<!DOCTYPE html><html><head><title>Help for package AmigaFFH</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {AmigaFFH}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#[.AmigaBasic'><p>Extract or replace lines of Amiga Basic code</p></a></li>
<li><a href='#amiga_display_keys'><p>A list of special display modes</p></a></li>
<li><a href='#amiga_display_modes'><p>A table of display modes on the Amiga and corresponding <code>raw</code> codes</p></a></li>
<li><a href='#amiga_monitors'><p>A list of Amiga monitors</p></a></li>
<li><a href='#amiga_palettes'><p>Commonly used palettes on the Commodore Amiga</p></a></li>
<li><a href='#AmigaBasic'><p>The S3 AmigaBasic class</p></a></li>
<li><a href='#AmigaBasic-files'><p>'demo.bas', 'r_logo.shp' and 'ball.shp' as example files for AmigaBasic and AmigaBasicShape objects</p></a></li>
<li><a href='#AmigaBasic.reserved'><p>List Amiga Basic reserved words.</p></a></li>
<li><a href='#AmigaBasicBMAP'><p>The S3 AmigaBasicBMAP class</p></a></li>
<li><a href='#AmigaBasicShape'><p>The S3 AmigaBasicShape class</p></a></li>
<li><a href='#AmigaBitmapFont'><p>The S3 AmigaBitmapFont and AmigaBitmapFontSet classes</p></a></li>
<li><a href='#AmigaFFH-package'><p>The Amiga File Format Handler package</p></a></li>
<li><a href='#AmigaIcon'><p>The S3 AmigaIcon class</p></a></li>
<li><a href='#as.AmigaBasic'><p>Coerce raw or character data to an AmigaBasic class object</p></a></li>
<li><a href='#as.AmigaBasicBMAP'><p>Coerce raw or named list to an AmigaBasicBMAP class object</p></a></li>
<li><a href='#as.character'><p>Coerce an AmigaBasic class object to its character representation</p></a></li>
<li><a href='#as.raster.AmigaBasicShape'><p>Convert AmigaFFH objects into grDevices raster images</p></a></li>
<li><a href='#as.raw.AmigaBasic'><p>Convert AmigaFFH objects into raw data</p></a></li>
<li><a href='#availableFontSizes'><p>Get available font sizes from an AmigaBitmapFontSet</p></a></li>
<li><a href='#bitmapToRaster'><p>Convert an Amiga bitmap image into a raster</p></a></li>
<li><a href='#c'><p>Combine multiple AmigaFFH objects</p></a></li>
<li><a href='#check.names.AmigaBasic'><p>Check Amiga Basic label/variable names for validity</p></a></li>
<li><a href='#colourToAmigaRaw'><p>Convert colours to Amiga compatible raw data or vice versa</p></a></li>
<li><a href='#deltaFibonacciCompress'><p>(De)compress 8-bit continuous signals.</p></a></li>
<li><a href='#dither'><p>Image dithering</p></a></li>
<li><a href='#font_example'><p>An example object for the AmigaBitmapFontSet class</p></a></li>
<li><a href='#fontName'><p>Extract or replace a font name</p></a></li>
<li><a href='#getAmigaBitmapFont'><p>Extract a specific AmigaBitmapFont from a AmigaBitmapFontSet</p></a></li>
<li><a href='#getIFFChunk'><p>Get a specific IFFChunk nested inside other IFFChunks</p></a></li>
<li><a href='#hardwareSprite-class'><p>The hardwareSprite class</p></a></li>
<li><a href='#IFFChunk-class'><p>A class structure to represent IFF files</p></a></li>
<li><a href='#IFFChunk-method'><p>Coerce to and create IFFChunk objects</p></a></li>
<li><a href='#ilbm8lores.iff'><p>An example file of a bitmap image stored in the Interchange File Format</p></a></li>
<li><a href='#index.colours'><p>Quantisation of colours and indexing a grDevices raster image</p></a></li>
<li><a href='#interpretIFFChunk'><p>Interpret an IFFChunk object</p></a></li>
<li><a href='#names.AmigaBasic'><p>Extract or replace variable and label names from Amiga Basic scripts</p></a></li>
<li><a href='#packBitmap'><p>A routine to (un)pack bitmap data</p></a></li>
<li><a href='#play'><p>Playing Amiga audio data</p></a></li>
<li><a href='#plot.AmigaBasicShape'><p>Plot AmigaFFH objects</p></a></li>
<li><a href='#rasterToAmigaBasicShape'><p>Convert a grDevices raster object into an AmigaBasicShape class object.</p></a></li>
<li><a href='#rasterToAmigaBitmapFont'><p>Convert a raster image into an AmigaBitmapFont</p></a></li>
<li><a href='#rasterToBitmap'><p>Convert a grDevices <code>raster</code> object into binary bitmap data</p></a></li>
<li><a href='#rasterToHWSprite'><p>Convert a raster object into an hardwareSprite object</p></a></li>
<li><a href='#rasterToIFF'><p>Convert a grDevices raster image into an IFF formated bitmap image</p></a></li>
<li><a href='#rawToAmigaBasic'><p>Coerce raw data into an AmigaBasic class object</p></a></li>
<li><a href='#rawToAmigaBasicBMAP'><p>Coerce raw data into an AmigaBasicBMAP class object</p></a></li>
<li><a href='#rawToAmigaBasicShape'><p>Coerce raw data into an AmigaBasicShape class object</p></a></li>
<li><a href='#rawToAmigaBitmapFont'><p>Coerce raw data into an AmigaBitmapFont class object</p></a></li>
<li><a href='#rawToAmigaBitmapFontSet'><p>Coerce raw data into an AmigaBitmapFontSet class object</p></a></li>
<li><a href='#rawToAmigaIcon'><p>Coerce raw data into an AmigaIcon class object</p></a></li>
<li><a href='#rawToHWSprite'><p>Convert raw data into an Amiga hardware sprite</p></a></li>
<li><a href='#rawToIFFChunk'><p>Coerce raw data to an IFFChunk class object</p></a></li>
<li><a href='#rawToSysConfig'><p>Coerce raw data into a SysConfig class object</p></a></li>
<li><a href='#read.AmigaBasic'><p>Read Amiga Basic files</p></a></li>
<li><a href='#read.AmigaBasicBMAP'><p>Read and write Amiga Basic BMAP files</p></a></li>
<li><a href='#read.AmigaBasicShape'><p>Read Amiga Basic Shape files</p></a></li>
<li><a href='#read.AmigaBitmapFont'><p>Read an AmigaBitmapFont class object from a file</p></a></li>
<li><a href='#read.AmigaBitmapFontSet'><p>Read AmigaBitmapFontSet from *.font file</p></a></li>
<li><a href='#read.AmigaIcon'><p>Read an Amiga Workbench icon (info) file</p></a></li>
<li><a href='#read.iff'><p>Read Interchange File Format (IFF)</p></a></li>
<li><a href='#read.SysConfig'><p>Read an Amiga system-configuration file</p></a></li>
<li><a href='#simpleAmigaIcon'><p>Create simple AmigaIcon objects</p></a></li>
<li><a href='#simpleSysConfig'><p>Function to generate a simple Amiga system-configuration representation</p></a></li>
<li><a href='#SysConfig'><p>The S3 SysConfig class</p></a></li>
<li><a href='#timeval'><p>Get an Amiga timeval struct value from raw data</p></a></li>
<li><a href='#WaveToIFF'><p>Convert WaveMC objects into an Interchange File Format object</p></a></li>
<li><a href='#write.AmigaBasic'><p>Write an AmigaBasic object to a file</p></a></li>
<li><a href='#write.AmigaBasicShape'><p>Write an AmigaBasicShape object to a file</p></a></li>
<li><a href='#write.AmigaBitmapFont'><p>Write an AmigaBitmapFont(set) file</p></a></li>
<li><a href='#write.AmigaIcon'><p>Write an Amiga Workbench icon (info) file</p></a></li>
<li><a href='#write.iff'><p>Write Interchange File Format (IFF)</p></a></li>
<li><a href='#write.SysConfig'><p>Write an Amiga system-configuration file</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Commodore Amiga File Format Handler</td>
</tr>
<tr>
<td>Version:</td>
<td>0.4.5</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-02-28</td>
</tr>
<tr>
<td>Author:</td>
<td>Pepijn de Vries [aut, cre, dtc]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Pepijn de Vries &lt;pepijn.devries@outlook.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Modern software often poorly support older file formats. This
    package intends to handle many file formats that were native to the
    antiquated Commodore Amiga machine. This package focuses on file types from
    the older Amiga operating systems (&lt;= 3.0). It will read and write specific
    file formats and coerces them into more contemporary data.</td>
</tr>
<tr>
<td>Depends:</td>
<td>tuneR (&ge; 1.0), R (&ge; 2.10)</td>
</tr>
<tr>
<td>Imports:</td>
<td>grDevices, methods, utils, vctrs</td>
</tr>
<tr>
<td>Suggests:</td>
<td>ProTrackR (&ge; 0.3.4), adfExplorer (&ge; 0.1.4)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>LazyData:</td>
<td>True</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://pepijn-devries.github.io/AmigaFFH/">https://pepijn-devries.github.io/AmigaFFH/</a>,
<a href="https://github.com/pepijn-devries/AmigaFFH/">https://github.com/pepijn-devries/AmigaFFH/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/pepijn-devries/AmigaFFH/issues">https://github.com/pepijn-devries/AmigaFFH/issues</a></td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-02-28 22:34:27 UTC; vries171</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-02-29 08:20:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='+5B.AmigaBasic'>Extract or replace lines of Amiga Basic code</h2><span id='topic++5B.AmigaBasic'></span><span id='topic++5B+3C-.AmigaBasic'></span><span id='topic++60+5B+5B.AmigaBasic+60'></span><span id='topic++5B+5B.AmigaBasic'></span><span id='topic++60+5B+5B+3C-.AmigaBasic+60'></span><span id='topic++5B+5B+3C-.AmigaBasic'></span>

<h3>Description</h3>

<p>Extract or replace lines of Amiga Basic code
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'AmigaBasic'
x[i]

## S3 replacement method for class 'AmigaBasic'
x[i] &lt;- value

## S3 method for class 'AmigaBasic'
x[[i]]

## S3 replacement method for class 'AmigaBasic'
x[[i]] &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B5B.AmigaBasic_+3A_x">x</code></td>
<td>
<p>An <code>AmigaBasic</code> class object from which specific lines
need to be extracted or replaced.</p>
</td></tr>
<tr><td><code id="+2B5B.AmigaBasic_+3A_i">i</code></td>
<td>
<p>In case of <code style="white-space: pre;">&#8288;[[', an integer index, representing the line-number of basic code to be selected. In case of &#8288;</code>[': a <code>vector</code> of <code>numeric</code> indices. This index
is used to select specific lines. Negative values will deselect lines.</p>
</td></tr>
<tr><td><code id="+2B5B.AmigaBasic_+3A_value">value</code></td>
<td>
<p>A <code>vector</code> of <code>character</code> strings or an
<code><a href="#topic+AmigaBasic">AmigaBasic()</a></code> class object that is used to replace
the selected indices <code>i</code>. <code>value</code> should represent the
same number of lines of code as the selected number of lines.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Extract or replace specific lines in an <code><a href="#topic+AmigaBasic">AmigaBasic()</a></code>-class object.
</p>


<h3>Value</h3>

<p>The extraction method returns an <code><a href="#topic+AmigaBasic">AmigaBasic()</a></code> object based in the lines selected with <code>i</code>.
The replacement method returns an <code><a href="#topic+AmigaBasic">AmigaBasic()</a></code> object with the selected lines replaced with <code>value</code>.
</p>


<h3>Author(s)</h3>

<p>Pepijn de Vries
</p>


<h3>See Also</h3>

<p>Other AmigaBasic.operations: 
<code><a href="#topic+AmigaBasic.reserved">AmigaBasic.reserved</a>()</code>,
<code><a href="#topic+AmigaBasicBMAP">AmigaBasicBMAP</a></code>,
<code><a href="#topic+AmigaBasic">AmigaBasic</a></code>,
<code><a href="#topic+as.AmigaBasicBMAP">as.AmigaBasicBMAP</a>()</code>,
<code><a href="#topic+as.AmigaBasic">as.AmigaBasic</a>()</code>,
<code><a href="#topic+as.character">as.character</a>()</code>,
<code><a href="#topic+check.names.AmigaBasic">check.names.AmigaBasic</a>()</code>,
<code><a href="#topic+names.AmigaBasic">names.AmigaBasic</a>()</code>,
<code><a href="#topic+rawToAmigaBasicBMAP">rawToAmigaBasicBMAP</a>()</code>,
<code><a href="#topic+rawToAmigaBasic">rawToAmigaBasic</a>()</code>,
<code><a href="#topic+read.AmigaBasicBMAP">read.AmigaBasicBMAP</a>()</code>,
<code><a href="#topic+read.AmigaBasic">read.AmigaBasic</a>()</code>,
<code><a href="#topic+write.AmigaBasic">write.AmigaBasic</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## First generate a few lines of Basic code:
bas &lt;- as.AmigaBasic(c(
  "LET a = 1",
  "a = a + 1",
  "PRINT \"a now equals\";a",
  "INPUT \"clear screen (y/n)? \", b$",
  "IF UCASE$(b$) = \"Y\" THEN CLS"
))

## Select only lines 4 and 5:
bas[4:5]

## use negative indices to deselect specific lines.
## deselect line 2:
bas[-2]

## replace line 2
bas[2] &lt;- "a = a + 2"

## You can also use AmigaBasic class object as replacement
bas[2] &lt;- as.AmigaBasic("a = a + 3")

## single lines can also be selected with '[['
bas[[2]]

## End(Not run)
</code></pre>

<hr>
<h2 id='amiga_display_keys'>A list of special display modes</h2><span id='topic+amiga_display_keys'></span>

<h3>Description</h3>

<p>A list of special display modes on the Amiga and corresponding <code>raw</code> keys.
</p>


<h3>Format</h3>


<p>A <code>data.frame</code> with 2 columns:
</p>

<ul>
<li><p> The column named 'mode': a <code>factor</code> reflecting a display mode, monitor or bitwise mask
</p>
</li>
<li><p> The column named 'code': vector of 4 <code>raw</code> values as used by the Amiga to reflect specific display modes</p>
</li></ul>




<h3>Details</h3>

<p>This table show specific special display modes and to which Amiga monitors they
relate. The <code>raw</code> codes can be used to interpret specific display modes
as listed in <code><a href="#topic+amiga_display_modes">amiga_display_modes()</a></code>. This information is used to
interpret <code><a href="#topic+IFFChunk">IFFChunk()</a></code> objects of type 'CAMG'. It is also used to
interpret ILBM images and creating IFF files from raster images.
</p>


<h3>References</h3>

<p><a href="https://wiki.amigaos.net/wiki/Display_Database#ModeID_Identifiers">https://wiki.amigaos.net/wiki/Display_Database#ModeID_Identifiers</a>
</p>
<p><a href="http://amigadev.elowar.com/read/ADCD_2.1/AmigaMail_Vol2_guide/node00FD.html">http://amigadev.elowar.com/read/ADCD_2.1/AmigaMail_Vol2_guide/node00FD.html</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("amiga_display_keys")
</code></pre>

<hr>
<h2 id='amiga_display_modes'>A table of display modes on the Amiga and corresponding <code>raw</code> codes</h2><span id='topic+amiga_display_modes'></span>

<h3>Description</h3>

<p>A table of display modes on the Amiga and corresponding <code>raw</code> codes
representing these modes.
</p>


<h3>Format</h3>


<p>A <code>data.frame</code> with 4 columns:
</p>

<ul>
<li><p> The column named 'DISPLAY_MODE': a <code>factor</code> reflecting
the display mode
</p>
</li>
<li><p> The column named 'DISPLAY_MODE_ID': A <code>list</code> containing a <code>vector</code>
of 4 <code>raw</code> values as used by the Amiga to reflect specific display modes.
These raw values are usually also stored with bitmap images in the Interchange
File Format in a <code><a href="#topic+IFFChunk">IFFChunk()</a></code> called 'CAMG'.
</p>
</li>
<li><p> The column named 'MONITOR_ID': A <code>character</code> string identifying
the monitor that could display the specific mode.
</p>
</li>
<li><p> The column named 'CHIPSET': a <code>factor</code> identifying the minimal
chip set that was required to display the specific mode. OCS is the original
chip set; ECS is the Enhanced Chip Set. AGA is the Advanced Graphics Architecture
chip set (in some countries known as just Advanced Architecture). AGA could
also display OCS and ECS modes, ECS could also display OCS modes, OCS could only
display OCS modes.</p>
</li></ul>




<h3>Details</h3>

<p>This table contains most display modes that were available on the Amiga.
It also contains <code>raw</code> codes that were used to represent these modes.
The table also contains the hardware monitors that could display the specific
modes, and the minimal chip set that was required for the display mode.
This data is used to interpret <code><a href="#topic+IFFChunk">IFFChunk()</a></code> objects of type
'CAMG'. It is also used to interpret ILBM images and creating IFF files from
raster images.
</p>


<h3>References</h3>

<p><a href="https://wiki.amigaos.net/wiki/Display_Database#ModeID_Identifiers">https://wiki.amigaos.net/wiki/Display_Database#ModeID_Identifiers</a>
</p>
<p><a href="http://amigadev.elowar.com/read/ADCD_2.1/AmigaMail_Vol2_guide/node00FD.html">http://amigadev.elowar.com/read/ADCD_2.1/AmigaMail_Vol2_guide/node00FD.html</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("amiga_display_modes")
</code></pre>

<hr>
<h2 id='amiga_monitors'>A list of Amiga monitors</h2><span id='topic+amiga_monitors'></span>

<h3>Description</h3>

<p>This table lists Amiga monitors and corresponding <code>raw</code> codes that represent
these monitors.
</p>


<h3>Format</h3>


<p>A <code>data.frame</code> with 2 columns:
</p>

<ul>
<li><p> The column named 'MONITOR_ID': a <code>factor</code> representing an Amiga monitor
</p>
</li>
<li><p> The column named 'CODE': A <code>list</code> containing a <code>vector</code> of 4
<code>raw</code> values as used by the Amiga to represent a specific monitor.</p>
</li></ul>




<h3>Details</h3>

<p>This table contains monitors that were compatible with the Amiga.
It also contains <code>raw</code> codes that were used to represent them.
This data is used to interpret <code><a href="#topic+IFFChunk">IFFChunk()</a></code> objects of type
'CAMG'. It is also used to interpret ILBM images and creating IFF files from
raster images.
</p>


<h3>References</h3>

<p><a href="https://wiki.amigaos.net/wiki/Display_Database#ModeID_Identifiers">https://wiki.amigaos.net/wiki/Display_Database#ModeID_Identifiers</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("amiga_monitors")
</code></pre>

<hr>
<h2 id='amiga_palettes'>Commonly used palettes on the Commodore Amiga</h2><span id='topic+amiga_palettes'></span>

<h3>Description</h3>

<p><code>amiga_palettes</code> is a named list, where each element represents a commonly
used palette on the Commodore Amiga.
</p>


<h3>Format</h3>


<p>A named list with the following elements:
</p>

<ul>
<li> <p><code>wb.os1</code>: A <code>vector</code> of 4 colours that were used as the default
palette of the Workbench on Amiga OS 1.x.
</p>
</li>
<li> <p><code>wb.os2</code>: A <code>vector</code> of 8 colours. The first 4 colours are the default
colours of a standard Workbench on Amiga OS 2.x. The latter 4 are additional
colours used by the Workbench expansion MagicWB.
</p>
</li>
<li> <p><code>spr.os1</code>: A <code>vector</code> of 3 colours that were used by default
for a mouse pointer sprite on Amiga OS 1.x.
</p>
</li>
<li> <p><code>spr.os2</code>: A <code>vector</code> of 3 colours that were used by default
for a mouse pointer sprite on Amiga OS 2.x.</p>
</li></ul>




<h3>Details</h3>

<p>Some files that contain bitmap images with an indexed palette did not store the
palette in the same file. Amiga Workbench icons (<code><a href="#topic+AmigaIcon">AmigaIcon()</a></code>) for instance
only store the index values of the palette, but not the palette itself.
<code>amiga_palettes</code> therefore provides some commonly used palettes on the Amiga,
such that these files can be interpreted.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("amiga_palettes")
</code></pre>

<hr>
<h2 id='AmigaBasic'>The S3 AmigaBasic class</h2><span id='topic+AmigaBasic'></span>

<h3>Description</h3>

<p>A class that represents the content of Amiga Basic files.
</p>


<h3>Details</h3>

<p>Amiga Basic is a <a href="https://en.wikipedia.org/wiki/BASIC">BASIC</a>-style programming language that was shipped
with early Commodore Amiga machines. It requires an interpreter to run an Amiga Basic script. The AmigaFFH
package does not interpret Amiga Basic scripts. It does allow for encoding and decoding scripts in the binary
format in which it was originally stored on the Amiga. Amiga Basic scripts were stored as encoded binaries instead
of ASCII text files in order to save (at the time precious) memory and disk space.
</p>
<p>Amiga Basic binary files start with a file header (as an identifier) and is followed by each line of the script
as binary data. The <code>AmigaBasic</code>-class object stores each line of the script as a <code>list</code> item as a <code>vector</code>
of <code>raw</code> data. Use <code><a href="#topic+as.character">as.character()</a></code> and <code><a href="#topic+as.AmigaBasic">as.AmigaBasic()</a></code> to switch between
<code>character</code> data and <code>AmigaBasic</code>-class objects.
</p>


<h3>Note</h3>

<p>Although there is ample reference material on the Amiga BASIC language, there is no documentation
available on the script file storage format. The implementation in the AmigaFFH package is all the result of
painstaking reverse engineering on my part. Consequently the Amiga Basic file encoders and decoders implemented
here may not be infallible.
</p>


<h3>Author(s)</h3>

<p>Pepijn de Vries
</p>


<h3>References</h3>

<p><a href="https://en.wikipedia.org/wiki/AmigaBASIC">https://en.wikipedia.org/wiki/AmigaBASIC</a>
</p>


<h3>See Also</h3>

<p>Other AmigaBasic.operations: 
<code><a href="#topic+AmigaBasic.reserved">AmigaBasic.reserved</a>()</code>,
<code><a href="#topic+AmigaBasicBMAP">AmigaBasicBMAP</a></code>,
<code><a href="#topic++5B.AmigaBasic">[.AmigaBasic</a>()</code>,
<code><a href="#topic+as.AmigaBasicBMAP">as.AmigaBasicBMAP</a>()</code>,
<code><a href="#topic+as.AmigaBasic">as.AmigaBasic</a>()</code>,
<code><a href="#topic+as.character">as.character</a>()</code>,
<code><a href="#topic+check.names.AmigaBasic">check.names.AmigaBasic</a>()</code>,
<code><a href="#topic+names.AmigaBasic">names.AmigaBasic</a>()</code>,
<code><a href="#topic+rawToAmigaBasicBMAP">rawToAmigaBasicBMAP</a>()</code>,
<code><a href="#topic+rawToAmigaBasic">rawToAmigaBasic</a>()</code>,
<code><a href="#topic+read.AmigaBasicBMAP">read.AmigaBasicBMAP</a>()</code>,
<code><a href="#topic+read.AmigaBasic">read.AmigaBasic</a>()</code>,
<code><a href="#topic+write.AmigaBasic">write.AmigaBasic</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## This creates an AmigaBasic-class object:
bas &lt;- as.AmigaBasic("PRINT \"hello world!\"")

## This will decode the object as plain text:
as.character(bas)

## End(Not run)
</code></pre>

<hr>
<h2 id='AmigaBasic-files'>'demo.bas', 'r_logo.shp' and 'ball.shp' as example files for AmigaBasic and AmigaBasicShape objects</h2><span id='topic+AmigaBasic-files'></span><span id='topic+demo.bas'></span><span id='topic+r_logo.shp'></span><span id='topic+ball.shp'></span>

<h3>Description</h3>

<p>'demo.bas', 'r_logo.shp' and 'ball.shp' as example files for <code><a href="#topic+AmigaBasic">AmigaBasic()</a></code> and
<code><a href="#topic+AmigaBasicShape">AmigaBasicShape()</a></code> objects
</p>


<h3>Format</h3>


<p>See <code><a href="#topic+AmigaBasic">AmigaBasic()</a></code> and <code><a href="#topic+AmigaBasicShape">AmigaBasicShape()</a></code> for more information
about the format.
</p>


<h3>Details</h3>

<p>The 'r_logo.shp' and 'ball.shp' files are formatted such that they can be read with
<code><a href="#topic+read.AmigaBasicShape">read.AmigaBasicShape()</a></code>. They serve as an example of the <code><a href="#topic+AmigaBasicShape">AmigaBasicShape()</a></code> class, where
the first represents a blitter object, and the latter a sprite.
</p>
<p>The 'demo.bas' file is an example of a binary encoded <a href="#topic+AmigaBasic">Amiga Basic</a> script. It can be read with
<code><a href="#topic+read.AmigaBasic">read.AmigaBasic()</a></code>. The script demonstrates how the shape files could be used in Amiga Basic.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
read.AmigaBasic(system.file("demo.bas", package = "AmigaFFH"))
read.AmigaBasicShape(system.file("ball.shp", package = "AmigaFFH"))
read.AmigaBasicShape(system.file("r_logo.shp", package = "AmigaFFH"))

## End(Not run)
</code></pre>

<hr>
<h2 id='AmigaBasic.reserved'>List Amiga Basic reserved words.</h2><span id='topic+AmigaBasic.reserved'></span>

<h3>Description</h3>

<p>Obtain a list of reserved Amiga Basic words. These words are not
allowed as names of variables or labels in Amiga Basic.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AmigaBasic.reserved()
</code></pre>


<h3>Details</h3>

<p>This function will return a full list of reserved Amiga Basic
words. This list does not serve as a manual for basic (for
that purpose consult external resources). This list is meant to
consult when choosing label names in Amiga Basic code. These
reserved words are not allowed as names.
</p>


<h3>Value</h3>

<p>Returns a <code>vecor</code> of <code>character</code> strings of
reserved Amiga Basic words.
</p>


<h3>Author(s)</h3>

<p>Pepijn de Vries
</p>


<h3>See Also</h3>

<p>Other AmigaBasic.operations: 
<code><a href="#topic+AmigaBasicBMAP">AmigaBasicBMAP</a></code>,
<code><a href="#topic+AmigaBasic">AmigaBasic</a></code>,
<code><a href="#topic++5B.AmigaBasic">[.AmigaBasic</a>()</code>,
<code><a href="#topic+as.AmigaBasicBMAP">as.AmigaBasicBMAP</a>()</code>,
<code><a href="#topic+as.AmigaBasic">as.AmigaBasic</a>()</code>,
<code><a href="#topic+as.character">as.character</a>()</code>,
<code><a href="#topic+check.names.AmigaBasic">check.names.AmigaBasic</a>()</code>,
<code><a href="#topic+names.AmigaBasic">names.AmigaBasic</a>()</code>,
<code><a href="#topic+rawToAmigaBasicBMAP">rawToAmigaBasicBMAP</a>()</code>,
<code><a href="#topic+rawToAmigaBasic">rawToAmigaBasic</a>()</code>,
<code><a href="#topic+read.AmigaBasicBMAP">read.AmigaBasicBMAP</a>()</code>,
<code><a href="#topic+read.AmigaBasic">read.AmigaBasic</a>()</code>,
<code><a href="#topic+write.AmigaBasic">write.AmigaBasic</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>AmigaBasic.reserved()
</code></pre>

<hr>
<h2 id='AmigaBasicBMAP'>The S3 AmigaBasicBMAP class</h2><span id='topic+AmigaBasicBMAP'></span>

<h3>Description</h3>

<p>A class that represents the content of Amiga Basic BMAP files.
</p>


<h3>Details</h3>

<p>The Amiga operating system made use of library files to execute specific (repetitive/routine) tasks. Amiga Basic
was also able to call such routines from library files. In order to do so, it required a 'bmap' file for each
library. This file contains a map of the library where it specifies: the name of routine; the &lsquo;Library Vector Offset&rsquo;
(explained below); and used CPU registers (explained below).
</p>
<p>The &lsquo;Library Vector Offset&rsquo; is an offset to the base address of a library in memory. This offsets indicates where
a specific executable routine starts. The CPU registers are used to (temporary) store (pointers to) input data
used by the routine. The BMAP file thus lists which CPU registers are used by specified routines.
</p>


<h3>Author(s)</h3>

<p>Pepijn de Vries
</p>


<h3>References</h3>

<p><a href="https://en.wikipedia.org/wiki/AmigaOS#Libraries_and_devices">https://en.wikipedia.org/wiki/AmigaOS#Libraries_and_devices</a>
</p>


<h3>See Also</h3>

<p>Other AmigaBasic.operations: 
<code><a href="#topic+AmigaBasic.reserved">AmigaBasic.reserved</a>()</code>,
<code><a href="#topic+AmigaBasic">AmigaBasic</a></code>,
<code><a href="#topic++5B.AmigaBasic">[.AmigaBasic</a>()</code>,
<code><a href="#topic+as.AmigaBasicBMAP">as.AmigaBasicBMAP</a>()</code>,
<code><a href="#topic+as.AmigaBasic">as.AmigaBasic</a>()</code>,
<code><a href="#topic+as.character">as.character</a>()</code>,
<code><a href="#topic+check.names.AmigaBasic">check.names.AmigaBasic</a>()</code>,
<code><a href="#topic+names.AmigaBasic">names.AmigaBasic</a>()</code>,
<code><a href="#topic+rawToAmigaBasicBMAP">rawToAmigaBasicBMAP</a>()</code>,
<code><a href="#topic+rawToAmigaBasic">rawToAmigaBasic</a>()</code>,
<code><a href="#topic+read.AmigaBasicBMAP">read.AmigaBasicBMAP</a>()</code>,
<code><a href="#topic+read.AmigaBasic">read.AmigaBasic</a>()</code>,
<code><a href="#topic+write.AmigaBasic">write.AmigaBasic</a>()</code>
</p>

<hr>
<h2 id='AmigaBasicShape'>The S3 AmigaBasicShape class</h2><span id='topic+AmigaBasicShape'></span>

<h3>Description</h3>

<p>A class that represents the file format used by Amiga Basic to store bitmap graphics: blitter objects and sprites.
</p>


<h3>Details</h3>

<p>Amiga Basic used a specific format to store bitmap images that could be displayed using Basic code. Both
sprites and blitter objects can be stored and used. This class is used to represent such files.
</p>


<h3>Author(s)</h3>

<p>Pepijn de Vries
</p>


<h3>See Also</h3>

<p>Other AmigaBasicShape.operations: 
<code><a href="#topic+rasterToAmigaBasicShape">rasterToAmigaBasicShape</a>()</code>,
<code><a href="#topic+read.AmigaBasicShape">read.AmigaBasicShape</a>()</code>,
<code><a href="#topic+write.AmigaBasicShape">write.AmigaBasicShape</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
ball   &lt;- read.AmigaBasicShape(system.file("ball.shp", package = "AmigaFFH"))
r_logo &lt;- read.AmigaBasicShape(system.file("r_logo.shp", package = "AmigaFFH"))

plot(ball)
plot(r_logo)

## End(Not run)
</code></pre>

<hr>
<h2 id='AmigaBitmapFont'>The S3 AmigaBitmapFont and AmigaBitmapFontSet classes</h2><span id='topic+AmigaBitmapFont'></span><span id='topic+AmigaBitmapFontSet'></span>

<h3>Description</h3>

<p>A comprehensive representation of monochromous Amiga bitmap fonts.
</p>


<h3>Details</h3>

<p>Nowadays fonts are represented by vector graphics an computer systems.
On the original Commodore Amiga, the screen resolution, system memory
and cpu speed were limited. On those systems, it was more efficient
to use bitmap images to represent the glyphs in fonts. The
<code>AmigaBitmapFontSet</code> and <code>AmigaBitmapFont</code> classes can be used
to represent Amiga bitmap fonts.
</p>
<p>The Commodore Amiga had a directory named 'FONTS' located in the
root, where (bitmap) fonts were stored. Font sets were stored
under the font name with a *.font extension. Files with the *.font
extension did not contain the bitmap images of the font. Rather
the *.font file contained information on which font heights (in
pixels) are available, in addition to some other meta-information.
</p>
<p>The bitmap images were stored in separate files for each individual
height. The <code>AmigaBitmapFontSet</code> is an S3 class that forms
a comprehensive format (named <code>list</code>) to represent the *.font
files. The <code>AmigaBitmapFont</code> is an S3 class is a comprehensive
format (named <code>list</code>) that represent each font bitmap and glyph
information. The <code>AmigaBitmapFontSet</code> objects will hold one or more
<code>AmigaBitmapFont</code> objects.
</p>
<p>The <code>AmigaBitmapFont</code> and <code>AmigaBitmapFontSet</code> objects are
essentially named <code>list</code>s. Their structure and most important
elements are described below. Although it is possible to replace
elements manually, it is only advisable when you know what you
are doing as it may break the validity of the font.
</p>


<h3>AmigaBitmapFontSet</h3>


<ul>
<li> <p><code>fch_FileID</code>: A <code>factor</code> with levels 'FontContents', 'TFontContents' and
'ScalableOutline'. It specifies the type of font.
Currently only the first level is supported.
</p>
</li>
<li> <p><code>fch_NumEntries</code>: number of font heights available for this font. It should
match with the length of <code>FontContents</code>. Do not change
this value manually.
</p>
</li>
<li> <p><code>FontContents</code>: This is a <code>list</code> with bitmap entries for each specific font
height (in pixels). The name of each element in this list is
'pt' followed by the height. Each element in this list holds
the elements:
</p>

<ul>
<li><p> Miscellaneous: Miscellaneous information from the \*.font file
</p>

<ul>
<li> <p><code>fc_FileName</code>: This element represents the filename of the
nested font bitmap images. Note that it should be a valid
Commodore Amiga filename. It is best to modify this name
using <code><a href="#topic+fontName">fontName()</a></code>. Note that this field could cause
problems as Commodore Amiga filenames can contain characters
that most modern platforms would not allow (such as the
question mark).
</p>
</li>
<li> <p><code>BitmapFont</code>: This element is of type <code>AmigaBitmapFont</code> and is structured
as described in the following section. The information in this
element is no longer part of the *.font file.
</p>
</li></ul>

</li></ul>

</li></ul>



<h3>AmigaBitmapFont</h3>

<p>Information represented by a <code>AmigaBitmapFont</code> is not stored
in *.font files. Rather it is stored in sub-directories of the font
in separate files. It has the following structure:
</p>

<ul>
<li><p> Miscellaneous: Elements with information on the font
properties and style, and also relative file pointers.
</p>
</li>
<li> <p><code>glyph.info</code>: A <code>data.frame</code> containing glyph info with information
for specific glyphs on each row. Each row matches with a specific
ASCII code, ranging from <code>tf_LoChar</code> up to <code>tf_HiChar</code>. There is an additional
row that contains information for the default glyph that is
out of the range of the <code>tf_LoChar</code> and <code>tf_HiChar</code>. The <code>data.frame</code>
thus has <code>2 + tf_HiChar - tf_LoChar</code> rows. This
table is used to extract and plot a glyph from the
<code>bitmap</code> image correctly.
</p>
</li>
<li> <p><code>bitmap</code>: Is a monochromous bitmap image of all the font's glyphs in a
single line. It is a simple <code>raster</code> object
(see <code><a href="grDevices.html#topic+as.raster">grDevices::as.raster()</a></code>) with an additional
attribute 'palette', which lists the two colours in the image. In
this palette, the first colour is the background colour and the
second colour is interpreted as the foregroundcolour.
</p>
</li></ul>



<h3>Useful functions</h3>

<p>For importing and exporting the following functions are useful:
<code><a href="#topic+read.AmigaBitmapFont">read.AmigaBitmapFont()</a></code>, <code><a href="#topic+read.AmigaBitmapFontSet">read.AmigaBitmapFontSet()</a></code>,
<code><a href="#topic+write.AmigaBitmapFont">write.AmigaBitmapFont()</a></code> and <code><a href="#topic+write.AmigaBitmapFontSet">write.AmigaBitmapFontSet()</a></code>.
</p>
<p>The following generic functions are implemented for these objects:
<code><a href="#topic+plot">plot()</a></code>, <code>print</code>,
<code><a href="#topic+as.raster">as.raster()</a></code> and <code><a href="#topic+as.raw">as.raw()</a></code>.
</p>
<p>Use <code><a href="#topic+c">c()</a></code> to combine one or more
<code>AmigaBitmapFont</code> objects into a <code>AmigaBitmapFontSet</code>.
</p>


<h3>Author(s)</h3>

<p>Pepijn de Vries
</p>


<h3>References</h3>

<p><a href="http://amigadev.elowar.com/read/ADCD_2.1/Libraries_Manual_guide/node03E0.html">http://amigadev.elowar.com/read/ADCD_2.1/Libraries_Manual_guide/node03E0.html</a>
<a href="http://amigadev.elowar.com/read/ADCD_2.1/Libraries_Manual_guide/node03DE.html">http://amigadev.elowar.com/read/ADCD_2.1/Libraries_Manual_guide/node03DE.html</a>
<a href="http://amigadev.elowar.com/read/ADCD_2.1/Libraries_Manual_guide/node05BA.html">http://amigadev.elowar.com/read/ADCD_2.1/Libraries_Manual_guide/node05BA.html</a>
</p>


<h3>See Also</h3>

<p>Other AmigaBitmapFont.operations: 
<code><a href="#topic+availableFontSizes">availableFontSizes</a>()</code>,
<code><a href="#topic+c">c</a>()</code>,
<code><a href="#topic+fontName">fontName</a>()</code>,
<code><a href="#topic+font_example">font_example</a></code>,
<code><a href="#topic+getAmigaBitmapFont">getAmigaBitmapFont</a>()</code>,
<code><a href="#topic+rasterToAmigaBitmapFont">rasterToAmigaBitmapFont</a>()</code>,
<code><a href="#topic+rawToAmigaBitmapFontSet">rawToAmigaBitmapFontSet</a>()</code>,
<code><a href="#topic+rawToAmigaBitmapFont">rawToAmigaBitmapFont</a>()</code>,
<code><a href="#topic+read.AmigaBitmapFontSet">read.AmigaBitmapFontSet</a>()</code>,
<code><a href="#topic+read.AmigaBitmapFont">read.AmigaBitmapFont</a>()</code>,
<code><a href="#topic+write.AmigaBitmapFont">write.AmigaBitmapFont</a>()</code>
</p>
<p>Other raster.operations: 
<code><a href="#topic+as.raster.AmigaBasicShape">as.raster.AmigaBasicShape</a>()</code>,
<code><a href="#topic+bitmapToRaster">bitmapToRaster</a>()</code>,
<code><a href="#topic+dither">dither</a>()</code>,
<code><a href="#topic+index.colours">index.colours</a>()</code>,
<code><a href="#topic+rasterToAmigaBasicShape">rasterToAmigaBasicShape</a>()</code>,
<code><a href="#topic+rasterToAmigaBitmapFont">rasterToAmigaBitmapFont</a>()</code>,
<code><a href="#topic+rasterToBitmap">rasterToBitmap</a>()</code>,
<code><a href="#topic+rasterToHWSprite">rasterToHWSprite</a>()</code>,
<code><a href="#topic+rasterToIFF">rasterToIFF</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## 'font_example' is an example of the AmigaBitmapFontSet object:
data(font_example)

## An AmigaBitmapFont object can also be extracted from this object:
font_example_9 &lt;- getAmigaBitmapFont(font_example, 9)

## the objects can be printed, plotted, converted to raw data or a raster:
print(font_example)
plot(font_example)
font_example_raw    &lt;- as.raw(font_example)
font_example_raster &lt;- as.raster(font_example)

## You can also format text using the font:
formated_raster     &lt;- as.raster(font_example, text = "Foo bar", style = "bold")
plot(font_example, text = "Foo bar", style = "underlined", interpolate = F)

## End(Not run)
</code></pre>

<hr>
<h2 id='AmigaFFH-package'>The Amiga File Format Handler package</h2><span id='topic+AmigaFFH'></span><span id='topic+AmigaFFH-package'></span>

<h3>Description</h3>

<p>The Amiga File Format Handler package (AmigaFFH) is designed to interpret file formats that were native
to Commodore Amiga machines.
</p>


<h3>Details</h3>

<p>In combination with the adfExplorer package this package can be used to interpret older file formats that
were native to the Commodore Amiga. The focus of this package will be on the older system (Amiga OS &lt;= 3.0).
This will allow you to analyse and interpret these files in the scripted environment of R.
</p>
<p>Note that all functions and methods in this package are implemented as scripted source code and may not run
very fast.
</p>


<h3>Supported File Formats</h3>

<p>This package supports a number of file formats. The ProTracker module file format requires sophisticated interpretation
and a dedicated package (<a href="ProTrackR.html#topic+ProTrackR-package">ProTrackR</a>) is developed for that purpose.
</p>
<p>The following formats are supported by this package (to some extend):
</p>

<ul>
<li> <p><a href="#topic+AmigaBasic">Amiga Basic</a> binary encode scripts and
<a href="#topic+AmigaBasicShape">Amiga Basic shapes</a> which
were used by such scripts to display specific graphics.
</p>
</li>
<li><p> Bitmap Font (.font). Originally fonts were stored in separate files on
the Amiga. An overarching '.font' file contained generic information,
amongst others the specific pixel heights that were available for a font.
The actual font bitmap images were stored in separate files. There
was a file available for each individual font height. For more details
see <code><a href="#topic+AmigaBitmapFont">AmigaBitmapFont()</a></code> and <code><a href="#topic+AmigaBitmapFontSet">AmigaBitmapFontSet()</a></code>.
</p>
</li>
<li><p> Interchange File Format (IFF). This file format is actually a container for a wide variety of
data flavours. Of which the following are supported:
</p>

<ul>
<li><p> 8SVX (8-bit sampled voices (i.e., audio)). There are no major restrictions in this package's
implementation.
</p>
</li>
<li><p> ANIM (animations). Not all display modes are supported as per ILBM. Furthermore, the vertical byterun
encoding for the animation frames is the only encoding currently supported.
</p>
</li>
<li><p> ILBM (InterLeaved BitMap images). Specific display modes (such as 'extra halfbrite') can in
some cases be decoded, but encoding for these modes may not (yet) be supported.
</p>
</li></ul>

</li>
<li><p> For more details see <code><a href="#topic+IFFChunk">IFFChunk()</a></code>, <code><a href="#topic+interpretIFFChunk">interpretIFFChunk()</a></code>, <code><a href="#topic+read.iff">read.iff()</a></code> and
<code><a href="#topic+write.iff">write.iff()</a></code>.
</p>
</li>
<li><p> Hardware sprites. This format follows the hardware structure for displaying sprites on the screen.
It is usually not used
as a file format as such, but it can be found embedded in some files (for instance the mouse pointer
is embedded as a
hardware sprite in the 'system-configuration' file). For more details see <code><a href="#topic+hardwareSprite">hardwareSprite()</a></code>.
</p>
</li>
<li><p> System-configuration. A file that was stored in the 'devs' directory of a system disk.
As the file name suggests, it holds many of the systems configurations. See <a href="#topic+SysConfig">SysConfig</a>
for more details.
</p>
</li>
<li><p> Workbench icons (.info). Icons (i.e., graphical representation of files and directories
on the Amiga) were stored as separate files with the extension '.info'. See
<code><a href="#topic+AmigaIcon">AmigaIcon()</a></code> for more details.
</p>
</li></ul>

<p>In future versions of this package more file types may be added to this list.
</p>


<h3>In Addition...</h3>

<p>Several helper functions are also exported by this package. This will give you access
to older compression techniques, such as the run length encoding (<code><a href="#topic+packBitmap">packBitmap()</a></code>)
and delta Fibonacci compression (<code><a href="#topic+deltaFibonacciCompress">deltaFibonacciCompress()</a></code>). But also other
techniques that will help in converting modern files into classic file formats and vice versa.
Such as for instance the function to <code><a href="#topic+dither">dither()</a></code> full colour images to a limited
colour palette.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Pepijn de Vries <a href="mailto:pepijn.devries@outlook.com">pepijn.devries@outlook.com</a> [data contributor]
</p>


<h3>References</h3>

<p>Documentation on several Amiga File types:
<a href="http://amigadev.elowar.com/read/ADCD_2.1/Devices_Manual_guide/">http://amigadev.elowar.com/read/ADCD_2.1/Devices_Manual_guide/</a>
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://pepijn-devries.github.io/AmigaFFH/">https://pepijn-devries.github.io/AmigaFFH/</a>
</p>
</li>
<li> <p><a href="https://github.com/pepijn-devries/AmigaFFH/">https://github.com/pepijn-devries/AmigaFFH/</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/pepijn-devries/AmigaFFH/issues">https://github.com/pepijn-devries/AmigaFFH/issues</a>
</p>
</li></ul>


<hr>
<h2 id='AmigaIcon'>The S3 AmigaIcon class</h2><span id='topic+AmigaIcon'></span>

<h3>Description</h3>

<p>A comprehensive representation of an Amiga Workbench icon file.
</p>


<h3>Details</h3>

<p>Files, directories and other similar objects were depicted as icons on the
Amiga Workbench (the Amiga's equivalent of what is now mostly known as the computer's
desktop). Icons were actually separate files with the exact same name as the
file or directory it represents, except for an additional &lsquo;.info&rsquo; extension.
</p>
<p>In addition of being a graphical representation of files or directories, icon
files also contained additional information about the file. It could for instance
indicate which tool would be required to open the file.
</p>
<p>The classic Amiga Workbench icon file has a rather complex structure as it is
basically a dump of how it is stored in memory. As a result it contains many
memory pointers that are really not necassary to store in a file.
</p>
<p>The S3 AmigaIcon class is used to represent these complex files as a named
<code>list</code>. The elements in that <code>list</code> have mostly identical
names as listed in the document at the top referenced below. The names are usually
self-explanatory, but the referred documents can also be
consulted to obtain more detailed information with respect to each of
these elements. As pointed out earlier, not all elements will have a meaningful
use.
</p>
<p>It is possible to change the values of the list, but not all values may be valid.
Note that they will not be fully checked for validity. Invalid values may result in errors
when writing to a binary file using <code><a href="#topic+write.AmigaIcon">write.AmigaIcon()</a></code>, or may simply not
work properly on an Amiga or in an emulator.
</p>
<p>The original &lsquo;.info&rsquo; file could be extended with NewIcon or with an OS3.5
<code><a href="#topic+IFFChunk">IFFChunk()</a></code> data, that allowed for icons with larger colour depths.
These extensions are currently not implemented.
</p>
<p>Use <code><a href="#topic+simpleAmigaIcon">simpleAmigaIcon()</a></code> for creating a simple <code>AmigaIcon</code> object which can
be modified. Use <code><a href="#topic+read.AmigaIcon">read.AmigaIcon()</a></code> to read, and <code><a href="#topic+write.AmigaIcon">write.AmigaIcon()</a></code>
to write workbench icon files (*.info). With <code><a href="#topic+rawToAmigaIcon">rawToAmigaIcon()</a></code> and
<code><a href="#topic+as.raw">as.raw()</a></code> <code>AmigaIcon</code> can be coerced back and forth from
and to its raw (binary) form.
</p>


<h3>Author(s)</h3>

<p>Pepijn de Vries
</p>


<h3>References</h3>

<p><a href="http://www.evillabs.net/index.php/Amiga_Icon_Formats">http://www.evillabs.net/index.php/Amiga_Icon_Formats</a>
<a href="http://fileformats.archiveteam.org/wiki/Amiga_Workbench_icon">http://fileformats.archiveteam.org/wiki/Amiga_Workbench_icon</a>
<a href="http://amigadev.elowar.com/read/ADCD_2.1/Libraries_Manual_guide/node0241.html">http://amigadev.elowar.com/read/ADCD_2.1/Libraries_Manual_guide/node0241.html</a>
<a href="http://amigadev.elowar.com/read/ADCD_2.1/Includes_and_Autodocs_3._guide/node05D6.html">http://amigadev.elowar.com/read/ADCD_2.1/Includes_and_Autodocs_3._guide/node05D6.html</a>
</p>


<h3>See Also</h3>

<p>Other AmigaIcon.operations: 
<code><a href="#topic+rawToAmigaIcon">rawToAmigaIcon</a>()</code>,
<code><a href="#topic+read.AmigaIcon">read.AmigaIcon</a>()</code>,
<code><a href="#topic+simpleAmigaIcon">simpleAmigaIcon</a>()</code>,
<code><a href="#topic+write.AmigaIcon">write.AmigaIcon</a>()</code>
</p>

<hr>
<h2 id='as.AmigaBasic'>Coerce raw or character data to an AmigaBasic class object</h2><span id='topic+as.AmigaBasic'></span>

<h3>Description</h3>

<p>Coerce raw or character data to an <code><a href="#topic+AmigaBasic">AmigaBasic()</a></code> S3 class object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.AmigaBasic(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.AmigaBasic_+3A_x">x</code></td>
<td>
<p><code>x</code> should be a <code>vector</code> of <code>raw</code> data or
<code>character</code> strings. When <code>x</code> is <code>raw</code> data, it
is interpreted as if it where from an Amiga Basic binary encoded file.
</p>
<p>When <code>x</code> is a <code>vector</code> of <code>character</code> strings,
each element of the vector should represent one line of Basic code.
Each line should not contain line break or other special characters,
as this will result in errors. The text should represent valid
Amiga Basic syntax. The syntax is only checked to a limited extent as
this package does not implement an interpreter for the code.</p>
</td></tr>
<tr><td><code id="as.AmigaBasic_+3A_...">...</code></td>
<td>
<p>Currently ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Convert text to an <code><a href="#topic+AmigaBasic">AmigaBasic()</a></code> S3 class object. The text should
consist of valid Amiga BASIC syntaxis. This function does not perform a
full check of the syntaxis, but will break on some fundamental syntaxis malformations
</p>


<h3>Value</h3>

<p>Returns an <code><a href="#topic+AmigaBasic">AmigaBasic()</a></code> class object based on <code>x</code>.
</p>


<h3>Author(s)</h3>

<p>Pepijn de Vries
</p>


<h3>References</h3>

<p><a href="https://en.wikipedia.org/wiki/AmigaBASIC">https://en.wikipedia.org/wiki/AmigaBASIC</a>
</p>


<h3>See Also</h3>

<p>Other AmigaBasic.operations: 
<code><a href="#topic+AmigaBasic.reserved">AmigaBasic.reserved</a>()</code>,
<code><a href="#topic+AmigaBasicBMAP">AmigaBasicBMAP</a></code>,
<code><a href="#topic+AmigaBasic">AmigaBasic</a></code>,
<code><a href="#topic++5B.AmigaBasic">[.AmigaBasic</a>()</code>,
<code><a href="#topic+as.AmigaBasicBMAP">as.AmigaBasicBMAP</a>()</code>,
<code><a href="#topic+as.character">as.character</a>()</code>,
<code><a href="#topic+check.names.AmigaBasic">check.names.AmigaBasic</a>()</code>,
<code><a href="#topic+names.AmigaBasic">names.AmigaBasic</a>()</code>,
<code><a href="#topic+rawToAmigaBasicBMAP">rawToAmigaBasicBMAP</a>()</code>,
<code><a href="#topic+rawToAmigaBasic">rawToAmigaBasic</a>()</code>,
<code><a href="#topic+read.AmigaBasicBMAP">read.AmigaBasicBMAP</a>()</code>,
<code><a href="#topic+read.AmigaBasic">read.AmigaBasic</a>()</code>,
<code><a href="#topic+write.AmigaBasic">write.AmigaBasic</a>()</code>
</p>
<p>Other raw.operations: 
<code><a href="#topic+as.raw.AmigaBasic">as.raw.AmigaBasic</a>()</code>,
<code><a href="#topic+colourToAmigaRaw">colourToAmigaRaw</a>()</code>,
<code><a href="#topic+packBitmap">packBitmap</a>()</code>,
<code><a href="#topic+rawToAmigaBasicBMAP">rawToAmigaBasicBMAP</a>()</code>,
<code><a href="#topic+rawToAmigaBasicShape">rawToAmigaBasicShape</a>()</code>,
<code><a href="#topic+rawToAmigaBasic">rawToAmigaBasic</a>()</code>,
<code><a href="#topic+rawToAmigaBitmapFontSet">rawToAmigaBitmapFontSet</a>()</code>,
<code><a href="#topic+rawToAmigaBitmapFont">rawToAmigaBitmapFont</a>()</code>,
<code><a href="#topic+rawToAmigaIcon">rawToAmigaIcon</a>()</code>,
<code><a href="#topic+rawToHWSprite">rawToHWSprite</a>()</code>,
<code><a href="#topic+rawToIFFChunk">rawToIFFChunk</a>()</code>,
<code><a href="#topic+rawToSysConfig">rawToSysConfig</a>()</code>,
<code><a href="#topic+simpleAmigaIcon">simpleAmigaIcon</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## An AmigaBasic object can be created from text.
## Note that each line of code is a seperate element
## in the vector:
bas &lt;- as.AmigaBasic(c(
  "CLS ' Clear the screen",
  "PRINT \"Hello world!\" ' Print a message on the screen"
))

## Let's make it raw data:
bas.raw &lt;- as.raw(bas)

## We can also use the raw data to create an Amiga Basic object:
## Note that this effectively the same as calling 'rawToAmigaBasic'
bas &lt;- as.AmigaBasic(bas.raw)

## End(Not run)
</code></pre>

<hr>
<h2 id='as.AmigaBasicBMAP'>Coerce raw or named list to an AmigaBasicBMAP class object</h2><span id='topic+as.AmigaBasicBMAP'></span>

<h3>Description</h3>

<p>Coerce <code>raw</code> or named <code>list</code> to an <code><a href="#topic+AmigaBasicBMAP">AmigaBasicBMAP()</a></code> class object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.AmigaBasicBMAP(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.AmigaBasicBMAP_+3A_x">x</code></td>
<td>
<p>When <code>x</code> is a <code>vector</code> of <code>raw</code> data, it needs to be structured as it would be
when stored in a binary file (see <code><a href="#topic+read.AmigaBasicBMAP">read.AmigaBasicBMAP()</a></code>). <code>x</code> can also be a named <code>list</code>,
where the name of each element corresponds with a routine in the library. Each element should than consist
of a <code>list</code> with 2 elements: The first should be named <code style="white-space: pre;">&#8288;libraryVectorOffset' and should hold the &#8288;</code>numeric<code style="white-space: pre;">&#8288;offset of the routine in the library (see details). The second element should be named&#8288;</code>registers' and should
contain a <code>vector</code> of <code>raw</code> values refering to CPU registers used by the routine (see details).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An <a href="#topic+AmigaBasicBMAP">Amiga Basic BMAP</a> file maps the offset of routines in Amiga libraries. This
function converts the raw format in which it would be stored as a file into a comprehensive S3 class object. It
can also convert a named list into an S3 class object. See <code style="white-space: pre;">&#8288;Arguments' and &#8288;</code>Examples' sections on how to format
this list.
</p>


<h3>Value</h3>

<p>Returns a <code><a href="#topic+AmigaBasicBMAP">AmigaBasicBMAP()</a></code> based on <code>x</code>
</p>


<h3>Author(s)</h3>

<p>Pepijn de Vries
</p>


<h3>See Also</h3>

<p>Other AmigaBasic.operations: 
<code><a href="#topic+AmigaBasic.reserved">AmigaBasic.reserved</a>()</code>,
<code><a href="#topic+AmigaBasicBMAP">AmigaBasicBMAP</a></code>,
<code><a href="#topic+AmigaBasic">AmigaBasic</a></code>,
<code><a href="#topic++5B.AmigaBasic">[.AmigaBasic</a>()</code>,
<code><a href="#topic+as.AmigaBasic">as.AmigaBasic</a>()</code>,
<code><a href="#topic+as.character">as.character</a>()</code>,
<code><a href="#topic+check.names.AmigaBasic">check.names.AmigaBasic</a>()</code>,
<code><a href="#topic+names.AmigaBasic">names.AmigaBasic</a>()</code>,
<code><a href="#topic+rawToAmigaBasicBMAP">rawToAmigaBasicBMAP</a>()</code>,
<code><a href="#topic+rawToAmigaBasic">rawToAmigaBasic</a>()</code>,
<code><a href="#topic+read.AmigaBasicBMAP">read.AmigaBasicBMAP</a>()</code>,
<code><a href="#topic+read.AmigaBasic">read.AmigaBasic</a>()</code>,
<code><a href="#topic+write.AmigaBasic">write.AmigaBasic</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## For the dos.library, the start of the bmap list would look like:
dos.list &lt;- list(
  xOpen = list(
    libraryVectorOffset = -30,
    registers = as.raw(2:3)
  ),
  xClose = list(
    libraryVectorOffset = -36,
    registers = as.raw(2)
  ),
  xRead = list(
    libraryVectorOffset = -42,
    registers = as.raw(2:4)
  )
)

## Note that the list above is incomplete, the dos.library holds more routines than shown here.
## This merely serves as an example.
## This list can be converted to an S3 class as follows:
dos.bmap &lt;- as.AmigaBasicBMAP(dos.list)

## End(Not run)
</code></pre>

<hr>
<h2 id='as.character'>Coerce an AmigaBasic class object to its character representation</h2><span id='topic+as.character'></span><span id='topic+as.character.AmigaBasic'></span>

<h3>Description</h3>

<p>Coerce an <code><a href="#topic+AmigaBasic">AmigaBasic()</a></code>-class object to its character representation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'AmigaBasic'
as.character(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.character_+3A_x">x</code></td>
<td>
<p>An <code><a href="#topic+AmigaBasic">AmigaBasic()</a></code> class object that needs to be
coerced to its <code>character</code> representation.</p>
</td></tr>
<tr><td><code id="as.character_+3A_...">...</code></td>
<td>
<p>Currently ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Amiga Basic files are encoded in a binary format and are also stored as such
in <code><a href="#topic+AmigaBasic">AmigaBasic()</a></code>-class objects. Use this function to convert
these objects into legible <code>character</code> data.
</p>


<h3>Value</h3>

<p>A <code>vector</code> of <code>character</code> strings, where
each element of the <code>vector</code> is a <code>character</code> representation
of a line of Amiga Basic code stored in <code>x</code>.
</p>


<h3>Author(s)</h3>

<p>Pepijn de Vries
</p>


<h3>See Also</h3>

<p>Other AmigaBasic.operations: 
<code><a href="#topic+AmigaBasic.reserved">AmigaBasic.reserved</a>()</code>,
<code><a href="#topic+AmigaBasicBMAP">AmigaBasicBMAP</a></code>,
<code><a href="#topic+AmigaBasic">AmigaBasic</a></code>,
<code><a href="#topic++5B.AmigaBasic">[.AmigaBasic</a>()</code>,
<code><a href="#topic+as.AmigaBasicBMAP">as.AmigaBasicBMAP</a>()</code>,
<code><a href="#topic+as.AmigaBasic">as.AmigaBasic</a>()</code>,
<code><a href="#topic+check.names.AmigaBasic">check.names.AmigaBasic</a>()</code>,
<code><a href="#topic+names.AmigaBasic">names.AmigaBasic</a>()</code>,
<code><a href="#topic+rawToAmigaBasicBMAP">rawToAmigaBasicBMAP</a>()</code>,
<code><a href="#topic+rawToAmigaBasic">rawToAmigaBasic</a>()</code>,
<code><a href="#topic+read.AmigaBasicBMAP">read.AmigaBasicBMAP</a>()</code>,
<code><a href="#topic+read.AmigaBasic">read.AmigaBasic</a>()</code>,
<code><a href="#topic+write.AmigaBasic">write.AmigaBasic</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## First create an Amiga Basic object:
bas &lt;- as.AmigaBasic("PRINT \"Hello world!\"")

## now convert the object back into text:
bas.txt &lt;- as.character(bas)

## End(Not run)
</code></pre>

<hr>
<h2 id='as.raster.AmigaBasicShape'>Convert AmigaFFH objects into grDevices raster images</h2><span id='topic+as.raster.AmigaBasicShape'></span><span id='topic+as.raster'></span><span id='topic+as.raster.AmigaBitmapFont'></span><span id='topic+as.raster.AmigaBitmapFontSet'></span><span id='topic+as.raster.hardwareSprite'></span><span id='topic+as.raster+2ChardwareSprite-method'></span><span id='topic+as.raster.IFFChunk'></span><span id='topic+as.raster.AmigaIcon'></span>

<h3>Description</h3>

<p>Convert AmigaFFH objects that contain bitmap images into grDevices raster
images.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'AmigaBasicShape'
as.raster(x, selected = c("bitmap", "shadow", "collision"), ...)

## S3 method for class 'AmigaBitmapFont'
as.raster(x, text, style, palette, ...)

## S3 method for class 'AmigaBitmapFontSet'
as.raster(x, text, style, palette, ...)

## S3 method for class 'hardwareSprite'
as.raster(x, background = "#AAAAAA", ...)

## S3 method for class 'IFFChunk'
as.raster(x, ...)

## S3 method for class 'AmigaIcon'
as.raster(x, selected = F, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.raster.AmigaBasicShape_+3A_x">x</code></td>
<td>
<p>Object that needs to be converted into a <code>grDevices</code> raster. It
can be an <code><a href="#topic+IFFChunk">IFFChunk()</a></code> containing an interleaved bitmap image
(ILBM) or animation (ANIM), a <code><a href="#topic+hardwareSprite">hardwareSprite()</a></code>, an
<code><a href="#topic+AmigaBitmapFont">AmigaBitmapFont()</a></code> object or an <code><a href="#topic+AmigaBitmapFontSet">AmigaBitmapFontSet()</a></code> object.</p>
</td></tr>
<tr><td><code id="as.raster.AmigaBasicShape_+3A_selected">selected</code></td>
<td>
<p>When <code>x</code> is an object of class <code><a href="#topic+AmigaIcon">AmigaIcon()</a></code>, <code>selected</code> can be
used to select a specific state. When set to <code>TRUE</code>, the raster of the <code><a href="#topic+AmigaIcon">AmigaIcon()</a></code>
will be based on the &lsquo;selected&rsquo; state of the icon. Otherwise it will be based on the
deselected state (default).
</p>
<p>When <code>x</code> is an <code><a href="#topic+AmigaBasicShape">AmigaBasicShape()</a></code> class object, <code>selected</code> can be used to select a
specific layer of the shape to plot, which can be one of <code>"bitmap"</code> (default), <code>"shadow"</code> or <code>"collision"</code>.</p>
</td></tr>
<tr><td><code id="as.raster.AmigaBasicShape_+3A_...">...</code></td>
<td>
<p>Currently ignored.</p>
</td></tr>
<tr><td><code id="as.raster.AmigaBasicShape_+3A_text">text</code></td>
<td>
<p>Text (a <code>character</code> string) to be formated
with <code>x</code> (when <code>x</code> is an <code><a href="#topic+AmigaBitmapFont">AmigaBitmapFont()</a></code>
or an <code><a href="#topic+AmigaBitmapFontSet">AmigaBitmapFontSet()</a></code>.</p>
</td></tr>
<tr><td><code id="as.raster.AmigaBasicShape_+3A_style">style</code></td>
<td>
<p>Argument is only valid when <code>x</code> is an <code><a href="#topic+AmigaBitmapFont">AmigaBitmapFont()</a></code>
or an <code><a href="#topic+AmigaBitmapFontSet">AmigaBitmapFontSet()</a></code>. No styling is applied
when missing or <code>NULL</code>. One or more of the following styles
can be used '<code>bold</code>', '<code>italic</code> or '<code>underlined</code>'.</p>
</td></tr>
<tr><td><code id="as.raster.AmigaBasicShape_+3A_palette">palette</code></td>
<td>
<p>Argument is only valid when <code>x</code> is an <code><a href="#topic+AmigaBitmapFont">AmigaBitmapFont()</a></code>
or an <code><a href="#topic+AmigaBitmapFontSet">AmigaBitmapFontSet()</a></code>. Should be a <code>vector</code> of
two colours. The first is element is used as background colour, the
second as foreground. When missing, transparent white and black are used.</p>
</td></tr>
<tr><td><code id="as.raster.AmigaBasicShape_+3A_background">background</code></td>
<td>
<p>Use the argument <code>background</code> to
specify a background colour in case <code>x</code> is a <code><a href="#topic+hardwareSprite">hardwareSprite()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Images on the Amiga were stored as bitmap images with indexed colour
palettes. This was mainly due to hardware and memory limitations.
Bitmap images could also be embedded in several file types. This method
can be used to convert AmigaFFH objects read from such files into
grDevices raster images (<code><a href="grDevices.html#topic+as.raster">grDevices::as.raster()</a></code>).
</p>


<h3>Value</h3>

<p>Returns a <code>grDevices</code> raster image (<code><a href="grDevices.html#topic+as.raster">grDevices::as.raster()</a></code>)
based on <code>x</code>. If <code>x</code> is an animation (<code><a href="#topic+IFFChunk">IFFChunk()</a></code> of type ANIM),
a <code>list</code> of raster objects is returned.
</p>


<h3>Author(s)</h3>

<p>Pepijn de Vries
</p>


<h3>See Also</h3>

<p>Other raster.operations: 
<code><a href="#topic+AmigaBitmapFont">AmigaBitmapFont</a></code>,
<code><a href="#topic+bitmapToRaster">bitmapToRaster</a>()</code>,
<code><a href="#topic+dither">dither</a>()</code>,
<code><a href="#topic+index.colours">index.colours</a>()</code>,
<code><a href="#topic+rasterToAmigaBasicShape">rasterToAmigaBasicShape</a>()</code>,
<code><a href="#topic+rasterToAmigaBitmapFont">rasterToAmigaBitmapFont</a>()</code>,
<code><a href="#topic+rasterToBitmap">rasterToBitmap</a>()</code>,
<code><a href="#topic+rasterToHWSprite">rasterToHWSprite</a>()</code>,
<code><a href="#topic+rasterToIFF">rasterToIFF</a>()</code>
</p>
<p>Other raster.operations: 
<code><a href="#topic+AmigaBitmapFont">AmigaBitmapFont</a></code>,
<code><a href="#topic+bitmapToRaster">bitmapToRaster</a>()</code>,
<code><a href="#topic+dither">dither</a>()</code>,
<code><a href="#topic+index.colours">index.colours</a>()</code>,
<code><a href="#topic+rasterToAmigaBasicShape">rasterToAmigaBasicShape</a>()</code>,
<code><a href="#topic+rasterToAmigaBitmapFont">rasterToAmigaBitmapFont</a>()</code>,
<code><a href="#topic+rasterToBitmap">rasterToBitmap</a>()</code>,
<code><a href="#topic+rasterToHWSprite">rasterToHWSprite</a>()</code>,
<code><a href="#topic+rasterToIFF">rasterToIFF</a>()</code>
</p>
<p>Other iff.operations: 
<code><a href="#topic+IFFChunk-class">IFFChunk-class</a></code>,
<code><a href="#topic+WaveToIFF">WaveToIFF</a>()</code>,
<code><a href="#topic+getIFFChunk">getIFFChunk</a>()</code>,
<code><a href="#topic+interpretIFFChunk">interpretIFFChunk</a>()</code>,
<code><a href="#topic+rasterToIFF">rasterToIFF</a>()</code>,
<code><a href="#topic+rawToIFFChunk">rawToIFFChunk</a>()</code>,
<code><a href="#topic+read.iff">read.iff</a>()</code>,
<code><a href="#topic+write.iff">write.iff</a>()</code>
</p>
<p>Other raster.operations: 
<code><a href="#topic+AmigaBitmapFont">AmigaBitmapFont</a></code>,
<code><a href="#topic+bitmapToRaster">bitmapToRaster</a>()</code>,
<code><a href="#topic+dither">dither</a>()</code>,
<code><a href="#topic+index.colours">index.colours</a>()</code>,
<code><a href="#topic+rasterToAmigaBasicShape">rasterToAmigaBasicShape</a>()</code>,
<code><a href="#topic+rasterToAmigaBitmapFont">rasterToAmigaBitmapFont</a>()</code>,
<code><a href="#topic+rasterToBitmap">rasterToBitmap</a>()</code>,
<code><a href="#topic+rasterToHWSprite">rasterToHWSprite</a>()</code>,
<code><a href="#topic+rasterToIFF">rasterToIFF</a>()</code>
</p>
<p>Other raster.operations: 
<code><a href="#topic+AmigaBitmapFont">AmigaBitmapFont</a></code>,
<code><a href="#topic+bitmapToRaster">bitmapToRaster</a>()</code>,
<code><a href="#topic+dither">dither</a>()</code>,
<code><a href="#topic+index.colours">index.colours</a>()</code>,
<code><a href="#topic+rasterToAmigaBasicShape">rasterToAmigaBasicShape</a>()</code>,
<code><a href="#topic+rasterToAmigaBitmapFont">rasterToAmigaBitmapFont</a>()</code>,
<code><a href="#topic+rasterToBitmap">rasterToBitmap</a>()</code>,
<code><a href="#topic+rasterToHWSprite">rasterToHWSprite</a>()</code>,
<code><a href="#topic+rasterToIFF">rasterToIFF</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## load an IFF file
example.iff &lt;- read.iff(system.file("ilbm8lores.iff", package = "AmigaFFH"))

## The file contains an interleaved bitmap image that can be
## converted into a raster:
example.raster &lt;- as.raster(example.iff)

## the raster can be plotted:
plot(example.raster)

## note that the IFFChunk can also be plotted directly:
plot(example.iff)

## Hardware sprites can also be converted into raster images.
## Let's generate a 16x16 sprite with a random bitmap:
spr &lt;- new("hardwareSprite",
           VStop = 16,
           bitmap = as.raw(sample.int(255, 64, replace = TRUE)))

## now convert it into a raster image.
## as the background colour is not specified for hardware
## sprite, we can optionally provide it here.
spr.raster &lt;- as.raster(spr, background = "green")

## AmigaBasicShape objects can also be converted into rasters:
ball &lt;- read.AmigaBasicShape(system.file("ball.shp", package = "AmigaFFH"))
ball.rst &lt;- as.raster(ball)

## End(Not run)
</code></pre>

<hr>
<h2 id='as.raw.AmigaBasic'>Convert AmigaFFH objects into raw data</h2><span id='topic+as.raw.AmigaBasic'></span><span id='topic+as.raw.AmigaBasicShape'></span><span id='topic+as.raw.AmigaBasicBMAP'></span><span id='topic+as.raw'></span><span id='topic+as.raw.AmigaBitmapFont'></span><span id='topic+as.raw.AmigaBitmapFontSet'></span><span id='topic+as.raw.AmigaTimeVal'></span><span id='topic+as.raw+2ChardwareSprite-method'></span><span id='topic+as.raw+2CIFFChunk-method'></span><span id='topic+as.raw.IFF.ANY'></span><span id='topic+as.raw.SysConfig'></span><span id='topic+as.raw.AmigaIcon'></span>

<h3>Description</h3>

<p>Convert AmigaFFH objects into raw data, as they would be stored in the Commodore
Amiga's memory or files.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'AmigaBasic'
as.raw(x, ...)

## S3 method for class 'AmigaBasicShape'
as.raw(x, ...)

## S3 method for class 'AmigaBasicBMAP'
as.raw(x)

## S3 method for class 'AmigaBitmapFont'
as.raw(x, ...)

## S3 method for class 'AmigaBitmapFontSet'
as.raw(x, ...)

## S3 method for class 'AmigaTimeVal'
as.raw(x, ...)

## S4 method for signature 'hardwareSprite'
as.raw(x)

## S4 method for signature 'IFFChunk'
as.raw(x)

## S3 method for class 'IFF.ANY'
as.raw(x, ...)

## S3 method for class 'SysConfig'
as.raw(x, ...)

## S3 method for class 'AmigaIcon'
as.raw(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.raw.AmigaBasic_+3A_x">x</code></td>
<td>
<p>An AmigaFFH object that needs to be converted into raw data.
See usage section for all supported objects.</p>
</td></tr>
<tr><td><code id="as.raw.AmigaBasic_+3A_...">...</code></td>
<td>
<p>Arguments passed on to <code><a href="#topic+IFFChunk-method">IFFChunk-method()</a></code> when <code>x</code> is
of class <code>IFF.ANY</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Objects originating from this package can in some cases be converted into
raw data, as they would be stored on an original Amiga. See the usage section
for the currently supported objects.
</p>
<p>Not all information from <code>x</code> may be included in the <code>raw</code>
data that is returned, so handle with care.
</p>
<p>As this package grows additional objects can be converted with this method.
</p>


<h3>Value</h3>

<p>Returns a <code>vector</code> of <code>raw</code> data based on <code>x</code>.
</p>


<h3>Author(s)</h3>

<p>Pepijn de Vries
</p>


<h3>See Also</h3>

<p>Other raw.operations: 
<code><a href="#topic+as.AmigaBasic">as.AmigaBasic</a>()</code>,
<code><a href="#topic+colourToAmigaRaw">colourToAmigaRaw</a>()</code>,
<code><a href="#topic+packBitmap">packBitmap</a>()</code>,
<code><a href="#topic+rawToAmigaBasicBMAP">rawToAmigaBasicBMAP</a>()</code>,
<code><a href="#topic+rawToAmigaBasicShape">rawToAmigaBasicShape</a>()</code>,
<code><a href="#topic+rawToAmigaBasic">rawToAmigaBasic</a>()</code>,
<code><a href="#topic+rawToAmigaBitmapFontSet">rawToAmigaBitmapFontSet</a>()</code>,
<code><a href="#topic+rawToAmigaBitmapFont">rawToAmigaBitmapFont</a>()</code>,
<code><a href="#topic+rawToAmigaIcon">rawToAmigaIcon</a>()</code>,
<code><a href="#topic+rawToHWSprite">rawToHWSprite</a>()</code>,
<code><a href="#topic+rawToIFFChunk">rawToIFFChunk</a>()</code>,
<code><a href="#topic+rawToSysConfig">rawToSysConfig</a>()</code>,
<code><a href="#topic+simpleAmigaIcon">simpleAmigaIcon</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## read an IFF file as an IFFChunk object:
example.iff &lt;- read.iff(system.file("ilbm8lores.iff", package = "AmigaFFH"))

## This will recreate the exact raw data as it was read from the file:
example.raw &lt;- as.raw(example.iff)

## End(Not run)
</code></pre>

<hr>
<h2 id='availableFontSizes'>Get available font sizes from an AmigaBitmapFontSet</h2><span id='topic+availableFontSizes'></span>

<h3>Description</h3>

<p>Get available font sizes (height) from an <code><a href="#topic+AmigaBitmapFontSet">AmigaBitmapFontSet()</a></code> in pixels.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>availableFontSizes(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="availableFontSizes_+3A_x">x</code></td>
<td>
<p>An <code><a href="#topic+AmigaBitmapFontSet">AmigaBitmapFontSet()</a></code> for which the available
font sizes (height) in number of pixels need to be obtained.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An <code><a href="#topic+AmigaBitmapFontSet">AmigaBitmapFontSet()</a></code> can hold bitmaps of multiple font
sizes. Use this function to obtain the available size from such a set.
</p>


<h3>Value</h3>

<p>Returns a <code>vector</code> of <code>numeric</code> values specifying
the available font sizes (height in pixels) for <code>x</code>.
</p>


<h3>Author(s)</h3>

<p>Pepijn de Vries
</p>


<h3>See Also</h3>

<p>Other AmigaBitmapFont.operations: 
<code><a href="#topic+AmigaBitmapFont">AmigaBitmapFont</a></code>,
<code><a href="#topic+c">c</a>()</code>,
<code><a href="#topic+fontName">fontName</a>()</code>,
<code><a href="#topic+font_example">font_example</a></code>,
<code><a href="#topic+getAmigaBitmapFont">getAmigaBitmapFont</a>()</code>,
<code><a href="#topic+rasterToAmigaBitmapFont">rasterToAmigaBitmapFont</a>()</code>,
<code><a href="#topic+rawToAmigaBitmapFontSet">rawToAmigaBitmapFontSet</a>()</code>,
<code><a href="#topic+rawToAmigaBitmapFont">rawToAmigaBitmapFont</a>()</code>,
<code><a href="#topic+read.AmigaBitmapFontSet">read.AmigaBitmapFontSet</a>()</code>,
<code><a href="#topic+read.AmigaBitmapFont">read.AmigaBitmapFont</a>()</code>,
<code><a href="#topic+write.AmigaBitmapFont">write.AmigaBitmapFont</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(font_example)

## The example font holds two font sizes (8 and 9):
availableFontSizes(font_example)

## End(Not run)
</code></pre>

<hr>
<h2 id='bitmapToRaster'>Convert an Amiga bitmap image into a raster</h2><span id='topic+bitmapToRaster'></span>

<h3>Description</h3>

<p>Amiga images are usually stored as bitmap images with indexed colours. This
function converts raw Amiga bitmap data into raster data
(<code><a href="grDevices.html#topic+as.raster">grDevices::as.raster()</a></code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bitmapToRaster(
  x,
  w,
  h,
  depth,
  palette = grDevices::gray(seq(0, 1, length.out = 2^depth)),
  interleaved = T
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bitmapToRaster_+3A_x">x</code></td>
<td>
<p>a <code>vector</code> of <code>raw</code> values, representing bitmap data.</p>
</td></tr>
<tr><td><code id="bitmapToRaster_+3A_w">w</code></td>
<td>
<p>Width in pixels of the bitmap image. Can be any positive value. However,
bitmap data is &lsquo;word&rsquo; aligned on the amiga. This means that the width of the stored
bitmap data is a multiple of 16 pixels. The image is cropped to the width specified here.</p>
</td></tr>
<tr><td><code id="bitmapToRaster_+3A_h">h</code></td>
<td>
<p>Height in pixels of the bitmap image.</p>
</td></tr>
<tr><td><code id="bitmapToRaster_+3A_depth">depth</code></td>
<td>
<p>The colour depth of the bitmap image (i.e., the number of bit planes).
The image will be composed of <code>2^depth</code> indexed colours.</p>
</td></tr>
<tr><td><code id="bitmapToRaster_+3A_palette">palette</code></td>
<td>
<p>A <code>vector</code> of <code>2^depth</code> colours, to be used for the indexed
colours of the bitmap image. By default, a grayscale palette is used.
When explicitly set to <code>NULL</code>, this function returns a matrix with palette index
values.</p>
</td></tr>
<tr><td><code id="bitmapToRaster_+3A_interleaved">interleaved</code></td>
<td>
<p>A <code>logical</code> value, indicating whether the bitmap is interleaved.
An interleaved bitmap image stores each consecutive bitmap layer per horizontal scanline.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Bitmap images stored as raw data, representing palette index colours, can
be converted into raster data (<code><a href="grDevices.html#topic+as.raster">grDevices::as.raster()</a></code>). The latter
data can easily be plotted in R. It is usually not necessary to call this function
directly, as there are several more convenient wrappers for this function. Those
wrappers can convert specific file formats (such as IFF ILBM and Hardware Sprites,
see <code><a href="#topic+as.raster">as.raster()</a></code>) into raster objects. This function is
provided for completeness sake (or for when you want to search for images in an
amiga memory dump).
</p>


<h3>Value</h3>

<p>Returns a raster object (<code><a href="#topic+as.raster">as.raster()</a></code>) as specified in
the <code><a href="grDevices.html#topic+grDevices">grDevices()</a></code> package. Unless, <code>palette</code> is set to <code>NULL</code>,
in which case a <code>matrix</code> with <code>numeric</code> palette index values is returned.
</p>


<h3>Author(s)</h3>

<p>Pepijn de Vries
</p>


<h3>See Also</h3>

<p>Other raster.operations: 
<code><a href="#topic+AmigaBitmapFont">AmigaBitmapFont</a></code>,
<code><a href="#topic+as.raster.AmigaBasicShape">as.raster.AmigaBasicShape</a>()</code>,
<code><a href="#topic+dither">dither</a>()</code>,
<code><a href="#topic+index.colours">index.colours</a>()</code>,
<code><a href="#topic+rasterToAmigaBasicShape">rasterToAmigaBasicShape</a>()</code>,
<code><a href="#topic+rasterToAmigaBitmapFont">rasterToAmigaBitmapFont</a>()</code>,
<code><a href="#topic+rasterToBitmap">rasterToBitmap</a>()</code>,
<code><a href="#topic+rasterToHWSprite">rasterToHWSprite</a>()</code>,
<code><a href="#topic+rasterToIFF">rasterToIFF</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## first load an example image:
example.iff &lt;- read.iff(system.file("ilbm8lores.iff", package = "AmigaFFH"))

## get the raw bitmap data, which is nested in the InterLeaved BitMap (ILBM)
## IFF chunk as the BODY:
bitmap.data &lt;- interpretIFFChunk(getIFFChunk(example.iff, c("ILBM", "BODY")))

## In order to translate the bitmap data into a raster object we need
## to know the image dimensions (width, height and colour depth). This
## information can be obtained from the bitmap header (BMHD):

bitmap.header &lt;- interpretIFFChunk(getIFFChunk(example.iff, c("ILBM", "BMHD")))

## First the bitmap data needs to be unpacked as it was stored in a compresssed
## form in the IFF file (see bitmap.header$Compression):

bitmap.data &lt;- unPackBitmap(bitmap.data)

## It would also be nice to use the correct colour palette. This can be obtained
## from the CMAP chunk in the IFF file:

bitmap.palette &lt;- interpretIFFChunk(getIFFChunk(example.iff, c("ILBM", "CMAP")))

example.raster &lt;- bitmapToRaster(bitmap.data,
                                 bitmap.header$w,
                                 bitmap.header$h,
                                 bitmap.header$nPlanes,
                                 bitmap.palette)

## We now have a raster object that can be plotted:

plot(example.raster, interpolate = FALSE)

## End(Not run)
</code></pre>

<hr>
<h2 id='c'>Combine multiple AmigaFFH objects</h2><span id='topic+c'></span><span id='topic+c.AmigaBasic'></span><span id='topic+c.AmigaBitmapFont'></span>

<h3>Description</h3>

<p>Use this function to correctly combine one or more <code><a href="#topic+AmigaBitmapFont">AmigaBitmapFont()</a></code>
class objects into a single <code><a href="#topic+AmigaBitmapFontSet">AmigaBitmapFontSet()</a></code> class
object, or to combine multiple <code><a href="#topic+AmigaBasic">AmigaBasic()</a></code> class objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'AmigaBasic'
c(...)

## S3 method for class 'AmigaBitmapFont'
c(..., name = "font")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="c_+3A_...">...</code></td>
<td>
<p>Either <code><a href="#topic+AmigaBasic">AmigaBasic()</a></code> or <code><a href="#topic+AmigaBitmapFont">AmigaBitmapFont()</a></code>
class objects. In case of <code><a href="#topic+AmigaBitmapFont">AmigaBitmapFont()</a></code> objects:
Each <code><a href="#topic+AmigaBitmapFont">AmigaBitmapFont()</a></code> object should have a
unique Y-size.</p>
</td></tr>
<tr><td><code id="c_+3A_name">name</code></td>
<td>
<p>This argument is only valid when <code>...</code> are one or more
<code><a href="#topic+AmigaBitmapFont">AmigaBitmapFont()</a></code> class objects.
</p>
<p>A <code>character</code> string specifying the name that needs to be
applied to the font set. When unspecified, the default name 'font' is
used. Note that this name will also be used as a file name when writing
the font to a file. So make sure the name is also a valid file name. This
will not be checked for you and may thus result in errors.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In case <code>...</code> are one or more <code><a href="#topic+AmigaBasic">AmigaBasic()</a></code> class objects:
</p>
<p><code><a href="#topic+AmigaBasic">AmigaBasic()</a></code> class objects are combined into a single
<code><a href="#topic+AmigaBasic">AmigaBasic()</a></code> class object in the same order as they
are given as argument to this function. for this purpose the lines of
Amiga Basic codes are simply concatenated.
</p>
<p>In case <code>...</code> are one or more <code><a href="#topic+AmigaBitmapFont">AmigaBitmapFont()</a></code> class objects:
</p>
<p><code><a href="#topic+AmigaBitmapFontSet">AmigaBitmapFontSet()</a></code> class objects can hold multiple
<code><a href="#topic+AmigaBitmapFont">AmigaBitmapFont()</a></code> class objects. Use this method to
combine font bitmaps into such a font set. Make sure each bitmap
represents a unique font height (in pixels). When heights are duplicated
an error will be thrown.
</p>
<p>You can also specify a <code>name</code> for the font, that will be embeded
in the object. As this name will also be used as a file name when
writing the font to a file, make sure that it is a valid filename.
</p>


<h3>Value</h3>

<p>Returns an <code><a href="#topic+AmigaBitmapFontSet">AmigaBitmapFontSet()</a></code> in which the
<code><a href="#topic+AmigaBitmapFont">AmigaBitmapFont()</a></code> objects are combined. Or when <code><a href="#topic+AmigaBasic">AmigaBasic()</a></code>
objects are combined, an <code><a href="#topic+AmigaBasic">AmigaBasic()</a></code> object is returned
in which the lines of Amiga Basic code are combined.
</p>


<h3>Author(s)</h3>

<p>Pepijn de Vries
</p>


<h3>See Also</h3>

<p>Other AmigaBitmapFont.operations: 
<code><a href="#topic+AmigaBitmapFont">AmigaBitmapFont</a></code>,
<code><a href="#topic+availableFontSizes">availableFontSizes</a>()</code>,
<code><a href="#topic+fontName">fontName</a>()</code>,
<code><a href="#topic+font_example">font_example</a></code>,
<code><a href="#topic+getAmigaBitmapFont">getAmigaBitmapFont</a>()</code>,
<code><a href="#topic+rasterToAmigaBitmapFont">rasterToAmigaBitmapFont</a>()</code>,
<code><a href="#topic+rawToAmigaBitmapFontSet">rawToAmigaBitmapFontSet</a>()</code>,
<code><a href="#topic+rawToAmigaBitmapFont">rawToAmigaBitmapFont</a>()</code>,
<code><a href="#topic+read.AmigaBitmapFontSet">read.AmigaBitmapFontSet</a>()</code>,
<code><a href="#topic+read.AmigaBitmapFont">read.AmigaBitmapFont</a>()</code>,
<code><a href="#topic+write.AmigaBitmapFont">write.AmigaBitmapFont</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(font_example)

## first get some AmigaBitmapFont objects:
font8 &lt;- getAmigaBitmapFont(font_example, 8)
font9 &lt;- getAmigaBitmapFont(font_example, 9)

## now bind these bitmaps again in a single set
font.set &lt;- c(font8, font9, name = "my_font_name")

## Amiga Basic codes can also be combined:
bas1 &lt;- as.AmigaBasic("LET a = 1")
bas2 &lt;- as.AmigaBasic("PRINT a")
bas  &lt;- c(bas1, bas2)

## End(Not run)
</code></pre>

<hr>
<h2 id='check.names.AmigaBasic'>Check Amiga Basic label/variable names for validity</h2><span id='topic+check.names.AmigaBasic'></span>

<h3>Description</h3>

<p>Check Amiga Basic label/variable names for validity
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check.names.AmigaBasic(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check.names.AmigaBasic_+3A_x">x</code></td>
<td>
<p>A <code>vector</code> of <code>character</code> strings that need to be checked</p>
</td></tr>
<tr><td><code id="check.names.AmigaBasic_+3A_...">...</code></td>
<td>
<p>Currently ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Names for variables and labels should adhere to the following rules in Amiga Basic:
</p>

<ul>
<li><p> Length of the names should be in the range of 1 up to 255 character
</p>
</li>
<li><p> Names cannot be <code><a href="#topic+AmigaBasic.reserved">AmigaBasic.reserved()</a></code> words
</p>
</li>
<li><p> Names should only contain alphanumeric characters or periods and
should not contain special characters (i.e., reserved for type definition,
such as dollar- or percentage sign)
</p>
</li>
<li><p> Names should not start with a numeric character
</p>
</li></ul>

<p>This function tests names against each of these criteria.
</p>


<h3>Value</h3>

<p>A <code>data.frame</code> with <code>logical</code> values with the same number of rows as the length of <code>x</code>.
Columns in the data.frame corresponds with the criteria listed in the details.
<code>FALSE</code> for invalid names.
</p>


<h3>Author(s)</h3>

<p>Pepijn de Vries
</p>


<h3>See Also</h3>

<p>Other AmigaBasic.operations: 
<code><a href="#topic+AmigaBasic.reserved">AmigaBasic.reserved</a>()</code>,
<code><a href="#topic+AmigaBasicBMAP">AmigaBasicBMAP</a></code>,
<code><a href="#topic+AmigaBasic">AmigaBasic</a></code>,
<code><a href="#topic++5B.AmigaBasic">[.AmigaBasic</a>()</code>,
<code><a href="#topic+as.AmigaBasicBMAP">as.AmigaBasicBMAP</a>()</code>,
<code><a href="#topic+as.AmigaBasic">as.AmigaBasic</a>()</code>,
<code><a href="#topic+as.character">as.character</a>()</code>,
<code><a href="#topic+names.AmigaBasic">names.AmigaBasic</a>()</code>,
<code><a href="#topic+rawToAmigaBasicBMAP">rawToAmigaBasicBMAP</a>()</code>,
<code><a href="#topic+rawToAmigaBasic">rawToAmigaBasic</a>()</code>,
<code><a href="#topic+read.AmigaBasicBMAP">read.AmigaBasicBMAP</a>()</code>,
<code><a href="#topic+read.AmigaBasic">read.AmigaBasic</a>()</code>,
<code><a href="#topic+write.AmigaBasic">write.AmigaBasic</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## These are valid names in Amiga Basic:
check.names.AmigaBasic(c("Foo", "Bar"))

## Reserved words and repeated names are not allowed:

check.names.AmigaBasic(c("Print", "Foo", "Foo"))

## End(Not run)
</code></pre>

<hr>
<h2 id='colourToAmigaRaw'>Convert colours to Amiga compatible raw data or vice versa</h2><span id='topic+colourToAmigaRaw'></span><span id='topic+amigaRawToColour'></span>

<h3>Description</h3>

<p>Convert colours to Amiga compatible raw data or vice versa, such that
it can be used in graphical objects from the Commodore Amiga.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>colourToAmigaRaw(
  x,
  colour.depth = c("12 bit", "24 bit"),
  n.bytes = c("2", "3")
)

amigaRawToColour(
  x,
  colour.depth = c("12 bit", "24 bit"),
  n.bytes = c("2", "3")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="colourToAmigaRaw_+3A_x">x</code></td>
<td>
<p>In the case <code>amigaRawToColour</code> is called, <code>x</code> should
be a <code>vector</code> of <code>raw</code> data. The length of this vector should
be a multiple of 2 (when <code>n.bytes = "2"</code>) or 3 (when
<code>n.bytes = "3"</code>). When <code>colourToAmigaRaw</code> is called, <code>x</code>
should be a <code>character</code> strings representing a colour.</p>
</td></tr>
<tr><td><code id="colourToAmigaRaw_+3A_colour.depth">colour.depth</code></td>
<td>
<p>A <code>character</code> string: <code>"12 bit"</code> (default) or
<code>"24 bit"</code>. The first should be used in most cases, as old Amigas
have a 12 bit colour depth.</p>
</td></tr>
<tr><td><code id="colourToAmigaRaw_+3A_n.bytes">n.bytes</code></td>
<td>
<p>A <code>character</code> string: <code>"2"</code> or <code>"3"</code>. The
number of bytes that is used or should be used to store each colour.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>On the original Commodore Amiga chipset, graphics used indexed palettes of
12 bit colours. Colours are specified by their RGB (Red, Green and Blue)
values, each component requiring 4 bits (with corresponding values ranging
from 0 up to 15). Data structures on the Amiga were WORD (2 bytes) aligned.
Colours are therefore typically stored in either 2 bytes (skipping the
first four bits) or 3 bytes (one byte for each value).
</p>
<p>These functions can be used to convert R colours into the closest matching
Amiga colour in a <code>raw</code> format, or vice versa. Note that later Amiga
models with the advanced (graphics) architecture (known as AA or AGA) allowed
for 24 bit colours.
</p>


<h3>Value</h3>

<p>In the case <code>amigaRawToColour</code> is called, a (vector of)
colour <code>character</code> string(s) is returned. When <code>colourToAmigaRaw</code>
is called, <code>raw</code> representing the colour(s) specified in <code>x</code> is
returned.
</p>


<h3>Author(s)</h3>

<p>Pepijn de Vries
</p>


<h3>See Also</h3>

<p>Other raw.operations: 
<code><a href="#topic+as.AmigaBasic">as.AmigaBasic</a>()</code>,
<code><a href="#topic+as.raw.AmigaBasic">as.raw.AmigaBasic</a>()</code>,
<code><a href="#topic+packBitmap">packBitmap</a>()</code>,
<code><a href="#topic+rawToAmigaBasicBMAP">rawToAmigaBasicBMAP</a>()</code>,
<code><a href="#topic+rawToAmigaBasicShape">rawToAmigaBasicShape</a>()</code>,
<code><a href="#topic+rawToAmigaBasic">rawToAmigaBasic</a>()</code>,
<code><a href="#topic+rawToAmigaBitmapFontSet">rawToAmigaBitmapFontSet</a>()</code>,
<code><a href="#topic+rawToAmigaBitmapFont">rawToAmigaBitmapFont</a>()</code>,
<code><a href="#topic+rawToAmigaIcon">rawToAmigaIcon</a>()</code>,
<code><a href="#topic+rawToHWSprite">rawToHWSprite</a>()</code>,
<code><a href="#topic+rawToIFFChunk">rawToIFFChunk</a>()</code>,
<code><a href="#topic+rawToSysConfig">rawToSysConfig</a>()</code>,
<code><a href="#topic+simpleAmigaIcon">simpleAmigaIcon</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Let's create some Amiga palettes:
colourToAmigaRaw(c("red", "navy blue", "brown", "#34AC5A"))

## let's do the reverse.
## this is white:
amigaRawToColour(as.raw(c(0x0f, 0xff)))

## this is white specified in 3 bytes:
amigaRawToColour(as.raw(c(0xf0, 0xf0, 0xf0)), n.bytes = "3")

## lower nybbles are ignored, you will get a warning when it is not zero:
amigaRawToColour(as.raw(c(0xf0, 0xf0, 0x0f)), n.bytes = "3")
</code></pre>

<hr>
<h2 id='deltaFibonacciCompress'>(De)compress 8-bit continuous signals.</h2><span id='topic+deltaFibonacciCompress'></span><span id='topic+deltaFibonacciDecompress'></span>

<h3>Description</h3>

<p>Use a lossy delta-Fibonacci (de)compression to continuous 8-bit signals.
This algorithm was used to compress 8-bit audio wave data on the Amiga.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>deltaFibonacciCompress(x, ...)

deltaFibonacciDecompress(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="deltaFibonacciCompress_+3A_x">x</code></td>
<td>
<p>A <code>vector</code> of <code>raw</code> data that needs to be (de)compressed.</p>
</td></tr>
<tr><td><code id="deltaFibonacciCompress_+3A_...">...</code></td>
<td>
<p>Currently ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This form of compression is lossy, meaning that information and quality will get lost.
8-bit audio is normally stored as an 8-bit signed value representing the amplitude
at specific time intervals. The delta-Fibonacci compression instead stores the
difference between two time intervals (delta) as a 4-bit index. This index in turn
represents a value from the Fibonacci series (hence the algorithm name). The compression
stores small delta values accurately, but large delta values less accurately.
As each sample is stored as a 4-bit value instead of an 8-bit value, the amount of
data is reduced with almost 50\
</p>
<p>The algorithm was first described by Steve Hayes and was used in 8SVX audio stored in
the Interchange File Format (IFF). The quality loss is considerable (especially
when the audio contained many large deltas) and was even in
the time it was developed (1985) not used much. The function is provided here for
the sake of completeness. The implementation here only compresses 8-bit data, as
for 16-bit data the quality loss will be more considerable.
</p>


<h3>Value</h3>

<p>Returns a <code>vector</code> of the resulting (de)compressed <code>raw</code> data.
</p>


<h3>Author(s)</h3>

<p>Pepijn de Vries
</p>


<h3>References</h3>

<p><a href="https://en.wikipedia.org/wiki/Delta_encoding">https://en.wikipedia.org/wiki/Delta_encoding</a>
</p>
<p><a href="http://amigadev.elowar.com/read/ADCD_2.1/Devices_Manual_guide/node02D6.html">http://amigadev.elowar.com/read/ADCD_2.1/Devices_Manual_guide/node02D6.html</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## Let's get an audio wave from the ProTrackR package, which we
## can use in this example:
buzz     &lt;- ProTrackR::PTSample(ProTrackR::mod.intro, 1)

## Let's convert it into raw data, such that we can compress it:
buzz.raw &lt;- adfExplorer::amigaIntToRaw(ProTrackR::waveform(buzz) - 128, 8, T)

## Let's compress it:
buzz.compress &lt;- deltaFibonacciCompress(buzz.raw)

## Look the new data uses less memory:
length(buzz.compress)/length(buzz.raw)

## The compression was lossy, which we can examine by decompressing the
## sample again:
buzz.decompress &lt;- deltaFibonacciDecompress(buzz.compress)

## And turn the raw data into numeric data:
buzz.decompress &lt;- adfExplorer::rawToAmigaInt(buzz.decompress, 8, T)

## Plot the original wave in black, the decompressed wave in blue
## and the error in red (difference between the original and decompressed
## wave). The error is actually very small here.
plot(ProTrackR::waveform(buzz) - 128, type = "l")
lines(buzz.decompress, col = "blue")
buzz.error &lt;- ProTrackR::waveform(buzz) - 128 - buzz.decompress
lines(buzz.error, col = "red")

## this can also be visualised by plotting the orignal wave data against
## the decompressed data (and observe a very good correlation):
plot(ProTrackR::waveform(buzz) - 128, buzz.decompress)

## Let's do the same with a sample of a snare drum, which has larger
## delta values:
snare.drum &lt;- ProTrackR::PTSample(ProTrackR::mod.intro, 2)

## Let's convert it into raw data, such that we can compress it:
snare.raw &lt;- adfExplorer::amigaIntToRaw(ProTrackR::waveform(snare.drum) - 128, 8, T)

## Let's compress it:
snare.compress &lt;- deltaFibonacciCompress(snare.raw)

## Decompress the sample:
snare.decompress &lt;- deltaFibonacciDecompress(snare.compress)

## And turn the raw data into numeric data:
snare.decompress &lt;- adfExplorer::rawToAmigaInt(snare.decompress, 8, T)

## Now if we make the same comparison as before, we note that the
## error in the decompressed wave is much larger than in the previous
## case (red line):
plot(ProTrackR::waveform(snare.drum) - 128, type = "l")
lines(snare.decompress, col = "blue")
snare.error &lt;- ProTrackR::waveform(snare.drum) - 128 - snare.decompress
lines(snare.error, col = "red")

## this can also be visualised by plotting the orignal wave data against
## the decompressed data (and observe a nice but not perfect correlation):
plot(ProTrackR::waveform(snare.drum) - 128, snare.decompress)

## End(Not run)
</code></pre>

<hr>
<h2 id='dither'>Image dithering</h2><span id='topic+dither'></span><span id='topic+dither.raster'></span><span id='topic+dither.matrix'></span>

<h3>Description</h3>

<p>Dither is an intentional form of noise applied to an image to avoid colour
banding when reducing the amount of colours in that image. This function
applies dithering to a grDevices <code>raster</code> image.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dither(x, method, ...)

## S3 method for class 'raster'
dither(
  x,
  method = c("none", "floyd-steinberg", "JJN", "stucki", "atkinson", "burkse", "sierra",
    "two-row-sierra", "sierra-lite"),
  palette,
  mode = c("none", "HAM6", "HAM8"),
  ...
)

## S3 method for class 'matrix'
dither(
  x,
  method = c("none", "floyd-steinberg", "JJN", "stucki", "atkinson", "burkse", "sierra",
    "two-row-sierra", "sierra-lite"),
  palette,
  mode = c("none", "HAM6", "HAM8"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dither_+3A_x">x</code></td>
<td>
<p>Original image data that needs to be dithered. Should be a raster object
(<code><a href="grDevices.html#topic+as.raster">grDevices::as.raster()</a></code>), or a matrix of <code>character</code> string
representing colours.</p>
</td></tr>
<tr><td><code id="dither_+3A_method">method</code></td>
<td>
<p>A <code>character</code> string indicating which dithering method should
be applied. See usage section for all possible options (Note that the &quot;JJN&quot; is
the Jarvis, Judice, and Ninke algorithm). Default is &quot;<code>none</code>&quot;, meaning that
no dithering is applied.</p>
</td></tr>
<tr><td><code id="dither_+3A_...">...</code></td>
<td>
<p>Currently ignored.</p>
</td></tr>
<tr><td><code id="dither_+3A_palette">palette</code></td>
<td>
<p>A palette to which the image should be dithered. It should be a
<code>vector</code> of <code>character</code> strings representing colours.</p>
</td></tr>
<tr><td><code id="dither_+3A_mode">mode</code></td>
<td>
<p>A <code>character</code> string indicating whether a special
Amiga display mode should be used when dithering. By default
&lsquo;<code>none</code>&rsquo; is used (no special mode). In addition,
&lsquo;<code>HAM6</code>&rsquo; and &lsquo;<code>HAM8</code>&rsquo; are supported.
See <code><a href="#topic+rasterToBitmap">rasterToBitmap()</a></code> for more details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The approaches implemented here all use error diffusion to achieve dithering.
Each pixel is scanned (from top to bottom, from left to right), where the actual
colour is sampled and compared with the closest matching colour in the palette.
The error (the differences between the actual and used colour) is distributed over
the surrounding pixels. The only difference between the methods implemented here
is the way the error is distributed. The algorithm itself is identical. For more
details consult the listed references.
</p>
<p>Which method results in the best quality image will depend on the original image
and the palette colours used for dithering, but is also a matter of taste. Note
that the dithering algorithm is relatively slow and is provided in this package
for your convenience. As it is not in the main scope of this package you should
use dedicated software for faster/better results.
</p>


<h3>Value</h3>

<p>Returns a <code>matrix</code> with the same dimensions as <code>x</code> containing
<code>numeric</code> index values. The corresponding palette is returned as attribute,
as well as the index value for the fully transparent colour in the palette.
</p>


<h3>Author(s)</h3>

<p>Pepijn de Vries
</p>


<h3>References</h3>

<p>R.W. Floyd, L. Steinberg, <em>An adaptive algorithm for spatial grey scale</em>. Proceedings of the Society of Information Display 17, 75-77 (1976).
</p>
<p>J. F. Jarvis, C. N. Judice, and W. H. Ninke, <em>A survey of techniques for the display of continuous tone pictures on bilevel displays</em>. Computer Graphics and Image Processing, 5:1:13-40 (1976).
</p>
<p><a href="https://en.wikipedia.org/wiki/Floyd-Steinberg_dithering">https://en.wikipedia.org/wiki/Floyd-Steinberg_dithering</a>
</p>
<p><a href="https://tannerhelland.com/4660/dithering-eleven-algorithms-source-code/">https://tannerhelland.com/4660/dithering-eleven-algorithms-source-code/</a>
</p>


<h3>See Also</h3>

<p>Other colour.quantisation.operations: 
<code><a href="#topic+index.colours">index.colours</a>()</code>
</p>
<p>Other raster.operations: 
<code><a href="#topic+AmigaBitmapFont">AmigaBitmapFont</a></code>,
<code><a href="#topic+as.raster.AmigaBasicShape">as.raster.AmigaBasicShape</a>()</code>,
<code><a href="#topic+bitmapToRaster">bitmapToRaster</a>()</code>,
<code><a href="#topic+index.colours">index.colours</a>()</code>,
<code><a href="#topic+rasterToAmigaBasicShape">rasterToAmigaBasicShape</a>()</code>,
<code><a href="#topic+rasterToAmigaBitmapFont">rasterToAmigaBitmapFont</a>()</code>,
<code><a href="#topic+rasterToBitmap">rasterToBitmap</a>()</code>,
<code><a href="#topic+rasterToHWSprite">rasterToHWSprite</a>()</code>,
<code><a href="#topic+rasterToIFF">rasterToIFF</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## first: Let's make a raster out of the 'volcano' data, which we can use in the example:
volcano.raster &lt;- as.raster(t(matrix(terrain.colors(1 + diff(range(volcano)))[volcano -
  min(volcano) + 1], nrow(volcano))))

## let's dither the image, using a predefined two colour palette:
volcano.dither &lt;- dither(volcano.raster,
                         method = "floyd-steinberg",
                         palette = c("yellow", "green"))

## Convert the indices back into a raster object, such that we can plot it:
volcano.dither &lt;- as.raster(apply(volcano.dither, 2, function(x) c("yellow", "green")[x]))
par(mfcol = c(1, 2))
plot(volcano.raster, interpolate = F)
plot(volcano.dither, interpolate = F)

## results will get better when a better matching colour palette is used.
## for that purpose use the function 'index.colours'.

## End(Not run)
</code></pre>

<hr>
<h2 id='font_example'>An example object for the AmigaBitmapFontSet class</h2><span id='topic+font_example'></span>

<h3>Description</h3>

<p>An example object for the <code><a href="#topic+AmigaBitmapFontSet">AmigaBitmapFontSet()</a></code> class used in
examples throughout this package. It also contains a nested
<code><a href="#topic+AmigaBitmapFont">AmigaBitmapFont()</a></code> class objects, which can be obtain by
using <code>getAmigaBitmapFont(font_example, 9)</code>.
</p>


<h3>Format</h3>


<p><code>font_example</code> is an <code><a href="#topic+AmigaBitmapFontSet">AmigaBitmapFontSet()</a></code>
object. For details see the object class documentation.
</p>


<h3>Details</h3>

<p>The <code>font_example</code> contains a font that was designed as an example
for this package. It holds bitmap glyphs for 8 and 9 pixels tall
characters.
</p>


<h3>See Also</h3>

<p>Other AmigaBitmapFont.operations: 
<code><a href="#topic+AmigaBitmapFont">AmigaBitmapFont</a></code>,
<code><a href="#topic+availableFontSizes">availableFontSizes</a>()</code>,
<code><a href="#topic+c">c</a>()</code>,
<code><a href="#topic+fontName">fontName</a>()</code>,
<code><a href="#topic+getAmigaBitmapFont">getAmigaBitmapFont</a>()</code>,
<code><a href="#topic+rasterToAmigaBitmapFont">rasterToAmigaBitmapFont</a>()</code>,
<code><a href="#topic+rawToAmigaBitmapFontSet">rawToAmigaBitmapFontSet</a>()</code>,
<code><a href="#topic+rawToAmigaBitmapFont">rawToAmigaBitmapFont</a>()</code>,
<code><a href="#topic+read.AmigaBitmapFontSet">read.AmigaBitmapFontSet</a>()</code>,
<code><a href="#topic+read.AmigaBitmapFont">read.AmigaBitmapFont</a>()</code>,
<code><a href="#topic+write.AmigaBitmapFont">write.AmigaBitmapFont</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("font_example")
</code></pre>

<hr>
<h2 id='fontName'>Extract or replace a font name</h2><span id='topic+fontName'></span><span id='topic+fontName+3C-'></span>

<h3>Description</h3>

<p>Extract or replace a font name from an <code><a href="#topic+AmigaBitmapFontSet">AmigaBitmapFontSet()</a></code>
object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fontName(x)

fontName(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fontName_+3A_x">x</code></td>
<td>
<p>An <code><a href="#topic+AmigaBitmapFontSet">AmigaBitmapFontSet()</a></code> for which the font name
needs to be changed.</p>
</td></tr>
<tr><td><code id="fontName_+3A_value">value</code></td>
<td>
<p>A <code>character</code> string specifying the name you
wish to use for the font.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The name of a font is embeded at multiple locations of an <code><a href="#topic+AmigaBitmapFontSet">AmigaBitmapFontSet()</a></code>
object. This function can be used to extract or replace the font name
correctly. This is also the name that will be used when writing the
font to a file with <code><a href="#topic+write.AmigaBitmapFontSet">write.AmigaBitmapFontSet()</a></code>.
</p>


<h3>Value</h3>

<p>Returns the font name. In case of the replace function, a copy
of <code>x</code> is returned with the name replaced by '<code>value</code>'.
</p>


<h3>Author(s)</h3>

<p>Pepijn de Vries
</p>


<h3>See Also</h3>

<p>Other AmigaBitmapFont.operations: 
<code><a href="#topic+AmigaBitmapFont">AmigaBitmapFont</a></code>,
<code><a href="#topic+availableFontSizes">availableFontSizes</a>()</code>,
<code><a href="#topic+c">c</a>()</code>,
<code><a href="#topic+font_example">font_example</a></code>,
<code><a href="#topic+getAmigaBitmapFont">getAmigaBitmapFont</a>()</code>,
<code><a href="#topic+rasterToAmigaBitmapFont">rasterToAmigaBitmapFont</a>()</code>,
<code><a href="#topic+rawToAmigaBitmapFontSet">rawToAmigaBitmapFontSet</a>()</code>,
<code><a href="#topic+rawToAmigaBitmapFont">rawToAmigaBitmapFont</a>()</code>,
<code><a href="#topic+read.AmigaBitmapFontSet">read.AmigaBitmapFontSet</a>()</code>,
<code><a href="#topic+read.AmigaBitmapFont">read.AmigaBitmapFont</a>()</code>,
<code><a href="#topic+write.AmigaBitmapFont">write.AmigaBitmapFont</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(font_example)

## show the name of the example font:
fontName(font_example)

## This is how you change the name into "foo"
fontName(font_example) &lt;- "foo"

## see it worked:
fontName(font_example)

## End(Not run)
</code></pre>

<hr>
<h2 id='getAmigaBitmapFont'>Extract a specific AmigaBitmapFont from a AmigaBitmapFontSet</h2><span id='topic+getAmigaBitmapFont'></span>

<h3>Description</h3>

<p>Extract a specific <code><a href="#topic+AmigaBitmapFont">AmigaBitmapFont()</a></code> from a
<code><a href="#topic+AmigaBitmapFontSet">AmigaBitmapFontSet()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getAmigaBitmapFont(x, size)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getAmigaBitmapFont_+3A_x">x</code></td>
<td>
<p>An <code><a href="#topic+AmigaBitmapFontSet">AmigaBitmapFontSet()</a></code> object, from which the
specific <code><a href="#topic+AmigaBitmapFont">AmigaBitmapFont()</a></code> object needs to be extracted.</p>
</td></tr>
<tr><td><code id="getAmigaBitmapFont_+3A_size">size</code></td>
<td>
<p>A single <code>numeric</code> value specifying the desired font
size in pixels. Use <code><a href="#topic+availableFontSizes">availableFontSizes()</a></code> to get available
sizes.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An <code><a href="#topic+AmigaBitmapFontSet">AmigaBitmapFontSet()</a></code> object can hold one or more
bitmaps for specific font sizes (heights). Use this function to
obtain such a specific <code><a href="#topic+AmigaBitmapFont">AmigaBitmapFont()</a></code>.
</p>


<h3>Value</h3>

<p>Returns an <code><a href="#topic+AmigaBitmapFont">AmigaBitmapFont()</a></code> of the requested size.
An error is thrown when the requested size is not available.
</p>


<h3>Author(s)</h3>

<p>Pepijn de Vries
</p>


<h3>See Also</h3>

<p>Other AmigaBitmapFont.operations: 
<code><a href="#topic+AmigaBitmapFont">AmigaBitmapFont</a></code>,
<code><a href="#topic+availableFontSizes">availableFontSizes</a>()</code>,
<code><a href="#topic+c">c</a>()</code>,
<code><a href="#topic+fontName">fontName</a>()</code>,
<code><a href="#topic+font_example">font_example</a></code>,
<code><a href="#topic+rasterToAmigaBitmapFont">rasterToAmigaBitmapFont</a>()</code>,
<code><a href="#topic+rawToAmigaBitmapFontSet">rawToAmigaBitmapFontSet</a>()</code>,
<code><a href="#topic+rawToAmigaBitmapFont">rawToAmigaBitmapFont</a>()</code>,
<code><a href="#topic+read.AmigaBitmapFontSet">read.AmigaBitmapFontSet</a>()</code>,
<code><a href="#topic+read.AmigaBitmapFont">read.AmigaBitmapFont</a>()</code>,
<code><a href="#topic+write.AmigaBitmapFont">write.AmigaBitmapFont</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(font_example)

## get the font object for the first available size:
font &lt;- getAmigaBitmapFont(font_example,
                           availableFontSizes(font_example)[1])

## End(Not run)
</code></pre>

<hr>
<h2 id='getIFFChunk'>Get a specific IFFChunk nested inside other IFFChunks</h2><span id='topic+getIFFChunk'></span><span id='topic+getIFFChunk+2CIFFChunk+2Ccharacter+2Cinteger-method'></span><span id='topic+getIFFChunk+2CIFFChunk+2Ccharacter+2Cmissing-method'></span><span id='topic+getIFFChunk+3C-'></span><span id='topic+getIFFChunk+3C-+2CIFFChunk+2Ccharacter+2Cmissing+2CIFFChunk-method'></span><span id='topic+getIFFChunk+3C-+2CIFFChunk+2Ccharacter+2Cinteger+2CIFFChunk-method'></span>

<h3>Description</h3>

<p><code><a href="#topic+IFFChunk">IFFChunk()</a></code>s can be nested in a tree-like structure. Use this method
to get a specific chunk with a specific label.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'IFFChunk,character,integer'
getIFFChunk(x, chunk.path, chunk.number)

## S4 method for signature 'IFFChunk,character,missing'
getIFFChunk(x, chunk.path, chunk.number)

## S4 replacement method for signature 'IFFChunk,character,missing,IFFChunk'
getIFFChunk(x, chunk.path, chunk.number = NULL) &lt;- value

## S4 replacement method for signature 'IFFChunk,character,integer,IFFChunk'
getIFFChunk(x, chunk.path, chunk.number = NULL) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getIFFChunk_+3A_x">x</code></td>
<td>
<p>An <code><a href="#topic+IFFChunk">IFFChunk()</a></code> object from which the nested
<code><a href="#topic+IFFChunk">IFFChunk()</a></code> should be extracted an returned.</p>
</td></tr>
<tr><td><code id="getIFFChunk_+3A_chunk.path">chunk.path</code></td>
<td>
<p>A <code>vector</code> of 4 <code>character</code> long strings
of IFF chunk labels, specifying the path of the target IFF chunk.
For example: <code>c("ILBM", "BODY")</code> means, get the &quot;BODY&quot; chunk
from inside the &quot;ILBM&quot; chunk.</p>
</td></tr>
<tr><td><code id="getIFFChunk_+3A_chunk.number">chunk.number</code></td>
<td>
<p>A <code>vector</code> of the same length as <code>chunk.path</code>,
with <code>integer</code> index numbers. Sometimes a chunk can contain a list of
chunks with the same label. With this argument you can specify which element
should be returned. By default (when missing), the first element is always
returned.</p>
</td></tr>
<tr><td><code id="getIFFChunk_+3A_value">value</code></td>
<td>
<p>An <code><a href="#topic+IFFChunk">IFFChunk()</a></code> with which the target chunk should be
replaced. Make sure that <code>value</code> is of the same <code>chunk.type</code> as the last
chunk specified in the <code>chunk.path</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>IFFChunk</code> objects have 4 <code>character</code> identifiers, indicating what type
of chunk you are dealing with. These chunks can be nested inside of each other.
Use this method to extract specific chunks by referring to there respective
identifiers. The identifiers are shown when calling <code>print</code> on an
<code><a href="#topic+IFFChunk">IFFChunk()</a></code>. If a specified path doesn't exist, this method throws a
&lsquo;subscript out of range&rsquo; error.
</p>


<h3>Value</h3>

<p>Returns an <code><a href="#topic+IFFChunk">IFFChunk()</a></code> object nested inside <code>x</code> at the
specified path. Or in case of the replace method the original chunk <code>x</code> is
returned with the target chunk replaced by <code>value</code>.
</p>


<h3>Author(s)</h3>

<p>Pepijn de Vries
</p>


<h3>See Also</h3>

<p>Other iff.operations: 
<code><a href="#topic+IFFChunk-class">IFFChunk-class</a></code>,
<code><a href="#topic+WaveToIFF">WaveToIFF</a>()</code>,
<code><a href="#topic+as.raster.AmigaBasicShape">as.raster.AmigaBasicShape</a>()</code>,
<code><a href="#topic+interpretIFFChunk">interpretIFFChunk</a>()</code>,
<code><a href="#topic+rasterToIFF">rasterToIFF</a>()</code>,
<code><a href="#topic+rawToIFFChunk">rawToIFFChunk</a>()</code>,
<code><a href="#topic+read.iff">read.iff</a>()</code>,
<code><a href="#topic+write.iff">write.iff</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## load an IFF file
example.iff &lt;- read.iff(system.file("ilbm8lores.iff", package = "AmigaFFH"))

## Get the BMHD (bitmap header) from the ILBM (interleaved bitmap) chunk:
bmhd &lt;- getIFFChunk(example.iff, c("ILBM", "BMHD"))

## This is essentially doing the same thing, but we now explicitly
## tell the method to get the first element for each specified label:
bmhd &lt;- getIFFChunk(example.iff, c("ILBM", "BMHD"), c(1L, 1L))

## Let's modify the bitmap header and replace it in the parent IFF chunk.
bmhd.itpt &lt;- interpretIFFChunk(bmhd)

## Let's disable the masking, the bitmap will no longer be transparent:
bmhd.itpt$Masking &lt;- "mskNone"
bmhd &lt;- IFFChunk(bmhd.itpt)

## Now replace the header from the original iff with the modified header:
getIFFChunk(example.iff, c("ILBM", "BMHD")) &lt;- bmhd

## End(Not run)
</code></pre>

<hr>
<h2 id='hardwareSprite-class'>The hardwareSprite class</h2><span id='topic+hardwareSprite-class'></span><span id='topic+hardwareSprite'></span>

<h3>Description</h3>

<p>An S4 class object that represent graphical objects known as
hardware sprites on the Commodore Amiga.
</p>


<h3>Details</h3>

<p>Amiga hardware supported sprites, which are graphical objects that
could be moved around the display and independently from each other.
Basic sprites were 16 pixels wide and any number of pixels high and
were composed of four colours, of which one is transparent.
</p>
<p>More complex sprites could be formed by linking separate sprites
together. That way, sprites could become wider, or be composed of
more colours. Such extended sprites are currently not supported
by this package.
</p>
<p>A well known example of hardware sprite on the Commodore Amiga is
the mouse pointer.
</p>
<p>This object simply holds the basic information belonging to
hardware sprite. Use <code><a href="#topic+as.raster">as.raster()</a></code> to convert it to
a raster which is a more useful graphical element in R.
</p>


<h3>Slots</h3>


<dl>
<dt><code>VStart</code></dt><dd><p>The vertical starting position of a sprite.</p>
</dd>
<dt><code>HStart</code></dt><dd><p>The horizontal starting position of a sprite.</p>
</dd>
<dt><code>VStop</code></dt><dd><p>The vertical stopping position of a sprite. The
height of a sprite should be given by <code>VStart</code> - <code>VStop</code>.</p>
</dd>
<dt><code>control.bits</code></dt><dd><p>8 <code>logical</code> values used for extending
sprites. The values are stored in this objects but extending
sprites is not (yet) supported.</p>
</dd>
<dt><code>bitmap</code></dt><dd><p>Interleaved bitmap data containing information on
the pixel colour numbers of the sprite.</p>
</dd>
<dt><code>colours</code></dt><dd><p>A vector of the 3 colours used for the sprite.</p>
</dd>
<dt><code>end.of.data</code></dt><dd><p>Sprite data can be followed by another sprite. It is terminated
with two WORDS equalling zero (<code>raw(4)</code>). Repeated sprite data is currently not
supported.</p>
</dd>
</dl>


<h3>Author(s)</h3>

<p>Pepijn de Vries
</p>


<h3>References</h3>

<p><a href="http://amigadev.elowar.com/read/ADCD_2.1/Hardware_Manual_guide/node00AE.html">http://amigadev.elowar.com/read/ADCD_2.1/Hardware_Manual_guide/node00AE.html</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## This generates a sprite of a single line (16x1 pixels) with an empty bitmap:
new("hardwareSprite")

## This generates a sprite of a single line (16x1 pixels) where
## the bitmap contains some coloured pixels:
new("hardwareSprite", bitmap = as.raw(c(0x01,0x02,0x03,0x04)))

## This generates a sprite of 16x16 pixels:
new("hardwareSprite",
    VStop = 16,
    bitmap = as.raw(sample.int(255, 64, replace = TRUE)))
</code></pre>

<hr>
<h2 id='IFFChunk-class'>A class structure to represent IFF files</h2><span id='topic+IFFChunk-class'></span>

<h3>Description</h3>

<p>An S4 class structure to represent data stored in the Interchange File
Format (IFF).
</p>


<h3>Details</h3>

<p>The Interchange File Format (IFF) was introduced in 1985 by Electronic Arts.
This format stores files in standardised modular objects, called &lsquo;chunks&rsquo;.
At the start of each chunk it is specified what type of data can be expected
and what the size of this data is. This was a very forward thinking way of
storing data, similar structures are still used in modern file formats (such
as PNG images and XML files).
</p>
<p>Although the IFF format is still in use, and new standardised chunk types can
still be registered, this package will focus on the older chunk types that
were primarily used on the Commodore Amiga (OS &lt;= 3.0). IFF files could
contain any kind of information. It could contain bitmap images, but also
audio clips or (formatted) texts.
</p>
<p>The <code>IFFChunk</code> class is designed such that it theoretically can hold
any type of IFF data. This package will mostly focus on the early IFF file types
(i.e., IFF chunks as originally registered by Electronic Arts). IFF files are
read by this package in a none lossy way (<code><a href="#topic+read.iff">read.iff()</a></code>), such that all
information is preserved (even if it is of an unknown type, as long as the chunk
identifier is 4 characters long).
</p>
<p>This means that the object needs to be interpreted in order to make sense out of
it (<code><a href="#topic+interpretIFFChunk">interpretIFFChunk()</a></code>). This interpretation returns simplified
interpretations of class <code>IFF.ANY</code> when it is supported (see
<code><a href="#topic+IFFChunk-method">IFFChunk-method()</a></code> for supported chunk types). Note that in the
interpretation process (meta-)information may get lost. converting
<code>IFF.ANY</code> objects back into <code><a href="#topic+IFFChunk">IFFChunk()</a></code> objects (if possible)
could therefore result in an object that is different from then one stored in the
original file and could even destroy the correct interpretation of IFF objects.
IFF files should thus be handled with care.
</p>


<h3>Slots</h3>


<dl>
<dt><code>chunk.type</code></dt><dd><p>A four <code>character</code> long code reflecting the type of
information represented by this chunk.</p>
</dd>
<dt><code>chunk.data</code></dt><dd><p>A <code>list</code> that holds either one or more valid
<code>IFFChunk</code>s or a single <code>vector</code> of <code>raw</code> data. This data
can only be interpreted in context of the specified type or in some cases
information from other <code>IFFChunk</code>s.</p>
</dd>
</dl>


<h3>Author(s)</h3>

<p>Pepijn de Vries
</p>


<h3>References</h3>

<p><a href="https://wiki.amigaos.net/wiki/IFF_Standard">https://wiki.amigaos.net/wiki/IFF_Standard</a>
</p>
<p><a href="https://wiki.amigaos.net/wiki/IFF_FORM_and_Chunk_Registry">https://wiki.amigaos.net/wiki/IFF_FORM_and_Chunk_Registry</a>
</p>
<p><a href="https://en.wikipedia.org/wiki/Interchange_File_Format">https://en.wikipedia.org/wiki/Interchange_File_Format</a>
</p>


<h3>See Also</h3>

<p>Other iff.operations: 
<code><a href="#topic+WaveToIFF">WaveToIFF</a>()</code>,
<code><a href="#topic+as.raster.AmigaBasicShape">as.raster.AmigaBasicShape</a>()</code>,
<code><a href="#topic+getIFFChunk">getIFFChunk</a>()</code>,
<code><a href="#topic+interpretIFFChunk">interpretIFFChunk</a>()</code>,
<code><a href="#topic+rasterToIFF">rasterToIFF</a>()</code>,
<code><a href="#topic+rawToIFFChunk">rawToIFFChunk</a>()</code>,
<code><a href="#topic+read.iff">read.iff</a>()</code>,
<code><a href="#topic+write.iff">write.iff</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## load an IFF file
example.iff &lt;- read.iff(system.file("ilbm8lores.iff", package = "AmigaFFH"))

## 'example.iff' is of class IFFChunk:
class(example.iff)

## let's plot it:
plot(example.iff)

## The default constructor will create an empty FORM:
new("IFFChunk")

## The constructor can also be used to create simple chunks:
new("IFFChunk",
    chunk.type = "TEXT",
    chunk.data = list(charToRaw("A simple chunk")))

## End(Not run)
</code></pre>

<hr>
<h2 id='IFFChunk-method'>Coerce to and create IFFChunk objects</h2><span id='topic+IFFChunk-method'></span><span id='topic+IFFChunk'></span><span id='topic+IFFChunk.character'></span><span id='topic+IFFChunk.IFF.FORM'></span><span id='topic+IFFChunk.IFF.BODY'></span><span id='topic+IFFChunk.IFF.ANNO'></span><span id='topic+IFFChunk.IFF.AUTH'></span><span id='topic+IFFChunk.IFF.CHRS'></span><span id='topic+IFFChunk.IFF.NAME'></span><span id='topic+IFFChunk.IFF.TEXT'></span><span id='topic+IFFChunk.IFF.copyright'></span><span id='topic+IFFChunk.IFF.CHAN'></span><span id='topic+IFFChunk.IFF.VHDR'></span><span id='topic+IFFChunk.IFF.8SVX'></span><span id='topic+IFFChunk.IFF.ILBM'></span><span id='topic+IFFChunk.IFF.CMAP'></span><span id='topic+IFFChunk.IFF.BMHD'></span><span id='topic+IFFChunk.IFF.CAMG'></span><span id='topic+IFFChunk.IFF.CRNG'></span><span id='topic+IFFChunk.IFF.ANIM'></span><span id='topic+IFFChunk.IFF.ANHD'></span><span id='topic+IFFChunk.IFF.DLTA'></span><span id='topic+IFFChunk.IFF.DPAN'></span>

<h3>Description</h3>

<p>Convert <code>IFF.ANY</code> objects (created with <code><a href="#topic+interpretIFFChunk">interpretIFFChunk()</a></code>) into
<code><a href="#topic+IFFChunk">IFFChunk()</a></code> objects. A basic <code><a href="#topic+IFFChunk">IFFChunk()</a></code> can also be
created with this method by providing the chunk type name.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>IFFChunk(x, ...)

## S3 method for class 'character'
IFFChunk(x, ...)

## S3 method for class 'IFF.FORM'
IFFChunk(x, ...)

## S3 method for class 'IFF.BODY'
IFFChunk(x, ...)

## S3 method for class 'IFF.ANNO'
IFFChunk(x, ...)

## S3 method for class 'IFF.AUTH'
IFFChunk(x, ...)

## S3 method for class 'IFF.CHRS'
IFFChunk(x, ...)

## S3 method for class 'IFF.NAME'
IFFChunk(x, ...)

## S3 method for class 'IFF.TEXT'
IFFChunk(x, ...)

## S3 method for class 'IFF.copyright'
IFFChunk(x, ...)

## S3 method for class 'IFF.CHAN'
IFFChunk(x, ...)

## S3 method for class 'IFF.VHDR'
IFFChunk(x, ...)

## S3 method for class 'IFF.8SVX'
IFFChunk(x, ...)

## S3 method for class 'IFF.ILBM'
IFFChunk(x, ...)

## S3 method for class 'IFF.CMAP'
IFFChunk(x, ...)

## S3 method for class 'IFF.BMHD'
IFFChunk(x, ...)

## S3 method for class 'IFF.CAMG'
IFFChunk(x, ...)

## S3 method for class 'IFF.CRNG'
IFFChunk(x, ...)

## S3 method for class 'IFF.ANIM'
IFFChunk(x, ...)

## S3 method for class 'IFF.ANHD'
IFFChunk(x, ...)

## S3 method for class 'IFF.DLTA'
IFFChunk(x, ...)

## S3 method for class 'IFF.DPAN'
IFFChunk(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="IFFChunk-method_+3A_x">x</code></td>
<td>
<p>An S3 class <code>IFF.ANY</code> object that needs to be coerced into an
<code><a href="#topic+IFFChunk-class">IFFChunk-class()</a></code> object. <code>IFF.ANY</code> objects are created with the
<code><a href="#topic+interpretIFFChunk">interpretIFFChunk()</a></code> method. <code>x</code> can also be a <code>character</code> string
of a IFF chunk type (e.g., &quot;<code>FORM</code>&quot; or &quot;<code>BMHD</code>&quot;). In that case an
<code><a href="#topic+IFFChunk">IFFChunk()</a></code> object of that type is created with some basic content.</p>
</td></tr>
<tr><td><code id="IFFChunk-method_+3A_...">...</code></td>
<td>
<p>Arguments passed onto methods underlying the interpretation of the
specific IFF chunks. Allowed arguments depend on the specific type of IFF chunk that
<code>x</code> represents.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>IFF data is stored in a <code><a href="#topic+IFFChunk-class">IFFChunk-class()</a></code> object when read from an
IFF file (<code><a href="#topic+read.iff">read.iff()</a></code>). These objects reflect the file structure
well, but the data is stored as <code>raw</code> information. IFF files can contain
a wide variety of information types, ranging from bitmap images to audio
clips. The raw information stored in <code><a href="#topic+IFFChunk">IFFChunk()</a></code> objects can
be interpreted into more meaningful representations that can be handled in
R. This is achieved with the <code><a href="#topic+interpretIFFChunk">interpretIFFChunk()</a></code> method, which
returns <code>IFF.ANY</code> objects.
</p>
<p>These <code>IFF.ANY</code> objects are a less strict representation of the
IFF Chunk, but are easier to handle in R. The interpretation method is lossy
and may not preserve all information in the <code>IFF.ANY</code> object.
The <code><a href="#topic+IFFChunk-method">IFFChunk-method()</a></code> can coerce <code>IFF.ANY</code> back
to the more strictly defined <code><a href="#topic+IFFChunk-class">IFFChunk-class()</a></code> objects.
Be careful with conversions between <code><a href="#topic+IFFChunk-class">IFFChunk-class()</a></code> and
<code>IFF.ANY</code> objects and vice versa, as information may get lost.
</p>
<p>More detailed information about IFF chunks can be found in the IFF chunk registry
(see references).
</p>

<ul>
<li> <p><code>IFF.FORM</code> represents a FORM chunk, which is a container that can hold any kind of chunk.
When interpreted, it is represented as a <code>list</code>, where each element is an interpreted chunk
nested inside the FORM.
</p>
</li>
<li> <p><code>IFF.BODY</code> represents the actual data in an IFF file. However, without context
this chunk cannot be interpreted and is therefore interpreted as a vector of <code>raw</code> data.
</p>
</li>
<li> <p><code>IFF.ANIM</code> represents an animation (ANIM) chunk. When interpreted, it will return a <code>list</code> where each
element is an animation frame represented as an <code>IFF.ILBM</code> object. Each animation frame should be
nested inside an ILBM chunk nested inside a FORM chunk, nested inside an ANIM chunk.
</p>

<ul>
<li> <p><code>IFF.ANHD</code> represents an ANimation HeaDer (ANHD) chunk. When interpreted,
it returns a named <code>list</code> containing the
following information:
</p>

<ul>
<li> <p><code>operation</code> is a <code>character</code> string indicating how the bitmap
data for the animation frame is encoded. Can be one of the following:
&quot;<code>standard</code>&quot;, &quot;<code>XOR</code>&quot;, &quot;<code>LongDeltaMode</code>&quot;,
&quot;<code>ShortDeltaMode</code>&quot;, &quot;<code>GeneralDeltamode</code>&quot;,
&quot;<code>ByteVerticalCompression</code>&quot;, &quot;<code>StereoOp5</code>&quot;, or
&quot;<code>ShortLongVerticalDeltaMode</code>&quot;. Currently, only the
ByteVerticalCompression is implemented in this package.
</p>
</li>
<li> <p><code>mask</code> is a <code>vector</code> of 8 <code>logical</code> values. It is currently
ignored.
</p>
</li>
<li> <p><code>w</code> and <code>h</code> are positive <code>numeric</code> values, specifying
the width and height of the frame (should be identical for all frames).
</p>
</li>
<li> <p><code>x</code> and <code>y</code> are <code>numeric</code> values, specifying the plotting
position for the frame.
</p>
</li>
<li> <p><code>abstime</code> is a positive <code>numeric</code> value - currently unused - used for
timing the frame relative to the time the first frame was displayed. In
jiffies (1/60 sec).
</p>
</li>
<li> <p><code>reltime</code> is a positive <code>numeric</code> value for timing the frame
relative to time previous frame was displayed. In jiffies (1/60 sec).
</p>
</li>
<li> <p><code>interleave</code> is currently unused. It should be set to 0.
</p>
</li>
<li> <p><code>pad0</code> is a padding byte (<code>raw</code>) for future use.
</p>
</li>
<li> <p><code>flags</code> is a <code>vector</code> of 32 <code>logical</code> values. They contain
information on how the bitmap data is stored.
</p>
</li>
<li> <p><code>pad1</code> are 16 padding bytes (<code>raw</code>) for future use.
</p>
</li></ul>

</li>
<li> <p><code>IFF.DPAN</code> represents an DPaint ANimation (DPAN) chunk. Some software will
require this chunk to correctly derive the total number of frames in the animation.
When interpreted, it will return a named <code>list</code> with the following elements:
</p>

<ul>
<li> <p><code>version</code> a <code>numeric</code> version number.
</p>
</li>
<li> <p><code>nframes</code> a positive <code>numeric</code> value, indicating the number
of frames in the animation.
</p>
</li>
<li> <p><code>flags</code> a <code>vector</code> of 32 <code>logical</code> values. Ignored in
this package as it was intended for future implementations.
</p>
</li></ul>

</li>
<li> <p><code>IFF.DLTA</code> represents a delta mode data chunk (DLTA). The first animation
frame is stored as a normal InterLeaved BitMap (ILBM) image as described below.
The following frames only store differences in bitmap data compared to the
previous frames but is not interleaved. They are thus incorrectly embedded in
an ILBM chunk (but is kept so for backward compatibility). When interpreted,
a <code>grDevices</code> raster object is returned only showing the differences. It
is not very meaningful to interpret these chunks on their own, but rather the
entire parent ANIM chunk.
</p>
</li></ul>

</li>
<li> <p><code>IFF.ILBM</code> represents InterLeaved BitMap (ILBM) chunks. It is interpreted here as a
raster image (see <code><a href="grDevices.html#topic+as.raster">grDevices::as.raster()</a></code>). ILBM chunks are usually nested inside
a FORM container.
</p>

<ul>
<li> <p><code>IFF.BMHD</code> represents the header chunk of a bitmap (BMHD), and should always be present
(nested inside) an ILBM chunk. It is interpreted as a named list containing the following elements:
</p>

<ul>
<li> <p><code>w</code> and <code>h</code> are positive <code>numeric</code> values specifying
the bitmap width and height in pixels. Note that the width
can be any positive whole number, whereas the bitmap data always
has a width divisible by 16.
</p>
</li>
<li> <p><code>x</code> and <code>y</code> are <code>numeric</code> values specifying the plotting
position relative to the top left position of the screen.
Although required in the bitmap header. It is ignored in the
interpretation of bitmap images.
</p>
</li>
<li> <p><code>nPlanes</code> is a positive value indicating the number of
bitplanes in the image. The number of colours in an image
can be calculated as <code>2^nPlanes</code>.
</p>
</li>
<li> <p><code>Masking</code> indicates whether there are bitplanes that should
be masked (i.e. are treated as transparent). It is a <code>character</code>
string equalling any of the following: &quot;<code>mskNone</code>&quot;,
&quot;<code>mskHasMask</code>&quot;, &quot;<code>mskHasTransparentColour</code>&quot;,
&quot;<code>mskLasso</code>&quot; or &quot;<code>mskUnknown</code>&quot;. Only the first (no transparency)
and third (one of the colours should be treated as transparent)
id is currently interpreted correctly. The others are ignored.
&quot;<code>mskUnknown</code>&quot; means that an undocumented mask is applied
to the image.
</p>
</li>
<li> <p><code>Compression</code> indicates whether the bitmap data is
compressed. It is a <code>character</code> string that can equal any
of the following: &quot;<code>cmpNone</code>&quot;, &quot;<code>cmpByteRun1</code>&quot; or
&quot;<code>cmpUnknown</code>&quot;. The latter means an undocumented form of
compression is applied and is currently ignored. In most cases
bitmap data is compressed with the <code>cmpByteRun1</code> algorithm
(<code><a href="#topic+packBitmap">packBitmap()</a></code>). In some cases, bitmap data is not
compressed (<code>cmpNone</code>).
</p>
</li>
<li> <p><code>pad</code> is a <code>raw</code> byte that is only used to
align data. It is ignored in the interpretation.
</p>
</li>
<li> <p><code>transparentColour</code> is a <code>numeric</code> value that indicates
which colour number in the palette should be treated as fully
transparent (when <code>Masking</code> equals
&quot;<code>mskHasTransparentColour</code>&quot;).
</p>
</li>
<li> <p><code>xAspect</code> and <code>yAspect</code> or positive <code>numeric</code>
values that indicate the aspect ratio of
the pixels in the image. Amiga screen modes allowed for some
extreme pixel aspect ratios. These values are used to stretch
the image to their intended display mode.
</p>
</li>
<li> <p><code>pageWidth</code> and <code>pageHeight</code> are positive
<code>numeric</code> values indicating the size of the screen in which
the image should be displayed. They are ignored in the
interpretation of the image.
</p>
</li></ul>

</li>
<li> <p><code>IFF.CMAP</code> represents the colour map (CMAP) or palette of a bitmap image. Although common,
the chunk is optional and can be omitted from the parent ILBM chunk. It is interpreted as a
vector of colours (i.e., a <code>character</code> string formatted as '#RRGGBB' or named colours such as
'blue').
</p>
</li>
<li> <p><code>IFF.CAMG</code> represents a chunk with information with respect
to the display mode in which the bitmap image should be displayed.
This information can be used to determine the correct pixel aspect
ratio, or is sometimes required to correctly interpret the bitmap
information. The <code>IFF.CAMG</code> chunk is interpreted as a named list
containing the following elements:
</p>

<ul>
<li> <p><code>monitor</code>: a <code>factor</code> indicating the hardware monitor
on which the image was created and should be displayed (see
<code><a href="#topic+amiga_monitors">amiga_monitors()</a></code>).
</p>
</li>
<li> <p><code>display.mode</code>: a <code>factor</code> indicating the display
mode in which the image should be displayed (see
<code><a href="#topic+amiga_display_modes">amiga_display_modes()</a></code>).
</p>
</li></ul>

</li>
<li> <p><code>IFF.CRNG</code> is an optional chunk nested in an ILBM chunk.
It represents a &lsquo;colour range&rsquo; and is used to cycle through
colours in the bitmap's palette in order to achieve
animation effects. It is interpreted as a named list with the
following elements. This chunk is currently not used with
the interpretation of ILBM images.
</p>

<ul>
<li> <p><code>padding</code> are two <code>raw</code> padding bytes and are
ignored when interpreted.
</p>
</li>
<li> <p><code>rate</code> is a <code>numeric</code> value specifying the rate
at which the colours are cycled. The rate is in steps per
second.
</p>
</li>
<li> <p><code>flags</code> is a flag that indicates how colours should
be cycled. It is a <code>character</code> string that can equal
any of the following: &quot;<code>RNG_OFF</code>&quot;, &quot;<code>RNG_ACTIVE</code>&quot;,
&quot;<code>RNG_REVERSE</code>&quot; or &quot;<code>RNG_UNKNOWN</code>&quot;. When equal to the
first, colours are not cycled. When equal to the second, colours
are cycled. When equal to the third, colours are cycled in
reverse direction. When equal to the latter, an undocumented
form of cycling is applied.
</p>
</li>
<li> <p><code>low</code> and <code>high</code> are <code>numeric</code> indices of
colours between which should be cycled. Only colour from
index <code>low</code> up to index <code>high</code> are affected.
</p>
</li></ul>

</li></ul>

</li>
<li> <p><code>IFF.8SVX</code> represents 8-bit sampled voice chunks (8SVX). The original
Amiga supported 8-bit audio which could be stored using the IFF. 8SVX chunks
can contain separate audio samples for each octave. 8SVX chunks are usually
stored inside a FORM container. Its body chunk contains 8-bit PCM wave data that
could be compressed. When the 8SVX chunk is
interpreted with this package, a <code>list</code> is returned where each element
represents an octave given as a <code><a href="tuneR.html#topic+Wave">tuneR::Wave()</a></code> object. Possible
chunks nested in 8SVX chunks and currently supported by this package are
as follows.
</p>

<ul>
<li> <p><code>IFF.VHDR</code> represents voice header chunks (VHDR). It contains (meta-)information about
the audio stored in the body of the parent 8SVX chunk. When interpreted, a named <code>list</code> is
returned with the following elements:
</p>

<ul>
<li> <p><code>oneShotHiSamples</code> is a <code>numeric</code> value indicating how many samples there are in the
audio wave of the first octave in the file, that should not be looped (repeated).
</p>
</li>
<li> <p><code>repeatHiSamples</code> is a <code>numeric</code> value indicating how many samples there are in the
audio wave of the first octave in the file, that should be looped (repeated).
</p>
</li>
<li> <p><code>samplesPerHiCycle</code> is a <code>numeric</code> value specifying the
number of samples per repeat cycle in the first octave, or 0 when unknown.
The number of <code>repeatHiSamples</code> should be an exact multiple of
<code>samplesPerHiCycle</code>.
</p>
</li>
<li> <p><code>samplesPerSec</code> is a <code>numeric</code> value specifying the data
sampling rate.
</p>
</li>
<li> <p><code>ctOctave</code> a positive whole <code>numeric</code> value indicating how many octaves are included.
In 8SVX files the audio wave is resampled for each octave. The wave data in the body starts with
the audio sample in the highest octave (least number of samples). The data is then followed by
each subsequent octave, where the number of samples increase by a factor of 2 for each octave.
</p>
</li>
<li> <p><code>sCompression</code> is a <code>character</code> string indicating whether and how the wave data in the body
is compressed. It can have one of the following values: &quot;<code>sCmpNone</code>&quot; (no compression),
&quot;<code>sCmpFibDelta</code>&quot; (<code><a href="#topic+deltaFibonacciCompress">deltaFibonacciCompress()</a></code>ion is applied), &quot;<code>sCmpUnknown</code>&quot; (an
undocumented and unknown form of compression is applied).
</p>
</li>
<li> <p><code>volume</code> is a numeric value between <code>0</code> (minimum) and <code>0x10000</code> (maximum) playback volume.
</p>
</li></ul>

</li>
<li> <p><code>IFF.CHAN</code> represents the channel chunk (CHAN). When interpreted it returns a named list
with 1 named element:
&quot;<code>channel</code>&quot;. It's value can be one of the following <code>character</code> strings &quot;<code>LEFT</code>&quot;, &quot;<code>RIGHT</code>&quot; or
&quot;<code>STEREO</code>&quot;. This indicates for how many (one or two) audio channels data is available in the
body of the parent
8SVX chunk. It also indicates two which channels the audio should be played back.
</p>
</li></ul>

</li>
<li> <p><code>IFF.ANNO</code>, <code>IFF.AUTH</code>, <code>IFF.CHRS</code>, <code>IFF.NAME</code>, <code>IFF.TEXT</code> and <code>IFF.copyright</code>
are all unformatted text chunks that can be included optionally in any of the chunk types.
Respectively, they
represent an annotation, the author's name, a generic character string, the name of the work,
generic unformatted text,
and copyright text. They are interpreted as a <code>character</code> string.
</p>
</li></ul>



<h3>Value</h3>

<p>Returns an <code><a href="#topic+IFFChunk-class">IFFChunk-class()</a></code> representation of <code>x</code>.
</p>


<h3>References</h3>

<p><a href="https://wiki.amigaos.net/wiki/IFF_FORM_and_Chunk_Registry">https://wiki.amigaos.net/wiki/IFF_FORM_and_Chunk_Registry</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## load an IFF file
example.iff &lt;- read.iff(system.file("ilbm8lores.iff", package = "AmigaFFH"))

## interpret the IFF file (in some cases information
## will get lost in this step):
example.itpt &lt;- interpretIFFChunk(example.iff)

## now coerce back to a formal IFFChunk class object.
## Only information in the interpreted object is used
## The coerced object may therefore depart from the
## original read from the file.
example.coerce &lt;- IFFChunk(example.itpt)

## and indeed the objects are not identical, as shown below.
## In this case the difference is not disastrous, the order
## of the colours in the palette have shifted. But be careful
## with switching between formal IFFChunk objects and
## interpreted IFF.ANY objects.
identical(example.iff, example.coerce)

## It is also possible to create simple IFFChunk objects
## by providing the desired chunk type identifier as a
## character string.

## This creates a basic bitmap header:
bmhd &lt;- IFFChunk("BMHD")

## This creates a basic colour palette:
cmap &lt;- IFFChunk("CMAP")

## End(Not run)
</code></pre>

<hr>
<h2 id='ilbm8lores.iff'>An example file of a bitmap image stored in the Interchange File Format</h2><span id='topic+ilbm8lores.iff'></span>

<h3>Description</h3>

<p>This file is provided to demonstrate the structure of an Interchange File
Format and is used in several examples throughout this package.
</p>


<h3>Format</h3>


<p>See <code><a href="#topic+IFFChunk-class">IFFChunk-class()</a></code> and references for more information
about the Interchange File Format.
</p>


<h3>Details</h3>

<p>The Interchange File Format stores information compartmentally in separate
containers called 'chunks'. This file demonstrates how a bitmap image
is stored in this format. In addition to the raw bitmap data, the file
also contains meta-information on the bitmap dimensions, its colour palette and
the display mode that should be used on an Amiga. See also
<code><a href="#topic+interpretIFFChunk">interpretIFFChunk()</a></code>, <code><a href="#topic+IFFChunk-class">IFFChunk-class()</a></code>
and the example for <code><a href="#topic+bitmapToRaster">bitmapToRaster()</a></code>.
</p>


<h3>References</h3>

<p><a href="https://en.wikipedia.org/wiki/Interchange_File_Format">https://en.wikipedia.org/wiki/Interchange_File_Format</a>
</p>
<p><a href="https://wiki.amigaos.net/wiki/A_Quick_Introduction_to_IFF">https://wiki.amigaos.net/wiki/A_Quick_Introduction_to_IFF</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
filename &lt;- system.file("ilbm8lores.iff", package = "AmigaFFH")
example.iff &lt;- read.iff(filename)

## show the structure of the IFF file:
print(example.iff)

## End(Not run)
</code></pre>

<hr>
<h2 id='index.colours'>Quantisation of colours and indexing a grDevices raster image</h2><span id='topic+index.colours'></span>

<h3>Description</h3>

<p>Converts an image represented by a grDevices <code>raster</code> object into a
matrix containing numeric indices of a quantised colour palette.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>index.colours(
  x,
  length.out = 8,
  palette = NULL,
  background = "#FFFFFF",
  dither = c("none", "floyd-steinberg", "JJN", "stucki", "atkinson", "burkse", "sierra",
    "two-row-sierra", "sierra-lite"),
  colour.depth = c("12 bit", "24 bit"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="index.colours_+3A_x">x</code></td>
<td>
<p>A raster object (<code><a href="grDevices.html#topic+as.raster">grDevices::as.raster()</a></code>), or a <code>matrix</code>
containing <code>character</code> strings representing colours. <code>x</code> can also
be a <code>list</code> of such matrices or rasters. All elements of this list should
have identical dimensions. An overall palette will be generated for elements in the
list.</p>
</td></tr>
<tr><td><code id="index.colours_+3A_length.out">length.out</code></td>
<td>
<p>A <code>numeric</code> value indicating the number of desired
colours in the indexed palette.
</p>
<p>It can also be a <code>character</code> string indicating which special
Amiga display mode should be used when indexing colours.
&lsquo;<code>HAM6</code>&rsquo; and &lsquo;<code>HAM8</code>&rsquo; are supported.
See <code><a href="#topic+rasterToBitmap">rasterToBitmap()</a></code> for more details on these
special modes.</p>
</td></tr>
<tr><td><code id="index.colours_+3A_palette">palette</code></td>
<td>
<p>A vector of no more than <code>length.out</code> colours, to be used
for the bitmap image. When missing or set to <code>NULL</code>, a palette will be
generated based on the provided colours in raster <code>x</code>. In that case,
<code><a href="stats.html#topic+kmeans">stats::kmeans()</a></code> is used on the hue, saturation, brightness and
alpha values of the colours in <code>x</code> for clustering the colours. The cluster
centres will be used as palette colours.</p>
</td></tr>
<tr><td><code id="index.colours_+3A_background">background</code></td>
<td>
<p>On the Amiga, indexed images could not be semi-transparent.
Only a single colour could be designated as being fully transparent. The
&ldquo;background'' argument should contain a background colour with which
semi-transparent colours should be mixed, before colour quantisation. It is
white by default.</p>
</td></tr>
<tr><td><code id="index.colours_+3A_dither">dither</code></td>
<td>
<p>Dither the output image using the algorithm specified here.
See the usage section for possible options. By default no dithering (&quot;<code>none</code>&quot;)
is applied. See <code><a href="#topic+dither">dither()</a></code> for more details.</p>
</td></tr>
<tr><td><code id="index.colours_+3A_colour.depth">colour.depth</code></td>
<td>
<p>A <code>character</code> string indicating the colour depth to be used.
Can be either &quot;<code style="white-space: pre;">&#8288;12 bit&#8288;</code>&quot; (default, standard on an Amiga with original chipset),
or &quot;<code style="white-space: pre;">&#8288;24 bit&#8288;</code>&quot;.
</p>
<p>This argument is overruled when <code>length.out</code> is set to &ldquo;<code>HAM6</code>&rdquo;
or &ldquo;<code>HAM8</code>&rdquo;. In that case the colour depth linked to that special mode
is used (12 bit for HAM6, 24 bit for HAM8).</p>
</td></tr>
<tr><td><code id="index.colours_+3A_...">...</code></td>
<td>
<p>Arguments that are passed onto <code><a href="stats.html#topic+kmeans">stats::kmeans()</a></code> (see
<code>palette</code> argument).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Determines the optimal limited palette by clustering colours in an image
with <code><a href="stats.html#topic+kmeans">stats::kmeans()</a></code>. The result of the optimisation routine
will depend on the randomly chosen cluster centres by this algorithm. This
means that the result may slightly differ for each call to this function. If
you want reproducible results, you may want to reset the random seed
(<code><a href="base.html#topic+set.seed">set.seed()</a></code>) before each call to this function.
</p>


<h3>Value</h3>

<p>Returns a <code>matrix</code> with the same dimensions as <code>x</code> containing
<code>numeric</code> index values. The corresponding palette is returned as attribute,
as well as the index value for the fully transparent colour in the palette.
When <code>x</code> is a <code>list</code> a <code>list</code> of matrices is returned.
</p>


<h3>Author(s)</h3>

<p>Pepijn de Vries
</p>


<h3>See Also</h3>

<p>Other colour.quantisation.operations: 
<code><a href="#topic+dither">dither</a>()</code>
</p>
<p>Other raster.operations: 
<code><a href="#topic+AmigaBitmapFont">AmigaBitmapFont</a></code>,
<code><a href="#topic+as.raster.AmigaBasicShape">as.raster.AmigaBasicShape</a>()</code>,
<code><a href="#topic+bitmapToRaster">bitmapToRaster</a>()</code>,
<code><a href="#topic+dither">dither</a>()</code>,
<code><a href="#topic+rasterToAmigaBasicShape">rasterToAmigaBasicShape</a>()</code>,
<code><a href="#topic+rasterToAmigaBitmapFont">rasterToAmigaBitmapFont</a>()</code>,
<code><a href="#topic+rasterToBitmap">rasterToBitmap</a>()</code>,
<code><a href="#topic+rasterToHWSprite">rasterToHWSprite</a>()</code>,
<code><a href="#topic+rasterToIFF">rasterToIFF</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## first: Let's make a raster out of the 'volcano' data, which we can use in the example:
volcano.raster &lt;- as.raster(t(matrix(terrain.colors(1 + diff(range(volcano)))[volcano -
  min(volcano) + 1], nrow(volcano))))

## This will create an image of the original raster using an indexed palette:
volcano.index &lt;- index.colours(volcano.raster)

## The index values can be converted back into colours, using the palette:
volcano.index &lt;- as.raster(apply(volcano.index, 2,
                                 function(x) attributes(volcano.index)$palette[x]))

## Create an indexed image using dithering
volcano.dith &lt;- index.colours(volcano.raster, dither = "floyd-steinberg")
volcano.dith &lt;- as.raster(apply(volcano.dith, 2,
                                function(x) attributes(volcano.dith)$palette[x]))

## plot the images side by side for comparison
par(mfcol = c(1, 3))
plot(volcano.raster, interpolate = F)
plot(volcano.index, interpolate = F)
plot(volcano.dith, interpolate = F)

## End(Not run)
</code></pre>

<hr>
<h2 id='interpretIFFChunk'>Interpret an IFFChunk object</h2><span id='topic+interpretIFFChunk'></span><span id='topic+interpretIFFChunk+2CIFFChunk-method'></span>

<h3>Description</h3>

<p><code><a href="#topic+IFFChunk">IFFChunk()</a></code>s represent the structure of the Interchange File Format well,
but the iformation is stored as <code>raw</code> data. This method tries to interpret and
translate the information into a more comprehensive format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'IFFChunk'
interpretIFFChunk(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="interpretIFFChunk_+3A_x">x</code></td>
<td>
<p>An <code><a href="#topic+IFFChunk">IFFChunk()</a></code> object which needs to be interpreted.</p>
</td></tr>
<tr><td><code id="interpretIFFChunk_+3A_...">...</code></td>
<td>
<p>Currently ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Interchange File Format chunks can hold any kind of information (images, audio,
(formatted) text, etc.). This method will try to convert this information into
something useful. Information may get lost in the translation, so be careful when
converting back to an <code><a href="#topic+IFFChunk-class">IFFChunk-class()</a></code> object using
<code><a href="#topic+IFFChunk-method">IFFChunk-method()</a></code>.
</p>
<p>An error is thrown when the <code><a href="#topic+IFFChunk">IFFChunk()</a></code> object is currently not
interpretable by this package. See <code><a href="#topic+IFFChunk-method">IFFChunk-method()</a></code> for an overview
of currently supported IFF chunks. This list may increase while this package
matures.
</p>


<h3>Value</h3>

<p>If <code>x</code> is interpretable by this package an S3 class object of
<code>IFF.ANY</code> is returned. The content of the returned object will depend
on the type of <code><a href="#topic+IFFChunk">IFFChunk()</a></code> provided for <code>x</code>. The result can
for instance be a <code>raster</code> image (<code><a href="grDevices.html#topic+as.raster">grDevices::as.raster()</a></code>),
a list of audio <code><a href="tuneR.html#topic+Wave">tuneR::Wave()</a></code>s, a <code>character</code> string or a named
<code>list</code>.
</p>


<h3>Author(s)</h3>

<p>Pepijn de Vries
</p>


<h3>See Also</h3>

<p>Other iff.operations: 
<code><a href="#topic+IFFChunk-class">IFFChunk-class</a></code>,
<code><a href="#topic+WaveToIFF">WaveToIFF</a>()</code>,
<code><a href="#topic+as.raster.AmigaBasicShape">as.raster.AmigaBasicShape</a>()</code>,
<code><a href="#topic+getIFFChunk">getIFFChunk</a>()</code>,
<code><a href="#topic+rasterToIFF">rasterToIFF</a>()</code>,
<code><a href="#topic+rawToIFFChunk">rawToIFFChunk</a>()</code>,
<code><a href="#topic+read.iff">read.iff</a>()</code>,
<code><a href="#topic+write.iff">write.iff</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## load an IFF file
example.iff &lt;- read.iff(system.file("ilbm8lores.iff", package = "AmigaFFH"))

## in this case, the file is a FORM container with a bitmap image, and a
## list with a raster object is returned when interpreted:
example.itpt &lt;- interpretIFFChunk(example.iff)
class(example.itpt)
typeof(example.itpt)
class(example.itpt[[1]])

## Let's extraxt the bitmap header from the main chunk:
bmhd &lt;- getIFFChunk(example.iff, c("ILBM", "BMHD"))

## When interpreted, a named list is returned with (meta-)information
## on the bitmap image:
bmhd.itpt &lt;- interpretIFFChunk(bmhd)
class(bmhd.itpt)
typeof(bmhd.itpt)
print(bmhd.itpt)

## End(Not run)
</code></pre>

<hr>
<h2 id='names.AmigaBasic'>Extract or replace variable and label names from Amiga Basic scripts</h2><span id='topic+names.AmigaBasic'></span><span id='topic+names+3C-.AmigaBasic'></span>

<h3>Description</h3>

<p>In the binary Amiga Basic files, names for labels and variables
in the code are stored at the end of the file. In the encoded
there is only a pointer to the index of the name in that list. Use
this function to list, select or replace names included in the code
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'AmigaBasic'
names(x)

## S3 replacement method for class 'AmigaBasic'
names(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="names.AmigaBasic_+3A_x">x</code></td>
<td>
<p>An <code><a href="#topic+AmigaBasic">AmigaBasic()</a></code>-class object for which to obtain or change variable and/or label names</p>
</td></tr>
<tr><td><code id="names.AmigaBasic_+3A_value">value</code></td>
<td>
<p>A (<code>vector</code> of) <code>character</code> string of desired replacement variable/label names.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Make sure that variable and label names are valid for the basic script (see <a href="#topic+check.names.AmigaBasic">check.names.AmigaBasic</a>).
</p>


<h3>Value</h3>

<p>A <code>vector</code> of <code>character</code> strings with label and variable names in the basic script.
In case of the replacement method a <code><a href="#topic+AmigaBasic">AmigaBasic()</a></code>-class with replaced names is returned.
</p>


<h3>Author(s)</h3>

<p>Pepijn de Vries
</p>


<h3>See Also</h3>

<p>Other AmigaBasic.operations: 
<code><a href="#topic+AmigaBasic.reserved">AmigaBasic.reserved</a>()</code>,
<code><a href="#topic+AmigaBasicBMAP">AmigaBasicBMAP</a></code>,
<code><a href="#topic+AmigaBasic">AmigaBasic</a></code>,
<code><a href="#topic++5B.AmigaBasic">[.AmigaBasic</a>()</code>,
<code><a href="#topic+as.AmigaBasicBMAP">as.AmigaBasicBMAP</a>()</code>,
<code><a href="#topic+as.AmigaBasic">as.AmigaBasic</a>()</code>,
<code><a href="#topic+as.character">as.character</a>()</code>,
<code><a href="#topic+check.names.AmigaBasic">check.names.AmigaBasic</a>()</code>,
<code><a href="#topic+rawToAmigaBasicBMAP">rawToAmigaBasicBMAP</a>()</code>,
<code><a href="#topic+rawToAmigaBasic">rawToAmigaBasic</a>()</code>,
<code><a href="#topic+read.AmigaBasicBMAP">read.AmigaBasicBMAP</a>()</code>,
<code><a href="#topic+read.AmigaBasic">read.AmigaBasic</a>()</code>,
<code><a href="#topic+write.AmigaBasic">write.AmigaBasic</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Let's create some Basic code with labels and variables:
bas &lt;- as.AmigaBasic(c(
  "REM - This will loop forever...",
  "my.label:",
  "  my.variable% = 0",
  "  WHILE my.variable% &lt; 10",
  "    my.variable% = my.variable% + 1",
  "  WEND",
  "  GOTO my.label"
))

## list the names in the script above:
names(bas)

## change the first name:
names(bas)[1] &lt;- "better.label"
</code></pre>

<hr>
<h2 id='packBitmap'>A routine to (un)pack bitmap data</h2><span id='topic+packBitmap'></span><span id='topic+unPackBitmap'></span>

<h3>Description</h3>

<p>A very simplistic lossless routine to (un)pack repetitive bitmap data. Often
used in InterLeaved BitMap (ILBM) images in IFF containers (<code><a href="#topic+IFFChunk">IFFChunk()</a></code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>packBitmap(x)

unPackBitmap(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="packBitmap_+3A_x">x</code></td>
<td>
<p><code>raw</code> data, usually representing a (packed) bitmap.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>InterLeaved BitMap (ILBM) images on the Amiga often use a packing algorithm
referred to as &lsquo;ByteRun1&rsquo;. This routine was introduced first on
the Macintosh where it was called PackBits. It is a form of run-length encoding
and is very simple:
when a specific byte is repeated in a bitmap, it is replaced by
a (signed negative) byte telling how many times the following byte
should be repeated. When a series of bytes are not repetitive, it
is preceded by a (signed positive) byte telling how long the non
repetitive part is.
</p>
<p>Not very complicated, but for most images some bytes can be shaved
off the file. This was very useful when everything had to be stored
on 880 kilobyte floppy disks with little CPU time to spare. Note
that the file size can also increase for (noisy) images.
</p>
<p>This packing routine will pack the entire bitmap (<code>x</code>)
at once. The IFF file format requires packing of bitmap data per
scanline. This is done automatically by the <code><a href="#topic+rasterToIFF">rasterToIFF()</a></code>
function, which calls this packing routine per scanline.
</p>


<h3>Value</h3>

<p>Returns packed or unpacked <code>raw</code> data, depending on
whether <code>packBitmap</code> or <code>unPackBitmap</code> was called.
</p>


<h3>Author(s)</h3>

<p>Pepijn de Vries
</p>


<h3>References</h3>

<p><a href="http://amigadev.elowar.com/read/ADCD_2.1/Devices_Manual_guide/node01C0.html">http://amigadev.elowar.com/read/ADCD_2.1/Devices_Manual_guide/node01C0.html</a>
</p>
<p><a href="https://en.wikipedia.org/wiki/PackBits">https://en.wikipedia.org/wiki/PackBits</a>
</p>


<h3>See Also</h3>

<p>Other raw.operations: 
<code><a href="#topic+as.AmigaBasic">as.AmigaBasic</a>()</code>,
<code><a href="#topic+as.raw.AmigaBasic">as.raw.AmigaBasic</a>()</code>,
<code><a href="#topic+colourToAmigaRaw">colourToAmigaRaw</a>()</code>,
<code><a href="#topic+rawToAmigaBasicBMAP">rawToAmigaBasicBMAP</a>()</code>,
<code><a href="#topic+rawToAmigaBasicShape">rawToAmigaBasicShape</a>()</code>,
<code><a href="#topic+rawToAmigaBasic">rawToAmigaBasic</a>()</code>,
<code><a href="#topic+rawToAmigaBitmapFontSet">rawToAmigaBitmapFontSet</a>()</code>,
<code><a href="#topic+rawToAmigaBitmapFont">rawToAmigaBitmapFont</a>()</code>,
<code><a href="#topic+rawToAmigaIcon">rawToAmigaIcon</a>()</code>,
<code><a href="#topic+rawToHWSprite">rawToHWSprite</a>()</code>,
<code><a href="#topic+rawToIFFChunk">rawToIFFChunk</a>()</code>,
<code><a href="#topic+rawToSysConfig">rawToSysConfig</a>()</code>,
<code><a href="#topic+simpleAmigaIcon">simpleAmigaIcon</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## generate some random raw data:
dat.rnd &lt;- as.raw(sample.int(10, 100, TRUE))

## try to pack it:
pack.rnd &lt;- packBitmap(dat.rnd)

## due to the random nature of the source data
## the data could not be packed efficiently.
## The length of the packed data is close to
## the length of the original data:
length(pack.rnd) - length(dat.rnd)

## Now generate similar data but sort it
## to generate more repetitive data:
dat.srt  &lt;- as.raw(sort(sample.int(10, 100, TRUE)))
pack.srt &lt;- packBitmap(dat.srt)

## This time the packing routing is more successful:
length(pack.srt) - length(dat.srt)

## The original data can always be obtained
## from the packed data:
all(dat.rnd == unPackBitmap(pack.rnd))
all(dat.srt == unPackBitmap(pack.srt))
</code></pre>

<hr>
<h2 id='play'>Playing Amiga audio data</h2><span id='topic+play'></span><span id='topic+play+2CANY-method'></span><span id='topic+play+2CIFFChunk-method'></span>

<h3>Description</h3>

<p>A wrapper for <code><a href="tuneR.html#topic+tuneR">tuneR()</a></code>-package's <code><a href="tuneR.html#topic+play">tuneR::play()</a></code> routine. Allowing it to play
Amiga audio (for instance stored in an 8SVX Interchange File Format).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'ANY'
play(object, player = NULL, ...)

## S4 method for signature 'IFFChunk'
play(object, player = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="play_+3A_object">object</code></td>
<td>
<p>An <code><a href="#topic+IFFChunk-class">IFFChunk-class()</a></code> object that needs to be played. The <code><a href="#topic+IFFChunk">IFFChunk()</a></code>
should be of type FORM, containing an 8SVX chunk, or an 8SVX itself. <code>object</code> can also be of class
<code>IFF.FORM</code> or <code>IFF.8SVX</code>. See <code><a href="tuneR.html#topic+play">tuneR::play()</a></code> for other objects that can be played.</p>
</td></tr>
<tr><td><code id="play_+3A_player">player</code></td>
<td>
<p>Path to the external audio player. See <code><a href="tuneR.html#topic+play">tuneR::play()</a></code> for more details.</p>
</td></tr>
<tr><td><code id="play_+3A_...">...</code></td>
<td>
<p>Arguments passed onto the tuneR <code><a href="#topic+play">play()</a></code> routine.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A wrapper for <code><a href="tuneR.html#topic+tuneR">tuneR()</a></code>-package's <code><a href="tuneR.html#topic+play">tuneR::play()</a></code> routine. It will try to play
audio using an external audio player. When 8SVX audio is played, each octave is played separately.
When a FORM container contains multiple 8SVX samples, they are also played successively.
</p>
<p>Note that a separate package is developed to interpret and play ProTracker modules and samples
(<code><a href="ProTrackR.html#topic+ProTrackR-package">ProTrackR()</a></code>).
</p>


<h3>Value</h3>

<p>Returns a list of data returned by tuneR's <code><a href="tuneR.html#topic+play">tuneR::play()</a></code>, for which the output
is undocumented.
</p>


<h3>Author(s)</h3>

<p>Pepijn de Vries
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## First get an audio sample from the ProTrackR package
snare.samp &lt;- ProTrackR::PTSample(ProTrackR::mod.intro, 2)

## Coerce it into an IFFChunk object:
snare.iff &lt;- WaveToIFF(snare.samp)

## Play the 8SVX sample:
play(snare.iff)

## End(Not run)
</code></pre>

<hr>
<h2 id='plot.AmigaBasicShape'>Plot AmigaFFH objects</h2><span id='topic+plot.AmigaBasicShape'></span><span id='topic+plot'></span><span id='topic+plot.AmigaBitmapFont'></span><span id='topic+plot.AmigaBitmapFontSet'></span><span id='topic+plot.hardwareSprite'></span><span id='topic+plot.IFFChunk'></span><span id='topic+plot.IFF.FORM'></span><span id='topic+plot.IFF.8SVX'></span><span id='topic+plot.IFF.ILBM'></span><span id='topic+plot.IFF.ANIM'></span><span id='topic+plot.SysConfig'></span><span id='topic+plot.AmigaIcon'></span>

<h3>Description</h3>

<p>Plot AmigaFFH objects using <code>base</code> plotting routines.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'AmigaBasicShape'
plot(x, y, ...)

## S3 method for class 'AmigaBitmapFont'
plot(x, y, ...)

## S3 method for class 'AmigaBitmapFontSet'
plot(x, y, ...)

## S3 method for class 'hardwareSprite'
plot(x, y, ...)

## S3 method for class 'IFFChunk'
plot(x, y, ...)

## S3 method for class 'IFF.FORM'
plot(x, y, ...)

## S3 method for class 'IFF.8SVX'
plot(x, y, ...)

## S3 method for class 'IFF.ILBM'
plot(x, y, ...)

## S3 method for class 'IFF.ANIM'
plot(x, y, ...)

## S3 method for class 'SysConfig'
plot(x, y, ...)

## S3 method for class 'AmigaIcon'
plot(x, y, asp = 2, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.AmigaBasicShape_+3A_x">x</code></td>
<td>
<p>An AmigaFFH object to be plotted. See usage section for supported object
classes. If <code>x</code> is an <code><a href="#topic+AmigaBitmapFont">AmigaBitmapFont()</a></code> or <code><a href="#topic+AmigaBitmapFontSet">AmigaBitmapFontSet()</a></code>
class object, it will plot the full bitmap that is used to extract the font glyphs.</p>
</td></tr>
<tr><td><code id="plot.AmigaBasicShape_+3A_y">y</code></td>
<td>
<p>When <code>x</code> is an <code><a href="#topic+AmigaIcon">AmigaIcon()</a></code> class object, <code>y</code> can be used as
an index. In that case, when <code>y=1</code> the first icon image is shown. When <code>y=2</code>
the selected icon image is shown.
</p>
<p>When <code>x</code> is an <code><a href="#topic+AmigaBitmapFontSet">AmigaBitmapFontSet()</a></code> class
object, <code>y</code> can be used to plot the bitmap of a specific font height (<code>y</code>).
</p>
<p>When <code>x</code> is an <code><a href="#topic+AmigaBasicShape">AmigaBasicShape()</a></code> class object, <code>y</code> can be used to select a
specific layer of the shape to plot, which can be one of <code>"bitmap"</code>, <code>"shadow"</code> or <code>"collision"</code>.</p>
</td></tr>
<tr><td><code id="plot.AmigaBasicShape_+3A_...">...</code></td>
<td>
<p>Parameters passed onto the generic <code>graphics</code> plotting routine.
</p>
<p>When <code>x</code> is an <code><a href="#topic+AmigaBitmapFont">AmigaBitmapFont()</a></code> or an <code><a href="#topic+AmigaBitmapFontSet">AmigaBitmapFontSet()</a></code>
object, '<code>...</code>' can also be used for arguments that need to be
passed onto the <code><a href="#topic+as.raster">as.raster()</a></code> function.</p>
</td></tr>
<tr><td><code id="plot.AmigaBasicShape_+3A_asp">asp</code></td>
<td>
<p>A <code>numeric</code> value indicating the aspect ratio for the plot. For
many AmigaFFH, the aspect ratio will be based on the Amiga display mode when known.
For <code><a href="#topic+AmigaIcon">AmigaIcon()</a></code> objects a default aspect ratio of <code>2</code> is used (tall
pixels).
</p>
<p>When <code>x</code> is an <code><a href="#topic+AmigaBitmapFont">AmigaBitmapFont()</a></code> or <code><a href="#topic+AmigaBitmapFontSet">AmigaBitmapFontSet()</a></code> object,
an aspect ratio of 1 is used by default. When the <code>TALLDOT</code> flag
is set for that font, the aspect ratio s multiplied by 2. When the
<code>WIDEDOT</code> flag is set, it will be divided by 2.
</p>
<p>A custom aspect ratio can also be used and will override the ratios specified above.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A plotting routine is implemented for most AmigaFFH objects. See the usage section
for all supported objects.
</p>


<h3>Value</h3>

<p>Returns <code>NULL</code> silently.
</p>


<h3>Author(s)</h3>

<p>Pepijn de Vries
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## load an IFF file
example.iff &lt;- read.iff(system.file("ilbm8lores.iff", package = "AmigaFFH"))

## and plot it:
plot(example.iff)

## AmigaIcons can also be plotted:
plot(simpleAmigaIcon())

## As can the cursor from a SysConfig object:
plot(simpleSysConfig())

## As can Amiga fonts:
data(font_example)
plot(font_example)
plot(font_example, text = "foo bar", style = "underlined", interpolate = F)

## As can AmigaBasicShapes:
ball &lt;- read.AmigaBasicShape(system.file("ball.shp", package = "AmigaFFH"))
plot(ball)

## End(Not run)
</code></pre>

<hr>
<h2 id='rasterToAmigaBasicShape'>Convert a grDevices raster object into an AmigaBasicShape class object.</h2><span id='topic+rasterToAmigaBasicShape'></span>

<h3>Description</h3>

<p>Convert a <code><a href="grDevices.html#topic+as.raster">raster()</a></code> object into an <code><a href="#topic+AmigaBasicShape">AmigaBasicShape()</a></code> class object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rasterToAmigaBasicShape(
  x,
  type = c("blitter object", "sprite"),
  palette,
  shadow,
  collision,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rasterToAmigaBasicShape_+3A_x">x</code></td>
<td>
<p>A <code><a href="grDevices.html#topic+as.raster">raster()</a></code> class object to convert into a <code><a href="#topic+AmigaBasicShape">AmigaBasicShape()</a></code> class obejct.</p>
</td></tr>
<tr><td><code id="rasterToAmigaBasicShape_+3A_type">type</code></td>
<td>
<p>A <code>character</code> string indicating what type of graphic needs to be created: &quot;<code style="white-space: pre;">&#8288;blitter object&#8288;</code>&quot; (default) or &quot;<code>sprite</code>&quot;.</p>
</td></tr>
<tr><td><code id="rasterToAmigaBasicShape_+3A_palette">palette</code></td>
<td>
<p>A <code>vector</code> of <code>character</code> strings, where each element represents a colour. This palette is used to quantize the
colours that occur in the <code>raster</code> <code>x</code>.</p>
</td></tr>
<tr><td><code id="rasterToAmigaBasicShape_+3A_shadow">shadow</code></td>
<td>
<p>An optional layer that could be stored with the graphics. This layer could be used for specific
shadow effects when blitting the graphics to the screen. It needs to be a <code><a href="grDevices.html#topic+as.raster">raster()</a></code>
object consisting of the colours black (bit unset) and white (bit set). The raster needs to have the same dimensions
as <code>x</code>. This layer will be omitted when this argument is omitted (or set to <code>NULL</code>).</p>
</td></tr>
<tr><td><code id="rasterToAmigaBasicShape_+3A_collision">collision</code></td>
<td>
<p>An optional layer that could be stored with the graphics. This layer could be used for collision
detection between graphical objects. It needs to be a <code><a href="grDevices.html#topic+as.raster">raster()</a></code>
object consisting of the colours black (bit unset) and white (bit set). The raster needs to have the same dimensions
as <code>x</code>. This layer will be omitted when this argument is omitted (or set to <code>NULL</code>).</p>
</td></tr>
<tr><td><code id="rasterToAmigaBasicShape_+3A_...">...</code></td>
<td>
<p>Arguments passed onto <code><a href="#topic+index.colours">index.colours()</a></code>. Can be used, for instance, to achieve specific dithering effects.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This method can be used to turn any graphics into an <code><a href="#topic+AmigaBasicShape">AmigaBasicShape()</a></code> class object. In order to do
so, the colours of the input image (a <code><a href="grDevices.html#topic+as.raster">raster()</a></code> object) will be quantized to a
limited palette. This palette can be forced as an argument to this function. Otherwise, it will be based on
the input image.
</p>


<h3>Value</h3>

<p>Returns an <code><a href="#topic+AmigaBasicShape">AmigaBasicShape()</a></code> class object based on <code>x</code>.
</p>


<h3>Author(s)</h3>

<p>Pepijn de Vries
</p>


<h3>See Also</h3>

<p>Other AmigaBasicShape.operations: 
<code><a href="#topic+AmigaBasicShape">AmigaBasicShape</a></code>,
<code><a href="#topic+read.AmigaBasicShape">read.AmigaBasicShape</a>()</code>,
<code><a href="#topic+write.AmigaBasicShape">write.AmigaBasicShape</a>()</code>
</p>
<p>Other raster.operations: 
<code><a href="#topic+AmigaBitmapFont">AmigaBitmapFont</a></code>,
<code><a href="#topic+as.raster.AmigaBasicShape">as.raster.AmigaBasicShape</a>()</code>,
<code><a href="#topic+bitmapToRaster">bitmapToRaster</a>()</code>,
<code><a href="#topic+dither">dither</a>()</code>,
<code><a href="#topic+index.colours">index.colours</a>()</code>,
<code><a href="#topic+rasterToAmigaBitmapFont">rasterToAmigaBitmapFont</a>()</code>,
<code><a href="#topic+rasterToBitmap">rasterToBitmap</a>()</code>,
<code><a href="#topic+rasterToHWSprite">rasterToHWSprite</a>()</code>,
<code><a href="#topic+rasterToIFF">rasterToIFF</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## get a raster image:
ilbm &lt;- as.raster(read.iff(system.file("ilbm8lores.iff", package = "AmigaFFH")))

## convert to an Amiga Basic blitter object:
bob &lt;- rasterToAmigaBasicShape(ilbm, "blitter object")

## End(Not run)
</code></pre>

<hr>
<h2 id='rasterToAmigaBitmapFont'>Convert a raster image into an AmigaBitmapFont</h2><span id='topic+rasterToAmigaBitmapFont'></span>

<h3>Description</h3>

<p>Convert a two-coloured <code><a href="grDevices.html#topic+as.raster">grDevices::as.raster()</a></code> image into
an <code><a href="#topic+AmigaBitmapFont">AmigaBitmapFont()</a></code> class object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rasterToAmigaBitmapFont(
  x,
  glyphs,
  default_glyph,
  baseline,
  glyph_width,
  glyph_space,
  glyph_kern,
  palette,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rasterToAmigaBitmapFont_+3A_x">x</code></td>
<td>
<p>A <code>raster</code> (see grDevices package) object composed of
two colours only. Make sure that all glyphs (graphical representation
of characters) are next to eachother on a single line. The height
of this raster (in pixels) is taken automatically as font height.</p>
</td></tr>
<tr><td><code id="rasterToAmigaBitmapFont_+3A_glyphs">glyphs</code></td>
<td>
<p>Specify which glyphs are included in the image
<code>x</code> from left to right. It can be specified in one of the
following ways:
</p>
<p>A single <code>character</code> string, where the length of the string
(<code>nchar</code>) equals the number of displayed glyphs in <code>x</code>.
</p>
<p>A <code>vector</code> of <code>numeric</code> ASCII codes. The length of
the <code>vector</code> should equal the number of displayed glyphs
in <code>x</code>.
</p>
<p>A <code>list</code> of either <code>character</code> strings or <code>vector</code> of
<code>numeric</code>s.  The length of the <code>list</code> should equal the
number of displayed glyphs in <code>x</code>. Each element can represent
multiple characters, meaning that the nth element of the list
uses the nth glyph shown in <code>x</code> to represent all the characters
included in that element.
</p>
<p>Note that Amiga bitmap fonts represent ASCII characters and may
not include all special characters or symbols.</p>
</td></tr>
<tr><td><code id="rasterToAmigaBitmapFont_+3A_default_glyph">default_glyph</code></td>
<td>
<p>A single <code>character</code> or ASCII code
(<code>numeric</code>) that should be used by default. This means
that all characters that are not specified by <code>glyphs</code> will
be represented by this <code>default_glyph</code>. <code>default_glyph</code> should
be included in <code>glyphs</code>.</p>
</td></tr>
<tr><td><code id="rasterToAmigaBitmapFont_+3A_baseline">baseline</code></td>
<td>
<p>The baseline of the font, specified in number of
pixels from the top (<code>numeric</code>). Should be a whole number
between 0 and the font height (height of <code>x</code>) minus 1.</p>
</td></tr>
<tr><td><code id="rasterToAmigaBitmapFont_+3A_glyph_width">glyph_width</code></td>
<td>
<p>A <code>numeric</code> <code>vector</code> with the same number
of elements or characters as used for <code>glyphs</code>. It specifies
the width in pixels for each glyph reserved in the raster image <code>x</code>.
They should be whole numbers greater or equal to 0.</p>
</td></tr>
<tr><td><code id="rasterToAmigaBitmapFont_+3A_glyph_space">glyph_space</code></td>
<td>
<p>A <code>numeric</code> <code>vector</code> with the same number
of elements or characters as used for <code>glyphs</code>. It specifies
the width in pixels for each glyph that should be used when formatting.
text. Note that these values can be smaller or larger than the values
specified for <code>glyph_width</code>.
They should be whole numbers greater or equal to 0.</p>
</td></tr>
<tr><td><code id="rasterToAmigaBitmapFont_+3A_glyph_kern">glyph_kern</code></td>
<td>
<p>Note that in Amiga bitmap fonts not the formal
definition from typography is used for kerning. Here, kerning is
used as the number of pixels the cursor should be moved forward or
backward after typesetting a character. It should be a
<code>numeric</code> <code>vector</code> with the same number of elements or
characters as used for <code>glyphs</code>. It can hold both positive
and negative values.</p>
</td></tr>
<tr><td><code id="rasterToAmigaBitmapFont_+3A_palette">palette</code></td>
<td>
<p>A <code>vector</code> of two colours. Both colours should
be in <code>x</code>. The first colour is used as background colour,
the second as foreground colour.
</p>
<p>When missing, it will be checked whether <code>x</code> has a palette
as attribute, and uses that. If that attribute is also missing,
the palette will be guessed from <code>x</code>, where the most
frequently occurring colour is assumed to be the background
colour.</p>
</td></tr>
<tr><td><code id="rasterToAmigaBitmapFont_+3A_...">...</code></td>
<td>
<p>Currently ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Create an <code><a href="#topic+AmigaBitmapFont">AmigaBitmapFont()</a></code> class object by providing
a two-coloured raster image and specifying which characters are
depicted by the image.
</p>


<h3>Value</h3>

<p>Returns a <code><a href="#topic+AmigaBitmapFont">AmigaBitmapFont()</a></code> class object based on <code>x</code>.
</p>


<h3>Author(s)</h3>

<p>Pepijn de Vries
</p>


<h3>See Also</h3>

<p>Other AmigaBitmapFont.operations: 
<code><a href="#topic+AmigaBitmapFont">AmigaBitmapFont</a></code>,
<code><a href="#topic+availableFontSizes">availableFontSizes</a>()</code>,
<code><a href="#topic+c">c</a>()</code>,
<code><a href="#topic+fontName">fontName</a>()</code>,
<code><a href="#topic+font_example">font_example</a></code>,
<code><a href="#topic+getAmigaBitmapFont">getAmigaBitmapFont</a>()</code>,
<code><a href="#topic+rawToAmigaBitmapFontSet">rawToAmigaBitmapFontSet</a>()</code>,
<code><a href="#topic+rawToAmigaBitmapFont">rawToAmigaBitmapFont</a>()</code>,
<code><a href="#topic+read.AmigaBitmapFontSet">read.AmigaBitmapFontSet</a>()</code>,
<code><a href="#topic+read.AmigaBitmapFont">read.AmigaBitmapFont</a>()</code>,
<code><a href="#topic+write.AmigaBitmapFont">write.AmigaBitmapFont</a>()</code>
</p>
<p>Other raster.operations: 
<code><a href="#topic+AmigaBitmapFont">AmigaBitmapFont</a></code>,
<code><a href="#topic+as.raster.AmigaBasicShape">as.raster.AmigaBasicShape</a>()</code>,
<code><a href="#topic+bitmapToRaster">bitmapToRaster</a>()</code>,
<code><a href="#topic+dither">dither</a>()</code>,
<code><a href="#topic+index.colours">index.colours</a>()</code>,
<code><a href="#topic+rasterToAmigaBasicShape">rasterToAmigaBasicShape</a>()</code>,
<code><a href="#topic+rasterToBitmap">rasterToBitmap</a>()</code>,
<code><a href="#topic+rasterToHWSprite">rasterToHWSprite</a>()</code>,
<code><a href="#topic+rasterToIFF">rasterToIFF</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data("font_example")

## make a raster that we can use to create a bitmap font
font9.rast &lt;- as.raster(getAmigaBitmapFont(font_example, 9))

## note the glyphs and the order in which they are included in
## the raster image:
plot(font9.rast)

## let's build a simple font, using only the first few glyphs
## in the raster:
font9 &lt;- rasterToAmigaBitmapFont(
  ## 'x' needs the raster image:
  x             = font9.rast,
  
  ## 'glyphs' are the graphical representation of the characters
  ## that we will include in our font. We will only use the
  ## first 7 characters in the raster image:
  glyphs        = " !\"#$%&amp;",
  
  ## We will use the '&amp;' glyph to represent all characters that
  ## are not specified in the font:
  default_glyph = "&amp;",
  
  ## The raster image is 9 pixels tall, as will be the font.
  ## Let's use 7 as the base (it needs to be less than the height)
  baseline      = 7,
  
  ## Let's define the width in pixels for each of the 7
  ## characters. This is their width in the raster image:
  glyph_width   = c(0, 1, 3, 6, 5, 5, 5),
  
  ## Let's define the space the character should take in pixels
  ## when it is used to format text:
  glyph_space   = c(4, 2, 4, 7, 6, 6, 6),
  
  ## the raster uses white as background colour and black as
  ## foreground:
  palette       = c("white", "black")
)

## note that for all characters that are not specified,
## the default glyph ('&amp;') is used:
plot(font9, text = "!@#$%ABCD")

## Let's take a subset from the font's bitmap (rasteer):
font9abc.rast &lt;- font9.rast[,263:282]

## as you can see this bitmap only contains the lowercase
## characters 'a', 'b', 'c', 'd' and 'e':
plot(font9abc.rast)

font9.abc &lt;- rasterToAmigaBitmapFont(
  x             = font9abc.rast,
  ## Each glyph in the image can be represented by a single
  ## element in a list. By specifying multiple characters in
  ## each element, you can recycle a glyph to represent different
  ## characters. So in this case, the glyph 'a' is used for
  ## all the accented variants of the character 'a'.
  glyphs        = list("a\xE0\xE1\xE2\xE3\xE4\xE5",
                       "b",
                       "c\xA2\xE7",
                       "d",
                       "e\xE8\xE9\xEA\xEB"),
  default_glyph = "c", ## 'c' is used as default glyph for all other characters
  baseline      = 7,
  glyph_width   = c(4, 4, 4, 4, 4),
  glyph_space   = c(5, 5, 5, 5, 5),
  palette       = c("white", "black")
)

## see what happens when you format text using the font we just created:
plot(font9.abc, text = "a\xE0\xE1\xE2\xE3\xE4\xE5bc\xA2\xE7de\xE8\xE9\xEA\xEB, foo bar")

## End(Not run)
</code></pre>

<hr>
<h2 id='rasterToBitmap'>Convert a grDevices <code>raster</code> object into binary bitmap data</h2><span id='topic+rasterToBitmap'></span>

<h3>Description</h3>

<p>Converts an image represented by a grDevices <code>raster</code> object into binary
(Amiga) bitmap data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rasterToBitmap(x, depth = 3, interleaved = T, indexing = index.colours)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rasterToBitmap_+3A_x">x</code></td>
<td>
<p>A raster object created with <code><a href="grDevices.html#topic+as.raster">grDevices::as.raster()</a></code> which
needs to be converted into bitmap data. It is also possible to let <code>x</code> be
a matrix of <code>character</code>s, representing colours.</p>
</td></tr>
<tr><td><code id="rasterToBitmap_+3A_depth">depth</code></td>
<td>
<p>The colour depth of the bitmap image. The image will be composed
of <code>2^depth</code> indexed colours.
</p>
<p><code>depth</code> can also be a <code>character</code> string &quot;HAM6&quot; or &quot;HAM8&quot;
representing special Amiga display modes (see details).</p>
</td></tr>
<tr><td><code id="rasterToBitmap_+3A_interleaved">interleaved</code></td>
<td>
<p>A <code>logical</code> value, indicating whether the bitmap needs to be
interleaved. An interleaved bitmap image stores each consecutive bitmap layer per
horizontal scanline.</p>
</td></tr>
<tr><td><code id="rasterToBitmap_+3A_indexing">indexing</code></td>
<td>
<p>A function that accepts two arguments: <code>x</code> (a grDevices
<code>raster</code> object); <code>length.out</code>, a numeric value indicating the
desired size of the palette (i.e., the number of colours). It should return
a matrix with numeric palette indices (ranging from 1 up to the number of
colours in the palette). The result should have an attribute named <code style="white-space: pre;">&#8288;palette' that contains the colours that correspond with the index numbers. The result should also carry an attribute with the name &#8288;</code>transparent', with a single numeric value
representing which colour in the palette should be treated as transparent (or
<code>NA</code> when no transparency is required). By default the
function <code><a href="#topic+index.colours">index.colours()</a></code> is used. You are free to provide
a customised version of this function (see examples).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Images represented by grDevices <code>raster</code> objects are virtually true colour (24 bit
colour depth) and an alpha layer (transparency). On the early Amiga's the chipset
(in combination with memory restrictions) only allowed images with indexed
palettes. The colour depth was 12 bit with the original chipset and the number
of colours allowed in a palette also depended on the chipset. This function
will allow you to convert a <code>raster</code> object into binary bitmap data with
an indexed palette. This means that the image is converted in a lossy way
(information will be lost). So don't expect the result to have the same quality as
the original image.
</p>
<p>With the <code>depth</code> argument, the raster can also be converted
to special mode bitmap images. One of these modes is the
&lsquo;hold and modify&rsquo; (HAM). In this mode two of the bitplanes
are reserved as modifier switches. If the this switch equals
zero, the remainder of the bitplanes are used as an index for
colours in a fixed palette. If the switch equals 1, 2 or 3, the
red, green or blue component of the previous is modified, using the
number in the remainder of the bitplanes. So it holds the previous
colour but modifies one of the colour components (hence the term
&lsquo;hold and modify&rsquo;.) Here only the HAM6 and
the HAM8 mode are implemented. HAM6 uses 6 bitplanes and a 12 bit
colour depth, HAM8 uses 8 bitplanes and a 24 bit colour depth.
</p>
<p>The HAM mode was a special video modes supported by Amiga hardware.
Normal mode bitmap images with a 6 bit depth would allow for a
palette of 64 (2^6) colours, HAM6 can display 4096 colours with
the same bit depth.
</p>
<p>In addition to HAM6 and HAM8, sliced HAM (or SHAM) was another
HAM variant. Using the coprocessor on the Amiga, it was possible
to change the palette at specific scanlines, increasing the number
of available colours even further. The SHAM mode is currently not
supported by this package.
</p>


<h3>Value</h3>

<p>The bitmap is returned as a <code>vector</code> of <code>logical</code> values.
The <code>logical</code> values reflect the bits for each bitplane. The palette used
for the bitmap is returned as attribute to the <code>vector</code>. There will also be
an attribute called <code style="white-space: pre;">&#8288;transparent'. This will hold a numeric index corresponding with the colour in the palette that will be treated as transparent. It will be &#8288;</code>NA' when transparency is not used.
</p>


<h3>Author(s)</h3>

<p>Pepijn de Vries
</p>


<h3>See Also</h3>

<p>Other raster.operations: 
<code><a href="#topic+AmigaBitmapFont">AmigaBitmapFont</a></code>,
<code><a href="#topic+as.raster.AmigaBasicShape">as.raster.AmigaBasicShape</a>()</code>,
<code><a href="#topic+bitmapToRaster">bitmapToRaster</a>()</code>,
<code><a href="#topic+dither">dither</a>()</code>,
<code><a href="#topic+index.colours">index.colours</a>()</code>,
<code><a href="#topic+rasterToAmigaBasicShape">rasterToAmigaBasicShape</a>()</code>,
<code><a href="#topic+rasterToAmigaBitmapFont">rasterToAmigaBitmapFont</a>()</code>,
<code><a href="#topic+rasterToHWSprite">rasterToHWSprite</a>()</code>,
<code><a href="#topic+rasterToIFF">rasterToIFF</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## first: Let's make a raster out of the 'volcano' data, which we can use in the example:
volcano.raster &lt;- as.raster(t(matrix(terrain.colors(1 + diff(range(volcano)))[volcano -
  min(volcano) + 1], nrow(volcano))))

## convert the raster into binary (logical) bitmap data:
volcano.bm &lt;- rasterToBitmap(volcano.raster)

## The palette for the indexed colours of the generated bitmap is returned as
## attribute. There is no transparency is the image:
attributes(volcano.bm)

## We can also include a custom function for colour quantisation. Let's include
## some dithering:
volcano.dither &lt;- rasterToBitmap(volcano.raster,
                                 indexing = function(x, length.out) {
                                   index.colours(x, length.out,
                                                 dither = "floyd-steinberg")
                                 })

## You can also use a custom indexing function to force a specified palette,
## in this case black and white:
volcano.bw &lt;- rasterToBitmap(volcano.raster,
                             indexing = function(x, length.out) {
                               index.colours(x, length.out,
                                             palette = c("black", "white"),
                                             dither = "floyd-steinberg")
                             })

## Make a bitmap using a special display mode (HAM6):
volcano.HAM &lt;- rasterToBitmap(volcano.raster, "HAM6")

## End(Not run)
</code></pre>

<hr>
<h2 id='rasterToHWSprite'>Convert a raster object into an hardwareSprite object</h2><span id='topic+rasterToHWSprite'></span>

<h3>Description</h3>

<p>Convert a grDevices raster object into an Amiga hardwareSprite class object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rasterToHWSprite(x, indexing = index.colours)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rasterToHWSprite_+3A_x">x</code></td>
<td>
<p>A <code><a href="grDevices.html#topic+grDevices">grDevices()</a></code> raster object (<code><a href="grDevices.html#topic+as.raster">grDevices::as.raster()</a></code>)
that needs to be converted into a <code><a href="#topic+hardwareSprite">hardwareSprite()</a></code> class object.
Note that a <code><a href="#topic+hardwareSprite">hardwareSprite()</a></code> has a maximum width of 16 pixels.
When <code>x</code> is wider, it will be cropped.</p>
</td></tr>
<tr><td><code id="rasterToHWSprite_+3A_indexing">indexing</code></td>
<td>
<p>A function that accepts two arguments: <code>x</code> (a grDevices
<code>raster</code> object); <code>length.out</code>, a numeric value indicating the
desired size of the palette (i.e., the number of colours). It should return
a matrix with numeric palette indices (ranging from 1 up to the number of
colours in the palette). The result should have an attribute named <code style="white-space: pre;">&#8288;palette' that contains the colours that correspond with the index numbers. The result should also carry an attribute with the name &#8288;</code>transparent', with a single numeric value
representing which colour in the palette should be treated as transparent (or
<code>NA</code> when no transparency is required). By default the
function <code><a href="#topic+index.colours">index.colours()</a></code> is used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A <code><a href="grDevices.html#topic+grDevices">grDevices()</a></code> raster image can be converted into a
<code><a href="#topic+hardwareSprite">hardwareSprite()</a></code> class object with this function. For this purpose
the any true-colour image will be converted to an indexed palette with 4 colours.
The Amiga hardware sprite will reserve one of the colours as transparent. Thos function
will use fully transparent colours in the original image (i.e., the alpha level equals 0)
for this purpose. Or when the image has no fully transparent colours, it will use the
most frequently occuring colour (at least when the default <code>indexing</code> function
is used).
</p>


<h3>Value</h3>

<p>Returns a <code><a href="#topic+hardwareSprite">hardwareSprite()</a></code> class object based on <code>x</code>
</p>


<h3>Author(s)</h3>

<p>Pepijn de Vries
</p>


<h3>See Also</h3>

<p>Other raster.operations: 
<code><a href="#topic+AmigaBitmapFont">AmigaBitmapFont</a></code>,
<code><a href="#topic+as.raster.AmigaBasicShape">as.raster.AmigaBasicShape</a>()</code>,
<code><a href="#topic+bitmapToRaster">bitmapToRaster</a>()</code>,
<code><a href="#topic+dither">dither</a>()</code>,
<code><a href="#topic+index.colours">index.colours</a>()</code>,
<code><a href="#topic+rasterToAmigaBasicShape">rasterToAmigaBasicShape</a>()</code>,
<code><a href="#topic+rasterToAmigaBitmapFont">rasterToAmigaBitmapFont</a>()</code>,
<code><a href="#topic+rasterToBitmap">rasterToBitmap</a>()</code>,
<code><a href="#topic+rasterToIFF">rasterToIFF</a>()</code>
</p>
<p>Other HWSprite.operations: 
<code><a href="#topic+rawToHWSprite">rawToHWSprite</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## first create a raster object that can be used as input
## (making sure that the background is transparent):
rst &lt;- as.raster(simpleSysConfig()$PointerMatrix, "#AAAAAA00")

## now turn it into a hardware sprite:
spr &lt;- rasterToHWSprite(rst)

## and plot it as a check:
plot(spr)

## End(Not run)
</code></pre>

<hr>
<h2 id='rasterToIFF'>Convert a grDevices raster image into an IFF formated bitmap image</h2><span id='topic+rasterToIFF'></span>

<h3>Description</h3>

<p>Convert grDevices raster images (<code><a href="grDevices.html#topic+as.raster">grDevices::as.raster()</a></code>)
into a formal <code><a href="#topic+IFFChunk">IFFChunk()</a></code> object, as an interleaved bitmap (ILBM)
image.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rasterToIFF(
  x,
  display.mode = as.character(AmigaFFH::amiga_display_modes$DISPLAY_MODE),
  monitor = as.character(AmigaFFH::amiga_monitors$MONITOR_ID),
  anim.options,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rasterToIFF_+3A_x">x</code></td>
<td>
<p>A raster object created with <code><a href="grDevices.html#topic+as.raster">grDevices::as.raster()</a></code> which
needs to be converted into an IFF formated bitmap image. It is also possible to let <code>x</code> be
a matrix of <code>character</code>s, representing colours.</p>
</td></tr>
<tr><td><code id="rasterToIFF_+3A_display.mode">display.mode</code></td>
<td>
<p>Specify the Amiga display mode that should be used.
See <code><a href="#topic+amiga_display_modes">amiga_display_modes()</a></code> for all possible options.
&quot;<code>LORES_KEY</code>&quot; is used by default, this is the lowest resolution
possible on the Amiga.</p>
</td></tr>
<tr><td><code id="rasterToIFF_+3A_monitor">monitor</code></td>
<td>
<p>The Amiga monitor on which the needs to be displayed.
See <code><a href="#topic+amiga_monitors">amiga_monitors()</a></code> for more details and posible options.
By default &quot;<code>DEFAULT_MONITOR_ID</code>&quot; is used.</p>
</td></tr>
<tr><td><code id="rasterToIFF_+3A_anim.options">anim.options</code></td>
<td>
<p>Currently ignored. This argument will potentitally be implemented
in future versions of this package. Currently, animations are always encoded
with the &quot;ByteVerticalCompression&quot; in this package (when <code>x</code> is a list of
<code>raster</code> objects).</p>
</td></tr>
<tr><td><code id="rasterToIFF_+3A_...">...</code></td>
<td>
<p>Arguments passed on to <code><a href="#topic+rasterToBitmap">rasterToBitmap()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Convert any modern image into a interleaved bitmap (image) conform
Interchange File Format (IFF) specifications. If your original image
is in true colour (i.e., a 24 bit colour depth) it will be converted
into a bitmap image with an indexed palette.
</p>


<h3>Value</h3>

<p>Returns an <code><a href="#topic+IFFChunk">IFFChunk()</a></code> object holding an Interleaved
Bitmap (ILBM) image based on <code>x</code>.
</p>


<h3>Author(s)</h3>

<p>Pepijn de Vries
</p>


<h3>See Also</h3>

<p>Other iff.operations: 
<code><a href="#topic+IFFChunk-class">IFFChunk-class</a></code>,
<code><a href="#topic+WaveToIFF">WaveToIFF</a>()</code>,
<code><a href="#topic+as.raster.AmigaBasicShape">as.raster.AmigaBasicShape</a>()</code>,
<code><a href="#topic+getIFFChunk">getIFFChunk</a>()</code>,
<code><a href="#topic+interpretIFFChunk">interpretIFFChunk</a>()</code>,
<code><a href="#topic+rawToIFFChunk">rawToIFFChunk</a>()</code>,
<code><a href="#topic+read.iff">read.iff</a>()</code>,
<code><a href="#topic+write.iff">write.iff</a>()</code>
</p>
<p>Other raster.operations: 
<code><a href="#topic+AmigaBitmapFont">AmigaBitmapFont</a></code>,
<code><a href="#topic+as.raster.AmigaBasicShape">as.raster.AmigaBasicShape</a>()</code>,
<code><a href="#topic+bitmapToRaster">bitmapToRaster</a>()</code>,
<code><a href="#topic+dither">dither</a>()</code>,
<code><a href="#topic+index.colours">index.colours</a>()</code>,
<code><a href="#topic+rasterToAmigaBasicShape">rasterToAmigaBasicShape</a>()</code>,
<code><a href="#topic+rasterToAmigaBitmapFont">rasterToAmigaBitmapFont</a>()</code>,
<code><a href="#topic+rasterToBitmap">rasterToBitmap</a>()</code>,
<code><a href="#topic+rasterToHWSprite">rasterToHWSprite</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## first: Let's make a raster out of the 'volcano' data, which we can use in the example:
volcano.raster &lt;- as.raster(t(matrix(terrain.colors(1 + diff(range(volcano)))[volcano -
  min(volcano) + 1], nrow(volcano))))

## Turning the raster into an IFFChunk object is easy:
volcano.iff &lt;- rasterToIFF(volcano.raster)

## This object can be saved as an IFF file using write.iff

## in special modes HAM6 and HAM 8 higher quality images
## can be obtained. See 'rasterToBitmap' for more info on the
## special HAM modes.
volcano.ham &lt;- rasterToIFF(volcano.raster, "HAM_KEY", depth = "HAM8")

## The result can be further improved by applying dithering
volcano.ham.dither &lt;- rasterToIFF(volcano.raster, "HAM_KEY", depth = "HAM8",
  indexing = function(x, length.out) {
    index.colours(x, length.out, dither = "JJN", iter.max = 20)
  })

## End(Not run)
</code></pre>

<hr>
<h2 id='rawToAmigaBasic'>Coerce raw data into an AmigaBasic class object</h2><span id='topic+rawToAmigaBasic'></span>

<h3>Description</h3>

<p><code><a href="#topic+AmigaBasic">AmigaBasic()</a></code> objects are comprehensive representations of binary-encode Amiga Basic scripts.
Use this function to convert raw content from encoded Amiga Basic scripts to an <code><a href="#topic+AmigaBasic">AmigaBasic()</a></code>
object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rawToAmigaBasic(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rawToAmigaBasic_+3A_x">x</code></td>
<td>
<p>A <code>vector</code> of <code>raw</code> data that is to be converted
into an <code><a href="#topic+AmigaBasic">AmigaBasic()</a></code> class object.</p>
</td></tr>
<tr><td><code id="rawToAmigaBasic_+3A_...">...</code></td>
<td>
<p>Currently ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function will convert raw data as stored in Amiga Basic files into its corresponding S3
<code><a href="#topic+AmigaBasic">AmigaBasic()</a></code>-class object.
</p>


<h3>Value</h3>

<p>An <code><a href="#topic+AmigaBasic">AmigaBasic()</a></code> class object based on <code>x</code>.
</p>


<h3>Author(s)</h3>

<p>Pepijn de Vries
</p>


<h3>See Also</h3>

<p>Other AmigaBasic.operations: 
<code><a href="#topic+AmigaBasic.reserved">AmigaBasic.reserved</a>()</code>,
<code><a href="#topic+AmigaBasicBMAP">AmigaBasicBMAP</a></code>,
<code><a href="#topic+AmigaBasic">AmigaBasic</a></code>,
<code><a href="#topic++5B.AmigaBasic">[.AmigaBasic</a>()</code>,
<code><a href="#topic+as.AmigaBasicBMAP">as.AmigaBasicBMAP</a>()</code>,
<code><a href="#topic+as.AmigaBasic">as.AmigaBasic</a>()</code>,
<code><a href="#topic+as.character">as.character</a>()</code>,
<code><a href="#topic+check.names.AmigaBasic">check.names.AmigaBasic</a>()</code>,
<code><a href="#topic+names.AmigaBasic">names.AmigaBasic</a>()</code>,
<code><a href="#topic+rawToAmigaBasicBMAP">rawToAmigaBasicBMAP</a>()</code>,
<code><a href="#topic+read.AmigaBasicBMAP">read.AmigaBasicBMAP</a>()</code>,
<code><a href="#topic+read.AmigaBasic">read.AmigaBasic</a>()</code>,
<code><a href="#topic+write.AmigaBasic">write.AmigaBasic</a>()</code>
</p>
<p>Other raw.operations: 
<code><a href="#topic+as.AmigaBasic">as.AmigaBasic</a>()</code>,
<code><a href="#topic+as.raw.AmigaBasic">as.raw.AmigaBasic</a>()</code>,
<code><a href="#topic+colourToAmigaRaw">colourToAmigaRaw</a>()</code>,
<code><a href="#topic+packBitmap">packBitmap</a>()</code>,
<code><a href="#topic+rawToAmigaBasicBMAP">rawToAmigaBasicBMAP</a>()</code>,
<code><a href="#topic+rawToAmigaBasicShape">rawToAmigaBasicShape</a>()</code>,
<code><a href="#topic+rawToAmigaBitmapFontSet">rawToAmigaBitmapFontSet</a>()</code>,
<code><a href="#topic+rawToAmigaBitmapFont">rawToAmigaBitmapFont</a>()</code>,
<code><a href="#topic+rawToAmigaIcon">rawToAmigaIcon</a>()</code>,
<code><a href="#topic+rawToHWSprite">rawToHWSprite</a>()</code>,
<code><a href="#topic+rawToIFFChunk">rawToIFFChunk</a>()</code>,
<code><a href="#topic+rawToSysConfig">rawToSysConfig</a>()</code>,
<code><a href="#topic+simpleAmigaIcon">simpleAmigaIcon</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## First create an AmigaBAsic object:
bas &lt;- as.AmigaBasic("PRINT \"Hello world!\"")

## Make it raw:
bas.raw &lt;- as.raw(bas)

## Now convert it back to an AmigaBasic object:
bas &lt;- rawToAmigaBasic(bas.raw)

## End(Not run)
</code></pre>

<hr>
<h2 id='rawToAmigaBasicBMAP'>Coerce raw data into an AmigaBasicBMAP class object</h2><span id='topic+rawToAmigaBasicBMAP'></span>

<h3>Description</h3>

<p>Coerce raw data into an <code><a href="#topic+AmigaBasicBMAP">AmigaBasicBMAP()</a></code> class object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rawToAmigaBasicBMAP(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rawToAmigaBasicBMAP_+3A_x">x</code></td>
<td>
<p>A <code>vector</code> of <code>raw</code> data that is to be converted
into an <code><a href="#topic+AmigaBasicBMAP">AmigaBasicBMAP()</a></code> class object.</p>
</td></tr>
<tr><td><code id="rawToAmigaBasicBMAP_+3A_...">...</code></td>
<td>
<p>Currently ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An <a href="#topic+AmigaBasicBMAP">Amiga Basic BMAP</a> file maps the offset of routines in Amiga libraries. This
function converts the raw format in which it would be stored as a file into a comprehensive S3 class object.
</p>


<h3>Value</h3>

<p>An <code><a href="#topic+AmigaBasicBMAP">AmigaBasicBMAP()</a></code> class object based on <code>x</code>.
</p>


<h3>Author(s)</h3>

<p>Pepijn de Vries
</p>


<h3>See Also</h3>

<p>Other AmigaBasic.operations: 
<code><a href="#topic+AmigaBasic.reserved">AmigaBasic.reserved</a>()</code>,
<code><a href="#topic+AmigaBasicBMAP">AmigaBasicBMAP</a></code>,
<code><a href="#topic+AmigaBasic">AmigaBasic</a></code>,
<code><a href="#topic++5B.AmigaBasic">[.AmigaBasic</a>()</code>,
<code><a href="#topic+as.AmigaBasicBMAP">as.AmigaBasicBMAP</a>()</code>,
<code><a href="#topic+as.AmigaBasic">as.AmigaBasic</a>()</code>,
<code><a href="#topic+as.character">as.character</a>()</code>,
<code><a href="#topic+check.names.AmigaBasic">check.names.AmigaBasic</a>()</code>,
<code><a href="#topic+names.AmigaBasic">names.AmigaBasic</a>()</code>,
<code><a href="#topic+rawToAmigaBasic">rawToAmigaBasic</a>()</code>,
<code><a href="#topic+read.AmigaBasicBMAP">read.AmigaBasicBMAP</a>()</code>,
<code><a href="#topic+read.AmigaBasic">read.AmigaBasic</a>()</code>,
<code><a href="#topic+write.AmigaBasic">write.AmigaBasic</a>()</code>
</p>
<p>Other raw.operations: 
<code><a href="#topic+as.AmigaBasic">as.AmigaBasic</a>()</code>,
<code><a href="#topic+as.raw.AmigaBasic">as.raw.AmigaBasic</a>()</code>,
<code><a href="#topic+colourToAmigaRaw">colourToAmigaRaw</a>()</code>,
<code><a href="#topic+packBitmap">packBitmap</a>()</code>,
<code><a href="#topic+rawToAmigaBasicShape">rawToAmigaBasicShape</a>()</code>,
<code><a href="#topic+rawToAmigaBasic">rawToAmigaBasic</a>()</code>,
<code><a href="#topic+rawToAmigaBitmapFontSet">rawToAmigaBitmapFontSet</a>()</code>,
<code><a href="#topic+rawToAmigaBitmapFont">rawToAmigaBitmapFont</a>()</code>,
<code><a href="#topic+rawToAmigaIcon">rawToAmigaIcon</a>()</code>,
<code><a href="#topic+rawToHWSprite">rawToHWSprite</a>()</code>,
<code><a href="#topic+rawToIFFChunk">rawToIFFChunk</a>()</code>,
<code><a href="#topic+rawToSysConfig">rawToSysConfig</a>()</code>,
<code><a href="#topic+simpleAmigaIcon">simpleAmigaIcon</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## A small fragment of the dos.library BMAP would look like this:
dos.bmap &lt;- as.AmigaBasicBMAP(list(
  xOpen = list(
    libraryVectorOffset = -30,
    registers = as.raw(2:3)
  ),
  xClose = list(
    libraryVectorOffset = -36,
    registers = as.raw(2)
  ),
  xRead = list(
    libraryVectorOffset = -42,
    registers = as.raw(2:4)
  )
))

## The raw representation would be
dos.bmap.raw &lt;- as.raw(dos.bmap)

## And the reverse
rawToAmigaBasicBMAP(dos.bmap.raw)

## End(Not run)
</code></pre>

<hr>
<h2 id='rawToAmigaBasicShape'>Coerce raw data into an AmigaBasicShape class object</h2><span id='topic+rawToAmigaBasicShape'></span>

<h3>Description</h3>

<p>Coerce raw data into an <code><a href="#topic+AmigaBasicShape">AmigaBasicShape()</a></code>-class object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rawToAmigaBasicShape(x, palette)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rawToAmigaBasicShape_+3A_x">x</code></td>
<td>
<p>A <code>vector</code> of <code>raw</code> data that is to be converted
into an <code><a href="#topic+AmigaBasicShape">AmigaBasicShape()</a></code> class object.</p>
</td></tr>
<tr><td><code id="rawToAmigaBasicShape_+3A_palette">palette</code></td>
<td>
<p>A <code>vector</code> of <code>character</code> strings, where each element represents a colour in the palette.
This palette will be used to display the graphics (note that the raw format does not store the palette, but this
S3 class does). When this argument is omitted a grey scale palette will be generated.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code><a href="#topic+AmigaBasicShape">AmigaBasicShape()</a></code> objects are comprehensive representations of blitter
and sprite graphics that can be used in <code><a href="#topic+AmigaBasic">AmigaBasic()</a></code> scripts. Use this function
to convert <code>raw</code> content to an <code><a href="#topic+AmigaBasicShape">AmigaBasicShape()</a></code> object.
</p>


<h3>Value</h3>

<p>returns an <code><a href="#topic+AmigaBasicShape">AmigaBasicShape()</a></code>-class object.
</p>


<h3>Author(s)</h3>

<p>Pepijn de Vries
</p>


<h3>See Also</h3>

<p>Other raw.operations: 
<code><a href="#topic+as.AmigaBasic">as.AmigaBasic</a>()</code>,
<code><a href="#topic+as.raw.AmigaBasic">as.raw.AmigaBasic</a>()</code>,
<code><a href="#topic+colourToAmigaRaw">colourToAmigaRaw</a>()</code>,
<code><a href="#topic+packBitmap">packBitmap</a>()</code>,
<code><a href="#topic+rawToAmigaBasicBMAP">rawToAmigaBasicBMAP</a>()</code>,
<code><a href="#topic+rawToAmigaBasic">rawToAmigaBasic</a>()</code>,
<code><a href="#topic+rawToAmigaBitmapFontSet">rawToAmigaBitmapFontSet</a>()</code>,
<code><a href="#topic+rawToAmigaBitmapFont">rawToAmigaBitmapFont</a>()</code>,
<code><a href="#topic+rawToAmigaIcon">rawToAmigaIcon</a>()</code>,
<code><a href="#topic+rawToHWSprite">rawToHWSprite</a>()</code>,
<code><a href="#topic+rawToIFFChunk">rawToIFFChunk</a>()</code>,
<code><a href="#topic+rawToSysConfig">rawToSysConfig</a>()</code>,
<code><a href="#topic+simpleAmigaIcon">simpleAmigaIcon</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
filename &lt;- system.file("ball.shp", package = "AmigaFFH")

## read as binary:
con      &lt;- file(filename, "rb")
ball.raw &lt;- readBin(con, "raw", file.size(filename))
close(con)

## convert raw data into something useful:
ball     &lt;- rawToAmigaBasicShape(ball.raw)

## A shortcut would be to call read.AmigaBasicShape
ball2    &lt;- read.AmigaBasicShape(filename)

## End(Not run)
</code></pre>

<hr>
<h2 id='rawToAmigaBitmapFont'>Coerce raw data into an AmigaBitmapFont class object</h2><span id='topic+rawToAmigaBitmapFont'></span>

<h3>Description</h3>

<p><code><a href="#topic+AmigaBitmapFont">AmigaBitmapFont()</a></code> objects are comprehensive representations of binary Amiga
font subset files. The file name is usually simply a numeric number
indicating the font height in pixels. Use this function to convert
<code>raw</code> content from such a file to an <code><a href="#topic+AmigaBitmapFont">AmigaBitmapFont()</a></code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rawToAmigaBitmapFont(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rawToAmigaBitmapFont_+3A_x">x</code></td>
<td>
<p>An <code><a href="#topic+AmigaBitmapFont">AmigaBitmapFont()</a></code> object which needs to be converted
into <code>raw</code> data.</p>
</td></tr>
<tr><td><code id="rawToAmigaBitmapFont_+3A_...">...</code></td>
<td>
<p>Currently ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function converts <code>raw</code> data as stored in font bitmap
files. These files are stored in subdirectories with the font's
name and usually have the font height in pixels as file name.
This function is effectively the inverse of <code><a href="#topic+as.raw">as.raw()</a></code>.
</p>


<h3>Value</h3>

<p>A <code>vector</code> of <code>raw</code> data representing <code>x</code>.
</p>


<h3>Author(s)</h3>

<p>Pepijn de Vries
</p>


<h3>See Also</h3>

<p>Other AmigaBitmapFont.operations: 
<code><a href="#topic+AmigaBitmapFont">AmigaBitmapFont</a></code>,
<code><a href="#topic+availableFontSizes">availableFontSizes</a>()</code>,
<code><a href="#topic+c">c</a>()</code>,
<code><a href="#topic+fontName">fontName</a>()</code>,
<code><a href="#topic+font_example">font_example</a></code>,
<code><a href="#topic+getAmigaBitmapFont">getAmigaBitmapFont</a>()</code>,
<code><a href="#topic+rasterToAmigaBitmapFont">rasterToAmigaBitmapFont</a>()</code>,
<code><a href="#topic+rawToAmigaBitmapFontSet">rawToAmigaBitmapFontSet</a>()</code>,
<code><a href="#topic+read.AmigaBitmapFontSet">read.AmigaBitmapFontSet</a>()</code>,
<code><a href="#topic+read.AmigaBitmapFont">read.AmigaBitmapFont</a>()</code>,
<code><a href="#topic+write.AmigaBitmapFont">write.AmigaBitmapFont</a>()</code>
</p>
<p>Other raw.operations: 
<code><a href="#topic+as.AmigaBasic">as.AmigaBasic</a>()</code>,
<code><a href="#topic+as.raw.AmigaBasic">as.raw.AmigaBasic</a>()</code>,
<code><a href="#topic+colourToAmigaRaw">colourToAmigaRaw</a>()</code>,
<code><a href="#topic+packBitmap">packBitmap</a>()</code>,
<code><a href="#topic+rawToAmigaBasicBMAP">rawToAmigaBasicBMAP</a>()</code>,
<code><a href="#topic+rawToAmigaBasicShape">rawToAmigaBasicShape</a>()</code>,
<code><a href="#topic+rawToAmigaBasic">rawToAmigaBasic</a>()</code>,
<code><a href="#topic+rawToAmigaBitmapFontSet">rawToAmigaBitmapFontSet</a>()</code>,
<code><a href="#topic+rawToAmigaIcon">rawToAmigaIcon</a>()</code>,
<code><a href="#topic+rawToHWSprite">rawToHWSprite</a>()</code>,
<code><a href="#topic+rawToIFFChunk">rawToIFFChunk</a>()</code>,
<code><a href="#topic+rawToSysConfig">rawToSysConfig</a>()</code>,
<code><a href="#topic+simpleAmigaIcon">simpleAmigaIcon</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## first create raw data that can be converted into a AmigaBitmapFont
data(font_example)
font.raw &lt;- as.raw(getAmigaBitmapFont(font_example, 9))

## Convert it back into an AmigaBitmapFont object:
font &lt;- rawToAmigaBitmapFont(font.raw)

## End(Not run)
</code></pre>

<hr>
<h2 id='rawToAmigaBitmapFontSet'>Coerce raw data into an AmigaBitmapFontSet class object</h2><span id='topic+rawToAmigaBitmapFontSet'></span>

<h3>Description</h3>

<p><code><a href="#topic+AmigaBitmapFontSet">AmigaBitmapFontSet()</a></code> objects are comprehensive representations of binary Amiga
font files (*.font). Use this function to convert <code>raw</code> data from
such a file to an <a href="#topic+AmigaBitmapFontSet">AmigaBitmapFontSet</a> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rawToAmigaBitmapFontSet(x, file, disk = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rawToAmigaBitmapFontSet_+3A_x">x</code></td>
<td>
<p>A <code>vector</code> of <code>raw</code> data that needs to be
converted into an <code><a href="#topic+AmigaBitmapFontSet">AmigaBitmapFontSet()</a></code>.</p>
</td></tr>
<tr><td><code id="rawToAmigaBitmapFontSet_+3A_file">file</code></td>
<td>
<p>The <code>raw</code> version of the <code><a href="#topic+AmigaBitmapFontSet">AmigaBitmapFontSet()</a></code>
does not contain the nested font bitmap images. In order to correctly
construct an <code><a href="#topic+AmigaBitmapFontSet">AmigaBitmapFontSet()</a></code> the file location of the
original *.font file is required in order to read and include the
font bitmap image information. <code>file</code> should thus be a <code>character</code>
string specifying the file location of the *.font file.</p>
</td></tr>
<tr><td><code id="rawToAmigaBitmapFontSet_+3A_disk">disk</code></td>
<td>
<p>A virtual Commodore Amiga disk from which the <code>file</code> should be
read. This should be an <code><a href="adfExplorer.html#topic+amigaDisk-class">amigaDisk()</a></code> object. Using
this argument requires the adfExplorer package.
When set to <code>NULL</code>, this argument is ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function converts <code>raw</code> data as stored in *.font
files. The function also needs the file location, in order
to load the nested bitmap images for each font height.
This function is effectively the inverse of <code><a href="#topic+as.raw">as.raw()</a></code>.
</p>


<h3>Value</h3>

<p>Returns an <code><a href="#topic+AmigaBitmapFontSet">AmigaBitmapFontSet()</a></code> object.
</p>


<h3>Author(s)</h3>

<p>Pepijn de Vries
</p>


<h3>See Also</h3>

<p>Other AmigaBitmapFont.operations: 
<code><a href="#topic+AmigaBitmapFont">AmigaBitmapFont</a></code>,
<code><a href="#topic+availableFontSizes">availableFontSizes</a>()</code>,
<code><a href="#topic+c">c</a>()</code>,
<code><a href="#topic+fontName">fontName</a>()</code>,
<code><a href="#topic+font_example">font_example</a></code>,
<code><a href="#topic+getAmigaBitmapFont">getAmigaBitmapFont</a>()</code>,
<code><a href="#topic+rasterToAmigaBitmapFont">rasterToAmigaBitmapFont</a>()</code>,
<code><a href="#topic+rawToAmigaBitmapFont">rawToAmigaBitmapFont</a>()</code>,
<code><a href="#topic+read.AmigaBitmapFontSet">read.AmigaBitmapFontSet</a>()</code>,
<code><a href="#topic+read.AmigaBitmapFont">read.AmigaBitmapFont</a>()</code>,
<code><a href="#topic+write.AmigaBitmapFont">write.AmigaBitmapFont</a>()</code>
</p>
<p>Other raw.operations: 
<code><a href="#topic+as.AmigaBasic">as.AmigaBasic</a>()</code>,
<code><a href="#topic+as.raw.AmigaBasic">as.raw.AmigaBasic</a>()</code>,
<code><a href="#topic+colourToAmigaRaw">colourToAmigaRaw</a>()</code>,
<code><a href="#topic+packBitmap">packBitmap</a>()</code>,
<code><a href="#topic+rawToAmigaBasicBMAP">rawToAmigaBasicBMAP</a>()</code>,
<code><a href="#topic+rawToAmigaBasicShape">rawToAmigaBasicShape</a>()</code>,
<code><a href="#topic+rawToAmigaBasic">rawToAmigaBasic</a>()</code>,
<code><a href="#topic+rawToAmigaBitmapFont">rawToAmigaBitmapFont</a>()</code>,
<code><a href="#topic+rawToAmigaIcon">rawToAmigaIcon</a>()</code>,
<code><a href="#topic+rawToHWSprite">rawToHWSprite</a>()</code>,
<code><a href="#topic+rawToIFFChunk">rawToIFFChunk</a>()</code>,
<code><a href="#topic+rawToSysConfig">rawToSysConfig</a>()</code>,
<code><a href="#topic+simpleAmigaIcon">simpleAmigaIcon</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(font_example)

## First create raw font set data. Note that this raw data
## does not include the nested font bitmap images.
fontset.raw &lt;- as.raw(font_example)

## Therefore it is necesary to have the entire font stored as files:
write.AmigaBitmapFontSet(font_example, tempdir())

font.restored &lt;- rawToAmigaBitmapFontSet(fontset.raw, file.path(tempdir(), "AmigaFFH.font"))

## End(Not run)
</code></pre>

<hr>
<h2 id='rawToAmigaIcon'>Coerce raw data into an AmigaIcon class object</h2><span id='topic+rawToAmigaIcon'></span>

<h3>Description</h3>

<p><code><a href="#topic+AmigaIcon">AmigaIcon()</a></code> objects are comprehensive representations of binary Amiga
Workbench icon files (*.info). Use this function to convert <code>raw</code> data from
such a file to an <code><a href="#topic+AmigaIcon">AmigaIcon()</a></code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rawToAmigaIcon(x, palette = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rawToAmigaIcon_+3A_x">x</code></td>
<td>
<p>A vector of <code>raw</code> data that needs to be converted into an S3
<code><a href="#topic+AmigaIcon">AmigaIcon()</a></code> class object.</p>
</td></tr>
<tr><td><code id="rawToAmigaIcon_+3A_palette">palette</code></td>
<td>
<p>Provide a palette (<code>vector</code> of colours) for the icon bitmap image.
When set to <code>NULL</code> (default) the standard Amiga Workbench palette will be used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Icons files (*.info) were used as a graphical representations of files and
directories on the Commodore Amiga. This function will convert the raw data from such files
into a more comprehensive names list (see <code><a href="#topic+AmigaIcon">AmigaIcon()</a></code>). Use
<code><a href="#topic+as.raw">as.raw()</a></code> to achieve the inverse.
</p>


<h3>Value</h3>

<p>Returns an <code><a href="#topic+AmigaIcon">AmigaIcon()</a></code> class object based on <code>x</code>.
</p>


<h3>Author(s)</h3>

<p>Pepijn de Vries
</p>


<h3>See Also</h3>

<p>Other AmigaIcon.operations: 
<code><a href="#topic+AmigaIcon">AmigaIcon</a></code>,
<code><a href="#topic+read.AmigaIcon">read.AmigaIcon</a>()</code>,
<code><a href="#topic+simpleAmigaIcon">simpleAmigaIcon</a>()</code>,
<code><a href="#topic+write.AmigaIcon">write.AmigaIcon</a>()</code>
</p>
<p>Other raw.operations: 
<code><a href="#topic+as.AmigaBasic">as.AmigaBasic</a>()</code>,
<code><a href="#topic+as.raw.AmigaBasic">as.raw.AmigaBasic</a>()</code>,
<code><a href="#topic+colourToAmigaRaw">colourToAmigaRaw</a>()</code>,
<code><a href="#topic+packBitmap">packBitmap</a>()</code>,
<code><a href="#topic+rawToAmigaBasicBMAP">rawToAmigaBasicBMAP</a>()</code>,
<code><a href="#topic+rawToAmigaBasicShape">rawToAmigaBasicShape</a>()</code>,
<code><a href="#topic+rawToAmigaBasic">rawToAmigaBasic</a>()</code>,
<code><a href="#topic+rawToAmigaBitmapFontSet">rawToAmigaBitmapFontSet</a>()</code>,
<code><a href="#topic+rawToAmigaBitmapFont">rawToAmigaBitmapFont</a>()</code>,
<code><a href="#topic+rawToHWSprite">rawToHWSprite</a>()</code>,
<code><a href="#topic+rawToIFFChunk">rawToIFFChunk</a>()</code>,
<code><a href="#topic+rawToSysConfig">rawToSysConfig</a>()</code>,
<code><a href="#topic+simpleAmigaIcon">simpleAmigaIcon</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## generate a simple AmigaIcon object:
icon &lt;- simpleAmigaIcon()

## convert it into raw data:
icon.raw &lt;- as.raw(icon)

## convert the raw data back into an icon:
icon.restored &lt;- rawToAmigaIcon(icon.raw)

## End(Not run)
</code></pre>

<hr>
<h2 id='rawToHWSprite'>Convert raw data into an Amiga hardware sprite</h2><span id='topic+rawToHWSprite'></span><span id='topic+rawToHWSprite+2Craw+2Cmissing-method'></span><span id='topic+rawToHWSprite+2Craw+2Ccharacter-method'></span>

<h3>Description</h3>

<p>Convert <code>raw</code> data structured conform a Commodore Amiga hardware
sprite (see references) into a <code><a href="#topic+hardwareSprite">hardwareSprite()</a></code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'raw,missing'
rawToHWSprite(x, col)

## S4 method for signature 'raw,character'
rawToHWSprite(x, col)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rawToHWSprite_+3A_x">x</code></td>
<td>
<p><code>raw</code> data structured as an Amiga hardware sprite
(see references).</p>
</td></tr>
<tr><td><code id="rawToHWSprite_+3A_col">col</code></td>
<td>
<p>A <code>vector</code> of colours (<code>character</code>) to be used
for the hardware sprite. Specify the three visible colours for the
sprite. When missing some default colours (grayscale) will be used.
The colours have to be provided separately as they are usually not stored
together with the hardware sprite data.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Information to set up a hardware sprite is stored as <code>raw</code> data
on Commodore Amigas. This method can be used to convert this data
into a <code><a href="#topic+hardwareSprite">hardwareSprite()</a></code> object. This object can in turn
be converted with <code><a href="#topic+as.raster">as.raster()</a></code> such that it can be plotted in R.
</p>


<h3>Value</h3>

<p>Returns a <code><a href="#topic+hardwareSprite">hardwareSprite()</a></code> object based on the provided raw data
</p>


<h3>Author(s)</h3>

<p>Pepijn de Vries
</p>


<h3>References</h3>

<p><a href="http://amigadev.elowar.com/read/ADCD_2.1/Hardware_Manual_guide/node00B9.html">http://amigadev.elowar.com/read/ADCD_2.1/Hardware_Manual_guide/node00B9.html</a>
</p>


<h3>See Also</h3>

<p>Other raw.operations: 
<code><a href="#topic+as.AmigaBasic">as.AmigaBasic</a>()</code>,
<code><a href="#topic+as.raw.AmigaBasic">as.raw.AmigaBasic</a>()</code>,
<code><a href="#topic+colourToAmigaRaw">colourToAmigaRaw</a>()</code>,
<code><a href="#topic+packBitmap">packBitmap</a>()</code>,
<code><a href="#topic+rawToAmigaBasicBMAP">rawToAmigaBasicBMAP</a>()</code>,
<code><a href="#topic+rawToAmigaBasicShape">rawToAmigaBasicShape</a>()</code>,
<code><a href="#topic+rawToAmigaBasic">rawToAmigaBasic</a>()</code>,
<code><a href="#topic+rawToAmigaBitmapFontSet">rawToAmigaBitmapFontSet</a>()</code>,
<code><a href="#topic+rawToAmigaBitmapFont">rawToAmigaBitmapFont</a>()</code>,
<code><a href="#topic+rawToAmigaIcon">rawToAmigaIcon</a>()</code>,
<code><a href="#topic+rawToIFFChunk">rawToIFFChunk</a>()</code>,
<code><a href="#topic+rawToSysConfig">rawToSysConfig</a>()</code>,
<code><a href="#topic+simpleAmigaIcon">simpleAmigaIcon</a>()</code>
</p>
<p>Other HWSprite.operations: 
<code><a href="#topic+rasterToHWSprite">rasterToHWSprite</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Let's generate a 16x16 sprite with a random bitmap:
dat &lt;- as.raw(c(0x00, 0x00, 0x10, 0x00,
              sample.int(255, 64, replace = TRUE),
              0x00, 0x00, 0x00, 0x00))
## make it a hardware sprite object:
spr &lt;- rawToHWSprite(dat)
## and plot it:
plot(spr, interpolate = FALSE)

## with some imagination when can make
## a more structured image:
dat &lt;- as.raw(c(0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0xff, 0xf8,
                0x7f, 0x80, 0x80, 0x70, 0x7f, 0x00, 0xbe, 0xe0,
                0x7e, 0x00, 0x85, 0xc0, 0x7d, 0x80, 0x82, 0x40,
                0x6b, 0xc0, 0x95, 0xa0, 0x57, 0xe0, 0xa8, 0xd0,
                0x2f, 0xf0, 0xd1, 0x68, 0x4f, 0xf8, 0xb0, 0x34,
                0x07, 0xfc, 0xf8, 0x5a, 0x03, 0xfe, 0xe4, 0x0d,
                0x01, 0xfc, 0xc2, 0x12, 0x00, 0xf8, 0x81, 0x04,
                0x00, 0x70, 0x00, 0x88, 0x00, 0x20, 0x00, 0x50,
                0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00))
spr &lt;- rawToHWSprite(dat, c("#EE4444", "#000000", "#EEEECC"))
plot(spr, interpolate = FALSE)
</code></pre>

<hr>
<h2 id='rawToIFFChunk'>Coerce raw data to an IFFChunk class object</h2><span id='topic+rawToIFFChunk'></span><span id='topic+rawToIFFChunk+2Craw-method'></span>

<h3>Description</h3>

<p>Coerce raw data, as it would be stored in the Interchange File Format (IFF), and
convert it into an <code><a href="#topic+IFFChunk">IFFChunk()</a></code> class object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'raw'
rawToIFFChunk(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rawToIFFChunk_+3A_x">x</code></td>
<td>
<p>A vector of raw data that needs to be converted into a <code><a href="#topic+IFFChunk">IFFChunk()</a></code>
class object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This method should work for all IFF chunk types that are implemented in this package
(see <code><a href="#topic+IFFChunk-method">IFFChunk-method()</a></code> for details). For non-implemented chunks this method
may work properly as long as the chunks are nested inside a FORM type container chunk.
This method is provided for your convenience, but it is recommended to import IFFChunk
methods using the <code><a href="#topic+read.iff">read.iff()</a></code> function. Use <code><a href="#topic+as.raw">as.raw()</a></code>
to achieve the inverse of this method.
</p>


<h3>Value</h3>

<p>Returns an <code><a href="#topic+IFFChunk">IFFChunk()</a></code> class object based on <code>x</code>.
</p>


<h3>Author(s)</h3>

<p>Pepijn de Vries
</p>


<h3>See Also</h3>

<p>Other iff.operations: 
<code><a href="#topic+IFFChunk-class">IFFChunk-class</a></code>,
<code><a href="#topic+WaveToIFF">WaveToIFF</a>()</code>,
<code><a href="#topic+as.raster.AmigaBasicShape">as.raster.AmigaBasicShape</a>()</code>,
<code><a href="#topic+getIFFChunk">getIFFChunk</a>()</code>,
<code><a href="#topic+interpretIFFChunk">interpretIFFChunk</a>()</code>,
<code><a href="#topic+rasterToIFF">rasterToIFF</a>()</code>,
<code><a href="#topic+read.iff">read.iff</a>()</code>,
<code><a href="#topic+write.iff">write.iff</a>()</code>
</p>
<p>Other raw.operations: 
<code><a href="#topic+as.AmigaBasic">as.AmigaBasic</a>()</code>,
<code><a href="#topic+as.raw.AmigaBasic">as.raw.AmigaBasic</a>()</code>,
<code><a href="#topic+colourToAmigaRaw">colourToAmigaRaw</a>()</code>,
<code><a href="#topic+packBitmap">packBitmap</a>()</code>,
<code><a href="#topic+rawToAmigaBasicBMAP">rawToAmigaBasicBMAP</a>()</code>,
<code><a href="#topic+rawToAmigaBasicShape">rawToAmigaBasicShape</a>()</code>,
<code><a href="#topic+rawToAmigaBasic">rawToAmigaBasic</a>()</code>,
<code><a href="#topic+rawToAmigaBitmapFontSet">rawToAmigaBitmapFontSet</a>()</code>,
<code><a href="#topic+rawToAmigaBitmapFont">rawToAmigaBitmapFont</a>()</code>,
<code><a href="#topic+rawToAmigaIcon">rawToAmigaIcon</a>()</code>,
<code><a href="#topic+rawToHWSprite">rawToHWSprite</a>()</code>,
<code><a href="#topic+rawToSysConfig">rawToSysConfig</a>()</code>,
<code><a href="#topic+simpleAmigaIcon">simpleAmigaIcon</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## Get an IFFChunk object:
example.iff &lt;- read.iff(system.file("ilbm8lores.iff", package = "AmigaFFH"))

## Coerce it to raw data:
example.raw &lt;- as.raw(example.iff)

## Coerce raw data to IFF chunk:
example.iff.new &lt;- rawToIFFChunk(example.raw)

## These conversions were non-destructive:
identical(example.iff, example.iff.new)

## End(Not run)
</code></pre>

<hr>
<h2 id='rawToSysConfig'>Coerce raw data into a SysConfig class object</h2><span id='topic+rawToSysConfig'></span>

<h3>Description</h3>

<p><a href="#topic+SysConfig">SysConfig</a> objects are comprehensive representations of binary Amiga
system-configuration files. Use this function to convert <code>raw</code> data from
such a file to a <a href="#topic+SysConfig">SysConfig</a> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rawToSysConfig(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rawToSysConfig_+3A_x">x</code></td>
<td>
<p>A vector of <code>raw</code> data that needs to be converted into an S3
<a href="#topic+SysConfig">SysConfig</a> class object. It should have a length of at least 232. Although
system-configurations can be extended, such extended files are not supported here.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Amiga used the system-configuration file to store certain system preferences
in a binary file. With this function such <code>raw</code> data can be converted into
a more comprehensive <a href="#topic+SysConfig">SysConfig</a> object. Use <code><a href="#topic+as.raw">as.raw()</a></code>
to achieve the inverse.
</p>


<h3>Value</h3>

<p>Returns a <a href="#topic+SysConfig">SysConfig</a> class object based on <code>x</code>.
</p>


<h3>Author(s)</h3>

<p>Pepijn de Vries
</p>


<h3>See Also</h3>

<p>Other SysConfig.operations: 
<code><a href="#topic+SysConfig">SysConfig</a></code>,
<code><a href="#topic+read.SysConfig">read.SysConfig</a>()</code>,
<code><a href="#topic+simpleSysConfig">simpleSysConfig</a>()</code>,
<code><a href="#topic+write.SysConfig">write.SysConfig</a>()</code>
</p>
<p>Other raw.operations: 
<code><a href="#topic+as.AmigaBasic">as.AmigaBasic</a>()</code>,
<code><a href="#topic+as.raw.AmigaBasic">as.raw.AmigaBasic</a>()</code>,
<code><a href="#topic+colourToAmigaRaw">colourToAmigaRaw</a>()</code>,
<code><a href="#topic+packBitmap">packBitmap</a>()</code>,
<code><a href="#topic+rawToAmigaBasicBMAP">rawToAmigaBasicBMAP</a>()</code>,
<code><a href="#topic+rawToAmigaBasicShape">rawToAmigaBasicShape</a>()</code>,
<code><a href="#topic+rawToAmigaBasic">rawToAmigaBasic</a>()</code>,
<code><a href="#topic+rawToAmigaBitmapFontSet">rawToAmigaBitmapFontSet</a>()</code>,
<code><a href="#topic+rawToAmigaBitmapFont">rawToAmigaBitmapFont</a>()</code>,
<code><a href="#topic+rawToAmigaIcon">rawToAmigaIcon</a>()</code>,
<code><a href="#topic+rawToHWSprite">rawToHWSprite</a>()</code>,
<code><a href="#topic+rawToIFFChunk">rawToIFFChunk</a>()</code>,
<code><a href="#topic+simpleAmigaIcon">simpleAmigaIcon</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## get the system-configuration from the adfExplorer example disk:
sc &lt;- adfExplorer::get.adf.file(adfExplorer::adf.example, "devs/system-configuration")

## This will get you the raw data from the file:
typeof(sc)

## Convert the raw data to a more comprehensive named list (and S3 SysConfig class):
sc &lt;- rawToSysConfig(sc)

## End(Not run)
</code></pre>

<hr>
<h2 id='read.AmigaBasic'>Read Amiga Basic files</h2><span id='topic+read.AmigaBasic'></span>

<h3>Description</h3>

<p>Read an <code><a href="#topic+AmigaBasic">AmigaBasic()</a></code> script from its binary format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.AmigaBasic(file, disk = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read.AmigaBasic_+3A_file">file</code></td>
<td>
<p>A <code>character</code> string of the filename of the Amiga Basic file to be read.</p>
</td></tr>
<tr><td><code id="read.AmigaBasic_+3A_disk">disk</code></td>
<td>
<p>A virtual Commodore Amiga disk from which the <code>file</code> should be
read. This should be an <code><a href="adfExplorer.html#topic+amigaDisk-class">amigaDisk()</a></code> object. Using
this argument requires the adfExplorer package.
When set to <code>NULL</code>, this argument is ignored.</p>
</td></tr>
<tr><td><code id="read.AmigaBasic_+3A_...">...</code></td>
<td>
<p>Currently ignored</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Normally Amiga Basic code is stored encoded in a binary format
(<code><a href="#topic+rawToAmigaBasic">rawToAmigaBasic()</a></code>).
This function reads the binary data from a file (which can be
stored on a virtual disk (<code><a href="adfExplorer.html#topic+amigaDisk-class">amigaDisk()</a></code>))
and converts in into an <code><a href="#topic+AmigaBasic">AmigaBasic()</a></code> class objec.
</p>


<h3>Value</h3>

<p>Returns an <code><a href="#topic+AmigaBasic">AmigaBasic()</a></code> class object read from the <code>file</code>.
</p>


<h3>Author(s)</h3>

<p>Pepijn de Vries
</p>


<h3>See Also</h3>

<p>Other AmigaBasic.operations: 
<code><a href="#topic+AmigaBasic.reserved">AmigaBasic.reserved</a>()</code>,
<code><a href="#topic+AmigaBasicBMAP">AmigaBasicBMAP</a></code>,
<code><a href="#topic+AmigaBasic">AmigaBasic</a></code>,
<code><a href="#topic++5B.AmigaBasic">[.AmigaBasic</a>()</code>,
<code><a href="#topic+as.AmigaBasicBMAP">as.AmigaBasicBMAP</a>()</code>,
<code><a href="#topic+as.AmigaBasic">as.AmigaBasic</a>()</code>,
<code><a href="#topic+as.character">as.character</a>()</code>,
<code><a href="#topic+check.names.AmigaBasic">check.names.AmigaBasic</a>()</code>,
<code><a href="#topic+names.AmigaBasic">names.AmigaBasic</a>()</code>,
<code><a href="#topic+rawToAmigaBasicBMAP">rawToAmigaBasicBMAP</a>()</code>,
<code><a href="#topic+rawToAmigaBasic">rawToAmigaBasic</a>()</code>,
<code><a href="#topic+read.AmigaBasicBMAP">read.AmigaBasicBMAP</a>()</code>,
<code><a href="#topic+write.AmigaBasic">write.AmigaBasic</a>()</code>
</p>
<p>Other io.operations: 
<code><a href="#topic+read.AmigaBasicBMAP">read.AmigaBasicBMAP</a>()</code>,
<code><a href="#topic+read.AmigaBasicShape">read.AmigaBasicShape</a>()</code>,
<code><a href="#topic+read.AmigaBitmapFontSet">read.AmigaBitmapFontSet</a>()</code>,
<code><a href="#topic+read.AmigaBitmapFont">read.AmigaBitmapFont</a>()</code>,
<code><a href="#topic+read.AmigaIcon">read.AmigaIcon</a>()</code>,
<code><a href="#topic+read.SysConfig">read.SysConfig</a>()</code>,
<code><a href="#topic+read.iff">read.iff</a>()</code>,
<code><a href="#topic+write.AmigaBasicShape">write.AmigaBasicShape</a>()</code>,
<code><a href="#topic+write.AmigaBasic">write.AmigaBasic</a>()</code>,
<code><a href="#topic+write.AmigaBitmapFont">write.AmigaBitmapFont</a>()</code>,
<code><a href="#topic+write.AmigaIcon">write.AmigaIcon</a>()</code>,
<code><a href="#topic+write.SysConfig">write.SysConfig</a>()</code>,
<code><a href="#topic+write.iff">write.iff</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## First create an AmigaBasic file
write.AmigaBasic(as.AmigaBasic("PRINT \"Hello world\""),
                 file.path(tempdir(), "helloworld.bas"))

## Now let's read the same file:
bas &lt;- read.AmigaBasic(file.path(tempdir(), "helloworld.bas"))

## End(Not run)

## There's also a demo file included with the package
demo.bas &lt;- read.AmigaBasic(system.file("demo.bas", package = "AmigaFFH"))
demo.bas
</code></pre>

<hr>
<h2 id='read.AmigaBasicBMAP'>Read and write Amiga Basic BMAP files</h2><span id='topic+read.AmigaBasicBMAP'></span><span id='topic+write.AmigaBasicBMAP'></span>

<h3>Description</h3>

<p>Read and write <code><a href="#topic+AmigaBasicBMAP">AmigaBasicBMAP()</a></code> binary file format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.AmigaBasicBMAP(file, disk = NULL)

write.AmigaBasicBMAP(x, file, disk = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read.AmigaBasicBMAP_+3A_file">file</code></td>
<td>
<p>A <code>character</code> string of the filename of the Amiga Basic BMAP file to be read or written.</p>
</td></tr>
<tr><td><code id="read.AmigaBasicBMAP_+3A_disk">disk</code></td>
<td>
<p>A virtual Commodore Amiga disk from which the <code>file</code> should be
read or written to. This should be an <code><a href="adfExplorer.html#topic+amigaDisk-class">amigaDisk()</a></code> object. Using
this argument requires the adfExplorer package.
When set to <code>NULL</code>, this argument is ignored.</p>
</td></tr>
<tr><td><code id="read.AmigaBasicBMAP_+3A_x">x</code></td>
<td>
<p>A <code><a href="#topic+AmigaBasicBMAP">AmigaBasicBMAP()</a></code> class object that needs to be
stored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An <a href="#topic+AmigaBasicBMAP">Amiga Basic BMAP</a> file maps the offset of routines in Amiga libraries and can be
read as a comprehensive list and written back to a binary file using these functions.
</p>


<h3>Value</h3>

<p>Returns an <code><a href="#topic+AmigaBasicBMAP">AmigaBasicBMAP()</a></code> class object read from the <code>file</code> in case of
<code>read.AmigaBasicBMAP</code>. Otherwise, invisibly returns the result of the call of <code>close</code> to the
file connection. Or, when <code>disk</code> is specified, a copy of
<code>disk</code> is returned to which the file is written.
</p>


<h3>Author(s)</h3>

<p>Pepijn de Vries
</p>


<h3>See Also</h3>

<p>Other AmigaBasic.operations: 
<code><a href="#topic+AmigaBasic.reserved">AmigaBasic.reserved</a>()</code>,
<code><a href="#topic+AmigaBasicBMAP">AmigaBasicBMAP</a></code>,
<code><a href="#topic+AmigaBasic">AmigaBasic</a></code>,
<code><a href="#topic++5B.AmigaBasic">[.AmigaBasic</a>()</code>,
<code><a href="#topic+as.AmigaBasicBMAP">as.AmigaBasicBMAP</a>()</code>,
<code><a href="#topic+as.AmigaBasic">as.AmigaBasic</a>()</code>,
<code><a href="#topic+as.character">as.character</a>()</code>,
<code><a href="#topic+check.names.AmigaBasic">check.names.AmigaBasic</a>()</code>,
<code><a href="#topic+names.AmigaBasic">names.AmigaBasic</a>()</code>,
<code><a href="#topic+rawToAmigaBasicBMAP">rawToAmigaBasicBMAP</a>()</code>,
<code><a href="#topic+rawToAmigaBasic">rawToAmigaBasic</a>()</code>,
<code><a href="#topic+read.AmigaBasic">read.AmigaBasic</a>()</code>,
<code><a href="#topic+write.AmigaBasic">write.AmigaBasic</a>()</code>
</p>
<p>Other io.operations: 
<code><a href="#topic+read.AmigaBasicShape">read.AmigaBasicShape</a>()</code>,
<code><a href="#topic+read.AmigaBasic">read.AmigaBasic</a>()</code>,
<code><a href="#topic+read.AmigaBitmapFontSet">read.AmigaBitmapFontSet</a>()</code>,
<code><a href="#topic+read.AmigaBitmapFont">read.AmigaBitmapFont</a>()</code>,
<code><a href="#topic+read.AmigaIcon">read.AmigaIcon</a>()</code>,
<code><a href="#topic+read.SysConfig">read.SysConfig</a>()</code>,
<code><a href="#topic+read.iff">read.iff</a>()</code>,
<code><a href="#topic+write.AmigaBasicShape">write.AmigaBasicShape</a>()</code>,
<code><a href="#topic+write.AmigaBasic">write.AmigaBasic</a>()</code>,
<code><a href="#topic+write.AmigaBitmapFont">write.AmigaBitmapFont</a>()</code>,
<code><a href="#topic+write.AmigaIcon">write.AmigaIcon</a>()</code>,
<code><a href="#topic+write.SysConfig">write.SysConfig</a>()</code>,
<code><a href="#topic+write.iff">write.iff</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## A small fragment of the dos.library BMAP would look like this:
dos.bmap &lt;- as.AmigaBasicBMAP(list(
  xOpen = list(
    libraryVectorOffset = -30,
    registers = as.raw(2:3)
  ),
  xClose = list(
    libraryVectorOffset = -36,
    registers = as.raw(2)
  ),
  xRead = list(
    libraryVectorOffset = -42,
    registers = as.raw(2:4)
  )
))

## This will write the BMAP to a file:
write.AmigaBasicBMAP(dos.bmap, file.path(tempdir(), "dos.bmap"))

## This will read the same file:
dos.bmap.copy &lt;- read.AmigaBasicBMAP(file.path(tempdir(), "dos.bmap"))

## End(Not run)
</code></pre>

<hr>
<h2 id='read.AmigaBasicShape'>Read Amiga Basic Shape files</h2><span id='topic+read.AmigaBasicShape'></span>

<h3>Description</h3>

<p>Read Amiga Basic Shape files
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.AmigaBasicShape(file, disk = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read.AmigaBasicShape_+3A_file">file</code></td>
<td>
<p>A <code>character</code> string of the filename of the Amiga Basic Shape file to be read.</p>
</td></tr>
<tr><td><code id="read.AmigaBasicShape_+3A_disk">disk</code></td>
<td>
<p>A virtual Commodore Amiga disk from which the <code>file</code> should be
read. This should be an <code><a href="adfExplorer.html#topic+amigaDisk-class">amigaDisk()</a></code> object. Using
this argument requires the adfExplorer package.
When set to <code>NULL</code>, this argument is ignored.</p>
</td></tr>
<tr><td><code id="read.AmigaBasicShape_+3A_...">...</code></td>
<td>
<p>Arguments passed to <code><a href="#topic+rawToAmigaBasicShape">rawToAmigaBasicShape()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>AmigaBasic used the term 'shapes' for graphics (sprites and blitter objects) which it could display.
These graphics were stored in a specific binary format, which can be read with this function. See
<code><a href="#topic+AmigaBasicShape">AmigaBasicShape()</a></code> for more details. The file can also be read from a virtual Amiga disk
(<code><a href="adfExplorer.html#topic+amigaDisk-class">amigaDisk()</a></code>).
</p>


<h3>Value</h3>

<p>Returns an <code><a href="#topic+AmigaBasicShape">AmigaBasicShape()</a></code> class object read from the <code>file</code>.
</p>


<h3>Author(s)</h3>

<p>Pepijn de Vries
</p>


<h3>See Also</h3>

<p>Other AmigaBasicShape.operations: 
<code><a href="#topic+AmigaBasicShape">AmigaBasicShape</a></code>,
<code><a href="#topic+rasterToAmigaBasicShape">rasterToAmigaBasicShape</a>()</code>,
<code><a href="#topic+write.AmigaBasicShape">write.AmigaBasicShape</a>()</code>
</p>
<p>Other io.operations: 
<code><a href="#topic+read.AmigaBasicBMAP">read.AmigaBasicBMAP</a>()</code>,
<code><a href="#topic+read.AmigaBasic">read.AmigaBasic</a>()</code>,
<code><a href="#topic+read.AmigaBitmapFontSet">read.AmigaBitmapFontSet</a>()</code>,
<code><a href="#topic+read.AmigaBitmapFont">read.AmigaBitmapFont</a>()</code>,
<code><a href="#topic+read.AmigaIcon">read.AmigaIcon</a>()</code>,
<code><a href="#topic+read.SysConfig">read.SysConfig</a>()</code>,
<code><a href="#topic+read.iff">read.iff</a>()</code>,
<code><a href="#topic+write.AmigaBasicShape">write.AmigaBasicShape</a>()</code>,
<code><a href="#topic+write.AmigaBasic">write.AmigaBasic</a>()</code>,
<code><a href="#topic+write.AmigaBitmapFont">write.AmigaBitmapFont</a>()</code>,
<code><a href="#topic+write.AmigaIcon">write.AmigaIcon</a>()</code>,
<code><a href="#topic+write.SysConfig">write.SysConfig</a>()</code>,
<code><a href="#topic+write.iff">write.iff</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
filename &lt;- system.file("ball.shp", package = "AmigaFFH")
ball     &lt;- read.AmigaBasicShape(filename)
## This is a sprite:
ball$flags[["fVSprite"]]

filename &lt;- system.file("r_logo.shp", package = "AmigaFFH")
## The palette is not stored with an Amiga Basic Shape, so let's provide one:
r_logo   &lt;- read.AmigaBasicShape(filename,
                                 palette = c("#FFFFFF", "#2266BB", "#3366BB", "#4477AA",
                                 "#778899", "#999999", "#AAAAAA", "#BBBBBB"))
## This is a blitter object:
r_logo$flags[["fVSprite"]]

## Just for fun, plot it:
plot(r_logo)

## End(Not run)
</code></pre>

<hr>
<h2 id='read.AmigaBitmapFont'>Read an AmigaBitmapFont class object from a file</h2><span id='topic+read.AmigaBitmapFont'></span>

<h3>Description</h3>

<p>Amiga Font Bitmaps of distinctive font heights are stored in separate
files, which in combination form a font collection or set. This
function can be used to read a specific bitmap from a set and returns
it as an <code><a href="#topic+AmigaBitmapFont">AmigaBitmapFont()</a></code> class object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.AmigaBitmapFont(file, disk = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read.AmigaBitmapFont_+3A_file">file</code></td>
<td>
<p>The file name of a font subset is usually simply a numeric number
indicating the font height in pixels. Use <code>file</code> as a <code>character</code>
string representing that file location.</p>
</td></tr>
<tr><td><code id="read.AmigaBitmapFont_+3A_disk">disk</code></td>
<td>
<p>A virtual Commodore Amiga disk from which the <code>file</code> should be
read. This should be an <code><a href="adfExplorer.html#topic+amigaDisk-class">amigaDisk()</a></code> object. Using
this argument requires the adfExplorer package.
When set to <code>NULL</code>, this argument is ignored.</p>
</td></tr>
<tr><td><code id="read.AmigaBitmapFont_+3A_...">...</code></td>
<td>
<p>Arguments passed on to <code><a href="#topic+rawToAmigaBitmapFont">rawToAmigaBitmapFont()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Individual font bitmaps are stored in a font's subdirectory where
the file name is usually equal to the font height in pixels. This
function will read such a font bitmap file and return it as an
<code><a href="#topic+AmigaBitmapFont">AmigaBitmapFont()</a></code> class object. It can also read such
files from <code><a href="adfExplorer.html#topic+amigaDisk-class">adfExplorer::amigaDisk-class()</a></code> objects,
but that requires the adfExplorer package to be installed.
</p>


<h3>Value</h3>

<p>Returns an <code><a href="#topic+AmigaBitmapFont">AmigaBitmapFont()</a></code> object read from the specified file.
</p>


<h3>Author(s)</h3>

<p>Pepijn de Vries
</p>


<h3>See Also</h3>

<p>Other AmigaBitmapFont.operations: 
<code><a href="#topic+AmigaBitmapFont">AmigaBitmapFont</a></code>,
<code><a href="#topic+availableFontSizes">availableFontSizes</a>()</code>,
<code><a href="#topic+c">c</a>()</code>,
<code><a href="#topic+fontName">fontName</a>()</code>,
<code><a href="#topic+font_example">font_example</a></code>,
<code><a href="#topic+getAmigaBitmapFont">getAmigaBitmapFont</a>()</code>,
<code><a href="#topic+rasterToAmigaBitmapFont">rasterToAmigaBitmapFont</a>()</code>,
<code><a href="#topic+rawToAmigaBitmapFontSet">rawToAmigaBitmapFontSet</a>()</code>,
<code><a href="#topic+rawToAmigaBitmapFont">rawToAmigaBitmapFont</a>()</code>,
<code><a href="#topic+read.AmigaBitmapFontSet">read.AmigaBitmapFontSet</a>()</code>,
<code><a href="#topic+write.AmigaBitmapFont">write.AmigaBitmapFont</a>()</code>
</p>
<p>Other io.operations: 
<code><a href="#topic+read.AmigaBasicBMAP">read.AmigaBasicBMAP</a>()</code>,
<code><a href="#topic+read.AmigaBasicShape">read.AmigaBasicShape</a>()</code>,
<code><a href="#topic+read.AmigaBasic">read.AmigaBasic</a>()</code>,
<code><a href="#topic+read.AmigaBitmapFontSet">read.AmigaBitmapFontSet</a>()</code>,
<code><a href="#topic+read.AmigaIcon">read.AmigaIcon</a>()</code>,
<code><a href="#topic+read.SysConfig">read.SysConfig</a>()</code>,
<code><a href="#topic+read.iff">read.iff</a>()</code>,
<code><a href="#topic+write.AmigaBasicShape">write.AmigaBasicShape</a>()</code>,
<code><a href="#topic+write.AmigaBasic">write.AmigaBasic</a>()</code>,
<code><a href="#topic+write.AmigaBitmapFont">write.AmigaBitmapFont</a>()</code>,
<code><a href="#topic+write.AmigaIcon">write.AmigaIcon</a>()</code>,
<code><a href="#topic+write.SysConfig">write.SysConfig</a>()</code>,
<code><a href="#topic+write.iff">write.iff</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(font_example)

## Let's store the example font first:
write.AmigaBitmapFontSet(font_example, tempdir())

## Now read a specific subset from the font files:
font.sub &lt;- read.AmigaBitmapFont(file.path(tempdir(), "AmigaFFH", "9"))

## The same can be done with a virtual Amiga disk. The following
## examples require the 'adfExplorer' package.
font.disk &lt;- adfExplorer::blank.amigaDOSDisk("font.disk")
font.disk &lt;- adfExplorer::dir.create.adf(font.disk, "FONTS")
font.disk &lt;- write.AmigaBitmapFontSet(font_example, "DF0:FONTS", font.disk)
font.sub &lt;- read.AmigaBitmapFont("DF0:FONTS/AmigaFFH/9", font.disk)

## End(Not run)
</code></pre>

<hr>
<h2 id='read.AmigaBitmapFontSet'>Read AmigaBitmapFontSet from *.font file</h2><span id='topic+read.AmigaBitmapFontSet'></span>

<h3>Description</h3>

<p>Reads <code><a href="#topic+AmigaBitmapFontSet">AmigaBitmapFontSet()</a></code> from *.font file including
all nested bitmap images for all font heights.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.AmigaBitmapFontSet(file, disk = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read.AmigaBitmapFontSet_+3A_file">file</code></td>
<td>
<p>A <code>character</code> string of the filename of the *.font file to be read.</p>
</td></tr>
<tr><td><code id="read.AmigaBitmapFontSet_+3A_disk">disk</code></td>
<td>
<p>A virtual Commodore Amiga disk from which the <code>file</code> should be
read. This should be an <code><a href="adfExplorer.html#topic+amigaDisk-class">amigaDisk()</a></code> object. Using
this argument requires the adfExplorer package.
When set to <code>NULL</code>, this argument is ignored.</p>
</td></tr>
<tr><td><code id="read.AmigaBitmapFontSet_+3A_...">...</code></td>
<td>
<p>Currently ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The *.font file only holds meta-information. The bitmap images for
each font height are stored in separate files, which are listed
in the *.font file. The function reads the *.font file, including
all nested bitmap files and returns it as a
<code><a href="#topic+AmigaBitmapFontSet">AmigaBitmapFontSet()</a></code>.
</p>
<p>It can also read *.font files
from <code><a href="adfExplorer.html#topic+amigaDisk-class">adfExplorer::amigaDisk-class()</a></code> objects,
but that requires the adfExplorer package to be installed.
</p>


<h3>Value</h3>

<p>Returns an <code><a href="#topic+AmigaBitmapFontSet">AmigaBitmapFontSet()</a></code> object read from the specified file.
</p>


<h3>Author(s)</h3>

<p>Pepijn de Vries
</p>


<h3>See Also</h3>

<p>Other AmigaBitmapFont.operations: 
<code><a href="#topic+AmigaBitmapFont">AmigaBitmapFont</a></code>,
<code><a href="#topic+availableFontSizes">availableFontSizes</a>()</code>,
<code><a href="#topic+c">c</a>()</code>,
<code><a href="#topic+fontName">fontName</a>()</code>,
<code><a href="#topic+font_example">font_example</a></code>,
<code><a href="#topic+getAmigaBitmapFont">getAmigaBitmapFont</a>()</code>,
<code><a href="#topic+rasterToAmigaBitmapFont">rasterToAmigaBitmapFont</a>()</code>,
<code><a href="#topic+rawToAmigaBitmapFontSet">rawToAmigaBitmapFontSet</a>()</code>,
<code><a href="#topic+rawToAmigaBitmapFont">rawToAmigaBitmapFont</a>()</code>,
<code><a href="#topic+read.AmigaBitmapFont">read.AmigaBitmapFont</a>()</code>,
<code><a href="#topic+write.AmigaBitmapFont">write.AmigaBitmapFont</a>()</code>
</p>
<p>Other io.operations: 
<code><a href="#topic+read.AmigaBasicBMAP">read.AmigaBasicBMAP</a>()</code>,
<code><a href="#topic+read.AmigaBasicShape">read.AmigaBasicShape</a>()</code>,
<code><a href="#topic+read.AmigaBasic">read.AmigaBasic</a>()</code>,
<code><a href="#topic+read.AmigaBitmapFont">read.AmigaBitmapFont</a>()</code>,
<code><a href="#topic+read.AmigaIcon">read.AmigaIcon</a>()</code>,
<code><a href="#topic+read.SysConfig">read.SysConfig</a>()</code>,
<code><a href="#topic+read.iff">read.iff</a>()</code>,
<code><a href="#topic+write.AmigaBasicShape">write.AmigaBasicShape</a>()</code>,
<code><a href="#topic+write.AmigaBasic">write.AmigaBasic</a>()</code>,
<code><a href="#topic+write.AmigaBitmapFont">write.AmigaBitmapFont</a>()</code>,
<code><a href="#topic+write.AmigaIcon">write.AmigaIcon</a>()</code>,
<code><a href="#topic+write.SysConfig">write.SysConfig</a>()</code>,
<code><a href="#topic+write.iff">write.iff</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(font_example)

## in order to read, we first need to write a file"
write.AmigaBitmapFontSet(font_example, tempdir())

## The font is written as 'AmigaFFH.font' as that name
## is embedded in the AmigaBitmapFontSet object 'font_example'.
## We can read it as follows:
font.read &lt;- read.AmigaBitmapFontSet(file.path(tempdir(), "AmigaFFH.font"))

## similarly, the file can also be written and read from and to
## a virtual amiga disk. The following codes requires the 'adfExplorer'
## package:
adf &lt;- adfExplorer::blank.amigaDOSDisk("font.disk")
adf &lt;- adfExplorer::dir.create.adf(adf, "FONTS")
adf &lt;- write.AmigaBitmapFontSet(font_example, "DF0:FONTS", adf)
font.read &lt;- read.AmigaBitmapFontSet("DF0:FONTS/AmigaFFH.font", adf)

## End(Not run)
</code></pre>

<hr>
<h2 id='read.AmigaIcon'>Read an Amiga Workbench icon (info) file</h2><span id='topic+read.AmigaIcon'></span>

<h3>Description</h3>

<p>Graphical representation of files and directories (icons) are stored as
separate files (with the .info extension) on the Amiga. This function reads such files
and imports them as <code><a href="#topic+AmigaIcon">AmigaIcon()</a></code> class objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.AmigaIcon(file, disk = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read.AmigaIcon_+3A_file">file</code></td>
<td>
<p>A <code>character</code> string representing the file name from which the
icon data should be read.</p>
</td></tr>
<tr><td><code id="read.AmigaIcon_+3A_disk">disk</code></td>
<td>
<p>A virtual Commodore Amiga disk from which the <code>file</code> should be
read. This should be an <code><a href="adfExplorer.html#topic+amigaDisk-class">amigaDisk()</a></code> object. Using
this argument requires the adfExplorer package.
When set to <code>NULL</code>, this argument is ignored.</p>
</td></tr>
<tr><td><code id="read.AmigaIcon_+3A_...">...</code></td>
<td>
<p>Arguments passed on to <code><a href="#topic+rawToAmigaIcon">rawToAmigaIcon()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code><a href="#topic+AmigaIcon">AmigaIcon()</a></code> S3 object provides a comprehensive format
for Amiga icons, which are used as a graphical representation of files
and directories on the Amiga. The <code><a href="#topic+AmigaIcon">AmigaIcon()</a></code> is a named
list containing all information of an icon. Use this function to
read an Amiga icon (with the .info extension) from a file and convert
it into an <code><a href="#topic+AmigaIcon">AmigaIcon()</a></code> object.
</p>


<h3>Value</h3>

<p>Returns an <code><a href="#topic+AmigaIcon">AmigaIcon()</a></code> class object as read from the <code>file</code>.
</p>


<h3>Author(s)</h3>

<p>Pepijn de Vries
</p>


<h3>See Also</h3>

<p>Other AmigaIcon.operations: 
<code><a href="#topic+AmigaIcon">AmigaIcon</a></code>,
<code><a href="#topic+rawToAmigaIcon">rawToAmigaIcon</a>()</code>,
<code><a href="#topic+simpleAmigaIcon">simpleAmigaIcon</a>()</code>,
<code><a href="#topic+write.AmigaIcon">write.AmigaIcon</a>()</code>
</p>
<p>Other io.operations: 
<code><a href="#topic+read.AmigaBasicBMAP">read.AmigaBasicBMAP</a>()</code>,
<code><a href="#topic+read.AmigaBasicShape">read.AmigaBasicShape</a>()</code>,
<code><a href="#topic+read.AmigaBasic">read.AmigaBasic</a>()</code>,
<code><a href="#topic+read.AmigaBitmapFontSet">read.AmigaBitmapFontSet</a>()</code>,
<code><a href="#topic+read.AmigaBitmapFont">read.AmigaBitmapFont</a>()</code>,
<code><a href="#topic+read.SysConfig">read.SysConfig</a>()</code>,
<code><a href="#topic+read.iff">read.iff</a>()</code>,
<code><a href="#topic+write.AmigaBasicShape">write.AmigaBasicShape</a>()</code>,
<code><a href="#topic+write.AmigaBasic">write.AmigaBasic</a>()</code>,
<code><a href="#topic+write.AmigaBitmapFont">write.AmigaBitmapFont</a>()</code>,
<code><a href="#topic+write.AmigaIcon">write.AmigaIcon</a>()</code>,
<code><a href="#topic+write.SysConfig">write.SysConfig</a>()</code>,
<code><a href="#topic+write.iff">write.iff</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## create a simple AmigaIcon:
icon &lt;- simpleAmigaIcon()

## write the icon to the temp dir:
write.AmigaIcon(icon, file.path(tempdir(), "icon.info"))

## read the same file:
icon2 &lt;- read.AmigaIcon(file.path(tempdir(), "icon.info"))

## End(Not run)
</code></pre>

<hr>
<h2 id='read.iff'>Read Interchange File Format (IFF)</h2><span id='topic+read.iff'></span>

<h3>Description</h3>

<p>Read the Interchange File Format (IFF) as an <code><a href="#topic+IFFChunk">IFFChunk()</a></code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.iff(file, disk = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read.iff_+3A_file">file</code></td>
<td>
<p>A filename of an IFF file to be read, or a connection from which
binary data can be read.</p>
</td></tr>
<tr><td><code id="read.iff_+3A_disk">disk</code></td>
<td>
<p>A virtual Commodore Amiga disk from which the <code>file</code> should be
read. This should be an <code><a href="adfExplorer.html#topic+amigaDisk-class">amigaDisk()</a></code> object. Using
this argument requires the adfExplorer package.
When set to <code>NULL</code>, this argument is ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Information is stored as &lsquo;chunks&rsquo; in IFF files (see <code><a href="#topic+IFFChunk">IFFChunk()</a></code>).
Each chunk should at least contain a label of the type of chunk and the data
for that chunk. This function reads all chunks from a valid IFF file, including
all nested chunks and stores them in an <code><a href="#topic+IFFChunk">IFFChunk()</a></code> object. IFF
files can hold any kind of data (e.g. images or audio), this read function
does not interpret the file. Use <code><a href="#topic+interpretIFFChunk">interpretIFFChunk()</a></code> for that
purpose.
</p>


<h3>Value</h3>

<p>Returns a <code><a href="#topic+IFFChunk">IFFChunk()</a></code> object read from the specified file.
</p>


<h3>Author(s)</h3>

<p>Pepijn de Vries
</p>


<h3>See Also</h3>

<p>Other io.operations: 
<code><a href="#topic+read.AmigaBasicBMAP">read.AmigaBasicBMAP</a>()</code>,
<code><a href="#topic+read.AmigaBasicShape">read.AmigaBasicShape</a>()</code>,
<code><a href="#topic+read.AmigaBasic">read.AmigaBasic</a>()</code>,
<code><a href="#topic+read.AmigaBitmapFontSet">read.AmigaBitmapFontSet</a>()</code>,
<code><a href="#topic+read.AmigaBitmapFont">read.AmigaBitmapFont</a>()</code>,
<code><a href="#topic+read.AmigaIcon">read.AmigaIcon</a>()</code>,
<code><a href="#topic+read.SysConfig">read.SysConfig</a>()</code>,
<code><a href="#topic+write.AmigaBasicShape">write.AmigaBasicShape</a>()</code>,
<code><a href="#topic+write.AmigaBasic">write.AmigaBasic</a>()</code>,
<code><a href="#topic+write.AmigaBitmapFont">write.AmigaBitmapFont</a>()</code>,
<code><a href="#topic+write.AmigaIcon">write.AmigaIcon</a>()</code>,
<code><a href="#topic+write.SysConfig">write.SysConfig</a>()</code>,
<code><a href="#topic+write.iff">write.iff</a>()</code>
</p>
<p>Other iff.operations: 
<code><a href="#topic+IFFChunk-class">IFFChunk-class</a></code>,
<code><a href="#topic+WaveToIFF">WaveToIFF</a>()</code>,
<code><a href="#topic+as.raster.AmigaBasicShape">as.raster.AmigaBasicShape</a>()</code>,
<code><a href="#topic+getIFFChunk">getIFFChunk</a>()</code>,
<code><a href="#topic+interpretIFFChunk">interpretIFFChunk</a>()</code>,
<code><a href="#topic+rasterToIFF">rasterToIFF</a>()</code>,
<code><a href="#topic+rawToIFFChunk">rawToIFFChunk</a>()</code>,
<code><a href="#topic+write.iff">write.iff</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## let's read a bitmap image stored in IFF as provided with this package:
filename &lt;- system.file("ilbm8lores.iff", package = "AmigaFFH")
example.iff &lt;- read.iff(filename)

## And plot it:
plot(example.iff)

## End(Not run)
</code></pre>

<hr>
<h2 id='read.SysConfig'>Read an Amiga system-configuration file</h2><span id='topic+read.SysConfig'></span>

<h3>Description</h3>

<p>Read a binary Amiga system-configuration file and return as <a href="#topic+SysConfig">SysConfig</a> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.SysConfig(file, disk = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read.SysConfig_+3A_file">file</code></td>
<td>
<p>The file name of a system-configuration file to be read.
Can also be a connection that allows reading binary data.</p>
</td></tr>
<tr><td><code id="read.SysConfig_+3A_disk">disk</code></td>
<td>
<p>A virtual Commodore Amiga disk from which the <code>file</code> should be
read. This should be an <code><a href="adfExplorer.html#topic+amigaDisk-class">amigaDisk()</a></code> object. Using
this argument requires the adfExplorer package.
When set to <code>NULL</code>, this argument is ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Amiga OS 1.x stored system preferences in a binary system-configuration file. This
function returns the file in a comprehensive format (a <a href="#topic+SysConfig">SysConfig</a> object).
</p>


<h3>Value</h3>

<p>Returns an S3 <a href="#topic+SysConfig">SysConfig</a> class object based on the file that is read.
</p>


<h3>Author(s)</h3>

<p>Pepijn de Vries
</p>


<h3>See Also</h3>

<p>Other SysConfig.operations: 
<code><a href="#topic+SysConfig">SysConfig</a></code>,
<code><a href="#topic+rawToSysConfig">rawToSysConfig</a>()</code>,
<code><a href="#topic+simpleSysConfig">simpleSysConfig</a>()</code>,
<code><a href="#topic+write.SysConfig">write.SysConfig</a>()</code>
</p>
<p>Other io.operations: 
<code><a href="#topic+read.AmigaBasicBMAP">read.AmigaBasicBMAP</a>()</code>,
<code><a href="#topic+read.AmigaBasicShape">read.AmigaBasicShape</a>()</code>,
<code><a href="#topic+read.AmigaBasic">read.AmigaBasic</a>()</code>,
<code><a href="#topic+read.AmigaBitmapFontSet">read.AmigaBitmapFontSet</a>()</code>,
<code><a href="#topic+read.AmigaBitmapFont">read.AmigaBitmapFont</a>()</code>,
<code><a href="#topic+read.AmigaIcon">read.AmigaIcon</a>()</code>,
<code><a href="#topic+read.iff">read.iff</a>()</code>,
<code><a href="#topic+write.AmigaBasicShape">write.AmigaBasicShape</a>()</code>,
<code><a href="#topic+write.AmigaBasic">write.AmigaBasic</a>()</code>,
<code><a href="#topic+write.AmigaBitmapFont">write.AmigaBitmapFont</a>()</code>,
<code><a href="#topic+write.AmigaIcon">write.AmigaIcon</a>()</code>,
<code><a href="#topic+write.SysConfig">write.SysConfig</a>()</code>,
<code><a href="#topic+write.iff">write.iff</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## Put a simple SysConfig object into the tempdir:
write.SysConfig(simpleSysConfig(), file.path(tempdir(), "system-configuration"))

## Now read the same file:
sc &lt;- read.SysConfig(file.path(tempdir(), "system-configuration"))

## and plot it
plot(sc)

## End(Not run)
</code></pre>

<hr>
<h2 id='simpleAmigaIcon'>Create simple AmigaIcon objects</h2><span id='topic+simpleAmigaIcon'></span>

<h3>Description</h3>

<p>Graphical representation of files and directories (icons) are stored as
separate files (with the .info extension) on the Amiga. This function writes
<code><a href="#topic+AmigaIcon">AmigaIcon()</a></code> class objects to such files.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simpleAmigaIcon(
  version = c("OS1.x", "OS2.x"),
  type = c("WBDISK", "WBDRAWER", "WBTOOL", "WBPROJECT", "WBGARBAGE", "WBDEVICE",
    "WBKICK", "WBAPPICON"),
  two.images = TRUE,
  back.fill = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simpleAmigaIcon_+3A_version">version</code></td>
<td>
<p>A <code>character</code> string indicating the Amiga OS version
with which the icon should be compatible. &quot;<code>OS2.x</code>&quot; indicates \&gt;=OS2.0
and &quot;<code>OS1.x</code>&quot; indicates &lt;OS2.0.</p>
</td></tr>
<tr><td><code id="simpleAmigaIcon_+3A_type">type</code></td>
<td>
<p>A <code>character</code> string indicating the type of object (file, disk, directory, etc.)
the icon should represent. See the &lsquo;Usage&rsquo; section for all posible options.</p>
</td></tr>
<tr><td><code id="simpleAmigaIcon_+3A_two.images">two.images</code></td>
<td>
<p>A single <code>logical</code> value, indicating whether
the selected icon is depicted as a second image (in which case the
icon contains two images). The default value is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="simpleAmigaIcon_+3A_back.fill">back.fill</code></td>
<td>
<p>A single <code>logical</code> value, indicating whether
the selected image of the icon should use the <code style="white-space: pre;">&#8288;back fill' mode (default). If set to &#8288;</code>FALSE<code style="white-space: pre;">&#8288; &#8288;</code>complement' mode is used. Note that
back fill is not compatible when the icon holds two images. In the
<code style="white-space: pre;">&#8288;complement' mode, the image colours are inverted when selected. In the &#8288;</code>back fill' exterior first colour is not inverted.</p>
</td></tr>
<tr><td><code id="simpleAmigaIcon_+3A_...">...</code></td>
<td>
<p>Reserved for additional arguments. Currently ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function creates basic <code><a href="#topic+AmigaIcon">AmigaIcon()</a></code> objects which
can be modified afterwards. It uses simple generic images to represent
different types of files or directories.
</p>


<h3>Value</h3>

<p>Returns a simple S3 object of class <code><a href="#topic+AmigaIcon">AmigaIcon()</a></code>.
</p>


<h3>Author(s)</h3>

<p>Pepijn de Vries
</p>


<h3>See Also</h3>

<p>Other AmigaIcon.operations: 
<code><a href="#topic+AmigaIcon">AmigaIcon</a></code>,
<code><a href="#topic+rawToAmigaIcon">rawToAmigaIcon</a>()</code>,
<code><a href="#topic+read.AmigaIcon">read.AmigaIcon</a>()</code>,
<code><a href="#topic+write.AmigaIcon">write.AmigaIcon</a>()</code>
</p>
<p>Other raw.operations: 
<code><a href="#topic+as.AmigaBasic">as.AmigaBasic</a>()</code>,
<code><a href="#topic+as.raw.AmigaBasic">as.raw.AmigaBasic</a>()</code>,
<code><a href="#topic+colourToAmigaRaw">colourToAmigaRaw</a>()</code>,
<code><a href="#topic+packBitmap">packBitmap</a>()</code>,
<code><a href="#topic+rawToAmigaBasicBMAP">rawToAmigaBasicBMAP</a>()</code>,
<code><a href="#topic+rawToAmigaBasicShape">rawToAmigaBasicShape</a>()</code>,
<code><a href="#topic+rawToAmigaBasic">rawToAmigaBasic</a>()</code>,
<code><a href="#topic+rawToAmigaBitmapFontSet">rawToAmigaBitmapFontSet</a>()</code>,
<code><a href="#topic+rawToAmigaBitmapFont">rawToAmigaBitmapFont</a>()</code>,
<code><a href="#topic+rawToAmigaIcon">rawToAmigaIcon</a>()</code>,
<code><a href="#topic+rawToHWSprite">rawToHWSprite</a>()</code>,
<code><a href="#topic+rawToIFFChunk">rawToIFFChunk</a>()</code>,
<code><a href="#topic+rawToSysConfig">rawToSysConfig</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## Create an AmigaIcon object using the default arguments:
icon &lt;- simpleAmigaIcon()

## End(Not run)
</code></pre>

<hr>
<h2 id='simpleSysConfig'>Function to generate a simple Amiga system-configuration representation</h2><span id='topic+simpleSysConfig'></span>

<h3>Description</h3>

<p><a href="#topic+SysConfig">SysConfig</a> objects are comprehensive representations of binary Amiga
system-configuration files. Use this function to create a simple <a href="#topic+SysConfig">SysConfig</a> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simpleSysConfig(options)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simpleSysConfig_+3A_options">options</code></td>
<td>
<p>A named <code>list</code> with elements of the target
<code><a href="#topic+SysConfig">SysConfig()</a></code> object that need to be modified.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Amiga used the system-configuration file to store certain system preferences
in a binary file. In the AmigaFFH package such files can be represented by the more
comprehensive <a href="#topic+SysConfig">SysConfig</a> class object. Use this function to create such an object
with basic settings (which can be modified).
</p>


<h3>Value</h3>

<p>Returns a comprehensive representation of a system-configuration file in the
for of a <a href="#topic+SysConfig">SysConfig</a> class object.
</p>


<h3>Author(s)</h3>

<p>Pepijn de Vries
</p>


<h3>See Also</h3>

<p>Other SysConfig.operations: 
<code><a href="#topic+SysConfig">SysConfig</a></code>,
<code><a href="#topic+rawToSysConfig">rawToSysConfig</a>()</code>,
<code><a href="#topic+read.SysConfig">read.SysConfig</a>()</code>,
<code><a href="#topic+write.SysConfig">write.SysConfig</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## Create a simple system-configuration (S3 SysConfigClass)
sc &lt;- simpleSysConfig()

## And modify it as you wish.
## in this case change the setting for the printer
## from the parallel port to the serial port:
sc$PrinterPort &lt;- factor("SERIAL_PRINTER", levels(sc$PrinterPort))

## It is also to provide modifications to the configuration
## via the 'options' argument:
sc &lt;- simpleSysConfig(options = list(FontHeight = 9))

## End(Not run)
</code></pre>

<hr>
<h2 id='SysConfig'>The S3 SysConfig class</h2><span id='topic+SysConfig'></span>

<h3>Description</h3>

<p>A comprehensive representation of an Amiga system-configuration file.
</p>


<h3>Details</h3>

<p>The system-configuration file is a binary file stored in the &lsquo;devs&rsquo; folder
of the root of a bootable Amiga DOS device, containing system preferences.
It was used in Amiga OS 1.x. Although it could be used in later versions, it was
gradually phased out and some settings may not be usable in the later versions.
See references below for more details.
</p>
<p>Definitions of the system-configuration have file been revised at some points.
Revisions are minor and usually targeted at backward compatibility. Here
revision V38.2 (released on 16 September 1992) is implemented, which is the
latest documented version.
</p>
<p>The sytem-configuration file contains settings for the serial and parallel
port and the printer. It also contains some settings for the &lsquo;workbench&rsquo;
which was the Amiga equivalent of what is now mostly known as the computers desktop.
Colours for the workbench and the shape of the mouse pointer are also stored
in this file. Settings for the mouse and basic screen resolution are also part
of the file.
</p>
<p>The SysConfig object is a comprehensive representation of the binary
system-configuration file. It is a a <code>list</code> where the elements have identical
names as listed in the documents provided the references. The names are usually
self-explanatory, but the referred documents can also be
consulted to obtain more detailed information with respect to each of
these elements. The mouse pointer is included as a <code><a href="#topic+hardwareSprite">hardwareSprite()</a></code> object
in the list. The pointer image can be replaced by a different <code><a href="#topic+hardwareSprite">hardwareSprite()</a></code>,
but make sure it has an height of 16 pixels.
</p>
<p>It is possible to change the values of the list, but not all values may be valid.
Note that they will not be fully checked for validity. Invalid values may result in errors
when writing to a binary file using <code><a href="#topic+write.SysConfig">write.SysConfig()</a></code>, or may simply not
work properly on an Amiga or in an emulator.
</p>
<p>Use <code><a href="#topic+simpleSysConfig">simpleSysConfig()</a></code> for creating a simple SysConfig object which can
be modified. Use <code><a href="#topic+read.SysConfig">read.SysConfig()</a></code> to read, and <code><a href="#topic+write.SysConfig">write.SysConfig()</a></code>
to write system-configuration files. With <code><a href="#topic+rawToSysConfig">rawToSysConfig()</a></code> and
<code><a href="#topic+as.raw">as.raw()</a></code> SysConfig can be coerced back and forth from and to
its raw (binary) form.
</p>


<h3>Author(s)</h3>

<p>Pepijn de Vries
</p>


<h3>References</h3>

<p><a href="https://wiki.amigaos.net/wiki/Preferences#Preferences_in_1.3_and_Older_Versions_of_the_OS">https://wiki.amigaos.net/wiki/Preferences#Preferences_in_1.3_and_Older_Versions_of_the_OS</a>
<a href="http://amigadev.elowar.com/read/ADCD_2.1/Includes_and_Autodocs_2._guide/node00D5.html">http://amigadev.elowar.com/read/ADCD_2.1/Includes_and_Autodocs_2._guide/node00D5.html</a>
<a href="http://amigadev.elowar.com/read/ADCD_2.1/Includes_and_Autodocs_3._guide/node063B.html">http://amigadev.elowar.com/read/ADCD_2.1/Includes_and_Autodocs_3._guide/node063B.html</a>
</p>


<h3>See Also</h3>

<p>Other SysConfig.operations: 
<code><a href="#topic+rawToSysConfig">rawToSysConfig</a>()</code>,
<code><a href="#topic+read.SysConfig">read.SysConfig</a>()</code>,
<code><a href="#topic+simpleSysConfig">simpleSysConfig</a>()</code>,
<code><a href="#topic+write.SysConfig">write.SysConfig</a>()</code>
</p>

<hr>
<h2 id='timeval'>Get an Amiga timeval struct value from raw data</h2><span id='topic+timeval'></span>

<h3>Description</h3>

<p>Some Amiga applications use a timeval struct (see references) to represent a
time span in seconds. This function coerces raw data to such a numeric time span.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>timeval(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="timeval_+3A_x">x</code></td>
<td>
<p>a <code>vector</code> of <code>raw</code> data that need to be converted into
Amiga timeval structs.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Timeval is a structure (struct) as specified in device/timer.h on the Amiga (see
references). It represents a timespan in seconds. This function retrieves the
numeric value from <code>raw</code> data. Amongst others, the timeval struct was used
in the system-configuration file (see <a href="#topic+SysConfig">SysConfig</a>) to specify key repeat speed,
key repeat delay and mouse double click speed. Use <code>as.raw</code> for the inverse
of this function and get the original raw data.
</p>


<h3>Value</h3>

<p>Returns a <code>numeric</code> <code>vector</code> of a timespan in seconds. It is
represented as an S3 AmigaTimeVal class.
</p>


<h3>Author(s)</h3>

<p>Pepijn de Vries
</p>


<h3>References</h3>

<p><a href="http://amigadev.elowar.com/read/ADCD_2.1/Includes_and_Autodocs_2._guide/node0053.html">http://amigadev.elowar.com/read/ADCD_2.1/Includes_and_Autodocs_2._guide/node0053.html</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## First four raw values represent seconds, the latter four microseconds:
temp &lt;- timeval(as.raw(c(0, 0, 0, 1, 0, 0, 0, 1)))
print(temp)

## You can use 'as.raw' to get the original raw data again:
as.raw(temp)
</code></pre>

<hr>
<h2 id='WaveToIFF'>Convert WaveMC objects into an Interchange File Format object</h2><span id='topic+WaveToIFF'></span>

<h3>Description</h3>

<p>Convert <code><a href="tuneR.html#topic+WaveMC">tuneR::WaveMC()</a></code> objects (or objects that can be coerced to
<code>WaveMC</code> objects) into an <code><a href="#topic+IFFChunk-class">IFFChunk-class()</a></code> object which
can be stored as a valid Iterchange File Format (<code><a href="#topic+write.iff">write.iff()</a></code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>WaveToIFF(
  x,
  loop.start = NA,
  octaves = 1,
  compress = c("sCmpNone", "sCmpFibDelta"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="WaveToIFF_+3A_x">x</code></td>
<td>
<p>A <code><a href="tuneR.html#topic+WaveMC">tuneR::WaveMC()</a></code> object that needs to be converted into an <code><a href="#topic+IFFChunk">IFFChunk()</a></code> object. <code>x</code>
can also be any other class object that can be coerced into a <code><a href="tuneR.html#topic+WaveMC">tuneR::WaveMC()</a></code> object. <code><a href="tuneR.html#topic+Wave">tuneR::Wave()</a></code>
and <code><a href="ProTrackR.html#topic+PTSample-class">PTSample()</a></code> objects are therefore also allowed.</p>
</td></tr>
<tr><td><code id="WaveToIFF_+3A_loop.start">loop.start</code></td>
<td>
<p>If the sample should be looped from a specific position to the
end of the sample, this argument specifies the starting position in samples (with
a base of 0) for looping. <code>loop.start</code> therefore should be a whole non-negative
number. When set to <code>NA</code> or negative values, the sample will not be looped.</p>
</td></tr>
<tr><td><code id="WaveToIFF_+3A_octaves">octaves</code></td>
<td>
<p>A whole positive <code>numeric</code> value indicating the number of octaves
that should be stored in the resulting IFF chunk. The original wave will be resampled
for each value larger than 1. Each subsequent octave will contain precisely twice
as many samples as the previous octave.</p>
</td></tr>
<tr><td><code id="WaveToIFF_+3A_compress">compress</code></td>
<td>
<p>A <code>character</code> string indicating whether compression should be applied to the waveform. &quot;<code>sCmpNone</code>&quot;
(default) applies no compression, &quot;<code>sCmpFibDelta</code>&quot; applies the lossy <code><a href="#topic+deltaFibonacciCompress">deltaFibonacciCompress()</a></code>ion.</p>
</td></tr>
<tr><td><code id="WaveToIFF_+3A_...">...</code></td>
<td>
<p>Currently ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code><a href="tuneR.html#topic+WaveMC">tuneR::WaveMC()</a></code> objects can be read from contemporary file containers
with <code><a href="tuneR.html#topic+readWave">tuneR::readWave()</a></code> or <code><a href="tuneR.html#topic+readMP3">tuneR::readMP3()</a></code>. With this
function such objects can be converted into an <code><a href="#topic+IFFChunk-class">IFFChunk-class()</a></code> object
which can be stored conform the Interchange File Format (<code><a href="#topic+write.iff">write.iff()</a></code>).
</p>
<p>When <code>x</code> is not a pcm formatted 8-bit sample, <code>x</code> will first be
normalised and scaled to a pcm-formatted 8-bit sample using
<code><a href="tuneR.html#topic+normalize">tuneR::normalize()</a></code>. If you don't like the result you need to convert
the sample to 8-bit pcm yourself before calling this function.
</p>


<h3>Value</h3>

<p>Returns an <code><a href="#topic+IFFChunk-class">IFFChunk-class()</a></code> object with a FORM container that
contains an 8SVX waveform based on <code>x</code>.
</p>


<h3>Author(s)</h3>

<p>Pepijn de Vries
</p>


<h3>References</h3>

<p><a href="https://en.wikipedia.org/wiki/8SVX">https://en.wikipedia.org/wiki/8SVX</a>
</p>


<h3>See Also</h3>

<p>Other iff.operations: 
<code><a href="#topic+IFFChunk-class">IFFChunk-class</a></code>,
<code><a href="#topic+as.raster.AmigaBasicShape">as.raster.AmigaBasicShape</a>()</code>,
<code><a href="#topic+getIFFChunk">getIFFChunk</a>()</code>,
<code><a href="#topic+interpretIFFChunk">interpretIFFChunk</a>()</code>,
<code><a href="#topic+rasterToIFF">rasterToIFF</a>()</code>,
<code><a href="#topic+rawToIFFChunk">rawToIFFChunk</a>()</code>,
<code><a href="#topic+read.iff">read.iff</a>()</code>,
<code><a href="#topic+write.iff">write.iff</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## First get an audio sample from the ProTrackR package
snare.samp &lt;- ProTrackR::PTSample(ProTrackR::mod.intro, 2)

## The sample can easily be converted into an IFFChunk:
snare.iff &lt;- WaveToIFF(snare.samp)

## You could also first convert the sample into a Wave object:
snare.wav &lt;- as(snare.samp, "Wave")

## And then convert into an IFFChunk. The result is the same:
snare.iff &lt;- WaveToIFF(snare.wav)

## You could also use a sine wave as input (although you will get some warnings).
## This will work because the vector of numeric data can be coerced to
## a WaveMC object
sine.iff &lt;- WaveToIFF(sin((0:2000)/20))

## End(Not run)
</code></pre>

<hr>
<h2 id='write.AmigaBasic'>Write an AmigaBasic object to a file</h2><span id='topic+write.AmigaBasic'></span>

<h3>Description</h3>

<p>Write an <code><a href="#topic+AmigaBasic">AmigaBasic()</a></code> class object to a file in its binary format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write.AmigaBasic(x, file, disk = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="write.AmigaBasic_+3A_x">x</code></td>
<td>
<p>The <code><a href="#topic+AmigaBasic">AmigaBasic()</a></code> class object that needs to be
stored.</p>
</td></tr>
<tr><td><code id="write.AmigaBasic_+3A_file">file</code></td>
<td>
<p>A <code>character</code> string specifying the file location
to which <code>x</code> (an <code><a href="#topic+AmigaBasic">AmigaBasic()</a></code> object) needs to be written.</p>
</td></tr>
<tr><td><code id="write.AmigaBasic_+3A_disk">disk</code></td>
<td>
<p>A virtual Commodore Amiga disk to which the <code>file</code> should be
written. This should be an <code><a href="adfExplorer.html#topic+amigaDisk-class">amigaDisk()</a></code> object. Using
this argument requires the adfExplorer package.
When set to <code>NULL</code>, this argument is ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function encodes the Amiga Basic code in its binary format
(using <code><a href="#topic+as.raw">as.raw()</a></code>) and writes it to a file. The file
can also be stored onto a virtual Amiga disk
(<code><a href="adfExplorer.html#topic+amigaDisk-class">amigaDisk()</a></code>).
</p>


<h3>Value</h3>

<p>Invisibly returns the result of the call of <code>close</code> to the
file connection. Or, when <code>disk</code> is specified, a copy of
<code>disk</code> is returned to which the file(s) is/are written.
</p>


<h3>Author(s)</h3>

<p>Pepijn de Vries
</p>


<h3>See Also</h3>

<p>Other AmigaBasic.operations: 
<code><a href="#topic+AmigaBasic.reserved">AmigaBasic.reserved</a>()</code>,
<code><a href="#topic+AmigaBasicBMAP">AmigaBasicBMAP</a></code>,
<code><a href="#topic+AmigaBasic">AmigaBasic</a></code>,
<code><a href="#topic++5B.AmigaBasic">[.AmigaBasic</a>()</code>,
<code><a href="#topic+as.AmigaBasicBMAP">as.AmigaBasicBMAP</a>()</code>,
<code><a href="#topic+as.AmigaBasic">as.AmigaBasic</a>()</code>,
<code><a href="#topic+as.character">as.character</a>()</code>,
<code><a href="#topic+check.names.AmigaBasic">check.names.AmigaBasic</a>()</code>,
<code><a href="#topic+names.AmigaBasic">names.AmigaBasic</a>()</code>,
<code><a href="#topic+rawToAmigaBasicBMAP">rawToAmigaBasicBMAP</a>()</code>,
<code><a href="#topic+rawToAmigaBasic">rawToAmigaBasic</a>()</code>,
<code><a href="#topic+read.AmigaBasicBMAP">read.AmigaBasicBMAP</a>()</code>,
<code><a href="#topic+read.AmigaBasic">read.AmigaBasic</a>()</code>
</p>
<p>Other io.operations: 
<code><a href="#topic+read.AmigaBasicBMAP">read.AmigaBasicBMAP</a>()</code>,
<code><a href="#topic+read.AmigaBasicShape">read.AmigaBasicShape</a>()</code>,
<code><a href="#topic+read.AmigaBasic">read.AmigaBasic</a>()</code>,
<code><a href="#topic+read.AmigaBitmapFontSet">read.AmigaBitmapFontSet</a>()</code>,
<code><a href="#topic+read.AmigaBitmapFont">read.AmigaBitmapFont</a>()</code>,
<code><a href="#topic+read.AmigaIcon">read.AmigaIcon</a>()</code>,
<code><a href="#topic+read.SysConfig">read.SysConfig</a>()</code>,
<code><a href="#topic+read.iff">read.iff</a>()</code>,
<code><a href="#topic+write.AmigaBasicShape">write.AmigaBasicShape</a>()</code>,
<code><a href="#topic+write.AmigaBitmapFont">write.AmigaBitmapFont</a>()</code>,
<code><a href="#topic+write.AmigaIcon">write.AmigaIcon</a>()</code>,
<code><a href="#topic+write.SysConfig">write.SysConfig</a>()</code>,
<code><a href="#topic+write.iff">write.iff</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## First create an AmigaBasic object:
bas &lt;- as.AmigaBasic("PRINT \"hello world!\"")

## write to tempdir:
write.AmigaBasic(bas, file.path(tempdir(), "helloworld.bas"))

## End(Not run)
</code></pre>

<hr>
<h2 id='write.AmigaBasicShape'>Write an AmigaBasicShape object to a file</h2><span id='topic+write.AmigaBasicShape'></span>

<h3>Description</h3>

<p>Write an <code><a href="#topic+AmigaBasicShape">AmigaBasicShape()</a></code> class object to a file in its binary format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write.AmigaBasicShape(x, file, disk = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="write.AmigaBasicShape_+3A_x">x</code></td>
<td>
<p>The <code><a href="#topic+AmigaBasicShape">AmigaBasicShape()</a></code> class object that needs to be
stored.</p>
</td></tr>
<tr><td><code id="write.AmigaBasicShape_+3A_file">file</code></td>
<td>
<p>A <code>character</code> string specifying the file location
to which <code>x</code> (an <code><a href="#topic+AmigaBasicShape">AmigaBasicShape()</a></code> object) needs to be written.</p>
</td></tr>
<tr><td><code id="write.AmigaBasicShape_+3A_disk">disk</code></td>
<td>
<p>A virtual Commodore Amiga disk to which the <code>file</code> should be
written. This should be an <code><a href="adfExplorer.html#topic+amigaDisk-class">amigaDisk()</a></code> object. Using
this argument requires the adfExplorer package.
When set to <code>NULL</code>, this argument is ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function coerces the Amiga Basic Shape into its binary format
(using <code><a href="#topic+as.raw">as.raw()</a></code>) and writes it to a file. The file
can also be stored onto a virtual Amiga disk
(<code><a href="adfExplorer.html#topic+amigaDisk-class">amigaDisk()</a></code>).
</p>


<h3>Value</h3>

<p>Invisibly returns the result of the call of <code>close</code> to the
file connection. Or, when <code>disk</code> is specified, a copy of
<code>disk</code> is returned to which the file(s) is/are written.
</p>


<h3>Author(s)</h3>

<p>Pepijn de Vries
</p>


<h3>See Also</h3>

<p>Other AmigaBasicShape.operations: 
<code><a href="#topic+AmigaBasicShape">AmigaBasicShape</a></code>,
<code><a href="#topic+rasterToAmigaBasicShape">rasterToAmigaBasicShape</a>()</code>,
<code><a href="#topic+read.AmigaBasicShape">read.AmigaBasicShape</a>()</code>
</p>
<p>Other io.operations: 
<code><a href="#topic+read.AmigaBasicBMAP">read.AmigaBasicBMAP</a>()</code>,
<code><a href="#topic+read.AmigaBasicShape">read.AmigaBasicShape</a>()</code>,
<code><a href="#topic+read.AmigaBasic">read.AmigaBasic</a>()</code>,
<code><a href="#topic+read.AmigaBitmapFontSet">read.AmigaBitmapFontSet</a>()</code>,
<code><a href="#topic+read.AmigaBitmapFont">read.AmigaBitmapFont</a>()</code>,
<code><a href="#topic+read.AmigaIcon">read.AmigaIcon</a>()</code>,
<code><a href="#topic+read.SysConfig">read.SysConfig</a>()</code>,
<code><a href="#topic+read.iff">read.iff</a>()</code>,
<code><a href="#topic+write.AmigaBasic">write.AmigaBasic</a>()</code>,
<code><a href="#topic+write.AmigaBitmapFont">write.AmigaBitmapFont</a>()</code>,
<code><a href="#topic+write.AmigaIcon">write.AmigaIcon</a>()</code>,
<code><a href="#topic+write.SysConfig">write.SysConfig</a>()</code>,
<code><a href="#topic+write.iff">write.iff</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
filename &lt;- system.file("ball.shp", package = "AmigaFFH")
ball     &lt;- read.AmigaBasicShape(filename)
write.AmigaBasicShape(ball, file.path(tempdir(), "ball.shp"))

## End(Not run)
</code></pre>

<hr>
<h2 id='write.AmigaBitmapFont'>Write an AmigaBitmapFont(set) file</h2><span id='topic+write.AmigaBitmapFont'></span><span id='topic+write.AmigaBitmapFontSet'></span>

<h3>Description</h3>

<p>Functions to write <code><a href="#topic+AmigaBitmapFont">AmigaBitmapFont()</a></code> and <code><a href="#topic+AmigaBitmapFontSet">AmigaBitmapFontSet()</a></code>
class objects to files.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write.AmigaBitmapFont(x, file, disk = NULL)

write.AmigaBitmapFontSet(x, path = getwd(), disk = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="write.AmigaBitmapFont_+3A_x">x</code></td>
<td>
<p>Respectively an <code><a href="#topic+AmigaBitmapFont">AmigaBitmapFont()</a></code> or a
<code><a href="#topic+AmigaBitmapFontSet">AmigaBitmapFontSet()</a></code> object depending on which of the
write-functions is called. This is the object that will be written
to the specified file.</p>
</td></tr>
<tr><td><code id="write.AmigaBitmapFont_+3A_file">file</code></td>
<td>
<p>A <code>character</code> string specifying the file location
to which <code>x</code> (an <code><a href="#topic+AmigaBitmapFont">AmigaBitmapFont()</a></code> object) needs to be written.
It is common practice on the Amiga to use the font height in pixels as
file name.</p>
</td></tr>
<tr><td><code id="write.AmigaBitmapFont_+3A_disk">disk</code></td>
<td>
<p>A virtual Commodore Amiga disk to which the <code>file</code> should be
written. This should be an <code><a href="adfExplorer.html#topic+amigaDisk-class">amigaDisk()</a></code> object. Using
this argument requires the adfExplorer package.
When set to <code>NULL</code>, this argument is ignored.</p>
</td></tr>
<tr><td><code id="write.AmigaBitmapFont_+3A_path">path</code></td>
<td>
<p>A <code>character</code> string specifying the path where
<code>x</code> (an <code><a href="#topic+AmigaBitmapFontSet">AmigaBitmapFontSet()</a></code> object) needs to be stored.
The filename for the font set will be extracted from <code>x</code> using
<code><a href="#topic+fontName">fontName()</a></code> followed by the *.font extension. A subdirectory
will be created with the same name (without the extension) if it doesn't
already exists. In this subdirectory all the nested <code><a href="#topic+AmigaBitmapFont">AmigaBitmapFont()</a></code>
objects are stored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code><a href="#topic+AmigaBitmapFontSet">AmigaBitmapFontSet()</a></code> class objects are written to a *.font
file. The filename used for this purpose is obtained from the object
itself using <code><a href="#topic+fontName">fontName()</a></code>. In addition, a subdirectory is
created automatically (when it doesn't already exist)
to which al the separate bitmap images for each font height are written
to individual files.
</p>
<p><code><a href="#topic+AmigaBitmapFont">AmigaBitmapFont()</a></code> class objects can also be written to a
file. In order to use it on a Commodore Amiga or emulator, it is better
to embed the font bitmap in a font set (using <code><a href="#topic+c">c()</a></code>)
and write the set to corresponding files.
</p>


<h3>Value</h3>

<p>Invisibly returns the result of the call of <code>close</code> to the
file connection. Or, when <code>disk</code> is specified, a copy of
<code>disk</code> is returned to which the file(s) is/are written.
</p>


<h3>Author(s)</h3>

<p>Pepijn de Vries
</p>


<h3>See Also</h3>

<p>Other AmigaBitmapFont.operations: 
<code><a href="#topic+AmigaBitmapFont">AmigaBitmapFont</a></code>,
<code><a href="#topic+availableFontSizes">availableFontSizes</a>()</code>,
<code><a href="#topic+c">c</a>()</code>,
<code><a href="#topic+fontName">fontName</a>()</code>,
<code><a href="#topic+font_example">font_example</a></code>,
<code><a href="#topic+getAmigaBitmapFont">getAmigaBitmapFont</a>()</code>,
<code><a href="#topic+rasterToAmigaBitmapFont">rasterToAmigaBitmapFont</a>()</code>,
<code><a href="#topic+rawToAmigaBitmapFontSet">rawToAmigaBitmapFontSet</a>()</code>,
<code><a href="#topic+rawToAmigaBitmapFont">rawToAmigaBitmapFont</a>()</code>,
<code><a href="#topic+read.AmigaBitmapFontSet">read.AmigaBitmapFontSet</a>()</code>,
<code><a href="#topic+read.AmigaBitmapFont">read.AmigaBitmapFont</a>()</code>
</p>
<p>Other io.operations: 
<code><a href="#topic+read.AmigaBasicBMAP">read.AmigaBasicBMAP</a>()</code>,
<code><a href="#topic+read.AmigaBasicShape">read.AmigaBasicShape</a>()</code>,
<code><a href="#topic+read.AmigaBasic">read.AmigaBasic</a>()</code>,
<code><a href="#topic+read.AmigaBitmapFontSet">read.AmigaBitmapFontSet</a>()</code>,
<code><a href="#topic+read.AmigaBitmapFont">read.AmigaBitmapFont</a>()</code>,
<code><a href="#topic+read.AmigaIcon">read.AmigaIcon</a>()</code>,
<code><a href="#topic+read.SysConfig">read.SysConfig</a>()</code>,
<code><a href="#topic+read.iff">read.iff</a>()</code>,
<code><a href="#topic+write.AmigaBasicShape">write.AmigaBasicShape</a>()</code>,
<code><a href="#topic+write.AmigaBasic">write.AmigaBasic</a>()</code>,
<code><a href="#topic+write.AmigaIcon">write.AmigaIcon</a>()</code>,
<code><a href="#topic+write.SysConfig">write.SysConfig</a>()</code>,
<code><a href="#topic+write.iff">write.iff</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## obtain a bitmap font set:
data(font_example)

## write the font set to their files. The file name
## is extracted from the font object, so you only have
## to provide the path:
write.AmigaBitmapFont(font_example, temp.dir())

## extract a font bitmap:
font &lt;- getAmigaBitmapFont(font_example, 9)

## and write it to the temp dir:
write.AmigaBitmapFont(font, file.path(temp.dir(), "9"))

## The following examples require the 'adfExplorer' package:
font.disk &lt;- adfExplorer::blank.amigaDOSDisk("font.disk")
font.disk &lt;- adfExplorer::dir.create.adf(font.disk, "FONTS")
font.disk &lt;- write.AmigaBitmapFontSet(font_example, "DF0:FONTS", font.disk)

## End(Not run)
</code></pre>

<hr>
<h2 id='write.AmigaIcon'>Write an Amiga Workbench icon (info) file</h2><span id='topic+write.AmigaIcon'></span>

<h3>Description</h3>

<p>Graphical representation of files and directories (icons) are stored as
separate files (with the .info extension) on the Amiga. This function writes
<code><a href="#topic+AmigaIcon">AmigaIcon()</a></code> class objects to such files.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write.AmigaIcon(x, file, disk = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="write.AmigaIcon_+3A_x">x</code></td>
<td>
<p>An <code><a href="#topic+AmigaIcon">AmigaIcon()</a></code> class object.</p>
</td></tr>
<tr><td><code id="write.AmigaIcon_+3A_file">file</code></td>
<td>
<p>A <code>character</code> string representing the file name to which the
icon data should be written.</p>
</td></tr>
<tr><td><code id="write.AmigaIcon_+3A_disk">disk</code></td>
<td>
<p>A virtual Commodore Amiga disk to which the <code>file</code> should be
written. This should be an <code><a href="adfExplorer.html#topic+amigaDisk-class">amigaDisk()</a></code> object. Using
this argument requires the adfExplorer package.
When set to <code>NULL</code>, this argument is ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code><a href="#topic+AmigaIcon">AmigaIcon()</a></code> S3 object provides a comprehensive format
for Amiga icons, which are used as a graphical representation of files
and directories on the Amiga. The <code><a href="#topic+AmigaIcon">AmigaIcon()</a></code> is a named
list containing all information of an icon. Use this function to
write this object to a file which can be used on the Commodore Amiga
or emulator.
</p>


<h3>Value</h3>

<p>Returns <code>NULL</code> or an <code>integer</code> status passed on by the
<code><a href="base.html#topic+close">close()</a></code> function, that is used to close the file connection.
It is returned invisibly. Or, when <code>disk</code> is specified, a copy of
<code>disk</code> is returned to which the file is written.
</p>


<h3>Author(s)</h3>

<p>Pepijn de Vries
</p>


<h3>See Also</h3>

<p>Other AmigaIcon.operations: 
<code><a href="#topic+AmigaIcon">AmigaIcon</a></code>,
<code><a href="#topic+rawToAmigaIcon">rawToAmigaIcon</a>()</code>,
<code><a href="#topic+read.AmigaIcon">read.AmigaIcon</a>()</code>,
<code><a href="#topic+simpleAmigaIcon">simpleAmigaIcon</a>()</code>
</p>
<p>Other io.operations: 
<code><a href="#topic+read.AmigaBasicBMAP">read.AmigaBasicBMAP</a>()</code>,
<code><a href="#topic+read.AmigaBasicShape">read.AmigaBasicShape</a>()</code>,
<code><a href="#topic+read.AmigaBasic">read.AmigaBasic</a>()</code>,
<code><a href="#topic+read.AmigaBitmapFontSet">read.AmigaBitmapFontSet</a>()</code>,
<code><a href="#topic+read.AmigaBitmapFont">read.AmigaBitmapFont</a>()</code>,
<code><a href="#topic+read.AmigaIcon">read.AmigaIcon</a>()</code>,
<code><a href="#topic+read.SysConfig">read.SysConfig</a>()</code>,
<code><a href="#topic+read.iff">read.iff</a>()</code>,
<code><a href="#topic+write.AmigaBasicShape">write.AmigaBasicShape</a>()</code>,
<code><a href="#topic+write.AmigaBasic">write.AmigaBasic</a>()</code>,
<code><a href="#topic+write.AmigaBitmapFont">write.AmigaBitmapFont</a>()</code>,
<code><a href="#topic+write.SysConfig">write.SysConfig</a>()</code>,
<code><a href="#topic+write.iff">write.iff</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## create a simple AmigaIcon:
icon &lt;- simpleAmigaIcon()

## write the icon to the temp dir:
write.AmigaIcon(icon, file.path(tempdir(), "icon.info"))

## End(Not run)
</code></pre>

<hr>
<h2 id='write.iff'>Write Interchange File Format (IFF)</h2><span id='topic+write.iff'></span>

<h3>Description</h3>

<p>Write an <code><a href="#topic+IFFChunk">IFFChunk()</a></code> object conform the Interchange File Format (IFF).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write.iff(x, file, disk = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="write.iff_+3A_x">x</code></td>
<td>
<p>An <code><a href="#topic+IFFChunk">IFFChunk()</a></code> object that needs to be written to a file.</p>
</td></tr>
<tr><td><code id="write.iff_+3A_file">file</code></td>
<td>
<p>A filename for the IFF file to which the <code><a href="#topic+IFFChunk">IFFChunk()</a></code> needs
to be saved, or a connection to which the data should be written.</p>
</td></tr>
<tr><td><code id="write.iff_+3A_disk">disk</code></td>
<td>
<p>A virtual Commodore Amiga disk to which the <code>file</code> should be
written. This should be an <code><a href="adfExplorer.html#topic+amigaDisk-class">amigaDisk()</a></code> object. Using
this argument requires the adfExplorer package.
When set to <code>NULL</code>, this argument is ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Writes an <code><a href="#topic+IFFChunk">IFFChunk()</a></code> object (including all nested chunks) to the
specified file. Only the structure of the object needs to be valid, however,
a correctly structured file does not necessarily result in an interpretable file
(see examples).
</p>


<h3>Value</h3>

<p>Returns either <code>NULL</code> or an <code>integer</code> status invisibly as passed
by the <code><a href="base.html#topic+connections">close()</a></code> statement used to close the file connection.
When <code>disk</code> is specified, a copy of <code>disk</code> is returned
to which the file is written.
</p>


<h3>Author(s)</h3>

<p>Pepijn de Vries
</p>


<h3>References</h3>

<p><a href="https://en.wikipedia.org/wiki/Interchange_File_Format">https://en.wikipedia.org/wiki/Interchange_File_Format</a>
</p>


<h3>See Also</h3>

<p>Other io.operations: 
<code><a href="#topic+read.AmigaBasicBMAP">read.AmigaBasicBMAP</a>()</code>,
<code><a href="#topic+read.AmigaBasicShape">read.AmigaBasicShape</a>()</code>,
<code><a href="#topic+read.AmigaBasic">read.AmigaBasic</a>()</code>,
<code><a href="#topic+read.AmigaBitmapFontSet">read.AmigaBitmapFontSet</a>()</code>,
<code><a href="#topic+read.AmigaBitmapFont">read.AmigaBitmapFont</a>()</code>,
<code><a href="#topic+read.AmigaIcon">read.AmigaIcon</a>()</code>,
<code><a href="#topic+read.SysConfig">read.SysConfig</a>()</code>,
<code><a href="#topic+read.iff">read.iff</a>()</code>,
<code><a href="#topic+write.AmigaBasicShape">write.AmigaBasicShape</a>()</code>,
<code><a href="#topic+write.AmigaBasic">write.AmigaBasic</a>()</code>,
<code><a href="#topic+write.AmigaBitmapFont">write.AmigaBitmapFont</a>()</code>,
<code><a href="#topic+write.AmigaIcon">write.AmigaIcon</a>()</code>,
<code><a href="#topic+write.SysConfig">write.SysConfig</a>()</code>
</p>
<p>Other iff.operations: 
<code><a href="#topic+IFFChunk-class">IFFChunk-class</a></code>,
<code><a href="#topic+WaveToIFF">WaveToIFF</a>()</code>,
<code><a href="#topic+as.raster.AmigaBasicShape">as.raster.AmigaBasicShape</a>()</code>,
<code><a href="#topic+getIFFChunk">getIFFChunk</a>()</code>,
<code><a href="#topic+interpretIFFChunk">interpretIFFChunk</a>()</code>,
<code><a href="#topic+rasterToIFF">rasterToIFF</a>()</code>,
<code><a href="#topic+rawToIFFChunk">rawToIFFChunk</a>()</code>,
<code><a href="#topic+read.iff">read.iff</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## read an IFF file as an IFFChunk object:
example.iff &lt;- read.iff(system.file("ilbm8lores.iff", package = "AmigaFFH"))

## This will write the IFF file (in this case a bitmap image)
## to the temp directory:
write.iff(example.iff, file.path(tempdir(), "image.iff"))


## End(Not run)
</code></pre>

<hr>
<h2 id='write.SysConfig'>Write an Amiga system-configuration file</h2><span id='topic+write.SysConfig'></span>

<h3>Description</h3>

<p>Write a <a href="#topic+SysConfig">SysConfig</a> class object to an Amiga binary system-configuration file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write.SysConfig(x, file, disk = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="write.SysConfig_+3A_x">x</code></td>
<td>
<p>An S3 <a href="#topic+SysConfig">SysConfig</a> class object.</p>
</td></tr>
<tr><td><code id="write.SysConfig_+3A_file">file</code></td>
<td>
<p>A file name to which the binary file should be written.</p>
</td></tr>
<tr><td><code id="write.SysConfig_+3A_disk">disk</code></td>
<td>
<p>A virtual Commodore Amiga disk to which the <code>file</code> should be
written. This should be an <code><a href="adfExplorer.html#topic+amigaDisk-class">amigaDisk()</a></code> object. Using
this argument requires the adfExplorer package.
When set to <code>NULL</code>, this argument is ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Amiga OS 1.x stored system preferences in a binary system-configuration file. This
function writes a <a href="#topic+SysConfig">SysConfig</a> class object as such a binary file. This file
can be used on an Amiga or in an emulator.
</p>


<h3>Value</h3>

<p>Returns <code>NULL</code> or an <code>integer</code> status passed on by the
<code><a href="base.html#topic+close">close()</a></code> function, that is used to close the file connection.
It is returned invisibly. Or, when <code>disk</code> is specified, a copy of
<code>disk</code> is returned to which the file is written.
</p>


<h3>Author(s)</h3>

<p>Pepijn de Vries
</p>


<h3>See Also</h3>

<p>Other SysConfig.operations: 
<code><a href="#topic+SysConfig">SysConfig</a></code>,
<code><a href="#topic+rawToSysConfig">rawToSysConfig</a>()</code>,
<code><a href="#topic+read.SysConfig">read.SysConfig</a>()</code>,
<code><a href="#topic+simpleSysConfig">simpleSysConfig</a>()</code>
</p>
<p>Other io.operations: 
<code><a href="#topic+read.AmigaBasicBMAP">read.AmigaBasicBMAP</a>()</code>,
<code><a href="#topic+read.AmigaBasicShape">read.AmigaBasicShape</a>()</code>,
<code><a href="#topic+read.AmigaBasic">read.AmigaBasic</a>()</code>,
<code><a href="#topic+read.AmigaBitmapFontSet">read.AmigaBitmapFontSet</a>()</code>,
<code><a href="#topic+read.AmigaBitmapFont">read.AmigaBitmapFont</a>()</code>,
<code><a href="#topic+read.AmigaIcon">read.AmigaIcon</a>()</code>,
<code><a href="#topic+read.SysConfig">read.SysConfig</a>()</code>,
<code><a href="#topic+read.iff">read.iff</a>()</code>,
<code><a href="#topic+write.AmigaBasicShape">write.AmigaBasicShape</a>()</code>,
<code><a href="#topic+write.AmigaBasic">write.AmigaBasic</a>()</code>,
<code><a href="#topic+write.AmigaBitmapFont">write.AmigaBitmapFont</a>()</code>,
<code><a href="#topic+write.AmigaIcon">write.AmigaIcon</a>()</code>,
<code><a href="#topic+write.iff">write.iff</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## First generate a simple SysConfig object to write to a file:
sc &lt;- simpleSysConfig()

## And write to the tempdir:
write.SysConfig(sc, file.path(tempdir(), "system-configuration"))

## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
