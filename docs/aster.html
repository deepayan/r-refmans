<!DOCTYPE html><html><head><title>Help for package aster</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {aster}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#anova.asterOrReaster'><p>Analysis of Deviance for Reaster Model Fits</p></a></li>
<li><a href='#aphid'><p>Life History Data on Uroleucon rudbeckiae</p></a></li>
<li><a href='#aster'><p>Aster Models</p></a></li>
<li><a href='#astertransform'><p>Transform between Aster Model Parameterizations</p></a></li>
<li><a href='#chamae'><p>Life History Data on Chamaecrista fasciculata</p></a></li>
<li><a href='#chamae2'><p>Life History Data on Chamaecrista fasciculata</p></a></li>
<li><a href='#chamae3'><p>Life History Data on Chamaecrista fasciculata</p></a></li>
<li><a href='#echin2'><p>Life History Data on Echinacea angustifolia</p></a></li>
<li><a href='#echinacea'><p>Life History Data on Echinacea angustifolia</p></a></li>
<li><a href='#families'><p>Families for Aster Models</p></a></li>
<li><a href='#foobar'><p>Toy Life History Data having Directions of Recession</p></a></li>
<li><a href='#mlogl'><p>Minus Log Likelihood for Aster Models</p></a></li>
<li><a href='#newpickle'><p>Penalized Quasi-Likelihood for Aster Models</p></a></li>
<li><a href='#oats'><p>Life History Data on Avena barbata</p></a></li>
<li><a href='#penmlogl'><p>Penalized Minus Log Likelihood for Aster Models</p></a></li>
<li><a href='#pickle'><p>Penalized Quasi-Likelihood for Aster Models</p></a></li>
<li><a href='#predict.aster'><p>Predict Method for Aster Model Fits</p></a></li>
<li><a href='#quickle'><p>Penalized Quasi-Likelihood for Aster Models</p></a></li>
<li><a href='#radish'><p>Life History Data on Raphanus sativus</p></a></li>
<li><a href='#raster'><p>Aster Model Simulation</p></a></li>
<li><a href='#reaster'><p>Aster Models with Random Effects</p></a></li>
<li><a href='#sim'><p>Simulated Life History Data</p></a></li>
<li><a href='#summary.aster'><p>Summarizing Aster Model Fits</p></a></li>
<li><a href='#summary.reaster'><p>Summarizing Aster Model with Random Effects Fits</p></a></li>
<li><a href='#truncated'><p>K-Truncated Distributions</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>1.1-3</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-12-13</td>
</tr>
<tr>
<td>Title:</td>
<td>Aster Models</td>
</tr>
<tr>
<td>Author:</td>
<td>Charles J. Geyer &lt;geyer@umn.edu&gt;</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Charles J. Geyer &lt;geyer@umn.edu&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.6.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, trust</td>
</tr>
<tr>
<td>Suggests:</td>
<td>numDeriv</td>
</tr>
<tr>
<td>ByteCompile:</td>
<td>TRUE</td>
</tr>
<tr>
<td>Description:</td>
<td>Aster models (Geyer, Wagenius, and Shaw, 2007,
    &lt;<a href="https://doi.org/10.1093%2Fbiomet%2Fasm030">doi:10.1093/biomet/asm030</a>&gt;; Shaw, Geyer, Wagenius, Hangelbroek, and
    Etterson, 2008, &lt;<a href="https://doi.org/10.1086%2F588063">doi:10.1086/588063</a>&gt;; Geyer, Ridley, Latta, Etterson,
    and Shaw, 2013, &lt;<a href="https://doi.org/10.1214%2F13-AOAS653">doi:10.1214/13-AOAS653</a>&gt;) are exponential family
    regression models for life
    history analysis.  They are like generalized linear models except that
    elements of the response vector can have different families (e. g.,
    some Bernoulli, some Poisson, some zero-truncated Poisson, some normal)
    and can be dependent, the dependence indicated by a graphical structure.
    Discrete time survival analysis, life table analysis,
    zero-inflated Poisson regression, and
    generalized linear models that are exponential family (e. g., logistic
    regression and Poisson regression with log link) are special cases.
    Main use is for data in which there is survival over discrete time periods
    and there is additional data about what happens conditional on survival
    (e. g., number of offspring).  Uses the exponential family canonical
    parameterization (aster transform of usual parameterization).
    There are also random effects versions of these models.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="http://www.stat.umn.edu/geyer/aster/">http://www.stat.umn.edu/geyer/aster/</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-12-13 18:49:04 UTC; geyer</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-12-14 15:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='anova.asterOrReaster'>Analysis of Deviance for Reaster Model Fits</h2><span id='topic+anova.asterOrReaster'></span><span id='topic+anovaAsterOrReasterList'></span><span id='topic+anova.aster'></span><span id='topic+anova.reaster'></span>

<h3>Description</h3>

<p>Compute an analysis of deviance table for two or more aster model
fits with or without random effects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'asterOrReaster'
anova(object, ...,
    tolerance = .Machine$double.eps ^ 0.75)
anovaAsterOrReasterList(objectlist, tolerance = .Machine$double.eps ^ 0.75)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="anova.asterOrReaster_+3A_object">object</code>, <code id="anova.asterOrReaster_+3A_...">...</code></td>
<td>
<p>objects of class <code>"asterOrReaster"</code>, typically
the result of a call to <code><a href="#topic+aster">aster</a></code> or <code><a href="#topic+reaster">reaster</a></code>.</p>
</td></tr>
<tr><td><code id="anova.asterOrReaster_+3A_objectlist">objectlist</code></td>
<td>
<p>list of objects of class <code>"asterOrReaster"</code>.</p>
</td></tr>
<tr><td><code id="anova.asterOrReaster_+3A_tolerance">tolerance</code></td>
<td>
<p>tolerance for comparing nesting of model matrices.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Constructs a table having a row for the
degrees of freedom and deviance for each model.
For all but the first model, the change in degrees of freedom and
deviance is also given, as is the corresponding asymptotic <code class="reqn">P</code>-value.
</p>
<p>For objects of class <code>"reaster"</code>, the
quantity called deviance is only approximate.  See references on
help for <code><a href="#topic+reaster">reaster</a></code>.
</p>
<p>When objects of class <code>"reaster"</code> are among those supplied,
degrees of freedom for fixed effects and degrees of freedom for
variance components are reported separately, because tests for fixed
effects are effectively two-tailed and tests for variance components
are effectively one-tailed.
</p>
<p>In case models being compared differ by one variance component, the
reference distribution is half a chi-square with the fixed effect
degrees of freedom (difference of number of fixed effects in the two
models) and half a chi-square with one more degrees of freedom.
</p>
<p>In case models being compared differ by two or more variance components,
we do not know how to how to do the test.  The reference distribution is
a mixture of chi-squares but the mixing weights are difficult to calculate.
An error is given in this case.
</p>


<h3>Value</h3>

<p>An object of class <code>"anova"</code> inheriting from class <code>"data.frame"</code>.
</p>


<h3>Warning</h3>

<p>The comparison between two or more models by <code>anova</code> or
<code>anovaAsterOrReasterList</code> will only be valid if they
are (1) fitted to the same dataset, 
(2) models are nested,
(3) have the same
dependence graph and exponential families.
Some of this is currently checked.  Some warnings are given.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+aster">aster</a></code>, <code><a href="#topic+reaster">reaster</a></code>, <code><a href="stats.html#topic+anova">anova</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### see package vignette for explanation ###
library(aster)
data(echinacea)
vars &lt;- c("ld02", "ld03", "ld04", "fl02", "fl03", "fl04",
    "hdct02", "hdct03", "hdct04")
redata &lt;- reshape(echinacea, varying = list(vars), direction = "long",
    timevar = "varb", times = as.factor(vars), v.names = "resp")
redata &lt;- data.frame(redata, root = 1)
pred &lt;- c(0, 1, 2, 1, 2, 3, 4, 5, 6)
fam &lt;- c(1, 1, 1, 1, 1, 1, 3, 3, 3)
hdct &lt;- grepl("hdct", as.character(redata$varb))
redata &lt;- data.frame(redata, hdct = as.integer(hdct))
level &lt;- gsub("[0-9]", "", as.character(redata$varb))
redata &lt;- data.frame(redata, level = as.factor(level))
aout1 &lt;- aster(resp ~ varb + hdct : (nsloc + ewloc + pop),
    pred, fam, varb, id, root, data = redata)
aout2 &lt;- aster(resp ~ varb + level : (nsloc + ewloc) + hdct : pop,
    pred, fam, varb, id, root, data = redata)
aout3 &lt;- aster(resp ~ varb + level : (nsloc + ewloc + pop),
    pred, fam, varb, id, root, data = redata)
anova(aout1, aout2, aout3)

# now random effects models and models without random effects mixed
## Not run: 
### CRAN policy says examples must take &lt; 5 sec.
### This doesn't (on their computers).
data(radish)
pred &lt;- c(0,1,2)
fam &lt;- c(1,3,2)
rout2 &lt;- reaster(resp ~ varb + fit : (Site * Region),
    list(block = ~ 0 + fit : Block, pop = ~ 0 + fit : Pop),
    pred, fam, varb, id, root, data = radish)
rout1 &lt;- reaster(resp ~ varb + fit : (Site * Region),
    list(block = ~ 0 + fit : Block),
    pred, fam, varb, id, root, data = radish)
rout0 &lt;- aster(resp ~ varb + fit : (Site * Region),
    pred, fam, varb, id, root, data = radish)
anova(rout0, rout1, rout2)

## End(Not run)
</code></pre>

<hr>
<h2 id='aphid'>Life History Data on Uroleucon rudbeckiae</h2><span id='topic+aphid'></span>

<h3>Description</h3>

<p>Data on life history traits for the brown ambrosia aphid
<em>Uroleucon rudbeckiae</em>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(aphid)</code></pre>


<h3>Format</h3>

<p>A data frame with records for 18 insects.
Data are already in &ldquo;long&rdquo; format; no need to reshape.
</p>

<dl>
<dt>resp</dt><dd><p>Response vector.</p>
</dd>
<dt>varb</dt><dd><p>Categorical.  Gives node of graphical model corresponding
to each component of <code>resp</code>.  See details below.</p>
</dd>
<dt>root</dt><dd><p>All ones.  Root variables for graphical model.</p>
</dd>
<dt>id</dt><dd><p>Categorical.  Indicates individual plants.</p>
</dd>
</dl>



<h3>Details</h3>

<p>The levels of <code>varb</code> indicate nodes of the graphical model to which
the corresponding elements of the response vector <code>resp</code> belong.
This is the typical &ldquo;long&rdquo; format produced by the R <code>reshape</code>
function.  For each individual, there are several response variables.
All response variables are combined in one vector <code>resp</code>.
The variable <code>varb</code> indicates which &ldquo;original&rdquo; variable
the number was for.  The variable <code>id</code> indicates which individual
the number was for.  The levels of <code>varb</code>, which are the names
of the &ldquo;original&rdquo; variables are the following.
<code>S1</code> through <code>S13</code> are Bernoulli: one if alive, zero if dead.
<code>B2</code> through <code>B9</code> are conditionally Poisson: the number of
offspring in the corresponding time period.  Some variables in the
original data that were zero have been deleted.
</p>


<h3>References</h3>

<p>These data were published in the following, where they were analyzed
by non-aster methods.
</p>
<p>Lenski, R. E. and Service, P. M. (1982).
The statistical analysis of population growth rates calculated
from schedules of survivorship and fecunidity.
<em>Ecology</em>, <b>63</b>, 655-662.
<a href="https://doi.org/10.2307/1936785">doi:10.2307/1936785</a>.
</p>
<p>These data are reanalyzed by aster methods in the following.
</p>
<p>Shaw, R. G., Geyer, C. J., Wagenius, S., Hangelbroek, H. H.,
and Etterson, J. R. (2008)
Unifying life history analyses for inference of fitness and population growth.
<em>American Naturalist</em>, <b>172</b>, E35-E47.
<a href="https://doi.org/10.1086/588063">doi:10.1086/588063</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(aphid)
### wide version
aphidw &lt;- reshape(aphid, direction = "wide", timevar = "varb",
    v.names = "resp", varying = list(levels(aphid$varb)))
</code></pre>

<hr>
<h2 id='aster'>Aster Models</h2><span id='topic+aster'></span><span id='topic+aster.default'></span><span id='topic+aster.formula'></span>

<h3>Description</h3>

<p>Fits Aster Models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aster(x, ...)

## Default S3 method:
aster(x, root, pred, fam, modmat, parm,
    type = c("unconditional", "conditional"), famlist = fam.default(),
    origin, origin.type = c("model.type", "unconditional", "conditional"),
    method = c("trust", "nlm", "CG", "L-BFGS-B"), fscale, maxiter = 1000,
    nowarn = TRUE, newton = TRUE, optout = FALSE, coef.names, ...)

## S3 method for class 'formula'
aster(formula, pred, fam, varvar, idvar, root,
    data, parm, type = c("unconditional", "conditional"),
    famlist = fam.default(),
    origin, origin.type = c("model.type", "unconditional", "conditional"),
    method = c("trust", "nlm", "CG", "L-BFGS-B"), fscale, maxiter = 1000,
    nowarn = TRUE, newton = TRUE, optout = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="aster_+3A_x">x</code></td>
<td>
<p>an <code>nind</code> by <code>nnode</code> matrix, the data for an
aster model.  The rows are independent and identically modeled
random vectors.  See details below for further requirements.
</p>
<p><code>aster.formula</code> constructs such an <code>x</code> from the response
in its formula.  Hence data for <code>aster.formula</code> must be a
vector of length <code>nind * nnode</code>.</p>
</td></tr>
<tr><td><code id="aster_+3A_root">root</code></td>
<td>
<p>an object of the same shape as <code>x</code>, the root data.
For <code>aster.default</code> an <code>nind</code> by <code>nnode</code> matrix,
For <code>aster.formula</code> an <code>nind * nnode</code> vector.</p>
</td></tr>
<tr><td><code id="aster_+3A_pred">pred</code></td>
<td>
<p>an integer vector of length <code>nnode</code> determining
the dependence
graph of the aster model.  <code>pred[j]</code> is
the index of the predecessor of
the node with index <code>j</code> unless the predecessor is a root
node, in which case <code>pred[j] == 0</code>.  See details below for
further requirements.</p>
</td></tr>
<tr><td><code id="aster_+3A_fam">fam</code></td>
<td>
<p>an integer vector of length <code>nnode</code> determining
the exponential family structure of the aster model.  Each element
is an index into the vector of family specifications given by
the argument <code>famlist</code>.</p>
</td></tr>
<tr><td><code id="aster_+3A_modmat">modmat</code></td>
<td>
<p>an <code>nind</code> by <code>nnode</code> by <code>ncoef</code>
three-dimensional array, the model matrix.
</p>
<p><code>aster.formula</code> constructs such a <code>modmat</code> from 
its formula, the data frame <code>data</code>, and the variables
in the environment of the formula.</p>
</td></tr>
<tr><td><code id="aster_+3A_parm">parm</code></td>
<td>
<p>usually missing.  Otherwise a vector of length <code>ncoef</code>
giving a starting point for the optimization.</p>
</td></tr>
<tr><td><code id="aster_+3A_type">type</code></td>
<td>
<p>type of model.
The value of this argument can be abbreviated.</p>
</td></tr>
<tr><td><code id="aster_+3A_famlist">famlist</code></td>
<td>
<p>a list of family specifications (see <code><a href="#topic+families">families</a></code>).</p>
</td></tr>
<tr><td><code id="aster_+3A_origin">origin</code></td>
<td>
<p>Distinguished point in parameter space.  May be missing,
in which case an unspecified default is provided.  See details below
for further explanation.  This is what <code><a href="stats.html#topic+lm">lm</a></code>,
<code><a href="stats.html#topic+glm">glm</a></code> and other functions that do regression call
&ldquo;offset&rdquo; but we don't change our name for reasons of backward
compatibility.</p>
</td></tr>
<tr><td><code id="aster_+3A_origin.type">origin.type</code></td>
<td>
<p>Parameter space in which specified distinguished point
is located.  If <code>"conditional"</code> then argument <code>"origin"</code> is
a conditional canonical parameter value.
If <code>"unconditional"</code> then argument <code>"origin"</code> is
an unconditional canonical parameter value.
If <code>"model.type"</code> then the type is taken from argument <code>"type"</code>.
The value of this argument can be abbreviated.</p>
</td></tr>
<tr><td><code id="aster_+3A_method">method</code></td>
<td>
<p>optimization method.  If <code>"trust"</code> then the
<code><a href="trust.html#topic+trust">trust</a></code> function is used.  If <code>"nlm"</code> then the
<code><a href="stats.html#topic+nlm">nlm</a></code> function is used.  Otherwise the
<code><a href="stats.html#topic+optim">optim</a></code> function is used with the specified <code>method</code>
supplied to it.
The value of this argument can be abbreviated.</p>
</td></tr>
<tr><td><code id="aster_+3A_fscale">fscale</code></td>
<td>
<p>an estimate of the size of the log likelihood at the maximum.
Defaults to <code>nind</code>.</p>
</td></tr>
<tr><td><code id="aster_+3A_maxiter">maxiter</code></td>
<td>
<p>maximum number of iterations.  Defaults to '1000'.</p>
</td></tr>
<tr><td><code id="aster_+3A_nowarn">nowarn</code></td>
<td>
<p>if <code>TRUE</code> (the default), suppress warnings from
the optimization routine.</p>
</td></tr>
<tr><td><code id="aster_+3A_newton">newton</code></td>
<td>
<p>if <code>TRUE</code> (the default), do one Newton iteration
on the result produced by the optimization routine, except when
<code>method == "trust"</code> when no such Newton iteration is done,
regardless of the value of <code>newton</code>, because <code><a href="trust.html#topic+trust">trust</a></code>
always terminates with a Newton iteration when it converges.</p>
</td></tr>
<tr><td><code id="aster_+3A_optout">optout</code></td>
<td>
<p>if <code>TRUE</code>, save the entire result of the optimization
routine (<code><a href="trust.html#topic+trust">trust</a></code>, <code><a href="stats.html#topic+nlm">nlm</a></code>, or <code><a href="stats.html#topic+optim">optim</a></code>,
as the case may be).</p>
</td></tr>
<tr><td><code id="aster_+3A_coef.names">coef.names</code></td>
<td>
<p>names of the regression coefficients.  If missing,
<code>dimnames(modmat)[[3]]</code> is used.  In <code>aster.formula</code> these
are produced automatically by the R formula machinery.</p>
</td></tr>
<tr><td><code id="aster_+3A_...">...</code></td>
<td>
<p>other arguments passed to the optimization method.</p>
</td></tr>
<tr><td><code id="aster_+3A_formula">formula</code></td>
<td>
<p>a symbolic description of the model to be fit.  See
<code><a href="stats.html#topic+lm">lm</a></code>, <code><a href="stats.html#topic+glm">glm</a></code>, and 
<code><a href="stats.html#topic+formula">formula</a></code> for discussions of the R formula mini-language.</p>
</td></tr>
<tr><td><code id="aster_+3A_varvar">varvar</code></td>
<td>
<p>a variable of the same length as the response in
the formula that is a factor whose levels are character strings
treated as variable names.  The number of variable names is <code>nnode</code>.
Must be of the form <code>rep(vars, each = nind)</code> where <code>vars</code> is
a vector of variable names.  Usually found in the data frame <code>data</code>
when this is produced by the <code><a href="stats.html#topic+reshape">reshape</a></code> function.</p>
</td></tr>
<tr><td><code id="aster_+3A_idvar">idvar</code></td>
<td>
<p>a variable of the same length as the response in
the formula that indexes individuals.  The number
of individuals is <code>nind</code>.
Must be of the form <code>rep(inds, times = nnode)</code> where <code>inds</code> is
a vector of labels for individuals.  Usually found in the data frame
<code>data</code> when this is produced by the <code><a href="stats.html#topic+reshape">reshape</a></code> function.</p>
</td></tr>
<tr><td><code id="aster_+3A_data">data</code></td>
<td>
<p>an optional data frame containing the variables
in the model.  If not found in <code>data</code>, the variables are taken
from <code>environment(formula)</code>, typically the environment from
which <code>aster</code> is called.  Usually produced by
the <code><a href="stats.html#topic+reshape">reshape</a></code> function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The vector <code>pred</code> must satisfy <code>all(pred &lt; seq(along = pred))</code>,
that is, each predecessor must precede in the order given in <code>pred</code>.
The vector <code>pred</code> defines a function <code class="reqn">p</code>.
</p>
<p>The joint distribution of the data matrix <code>x</code> is a product of conditionals
</p>
<p style="text-align: center;"><code class="reqn">\prod_{i \in I} \prod_{j \in J} \Pr \{ X_{i j} | X_{i p(j)} \}</code>
</p>

<p>When <code class="reqn">p(j) = 0</code>, the notation <code class="reqn">X_{i p(j)}</code>
means <code>root[i, j]</code>.  Other elements of the matrix <code>root</code> are
not used.
</p>
<p>The conditional distribution
<code class="reqn">\Pr \{ X_{i j} | X_{i p(j)} \}</code>
is the <code class="reqn">X_{i p(j)}</code>-fold convolution of the <code class="reqn">j</code>-th family
in the vector <code>fam</code>, a one-parameter exponential family
(i.e., the sum of <code class="reqn">X_{i p(j)}</code> i.i.d. terms having
this one-parameter exponential family distribution).
</p>
<p>For <code>type == "conditional"</code> the canonical parameter vector
<code class="reqn">\theta_{i j}</code> is modeled in GLM fashion as
<code class="reqn">\theta = a + M \beta</code> where <code class="reqn">M</code> is the model
matrix <code>modmat</code> and <code class="reqn">a</code> is the distinguished point <code>origin</code>.
Since the &ldquo;vector&rdquo; <code class="reqn">\theta</code> is
actually a matrix, the &ldquo;matrix&rdquo; <code class="reqn">M</code> must correspondingly
be a three-dimensional array.  So <code class="reqn">\theta = a + M \beta</code>
written out in full is
</p>
<p style="text-align: center;"><code class="reqn">\theta_{i j} = a_{i j} + \sum_{k \in K} m_{i j k} \beta_k</code>
</p>

<p>This specifies the log likelihood.
</p>
<p>For <code>type == "unconditional"</code> the canonical parameter vector
for an unconditional model is modeled in GLM fashion as
<code class="reqn">\varphi = a + M \beta</code> (where the notation is as above).
The unconditional canonical parameters are then specified in terms of
the conditional ones by
</p>
<p style="text-align: center;"><code class="reqn">\varphi_{i j} = \theta_{i j} - \sum_{k \in S(j)} \psi_k(\theta_{i k})</code>
</p>

<p>where <code class="reqn">S(j)</code> denotes the set of successors of <code class="reqn">j</code>,
the <code class="reqn">k</code> such that <code class="reqn">p(k) = j</code>, and <code class="reqn">\psi_k</code> is the
cumulant function for the <code class="reqn">k</code>-th exponential family.
This rather crazy looking formulation is an invertible change of parameter
and makes <code class="reqn">\varphi</code>
the canonical parameter and <code class="reqn">x</code> the canonical statistic of a full
flat unconditional exponential family.
Again, this specifies the log likelihood.
</p>
<p>In versions of aster prior to version 0.6 there was no <code class="reqn">a</code> in the model
specification, which is the same as specifying <code class="reqn">a = 0</code> in the current
specification.  If <code class="reqn">a</code> is in the column space of the model matrix, that
is, if there exists an <code class="reqn">\alpha</code>
such that <code class="reqn">a = M \alpha</code>, then there is no difference
in the model specified with <code class="reqn">a</code> and the one with <code class="reqn">a = 0</code>.
The maximum likelihood regression coefficients <code class="reqn">\hat{\beta}</code>
will be different, but the maximum likelihood estimates of all other
parameters (conditional and unconditional, canonical and mean value)
will be the same.  This is the usual case and explains why &ldquo;linear&rdquo;
models (with <code class="reqn">a = 0</code>) as opposed to &ldquo;affine&rdquo; models
(with general <code class="reqn">a</code>)
are popular.  In the unusual case where <code class="reqn">a</code> is not in the column space
of the design matrix, then affine models are a generalization of linear
models: the two are not equivalent, their maximum likelihood estimates are
not the same in any parameterization.
</p>
<p>In order to use the R model formula mini-language we must flatten
the dimensionality, making the model matrix <code>modmat</code> two-dimensional
(a true matrix).  This must be done as if by
<code>matrix(modmat, ncol = ncoef)</code>,
which imposes the requirements on <code>varvar</code> and <code>idvar</code>
given in the arguments section: they must look like <code>row(x)</code> and
<code>col(x)</code> modulo relabeling.
Then <code>x</code> and <code>root</code>
become one-dimensional, done as if by <code>as.numeric(x)</code>
and <code>as.numeric(root)</code>.
</p>
<p>The standard way to do this in R is to use the <code><a href="stats.html#topic+reshape">reshape</a></code>
function on a data frame in which the columns of the <code>x</code> matrix
are variables in the data frame.  <code><a href="stats.html#topic+reshape">reshape</a></code> automatically puts
things in the right order and creates <code>varvar</code> and <code>idvar</code>.
This is shown in the examples section below and in the package vignette
titled &quot;Aster Package Tutorial&quot;.
</p>


<h3>Value</h3>

<p><code>aster</code> returns an object of class inheriting from <code>"aster"</code>.
<code>aster.formula</code>, returns an object of class <code>"aster"</code> and
subclass <code>"aster.formula"</code>.
</p>
<p>The function <code><a href="base.html#topic+summary">summary</a></code> (i.e., <code><a href="#topic+summary.aster">summary.aster</a></code>) can
be used to obtain or print a summary of the results, the function
<code><a href="stats.html#topic+anova">anova</a></code> (i.e., <code><a href="#topic+anova.aster">anova.aster</a></code>)
to produce an analysis of deviance table, and the function
<code><a href="stats.html#topic+predict">predict</a></code> (i.e., <code><a href="#topic+predict.aster">predict.aster</a></code>)
to produce predicted values and standard errors.
</p>
<p>An object of class <code>"aster"</code> is a list containing at least the
following components:
</p>
<table>
<tr><td><code>coefficients</code></td>
<td>
<p>a named vector of coefficients.</p>
</td></tr>
<tr><td><code>rank</code></td>
<td>
<p>the numeric rank of the fitted generalized linear model
part of the aster model (i.e., the rank of <code>modmat</code>).</p>
</td></tr>
<tr><td><code>deviance</code></td>
<td>
<p>up to a constant, minus twice the maximized
log-likelihood.  (Note the minus.  This is somewhat counterintuitive,
but cannot be changed for reasons of backward compatibility.)</p>
</td></tr>
<tr><td><code>iter</code></td>
<td>
<p>the number of iterations used by the optimization method.</p>
</td></tr>
<tr><td><code>converged</code></td>
<td>
<p>logical. Was the optimization algorithm judged to have
converged?</p>
</td></tr>
<tr><td><code>code</code></td>
<td>
<p>integer.  The convergence code returned by the optimization
method.</p>
</td></tr>
<tr><td><code>gradient</code></td>
<td>
<p>The gradient vector of minus the log likelihood at the
fitted <code>coefficients</code> vector.</p>
</td></tr>
<tr><td><code>hessian</code></td>
<td>
<p>The Hessian matrix of minus the log likelihood
(i.e., the observed Fisher information) at the
fitted <code>coefficients</code> vector.
This is also the expected Fisher information when
<code>type == "unconditional"</code>.</p>
</td></tr>
<tr><td><code>fisher</code></td>
<td>
<p>Expected Fisher information at the fitted <code>coefficients</code>
vector.</p>
</td></tr>
<tr><td><code>optout</code></td>
<td>
<p>The object returned by the optimization routine
(<code><a href="trust.html#topic+trust">trust</a></code>, <code><a href="stats.html#topic+nlm">nlm</a></code>, or <code><a href="stats.html#topic+optim">optim</a></code>).
Only returned when the argument <code>optout</code> is <code>TRUE</code>.</p>
</td></tr>
</table>
<p>Calls to <code>aster.formula</code> return a list also containing:
</p>
<table>
<tr><td><code>call</code></td>
<td>
<p>the matched call.</p>
</td></tr>
<tr><td><code>formula</code></td>
<td>
<p>the formula supplied.</p>
</td></tr>
<tr><td><code>terms</code></td>
<td>
<p>the <code><a href="stats.html#topic+terms">terms</a></code> object used.</p>
</td></tr>
<tr><td><code>data</code></td>
<td>
<p>the <code>data argument</code>.</p>
</td></tr>
</table>


<h3>NA Values</h3>

<p>It was almost always wrong for aster model data to have <code>NA</code> values.
Although theoretically possible for the R formula mini-language to do the
right thing for an aster model with <code>NA</code> values in the data, usually
it does some wrong thing.  Thus, since version 0.8-20, this function and
the <code><a href="#topic+reaster">reaster</a></code> function give errors when used with data having
<code>NA</code> values.  Users must remove all <code>NA</code> values (or replace them
with what they should be, perhaps zero values) &ldquo;by hand&rdquo;.
</p>


<h3>Directions of Recession</h3>

<p>Even if the result of this function
has component <code>converges</code> equal to <code>TRUE</code>, the result will be
nonsense if there are one or more directions of recession.  These are
not detected by this function, but rather by the <code>summary</code> function
applied to the result of this function,
for which see <code><a href="#topic+summary.aster">summary.aster</a></code>.
</p>


<h3>References</h3>

<p>Geyer, C. J., Wagenius, S., and Shaw, R. G. (2007)
Aster Models for Life History Analysis.
<em>Biometrika</em>, <b>94</b>, 415&ndash;426.
<a href="https://doi.org/10.1093/biomet/asm030">doi:10.1093/biomet/asm030</a>.
</p>
<p>Shaw, R. G., Geyer, C. J., Wagenius, S., Hangelbroek, H. H., and
Etterson, J. R. (2008)
Unifying Life History Analysis for Inference of Fitness
and population growth.
<em>American Naturalist</em>, <b>172</b>, E35&ndash;E47.
<a href="https://doi.org/10.1086/588063">doi:10.1086/588063</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+anova.aster">anova.aster</a></code>,
<code><a href="#topic+summary.aster">summary.aster</a></code>,
and
<code><a href="#topic+predict.aster">predict.aster</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### see package vignette for explanation ###
library(aster)
data(echinacea)
vars &lt;- c("ld02", "ld03", "ld04", "fl02", "fl03", "fl04",
    "hdct02", "hdct03", "hdct04")
redata &lt;- reshape(echinacea, varying = list(vars), direction = "long",
    timevar = "varb", times = as.factor(vars), v.names = "resp")
redata &lt;- data.frame(redata, root = 1)
pred &lt;- c(0, 1, 2, 1, 2, 3, 4, 5, 6)
fam &lt;- c(1, 1, 1, 1, 1, 1, 3, 3, 3)
hdct &lt;- grepl("hdct", as.character(redata$varb))
redata &lt;- data.frame(redata, hdct = as.integer(hdct))
level &lt;- gsub("[0-9]", "", as.character(redata$varb))
redata &lt;- data.frame(redata, level = as.factor(level))
aout &lt;- aster(resp ~ varb + level : (nsloc + ewloc) + hdct : pop,
    pred, fam, varb, id, root, data = redata)
summary(aout, show.graph = TRUE)
</code></pre>

<hr>
<h2 id='astertransform'>Transform between Aster Model Parameterizations</h2><span id='topic+astertransform'></span>

<h3>Description</h3>

<p>Transform between different parameterizations of the aster model.
In effect, this function is called inside <code><a href="#topic+predict.aster">predict.aster</a></code>.
Users generally do not need to call it directly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>astertransform(arg, obj, from = c("unconditional", "conditional"),
    to.cond = c("unconditional", "conditional"),
    to.mean = c("mean.value", "canonical"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="astertransform_+3A_arg">arg</code></td>
<td>
<p>canonical parameter vector of length <code>nrow(obj$data)</code>,
either unconditional (<code class="reqn">\varphi</code>)
or conditional (<code class="reqn">\theta</code>) depending on the value of
argument <code>from</code>.</p>
</td></tr>
<tr><td><code id="astertransform_+3A_obj">obj</code></td>
<td>
<p>aster model object, the result of a call to <code><a href="#topic+aster">aster</a></code>.</p>
</td></tr>
<tr><td><code id="astertransform_+3A_from">from</code></td>
<td>
<p>the type of canonical parameter which argument <code>arg</code> is.</p>
</td></tr>
<tr><td><code id="astertransform_+3A_to.cond">to.cond</code></td>
<td>
<p>the type of parameter we want.</p>
</td></tr>
<tr><td><code id="astertransform_+3A_to.mean">to.mean</code></td>
<td>
<p>the type of parameter we want.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of the same length as <code>arg</code>, the transformed parameter vector.
</p>

<hr>
<h2 id='chamae'>Life History Data on Chamaecrista fasciculata</h2><span id='topic+chamae'></span>

<h3>Description</h3>

<p>Data on life history traits for the partridge pea
<em>Chamaecrista fasciculata</em>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(chamae)</code></pre>


<h3>Format</h3>

<p>A data frame with records for 2235 plants.
Data are already in &ldquo;long&rdquo; format; no need to reshape.
</p>

<dl>
<dt>resp</dt><dd><p>Response vector.</p>
</dd>
<dt>varb</dt><dd><p>Categorical.  Gives node of graphical model corresponding
to each component of <code>resp</code>.  See details below.</p>
</dd>
<dt>root</dt><dd><p>All ones.  Root variables for graphical model.</p>
</dd>
<dt>id</dt><dd><p>Categorical.  Indicates individual plants.</p>
</dd>
<dt>STG1N</dt><dd><p>Numerical.  Reproductive stage.  Integer with only 3 values
in this dataset.</p>
</dd>
<dt>LOGLVS</dt><dd><p>Numerical.  Log leaf number.</p>
</dd>
<dt>LOGSLA</dt><dd><p>Numerical.  Log leaf thickness.</p>
</dd>
<dt>BLK</dt><dd><p>Categorical.  Block within experiment.</p>
</dd>
</dl>



<h3>Details</h3>

<p>The levels of <code>varb</code> indicate nodes of the graphical model to which
the corresponding elements of the response vector <code>resp</code> belong.
This is the typical &ldquo;long&rdquo; format produced by the R <code>reshape</code>
function.  For each individual, there are several response variables.
All response variables are combined in one vector <code>resp</code>.
The variable <code>varb</code> indicates which &ldquo;original&rdquo; variable
the number was for.  The variable <code>id</code> indicates which individual
the number was for.  The levels of <code>varb</code>, which are the names
of the &ldquo;original&rdquo; variables are
</p>

<dl>
<dt>fecund</dt><dd><p>Fecundity.  Bernoulli, One if any fruit, zero if no fruit.</p>
</dd>
<dt>fruit</dt><dd><p>Integer.  Number of fruits observed.  Greater than or equal
3 if nonzero.</p>
</dd>
<dt>seed</dt><dd><p>Integer.  Number of seeds observed from a random sample of
3 of the fruits for this individual.</p>
</dd>
</dl>



<h3>Source</h3>

<p>Julie Etterson
<a href="https://sites.google.com/d.umn.edu/dr-julie-r-etterson/home">https://sites.google.com/d.umn.edu/dr-julie-r-etterson/home</a>
</p>


<h3>References</h3>

<p>These data are a subset of data previously analyzed by non-aster methods in the following.
</p>
<p>Etterson, J. R. (2004).
Evolutionary potential of <em>Chamaecrista fasciculata</em> in
relation to climate change.  I. Clinal patterns of selection along
an environmental gradient in the great plains.
<em>Evolution</em>, <b>58</b>, 1446-1458.
<a href="https://doi.org/10.1111/j.0014-3820.2004.tb01726.x">doi:10.1111/j.0014-3820.2004.tb01726.x</a>.
</p>
<p>Etterson, J. R., and Shaw, R. G. (2001).
Constraint to adaptive evolution in response to global warming.
<em>Science</em>, <b>294</b>, 151-154.
<a href="https://doi.org/10.1126/science.1063656">doi:10.1126/science.1063656</a>.
</p>
<p>These data are reanalyzed by aster methods in the following.
</p>
<p>Shaw, R. G., Geyer, C. J., Wagenius, S., Hangelbroek, H. H.,
and Etterson, J. R. (2008)
Unifying life history analyses for inference of fitness and population growth.
<em>American Naturalist</em>, <b>172</b>, E35-E47.
<a href="https://doi.org/10.1086/588063">doi:10.1086/588063</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(chamae)
### wide version
chamaew &lt;- reshape(chamae, direction = "wide", timevar = "varb",
    v.names = "resp", varying = list(levels(chamae$varb)))
</code></pre>

<hr>
<h2 id='chamae2'>Life History Data on Chamaecrista fasciculata</h2><span id='topic+chamae2'></span>

<h3>Description</h3>

<p>Data on life history traits for the partridge pea
<em>Chamaecrista fasciculata</em>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(chamae2)</code></pre>


<h3>Format</h3>

<p>A data frame with records for 2239 plants.
Data are already in &ldquo;long&rdquo; format; no need to reshape.
</p>

<dl>
<dt>resp</dt><dd><p>Response vector.</p>
</dd>
<dt>varb</dt><dd><p>Categorical.  Gives node of graphical model corresponding
to each component of <code>resp</code>.  See details below.</p>
</dd>
<dt>root</dt><dd><p>All ones.  Root variables for graphical model.</p>
</dd>
<dt>id</dt><dd><p>Categorical.  Indicates individual plants.</p>
</dd>
<dt>STG1N</dt><dd><p>Numerical.  Reproductive stage.  Integer with only 3 values
in this dataset.</p>
</dd>
<dt>LOGLVS</dt><dd><p>Numerical.  Log leaf number.</p>
</dd>
<dt>LOGSLA</dt><dd><p>Numerical.  Log leaf thickness.</p>
</dd>
<dt>BLK</dt><dd><p>Categorical.  Block within experiment.</p>
</dd>
</dl>



<h3>Details</h3>

<p>The levels of <code>varb</code> indicate nodes of the graphical model to which
the corresponding elements of the response vector <code>resp</code> belong.
This is the typical &ldquo;long&rdquo; format produced by the R <code>reshape</code>
function.  For each individual, there are several response variables.
All response variables are combined in one vector <code>resp</code>.
The variable <code>varb</code> indicates which &ldquo;original&rdquo; variable
the number was for.  The variable <code>id</code> indicates which individual
the number was for.  The levels of <code>varb</code>, which are the names
of the &ldquo;original&rdquo; variables are
</p>

<dl>
<dt>fecund</dt><dd><p>Fecundity.  Bernoulli, One if any fruit, zero if no fruit.</p>
</dd>
<dt>fruit</dt><dd><p>Integer.  Number of fruits observed.</p>
</dd>
</dl>



<h3>Source</h3>

<p>Julie Etterson
<a href="https://sites.google.com/d.umn.edu/dr-julie-r-etterson/home">https://sites.google.com/d.umn.edu/dr-julie-r-etterson/home</a>
</p>


<h3>References</h3>

<p>These data are a subset of data previously analyzed by non-aster methods in the following.
</p>
<p>Etterson, J. R. (2004).
Evolutionary potential of <em>Chamaecrista fasciculata</em> in
relation to climate change.  I. Clinal patterns of selection along
an environmental gradient in the great plains.
<em>Evolution</em>, <b>58</b>, 1446-1458.
<a href="https://doi.org/10.1111/j.0014-3820.2004.tb01726.x">doi:10.1111/j.0014-3820.2004.tb01726.x</a>.
</p>
<p>Etterson, J. R., and Shaw, R. G. (2001).
Constraint to adaptive evolution in response to global warming.
<em>Science</em>, <b>294</b>, 151-154.
<a href="https://doi.org/10.1126/science.1063656">doi:10.1126/science.1063656</a>.
</p>
<p>These data are reanalyzed by aster methods in the following.
</p>
<p>Shaw, R. G., Geyer, C. J., Wagenius, S., Hangelbroek, H. H.,
and Etterson, J. R. (2008)
Unifying life history analyses for inference of fitness and population growth.
<em>American Naturalist</em>, <b>172</b>, E35-E47.
<a href="https://doi.org/10.1086/588063">doi:10.1086/588063</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(chamae2)
### wide version
chamae2w &lt;- reshape(chamae2, direction = "wide", timevar = "varb",
    v.names = "resp", varying = list(levels(chamae2$varb)))
</code></pre>

<hr>
<h2 id='chamae3'>Life History Data on Chamaecrista fasciculata</h2><span id='topic+chamae3'></span>

<h3>Description</h3>

<p>Data on life history traits for the partridge pea
<em>Chamaecrista fasciculata</em>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(chamae3)</code></pre>


<h3>Format</h3>

<p>A data frame with records for 2239 plants.
Data are already in &ldquo;long&rdquo; format; no need to reshape.
</p>

<dl>
<dt>resp</dt><dd><p>Response vector.</p>
</dd>
<dt>varb</dt><dd><p>Categorical.  Gives node of graphical model corresponding
to each component of <code>resp</code>.  See details below.</p>
</dd>
<dt>root</dt><dd><p>All ones.  Root variables for graphical model.</p>
</dd>
<dt>id</dt><dd><p>Categorical.  Indicates individual plants.</p>
</dd>
<dt>fit</dt><dd><p>Zero-or-one-valued.  Indicates &ldquo;fitness&rdquo; nodes of the
graph.</p>
</dd>
<dt>SIRE</dt><dd><p>Categorical.  Sire.</p>
</dd>
<dt>DAM</dt><dd><p>Categorical.  Dam.</p>
</dd>
<dt>SITE</dt><dd><p>Categorical.  Experiment site.</p>
</dd>
<dt>POP</dt><dd><p>Categorical.  Population of sire and dam.</p>
</dd>
<dt>ROW</dt><dd><p>Numerical.  Row.  Position in site.</p>
</dd>
<dt>BLK</dt><dd><p>Categorical.  Block within site.</p>
</dd>
</dl>



<h3>Details</h3>

<p>The levels of <code>varb</code> indicate nodes of the graphical model to which
the corresponding elements of the response vector <code>resp</code> belong.
This is the typical &ldquo;long&rdquo; format produced by the R <code>reshape</code>
function.  For each individual, there are several response variables.
All response variables are combined in one vector <code>resp</code>.
The variable <code>varb</code> indicates which &ldquo;original&rdquo; variable
the number was for.  The variable <code>id</code> indicates which individual
the number was for.  The levels of <code>varb</code>, which are the names
of the &ldquo;original&rdquo; variables are
</p>

<dl>
<dt>fecund</dt><dd><p>Fecundity.  Bernoulli, One if any fruit, zero if no fruit.</p>
</dd>
<dt>fruit</dt><dd><p>Integer.  Number of fruits observed.</p>
</dd>
</dl>



<h3>Source</h3>

<p>Julie Etterson
<a href="https://sites.google.com/d.umn.edu/dr-julie-r-etterson/home">https://sites.google.com/d.umn.edu/dr-julie-r-etterson/home</a>
</p>


<h3>References</h3>

<p>These data are a subset of data previously analyzed by non-aster methods in the following.
</p>
<p>Etterson, J. R. (2004).
Evolutionary potential of <em>Chamaecrista fasciculata</em> in
relation to climate change.  II. Genetic architecture of three
populations reciprocally planted along an environmental gradient in the
great plains.
<em>Evolution</em>, <b>58</b>, 1459&ndash;1471.
<a href="https://doi.org/10.1111/j.0014-3820.2004.tb01727.x">doi:10.1111/j.0014-3820.2004.tb01727.x</a>.
</p>
<p>These data were reanalyzed by aster methods in the following.
</p>
<p>Geyer, C. J., Ridley, C. E., Latta, R. G., Etterson, J. R.,
and Shaw, R. G. (2013)
Local Adaptation and Genetic Effects on Fitness: Calculations
for Exponential Family Models with Random Effects.
<em>Annals of Applied Statistics</em>, <b>7</b>, 1778&ndash;1795.
<a href="https://doi.org/10.1214/13-AOAS653">doi:10.1214/13-AOAS653</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(chamae3)
### wide version
## Not run: 
### CRAN policy says examples must take &lt; 5 sec.  This doesn't.
foo &lt;- chamae3
### delete fit because it makes no sense in wide version
foo$fit &lt;- NULL
chamae3w &lt;- reshape(foo, direction = "wide", timevar = "varb",
    v.names = "resp", varying = list(levels(chamae3$varb)))

## End(Not run)
</code></pre>

<hr>
<h2 id='echin2'>Life History Data on Echinacea angustifolia</h2><span id='topic+echin2'></span>

<h3>Description</h3>

<p>Data on life history traits for the narrow-leaved purple coneflower
<em>Echinacea angustifolia</em>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(echin2)</code></pre>


<h3>Format</h3>

<p>A data frame with records for 557 plants observed over five years.
Data are already in &ldquo;long&rdquo; format; no need to reshape.
</p>

<dl>
<dt>resp</dt><dd><p>Response vector.</p>
</dd>
<dt>varb</dt><dd><p>Categorical.  Gives node of graphical model corresponding
to each component of <code>resp</code>.  See details below.</p>
</dd>
<dt>root</dt><dd><p>All ones.  Root variables for graphical model.</p>
</dd>
<dt>id</dt><dd><p>Categorical.  Indicates individual plants.</p>
</dd>
<dt>flat</dt><dd><p>Categorical.  Position in growth chamber.</p>
</dd>
<dt>row</dt><dd><p>Categorical.  Row in the field.</p>
</dd>
<dt>posi</dt><dd><p>Numerical.  Position within row in the field.</p>
</dd>
<dt>crosstype</dt><dd><p>Categorical.  See details.</p>
</dd>
<dt>yearcross</dt><dd><p>Categorical.  Year in which cross was done.</p>
</dd>
</dl>



<h3>Details</h3>

<p>The levels of <code>varb</code> indicate nodes of the graphical model to which
the corresponding elements of the response vector <code>resp</code> belong.
This is the typical &ldquo;long&rdquo; format produced by the R <code>reshape</code>
function.  For each individual, there are several response variables.
All response variables are combined in one vector <code>resp</code>.
The variable <code>varb</code> indicates which &ldquo;original&rdquo; variable
the number was for.  The variable <code>id</code> indicates which individual
the number was for.  The levels of <code>varb</code>, which are the names
of the &ldquo;original&rdquo; variables are
</p>

<dl>
<dt>lds1</dt><dd><p>Survival for the first month in the growth
chamber.</p>
</dd>
<dt>lds2</dt><dd><p>Ditto for 2nd month in the growth chamber.</p>
</dd>
<dt>lds3</dt><dd><p>Ditto for 3rd month in the growth chamber.</p>
</dd>
<dt>ld01</dt><dd><p>Survival for first year in the field.</p>
</dd>
<dt>ld02</dt><dd><p>Ditto for 2nd year in the field.</p>
</dd>
<dt>ld03</dt><dd><p>Ditto for 3rd year in the field.</p>
</dd>
<dt>ld04</dt><dd><p>Ditto for 4th year in the field.</p>
</dd>
<dt>ld05</dt><dd><p>Ditto for 5th year in the field.</p>
</dd>
<dt>roct2003</dt><dd><p>Rosette count, measure of size and vigor,
recorded for 3rd year in the field.</p>
</dd>
<dt>roct2004</dt><dd><p>Ditto for 4th year in the field.</p>
</dd>
<dt>roct2005</dt><dd><p>Ditto for 5th year in the field.</p>
</dd>
</dl>

<p>These data are complicated by the experiment being done in two parts.
Plants start their life indoors in a growth chamber.  The predictor
variable <code>flat</code> only makes sense during this time in which three
response variables <code>lds1</code>, <code>lds2</code>, and <code>lds3</code> are observed.
After three months in the growth chamber, the plants (if they
survived, i. e., if <code>lds3 == 1</code>) were planted in an experimental
field plot outdoors.  The variables <code>row</code> and <code>posi</code> only make
sense during this time in which all of the rest of the response variables
are observed.  Because of certain predictor variables only making sense
with respect to certain components of the response vector, the R formula
mini-language is unable to cope, and model matrices must be constructed
&quot;by hand&quot;.
</p>
<p><em>Echinacea angustifolia</em> is native to North American tallgrass prairie,
which was once extensive but now exists only in isolated remnants.
To evaluate the effects of different mating regimes on the fitness of
resulting progeny, crosses were conducted to produce progeny of (a) mates
from different remnants, (b) mates chosen at random from the same remnant,
and (c) mates known to share maternal parent.  These three categories are
the three levels of <code>crosstype</code>.
</p>


<h3>Source</h3>

<p>Stuart Wagenius,
<a href="https://www.chicagobotanic.org/research/staff/wagenius">https://www.chicagobotanic.org/research/staff/wagenius</a>
</p>


<h3>References</h3>

<p>These data are analyzed in the following.                                     
</p>
<p>Shaw, R. G., Geyer, C. J., Wagenius, S., Hangelbroek, H. H.,
and Etterson, J. R. (2008)
Unifying life history analyses for inference of fitness and population growth.
<em>American Naturalist</em>, <b>172</b>, E35-E47.
<a href="https://doi.org/10.1086/588063">doi:10.1086/588063</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(echin2)
</code></pre>

<hr>
<h2 id='echinacea'>Life History Data on Echinacea angustifolia</h2><span id='topic+echinacea'></span>

<h3>Description</h3>

<p>Data on life history traits for the narrow-leaved purple coneflower
<em>Echinacea angustifolia</em>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(echinacea)</code></pre>


<h3>Format</h3>

<p>A data frame with records for 570 plants observed over three years.
</p>

<dl>
<dt>ld02</dt><dd><p>Indicator of being alive in 2002.</p>
</dd>
<dt>ld03</dt><dd><p>Ditto for 2003.</p>
</dd>
<dt>ld04</dt><dd><p>Ditto for 2004.</p>
</dd>
<dt>fl02</dt><dd><p>Indicator of flowering 2002.</p>
</dd>
<dt>fl03</dt><dd><p>Ditto for 2003.</p>
</dd>
<dt>fl04</dt><dd><p>Ditto for 2004.</p>
</dd>
<dt>hdct02</dt><dd><p>Count of number of flower heads in 2002.</p>
</dd>
<dt>hdct03</dt><dd><p>Ditto for 2003.</p>
</dd>
<dt>hdct04</dt><dd><p>Ditto for 2004.</p>
</dd>
<dt>pop</dt><dd><p>the remnant population of origin of the plant
(all plants were grown together, <code>pop</code> encodes ancestry).</p>
</dd>
<dt>ewloc</dt><dd><p>east-west location in plot.</p>
</dd>
<dt>nsloc</dt><dd><p>north-south location in plot.</p>
</dd>
</dl>



<h3>Source</h3>

<p>Stuart Wagenius,
<a href="https://www.chicagobotanic.org/research/staff/wagenius">https://www.chicagobotanic.org/research/staff/wagenius</a>
</p>


<h3>References</h3>

<p>These data are analyzed in the following.
</p>
<p>Geyer, C. J., Wagenius, S., and Shaw, R. G. (2007)
Aster Models for Life History Analysis.
<em>Biometrika</em>, <b>94</b>, 415&ndash;426.
<a href="https://doi.org/10.1093/biomet/asm030">doi:10.1093/biomet/asm030</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(aster)
data(echinacea)
vars &lt;- c("ld02", "ld03", "ld04", "fl02", "fl03", "fl04",
    "hdct02", "hdct03", "hdct04")
redata &lt;- reshape(echinacea, varying = list(vars), direction = "long",
    timevar = "varb", times = as.factor(vars), v.names = "resp")
names(echinacea)
dim(echinacea)
names(redata)
dim(redata)
</code></pre>

<hr>
<h2 id='families'>Families for Aster Models</h2><span id='topic+families'></span><span id='topic+fam.bernoulli'></span><span id='topic+fam.poisson'></span><span id='topic+fam.truncated.poisson'></span><span id='topic+fam.negative.binomial'></span><span id='topic+fam.truncated.negative.binomial'></span><span id='topic+fam.normal.location'></span><span id='topic+fam.default'></span><span id='topic+famfun'></span>

<h3>Description</h3>

<p>Families (response models) known to the package.
These functions construct simple family specifications used
in specifying models for <code><a href="#topic+aster">aster</a></code> and <code><a href="#topic+mlogl">mlogl</a></code>.
They are mostly for convenience, since the specifications are easy
to construct by hand.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fam.bernoulli()
fam.poisson()
fam.truncated.poisson(truncation)
fam.negative.binomial(size)
fam.truncated.negative.binomial(size, truncation)
fam.normal.location(sd)
fam.default()
famfun(fam, deriv, theta)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="families_+3A_truncation">truncation</code></td>
<td>
<p>the truncation point, called <code class="reqn">k</code> in the details
section below.</p>
</td></tr>
<tr><td><code id="families_+3A_size">size</code></td>
<td>
<p>the sample size.  May be non-integer.</p>
</td></tr>
<tr><td><code id="families_+3A_sd">sd</code></td>
<td>
<p>the standard deviation.  May be non-integer.</p>
</td></tr>
<tr><td><code id="families_+3A_fam">fam</code></td>
<td>
<p>a family specification, which is a list of class <code>"astfam"</code>
containing, at least one element named <code>"name"</code> and perhaps other
elements specifying hyperparameters.</p>
</td></tr>
<tr><td><code id="families_+3A_deriv">deriv</code></td>
<td>
<p>derivative wanted: 0, 1, or 2.</p>
</td></tr>
<tr><td><code id="families_+3A_theta">theta</code></td>
<td>
<p>value of the canonical parameter.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Currently implemented families are
</p>

<dl>
<dt><code>"bernoulli"</code></dt><dd><p>Bernoulli.  The mean value parameter
<code class="reqn">\mu</code> is the success probability.  The canonical parameter is
<code class="reqn">\theta = \log(\mu) - \log(1 - \mu)</code>,
also called logit of <code class="reqn">\mu</code>.  The first derivative of the
cumulant function has the value <code class="reqn">\mu</code> and the second derivative
of the cumulant function has the value <code class="reqn">\mu (1 - \mu)</code>.</p>
</dd>
<dt><code>"poisson"</code></dt><dd><p>Poisson.  The mean value parameter
<code class="reqn">\mu</code> is the mean of the Poisson distribution.
The canonical parameter is <code class="reqn">\theta = \log(\mu)</code>.
The first and second derivatives of the cumulant function both have
the value <code class="reqn">\mu</code>.</p>
</dd>
<dt><code>"truncated.poisson"</code></dt><dd><p>Poisson conditioned on being
strictly greater than <code class="reqn">k</code>, specified by
the argument <code>truncation</code>.
Let <code class="reqn">\mu</code> be the mean of the corresponding untruncated
Poisson distribution.  Then the canonical parameters for both
truncated and untruncated distributions are the same
<code class="reqn">\theta = \log(\mu)</code>.
Let <code class="reqn">Y</code> be a Poisson random variable having the same mean parameter
as this distribution, and define
</p>
<p style="text-align: center;"><code class="reqn">\beta = \frac{\Pr\{Y &gt; k + 1\}}{\Pr\{Y = k + 1\}}</code>
</p>

<p>Then the mean value parameter and first derivative of the
cumulant function of this distribution has the value
</p>
<p style="text-align: center;"><code class="reqn">\tau = \mu + \frac{k + 1}{1 + \beta}</code>
</p>

<p>and the second derivative of the cumulant function has the value
</p>
<p style="text-align: center;"><code class="reqn">\mu \left[ 1 - \frac{k + 1}{1 + \beta} \left( 1 - \frac{k + 1}{\mu} \cdot \frac{\beta}{1 + \beta} \right) \right]</code>
</p>
<p>.</p>
</dd>
<dt><code>"negative.binomial"</code></dt><dd><p>Negative binomial.  The size parameter
<code class="reqn">\alpha</code> may be noninteger, meaning the cumulant function
is <code class="reqn">\alpha</code> times the cumulant function of the geometric
distribution.  The mean value parameter <code class="reqn">\mu</code> is the mean of
the negative binomial distribution.  The success probability parameter
is </p>
<p style="text-align: center;"><code class="reqn">p = \frac{\alpha}{\mu + \alpha}.</code>
</p>

<p>The canonical parameter
is <code class="reqn">\theta = \log(1 - p)</code>.
Since <code class="reqn">1 - p &lt; 1</code>, the canonical parameter space is restricted,
the set of <code class="reqn">\theta</code> such that <code class="reqn">\theta &lt; 0</code>.
This is, however, a
regular exponential family (the log likelihood goes to minus infinity
as <code class="reqn">\theta</code> converges to the boundary of the parameter space,
so the constraint <code class="reqn">\theta &lt; 0</code> plays no role in maximum
likelihood estimation so long as the optimization software is not too
stupid.  There will be no problems so long as the default optimizer
(<code><a href="trust.html#topic+trust">trust</a></code>) is used.  Since zero is not in the canonical
parameter space a negative default origin is used.  The first derivative
of the cumulant function has the value
</p>
<p style="text-align: center;"><code class="reqn">\mu = \alpha \frac{1 - p}{p}</code>
</p>

<p>and the second derivative has the value
</p>
<p style="text-align: center;"><code class="reqn">\alpha \frac{1 - p}{p^2}.</code>
</p>
</dd>
<dt><code>"truncated.negative.binomial"</code></dt><dd><p>Negative binomial conditioned
on being strictly greater than <code class="reqn">k</code>, specified by
the argument <code>truncation</code>.
Let <code class="reqn">p</code> be the success probability parameter of the corresponding
untruncated negative binomial distribution.  Then the canonical
parameters for both
truncated and untruncated distributions are the same
<code class="reqn">\theta = \log(1 - p)</code>, and consequently
the canonical parameter spaces are the same,
the set of <code class="reqn">\theta</code> such that <code class="reqn">\theta &lt; 0</code>,
and both models are regular exponential families.
Let <code class="reqn">Y</code> be an untruncated negative binomial random variable having
the same size and success probability parameters as this distribution.
and define
</p>
<p style="text-align: center;"><code class="reqn">\beta = \frac{\Pr\{Y &gt; k + 1\}}{\Pr\{Y = k + 1\}}</code>
</p>

<p>Then the mean value parameter and first derivative of the
cumulant function of this distribution has the value
</p>
<p style="text-align: center;"><code class="reqn">\tau = \mu + \frac{k + 1}{p (1 + \beta)}</code>
</p>

<p>and the second derivative is too complicated to write here (the
formula can be found in the vignette <code>trunc.pdf</code>.</p>
</dd>
<dt><code>"normal.location"</code></dt><dd><p>Normal, unknown mean, known variance.
The sd (standard deviation) parameter
<code class="reqn">\sigma</code> may be noninteger, meaning the cumulant function
is <code class="reqn">\sigma^2</code> times the cumulant function of the standard
normal distribution.  The mean value parameter <code class="reqn">\mu</code> is the
mean of the normal distribution.
The canonical parameter
is <code class="reqn">\theta = \mu / \sigma^2</code>.
The first derivative of the cumulant function has the value
</p>
<p style="text-align: center;"><code class="reqn">\mu = \sigma^2 \theta</code>
</p>

<p>and the second derivative has the value
</p>
<p style="text-align: center;"><code class="reqn">\sigma^2.</code>
</p>
</dd>
</dl>



<h3>Value</h3>

<p>For all but <code>fam.default</code>,
a list of class <code>"astfam"</code> giving name and values of any
hyperparameters.
For <code>fam.default</code>,
a list each element of which is of class <code>"astfam"</code>.
The list of families which were hard coded in earlier versions of the
package.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+aster">aster</a></code> and <code><a href="#topic+mlogl">mlogl</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>### mean of poisson with mean 0.2
famfun(fam.poisson(), 1, log(0.2))
### variance of poisson with mean 0.2
famfun(fam.poisson(), 2, log(0.2))
### mean of poisson with mean 0.2 conditioned on being nonzero
famfun(fam.truncated.poisson(trunc = 0), 1, log(0.2))
### variance of poisson with mean 0.2 conditioned on being nonzero
famfun(fam.truncated.poisson(trunc = 0), 2, log(0.2))
</code></pre>

<hr>
<h2 id='foobar'>Toy Life History Data having Directions of Recession</h2><span id='topic+foobar'></span>

<h3>Description</h3>

<p>Toy life history data created to exhibit the phenomenon of directions
of recession.   It was analyzed in a special topics course on aster models
Fall 2018.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(foobar)</code></pre>


<h3>Format</h3>

<p><code>data(foobar)</code> loads four R objects.
</p>

<dl>
<dt>fam</dt><dd><p>a vector of family indices.</p>
</dd>
<dt>pred</dt><dd><p>a vector of predecessor indices.</p>
</dd>
<dt>vars</dt><dd><p>a vector of variable names associated with the nodes
of the aster graph.</p>
</dd>
<dt>redata</dt><dd><p>a data frame having data on 300 individuals, each of
which has <code>length(vars) == 4</code> components of fitness,
so the aster graph for one individual has four nodes.  This data
frame is already in long format; no need to <code><a href="stats.html#topic+reshape">reshape</a></code>.
The variables in this data frame are:
</p>

<dl>
<dt>resp</dt><dd><p>the response vector.</p>
</dd>
<dt>varb</dt><dd><p>Categorical.  Gives node of graphical model corresponding
to each component of <code>resp</code>.  See details below.</p>
</dd>
<dt>root</dt><dd><p>All ones.  Root variables for graphical model.</p>
</dd>
<dt>id</dt><dd><p>Categorical.  Individual ID numbers.</p>
</dd>
<dt>trt</dt><dd><p>Categorical.  Treatment.</p>
</dd>
<dt>blk</dt><dd><p>Categorical.  Block.</p>
</dd>
<dt>fit</dt><dd><p>Bernoulli (zero-or-one-valued).  Indicator variable
of the fitness nodes
of the graph; in these data there is just one node for fitness.</p>
</dd>
</dl>

</dd>
</dl>



<h3>Details</h3>

<p>The levels of <code>varb</code> indicate nodes of the graphical model to which
the corresponding elements of the response vector <code>resp</code> belong.
This is the typical &ldquo;long&rdquo; format produced by the R <code>reshape</code>
function.  For each individual, there are several response variables.
All response variables are combined in one vector <code>resp</code>.
The variable <code>varb</code> indicates which &ldquo;original&rdquo; variable
the the corresponding component of the response vector was.
The variable <code>id</code> indicates which individual the corresponding
component of the response vector was.
</p>


<h3>Source</h3>

<p>Charles J. Geyer
<a href="http://www.stat.umn.edu/geyer/8931aster/foobar.rda">http://www.stat.umn.edu/geyer/8931aster/foobar.rda</a>
</p>


<h3>References</h3>

<p>These data are analyzed in deck 9 of the slides for a special topics
course on aster models taught fall semester 2018
(<a href="http://www.stat.umn.edu/geyer/8931aster/slides/s9.pdf">http://www.stat.umn.edu/geyer/8931aster/slides/s9.pdf</a>).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(foobar)
library(aster)
aout &lt;- aster(resp ~ varb + fit : (trt * blk), pred,
    fam, varb, id, root, data = redata)
foo &lt;- try(summary(aout))
# gives an error about directions of recession
# get directions of recession
dor &lt;- attr(foo, "condition")$dor
dor
# found one apparent direction of recession
# from regular pattern
# it looks like a true direction of recession
dor &lt;- dor / max(abs(dor))
dor
# but what does it do?  For that need to map to saturated model
# parameter space
modmat &lt;- aout$modmat
dim(modmat)
# oof!  modmat is three-dimensional.  Need an actual matrix here.
modmat &lt;- matrix(as.vector(modmat), ncol = length(dor))
dor.phi &lt;- drop(modmat %*% dor)
names(dor.phi) &lt;- with(redata, paste(id, as.character(varb), sep = "."))
dor.phi[dor.phi != 0]
fam.default()[fam[vars == "seeds"]]
# since the support of the Poisson distribution is bounded above,
# actually this must be minus the DOR (if it is a DOR at all).
# check that all components of response vector for which dor.phi == 1 are zero
# (lower bound of Poisson range)
all(redata$resp[dor.phi == 1] == 0)
# so minus dor.phi is a true direction of recession in the saturated model
# canonical parameter space, and minus dor is a true direction of recession
# in the submodel canonical parameter space
#
# try to get more info
trt.blk &lt;- with(redata,
    paste(as.character(trt), as.character(blk), sep = "."))
unique(trt.blk[dor.phi == 1])
# the reason for the direction of recession is that every individual getting
# treatment a in block A had zero seeds.
#
# the reason the submodel DOR, R object dor, was so hard to interpret was
# because fit:trta:blkA is not in the model.  So let's force it in
redata &lt;- transform(redata, trt = relevel(trt, ref = "b"),
    blk = relevel(blk, ref = "B"))
# Note: following code is copied exactly from above.  Only difference
# is releveling in the immediately preceding statement
aout &lt;- aster(resp ~ varb + fit : (trt * blk), pred,
    fam, varb, id, root, data = redata)
foo &lt;- try(summary(aout))
dor &lt;- attr(foo, "condition")$dor
dor &lt;- dor / max(abs(dor))
dor
# now it is obvious from looking at this dor that all individuals in trt a
# and blk A are at the lower end (zero) of the Poisson range.
# maybe the other dor we had previously would be "obvious" to someone
# sufficiently skilled in understanding the meaning of regression coefficients
# but not "obvious" to your humble author
#
# as for what to do about this, see the course slides cited in the reference
# section.  There is no single Right Thing to do.
</code></pre>

<hr>
<h2 id='mlogl'>Minus Log Likelihood for Aster Models</h2><span id='topic+mlogl'></span>

<h3>Description</h3>

<p>Minus the Log Likelihood for an Aster model, and its first and second
derivative.  This function is called inside R function <code><a href="#topic+aster">aster</a></code>.
Users generally do not need to call it directly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mlogl(parm, pred, fam, x, root, modmat, deriv = 0,
    type = c("unconditional", "conditional"), famlist = fam.default(),
    origin, origin.type = c("model.type", "unconditional", "conditional"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mlogl_+3A_parm">parm</code></td>
<td>
<p>parameter value (vector of regression coefficients)
where we evaluate the log likelihood, etc.
We also refer to <code>length(parm)</code> as <code>ncoef</code>.</p>
</td></tr>
<tr><td><code id="mlogl_+3A_pred">pred</code></td>
<td>
<p>integer vector determining the graph.
<code>pred[j]</code> is the index of the predecessor of
the node with index <code>j</code> unless the predecessor is a root
node, in which case <code>pred[j] == 0</code>.
We also refer to <code>length(pred)</code> as <code>nnode</code>.
This argument is required to satisfy <code>pred[j] &lt; j</code> for all <code>j</code>.</p>
</td></tr>
<tr><td><code id="mlogl_+3A_fam">fam</code></td>
<td>
<p>an integer vector of length <code>nnode</code> determining
the exponential family structure of the aster model.  Each element
is an index into the vector of family specifications given by
the argument <code>famlist</code>.</p>
</td></tr>
<tr><td><code id="mlogl_+3A_x">x</code></td>
<td>
<p>the response.  If a matrix, rows are individuals, and columns are
variables (nodes of graphical model).  So <code>ncol(x) == nnode</code> and
we also refer to <code>nrow(x)</code> as <code>nind</code>.  If not a matrix, then
<code>x</code> must be as if it were such a matrix and then dimension
information removed by <code>x = as.numeric(x)</code>.</p>
</td></tr>
<tr><td><code id="mlogl_+3A_root">root</code></td>
<td>
<p>A matrix or vector like <code>x</code>.
Data <code>root[i, j]</code> is the data for a root node that is
the predecessor of the response <code>x[i, j]</code>
and is ignored when <code>pred[j] &gt; 0</code>.</p>
</td></tr>
<tr><td><code id="mlogl_+3A_modmat">modmat</code></td>
<td>
<p>a three-dimensional array, <code>nind</code> by <code>nnode</code> by
<code>ncoef</code>, the model matrix.  Or a matrix, <code>nind * nnode</code> by
<code>ncoef</code> (when <code>x</code> and <code>root</code> are one-dimensional
of length <code>nind * nnode</code>).</p>
</td></tr>
<tr><td><code id="mlogl_+3A_deriv">deriv</code></td>
<td>
<p>derivatives wanted: 0, 1, or 2.</p>
</td></tr>
<tr><td><code id="mlogl_+3A_type">type</code></td>
<td>
<p>type of model.  The value of this argument can be abbreviated.</p>
</td></tr>
<tr><td><code id="mlogl_+3A_famlist">famlist</code></td>
<td>
<p>a list of family specifications (see <code><a href="#topic+families">families</a></code>).</p>
</td></tr>
<tr><td><code id="mlogl_+3A_origin">origin</code></td>
<td>
<p>Distinguished point in parameter space.  May be missing,
in which case an unspecified default is provided.  See <code><a href="#topic+aster">aster</a></code>
for further explanation.</p>
</td></tr>
<tr><td><code id="mlogl_+3A_origin.type">origin.type</code></td>
<td>
<p>Parameter space in which specified distinguished point
is located.  If <code>"conditional"</code> then argument <code>"origin"</code> is
a conditional canonical parameter value.
If <code>"unconditional"</code> then argument <code>"origin"</code> is
an unconditional canonical parameter value.
If <code>"model.type"</code> then the type is taken from argument <code>"type"</code>.
The value of this argument can be abbreviated.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list containing some of the following components:
</p>
<table>
<tr><td><code>value</code></td>
<td>
<p>minus the log likelihood.</p>
</td></tr>
<tr><td><code>gradient</code></td>
<td>
<p>minus the first derivative vector of the log likelihood
(minus the score).</p>
</td></tr>
<tr><td><code>hessian</code></td>
<td>
<p>minus the second derivative matrix of the log likelihood
(observed Fisher information).</p>
</td></tr>
</table>

<hr>
<h2 id='newpickle'>Penalized Quasi-Likelihood for Aster Models</h2><span id='topic+newpickle'></span>

<h3>Description</h3>

<p>Evaluates the objective function for approximate maximum likelihood for
an aster model with random effects.  Uses Laplace approximation to
integrate out the random effects analytically.
The &ldquo;quasi&rdquo; in the title is a misnomer in the context of aster
models but the acronym PQL for this procedure is well-established in
the generalized linear mixed models literature.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>newpickle(alphaceesigma, fixed, random, obj, y, origin, zwz, deriv = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="newpickle_+3A_alphaceesigma">alphaceesigma</code></td>
<td>
<p>the parameter value where the function is evaluated,
a numeric vector, see details.</p>
</td></tr>
<tr><td><code id="newpickle_+3A_fixed">fixed</code></td>
<td>
<p>the model matrix for fixed effects.  The number of rows
is <code>nrow(obj$data)</code>.  The number of columns is the number of fixed
effects.</p>
</td></tr>
<tr><td><code id="newpickle_+3A_random">random</code></td>
<td>
<p>the model matrix or matrices for random effects.
The number of rows is <code>nrow(obj$data)</code>.  The number of columns
is the number of random effects in a group.  Either a matrix or a list
each element of which is a matrix.</p>
</td></tr>
<tr><td><code id="newpickle_+3A_obj">obj</code></td>
<td>
<p>aster model object, the result of a call to <code><a href="#topic+aster">aster</a></code>.</p>
</td></tr>
<tr><td><code id="newpickle_+3A_y">y</code></td>
<td>
<p>response vector.  May be omitted, in which case <code>obj$x</code>
is used.  If supplied, must be a matrix of the same dimensions as
<code>obj$x</code>.</p>
</td></tr>
<tr><td><code id="newpickle_+3A_origin">origin</code></td>
<td>
<p>origin of aster model.  May be omitted, in which case
default origin (see <code><a href="#topic+aster">aster</a></code>) is used.  If supplied, must be
a matrix of the same dimensions <code>obj$x</code>.</p>
</td></tr>
<tr><td><code id="newpickle_+3A_zwz">zwz</code></td>
<td>
<p>A possible value of <code class="reqn">Z^T W Z</code>, where <code class="reqn">Z</code> is the
model matrix for all random effects and <code class="reqn">W</code> is the variance matrix of
the response.  May be missing, in which case it is calculated from
<code>alphaceesigma</code>.  See details.</p>
</td></tr>
<tr><td><code id="newpickle_+3A_deriv">deriv</code></td>
<td>
<p>Number of derivatives wanted, either zero or one.
Must be zero if <code>zwz</code> is missing.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Define
</p>
<p style="text-align: center;"><code class="reqn">p(\alpha, c, \sigma) = m(a + M \alpha + Z A c) + c^T c / 2 + \log \det[A Z^T W(a + M \alpha + Z A c) Z A + I]</code>
</p>

<p>where <code class="reqn">m</code> is minus the log likelihood function of a saturated aster model,
where <code class="reqn">W</code> is the Hessian matrix of <code class="reqn">m</code>,
where <code class="reqn">a</code> is a known vector (the <em>offset vector</em> in the terminology
of <code><a href="stats.html#topic+glm">glm</a></code> but the <em>origin</em> in the terminology
of <code><a href="#topic+aster">aster</a></code>), where <code class="reqn">M</code> is a known matrix, the model matrix for
fixed effects (the argument <code>fixed</code> of this function),
<code class="reqn">Z</code> is a known matrix, the model matrix for random effects
(either the argument <code>random</code> of this functions if it is a matrix or
<code>Reduce(cbind, random)</code> if <code>random</code> is a list of matrices),
where <code class="reqn">A</code> is a diagonal matrix whose diagonal is the vector
<code>rep(sigma, times = nrand)</code>
where <code>nrand</code> is <code>sapply(random, ncol)</code>
when <code>random</code> is a list of
matrices and <code>ncol(random)</code> when <code>random</code> is a matrix,
and where <code class="reqn">I</code> is the identity matrix.
This function evaluates <code class="reqn">p(\alpha, c, \sigma)</code>
when <code>zwz</code> is missing.
Otherwise it evaluates the same thing except that
</p>
<p style="text-align: center;"><code class="reqn">Z^T W(a + M \alpha + Z A c) Z</code>
</p>

<p>is replaced by <code>zwz</code>.
Note that <code class="reqn">A</code> is a function of <code class="reqn">\sigma</code> although the
notation does not explicitly indicate this.
</p>


<h3>Value</h3>

<p>a list with components <code>value</code> and <code>gradient</code>,
the latter missing if <code>deriv == 0</code>.
</p>


<h3>Note</h3>

<p>Not intended for use by naive users.  Use <code><a href="#topic+reaster">reaster</a></code>.
Actually no longer used by other functions in this package.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(radish)

pred &lt;- c(0,1,2)
fam &lt;- c(1,3,2)

### need object of type aster to supply to penmlogl and pickle

aout &lt;- aster(resp ~ varb + fit : (Site * Region + Block + Pop),
    pred, fam, varb, id, root, data = radish)

### model matrices for fixed and random effects

modmat.fix &lt;- model.matrix(resp ~ varb + fit : (Site * Region),
    data = radish)
modmat.blk &lt;- model.matrix(resp ~ 0 + fit:Block, data = radish)
modmat.pop &lt;- model.matrix(resp ~ 0 + fit:Pop, data = radish)

rownames(modmat.fix) &lt;- NULL
rownames(modmat.blk) &lt;- NULL
rownames(modmat.pop) &lt;- NULL

idrop &lt;- match(aout$dropped, colnames(modmat.fix))
idrop &lt;- idrop[! is.na(idrop)]
modmat.fix &lt;- modmat.fix[ , - idrop]

nfix &lt;- ncol(modmat.fix)
nblk &lt;- ncol(modmat.blk)
npop &lt;- ncol(modmat.pop)

alpha.start &lt;- aout$coefficients[match(colnames(modmat.fix),
    names(aout$coefficients))]
cee.start &lt;- rep(0, nblk + npop)
sigma.start &lt;- rep(1, 2)
alphaceesigma.start &lt;- c(alpha.start, cee.start, sigma.start)

foo &lt;- newpickle(alphaceesigma.start, fixed = modmat.fix,
    random = list(modmat.blk, modmat.pop), obj = aout)
</code></pre>

<hr>
<h2 id='oats'>Life History Data on Avena barbata</h2><span id='topic+oats'></span>

<h3>Description</h3>

<p>Data on life history traits for the 
invasive California wild oat <em>Avena barbata</em>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(oats)</code></pre>


<h3>Format</h3>

<p>A data frame with records for 821 plants.
Data are already in &ldquo;long&rdquo; format; no need to reshape.
</p>

<dl>
<dt>resp</dt><dd><p>Response vector.</p>
</dd>
<dt>varb</dt><dd><p>Categorical.  Gives node of graphical model corresponding
to each component of <code>resp</code>.  See details below.</p>
</dd>
<dt>root</dt><dd><p>All ones.  Root variables for graphical model.</p>
</dd>
<dt>id</dt><dd><p>Categorical.  Indicates individual plants.</p>
</dd>
<dt>Plant.id</dt><dd><p>Categorical.  Another indicator of individual plants.</p>
</dd>
<dt>Env</dt><dd><p>Categorical.  Environment in which plant was grown, a
combination of experimental site and year.</p>
</dd>
<dt>Gen</dt><dd><p>Categorical.  Ecotype of plant: mesic (M) or xeric (X).</p>
</dd>
<dt>Fam</dt><dd><p>Categorical.  Accession, nested within ecotype.</p>
</dd>
<dt>Site</dt><dd><p>Categorical.  Experiment site.  Two sites in these data.</p>
</dd>
<dt>Year</dt><dd><p>Categorical.  Year in which data were collected.
Four years in these data.</p>
</dd>
<dt>fit</dt><dd><p>Indicator (zero or one).  Shorthand
for <code>as.numeric(oats$varb == "Spike")</code>.  So-called because the
components of <code>outcome</code> indicated are the best surrogate of
Darwinian fitness in these data.</p>
</dd>
</dl>



<h3>Details</h3>

<p>The levels of <code>varb</code> indicate nodes of the graphical model to which
the corresponding elements of the response vector <code>resp</code> belong.
This is the typical &ldquo;long&rdquo; format produced by the R <code>reshape</code>
function.  For each individual, there are several response variables.
All response variables are combined in one vector <code>resp</code>.
The variable <code>varb</code> indicates which &ldquo;original&rdquo; variable
the number was for.  The variable <code>id</code> indicates which individual
the number was for.  The levels of <code>varb</code>, which are the names
of the &ldquo;original&rdquo; variables are
</p>

<dl>
<dt>Surv</dt><dd><p>Indicator (zero or one).  Bernoulli, One if individual
survived to produce flowers.</p>
</dd>
<dt>Spike</dt><dd><p>Integer.  Zero-truncated Poisson, number of spikelets
(compound floral structures) observed.</p>
</dd>
</dl>

<p>Graphical model is
</p>
<p style="text-align: center;"><code class="reqn">1 \longrightarrow \mbox{Surv} \longrightarrow \mbox{Spike}</code>
</p>



<h3>Source</h3>

<p>Robert Latta
<a href="https://www.dal.ca/faculty/science/biology/faculty-staff/our-faculty/robert-latta.html">https://www.dal.ca/faculty/science/biology/faculty-staff/our-faculty/robert-latta.html</a>
</p>


<h3>References</h3>

<p>These data are a subset of data previously analyzed using non-aster methods
in the following.
</p>
<p>Latta, R. G. (2009).
Testing for local adaptation in <em>Avena barbata</em>,
a classic example of ecotypic divergence.
<em>Molecular Ecology</em>, <b>18</b>, 3781&ndash;3791.
<a href="https://doi.org/10.1111/j.1365-294X.2009.04302.x">doi:10.1111/j.1365-294X.2009.04302.x</a>.
</p>
<p>These data are reanalyzed by aster methods in the following.
</p>
<p>Geyer, C. J., Ridley, C. E., Latta, R. G., Etterson, J. R.,
and Shaw, R. G. (2013)
Local Adaptation and Genetic Effects on Fitness: Calculations
for Exponential Family Models with Random Effects.
<em>Annals of Applied Statistics</em>, <b>7</b>, 1778&ndash;1795.
<a href="https://doi.org/10.1214/13-AOAS653">doi:10.1214/13-AOAS653</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(oats)
</code></pre>

<hr>
<h2 id='penmlogl'>Penalized Minus Log Likelihood for Aster Models</h2><span id='topic+penmlogl'></span><span id='topic+penmlogl2'></span>

<h3>Description</h3>

<p>Penalized minus log likelihood for an aster model, and its first and second
derivative.  The penalization allows for (approximate) random effects.
These functions are called inside <code><a href="#topic+pickle">pickle</a></code>,
<code><a href="#topic+pickle1">pickle1</a></code>, <code><a href="#topic+pickle2">pickle2</a></code>, <code><a href="#topic+pickle3">pickle3</a></code>,
and <code><a href="#topic+reaster">reaster</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>penmlogl(parm, sigma, fixed, random, obj, y, origin, deriv = 2)
penmlogl2(parm, alpha, sigma, fixed, random, obj, y, origin)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="penmlogl_+3A_parm">parm</code></td>
<td>
<p>for <code>penmlogl</code>, parameter value (vector of regression
coefficients and rescaled random effects) at which we evaluate the
penalized log likelihood.  For <code>penmlogl2</code> the vector of rescaled
random effects only (see next item).</p>
</td></tr>
<tr><td><code id="penmlogl_+3A_alpha">alpha</code></td>
<td>
<p>the vector of fixed effects.  For <code>penmlogl2</code>, the
concatenation <code>c(alpha, parm)</code> is the same as <code>parm</code> that
is supplied to <code>pemnmlogl</code>.</p>
</td></tr>
<tr><td><code id="penmlogl_+3A_sigma">sigma</code></td>
<td>
<p>vector of square roots of variance components, one component
for each group of random effects.</p>
</td></tr>
<tr><td><code id="penmlogl_+3A_fixed">fixed</code></td>
<td>
<p>the model matrix for fixed effects.  The number of rows
is <code>nrow(obj$data)</code>.
The number of columns is the number of fixed effects.</p>
</td></tr>
<tr><td><code id="penmlogl_+3A_random">random</code></td>
<td>
<p>the model matrix or matrices for random effects.
Each has the same number of rows as <code>fixed</code>.  The number of columns
is the number of random effects in a group.  Either a matrix or a list
of matrices.</p>
</td></tr>
<tr><td><code id="penmlogl_+3A_obj">obj</code></td>
<td>
<p>aster model object, the result of a call to <code><a href="#topic+aster">aster</a></code>.</p>
</td></tr>
<tr><td><code id="penmlogl_+3A_y">y</code></td>
<td>
<p>response vector.  May be omitted, in which case <code>obj$x</code>
is used.  If supplied, must be a matrix of the same dimensions as
<code>obj$x</code>.</p>
</td></tr>
<tr><td><code id="penmlogl_+3A_origin">origin</code></td>
<td>
<p>origin of aster model.  May be omitted, in which case
default origin (see <code><a href="#topic+aster">aster</a></code>) is used.  If supplied, must be
a matrix of the same dimensions <code>obj$x</code>.</p>
</td></tr>
<tr><td><code id="penmlogl_+3A_deriv">deriv</code></td>
<td>
<p>number of derivatives wanted.  Allowed values are 0, 1, or 2.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Consider an aster model with random effects and canonical parameter vector
of the form
</p>
<p style="text-align: center;"><code class="reqn">M \alpha + Z_1 b_1 + \cdots + Z_k b_k</code>
</p>

<p>where <code class="reqn">M</code> and each <code class="reqn">Z_j</code> are known matrices having the same
row dimension, where <code class="reqn">\alpha</code> is a vector of unknown parameters
(the fixed effects) and each <code class="reqn">b_j</code> is a vector of random effects
that are supposed to be (marginally) independent and identically distributed
mean-zero normal with variance <code>sigma[j]^2</code>.
</p>
<p>These functions evaluate minus the &ldquo;penalized log likelihood&rdquo;
for this model, which considers the random effects as parameters but
adds a penalization term
</p>
<p style="text-align: center;"><code class="reqn">b_1^2 / (2 \sigma_1^2) + \cdots + b_k^2 / (2 \sigma_k^2)</code>
</p>

<p>to minus the log likelihood.
</p>
<p>To properly deal with random effects that are zero, random effects
are rescaled by their standard deviation.
The rescaled random effects are
<code class="reqn">c_i = b_i / \sigma_i</code>.
If <code class="reqn">\sigma_i = 0</code>, then the corresponding rescaled
random effects <code class="reqn">c_i</code> are also zero.
</p>


<h3>Value</h3>

<p>a list containing some of the following components:
</p>
<table>
<tr><td><code>value</code></td>
<td>
<p>minus the penalized log likelihood.</p>
</td></tr>
<tr><td><code>gradient</code></td>
<td>
<p>minus the first derivative vector of the penalized
log likelihood.</p>
</td></tr>
<tr><td><code>hessian</code></td>
<td>
<p>minus the second derivative matrix of the penalized
log likelihood.</p>
</td></tr>
<tr><td><code>argument</code></td>
<td>
<p>the value of the <code>parm</code> argument for this function.</p>
</td></tr>
<tr><td><code>scale</code></td>
<td>
<p>the vector by which <code>parm</code> must be scaled to obtain
the true random effects.</p>
</td></tr>
<tr><td><code>mlogl.gradient</code></td>
<td>
<p>gradient for evaluation of log likelihood;
<code>gradient</code> is this plus gradient of penalty.</p>
</td></tr>
<tr><td><code>mlogl.hessian</code></td>
<td>
<p>hessian for evaluation of log likelihood;
<code>hessian</code> is this plus hessian of penalty.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Not intended for use by naive users.  Use <code><a href="#topic+reaster">reaster</a></code>,
which calls them.
</p>


<h3>See Also</h3>

<p>For an example using this function see the example
for <code><a href="#topic+pickle">pickle</a></code>.</p>

<hr>
<h2 id='pickle'>Penalized Quasi-Likelihood for Aster Models</h2><span id='topic+pickle'></span><span id='topic+pickle1'></span><span id='topic+pickle2'></span><span id='topic+pickle3'></span><span id='topic+makezwz'></span>

<h3>Description</h3>

<p>Evaluates an approximation to minus the log likelihood for an
aster model with random effects.  Uses Laplace approximation to
integrate out the random effects analytically.
The &ldquo;quasi&rdquo; in the title is a misnomer in the context of aster
models but the acronym PQL for this procedure is well-established in
the generalized linear mixed models literature.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pickle(sigma, parm, fixed, random, obj, y, origin, cache, ...)
makezwz(sigma, parm, fixed, random, obj, y, origin)
pickle1(sigma, parm, fixed, random, obj, y, origin, cache, zwz,
    deriv = 0, ...)
pickle2(alphasigma, parm, fixed, random, obj, y, origin, cache, zwz,
    deriv = 0, ...)
pickle3(alphaceesigma, fixed, random, obj, y, origin, zwz, deriv = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pickle_+3A_sigma">sigma</code></td>
<td>
<p>vector of square roots of variance components,
one component for each group of random effects.  Negative values are
allowed; the vector of variance components is <code>sigma^2</code>.</p>
</td></tr>
<tr><td><code id="pickle_+3A_parm">parm</code></td>
<td>
<p>starting value for inner optimization.  Ignored if
<code>cache$parm</code> exists, in which case the latter is used.
For <code>pickle</code> and <code>pickle1</code>, length
is number of effects (fixed and random).
For <code>pickle2</code>, length
is number of random effects.   For all, random effects are rescaled,
divided by the corresponding component of <code>sigma</code> if that is
nonzero and equal to zero otherwise.</p>
</td></tr>
<tr><td><code id="pickle_+3A_alphasigma">alphasigma</code></td>
<td>
<p>the concatenation of the vector of fixed effects
and the vector of square roots of variance components.</p>
</td></tr>
<tr><td><code id="pickle_+3A_alphaceesigma">alphaceesigma</code></td>
<td>
<p>the concatenation of the vector of fixed effects,
the vector of rescaled random effects,
and the vector of square roots of variance components.</p>
</td></tr>
<tr><td><code id="pickle_+3A_fixed">fixed</code></td>
<td>
<p>the model matrix for fixed effects.  The number of rows
is <code>nrow(obj$data)</code>.  The number of columns is the number of fixed
effects.</p>
</td></tr>
<tr><td><code id="pickle_+3A_random">random</code></td>
<td>
<p>the model matrix or matrices for random effects.
The number of rows is <code>nrow(obj$data)</code>.  The number of columns
is the number of random effects in a group.  Either a matrix or a list
each element of which is a matrix.</p>
</td></tr>
<tr><td><code id="pickle_+3A_obj">obj</code></td>
<td>
<p>aster model object, the result of a call to <code><a href="#topic+aster">aster</a></code>.</p>
</td></tr>
<tr><td><code id="pickle_+3A_y">y</code></td>
<td>
<p>response vector.  May be omitted, in which case <code>obj$x</code>
is used.  If supplied, must be a matrix of the same dimensions as
<code>obj$x</code>.</p>
</td></tr>
<tr><td><code id="pickle_+3A_origin">origin</code></td>
<td>
<p>origin of aster model.  May be omitted, in which case
default origin (see <code><a href="#topic+aster">aster</a></code>) is used.  If supplied, must be
a matrix of the same dimensions <code>obj$x</code>.</p>
</td></tr>
<tr><td><code id="pickle_+3A_cache">cache</code></td>
<td>
<p>If not missing, an environment in which to cache the value
of <code>parm</code> found during previous evaluations.  If supplied <code>parm</code>
is taken from <code>cache</code>.</p>
</td></tr>
<tr><td><code id="pickle_+3A_zwz">zwz</code></td>
<td>
<p>A possible value of <code class="reqn">Z^T W Z</code>, where <code class="reqn">Z</code> is the
model matrix for all random effects and <code class="reqn">W</code> is the variance matrix of
the response.</p>
</td></tr>
<tr><td><code id="pickle_+3A_deriv">deriv</code></td>
<td>
<p>Number of derivatives wanted.  For <code>pickle1</code>
or <code>pickle2</code>, either zero or one.  For <code>pickle3</code>,
zero, one or two.</p>
</td></tr>
<tr><td><code id="pickle_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code><a href="trust.html#topic+trust">trust</a></code>, which
is used to maximize the penalized log likelihood.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Define
</p>
<p style="text-align: center;"><code class="reqn">p(\alpha, c, \sigma) = m(a + M \alpha + Z A c) + c^T c / 2 + \log \det[A Z^T \widehat{W} Z A + I] / 2</code>
</p>

<p>where <code class="reqn">m</code> is minus the log likelihood function of a saturated aster model,
<code class="reqn">a</code> is a known vector (the <em>offset vector</em> in the terminology
of <code><a href="stats.html#topic+glm">glm</a></code> but the <em>origin</em> in the terminology
of <code><a href="#topic+aster">aster</a></code>), <code class="reqn">M</code> is a known matrix, the model matrix for
fixed effects (the argument <code>fixed</code> of these functions),
<code class="reqn">Z</code> is a known matrix, the model matrix for random effects
(either the argument <code>random</code> of these functions if it is a matrix or
<code>Reduce(cbind, random)</code> if <code>random</code> is a list of matrices),
<code class="reqn">A</code> is a diagonal matrix whose diagonal is the vector
<code>rep(sigma, times = nrand)</code>
where <code>nrand</code> is <code>sapply(random, ncol)</code>
when <code>random</code> is a list of
matrices and <code>ncol(random)</code> when <code>random</code> is a matrix,
<code class="reqn">\widehat{W}</code> is any symmetric positive semidefinite matrix
(more on this below),
and <code class="reqn">I</code> is the identity matrix.
Note that <code class="reqn">A</code> is a function of <code class="reqn">\sigma</code> although the
notation does not explicitly indicate this.
</p>
<p>Let <code class="reqn">c^*</code> denote the minimizer of
<code class="reqn">p(\alpha, c, \sigma)</code> considered as a function of <code class="reqn">c</code>
for fixed <code class="reqn">\alpha</code> and <code class="reqn">\sigma</code>,
and let <code class="reqn">\tilde{\alpha}</code> and <code class="reqn">\tilde{c}</code>
denote the (joint) minimizers of <code class="reqn">p(\alpha, c, \sigma)</code> considered as
a function of <code class="reqn">\alpha</code> and <code class="reqn">c</code> for fixed <code class="reqn">\sigma</code>.
Note that <code class="reqn">c^*</code> is a function of <code class="reqn">\alpha</code>
and <code class="reqn">\sigma</code> although the notation does not explicitly
indicate this.
Note that <code class="reqn">\tilde{\alpha}</code> and <code class="reqn">\tilde{c}</code>
are functions of <code class="reqn">\sigma</code> (only) although the notation
does not explicitly indicate this.
Now define
</p>
<p style="text-align: center;"><code class="reqn">q(\alpha, \sigma) = p(\alpha, c^*, \sigma)</code>
</p>

<p>and
</p>
<p style="text-align: center;"><code class="reqn">r(\sigma) = p(\tilde{\alpha}, \tilde{c}, \sigma)</code>
</p>

<p>Then <code>pickle1</code> evaluates <code class="reqn">r(\sigma)</code>,
<code>pickle2</code> evaluates <code class="reqn">q(\alpha, \sigma)</code>, and
<code>pickle3</code> evaluates <code class="reqn">p(\alpha, c, \sigma)</code>,
where <code class="reqn">Z^T \widehat{W} Z</code> in the formulas above is
specified by the argument <code>zwz</code> of these functions.
All of these functions supply derivative (gradient) vectors if
<code>deriv = 1</code> is specified, and <code>pickle3</code> supplies the
second derivative (Hessian) matrix if <code>deriv = 2</code> is specified.
</p>
<p>Let <code class="reqn">W</code> denote the second derivative function of <code class="reqn">m</code>, that is,
<code class="reqn">W(\varphi)</code> is the second derivative matrix of the function
<code class="reqn">m</code> evaluated at the point <code class="reqn">\varphi</code>.  The idea is that
<code class="reqn">\widehat{W}</code> should be approximately the value of
<code class="reqn">W(a + M \hat{\alpha} + Z \widehat{A} \hat{c})</code>,
where <code class="reqn">\hat{\alpha}</code>, <code class="reqn">\hat{c}</code>,
and <code class="reqn">\hat{\sigma}</code> are the (joint) minimizers of <code class="reqn">p(\alpha, c, \sigma)</code>
and <code class="reqn">\widehat{A} = A(\hat{\sigma})</code>.
In aid of this, the function <code>makezwz</code>
evaluates
<code class="reqn">Z^T W(a + M \alpha + Z A c) Z</code>
for any <code class="reqn">\alpha</code>, <code class="reqn">c</code>, and <code class="reqn">\sigma</code>.
</p>
<p><code>pickle</code> evaluates the function
</p>
<p style="text-align: center;"><code class="reqn">s(\sigma) = m(a + M \tilde{\alpha} + Z A \tilde{c}) + \tilde{c}^T \tilde{c} / 2 + \log \det[A Z^T W(a + M \tilde{\alpha} + Z A \tilde{c}) Z A + I]</code>
</p>

<p>no derivatives can be computed because no derivatives of the function
<code class="reqn">W</code> are computed for aster models.
</p>
<p>The general idea is the one uses <code>pickle</code> with a no-derivative
optimizer, such as the <code>"Nelder-Mead"</code> method of the <code>optim</code>
function to get a crude estimate of <code class="reqn">\hat{\sigma}</code>.
Then one uses <code><a href="trust.html#topic+trust">trust</a></code> with objective
function <code><a href="#topic+penmlogl">penmlogl</a></code> to estimate the corresponding
<code class="reqn">\hat{\alpha}</code> and <code class="reqn">\hat{c}</code> (example below).
Then one use <code>makezwz</code> to produce the corresponding <code>zwz</code>
(example below).
These estimates can be improved using <code><a href="trust.html#topic+trust">trust</a></code> with objective
function <code>pickle3</code> using this <code>zwz</code> (example below), and this
step may be iterated until convergence.
Finally, <code><a href="stats.html#topic+optim">optim</a></code> is used with objective function <code>pickle2</code>
to estimate the Hessian matrix of <code class="reqn">q(\alpha, \sigma)</code>,
which is approximate observed information because
<code class="reqn">q(\alpha, \sigma)</code> is approximate minus log likelihood.
</p>


<h3>Value</h3>

<p>For <code>pickle</code>, a scalar, minus the
(PQL approximation of) the log likelihood.
For <code>pickle1</code> and <code>pickle2</code>, a list having components <code>value</code>
and <code>gradient</code> (present only when <code>deriv = 1</code>).
For <code>pickle3</code>, a list having components <code>value</code>,
<code>gradient</code> (present only when <code>deriv &gt;= 1</code>),
and <code>hessian</code> (present only when <code>deriv = 2</code>).
</p>


<h3>Note</h3>

<p>Not intended for use by naive users.  Use <code><a href="#topic+reaster">reaster</a></code>,
which calls them.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(radish)
library(trust)

pred &lt;- c(0,1,2)
fam &lt;- c(1,3,2)

### need object of type aster to supply to penmlogl and pickle

aout &lt;- aster(resp ~ varb + fit : (Site * Region + Block + Pop),
    pred, fam, varb, id, root, data = radish)

### model matrices for fixed and random effects

modmat.fix &lt;- model.matrix(resp ~ varb + fit : (Site * Region),
    data = radish)
modmat.blk &lt;- model.matrix(resp ~ 0 + fit:Block, data = radish)
modmat.pop &lt;- model.matrix(resp ~ 0 + fit:Pop, data = radish)

rownames(modmat.fix) &lt;- NULL
rownames(modmat.blk) &lt;- NULL
rownames(modmat.pop) &lt;- NULL

idrop &lt;- match(aout$dropped, colnames(modmat.fix))
idrop &lt;- idrop[! is.na(idrop)]
modmat.fix &lt;- modmat.fix[ , - idrop]

nfix &lt;- ncol(modmat.fix)
nblk &lt;- ncol(modmat.blk)
npop &lt;- ncol(modmat.pop)

### try penmlogl

sigma.start &lt;- c(1, 1)

alpha.start &lt;- aout$coefficients[match(colnames(modmat.fix),
    names(aout$coefficients))]
parm.start &lt;- c(alpha.start, rep(0, nblk + npop))

tout &lt;- trust(objfun = penmlogl, parm.start, rinit = 1, rmax = 10,
    sigma = sigma.start, fixed = modmat.fix,
    random = list(modmat.blk, modmat.pop), obj = aout)
tout$converged

### crude estimate of variance components

eff.blk &lt;- tout$argument[seq(nfix + 1, nfix + nblk)]
eff.pop &lt;- tout$argument[seq(nfix + nblk + 1, nfix + nblk + npop)]
sigma.crude &lt;- sqrt(c(var(eff.blk), var(eff.pop)))

### try optim and pickle

cache &lt;- new.env(parent = emptyenv())
oout &lt;- optim(sigma.crude, pickle, parm = tout$argument,
    fixed = modmat.fix, random = list(modmat.blk, modmat.pop),
    obj = aout, cache = cache)
oout$convergence == 0
### estimated variance components
oout$par^2

### get estimates of fixed and random effects

tout &lt;- trust(objfun = penmlogl, tout$argument, rinit = 1, rmax = 10,
    sigma = oout$par, fixed = modmat.fix,
    random = list(modmat.blk, modmat.pop), obj = aout, fterm = 0)
tout$converged

sigma.better &lt;- oout$par
alpha.better &lt;- tout$argument[1:nfix]
c.better &lt;- tout$argument[- (1:nfix)]
zwz.better &lt;- makezwz(sigma.better, parm = c(alpha.better, c.better),
    fixed = modmat.fix, random = list(modmat.blk, modmat.pop), obj = aout)

### get better estimates

objfun &lt;- function(alphaceesigma, zwz)
    pickle3(alphaceesigma, fixed = modmat.fix,
    random = list(modmat.blk, modmat.pop), obj = aout, zwz = zwz, deriv = 2)
tout &lt;- trust(objfun, c(alpha.better, c.better, sigma.better),
    rinit = 1, rmax = 10, zwz = zwz.better)
tout$converged
alpha.mle &lt;- tout$argument[1:nfix]
c.mle &lt;- tout$argument[nfix + 1:(nblk + npop)]
sigma.mle &lt;- tout$argument[nfix + nblk + npop + 1:2]
zwz.mle &lt;- makezwz(sigma.mle, parm = c(alpha.mle, c.mle),
    fixed = modmat.fix, random = list(modmat.blk, modmat.pop), obj = aout)
### estimated variance components
sigma.mle^2

### preceding step can be iterated "until convergence"

### get (approximate) Fisher information

objfun &lt;- function(alphasigma) pickle2(alphasigma, parm = c.mle,
    fixed = modmat.fix, random = list(modmat.blk, modmat.pop),
    obj = aout, zwz = zwz.mle)$value
gradfun &lt;- function(alphasigma) pickle2(alphasigma, parm = c.mle,
    fixed = modmat.fix, random = list(modmat.blk, modmat.pop),
    obj = aout, zwz = zwz.mle, deriv = 1)$gradient
oout &lt;- optim(c(alpha.mle, sigma.mle), objfun, gradfun, method = "BFGS",
    hessian = TRUE)
oout$convergence == 0
fish &lt;- oout$hessian
</code></pre>

<hr>
<h2 id='predict.aster'>Predict Method for Aster Model Fits</h2><span id='topic+predict.aster'></span><span id='topic+predict.aster.formula'></span>

<h3>Description</h3>

<p>Obtains predictions (parameter estimates) and optionally estimates
standard errors of those predictions (parameter estimates) from
a fitted Aster model object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'aster'
predict(object, x, root, modmat, amat,
    parm.type = c("mean.value", "canonical"),
    model.type = c("unconditional", "conditional"),
    is.always.parameter = FALSE,
    se.fit = FALSE, info = c("expected", "observed"),
    info.tol = sqrt(.Machine$double.eps), newcoef = NULL,
    gradient = se.fit, ...)

## S3 method for class 'aster.formula'
predict(object, newdata, varvar, idvar, root, amat,
    parm.type = c("mean.value", "canonical"),
    model.type = c("unconditional", "conditional"),
    is.always.parameter = FALSE,
    se.fit = FALSE, info = c("expected", "observed"),
    info.tol = sqrt(.Machine$double.eps), newcoef = NULL,
    gradient = se.fit, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.aster_+3A_object">object</code></td>
<td>
<p>a fitted object of class inheriting from <code>"aster"</code>
or <code>"aster.formula"</code>.</p>
</td></tr>
<tr><td><code id="predict.aster_+3A_modmat">modmat</code></td>
<td>
<p>a model matrix to use instead of <code>object$modmat</code>.
Must have the same structure (three-dimensional array, first index runs
over individuals, second over nodes of the graphical model, third over
covariates).  Must have the same second and third dimensions as
<code>object$modmat</code>.  The second and third components of
<code>dimnames(modmat)</code> and <code>dimnames(object$modmat)</code> must also be
the same.
</p>
<p>May be missing, in which case <code>object$modmat</code> is used.
</p>
<p><code>predict.aster.formula</code> constructs such a <code>modmat</code> from
<code>object$formula</code>, the data frame <code>newdata</code>, and variables
in the environment of the formula.  When <code>newdata</code> is missing,
<code>object$modmat</code> is used.</p>
</td></tr>
<tr><td><code id="predict.aster_+3A_x">x</code></td>
<td>
<p>response.  Ignored and may be missing unless
<code>parm.type = "mean.value"</code> and <code>model.type = "conditional"</code>.
Even then may be missing when <code>modmat</code> is missing,
in which case <code>object$x</code> is used.  A matrix whose first and
second dimensions and the corresponding dimnames agrees with
those of <code>modmat</code> and <code>object$modmat</code>.
</p>
<p><code>predict.aster.formula</code> constructs such an <code>x</code> from
the response variable name in <code>object$formula</code>,
the data frame <code>newdata</code>,
and the variables in the environment of the formula.  When <code>newdata</code>
is missing, <code>object$x</code> is used.</p>
</td></tr>
<tr><td><code id="predict.aster_+3A_root">root</code></td>
<td>
<p>root data.  Ignored and may be missing unless
<code>parm.type == "mean.value"</code>.
Even then may be missing when <code>modmat</code> is missing,
in which case <code>object$root</code> is used.  A matrix of the
same form as <code>x</code>.
</p>
<p><code>predict.aster.formula</code> looks up the variable supplied as
the argument <code>root</code> in the data frame <code>newdata</code> or in
the variables in the environment of the formula and makes it a matrix
of the same form as <code>x</code>.  When <code>newdata</code>
is missing, <code>object$root</code> is used.</p>
</td></tr>
<tr><td><code id="predict.aster_+3A_amat">amat</code></td>
<td>
<p>if <code>zeta</code> is the requested prediction (mean value
or canonical, unconditional or conditional, depending on <code>parm.type</code>
and <code>model.type</code>), then we predict the linear function
<code>t(amat) %*% zeta</code>.  May be missing, in which case the identity
linear function is used.
</p>
<p>For <code>predict.aster</code>, a three-dimensional
array with <code>dim(amat)[1:2] == dim(modmat)[1:2]</code>.
</p>
<p>For <code>predict.aster.formula</code>, a three-dimensional array
of the same dimensions as required for <code>predict.aster</code>
(even though <code>modmat</code> is not provided).  First dimension
is number of individuals in <code>newdata</code>, if provided, otherwise
number of individuals in <code>object$data</code>.  Second dimension
is number of variables (<code>length(object$pred)</code>).
</p>
</td></tr>
<tr><td><code id="predict.aster_+3A_parm.type">parm.type</code></td>
<td>
<p>the type of parameter to predict.  The default is
mean value parameters (the opposite of the default
for <code><a href="stats.html#topic+predict.glm">predict.glm</a></code>), the expected value of a linear function
of the response under the MLE probability model (also called the
MLE of the mean value parameter).  The expectation is unconditional
or conditional depending on <code>parm.type</code>.
</p>
<p>The alternative <code>"canonical"</code> is the value of a linear function
of the MLE of canonical parameters under the MLE probability model.
The canonical parameter is unconditional
or conditional depending on <code>parm.type</code>.
</p>
<p>The value of this argument can be abbreviated.
</p>
</td></tr>
<tr><td><code id="predict.aster_+3A_model.type">model.type</code></td>
<td>
<p>the type of model in which to predict.  The default is
<code>"unconditional"</code> in which case the parameters (either mean value
or canonical, depending on the value of <code>parm.type</code>) are those
of an unconditional model.
The alternative is <code>"conditional"</code> in which case the parameters
are those of a conditional model.
</p>
<p>The value of this argument can be abbreviated.
</p>
</td></tr>
<tr><td><code id="predict.aster_+3A_is.always.parameter">is.always.parameter</code></td>
<td>
<p>logical, default <code>FALSE</code>.
Only affects the result when <code>parm.type = "mean.value"</code> and
<code>model.type = "conditional"</code>.  <code>TRUE</code> means the conditional
mean value parameter is produced.  <code>FALSE</code> means the conditional
mean values themselves are produced (which depend on data so are not
parameters).  See Conditional Mean Values Section below for further
explanation.</p>
</td></tr>
<tr><td><code id="predict.aster_+3A_se.fit">se.fit</code></td>
<td>
<p>logical switch indicating if standard errors are required.</p>
</td></tr>
<tr><td><code id="predict.aster_+3A_info">info</code></td>
<td>
<p>the type of Fisher information to use to compute standard errors.</p>
</td></tr>
<tr><td><code id="predict.aster_+3A_info.tol">info.tol</code></td>
<td>
<p>tolerance for eigenvalues of Fisher information.
If <code>eval</code> is the vector of eigenvalues of the information matrix,
then <code>eval &lt; cond.tol * max(eval)</code> are considered zero.  Hence the
corresponding eigenvectors are directions of constancy or recession of
the log likelihood.</p>
</td></tr>
<tr><td><code id="predict.aster_+3A_newdata">newdata</code></td>
<td>
<p>optionally, a data frame in which to look for variables with
which to predict.  If omitted, see <code>modmat</code> above.  See also details
section below.</p>
</td></tr>
<tr><td><code id="predict.aster_+3A_varvar">varvar</code></td>
<td>
<p>a variable of length <code>nrow(newdata)</code>, typically a
variable in <code>newdata</code>
that is a factor whose levels are character strings
treated as variable names.  The number of variable names is <code>nnode</code>.
Must be of the form <code>rep(vars, each = nind)</code> where <code>vars</code> is
a vector of variable names.  Not used if <code>newdata</code> is missing.</p>
</td></tr>
<tr><td><code id="predict.aster_+3A_idvar">idvar</code></td>
<td>
<p>a variable of length <code>nrow(newdata)</code>, typically a
variable in <code>newdata</code>
that indexes individuals.  The number
of individuals is <code>nind</code>.
Must be of the form <code>rep(inds, times = nnode)</code> where <code>inds</code> is
a vector of labels for individuals.  Not used if <code>newdata</code> is missing.</p>
</td></tr>
<tr><td><code id="predict.aster_+3A_newcoef">newcoef</code></td>
<td>
<p>if not <code>NULL</code>,
a variable of length <code>object$coefficients</code> and used
in its place when one wants predictions at other than the fitted
coefficient values.</p>
</td></tr>
<tr><td><code id="predict.aster_+3A_gradient">gradient</code></td>
<td>
<p>if <code>TRUE</code> return the gradient (Jacobian of the
transformation) matrix.  This matrix has number of rows equal to the
length of the fitted values and number of columns equal to the number
of regression coefficients.  It is the derivative matrix (matrix of
partial derivatives) of the mapping from regression coefficients to
whatever the predicted values are, which depends on what the
arguments <code>newdata</code>, <code>amat</code>, <code>parm.type</code>, and
<code>model.type</code> are.</p>
</td></tr>
<tr><td><code id="predict.aster_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that <code>model.type</code> need have nothing to do with the type
of the fitted aster model, which is <code>object$type</code>.
</p>
<p>Whether the
fitted model is conditional or unconditional, one typically wants
<em>unconditional</em> mean value parameters, because conditional mean
value parameters for hypothetical individuals depend on the hypothetical
data <code>x</code>, which usually makes no scientific sense.
</p>
<p>If one asks for <em>conditional</em> mean value parameters, one gets
them only if <code>is.always.parameter = TRUE</code> is specified.
Otherwise, conditional expectations that are not parameters (because
they depend on data) are produced.
See Conditional Mean Values Section for more about this.
</p>
<p>Similarly, if <code>object$type == "conditional"</code>, then the conditional
canonical parameters are a linear function of the regression coefficients
<code class="reqn">\theta = M \beta</code>, where <code class="reqn">M</code> is the model matrix,
but one can predict either <code class="reqn">\theta</code> or the unconditional
canonical parameters <code class="reqn">\varphi</code>,
as selected by <code>model.type</code>.
Similarly, if <code>object$type == "unconditional"</code>,
so <code class="reqn">\varphi = M \beta</code>, one can predict either
<code class="reqn">\theta</code> or <code class="reqn">\varphi</code>
as selected by <code>model.type</code>.
</p>
<p>The specification of the prediction model is confusing because there
are so many possibilities.  First the &ldquo;usual&rdquo; case.
The fit was done using a formula, found in <code>object$formula</code>.
A data frame <code>newdata</code> that has the same variables as <code>object$data</code>,
the data frame used in the fit, but may have different rows (representing
hypothetical individuals) is supplied.
But <code>newdata</code> must specify <em>all nodes</em>
of the graphical model for each (hypothetical, new) individual,
just like <code>object$data</code> did for real observed individuals.
Hence <code>newdata</code> is typically constructed using <code><a href="stats.html#topic+reshape">reshape</a></code>.
See also the details section of <code><a href="#topic+aster">aster</a></code>.
</p>
<p>In this &ldquo;usual&rdquo; case we need <code>varvar</code> and <code>idvar</code> to
tell us what rows of <code>newdata</code> correspond to which individuals and
nodes (the same role they played in the original fit by <code><a href="#topic+aster">aster</a></code>).
If we are predicting canonical parameters, then we do not need <code>root</code> or
<code>x</code>.
If we are predicting unconditional mean value parameters, then
we also need <code>root</code> but not <code>x</code>.
If we are predicting conditional mean value parameters, then
we also need both <code>root</code> and <code>x</code>.
In the &ldquo;usual&rdquo; case, these are found in <code>newdata</code> and
not supplied as arguments to <code>predict</code>.  Moreover, <code>x</code>
is not named <code>"x"</code> but is the response in <code>out$formula</code>.
</p>
<p>The next case, <code>predict(object)</code> with no other arguments,
is often used with linear models (<code><a href="stats.html#topic+predict.lm">predict.lm</a></code>),
but we expect will be little used for aster models.  As for linear
models, this &ldquo;predicts&rdquo; the observed data.  In this case
<code>modmat</code>, <code>x</code>, and <code>root</code> are found in <code>object</code>
and nothing is supplied as an argument to <code>predict.aster</code>, except
perhaps <code>amat</code> if one wants a function of predictions for the observed
data.
</p>
<p>The final case, also perhaps little used, is a fail-safe mode for problems
in which the R formula language just cannot be bludgeoned into doing what
you want.  This is the same reason <code><a href="#topic+aster.default">aster.default</a></code> exists.
Then a model matrix can be constructed &ldquo;by hand&rdquo;, and the function
<code>predict.aster</code> is used instead of <code>predict.aster.formula</code>.
</p>
<p>Note that it is possible to use a &ldquo;constructed by hand&rdquo;
model matrix even if <code>object</code> was produced by <code><a href="#topic+aster.formula">aster.formula</a></code>.
Simply explicitly call <code>predict.aster</code> rather than <code>predict</code>
to override the R method dispatch (which would
call <code>predict.aster.formula</code> in this case).
</p>


<h3>Value</h3>

<p>If <code>se.fit = FALSE</code> and <code>gradient = FALSE</code>, a vector of predictions.
If <code>se.fit = TRUE</code>, a list with components
</p>
<table>
<tr><td><code>fit</code></td>
<td>
<p>Predictions</p>
</td></tr>
<tr><td><code>se.fit</code></td>
<td>
<p>Estimated standard errors</p>
</td></tr>
<tr><td><code>gradient</code></td>
<td>
<p>The gradient of the transformation from
regression coefficients to predictions</p>
</td></tr>
</table>
<p>If <code>gradient = TRUE</code>, a list with components
</p>
<table>
<tr><td><code>fit</code></td>
<td>
<p>Predictions</p>
</td></tr>
<tr><td><code>gradient</code></td>
<td>
<p>The gradient of the transformation from
regression coefficients to predictions</p>
</td></tr>
</table>


<h3>Conditional Mean Values</h3>

<p>Both the original aster paper (Geyer, et al., 2007) and this package are
weird about conditional mean values.  Equation (10) of that paper defines
(using different notation from what we use here)
</p>
<p style="text-align: center;"><code class="reqn">\xi_j = E(x_j | x_{p(j)})</code>
</p>

<p>where <code class="reqn">x_j</code> are components of the response vector and <code class="reqn">p(j)</code>
denotes denotes the predecessor of node <code class="reqn">j</code>.  That paper explicitly says
that this is is not a parameter because it depends on the data.  In fact
</p>
<p style="text-align: center;"><code class="reqn">E(x_j | x_{p(j)}) = x_{p(j)} E(x_j | x_{p(j)} = 1)</code>
</p>

<p>(this is equation (3) of that paper in different notation).
Thus it is weird to use a Greek letter to denote this.
</p>
<p>There should be a conditional mean value parameter, and
Geyer (2010, equation (11b)) defines it as
</p>
<p style="text-align: center;"><code class="reqn">\xi_j = E(y_j | y_{p(j)} = 1)</code>
</p>

<p>(This equation only makes sense when the conditioning event
<code class="reqn">x_{p(j)} = 1</code> is possible, which it is not for
<code class="reqn">k</code>-truncated arrows for <code class="reqn">k &gt; 0</code>.  Then a more complicated definition
must be used.  By definition <code class="reqn">x_j</code> is the sum
of <code class="reqn">x_{p(j)}</code> independent and identically distributed random
variables, and <code class="reqn">\xi_j</code> is always the mean of one of those
random variables.)
This gives us the important relationship between conditional and unconditional
mean value parameters
</p>
<p style="text-align: center;"><code class="reqn">\mu_j = \xi_j \mu_{p(j)}</code>
</p>

<p>which holds for all successor nodes <code class="reqn">j</code>.
All later writings of this author use this definition of <code class="reqn">\xi</code>
as does the R package <code>aster2</code> (Geyer, 2017).
This is one of six important parameterizations of an unconditional aster model
(Geyer, 2010, Sections 2.7 and 2.8).  The R package <code>aster2</code> uses all
of them.
</p>
<p>This function (as of version 1.0 of this package) has an argument
<code>is.always.parameter</code> to switch between these two definitions
in case <code>parm.type = "mean.value"</code> and <code>model.type = "conditional"</code>
are specified.  Then <code>is.always.parameter = TRUE</code> specifies that the latter
definition of <code class="reqn">\xi</code> is produced (which is a parameter, with all other
options for <code>parm.type</code> and <code>model.type</code>).  The option
<code>is.always.parameter = FALSE</code> specifies that the former
definition of <code class="reqn">\xi</code> is produced (which is a conditional expectation
but not a parameter) and is what this function produced in versions of this
package before 1.0.
</p>


<h3>References</h3>

<p>Geyer, C. J. (2010)
A Philosophical Look at Aster Models.
Technical Report No. 676.  School of Statistics, University of Minnesota.
<a href="http://purl.umn.edu/57163">http://purl.umn.edu/57163</a>.
</p>
<p>Geyer, C.~J. (2017).
R package <code>aster2</code> (Aster Models), version 0.3.
<a href="https://cran.r-project.org/package=aster2">https://cran.r-project.org/package=aster2</a>.
</p>
<p>Geyer, C. J., Wagenius, S., and Shaw, R. G. (2007)
Aster models for life history analysis.
<em>Biometrika</em>, <b>94</b>, 415&ndash;426.
<a href="https://doi.org/10.1093/biomet/asm030">doi:10.1093/biomet/asm030</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### see package vignette for explanation ###
library(aster)
data(echinacea)
vars &lt;- c("ld02", "ld03", "ld04", "fl02", "fl03", "fl04",
    "hdct02", "hdct03", "hdct04")
redata &lt;- reshape(echinacea, varying = list(vars), direction = "long",
    timevar = "varb", times = as.factor(vars), v.names = "resp")
redata &lt;- data.frame(redata, root = 1)
pred &lt;- c(0, 1, 2, 1, 2, 3, 4, 5, 6)
fam &lt;- c(1, 1, 1, 1, 1, 1, 3, 3, 3)
hdct &lt;- grepl("hdct", as.character(redata$varb))
redata &lt;- data.frame(redata, hdct = as.integer(hdct))
level &lt;- gsub("[0-9]", "", as.character(redata$varb))
redata &lt;- data.frame(redata, level = as.factor(level))
aout &lt;- aster(resp ~ varb + level : (nsloc + ewloc) + hdct : pop,
    pred, fam, varb, id, root, data = redata)
newdata &lt;- data.frame(pop = levels(echinacea$pop))
for (v in vars)
    newdata[[v]] &lt;- 1
newdata$root &lt;- 1
newdata$ewloc &lt;- 0
newdata$nsloc &lt;- 0
renewdata &lt;- reshape(newdata, varying = list(vars),
     direction = "long", timevar = "varb", times = as.factor(vars),
     v.names = "resp")
hdct &lt;- grepl("hdct", as.character(renewdata$varb))
renewdata &lt;- data.frame(renewdata, hdct = as.integer(hdct))
level &lt;- gsub("[0-9]", "", as.character(renewdata$varb))
renewdata &lt;- data.frame(renewdata, level = as.factor(level))
nind &lt;- nrow(newdata)
nnode &lt;- length(vars)
amat &lt;- array(0, c(nind, nnode, nind))
for (i in 1:nind)
    amat[i , grep("hdct", vars), i] &lt;- 1
foo &lt;- predict(aout, varvar = varb, idvar = id, root = root,
    newdata = renewdata, se.fit = TRUE, amat = amat)
bar &lt;- cbind(foo$fit, foo$se.fit)
dimnames(bar) &lt;- list(as.character(newdata$pop), c("Estimate", "Std. Error"))
print(bar)
</code></pre>

<hr>
<h2 id='quickle'>Penalized Quasi-Likelihood for Aster Models</h2><span id='topic+quickle'></span>

<h3>Description</h3>

<p>Evaluates the objective function for approximate maximum likelihood for
an aster model with random effects.  Uses Laplace approximation to
integrate out the random effects analytically.
The &ldquo;quasi&rdquo; in the title is a misnomer in the context of aster
models but the acronym PQL for this procedure is well-established in
the generalized linear mixed models literature.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>quickle(alphanu, bee, fixed, random, obj, y, origin, zwz, deriv = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="quickle_+3A_alphanu">alphanu</code></td>
<td>
<p>the parameter vector value where the function is evaluated,
a numeric vector, see details.</p>
</td></tr>
<tr><td><code id="quickle_+3A_bee">bee</code></td>
<td>
<p>the random effects vector that is used as the starting point
for the inner optimization, which maximizes the penalized log likelihood
to find the optimal random effects vector matching <code>alphanu</code>.</p>
</td></tr>
<tr><td><code id="quickle_+3A_fixed">fixed</code></td>
<td>
<p>the model matrix for fixed effects.  The number of rows
is <code>nrow(obj$data)</code>.  The number of columns is the number of fixed
effects.</p>
</td></tr>
<tr><td><code id="quickle_+3A_random">random</code></td>
<td>
<p>the model matrix or matrices for random effects.
The number of rows is <code>nrow(obj$data)</code>.  The number of columns
is the number of random effects in a group.  Either a matrix or a list
each element of which is a matrix.</p>
</td></tr>
<tr><td><code id="quickle_+3A_obj">obj</code></td>
<td>
<p>aster model object, the result of a call to <code><a href="#topic+aster">aster</a></code>.</p>
</td></tr>
<tr><td><code id="quickle_+3A_y">y</code></td>
<td>
<p>response vector.  May be omitted, in which case <code>obj$x</code>
is used.  If supplied, must be a matrix of the same dimensions as
<code>obj$x</code>.</p>
</td></tr>
<tr><td><code id="quickle_+3A_origin">origin</code></td>
<td>
<p>origin of aster model.  May be omitted, in which case
default origin (see <code><a href="#topic+aster">aster</a></code>) is used.  If supplied, must be
a matrix of the same dimensions <code>obj$x</code>.</p>
</td></tr>
<tr><td><code id="quickle_+3A_zwz">zwz</code></td>
<td>
<p>A possible value of <code class="reqn">Z^T W Z</code>, where <code class="reqn">Z</code> is the
model matrix for all random effects and <code class="reqn">W</code> is the variance matrix of
the response.  See details.  Typically constructed by
the function <code><a href="#topic+makezwz">makezwz</a></code>.</p>
</td></tr>
<tr><td><code id="quickle_+3A_deriv">deriv</code></td>
<td>
<p>Number of derivatives wanted, zero, one, or two.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Define
</p>
<p style="text-align: center;"><code class="reqn">p(\alpha, b, \nu) = m(a + M \alpha + Z b) + {\textstyle \frac{1}{2}} b^T D^{- 1} b + {\textstyle \frac{1}{2}} \log \det[Z^T W Z D + I]</code>
</p>

<p>where <code class="reqn">m</code> is minus the log likelihood function of a saturated aster model,
where <code class="reqn">a</code> is a known vector (the <em>offset vector</em> in the terminology
of <code><a href="stats.html#topic+glm">glm</a></code> but the <em>origin</em> in the terminology
of <code><a href="#topic+aster">aster</a></code>),
where <code class="reqn">M</code> is a known matrix, the model matrix for fixed effects
(the argument <code>fixed</code> of this function),
where <code class="reqn">Z</code> is a known matrix, the model matrix for random effects
(either the argument <code>random</code> of this function if it is a matrix or
<code>Reduce(cbind, random)</code> if <code>random</code> is a list of matrices),
where <code class="reqn">D</code> is a diagonal matrix whose diagonal is the vector
<code>rep(nu, times = nrand)</code>
where <code>nrand</code> is <code>sapply(random, ncol)</code>
when <code>random</code> is a list of
matrices and <code>ncol(random)</code> when <code>random</code> is a matrix,
where <code class="reqn">W</code> is an arbitrary symmetric positive semidefinite matrix
(<code class="reqn">Z^T W Z</code> is the argument <code>zwz</code> of this function),
and where <code class="reqn">I</code> is the identity matrix.
Note that <code class="reqn">D</code> is a function of <code class="reqn">\nu</code>
although the notation does not explicitly indicate this.
</p>
<p>The argument <code>alphanu</code> of this function is the concatenation
of the parameter vectors <code class="reqn">\alpha</code> and <code class="reqn">\nu</code>.
The argument <code>bee</code> of this function is a possible value of <code class="reqn">b</code>.
The length of <code class="reqn">\alpha</code> is the column dimension of <code class="reqn">M</code>.
The length of <code class="reqn">b</code> is the column dimension of <code class="reqn">Z</code>.
The length of <code class="reqn">\nu</code> is the length of the argument <code>random</code>
of this function if it is a list and is one otherwise.
</p>
<p>Let <code class="reqn">b^*</code> denote the minimizer
of <code class="reqn">p(\alpha, b, \nu)</code> considered as a function of
<code class="reqn">b</code> for fixed <code class="reqn">\alpha</code> and <code class="reqn">\nu</code>, so <code class="reqn">b^*</code>
is a function of <code class="reqn">\alpha</code> and <code class="reqn">\nu</code>.
This function evaluates
</p>
<p style="text-align: center;"><code class="reqn">q(\alpha, \nu) = p(\alpha, b^*, \nu)</code>
</p>

<p>and its gradient vector and Hessian matrix (if requested).
Note that <code class="reqn">b^*</code> is a function of <code class="reqn">\alpha</code>
and <code class="reqn">\nu</code> although the notation does not explicitly indicate this.
</p>


<h3>Value</h3>

<p>a list with some of the following components: <code>value</code>, <code>gradient</code>,
<code>hessian</code>, <code>alpha</code>, <code>bee</code>, <code>nu</code>.  The first three are
the requested derivatives.  The second three are the corresponding parameter
values: <code>alpha</code> and <code>nu</code> are the corresponding parts of the
argument <code>alphanu</code>, the value of <code>bee</code> is the result of the inner
optimization (<code class="reqn">b^*</code> in the notation in details),
not the argument <code>bee</code> of this function.
</p>


<h3>Note</h3>

<p>Not intended for use by naive users.  Use <code><a href="#topic+summary.reaster">summary.reaster</a></code>,
which calls it.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(radish)

pred &lt;- c(0,1,2)
fam &lt;- c(1,3,2)

rout &lt;- reaster(resp ~ varb + fit : (Site * Region),
    list(block = ~ 0 + fit : Block, pop = ~ 0 + fit : Pop),
    pred, fam, varb, id, root, data = radish)

alpha.mle &lt;- rout$alpha
bee.mle &lt;- rout$b
nu.mle &lt;- rout$sigma^2
zwz.mle &lt;- rout$zwz
obj &lt;- rout$obj
fixed &lt;- rout$fixed
random &lt;- rout$random
alphanu.mle &lt;- c(alpha.mle, nu.mle)

qout &lt;- quickle(alphanu.mle, bee.mle, fixed, random, obj,
    zwz = zwz.mle, deriv = 2)
</code></pre>

<hr>
<h2 id='radish'>Life History Data on Raphanus sativus</h2><span id='topic+radish'></span>

<h3>Description</h3>

<p>Data on life history traits for the 
invasive California wild radish <em>Raphanus sativus</em>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(radish)</code></pre>


<h3>Format</h3>

<p>A data frame with records for 286 plants.
Data are already in &ldquo;long&rdquo; format; no need to reshape.
</p>

<dl>
<dt>resp</dt><dd><p>Response vector.</p>
</dd>
<dt>varb</dt><dd><p>Categorical.  Gives node of graphical model corresponding
to each component of <code>resp</code>.  See details below.</p>
</dd>
<dt>root</dt><dd><p>All ones.  Root variables for graphical model.</p>
</dd>
<dt>id</dt><dd><p>Categorical.  Indicates individual plants.</p>
</dd>
<dt>Site</dt><dd><p>Categorical.  Experimental site where plant was grown.
Two sites in this dataset.</p>
</dd>
<dt>Block</dt><dd><p>Categorical.  Block nested within site.</p>
</dd>
<dt>Region</dt><dd><p>Categorical.  Region from which individuals
were obtained: northern, coastal California (N) or southern, inland
California (S).</p>
</dd>
<dt>Pop</dt><dd><p>Categorical.  Wild population nested within region.</p>
</dd>
<dt>varbFlowering</dt><dd><p>Indicator (zero or one).  Shorthand
for <code>as.numeric(radish$varb == "Flowering")</code>.</p>
</dd>
<dt>varbFlowers</dt><dd><p>Indicator (zero or one).  Shorthand
for <code>as.numeric(radish$varb == "Flowers")</code>.</p>
</dd>
<dt>fit</dt><dd><p>Indicator (zero or one).  Shorthand
for <code>as.numeric(radish$varb == "Fruits")</code>.  So-called because the
components of <code>outcome</code> indicated are the best surrogate of
Darwinian fitness in these data.</p>
</dd>
</dl>



<h3>Details</h3>

<p>The levels of <code>varb</code> indicate nodes of the graphical model to which
the corresponding elements of the response vector <code>resp</code> belong.
This is the typical &ldquo;long&rdquo; format produced by the R <code>reshape</code>
function.  For each individual, there are several response variables.
All response variables are combined in one vector <code>resp</code>.
The variable <code>varb</code> indicates which &ldquo;original&rdquo; variable
the number was for.  The variable <code>id</code> indicates which individual
the number was for.  The levels of <code>varb</code>, which are the names
of the &ldquo;original&rdquo; variables are
</p>

<dl>
<dt>Flowering</dt><dd><p>Indicator (zero or one).  Bernoulli, One if individual
survived to produce flowers.</p>
</dd>
<dt>Flowers</dt><dd><p>Integer.  Zero-truncated Poisson, number of flowers observed.</p>
</dd>
<dt>Fruits</dt><dd><p>Integer.  Poisson, number of fruits observed.</p>
</dd>
</dl>

<p>Graphical model is
</p>
<p style="text-align: center;"><code class="reqn">1 \longrightarrow \mbox{Flowering} \longrightarrow \mbox{Flowers} \longrightarrow \mbox{Fruits}</code>
</p>



<h3>Source</h3>

<p>Caroline Ridley
</p>


<h3>References</h3>

<p>These data are a subset of data previously analyzed using fixed effect
aster methods (R function <code>aster</code>) in the following.
</p>
<p>Ridley, C. E. and Ellstrand, N. C. (2010).
Rapid evolution of morphology and adaptive life history in
the invasive California wild radish (<em>Raphanus sativus</em>) and
the implications for management.
<em>Evolutionary Applications</em>, <b>3</b>, 64&ndash;76.
</p>
<p>These data are a subset of data previously analyzed using random effect
aster methods (R function <code>reaster</code>) in the following.
</p>
<p>Geyer, C. J., Ridley, C. E., Latta, R. G., Etterson, J. R.,
and Shaw, R. G. (2013)
Local Adaptation and Genetic Effects on Fitness: Calculations
for Exponential Family Models with Random Effects.
<em>Annals of Applied Statistics</em>, <b>7</b>, 1778&ndash;1795.
<a href="https://doi.org/10.1214/13-AOAS653">doi:10.1214/13-AOAS653</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pickle">pickle</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(radish)
</code></pre>

<hr>
<h2 id='raster'>Aster Model Simulation</h2><span id='topic+raster'></span>

<h3>Description</h3>

<p>Random generation of data for Aster models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>raster(theta, pred, fam, root, famlist = fam.default())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="raster_+3A_theta">theta</code></td>
<td>
<p>canonical parameter of the conditional model.
A matrix, rows represent individuals and columns represent
nodes in the graphical model.</p>
</td></tr>
<tr><td><code id="raster_+3A_pred">pred</code></td>
<td>
<p>integer vector of length <code>ncol(theta)</code> determining
the graph.  <code>pred[j]</code> is the index of the predecessor of
the node with index <code>j</code> unless the predecessor is a root
node, in which case <code>pred[j] == 0</code>.</p>
</td></tr>
<tr><td><code id="raster_+3A_fam">fam</code></td>
<td>
<p>integer vector of length <code>ncol(theta)</code> determining
the exponential family structure of the aster model.  Each element
is an index into the vector of family specifications given by
the argument <code>famlist</code>.</p>
</td></tr>
<tr><td><code id="raster_+3A_root">root</code></td>
<td>
<p>A matrix of the same dimensions as <code>theta</code>.
Data <code>root[i, j]</code> is the data for the founder that is
the predecessor of the <code>[i, j]</code> node.</p>
</td></tr>
<tr><td><code id="raster_+3A_famlist">famlist</code></td>
<td>
<p>a list of family specifications (see <code><a href="#topic+families">families</a></code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of the same dimensions as <code>theta</code>.  The random data
for an aster model with the specified graph, parameters, and root
data.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+aster">aster</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>### see package vignette for explanation ###
data(echinacea)
vars &lt;- c("ld02", "ld03", "ld04", "fl02", "fl03", "fl04",
    "hdct02", "hdct03", "hdct04")
redata &lt;- reshape(echinacea, varying = list(vars),
     direction = "long", timevar = "varb", times = as.factor(vars),
     v.names = "resp")
redata &lt;- data.frame(redata, root = 1)
pred &lt;- c(0, 1, 2, 1, 2, 3, 4, 5, 6)
fam &lt;- c(1, 1, 1, 1, 1, 1, 3, 3, 3)
hdct &lt;- grep("hdct", as.character(redata$varb))
hdct &lt;- is.element(seq(along = redata$varb), hdct)
redata &lt;- data.frame(redata, hdct = as.integer(hdct))
aout4 &lt;- aster(resp ~ varb + nsloc + ewloc + pop * hdct - pop,
    pred, fam, varb, id, root, data = redata)
newdata &lt;- data.frame(pop = levels(echinacea$pop))
for (v in vars)
    newdata[[v]] &lt;- 1
newdata$root &lt;- 1
newdata$ewloc &lt;- 0
newdata$nsloc &lt;- 0
renewdata &lt;- reshape(newdata, varying = list(vars),
    direction = "long", timevar = "varb", times = as.factor(vars),
    v.names = "resp")
hdct &lt;- grep("hdct", as.character(renewdata$varb))
hdct &lt;- is.element(seq(along = renewdata$varb), hdct)
renewdata &lt;- data.frame(renewdata, hdct = as.integer(hdct))
beta.hat &lt;- aout4$coef
theta.hat &lt;- predict(aout4, model.type = "cond", parm.type = "canon")
theta.hat &lt;- matrix(theta.hat, nrow = nrow(aout4$x), ncol = ncol(aout4$x))
xstar &lt;- raster(theta.hat, pred, fam, aout4$root)
aout4star &lt;- aster(xstar, aout4$root, pred, fam, aout4$modmat, beta.hat)
beta.star &lt;- aout4star$coef
print(cbind(beta.hat, beta.star))
</code></pre>

<hr>
<h2 id='reaster'>Aster Models with Random Effects</h2><span id='topic+reaster'></span><span id='topic+reaster.default'></span><span id='topic+reaster.formula'></span>

<h3>Description</h3>

<p>Fits Aster Models with Random Effects using Laplace Approximation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reaster(fixed, random, pred, fam, varvar, idvar, root,
    famlist = fam.default(), origin, data, effects, sigma, response)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reaster_+3A_fixed">fixed</code></td>
<td>
<p>either a model matrix or a formula specifying response
and model matrix.  The model matrix for fixed effects.</p>
</td></tr>
<tr><td><code id="reaster_+3A_random">random</code></td>
<td>
<p>either a model matrix or list of model matrices or
a formula or a list of formulas specifying a model matrix or matrices.
The model matrix or matrices for random effects.  Each model matrix
specifies the random effects for one variance component.</p>
</td></tr>
<tr><td><code id="reaster_+3A_pred">pred</code></td>
<td>
<p>an integer vector of length <code>nnode</code> determining
the dependence graph of the aster model.  <code>pred[j]</code> is
the index of the predecessor of
the node with index <code>j</code> unless the predecessor is a root
node, in which case <code>pred[j] == 0</code>.  See details section
of <code><a href="#topic+aster">aster</a></code> for further requirements.</p>
</td></tr>
<tr><td><code id="reaster_+3A_fam">fam</code></td>
<td>
<p>an integer vector of length <code>nnode</code> determining
the exponential family structure of the aster model.  Each element
is an index into the vector of family specifications given by
the argument <code>famlist</code>.</p>
</td></tr>
<tr><td><code id="reaster_+3A_varvar">varvar</code></td>
<td>
<p>a variable whose length is the row dimension of all model
matrices that is a factor whose levels are character strings
treated as variable names.  The number of variable names is <code>nnode</code>.
Must be of the form <code>rep(vars, each = nind)</code> where <code>vars</code> is
a vector of variable names.  Usually found in the data frame <code>data</code>
when this is produced by the <code><a href="stats.html#topic+reshape">reshape</a></code> function.</p>
</td></tr>
<tr><td><code id="reaster_+3A_idvar">idvar</code></td>
<td>
<p>a variable whose length is the row dimension of all model
matrices.  The number of individuals is <code>nind</code>.
Must be of the form <code>rep(inds, times = nnode)</code> where <code>inds</code> is
a vector of labels for individuals.  Usually found in the data frame
<code>data</code> when this is produced by the <code><a href="stats.html#topic+reshape">reshape</a></code> function.</p>
</td></tr>
<tr><td><code id="reaster_+3A_root">root</code></td>
<td>
<p>a vector whose length is the row dimension of all model
matrices.  For nodes whose predecessors are root nodes specifies the
value of the constant at that root node.  Typically the vector having
all components equal to one.</p>
</td></tr>
<tr><td><code id="reaster_+3A_famlist">famlist</code></td>
<td>
<p>a list of family specifications (see <code><a href="#topic+families">families</a></code>).</p>
</td></tr>
<tr><td><code id="reaster_+3A_origin">origin</code></td>
<td>
<p>a vector whose length is the row dimension of all model
matrices.  Distinguished point in parameter space.  May be missing,
in which case an unspecified default is provided.  See details of
<code><a href="#topic+aster">aster</a></code> for further explanation.</p>
</td></tr>
<tr><td><code id="reaster_+3A_data">data</code></td>
<td>
<p>an optional data frame containing the variables
in the model.  If not found in <code>data</code>, the variables are taken
from <code>environment(fixed)</code>, typically the environment from
which <code>reaster</code> is called.  Usually produced by
the <code><a href="stats.html#topic+reshape">reshape</a></code> function.  Not needed when model matrices
rather than formulas are supplied in <code>fixed</code> and <code>random</code>.</p>
</td></tr>
<tr><td><code id="reaster_+3A_effects">effects</code></td>
<td>
<p>if not missing, a vector specifying starting values for
all effects, fixed and random.  Length is the sum of the column dimensions
of all model matrices.  If supplied, the random effects part should be
standardized (random effects divided by their standard deviations, like
the component <code>c</code> of the output of this function).</p>
</td></tr>
<tr><td><code id="reaster_+3A_sigma">sigma</code></td>
<td>
<p>if not missing, a vector specifying starting values for
the square roots of the variance components.  Length is the number
of model matrices for
random effects (the length of the list <code>random</code> if a list and one
if <code>random</code> is not a list.</p>
</td></tr>
<tr><td><code id="reaster_+3A_response">response</code></td>
<td>
<p>if not missing, a vector specifying the response.  Length
is the row dimension of all model matrices.  If missing, the response
is determined by the response in the formula <code>fixed</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See the help page for the function <code><a href="#topic+aster">aster</a></code> for specification
of aster models.  This function only fits unconditional aster models
(those with default values of the <code>aster</code> function arguments
<code>type</code> and <code>origin.type</code>.
</p>
<p>The only difference between this function and the <code>aster</code> function is
that some effects are treated as random.  The unconditional canonical
parameter vector of the aster model is treated as an affine function of
fixed and random effects
</p>
<p style="text-align: center;"><code class="reqn">\varphi = M \beta + \sum_{i = 1}^k \sigma^2_i Z_i b_i</code>
</p>

<p>where <code class="reqn">M</code> and the <code class="reqn">Z_i</code> are model matrices specified by
the arguments <code>fixed</code> and <code>random</code>, where <code class="reqn">\beta</code>
is a vector of
fixed effects and each <code class="reqn">b_i</code> is a vector of random
effects that are assumed to be (marginally) normally distributed with
mean vector zero and variance matrix <code class="reqn">\sigma_i^2</code> times
the identity matrix.
The vectors of random effects <code class="reqn">b_i</code> are not parameters, rather
they are latent (unobservable, hypothetical) variables.  The square roots
of the variance components <code class="reqn">\sigma_i</code> are parameters as
are the components of <code class="reqn">\beta</code>.
</p>
<p>This function maximizes an approximation to the likelihood introduced
by Breslow and Clayton (1993).  See Geyer, et al. (2013) for details.
</p>


<h3>Value</h3>

<p><code>reaster</code> returns an object of class inheriting from <code>"reaster"</code>.
An object of class <code>"reaster"</code> is a list containing at least the
following components:
</p>
<table>
<tr><td><code>obj</code></td>
<td>
<p>The aster object returned by a call to the <code><a href="#topic+aster">aster</a></code>
function to fit the fixed effects model.</p>
</td></tr>
<tr><td><code>fixed</code></td>
<td>
<p>the model matrix for fixed effects.</p>
</td></tr>
<tr><td><code>random</code></td>
<td>
<p>the model matrix or matrices for random effects.</p>
</td></tr>
<tr><td><code>dropped</code></td>
<td>
<p>names of columns dropped from the fixed effects matrix.</p>
</td></tr>
<tr><td><code>sigma</code></td>
<td>
<p>approximate MLE for square roots of variance components.</p>
</td></tr>
<tr><td><code>nu</code></td>
<td>
<p>approximate MLE for variance components.</p>
</td></tr>
<tr><td><code>c</code></td>
<td>
<p>penalized likelihood estimates for the <code class="reqn">c</code>'s,
which are rescaled random effects.</p>
</td></tr>
<tr><td><code>b</code></td>
<td>
<p>penalized likelihood estimates for the random effects.</p>
</td></tr>
<tr><td><code>alpha</code></td>
<td>
<p>approximate MLE for fixed effects.</p>
</td></tr>
<tr><td><code>zwz</code></td>
<td>
<p><code class="reqn">Z W Z^T</code> where <code class="reqn">Z</code> is
the model matrix for random effects and <code class="reqn">W</code> is the Hessian matrix
of minus the complete data log likelihood with respect to random effects
with MLE values of the parameters plugged in.</p>
</td></tr>
<tr><td><code>response</code></td>
<td>
<p>the response vector.</p>
</td></tr>
<tr><td><code>origin</code></td>
<td>
<p>the origin (offset) vector.</p>
</td></tr>
<tr><td><code>iterations</code></td>
<td>
<p>number of iterations of trust region algorithm in
each iteration of re-estimating <code>zwz</code> and re-fitting.</p>
</td></tr>
<tr><td><code>counts</code></td>
<td>
<p>number of iterations of Nelder-Mead in initial optimization
of approximate missing data log likelihood.</p>
</td></tr>
<tr><td><code>deviance</code></td>
<td>
<p>up to a constant, minus twice the maximized value of
the Breslow-Clayton approximation to the
log-likelihood.  (Note the minus.  This is somewhat counterintuitive,
but agrees with the convention used by the <code><a href="#topic+aster">aster</a></code> function.)</p>
</td></tr>
</table>
<p>Calls to <code>reaster.formula</code> return a list also containing:
</p>
<table>
<tr><td><code>call</code></td>
<td>
<p>the matched call.</p>
</td></tr>
<tr><td><code>formula</code></td>
<td>
<p>the formulas supplied.</p>
</td></tr>
</table>


<h3>NA Values</h3>

<p>It was almost always wrong for aster model data to have <code>NA</code> values.
Although theoretically possible for the R formula mini-language to do the
right thing for an aster model with <code>NA</code> values in the data, usually
it does some wrong thing.  Thus, since version 0.8-20, this function and
the <code><a href="#topic+aster">aster</a></code> function give errors when used with data having
<code>NA</code> values.  Users must remove all <code>NA</code> values (or replace them
with what they should be, perhaps zero values) &ldquo;by hand&rdquo;.
</p>


<h3>Warning about Negative Binomial</h3>

<p>The negative binomial and truncated negative binomial are fundamentally
incompatible with random effects.  The reason is that the canonical parameter
space for a one-parameter negative binomial or truncated negative binomial
is the negative half line.  Thus the conditional canonical parameter
<code class="reqn">\theta</code> for such a node must be negative valued.  The aster
transform is so complicated that it is unclear what the corresponding
constraint on the unconditional canonical parameter <code class="reqn">\varphi</code> is,
but there is a constraint: its parameter space is not the whole real line.
A normal random effect, in contrast, does have support the whole real line.
It wants to make parameters that are constrained to have any real number.
The code only warns about this situation, because if the random effects do
not influence any negative binomial or truncated negative binomial nodes
of the graph, then there would be no problem.
</p>


<h3>Warning about Individual Random Effects</h3>

<p>The Breslow-Clayton approximation assumes the complete data log likelihood
is approximately quadratic considered as a function of random effects only.
This will be the case by the law of large numbers if the number of individuals
is much larger than the number of random effects.  Thus Geyer, et al. (2013)
warn against trying to put a random effect for each individual in the model.
If you do that, the code will try to fit the model, but it will take forever
and no theory says the results will make any sense.
</p>


<h3>References</h3>

<p>Breslow, N. E., and Clayton, D. G. (1993).
Approximate Inference in Generalized Linear Mixed Models.
<em>Journal of the American Statistical Association</em>, <b>88</b>, 9&ndash;25.
<a href="https://doi.org/10.1080/01621459.1993.10594284">doi:10.1080/01621459.1993.10594284</a>.
</p>
<p>Geyer, C. J., Ridley, C. E., Latta, R. G., Etterson, J. R.,
and Shaw, R. G. (2012)
Aster Models with Random Effects via Penalized Likelihood.
Technical Report 692, School of Statistics, University of Minnesota.
<a href="http://purl.umn.edu/135870">http://purl.umn.edu/135870</a>.
</p>
<p>Geyer, C. J., Ridley, C. E., Latta, R. G., Etterson, J. R.,
and Shaw, R. G. (2013)
Local Adaptation and Genetic Effects on Fitness: Calculations
for Exponential Family Models with Random Effects.
<em>Annals of Applied Statistics</em>, <b>7</b>, 1778&ndash;1795.
<a href="https://doi.org/10.1214/13-AOAS653">doi:10.1214/13-AOAS653</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(aster)
data(radish)
pred &lt;- c(0,1,2)
fam &lt;- c(1,3,2)
rout &lt;- reaster(resp ~ varb + fit : (Site * Region),
    list(block = ~ 0 + fit : Block, pop = ~ 0 + fit : Pop),
    pred, fam, varb, id, root, data = radish)
summary(rout)
summary(rout, stand = FALSE, random = TRUE)
</code></pre>

<hr>
<h2 id='sim'>Simulated Life History Data</h2><span id='topic+sim'></span><span id='topic+beta.true'></span><span id='topic+mu.true'></span><span id='topic+phi.true'></span><span id='topic+theta.true'></span><span id='topic+fam'></span><span id='topic+pred'></span><span id='topic+vars'></span><span id='topic+ladata'></span><span id='topic+redata'></span>

<h3>Description</h3>

<p>Data on life history traits for four years and five fitness components
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(sim)</code></pre>


<h3>Format</h3>

<p>Loads nine objects.
The objects <code>beta.true</code>,  <code>mu.true</code>, <code>phi.true</code>, and
<code>theta.true</code> are the simulation truth parameter values in
different parametrizations.
</p>

<dl>
<dt>beta.true</dt><dd><p>Regression coefficient vector for model
<code>resp ~ varb + 0 + z1 + z2 + I(z1^2) + I(z1*z2) + I(z2^2)</code>.</p>
</dd>
<dt>mu.true</dt><dd><p>Unconditional mean value parameter vector for same
model.</p>
</dd> 
<dt>phi.true</dt><dd><p>Unconditional canonical value parameter vector for
same model.</p>
</dd> 
<dt>theta.true</dt><dd><p>Conditional canonical value parameter vector for
same model.</p>
</dd>
</dl>

<p>The objects <code>fam</code>,  <code>pred</code>, and <code>vars</code>
specify the aster model graphical and probabilistic structure.
</p>

<dl>
<dt>fam</dt><dd><p>Integer vector giving the families of the variables in
the graph.</p>
</dd>
<dt>pred</dt><dd><p>Integer vector giving the predecessors of the variables in
the graph.</p>
</dd>
<dt>vars</dt><dd><p>Character vector giving the names of the variables in
the graph.</p>
</dd>
</dl>

<p>The objects <code>ladata</code> and <code>redata</code> are the simulated data
in two forms <code>"wide"</code> and <code>"long"</code> in the terminology
of the <code>reshape</code> function.
</p>

<dl>
<dt>ladata</dt><dd><p>Data frame with variables <code>y</code>, <code>z1</code>,
<code>z2</code> used for Lande-Arnold type estimation of fitness landscape.
<code>y</code> is the response, fitness, and <code>z1</code> and <code>z1</code> are
predictor variables, phenotypes.</p>
</dd>
<dt>redata</dt><dd><p>Data frame with variables <code>resp</code>, <code>z1</code>,
<code>z2</code>, <code>varb</code>, <code>id</code>, <code>root</code>
used for aster type estimation of fitness landscape.
<code>resp</code> is the response, containing all components of fitness,
and <code>z1</code> and <code>z1</code> are predictor variables, phenotypes.
<code>varb</code> is a factor whose levels are are elements of <code>vars</code>
indicating which elements of <code>resp</code> go with which nodes of the
aster model graphical structure.  The variables <code>z1</code> and <code>z2</code>
have been set equal to zero except when <code>grep("nseed", varb)</code> is
<code>TRUE</code>.  For the rationale see Section 3.2 of TR 669 referenced
below.
</p>
</dd>
</dl>



<h3>Source</h3>

<p>Geyer, C. J and Shaw, R. G. (2008)
Supporting Data Analysis for a talk to be given at Evolution 2008.
Technical Report No. 669.  School of Statistics, University of Minnesota.
<a href="http://hdl.handle.net/11299/56204">http://hdl.handle.net/11299/56204</a>.
</p>


<h3>References</h3>

<p>Geyer, C. J and Shaw, R. G. (2009)
Hypothesis Tests and Confidence Intervals
Involving Fitness Landscapes fit by Aster Models.
Technical Report No. 671.  School of Statistics, University of Minnesota.
<a href="http://hdl.handle.net/11299/56219">http://hdl.handle.net/11299/56219</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(sim)
## Not run: 
### CRAN policy says examples must take &lt; 5 sec.  This doesn't.
out6 &lt;- aster(resp ~ varb + 0 + z1 + z2 + I(z1^2) + I(z1*z2) + I(z2^2),
    pred, fam, varb, id, root, data = redata)
summary(out6)

## End(Not run)
lout &lt;- lm(y ~ z1 + z2 + I(z1^2) + I(z1*z2) + I(z2^2), data = ladata)
summary(lout)
</code></pre>

<hr>
<h2 id='summary.aster'>Summarizing Aster Model Fits</h2><span id='topic+summary.aster'></span><span id='topic+print.summary.aster'></span>

<h3>Description</h3>

<p>These functions are all <code><a href="utils.html#topic+methods">methods</a></code> for class <code>aster</code> or
<code>summary.aster</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'aster'
summary(object, info = c("expected", "observed"),
    info.tol = sqrt(.Machine$double.eps),  show.graph = FALSE, ...)

## S3 method for class 'summary.aster'
print(x, digits = max(3, getOption("digits") - 3),
      signif.stars = getOption("show.signif.stars"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.aster_+3A_object">object</code></td>
<td>
<p>an object of class <code>"aster"</code>, usually, a result of a
call to <code><a href="#topic+aster">aster</a></code>.</p>
</td></tr>
<tr><td><code id="summary.aster_+3A_info">info</code></td>
<td>
<p>the type of Fisher information use to compute standard errors.</p>
</td></tr>
<tr><td><code id="summary.aster_+3A_info.tol">info.tol</code></td>
<td>
<p>tolerance for eigenvalues of Fisher information.
If <code>eval</code> is the vector of eigenvalues of the information matrix,
then <code>eval &lt; cond.tol * max(eval)</code> are considered zero.  Hence the
corresponding eigenvectors are directions of constancy or recession of
the log likelihood.</p>
</td></tr>
<tr><td><code id="summary.aster_+3A_show.graph">show.graph</code></td>
<td>
<p>if <code>TRUE</code>, show the graphical model.</p>
</td></tr>
<tr><td><code id="summary.aster_+3A_x">x</code></td>
<td>
<p>an object of class <code>"summary.aster"</code>, usually, a result of a
call to <code>summary.aster</code>.</p>
</td></tr>
<tr><td><code id="summary.aster_+3A_digits">digits</code></td>
<td>
<p>the number of significant digits to use when printing.</p>
</td></tr>
<tr><td><code id="summary.aster_+3A_signif.stars">signif.stars</code></td>
<td>
<p>logical. If <code>TRUE</code>, &ldquo;significance stars&rdquo;
are printed for each coefficient.</p>
</td></tr>
<tr><td><code id="summary.aster_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>summary.aster</code> returns an object of class <code>"summary.aster"</code>
list with the same components as <code>object</code>, which is of class
<code>"aster"</code>.
</p>


<h3>Directions of Recession</h3>

<p>This function may give an error message
<code>"cannot compute standard errors, apparent directions of recession"</code>.
There are two reasons why this can happen.
</p>

<ul>
<li><p> There may actually be a direction of recession (DOR).  Then the
maximum likelihood estimate does not exist; increasing the likelihood
drives (some of) the coefficients to infinity or minus infinity.
</p>
<p>This function's guess at the DOR can be extracted
from the error object obtained by wrapping this function
in <code><a href="base.html#topic+try">try</a></code> and then extracting the <code>dor</code> component
of the <code>condition</code> attribute of the error object.
An example of this is on the help page for the <code><a href="#topic+foobar">foobar</a></code>
data set.
</p>
<p>This function's guessed DOR are apparent null eigenvector(s) of the Fisher
information matrix.  Due to inaccuracy of computer arithmetic, this is
only a guess.  What are deemed null eigenvectors is controlled by the
<code>info.tol</code> argument of this function.  Reducing <code>info.tol</code>
to perhaps <code>1e-9</code> or <code>1e-10</code> or even a little lower
may make the putative DOR go away.  In this case they were probably
bogus (see next item).  Reducing <code>info.tol</code> to near or below the
machine epsilon <code>.Machine$double.eps</code> (<code><a href="base.html#topic+.Machine">.Machine</a></code>)
instructs this function to feed you garbage with no error or warning.
</p>
<p>Putative DOR are probably true DOR if they are highly patterned with
many zero or nearly zero components and other components that are
nearly (small) integer multiples of each other.
Putative DOR are probably bogus if they look like random noise.
</p>
<p>DOR, if true, cannot simply be ignored.  For more information,
including how to do more rigorous investigation of whether putative
DOR are true or bogus,
see the example on the help page for the <code><a href="#topic+foobar">foobar</a></code>
data set and the reference cited on that help page.
</p>
</li>
<li><p> All of the putative directions of recession may be bogus.
Due to inaccuracy of computer arithmetic, ill-conditioning
of predictor variables, or ill-conditioning of the aster model itself
(large graphs cause more inaccurate computation), what appear to be
null eigenvectors of the Fisher information matrix need not be true
null eigenvectors.
</p>
<p>In this case, the problem will go away when <code>info.tol</code> is decreased
slightly.  Only when one has proved that there is no DOR, should one
use <code>info.tol = 1e-20</code> which says to ignore the problem altogether
(whether putative DOR are true or bogus).
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+aster">aster</a></code>, <code><a href="base.html#topic+summary">summary</a></code>.
</p>

<hr>
<h2 id='summary.reaster'>Summarizing Aster Model with Random Effects Fits</h2><span id='topic+summary.reaster'></span><span id='topic+print.summary.reaster'></span>

<h3>Description</h3>

<p>These functions are all <code><a href="utils.html#topic+methods">methods</a></code> for class <code>reaster</code> or
<code>summary.reaster</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'reaster'
summary(object, standard.deviation = TRUE, ...)

## S3 method for class 'summary.reaster'
print(x, digits = max(3, getOption("digits") - 3),
      signif.stars = getOption("show.signif.stars"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.reaster_+3A_object">object</code></td>
<td>
<p>an object of class <code>"reaster"</code>, usually, a result of a
call to <code><a href="#topic+reaster">reaster</a></code>.</p>
</td></tr>
<tr><td><code id="summary.reaster_+3A_standard.deviation">standard.deviation</code></td>
<td>
<p>if <code>TRUE</code>, treat the parameters described
in the &ldquo;variance components&rdquo; section of the printout are square
roots of variance components (that is, standard deviations) rather
than the variance components themselves.  Warning: if <code>FALSE</code>
so actual variance components are described, (asymptotic, approximate)
standard errors are zero when they the variance components are zero
(see details section below).</p>
</td></tr>
<tr><td><code id="summary.reaster_+3A_x">x</code></td>
<td>
<p>an object of class <code>"summary.reaster"</code>, usually, a result of a
call to <code>summary.reaster</code>.</p>
</td></tr>
<tr><td><code id="summary.reaster_+3A_digits">digits</code></td>
<td>
<p>the number of significant digits to use when printing.</p>
</td></tr>
<tr><td><code id="summary.reaster_+3A_signif.stars">signif.stars</code></td>
<td>
<p>logical. If <code>TRUE</code>, &ldquo;significance stars&rdquo;
are printed for each coefficient.</p>
</td></tr>
<tr><td><code id="summary.reaster_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code><a href="#topic+reaster">reaster</a></code> function only does approximate maximum likelihood.
Even if it did actual maximum likelihood, standard errors would be only
approximate.  Standard errors for variance components are derived via
the delta method from standard errors for square roots of variance
components (standard deviations).  Hence P-values for variance components
and square roots of variance components do not agree exactly (although
they do asymptotically).
</p>


<h3>Value</h3>

<p><code>summary.reaster</code> returns an object of class <code>"summary.reaster"</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+reaster">reaster</a></code>, <code><a href="base.html#topic+summary">summary</a></code>.
</p>

<hr>
<h2 id='truncated'>K-Truncated Distributions</h2><span id='topic+truncated'></span><span id='topic+rktp'></span><span id='topic+rktnb'></span><span id='topic+rnzp'></span>

<h3>Description</h3>

<p>Random generation for the <code class="reqn">k</code>-truncated Poisson distribution
or for the <code class="reqn">k</code>-truncated negative binomial distribution, where
&ldquo;<code class="reqn">k</code>-truncated&rdquo; means conditioned on being strictly greater
than <code class="reqn">k</code>.  If <code>xpred</code> is not one, then the random variate is
the sum of <code>xpred</code> such random variates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rktp(n, k, mu, xpred = 1)
rktnb(n, size, k, mu, xpred = 1)
rnzp(n, mu, xpred = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="truncated_+3A_n">n</code></td>
<td>
<p>number of random values to return.  If <code>length(n) &gt; 1</code>,
the length is taken to be the number required.</p>
</td></tr>
<tr><td><code id="truncated_+3A_size">size</code></td>
<td>
<p>the size parameter for the negative binomial distribution.</p>
</td></tr>
<tr><td><code id="truncated_+3A_k">k</code></td>
<td>
<p>truncation limit.</p>
</td></tr>
<tr><td><code id="truncated_+3A_xpred">xpred</code></td>
<td>
<p>number of trials.</p>
</td></tr>
<tr><td><code id="truncated_+3A_mu">mu</code></td>
<td>
<p>vector of positive means.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>rktp</code> simulates <code class="reqn">k</code>-truncated Poisson random variates.
<code>rktnb</code> simulates <code class="reqn">k</code>-truncated negative binomial random variates.
<code>rnzp</code> simulates zero-truncated Poisson random variates
(maintained only for backward compatibility, it now calls <code>rktp</code>).
</p>


<h3>Value</h3>

<p>a vector of random deviates.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+families">families</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>rktp(10, 2, 0.75)
rktnb(10, 2.222, 2, 0.75)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
