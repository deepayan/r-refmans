<!DOCTYPE html><html><head><title>Help for package Kernelheaping</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {Kernelheaping}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#createSim.Kernelheaping'><p>Create heaped data for Simulation</p></a></li>
<li><a href='#dbivr'><p>Bivariate kernel density estimation for rounded data</p></a></li>
<li><a href='#dclass'><p>Kernel density estimation for classified data</p></a></li>
<li><a href='#dheaping'><p>Kernel density estimation for heaped data</p></a></li>
<li><a href='#dshape3dProp'><p>3d Kernel density estimation for data classified in polygons or shapes</p></a></li>
<li><a href='#dshapebivr'><p>Bivariate Kernel density estimation for data classified in polygons or shapes</p></a></li>
<li><a href='#dshapebivrProp'><p>Bivariate Kernel density estimation for data classified in polygons or shapes</p></a></li>
<li><a href='#Kernelheaping'><p>Kernel Density Estimation for Heaped Data</p></a></li>
<li><a href='#plot.bivrounding'><p>Plot Kernel density estimate of heaped data naively and corrected by partly bayesian model</p></a></li>
<li><a href='#plot.Kernelheaping'><p>Plot Kernel density estimate of heaped data naively and corrected by partly bayesian model</p></a></li>
<li><a href='#sim.Kernelheaping'><p>Simulation of heaping correction method</p></a></li>
<li><a href='#simSummary.Kernelheaping'><p>Simulation Summary</p></a></li>
<li><a href='#students'><p>Student0405</p></a></li>
<li><a href='#summary.Kernelheaping'><p>Prints some descriptive statistics (means and quantiles) for the estimated rounding, bias and acceleration (beta) parameters</p></a></li>
<li><a href='#toOtherShape'><p>Transfer observations to other shape</p></a></li>
<li><a href='#tracePlots'><p>Plots some trace plots for the rounding, bias and acceleration (beta) parameters</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Kernel Density Estimation for Heaped and Rounded Data</td>
</tr>
<tr>
<td>Version:</td>
<td>2.3.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-01-26</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.15.0), MASS, ks, sparr</td>
</tr>
<tr>
<td>Imports:</td>
<td>sp, plyr, dplyr, fastmatch, fitdistrplus, GB2, magrittr,
mvtnorm</td>
</tr>
<tr>
<td>Author:</td>
<td>Marcus Gross [aut, cre],
  Lukas Fuchs [aut],
  Kerstin Erfurth [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Marcus Gross &lt;marcus.gross@inwt-statistics.de&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>In self-reported or anonymised data the user often encounters
    heaped data, i.e. data which are rounded (to a possibly different degree
    of coarseness). While this is mostly a minor problem in parametric density
    estimation the bias can be very large for non-parametric methods such as kernel
    density estimation. This package implements a partly Bayesian algorithm treating
    the true unknown values as additional parameters and estimates the rounding
    parameters to give a corrected kernel density estimate. It supports various
    standard bandwidth selection methods. Varying rounding probabilities (depending
    on the true value) and asymmetric rounding is estimable as well: Gross, M. and Rendtel, U. (2016) (&lt;<a href="https://doi.org/10.1093%2Fjssam%2Fsmw011">doi:10.1093/jssam/smw011</a>&gt;).
    Additionally, bivariate non-parametric density estimation for rounded data, Gross, M. et al. (2016) (&lt;<a href="https://doi.org/10.1111%2Frssa.12179">doi:10.1111/rssa.12179</a>&gt;),
    as well as data aggregated on areas is supported.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.0</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-01-26 18:23:59 UTC; M</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-01-26 18:42:52 UTC</td>
</tr>
</table>
<hr>
<h2 id='createSim.Kernelheaping'>Create heaped data for Simulation</h2><span id='topic+createSim.Kernelheaping'></span>

<h3>Description</h3>

<p>Create heaped data for Simulation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>createSim.Kernelheaping(
  n,
  distribution,
  rounds,
  thresholds,
  offset = 0,
  downbias = 0.5,
  Beta = 0,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="createSim.Kernelheaping_+3A_n">n</code></td>
<td>
<p>sample size</p>
</td></tr>
<tr><td><code id="createSim.Kernelheaping_+3A_distribution">distribution</code></td>
<td>
<p>name of the distribution where random sampling is available, e.g. &quot;norm&quot;</p>
</td></tr>
<tr><td><code id="createSim.Kernelheaping_+3A_rounds">rounds</code></td>
<td>
<p>rounding values</p>
</td></tr>
<tr><td><code id="createSim.Kernelheaping_+3A_thresholds">thresholds</code></td>
<td>
<p>rounding thresholds (for Beta=0)</p>
</td></tr>
<tr><td><code id="createSim.Kernelheaping_+3A_offset">offset</code></td>
<td>
<p>certain value added to all observed random samples</p>
</td></tr>
<tr><td><code id="createSim.Kernelheaping_+3A_downbias">downbias</code></td>
<td>
<p>bias parameter</p>
</td></tr>
<tr><td><code id="createSim.Kernelheaping_+3A_beta">Beta</code></td>
<td>
<p>acceleration paramter</p>
</td></tr>
<tr><td><code id="createSim.Kernelheaping_+3A_...">...</code></td>
<td>
<p>additional attributes handed over to &quot;rdistribution&quot; (i.e. rnorm, rgamma,..)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List of heaped values, true values and input parameters
</p>

<hr>
<h2 id='dbivr'>Bivariate kernel density estimation for rounded data</h2><span id='topic+dbivr'></span>

<h3>Description</h3>

<p>Bivariate kernel density estimation for rounded data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dbivr(
  xrounded,
  roundvalue,
  burnin = 2,
  samples = 5,
  adaptive = FALSE,
  gridsize = 200
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dbivr_+3A_xrounded">xrounded</code></td>
<td>
<p>rounded values from which to estimate bivariate density, matrix with 2 columns (x,y)</p>
</td></tr>
<tr><td><code id="dbivr_+3A_roundvalue">roundvalue</code></td>
<td>
<p>rounding value (side length of square in that the true value lies around the rounded one)</p>
</td></tr>
<tr><td><code id="dbivr_+3A_burnin">burnin</code></td>
<td>
<p>burn-in sample size</p>
</td></tr>
<tr><td><code id="dbivr_+3A_samples">samples</code></td>
<td>
<p>sampling iteration size</p>
</td></tr>
<tr><td><code id="dbivr_+3A_adaptive">adaptive</code></td>
<td>
<p>set to TRUE for adaptive bandwidth</p>
</td></tr>
<tr><td><code id="dbivr_+3A_gridsize">gridsize</code></td>
<td>
<p>number of evaluation grid points</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns a list object with the following objects (besides all input objects):
</p>
<table>
<tr><td><code>Mestimates</code></td>
<td>
<p>kde object containing the corrected density estimate</p>
</td></tr>
<tr><td><code>gridx</code></td>
<td>
<p>Vector Grid on which density is evaluated (x)</p>
</td></tr>
<tr><td><code>gridy</code></td>
<td>
<p>Vector Grid on which density is evaluated (y)</p>
</td></tr>
<tr><td><code>resultDensity</code></td>
<td>
<p>Array with Estimated Density for each iteration</p>
</td></tr>
<tr><td><code>resultX</code></td>
<td>
<p>Matrix of true latent values X estimates</p>
</td></tr>
<tr><td><code>delaigle</code></td>
<td>
<p>Matrix of Delaigle estimator estimates</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># Create Mu and Sigma  -----------------------------------------------------------
mu1 &lt;- c(0, 0)
mu2 &lt;- c(5, 3)
mu3 &lt;- c(-4, 1)
Sigma1 &lt;- matrix(c(4, 3, 3, 4), 2, 2)
Sigma2 &lt;- matrix(c(3, 0.5, 0.5, 1), 2, 2)
Sigma3 &lt;- matrix(c(5, 4, 4, 6), 2, 2)
# Mixed Normal Distribution -------------------------------------------------------
mus &lt;- rbind(mu1, mu2, mu3)
Sigmas &lt;- rbind(Sigma1, Sigma2, Sigma3)
props &lt;- c(1/3, 1/3, 1/3)
## Not run: xtrue=rmvnorm.mixt(n=1000, mus=mus, Sigmas=Sigmas, props=props)
roundvalue=2
xrounded=plyr::round_any(xtrue,roundvalue)
est &lt;- dbivr(xrounded,roundvalue=roundvalue,burnin=5,samples=10)

#Plot corrected and Naive distribution
plot(est,trueX=xtrue)
#for comparison: plot true density
 dens=dmvnorm.mixt(x=expand.grid(est$Mestimates$eval.points[[1]],est$Mestimates$eval.points[[2]]),
  mus=mus, Sigmas=Sigmas, props=props)
 dens=matrix(dens,nrow=length(est$gridx),ncol=length(est$gridy))
 contour(dens,x=est$Mestimates$eval.points[[1]],y=est$Mestimates$eval.points[[2]],
    xlim=c(min(est$gridx),max(est$gridx)),ylim=c(min(est$gridy),max(est$gridy)),main="True Density")
## End(Not run)
</code></pre>

<hr>
<h2 id='dclass'>Kernel density estimation for classified data</h2><span id='topic+dclass'></span>

<h3>Description</h3>

<p>Kernel density estimation for classified data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dclass(
  xclass,
  burnin = 2,
  samples = 5,
  boundary = FALSE,
  bw = "nrd0",
  evalpoints = 200,
  adjust = 1,
  dFunc = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dclass_+3A_xclass">xclass</code></td>
<td>
<p>classified values; matrix with two columns: lower and upper value</p>
</td></tr>
<tr><td><code id="dclass_+3A_burnin">burnin</code></td>
<td>
<p>burn-in sample size</p>
</td></tr>
<tr><td><code id="dclass_+3A_samples">samples</code></td>
<td>
<p>sampling iteration size</p>
</td></tr>
<tr><td><code id="dclass_+3A_boundary">boundary</code></td>
<td>
<p>TRUE for positive only data (no positive density for negative values)</p>
</td></tr>
<tr><td><code id="dclass_+3A_bw">bw</code></td>
<td>
<p>bandwidth selector method, defaults to &quot;nrd0&quot; see <code>density</code> for more options</p>
</td></tr>
<tr><td><code id="dclass_+3A_evalpoints">evalpoints</code></td>
<td>
<p>number of evaluation grid points</p>
</td></tr>
<tr><td><code id="dclass_+3A_adjust">adjust</code></td>
<td>
<p>as in <code>density</code>, the user can multiply the bandwidth by a certain factor such that bw=adjust*bw</p>
</td></tr>
<tr><td><code id="dclass_+3A_dfunc">dFunc</code></td>
<td>
<p>character optional density (with &quot;d&quot;, &quot;p&quot; and &quot;q&quot; functions) function name for parametric estimation such as &quot;norm&quot; &quot;gamma&quot; or &quot;lnorm&quot;</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns a list object with the following objects (besides all input objects):
</p>
<table>
<tr><td><code>Mestimates</code></td>
<td>
<p>kde object containing the corrected density estimate</p>
</td></tr>
<tr><td><code>gridx</code></td>
<td>
<p>Vector Grid on which density is evaluated</p>
</td></tr>
<tr><td><code>resultDensity</code></td>
<td>
<p>Matrix with Estimated Density for each iteration</p>
</td></tr>
<tr><td><code>resultX</code></td>
<td>
<p>Matrix of true latent values X estimates</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>x=rlnorm(500, meanlog = 8, sdlog = 1)
classes &lt;- c(0,500,1000,1500,2000,2500,3000,4000,5000,6000,8000,10000,15000,Inf)
xclass &lt;- cut(x,breaks=classes)
xclass &lt;- cbind(classes[as.numeric(xclass)], classes[as.numeric(xclass) + 1])
densityEst &lt;- dclass(xclass=xclass, burnin=20, samples=50, evalpoints=1000)
plot(densityEst$Mestimates~densityEst$gridx ,lwd=2, type = "l")
</code></pre>

<hr>
<h2 id='dheaping'>Kernel density estimation for heaped data</h2><span id='topic+dheaping'></span>

<h3>Description</h3>

<p>Kernel density estimation for heaped data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dheaping(
  xheaped,
  rounds,
  burnin = 5,
  samples = 10,
  setBias = FALSE,
  weights = NULL,
  bw = "nrd0",
  boundary = FALSE,
  unequal = FALSE,
  random = FALSE,
  adjust = 1,
  recall = F,
  recallParams = c(1/3, 1/3)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dheaping_+3A_xheaped">xheaped</code></td>
<td>
<p>heaped values from which to estimate density of x</p>
</td></tr>
<tr><td><code id="dheaping_+3A_rounds">rounds</code></td>
<td>
<p>rounding values, numeric vector of length &gt;=1</p>
</td></tr>
<tr><td><code id="dheaping_+3A_burnin">burnin</code></td>
<td>
<p>burn-in sample size</p>
</td></tr>
<tr><td><code id="dheaping_+3A_samples">samples</code></td>
<td>
<p>sampling iteration size</p>
</td></tr>
<tr><td><code id="dheaping_+3A_setbias">setBias</code></td>
<td>
<p>if TRUE a rounding Bias parameter is estimated. For values above 0.5, the respondents
are more prone to round down, while for values &lt; 0.5 they are more likely to round up</p>
</td></tr>
<tr><td><code id="dheaping_+3A_weights">weights</code></td>
<td>
<p>optional numeric vector of sampling weights</p>
</td></tr>
<tr><td><code id="dheaping_+3A_bw">bw</code></td>
<td>
<p>bandwidth selector method, defaults to &quot;nrd0&quot; see <code>density</code> for more options</p>
</td></tr>
<tr><td><code id="dheaping_+3A_boundary">boundary</code></td>
<td>
<p>TRUE for positive only data (no positive density for negative values)</p>
</td></tr>
<tr><td><code id="dheaping_+3A_unequal">unequal</code></td>
<td>
<p>if TRUE a probit model is fitted for the rounding probabilities with log(true value) as regressor</p>
</td></tr>
<tr><td><code id="dheaping_+3A_random">random</code></td>
<td>
<p>if TRUE a random effect probit model is fitted for rounding probabilities</p>
</td></tr>
<tr><td><code id="dheaping_+3A_adjust">adjust</code></td>
<td>
<p>as in <code>density</code>, the user can multiply the bandwidth by a certain factor such that bw=adjust*bw</p>
</td></tr>
<tr><td><code id="dheaping_+3A_recall">recall</code></td>
<td>
<p>if TRUE a recall error is introduced to the heaping model</p>
</td></tr>
<tr><td><code id="dheaping_+3A_recallparams">recallParams</code></td>
<td>
<p>recall error model parameters expression(nu) and expression(eta). Default is c(1/3, 1/3)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns a list object with the following objects (besides all input objects):
</p>
<table>
<tr><td><code>meanPostDensity</code></td>
<td>
<p>Vector of Mean Posterior Density</p>
</td></tr>
<tr><td><code>gridx</code></td>
<td>
<p>Vector Grid on which density is evaluated</p>
</td></tr>
<tr><td><code>resultDensity</code></td>
<td>
<p>Matrix with Estimated Density for each iteration</p>
</td></tr>
<tr><td><code>resultRR</code></td>
<td>
<p>Matrix with rounding probability threshold values for each iteration (on probit scale)</p>
</td></tr>
<tr><td><code>resultBias</code></td>
<td>
<p>Vector with estimated Bias parameter for each iteration</p>
</td></tr>
<tr><td><code>resultBeta</code></td>
<td>
<p>Vector with estimated Beta parameter for each iteration</p>
</td></tr>
<tr><td><code>resultX</code></td>
<td>
<p>Matrix of true latent values X estimates</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>#Simple Rounding   ----------------------------------------------------------
xtrue=rnorm(3000)
xrounded=round(xtrue)
est &lt;- dheaping(xrounded,rounds=1,burnin=20,samples=50)
plot(est,trueX=xtrue)

#####################
#####Heaping
#####################
#Real Data Example  ----------------------------------------------------------
# Student learning hours per week
data(students)
xheaped &lt;- as.numeric(na.omit(students$StudyHrs))
## Not run: est &lt;- dheaping(xheaped,rounds=c(1,2,5,10), boundary=TRUE, unequal=TRUE,burnin=20,samples=50)
plot(est)
summary(est)
## End(Not run)

#Simulate Data   ----------------------------------------------------------
Sim1 &lt;- createSim.Kernelheaping(n=500, distribution="norm",rounds=c(1,10,100),
thresholds=c(-0.5244005, 0.5244005), sd=100)
## Not run: est &lt;- dheaping(Sim1$xheaped,rounds=Sim1$rounds)
plot(est,trueX=Sim1$x)
## End(Not run)

#Biased rounding
Sim2 &lt;- createSim.Kernelheaping(n=500, distribution="gamma",rounds=c(1,2,5,10),
                     thresholds=c(-1.2815516, -0.6744898, 0.3853205),downbias=0.2,
                     shape=4,scale=8,offset=45)
## Not run: est &lt;- dheaping(Sim2$xheaped, rounds=Sim2$rounds, setBias=T, bw="SJ")
plot(est, trueX=Sim2$x)
summary(est)
tracePlots(est)
## End(Not run)

Sim3 &lt;- createSim.Kernelheaping(n=500, distribution="gamma",rounds=c(1,2,5,10),
thresholds=c(1.84, 2.64, 3.05), downbias=0.75, Beta=-0.5, shape=4, scale=8)
## Not run: est &lt;- dheaping(Sim3$xheaped,rounds=Sim3$rounds,boundary=TRUE,unequal=TRUE,setBias=T)
plot(est,trueX=Sim3$x)
## End(Not run)
</code></pre>

<hr>
<h2 id='dshape3dProp'>3d Kernel density estimation for data classified in polygons or shapes</h2><span id='topic+dshape3dProp'></span>

<h3>Description</h3>

<p>3d Kernel density estimation for data classified in polygons or shapes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dshape3dProp(
  data,
  burnin = 2,
  samples = 5,
  shapefile,
  gridsize = 200,
  boundary = FALSE,
  deleteShapes = NULL,
  fastWeights = TRUE,
  numChains = 1,
  numThreads = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dshape3dProp_+3A_data">data</code></td>
<td>
<p>data.frame with 5 columns: x-coordinate, y-coordinate (i.e. center of polygon) and number of observations in area for partial population and number of observations for complete observations and third variable (numeric).</p>
</td></tr>
<tr><td><code id="dshape3dProp_+3A_burnin">burnin</code></td>
<td>
<p>burn-in sample size</p>
</td></tr>
<tr><td><code id="dshape3dProp_+3A_samples">samples</code></td>
<td>
<p>sampling iteration size</p>
</td></tr>
<tr><td><code id="dshape3dProp_+3A_shapefile">shapefile</code></td>
<td>
<p>shapefile with number of polygons equal to nrow(data) / length(unique(data[,5]))</p>
</td></tr>
<tr><td><code id="dshape3dProp_+3A_gridsize">gridsize</code></td>
<td>
<p>number of evaluation grid points</p>
</td></tr>
<tr><td><code id="dshape3dProp_+3A_boundary">boundary</code></td>
<td>
<p>boundary corrected kernel density estimate?</p>
</td></tr>
<tr><td><code id="dshape3dProp_+3A_deleteshapes">deleteShapes</code></td>
<td>
<p>shapefile containing areas without observations</p>
</td></tr>
<tr><td><code id="dshape3dProp_+3A_fastweights">fastWeights</code></td>
<td>
<p>if TRUE weigths for boundary estimation are only computed for first 10 percent of samples to speed up computation</p>
</td></tr>
<tr><td><code id="dshape3dProp_+3A_numchains">numChains</code></td>
<td>
<p>number of chains of SEM algorithm</p>
</td></tr>
<tr><td><code id="dshape3dProp_+3A_numthreads">numThreads</code></td>
<td>
<p>number of threads to be used (only applicable if more than one chains)</p>
</td></tr>
</table>

<hr>
<h2 id='dshapebivr'>Bivariate Kernel density estimation for data classified in polygons or shapes</h2><span id='topic+dshapebivr'></span>

<h3>Description</h3>

<p>Bivariate Kernel density estimation for data classified in polygons or shapes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dshapebivr(
  data,
  burnin = 2,
  samples = 5,
  adaptive = FALSE,
  shapefile,
  gridsize = 200,
  boundary = FALSE,
  deleteShapes = NULL,
  fastWeights = TRUE,
  numChains = 1,
  numThreads = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dshapebivr_+3A_data">data</code></td>
<td>
<p>data.frame with 3 columns: x-coordinate, y-coordinate (i.e. center of polygon) and number of observations in area.</p>
</td></tr>
<tr><td><code id="dshapebivr_+3A_burnin">burnin</code></td>
<td>
<p>burn-in sample size</p>
</td></tr>
<tr><td><code id="dshapebivr_+3A_samples">samples</code></td>
<td>
<p>sampling iteration size</p>
</td></tr>
<tr><td><code id="dshapebivr_+3A_adaptive">adaptive</code></td>
<td>
<p>TRUE for adaptive kernel density estimation</p>
</td></tr>
<tr><td><code id="dshapebivr_+3A_shapefile">shapefile</code></td>
<td>
<p>shapefile with number of polygons equal to nrow(data)</p>
</td></tr>
<tr><td><code id="dshapebivr_+3A_gridsize">gridsize</code></td>
<td>
<p>number of evaluation grid points</p>
</td></tr>
<tr><td><code id="dshapebivr_+3A_boundary">boundary</code></td>
<td>
<p>boundary corrected kernel density estimate?</p>
</td></tr>
<tr><td><code id="dshapebivr_+3A_deleteshapes">deleteShapes</code></td>
<td>
<p>shapefile containing areas without observations</p>
</td></tr>
<tr><td><code id="dshapebivr_+3A_fastweights">fastWeights</code></td>
<td>
<p>if TRUE weigths for boundary estimation are only computed for first 10 percent of samples to speed up computation</p>
</td></tr>
<tr><td><code id="dshapebivr_+3A_numchains">numChains</code></td>
<td>
<p>number of chains of SEM algorithm</p>
</td></tr>
<tr><td><code id="dshapebivr_+3A_numthreads">numThreads</code></td>
<td>
<p>number of threads to be used (only applicable if more than one chains)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns a list object with the following objects (besides all input objects):
</p>
<table>
<tr><td><code>Mestimates</code></td>
<td>
<p>kde object containing the corrected density estimate</p>
</td></tr>
<tr><td><code>gridx</code></td>
<td>
<p>Vector Grid of x-coordinates on which density is evaluated</p>
</td></tr>
<tr><td><code>gridy</code></td>
<td>
<p>Vector Grid of y-coordinates on which density is evaluated</p>
</td></tr>
<tr><td><code>resultDensity</code></td>
<td>
<p>Matrix with Estimated Density for each iteration</p>
</td></tr>
<tr><td><code>resultX</code></td>
<td>
<p>Matrix of true latent values X estimates</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(maptools)

# Read Shapefile of Berlin Urban Planning Areas (download available from:
# https://www.statistik-berlin-brandenburg.de/opendata/RBS_OD_LOR_2015_12.zip)
Berlin &lt;- rgdal::readOGR("X:/SomeDir/RBS_OD_LOR_2015_12.shp") #(von daten.berlin.de)

# Get Dataset of Berlin Population (download available from:
# https://www.statistik-berlin-brandenburg.de/opendata/EWR201512E_Matrix.csv)
data &lt;- read.csv2("X:/SomeDir/EWR201512E_Matrix.csv")

# Form Dataset for Estimation Process
dataIn &lt;- cbind(t(sapply(1:length(Berlin@polygons),
 function(x) Berlin@polygons[[x]]@labpt)), data$E_E65U80)

#Estimate Bivariate Density
Est &lt;- dshapebivr(data = dataIn, burnin = 5, samples = 10, adaptive = FALSE,
                 shapefile = Berlin, gridsize = 325, boundary = TRUE)
## End(Not run)

# Plot Density over Area:
## Not run: breaks &lt;- seq(1E-16,max(Est$Mestimates$estimate),length.out = 20)
image.plot(x=Est$Mestimates$eval.points[[1]],y=Est$Mestimates$eval.points[[2]],
          z=Est$Mestimates$estimate, asp=1, breaks = breaks,
          col =  colorRampPalette(brewer.pal(9,"YlOrRd"))(length(breaks)-1))
plot(Berlin, add=TRUE)
## End(Not run)
</code></pre>

<hr>
<h2 id='dshapebivrProp'>Bivariate Kernel density estimation for data classified in polygons or shapes</h2><span id='topic+dshapebivrProp'></span>

<h3>Description</h3>

<p>Bivariate Kernel density estimation for data classified in polygons or shapes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dshapebivrProp(
  data,
  burnin = 2,
  samples = 5,
  adaptive = FALSE,
  shapefile,
  gridsize = 200,
  boundary = FALSE,
  deleteShapes = NULL,
  fastWeights = TRUE,
  numChains = 1,
  numThreads = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dshapebivrProp_+3A_data">data</code></td>
<td>
<p>data.frame with 4 columns: x-coordinate, y-coordinate (i.e. center of polygon) and number of observations in area for partial population and number of observations for complete observations.</p>
</td></tr>
<tr><td><code id="dshapebivrProp_+3A_burnin">burnin</code></td>
<td>
<p>burn-in sample size</p>
</td></tr>
<tr><td><code id="dshapebivrProp_+3A_samples">samples</code></td>
<td>
<p>sampling iteration size</p>
</td></tr>
<tr><td><code id="dshapebivrProp_+3A_adaptive">adaptive</code></td>
<td>
<p>TRUE for adaptive kernel density estimation</p>
</td></tr>
<tr><td><code id="dshapebivrProp_+3A_shapefile">shapefile</code></td>
<td>
<p>shapefile with number of polygons equal to nrow(data)</p>
</td></tr>
<tr><td><code id="dshapebivrProp_+3A_gridsize">gridsize</code></td>
<td>
<p>number of evaluation grid points</p>
</td></tr>
<tr><td><code id="dshapebivrProp_+3A_boundary">boundary</code></td>
<td>
<p>boundary corrected kernel density estimate?</p>
</td></tr>
<tr><td><code id="dshapebivrProp_+3A_deleteshapes">deleteShapes</code></td>
<td>
<p>shapefile containing areas without observations</p>
</td></tr>
<tr><td><code id="dshapebivrProp_+3A_fastweights">fastWeights</code></td>
<td>
<p>if TRUE weigths for boundary estimation are only computed for first 10 percent of samples to speed up computation</p>
</td></tr>
<tr><td><code id="dshapebivrProp_+3A_numchains">numChains</code></td>
<td>
<p>number of chains of SEM algorithm</p>
</td></tr>
<tr><td><code id="dshapebivrProp_+3A_numthreads">numThreads</code></td>
<td>
<p>number of threads to be used (only applicable if more than one chains)</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(maptools)

# Read Shapefile of Berlin Urban Planning Areas (download available from:
  https://www.statistik-berlin-brandenburg.de/opendata/RBS_OD_LOR_2015_12.zip)
Berlin &lt;- rgdal::readOGR("X:/SomeDir/RBS_OD_LOR_2015_12.shp") #(von daten.berlin.de)

# Get Dataset of Berlin Population (download available from:
# https://www.statistik-berlin-brandenburg.de/opendata/EWR201512E_Matrix.csv)
data &lt;- read.csv2("X:/SomeDir/EWR201512E_Matrix.csv")

# Form Dataset for Estimation Process
dataIn &lt;- cbind(t(sapply(1:length(Berlin@polygons),
function(x) Berlin@polygons[[x]]@labpt)), data$E_E65U80, data$E_E)

#Estimate Bivariate Proportions (may take some minutes)
PropEst &lt;- dshapebivrProp(data = dataIn, burnin = 5, samples = 20, adaptive = FALSE,
shapefile = Berlin, gridsize=325, numChains = 16, numThreads = 4)
## End(Not run)

# Plot Proportions over Area:
## Not run: 
breaks &lt;- seq(0,0.4,by=0.025)
image.plot(x=PropEst$Mestimates$eval.points[[1]],y=PropEst$Mestimates$eval.points[[2]],
          z=PropEst$proportion+1E-96, asp=1, breaks = breaks,
          col =  colorRampPalette(brewer.pal(9,"YlOrRd"))(length(breaks)-1))
plot(Berlin, add=TRUE)
## End(Not run)
</code></pre>

<hr>
<h2 id='Kernelheaping'>Kernel Density Estimation for Heaped Data</h2><span id='topic+Kernelheaping'></span>

<h3>Description</h3>

<p>In self-reported or anonymized data the user often encounters heaped data,
i.e. data which are rounded (to a possibly different degree of coarseness).
While this is mostly a minor problem in parametric density estimation the bias can be very large 
for non-parametric methods such as kernel density estimation. This package implements a partly 
Bayesian algorithm treating the true unknown values as additional parameters and estimates the
rounding parameters to give a corrected kernel density estimate. It supports various standard 
bandwidth selection methods. Varying rounding probabilities (depending on the true value) and 
asymmetric rounding is estimable as well. Additionally, bivariate non-parametric density estimation 
for rounded data is supported.
</p>


<h3>Details</h3>

<p>The most important function is <code><a href="#topic+dheaping">dheaping</a></code>. See the help and the attached examples on how to use the package.
</p>

<hr>
<h2 id='plot.bivrounding'>Plot Kernel density estimate of heaped data naively and corrected by partly bayesian model</h2><span id='topic+plot.bivrounding'></span>

<h3>Description</h3>

<p>Plot Kernel density estimate of heaped data naively and corrected by partly bayesian model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bivrounding'
plot(x, trueX = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.bivrounding_+3A_x">x</code></td>
<td>
<p>bivrounding object produced by <code>dbivr</code> function</p>
</td></tr>
<tr><td><code id="plot.bivrounding_+3A_truex">trueX</code></td>
<td>
<p>optional, if true values X are known (in simulations, for example) the 'Oracle' density estimate is added as well</p>
</td></tr>
<tr><td><code id="plot.bivrounding_+3A_...">...</code></td>
<td>
<p>additional arguments given to standard plot function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>plot with Kernel density estimates (Naive, Corrected and True (if provided))
</p>

<hr>
<h2 id='plot.Kernelheaping'>Plot Kernel density estimate of heaped data naively and corrected by partly bayesian model</h2><span id='topic+plot.Kernelheaping'></span>

<h3>Description</h3>

<p>Plot Kernel density estimate of heaped data naively and corrected by partly bayesian model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Kernelheaping'
plot(x, trueX = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.Kernelheaping_+3A_x">x</code></td>
<td>
<p>Kernelheaping object produced by <code>dheaping</code> function</p>
</td></tr>
<tr><td><code id="plot.Kernelheaping_+3A_truex">trueX</code></td>
<td>
<p>optional, if true values X are known (in simulations, for example) the 'Oracle' density estimate is added as well</p>
</td></tr>
<tr><td><code id="plot.Kernelheaping_+3A_...">...</code></td>
<td>
<p>additional arguments given to standard plot function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>plot with Kernel density estimates (Naive, Corrected and True (if provided))
</p>

<hr>
<h2 id='sim.Kernelheaping'>Simulation of heaping correction method</h2><span id='topic+sim.Kernelheaping'></span>

<h3>Description</h3>

<p>Simulation of heaping correction method
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim.Kernelheaping(
  simRuns,
  n,
  distribution,
  rounds,
  thresholds,
  downbias = 0.5,
  setBias = FALSE,
  Beta = 0,
  unequal = FALSE,
  burnin = 5,
  samples = 10,
  bw = "nrd0",
  offset = 0,
  boundary = FALSE,
  adjust = 1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sim.Kernelheaping_+3A_simruns">simRuns</code></td>
<td>
<p>number of simulations runs</p>
</td></tr>
<tr><td><code id="sim.Kernelheaping_+3A_n">n</code></td>
<td>
<p>sample size</p>
</td></tr>
<tr><td><code id="sim.Kernelheaping_+3A_distribution">distribution</code></td>
<td>
<p>name of the distribution where random sampling is available, e.g. &quot;norm&quot;</p>
</td></tr>
<tr><td><code id="sim.Kernelheaping_+3A_rounds">rounds</code></td>
<td>
<p>rounding values, numeric vector of length &gt;=1</p>
</td></tr>
<tr><td><code id="sim.Kernelheaping_+3A_thresholds">thresholds</code></td>
<td>
<p>rounding thresholds</p>
</td></tr>
<tr><td><code id="sim.Kernelheaping_+3A_downbias">downbias</code></td>
<td>
<p>Bias parameter used in the simulation</p>
</td></tr>
<tr><td><code id="sim.Kernelheaping_+3A_setbias">setBias</code></td>
<td>
<p>if TRUE a rounding Bias parameter is estimated. For values above 0.5, the respondents
are more prone to round down, while for values &lt; 0.5 they are more likely to round up</p>
</td></tr>
<tr><td><code id="sim.Kernelheaping_+3A_beta">Beta</code></td>
<td>
<p>Parameter of the probit model for rounding probabilities used in simulation</p>
</td></tr>
<tr><td><code id="sim.Kernelheaping_+3A_unequal">unequal</code></td>
<td>
<p>if TRUE a probit model is fitted for the rounding probabilities with log(true value) as regressor</p>
</td></tr>
<tr><td><code id="sim.Kernelheaping_+3A_burnin">burnin</code></td>
<td>
<p>burn-in sample size</p>
</td></tr>
<tr><td><code id="sim.Kernelheaping_+3A_samples">samples</code></td>
<td>
<p>sampling iteration size</p>
</td></tr>
<tr><td><code id="sim.Kernelheaping_+3A_bw">bw</code></td>
<td>
<p>bandwidth selector method, defaults to &quot;nrd0&quot; see <code>density</code> for more options</p>
</td></tr>
<tr><td><code id="sim.Kernelheaping_+3A_offset">offset</code></td>
<td>
<p>location shift parameter used simulation in simulation</p>
</td></tr>
<tr><td><code id="sim.Kernelheaping_+3A_boundary">boundary</code></td>
<td>
<p>TRUE for positive only data (no positive density for negative values)</p>
</td></tr>
<tr><td><code id="sim.Kernelheaping_+3A_adjust">adjust</code></td>
<td>
<p>as in <code>density</code>, the user can multiply the bandwidth by a certain factor such that bw=adjust*bw</p>
</td></tr>
<tr><td><code id="sim.Kernelheaping_+3A_...">...</code></td>
<td>
<p>additional attributes handed over to <code>createSim.Kernelheaping</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>List of estimation results
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: Sims1 &lt;- sim.Kernelheaping(simRuns=2, n=500, distribution="norm",
rounds=c(1,10,100), thresholds=c(0.3,0.4,0.3), sd=100)
## End(Not run)
</code></pre>

<hr>
<h2 id='simSummary.Kernelheaping'>Simulation Summary</h2><span id='topic+simSummary.Kernelheaping'></span>

<h3>Description</h3>

<p>Simulation Summary
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simSummary.Kernelheaping(sim, coverage = 0.9)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simSummary.Kernelheaping_+3A_sim">sim</code></td>
<td>
<p>Simulation object returned from sim.Kernelheaping</p>
</td></tr>
<tr><td><code id="simSummary.Kernelheaping_+3A_coverage">coverage</code></td>
<td>
<p>probability for computing coverage intervals</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list with summary statistics
</p>

<hr>
<h2 id='students'>Student0405</h2><span id='topic+students'></span>

<h3>Description</h3>

<p>Data collected during 2004 and 2005 from students in statistics classes 
at a large state university in the northeastern United States.
</p>


<h3>Source</h3>

<p>http://mathfaculty.fullerton.edu/mori/Math120/Data/readme
</p>


<h3>References</h3>

<p>Utts, J. M., &amp; Heckard, R. F. (2011). Mind on statistics. Cengage Learning.
</p>

<hr>
<h2 id='summary.Kernelheaping'>Prints some descriptive statistics (means and quantiles) for the estimated rounding, bias and acceleration (beta) parameters</h2><span id='topic+summary.Kernelheaping'></span>

<h3>Description</h3>

<p>Prints some descriptive statistics (means and quantiles) for the estimated rounding, bias and acceleration (beta) parameters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Kernelheaping'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.Kernelheaping_+3A_object">object</code></td>
<td>
<p>Kernelheaping object produced by <code>dheaping</code> function</p>
</td></tr>
<tr><td><code id="summary.Kernelheaping_+3A_...">...</code></td>
<td>
<p>unused</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Prints summary statistics
</p>

<hr>
<h2 id='toOtherShape'>Transfer observations to other shape</h2><span id='topic+toOtherShape'></span>

<h3>Description</h3>

<p>Transfer observations to other shape
</p>


<h3>Usage</h3>

<pre><code class='language-R'>toOtherShape(Mestimates, shapefile)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="toOtherShape_+3A_mestimates">Mestimates</code></td>
<td>
<p>Estimation object created by functions dshapebivr and dbivr</p>
</td></tr>
<tr><td><code id="toOtherShape_+3A_shapefile">shapefile</code></td>
<td>
<p>The new shapefile for which the observations shall be transferred to</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns the count, sd and 90
</p>

<hr>
<h2 id='tracePlots'>Plots some trace plots for the rounding, bias and acceleration (beta) parameters</h2><span id='topic+tracePlots'></span>

<h3>Description</h3>

<p>Plots some trace plots for the rounding, bias and acceleration (beta) parameters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tracePlots(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tracePlots_+3A_x">x</code></td>
<td>
<p>Kernelheaping object produced by <code>dheaping</code> function</p>
</td></tr>
<tr><td><code id="tracePlots_+3A_...">...</code></td>
<td>
<p>additional arguments given to standard plot function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Prints summary statistics
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
