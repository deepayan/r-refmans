<!DOCTYPE html><html><head><title>Help for package cubfits</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {cubfits}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#Asymmetric Laplace Distribution'><p>The Asymmetric Laplace Distribution</p></a></li>
<li><a href='#Cedric Convergence Utilities'><p>Cedric Convergence Utilities</p></a></li>
<li><a href='#Cedric Internal Functions'><p>All Cedric Internal Functions</p></a></li>
<li><a href='#Cedric IO Utilities'><p>Cedric IO Utilities</p></a></li>
<li><a href='#Cedric Plot Utilities'><p>Cedric Plot Utilities</p></a></li>
<li><a href='#Codon Adaptation Index'><p>Function for Codon Adaptation Index (CAI)</p></a></li>
<li><a href='#Controls'><p>Default Controlling Options</p></a></li>
<li><a href='#Coverting Utility'><p>Convert Data Frame to Other Formats</p></a></li>
<li><a href='#CUB Model Approximation'><p>Codon Usage Bias Approximation for ORFs without Expression</p></a></li>
<li><a href='#CUB Model Fits'><p>Codon Usage Bias Fits for Observed ORFs and Expression</p></a></li>
<li><a href='#CUB Model Prediction'><p>Codon Usage Bias Prediction for Observed ORFs</p></a></li>
<li><a href='#cubfits-package'><p>Codon Bias Usage Fits</p></a></li>
<li><a href='#Data Formats'><p>Data Formats</p></a></li>
<li><a href='#Datasets'><p>Datasets for Demonstrations</p></a></li>
<li><a href='#Estimate Phi'><p>Initialization of Phi (Generic)</p></a></li>
<li><a href='#Fit Multinomial'><p>Fit Multinomial Model (Generic)</p></a></li>
<li><a href='#Generating Utility'><p>Generating Data Structure</p></a></li>
<li><a href='#Initial Generic Functions'><p>Initial Generic Functions of Codon Usage Bias Fits</p></a></li>
<li><a href='#Input and Output Utility'><p>Input and Output Utility</p></a></li>
<li><a href='#Internal Functions'><p>All Internal Functions</p></a></li>
<li><a href='#Mixed Normal Optimization'><p>Mixed Normal Optimization</p></a></li>
<li><a href='#Plotbin'><p>Plot Binning Results</p></a></li>
<li><a href='#Plotmodel'><p>Plot Fitted Models</p></a></li>
<li><a href='#Plotprxy'><p>Predictive X-Y Plot</p></a></li>
<li><a href='#Posterior Results of Yassour2009'><p>Posterior Results of Yassour 2009 Yeast Experiment Dataset</p></a></li>
<li><a href='#Print'><p>Functions for Printing Objects According to Classes</p></a></li>
<li><a href='#Randomize SCUO Index'><p>Generate Randomized SCUO Index</p></a></li>
<li><a href='#Rearrangment Utility'><p>Rearrange Data Structure by ORF Names</p></a></li>
<li><a href='#SCUO Index'><p>Function for Synonymous Codon Usage Order (SCUO) Index</p></a></li>
<li><a href='#Selection on Codon Usage'><p>Function for Selection on Codon Usage (SCU)</p></a></li>
<li><a href='#Simulation Tool'><p>Simulate ORFs and Expression Data</p></a></li>
<li><a href='#Yassour2009'><p>Yassour 2009 Yeast Experiment Dataset</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>0.1-4</td>
</tr>
<tr>
<td>Date:</td>
<td>2021-11-06</td>
</tr>
<tr>
<td>Title:</td>
<td>Codon Usage Bias Fits</td>
</tr>
<tr>
<td>Depends:</td>
<td>R(&ge; 4.0.0), methods, coda, foreach, parallel, stats,
graphics, utils</td>
</tr>
<tr>
<td>Suggests:</td>
<td>seqinr, VGAM, EMCluster</td>
</tr>
<tr>
<td>Enhances:</td>
<td>pbdMPI (&ge; 0.3-1)</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>LazyData:</td>
<td>yes</td>
</tr>
<tr>
<td>Description:</td>
<td>Estimating mutation and selection coefficients on synonymous
       codon bias usage based on models of ribosome overhead cost (ROC).
       Multinomial logistic regression and Markov Chain Monte Carlo are used to
       estimate and predict protein production rates with/without the presence
       of expressions and measurement errors. Work flows with examples for
       simulation, estimation and prediction processes are also provided
       with parallelization speedup. The whole framework is tested with
       yeast genome and gene expression data of Yassour, et al. (2009)
       &lt;<a href="https://doi.org/10.1073%2Fpnas.0812841106">doi:10.1073/pnas.0812841106</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.mozilla.org/en-US/MPL/2.0/">Mozilla Public License 2.0</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/snoweye/cubfits/issues">https://github.com/snoweye/cubfits/issues</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/snoweye/cubfits">https://github.com/snoweye/cubfits</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Wei-Chen Chen &lt;wccsnow@gmail.com&gt;</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-11-07 01:53:23 UTC; snoweye</td>
</tr>
<tr>
<td>Author:</td>
<td>Wei-Chen Chen [aut, cre],
  Russell Zaretzki [aut],
  William Howell [aut],
  Cedric Landerer [aut],
  Drew Schmidt [aut],
  Michael A. Gilchrist [aut],
  Preston Hewgley [ctb],
  Students REU13 [ctb]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-11-07 17:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='Asymmetric+20Laplace+20Distribution'>The Asymmetric Laplace Distribution</h2><span id='topic+dasl'></span><span id='topic+dasla'></span><span id='topic+pasl'></span><span id='topic+pasla'></span><span id='topic+qasl'></span><span id='topic+qasla'></span><span id='topic+rasl'></span><span id='topic+rasla'></span><span id='topic+asl.optim'></span>

<h3>Description</h3>

<p>Density, probability, quantile, random number generation, and MLE functions
for the asymmetric Laplace distribution
with parameters either in <code class="reqn">ASL(\theta, \mu, \sigma)</code>
or the alternative
<code class="reqn">ASL^*(\theta, \kappa, \sigma)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  dasl(x, theta = 0, mu = 0, sigma = 1, log = FALSE)
  dasla(x, theta = 0, kappa = 1, sigma = 1, log = FALSE)

  pasl(q, theta = 0, mu = 0, sigma = 1, lower.tail = TRUE,
          log.p = FALSE)
  pasla(q, theta = 0, kappa = 1, sigma = 1, lower.tail = TRUE,
           log.p = FALSE)

  qasl(p, theta = 0, mu = 0, sigma = 1, lower.tail = TRUE,
          log.p = FALSE)
  qasla(p, theta = 0, kappa = 1, sigma = 1, lower.tail = TRUE,
           log.p = FALSE)

  rasl(n, theta = 0, mu = 0, sigma = 1)
  rasla(n, theta = 0, kappa = 1, sigma = 1)

  asl.optim(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Asymmetric+2B20Laplace+2B20Distribution_+3A_x">x</code>, <code id="Asymmetric+2B20Laplace+2B20Distribution_+3A_q">q</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="Asymmetric+2B20Laplace+2B20Distribution_+3A_p">p</code></td>
<td>
<p>vector of probabilities.</p>
</td></tr>
<tr><td><code id="Asymmetric+2B20Laplace+2B20Distribution_+3A_n">n</code></td>
<td>
<p>number of observations. If <code>length(n) &gt; 1</code>, the length is
taken to be the number required.</p>
</td></tr>
<tr><td><code id="Asymmetric+2B20Laplace+2B20Distribution_+3A_theta">theta</code></td>
<td>
<p>center parameter.</p>
</td></tr>
<tr><td><code id="Asymmetric+2B20Laplace+2B20Distribution_+3A_mu">mu</code>, <code id="Asymmetric+2B20Laplace+2B20Distribution_+3A_kappa">kappa</code></td>
<td>
<p>location parameters.</p>
</td></tr>
<tr><td><code id="Asymmetric+2B20Laplace+2B20Distribution_+3A_sigma">sigma</code></td>
<td>
<p>shape parameter.</p>
</td></tr>
<tr><td><code id="Asymmetric+2B20Laplace+2B20Distribution_+3A_log">log</code>, <code id="Asymmetric+2B20Laplace+2B20Distribution_+3A_log.p">log.p</code></td>
<td>
<p>logical; if <code>TRUE</code>, probabilities p are given as
log(p).</p>
</td></tr>
<tr><td><code id="Asymmetric+2B20Laplace+2B20Distribution_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical; if <code>TRUE</code> (default), probabilities are
P[X &lt;= x] otherwise, P[X &gt; x].</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The density <code class="reqn">f(x)</code> of
<code class="reqn">ASL^*(\theta, \kappa, \sigma)</code>
is given as
<code class="reqn">\frac{\sqrt{2}}{\sigma}\frac{\kappa}{1 + \kappa^2}
       exp(- \frac{\sqrt{2}\kappa}{\sigma} |x - \theta|)</code>
if <code class="reqn">x \ge \theta</code>, and
<code class="reqn">\frac{\sqrt{2}}{\sigma}\frac{\kappa}{1 + \kappa^2}
       exp(- \frac{\sqrt{2}}{\sigma\kappa} |x - \theta|)</code>
if <code class="reqn">x &lt; \theta</code>.
</p>
<p>The parameter domains of ASL and ASL* are
<code class="reqn">\theta \in R</code>,
<code class="reqn">\sigma &gt; 0</code>,
<code class="reqn">\kappa &gt; 0</code>, and
<code class="reqn">\mu \in R</code>.
The relation of <code class="reqn">\mu</code> and <code class="reqn">\kappa</code> are
<code class="reqn">\kappa = \frac{\sqrt{2\sigma^2 + \mu^2}-\mu}{\sqrt{2\sigma}}</code>
or
<code class="reqn">\mu = \frac{\sigma}{\sqrt{2}} (\frac{1}{\kappa} - \kappa)</code>.
</p>


<h3>Value</h3>

<p>&ldquo;dasl&rdquo; and &ldquo;dasla&rdquo; give the densities,
&ldquo;pasl&rdquo; and &ldquo;pasla&rdquo; give the distribution functions,
&ldquo;qasl&rdquo; and &ldquo;qasla&rdquo; give the quantile functions, and
&ldquo;rasl&rdquo; and &ldquo;rasls&rdquo; give the random numbers.
</p>
<p><code>asl.optim</code> returns the MLE of data <code>x</code> including
<code>theta</code>, <code>mu</code>, <code>kappa</code>, and <code>sigma</code>.
</p>


<h3>Author(s)</h3>

<p>Wei-Chen Chen <a href="mailto:wccsnow@gmail.com">wccsnow@gmail.com</a>.
</p>


<h3>References</h3>

<p>Kotz S, Kozubowski TJ, Podgorski K. (2001) &ldquo;The Laplace distribution
and generalizations: a revisit with applications to
communications, economics, engineering, and finance.&rdquo;
Boston: Birkhauser.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
suppressMessages(library(cubfits, quietly = TRUE))
set.seed(1234)

dasl(-2:2)
dasla(-2:2)
pasl(-2:2)
pasla(-2:2)
qasl(seq(0, 1, length = 5))
qasla(seq(0, 1, length = 5))

dasl(-2:2, log = TRUE)
dasla(-2:2, log = TRUE)
pasl(-2:2, log.p = TRUE)
pasla(-2:2, log.p = TRUE)
qasl(log(seq(0, 1, length = 5)), log.p = TRUE)
qasla(log(seq(0, 1, length = 5)), log.p = TRUE)

set.seed(123)
rasl(5)
rasla(5)

asl.optim(rasl(5000))

## End(Not run)
</code></pre>

<hr>
<h2 id='Cedric+20Convergence+20Utilities'>Cedric Convergence Utilities</h2><span id='topic+cubmultichain'></span><span id='topic+cubsinglechain'></span><span id='topic+isConverged'></span>

<h3>Description</h3>

<p>This utility function provides convergence related functions by Cedric.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  cubmultichain(cubmethod, reset.qr, seeds=NULL,
                teston=c("phi", "sphi"), swap=0, swapAt=0.05, monitor=NULL, 
                min=0, max=160000, nchains=2, conv.thin=10,
                eps=0.1, ncores=2, ...)
                          
  cubsinglechain(cubmethod, frac1=0.1, frac2=0.5, reset.qr,
                 seed=NULL, teston=c("phi", "sphi"), monitor=NULL, 
                 min=0, max=160000, conv.thin=10, eps=1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Cedric+2B20Convergence+2B20Utilities_+3A_cubmethod">cubmethod</code></td>
<td>
<p>String to choose method. Options are &quot;cubfits&quot;, &quot;cubappr&quot;, &quot;cubpred&quot;</p>
</td></tr>
<tr><td><code id="Cedric+2B20Convergence+2B20Utilities_+3A_reset.qr">reset.qr</code></td>
<td>
<p>recalculate QR decomposition matrix of covariance matrix until reset.qr samples are reached</p>
</td></tr>
<tr><td><code id="Cedric+2B20Convergence+2B20Utilities_+3A_swap">swap</code></td>
<td>
<p>proportion of b matrix parameters to be swaped between convergence checks</p>
</td></tr>
<tr><td><code id="Cedric+2B20Convergence+2B20Utilities_+3A_swapat">swapAt</code></td>
<td>
<p>difference (L1-norm) between two consequtive convergence test leading to a swap in the b matrix</p>
</td></tr>
<tr><td><code id="Cedric+2B20Convergence+2B20Utilities_+3A_seeds">seeds</code></td>
<td>
<p>Vector of seed for random number generation</p>
</td></tr>
<tr><td><code id="Cedric+2B20Convergence+2B20Utilities_+3A_seed">seed</code></td>
<td>
<p>Seed for random number generation</p>
</td></tr>
<tr><td><code id="Cedric+2B20Convergence+2B20Utilities_+3A_teston">teston</code></td>
<td>
<p>Select data to test convergence on</p>
</td></tr>
<tr><td><code id="Cedric+2B20Convergence+2B20Utilities_+3A_monitor">monitor</code></td>
<td>
<p>A function to monitor the progress of the MCMC. The fucntions expects the result object and for cubmultichain an index i. 
(cubmultichain call: monitor(x,i), cubsinglechain call: monitor(x))</p>
</td></tr>
<tr><td><code id="Cedric+2B20Convergence+2B20Utilities_+3A_min">min</code></td>
<td>
<p>Minimum samples to be obtained. eps is ignored until number of samples reaches min</p>
</td></tr>
<tr><td><code id="Cedric+2B20Convergence+2B20Utilities_+3A_max">max</code></td>
<td>
<p>Maximum samples to be obtained. eps is ignored after max samples is obtained</p>
</td></tr>
<tr><td><code id="Cedric+2B20Convergence+2B20Utilities_+3A_eps">eps</code></td>
<td>
<p>Convergence criterium</p>
</td></tr>
<tr><td><code id="Cedric+2B20Convergence+2B20Utilities_+3A_conv.thin">conv.thin</code></td>
<td>
<p>thinning of samples before performing convergence test</p>
</td></tr>
<tr><td><code id="Cedric+2B20Convergence+2B20Utilities_+3A_nchains">nchains</code></td>
<td>
<p>number of chains to run in parallel</p>
</td></tr>
<tr><td><code id="Cedric+2B20Convergence+2B20Utilities_+3A_ncores">ncores</code></td>
<td>
<p>number of cores to use for parallel execution of chains</p>
</td></tr>
<tr><td><code id="Cedric+2B20Convergence+2B20Utilities_+3A_frac1">frac1</code></td>
<td>
<p>fraction of samples at the beginning of set for Geweke test</p>
</td></tr>
<tr><td><code id="Cedric+2B20Convergence+2B20Utilities_+3A_frac2">frac2</code></td>
<td>
<p>fraction of samples at the end of set for Geweke test</p>
</td></tr>
<tr><td><code id="Cedric+2B20Convergence+2B20Utilities_+3A_...">...</code></td>
<td>
<p>named arguments for functions &quot;cubfits&quot;, &quot;cubappr&quot; or &quot;cubpred&quot;</p>
</td></tr>
</table>


<h3>Details</h3>

<p>under development
</p>


<h3>Value</h3>

<p>under development
</p>


<h3>Author(s)</h3>

<p>Cedric Landerer <a href="mailto:cedric.landerer@gmail.com">cedric.landerer@gmail.com</a>.
</p>


<h3>References</h3>

<p><a href="https://github.com/clandere/cubfits/">https://github.com/clandere/cubfits/</a>
</p>


<h3>See Also</h3>

<p>cubfits, cubappr, cubpred
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
suppressMessages(library(cubfits, quietly = TRUE))


## End(Not run)
</code></pre>

<hr>
<h2 id='Cedric+20Internal+20Functions'>All Cedric Internal Functions</h2><span id='topic+plotBMatrixPosterior'></span><span id='topic+plotCUB.NSE'></span><span id='topic+plotbin.NSE'></span><span id='topic+prop.model.nse'></span>

<h3>Description</h3>

<p>All Cedric internal functions</p>


<h3>Author(s)</h3>

<p>Cedric Landerer <a href="mailto:cedric.landerer@gmail.com">cedric.landerer@gmail.com</a>.
</p>


<h3>References</h3>

<p><a href="https://github.com/clandere/cubfits/">https://github.com/clandere/cubfits/</a>
</p>

<hr>
<h2 id='Cedric+20IO+20Utilities'>Cedric IO Utilities</h2><span id='topic+readGenome'></span><span id='topic+normalizeDataSet'></span>

<h3>Description</h3>

<p>This utility function provides basic IO by Cedric.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  readGenome(fn.genome, ex.sh.aa = 0, rm.first.aa = 0)
  
  normalizeDataSet(data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Cedric+2B20IO+2B20Utilities_+3A_fn.genome">fn.genome</code></td>
<td>
<p>Fasta file with sequences</p>
</td></tr>
<tr><td><code id="Cedric+2B20IO+2B20Utilities_+3A_ex.sh.aa">ex.sh.aa</code></td>
<td>
<p>Ignore sequences with a length less than ex.sh.aa. (After removal of the first rm.first.aa amino acids)</p>
</td></tr>
<tr><td><code id="Cedric+2B20IO+2B20Utilities_+3A_rm.first.aa">rm.first.aa</code></td>
<td>
<p>Remove the first rm.first.aa amino acids (after start codon)</p>
</td></tr>
<tr><td><code id="Cedric+2B20IO+2B20Utilities_+3A_data">data</code></td>
<td>
<p>Vector to be normalized. Means will be set to 1</p>
</td></tr>
</table>


<h3>Details</h3>

<p>under development
</p>


<h3>Value</h3>

<p>under development
</p>


<h3>Author(s)</h3>

<p>Cedric Landerer <a href="mailto:cedric.landerer@gmail.com">cedric.landerer@gmail.com</a>.
</p>


<h3>References</h3>

<p><a href="https://github.com/clandere/cubfits/">https://github.com/clandere/cubfits/</a>
</p>


<h3>See Also</h3>

<p>under development
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  ## Not run: 
    library(cubfits)
    seq.string &lt;- readGenome("my_genome.fasta", 150, 10)
  
## End(Not run)
</code></pre>

<hr>
<h2 id='Cedric+20Plot+20Utilities'>Cedric Plot Utilities</h2><span id='topic+plotCUB'></span><span id='topic+plotTraces'></span><span id='topic+plotExpectedPhiTrace'></span><span id='topic+plotPTraces'></span>

<h3>Description</h3>

<p>This utility function provides basic plots by Cedric.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  plotPTraces(pMat, ...)
  
  plotExpectedPhiTrace(phiMat, ...)
  
  plotCUB(reu13.df.obs, bMat = NULL, bVec = NULL, phi.bin,
          n.use.samples = 2000, main = "CUB", model.label = c("True Model"),
          model.lty = 1, weightedCenters = TRUE)

  plotTraces(bMat, names.aa, param = c("logmu", "deltaeta", "deltat"),
             main = "AA parameter trace")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Cedric+2B20Plot+2B20Utilities_+3A_reu13.df.obs">reu13.df.obs</code></td>
<td>
<p>under development</p>
</td></tr>
<tr><td><code id="Cedric+2B20Plot+2B20Utilities_+3A_bvec">bVec</code></td>
<td>
<p>a parameter vector</p>
</td></tr>
<tr><td><code id="Cedric+2B20Plot+2B20Utilities_+3A_phi.bin">phi.bin</code></td>
<td>
<p>phi values to bin for comparison</p>
</td></tr>
<tr><td><code id="Cedric+2B20Plot+2B20Utilities_+3A_n.use.samples">n.use.samples</code></td>
<td>
<p>under development</p>
</td></tr>
<tr><td><code id="Cedric+2B20Plot+2B20Utilities_+3A_main">main</code></td>
<td>
<p>Main name for plotTraces</p>
</td></tr>
<tr><td><code id="Cedric+2B20Plot+2B20Utilities_+3A_model.label">model.label</code></td>
<td>
<p>Name of model</p>
</td></tr>
<tr><td><code id="Cedric+2B20Plot+2B20Utilities_+3A_model.lty">model.lty</code></td>
<td>
<p>line type for model</p>
</td></tr>
<tr><td><code id="Cedric+2B20Plot+2B20Utilities_+3A_weightedcenters">weightedCenters</code></td>
<td>
<p>if centers are weighted.</p>
</td></tr>
<tr><td><code id="Cedric+2B20Plot+2B20Utilities_+3A_names.aa">names.aa</code></td>
<td>
<p>List of amino acids used for estimation</p>
</td></tr>
<tr><td><code id="Cedric+2B20Plot+2B20Utilities_+3A_param">param</code></td>
<td>
<p>select to plot parameter trace for either log(mu) values or
delta t</p>
</td></tr>
<tr><td><code id="Cedric+2B20Plot+2B20Utilities_+3A_phimat">phiMat</code></td>
<td>
<p>phi matrix from the output of &quot;cubmultichain&quot;,
&quot;cubsinglechain&quot;, &quot;cubfits&quot;, &quot;cubappr&quot;, or &quot;cubpred&quot;</p>
</td></tr>
<tr><td><code id="Cedric+2B20Plot+2B20Utilities_+3A_bmat">bMat</code></td>
<td>
<p>b matrix from the output of &quot;cubmultichain&quot;, &quot;cubsinglechain&quot;,
&quot;cubfits&quot;, &quot;cubappr&quot;, or &quot;cubpred&quot;</p>
</td></tr>
<tr><td><code id="Cedric+2B20Plot+2B20Utilities_+3A_pmat">pMat</code></td>
<td>
<p>p matrix from the output of &quot;cubmultichain&quot;, &quot;cubsinglechain&quot;,
&quot;cubfits&quot;, &quot;cubappr&quot;, or &quot;cubpred&quot;</p>
</td></tr>
<tr><td><code id="Cedric+2B20Plot+2B20Utilities_+3A_...">...</code></td>
<td>
<p>other ploting options</p>
</td></tr>
</table>


<h3>Details</h3>

<p>under development
</p>


<h3>Value</h3>

<p>under development
</p>


<h3>Author(s)</h3>

<p>Cedric Landerer <a href="mailto:cedric.landerer@gmail.com">cedric.landerer@gmail.com</a>.
</p>


<h3>References</h3>

<p><a href="https://github.com/clandere/cubfits/">https://github.com/clandere/cubfits/</a>
</p>


<h3>See Also</h3>

<p>plot
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
suppressMessages(library(cubfits, quietly = TRUE))


## End(Not run)
</code></pre>

<hr>
<h2 id='Codon+20Adaptation+20Index'>Function for Codon Adaptation Index (CAI)</h2><span id='topic+calc_cai_values'></span>

<h3>Description</h3>

<p>Calculate the Codon Adaptation Index (CAI) for each gene.
Used as a substitute for expression in cases of without expression
measurements.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  calc_cai_values(y, y.list, w = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Codon+2B20Adaptation+2B20Index_+3A_y">y</code></td>
<td>
<p>an object of format <code><a href="#topic+y">y</a></code>.</p>
</td></tr>
<tr><td><code id="Codon+2B20Adaptation+2B20Index_+3A_y.list">y.list</code></td>
<td>
<p>an object of format <code><a href="#topic+y.list">y.list</a></code>.</p>
</td></tr>
<tr><td><code id="Codon+2B20Adaptation+2B20Index_+3A_w">w</code></td>
<td>
<p>a specified relative frequency of synonymous codons.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function computes CAI for each gene. Typically, this method
is completely based on entropy and information theory to estimate
expression values of sequences according to their codon information.
</p>
<p>If the input <code>w</code> is <code>NULL</code>, then empirical values are computed.
</p>


<h3>Value</h3>

<p>A list with two named elements <code>CAI</code> and <code>w</code> are returned
where <code>CAI</code> are CAI of input sequences (<code>y</code> and <code>y.list</code>)
and <code>w</code> are the relative frequencey used to computed those CAI's.
</p>


<h3>Author(s)</h3>

<p>Wei-Chen Chen <a href="mailto:wccsnow@gmail.com">wccsnow@gmail.com</a>.
</p>


<h3>References</h3>

<p>Sharp P.M. and Li W.-H.
&ldquo;The codon Adaptation Index &ndash; a measure of directional synonymous codon
usage bias, and its potential applications&rdquo;
Nucleic Acids Res. 15 (3): 1281-1295, 1987.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+calc_scuo_values">calc_scuo_values</a>()</code>,
<code><a href="#topic+calc_scu_values">calc_scu_values</a>()</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
rm(list = ls())
library(cubfits, quietly = TRUE)

y &lt;- ex.train$y
y.list &lt;- convert.y.to.list(y)
CAI &lt;- calc_cai_values(y, y.list)$CAI
plot(CAI, log10(ex.train$phi.Obs), main = "Expression vs CAI",
     xlab = "CAI", ylab = "Expression (log10)")

### Verify with the seqinr example.
library(seqinr, quietly = TRUE)
inputdatfile &lt;- system.file("sequences/input.dat", package = "seqinr")
input &lt;- read.fasta(file = inputdatfile, forceDNAtolower = FALSE)
names(input)[65] &lt;- paste(names(input)[65], ".1", sep = "") # name duplicated.
input &lt;- input[order(names(input))]

### Convert to cubfits format.
seq.string &lt;- convert.seq.data.to.string(input)
new.y &lt;- gen.y(seq.string)
new.y.list &lt;- convert.y.to.list(new.y)
ret &lt;- calc_cai_values(new.y, new.y.list)

### Rebuild w.
w &lt;- rep(1, 64)
names(w) &lt;- codon.low2up(rownames(caitab))
for(i in 1:64){
  id &lt;- which(names(ret$w) == names(w)[i])
  if(length(id) == 1){
    w[i] &lt;- ret$w[id]
  }
}
CAI.res &lt;- sapply(input, seqinr::cai, w = w)

### Plot.
plot(CAI.res, ret$CAI,
     main = "Comparison of seqinR and cubfits results",
     xlab = "CAI from seqinR", ylab = "CAI from cubfits", las = 1)
abline(c(0, 1))

## End(Not run)
</code></pre>

<hr>
<h2 id='Controls'>Default Controlling Options</h2><span id='topic+.cubfitsEnv'></span><span id='topic+.CF.CT'></span><span id='topic+.CF.CONF'></span><span id='topic+.CF.DP'></span><span id='topic+.CF.GV'></span><span id='topic+.CF.OP'></span><span id='topic+.CF.AC'></span><span id='topic+.CF.PT'></span><span id='topic+.CF.PARAM'></span><span id='topic+.CO.CT'></span>

<h3>Description</h3>

<p>Default controls of <span class="pkg">cubfits</span> include for models, optimizations, MCMC,
plotting, global variables, etc.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  .cubfitsEnv
  .CF.CT
  .CF.CONF
  .CF.GV
  .CF.DP
  .CF.OP
  .CF.AC
  .CF.PT
  .CF.PARAM
  .CO.CT
</code></pre>


<h3>Format</h3>

<p>All are in lists and contain several controlling options.
</p>


<h3>Details</h3>

<p>See <code><a href="#topic+init.function">init.function</a>()</code> for use cases of these objects.
</p>

<ul>
<li>
<p><code>.cubfitEnv</code> is a default environment to dynamically save functions
and objects.
</p>
</li>
<li>
<p><code>.CF.CT</code> is main controls of models. It currently includes
</p>

<table>
<tr>
 <td style="text-align: left;">
      <code>model</code>     </td><td style="text-align: left;"> main models </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code>type.p</code>    </td><td style="text-align: left;"> proposal for hyper-parameters </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code>type.Phi</code>  </td><td style="text-align: left;"> proposal for Phi </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code>model.Phi</code> </td><td style="text-align: left;"> prior of Phi </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code>init.Phi</code>  </td><td style="text-align: left;"> initial methods for Phi </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code>init.fit</code>  </td><td style="text-align: left;"> how is coefficient proposed </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code>parallel</code>  </td><td style="text-align: left;"> parallel functions </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code>adaptive</code>  </td><td style="text-align: left;"> method for adaptive MCMC
    </td>
</tr>

</table>

</li>
<li>
<p><code>.CF.CONF</code> controls the initial and draw scaling. 
It currently includes
</p>

<table>
<tr>
 <td style="text-align: left;">
      <code>scale.phi.Obs</code>           </td><td style="text-align: left;"> if phi were scaled to mean 1 </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code>init.b.Scale</code>            </td><td style="text-align: left;"> initial b scale </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code>init.phi.Scale</code>          </td><td style="text-align: left;"> initial phi scale </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code>p.nclass</code>                </td><td style="text-align: left;"> number of classes if mixture phi </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code>b.DrawScale</code>             </td><td style="text-align: left;"> drawing scale for b if random walk </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code>p.DrawScale</code>             </td><td style="text-align: left;"> drawing scale for p if random walk </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code>phi.DrawScale</code>           </td><td style="text-align: left;"> random walk scale for phi </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code>phi.pred.DrawScale</code>      </td><td style="text-align: left;"> random walk scale for phi.pred </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code>sigma.Phi.DrawScale</code>     </td><td style="text-align: left;"> random walk scale for sigma.Phi </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code>bias.Phi.DrawScale</code>      </td><td style="text-align: left;"> random walk scale for bias.Phi </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code>estimate.bias.Phi</code>       </td><td style="text-align: left;"> if estimate bias of phi during MCMC </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code>compute.logL</code>            </td><td style="text-align: left;"> if compute logL in each iteration
    </td>
</tr>

</table>

</li>
<li>
<p><code>.CF.GV</code> contains global variables for amino acids and codons.
It currently includes
</p>

<table>
<tr>
 <td style="text-align: left;">
      <code>amino.acid</code>             </td><td style="text-align: left;"> amino acids </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code>amino.acid.3</code>           </td><td style="text-align: left;"> amino acids </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code>synonymous.codon</code>       </td><td style="text-align: left;"> synonymous codons of amino acids </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code>amino.acid.split</code>       </td><td style="text-align: left;"> amino acid 'S' is split </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code>amino.acid.split.3</code>     </td><td style="text-align: left;"> amino acid 'S' is split </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code>synonymous.codon.split</code> </td><td style="text-align: left;"> synonymous codons of split amino acid
    </td>
</tr>

</table>

</li>
<li>
<p><code>.CF.OP</code> controls optimizations. It currently includes
</p>

<table>
<tr>
 <td style="text-align: left;">
      <code>optim.method</code>    </td><td style="text-align: left;"> method for <code>optim</code>() </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code>stable.min.exp</code>  </td><td style="text-align: left;"> minimum exponent </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code>stable.max.exp</code>  </td><td style="text-align: left;"> maximum exponent </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code>E.Phi</code>           </td><td style="text-align: left;"> expected Phi </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code>lower.optim</code>     </td><td style="text-align: left;"> lower of derivative of logL(x) </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code>upper.optim</code>     </td><td style="text-align: left;"> upper of derivative of logL(x) </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code>lower.integrate</code> </td><td style="text-align: left;"> lower of integration of L(x) </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code>upper.integrate</code> </td><td style="text-align: left;"> upper of integration of L(x)
    </td>
</tr>

</table>

</li>
<li>
<p><code>.CF.DP</code> is for dumping MCMC iterations. It currently includes
</p>

<table>
<tr>
 <td style="text-align: left;">
      <code>dump</code>             </td><td style="text-align: left;"> if dumping within MCMC </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code>iter</code>             </td><td style="text-align: left;"> iterations per dumping </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code>prefix.dump</code>      </td><td style="text-align: left;"> path and file names of dumping </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code>verbose</code>          </td><td style="text-align: left;"> if verbose </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code>iterThin</code>         </td><td style="text-align: left;"> iterations to thin chain </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code>report</code>           </td><td style="text-align: left;"> iterations to report </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code>report.proc</code>      </td><td style="text-align: left;"> iterations to report <code>proc.time</code>()
    </td>
</tr>

</table>

</li>
<li>
<p><code>.CF.AC</code> controls adaptive MCMC. It currently includes
</p>

<table>
<tr>
 <td style="text-align: left;">
      <code>renew.iter</code>          </td><td style="text-align: left;"> per renewing iterations </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code>target.accept.lower</code> </td><td style="text-align: left;"> target acceptant rate lower bound </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code>target.accept.upper</code> </td><td style="text-align: left;"> target acceptant rate upper bound </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code>scale.increase</code>      </td><td style="text-align: left;"> increase scale size </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code>scale.decrease</code>      </td><td style="text-align: left;"> decrease scale size </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code>sigma.lower</code>         </td><td style="text-align: left;"> lower bound of relative scale size </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code>sigma.upper</code>         </td><td style="text-align: left;"> upper bound of relative scale size
    </td>
</tr>

</table>

</li>
<li>
<p><code>.CF.PT</code> controls the plotting format. It currently includes
</p>

<table>
<tr>
 <td style="text-align: left;">
      <code>color</code> </td><td style="text-align: left;"> color for codons.
    </td>
</tr>

</table>

</li>
<li>
<p><code>.CF.PARAM</code> controls the parameters and hyperparameters of priors.
It currently includes
</p>

<table>
<tr>
 <td style="text-align: left;">
      <code>phi.meanlog</code>      </td><td style="text-align: left;"> mean of phi in loca scale </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code>phi.sdlog</code>        </td><td style="text-align: left;"> standard deviation of phi in loca scale
    </td>
</tr>

</table>

</li>
<li>
<p><code>.CO.CT</code> controls the constrained optimization function. It currently
includes
</p>

<table>
<tr>
 <td style="text-align: left;">
      <code>debug</code> </td><td style="text-align: left;"> message printing level of debugging.
    </td>
</tr>

</table>

</li></ul>



<h3>Author(s)</h3>

<p>Wei-Chen Chen <a href="mailto:wccsnow@gmail.com">wccsnow@gmail.com</a>.
</p>


<h3>References</h3>

<p><a href="https://github.com/snoweye/cubfits/">https://github.com/snoweye/cubfits/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+init.function">init.function</a>()</code>, <code><a href="#topic+cubfits">cubfits</a>()</code>,
<code><a href="#topic+cubpred">cubpred</a>()</code>, <code><a href="#topic+cubappr">cubappr</a>()</code>, and
<code><a href="#topic+mixnormerr.optim">mixnormerr.optim</a>()</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
suppressMessages(library(cubfits, quietly = TRUE))

.CF.CT
.CF.CONF
.CF.DP
.CF.GV
.CF.OP
.CF.AC
.CF.PT
.CF.PARAM
.CO.CT

ls(.cubfitsEnv)
init.function()
ls(.cubfitsEnv)

## End(Not run)
</code></pre>

<hr>
<h2 id='Coverting+20Utility'>Convert Data Frame to Other Formats</h2><span id='topic+convert.reu13.df.to.list'></span><span id='topic+convert.y.to.list'></span><span id='topic+convert.n.to.list'></span><span id='topic+convert.y.to.scuo'></span><span id='topic+convert.seq.data.to.string'></span><span id='topic+codon.low2up'></span><span id='topic+codon.up2low'></span><span id='topic+dna.low2up'></span><span id='topic+dna.up2low'></span><span id='topic+convert.b.to.bVec'></span><span id='topic+convert.bVec.to.b'></span><span id='topic+DataConverting'></span>

<h3>Description</h3>

<p>These utility functions convert data of format divided by amino acids into
list of format divided by ORFs, or convert data to other formats.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  convert.reu13.df.to.list(reu13.df)
  convert.y.to.list(y)
  convert.n.to.list(n)

  convert.y.to.scuo(y)
  convert.seq.data.to.string(seq.data)

  codon.low2up(x)
  codon.up2low(x)

  dna.low2up(x)
  dna.up2low(x)

  convert.b.to.bVec(b)
  convert.bVec.to.b(bVec, aa.names, model = .CF.CT$model[1])
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Coverting+2B20Utility_+3A_reu13.df">reu13.df</code></td>
<td>
<p>a list of <code><a href="#topic+reu13.df">reu13.df</a></code> data frames
divided by amino acids.</p>
</td></tr>
<tr><td><code id="Coverting+2B20Utility_+3A_y">y</code></td>
<td>
<p>a list of <code><a href="#topic+y">y</a></code> data frames divided by amino acids.</p>
</td></tr>
<tr><td><code id="Coverting+2B20Utility_+3A_n">n</code></td>
<td>
<p>a list of <code><a href="#topic+n">n</a></code> vectors divided by amino acids.</p>
</td></tr>
<tr><td><code id="Coverting+2B20Utility_+3A_seq.data">seq.data</code></td>
<td>
<p>a vector of <code><a href="#topic+seq.data">seq.data</a></code> format.</p>
</td></tr>
<tr><td><code id="Coverting+2B20Utility_+3A_x">x</code></td>
<td>
<p>a codon or dna string, such &quot;ACG&quot;, &quot;acg&quot;, or &quot;A&quot;, &quot;a&quot;.</p>
</td></tr>
<tr><td><code id="Coverting+2B20Utility_+3A_b">b</code></td>
<td>
<p>a <code><a href="#topic+b">b</a></code> object.</p>
</td></tr>
<tr><td><code id="Coverting+2B20Utility_+3A_bvec">bVec</code></td>
<td>
<p>a <code><a href="#topic+bVec">bVec</a></code> object.</p>
</td></tr>
<tr><td><code id="Coverting+2B20Utility_+3A_aa.names">aa.names</code></td>
<td>
<p>a vector contains amino acid names for analysis.</p>
</td></tr>
<tr><td><code id="Coverting+2B20Utility_+3A_model">model</code></td>
<td>
<p>model fitted.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>convert.reu13.df.to.list()</code>, <code>convert.y.to.list()</code>, and
<code>convert.n.to.list()</code>:
these utility functions take the inputs divided by amino acids
and return the outputs divided by ORFs.
</p>
<p><code>convert.y.scuo()</code> converts <code><a href="#topic+y">y</a></code> into <code><a href="#topic+scuo">scuo</a></code>
format.
</p>
<p><code>convert.seq.data.to.string()</code> converts <code><a href="#topic+seq.data">seq.data</a></code> into
<code><a href="#topic+seq.string">seq.string</a></code> format.
</p>
<p><code>codon.low2up()</code> and <code>codon.up2low()</code> convert codon strings
between lower or upper cases.
</p>
<p><code>convert.bVec.to.b()</code> and <code>convert.b.to.bVec()</code> convert
objects <code><a href="#topic+b">b</a></code> and <code><a href="#topic+bVec">bVec</a></code>.
</p>


<h3>Value</h3>

<p>All functions return the corresponding formats.
</p>


<h3>Author(s)</h3>

<p>Wei-Chen Chen <a href="mailto:wccsnow@gmail.com">wccsnow@gmail.com</a>.
</p>


<h3>References</h3>

<p><a href="https://github.com/snoweye/cubfits/">https://github.com/snoweye/cubfits/</a>
</p>


<h3>See Also</h3>

<p><a href="#topic+AllDataFormats">AllDataFormats</a>,
<code><a href="#topic+rearrange.n">rearrange.n</a>()</code>,
<code><a href="#topic+rearrange.reu13.df">rearrange.reu13.df</a>()</code>,
<code><a href="#topic+rearrange.y">rearrange.y</a>()</code>, and
<code><a href="#topic+read.seq">read.seq</a>()</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
suppressMessages(library(cubfits, quietly = TRUE))

reu13.list &lt;- convert.reu13.df.to.list(ex.train$reu13.df)
y.list &lt;- convert.y.to.list(ex.train$y)
n.list &lt;- convert.n.to.list(ex.train$n)

scuo &lt;- convert.y.to.scuo(ex.train$y)

seq.data &lt;- read.seq(get.expath("seq_200.fasta"))
seq.string &lt;- convert.seq.data.to.string(seq.data)

codon.low2up("acg")
codon.up2low("ACG")

dna.low2up(c("a", "c", "g"))
dna.up2low(c("A", "C", "G"))

## End(Not run)
</code></pre>

<hr>
<h2 id='CUB+20Model+20Approximation'>Codon Usage Bias Approximation for ORFs without Expression</h2><span id='topic+cubappr'></span>

<h3>Description</h3>

<p>This function provides codon usage bias approximation with observed ORFs
but without any expressions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  cubappr(reu13.df.obs, phi.pred.Init, y, n,
          nIter = 1000,
          b.Init = NULL, init.b.Scale = .CF.CONF$init.b.Scale,
              b.DrawScale = .CF.CONF$b.DrawScale,
              b.RInit = NULL,
          p.Init = NULL, p.nclass = .CF.CONF$p.nclass,
              p.DrawScale = .CF.CONF$p.DrawScale,
          phi.pred.DrawScale = .CF.CONF$phi.pred.DrawScale,
          model = .CF.CT$model[1], model.Phi = .CF.CT$model.Phi[1],
          adaptive = .CF.CT$adaptive[1],
          verbose = .CF.DP$verbose,
          iterThin = .CF.DP$iterThin, report = .CF.DP$report)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CUB+2B20Model+2B20Approximation_+3A_reu13.df.obs">reu13.df.obs</code></td>
<td>
<p>a <code><a href="#topic+reu13.df">reu13.df</a></code> object, ORFs information.</p>
</td></tr>
<tr><td><code id="CUB+2B20Model+2B20Approximation_+3A_phi.pred.init">phi.pred.Init</code></td>
<td>
<p>a <code><a href="#topic+phi.Obs">phi.Obs</a></code> object, temporarily initial of expression
without measurement errors.</p>
</td></tr>
<tr><td><code id="CUB+2B20Model+2B20Approximation_+3A_y">y</code></td>
<td>
<p>a <code><a href="#topic+y">y</a></code> object, codon counts.</p>
</td></tr>
<tr><td><code id="CUB+2B20Model+2B20Approximation_+3A_n">n</code></td>
<td>
<p>a <code><a href="#topic+n">n</a></code> object, total codon counts.</p>
</td></tr>
<tr><td><code id="CUB+2B20Model+2B20Approximation_+3A_niter">nIter</code></td>
<td>
<p>number of iterations after burn-in iterations.</p>
</td></tr>
<tr><td><code id="CUB+2B20Model+2B20Approximation_+3A_b.init">b.Init</code></td>
<td>
<p>initial values for parameters <code><a href="#topic+b">b</a></code>.</p>
</td></tr>
<tr><td><code id="CUB+2B20Model+2B20Approximation_+3A_init.b.scale">init.b.Scale</code></td>
<td>
<p>for initial <code><a href="#topic+b">b</a></code> if <code>b.Init = NULL</code>.</p>
</td></tr>
<tr><td><code id="CUB+2B20Model+2B20Approximation_+3A_b.drawscale">b.DrawScale</code></td>
<td>
<p>scaling factor for adaptive MCMC with random walks
when drawing new <code><a href="#topic+b">b</a></code>.</p>
</td></tr>
<tr><td><code id="CUB+2B20Model+2B20Approximation_+3A_b.rinit">b.RInit</code></td>
<td>
<p>initial values (in a list) for <code>R</code> matrices of
parameters <code><a href="#topic+b">b</a></code> yielding from QR decomposition
of <code>vglm()</code> for the variance-covariance matrix of
<code><a href="#topic+b">b</a></code>.</p>
</td></tr>
<tr><td><code id="CUB+2B20Model+2B20Approximation_+3A_p.init">p.Init</code></td>
<td>
<p>initial values for hyper-parameters.</p>
</td></tr>
<tr><td><code id="CUB+2B20Model+2B20Approximation_+3A_p.nclass">p.nclass</code></td>
<td>
<p>number of components for <code>model.Phi = "logmixture"</code>.</p>
</td></tr>
<tr><td><code id="CUB+2B20Model+2B20Approximation_+3A_p.drawscale">p.DrawScale</code></td>
<td>
<p>scaling factor for adaptive MCMC with random walks
when drawing new <code>sigma.Phi</code>.</p>
</td></tr>
<tr><td><code id="CUB+2B20Model+2B20Approximation_+3A_phi.pred.drawscale">phi.pred.DrawScale</code></td>
<td>
<p>scaling factor for adaptive MCMC with random walks
when drawing new Phi of predicted set.</p>
</td></tr>
<tr><td><code id="CUB+2B20Model+2B20Approximation_+3A_model">model</code></td>
<td>
<p>model to be fitted, currently &quot;roc&quot; only.</p>
</td></tr>
<tr><td><code id="CUB+2B20Model+2B20Approximation_+3A_model.phi">model.Phi</code></td>
<td>
<p>prior model for Phi, currently &quot;lognormal&quot;.</p>
</td></tr>
<tr><td><code id="CUB+2B20Model+2B20Approximation_+3A_adaptive">adaptive</code></td>
<td>
<p>adaptive method of MCMC for proposing new <code><a href="#topic+b">b</a></code> and
Phi.</p>
</td></tr>
<tr><td><code id="CUB+2B20Model+2B20Approximation_+3A_verbose">verbose</code></td>
<td>
<p>print iteration messages.</p>
</td></tr>
<tr><td><code id="CUB+2B20Model+2B20Approximation_+3A_iterthin">iterThin</code></td>
<td>
<p>thinning iterations.</p>
</td></tr>
<tr><td><code id="CUB+2B20Model+2B20Approximation_+3A_report">report</code></td>
<td>
<p>number of iterations to report more information.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Total number of MCMC iterations is <code>nIter + 1</code>, but the
outputs may be thinned to <code>nIter / iterThin + 1</code>
iterations.
</p>
<p>Temporary result dumping may be controlled by <code><a href="#topic+.CF.DP">.CF.DP</a></code>.
</p>


<h3>Value</h3>

<p>A list contains three big lists of MCMC traces including:
<code>b.Mat</code> for mutation and selection coefficients of <code><a href="#topic+b">b</a></code>,
<code>p.Mat</code> for hyper-parameters, and
<code>phi.Mat</code> for expected expression values Phi.
All lists are of length <code>nIter / iterThin + 1</code> and
each element contains the output of each iteration.
</p>
<p>All lists also can be binded as trace matrices, such as via
<code>do.call("rbind", b.Mat)</code> yielding a matrix of dimension number of
iterations by number of parameters. Then, those traces can be analyzed
further via other MCMC packages such as <span class="pkg">coda</span>.
</p>


<h3>Note</h3>

<p>Note that <code>phi.pred.Init</code> need to be normalized to mean 1.
</p>
<p><code>p.DrawScale</code> may cause scaling prior if adaptive MCMC is used, and
it can result in non-exits of equilibrium distribution.
</p>


<h3>Author(s)</h3>

<p>Wei-Chen Chen <a href="mailto:wccsnow@gmail.com">wccsnow@gmail.com</a>.
</p>


<h3>References</h3>

<p><a href="https://github.com/snoweye/cubfits/">https://github.com/snoweye/cubfits/</a>
</p>


<h3>See Also</h3>

<p><a href="#topic+DataIO">DataIO</a>, <a href="#topic+DataConverting">DataConverting</a>,
<code><a href="#topic+cubfits">cubfits</a>()</code> and <code><a href="#topic+cubpred">cubpred</a>()</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
suppressMessages(library(cubfits, quietly = TRUE))

demo(roc.appr, 'cubfits', ask = F, echo = F)

## End(Not run)
</code></pre>

<hr>
<h2 id='CUB+20Model+20Fits'>Codon Usage Bias Fits for Observed ORFs and Expression</h2><span id='topic+cubfits'></span>

<h3>Description</h3>

<p>This function provides codon usage bias fits with observed ORFs and
expressions which possibly contains measurement errors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  cubfits(reu13.df.obs, phi.Obs, y, n,
          nIter = 1000,
          b.Init = NULL, init.b.Scale = .CF.CONF$init.b.Scale,
              b.DrawScale = .CF.CONF$b.DrawScale,
              b.RInit = NULL,
          p.Init = NULL, p.nclass = .CF.CONF$p.nclass,
              p.DrawScale = .CF.CONF$p.DrawScale,
          phi.Init = NULL, init.phi.Scale = .CF.CONF$init.phi.Scale,
              phi.DrawScale = .CF.CONF$phi.DrawScale,
          model = .CF.CT$model[1], model.Phi = .CF.CT$model.Phi[1],
          adaptive = .CF.CT$adaptive[1],
          verbose = .CF.DP$verbose,
          iterThin = .CF.DP$iterThin, report = .CF.DP$report)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CUB+2B20Model+2B20Fits_+3A_reu13.df.obs">reu13.df.obs</code></td>
<td>
<p>a <code><a href="#topic+reu13.df">reu13.df</a></code> object, ORFs information.</p>
</td></tr>
<tr><td><code id="CUB+2B20Model+2B20Fits_+3A_phi.obs">phi.Obs</code></td>
<td>
<p>a <code><a href="#topic+phi.Obs">phi.Obs</a></code> object, expression with measurement errors.</p>
</td></tr>
<tr><td><code id="CUB+2B20Model+2B20Fits_+3A_y">y</code></td>
<td>
<p>a <code><a href="#topic+y">y</a></code> object, codon counts.</p>
</td></tr>
<tr><td><code id="CUB+2B20Model+2B20Fits_+3A_n">n</code></td>
<td>
<p>a <code><a href="#topic+n">n</a></code> object, total codon counts.</p>
</td></tr>
<tr><td><code id="CUB+2B20Model+2B20Fits_+3A_niter">nIter</code></td>
<td>
<p>number of iterations after burn-in iterations.</p>
</td></tr>
<tr><td><code id="CUB+2B20Model+2B20Fits_+3A_b.init">b.Init</code></td>
<td>
<p>initial values for parameters <code><a href="#topic+b">b</a></code>.</p>
</td></tr>
<tr><td><code id="CUB+2B20Model+2B20Fits_+3A_init.b.scale">init.b.Scale</code></td>
<td>
<p>for initial <code><a href="#topic+b">b</a></code> if <code>b.Init = NULL</code>.</p>
</td></tr>
<tr><td><code id="CUB+2B20Model+2B20Fits_+3A_b.drawscale">b.DrawScale</code></td>
<td>
<p>scaling factor for adaptive MCMC with random walks
when drawing new <code><a href="#topic+b">b</a></code>.</p>
</td></tr>
<tr><td><code id="CUB+2B20Model+2B20Fits_+3A_b.rinit">b.RInit</code></td>
<td>
<p>initial values (in a list) for <code>R</code> matrices of
parameters <code><a href="#topic+b">b</a></code> yielding from QR decomposition
of <code>vglm()</code> for the variance-covariance matrix of
<code><a href="#topic+b">b</a></code>.</p>
</td></tr>
<tr><td><code id="CUB+2B20Model+2B20Fits_+3A_p.init">p.Init</code></td>
<td>
<p>initial values for hyper-parameters.</p>
</td></tr>
<tr><td><code id="CUB+2B20Model+2B20Fits_+3A_p.nclass">p.nclass</code></td>
<td>
<p>number of components for <code>model.Phi = "logmixture"</code>.</p>
</td></tr>
<tr><td><code id="CUB+2B20Model+2B20Fits_+3A_p.drawscale">p.DrawScale</code></td>
<td>
<p>scaling factor for adaptive MCMC with random walks
when drawing new <code>sigma.Phi</code>.</p>
</td></tr>
<tr><td><code id="CUB+2B20Model+2B20Fits_+3A_phi.init">phi.Init</code></td>
<td>
<p>initial values for Phi.</p>
</td></tr>
<tr><td><code id="CUB+2B20Model+2B20Fits_+3A_init.phi.scale">init.phi.Scale</code></td>
<td>
<p>for initial phi if <code>phi.Init = NULL</code>.</p>
</td></tr>
<tr><td><code id="CUB+2B20Model+2B20Fits_+3A_phi.drawscale">phi.DrawScale</code></td>
<td>
<p>scaling factor for adaptive MCMC with random walks
when drawing new Phi.</p>
</td></tr>
<tr><td><code id="CUB+2B20Model+2B20Fits_+3A_model">model</code></td>
<td>
<p>model to be fitted, currently &quot;roc&quot; only.</p>
</td></tr>
<tr><td><code id="CUB+2B20Model+2B20Fits_+3A_model.phi">model.Phi</code></td>
<td>
<p>prior model for Phi, currently &quot;lognormal&quot;.</p>
</td></tr>
<tr><td><code id="CUB+2B20Model+2B20Fits_+3A_adaptive">adaptive</code></td>
<td>
<p>adaptive method of MCMC for proposing new <code><a href="#topic+b">b</a></code> and
Phi.</p>
</td></tr>
<tr><td><code id="CUB+2B20Model+2B20Fits_+3A_verbose">verbose</code></td>
<td>
<p>print iteration messages.</p>
</td></tr>
<tr><td><code id="CUB+2B20Model+2B20Fits_+3A_iterthin">iterThin</code></td>
<td>
<p>thinning iterations.</p>
</td></tr>
<tr><td><code id="CUB+2B20Model+2B20Fits_+3A_report">report</code></td>
<td>
<p>number of iterations to report more information.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function correctly and carefully implements a combining version of
Shah and Gilchrist (2011) and Wallace et al. (2013).
</p>
<p>Total number of MCMC iterations is <code>nIter + 1</code>, but the
outputs may be thinned to <code>nIter / iterThin + 1</code>
iterations.
</p>
<p>Temporary result dumping may be controlled by <code><a href="#topic+.CF.DP">.CF.DP</a></code>.
</p>


<h3>Value</h3>

<p>A list contains three big lists of MCMC traces including:
<code>b.Mat</code> for mutation and selection coefficients of <code><a href="#topic+b">b</a></code>,
<code>p.Mat</code> for hyper-parameters, and
<code>phi.Mat</code> for expected expression values Phi.
All lists are of length <code>nIter / iterThin + 1</code> and
each element contains the output of each iteration.
</p>
<p>All lists also can be binded as trace matrices, such as via
<code>do.call("rbind", b.Mat)</code> yielding a matrix of dimension number of
iterations by number of parameters. Then, those traces can be analyzed
further via other MCMC packages such as <span class="pkg">coda</span>.
</p>


<h3>Note</h3>

<p>Note that <code>phi.Init</code> need to be normalized to mean 1.
</p>
<p><code>p.DrawScale</code> may cause scaling prior if adaptive MCMC is used, and
it can result in non-exits of equilibrium distribution.
</p>


<h3>Author(s)</h3>

<p>Wei-Chen Chen <a href="mailto:wccsnow@gmail.com">wccsnow@gmail.com</a>.
</p>


<h3>References</h3>

<p><a href="https://github.com/snoweye/cubfits/">https://github.com/snoweye/cubfits/</a>
</p>
<p>Shah P. and Gilchrist M.A.
&ldquo;Explaining complex codon usage patterns
with selection for translational efficiency, mutation bias, and genetic
drift&rdquo;
Proc Natl Acad Sci USA (2011) 108:10231&ndash;10236.
</p>
<p>Wallace E.W.J., Airoldi E.M., and Drummond D.A.
&ldquo;Estimating Selection on Synonymous Codon Usage from Noisy Experimental
Data&rdquo;
Mol Biol Evol (2013) 30(6):1438&ndash;1453.
</p>


<h3>See Also</h3>

<p><a href="#topic+DataIO">DataIO</a>, <a href="#topic+DataConverting">DataConverting</a>,
<code><a href="#topic+cubappr">cubappr</a>()</code> and <code><a href="#topic+cubpred">cubpred</a>()</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
suppressMessages(library(cubfits, quietly = TRUE))

demo(roc.train, 'cubfits', ask = F, echo = F)

## End(Not run)
</code></pre>

<hr>
<h2 id='CUB+20Model+20Prediction'>Codon Usage Bias Prediction for Observed ORFs</h2><span id='topic+cubpred'></span>

<h3>Description</h3>

<p>This function provides codon usage bias fits of training set
which has observed ORFs and expressions possibly containing
measurement errors, and provides predictions of testing set
which has other observed ORFs but without expression.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  cubpred(reu13.df.obs, phi.Obs, y, n,
          reu13.df.pred, y.pred, n.pred,
          nIter = 1000,
          b.Init = NULL, init.b.Scale = .CF.CONF$init.b.Scale,
              b.DrawScale = .CF.CONF$b.DrawScale,
              b.RInit = NULL,
          p.Init = NULL, p.nclass = .CF.CONF$p.nclass,
              p.DrawScale = .CF.CONF$p.DrawScale,
          phi.Init = NULL, init.phi.Scale = .CF.CONF$init.phi.Scale,
              phi.DrawScale = .CF.CONF$phi.DrawScale,
          phi.pred.Init = NULL,
              phi.pred.DrawScale = .CF.CONF$phi.pred.DrawScale,
          model = .CF.CT$model[1], model.Phi = .CF.CT$model.Phi[1],
          adaptive = .CF.CT$adaptive[1],
          verbose = .CF.DP$verbose,
          iterThin = .CF.DP$iterThin, report = .CF.DP$report)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CUB+2B20Model+2B20Prediction_+3A_reu13.df.obs">reu13.df.obs</code></td>
<td>
<p>a <code><a href="#topic+reu13.df">reu13.df</a></code> to be trained.</p>
</td></tr>
<tr><td><code id="CUB+2B20Model+2B20Prediction_+3A_phi.obs">phi.Obs</code></td>
<td>
<p>a <code><a href="#topic+phi.Obs">phi.Obs</a></code> to be trained.</p>
</td></tr>
<tr><td><code id="CUB+2B20Model+2B20Prediction_+3A_y">y</code></td>
<td>
<p>a <code><a href="#topic+y">y</a></code> to be trained.</p>
</td></tr>
<tr><td><code id="CUB+2B20Model+2B20Prediction_+3A_n">n</code></td>
<td>
<p>a <code><a href="#topic+n">n</a></code> to be trained.</p>
</td></tr>
<tr><td><code id="CUB+2B20Model+2B20Prediction_+3A_reu13.df.pred">reu13.df.pred</code></td>
<td>
<p>a <code><a href="#topic+reu13.df">reu13.df</a></code> to be predicted.</p>
</td></tr>
<tr><td><code id="CUB+2B20Model+2B20Prediction_+3A_y.pred">y.pred</code></td>
<td>
<p>a <code><a href="#topic+y">y</a></code> to be predicted.</p>
</td></tr>
<tr><td><code id="CUB+2B20Model+2B20Prediction_+3A_n.pred">n.pred</code></td>
<td>
<p>a <code><a href="#topic+n">n</a></code> to be predicted.</p>
</td></tr>
<tr><td><code id="CUB+2B20Model+2B20Prediction_+3A_niter">nIter</code></td>
<td>
<p>number of iterations after burn-in iterations.</p>
</td></tr>
<tr><td><code id="CUB+2B20Model+2B20Prediction_+3A_b.init">b.Init</code></td>
<td>
<p>initial values for parameters <code><a href="#topic+b">b</a></code>.</p>
</td></tr>
<tr><td><code id="CUB+2B20Model+2B20Prediction_+3A_init.b.scale">init.b.Scale</code></td>
<td>
<p>for initial <code><a href="#topic+b">b</a></code> if <code>b.Init = NULL</code>.</p>
</td></tr>
<tr><td><code id="CUB+2B20Model+2B20Prediction_+3A_b.drawscale">b.DrawScale</code></td>
<td>
<p>scaling factor for adaptive MCMC with random walks
when drawing new <code><a href="#topic+b">b</a></code>.</p>
</td></tr>
<tr><td><code id="CUB+2B20Model+2B20Prediction_+3A_b.rinit">b.RInit</code></td>
<td>
<p>initial values (in a list) for <code>R</code> matrices of
parameters <code><a href="#topic+b">b</a></code> yielding from QR decomposition
of <code>vglm()</code> for the variance-covariance matrix of
<code><a href="#topic+b">b</a></code>.</p>
</td></tr>
<tr><td><code id="CUB+2B20Model+2B20Prediction_+3A_p.init">p.Init</code></td>
<td>
<p>initial values for hyper-parameters.</p>
</td></tr>
<tr><td><code id="CUB+2B20Model+2B20Prediction_+3A_p.nclass">p.nclass</code></td>
<td>
<p>number of components for <code>model.Phi = "logmixture"</code>.</p>
</td></tr>
<tr><td><code id="CUB+2B20Model+2B20Prediction_+3A_p.drawscale">p.DrawScale</code></td>
<td>
<p>scaling factor for adaptive MCMC with random walks
when drawing new <code>sigma.Phi</code>.</p>
</td></tr>
<tr><td><code id="CUB+2B20Model+2B20Prediction_+3A_phi.init">phi.Init</code></td>
<td>
<p>initial values for Phi.</p>
</td></tr>
<tr><td><code id="CUB+2B20Model+2B20Prediction_+3A_init.phi.scale">init.phi.Scale</code></td>
<td>
<p>for initial phi if <code>phi.Init = NULL</code>.</p>
</td></tr>
<tr><td><code id="CUB+2B20Model+2B20Prediction_+3A_phi.drawscale">phi.DrawScale</code></td>
<td>
<p>scaling factor for adaptive MCMC with random walks
when drawing new Phi.</p>
</td></tr>
<tr><td><code id="CUB+2B20Model+2B20Prediction_+3A_phi.pred.init">phi.pred.Init</code></td>
<td>
<p>initial values for Phi of predicted set.</p>
</td></tr>
<tr><td><code id="CUB+2B20Model+2B20Prediction_+3A_phi.pred.drawscale">phi.pred.DrawScale</code></td>
<td>
<p>as <code>phi.DrawScale</code> but for predicted set.</p>
</td></tr>
<tr><td><code id="CUB+2B20Model+2B20Prediction_+3A_model">model</code></td>
<td>
<p>model to be fitted, currently &quot;roc&quot; only.</p>
</td></tr>
<tr><td><code id="CUB+2B20Model+2B20Prediction_+3A_model.phi">model.Phi</code></td>
<td>
<p>prior model for Phi, currently &quot;lognormal&quot;.</p>
</td></tr>
<tr><td><code id="CUB+2B20Model+2B20Prediction_+3A_adaptive">adaptive</code></td>
<td>
<p>adaptive method of MCMC for proposing new <code><a href="#topic+b">b</a></code>
and Phi.</p>
</td></tr>
<tr><td><code id="CUB+2B20Model+2B20Prediction_+3A_verbose">verbose</code></td>
<td>
<p>print iteration messages.</p>
</td></tr>
<tr><td><code id="CUB+2B20Model+2B20Prediction_+3A_iterthin">iterThin</code></td>
<td>
<p>thinning iterations.</p>
</td></tr>
<tr><td><code id="CUB+2B20Model+2B20Prediction_+3A_report">report</code></td>
<td>
<p>number of iterations to report more information.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function correctly and carefully implements an extension of
Shah and Gilchrist (2011) and Wallace et al. (2013).
</p>
<p>Total number of MCMC iterations is <code>nIter + 1</code>, but the
outputs may be thinned to <code>nIter / iterThin + 1</code>
iterations.
</p>
<p>Temporary result dumping may be controlled by <code><a href="#topic+.CF.DP">.CF.DP</a></code>.
</p>


<h3>Value</h3>

<p>A list contains four big lists of MCMC traces including:
<code>b.Mat</code> for mutation and selection coefficients of <code><a href="#topic+b">b</a></code>,
<code>p.Mat</code> for hyper-parameters,
<code>phi.Mat</code> for expected expression values Phi, and
<code>phi.pred.Mat</code> for predictive expression values Phi.
All lists have <code>nIter / iterThin + 1</code> elements,
and each element contains the output of each iteration.
</p>
<p>All lists also can be binded as trace matrices, such as via
<code>do.call("rbind", b.Mat)</code> yielding a matrix of dimension number of
iterations by number of parameters. Then, those traces can be analyzed
further via other MCMC packages such as <span class="pkg">coda</span>.
</p>


<h3>Note</h3>

<p>Note that <code>phi.Init</code> and <code>phi.pred.Init</code> need to be normalized
to mean 1.
</p>
<p><code>p.DrawScale</code> may cause scaling prior if adaptive MCMC is used, and
it can result in non-exits of equilibrium distribution.
</p>


<h3>Author(s)</h3>

<p>Wei-Chen Chen <a href="mailto:wccsnow@gmail.com">wccsnow@gmail.com</a>.
</p>


<h3>References</h3>

<p><a href="https://github.com/snoweye/cubfits/">https://github.com/snoweye/cubfits/</a>
</p>
<p>Shah P. and Gilchrist M.A.
&ldquo;Explaining complex codon usage patterns
with selection for translational efficiency, mutation bias, and genetic
drift&rdquo;
Proc Natl Acad Sci USA (2011) 108:10231&ndash;10236.
</p>


<h3>See Also</h3>

<p><a href="#topic+DataIO">DataIO</a>, <a href="#topic+DataConverting">DataConverting</a>,
<code><a href="#topic+cubfits">cubfits</a>()</code> and <code><a href="#topic+cubappr">cubappr</a>()</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
suppressMessages(library(cubfits, quietly = TRUE))

demo(roc.pred, 'cubfits', ask = F, echo = F)

## End(Not run)
</code></pre>

<hr>
<h2 id='cubfits-package'>Codon Bias Usage Fits</h2><span id='topic+cubfits-package'></span>

<h3>Description</h3>

<p>Estimating mutation and selection coefficients on synonymous
codon bias usage based on models of ribosome overhead cost (ROC).
Multinomial logistic regression and Markov Chain Monte Carlo are used to
estimate and predict protein production rates with/without the presence of
expressions and measurement errors.
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
  Package: </td><td style="text-align: left;"> cubfits</td>
</tr>
<tr>
 <td style="text-align: left;">
  Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
  License: </td><td style="text-align: left;"> Mozilla Public License 2.0</td>
</tr>
<tr>
 <td style="text-align: left;">
  LazyLoad: </td><td style="text-align: left;"> yes</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>The install command is simply as <br />
<br />
<code>&gt; R CMD INSTALL cubfits_*.tar.gz </code> <br />
<br />
from a command mode or <br />
<br />
<code>R&gt; install.packages("cubfits") </code> <br />
<br />
inside an R session.
</p>


<h3>Author(s)</h3>

<p>Wei-Chen Chen <a href="mailto:wccsnow@gmail.com">wccsnow@gmail.com</a>, Russell Zaretzki,
William Howell, Drew Schmidt, and Michael Gilchrist.
</p>


<h3>References</h3>

<p><a href="https://github.com/snoweye/cubfits/">https://github.com/snoweye/cubfits/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+init.function">init.function</a>()</code>, <code><a href="#topic+cubfits">cubfits</a>()</code>,
<code><a href="#topic+cubpred">cubpred</a>()</code>, and <code><a href="#topic+cubappr">cubappr</a>()</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
suppressMessages(library(cubfits, quietly = TRUE))

demo(roc.train, 'cubfits', ask = F, echo = F)
demo(roc.pred, 'cubfits', ask = F, echo = F)
demo(roc.appr, 'cubfits', ask = F, echo = F)

## End(Not run)
</code></pre>

<hr>
<h2 id='Data+20Formats'>Data Formats</h2><span id='topic+b'></span><span id='topic+bVec'></span><span id='topic+n'></span><span id='topic+n.list'></span><span id='topic+phi.df'></span><span id='topic+reu13.df'></span><span id='topic+reu13.list'></span><span id='topic+scuo'></span><span id='topic+seq.string'></span><span id='topic+seq.data'></span><span id='topic+phi.Obs'></span><span id='topic+y'></span><span id='topic+y.list'></span><span id='topic+AllDataFormats'></span>

<h3>Description</h3>

<p>Data formats used in <span class="pkg">cubfits</span>.
</p>


<h3>Format</h3>

<p>All are in simple formats as S3 default lists or data frames.
</p>


<h3>Details</h3>


<ul>
<li>
<p>Format <code>b</code>: <br />
A named list <code>A</code> contains amino acids.
Each element of the list <code>A[[i]]</code> is a list of elements
<code>coefficients</code> (coefficients of log(mu) and Delta.t),
<code>coef.mat</code> (matrix format of <code>coefficients</code>), and
<code>R</code> (covariance matrix of <code>coefficients</code>).
Note that <code>coefficients</code> and <code>R</code> are typically as in the output
of <code>vglm()</code> of <span class="pkg">VGAM</span> package.
Also, <code>coef.mat</code> and <code>R</code> may miss in some cases.
<br />
e.g. <code>A[[i]]$coef.mat</code> is the regression beta matrix of <code>i</code>-th
amino acid.
</p>
</li>
<li>
<p>Format <code>bVec</code>: <br />
A vector simply contains all coefficients of a <code>b</code> object <code>A</code>.
Note that this is probably only used inside MCMC or the output of
<code>vglm()</code> of <span class="pkg">VGAM</span> package.
<br />
e.g. <code>do.call("c", lapply(A, function(x) x$coefficients))</code>.
</p>
</li>
<li>
<p>Format <code>n</code>: <br />
A named list <code>A</code> contains amino acids.
Each element of the list <code>A[[i]]</code> is a vector containing total
codon counts.
<br />
e.g. <code>A[[i]][j]</code> is for <code>j</code>-th ORF of <code>i</code>-th amino acid
<code>names(A)[i]</code>.
</p>
</li>
<li>
<p>Format <code>n.list</code>: <br />
A named list <code>A</code> contains ORFs.
Each element of the list <code>A[[i]]</code> is a named list of amino acid
containing total count.
<br />
e.g. <code>A[[i]][[j]]</code> contains total count of
<code>j</code>-th amino acid in <code>i</code>-th ORF.
</p>
</li>
<li>
<p>Format <code>phi.df</code>: <br />
A data frame <code>A</code> contains two columns <code>ORF</code> and <code>phi.value</code>.
<br />
e.g. <code>A[i,]</code> is for <code>i</code>-th ORF.
</p>
</li>
<li>
<p>Format <code>reu13.df</code>: <br />
A named list <code>A</code> contains amino acids.
Each element is a data frame summarizing ORF and expression.
The data frame has four to five columns including
<code>ORF</code>, <code>phi</code> (expression), <code>Pos</code> (amino acid position),
<code>Codon</code> (synonymous codon), and
<code>Codon.id</code> (synonymous codon id, for computing only).
Note that <code>Codon.id</code> may miss in some cases.
<br />
e.g. <code>A[[i]][17,]</code> is the 17-th recode of <code>i</code>-th amino acid.
</p>
</li>
<li>
<p>Format <code>reu13.list</code>: <br />
A named list <code>A</code> contains ORFs.
Each element is a named list <code>A[[i]]</code> contains amino acids.
Each element of nested list <code>A[[i]][[j]]</code> is a position vector
of synonymous codon.
<br />
e.g. <code>A[[i]][[j]][k]</code> is the <code>k</code>-th synonymous codon position of
<code>j</code>-th amino acid in the <code>i</code>-th ORF.
</p>
</li>
<li>
<p>Format <code>scuo</code>: <br />
A data frame of 8 named columns includes
<code>AA</code> (amino acid), <code>ORF</code>, <code>C1</code>, ..., <code>C6</code>
where <code>C*</code>'s are for codon counts.
</p>
</li>
<li>
<p>Format <code>seq.string</code>: <br />
Default outputs of <code>read.fasta()</code> of <span class="pkg">seqinr</span> package.
A named list <code>A</code> contains ORFs.
Each element of the list is a long string of a ORF.
<br />
e.g. <code>A[[i]][1]</code> or <code>A[[i]]</code> is the sequence of
<code>i</code>-th ORF.
</p>
</li>
<li>
<p>Format <code>seq.data</code>: <br />
Converted from <code>seq.string</code> format.
A named list <code>A</code> contains ORFs.
Each element of the list <code>A[[i]]</code> is a string vector.
Each element of the vector is a codon string.
<br />
e.g. <code>A[[i]][j]</code> is <code>i</code>-th ORF and <code>j</code>-th codon.
</p>
</li>
<li>
<p>Format <code>phi.Obs</code>: <br />
A named vector <code>A</code> of observed expression values and possibly
with measurement errors.
<br />
e.g. <code>A[i]</code> is the observed phi value of <code>i</code>-th ORF.
</p>
</li>
<li>
<p>Format <code>y</code>: <br />
A named list <code>A</code> contains amino acids.
Each element of the list <code>A[[i]]</code> is a matrix
where ORFs are in row and synonymous codons are in column.
The element of the matrix contains codon counts.
<br />
e.g. <code>A[[i]][j, k]</code> is the count for <code>i</code>-th amino acid,
<code>j</code>-th ORF, and <code>k</code>-th synonymous codon.
</p>
</li>
<li>
<p>Format <code>y.list</code>: <br />
A named list <code>A</code> contains ORFs.
Each element of the list <code>A[[i]]</code> is a named list <code>A[[i]][[j]]</code>
contains amino acids.
The element of amino acids list is a codon count vector.
<br />
e.g. <code>A[[i]][[j]][k]</code> is the count for <code>i</code>-th ORF,
<code>j</code>-th amino acid, and <code>k</code>-th synonymous codon.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Wei-Chen Chen <a href="mailto:wccsnow@gmail.com">wccsnow@gmail.com</a>.
</p>


<h3>References</h3>

<p><a href="https://github.com/snoweye/cubfits/">https://github.com/snoweye/cubfits/</a>
</p>

<hr>
<h2 id='Datasets'>Datasets for Demonstrations</h2><span id='topic+b.Init'></span><span id='topic+ex.test'></span><span id='topic+ex.train'></span>

<h3>Description</h3>

<p>Examples of toy data to test and demonstrate <span class="pkg">cubfits</span>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  b.Init
  ex.test
  ex.train
</code></pre>


<h3>Format</h3>

<p>All are in list formats.
</p>


<h3>Details</h3>

<p><code>b.Init</code> contains two sets (<code>roc</code> and <code>rocnse</code>) of
initial coefficients including mutation and selection parameters for
3 amino acids 'A', 'C', and 'D' in <code>matrix</code> format.
Both sets are in <code><a href="#topic+b">b</a></code> format.
</p>
<p><code>ex.train</code> contains a training set of 100 sequences including
3 <code><a href="#topic+reu13.df">reu13.df</a></code> (codon counts in <code>reu13</code> data frame format
divided by amino acids),
3 <code><a href="#topic+y">y</a></code> (codon counts in simplified data frame format
divided by amino acids),
3 <code><a href="#topic+n">n</a></code> (total amino acid counts in vector format
divided by amino acids), and
<code><a href="#topic+phi.Obs">phi.Obs</a></code> (observed phi values in vector format).
</p>
<p><code>ex.test</code> contains a testing set of the other 100 sequences in the
same format of <code>ex.train</code>.
</p>


<h3>Author(s)</h3>

<p>Wei-Chen Chen <a href="mailto:wccsnow@gmail.com">wccsnow@gmail.com</a>.
</p>


<h3>References</h3>

<p><a href="https://github.com/snoweye/cubfits/">https://github.com/snoweye/cubfits/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+init.function">init.function</a>()</code>, <code><a href="#topic+cubfits">cubfits</a>()</code>,
<code><a href="#topic+cubpred">cubpred</a>()</code>, and <code><a href="#topic+cubappr">cubappr</a>()</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
suppressMessages(library(cubfits, quietly = TRUE))

str(b.Init)
str(ex.test)
str(ex.train)

## End(Not run)
</code></pre>

<hr>
<h2 id='Estimate+20Phi'>Initialization of Phi (Generic)</h2><span id='topic+estimatePhi'></span>

<h3>Description</h3>

<p>This generic function estimates Phi (expression value) either by posterior
mean (PM) or by maximum likelihood estimator (MLE) depending on options set
by <code><a href="#topic+init.function">init.function</a>()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  estimatePhi(fitlist, reu13.list, y.list, n.list,
    E.Phi = .CF.OP$E.Phi, lower.optim = .CF.OP$lower.optim,
    upper.optim = .CF.OP$upper.optim,
    lower.integrate = .CF.OP$lower.integrate,
    upper.integrate = .CF.OP$upper.integrate, control = list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Estimate+2B20Phi_+3A_fitlist">fitlist</code></td>
<td>
<p>an object of format <code><a href="#topic+b">b</a></code>.</p>
</td></tr>
<tr><td><code id="Estimate+2B20Phi_+3A_reu13.list">reu13.list</code></td>
<td>
<p>an object of format <code><a href="#topic+reu13.list">reu13.list</a></code>.</p>
</td></tr>
<tr><td><code id="Estimate+2B20Phi_+3A_y.list">y.list</code></td>
<td>
<p>an object of format <code><a href="#topic+y.list">y.list</a></code>.</p>
</td></tr>
<tr><td><code id="Estimate+2B20Phi_+3A_n.list">n.list</code></td>
<td>
<p>an object of format <code><a href="#topic+n.list">n.list</a></code>.</p>
</td></tr>
<tr><td><code id="Estimate+2B20Phi_+3A_e.phi">E.Phi</code></td>
<td>
<p>potential expected value of Phi.</p>
</td></tr>
<tr><td><code id="Estimate+2B20Phi_+3A_lower.optim">lower.optim</code></td>
<td>
<p>lower bound to <code>optim()</code>.</p>
</td></tr>
<tr><td><code id="Estimate+2B20Phi_+3A_upper.optim">upper.optim</code></td>
<td>
<p>upper bound to <code>optim()</code>.</p>
</td></tr>
<tr><td><code id="Estimate+2B20Phi_+3A_lower.integrate">lower.integrate</code></td>
<td>
<p>lower bound to <code>integrate()</code>.</p>
</td></tr>
<tr><td><code id="Estimate+2B20Phi_+3A_upper.integrate">upper.integrate</code></td>
<td>
<p>upper bound to <code>integrate()</code>.</p>
</td></tr>
<tr><td><code id="Estimate+2B20Phi_+3A_control">control</code></td>
<td>
<p>control options to <code>optim()</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>estimatePhi()</code> is a generic function first initialized by
<code><a href="#topic+init.function">init.function</a>()</code>, then it estimates Phi accordingly.
By default, <code>.CF.CT$init.Phi</code> sets the method <code>PM</code> for the
posterior mean.
</p>
<p><code>PM</code> uses a flat prior and <code>integrate()</code> to estimate
Phi. While, <code>MLE</code> uses <code>optim()</code> to estimate Phi which
may have boundary solutions for some sequences.
</p>


<h3>Value</h3>

<p>Estimated Phi for every sequence is returned.
</p>


<h3>Author(s)</h3>

<p>Wei-Chen Chen <a href="mailto:wccsnow@gmail.com">wccsnow@gmail.com</a>.
</p>


<h3>References</h3>

<p><a href="https://github.com/snoweye/cubfits/">https://github.com/snoweye/cubfits/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+init.function">init.function</a>()</code> and <code><a href="#topic+fitMultinom">fitMultinom</a>()</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
suppressMessages(library(cubfits, quietly = TRUE))
set.seed(1234)

# Convert data.
reu13.list &lt;- convert.reu13.df.to.list(ex.test$reu13.df)
y.list &lt;- convert.y.to.list(ex.test$y)
n.list &lt;- convert.n.to.list(ex.test$n)

# Get phi.pred.Init
init.function(model = "roc")
fitlist &lt;- fitMultinom(ex.train$reu13.df, ex.train$phi.Obs, ex.train$y, ex.train$n)
phi.pred.Init &lt;- estimatePhi(fitlist, reu13.list, y.list, n.list,
                         E.Phi = median(ex.test$phi.Obs),
                         lower.optim = min(ex.test$phi.Obs) * 0.9,
                         upper.optim = max(ex.test$phi.Obs) * 1.1)

## End(Not run)
</code></pre>

<hr>
<h2 id='Fit+20Multinomial'>Fit Multinomial Model (Generic)</h2><span id='topic+fitMultinom'></span>

<h3>Description</h3>

<p>This generic function estimates <code><a href="#topic+b">b</a></code>
(mutation (log(mu)) and selection (Delta.t) parameters)
depending on options set by <code><a href="#topic+init.function">init.function</a>()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  fitMultinom(reu13.df, phi, y, n, phi.new = NULL, coefstart = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Fit+2B20Multinomial_+3A_reu13.df">reu13.df</code></td>
<td>
<p>an object of format <code><a href="#topic+reu13.df">reu13.df</a></code>.</p>
</td></tr>
<tr><td><code id="Fit+2B20Multinomial_+3A_phi">phi</code></td>
<td>
<p>an object of format <code><a href="#topic+phi.Obs">phi.Obs</a></code>.</p>
</td></tr>
<tr><td><code id="Fit+2B20Multinomial_+3A_y">y</code></td>
<td>
<p>an object of format <code><a href="#topic+y">y</a></code>.</p>
</td></tr>
<tr><td><code id="Fit+2B20Multinomial_+3A_n">n</code></td>
<td>
<p>an object of format <code><a href="#topic+n">n</a></code>.</p>
</td></tr>
<tr><td><code id="Fit+2B20Multinomial_+3A_phi.new">phi.new</code></td>
<td>
<p>an object of format <code><a href="#topic+phi.Obs">phi.Obs</a></code> for MCMC only.</p>
</td></tr>
<tr><td><code id="Fit+2B20Multinomial_+3A_coefstart">coefstart</code></td>
<td>
<p>initial value for <code><a href="#topic+b">b</a></code>
(mutation (log(mu)) and selection (Delta.t) parameters)
only used in <code>vglm()</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>fitMultinom()</code> fits a multinomial logistic regression via
vector generalized linear model fitting, <code>vglm()</code>.
By default, for each amino acids, the last codon (order by characters)
is assumed as a based line, and other codons are compared to the based
line relatively.
</p>
<p>In MCMC, <code>phi.new</code> are new proposed expression values and
used to propose new <code><a href="#topic+b">b</a></code>. The <code>coefstart</code> is used to avoid
randomization of estimating <code><a href="#topic+b">b</a></code> in <code>vglm()</code>,
and speed up computation.
</p>


<h3>Value</h3>

<p>A list of format <code><a href="#topic+b">b</a></code> is returned which are modified from
the returns of <code>vglm()</code>. Mainly, it includes
<code>b$coefficient</code> (parameters in <code>vector</code>),
<code>b$coef.mat</code> (parameters in <code>matrix</code>), and
<code>b$R</code> (covariance matrix of parameters, *R* matrix in QR decomposition).
</p>


<h3>Author(s)</h3>

<p>Wei-Chen Chen <a href="mailto:wccsnow@gmail.com">wccsnow@gmail.com</a>.
</p>


<h3>References</h3>

<p><a href="https://github.com/snoweye/cubfits/">https://github.com/snoweye/cubfits/</a>
</p>
<p>Shah P. and Gilchrist M.A.
&ldquo;Explaining complex codon usage patterns
with selection for translational efficiency, mutation bias, and
genetic drift&rdquo;
Proc Natl Acad Sci USA (2011) 108:10231&ndash;10236.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+init.function">init.function</a>()</code> and <code><a href="#topic+estimatePhi">estimatePhi</a>()</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
suppressMessages(library(cubfits, quietly = TRUE))
set.seed(1234)

# Convert data.
reu13.list &lt;- convert.reu13.df.to.list(ex.test$reu13.df)
y.list &lt;- convert.y.to.list(ex.test$y)
n.list &lt;- convert.n.to.list(ex.test$n)

# Get phi.pred.Init
init.function(model = "roc")
fitlist &lt;- fitMultinom(ex.train$reu13.df, ex.train$phi.Obs, ex.train$y, ex.train$n)
phi.pred.Init &lt;- estimatePhi(fitlist, reu13.list, y.list, n.list,
                         E.Phi = median(ex.test$phi.Obs),
                         lower.optim = min(ex.test$phi.Obs) * 0.9,
                         upper.optim = max(ex.test$phi.Obs) * 1.1)

## End(Not run)
</code></pre>

<hr>
<h2 id='Generating+20Utility'>Generating Data Structure</h2><span id='topic+gen.reu13.df'></span><span id='topic+gen.reu13.list'></span><span id='topic+gen.y'></span><span id='topic+gen.n'></span><span id='topic+gen.phi.Obs'></span><span id='topic+gen.scuo'></span><span id='topic+DataGenerating'></span>

<h3>Description</h3>

<p>These utility functions generate and summarize sequence strings into several
useful formats such as <code><a href="#topic+reu13.df">reu13.df</a></code>, <code><a href="#topic+y">y</a></code>, and
<code><a href="#topic+n">n</a></code>, etc.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  gen.reu13.df(seq.string, phi.df = NULL, aa.names = .CF.GV$amino.acid,
               split.S = TRUE, drop.X = TRUE, drop.MW = TRUE,
               drop.1st.codon = TRUE)
  gen.y(seq.string, aa.names = .CF.GV$amino.acid,
        split.S = TRUE, drop.X = TRUE, drop.MW = TRUE)
  gen.n(seq.string, aa.names = .CF.GV$amino.acid,
        split.S = TRUE, drop.X = TRUE, drop.MW = TRUE)

  gen.reu13.list(seq.string, aa.names = .CF.GV$amino.acid,
                 split.S = TRUE, drop.X = TRUE, drop.MW = TRUE,
                 drop.1st.codon = TRUE)
  gen.phi.Obs(phi.df)
  gen.scuo(seq.string, aa.names = .CF.GV$amino.acid,
           split.S = TRUE, drop.X = TRUE, drop.MW = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Generating+2B20Utility_+3A_seq.string">seq.string</code></td>
<td>
<p>a list of sequence strings.</p>
</td></tr>
<tr><td><code id="Generating+2B20Utility_+3A_phi.df">phi.df</code></td>
<td>
<p>a <code><a href="#topic+phi.df">phi.df</a></code> object returned from <code><a href="#topic+read.phi.df">read.phi.df</a>()</code>.</p>
</td></tr>
<tr><td><code id="Generating+2B20Utility_+3A_aa.names">aa.names</code></td>
<td>
<p>a vector contains amino acid names for analysis.</p>
</td></tr>
<tr><td><code id="Generating+2B20Utility_+3A_split.s">split.S</code></td>
<td>
<p>split amino acid 'S' if any.</p>
</td></tr>
<tr><td><code id="Generating+2B20Utility_+3A_drop.x">drop.X</code></td>
<td>
<p>drop amino acid 'X' if any.</p>
</td></tr>
<tr><td><code id="Generating+2B20Utility_+3A_drop.mw">drop.MW</code></td>
<td>
<p>drop amino acid 'M' and 'W' if any.</p>
</td></tr>
<tr><td><code id="Generating+2B20Utility_+3A_drop.1st.codon">drop.1st.codon</code></td>
<td>
<p>if drop the first codon.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions mainly take inputs of sequence strings
<code><a href="#topic+seq.string">seq.string</a></code> or <code><a href="#topic+phi.df">phi.df</a></code> and turn them
into corresponding format.
</p>


<h3>Value</h3>

<p>The outputs are data structure in corresponding formats.
See <a href="#topic+AllDataFormats">AllDataFormats</a> for details.
</p>


<h3>Author(s)</h3>

<p>Wei-Chen Chen <a href="mailto:wccsnow@gmail.com">wccsnow@gmail.com</a>.
</p>


<h3>References</h3>

<p><a href="https://github.com/snoweye/cubfits/">https://github.com/snoweye/cubfits/</a>
</p>


<h3>See Also</h3>

<p><a href="#topic+AllDataFormats">AllDataFormats</a>,
<code><a href="#topic+read.seq">read.seq</a>()</code>, <code><a href="#topic+read.phi.df">read.phi.df</a>()</code>, and
<code><a href="#topic+convert.seq.data.to.string">convert.seq.data.to.string</a>()</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
suppressMessages(library(cubfits, quietly = TRUE))

seq.data &lt;- read.seq(get.expath("seq_200.fasta"))
phi.df &lt;- read.phi.df(get.expath("phi_200.tsv"))
aa.names &lt;- c("A", "C", "D")

# Read in from FASTA file.
seq.string &lt;- convert.seq.data.to.string(seq.data)
reu13.df &lt;- gen.reu13.df(seq.string, phi.df, aa.names)
reu13.list.new &lt;- gen.reu13.list(seq.string, aa.names)
y &lt;- gen.y(seq.string, aa.names)
n &lt;- gen.n(seq.string, aa.names)
scuo &lt;- gen.scuo(seq.string, aa.names)

# Convert to list format.
reu13.list &lt;- convert.reu13.df.to.list(reu13.df)
y.list &lt;- convert.y.to.list(y)
n.list &lt;- convert.n.to.list(n)

## End(Not run)
</code></pre>

<hr>
<h2 id='Initial+20Generic+20Functions'>Initial Generic Functions of Codon Usage Bias Fits</h2><span id='topic+init.function'></span>

<h3>Description</h3>

<p>Initial generic functions for model fitting/approximation/prediction
of <span class="pkg">cubfits</span>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  init.function(model = .CF.CT$model[1],
                type.p = .CF.CT$type.p[1],
                type.Phi = .CF.CT$type.Phi[1],
                model.Phi = .CF.CT$model.Phi[1],
                init.Phi = .CF.CT$init.Phi[1],
                init.fit = .CF.CT$init.fit[1],
                parallel = .CF.CT$parallel[1],
                adaptive = .CF.CT$adaptive[1])
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Initial+2B20Generic+2B20Functions_+3A_model">model</code></td>
<td>
<p>main fitted model.</p>
</td></tr>
<tr><td><code id="Initial+2B20Generic+2B20Functions_+3A_type.p">type.p</code></td>
<td>
<p>proposal method for hyper-parameters.</p>
</td></tr>
<tr><td><code id="Initial+2B20Generic+2B20Functions_+3A_type.phi">type.Phi</code></td>
<td>
<p>proposal method for Phi (true expression values).</p>
</td></tr>
<tr><td><code id="Initial+2B20Generic+2B20Functions_+3A_model.phi">model.Phi</code></td>
<td>
<p>prior of Phi.</p>
</td></tr>
<tr><td><code id="Initial+2B20Generic+2B20Functions_+3A_init.phi">init.Phi</code></td>
<td>
<p>initial methods for Phi.</p>
</td></tr>
<tr><td><code id="Initial+2B20Generic+2B20Functions_+3A_init.fit">init.fit</code></td>
<td>
<p>how is coefficient initialed in <code>vglm()</code> of <span class="pkg">VGAM</span>.</p>
</td></tr>
<tr><td><code id="Initial+2B20Generic+2B20Functions_+3A_parallel">parallel</code></td>
<td>
<p>parallel functions.</p>
</td></tr>
<tr><td><code id="Initial+2B20Generic+2B20Functions_+3A_adaptive">adaptive</code></td>
<td>
<p>method for adaptive MCMC.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function mainly takes the options, find the according generic
functions, and assign those functions to <code><a href="#topic+.cubfitsEnv">.cubfitsEnv</a></code>.
Those generic functions can be executed accordingly later within functions
for MCMC or multinomial logistic regression such as <code><a href="#topic+cubfits">cubfits</a>()</code>,
<code><a href="#topic+cubappr">cubappr</a>()</code>, and <code><a href="#topic+cubpred">cubpred</a>()</code>.
By default, those options are provided by <code><a href="#topic+.CF.CT">.CF.CT</a></code> which also
leaves rooms for extensions of more complicated models and further
optimizations.
</p>
<p>It is supposed to call this function before running any MCMC or
multinomial logistic regression. This function may affect
<code><a href="#topic+cubfits">cubfits</a>()</code>, <code><a href="#topic+cubpred">cubpred</a>()</code>, <code><a href="#topic+cubappr">cubappr</a>()</code>,
<code><a href="#topic+estimatePhi">estimatePhi</a>()</code>, and <code><a href="#topic+fitMultinom">fitMultinom</a>()</code>.
</p>

<ul>
<li>
<p><code>model</code> is the main fitting model, currently only <code>roc</code> is
fully supported.
</p>
</li>
<li>
<p><code>type.p</code> is for proposing hyper-parameters in Gibb sampler. Currently,
<code>lognormal_fix</code> is suggested where mean 1 is fixed for log normal
distribution. Conjugated prior and flat prior exist and are easily available
in this step
</p>
</li>
<li>
<p><code>type.Phi</code> is for proposing Phi (expression values) in the random walk
chain updates. Only, <code>RW_Norm</code> is supported. Usually, the acceptance
ratio can be adapted within 25% and 50% controlled by
<code><a href="#topic+.CF.AC">.CF.AC</a></code> if <code>adaptive = simple</code>.
</p>
</li>
<li>
<p><code>model.Phi</code> is for the distribution of Phi. Typically, log normal
distribution <code>lognormal</code> is assumed.
</p>
</li>
<li>
<p><code>init.Phi</code> is a way to initial Phi. Posterior mean <code>PM</code>
is recommended which avoid boundary values.
</p>
</li>
<li>
<p><code>init.fit</code> is a way of initial coefficients to fit mutation and
selection coefficients (<code class="reqn">\log\mu</code> and
<code class="reqn">\Delta t</code> or <code class="reqn">\omega</code>)
in <code>vglm()</code>. Option <code>current</code> means the <code><a href="#topic+b">b</a></code>
(log(mu) and Delta.t) of current MCMC iteration is the initial values, while
<code>random</code> means <code>vglm()</code> provides the initial values.
</p>
</li>
<li>
<p><code>parallel</code> is a way of parallel methods to speed up code.
<code>lapply</code> means <code>lapply()</code> is used and no parallel;
<code>mclapply</code> means <code>mclapply()</code> of <span class="pkg">parallel</span> is used and
good for shared memory machines;
<code>task.pull</code> means <code>task.pull()</code> of <span class="pkg">pbdMPI</span> is used and
good for heterogeneous machines;
<code>pbdLapply</code> means <code>pbdLapply()</code> of <span class="pkg">pbdMPI</span> is used and
good for homogeneous machines.
Among those, <code>task.pull</code> is tested thoroughly and is the most reliable
and efficient method.
</p>
</li>
<li>
<p><code>adaptive</code> is a way for adaptive MCMC that propose better mixing
distributions for random walks of Phi. The <code>simple</code> method is
suggested and only the proposal distribution of Phi
(<code>type.Phi = RW_Norm</code>) is adjusted gradually.
</p>
</li></ul>



<h3>Value</h3>

<p>Return an invisible object which is a list contain all
generic functions according to the input options.
All functions are also assigned in the <code><a href="#topic+.cubfitsEnv">.cubfitsEnv</a></code>
for later evaluations called by MCMC or multinomial logistic regression.
</p>


<h3>Note</h3>

<p>Note that all options are taken default values from the global control
object <code><a href="#topic+.CF.CT">.CF.CT</a></code>, so one can utilize/alter the object's values
to adjust those affected functions.
</p>
<p>Note that <code>phi.Obs</code> should be scaled to mean 1 before
applying to MCMC.
</p>


<h3>Author(s)</h3>

<p>Wei-Chen Chen <a href="mailto:wccsnow@gmail.com">wccsnow@gmail.com</a>.
</p>


<h3>References</h3>

<p><a href="https://github.com/snoweye/cubfits/">https://github.com/snoweye/cubfits/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+.CF.CT">.CF.CT</a></code>, <code><a href="#topic+.CF.CT">.CF.CT</a></code>, <code><a href="#topic+cubfits">cubfits</a>()</code>,
<code><a href="#topic+cubpred">cubpred</a>()</code>, and <code><a href="#topic+cubappr">cubappr</a>()</code>. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
suppressMessages(library(cubfits, quietly = TRUE))
set.seed(1234)

# Convert data.
reu13.list &lt;- convert.reu13.df.to.list(ex.test$reu13.df)
y.list &lt;- convert.y.to.list(ex.test$y)
n.list &lt;- convert.n.to.list(ex.test$n)

# Get phi.pred.Init
init.function(model = "roc")
fitlist &lt;- fitMultinom(ex.train$reu13.df, ex.train$phi.Obs, ex.train$y,
                       ex.train$n)
phi.pred.Init &lt;- estimatePhi(fitlist, reu13.list, y.list, n.list,
                         E.Phi = median(ex.test$phi.Obs),
                         lower.optim = min(ex.test$phi.Obs) * 0.9,
                         upper.optim = max(ex.test$phi.Obs) * 1.1)

## End(Not run)
</code></pre>

<hr>
<h2 id='Input+20and+20Output+20Utility'>Input and Output Utility</h2><span id='topic+get.expath'></span><span id='topic+read.seq'></span><span id='topic+read.phi.df'></span><span id='topic+write.seq'></span><span id='topic+write.phi.df'></span><span id='topic+DataIO'></span>

<h3>Description</h3>

<p>These utility functions read and write data of FASTA and phi.df formats.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  read.seq(file.name, forceDNAtolower = FALSE, convertDNAtoupper = TRUE)
  write.seq(seq.data, file.name)

  read.phi.df(file.name, header = TRUE, sep = "\t", quote = "")
  write.phi.df(phi.df, file.name)

  get.expath(file.name, path.root = "./ex_data/", pkg = "cubfits")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Input+2B20and+2B20Output+2B20Utility_+3A_file.name">file.name</code></td>
<td>
<p>a file name to read or write.</p>
</td></tr>
<tr><td><code id="Input+2B20and+2B20Output+2B20Utility_+3A_forcednatolower">forceDNAtolower</code></td>
<td>
<p>an option passed to <code>read.fasta()</code> of
<span class="pkg">seqinr</span> package.</p>
</td></tr>
<tr><td><code id="Input+2B20and+2B20Output+2B20Utility_+3A_convertdnatoupper">convertDNAtoupper</code></td>
<td>
<p>force everything in upper case.</p>
</td></tr>
<tr><td><code id="Input+2B20and+2B20Output+2B20Utility_+3A_header">header</code></td>
<td>
<p>an option passed to <code>read.table()</code>.</p>
</td></tr>
<tr><td><code id="Input+2B20and+2B20Output+2B20Utility_+3A_sep">sep</code></td>
<td>
<p>an option passed to <code>read.table()</code>.</p>
</td></tr>
<tr><td><code id="Input+2B20and+2B20Output+2B20Utility_+3A_quote">quote</code></td>
<td>
<p>an option passed to <code>read.table()</code>.</p>
</td></tr>
<tr><td><code id="Input+2B20and+2B20Output+2B20Utility_+3A_seq.data">seq.data</code></td>
<td>
<p>a <code><a href="#topic+seq.data">seq.data</a></code> object.</p>
</td></tr>
<tr><td><code id="Input+2B20and+2B20Output+2B20Utility_+3A_phi.df">phi.df</code></td>
<td>
<p>a <code><a href="#topic+phi.df">phi.df</a></code> object.</p>
</td></tr>
<tr><td><code id="Input+2B20and+2B20Output+2B20Utility_+3A_path.root">path.root</code></td>
<td>
<p>root path for the file name relatively to the pkg.</p>
</td></tr>
<tr><td><code id="Input+2B20and+2B20Output+2B20Utility_+3A_pkg">pkg</code></td>
<td>
<p>package name for the path of root.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>read.seq()</code> and <code>write.seq()</code> typically read and
write FASTA files (DNA ORFs or sequences).
</p>
<p><code>read.phi.df()</code> and <code>write.phi.df()</code> typically read and write
phi.df files (expression values of ORFs or sequences).
</p>
<p><code>get.expath()</code> is only for demonstration returning a full path
to the file.
</p>


<h3>Value</h3>

<p><code>read.seq()</code> returns an object of <code><a href="#topic+seq.data">seq.data</a></code> format
which can be converted to <code><a href="#topic+seq.string">seq.string</a></code> format later via
<code><a href="#topic+convert.seq.data.to.string">convert.seq.data.to.string</a>()</code>.
</p>
<p><code>read.phi.df()</code> returns an object of <code><a href="#topic+phi.df">phi.df</a></code> format
which contains expression values.
</p>


<h3>Author(s)</h3>

<p>Wei-Chen Chen <a href="mailto:wccsnow@gmail.com">wccsnow@gmail.com</a>.
</p>


<h3>References</h3>

<p><a href="https://github.com/snoweye/cubfits/">https://github.com/snoweye/cubfits/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+convert.seq.data.to.string">convert.seq.data.to.string</a>()</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
suppressMessages(library(cubfits, quietly = TRUE))

seq.data &lt;- read.seq(get.expath("seq_200.fasta"))
phi.df &lt;- read.phi.df(get.expath("phi_200.tsv"))
aa.names &lt;- c("A", "C", "D")

# Read in from FASTA file.
seq.string &lt;- convert.seq.data.to.string(seq.data)

## End(Not run)
</code></pre>

<hr>
<h2 id='Internal+20Functions'>All Internal Functions</h2><span id='topic+cp.workflow'></span><span id='topic+get.workflow'></span>

<h3>Description</h3>

<p>All internal functions</p>


<h3>Author(s)</h3>

<p>Wei-Chen Chen <a href="mailto:wccsnow@gmail.com">wccsnow@gmail.com</a>.
</p>


<h3>References</h3>

<p><a href="https://github.com/snoweye/cubfits/">https://github.com/snoweye/cubfits/</a>
</p>

<hr>
<h2 id='Mixed+20Normal+20Optimization'>Mixed Normal Optimization</h2><span id='topic+mixnormerr.optim'></span><span id='topic+dmixnormerr'></span>

<h3>Description</h3>

<p>Constrained optimization for mixed normal in 1D and typically for 2
components.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  mixnormerr.optim(X, K = 2, param = NULL)
  dmixnormerr(x, param)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Mixed+2B20Normal+2B20Optimization_+3A_x">X</code></td>
<td>
<p>a gene expression data matrix of dimension <code>N * R</code>
which has <code>N</code> genes and <code>R</code> replicates.</p>
</td></tr>
<tr><td><code id="Mixed+2B20Normal+2B20Optimization_+3A_k">K</code></td>
<td>
<p>number of components to fit.</p>
</td></tr>
<tr><td><code id="Mixed+2B20Normal+2B20Optimization_+3A_x">x</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="Mixed+2B20Normal+2B20Optimization_+3A_param">param</code></td>
<td>
<p>parameters of <code>mixnormerr</code>, typically the element
<code>param</code> of the <code>mixnormerr.optim()</code> returning object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>mixnormerr.optim()</code>
maximizes likelihood using <code>constrOptim()</code> based on
the gene expression data <code>X</code> (usually in log scale)
for <code>N</code> genes and <code>R</code> replicates (<code>NA</code> is allowed).
The likelihood of each gene expression
is a <code>K = 2</code> component mixed normal distribution
(<code class="reqn">\sum_k p_k N(mu_k, \sigma_k^2 + \sigma_e^2)</code>)
with measurement errors of the replicates
(<code class="reqn">N(0, \sigma_e^2)</code>).
</p>
<p>The <code>sigma_k^2</code> is as the error of random component and
the <code>sigma_e^2</code> is as the error of fixed component. Both
are within a mixture model of two normal distributions.
</p>
<p>The function <code>dmixnormerr()</code> computes the density of the mixed
normal distribution.
</p>
<p><code>param</code> is a parameter list and contains five elements:
<code>K</code> for number of components,
<code>prop</code> for proportions,
<code>mu</code> for centers of components,
<code>sigma2</code> for variance of components, and
<code>sigma2.e</code> for variance of measurement errors. 
</p>


<h3>Value</h3>

<p><code>mixnormerr.optim()</code> returns a list containing three main elements
<code>param</code> is the final results (MLEs), <code>param.start</code> is the starting
parameters, and <code>optim.ret</code> is the original returns of
<code>constrOptim()</code>.
</p>


<h3>Note</h3>

<p>This function is limited for small <code>K</code>. An equivalent EM algorithm
should be done in a more stable way for large <code>K</code>.
</p>


<h3>Author(s)</h3>

<p>Wei-Chen Chen <a href="mailto:wccsnow@gmail.com">wccsnow@gmail.com</a>.
</p>


<h3>References</h3>

<p><a href="https://github.com/snoweye/cubfits/">https://github.com/snoweye/cubfits/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+print.mixnormerr">print.mixnormerr</a>()</code>,
<code><a href="#topic+simu.mixnormerr">simu.mixnormerr</a>()</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
suppressMessages(library(cubfits, quietly = TRUE))

### Get individual of phi.Obs.
GM &lt;- apply(yassour[, -1], 1, function(x) exp(mean(log(x[x != 0]))))
phi.Obs.all &lt;- yassour[, -1] / sum(GM) * 15000
phi.Obs.all[phi.Obs.all == 0] &lt;- NA

### Run optimization.
X &lt;- log(as.matrix(phi.Obs.all))
param.init &lt;- list(K = 2, prop = c(0.95, 0.05), mu = c(-0.59, 3.11),
                   sigma2 = c(1.40, 0.59), sigma2.e = 0.03)
ret &lt;- mixnormerr.optim(X, K = 2, param = param.init)
print(ret)

## End(Not run)
</code></pre>

<hr>
<h2 id='Plotbin'>Plot Binning Results</h2><span id='topic+prop.bin.roc'></span><span id='topic+plotbin'></span>

<h3>Description</h3>

<p>Plot binning results to visualize the effects of mutation and selection
along with expression levels empirically.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  prop.bin.roc(reu13.df, phi.Obs = NULL, nclass = 20, bin.class = NULL,
               weightedCenters = TRUE, logBins = FALSE)

  plotbin(ret.bin, ret.model = NULL, main = NULL,
          xlab = "Production Rate (log10)", ylab = "Proportion",
          xlim = NULL, lty = 1, x.log10 = TRUE, stderr = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Plotbin_+3A_reu13.df">reu13.df</code></td>
<td>
<p>a <code><a href="#topic+reu13.df">reu13.df</a></code> object.</p>
</td></tr>
<tr><td><code id="Plotbin_+3A_phi.obs">phi.Obs</code></td>
<td>
<p>a <code><a href="#topic+phi.Obs">phi.Obs</a></code> object.</p>
</td></tr>
<tr><td><code id="Plotbin_+3A_nclass">nclass</code></td>
<td>
<p>number of binning classes across the range of <code>phi.Obs</code>.</p>
</td></tr>
<tr><td><code id="Plotbin_+3A_bin.class">bin.class</code></td>
<td>
<p>binning proportion, e.g.
<code>c(0, seq(0.05, 0.95, length = nclass), 1)</code>.</p>
</td></tr>
<tr><td><code id="Plotbin_+3A_ret.bin">ret.bin</code></td>
<td>
<p>binning results from <code><a href="#topic+prop.bin.roc">prop.bin.roc</a>()</code>.</p>
</td></tr>
<tr><td><code id="Plotbin_+3A_weightedcenters">weightedCenters</code></td>
<td>
<p>if centers are weighted.</p>
</td></tr>
<tr><td><code id="Plotbin_+3A_logbins">logBins</code></td>
<td>
<p>if use log scale for bin.</p>
</td></tr>
<tr><td><code id="Plotbin_+3A_ret.model">ret.model</code></td>
<td>
<p>model results from <code><a href="#topic+prop.model.roc">prop.model.roc</a>()</code>.</p>
</td></tr>
<tr><td><code id="Plotbin_+3A_main">main</code></td>
<td>
<p>an option passed to <code>plot()</code>.</p>
</td></tr>
<tr><td><code id="Plotbin_+3A_xlab">xlab</code></td>
<td>
<p>an option passed to <code>plot()</code>.</p>
</td></tr>
<tr><td><code id="Plotbin_+3A_ylab">ylab</code></td>
<td>
<p>an option passed to <code>plot()</code>.</p>
</td></tr>
<tr><td><code id="Plotbin_+3A_xlim">xlim</code></td>
<td>
<p>range of X-axis.</p>
</td></tr>
<tr><td><code id="Plotbin_+3A_lty">lty</code></td>
<td>
<p>line type if <code>ret.model</code> is provided.</p>
</td></tr>
<tr><td><code id="Plotbin_+3A_x.log10">x.log10</code></td>
<td>
<p><code>log10()</code> transformation of X-axis.</p>
</td></tr>
<tr><td><code id="Plotbin_+3A_stderr">stderr</code></td>
<td>
<p>plot stand error instead of stand deviation.</p>
</td></tr>
<tr><td><code id="Plotbin_+3A_...">...</code></td>
<td>
<p>options passed to <code>plot()</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>plotbin()</code> plots the binning results <code>ret.bin</code>
returned from <code>prop.bin.roc()</code>. Fitted curves may be added if
<code>ret.model</code> is provided which can be obtained from
<code><a href="#topic+prop.model.roc">prop.model.roc</a>()</code>.
</p>
<p><code><a href="#topic+plotaddmodel">plotaddmodel</a>()</code> can append model later if <code>ret.model</code>
is not provided to <code>plotbin()</code>.
</p>
<p>Currently, only ROC model is supported.
Colors are controlled by <code><a href="#topic+.CF.PT">.CF.PT</a></code>.
</p>


<h3>Value</h3>

<p>A binning plot is drawn.
</p>


<h3>Author(s)</h3>

<p>Wei-Chen Chen <a href="mailto:wccsnow@gmail.com">wccsnow@gmail.com</a>.
</p>


<h3>References</h3>

<p><a href="https://github.com/snoweye/cubfits/">https://github.com/snoweye/cubfits/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plotmodel">plotmodel</a>()</code> and <code><a href="#topic+prop.model.roc">prop.model.roc</a>()</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
demo(plotbin, 'cubfits', ask = F, echo = F)

## End(Not run)
</code></pre>

<hr>
<h2 id='Plotmodel'>Plot Fitted Models</h2><span id='topic+prop.model.roc'></span><span id='topic+plotmodel'></span><span id='topic+plotaddmodel'></span>

<h3>Description</h3>

<p>Plot model results to visualize the effects of mutation and selection
along with expression levels. 
The model can be fitted by MCMC or multinomial logistic regression.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  prop.model.roc(b.Init, phi.Obs.lim = c(0.01, 10), phi.Obs.scale = 1,
                 nclass = 40, x.log10 = TRUE)

  plotmodel(ret.model, main = NULL,
            xlab = "Production Rate (log10)", ylab = "Proportion",
            xlim = NULL, lty = 1, x.log10 = TRUE, ...)

  plotaddmodel(ret.model, lty, u.codon = NULL, color = NULL,
               x.log10 = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Plotmodel_+3A_b.init">b.Init</code></td>
<td>
<p>a <code><a href="#topic+b">b</a></code> object.</p>
</td></tr>
<tr><td><code id="Plotmodel_+3A_phi.obs.lim">phi.Obs.lim</code></td>
<td>
<p>range of <code>phi.Obs</code>.</p>
</td></tr>
<tr><td><code id="Plotmodel_+3A_phi.obs.scale">phi.Obs.scale</code></td>
<td>
<p>optional scaling factor.</p>
</td></tr>
<tr><td><code id="Plotmodel_+3A_nclass">nclass</code></td>
<td>
<p>number of binning classes across the range of <code>phi.Obs</code>.</p>
</td></tr>
<tr><td><code id="Plotmodel_+3A_x.log10">x.log10</code></td>
<td>
<p><code>log10()</code> transformation of X-axis.</p>
</td></tr>
<tr><td><code id="Plotmodel_+3A_ret.model">ret.model</code></td>
<td>
<p>model results from <code><a href="#topic+prop.model.roc">prop.model.roc</a>()</code>.</p>
</td></tr>
<tr><td><code id="Plotmodel_+3A_main">main</code></td>
<td>
<p>an option passed to <code>plot()</code>.</p>
</td></tr>
<tr><td><code id="Plotmodel_+3A_xlab">xlab</code></td>
<td>
<p>an option passed to <code>plot()</code>.</p>
</td></tr>
<tr><td><code id="Plotmodel_+3A_ylab">ylab</code></td>
<td>
<p>an option passed to <code>plot()</code>.</p>
</td></tr>
<tr><td><code id="Plotmodel_+3A_xlim">xlim</code></td>
<td>
<p>range of X-axis.</p>
</td></tr>
<tr><td><code id="Plotmodel_+3A_lty">lty</code></td>
<td>
<p>line type.</p>
</td></tr>
<tr><td><code id="Plotmodel_+3A_u.codon">u.codon</code></td>
<td>
<p>unique synonymous codon names.</p>
</td></tr>
<tr><td><code id="Plotmodel_+3A_color">color</code></td>
<td>
<p>a color vector for unique codon, typically returns of
the internal function <code>get.color()</code>.</p>
</td></tr>
<tr><td><code id="Plotmodel_+3A_...">...</code></td>
<td>
<p>options passed to <code>plot()</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>plotmodel()</code> plots the fitted curves obtained from
<code><a href="#topic+prop.model.roc">prop.model.roc</a>()</code>.
</p>
<p>The function <code>plotaddmodel()</code> can append model curves to a binning plot
provided unique synonymous codons and colors are given. This function is
nearly for an internal call within <code>plotmodel()</code>, but is exported and
useful for workflow.
</p>
<p>Currently, only ROC model is supported.
Colors are controlled by <code><a href="#topic+.CF.PT">.CF.PT</a></code>.
</p>


<h3>Value</h3>

<p>A fitted curve plot is drawn.
</p>


<h3>Author(s)</h3>

<p>Wei-Chen Chen <a href="mailto:wccsnow@gmail.com">wccsnow@gmail.com</a>.
</p>


<h3>References</h3>

<p><a href="https://github.com/snoweye/cubfits/">https://github.com/snoweye/cubfits/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plotbin">plotbin</a>()</code>, <code><a href="#topic+prop.bin.roc">prop.bin.roc</a>()</code>, and
<code><a href="#topic+prop.model.roc">prop.model.roc</a>()</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
demo(plotbin, 'cubfits', ask = F, echo = F)

## End(Not run)
</code></pre>

<hr>
<h2 id='Plotprxy'>Predictive X-Y Plot</h2><span id='topic+plotprxy'></span>

<h3>Description</h3>

<p>This utility function provides a basic plot of production rates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  plotprxy(x, y, x.ci = NULL, y.ci = NULL,
           log10.x = TRUE, log10.y = TRUE,
           add.lm = TRUE, add.one.to.one = TRUE, weights = NULL,
           add.legend = TRUE,
           xlim = NULL, ylim = NULL,
           xlab = "Predicted Production Rate (log10)",
           ylab = "Observed Production Rate (log10)",
           main = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Plotprxy_+3A_x">x</code></td>
<td>
<p>expression values.</p>
</td></tr>
<tr><td><code id="Plotprxy_+3A_y">y</code></td>
<td>
<p>expression values, of the same length of <code>x</code>.</p>
</td></tr>
<tr><td><code id="Plotprxy_+3A_x.ci">x.ci</code></td>
<td>
<p>confidence interval of <code>x</code>, of dimension
<code>length{x} * 2</code>, for outliers labeling.</p>
</td></tr>
<tr><td><code id="Plotprxy_+3A_y.ci">y.ci</code></td>
<td>
<p>confidence interval of <code>y</code>, of dimension
<code>length{y} * 2</code>, for outliers labeling.</p>
</td></tr>
<tr><td><code id="Plotprxy_+3A_log10.x">log10.x</code></td>
<td>
<p><code>log10()</code> and mean transformation of x axis.</p>
</td></tr>
<tr><td><code id="Plotprxy_+3A_log10.y">log10.y</code></td>
<td>
<p><code>log10()</code> and mean transformation of y axis.</p>
</td></tr>
<tr><td><code id="Plotprxy_+3A_add.lm">add.lm</code></td>
<td>
<p>if add <code>lm()</code> fit.</p>
</td></tr>
<tr><td><code id="Plotprxy_+3A_add.one.to.one">add.one.to.one</code></td>
<td>
<p>if add one-to-one line.</p>
</td></tr>
<tr><td><code id="Plotprxy_+3A_weights">weights</code></td>
<td>
<p>weights to <code>lm()</code>.</p>
</td></tr>
<tr><td><code id="Plotprxy_+3A_add.legend">add.legend</code></td>
<td>
<p>if add default legend.</p>
</td></tr>
<tr><td><code id="Plotprxy_+3A_xlim">xlim</code></td>
<td>
<p>limits of x-axis.</p>
</td></tr>
<tr><td><code id="Plotprxy_+3A_ylim">ylim</code></td>
<td>
<p>limits of y-axis.</p>
</td></tr>
<tr><td><code id="Plotprxy_+3A_xlab">xlab</code></td>
<td>
<p>an option passed to <code>plot()</code>.</p>
</td></tr>
<tr><td><code id="Plotprxy_+3A_ylab">ylab</code></td>
<td>
<p>an option passed to <code>plot()</code>.</p>
</td></tr>
<tr><td><code id="Plotprxy_+3A_main">main</code></td>
<td>
<p>an option passed to <code>plot()</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>As the usual X-Y plot where <code>x</code> and <code>y</code> are expression values.
</p>
<p>If <code>add.lm = TRUE</code> and <code>weights</code> are given, then both ordinary
and weighted least squares results will be plotted.
</p>


<h3>Value</h3>

<p>A scatter plot with a fitted <code>lm()</code> line and R squared value.
</p>


<h3>Author(s)</h3>

<p>Wei-Chen Chen <a href="mailto:wccsnow@gmail.com">wccsnow@gmail.com</a>.
</p>


<h3>References</h3>

<p><a href="https://github.com/snoweye/cubfits/">https://github.com/snoweye/cubfits/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plotbin">plotbin</a>()</code> and <code><a href="#topic+plotmodel">plotmodel</a>()</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
suppressMessages(library(cubfits, quietly = TRUE))

y.scuo &lt;- convert.y.to.scuo(ex.train$y)
SCUO &lt;- calc_scuo_values(y.scuo)$SCUO
plotprxy(ex.train$phi.Obs, SCUO)

## End(Not run)
</code></pre>

<hr>
<h2 id='Posterior+20Results+20of+20Yassour2009'>Posterior Results of Yassour 2009 Yeast Experiment Dataset</h2><span id='topic+yassour.PM.fits'></span><span id='topic+yassour.PM.appr'></span><span id='topic+yassour.info'></span>

<h3>Description</h3>

<p>Output summarized from MCMC posterior results
analyzing Yassour 2009 data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  yassour.PM.fits
  yassour.PM.appr
  yassour.info
</code></pre>


<h3>Format</h3>

<p>These are <code>list</code>'s containing several posterior means:
<code>E.Phi</code> for expected expression, <code>b.InitList.roc</code> for parameters,
<code>AA.prob</code> for proportion of amino acids, <code>sigmaW</code> for
standard error of measure errors, and <code>gene.length</code> for
gene length.
</p>


<h3>Details</h3>

<p><code>yassour.PM.fits</code> and <code>yassour.PM.appr</code> are the MCMC output
of with/without observed expression, respectively.
Both contain posterior means of expected expressions and coefficient
parameters: <code>E.Phi</code> and <code>b.InitList.roc</code> are
scaled results such that each MCMC iteration has mean 1 at <code>E.Phi</code>.
</p>
<p><code>yassour.info</code> contains sequences information (Yeast):
<code>AA.prob</code> and <code>gene.length</code> are summarized
from corresponding genes in the analysis.
</p>
<p>Note that some of genes may not have good quality of expression or sequence
information, so those genes are dropped from <code><a href="#topic+yassour">yassour</a></code> dataset.
</p>


<h3>References</h3>

<p><a href="https://github.com/snoweye/cubfits/">https://github.com/snoweye/cubfits/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+yassour">yassour</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
str(yassour.PM.fits)
str(yassour.PM.appr)
str(yassour.PM.info)

## End(Not run)
</code></pre>

<hr>
<h2 id='Print'>Functions for Printing Objects According to Classes</h2><span id='topic+print.mixnormerr'></span>

<h3>Description</h3>

<p>A Class <code>mixnormerr</code> is declared in <span class="pkg">cubfits</span>, and this is the function
to print and summary objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mixnormerr'
print(x, digits = max(4, getOption("digits") - 3), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Print_+3A_x">x</code></td>
<td>
<p>an object with the class attributes.</p>
</td></tr>
<tr><td><code id="Print_+3A_digits">digits</code></td>
<td>
<p>for printing out numbers.</p>
</td></tr>
<tr><td><code id="Print_+3A_...">...</code></td>
<td>
<p>other possible options.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is an useful function for summarizing and debugging.
</p>


<h3>Value</h3>

<p>The results will cat or print on the STDOUT by default.
</p>


<h3>Author(s)</h3>

<p>Wei-Chen Chen <a href="mailto:wccsnow@gmail.com">wccsnow@gmail.com</a>.
</p>


<h3>References</h3>

<p><a href="https://github.com/snoweye/cubfits/">https://github.com/snoweye/cubfits/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mixnormerr.optim">mixnormerr.optim</a>()</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
suppressMessages(library(cubfits, quietly = TRUE))

### Get individual of phi.Obs.
GM &lt;- apply(yassour[, -1], 1, function(x) exp(mean(log(x[x != 0]))))
phi.Obs.all &lt;- yassour[, -1] / sum(GM) * 15000
phi.Obs.all[phi.Obs.all == 0] &lt;- NA

### Run optimization.
X &lt;- log(as.matrix(phi.Obs.all))
param.init &lt;- list(K = 2, prop = c(0.95, 0.05), mu = c(-0.59, 3.11),
                   sigma2 = c(1.40, 0.59), sigma2.e = 0.03)
ret &lt;- mixnormerr.optim(X, K = 2, param = param.init)
print(ret)

## End(Not run)
</code></pre>

<hr>
<h2 id='Randomize+20SCUO+20Index'>Generate Randomized SCUO Index</h2><span id='topic+scuo.random'></span>

<h3>Description</h3>

<p>Generate randomized SCUO indices in log normal distribution, but
provided original unchanged SCUO order.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  scuo.random(SCUO, phi.Obs = NULL, meanlog = .CF.PARAM$phi.meanlog,
              sdlog = .CF.PARAM$phi.sdlog)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Randomize+2B20SCUO+2B20Index_+3A_scuo">SCUO</code></td>
<td>
<p>SCUO index returned from <code><a href="#topic+calc_scuo_values">calc_scuo_values</a>()</code>.</p>
</td></tr>
<tr><td><code id="Randomize+2B20SCUO+2B20Index_+3A_phi.obs">phi.Obs</code></td>
<td>
<p>optional object of format <code><a href="#topic+phi.Obs">phi.Obs</a></code>.</p>
</td></tr>
<tr><td><code id="Randomize+2B20SCUO+2B20Index_+3A_meanlog">meanlog</code></td>
<td>
<p>mean of log normal distribution.</p>
</td></tr>
<tr><td><code id="Randomize+2B20SCUO+2B20Index_+3A_sdlog">sdlog</code></td>
<td>
<p>std of log normal distribution.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function takes <code>SCUO</code> indices (outputs of
<code><a href="#topic+calc_scuo_values">calc_scuo_values</a>()</code>)
computes the rank of them, generates log normal random variables, and
replaces <code>SCUO</code> indices by those variables in the same rank orders.
Typically, these random variables are used to replace expression values
when either no expression is observed or for the purpose of model validation.
</p>
<p>If <code>phi.Obs</code> is provided, the mean and std of <code>log(phi.Obs)</code> are used
for log normal random variables. Otherwise, <code>menalog</code> and <code>sdlog</code>
are used.
</p>
<p>The default <code>meanlog</code> and <code>sdlog</code> was estimated from
<code>yassour</code> dataset.
</p>


<h3>Value</h3>

<p>A vector of log normal random variables is returned.
</p>


<h3>Author(s)</h3>

<p>Wei-Chen Chen <a href="mailto:wccsnow@gmail.com">wccsnow@gmail.com</a>.
</p>


<h3>References</h3>

<p><a href="https://github.com/snoweye/cubfits/">https://github.com/snoweye/cubfits/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+calc_scuo_values">calc_scuo_values</a>()</code>, <code>yassour</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
suppressMessages(library(cubfits, quietly = TRUE))

### example dataset.
y.scuo &lt;- convert.y.to.scuo(ex.train$y)
SCUO &lt;- calc_scuo_values(y.scuo)$SCUO
plotprxy(ex.train$phi.Obs, SCUO)

### yassour dataset.
GM &lt;- apply(yassour[, -1], 1, function(x) exp(mean(log(x[x != 0]))))
phi.Obs &lt;- GM / sum(GM) * 15000
mean(log(phi.Obs))
sd(log(phi.Obs))
ret &lt;- scuo.random(SCUO, meanlog = -0.441473, sdlog = 1.393285)
plotprxy(ret, SCUO)

## End(Not run)
</code></pre>

<hr>
<h2 id='Rearrangment+20Utility'>Rearrange Data Structure by ORF Names</h2><span id='topic+rearrange.reu13.df'></span><span id='topic+rearrange.y'></span><span id='topic+rearrange.n'></span><span id='topic+rearrange.phi.Obs'></span>

<h3>Description</h3>

<p>These utility functions rearrange data in the order of ORF names.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  rearrange.reu13.df(reu13.df)
  rearrange.y(y)
  rearrange.n(n)
  rearrange.phi.Obs(phi.Obs)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Rearrangment+2B20Utility_+3A_reu13.df">reu13.df</code></td>
<td>
<p>a list of <code><a href="#topic+reu13.df">reu13.df</a></code> data frames
divided by amino acids.</p>
</td></tr>
<tr><td><code id="Rearrangment+2B20Utility_+3A_y">y</code></td>
<td>
<p>a list of <code><a href="#topic+y">y</a></code> data frames divided by amino acids.</p>
</td></tr>
<tr><td><code id="Rearrangment+2B20Utility_+3A_n">n</code></td>
<td>
<p>a list of <code><a href="#topic+n">n</a></code> vectors divided by amino acids.</p>
</td></tr>
<tr><td><code id="Rearrangment+2B20Utility_+3A_phi.obs">phi.Obs</code></td>
<td>
<p>a vector of <code><a href="#topic+phi.Obs">phi.Obs</a></code> format.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These utility functions take inputs and return ordered outputs.
It is necessary to rearrange data in a right order of ORF names which
avoids subsetting data frame within MCMC and improve performance.
</p>


<h3>Value</h3>

<p>The outputs are in the same format of inputs except the order of data
is sorted by ORF names.
</p>


<h3>Author(s)</h3>

<p>Wei-Chen Chen <a href="mailto:wccsnow@gmail.com">wccsnow@gmail.com</a>.
</p>


<h3>References</h3>

<p><a href="https://github.com/snoweye/cubfits/">https://github.com/snoweye/cubfits/</a>
</p>


<h3>See Also</h3>

<p><a href="#topic+AllDataFormats">AllDataFormats</a>,
<code><a href="#topic+convert.n.to.list">convert.n.to.list</a>()</code>,
<code><a href="#topic+convert.reu13.df.to.list">convert.reu13.df.to.list</a>()</code>, and
<code><a href="#topic+convert.y.to.list">convert.y.to.list</a>()</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
suppressMessages(library(cubfits, quietly = TRUE))

reu13.df &lt;- rearrange.reu13.df(ex.train$reu13.df)
y &lt;- rearrange.y(ex.train$y)
n &lt;- rearrange.n(ex.train$n)
phi.Obs &lt;- rearrange.phi.Obs(ex.train$phi.Obs)

## End(Not run)
</code></pre>

<hr>
<h2 id='SCUO+20Index'>Function for Synonymous Codon Usage Order (SCUO) Index</h2><span id='topic+calc_scuo_values'></span>

<h3>Description</h3>

<p>Calculate the Synonymous Codon Usage Order (SCUO) index for each gene.
Used as a substitute for expression in cases of without expression
measurements.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  calc_scuo_values(codon.counts)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SCUO+2B20Index_+3A_codon.counts">codon.counts</code></td>
<td>
<p>an object of format <code><a href="#topic+scuo">scuo</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function computes SCUO index for each gene. Typically, this method
is completely based on entropy and information theory to estimate
expression values of sequences according to their codon information.
</p>


<h3>Value</h3>

<p><code>SCUO</code> indices are returned.
</p>


<h3>Author(s)</h3>

<p>Drew Schmidt.
</p>


<h3>References</h3>

<p><a href="https://www.tandfonline.com/doi/abs/10.1080/03081070500502967">https://www.tandfonline.com/doi/abs/10.1080/03081070500502967</a>
</p>
<p>Wan X.-F., Zhou J., Xu D.
&ldquo;CodonO: a new informatics method for measuring synonymous codon usage
bias within and across genomes&rdquo;
International Journal of General Systems Vol. 35, Iss. 1, 2006.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+scuo.random">scuo.random</a>()</code>, <code><a href="#topic+calc_cai_values">calc_cai_values</a>()</code>,
<code><a href="#topic+calc_scu_values">calc_scu_values</a>()</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
suppressMessages(library(cubfits, quietly = TRUE))

y.scuo &lt;- convert.y.to.scuo(ex.train$y)
SCUO &lt;- calc_scuo_values(y.scuo)$SCUO
plotprxy(ex.train$phi.Obs, SCUO, ylab = "SCUO (log10)")

## End(Not run)
</code></pre>

<hr>
<h2 id='Selection+20on+20Codon+20Usage'>Function for Selection on Codon Usage (SCU)</h2><span id='topic+calc_scu_values'></span>

<h3>Description</h3>

<p>Calculate the average translational selection per transcript
include mSCU and SCU (if gene expression is provided) for each gene.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  calc_scu_values(b, y.list, phi.Obs = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Selection+2B20on+2B20Codon+2B20Usage_+3A_b">b</code></td>
<td>
<p>an object of format <code><a href="#topic+b">b</a></code>.</p>
</td></tr>
<tr><td><code id="Selection+2B20on+2B20Codon+2B20Usage_+3A_y.list">y.list</code></td>
<td>
<p>an object of format <code><a href="#topic+y.list">y.list</a></code>.</p>
</td></tr>
<tr><td><code id="Selection+2B20on+2B20Codon+2B20Usage_+3A_phi.obs">phi.Obs</code></td>
<td>
<p>an object of format <code><a href="#topic+phi.Obs">phi.Obs</a></code>, for
SCU only.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function computes SCU and mSCU for each gene. Typically, this method
is completely based on estimated parameters of mutation and selection
such as outputs of MCMC or <code><a href="#topic+fitMultinom">fitMultinom</a>()</code>.
</p>


<h3>Value</h3>

<p>A list with two named elements <code>SCU</code> and <code>mSCU</code> are returned.
</p>


<h3>Author(s)</h3>

<p>Wei-Chen Chen <a href="mailto:wccsnow@gmail.com">wccsnow@gmail.com</a>.
</p>


<h3>References</h3>

<p>Wallace E.W.J., Airoldi E.M., and Drummond D.A.
&ldquo;Estimating Selection on Synonymous Codon Usage from Noisy Experimental
Data&rdquo;
Mol Biol Evol (2013) 30(6):1438&ndash;1453.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+calc_scuo_values">calc_scuo_values</a>()</code>,
<code><a href="#topic+calc_cai_values">calc_cai_values</a>()</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(cubfits, quietly = TRUE)

b &lt;- b.Init$roc
phi.Obs &lt;- ex.train$phi.Obs
y &lt;- ex.train$y
y.list &lt;- convert.y.to.list(y)
mSCU &lt;- calc_scu_values(b, y.list, phi.Obs)$mSCU
plot(mSCU, log10(phi.Obs), main = "Expression vs mSCU",
     xlab = "mSCU", ylab = "Expression (log10)")

### Compare with CAI with weights seqinr::cubtab$sc.
library(seqinr, quietly = TRUE)
w &lt;- caitab$sc
names(w) &lt;- codon.low2up(rownames(caitab))
CAI &lt;- calc_cai_values(y, y.list, w = w)$CAI

plot(mSCU, CAI, main = "CAI vs mSCU",
     xlab = "mSCU", ylab = "CAI")

## End(Not run)
</code></pre>

<hr>
<h2 id='Simulation+20Tool'>Simulate ORFs and Expression Data</h2><span id='topic+simu.orf'></span><span id='topic+simu.phi.Obs'></span><span id='topic+simu.mixnormerr'></span>

<h3>Description</h3>

<p>These utility functions generate data for simulation studies
including fake ORFs and expression values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  simu.orf(n, b.Init, phi.Obs = NULL, AA.prob = NULL, orf.length = NULL,
           orf.names = NULL, model = .CF.CT$model)
  simu.phi.Obs(Phi, sigmaW.lim = 1, bias.Phi = 0)
  simu.mixnormerr(n, param)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Simulation+2B20Tool_+3A_n">n</code></td>
<td>
<p>number of ORFs or sequences.</p>
</td></tr>
<tr><td><code id="Simulation+2B20Tool_+3A_b.init">b.Init</code></td>
<td>
<p>parameters of mutation and selection of format
<code><a href="#topic+b">b</a></code>.</p>
</td></tr>
<tr><td><code id="Simulation+2B20Tool_+3A_phi.obs">phi.Obs</code></td>
<td>
<p>an object of format <code><a href="#topic+phi.Obs">phi.Obs</a></code>.</p>
</td></tr>
<tr><td><code id="Simulation+2B20Tool_+3A_aa.prob">AA.prob</code></td>
<td>
<p>proportion of amino acids.</p>
</td></tr>
<tr><td><code id="Simulation+2B20Tool_+3A_orf.length">orf.length</code></td>
<td>
<p>lengths of ORFs.</p>
</td></tr>
<tr><td><code id="Simulation+2B20Tool_+3A_orf.names">orf.names</code></td>
<td>
<p>names of ORFs.</p>
</td></tr>
<tr><td><code id="Simulation+2B20Tool_+3A_model">model</code></td>
<td>
<p>model to be simulated.</p>
</td></tr>
<tr><td><code id="Simulation+2B20Tool_+3A_phi">Phi</code></td>
<td>
<p>expression values (potentially true expression).</p>
</td></tr>
<tr><td><code id="Simulation+2B20Tool_+3A_sigmaw.lim">sigmaW.lim</code></td>
<td>
<p>std of measurement errors (between Phi and phi.Obs).</p>
</td></tr>
<tr><td><code id="Simulation+2B20Tool_+3A_bias.phi">bias.Phi</code></td>
<td>
<p>bias (in log scale) for observed phi.</p>
</td></tr>
<tr><td><code id="Simulation+2B20Tool_+3A_param">param</code></td>
<td>
<p>as in <code><a href="#topic+dmixnormerr">dmixnormerr</a>()</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>simu.orf()</code> generates ORFs or sequences based on the <code>b.Init</code>
and <code>phi.Obs</code>.
</p>
<p>If <code>phi.Obs</code> is omitted, then standard log normal random variables
are instead).
</p>
<p>If <code>AA.prob</code> is omitted, then uniform proportion is assigned.
</p>
<p>If <code>orf.length</code> is omitted, then 10 to 20 codons are randomly
assigned.
</p>
<p>If <code>orf.names</code> is omitted, then &quot;ORF1&quot; to &quot;ORFn&quot; are assigned.
</p>
<p><code>simu.phi.Obs()</code> generates <code><a href="#topic+phi.Obs">phi.Obs</a></code> by adding normal random
errors to <code>Phi</code>, and errors have mean 0 and standard deviation
<code>sigmaW.lim</code>.
</p>
<p><code>simu.mixnormerr()</code> generates <code>Phi</code> according to the <code>param</code>,
and adds normal random errors to <code>Phi</code>.
</p>


<h3>Value</h3>

<p><code>simu.orf()</code> returns a list of format <code><a href="#topic+seq.data">seq.data</a></code>.
</p>
<p><code>simu.phi.Obs()</code> returns a vector of format <code><a href="#topic+phi.Obs">phi.Obs</a></code>.
</p>
<p><code>simu.mixnormerr()</code> returns a list contains three vectors of length
<code>n</code>: one for expected gene expression <code>Phi</code>, one for observed
gene expression <code>phi.Obs</code>, and one for the component id <code>id.K</code>.
</p>


<h3>Author(s)</h3>

<p>Wei-Chen Chen <a href="mailto:wccsnow@gmail.com">wccsnow@gmail.com</a>.
</p>


<h3>References</h3>

<p><a href="https://github.com/snoweye/cubfits/">https://github.com/snoweye/cubfits/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+read.seq">read.seq</a>()</code>, <code><a href="#topic+read.phi.df">read.phi.df</a>()</code>,
<code><a href="#topic+write.seq">write.seq</a>()</code>, <code><a href="#topic+write.phi.df">write.phi.df</a>()</code>, and
<code><a href="#topic+mixnormerr.optim">mixnormerr.optim</a>()</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
suppressMessages(library(cubfits, quietly = TRUE))
set.seed(1234)

# Generate sequences.
da.roc &lt;- simu.orf(length(ex.train$phi.Obs), b.Init$roc,
                   phi.Obs = ex.train$phi.Obs, model = "roc")
names(da.roc) &lt;- names(ex.train$phi.Obs)
write.fasta(da.roc, names(da.roc), "toy_roc.fasta")

## End(Not run)
</code></pre>

<hr>
<h2 id='Yassour2009'>Yassour 2009 Yeast Experiment Dataset</h2><span id='topic+yassour'></span>

<h3>Description</h3>

<p>Experiments and data are obtained from Yassour et. al. (2009).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  yassour
</code></pre>


<h3>Format</h3>

<p>A <code>data.frame</code> contains 6303 rows and 5 columns:
<code>ORF</code> is for gene names in character, and
<code>YPD0.1</code>, <code>YPD0.2</code>, <code>YPD15.1</code>, and <code>YPD15.2</code> are
gene expressions in positive double corresponding to 4 controlled
Yeast experiments.
</p>


<h3>Details</h3>

<p>The original data are available as the URL of the section of Source next.
As the section of Examples next, data are selected from <code>SD3.xls</code> and
reordered by <code>ORF</code>.
</p>
<p>For further analysis, the Examples section also provides how to
convert them to <code>phi.Obs</code> values either in geometric means or individually.
</p>


<h3>Source</h3>

<p><a href="https://www.pnas.org/content/early/2009/02/10/0812841106">https://www.pnas.org/content/early/2009/02/10/0812841106</a>
</p>
<p><a href="https://www.pnas.org/highwire/filestream/598612/field_highwire_adjunct_files/3/SD3.xls">https://www.pnas.org/highwire/filestream/598612/field_highwire_adjunct_files/3/SD3.xls</a>
</p>
<p>Yassour M, Kaplan T, Fraser HB, Levin JZ, Pfiffner J, Adiconis X,
Schroth G, Luo S, Khrebtukova I, Gnirke A, Nusbaum C, Thompson DA,
Friedman N, Regev A. (2009) &ldquo;Ab initio construction of a eukaryotic
transcriptome by massively parallel mRNA sequencing.&rdquo;
Proc Natl Acad Sci USA 106(9):3264-9. [PMID:19208812]
</p>


<h3>References</h3>

<p>Wallace E.W.J., Airoldi E.M., and Drummond D.A.
&ldquo;Estimating Selection on Synonymous Codon Usage from Noisy Experimental
Data&rdquo;
Mol Biol Evol (2013) 30(6):1438&ndash;1453.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
### SD3.xls is available from the URL provided in the References.
da &lt;- read.table("SD3.xls", header = TRUE, sep = "\t", quote = "",
                 stringsAsFactors = FALSE)

### Select ORF, YPD0.1, YPD0.2, YPD15.1, YPD15.2.
da &lt;- da[, c(1, 8, 9, 10, 11)]
colnames(da) &lt;- c("ORF", "YPD0.1", "YPD0.2", "YPD15.1", "YPD15.2")

### Drop inappropriate values (NaN, NA, Inf, -Inf, and 0).
tmp &lt;- da[, 2:5]
id.tmp &lt;- rowSums(is.finite(as.matrix(tmp)) &amp; tmp != 0) &gt;= 3
tmp &lt;- da[id.tmp, 1:5]
yassour &lt;- tmp[order(tmp$ORF),]    # cubfits::yassour

### Get geometric mean of phi.Obs and scaling similar to Wallace (2013).
GM &lt;- apply(yassour[, -1], 1, function(x) exp(mean(log(x[x != 0]))))
phi.Obs &lt;- GM / sum(GM) * 15000

### Get individual of phi.Obs.
GM &lt;- apply(yassour[, -1], 1, function(x) exp(mean(log(x[x != 0]))))
phi.Obs.all &lt;- yassour[, -1] / sum(GM) * 15000
phi.Obs.all[phi.Obs.all == 0] &lt;- NA

## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
