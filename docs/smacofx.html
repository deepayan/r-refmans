<!DOCTYPE html><html><head><title>Help for package smacofx</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {smacofx}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#alscal'><p>ALSCAL SMACOF</p></a></li>
<li><a href='#apStressMin'><p>Approximate Power Stress SMACOF</p></a></li>
<li><a href='#BankingCrisesDistances'><p>Banking Crises Distances</p></a></li>
<li><a href='#bcmds'><p>Box-Cox MDS</p></a></li>
<li><a href='#bcsdistance'><p>Calculating the blended chi square distance matrix between n vectors.</p></a></li>
<li><a href='#biplotmds.smacofP'><p>S3 method for smacofP objects</p></a></li>
<li><a href='#bootmds.smacofP'><p>MDS Bootstrap for smacofP objects</p></a></li>
<li><a href='#clca'><p>Curvilinear Component Analysis (CLCA)</p></a></li>
<li><a href='#clda'><p>Curvilinear Distance Analysis (CLDA)</p></a></li>
<li><a href='#cmds'><p>Classical Scaling</p></a></li>
<li><a href='#cmdscale'><p>Wrapper to <code>cmdscale</code> for S3 class</p></a></li>
<li><a href='#conf_adjust'><p>conf_adjust: a function to procrustes adjust two matrices</p></a></li>
<li><a href='#doubleCenter'><p>Double centering of a matrix</p></a></li>
<li><a href='#elscal'><p>Elastic Scaling  SMACOF</p></a></li>
<li><a href='#enorm'><p>Explicit Normalization</p>
Normalizes distances</a></li>
<li><a href='#icExploreGen'><p>Exploring initial configurations in an agnostic way</p></a></li>
<li><a href='#jackmds.smacofP'><p>MDS Jackknife for smacofP objects</p></a></li>
<li><a href='#lmds'><p>Local MDS</p></a></li>
<li><a href='#mkBmat'><p>Auxfunction1</p></a></li>
<li><a href='#mkPower'><p>Take matrix to a power</p></a></li>
<li><a href='#multiscale'><p>Multiscale SMACOF</p></a></li>
<li><a href='#multistart'><p>Multistart MDS function</p></a></li>
<li><a href='#pdist'><p>Squared p-distances</p></a></li>
<li><a href='#permtest.smacofP'><p>Permutation test for smacofP objects</p></a></li>
<li><a href='#plot.smacofP'><p>S3 plot method for smacofP objects</p></a></li>
<li><a href='#powerStressFast'><p>Power stress minimization by NEWUOA (nloptr)</p></a></li>
<li><a href='#powerStressMin'><p>Power Stress SMACOF</p></a></li>
<li><a href='#procruster'><p>procruster: a procrustes function</p></a></li>
<li><a href='#rpowerStressMin'><p>Restricted Power Stress SMACOF</p></a></li>
<li><a href='#rStressMin'><p>R stress SMACOF</p></a></li>
<li><a href='#sammon'><p>Wrapper to <code>sammon</code> for S3 class</p></a></li>
<li><a href='#sammonmap'><p>Sammon Mapping SMACOF</p></a></li>
<li><a href='#scale_adjust'><p>Adjusts a configuration</p></a></li>
<li><a href='#secularEq'><p>Secular Equation</p></a></li>
<li><a href='#smacofx'><p>smacofx: Flexible multidimensional scaling methods and SMACOF extensions</p></a></li>
<li><a href='#spmdda'><p>Sparse (POST-)Multidimensional Distance Analysis (SPMDDA or SMDDA) either as self-organizing or not</p></a></li>
<li><a href='#spmds'><p>Sparsified (POST-) Multidimensional Scaling (SPMDS or SMDS) either as self-organizing or not</p></a></li>
<li><a href='#spp'><p>Calculating stress per point</p></a></li>
<li><a href='#sqdist'><p>Squared distances</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Flexible Multidimensional Scaling and 'smacof' Extensions</td>
</tr>
<tr>
<td>Version:</td>
<td>0.6-6</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Thomas Rusch &lt;thomas.rusch@wu.ac.at&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Flexible multidimensional scaling (MDS) methods centered around scaling with majorization and
    extensions to the package 'smacof'. This package enhances 'smacof' and contains various functions, wrappers,
    methods and classes for fitting, plotting and displaying a large number of different flexible MDS models
    (some as of yet unpublished) such as Torgerson scaling (Torgerson, 1958, ISBN:978-0471879459) with powers,
    Sammon mapping (Sammon, 1969, &lt;<a href="https://doi.org/10.1109%2FT-C.1969.222678">doi:10.1109/T-C.1969.222678</a>&gt;) with ratio and interval optimal scaling,
    Multiscale MDS (Ramsay, 1977, &lt;<a href="https://doi.org/10.1007%2FBF02294052">doi:10.1007/BF02294052</a>&gt;) with ratio and interval optimal scaling, S-stress MDS
    (ALSCAL; Takane, Young &amp; De Leeuw, 1977, &lt;<a href="https://doi.org/10.1007%2FBF02293745">doi:10.1007/BF02293745</a>&gt;) with ratio and interval optimal
    scaling, elastic scaling (McGee, 1966, &lt;<a href="https://doi.org/10.1111%2Fj.2044-8317.1966.tb00367.x">doi:10.1111/j.2044-8317.1966.tb00367.x</a>&gt;) with ratio and interval
    optimal scaling, r-stress MDS (De Leeuw, Groenen &amp; Mair, 2016, <a href="https://rpubs.com/deleeuw/142619">https://rpubs.com/deleeuw/142619</a>) with ratio,
    interval and non-metric optimal scaling, power-stress MDS
    (POST-MDS; Buja &amp; Swayne, 2002 &lt;<a href="https://doi.org/10.1007%2Fs00357-001-0031-0">doi:10.1007/s00357-001-0031-0</a>&gt;) with ratio and interval optimal scaling,
    restricted power-stress (Rusch, Mair &amp; Hornik, 2021, &lt;<a href="https://doi.org/10.1080%2F10618600.2020.1869027">doi:10.1080/10618600.2020.1869027</a>&gt;)
    with ratio and interval optimal scaling, approximate power-stress with ratio optimal scaling
    (Rusch, Mair &amp; Hornik, 2021, &lt;<a href="https://doi.org/10.1080%2F10618600.2020.1869027">doi:10.1080/10618600.2020.1869027</a>&gt;),
    Box-Cox MDS (Chen &amp; Buja, 2013, <a href="https://jmlr.org/papers/v14/chen13a.html">https://jmlr.org/papers/v14/chen13a.html</a>),
    local MDS (Chen &amp; Buja, 2009, &lt;<a href="https://doi.org/10.1198%2Fjasa.2009.0111">doi:10.1198/jasa.2009.0111</a>&gt;), curvilinear component analysis
    (Demartines &amp; Herault, 1997, &lt;<a href="https://doi.org/10.1109%2F72.554199">doi:10.1109/72.554199</a>&gt;) and curvilinear distance analysis
    (Lee, Lendasse &amp; Verleysen, 2004, &lt;<a href="https://doi.org/10.1016%2Fj.neucom.2004.01.007">doi:10.1016/j.neucom.2004.01.007</a>&gt;). There also are experimental
    models (e.g., sparsified MDS and sparsified POST-MDS). Some functions are suitably flexible to allow any other
    sensible combination of explicit power transformations for weights, distances and input proximities with
    implicit ratio, interval or non-metric optimal scaling of the input proximities. Most functions use a 
    Majorization-Minimization algorithm. </td>
</tr>
<tr>
<td>Depends:</td>
<td>smacof (&ge; 1.10-4)</td>
</tr>
<tr>
<td>Imports:</td>
<td>MASS, minqa, plotrix, ProjectionBasedClustering, weights,
vegan</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://r-forge.r-project.org/projects/stops/">https://r-forge.r-project.org/projects/stops/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://r-forge.r-project.org/tracker/?atid=5375&amp;group_id=2037&amp;func=browse">https://r-forge.r-project.org/tracker/?atid=5375&amp;group_id=2037&amp;func=browse</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-08-16 10:41:38 UTC; trusch</td>
</tr>
<tr>
<td>Author:</td>
<td>Thomas Rusch <a href="https://orcid.org/0000-0002-7773-2096"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Jan de Leeuw [aut],
  Lisha Chen [aut],
  Patrick Mair <a href="https://orcid.org/0000-0003-0100-6511"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-08-17 06:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='alscal'>ALSCAL SMACOF</h2><span id='topic+alscal'></span>

<h3>Description</h3>

<p>An implementation to minimize s-stress by majorization with ratio and interval optimal scaling. Uses a repeat loo
</p>


<h3>Usage</h3>

<pre><code class='language-R'>alscal(
  delta,
  type = "ratio",
  weightmat,
  init = NULL,
  ndim = 2,
  acc = 1e-06,
  itmax = 10000,
  verbose = FALSE,
  principal = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="alscal_+3A_delta">delta</code></td>
<td>
<p>dist object or a symmetric, numeric data.frame or matrix of distances</p>
</td></tr>
<tr><td><code id="alscal_+3A_type">type</code></td>
<td>
<p>what type of MDS to fit. Currently one of &quot;ratio&quot; or &quot;interval&quot;. Default is &quot;ratio&quot;.</p>
</td></tr>
<tr><td><code id="alscal_+3A_weightmat">weightmat</code></td>
<td>
<p>a matrix of finite weights</p>
</td></tr>
<tr><td><code id="alscal_+3A_init">init</code></td>
<td>
<p>starting configuration</p>
</td></tr>
<tr><td><code id="alscal_+3A_ndim">ndim</code></td>
<td>
<p>dimension of the configuration; defaults to 2</p>
</td></tr>
<tr><td><code id="alscal_+3A_acc">acc</code></td>
<td>
<p>numeric accuracy of the iteration. Default is 1e-6.</p>
</td></tr>
<tr><td><code id="alscal_+3A_itmax">itmax</code></td>
<td>
<p>maximum number of iterations. Default is 10000.</p>
</td></tr>
<tr><td><code id="alscal_+3A_verbose">verbose</code></td>
<td>
<p>should iteration output be printed; if &gt; 1 then yes</p>
</td></tr>
<tr><td><code id="alscal_+3A_principal">principal</code></td>
<td>
<p>If ‘TRUE’, principal axis transformation is applied to the final configuration</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a 'smacofP' object (inheriting from 'smacofB', see <code><a href="smacof.html#topic+smacofSym">smacofSym</a></code>). It is a list with the components
</p>

<ul>
<li><p> delta: Observed untransformed dissimilarities
</p>
</li>
<li><p> tdelta: Observed explicitly transformed (squared) dissimilarities, normalized
</p>
</li>
<li><p> dhat: Explicitly transformed dissimilarities (dhats), optimally scaled and normalized 
</p>
</li>
<li><p> confdist: Configuration dissimilarities
</p>
</li>
<li><p> conf: Matrix of fitted configuration
</p>
</li>
<li><p> stress: Default stress  (stress 1; sqrt of explicitly normalized stress)
</p>
</li>
<li><p> spp: Stress per point
</p>
</li>
<li><p> ndim: Number of dimensions
</p>
</li>
<li><p> model: Name of smacof model
</p>
</li>
<li><p> niter: Number of iterations
</p>
</li>
<li><p> nobj: Number of objects
</p>
</li>
<li><p> type: Type of MDS model
</p>
</li>
<li><p> weightmat: weighting matrix as supplied 
</p>
</li>
<li><p> stress.m: Default stress (stress-1^2)
</p>
</li>
<li><p> tweightmat: transformed weighting matrix (here NULL)
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+rStressMin">rStressMin</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dis&lt;-smacof::kinshipdelta
res&lt;-alscal(as.matrix(dis),type="interval",itmax=1000)
res
summary(res)
plot(res)

</code></pre>

<hr>
<h2 id='apStressMin'>Approximate Power Stress SMACOF</h2><span id='topic+apStressMin'></span><span id='topic+apowerstressMin'></span><span id='topic+apostmds'></span><span id='topic+apstressMin'></span><span id='topic+apstressmds'></span>

<h3>Description</h3>

<p>An implementation to minimize power stress by majorization with ratio or interval optimal scaling. Usually more accurate but slower than 'powerStressFast'. Uses a repeat loop.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>apStressMin(
  delta,
  kappa = 1,
  lambda = 1,
  nu = 1,
  type = "ratio",
  weightmat = 1 - diag(nrow(delta)),
  init = NULL,
  ndim = 2,
  acc = 1e-06,
  itmax = 10000,
  verbose = FALSE,
  principal = FALSE
)

apowerstressMin(
  delta,
  kappa = 1,
  lambda = 1,
  nu = 1,
  type = "ratio",
  weightmat = 1 - diag(nrow(delta)),
  init = NULL,
  ndim = 2,
  acc = 1e-06,
  itmax = 10000,
  verbose = FALSE,
  principal = FALSE
)

apostmds(
  delta,
  kappa = 1,
  lambda = 1,
  nu = 1,
  type = "ratio",
  weightmat = 1 - diag(nrow(delta)),
  init = NULL,
  ndim = 2,
  acc = 1e-06,
  itmax = 10000,
  verbose = FALSE,
  principal = FALSE
)

apstressMin(
  delta,
  kappa = 1,
  lambda = 1,
  nu = 1,
  type = "ratio",
  weightmat = 1 - diag(nrow(delta)),
  init = NULL,
  ndim = 2,
  acc = 1e-06,
  itmax = 10000,
  verbose = FALSE,
  principal = FALSE
)

apstressmds(
  delta,
  kappa = 1,
  lambda = 1,
  nu = 1,
  type = "ratio",
  weightmat = 1 - diag(nrow(delta)),
  init = NULL,
  ndim = 2,
  acc = 1e-06,
  itmax = 10000,
  verbose = FALSE,
  principal = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="apStressMin_+3A_delta">delta</code></td>
<td>
<p>dist object or a symmetric, numeric data.frame or matrix of distances</p>
</td></tr>
<tr><td><code id="apStressMin_+3A_kappa">kappa</code></td>
<td>
<p>power of the transformation of the fitted distances; defaults to 1</p>
</td></tr>
<tr><td><code id="apStressMin_+3A_lambda">lambda</code></td>
<td>
<p>the power of the transformation of the proximities; defaults to 1</p>
</td></tr>
<tr><td><code id="apStressMin_+3A_nu">nu</code></td>
<td>
<p>the power of the transformation for weightmat; defaults to 1</p>
</td></tr>
<tr><td><code id="apStressMin_+3A_type">type</code></td>
<td>
<p>what type of MDS to fit. Only &quot;ratio&quot; currently.</p>
</td></tr>
<tr><td><code id="apStressMin_+3A_weightmat">weightmat</code></td>
<td>
<p>a binary matrix of finite nonegative weights.</p>
</td></tr>
<tr><td><code id="apStressMin_+3A_init">init</code></td>
<td>
<p>starting configuration</p>
</td></tr>
<tr><td><code id="apStressMin_+3A_ndim">ndim</code></td>
<td>
<p>dimension of the configuration; defaults to 2</p>
</td></tr>
<tr><td><code id="apStressMin_+3A_acc">acc</code></td>
<td>
<p>numeric accuracy of the iteration. Default is 1e-6.</p>
</td></tr>
<tr><td><code id="apStressMin_+3A_itmax">itmax</code></td>
<td>
<p>maximum number of iterations. Default is 10000.</p>
</td></tr>
<tr><td><code id="apStressMin_+3A_verbose">verbose</code></td>
<td>
<p>should iteration output be printed; if &gt; 1 then yes</p>
</td></tr>
<tr><td><code id="apStressMin_+3A_principal">principal</code></td>
<td>
<p>If 'TRUE', principal axis transformation is applied to the final configuration</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a 'smacofP' object (inheriting from 'smacofB', see <code><a href="smacof.html#topic+smacofSym">smacofSym</a></code>). It is a list with the components
</p>

<ul>
<li><p> delta: Observed, untransformed dissimilarities
</p>
</li>
<li><p> tdelta: Observed explicitly transformed dissimilarities, normalized
</p>
</li>
<li><p> dhat: Explicitly transformed dissimilarities (dhats), optimally scaled and normalized 
</p>
</li>
<li><p> confdist: Configuration dissimilarities
</p>
</li>
<li><p> conf: Matrix of fitted configuration
</p>
</li>
<li><p> stress: Default stress  (stress 1; sqrt of explicitly normalized stress)
</p>
</li>
<li><p> spp: Stress per point 
</p>
</li>
<li><p> ndim: Number of dimensions
</p>
</li>
<li><p> model: Name of smacof model
</p>
</li>
<li><p> niter: Number of iterations
</p>
</li>
<li><p> nobj: Number of objects
</p>
</li>
<li><p> type: Type of MDS model 
</p>
</li>
<li><p> weightmat: weighting matrix as supplied 
</p>
</li>
<li><p> stress.m: Default stress (stress-1^2)
</p>
</li>
<li><p> tweightmat: transformed weightingmatrix (here weightmat^nu)
</p>
</li></ul>



<h3>Note</h3>

<p>Internally we calculate the approximation parameters upsilon=nu+2*lambda*(1-(1/kappa)) and tau=lambda/kappa. They are not output.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dis&lt;-smacof::kinshipdelta
res&lt;-apStressMin(as.matrix(dis),kappa=2,lambda=1.5,itmax=1000)
res
summary(res)
plot(res)
plot(res,"Shepard")
plot(res,"transplot")

</code></pre>

<hr>
<h2 id='BankingCrisesDistances'>Banking Crises Distances</h2><span id='topic+BankingCrisesDistances'></span>

<h3>Description</h3>

<p>Matrix of Jaccard distances between 70 countries (Hungary and Greece were combined to be the same observation) based on their binary time series of having had a banking crises in a year from 1800 to 2010 or not. See data(bankingCrises) in package Ecdat for more info. The last column is Reinhart &amp; Rogoffs classification as a low (3), middle- (2) or high-income country (1).
</p>


<h3>Format</h3>

<p>A 69 x 70 matrix.
</p>


<h3>Source</h3>

<p>data(bankingCrises) in library(Ecdat)
</p>

<hr>
<h2 id='bcmds'>Box-Cox MDS</h2><span id='topic+bcmds'></span><span id='topic+bcStressMin'></span><span id='topic+bcstressMin'></span><span id='topic+boxcoxmds'></span>

<h3>Description</h3>

<p>This function minimizes the Box-Cox Stress of Chen &amp; Buja (2013) via gradient descent. This is a ratio metric scaling method. The transformations are not straightforward to interpret but mu is associated with fitted distances in the configuration and lambda with the dissimilarities. Concretely for fitted distances (attraction part) it is BC_mu+lambda(d(X)) and for the repulsion part it is delta^lambdaBC_mu(d(X)) with BC being the one-parameter Box Cox transformation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bcmds(
  delta,
  mu = 1,
  lambda = 1,
  rho = 0,
  ndim = 2,
  itmax = 2000,
  init = NULL,
  verbose = 0,
  addD0 = 1e-04,
  principal = FALSE
)

bcStressMin(
  delta,
  mu = 1,
  lambda = 1,
  rho = 0,
  ndim = 2,
  itmax = 2000,
  init = NULL,
  verbose = 0,
  addD0 = 1e-04,
  principal = FALSE
)

bcstressMin(
  delta,
  mu = 1,
  lambda = 1,
  rho = 0,
  ndim = 2,
  itmax = 2000,
  init = NULL,
  verbose = 0,
  addD0 = 1e-04,
  principal = FALSE
)

boxcoxmds(
  delta,
  mu = 1,
  lambda = 1,
  rho = 0,
  ndim = 2,
  itmax = 2000,
  init = NULL,
  verbose = 0,
  addD0 = 1e-04,
  principal = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bcmds_+3A_delta">delta</code></td>
<td>
<p>dissimilarity or distance matrix, dissimilarity or distance data frame or 'dist' object</p>
</td></tr>
<tr><td><code id="bcmds_+3A_mu">mu</code></td>
<td>
<p>mu parameter. Should be 0 or larger for everything working ok. If mu&lt;0 it works but I find the MDS model is strange and normalized stress tends towards 0 regardless of fit. Use normalized stress at your own risk in that case.</p>
</td></tr>
<tr><td><code id="bcmds_+3A_lambda">lambda</code></td>
<td>
<p>lambda parameter. Must be larger than 0.</p>
</td></tr>
<tr><td><code id="bcmds_+3A_rho">rho</code></td>
<td>
<p>the rho parameter, power for the weights (the easiest).</p>
</td></tr>
<tr><td><code id="bcmds_+3A_ndim">ndim</code></td>
<td>
<p>the dimension of the configuration</p>
</td></tr>
<tr><td><code id="bcmds_+3A_itmax">itmax</code></td>
<td>
<p>number of optimizing iterations, defaults to 2000.</p>
</td></tr>
<tr><td><code id="bcmds_+3A_init">init</code></td>
<td>
<p>initial configuration. If NULL a classical scaling solution is used.</p>
</td></tr>
<tr><td><code id="bcmds_+3A_verbose">verbose</code></td>
<td>
<p>prints progress if &gt; 3.</p>
</td></tr>
<tr><td><code id="bcmds_+3A_addd0">addD0</code></td>
<td>
<p>a small number that's added for D(X)=0 for numerical evaluation of worst fit (numerical reasons, see details). If addD0=0 the normalized stress for mu!=0 and mu+lambda!=0 is correct, but will give useless normalized stress for mu=0 or mu+lambda!=0.</p>
</td></tr>
<tr><td><code id="bcmds_+3A_principal">principal</code></td>
<td>
<p>If 'TRUE', principal axis transformation is applied to the final configuration</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For numerical reasons with certain parameter combinations, the normalized stress uses a configuration as worst result where every d(X) is 0+addD0. The same number is not added to the delta so there is a small inaccuracy of the normalized stress (but negligible if min(delta)&gt;&gt;addD0). Also, for mu&lt;0 or mu+lambda&lt;0 the normalization cannot generally be trusted (in the worst case of D(X)=0 one would have an 0^(-a)).
</p>


<h3>Value</h3>

<p>an object of class 'bcmds' (also inherits from 'smacofP'). It is a list with the components
</p>

<ul>
<li><p> delta: Observed, untransformed dissimilarities
</p>
</li>
<li><p> tdelta: Observed explicitly transformed dissimilarities, normalized
</p>
</li>
<li><p> dhat: Explicitly transformed dissimilarities (dhats)
</p>
</li>
<li><p> confdist: Configuration dissimilarities
</p>
</li>
<li><p> conf: Matrix of fitted configuration
</p>
</li>
<li><p> stress: Default stress  (stress 1; sqrt of explicitly normalized stress)
</p>
</li>
<li><p> ndim: Number of dimensions
</p>
</li>
<li><p> model: Name of MDS model
</p>
</li>
<li><p> type: Must be &quot;ratio&quot; here. 
</p>
</li>
<li><p> niter: Number of iterations
</p>
</li>
<li><p> nobj: Number of objects
</p>
</li>
<li><p> pars: hyperparameter vector theta
</p>
</li>
<li><p> weightmat:  delta^rho
</p>
</li>
<li><p> parameters, pars, theta: The parameters supplied
</p>
</li>
<li><p> call the call
</p>
</li></ul>

<p>and some additional components
</p>

<ul>
<li><p> stress.m: default stress is the explicitly normalized stress on the normalized, transformed dissimilarities
</p>
</li>
<li><p> mu: mu parameter (for attraction)
</p>
</li>
<li><p> lambda: lambda parameter (for repulsion)
</p>
</li>
<li><p> rho: rho parameter (for weights) 
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Lisha Chen &amp; Thomas Rusch
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dis&lt;-smacof::kinshipdelta
res&lt;-bcmds(dis,mu=2,lambda=1.5,rho=0)
res
summary(res)
plot(res)

</code></pre>

<hr>
<h2 id='bcsdistance'>Calculating the blended chi square distance matrix between n vectors.</h2><span id='topic+bcsdistance'></span>

<h3>Description</h3>

<p>The pairwise blended chi-distance of two vectors x and y is sqrt(sum(((x[i]-y[i])^2)/(2*(ax[i]+by[i])))), with originally a in [0,1] and b=1-a as in Lindsay (1994) (but we allow any non-negative a and b). The function calculates this for all pairs of rows of a matrix or data frame x.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bcsdistance(x, a = 0.5, b = 1 - a)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bcsdistance_+3A_x">x</code></td>
<td>
<p>an n times p numeric matrix or data frame. Note that the valeus of x must be non-negative.</p>
</td></tr>
<tr><td><code id="bcsdistance_+3A_a">a</code></td>
<td>
<p>first blending weight. Must be non-negative and should be in [0,1] if a blended chi-square distance as in Lindsay (1994) is sought. Defaults to 0.5.</p>
</td></tr>
<tr><td><code id="bcsdistance_+3A_b">b</code></td>
<td>
<p>second blending weight. Must be non-negative and should be 1-a if a blended chi-square distance as in Lindsay (1994) is sought. Defaults to 1-a.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a symmetric n times n matrix of pairwise blended chi-square distance (between rows of x) with 0 in the main diagonal. It is an object of class distance and matrix with attributes &quot;method&quot;, &quot;type&quot; and &quot;par&quot;, the latter returning the a and b values.
</p>

<hr>
<h2 id='biplotmds.smacofP'>S3 method for smacofP objects</h2><span id='topic+biplotmds.smacofP'></span>

<h3>Description</h3>

<p>S3 method for smacofP objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'smacofP'
biplotmds(object, extvar, scale = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="biplotmds.smacofP_+3A_object">object</code></td>
<td>
<p>An object of class smacofP</p>
</td></tr>
<tr><td><code id="biplotmds.smacofP_+3A_extvar">extvar</code></td>
<td>
<p>Data frame with external variables.</p>
</td></tr>
<tr><td><code id="biplotmds.smacofP_+3A_scale">scale</code></td>
<td>
<p>if 'TRUE' external variables are standardized internally.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If a model for individual differences is provided, the external
variables are regressed on the group stimulus space
configurations. For objects returned from 'biplotmds' we use the plot method in
<code><a href="smacof.html#topic+biplotmds">biplotmds</a></code>. In the biplot called with plot() only the relative length of the
vectors and their direction matters. Using the vecscale argument in plot() the
user can control for the relative length of the vectors. If
'vecscale = NULL', the 'vecscale()' function from the 'candisc'
package is used which tries to automatically calculate the scale
factor so that the vectors approximately fill the same space as
the configuration. In this method vecscale should usually be smaller than the one used in smacof
by a factor of 0.1.
</p>


<h3>Value</h3>

<p>Returns an object belonging to classes 'mlm' and 'mdsbi'. See 'lm' for details.
R2vec: Vector containing the R2 values.
See also <code><a href="smacof.html#topic+biplotmds">biplotmds</a></code> for the plot method.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## see smacof::biplotmds for more
res &lt;- powerStressMin(morse,kappa=0.5,lambda=2)
fitbi &lt;- biplotmds(res, morsescales[,2:3])
plot(fitbi, main = "MDS Biplot", vecscale = 0.03)

</code></pre>

<hr>
<h2 id='bootmds.smacofP'>MDS Bootstrap for smacofP objects</h2><span id='topic+bootmds.smacofP'></span>

<h3>Description</h3>

<p>Performs a bootstrap on an MDS solution. It works for derived dissimilarities only, i.e. generated by the call dist(data). The original data matrix needs to be provided, as well as the type of dissimilarity measure used to compute the input dissimilarities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'smacofP'
bootmds(
  object,
  data,
  method.dat = "pearson",
  nrep = 100,
  alpha = 0.05,
  verbose = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bootmds.smacofP_+3A_object">object</code></td>
<td>
<p>Object of class smacofP if used as method or another object inheriting from smacofB (needs to be called directly as bootmds.smacofP then).</p>
</td></tr>
<tr><td><code id="bootmds.smacofP_+3A_data">data</code></td>
<td>
<p>Initial data (before dissimilarity computation).</p>
</td></tr>
<tr><td><code id="bootmds.smacofP_+3A_method.dat">method.dat</code></td>
<td>
<p>Dissimilarity computation used as MDS input. This must be one of &quot;pearson&quot;, &quot;spearman&quot;, &quot;kendall&quot;, &quot;euclidean&quot;, &quot;maximum&quot;, &quot;manhattan&quot;, &quot;canberra&quot;, &quot;binary&quot;.</p>
</td></tr>
<tr><td><code id="bootmds.smacofP_+3A_nrep">nrep</code></td>
<td>
<p>Number of bootstrap replications.</p>
</td></tr>
<tr><td><code id="bootmds.smacofP_+3A_alpha">alpha</code></td>
<td>
<p>Alpha level for condfidence ellipsoids.</p>
</td></tr>
<tr><td><code id="bootmds.smacofP_+3A_verbose">verbose</code></td>
<td>
<p>If 'TRUE', bootstrap index is printed out.</p>
</td></tr>
<tr><td><code id="bootmds.smacofP_+3A_...">...</code></td>
<td>
<p>Additional arguments needed for dissimilarity computation as specified in <code><a href="smacof.html#topic+sim2diss">sim2diss</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In order to examine the stability solution of an MDS, a bootstrap on the raw data can be performed. This results in confidence ellipses in the configuration plot. The ellipses are returned as list which allows users to produce (and further customize) the plot by hand. See <code><a href="smacof.html#topic+bootmds">bootmds</a></code> for more.
</p>


<h3>Value</h3>

<p>An object of class 'smacofboot', see <code><a href="smacof.html#topic+bootmds">bootmds</a></code>. With values 
</p>

<ul>
<li><p> cov: Covariances for ellipse computation
</p>
</li>
<li><p> bootconf: Configurations bootstrap samples
</p>
</li>
<li><p> stressvec: Bootstrap stress values
</p>
</li>
<li><p> bootci: Stress bootstrap percentile confidence interval
</p>
</li>
<li><p> spp: Stress per point (based on stress.en) 
</p>
</li>
<li><p> stab: Stability coefficient
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>##see ?smacof::bootmds for more 
data &lt;- na.omit(smacof::PVQ40[,1:5])
diss &lt;- dist(t(data))   ## Euclidean distances
fit &lt;- rStressMin(diss,r=0.5,itmax=1000) ## 2D ratio MDS
set.seed(123)
resboot &lt;- bootmds(fit, data, method.dat = "euclidean", nrep = 10) #run for more nrep
resboot
plot(resboot) #see ?smacof::bootmds for more on the plot method

fit2 &lt;- powerStressMin(diss,kappa=1.5,lambda=1.5,itmax=1000) ## 2D power stress MDS
set.seed(123)
resboot2 &lt;- bootmds(fit2, data, method.dat = "euclidean", nrep = 10)
plot(resboot)

</code></pre>

<hr>
<h2 id='clca'>Curvilinear Component Analysis (CLCA)</h2><span id='topic+clca'></span>

<h3>Description</h3>

<p>A wrapper to run curvilinear component analysis via <code><a href="ProjectionBasedClustering.html#topic+CCA">CCA</a></code> and returning a 'smacofP' object. Note this functionality is rather rudimentary.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clca(
  delta,
  Epochs = 20,
  alpha0 = 0.5,
  lambda0,
  ndim = 2,
  weightmat = 1 - diag(nrow(delta)),
  init = NULL,
  acc = 1e-06,
  itmax = 10000,
  verbose = 0,
  method = "euclidean",
  principal = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="clca_+3A_delta">delta</code></td>
<td>
<p>dist object or a symmetric, numeric data.frame or matrix of distances.</p>
</td></tr>
<tr><td><code id="clca_+3A_epochs">Epochs</code></td>
<td>
<p>Scalar; gives the number of passes through the data.</p>
</td></tr>
<tr><td><code id="clca_+3A_alpha0">alpha0</code></td>
<td>
<p>(scalar) initial step size, 0.5 by default</p>
</td></tr>
<tr><td><code id="clca_+3A_lambda0">lambda0</code></td>
<td>
<p>the boundary/neighbourhood parameter(s) (called lambda_y in the original paper). It is supposed to be a numeric scalar. It defaults to the 90% quantile of delta.</p>
</td></tr>
<tr><td><code id="clca_+3A_ndim">ndim</code></td>
<td>
<p>dimension of the configuration; defaults to 2</p>
</td></tr>
<tr><td><code id="clca_+3A_weightmat">weightmat</code></td>
<td>
<p>not used</p>
</td></tr>
<tr><td><code id="clca_+3A_init">init</code></td>
<td>
<p>starting configuration, not used</p>
</td></tr>
<tr><td><code id="clca_+3A_acc">acc</code></td>
<td>
<p>numeric accuracy of the iteration; not used</p>
</td></tr>
<tr><td><code id="clca_+3A_itmax">itmax</code></td>
<td>
<p>maximum number of iterations. Not used.</p>
</td></tr>
<tr><td><code id="clca_+3A_verbose">verbose</code></td>
<td>
<p>should iteration output be printed; not used</p>
</td></tr>
<tr><td><code id="clca_+3A_method">method</code></td>
<td>
<p>Distance calculation; currently not used.</p>
</td></tr>
<tr><td><code id="clca_+3A_principal">principal</code></td>
<td>
<p>If 'TRUE', principal axis transformation is applied to the final configuration</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This implements CCA as in Demartines &amp; Herault (1997). A different take on the ideas of curvilinear compomnent analysis is available in the experimental functions <code><a href="#topic+spmds">spmds</a></code> and <code><a href="#topic+spmds">spmds</a></code>.
</p>


<h3>Value</h3>

<p>a 'smacofP' object. It is a list with the components
</p>

<ul>
<li><p> delta: Observed, untransformed dissimilarities
</p>
</li>
<li><p> tdelta: Observed explicitly transformed dissimilarities, normalized
</p>
</li>
<li><p> dhat: Explicitly transformed dissimilarities (dhats), optimally scaled and normalized 
</p>
</li>
<li><p> confdist: Configuration dissimilarities
</p>
</li>
<li><p> conf: Matrix of fitted configuration
</p>
</li>
<li><p> stress: Default stress (stress-1; sqrt of explicitly normalized stress)
</p>
</li>
<li><p> spp: Stress per point 
</p>
</li>
<li><p> ndim: Number of dimensions
</p>
</li>
<li><p> model: Name of model
</p>
</li>
<li><p> niter: Number of iterations (training length)
</p>
</li>
<li><p> nobj: Number of objects
</p>
</li>
<li><p> type: Type of MDS model. Only ratio here.
</p>
</li>
<li><p> weightmat: weighting matrix as supplied
</p>
</li>
<li><p> stress.m: Default stress (stress-1^2)
</p>
</li>
<li><p> tweightmat: transformed weighting matrix; it is weightmat here.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>dis&lt;-smacof::morse
res&lt;-clca(dis,lambda0=0.4)
res
summary(res)
plot(res)

</code></pre>

<hr>
<h2 id='clda'>Curvilinear Distance Analysis (CLDA)</h2><span id='topic+clda'></span>

<h3>Description</h3>

<p>A function to run curvilinear distance analysis via <code><a href="ProjectionBasedClustering.html#topic+CCA">CCA</a></code> and returning a 'smacofP' object. Note this functionality is rather rudimentary.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clda(
  delta,
  Epochs = 20,
  alpha0 = 0.5,
  lambda0,
  ndim = 2,
  weightmat = 1 - diag(nrow(delta)),
  init = NULL,
  acc = 1e-06,
  itmax = 10000,
  verbose = 0,
  method = "euclidean",
  principal = FALSE,
  epsilon,
  k,
  path = "shortest",
  fragmentedOK = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="clda_+3A_delta">delta</code></td>
<td>
<p>dist object or a symmetric, numeric data.frame or matrix of distances. Will be turne dinto geodesci distances.</p>
</td></tr>
<tr><td><code id="clda_+3A_epochs">Epochs</code></td>
<td>
<p>Scalar; gives the number of passes through the data.</p>
</td></tr>
<tr><td><code id="clda_+3A_alpha0">alpha0</code></td>
<td>
<p>(scalar) initial step size, 0.5 by default</p>
</td></tr>
<tr><td><code id="clda_+3A_lambda0">lambda0</code></td>
<td>
<p>the boundary/neighbourhood parameter(s) (called lambda_y in the original paper). It is supposed to be a numeric scalar. It defaults to the 90% quantile of delta.</p>
</td></tr>
<tr><td><code id="clda_+3A_ndim">ndim</code></td>
<td>
<p>dimension of the configuration; defaults to 2</p>
</td></tr>
<tr><td><code id="clda_+3A_weightmat">weightmat</code></td>
<td>
<p>not used</p>
</td></tr>
<tr><td><code id="clda_+3A_init">init</code></td>
<td>
<p>starting configuration, not used</p>
</td></tr>
<tr><td><code id="clda_+3A_acc">acc</code></td>
<td>
<p>numeric accuracy of the iteration; not used</p>
</td></tr>
<tr><td><code id="clda_+3A_itmax">itmax</code></td>
<td>
<p>maximum number of iterations. Not used.</p>
</td></tr>
<tr><td><code id="clda_+3A_verbose">verbose</code></td>
<td>
<p>should iteration output be printed; not used</p>
</td></tr>
<tr><td><code id="clda_+3A_method">method</code></td>
<td>
<p>Distance calculation; currently not used.</p>
</td></tr>
<tr><td><code id="clda_+3A_principal">principal</code></td>
<td>
<p>If 'TRUE', principal axis transformation is applied to the final configuration</p>
</td></tr>
<tr><td><code id="clda_+3A_epsilon">epsilon</code></td>
<td>
<p>Shortest dissimilarity retained.</p>
</td></tr>
<tr><td><code id="clda_+3A_k">k</code></td>
<td>
<p>Number of shortest dissimilarities retained for a point. If both 'epsilon' and 'k' are given, 'epsilon' will be used.</p>
</td></tr>
<tr><td><code id="clda_+3A_path">path</code></td>
<td>
<p>Method used in 'stepacross' to estimate the shortest path, with alternatives '&quot;shortest&quot;' and '&quot;extended&quot;'.</p>
</td></tr>
<tr><td><code id="clda_+3A_fragmentedok">fragmentedOK</code></td>
<td>
<p>What to do if dissimilarity matrix is fragmented. If 'TRUE', analyse the largest connected group, otherwise stop with error.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This implements CLDA as CLCA with geodesic distances. The geodesic distances are calculated via 'vegan::isomapdist', see <code><a href="vegan.html#topic+isomapdist">isomapdist</a></code> for a documentation of what these distances do. 'clda' is just a wrapper for 'clca' applied to the geodesic distances obtained via isomapdist.
</p>


<h3>Value</h3>

<p>a 'smacofP' object. It is a list with the components
</p>

<ul>
<li><p> delta: Observed, untransformed dissimilarities
</p>
</li>
<li><p> tdelta: Observed explicitly transformed dissimilarities, normalized
</p>
</li>
<li><p> dhat: Explicitly transformed dissimilarities (dhats), optimally scaled and normalized 
</p>
</li>
<li><p> confdist: Configuration dissimilarities
</p>
</li>
<li><p> conf: Matrix of fitted configuration
</p>
</li>
<li><p> stress: Default stress (stress-1; sqrt of explicitly normalized stress)
</p>
</li>
<li><p> spp: Stress per point 
</p>
</li>
<li><p> ndim: Number of dimensions
</p>
</li>
<li><p> model: Name of model
</p>
</li>
<li><p> niter: Number of iterations (training length)
</p>
</li>
<li><p> nobj: Number of objects
</p>
</li>
<li><p> type: Type of MDS model. Only ratio here.
</p>
</li>
<li><p> weightmat: weighting matrix as supplied
</p>
</li>
<li><p> stress.m: Default stress (stress-1^2)
</p>
</li>
<li><p> tweightmat: transformed weighting matrix; it is weightmat here.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>dis&lt;-smacof::morse
res&lt;-clda(dis,lambda0=0.4,k=4)
res
summary(res)
plot(res)

</code></pre>

<hr>
<h2 id='cmds'>Classical Scaling</h2><span id='topic+cmds'></span>

<h3>Description</h3>

<p>Classical Scaling
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cmds(Do)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cmds_+3A_do">Do</code></td>
<td>
<p>dissimilarity matrix</p>
</td></tr>
</table>

<hr>
<h2 id='cmdscale'>Wrapper to <code>cmdscale</code> for S3 class</h2><span id='topic+cmdscale'></span>

<h3>Description</h3>

<p>Wrapper to <code>cmdscale</code> for S3 class
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cmdscale(d, k = 2, eig = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cmdscale_+3A_d">d</code></td>
<td>
<p>a distance structure such as that returned by 'dist' or a full symmetric matrix containing the dissimilarities</p>
</td></tr>
<tr><td><code id="cmdscale_+3A_k">k</code></td>
<td>
<p>the maximum dimension of the space which the data are to be represented in</p>
</td></tr>
<tr><td><code id="cmdscale_+3A_eig">eig</code></td>
<td>
<p>indicates whether eigenvalues should be returned. Defaults to TRUE.</p>
</td></tr>
<tr><td><code id="cmdscale_+3A_...">...</code></td>
<td>
<p>additional parameters passed to cmdscale. See <code><a href="#topic+cmdscale">cmdscale</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>overloads stats::cmdscale turns on the liosting and adds slots and class attributes for which there are methods.
</p>


<h3>Value</h3>

<p>Object of class 'cmdscalex' and 'cmdscale' extending <code><a href="#topic+cmdscale">cmdscale</a></code>. This wrapper always returns the results of cmdscale as a list, adds column labels to the $points and adds extra elements (conf=points, delta=d, confdist=dist(conf), dhat=d) and the call to the list, and assigns S3 class 'cmdscalex' and 'cmdscale'.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dis&lt;-as.matrix(smacof::kinshipdelta)
res&lt;-cmdscale(dis)
</code></pre>

<hr>
<h2 id='conf_adjust'>conf_adjust: a function to procrustes adjust two matrices</h2><span id='topic+conf_adjust'></span>

<h3>Description</h3>

<p>conf_adjust: a function to procrustes adjust two matrices
</p>


<h3>Usage</h3>

<pre><code class='language-R'>conf_adjust(conf1, conf2, verbose = FALSE, eps = 1e-12, itmax = 100)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="conf_adjust_+3A_conf1">conf1</code></td>
<td>
<p>reference configuration, a numeric matrix</p>
</td></tr>
<tr><td><code id="conf_adjust_+3A_conf2">conf2</code></td>
<td>
<p>another configuration, a numeric matrix</p>
</td></tr>
<tr><td><code id="conf_adjust_+3A_verbose">verbose</code></td>
<td>
<p>should adjustment be output; default to FALSE</p>
</td></tr>
<tr><td><code id="conf_adjust_+3A_eps">eps</code></td>
<td>
<p>numerical accuracy</p>
</td></tr>
<tr><td><code id="conf_adjust_+3A_itmax">itmax</code></td>
<td>
<p>maximum number of iterations</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with 'ref.conf' being the reference configuration, 'other.conf' the adjusted coniguration and 'comparison.conf' the comparison configuration
</p>

<hr>
<h2 id='doubleCenter'>Double centering of a matrix</h2><span id='topic+doubleCenter'></span>

<h3>Description</h3>

<p>Double centering of a matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>doubleCenter(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="doubleCenter_+3A_x">x</code></td>
<td>
<p>numeric matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the double centered matrix
</p>

<hr>
<h2 id='elscal'>Elastic Scaling  SMACOF</h2><span id='topic+elscal'></span>

<h3>Description</h3>

<p>An implementation to minimize elastic scaling stress by majorization with ratio and interval optimal scaling. Uses a repeat loop.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>elscal(
  delta,
  type = c("ratio", "interval"),
  weightmat,
  init = NULL,
  ndim = 2,
  acc = 1e-06,
  itmax = 10000,
  verbose = FALSE,
  principal = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="elscal_+3A_delta">delta</code></td>
<td>
<p>dist object or a symmetric, numeric data.frame or matrix of distances</p>
</td></tr>
<tr><td><code id="elscal_+3A_type">type</code></td>
<td>
<p>what type of MDS to fit. Currently one of &quot;ratio&quot; and &quot;interval&quot;. Default is &quot;ratio&quot;.</p>
</td></tr>
<tr><td><code id="elscal_+3A_weightmat">weightmat</code></td>
<td>
<p>a matrix of finite weights</p>
</td></tr>
<tr><td><code id="elscal_+3A_init">init</code></td>
<td>
<p>starting configuration</p>
</td></tr>
<tr><td><code id="elscal_+3A_ndim">ndim</code></td>
<td>
<p>dimension of the configuration; defaults to 2</p>
</td></tr>
<tr><td><code id="elscal_+3A_acc">acc</code></td>
<td>
<p>numeric accuracy of the iteration. Default is 1e-6.</p>
</td></tr>
<tr><td><code id="elscal_+3A_itmax">itmax</code></td>
<td>
<p>maximum number of iterations. Default is 10000.</p>
</td></tr>
<tr><td><code id="elscal_+3A_verbose">verbose</code></td>
<td>
<p>should iteration output be printed; if &gt; 1 then yes</p>
</td></tr>
<tr><td><code id="elscal_+3A_principal">principal</code></td>
<td>
<p>If 'TRUE', principal axis transformation is applied to the final configuration</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a 'smacofP' object (inheriting from smacofB, see <code><a href="smacof.html#topic+smacofSym">smacofSym</a></code>). It is a list with the components
</p>

<ul>
<li><p> delta: Observed untransformed dissimilarities
</p>
</li>
<li><p> tdelta: Observed explicitly transformed dissimilarities, normalized
</p>
</li>
<li><p> dhat: Explicitly transformed dissimilarities (dhats), optimally scaled and normalized 
</p>
</li>
<li><p> confdist: Configuration dissimilarities, NOT normalized 
</p>
</li>
<li><p> conf: Matrix of fitted configuration, NOT normalized
</p>
</li>
<li><p> stress: Default stress  (stress 1; sqrt of explicitly normalized stress)
</p>
</li>
<li><p> spp: Stress per point (based on stress.en) 
</p>
</li>
<li><p> ndim: Number of dimensions
</p>
</li>
<li><p> model: Name of smacof model
</p>
</li>
<li><p> niter: Number of iterations
</p>
</li>
<li><p> nobj: Number of objects
</p>
</li>
<li><p> type: Type of MDS model
</p>
</li>
<li><p> weightmat: weighting matrix as supplied
</p>
</li>
<li><p> tweightmat: transformed weighting matrix (here weightmat/delta^2) 
</p>
</li>
<li><p> stress.m: Default stress (stress-1^2)
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+rStressMin">rStressMin</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dis&lt;-smacof::kinshipdelta
res&lt;-elscal(as.matrix(dis),itmax=1000)
res
summary(res)
plot(res)

</code></pre>

<hr>
<h2 id='enorm'>Explicit Normalization
Normalizes distances</h2><span id='topic+enorm'></span>

<h3>Description</h3>

<p>Explicit Normalization
Normalizes distances
</p>


<h3>Usage</h3>

<pre><code class='language-R'>enorm(x, w = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="enorm_+3A_x">x</code></td>
<td>
<p>numeric matrix</p>
</td></tr>
<tr><td><code id="enorm_+3A_w">w</code></td>
<td>
<p>weight</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a constant
</p>

<hr>
<h2 id='icExploreGen'>Exploring initial configurations in an agnostic way</h2><span id='topic+icExploreGen'></span>

<h3>Description</h3>

<p>Allows to user to explore the effect of various starting configurations when fitting an MDS model. This is a bit more general than the icExplore function in smacof, as we allow any PS model to be used as the model is either setup by call or by a prefitted object (for the models in cops and stops we do not have a single UI function which necessitates this). Additionally, one can supply their own configurations and not just random ones.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>icExploreGen(
  object,
  mdscall = NULL,
  conflist,
  nrep = 100,
  ndim,
  returnfit = FALSE,
  min = -5,
  max = 5,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="icExploreGen_+3A_object">object</code></td>
<td>
<p>A fitted object of class 'smacofP', 'smacofB' or 'smacof'. If supplied this takes precedence over the call argument. If given this is added to the output and may be the optimal one.</p>
</td></tr>
<tr><td><code id="icExploreGen_+3A_mdscall">mdscall</code></td>
<td>
<p>Alternatively to a fitted object, one can pass a syntactically valid call for any of the MDS functions cops, stops or smacof that find a configuration (not the ones that do parameter selection like pcops or stops). If object and call is given, object takes precedence.</p>
</td></tr>
<tr><td><code id="icExploreGen_+3A_conflist">conflist</code></td>
<td>
<p>Optional list of starting configurations.</p>
</td></tr>
<tr><td><code id="icExploreGen_+3A_nrep">nrep</code></td>
<td>
<p>If conflist is not supplied, how many random starting configurations should be used.</p>
</td></tr>
<tr><td><code id="icExploreGen_+3A_ndim">ndim</code></td>
<td>
<p>Dimensions of target space.</p>
</td></tr>
<tr><td><code id="icExploreGen_+3A_returnfit">returnfit</code></td>
<td>
<p>Should all fitted MDS be returned. If FALSE (default) none is returned.</p>
</td></tr>
<tr><td><code id="icExploreGen_+3A_min">min</code></td>
<td>
<p>lower bound for the uniform distribution to sample from</p>
</td></tr>
<tr><td><code id="icExploreGen_+3A_max">max</code></td>
<td>
<p>upper bound for the uniform distribution to sample from</p>
</td></tr>
<tr><td><code id="icExploreGen_+3A_verbose">verbose</code></td>
<td>
<p>If &gt;0 prints the fitting progress.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If no configuration list is supplied, then nrep configurations are simulated. They are drawn from a ndim-dimensional uniform distribution with minimum min and maximum max. We recommend to use the route via supplying a fitted model as these are typically starting from a Torgerson configuration and are likely quite good.
</p>


<h3>Value</h3>

<p>an object of class 'icexplore', see <code><a href="smacof.html#topic+icExplore">icExplore</a></code> for more. There is a plot method in package 'smacof'.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
dis&lt;-smacof::kinshipdelta

## Version 1: Using a fitted object (recommended)
res1&lt;-rStressMin(delta=dis,type="ordinal",itmax=100)
resm&lt;-icExploreGen(res1,nrep=5)

## Version 2: Using a call object and supplying conflist
conflist&lt;-list(res1$init,jitter(res1$init,1),jitter(res1$init,1),jitter(res1$init,1))
c1 &lt;- call("smds",delta=dis,tau=0.2,itmax=100)
resm&lt;-icExploreGen(mdscall=c1,conflist=conflist,returnfit=TRUE)

plot(resm)

</code></pre>

<hr>
<h2 id='jackmds.smacofP'>MDS Jackknife for smacofP objects</h2><span id='topic+jackmds.smacofP'></span>

<h3>Description</h3>

<p>These methods perform an MDSJackknife and plot the corresponding solution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'smacofP'
jackmds(object, eps = 1e-06, itmax = 100, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="jackmds.smacofP_+3A_object">object</code></td>
<td>
<p>Object of class smacofP if used as method or another object inheriting from smacofB (needs to be called directly as bootmds.smacofP then).</p>
</td></tr>
<tr><td><code id="jackmds.smacofP_+3A_eps">eps</code></td>
<td>
<p>Convergence criterion</p>
</td></tr>
<tr><td><code id="jackmds.smacofP_+3A_itmax">itmax</code></td>
<td>
<p>Maximum number of iterations</p>
</td></tr>
<tr><td><code id="jackmds.smacofP_+3A_verbose">verbose</code></td>
<td>
<p>If 'TRUE', intermediate stress is printed out.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In order to examine the stability solution of an MDS, a Jackknife on the configurations can be performed (see de Leeuw &amp; Meulman, 1986) and plotted. The plot shows the jackknife configurations which are connected to their centroid. In addition, the original configuration (transformed through Procrustes) is plotted. The Jackknife function itself returns also a stability measure (as ratio of between and total variance), a measure for cross validity, and the dispersion around the original smacof solution.
</p>


<h3>Value</h3>

<p>An object of class 'smacofJK', see <code><a href="smacof.html#topic+jackmds">jackmds</a></code>. With values 
</p>

<ul>
<li><p> smacof.conf: Configurations
</p>
</li>
<li><p> jackknife.confboot: An array of n-1 configuration matrices for each Jackknife MDS solution
</p>
</li>
<li><p> comparison.conf: Centroid Jackknife configurations (comparison matrix)
</p>
</li>
<li><p> cross: Cross validity
</p>
</li>
<li><p> stab: Stability coefficient
</p>
</li>
<li><p> disp: Dispersion
</p>
</li>
<li><p> loss: Value of the loss function
</p>
</li>
<li><p> ndim: Number of dimensions
</p>
</li>
<li><p> call: Model call
</p>
</li>
<li><p> niter: Number of iterations
</p>
</li>
<li><p> nobj: Number of objects
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>data &lt;- na.omit(smacof::PVQ40[,1:5])
diss &lt;- dist(t(data))   ## Euclidean distances
fit &lt;- rStressMin(diss,"ratio",r=0.5,itmax=1000) ## 2D ratio MDS

res.jk &lt;- jackmds(fit)
plot(res.jk, col.p = "black", col.l = "gray")
plot(res.jk, hclpar = list(c = 80, l = 40))
plot(res.jk, hclpar = list(c = 80, l = 40), plot.lines = FALSE)

</code></pre>

<hr>
<h2 id='lmds'>Local MDS</h2><span id='topic+lmds'></span>

<h3>Description</h3>

<p>This function minimizes the Local MDS Stress of Chen &amp; Buja (2006) via gradient descent. This is a ratio metric scaling method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lmds(
  delta,
  init = NULL,
  ndim = 2,
  k = 2,
  tau = 1,
  itmax = 5000,
  verbose = 0,
  principal = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lmds_+3A_delta">delta</code></td>
<td>
<p>dissimilarity or distance matrix, dissimilarity or distance data frame or 'dist' object</p>
</td></tr>
<tr><td><code id="lmds_+3A_init">init</code></td>
<td>
<p>initial configuration. If NULL a classical scaling solution is used.</p>
</td></tr>
<tr><td><code id="lmds_+3A_ndim">ndim</code></td>
<td>
<p>the dimension of the configuration</p>
</td></tr>
<tr><td><code id="lmds_+3A_k">k</code></td>
<td>
<p>the k neighbourhood parameter</p>
</td></tr>
<tr><td><code id="lmds_+3A_tau">tau</code></td>
<td>
<p>the penalty parameter (suggested to be in [0,1])</p>
</td></tr>
<tr><td><code id="lmds_+3A_itmax">itmax</code></td>
<td>
<p>number of optimizing iterations, defaults to 5000.</p>
</td></tr>
<tr><td><code id="lmds_+3A_verbose">verbose</code></td>
<td>
<p>prints info if &gt; 0 and progress if &gt; 1.</p>
</td></tr>
<tr><td><code id="lmds_+3A_principal">principal</code></td>
<td>
<p>If 'TRUE', principal axis transformation is applied to the final configuration</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that k and tau are not independent. It is possible for normalized stress to become negative if the tau and k combination is so that the absolute repulsion for the found configuration dominates the local stress substantially less than the repulsion term does for the solution of D(X)=Delta, so that the local stress difference between the found solution and perfect solution is nullified. This can typically be avoided if tau is between 0 and 1. If not, set k and or tau to a smaller value.
</p>


<h3>Value</h3>

<p>an object of class 'lmds' (also inherits from 'smacofP'). See <code><a href="#topic+powerStressMin">powerStressMin</a></code>. It is a list with the components as in power stress
</p>

<ul>
<li><p> delta: Observed, untransformed dissimilarities
</p>
</li>
<li><p> tdelta: Observed explicitly transformed dissimilarities, normalized
</p>
</li>
<li><p> dhat: Explicitly transformed dissimilarities (dhats)
</p>
</li>
<li><p> confdist: Configuration dissimilarities
</p>
</li>
<li><p> conf: Matrix of fitted configuration
</p>
</li>
<li><p> stress: Default stress  (stress 1; sqrt of explicitly normalized stress)
</p>
</li>
<li><p> ndim: Number of dimensions
</p>
</li>
<li><p> model: Name of MDS model
</p>
</li>
<li><p> type: Is &quot;ratio&quot; here. 
</p>
</li>
<li><p> niter: Number of iterations
</p>
</li>
<li><p> nobj: Number of objects
</p>
</li>
<li><p> pars: explicit transformations hyperparameter vector theta
</p>
</li>
<li><p> weightmat: 1-diagonal matrix (for compatibility with smacof classes)
</p>
</li>
<li><p> parameters, pars, theta: The parameters supplied
</p>
</li>
<li><p> call the call
</p>
</li></ul>

<p>and some additional components
</p>

<ul>
<li><p> stress.m: default stress is the explicitly normalized stress on the normalized, transformed dissimilarities
</p>
</li>
<li><p> tau: tau parameter
</p>
</li>
<li><p> k: k parameter
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Lisha Chen &amp; Thomas Rusch
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dis&lt;-smacof::kinshipdelta
res&lt;- lmds(dis,k=2,tau=0.1)
res
summary(res)
plot(res)

</code></pre>

<hr>
<h2 id='mkBmat'>Auxfunction1</h2><span id='topic+mkBmat'></span>

<h3>Description</h3>

<p>only used internally
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mkBmat(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mkBmat_+3A_x">x</code></td>
<td>
<p>matrix</p>
</td></tr>
</table>

<hr>
<h2 id='mkPower'>Take matrix to a power</h2><span id='topic+mkPower'></span>

<h3>Description</h3>

<p>Take matrix to a power
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mkPower(x, r)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mkPower_+3A_x">x</code></td>
<td>
<p>matrix</p>
</td></tr>
<tr><td><code id="mkPower_+3A_r">r</code></td>
<td>
<p>numeric (power)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix
</p>

<hr>
<h2 id='multiscale'>Multiscale SMACOF</h2><span id='topic+multiscale'></span>

<h3>Description</h3>

<p>An implementation for maximum likelihood MDS aka multiscale that minimizes the multiscale stress by majorization with ratio and interval optimal scaling. Uses a repeat loop.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>multiscale(
  delta,
  type = c("ratio", "interval"),
  weightmat,
  init = NULL,
  ndim = 2,
  acc = 1e-06,
  itmax = 10000,
  verbose = FALSE,
  kappa = 0.1,
  principal = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="multiscale_+3A_delta">delta</code></td>
<td>
<p>dist object or a symmetric, numeric data.frame or matrix of distances. Warning: these will get transformed to the log scale, so make sure that log(delta)&gt;=0.</p>
</td></tr>
<tr><td><code id="multiscale_+3A_type">type</code></td>
<td>
<p>what optimal scaling type of MDS to fit. Currently one of &quot;ratio&quot; or &quot;interval&quot;. Default is &quot;ratio&quot;.</p>
</td></tr>
<tr><td><code id="multiscale_+3A_weightmat">weightmat</code></td>
<td>
<p>a matrix of finite weights</p>
</td></tr>
<tr><td><code id="multiscale_+3A_init">init</code></td>
<td>
<p>starting configuration</p>
</td></tr>
<tr><td><code id="multiscale_+3A_ndim">ndim</code></td>
<td>
<p>dimension of the configuration; defaults to 2</p>
</td></tr>
<tr><td><code id="multiscale_+3A_acc">acc</code></td>
<td>
<p>numeric accuracy of the iteration. Default is 1e-6.</p>
</td></tr>
<tr><td><code id="multiscale_+3A_itmax">itmax</code></td>
<td>
<p>maximum number of iterations. Default is 10000.</p>
</td></tr>
<tr><td><code id="multiscale_+3A_verbose">verbose</code></td>
<td>
<p>should iteration output be printed; if &gt; 1 then yes</p>
</td></tr>
<tr><td><code id="multiscale_+3A_kappa">kappa</code></td>
<td>
<p>As this is not exactly multiscale but an r-stress approximation, we have multiscale only for kappa-&gt;0. This argument can therefore be used to make the approximation more accurate by making it smaller. Default is 0.1.</p>
</td></tr>
<tr><td><code id="multiscale_+3A_principal">principal</code></td>
<td>
<p>If ‘TRUE’, principal axis transformation is applied to the final configuration</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a 'smacofP' object (inheriting from 'smacofB', see <code><a href="smacof.html#topic+smacofSym">smacofSym</a></code>). It is a list with the components
</p>

<ul>
<li><p> delta: Observed dissimilarities
</p>
</li>
<li><p> tdelta: Observed explicitly transformed (log) dissimilarities, normalized
</p>
</li>
<li><p> dhat: Explicitly transformed dissimilarities (dhats), optimally scaled and normalized 
</p>
</li>
<li><p> confdist: Configuration dissimilarities, NOT normalized 
</p>
</li>
<li><p> conf: Matrix of fitted configuration, NOT normalized
</p>
</li>
<li><p> stress: Default stress  (stress 1; sqrt of explicitly normalized stress)
</p>
</li>
<li><p> spp: Stress per point
</p>
</li>
<li><p> ndim: Number of dimensions
</p>
</li>
<li><p> model: Name of smacof model
</p>
</li>
<li><p> niter: Number of iterations
</p>
</li>
<li><p> nobj: Number of objects
</p>
</li>
<li><p> type: Type of MDS model
</p>
</li>
<li><p> weightmat: weighting matrix 
</p>
</li>
<li><p> stress.m: Default stress (stress-1^2)
</p>
</li></ul>



<h3>Warning</h3>

<p>The input delta will internally get transformed to the log scale, so make sure that log(delta)&gt;=0 otherwise it throws an error. It is often a good idea to use 1+delta in this case.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rStressMin">rStressMin</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dis&lt;-smacof::kinshipdelta
res&lt;-multiscale(as.matrix(dis),type="interval",itmax=1000)
res
summary(res)
plot(res)

</code></pre>

<hr>
<h2 id='multistart'>Multistart MDS function</h2><span id='topic+multistart'></span>

<h3>Description</h3>

<p>For different starting configurations, this function fits a series of PS models given in object or call and returns the one with the lowest stress overall. The starting configuirations can be supplied or are generated internally.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>multistart(
  object,
  mdscall = NULL,
  ndim = 2,
  conflist,
  nstarts = 10,
  return.all = FALSE,
  verbose = TRUE,
  min = -5,
  max = 5
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="multistart_+3A_object">object</code></td>
<td>
<p>A fitted object of class 'smacofP', 'smacofB' or 'smacof'. If supplied this takes precedence over the call argument. If given this is added to the output and may be the optimal one.</p>
</td></tr>
<tr><td><code id="multistart_+3A_mdscall">mdscall</code></td>
<td>
<p>Alternatively to a fitted object, one can pass a syntactically valid call for any of the MDS functions cops, stops or smacof that find a configuration (not the ones that do parameter selection like pcops or stops). If object and call is given, object takes precedence.</p>
</td></tr>
<tr><td><code id="multistart_+3A_ndim">ndim</code></td>
<td>
<p>Dimensions of target space.</p>
</td></tr>
<tr><td><code id="multistart_+3A_conflist">conflist</code></td>
<td>
<p>Optional list of starting configurations.</p>
</td></tr>
<tr><td><code id="multistart_+3A_nstarts">nstarts</code></td>
<td>
<p>If conflist is not supplied, how many random starting configurations should be used.</p>
</td></tr>
<tr><td><code id="multistart_+3A_return.all">return.all</code></td>
<td>
<p>Should all fitted MDS be returned. If FALSE (default) only the optimal one is returned.</p>
</td></tr>
<tr><td><code id="multistart_+3A_verbose">verbose</code></td>
<td>
<p>If &gt;0 prints the fitting progress.</p>
</td></tr>
<tr><td><code id="multistart_+3A_min">min</code></td>
<td>
<p>lower bound for the uniform distribution to sample from</p>
</td></tr>
<tr><td><code id="multistart_+3A_max">max</code></td>
<td>
<p>upper bound for the uniform distribution to sample from</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If no configuration list is supplied, then nstarts configurations are simulated. They are drawn from a ndim-dimesnional uniform distribution with minimum min and maximum max. We recommend to use the route via supplying a fitted model as these are typically starting from a Torgerson configuration and are likely quite good.    
</p>
<p>One can simply extract $best and save that and work with it right away.
</p>


<h3>Value</h3>

<p>if 'return.all=FALSE', a list with the best fitted model as '$best' (minimal badness-of-fit of all fitted models) and '$stressvec' the stresses of all models. If 'return.all=TRUE' a list with slots
</p>

<ul>
<li><p> best: The object resulting from the fit that had the overall lowest objective function value (usually stress)
</p>
</li>
<li><p> stressvec: The vector of objective function values
</p>
</li>
<li><p> models: A list of all the fitted objects.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>dis&lt;-smacof::kinshipdelta

## Version 1: Using a fitted object (recommended)
res1&lt;-rStressMin(delta=dis,type="ordinal",itmax=100)
resm&lt;-multistart(res1,nstarts=2)
## best model
res2&lt;-resm$best
#it's starting configuration
res2$init

## Version 2: Using a call object and supplying conflist
conflist&lt;-list(res2$init,jitter(res2$init,1))
c1 &lt;- call("rstressMin",delta=dis,type="ordinal",itmax=100)
resm&lt;-multistart(mdscall=c1,conflist=conflist,return.all=TRUE)

</code></pre>

<hr>
<h2 id='pdist'>Squared p-distances</h2><span id='topic+pdist'></span>

<h3>Description</h3>

<p>Squared p-distances
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pdist(x, p)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pdist_+3A_x">x</code></td>
<td>
<p>numeric matrix</p>
</td></tr>
<tr><td><code id="pdist_+3A_p">p</code></td>
<td>
<p>p&gt;0 the Minkoswki distance</p>
</td></tr>
</table>


<h3>Value</h3>

<p>squared Minkowski distance matrix
</p>

<hr>
<h2 id='permtest.smacofP'>Permutation test for smacofP objects</h2><span id='topic+permtest.smacofP'></span>

<h3>Description</h3>

<p>Performs a permutation test on an MDS solution. It works with a smacofP object alone and also for derived dissimilarities, i.e. generated by the call dist(data). The original data matrix needs to be provided, as well as the type of dissimilarity measure used to compute the input dissimilarities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'smacofP'
permtest(
  object,
  data,
  method.dat = "pearson",
  nrep = 100,
  verbose = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="permtest.smacofP_+3A_object">object</code></td>
<td>
<p>Object of class smacofP if used as method or another object inheriting from smacof (needs to be called directly as permtest.smacofP then).</p>
</td></tr>
<tr><td><code id="permtest.smacofP_+3A_data">data</code></td>
<td>
<p>Optional: Initial data; if provided permutations are performed on the data matrix (see details)</p>
</td></tr>
<tr><td><code id="permtest.smacofP_+3A_method.dat">method.dat</code></td>
<td>
<p>Dissimilarity computation used as MDS input. This must be one of &quot;pearson&quot;, &quot;spearman&quot;, &quot;kendall&quot;, &quot;euclidean&quot;, &quot;maximum&quot;, &quot;manhattan&quot;, &quot;canberra&quot;, &quot;binary&quot;. If data is provided, then this must be provided as well.</p>
</td></tr>
<tr><td><code id="permtest.smacofP_+3A_nrep">nrep</code></td>
<td>
<p>Number of permutations.</p>
</td></tr>
<tr><td><code id="permtest.smacofP_+3A_verbose">verbose</code></td>
<td>
<p>If TRUE, bootstrap index is printed out.</p>
</td></tr>
<tr><td><code id="permtest.smacofP_+3A_...">...</code></td>
<td>
<p>Additional arguments needed for dissimilarity computation as specified in <code><a href="smacof.html#topic+sim2diss">sim2diss</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This routine permutes m dissimilarity values, where m is the number of lower diagonal
elements in the corresponding dissimilarity matrix. For each sample a symmetric, nonmetric SMACOF of
dimension 'ndim' is computed and the stress values are stored in ‘stressvec’. Using the fitted
stress value, the p-value is computed. Subsequently, the empirical cumulative distribution function
can be plotted using the plot method.
</p>
<p>If the MDS fit provided on derived proximities of a data matrix,
this matrix can be passed to the ‘permtest’ function.
Consequently, the data matrix is subject to permutations. The
proximity measure used for MDS fit has to match the one used for
the permutation test. If a correlation similarity is provided, it
is converted internally into a dissimilarity using 'sim2diss' with
corresponding arguments passed to the ... argument.
</p>


<h3>Value</h3>

<p>An object of class 'smacofPerm', see <code><a href="smacof.html#topic+permtest">permtest</a></code> for details and methods. It has values
</p>

<ul>
<li><p> stressvec: Vector containing the stress values of the permutation samples
</p>
</li>
<li><p> stress.obs: Stress (observed sample) 
</p>
</li>
<li><p> pval: Resulting p-value
</p>
</li>
<li><p> call: Model call
</p>
</li>
<li><p> nrep: Number of permutations
</p>
</li>
<li><p> nobj: Number of objects
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>##see ?smacof::permtest for more
## permuting the dissimilarity matrix (full)
#' data(kinshipdelta)
fitkin &lt;- rStressMin(kinshipdelta, ndim = 2, r=0.5,itmax=10) #use higher itmax
set.seed(222)
res.perm &lt;- permtest(fitkin,nrep=5) #use higher nrep in reality
res.perm
plot(res.perm)
## permuting the data matrix
GOPdtm[GOPdtm &gt; 1] &lt;- 1     ## use binary version
diss1 &lt;- dist(t(GOPdtm[,1:10]), method = "binary")  ## Jaccard distance
fitgop1 &lt;- alscal(diss1,type="interval",itmax=10) #use higher itmax
fitgop1
set.seed(123)
permtest(fitgop1, GOPdtm[,1:10], nrep = 5, method.dat = "binary")
</code></pre>

<hr>
<h2 id='plot.smacofP'>S3 plot method for smacofP objects</h2><span id='topic+plot.smacofP'></span>

<h3>Description</h3>

<p>S3 plot method for smacofP objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'smacofP'
plot(
  x,
  plot.type = "confplot",
  plot.dim = c(1, 2),
  bubscale = 1,
  col,
  label.conf = list(label = TRUE, pos = 3, col = 1, cex = 0.8),
  hull.conf = list(hull = FALSE, col = 1, lwd = 1, ind = NULL),
  shepard.x = NULL,
  identify = FALSE,
  type = "p",
  cex = 0.5,
  pch = 20,
  asp = 1,
  main,
  xlab,
  ylab,
  xlim,
  ylim,
  col.hist = NULL,
  legend = TRUE,
  legpos,
  loess = TRUE,
  shepard.lin = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.smacofP_+3A_x">x</code></td>
<td>
<p>an object of class smacofP</p>
</td></tr>
<tr><td><code id="plot.smacofP_+3A_plot.type">plot.type</code></td>
<td>
<p>String indicating which type of plot to be produced: &quot;confplot&quot;, &quot;resplot&quot;, &quot;Shepard&quot;, &quot;stressplot&quot;,&quot;transplot&quot;, &quot;bubbleplot&quot; (see details)</p>
</td></tr>
<tr><td><code id="plot.smacofP_+3A_plot.dim">plot.dim</code></td>
<td>
<p>dimensions to be plotted in confplot; defaults to c(1, 2)</p>
</td></tr>
<tr><td><code id="plot.smacofP_+3A_bubscale">bubscale</code></td>
<td>
<p>Scaling factor (size) for the bubble plot</p>
</td></tr>
<tr><td><code id="plot.smacofP_+3A_col">col</code></td>
<td>
<p>vector of colors for the points</p>
</td></tr>
<tr><td><code id="plot.smacofP_+3A_label.conf">label.conf</code></td>
<td>
<p>List with arguments for plotting the labels of the configurations in a configuration plot (logical value whether to plot labels or not, label position, label color)</p>
</td></tr>
<tr><td><code id="plot.smacofP_+3A_hull.conf">hull.conf</code></td>
<td>
<p>Option to add convex hulls to a configuration plot. Hull index needs to be provided.</p>
</td></tr>
<tr><td><code id="plot.smacofP_+3A_shepard.x">shepard.x</code></td>
<td>
<p>Shepard plot only: original data (e.g. correlation matrix) can be provided for plotting on x-axis</p>
</td></tr>
<tr><td><code id="plot.smacofP_+3A_identify">identify</code></td>
<td>
<p>If 'TRUE', the 'identify()' function is called internally that allows to add configuration labels by mouse click</p>
</td></tr>
<tr><td><code id="plot.smacofP_+3A_type">type</code></td>
<td>
<p>What type of plot should be drawn (see also 'plot')</p>
</td></tr>
<tr><td><code id="plot.smacofP_+3A_cex">cex</code></td>
<td>
<p>Symbol size.</p>
</td></tr>
<tr><td><code id="plot.smacofP_+3A_pch">pch</code></td>
<td>
<p>Plot symbol</p>
</td></tr>
<tr><td><code id="plot.smacofP_+3A_asp">asp</code></td>
<td>
<p>Aspect ratio; defaults to 1 so distances between x and y are represented accurately; can lead to slighlty weird looking plots if the variance on one axis is much smaller than on the other axis; use NA if the standard type of R plot is wanted where the ylim and xlim arguments define the aspect ratio - but then the distances seen are no longer accurate</p>
</td></tr>
<tr><td><code id="plot.smacofP_+3A_main">main</code></td>
<td>
<p>plot title</p>
</td></tr>
<tr><td><code id="plot.smacofP_+3A_xlab">xlab</code></td>
<td>
<p>label of x axis</p>
</td></tr>
<tr><td><code id="plot.smacofP_+3A_ylab">ylab</code></td>
<td>
<p>label of y axis</p>
</td></tr>
<tr><td><code id="plot.smacofP_+3A_xlim">xlim</code></td>
<td>
<p>scale of x axis</p>
</td></tr>
<tr><td><code id="plot.smacofP_+3A_ylim">ylim</code></td>
<td>
<p>scale of y axis</p>
</td></tr>
<tr><td><code id="plot.smacofP_+3A_col.hist">col.hist</code></td>
<td>
<p>Color of the borders of the histogram.</p>
</td></tr>
<tr><td><code id="plot.smacofP_+3A_legend">legend</code></td>
<td>
<p>Flag whether legends should be drawn for plots that have legends</p>
</td></tr>
<tr><td><code id="plot.smacofP_+3A_legpos">legpos</code></td>
<td>
<p>Position of legend in plots with legends</p>
</td></tr>
<tr><td><code id="plot.smacofP_+3A_loess">loess</code></td>
<td>
<p>if TRUE a loess fit (by Tukey's rescending M-Estimator) of configuration distances explained by delta  is added to the Shepard plot</p>
</td></tr>
<tr><td><code id="plot.smacofP_+3A_shepard.lin">shepard.lin</code></td>
<td>
<p>Shepard plot only: if TRUE the Shepard plot is linearized so d^kappa~delta^lambda. If FALSE d~delta^lambda</p>
</td></tr>
<tr><td><code id="plot.smacofP_+3A_...">...</code></td>
<td>
<p>Further plot arguments passed: see 'plot.smacof' and 'plot' for detailed information.</p>
</td></tr>
</table>


<h3>Details</h3>


<ul>
<li><p>  Configuration plot (plot.type = &quot;confplot&quot;): Plots the MDS configuration.
</p>
</li>
<li><p> Residual plot (plot.type = &quot;resplot&quot;): Plots the dhats f(T(delta)) against the transformed fitted distances T(d(X)).
</p>
</li>
<li><p> (Linearized) Shepard diagram (plot.type = &quot;Shepard&quot;): Is shep.lin=TRUE a diagram with the transformed observed normalized dissimilarities (T(delta) on x)  against the transformed fitted distance (T(d(X) on y) as well as a loess curve and a regression line corresponding to type (linear without intercept for ratio, linear for interval and isotonic for ordinal). If shep.lin=FALSE it uses the untransformed delta. Note that the regression line corresponds to the optimal scaling results (dhat) only up to a linear transformation. 
</p>
</li>
<li><p> Transformation Plot (plot.type = &quot;transplot&quot;): Diagram with normalized observed dissimilarities (delta, light grey) and the normalized explicitly transformed dissimilarities (T(Delta), darker) against the untransformed fitted distances (d(X)) together with a nonlinear regression curve corresponding to the explicit transformation (fitted power transformation). This is most useful for ratio models with power transformations as the transformations can be read of directly. For other MDS models and stresses, it still gives a quick way to assess how the explicit transformations worked.  
</p>
</li>
<li><p> Stress decomposition plot (plot.type = &quot;stressplot&quot;): Plots the stress contribution in of each observation. Note that it rescales the stress-per-point (SPP) from the corresponding function to percentages (sum is 100). The higher the contribution, the worse the fit.
</p>
</li>
<li><p> Bubble plot (plot.type = &quot;bubbleplot&quot;): Combines the configuration plot with the point stress contribution. The larger the bubbles, the worse the fit.
</p>
</li>
<li><p> histogram (‘plot.type = &quot;histogram&quot;’: gives a weighted histogram of the dissimilarities (weighted with tweightmat if exists else with weightmat). For optional arguments, see ‘wtd.hist’.
</p>
</li></ul>



<h3>Value</h3>

<p>no return value; just plots for class 'smacofP' (see details)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dis&lt;-as.matrix(smacof::kinshipdelta)
res&lt;-powerStressMin(dis)
plot(res)
plot(res,"Shepard")
plot(res,"resplot")
plot(res,"transplot")
plot(res,"stressplot")
plot(res,"bubbleplot")
plot(res,"histogram")
</code></pre>

<hr>
<h2 id='powerStressFast'>Power stress minimization by NEWUOA (nloptr)</h2><span id='topic+powerStressFast'></span>

<h3>Description</h3>

<p>An implementation to minimize power stress by a derivative-free trust region optimization algorithm (NEWUOA). Much faster than majorizing as used in powerStressMin but perhaps less accurate.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>powerStressFast(
  delta,
  kappa = 1,
  lambda = 1,
  nu = 1,
  weightmat = 1 - diag(nrow(delta)),
  init = NULL,
  ndim = 2,
  acc = 1e-06,
  itmax = 10000,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="powerStressFast_+3A_delta">delta</code></td>
<td>
<p>dist object or a symmetric, numeric data.frame or matrix of distances</p>
</td></tr>
<tr><td><code id="powerStressFast_+3A_kappa">kappa</code></td>
<td>
<p>power of the transformation of the fitted distances; defaults to 1</p>
</td></tr>
<tr><td><code id="powerStressFast_+3A_lambda">lambda</code></td>
<td>
<p>the power of the transformation of the proximities; defaults to 1</p>
</td></tr>
<tr><td><code id="powerStressFast_+3A_nu">nu</code></td>
<td>
<p>the power of the transformation for weightmat; defaults to 1</p>
</td></tr>
<tr><td><code id="powerStressFast_+3A_weightmat">weightmat</code></td>
<td>
<p>a matrix of finite weights</p>
</td></tr>
<tr><td><code id="powerStressFast_+3A_init">init</code></td>
<td>
<p>starting configuration</p>
</td></tr>
<tr><td><code id="powerStressFast_+3A_ndim">ndim</code></td>
<td>
<p>dimension of the configuration; defaults to 2</p>
</td></tr>
<tr><td><code id="powerStressFast_+3A_acc">acc</code></td>
<td>
<p>The smallest value of the trust region radius that is allowed. If not defined, then 1e-6 will be used.</p>
</td></tr>
<tr><td><code id="powerStressFast_+3A_itmax">itmax</code></td>
<td>
<p>maximum number of iterations. Default is 10000.</p>
</td></tr>
<tr><td><code id="powerStressFast_+3A_verbose">verbose</code></td>
<td>
<p>should iteration output be printed; if &gt; 1 then yes</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a 'smacofP' object (inheriting from 'smacofB', see <code><a href="smacof.html#topic+smacofSym">smacofSym</a></code>). It is a list with the components
</p>

<ul>
<li><p> delta: Observed dissimilarities, not normalized
</p>
</li>
<li><p> obsdiss: Observed dissimilarities, normalized 
</p>
</li>
<li><p> confdist: Configuration dissimilarities, NOT normalized 
</p>
</li>
<li><p> conf: Matrix of fitted configuration, NOT normalized
</p>
</li>
<li><p> stress: Default stress (stress 1, square root of the explicitly normalized stress on the normalized, transformed dissimilarities)  
</p>
</li>
<li><p> spp: Stress per point (based on stress.en) 
</p>
</li>
<li><p> ndim: Number of dimensions
</p>
</li>
<li><p> model: Name of smacof model
</p>
</li>
<li><p> niter: Number of iterations
</p>
</li>
<li><p> nobj: Number of objects
</p>
</li>
<li><p> type: Type of MDS model
</p>
</li></ul>

<p>and some additional components
</p>

<ul>
<li><p> gamma: Empty
</p>
</li>
<li><p> stress.m: default stress for the COPS and STOP. Defaults to the explicitly normalized stress on the normalized, transformed dissimilarities
</p>
</li>
<li><p> stress.en: explicitly stress on the normalized, transformed dissimilarities and normalized transformed distances
</p>
</li>
<li><p> deltaorig: observed, untransformed dissimilarities
</p>
</li>
<li><p> weightmat: weighting matrix 
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="smacof.html#topic+smacofSym">smacofSym</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dis&lt;-smacof::kinshipdelta
res&lt;-powerStressFast(as.matrix(dis),kappa=2,lambda=1.5)
res
summary(res)
plot(res)

</code></pre>

<hr>
<h2 id='powerStressMin'>Power Stress SMACOF</h2><span id='topic+powerStressMin'></span><span id='topic+powerstressMin'></span><span id='topic+postmds'></span><span id='topic+pstressMin'></span><span id='topic+pStressMin'></span><span id='topic+pstressmds'></span>

<h3>Description</h3>

<p>An implementation to minimize power stress by majorization with ratio or interval optimal scaling. Usually more accurate but slower than powerStressFast. Uses a repeat loop.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>powerStressMin(
  delta,
  kappa = 1,
  lambda = 1,
  nu = 1,
  type = "ratio",
  weightmat = 1 - diag(nrow(delta)),
  init = NULL,
  ndim = 2,
  acc = 1e-06,
  itmax = 10000,
  verbose = FALSE,
  principal = FALSE
)

powerstressMin(
  delta,
  kappa = 1,
  lambda = 1,
  nu = 1,
  type = "ratio",
  weightmat = 1 - diag(nrow(delta)),
  init = NULL,
  ndim = 2,
  acc = 1e-06,
  itmax = 10000,
  verbose = FALSE,
  principal = FALSE
)

postmds(
  delta,
  kappa = 1,
  lambda = 1,
  nu = 1,
  type = "ratio",
  weightmat = 1 - diag(nrow(delta)),
  init = NULL,
  ndim = 2,
  acc = 1e-06,
  itmax = 10000,
  verbose = FALSE,
  principal = FALSE
)

pstressMin(
  delta,
  kappa = 1,
  lambda = 1,
  nu = 1,
  type = "ratio",
  weightmat = 1 - diag(nrow(delta)),
  init = NULL,
  ndim = 2,
  acc = 1e-06,
  itmax = 10000,
  verbose = FALSE,
  principal = FALSE
)

pStressMin(
  delta,
  kappa = 1,
  lambda = 1,
  nu = 1,
  type = "ratio",
  weightmat = 1 - diag(nrow(delta)),
  init = NULL,
  ndim = 2,
  acc = 1e-06,
  itmax = 10000,
  verbose = FALSE,
  principal = FALSE
)

pstressmds(
  delta,
  kappa = 1,
  lambda = 1,
  nu = 1,
  type = "ratio",
  weightmat = 1 - diag(nrow(delta)),
  init = NULL,
  ndim = 2,
  acc = 1e-06,
  itmax = 10000,
  verbose = FALSE,
  principal = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="powerStressMin_+3A_delta">delta</code></td>
<td>
<p>dist object or a symmetric, numeric data.frame or matrix of distances</p>
</td></tr>
<tr><td><code id="powerStressMin_+3A_kappa">kappa</code></td>
<td>
<p>power of the transformation of the fitted distances; defaults to 1</p>
</td></tr>
<tr><td><code id="powerStressMin_+3A_lambda">lambda</code></td>
<td>
<p>the power of the transformation of the proximities; defaults to 1</p>
</td></tr>
<tr><td><code id="powerStressMin_+3A_nu">nu</code></td>
<td>
<p>the power of the transformation for weightmat; defaults to 1</p>
</td></tr>
<tr><td><code id="powerStressMin_+3A_type">type</code></td>
<td>
<p>what type of MDS to fit. One of &quot;ratio&quot; or &quot;interval&quot;. Default is &quot;ratio&quot;.</p>
</td></tr>
<tr><td><code id="powerStressMin_+3A_weightmat">weightmat</code></td>
<td>
<p>a matrix of finite weights or dist object</p>
</td></tr>
<tr><td><code id="powerStressMin_+3A_init">init</code></td>
<td>
<p>starting configuration</p>
</td></tr>
<tr><td><code id="powerStressMin_+3A_ndim">ndim</code></td>
<td>
<p>dimension of the configuration; defaults to 2</p>
</td></tr>
<tr><td><code id="powerStressMin_+3A_acc">acc</code></td>
<td>
<p>numeric accuracy of the iteration. Default is 1e-6.</p>
</td></tr>
<tr><td><code id="powerStressMin_+3A_itmax">itmax</code></td>
<td>
<p>maximum number of iterations. Default is 10000.</p>
</td></tr>
<tr><td><code id="powerStressMin_+3A_verbose">verbose</code></td>
<td>
<p>should iteration output be printed; if &gt; 1 then yes</p>
</td></tr>
<tr><td><code id="powerStressMin_+3A_principal">principal</code></td>
<td>
<p>If 'TRUE', principal axis transformation is applied to the final configuration</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a 'smacofP' object (inheriting from 'smacofB', see <code><a href="smacof.html#topic+smacofSym">smacofSym</a></code>). It is a list with the components
</p>

<ul>
<li><p> delta: Observed, untransformed dissimilarities
</p>
</li>
<li><p> tdelta: Observed explicitly transformed dissimilarities, normalized
</p>
</li>
<li><p> dhat: Explicitly transformed dissimilarities (dhats), optimally scaled and normalized 
</p>
</li>
<li><p> confdist: Configuration dissimilarities
</p>
</li>
<li><p> conf: Matrix of fitted configuration
</p>
</li>
<li><p> stress: Default stress  (stress 1; sqrt of explicitly normalized stress)
</p>
</li>
<li><p> spp: Stress per point 
</p>
</li>
<li><p> ndim: Number of dimensions
</p>
</li>
<li><p> model: Name of smacof model
</p>
</li>
<li><p> niter: Number of iterations
</p>
</li>
<li><p> nobj: Number of objects
</p>
</li>
<li><p> type: Type of MDS model 
</p>
</li>
<li><p> weightmat: weighting matrix as supplied 
</p>
</li>
<li><p> stress.m: Default stress (stress-1^2)
</p>
</li>
<li><p> tweightmat: transformed weighthingmatrix (here weightmat^nu)
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="smacof.html#topic+smacofSym">smacofSym</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dis&lt;-smacof::kinshipdelta
res&lt;-powerStressMin(dis,type="ratio",kappa=2,lambda=1.5,itmax=1000)
res
summary(res)
plot(res)

</code></pre>

<hr>
<h2 id='procruster'>procruster: a procrustes function</h2><span id='topic+procruster'></span>

<h3>Description</h3>

<p>procruster: a procrustes function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>procruster(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="procruster_+3A_x">x</code></td>
<td>
<p>numeric matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix
</p>

<hr>
<h2 id='rpowerStressMin'>Restricted Power Stress SMACOF</h2><span id='topic+rpowerStressMin'></span><span id='topic+rpowerstressMin'></span><span id='topic+rpostmds'></span><span id='topic+rpstressMin'></span><span id='topic+rpStressMin'></span><span id='topic+rpstressmds'></span>

<h3>Description</h3>

<p>An implementation to minimize restricted power stress by majorization with ratio or interval optimal scaling. Restricted means that the same power is used for both dissimilarities and fitted distances. Uses a repeat loop.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rpowerStressMin(
  delta,
  expo = 1,
  nu = 1,
  type = "ratio",
  weightmat,
  init = NULL,
  ndim = 2,
  acc = 1e-06,
  itmax = 10000,
  verbose = FALSE,
  principal = FALSE
)

rpowerstressMin(
  delta,
  expo = 1,
  nu = 1,
  type = "ratio",
  weightmat,
  init = NULL,
  ndim = 2,
  acc = 1e-06,
  itmax = 10000,
  verbose = FALSE,
  principal = FALSE
)

rpostmds(
  delta,
  expo = 1,
  nu = 1,
  type = "ratio",
  weightmat,
  init = NULL,
  ndim = 2,
  acc = 1e-06,
  itmax = 10000,
  verbose = FALSE,
  principal = FALSE
)

rpstressMin(
  delta,
  expo = 1,
  nu = 1,
  type = "ratio",
  weightmat,
  init = NULL,
  ndim = 2,
  acc = 1e-06,
  itmax = 10000,
  verbose = FALSE,
  principal = FALSE
)

rpStressMin(
  delta,
  expo = 1,
  nu = 1,
  type = "ratio",
  weightmat,
  init = NULL,
  ndim = 2,
  acc = 1e-06,
  itmax = 10000,
  verbose = FALSE,
  principal = FALSE
)

rpstressmds(
  delta,
  expo = 1,
  nu = 1,
  type = "ratio",
  weightmat,
  init = NULL,
  ndim = 2,
  acc = 1e-06,
  itmax = 10000,
  verbose = FALSE,
  principal = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rpowerStressMin_+3A_delta">delta</code></td>
<td>
<p>dist object or a symmetric, numeric data.frame or matrix of distances</p>
</td></tr>
<tr><td><code id="rpowerStressMin_+3A_expo">expo</code></td>
<td>
<p>power of the transformation of the fitted distances and dissimilarities; defaults to 1</p>
</td></tr>
<tr><td><code id="rpowerStressMin_+3A_nu">nu</code></td>
<td>
<p>the power of the transformation for weightmat; defaults to 1</p>
</td></tr>
<tr><td><code id="rpowerStressMin_+3A_type">type</code></td>
<td>
<p>what type of MDS to fit. One of &quot;ratio&quot; or &quot;interval&quot;. Default is &quot;ratio&quot;.</p>
</td></tr>
<tr><td><code id="rpowerStressMin_+3A_weightmat">weightmat</code></td>
<td>
<p>a matrix of finite weights</p>
</td></tr>
<tr><td><code id="rpowerStressMin_+3A_init">init</code></td>
<td>
<p>starting configuration</p>
</td></tr>
<tr><td><code id="rpowerStressMin_+3A_ndim">ndim</code></td>
<td>
<p>dimension of the configuration; defaults to 2</p>
</td></tr>
<tr><td><code id="rpowerStressMin_+3A_acc">acc</code></td>
<td>
<p>numeric accuracy of the iteration. Default is 1e-6.</p>
</td></tr>
<tr><td><code id="rpowerStressMin_+3A_itmax">itmax</code></td>
<td>
<p>maximum number of iterations. Default is 10000.</p>
</td></tr>
<tr><td><code id="rpowerStressMin_+3A_verbose">verbose</code></td>
<td>
<p>should iteration output be printed; if &gt; 1 then yes</p>
</td></tr>
<tr><td><code id="rpowerStressMin_+3A_principal">principal</code></td>
<td>
<p>If 'TRUE', principal axis transformation is applied to the final configuration</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a 'smacofP' object (inheriting from 'smacofB', see <code><a href="smacof.html#topic+smacofSym">smacofSym</a></code>). It is a list with the components
</p>

<ul>
<li><p> delta: Observed, untransformed dissimilarities
</p>
</li>
<li><p> tdelta: Observed explicitly transformed dissimilarities, normalized
</p>
</li>
<li><p> dhat: Explicitly transformed dissimilarities (dhats), optimally scaled and normalized 
</p>
</li>
<li><p> confdist: Configuration dissimilarities
</p>
</li>
<li><p> conf: Matrix of fitted configuration
</p>
</li>
<li><p> stress: Default stress  (stress 1; sqrt of explicitly normalized stress)
</p>
</li>
<li><p> spp: Stress per point 
</p>
</li>
<li><p> ndim: Number of dimensions
</p>
</li>
<li><p> model: Name of smacof model
</p>
</li>
<li><p> niter: Number of iterations
</p>
</li>
<li><p> nobj: Number of objects
</p>
</li>
<li><p> type: Type of MDS model 
</p>
</li>
<li><p> weightmat: weighting matrix as supplied 
</p>
</li>
<li><p> stress.m: Default stress (stress-1^2)
</p>
</li>
<li><p> tweightmat: transformed weighthing matrix (here weightmat^nu)
</p>
</li>
<li><p> parameters, pars, theta: The parameter vector of the explicit transformations
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>dis&lt;-smacof::kinshipdelta
res&lt;-rpowerStressMin(as.matrix(dis),expo=1.7,itmax=1000)
res
summary(res)
plot(res)

</code></pre>

<hr>
<h2 id='rStressMin'>R stress SMACOF</h2><span id='topic+rStressMin'></span><span id='topic+rstressMin'></span><span id='topic+rstressmds'></span><span id='topic+rstress'></span>

<h3>Description</h3>

<p>An implementation to minimize r-stress by majorization with ratio, interval and ordinal optimal scaling. Uses a repeat loop.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rStressMin(
  delta,
  r = 0.5,
  type = c("ratio", "interval", "ordinal"),
  ties = "primary",
  weightmat = 1 - diag(nrow(delta)),
  init = NULL,
  ndim = 2,
  acc = 1e-06,
  itmax = 10000,
  verbose = FALSE,
  principal = FALSE
)

rstressMin(
  delta,
  r = 0.5,
  type = c("ratio", "interval", "ordinal"),
  ties = "primary",
  weightmat = 1 - diag(nrow(delta)),
  init = NULL,
  ndim = 2,
  acc = 1e-06,
  itmax = 10000,
  verbose = FALSE,
  principal = FALSE
)

rstressmds(
  delta,
  r = 0.5,
  type = c("ratio", "interval", "ordinal"),
  ties = "primary",
  weightmat = 1 - diag(nrow(delta)),
  init = NULL,
  ndim = 2,
  acc = 1e-06,
  itmax = 10000,
  verbose = FALSE,
  principal = FALSE
)

rstress(
  delta,
  r = 0.5,
  type = c("ratio", "interval", "ordinal"),
  ties = "primary",
  weightmat = 1 - diag(nrow(delta)),
  init = NULL,
  ndim = 2,
  acc = 1e-06,
  itmax = 10000,
  verbose = FALSE,
  principal = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rStressMin_+3A_delta">delta</code></td>
<td>
<p>dist object or a symmetric, numeric data.frame or matrix of distances</p>
</td></tr>
<tr><td><code id="rStressMin_+3A_r">r</code></td>
<td>
<p>power of the transformation of the fitted distances (corresponds to kappa/2 in power stress); defaults to 0.5 for standard stress</p>
</td></tr>
<tr><td><code id="rStressMin_+3A_type">type</code></td>
<td>
<p>what type of MDS to fit. Currently one of &quot;ratio&quot;, &quot;interval&quot; or &quot;ordinal&quot;. Default is &quot;ratio&quot;.</p>
</td></tr>
<tr><td><code id="rStressMin_+3A_ties">ties</code></td>
<td>
<p>the handling of ties for ordinal (nonmetric) MDS. Possible are &quot;primary&quot; (default), &quot;secondary&quot; or &quot;tertiary&quot;.</p>
</td></tr>
<tr><td><code id="rStressMin_+3A_weightmat">weightmat</code></td>
<td>
<p>a matrix of finite weights.</p>
</td></tr>
<tr><td><code id="rStressMin_+3A_init">init</code></td>
<td>
<p>starting configuration</p>
</td></tr>
<tr><td><code id="rStressMin_+3A_ndim">ndim</code></td>
<td>
<p>dimension of the configuration; defaults to 2</p>
</td></tr>
<tr><td><code id="rStressMin_+3A_acc">acc</code></td>
<td>
<p>numeric accuracy of the iteration. Default is 1e-6.</p>
</td></tr>
<tr><td><code id="rStressMin_+3A_itmax">itmax</code></td>
<td>
<p>maximum number of iterations. Default is 10000.</p>
</td></tr>
<tr><td><code id="rStressMin_+3A_verbose">verbose</code></td>
<td>
<p>should iteration output be printed; if &gt; 1 then yes</p>
</td></tr>
<tr><td><code id="rStressMin_+3A_principal">principal</code></td>
<td>
<p>If 'TRUE', principal axis transformation is applied to the final configuration</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a 'smacofP' object (inheriting from 'smacofB', see <code><a href="smacof.html#topic+smacofSym">smacofSym</a></code>). It is a list with the components
</p>

<ul>
<li><p> delta: Observed, untransformed dissimilarities
</p>
</li>
<li><p> tdelta: Observed explicitly transformed dissimilarities, normalized
</p>
</li>
<li><p> dhat: Explicitly transformed dissimilarities (dhats), optimally scaled and normalized 
</p>
</li>
<li><p> confdist: Configuration dissimilarities
</p>
</li>
<li><p> conf: Matrix of fitted configuration
</p>
</li>
<li><p> stress: Default stress  (stress 1; sqrt of explicitly normalized stress)
</p>
</li>
<li><p> spp: Stress per point 
</p>
</li>
<li><p> ndim: Number of dimensions
</p>
</li>
<li><p> model: Name of smacof model
</p>
</li>
<li><p> niter: Number of iterations
</p>
</li>
<li><p> nobj: Number of objects
</p>
</li>
<li><p> type: Type of MDS model
</p>
</li>
<li><p> weightmat: weighting matrix as supplied
</p>
</li>
<li><p> stress.m: Default stress (stress-1^2)
</p>
</li>
<li><p> tweightmat: transformed weighting matrix (here NULL)
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="smacof.html#topic+smacofSym">smacofSym</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dis&lt;-smacof::kinshipdelta
res&lt;-rStressMin(as.matrix(dis),type="ordinal",r=1,itmax=1000)
res
summary(res)
plot(res)

</code></pre>

<hr>
<h2 id='sammon'>Wrapper to <code>sammon</code> for S3 class</h2><span id='topic+sammon'></span>

<h3>Description</h3>

<p>Wrapper to <code>sammon</code> for S3 class
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sammon(d, y = NULL, k = 2, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sammon_+3A_d">d</code></td>
<td>
<p>a distance structure such as that returned by 'dist' or a full symmetric matrix.  Data are assumed to be dissimilarities or relative distances, but must be positive except for self-distance.  This can contain missing values.</p>
</td></tr>
<tr><td><code id="sammon_+3A_y">y</code></td>
<td>
<p>An initial configuration. If NULL, <code><a href="#topic+cmdscale">cmdscale</a></code> is used to provide the classical solution. (If there are missing values in 'd', an initial configuration must be provided.)  This must not have duplicates.</p>
</td></tr>
<tr><td><code id="sammon_+3A_k">k</code></td>
<td>
<p>The dimension of the configuration</p>
</td></tr>
<tr><td><code id="sammon_+3A_...">...</code></td>
<td>
<p>Additional parameters passed to <code>sammon</code>, see <code><a href="#topic+sammon">sammon</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Overloads MASS::sammon and adds new slots and class attributes for which there are methods.
</p>


<h3>Value</h3>

<p>Object of class 'sammonx' inheriting from <code><a href="#topic+sammon">sammon</a></code>. This wrapper adds an extra slot to the list with the call, adds column labels to the $points, adds slots conf=points, delta=d, dhat=normalized dissimilarities, confdist=distance between points in conf, stress.m=stress, stress=sqrt(stress.m) and assigns S3 classes 'sammonx', 'sammon' and 'cmdscalex'.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dis&lt;-as.matrix(smacof::kinshipdelta)
res&lt;-sammon(dis)
</code></pre>

<hr>
<h2 id='sammonmap'>Sammon Mapping SMACOF</h2><span id='topic+sammonmap'></span>

<h3>Description</h3>

<p>An implementation to minimize Sammon stress by majorization with ratio and interval optimal scaling. Uses a repeat loop.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sammonmap(
  delta,
  type = c("ratio", "interval"),
  weightmat,
  init = NULL,
  ndim = 2,
  acc = 1e-06,
  itmax = 10000,
  verbose = FALSE,
  principal = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sammonmap_+3A_delta">delta</code></td>
<td>
<p>dist object or a symmetric, numeric data.frame or matrix of distances</p>
</td></tr>
<tr><td><code id="sammonmap_+3A_type">type</code></td>
<td>
<p>what type of MDS to fit. Currently one of &quot;ratio&quot; and &quot;interval&quot;. Default is &quot;ratio&quot;.</p>
</td></tr>
<tr><td><code id="sammonmap_+3A_weightmat">weightmat</code></td>
<td>
<p>a matrix of finite weights</p>
</td></tr>
<tr><td><code id="sammonmap_+3A_init">init</code></td>
<td>
<p>starting configuration</p>
</td></tr>
<tr><td><code id="sammonmap_+3A_ndim">ndim</code></td>
<td>
<p>dimension of the configuration; defaults to 2</p>
</td></tr>
<tr><td><code id="sammonmap_+3A_acc">acc</code></td>
<td>
<p>numeric accuracy of the iteration. Default is 1e-6.</p>
</td></tr>
<tr><td><code id="sammonmap_+3A_itmax">itmax</code></td>
<td>
<p>maximum number of iterations. Default is 10000.</p>
</td></tr>
<tr><td><code id="sammonmap_+3A_verbose">verbose</code></td>
<td>
<p>should iteration output be printed; if &gt; 1 then yes</p>
</td></tr>
<tr><td><code id="sammonmap_+3A_principal">principal</code></td>
<td>
<p>If 'TRUE', principal axis transformation is applied to the final configuration</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a 'smacofP' object (inheriting from smacofB, see <code><a href="smacof.html#topic+smacofSym">smacofSym</a></code>). It is a list with the components
</p>

<ul>
<li><p> delta: Observed dissimilarities
</p>
</li>
<li><p> tdelta: Observed explicitly transformed dissimilarities, normalized
</p>
</li>
<li><p> dhat: Observed dissimilarities (dhats), optimally scaled and normalized 
</p>
</li>
<li><p> confdist: Configuration dissimilarities
</p>
</li>
<li><p> conf: Matrix of fitted configuration
</p>
</li>
<li><p> stress: Default stress  (stress 1; sqrt of explicitly normalized stress)
</p>
</li>
<li><p> spp: Stress per point (based on stress.en) 
</p>
</li>
<li><p> ndim: Number of dimensions
</p>
</li>
<li><p> model: Name of smacof model
</p>
</li>
<li><p> niter: Number of iterations
</p>
</li>
<li><p> nobj: Number of objects
</p>
</li>
<li><p> type: Type of MDS model
</p>
</li>
<li><p> weightmat: weighting matrix as supplied
</p>
</li>
<li><p> stress.m: default stress (stress-1^2)
</p>
</li>
<li><p> tweightmat: weighting matrix atfer transformation (here weightmat/delta)
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+rStressMin">rStressMin</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dis&lt;-smacof::kinshipdelta
res&lt;-sammonmap(as.matrix(dis),itmax=1000)
res
summary(res)
plot(res)

</code></pre>

<hr>
<h2 id='scale_adjust'>Adjusts a configuration</h2><span id='topic+scale_adjust'></span>

<h3>Description</h3>

<p>Adjusts a configuration
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scale_adjust(conf, ref, scale = c("sd", "std", "proc", "none"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scale_adjust_+3A_conf">conf</code></td>
<td>
<p>a configuration</p>
</td></tr>
<tr><td><code id="scale_adjust_+3A_ref">ref</code></td>
<td>
<p>a reference configuration (only for scale=&quot;proc&quot;)</p>
</td></tr>
<tr><td><code id="scale_adjust_+3A_scale">scale</code></td>
<td>
<p>Scale adjustment. &quot;std&quot; standardizes each column of the configurations to mean=0 and sd=1, &quot;sd&quot; scales the configuration by the maximum standard devation of any column, &quot;proc&quot; adjusts the fitted configuration to the reference</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The scale adjusted configuration.
</p>

<hr>
<h2 id='secularEq'>Secular Equation</h2><span id='topic+secularEq'></span>

<h3>Description</h3>

<p>Secular Equation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>secularEq(a, b)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="secularEq_+3A_a">a</code></td>
<td>
<p>matrix</p>
</td></tr>
<tr><td><code id="secularEq_+3A_b">b</code></td>
<td>
<p>matrix</p>
</td></tr>
</table>

<hr>
<h2 id='smacofx'>smacofx: Flexible multidimensional scaling methods and SMACOF extensions</h2><span id='topic+smacofx'></span>

<h3>Description</h3>

<p>Flexible multidimensional scaling (MDS) methods centered around the Majorization algorithm. The package contains various functions, wrappers, methods and classes for fitting, plotting and displaying a large number of different flexible MDS models such as Torgerson scaling, ratio, interval and nonmetric MDS with majorization, Sammon mapping with ratio and interval optimal scaling, multiscale MDS with ratio and interval optimal scaling, Alscal (s-stress) MDS with ratio and interval optimal scaling, elastic scaling with ratio and interval optimal scaling, r-stress MDS for ratio, interval and nonmetric scaling, power stress for interval and ratio optimal scaling, restricted power-stress with ratio and interval optimal scaling, approximate power-stress with ratio scaling, curvilinear component analysis with ratio, interval and ordinal optimal scaling, power curvilinear component analysis with ratio, interval and ordinal optimal scaling, Box-Cox MDS and local MDS. Some functions are suitably flexible to allow any other sensible combination of explicit power transformations for weights, distances and input proximities with implicit ratio, interval or ordinal optimal scaling of the input proximities. Most functions use a majorization algorithm.
</p>


<h3>Details</h3>

<p>The package provides:
</p>
<p>Models:
</p>

<ul>
<li><p> alscal... ALSCAL (s-stress) MDS with ratio, interval optimal scaling
</p>
</li>
<li><p> elscal.. Elastic scaling MDS with ratio, interval optimal scaling
</p>
</li>
<li><p> multiscale... Multiscale MDSwith ratio, interval optimal scaling
</p>
</li>
<li><p> rstressMin .. R-Stress MDS with ratio, interval, ordinal optimal scaling
</p>
</li>
<li><p> powerStressMin... power stress MDS (POST-MDS) with ratio, interval optimal scaling
</p>
</li>
<li><p> apStressMin... approximate POST-MDS with ratio, interval optimal scaling
</p>
</li>
<li><p> rpowerStressMin... restricted POST-MDS with ratio, interval optimal scaling
</p>
</li>
<li><p> clca ... curvilinear component analysis with ratio, interval, ordinal optimal scaling
</p>
</li>
<li><p> pclca ... power curvilinear component analysis with ratio, interval, ordinal optimal scaling
</p>
</li>
<li><p> bcmds ... Box-Cox MDS with ratio optimal scaling
</p>
</li>
<li><p> lmds... Local MDS with ratio optimal scaling
</p>
</li>
<li><p> sammonmap... Sammon mapping with ratio, interval optimal scaling
</p>
</li></ul>

<p>Classes and Methods: 
The objects are of classes that extend the S3 classes smacof and smacofB. For the objects returned by the high-level functions S3 methods for standard generics were implemented, including print, coef, residuals, summary, plot, plot3dstatic.
Wrappers and convenience functions for the model objects:
</p>

<ul>
<li><p> bootmds ... bootstrapping and MDS model
</p>
</li>
<li><p> biplotmds ... MDS Biplots
</p>
</li>
<li><p> icExploreGen ... Expore initial configurations 
</p>
</li>
<li><p> jackmds ... jackknife for MDS 
</p>
</li>
<li><p> multistart ... multistart function for MDS  
</p>
</li>
<li><p> permtest ... permutation test for MDS
</p>
</li></ul>

<p>Wrappers:
</p>

<ul>
<li><p> cmdscale ... stats::cmdscale but returns an S3 objects to be used with smacof classes 
</p>
</li>
<li><p> sammon... MASS::sammon but returns S3 objects to be used with smacof classes 
</p>
</li></ul>

<p>Authors: Thomas Rusch, Jan de Leeuw, Lisha Chen, Patrick Mair
</p>
<p>Maintainer: Thomas Rusch
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(BankingCrisesDistances)

res&lt;-rStressMin(BankingCrisesDistances[,1:69],type="ordinal",r=2)
res

summary(res)
plot(res)
plot(res,"transplot")
plot(res,"Shepard")

msres&lt;- multistart(res)

res2&lt;-msres$best
permtest(res2)



</code></pre>

<hr>
<h2 id='spmdda'>Sparse (POST-)Multidimensional Distance Analysis (SPMDDA or SMDDA) either as self-organizing or not</h2><span id='topic+spmdda'></span><span id='topic+smdda'></span><span id='topic+so_spmdda'></span><span id='topic+so_smdda'></span>

<h3>Description</h3>

<p>An implementation of a sparsified version of (POST-)MDS by pseudo-majorization with ratio, interval and ordinal optimal scaling for geodesic distances and optional power transformations. This is inspired by curvilinear distance analysis but works differently: It finds an initial weightmatrix where w_ij(X^0)=0 if d_ij(X^0)&gt;tau and fits a POST-MDS with these weights. Then in each successive iteration step, the weightmat is recalculated so that w_ij(X^(n+1))=0 if d_ij(X^(n+1))&gt;tau. Right now the zero weights are not found by the correct optimization, but we're working on that.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spmdda(
  delta,
  lambda = 1,
  kappa = 1,
  nu = 1,
  tau,
  type = "ratio",
  ties = "primary",
  epsilon,
  k,
  path = "shortest",
  fragmentedOK = FALSE,
  weightmat = 1 - diag(nrow(delta)),
  init = NULL,
  ndim = 2,
  acc = 1e-06,
  itmax = 10000,
  verbose = FALSE,
  principal = FALSE
)

smdda(
  delta,
  tau = stats::quantile(delta, 0.9),
  type = c("ratio"),
  ties = "primary",
  epsilon,
  k,
  path = "shortest",
  fragmentedOK = FALSE,
  weightmat = 1 - diag(nrow(delta)),
  init = NULL,
  ndim = 2,
  acc = 1e-06,
  itmax = 10000,
  verbose = FALSE,
  principal = FALSE
)

so_spmdda(
  delta,
  kappa = 1,
  lambda = 1,
  nu = 1,
  tau = max(delta),
  epochs = 10,
  type = c("ratio"),
  ties = "primary",
  epsilon,
  k,
  path = "shortest",
  fragmentedOK = FALSE,
  weightmat = 1 - diag(nrow(delta)),
  init = NULL,
  ndim = 2,
  acc = 1e-06,
  itmax = 10000,
  verbose = FALSE,
  principal = FALSE
)

so_smdda(
  delta,
  tau = max(delta),
  epochs = 10,
  type = c("ratio"),
  ties = "primary",
  epsilon,
  k,
  path = "shortest",
  fragmentedOK = FALSE,
  weightmat = 1 - diag(nrow(delta)),
  init = NULL,
  ndim = 2,
  acc = 1e-06,
  itmax = 10000,
  verbose = FALSE,
  principal = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spmdda_+3A_delta">delta</code></td>
<td>
<p>dist object or a symmetric, numeric data.frame or matrix of distances</p>
</td></tr>
<tr><td><code id="spmdda_+3A_lambda">lambda</code></td>
<td>
<p>exponent of the power transformation of the dissimilarities; defaults to 1, which is also the setup of 'smdda'</p>
</td></tr>
<tr><td><code id="spmdda_+3A_kappa">kappa</code></td>
<td>
<p>exponent of the power transformation of the fitted distances; defaults to 1, which is also the setup of 'smdda'.</p>
</td></tr>
<tr><td><code id="spmdda_+3A_nu">nu</code></td>
<td>
<p>exponent of the power of the weighting matrix; defaults to 1 which is also the setup for 'clca'.</p>
</td></tr>
<tr><td><code id="spmdda_+3A_tau">tau</code></td>
<td>
<p>the boundary/neighbourhood parameter(s) (called lambda in the original paper). For 'spmdda' and 'smdda' it is supposed to be a numeric scalar (if a sequence is supplied the maximum is taken as tau) and all the transformed fitted distances exceeding tau are set to 0 via the weightmat (assignment can change between iterations).  It defaults to the 90% quantile of the enormed (power transformed) geodesic distances of delta. For 'so_pclca' tau is supposed to be either a user supplied decreasing sequence of taus or if a scalar the maximum tau from which a decreasing sequence of taus is generated automatically as 'seq(from=tau,to=tau/epochs,length.out=epochs)' and then used in sequence.</p>
</td></tr>
<tr><td><code id="spmdda_+3A_type">type</code></td>
<td>
<p>what type of MDS to fit. Currently one of &quot;ratio&quot;, &quot;interval&quot; or &quot;ordinal&quot;. Default is &quot;ratio&quot;.</p>
</td></tr>
<tr><td><code id="spmdda_+3A_ties">ties</code></td>
<td>
<p>the handling of ties for ordinal (nonmetric) MDS. Possible are &quot;primary&quot; (default), &quot;secondary&quot; or &quot;tertiary&quot;.</p>
</td></tr>
<tr><td><code id="spmdda_+3A_epsilon">epsilon</code></td>
<td>
<p>Shortest dissimilarity retained.</p>
</td></tr>
<tr><td><code id="spmdda_+3A_k">k</code></td>
<td>
<p>Number of shortest dissimilarities retained for a point. If both 'epsilon' and 'k' are given, 'epsilon' will be used.</p>
</td></tr>
<tr><td><code id="spmdda_+3A_path">path</code></td>
<td>
<p>Method used in 'stepacross' to estimate the shortest path, with alternatives '&quot;shortest&quot;' and '&quot;extended&quot;'.</p>
</td></tr>
<tr><td><code id="spmdda_+3A_fragmentedok">fragmentedOK</code></td>
<td>
<p>What to do if dissimilarity matrix is fragmented. If 'TRUE', analyse the largest connected group, otherwise stop with error.</p>
</td></tr>
<tr><td><code id="spmdda_+3A_weightmat">weightmat</code></td>
<td>
<p>a matrix of finite weights.</p>
</td></tr>
<tr><td><code id="spmdda_+3A_init">init</code></td>
<td>
<p>starting configuration</p>
</td></tr>
<tr><td><code id="spmdda_+3A_ndim">ndim</code></td>
<td>
<p>dimension of the configuration; defaults to 2</p>
</td></tr>
<tr><td><code id="spmdda_+3A_acc">acc</code></td>
<td>
<p>numeric accuracy of the iteration. Default is 1e-6.</p>
</td></tr>
<tr><td><code id="spmdda_+3A_itmax">itmax</code></td>
<td>
<p>maximum number of iterations. Default is 10000.</p>
</td></tr>
<tr><td><code id="spmdda_+3A_verbose">verbose</code></td>
<td>
<p>should iteration output be printed; if &gt; 1 then yes</p>
</td></tr>
<tr><td><code id="spmdda_+3A_principal">principal</code></td>
<td>
<p>If 'TRUE', principal axis transformation is applied to the final configuration</p>
</td></tr>
<tr><td><code id="spmdda_+3A_epochs">epochs</code></td>
<td>
<p>for 'so_pclca' and tau being scalar, it gives the number of passes through the data. The sequence of taus created is 'seq(tau,tau/epochs,length.out=epochs)'. If tau is of length &gt;1, this argument is ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In 'spmdda' the logic is that we first transform to geodesic distance, then apply the explicit power transformation and then the implicit optimal scaling. There is a wrapper 'smdda' where the exponents are 1, which is standard SMDDA but extend to allow optimal scaling. The neighborhood parameter tau is kept fixed in 'spmdda' and 'smdda'. The functions 'so_spmdda' and 'so_smdda' implement a self-organising principle where the is repeatedly fitted for a decreasing sequence of taus.
</p>
<p>The solution is found by &quot;quasi-majorization&quot;, which mean that the majorization is only working properly after a burn-in of a few iterations when the assignment which distances are ignored no longer changes. Due to that it can be that in the beginning the stress may not decrease monotonically and that there's a chance it might never.
</p>
<p>The geodesic distances are calculated via 'vegan::isomapdist', see <code><a href="vegan.html#topic+isomapdist">isomapdist</a></code> for a documentation of what these distances do. The functions of '(p)smdda' are just a wrapper for '(p)clca' applied to the geodesic distances obtained via isomapdist. 
</p>
<p>If tau is too small it may happen that all distances for one i to all j are zero and then there will be an error, so make sure to set a larger tau.
</p>
<p>In the standard functions 'spmdda' and 'smdda' we keep tau fixed throughout. This means that if tau is large enough, then the result is the same as the corresponding MDS. In the orginal publication the idea was that of a self-organizing map which decreased tau over epochs (i.e., passes through the data). This can be achieved with our function 'so_spmdda' 'so_smdda' which creates a vector of decreasing tau values, calls the function 'spmdda' with the first tau, then supplies the optimal configuration obtained as the init for the next call with the next tau and so on.
</p>


<h3>Value</h3>

<p>a 'smacofP' object (inheriting from 'smacofB', see <code><a href="smacof.html#topic+smacofSym">smacofSym</a></code>). It is a list with the components
</p>

<ul>
<li><p> delta: Observed, untransformed dissimilarities
</p>
</li>
<li><p> tdelta: Observed explicitly transformed dissimilarities, normalized
</p>
</li>
<li><p> dhat: Explicitly transformed dissimilarities (dhats), optimally scaled and normalized 
</p>
</li>
<li><p> confdist: Configuration dissimilarities
</p>
</li>
<li><p> conf: Matrix of fitted configuration
</p>
</li>
<li><p> stress: Default stress  (stress 1; sqrt of explicitly normalized stress)
</p>
</li>
<li><p> spp: Stress per point 
</p>
</li>
<li><p> ndim: Number of dimensions
</p>
</li>
<li><p> model: Name of smacof model
</p>
</li>
<li><p> niter: Number of iterations
</p>
</li>
<li><p> nobj: Number of objects
</p>
</li>
<li><p> type: Type of MDS model
</p>
</li>
<li><p> weightmat: weighting matrix as supplied
</p>
</li>
<li><p> stress.m: Default stress (stress-1^2)
</p>
</li>
<li><p> tweightmat: transformed weighting matrix; it is weightmat but containing all the 0s for the distances set to 0. 
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>dis&lt;-smacof::morse
res&lt;-spmdda(dis,kappa=2,lambda=2,tau=0.4,k=5,itmax=500) #use higher itmax
res
#already many parameters 
coef(res)

res2&lt;-smdda(dis,type="interval",tau=0.4,epsilon=1,itmax=500) #use higher itmax
res2
summary(res)
oldpar&lt;-par(mfrow=c(1,2))
plot(res)
plot(res2)
par(oldpar)

##which d_{ij}(X) exceeded tau at convergence (i.e., have been set to 0)?
res$tweighmat
res2$tweightmat


## Self-organizing map style (as in the original publication)
#run the som-style (p)smdda 
sommod1&lt;-so_spmdda(dis,tau=2,k=5,kappa=0.5,lambda=2,epochs=100,verbose=1)
sommod2&lt;-so_smdda(dis,tau=2.5,epsilon=1,epochs=50,verbose=1)
sommod1
sommod2


</code></pre>

<hr>
<h2 id='spmds'>Sparsified (POST-) Multidimensional Scaling (SPMDS or SMDS) either as self-organizing or not</h2><span id='topic+spmds'></span><span id='topic+smds'></span><span id='topic+so_spmds'></span><span id='topic+so_smds'></span>

<h3>Description</h3>

<p>An implementation of a sparsified version of (POST-)MDS by pseudo-majorization with ratio, interval and ordinal optimal scaling for dissimilarities and optional power transformations. This is inspired by curvilinear component analysis but works differently: It finds an initial weightmatrix where w_ij(X^0)=0 if d_ij(X^0)&gt;tau and fits a POST-MDS with these weights. Then in each successive iteration step, the weightmat is recalculated so that w_ij(X^(n+1))=0 if d_ij(X^(n+1))&gt;tau.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spmds(
  delta,
  lambda = 1,
  kappa = 1,
  nu = 1,
  tau,
  type = "ratio",
  ties = "primary",
  weightmat = 1 - diag(nrow(delta)),
  init = NULL,
  ndim = 2,
  acc = 1e-06,
  itmax = 10000,
  verbose = FALSE,
  principal = FALSE
)

smds(
  delta,
  tau = stats::quantile(delta, 0.9),
  type = "ratio",
  ties = "primary",
  weightmat = 1 - diag(nrow(delta)),
  init = NULL,
  ndim = 2,
  acc = 1e-06,
  itmax = 10000,
  verbose = FALSE,
  principal = FALSE
)

so_spmds(
  delta,
  kappa = 1,
  lambda = 1,
  nu = 1,
  tau = max(delta),
  epochs = 10,
  type = "ratio",
  ties = "primary",
  weightmat = 1 - diag(nrow(delta)),
  init = NULL,
  ndim = 2,
  acc = 1e-06,
  itmax = 10000,
  verbose = FALSE,
  principal = FALSE
)

so_smds(
  delta,
  tau = max(delta),
  epochs = 10,
  type = "ratio",
  ties = "primary",
  weightmat = 1 - diag(nrow(delta)),
  init = NULL,
  ndim = 2,
  acc = 1e-06,
  itmax = 10000,
  verbose = FALSE,
  principal = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spmds_+3A_delta">delta</code></td>
<td>
<p>dist object or a symmetric, numeric data.frame or matrix of distances</p>
</td></tr>
<tr><td><code id="spmds_+3A_lambda">lambda</code></td>
<td>
<p>exponent of the power transformation of the dissimilarities; defaults to 1, which is also the setup of 'smds'</p>
</td></tr>
<tr><td><code id="spmds_+3A_kappa">kappa</code></td>
<td>
<p>exponent of the power transformation of the fitted distances; defaults to 1, which is also the setup of 'smds'.</p>
</td></tr>
<tr><td><code id="spmds_+3A_nu">nu</code></td>
<td>
<p>exponent of the power of the weighting matrix; defaults to 1 which is also the setup for 'smds'.</p>
</td></tr>
<tr><td><code id="spmds_+3A_tau">tau</code></td>
<td>
<p>the boundary/neighbourhood parameter(s) (called lambda in the original paper). For 'spmds' and 'smds' it is supposed to be a numeric scalar (if a sequence is supplied the maximum is taken as tau) and all the transformed fitted distances exceeding tau are set to 0 via the weightmat (assignment can change between iterations). It defaults to the 90% quantile of delta. For 'so_spmds' tau is supposed to be either a user supplied decreasing sequence of taus or if a scalar the maximum tau from which a decreasing sequence of taus is generated automatically as 'seq(from=tau,to=tau/epochs,length.out=epochs)' and then used in sequence.</p>
</td></tr>
<tr><td><code id="spmds_+3A_type">type</code></td>
<td>
<p>what type of MDS to fit. Currently one of &quot;ratio&quot;, &quot;interval&quot; or &quot;ordinal&quot;. Default is &quot;ratio&quot;.</p>
</td></tr>
<tr><td><code id="spmds_+3A_ties">ties</code></td>
<td>
<p>the handling of ties for ordinal (nonmetric) MDS. Possible are &quot;primary&quot; (default), &quot;secondary&quot; or &quot;tertiary&quot;.</p>
</td></tr>
<tr><td><code id="spmds_+3A_weightmat">weightmat</code></td>
<td>
<p>a matrix of finite weights.</p>
</td></tr>
<tr><td><code id="spmds_+3A_init">init</code></td>
<td>
<p>starting configuration. If NULL (default) we fit a full rstress model.</p>
</td></tr>
<tr><td><code id="spmds_+3A_ndim">ndim</code></td>
<td>
<p>dimension of the configuration; defaults to 2</p>
</td></tr>
<tr><td><code id="spmds_+3A_acc">acc</code></td>
<td>
<p>numeric accuracy of the iteration. Default is 1e-6.</p>
</td></tr>
<tr><td><code id="spmds_+3A_itmax">itmax</code></td>
<td>
<p>maximum number of iterations. Default is 10000.</p>
</td></tr>
<tr><td><code id="spmds_+3A_verbose">verbose</code></td>
<td>
<p>should iteration output be printed; if &gt; 1 then yes</p>
</td></tr>
<tr><td><code id="spmds_+3A_principal">principal</code></td>
<td>
<p>If 'TRUE', principal axis transformation is applied to the final configuration</p>
</td></tr>
<tr><td><code id="spmds_+3A_epochs">epochs</code></td>
<td>
<p>for 'so_spmds' and tau being scalar, it gives the number of passes through the data. The sequence of taus created is 'seq(tau,tau/epochs,length.out=epochs)'. If tau is of length &gt;1, this argument is ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>There is a wrapper 'smds' where the exponents are 1, which is standard SMDS but extend to allow optimal scaling. The neighborhood parameter tau is kept fixed in 'spmds' and 'smds'. The functions 'so_spmds' and 'so_smds' implement a self-organising principle, where the SMDS is repeatedly fitted for a decreasing sequence of taus.
</p>
<p>The solution is found by &quot;quasi-majorization&quot;, which means that the majorization is only real majorization once the weightmat no longer changes. This typically happens after a few iterations. Due to that it can be that in the beginning the stress may not decrease monotonically and that there's a chance it might never. 
</p>
<p>If tau is too small it may happen that all distances for one i to all j are zero and then there will be an error, so make sure to set a larger tau.
</p>
<p>In the standard functions 'spmds' and 'smds' we keep tau fixed throughout. This means that if tau is large enough, then the result is the same as the corresponding MDS. In the orginal publication the idea was that of a self-organizing map which decreased tau over epochs (i.e., passes through the data). This can be achieved with our function 'so_spmds' 'so_smds' which creates a vector of decreasing tau values, calls the function 'spmds' with the first tau, then supplies the optimal configuration obtained as the init for the next call with the next tau and so on.
</p>


<h3>Value</h3>

<p>a 'smacofP' object (inheriting from 'smacofB', see <code><a href="smacof.html#topic+smacofSym">smacofSym</a></code>). It is a list with the components
</p>

<ul>
<li><p> delta: Observed, untransformed dissimilarities
</p>
</li>
<li><p> tdelta: Observed explicitly transformed dissimilarities, normalized
</p>
</li>
<li><p> dhat: Explicitly transformed dissimilarities (dhats), optimally scaled and normalized 
</p>
</li>
<li><p> confdist: Configuration dissimilarities
</p>
</li>
<li><p> conf: Matrix of fitted configuration
</p>
</li>
<li><p> stress: Default stress  (stress 1; sqrt of explicitly normalized stress)
</p>
</li>
<li><p> spp: Stress per point 
</p>
</li>
<li><p> ndim: Number of dimensions
</p>
</li>
<li><p> model: Name of smacof model
</p>
</li>
<li><p> niter: Number of iterations
</p>
</li>
<li><p> nobj: Number of objects
</p>
</li>
<li><p> type: Type of MDS model
</p>
</li>
<li><p> weightmat: weighting matrix as supplied
</p>
</li>
<li><p> stress.m: Default stress (stress-1^2)
</p>
</li>
<li><p> tweightmat: transformed weighting matrix; it is weightmat but containing all the 0s for the distances set to 0. 
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>dis&lt;-smacof::morse
res&lt;-spmds(dis,type="interval",kappa=2,lambda=2,tau=0.35,itmax=100) #use higher itmax
res2&lt;-smds(dis,type="interval",tau=0.35,itmax=500) #use higher itmax
res
res2
summary(res)
oldpar&lt;-par(mfrow=c(1,2))
plot(res)
plot(res2)
par(oldpar)

##which d_{ij}(X) exceeded tau at convergence (i.e., have been set to 0)?
res$tweightmat
res2$tweightmat


## Self-organizing map style (as in the clca publication)
#run the som-style (p)smds 
sommod1&lt;-so_spmds(dis,tau=0.3,kappa=0.5,lambda=2,epochs=10,verbose=1)
sommod2&lt;-so_smds(dis,tau=0.3,epochs=10,verbose=1)
sommod1
sommod2


</code></pre>

<hr>
<h2 id='spp'>Calculating stress per point</h2><span id='topic+spp'></span>

<h3>Description</h3>

<p>Calculating stress per point
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spp(dhat, confdist, weightmat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spp_+3A_dhat">dhat</code></td>
<td>
<p>a dist object or symmetric matrix of dissimilarities</p>
</td></tr>
<tr><td><code id="spp_+3A_confdist">confdist</code></td>
<td>
<p>a dist object or symmetric matrix of fitted distances</p>
</td></tr>
<tr><td><code id="spp_+3A_weightmat">weightmat</code></td>
<td>
<p>dist objetc or symmetric matrix of weights</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list
</p>

<hr>
<h2 id='sqdist'>Squared distances</h2><span id='topic+sqdist'></span>

<h3>Description</h3>

<p>Squared distances
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sqdist(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sqdist_+3A_x">x</code></td>
<td>
<p>numeric matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>squared distance matrix
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
