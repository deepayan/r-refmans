<!DOCTYPE html><html><head><title>Help for package logconcens</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {logconcens}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#cure.profile'>
<p>Evaluate the Profile Log-Likelihood on a Grid of <code class="reqn">p_0</code>-Values</p></a></li>
<li><a href='#lc.control'>
<p>Set the Control Parameters for <code>logcon</code></p></a></li>
<li><a href='#lcdensity-methods'>
<p>Methods for Objects of Class <code>lcdensity</code></p></a></li>
<li><a href='#logcon'>
<p>Compute Log-Concave MLE Based on Censored or Exact Data</p></a></li>
<li><a href='#logconcens-internal'><p>Internal logconcens Functions</p></a></li>
<li><a href='#logconcens-package'>
<p>Maximum Likelihood Estimation of a Log-Concave Density Based on Censored Data</p></a></li>
<li><a href='#loglike'>
<p>Compute Log-Likelihood for an Object of Class <code>lcdensity</code></p></a></li>
<li><a href='#plotint'>
<p>Plot Censored Data</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Maximum Likelihood Estimation of a Log-Concave Density Based on
Censored Data</td>
</tr>
<tr>
<td>Version:</td>
<td>0.17-3</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-08-19</td>
</tr>
<tr>
<td>Author:</td>
<td>Dominic Schuhmacher &lt;dominic.schuhmacher@mathematik.uni-goettingen.de&gt;, Kaspar Rufibach &lt;kaspar.rufibach@gmail.com&gt;, Lutz Duembgen &lt;duembgen@stat.unibe.ch&gt;</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Dominic Schuhmacher &lt;dominic.schuhmacher@mathematik.uni-goettingen.de&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.15.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>grDevices, graphics, stats, utils</td>
</tr>
<tr>
<td>Suggests:</td>
<td>logcondens</td>
</tr>
<tr>
<td>Description:</td>
<td>Based on right or interval censored data, compute the maximum likelihood estimator of a (sub)probability density under the assumption that it is log-concave. For further information see Duembgen, Rufibach and Schuhmacher (2014) &lt;<a href="https://doi.org/10.1214%2F14-EJS930">doi:10.1214/14-EJS930</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-08-19 10:21:41 UTC; schumi</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-08-19 11:32:32 UTC</td>
</tr>
</table>
<hr>
<h2 id='cure.profile'>
Evaluate the Profile Log-Likelihood on a Grid of <code class="reqn">p_0</code>-Values
</h2><span id='topic+cure.profile'></span>

<h3>Description</h3>

<p>For each of a series of values for the cure parameter <code class="reqn">p_0</code> run the function <code>logcon</code> and evaluate the (normalized) log-likelihood at <code class="reqn">(\phi,p_0)</code>, where <code class="reqn">\phi</code> is the log subprobability density returned by <code>logcon</code>. This serves for (approximate) joint likelihood maximization in <code class="reqn">(\phi,p_0)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cure.profile(x, p0grid=seq(0,0.95,0.05), knot.prec=IQR(x[x&lt;Inf])/75,
                  reduce=TRUE, control=lc.control())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cure.profile_+3A_x">x</code></td>
<td>

<p>a two-column matrix of <code class="reqn">n \geq 2</code> rows containing the data intervals.
</p>
</td></tr>
<tr><td><code id="cure.profile_+3A_p0grid">p0grid</code></td>
<td>

<p>a vector of values <code class="reqn">p_0</code> for which the profile log-likelihood is to be evaluated.
</p>
</td></tr>
<tr><td><code id="cure.profile_+3A_knot.prec">knot.prec</code>, <code id="cure.profile_+3A_reduce">reduce</code>, <code id="cure.profile_+3A_control">control</code></td>
<td>

<p>arguments passed to the function <code><a href="#topic+logcon">logcon</a></code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the following values:
</p>
<table>
<tr><td><code>p0hat</code></td>
<td>
<p>the element in <code>p0grid</code> that maximizes the profile likelihood (in the very unlikely case of ties, only the smallest such element is returned).</p>
</td></tr>
<tr><td><code>status</code></td>
<td>
<p>the vector of (normalized) profile log-likelihood values for the elements of <code>p0grid</code>.</p>
</td></tr> 
</table>


<h3>Note</h3>

<p>For a large <code>p0grid</code>-vector (fine grid) computations may take a long time. Consider using the option <code>adapt.p0</code> in the function <code>logcon</code> for a much faster method of joint likelihood maximization in <code class="reqn">(\phi,p_0)</code>.
</p>


<h3>Author(s)</h3>

<p>Dominic Schuhmacher <a href="mailto:dominic.schuhmacher@mathematik.uni-goettingen.de">dominic.schuhmacher@mathematik.uni-goettingen.de</a><br />
Kaspar Rufibach <a href="mailto:kaspar.rufibach@gmail.com">kaspar.rufibach@gmail.com</a><br />
Lutz Duembgen <a href="mailto:duembgen@stat.unibe.ch">duembgen@stat.unibe.ch</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+logcon">logcon</a></code>, <code><a href="#topic+loglike">loglike</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## The example from the logconcens-package help page:
set.seed(11)
x &lt;- rgamma(50,3,1)
x &lt;- cbind(x,ifelse(rexp(50,1/3) &lt; x,Inf,x))

## Not run: 
plotint(x)
progrid &lt;- seq(0.1,0.6,0.025)
prores &lt;- cure.profile(x, progrid)
plot(progrid, prores$loglike)
prores$p0hat
res &lt;- logcon(x, p0=prores$p0hat)
plot(res, type="survival")

## End(Not run)
</code></pre>

<hr>
<h2 id='lc.control'>
Set the Control Parameters for <code>logcon</code>
</h2><span id='topic+lc.control'></span><span id='topic+control'></span>

<h3>Description</h3>

<p>Allows to set the control parameters for the more technical aspects of the function <code><a href="#topic+logcon">logcon</a></code> and provides default values for any parameters that are not set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lc.control(maxiter=49, move.prec=1e-5, domind1l=1, domind2r=1, force.inf=FALSE,
                red.thresh=NULL, check.red=TRUE, addpoints=FALSE, addeps=NULL,
                preweights=NULL, minw=0, show=FALSE, verbose=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lc.control_+3A_maxiter">maxiter</code></td>
<td>

<p>the maximal number of iterations in the main EM algorithm. Default is <code>49</code> rather than <code>50</code>,
because this goes well with plotting in case of <code>show = TRUE</code>. 
</p>
</td></tr>
<tr><td><code id="lc.control_+3A_move.prec">move.prec</code></td>
<td>

<p>a real number giving the threshold for the <code class="reqn">L_1</code>-distance between densities in subsequent steps below which the algorithm is stopped.
</p>
</td></tr>
<tr><td><code id="lc.control_+3A_domind1l">domind1l</code>, <code id="lc.control_+3A_domind2r">domind2r</code></td>
<td>

<p>index numbers in the vector of sorted interval endpoints that specify the left and right boundary of the maximal domain to be considered by the algorithm; see the details section of the help for <code>logcon</code>. The indices are counted from the left and from the right, respectively. So the default values of <code>domind1l = 1</code> and <code>domind2r = 1</code> mean that the largest possible domain is used. 
</p>
</td></tr>
<tr><td><code id="lc.control_+3A_force.inf">force.inf</code></td>
<td>

<p><code>logical</code>. For experimental use only. Should the domain interval be forced to be right-infinite (if there is a right-infinite data interval)? 
</p>
</td></tr>
<tr><td><code id="lc.control_+3A_red.thresh">red.thresh</code></td>
<td>

<p>a real number indicating the threshold below which the boundary integrals are considered too small; see the details section of the help for <code>logcon</code>. There is a sensible default, which depends on <code>check.red</code>.
</p>
</td></tr>
<tr><td><code id="lc.control_+3A_check.red">check.red</code></td>
<td>

<p><code>logical</code>. If a boundary integral is deemed too small, should the derivative of the augmented log-likelihood be checked to confirm the domain reduction. 
</p>
</td></tr>
<tr><td><code id="lc.control_+3A_addpoints">addpoints</code></td>
<td>

<p><code>logical</code>. Should extra exact observations be added to the data at the left- and rightmost finite interval endpoints to prevent domain reduction? These observations obtain a small weight <code class="reqn">&lt;1</code> as compared to the weight of 1 for all the other observation intervals. The weight is specified by <code>addeps</code>.
</p>
</td></tr>
<tr><td><code id="lc.control_+3A_addeps">addeps</code></td>
<td>

<p>a positive real number. If <code>NULL</code>, a default value of <code class="reqn">1/n^2</code> is computed where <code class="reqn">n</code> is the number of observation intervals. See <code>addpoints</code>.
</p>
</td></tr>
<tr><td><code id="lc.control_+3A_preweights">preweights</code></td>
<td>

<p>a vector of weights for the observation intervals. Defaults to <code>rep(1,n)</code>.
</p>
</td></tr>
<tr><td><code id="lc.control_+3A_minw">minw</code></td>
<td>

<p>a positive real number. This gives another way for preventing domain reduction. Instead of adding
observations the weights for the internal active set algorithm are kept at or above minw at the boundary
of the domain. 
</p>
</td></tr>
<tr><td><code id="lc.control_+3A_show">show</code></td>
<td>

<p><code>logical</code>. Should progress of the algorithm be plotted? Warning: if <code>TRUE</code>, this may open
many new graphics devices in case of complicated data sets.
</p>
</td></tr>
<tr><td><code id="lc.control_+3A_verbose">verbose</code></td>
<td>

<p><code>logical</code>. Should additional information about the progress of the algorithm be printed? 
This mainly prints quantities important for the decision to reduce the domain of the function
and about the progress of the EM algorithm.  
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For further explanations about the algorithm see the help for <code>logcon</code>. In summary:
</p>
<p><code>maxiter</code> and <code>move.prec</code> provide stopping criteria for the EM algorithm.
</p>
<p><code>domind1l</code>, <code>domind2r</code>, <code>force.inf</code>, <code>red.thresh</code>, and <code>check.red</code> control aspects related to domain reduction.
</p>
<p><code>addpoints</code>, <code>addeps</code>, <code>preweights</code>, <code>winw</code> allow for reweighing of data interval, mainly for increasing numerical stability by preventing domain reduction.
</p>
<p><code>show</code> and <code>verbose</code> give illustrations and background information of the run of the algorithm.   
</p>


<h3>Value</h3>

<p>A list with all of the above components set to their (specified or default) value.  
</p>


<h3>Author(s)</h3>

<p>Dominic Schuhmacher <a href="mailto:dominic.schuhmacher@mathematik.uni-goettingen.de">dominic.schuhmacher@mathematik.uni-goettingen.de</a><br />
Kaspar Rufibach <a href="mailto:kaspar.rufibach@gmail.com">kaspar.rufibach@gmail.com</a><br />
Lutz Duembgen <a href="mailto:duembgen@stat.unibe.ch">duembgen@stat.unibe.ch</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+logcon">logcon</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## See the examples for logcon
</code></pre>

<hr>
<h2 id='lcdensity-methods'>
Methods for Objects of Class <code>lcdensity</code>
</h2><span id='topic+lcdensity-methods'></span><span id='topic+plot.lcdensity'></span><span id='topic+print.lcdensity'></span><span id='topic+summary.lcdensity'></span>

<h3>Description</h3>

<p>Plot, print, and summary methods for objects of class <code>lcdensity</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lcdensity'
plot(x, type = c("log-density", "density", "CDF", "survival"), sloperange = TRUE,
                      kinklines=TRUE, kinkpoints=FALSE, xlim=NULL, ylim=NULL, ...)

## S3 method for class 'lcdensity'
print(x, ...)

## S3 method for class 'lcdensity'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lcdensity-methods_+3A_x">x</code>, <code id="lcdensity-methods_+3A_object">object</code></td>
<td>
<p>objects of class <code>lcdensity</code>, as returned by <code><a href="#topic+logcon">logcon</a></code>.</p>
</td></tr>
<tr><td><code id="lcdensity-methods_+3A_type">type</code></td>
<td>
<p>the type of plot to be produced.</p>
</td></tr>
<tr><td><code id="lcdensity-methods_+3A_sloperange">sloperange</code></td>
<td>
<p><code>logical</code>. In cases where the cure parameter / the right-hand side slope of the
log-subdensity <code class="reqn">\phi</code> is not unique, should grey area be drawn indicating the set of
possible right-hand slopes?</p>
</td></tr>
<tr><td><code id="lcdensity-methods_+3A_kinklines">kinklines</code></td>
<td>
<p><code>logical</code>. Should vertical lines be drawn at the kinks of the log-subdensity <code class="reqn">\phi</code>?</p>
</td></tr>
<tr><td><code id="lcdensity-methods_+3A_kinkpoints">kinkpoints</code></td>
<td>
<p><code>logical</code>. Should fat points be plotted at the kinks of the log-subdensity <code class="reqn">\phi</code>?</p>
</td></tr>
<tr><td><code id="lcdensity-methods_+3A_xlim">xlim</code>, <code id="lcdensity-methods_+3A_ylim">ylim</code></td>
<td>
<p>numeric vectors of length 2, giving the x and y coordinates ranges.</p>
</td></tr>
<tr><td><code id="lcdensity-methods_+3A_...">...</code></td>
<td>
<p>further arguments passed to <code><a href="graphics.html#topic+plot.default">plot.default</a></code>. Depending on the argument
this may or may not work in the intended way.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Dominic Schuhmacher <a href="mailto:dominic.schuhmacher@mathematik.uni-goettingen.de">dominic.schuhmacher@mathematik.uni-goettingen.de</a><br />
Kaspar Rufibach <a href="mailto:kaspar.rufibach@gmail.com">kaspar.rufibach@gmail.com</a><br />
Lutz Duembgen <a href="mailto:duembgen@stat.unibe.ch">duembgen@stat.unibe.ch</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plotint">plotint</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## See the examples for logcon
</code></pre>

<hr>
<h2 id='logcon'>
Compute Log-Concave MLE Based on Censored or Exact Data
</h2><span id='topic+logcon'></span><span id='topic+logconcure'></span><span id='topic+logConCens'></span>

<h3>Description</h3>

<p>Based on independent intervals <code class="reqn">X_i = [L_i,R_i]</code>, where <code class="reqn">-\infty &lt; L_i \leq R_i \leq \infty</code>, compute the maximum likelihood estimator of a (sub)probability density <code class="reqn">\phi</code> and the remaining mass <code class="reqn">p_0</code> at infinity (also known as <em>cure parameter</em>) under the assumption that the former is log-concave. Computation is based on an EM algorithm. For further information see Duembgen, Rufibach, and Schuhmacher (2013, preprint).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>logcon(x, adapt.p0=FALSE, p0=0, knot.prec=IQR(x[x&lt;Inf])/75, reduce=TRUE,
            control=lc.control())

logConCens(x, adapt.p0=FALSE, p0=0, knot.prec=IQR(x[x&lt;Inf])/75, reduce=TRUE,
                control=lc.control())

logconcure(x, p0=0, knot.prec=IQR(x[x&lt;Inf])/75, reduce=TRUE, control=lc.control())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logcon_+3A_x">x</code></td>
<td>

<p>a two-column matrix of <code class="reqn">n \geq 2</code> rows containing the data intervals, or a vector of length
<code class="reqn">n \geq 2</code> containing the exact data points.
</p>
</td></tr>
<tr><td><code id="logcon_+3A_adapt.p0">adapt.p0</code></td>
<td>

<p><code>logical</code>. Should the algorithm be allowed to adapt <code class="reqn">p_0</code>? In this case an alternating maximization procedure is used that is <em>believed</em> to always yield a joint maximizer <code class="reqn">(\hat{\phi},\hat{p_0})</code>. For the much slower (but maybe safer) profile likelihood maximization method, see the function <code><a href="#topic+cure.profile">cure.profile</a></code>.
</p>
</td></tr>
<tr><td><code id="logcon_+3A_p0">p0</code></td>
<td>

<p>a number from 0 to 1 specifying the mass at infinity. 
If the algorithm is allowed to adapt <code class="reqn">p_0</code>, this argument only specifies the starting value.
Otherwise it is assumed that the true cure parameter <code class="reqn">p_0</code> is equal to this number. In particular,
for the default setting of 0, a proper probability density <code class="reqn">\phi</code> is estimated.
</p>
</td></tr>
<tr><td><code id="logcon_+3A_knot.prec">knot.prec</code></td>
<td>

<p>the maximal distance between two consecutive grid points, where knots (points at which the resulting
log-subdensity <code class="reqn">\phi</code> may change slope) can be positioned. See details.
</p>
</td></tr>
<tr><td><code id="logcon_+3A_reduce">reduce</code></td>
<td>

<p><code>logical</code>. Should the domain of the (sub)density be reduced whenever the mass at the left or the right boundary becomes too small?
</p>
</td></tr>
<tr><td><code id="logcon_+3A_control">control</code></td>
<td>

<p>a list of control parameters for the more technical aspects of the algorithm; usually the result of a call
to <code><a href="#topic+lc.control">lc.control</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Based on the data intervals <code class="reqn">X_i = [L_i,R_i]</code> described above, function <code>logcon</code> computes a concave, piecewise linear function <code class="reqn">\phi</code> and a probability <code class="reqn">p_0</code> which satisfy <code class="reqn">\int \exp \phi(x) \, dx = 1-p_0</code> and jointly maximize the (normalized) log-likelihood.
</p>
<p style="text-align: center;"><code class="reqn">\ell(\phi, p_0) = \frac{1}{n} \sum_{i=1}^n \biggl[ 1\{L_i = R_i\} \phi(X_i) + 1\{L_i &lt; R_i\}
   \log \biggl( \int_{L_i}^{R_i} \exp \phi(x) \; dx + 1\{R_i = \infty\} p_0 \biggr) \ \biggr],</code>
</p>

<p>If <code>x</code> is a two-column matrix, it is assumed to contain the left and right interval endpoints in the correct order. Intervals may have length zero (both endpoints equal) or be unbounded to the right (right endpoint is <code>Inf</code>). Computation is based on an EM algorithm, where the M-step uses an active set algorithm for computing the log-concave MLE for exact data with weights. The active set algorithm was described in Duembgen, Huesler, and Rufibach (2007) and Duembgen and Rufibach (2011) and is available in the R package <code>logcondens</code>. It has been re-implemented in C for the current package because of speed requirements. The whole algorithm for censored data has been indicated in Duembgen, Huesler, and Rufibach (2007) and was elaborated in Duembgen, Schuhmacher, and Rufibach (2013, preprint).
</p>
<p>If <code>x</code> is a vector argument, it is assumed to contain the exact data points. In this case the active set algorithm is accessed directly.
</p>
<p>In order to obtain a finite dimensional optimization problem the (supposed) domain of <code class="reqn">\phi</code> is subdivided by a grid. Stretches between interval endpoints where for theoretical reasons no knots (points where the slope of <code class="reqn">\phi</code> changes) can lie are left out. The argument <code>kink.prec</code> gives the maximal distance we allow between consecutive grid points in stretches where knots can lie. Say <code>plotint(x)</code> to see the grid.
</p>
<p>The EM algorithm works only for fixed dimensionality of the problem, but the domain of the function <code class="reqn">\phi</code> is not a priori known. Therefore there is an outer loop starting with the largest possible domain, given by the minimal and maximal endpoints of all the intervals, and decreasing the domain as soon as the EM steps let <code class="reqn">\phi</code> become very small towards the boundary. &ldquo;Very small&rdquo; means that the integral of <code class="reqn">\exp \circ \, \phi</code> over the first or last stretch between interval endpoints within the current domain falls below a certain threshold <code>red.thresh</code>, which can be controlled via <code><a href="#topic+lc.control">lc.control</a></code>.
</p>
<p>Domain reduction tends to be rather conservative. If the computed solution has a suspiciously steep slope at any of the domain boundaries, the recommended strategy is to enforce a smaller domain by increasing the parameters <code>domind1l</code> and/or <code>domind2r</code> via <code><a href="#topic+lc.control">lc.control</a></code>. The function <code><a href="#topic+loglike">loglike</a></code> may be used to compare the (normalized) log-likelihoods of the results.
</p>
<p><code>logConCens</code> is  an alias for <code>logcon</code>. It is introduced to provide unified naming with the main functions in the packages <code>logcondens</code> and <code>logcondiscr</code>. 
</p>
<p><code>logconcure</code> is the same as <code>logcon</code> with <code>adapt.p0 = TRUE</code> fixed. 


</p>


<h3>Value</h3>

<p>An object of class <code>lcdensity</code> for which reasonable <code><a href="#topic+plot.lcdensity">plot</a></code>, <code><a href="#topic+print.lcdensity">print</a></code>, and <code><a href="#topic+summary.lcdensity">summary</a></code> methods are available.
</p>
<p>If the argument <code>x</code> is a two-column matrix (censored data case), such an object has the following components. 
</p>
<table>
<tr><td><code>basedOn</code></td>
<td>
<p>the string <code>"censored"</code> for the type of data the solution is based on.</p>
</td></tr>
<tr><td><code>status</code></td>
<td>
<p>currently only <code>0</code> if the algorithm converged; and <code>1</code> otherwise. 
Note that in most cases even with status <code>1</code> the returned solution is very close to the truth.
The <code>1</code> is often due to the fact that the termination criterion is not so well balanced yet.</p>
</td></tr>
<tr><td><code>x</code></td>
<td>
<p>the data entered.</p>
</td></tr>
<tr><td><code>tau</code></td>
<td>
<p>the ordered vector of different interval endpoints.</p>
</td></tr>
<tr><td><code>domind1</code>, <code>domind2</code></td>
<td>
<p>the indices of the <code>tau</code>-element at which the domain of the MLE <code class="reqn">\phi</code>
starts/ends.</p>
</td></tr>
<tr><td><code>tplus</code></td>
<td>
<p>the grid vector. <code>tau[domind1:domind2]</code> augmented by points of subdivision.</p>
</td></tr>
<tr><td><code>isKnot</code></td>
<td>
<p><code>0</code>-<code>1</code> value. For the finite elements of <code>tplus</code> a <code>1</code> if <code class="reqn">\phi</code> has a knot at this position, <code>0</code> otherwise.</p>
</td></tr>
<tr><td><code>phi</code></td>
<td>
<p>the vector of <code class="reqn">\phi</code>-values at the finite elements of <code>tplus</code>.</p>
</td></tr>
<tr><td><code>phislr</code></td>
<td>
<p>if <code class="reqn">\sup({\rm dom}(\phi)) = \infty</code>, the slope of <code class="reqn">\phi</code> after the last knot. Otherwise <code class="reqn">-\infty</code>.</p>
</td></tr>
<tr><td><code>phislr.range</code></td>
<td>
<p>a vector of length 2 specifying a range of possible values for <code>phislr</code>. This is for the (rather rare) situations that mass may be shifted between the interval from the rightmost tau-point to infinity and the cure parameter without changing the likelihood. Otherwise <code>phislr.range</code> is <code>NA</code>.</p>
</td></tr>
<tr><td><code>cure</code></td>
<td>
<p>the cure parameter. Either the original argument <code>p0</code> if <code>adapt.p0</code> was <code>FALSE</code>, otheriwse the estimated cure parameter obtained by the alternating maximization procedure.</p>
</td></tr>
<tr><td><code>cure.range</code></td>
<td>
<p>a vector of length 2 specifying a range of possible values for <code>cure</code> or <code>NA</code>. See <code>phislr.range</code>.</p>
</td></tr>
<tr><td><code>Fhat</code></td>
<td>
<p>the vector of values of the distribution function <code class="reqn">F</code> of <code class="reqn">\exp \circ \, \phi</code> at the finite elements of <code>tplus</code>.</p>
</td></tr>
<tr><td><code>Fhatfin</code></td>
<td>
<p>the computed value of <code class="reqn">\lim_{t \to \infty} F(t)</code>.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>If <code>x</code> is a vector, this function does the same as the function <code>logConDens</code> in the package
<code>logcondens</code>. The latter package offers additional features such as grid-based computation with weights
(for high numerical stability) and
smoothing of the estimator, as well as nicer plotting. <strong>For exact data</strong> we recommend using
<code>logConDens</code> for
everyday data analysis. <code>logcon</code> with a vector argument is to be preferred if time is of the essence (for
data sets with several thousands of points or repeated optimization in iterative algorithms) or
if an additional slope functionality is required. 
</p>
<p>Two other helpful packages for log-concave density estimation based on exact data are <code>logcondiscr</code> for estimating a discrete distribution and <code>LogConcDEAD</code> for estimating a multivariate continuous distribution.
</p>


<h3>Author(s)</h3>

<p>Dominic Schuhmacher <a href="mailto:dominic.schuhmacher@mathematik.uni-goettingen.de">dominic.schuhmacher@mathematik.uni-goettingen.de</a><br />
Kaspar Rufibach <a href="mailto:kaspar.rufibach@gmail.com">kaspar.rufibach@gmail.com</a><br />
Lutz Duembgen <a href="mailto:duembgen@stat.unibe.ch">duembgen@stat.unibe.ch</a>
</p>


<h3>References</h3>

<p>Duembgen, L., Huesler, A., and Rufibach, K. (2007). Active set and EM algorithms for log-concave densities based on complete and censored data. Technical Report 61. IMSV, University of Bern. <a href="https://arxiv.org/abs/0707.4643">https://arxiv.org/abs/0707.4643</a>
</p>
<p>Duembgen, L. and Rufibach, K., (2011). logcondens: Computations Related to Univariate Log-Concave Density Estimation. Journal of Statistical Software, 39(6), 1-28. <a href="https://doi.org/10.18637/jss.v039.i06">doi:10.18637/jss.v039.i06</a>
</p>
<p>Duembgen, L., Rufibach, K., and Schuhmacher, D. (2014). Maximum-likelihood estimation of a log-concave density based on censored data. Electronic Journal of Statistics, 8(1), 1405-1437. <a href="https://doi.org/10.1214/14-EJS930">doi:10.1214/14-EJS930</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lc.control">lc.control</a></code>, <code><a href="#topic+lcdensity-methods">lcdensity-methods</a></code>, <code><a href="#topic+loglike">loglike</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># A function for artificially censoring exact data
censor &lt;- function(y, timemat) {
  tm &lt;- cbind(0,timemat,Inf)
  n &lt;- length(y)
  res &lt;- sapply(1:n, function(i){
            return( c( max(tm[i,][tm[i,] &lt; y[i]]), min(tm[i,][tm[i,] &gt;= y[i]]) ) ) } )
  return(t(res))
}



# ------------------------
#  interval censored data
# ------------------------

set.seed(20)
n &lt;- 100
# generate exact data:
y &lt;- rgamma(n,3)
# generate matrix of inspection times:
itimes &lt;- matrix(rexp(10*n),n,10)
itimes &lt;- t(apply(itimes,1,cumsum))
# transform exact data to interval data
x &lt;- censor(y, itimes)
# plot both
plotint(x, imarks=y)

# Compute censored log-concave MLE
# (assuming only the censored data is available to us)
res &lt;- logcon(x)
plot(res)

# Compare it to the log-concave MLE for the exact data
# and to the true Gamma(3,1) log-density
res.ex &lt;- logcon(y)
lines(res.ex$x, res.ex$phi, lwd=2.5, lty=2)
xi &lt;- seq(0,14,0.05)
lines(xi,log(dgamma(xi,3,1)), col=3, lwd=2)



# -------------------------
#  censored data with cure
# -------------------------

## Not run: 
set.seed(21)
n &lt;- 100
# generate exact data:
y &lt;- rgamma(n,3)
cured &lt;- as.logical(rbinom(n,1,0.3))
y[cured] &lt;- Inf

# generate matrix of inspection times:
itimes &lt;- matrix(rexp(6*n),n,6)
itimes &lt;- t(apply(itimes,1,cumsum))
# transform exact data to interval data
x &lt;- censor(y, itimes)
# plot both
plotint(x, imarks=y)

# Compute censored log-concave MLE including cure parameter
# (assuming only the censored data is available to us)
res &lt;- logcon(x, adapt.p0=TRUE)
plot(res)
# There is a trade-off between right-hand slope and cure parameter here
# (seen by the grey area on the right), but the margin is very small:
res$cure.range

# Compare the corresponding CDF to the true CDF
plot(res, type="CDF")
xi &lt;- seq(0,14,0.05)
lines(xi,0.7*pgamma(xi,3,1), col=3, lwd=2)
# Note that the trade-off for the right-hand slope is not visible anymore 
# (in terms of the CDF the effect is too small)

## End(Not run)



# ------------------------------------
#  real right censored data with cure
# ------------------------------------

# Look at data set ovarian from package survival
# Gives survival times in days for 26 patients with advanced ovarian carcinoma,
# ignoring the covariates

# Bring data to right format and plot it
## Not run: 
library(survival)
data(ovarian)
sobj &lt;- Surv(ovarian$futime, ovarian$fustat)
x &lt;- cbind(sobj[,1], ifelse(as.logical(sobj[,2]),sobj[,1],Inf))
plotint(x)

# Compute censored log-concave MLE including cure parameter
res &lt;- logcon(x, adapt.p0=TRUE)

# Compare the corresponding survival function to the Kaplan-Meier estimator
plot(res, type="survival")
res.km &lt;- survfit(sobj ~ 1)
lines(res.km, lwd=1.5)
## End(Not run)



# ----------------------
#  current status data
# ----------------------

## Not run: 
set.seed(22)
n &lt;- 200
# generate exact data
y &lt;- rweibull(n,2,1)
# generate vector of inspection times
itime &lt;- matrix(rexp(n),n,1)
# transform exact data to interval data
x &lt;- censor(y, itime)
# plot both
plotint(x, imarks=y)

# Compute censored log-concave MLE
# (assuming only the censored data is available to us)
res &lt;- logcon(x)
plot(res, type="CDF")

# Compare it to the true Weibull(2,1) c.d.f.
xi &lt;- seq(0,3,0.05)
lines(xi,pweibull(xi,2,1), col=3, lwd=2)
## End(Not run)



# ----------------------
#  rounded/binned data
# ----------------------

## Not run: 
set.seed(23)
n &lt;- 100
# generate data in [0,1] rounded to one digit
y &lt;- round(rbeta(n,2,3),1)
# bring data to right format and plot it
x &lt;- cbind(y-0.05,y+0.05)
plotint(x)

# Compute censored log-concave MLE
res &lt;- logcon(x)
plot(res, type="density", xlim=c(0,1))

# Compare it to the true Beta(2,3) density
xi &lt;- seq(0,1,0.005)
lines(xi,dbeta(xi,2,3), col=3, lwd=2)
# The peaks in the estimated density are often considered unsatisfactory
# However, they are barely noticeable in the c.d.f.
plot(res, type="CDF", xlim=c(0,1))
lines(xi,pbeta(xi,2,3), col=3, lwd=2)

# To get rid of them in the density apply the smoothing
# proposed in the package logcondens (to be implemented here)
## End(Not run)
</code></pre>

<hr>
<h2 id='logconcens-internal'>Internal logconcens Functions</h2><span id='topic+GetWeights'></span><span id='topic+J00'></span><span id='topic+J10'></span><span id='topic+clc.fixdom'></span><span id='topic+subdivisor'></span><span id='topic+phidivisor'></span>

<h3>Description</h3>

<p>Internal logconcens functions, usually not to be called by the user.</p>


<h3>Usage</h3>

<pre><code class='language-R'>GetWeights(preweights,tplus, p0, xindex, rightinf, phi, phislr, needsl)
J00(x, y, v = 1)
J10(x, y)
clc.fixdom(x, preweights=rep(1,dim(x)[1]), minw=0,
   p0, adapt.p0 = FALSE, reduce=TRUE, red.thresh=NULL,
   check.red=TRUE, force.inf=FALSE, tau, subdivide, domind1, 
   domind2, maxiter=60, knot.prec=IQR(x[x&lt;Inf])/75,
   move.prec=1e-5, show=TRUE, verbose=FALSE)
subdivisor(j, tau, eps = 0.01)
phidivisor(j, tau, phi, eps=0.01)
</code></pre>


<h3>Details</h3>

<p>These functions are not exported any more and this overview remains in place purely for information.</p>


<h3>Author(s)</h3>

<p>Dominic Schuhmacher <a href="mailto:dominic.schuhmacher@mathematik.uni-goettingen.de">dominic.schuhmacher@mathematik.uni-goettingen.de</a><br />
Kaspar Rufibach <a href="mailto:kaspar.rufibach@gmail.com">kaspar.rufibach@gmail.com</a><br />
Lutz Duembgen <a href="mailto:duembgen@stat.unibe.ch">duembgen@stat.unibe.ch</a>
</p>

<hr>
<h2 id='logconcens-package'>
Maximum Likelihood Estimation of a Log-Concave Density Based on Censored Data 
</h2><span id='topic+logconcens-package'></span><span id='topic+logconcens'></span>

<h3>Description</h3>

<p>Based on independent intervals <code class="reqn">X_i = [L_i,R_i]</code>, where <code class="reqn">-\infty &lt; L_i \leq R_i \leq \infty</code>, compute the maximum likelihood estimator of a (sub)probability density under the assumption that it is log-concave. For further information see Duembgen, Rufibach, and Schuhmacher (2013).
</p>


<h3>Details</h3>

<p>The main function is <code><a href="#topic+logcon">logcon</a></code>, which offers computation of the MLE for many types of censored and also exact data. Various parameters can be set that allow for fine control of the underlying EM algorithm in &ldquo;difficult&rdquo; situations. An object of type <code>lcdensity</code> is returned, for which <code><a href="#topic+plot.lcdensity">plot</a></code>, <code><a href="#topic+print.lcdensity">print</a></code>, and <code><a href="#topic+summary.lcdensity">summary</a></code> methods are available. There is also a function <code><a href="#topic+loglike">loglike</a></code> for computing the log-likelihood of a <code>lcdensity</code> object.  
</p>


<h3>Author(s)</h3>

<p>Dominic Schuhmacher <a href="mailto:dominic.schuhmacher@mathematik.uni-goettingen.de">dominic.schuhmacher@mathematik.uni-goettingen.de</a><br />
Kaspar Rufibach <a href="mailto:kaspar.rufibach@gmail.com">kaspar.rufibach@gmail.com</a><br />
Lutz Duembgen <a href="mailto:duembgen@stat.unibe.ch">duembgen@stat.unibe.ch</a>
</p>
<p>Maintainer: Dominic Schuhmacher <a href="mailto:dominic.schuhmacher@mathematik.uni-goettingen.de">dominic.schuhmacher@mathematik.uni-goettingen.de</a><br />
</p>


<h3>References</h3>

<p>Duembgen, L., Rufibach, K., and Schuhmacher, D. (2014). Maximum-likelihood estimation of a log-concave density based on censored data. Electronic Journal of Statistics, 8(1), 1405-1437. <a href="https://doi.org/10.1214/14-EJS930">doi:10.1214/14-EJS930</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Simple examples with simulated data.
## For more detailed examples see the help for the function logcon.

## exact data
set.seed(10)
x &lt;- rnorm(100)
res &lt;- logcon(x)
## Not run: 
plot(res)
xi &lt;- seq(-3,3,0.05)
lines(xi,log(dnorm(xi)))
## End(Not run)

## interval censored data
x &lt;- rgamma(50,3,1)
x &lt;- cbind(x,x+rexp(50,1))
plotint(x)
res &lt;- logcon(x)
## Not run: plot(res, type="CDF")

## right censored data with mass at infinity
set.seed(11)
x &lt;- rgamma(50,3,1)
x &lt;- cbind(x,ifelse(rexp(50,1/3) &lt; x,Inf,x))
plotint(x)
res &lt;- logcon(x,adapt.p0=TRUE)
## Not run: plot(res, type="survival")

## rounded/binned data
set.seed(12)
x &lt;- round(rnorm(100))
x &lt;- cbind(x-0.5,x+0.5)
plotint(x)
res &lt;- logcon(x)
## Not run: 
plot(res)
xi &lt;- seq(-3,3,0.05)
lines(xi,log(dnorm(xi)))
## End(Not run)
</code></pre>

<hr>
<h2 id='loglike'>
Compute Log-Likelihood for an Object of Class <code>lcdensity</code>
</h2><span id='topic+loglike'></span>

<h3>Description</h3>

<p>Compute the (normalized) log-likelihood for an object of class <code>lcdensity</code> as described in the details section for the function <code><a href="#topic+logcon">logcon</a></code>. The main use of this function is for comparing different results from <code>logcon</code> based on different (starting) domains.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>loglike(lcd)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="loglike_+3A_lcd">lcd</code></td>
<td>
<p>an object of class <code>lcdensity</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A single numeric value, the (normalized) log-likelihood.
</p>


<h3>Author(s)</h3>

<p>Dominic Schuhmacher <a href="mailto:dominic.schuhmacher@mathematik.uni-goettingen.de">dominic.schuhmacher@mathematik.uni-goettingen.de</a><br />
Kaspar Rufibach <a href="mailto:kaspar.rufibach@gmail.com">kaspar.rufibach@gmail.com</a><br />
Lutz Duembgen <a href="mailto:duembgen@stat.unibe.ch">duembgen@stat.unibe.ch</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+logcon">logcon</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  x &lt;- matrix(c(0,0.5,0.5,1,1,2,3,3),4,2)
  res &lt;- logcon(x)
  loglike(res)
</code></pre>

<hr>
<h2 id='plotint'>
Plot Censored Data
</h2><span id='topic+plotint'></span>

<h3>Description</h3>

<p>Plot a graphical representation of censored data specified by a two-column matrix of left and right interval endpoints. The grid of potential knots used by <code>logcon</code> is also shown.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotint(x, knot.prec = IQR(x[x&lt;Inf])/75, imarks = NULL) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotint_+3A_x">x</code></td>
<td>

<p>a two-column matrix of left and right endpoints of data intervals.
</p>
</td></tr>
<tr><td><code id="plotint_+3A_knot.prec">knot.prec</code></td>
<td>

<p>the maximal distance between two consecutive grid points in the depiction of the grid used by
<code>logcon</code>.
</p>
</td></tr>
<tr><td><code id="plotint_+3A_imarks">imarks</code></td>
<td>

<p>an optional vector of &ldquo;spots&rdquo; to be marked by &lsquo;x&rsquo; for the intervals.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Used for the side effect.
</p>


<h3>Author(s)</h3>

<p>Dominic Schuhmacher <a href="mailto:dominic.schuhmacher@mathematik.uni-goettingen.de">dominic.schuhmacher@mathematik.uni-goettingen.de</a><br />
Kaspar Rufibach <a href="mailto:kaspar.rufibach@gmail.com">kaspar.rufibach@gmail.com</a><br />
Lutz Duembgen <a href="mailto:duembgen@stat.unibe.ch">duembgen@stat.unibe.ch</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.lcdensity">plot.lcdensity</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## See the examples for logcon
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
