<!DOCTYPE html><html><head><title>Help for package BNPdensity</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {BNPdensity}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#acidity'><p>Acidity Index Dataset</p></a></li>
<li><a href='#add'><p>Add x and y</p></a></li>
<li><a href='#as.mcmc.multNRMI'><p>Convert the output of multMixNRMI into a coda mcmc object</p></a></li>
<li><a href='#asNumeric_no_warning'><p>If the function Rmpfr::asNumeric returns a warning about inefficiency, silence it.</p></a></li>
<li><a href='#BNPdensity-package'><p>Bayesian nonparametric density estimation</p></a></li>
<li><a href='#cens_data_check'><p>Censoring data check</p></a></li>
<li><a href='#censor_code_rl'><p>Censor code right-left</p></a></li>
<li><a href='#comment_on_NRMI_type'><p>Comment on the NRMI process depending on the value of the parameters</p></a></li>
<li><a href='#comp1'><p>Ties function: univariate</p></a></li>
<li><a href='#comp2'><p>Ties function: bivariate</p></a></li>
<li><a href='#compute_optimal_clustering'><p>Compute the optimal clustering from an MCMC sample</p></a></li>
<li><a href='#compute_thinning_grid'><p>Compute the grid for thinning the MCMC chain</p></a></li>
<li><a href='#convert_to_mcmc'><p>Convert the output of multMixNRMI into a coda mcmc object</p></a></li>
<li><a href='#cpo'><p>Conditional predictive ordinate function</p></a></li>
<li><a href='#cpo.multNRMI'><p>Extract the Conditional Predictive Ordinates (CPOs) from a list of fitted objects</p></a></li>
<li><a href='#cpo.NRMI1'><p>Extract the Conditional Predictive Ordinates (CPOs) from a fitted object</p></a></li>
<li><a href='#cpo.NRMI2'><p>Extract the Conditional Predictive Ordinates (CPOs) from a fitted object</p></a></li>
<li><a href='#dhalfcauchy'><p>Density half Cauchy</p></a></li>
<li><a href='#dhalfnorm'><p>Density half normal</p></a></li>
<li><a href='#dhalft'><p>Density half Student-t</p></a></li>
<li><a href='#dist_name_k_index_converter'><p>Convert distribution names to indices</p></a></li>
<li><a href='#dk'><p>Kernel density function</p></a></li>
<li><a href='#dkcens2'><p>Density of the chosen kernel</p></a></li>
<li><a href='#dkcens2_1val'><p>Density evaluation once</p></a></li>
<li><a href='#dt_'><p>Non-standard student-t density</p></a></li>
<li><a href='#dtnorm'><p>Density truncated normal</p></a></li>
<li><a href='#enzyme'><p>Enzyme Dataset</p></a></li>
<li><a href='#Enzyme1.out'><p>Fit of MixNRMI1 function to the enzyme dataset</p></a></li>
<li><a href='#Enzyme2.out'><p>Fit of MixNRMI2 function to the enzyme dataset</p></a></li>
<li><a href='#expected_number_of_components_Dirichlet'><p>Computes the expected number of components for a Dirichlet process.</p></a></li>
<li><a href='#expected_number_of_components_stable'><p>Computes the expected number of components for a stable process.</p></a></li>
<li><a href='#fcondXA'><p>Conditional density evaluation in the semiparametric model</p></a></li>
<li><a href='#fcondXA2'><p>Conditional density evaluation in the fully nonparametric model</p></a></li>
<li><a href='#fcondXA2cens2'><p>Conditional density evaluation in the fully nonparametric model for censored</p>
data</a></li>
<li><a href='#fcondYXA'><p>Conditional posterior distribution of the latents Y</p></a></li>
<li><a href='#fcondYXAcens2'><p>Conditional posterior distribution of the latents Y in the censoring case</p></a></li>
<li><a href='#fcondYZXA'><p>Conditional posterior distribution of the bivariate latents (Y,Z)</p></a></li>
<li><a href='#fcondYZXAcens2'><p>Conditional posterior distribution of the bivariate latents (Y,Z) in the</p>
case of censoring</a></li>
<li><a href='#fill_sigmas'><p>Repeat the common scale parameter of a semiparametric model to match the</p>
dimension of the location parameters.</a></li>
<li><a href='#galaxy'><p>Galaxy Data Set</p></a></li>
<li><a href='#Galaxy1.out'><p>Fit of MixNRMI1 function to the galaxy dataset</p></a></li>
<li><a href='#Galaxy2.out'><p>Fit of MixNRMI2 function to the galaxy dataset</p></a></li>
<li><a href='#give_kernel_name'><p>Gives the kernel name from the integer code</p></a></li>
<li><a href='#GOFplots'><p>Plot Goodness of fits graphical checks for censored data</p></a></li>
<li><a href='#GOFplots_censored'><p>Plot Goodness of fits graphical checks for censored data</p></a></li>
<li><a href='#GOFplots_noncensored'><p>Plot Goodness of fits graphical checks for non censored data</p></a></li>
<li><a href='#grid_from_data'><p>Create a plotting grid from censored or non-censored data.</p></a></li>
<li><a href='#grid_from_data_censored'><p>Create a plotting grid from censored data.</p></a></li>
<li><a href='#grid_from_data_noncensored'><p>Create a plotting grid from non-censored data.</p></a></li>
<li><a href='#gs3'><p>Conditional posterior distribution of latent U</p></a></li>
<li><a href='#gs3_adaptive3'><p>Conditional posterior distribution of latent U</p></a></li>
<li><a href='#gs3_log'><p>Conditional posterior distribution of latent logU</p></a></li>
<li><a href='#gs4'><p>Resampling Ystar function</p></a></li>
<li><a href='#gs4cens2'><p>Resampling Ystar function in the case of censoring</p></a></li>
<li><a href='#gs5'><p>Conditional posterior distribution of sigma</p></a></li>
<li><a href='#gs5cens2'><p>Conditional posterior distribution of sigma in the case of censoring</p></a></li>
<li><a href='#gsHP'><p>Updates the hyper-parameters of py0</p></a></li>
<li><a href='#gsYZstar'><p>Jointly resampling Ystar and Zstar function</p></a></li>
<li><a href='#gsYZstarcens2'><p>Jointly resampling Ystar and Zstar function in the case of censoring</p></a></li>
<li><a href='#is_censored'><p>Test if the data is censored</p></a></li>
<li><a href='#is_semiparametric'><p>Tests if a fit is a semi parametric or nonparametric model.</p></a></li>
<li><a href='#logacceptance_ratio_logu'><p>Metropolis-Hastings ratio for the conditional of logU</p></a></li>
<li><a href='#logdprop_logu'><p>Contribution of the proposal kernel logdensity to the Metropolis-Hastings ratio</p></a></li>
<li><a href='#logf_logu_cond_y'><p>Contribution of the target logdensity of logU to the Metropolis-Hastings ratio</p></a></li>
<li><a href='#logf_u_cond_y'><p>Target logdensity of U given the data</p></a></li>
<li><a href='#MixNRMI1'><p>Normalized Random Measures Mixture of Type I</p></a></li>
<li><a href='#MixNRMI1cens'><p>Normalized Random Measures Mixture of Type I for censored data</p></a></li>
<li><a href='#MixNRMI2'><p>Normalized Random Measures Mixture of Type II</p></a></li>
<li><a href='#MixNRMI2cens'><p>Normalized Random Measures Mixture of Type II for censored data</p></a></li>
<li><a href='#MixPY1'><p>Pitman-Yor process mixture  of Type I</p></a></li>
<li><a href='#MixPY2'><p>Pitman-Yor process mixture  of Type II</p></a></li>
<li><a href='#multMixNRMI1'><p>Multiple chains of MixNRMI1</p></a></li>
<li><a href='#multMixNRMI1cens'><p>Multiple chains of MixNRMI1cens</p></a></li>
<li><a href='#multMixNRMI2'><p>Multiple chains of MixNRMI2</p></a></li>
<li><a href='#multMixNRMI2cens'><p>Multiple chains of MixNRMI2cens</p></a></li>
<li><a href='#Mv'><p>Continuous Jump heights function</p></a></li>
<li><a href='#MvInv'><p>Invert jump heights function</p></a></li>
<li><a href='#p0'><p>Centering function</p></a></li>
<li><a href='#phalfcauchy'><p>Distribution function half Cauchy</p></a></li>
<li><a href='#phalfnorm'><p>Distribution function half Normal</p></a></li>
<li><a href='#phalft'><p>Distribution function half Student-t</p></a></li>
<li><a href='#pk'><p>Kernel distribution function</p></a></li>
<li><a href='#plot_clustering_and_CDF'><p>Plot the clustering and the Cumulative Distribution Function</p></a></li>
<li><a href='#plot_prior_number_of_components'><p>This plots the prior distribution on the number of components for the stable</p>
process. The Dirichlet process is provided for comparison.</a></li>
<li><a href='#plot.multNRMI'><p>Plot the density estimate and the 95% credible interval</p></a></li>
<li><a href='#plot.NRMI1'><p>Plot the density estimate and the 95% credible interval</p></a></li>
<li><a href='#plot.NRMI2'><p>Plot the density estimate and the 95% credible interval</p></a></li>
<li><a href='#plot.PY1'><p>Plot the density estimate and the 95% credible interval</p></a></li>
<li><a href='#plot.PY2'><p>Plot the density estimate and the 95% credible interval</p></a></li>
<li><a href='#plotCDF_censored'><p>Plot the Turnbull CDF and fitted CDF for censored data.</p></a></li>
<li><a href='#plotCDF_noncensored'><p>Plot the empirical and fitted CDF for non censored data.</p></a></li>
<li><a href='#plotfit_censored'><p>Plot the density estimate and the 95% credible interval for censored data</p></a></li>
<li><a href='#plotfit_noncensored'><p>Plot the density estimate and the 95% credible interval for noncensored</p>
data</a></li>
<li><a href='#plotPDF_censored'><p>Plot the density for censored data.</p></a></li>
<li><a href='#plotPDF_noncensored'><p>Plot the density and a histogram for non censored data.</p></a></li>
<li><a href='#pp_plot_censored'><p>Plot the percentile-percentile graph for non censored data, using the</p>
Turnbull estimator the position of the percentiles.</a></li>
<li><a href='#pp_plot_noncensored'><p>Plot the percentile-percentile graph for non censored data.</p></a></li>
<li><a href='#print.multNRMI'><p>S3 method for class 'multNRMI'</p></a></li>
<li><a href='#print.NRMI1'><p>S3 method for class 'MixNRMI1'</p></a></li>
<li><a href='#print.NRMI2'><p>S3 method for class 'MixNRMI2'</p></a></li>
<li><a href='#print.PY1'><p>S3 method for class 'PY1'</p></a></li>
<li><a href='#print.PY2'><p>S3 method for class 'PY2'</p></a></li>
<li><a href='#process_dist_name'><p>Process the distribution name argument into a distribution index</p></a></li>
<li><a href='#pt_'><p>Distribution function non-standard student-t</p></a></li>
<li><a href='#ptnorm'><p>Distribution function truncated normal</p></a></li>
<li><a href='#qgeneric'><p>Generic function to find quantiles of a distribution</p></a></li>
<li><a href='#qhalfcauchy'><p>Quantile function half Cauchy</p></a></li>
<li><a href='#qhalfnorm'><p>Quantile function half Normal</p></a></li>
<li><a href='#qhalft'><p>Quantile function half Student-t</p></a></li>
<li><a href='#qq_plot_censored'><p>Plot the quantile-quantile graph for censored data.</p></a></li>
<li><a href='#qq_plot_noncensored'><p>Plot the quantile-quantile graph for non censored data.</p></a></li>
<li><a href='#qt_'><p>Quantile function non-standard Student-t</p></a></li>
<li><a href='#qtnorm'><p>Quantile function truncated normal</p></a></li>
<li><a href='#rfystar'><p>Conditional posterior distribution of the distinct Ystar</p></a></li>
<li><a href='#rfystarcens2'><p>Conditional posterior distribution of the distinct Ystar in the case of</p>
censoring</a></li>
<li><a href='#rfyzstar'><p>Conditional posterior distribution of the distinct vectors (Ystar,Zstar)</p></a></li>
<li><a href='#rfyzstarcens2'><p>Conditional posterior distribution of the distinct vectors (Ystar,Zstar) in</p>
the case of censoring</a></li>
<li><a href='#rhalfcauchy'><p>Random number generator half Cauchy</p></a></li>
<li><a href='#rhalfnorm'><p>Random number generator half Normal</p></a></li>
<li><a href='#rhalft'><p>Random number generator half Student-t</p></a></li>
<li><a href='#rk'><p>Kernel density sampling function</p></a></li>
<li><a href='#rprop_logu'><p>Proposal distribution for logU</p></a></li>
<li><a href='#rt_'><p>Random number generator non-standard Student-t</p></a></li>
<li><a href='#rtnorm'><p>Random number generator for a truncated normal distribution</p></a></li>
<li><a href='#salinity'><p>Salinity tolerance</p></a></li>
<li><a href='#summary.multNRMI'><p>S3 method for class 'multNRMI'</p></a></li>
<li><a href='#summary.NRMI1'><p>S3 method for class 'MixNRMI1'</p></a></li>
<li><a href='#summary.NRMI2'><p>S3 method for class 'MixNRMI2'</p></a></li>
<li><a href='#summary.PY1'><p>S3 method for class 'PY1'</p></a></li>
<li><a href='#summary.PY2'><p>S3 method for class 'PY2'</p></a></li>
<li><a href='#summarytext'><p>Common text for the summary S3 methods</p></a></li>
<li><a href='#thresholdGG'><p>Choosing the truncation level for the NGG process</p></a></li>
<li><a href='#traceplot'><p>Draw a traceplot for multiple chains</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Ferguson-Klass Type Algorithm for Posterior Normalized Random
Measures</td>
</tr>
<tr>
<td>Version:</td>
<td>2023.3.8</td>
</tr>
<tr>
<td>Description:</td>
<td>Bayesian nonparametric density estimation modeling mixtures by a Ferguson-Klass type algorithm for posterior normalized random measures.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>yes</td>
</tr>
<tr>
<td>ByteCompile:</td>
<td>yes</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Depends:</td>
<td>R(&ge; 3.5.0)</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Guillaume Kon Kam King &lt;guillaume.konkamking.work@gmail.com&gt;</td>
</tr>
<tr>
<td>Imports:</td>
<td>ggplot2, gridExtra, survival, coda, dplyr, tidyr, viridis</td>
</tr>
<tr>
<td>Suggests:</td>
<td>GreedyEPL, Rmpfr, gmp, knitr, rmarkdown, testthat, BNPmix</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-03-24 14:47:00 UTC; gkonkamking</td>
</tr>
<tr>
<td>Author:</td>
<td>Julyan Arbel [ctb],
  Ernesto Barrios [aut],
  Guillaume Kon Kam King [aut, cre],
  Antonio Lijoi [aut],
  Luis E. Nieto-Barajas [aut],
  Igor Prünster [aut]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-03-24 15:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='acidity'>Acidity Index Dataset</h2><span id='topic+acidity'></span>

<h3>Description</h3>

<p>Concerns an acidity index measured in a sample of 155 lakes in north-central
Wisconsin.
</p>


<h3>Format</h3>

<p>A real vector with 155 observations.
</p>


<h3>References</h3>

<p>Crawford, S. L., DeGroot, M. H., Kadane, J. B. and Small, M. J.
(1992). Modeling lake chemistry distributions: approximate Bayesian methods
for estimating a finite mixture model. Technometrics, 34, 441-453.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(acidity)
hist(acidity)
</code></pre>

<hr>
<h2 id='add'>Add x and y</h2><span id='topic+add'></span>

<h3>Description</h3>

<p>This is a helper function for use in Reduce() over a list of vectors
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add(x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_+3A_x">x</code></td>
<td>
<p>first argument of the sum</p>
</td></tr>
<tr><td><code id="add_+3A_y">y</code></td>
<td>
<p>second argument of the sum</p>
</td></tr>
</table>


<h3>Value</h3>

<p>x + y
</p>

<hr>
<h2 id='as.mcmc.multNRMI'>Convert the output of multMixNRMI into a coda mcmc object</h2><span id='topic+as.mcmc.multNRMI'></span>

<h3>Description</h3>

<p>Convert the output of multMixNRMI into a coda mcmc object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'multNRMI'
as.mcmc(x, ..., thinning_to = 1000, ncores = parallel::detectCores())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.mcmc.multNRMI_+3A_x">x</code></td>
<td>
<p>Output of multMixNRMI.</p>
</td></tr>
<tr><td><code id="as.mcmc.multNRMI_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed to specific methods</p>
</td></tr>
<tr><td><code id="as.mcmc.multNRMI_+3A_thinning_to">thinning_to</code></td>
<td>
<p>Final length of the chain after thinning.</p>
</td></tr>
<tr><td><code id="as.mcmc.multNRMI_+3A_ncores">ncores</code></td>
<td>
<p>Specify the number of cores to use in the conversion</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a coda::mcmc object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(acidity)
out &lt;- multMixNRMI1(acidity, parallel = TRUE, Nit = 10, ncores = 2)
coda::as.mcmc(out, ncores = 2)
</code></pre>

<hr>
<h2 id='asNumeric_no_warning'>If the function Rmpfr::asNumeric returns a warning about inefficiency, silence it.</h2><span id='topic+asNumeric_no_warning'></span>

<h3>Description</h3>

<p>The function Rmpfr::asNumeric prints the following warning: In asMethod(object) : coercing &quot;mpfr1&quot; via &quot;mpfr&quot; (inefficient). It is not clear how to avoid it nor how to silence it, hence this function.
A cleaner solution may be available at: https://stackoverflow.com/questions/4948361/how-do-i-save-warnings-and-errors-as-output-from-a-function/4952908#4952908
</p>


<h3>Usage</h3>

<pre><code class='language-R'>asNumeric_no_warning(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="asNumeric_no_warning_+3A_x">x</code></td>
<td>
<p>An object of class Rmpfr::mpfr1</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a &quot;numeric&quot; number
</p>

<hr>
<h2 id='BNPdensity-package'>Bayesian nonparametric density estimation</h2><span id='topic+BNPdensity-package'></span><span id='topic+BNPdensity'></span>

<h3>Description</h3>

<p>This package performs Bayesian nonparametric density estimation for exact
and censored data via a normalized random measure mixture model. The package
allows the user to specify the mixture kernel, the mixing normalized measure
and the choice of performing fully nonparametric mixtures on locations and
scales, or semiparametric mixtures on locations only with common scale
parameter. Options for the kernels are: two kernels with support in the real
line (gaussian and double exponential), two more kernels in the positive
line (gamma and lognormal) and one with bounded support (beta). The options
for the normalized random measures are members of the class of normalized
generalized gamma, which include the Dirichlet process, the normalized
inverse gaussian process and the normalized stable process.  The type of
censored data handled by the package is right, left and interval.
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;"> Package: </td><td style="text-align: left;"> BNPdensity</td>
</tr>
<tr>
 <td style="text-align: left;"> Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;"> Version:
</td><td style="text-align: left;"> 2016.10</td>
</tr>
<tr>
 <td style="text-align: left;"> Date: </td><td style="text-align: left;"> 2016-10-14</td>
</tr>
<tr>
 <td style="text-align: left;"> License: </td><td style="text-align: left;"> GPL version 2 or
later</td>
</tr>
<tr>
 <td style="text-align: left;"> LazyLoad: </td><td style="text-align: left;"> yes</td>
</tr>
<tr>
 <td style="text-align: left;"> </td>
</tr>

</table>
<p> The package includes four main functions:
MixNRMI1, MixNRMI2, MixNRMI1cens and MixNRMI2cens which implement
semiparametric and fully nonparametric mixtures for exact data, and
semiparametric and fully nonparametric mixtures for censored data
respectively. Additionally, the package includes several other functions
required for sampling from conditional distributions in the MCMC
implementation. These functions are intended for internal use only.
</p>


<h3>Author(s)</h3>

<p>Barrios, E., Lijoi, A., Nieto-Barajas, L. E. and Prünster, I.;
Contributor: Guillaume Kon Kam King.; Maintainer: Ernesto Barrios &lt;ebarrios
at itam.mx&gt;
</p>


<h3>References</h3>

<p>Barrios, E., Lijoi, A., Nieto-Barajas, L. E. and Prünster, I.
(2013). Modeling with Normalized Random Measure Mixture Models. Statistical
Science. Vol. 28, No. 3, 313-334.
</p>
<p>Kon Kam King, G., Arbel, J. and Prünster, I. (2016). Species Sensitivity
Distribution revisited: a Bayesian nonparametric approach. In preparation.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+MixNRMI1">MixNRMI1</a></code>, <code><a href="#topic+MixNRMI2">MixNRMI2</a></code>,
<code><a href="#topic+MixNRMI1cens">MixNRMI1cens</a></code>, <code><a href="#topic+MixNRMI2cens">MixNRMI2cens</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
example(MixNRMI1)
example(MixNRMI2)
example(MixNRMI1cens)
example(MixNRMI2cens)
</code></pre>

<hr>
<h2 id='cens_data_check'>Censoring data check</h2><span id='topic+cens_data_check'></span>

<h3>Description</h3>

<p>Checks that a censored dataset is valid. This performs two checks: check that the dataset does not contain only NA, and check that the for interval censored data, the bounds are in the right order.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cens_data_check(xleft, xright)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cens_data_check_+3A_xleft">xleft</code></td>
<td>
<p>left bounds for the censored dataset. Can be a real number or NA</p>
</td></tr>
<tr><td><code id="cens_data_check_+3A_xright">xright</code></td>
<td>
<p>right bounds for the censored dataset</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For internal use
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## The function is currently defined as
function(xleft, xright) {
  if (any(xright &lt; xleft, na.rm = T)) {
    stop("in censored data, left bound not always smaller than right bound")
  }
  if (any(mapply(FUN = function(xileft, xiright) {
    is.na(xileft) &amp; is.na(xiright)
  }, xleft, xright))) {
    stop("in censored data, there is an NA NA")
  }
}
</code></pre>

<hr>
<h2 id='censor_code_rl'>Censor code right-left</h2><span id='topic+censor_code_rl'></span>

<h3>Description</h3>

<p>Creates censoring code 0:3.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>censor_code_rl(left, right)
</code></pre>


<h3>Details</h3>

<p>For internal use
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## The function is currently defined as
function(left, right) {
  test_ &lt;- function(k) {
    if (is.na(left[[k]]) &amp; is.na(right[[k]])) {
      NA
    } else if (is.na(left[[k]])) {
      2
    } else if (is.na(right[[k]])) {
      0
    } else if (left[[k]] == right[[k]]) {
      1
    } else {
      3
    }
  }
  sapply(seq_along(left), FUN = test_)
}
</code></pre>

<hr>
<h2 id='comment_on_NRMI_type'>Comment on the NRMI process depending on the value of the parameters</h2><span id='topic+comment_on_NRMI_type'></span>

<h3>Description</h3>

<p>Comment on the NRMI process depending on the value of the parameters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>comment_on_NRMI_type(NRMI_param = list(Alpha = 1, Kappa = 0, Gamma = 0.4))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="comment_on_NRMI_type_+3A_nrmi_param">NRMI_param</code></td>
<td>
<p>A named list of the form list(&quot;Alpha&quot; = 1, &quot;Kappa&quot; = 0, &quot;Gamma&quot; = 0.4)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A string containing a comment on the NRMI process
</p>


<h3>Examples</h3>

<pre><code class='language-R'>BNPdensity:::comment_on_NRMI_type(list("Alpha" = 1, "Kappa" = 0, "Gamma" = 0.4))
BNPdensity:::comment_on_NRMI_type(list("Alpha" = 1, "Kappa" = 0.1, "Gamma" = 0.4))
BNPdensity:::comment_on_NRMI_type(list("Alpha" = 1, "Kappa" = 0.1, "Gamma" = 0.5))
</code></pre>

<hr>
<h2 id='comp1'>Ties function: univariate</h2><span id='topic+comp1'></span>

<h3>Description</h3>

<p>This function computes the distinct observations and their frequencies in a
numeric vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>comp1(y)
</code></pre>


<h3>Details</h3>

<p>For internal use.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## The function is currently defined as
function(y) {
  n &lt;- length(y)
  mat &lt;- outer(y, y, "==")
  jstar &lt;- led &lt;- rep(FALSE, n)
  for (j in seq(n)) {
    if (!led[j]) {
      jstar[j] &lt;- TRUE
      if (j == n) {
        break
      }
      ji &lt;- seq(j + 1, n)
      tt &lt;- mat[ji, j] %in% TRUE
      led[ji] &lt;- led[ji] | tt
    }
    if (all(led[-seq(j)])) {
      break
    }
  }
  ystar &lt;- y[jstar]
  nstar &lt;- apply(mat[, jstar], 2, sum)
  r &lt;- length(nstar)
  idx &lt;- match(y, ystar)
  return(list(ystar = ystar, nstar = nstar, r = r, idx = idx))
}
</code></pre>

<hr>
<h2 id='comp2'>Ties function: bivariate</h2><span id='topic+comp2'></span>

<h3>Description</h3>

<p>This function computes the distinct observations (couples) and their
frequencies in a bivariate numeric vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>comp2(y, z)
</code></pre>


<h3>Details</h3>

<p>For internal use.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## The function is currently defined as
function(y, z) {
  if (length(y) != length(z)) {
    stop("Vectors y and z should have equal length!")
  }
  n &lt;- length(y)
  matY &lt;- outer(y, y, "==")
  matZ &lt;- outer(z, z, "==")
  mat &lt;- matY &amp; matZ
  jstar &lt;- led &lt;- rep(FALSE, n)
  for (j in seq(n)) {
    if (!led[j]) {
      jstar[j] &lt;- TRUE
      if (j == n) {
        break
      }
      ji &lt;- seq(j + 1, n)
      tt &lt;- mat[ji, j] %in% TRUE
      led[ji] &lt;- led[ji] | tt
    }
    if (all(led[-seq(j)])) {
      break
    }
  }
  ystar &lt;- y[jstar]
  zstar &lt;- z[jstar]
  nstar &lt;- apply(mat[, jstar], 2, sum)
  rstar &lt;- length(nstar)
  idx &lt;- match(y, ystar)
  return(list(
    ystar = ystar, zstar = zstar, nstar = nstar,
    rstar = rstar, idx = idx
  ))
}
</code></pre>

<hr>
<h2 id='compute_optimal_clustering'>Compute the optimal clustering from an MCMC sample</h2><span id='topic+compute_optimal_clustering'></span>

<h3>Description</h3>

<p>Summarizes the posterior on all possible clusterings by an optimal
clustering where optimality is defined as minimizing the posterior
expectation of a specific loss function, the Variation of Information or
Binder's loss function. Computation can be lengthy for large datasets,
because of the large size of the space of all clusterings.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_optimal_clustering(fit, loss_type = "VI")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute_optimal_clustering_+3A_fit">fit</code></td>
<td>
<p>The fitted object, obtained from one of the MixNRMIx functions</p>
</td></tr>
<tr><td><code id="compute_optimal_clustering_+3A_loss_type">loss_type</code></td>
<td>
<p>Defines the loss function to be used in the expected
posterior loss minimization. Can be one of &quot;VI&quot; (Variation of Information),
&quot;B&quot; (Binder's loss), &quot;NVI&quot; (Normalized Variation of Information) or &quot;NID&quot;
(Normalized Information Distance). Defaults to &quot;VI&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of integers with the same size as the data, indicating the
allocation of each data point.
</p>

<hr>
<h2 id='compute_thinning_grid'>Compute the grid for thinning the MCMC chain</h2><span id='topic+compute_thinning_grid'></span>

<h3>Description</h3>

<p>This function creates an real grid then rounds it. If the grid is fine
enough, there is a risk that rounding ties, i.e. iteration which are kept
twice. To avoid this, if the total number of iterations is smaller than
twice the number of iterations desired after thinning, the chain is not
thinned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_thinning_grid(Nit, thinning_to = 10)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute_thinning_grid_+3A_nit">Nit</code></td>
<td>
<p>Length of the MCMC chain</p>
</td></tr>
<tr><td><code id="compute_thinning_grid_+3A_thinning_to">thinning_to</code></td>
<td>
<p>Desired number of iterations after thinning.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an integer vector of the MCMC iterations retained.
</p>

<hr>
<h2 id='convert_to_mcmc'>Convert the output of multMixNRMI into a coda mcmc object</h2><span id='topic+convert_to_mcmc'></span>

<h3>Description</h3>

<p>Convert the output of multMixNRMI into a coda mcmc object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convert_to_mcmc(fitlist, thinning_to = 1000, ncores = parallel::detectCores())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="convert_to_mcmc_+3A_fitlist">fitlist</code></td>
<td>
<p>Output of multMixNRMI.</p>
</td></tr>
<tr><td><code id="convert_to_mcmc_+3A_thinning_to">thinning_to</code></td>
<td>
<p>Final length of the chain after thinning.</p>
</td></tr>
<tr><td><code id="convert_to_mcmc_+3A_ncores">ncores</code></td>
<td>
<p>Specify the number of cores to use in the conversion</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a coda::mcmc object
</p>

<hr>
<h2 id='cpo'>Conditional predictive ordinate function</h2><span id='topic+cpo'></span>

<h3>Description</h3>

<p>This function computes conditional predictive ordinates for each data point.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cpo(object, ...)

cpo(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cpo_+3A_object">object</code></td>
<td>
<p>A fit obtained through one of the NRMI functions</p>
</td></tr>
<tr><td><code id="cpo_+3A_...">...</code></td>
<td>
</td></tr>
</table>


<h3>Details</h3>

<p>For internal use.
</p>


<h3>Value</h3>

<p>A vector of Conditional Predictive Ordinates (CPOs)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## The function is currently defined as
function(obj) {
  fx &lt;- obj$fx
  cpo &lt;- 1 / apply(1 / fx, 1, mean)
  return(cpo)
}
</code></pre>

<hr>
<h2 id='cpo.multNRMI'>Extract the Conditional Predictive Ordinates (CPOs) from a list of fitted objects</h2><span id='topic+cpo.multNRMI'></span>

<h3>Description</h3>

<p>This function assumes that all chains have the same size. To allow for different chain sizes, care should be paid to proper weighting.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'multNRMI'
cpo(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cpo.multNRMI_+3A_object">object</code></td>
<td>
<p>A fit obtained through from the functions MixNRMI1/MixNRMI1cens</p>
</td></tr>
<tr><td><code id="cpo.multNRMI_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed to generic function, ignored at the moment</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of Conditional Predictive Ordinates (CPOs)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(acidity)
out &lt;- multMixNRMI1(acidity, parallel = TRUE, Nit = 10, ncores = 2)
cpo(out)
</code></pre>

<hr>
<h2 id='cpo.NRMI1'>Extract the Conditional Predictive Ordinates (CPOs) from a fitted object</h2><span id='topic+cpo.NRMI1'></span>

<h3>Description</h3>

<p>Extract the Conditional Predictive Ordinates (CPOs) from a fitted object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'NRMI1'
cpo(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cpo.NRMI1_+3A_object">object</code></td>
<td>
<p>A fit obtained through from the functions MixNRMI1/MixNRMI1cens</p>
</td></tr>
<tr><td><code id="cpo.NRMI1_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed to generic function, ignored at the moment</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of Conditional Predictive Ordinates (CPOs)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(acidity)
out &lt;- MixNRMI1(acidity, Nit = 50)
cpo(out)
</code></pre>

<hr>
<h2 id='cpo.NRMI2'>Extract the Conditional Predictive Ordinates (CPOs) from a fitted object</h2><span id='topic+cpo.NRMI2'></span>

<h3>Description</h3>

<p>Extract the Conditional Predictive Ordinates (CPOs) from a fitted object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'NRMI2'
cpo(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cpo.NRMI2_+3A_object">object</code></td>
<td>
<p>A fit obtained through from the function MixNRMI2/MixNRMI2cens</p>
</td></tr>
<tr><td><code id="cpo.NRMI2_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed to generic function, ignored at the moment</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of Conditional Predictive Ordinates (CPOs)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(acidity)
out &lt;- MixNRMI2(acidity, Nit = 50)
cpo(out)
</code></pre>

<hr>
<h2 id='dhalfcauchy'>Density half Cauchy</h2><span id='topic+dhalfcauchy'></span>

<h3>Description</h3>

<p>Computes the density.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dhalfcauchy(x, location = 0, scale = 1)
</code></pre>


<h3>Details</h3>

<p>For internal use
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## The function is currently defined as
function(x, location = 0, scale = 1) {
  ifelse(x &lt; 0, 0, 1) * dcauchy(x, location, scale) / (1 - pcauchy(
    0,
    location, scale
  ))
}
</code></pre>

<hr>
<h2 id='dhalfnorm'>Density half normal</h2><span id='topic+dhalfnorm'></span>

<h3>Description</h3>

<p>Computes the density.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dhalfnorm(x, mean = 0, sd = 1)
</code></pre>


<h3>Details</h3>

<p>For internal use
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## The function is currently defined as
function(x, mean = 0, sd = 1) {
  ifelse(x &lt; 0, 0, 1) * dnorm(x, mean, sd) / (1 - pnorm(
    0, mean,
    sd
  ))
}
</code></pre>

<hr>
<h2 id='dhalft'>Density half Student-t</h2><span id='topic+dhalft'></span>

<h3>Description</h3>

<p>Computes the density.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dhalft(x, df = 1, mean = 0, sd = 1)
</code></pre>


<h3>Details</h3>

<p>For internal use
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## The function is currently defined as
function(x, df = 1, mean = 0, sd = 1) {
  ifelse(x &lt; 0, 0, 1) * dt_(x, df, mean, sd) / (1 - pt_(
    0, df,
    mean, sd
  ))
}
</code></pre>

<hr>
<h2 id='dist_name_k_index_converter'>Convert distribution names to indices</h2><span id='topic+dist_name_k_index_converter'></span>

<h3>Description</h3>

<p>Convert distribution names to indices
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dist_name_k_index_converter(distname)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dist_name_k_index_converter_+3A_distname">distname</code></td>
<td>
<p>a character representing the distribution name. Allowed names are &quot;normal&quot;, &quot;gamma&quot;, &quot;beta&quot;, &quot;exponential&quot;, &quot;double exponential&quot;, &quot;lognormal&quot;, &quot;half-Cauchy&quot;, &quot;half-normal&quot;, &quot;half-student&quot;, &quot;uniform&quot; and &quot;truncated normal&quot;, or their common abbreviations &quot;norm&quot;, &quot;exp&quot;, &quot;lnorm&quot;, &quot;halfcauchy&quot;, &quot;halfnorm&quot;, &quot;halft&quot; and &quot;unif&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an index describing the distribution. 1 = Normal; 2
= Gamma; 3 = Beta; 4 = Double Exponential; 5 = Lognormal, 6 = Half-Cauchy, 7 = Half-normal, 8 = Half-Student, 9 = Uniform, 10 = Truncated normal
</p>

<hr>
<h2 id='dk'>Kernel density function</h2><span id='topic+dk'></span>

<h3>Description</h3>

<p>This functions evaluates a density at a certain data point.  There are 4
density options (1 (normal), 2 (gamma), 3 (beta), 4 (exponential), 5 (lognormal), 6 (half-Cauchy), 7 (half-normal), 8 (half-student), 9 (uniform) and 10 (truncated normal)). All densities are parameterized in terms of mean and standard
deviation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dk(x, distr = NULL, mu = NULL, sigma = NULL)
</code></pre>


<h3>Details</h3>

<p>For internal use.
</p>

<hr>
<h2 id='dkcens2'>Density of the chosen kernel</h2><span id='topic+dkcens2'></span>

<h3>Description</h3>

<p>Computes likelihood contribution for censored data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dkcens2(xleft, xright, c_code_filters, distr = NULL, mu = NULL, sigma = NULL)
</code></pre>


<h3>Details</h3>

<p>For internal use
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## The function is currently defined as
function(xleft, xright, c_code_filters, distr = NULL, mu = NULL,
         sigma = NULL) {
  res &lt;- seq_along(xleft)
  res[c_code_filters[["1"]]] &lt;- dk(
    x = xleft[c_code_filters[["1"]]],
    distr, mu, sigma
  )
  res[c_code_filters[["2"]]] &lt;- pk(
    xright[c_code_filters[["2"]]],
    distr, mu, sigma
  )
  res[c_code_filters[["0"]]] &lt;- 1 - pk(
    xleft[c_code_filters[["0"]]],
    distr, mu, sigma
  )
  res[c_code_filters[["3"]]] &lt;- pk(
    xright[c_code_filters[["3"]]],
    distr, mu, sigma
  ) - pk(
    xleft[c_code_filters[["3"]]],
    distr, mu, sigma
  )
  return(res)
}
</code></pre>

<hr>
<h2 id='dkcens2_1val'>Density evaluation once</h2><span id='topic+dkcens2_1val'></span>

<h3>Description</h3>

<p>Computes the likelihood contribution for one data point in the case of
censoring.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dkcens2_1val(xleft, xright, c_code, distr = NULL, mu = NULL, sigma = NULL)
</code></pre>


<h3>Details</h3>

<p>For internal use
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## The function is currently defined as
function(xleft, xright, c_code, distr = NULL, mu = NULL, sigma = NULL) {
  if (c_code == 1) {
    dk(x = xleft, distr, mu, sigma)
  } else if (c_code == 2) {
    pk(xright, distr, mu, sigma)
  } else if (c_code == 0) {
    1 - pk(xleft, distr, mu, sigma)
  } else if (c_code == 3) {
    pk(xright, distr, mu, sigma) - pk(xleft, distr, mu, sigma)
  } else {
    stop("Wrong integer code for censored data")
  }
}
</code></pre>

<hr>
<h2 id='dt_'>Non-standard student-t density</h2><span id='topic+dt_'></span>

<h3>Description</h3>

<p>Computes the density.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dt_(x, df, mean, sd)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dt__+3A_x">x</code></td>
<td>
<p>Numeric vector. Data set to which the density is evaluated.</p>
</td></tr>
<tr><td><code id="dt__+3A_df">df</code></td>
<td>
<p>Numeric constant. Degrees of freedom (&gt; 0, maybe non-integer)</p>
</td></tr>
<tr><td><code id="dt__+3A_mean">mean</code></td>
<td>
<p>Numeric constant. Location parameter.</p>
</td></tr>
<tr><td><code id="dt__+3A_sd">sd</code></td>
<td>
<p>Positive numeric constant. Scale parameter.
</p>
<p>## The function is currently defined as
function(x, df, mean, sd) 
dt((x - mean) / sd, df, ncp = 0) / sd
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For internal use
</p>

<hr>
<h2 id='dtnorm'>Density truncated normal</h2><span id='topic+dtnorm'></span>

<h3>Description</h3>

<p>Computes the density.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dtnorm(x, mean = 0, sd = 1, lower = -Inf, upper = Inf, log = FALSE)
</code></pre>


<h3>Details</h3>

<p>For internal use
</p>


<h3>Note</h3>

<p>Taken from <code>msm</code> R-package.
</p>


<h3>Author(s)</h3>

<p>C. H. Jackson
</p>


<h3>References</h3>

<p>Taken from
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## The function is currently defined as
function(x, mean = 0, sd = 1, lower = -Inf, upper = Inf, log = FALSE) {
  ret &lt;- numeric(length(x))
  ret[x &lt; lower | x &gt; upper] &lt;- if (log) {
    -Inf
  } else {
    0
  }
  ret[upper &lt; lower] &lt;- NaN
  ind &lt;- x &gt;= lower &amp; x &lt;= upper
  if (any(ind)) {
    denom &lt;- pnorm(upper, mean, sd) - pnorm(
      lower, mean,
      sd
    )
    xtmp &lt;- dnorm(x, mean, sd, log)
    if (log) {
      xtmp &lt;- xtmp - log(denom)
    } else {
      xtmp &lt;- xtmp / denom
    }
    ret[x &gt;= lower &amp; x &lt;= upper] &lt;- xtmp[ind]
  }
  ret
}
</code></pre>

<hr>
<h2 id='enzyme'>Enzyme Dataset</h2><span id='topic+enzyme'></span>

<h3>Description</h3>

<p>Concerns the distribution of enzymatic activity in the blood, for an enzyme
involved in the metabolism of carcinogenetic substances, among a group of
245 unrelated individuals.
</p>


<h3>Format</h3>

<p>A data frame with 244 observations on the following variable:
</p>
 <dl>
<dt>list(&quot;enzyme&quot;)</dt><dd><p>A numeric vector.</p>
</dd> </dl>



<h3>References</h3>

<p>Bechtel, Y. C., Bonaiti-Pellie, C., Poisson, N., Magnette, J.
and Bechtel, P.R. (1993). A population and family study of
N-acetyltransferase using caffeine urinary metabolites. Clin. Pharm. Therp.,
54, 134-141.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(enzyme)
hist(enzyme)
</code></pre>

<hr>
<h2 id='Enzyme1.out'>Fit of MixNRMI1 function to the enzyme dataset</h2><span id='topic+Enzyme1.out'></span>

<h3>Description</h3>

<p>This object contains the output when setting set.seed(150520) and running
the function Enzyme1.out &lt;- MixNRMI1(enzyme, Alpha = 1, Kappa = 0.007, Gama = 0.5, distr.k = &quot;gamma&quot;, distr.p0 = &quot;gamma&quot;, asigma = 1, bsigma = 1, Meps = 0.005, Nit = 5000, Pbi = 0.2)
</p>


<h3>Details</h3>

<p>See function MixNRMI1
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(Enzyme1.out)
</code></pre>

<hr>
<h2 id='Enzyme2.out'>Fit of MixNRMI2 function to the enzyme dataset</h2><span id='topic+Enzyme2.out'></span>

<h3>Description</h3>

<p>This object contains the output when setting set.seed(150520) and running
the function Enzyme2.out &lt;- MixNRMI2(enzyme, Alpha = 1, Kappa = 0.007, Gama = 0.5, distr.k = &quot;gamma&quot;, distr.py0 = &quot;gamma&quot;, distr.pz0 = &quot;gamma&quot;, mu.pz0 = 1, sigma.pz0 = 1, Meps = 0.005, Nit = 5000, Pbi = 0.2)
See function MixNRMI2
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(Enzyme2.out)
</code></pre>

<hr>
<h2 id='expected_number_of_components_Dirichlet'>Computes the expected number of components for a Dirichlet process.</h2><span id='topic+expected_number_of_components_Dirichlet'></span>

<h3>Description</h3>

<p>Computes the expected number of components for a Dirichlet process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expected_number_of_components_Dirichlet(
  n,
  Alpha,
  ntrunc = NULL,
  silence = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="expected_number_of_components_Dirichlet_+3A_n">n</code></td>
<td>
<p>Number of data points</p>
</td></tr>
<tr><td><code id="expected_number_of_components_Dirichlet_+3A_alpha">Alpha</code></td>
<td>
<p>Numeric constant. Total mass of the centering measure.</p>
</td></tr>
<tr><td><code id="expected_number_of_components_Dirichlet_+3A_ntrunc">ntrunc</code></td>
<td>
<p>Level of truncation when computing the expectation. Defaults
to n. If greater than n, it is fixed to n.</p>
</td></tr>
<tr><td><code id="expected_number_of_components_Dirichlet_+3A_silence">silence</code></td>
<td>
<p>Boolean. Whether to print the current calculation step for the Stable process, as the function can be long</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A real value which approximates the expected number of components
</p>
<p>Reference: P. De Blasi, S. Favaro, A. Lijoi, R. H. Mena, I. Prünster, and M.
Ruggiero, “Are Gibbs-type priors the most natural generalization of the
Dirichlet process?,” IEEE Trans. Pattern Anal. Mach. Intell., vol. 37, no.
2, pp. 212–229, 2015.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
expected_number_of_components_Dirichlet(100, 1.2)
</code></pre>

<hr>
<h2 id='expected_number_of_components_stable'>Computes the expected number of components for a stable process.</h2><span id='topic+expected_number_of_components_stable'></span>

<h3>Description</h3>

<p>Computes the expected number of components for a stable process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expected_number_of_components_stable(n, Gama, ntrunc = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="expected_number_of_components_stable_+3A_n">n</code></td>
<td>
<p>Number of data points</p>
</td></tr>
<tr><td><code id="expected_number_of_components_stable_+3A_gama">Gama</code></td>
<td>
<p>Numeric constant. 0 &lt;= Gama &lt;=1.</p>
</td></tr>
<tr><td><code id="expected_number_of_components_stable_+3A_ntrunc">ntrunc</code></td>
<td>
<p>Level of truncation when computing the expectation. Defaults
to n. If greater than n, it is fixed to n.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A real value of type mpfr1 which approximates the expected number of
components
</p>
<p>In spite of the high precision arithmetic packages used for in function, it
can be numerically unstable for small values of Gama. This is because
evaluating a sum with alternated signs, in the generalized factorial
coefficients, is tricky. Reference: P. De Blasi, S. Favaro, A. Lijoi, R. H.
Mena, I. Prünster, and M. Ruggiero, “Are gibbs-type priors the most natural
generalization of the Dirichlet process?,” IEEE Trans. Pattern Anal. Mach.
Intell., vol. 37, no. 2, pp. 212–229, 2015.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
expected_number_of_components_stable(100, 0.8)
</code></pre>

<hr>
<h2 id='fcondXA'>Conditional density evaluation in the semiparametric model</h2><span id='topic+fcondXA'></span>

<h3>Description</h3>

<p>This function evaluates a density path conditionally on a posterior
realization of the normalized measure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fcondXA(x, distr, Tau, J, sigma)
</code></pre>


<h3>Details</h3>

<p>For internal use.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## The function is currently defined as
function(x, distr = 1, Tau, J, sigma) {
  pJ &lt;- J / sum(J)
  K &lt;- matrix(NA, nrow = length(Tau), ncol = length(x))
  for (i in seq(Tau)) {
    K[i, ] &lt;- dk(x, distr = distr, mu = Tau[i], sigma = sigma)
  }
  fcondXA &lt;- apply(K, 2, function(x) sum(x * pJ))
  return(fcondXA)
}
</code></pre>

<hr>
<h2 id='fcondXA2'>Conditional density evaluation in the fully nonparametric model</h2><span id='topic+fcondXA2'></span>

<h3>Description</h3>

<p>This function evaluates a density path conditionally on a posterior
realization of the normalized measure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fcondXA2(x, distr, Tauy, Tauz, J)
</code></pre>


<h3>Details</h3>

<p>For internal use.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## The function is currently defined as
function(x, distr = 1, Tauy, Tauz, J) {
  pJ &lt;- J / sum(J)
  K &lt;- matrix(NA, nrow = length(Tauy), ncol = length(x))
  for (i in seq(Tauy)) {
    K[i, ] &lt;- dk(x, distr = distr, mu = Tauy[i], sigma = Tauz[i])
  }
  fcondXA2 &lt;- apply(K, 2, function(x) sum(x * pJ))
  return(fcondXA2)
}
</code></pre>

<hr>
<h2 id='fcondXA2cens2'>Conditional density evaluation in the fully nonparametric model for censored
data</h2><span id='topic+fcondXA2cens2'></span>

<h3>Description</h3>

<p>This function evaluates a density path conditionally on a posterior
realization of the normalized measure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fcondXA2cens2(xleft, xright, censor_code_filters, distr, Tauy, Tauz, J)
</code></pre>


<h3>Details</h3>

<p>For internal use
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## The function is currently defined as
function(xleft, xright, censor_code_filters, distr, Tauy, Tauz,
         J) {
  pJ &lt;- J / sum(J)
  K &lt;- matrix(NA, nrow = length(Tauy), ncol = length(xleft))
  for (i in seq(Tauy)) {
    K[i, ] &lt;- dkcens2(
      xleft = xleft, xright = xright, c_code_filters = censor_code_filters,
      distr = distr, mu = Tauy[i], sigma = Tauz[i]
    )
  }
  fcondXA2cens &lt;- apply(K, 2, function(x) sum(x * pJ))
  return(fcondXA2cens)
}
</code></pre>

<hr>
<h2 id='fcondYXA'>Conditional posterior distribution of the latents Y</h2><span id='topic+fcondYXA'></span>

<h3>Description</h3>

<p>This function simulates form the conditional posterior distribution of the
latents Y.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fcondYXA(x, distr, Tau, J, sigma)
</code></pre>


<h3>Details</h3>

<p>For internal use.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## The function is currently defined as
function(x, distr = 1, Tau, J, sigma) {
  K &lt;- matrix(NA, nrow = length(Tau), ncol = length(x))
  for (i in seq(Tau)) {
    K[i, ] &lt;- dk(x, distr = distr, mu = Tau[i], sigma = sigma) *
      J[i]
  }
  pK &lt;- prop.table(K, margin = 2)
  y &lt;- apply(pK, 2, function(x) sample(Tau, size = 1, prob = x))
  return(y)
}
</code></pre>

<hr>
<h2 id='fcondYXAcens2'>Conditional posterior distribution of the latents Y in the censoring case</h2><span id='topic+fcondYXAcens2'></span>

<h3>Description</h3>

<p>This function simulates form the conditional posterior distribution of the
latents Y.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fcondYXAcens2(xleft, xright, censor_code_filters, distr, Tau, J, sigma)
</code></pre>


<h3>Details</h3>

<p>For internal use
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## The function is currently defined as
function(xleft, xright, censor_code_filters, distr, Tau, J,
         sigma) {
  K &lt;- matrix(NA, nrow = length(Tau), ncol = length(xleft))
  for (i in seq(Tau)) {
    K[i, ] &lt;- dkcens2(
      xleft = xleft, xright = xright, c_code_filters = censor_code_filters,
      distr = distr, mu = Tau[i], sigma = sigma
    ) * J[i]
  }
  pK &lt;- prop.table(K, margin = 2)
  y &lt;- apply(pK, 2, function(x) sample(Tau, size = 1, prob = x))
  return(y)
}
</code></pre>

<hr>
<h2 id='fcondYZXA'>Conditional posterior distribution of the bivariate latents (Y,Z)</h2><span id='topic+fcondYZXA'></span>

<h3>Description</h3>

<p>This function simulates form the conditional posterior distribution of the
latents (Y,Z).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fcondYZXA(x, distr, Tauy, Tauz, J)
</code></pre>


<h3>Details</h3>

<p>For internal use.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## The function is currently defined as
function(x, distr = 1, Tauy, Tauz, J) {
  K &lt;- matrix(NA, nrow = length(Tauy), ncol = length(x))
  for (i in seq(Tauy)) {
    K[i, ] &lt;- dk(x, distr = distr, mu = Tauy[i], sigma = Tauz[i]) *
      J[i]
  }
  if (any(is.na(K))) {
    print(K, Tauy, Tauz, J)
  }
  pK &lt;- prop.table(K, margin = 2)
  j &lt;- apply(pK, 2, function(x) {
    sample(length(Tauy),
      size = 1,
      prob = x
    )
  })
  return(matrix(c(y = Tauy[j], z = Tauz[j]),
    nrow = length(x),
    ncol = 2
  ))
}
</code></pre>

<hr>
<h2 id='fcondYZXAcens2'>Conditional posterior distribution of the bivariate latents (Y,Z) in the
case of censoring</h2><span id='topic+fcondYZXAcens2'></span>

<h3>Description</h3>

<p>This function simulates form the conditional posterior distribution of the
latents (Y,Z).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fcondYZXAcens2(xleft, xright, censor_code_filters, distr, Tauy, Tauz, J)
</code></pre>


<h3>Details</h3>

<p>For internal use
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## The function is currently defined as
function(xleft, xright, censor_code_filters, distr, Tauy, Tauz,
         J) {
  K &lt;- matrix(NA, nrow = length(Tauy), ncol = length(xleft))
  for (i in seq(Tauy)) {
    K[i, ] &lt;- dkcens2(xleft, xright,
      c_code_filters = censor_code_filters,
      distr = distr, mu = Tauy[i], sigma = Tauz[i]
    ) * J[i]
  }
  if (any(is.na(K))) {
    print(K, Tauy, Tauz, J)
  }
  pK &lt;- prop.table(K, margin = 2)
  j &lt;- apply(pK, 2, function(x) {
    sample(length(Tauy),
      size = 1,
      prob = x
    )
  })
  return(matrix(c(y = Tauy[j], z = Tauz[j]),
    nrow = length(xleft),
    ncol = 2
  ))
}
</code></pre>

<hr>
<h2 id='fill_sigmas'>Repeat the common scale parameter of a semiparametric model to match the
dimension of the location parameters.</h2><span id='topic+fill_sigmas'></span>

<h3>Description</h3>

<p>Repeat the common scale parameter of a semiparametric model to match the
dimension of the location parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fill_sigmas(semiparametric_fit)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fill_sigmas_+3A_semiparametric_fit">semiparametric_fit</code></td>
<td>
<p>The result of the fit, obtained through the
function MixNRMI1.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an adequate list of vectors of sigmas
</p>

<hr>
<h2 id='galaxy'>Galaxy Data Set</h2><span id='topic+galaxy'></span>

<h3>Description</h3>

<p>Velocities of 82 galaxies diverging from our own galaxy.
</p>


<h3>Format</h3>

<p>A data frame with 82 observations on the following variable:
</p>
 <dl>
<dt>list(&quot;velocity&quot;)</dt><dd><p>A numeric vector.</p>
</dd> </dl>



<h3>References</h3>

<p>Roeder, K. (1990) &quot;Density estimation with confidence sets
exemplified by superclusters and voids in the galaxies&quot;. Journal of the
American Statistical Association. 85, 617-624.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(galaxy)
hist(galaxy)
</code></pre>

<hr>
<h2 id='Galaxy1.out'>Fit of MixNRMI1 function to the galaxy dataset</h2><span id='topic+Galaxy1.out'></span>

<h3>Description</h3>

<p>This object contains the output when setting set.seed(150520) and running
the function MixNRMI1(galaxy, Alpha = 1, Kappa = 0.015, Gama = 0.5, distr.k = &quot;normal&quot;, distr.p0 = &quot;gamma&quot;, asigma = 1, bsigma = 1, delta = 7, Meps = 0.005, Nit = 5000, Pbi = 0.2)
</p>


<h3>Details</h3>

<p>See function MixNRMI1.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(Galaxy1.out)
</code></pre>

<hr>
<h2 id='Galaxy2.out'>Fit of MixNRMI2 function to the galaxy dataset</h2><span id='topic+Galaxy2.out'></span>

<h3>Description</h3>

<p>This object contains the output when setting set.seed(150520) and running
the function Enzyme2.out &lt;- MixNRMI2(x, Alpha = 1, Kappa = 0.007, Gama = 0.5, distr.k = &quot;gamma&quot;, distr.py0 = &quot;gamma&quot;, distr.pz0 = &quot;gamma&quot;, mu.pz0 = 1, sigma.pz0 = 1, Meps = 0.005, Nit = 5000, Pbi = 0.2)
</p>


<h3>Details</h3>

<p>See function MixNRMI2.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(Galaxy2.out)
</code></pre>

<hr>
<h2 id='give_kernel_name'>Gives the kernel name from the integer code</h2><span id='topic+give_kernel_name'></span>

<h3>Description</h3>

<p>This function is used in the print methods for MixNRMI1, MixNRMI2, MixNRMI1cens, MixNRMI2cens, and all the multMixNRMIx versions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>give_kernel_name(distr.k)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="give_kernel_name_+3A_distr.k">distr.k</code></td>
<td>
<p>The distribution name for the kernel. Allowed names are &quot;normal&quot;, &quot;gamma&quot;, &quot;beta&quot;, &quot;double exponential&quot;, &quot;lognormal&quot; or their common abbreviations &quot;norm&quot;, &quot;exp&quot;, or an integer number identifying the mixture kernel: 1 = Normal; 2 = Gamma; 3 = Beta; 4 = Double Exponential; 5 = Lognormal.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character with the name of the distribution used as the kernel
</p>


<h3>Examples</h3>

<pre><code class='language-R'>BNPdensity:::give_kernel_name(4)
</code></pre>

<hr>
<h2 id='GOFplots'>Plot Goodness of fits graphical checks for censored data</h2><span id='topic+GOFplots'></span>

<h3>Description</h3>

<p>Plot Goodness of fits graphical checks for censored data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GOFplots(fit, qq_plot = FALSE, thinning_to = 500)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GOFplots_+3A_fit">fit</code></td>
<td>
<p>The result of the fit, obtained through the function MixNRMI1 or
MixNRMI2, MixMRMI1cens or MixMRMI2cens</p>
</td></tr>
<tr><td><code id="GOFplots_+3A_qq_plot">qq_plot</code></td>
<td>
<p>Whether to compute the QQ-plot</p>
</td></tr>
<tr><td><code id="GOFplots_+3A_thinning_to">thinning_to</code></td>
<td>
<p>How many iterations to compute the mean posterior
quantiles</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A density plot, a cumulative density plot with the Turnbull
cumulative distribution, a percentile-percentile plot, and potentially a
quantile-quantile plot.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(150520)
data(salinity)
out &lt;- MixNRMI1cens(salinity$left, salinity$right, extras = TRUE, Nit = 100)
GOFplots(out)
</code></pre>

<hr>
<h2 id='GOFplots_censored'>Plot Goodness of fits graphical checks for censored data</h2><span id='topic+GOFplots_censored'></span>

<h3>Description</h3>

<p>Plot Goodness of fits graphical checks for censored data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GOFplots_censored(fit, qq_plot = FALSE, thinning_to = 500)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GOFplots_censored_+3A_fit">fit</code></td>
<td>
<p>The result of the fit, obtained through the function MixNRMI1 or
MixNRMI2, MixMRMI1cens or MixMRMI2cens</p>
</td></tr>
<tr><td><code id="GOFplots_censored_+3A_qq_plot">qq_plot</code></td>
<td>
<p>Whether to compute the QQ-plot</p>
</td></tr>
<tr><td><code id="GOFplots_censored_+3A_thinning_to">thinning_to</code></td>
<td>
<p>How many iterations to compute the mean posterior
quantiles</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A density plot, a cumulative density plot with the Turnbull
cumulative distribution, and a percentile-percentile plot.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(150520)
data(salinty)
out &lt;- MixNRMI1cens(salinity$left, salinity$right, extras = TRUE, Nit = 100)
BNPdensity:::GOFplots_censored(out)
</code></pre>

<hr>
<h2 id='GOFplots_noncensored'>Plot Goodness of fits graphical checks for non censored data</h2><span id='topic+GOFplots_noncensored'></span>

<h3>Description</h3>

<p>Plot Goodness of fits graphical checks for non censored data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GOFplots_noncensored(fit, qq_plot = FALSE, thinning_to = 500)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GOFplots_noncensored_+3A_fit">fit</code></td>
<td>
<p>The result of the fit, obtained through the function MixNRMI1 or
MixNRMI2, MixMRMI1cens or MixMRMI2cens</p>
</td></tr>
<tr><td><code id="GOFplots_noncensored_+3A_qq_plot">qq_plot</code></td>
<td>
<p>Whether to compute the QQ-plot</p>
</td></tr>
<tr><td><code id="GOFplots_noncensored_+3A_thinning_to">thinning_to</code></td>
<td>
<p>How many iterations to compute the mean posterior
quantiles</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A density plot with histogram, a cumulative density plot with the
empirical cumulative distribution, and a percentile-percentile plot.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(150520)
data(acidity)
out &lt;- MixNRMI1(acidity, extras = TRUE, Nit = 100)
BNPdensity:::GOFplots_noncensored(out)
</code></pre>

<hr>
<h2 id='grid_from_data'>Create a plotting grid from censored or non-censored data.</h2><span id='topic+grid_from_data'></span>

<h3>Description</h3>

<p>Create a plotting grid from censored or non-censored data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grid_from_data(data, npoints = 100)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="grid_from_data_+3A_data">data</code></td>
<td>
<p>Input data from which to compute the grid.</p>
</td></tr>
<tr><td><code id="grid_from_data_+3A_npoints">npoints</code></td>
<td>
<p>Number of points on the grid.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector containing the plotting grid
</p>

<hr>
<h2 id='grid_from_data_censored'>Create a plotting grid from censored data.</h2><span id='topic+grid_from_data_censored'></span>

<h3>Description</h3>

<p>Create a plotting grid from censored data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grid_from_data_censored(data, npoints = 100)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="grid_from_data_censored_+3A_data">data</code></td>
<td>
<p>Censored input data from which to compute the grid.</p>
</td></tr>
<tr><td><code id="grid_from_data_censored_+3A_npoints">npoints</code></td>
<td>
<p>Number of points on the grid.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector containing the plotting grid
</p>

<hr>
<h2 id='grid_from_data_noncensored'>Create a plotting grid from non-censored data.</h2><span id='topic+grid_from_data_noncensored'></span>

<h3>Description</h3>

<p>Create a plotting grid from non-censored data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grid_from_data_noncensored(data, npoints = 100)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="grid_from_data_noncensored_+3A_data">data</code></td>
<td>
<p>Non-censored input data from which to compute the grid.</p>
</td></tr>
<tr><td><code id="grid_from_data_noncensored_+3A_npoints">npoints</code></td>
<td>
<p>Number of points on the grid.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector containing the plotting grid
</p>

<hr>
<h2 id='gs3'>Conditional posterior distribution of latent U</h2><span id='topic+gs3'></span>

<h3>Description</h3>

<p>This function simulates from the conditional posterior distribution of the
latent U.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gs3(ut, n, r, alpha, kappa, gama, delta)
</code></pre>


<h3>Details</h3>

<p>For internal use.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## The function is currently defined as
function(ut, n = 200, r = 20, alpha = 1, kappa = 1, gama = 1 / 2,
         delta = 2) {
  w &lt;- ut
  ratio &lt;- NaN
  while (is.nan(ratio)) {
    v &lt;- ustar &lt;- rgamma(1, shape = delta, rate = delta / ut)
    vw &lt;- v / w
    vb &lt;- v + kappa
    wb &lt;- w + kappa
    A &lt;- vw^(n - 2 * delta)
    B &lt;- (vb / wb)^(r * gama - n)
    D &lt;- vb^gama - wb^gama
    E &lt;- 1 / vw - vw
    ratio &lt;- A * B * exp(-alpha / gama * D - delta * E)
  }
  p &lt;- min(1, ratio)
  u &lt;- ifelse(runif(1) &lt;= p, ustar, ut)
  return(u)
}
</code></pre>

<hr>
<h2 id='gs3_adaptive3'>Conditional posterior distribution of latent U</h2><span id='topic+gs3_adaptive3'></span>

<h3>Description</h3>

<p>This function simulates from the conditional posterior distribution of the
latent U, with an adaptive proposal
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gs3_adaptive3(ut, n, r, alpha, kappa, gama, delta, U, iter, adapt = FALSE)
</code></pre>

<hr>
<h2 id='gs3_log'>Conditional posterior distribution of latent logU</h2><span id='topic+gs3_log'></span>

<h3>Description</h3>

<p>This function simulates from the conditional posterior distribution of a log transformation of the
latent U.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gs3_log(logut, n, r, alpha, kappa, gama, delta)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gs3_log_+3A_logut">logut</code></td>
<td>
<p>Real, log of the latent variable U at the current iteration.</p>
</td></tr>
<tr><td><code id="gs3_log_+3A_n">n</code></td>
<td>
<p>Integer, number of data points.</p>
</td></tr>
<tr><td><code id="gs3_log_+3A_r">r</code></td>
<td>
<p>Integer, number of clusters.</p>
</td></tr>
<tr><td><code id="gs3_log_+3A_alpha">alpha</code></td>
<td>
<p>Positive real. Total mass of the centering measure.</p>
</td></tr>
<tr><td><code id="gs3_log_+3A_kappa">kappa</code></td>
<td>
<p>Positive real. A parameter of the NRMI process.</p>
</td></tr>
<tr><td><code id="gs3_log_+3A_gama">gama</code></td>
<td>
<p>Real. <code class="reqn">0\leq \texttt{gama} \leq 1</code>.  See details.</p>
</td></tr>
<tr><td><code id="gs3_log_+3A_delta">delta</code></td>
<td>
<p>Scale of the Metropolis-Hastings proposal distribution</p>
</td></tr>
</table>

<hr>
<h2 id='gs4'>Resampling Ystar function</h2><span id='topic+gs4'></span>

<h3>Description</h3>

<p>This function resamples the distinct Ystar in the semiparametric model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gs4(ystar, x, idx, distr.k, sigma.k, distr.p0, mu.p0, sigma.p0)
</code></pre>


<h3>Details</h3>

<p>For internal use.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## The function is currently defined as
function(ystar, x, idx, distr.k, sigma.k, distr.p0, mu.p0, sigma.p0) {
  r &lt;- length(ystar)
  nstar &lt;- as.numeric(table(idx))
  for (j in seq(r)) {
    id &lt;- which(!is.na(match(idx, j)))
    xj &lt;- x[id]
    xbar &lt;- sum(xj) / nstar[j]
    y2star &lt;- rk(1, distr = distr.k, mu = xbar, sigma = sigma.k / sqrt(nstar[j]))
    f.ratio &lt;- rfyzstar(y2star, ystar[j], xj,
      distr = distr.k, sigma = sigma.k,
      distr.p0 = distr.p0, mu.p0 = mu.p0, sigma.p0 = sigma.p0
    )
    k.ratio &lt;- dk(ystar[j],
      distr = distr.k,
      mu = xbar, sigma = sigma.k / sqrt(nstar[j])
    ) / dk(y2star,
      distr = distr.k, mu = xbar, sigma = sigma.k / sqrt(nstar[j])
    )
    q2 &lt;- min(1, f.ratio * k.ratio)
    ystar[j] &lt;- ifelse(runif(1) &lt;= q2, y2star, ystar[j])
  }
  return(ystar)
}
</code></pre>

<hr>
<h2 id='gs4cens2'>Resampling Ystar function in the case of censoring</h2><span id='topic+gs4cens2'></span>

<h3>Description</h3>

<p>This function resamples the distinct Ystar in the semiparametric model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gs4cens2(
  ystar,
  xleft,
  xright,
  censor_code,
  idx,
  distr.k,
  sigma.k,
  distr.p0,
  mu.p0,
  sigma.p0
)
</code></pre>


<h3>Details</h3>

<p>For internal use
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## The function is currently defined as
function(ystar, xleft, xright, censor_code, idx, distr.k, sigma.k,
         distr.p0, mu.p0, sigma.p0) {
  r &lt;- length(ystar)
  nstar &lt;- as.numeric(table(idx))
  for (j in seq(r)) {
    id &lt;- which(!is.na(match(idx, j)))
    xjleft &lt;- xleft[id]
    xjright &lt;- xright[id]
    xbar &lt;- 0.5 * sum(xjleft + xjright, na.rm = T) / nstar[j]
    y2star &lt;- rk(1, distr = distr.k, mu = xbar, sigma = sigma.k / sqrt(nstar[j]))
    f.ratio &lt;- rfystarcens2(
      v = y2star, v2 = ystar[j], xleft = xjleft,
      xright = xjright, censor_code = censor_code[id],
      distr.k = distr.k, sigma.k = sigma.k, distr.p0 = distr.p0,
      mu.p0 = mu.p0, sigma.p0 = sigma.p0
    )
    k.ratio &lt;- dk(ystar[j], distr = distr.k, mu = xbar, sigma = sigma.k / sqrt(nstar[j])) /
      dk(y2star,
        distr = distr.k, mu = xbar, sigma = sigma.k / sqrt(nstar[j])
      )
    if (!is.nan(f.ratio * k.ratio)) {
      q2 &lt;- min(1, f.ratio * k.ratio)
      ystar[j] &lt;- ifelse(runif(1) &lt;= q2, y2star, ystar[j])
    }
  }
  return(ystar)
}
</code></pre>

<hr>
<h2 id='gs5'>Conditional posterior distribution of sigma</h2><span id='topic+gs5'></span>

<h3>Description</h3>

<p>This function simulates from the conditional posterior distribution of
sigma.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gs5(sigma, x, y, distr, asigma, bsigma, delta)
</code></pre>


<h3>Details</h3>

<p>For internal use.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## The function is currently defined as
function(sigma, x, y, distr = 1, asigma = 1, bsigma = 2, delta = 4) {
  sigmaStar &lt;- rgamma(1, shape = delta, rate = delta / sigma)
  sigmaT &lt;- sigma
  qgammas &lt;- sigmaT / sigmaStar
  Qgammas &lt;- sigmaStar / sigmaT
  Term2 &lt;- qgammas^(2 * delta - 1) * exp(-delta * (qgammas -
    Qgammas))
  Kgamma &lt;- Qgammas^(asigma - 1) * exp(-bsigma * (sigmaStar -
    sigmaT))
  Prod &lt;- 1
  for (i in seq(length(x))) {
    Prod &lt;- Prod * (dk(x[i], distr = distr, mu = y[i], sigma = sigmaStar) / dk(x[i],
      distr = distr, mu = y[i], sigma = sigmaT
    ))
  }
  q3 &lt;- min(1, Kgamma * Prod * Term2)
  sigma &lt;- ifelse(runif(1) &lt;= q3, sigmaStar, sigmaT)
  return(sigma)
}
</code></pre>

<hr>
<h2 id='gs5cens2'>Conditional posterior distribution of sigma in the case of censoring</h2><span id='topic+gs5cens2'></span>

<h3>Description</h3>

<p>This function simulates from the conditional posterior distribution of
sigma.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gs5cens2(
  sigma,
  xleft,
  xright,
  censor_code,
  y,
  distr = 1,
  asigma = 1,
  bsigma = 2,
  delta = 4
)
</code></pre>


<h3>Details</h3>

<p>For internal use
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## The function is currently defined as
function(sigma, xleft, xright, censor_code, y, distr = 1, asigma = 1,
         bsigma = 2, delta = 4) {
  sigmaStar &lt;- rgamma(1, shape = delta, rate = delta / sigma)
  sigmaT &lt;- sigma
  qgammas &lt;- sigmaT / sigmaStar
  Qgammas &lt;- sigmaStar / sigmaT
  Term2 &lt;- qgammas^(2 * delta - 1) * exp(-delta * (qgammas -
    Qgammas))
  Kgamma &lt;- Qgammas^(asigma - 1) * exp(-bsigma * (sigmaStar -
    sigmaT))
  Prod &lt;- 1
  for (i in seq_along(xleft)) {
    Prod &lt;- Prod * dkcens2_1val(
      xleft = xleft[i], xright = xright[i],
      c_code = censor_code[i], distr = distr, mu = y[i],
      sigma = sigmaStar
    ) / dkcens2_1val(
      xleft = xleft[i],
      xright = xright[i], c_code = censor_code[i], distr = distr,
      mu = y[i], sigma = sigmaT
    )
  }
  q3 &lt;- min(1, Kgamma * Prod * Term2)
  sigma &lt;- ifelse(runif(1) &lt;= q3, sigmaStar, sigmaT)
  return(sigma)
}
</code></pre>

<hr>
<h2 id='gsHP'>Updates the hyper-parameters of py0</h2><span id='topic+gsHP'></span>

<h3>Description</h3>

<p>This function updates the hyper-parameters of the centering distribution
py0.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gsHP(ystar, rstar, distr)
</code></pre>


<h3>Details</h3>

<p>For internal use.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## The function is currently defined as
function(ystar, rstar, distr) {
  if (distr == 1) {
    mu0 &lt;- 0
    s0 &lt;- 0.01
    q1 &lt;- 0.1
    q2 &lt;- 0.1
    a &lt;- q1 + rstar / 2
    b &lt;- q2 + (rstar - 1) * var(ystar) / 2 + s0 * rstar * (mean(ystar) - mu0)^2 / 2 / (s0 + rstar)
    t2 &lt;- rgamma(1, shape = a, rate = b)
    a &lt;- (s0 * mu0 + sum(ystar)) / (s0 + rstar)
    b &lt;- (s0 + rstar) * t2
    t1 &lt;- rnorm(1, mean = a, sd = 1 / sqrt(b))
    mu.py0 &lt;- t1
    sigma.py0 &lt;- 1 / sqrt(t2)
  }
  else if (distr == 2) {
    q1 &lt;- 0.01
    q2 &lt;- 0.01
    t1 &lt;- rgamma(1, shape = q1 + rstar, rate = q2 + sum(ystar))
    mu.py0 &lt;- sigma.py0 &lt;- 1 / t1
  }
  else if (distr == 3) {
    q1 &lt;- 0.01
    q2 &lt;- 0.01
    t1 &lt;- rgamma(1, shape = q1 + rstar, rate = q2 - sum(log(ystar)))
    mu.py0 &lt;- t1 / (t1 + 1)
    sigma.py0 &lt;- sqrt(t1 / (t1 + 1)^2 / (t1 + 2))
  }
  else {
    stop("Argument \"distr\" should be defined numeric with possible values 1,2 or 3")
  }
  return(list(mu.py0 = mu.py0, sigma.py0 = sigma.py0))
}
</code></pre>

<hr>
<h2 id='gsYZstar'>Jointly resampling Ystar and Zstar function</h2><span id='topic+gsYZstar'></span>

<h3>Description</h3>

<p>This function resamples jointly the distinct pairs (Ystar,Zstar) in the
fully nonparametric model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gsYZstar(
  ystar,
  zstar,
  nstar,
  rstar,
  idx,
  x,
  delta,
  kappa,
  distr.k,
  distr.py0,
  mu.py0,
  sigma.py0,
  distr.pz0,
  mu.pz0,
  sigma.pz0
)
</code></pre>


<h3>Details</h3>

<p>For internal use.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## The function is currently defined as
function(ystar, zstar, nstar, rstar, idx, x, delta, kappa, distr.k,
         distr.py0, mu.py0, sigma.py0, distr.pz0, mu.pz0, sigma.pz0) {
  for (j in seq(rstar)) {
    flag &lt;- 1
    while (flag == 1) {
      id &lt;- which(!is.na(match(idx, j)))
      xj &lt;- x[id]
      xbar &lt;- sum(xj) / nstar[j]
      z2star &lt;- rk(1, distr = distr.pz0, mu = zstar[j], sigma = zstar[j] / sqrt(delta))
      y2star &lt;- rk(1, distr = distr.py0, mu = xbar, sigma = kappa * z2star / sqrt(nstar[j]))
      f.ratio &lt;- rfyzstar(y2star, ystar[j], z2star, zstar[j], xj,
        distr.k = distr.k,
        distr.py0 = distr.py0, mu.py0 = mu.py0, sigma.py0 = sigma.py0,
        distr.pz0 = distr.pz0, mu.pz0 = mu.pz0, sigma.pz0 = sigma.pz0
      )
      k.ratioNum &lt;- dk(zstar[j],
        distr = distr.pz0, mu = z2star,
        sigma = z2star / sqrt(delta)
      )
      k.ratioDen &lt;- dk(z2star,
        distr = distr.pz0, mu = zstar[j],
        sigma = zstar[j] / sqrt(delta)
      )
      k.ratio &lt;- k.ratioNum / k.ratioDen
      k.ratioNum &lt;- dk(ystar[j],
        distr = distr.py0, mu = xbar,
        sigma = kappa * zstar[j] / sqrt(nstar[j])
      )
      k.ratioDen &lt;- dk(y2star,
        distr = distr.py0, mu = xbar,
        sigma = kappa * z2star / sqrt(nstar[j])
      )
      k.ratio &lt;- k.ratio * k.ratioNum / k.ratioDen
      q2 &lt;- min(1, f.ratio * k.ratio)
      if (is.na(q2)) {
        flag &lt;- 1
      } else {
        if (runif(1) &lt;= q2) {
          ystar[j] &lt;- y2star
          zstar[j] &lt;- z2star
          flag &lt;- 0
        }
      }
    }
  }
  return(list(ystar = ystar, zstar = zstar))
}
</code></pre>

<hr>
<h2 id='gsYZstarcens2'>Jointly resampling Ystar and Zstar function in the case of censoring</h2><span id='topic+gsYZstarcens2'></span>

<h3>Description</h3>

<p>This function resamples jointly the distinct pairs (Ystar,Zstar) in the
fully nonparametric model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gsYZstarcens2(
  ystar,
  zstar,
  nstar,
  rstar,
  idx,
  xleft,
  xright,
  censor_code,
  delta,
  kappa,
  distr.k,
  distr.py0,
  mu.py0,
  sigma.py0,
  distr.pz0,
  mu.pz0,
  sigma.pz0
)
</code></pre>


<h3>Details</h3>

<p>For internal use
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## The function is currently defined as
function(ystar, zstar, nstar, rstar, idx, xleft, xright, censor_code,
         delta, kappa, distr.k, distr.py0, mu.py0, sigma.py0, distr.pz0,
         mu.pz0, sigma.pz0) {
  for (j in seq(rstar)) {
    flag &lt;- 1
    while (flag == 1) {
      id &lt;- which(!is.na(match(idx, j)))
      xjleft &lt;- xleft[id]
      xjright &lt;- xright[id]
      xbar &lt;- 0.5 * sum(xjleft + xjright, na.rm = T) / nstar[j]
      z2star &lt;- rk(1,
        distr = distr.pz0, mu = zstar[j],
        sigma = zstar[j] / sqrt(delta)
      )
      y2star &lt;- rk(1, distr = distr.py0, mu = xbar, sigma = kappa *
        z2star / sqrt(nstar[j]))
      f.ratio &lt;- rfyzstarcens2(
        v = y2star, v2 = ystar[j],
        z = z2star, z2 = zstar[j], xleft = xjleft, xright = xjright,
        censor_code = censor_code[id], distr.k = distr.k,
        distr.py0 = distr.py0, mu.py0 = mu.py0, sigma.py0 = sigma.py0,
        distr.pz0 = distr.pz0, mu.pz0 = mu.pz0, sigma.pz0 = sigma.pz0
      )
      k.ratioNum &lt;- dk(zstar[j],
        distr = distr.pz0, mu = z2star,
        sigma = z2star / sqrt(delta)
      )
      k.ratioDen &lt;- dk(z2star,
        distr = distr.pz0, mu = zstar[j],
        sigma = zstar[j] / sqrt(delta)
      )
      k.ratio &lt;- k.ratioNum / k.ratioDen
      k.ratioNum &lt;- dk(ystar[j],
        distr = distr.py0, mu = xbar,
        sigma = kappa * zstar[j] / sqrt(nstar[j])
      )
      k.ratioDen &lt;- dk(y2star,
        distr = distr.py0, mu = xbar,
        sigma = kappa * z2star / sqrt(nstar[j])
      )
      k.ratio &lt;- k.ratio * k.ratioNum / k.ratioDen
      q2 &lt;- min(1, f.ratio * k.ratio)
      if (is.na(q2)) {
        flag &lt;- 1
      }
      else {
        flag &lt;- 0
        if (runif(1) &lt;= q2) {
          ystar[j] &lt;- y2star
          zstar[j] &lt;- z2star
        }
      }
    }
  }
  return(list(ystar = ystar, zstar = zstar))
}
</code></pre>

<hr>
<h2 id='is_censored'>Test if the data is censored</h2><span id='topic+is_censored'></span>

<h3>Description</h3>

<p>Test if the data is censored
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_censored(dat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_censored_+3A_dat">dat</code></td>
<td>
<p>The dataset to be tested</p>
</td></tr>
</table>


<h3>Value</h3>

<p>TRUE if the data is censored
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(salinity)
BNPdensity:::is_censored(salinity)
</code></pre>

<hr>
<h2 id='is_semiparametric'>Tests if a fit is a semi parametric or nonparametric model.</h2><span id='topic+is_semiparametric'></span>

<h3>Description</h3>

<p>Tests if a fit is a semi parametric or nonparametric model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_semiparametric(fit)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_semiparametric_+3A_fit">fit</code></td>
<td>
<p>The result of the fit, obtained through the function MixNRMI1 or
MixNRMI2.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>TRUE if the fit is a semiparametric model
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(150520)
data(acidity)
x &lt;- enzyme
out &lt;- MixNRMI1(enzyme, extras = TRUE, Nit = 10)
BNPdensity:::is_semiparametric(out)
</code></pre>

<hr>
<h2 id='logacceptance_ratio_logu'>Metropolis-Hastings ratio for the conditional of logU</h2><span id='topic+logacceptance_ratio_logu'></span>

<h3>Description</h3>

<p>This function computes the Metropolis-Hastings ratio to decide whether to accept or reject a new value for logU.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>logacceptance_ratio_logu(logu, logu_prime, n, r, gamma, kappa, a, delta)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logacceptance_ratio_logu_+3A_logu">logu</code></td>
<td>
<p>Real, log of the latent variable U at the current iteration.</p>
</td></tr>
<tr><td><code id="logacceptance_ratio_logu_+3A_logu_prime">logu_prime</code></td>
<td>
<p>Real, log of the new proposed latent variable U.</p>
</td></tr>
<tr><td><code id="logacceptance_ratio_logu_+3A_n">n</code></td>
<td>
<p>Integer, number of data points.</p>
</td></tr>
<tr><td><code id="logacceptance_ratio_logu_+3A_r">r</code></td>
<td>
<p>Integer, number of clusters.</p>
</td></tr>
<tr><td><code id="logacceptance_ratio_logu_+3A_kappa">kappa</code></td>
<td>
<p>Positive real. A parameter of the NRMI process.</p>
</td></tr>
<tr><td><code id="logacceptance_ratio_logu_+3A_a">a</code></td>
<td>
<p>Positive real. Total mass of the centering measure.</p>
</td></tr>
<tr><td><code id="logacceptance_ratio_logu_+3A_delta">delta</code></td>
<td>
<p>Scale of the Metropolis-Hastings proposal distribution</p>
</td></tr>
</table>

<hr>
<h2 id='logdprop_logu'>Contribution of the proposal kernel logdensity to the Metropolis-Hastings ratio</h2><span id='topic+logdprop_logu'></span>

<h3>Description</h3>

<p>Contribution of the proposal kernel logdensity to the Metropolis-Hastings ratio
</p>


<h3>Usage</h3>

<pre><code class='language-R'>logdprop_logu(logu_prime, logu, delta)
</code></pre>

<hr>
<h2 id='logf_logu_cond_y'>Contribution of the target logdensity of logU to the Metropolis-Hastings ratio</h2><span id='topic+logf_logu_cond_y'></span>

<h3>Description</h3>

<p>Contribution of the target logdensity of logU to the Metropolis-Hastings ratio
</p>


<h3>Usage</h3>

<pre><code class='language-R'>logf_logu_cond_y(logu, n, r, gamma, kappa, a)
</code></pre>

<hr>
<h2 id='logf_u_cond_y'>Target logdensity of U given the data</h2><span id='topic+logf_u_cond_y'></span>

<h3>Description</h3>

<p>Target logdensity of U given the data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>logf_u_cond_y(u, n, r, gamma, kappa, a)
</code></pre>

<hr>
<h2 id='MixNRMI1'>Normalized Random Measures Mixture of Type I</h2><span id='topic+MixNRMI1'></span>

<h3>Description</h3>

<p>Bayesian nonparametric estimation based on normalized measures driven
mixtures for locations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MixNRMI1(
  x,
  probs = c(0.025, 0.5, 0.975),
  Alpha = 1,
  Kappa = 0,
  Gama = 0.4,
  distr.k = "normal",
  distr.p0 = 1,
  asigma = 0.5,
  bsigma = 0.5,
  delta_S = 3,
  delta_U = 2,
  Meps = 0.01,
  Nx = 150,
  Nit = 1500,
  Pbi = 0.1,
  epsilon = NULL,
  printtime = TRUE,
  extras = TRUE,
  adaptive = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MixNRMI1_+3A_x">x</code></td>
<td>
<p>Numeric vector. Data set to which the density is fitted.</p>
</td></tr>
<tr><td><code id="MixNRMI1_+3A_probs">probs</code></td>
<td>
<p>Numeric vector. Desired quantiles of the density estimates.</p>
</td></tr>
<tr><td><code id="MixNRMI1_+3A_alpha">Alpha</code></td>
<td>
<p>Numeric constant. Total mass of the centering measure. See
details.</p>
</td></tr>
<tr><td><code id="MixNRMI1_+3A_kappa">Kappa</code></td>
<td>
<p>Numeric positive constant. See details.</p>
</td></tr>
<tr><td><code id="MixNRMI1_+3A_gama">Gama</code></td>
<td>
<p>Numeric constant. <code class="reqn">0\leq \texttt{Gama} \leq 1</code>.  See details.</p>
</td></tr>
<tr><td><code id="MixNRMI1_+3A_distr.k">distr.k</code></td>
<td>
<p>The distribution name for the kernel. Allowed names are &quot;normal&quot;, &quot;gamma&quot;, &quot;beta&quot;, &quot;double exponential&quot;, &quot;lognormal&quot; or their common abbreviations &quot;norm&quot;, &quot;exp&quot;, or an integer number identifying the mixture kernel: 1 = Normal; 2 = Gamma; 3 = Beta; 4 = Double Exponential; 5 = Lognormal.</p>
</td></tr>
<tr><td><code id="MixNRMI1_+3A_distr.p0">distr.p0</code></td>
<td>
<p>The distribution name for the centering measure. Allowed names are &quot;normal&quot;, &quot;gamma&quot;, &quot;beta&quot;, or their common abbreviations &quot;norm&quot;, &quot;exp&quot;, or an integer number identifying the centering measure: 1 = Normal; 2 = Gamma; 3 = Beta.</p>
</td></tr>
<tr><td><code id="MixNRMI1_+3A_asigma">asigma</code></td>
<td>
<p>Numeric positive constant. Shape parameter of the gamma prior
on the standard deviation of the mixture kernel <code>distr.k</code>.</p>
</td></tr>
<tr><td><code id="MixNRMI1_+3A_bsigma">bsigma</code></td>
<td>
<p>Numeric positive constant. Rate parameter of the gamma prior
on the standard deviation of the mixture kernel <code>distr.k</code>.</p>
</td></tr>
<tr><td><code id="MixNRMI1_+3A_delta_s">delta_S</code></td>
<td>
<p>Numeric positive constant. Metropolis-Hastings proposal
variation coefficient for sampling sigma.</p>
</td></tr>
<tr><td><code id="MixNRMI1_+3A_delta_u">delta_U</code></td>
<td>
<p>Numeric positive constant. Metropolis-Hastings proposal
variation coefficient for sampling the latent U.</p>
</td></tr>
<tr><td><code id="MixNRMI1_+3A_meps">Meps</code></td>
<td>
<p>Numeric constant. Relative error of the jump sizes in the
continuous component of the process. Smaller values imply larger number of
jumps.</p>
</td></tr>
<tr><td><code id="MixNRMI1_+3A_nx">Nx</code></td>
<td>
<p>Integer constant. Number of grid points for the evaluation of the
density estimate.</p>
</td></tr>
<tr><td><code id="MixNRMI1_+3A_nit">Nit</code></td>
<td>
<p>Integer constant. Number of MCMC iterations.</p>
</td></tr>
<tr><td><code id="MixNRMI1_+3A_pbi">Pbi</code></td>
<td>
<p>Numeric constant. Burn-in period proportion of Nit.</p>
</td></tr>
<tr><td><code id="MixNRMI1_+3A_epsilon">epsilon</code></td>
<td>
<p>Numeric constant. Extension to the evaluation grid range.
See details.</p>
</td></tr>
<tr><td><code id="MixNRMI1_+3A_printtime">printtime</code></td>
<td>
<p>Logical. If TRUE, prints out the execution time.</p>
</td></tr>
<tr><td><code id="MixNRMI1_+3A_extras">extras</code></td>
<td>
<p>Logical. If TRUE, gives additional objects: means, weights and
Js.</p>
</td></tr>
<tr><td><code id="MixNRMI1_+3A_adaptive">adaptive</code></td>
<td>
<p>Logical. If TRUE, uses an adaptive MCMC strategy to sample the latent U (adaptive delta_U).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This generic function fits a normalized random measure (NRMI) mixture model
for density estimation (James et al. 2009). Specifically, the model assumes
a normalized generalized gamma (NGG) prior for the locations (means) of the
mixture kernel and a parametric prior for the common smoothing parameter
sigma, leading to a semiparametric mixture model.
</p>
<p>The details of the model are: </p>
<p style="text-align: center;"><code class="reqn">X_i|Y_i,\sigma \sim k(\cdot
|Y_i,\sigma)</code>
</p>
 <p style="text-align: center;"><code class="reqn">Y_i|P \sim P,\quad
i=1,\dots,n</code>
</p>
 <p style="text-align: center;"><code class="reqn">P \sim \textrm{NGG(\texttt{Alpha,
Kappa, Gama; P\_0})}</code>
</p>
 <p style="text-align: center;"><code class="reqn">\sigma \sim
\textrm{Gamma(asigma, bsigma)}</code>
</p>
<p> where
<code class="reqn">X_i</code>'s are the observed data, <code class="reqn">Y_i</code>'s are latent (location)
variables, <code>sigma</code> is the smoothing parameter, <code>k</code> is a parametric
kernel parameterized in terms of mean and standard deviation, <code>(Alpha,
Kappa, Gama; P_0)</code> are the parameters of the NGG prior with <code>P_0</code> being
the centering measure whose parameters are assigned vague hyper prior
distributions, and <code>(asigma,bsigma)</code> are the hyper-parameters of the
gamma prior on the smoothing parameter <code>sigma</code>. In particular:
<code>NGG(Alpha, 1, 0; P_0)</code> defines a Dirichlet process; <code>NGG(1,
Kappa, 1/2; P_0)</code> defines a Normalized inverse Gaussian process; and
<code>NGG(1, 0, Gama; P_0)</code> defines a normalized stable process.
</p>
<p>The evaluation grid ranges from <code>min(x) - epsilon</code> to <code>max(x) +
epsilon</code>. By default <code>epsilon=sd(x)/4</code>.
</p>


<h3>Value</h3>

<p>The function returns a MixNRMI1 object. It is based on a list with the following components:
</p>
<table>
<tr><td><code>xx</code></td>
<td>
<p>Numeric vector. Evaluation grid.</p>
</td></tr>
<tr><td><code>qx</code></td>
<td>
<p>Numeric array. Matrix
of dimension <code class="reqn">\texttt{Nx} \times (\texttt{length(probs)} + 1)</code> with the posterior mean and the desired quantiles input
in <code>probs</code>.</p>
</td></tr>
<tr><td><code>cpo</code></td>
<td>
<p>Numeric vector of <code>length(x)</code> with
conditional predictive ordinates.</p>
</td></tr>
<tr><td><code>R</code></td>
<td>
<p>Numeric vector of
<code>length(Nit*(1-Pbi))</code> with the number of mixtures components
(clusters).</p>
</td></tr>
<tr><td><code>S</code></td>
<td>
<p>Numeric vector of <code>length(Nit*(1-Pbi))</code> with the
values of common standard deviation sigma.</p>
</td></tr>
<tr><td><code>U</code></td>
<td>
<p>Numeric vector of
<code>length(Nit*(1-Pbi))</code> with the values of the latent variable U.</p>
</td></tr>
<tr><td><code>Allocs</code></td>
<td>
<p>List of <code>length(Nit*(1-Pbi))</code> with the clustering
allocations.</p>
</td></tr>
<tr><td><code>means</code></td>
<td>
<p>List of <code>length(Nit*(1-Pbi))</code> with the
cluster means (locations). Only if extras = TRUE.</p>
</td></tr>
<tr><td><code>weights</code></td>
<td>
<p>List of
<code>length(Nit*(1-Pbi))</code> with the mixture weights. Only if extras = TRUE.</p>
</td></tr>
<tr><td><code>Js</code></td>
<td>
<p>List of <code>length(Nit*(1-Pbi))</code> with the unnormalized weights
(jump sizes). Only if extras = TRUE.</p>
</td></tr>
<tr><td><code>Nm</code></td>
<td>
<p>Integer constant. Number of
jumps of the continuous component of the unnormalized process.</p>
</td></tr>
<tr><td><code>Nx</code></td>
<td>
<p>Integer constant. Number of grid points for the evaluation of the
density estimate.</p>
</td></tr>
<tr><td><code>Nit</code></td>
<td>
<p>Integer constant. Number of MCMC iterations.</p>
</td></tr>
<tr><td><code>Pbi</code></td>
<td>
<p>Numeric constant. Burn-in period proportion of <code>Nit</code>.</p>
</td></tr>
<tr><td><code>procTime</code></td>
<td>
<p>Numeric vector with execution time provided by
<code>proc.time</code> function.</p>
</td></tr>
<tr><td><code>distr.k</code></td>
<td>
<p>Integer corresponding to the kernel chosen for the mixture</p>
</td></tr>
<tr><td><code>data</code></td>
<td>
<p>Data used for the fit</p>
</td></tr>
<tr><td><code>NRMI_params</code></td>
<td>
<p>A named list with the parameters of the NRMI process</p>
</td></tr>
</table>


<h3>Warning </h3>

<p>The function is computing intensive. Be patient.
</p>


<h3>Author(s)</h3>

<p>Barrios, E., Kon Kam King, G., Lijoi, A., Nieto-Barajas, L.E. and Prüenster, I.
</p>


<h3>References</h3>

<p>1.- Barrios, E., Lijoi, A., Nieto-Barajas, L. E. and Prünster,
I. (2013). Modeling with Normalized Random Measure Mixture Models.
Statistical Science. Vol. 28, No. 3, 313-334.
</p>
<p>2.- James, L.F., Lijoi, A. and Prünster, I. (2009). Posterior analysis for
normalized random measure with independent increments. Scand. J. Statist 36,
76-97.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+MixNRMI2">MixNRMI2</a></code>, <code><a href="#topic+MixNRMI1cens">MixNRMI1cens</a></code>,
<code><a href="#topic+MixNRMI2cens">MixNRMI2cens</a></code>, <code><a href="#topic+multMixNRMI1">multMixNRMI1</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
### Example 1
## Not run: 
# Data
data(acidity)
x &lt;- acidity
# Fitting the model under default specifications
out &lt;- MixNRMI1(x)
# Plotting density estimate + 95% credible interval
plot(out)
### Example 2
set.seed(150520)
data(enzyme)
x &lt;- enzyme
Enzyme1.out &lt;- MixNRMI1(x, Alpha = 1, Kappa = 0.007, Gama = 0.5,
                         distr.k = "gamma", distr.p0 = "gamma",
                         asigma = 1, bsigma = 1, Meps=0.005,
                         Nit = 5000, Pbi = 0.2)
attach(Enzyme1.out)
# Plotting density estimate + 95% credible interval
plot(Enzyme1.out)
# Plotting number of clusters
par(mfrow = c(2, 1))
plot(R, type = "l", main = "Trace of R")
hist(R, breaks = min(R - 0.5):max(R + 0.5), probability = TRUE)
# Plotting sigma
par(mfrow = c(2, 1))
plot(S, type = "l", main = "Trace of sigma")
hist(S, nclass = 20, probability = TRUE, main = "Histogram of sigma")
# Plotting u
par(mfrow = c(2, 1))
plot(U, type = "l", main = "Trace of U")
hist(U, nclass = 20, probability = TRUE, main = "Histogram of U")
# Plotting cpo
par(mfrow = c(2, 1))
plot(cpo, main = "Scatter plot of CPO's")
boxplot(cpo, horizontal = TRUE, main = "Boxplot of CPO's")
print(paste("Average log(CPO)=", round(mean(log(cpo)), 4)))
print(paste("Median log(CPO)=", round(median(log(cpo)), 4)))
detach()

## End(Not run)

### Example 3
## Do not run
# set.seed(150520)
# data(galaxy)
# x &lt;- galaxy
#  Galaxy1.out &lt;- MixNRMI1(x, Alpha = 1, Kappa = 0.015, Gama = 0.5,
#                          distr.k = "normal", distr.p0 = "gamma",
#                          asigma = 1, bsigma = 1, delta = 7, Meps=0.005,
#                          Nit = 5000, Pbi = 0.2)

# The output of this run is already loaded in the package
# To show results run the following
# Data
data(galaxy)
x &lt;- galaxy
data(Galaxy1.out)
attach(Galaxy1.out)
# Plotting density estimate + 95% credible interval
plot(Galaxy1.out)
# Plotting number of clusters
par(mfrow = c(2, 1))
plot(R, type = "l", main = "Trace of R")
hist(R, breaks = min(R - 0.5):max(R + 0.5), probability = TRUE)
# Plotting sigma
par(mfrow = c(2, 1))
plot(S, type = "l", main = "Trace of sigma")
hist(S, nclass = 20, probability = TRUE, main = "Histogram of sigma")
# Plotting u
par(mfrow = c(2, 1))
plot(U, type = "l", main = "Trace of U")
hist(U, nclass = 20, probability = TRUE, main = "Histogram of U")
# Plotting cpo
par(mfrow = c(2, 1))
plot(cpo, main = "Scatter plot of CPO's")
boxplot(cpo, horizontal = TRUE, main = "Boxplot of CPO's")
print(paste("Average log(CPO)=", round(mean(log(cpo)), 4)))
print(paste("Median log(CPO)=", round(median(log(cpo)), 4)))
detach()
</code></pre>

<hr>
<h2 id='MixNRMI1cens'>Normalized Random Measures Mixture of Type I for censored data</h2><span id='topic+MixNRMI1cens'></span>

<h3>Description</h3>

<p>Bayesian nonparametric estimation based on normalized measures driven
mixtures for locations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MixNRMI1cens(
  xleft,
  xright,
  probs = c(0.025, 0.5, 0.975),
  Alpha = 1,
  Kappa = 0,
  Gama = 0.4,
  distr.k = "normal",
  distr.p0 = "normal",
  asigma = 0.5,
  bsigma = 0.5,
  delta_S = 3,
  delta_U = 2,
  Meps = 0.01,
  Nx = 150,
  Nit = 1500,
  Pbi = 0.1,
  epsilon = NULL,
  printtime = TRUE,
  extras = TRUE,
  adaptive = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MixNRMI1cens_+3A_xleft">xleft</code></td>
<td>
<p>Numeric vector. Lower limit of interval censoring. For exact
data the same as xright</p>
</td></tr>
<tr><td><code id="MixNRMI1cens_+3A_xright">xright</code></td>
<td>
<p>Numeric vector. Upper limit of interval censoring. For exact
data the same as xleft.</p>
</td></tr>
<tr><td><code id="MixNRMI1cens_+3A_probs">probs</code></td>
<td>
<p>Numeric vector. Desired quantiles of the density estimates.</p>
</td></tr>
<tr><td><code id="MixNRMI1cens_+3A_alpha">Alpha</code></td>
<td>
<p>Numeric constant. Total mass of the centering measure. See
details.</p>
</td></tr>
<tr><td><code id="MixNRMI1cens_+3A_kappa">Kappa</code></td>
<td>
<p>Numeric positive constant. See details.</p>
</td></tr>
<tr><td><code id="MixNRMI1cens_+3A_gama">Gama</code></td>
<td>
<p>Numeric constant. <code class="reqn">0\leq \texttt{Gama} \leq 1</code>.  See details.</p>
</td></tr>
<tr><td><code id="MixNRMI1cens_+3A_distr.k">distr.k</code></td>
<td>
<p>The distribution name for the kernel. Allowed names are &quot;normal&quot;, &quot;gamma&quot;, &quot;beta&quot;, &quot;double exponential&quot;, &quot;lognormal&quot; or their common abbreviations &quot;norm&quot;, &quot;exp&quot;, or an integer number identifying the mixture kernel: 1 = Normal; 2 = Gamma; 3 = Beta; 4 = Double Exponential; 5 = Lognormal.</p>
</td></tr>
<tr><td><code id="MixNRMI1cens_+3A_distr.p0">distr.p0</code></td>
<td>
<p>The distribution name for the centering measure. Allowed names are &quot;normal&quot;, &quot;gamma&quot;, &quot;beta&quot;, or their common abbreviations &quot;norm&quot;, &quot;exp&quot;, or an integer number identifying the centering measure: 1 = Normal; 2 = Gamma; 3 = Beta.</p>
</td></tr>
<tr><td><code id="MixNRMI1cens_+3A_asigma">asigma</code></td>
<td>
<p>Numeric positive constant. Shape parameter of the gamma prior
on the standard deviation of the mixture kernel <code>distr.k</code>.</p>
</td></tr>
<tr><td><code id="MixNRMI1cens_+3A_bsigma">bsigma</code></td>
<td>
<p>Numeric positive constant. Rate parameter of the gamma prior
on the standard deviation of the mixture kernel <code>distr.k</code>.</p>
</td></tr>
<tr><td><code id="MixNRMI1cens_+3A_delta_s">delta_S</code></td>
<td>
<p>Numeric positive constant. Metropolis-Hastings proposal
variation coefficient for sampling sigma.</p>
</td></tr>
<tr><td><code id="MixNRMI1cens_+3A_delta_u">delta_U</code></td>
<td>
<p>Numeric positive constant. Metropolis-Hastings proposal
variation coefficient for sampling the latent U.</p>
</td></tr>
<tr><td><code id="MixNRMI1cens_+3A_meps">Meps</code></td>
<td>
<p>Numeric constant. Relative error of the jump sizes in the
continuous component of the process. Smaller values imply larger number of
jumps.</p>
</td></tr>
<tr><td><code id="MixNRMI1cens_+3A_nx">Nx</code></td>
<td>
<p>Integer constant. Number of grid points for the evaluation of the
density estimate.</p>
</td></tr>
<tr><td><code id="MixNRMI1cens_+3A_nit">Nit</code></td>
<td>
<p>Integer constant. Number of MCMC iterations.</p>
</td></tr>
<tr><td><code id="MixNRMI1cens_+3A_pbi">Pbi</code></td>
<td>
<p>Numeric constant. Burn-in period proportion of Nit.</p>
</td></tr>
<tr><td><code id="MixNRMI1cens_+3A_epsilon">epsilon</code></td>
<td>
<p>Numeric constant. Extension to the evaluation grid range.
See details.</p>
</td></tr>
<tr><td><code id="MixNRMI1cens_+3A_printtime">printtime</code></td>
<td>
<p>Logical. If TRUE, prints out the execution time.</p>
</td></tr>
<tr><td><code id="MixNRMI1cens_+3A_extras">extras</code></td>
<td>
<p>Logical. If TRUE, gives additional objects: means, weights and
Js.</p>
</td></tr>
<tr><td><code id="MixNRMI1cens_+3A_adaptive">adaptive</code></td>
<td>
<p>Logical. If TRUE, uses an adaptive MCMC strategy to sample the latent U (adaptive delta_U).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This generic function fits a normalized random measure (NRMI) mixture model
for density estimation (James et al. 2009) with censored data. Specifically,
the model assumes a normalized generalized gamma (NGG) prior for the
locations (means) of the mixture kernel and a parametric prior for the
common smoothing parameter sigma, leading to a semiparametric mixture model.
</p>
<p>This function coincides with <code><a href="#topic+MixNRMI1">MixNRMI1</a></code> when the lower (xleft)
and upper (xright) censoring limits correspond to the same exact value.
</p>
<p>The details of the model are: </p>
<p style="text-align: center;"><code class="reqn">X_i|Y_i,\sigma \sim k(\cdot
|Y_i,\sigma)</code>
</p>
 <p style="text-align: center;"><code class="reqn">Y_i|P \sim P,\quad
i=1,\dots,n</code>
</p>
 <p style="text-align: center;"><code class="reqn">P \sim \textrm{NGG(\texttt{Alpha,
Kappa, Gama; P\_0})}</code>
</p>
 <p style="text-align: center;"><code class="reqn">\sigma \sim
\textrm{Gamma(asigma, bsigma)}</code>
</p>
<p> where
<code class="reqn">X_i</code>'s are the observed data, <code class="reqn">Y_i</code>'s are latent (location)
variables, <code>sigma</code> is the smoothing parameter, <code>k</code> is a parametric
kernel parameterized in terms of mean and standard deviation, <code>(Alpha,
Kappa, Gama; P_0)</code> are the parameters of the NGG prior with <code>P_0</code> being
the centering measure whose parameters are assigned vague hyper prior
distributions, and <code>(asigma,bsigma)</code> are the hyper-parameters of the
gamma prior on the smoothing parameter <code>sigma</code>. In particular:
<code>NGG(Alpha, 1, 0; P_0)</code> defines a Dirichlet process; <code>NGG(1,
Kappa, 1/2; P_0)</code> defines a Normalized inverse Gaussian process; and
<code>NGG(1, 0, Gama; P_0)</code> defines a normalized stable process.
</p>
<p>The evaluation grid ranges from <code>min(x) - epsilon</code> to <code>max(x) +
epsilon</code>. By default <code>epsilon=sd(x)/4</code>.
</p>


<h3>Value</h3>

<p>The function returns a list with the following components:
</p>
<table>
<tr><td><code>xx</code></td>
<td>
<p>Numeric vector. Evaluation grid.</p>
</td></tr> <tr><td><code>qx</code></td>
<td>
<p>Numeric array. Matrix
of dimension <code class="reqn">\texttt{Nx} \times (\texttt{length(probs)} + 1)</code> with the posterior mean and the desired quantiles input
in <code>probs</code>.</p>
</td></tr> <tr><td><code>cpo</code></td>
<td>
<p>Numeric vector of <code>length(x)</code> with
conditional predictive ordinates.</p>
</td></tr> <tr><td><code>R</code></td>
<td>
<p>Numeric vector of
<code>length(Nit*(1-Pbi))</code> with the number of mixtures components
(clusters).</p>
</td></tr> <tr><td><code>S</code></td>
<td>
<p>Numeric vector of <code>length(Nit*(1-Pbi))</code> with the
values of common standard deviation sigma.</p>
</td></tr> <tr><td><code>U</code></td>
<td>
<p>Numeric vector of
<code>length(Nit*(1-Pbi))</code> with the values of the latent variable U.</p>
</td></tr>
<tr><td><code>Allocs</code></td>
<td>
<p>List of <code>length(Nit*(1-Pbi))</code> with the clustering
allocations.</p>
</td></tr> <tr><td><code>means</code></td>
<td>
<p>List of <code>length(Nit*(1-Pbi))</code> with the
cluster means (locations). Only if extras = TRUE.</p>
</td></tr> <tr><td><code>weights</code></td>
<td>
<p>List of
<code>length(Nit*(1-Pbi))</code> with the mixture weights. Only if extras = TRUE.</p>
</td></tr>
<tr><td><code>Js</code></td>
<td>
<p>List of <code>length(Nit*(1-Pbi))</code> with the unnormalized weights
(jump sizes). Only if extras = TRUE.</p>
</td></tr> <tr><td><code>Nm</code></td>
<td>
<p>Integer constant. Number of
jumps of the continuous component of the unnormalized process.</p>
</td></tr>
<tr><td><code>Nx</code></td>
<td>
<p>Integer constant. Number of grid points for the evaluation of the
density estimate.</p>
</td></tr> <tr><td><code>Nit</code></td>
<td>
<p>Integer constant. Number of MCMC iterations.</p>
</td></tr>
<tr><td><code>Pbi</code></td>
<td>
<p>Numeric constant. Burn-in period proportion of <code>Nit</code>.</p>
</td></tr>
<tr><td><code>procTime</code></td>
<td>
<p>Numeric vector with execution time provided by
<code>proc.time</code> function.</p>
</td></tr>
<tr><td><code>distr.k</code></td>
<td>
<p>Integer corresponding to the kernel chosen for the mixture</p>
</td></tr>
<tr><td><code>data</code></td>
<td>
<p>Data used for the fit</p>
</td></tr>
<tr><td><code>NRMI_params</code></td>
<td>
<p>A named list with the parameters of the NRMI process</p>
</td></tr>
</table>


<h3>Warning </h3>

<p>The function is computing intensive. Be patient.
</p>


<h3>Author(s)</h3>

<p>Barrios, E., Kon Kam King, G. and Nieto-Barajas, L.E.
</p>


<h3>References</h3>

<p>1.- Barrios, E., Lijoi, A., Nieto-Barajas, L. E. and Prünster,
I. (2013). Modeling with Normalized Random Measure Mixture Models.
Statistical Science. Vol. 28, No. 3, 313-334.
</p>
<p>2.- James, L.F., Lijoi, A. and Prünster, I. (2009). Posterior analysis for
normalized random measure with independent increments. Scand. J. Statist 36,
76-97.
</p>
<p>3.- Kon Kam King, G., Arbel, J. and Prünster, I. (2016). Species
Sensitivity Distribution revisited: a Bayesian nonparametric approach. In
preparation.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+MixNRMI2">MixNRMI2</a></code>, <code><a href="#topic+MixNRMI1cens">MixNRMI1cens</a></code>,
<code><a href="#topic+MixNRMI2cens">MixNRMI2cens</a></code>, <code><a href="#topic+multMixNRMI1">multMixNRMI1</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
### Example 1
## Not run: 
# Data
data(acidity)
x &lt;- acidity
# Fitting the model under default specifications
out &lt;- MixNRMI1cens(x, x)
# Plotting density estimate + 95% credible interval
plot(out)

## End(Not run)

## Not run: 
### Example 2
# Data
data(salinity)
# Fitting the model under default specifications
out &lt;- MixNRMI1cens(xleft = salinity$left, xright = salinity$right, Nit = 5000)
# Plotting density estimate + 95% credible interval
attach(out)
plot(out)
# Plotting number of clusters
par(mfrow = c(2, 1))
plot(R, type = "l", main = "Trace of R")
hist(R, breaks = min(R - 0.5):max(R + 0.5), probability = TRUE)
detach()

## End(Not run)

</code></pre>

<hr>
<h2 id='MixNRMI2'>Normalized Random Measures Mixture of Type II</h2><span id='topic+MixNRMI2'></span>

<h3>Description</h3>

<p>Bayesian nonparametric estimation based on normalized measures driven
mixtures for locations and scales.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MixNRMI2(
  x,
  probs = c(0.025, 0.5, 0.975),
  Alpha = 1,
  Kappa = 0,
  Gama = 0.4,
  distr.k = "normal",
  distr.py0 = "normal",
  distr.pz0 = "gamma",
  mu.pz0 = 3,
  sigma.pz0 = sqrt(10),
  delta_S = 4,
  kappa = 2,
  delta_U = 2,
  Meps = 0.01,
  Nx = 150,
  Nit = 1500,
  Pbi = 0.1,
  epsilon = NULL,
  printtime = TRUE,
  extras = TRUE,
  adaptive = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MixNRMI2_+3A_x">x</code></td>
<td>
<p>Numeric vector. Data set to which the density is fitted.</p>
</td></tr>
<tr><td><code id="MixNRMI2_+3A_probs">probs</code></td>
<td>
<p>Numeric vector. Desired quantiles of the density estimates.</p>
</td></tr>
<tr><td><code id="MixNRMI2_+3A_alpha">Alpha</code></td>
<td>
<p>Numeric constant. Total mass of the centering measure.  See
details.</p>
</td></tr>
<tr><td><code id="MixNRMI2_+3A_kappa">Kappa</code></td>
<td>
<p>Numeric positive constant. See details.</p>
</td></tr>
<tr><td><code id="MixNRMI2_+3A_gama">Gama</code></td>
<td>
<p>Numeric constant. <code class="reqn">0 \leq Gama \leq 1</code>.  See
details.</p>
</td></tr>
<tr><td><code id="MixNRMI2_+3A_distr.k">distr.k</code></td>
<td>
<p>The distribution name for the kernel. Allowed names are &quot;normal&quot;, &quot;gamma&quot;, &quot;beta&quot;, &quot;double exponential&quot;, &quot;lognormal&quot; or their common abbreviations &quot;norm&quot;, &quot;exp&quot;, or an integer number identifying the mixture kernel: 1 = Normal; 2 = Gamma; 3 = Beta; 4 = Double Exponential; 5 = Lognormal.</p>
</td></tr>
<tr><td><code id="MixNRMI2_+3A_distr.py0">distr.py0</code></td>
<td>
<p>The distribution name for the centering measure for locations. Allowed names are &quot;normal&quot;, &quot;gamma&quot;, &quot;beta&quot;, or their common abbreviations &quot;norm&quot;, &quot;exp&quot;, or an integer number identifying the centering measure for locations: 1 = Normal; 2 = Gamma; 3 = Beta.</p>
</td></tr>
<tr><td><code id="MixNRMI2_+3A_distr.pz0">distr.pz0</code></td>
<td>
<p>The distribution name for the centering measure for scales.  Allowed names are &quot;gamma&quot;, or an integer number identifying the centering measure for
scales: 2 = Gamma. For more options use <code><a href="#topic+MixNRMI2cens">MixNRMI2cens</a></code>.</p>
</td></tr>
<tr><td><code id="MixNRMI2_+3A_mu.pz0">mu.pz0</code></td>
<td>
<p>Numeric constant. Prior mean of the centering measure for
scales.</p>
</td></tr>
<tr><td><code id="MixNRMI2_+3A_sigma.pz0">sigma.pz0</code></td>
<td>
<p>Numeric constant. Prior standard deviation of the centering
measure for scales.</p>
</td></tr>
<tr><td><code id="MixNRMI2_+3A_delta_s">delta_S</code></td>
<td>
<p>Numeric positive constant. Metropolis-Hastings proposal
variation coefficient for sampling the scales.</p>
</td></tr>
<tr><td><code id="MixNRMI2_+3A_kappa">kappa</code></td>
<td>
<p>Numeric positive constant. Metropolis-Hastings proposal
variation coefficient for sampling the location parameters.</p>
</td></tr>
<tr><td><code id="MixNRMI2_+3A_delta_u">delta_U</code></td>
<td>
<p>Numeric positive constant. Metropolis-Hastings proposal
variation coefficient for sampling the latent U. If 'adaptive=TRUE', 'delta_U'is the starting value for the adaptation.</p>
</td></tr>
<tr><td><code id="MixNRMI2_+3A_meps">Meps</code></td>
<td>
<p>Numeric constant. Relative error of the jump sizes in the
continuous component of the process. Smaller values imply larger number of
jumps.</p>
</td></tr>
<tr><td><code id="MixNRMI2_+3A_nx">Nx</code></td>
<td>
<p>Integer constant. Number of grid points for the evaluation of the
density estimate.</p>
</td></tr>
<tr><td><code id="MixNRMI2_+3A_nit">Nit</code></td>
<td>
<p>Integer constant. Number of MCMC iterations.</p>
</td></tr>
<tr><td><code id="MixNRMI2_+3A_pbi">Pbi</code></td>
<td>
<p>Numeric constant. Burn-in period proportion of <code>Nit</code>.</p>
</td></tr>
<tr><td><code id="MixNRMI2_+3A_epsilon">epsilon</code></td>
<td>
<p>Numeric constant. Extension to the evaluation grid range.
See details.</p>
</td></tr>
<tr><td><code id="MixNRMI2_+3A_printtime">printtime</code></td>
<td>
<p>Logical. If TRUE, prints out the execution time.</p>
</td></tr>
<tr><td><code id="MixNRMI2_+3A_extras">extras</code></td>
<td>
<p>Logical. If TRUE, gives additional objects: means, sigmas,
weights and Js.</p>
</td></tr>
<tr><td><code id="MixNRMI2_+3A_adaptive">adaptive</code></td>
<td>
<p>Logical. If TRUE, uses an adaptive MCMC strategy to sample the latent U (adaptive delta_U).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This generic function fits a normalized random measure (NRMI) mixture model
for density estimation (James et al. 2009). Specifically, the model assumes
a normalized generalized gamma (NGG) prior for both, locations (means) and
standard deviations, of the mixture kernel, leading to a fully nonparametric
mixture model.
</p>
<p>The details of the model are: </p>
<p style="text-align: center;"><code class="reqn">X_i|Y_i,Z_i \sim
k(\cdot|Y_i,Z_i)</code>
</p>
 <p style="text-align: center;"><code class="reqn">(Y_i,Z_i)|P \sim P,
i=1,\dots,n</code>
</p>
 <p style="text-align: center;"><code class="reqn">P \sim
\textrm{NGG}(\texttt{Alpha, Kappa, Gama; P\_0})</code>
</p>
<p> where, <code class="reqn">X_i</code>'s are the observed data, <code class="reqn">(Y_i,Z_i)</code>'s are
bivariate latent (location and scale) vectors, <code>k</code> is a parametric
kernel parameterized in terms of mean and standard deviation, <code>(Alpha,
Kappa, Gama; P_0)</code> are the parameters of the NGG prior with a bivariate
<code>P_0</code> being the centering measure with independent components, that is,
<code class="reqn">P_0(Y,Z) = P_0(Y)*P_0(Z)</code>. The parameters of <code>P_0(Y)</code> are assigned
vague hyper prior distributions and <code>(mu.pz0,sigma.pz0)</code> are the
hyper-parameters of <code>P_0(Z)</code>. In particular, <code>NGG(Alpha, 1, 0;
P_0)</code> defines a Dirichlet process; <code>NGG(1, Kappa, 1/2;P_0)</code> defines a
Normalized inverse Gaussian process; and <code>NGG(1, 0, Gama; P_0)</code> defines
a normalized stable process. The evaluation grid ranges from <code>min(x) -
epsilon</code> to <code>max(x) + epsilon</code>. By default <code>epsilon=sd(x)/4</code>.
</p>


<h3>Value</h3>

<p>The function returns a list with the following components:
</p>
<table>
<tr><td><code>xx</code></td>
<td>
<p>Numeric vector. Evaluation grid.</p>
</td></tr>
<tr><td><code>qx</code></td>
<td>
<p>Numeric array. Matrix
of dimension <code class="reqn">\texttt{Nx} \times (\texttt{length(probs)} + 1)</code> with the posterior mean and the desired quantiles input
in <code>probs</code>.</p>
</td></tr>
<tr><td><code>cpo</code></td>
<td>
<p>Numeric vector of <code>length(x)</code> with
conditional predictive ordinates.</p>
</td></tr>
<tr><td><code>R</code></td>
<td>
<p>Numeric vector of
<code>length(Nit*(1-Pbi))</code> with the number of mixtures components
(clusters).</p>
</td></tr>
<tr><td><code>U</code></td>
<td>
<p>Numeric vector of <code>length(Nit*(1-Pbi))</code> with the
values of the latent variable U.</p>
</td></tr>
<tr><td><code>Allocs</code></td>
<td>
<p>List of
<code>length(Nit*(1-Pbi))</code> with the clustering allocations.</p>
</td></tr>
<tr><td><code>means</code></td>
<td>
<p>List of <code>length(Nit*(1-Pbi))</code> with the cluster means
(locations). Only if extras = TRUE.</p>
</td></tr>
<tr><td><code>sigmas</code></td>
<td>
<p>Numeric vector of
<code>length(Nit*(1-Pbi))</code> with the cluster standard deviations. Only if
extras = TRUE.</p>
</td></tr>
<tr><td><code>weights</code></td>
<td>
<p>List of <code>length(Nit*(1-Pbi))</code> with the
mixture weights. Only if extras = TRUE.</p>
</td></tr>
<tr><td><code>Js</code></td>
<td>
<p>List of
<code>length(Nit*(1-Pbi))</code> with the unnormalized weights (jump sizes). Only
if extras = TRUE.</p>
</td></tr>
<tr><td><code>Nm</code></td>
<td>
<p>Integer constant. Number of jumps of the
continuous component of the unnormalized process.</p>
</td></tr>
<tr><td><code>delta_Us</code></td>
<td>
<p>List of
<code>length(Nit*(1-Pbi))</code> with the sequence of adapted delta_U used in the MH step for the latent variable U.</p>
</td></tr>
<tr><td><code>Nx</code></td>
<td>
<p>Integer
constant. Number of grid points for the evaluation of the density estimate.</p>
</td></tr>
<tr><td><code>Nit</code></td>
<td>
<p>Integer constant. Number of MCMC iterations.</p>
</td></tr>
<tr><td><code>Pbi</code></td>
<td>
<p>Numeric constant. Burn-in period proportion of <code>Nit</code>.</p>
</td></tr>
<tr><td><code>procTime</code></td>
<td>
<p>Numeric vector with execution time provided by <code>proc.time</code> function.</p>
</td></tr>
<tr><td><code>distr.k</code></td>
<td>
<p>Integer corresponding to the kernel chosen for the mixture</p>
</td></tr>
<tr><td><code>data</code></td>
<td>
<p>Data used for the fit</p>
</td></tr>
<tr><td><code>NRMI_params</code></td>
<td>
<p>A named list with the parameters of the NRMI process</p>
</td></tr>
</table>


<h3>Warning </h3>

<p>The function is computing intensive. Be patient.
</p>


<h3>Author(s)</h3>

<p>Barrios, Kon Kam King, G., E., Lijoi, A., Nieto-Barajas, L.E. and Prüenster, I.
</p>


<h3>References</h3>

<p>1.- Barrios, E., Lijoi, A., Nieto-Barajas, L. E. and Prünster,
I. (2013). Modeling with Normalized Random Measure Mixture Models.
Statistical Science. Vol. 28, No. 3, 313-334.
</p>
<p>2.- James, L.F., Lijoi, A. and Prünster, I. (2009). Posterior analysis for
normalized random measure with independent increments. Scand. J. Statist 36,
76-97.
</p>
<p>3.- Arbel, J., Kon Kam King, G.,  Lijoi, A., Nieto-Barajas, L.E. and Prüenster, I. (2021). BNPdensity: a package for Bayesian Nonparametric density estimation using Normalised Random Measures with Independent Increments.. Australian and New Zealand Journal of Statistics, to appear
</p>


<h3>See Also</h3>

<p><code><a href="#topic+MixNRMI2">MixNRMI2</a></code>, <code><a href="#topic+MixNRMI1cens">MixNRMI1cens</a></code>,
<code><a href="#topic+MixNRMI2cens">MixNRMI2cens</a></code>, <code><a href="#topic+multMixNRMI1">multMixNRMI1</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
### Example 1
# Data
data(acidity)
x &lt;- acidity
# Fitting the model under default specifications
out &lt;- MixNRMI2(x)
# Plotting density estimate + 95% credible interval
plot(out)

## End(Not run)

### Example 2
## Do not run
# set.seed(150520)
# data(enzyme)
# x &lt;- enzyme
#  Enzyme2.out &lt;- MixNRMI2(x, Alpha = 1, Kappa = 0.007, Gama = 0.5,
#                          distr.k = "gamma", distr.py0 = "gamma",
#                          distr.pz0 = "gamma", mu.pz0 = 1, sigma.pz0 = 1, Meps=0.005,
#                          Nit = 5000, Pbi = 0.2)
# The output of this run is already loaded in the package
# To show results run the following
# Data
data(enzyme)
x &lt;- enzyme
data(Enzyme2.out)
attach(Enzyme2.out)
# Plotting density estimate + 95% credible interval
plot(Enzyme2.out)
# Plotting number of clusters
par(mfrow = c(2, 1))
plot(R, type = "l", main = "Trace of R")
hist(R, breaks = min(R - 0.5):max(R + 0.5), probability = TRUE)
# Plotting u
par(mfrow = c(2, 1))
plot(U, type = "l", main = "Trace of U")
hist(U, nclass = 20, probability = TRUE, main = "Histogram of U")
# Plotting cpo
par(mfrow = c(2, 1))
plot(cpo, main = "Scatter plot of CPO's")
boxplot(cpo, horizontal = TRUE, main = "Boxplot of CPO's")
print(paste("Average log(CPO)=", round(mean(log(cpo)), 4)))
print(paste("Median log(CPO)=", round(median(log(cpo)), 4)))
detach()

### Example 3
## Do not run
# set.seed(150520)
# data(galaxy)
# x &lt;- galaxy
#  Galaxy2.out &lt;- MixNRMI2(x, Alpha = 1, Kappa = 0.015, Gama = 0.5,
#                          distr.k = "normal", distr.py0 = "gamma",
#                          distr.pz0 = "gamma", mu.pz0 = 1, sigma.pz0 = 1,  Meps=0.005,
#                          Nit = 5000, Pbi = 0.2)
# The output of this run is already loaded in the package
# To show results run the following
# Data
data(galaxy)
x &lt;- galaxy
data(Galaxy2.out)
attach(Galaxy2.out)
# Plotting density estimate + 95% credible interval
plot(Galaxy2.out)
# Plotting number of clusters
par(mfrow = c(2, 1))
plot(R, type = "l", main = "Trace of R")
hist(R, breaks = min(R - 0.5):max(R + 0.5), probability = TRUE)
# Plotting u
par(mfrow = c(2, 1))
plot(U, type = "l", main = "Trace of U")
hist(U, nclass = 20, probability = TRUE, main = "Histogram of U")
# Plotting cpo
par(mfrow = c(2, 1))
plot(cpo, main = "Scatter plot of CPO's")
boxplot(cpo, horizontal = TRUE, main = "Boxplot of CPO's")
print(paste("Average log(CPO)=", round(mean(log(cpo)), 4)))
print(paste("Median log(CPO)=", round(median(log(cpo)), 4)))
detach()
</code></pre>

<hr>
<h2 id='MixNRMI2cens'>Normalized Random Measures Mixture of Type II for censored data</h2><span id='topic+MixNRMI2cens'></span>

<h3>Description</h3>

<p>Bayesian nonparametric estimation based on normalized measures driven
mixtures for locations and scales.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MixNRMI2cens(
  xleft,
  xright,
  probs = c(0.025, 0.5, 0.975),
  Alpha = 1,
  Kappa = 0,
  Gama = 0.4,
  distr.k = "normal",
  distr.py0 = "normal",
  distr.pz0 = "gamma",
  mu.pz0 = 3,
  sigma.pz0 = sqrt(10),
  delta_S = 4,
  kappa = 2,
  delta_U = 2,
  Meps = 0.01,
  Nx = 150,
  Nit = 1500,
  Pbi = 0.1,
  epsilon = NULL,
  printtime = TRUE,
  extras = TRUE,
  adaptive = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MixNRMI2cens_+3A_xleft">xleft</code></td>
<td>
<p>Numeric vector. Lower limit of interval censoring. For exact
data the same as xright</p>
</td></tr>
<tr><td><code id="MixNRMI2cens_+3A_xright">xright</code></td>
<td>
<p>Numeric vector. Upper limit of interval censoring. For exact
data the same as xleft.</p>
</td></tr>
<tr><td><code id="MixNRMI2cens_+3A_probs">probs</code></td>
<td>
<p>Numeric vector. Desired quantiles of the density estimates.</p>
</td></tr>
<tr><td><code id="MixNRMI2cens_+3A_alpha">Alpha</code></td>
<td>
<p>Numeric constant. Total mass of the centering measure.  See
details.</p>
</td></tr>
<tr><td><code id="MixNRMI2cens_+3A_kappa">Kappa</code></td>
<td>
<p>Numeric positive constant. See details.</p>
</td></tr>
<tr><td><code id="MixNRMI2cens_+3A_gama">Gama</code></td>
<td>
<p>Numeric constant. <code class="reqn">0 \leq Gama \leq 1</code>.  See
details.</p>
</td></tr>
<tr><td><code id="MixNRMI2cens_+3A_distr.k">distr.k</code></td>
<td>
<p>The distribution name for the kernel. Allowed names are &quot;normal&quot;, &quot;gamma&quot;, &quot;beta&quot;, &quot;double exponential&quot;, &quot;lognormal&quot; or their common abbreviations &quot;norm&quot;, &quot;exp&quot;, or an integer number identifying the mixture kernel: 1 = Normal; 2 = Gamma; 3 = Beta; 4 = Double Exponential; 5 = Lognormal.</p>
</td></tr>
<tr><td><code id="MixNRMI2cens_+3A_distr.py0">distr.py0</code></td>
<td>
<p>The distribution name for the centering measure for locations. Allowed names are &quot;normal&quot;, &quot;gamma&quot;, &quot;beta&quot;, or their common abbreviations &quot;norm&quot;, &quot;exp&quot;, or an integer number identifying the centering measure for locations: 1 = Normal; 2 = Gamma; 3 = Beta.</p>
</td></tr>
<tr><td><code id="MixNRMI2cens_+3A_distr.pz0">distr.pz0</code></td>
<td>
<p>The distribution name for the centering measure for scales.  Allowed names are &quot;gamma&quot;, &quot;lognormal&quot;, &quot;half-Cauchy&quot;, &quot;half-normal&quot;, &quot;half-student&quot;, &quot;uniform&quot; and &quot;truncated normal&quot;, or their common abbreviations &quot;norm&quot;, &quot;exp&quot;, &quot;lnorm&quot;, &quot;halfcauchy&quot;, &quot;halfnorm&quot;, &quot;halft&quot; and &quot;unif&quot;, or an integer number identifying the centering measure for scales: 2 = Gamma, 5 = Lognormal, 6 = Half Cauchy, 7 = Half Normal, 8 = Half Student-t, 9 = Uniform, 10 = Truncated Normal.</p>
</td></tr>
<tr><td><code id="MixNRMI2cens_+3A_mu.pz0">mu.pz0</code></td>
<td>
<p>Numeric constant. Prior mean of the centering measure for
scales.</p>
</td></tr>
<tr><td><code id="MixNRMI2cens_+3A_sigma.pz0">sigma.pz0</code></td>
<td>
<p>Numeric constant. Prior standard deviation of the centering
measure for scales.</p>
</td></tr>
<tr><td><code id="MixNRMI2cens_+3A_delta_s">delta_S</code></td>
<td>
<p>Numeric positive constant. Metropolis-Hastings proposal
variation coefficient for sampling the scales.</p>
</td></tr>
<tr><td><code id="MixNRMI2cens_+3A_kappa">kappa</code></td>
<td>
<p>Numeric positive constant. Metropolis-Hastings proposal
variation coefficient for sampling the location parameters.</p>
</td></tr>
<tr><td><code id="MixNRMI2cens_+3A_delta_u">delta_U</code></td>
<td>
<p>Numeric positive constant. Metropolis-Hastings proposal
variation coefficient for sampling the latent U. If 'adaptive=TRUE', 'delta_U'is the starting value for the adaptation.</p>
</td></tr>
<tr><td><code id="MixNRMI2cens_+3A_meps">Meps</code></td>
<td>
<p>Numeric constant. Relative error of the jump sizes in the
continuous component of the process. Smaller values imply larger number of
jumps.</p>
</td></tr>
<tr><td><code id="MixNRMI2cens_+3A_nx">Nx</code></td>
<td>
<p>Integer constant. Number of grid points for the evaluation of the
density estimate.</p>
</td></tr>
<tr><td><code id="MixNRMI2cens_+3A_nit">Nit</code></td>
<td>
<p>Integer constant. Number of MCMC iterations.</p>
</td></tr>
<tr><td><code id="MixNRMI2cens_+3A_pbi">Pbi</code></td>
<td>
<p>Numeric constant. Burn-in period proportion of <code>Nit</code>.</p>
</td></tr>
<tr><td><code id="MixNRMI2cens_+3A_epsilon">epsilon</code></td>
<td>
<p>Numeric constant. Extension to the evaluation grid range.
See details.</p>
</td></tr>
<tr><td><code id="MixNRMI2cens_+3A_printtime">printtime</code></td>
<td>
<p>Logical. If TRUE, prints out the execution time.</p>
</td></tr>
<tr><td><code id="MixNRMI2cens_+3A_extras">extras</code></td>
<td>
<p>Logical. If TRUE, gives additional objects: means, sigmas,
weights and Js.</p>
</td></tr>
<tr><td><code id="MixNRMI2cens_+3A_adaptive">adaptive</code></td>
<td>
<p>Logical. If TRUE, uses an adaptive MCMC strategy to sample the latent U (adaptive delta_U).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This generic function fits a normalized random measure (NRMI) mixture model
for density estimation (James et al. 2009). Specifically, the model assumes
a normalized generalized gamma (NGG) prior for both, locations (means) and
standard deviations, of the mixture kernel, leading to a fully nonparametric
mixture model.
</p>
<p>The details of the model are: </p>
<p style="text-align: center;"><code class="reqn">X_i|Y_i,Z_i \sim
k(\cdot|Y_i,Z_i)</code>
</p>
 <p style="text-align: center;"><code class="reqn">(Y_i,Z_i)|P \sim P,
i=1,\dots,n</code>
</p>
 <p style="text-align: center;"><code class="reqn">P \sim
\textrm{NGG}(\texttt{Alpha, Kappa, Gama; P\_0})</code>
</p>
<p> where, <code class="reqn">X_i</code>'s are the observed data, <code class="reqn">(Y_i,Z_i)</code>'s are
bivariate latent (location and scale) vectors, <code>k</code> is a parametric
kernel parameterized in terms of mean and standard deviation, <code>(Alpha,
Kappa, Gama; P_0)</code> are the parameters of the NGG prior with a bivariate
<code>P_0</code> being the centering measure with independent components, that is,
<code class="reqn">P_0(Y,Z) = P_0(Y)*P_0(Z)</code>. The parameters of <code>P_0(Y)</code> are assigned
vague hyper prior distributions and <code>(mu.pz0,sigma.pz0)</code> are the
hyper-parameters of <code>P_0(Z)</code>. In particular, <code>NGG(Alpha, 1, 0;
P_0)</code> defines a Dirichlet process; <code>NGG(1, Kappa, 1/2;P_0)</code> defines a
Normalized inverse Gaussian process; and <code>NGG(1, 0, Gama; P_0)</code> defines
a normalized stable process. The evaluation grid ranges from <code>min(x) -
epsilon</code> to <code>max(x) + epsilon</code>. By default <code>epsilon=sd(x)/4</code>.
</p>


<h3>Value</h3>

<p>The function returns a list with the following components:
</p>
<table>
<tr><td><code>xx</code></td>
<td>
<p>Numeric vector. Evaluation grid.</p>
</td></tr>
<tr><td><code>qx</code></td>
<td>
<p>Numeric array. Matrix
of dimension <code class="reqn">\texttt{Nx} \times (\texttt{length(probs)} + 1)</code> with the posterior mean and the desired quantiles input
in <code>probs</code>.</p>
</td></tr>
<tr><td><code>cpo</code></td>
<td>
<p>Numeric vector of <code>length(x)</code> with
conditional predictive ordinates.</p>
</td></tr>
<tr><td><code>R</code></td>
<td>
<p>Numeric vector of
<code>length(Nit*(1-Pbi))</code> with the number of mixtures components
(clusters).</p>
</td></tr>
<tr><td><code>U</code></td>
<td>
<p>Numeric vector of <code>length(Nit*(1-Pbi))</code> with the
values of the latent variable U.</p>
</td></tr>
<tr><td><code>Allocs</code></td>
<td>
<p>List of
<code>length(Nit*(1-Pbi))</code> with the clustering allocations.</p>
</td></tr>
<tr><td><code>means</code></td>
<td>
<p>List of <code>length(Nit*(1-Pbi))</code> with the cluster means
(locations). Only if extras = TRUE.</p>
</td></tr>
<tr><td><code>sigmas</code></td>
<td>
<p>Numeric vector of
<code>length(Nit*(1-Pbi))</code> with the cluster standard deviations. Only if
extras = TRUE.</p>
</td></tr>
<tr><td><code>weights</code></td>
<td>
<p>List of <code>length(Nit*(1-Pbi))</code> with the
mixture weights. Only if extras = TRUE.</p>
</td></tr>
<tr><td><code>Js</code></td>
<td>
<p>List of
<code>length(Nit*(1-Pbi))</code> with the unnormalized weights (jump sizes). Only
if extras = TRUE.</p>
</td></tr>
<tr><td><code>Nm</code></td>
<td>
<p>Integer constant. Number of jumps of the
continuous component of the unnormalized process.</p>
</td></tr>
<tr><td><code>delta_Us</code></td>
<td>
<p>List of
<code>length(Nit*(1-Pbi))</code> with the sequence of adapted delta_U used in the MH step for the latent variable U.</p>
</td></tr>
<tr><td><code>Nx</code></td>
<td>
<p>Integer
constant. Number of grid points for the evaluation of the density estimate.</p>
</td></tr>
<tr><td><code>Nit</code></td>
<td>
<p>Integer constant. Number of MCMC iterations.</p>
</td></tr>
<tr><td><code>Pbi</code></td>
<td>
<p>Numeric
constant. Burn-in period proportion of <code>Nit</code>.</p>
</td></tr>
<tr><td><code>procTime</code></td>
<td>
<p>Numeric
vector with execution time provided by <code>proc.time</code> function.</p>
</td></tr>
<tr><td><code>distr.k</code></td>
<td>
<p>Integer corresponding to the kernel chosen for the mixture</p>
</td></tr>
<tr><td><code>data</code></td>
<td>
<p>Data used for the fit</p>
</td></tr>
<tr><td><code>NRMI_params</code></td>
<td>
<p>A named list with the parameters of the NRMI process</p>
</td></tr>
</table>


<h3>Warning </h3>

<p>The function is computing intensive. Be patient.
</p>


<h3>Author(s)</h3>

<p>Barrios, E., Kon Kam King, G. and Nieto-Barajas, L.E.
</p>


<h3>References</h3>

<p>1.- Barrios, E., Lijoi, A., Nieto-Barajas, L. E. and Prünster,
I. (2013). Modeling with Normalized Random Measure Mixture Models.
Statistical Science. Vol. 28, No. 3, 313-334.
</p>
<p>2.- James, L.F., Lijoi, A. and Prünster, I. (2009). Posterior analysis for
normalized random measure with independent increments. Scand. J. Statist 36,
76-97.
</p>
<p>3.- Kon Kam King, G., Arbel, J. and Prünster, I. (2016). Species
Sensitivity Distribution revisited: a Bayesian nonparametric approach. In
preparation.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+MixNRMI2">MixNRMI2</a></code>, <code><a href="#topic+MixNRMI1cens">MixNRMI1cens</a></code>,
<code><a href="#topic+MixNRMI2cens">MixNRMI2cens</a></code>, <code><a href="#topic+multMixNRMI1">multMixNRMI1</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
### Example 1
# Data
data(acidity)
x &lt;- acidity
# Fitting the model under default specifications
out &lt;- MixNRMI2cens(x, x)
# Plotting density estimate + 95% credible interval
plot(out)

## End(Not run)

## Not run: 
### Example 2
# Data
data(salinity)
# Fitting the model under special specifications
out &lt;- MixNRMI2cens(
  xleft = salinity$left, xright = salinity$right, Nit = 5000, distr.pz0 = 10,
  mu.pz0 = 1, sigma.pz0 = 2
)
# Plotting density estimate + 95% credible interval
attach(out)
plot(out)
# Plotting number of clusters
par(mfrow = c(2, 1))
plot(R, type = "l", main = "Trace of R")
hist(R, breaks = min(R - 0.5):max(R + 0.5), probability = TRUE)
detach()

## End(Not run)

</code></pre>

<hr>
<h2 id='MixPY1'>Pitman-Yor process mixture  of Type I</h2><span id='topic+MixPY1'></span>

<h3>Description</h3>

<p>This function calls the PYdensity function from package BNPmix, to allow fitting a Pitman-Yor process mixture to the data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MixPY1(
  x,
  probs = c(0.025, 0.5, 0.975),
  Alpha = 1,
  Gama = 0.4,
  asigma = 2,
  bsigma = 1/var(x),
  Nx = 100,
  Nit = 1500,
  Pbi = 0.5,
  epsilon = NULL,
  printtime = TRUE,
  extras = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MixPY1_+3A_x">x</code></td>
<td>
<p>Numeric vector. Data set to which the density is fitted.</p>
</td></tr>
<tr><td><code id="MixPY1_+3A_probs">probs</code></td>
<td>
<p>Numeric vector. Desired quantiles of the density estimates.</p>
</td></tr>
<tr><td><code id="MixPY1_+3A_alpha">Alpha</code></td>
<td>
<p>Numeric constant. Total mass of the centering measure. See</p>
</td></tr>
<tr><td><code id="MixPY1_+3A_gama">Gama</code></td>
<td>
<p>Numeric constant. <code class="reqn">0\leq \texttt{Gama} \leq 1</code>.  See details.</p>
</td></tr>
<tr><td><code id="MixPY1_+3A_asigma">asigma</code></td>
<td>
<p>Numeric positive constant. Shape parameter of the gamma prior
on the standard deviation of the mixture kernel. Default value suggested by package BNPmix.</p>
</td></tr>
<tr><td><code id="MixPY1_+3A_bsigma">bsigma</code></td>
<td>
<p>Numeric positive constant. Rate parameter of the gamma prior
on the standard deviation of the mixture kernel. Default value suggested by package BNPmix.</p>
</td></tr>
<tr><td><code id="MixPY1_+3A_nx">Nx</code></td>
<td>
<p>Integer constant. Number of grid points for the evaluation of the
density estimate.</p>
</td></tr>
<tr><td><code id="MixPY1_+3A_nit">Nit</code></td>
<td>
<p>Integer constant. Number of MCMC iterations.</p>
</td></tr>
<tr><td><code id="MixPY1_+3A_pbi">Pbi</code></td>
<td>
<p>Numeric constant. Burn-in period proportion of Nit.</p>
</td></tr>
<tr><td><code id="MixPY1_+3A_epsilon">epsilon</code></td>
<td>
<p>Numeric constant. Extension to the evaluation grid range.
See details.</p>
</td></tr>
<tr><td><code id="MixPY1_+3A_printtime">printtime</code></td>
<td>
<p>Logical. If TRUE, prints out the execution time.</p>
</td></tr>
<tr><td><code id="MixPY1_+3A_extras">extras</code></td>
<td>
<p>Logical. If TRUE, gives additional objects: means and weights</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns a MixPY1 object. It is based on a list with the following components:
</p>
<table>
<tr><td><code>xx</code></td>
<td>
<p>Numeric vector. Evaluation grid.</p>
</td></tr>
<tr><td><code>qx</code></td>
<td>
<p>Numeric array. Matrix
of dimension <code class="reqn">\texttt{Nx} \times (\texttt{length(probs)} + 1)</code> with the posterior mean and the desired quantiles input
in <code>probs</code>.</p>
</td></tr>
<tr><td><code>R</code></td>
<td>
<p>Numeric vector of
<code>length(Nit*(1-Pbi))</code> with the number of mixtures components
(clusters).</p>
</td></tr>
<tr><td><code>S</code></td>
<td>
<p>Numeric vector of <code>length(Nit*(1-Pbi))</code> with the
values of common standard deviation sigma.</p>
</td></tr>
<tr><td><code>Allocs</code></td>
<td>
<p>List of <code>length(Nit*(1-Pbi))</code> with the clustering
allocations.</p>
</td></tr>
<tr><td><code>means</code></td>
<td>
<p>List of <code>length(Nit*(1-Pbi))</code> with the
cluster means (locations). Only if extras = TRUE.</p>
</td></tr>
<tr><td><code>weights</code></td>
<td>
<p>List of
<code>length(Nit*(1-Pbi))</code> with the mixture weights. Only if extras = TRUE.</p>
</td></tr>
<tr><td><code>Nit</code></td>
<td>
<p>Integer constant. Number of MCMC iterations.</p>
</td></tr>
<tr><td><code>Pbi</code></td>
<td>
<p>Numeric constant. Burn-in period proportion of <code>Nit</code>.</p>
</td></tr>
<tr><td><code>distr.k</code></td>
<td>
<p>Integer corresponding to the kernel chosen for the mixture. Always 1, since the Pitman-Yor process is only written to work with Gaussian kernels.</p>
</td></tr>
<tr><td><code>data</code></td>
<td>
<p>Data used for the fit</p>
</td></tr>
<tr><td><code>PY_params</code></td>
<td>
<p>A named list with the parameters of the Pitman-Yor process</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># Data
data(acidity)
x &lt;- acidity
# Fitting the model under default specifications
out &lt;- MixPY1(x)
# Plotting density estimate + 95% credible interval
plot(out)
</code></pre>

<hr>
<h2 id='MixPY2'>Pitman-Yor process mixture  of Type II</h2><span id='topic+MixPY2'></span>

<h3>Description</h3>

<p>This function calls the PYdensity function from package BNPmix, to allow fitting a Pitman-Yor process mixture to the data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MixPY2(
  x,
  probs = c(0.025, 0.5, 0.975),
  Alpha = 1,
  Gama = 0.4,
  asigma = 2,
  bsigma = 1/var(x),
  Nx = 100,
  Nit = 1500,
  Pbi = 0.5,
  epsilon = NULL,
  printtime = TRUE,
  extras = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MixPY2_+3A_x">x</code></td>
<td>
<p>Numeric vector. Data set to which the density is fitted.</p>
</td></tr>
<tr><td><code id="MixPY2_+3A_probs">probs</code></td>
<td>
<p>Numeric vector. Desired quantiles of the density estimates.</p>
</td></tr>
<tr><td><code id="MixPY2_+3A_alpha">Alpha</code></td>
<td>
<p>Numeric constant. Total mass of the centering measure. See</p>
</td></tr>
<tr><td><code id="MixPY2_+3A_gama">Gama</code></td>
<td>
<p>Numeric constant. <code class="reqn">0\leq \texttt{Gama} \leq 1</code>.  See details.</p>
</td></tr>
<tr><td><code id="MixPY2_+3A_asigma">asigma</code></td>
<td>
<p>Numeric positive constant. Shape parameter of the gamma prior
on the standard deviation of the mixture kernel. Default value suggested by package BNPmix.</p>
</td></tr>
<tr><td><code id="MixPY2_+3A_bsigma">bsigma</code></td>
<td>
<p>Numeric positive constant. Rate parameter of the gamma prior
on the standard deviation of the mixture kernel. Default value suggested by package BNPmix.</p>
</td></tr>
<tr><td><code id="MixPY2_+3A_nx">Nx</code></td>
<td>
<p>Integer constant. Number of grid points for the evaluation of the
density estimate.</p>
</td></tr>
<tr><td><code id="MixPY2_+3A_nit">Nit</code></td>
<td>
<p>Integer constant. Number of MCMC iterations.</p>
</td></tr>
<tr><td><code id="MixPY2_+3A_pbi">Pbi</code></td>
<td>
<p>Numeric constant. Burn-in period proportion of Nit.</p>
</td></tr>
<tr><td><code id="MixPY2_+3A_epsilon">epsilon</code></td>
<td>
<p>Numeric constant. Extension to the evaluation grid range.
See details.</p>
</td></tr>
<tr><td><code id="MixPY2_+3A_printtime">printtime</code></td>
<td>
<p>Logical. If TRUE, prints out the execution time.</p>
</td></tr>
<tr><td><code id="MixPY2_+3A_extras">extras</code></td>
<td>
<p>Logical. If TRUE, gives additional objects: means and weights</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns a MixPY2 object. It is based on a list with the following components:
</p>
<table>
<tr><td><code>xx</code></td>
<td>
<p>Numeric vector. Evaluation grid.</p>
</td></tr>
<tr><td><code>qx</code></td>
<td>
<p>Numeric array. Matrix
of dimension <code class="reqn">\texttt{Nx} \times (\texttt{length(probs)} + 1)</code> with the posterior mean and the desired quantiles input
in <code>probs</code>.</p>
</td></tr>
<tr><td><code>R</code></td>
<td>
<p>Numeric vector of
<code>length(Nit*(1-Pbi))</code> with the number of mixtures components
(clusters).</p>
</td></tr>
<tr><td><code>Allocs</code></td>
<td>
<p>List of <code>length(Nit*(1-Pbi))</code> with the clustering
allocations.</p>
</td></tr>
<tr><td><code>means</code></td>
<td>
<p>List of <code>length(Nit*(1-Pbi))</code> with the
cluster means (locations). Only if extras = TRUE.</p>
</td></tr>
<tr><td><code>sigmas</code></td>
<td>
<p>List of <code>length(Nit*(1-Pbi))</code> with the
cluster standard deviations (scales). Only if extras = TRUE.</p>
</td></tr>
<tr><td><code>weights</code></td>
<td>
<p>List of
<code>length(Nit*(1-Pbi))</code> with the mixture weights. Only if extras = TRUE.</p>
</td></tr>
<tr><td><code>Nit</code></td>
<td>
<p>Integer constant. Number of MCMC iterations.</p>
</td></tr>
<tr><td><code>Pbi</code></td>
<td>
<p>Numeric constant. Burn-in period proportion of <code>Nit</code>.</p>
</td></tr>
<tr><td><code>distr.k</code></td>
<td>
<p>Integer corresponding to the kernel chosen for the mixture. Always 1, since the Pitman-Yor process is only written to work with Gaussian kernels.</p>
</td></tr>
<tr><td><code>data</code></td>
<td>
<p>Data used for the fit</p>
</td></tr>
<tr><td><code>PY_params</code></td>
<td>
<p>A named list with the parameters of the Pitman-Yor process</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># Data
data(acidity)
x &lt;- acidity
# Fitting the model under default specifications
out &lt;- MixPY2(x)
# Plotting density estimate + 95% credible interval
plot(out)
</code></pre>

<hr>
<h2 id='multMixNRMI1'>Multiple chains of MixNRMI1</h2><span id='topic+multMixNRMI1'></span>

<h3>Description</h3>

<p>Multiple chains of MixNRMI1
</p>


<h3>Usage</h3>

<pre><code class='language-R'>multMixNRMI1(
  x,
  probs = c(0.025, 0.5, 0.975),
  Alpha = 1,
  Kappa = 0,
  Gama = 0.4,
  distr.k = "normal",
  distr.p0 = "normal",
  asigma = 0.5,
  bsigma = 0.5,
  delta_S = 3,
  delta_U = 2,
  Meps = 0.01,
  Nx = 150,
  Nit = 1500,
  Pbi = 0.1,
  epsilon = NULL,
  printtime = TRUE,
  extras = TRUE,
  adaptive = FALSE,
  nchains = 4,
  parallel = TRUE,
  ncores = parallel::detectCores()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="multMixNRMI1_+3A_x">x</code></td>
<td>
<p>Numeric vector. Data set to which the density is fitted.</p>
</td></tr>
<tr><td><code id="multMixNRMI1_+3A_probs">probs</code></td>
<td>
<p>Numeric vector. Desired quantiles of the density estimates.</p>
</td></tr>
<tr><td><code id="multMixNRMI1_+3A_alpha">Alpha</code></td>
<td>
<p>Numeric constant. Total mass of the centering measure. See
details.</p>
</td></tr>
<tr><td><code id="multMixNRMI1_+3A_kappa">Kappa</code></td>
<td>
<p>Numeric positive constant. See details.</p>
</td></tr>
<tr><td><code id="multMixNRMI1_+3A_gama">Gama</code></td>
<td>
<p>Numeric constant. <code class="reqn">0\leq \texttt{Gama} \leq 1</code>.  See details.</p>
</td></tr>
<tr><td><code id="multMixNRMI1_+3A_distr.k">distr.k</code></td>
<td>
<p>The distribution name for the kernel. Allowed names are &quot;normal&quot;, &quot;gamma&quot;, &quot;beta&quot;, &quot;double exponential&quot;, &quot;lognormal&quot; or their common abbreviations &quot;norm&quot;, &quot;exp&quot;, or an integer number identifying the mixture kernel: 1 = Normal; 2 = Gamma; 3 = Beta; 4 = Double Exponential; 5 = Lognormal.</p>
</td></tr>
<tr><td><code id="multMixNRMI1_+3A_distr.p0">distr.p0</code></td>
<td>
<p>The distribution name for the centering measure. Allowed names are &quot;normal&quot;, &quot;gamma&quot;, &quot;beta&quot;, or their common abbreviations &quot;norm&quot;, &quot;exp&quot;, or an integer number identifying the centering measure: 1 = Normal; 2 = Gamma; 3 = Beta.</p>
</td></tr>
<tr><td><code id="multMixNRMI1_+3A_asigma">asigma</code></td>
<td>
<p>Numeric positive constant. Shape parameter of the gamma prior
on the standard deviation of the mixture kernel <code>distr.k</code>.</p>
</td></tr>
<tr><td><code id="multMixNRMI1_+3A_bsigma">bsigma</code></td>
<td>
<p>Numeric positive constant. Rate parameter of the gamma prior
on the standard deviation of the mixture kernel <code>distr.k</code>.</p>
</td></tr>
<tr><td><code id="multMixNRMI1_+3A_delta_s">delta_S</code></td>
<td>
<p>Numeric positive constant. Metropolis-Hastings proposal
variation coefficient for sampling sigma.</p>
</td></tr>
<tr><td><code id="multMixNRMI1_+3A_delta_u">delta_U</code></td>
<td>
<p>Numeric positive constant. Metropolis-Hastings proposal
variation coefficient for sampling the latent U.</p>
</td></tr>
<tr><td><code id="multMixNRMI1_+3A_meps">Meps</code></td>
<td>
<p>Numeric constant. Relative error of the jump sizes in the
continuous component of the process. Smaller values imply larger number of
jumps.</p>
</td></tr>
<tr><td><code id="multMixNRMI1_+3A_nx">Nx</code></td>
<td>
<p>Integer constant. Number of grid points for the evaluation of the
density estimate.</p>
</td></tr>
<tr><td><code id="multMixNRMI1_+3A_nit">Nit</code></td>
<td>
<p>Integer constant. Number of MCMC iterations.</p>
</td></tr>
<tr><td><code id="multMixNRMI1_+3A_pbi">Pbi</code></td>
<td>
<p>Numeric constant. Burn-in period proportion of Nit.</p>
</td></tr>
<tr><td><code id="multMixNRMI1_+3A_epsilon">epsilon</code></td>
<td>
<p>Numeric constant. Extension to the evaluation grid range.
See details.</p>
</td></tr>
<tr><td><code id="multMixNRMI1_+3A_printtime">printtime</code></td>
<td>
<p>Logical. If TRUE, prints out the execution time.</p>
</td></tr>
<tr><td><code id="multMixNRMI1_+3A_extras">extras</code></td>
<td>
<p>Logical. If TRUE, gives additional objects: means, weights and
Js.</p>
</td></tr>
<tr><td><code id="multMixNRMI1_+3A_adaptive">adaptive</code></td>
<td>
<p>Logical. If TRUE, uses an adaptive MCMC strategy to sample the latent U (adaptive delta_U).</p>
</td></tr>
<tr><td><code id="multMixNRMI1_+3A_nchains">nchains</code></td>
<td>
<p>The number of chains to run.</p>
</td></tr>
<tr><td><code id="multMixNRMI1_+3A_parallel">parallel</code></td>
<td>
<p>Whether to run the chains in parallel. Only works on UNIX-like systems as it rests on Fork parallelism</p>
</td></tr>
<tr><td><code id="multMixNRMI1_+3A_ncores">ncores</code></td>
<td>
<p>Number of cores for the parallel run. Defaults to parallel::detectCores(), i.e. the maximum number of cores detected by R on your system.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list containing the multiple fits.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+MixNRMI2">MixNRMI2</a></code>, <code><a href="#topic+MixNRMI1cens">MixNRMI1cens</a></code>,
<code><a href="#topic+MixNRMI2cens">MixNRMI2cens</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(acidity)
multMixNRMI1(acidity, parallel = TRUE, Nit = 10, ncores = 2)
</code></pre>

<hr>
<h2 id='multMixNRMI1cens'>Multiple chains of MixNRMI1cens</h2><span id='topic+multMixNRMI1cens'></span>

<h3>Description</h3>

<p>Multiple chains of MixNRMI1cens
</p>


<h3>Usage</h3>

<pre><code class='language-R'>multMixNRMI1cens(
  xleft,
  xright,
  probs = c(0.025, 0.5, 0.975),
  Alpha = 1,
  Kappa = 0,
  Gama = 0.4,
  distr.k = "normal",
  distr.p0 = "normal",
  asigma = 0.5,
  bsigma = 0.5,
  delta_S = 3,
  delta_U = 2,
  Meps = 0.01,
  Nx = 150,
  Nit = 1500,
  Pbi = 0.1,
  epsilon = NULL,
  printtime = TRUE,
  extras = TRUE,
  adaptive = FALSE,
  nchains = 4,
  parallel = TRUE,
  ncores = parallel::detectCores()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="multMixNRMI1cens_+3A_xleft">xleft</code></td>
<td>
<p>Numeric vector. Lower limit of interval censoring. For exact
data the same as xright</p>
</td></tr>
<tr><td><code id="multMixNRMI1cens_+3A_xright">xright</code></td>
<td>
<p>Numeric vector. Upper limit of interval censoring. For exact
data the same as xleft.</p>
</td></tr>
<tr><td><code id="multMixNRMI1cens_+3A_probs">probs</code></td>
<td>
<p>Numeric vector. Desired quantiles of the density estimates.</p>
</td></tr>
<tr><td><code id="multMixNRMI1cens_+3A_alpha">Alpha</code></td>
<td>
<p>Numeric constant. Total mass of the centering measure. See
details.</p>
</td></tr>
<tr><td><code id="multMixNRMI1cens_+3A_kappa">Kappa</code></td>
<td>
<p>Numeric positive constant. See details.</p>
</td></tr>
<tr><td><code id="multMixNRMI1cens_+3A_gama">Gama</code></td>
<td>
<p>Numeric constant. <code class="reqn">0\leq \texttt{Gama} \leq 1</code>.  See details.</p>
</td></tr>
<tr><td><code id="multMixNRMI1cens_+3A_distr.k">distr.k</code></td>
<td>
<p>The distribution name for the kernel. Allowed names are &quot;normal&quot;, &quot;gamma&quot;, &quot;beta&quot;, &quot;double exponential&quot;, &quot;lognormal&quot; or their common abbreviations &quot;norm&quot;, &quot;exp&quot;, or an integer number identifying the mixture kernel: 1 = Normal; 2 = Gamma; 3 = Beta; 4 = Double Exponential; 5 = Lognormal.</p>
</td></tr>
<tr><td><code id="multMixNRMI1cens_+3A_distr.p0">distr.p0</code></td>
<td>
<p>The distribution name for the centering measure. Allowed names are &quot;normal&quot;, &quot;gamma&quot;, &quot;beta&quot;, or their common abbreviations &quot;norm&quot;, &quot;exp&quot;, or an integer number identifying the centering measure: 1 = Normal; 2 = Gamma; 3 = Beta.</p>
</td></tr>
<tr><td><code id="multMixNRMI1cens_+3A_asigma">asigma</code></td>
<td>
<p>Numeric positive constant. Shape parameter of the gamma prior
on the standard deviation of the mixture kernel <code>distr.k</code>.</p>
</td></tr>
<tr><td><code id="multMixNRMI1cens_+3A_bsigma">bsigma</code></td>
<td>
<p>Numeric positive constant. Rate parameter of the gamma prior
on the standard deviation of the mixture kernel <code>distr.k</code>.</p>
</td></tr>
<tr><td><code id="multMixNRMI1cens_+3A_delta_s">delta_S</code></td>
<td>
<p>Numeric positive constant. Metropolis-Hastings proposal
variation coefficient for sampling sigma.</p>
</td></tr>
<tr><td><code id="multMixNRMI1cens_+3A_delta_u">delta_U</code></td>
<td>
<p>Numeric positive constant. Metropolis-Hastings proposal
variation coefficient for sampling the latent U.</p>
</td></tr>
<tr><td><code id="multMixNRMI1cens_+3A_meps">Meps</code></td>
<td>
<p>Numeric constant. Relative error of the jump sizes in the
continuous component of the process. Smaller values imply larger number of
jumps.</p>
</td></tr>
<tr><td><code id="multMixNRMI1cens_+3A_nx">Nx</code></td>
<td>
<p>Integer constant. Number of grid points for the evaluation of the
density estimate.</p>
</td></tr>
<tr><td><code id="multMixNRMI1cens_+3A_nit">Nit</code></td>
<td>
<p>Integer constant. Number of MCMC iterations.</p>
</td></tr>
<tr><td><code id="multMixNRMI1cens_+3A_pbi">Pbi</code></td>
<td>
<p>Numeric constant. Burn-in period proportion of Nit.</p>
</td></tr>
<tr><td><code id="multMixNRMI1cens_+3A_epsilon">epsilon</code></td>
<td>
<p>Numeric constant. Extension to the evaluation grid range.
See details.</p>
</td></tr>
<tr><td><code id="multMixNRMI1cens_+3A_printtime">printtime</code></td>
<td>
<p>Logical. If TRUE, prints out the execution time.</p>
</td></tr>
<tr><td><code id="multMixNRMI1cens_+3A_extras">extras</code></td>
<td>
<p>Logical. If TRUE, gives additional objects: means, weights and
Js.</p>
</td></tr>
<tr><td><code id="multMixNRMI1cens_+3A_adaptive">adaptive</code></td>
<td>
<p>Logical. If TRUE, uses an adaptive MCMC strategy to sample the latent U (adaptive delta_U).</p>
</td></tr>
<tr><td><code id="multMixNRMI1cens_+3A_nchains">nchains</code></td>
<td>
<p>The number of chains to run.</p>
</td></tr>
<tr><td><code id="multMixNRMI1cens_+3A_parallel">parallel</code></td>
<td>
<p>Whether to run the chains in parallel. Only works on
UNIX-like systems as it rests on Fork parallelism</p>
</td></tr>
<tr><td><code id="multMixNRMI1cens_+3A_ncores">ncores</code></td>
<td>
<p>Number of cores for the parallel run. Defaults to
parallel::detectCores(), i.e. the maximum number of cores detected by R on
your system.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list containing the multiple fits.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+MixNRMI2">MixNRMI2</a></code>, <code><a href="#topic+MixNRMI1cens">MixNRMI1cens</a></code>,
<code><a href="#topic+MixNRMI2cens">MixNRMI2cens</a></code>, <code><a href="#topic+multMixNRMI1">multMixNRMI1</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(salinity)
multMixNRMI1cens(salinity$left, salinity$right, parallel = TRUE, Nit = 10, ncores = 2)
</code></pre>

<hr>
<h2 id='multMixNRMI2'>Multiple chains of MixNRMI2</h2><span id='topic+multMixNRMI2'></span>

<h3>Description</h3>

<p>Multiple chains of MixNRMI2
</p>


<h3>Usage</h3>

<pre><code class='language-R'>multMixNRMI2(
  x,
  probs = c(0.025, 0.5, 0.975),
  Alpha = 1,
  Kappa = 0,
  Gama = 0.4,
  distr.k = "normal",
  distr.py0 = "normal",
  distr.pz0 = "gamma",
  mu.pz0 = 3,
  sigma.pz0 = sqrt(10),
  delta_S = 4,
  kappa = 2,
  delta_U = 2,
  Meps = 0.01,
  Nx = 150,
  Nit = 1500,
  Pbi = 0.1,
  epsilon = NULL,
  printtime = TRUE,
  extras = TRUE,
  adaptive = FALSE,
  nchains = 4,
  parallel = FALSE,
  ncores = parallel::detectCores()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="multMixNRMI2_+3A_x">x</code></td>
<td>
<p>Numeric vector. Data set to which the density is fitted.</p>
</td></tr>
<tr><td><code id="multMixNRMI2_+3A_probs">probs</code></td>
<td>
<p>Numeric vector. Desired quantiles of the density estimates.</p>
</td></tr>
<tr><td><code id="multMixNRMI2_+3A_alpha">Alpha</code></td>
<td>
<p>Numeric constant. Total mass of the centering measure.  See
details.</p>
</td></tr>
<tr><td><code id="multMixNRMI2_+3A_kappa">Kappa</code></td>
<td>
<p>Numeric positive constant. See details.</p>
</td></tr>
<tr><td><code id="multMixNRMI2_+3A_gama">Gama</code></td>
<td>
<p>Numeric constant. <code class="reqn">0 \leq Gama \leq 1</code>.  See
details.</p>
</td></tr>
<tr><td><code id="multMixNRMI2_+3A_distr.k">distr.k</code></td>
<td>
<p>The distribution name for the kernel. Allowed names are &quot;normal&quot;, &quot;gamma&quot;, &quot;beta&quot;, &quot;double exponential&quot;, &quot;lognormal&quot; or their common abbreviations &quot;norm&quot;, &quot;exp&quot;, or an integer number identifying the mixture kernel: 1 = Normal; 2 = Gamma; 3 = Beta; 4 = Double Exponential; 5 = Lognormal.</p>
</td></tr>
<tr><td><code id="multMixNRMI2_+3A_distr.py0">distr.py0</code></td>
<td>
<p>The distribution name for the centering measure for locations. Allowed names are &quot;normal&quot;, &quot;gamma&quot;, &quot;beta&quot;, or their common abbreviations &quot;norm&quot;, &quot;exp&quot;, or an integer number identifying the centering measure for locations: 1 = Normal; 2 = Gamma; 3 = Beta.</p>
</td></tr>
<tr><td><code id="multMixNRMI2_+3A_distr.pz0">distr.pz0</code></td>
<td>
<p>The distribution name for the centering measure for scales.  Allowed names are &quot;gamma&quot;, or an integer number identifying the centering measure for
scales: 2 = Gamma. For more options use <code><a href="#topic+MixNRMI2cens">MixNRMI2cens</a></code>.</p>
</td></tr>
<tr><td><code id="multMixNRMI2_+3A_mu.pz0">mu.pz0</code></td>
<td>
<p>Numeric constant. Prior mean of the centering measure for
scales.</p>
</td></tr>
<tr><td><code id="multMixNRMI2_+3A_sigma.pz0">sigma.pz0</code></td>
<td>
<p>Numeric constant. Prior standard deviation of the centering
measure for scales.</p>
</td></tr>
<tr><td><code id="multMixNRMI2_+3A_delta_s">delta_S</code></td>
<td>
<p>Numeric positive constant. Metropolis-Hastings proposal
variation coefficient for sampling the scales.</p>
</td></tr>
<tr><td><code id="multMixNRMI2_+3A_kappa">kappa</code></td>
<td>
<p>Numeric positive constant. Metropolis-Hastings proposal
variation coefficient for sampling the location parameters.</p>
</td></tr>
<tr><td><code id="multMixNRMI2_+3A_delta_u">delta_U</code></td>
<td>
<p>Numeric positive constant. Metropolis-Hastings proposal
variation coefficient for sampling the latent U. If 'adaptive=TRUE', 'delta_U'is the starting value for the adaptation.</p>
</td></tr>
<tr><td><code id="multMixNRMI2_+3A_meps">Meps</code></td>
<td>
<p>Numeric constant. Relative error of the jump sizes in the
continuous component of the process. Smaller values imply larger number of
jumps.</p>
</td></tr>
<tr><td><code id="multMixNRMI2_+3A_nx">Nx</code></td>
<td>
<p>Integer constant. Number of grid points for the evaluation of the
density estimate.</p>
</td></tr>
<tr><td><code id="multMixNRMI2_+3A_nit">Nit</code></td>
<td>
<p>Integer constant. Number of MCMC iterations.</p>
</td></tr>
<tr><td><code id="multMixNRMI2_+3A_pbi">Pbi</code></td>
<td>
<p>Numeric constant. Burn-in period proportion of <code>Nit</code>.</p>
</td></tr>
<tr><td><code id="multMixNRMI2_+3A_epsilon">epsilon</code></td>
<td>
<p>Numeric constant. Extension to the evaluation grid range.
See details.</p>
</td></tr>
<tr><td><code id="multMixNRMI2_+3A_printtime">printtime</code></td>
<td>
<p>Logical. If TRUE, prints out the execution time.</p>
</td></tr>
<tr><td><code id="multMixNRMI2_+3A_extras">extras</code></td>
<td>
<p>Logical. If TRUE, gives additional objects: means, sigmas,
weights and Js.</p>
</td></tr>
<tr><td><code id="multMixNRMI2_+3A_adaptive">adaptive</code></td>
<td>
<p>Logical. If TRUE, uses an adaptive MCMC strategy to sample the latent U (adaptive delta_U).</p>
</td></tr>
<tr><td><code id="multMixNRMI2_+3A_nchains">nchains</code></td>
<td>
<p>The number of chains to run.</p>
</td></tr>
<tr><td><code id="multMixNRMI2_+3A_parallel">parallel</code></td>
<td>
<p>Whether to run the chains in parallel. Only works on UNIX-like systems as it rests on Fork parallelism</p>
</td></tr>
<tr><td><code id="multMixNRMI2_+3A_ncores">ncores</code></td>
<td>
<p>Number of cores for the parallel run. Defaults to parallel::detectCores(), i.e. the maximum number of cores detected by R on your system.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list containing the multiple fits.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+MixNRMI2">MixNRMI2</a></code>, <code><a href="#topic+MixNRMI1cens">MixNRMI1cens</a></code>,
<code><a href="#topic+MixNRMI2cens">MixNRMI2cens</a></code>, <code><a href="#topic+multMixNRMI1">multMixNRMI1</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(acidity)
multMixNRMI2(acidity, parallel = TRUE, Nit = 10, ncores = 2)
</code></pre>

<hr>
<h2 id='multMixNRMI2cens'>Multiple chains of MixNRMI2cens</h2><span id='topic+multMixNRMI2cens'></span>

<h3>Description</h3>

<p>Multiple chains of MixNRMI2cens
</p>


<h3>Usage</h3>

<pre><code class='language-R'>multMixNRMI2cens(
  xleft,
  xright,
  probs = c(0.025, 0.5, 0.975),
  Alpha = 1,
  Kappa = 0,
  Gama = 0.4,
  distr.k = "normal",
  distr.py0 = "normal",
  distr.pz0 = "gamma",
  mu.pz0 = 3,
  sigma.pz0 = sqrt(10),
  delta_S = 4,
  kappa = 2,
  delta_U = 2,
  Meps = 0.01,
  Nx = 150,
  Nit = 1500,
  Pbi = 0.1,
  epsilon = NULL,
  printtime = TRUE,
  extras = TRUE,
  adaptive = FALSE,
  nchains = 4,
  parallel = TRUE,
  ncores = parallel::detectCores()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="multMixNRMI2cens_+3A_xleft">xleft</code></td>
<td>
<p>Numeric vector. Lower limit of interval censoring. For exact
data the same as xright</p>
</td></tr>
<tr><td><code id="multMixNRMI2cens_+3A_xright">xright</code></td>
<td>
<p>Numeric vector. Upper limit of interval censoring. For exact
data the same as xleft.</p>
</td></tr>
<tr><td><code id="multMixNRMI2cens_+3A_probs">probs</code></td>
<td>
<p>Numeric vector. Desired quantiles of the density estimates.</p>
</td></tr>
<tr><td><code id="multMixNRMI2cens_+3A_alpha">Alpha</code></td>
<td>
<p>Numeric constant. Total mass of the centering measure.  See
details.</p>
</td></tr>
<tr><td><code id="multMixNRMI2cens_+3A_kappa">Kappa</code></td>
<td>
<p>Numeric positive constant. See details.</p>
</td></tr>
<tr><td><code id="multMixNRMI2cens_+3A_gama">Gama</code></td>
<td>
<p>Numeric constant. <code class="reqn">0 \leq Gama \leq 1</code>.  See
details.</p>
</td></tr>
<tr><td><code id="multMixNRMI2cens_+3A_distr.k">distr.k</code></td>
<td>
<p>The distribution name for the kernel. Allowed names are &quot;normal&quot;, &quot;gamma&quot;, &quot;beta&quot;, &quot;double exponential&quot;, &quot;lognormal&quot; or their common abbreviations &quot;norm&quot;, &quot;exp&quot;, or an integer number identifying the mixture kernel: 1 = Normal; 2 = Gamma; 3 = Beta; 4 = Double Exponential; 5 = Lognormal.</p>
</td></tr>
<tr><td><code id="multMixNRMI2cens_+3A_distr.py0">distr.py0</code></td>
<td>
<p>The distribution name for the centering measure for locations. Allowed names are &quot;normal&quot;, &quot;gamma&quot;, &quot;beta&quot;, or their common abbreviations &quot;norm&quot;, &quot;exp&quot;, or an integer number identifying the centering measure for locations: 1 = Normal; 2 = Gamma; 3 = Beta.</p>
</td></tr>
<tr><td><code id="multMixNRMI2cens_+3A_distr.pz0">distr.pz0</code></td>
<td>
<p>The distribution name for the centering measure for scales.  Allowed names are &quot;gamma&quot;, &quot;lognormal&quot;, &quot;half-Cauchy&quot;, &quot;half-normal&quot;, &quot;half-student&quot;, &quot;uniform&quot; and &quot;truncated normal&quot;, or their common abbreviations &quot;norm&quot;, &quot;exp&quot;, &quot;lnorm&quot;, &quot;halfcauchy&quot;, &quot;halfnorm&quot;, &quot;halft&quot; and &quot;unif&quot;, or an integer number identifying the centering measure for scales: 2 = Gamma, 5 = Lognormal, 6 = Half Cauchy, 7 = Half Normal, 8 = Half Student-t, 9 = Uniform, 10 = Truncated Normal.</p>
</td></tr>
<tr><td><code id="multMixNRMI2cens_+3A_mu.pz0">mu.pz0</code></td>
<td>
<p>Numeric constant. Prior mean of the centering measure for
scales.</p>
</td></tr>
<tr><td><code id="multMixNRMI2cens_+3A_sigma.pz0">sigma.pz0</code></td>
<td>
<p>Numeric constant. Prior standard deviation of the centering
measure for scales.</p>
</td></tr>
<tr><td><code id="multMixNRMI2cens_+3A_delta_s">delta_S</code></td>
<td>
<p>Numeric positive constant. Metropolis-Hastings proposal
variation coefficient for sampling the scales.</p>
</td></tr>
<tr><td><code id="multMixNRMI2cens_+3A_kappa">kappa</code></td>
<td>
<p>Numeric positive constant. Metropolis-Hastings proposal
variation coefficient for sampling the location parameters.</p>
</td></tr>
<tr><td><code id="multMixNRMI2cens_+3A_delta_u">delta_U</code></td>
<td>
<p>Numeric positive constant. Metropolis-Hastings proposal
variation coefficient for sampling the latent U. If 'adaptive=TRUE', 'delta_U'is the starting value for the adaptation.</p>
</td></tr>
<tr><td><code id="multMixNRMI2cens_+3A_meps">Meps</code></td>
<td>
<p>Numeric constant. Relative error of the jump sizes in the
continuous component of the process. Smaller values imply larger number of
jumps.</p>
</td></tr>
<tr><td><code id="multMixNRMI2cens_+3A_nx">Nx</code></td>
<td>
<p>Integer constant. Number of grid points for the evaluation of the
density estimate.</p>
</td></tr>
<tr><td><code id="multMixNRMI2cens_+3A_nit">Nit</code></td>
<td>
<p>Integer constant. Number of MCMC iterations.</p>
</td></tr>
<tr><td><code id="multMixNRMI2cens_+3A_pbi">Pbi</code></td>
<td>
<p>Numeric constant. Burn-in period proportion of <code>Nit</code>.</p>
</td></tr>
<tr><td><code id="multMixNRMI2cens_+3A_epsilon">epsilon</code></td>
<td>
<p>Numeric constant. Extension to the evaluation grid range.
See details.</p>
</td></tr>
<tr><td><code id="multMixNRMI2cens_+3A_printtime">printtime</code></td>
<td>
<p>Logical. If TRUE, prints out the execution time.</p>
</td></tr>
<tr><td><code id="multMixNRMI2cens_+3A_extras">extras</code></td>
<td>
<p>Logical. If TRUE, gives additional objects: means, sigmas,
weights and Js.</p>
</td></tr>
<tr><td><code id="multMixNRMI2cens_+3A_adaptive">adaptive</code></td>
<td>
<p>Logical. If TRUE, uses an adaptive MCMC strategy to sample the latent U (adaptive delta_U).</p>
</td></tr>
<tr><td><code id="multMixNRMI2cens_+3A_nchains">nchains</code></td>
<td>
<p>The number of chains to run.</p>
</td></tr>
<tr><td><code id="multMixNRMI2cens_+3A_parallel">parallel</code></td>
<td>
<p>Whether to run the chains in parallel. Only works on
UNIX-like systems as it rests on Fork parallelism</p>
</td></tr>
<tr><td><code id="multMixNRMI2cens_+3A_ncores">ncores</code></td>
<td>
<p>Number of cores for the parallel run. Defaults to
parallel::detectCores(), i.e. the maximum number of cores detected by R on
your system.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list containing the multiple fits.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+MixNRMI2">MixNRMI2</a></code>, <code><a href="#topic+MixNRMI1cens">MixNRMI1cens</a></code>,
<code><a href="#topic+MixNRMI2cens">MixNRMI2cens</a></code>, <code><a href="#topic+multMixNRMI1">multMixNRMI1</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(salinity)
## Not run: 
multMixNRMI2cens(salinity$left, salinity$right, parallel = TRUE, Nit = 20, ncores = 2)

## End(Not run)

</code></pre>

<hr>
<h2 id='Mv'>Continuous Jump heights function</h2><span id='topic+Mv'></span>

<h3>Description</h3>

<p>This function evaluates the M(v) function that determines the jump heights
in the &quot;continuous&quot; part of an increasing additive process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Mv(u, alpha, beta, gama, low, upp, N)
</code></pre>


<h3>Details</h3>

<p>For internal use.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## The function is currently defined as
function(u = 0.5, alpha = 1, beta = 1, gama = 1 / 2, low = 1e-04,
         upp = 10, N = 5001) {
  x &lt;- -log(seq(from = exp(-low), to = exp(-upp), length = N))
  f &lt;- alpha / gamma(1 - gama) * x^(-(1 + gama)) * exp(-(u +
    beta) * x)
  dx &lt;- diff(x)
  h &lt;- (f[-1] + f[-N]) / 2
  Mv &lt;- rep(0, N)
  for (i in seq(N - 1, 1)) Mv[i] &lt;- Mv[i + 1] + dx[i] * h[i]
  return(list(v = x, Mv = Mv))
}
</code></pre>

<hr>
<h2 id='MvInv'>Invert jump heights function</h2><span id='topic+MvInv'></span>

<h3>Description</h3>

<p>Determines the jump heights of an increasing additive process by inverting
the M(v) function. Use a truncation level based on expected moments of the NGG process (<code><a href="#topic+thresholdGG">thresholdGG</a></code>).
For internal use.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MvInv(eps, u = 0.5, alpha = 1, kappa = 1, gama = 1/2, N = 3001)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MvInv_+3A_eps">eps</code></td>
<td>
<p>Dummy argument kept for consistency with past versions of the functions</p>
</td></tr>
<tr><td><code id="MvInv_+3A_u">u</code></td>
<td>
<p>Real number. The value of the latent variable at the current step.</p>
</td></tr>
<tr><td><code id="MvInv_+3A_alpha">alpha</code></td>
<td>
<p>Numeric constant. Total mass of the centering measure.</p>
</td></tr>
<tr><td><code id="MvInv_+3A_kappa">kappa</code></td>
<td>
<p>Numeric positive constant.</p>
</td></tr>
<tr><td><code id="MvInv_+3A_gama">gama</code></td>
<td>
<p>Numeric constant. Discount parameter of the NRMI process.</p>
</td></tr>
<tr><td><code id="MvInv_+3A_n">N</code></td>
<td>
<p>Number of steps in the discretization scheme for the grid inversion.
</p>
<p>## The function has been optimised but it is morally defined as:
function(eps, u = 0.5, alpha = 1, kappa = 1, gama = 1 / 2, N = 3001) 
n &lt;- length(w)
v &lt;- rep(NA, n)
x &lt;- -log(seq(from = exp(-1e-05), to = exp(-10), length = N))
f &lt;- alpha / gamma(1 - gama) * x^(-(1 + gama)) * exp(-(u +
kappa) * x)
dx &lt;- diff(x)
h &lt;- (f[-1] + f[-N]) / 2
Mv &lt;- rep(0, N)
for (i in seq(N - 1, 1)) Mv[i] &lt;- Mv[i + 1] + dx[i] * h[i]
for (j in seq(n)) v[j] &lt;- x[which.min(Mv &gt; w[j])]
return(v)
</p>
</td></tr>
</table>

<hr>
<h2 id='p0'>Centering function</h2><span id='topic+p0'></span>

<h3>Description</h3>

<p>This function determines the centering density of the normalized random
measure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>p0(x, distr = NULL, mu = NULL, sigma = NULL)
</code></pre>


<h3>Details</h3>

<p>For internal use.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## The function is currently defined as
function(x, distr = NULL, mu = NULL, sigma = NULL) {
  if (is.null(distr)) {
    stop("Argument \"distr\" should be defined numeric with possible values 1,2, or 3")
  }
  else if (distr == 1) {
    a &lt;- ifelse(is.null(mu), 0, mu)
    b &lt;- ifelse(is.null(sigma), 1, sigma)
    p0 &lt;- dnorm(x, mean = a, sd = b)
  }
  else if (distr == 2) {
    a &lt;- ifelse(is.null(mu), 1, mu^2 / sigma^2)
    b &lt;- ifelse(is.null(sigma), 1, mu / sigma^2)
    p0 &lt;- dgamma(x, shape = a, rate = b)
  }
  else if (distr == 3) {
    a &lt;- ifelse(is.null(mu), 0.5, (1 - mu) * (mu / sigma)^2 -
      mu)
    b &lt;- ifelse(is.null(sigma), 1 / sqrt(12), (mu * (1 - mu) / sigma^2 -
      1) * (1 - mu))
    if (any(c(a, b) &lt;= 0)) {
      stop(paste(
        "\nNegative Beta parameters:\n a =", a,
        ";\t b =", b
      ))
    }
    p0 &lt;- dbeta(x, shape1 = a, shape2 = b)
  }
  else {
    stop("Argument \"distr\" should be defined numeric with possible values 1,2, or 3")
  }
  return(p0)
}
</code></pre>

<hr>
<h2 id='phalfcauchy'>Distribution function half Cauchy</h2><span id='topic+phalfcauchy'></span>

<h3>Description</h3>

<p>Computes the cdf.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>phalfcauchy(q, location = 0, scale = 1)
</code></pre>


<h3>Details</h3>

<p>For internal use
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## The function is currently defined as
function(q, location = 0, scale = 1) {
  ifelse(x &lt; 0, 0, 1) * (pcauchy(q, location, scale) - pcauchy(
    0,
    location, scale
  )) / (1 - pcauchy(0, location, scale))
}
</code></pre>

<hr>
<h2 id='phalfnorm'>Distribution function half Normal</h2><span id='topic+phalfnorm'></span>

<h3>Description</h3>

<p>Computes the cdf.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>phalfnorm(q, mean = 0, sd = 1)
</code></pre>


<h3>Details</h3>

<p>For internal use
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## The function is currently defined as
function(q, mean = 0, sd = 1) {
  ifelse(q &lt; 0, 0, 1) * (pnorm(q, mean, sd) - pnorm(
    0, mean,
    sd
  )) / (1 - pnorm(0, mean, sd))
}
</code></pre>

<hr>
<h2 id='phalft'>Distribution function half Student-t</h2><span id='topic+phalft'></span>

<h3>Description</h3>

<p>Computes the cumulative distribution function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>phalft(q, df = 1, mean = 0, sd = 1)
</code></pre>


<h3>Details</h3>

<p>For internal use
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## The function is currently defined as
function(q, df = 1, mean = 0, sd = 1) {
  ifelse(x &lt; 0, 0, 1) * (pt_(q, df, mean, sd) - pt_(
    0, df,
    mean, sd
  )) / (1 - pt_(0, df, mean, sd))
}
</code></pre>

<hr>
<h2 id='pk'>Kernel distribution function</h2><span id='topic+pk'></span>

<h3>Description</h3>

<p>This functions evaluates the cumulative distribution function at a certain
data point.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pk(q, distr = NULL, mu = NULL, sigma = NULL)
</code></pre>


<h3>Details</h3>

<p>For internal use
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## The function is currently defined as
function(q, distr = NULL, mu = NULL, sigma = NULL) {
  if (is.null(distr)) {
    stop(msg)
  }
  else if (distr == 1) {
    a &lt;- ifelse(is.null(mu), 0, mu)
    b &lt;- ifelse(is.null(sigma), 1, sigma)
    pk &lt;- pnorm(q, mean = a, sd = b)
  }
  else if (distr == 2) {
    a &lt;- ifelse(is.null(mu), 1, mu^2 / sigma^2)
    b &lt;- ifelse(is.null(sigma), 1, mu / sigma^2)
    pk &lt;- pgamma(q, shape = a, rate = b)
  }
  else if (distr == 3) {
    a &lt;- ifelse(is.null(mu), 0.5, (1 - mu) * (mu / sigma)^2 -
      mu)
    b &lt;- ifelse(is.null(sigma), 1 / sqrt(12), (mu * (1 - mu) / sigma^2 -
      1) * (1 - mu))
    if (any(c(a, b) &lt;= 0)) {
      stop(paste(
        "\nNegative Beta parameters:\n a =", a,
        ";\t b =", b
      ))
    }
    pk &lt;- pbeta(q, shape1 = a, shape2 = b)
  }
  else if (distr == 4) {
    a &lt;- ifelse(is.null(mu), 0, mu)
    b &lt;- ifelse(is.null(sigma), 1 / sqrt(2), sigma / sqrt(2))
    pk &lt;- ifelse(q &lt; a, exp((q - a) / b) / 2, 1 - exp((a - q) / b) / 2)
  }
  else if (distr == 5) {
    a &lt;- ifelse(is.null(mu), exp(1 / 2), log(mu / sqrt(1 + (sigma / mu)^2)))
    b &lt;- ifelse(is.null(sigma), exp(1) * (exp(1) - 1), sqrt(log(1 +
      (sigma / y)^2)))
    pk &lt;- plnorm(q, meanlog = a, sdlog = b)
  }
  else if (distr == 6) {
    pk &lt;- phalfcauchy(q, location = ifelse(is.null(mu), 0,
      mu
    ), scale = ifelse(is.null(sigma), 1, sigma))
  }
  else if (distr == 7) {
    pk &lt;- phalfnorm(q,
      mean = ifelse(is.null(mu), 0, mu),
      sd = ifelse(is.null(sigma), 1, sigma)
    )
  }
  else if (distr == 8) {
    pk &lt;- phalft(q, df = 10, mean = ifelse(is.null(mu), 0,
      mu
    ), sd = ifelse(is.null(sigma), 1, sigma))
  }
  else if (distr == 9) {
    pk &lt;- punif(q, min = ifelse(is.null(mu), 0, mu), max = ifelse(is.null(sigma),
      1, sigma
    ))
  }
  else if (distr == 10) {
    pk &lt;- ptnorm(q, mean = ifelse(is.null(mu), 0, mu), sd = ifelse(is.null(sigma),
      1, sigma
    ), lower = 0.1)
  }
  else {
    stop(msg)
  }
  return(pk)
}
</code></pre>

<hr>
<h2 id='plot_clustering_and_CDF'>Plot the clustering and the Cumulative Distribution Function</h2><span id='topic+plot_clustering_and_CDF'></span>

<h3>Description</h3>

<p>This is a function to visualize the clustering induced by the BNP model. The
data points are plotted with a color reflecting their cluster.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_clustering_and_CDF(fit, clustering, label_vector = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_clustering_and_CDF_+3A_fit">fit</code></td>
<td>
<p>The fitted object, obtained from one of the MixNRMIx functions</p>
</td></tr>
<tr><td><code id="plot_clustering_and_CDF_+3A_clustering">clustering</code></td>
<td>
<p>A vector of integers with the same length as the data,
representing the allocation variable for data each point.</p>
</td></tr>
<tr><td><code id="plot_clustering_and_CDF_+3A_label_vector">label_vector</code></td>
<td>
<p>A vector of data labels to be plotted, to provide some
identification to each point.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot of the Cumulative Distribution Function (or Turnbull estimate
for censored data) with data points whose color denotes the cluster
allocation. For censored data, right or left censored data points are not
represented, while interval censored data points are represented at the
middle of the censoring interval.
</p>

<hr>
<h2 id='plot_prior_number_of_components'>This plots the prior distribution on the number of components for the stable
process. The Dirichlet process is provided for comparison.</h2><span id='topic+plot_prior_number_of_components'></span>

<h3>Description</h3>

<p>This plots the prior distribution on the number of components for the stable
process. The Dirichlet process is provided for comparison.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_prior_number_of_components(
  n,
  Gama,
  Alpha = 1,
  grid = NULL,
  silence = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_prior_number_of_components_+3A_n">n</code></td>
<td>
<p>Number of data points</p>
</td></tr>
<tr><td><code id="plot_prior_number_of_components_+3A_gama">Gama</code></td>
<td>
<p>Numeric constant. 0 &lt;= Gama &lt;=1.</p>
</td></tr>
<tr><td><code id="plot_prior_number_of_components_+3A_alpha">Alpha</code></td>
<td>
<p>Numeric constant. Total mass of the centering measure for the
Dirichlet process.</p>
</td></tr>
<tr><td><code id="plot_prior_number_of_components_+3A_grid">grid</code></td>
<td>
<p>Integer vector. Level of truncation when computing the expectation. Defaults to
n. If greater than n, it is fixed to n.</p>
</td></tr>
<tr><td><code id="plot_prior_number_of_components_+3A_silence">silence</code></td>
<td>
<p>Boolean. Whether to print the current calculation step for the Stable process, as the function can be long</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot with the prior distribution on the number of components.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
plot_prior_number_of_components(50, 0.4)
</code></pre>

<hr>
<h2 id='plot.multNRMI'>Plot the density estimate and the 95% credible interval</h2><span id='topic+plot.multNRMI'></span>

<h3>Description</h3>

<p>The density estimate is the mean posterior density computed on the data
points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'multNRMI'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.multNRMI_+3A_x">x</code></td>
<td>
<p>An object of class multNRMI</p>
</td></tr>
<tr><td><code id="plot.multNRMI_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed to generic functions, ignored at the moment</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A graph with the density estimate, the 95% credible interval.
Includes a histogram if the data is non censored.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(salinity)
fit &lt;- multMixNRMI2cens(salinity$left, salinity$right, parallel = TRUE, Nit = 10, ncores = 2)
plot(fit)

</code></pre>

<hr>
<h2 id='plot.NRMI1'>Plot the density estimate and the 95% credible interval</h2><span id='topic+plot.NRMI1'></span>

<h3>Description</h3>

<p>The density estimate is the mean posterior density computed on the data
points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'NRMI1'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.NRMI1_+3A_x">x</code></td>
<td>
<p>A fitted object of class NRMI1</p>
</td></tr>
<tr><td><code id="plot.NRMI1_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed to generic function, ignored at the moment</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A graph with the density estimate, the 95% credible interval and a
histogram of the data
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Example for non censored data

data(acidity)
out &lt;- MixNRMI1(acidity, Nit = 50)
plot(out)

## Example for censored data

data(salinity)
out &lt;- MixNRMI1cens(salinity$left, salinity$right, Nit = 50)
plot(out)
</code></pre>

<hr>
<h2 id='plot.NRMI2'>Plot the density estimate and the 95% credible interval</h2><span id='topic+plot.NRMI2'></span>

<h3>Description</h3>

<p>The density estimate is the mean posterior density computed on the data
points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'NRMI2'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.NRMI2_+3A_x">x</code></td>
<td>
<p>A fitted object of class NRMI2</p>
</td></tr>
<tr><td><code id="plot.NRMI2_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed to generic function, ignored at the moment</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A graph with the density estimate, the 95% credible interval and a
histogram of the data
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Example for non censored data

data(acidity)
out &lt;- MixNRMI2(acidity, Nit = 20)
plot(out)

## Example for censored data

data(salinity)
out &lt;- MixNRMI2cens(salinity$left, salinity$right, Nit = 20)
plot(out)
</code></pre>

<hr>
<h2 id='plot.PY1'>Plot the density estimate and the 95% credible interval</h2><span id='topic+plot.PY1'></span>

<h3>Description</h3>

<p>Plot the density estimate and the 95% credible interval
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'PY1'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.PY1_+3A_x">x</code></td>
<td>
<p>A fitted object of class PY1</p>
</td></tr>
<tr><td><code id="plot.PY1_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed to generic function, ignored at the moment</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A graph with the density estimate, the 95% credible interval and a
histogram of the data
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(acidity)
out &lt;- MixPY1(acidity, Nit = 50)
plot(out)
</code></pre>

<hr>
<h2 id='plot.PY2'>Plot the density estimate and the 95% credible interval</h2><span id='topic+plot.PY2'></span>

<h3>Description</h3>

<p>Plot the density estimate and the 95% credible interval
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'PY2'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.PY2_+3A_x">x</code></td>
<td>
<p>A fitted object of class PY2</p>
</td></tr>
<tr><td><code id="plot.PY2_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed to generic function, ignored at the moment</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A graph with the density estimate, the 95% credible interval and a
histogram of the data
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(acidity)
out &lt;- MixPY2(acidity, Nit = 50)
plot(out)
</code></pre>

<hr>
<h2 id='plotCDF_censored'>Plot the Turnbull CDF and fitted CDF for censored data.</h2><span id='topic+plotCDF_censored'></span>

<h3>Description</h3>

<p>Plot the Turnbull CDF and fitted CDF for censored data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotCDF_censored(fit)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotCDF_censored_+3A_fit">fit</code></td>
<td>
<p>The result of the fit, obtained through the function MixNRMI1cens
or MixNRMI2cens.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Plot of the empirical and fitted CDF for non censored data.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(150520)
data(salinity)
out &lt;- MixNRMI1cens(salinity$left, salinity$right, extras = TRUE, Nit = 100)
BNPdensity:::plotCDF_censored(out)
</code></pre>

<hr>
<h2 id='plotCDF_noncensored'>Plot the empirical and fitted CDF for non censored data.</h2><span id='topic+plotCDF_noncensored'></span>

<h3>Description</h3>

<p>Plot the empirical and fitted CDF for non censored data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotCDF_noncensored(fit)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotCDF_noncensored_+3A_fit">fit</code></td>
<td>
<p>The result of the fit, obtained through the function MixNRMI1 or
MixNRMI2.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Plot of the empirical and fitted CDF for non censored data.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(150520)
data(acidity)
out &lt;- MixNRMI1(acidity, extras = TRUE, Nit = 10)
BNPdensity:::plotCDF_noncensored(out)
</code></pre>

<hr>
<h2 id='plotfit_censored'>Plot the density estimate and the 95% credible interval for censored data</h2><span id='topic+plotfit_censored'></span>

<h3>Description</h3>

<p>The density estimate is the mean posterior density computed on the data
points. It is not possible to display a histogram for censored data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotfit_censored(fit)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotfit_censored_+3A_fit">fit</code></td>
<td>
<p>A fitted object of class NRMI1cens or NRMI2cens</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A graph with the density estimate and the 95% credible interval
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(acidity)
out &lt;- MixNRMI1(acidity, Nit = 50)
plot(out)
</code></pre>

<hr>
<h2 id='plotfit_noncensored'>Plot the density estimate and the 95% credible interval for noncensored
data</h2><span id='topic+plotfit_noncensored'></span>

<h3>Description</h3>

<p>The density estimate is the mean posterior density computed on the data
points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotfit_noncensored(fit)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotfit_noncensored_+3A_fit">fit</code></td>
<td>
<p>A fitted object of class NRMI1 or NRMI2</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A graph with the density estimate, the 95% credible interval and a
histogram of the data
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(acidity)
out &lt;- MixNRMI1(acidity, Nit = 50)
plot(out)
</code></pre>

<hr>
<h2 id='plotPDF_censored'>Plot the density for censored data.</h2><span id='topic+plotPDF_censored'></span>

<h3>Description</h3>

<p>Plot the density for censored data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotPDF_censored(fit)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotPDF_censored_+3A_fit">fit</code></td>
<td>
<p>The result of the fit, obtained through the function MixNRMI1cens
or MixNRMI2cens.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Plot of the density and a histogram for non censored data.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(150520)
data(salinity)
out &lt;- MixNRMI1cens(xleft = salinity$left, xright = salinity$right, extras = TRUE, Nit = 100)
BNPdensity:::plotPDF_censored(out)
</code></pre>

<hr>
<h2 id='plotPDF_noncensored'>Plot the density and a histogram for non censored data.</h2><span id='topic+plotPDF_noncensored'></span>

<h3>Description</h3>

<p>Plot the density and a histogram for non censored data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotPDF_noncensored(fit)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotPDF_noncensored_+3A_fit">fit</code></td>
<td>
<p>The result of the fit, obtained through the function MixNRMI1 or
MixNRMI2.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Plot of the density and a histogram for non censored data.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(150520)
data(acidity)
out &lt;- MixNRMI1(acidity, extras = TRUE, Nit = 100)
BNPdensity:::plotPDF_noncensored(out)
</code></pre>

<hr>
<h2 id='pp_plot_censored'>Plot the percentile-percentile graph for non censored data, using the
Turnbull estimator the position of the percentiles.</h2><span id='topic+pp_plot_censored'></span>

<h3>Description</h3>

<p>Plot the percentile-percentile graph for non censored data, using the
Turnbull estimator the position of the percentiles.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pp_plot_censored(fit)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pp_plot_censored_+3A_fit">fit</code></td>
<td>
<p>The result of the fit, obtained through the function MixNRMI1cens
or MixNRMI2cens.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Percentile-percentile graph using the Turnbull estimator
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(150520)
data(salinity)
out &lt;- MixNRMI1cens(xleft = salinity$left, xright = salinity$right, extras = TRUE, Nit = 100)
BNPdensity:::pp_plot_censored(out)
</code></pre>

<hr>
<h2 id='pp_plot_noncensored'>Plot the percentile-percentile graph for non censored data.</h2><span id='topic+pp_plot_noncensored'></span>

<h3>Description</h3>

<p>Plot the percentile-percentile graph for non censored data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pp_plot_noncensored(fit)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pp_plot_noncensored_+3A_fit">fit</code></td>
<td>
<p>The result of the fit, obtained through the function MixNRMI1 or
MixNRMI2.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Percentile-percentile plot for non censored data.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(150520)
data(acidity)
out &lt;- MixNRMI1(acidity, extras = TRUE, Nit = 100)
BNPdensity:::pp_plot_noncensored(out)
</code></pre>

<hr>
<h2 id='print.multNRMI'>S3 method for class 'multNRMI'</h2><span id='topic+print.multNRMI'></span>

<h3>Description</h3>

<p>S3 method for class 'multNRMI'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'multNRMI'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.multNRMI_+3A_x">x</code></td>
<td>
<p>An object of class multNRMI</p>
</td></tr>
<tr><td><code id="print.multNRMI_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed to generic functions, ignored at the moment</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A visualization of the important information about the object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(salinity)
out &lt;- multMixNRMI2cens(salinity$left, salinity$right, parallel = TRUE, Nit = 10, ncores = 2)
print(out)

</code></pre>

<hr>
<h2 id='print.NRMI1'>S3 method for class 'MixNRMI1'</h2><span id='topic+print.NRMI1'></span>

<h3>Description</h3>

<p>S3 method for class 'MixNRMI1'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'NRMI1'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.NRMI1_+3A_x">x</code></td>
<td>
<p>A fitted object of class NRMI1</p>
</td></tr>
<tr><td><code id="print.NRMI1_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed to generic function, ignored at the moment</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A visualization of the important information about the object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Example for non censored data

data(acidity)
out &lt;- MixNRMI1(acidity, Nit = 50)
print(out)

## Example for censored data

data(salinity)
out &lt;- MixNRMI1cens(salinity$left, salinity$right, Nit = 50)
print(out)
</code></pre>

<hr>
<h2 id='print.NRMI2'>S3 method for class 'MixNRMI2'</h2><span id='topic+print.NRMI2'></span>

<h3>Description</h3>

<p>S3 method for class 'MixNRMI2'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'NRMI2'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.NRMI2_+3A_x">x</code></td>
<td>
<p>A fitted object of class NRMI2</p>
</td></tr>
<tr><td><code id="print.NRMI2_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed to generic function, ignored at the moment</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A visualization of the important information about the object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#' ## Example for censored data
data(acidity)
out &lt;- MixNRMI2(acidity, Nit = 20)
print(out)

data(salinity)
out &lt;- MixNRMI2cens(salinity$left, salinity$right, Nit = 20)
print(out)
</code></pre>

<hr>
<h2 id='print.PY1'>S3 method for class 'PY1'</h2><span id='topic+print.PY1'></span>

<h3>Description</h3>

<p>S3 method for class 'PY1'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'PY1'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.PY1_+3A_x">x</code></td>
<td>
<p>A fitted object of class PY1</p>
</td></tr>
<tr><td><code id="print.PY1_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed to generic function, ignored at the moment</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A visualization of the important information about the object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Example for non censored data

data(acidity)
out &lt;- MixPY1(acidity, Nit = 50)
print(out)
</code></pre>

<hr>
<h2 id='print.PY2'>S3 method for class 'PY2'</h2><span id='topic+print.PY2'></span>

<h3>Description</h3>

<p>S3 method for class 'PY2'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'PY2'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.PY2_+3A_x">x</code></td>
<td>
<p>A fitted object of class PY2</p>
</td></tr>
<tr><td><code id="print.PY2_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed to generic function, ignored at the moment</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A visualization of the important information about the object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Example for non censored data

data(acidity)
out &lt;- MixPY2(acidity, Nit = 50)
print(out)
</code></pre>

<hr>
<h2 id='process_dist_name'>Process the distribution name argument into a distribution index</h2><span id='topic+process_dist_name'></span>

<h3>Description</h3>

<p>This function is intended to help with compatibility with the previous versions of the package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>process_dist_name(distname)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="process_dist_name_+3A_distname">distname</code></td>
<td>
<p>Can be an integer or a distribution name. Allowed names are &quot;normal&quot;, &quot;gamma&quot;, &quot;beta&quot;, &quot;exponential&quot;, &quot;lognormal&quot;, &quot;half-Cauchy&quot;, &quot;half-normal&quot;, &quot;half-student&quot;, &quot;uniform&quot; and &quot;truncated normal&quot;, or their common abbreviations &quot;norm&quot;, &quot;exp&quot;, &quot;halfcauchy&quot;, &quot;halfnorm&quot;, &quot;halft&quot; and &quot;unif&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an integer both if distname is an integer or a character
</p>

<hr>
<h2 id='pt_'>Distribution function non-standard student-t</h2><span id='topic+pt_'></span>

<h3>Description</h3>

<p>Computes the cdf.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pt_(x, df, mean, sd)
</code></pre>


<h3>Details</h3>

<p>For internal use
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## The function is currently defined as
function(x, df, mean, sd) {
  pt((x - mean) / sd, df, ncp = 0)
}
</code></pre>

<hr>
<h2 id='ptnorm'>Distribution function truncated normal</h2><span id='topic+ptnorm'></span>

<h3>Description</h3>

<p>Computes the cumulative distribution function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ptnorm(
  q,
  mean = 0,
  sd = 1,
  lower = -Inf,
  upper = Inf,
  lower.tail = TRUE,
  log.p = FALSE
)
</code></pre>


<h3>Details</h3>

<p>For internal use
</p>


<h3>Note</h3>

<p>Taken from <code>msm</code> R-package.
</p>


<h3>Author(s)</h3>

<p>C. H. Jackson
</p>


<h3>References</h3>

<p>Taken from
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## The function is currently defined as
function(q, mean = 0, sd = 1, lower = -Inf, upper = Inf, lower.tail = TRUE,
         log.p = FALSE) {
  ret &lt;- numeric(length(q))
  if (lower.tail) {
    ret[q &lt; lower] &lt;- 0
    ret[q &gt; upper] &lt;- 1
  }
  else {
    ret[q &lt; lower] &lt;- 1
    ret[q &gt; upper] &lt;- 0
  }
  ret[upper &lt; lower] &lt;- NaN
  ind &lt;- q &gt;= lower &amp; q &lt;= upper
  if (any(ind)) {
    denom &lt;- pnorm(upper, mean, sd) - pnorm(
      lower, mean,
      sd
    )
    if (lower.tail) {
      qtmp &lt;- pnorm(q, mean, sd) - pnorm(lower, mean, sd)
    } else {
      qtmp &lt;- pnorm(upper, mean, sd) - pnorm(
        q, mean,
        sd
      )
    }
    if (log.p) {
      qtmp &lt;- log(qtmp) - log(denom)
    } else {
      qtmp &lt;- qtmp / denom
    }
    ret[q &gt;= lower &amp; q &lt;= upper] &lt;- qtmp[ind]
  }
  ret
}
</code></pre>

<hr>
<h2 id='qgeneric'>Generic function to find quantiles of a distribution</h2><span id='topic+qgeneric'></span>

<h3>Description</h3>

<p>Computes quantiles.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qgeneric(pdist, p, ...)
</code></pre>


<h3>Details</h3>

<p>For internal use
</p>


<h3>Note</h3>

<p>Taken from msm R-package.
</p>


<h3>Author(s)</h3>

<p>Christopher Jackson
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## The function is currently defined as
function(pdist, p, ...) {
  args &lt;- list(...)
  if (is.null(args$log.p)) {
    args$log.p &lt;- FALSE
  }
  if (is.null(args$lower.tail)) {
    args$lower.tail &lt;- TRUE
  }
  if (is.null(args$lbound)) {
    args$lbound &lt;- -Inf
  }
  if (is.null(args$ubound)) {
    args$ubound &lt;- Inf
  }
  if (args$log.p) {
    p &lt;- exp(p)
  }
  if (!args$lower.tail) {
    p &lt;- 1 - p
  }
  ret &lt;- numeric(length(p))
  ret[p == 0] &lt;- args$lbound
  ret[p == 1] &lt;- args$ubound
  args[c("lower.tail", "log.p", "lbound", "ubound")] &lt;- NULL
  maxlen &lt;- max(sapply(c(args, p = list(p)), length))
  for (i in seq(along = args)) {
    args[[i]] &lt;- rep(args[[i]],
      length.out = maxlen
    )
  }
  p &lt;- rep(p, length.out = maxlen)
  ret[p &lt; 0 | p &gt; 1] &lt;- NaN
  ind &lt;- (p &gt; 0 &amp; p &lt; 1)
  if (any(ind)) {
    hind &lt;- seq(along = p)[ind]
    h &lt;- function(y) {
      args &lt;- lapply(args, function(x) x[hind[i]])
      p &lt;- p[hind[i]]
      args$q &lt;- y
      (do.call(pdist, args) - p)
    }
    ptmp &lt;- numeric(length(p[ind]))
    for (i in 1:length(p[ind])) {
      interval &lt;- c(-1, 1)
      while (h(interval[1]) * h(interval[2]) &gt;= 0) {
        interval &lt;- interval + c(-1, 1) * 0.5 * (interval[2] -
          interval[1])
      }
      ptmp[i] &lt;- uniroot(h, interval, tol = .Machine$double.eps)$root
    }
    ret[ind] &lt;- ptmp
  }
  if (any(is.nan(ret))) {
    warning("NaNs produced")
  }
  ret
}
</code></pre>

<hr>
<h2 id='qhalfcauchy'>Quantile function half Cauchy</h2><span id='topic+qhalfcauchy'></span>

<h3>Description</h3>

<p>Computes the quantiles.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qhalfcauchy(p, location = 0, scale = 1)
</code></pre>


<h3>Details</h3>

<p>For internal use
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## The function is currently defined as
function(p, location = 0, scale = 1) {
  qcauchy(p * (1 - pcauchy(0, location, scale)) + pcauchy(
    0,
    location, scale
  ), location, scale)
}
</code></pre>

<hr>
<h2 id='qhalfnorm'>Quantile function half Normal</h2><span id='topic+qhalfnorm'></span>

<h3>Description</h3>

<p>Computes the quantiles.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qhalfnorm(p, mean = 0, sd = 1)
</code></pre>


<h3>Details</h3>

<p>For internal use
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## The function is currently defined as
function(p, mean = 0, sd = 1) {
  qnorm(
    p * (1 - pnorm(0, mean, sd)) + pnorm(0, mean, sd),
    mean, sd
  )
}
</code></pre>

<hr>
<h2 id='qhalft'>Quantile function half Student-t</h2><span id='topic+qhalft'></span>

<h3>Description</h3>

<p>Computes the quantiles.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qhalft(p, df = 1, mean = 0, sd = 1)
</code></pre>


<h3>Details</h3>

<p>For internal use
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## The function is currently defined as
function(p, df = 1, mean = 0, sd = 1) {
  qt_(
    p * (1 - pt_(0, df, mean, sd)) + pt_(0, df, mean, sd),
    df, mean, sd
  )
}
</code></pre>

<hr>
<h2 id='qq_plot_censored'>Plot the quantile-quantile graph for censored data.</h2><span id='topic+qq_plot_censored'></span>

<h3>Description</h3>

<p>This function may be rather slow for many iterations/many data because it
relies on numerical inversion of the mixture Cumulative Distribution
Function. set.seed(150520) data(salinity) out &lt;- MixNRMI1cens(xleft =
salinity$left, xright = salinity$right, extras = TRUE, Nit = 100)
BNPdensity:::qq_plot_censored(out)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qq_plot_censored(fit, thinning_to = 500)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="qq_plot_censored_+3A_fit">fit</code></td>
<td>
<p>The result of the fit, obtained through the function MixNRMI1 or
MixNRMI2, MixMRMI1cens or MixMRMI2cens</p>
</td></tr>
<tr><td><code id="qq_plot_censored_+3A_thinning_to">thinning_to</code></td>
<td>
<p>How many iterations to compute the mean posterior
quantiles</p>
</td></tr>
</table>


<h3>Value</h3>

<p>quantile-quantile plot for non censored data.
</p>

<hr>
<h2 id='qq_plot_noncensored'>Plot the quantile-quantile graph for non censored data.</h2><span id='topic+qq_plot_noncensored'></span>

<h3>Description</h3>

<p>This function may be rather slow for many iterations/many data because it
relies on numerical inversion of the mixture Cumulative Distribution
Function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qq_plot_noncensored(fit, thinning_to = 500)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="qq_plot_noncensored_+3A_fit">fit</code></td>
<td>
<p>The result of the fit, obtained through the function MixNRMI1 or
MixNRMI2, MixMRMI1cens or MixMRMI2cens</p>
</td></tr>
<tr><td><code id="qq_plot_noncensored_+3A_thinning_to">thinning_to</code></td>
<td>
<p>How many iterations to compute the mean posterior
quantiles</p>
</td></tr>
</table>


<h3>Value</h3>

<p>quantile-quantile plot for non censored data.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

### Not run
# set.seed(150520)
# data(acidity)
# out &lt;- MixNRMI1(acidity, extras = TRUE, Nit = 100)
# BNPdensity:::qq_plot_noncensored(out)
</code></pre>

<hr>
<h2 id='qt_'>Quantile function non-standard Student-t</h2><span id='topic+qt_'></span>

<h3>Description</h3>

<p>Computes the quantiles.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qt_(p, df, mean, sd)
</code></pre>


<h3>Details</h3>

<p>For internal use
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## The function is currently defined as
function(p, df, mean, sd) {
  sd * qt(p, df, ncp = 0) + mean
}
</code></pre>

<hr>
<h2 id='qtnorm'>Quantile function truncated normal</h2><span id='topic+qtnorm'></span>

<h3>Description</h3>

<p>Computes the quantiles.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qtnorm(
  p,
  mean = 0,
  sd = 1,
  lower = -Inf,
  upper = Inf,
  lower.tail = TRUE,
  log.p = FALSE
)
</code></pre>


<h3>Details</h3>

<p>For internal use
</p>


<h3>Note</h3>

<p>Taken from <code>msm</code> R-package.
</p>


<h3>Author(s)</h3>

<p>C. H. Jackson
</p>


<h3>References</h3>

<p>Taken from
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## The function is currently defined as
function(p, mean = 0, sd = 1, lower = -Inf, upper = Inf, lower.tail = TRUE,
         log.p = FALSE) {
  qgeneric(ptnorm,
    p = p, mean = mean, sd = sd, lower = lower,
    upper = upper, lbound = lower, ubound = upper, lower.tail = lower.tail,
    log.p = log.p
  )
}
</code></pre>

<hr>
<h2 id='rfystar'>Conditional posterior distribution of the distinct Ystar</h2><span id='topic+rfystar'></span>

<h3>Description</h3>

<p>This function evaluates the ratio of conditional posterior distributions of
the distinct latents Ystar.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rfystar(v, v2, x, distr.k, sigma.k, distr.p0, mu.p0, sigma.p0)
</code></pre>


<h3>Details</h3>

<p>For internal use.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## The function is currently defined as
function(v, v2, x, distr.k, sigma.k, distr.p0, mu.p0, sigma.p0) {
  alpha &lt;- p0(v, distr = distr.p0, mu = mu.p0, sigma = sigma.p0) /
    p0(v2, distr = distr.p0, mu = mu.p0, sigma = sigma.p0)
  Prod &lt;- 1
  for (i in seq(length(x))) {
    fac &lt;- dk(x[i], distr = distr.k, mu = v, sigma = sigma.k) /
      dk(x[i], distr = distr.k, mu = v2, sigma = sigma.k)
    Prod &lt;- Prod * fac
  }
  f &lt;- alpha * Prod
  return(f)
}
</code></pre>

<hr>
<h2 id='rfystarcens2'>Conditional posterior distribution of the distinct Ystar in the case of
censoring</h2><span id='topic+rfystarcens2'></span>

<h3>Description</h3>

<p>This function evaluates the ratio of conditional posterior distributions of
the distinct latents Ystar.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rfystarcens2(
  v,
  v2,
  xleft,
  xright,
  censor_code,
  distr.k,
  sigma.k,
  distr.p0,
  mu.p0,
  sigma.p0
)
</code></pre>


<h3>Details</h3>

<p>For internal use
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## The function is currently defined as
function(v, v2, xleft, xright, censor_code, distr.k, sigma.k,
         distr.p0, mu.p0, sigma.p0) {
  alpha &lt;- p0(v, distr = distr.p0, mu = mu.p0, sigma = sigma.p0) / p0(v2,
    distr = distr.p0, mu = mu.p0, sigma = sigma.p0
  )
  Prod &lt;- 1
  for (i in seq_along(xleft)) {
    fac &lt;- dkcens2_1val(
      xleft = xleft[i], xright = xright[i],
      c_code = censor_code[i], distr = distr.k, mu = v,
      sigma = sigma.k
    ) / dkcens2_1val(
      xleft = xleft[i], xright = xright[i],
      c_code = censor_code[i], distr = distr.k, mu = v2,
      sigma = sigma.k
    )
    Prod &lt;- Prod * fac
  }
  f &lt;- alpha * Prod
  return(f)
}
</code></pre>

<hr>
<h2 id='rfyzstar'>Conditional posterior distribution of the distinct vectors (Ystar,Zstar)</h2><span id='topic+rfyzstar'></span>

<h3>Description</h3>

<p>This function evaluates the ratio of conditional posterior distributions of
the distinct latent vectors (Ystar,Zstar).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rfyzstar(
  v,
  v2,
  z,
  z2,
  x,
  distr.k,
  distr.py0,
  mu.py0,
  sigma.py0,
  distr.pz0,
  mu.pz0,
  sigma.pz0
)
</code></pre>


<h3>Details</h3>

<p>For internal use.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## The function is currently defined as
function(v, v2, z, z2, x, distr.k, distr.py0, mu.py0, sigma.py0, distr.pz0, mu.pz0, sigma.pz0) {
  alpha &lt;- p0(v, distr = distr.py0, mu = mu.py0, sigma = sigma.py0) /
    p0(v2, distr = distr.py0, mu = mu.py0, sigma = sigma.py0) *
    p0(z, distr = distr.pz0, mu = mu.pz0, sigma = sigma.pz0) /
    p0(z2, distr = distr.pz0, mu = mu.pz0, sigma = sigma.pz0)
  Prod &lt;- 1
  for (i in seq(length(x))) {
    fac &lt;- dk(x[i], distr = distr.k, mu = v, sigma = z) / dk(x[i],
      distr = distr.k, mu = v2, sigma = z2
    )
    Prod &lt;- Prod * fac
  }
  f &lt;- alpha * Prod
  return(f)
}
</code></pre>

<hr>
<h2 id='rfyzstarcens2'>Conditional posterior distribution of the distinct vectors (Ystar,Zstar) in
the case of censoring</h2><span id='topic+rfyzstarcens2'></span>

<h3>Description</h3>

<p>This function evaluates the ratio of conditional posterior distributions of
the distinct latent vectors (Ystar,Zstar).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rfyzstarcens2(
  v,
  v2,
  z,
  z2,
  xleft,
  xright,
  censor_code,
  distr.k,
  distr.py0,
  mu.py0,
  sigma.py0,
  distr.pz0,
  mu.pz0,
  sigma.pz0
)
</code></pre>


<h3>Details</h3>

<p>For internal use
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## The function is currently defined as
function(v, v2, z, z2, xleft, xright, censor_code, distr.k,
         distr.py0, mu.py0, sigma.py0, distr.pz0, mu.pz0, sigma.pz0) {
  alpha &lt;- p0(v, distr = distr.py0, mu = mu.py0, sigma = sigma.py0) / p0(v2,
    distr = distr.py0, mu = mu.py0, sigma = sigma.py0
  ) *
    p0(z, distr = distr.pz0, mu = mu.pz0, sigma = sigma.pz0) / p0(z2,
      distr = distr.pz0, mu = mu.pz0, sigma = sigma.pz0
    )
  Prod &lt;- 1
  for (i in seq_along(xleft)) {
    fac &lt;- dkcens2_1val(
      xleft = xleft[i], xright = xright[i],
      c_code = censor_code[i], distr = distr.k, mu = v,
      sigma = z
    ) / dkcens2_1val(
      xleft = xleft[i], xright = xright[i],
      c_code = censor_code[i], distr = distr.k, mu = v2,
      sigma = z2
    )
    Prod &lt;- Prod * fac
  }
  f &lt;- alpha * Prod
  return(f)
}
</code></pre>

<hr>
<h2 id='rhalfcauchy'>Random number generator half Cauchy</h2><span id='topic+rhalfcauchy'></span>

<h3>Description</h3>

<p>Computes a random number.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rhalfcauchy(n, location = 0, scale = 1)
</code></pre>


<h3>Details</h3>

<p>For internal use
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## The function is currently defined as
function(n, location = 0, scale = 1) {
  abs(rcauchy(n, location, scale))
}
</code></pre>

<hr>
<h2 id='rhalfnorm'>Random number generator half Normal</h2><span id='topic+rhalfnorm'></span>

<h3>Description</h3>

<p>Computes a random number.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rhalfnorm(n, mean = 0, sd = 1)
</code></pre>


<h3>Details</h3>

<p>For internal use
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## The function is currently defined as
function(n, mean = 0, sd = 1) {
  abs(rnorm(n, mean, sd))
}
</code></pre>

<hr>
<h2 id='rhalft'>Random number generator half Student-t</h2><span id='topic+rhalft'></span>

<h3>Description</h3>

<p>Generates a random number.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rhalft(n, df = 1, mean = 0, sd = 1)
</code></pre>


<h3>Details</h3>

<p>For internal use
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## The function is currently defined as
function(n, df = 1, mean = 0, sd = 1) {
  abs(rt_(n, df, mean, sd))
}
</code></pre>

<hr>
<h2 id='rk'>Kernel density sampling function</h2><span id='topic+rk'></span>

<h3>Description</h3>

<p>This function simulates from a density.  There are 4 density options (1 =
Gaussian, 2 = Gamma, 3 = Beta, 4 = double exponential, 5 = lognormal). All
densities are parameterized in terms of mean and standard deviation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rk(n, distr = NULL, mu = NULL, sigma = NULL)
</code></pre>


<h3>Details</h3>

<p>For internal use.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## The function is currently defined as
function(n, distr = NULL, mu = NULL, sigma = NULL) {
  if (is.null(distr)) {
    stop("Argument \"distr\" should be defined numeric with possible values 1,2,3,4 or 5")
  }
  else if (distr == 1) {
    a &lt;- ifelse(is.null(mu), 0, mu)
    b &lt;- ifelse(is.null(sigma), 1, sigma)
    rk &lt;- rnorm(n, mean = a, sd = b)
  }
  else if (distr == 2) {
    a &lt;- ifelse(is.null(mu), 0, mu)
    b &lt;- ifelse(is.null(sigma), 1 / sqrt(2), sigma / sqrt(2))
    rk &lt;- a + b * sample(c(-1, +1), size = n, replace = TRUE) *
      rexp(n)
  }
  else if (distr == 3) {
    a &lt;- ifelse(is.null(mu), exp(1 / 2), log(mu / sqrt(1 + (sigma / mu)^2)))
    b &lt;- ifelse(is.null(sigma), exp(1) * (exp(1) - 1), sqrt(log(1 +
      (sigma / y)^2)))
    rk &lt;- rlnorm(n, meanlog = a, sdlog = b)
  }
  else if (distr == 4) {
    a &lt;- ifelse(is.null(mu), 1, mu^2 / sigma^2)
    b &lt;- ifelse(is.null(sigma), 1, mu / sigma^2)
    rk &lt;- rgamma(n, shape = a, rate = b)
  }
  else if (distr == 5) {
    a &lt;- ifelse(is.null(mu), 0.5, (1 - mu) * (mu / sigma)^2 -
      mu)
    b &lt;- ifelse(is.null(sigma), 1 / sqrt(12), (mu * (1 - mu) / sigma^2 -
      1) * (1 - mu))
    if (any(c(a, b) &lt;= 0)) {
      stop(paste(
        "\nNegative Beta parameters:\n a =", a,
        ";\t b =", b
      ))
    }
    rk &lt;- rbeta(n, shape1 = a, shape2 = b)
  }
  else {
    stop("Argument \"distr\" should be defined numeric with possible values 1,2,3,4 or 5")
  }
  return(rk)
}
</code></pre>

<hr>
<h2 id='rprop_logu'>Proposal distribution for logU</h2><span id='topic+rprop_logu'></span>

<h3>Description</h3>

<p>This function makes a proposal for a new value of logU
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rprop_logu(logu, delta)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rprop_logu_+3A_logu">logu</code></td>
<td>
<p>Real, log of the latent variable U at the current iteration.</p>
</td></tr>
<tr><td><code id="rprop_logu_+3A_delta">delta</code></td>
<td>
<p>Scale of the Metropolis-Hastings proposal distribution</p>
</td></tr>
</table>

<hr>
<h2 id='rt_'>Random number generator non-standard Student-t</h2><span id='topic+rt_'></span>

<h3>Description</h3>

<p>Computes a random number.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rt_(n, df, mean, sd)
</code></pre>


<h3>Details</h3>

<p>For internal use
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## The function is currently defined as
function(n, df, mean, sd) {
  mean + sd * rt(n, df, ncp = 0)
}
</code></pre>

<hr>
<h2 id='rtnorm'>Random number generator for a truncated normal distribution</h2><span id='topic+rtnorm'></span>

<h3>Description</h3>

<p>Generates a random number from a truncated normal distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rtnorm(n, mean = 0, sd = 1, lower = -Inf, upper = Inf)
</code></pre>


<h3>Details</h3>

<p>For internal use
</p>


<h3>Note</h3>

<p>Taken from <code>msm</code> R-package.
</p>


<h3>Author(s)</h3>

<p>C. H. Jackson
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## The function is currently defined as
function(n, mean = 0, sd = 1, lower = -Inf, upper = Inf) {
  if (length(n) &gt; 1) {
    n &lt;- length(n)
  }
  mean &lt;- rep(mean, length = n)
  sd &lt;- rep(sd, length = n)
  lower &lt;- rep(lower, length = n)
  upper &lt;- rep(upper, length = n)
  lower &lt;- (lower - mean) / sd
  upper &lt;- (upper - mean) / sd
  ind &lt;- seq(length = n)
  ret &lt;- numeric(n)
  alg &lt;- ifelse(lower &gt; upper, -1, ifelse(((lower &lt; 0 &amp; upper ==
    Inf) | (lower == -Inf &amp; upper &gt; 0) | (is.finite(lower) &amp;
    is.finite(upper) &amp; (lower &lt; 0) &amp; (upper &gt; 0) &amp; (upper -
    lower &gt; sqrt(2 * pi)))), 0, ifelse((lower &gt;= 0 &amp; (upper &gt;
    lower + 2 * sqrt(exp(1)) / (lower + sqrt(lower^2 + 4)) *
      exp((lower * 2 - lower * sqrt(lower^2 + 4)) / 4))),
  1, ifelse(upper &lt;= 0 &amp; (-lower &gt; -upper + 2 * sqrt(exp(1)) / (-upper +
    sqrt(upper^2 + 4)) * exp((upper * 2 - -upper * sqrt(upper^2 +
    4)) / 4)), 2, 3)
  )))
  ind.nan &lt;- ind[alg == -1]
  ind.no &lt;- ind[alg == 0]
  ind.expl &lt;- ind[alg == 1]
  ind.expu &lt;- ind[alg == 2]
  ind.u &lt;- ind[alg == 3]
  ret[ind.nan] &lt;- NaN
  while (length(ind.no) &gt; 0) {
    y &lt;- rnorm(length(ind.no))
    done &lt;- which(y &gt;= lower[ind.no] &amp; y &lt;= upper[ind.no])
    ret[ind.no[done]] &lt;- y[done]
    ind.no &lt;- setdiff(ind.no, ind.no[done])
  }
  stopifnot(length(ind.no) == 0)
  while (length(ind.expl) &gt; 0) {
    a &lt;- (lower[ind.expl] + sqrt(lower[ind.expl]^2 + 4)) / 2
    z &lt;- rexp(length(ind.expl), a) + lower[ind.expl]
    u &lt;- runif(length(ind.expl))
    done &lt;- which((u &lt;= exp(-(z - a)^2 / 2)) &amp; (z &lt;= upper[ind.expl]))
    ret[ind.expl[done]] &lt;- z[done]
    ind.expl &lt;- setdiff(ind.expl, ind.expl[done])
  }
  stopifnot(length(ind.expl) == 0)
  while (length(ind.expu) &gt; 0) {
    a &lt;- (-upper[ind.expu] + sqrt(upper[ind.expu]^2 + 4)) / 2
    z &lt;- rexp(length(ind.expu), a) - upper[ind.expu]
    u &lt;- runif(length(ind.expu))
    done &lt;- which((u &lt;= exp(-(z - a)^2 / 2)) &amp; (z &lt;= -lower[ind.expu]))
    ret[ind.expu[done]] &lt;- -z[done]
    ind.expu &lt;- setdiff(ind.expu, ind.expu[done])
  }
  stopifnot(length(ind.expu) == 0)
  while (length(ind.u) &gt; 0) {
    z &lt;- runif(length(ind.u), lower[ind.u], upper[ind.u])
    rho &lt;- ifelse(lower[ind.u] &gt; 0, exp((lower[ind.u]^2 -
      z^2) / 2), ifelse(upper[ind.u] &lt; 0, exp((upper[ind.u]^2 -
      z^2) / 2), exp(-z^2 / 2)))
    u &lt;- runif(length(ind.u))
    done &lt;- which(u &lt;= rho)
    ret[ind.u[done]] &lt;- z[done]
    ind.u &lt;- setdiff(ind.u, ind.u[done])
  }
  stopifnot(length(ind.u) == 0)
  ret * sd + mean
}
</code></pre>

<hr>
<h2 id='salinity'>Salinity tolerance</h2><span id='topic+salinity'></span>

<h3>Description</h3>

<p>72-hour acute salinity tolerance (LC50 values) of riverine
macro-invertebrates.
</p>


<h3>Format</h3>

<p>A data frame with 108 observations on the following two variables:
</p>

<dl>
<dt>left</dt><dd><p>A numeric vector.</p>
</dd>
<dt>right</dt><dd><p>A
numeric vector.</p>
</dd> </dl>



<h3>Source</h3>

<p><code>fitdistrplus</code> R-package
</p>


<h3>References</h3>

<p>Kefford, B.J., Nugegoda, D., Metzeling, L., Fields, E. 2006.
Validating species sensitivity distributions using salinity tolerance of
riverine macroinvertebrates in the southern Murray-darling Basin (Victoria,
Australia). Canadian Journal of Fisheries and Aquatic Science, 63,
1865-1877.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(salinity)
hist(salinity$left)
</code></pre>

<hr>
<h2 id='summary.multNRMI'>S3 method for class 'multNRMI'</h2><span id='topic+summary.multNRMI'></span>

<h3>Description</h3>

<p>S3 method for class 'multNRMI'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'multNRMI'
summary(object, number_of_clusters = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.multNRMI_+3A_object">object</code></td>
<td>
<p>A fitted object of class NRMI1cens</p>
</td></tr>
<tr><td><code id="summary.multNRMI_+3A_number_of_clusters">number_of_clusters</code></td>
<td>
<p>Whether to compute the optimal number of clusters, which can be a time-consuming operation (see <code><a href="#topic+compute_optimal_clustering">compute_optimal_clustering</a></code>)</p>
</td></tr>
<tr><td><code id="summary.multNRMI_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed to generic function, ignored at the moment</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Prints out the text for the summary S3 methods
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(salinity)
out &lt;- multMixNRMI2cens(salinity$left, salinity$right, parallel = TRUE, Nit = 10, ncores = 2)
summary(out)

</code></pre>

<hr>
<h2 id='summary.NRMI1'>S3 method for class 'MixNRMI1'</h2><span id='topic+summary.NRMI1'></span>

<h3>Description</h3>

<p>S3 method for class 'MixNRMI1'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'NRMI1'
summary(object, number_of_clusters = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.NRMI1_+3A_object">object</code></td>
<td>
<p>A fitted object of class NRMI1</p>
</td></tr>
<tr><td><code id="summary.NRMI1_+3A_number_of_clusters">number_of_clusters</code></td>
<td>
<p>Whether to compute the optimal number of clusters, which can be a time-consuming operation (see <code><a href="#topic+compute_optimal_clustering">compute_optimal_clustering</a></code>)</p>
</td></tr>
<tr><td><code id="summary.NRMI1_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed to generic function, ignored at the moment</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Prints out the text for the summary S3 methods
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Example for non censored data

data(acidity)
out &lt;- MixNRMI1(acidity, Nit = 50)
summary(out)
</code></pre>

<hr>
<h2 id='summary.NRMI2'>S3 method for class 'MixNRMI2'</h2><span id='topic+summary.NRMI2'></span>

<h3>Description</h3>

<p>S3 method for class 'MixNRMI2'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'NRMI2'
summary(object, number_of_clusters = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.NRMI2_+3A_object">object</code></td>
<td>
<p>A fitted object of class NRMI2</p>
</td></tr>
<tr><td><code id="summary.NRMI2_+3A_number_of_clusters">number_of_clusters</code></td>
<td>
<p>Whether to compute the optimal number of clusters, which can be a time-consuming operation (see <code><a href="#topic+compute_optimal_clustering">compute_optimal_clustering</a></code>)</p>
</td></tr>
<tr><td><code id="summary.NRMI2_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed to generic function, ignored at the moment</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Prints out the text for the summary S3 methods
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(acidity)
out &lt;- MixNRMI2(acidity, Nit = 20)
summary(out)

data(salinity)
out &lt;- MixNRMI2cens(salinity$left, salinity$right, Nit = 20)
summary(out)
</code></pre>

<hr>
<h2 id='summary.PY1'>S3 method for class 'PY1'</h2><span id='topic+summary.PY1'></span>

<h3>Description</h3>

<p>S3 method for class 'PY1'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'PY1'
summary(object, number_of_clusters = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.PY1_+3A_object">object</code></td>
<td>
<p>A fitted object of class PY1</p>
</td></tr>
<tr><td><code id="summary.PY1_+3A_number_of_clusters">number_of_clusters</code></td>
<td>
<p>Whether to compute the optimal number of clusters, which can be a time-consuming operation (see <code><a href="#topic+compute_optimal_clustering">compute_optimal_clustering</a></code>)</p>
</td></tr>
<tr><td><code id="summary.PY1_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed to generic function, ignored at the moment</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Prints out the text for the summary S3 methods
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Example for non censored data

data(acidity)
out &lt;- MixPY1(acidity, Nit = 50)
summary(out)
</code></pre>

<hr>
<h2 id='summary.PY2'>S3 method for class 'PY2'</h2><span id='topic+summary.PY2'></span>

<h3>Description</h3>

<p>S3 method for class 'PY2'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'PY2'
summary(object, number_of_clusters = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.PY2_+3A_object">object</code></td>
<td>
<p>A fitted object of class PY2</p>
</td></tr>
<tr><td><code id="summary.PY2_+3A_number_of_clusters">number_of_clusters</code></td>
<td>
<p>Whether to compute the optimal number of clusters, which can be a time-consuming operation (see <code><a href="#topic+compute_optimal_clustering">compute_optimal_clustering</a></code>)</p>
</td></tr>
<tr><td><code id="summary.PY2_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed to generic function, ignored at the moment</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Prints out the text for the summary S3 methods
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Example for non censored data

data(acidity)
out &lt;- MixPY2(acidity, Nit = 50)
summary(out)
</code></pre>

<hr>
<h2 id='summarytext'>Common text for the summary S3 methods</h2><span id='topic+summarytext'></span>

<h3>Description</h3>

<p>Common text for the summary S3 methods
</p>


<h3>Usage</h3>

<pre><code class='language-R'>summarytext(
  fit,
  kernel_comment,
  BNP_process_comment,
  number_of_clusters = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summarytext_+3A_fit">fit</code></td>
<td>
<p>NRMIx or PYx object</p>
</td></tr>
<tr><td><code id="summarytext_+3A_kernel_comment">kernel_comment</code></td>
<td>
<p>Text specific to the parametric and nonparametric nature of the model</p>
</td></tr>
<tr><td><code id="summarytext_+3A_bnp_process_comment">BNP_process_comment</code></td>
<td>
<p>Text specific to the nonparametric process, NRMI or Pitman-Yor</p>
</td></tr>
<tr><td><code id="summarytext_+3A_number_of_clusters">number_of_clusters</code></td>
<td>
<p>Flag to decide whether to compute the optimal clustering</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Prints out the text for the summary S3 methods
</p>

<hr>
<h2 id='thresholdGG'>Choosing the truncation level for the NGG process</h2><span id='topic+thresholdGG'></span>

<h3>Description</h3>

<p>This function uses the M_array which provides the threshold which ensures
a moment match of 5
</p>


<h3>Usage</h3>

<pre><code class='language-R'>thresholdGG(alpha = 1, kappa = 1, gama = 1/2, max_threshold = 200)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="thresholdGG_+3A_alpha">alpha</code></td>
<td>
<p>Numeric constant. Total mass of the centering measure</p>
</td></tr>
<tr><td><code id="thresholdGG_+3A_kappa">kappa</code></td>
<td>
<p>Numeric positive constant.</p>
</td></tr>
<tr><td><code id="thresholdGG_+3A_gama">gama</code></td>
<td>
<p>Numeric constant. <code class="reqn">0 \leq Gama \leq 1</code>.</p>
</td></tr>
<tr><td><code id="thresholdGG_+3A_max_threshold">max_threshold</code></td>
<td>
<p>Numeric positive integer. Maximum allowed value for the threshold</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For internal use
</p>


<h3>Value</h3>

<p>Numeric positive integer, the truncation level of the NGG process
</p>

<hr>
<h2 id='traceplot'>Draw a traceplot for multiple chains</h2><span id='topic+traceplot'></span>

<h3>Description</h3>

<p>This is a convenience function which works when coda is not yet loaded by the user. If coda is
loaded, it gets masked. See also file multMixNRMI.R
</p>


<h3>Usage</h3>

<pre><code class='language-R'>traceplot(fitlist)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="traceplot_+3A_fitlist">fitlist</code></td>
<td>
<p>Output of multMixNRMI.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A traceplot for multiple chains.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
