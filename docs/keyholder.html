<!DOCTYPE html><html><head><title>Help for package keyholder</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {keyholder}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#keyholder-package'><p>keyholder: Store Data About Rows</p></a></li>
<li><a href='#key-by-scoped'><p>Key by selection of variables</p></a></li>
<li><a href='#keyed-df'><p>Keyed object</p></a></li>
<li><a href='#keyed-df-one-tbl'><p>One-table verbs from dplyr for keyed_df</p></a></li>
<li><a href='#keyed-df-two-tbl'><p>Two-table verbs from dplyr for keyed_df</p></a></li>
<li><a href='#keyholder-id'><p>Add id column and key</p></a></li>
<li><a href='#keyholder-scoped'><p>Operate on a selection of keys</p></a></li>
<li><a href='#keyholder-supported-funs'><p>Supported functions</p></a></li>
<li><a href='#keys-get'><p>Get keys</p></a></li>
<li><a href='#keys-manipulate'><p>Manipulate keys</p></a></li>
<li><a href='#keys-set'><p>Set keys</p></a></li>
<li><a href='#reexports'><p>Objects exported from other packages</p></a></li>
<li><a href='#remove-keys-scoped'><p>Remove selection of keys</p></a></li>
<li><a href='#rename-keys-scoped'><p>Rename selection of keys</p></a></li>
<li><a href='#restore-keys-scoped'><p>Restore selection of keys</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Store Data About Rows</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.7</td>
</tr>
<tr>
<td>Description:</td>
<td>Tools for keeping track of information, named
    "keys", about rows of data frame like objects. This is done by
    creating special attribute "keys" which is updated after every change
    in rows (subsetting, ordering, etc.).  This package is designed to
    work tightly with 'dplyr' package.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://echasnovski.github.io/keyholder/">https://echasnovski.github.io/keyholder/</a>,
<a href="https://github.com/echasnovski/keyholder/">https://github.com/echasnovski/keyholder/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/echasnovski/keyholder/issues/">https://github.com/echasnovski/keyholder/issues/</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.4.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>dplyr (&ge; 0.7.0), rlang (&ge; 0.1), tibble, utils</td>
</tr>
<tr>
<td>Suggests:</td>
<td>covr, knitr, rmarkdown, testthat</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-03-11 17:31:00 UTC; evgeni</td>
</tr>
<tr>
<td>Author:</td>
<td>Evgeni Chasnovski <a href="https://orcid.org/0000-0002-1617-4019"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Evgeni Chasnovski &lt;evgeni.chasnovski@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-03-11 18:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='keyholder-package'>keyholder: Store Data About Rows</h2><span id='topic+keyholder'></span><span id='topic+keyholder-package'></span>

<h3>Description</h3>

<p><code>keyholder</code> offers a set of tools for storing information about rows of data
frame like objects. The common use cases are:
</p>

<ul>
<li><p> Track rows of data frame without changing it.
</p>
</li>
<li><p> Store columns for future restoring in data frame.
</p>
</li>
<li><p> Hide columns for convenient use of <a href="dplyr.html#topic+scoped">dplyr</a>'s *_if scoped
variants of verbs.
</p>
</li></ul>



<h3>Details</h3>

<p>To learn more about <code>keyholder</code>:
</p>

<ul>
<li><p> Browse vignettes with <code>browseVignettes(package = "keyholder")</code>.
</p>
</li>
<li><p> Look how to <a href="#topic+keys-set">set keys</a>.
</p>
</li>
<li><p> Look at the list of <a href="#topic+keyholder-supported-funs">supported functions</a>.
</p>
</li></ul>



<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Evgeni Chasnovski <a href="mailto:evgeni.chasnovski@gmail.com">evgeni.chasnovski@gmail.com</a> (<a href="https://orcid.org/0000-0002-1617-4019">ORCID</a>)
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://echasnovski.github.io/keyholder/">https://echasnovski.github.io/keyholder/</a>
</p>
</li>
<li> <p><a href="https://github.com/echasnovski/keyholder/">https://github.com/echasnovski/keyholder/</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/echasnovski/keyholder/issues/">https://github.com/echasnovski/keyholder/issues/</a>
</p>
</li></ul>


<hr>
<h2 id='key-by-scoped'>Key by selection of variables</h2><span id='topic+key-by-scoped'></span><span id='topic+key_by_all'></span><span id='topic+key_by_if'></span><span id='topic+key_by_at'></span>

<h3>Description</h3>

<p>These functions perform keying by selection of variables using corresponding
<a href="dplyr.html#topic+select_all">scoped variant</a> of <a href="dplyr.html#topic+select">select</a>. Appropriate
data frame is selected with scoped function first, and then it is assigned
as keys.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>key_by_all(.tbl, .funs = list(), ..., .add = FALSE, .exclude = FALSE)

key_by_if(.tbl, .predicate, .funs = list(), ..., .add = FALSE,
  .exclude = FALSE)

key_by_at(.tbl, .vars, .funs = list(), ..., .add = FALSE,
  .exclude = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="key-by-scoped_+3A_.tbl">.tbl</code></td>
<td>
<p>Reference data frame .</p>
</td></tr>
<tr><td><code id="key-by-scoped_+3A_.funs">.funs</code></td>
<td>
<p>Parameter for <a href="dplyr.html#topic+scoped">scoped</a> functions.</p>
</td></tr>
<tr><td><code id="key-by-scoped_+3A_...">...</code></td>
<td>
<p>Parameter for <a href="dplyr.html#topic+scoped">scoped</a> functions.</p>
</td></tr>
<tr><td><code id="key-by-scoped_+3A_.add">.add</code></td>
<td>
<p>Whether to add keys to (possibly) existing ones. If <code>FALSE</code> keys
will be overridden.</p>
</td></tr>
<tr><td><code id="key-by-scoped_+3A_.exclude">.exclude</code></td>
<td>
<p>Whether to exclude key variables from <code>.tbl</code>.</p>
</td></tr>
<tr><td><code id="key-by-scoped_+3A_.predicate">.predicate</code></td>
<td>
<p>Parameter for <a href="dplyr.html#topic+scoped">scoped</a> functions.</p>
</td></tr>
<tr><td><code id="key-by-scoped_+3A_.vars">.vars</code></td>
<td>
<p>Parameter for <a href="dplyr.html#topic+scoped">scoped</a> functions.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><a href="#topic+keys-set">Not scoped key_by()</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mtcars %&gt;% key_by_all(.funs = toupper)

mtcars %&gt;% key_by_if(rlang::is_integerish, toupper)

mtcars %&gt;% key_by_at(c("vs", "am"), toupper)

</code></pre>

<hr>
<h2 id='keyed-df'>Keyed object</h2><span id='topic+keyed-df'></span><span id='topic+is_keyed_df'></span><span id='topic+is.keyed_df'></span><span id='topic+print.keyed_df'></span><span id='topic++5B.keyed_df'></span>

<h3>Description</h3>

<p>Utility functions for keyed objects which are implemented with class
<code>keyed_df</code>. Keyed object should be a data frame which inherits from
<code>keyed_df</code> and contains a data frame of <a href="#topic+keys-set">keys</a> in attribute 'keys'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_keyed_df(.tbl)

is.keyed_df(.tbl)

## S3 method for class 'keyed_df'
print(x, ...)

## S3 method for class 'keyed_df'
x[i, j, ...]
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="keyed-df_+3A_.tbl">.tbl</code></td>
<td>
<p>Object to check.</p>
</td></tr>
<tr><td><code id="keyed-df_+3A_x">x</code></td>
<td>
<p>Object to print or extract elements.</p>
</td></tr>
<tr><td><code id="keyed-df_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
<tr><td><code id="keyed-df_+3A_i">i</code>, <code id="keyed-df_+3A_j">j</code></td>
<td>
<p>Arguments for <code><a href="base.html#topic++5B">[</a></code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>is_keyed_df(mtcars)

mtcars %&gt;% key_by(vs) %&gt;% is_keyed_df

# Not valid keyed_df
df &lt;- mtcars
class(df) &lt;- c("keyed_df", "data.frame")
is_keyed_df(df)

</code></pre>

<hr>
<h2 id='keyed-df-one-tbl'>One-table verbs from dplyr for keyed_df</h2><span id='topic+keyed-df-one-tbl'></span><span id='topic+select.keyed_df'></span><span id='topic+rename.keyed_df'></span><span id='topic+mutate.keyed_df'></span><span id='topic+transmute.keyed_df'></span><span id='topic+summarise.keyed_df'></span><span id='topic+group_by.keyed_df'></span><span id='topic+ungroup.keyed_df'></span><span id='topic+rowwise.keyed_df'></span><span id='topic+distinct.keyed_df'></span><span id='topic+do.keyed_df'></span><span id='topic+arrange.keyed_df'></span><span id='topic+filter.keyed_df'></span><span id='topic+slice.keyed_df'></span>

<h3>Description</h3>

<p>Defined methods for <a href="dplyr.html#topic+dplyr">dplyr</a> generic single table functions. Most of them
preserve 'keyed_df' class and 'keys' attribute (excluding <code>summarise</code> with
scoped variants, <code>distinct</code> and <code>do</code> which remove them). Also these methods
modify rows in keys according to the rows modification in reference
data frame (if any).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'keyed_df'
select(.data, ...)

## S3 method for class 'keyed_df'
rename(.data, ...)

## S3 method for class 'keyed_df'
mutate(.data, ...)

## S3 method for class 'keyed_df'
transmute(.data, ...)

## S3 method for class 'keyed_df'
summarise(.data, ...)

## S3 method for class 'keyed_df'
group_by(.data, ...)

## S3 method for class 'keyed_df'
ungroup(x, ...)

## S3 method for class 'keyed_df'
rowwise(data, ...)

## S3 method for class 'keyed_df'
distinct(.data, ..., .keep_all = FALSE)

## S3 method for class 'keyed_df'
do(.data, ...)

## S3 method for class 'keyed_df'
arrange(.data, ..., .by_group = FALSE)

## S3 method for class 'keyed_df'
filter(.data, ...)

## S3 method for class 'keyed_df'
slice(.data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="keyed-df-one-tbl_+3A_.data">.data</code>, <code id="keyed-df-one-tbl_+3A_data">data</code>, <code id="keyed-df-one-tbl_+3A_x">x</code></td>
<td>
<p>A keyed object.</p>
</td></tr>
<tr><td><code id="keyed-df-one-tbl_+3A_...">...</code></td>
<td>
<p>Appropriate arguments for functions.</p>
</td></tr>
<tr><td><code id="keyed-df-one-tbl_+3A_.keep_all">.keep_all</code></td>
<td>
<p>Parameter for <a href="dplyr.html#topic+distinct">dplyr::distinct</a>.</p>
</td></tr>
<tr><td><code id="keyed-df-one-tbl_+3A_.by_group">.by_group</code></td>
<td>
<p>Parameter for <a href="dplyr.html#topic+arrange">dplyr::arrange</a>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code><a href="dplyr.html#topic+transmute">dplyr::transmute()</a></code> is supported implicitly with <code><a href="dplyr.html#topic+mutate">dplyr::mutate()</a></code>
support.
</p>
<p><code><a href="dplyr.html#topic+rowwise">dplyr::rowwise()</a></code> is not supposed to be generic in <code>dplyr</code>. Use
<code>rowwise.keyed_df</code> directly.
</p>
<p>All <a href="dplyr.html#topic+scoped">scoped</a> variants of present functions are also supported.
</p>


<h3>See Also</h3>

<p><a href="#topic+keyed-df-two-tbl">Two-table verbs</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mtcars %&gt;% key_by(vs, am) %&gt;% dplyr::mutate(gear = 1)

</code></pre>

<hr>
<h2 id='keyed-df-two-tbl'>Two-table verbs from dplyr for keyed_df</h2><span id='topic+keyed-df-two-tbl'></span><span id='topic+inner_join.keyed_df'></span><span id='topic+left_join.keyed_df'></span><span id='topic+right_join.keyed_df'></span><span id='topic+full_join.keyed_df'></span><span id='topic+semi_join.keyed_df'></span><span id='topic+anti_join.keyed_df'></span>

<h3>Description</h3>

<p>Defined methods for <a href="dplyr.html#topic+dplyr">dplyr</a> generic <a href="dplyr.html#topic+mutate-joins">join</a> functions. All of
them preserve 'keyed_df' class and 'keys' attribute <strong>of the first
argument</strong>. Also these methods modify rows in keys according to the rows
modification in first argument (if any).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'keyed_df'
inner_join(x, y, by = NULL, copy = FALSE,
  suffix = c(".x", ".y"), ...)

## S3 method for class 'keyed_df'
left_join(x, y, by = NULL, copy = FALSE,
  suffix = c(".x", ".y"), ...)

## S3 method for class 'keyed_df'
right_join(x, y, by = NULL, copy = FALSE,
  suffix = c(".x", ".y"), ...)

## S3 method for class 'keyed_df'
full_join(x, y, by = NULL, copy = FALSE,
  suffix = c(".x", ".y"), ...)

## S3 method for class 'keyed_df'
semi_join(x, y, by = NULL, copy = FALSE, ...)

## S3 method for class 'keyed_df'
anti_join(x, y, by = NULL, copy = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="keyed-df-two-tbl_+3A_x">x</code>, <code id="keyed-df-two-tbl_+3A_y">y</code>, <code id="keyed-df-two-tbl_+3A_by">by</code>, <code id="keyed-df-two-tbl_+3A_copy">copy</code>, <code id="keyed-df-two-tbl_+3A_suffix">suffix</code>, <code id="keyed-df-two-tbl_+3A_...">...</code></td>
<td>
<p>Parameters for <a href="dplyr.html#topic+mutate-joins">join</a> functions.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><a href="#topic+keyed-df-one-tbl">One-table verbs</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
dplyr::band_members %&gt;% key_by(band) %&gt;%
  dplyr::semi_join(dplyr::band_instruments, by = "name") %&gt;%
  keys()

</code></pre>

<hr>
<h2 id='keyholder-id'>Add id column and key</h2><span id='topic+keyholder-id'></span><span id='topic+use_id'></span><span id='topic+compute_id_name'></span><span id='topic+add_id'></span><span id='topic+key_by_id'></span>

<h3>Description</h3>

<p>Functions for creating id column and key.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>use_id(.tbl)

compute_id_name(x)

add_id(.tbl)

key_by_id(.tbl, .add = FALSE, .exclude = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="keyholder-id_+3A_.tbl">.tbl</code></td>
<td>
<p>Reference data frame.</p>
</td></tr>
<tr><td><code id="keyholder-id_+3A_x">x</code></td>
<td>
<p>Character vector of names.</p>
</td></tr>
<tr><td><code id="keyholder-id_+3A_.add">.add</code>, <code id="keyholder-id_+3A_.exclude">.exclude</code></td>
<td>
<p>Parameters for <code><a href="#topic+key_by">key_by()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>use_id()</code> <a href="#topic+keys-set">assigns</a> as keys a tibble with column '.id'
and row numbers of <code>.tbl</code> as values.
</p>
<p><code>compute_id_name()</code> computes the name which is different from every
element in <code>x</code> by the following algorithm: if '.id' is not present in <code>x</code> it
is returned; if taken - '.id1' is checked; if taken - '.id11' is checked and
so on.
</p>
<p><code>add_id()</code> creates a column with unique name (computed with
<code>compute_id_name()</code>) and row numbers as values (grouping is ignored). After
that puts it as first column.
</p>
<p><code>key_by_id()</code> is similar to <code>add_id()</code>: it creates a column with unique name
and row numbers as values (grouping is ignored) and calls <code><a href="#topic+key_by">key_by()</a></code> function
to use this column as key. If <code>.add</code> is <code>FALSE</code> unique name is computed based
on <code>.tbl</code> column names; if <code>TRUE</code> then based on <code>.tbl</code> and its keys column
names.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mtcars %&gt;% use_id()

mtcars %&gt;% add_id()

mtcars %&gt;% key_by_id(.exclude = TRUE)

</code></pre>

<hr>
<h2 id='keyholder-scoped'>Operate on a selection of keys</h2><span id='topic+keyholder-scoped'></span>

<h3>Description</h3>

<p><a href="#topic+keyholder-package">keyholder</a> offers <a href="dplyr.html#topic+scoped">scoped</a> variants of the
following functions:
</p>

<ul>
<li> <p><code><a href="#topic+key_by">key_by()</a></code>. See <a href="#topic+key-by-scoped">key_by_all()</a>.
</p>
</li>
<li> <p><code><a href="#topic+remove_keys">remove_keys()</a></code>. See <a href="#topic+remove-keys-scoped">remove_keys_all()</a>.
</p>
</li>
<li> <p><code><a href="#topic+restore_keys">restore_keys()</a></code>. See <a href="#topic+restore-keys-scoped">restore_keys_all()</a>.
</p>
</li>
<li> <p><code><a href="#topic+rename_keys">rename_keys()</a></code>. See <a href="#topic+rename-keys-scoped">rename_keys_all()</a>.
</p>
</li></ul>



<h3>Arguments</h3>

<table>
<tr><td><code id="keyholder-scoped_+3A_.funs">.funs</code></td>
<td>
<p>Parameter for <a href="dplyr.html#topic+scoped">scoped</a> functions.</p>
</td></tr>
<tr><td><code id="keyholder-scoped_+3A_.vars">.vars</code></td>
<td>
<p>Parameter for <a href="dplyr.html#topic+scoped">scoped</a> functions.</p>
</td></tr>
<tr><td><code id="keyholder-scoped_+3A_.predicate">.predicate</code></td>
<td>
<p>Parameter for <a href="dplyr.html#topic+scoped">scoped</a> functions.</p>
</td></tr>
<tr><td><code id="keyholder-scoped_+3A_...">...</code></td>
<td>
<p>Parameter for <a href="dplyr.html#topic+scoped">scoped</a> functions.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><a href="#topic+keys-manipulate">Not scoped manipulation functions</a>
</p>
<p><a href="#topic+keys-set">Not scoped key_by()</a>
</p>

<hr>
<h2 id='keyholder-supported-funs'>Supported functions</h2><span id='topic+keyholder-supported-funs'></span>

<h3>Description</h3>

<p><code>keyholder</code> supports the following functions:
</p>

<ul>
<li><p> Base subsetting with <a href="base.html#topic++5B">[</a>.
</p>
</li>
<li> <p><code>dplyr</code> <a href="#topic+keyed-df-one-tbl">one table verbs</a>.
</p>
</li>
<li> <p><code>dplyr</code> <a href="#topic+keyed-df-two-tbl">two table verbs</a>.
</p>
</li></ul>


<hr>
<h2 id='keys-get'>Get keys</h2><span id='topic+keys-get'></span><span id='topic+keys'></span><span id='topic+raw_keys'></span><span id='topic+has_keys'></span>

<h3>Description</h3>

<p>Functions for getting information about keys.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>keys(.tbl)

raw_keys(.tbl)

has_keys(.tbl)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="keys-get_+3A_.tbl">.tbl</code></td>
<td>
<p>Reference data frame.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>keys()</code> always returns a <a href="tibble.html#topic+lst">tibble</a> of keys. In case of
no keys it returns a tibble with number of rows as in <code>.tbl</code> and zero
columns. <code>raw_keys()</code> is just a wrapper for <code>attr(.tbl, "keys")</code>.
To know whether <code>.tbl</code> has keys use <code>has_keys()</code>.
</p>


<h3>See Also</h3>

<p><a href="#topic+keys-set">Set keys</a>, <a href="#topic+keys-manipulate">Manipulate keys</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>keys(mtcars)

raw_keys(mtcars)

has_keys(mtcars)

df &lt;- key_by(mtcars, vs, am)
keys(df)

has_keys(df)

</code></pre>

<hr>
<h2 id='keys-manipulate'>Manipulate keys</h2><span id='topic+keys-manipulate'></span><span id='topic+remove_keys'></span><span id='topic+restore_keys'></span><span id='topic+pull_key'></span><span id='topic+rename_keys'></span>

<h3>Description</h3>

<p>Functions to manipulate <a href="#topic+keys-set">keys</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>remove_keys(.tbl, ..., .unkey = FALSE)

restore_keys(.tbl, ..., .remove = FALSE, .unkey = FALSE)

pull_key(.tbl, var)

rename_keys(.tbl, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="keys-manipulate_+3A_.tbl">.tbl</code></td>
<td>
<p>Reference data frame.</p>
</td></tr>
<tr><td><code id="keys-manipulate_+3A_...">...</code></td>
<td>
<p>Variables to be used for operations defined in similar fashion as
in <code><a href="dplyr.html#topic+select">dplyr::select()</a></code>.</p>
</td></tr>
<tr><td><code id="keys-manipulate_+3A_.unkey">.unkey</code></td>
<td>
<p>Whether to <code><a href="#topic+unkey">unkey()</a></code> <code>.tbl</code> in case there are no keys left.</p>
</td></tr>
<tr><td><code id="keys-manipulate_+3A_.remove">.remove</code></td>
<td>
<p>Whether to remove keys after restoring.</p>
</td></tr>
<tr><td><code id="keys-manipulate_+3A_var">var</code></td>
<td>
<p>Parameter for <code><a href="dplyr.html#topic+pull">dplyr::pull()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>remove_keys()</code> removes keys defined with <code>...</code>.
</p>
<p><code>restore_keys()</code> transfers keys defined with <code>...</code> into <code>.tbl</code> and removes
them from <code>keys</code> if <code>.remove == TRUE</code>. If <code>.tbl</code> is grouped the following
happens:
</p>

<ul>
<li><p> If restored keys don't contain grouping variables then groups don't change;
</p>
</li>
<li><p> If restored keys contain grouping variables then result will be regrouped
based on restored values. In other words restoring keys beats 'not-modifying'
grouping variables rule. It is made according to the ideology of keys: they
contain information about rows and by restoring you want it to be
available.
</p>
</li></ul>

<p><code>pull_key()</code> extracts one specified column from keys with <code><a href="dplyr.html#topic+pull">dplyr::pull()</a></code>.
</p>
<p><code>rename_keys()</code> renames columns in keys using <code><a href="dplyr.html#topic+rename">dplyr::rename()</a></code>.
</p>


<h3>See Also</h3>

<p><a href="#topic+keys-get">Get keys</a>, <a href="#topic+keys-set">Set keys</a>
</p>
<p><a href="#topic+keyholder-scoped">Scoped functions</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- mtcars %&gt;% dplyr::as_tibble() %&gt;%
  key_by(vs, am, .exclude = TRUE)
df %&gt;% remove_keys(vs)

df %&gt;% remove_keys(dplyr::everything())

df %&gt;% remove_keys(dplyr::everything(), .unkey = TRUE)


df %&gt;% restore_keys(vs)

df %&gt;% restore_keys(vs, .remove = TRUE)


df %&gt;% restore_keys(dplyr::everything(), .remove = TRUE)

df %&gt;% restore_keys(dplyr::everything(), .remove = TRUE, .unkey = TRUE)


# Restoring on grouped data frame
df_grouped &lt;- df %&gt;% dplyr::mutate(vs = 1) %&gt;% dplyr::group_by(vs)
df_grouped %&gt;% restore_keys(dplyr::everything())

# Pulling
df %&gt;% pull_key(vs)

# Renaming
df %&gt;% rename_keys(Vs = vs)

</code></pre>

<hr>
<h2 id='keys-set'>Set keys</h2><span id='topic+keys-set'></span><span id='topic+keys+3C-'></span><span id='topic+assign_keys'></span><span id='topic+key_by'></span><span id='topic+unkey'></span>

<h3>Description</h3>

<p>Key is a vector which goal is to provide information about rows in reference
data frame. Its length should always be equal to number of rows in
data frame. Keys are stored as <a href="tibble.html#topic+lst">tibble</a> in attribute <code>"keys"</code>
and so one data frame can have multiple keys. Data frame with keys is
implemented as class <a href="#topic+keyed-df">keyed_df</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>keys(.tbl) &lt;- value

assign_keys(.tbl, value)

key_by(.tbl, ..., .add = FALSE, .exclude = FALSE)

unkey(.tbl)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="keys-set_+3A_.tbl">.tbl</code></td>
<td>
<p>Reference data frame .</p>
</td></tr>
<tr><td><code id="keys-set_+3A_value">value</code></td>
<td>
<p>Values of keys (converted to <a href="tibble.html#topic+as_tibble">tibble</a>).</p>
</td></tr>
<tr><td><code id="keys-set_+3A_...">...</code></td>
<td>
<p>Variables to be used as keys defined in similar fashion as in
<code><a href="dplyr.html#topic+select">dplyr::select()</a></code>.</p>
</td></tr>
<tr><td><code id="keys-set_+3A_.add">.add</code></td>
<td>
<p>Whether to add keys to (possibly) existing ones. If <code>FALSE</code> keys
will be overridden.</p>
</td></tr>
<tr><td><code id="keys-set_+3A_.exclude">.exclude</code></td>
<td>
<p>Whether to exclude key variables from <code>.tbl</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>key_by</code> ignores grouping when creating keys. Also if <code>.add == TRUE</code>
and names of some added keys match the names of existing keys the new ones
will override the old ones.
</p>
<p>Value for <code style="white-space: pre;">&#8288;keys&lt;-&#8288;</code> should not be <code>NULL</code> because it is converted to tibble
with zero rows. To remove keys use <code>unkey()</code>, <code><a href="#topic+remove_keys">remove_keys()</a></code> or
<code><a href="#topic+restore_keys">restore_keys()</a></code>. <code>assign_keys</code> is a more suitable for piping wrapper for
<code style="white-space: pre;">&#8288;keys&lt;-&#8288;</code>.
</p>


<h3>See Also</h3>

<p><a href="#topic+keys-get">Get keys</a>, <a href="#topic+keys-manipulate">Manipulate keys</a>
</p>
<p><a href="#topic+key-by-scoped">Scoped key_by()</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- dplyr::as_tibble(mtcars)

# Value is converted to tibble
keys(df) &lt;- 1:nrow(df)

# This will throw an error
## Not run: 
keys(df) &lt;- 1:10

## End(Not run)

# Use 'vs' and 'am' as keys
df %&gt;% key_by(vs, am)

df %&gt;% key_by(vs, am, .exclude = TRUE)

df %&gt;% key_by(vs) %&gt;% key_by(am, .add = TRUE, .exclude = TRUE)

# Override keys
df %&gt;% key_by(vs, am) %&gt;% dplyr::mutate(vs = 1) %&gt;%
  key_by(gear, vs, .add = TRUE)

# Use select helpers
df %&gt;% key_by(dplyr::one_of(c("vs", "am")))

df %&gt;% key_by(dplyr::everything())

</code></pre>

<hr>
<h2 id='reexports'>Objects exported from other packages</h2><span id='topic+reexports'></span><span id='topic+filter'></span><span id='topic++25+3E+25'></span>

<h3>Description</h3>

<p>These objects are imported from other packages. Follow the links
below to see their documentation.
</p>

<dl>
<dt>dplyr</dt><dd><p><code><a href="dplyr.html#topic+reexports">%&gt;%</a></code>, <code><a href="dplyr.html#topic+filter">filter</a></code></p>
</dd>
</dl>

<hr>
<h2 id='remove-keys-scoped'>Remove selection of keys</h2><span id='topic+remove-keys-scoped'></span><span id='topic+remove_keys_all'></span><span id='topic+remove_keys_if'></span><span id='topic+remove_keys_at'></span>

<h3>Description</h3>

<p>These functions remove selection of keys using corresponding
<a href="dplyr.html#topic+select_all">scoped variant</a> of <a href="dplyr.html#topic+select">select</a>. <code>.funs</code>
argument is removed because of its redundancy.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>remove_keys_all(.tbl, ..., .unkey = FALSE)

remove_keys_if(.tbl, .predicate, ..., .unkey = FALSE)

remove_keys_at(.tbl, .vars, ..., .unkey = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="remove-keys-scoped_+3A_.tbl">.tbl</code></td>
<td>
<p>Reference data frame.</p>
</td></tr>
<tr><td><code id="remove-keys-scoped_+3A_...">...</code></td>
<td>
<p>Parameter for <a href="dplyr.html#topic+scoped">scoped</a> functions.</p>
</td></tr>
<tr><td><code id="remove-keys-scoped_+3A_.unkey">.unkey</code></td>
<td>
<p>Whether to <code><a href="#topic+unkey">unkey()</a></code> <code>.tbl</code> in case there are no keys left.</p>
</td></tr>
<tr><td><code id="remove-keys-scoped_+3A_.predicate">.predicate</code></td>
<td>
<p>Parameter for <a href="dplyr.html#topic+scoped">scoped</a> functions.</p>
</td></tr>
<tr><td><code id="remove-keys-scoped_+3A_.vars">.vars</code></td>
<td>
<p>Parameter for <a href="dplyr.html#topic+scoped">scoped</a> functions.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- mtcars %&gt;% dplyr::as_tibble() %&gt;% key_by(vs, am, disp)
df %&gt;% remove_keys_all()

df %&gt;% remove_keys_all(.unkey = TRUE)

df %&gt;% remove_keys_if(rlang::is_integerish)

df %&gt;% remove_keys_at(c("vs", "am"))

</code></pre>

<hr>
<h2 id='rename-keys-scoped'>Rename selection of keys</h2><span id='topic+rename-keys-scoped'></span><span id='topic+rename_keys_all'></span><span id='topic+rename_keys_if'></span><span id='topic+rename_keys_at'></span>

<h3>Description</h3>

<p>These functions rename selection of keys using corresponding
<a href="dplyr.html#topic+select_all">scoped variant</a> of <a href="dplyr.html#topic+rename">rename</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rename_keys_all(.tbl, .funs = list(), ...)

rename_keys_if(.tbl, .predicate, .funs = list(), ...)

rename_keys_at(.tbl, .vars, .funs = list(), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rename-keys-scoped_+3A_.tbl">.tbl</code></td>
<td>
<p>Reference data frame.</p>
</td></tr>
<tr><td><code id="rename-keys-scoped_+3A_.funs">.funs</code></td>
<td>
<p>Parameter for <a href="dplyr.html#topic+scoped">scoped</a> functions.</p>
</td></tr>
<tr><td><code id="rename-keys-scoped_+3A_...">...</code></td>
<td>
<p>Parameter for <a href="dplyr.html#topic+scoped">scoped</a> functions.</p>
</td></tr>
<tr><td><code id="rename-keys-scoped_+3A_.predicate">.predicate</code></td>
<td>
<p>Parameter for <a href="dplyr.html#topic+scoped">scoped</a> functions.</p>
</td></tr>
<tr><td><code id="rename-keys-scoped_+3A_.vars">.vars</code></td>
<td>
<p>Parameter for <a href="dplyr.html#topic+scoped">scoped</a> functions.</p>
</td></tr>
</table>

<hr>
<h2 id='restore-keys-scoped'>Restore selection of keys</h2><span id='topic+restore-keys-scoped'></span><span id='topic+restore_keys_all'></span><span id='topic+restore_keys_if'></span><span id='topic+restore_keys_at'></span>

<h3>Description</h3>

<p>These functions restore selection of keys using corresponding
<a href="dplyr.html#topic+select_all">scoped variant</a> of <a href="dplyr.html#topic+select">select</a>. <code>.funs</code>
argument can be used to rename some keys (without touching actual keys)
before restoring.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>restore_keys_all(.tbl, .funs = list(), ..., .remove = FALSE,
  .unkey = FALSE)

restore_keys_if(.tbl, .predicate, .funs = list(), ..., .remove = FALSE,
  .unkey = FALSE)

restore_keys_at(.tbl, .vars, .funs = list(), ..., .remove = FALSE,
  .unkey = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="restore-keys-scoped_+3A_.tbl">.tbl</code></td>
<td>
<p>Reference data frame.</p>
</td></tr>
<tr><td><code id="restore-keys-scoped_+3A_.funs">.funs</code></td>
<td>
<p>Parameter for <a href="dplyr.html#topic+scoped">scoped</a> functions.</p>
</td></tr>
<tr><td><code id="restore-keys-scoped_+3A_...">...</code></td>
<td>
<p>Parameter for <a href="dplyr.html#topic+scoped">scoped</a> functions.</p>
</td></tr>
<tr><td><code id="restore-keys-scoped_+3A_.remove">.remove</code></td>
<td>
<p>Whether to remove keys after restoring.</p>
</td></tr>
<tr><td><code id="restore-keys-scoped_+3A_.unkey">.unkey</code></td>
<td>
<p>Whether to <code><a href="#topic+unkey">unkey()</a></code> <code>.tbl</code> in case there are no keys left.</p>
</td></tr>
<tr><td><code id="restore-keys-scoped_+3A_.predicate">.predicate</code></td>
<td>
<p>Parameter for <a href="dplyr.html#topic+scoped">scoped</a> functions.</p>
</td></tr>
<tr><td><code id="restore-keys-scoped_+3A_.vars">.vars</code></td>
<td>
<p>Parameter for <a href="dplyr.html#topic+scoped">scoped</a> functions.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- mtcars %&gt;% dplyr::as_tibble() %&gt;% key_by(vs, am, disp)
# Just restore all keys
df %&gt;% restore_keys_all()

# Restore all keys with renaming and without touching actual keys
df %&gt;% restore_keys_all(.funs = toupper)

# Restore with renaming and removing
df %&gt;%
  restore_keys_all(.funs = toupper, .remove = TRUE)

# Restore with renaming, removing and unkeying
df %&gt;%
  restore_keys_all(.funs = toupper, .remove = TRUE, .unkey = TRUE)

# Restore with renaming keys satisfying the predicate
df %&gt;%
  restore_keys_if(rlang::is_integerish, .funs = toupper)

# Restore with renaming specified keys
df %&gt;%
  restore_keys_at(c("vs", "disp"), .funs = toupper)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
