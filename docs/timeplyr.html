<!DOCTYPE html><html lang="en"><head><title>Help for package timeplyr</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {timeplyr}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#timeplyr-package'><p>timeplyr: Fast Tidy Tools for Date and Date-Time Manipulation</p></a></li>
<li><a href='#.time_units'><p>Time units</p></a></li>
<li><a href='#+25+26gt+3B+25'><p>Pipe operator</p></a></li>
<li><a href='#age_years'><p>Accurate and efficient age calculation</p></a></li>
<li><a href='#calendar'><p>Create a table of common time units from a date or datetime sequence.</p></a></li>
<li><a href='#get_time_delay'><p>Get summary statistics of time delay</p></a></li>
<li><a href='#growth'><p>Rolling basic growth</p></a></li>
<li><a href='#growth_rate'><p>Fast Growth Rates</p></a></li>
<li><a href='#is_date'><p>Utility functions for checking if date or datetime</p></a></li>
<li><a href='#is_whole_number'><p>Are all numbers whole numbers?</p></a></li>
<li><a href='#iso_week'><p>Efficient, simple and flexible ISO week calculation</p></a></li>
<li><a href='#missing_dates'><p>Check for missing dates between first and last date</p></a></li>
<li><a href='#reset_timeplyr_options'><p>Reset 'timeplyr' options</p></a></li>
<li><a href='#resolution'><p>Time resolution &amp; granularity</p></a></li>
<li><a href='#roll_lag'><p>Fast rolling grouped lags and differences</p></a></li>
<li><a href='#roll_na_fill'><p>Fast grouped &quot;locf&quot; <code>NA</code> fill</p></a></li>
<li><a href='#roll_sum'><p>Fast by-group rolling functions</p></a></li>
<li><a href='#time_add'><p>Add/subtract timespans to dates and date-times</p></a></li>
<li><a href='#time_by'><p>Group by a time variable at a higher time unit</p></a></li>
<li><a href='#time_cut'><p>Cut dates and datetimes into regularly spaced date or datetime intervals</p></a></li>
<li><a href='#time_diff'><p>Time differences by any time unit</p></a></li>
<li><a href='#time_elapsed'><p>Fast grouped time elapsed</p></a></li>
<li><a href='#time_episodes'><p>Episodic calculation of time-since-event data</p></a></li>
<li><a href='#time_expand'><p>A time based extension to <code>tidyr::complete()</code>.</p></a></li>
<li><a href='#time_gaps'><p>Gaps in a regular time sequence</p></a></li>
<li><a href='#time_ggplot'><p>Quick time-series ggplot</p></a></li>
<li><a href='#time_grid'><p>Vector date and datetime functions</p></a></li>
<li><a href='#time_id'><p>Time ID</p></a></li>
<li><a href='#time_interval'><p>S3-based Time Intervals (Currently very experimental and so subject to change)</p></a></li>
<li><a href='#time_is_regular'><p>Is time a regular sequence? (Experimental)</p></a></li>
<li><a href='#time_roll_sum'><p>Fast time-based by-group rolling sum/mean - Currently experimental</p></a></li>
<li><a href='#time_seq'><p>Time based version of <code>base::seq()</code></p></a></li>
<li><a href='#time_seq_id'><p>Generate a unique identifier for a regular time sequence with gaps</p></a></li>
<li><a href='#timespan'><p>Timespans</p></a></li>
<li><a href='#transform_year_month'><p>Additional ggplot2 scales</p></a></li>
<li><a href='#ts_as_tbl'><p>Turn <code>ts</code> into a <code>tibble</code></p></a></li>
<li><a href='#year_month'><p>Fast methods for creating year-months and year-quarters</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Fast Tidy Tools for Date and Date-Time Manipulation</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1.0</td>
</tr>
<tr>
<td>Description:</td>
<td>A set of fast tidy functions for wrangling, completing and
    summarising date and date-time data. It combines 'tidyverse' syntax
    with the efficiency of 'data.table' and speed of 'collapse'.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/NicChr/timeplyr/issues">https://github.com/NicChr/timeplyr/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.0.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>cheapr (&ge; 1.0.0), cli, collapse (&ge; 2.0.0), cppdoubles (&ge;
0.2.0), data.table (&ge; 1.14.8), dplyr (&ge; 1.1.0), fastplyr (&ge;
0.5.0), ggplot2 (&ge; 3.4.0), lifecycle, lubridate (&ge; 1.9.0),
magrittr, pillar (&ge; 1.7.0), rlang (&ge; 1.0.0), scales, stringr
(&ge; 1.4.0), tidyselect (&ge; 1.2.0), timechange (&ge; 0.2.0), vctrs
(&ge; 0.6.0)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>bench, knitr, nycflights13, outbreaks, rmarkdown, testthat
(&ge; 3.0.0), tidyr, zoo</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>cpp11, tzdb</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-03-17 18:11:59 UTC; Nmc5</td>
</tr>
<tr>
<td>Author:</td>
<td>Nick Christofides <a href="https://orcid.org/0000-0002-9743-7342"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Nick Christofides &lt;nick.christofides.r@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-03-17 18:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='timeplyr-package'>timeplyr: Fast Tidy Tools for Date and Date-Time Manipulation</h2><span id='topic+timeplyr-package'></span>

<h3>Description</h3>

<p>A framework for handling raw date &amp; datetime data <br />
using tidy best-practices from the tidyverse, the efficiency of data.table,
and the speed of collapse.
</p>
<p>You can learn more about the tidyverse,
data.table and collapse using the links below
</p>
<p><a href="https://www.tidyverse.org/learn/">tidyverse</a>
</p>
<p><a href="https://CRAN.R-project.org/package=data.table">data.table</a>
</p>
<p><a href="https://sebkrantz.github.io/collapse/articles/collapse_intro.html">collapse</a>
</p>
<p>A framework for handling raw date &amp; datetime data <br />
using tidy best-practices from the tidyverse, the efficiency of data.table,
and the speed of collapse.
</p>
<p>You can learn more about the tidyverse,
data.table and collapse using the links below
</p>
<p><a href="https://www.tidyverse.org/learn/">tidyverse</a>
</p>
<p><a href="https://CRAN.R-project.org/package=data.table">data.table</a>
</p>
<p><a href="https://sebkrantz.github.io/collapse/articles/collapse_intro.html">collapse</a>
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Nick Christofides <a href="mailto:nick.christofides.r@gmail.com">nick.christofides.r@gmail.com</a> (<a href="https://orcid.org/0000-0002-9743-7342">ORCID</a>)
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li><p> Report bugs at <a href="https://github.com/NicChr/timeplyr/issues">https://github.com/NicChr/timeplyr/issues</a>
</p>
</li></ul>

<p>Useful links:
</p>

<ul>
<li><p> Report bugs at <a href="https://github.com/NicChr/timeplyr/issues">https://github.com/NicChr/timeplyr/issues</a>
</p>
</li></ul>


<hr>
<h2 id='.time_units'>Time units</h2><span id='topic+.time_units'></span><span id='topic+.period_units'></span><span id='topic+.duration_units'></span><span id='topic+.extra_time_units'></span>

<h3>Description</h3>

<p>Time units
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.time_units

.period_units

.duration_units

.extra_time_units
</code></pre>


<h3>Format</h3>

<p>An object of class <code>character</code> of length 21.
</p>
<p>An object of class <code>character</code> of length 7.
</p>
<p>An object of class <code>character</code> of length 11.
</p>
<p>An object of class <code>character</code> of length 10.
</p>

<hr>
<h2 id='+25+26gt+3B+25'>Pipe operator</h2><span id='topic++25+3E+25'></span>

<h3>Description</h3>

<p>See <code>magrittr::<a href="magrittr.html#topic+pipe">%&gt;%</a></code> for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lhs %&gt;% rhs
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="+2B25+2B26gt+2B3B+2B25_+3A_lhs">lhs</code></td>
<td>
<p>A value or the magrittr placeholder.</p>
</td></tr>
<tr><td><code id="+2B25+2B26gt+2B3B+2B25_+3A_rhs">rhs</code></td>
<td>
<p>A function call using the magrittr semantics.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The result of calling <code>rhs(lhs)</code>.
</p>

<hr>
<h2 id='age_years'>Accurate and efficient age calculation</h2><span id='topic+age_years'></span><span id='topic+age_months'></span>

<h3>Description</h3>

<p>Correct calculation of ages in years using lubridate periods.
Leap year calculations work as well.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>age_years(start, end = if (is_date(start)) Sys.Date() else Sys.time())

age_months(start, end = if (is_date(start)) Sys.Date() else Sys.time())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="age_years_+3A_start">start</code></td>
<td>
<p>Start date/datetime, typically date of birth.</p>
</td></tr>
<tr><td><code id="age_years_+3A_end">end</code></td>
<td>
<p>End date/datetime. Default is current date/datetime.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Integer vector of age in years or months.
</p>

<hr>
<h2 id='calendar'>Create a table of common time units from a date or datetime sequence.</h2><span id='topic+calendar'></span>

<h3>Description</h3>

<p>Create a table of common time units from a date or datetime sequence.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calendar(
  x,
  label = TRUE,
  week_start = getOption("lubridate.week.start", 1),
  fiscal_start = getOption("lubridate.fiscal.start", 1),
  name = "time"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calendar_+3A_x">x</code></td>
<td>
<p>date or datetime vector.</p>
</td></tr>
<tr><td><code id="calendar_+3A_label">label</code></td>
<td>
<p>Logical. Should labelled (ordered factor) versions of
week day and month be returned? Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="calendar_+3A_week_start">week_start</code></td>
<td>
<p>day on which week starts following ISO conventions - 1
means Monday, 7 means Sunday (default). When <code>label = TRUE</code>,
this will be the first level of the returned factor.
You can set <code>lubridate.week.start</code> option to control this parameter globally.</p>
</td></tr>
<tr><td><code id="calendar_+3A_fiscal_start">fiscal_start</code></td>
<td>
<p>Numeric indicating the starting month of a fiscal year.</p>
</td></tr>
<tr><td><code id="calendar_+3A_name">name</code></td>
<td>
<p>Name of date/datetime column.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>tibble</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(timeplyr)
library(lubridate)

# Create a calendar for the current year
from &lt;- floor_date(today(), unit = "year")
to &lt;- ceiling_date(today(), unit = "year", change_on_boundary = TRUE) - days(1)

my_seq &lt;- time_seq(from, to, "day")
calendar(my_seq)

</code></pre>

<hr>
<h2 id='get_time_delay'>Get summary statistics of time delay</h2><span id='topic+get_time_delay'></span>

<h3>Description</h3>

<p>The output is a <code>list</code> containing summary statistics of time delay between two date/datetime vectors.
This can be especially useful in estimating reporting delay for example.
</p>

<ul>
<li> <p><b>data</b> - A data frame containing the origin, end and calculated time delay.
</p>
</li>
<li> <p><b>unit</b> - The chosen time unit.
</p>
</li>
<li> <p><b>num</b> - The number of time units.
</p>
</li>
<li> <p><b>summary</b> - <code>tibble</code> with summary statistics.
</p>
</li>
<li> <p><b>delay</b> - <code>tibble</code> containing the empirical cumulative distribution function
values by time delay.
</p>
</li>
<li> <p><b>plot</b> - A <code>ggplot</code> of the time delay distribution.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>get_time_delay(
  data,
  origin,
  end,
  timespan = 1L,
  min_delay = -Inf,
  max_delay = Inf,
  probs = c(0.25, 0.5, 0.75, 0.95),
  .by = NULL,
  include_plot = TRUE,
  x_scales = "fixed",
  bw = "sj",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_time_delay_+3A_data">data</code></td>
<td>
<p>A data frame.</p>
</td></tr>
<tr><td><code id="get_time_delay_+3A_origin">origin</code></td>
<td>
<p>Origin date variable.</p>
</td></tr>
<tr><td><code id="get_time_delay_+3A_end">end</code></td>
<td>
<p>End date variable.</p>
</td></tr>
<tr><td><code id="get_time_delay_+3A_timespan">timespan</code></td>
<td>
<p><a href="#topic+timespan">timespan</a>.</p>
</td></tr>
<tr><td><code id="get_time_delay_+3A_min_delay">min_delay</code></td>
<td>
<p>The minimum acceptable delay,
all delays less than this are removed before calculation.
Default is <code>min_delay = -Inf</code>.</p>
</td></tr>
<tr><td><code id="get_time_delay_+3A_max_delay">max_delay</code></td>
<td>
<p>The maximum acceptable delay,
all delays greater than this are removed before calculation.
Default is <code>max_delay = Inf</code>.</p>
</td></tr>
<tr><td><code id="get_time_delay_+3A_probs">probs</code></td>
<td>
<p>Probabilities used in the quantile summary.
Default is <code>probs = c(0.25, 0.5, 0.75, 0.95)</code>.</p>
</td></tr>
<tr><td><code id="get_time_delay_+3A_.by">.by</code></td>
<td>
<p>(Optional). A selection of columns to group by for this operation.
Columns are specified using tidy-select.</p>
</td></tr>
<tr><td><code id="get_time_delay_+3A_include_plot">include_plot</code></td>
<td>
<p>Should a <code>ggplot</code> graph of delay distributions be included in the output?</p>
</td></tr>
<tr><td><code id="get_time_delay_+3A_x_scales">x_scales</code></td>
<td>
<p>Option to control how the x-axis is displayed for multiple facets.
Choices are &quot;fixed&quot; or &quot;free_x&quot;.</p>
</td></tr>
<tr><td><code id="get_time_delay_+3A_bw">bw</code></td>
<td>
<p>The smoothing bandwidth selector for the Kernel Density estimator.
If numeric, the standard deviation of the smoothing kernel.
If character, a rule to choose the bandwidth. See <code>?stats::bw.nrd</code> for more details.
The default has been set to &quot;SJ&quot; which implements the Sheather &amp; Jones (1991) method,
as recommended by the R team <code>?stats::density</code>.
This differs from the default implemented by <code>stats::density()</code>
which uses Silverman's rule-of-thumb.</p>
</td></tr>
<tr><td><code id="get_time_delay_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed on to <code>ggplot2::geom_density()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing summary data, summary statistics and an optional <code>ggplot</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(timeplyr)
library(outbreaks)
library(dplyr)

ebola_linelist &lt;- ebola_sim_clean$linelist

# Incubation period distribution

# 95% of individuals experienced an incubation period of &lt;= 26 days
inc_distr_days &lt;- ebola_linelist %&gt;%
  get_time_delay(date_of_infection,
                 date_of_onset,
                 time = "days")
head(inc_distr_days$data)
inc_distr_days$unit
inc_distr_days$num
inc_distr_days$summary
head(inc_distr_days$delay) # ECDF and freq by delay
inc_distr_days$plot

# Can change bandwidth selector
inc_distr_days &lt;- ebola_linelist %&gt;%
  get_time_delay(date_of_infection,
                 date_of_onset,
                 time = "day",
                 bw = "nrd")
inc_distr_days$plot

# Can choose any time units
inc_distr_weeks &lt;- ebola_linelist %&gt;%
  get_time_delay(date_of_infection,
                 date_of_onset,
                 time = "weeks",
                 bw = "nrd")
inc_distr_weeks$plot

</code></pre>

<hr>
<h2 id='growth'>Rolling basic growth</h2><span id='topic+growth'></span><span id='topic+rolling_growth'></span>

<h3>Description</h3>

<p>Calculate basic growth calculations on a rolling basis.
<code>growth()</code> calculates the percent change between the totals of two numeric vectors
when they're of equal length, otherwise the percent change between the means.
<code>rolling_growth()</code> does the same calculation on 1 numeric vector, on a rolling basis.
Pairs of windows of length <code>n</code>, lagged by the value specified by <code>lag</code> are compared in
a similar manner.
When <code>lag = n</code> then <code>data.table::frollsum()</code> is used,
otherwise <code>data.table::frollmean()</code> is used.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>growth(x, y, na.rm = FALSE, log = FALSE, inf_fill = NULL)

rolling_growth(
  x,
  n = 1,
  lag = n,
  na.rm = FALSE,
  partial = TRUE,
  offset = NULL,
  weights = NULL,
  inf_fill = NULL,
  log = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="growth_+3A_x">x</code></td>
<td>
<p>Numeric vector.</p>
</td></tr>
<tr><td><code id="growth_+3A_y">y</code></td>
<td>
<p>numeric vector</p>
</td></tr>
<tr><td><code id="growth_+3A_na.rm">na.rm</code></td>
<td>
<p>Should missing values be removed when calculating window? Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="growth_+3A_log">log</code></td>
<td>
<p>If <code>TRUE</code> Growth (relative change) in total and mean events will be
calculated on the log-scale.</p>
</td></tr>
<tr><td><code id="growth_+3A_inf_fill">inf_fill</code></td>
<td>
<p>Numeric value to replace <code>Inf</code> values with. Default behaviour is to keep <code>Inf</code> values.</p>
</td></tr>
<tr><td><code id="growth_+3A_n">n</code></td>
<td>
<p>Rolling window size, default is 1.</p>
</td></tr>
<tr><td><code id="growth_+3A_lag">lag</code></td>
<td>
<p>Lag of basic growth comparison, default is the rolling window size.</p>
</td></tr>
<tr><td><code id="growth_+3A_partial">partial</code></td>
<td>
<p>Should rates be calculated outwith the window using partial windows?
If <code>TRUE</code> (the default), (n - 1) pairs of equally-sized rolling windows are compared,
their size increasing by 1 up to size n, at which point the rest of the window pairs are
all of size n. If <code>FALSE</code> all window-pairs will be of size n.</p>
</td></tr>
<tr><td><code id="growth_+3A_offset">offset</code></td>
<td>
<p>Numeric vector of values to use as offset, e.g. population sizes or exposure times.</p>
</td></tr>
<tr><td><code id="growth_+3A_weights">weights</code></td>
<td>
<p>Importance weights. These can either be
length 1 or the same length as x.
Currently, no normalisation of weights occurs.</p>
</td></tr>
<tr><td><code id="growth_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed on to <code>frollmean</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>growth</code> returns a <code>numeric(1)</code> and <code>rolling_growth</code>
returns a <code>numeric(length(x))</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(timeplyr)

set.seed(42)
# Growth rate is 6% per day
x &lt;- 10 * (1.06)^(0:25)

# Simple growth from one day to the next
rolling_growth(x, n = 1)

# Growth comparing rolling 3 day cumulative
rolling_growth(x, n = 3)

# Growth comparing rolling 3 day cumulative, lagged by 1 day
rolling_growth(x, n = 3, lag = 1)

# Growth comparing windows of equal size
rolling_growth(x, n = 3, partial = FALSE)

# Seven day moving average growth
roll_mean(rolling_growth(x), window = 7, partial = FALSE)

</code></pre>

<hr>
<h2 id='growth_rate'>Fast Growth Rates</h2><span id='topic+growth_rate'></span>

<h3>Description</h3>

<p>Calculate the rate of percentage
change per unit time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>growth_rate(x, na.rm = FALSE, log = FALSE, inf_fill = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="growth_rate_+3A_x">x</code></td>
<td>
<p>Numeric vector.</p>
</td></tr>
<tr><td><code id="growth_rate_+3A_na.rm">na.rm</code></td>
<td>
<p>Should missing values be removed when calculating window?
Defaults to <code>FALSE</code>. When <code>na.rm = TRUE</code> the size of the rolling windows
are adjusted to the number of non-<code>NA</code> values in each window.</p>
</td></tr>
<tr><td><code id="growth_rate_+3A_log">log</code></td>
<td>
<p>If <code>TRUE</code> then growth rates are calculated on the log-scale.</p>
</td></tr>
<tr><td><code id="growth_rate_+3A_inf_fill">inf_fill</code></td>
<td>
<p>Numeric value to replace <code>Inf</code> values with.
Default behaviour is to keep <code>Inf</code> values.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It is assumed that <code>x</code> is a vector of values with
a corresponding time index that increases regularly
with no gaps or missing values.
</p>
<p>The output is to be interpreted as the average percent change per unit time.
</p>
<p>For a rolling version that can calculate rates as you move through time,
see <code>roll_growth_rate</code>.
</p>
<p>For a more generalised method that incorporates
time gaps and complex time windows,
use <code>time_roll_growth_rate</code>.
</p>
<p>The growth rate can also be calculated using the
geometric mean of percent changes.
</p>
<p>The below identity should always hold:
</p>
<pre>
`tail(roll_growth_rate(x, window = length(x)), 1) == growth_rate(x)`
</pre>


<h3>Value</h3>

<p><code>numeric(1)</code>
</p>


<h3>See Also</h3>

<p><a href="#topic+roll_growth_rate">roll_growth_rate</a> <a href="#topic+time_roll_growth_rate">time_roll_growth_rate</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(timeplyr)

set.seed(42)
initial_investment &lt;- 100
years &lt;- 1990:2000
# Assume a rate of 8% increase with noise
relative_increases &lt;- 1.08 + rnorm(10, sd = 0.005)

assets &lt;- Reduce(`*`, relative_increases, init = initial_investment, accumulate = TRUE)
assets

# Note that this is approximately 8%
growth_rate(assets)

# We can also calculate the growth rate via geometric mean

rel_diff &lt;- exp(diff(log(assets)))
all.equal(rel_diff, relative_increases)

geometric_mean &lt;- function(x, na.rm = TRUE, weights = NULL){
  exp(collapse::fmean(log(x), na.rm = na.rm, w = weights))
}

geometric_mean(rel_diff) == growth_rate(assets)

# Weighted growth rate

w &lt;- c(rnorm(5)^2, rnorm(5)^4)
geometric_mean(rel_diff, weights = w)

# Rolling growth rate over the last n years
roll_growth_rate(assets)

# The same but using geometric means
exp(roll_mean(log(c(NA, rel_diff))))

# Rolling growth rate over the last 5 years
roll_growth_rate(assets, window = 5)
roll_growth_rate(assets, window = 5, partial = FALSE)

## Rolling growth rate with gaps in time

years2 &lt;- c(1990, 1993, 1994, 1997, 1998, 2000)
assets2 &lt;- assets[years %in% years2]

# Below does not incorporate time gaps into growth rate calculation
# But includes helpful warning
time_roll_growth_rate(assets2, window = 5, time = years2)
# Time step allows us to calculate correct rates across time gaps
time_roll_growth_rate(assets2, window = 5, time = years2, time_step = 1) # Time aware

</code></pre>

<hr>
<h2 id='is_date'>Utility functions for checking if date or datetime</h2><span id='topic+is_date'></span><span id='topic+is_datetime'></span><span id='topic+is_time'></span><span id='topic+is_time_or_num'></span>

<h3>Description</h3>

<p>Utility functions for checking if date or datetime
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_date(x)

is_datetime(x)

is_time(x)

is_time_or_num(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is_date_+3A_x">x</code></td>
<td>
<p>Time variable. <br />
Can be a <code>Date</code>, <code>POSIXt</code>, <code>numeric</code>, <code>integer</code>,
<code>yearmon</code>, <code>yearqtr</code>, <code>year_month</code> or <code>year_quarter</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <a href="base.html#topic+logical">logical</a> of length 1.
</p>

<hr>
<h2 id='is_whole_number'>Are all numbers whole numbers?</h2><span id='topic+is_whole_number'></span>

<h3>Description</h3>

<p>Are all numbers whole numbers?
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_whole_number(x, tol = .Machine$double.eps^(2/3), na.rm = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is_whole_number_+3A_x">x</code></td>
<td>
<p>A numeric vector.</p>
</td></tr>
<tr><td><code id="is_whole_number_+3A_tol">tol</code></td>
<td>
<p>tolerance value. <br />
The default is <code>.Machine$double.eps^(2/3)</code>, an arbitrarily small tolerance.</p>
</td></tr>
<tr><td><code id="is_whole_number_+3A_na.rm">na.rm</code></td>
<td>
<p>Should <code>NA</code> values be ignored? Default is <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a very efficient function that returns <code>FALSE</code> if any number
is not a whole-number and <code>TRUE</code> if all of them are.
</p>


<h4>Method</h4>

<p><code>x</code> is defined as a whole number vector
if all numbers satisfy <code>abs(x - round(x)) &lt; tol</code>.
</p>



<h4><code>NA</code> handling</h4>

<p><code>NA</code> values are handled in a custom way. <br />
If <code>x</code> is an integer, <code>TRUE</code> is always returned even if <code>x</code> has missing values. <br />
If <code>x</code> has both missing values and decimal numbers, <code>FALSE</code> is always returned. <br />
If <code>x</code> has missing values, and only whole numbers and <code>na.rm = FALSE</code>, then
<code>NA</code> is returned. <br />
Basically <code>NA</code> is only returned if <code>na.rm = FALSE</code> and
<code>x</code> is a double vector of only whole numbers and <code>NA</code> values.
</p>
<p>Inspired by the discussion in this thread:
<a href="https://stackoverflow.com/questions/3476782/check-if-the-number-is-integer/76655734">check-if-the-number-is-integer</a>
</p>



<h3>Value</h3>

<p>A logical vector of length 1.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(timeplyr)
library(dplyr)

# Has built-in tolerance
sqrt(2)^2 %% 1 == 0
is_whole_number(sqrt(2)^2)

is_whole_number(1)
is_whole_number(1.2)

x1 &lt;- c(0.02, 0:10^5)
x2 &lt;- c(0:10^5, 0.02)

is_whole_number(x1)
is_whole_number(x2)

# Somewhat more strict than all.equal

all.equal(10^9 + 0.0001, round(10^9 + 0.0001))
is_whole_number(10^9 + 0.0001)

# Can safely be used to select whole number variables
starwars %&gt;%
  select(where(is_whole_number))

# To reduce the size of any data frame one can use the below code

df &lt;- starwars %&gt;%
  mutate(across(where(is_whole_number), as.integer))

</code></pre>

<hr>
<h2 id='iso_week'>Efficient, simple and flexible ISO week calculation</h2><span id='topic+iso_week'></span><span id='topic+isoday'></span>

<h3>Description</h3>

<p><code>iso_week()</code> is a flexible function to return formatted
ISO weeks, with optional ISO year and ISO day.
<code>isoday()</code> returns the day of the ISO week.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>iso_week(x, year = TRUE, day = FALSE)

isoday(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="iso_week_+3A_x">x</code></td>
<td>
<p>Date vector.</p>
</td></tr>
<tr><td><code id="iso_week_+3A_year">year</code></td>
<td>
<p>Logical. If <code>TRUE</code> then ISO Year is returned
along with the ISO week.</p>
</td></tr>
<tr><td><code id="iso_week_+3A_day">day</code></td>
<td>
<p>Logical. If <code>TRUE</code> then day of the week is returned
with the ISO week, starting at 1, Monday, and ending at 7, Sunday.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An ISO week vector of class <code>character</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(timeplyr)
library(lubridate)

iso_week(today())
iso_week(today(), day = TRUE)
iso_week(today(), year = FALSE, day = TRUE)
iso_week(today(), year = FALSE, day = FALSE)

</code></pre>

<hr>
<h2 id='missing_dates'>Check for missing dates between first and last date</h2><span id='topic+missing_dates'></span><span id='topic+n_missing_dates'></span>

<h3>Description</h3>

<p>Check for missing dates between first and last date
</p>


<h3>Usage</h3>

<pre><code class='language-R'>missing_dates(x)

n_missing_dates(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="missing_dates_+3A_x">x</code></td>
<td>
<p>A Date or Date-Time vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>Date</code> vector.
</p>

<hr>
<h2 id='reset_timeplyr_options'>Reset 'timeplyr' options</h2><span id='topic+reset_timeplyr_options'></span>

<h3>Description</h3>

<p>Reset 'timeplyr' options
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reset_timeplyr_options()
</code></pre>


<h3>Value</h3>

<p>Resets the timeplyr global options (prefixed with <code>"timeplyr."</code>): <br />
roll_month &amp; roll_dst.
</p>

<hr>
<h2 id='resolution'>Time resolution &amp; granularity</h2><span id='topic+resolution'></span><span id='topic+granularity'></span>

<h3>Description</h3>

<p>The definitions of resolution and granularity may evolve over time but
currently the resolution defines the smallest timespan
that differentiates two non-fractional instances in time.
The granularity defines the smallest common time difference.
A practical example would be when using dates to record data with a monthly
frequency. In this case the granularity is 1 month, whereas the resolution
of the data type <code>Date</code> is 1 day. Therefore the resolution depends
only on the data type whereas the granularity depends on the frequency
with which the data is recorded.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>resolution(x, ...)

granularity(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="resolution_+3A_x">x</code></td>
<td>
<p>Time vector. <br />
E.g. a <code>Date</code>, <code>POSIXt</code>, <code>numeric</code> or any time-based vector.</p>
</td></tr>
<tr><td><code id="resolution_+3A_...">...</code></td>
<td>
<p>Further arguments passed to methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For dates and date-times, the argument <code>exact = TRUE</code>
can be used to detect monthly/yearly granularity.
In some cases this can be slow and memory-intensive so
it is advised to set this to <code>FALSE</code> in these cases.
</p>
<p>The default for dates is <code>exact = TRUE</code> whereas the default
for date-times is <code>exact = FALSE</code>.
</p>


<h3>Value</h3>

<p>A <a href="#topic+timespan">timespan</a> object.
</p>

<hr>
<h2 id='roll_lag'>Fast rolling grouped lags and differences</h2><span id='topic+roll_lag'></span><span id='topic+roll_lag.default'></span><span id='topic+roll_lag.ts'></span><span id='topic+roll_lag.zoo'></span><span id='topic+roll_diff'></span><span id='topic+roll_diff.default'></span><span id='topic+roll_diff.ts'></span><span id='topic+roll_diff.zoo'></span><span id='topic+diff_'></span>

<h3>Description</h3>

<p>Inspired by 'collapse', <code>roll_lag</code> and <code>roll_diff</code> operate similarly to
<code>flag</code> and <code>fdiff</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>roll_lag(x, n = 1L, ...)

## Default S3 method:
roll_lag(x, n = 1L, g = NULL, fill = NULL, ...)

## S3 method for class 'ts'
roll_lag(x, n = 1L, g = NULL, fill = NULL, ...)

## S3 method for class 'zoo'
roll_lag(x, n = 1L, g = NULL, fill = NULL, ...)

roll_diff(x, n = 1L, ...)

## Default S3 method:
roll_diff(x, n = 1L, g = NULL, fill = NULL, differences = 1L, ...)

## S3 method for class 'ts'
roll_diff(x, n = 1L, g = NULL, fill = NULL, differences = 1L, ...)

## S3 method for class 'zoo'
roll_diff(x, n = 1L, g = NULL, fill = NULL, differences = 1L, ...)

diff_(
  x,
  n = 1L,
  differences = 1L,
  order = NULL,
  run_lengths = NULL,
  fill = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="roll_lag_+3A_x">x</code></td>
<td>
<p>A vector or data frame.</p>
</td></tr>
<tr><td><code id="roll_lag_+3A_n">n</code></td>
<td>
<p>Lag. This will be recycled to match the length of x and can be negative.</p>
</td></tr>
<tr><td><code id="roll_lag_+3A_...">...</code></td>
<td>
<p>Arguments passed onto appropriate method.</p>
</td></tr>
<tr><td><code id="roll_lag_+3A_g">g</code></td>
<td>
<p>Grouping vector. This can be a vector, data frame or <code>GRP</code> object.</p>
</td></tr>
<tr><td><code id="roll_lag_+3A_fill">fill</code></td>
<td>
<p>Value to fill the first <code>n</code> elements.</p>
</td></tr>
<tr><td><code id="roll_lag_+3A_differences">differences</code></td>
<td>
<p>Number indicating the number of times to recursively apply
the differencing algorithm. If <code>length(n) == 1</code>, i.e the lag is a scalar integer,
an optimised method is used which avoids recursion entirely.
If <code>length(n) != 1</code> then simply recursion is used.</p>
</td></tr>
<tr><td><code id="roll_lag_+3A_order">order</code></td>
<td>
<p>Optionally specify an ordering with which to
apply the lags/differences.
This is useful for example when applying lags chronologically
using an unsorted time variable.</p>
</td></tr>
<tr><td><code id="roll_lag_+3A_run_lengths">run_lengths</code></td>
<td>
<p>Optional integer vector of run lengths that defines
the size of each lag run. For example, supplying <code>c(5, 5)</code> applies
lags to the first 5 elements and then essentially resets the bounds and
applies lags to the next 5 elements as if
they were an entirely separate and standalone vector. <br />
This is particularly useful in conjunction with the order argument to
perform a by-group lag.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>While these may not be as fast the 'collapse' equivalents,
they are adequately fast and efficient. <br />
A key difference between <code>roll_lag</code> and <code>flag</code> is that <code>g</code> does not need
to be sorted for the result to be correct. <br />
Furthermore, a vector of lags can be supplied for a custom rolling lag.
</p>
<p><code>roll_diff()</code> silently returns <code>NA</code> when there is integer overflow.
Both <code>roll_lag()</code> and <code>roll_diff()</code> apply recursively to list elements.
</p>


<h3>Value</h3>

<p>A vector the same length as <code>x</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(timeplyr)

x &lt;- 1:10

roll_lag(x) # Lag
roll_lag(x, -1) # Lead
roll_diff(x) # Lag diff
roll_diff(x, -1) # Lead diff

# Using cheapr::lag_sequence()
# Differences lagged at 5, first 5 differences are compared to x[1]
roll_diff(x, cheapr::lag_sequence(length(x), 5, partial = TRUE))

# Like diff() but x/y instead of x-y
quotient &lt;- function(x, n = 1L){
  x / roll_lag(x, n)
}
# People often call this a growth rate
# but it's just a percentage difference
# See ?roll_growth_rate for growth rate calculations
quotient(1:10)

</code></pre>

<hr>
<h2 id='roll_na_fill'>Fast grouped &quot;locf&quot; <code>NA</code> fill</h2><span id='topic+roll_na_fill'></span>

<h3>Description</h3>

<p>A fast and efficient by-group method for
&quot;last-observation-carried-forward&quot; <code>NA</code> filling.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>roll_na_fill(x, g = NULL, fill_limit = Inf)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="roll_na_fill_+3A_x">x</code></td>
<td>
<p>A vector.</p>
</td></tr>
<tr><td><code id="roll_na_fill_+3A_g">g</code></td>
<td>
<p>An object use for grouping x
This may be a vector or data frame for example.</p>
</td></tr>
<tr><td><code id="roll_na_fill_+3A_fill_limit">fill_limit</code></td>
<td>
<p>(Optional) maximum number of consecutive NAs to fill
per <code>NA</code> cluster. Default is <code>Inf</code>.</p>
</td></tr>
</table>


<h3>Details</h3>



<h4>Method</h4>

<p>When supplying groups using <code>g</code>, this method uses <code>radixorder(g)</code> to
specify how to loop through <code>x</code>, making this extremely efficient.
</p>
<p>When <code>x</code> contains zero or all <code>NA</code> values, then <code>x</code> is returned with no copy
made.
</p>



<h3>Value</h3>

<p>A filled vector of <code>x</code> the same length as <code>x</code>.
</p>

<hr>
<h2 id='roll_sum'>Fast by-group rolling functions</h2><span id='topic+roll_sum'></span><span id='topic+roll_mean'></span><span id='topic+roll_geometric_mean'></span><span id='topic+roll_harmonic_mean'></span><span id='topic+roll_growth_rate'></span>

<h3>Description</h3>

<p>An efficient method for rolling sum, mean and growth rate for many groups.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>roll_sum(
  x,
  window = Inf,
  g = NULL,
  partial = TRUE,
  weights = NULL,
  na.rm = TRUE,
  ...
)

roll_mean(
  x,
  window = Inf,
  g = NULL,
  partial = TRUE,
  weights = NULL,
  na.rm = TRUE,
  ...
)

roll_geometric_mean(
  x,
  window = Inf,
  g = NULL,
  partial = TRUE,
  weights = NULL,
  na.rm = TRUE,
  ...
)

roll_harmonic_mean(
  x,
  window = Inf,
  g = NULL,
  partial = TRUE,
  weights = NULL,
  na.rm = TRUE,
  ...
)

roll_growth_rate(
  x,
  window = Inf,
  g = NULL,
  partial = TRUE,
  na.rm = FALSE,
  log = FALSE,
  inf_fill = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="roll_sum_+3A_x">x</code></td>
<td>
<p>Numeric vector, data frame, or list.</p>
</td></tr>
<tr><td><code id="roll_sum_+3A_window">window</code></td>
<td>
<p>Rolling window size, default is <code>Inf</code>.</p>
</td></tr>
<tr><td><code id="roll_sum_+3A_g">g</code></td>
<td>
<p>Grouping object passed directly to <code>collapse::GRP()</code>.
This can for example be a vector or data frame.</p>
</td></tr>
<tr><td><code id="roll_sum_+3A_partial">partial</code></td>
<td>
<p>Should calculations be done using partial windows?
Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="roll_sum_+3A_weights">weights</code></td>
<td>
<p>Importance weights. Must be the same length as x.
Currently, no normalisation of weights occurs.</p>
</td></tr>
<tr><td><code id="roll_sum_+3A_na.rm">na.rm</code></td>
<td>
<p>Should missing values be removed for the calculation?
The default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="roll_sum_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code>data.table::frollmean</code> and
<code>data.table::frollsum</code>.</p>
</td></tr>
<tr><td><code id="roll_sum_+3A_log">log</code></td>
<td>
<p>For <code>roll_growth_rate</code>:
If <code>TRUE</code> then growth rates are calculated on the log-scale.</p>
</td></tr>
<tr><td><code id="roll_sum_+3A_inf_fill">inf_fill</code></td>
<td>
<p>For <code>roll_growth_rate</code>:
Numeric value to replace <code>Inf</code> values with.
Default behaviour is to keep <code>Inf</code> values.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>roll_sum</code> and <code>roll_mean</code> support parallel computations when
<code>x</code> is a data frame of multiple columns. <br />
<code>roll_geometric_mean</code> and <code>roll_harmonic_mean</code> are convenience functions that
utilise <code>roll_mean</code>. <br />
<code>roll_growth_rate</code> calculates the rate of percentage
change per unit time on a rolling basis.
</p>


<h3>Value</h3>

<p>A numeric vector the same length as <code>x</code> when <code>x</code> is a vector,
or a list when <code>x</code> is a <code>data.frame</code>. <br />
</p>


<h3>See Also</h3>

<p><a href="#topic+time_roll_mean">time_roll_mean</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(timeplyr)

x &lt;- 1:10
roll_sum(x) # Simple rolling total
roll_mean(x) # Simple moving average
roll_sum(x, window = 3)
roll_mean(x, window = 3)
roll_sum(x, window = 3, partial = FALSE)
roll_mean(x, window = 3, partial = FALSE)

# Plot of expected value of 'coin toss' over many flips
set.seed(42)
x &lt;- sample(c(1, 0), 10^3, replace = TRUE)
ev &lt;- roll_mean(x)
plot(ev)
abline(h = 0.5, lty = 2)

all.equal(roll_sum(iris$Sepal.Length, g = iris$Species),
          ave(iris$Sepal.Length, iris$Species, FUN = cumsum))
# The below is run using parallel computations where applicable
roll_sum(iris[, 1:4], window = 7, g = iris$Species)

  library(data.table)
  library(bench)
  df &lt;- data.table(g = sample.int(10^4, 10^5, TRUE),
                   x = rnorm(10^5))
  mark(e1 = df[, mean := frollmean(x, n = 7,
                                   align = "right", na.rm = FALSE), by = "g"]$mean,
       e2 = df[, mean := roll_mean(x, window = 7, g = get("g"),
                                   partial = FALSE, na.rm = FALSE)]$mean)


</code></pre>

<hr>
<h2 id='time_add'>Add/subtract timespans to dates and date-times</h2><span id='topic+time_add'></span><span id='topic+time_subtract'></span><span id='topic+time_floor'></span><span id='topic+time_ceiling'></span>

<h3>Description</h3>

<p>A very fast method of adding time units to dates and date-times.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>time_add(
  x,
  timespan,
  roll_month = getOption("timeplyr.roll_month", "xlast"),
  roll_dst = getOption("timeplyr.roll_dst", c("NA", "xfirst"))
)

time_subtract(
  x,
  timespan,
  roll_month = getOption("timeplyr.roll_month", "xlast"),
  roll_dst = getOption("timeplyr.roll_dst", c("NA", "xfirst"))
)

time_floor(x, timespan, week_start = getOption("lubridate.week.start", 1))

time_ceiling(
  x,
  timespan,
  week_start = getOption("lubridate.week.start", 1),
  change_on_boundary = is_date(x)
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="time_add_+3A_x">x</code></td>
<td>
<p>Time vector. <br />
E.g. a <code>Date</code>, <code>POSIXt</code>, <code>numeric</code> or any time-based vector.</p>
</td></tr>
<tr><td><code id="time_add_+3A_timespan">timespan</code></td>
<td>
<p><a href="#topic+timespan">timespan</a>.</p>
</td></tr>
<tr><td><code id="time_add_+3A_roll_month">roll_month</code></td>
<td>
<p>See <code>?timechange::time_add</code>. Additional choices
include <code>xlast</code> (default) and <code>xfirst</code>. These work conceptually similar to
skipped DST intervals.</p>
</td></tr>
<tr><td><code id="time_add_+3A_roll_dst">roll_dst</code></td>
<td>
<p>See <code>?timechange::time_add</code>.</p>
</td></tr>
<tr><td><code id="time_add_+3A_week_start">week_start</code></td>
<td>
<p>day on which week starts following ISO conventions - 1
means Monday, 7 means Sunday (default). When <code>label = TRUE</code>,
this will be the first level of the returned factor.
You can set <code>lubridate.week.start</code> option to control this parameter globally.</p>
</td></tr>
<tr><td><code id="time_add_+3A_change_on_boundary">change_on_boundary</code></td>
<td>
<p><code>?timechange::time_floor</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The methods are continuously being improved over time.
Date arithmetic should be very fast regardless of the timespan supplied.
Date-time arithmetic, specifically
when supplied days, weeks, months and years, is being improved.
</p>


<h3>Value</h3>

<p>A date, date-time, or other time-based vector.
</p>

<hr>
<h2 id='time_by'>Group by a time variable at a higher time unit</h2><span id='topic+time_by'></span><span id='topic+time_tbl_time_col'></span>

<h3>Description</h3>

<p><code>time_by</code> groups a time variable by a specified time unit like
for example &quot;days&quot; or &quot;weeks&quot;. <br />
It can be used exactly like <code>dplyr::group_by</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>time_by(data, time, width = NULL, .name = NULL, .add = TRUE)

time_tbl_time_col(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="time_by_+3A_data">data</code></td>
<td>
<p>A data frame.</p>
</td></tr>
<tr><td><code id="time_by_+3A_time">time</code></td>
<td>
<p>Time variable (<b>data-masking</b>). <br />
E.g., a <code>Date</code>, <code>POSIXt</code>, <code>numeric</code> or any time variable.</p>
</td></tr>
<tr><td><code id="time_by_+3A_width">width</code></td>
<td>
<p>A <a href="#topic+timespan">timespan</a>.</p>
</td></tr>
<tr><td><code id="time_by_+3A_.name">.name</code></td>
<td>
<p>An optional glue specification passed to <code>stringr::glue()</code>
which can be used to concatenate
strings to the time column name or replace it.</p>
</td></tr>
<tr><td><code id="time_by_+3A_.add">.add</code></td>
<td>
<p>Should the time groups be added to existing groups?
Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="time_by_+3A_x">x</code></td>
<td>
<p>A <code>time_tbl_df</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>time_tbl_df</code> which for practical purposes can be treated the
same way as a dplyr <code>grouped_df</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
library(timeplyr)
library(fastplyr)
library(nycflights13)
library(lubridate)

# Basic usage
hourly_flights &lt;- flights %&gt;%
  time_by(time_hour) # Detects time granularity

hourly_flights

monthly_flights &lt;- flights %&gt;%
  time_by(time_hour, "month")
weekly_flights &lt;- flights %&gt;%
  time_by(time_hour, "week")

monthly_flights %&gt;%
  f_count()

weekly_flights %&gt;%
  f_summarise(n = n(), arr_delay = mean(arr_delay, na.rm = TRUE))

# To aggregate multiple variables, use time_aggregate

flights %&gt;%
  f_count(week = time_cut_width(time_hour, months(3)))
</code></pre>

<hr>
<h2 id='time_cut'>Cut dates and datetimes into regularly spaced date or datetime intervals</h2><span id='topic+time_cut'></span><span id='topic+time_cut_n'></span><span id='topic+time_cut_width'></span><span id='topic+time_breaks'></span>

<h3>Description</h3>

<p>Useful functions especially for when plotting time-series.
<code>time_cut</code> makes approximately <code>n</code> groups of equal time range.
It prioritises the highest time unit possible, making axes look
less cluttered and thus prettier.
<code>time_breaks</code> returns only the breaks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>time_cut(
  x,
  n = 5,
  timespan = NULL,
  from = NULL,
  to = NULL,
  time_floor = FALSE,
  week_start = getOption("lubridate.week.start", 1)
)

time_cut_n(
  x,
  n = 5,
  timespan = NULL,
  from = NULL,
  to = NULL,
  time_floor = FALSE,
  week_start = getOption("lubridate.week.start", 1)
)

time_cut_width(x, timespan = granularity(x), from = NULL, to = NULL)

time_breaks(
  x,
  n = 5,
  timespan = NULL,
  from = NULL,
  to = NULL,
  time_floor = FALSE,
  week_start = getOption("lubridate.week.start", 1)
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="time_cut_+3A_x">x</code></td>
<td>
<p>Time vector. <br />
E.g. a <code>Date</code>, <code>POSIXt</code>, <code>numeric</code> or any time-based vector.</p>
</td></tr>
<tr><td><code id="time_cut_+3A_n">n</code></td>
<td>
<p>Number of breaks.</p>
</td></tr>
<tr><td><code id="time_cut_+3A_timespan">timespan</code></td>
<td>
<p><a href="#topic+timespan">timespan</a>.</p>
</td></tr>
<tr><td><code id="time_cut_+3A_from">from</code></td>
<td>
<p>Start time.</p>
</td></tr>
<tr><td><code id="time_cut_+3A_to">to</code></td>
<td>
<p>End time.</p>
</td></tr>
<tr><td><code id="time_cut_+3A_time_floor">time_floor</code></td>
<td>
<p>Logical. Should the initial date/datetime be
floored before building the sequence?</p>
</td></tr>
<tr><td><code id="time_cut_+3A_week_start">week_start</code></td>
<td>
<p>day on which week starts following ISO conventions - 1
means Monday (default), 7 means Sunday.
This is only used when <code>time_floor = TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>To retrieve regular time breaks that simply spans the range of <code>x</code>,
use <code>time_seq()</code> or <code>time_aggregate()</code>.
This can also be achieved in <code>time_cut()</code> by supplying <code>n = Inf</code>.
</p>
<p>By default <code>time_cut()</code> will try to find
the prettiest way of cutting the interval by
trying to cut the date/date-times into
groups of the highest possible time units,
starting at years and ending at milliseconds.
</p>
<p>When <code>x</code> is a numeric vector, <code>time_cut</code> will behave similar to <code>time_cut</code>
except for 3 things:
</p>

<ul>
<li><p> The intervals are all right-open and of equal width.
</p>
</li>
<li><p> The left value of the leftmost interval is always <code>min(x)</code>.
</p>
</li>
<li><p> Up to <code>n</code> breaks are created, i.e <code style="white-space: pre;">&#8288;&lt;= n&#8288;</code> breaks. This is to prioritise
pretty breaks.
</p>
</li></ul>



<h3>Value</h3>

<p><code>time_breaks</code> returns a vector of breaks. <br />
<code>time_cut</code> returns either a vector or <code>time_interval</code>. <br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(timeplyr)
library(fastplyr)
library(cheapr)
library(lubridate)
library(ggplot2)
library(dplyr)

time_cut_n(1:10, n = 5)

# Easily create custom time breaks
df &lt;- nycflights13::flights %&gt;%
  f_slice_sample(n = 100) %&gt;%
  with_local_seed(.seed = 8192821) %&gt;%
  f_select(time_hour) %&gt;%
  fastplyr::f_arrange(time_hour) %&gt;%
  mutate(date = as_date(time_hour))

# time_cut_n() and time_breaks() automatically find a
# suitable way to cut the data
time_cut_n(df$date) %&gt;%
  interval_count()
# Works with datetimes as well
time_cut_n(df$time_hour, n = 5) %&gt;%
  interval_count()
time_cut_n(df$date, timespan = "month") %&gt;%
  interval_count()
# Just the breaks
time_breaks(df$date, n = 5, timespan = "month")

cut_dates &lt;- time_cut_n(df$date)
date_breaks &lt;- time_breaks(df$date)

# When n = Inf it should be equivalent to using time_cut_width
identical(time_cut_n(df$date, n = Inf, "month"),
          time_cut_width(df$date, "month"))
# To get exact breaks at regular intervals, use time_grid
weekly_breaks &lt;- time_grid(
  df$date, "5 weeks",
  from = floor_date(min(df$date), "week", week_start = 1)
)
weekly_labels &lt;- format(weekly_breaks, "%b-%d")
df %&gt;%
  time_by(date, "week", .name = "date") %&gt;%
  f_count() %&gt;%
  mutate(date = interval_start(date)) %&gt;%
  ggplot(aes(x = date, y = n)) +
  geom_bar(stat = "identity") +
  scale_x_date(breaks = weekly_breaks,
               labels = weekly_labels)
</code></pre>

<hr>
<h2 id='time_diff'>Time differences by any time unit</h2><span id='topic+time_diff'></span>

<h3>Description</h3>

<p>The time difference between 2 date or date-time vectors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>time_diff(x, y, timespan = 1L)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="time_diff_+3A_x">x</code></td>
<td>
<p>Start date or datetime.</p>
</td></tr>
<tr><td><code id="time_diff_+3A_y">y</code></td>
<td>
<p>End date or datetime.</p>
</td></tr>
<tr><td><code id="time_diff_+3A_timespan">timespan</code></td>
<td>
<p>A <a href="#topic+timespan">timespan</a> used to divide the difference.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector recycled to the length of <code>max(length(x), length(y))</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(timeplyr)
library(lubridate)
time_diff(today(), today() + days(10), "days")
time_diff(today(), today() + days((0:3) * 7), weeks(1))
time_diff(today(), today() + days(100), timespan("days", 1:100))
time_diff(1, 1 + 0:100, 3)

</code></pre>

<hr>
<h2 id='time_elapsed'>Fast grouped time elapsed</h2><span id='topic+time_elapsed'></span>

<h3>Description</h3>

<p>Calculate how much time has passed
on a rolling or cumulative basis. <br />
</p>


<h3>Usage</h3>

<pre><code class='language-R'>time_elapsed(
  x,
  timespan = granularity(x),
  g = NULL,
  rolling = TRUE,
  fill = NA,
  na_skip = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="time_elapsed_+3A_x">x</code></td>
<td>
<p>Time vector. <br />
E.g. a <code>Date</code>, <code>POSIXt</code>, <code>numeric</code> or any time-based vector.</p>
</td></tr>
<tr><td><code id="time_elapsed_+3A_timespan">timespan</code></td>
<td>
<p><a href="#topic+timespan">timespan</a>.</p>
</td></tr>
<tr><td><code id="time_elapsed_+3A_g">g</code></td>
<td>
<p>Object to be used for grouping <code>x</code>, passed onto <code>collapse::GRP()</code>.</p>
</td></tr>
<tr><td><code id="time_elapsed_+3A_rolling">rolling</code></td>
<td>
<p>If <code>TRUE</code> (the default) then lagged
time differences are calculated on a rolling basis,
essentially like <code>diff()</code>. <br />
If <code>FALSE</code> then time differences compared to the index (first) time
are calculated.</p>
</td></tr>
<tr><td><code id="time_elapsed_+3A_fill">fill</code></td>
<td>
<p>When <code>rolling = TRUE</code>, this is the value that fills
the first elapsed time. The default is <code>NA</code>.</p>
</td></tr>
<tr><td><code id="time_elapsed_+3A_na_skip">na_skip</code></td>
<td>
<p>Should <code>NA</code> values be skipped? Default is <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>time_elapsed()</code> is quite efficient when there are many groups,
especially if your data is sorted in order of those groups.
In the case that <code>g</code> is supplied, it is most efficient when your data is
sorted by <code>g</code> .
When <code>na_skip</code> is <code>TRUE</code> and <code>rolling</code> is also <code>TRUE</code>, <code>NA</code> values are simply
skipped and hence the time differences between the current value and the
previous non-NA value are calculated. For example,
<code>c(3, 4, 6, NA, NA, 9)</code> becomes <code>c(NA, 1, 2, NA, NA, 3)</code>. <br />
When <code>na_skip</code> is <code>TRUE</code> and <code>rolling</code> is <code>FALSE</code>, time differences between
the current value and the first non-NA value of the series are calculated.
For example,
<code>c(NA, NA, 3, 4, 6, NA, 8)</code> becomes <code>c(NA, NA, 0, 1, 3, NA, 5)</code>.
</p>


<h3>Value</h3>

<p>A numeric vector the same length as <code>x</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(timeplyr)
library(dplyr)
library(lubridate)

x &lt;- time_seq(today(), length.out = 25, time = "3 days")
time_elapsed(x)
time_elapsed(x, "days", rolling = FALSE)

# Grouped example
set.seed(99)
g &lt;- sample.int(3, 25, TRUE)

time_elapsed(x, "days", g = g)

</code></pre>

<hr>
<h2 id='time_episodes'>Episodic calculation of time-since-event data</h2><span id='topic+time_episodes'></span>

<h3>Description</h3>

<p>This function assigns episodes to events
based on a pre-defined threshold of a chosen time unit.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>time_episodes(
  data,
  time,
  time_by = NULL,
  window = 1,
  roll_episode = TRUE,
  switch_on_boundary = TRUE,
  fill = 0,
  .add = FALSE,
  event = NULL,
  .by = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="time_episodes_+3A_data">data</code></td>
<td>
<p>A data frame.</p>
</td></tr>
<tr><td><code id="time_episodes_+3A_time">time</code></td>
<td>
<p>Date or datetime variable to use for the episode calculation.
Supply the variable using <code>tidyselect</code> notation.</p>
</td></tr>
<tr><td><code id="time_episodes_+3A_time_by">time_by</code></td>
<td>
<p>Time units used to calculate episode flags.
If <code>time_by</code> is <code>NULL</code> then a heuristic will try and estimate the highest
order time unit associated with the time variable.
If specified, then by must be one of the three:
</p>

<ul>
<li><p> string, specifying either the unit or the number and unit, e.g
<code>time_by = "days"</code> or <code>time_by = "2 weeks"</code>
</p>
</li>
<li><p> named list of length one, the unit being the name, and
the number the value of the list, e.g. <code>list("days" = 7)</code>.
For the vectorized time functions, you can supply multiple values,
e.g. <code>list("days" = 1:10)</code>.
</p>
</li>
<li><p> Numeric vector. If by is a numeric vector and x is not a date/datetime,
then arithmetic is used, e.g <code>time_by = 1</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="time_episodes_+3A_window">window</code></td>
<td>
<p>Single number defining the episode threshold.
When <code>rolling = TRUE</code> events with a
<code>t_elapsed &gt;= window</code> since the last event
are defined as a new episode. <br />
When <code>rolling = FALSE</code> events with a
<code>t_elapsed &gt;= window</code> since the first event of the corresponding episode
are defined as a new episode. <br />
By default, <code>window = 1</code> which assigns every event to a new episode.</p>
</td></tr>
<tr><td><code id="time_episodes_+3A_roll_episode">roll_episode</code></td>
<td>
<p>Logical.
Should episodes be calculated using a rolling or fixed window?
If <code>TRUE</code> (the default), an amount of time must have passed (<code style="white-space: pre;">&#8288;&gt;= window&#8288;</code>)
since the last event, with each new event
effectively resetting the time at which
you start counting. <br />
If <code>FALSE</code>, the elapsed time is fixed and
new episodes are defined based on how much cumulative time has
passed since the first event of each episode.</p>
</td></tr>
<tr><td><code id="time_episodes_+3A_switch_on_boundary">switch_on_boundary</code></td>
<td>
<p>When an exact amount of time
(specified in <code>time_by</code>) has passed, should there be an increment in ID? <br />
The default is <code>TRUE</code>. <br />
For example, if <code>time_by = "days"</code> and
<code>switch_on_boundary = FALSE</code>, <code style="white-space: pre;">&#8288;&gt; 1&#8288;</code> day must have passed, otherwise
<code style="white-space: pre;">&#8288;&gt;= 1&#8288;</code> day must have passed.</p>
</td></tr>
<tr><td><code id="time_episodes_+3A_fill">fill</code></td>
<td>
<p>Value to fill first time elapsed value. Only applicable when
<code>roll_episode = TRUE</code>. <br />
Default is <code>0</code>.</p>
</td></tr>
<tr><td><code id="time_episodes_+3A_.add">.add</code></td>
<td>
<p>Should episodic variables be added to the data? <br />
If <code>FALSE</code> (the default), then only the relevant variables are returned. <br />
If <code>TRUE</code>, the episodic variables are added to the original data.
In both cases, the order of the data is unchanged.</p>
</td></tr>
<tr><td><code id="time_episodes_+3A_event">event</code></td>
<td>
<p>(<b>Optional</b>) List that encodes which rows are events,
and which aren't.
By default <code>time_episodes()</code>
assumes every observation (row) is an event
but this need not be the case. <br />
<code>event</code> must be a named list of length 1 where the values of the
list element represent the event. For example, if your events were coded as
<code>0</code> and <code>1</code> in a variable named &quot;evt&quot; where <code>1</code> represents the event,
you would supply <code>event = list(evt = 1)</code>.</p>
</td></tr>
<tr><td><code id="time_episodes_+3A_.by">.by</code></td>
<td>
<p>(Optional). A selection of columns to group by for this operation.
Columns are specified using <code>tidyselect</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>time_episodes()</code> calculates the time elapsed (rolling or fixed) between
successive events, and flags these events as episodes or not based on how much
time has passed.
</p>
<p>An example of episodic analysis can include disease infections over time.
</p>
<p>In this example, a positive test result represents an <b>event</b> and <br />
a new infection represents a new <b>episode</b>.
</p>
<p>It is assumed that after a pre-determined amount of time, a positive result
represents a new episode of infection.
</p>
<p>To perform simple time-since-event analysis, which means one
is not interested in episodes, simply use <code>time_elapsed()</code> instead.
</p>
<p>To find implicit missing gaps in time, set <code>window</code> to <code>1</code> and
<code>switch_on_boundary</code> to <code>FALSE</code>. Any event classified as an
episode in this scenario is an event following a gap in time.
</p>
<p>The data are always sorted before calculation and then
sorted back to the input order.
</p>
<p>4 Key variables will be calculated:
</p>

<ul>
<li> <p><b>ep_id</b> - An integer variable signifying
which episode each event belongs to. <br />
Non-events are assigned <code>NA</code>. <br />
<code>ep_id</code> is an increasing integer starting at 1.
In the infections scenario, 1 are positives within the
first episode of infection,
2 are positives within the second episode of infection and so on.
</p>
</li>
<li> <p><b>ep_id_new</b> - An integer variable signifying the first
instance of each new episode.
This is an increasing integer where
0 signifies within-episode observations and &gt;= 1
signifies the first instance of the respective episode.
</p>
</li>
<li> <p><b>t_elapsed</b> - The time elapsed since the last event. <br />
When <code>roll_episode = FALSE</code>, this becomes the time elapsed since the
first event of the current episode.
Time units are specified in the by argument.
</p>
</li>
<li> <p><b>ep_start</b> - Start date/datetime of the episode.
</p>
</li></ul>

<p><code>data.table</code> and <code>collapse</code> are used for speed and efficiency.
</p>


<h3>Value</h3>

<p>A <code>data.frame</code> in the same order as it was given.
</p>


<h3>See Also</h3>

<p><a href="#topic+time_elapsed">time_elapsed</a> <a href="#topic+time_seq_id">time_seq_id</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(timeplyr)
library(dplyr)
library(nycflights13)
library(lubridate)
library(ggplot2)

# Say we want to flag origin-destination pairs
# that haven't seen departures or arrivals for a week

events &lt;- flights %&gt;%
  mutate(date = as_date(time_hour)) %&gt;%
  group_by(origin, dest) %&gt;%
  time_episodes(date, "week", window = 1)

events

episodes &lt;- events %&gt;%
  filter(ep_id_new &gt; 1)
nrow(fastplyr::f_distinct(episodes, origin, dest)) # 55 origin-destinations

# As expected summer months saw the least number of
# dry-periods
episodes %&gt;%
  ungroup() %&gt;%
  time_by(ep_start, "week", .name = "ep_start") %&gt;%
  count(ep_start = interval_start(ep_start)) %&gt;%
  ggplot(aes(x = ep_start, y = n)) +
  geom_bar(stat = "identity")

</code></pre>

<hr>
<h2 id='time_expand'>A time based extension to <code>tidyr::complete()</code>.</h2><span id='topic+time_expand'></span><span id='topic+time_complete'></span>

<h3>Description</h3>

<p>A time based extension to <code>tidyr::complete()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>time_expand(
  data,
  time = NULL,
  ...,
  .by = NULL,
  time_by = NULL,
  from = NULL,
  to = NULL,
  sort = TRUE
)

time_complete(
  data,
  time = NULL,
  ...,
  .by = NULL,
  time_by = NULL,
  from = NULL,
  to = NULL,
  sort = TRUE,
  fill = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="time_expand_+3A_data">data</code></td>
<td>
<p>A data frame.</p>
</td></tr>
<tr><td><code id="time_expand_+3A_time">time</code></td>
<td>
<p>Time variable.</p>
</td></tr>
<tr><td><code id="time_expand_+3A_...">...</code></td>
<td>
<p>Groups to expand.</p>
</td></tr>
<tr><td><code id="time_expand_+3A_.by">.by</code></td>
<td>
<p>(Optional). A selection of columns to group by for this operation.
Columns are specified using tidy-select.</p>
</td></tr>
<tr><td><code id="time_expand_+3A_time_by">time_by</code></td>
<td>
<p>A <a href="#topic+timespan">timespan</a>.</p>
</td></tr>
<tr><td><code id="time_expand_+3A_from">from</code></td>
<td>
<p>Time series start date.</p>
</td></tr>
<tr><td><code id="time_expand_+3A_to">to</code></td>
<td>
<p>Time series end date.</p>
</td></tr>
<tr><td><code id="time_expand_+3A_sort">sort</code></td>
<td>
<p>Logical. If <code>TRUE</code> expanded/completed variables are sorted.</p>
</td></tr>
<tr><td><code id="time_expand_+3A_fill">fill</code></td>
<td>
<p>A named list containing value-name pairs to fill
the named implicit missing values.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This works much the same as <code>tidyr::complete()</code>, except that
you can supply an additional <code>time</code> argument to allow for
completing implicit time gaps and creating time sequences by group.
</p>


<h3>Value</h3>

<p>A <code>data.frame</code> of expanded time by or across groups.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(timeplyr)
library(dplyr)
library(lubridate)
library(nycflights13)

x &lt;- flights$time_hour

time_num_gaps(x) # Missing hours

flights_count &lt;- flights %&gt;%
  fastplyr::f_count(time_hour)

# Fill in missing hours
flights_count %&gt;%
  time_complete(time = time_hour)

# You can specify units too
flights_count %&gt;%
  time_complete(time = time_hour, time_by = "hours")
flights_count %&gt;%
  time_complete(time = as_date(time_hour), time_by = "days") #  Nothing to complete here

# Where time_expand() and time_complete() really shine is how fast they are with groups
flights %&gt;%
  group_by(origin, dest) %&gt;%
  time_expand(time = time_hour, time_by = dweeks(1))

</code></pre>

<hr>
<h2 id='time_gaps'>Gaps in a regular time sequence</h2><span id='topic+time_gaps'></span><span id='topic+time_num_gaps'></span><span id='topic+time_has_gaps'></span>

<h3>Description</h3>

<p><code>time_gaps()</code> checks for implicit missing gaps in time for any
regular date or datetime sequence.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>time_gaps(
  x,
  timespan = granularity(x),
  g = NULL,
  use.g.names = TRUE,
  check_time_regular = FALSE
)

time_num_gaps(
  x,
  timespan = granularity(x),
  g = NULL,
  use.g.names = TRUE,
  na.rm = TRUE,
  check_time_regular = FALSE
)

time_has_gaps(
  x,
  timespan = granularity(x),
  g = NULL,
  use.g.names = TRUE,
  na.rm = TRUE,
  check_time_regular = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="time_gaps_+3A_x">x</code></td>
<td>
<p>Time vector. <br />
E.g. a <code>Date</code>, <code>POSIXt</code>, <code>numeric</code> or any time-based vector.</p>
</td></tr>
<tr><td><code id="time_gaps_+3A_timespan">timespan</code></td>
<td>
<p><a href="#topic+timespan">timespan</a>.</p>
</td></tr>
<tr><td><code id="time_gaps_+3A_g">g</code></td>
<td>
<p>Grouping object passed directly to <code>collapse::GRP()</code>.
This can for example be a vector or data frame.</p>
</td></tr>
<tr><td><code id="time_gaps_+3A_use.g.names">use.g.names</code></td>
<td>
<p>Should the result include group names?
Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="time_gaps_+3A_check_time_regular">check_time_regular</code></td>
<td>
<p>Should the time vector be
checked to see if it is regular (with or without gaps)?
Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="time_gaps_+3A_na.rm">na.rm</code></td>
<td>
<p>Should <code>NA</code> values be removed? Default is <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When <code>check_time_regular</code> is TRUE, <code>x</code> is passed to
<code>time_is_regular</code>, which checks that the time elapsed between successive
values are in increasing order and are whole numbers.
For more strict checks, see <code>?time_is_regular</code>.
</p>


<h3>Value</h3>

<p><code>time_gaps</code> returns a vector of time gaps. <br />
<code>time_num_gaps</code> returns the number of time gaps. <br />
<code>time_has_gaps</code> returns a logical(1) of whether there are gaps.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(timeplyr)
library(fastplyr)
library(lubridate)
library(nycflights13)
missing_dates(flights$time_hour)
time_has_gaps(flights$time_hour)
time_num_gaps(flights$time_hour)
length(time_gaps(flights$time_hour))
time_num_gaps(flights$time_hour, g = flights$origin)

# Number of missing hours by origin and dest
flights %&gt;%
  f_group_by(origin, dest) %&gt;%
  f_summarise(n_missing = time_num_gaps(time_hour, "hours"))

</code></pre>

<hr>
<h2 id='time_ggplot'>Quick time-series ggplot</h2><span id='topic+time_ggplot'></span>

<h3>Description</h3>

<p><code>time_ggplot()</code> is a neat way to quickly
plot aggregate time-series data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>time_ggplot(
  data,
  time,
  value,
  group = NULL,
  facet = FALSE,
  geom = ggplot2::geom_line,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="time_ggplot_+3A_data">data</code></td>
<td>
<p>A data frame</p>
</td></tr>
<tr><td><code id="time_ggplot_+3A_time">time</code></td>
<td>
<p>Time variable using <code>tidyselect</code>.</p>
</td></tr>
<tr><td><code id="time_ggplot_+3A_value">value</code></td>
<td>
<p>Value variable using <code>tidyselect</code>.</p>
</td></tr>
<tr><td><code id="time_ggplot_+3A_group">group</code></td>
<td>
<p>(Optional) Group variable using <code>tidyselect</code>.</p>
</td></tr>
<tr><td><code id="time_ggplot_+3A_facet">facet</code></td>
<td>
<p>When groups are supplied, should multi-series be
plotted separately or on the same plot?
Default is <code>FALSE</code>, or together.</p>
</td></tr>
<tr><td><code id="time_ggplot_+3A_geom">geom</code></td>
<td>
<p><code>ggplot2</code> 'geom' type. Default is <code>geom_line()</code>.</p>
</td></tr>
<tr><td><code id="time_ggplot_+3A_...">...</code></td>
<td>
<p>Further arguments passed to the chosen 'geom'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>ggplot</code>.
</p>


<h3>See Also</h3>

<p><a href="#topic+ts_as_tbl">ts_as_tbl</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
library(timeplyr)
library(ggplot2)
library(lubridate)

# It's as easy as this
AirPassengers %&gt;%
  ts_as_tbl() %&gt;%
  time_ggplot(time, value)

# And this
EuStockMarkets %&gt;%
  ts_as_tbl() %&gt;%
  time_ggplot(time, value, group)

# Converting this to monthly averages

EuStockMarkets %&gt;%
  ts_as_tbl() %&gt;%
  mutate(month = year_month_decimal(time)) %&gt;%
  summarise(avg = mean(value),
            .by = c(group, month)) %&gt;%
  time_ggplot(month, avg, group)

# zoo example
x.Date &lt;- as.Date("2003-02-01") + c(1, 3, 7, 9, 14) - 1
x &lt;- zoo::zoo(rnorm(5), x.Date)
x %&gt;%
  ts_as_tbl() %&gt;%
  time_ggplot(time, value)

</code></pre>

<hr>
<h2 id='time_grid'>Vector date and datetime functions</h2><span id='topic+time_grid'></span><span id='topic+time_complete_missing'></span><span id='topic+time_grid_size'></span>

<h3>Description</h3>

<p>These are atomic vector-based functions
of the tidy equivalents which all have a &quot;v&quot; suffix to denote this.
These are more geared towards programmers and allow for working with date and
datetime vectors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>time_grid(x, timespan = granularity(x), from = NULL, to = NULL)

time_complete_missing(x, timespan = granularity(x))

time_grid_size(x, timespan = granularity(x), from = NULL, to = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="time_grid_+3A_x">x</code></td>
<td>
<p>Time vector. <br />
E.g. a <code>Date</code>, <code>POSIXt</code>, <code>numeric</code> or any time-based vector.</p>
</td></tr>
<tr><td><code id="time_grid_+3A_timespan">timespan</code></td>
<td>
<p><a href="#topic+timespan">timespan</a>.</p>
</td></tr>
<tr><td><code id="time_grid_+3A_from">from</code></td>
<td>
<p>Start time.</p>
</td></tr>
<tr><td><code id="time_grid_+3A_to">to</code></td>
<td>
<p>End time.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vectors (typically the same class as <code>x</code>) of varying lengths depending
on the arguments supplied.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(timeplyr)
library(dplyr)
library(lubridate)
library(nycflights13)
x &lt;- unique(flights$time_hour)

# Number of missing hours
time_num_gaps(x)

# Same as above
time_grid_size(x) - length(unique(x))

# Time sequence that spans the data
length(time_grid(x)) # Automatically detects hour granularity
time_grid(x, "month")
time_grid(x, from = floor_date(min(x), "month"), to = today(),
          timespan = timespan("month"))

# Complete missing gaps in time using time_complete
y &lt;- time_complete_missing(x, "hour")
identical(y[!y %in% x], time_gaps(x))

# Summarise time into higher intervals
quarters &lt;- time_cut_width(y, "quarter")
interval_count(quarters)

</code></pre>

<hr>
<h2 id='time_id'>Time ID</h2><span id='topic+time_id'></span>

<h3>Description</h3>

<p>Generate a time ID that signifies how many time steps away
a time value is from the starting time point or more intuitively,
this is the time passed since
the first time point.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>time_id(x, timespan = granularity(x), g = NULL, na_skip = TRUE, shift = 1L)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="time_id_+3A_x">x</code></td>
<td>
<p>Time vector. <br />
E.g. a <code>Date</code>, <code>POSIXt</code>, <code>numeric</code> or any time-based vector.</p>
</td></tr>
<tr><td><code id="time_id_+3A_timespan">timespan</code></td>
<td>
<p><a href="#topic+timespan">timespan</a>.</p>
</td></tr>
<tr><td><code id="time_id_+3A_g">g</code></td>
<td>
<p>Object used for grouping x.
This can for example be a vector or data frame.
<code>g</code> is passed directly to <code>collapse::GRP()</code>.</p>
</td></tr>
<tr><td><code id="time_id_+3A_na_skip">na_skip</code></td>
<td>
<p>Should <code>NA</code> values be skipped? Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="time_id_+3A_shift">shift</code></td>
<td>
<p>Value used to shift the time IDs. Typically this is 1 to ensure the
IDs start at 1 but can be 0 or even negative if for example
your time values are going backwards in time.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is heavily inspired by <code>collapse::timeid</code> but differs in 3 ways:
</p>

<ul>
<li><p> The time steps need not be the greatest common divisor of successive
differences
</p>
</li>
<li><p> The starting time point may not necessarily
be the earliest chronologically and thus <code>time_id</code> can generate negative IDs.
</p>
</li>
<li> <p><code>g</code> can be supplied to calculate IDs by group.
</p>
</li></ul>

<p><code>time_id(c(3, 2, 1))</code> is not the same as <code>collapse::timeid(c(3, 2, 1))</code>.
In general <code>time_id(sort(x))</code>
should be equal to  <code>collapse::timeid(sort(x))</code>.
The time difference GCD is always calculated using all the data and not
by-group.
</p>


<h3>Value</h3>

<p>An integer vector the same length as <code>x</code>.
</p>


<h3>See Also</h3>

<p><a href="#topic+time_elapsed">time_elapsed</a> <a href="#topic+time_seq_id">time_seq_id</a>
</p>

<hr>
<h2 id='time_interval'>S3-based Time Intervals (Currently very experimental and so subject to change)</h2><span id='topic+time_interval'></span><span id='topic+is_time_interval'></span><span id='topic+new_time_interval'></span><span id='topic+interval_start'></span><span id='topic+interval_end'></span><span id='topic+interval_width'></span><span id='topic+interval_count'></span><span id='topic+interval_range'></span>

<h3>Description</h3>

<p>Inspired by both 'lubridate' and 'ivs',
<code>time_interval</code> objects are lightweight S3 objects of a fixed width.
This enables fast and flexible representation of time data
such as months, weeks, and more.
They are all left closed, right open intervals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>time_interval(start = integer(), width = resolution(start))

is_time_interval(x)

new_time_interval(start, width)

interval_start(x)

interval_end(x)

interval_width(x)

interval_count(x)

interval_range(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="time_interval_+3A_start">start</code></td>
<td>
<p>Start time. <br />
E.g a <code>Date</code>, <code>POSIXt</code>, <code>numeric</code> and more.</p>
</td></tr>
<tr><td><code id="time_interval_+3A_width">width</code></td>
<td>
<p>Interval width supplied as a <a href="#topic+timespan">timespan</a>.
By default this is the <a href="#topic+resolution">resolution</a> of a time vector so for example,
a date's resolution is exactly 1 day, therefore
<code>time_interval(Sys.Date())</code> simply represents today's date
as an interval.</p>
</td></tr>
<tr><td><code id="time_interval_+3A_x">x</code></td>
<td>
<p>A <a href="#topic+time_interval">time_interval</a>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Currently because of limitations with the S3/S4 system,
one can't use time intervals directly with lubridate periods.
To navigate around this, <code>timeplyr::timespan()</code> can be used.
e.g. instead of <code>interval / weeks(3)</code>, use <code>interval / timespan(weeks(3))</code>
or even <code>interval / "3 weeks"</code>. where <code>interval</code> is a <code>time_interval</code>.
</p>
<p>To perform interval algebra it is advised to use the 'ivs' package.
To convert a <code>time_interval</code> into an <code>ivs_iv</code>, use
<code>ivs::iv(interval_start(x), interval_end(x))</code>.
</p>


<h3>Value</h3>

<p>An object of class <code>time_interval</code>. <br />
<code>is_time_interval</code> returns a logical of length 1. <br />
<code>interval_start</code> returns the start times. <br />
<code>interval_end</code> returns the end times. <br />
<code>interval_width</code> returns the width of the interval as a <a href="#topic+timespan">timespan</a>. <br />
<code>interval_count</code> returns a data frame of unique intervals and their counts. <br />
<code>interval_range</code> returns a the range of the interval. <br />
<code>new_time_interval</code> is a bare-bones version of <code>time_interval()</code> that
performs no checks.
</p>


<h3>See Also</h3>

<p><a href="#topic+interval_start">interval_start</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
library(timeplyr)
library(lubridate)
x &lt;- 1:10
int &lt;- time_interval(x, 100)
int

month_start &lt;- floor_date(today(), unit = "months")
month_int &lt;- time_interval(month_start, "month")
month_int

interval_start(month_int)
interval_end(month_int)

# Divide an interval into different time units
time_interval(today(), years(10)) / timespan("year")

# Cutting Sepal Length into blocks of width 1
int &lt;- time_cut_width(iris$Sepal.Length, 1)
interval_count(int)

</code></pre>

<hr>
<h2 id='time_is_regular'>Is time a regular sequence? (Experimental)</h2><span id='topic+time_is_regular'></span>

<h3>Description</h3>

<p>This function is a fast way to check if a time vector
is a regular sequence, possibly for many groups.
Regular in this context means that the lagged time differences are a
whole multiple of the specified time unit. <br />
This means <code>x</code> can be a regular sequence with or without gaps in time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>time_is_regular(
  x,
  timespan = granularity(x),
  g = NULL,
  use.g.names = TRUE,
  na.rm = TRUE,
  allow_gaps = FALSE,
  allow_dups = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="time_is_regular_+3A_x">x</code></td>
<td>
<p>Time vector. <br />
E.g. a <code>Date</code>, <code>POSIXt</code>, <code>numeric</code> or any time-based vector.</p>
</td></tr>
<tr><td><code id="time_is_regular_+3A_timespan">timespan</code></td>
<td>
<p><a href="#topic+timespan">timespan</a>.</p>
</td></tr>
<tr><td><code id="time_is_regular_+3A_g">g</code></td>
<td>
<p>Grouping object passed directly to <code>collapse::GRP()</code>.
This can for example be a vector or data frame. <br />
Note that when <code>g</code> is supplied the output is a logical with length
matching the number of unique groups.</p>
</td></tr>
<tr><td><code id="time_is_regular_+3A_use.g.names">use.g.names</code></td>
<td>
<p>Should the result include group names?
Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="time_is_regular_+3A_na.rm">na.rm</code></td>
<td>
<p>Should <code>NA</code> values be removed before calculation?
Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="time_is_regular_+3A_allow_gaps">allow_gaps</code></td>
<td>
<p>Should gaps be allowed? Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="time_is_regular_+3A_allow_dups">allow_dups</code></td>
<td>
<p>Should duplicates be allowed? Default is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical vector the same length as the number of supplied groups.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(timeplyr)
library(lubridate)
library(dplyr)

x &lt;- 1:5
y &lt;- c(1, 1, 2, 3, 5)

# No duplicates or gaps allowed by default
time_is_regular(x)
time_is_regular(y)

increment &lt;- 1

# duplicates and gaps allowed
time_is_regular(x, increment, allow_dups = TRUE, allow_gaps = TRUE)
time_is_regular(y, increment, allow_dups = TRUE, allow_gaps = TRUE)

# No gaps allowed
time_is_regular(x, increment, allow_dups = TRUE, allow_gaps = FALSE)
time_is_regular(y, increment, allow_dups = TRUE, allow_gaps = FALSE)

# Grouped
eu_stock &lt;- ts_as_tbl(EuStockMarkets)
eu_stock &lt;- eu_stock %&gt;%
  mutate(date = as_date(
    date_decimal(time)
  ))

time_is_regular(eu_stock$date, g = eu_stock$group, timespan = 1,
                allow_gaps = TRUE)
# This makes sense as no trading occurs on weekends and holidays
time_is_regular(eu_stock$date, g = eu_stock$group,
                timespan = 1,
                allow_gaps = FALSE)

</code></pre>

<hr>
<h2 id='time_roll_sum'>Fast time-based by-group rolling sum/mean - Currently experimental</h2><span id='topic+time_roll_sum'></span><span id='topic+time_roll_mean'></span><span id='topic+time_roll_growth_rate'></span><span id='topic+time_roll_window_size'></span><span id='topic+time_roll_window'></span><span id='topic+time_roll_apply'></span>

<h3>Description</h3>

<p><code>time_roll_sum</code> and <code>time_roll_mean</code> are efficient
methods for calculating a rolling sum and mean respectively given
many groups and with respect to a date or datetime time index. <br />
It is always aligned &quot;right&quot;. <br />
<code>time_roll_window</code> splits <code>x</code> into windows based on the index. <br />
<code>time_roll_window_size</code> returns the window sizes for all indices of <code>x</code>. <br />
<code>time_roll_apply</code> is a generic function that applies any function
on a rolling basis with respect to a time index. <br />
</p>
<p><code>time_roll_growth_rate</code> can efficiently calculate by-group
rolling growth rates with respect to a date/datetime index.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>time_roll_sum(
  x,
  window = timespan(Inf),
  time = NULL,
  weights = NULL,
  g = NULL,
  partial = TRUE,
  close_left_boundary = FALSE,
  na.rm = TRUE,
  ...
)

time_roll_mean(
  x,
  window = timespan(Inf),
  time = NULL,
  weights = NULL,
  g = NULL,
  partial = TRUE,
  close_left_boundary = FALSE,
  na.rm = TRUE,
  ...
)

time_roll_growth_rate(
  x,
  window = timespan(Inf),
  time = NULL,
  time_step = NULL,
  g = NULL,
  partial = TRUE,
  close_left_boundary = FALSE,
  na.rm = TRUE
)

time_roll_window_size(
  time,
  window = timespan(Inf),
  g = NULL,
  partial = TRUE,
  close_left_boundary = FALSE
)

time_roll_window(
  x,
  window = timespan(Inf),
  time = NULL,
  g = NULL,
  partial = TRUE,
  close_left_boundary = FALSE
)

time_roll_apply(
  x,
  window = timespan(Inf),
  fun,
  time = NULL,
  g = NULL,
  partial = TRUE,
  unlist = FALSE,
  close_left_boundary = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="time_roll_sum_+3A_x">x</code></td>
<td>
<p>Numeric vector.</p>
</td></tr>
<tr><td><code id="time_roll_sum_+3A_window">window</code></td>
<td>
<p>Time window size as a <a href="#topic+timespan">timespan</a>.</p>
</td></tr>
<tr><td><code id="time_roll_sum_+3A_time">time</code></td>
<td>
<p>(Optional) time index. <br />
Can be a <code>Date</code>, <code>POSIXt</code>, <code>numeric</code>, <code>integer</code>,
<code>yearmon</code>, or <code>yearqtr</code> vector.</p>
</td></tr>
<tr><td><code id="time_roll_sum_+3A_weights">weights</code></td>
<td>
<p>Importance weights. Must be the same length as x.
Currently, no normalisation of weights occurs.</p>
</td></tr>
<tr><td><code id="time_roll_sum_+3A_g">g</code></td>
<td>
<p>Grouping object passed directly to <code>collapse::GRP()</code>.
This can for example be a vector or data frame.</p>
</td></tr>
<tr><td><code id="time_roll_sum_+3A_partial">partial</code></td>
<td>
<p>Should calculations be done using partial windows?
Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="time_roll_sum_+3A_close_left_boundary">close_left_boundary</code></td>
<td>
<p>Should the left boundary be closed?
For example, if you specify <code>window = "day"</code> and
<code>time = c(today(), today() + 1)</code>, <br />
a value of <code>FALSE</code> would result in the window vector <code>c(1, 1)</code> whereas
a value of <code>TRUE</code> would result in the window vector <code>c(1, 2)</code>.</p>
</td></tr>
<tr><td><code id="time_roll_sum_+3A_na.rm">na.rm</code></td>
<td>
<p>Should missing values be removed for the calculation?
The default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="time_roll_sum_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code>data.table::frollmean</code> and
<code>data.table::frollsum</code>.</p>
</td></tr>
<tr><td><code id="time_roll_sum_+3A_time_step">time_step</code></td>
<td>
<p>An optional but <b>important</b> argument
that follows the same input rules as <code>window</code>. <br />
It is currently only used only in <code>time_roll_growth_rate</code>. <br />
If this is supplied, the time differences across
gaps in time are incorporated into the growth
rate calculation. See <b>details</b> for more info.</p>
</td></tr>
<tr><td><code id="time_roll_sum_+3A_fun">fun</code></td>
<td>
<p>A function.</p>
</td></tr>
<tr><td><code id="time_roll_sum_+3A_unlist">unlist</code></td>
<td>
<p>Should the output of <code>time_roll_apply</code> be unlisted with
<code>unlist</code>? Default is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It is much faster if your data are already sorted such that
<code>!is.unsorted(order(g, x))</code> is <code>TRUE</code>.
</p>


<h4>Growth rates</h4>

<p>For growth rates across time, one can use <code>time_step</code> to incorporate
gaps in time into the calculation.
</p>
<p>For example: <br />
<code>x &lt;- c(10, 20)</code> <br />
<code>t &lt;- c(1, 10)</code> <br />
<code>k &lt;- Inf</code><br />
<code>time_roll_growth_rate(x, time = t, window = k)</code> = <code>c(1, 2)</code>
whereas <br />
<code>time_roll_growth_rate(x, time = t, window = k, time_step = 1)</code> = <code>c(1, 1.08)</code> <br />
The first is a doubling from 10 to 20, whereas the second implies a growth of
8% for each time step from 1 to 10. <br />
This allows us for example to calculate daily growth rates over the last x months,
even with missing days.
</p>



<h3>Value</h3>

<p>A vector the same length as <code>time</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(timeplyr)
library(lubridate)
library(dplyr)
library(fastplyr)

time &lt;- time_seq(today(), today() + weeks(3), "3 days")
set.seed(99)
x &lt;- sample.int(length(time))

roll_mean(x, window = 7)
roll_sum(x, window = 7)

time_roll_mean(x, window = days(7), time = time)
time_roll_sum(x, window = days(7), time = time)

# Alternatively and more verbosely
x_chunks &lt;- time_roll_window(x, window = 7, time = time)
x_chunks
vapply(x_chunks, mean, 0)

# Interval (x - 3 x]
time_roll_sum(x, window = days(3), time = time)

# An example with an irregular time series

t &lt;- today() + days(sort(sample(1:30, 20, TRUE)))
time_elapsed(t, days(1)) # See the irregular elapsed time
x &lt;- rpois(length(t), 10)

new_tbl(x, t) %&gt;%
  mutate(sum = time_roll_sum(x, time = t, window = days(3))) %&gt;%
  time_ggplot(t, sum)


### Rolling mean example with many time series

# Sparse time with duplicates
index &lt;- sort(sample(seq(now(), now() + dyears(3), by = "333 hours"),
                     250, TRUE))
x &lt;- matrix(rnorm(length(index) * 10^3),
            ncol = 10^3, nrow = length(index),
            byrow = FALSE)

zoo_ts &lt;- zoo::zoo(x, order.by = index)

# Normally you might attempt something like this
apply(x, 2,
      function(x){
        time_roll_mean(x, window = dmonths(1), time = index)
      }
)
# Unfortunately this is too slow and inefficient


# Instead we can pivot it longer and code each series as a separate group
tbl &lt;- ts_as_tbl(zoo_ts)

tbl %&gt;%
  mutate(monthly_mean = time_roll_mean(value, window = dmonths(1),
                                       time = time, g = group))


</code></pre>

<hr>
<h2 id='time_seq'>Time based version of <code>base::seq()</code></h2><span id='topic+time_seq'></span><span id='topic+time_seq_sizes'></span><span id='topic+time_seq_v'></span><span id='topic+time_seq_v2'></span>

<h3>Description</h3>

<p>Time based version of <code>base::seq()</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>time_seq(
  from = NULL,
  to = NULL,
  time_by = NULL,
  length.out = NULL,
  roll_month = getOption("timeplyr.roll_month", "xlast"),
  roll_dst = getOption("timeplyr.roll_dst", c("NA", "xfirst"))
)

time_seq_sizes(from, to, timespan)

time_seq_v(
  from,
  to,
  timespan,
  roll_month = getOption("timeplyr.roll_month", "xlast"),
  roll_dst = getOption("timeplyr.roll_dst", c("NA", "xfirst"))
)

time_seq_v2(
  sizes,
  from,
  timespan,
  roll_month = getOption("timeplyr.roll_month", "xlast"),
  roll_dst = getOption("timeplyr.roll_dst", c("NA", "xfirst"))
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="time_seq_+3A_from">from</code></td>
<td>
<p>Start time.</p>
</td></tr>
<tr><td><code id="time_seq_+3A_to">to</code></td>
<td>
<p>End time.</p>
</td></tr>
<tr><td><code id="time_seq_+3A_time_by">time_by</code></td>
<td>
<p>A <a href="#topic+timespan">timespan</a>. This argument may be renamed in the future.</p>
</td></tr>
<tr><td><code id="time_seq_+3A_length.out">length.out</code></td>
<td>
<p>Length of the sequence.</p>
</td></tr>
<tr><td><code id="time_seq_+3A_roll_month">roll_month</code></td>
<td>
<p>Control how impossible dates are handled when
month or year arithmetic is involved.
Options are &quot;preday&quot;, &quot;boundary&quot;, &quot;postday&quot;, &quot;full&quot; and &quot;NA&quot;.
See <code>?timechange::time_add</code> for more details.</p>
</td></tr>
<tr><td><code id="time_seq_+3A_roll_dst">roll_dst</code></td>
<td>
<p>See <code>?timechange::time_add</code> for the full list of details.</p>
</td></tr>
<tr><td><code id="time_seq_+3A_timespan">timespan</code></td>
<td>
<p><a href="#topic+timespan">timespan</a>.</p>
</td></tr>
<tr><td><code id="time_seq_+3A_sizes">sizes</code></td>
<td>
<p>Time sequence sizes.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This works like <code>seq()</code>,
but using <code>timechange</code> for the period calculations and
<code>base::seq.POSIXT()</code> for the duration calculations.
In many ways it is improved over <code>seq</code> as
dates and/or datetimes can be supplied with no errors to
the start and end points.
Examples like,<br />
<code>time_seq(now(), length.out = 10, by = "0.5 days", seq_type = "dur")</code>
and <br />
<code>time_seq(today(), length.out = 10, by = "0.5 days", seq_type = "dur")</code><br />
produce more expected results compared to <br />
<code>seq(now(), length.out = 10, by = "0.5 days")</code> or <br />
<code>seq(today(), length.out = 10, by = "0.5 days")</code>.<br />
</p>
<p>For a vectorized implementation with multiple start/end times,
use <code>time_seq_v()</code>/<code>time_seq_v2()</code>
</p>
<p><code>time_seq_sizes()</code> is a convenience
function to calculate time sequence lengths, given start/end times.
</p>


<h3>Value</h3>

<p><code>time_seq</code> returns a time sequence. <br />
<code>time_seq_sizes</code> returns an integer vector of sequence sizes. <br />
<code>time_seq_v</code> returns time sequences. <br />
<code>time_seq_v2</code> also returns time sequences.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(timeplyr)
library(lubridate)

# Dates
today &lt;- today()
now &lt;- now()

time_seq(today, today + months(1), time = "day")
time_seq(today, length.out = 10, time = "day")
time_seq(today, length.out = 10, time = "hour")

time_seq(today, today + months(1), time = timespan("days", 1)) # Alternative
time_seq(today, today + years(1), time = "week")
time_seq(today, today + years(1), time = "fortnight")
time_seq(today, today + years(1), time = "year")
time_seq(today, today + years(10), time = "year")
time_seq(today, today + years(100), time = "decade")

# Datetimes
time_seq(now, now + weeks(1), time = "12 hours")
time_seq(now, now + weeks(1), time = "day")
time_seq(now, now + years(1), time = "week")
time_seq(now, now + years(1), time = "fortnight")
time_seq(now, now + years(1), time = "year")
time_seq(now, now + years(10), time = "year")
time_seq(now, today + years(100), time = "decade")

# You can seamlessly mix dates and datetimes with no errors.
time_seq(now, today + days(3), time = "day")
time_seq(now, today + days(3), time = "hour")
time_seq(today, now + days(3), time = "day")
time_seq(today, now + days(3), time = "hour")

# Choose between durations or periods

start &lt;- dmy(31012020)
# If time_type is left as is,
# periods are used for days, weeks, months and years.
time_seq(start, time = months(1), length.out = 12)
time_seq(start, time = dmonths(1), length.out = 12)
# Notice how strange base R version is.
seq(start, by = "month", length.out = 12)

# Roll forward or backward impossible dates

leap &lt;- dmy(29022020) # Leap day
end &lt;- dmy(01032021)
# 3 different options
time_seq(leap, to = end, time = "year",
         roll_month = "NA")
time_seq(leap, to = end, time = "year",
         roll_month = "postday")
time_seq(leap, to = end, time = "year",
         roll_month = getOption("timeplyr.roll_month", "xlast"))

</code></pre>

<hr>
<h2 id='time_seq_id'>Generate a unique identifier for a regular time sequence with gaps</h2><span id='topic+time_seq_id'></span>

<h3>Description</h3>

<p>A unique identifier is created every time a specified amount of
time has passed, or in the case of regular sequences, when there is a gap
in time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>time_seq_id(
  x,
  timespan = granularity(x),
  threshold = 1,
  g = NULL,
  na_skip = TRUE,
  rolling = TRUE,
  switch_on_boundary = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="time_seq_id_+3A_x">x</code></td>
<td>
<p>Time vector. <br />
E.g. a <code>Date</code>, <code>POSIXt</code>, <code>numeric</code> or any time-based vector.</p>
</td></tr>
<tr><td><code id="time_seq_id_+3A_timespan">timespan</code></td>
<td>
<p><a href="#topic+timespan">timespan</a>.</p>
</td></tr>
<tr><td><code id="time_seq_id_+3A_threshold">threshold</code></td>
<td>
<p>Threshold such that when the time elapsed
exceeds this, the sequence ID is incremented by 1.
For example, if <code>timespan = "days"</code> and <code>threshold = 2</code>,
then when 2 days have passed, a new ID is created.
Furthermore, <code>threshold</code> generally need not be supplied as <br />
<code>timespan = "3 days"</code> &amp; <code>threshold = 1</code> <br />
is identical to <br />
<code>timespan = "days"</code> &amp; <code>threshold = 3</code>. <br /></p>
</td></tr>
<tr><td><code id="time_seq_id_+3A_g">g</code></td>
<td>
<p>Object used for grouping x.
This can for example be a vector or data frame.
<code>g</code> is passed directly to <code>collapse::GRP()</code>.</p>
</td></tr>
<tr><td><code id="time_seq_id_+3A_na_skip">na_skip</code></td>
<td>
<p>Should <code>NA</code> values be skipped? Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="time_seq_id_+3A_rolling">rolling</code></td>
<td>
<p>When this is <code>FALSE</code>, a new ID is created every time
a cumulative amount of time has passed. Once that amount of time has passed,
a new ID is created, the clock &quot;resets&quot; and we start counting from that point.</p>
</td></tr>
<tr><td><code id="time_seq_id_+3A_switch_on_boundary">switch_on_boundary</code></td>
<td>
<p>When an exact amount of time
(specified in <code>time_by</code>) has passed, should there an increment in ID?
The default is <code>FALSE</code>. For example, if <code>time_by = "days"</code> and
<code>switch_on_boundary = FALSE</code>, <code>&gt;</code> 1 day must have passed, otherwise
<code>&gt;=</code> 1 day must have passed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>time_seq_id()</code> Assumes <code>x</code> is regular and in
ascending or descending order.
To check this condition formally, use <code>time_is_regular()</code>.
</p>


<h3>Value</h3>

<p>An integer vector of <code>length(x)</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
library(timeplyr)
library(lubridate)

# Weekly sequence, with 2 gaps in between
x &lt;- time_seq(today(), length.out = 10, time = "week")
x &lt;- x[-c(3, 7)]
# A new ID when more than a week has passed since the last time point
time_seq_id(x)
# A new ID when &gt;= 2 weeks has passed since the last time point
time_seq_id(x, threshold = 2, switch_on_boundary = TRUE)
# A new ID when at least 4 cumulative weeks have passed
time_seq_id(x, timespan = "4 weeks",
            switch_on_boundary = TRUE, rolling = FALSE)
# A new ID when more than 4 cumulative weeks have passed
time_seq_id(x, timespan = "4 weeks",
            switch_on_boundary = FALSE, rolling = FALSE)

</code></pre>

<hr>
<h2 id='timespan'>Timespans</h2><span id='topic+timespan'></span><span id='topic+new_timespan'></span><span id='topic+is_timespan'></span><span id='topic+timespan_unit'></span><span id='topic+timespan_num'></span>

<h3>Description</h3>

<p>Timespans
</p>


<h3>Usage</h3>

<pre><code class='language-R'>timespan(units, num = 1L, ...)

new_timespan(units, num = 1L)

is_timespan(x)

timespan_unit(x)

timespan_num(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="timespan_+3A_units">units</code></td>
<td>
<p>A unit of time, e.g.
<code>"days"</code>, <code>"3 weeks"</code>, <code>lubridate::weeks(3)</code>, or just a numeric vector.</p>
</td></tr>
<tr><td><code id="timespan_+3A_num">num</code></td>
<td>
<p>Number of units. E.g. <code>units = "days"</code> and <code>num = 3</code> produces
a timespan width of 3 days.</p>
</td></tr>
<tr><td><code id="timespan_+3A_...">...</code></td>
<td>
<p>Further arguments passed onto methods.</p>
</td></tr>
<tr><td><code id="timespan_+3A_x">x</code></td>
<td>
<p>A <a href="#topic+timespan">timespan</a>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>timespan()</code> can be used to create objects of class 'timespan' which are
used widely in timeplyr.
</p>
<p><code>new_timespan()</code> is a bare-bones version that
does no checking or string parsing and is
intended for fast timespan creation.
</p>
<p><code>timespan_unit()</code> is a helper that extracts the unit of time of the timespan.
</p>
<p><code>timespan_num()</code> is a helper that extracts the number of units of time.
</p>


<h3>Value</h3>

<p>A <a href="#topic+timespan">timespan</a> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(timeplyr)

timespan("week")
timespan("day")
timespan("decade")

# Multiple units of time

timespan("10 weeks")
timespan("1.5 hours")

# These are all equivalent
timespan(NULL, 3);timespan(3);timespan(NA_character_, 3)

</code></pre>

<hr>
<h2 id='transform_year_month'>Additional ggplot2 scales</h2><span id='topic+transform_year_month'></span><span id='topic+transform_year_quarter'></span><span id='topic+scale_x_year_month'></span><span id='topic+scale_x_year_quarter'></span><span id='topic+scale_y_year_month'></span><span id='topic+scale_y_year_quarter'></span>

<h3>Description</h3>

<p>Additional scales and transforms for use with year_months and year_quarters
in ggplot2.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>transform_year_month()

transform_year_quarter()

scale_x_year_month(...)

scale_x_year_quarter(...)

scale_y_year_month(...)

scale_y_year_quarter(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="transform_year_month_+3A_...">...</code></td>
<td>
<p>Arguments passed to <code>scale_x_continuous</code> and <code>scale_y_continuous</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot2 scale or transform.
</p>

<hr>
<h2 id='ts_as_tbl'>Turn <code>ts</code> into a <code>tibble</code></h2><span id='topic+ts_as_tbl'></span><span id='topic+ts_as_tbl.default'></span><span id='topic+ts_as_tbl.mts'></span><span id='topic+ts_as_tbl.xts'></span><span id='topic+ts_as_tbl.zoo'></span><span id='topic+ts_as_tbl.timeSeries'></span>

<h3>Description</h3>

<p>While a method already exists in the <code>tibble</code> package,
this method works differently in 2 ways:
</p>

<ul>
<li><p> The time variable associated with the time-series is also returned.
</p>
</li>
<li><p> The returned <code>tibble</code> is always in long format, even when the time-series
is multivariate.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>ts_as_tbl(x, name = "time", value = "value", group = "group")

## Default S3 method:
ts_as_tbl(x, name = "time", value = "value", group = "group")

## S3 method for class 'mts'
ts_as_tbl(x, name = "time", value = "value", group = "group")

## S3 method for class 'xts'
ts_as_tbl(x, name = "time", value = "value", group = "group")

## S3 method for class 'zoo'
ts_as_tbl(x, name = "time", value = "value", group = "group")

## S3 method for class 'timeSeries'
ts_as_tbl(x, name = "time", value = "value", group = "group")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ts_as_tbl_+3A_x">x</code></td>
<td>
<p>An object of class <code>ts</code>, <code>mts</code>, <code>zoo</code>, <code>xts</code> or <code>timeSeries</code>.</p>
</td></tr>
<tr><td><code id="ts_as_tbl_+3A_name">name</code></td>
<td>
<p>Name of the output time column.</p>
</td></tr>
<tr><td><code id="ts_as_tbl_+3A_value">value</code></td>
<td>
<p>Name of the output value column.</p>
</td></tr>
<tr><td><code id="ts_as_tbl_+3A_group">group</code></td>
<td>
<p>Name of the output group column
when there are multiple series.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A 2-column <code>tibble</code> containing the time index and values for each
time index. In the case where there are multiple series, this becomes
a 3-column <code>tibble</code> with an additional &quot;group&quot; column added.
</p>


<h3>See Also</h3>

<p><a href="#topic+time_ggplot">time_ggplot</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(timeplyr)
library(ggplot2)
library(dplyr)

# Using the examples from ?ts

# Univariate
uts &lt;- ts(cumsum(1 + round(rnorm(100), 2)),
          start = c(1954, 7), frequency = 12)
uts_tbl &lt;- ts_as_tbl(uts)

## Multivariate
mts &lt;- ts(matrix(rnorm(300), 100, 3), start = c(1961, 1), frequency = 12)
mts_tbl &lt;- ts_as_tbl(mts)

uts_tbl %&gt;%
  time_ggplot(time, value)

mts_tbl %&gt;%
  time_ggplot(time, value, group, facet = TRUE)

# zoo example
x.Date &lt;- as.Date("2003-02-01") + c(1, 3, 7, 9, 14) - 1
x &lt;- zoo::zoo(rnorm(5), x.Date)
ts_as_tbl(x)
x &lt;- zoo::zoo(matrix(1:12, 4, 3), as.Date("2003-01-01") + 0:3)
ts_as_tbl(x)

</code></pre>

<hr>
<h2 id='year_month'>Fast methods for creating year-months and year-quarters</h2><span id='topic+year_month'></span><span id='topic+year_quarter'></span><span id='topic+YM'></span><span id='topic+year_month_decimal'></span><span id='topic+decimal_year_month'></span><span id='topic+YQ'></span><span id='topic+year_quarter_decimal'></span><span id='topic+decimal_year_quarter'></span>

<h3>Description</h3>

<p>These are experimental methods for working with year-months and
year-quarters inspired by 'zoo' and 'tsibble'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>year_month(x)

year_quarter(x)

YM(length = 0L)

year_month_decimal(x)

decimal_year_month(x)

YQ(length = 0L)

year_quarter_decimal(x)

decimal_year_quarter(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="year_month_+3A_x">x</code></td>
<td>
<p>A <code>year_month</code>, <code>year_quarter</code>, or any other time-based object.</p>
</td></tr>
<tr><td><code id="year_month_+3A_length">length</code></td>
<td>
<p>Length of <code>year_month</code> or <code>year_quarter</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The biggest difference is that the underlying data is simply
the number of months/quarters since epoch. This makes integer
arithmetic very simple, and allows for fast sequence creation as well as
fast coercion to <code>year_month</code> and <code>year_quarter</code>
from numeric vectors.
</p>
<p>Printing method is also fast.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(timeplyr)
library(lubridate)

x &lt;- year_month(today())

# Adding 1 adds 1 month
x + 1
# Adding 12 adds 1 year
x + 12
# Sequence of yearmonths
x + 0:12

# If you unclass, do the same arithmetic, and coerce back to year_month
# The result is always the same
year_month(unclass(x) + 1)
year_month(unclass(x) + 12)

# Initialise a year_month or year_quarter to the specified length
YM(0)
YQ(0)
YM(3)
YQ(3)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
