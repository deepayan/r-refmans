<!DOCTYPE html><html><head><title>Help for package timeplyr</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {timeplyr}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#.time_units'><p>Time units</p></a></li>
<li><a href='#age_years'><p>Accurate and efficient age calculation</p></a></li>
<li><a href='#arithmetic_mean'><p>Unweighted &amp; weighted arithmetic, geometric and harmonic mean</p></a></li>
<li><a href='#asc'><p>Helpers to sort variables in ascending or descending order</p></a></li>
<li><a href='#calendar'><p>Create a table of common time units from a date or datetime sequence.</p></a></li>
<li><a href='#cpp_which'><p>Efficient alternative to <code>which()</code></p></a></li>
<li><a href='#crossed_join'><p>A <code>do.call()</code> and <code>data.table::CJ()</code> method</p></a></li>
<li><a href='#duplicate_rows'><p>Find duplicate rows</p></a></li>
<li><a href='#edf'><p>Grouped empirical cumulative distribution function applied to data</p></a></li>
<li><a href='#farrange'><p>A <code>collapse</code> version of <code>dplyr::arrange()</code></p></a></li>
<li><a href='#fcount'><p>A fast replacement to dplyr::count()</p></a></li>
<li><a href='#fdistinct'><p>Find distinct rows</p></a></li>
<li><a href='#fexpand'><p>Fast versions of <code>tidyr::expand()</code> and <code>tidyr::complete()</code>.</p></a></li>
<li><a href='#fgroup_by'><p>'collapse' version of <code>dplyr::group_by()</code></p></a></li>
<li><a href='#fn'><p>Supplementary fast statistical functions, <code>collapse</code> style</p></a></li>
<li><a href='#frowid'><p>Fast grouped row numbers</p></a></li>
<li><a href='#fselect'><p>Fast <code>dplyr::select()</code>/<code>dplyr::rename()</code></p></a></li>
<li><a href='#fskim'><p>Fast alternative to <code>skimr::skim()</code></p></a></li>
<li><a href='#fslice'><p>Faster <code>dplyr::slice()</code></p></a></li>
<li><a href='#gcd'><p>Greatest common divisor and smallest common multiple</p></a></li>
<li><a href='#get_time_delay'><p>Get summary statistics of time delay</p></a></li>
<li><a href='#group_collapse'><p>Key group information</p></a></li>
<li><a href='#group_id'><p>Fast group IDs</p></a></li>
<li><a href='#groups_equal'><p>Are groups equal?</p></a></li>
<li><a href='#growth'><p>Rolling basic growth</p></a></li>
<li><a href='#growth_rate'><p>Fast Growth Rates</p></a></li>
<li><a href='#gsum'><p>Grouped statistical functions.</p></a></li>
<li><a href='#gunique'><p>Grouped <code>unique()</code>, <code>sort()</code> and <code>duplicated()</code></p></a></li>
<li><a href='#is_date'><p>Utility functions for checking if date or datetime</p></a></li>
<li><a href='#is_whole_number'><p>Are all numbers whole numbers?</p></a></li>
<li><a href='#iso_week'><p>Efficient, simple and flexible ISO week calculation</p></a></li>
<li><a href='#missing_dates'><p>Check for missing dates between first and last date</p></a></li>
<li><a href='#num_na'><p>Fast number of missing values</p></a></li>
<li><a href='#q_summarise'><p>Fast grouped quantile summary</p></a></li>
<li><a href='#roll_apply'><p>By-group rolling functions</p></a></li>
<li><a href='#roll_lag'><p>Fast rolling grouped lags and differences</p></a></li>
<li><a href='#roll_na_fill'><p>Fast grouped &quot;locf&quot; <code>NA</code> fill</p></a></li>
<li><a href='#roll_sum'><p>Fast by-group rolling functions</p></a></li>
<li><a href='#sequence2'><p>Utilities for creating useful sequences</p></a></li>
<li><a href='#stat_summarise'><p>Fast grouped statistical summary for data frames.</p></a></li>
<li><a href='#time_aggregate'><p>Aggregate time to a higher unit</p></a></li>
<li><a href='#time_by'><p>Group by a time variable at a higher time unit</p></a></li>
<li><a href='#time_count'><p>Fast count time at higher time units.</p></a></li>
<li><a href='#time_cut'><p>Cut dates and datetimes into regularly spaced date or datetime intervals</p></a></li>
<li><a href='#time_diff'><p>Time differences by any time unit</p></a></li>
<li><a href='#time_diff_gcd'><p>Fast greatest common divisor of time differences</p></a></li>
<li><a href='#time_distinct'><p>A time based extension to <code>dplyr::distinct()</code>.</p></a></li>
<li><a href='#time_elapsed'><p>Fast grouped time elapsed</p></a></li>
<li><a href='#time_episodes'><p>Episodic calculation of time-since-event data</p></a></li>
<li><a href='#time_expand'><p>A time based extension to <code>tidyr::complete()</code>.</p></a></li>
<li><a href='#time_expandv'><p>Vector date and datetime functions</p></a></li>
<li><a href='#time_gaps'><p>Gaps in a regular time sequence</p></a></li>
<li><a href='#time_ggplot'><p>Quick time-series ggplot</p></a></li>
<li><a href='#time_id'><p>Time ID</p></a></li>
<li><a href='#time_is_regular'><p>Is time a regular sequence? (Experimental)</p></a></li>
<li><a href='#time_lag'><p>Time-lagged values</p></a></li>
<li><a href='#time_mutate'><p>A time based extension to <code>dplyr::mutate()</code>.</p></a></li>
<li><a href='#time_roll_diff'><p>Lagged time differences</p></a></li>
<li><a href='#time_roll_sum'><p>Fast time-based by-group rolling sum/mean - Currently experimental</p></a></li>
<li><a href='#time_seq'><p>Time based version of <code>base::seq()</code></p></a></li>
<li><a href='#time_seq_id'><p>Generate a unique identifier for a regular time sequence with gaps</p></a></li>
<li><a href='#time_summarise'><p>A time based extension to <code>dplyr::summarise()</code></p></a></li>
<li><a href='#timeplyr-package'><p>timeplyr: Fast Tidy Tools for Date and Date-Time Manipulation</p></a></li>
<li><a href='#top_n_tbl'><p>Top N most/least frequent values</p></a></li>
<li><a href='#ts_as_tibble'><p>Turn <code>ts</code> into a <code>tibble</code></p></a></li>
<li><a href='#unit_guess'><p>Guess time unit and extract basic information.</p></a></li>
<li><a href='#year_month'><p>Fast methods for creating year-months and year-quarters</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Fast Tidy Tools for Date and Date-Time Manipulation</td>
</tr>
<tr>
<td>Version:</td>
<td>0.5.0</td>
</tr>
<tr>
<td>Description:</td>
<td>A set of fast tidy functions for wrangling, completing and
    summarising date and date-time data. It combines 'tidyverse' syntax
    with the efficiency of 'data.table' and speed of 'collapse'.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/NicChr/timeplyr/issues">https://github.com/NicChr/timeplyr/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>collapse (&ge; 2.0.0), cppdoubles, data.table (&ge; 1.14.8), dplyr
(&ge; 1.1.0), ggplot2 (&ge; 3.4.0), lubridate (&ge; 1.9.0), pillar(&ge;
1.7.0), rlang (&ge; 1.0.0), stringr (&ge; 1.4.0), tidyselect (&ge;
1.2.0), timechange (&ge; 0.2.0), vctrs (&ge; 0.6.0)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>bench, knitr, nycflights13, outbreaks, rmarkdown, testthat
(&ge; 3.0.0), tidyr, zoo</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>cpp11</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-12-12 11:44:49 UTC; Nmc5</td>
</tr>
<tr>
<td>Author:</td>
<td>Nick Christofides <a href="https://orcid.org/0000-0002-9743-7342"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Nick Christofides &lt;nick.christofides.r@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-12-12 12:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='.time_units'>Time units</h2><span id='topic+.time_units'></span><span id='topic+.period_units'></span><span id='topic+.duration_units'></span><span id='topic+.extra_time_units'></span>

<h3>Description</h3>

<p>Time units
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.time_units

.period_units

.duration_units

.extra_time_units
</code></pre>


<h3>Format</h3>

<p>An object of class <code>character</code> of length 21.
</p>
<p>An object of class <code>character</code> of length 7.
</p>
<p>An object of class <code>character</code> of length 11.
</p>
<p>An object of class <code>character</code> of length 10.
</p>

<hr>
<h2 id='age_years'>Accurate and efficient age calculation</h2><span id='topic+age_years'></span><span id='topic+age_months'></span>

<h3>Description</h3>

<p>Correct calculation of ages in years using lubridate periods.
Leap year calculations work as well.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>age_years(start, end = if (is_date(start)) Sys.Date() else Sys.time())

age_months(start, end = if (is_date(start)) Sys.Date() else Sys.time())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="age_years_+3A_start">start</code></td>
<td>
<p>Start date/datetime, typically date of birth.</p>
</td></tr>
<tr><td><code id="age_years_+3A_end">end</code></td>
<td>
<p>End date/datetime. Default is current date/datetime.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Integer vector of age in years or months.
</p>

<hr>
<h2 id='arithmetic_mean'>Unweighted &amp; weighted arithmetic, geometric and harmonic mean</h2><span id='topic+arithmetic_mean'></span><span id='topic+geometric_mean'></span><span id='topic+harmonic_mean'></span>

<h3>Description</h3>

<p>Convenience functions for fast unweighted and weighted mean calculations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>arithmetic_mean(x, weights = NULL, na.rm = TRUE, ...)

geometric_mean(x, weights = NULL, na.rm = TRUE, ...)

harmonic_mean(x, weights = NULL, na.rm = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="arithmetic_mean_+3A_x">x</code></td>
<td>
<p><a href="base.html#topic+numeric">numeric</a> Vector.</p>
</td></tr>
<tr><td><code id="arithmetic_mean_+3A_weights">weights</code></td>
<td>
<p><a href="base.html#topic+numeric">numeric</a> Vector of weights. <br />
Default is <code>NULL</code> which performs an unweighted mean.</p>
</td></tr>
<tr><td><code id="arithmetic_mean_+3A_na.rm">na.rm</code></td>
<td>
<p><a href="base.html#topic+logical">logical</a> Value (Default is <code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="arithmetic_mean_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code>collapse::fmean</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>numeric(min(length(x), 1))</code>.
</p>

<hr>
<h2 id='asc'>Helpers to sort variables in ascending or descending order</h2><span id='topic+asc'></span><span id='topic+desc'></span>

<h3>Description</h3>

<p>An alternative to <code>dplyr::desc()</code> which is much faster
for character vectors and factors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>asc(x)

desc(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="asc_+3A_x">x</code></td>
<td>
<p>Vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector that can be ordered in ascending or descending order. <br />
Useful in <code>dplyr::arrange()</code> or <code>farrange()</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
library(timeplyr)

starwars %&gt;%
  fdistinct(mass) %&gt;%
  farrange(desc(mass))

</code></pre>

<hr>
<h2 id='calendar'>Create a table of common time units from a date or datetime sequence.</h2><span id='topic+calendar'></span><span id='topic+add_calendar'></span>

<h3>Description</h3>

<p>Create a table of common time units from a date or datetime sequence.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calendar(
  x,
  label = TRUE,
  week_start = getOption("lubridate.week.start", 1),
  fiscal_start = getOption("lubridate.fiscal.start", 1),
  name = "time"
)

add_calendar(
  data,
  time = NULL,
  label = TRUE,
  week_start = getOption("lubridate.week.start", 1),
  fiscal_start = getOption("lubridate.fiscal.start", 1)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calendar_+3A_x">x</code></td>
<td>
<p>date or datetime vector.</p>
</td></tr>
<tr><td><code id="calendar_+3A_label">label</code></td>
<td>
<p>Logical. Should labelled (ordered factor) versions of
week day and month be returned? Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="calendar_+3A_week_start">week_start</code></td>
<td>
<p>day on which week starts following ISO conventions - 1
means Monday, 7 means Sunday (default). When <code>label = TRUE</code>,
this will be the first level of the returned factor.
You can set <code>lubridate.week.start</code> option to control this parameter globally.</p>
</td></tr>
<tr><td><code id="calendar_+3A_fiscal_start">fiscal_start</code></td>
<td>
<p>Numeric indicating the starting month of a fiscal year.</p>
</td></tr>
<tr><td><code id="calendar_+3A_name">name</code></td>
<td>
<p>Name of date/datetime column.</p>
</td></tr>
<tr><td><code id="calendar_+3A_data">data</code></td>
<td>
<p>A data frame.</p>
</td></tr>
<tr><td><code id="calendar_+3A_time">time</code></td>
<td>
<p>Time variable.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>tibble</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(timeplyr)
library(lubridate)

# Create a calendar for the current year
from &lt;- floor_date(today(), unit = "year")
to &lt;- ceiling_date(today(), unit = "year", change_on_boundary = TRUE) - days(1)

my_seq &lt;- time_seq(from, to, time_by = "day")
calendar(my_seq)

</code></pre>

<hr>
<h2 id='cpp_which'>Efficient alternative to <code>which()</code></h2><span id='topic+cpp_which'></span>

<h3>Description</h3>

<p>Exactly the same as <code>which()</code> but more memory efficient.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cpp_which(x, invert = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cpp_which_+3A_x">x</code></td>
<td>
<p>A <a href="base.html#topic+logical">logical</a> vector.</p>
</td></tr>
<tr><td><code id="cpp_which_+3A_invert">invert</code></td>
<td>
<p>If <code>TRUE</code>, indices of values that are not <code>TRUE</code> are returned
(including <code>NA</code>). If <code>FALSE</code> (the default), only <code>TRUE</code> indices are returned.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This implementation is similar in speed to <code>which()</code>
but usually more memory efficient.
</p>


<h3>Value</h3>

<p>An unnamed integer vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(timeplyr)
library(bench)

x &lt;- sample(c(TRUE, FALSE), 1e05, TRUE)
x[sample.int(1e05, round(1e05/3))] &lt;- NA

mark(cpp_which(TRUE), which(TRUE))
mark(cpp_which(FALSE), which(FALSE))
mark(cpp_which(logical()), which(logical()))
mark(cpp_which(x), which(x), iterations = 20)
mark(base = which(is.na(match(x, TRUE))),
     collapse = collapse::whichNA(collapse::fmatch(x, TRUE, overid = 2L)),
     timeplyr = cpp_which(x, invert = TRUE),
     iterations = 20)


</code></pre>

<hr>
<h2 id='crossed_join'>A <code>do.call()</code> and <code>data.table::CJ()</code> method</h2><span id='topic+crossed_join'></span>

<h3>Description</h3>

<p>This function operates like <code>do.call(CJ, ...)</code> and accepts
a list or data.frame as an argument. <br />
It has less overhead for small joins, especially when <code>unique = FALSE</code> and
<code>as_dt = FALSE</code>. <br />
<code>NA</code>s are by default sorted last.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>crossed_join(
  X,
  sort = FALSE,
  unique = TRUE,
  as_dt = TRUE,
  strings_as_factors = FALSE,
  log_limit = 8
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="crossed_join_+3A_x">X</code></td>
<td>
<p>A list or data frame.</p>
</td></tr>
<tr><td><code id="crossed_join_+3A_sort">sort</code></td>
<td>
<p>Should the expansion be sorted? By default it is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="crossed_join_+3A_unique">unique</code></td>
<td>
<p>Should unique values across each column or list element
be taken? By default this is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="crossed_join_+3A_as_dt">as_dt</code></td>
<td>
<p>Should result be a <code>data.table</code>?
By default this is <code>TRUE</code>. If <code>FALSE</code> a list is returned.</p>
</td></tr>
<tr><td><code id="crossed_join_+3A_strings_as_factors">strings_as_factors</code></td>
<td>
<p>Should strings be converted to factors before
expansion? The default is <code>FALSE</code> but setting to <code>TRUE</code> can offer
a significant speed improvement.</p>
</td></tr>
<tr><td><code id="crossed_join_+3A_log_limit">log_limit</code></td>
<td>
<p>The maximum log10 limit for expanded number of rows.
Anything &gt;= this results in an error.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An important note is that currently <code>NA</code>s
are sorted last and therefore a key is not set.
</p>


<h3>Value</h3>

<p>A data.table or list object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(timeplyr)

crossed_join(list(1:3, -2:2))
crossed_join(iris)

</code></pre>

<hr>
<h2 id='duplicate_rows'>Find duplicate rows</h2><span id='topic+duplicate_rows'></span><span id='topic+fduplicates'></span><span id='topic+fduplicates2'></span>

<h3>Description</h3>

<p>Find duplicate rows
</p>


<h3>Usage</h3>

<pre><code class='language-R'>duplicate_rows(
  data,
  ...,
  .keep_all = FALSE,
  .both_ways = FALSE,
  .add_count = FALSE,
  .drop_empty = FALSE,
  sort = FALSE,
  .by = NULL,
  .cols = NULL
)

fduplicates(
  data,
  ...,
  .keep_all = FALSE,
  .both_ways = FALSE,
  .add_count = FALSE,
  .drop_empty = FALSE,
  sort = FALSE,
  .by = NULL,
  .cols = NULL
)

fduplicates2(
  data,
  ...,
  .keep_all = FALSE,
  .both_ways = FALSE,
  .add_count = FALSE,
  .drop_empty = FALSE,
  .by = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="duplicate_rows_+3A_data">data</code></td>
<td>
<p>A data frame.</p>
</td></tr>
<tr><td><code id="duplicate_rows_+3A_...">...</code></td>
<td>
<p>Variables used to find duplicate rows.</p>
</td></tr>
<tr><td><code id="duplicate_rows_+3A_.keep_all">.keep_all</code></td>
<td>
<p>If <code>TRUE</code> then all columns of data frame are kept,
default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="duplicate_rows_+3A_.both_ways">.both_ways</code></td>
<td>
<p>If <code>TRUE</code> then duplicates and non-duplicate first instances
are retained. The default is <code>FALSE</code> which returns only duplicate rows. <br />
Setting this to <code>TRUE</code> can be particularly useful when examining
the differences between duplicate rows.</p>
</td></tr>
<tr><td><code id="duplicate_rows_+3A_.add_count">.add_count</code></td>
<td>
<p>If <code>TRUE</code> then a count column is added to denote the
number of duplicates (including first non-duplicate instance).
The naming convention of this column follows <code>dplyr::add_count()</code>.</p>
</td></tr>
<tr><td><code id="duplicate_rows_+3A_.drop_empty">.drop_empty</code></td>
<td>
<p>If <code>TRUE</code> then empty rows with all <code>NA</code> values are removed.
The default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="duplicate_rows_+3A_sort">sort</code></td>
<td>
<p>Should result be sorted?
If <code>FALSE</code> (the default), then rows are returned in the exact same order as
they appear in the data.
If <code>TRUE</code> then the duplicate rows are sorted.</p>
</td></tr>
<tr><td><code id="duplicate_rows_+3A_.by">.by</code></td>
<td>
<p>(Optional). A selection of columns to group by for this operation.
Columns are specified using tidy-select.</p>
</td></tr>
<tr><td><code id="duplicate_rows_+3A_.cols">.cols</code></td>
<td>
<p>(Optional) alternative to <code>...</code> that accepts
a named character vector or numeric vector.
If speed is an expensive resource, it is recommended to use this.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function works like <code>dplyr::distinct()</code> in its handling of
arguments and data-masking but returns duplicate rows.
In certain situations in can be much faster than <code>data %&gt;% group_by() %&gt;% filter(n() &gt; 1)</code>
when there are many groups.
<code>fduplicates2()</code> returns the same output but uses a different
method which utilises joins and is written almost entirely using dplyr.
</p>


<h3>Value</h3>

<p>A <code>data.frame</code> of duplicate rows.
</p>


<h3>See Also</h3>

<p><a href="#topic+fcount">fcount</a> <a href="#topic+group_collapse">group_collapse</a> <a href="#topic+fdistinct">fdistinct</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
library(timeplyr)
library(ggplot2)

# Duplicates across all columns
diamonds %&gt;%
  duplicate_rows()
# Alternatively with row ids
diamonds %&gt;%
  filter(frowid(.) &gt; 1)
# Diamonds with the same dimensions
diamonds %&gt;%
  duplicate_rows(x, y, z)
# Can use tidyverse select notation
diamonds %&gt;%
  duplicate_rows(across(where(is.factor)), .keep_all = FALSE)
# Similar to janitor::get_dupes()
diamonds %&gt;%
  duplicate_rows(.add_count = TRUE)
# Keep the first instance of each duplicate row
diamonds %&gt;%
  duplicate_rows(.both_ways = TRUE)
# Same as the below
diamonds %&gt;%
  fadd_count(across(everything())) %&gt;%
  filter(n &gt; 1)

</code></pre>

<hr>
<h2 id='edf'>Grouped empirical cumulative distribution function applied to data</h2><span id='topic+edf'></span>

<h3>Description</h3>

<p>Like <code>dplyr::cume_dist(x)</code> and <code>ecdf(x)(x)</code>
but with added grouping and weighting functionality.<br />
You can calculate the empirical distribution of x using
aggregated data by supplying frequency weights.
No expansion occurs which makes this function extremely efficient
for this type of data, of which plotting is a common application.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>edf(x, g = NULL, wt = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="edf_+3A_x">x</code></td>
<td>
<p>Numeric vector.</p>
</td></tr>
<tr><td><code id="edf_+3A_g">g</code></td>
<td>
<p>Numeric vector of group IDs.</p>
</td></tr>
<tr><td><code id="edf_+3A_wt">wt</code></td>
<td>
<p>Frequency weights.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector the same length as <code>x</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(timeplyr)
library(dplyr)
library(ggplot2)

set.seed(9123812)
x &lt;- sample(seq(-10, 10, 0.5), size = 10^2, replace = TRUE)
plot(sort(edf(x)))
all.equal(edf(x), ecdf(x)(x))
all.equal(edf(x), cume_dist(x))

# Manual ECDF plot using only aggregate data
y &lt;- rnorm(100, 10)
grid &lt;- time_span(y, time_by = 0.1, time_floor = TRUE)
counts &lt;- time_countv(y, time_by = 0.1, time_floor = TRUE, complete = TRUE)$n
edf &lt;- edf(grid, wt = counts)
# Trivial here as this is the same
all.equal(unname(cumsum(counts)/sum(counts)), edf)

# Full ecdf
tibble(x) %&gt;%
  ggplot(aes(x = y)) +
  stat_ecdf()
# Approximation using aggregate only data
tibble(grid, edf) %&gt;%
  ggplot(aes(x = grid, y = edf)) +
  geom_step()

# Grouped example
g &lt;- sample(letters[1:3], size = 10^2, replace = TRUE)

edf1 &lt;- tibble(x, g) %&gt;%
  mutate(edf = cume_dist(x),
         .by = g) %&gt;%
  pull(edf)
edf2 &lt;- edf(x, g = g)
all.equal(edf1, edf2)

</code></pre>

<hr>
<h2 id='farrange'>A <code>collapse</code> version of <code>dplyr::arrange()</code></h2><span id='topic+farrange'></span>

<h3>Description</h3>

<p>This is a fast and near-identical alternative to <code>dplyr::arrange()</code>
using the <code>collapse</code> package.
</p>
<p><code>desc()</code> is like <code>dplyr::desc()</code> but works faster when
called directly on vectors. <br />
</p>


<h3>Usage</h3>

<pre><code class='language-R'>farrange(data, ..., .by = NULL, .by_group = FALSE, .cols = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="farrange_+3A_data">data</code></td>
<td>
<p>A data frame.</p>
</td></tr>
<tr><td><code id="farrange_+3A_...">...</code></td>
<td>
<p>Variables to arrange by.</p>
</td></tr>
<tr><td><code id="farrange_+3A_.by">.by</code></td>
<td>
<p>(Optional). A selection of columns to group by for this operation.
Columns are specified using <code>tidyselect</code>.</p>
</td></tr>
<tr><td><code id="farrange_+3A_.by_group">.by_group</code></td>
<td>
<p>If <code>TRUE</code> the sorting will be first done by the group
variables.</p>
</td></tr>
<tr><td><code id="farrange_+3A_.cols">.cols</code></td>
<td>
<p>(Optional) alternative to <code>...</code> that accepts
a named character vector or numeric vector.
If speed is an expensive resource, it is recommended to use this.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>farrange()</code> is inspired by <code>collapse::roworder()</code> but also supports
<code>dplyr</code> style <code>data-masking</code> which makes it a
closer replacement to <code>dplyr::arrange()</code>.
</p>
<p>You can use <code>desc()</code> interchangeably with <code>dplyr</code> and <code>timeplyr</code>. <br />
<code>arrange(iris, desc(Species))</code> uses <code>dplyr</code>'s version. <br />
<code>farrange(iris, desc(Species))</code> uses <code>timeplyr</code>'s version.
</p>
<p><code>farrange()</code> is faster when there are many groups or a large number of
rows.
</p>


<h3>Value</h3>

<p>A sorted <code>data.frame</code>.
</p>

<hr>
<h2 id='fcount'>A fast replacement to dplyr::count()</h2><span id='topic+fcount'></span><span id='topic+fadd_count'></span>

<h3>Description</h3>

<p>Near-identical alternative to <code>dplyr::count()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fcount(
  data,
  ...,
  wt = NULL,
  sort = FALSE,
  order = TRUE,
  name = NULL,
  .by = NULL,
  .cols = NULL
)

fadd_count(
  data,
  ...,
  wt = NULL,
  sort = FALSE,
  order = TRUE,
  name = NULL,
  .by = NULL,
  .cols = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fcount_+3A_data">data</code></td>
<td>
<p>A data frame.</p>
</td></tr>
<tr><td><code id="fcount_+3A_...">...</code></td>
<td>
<p>Variables to group by.</p>
</td></tr>
<tr><td><code id="fcount_+3A_wt">wt</code></td>
<td>
<p>Frequency weights.
Can be <code>NULL</code> or a variable:
</p>

<ul>
<li><p> If <code>NULL</code> (the default), counts the number of rows in each group.
</p>
</li>
<li><p> If a variable, computes <code>sum(wt)</code> for each group.
</p>
</li></ul>
</td></tr>
<tr><td><code id="fcount_+3A_sort">sort</code></td>
<td>
<p>If <code>TRUE</code>, will show the largest groups at the top.</p>
</td></tr>
<tr><td><code id="fcount_+3A_order">order</code></td>
<td>
<p>Should the groups be calculated as ordered groups?
If <code>FALSE</code>, this will return the groups in order of first appearance,
and in many cases is faster.
If <code>TRUE</code> (the default), the groups are returned in sorted order,
exactly the same way as <code>dplyr::count</code>.</p>
</td></tr>
<tr><td><code id="fcount_+3A_name">name</code></td>
<td>
<p>The name of the new column in the output.
If there's already a column called <code>n</code>,
it will use <code>nn</code>.
If there's a column called <code>n</code> and <code>n</code>n,
it'll use <code>nnn</code>, and so on, adding <code>n</code>s until it gets a new name.</p>
</td></tr>
<tr><td><code id="fcount_+3A_.by">.by</code></td>
<td>
<p>(Optional). A selection of columns to group by for this operation.
Columns are specified using tidy-select.</p>
</td></tr>
<tr><td><code id="fcount_+3A_.cols">.cols</code></td>
<td>
<p>(Optional) alternative to <code>...</code> that accepts
a named character vector or numeric vector.
If speed is an expensive resource, it is recommended to use this.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a fast and near-identical alternative to dplyr::count() using the <code>collapse</code> package.
Unlike <code>collapse::fcount()</code>, this works very similarly to <code>dplyr::count()</code>.
The only main difference is that anything supplied to <code>wt</code>
is recycled and added as a data variable.
Other than that everything works exactly as the dplyr equivalent.
</p>
<p><code>fcount()</code> and <code>fadd_count()</code> can be up to &gt;100x faster than the dplyr equivalents.
</p>


<h3>Value</h3>

<p>A <code>data.frame</code> of frequency counts by group.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(timeplyr)
library(dplyr)

iris %&gt;%
  fcount()
iris %&gt;%
  fadd_count(name = "count") %&gt;%
  fslice_head(n = 10)
iris %&gt;%
  group_by(Species) %&gt;%
  fcount()
iris %&gt;%
  fcount(Species)
iris %&gt;%
  fcount(across(where(is.numeric), mean))

### Sorting behaviour

# Sorted by group
starwars %&gt;%
  fcount(hair_color)
# Sorted by frequency
starwars %&gt;%
  fcount(hair_color, sort = TRUE)
# Groups sorted by order of first appearance (faster)
starwars %&gt;%
  fcount(hair_color, order = FALSE)

</code></pre>

<hr>
<h2 id='fdistinct'>Find distinct rows</h2><span id='topic+fdistinct'></span>

<h3>Description</h3>

<p>Like <code>dplyr::distinct()</code> but faster when lots of
groups are involved.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fdistinct(
  data,
  ...,
  .keep_all = FALSE,
  sort = FALSE,
  order = sort,
  .by = NULL,
  .cols = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fdistinct_+3A_data">data</code></td>
<td>
<p>A data frame.</p>
</td></tr>
<tr><td><code id="fdistinct_+3A_...">...</code></td>
<td>
<p>Variables used to find distinct rows.</p>
</td></tr>
<tr><td><code id="fdistinct_+3A_.keep_all">.keep_all</code></td>
<td>
<p>If <code>TRUE</code> then all columns of data frame are kept,
default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="fdistinct_+3A_sort">sort</code></td>
<td>
<p>Should result be sorted? Default is <code>FALSE</code>.
When <code>order = FALSE</code> this option has no effect on the result.</p>
</td></tr>
<tr><td><code id="fdistinct_+3A_order">order</code></td>
<td>
<p>Should the groups be calculated as ordered groups?
Setting to <code>TRUE</code> may sometimes offer a speed benefit, but usually this
is not the case. The default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="fdistinct_+3A_.by">.by</code></td>
<td>
<p>(Optional). A selection of columns to group by for this operation.
Columns are specified using tidy-select.</p>
</td></tr>
<tr><td><code id="fdistinct_+3A_.cols">.cols</code></td>
<td>
<p>(Optional) alternative to <code>...</code> that accepts
a named character vector or numeric vector.
If speed is an expensive resource, it is recommended to use this.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code> of distinct groups.
</p>


<h3>See Also</h3>

<p><a href="#topic+group_collapse">group_collapse</a> <a href="#topic+duplicate_rows">duplicate_rows</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
library(timeplyr)
library(ggplot2)

mpg %&gt;%
  distinct(manufacturer)
mpg %&gt;%
  fdistinct(manufacturer)

</code></pre>

<hr>
<h2 id='fexpand'>Fast versions of <code>tidyr::expand()</code> and <code>tidyr::complete()</code>.</h2><span id='topic+fexpand'></span><span id='topic+fcomplete'></span>

<h3>Description</h3>

<p>Fast versions of <code>tidyr::expand()</code> and <code>tidyr::complete()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fexpand(
  data,
  ...,
  expand_type = c("crossing", "nesting"),
  sort = FALSE,
  .by = NULL,
  keep_class = TRUE,
  log_limit = 8
)

fcomplete(
  data,
  ...,
  expand_type = c("crossing", "nesting"),
  sort = FALSE,
  .by = NULL,
  keep_class = TRUE,
  fill = NA,
  log_limit = 8
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fexpand_+3A_data">data</code></td>
<td>
<p>A data frame</p>
</td></tr>
<tr><td><code id="fexpand_+3A_...">...</code></td>
<td>
<p>Variables to expand</p>
</td></tr>
<tr><td><code id="fexpand_+3A_expand_type">expand_type</code></td>
<td>
<p>Type of expansion to use where &quot;nesting&quot;
finds combinations already present in the data
(exactly the same as using <code>distinct()</code> but <code>fexpand()</code>
allows new variables to be created on the fly
and columns are sorted in the order given.
&quot;crossing&quot; finds all combinations of values in the group variables.</p>
</td></tr>
<tr><td><code id="fexpand_+3A_sort">sort</code></td>
<td>
<p>Logical. If <code>TRUE</code> expanded/completed variables are sorted.
The default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="fexpand_+3A_.by">.by</code></td>
<td>
<p>(Optional). A selection of columns to group by for this operation.
Columns are specified using tidy-select.</p>
</td></tr>
<tr><td><code id="fexpand_+3A_keep_class">keep_class</code></td>
<td>
<p>Logical.
If <code>TRUE</code> then the class of the input data is retained.
If <code>FALSE</code>, which is sometimes faster, a <code>data.table</code> is returned.</p>
</td></tr>
<tr><td><code id="fexpand_+3A_log_limit">log_limit</code></td>
<td>
<p>The maximum log10 number of rows that can be expanded.
Anything exceeding this will throw an error.</p>
</td></tr>
<tr><td><code id="fexpand_+3A_fill">fill</code></td>
<td>
<p>A named list containing value-name pairs
to fill the named implicit missing values.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For un-grouped data <code>fexpand()</code> is similar in speed to <code>tidyr::expand()</code>.
When the data contain many groups, <code>fexpand()</code> is much much faster (see examples).
</p>
<p>The 2 main differences between <code>fexpand()</code> and <code>tidyr::expand()</code> are that:
</p>

<ul>
<li><p> tidyr style helpers like <code>nesting()</code> and <code>crossing()</code> are ignored.
The type of expansion used is controlled through <code>expand_type</code> and applies to
all supplied variables.
</p>
</li>
<li><p> Expressions are first calculated on the entire ungrouped dataset before being
expanded but within-group expansions will work on variables that already exist
in the dataset.
For example, <code>iris %&gt;% group_by(Species) %&gt;% fexpand(Sepal.Length, Sepal.Width)</code>
will perform a grouped expansion but
<code>iris %&gt;% group_by(Species) %&gt;% fexpand(range(Sepal.Length))</code>
will not.
</p>
</li></ul>

<p>For efficiency, when supplying groups, expansion is done on a by-group basis only if
there are 2 or more variables that aren't part of the grouping.
The reason is that a by-group calculation does not need to be done with 1 expansion variable
as all combinations across groups already exist against that 1 variable.
When <code>expand_type = "nesting"</code> groups are ignored for speed purposes as the result is the same.
</p>
<p>An advantage of <code>fexpand()</code> is that it returns a data frame with the same class
as the input. It also uses <code>data.table</code> for memory efficiency and <code>collapse</code> for speed.
</p>
<p>A future development for <code>fcomplete()</code> would be to only fill values of variables that
correspond only to both additional completed rows and rows that match the expanded rows, are
filled in. For example,
<code>iris %&gt;% mutate(test = NA_real_) %&gt;% complete(Sepal.Length = 0:100, fill = list(test = 0))</code>
fills in all <code>NA</code> values of test, whereas
<code>iris %&gt;% mutate(test = NA_real_) %&gt;% fcomplete(Sepal.Length = 0:100, fill = list(test = 0))</code>
should only fill in values of test that correspond to Sepal.Length values of <code>0:100</code>.
</p>
<p>An additional note to add when <code>expand_type = "nesting"</code> is that if one of the
supplied variables in <code>...</code> does not exist in the data, but can be recycled
to the length of the data, then it is added and treated as a data variable.
</p>


<h3>Value</h3>

<p>A <code>data.frame</code> of expanded groups.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(timeplyr)
library(dplyr)
library(lubridate)
library(nycflights13)

flights %&gt;%
  fexpand(origin, dest)
flights %&gt;%
  fexpand(origin, dest, sort = FALSE)

# Grouped expansions example
# 1 extra group (carrier) this is very quick
flights %&gt;%
  group_by(origin, dest, tailnum) %&gt;%
  fexpand(carrier)

</code></pre>

<hr>
<h2 id='fgroup_by'>'collapse' version of <code>dplyr::group_by()</code></h2><span id='topic+fgroup_by'></span>

<h3>Description</h3>

<p>This works the exact same as <code>dplyr::group_by()</code> and typically
performs around the same speed but uses slightly less memory.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fgroup_by(
  data,
  ...,
  .add = FALSE,
  order = TRUE,
  .by = NULL,
  .cols = NULL,
  .drop = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fgroup_by_+3A_data">data</code></td>
<td>
<p>data frame.</p>
</td></tr>
<tr><td><code id="fgroup_by_+3A_...">...</code></td>
<td>
<p>Variables to group by.</p>
</td></tr>
<tr><td><code id="fgroup_by_+3A_.add">.add</code></td>
<td>
<p>Should groups be added to existing groups?
Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="fgroup_by_+3A_order">order</code></td>
<td>
<p>Should groups be ordered? If <code>FALSE</code>
groups will be ordered based on first-appearance.</p>
</td></tr>
<tr><td><code id="fgroup_by_+3A_.by">.by</code></td>
<td>
<p>(Optional). A selection of columns to group by for this operation.
Columns are specified using <code>tidyselect</code>.</p>
</td></tr>
<tr><td><code id="fgroup_by_+3A_.cols">.cols</code></td>
<td>
<p>(Optional) alternative to <code>...</code> that accepts
a named character vector or numeric vector.
If speed is an expensive resource, it is recommended to use this.</p>
</td></tr>
<tr><td><code id="fgroup_by_+3A_.drop">.drop</code></td>
<td>
<p>Should unused factor levels be dropped? Default is <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>fgroup_by()</code> works almost exactly like the 'dplyr' equivalent.
An attribute &quot;sorted&quot; (<code>TRUE</code> or <code>FALSE</code>) is added to the group data to
signify if the groups are sorted or not.
</p>


<h3>Value</h3>

<p>A <code>grouped_df</code>.
</p>

<hr>
<h2 id='fn'>Supplementary fast statistical functions, <code>collapse</code> style</h2><span id='topic+fn'></span><span id='topic+fcummean'></span><span id='topic+fnmiss'></span><span id='topic+fprop_complete'></span><span id='topic+fprop_missing'></span>

<h3>Description</h3>

<p>Supplementary fast statistical functions, <code>collapse</code> style
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fn(x, g = NULL, sort = TRUE, expand = FALSE, use.g.names = !expand)

fcummean(x, g = NULL, na.rm = FALSE, ...)

fnmiss(x, g = NULL, sort = TRUE, use.g.names = TRUE, na.rm = FALSE)

fprop_complete(x, g = NULL, sort = TRUE, use.g.names = TRUE, na.rm = FALSE)

fprop_missing(x, g = NULL, sort = TRUE, use.g.names = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fn_+3A_x">x</code></td>
<td>
<p>A vector or data frame.
In the case of <code>fn()</code> this can be left unused as long as g is not <code>NULL</code>,
otherwise it is used as a template with which to calculate group sizes.
For example, is <code>x</code> is a vector, lengths are calculated per-group,
and if <code>x</code> is a data frame, numbers of rows are calculated per-group.</p>
</td></tr>
<tr><td><code id="fn_+3A_g">g</code></td>
<td>
<p>Object to be used for grouping,
passed directly to <code>collapse::GRP()</code>.</p>
</td></tr>
<tr><td><code id="fn_+3A_sort">sort</code></td>
<td>
<p>Should the grouped counts be ordered by the sorted groups?
If <code>FALSE</code> the result is ordered by groups of first appearance.</p>
</td></tr>
<tr><td><code id="fn_+3A_expand">expand</code></td>
<td>
<p>Should the grouped counts be expanded to match the length
and order of the data? Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="fn_+3A_use.g.names">use.g.names</code></td>
<td>
<p>If <code>TRUE</code> group names are added to the result as names.
This only applies to <code>fn()</code>. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="fn_+3A_na.rm">na.rm</code></td>
<td>
<p>Should <code>NA</code> values be removed? Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="fn_+3A_...">...</code></td>
<td>
<p>Additional parameters passed to <code>collapse::fsum()</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>fn()</code> Is different to the other <code>collapse</code>
fast statistical functions because given a data frame, it
operates on the entire data frame, instead of column-wise. It is similar
to the the other statistical functions in that order of the returned groups
matches that of <code>collapse::fnobs()</code>.
For example, <code>collapse::GRPN(c(2, 2, 1), expand = FALSE)</code>
returns <code>c(2, 1)</code> whereas <code>fn(g = c(2, 2, 1))</code> returns <code>c(1, 2)</code> which
is similar to <code>collapse::fnobs(rep(1, 3), g = c(2, 2, 1))</code>. <br />
While <code>fn()</code> is not entirely useful as a function, it is useful for
internal code that utilises <code>GRP</code> objects.
</p>

<hr>
<h2 id='frowid'>Fast grouped row numbers</h2><span id='topic+frowid'></span>

<h3>Description</h3>

<p>Very fast row numbers by group.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>frowid(x, ascending = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="frowid_+3A_x">x</code></td>
<td>
<p>A vector, data frame or <code>GRP</code> object.</p>
</td></tr>
<tr><td><code id="frowid_+3A_ascending">ascending</code></td>
<td>
<p>When <code>ascending = TRUE</code> the row IDs are in
increasing order. When <code>ascending = FALSE</code> the row IDs are in
decreasing order.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>frowid()</code> is like <code>data.table::rowid()</code> but uses
an alternative method for calculating row numbers.
When <code>x</code> is a collapse <code>GRP</code> object, it is considerably faster.
It is also faster for character vectors.
</p>


<h3>Value</h3>

<p>An integer vector of row IDs.
</p>


<h3>See Also</h3>

<p><a href="#topic+row_id">row_id</a> <a href="#topic+add_row_id">add_row_id</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(timeplyr)
library(dplyr)
library(data.table)
library(nycflights13)

# Simple row numbers
head(row_id(flights))
# Row numbers by origin
head(frowid(flights$origin))
head(row_id(flights, origin))

# Fast duplicate rows
head(frowid(flights) &gt; 1)

# With data frames, better to use row_id()
flights %&gt;%
  add_row_id() %&gt;% # Plain row ids
  add_row_id(origin, dest, .name = "grouped_row_id") # Row IDs by group

</code></pre>

<hr>
<h2 id='fselect'>Fast <code>dplyr::select()</code>/<code>dplyr::rename()</code></h2><span id='topic+fselect'></span><span id='topic+frename'></span>

<h3>Description</h3>

<p><code>fselect()</code> operates the exact same way as <code>dplyr::select()</code> and
can be used naturally with <code>tidy-select</code> helpers.
It uses collapse to perform the actual selecting of variables and is
considerably faster than dplyr for selecting exact columns,
and even more so when supplying the <code>.cols</code> argument.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fselect(data, ..., .cols = NULL)

frename(data, ..., .cols = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fselect_+3A_data">data</code></td>
<td>
<p>A data frame.</p>
</td></tr>
<tr><td><code id="fselect_+3A_...">...</code></td>
<td>
<p>Variables to select using <code>tidy-select</code>.
See <code>?dplyr::select</code> for more info.</p>
</td></tr>
<tr><td><code id="fselect_+3A_.cols">.cols</code></td>
<td>
<p>(Optional) faster alternative to <code>...</code> that accepts
a named character vector or numeric vector. <br />
No checks on duplicates column names are done when using <code>.cols</code>. <br />
If speed is an expensive resource, it is recommended to use this.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code> of selected columns.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(timeplyr)
library(dplyr)

df &lt;- slice_head(iris, n = 5)
fselect(df, Species, SL = Sepal.Length)
fselect(df, .cols = c("Species", "Sepal.Length"))
fselect(df, all_of(c("Species", "Sepal.Length")))
fselect(df, 5, 1)
fselect(df, .cols = c(5, 1))
df %&gt;%
  fselect(where(is.numeric))

</code></pre>

<hr>
<h2 id='fskim'>Fast alternative to <code>skimr::skim()</code></h2><span id='topic+fskim'></span>

<h3>Description</h3>

<p>Inspired by the brilliant <code>skimr</code> package, this is a fast
alternative that provides an un-grouped data frame summary.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fskim(data, hist = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fskim_+3A_data">data</code></td>
<td>
<p>A data frame.</p>
</td></tr>
<tr><td><code id="fskim_+3A_hist">hist</code></td>
<td>
<p>Logical. If <code>TRUE</code>, histogram spark graphs are produced
in the numeric summary.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>collapse</code> is used to compute the summary statistics and
<code>data.table</code> is used to wrangle the data frames. <br />
Character vectors are internally converted to factors using
<code>collapse::qF()</code>.
</p>


<h3>Value</h3>

<p>A list of length 7 with the elements:
</p>

<ul>
<li> <p><code>nrow</code> - Number of rows
</p>
</li>
<li> <p><code>ncol</code> - Number of columns
</p>
</li>
<li> <p><code>logical</code> - A <code>tibble</code> summary of the logical columns.
</p>
</li>
<li> <p><code>numeric</code> - A <code>tibble</code> summary of the numeric columns.
</p>
</li>
<li> <p><code>date</code> - A <code>tibble</code> summary of the date columns.
</p>
</li>
<li> <p><code>datetime</code> - A <code>tibble</code> summary of the datetime columns.
</p>
</li>
<li> <p><code>categorical</code> - A <code>tibble</code> summary of the categorical columns.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>library(timeplyr)
library(nycflights13)

fskim(flights)

</code></pre>

<hr>
<h2 id='fslice'>Faster <code>dplyr::slice()</code></h2><span id='topic+fslice'></span><span id='topic+fslice_head'></span><span id='topic+fslice_tail'></span><span id='topic+fslice_min'></span><span id='topic+fslice_max'></span><span id='topic+fslice_sample'></span>

<h3>Description</h3>

<p>When there are lots of groups, the <code>fslice()</code> functions are much faster.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fslice(data, ..., .by = NULL, keep_order = FALSE, sort_groups = TRUE)

fslice_head(
  data,
  ...,
  n,
  prop,
  .by = NULL,
  keep_order = FALSE,
  sort_groups = TRUE
)

fslice_tail(
  data,
  ...,
  n,
  prop,
  .by = NULL,
  keep_order = FALSE,
  sort_groups = TRUE
)

fslice_min(
  data,
  order_by,
  ...,
  n,
  prop,
  .by = NULL,
  with_ties = TRUE,
  na_rm = FALSE,
  keep_order = FALSE,
  sort_groups = TRUE
)

fslice_max(
  data,
  order_by,
  ...,
  n,
  prop,
  .by = NULL,
  with_ties = TRUE,
  na_rm = FALSE,
  keep_order = FALSE,
  sort_groups = TRUE
)

fslice_sample(
  data,
  n,
  replace = FALSE,
  prop,
  .by = NULL,
  keep_order = FALSE,
  sort_groups = TRUE,
  weights = NULL,
  seed = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fslice_+3A_data">data</code></td>
<td>
<p>Data frame</p>
</td></tr>
<tr><td><code id="fslice_+3A_...">...</code></td>
<td>
<p>See <code>?dplyr::slice</code> for details.</p>
</td></tr>
<tr><td><code id="fslice_+3A_.by">.by</code></td>
<td>
<p>(Optional). A selection of columns to group by for this operation.
Columns are specified using tidy-select.</p>
</td></tr>
<tr><td><code id="fslice_+3A_keep_order">keep_order</code></td>
<td>
<p>Should the sliced data frame be returned in its original order?
The default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="fslice_+3A_sort_groups">sort_groups</code></td>
<td>
<p>If <code>TRUE</code> (the default) the by-group slices will be
done in order of the sorted groups.
If <code>FALSE</code> the group order is determined by first-appearance in the data.</p>
</td></tr>
<tr><td><code id="fslice_+3A_n">n</code></td>
<td>
<p>Number of rows.</p>
</td></tr>
<tr><td><code id="fslice_+3A_prop">prop</code></td>
<td>
<p>Proportion of rows.</p>
</td></tr>
<tr><td><code id="fslice_+3A_order_by">order_by</code></td>
<td>
<p>Variables to order by.</p>
</td></tr>
<tr><td><code id="fslice_+3A_with_ties">with_ties</code></td>
<td>
<p>Should ties be kept together? The default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="fslice_+3A_na_rm">na_rm</code></td>
<td>
<p>Should missing values in <code>fslice_max()</code> and <code>fslice_min()</code> be removed?
The default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="fslice_+3A_replace">replace</code></td>
<td>
<p>Should <code>fslice_sample()</code> sample with or without replacement?
Default is <code>FALSE</code>, without replacement.</p>
</td></tr>
<tr><td><code id="fslice_+3A_weights">weights</code></td>
<td>
<p>Probability weights used in <code>fslice_sample()</code>.</p>
</td></tr>
<tr><td><code id="fslice_+3A_seed">seed</code></td>
<td>
<p>Seed number defining RNG state.
If supplied, this is only applied <b>locally</b> within the function
and the seed state isn't retained after sampling.
To clarify, whatever seed state was in place before the function call,
is restored to ensure seed continuity.
If left <code>NULL</code> (the default), then the seed is never modified.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>fslice()</code> and friends allow for more flexibility in how you order the by-group slicing. <br />
Furthermore, you can control whether the returned data frame is sliced in
the order of the supplied row indices, or whether the
original order is retained (like <code>dplyr::filter()</code>).
</p>
<p>In <code>fslice()</code>, when <code>length(n) == 1</code>, an optimised method is implemented
that internally uses <code>list_subset()</code>, a fast function for extracting
single elements from single-level lists that contain vectors of the same
type, e.g. integer.
</p>
<p><code>fslice_head()</code> and <code>fslice_tail()</code> are very fast with large numbers of groups.
</p>
<p><code>fslice_sample()</code> is arguably more intuitive as it by default
resamples each entire group without replacement, without having to specify a
maximum group size like in <code>dplyr::slice_sample()</code>.
</p>


<h3>Value</h3>

<p>A <code>data.frame</code> of specified rows.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(timeplyr)
library(dplyr)
library(nycflights13)

flights &lt;- flights %&gt;%
  group_by(origin, dest)

# First row repeated for each group
flights %&gt;%
  fslice(1, 1)
# First row per group
flights %&gt;%
  fslice_head(n = 1)
# Last row per group
flights %&gt;%
  fslice_tail(n = 1)
# Earliest flight per group
flights %&gt;%
  fslice_min(time_hour, with_ties = FALSE)
# Last flight per group
flights %&gt;%
  fslice_max(time_hour, with_ties = FALSE)
# Random sample without replacement by group
# (or stratified random sampling)
flights %&gt;%
  fslice_sample()

</code></pre>

<hr>
<h2 id='gcd'>Greatest common divisor and smallest common multiple</h2><span id='topic+gcd'></span><span id='topic+scm'></span><span id='topic+gcd_diff'></span>

<h3>Description</h3>

<p>Fast greatest common divisor and smallest common multiple
using the Euclidean algorithm.
</p>
<p><code>gcd()</code> returns the greatest common divisor. <br />
<code>scm()</code> returns the smallest common multiple. <br />
<code>gcd_diff()</code> returns the greatest common divisor of numeric differences.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gcd(
  x,
  tol = sqrt(.Machine$double.eps),
  na_rm = TRUE,
  round = TRUE,
  break_early = TRUE
)

scm(x, tol = sqrt(.Machine$double.eps), na_rm = TRUE)

gcd_diff(
  x,
  lag = 1L,
  fill = NA,
  tol = sqrt(.Machine$double.eps),
  na_rm = TRUE,
  round = TRUE,
  break_early = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gcd_+3A_x">x</code></td>
<td>
<p>A <a href="base.html#topic+numeric">numeric</a> vector.</p>
</td></tr>
<tr><td><code id="gcd_+3A_tol">tol</code></td>
<td>
<p>Tolerance. This must
be a single positive number strictly less than 1.</p>
</td></tr>
<tr><td><code id="gcd_+3A_na_rm">na_rm</code></td>
<td>
<p>If <code>TRUE</code> the default, <code>NA</code> values are ignored.</p>
</td></tr>
<tr><td><code id="gcd_+3A_round">round</code></td>
<td>
<p>If <code>TRUE</code> the output is rounded as
<code>round(gcd, digits)</code> where digits is
<code>ceiling(abs(log10(tol))) + 1</code>. <br />
This can potentially reduce floating point errors on
further calculations. <br />
The default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="gcd_+3A_break_early">break_early</code></td>
<td>
<p>This is experimental and
applies only to floating-point numbers.
When <code>TRUE</code> the algorithm will end once <code>gcd &gt; 0 &amp;&amp; gcd &lt; 2 * tol</code>.
This can offer a tremendous speed improvement.
If <code>FALSE</code> the algorithm finishes once it has gone through all elements of <code>x</code>.
The default is <code>TRUE</code>. <br />
For integers, the algorithm always breaks early once <code>gcd &gt; 0 &amp;&amp; gcd &lt;= 1</code>.</p>
</td></tr>
<tr><td><code id="gcd_+3A_lag">lag</code></td>
<td>
<p>Lag of differences.</p>
</td></tr>
<tr><td><code id="gcd_+3A_fill">fill</code></td>
<td>
<p>Value to initialise the algorithm for <code>gcd_diff()</code>.</p>
</td></tr>
</table>


<h3>Details</h3>



<h4>Method</h4>



<h5>GCD</h5>

<p>The GCD is calculated using a binary function that takes input
<code>GCD(gcd, x[i + 1])</code> where the output of this function is passed as input
back into the same function iteratively along the length of <code>x</code>.
The first gcd value is <code>x[1]</code>.
</p>
<p>Zeroes are handled in the following way: <br />
<code>GCD(0, 0) = 0</code> <br />
<code>GCD(a, 0) = a</code> <br />
</p>
<p>This has the nice property that zeroes are essentially ignored.
</p>



<h5>SCM</h5>

<p>This is calculated using the GCD and the formula is: <br />
<code>SCM(x, y) = (abs(x) / GCD(x, y) ) * abs(y)</code>
</p>
<p>If you want to calculate the gcd &amp; lcm for 2 values
instead of a vector of values,
use the internal functions <code>cpp_gcd2</code> and <code>cpp_lcm2</code>.
You can then easily write a vectorised method using these.
</p>




<h3>Value</h3>

<p>A number representing the GCD or SCM.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(timeplyr)
library(bench)

gcd(c(0, 5, 25))
mark(gcd(c(0, 5, 25)))

x &lt;- rnorm(10^6)
gcd(x)
gcd(x, round = TRUE)
mark(gcd(x))

</code></pre>

<hr>
<h2 id='get_time_delay'>Get summary statistics of time delay</h2><span id='topic+get_time_delay'></span>

<h3>Description</h3>

<p>The output is a <code>list</code> containing summary statistics of time delay between two date/datetime vectors.
This can be especially useful in estimating reporting delay for example.
</p>

<ul>
<li> <p><b>data</b> - A data frame containing the origin, end and calculated time delay.
</p>
</li>
<li> <p><b>unit</b> - The chosen time unit.
</p>
</li>
<li> <p><b>num</b> - The number of time units.
</p>
</li>
<li> <p><b>summary</b> - <code>tibble</code> with summary statistics.
</p>
</li>
<li> <p><b>delay</b> - <code>tibble</code> containing the empirical cumulative distribution function
values by time delay.
</p>
</li>
<li> <p><b>plot</b> - A <code>ggplot</code> of the time delay distribution.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>get_time_delay(
  data,
  origin,
  end,
  time_by = 1L,
  time_type = getOption("timeplyr.time_type", "auto"),
  min_delay = -Inf,
  max_delay = Inf,
  probs = c(0.25, 0.5, 0.75, 0.95),
  .by = NULL,
  include_plot = TRUE,
  x_scales = "fixed",
  bw = "SJ",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_time_delay_+3A_data">data</code></td>
<td>
<p>A data frame.</p>
</td></tr>
<tr><td><code id="get_time_delay_+3A_origin">origin</code></td>
<td>
<p>Origin date variable.</p>
</td></tr>
<tr><td><code id="get_time_delay_+3A_end">end</code></td>
<td>
<p>End date variable.</p>
</td></tr>
<tr><td><code id="get_time_delay_+3A_time_by">time_by</code></td>
<td>
<p>Must be one of the three:
</p>

<ul>
<li><p> string, specifying either the unit or the number and unit, e.g
<code>time_by = "days"</code> or <code>time_by = "2 weeks"</code>
</p>
</li>
<li><p> named list of length one, the unit being the name, and
the number the value of the list, e.g. <code>list("days" = 7)</code>.
For the vectorized time functions, you can supply multiple values,
e.g. <code>list("days" = 1:10)</code>.
</p>
</li>
<li><p> Numeric vector. If time_by is a numeric vector and x is not a date/datetime,
then arithmetic is used, e.g <code>time_by = 1</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="get_time_delay_+3A_time_type">time_type</code></td>
<td>
<p>If &quot;auto&quot;, <code>periods</code> are used for
the time expansion when days, weeks, months or years are specified,
and <code>durations</code> are used otherwise.</p>
</td></tr>
<tr><td><code id="get_time_delay_+3A_min_delay">min_delay</code></td>
<td>
<p>The minimum acceptable delay,
all delays less than this are removed before calculation.
Default is <code>min_delay = -Inf</code>.</p>
</td></tr>
<tr><td><code id="get_time_delay_+3A_max_delay">max_delay</code></td>
<td>
<p>The maximum acceptable delay,
all delays greater than this are removed before calculation.
Default is <code>max_delay = Inf</code>.</p>
</td></tr>
<tr><td><code id="get_time_delay_+3A_probs">probs</code></td>
<td>
<p>Probabilities used in the quantile summary.
Default is <code>probs = c(0.25, 0.5, 0.75, 0.95)</code>.</p>
</td></tr>
<tr><td><code id="get_time_delay_+3A_.by">.by</code></td>
<td>
<p>(Optional). A selection of columns to group by for this operation.
Columns are specified using tidy-select.</p>
</td></tr>
<tr><td><code id="get_time_delay_+3A_include_plot">include_plot</code></td>
<td>
<p>Should a <code>ggplot</code> graph of delay distributions be included in the output?</p>
</td></tr>
<tr><td><code id="get_time_delay_+3A_x_scales">x_scales</code></td>
<td>
<p>Option to control how the x-axis is displayed for multiple facets.
Choices are &quot;fixed&quot; or &quot;free_x&quot;.</p>
</td></tr>
<tr><td><code id="get_time_delay_+3A_bw">bw</code></td>
<td>
<p>The smoothing bandwidth selector for the Kernel Density estimator.
If numeric, the standard deviation of the smoothing kernel.
If character, a rule to choose the bandwidth. See <code>?stats::bw.nrd</code> for more details.
The default has been set to &quot;SJ&quot; which implements the Sheather &amp; Jones (1991) method,
as recommended by the R team <code>?stats::density</code>.
This differs from the default implemented by <code>stats::density()</code>
which uses Silverman's rule-of-thumb.</p>
</td></tr>
<tr><td><code id="get_time_delay_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed on to <code>ggplot2::geom_density()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing summary data, summary statistics and an optional <code>ggplot</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(timeplyr)
library(outbreaks)
library(dplyr)

ebola_linelist &lt;- ebola_sim_clean$linelist

# Incubation period distribution

# 95% of individuals experienced an incubation period of &lt;= 26 days
inc_distr_days &lt;- ebola_linelist %&gt;%
  get_time_delay(date_of_infection,
                 date_of_onset,
                 time_by = "days")
head(inc_distr_days$data)
inc_distr_days$unit
inc_distr_days$num
inc_distr_days$summary
head(inc_distr_days$delay) # ECDF and freq by delay
inc_distr_days$plot

# Can change bandwidth selector
inc_distr_days &lt;- ebola_linelist %&gt;%
  get_time_delay(date_of_infection,
                 date_of_onset,
                 time_by = "day",
                 bw = "nrd")
inc_distr_days$plot

# Can choose any time units
inc_distr_weeks &lt;- ebola_linelist %&gt;%
  get_time_delay(date_of_infection,
                 date_of_onset,
                 time_by = "weeks",
                 bw = "nrd")
inc_distr_weeks$plot

</code></pre>

<hr>
<h2 id='group_collapse'>Key group information</h2><span id='topic+group_collapse'></span>

<h3>Description</h3>

<p>Key group information
</p>


<h3>Usage</h3>

<pre><code class='language-R'>group_collapse(
  data,
  ...,
  order = TRUE,
  sort = FALSE,
  ascending = TRUE,
  .by = NULL,
  .cols = NULL,
  id = TRUE,
  size = TRUE,
  loc = TRUE,
  start = TRUE,
  end = TRUE,
  drop = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="group_collapse_+3A_data">data</code></td>
<td>
<p>A data frame or vector.</p>
</td></tr>
<tr><td><code id="group_collapse_+3A_...">...</code></td>
<td>
<p>Additional groups using tidy <code>data-masking</code> rules. <br />
To specify groups using <code>tidyselect</code>, simply use the <code>.by</code> argument.</p>
</td></tr>
<tr><td><code id="group_collapse_+3A_order">order</code></td>
<td>
<p>Should the groups be ordered?
<b>THE PHYSICAL ORDER OF THE DATA IS NOT CHANGED.</b> <br />
When order is <code>TRUE</code> (the default) the group IDs will be ordered but not sorted.
If <code>FALSE</code> the order of the group IDs will be based on first appearance.</p>
</td></tr>
<tr><td><code id="group_collapse_+3A_sort">sort</code></td>
<td>
<p>Should the data frame be sorted by the groups?</p>
</td></tr>
<tr><td><code id="group_collapse_+3A_ascending">ascending</code></td>
<td>
<p>Should groups be ordered in ascending order?
Default is <code>TRUE</code> and only applies when <code>order = TRUE</code>.</p>
</td></tr>
<tr><td><code id="group_collapse_+3A_.by">.by</code></td>
<td>
<p>Alternative way of supplying groups using <code>tidyselect</code> notation.
This is kept to be consistent with other functions.</p>
</td></tr>
<tr><td><code id="group_collapse_+3A_.cols">.cols</code></td>
<td>
<p>(Optional) alternative to <code>...</code> that accepts
a named character vector or numeric vector.
If speed is an expensive resource, it is recommended to use this.</p>
</td></tr>
<tr><td><code id="group_collapse_+3A_id">id</code></td>
<td>
<p>Should group IDs be added? Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="group_collapse_+3A_size">size</code></td>
<td>
<p>Should group sizes be added? Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="group_collapse_+3A_loc">loc</code></td>
<td>
<p>Should group locations be added? Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="group_collapse_+3A_start">start</code></td>
<td>
<p>Should group start locations be added? Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="group_collapse_+3A_end">end</code></td>
<td>
<p>Should group end locations be added? Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="group_collapse_+3A_drop">drop</code></td>
<td>
<p>Should unused factor levels be dropped? Default is <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>group_collapse()</code> is similar to <code>dplyr::group_data()</code> but differs in 3 key regards:
</p>

<ul>
<li><p> The output tries to convey as much information about the groups as possible.
By default, like <code>dplyr</code>, the groups are ordered, but unlike <code>dplyr</code> they are not
sorted, which conveys information on order-of-first-appearance in the data.
In addition to group locations, group sizes and start indices are returned.
</p>
</li>
<li><p> There is more flexibility in specifying how the groups are ordered and/or sorted.
</p>
</li>
<li> <p><code>collapse</code> is used to obtain the grouping structure, which is very fast.
</p>
</li></ul>

<p>There are 3 ways to specify the groups:
</p>

<ul>
<li><p> Using <code>...</code> which utilises <code>tidy</code> <code>data-masking</code>.
</p>
</li>
<li><p> Using <code>.by</code> which utilises <code>tidyselect</code>.
</p>
</li>
<li><p> Using <code>.cols</code> which accepts a named character/integer vector.
</p>
</li></ul>



<h3>Value</h3>

<p>A <code>tibble</code> of unique groups and an integer ID uniquely identifying each group.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(timeplyr)
library(dplyr)

iris &lt;- dplyr::as_tibble(iris)
group_collapse(iris) # No groups
group_collapse(iris, Species) # Species groups

iris %&gt;%
  group_by(Species) %&gt;%
  group_collapse() # Same thing

# Group entire data frame
group_collapse(iris, .by = everything())

</code></pre>

<hr>
<h2 id='group_id'>Fast group IDs</h2><span id='topic+group_id'></span><span id='topic+add_group_id'></span><span id='topic+row_id'></span><span id='topic+add_row_id'></span><span id='topic+group_order'></span><span id='topic+add_group_order'></span>

<h3>Description</h3>

<p>These are tidy-based functions for calculating group IDs, row IDs and
group orders. <br />
</p>

<ul>
<li> <p><code>group_id()</code> returns an integer vector of group IDs the same size as the data.
</p>
</li>
<li> <p><code>row_id()</code> returns an integer vector of row IDs.
</p>
</li>
<li> <p><code>group_order()</code> returns the order of the groups.
</p>
</li></ul>

<p>The <code>add_</code> variants add a column of group IDs/row IDs/group orders.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>group_id(
  data,
  ...,
  order = TRUE,
  ascending = TRUE,
  .by = NULL,
  .cols = NULL,
  as_qg = FALSE
)

add_group_id(
  data,
  ...,
  order = TRUE,
  ascending = TRUE,
  .by = NULL,
  .cols = NULL,
  .name = NULL,
  as_qg = FALSE
)

row_id(data, ..., ascending = TRUE, .by = NULL, .cols = NULL)

add_row_id(data, ..., ascending = TRUE, .by = NULL, .cols = NULL, .name = NULL)

group_order(data, ..., ascending = TRUE, .by = NULL, .cols = NULL)

add_group_order(
  data,
  ...,
  ascending = TRUE,
  .by = NULL,
  .cols = NULL,
  .name = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="group_id_+3A_data">data</code></td>
<td>
<p>A data frame or vector.</p>
</td></tr>
<tr><td><code id="group_id_+3A_...">...</code></td>
<td>
<p>Additional groups using tidy <code>data-masking</code> rules. <br />
To specify groups using <code>tidyselect</code>, simply use the <code>.by</code> argument.</p>
</td></tr>
<tr><td><code id="group_id_+3A_order">order</code></td>
<td>
<p>Should the groups be ordered?
<b>THE PHYSICAL ORDER OF THE DATA IS NOT CHANGED.</b> <br />
When order is <code>TRUE</code> (the default) the group IDs will be
ordered but not sorted.<br />
The expression
</p>
<pre>
identical(order(x, na.last = TRUE),
          order(group_id(x, order = TRUE)))
</pre>
<p>or in the case of a data frame
</p>
<pre>
identical(order(x1, x2, x3, na.last = TRUE),
          order(group_id(data, x1, x2, x3, order = TRUE)))
</pre>
<p>should always hold.<br />
If <code>FALSE</code> the order of the group IDs will be based on first appearance.</p>
</td></tr>
<tr><td><code id="group_id_+3A_ascending">ascending</code></td>
<td>
<p>Should the group order be ascending or descending?
The default is <code>TRUE</code>. <br />
For <code>row_id()</code> this determines if the row IDs are increasing or decreasing. <br />
<b>NOTE</b> - When <code>order = FALSE</code>, the <code>ascending</code> argument is
ignored. This is something that will be fixed in a later version.</p>
</td></tr>
<tr><td><code id="group_id_+3A_.by">.by</code></td>
<td>
<p>Alternative way of supplying groups using <code>tidyselect</code> notation.</p>
</td></tr>
<tr><td><code id="group_id_+3A_.cols">.cols</code></td>
<td>
<p>(Optional) alternative to <code>...</code> that accepts
a named character vector or numeric vector.
If speed is an expensive resource, it is recommended to use this.</p>
</td></tr>
<tr><td><code id="group_id_+3A_as_qg">as_qg</code></td>
<td>
<p>Should the group IDs be returned as a
collapse &quot;qG&quot; class? The default (<code>FALSE</code>) always returns
an integer vector.</p>
</td></tr>
<tr><td><code id="group_id_+3A_.name">.name</code></td>
<td>
<p>Name of the added ID column which should be a
character vector of length 1.
If <code>.name = NULL</code> (the default),
<code>add_group_id()</code> will add a column named &quot;group_id&quot;,
and if one already exists, a unique name will be used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It's important to note for data frames, these functions by default assume
no groups unless you supply them.
</p>
<p>This means that when no groups are supplied:
</p>

<ul>
<li> <p><code>group_id(iris)</code> returns a vector of ones
</p>
</li>
<li> <p><code>row_id(iris)</code> returns the plain row id numbers
</p>
</li>
<li> <p><code>group_order(iris) == row_id(iris)</code>.
</p>
</li></ul>

<p>One can specify groups in the second argument like so:
</p>

<ul>
<li> <p><code>group_id(iris, Species)</code>
</p>
</li>
<li> <p><code>row_id(iris, across(all_of("Species")))</code>
</p>
</li>
<li> <p><code>group_order(iris, across(where(is.numeric), desc))</code>
</p>
</li></ul>

<p>If you want <code>group_id</code> to always use all the columns of a data frame
for grouping
while simultaneously utilising the <code>group_id</code> methods, one can use the below
function.
</p>
<pre>
group_id2 &lt;- function(data, ...){
 group_id(data, ..., .cols = names(data))
}
</pre>


<h3>Value</h3>

<p>An integer vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(timeplyr)
library(dplyr)
library(ggplot2)

group_id(iris) # No groups
group_id(iris, Species) # Species groups
row_id(iris) # Plain row IDs
row_id(iris, Species) # Row IDs by group
# Order of Species + descending Petal.Width
group_order(iris, Species, desc(Petal.Width))
# Same as
order(iris$Species, -xtfrm(iris$Petal.Width))

# Tidy data-masking/tidyselect can be used
group_id(iris, across(where(is.numeric))) # Groups across numeric values
# Alternatively using tidyselect
group_id(iris, .by = where(is.numeric))

# Group IDs using a mixtured order
group_id(iris, desc(Species), Sepal.Length, desc(Petal.Width))

# add_ helpers
iris %&gt;%
  distinct(Species) %&gt;%
  add_group_id(Species)
iris %&gt;%
  add_row_id(Species) %&gt;%
  pull(row_id)

# Usage in data.table
library(data.table)
iris_dt &lt;- as.data.table(iris)
iris_dt[, group_id := group_id(.SD, .cols = names(.SD)),
        .SDcols = "Species"]

# Or if you're using this often you can write a wrapper
set_add_group_id &lt;- function(x, ..., .name = "group_id"){
  id &lt;- group_id(x, ...)
  data.table::set(x, j = .name, value = id)
}
set_add_group_id(iris_dt, desc(Species))[]

mm_mpg &lt;- mpg %&gt;%
  select(manufacturer, model) %&gt;%
  arrange(desc(pick(everything())))

# Sorted/non-sorted groups
mm_mpg %&gt;%
  add_group_id(across(everything()),
               .name = "sorted_id", order = TRUE) %&gt;%
  add_group_id(manufacturer, model,
               .name = "not_sorted_id", order = FALSE) %&gt;%
  distinct()

</code></pre>

<hr>
<h2 id='groups_equal'>Are groups equal?</h2><span id='topic+groups_equal'></span>

<h3>Description</h3>

<p>This function is a very fast utility for quickly checking if
the group data between 2 data frames are identical.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>groups_equal(x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="groups_equal_+3A_x">x</code></td>
<td>
<p>A <code>grouped_df</code>.</p>
</td></tr>
<tr><td><code id="groups_equal_+3A_y">y</code></td>
<td>
<p>A <code>grouped_df</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical indicating whether the groups are identical or not.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
library(timeplyr)

df &lt;- iris %&gt;%
  group_by(Species)
df2 &lt;- iris %&gt;%
  fslice_sample(seed = 1777) %&gt;%
  group_by(Species)

groups_equal(iris, iris)
groups_equal(df, df)
groups_equal(df, df2)

</code></pre>

<hr>
<h2 id='growth'>Rolling basic growth</h2><span id='topic+growth'></span><span id='topic+rolling_growth'></span>

<h3>Description</h3>

<p>Calculate basic growth calculations on a rolling basis.
<code>growth()</code> calculates the percent change between the totals of two numeric vectors
when they're of equal length, otherwise the percent change between the means.
<code>rolling_growth()</code> does the same calculation on 1 numeric vector, on a rolling basis.
Pairs of windows of length <code>n</code>, lagged by the value specified by <code>lag</code> are compared in
a similar manner.
When <code>lag = n</code> then <code>data.table::frollsum()</code> is used,
otherwise <code>data.table::frollmean()</code> is used.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>growth(x, y, na.rm = FALSE, log = FALSE, inf_fill = NULL)

rolling_growth(
  x,
  n = 1,
  lag = n,
  na.rm = FALSE,
  partial = TRUE,
  offset = NULL,
  weights = NULL,
  inf_fill = NULL,
  log = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="growth_+3A_x">x</code></td>
<td>
<p>Numeric vector.</p>
</td></tr>
<tr><td><code id="growth_+3A_y">y</code></td>
<td>
<p>numeric vector</p>
</td></tr>
<tr><td><code id="growth_+3A_na.rm">na.rm</code></td>
<td>
<p>Should missing values be removed when calculating window? Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="growth_+3A_log">log</code></td>
<td>
<p>If <code>TRUE</code> Growth (relative change) in total and mean events will be
calculated on the log-scale.</p>
</td></tr>
<tr><td><code id="growth_+3A_inf_fill">inf_fill</code></td>
<td>
<p>Numeric value to replace <code>Inf</code> values with. Default behaviour is to keep <code>Inf</code> values.</p>
</td></tr>
<tr><td><code id="growth_+3A_n">n</code></td>
<td>
<p>Rolling window size, default is 1.</p>
</td></tr>
<tr><td><code id="growth_+3A_lag">lag</code></td>
<td>
<p>Lag of basic growth comparison, default is the rolling window size.</p>
</td></tr>
<tr><td><code id="growth_+3A_partial">partial</code></td>
<td>
<p>Should rates be calculated outwith the window using partial windows?
If <code>TRUE</code> (the default), (n - 1) pairs of equally-sized rolling windows are compared,
their size increasing by 1 up to size n, at which point the rest of the window pairs are
all of size n. If <code>FALSE</code> all window-pairs will be of size n.</p>
</td></tr>
<tr><td><code id="growth_+3A_offset">offset</code></td>
<td>
<p>Numeric vector of values to use as offset, e.g. population sizes or exposure times.</p>
</td></tr>
<tr><td><code id="growth_+3A_weights">weights</code></td>
<td>
<p>Importance weights. These can either be
length 1 or the same length as x.
Currently, no normalisation of weights occurs.</p>
</td></tr>
<tr><td><code id="growth_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed on to <code>frollmean</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>growth</code> returns a <code>numeric(1)</code> and <code>rolling_growth</code>
returns a <code>numeric(length(x))</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(timeplyr)

set.seed(42)
# Growth rate is 6% per day
x &lt;- 10 * (1.06)^(0:25)

# Simple growth from one day to the next
rolling_growth(x, n = 1)

# Growth comparing rolling 3 day cumulative
rolling_growth(x, n = 3)

# Growth comparing rolling 3 day cumulative, lagged by 1 day
rolling_growth(x, n = 3, lag = 1)

# Growth comparing windows of equal size
rolling_growth(x, n = 3, partial = FALSE)

# Seven day moving average growth
roll_mean(rolling_growth(x), window = 7, partial = FALSE)

</code></pre>

<hr>
<h2 id='growth_rate'>Fast Growth Rates</h2><span id='topic+growth_rate'></span>

<h3>Description</h3>

<p>Calculate the rate of percentage
change per unit time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>growth_rate(x, na.rm = FALSE, log = FALSE, inf_fill = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="growth_rate_+3A_x">x</code></td>
<td>
<p>Numeric vector.</p>
</td></tr>
<tr><td><code id="growth_rate_+3A_na.rm">na.rm</code></td>
<td>
<p>Should missing values be removed when calculating window?
Defaults to <code>FALSE</code>. When <code>na.rm = TRUE</code> the size of the rolling windows
are adjusted to the number of non-<code>NA</code> values in each window.</p>
</td></tr>
<tr><td><code id="growth_rate_+3A_log">log</code></td>
<td>
<p>If <code>TRUE</code> then growth rates are calculated on the log-scale.</p>
</td></tr>
<tr><td><code id="growth_rate_+3A_inf_fill">inf_fill</code></td>
<td>
<p>Numeric value to replace <code>Inf</code> values with.
Default behaviour is to keep <code>Inf</code> values.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It is assumed that <code>x</code> is a vector of values with
a corresponding time index that increases regularly
with no gaps or missing values.
</p>
<p>The output is to be interpreted as the average percent change per unit time.
</p>
<p>For a rolling version that can calculate rates as you move through time,
see <code>roll_growth_rate</code>.
</p>
<p>For a more generalised method that incorporates
time gaps and complex time windows,
use <code>time_roll_growth_rate</code>.
</p>
<p>The growth rate can also be calculated using the
geometric mean of percent changes.
</p>
<p>The below identity should always hold:
</p>
<pre>
`tail(roll_growth_rate(x, window = length(x)), 1) == growth_rate(x)`
</pre>


<h3>Value</h3>

<p><code>numeric(1)</code>
</p>


<h3>See Also</h3>

<p><a href="#topic+roll_growth_rate">roll_growth_rate</a> <a href="#topic+time_roll_growth_rate">time_roll_growth_rate</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(timeplyr)

set.seed(42)
initial_investment &lt;- 100
years &lt;- 1990:2000
# Assume a rate of 8% increase with noise
relative_increases &lt;- 1.08 + rnorm(10, sd = 0.005)

assets &lt;- Reduce(`*`, relative_increases, init = initial_investment, accumulate = TRUE)
assets

# Note that this is approximately 8%
growth_rate(assets)

# We can also calculate the growth rate via geometric mean

rel_diff &lt;- exp(diff(log(assets)))
all.equal(rel_diff, relative_increases)

geometric_mean(rel_diff) == growth_rate(assets)

# Weighted growth rate

w &lt;- c(rnorm(5)^2, rnorm(5)^4)
geometric_mean(rel_diff, weights = w)

# Rolling growth rate over the last n years
roll_growth_rate(assets)

# The same but using geometric means
exp(roll_mean(log(c(NA, rel_diff))))

# Rolling growth rate over the last 5 years
roll_growth_rate(assets, window = 5)
roll_growth_rate(assets, window = 5, partial = FALSE)

## Rolling growth rate with gaps in time

years2 &lt;- c(1990, 1993, 1994, 1997, 1998, 2000)
assets2 &lt;- assets[years %in% years2]

# Below does not incorporate time gaps into growth rate calculation
# But includes helpful warning
time_roll_growth_rate(assets2, window = 5, time = years2)
# Time step allows us to calculate correct rates across time gaps
time_roll_growth_rate(assets2, window = 5, time = years2, time_step = 1) # Time aware

</code></pre>

<hr>
<h2 id='gsum'>Grouped statistical functions.</h2><span id='topic+gsum'></span><span id='topic+gmean'></span><span id='topic+gmin'></span><span id='topic+gmax'></span><span id='topic+gsd'></span><span id='topic+gvar'></span><span id='topic+gmode'></span><span id='topic+gmedian'></span><span id='topic+gfirst'></span><span id='topic+glast'></span><span id='topic+gnobs'></span>

<h3>Description</h3>

<p>These functions are wrappers around the collapse equivalents
but always return a vector the same length and same order as x.<br />
They all accept group IDs for grouped calculations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gsum(x, g = NULL, na.rm = TRUE, ...)

gmean(x, g = NULL, na.rm = TRUE, ...)

gmin(x, g = NULL, na.rm = TRUE, ...)

gmax(x, g = NULL, na.rm = TRUE, ...)

gsd(x, g = NULL, na.rm = TRUE, ...)

gvar(x, g = NULL, na.rm = TRUE, ...)

gmode(x, g = NULL, na.rm = TRUE, ...)

gmedian(x, g = NULL, na.rm = TRUE, ...)

gfirst(x, g = NULL, na.rm = TRUE, ...)

glast(x, g = NULL, na.rm = TRUE, ...)

gnobs(x, g = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gsum_+3A_x">x</code></td>
<td>
<p>An atomic vector.</p>
</td></tr>
<tr><td><code id="gsum_+3A_g">g</code></td>
<td>
<p>Group IDs passed directly to <code>collapse::GRP()</code>.
This can be a vector, list or data frame.</p>
</td></tr>
<tr><td><code id="gsum_+3A_na.rm">na.rm</code></td>
<td>
<p>Should <code>NA</code> values be removed? Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="gsum_+3A_...">...</code></td>
<td>
<p>Additional parameters passed on to the collapse package
equivalents, <code>fsum()</code>, <code>fmean()</code>, <code>fmin()</code>, <code>fmax()</code>,
<code>fsd()</code>, <code>fvar()</code>, <code>fmode()</code>, <code>fmedian()</code>, <code>ffirst()</code>, <code>flast()</code> and
<code>fnobs()</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector the same length as <code>x</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(timeplyr)
library(dplyr)
library(ggplot2)

# Dplyr
iris %&gt;%
  mutate(mean = mean(Sepal.Length), .by = Species)
# Timeplyr
iris %&gt;%
  mutate(mean = gmean(Sepal.Length, g = Species))

# One can utilise pick() to specify multiple groups
mpg %&gt;%
  mutate(mean = gmean(displ, g = pick(manufacturer, model)))

# Alternatively you can create a unique ID for each group
mpg %&gt;%
  add_group_id(manufacturer, model) %&gt;%
  mutate(mean = gmean(displ, g = group_id))

# Another example

iris %&gt;%
  add_group_id(Species, .name = "g") %&gt;%
  mutate(min = gmin(Sepal.Length, g = g),
         max = gmax(Sepal.Length, g = g),
         sum = gsum(Sepal.Length, g = g),
         mean = gmean(Sepal.Length, g = g)) %&gt;%
  # The below is equivalent to above
  mutate(min2 = min(Sepal.Length),
         max2 = max(Sepal.Length),
         sum2 = sum(Sepal.Length),
         mean2 = mean(Sepal.Length),
         .by = Species) %&gt;%
  distinct(Species,
           min, min2,
           max, max2,
           sum, sum2,
           mean, mean2)

</code></pre>

<hr>
<h2 id='gunique'>Grouped <code>unique()</code>, <code>sort()</code> and <code>duplicated()</code></h2><span id='topic+gunique'></span><span id='topic+gduplicated'></span><span id='topic+gwhich_duplicated'></span><span id='topic+gsort'></span><span id='topic+gorder'></span>

<h3>Description</h3>

<p>These functions use <code>collapse</code> and are like the
<code>collapse</code> counterpart but differ in that they accept a group <code>g</code> argument
which allows for more flexible by-group sorting.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gunique(x, g = NULL, sort = FALSE, order = TRUE, use.g.names = TRUE)

gduplicated(x, g = NULL, order = TRUE, all = FALSE)

gwhich_duplicated(x, g = NULL, order = TRUE, all = FALSE)

gsort(x, g = NULL, order = TRUE, use.g.names = TRUE)

gorder(x, g = NULL, order = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gunique_+3A_x">x</code></td>
<td>
<p>A vector or data frame.</p>
</td></tr>
<tr><td><code id="gunique_+3A_g">g</code></td>
<td>
<p>Object used for grouping, passed directly to <code>collapse::GRP()</code>.<br />
This can for example be a vector or data frame.</p>
</td></tr>
<tr><td><code id="gunique_+3A_sort">sort</code></td>
<td>
<p>Should the result be sorted? <br />
This only applies to <code>gunique()</code>.</p>
</td></tr>
<tr><td><code id="gunique_+3A_order">order</code></td>
<td>
<p>Should the groups be treated as ordered groups?
Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="gunique_+3A_use.g.names">use.g.names</code></td>
<td>
<p>Should group names be used? Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="gunique_+3A_all">all</code></td>
<td>
<p>If <code>TRUE</code>, <code>gduplicated()</code> returns all duplicated values,
including the first occurrence.</p>
</td></tr>
</table>

<hr>
<h2 id='is_date'>Utility functions for checking if date or datetime</h2><span id='topic+is_date'></span><span id='topic+is_datetime'></span><span id='topic+is_time'></span><span id='topic+is_time_or_num'></span>

<h3>Description</h3>

<p>Utility functions for checking if date or datetime
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_date(x)

is_datetime(x)

is_time(x)

is_time_or_num(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_date_+3A_x">x</code></td>
<td>
<p>Time variable. <br />
Can be a <code>Date</code>, <code>POSIXt</code>, <code>numeric</code>, <code>integer</code>,
<code>yearmon</code>, <code>yearqtr</code>, <code>year_month</code> or <code>year_quarter</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <a href="base.html#topic+logical">logical</a> of length 1.
</p>

<hr>
<h2 id='is_whole_number'>Are all numbers whole numbers?</h2><span id='topic+is_whole_number'></span>

<h3>Description</h3>

<p>Are all numbers whole numbers?
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_whole_number(x, tol = .Machine$double.eps, na.rm = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_whole_number_+3A_x">x</code></td>
<td>
<p>A numeric vector.</p>
</td></tr>
<tr><td><code id="is_whole_number_+3A_tol">tol</code></td>
<td>
<p>tolerance value. <br />
The default is <code>.Machine$double.eps</code>, essentially the lowest possible tolerance.
A more typical tolerance for double floating point comparisons in other comparisons
is <code>sqrt(.Machine$double.eps)</code>.</p>
</td></tr>
<tr><td><code id="is_whole_number_+3A_na.rm">na.rm</code></td>
<td>
<p>Should <code>NA</code> values be removed before calculation?
Default is <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a very efficient function that returns <code>FALSE</code> if any number
is not a whole-number and <code>TRUE</code> if all of them are.
</p>


<h4>Method</h4>

<p><code>x</code> is defined as a whole number vector
if all numbers satisfy <code>abs(x - round(x)) &lt; tol</code>.
</p>



<h4><code>NA</code> handling</h4>

<p><code>NA</code> values are handled in a custom way. <br />
If <code>x</code> is an integer, <code>TRUE</code> is always returned even if <code>x</code> has missing values. <br />
If <code>x</code> has both missing values and decimal numbers, <code>FALSE</code> is always returned. <br />
If <code>x</code> has missing values, and only whole numbers and <code>na.rm = FALSE</code>, then
<code>NA</code> is returned. <br />
Basically <code>NA</code> is only returned if <code>na.rm = FALSE</code> and
<code>x</code> is a double vector of only whole numbers and <code>NA</code> values.
</p>
<p>Inspired by the discussion in this thread:
<a href="https://stackoverflow.com/questions/3476782/check-if-the-number-is-integer/76655734">check-if-the-number-is-integer</a>
</p>



<h3>Value</h3>

<p>A logical vector of length 1.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(timeplyr)
library(dplyr)

# Has built-in tolerance
sqrt(2)^2 %% 1 == 0
is_whole_number(sqrt(2)^2)

is_whole_number(1)
is_whole_number(1.2)

x1 &lt;- c(0.02, 0:10^5)
x2 &lt;- c(0:10^5, 0.02)

is_whole_number(x1)
is_whole_number(x2)

# Somewhat more strict than all.equal

all.equal(10^9 + 0.0001, round(10^9 + 0.0001))
is_whole_number(10^9 + 0.0001)

# Can safely be used to select whole number variables
starwars %&gt;%
  select(where(is_whole_number))

# To reduce the size of any data frame one can use the below code

df &lt;- starwars %&gt;%
  mutate(across(where(is_whole_number), as.integer))

</code></pre>

<hr>
<h2 id='iso_week'>Efficient, simple and flexible ISO week calculation</h2><span id='topic+iso_week'></span><span id='topic+isoday'></span>

<h3>Description</h3>

<p><code>iso_week()</code> is a flexible function to return formatted
ISO weeks, with optional ISO year and ISO day.
<code>isoday()</code> returns the day of the ISO week.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>iso_week(x, year = TRUE, day = FALSE)

isoday(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="iso_week_+3A_x">x</code></td>
<td>
<p>Date vector.</p>
</td></tr>
<tr><td><code id="iso_week_+3A_year">year</code></td>
<td>
<p>Logical. If <code>TRUE</code> then ISO Year is returned
along with the ISO week.</p>
</td></tr>
<tr><td><code id="iso_week_+3A_day">day</code></td>
<td>
<p>Logical. If <code>TRUE</code> then day of the week is returned
with the ISO week, starting at 1, Monday, and ending at 7, Sunday.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An ISO week vector of class <code>character</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(timeplyr)
library(lubridate)

iso_week(today())
iso_week(today(), day = TRUE)
iso_week(today(), year = FALSE, day = TRUE)
iso_week(today(), year = FALSE, day = FALSE)

</code></pre>

<hr>
<h2 id='missing_dates'>Check for missing dates between first and last date</h2><span id='topic+missing_dates'></span><span id='topic+n_missing_dates'></span>

<h3>Description</h3>

<p>Check for missing dates between first and last date
</p>


<h3>Usage</h3>

<pre><code class='language-R'>missing_dates(x)

n_missing_dates(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="missing_dates_+3A_x">x</code></td>
<td>
<p>A date or datetime vector, or a data frame.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A date vector if x is a vector, or a list if x is a <code>data.frame</code>.
</p>

<hr>
<h2 id='num_na'>Fast number of missing values</h2><span id='topic+num_na'></span>

<h3>Description</h3>

<p>A faster and more efficient alternative to <code>sum(is.na(x))</code>. <br />
Long vectors, i.e vectors with length &gt;= 2^31 are also supported.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>num_na(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="num_na_+3A_x">x</code></td>
<td>
<p>A vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Number of <code>NA</code> values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(timeplyr)
library(bench)

flights &lt;- nycflights13::flights

# num_na is more efficient than using `sum(is.na())`
mark(vapply(flights, num_na, integer(1)),
     vapply(flights, function(x) sum(is.na(x)), integer(1)),
     iterations = 10)

</code></pre>

<hr>
<h2 id='q_summarise'>Fast grouped quantile summary</h2><span id='topic+q_summarise'></span>

<h3>Description</h3>

<p><code>collapse</code> and <code>data.table</code> are used for the calculations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>q_summarise(
  data,
  ...,
  probs = seq(0, 1, 0.25),
  type = 7,
  pivot = c("wide", "long"),
  na.rm = TRUE,
  sort = TRUE,
  .by = NULL,
  .cols = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="q_summarise_+3A_data">data</code></td>
<td>
<p>A data frame.</p>
</td></tr>
<tr><td><code id="q_summarise_+3A_...">...</code></td>
<td>
<p>Variables used to calculate quantiles for.
Tidy data-masking applies.</p>
</td></tr>
<tr><td><code id="q_summarise_+3A_probs">probs</code></td>
<td>
<p>Quantile probabilities.</p>
</td></tr>
<tr><td><code id="q_summarise_+3A_type">type</code></td>
<td>
<p>An integer from 5-9 specifying which algorithm to use.
See <code><a href="stats.html#topic+quantile">quantile</a></code> for more details.</p>
</td></tr>
<tr><td><code id="q_summarise_+3A_pivot">pivot</code></td>
<td>
<p>Should data be pivoted wide or long? Default is <code>wide</code>.</p>
</td></tr>
<tr><td><code id="q_summarise_+3A_na.rm">na.rm</code></td>
<td>
<p>Should <code>NA</code> values be removed? Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="q_summarise_+3A_sort">sort</code></td>
<td>
<p>Should groups be sorted? Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="q_summarise_+3A_.by">.by</code></td>
<td>
<p>(Optional). A selection of columns to group by for this operation.
Columns are specified using tidy-select.</p>
</td></tr>
<tr><td><code id="q_summarise_+3A_.cols">.cols</code></td>
<td>
<p>(Optional) alternative to <code>...</code> that accepts
a named character vector or numeric vector.
If speed is an expensive resource, it is recommended to use this.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.table</code> containing the quantile values for each group.
</p>


<h3>See Also</h3>

<p><a href="#topic+stat_summarise">stat_summarise</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(timeplyr)
library(dplyr)

# Standard quantiles
iris %&gt;%
  q_summarise(Sepal.Length)
# Quantiles by species
iris %&gt;%
  q_summarise(Sepal.Length, .by = Species)
# Quantiles by species across multiple columns
iris %&gt;%
  q_summarise(Sepal.Length, Sepal.Width,
            probs = c(0, 1),
            .by = Species)
# Long format if one desires, useful for ggplot2
iris %&gt;%
  q_summarise(Sepal.Length, pivot = "long",
            .by = Species)
# Example with lots of groups
set.seed(20230606)
df &lt;- data.frame(x = rnorm(10^5),
                 g = sample.int(10^5, replace = TRUE))
q_summarise(df, x, .by = g, sort = FALSE)

</code></pre>

<hr>
<h2 id='roll_apply'>By-group rolling functions</h2><span id='topic+roll_apply'></span>

<h3>Description</h3>

<p>Apply any function on a rolling basis
for each group using one-pass through the data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>roll_apply(
  x,
  fun,
  before = Inf,
  after = 0L,
  g = NULL,
  partial = TRUE,
  default = NULL,
  unlist = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="roll_apply_+3A_x">x</code></td>
<td>
<p>Numeric vector, data frame, or list.</p>
</td></tr>
<tr><td><code id="roll_apply_+3A_fun">fun</code></td>
<td>
<p>A function.</p>
</td></tr>
<tr><td><code id="roll_apply_+3A_before">before</code></td>
<td>
<p>A number denoting how many indices
to look backward on a rolling basis.</p>
</td></tr>
<tr><td><code id="roll_apply_+3A_after">after</code></td>
<td>
<p>A number denoting how many indices to look forward on a rolling
basis.</p>
</td></tr>
<tr><td><code id="roll_apply_+3A_g">g</code></td>
<td>
<p>Grouping object passed directly to <code>collapse::GRP()</code>.
This can for example be a vector or data frame.</p>
</td></tr>
<tr><td><code id="roll_apply_+3A_partial">partial</code></td>
<td>
<p>Should calculations be done using partial windows?
Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="roll_apply_+3A_default">default</code></td>
<td>
<p>Default value for each list element.</p>
</td></tr>
<tr><td><code id="roll_apply_+3A_unlist">unlist</code></td>
<td>
<p>If <code>TRUE</code>, the result is passed to <code>unlist()</code>.
The default is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>roll_apply</code> accepts any user function which makes it more flexible
than the other rolling functions but much less efficient. <br />
<code>roll_apply2</code> is an alternative to <code>roll_apply</code> that instead accepts
a vector of window sizes. The window sizes can be easily created
using <code>window_sequence()</code>.
</p>


<h3>Value</h3>

<p>A list the same length as <code>x</code> unless <code>unlist</code> is <code>TRUE</code>.
</p>


<h3>See Also</h3>

<p><a href="#topic+time_roll_apply">time_roll_apply</a> <a href="#topic+roll_sum">roll_sum</a> <a href="#topic+roll_growth_rate">roll_growth_rate</a>
</p>

<hr>
<h2 id='roll_lag'>Fast rolling grouped lags and differences</h2><span id='topic+roll_lag'></span><span id='topic+roll_diff'></span><span id='topic+lag_seq'></span><span id='topic+lag_'></span><span id='topic+lead_'></span><span id='topic+diff_'></span>

<h3>Description</h3>

<p>Inspired by 'collapse', <code>roll_lag</code> and <code>roll_diff</code> operate similarly to
<code>flag</code> and <code>fdiff</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>roll_lag(x, n = 1L, g = NULL, fill = NULL)

roll_diff(x, n = 1L, g = NULL, fill = NULL)

lag_seq(size, n = 1L, partial = FALSE)

lag_(x, n = 1L, fill = NA)

lead_(x, n = 1L, fill = NA)

diff_(x, n = 1L, fill = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="roll_lag_+3A_x">x</code></td>
<td>
<p>A vector.</p>
</td></tr>
<tr><td><code id="roll_lag_+3A_n">n</code></td>
<td>
<p>Lag. Either length 1 or the same length as <code>x.</code>
This can also be negative.</p>
</td></tr>
<tr><td><code id="roll_lag_+3A_g">g</code></td>
<td>
<p>Grouping vector. This can be a vector, data frame or <code>GRP</code> object.</p>
</td></tr>
<tr><td><code id="roll_lag_+3A_fill">fill</code></td>
<td>
<p>Value to fill the first <code>n</code> elements.</p>
</td></tr>
<tr><td><code id="roll_lag_+3A_size">size</code></td>
<td>
<p>Size of lag sequence.</p>
</td></tr>
<tr><td><code id="roll_lag_+3A_partial">partial</code></td>
<td>
<p>If <code>TRUE</code>, the sequence will increment from 0 up to the
lag value. When calculating differences this can be useful,
as passing this lag sequence to
<code>roll_diff</code> will produce differences compared to the first value of <code>x</code>
for the first <code>n</code> differences.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>While these may not be as fast the 'collapse' equivalents,
they are adequately fast and efficient. <br />
A key difference between <code>roll_lag</code> and <code>flag</code> is that <code>g</code> does not need
to be sorted for the result to be correct. <br />
Furthermore, a vector of lags can be supplied for a custom rolling lag.
In this case, groups are ignored. <br />
For time-based lags, see <a href="#topic+time_lag">time_lag</a>.
</p>
<p><code>lag_</code>, <code>lead_</code> and <code>diff_</code> are wrappers around the 'c++' functions that offer
very low overhead of ~1 microsecond and thus are primarily for programmers.
</p>


<h3>Value</h3>

<p>A vector the same length as <code>x</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(timeplyr)

x &lt;- 1:10

roll_lag(x) # Lag
roll_lag(x, -1) # Lead
roll_diff(x) # Lag diff
roll_diff(x, -1) # Lead diff

# Using lag_seq()
roll_lag(x, lag_seq(length(x), 2))
roll_diff(x, lag_seq(length(x), 5, partial = TRUE))

# Like diff() but x/y instead of x-y
quotient &lt;- function(x, n = 1L){
  x / roll_lag(x, n)
}
# People often call this a growth rate
# but it's just a percentage difference
# See ?roll_growth_rate for growth rate calculations
quotient(1:10)

</code></pre>

<hr>
<h2 id='roll_na_fill'>Fast grouped &quot;locf&quot; <code>NA</code> fill</h2><span id='topic+roll_na_fill'></span><span id='topic+.roll_na_fill'></span>

<h3>Description</h3>

<p>A fast and efficient by-group method for
&quot;last-observation-carried-forward&quot; <code>NA</code> filling.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>roll_na_fill(x, g = NULL, fill_limit = Inf)

.roll_na_fill(x, fill_limit = Inf)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="roll_na_fill_+3A_x">x</code></td>
<td>
<p>A vector.</p>
</td></tr>
<tr><td><code id="roll_na_fill_+3A_g">g</code></td>
<td>
<p>An object use for grouping x
This may be a vector or data frame for example.</p>
</td></tr>
<tr><td><code id="roll_na_fill_+3A_fill_limit">fill_limit</code></td>
<td>
<p>(Optional) maximum number of consecutive NAs to fill
per <code>NA</code> cluster. Default is <code>Inf</code>.</p>
</td></tr>
</table>


<h3>Details</h3>



<h4>Method</h4>

<p>When supplying groups using <code>g</code>, this method uses <code>radixorder(g)</code> to
specify how to loop through <code>x</code>, making this extremely efficient.
</p>
<p>When <code>x</code> contains zero or all <code>NA</code> values, then <code>x</code> is returned with no copy
made.
</p>
<p><code>.roll_na_fill()</code> is the same as <code>roll_na_fill()</code> but without a g argument and
it performs no sanity checks. It is passed straight to c++ which makes it efficient for
loops.
</p>



<h3>Value</h3>

<p>A filled vector of <code>x</code> the same length as <code>x</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(timeplyr)
library(dplyr)
library(data.table)

words &lt;- do.call(paste0,
                 do.call(expand.grid, rep(list(letters), 3)))
groups &lt;- sample(words, size = 10^5, replace = TRUE)
x &lt;- sample.int(10^2, 10^5, TRUE)
x[sample.int(10^5, 10^4)] &lt;- NA

dt &lt;- data.table(x, groups)

roll_na_fill(x, groups)

library(zoo)

  # Summary
# Latest version of vctrs with their vec_fill_missing
# Is the fastest but not most memory efficient
# For low repetitions and large vectors, data.table is best

# For large numbers of repetitions (groups) and data
# that is sorted by groups
# timeplyr is fastest

# No groups
bench::mark(e1 = dt[, filled1 := timeplyr::roll_na_fill(x)][]$filled1,
            e2 = dt[, filled2 := data.table::nafill(x, type = "locf")][]$filled2,
            e3 = dt[, filled3 := vctrs::vec_fill_missing(x)][]$filled3,
            e4 = dt[, filled4 := zoo::na.locf0(x)][]$filled4,
            e5 = dt[, filled5 := timeplyr::.roll_na_fill(x)][]$filled5)
# With group
bench::mark(e1 = dt[, filled1 := timeplyr::roll_na_fill(x, groups)][]$filled1,
            e2 = dt[, filled2 := data.table::nafill(x, type = "locf"), by = groups][]$filled2,
            e3 = dt[, filled3 := vctrs::vec_fill_missing(x), by = groups][]$filled3,
            e4 = dt[, filled4 := timeplyr::.roll_na_fill(x), by = groups][]$filled4)
# Data sorted by groups
setkey(dt, groups)
bench::mark(e1 = dt[, filled1 := timeplyr::roll_na_fill(x, groups)][]$filled1,
            e2 = dt[, filled2 := data.table::nafill(x, type = "locf"), by = groups][]$filled2,
            e3 = dt[, filled3 := vctrs::vec_fill_missing(x), by = groups][]$filled3,
            e4 = dt[, filled4 := timeplyr::.roll_na_fill(x), by = groups][]$filled4)


</code></pre>

<hr>
<h2 id='roll_sum'>Fast by-group rolling functions</h2><span id='topic+roll_sum'></span><span id='topic+roll_mean'></span><span id='topic+roll_geometric_mean'></span><span id='topic+roll_harmonic_mean'></span><span id='topic+roll_growth_rate'></span>

<h3>Description</h3>

<p>An efficient method for rolling sum, mean and growth rate for many groups.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>roll_sum(
  x,
  window = Inf,
  g = NULL,
  partial = TRUE,
  weights = NULL,
  na.rm = TRUE,
  ...
)

roll_mean(
  x,
  window = Inf,
  g = NULL,
  partial = TRUE,
  weights = NULL,
  na.rm = TRUE,
  ...
)

roll_geometric_mean(
  x,
  window = Inf,
  g = NULL,
  partial = TRUE,
  weights = NULL,
  na.rm = TRUE,
  ...
)

roll_harmonic_mean(
  x,
  window = Inf,
  g = NULL,
  partial = TRUE,
  weights = NULL,
  na.rm = TRUE,
  ...
)

roll_growth_rate(
  x,
  window = Inf,
  g = NULL,
  partial = TRUE,
  na.rm = FALSE,
  log = FALSE,
  inf_fill = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="roll_sum_+3A_x">x</code></td>
<td>
<p>Numeric vector, data frame, or list.</p>
</td></tr>
<tr><td><code id="roll_sum_+3A_window">window</code></td>
<td>
<p>Rolling window size, default is <code>Inf</code>.</p>
</td></tr>
<tr><td><code id="roll_sum_+3A_g">g</code></td>
<td>
<p>Grouping object passed directly to <code>collapse::GRP()</code>.
This can for example be a vector or data frame.</p>
</td></tr>
<tr><td><code id="roll_sum_+3A_partial">partial</code></td>
<td>
<p>Should calculations be done using partial windows?
Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="roll_sum_+3A_weights">weights</code></td>
<td>
<p>Importance weights. Must be the same length as x.
Currently, no normalisation of weights occurs.</p>
</td></tr>
<tr><td><code id="roll_sum_+3A_na.rm">na.rm</code></td>
<td>
<p>Should missing values be removed for the calculation?
The default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="roll_sum_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code>data.table::frollmean</code> and
<code>data.table::frollsum</code>.</p>
</td></tr>
<tr><td><code id="roll_sum_+3A_log">log</code></td>
<td>
<p>For <code>roll_growth_rate</code>:
If <code>TRUE</code> then growth rates are calculated on the log-scale.</p>
</td></tr>
<tr><td><code id="roll_sum_+3A_inf_fill">inf_fill</code></td>
<td>
<p>For <code>roll_growth_rate</code>:
Numeric value to replace <code>Inf</code> values with.
Default behaviour is to keep <code>Inf</code> values.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>roll_sum</code> and <code>roll_mean</code> support parallel computations when
<code>x</code> is a data frame of multiple columns. <br />
<code>roll_geometric_mean</code> and <code>roll_harmonic_mean</code> are convenience functions that
utilise <code>roll_mean</code>. <br />
<code>roll_growth_rate</code> calculates the rate of percentage
change per unit time on a rolling basis.
</p>


<h3>Value</h3>

<p>A numeric vector the same length as <code>x</code> when <code>x</code> is a vector,
or a list when <code>x</code> is a <code>data.frame</code>. <br />
</p>


<h3>See Also</h3>

<p><a href="#topic+time_roll_mean">time_roll_mean</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(timeplyr)

x &lt;- 1:10
roll_sum(x) # Simple rolling total
roll_mean(x) # Simple moving average
roll_sum(x, window = 3)
roll_mean(x, window = 3)
roll_sum(x, window = 3, partial = FALSE)
roll_mean(x, window = 3, partial = FALSE)

# Plot of expected value of 'coin toss' over many flips
set.seed(42)
x &lt;- sample(c(1, 0), 10^3, replace = TRUE)
ev &lt;- roll_mean(x)
plot(ev)
abline(h = 0.5, lty = 2)

all.equal(roll_sum(iris$Sepal.Length, g = iris$Species),
          ave(iris$Sepal.Length, iris$Species, FUN = cumsum))
# The below is run using parallel computations where applicable
roll_sum(iris[, 1:4], window = 7, g = iris$Species)

  library(data.table)
  library(bench)
  df &lt;- data.table(g = sample.int(10^4, 10^5, TRUE),
                   x = rnorm(10^5))
  mark(e1 = df[, mean := frollmean(x, n = 7,
                                   align = "right", na.rm = FALSE), by = "g"]$mean,
       e2 = df[, mean := roll_mean(x, window = 7, g = get("g"),
                                   partial = FALSE, na.rm = FALSE)]$mean)


</code></pre>

<hr>
<h2 id='sequence2'>Utilities for creating useful sequences</h2><span id='topic+sequence2'></span><span id='topic+seq_id'></span><span id='topic+seq_v'></span><span id='topic+seq_size'></span><span id='topic+window_sequence'></span><span id='topic+lag_sequence'></span><span id='topic+lead_sequence'></span>

<h3>Description</h3>

<p><code>sequence2</code> is an extension to <a href="base.html#topic+sequence">sequence</a> which
accepts decimal number increments. <br />
<code>seq_id</code> can be paired with <code>sequence2</code> to group individual sequences. <br />
<code>seq_v</code> is a vectorised version of <a href="base.html#topic+seq">seq</a>. <br />
<code>window_sequence</code> creates a vector of window sizes for rolling calculations. <br />
<code>lag_sequence</code> creates a vector of lags for rolling calculations. <br />
<code>lead_sequence</code> creates a vector of leads for rolling calculations. <br />
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sequence2(size, from = 1L, by = 1L)

seq_id(size)

seq_v(from = 1L, to = 1L, by = 1L)

seq_size(from, to, by = 1L)

window_sequence(size, k, partial = TRUE, ascending = TRUE)

lag_sequence(size, k, partial = TRUE)

lead_sequence(size, k, partial = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sequence2_+3A_size">size</code></td>
<td>
<p>Vector of sequence lengths.</p>
</td></tr>
<tr><td><code id="sequence2_+3A_from">from</code></td>
<td>
<p>Start of sequence(s).</p>
</td></tr>
<tr><td><code id="sequence2_+3A_by">by</code></td>
<td>
<p>Unit increment of sequence(s).</p>
</td></tr>
<tr><td><code id="sequence2_+3A_to">to</code></td>
<td>
<p>End of sequence(s).</p>
</td></tr>
<tr><td><code id="sequence2_+3A_k">k</code></td>
<td>
<p>Window/lag size.</p>
</td></tr>
<tr><td><code id="sequence2_+3A_partial">partial</code></td>
<td>
<p>Should partial windows/lags be returned? Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="sequence2_+3A_ascending">ascending</code></td>
<td>
<p>Should window sequence be ascending? Default is <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>sequence2()</code> works in the same way as <code>sequence()</code> but can accept
non-integer <code>by</code> values.
It also recycles <code>from</code> and <code>to</code>, in the same way as <code>sequence()</code>. <br />
If any of the sequences contain values &gt; <code>.Machine$integer.max</code>,
then the result will always be a double vector.
</p>
<p><code>from</code> can be also be a date, date-time, or any object that supports
addition and multiplication.
</p>
<p><code>seq_v()</code> is a vectorised version of <code>seq()</code> that strictly accepts
only the arguments <code>from</code>, <code>to</code> and <code>by</code>. <br />
</p>


<h3>Value</h3>

<p>A vector of length <code>sum(size)</code> except for <code>seq_v</code> which
returns a vector of size <code>sum((to - from) / (by + 1))</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(timeplyr)

sequence(1:3)
sequence2(1:3)

sequence(1:3, by = 0.1)
sequence2(1:3, by = 0.1)

sequence(c(3, 2), by = c(-0.1, 0.1))
sequence2(c(3, 2), by = c(-0.1, 0.1))

# We can group sequences using seq_id
size &lt;- c(7, 0, 3)
from &lt;- 1
by &lt;- c(-0.1, 0.1, 1/3)
x &lt;- sequence2(size, from, by)
names(x) &lt;- seq_id(size)
x

# Vectorised version of seq()
seq_v(1, 10, by = c(1, 0.5))
# Same as below
c(seq(1, 10, 1), seq(1, 10, 0.5))

# Programmers may use seq_size() to determine final sequence lengths

sizes &lt;- seq_size(1, 10, by = c(1, 0.5))
print(paste(c("sequence sizes: (", sizes, ") total size:", sum(sizes)),
            collapse = " "))

# We can group sequences using seq_id

from &lt;- Sys.Date()
to &lt;- from + 10
by &lt;- c(1, 2, 3)
x &lt;- seq_v(from, to, by)
names(x) &lt;- seq_id(seq_size(from, to, by))
x

# Utilities for rolling calculations

window_sequence(c(3, 5), 3)
window_sequence(c(3, 5), 3, partial = FALSE)
window_sequence(c(3, 5), 3, partial = TRUE, ascending = FALSE)
# One can for example use these in data.table::frollsum

</code></pre>

<hr>
<h2 id='stat_summarise'>Fast grouped statistical summary for data frames.</h2><span id='topic+stat_summarise'></span><span id='topic+.stat_fns'></span>

<h3>Description</h3>

<p><code>collapse</code> and <code>data.table</code> are used for the calculations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stat_summarise(
  data,
  ...,
  stat = c("n", "nmiss", "ndistinct"),
  q_probs = NULL,
  na.rm = TRUE,
  sort = TRUE,
  .names = NULL,
  .by = NULL,
  .cols = NULL,
  as_tbl = FALSE
)

.stat_fns
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stat_summarise_+3A_data">data</code></td>
<td>
<p>A data frame.</p>
</td></tr>
<tr><td><code id="stat_summarise_+3A_...">...</code></td>
<td>
<p>Variables to apply the statistical functions to.
Tidy data-masking applies.</p>
</td></tr>
<tr><td><code id="stat_summarise_+3A_stat">stat</code></td>
<td>
<p>A character vector of statistical summaries to apply.
This can be one or more of the following: <br />
&quot;n&quot;, &quot;nmiss&quot;, &quot;ndistinct&quot;, &quot;min&quot;, &quot;max&quot;, &quot;mean&quot;, &quot;first&quot;, &quot;last&quot;, &quot;sd&quot;,
&quot;var&quot;, &quot;mode&quot;, &quot;median&quot;, &quot;sum&quot;, &quot;prop_complete&quot;.</p>
</td></tr>
<tr><td><code id="stat_summarise_+3A_q_probs">q_probs</code></td>
<td>
<p>(Optional) Quantile probabilities.
If supplied, <code>q_summarise()</code> is called and added to the result.</p>
</td></tr>
<tr><td><code id="stat_summarise_+3A_na.rm">na.rm</code></td>
<td>
<p>Should <code>NA</code> values be removed? Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="stat_summarise_+3A_sort">sort</code></td>
<td>
<p>Should groups be sorted? Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="stat_summarise_+3A_.names">.names</code></td>
<td>
<p>An optional glue specification passed to <code>stringr::glue()</code>.
If <code>.names = NULL</code>, then when there is 1 variable, the function name
is used, i.e <code>.names = "{.fn}"</code>, when there are multiple variables and
1 function, the variable names are used, i.e, <code>.names = "{.col}"</code>
and in the case of multiple variables and functions.
<code>"{.col}_{.fn}"</code> is used.</p>
</td></tr>
<tr><td><code id="stat_summarise_+3A_.by">.by</code></td>
<td>
<p>(Optional). A selection of columns to group by for this operation.
Columns are specified using tidy-select.</p>
</td></tr>
<tr><td><code id="stat_summarise_+3A_.cols">.cols</code></td>
<td>
<p>(Optional) alternative to <code>...</code> that accepts
a named character vector or numeric vector.
If speed is an expensive resource, it is recommended to use this.</p>
</td></tr>
<tr><td><code id="stat_summarise_+3A_as_tbl">as_tbl</code></td>
<td>
<p>Should the result be a <code>tibble</code>? Default is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Format</h3>

<p><code>.stat_fns</code>
</p>
<p>An object of class <code>character</code> of length 14.
</p>


<h3>Details</h3>

<p><code>stat_summarise()</code> can apply multiple functions to multiple variables.
</p>
<p><code>stat_summarise()</code> is equivalent to <br />
<code>data %&gt;% group_by(...) %&gt;% summarise(across(..., list(...)))</code> <br />
but is faster and more efficient and accepts limited statistical functions.
</p>


<h3>Value</h3>

<p>A summary <code>data.table</code> containing the summary values for each group.
</p>


<h3>See Also</h3>

<p><a href="#topic+q_summarise">q_summarise</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(timeplyr)
library(dplyr)

stat_df &lt;- iris %&gt;%
  stat_summarise(Sepal.Length, .by = Species)
# Join quantile info too
q_df &lt;- iris %&gt;%
  q_summarise(Sepal.Length, .by = Species)
summary_df &lt;- left_join(stat_df, q_df, by = "Species")
summary_df

# Multiple cols
iris %&gt;%
  group_by(Species) %&gt;%
  stat_summarise(across(contains("Width")),
            stat = c("min", "max", "mean", "sd"))

</code></pre>

<hr>
<h2 id='time_aggregate'>Aggregate time to a higher unit</h2><span id='topic+time_aggregate'></span>

<h3>Description</h3>

<p>Aggregate time to a higher unit for possibly many groups
with respect to a time index.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>time_aggregate(
  x,
  time_by = NULL,
  g = NULL,
  time_type = getOption("timeplyr.time_type", "auto"),
  roll_month = getOption("timeplyr.roll_month", "preday"),
  roll_dst = getOption("timeplyr.roll_dst", "boundary"),
  direction = c("l2r", "r2l")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="time_aggregate_+3A_x">x</code></td>
<td>
<p>Time vector. <br />
Can be a <code>Date</code>, <code>POSIXt</code>, <code>numeric</code>, <code>integer</code>,
<code>yearmon</code>, or <code>yearqtr</code> vector.</p>
</td></tr>
<tr><td><code id="time_aggregate_+3A_time_by">time_by</code></td>
<td>
<p>Time unit. <br />
Must be one of the following:
</p>

<ul>
<li><p> string, e.g <code>time_by = "day"</code> or <code>time_by = "2 weeks"</code>
</p>
</li>
<li><p> lubridate duration or period object, e.g. <code>days(1)</code> or <code>ddays(1)</code>.
</p>
</li>
<li><p> named list of length one, e.g. <code>list("days" = 7)</code>.
</p>
</li>
<li><p> Numeric vector, e.g. <code>time_by = 7</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="time_aggregate_+3A_g">g</code></td>
<td>
<p>Grouping object passed directly to <code>collapse::GRP()</code>.
This can for example be a vector or data frame.</p>
</td></tr>
<tr><td><code id="time_aggregate_+3A_time_type">time_type</code></td>
<td>
<p>If &quot;auto&quot;, <code>periods</code> are used for
the time expansion when days, weeks, months or years are specified,
and <code>durations</code> are used otherwise.</p>
</td></tr>
<tr><td><code id="time_aggregate_+3A_roll_month">roll_month</code></td>
<td>
<p>Control how impossible dates are handled when
month or year arithmetic is involved.</p>
</td></tr>
<tr><td><code id="time_aggregate_+3A_roll_dst">roll_dst</code></td>
<td>
<p>See <code>?timechange::time_add</code> for the full list of details.</p>
</td></tr>
<tr><td><code id="time_aggregate_+3A_direction">direction</code></td>
<td>
<p>Direction with which to aggregate time,
&quot;l2r&quot; (&quot;left-to-right&quot;) or &quot;r2l&quot; (&quot;right-to-left&quot;).
If &quot;l2r&quot; (the default), then the minimum time is used as the
reference time, otherwise the maximum time is used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>time_aggregate</code> aggregates time using
distinct moving time range blocks of a specified time unit.
</p>
<p>The actual calculation is extremely simple and essentially requires
a subtraction, a rounding and an addition.
</p>
<p>If for example <code>time_by = "week"</code> then all dates or datetimes
will be shifted backwards (or forwards if direction is &quot;r2l&quot;) to the
nearest start of the week, where the start of week is based on <code>min(x)</code>.
This is identical to building a weekly sequence and using this as
breakpoints to cut <code>x</code>. No time expansion occurs so this is very efficient
except when <code>periods</code> are used and there is a lot of data.
In this case, provided the expansion is not too big,
it may be more efficient to cut the data using the period sequence which can
be achieved using <code>time_summarisev</code>.
</p>


<h3>Value</h3>

<p>A time aggregated vector the same class and length as <code>x</code>.
</p>


<h3>See Also</h3>

<p><a href="#topic+time_summarisev">time_summarisev</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(timeplyr)
library(nycflights13)
library(lubridate)
library(dplyr)

sunique &lt;- function(x) sort(unique(x))

hours &lt;- sunique(flights$time_hour)
days &lt;- as_date(hours)

# Aggregate by week or any time unit easily
unique(time_aggregate(hours, "week"))
unique(time_aggregate(hours, ddays(14)))
unique(time_aggregate(hours, "month"))
unique(time_aggregate(days, "month"))

# Left aligned
unique(time_aggregate(days, "quarter"))
# Right aligned
unique(time_aggregate(days, "quarter", direction = "r2l"))

# Very fast by group aggregation
week_by_tailnum &lt;- time_aggregate(flights$time_hour, time_by = ddays(7),
                                  g = flights$tailnum)
# Confirm this has been done by group as each group will have a
# Different aggregate start date
flights %&gt;%
  mutate(week_by_tailnum) %&gt;%
  stat_summarise(week_by_tailnum, .by = tailnum, stat = "min",
                 sort = FALSE)

</code></pre>

<hr>
<h2 id='time_by'>Group by a time variable at a higher time unit</h2><span id='topic+time_by'></span><span id='topic+time_by_span'></span><span id='topic+time_by_var'></span><span id='topic+time_by_units'></span>

<h3>Description</h3>

<p><code>time_by</code> groups a time variable by a specified time unit like
for example &quot;days&quot; or &quot;weeks&quot;. <br />
It can be used exactly like <code>dplyr::group_by</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>time_by(
  data,
  time,
  time_by_unit = NULL,
  from = NULL,
  to = NULL,
  .name = "{.col}",
  .add = FALSE,
  time_type = getOption("timeplyr.time_type", "auto"),
  time_floor = FALSE,
  week_start = getOption("lubridate.week.start", 1),
  roll_month = getOption("timeplyr.roll_month", "preday"),
  roll_dst = getOption("timeplyr.roll_dst", "boundary"),
  .time_by_group = TRUE
)

time_by_span(x)

time_by_var(x)

time_by_units(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="time_by_+3A_data">data</code></td>
<td>
<p>A data frame.</p>
</td></tr>
<tr><td><code id="time_by_+3A_time">time</code></td>
<td>
<p>Time variable (<b>data-masking</b>). <br />
Can be a <code>Date</code>, <code>POSIXt</code>, <code>numeric</code>, <code>integer</code>, <code>yearmon</code>, or <code>yearqtr</code>.</p>
</td></tr>
<tr><td><code id="time_by_+3A_time_by_unit">time_by_unit</code></td>
<td>
<p>Time unit. <br />
Must be one of the following:
</p>

<ul>
<li><p> string, specifying either the unit or the number and unit, e.g
<code>time_by = "days"</code> or <code>time_by = "2 weeks"</code>
</p>
</li>
<li><p> lubridate duration or period object, e.g. <code>days(1)</code> or <code>ddays(1)</code>.
</p>
</li>
<li><p> named list of length one, the unit being the name, and
the number the value of the list, e.g. <code>list("days" = 7)</code>.
For the vectorized time functions, you can supply multiple values,
e.g. <code>list("days" = 1:10)</code>.
</p>
</li>
<li><p> Numeric vector. If time_by is a numeric vector and x is not a date/datetime,
then arithmetic is used, e.g <code>time_by = 1</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="time_by_+3A_from">from</code></td>
<td>
<p>(Optional) Start time.</p>
</td></tr>
<tr><td><code id="time_by_+3A_to">to</code></td>
<td>
<p>(Optional) end time.</p>
</td></tr>
<tr><td><code id="time_by_+3A_.name">.name</code></td>
<td>
<p>An optional glue specification passed to <code>stringr::glue()</code>
which can be used to concatenate
strings to the time column name or replace it.</p>
</td></tr>
<tr><td><code id="time_by_+3A_.add">.add</code></td>
<td>
<p>Should the time groups be added to existing groups?
Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="time_by_+3A_time_type">time_type</code></td>
<td>
<p>If &quot;auto&quot;, <code>periods</code> are used for
the time expansion when days, weeks,
months or years are specified, and <code>durations</code>
are used otherwise. If <code>durations</code>
are used the output is always of class <code>POSIXt</code>.</p>
</td></tr>
<tr><td><code id="time_by_+3A_time_floor">time_floor</code></td>
<td>
<p>Should the start of each time sequence
be floored to
the nearest unit specified through the <code>time_by</code>
argument? This is particularly useful for
starting sequences at the beginning of a week
or month for example.</p>
</td></tr>
<tr><td><code id="time_by_+3A_week_start">week_start</code></td>
<td>
<p>day on which week starts following ISO conventions - 1
means Monday (default), 7 means Sunday.
This is only used when <code>time_floor = TRUE</code>.</p>
</td></tr>
<tr><td><code id="time_by_+3A_roll_month">roll_month</code></td>
<td>
<p>Control how impossible dates are handled when
month or year arithmetic is involved.
Options are &quot;preday&quot;, &quot;boundary&quot;, &quot;postday&quot;, &quot;full&quot; and &quot;NA&quot;.
See <code>?timechange::time_add</code> for more details.</p>
</td></tr>
<tr><td><code id="time_by_+3A_roll_dst">roll_dst</code></td>
<td>
<p>See <code>?timechange::time_add</code> for the full list of details.</p>
</td></tr>
<tr><td><code id="time_by_+3A_.time_by_group">.time_by_group</code></td>
<td>
<p>Should the time aggregations be built on a
group-by-group basis (the default), or should the time variable be aggregated
using the full data? If done by group, different groups may contain
different time sequences. This only applies when <code>.add = TRUE</code>.</p>
</td></tr>
<tr><td><code id="time_by_+3A_x">x</code></td>
<td>
<p>A <code>time_tbl_df</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>time_tbl_df</code> which for practical purposes can be treated the
same way as a dplyr <code>grouped_df</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
library(timeplyr)
library(nycflights13)
library(lubridate)


# Basic usage
hourly_flights &lt;- flights %&gt;%
  time_by(time_hour) # Detects time granularity

hourly_flights
time_by_span(hourly_flights)

monthly_flights &lt;- flights %&gt;%
  time_by(time_hour, "month")
weekly_flights &lt;- flights %&gt;%
  time_by(time_hour, "week", time_floor = TRUE)

monthly_flights %&gt;%
  count()

weekly_flights %&gt;%
  summarise(n = n(), arr_delay = mean(arr_delay, na.rm = TRUE))

# To aggregate multiple variables, use time_aggregate or time_summarisev


flights %&gt;%
  select(time_hour) %&gt;%
  mutate(across(everything(), \(x) time_summarisev(x, time_by = dweeks(1)))) %&gt;%
  count(time_hour)

</code></pre>

<hr>
<h2 id='time_count'>Fast count time at higher time units.</h2><span id='topic+time_count'></span>

<h3>Description</h3>

<p>This function operates like <code>dplyr::count()</code>
but with emphasis on
a specified time variable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>time_count(
  data,
  time = NULL,
  ...,
  time_by = NULL,
  from = NULL,
  to = NULL,
  complete = FALSE,
  wt = NULL,
  name = NULL,
  sort = FALSE,
  .by = NULL,
  time_floor = FALSE,
  week_start = getOption("lubridate.week.start", 1),
  time_type = getOption("timeplyr.time_type", "auto"),
  roll_month = getOption("timeplyr.roll_month", "preday"),
  roll_dst = getOption("timeplyr.roll_dst", "boundary"),
  include_interval = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="time_count_+3A_data">data</code></td>
<td>
<p>A data frame.</p>
</td></tr>
<tr><td><code id="time_count_+3A_time">time</code></td>
<td>
<p>Time variable.</p>
</td></tr>
<tr><td><code id="time_count_+3A_...">...</code></td>
<td>
<p>Additional variables to include.</p>
</td></tr>
<tr><td><code id="time_count_+3A_time_by">time_by</code></td>
<td>
<p>Time unit. <br />
Must be one of the three:
</p>

<ul>
<li><p> string, specifying either the unit or the number and unit, e.g
<code>time_by = "days"</code> or <code>time_by = "2 weeks"</code>
</p>
</li>
<li><p> named list of length one, the unit being the name, and
the number the value of the list, e.g. <code>list("days" = 7)</code>.
For the vectorized time functions, you can supply multiple values,
e.g. <code>list("days" = 1:10)</code>.
</p>
</li>
<li><p> Numeric vector. If time_by is a numeric vector and x is not a date/datetime,
then arithmetic is used, e.g <code>time_by = 1</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="time_count_+3A_from">from</code></td>
<td>
<p>Time series start date. If <code>NULL</code> then min time is used.</p>
</td></tr>
<tr><td><code id="time_count_+3A_to">to</code></td>
<td>
<p>Time series end date. If <code>NULL</code> then max time is used.</p>
</td></tr>
<tr><td><code id="time_count_+3A_complete">complete</code></td>
<td>
<p><b>Deprecated</b>.
Use <code>time_complete()</code> after <code>time_count()</code> to
complete missing gaps in time (as well as optionally expand groups).</p>
</td></tr>
<tr><td><code id="time_count_+3A_wt">wt</code></td>
<td>
<p>Frequency weights.
<code>dplyr</code> &quot;data-masking&quot; is used for variable selection.
Can be <code>NULL</code> or a variable:
</p>

<ul>
<li><p> If <code>NULL</code> (the default), counts the number of rows in each group.
</p>
</li>
<li><p> If a variable, computes <code>sum(wt)</code> for each group.
</p>
</li></ul>
</td></tr>
<tr><td><code id="time_count_+3A_name">name</code></td>
<td>
<p>Character vector of length 1, specifying the name of
the new column in the output.</p>
</td></tr>
<tr><td><code id="time_count_+3A_sort">sort</code></td>
<td>
<p>If <code>TRUE</code> the groups with largest counts will be sorted first.
If <code>FALSE</code> the result is sorted by groups + time + ... groups.</p>
</td></tr>
<tr><td><code id="time_count_+3A_.by">.by</code></td>
<td>
<p>(Optional). A selection of columns to group by for this operation.
Columns are specified using tidy-select.</p>
</td></tr>
<tr><td><code id="time_count_+3A_time_floor">time_floor</code></td>
<td>
<p>Should <code>from</code> be floored to the nearest unit
specified through the <code>time_by</code>
argument? This is particularly useful for starting
sequences at the beginning of a week
or month for example.</p>
</td></tr>
<tr><td><code id="time_count_+3A_week_start">week_start</code></td>
<td>
<p>day on which week starts following ISO conventions - 1
means Monday (default), 7 means Sunday.
This is only used when <code>time_floor = TRUE</code>.</p>
</td></tr>
<tr><td><code id="time_count_+3A_time_type">time_type</code></td>
<td>
<p>If &quot;auto&quot;, <code>periods</code> are used for
the time expansion when days, weeks, months or
years are specified, and <code>durations</code>
are used otherwise.</p>
</td></tr>
<tr><td><code id="time_count_+3A_roll_month">roll_month</code></td>
<td>
<p>Control how impossible dates are handled when
month or year arithmetic is involved.
Options are &quot;preday&quot;, &quot;boundary&quot;, &quot;postday&quot;, &quot;full&quot; and &quot;NA&quot;.
See <code>?timechange::time_add</code> for more details.</p>
</td></tr>
<tr><td><code id="time_count_+3A_roll_dst">roll_dst</code></td>
<td>
<p>See <code>?timechange::time_add</code> for the full list of details.</p>
</td></tr>
<tr><td><code id="time_count_+3A_include_interval">include_interval</code></td>
<td>
<p>Logical. If <code>TRUE</code> then
a column &quot;interval&quot; of the form <code style="white-space: pre;">&#8288;time_min &lt;= x &lt; time_max&#8288;</code> is added
showing the time interval in which the respective counts belong to.
The rightmost interval will always be closed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>time_count</code> Creates an
aggregated frequency time series where time
can be aggregated to
both lower and higher time units.
</p>
<p>An important note is that when the data are grouped, time ranges are expanded
on a group-by-group basis. <br />
When groups are supplied through
<code>...</code>, the time range of the entire data is used
to aggregate the time variable.
</p>


<h3>Value</h3>

<p>An object of class <code>data.frame</code>
containing the aggregate time variable and corresponding counts.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(timeplyr)
library(dplyr)
library(lubridate)
library(nycflights13)

df &lt;- flights %&gt;%
  mutate(date = as_date(time_hour)) %&gt;%
  select(year, month, day, origin, dest, date, time_hour)

# By default time_count() guesses the time granularity
df %&gt;%
  time_count(time_hour)
# Aggregated to week level
df %&gt;%
  time_count(time = date, time_by = "2 weeks")
df %&gt;%
  time_count(time = date, time_by = list("months" = 3),
             from = dmy("15-01-2013"),
             time_floor = TRUE,
             include_interval = TRUE)

</code></pre>

<hr>
<h2 id='time_cut'>Cut dates and datetimes into regularly spaced date or datetime intervals</h2><span id='topic+time_cut'></span><span id='topic+time_breaks'></span>

<h3>Description</h3>

<p><code>time_cut()</code> is very useful for plotting with dates and datetimes
and always returns breaks of regular width. <br />
</p>


<h3>Usage</h3>

<pre><code class='language-R'>time_cut(
  x,
  n = 5,
  time_by = NULL,
  from = NULL,
  to = NULL,
  fmt = NULL,
  time_floor = FALSE,
  week_start = getOption("lubridate.week.start", 1),
  n_at_most = TRUE,
  as_factor = TRUE,
  time_type = getOption("timeplyr.time_type", "auto"),
  roll_month = getOption("timeplyr.roll_month", "preday"),
  roll_dst = getOption("timeplyr.roll_dst", "boundary")
)

time_breaks(
  x,
  n = 5,
  time_by = NULL,
  from = NULL,
  to = NULL,
  time_floor = FALSE,
  week_start = getOption("lubridate.week.start", 1),
  n_at_most = TRUE,
  time_type = getOption("timeplyr.time_type", "auto"),
  roll_month = getOption("timeplyr.roll_month", "preday"),
  roll_dst = getOption("timeplyr.roll_dst", "boundary")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="time_cut_+3A_x">x</code></td>
<td>
<p>Time variable. <br />
Can be a <code>Date</code>, <code>POSIXt</code>, <code>numeric</code>, <code>integer</code>, <code>yearmon</code>, or <code>yearqtr</code>.</p>
</td></tr>
<tr><td><code id="time_cut_+3A_n">n</code></td>
<td>
<p>Number of breaks.</p>
</td></tr>
<tr><td><code id="time_cut_+3A_time_by">time_by</code></td>
<td>
<p>Time unit. <br />
Must be one of the three:
</p>

<ul>
<li><p> string, specifying either the unit or the number and unit, e.g
<code>time_by = "days"</code> or <code>time_by = "2 weeks"</code>
</p>
</li>
<li><p> named list of length one, the unit being the name, and
the number the value of the list, e.g. <code>list("days" = 7)</code>.
For the vectorized time functions, you can supply multiple values,
e.g. <code>list("days" = 1:10)</code>.
</p>
</li>
<li><p> Numeric vector. If time_by is a numeric vector and x is not a date/datetime,
then arithmetic is used, e.g <code>time_by = 1</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="time_cut_+3A_from">from</code></td>
<td>
<p>Time series start date.</p>
</td></tr>
<tr><td><code id="time_cut_+3A_to">to</code></td>
<td>
<p>Time series end date.</p>
</td></tr>
<tr><td><code id="time_cut_+3A_fmt">fmt</code></td>
<td>
<p>(Optional) Date/datetime format for the factor labels.
If supplied, this is passed to <code>format()</code>.</p>
</td></tr>
<tr><td><code id="time_cut_+3A_time_floor">time_floor</code></td>
<td>
<p>Logical. Should the initial date/datetime be
floored before building the sequence?</p>
</td></tr>
<tr><td><code id="time_cut_+3A_week_start">week_start</code></td>
<td>
<p>day on which week starts following ISO conventions - 1
means Monday (default), 7 means Sunday.
This is only used when <code>time_floor = TRUE</code>.</p>
</td></tr>
<tr><td><code id="time_cut_+3A_n_at_most">n_at_most</code></td>
<td>
<p><b>Deprecated</b>. No longer used.</p>
</td></tr>
<tr><td><code id="time_cut_+3A_as_factor">as_factor</code></td>
<td>
<p>Logical. If <code>TRUE</code> the output is an ordered factor.
Setting this to <code>FALSE</code> is sometimes much faster.</p>
</td></tr>
<tr><td><code id="time_cut_+3A_time_type">time_type</code></td>
<td>
<p>If &quot;auto&quot;, <code>periods</code> are used for
the time expansion when days, weeks, months or years are specified,
and <code>durations</code> are used otherwise.</p>
</td></tr>
<tr><td><code id="time_cut_+3A_roll_month">roll_month</code></td>
<td>
<p>Control how impossible dates are handled when
month or year arithmetic is involved.
Options are &quot;preday&quot;, &quot;boundary&quot;, &quot;postday&quot;, &quot;full&quot; and &quot;NA&quot;.
See <code>?timechange::time_add</code> for more details.</p>
</td></tr>
<tr><td><code id="time_cut_+3A_roll_dst">roll_dst</code></td>
<td>
<p>See <code>?timechange::time_add</code> for the full list of details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>To specify exact widths, similar to <code>ggplot2::cut_width()</code>,
supply <code>time_by</code> and <code>n = Inf</code>. <br />
<code>time_breaks()</code> is a helper that
returns only the time breaks.
</p>
<p>By default <code>time_cut()</code> will try to find
the prettiest way of cutting the interval by
trying to cut the date/date-times into
groups of the highest possible time units,
starting at years and ending at milliseconds.
</p>
<p>When <code>x</code> is a numeric vector, <code>time_cut</code> will behave similar to <code>time_cut</code>
except for 3 things:
</p>

<ul>
<li><p> The intervals are all right open and equal width, except for the
rightmost interval which is closed with width &lt;= the other widths.
</p>
</li>
<li><p> The left value of the leftmost interval is always <code>min(x)</code>.
</p>
</li>
<li><p> Up to <code>n</code> breaks are created, i.e <code style="white-space: pre;">&#8288;&lt;= n&#8288;</code> breaks. This is to prioritise
pretty breaks.
</p>
</li></ul>

<p><code>time_cut</code> is a generalisation of <code>time_summarisev</code> such that the
below identity should always hold:
</p>
<pre>
 identical(time_cut(x, n = Inf, as_factor = FALSE), time_summarisev(x))
</pre>


<h3>Value</h3>

<p><code>time_breaks</code> returns a vector of breaks. <br />
<code>time_cut</code> returns either a <code>factor</code> or a vector the same class as <code>x</code>.
In both cases it is the same length as <code>x</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(timeplyr)
library(lubridate)
library(ggplot2)
library(dplyr)

time_cut(1:10, n = 5)
# Easily create custom time breaks
df &lt;- nycflights13::flights %&gt;%
  fslice_sample(n = 10, seed = 8192821) %&gt;%
  select(time_hour) %&gt;%
  farrange(time_hour) %&gt;%
  mutate(date = as_date(time_hour))

# time_cut() and time_breaks() automatically find a
# suitable way to cut the data
time_cut(df$date)
# Works with datetimes as well
time_cut(df$time_hour, n = 5) # &lt;= 5 breaks
# Custom formatting
time_cut(df$date, fmt = "%Y %b", time_by = "month")
# Just the breaks
time_breaks(df$date, n = 5, time_by = "month")

cut_dates &lt;- time_cut(df$date)
date_breaks &lt;- time_breaks(df$date)

# Grouping each interval into the start of its interval
identical(date_breaks[group_id(cut_dates)],
          time_cut(df$date, as_factor = FALSE))

# WHen n = Inf and as_factor = FALSE, it should be equivalent to using
# time_aggregate or time_summarisev
identical(time_cut(df$date, n = Inf, time_by = "month", as_factor = FALSE),
          time_summarisev(df$date, time_by = "month"))
identical(time_summarisev(df$date, time_by = "month"),
          time_aggregate(df$date, time_by = "month"))

# To get exact breaks at regular intervals, use time_expandv
weekly_breaks &lt;- time_expandv(df$date,
                              time_by = "5 weeks",
                              week_start = 1, # Monday
                              time_floor = TRUE)
weekly_labels &lt;- format(weekly_breaks, "%b-%d")
df %&gt;%
  time_count(time = date, time_by = "week") %&gt;%
  ggplot(aes(x = date, y = n)) +
  geom_bar(stat = "identity") +
  scale_x_date(breaks = weekly_breaks,
               labels = weekly_labels)

</code></pre>

<hr>
<h2 id='time_diff'>Time differences by any time unit</h2><span id='topic+time_diff'></span>

<h3>Description</h3>

<p>The time difference between 2 date or date-time vectors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>time_diff(
  x,
  y,
  time_by = 1L,
  time_type = getOption("timeplyr.time_type", "auto")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="time_diff_+3A_x">x</code></td>
<td>
<p>Start date or datetime.</p>
</td></tr>
<tr><td><code id="time_diff_+3A_y">y</code></td>
<td>
<p>End date or datetime.</p>
</td></tr>
<tr><td><code id="time_diff_+3A_time_by">time_by</code></td>
<td>
<p>Must be one of the three (Default is 1):
</p>

<ul>
<li><p> string, specifying either the unit or the number and unit, e.g
<code>time_by = "days"</code> or <code>time_by = "2 weeks"</code>
</p>
</li>
<li><p> named list of length one, the unit being the name, and
the number the value of the list, e.g. <code>list("days" = 7)</code>.
For the vectorized time functions, you can supply multiple values,
e.g. <code>list("days" = 1:10)</code>.
</p>
</li>
<li><p> Numeric vector. If time_by is a numeric vector and x is not a date/datetime,
then arithmetic is used, e.g <code>time_by = 1</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="time_diff_+3A_time_type">time_type</code></td>
<td>
<p>Time difference type: &quot;auto&quot;, &quot;duration&quot; or &quot;period&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When <code>time_by</code> is a numeric vector, e.g <code>time_by = 1</code> then
base arithmetic using <code>base::`-`</code> is used, otherwise 'lubridate' style
durations and periods are used.<br />
Some more exotic time units such as quarters, fortnights, etcetera
can be specified. See <code>.time_units</code> for more choices.
</p>


<h3>Value</h3>

<p>A numeric vector recycled to the length of <code>max(length(x), length(y))</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(timeplyr)
library(lubridate)

time_diff(today(), today() + days(10),
          time_by = "days")
time_diff(today(), today() + days((0:3) * 7),
          time_by = weeks(1))
time_diff(today(), today() + days(100),
          time_by = list("days" = 1:100))
time_diff(1, 1 + 0:100, time_by = 3)

library(nycflights13)
library(bench)

# Period differences are much faster
mark(timeplyr = time_diff(flights$time_hour, today(), "weeks", time_type = "period"),
     lubridate = interval(flights$time_hour, today()) / weeks(1))


</code></pre>

<hr>
<h2 id='time_diff_gcd'>Fast greatest common divisor of time differences</h2><span id='topic+time_diff_gcd'></span>

<h3>Description</h3>

<p>Fast greatest common divisor of time differences
</p>


<h3>Usage</h3>

<pre><code class='language-R'>time_diff_gcd(
  x,
  time_by = 1,
  time_type = getOption("timeplyr.time_type", "auto"),
  tol = sqrt(.Machine$double.eps)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="time_diff_gcd_+3A_x">x</code></td>
<td>
<p>Time variable. <br />
Can be a <code>Date</code>, <code>POSIXt</code>, <code>numeric</code>, <code>integer</code>, <code>yearmon</code>, or <code>yearqtr</code>.</p>
</td></tr>
<tr><td><code id="time_diff_gcd_+3A_time_by">time_by</code></td>
<td>
<p>Time unit (default is 1). <br />
Must be one of the following:
</p>

<ul>
<li><p> string, specifying either the unit or the number and unit, e.g
<code>time_by = "days"</code> or <code>time_by = "2 weeks"</code>
</p>
</li>
<li><p> named list of length one, the unit being the name, and
the number the value of the list, e.g. <code>list("days" = 7)</code>.
For the vectorized time functions, you can supply multiple values,
e.g. <code>list("days" = 1:10)</code>.
</p>
</li>
<li><p> Numeric vector. If time_by is a numeric vector and x is not a date/datetime,
then arithmetic is used, e.g <code>time_by = 1</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="time_diff_gcd_+3A_time_type">time_type</code></td>
<td>
<p>If &quot;auto&quot;, <code>periods</code> are used if <code>x</code> is a Date and
durations are used if <code>x</code> is a datetime.
Otherwise numeric differences are calculated.</p>
</td></tr>
<tr><td><code id="time_diff_gcd_+3A_tol">tol</code></td>
<td>
<p>Tolerance of comparison. The time differences are rounded
using <code>digits = ceiling(abs(log10(tol)))</code> to try and avoid
precision issues.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A double vector of length 1 or length 0 if <code>length(x)</code> is 0.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(timeplyr)
library(lubridate)
library(cppdoubles)

time_diff_gcd(1:10)
time_diff_gcd(seq(0, 1, 0.2))

time_diff_gcd(time_seq(today(), today() + 100, time_by = "3 days"))
time_diff_gcd(time_seq(now(), len = 10^2, time_by = "125 seconds"))

# Monthly gcd using lubridate periods
quarter_seq &lt;- time_seq(today(), len = 24, time_by = months(4))
time_diff_gcd(quarter_seq, time_by = months(1))
time_diff_gcd(quarter_seq, time_by = "months", time_type = "duration")

# Detects monthly granularity
double_equal(time_diff_gcd(as.vector(time(AirPassengers))), 1/12)

</code></pre>

<hr>
<h2 id='time_distinct'>A time based extension to <code>dplyr::distinct()</code>.</h2><span id='topic+time_distinct'></span>

<h3>Description</h3>

<p>This works much the same as <code>dplyr::distinct()</code>, except that
you can supply an additional <code>time</code> argument to allow for
aggregating time to a higher unit.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>time_distinct(
  data,
  time = NULL,
  ...,
  time_by = NULL,
  from = NULL,
  to = NULL,
  .keep_all = FALSE,
  time_type = getOption("timeplyr.time_type", "auto"),
  include_interval = FALSE,
  .by = NULL,
  time_floor = FALSE,
  week_start = getOption("lubridate.week.start", 1),
  roll_month = getOption("timeplyr.roll_month", "preday"),
  roll_dst = getOption("timeplyr.roll_dst", "boundary"),
  sort = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="time_distinct_+3A_data">data</code></td>
<td>
<p>A data frame.</p>
</td></tr>
<tr><td><code id="time_distinct_+3A_time">time</code></td>
<td>
<p>Time variable.</p>
</td></tr>
<tr><td><code id="time_distinct_+3A_...">...</code></td>
<td>
<p>Additional variables to include.</p>
</td></tr>
<tr><td><code id="time_distinct_+3A_time_by">time_by</code></td>
<td>
<p>Time unit. <br />
Must be one of the three:
</p>

<ul>
<li><p> string, specifying either the unit or the number and unit, e.g
<code>time_by = "days"</code> or <code>time_by = "2 weeks"</code>
</p>
</li>
<li><p> named list of length one, the unit being the name, and
the number the value of the list, e.g. <code>list("days" = 7)</code>.
For the vectorized time functions, you can supply multiple values,
e.g. <code>list("days" = 1:10)</code>.
</p>
</li>
<li><p> Numeric vector. If time_by is a numeric vector and x is not a date/datetime,
then arithmetic is used, e.g <code>time_by = 1</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="time_distinct_+3A_from">from</code></td>
<td>
<p>Time series start date.</p>
</td></tr>
<tr><td><code id="time_distinct_+3A_to">to</code></td>
<td>
<p>Time series end date.</p>
</td></tr>
<tr><td><code id="time_distinct_+3A_.keep_all">.keep_all</code></td>
<td>
<p>If <code>TRUE</code> then all columns of data frame are kept,
default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="time_distinct_+3A_time_type">time_type</code></td>
<td>
<p>If &quot;auto&quot;, <code>periods</code> are used for
the time expansion when days, weeks, months or years are specified,
and <code>durations</code> are used otherwise.</p>
</td></tr>
<tr><td><code id="time_distinct_+3A_include_interval">include_interval</code></td>
<td>
<p>Logical. If <code>TRUE</code> then
a column &quot;interval&quot; of the form <code style="white-space: pre;">&#8288;time_min &lt;= x &lt; time_max&#8288;</code> is added
showing the time interval in which the respective counts belong to.
The rightmost interval will always be closed.</p>
</td></tr>
<tr><td><code id="time_distinct_+3A_.by">.by</code></td>
<td>
<p>(Optional). A selection of columns to group by for this operation.
Columns are specified using tidy-select.</p>
</td></tr>
<tr><td><code id="time_distinct_+3A_time_floor">time_floor</code></td>
<td>
<p>Should <code>from</code> be floored to the nearest unit
specified through the <code>time_by</code>
argument? This is particularly useful for starting
sequences at the beginning of a week
or month for example.</p>
</td></tr>
<tr><td><code id="time_distinct_+3A_week_start">week_start</code></td>
<td>
<p>day on which week starts following ISO conventions - 1
means Monday, 7 means Sunday (default).
This is only used when <code>time_floor = TRUE</code>.</p>
</td></tr>
<tr><td><code id="time_distinct_+3A_roll_month">roll_month</code></td>
<td>
<p>Control how impossible dates are handled when
month or year arithmetic is involved.
Options are &quot;preday&quot;, &quot;boundary&quot;, &quot;postday&quot;, &quot;full&quot; and &quot;NA&quot;.
See <code>?timechange::time_add</code> for more details.</p>
</td></tr>
<tr><td><code id="time_distinct_+3A_roll_dst">roll_dst</code></td>
<td>
<p>See <code>?timechange::time_add</code> for the full list of details.</p>
</td></tr>
<tr><td><code id="time_distinct_+3A_sort">sort</code></td>
<td>
<p>Should the result be sorted? Default is <code>TRUE</code>.
If <code>FALSE</code> then original (input) order is kept.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code> of distinct aggregate time values across groups.
</p>

<hr>
<h2 id='time_elapsed'>Fast grouped time elapsed</h2><span id='topic+time_elapsed'></span>

<h3>Description</h3>

<p>Calculate how much time has passed
on a rolling or cumulative basis. <br />
</p>


<h3>Usage</h3>

<pre><code class='language-R'>time_elapsed(
  x,
  time_by = NULL,
  g = NULL,
  time_type = getOption("timeplyr.time_type", "auto"),
  rolling = TRUE,
  fill = NA,
  na_skip = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="time_elapsed_+3A_x">x</code></td>
<td>
<p>Time variable. <br />
Can be a <code>Date</code>, <code>POSIXt</code>, <code>numeric</code>, <code>integer</code>, <code>yearmon</code>, or <code>yearqtr</code>.</p>
</td></tr>
<tr><td><code id="time_elapsed_+3A_time_by">time_by</code></td>
<td>
<p>Must be one of the three:
</p>

<ul>
<li><p> string, specifying either the unit or the number and unit, e.g
<code>time_by = "days"</code> or <code>time_by = "2 weeks"</code>
</p>
</li>
<li><p> named list of length one, the unit being the name, and
the number the value of the list, e.g. <code>list("days" = 7)</code>.
For the vectorized time functions, you can supply multiple values,
e.g. <code>list("days" = 1:10)</code>.
</p>
</li>
<li><p> Numeric vector. If time_by is a numeric vector and x is not a date/datetime,
then arithmetic is used, e.g <code>time_by = 1</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="time_elapsed_+3A_g">g</code></td>
<td>
<p>Object to be used for grouping <code>x</code>, passed onto <code>collapse::GRP()</code>.</p>
</td></tr>
<tr><td><code id="time_elapsed_+3A_time_type">time_type</code></td>
<td>
<p>Time type, either &quot;auto&quot;, &quot;duration&quot; or &quot;period&quot;.
With larger data, it is recommended to use <code>time_type = "duration"</code> for
speed and efficiency.</p>
</td></tr>
<tr><td><code id="time_elapsed_+3A_rolling">rolling</code></td>
<td>
<p>If <code>TRUE</code> (the default) then lagged
time differences are calculated on a rolling basis,
essentially like <code>diff()</code>. <br />
If <code>FALSE</code> then time differences compared to the index (first) time
are calculated.</p>
</td></tr>
<tr><td><code id="time_elapsed_+3A_fill">fill</code></td>
<td>
<p>When <code>rolling = TRUE</code>, this is the value that fills
the first elapsed time. The default is <code>NA</code>.</p>
</td></tr>
<tr><td><code id="time_elapsed_+3A_na_skip">na_skip</code></td>
<td>
<p>Should <code>NA</code> values be skipped? Default is <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>time_elapsed()</code> is quite efficient when there are many groups,
especially if your data is sorted in order of those groups.
In the case that <code>g</code> is supplied, it is most efficient when your data is
sorted by <code>g</code> .
When <code>na_skip</code> is <code>TRUE</code> and <code>rolling</code> is also <code>TRUE</code>, <code>NA</code> values are simply
skipped and hence the time differences between the current value and the
previous non-NA value are calculated. For example,
<code>c(3, 4, 6, NA, NA, 9)</code> becomes <code>c(NA, 1, 2, NA, NA, 3)</code>. <br />
When <code>na_skip</code> is <code>TRUE</code> and <code>rolling</code> is <code>FALSE</code>, time differences between
the current value and the first non-NA value of the series are calculated.
For example,
<code>c(NA, NA, 3, 4, 6, NA, 8)</code> becomes <code>c(NA, NA, 0, 1, 3, NA, 5)</code>.
</p>


<h3>Value</h3>

<p>A numeric vector the same length as <code>x</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(timeplyr)
library(dplyr)
library(lubridate)

x &lt;- time_seq(today(), length.out = 25, time_by = "3 days")
time_elapsed(x)
time_elapsed(x, rolling = FALSE, time_by = "day")

# Grouped example
set.seed(99)
# ~ 100k groups, 1m rows
x &lt;- sample(time_seq_v2(20, today(), "day"), 10^6, TRUE)
g &lt;- sample.int(10^5, 10^6, TRUE)

time_elapsed(x, time_by = "day", g = g)

</code></pre>

<hr>
<h2 id='time_episodes'>Episodic calculation of time-since-event data</h2><span id='topic+time_episodes'></span>

<h3>Description</h3>

<p>This function assigns episodes to events
based on a pre-defined threshold of a chosen time unit.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>time_episodes(
  data,
  time,
  time_by = NULL,
  window = 1,
  roll_episode = TRUE,
  switch_on_boundary = TRUE,
  fill = 0,
  .add = FALSE,
  event = NULL,
  time_type = getOption("timeplyr.time_type", "auto"),
  .by = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="time_episodes_+3A_data">data</code></td>
<td>
<p>A data frame.</p>
</td></tr>
<tr><td><code id="time_episodes_+3A_time">time</code></td>
<td>
<p>Date or datetime variable to use for the episode calculation.
Supply the variable using <code>tidyselect</code> notation.</p>
</td></tr>
<tr><td><code id="time_episodes_+3A_time_by">time_by</code></td>
<td>
<p>Time units used to calculate episode flags.
If <code>time_by</code> is <code>NULL</code> then a heuristic will try and estimate the highest
order time unit associated with the time variable.
If specified, then by must be one of the three:
</p>

<ul>
<li><p> string, specifying either the unit or the number and unit, e.g
<code>time_by = "days"</code> or <code>time_by = "2 weeks"</code>
</p>
</li>
<li><p> named list of length one, the unit being the name, and
the number the value of the list, e.g. <code>list("days" = 7)</code>.
For the vectorized time functions, you can supply multiple values,
e.g. <code>list("days" = 1:10)</code>.
</p>
</li>
<li><p> Numeric vector. If by is a numeric vector and x is not a date/datetime,
then arithmetic is used, e.g <code>time_by = 1</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="time_episodes_+3A_window">window</code></td>
<td>
<p>Single number defining the episode threshold.
When <code>rolling = TRUE</code> events with a
<code>t_elapsed &gt;= window</code> since the last event
are defined as a new episode. <br />
When <code>rolling = FALSE</code> events with a
<code>t_elapsed &gt;= window</code> since the first event of the corresponding episode
are defined as a new episode. <br />
By default, <code>window = 1</code> which assigns every event to a new episode.</p>
</td></tr>
<tr><td><code id="time_episodes_+3A_roll_episode">roll_episode</code></td>
<td>
<p>Logical.
Should episodes be calculated using a rolling or fixed window?
If <code>TRUE</code> (the default), an amount of time must have passed (<code style="white-space: pre;">&#8288;&gt;= window&#8288;</code>)
since the last event, with each new event
effectively resetting the time at which
you start counting. <br />
If <code>FALSE</code>, the elapsed time is fixed and
new episodes are defined based on how much cumulative time has
passed since the first event of each episode.</p>
</td></tr>
<tr><td><code id="time_episodes_+3A_switch_on_boundary">switch_on_boundary</code></td>
<td>
<p>When an exact amount of time
(specified in <code>time_by</code>) has passed, should there be an increment in ID? <br />
The default is <code>TRUE</code>. <br />
For example, if <code>time_by = "days"</code> and
<code>switch_on_boundary = FALSE</code>, <code style="white-space: pre;">&#8288;&gt; 1&#8288;</code> day must have passed, otherwise
<code style="white-space: pre;">&#8288;&gt;= 1&#8288;</code> day must have passed.</p>
</td></tr>
<tr><td><code id="time_episodes_+3A_fill">fill</code></td>
<td>
<p>Value to fill first time elapsed value. Only applicable when
<code>roll_episode = TRUE</code>. <br />
Default is <code>0</code>.</p>
</td></tr>
<tr><td><code id="time_episodes_+3A_.add">.add</code></td>
<td>
<p>Should episodic variables be added to the data? <br />
If <code>FALSE</code> (the default), then only the relevant variables are returned. <br />
If <code>TRUE</code>, the episodic variables are added to the original data using
<code>dplyr::bind_cols()</code>. <br />
In both cases, the order of the data is unchanged.</p>
</td></tr>
<tr><td><code id="time_episodes_+3A_event">event</code></td>
<td>
<p>(<b>Optional</b>) List that encodes which rows are events,
and which aren't.
By default <code>time_episodes()</code>
assumes every observation (row) is an event
but this need not be the case. <br />
<code>event</code> must be a named list of length 1 where the values of the
list element represent the event. For example, if your events were coded as
<code>0</code> and <code>1</code> in a variable named &quot;evt&quot; where <code>1</code> represents the event,
you would supply <code>event = list(evt = 1)</code>.</p>
</td></tr>
<tr><td><code id="time_episodes_+3A_time_type">time_type</code></td>
<td>
<p>Time type, either &quot;auto&quot;, &quot;duration&quot; or &quot;period&quot;.
With larger data, it is recommended to use <code>time_type = "duration"</code> for
speed and efficiency.</p>
</td></tr>
<tr><td><code id="time_episodes_+3A_.by">.by</code></td>
<td>
<p>(Optional). A selection of columns to group by for this operation.
Columns are specified using <code>tidyselect</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>time_episodes()</code> calculates the time elapsed (rolling or fixed) between
successive events, and flags these events as episodes or not based on how much
time has passed.
</p>
<p>An example of episodic analysis can include disease infections over time.
</p>
<p>In this example, a positive test result represents an <b>event</b> and <br />
a new infection represents a new <b>episode</b>.
</p>
<p>It is assumed that after a pre-determined amount of time, a positive result
represents a new episode of infection.
</p>
<p>To perform simple time-since-event analysis, set <code>window</code> to <code>1</code>, which is
the default.
</p>
<p>The data are always sorted before calculation and then
sorted back to the input order.
</p>
<p>4 Key variables will be calculated:
</p>

<ul>
<li> <p><b>ep_id</b> - An integer variable signifying
which episode each event belongs to. <br />
Non-events are assigned <code>NA</code>. <br />
<code>ep_id</code> is an increasing integer starting at 1.
In the infections scenario, 1 are positives within the
first episode of infection,
2 are positives within the second episode of infection and so on.
</p>
</li>
<li> <p><b>ep_id_new</b> - An integer variable signifying the first
instance of each new episode.
This is an increasing integer where
0 signifies within-episode observations and &gt;= 1
signifies the first instance of the respective episode.
</p>
</li>
<li> <p><b>t_elapsed</b> - The time elapsed since the last event. <br />
When <code>roll_episode = FALSE</code>, this becomes the time elapsed since the
first event of the current episode.
Time units are specified in the by argument.
</p>
</li>
<li> <p><b>ep_start</b> - Start date/datetime of the episode.
</p>
</li></ul>

<p><code>data.table</code> and <code>collapse</code> are used for speed and efficiency.
</p>


<h3>Value</h3>

<p>A <code>data.frame</code> in the same order as it was given.
</p>


<h3>See Also</h3>

<p><a href="#topic+time_elapsed">time_elapsed</a> <a href="#topic+time_seq_id">time_seq_id</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(timeplyr)
library(dplyr)
library(nycflights13)
library(lubridate)
library(ggplot2)

# Say we want to flag origin-destination pairs
# that haven't seen departures or arrivals for a week

events &lt;- flights %&gt;%
  mutate(date = as_date(time_hour)) %&gt;%
  group_by(origin, dest) %&gt;%
  time_episodes(date, time_by = "week", window = 1)
episodes &lt;- events %&gt;%
  filter(ep_id_new &gt; 1)
nrow(fdistinct(episodes, origin, dest)) # 55 origin-destinations

# As expected summer months saw the least number of
# dry-periods
episodes %&gt;%
  ungroup() %&gt;%
  time_count(time = ep_start, time_by = "week", time_floor = TRUE) %&gt;%
  ggplot(aes(x = ep_start, y = n)) +
  geom_bar(stat = "identity")

</code></pre>

<hr>
<h2 id='time_expand'>A time based extension to <code>tidyr::complete()</code>.</h2><span id='topic+time_expand'></span><span id='topic+time_complete'></span>

<h3>Description</h3>

<p>A time based extension to <code>tidyr::complete()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>time_expand(
  data,
  time = NULL,
  ...,
  .by = NULL,
  time_by = NULL,
  from = NULL,
  to = NULL,
  time_type = getOption("timeplyr.time_type", "auto"),
  time_floor = FALSE,
  week_start = getOption("lubridate.week.start", 1),
  expand_type = c("nesting", "crossing"),
  sort = TRUE,
  keep_class = TRUE,
  roll_month = getOption("timeplyr.roll_month", "preday"),
  roll_dst = getOption("timeplyr.roll_dst", "boundary"),
  log_limit = 8
)

time_complete(
  data,
  time = NULL,
  ...,
  .by = NULL,
  time_by = NULL,
  from = NULL,
  to = NULL,
  time_type = getOption("timeplyr.time_type", "auto"),
  time_floor = FALSE,
  week_start = getOption("lubridate.week.start", 1),
  expand_type = c("nesting", "crossing"),
  sort = TRUE,
  keep_class = TRUE,
  fill = NA,
  roll_month = getOption("timeplyr.roll_month", "preday"),
  roll_dst = getOption("timeplyr.roll_dst", "boundary"),
  log_limit = 8
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="time_expand_+3A_data">data</code></td>
<td>
<p>A data frame.</p>
</td></tr>
<tr><td><code id="time_expand_+3A_time">time</code></td>
<td>
<p>Time variable.</p>
</td></tr>
<tr><td><code id="time_expand_+3A_...">...</code></td>
<td>
<p>Groups to expand.</p>
</td></tr>
<tr><td><code id="time_expand_+3A_.by">.by</code></td>
<td>
<p>(Optional). A selection of columns to group by for this operation.
Columns are specified using tidy-select.</p>
</td></tr>
<tr><td><code id="time_expand_+3A_time_by">time_by</code></td>
<td>
<p>Time unit. <br />
Must be one of the three:
</p>

<ul>
<li><p> string, specifying either the unit or the number and unit, e.g
<code>time_by = "days"</code> or <code>time_by = "2 weeks"</code>
</p>
</li>
<li><p> named list of length one, the unit being the name, and
the number the value of the list, e.g. <code>list("days" = 7)</code>.
For the vectorized time functions, you can supply multiple values,
e.g. <code>list("days" = 1:10)</code>.
</p>
</li>
<li><p> Numeric vector. If time_by is a numeric vector and x is not a date/datetime,
then arithmetic is used, e.g <code>time_by = 1</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="time_expand_+3A_from">from</code></td>
<td>
<p>Time series start date.</p>
</td></tr>
<tr><td><code id="time_expand_+3A_to">to</code></td>
<td>
<p>Time series end date.</p>
</td></tr>
<tr><td><code id="time_expand_+3A_time_type">time_type</code></td>
<td>
<p>If &quot;auto&quot;, <code>periods</code> are used for
the time expansion when days, weeks, months or years are specified,
and <code>durations</code> are used otherwise.</p>
</td></tr>
<tr><td><code id="time_expand_+3A_time_floor">time_floor</code></td>
<td>
<p>Should <code>from</code> be floored to the
nearest unit specified through the <code>time_by</code>
argument? This is particularly useful for
starting sequences at the beginning of a week or month for example.</p>
</td></tr>
<tr><td><code id="time_expand_+3A_week_start">week_start</code></td>
<td>
<p>day on which week starts following ISO conventions - 1
means Monday (default), 7 means Sunday.
This is only used when <code>floor_date = TRUE</code>.</p>
</td></tr>
<tr><td><code id="time_expand_+3A_expand_type">expand_type</code></td>
<td>
<p>Type of time expansion to use where &quot;nesting&quot;
finds combinations already present in the data,
&quot;crossing&quot; finds all combinations of values in the group variables.</p>
</td></tr>
<tr><td><code id="time_expand_+3A_sort">sort</code></td>
<td>
<p>Logical. If <code>TRUE</code> expanded/completed variables are sorted.</p>
</td></tr>
<tr><td><code id="time_expand_+3A_keep_class">keep_class</code></td>
<td>
<p>Logical. If <code>TRUE</code> then the class of the input data is retained.
If <code>FALSE</code>, which is sometimes faster, a <code>data.table</code> is returned.</p>
</td></tr>
<tr><td><code id="time_expand_+3A_roll_month">roll_month</code></td>
<td>
<p>Control how impossible dates are handled when
month or year arithmetic is involved.
Options are &quot;preday&quot;, &quot;boundary&quot;, &quot;postday&quot;, &quot;full&quot; and &quot;NA&quot;.
See <code>?timechange::time_add</code> for more details.</p>
</td></tr>
<tr><td><code id="time_expand_+3A_roll_dst">roll_dst</code></td>
<td>
<p>See <code>?timechange::time_add</code> for the full list of details.</p>
</td></tr>
<tr><td><code id="time_expand_+3A_log_limit">log_limit</code></td>
<td>
<p>The maximum log10 number of rows that can be expanded.
Anything exceeding this will throw an error.</p>
</td></tr>
<tr><td><code id="time_expand_+3A_fill">fill</code></td>
<td>
<p>A named list containing value-name pairs to fill the named implicit missing values.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This works much the same as <code>tidyr::complete()</code>, except that
you can supply an additional <code>time</code> argument to allow for filling in time gaps,
expansion of time, as well as aggregating time to a higher unit.
<code>lubridate</code> is used for handling time, while <code>data.table</code> and <code>collapse</code> are used for
the data frame expansion.
</p>
<p>At the moment, within group combinations are ignored. This means when <code>expand_type = nesting</code>,
existing combinations of supplied groups across the entire dataset are used, and
when <code>expand_type = crossing</code>, all possible combinations of supplied groups across the <b>entire</b>
dataset are used as well.
</p>


<h3>Value</h3>

<p>A <code>data.frame</code> of expanded time by or across groups.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(timeplyr)
library(dplyr)
library(lubridate)
library(nycflights13)

x &lt;- flights$time_hour

time_num_gaps(x) # Missing hours

flights_count &lt;- flights %&gt;%
  fcount(time_hour)

# Fill in missing hours
flights_count %&gt;%
  time_complete(time = time_hour)

# You can specify units too
flights_count %&gt;%
  time_complete(time = time_hour, time_by = "hours")
flights_count %&gt;%
  time_complete(time = as_date(time_hour), time_by = "days") #  Nothing to complete here

# Where time_expand() and time_complete() really shine is how fast they are with groups
flights %&gt;%
  group_by(origin, dest) %&gt;%
  time_expand(time = time_hour, time_by = dweeks(1))

</code></pre>

<hr>
<h2 id='time_expandv'>Vector date and datetime functions</h2><span id='topic+time_expandv'></span><span id='topic+time_span'></span><span id='topic+time_completev'></span><span id='topic+time_summarisev'></span><span id='topic+time_countv'></span><span id='topic+time_span_size'></span>

<h3>Description</h3>

<p>These are atomic vector-based functions
of the tidy equivalents which all have a &quot;v&quot; suffix to denote this.
These are more geared towards programmers and allow for working with date and
datetime vectors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>time_expandv(
  x,
  time_by = NULL,
  from = NULL,
  to = NULL,
  g = NULL,
  use.g.names = TRUE,
  time_type = getOption("timeplyr.time_type", "auto"),
  time_floor = FALSE,
  week_start = getOption("lubridate.week.start", 1),
  roll_month = getOption("timeplyr.roll_month", "preday"),
  roll_dst = getOption("timeplyr.roll_dst", "boundary")
)

time_span(
  x,
  time_by = NULL,
  from = NULL,
  to = NULL,
  g = NULL,
  use.g.names = TRUE,
  time_type = getOption("timeplyr.time_type", "auto"),
  time_floor = FALSE,
  week_start = getOption("lubridate.week.start", 1),
  roll_month = getOption("timeplyr.roll_month", "preday"),
  roll_dst = getOption("timeplyr.roll_dst", "boundary")
)

time_completev(
  x,
  time_by = NULL,
  from = NULL,
  to = NULL,
  sort = TRUE,
  time_type = getOption("timeplyr.time_type", "auto"),
  time_floor = FALSE,
  week_start = getOption("lubridate.week.start", 1),
  roll_month = getOption("timeplyr.roll_month", "preday"),
  roll_dst = getOption("timeplyr.roll_dst", "boundary")
)

time_summarisev(
  x,
  time_by = NULL,
  from = NULL,
  to = NULL,
  sort = FALSE,
  unique = FALSE,
  time_type = getOption("timeplyr.time_type", "auto"),
  time_floor = FALSE,
  week_start = getOption("lubridate.week.start", 1),
  roll_month = getOption("timeplyr.roll_month", "preday"),
  roll_dst = getOption("timeplyr.roll_dst", "boundary"),
  include_interval = FALSE
)

time_countv(
  x,
  time_by = NULL,
  from = NULL,
  to = NULL,
  sort = TRUE,
  unique = TRUE,
  complete = FALSE,
  time_type = getOption("timeplyr.time_type", "auto"),
  include_interval = FALSE,
  time_floor = FALSE,
  week_start = getOption("lubridate.week.start", 1),
  roll_month = getOption("timeplyr.roll_month", "preday"),
  roll_dst = getOption("timeplyr.roll_dst", "boundary")
)

time_span_size(
  x,
  time_by = NULL,
  from = NULL,
  to = NULL,
  g = NULL,
  use.g.names = TRUE,
  time_type = getOption("timeplyr.time_type", "auto"),
  time_floor = FALSE,
  week_start = getOption("lubridate.week.start", 1)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="time_expandv_+3A_x">x</code></td>
<td>
<p>Time variable. <br />
Can be a <code>Date</code>, <code>POSIXt</code>, <code>numeric</code>, <code>integer</code>, <code>yearmon</code>, or <code>yearqtr</code>.</p>
</td></tr>
<tr><td><code id="time_expandv_+3A_time_by">time_by</code></td>
<td>
<p>Time unit. <br />
Must be one of the following:
</p>

<ul>
<li><p> string, specifying either the unit or the number and unit, e.g
<code>time_by = "days"</code> or <code>time_by = "2 weeks"</code>
</p>
</li>
<li><p> named list of length one, the unit being the name, and
the number the value of the list, e.g. <code>list("days" = 7)</code>.
For the vectorized time functions, you can supply multiple values,
e.g. <code>list("days" = 1:10)</code>.
</p>
</li>
<li><p> Numeric vector. If time_by is a numeric vector and x is not a date/datetime,
then arithmetic is used, e.g <code>time_by = 1</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="time_expandv_+3A_from">from</code></td>
<td>
<p>Time series start date.</p>
</td></tr>
<tr><td><code id="time_expandv_+3A_to">to</code></td>
<td>
<p>Time series end date.</p>
</td></tr>
<tr><td><code id="time_expandv_+3A_g">g</code></td>
<td>
<p>Grouping object passed directly to <code>collapse::GRP()</code>.
This can for example be a vector or data frame.</p>
</td></tr>
<tr><td><code id="time_expandv_+3A_use.g.names">use.g.names</code></td>
<td>
<p>Should the result include group names?
Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="time_expandv_+3A_time_type">time_type</code></td>
<td>
<p>If &quot;auto&quot;, <code>periods</code> are used for
the time expansion when days, weeks, months or years are specified,
and <code>durations</code> are used otherwise.</p>
</td></tr>
<tr><td><code id="time_expandv_+3A_time_floor">time_floor</code></td>
<td>
<p>Should <code>from</code> be floored to the nearest unit specified
through the <code>time_by</code> argument?
This is particularly useful for starting sequences at the
beginning of a week or month for example.</p>
</td></tr>
<tr><td><code id="time_expandv_+3A_week_start">week_start</code></td>
<td>
<p>day on which week starts following ISO conventions - 1
means Monday (default), 7 means Sunday.
This is only used when <code>time_floor = TRUE</code>.</p>
</td></tr>
<tr><td><code id="time_expandv_+3A_roll_month">roll_month</code></td>
<td>
<p>Control how impossible dates are handled when
month or year arithmetic is involved.
Options are &quot;preday&quot;, &quot;boundary&quot;, &quot;postday&quot;, &quot;full&quot; and &quot;NA&quot;.
See <code>?timechange::time_add</code> for more details.</p>
</td></tr>
<tr><td><code id="time_expandv_+3A_roll_dst">roll_dst</code></td>
<td>
<p>See <code>?timechange::time_add</code> for the full list of details.</p>
</td></tr>
<tr><td><code id="time_expandv_+3A_sort">sort</code></td>
<td>
<p>Should the output be sorted? Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="time_expandv_+3A_unique">unique</code></td>
<td>
<p>Should the result be unique or match the length of the vector?
Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="time_expandv_+3A_include_interval">include_interval</code></td>
<td>
<p>Logical. If <code>TRUE</code> then the result is a <code>tibble</code>
with a column &quot;interval&quot; of the form <code style="white-space: pre;">&#8288;time_min &lt;= x &lt; time_max&#8288;</code>
showing the time interval in which the aggregated time points belong to.
The rightmost interval will always be closed.</p>
</td></tr>
<tr><td><code id="time_expandv_+3A_complete">complete</code></td>
<td>
<p>Logical. If <code>TRUE</code> implicit gaps in time are filled
before counting and after time aggregation (controlled using <code>time_by</code>).
The default is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vectors (typically the same class as <code>x</code>) of varying lengths depending
on the arguments supplied.
<code>time_countv()</code> returns a <code>tibble</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(timeplyr)
library(dplyr)
library(lubridate)
library(nycflights13)

x &lt;- unique(flights$time_hour)

# Number of missing hours
time_num_gaps(x)

# Same as above
time_span_size(x) - length(unique(x))

# Time sequence that spans the data
time_span(x) # Automatically detects hour granularity
time_span(x, time_by = "month")
time_span(x, time_by = list("quarters" = 1),
             to = today(),
             # Floor start of sequence to nearest month
             time_floor = TRUE)

# Complete missing gaps in time using time_completev
y &lt;- time_completev(x, time_by = "hour")
identical(y[!y %in% x], time_gaps(x))

# Summarise time using time_summarisev
time_summarisev(y, time_by = "quarter")
time_summarisev(y, time_by = "quarter", unique = TRUE)
flights %&gt;%
  fcount(quarter_start = time_summarisev(time_hour, "quarter"))
# Alternatively
time_countv(x, time_by = "quarter")
# If you want the above as an atomic vector just use tibble::deframe

</code></pre>

<hr>
<h2 id='time_gaps'>Gaps in a regular time sequence</h2><span id='topic+time_gaps'></span><span id='topic+time_num_gaps'></span><span id='topic+time_has_gaps'></span>

<h3>Description</h3>

<p><code>time_gaps()</code> checks for missing gaps in time for any
regular date or datetime sequence.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>time_gaps(
  x,
  time_by = NULL,
  g = NULL,
  use.g.names = TRUE,
  time_type = getOption("timeplyr.time_type", "auto"),
  check_time_regular = FALSE
)

time_num_gaps(
  x,
  time_by = NULL,
  g = NULL,
  use.g.names = TRUE,
  na.rm = TRUE,
  time_type = getOption("timeplyr.time_type", "auto"),
  check_time_regular = FALSE
)

time_has_gaps(
  x,
  time_by = NULL,
  g = NULL,
  use.g.names = TRUE,
  na.rm = TRUE,
  time_type = getOption("timeplyr.time_type", "auto"),
  check_time_regular = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="time_gaps_+3A_x">x</code></td>
<td>
<p>A date, datetime or numeric vector.</p>
</td></tr>
<tr><td><code id="time_gaps_+3A_time_by">time_by</code></td>
<td>
<p>Time unit. <br />
Must be one of the three:
</p>

<ul>
<li><p> string, specifying either the unit or the number and unit, e.g
<code>time_by = "days"</code> or <code>time_by = "2 weeks"</code>
</p>
</li>
<li><p> named list of length one, the unit being the name, and
the number the value of the list, e.g. <code>list("days" = 7)</code>.
For the vectorized time functions, you can supply multiple values,
e.g. <code>list("days" = 1:10)</code>.
</p>
</li>
<li><p> Numeric vector. If time_by is a numeric vector and x is not a date/datetime,
then arithmetic is used, e.g <code>time_by = 1</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="time_gaps_+3A_g">g</code></td>
<td>
<p>Grouping object passed directly to <code>collapse::GRP()</code>.
This can for example be a vector or data frame.</p>
</td></tr>
<tr><td><code id="time_gaps_+3A_use.g.names">use.g.names</code></td>
<td>
<p>Should the result include group names?
Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="time_gaps_+3A_time_type">time_type</code></td>
<td>
<p>Time type, either &quot;auto&quot;, &quot;duration&quot; or &quot;period&quot;.
With larger data, it is recommended to use <code>time_type = "duration"</code> for
speed and efficiency.</p>
</td></tr>
<tr><td><code id="time_gaps_+3A_check_time_regular">check_time_regular</code></td>
<td>
<p>Should the time vector be
checked to see if it is regular (with or without gaps)?
Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="time_gaps_+3A_na.rm">na.rm</code></td>
<td>
<p>Should <code>NA</code> values be removed? Default is <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When <code>check_time_regular</code> is TRUE, <code>x</code> is passed to
<code>time_is_regular</code>, which checks that the time elapsed between successive
values are in increasing order and are whole numbers.
For more strict checks, see <code>?time_is_regular</code>.
</p>


<h3>Value</h3>

<p><code>time_gaps</code> returns a vector of time gaps. <br />
<code>time_num_gaps</code> returns the number of time gaps. <br />
<code>time_has_gaps</code> returns a logical(1) of whether there are gaps.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(timeplyr)
library(dplyr)
library(lubridate)
library(nycflights13)

missing_dates(flights$time_hour)
time_has_gaps(flights$time_hour)
time_num_gaps(flights$time_hour)
time_gaps(flights$time_hour)
time_num_gaps(flights$time_hour, g = flights$origin)

# Number of missing hours by origin and dest
flights %&gt;%
  group_by(origin, dest) %&gt;%
  summarise(n_missing = time_num_gaps(time_hour, "hours"))

</code></pre>

<hr>
<h2 id='time_ggplot'>Quick time-series ggplot</h2><span id='topic+time_ggplot'></span>

<h3>Description</h3>

<p><code>time_ggplot()</code> is a neat way to quickly
plot aggregate time-series data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>time_ggplot(
  data,
  time,
  value,
  group = NULL,
  facet = FALSE,
  geom = ggplot2::geom_line,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="time_ggplot_+3A_data">data</code></td>
<td>
<p>A data frame</p>
</td></tr>
<tr><td><code id="time_ggplot_+3A_time">time</code></td>
<td>
<p>Time variable using <code>tidyselect</code>.</p>
</td></tr>
<tr><td><code id="time_ggplot_+3A_value">value</code></td>
<td>
<p>Value variable using <code>tidyselect</code>.</p>
</td></tr>
<tr><td><code id="time_ggplot_+3A_group">group</code></td>
<td>
<p>(Optional) Group variable using <code>tidyselect</code>.</p>
</td></tr>
<tr><td><code id="time_ggplot_+3A_facet">facet</code></td>
<td>
<p>When groups are supplied, should multi-series be
plotted separately or on the same plot?
Default is <code>FALSE</code>, or together.</p>
</td></tr>
<tr><td><code id="time_ggplot_+3A_geom">geom</code></td>
<td>
<p><code>ggplot2</code> 'geom' type. Default is <code>geom_line()</code>.</p>
</td></tr>
<tr><td><code id="time_ggplot_+3A_...">...</code></td>
<td>
<p>Further arguments passed to the chosen 'geom'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>ggplot</code>.
</p>


<h3>See Also</h3>

<p><a href="#topic+ts_as_tibble">ts_as_tibble</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
library(timeplyr)
library(ggplot2)

# It's as easy as this
AirPassengers %&gt;%
  ts_as_tibble() %&gt;%
  time_ggplot(time, value)

# And this
EuStockMarkets %&gt;%
  ts_as_tibble() %&gt;%
  time_ggplot(time, value, group)

# zoo example
x.Date &lt;- as.Date("2003-02-01") + c(1, 3, 7, 9, 14) - 1
x &lt;- zoo::zoo(rnorm(5), x.Date)
x %&gt;%
  ts_as_tibble() %&gt;%
  time_ggplot(time, value)

# An example using raw data

ebola &lt;- outbreaks::ebola_sim$linelist

# We can build a helper to count and complete
# Using the same time grid

count_and_complete &lt;- function(.data, time, ...,
                               time_by = NULL, time_floor = TRUE){
  .data %&gt;%
    time_count(!!dplyr::enquo(time), ..., time_by = time_by,
               time_floor = time_floor) %&gt;%
    time_complete(!!dplyr::enquo(time), ..., time_by = time_by,
                  time_floor = time_floor, fill = list(n = 0))
}
ebola %&gt;%
  count_and_complete(date_of_onset, outcome, time_by = "week") %&gt;%
  time_ggplot(date_of_onset, n, geom = geom_blank) +
  geom_col(aes(fill = outcome))

</code></pre>

<hr>
<h2 id='time_id'>Time ID</h2><span id='topic+time_id'></span>

<h3>Description</h3>

<p>Generate a time ID that signifies how many time steps away
a time value is from the starting time point or more intuitively,
this is the time passed since
the first time point.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>time_id(
  x,
  time_by = NULL,
  g = NULL,
  na_skip = TRUE,
  time_type = getOption("timeplyr.time_type", "auto"),
  shift = 1L
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="time_id_+3A_x">x</code></td>
<td>
<p>Time variable. <br />
Can be a <code>Date</code>, <code>POSIXt</code>, <code>numeric</code>, <code>integer</code>, <code>yearmon</code>, or <code>yearqtr</code>.</p>
</td></tr>
<tr><td><code id="time_id_+3A_time_by">time_by</code></td>
<td>
<p>Time unit. <br />
This signifies the granularity of the time data with which to measure gaps
in the sequence.
If your data is daily for example, supply <code>time_by = "days"</code>.
If weekly, supply <code>time_by = "week"</code>.
Must be one of the three:
</p>

<ul>
<li><p> string, specifying either the unit or the number and unit, e.g
<code>time_by = "days"</code> or <code>time_by = "2 weeks"</code>
</p>
</li>
<li><p> named list of length one, the unit being the name, and
the number the value of the list, e.g. <code>list("days" = 7)</code>.
For the vectorized time functions, you can supply multiple values,
e.g. <code>list("days" = 1:10)</code>.
</p>
</li>
<li><p> Numeric vector. If time_by is a numeric vector and x is not a date/datetime,
then arithmetic is used, e.g <code>time_by = 1</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="time_id_+3A_g">g</code></td>
<td>
<p>Object used for grouping x.
This can for example be a vector or data frame.
<code>g</code> is passed directly to <code>collapse::GRP()</code>.</p>
</td></tr>
<tr><td><code id="time_id_+3A_na_skip">na_skip</code></td>
<td>
<p>Should <code>NA</code> values be skipped? Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="time_id_+3A_time_type">time_type</code></td>
<td>
<p>If &quot;auto&quot;, <code>periods</code> are used for
the time expansion when days, weeks, months or years are specified,
and <code>durations</code> are used otherwise.</p>
</td></tr>
<tr><td><code id="time_id_+3A_shift">shift</code></td>
<td>
<p>Value used to shift the time IDs. Typically this is 1 to ensure the
IDs start at 1 but can be 0 or even negative if for example
your time values are going backwards in time.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is heavily inspired by <code>collapse::timeid</code> but differs in 3 ways:
</p>

<ul>
<li><p> The time steps need not be the greatest common divisor of successive
differences
</p>
</li>
<li><p> The starting time point may not necessarily
be the earliest chronologically and thus <code>time_id</code> can generate negative IDs.
</p>
</li>
<li> <p><code>g</code> can be supplied to calculate IDs by group.
</p>
</li></ul>

<p><code>time_id(c(3, 2, 1))</code> is not the same as <code>collapse::timeid(c(3, 2, 1))</code>.
In general <code>time_id(sort(x))</code>
should be equal to  <code>collapse::timeid(sort(x))</code>.
The time difference GCD is always calculated using all the data and not
by-group.
</p>


<h3>Value</h3>

<p>An integer vector the same length as <code>x</code>.
</p>


<h3>See Also</h3>

<p><a href="#topic+time_elapsed">time_elapsed</a> <a href="#topic+time_seq_id">time_seq_id</a>
</p>

<hr>
<h2 id='time_is_regular'>Is time a regular sequence? (Experimental)</h2><span id='topic+time_is_regular'></span>

<h3>Description</h3>

<p>This function is a fast way to check if a time vector
is a regular sequence, possibly for many groups.
Regular in this context means that the lagged time differences are a
whole multiple of the specified time unit. <br />
This means <code>x</code> can be a regular sequence with or without gaps in time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>time_is_regular(
  x,
  time_by = NULL,
  g = NULL,
  use.g.names = TRUE,
  na.rm = TRUE,
  time_type = getOption("timeplyr.time_type", "auto"),
  allow_gaps = TRUE,
  allow_dups = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="time_is_regular_+3A_x">x</code></td>
<td>
<p>A vector. Can be a
<code>Date</code>, <code>POSIXt</code>, <code>numeric</code>, <code>integer</code>, <code>yearmon</code>, or <code>yearqtr</code>.</p>
</td></tr>
<tr><td><code id="time_is_regular_+3A_time_by">time_by</code></td>
<td>
<p>Time unit. <br />
Must be one of the three:
</p>

<ul>
<li><p> string, specifying either the unit or the number and unit, e.g
<code>time_by = "days"</code> or <code>time_by = "2 weeks"</code>
</p>
</li>
<li><p> named list of length one, the unit being the name, and
the number the value of the list, e.g. <code>list("days" = 7)</code>.
For the vectorized time functions, you can supply multiple values,
e.g. <code>list("days" = 1:10)</code>.
</p>
</li>
<li><p> Numeric vector. If time_by is a numeric vector and x is not a date/datetime,
then arithmetic is used, e.g <code>time_by = 1</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="time_is_regular_+3A_g">g</code></td>
<td>
<p>Grouping object passed directly to <code>collapse::GRP()</code>.
This can for example be a vector or data frame. <br />
Note that when <code>g</code> is supplied the output is a logical with length
matching the number of unique groups.</p>
</td></tr>
<tr><td><code id="time_is_regular_+3A_use.g.names">use.g.names</code></td>
<td>
<p>Should the result include group names?
Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="time_is_regular_+3A_na.rm">na.rm</code></td>
<td>
<p>Should <code>NA</code> values be removed before calculation?
Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="time_is_regular_+3A_time_type">time_type</code></td>
<td>
<p>If &quot;auto&quot;, <code>periods</code> are used for
the time expansion when days, weeks,
months or years are specified, and <code>durations</code>
are used otherwise. If <code>durations</code>
are used the output is always of class <code>POSIXt</code>.</p>
</td></tr>
<tr><td><code id="time_is_regular_+3A_allow_gaps">allow_gaps</code></td>
<td>
<p>Should gaps be allowed? Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="time_is_regular_+3A_allow_dups">allow_dups</code></td>
<td>
<p>Should duplicates be allowed? Default is <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical vector the same length as the number of supplied groups.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(timeplyr)
library(lubridate)
library(dplyr)

x &lt;- 1:5
y &lt;- c(1, 1, 2, 3, 5)

time_is_regular(x)
time_is_regular(y)

increment &lt;- 1

# No duplicates allowed
time_is_regular(x, increment, allow_dups = FALSE)
time_is_regular(y, increment, allow_dups = FALSE)

# No gaps allowed
time_is_regular(x, increment, allow_gaps = FALSE)
time_is_regular(y, increment, allow_gaps = FALSE)

# Grouped
eu_stock &lt;- ts_as_tibble(EuStockMarkets)
eu_stock &lt;- eu_stock %&gt;%
  mutate(date = as_date(
    date_decimal(time)
  ))

time_is_regular(eu_stock$date, g = eu_stock$group,
                time_by = 1)
# This makes sense as no trading occurs on weekends and holidays
time_is_regular(eu_stock$date, g = eu_stock$group,
                time_by = 1,
                allow_gaps = FALSE)

</code></pre>

<hr>
<h2 id='time_lag'>Time-lagged values</h2><span id='topic+time_lag'></span>

<h3>Description</h3>

<p>Time-lagged values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>time_lag(
  x,
  k = 1L,
  time = seq_along(x),
  g = NULL,
  time_type = getOption("timeplyr.time_type", "auto"),
  roll_month = getOption("timeplyr.roll_month", "preday"),
  roll_dst = getOption("timeplyr.roll_dst", "boundary")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="time_lag_+3A_x">x</code></td>
<td>
<p>Vector.</p>
</td></tr>
<tr><td><code id="time_lag_+3A_k">k</code></td>
<td>
<p>Lag size, must be one of the following:
</p>

<ul>
<li><p> string, e.g <code>"day"</code> or <code>"2 weeks"</code>
</p>
</li>
<li><p> lubridate duration or period object, e.g. <code>days(1)</code> or <code>ddays(1)</code>.
</p>
</li>
<li><p> named list of length one, e.g. <code>list("days" = 7)</code>.
</p>
</li>
<li><p> Numeric vector, e.g. <code>7</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="time_lag_+3A_time">time</code></td>
<td>
<p>(Optional) time index. <br />
Can be a <code>Date</code>, <code>POSIXt</code>, <code>numeric</code>, <code>integer</code>,
<code>yearmon</code>, or <code>yearqtr</code> vector.</p>
</td></tr>
<tr><td><code id="time_lag_+3A_g">g</code></td>
<td>
<p>Grouping object passed directly to <code>collapse::GRP()</code>.
This can for example be a vector or data frame.</p>
</td></tr>
<tr><td><code id="time_lag_+3A_time_type">time_type</code></td>
<td>
<p>If &quot;auto&quot;, <code>periods</code> are used for
the time expansion when lubridate periods are specified or when
days, weeks, months or years are specified,
and <code>durations</code> are used otherwise.</p>
</td></tr>
<tr><td><code id="time_lag_+3A_roll_month">roll_month</code></td>
<td>
<p>Control how impossible dates are handled when
month or year arithmetic is involved.
Options are &quot;preday&quot;, &quot;boundary&quot;, &quot;postday&quot;, &quot;full&quot; and &quot;NA&quot;.
See <code>?timechange::time_add</code> for more details.</p>
</td></tr>
<tr><td><code id="time_lag_+3A_roll_dst">roll_dst</code></td>
<td>
<p>See <code>?timechange::time_add</code> for the full list of details.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of <code>length(x)</code> lagged by a specified time unit.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(timeplyr)

x &lt;- 1:10
t &lt;- time_seq(Sys.Date(), len = 10, time_by = "3 days")

dplyr::lag(x)
time_lag(x)
time_lag(x, time = t, k = "3 days")

# No values exist at t-1 days
time_lag(x, time = t, k = 1)

</code></pre>

<hr>
<h2 id='time_mutate'>A time based extension to <code>dplyr::mutate()</code>.</h2><span id='topic+time_mutate'></span>

<h3>Description</h3>

<p>This works much the same as <code>dplyr::mutate()</code>, except that
you can supply an additional <code>time</code> argument to allow for
aggregating time to a higher unit.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>time_mutate(
  data,
  time = NULL,
  ...,
  time_by = NULL,
  from = NULL,
  to = NULL,
  time_type = getOption("timeplyr.time_type", "auto"),
  include_interval = FALSE,
  .by = NULL,
  .keep = c("all", "used", "unused", "none"),
  time_floor = FALSE,
  week_start = getOption("lubridate.week.start", 1),
  roll_month = getOption("timeplyr.roll_month", "preday"),
  roll_dst = getOption("timeplyr.roll_dst", "boundary")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="time_mutate_+3A_data">data</code></td>
<td>
<p>A data frame.</p>
</td></tr>
<tr><td><code id="time_mutate_+3A_time">time</code></td>
<td>
<p>Time variable.</p>
</td></tr>
<tr><td><code id="time_mutate_+3A_...">...</code></td>
<td>
<p>Additional variables to include.</p>
</td></tr>
<tr><td><code id="time_mutate_+3A_time_by">time_by</code></td>
<td>
<p>Time unit. <br />
Must be one of the three:
</p>

<ul>
<li><p> string, specifying either the unit or the number and unit, e.g
<code>time_by = "days"</code> or <code>time_by = "2 weeks"</code>
</p>
</li>
<li><p> named list of length one, the unit being the name, and
the number the value of the list, e.g. <code>list("days" = 7)</code>.
For the vectorized time functions, you can supply multiple values,
e.g. <code>list("days" = 1:10)</code>.
</p>
</li>
<li><p> Numeric vector. If time_by is a numeric vector and x is not a date/datetime,
then arithmetic is used, e.g <code>time_by = 1</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="time_mutate_+3A_from">from</code></td>
<td>
<p>Time series start date.</p>
</td></tr>
<tr><td><code id="time_mutate_+3A_to">to</code></td>
<td>
<p>Time series end date.</p>
</td></tr>
<tr><td><code id="time_mutate_+3A_time_type">time_type</code></td>
<td>
<p>If &quot;auto&quot;, <code>periods</code> are used for
the time expansion when days, weeks, months or years are specified,
and <code>durations</code>
are used otherwise.</p>
</td></tr>
<tr><td><code id="time_mutate_+3A_include_interval">include_interval</code></td>
<td>
<p>Logical. If <code>TRUE</code> then
a column &quot;interval&quot; of the form <code style="white-space: pre;">&#8288;time_min &lt;= x &lt; time_max&#8288;</code> is added
showing the time interval in which the respective counts belong to.
The rightmost interval will always be closed.</p>
</td></tr>
<tr><td><code id="time_mutate_+3A_.by">.by</code></td>
<td>
<p>(Optional). A selection of columns to group by for this operation.
Columns are specified using tidy-select.</p>
</td></tr>
<tr><td><code id="time_mutate_+3A_.keep">.keep</code></td>
<td>
<p>Control which columns are retained.
See <code>?dplyr::mutate</code> for more details.</p>
</td></tr>
<tr><td><code id="time_mutate_+3A_time_floor">time_floor</code></td>
<td>
<p>Should <code>from</code> be floored to the nearest unit specified
through the <code>time_by</code>
argument? This is particularly useful for starting
sequences at the beginning of a week or month for example.</p>
</td></tr>
<tr><td><code id="time_mutate_+3A_week_start">week_start</code></td>
<td>
<p>day on which week starts following ISO conventions - 1
means Monday (default), 7 means Sunday.
This is only used when <code>floor_date = TRUE</code>.</p>
</td></tr>
<tr><td><code id="time_mutate_+3A_roll_month">roll_month</code></td>
<td>
<p>Control how impossible dates are handled when
month or year arithmetic is involved.
Options are &quot;preday&quot;, &quot;boundary&quot;, &quot;postday&quot;, &quot;full&quot; and &quot;NA&quot;.
See <code>?timechange::time_add</code> for more details.</p>
</td></tr>
<tr><td><code id="time_mutate_+3A_roll_dst">roll_dst</code></td>
<td>
<p>See <code>?timechange::time_add</code> for the full list of details.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code> with added columns.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(timeplyr)
library(dplyr)
library(lubridate)
library(nycflights13)

# Like the other time_ functions, it allows for an additional time variable to
# aggregate by
flights %&gt;%
  fdistinct(time_hour) %&gt;%
  time_mutate(time = across(time_hour, as_date),
              time_by = "month", .keep = "none",
              include_interval = TRUE) %&gt;%
  fdistinct()

</code></pre>

<hr>
<h2 id='time_roll_diff'>Lagged time differences</h2><span id='topic+time_roll_diff'></span>

<h3>Description</h3>

<p><code>time_roll_diff</code> is like <code>diff()</code> but always returns a <code>numeric(length(x))</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>time_roll_diff(
  time,
  time_by = 1,
  lag = 1L,
  g = NULL,
  time_type = getOption("timeplyr.time_type", "auto")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="time_roll_diff_+3A_time">time</code></td>
<td>
<p>Time variable. <br />
Can be a <code>Date</code>, <code>POSIXt</code>, <code>numeric</code>, <code>integer</code>, <code>yearmon</code>, or <code>yearqtr</code>.</p>
</td></tr>
<tr><td><code id="time_roll_diff_+3A_time_by">time_by</code></td>
<td>
<p>Time unit. <br />
Must be one of the following:
</p>

<ul>
<li><p> string, specifying either the unit or the number and unit, e.g
<code>time_by = "days"</code> or <code>time_by = "2 weeks"</code>
</p>
</li>
<li><p> named list of length one, the unit being the name, and
the number the value of the list, e.g. <code>list("days" = 7)</code>.
For the vectorized time functions, you can supply multiple values,
e.g. <code>list("days" = 1:10)</code>.
</p>
</li>
<li><p> Numeric vector. If time_by is a numeric vector and x is not a date/datetime,
then arithmetic is used, e.g <code>time_by = 1</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="time_roll_diff_+3A_lag">lag</code></td>
<td>
<p>A number indicating the lag size. Negative values are allowed.</p>
</td></tr>
<tr><td><code id="time_roll_diff_+3A_g">g</code></td>
<td>
<p>Grouping object passed directly to <code>collapse::GRP()</code>.
This can for example be a vector or data frame.</p>
</td></tr>
<tr><td><code id="time_roll_diff_+3A_time_type">time_type</code></td>
<td>
<p>If &quot;auto&quot;, <code>periods</code> are used for
the time expansion when days, weeks, months or years are specified,
and <code>durations</code> are used otherwise.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>time_elapsed</code> is very similar to <code>time_roll_diff</code> but
is more general in that it supports
cumulative time differencing, <code>NA</code> filling as well as <code>NA</code> skipping.
</p>


<h3>Value</h3>

<p>A numeric vector the same length as <code>x.</code>
on the arguments supplied.
</p>


<h3>See Also</h3>

<p><a href="#topic+time_elapsed">time_elapsed</a>
</p>

<hr>
<h2 id='time_roll_sum'>Fast time-based by-group rolling sum/mean - Currently experimental</h2><span id='topic+time_roll_sum'></span><span id='topic+time_roll_mean'></span><span id='topic+time_roll_growth_rate'></span><span id='topic+time_roll_window_size'></span><span id='topic+time_roll_window'></span><span id='topic+time_roll_apply'></span>

<h3>Description</h3>

<p><code>time_roll_sum</code> and <code>time_roll_mean</code> are efficient
methods for calculating a rolling sum and mean respectively given
many groups and with respect to a date or datetime time index. <br />
It is always aligned &quot;right&quot;. <br />
<code>time_roll_window</code> splits <code>x</code> into windows based on the index. <br />
<code>time_roll_window_size</code> returns the window sizes for all indices of <code>x</code>. <br />
<code>time_roll_apply</code> is a generic function that applies any function
on a rolling basis with respect to a time index. <br />
</p>
<p><code>time_roll_growth_rate</code> can efficiently calculate by-group
rolling growth rates with respect to a date/datetime index.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>time_roll_sum(
  x,
  window = Inf,
  time = seq_along(x),
  weights = NULL,
  g = NULL,
  partial = TRUE,
  close_left_boundary = FALSE,
  na.rm = TRUE,
  time_type = getOption("timeplyr.time_type", "auto"),
  roll_month = getOption("timeplyr.roll_month", "preday"),
  roll_dst = getOption("timeplyr.roll_dst", "boundary"),
  ...
)

time_roll_mean(
  x,
  window = Inf,
  time = seq_along(x),
  weights = NULL,
  g = NULL,
  partial = TRUE,
  close_left_boundary = FALSE,
  na.rm = TRUE,
  time_type = getOption("timeplyr.time_type", "auto"),
  roll_month = getOption("timeplyr.roll_month", "preday"),
  roll_dst = getOption("timeplyr.roll_dst", "boundary"),
  ...
)

time_roll_growth_rate(
  x,
  window = Inf,
  time = seq_along(x),
  time_step = NULL,
  g = NULL,
  partial = TRUE,
  close_left_boundary = FALSE,
  na.rm = TRUE,
  time_type = getOption("timeplyr.time_type", "auto"),
  roll_month = getOption("timeplyr.roll_month", "preday"),
  roll_dst = getOption("timeplyr.roll_dst", "boundary")
)

time_roll_window_size(
  time,
  window = Inf,
  g = NULL,
  partial = TRUE,
  close_left_boundary = FALSE,
  time_type = getOption("timeplyr.time_type", "auto"),
  roll_month = getOption("timeplyr.roll_month", "preday"),
  roll_dst = getOption("timeplyr.roll_dst", "boundary")
)

time_roll_window(
  x,
  window = Inf,
  time = seq_along(x),
  g = NULL,
  partial = TRUE,
  close_left_boundary = FALSE,
  time_type = getOption("timeplyr.time_type", "auto"),
  roll_month = getOption("timeplyr.roll_month", "preday"),
  roll_dst = getOption("timeplyr.roll_dst", "boundary")
)

time_roll_apply(
  x,
  window = Inf,
  fun,
  time = seq_along(x),
  g = NULL,
  partial = TRUE,
  unlist = FALSE,
  close_left_boundary = FALSE,
  time_type = getOption("timeplyr.time_type", "auto"),
  roll_month = getOption("timeplyr.roll_month", "preday"),
  roll_dst = getOption("timeplyr.roll_dst", "boundary")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="time_roll_sum_+3A_x">x</code></td>
<td>
<p>Numeric vector.</p>
</td></tr>
<tr><td><code id="time_roll_sum_+3A_window">window</code></td>
<td>
<p>Time window size (Default is <code>Inf</code>).
Must be one of the following:
</p>

<ul>
<li><p> string, e.g <code>window = "day"</code> or <code>window = "2 weeks"</code>
</p>
</li>
<li><p> lubridate duration or period object, e.g. <code>days(1)</code> or <code>ddays(1)</code>.
</p>
</li>
<li><p> named list of length one, e.g. <code>list("days" = 7)</code>.
</p>
</li>
<li><p> Numeric vector, e.g. <code>window = 7</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="time_roll_sum_+3A_time">time</code></td>
<td>
<p>(Optional) time index. <br />
Can be a <code>Date</code>, <code>POSIXt</code>, <code>numeric</code>, <code>integer</code>,
<code>yearmon</code>, or <code>yearqtr</code> vector.</p>
</td></tr>
<tr><td><code id="time_roll_sum_+3A_weights">weights</code></td>
<td>
<p>Importance weights. Must be the same length as x.
Currently, no normalisation of weights occurs.</p>
</td></tr>
<tr><td><code id="time_roll_sum_+3A_g">g</code></td>
<td>
<p>Grouping object passed directly to <code>collapse::GRP()</code>.
This can for example be a vector or data frame.</p>
</td></tr>
<tr><td><code id="time_roll_sum_+3A_partial">partial</code></td>
<td>
<p>Should calculations be done using partial windows?
Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="time_roll_sum_+3A_close_left_boundary">close_left_boundary</code></td>
<td>
<p>Should the left boundary be closed?
For example, if you specify <code>window = "day"</code> and
<code>time = c(today(), today() + 1)</code>, <br />
a value of <code>FALSE</code> would result in the window vector <code>c(1, 1)</code> whereas
a value of <code>TRUE</code> would result in the window vector <code>c(1, 2)</code>.</p>
</td></tr>
<tr><td><code id="time_roll_sum_+3A_na.rm">na.rm</code></td>
<td>
<p>Should missing values be removed for the calculation?
The default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="time_roll_sum_+3A_time_type">time_type</code></td>
<td>
<p>If &quot;auto&quot;, <code>periods</code> are used for
the time expansion when lubridate periods are specified or when
days, weeks, months or years are specified,
and <code>durations</code> are used otherwise.</p>
</td></tr>
<tr><td><code id="time_roll_sum_+3A_roll_month">roll_month</code></td>
<td>
<p>Control how impossible dates are handled when
month or year arithmetic is involved.
Options are &quot;preday&quot;, &quot;boundary&quot;, &quot;postday&quot;, &quot;full&quot; and &quot;NA&quot;.
See <code>?timechange::time_add</code> for more details.</p>
</td></tr>
<tr><td><code id="time_roll_sum_+3A_roll_dst">roll_dst</code></td>
<td>
<p>See <code>?timechange::time_add</code> for the full list of details.</p>
</td></tr>
<tr><td><code id="time_roll_sum_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code>data.table::frollmean</code> and
<code>data.table::frollsum</code>.</p>
</td></tr>
<tr><td><code id="time_roll_sum_+3A_time_step">time_step</code></td>
<td>
<p>An optional but <b>important</b> argument
that follows the same input rules as <code>window</code>. <br />
It is currently only used only in <code>time_roll_growth_rate</code>. <br />
If this is supplied, the time differences across
gaps in time are incorporated into the growth
rate calculation. See <b>details</b> for more info.</p>
</td></tr>
<tr><td><code id="time_roll_sum_+3A_fun">fun</code></td>
<td>
<p>A function.</p>
</td></tr>
<tr><td><code id="time_roll_sum_+3A_unlist">unlist</code></td>
<td>
<p>Should the output of <code>time_roll_apply</code> be unlisted with
<code>unlist</code>? Default is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It is much faster if your data are already sorted such that
<code>!is.unsorted(order(g, x))</code> is <code>TRUE</code>.
</p>


<h4>Growth rates</h4>

<p>For growth rates across time, one can use <code>time_step</code> to incorporate
gaps in time into the calculation.
</p>
<p>For example: <br />
<code>x &lt;- c(10, 20)</code> <br />
<code>t &lt;- c(1, 10)</code> <br />
<code>k &lt;- Inf</code><br />
<code>time_roll_growth_rate(x, time = t, window = k)</code> = <code>c(1, 2)</code>
whereas <br />
<code>time_roll_growth_rate(x, time = t, window = k, time_step = 1)</code> = <code>c(1, 1.08)</code> <br />
The first is a doubling from 10 to 20, whereas the second implies a growth of
8% for each time step from 1 to 10. <br />
This allows us for example to calculate daily growth rates over the last x months,
even with missing days.
</p>



<h3>Value</h3>

<p>A vector the same length as <code>time</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(timeplyr)
library(lubridate)
library(dplyr)

time &lt;- time_seq(today(), today() + weeks(3),
                 time_by = "3 days")
set.seed(99)
x &lt;- sample.int(length(time))

roll_mean(x, window = 7)
roll_sum(x, window = 7)

time_roll_mean(x, window = ddays(7), time = time)
time_roll_sum(x, window = days(7), time = time)

# Alternatively and more verbosely
x_chunks &lt;- time_roll_window(x, window = 7, time = time)
x_chunks
vapply(x_chunks, mean, 0)

# Interval (x - 3 x]
time_roll_sum(x, window = ddays(3), time = time)

# An example with an irregular time series

t &lt;- today() + days(sort(sample(1:30, 20, TRUE)))
time_elapsed(t, days(1)) # See the irregular elapsed time
x &lt;- rpois(length(t), 10)

tibble(x, t) %&gt;%
  mutate(sum = time_roll_sum(x, time = t, window = days(3))) %&gt;%
  time_ggplot(t, sum)


### Rolling mean example with many time series

# Sparse time with duplicates
index &lt;- sort(sample(seq(now(), now() + dyears(3), by = "333 hours"),
                     250, TRUE))
x &lt;- matrix(rnorm(length(index) * 10^3),
            ncol = 10^3, nrow = length(index),
            byrow = FALSE)

zoo_ts &lt;- zoo::zoo(x, order.by = index)

# Normally you might attempt something like this
apply(x, 2,
      function(x){
        time_roll_mean(x, window = dmonths(1), time = index)
      }
)
# Unfortunately this is too slow and inefficient


# Instead we can pivot it longer and code each series as a separate group
tbl &lt;- ts_as_tibble(zoo_ts)

tbl %&gt;%
  mutate(monthly_mean = time_roll_mean(value, window = dmonths(1),
                                       time = time, g = group))


</code></pre>

<hr>
<h2 id='time_seq'>Time based version of <code>base::seq()</code></h2><span id='topic+time_seq'></span><span id='topic+time_seq_sizes'></span><span id='topic+time_seq_v'></span><span id='topic+time_seq_v2'></span>

<h3>Description</h3>

<p>Time based version of <code>base::seq()</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>time_seq(
  from,
  to,
  time_by,
  length.out = NULL,
  time_type = getOption("timeplyr.time_type", "auto"),
  week_start = getOption("lubridate.week.start", 1),
  time_floor = FALSE,
  roll_month = getOption("timeplyr.roll_month", "preday"),
  roll_dst = getOption("timeplyr.roll_dst", "boundary")
)

time_seq_sizes(
  from,
  to,
  time_by,
  time_type = getOption("timeplyr.time_type", "auto")
)

time_seq_v(
  from,
  to,
  time_by,
  time_type = getOption("timeplyr.time_type", "auto"),
  roll_month = getOption("timeplyr.roll_month", "preday"),
  roll_dst = getOption("timeplyr.roll_dst", "boundary"),
  time_floor = FALSE,
  week_start = getOption("lubridate.week.start", 1)
)

time_seq_v2(
  sizes,
  from,
  time_by,
  time_type = getOption("timeplyr.time_type", "auto"),
  time_floor = FALSE,
  week_start = getOption("lubridate.week.start", 1),
  roll_month = getOption("timeplyr.roll_month", "preday"),
  roll_dst = getOption("timeplyr.roll_dst", "boundary")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="time_seq_+3A_from">from</code></td>
<td>
<p>Start date/datetime of sequence.</p>
</td></tr>
<tr><td><code id="time_seq_+3A_to">to</code></td>
<td>
<p>End date/datetime of sequence.</p>
</td></tr>
<tr><td><code id="time_seq_+3A_time_by">time_by</code></td>
<td>
<p>Time unit increment. <br />
Must be one of the three:
</p>

<ul>
<li><p> string, specifying either the unit or the number and unit, e.g
<code>time_by = "days"</code> or <code>time_by = "2 weeks"</code>
</p>
</li>
<li><p> named list of length one, the unit being the name, and
the number the value of the list, e.g. <code>list("days" = 7)</code>.
For the vectorized time functions, you can supply multiple values,
e.g. <code>list("days" = 1:10)</code>.
</p>
</li>
<li><p> Numeric vector. If time_by is a numeric vector and x is not a date/datetime,
then arithmetic is used, e.g <code>time_by = 1</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="time_seq_+3A_length.out">length.out</code></td>
<td>
<p>Length of the sequence.</p>
</td></tr>
<tr><td><code id="time_seq_+3A_time_type">time_type</code></td>
<td>
<p>If &quot;auto&quot;, <code>periods</code> are used for
the time expansion when days, weeks,
months or years are specified, and <code>durations</code>
are used otherwise. If <code>durations</code>
are used the output is always of class <code>POSIXt</code>.</p>
</td></tr>
<tr><td><code id="time_seq_+3A_week_start">week_start</code></td>
<td>
<p>day on which week starts following ISO conventions - 1
means Monday (default), 7 means Sunday.
This is only used when <code>time_floor = TRUE</code>.</p>
</td></tr>
<tr><td><code id="time_seq_+3A_time_floor">time_floor</code></td>
<td>
<p>Should <code>from</code> be floored to
the nearest unit specified through the <code>time_by</code>
argument? This is particularly useful for
starting sequences at the beginning of a week
or month for example.</p>
</td></tr>
<tr><td><code id="time_seq_+3A_roll_month">roll_month</code></td>
<td>
<p>Control how impossible dates are handled when
month or year arithmetic is involved.
Options are &quot;preday&quot;, &quot;boundary&quot;, &quot;postday&quot;, &quot;full&quot; and &quot;NA&quot;.
See <code>?timechange::time_add</code> for more details.</p>
</td></tr>
<tr><td><code id="time_seq_+3A_roll_dst">roll_dst</code></td>
<td>
<p>See <code>?timechange::time_add</code> for the full list of details.</p>
</td></tr>
<tr><td><code id="time_seq_+3A_sizes">sizes</code></td>
<td>
<p>Time sequence sizes.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This works like <code>seq()</code>,
but using <code>timechange</code> for the period calculations and
<code>base::seq.POSIXT()</code> for the duration calculations.
In many ways it is improved over <code>seq</code> as
dates and/or datetimes can be supplied with no errors to
the start and end points.
Examples like,<br />
<code>time_seq(now(), length.out = 10, by = "0.5 days", seq_type = "dur")</code>
and <br />
<code>time_seq(today(), length.out = 10, by = "0.5 days", seq_type = "dur")</code><br />
produce more expected results compared to <br />
<code>seq(now(), length.out = 10, by = "0.5 days")</code> or <br />
<code>seq(today(), length.out = 10, by = "0.5 days")</code>.<br />
</p>
<p>For a vectorized implementation with multiple start/end times,
use <code>time_seq_v()</code>/<code>time_seq_v2()</code>
</p>
<p><code>time_seq_sizes()</code> is a convenience
function to calculate time sequence lengths, given start/end times.
</p>


<h3>Value</h3>

<p><code>time_seq</code> returns a time sequence. <br />
<code>time_seq_sizes</code> returns an integer vector of sequence sizes. <br />
<code>time_seq_v</code> returns time sequences. <br />
<code>time_seq_v2</code> also returns time sequences.
</p>


<h3>See Also</h3>

<p><a href="#topic+seq_id">seq_id</a> <a href="#topic+time_seq_id">time_seq_id</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(timeplyr)
library(lubridate)

# Dates
today &lt;- today()
now &lt;- now()

time_seq(today, today + years(1), time_by = "day")
time_seq(today, length.out = 10, time_by = "day")
time_seq(today, length.out = 10, time_by = "hour")

time_seq(today, today + years(1), time_by = list("days" = 1)) # Alternative
time_seq(today, today + years(1), time_by = "week")
time_seq(today, today + years(1), time_by = "fortnight")
time_seq(today, today + years(1), time_by = "year")
time_seq(today, today + years(10), time_by = "year")
time_seq(today, today + years(100), time_by = "decade")

# Datetimes
time_seq(now, now + years(1), time_by = "12 hours")
time_seq(now, now + years(1), time_by = "day")
time_seq(now, now + years(1), time_by = "week")
time_seq(now, now + years(1), time_by = "fortnight")
time_seq(now, now + years(1), time_by = "year")
time_seq(now, now + years(10), time_by = "year")
time_seq(now, today + years(100), time_by = "decade")

# You can seamlessly mix dates and datetimes with no errors.
time_seq(now, today + days(3), time_by = "day")
time_seq(now, today + days(3), time_by = "hour")
time_seq(today, now + days(3), time_by = "day")
time_seq(today, now + days(3), time_by = "hour")

# Choose between durations or periods

start &lt;- dmy(31012020)
# If time_type is left as is,
# periods are used for days, weeks, months and years.
time_seq(start, time_by = "month", length.out = 12,
         time_type = "period")
time_seq(start, time_by = "month", length.out = 12,
         time_type = "duration")
# Notice how strange base R version is.
seq(start, by = "month", length.out = 12)

# Roll forward or backward impossible dates

leap &lt;- dmy(29022020) # Leap day
end &lt;- dmy(01032021)
# 3 different options
time_seq(leap, to = end, time_by = "year",
         roll_month = "NA")
time_seq(leap, to = end, time_by = "year",
         roll_month = "postday")
time_seq(leap, to = end, time_by = "year",
         roll_month = getOption("timeplyr.roll_month", "preday"))

</code></pre>

<hr>
<h2 id='time_seq_id'>Generate a unique identifier for a regular time sequence with gaps</h2><span id='topic+time_seq_id'></span>

<h3>Description</h3>

<p>A unique identifier is created every time a specified amount of
time has passed, or in the case of regular sequences, when there is a gap
in time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>time_seq_id(
  x,
  time_by = NULL,
  threshold = 1,
  g = NULL,
  na_skip = TRUE,
  rolling = TRUE,
  switch_on_boundary = FALSE,
  time_type = getOption("timeplyr.time_type", "auto")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="time_seq_id_+3A_x">x</code></td>
<td>
<p>Date, datetime or numeric vector.</p>
</td></tr>
<tr><td><code id="time_seq_id_+3A_time_by">time_by</code></td>
<td>
<p>Time unit. <br />
This signifies the granularity of the time data with which to measure gaps
in the sequence.
If your data is daily for example, supply <code>time_by = "days"</code>.
If weekly, supply <code>time_by = "week"</code>.
Must be one of the three:
</p>

<ul>
<li><p> string, specifying either the unit or the number and unit, e.g
<code>time_by = "days"</code> or <code>time_by = "2 weeks"</code>
</p>
</li>
<li><p> named list of length one, the unit being the name, and
the number the value of the list, e.g. <code>list("days" = 7)</code>.
For the vectorized time functions, you can supply multiple values,
e.g. <code>list("days" = 1:10)</code>.
</p>
</li>
<li><p> Numeric vector. If time_by is a numeric vector and x is not a date/datetime,
then arithmetic is used, e.g <code>time_by = 1</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="time_seq_id_+3A_threshold">threshold</code></td>
<td>
<p>Threshold such that when the time elapsed
exceeds this, the sequence ID is incremented by 1.
For example, if <code>time_by = "days"</code> and <code>threshold = 2</code>,
then when 2 days have passed, a new ID is created.
Furthermore, <code>threshold</code> generally need not be supplied as <br />
<code>time_by = "3 days"</code> &amp; <code>threshold = 1</code> <br />
is identical to <br />
<code>time_by = "days"</code> &amp; <code>threshold = 3</code>. <br /></p>
</td></tr>
<tr><td><code id="time_seq_id_+3A_g">g</code></td>
<td>
<p>Object used for grouping x.
This can for example be a vector or data frame.
<code>g</code> is passed directly to <code>collapse::GRP()</code>.</p>
</td></tr>
<tr><td><code id="time_seq_id_+3A_na_skip">na_skip</code></td>
<td>
<p>Should <code>NA</code> values be skipped? Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="time_seq_id_+3A_rolling">rolling</code></td>
<td>
<p>When this is <code>FALSE</code>, a new ID is created every time
a cumulative amount of time has passed. Once that amount of time has passed,
a new ID is created, the clock &quot;resets&quot; and we start counting from that point.</p>
</td></tr>
<tr><td><code id="time_seq_id_+3A_switch_on_boundary">switch_on_boundary</code></td>
<td>
<p>When an exact amount of time
(specified in <code>time_by</code>) has passed, should there an increment in ID?
The default is <code>FALSE</code>. For example, if <code>time_by = "days"</code> and
<code>switch_on_boundary = FALSE</code>, <code>&gt;</code> 1 day must have passed, otherwise
<code>&gt;=</code> 1 day must have passed.</p>
</td></tr>
<tr><td><code id="time_seq_id_+3A_time_type">time_type</code></td>
<td>
<p>If &quot;auto&quot;, <code>periods</code> are used for
the time expansion when days, weeks, months or years are specified,
and <code>durations</code> are used otherwise.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>time_seq_id()</code> Assumes <code>x</code> is regular and in
ascending or descending order.
To check this condition formally, use <code>time_is_regular()</code>.
</p>


<h3>Value</h3>

<p>An integer vector of <code>length(x)</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
library(timeplyr)
library(lubridate)

# Weekly sequence, with 2 gaps in between
x &lt;- time_seq(today(), length.out = 10, time_by = "week")
x &lt;- x[-c(3, 7)]
# A new ID when more than a week has passed since the last time point
time_seq_id(x, time_by = "week")
# A new ID when &gt;= 2 weeks has passed since the last time point
time_seq_id(x, time_by = "weeks", threshold = 2, switch_on_boundary = TRUE)
# A new ID when at least 4 cumulative weeks have passed
time_seq_id(x, time_by = "4 weeks",
            switch_on_boundary = TRUE, rolling = FALSE)
# A new ID when more than 4 cumulative weeks have passed
time_seq_id(x, time_by = "4 weeks",
            switch_on_boundary = FALSE, rolling = FALSE)

</code></pre>

<hr>
<h2 id='time_summarise'>A time based extension to <code>dplyr::summarise()</code></h2><span id='topic+time_summarise'></span>

<h3>Description</h3>

<p>This works much the same as <code>dplyr::summarise()</code>, except that
you can supply an additional <code>time</code> argument to allow for
aggregating time to a higher unit.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>time_summarise(
  data,
  time = NULL,
  ...,
  time_by = NULL,
  from = NULL,
  to = NULL,
  time_type = getOption("timeplyr.time_type", "auto"),
  include_interval = FALSE,
  .by = NULL,
  time_floor = FALSE,
  week_start = getOption("lubridate.week.start", 1),
  roll_month = getOption("timeplyr.roll_month", "preday"),
  roll_dst = getOption("timeplyr.roll_dst", "boundary"),
  sort = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="time_summarise_+3A_data">data</code></td>
<td>
<p>A data frame.</p>
</td></tr>
<tr><td><code id="time_summarise_+3A_time">time</code></td>
<td>
<p>Time variable.</p>
</td></tr>
<tr><td><code id="time_summarise_+3A_...">...</code></td>
<td>
<p>Additional variables to include.</p>
</td></tr>
<tr><td><code id="time_summarise_+3A_time_by">time_by</code></td>
<td>
<p>Time unit. <br />
Must be one of the three:
</p>

<ul>
<li><p> string, specifying either the unit or the number and unit, e.g
<code>time_by = "days"</code> or <code>time_by = "2 weeks"</code>
</p>
</li>
<li><p> named list of length one, the unit being the name, and
the number the value of the list, e.g. <code>list("days" = 7)</code>.
For the vectorized time functions, you can supply multiple values,
e.g. <code>list("days" = 1:10)</code>.
</p>
</li>
<li><p> Numeric vector. If time_by is a numeric vector and x is not a date/datetime,
then arithmetic is used, e.g <code>time_by = 1</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="time_summarise_+3A_from">from</code></td>
<td>
<p>Time series start date.</p>
</td></tr>
<tr><td><code id="time_summarise_+3A_to">to</code></td>
<td>
<p>Time series end date.</p>
</td></tr>
<tr><td><code id="time_summarise_+3A_time_type">time_type</code></td>
<td>
<p>If &quot;auto&quot;, <code>periods</code> are used for
the time expansion when days, weeks, months or years are specified,
and <code>durations</code>
are used otherwise.</p>
</td></tr>
<tr><td><code id="time_summarise_+3A_include_interval">include_interval</code></td>
<td>
<p>Logical. If <code>TRUE</code> then
a column &quot;interval&quot; of the form <code style="white-space: pre;">&#8288;time_min &lt;= x &lt; time_max&#8288;</code> is added
showing the time interval in which the respective counts belong to.
The rightmost interval will always be closed.</p>
</td></tr>
<tr><td><code id="time_summarise_+3A_.by">.by</code></td>
<td>
<p>(Optional). A selection of columns to group by for this operation.
Columns are specified using tidy-select.</p>
</td></tr>
<tr><td><code id="time_summarise_+3A_time_floor">time_floor</code></td>
<td>
<p>Should <code>from</code> be floored to the nearest unit
specified through the <code>time_by</code>
argument? This is particularly useful for starting
sequences at the beginning of a week
or month for example.</p>
</td></tr>
<tr><td><code id="time_summarise_+3A_week_start">week_start</code></td>
<td>
<p>day on which week starts following ISO conventions - 1
means Monday, 7 means Sunday (default).
This is only used when <code>time_floor = TRUE</code>.</p>
</td></tr>
<tr><td><code id="time_summarise_+3A_roll_month">roll_month</code></td>
<td>
<p>Control how impossible dates are handled when
month or year arithmetic is involved.
Options are &quot;preday&quot;, &quot;boundary&quot;, &quot;postday&quot;, &quot;full&quot; and &quot;NA&quot;.
See <code>?timechange::time_add</code> for more details.</p>
</td></tr>
<tr><td><code id="time_summarise_+3A_roll_dst">roll_dst</code></td>
<td>
<p>See <code>?timechange::time_add</code> for the full list of details.</p>
</td></tr>
<tr><td><code id="time_summarise_+3A_sort">sort</code></td>
<td>
<p>Should the result be sorted? Default is <code>TRUE</code>.
If <code>FALSE</code> then original (input) order is kept.
The sorting only applies to groups and time variable.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A summarised <code>data.frame</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(timeplyr)
library(dplyr)
library(lubridate)
library(nycflights13)

# Works the same way as summarise()
# Monthly average arrival time
flights %&gt;%
  mutate(date = as_date(time_hour)) %&gt;%
  time_summarise(mean_arr_time = mean(arr_time, na.rm = TRUE),
                 time = date,
                 time_by = "month",
                 include_interval = TRUE)
# Example of monthly summary using zoo's yearmon

flights %&gt;%
  mutate(yearmon = zoo::as.yearmon(as_date(time_hour))) %&gt;%
  time_summarise(time = yearmon,
                 n = n(),
                 mean_arr_time = mean(arr_time, na.rm = TRUE),
                 include_interval = TRUE)


</code></pre>

<hr>
<h2 id='timeplyr-package'>timeplyr: Fast Tidy Tools for Date and Date-Time Manipulation</h2><span id='topic+timeplyr'></span><span id='topic+timeplyr-package'></span>

<h3>Description</h3>

<p>A framework for handling raw date &amp; datetime data <br />
using tidy best-practices from the tidyverse, the efficiency of data.table,
and the speed of collapse.
</p>
<p>You can learn more about the tidyverse,
data.table and collapse using the links below
</p>
<p><a href="https://www.tidyverse.org/learn/">tidyverse</a>
</p>
<p><a href="https://CRAN.R-project.org/package=data.table">data.table</a>
</p>
<p><a href="https://sebkrantz.github.io/collapse/articles/collapse_intro.html">collapse</a>
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Nick Christofides <a href="mailto:nick.christofides.r@gmail.com">nick.christofides.r@gmail.com</a> (<a href="https://orcid.org/0000-0002-9743-7342">ORCID</a>)
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li><p> Report bugs at <a href="https://github.com/NicChr/timeplyr/issues">https://github.com/NicChr/timeplyr/issues</a>
</p>
</li></ul>


<hr>
<h2 id='top_n_tbl'>Top N most/least frequent values</h2><span id='topic+top_n_tbl'></span><span id='topic+top_n'></span><span id='topic+bottom_n_tbl'></span><span id='topic+bottom_n'></span><span id='topic+lump_top_n'></span><span id='topic+lump_bottom_n'></span>

<h3>Description</h3>

<p>Inspired by <code>forcats::fct_lump_n</code> and by the lack of a good alternative. <br />
These are very fast and memory efficient.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>top_n_tbl(x, n = 5, na_rm = FALSE, with_ties = FALSE)

top_n(x, n = 5, na_rm = FALSE, with_ties = FALSE)

bottom_n_tbl(x, n = 5, na_rm = FALSE, with_ties = FALSE)

bottom_n(x, n = 5, na_rm = FALSE, with_ties = FALSE)

lump_top_n(
  x,
  n = 5,
  na_rm = FALSE,
  with_ties = FALSE,
  as_factor = TRUE,
  other_category = "Other"
)

lump_bottom_n(
  x,
  n = 5,
  na_rm = FALSE,
  with_ties = FALSE,
  as_factor = TRUE,
  other_category = "Other"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="top_n_tbl_+3A_x">x</code></td>
<td>
<p><a href="base.html#topic+vector">vector</a></p>
</td></tr>
<tr><td><code id="top_n_tbl_+3A_n">n</code></td>
<td>
<p><a href="base.html#topic+integer">integer</a> Number of categories to include.</p>
</td></tr>
<tr><td><code id="top_n_tbl_+3A_na_rm">na_rm</code></td>
<td>
<p><a href="base.html#topic+logical">logical</a> Should <code>NA</code> values be removed? Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="top_n_tbl_+3A_with_ties">with_ties</code></td>
<td>
<p><a href="base.html#topic+logical">logical</a> Should ties be kept? Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="top_n_tbl_+3A_as_factor">as_factor</code></td>
<td>
<p><a href="base.html#topic+logical">logical</a> Should the result be a factor? Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="top_n_tbl_+3A_other_category">other_category</code></td>
<td>
<p><a href="base.html#topic+character">character</a> Name of the other category. Default is &quot;Other&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>top_n</code> returns a vector of the most frequent values, with an
added attribute of counts named &quot;n&quot;. <br />
<code>top_n_tbl</code> returns a data frame of top n values and associated counts. <br />
<code>lump_top_n</code> returns a factor such that any values not in the top n values are
placed into a separate category &quot;Other&quot;.
</p>


<h3>Value</h3>

<p><code>top_n</code>/<code>bottom_n</code> return a vector the same class as <code>x</code>. <br />
<code>top_n_tbl</code>/<code>bottom_n_tbl</code> return a 2-col <code>data.frame</code>. <br />
<code>lump_top_n</code>/<code>lump_bottom_n</code> return a <code>factor</code> (or <code>character</code> vector).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
library(timeplyr)

### Top 3 hair colours
timeplyr::top_n(starwars$hair_color, n = 3)

starwars %&gt;%
  count(hair_col = lump_top_n(hair_color, n = 3))

top_n_tbl(starwars$hair_color, n = 3)

</code></pre>

<hr>
<h2 id='ts_as_tibble'>Turn <code>ts</code> into a <code>tibble</code></h2><span id='topic+ts_as_tibble'></span><span id='topic+ts_as_tibble.default'></span><span id='topic+ts_as_tibble.mts'></span><span id='topic+ts_as_tibble.xts'></span><span id='topic+ts_as_tibble.zoo'></span><span id='topic+ts_as_tibble.timeSeries'></span>

<h3>Description</h3>

<p>While a method already exists in the <code>tibble</code> package,
this method works differently in 2 ways:
</p>

<ul>
<li><p> The time variable associated with the time-series is also returned.
</p>
</li>
<li><p> The returned <code>tibble</code> is always in long format, even when the time-series
is multivariate.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>ts_as_tibble(x, name = "time", value = "value", group = "group")

## Default S3 method:
ts_as_tibble(x, name = "time", value = "value", group = "group")

## S3 method for class 'mts'
ts_as_tibble(x, name = "time", value = "value", group = "group")

## S3 method for class 'xts'
ts_as_tibble(x, name = "time", value = "value", group = "group")

## S3 method for class 'zoo'
ts_as_tibble(x, name = "time", value = "value", group = "group")

## S3 method for class 'timeSeries'
ts_as_tibble(x, name = "time", value = "value", group = "group")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ts_as_tibble_+3A_x">x</code></td>
<td>
<p>An object of class <code>ts</code>, <code>mts</code>, <code>zoo</code>, <code>xts</code> or <code>timeSeries</code>.</p>
</td></tr>
<tr><td><code id="ts_as_tibble_+3A_name">name</code></td>
<td>
<p>Name of the output time column.</p>
</td></tr>
<tr><td><code id="ts_as_tibble_+3A_value">value</code></td>
<td>
<p>Name of the output value column.</p>
</td></tr>
<tr><td><code id="ts_as_tibble_+3A_group">group</code></td>
<td>
<p>Name of the output group column
when there are multiple series.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A 2-column <code>tibble</code> containing the time index and values for each
time index. In the case where there are multiple series, this becomes
a 3-column <code>tibble</code> with an additional &quot;group&quot; column added.
</p>


<h3>See Also</h3>

<p><a href="#topic+time_ggplot">time_ggplot</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(timeplyr)
library(ggplot2)
library(dplyr)

# Using the examples from ?ts

# Univariate
uts &lt;- ts(cumsum(1 + round(rnorm(100), 2)),
          start = c(1954, 7), frequency = 12)
uts_tbl &lt;- ts_as_tibble(uts)

## Multivariate
mts &lt;- ts(matrix(rnorm(300), 100, 3), start = c(1961, 1), frequency = 12)
mts_tbl &lt;- ts_as_tibble(mts)

uts_tbl %&gt;%
  time_ggplot(time, value)

mts_tbl %&gt;%
  time_ggplot(time, value, group, facet = TRUE)

# zoo example
x.Date &lt;- as.Date("2003-02-01") + c(1, 3, 7, 9, 14) - 1
x &lt;- zoo::zoo(rnorm(5), x.Date)
ts_as_tibble(x)
x &lt;- zoo::zoo(matrix(1:12, 4, 3), as.Date("2003-01-01") + 0:3)
ts_as_tibble(x)

</code></pre>

<hr>
<h2 id='unit_guess'>Guess time unit and extract basic information.</h2><span id='topic+unit_guess'></span>

<h3>Description</h3>

<p>This is a simple R function to convert time units to a
common unit, with number and scale. <br />
See <code>.time_units</code> for a list of accepted
time units.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unit_guess(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unit_guess_+3A_x">x</code></td>
<td>
<p>This can be 1 of 4 options:
</p>

<ul>
<li><p> A string, e.g. &quot;7 days&quot;
</p>
</li>
<li><p> lubridate duration or period object, e.g. <code>days(1)</code> or <code>ddays(1)</code>.
</p>
</li>
<li><p> A list, e.g. list(&quot;days&quot; = 7)
</p>
</li>
<li><p> A number, e.g. 5
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of length 3, including the unit, number and scale.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(timeplyr)

# Single units
unit_guess("days")
unit_guess("hours")

# Multi-units
unit_guess("7 days")
unit_guess("0.5 hours")

# Negative units
unit_guess("-7 days")
unit_guess("-.12 days")

# Exotic units
unit_guess("fortnights")
unit_guess("decades")
.extra_time_units

# list input is accepted
unit_guess(list("months" = 12))
# With a list, a vector of numbers is accepted
unit_guess(list("months" = 1:10))
unit_guess(list("days" = -10:10 %% 7))

# Numbers also accepted
unit_guess(100)

</code></pre>

<hr>
<h2 id='year_month'>Fast methods for creating year-months and year-quarters</h2><span id='topic+year_month'></span><span id='topic+year_quarter'></span><span id='topic+YM'></span><span id='topic+YQ'></span>

<h3>Description</h3>

<p>These are experimental methods for working with year-months and
year-quarters inspired by 'zoo' and 'tsibble'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>year_month(x)

year_quarter(x)

YM(length = 0L)

YQ(length = 0L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="year_month_+3A_x">x</code></td>
<td>
<p>A <code>year_month</code>, <code>year_quarter</code>, or any other time-based object.</p>
</td></tr>
<tr><td><code id="year_month_+3A_length">length</code></td>
<td>
<p>Length of <code>year_month</code> or <code>year_quarter</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The biggest difference is that the underlying data is simply
the number of months/quarters since epoch. This makes integer
arithmetic very simple, and allows for fast sequence creation as well as
fast coercion to <code>year_month</code> and <code>year_quarter</code>
from numeric vectors.
</p>
<p>Printing method is also fast.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(timeplyr)
library(lubridate)

x &lt;- year_month(today())

# Adding 1 adds 1 month
x + 1
# Adding 12 adds 1 year
x + 12
# Sequence of yearmonths
x + 0:12

# If you unclass, do the same arithmetic, and coerce back to year_month
# The result is always the same
year_month(unclass(x) + 1)
year_month(unclass(x) + 12)

# Initialise a year_month or year_quarter to the specified length
YM(0)
YQ(0)
YM(3)
YQ(3)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
