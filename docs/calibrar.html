<!DOCTYPE html><html><head><title>Help for package calibrar</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {calibrar}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#.get_command_argument'><p>Get an specific argument from the command line</p></a></li>
<li><a href='#.read_configuration'><p>Read a configuration file.</p></a></li>
<li><a href='#ahres'><p>Adaptative Hierarchical Recombination Evolutionary Strategy (AHR-ES) for</p>
derivative-free and black-box optimization</a></li>
<li><a href='#calibrar_demo'><p>Demos for the calibrar package</p></a></li>
<li><a href='#calibrar-defunct'><p>Defunct functions in package <span class="pkg">calibrar</span>.</p></a></li>
<li><a href='#calibrar-package'><p>Automated Calibration for Complex Models</p></a></li>
<li><a href='#calibrate'><p>Sequential parameter estimation for the calibration of complex models</p></a></li>
<li><a href='#calibration_data'><p>Get observed data for the calibration of a model</p></a></li>
<li><a href='#calibration_objFn'><p>Create an objective function to be used with optimization routines</p></a></li>
<li><a href='#calibration_setup'><p>Get information to run a calibration using the <code>calibrar</code> package.</p></a></li>
<li><a href='#createObjectiveFunction-defunct'><p>Create an objective function to be used with optimization routines</p></a></li>
<li><a href='#gaussian_kernel'><p>Calculate a discretization of the 2D Gaussian Kernel</p></a></li>
<li><a href='#getCalibrationInfo-defunct'><p>Get information to run a calibration using the <code>calibrar</code> package.</p></a></li>
<li><a href='#getObservedData-defunct'><p>Get observed data for the calibration of a model</p></a></li>
<li><a href='#gradient'><p>Numerical computation of the gradient, with parallel capabilities</p></a></li>
<li><a href='#objFn'><p>Calcuted error measure between observed and simulated data</p></a></li>
<li><a href='#optim2'><p>General-purpose optimization with parallel numerical gradient computation</p></a></li>
<li><a href='#optimh'><p>General-purpose optimization using heuristic algorithms</p></a></li>
<li><a href='#sphereN'><p>Sphere function with random noise</p></a></li>
<li><a href='#spline_par'><p>Predict time-varying parameters using splines.</p></a></li>
<li><a href='#summary.calibrar.results'><p>Summary for calibration results object</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>0.9.0</td>
</tr>
<tr>
<td>Title:</td>
<td>Automated Parameter Estimation for Complex Models</td>
</tr>
<tr>
<td>Description:</td>
<td>General optimisation and specific tools for the parameter estimation (i.e. calibration) of complex models, including stochastic ones. It implements generic functions that can be used for fitting any type of models, especially those with non-differentiable objective functions, with the same syntax as base::optim. 
  It supports multiple phases estimation (sequential parameter masking), constrained optimization (bounding box restrictions) and automatic parallel computation of numerical gradients. 
  Some common maximum likelihood estimation methods and automated construction of the objective function from simulated model outputs is provided.  
  See <a href="https://roliveros-ramos.github.io/calibrar/">https://roliveros-ramos.github.io/calibrar/</a> for more details.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>BB, cmaes, DEoptim, dfoptim, GenSA, graphics, minqa, optimx,
foreach, lbfgsb3c, parallel, pso, rgenoud, soma, stats,
stringr, utils</td>
</tr>
<tr>
<td>Suggests:</td>
<td>deSolve, ibm, knitr, rmarkdown, testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://roliveros-ramos.github.io/calibrar/">https://roliveros-ramos.github.io/calibrar/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/roliveros-ramos/calibrar/issues">https://github.com/roliveros-ramos/calibrar/issues</a></td>
</tr>
<tr>
<td>ByteCompile:</td>
<td>TRUE</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-02-14 15:51:09 UTC; roliveros</td>
</tr>
<tr>
<td>Author:</td>
<td>Ricardo Oliveros-Ramos [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Ricardo Oliveros-Ramos &lt;ricardo.oliveros@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-02-14 21:30:15 UTC</td>
</tr>
</table>
<hr>
<h2 id='.get_command_argument'>Get an specific argument from the command line</h2><span id='topic+.get_command_argument'></span>

<h3>Description</h3>

<p>Get an specific argument from the command line
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.get_command_argument(
  x,
  argument,
  prefix = "--",
  default = FALSE,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".get_command_argument_+3A_x">x</code></td>
<td>
<p>The command line arguments, from <code>x = commandArgs()</code></p>
</td></tr>
<tr><td><code id=".get_command_argument_+3A_argument">argument</code></td>
<td>
<p>The name of the argument.</p>
</td></tr>
<tr><td><code id=".get_command_argument_+3A_prefix">prefix</code></td>
<td>
<p>The prefix to any argument of interest, the default is &quot;&ndash;&quot;</p>
</td></tr>
<tr><td><code id=".get_command_argument_+3A_default">default</code></td>
<td>
<p>Default value to return is argument is missing, default to FALSE.</p>
</td></tr>
<tr><td><code id=".get_command_argument_+3A_verbose">verbose</code></td>
<td>
<p>Boolean, if TRUE, shows a warning when the parameter is not found.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The value of the argument, assumed to be followed after '=' or, TRUE if nothing but the argument was found. 
If the argument is not found, FALSE is returned.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>.get_command_argument(commandArgs(), "interactive")
.get_command_argument(commandArgs(), "RStudio")
.get_command_argument(commandArgs(), "RStudio", prefix="")
.get_command_argument(commandArgs(), "vanilla")
.get_command_argument("--control.file=baz.txt", "control.file")
</code></pre>

<hr>
<h2 id='.read_configuration'>Read a configuration file.</h2><span id='topic+.read_configuration'></span>

<h3>Description</h3>

<p>File is expected to have lines of the form 'key SEP value' where key is the
name of the parameter, SEP a separator (can be '=' ',', ';') and value the value
of the parameter itself. The SEP for each line is determined and parameters values are
returned as a list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.read_configuration(
  file,
  recursive = TRUE,
  keep.names = TRUE,
  conf.key = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".read_configuration_+3A_file">file</code></td>
<td>
<p>File to read the configuration</p>
</td></tr>
<tr><td><code id=".read_configuration_+3A_recursive">recursive</code></td>
<td>
<p>Should 'conf.key' keys be read as additional configuration files? Default is TRUE.</p>
</td></tr>
<tr><td><code id=".read_configuration_+3A_keep.names">keep.names</code></td>
<td>
<p>Should names be kept as they are? By default, are converted to lower case.</p>
</td></tr>
<tr><td><code id=".read_configuration_+3A_conf.key">conf.key</code></td>
<td>
<p>String indicating the leading key to find an additional configuration file.</p>
</td></tr>
<tr><td><code id=".read_configuration_+3A_...">...</code></td>
<td>
<p>Additional arguments, not currently in use.</p>
</td></tr>
</table>

<hr>
<h2 id='ahres'>Adaptative Hierarchical Recombination Evolutionary Strategy (AHR-ES) for 
derivative-free and black-box optimization</h2><span id='topic+ahres'></span>

<h3>Description</h3>

<p>This function performs the optimization of a function using 
the Adaptative Hierarchical Recombination Evolutionary Strategy (AHR-ES, Oliveros &amp; Shin, 2015).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ahres(
  par,
  fn,
  gr = NULL,
  ...,
  lower = -Inf,
  upper = +Inf,
  active = NULL,
  control = list(),
  hessian = FALSE,
  parallel = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ahres_+3A_par">par</code></td>
<td>
<p>A numeric vector or list. The length of the par argument defines the 
number of parameters to be estimated (i.e. the dimension of the problem).</p>
</td></tr>
<tr><td><code id="ahres_+3A_fn">fn</code></td>
<td>
<p>The function to be minimized.</p>
</td></tr>
<tr><td><code id="ahres_+3A_gr">gr</code></td>
<td>
<p>A function computing the gradient of <code>fn</code>. If NULL, a numerical approximation
of the gradient is used. It can be also a character specifying the method for the computation
of the numerical gradient: 'central', 'forward' (the default), 'backward' or 'richardson'.</p>
</td></tr>
<tr><td><code id="ahres_+3A_...">...</code></td>
<td>
<p>Additional parameters to be passed to <code>fn</code>.</p>
</td></tr>
<tr><td><code id="ahres_+3A_lower">lower</code></td>
<td>
<p>Lower threshold value(s) for parameters. One value or a vector 
of the same length as par. If one value is provided, it is used for all 
parameters. <code>NA</code> means <code>-Inf</code>. By default <code>-Inf</code> is used (unconstrained).</p>
</td></tr>
<tr><td><code id="ahres_+3A_upper">upper</code></td>
<td>
<p>Upper threshold value(s) for parameters. One value or a vector 
of the same length as par. If one value is provided, it is used for all 
parameters. <code>NA</code> means <code>Inf</code>. By default <code>Inf</code> is used (unconstrained).</p>
</td></tr>
<tr><td><code id="ahres_+3A_active">active</code></td>
<td>
<p>Boolean vector of the same length as par, indicating if the 
parameter is used in the optimization (TRUE) or hold at a fixed value (FALSE).</p>
</td></tr>
<tr><td><code id="ahres_+3A_control">control</code></td>
<td>
<p>Parameter for the control of the algorithm itself, see details.</p>
</td></tr>
<tr><td><code id="ahres_+3A_hessian">hessian</code></td>
<td>
<p>Logical. Should a numerically differentiated Hessian matrix be returned?
Currently not implemented.</p>
</td></tr>
<tr><td><code id="ahres_+3A_parallel">parallel</code></td>
<td>
<p>Logical. Use parallel computation numerical of gradient?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with components:
</p>

<dl>
<dt>par</dt><dd><p>The best set of parameters found.</p>
</dd>
<dt>value</dt><dd><p>The value of fn corresponding to par.</p>
</dd>
<dt>counts</dt><dd><p>A two-element integer vector giving the number of calls to fn and gr respectively. This excludes those calls needed to compute the Hessian, if requested, and any calls to fn to compute a finite-difference approximation to the gradient.</p>
</dd>
<dt>convergence</dt><dd><p>An integer code. 0 indicates successful completion. </p>
</dd>
<dt>message</dt><dd><p>A character string giving any additional information returned by the optimizer, or NULL.</p>
</dd>
<dt>hessian</dt><dd><p>Only if argument hessian is true. A symmetric matrix giving an estimate of the Hessian at the solution found. Note that this is the Hessian of the unconstrained problem even if the box constraints are active.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Ricardo Oliveros-Ramos
</p>


<h3>See Also</h3>

<p>Other optimisers: 
<code><a href="#topic+calibrate">calibrate</a>()</code>,
<code><a href="#topic+optim2">optim2</a>()</code>,
<code><a href="#topic+optimh">optimh</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: ahres(par=rep(1, 5), fn=sphereN)
</code></pre>

<hr>
<h2 id='calibrar_demo'>Demos for the calibrar package</h2><span id='topic+calibrar_demo'></span>

<h3>Description</h3>

<p>Creates demo files able to be processed for a full calibration using
the calibrar package
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calibrar_demo(path = NULL, model = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calibrar_demo_+3A_path">path</code></td>
<td>
<p>Path to create the demo files</p>
</td></tr>
<tr><td><code id="calibrar_demo_+3A_model">model</code></td>
<td>
<p>Model to be used in the demo files, see details.</p>
</td></tr>
<tr><td><code id="calibrar_demo_+3A_...">...</code></td>
<td>
<p>Additional parameters to be used in the construction of
the demo files.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Current implemented models are:
</p>

<dl>
<dt>PoissonMixedModel</dt><dd><p>Poisson Autoregressive Mixed model for the dynamics 
of a population in different sites:
</p>
<p style="text-align: center;"><code class="reqn">log(\mu_{i, t+1}) = log(\mu_{i, t}) + \alpha + \beta X_{i, t} + \gamma_t</code>
</p>

<p>where <code class="reqn">\mu_{i, t}</code> is the size of the population in site <code class="reqn">i</code> at year <code class="reqn">t</code>, 
<code class="reqn">X_{i, t}</code> is the value of an environmental variable in site <code class="reqn">i</code> at year <code class="reqn">t</code>. 
The parameters to estimate were <code class="reqn">\alpha</code>, <code class="reqn">\beta</code>, and <code class="reqn">\gamma_t</code>, the 
random effects for each year, <code class="reqn">\gamma_t \sim N(0,\sigma^2)</code>, and the initial 
population at each site <code class="reqn">\mu_{i, 0}</code>. We assumed that the observations 
<code class="reqn">N_{i,t}</code> follow a Poisson distribution with mean <code class="reqn">\mu_{i, t}</code>.</p>
</dd>
<dt>PredatorPrey</dt><dd><p>Lotka Volterra Predator-Prey model. The model is defined 
by a system of ordinary differential equations for the abundance of prey $N$ and predator $P$:
</p>
<p style="text-align: center;"><code class="reqn">\frac{dN}{dt} = rN(1-N/K)-\alpha NP</code>
</p>

<p style="text-align: center;"><code class="reqn">\frac{dP}{dt} = -lP + \gamma\alpha NP</code>
</p>

<p>The parameters to estimate are the prey’s growth rate <code class="reqn">r</code>, the predator’s 
mortality rate <code class="reqn">l</code>, the carrying capacity of the prey <code class="reqn">K</code> and <code class="reqn">\alpha</code> 
and <code class="reqn">\gamma</code> for the predation interaction. Uses <code>deSolve</code> package 
for numerical solution of the ODE system.</p>
</dd>
<dt>SIR</dt><dd><p>Susceptible-Infected-Recovered epidemiological model. 
The model is defined by a system of ordinary differential equations for the 
number of susceptible $S$, infected $I$ and recovered $R$ individuals:
</p>
<p style="text-align: center;"><code class="reqn">\frac{dS}{dt} = -\beta S I/N</code>
</p>

<p style="text-align: center;"><code class="reqn">\frac{dI}{dt} = \beta S I/N -\gamma I</code>
</p>

<p style="text-align: center;"><code class="reqn">\frac{dR}{dt} = \gamma I</code>
</p>

<p>The parameters to estimate are the  average number of contacts per person per 
time <code class="reqn">\beta</code> and the instant probability of an infectious individual 
recovering <code class="reqn">\gamma</code>. Uses <code>deSolve</code> package for numerical solution of the ODE system.</p>
</dd>
<dt>IBMLotkaVolterra</dt><dd><p>Stochastic Individual Based Model for Lotka-Volterra model. Uses <code>ibm</code> package for the simulation.</p>
</dd>
</dl>



<h3>Value</h3>

<p>A list with the following elements:
</p>
<table>
<tr><td><code>path</code></td>
<td>
<p>Path were the files were saved</p>
</td></tr>
<tr><td><code>par</code></td>
<td>
<p>Real value of the parameters used in the demo</p>
</td></tr> 
<tr><td><code>setup</code></td>
<td>
<p>Path to the calibration setup file</p>
</td></tr> 
<tr><td><code>guess</code></td>
<td>
<p>Values to be provided as initial guess to the calibrate function</p>
</td></tr> 
<tr><td><code>lower</code></td>
<td>
<p>Values to be provided as lower bounds to the calibrate function</p>
</td></tr> 
<tr><td><code>upper</code></td>
<td>
<p>Values to be provided as upper bounds to the calibrate function</p>
</td></tr> 
<tr><td><code>phase</code></td>
<td>
<p>Values to be provided as phases to the calibrate function</p>
</td></tr> 
<tr><td><code>constants</code></td>
<td>
<p>Constants used in the demo, any other variable not listed here.</p>
</td></tr> 
<tr><td><code>value</code></td>
<td>
<p>NA, set for compatibility with summary methods.</p>
</td></tr> 
<tr><td><code>time</code></td>
<td>
<p>NA, set for compatibility with summary methods.</p>
</td></tr> 
<tr><td><code>counts</code></td>
<td>
<p>NA, set for compatibility with summary methods.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Ricardo Oliveros&ndash;Ramos
</p>


<h3>References</h3>

<p>Oliveros-Ramos and Shin (2014)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

summary(ahr)
set.seed(880820)
path = NULL # NULL to use the current directory
# create the demonstration files
demo = calibrar_demo(path=path, model="PredatorPrey", T=100) 
# get calibration information
calibration_settings = calibration_setup(file = demo$setup)
# get observed data
observed = calibration_data(setup = calibration_settings, path=demo$path)
# Defining 'run_model' function
run_model = calibrar:::.PredatorPreyModel
# real parameters
cat("Real parameters used to simulate data\n")
print(unlist(demo$par)) # parameters are in a list
# objective functions
obj  = calibration_objFn(model=run_model, setup=calibration_settings, observed=observed, T=demo$T)
obj2 = calibration_objFn(model=run_model, setup=calibration_settings, observed=observed, 
T=demo$T, aggregate=TRUE)
cat("Starting calibration...\n")
cat("Running optimization algorithms\n", "\t")
cat("Running optim AHR-ES\n")
ahr = calibrate(par=demo$guess, fn=obj, lower=demo$lower, upper=demo$upper, phases=demo$phase)
summary(ahr)

## End(Not run) 
</code></pre>

<hr>
<h2 id='calibrar-defunct'>Defunct functions in package <span class="pkg">calibrar</span>.</h2><span id='topic+calibrar-defunct'></span><span id='topic+getObservedData'></span><span id='topic+getCalibrationInfo'></span><span id='topic+createObjectiveFunction'></span>

<h3>Description</h3>

<p>The functions listed below are defunct. When possible, alternative functions with similar
functionality are also mentioned. Help pages for defunct functions are
available at <code>help("&lt;function&gt;-defunct")</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getObservedData(info, path, data.folder = "data", ...)

getCalibrationInfo(
  path,
  file = "calibrationInfo.csv",
  stringsAsFactors = FALSE,
  ...
)

createObjectiveFunction(
  runModel,
  info,
  observed,
  aggFn = .weighted.sum,
  aggregate = FALSE,
  ...
)
</code></pre>


<h3><code>getObservedData</code></h3>

<p>Deprecated in v0.3, defunct in v0.9. For <code>getObservedData</code>, use <code><a href="#topic+calibration_data">calibration_data</a></code>.
</p>


<h3><code>getCalibrationInfo</code></h3>

<p>Deprecated in v0.3, defunct in v0.9. For <code>getCalibrationInfo</code>, use <code><a href="#topic+calibration_setup">calibration_setup</a></code>.
</p>


<h3><code>createObjectiveFunction</code></h3>

<p>Deprecated in v0.3, defunct in v0.9. For <code>createObjectiveFunction</code>, use <code><a href="#topic+calibration_objFn">calibration_objFn</a></code>.
</p>

<hr>
<h2 id='calibrar-package'>Automated Calibration for Complex Models</h2><span id='topic+calibrar-package'></span><span id='topic+calibrar'></span>

<h3>Description</h3>

<p>Automated Calibration for Complex Models
</p>


<h3>Details</h3>

<p>calibrar package: Automated Calibration for Complex Models
</p>
<p><img src="../help/figures/logo_small.png" style='float: right' alt='logo' width='150' />
</p>
<p>This package allows the parameter estimation (i.e. calibration) of complex models, including stochastic ones. It implements generic functions that can be used for fitting any type of models, especially those with non-differentiable objective functions, with the same syntax as base::optim. 
It supports multiple phases estimation (sequential parameter masking), constrained optimization (bounding box restrictions) and automatic parallel computation of numerical gradients. 
Some common maximum likelihood estimation methods and automated construction of the objective function from simulated model outputs is provided.  
See &lt;https://roliveros-ramos.github.io/calibrar/&gt; for more details.
</p>


<h3>Author(s)</h3>

<p>Ricardo Oliveros-Ramos Maintainer: Ricardo Oliveros-Ramos
&lt;ricardo.oliveros@gmail.com&gt;
</p>


<h3>References</h3>

<p>calibrar: an R package for the calibration of ecological models (Oliveros-Ramos and Shin 2014)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
require(calibrar)
set.seed(880820)
path = NULL # NULL to use the current directory
# create the demonstration files
demo = calibrar_demo(model="PoissonMixedModel", L=5, T=100) 
# get calibration information
calibrationInfo = calibration_setup(file=demo$path)
# get observed data
observed = calibration_data(setup=calibrationInfo, path=demo$path)
# read forcings for the model
forcing = read.csv(file.path(demo$path, "master", "environment.csv"), row.names=1)
# Defining 'runModel' function
runModel = function(par, forcing) {
output = calibrar:::.PoissonMixedModel(par=par, forcing=forcing)
# adding gamma parameters for penalties
output = c(output, list(gammas=par$gamma)) 
return(output)
}
# real parameters
cat("Real parameters used to simulate data\n")
print(demo$par)
# objective functions
obj  = calibration_objFn(model=runModel, setup=calibrationInfo, 
                               observed=observed, forcing=forcing)
cat("Starting calibration...\n")
control = list(weights=calibrationInfo$weights, maxit=3.6e5) # control parameters
cat("Running optimization algorithms\n", "\t", date(), "\n")
cat("Running optim AHR-ES\n")
ahr = calibrate(par=demo$guess, fn=obj, lower=demo$lower, upper=demo$upper, control=control)
summary(ahr)

## End(Not run) 
</code></pre>

<hr>
<h2 id='calibrate'>Sequential parameter estimation for the calibration of complex models</h2><span id='topic+calibrate'></span><span id='topic+calibrate.default'></span>

<h3>Description</h3>

<p>This function performs the optimization of a function, possibly 
in sequential phases of increasing complexity, and it is designed for the 
calibration of a model, by minimizing the error function <code>fn</code> associated to it.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calibrate(
  par,
  fn,
  gr,
  ...,
  method,
  lower,
  upper,
  phases,
  control,
  hessian,
  replicates,
  parallel
)

## Default S3 method:
calibrate(
  par,
  fn,
  gr = NULL,
  ...,
  method = NULL,
  lower = NULL,
  upper = NULL,
  phases = NULL,
  control = list(),
  hessian = FALSE,
  replicates = 1,
  parallel = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calibrate_+3A_par">par</code></td>
<td>
<p>A numeric vector or list. The length of the par argument defines the 
number of parameters to be estimated (i.e. the dimension of the problem).</p>
</td></tr>
<tr><td><code id="calibrate_+3A_fn">fn</code></td>
<td>
<p>The function to be minimized.</p>
</td></tr>
<tr><td><code id="calibrate_+3A_gr">gr</code></td>
<td>
<p>A function computing the gradient of <code>fn</code>. If NULL, a numerical approximation
of the gradient is used. It can be also a character specifying the method for the computation
of the numerical gradient: 'central', 'forward' (the default), 'backward' or 'richardson'.</p>
</td></tr>
<tr><td><code id="calibrate_+3A_...">...</code></td>
<td>
<p>Additional parameters to be passed to <code>fn</code>.</p>
</td></tr>
<tr><td><code id="calibrate_+3A_method">method</code></td>
<td>
<p>The optimization method to be used. The default method
is the AHR-ES (Adaptative Hierarchical Recombination Evolutionary Strategy, 
Oliveros-Ramos &amp; Shin, 2016). See details for the methods available.</p>
</td></tr>
<tr><td><code id="calibrate_+3A_lower">lower</code></td>
<td>
<p>Lower threshold value(s) for parameters. One value or a vector 
of the same length as par. If one value is provided, it is used for all 
parameters. <code>NA</code> means <code>-Inf</code>. By default <code>-Inf</code> is used (unconstrained).</p>
</td></tr>
<tr><td><code id="calibrate_+3A_upper">upper</code></td>
<td>
<p>Upper threshold value(s) for parameters. One value or a vector 
of the same length as par. If one value is provided, it is used for all 
parameters. <code>NA</code> means <code>Inf</code>. By default <code>Inf</code> is used (unconstrained).</p>
</td></tr>
<tr><td><code id="calibrate_+3A_phases">phases</code></td>
<td>
<p>An optional vector of the same length as <code>par</code>, 
indicating the phase at which each parameter becomes active. If omitted, 
default value is 1 for all parameters, performing a single optimization.</p>
</td></tr>
<tr><td><code id="calibrate_+3A_control">control</code></td>
<td>
<p>Parameter for the control of the algorithm itself, see details.</p>
</td></tr>
<tr><td><code id="calibrate_+3A_hessian">hessian</code></td>
<td>
<p>Logical. Should a numerically differentiated Hessian matrix be returned?
Currently not implemented.</p>
</td></tr>
<tr><td><code id="calibrate_+3A_replicates">replicates</code></td>
<td>
<p>The number of replicates for the evaluation of <code>fn</code>.
The default value is 1. A value greater than 1 is only useful for stochastic
functions.</p>
</td></tr>
<tr><td><code id="calibrate_+3A_parallel">parallel</code></td>
<td>
<p>Logical. Use parallel computation numerical of gradient?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In the control list, <code>aggFn</code> is a function to aggregate <code>fn</code> to 
a scalar value if the returned value is a vector. Some optimization algorithm can 
exploite the additional information provided by a vectorial output from <code>fn</code>.
</p>


<h3>Author(s)</h3>

<p>Ricardo Oliveros-Ramos
</p>


<h3>See Also</h3>

<p>Other optimisers: 
<code><a href="#topic+ahres">ahres</a>()</code>,
<code><a href="#topic+optim2">optim2</a>()</code>,
<code><a href="#topic+optimh">optimh</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>calibrate(par=rep(NA, 5), fn=sphereN)
## Not run: 
calibrate(par=rep(NA, 5), fn=sphereN, replicates=3)
calibrate(par=rep(0.5, 5), fn=sphereN, replicates=3, lower=-5, upper=5)
calibrate(par=rep(0.5, 5), fn=sphereN, replicates=3, lower=-5, upper=5, phases=c(1,1,1,2,3))
calibrate(par=rep(0.5, 5), fn=sphereN, replicates=c(1,1,4), lower=-5, upper=5, phases=c(1,1,1,2,3))

## End(Not run)
</code></pre>

<hr>
<h2 id='calibration_data'>Get observed data for the calibration of a model</h2><span id='topic+calibration_data'></span>

<h3>Description</h3>

<p>Create a list with the observed data with the 
information provided by its main argument.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calibration_data(setup, path = ".", file = NULL, verbose = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calibration_data_+3A_setup">setup</code></td>
<td>
<p>A data.frame with the information about the calibration, 
normally created with the <code><a href="#topic+calibration_setup">calibration_setup</a></code> function. 
See details.</p>
</td></tr>
<tr><td><code id="calibration_data_+3A_path">path</code></td>
<td>
<p>Path to the directory to look up for the data. Paths in setup are considered relatives to this path.</p>
</td></tr>
<tr><td><code id="calibration_data_+3A_file">file</code></td>
<td>
<p>Optional file to save the created object (as an 'rds' file.)</p>
</td></tr>
<tr><td><code id="calibration_data_+3A_verbose">verbose</code></td>
<td>
<p>If TRUE, detailed messages of the process are printed.</p>
</td></tr>
<tr><td><code id="calibration_data_+3A_...">...</code></td>
<td>
<p>Additional arguments to <code>read.csv</code> function 
to read the data files.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the observed data needed for a calibration, to be used 
in combination with the <code><a href="#topic+calibration_objFn">calibration_objFn</a></code>.
</p>


<h3>Author(s)</h3>

<p>Ricardo Oliveros-Ramos
</p>


<h3>See Also</h3>

<p><code><a href="#topic+calibration_objFn">calibration_objFn</a></code>, <code><a href="#topic+calibration_setup">calibration_setup</a></code>.
</p>

<hr>
<h2 id='calibration_objFn'>Create an objective function to be used with optimization routines</h2><span id='topic+calibration_objFn'></span>

<h3>Description</h3>

<p>Create a new function, to be used as the objective function in the 
calibration, given a function to run the model within R, observed data 
and information about the comparison with data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calibration_objFn(model, setup, observed, aggFn = NULL, aggregate = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calibration_objFn_+3A_model">model</code></td>
<td>
<p>Function to run the model and produce a list of outputs.</p>
</td></tr>
<tr><td><code id="calibration_objFn_+3A_setup">setup</code></td>
<td>
<p>A data.frame with the information about the calibration, 
normally created with the <code><a href="#topic+calibration_setup">calibration_setup</a></code> function. 
See details.</p>
</td></tr>
<tr><td><code id="calibration_objFn_+3A_observed">observed</code></td>
<td>
<p>A list of the observed variables created with the 
function <code><a href="#topic+calibration_data">calibration_data</a></code></p>
</td></tr>
<tr><td><code id="calibration_objFn_+3A_aggfn">aggFn</code></td>
<td>
<p>A function to aggregate <code>fn</code> to a scalar value if the
returned value is a vector. Some optimization algorithm can explote the
additional information provided by a vectorial output from <code>fn</code></p>
</td></tr>
<tr><td><code id="calibration_objFn_+3A_aggregate">aggregate</code></td>
<td>
<p>boolean, if TRUE, a scalar value is returned using the 
<code>aggFn</code>.</p>
</td></tr>
<tr><td><code id="calibration_objFn_+3A_...">...</code></td>
<td>
<p>More arguments passed to the <code>model</code> function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A function, integrating the simulation of the model and the 
comparison with observed data.
</p>


<h3>Author(s)</h3>

<p>Ricardo Oliveros-Ramos
</p>


<h3>See Also</h3>

<p><code><a href="#topic+calibration_data">calibration_data</a></code>, <code><a href="#topic+calibration_setup">calibration_setup</a></code>.
</p>

<hr>
<h2 id='calibration_setup'>Get information to run a calibration using the <code>calibrar</code> package.</h2><span id='topic+calibration_setup'></span>

<h3>Description</h3>

<p>A wrapper for <code>read.csv</code> checking column names and data types 
for the table with the calibration information.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calibration_setup(file, control = list(), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calibration_setup_+3A_file">file</code></td>
<td>
<p>The file with the calibration information, see details.</p>
</td></tr>
<tr><td><code id="calibration_setup_+3A_control">control</code></td>
<td>
<p>Control arguments for generating the setup. See details.</p>
</td></tr>
<tr><td><code id="calibration_setup_+3A_...">...</code></td>
<td>
<p>Additional arguments to <code>read.csv</code> function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame with the information for the calibration of a 
model, to be used with the <code><a href="#topic+calibration_objFn">calibration_objFn</a></code> 
and <code><a href="#topic+calibration_data">calibration_data</a></code>.
</p>


<h3>Author(s)</h3>

<p>Ricardo Oliveros-Ramos
</p>


<h3>See Also</h3>

<p><code><a href="#topic+calibration_objFn">calibration_objFn</a></code>, <code><a href="#topic+calibration_data">calibration_data</a></code>.
</p>

<hr>
<h2 id='createObjectiveFunction-defunct'>Create an objective function to be used with optimization routines</h2><span id='topic+createObjectiveFunction-defunct'></span>

<h3>Description</h3>

<p>Create a new function, to be used as the objective function in the 
calibration, given a function to run the model within R, observed data 
and information about the comparison with data.
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="createObjectiveFunction-defunct_+3A_runmodel">runModel</code></td>
<td>
<p>Function to run the model and produce a list of outputs.</p>
</td></tr>
<tr><td><code id="createObjectiveFunction-defunct_+3A_info">info</code></td>
<td>
<p>A data.frame with the information about the calibration, 
normally created with the <code><a href="#topic+getCalibrationInfo">getCalibrationInfo</a></code> function. 
See details.</p>
</td></tr>
<tr><td><code id="createObjectiveFunction-defunct_+3A_observed">observed</code></td>
<td>
<p>A list of the observed variables created with the 
function <code><a href="#topic+getObservedData">getObservedData</a></code></p>
</td></tr>
<tr><td><code id="createObjectiveFunction-defunct_+3A_aggfn">aggFn</code></td>
<td>
<p>A function to aggregate <code>fn</code> to a scalar value if the
returned value is a vector. Some optimization algorithm can explote the
additional information provided by a vectorial output from <code>fn</code></p>
</td></tr>
<tr><td><code id="createObjectiveFunction-defunct_+3A_aggregate">aggregate</code></td>
<td>
<p>boolean, if TRUE, a scalar value is returned using the 
<code>aggFn</code>.</p>
</td></tr>
<tr><td><code id="createObjectiveFunction-defunct_+3A_...">...</code></td>
<td>
<p>More arguments passed to the <code>runModel</code> function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A function, integrating the simulation of the model and the 
comparison with observed data.
</p>


<h3>Author(s)</h3>

<p>Ricardo Oliveros-Ramos
</p>


<h3>See Also</h3>

<p><code><a href="#topic+calibrar-defunct">calibrar-defunct</a></code>
</p>

<hr>
<h2 id='gaussian_kernel'>Calculate a discretization of the 2D Gaussian Kernel</h2><span id='topic+gaussian_kernel'></span>

<h3>Description</h3>

<p>Calculate a discretization of the 2D Gaussian Kernel
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gaussian_kernel(par, lower, upper, n = 10, checkSymmetry = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gaussian_kernel_+3A_par">par</code></td>
<td>
<p>A list, including the mean and covariance matrix.</p>
</td></tr>
<tr><td><code id="gaussian_kernel_+3A_lower">lower</code></td>
<td>
<p>A vector, indicating the lower bound for the calculation.</p>
</td></tr>
<tr><td><code id="gaussian_kernel_+3A_upper">upper</code></td>
<td>
<p>A vector, indicating the upper bound for the calculation.</p>
</td></tr>
<tr><td><code id="gaussian_kernel_+3A_n">n</code></td>
<td>
<p>The number of cells for each dimension, can be one or two numbers.</p>
</td></tr>
<tr><td><code id="gaussian_kernel_+3A_checksymmetry">checkSymmetry</code></td>
<td>
<p>TRUE by default, checks if the covariance matrix is symmetric.</p>
</td></tr>
<tr><td><code id="gaussian_kernel_+3A_...">...</code></td>
<td>
<p>Additional arguments, currently not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list, with 'x', 'y' and 'z' components.
</p>

<hr>
<h2 id='getCalibrationInfo-defunct'>Get information to run a calibration using the <code>calibrar</code> package.</h2><span id='topic+getCalibrationInfo-defunct'></span>

<h3>Description</h3>

<p>A wrapper for <code>read.csv</code> checking column names and data types 
for the table with the calibration information.
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="getCalibrationInfo-defunct_+3A_path">path</code></td>
<td>
<p>The path to look for the file.</p>
</td></tr>
<tr><td><code id="getCalibrationInfo-defunct_+3A_file">file</code></td>
<td>
<p>The file with the calibration information, see details.</p>
</td></tr>
<tr><td><code id="getCalibrationInfo-defunct_+3A_stringsasfactors">stringsAsFactors</code></td>
<td>
<p>To be passed to <code>read.csv</code>.</p>
</td></tr>
<tr><td><code id="getCalibrationInfo-defunct_+3A_...">...</code></td>
<td>
<p>Additional arguments to <code>read.csv</code> function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame with the information for the calibration of a 
model, to be used with the <code><a href="#topic+createObjectiveFunction">createObjectiveFunction</a></code> 
and <code><a href="#topic+getObservedData">getObservedData</a></code>.
</p>


<h3>Author(s)</h3>

<p>Ricardo Oliveros-Ramos
</p>


<h3>See Also</h3>

<p><code><a href="#topic+calibrar-defunct">calibrar-defunct</a></code>
</p>

<hr>
<h2 id='getObservedData-defunct'>Get observed data for the calibration of a model</h2><span id='topic+getObservedData-defunct'></span>

<h3>Description</h3>

<p>Create a list with the observed data with the 
information provided by its main argument.
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="getObservedData-defunct_+3A_info">info</code></td>
<td>
<p>A data.frame with the information about the calibration, 
normally created with the <code><a href="#topic+getCalibrationInfo">getCalibrationInfo</a></code> function. 
See details.</p>
</td></tr>
<tr><td><code id="getObservedData-defunct_+3A_path">path</code></td>
<td>
<p>Path to the directory to look up for the data.</p>
</td></tr>
<tr><td><code id="getObservedData-defunct_+3A_data.folder">data.folder</code></td>
<td>
<p>folder in the path containing the data.</p>
</td></tr>
<tr><td><code id="getObservedData-defunct_+3A_...">...</code></td>
<td>
<p>Additional arguments to <code>read.csv</code> function 
to read the data files.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the observed data needed for a calibration, to be used 
in combination with the <code><a href="#topic+createObjectiveFunction">createObjectiveFunction</a></code>.
</p>


<h3>Author(s)</h3>

<p>Ricardo Oliveros-Ramos
</p>


<h3>See Also</h3>

<p><code><a href="#topic+calibrar-defunct">calibrar-defunct</a></code>
</p>

<hr>
<h2 id='gradient'>Numerical computation of the gradient, with parallel capabilities</h2><span id='topic+gradient'></span>

<h3>Description</h3>

<p>This function calculates the gradient of a function, numerically, including the possibility
of doing it in parallel.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gradient(fn, x, method, control, parallel, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gradient_+3A_fn">fn</code></td>
<td>
<p>The function to calculate the gradient.</p>
</td></tr>
<tr><td><code id="gradient_+3A_x">x</code></td>
<td>
<p>The value to compute the gradient at.</p>
</td></tr>
<tr><td><code id="gradient_+3A_method">method</code></td>
<td>
<p>The method used. Currently implemented: central, backward, forward and Richardson. See details.</p>
</td></tr>
<tr><td><code id="gradient_+3A_control">control</code></td>
<td>
<p>A list of control arguments.</p>
</td></tr>
<tr><td><code id="gradient_+3A_parallel">parallel</code></td>
<td>
<p>Boolean, should numerical derivatives be calculated in parallel?</p>
</td></tr>
<tr><td><code id="gradient_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to <code>fn</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The gradient of <code>fn</code> at <code>x</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>gradient(fn=function(x) sum(x^3), x=0)
</code></pre>

<hr>
<h2 id='objFn'>Calcuted error measure between observed and simulated data</h2><span id='topic+objFn'></span><span id='topic+fitness'></span>

<h3>Description</h3>

<p>Calcuted error measure between observed and simulated data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>objFn(obs, sim, FUN, ...)

fitness(obs, sim, FUN, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="objFn_+3A_obs">obs</code></td>
<td>
<p>observed data as expected by FUN.</p>
</td></tr>
<tr><td><code id="objFn_+3A_sim">sim</code></td>
<td>
<p>simulated data matching 'obs'</p>
</td></tr>
<tr><td><code id="objFn_+3A_fun">FUN</code></td>
<td>
<p>the error function. Current accepted values area: 'norm2', 
'lnorm2', 'lnorm3', 'multinomial', 'pois', 'penalty0', 'penalty1', 'penalty2' and 'normp'.</p>
</td></tr>
<tr><td><code id="objFn_+3A_...">...</code></td>
<td>
<p>Additional arguments to FUN</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the value of FUN(obs, sim, ...)
</p>

<hr>
<h2 id='optim2'>General-purpose optimization with parallel numerical gradient computation</h2><span id='topic+optim2'></span>

<h3>Description</h3>

<p>General-purpose optimization with parallel numerical gradient computation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>optim2(
  par,
  fn,
  gr = NULL,
  ...,
  method = c("Nelder-Mead", "BFGS", "CG", "L-BFGS-B", "SANN", "Brent", "nlm", "nlminb",
    "Rcgmin", "Rvmmin", "hjn", "spg", "LBFGSB3", "AHR-ES"),
  lower = -Inf,
  upper = +Inf,
  active = NULL,
  control = list(),
  hessian = FALSE,
  parallel = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="optim2_+3A_par">par</code></td>
<td>
<p>A numeric vector or list. The length of the par argument defines the 
number of parameters to be estimated (i.e. the dimension of the problem).</p>
</td></tr>
<tr><td><code id="optim2_+3A_fn">fn</code></td>
<td>
<p>The function to be minimized.</p>
</td></tr>
<tr><td><code id="optim2_+3A_gr">gr</code></td>
<td>
<p>A function computing the gradient of <code>fn</code>. If NULL, a numerical approximation
of the gradient is used. It can be also a character specifying the method for the computation
of the numerical gradient: 'central', 'forward' (the default), 'backward' or 'richardson'.</p>
</td></tr>
<tr><td><code id="optim2_+3A_...">...</code></td>
<td>
<p>Additional parameters to be passed to <code>fn</code>.</p>
</td></tr>
<tr><td><code id="optim2_+3A_method">method</code></td>
<td>
<p>The optimization method to be used. The default method
is the AHR-ES (Adaptative Hierarchical Recombination Evolutionary Strategy, 
Oliveros-Ramos &amp; Shin, 2016). See details for the methods available.</p>
</td></tr>
<tr><td><code id="optim2_+3A_lower">lower</code></td>
<td>
<p>Lower threshold value(s) for parameters. One value or a vector 
of the same length as par. If one value is provided, it is used for all 
parameters. <code>NA</code> means <code>-Inf</code>. By default <code>-Inf</code> is used (unconstrained).</p>
</td></tr>
<tr><td><code id="optim2_+3A_upper">upper</code></td>
<td>
<p>Upper threshold value(s) for parameters. One value or a vector 
of the same length as par. If one value is provided, it is used for all 
parameters. <code>NA</code> means <code>Inf</code>. By default <code>Inf</code> is used (unconstrained).</p>
</td></tr>
<tr><td><code id="optim2_+3A_active">active</code></td>
<td>
<p>Boolean vector of the same length as par, indicating if the 
parameter is used in the optimization (TRUE) or hold at a fixed value (FALSE).</p>
</td></tr>
<tr><td><code id="optim2_+3A_control">control</code></td>
<td>
<p>Parameter for the control of the algorithm itself, see details.</p>
</td></tr>
<tr><td><code id="optim2_+3A_hessian">hessian</code></td>
<td>
<p>Logical. Should a numerically differentiated Hessian matrix be returned?
Currently not implemented.</p>
</td></tr>
<tr><td><code id="optim2_+3A_parallel">parallel</code></td>
<td>
<p>Logical. Use parallel computation numerical of gradient?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with components:
</p>

<dl>
<dt>par</dt><dd><p>The best set of parameters found.</p>
</dd>
<dt>value</dt><dd><p>The value of fn corresponding to par.</p>
</dd>
<dt>counts</dt><dd><p>A two-element integer vector giving the number of calls to fn and gr respectively. This excludes those calls needed to compute the Hessian, if requested, and any calls to fn to compute a finite-difference approximation to the gradient.</p>
</dd>
<dt>convergence</dt><dd><p>An integer code. 0 indicates successful completion. </p>
</dd>
<dt>message</dt><dd><p>A character string giving any additional information returned by the optimizer, or NULL.</p>
</dd>
<dt>hessian</dt><dd><p>Only if argument hessian is true. A symmetric matrix giving an estimate of the Hessian at the solution found. Note that this is the Hessian of the unconstrained problem even if the box constraints are active.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Ricardo Oliveros-Ramos
</p>


<h3>See Also</h3>

<p>Other optimisers: 
<code><a href="#topic+ahres">ahres</a>()</code>,
<code><a href="#topic+calibrate">calibrate</a>()</code>,
<code><a href="#topic+optimh">optimh</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>optim2(par=rep(NA, 5), fn=sphereN)
</code></pre>

<hr>
<h2 id='optimh'>General-purpose optimization using heuristic algorithms</h2><span id='topic+optimh'></span>

<h3>Description</h3>

<p>General-purpose optimization using heuristic algorithms
</p>


<h3>Usage</h3>

<pre><code class='language-R'>optimh(
  par,
  fn,
  gr = NULL,
  ...,
  method = c("AHR-ES", "Nelder-Mead", "SANN", "hjn", "bobyqa", "CMA-ES", "genSA", "DE",
    "soma", "genoud", "PSO", "hybridPSO", "mads", "hjk", "hjkb", "nmk", "nmkb"),
  lower = -Inf,
  upper = +Inf,
  active = NULL,
  control = list(),
  hessian = FALSE,
  parallel = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="optimh_+3A_par">par</code></td>
<td>
<p>A numeric vector or list. The length of the par argument defines the 
number of parameters to be estimated (i.e. the dimension of the problem).</p>
</td></tr>
<tr><td><code id="optimh_+3A_fn">fn</code></td>
<td>
<p>The function to be minimized.</p>
</td></tr>
<tr><td><code id="optimh_+3A_gr">gr</code></td>
<td>
<p>Function to compute the gradient of <code>fn</code>. Ignored by most methods, 
added for consistency with other optimization functions.</p>
</td></tr>
<tr><td><code id="optimh_+3A_...">...</code></td>
<td>
<p>Additional parameters to be passed to <code>fn</code>.</p>
</td></tr>
<tr><td><code id="optimh_+3A_method">method</code></td>
<td>
<p>The optimization method to be used. The default method
is the AHR-ES (Adaptative Hierarchical Recombination Evolutionary Strategy, 
Oliveros-Ramos &amp; Shin, 2016). See details for the methods available.</p>
</td></tr>
<tr><td><code id="optimh_+3A_lower">lower</code></td>
<td>
<p>Lower threshold value(s) for parameters. One value or a vector 
of the same length as par. If one value is provided, it is used for all 
parameters. <code>NA</code> means <code>-Inf</code>. By default <code>-Inf</code> is used (unconstrained).</p>
</td></tr>
<tr><td><code id="optimh_+3A_upper">upper</code></td>
<td>
<p>Upper threshold value(s) for parameters. One value or a vector 
of the same length as par. If one value is provided, it is used for all 
parameters. <code>NA</code> means <code>Inf</code>. By default <code>Inf</code> is used (unconstrained).</p>
</td></tr>
<tr><td><code id="optimh_+3A_active">active</code></td>
<td>
<p>Boolean vector of the same length as par, indicating if the 
parameter is used in the optimization (TRUE) or hold at a fixed value (FALSE).</p>
</td></tr>
<tr><td><code id="optimh_+3A_control">control</code></td>
<td>
<p>Parameter for the control of the algorithm itself, see details.</p>
</td></tr>
<tr><td><code id="optimh_+3A_hessian">hessian</code></td>
<td>
<p>Logical. Should a numerically differentiated Hessian matrix be returned?
Currently not implemented.</p>
</td></tr>
<tr><td><code id="optimh_+3A_parallel">parallel</code></td>
<td>
<p>Logical. Use parallel computation numerical of gradient?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with components:
</p>

<dl>
<dt>par</dt><dd><p>The best set of parameters found.</p>
</dd>
<dt>value</dt><dd><p>The value of fn corresponding to par.</p>
</dd>
<dt>counts</dt><dd><p>A two-element integer vector giving the number of calls to fn and gr respectively. This excludes those calls needed to compute the Hessian, if requested, and any calls to fn to compute a finite-difference approximation to the gradient.</p>
</dd>
<dt>convergence</dt><dd><p>An integer code. 0 indicates successful completion. </p>
</dd>
<dt>message</dt><dd><p>A character string giving any additional information returned by the optimizer, or NULL.</p>
</dd>
<dt>hessian</dt><dd><p>Only if argument hessian is true. A symmetric matrix giving an estimate of the Hessian at the solution found. Note that this is the Hessian of the unconstrained problem even if the box constraints are active.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Ricardo Oliveros-Ramos
</p>


<h3>See Also</h3>

<p>Other optimisers: 
<code><a href="#topic+ahres">ahres</a>()</code>,
<code><a href="#topic+calibrate">calibrate</a>()</code>,
<code><a href="#topic+optim2">optim2</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>optim2(par=rep(NA, 5), fn=sphereN)
</code></pre>

<hr>
<h2 id='sphereN'>Sphere function with random noise</h2><span id='topic+sphereN'></span>

<h3>Description</h3>

<p>This function calculates the Euclidian distance from a point to the origin
after a random displacement of its position.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sphereN(x, sd = 0.1, aggregate = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sphereN_+3A_x">x</code></td>
<td>
<p>The coordinates of the point</p>
</td></tr>
<tr><td><code id="sphereN_+3A_sd">sd</code></td>
<td>
<p>The standard deviation of the noise
to be added to the position of <code>x</code>, a normal distribution with mean
zero is used.</p>
</td></tr>
<tr><td><code id="sphereN_+3A_aggregate">aggregate</code></td>
<td>
<p>If <code>aggregate</code> is <code>TRUE</code> the distance is returned, 
otherwise the size of the projection of the distance among each axis.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The distance from the point <code>x</code> to the origin after a random
displacement.
</p>


<h3>Author(s)</h3>

<p>Ricardo Oliveros&ndash;Ramos
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sphereN(rep(0, 10))
</code></pre>

<hr>
<h2 id='spline_par'>Predict time-varying parameters using splines.</h2><span id='topic+spline_par'></span>

<h3>Description</h3>

<p>Predict time-varying parameters using splines.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spline_par(par, n, knots = NULL, periodic = FALSE, period = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spline_par_+3A_par">par</code></td>
<td>
<p>Values at knots</p>
</td></tr>
<tr><td><code id="spline_par_+3A_n">n</code></td>
<td>
<p>Number of points. Time (independent variable) is assumed to be between 0 and n with length(par) equidistant points (including 0 and n).</p>
</td></tr>
<tr><td><code id="spline_par_+3A_knots">knots</code></td>
<td>
<p>Position of knots. Default, is length(x) equidistant points between 0 and 1. Always are re-scaled to 0 to 1.</p>
</td></tr>
<tr><td><code id="spline_par_+3A_periodic">periodic</code></td>
<td>
<p>boolean, is the spline periodic?</p>
</td></tr>
<tr><td><code id="spline_par_+3A_period">period</code></td>
<td>
<p>If periodic is TRUE, it specify the time period.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the interpolates values as 'x' and 'time'.
</p>

<hr>
<h2 id='summary.calibrar.results'>Summary for calibration results object</h2><span id='topic+summary.calibrar.results'></span>

<h3>Description</h3>

<p>Summary for calibration results object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'calibrar.results'
summary(object, ..., show_par = NULL, par.only = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.calibrar.results_+3A_object">object</code></td>
<td>
<p>Object of class calibrar.results</p>
</td></tr>
<tr><td><code id="summary.calibrar.results_+3A_...">...</code></td>
<td>
<p>More objects of class calibrar.results as needed for comparisons.</p>
</td></tr>
<tr><td><code id="summary.calibrar.results_+3A_show_par">show_par</code></td>
<td>
<p>Vector of names of positions of the parameters to show in the summary.</p>
</td></tr>
<tr><td><code id="summary.calibrar.results_+3A_par.only">par.only</code></td>
<td>
<p>Show only parameters in the summary, used when more than one optimization results are summarized.</p>
</td></tr>
</table>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
