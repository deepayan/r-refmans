<!DOCTYPE html><html lang="en"><head><title>Help for package SiFINeT</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {SiFINeT}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#assign_shared_feature'><p>assign_shared_feature</p></a></li>
<li><a href='#cal_coexp'><p>cal_coexp</p>
This function calculates the coexpression patterns between genes
and returns the coexpression matrix.</a></li>
<li><a href='#cal_coexp_sp'><p>cal_coexp_sp</p>
This function calculates the coexpression patterns between genes
in sparse matrix and returns the coexpression matrix.</a></li>
<li><a href='#cal_conn'><p>cal_conn</p>
This function calculates the first 3 order connectivities for each gene
and returns the list of vectors of connectivities.</a></li>
<li><a href='#cal_connectivity'><p>cal_connectivity</p></a></li>
<li><a href='#create_network'><p>create_network</p></a></li>
<li><a href='#create_SiFINeT_object'><p>create_SiFINeT_object</p></a></li>
<li><a href='#enrich_feature_set'><p>enrich_feature_set</p></a></li>
<li><a href='#EstNull'><p>EstNull</p>
This function is a Rcpp version of Wenguang Sun and Tony T. Cai's
EstNull.func R function, estimating null distribution from data.
Sun, W., &amp; Cai, T. T. (2007). Oracle and Adaptive Compound Decision
Rules for False Discovery Rate Control.
Journal of the American Statistical Association,
102(479), 901–912.</a></li>
<li><a href='#extract_subnetwork'><p>extract_subnetwork</p></a></li>
<li><a href='#feature_coexp'><p>feature_coexp</p></a></li>
<li><a href='#filter_lowexp'><p>filter_lowexp</p></a></li>
<li><a href='#find_unique_feature'><p>find_unique_feature</p></a></li>
<li><a href='#geneset_topology'><p>geneset_topology</p></a></li>
<li><a href='#norm_FDR_SQAUC'><p>norm_FDR_SQAUC</p>
The function controls the false discovery rate (FDR) of coexpression patterns
using SQAUC method
Jichun Xie and Ruosha Li. &quot;False discovery rate control for high dimensional
networks of quantile associations conditioning on covariates&quot;.
In: J R Stat Soc Series B Stat Methodol (2018). doi: 10.1111/rssb.12288.</a></li>
<li><a href='#quantile_thres'><p>quantile_thres</p></a></li>
<li><a href='#SiFINeT-class'><p>The SiFINeT Class</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Single Cell Feature Identification with Network Topology</td>
</tr>
<tr>
<td>Version:</td>
<td>1.13</td>
</tr>
<tr>
<td>Date:</td>
<td>2025-01-01</td>
</tr>
<tr>
<td>Author:</td>
<td>Qi Gao [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Qi Gao &lt;gqi@med.umich.edu&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Cluster-independent method based on topology structure of gene co-expression network for identifying feature gene sets, extracting cellular subpopulations, and elucidating intrinsic relationships among these subpopulations. Without prior cell clustering, SifiNet circumvents potential inaccuracies in clustering that may influence subsequent analyses. This method is introduced in Qi Gao, Zhicheng Ji, Liuyang Wang, Kouros Owzar, Qi-Jing Li, Cliburn Chan, Jichun Xie "SifiNet: a robust and accurate method to identify feature gene sets and annotate cells" (2024) &lt;<a href="https://doi.org/10.1093%2Fnar%2Fgkae307">doi:10.1093/nar/gkae307</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>BuildVignettes:</td>
<td>yes</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.6.0), methods, utils, stats</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 1.0.9), quantreg (&ge; 5.94), igraph (&ge; 1.3.5), Matrix
(&ge; 1.5-1), ggraph (&ge; 2.0.6), ggplot2 (&ge; 3.3.6),</td>
</tr>
<tr>
<td>Suggests:</td>
<td>rmarkdown (&ge; 2.20), knitr (&ge; 1.42)</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-01-15 22:31:46 UTC; gqi</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-01-16 15:10:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='assign_shared_feature'>assign_shared_feature</h2><span id='topic+assign_shared_feature'></span>

<h3>Description</h3>

<p>The function assigns non-unique candidate feature genes as shared feature genes into unique feature gene sets
</p>


<h3>Usage</h3>

<pre><code class='language-R'>assign_shared_feature(so, min_edge_prop = 0.4)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="assign_shared_feature_+3A_so">so</code></td>
<td>
<p>a SiFINeT object</p>
</td></tr>
<tr><td><code id="assign_shared_feature_+3A_min_edge_prop">min_edge_prop</code></td>
<td>
<p>minimum proportion of edges between a gene and a unique feature gene set for the new gene to be assigned to the set</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Candidate feature genes that are not chosen as unique feature genes would be reconsidered as shared feature genes.
A non-unique candidate feature gene would be assigned to a unique feature gene group if it is connected to more than min_edge_prop of the unique genes in the group.
</p>


<h3>Value</h3>

<p>SiFINeT object with shared feature genes in featureset updated.
</p>

<hr>
<h2 id='cal_coexp'>cal_coexp
This function calculates the coexpression patterns between genes
and returns the coexpression matrix.</h2><span id='topic+cal_coexp'></span>

<h3>Description</h3>

<p>cal_coexp
This function calculates the coexpression patterns between genes
and returns the coexpression matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cal_coexp(X)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cal_coexp_+3A_x">X</code></td>
<td>
<p>Input binarized cell (row) by gene (column) matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Coexpression matrix
</p>


<h3>Author(s)</h3>

<p>Qi Gao
</p>

<hr>
<h2 id='cal_coexp_sp'>cal_coexp_sp
This function calculates the coexpression patterns between genes
in sparse matrix and returns the coexpression matrix.</h2><span id='topic+cal_coexp_sp'></span>

<h3>Description</h3>

<p>cal_coexp_sp
This function calculates the coexpression patterns between genes
in sparse matrix and returns the coexpression matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cal_coexp_sp(X)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cal_coexp_sp_+3A_x">X</code></td>
<td>
<p>Input binarized cell (row) by gene (column) sparse matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Coexpression matrix
</p>


<h3>Author(s)</h3>

<p>Qi Gao
</p>

<hr>
<h2 id='cal_conn'>cal_conn
This function calculates the first 3 order connectivities for each gene
and returns the list of vectors of connectivities.</h2><span id='topic+cal_conn'></span>

<h3>Description</h3>

<p>cal_conn
This function calculates the first 3 order connectivities for each gene
and returns the list of vectors of connectivities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cal_conn(data, thres = 3, m = 10L, abso = 1L, niter = 100L)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cal_conn_+3A_data">data</code></td>
<td>
<p>Input gene by gene coexpression matrix</p>
</td></tr>
<tr><td><code id="cal_conn_+3A_thres">thres</code></td>
<td>
<p>Gene pairs with coexpression exceed thres would be assigned an
edge between them in the coexpression network</p>
</td></tr>
<tr><td><code id="cal_conn_+3A_m">m</code></td>
<td>
<p>Sample size used for the calculation of 3rd order connectivities</p>
</td></tr>
<tr><td><code id="cal_conn_+3A_abso">abso</code></td>
<td>
<p>Whether to calculate connectivities in absolute network (TRUE)
or positive network (FALSE)</p>
</td></tr>
<tr><td><code id="cal_conn_+3A_niter">niter</code></td>
<td>
<p>Number of sample used for the calculation of 3rd order
connectivities</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List of connectivities C1, C2, and C3 ' @export
</p>


<h3>Author(s)</h3>

<p>Qi Gao
</p>

<hr>
<h2 id='cal_connectivity'>cal_connectivity</h2><span id='topic+cal_connectivity'></span>

<h3>Description</h3>

<p>The function calculates the 1st, 2nd and 3rd order connectivities for all genes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cal_connectivity(so, m = 10, niter = 100)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cal_connectivity_+3A_so">so</code></td>
<td>
<p>a SiFINeT object</p>
</td></tr>
<tr><td><code id="cal_connectivity_+3A_m">m</code></td>
<td>
<p>number of neighbors sampled each time for the calculation of 3rd order connectivity</p>
</td></tr>
<tr><td><code id="cal_connectivity_+3A_niter">niter</code></td>
<td>
<p>number of samples created for the calculation of 3rd order connectivity</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For gene i, First order connectivity is defined as the number of edges connected to gene i (degree of the gene node i in the network).
Second order connectivity is defined as the proportion of edges between the neighbors of gene i, calculated as number of observed edges between the neighbors of gene i divided by the number of possible edges between the neighbors.
Third order connectivity is defined as a weighted proportion of edges between neighbors and neighbors of neighbors of gene i. Third order connectivity is calculated as the mean of edge proportions across weighted samples.
Each gene is weighted by the number of edges it has with the neighbors of gene i. Then SiFINeT repeatedly samples m genes for niter times. For each sample, the edge proportion (number of observed edges / number of possible edges) is calculated. And the mean edge proportion across the sample is the 3rd order connectivity for gene i.
</p>


<h3>Value</h3>

<p>SiFINeT object with conn (absolute network connectivities) updated.
</p>

<hr>
<h2 id='create_network'>create_network</h2><span id='topic+create_network'></span>

<h3>Description</h3>

<p>The function estimates the null distribution of coexpression patterns
and generates coexpression network
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_network(so, alpha = 0.05, manual = FALSE, least_edge_prop = 0.01)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="create_network_+3A_so">so</code></td>
<td>
<p>a SiFINeT object</p>
</td></tr>
<tr><td><code id="create_network_+3A_alpha">alpha</code></td>
<td>
<p>the Type I error rate used for FDR control procedure</p>
</td></tr>
<tr><td><code id="create_network_+3A_manual">manual</code></td>
<td>
<p>whether to manually set threshold for edge assignment</p>
</td></tr>
<tr><td><code id="create_network_+3A_least_edge_prop">least_edge_prop</code></td>
<td>
<p>the minimum proportion of edges. Only used when manual = TRUE</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Theoretically the distribution of coexpression patterns would converge to standard Gaussian if either one of the gene pair is not feature gene.
However in genomics analysis, empirical null could be much more variable than theoretical null.
SiFINeT uses estimated null mean and standard deviation to find the threshold for network edges. An edge is assigned to a pair of gene if the absolute value of coexpression pattern between the 2 genes is greater than the threshold
Assuming the distribution to be Gaussian, with the estimated null mean and standard deviation, SiFINeT uses SQUAC to control the false discovery rate (FDR) for coexpression patterns.
In case the signal is not strong enough and the coexpression network is too sparse, SiFINeT also accept user-defined lower bound for the least proportion of edges.
Usually a coexpression network with edge proportion between 0.5% - 10% would have better performance for the detection of feature gene sets.
</p>


<h3>Value</h3>

<p>SiFINeT object with est_ms (estimated mean and sd) and thres (network edge threshold) updated.
</p>


<h3>References</h3>

<p>Jiashun Jin and Tony T. Cai. “Estimating the Null and the Proportion of Non-Null Effects in Large-Scale Multiple Comparisons”. In: Journal of the American Statistical Association 102 (478 2004), pp. 495–506. doi: 10.1198/016214507000000167.
</p>
<p>Jichun Xie and Ruosha Li. “False discovery rate control for high dimensional networks of quantile associations conditioning on covariates”. In: J R Stat Soc Series B Stat Methodol (2018). doi: 10.1111/rssb.12288.
</p>

<hr>
<h2 id='create_SiFINeT_object'>create_SiFINeT_object</h2><span id='topic+create_SiFINeT_object'></span>

<h3>Description</h3>

<p>The function classifies count data based on thresholds
defined by quantile regression
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_SiFINeT_object(
  counts,
  gene.name = NULL,
  meta.data = NULL,
  data.name = NULL,
  sparse = FALSE,
  rowfeature = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="create_SiFINeT_object_+3A_counts">counts</code></td>
<td>
<p>count matrix</p>
</td></tr>
<tr><td><code id="create_SiFINeT_object_+3A_gene.name">gene.name</code></td>
<td>
<p>name of the features</p>
</td></tr>
<tr><td><code id="create_SiFINeT_object_+3A_meta.data">meta.data</code></td>
<td>
<p>data.frame of meta data</p>
</td></tr>
<tr><td><code id="create_SiFINeT_object_+3A_data.name">data.name</code></td>
<td>
<p>name of dataset</p>
</td></tr>
<tr><td><code id="create_SiFINeT_object_+3A_sparse">sparse</code></td>
<td>
<p>whether the count matrix should be analyzed as sparse matrix</p>
</td></tr>
<tr><td><code id="create_SiFINeT_object_+3A_rowfeature">rowfeature</code></td>
<td>
<p>whether the count matrix is feature (row) by cell (column)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a SiFINeT object
</p>

<hr>
<h2 id='enrich_feature_set'>enrich_feature_set</h2><span id='topic+enrich_feature_set'></span>

<h3>Description</h3>

<p>The function chooses genes that are not found to be feature genes as enriched feature genes and assigns them into unique+shared feature gene sets
</p>


<h3>Usage</h3>

<pre><code class='language-R'>enrich_feature_set(so, min_edge_prop = 0.9)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="enrich_feature_set_+3A_so">so</code></td>
<td>
<p>a SiFINeT object</p>
</td></tr>
<tr><td><code id="enrich_feature_set_+3A_min_edge_prop">min_edge_prop</code></td>
<td>
<p>minimum proportion of edges between a gene and a unique+shared feature gene set for the new feature to be assigned to the set</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Genes that are not selected as feature genes would be added in the enriched section of the feature gene set if they are connected with
more than min_edge_prop of the unique and shared feature genes in each of the feature gene group.
</p>


<h3>Value</h3>

<p>SiFINeT object with enriched feature genes in geneset updated.
</p>

<hr>
<h2 id='EstNull'>EstNull
This function is a Rcpp version of Wenguang Sun and Tony T. Cai's
EstNull.func R function, estimating null distribution from data.
Sun, W., &amp; Cai, T. T. (2007). Oracle and Adaptive Compound Decision
Rules for False Discovery Rate Control.
Journal of the American Statistical Association,
102(479), 901–912.</h2><span id='topic+EstNull'></span>

<h3>Description</h3>

<p>EstNull
This function is a Rcpp version of Wenguang Sun and Tony T. Cai's
EstNull.func R function, estimating null distribution from data.
Sun, W., &amp; Cai, T. T. (2007). Oracle and Adaptive Compound Decision
Rules for False Discovery Rate Control.
Journal of the American Statistical Association,
102(479), 901–912.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EstNull(x, gamma = 0.1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="EstNull_+3A_x">x</code></td>
<td>
<p>Input vector of all coexpression values</p>
</td></tr>
<tr><td><code id="EstNull_+3A_gamma">gamma</code></td>
<td>
<p>Parameter setting the stopping threshold</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List of mean and std
</p>


<h3>Author(s)</h3>

<p>Qi Gao
</p>

<hr>
<h2 id='extract_subnetwork'>extract_subnetwork</h2><span id='topic+extract_subnetwork'></span>

<h3>Description</h3>

<p>The function extract a subnetwork from the co-expression network
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract_subnetwork(
  so,
  target_gene_name = NULL,
  target_gene_id = NULL,
  positive = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="extract_subnetwork_+3A_so">so</code></td>
<td>
<p>a SiFINeT object</p>
</td></tr>
<tr><td><code id="extract_subnetwork_+3A_target_gene_name">target_gene_name</code></td>
<td>
<p>the names of the target genes in the output network</p>
</td></tr>
<tr><td><code id="extract_subnetwork_+3A_target_gene_id">target_gene_id</code></td>
<td>
<p>the indices of the target genes in the output network, not used when target_gene_name is not Null</p>
</td></tr>
<tr><td><code id="extract_subnetwork_+3A_positive">positive</code></td>
<td>
<p>whether only positive (default) co-expressions or all co-expressions are considered in assigning edges</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an adjacency matrix of the output subnetwork
</p>

<hr>
<h2 id='feature_coexp'>feature_coexp</h2><span id='topic+feature_coexp'></span>

<h3>Description</h3>

<p>The function calculates coexpression patterns between genes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>feature_coexp(so)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="feature_coexp_+3A_so">so</code></td>
<td>
<p>a SiFINeT object</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The coexpression pattern of a pair of genes is a normalized co-occurrence of high (or equivalently low) expression level of the 2 genes in the classified count matrix.
The normalization is based on the estimated quantiles of the low-high separation instead of the quantiles used for quantile regressions.
Theoretically, the distribution of coexpression patterns should asymptotically follow standard Gaussian distribution if at least one of the 2 genes is not differentially expressed feature gene.
</p>


<h3>Value</h3>

<p>SiFINeT object with coexp (gene coexpression matrix) updated.
</p>

<hr>
<h2 id='filter_lowexp'>filter_lowexp</h2><span id='topic+filter_lowexp'></span>

<h3>Description</h3>

<p>The function filters out genes with low expression rate and
high positive coexpression with genes of same expression level
</p>


<h3>Usage</h3>

<pre><code class='language-R'>filter_lowexp(so, t1 = 10, t2 = 0.9, t3 = 0.9)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="filter_lowexp_+3A_so">so</code></td>
<td>
<p>a SiFINeT object</p>
</td></tr>
<tr><td><code id="filter_lowexp_+3A_t1">t1</code></td>
<td>
<p>threshold for number of total edges connecting the feature node. Lower t1 leads to stricter filtering.</p>
</td></tr>
<tr><td><code id="filter_lowexp_+3A_t2">t2</code></td>
<td>
<p>threshold for the proportion of positive edges. Lower t2 leads to stricter filtering.</p>
</td></tr>
<tr><td><code id="filter_lowexp_+3A_t3">t3</code></td>
<td>
<p>threshold for the proportion of edges with features of same expression level. Lower t3 leads to stricter filtering.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When using only mean expression level as independent variable in quantile regression,
it is observed that genes with low expression level tend to have large positive <code class="reqn">S_{ij}</code> with genes that have same median expression level.
To reduce the coexpression noise caused by low expression level, it is preferred to filter out genes which have large amount and high proportion of positive coexpressions with genes sharing same median expression level.
</p>


<h3>Value</h3>

<p>SiFINeT object with kset (kept index set) updated.
</p>

<hr>
<h2 id='find_unique_feature'>find_unique_feature</h2><span id='topic+find_unique_feature'></span>

<h3>Description</h3>

<p>The function finds the clustered unique feature genes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find_unique_feature(
  so,
  t1 = 5,
  t2 = 0.4,
  t3 = 0.3,
  t1p = 5,
  t2p = 0.7,
  t3p = 0.5,
  resolution = 1,
  min_set_size = 5
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="find_unique_feature_+3A_so">so</code></td>
<td>
<p>a SiFINeT object</p>
</td></tr>
<tr><td><code id="find_unique_feature_+3A_t1">t1</code></td>
<td>
<p>feature gene selection parameter, lower threshold for 1st order connectivity in absolute network</p>
</td></tr>
<tr><td><code id="find_unique_feature_+3A_t2">t2</code></td>
<td>
<p>feature gene selection parameter, lower threshold for 2nd order connectivity in absolute network</p>
</td></tr>
<tr><td><code id="find_unique_feature_+3A_t3">t3</code></td>
<td>
<p>feature gene selection parameter, lower threshold for 3rd order connectivity in absolute network</p>
</td></tr>
<tr><td><code id="find_unique_feature_+3A_t1p">t1p</code></td>
<td>
<p>unique feature gene selection parameter, lower threshold for 1st order connectivity in positive sub-network</p>
</td></tr>
<tr><td><code id="find_unique_feature_+3A_t2p">t2p</code></td>
<td>
<p>unique feature gene selection parameter, lower threshold for 2nd order connectivity in positive sub-network</p>
</td></tr>
<tr><td><code id="find_unique_feature_+3A_t3p">t3p</code></td>
<td>
<p>unique feature gene selection parameter, lower threshold for 3rd order connectivity in positive sub-network</p>
</td></tr>
<tr><td><code id="find_unique_feature_+3A_resolution">resolution</code></td>
<td>
<p>resolution for louvain clustering of unique feature genes</p>
</td></tr>
<tr><td><code id="find_unique_feature_+3A_min_set_size">min_set_size</code></td>
<td>
<p>minimum size for a unique feature gene cluster to be a separate unique feature gene set</p>
</td></tr>
</table>


<h3>Details</h3>

<p>SiFINeT first find genes with high 1st (&gt;= t1), 2nd (&gt;= t2) and 3rd (&gt;= t3) order connectivities in absolute network (conn) to be candidate feature genes.
Then a positive sub-network is created where only candidate feature gene nodes (fg_id) and edges with positive coexpression patterns (coexp &gt;= thres) are included.
Feature genes genes with high 1st (&gt;= t1p), 2nd (&gt;= t2p) and at least moderate 3rd (&gt;= t3p) order connectivities in positive sub-network (conn2) are chosen to be candidate unique feature genes.
Note that when the network is not too sparse, t3p should usually be smaller than t2p for the detection of unique feature genes in transition cell types.
The candidate unique feature genes are then separated into groups by louvain clustering (with resolution defined by the resolution parameter),
and among them large groups (number of genes greater than min_set_size) are chosen to be unique feature gene sets that represent different cell types.
</p>


<h3>Value</h3>

<p>SiFINeT object with fg_id (candidate feature gene index), uni_fg_id (candidate unique feature gene index), conn2 (connectivities in positive sub-network),
uni_cluster (cluster of candidate unique feature genes), selected_cluster (selected unique feature gene clusters), and unique feature genes in featureset updated.
</p>

<hr>
<h2 id='geneset_topology'>geneset_topology</h2><span id='topic+geneset_topology'></span>

<h3>Description</h3>

<p>The function plots the topology network of the feature gene sets found by SiFINeT.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geneset_topology(
  so,
  weightthres = 0.3,
  edge_method = 2,
  node_color = "black",
  shiftsize = 0.05,
  boundsize = 0.3,
  prefix = "",
  set_name = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="geneset_topology_+3A_so">so</code></td>
<td>
<p>a SiFINeT object</p>
</td></tr>
<tr><td><code id="geneset_topology_+3A_weightthres">weightthres</code></td>
<td>
<p>edges between nodes (feature gene sets) with weight greater than weightthres would be shown in the plot</p>
</td></tr>
<tr><td><code id="geneset_topology_+3A_edge_method">edge_method</code></td>
<td>
<p>SiFINeT provides 2 methods of calculating edge weight.
The number of shared feature genes between feature gene sets would be used when edge_method = 1;
while the edge proportion between feature gene sets would be applied if edge_method = 2.</p>
</td></tr>
<tr><td><code id="geneset_topology_+3A_node_color">node_color</code></td>
<td>
<p>color of nodes. Should have either length 1 or same length as the number of feature gene sets.</p>
</td></tr>
<tr><td><code id="geneset_topology_+3A_shiftsize">shiftsize</code></td>
<td>
<p>set the distance between center of label and the corresponding feature gene sets node.</p>
</td></tr>
<tr><td><code id="geneset_topology_+3A_boundsize">boundsize</code></td>
<td>
<p>set the size of the boundary region.</p>
</td></tr>
<tr><td><code id="geneset_topology_+3A_prefix">prefix</code></td>
<td>
<p>the prefix of the labels</p>
</td></tr>
<tr><td><code id="geneset_topology_+3A_set_name">set_name</code></td>
<td>
<p>name of the gene sets</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function visualizes the output feature gene sets of SiFINeT in the form of network.
Number of shared feature genes or proportion of edges between feature gene sets could be used to weight the edges.
The layout of the nodes is created by create_layout function in ggraph package.
</p>


<h3>Value</h3>

<p>A ggraph (ggplot) object
</p>


<h3>References</h3>

<p>Thomas Lin Pedersen (2022). ggraph: An Implementation of
Grammar of Graphics for Graphs and Networks. R package
version 2.0.6. https://CRAN.R-project.org/package=ggraph
</p>

<hr>
<h2 id='norm_FDR_SQAUC'>norm_FDR_SQAUC
The function controls the false discovery rate (FDR) of coexpression patterns
using SQAUC method
Jichun Xie and Ruosha Li. &quot;False discovery rate control for high dimensional
networks of quantile associations conditioning on covariates&quot;.
In: J R Stat Soc Series B Stat Methodol (2018). doi: 10.1111/rssb.12288.</h2><span id='topic+norm_FDR_SQAUC'></span>

<h3>Description</h3>

<p>norm_FDR_SQAUC
The function controls the false discovery rate (FDR) of coexpression patterns
using SQAUC method
Jichun Xie and Ruosha Li. &quot;False discovery rate control for high dimensional
networks of quantile associations conditioning on covariates&quot;.
In: J R Stat Soc Series B Stat Methodol (2018). doi: 10.1111/rssb.12288.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>norm_FDR_SQAUC(value, sam_mean, sam_sd, alpha, n, p)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="norm_FDR_SQAUC_+3A_value">value</code></td>
<td>
<p>the vector of coexpression patterns</p>
</td></tr>
<tr><td><code id="norm_FDR_SQAUC_+3A_sam_mean">sam_mean</code></td>
<td>
<p>the estimated sample mean</p>
</td></tr>
<tr><td><code id="norm_FDR_SQAUC_+3A_sam_sd">sam_sd</code></td>
<td>
<p>the estimated sample sd</p>
</td></tr>
<tr><td><code id="norm_FDR_SQAUC_+3A_alpha">alpha</code></td>
<td>
<p>the type I error rate</p>
</td></tr>
<tr><td><code id="norm_FDR_SQAUC_+3A_n">n</code></td>
<td>
<p>the number of cells</p>
</td></tr>
<tr><td><code id="norm_FDR_SQAUC_+3A_p">p</code></td>
<td>
<p>the number of genes</p>
</td></tr>
</table>


<h3>Value</h3>

<p>lower bound threshold for genes to be significantly coexpressed
</p>

<hr>
<h2 id='quantile_thres'>quantile_thres</h2><span id='topic+quantile_thres'></span>

<h3>Description</h3>

<p>The function classifies count data into binary low (0) - high (1) data, based on whether the count number is greater than a threshold.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>quantile_thres(so)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="quantile_thres_+3A_so">so</code></td>
<td>
<p>a SiFINeT object</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The threshold used for classification is defined by quantile regression on each gene using Frisch–Newton interior point method (&quot;fn&quot; option for method variable in quantreg package, rq function).
By default if no meta data is provided, the quantile regression would be applied on the mean expression level of each cell.
The quantile to be estimated in the quantile regression is set to be the estimated 50% quantile of the non-zero part of the expression level for each gene.
If the expression level of a gene is low (with median 0), then the threshold is set to be 0.
</p>


<h3>Value</h3>

<p>SiFINeT object with data.thres (categorized count matrix) updated.
</p>


<h3>References</h3>

<p>Koenker, R. and S. Portnoy (1997) The Gaussian Hare and the Laplacean Tortoise: Computability of Squared-error vs Absolute Error Estimators, (with discussion). Statistical Science, 12, 279-300.
</p>
<p>Roger Koenker (2022). quantreg: Quantile Regression. R package version 5.94. https://CRAN.R-project.org/package=quantreg
</p>

<hr>
<h2 id='SiFINeT-class'>The SiFINeT Class</h2><span id='topic+SiFINeT-class'></span><span id='topic+SiFINeT'></span>

<h3>Description</h3>

<p>The SiFINeT Class
</p>


<h3>Slots</h3>


<dl>
<dt><code>data</code></dt><dd><p>a list of cell (row) by gene (column) count matrix, either regular or sparse matrix</p>
</dd>
<dt><code>sparse</code></dt><dd><p>whether the count matrix should be analyzed as sparse matrix</p>
</dd>
<dt><code>meta.data</code></dt><dd><p>matrix of meta data, the number of rows should equal to the number of cells</p>
</dd>
<dt><code>gene.name</code></dt><dd><p>a vector of names of genes with length equal to the number of genes</p>
</dd>
<dt><code>data.name</code></dt><dd><p>name of the dataset</p>
</dd>
<dt><code>n</code></dt><dd><p>number of cells in the dataset</p>
</dd>
<dt><code>p</code></dt><dd><p>number of genes in the dataset</p>
</dd>
<dt><code>data.thres</code></dt><dd><p>binarized count matrix</p>
</dd>
<dt><code>coexp</code></dt><dd><p>matrix of genes coexpression</p>
</dd>
<dt><code>est_ms</code></dt><dd><p>estimated mean and sd of coexpression values</p>
</dd>
<dt><code>thres</code></dt><dd><p>lower bound of coexpression (or absolute value of coexpression) for network edge assignment</p>
</dd>
<dt><code>q5</code></dt><dd><p>50% quantile for each gene</p>
</dd>
<dt><code>kset</code></dt><dd><p>index of kept genes after the filtering step</p>
</dd>
<dt><code>conn</code></dt><dd><p>list of connectivities in absolute network</p>
</dd>
<dt><code>conn2</code></dt><dd><p>list of connectivities in positive sub-network</p>
</dd>
<dt><code>fg_id</code></dt><dd><p>index of the candidate feature genes</p>
</dd>
<dt><code>uni_fg_id</code></dt><dd><p>index of the candidate unique feature genes</p>
</dd>
<dt><code>uni_cluster</code></dt><dd><p>cluster result of the candidate unique feature genes</p>
</dd>
<dt><code>selected_cluster</code></dt><dd><p>selected unique feature gene clusters</p>
</dd>
<dt><code>featureset</code></dt><dd><p>detected set of feature genes</p>
</dd>
</dl>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
