<!DOCTYPE html><html lang="en"><head><title>Help for package MECfda</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {MECfda}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#+25+26gt+3B+25'><p>Pipe operator</p></a></li>
<li><a href='#basis2fun'><p>From the summation series of a functional basis to function value</p></a></li>
<li><a href='#bspline_basis_expansion'><p>B-splines basis expansion for functional variable data</p></a></li>
<li><a href='#bspline_basis-class'><p>b-spline basis</p></a></li>
<li><a href='#bspline_series-class'><p>b-splines summation series.</p></a></li>
<li><a href='#bsplineSeries2fun'><p>Compute the value of the b-splines summation series at certain points.</p></a></li>
<li><a href='#dim+2Cfunctional_variable-method'><p>Extract dimensionality of functional data.</p></a></li>
<li><a href='#extractCoef'><p>Method of class Fourier_series to extract Fourier coefficients</p></a></li>
<li><a href='#fc.beta'><p>Extract the value of coefficient parameter function</p></a></li>
<li><a href='#fcQR'><p>Solve quantile regression models with functional covariate(s).</p></a></li>
<li><a href='#fcRegression'><p>Solve linear models with functional covariate(s)</p></a></li>
<li><a href='#fourier_basis_expansion'><p>Fourier basis expansion for functional variable data</p></a></li>
<li><a href='#Fourier_series-class'><p>s4 class of Fourier summation series</p></a></li>
<li><a href='#FourierSeries2fun'><p>Compute the value of the Fourier summation series</p></a></li>
<li><a href='#FPC_basis_expansion'><p>Functional principal component basis expansion for functional variable data</p></a></li>
<li><a href='#functional_variable-class'><p>Function-valued variable data.</p></a></li>
<li><a href='#ME.fcLR_IV'><p>Bias correction method of applying linear regression to one functional</p>
covariate with measurement error using instrumental variable.</a></li>
<li><a href='#ME.fcQR_CLS'><p>Bias correction method of applying quantile linear regression to dataset</p>
with one functional covariate with measurement error using corrected loss score method.</a></li>
<li><a href='#ME.fcQR_IV.SIMEX'><p>Bias correction method of applying quantile linear regression to dataset</p>
with one functional covariate with measurement error using instrumental variable.</a></li>
<li><a href='#ME.fcRegression_MEM'><p>Use UP_MEM or MP_MEM substitution to apply</p>
(generalized) linear regression with one functional covariate with measurement error.</a></li>
<li><a href='#MECfda_simDataGen_fcReg'><p>Simulation Data Generation: Scalar-on-function Regression</p></a></li>
<li><a href='#MECfda_simDataGen_ME'><p>Simulation Data Generation: Measurement Error Bias Correction of Scalar-on-function Regression</p></a></li>
<li><a href='#MECfda.data.sim.0.0'><p>Simulated data</p></a></li>
<li><a href='#MECfda.data.sim.0.1'><p>Simulated data</p></a></li>
<li><a href='#MECfda.data.sim.0.2'><p>Simulated data</p></a></li>
<li><a href='#MECfda.data.sim.0.3'><p>Simulated data</p></a></li>
<li><a href='#MECfda.data.sim.1.0'><p>Simulated data</p></a></li>
<li><a href='#MECfda.data.sim.1.1'><p>Simulated data</p></a></li>
<li><a href='#MECfda.data.sim.1.2'><p>Simulated data</p></a></li>
<li><a href='#MECfda.data.sim.1.3'><p>Simulated data</p></a></li>
<li><a href='#MEM_X_hat'><p>Get MEM substitution for</p>
(generalized) linear regression with one functional covariate with measurement error.</a></li>
<li><a href='#numeric_basis_expansion'><p>Numeric basis expansion for functional variable data</p></a></li>
<li><a href='#numeric_basis-class'><p>Numeric representation of a function basis</p></a></li>
<li><a href='#numericBasis_series-class'><p>Linear combination of a sequence of basis functions represented numerically</p></a></li>
<li><a href='#numericBasisSeries2fun'><p>Compute the value of the basis function summation series at certain points.</p></a></li>
<li><a href='#plot+2Cbspline_series-method'><p>Plot b-splines basis summation series.</p></a></li>
<li><a href='#plot+2CFourier_series-method'><p>Plot Fourier basis summation series.</p></a></li>
<li><a href='#plot+2CnumericBasis_series-method'><p>Plot numeric basis function summation series.</p></a></li>
<li><a href='#predict.fcQR'><p>Predicted values based on fcQR object</p></a></li>
<li><a href='#predict.fcRegression'><p>Predicted values based on fcRegression object</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Scalar-on-Function Regression with Measurement Error Correction</td>
</tr>
<tr>
<td>Version:</td>
<td>0.2.0</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Heyang Ji &lt;jihx1015@outlook.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Solve scalar-on-function linear models,
    including generalized linear mixed effect model and quantile linear regression model,
    and bias correction estimation methods due to measurement error. 
    Details about the measurement error bias correction methods, see
    Luan  et al. (2023) &lt;<a href="https://doi.org/10.48550%2FarXiv.2305.12624">doi:10.48550/arXiv.2305.12624</a>&gt;, 
    Tekwe et al. (2022) &lt;<a href="https://doi.org/10.1093%2Fbiostatistics%2Fkxac017">doi:10.1093/biostatistics/kxac017</a>&gt;, 
    Zhang et al. (2023) &lt;<a href="https://doi.org/10.5705%2Fss.202021.0246">doi:10.5705/ss.202021.0246</a>&gt;, 
    Tekwe et al. (2019) &lt;<a href="https://doi.org/10.1002%2Fsim.8179">doi:10.1002/sim.8179</a>&gt;. </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10),</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, lme4, quantreg, splines, dplyr, MASS, Matrix, gss,
corpcor, fda, magrittr, methods, nlme, glme, mgcv, refund,
pracma</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-03-06 21:41:00 UTC; jihx1</td>
</tr>
<tr>
<td>Author:</td>
<td>Heyang Ji <a href="https://orcid.org/0009-0001-7494-7227"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cre, ctb, dtc],
  Ufuk Beyaztas <a href="https://orcid.org/0000-0002-5208-4950"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, ctb, rev],
  Nicolas Escobar-Velasquez
    <a href="https://orcid.org/0009-0006-0800-5692"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [com],
  Yuanyuan Luan [aut, ctb],
  Xiwei Chen [aut, ctb],
  Mengli Zhang [aut, ctb],
  Roger Zoh [aut, ths],
  Lan Xue [aut, ths],
  Carmen Tekwe <a href="https://orcid.org/0000-0002-1857-2416"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, ths]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-03-06 22:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='+25+26gt+3B+25'>Pipe operator</h2><span id='topic++25+3E+25'></span>

<h3>Description</h3>

<p>See <code>magrittr::<a href="magrittr.html#topic+pipe">%&gt;%</a></code> for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lhs %&gt;% rhs
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="+2B25+2B26gt+2B3B+2B25_+3A_lhs">lhs</code></td>
<td>
<p>A value or the magrittr placeholder.</p>
</td></tr>
<tr><td><code id="+2B25+2B26gt+2B3B+2B25_+3A_rhs">rhs</code></td>
<td>
<p>A function call using the magrittr semantics.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The result of calling 'rhs(lhs)'.
</p>

<hr>
<h2 id='basis2fun'>From the summation series of a functional basis to function value</h2><span id='topic+basis2fun'></span><span id='topic+basis2fun+2Cbspline_series+2Cnumeric-method'></span><span id='topic+basis2fun+2CFourier_series+2Cnumeric-method'></span><span id='topic+basis2fun+2CnumericBasis_series+2Cnumeric-method'></span>

<h3>Description</h3>

<p>Generic function to compute function value from summation series of a functional basis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>basis2fun(object, x)

## S4 method for signature 'bspline_series,numeric'
basis2fun(object, x)

## S4 method for signature 'Fourier_series,numeric'
basis2fun(object, x)

## S4 method for signature 'numericBasis_series,numeric'
basis2fun(object, x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="basis2fun_+3A_object">object</code></td>
<td>
<p>An object that represents a functional basis.</p>
</td></tr>
<tr><td><code id="basis2fun_+3A_x">x</code></td>
<td>
<p>point(s) to take value.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When applied to <code><a href="#topic+bspline_series">bspline_series</a></code>      object, equivalent to <code><a href="#topic+bsplineSeries2fun">bsplineSeries2fun</a></code>.<br />
When applied to <code><a href="#topic+Fourier_series">Fourier_series</a></code>      object, equivalent to <code><a href="#topic+FourierSeries2fun">FourierSeries2fun</a></code>.<br />
When applied to <code><a href="#topic+numericBasis_series">numericBasis_series</a></code> object, equivalent to <code><a href="#topic+numericBasisSeries2fun">numericBasisSeries2fun</a></code>.
</p>


<h3>Value</h3>

<p>A numeric atomic vector.
See <code><a href="#topic+bsplineSeries2fun">bsplineSeries2fun</a></code> and <code><a href="#topic+FourierSeries2fun">FourierSeries2fun</a></code>.
</p>


<h3>Author(s)</h3>

<p>Heyang Ji
</p>

<hr>
<h2 id='bspline_basis_expansion'>B-splines basis expansion for functional variable data</h2><span id='topic+bspline_basis_expansion'></span><span id='topic+bspline_basis_expansion+2Cfunctional_variable+2Cinteger-method'></span>

<h3>Description</h3>

<p>For a function <code class="reqn">f(t), t\in\Omega</code>, and a basis function sequence <code class="reqn">\{\rho_k\}_{k\in\kappa}</code>,
basis expansion is to compute <code class="reqn">\int_\Omega f(t)\rho_k(t) dt</code>.
Here we do basis expansion for all <code class="reqn">f_i(t), t\in\Omega = [t_0,t_0+T]</code> in functional variable data, <code class="reqn">i=1,\dots,n</code>.
We compute a matrix <code class="reqn">(b_{ik})_{n\times p}</code>, where <code class="reqn">b_{ik} = \int_\Omega f(t)\rho_k(t) dt</code>.
The basis used here is the b-splines basis, <code class="reqn">\{B_{i,p}(x)\}_{i=-p}^{k}</code>, <code class="reqn">x\in[t_0,t_{k+1}]</code>,
where <code class="reqn">t_{k+1} = t_0+T</code> and <code class="reqn">B_{i,p}(x)</code> is defined as
</p>
<p style="text-align: center;"><code class="reqn">B_{i,0}(x) = \left\{
  \begin{aligned}
  &amp;I_{(t_i,t_{i+1}]}(x), &amp; i = 0,1,\dots,k\\
  &amp;0, &amp;i&lt;0\ or\ i&gt;k
  \end{aligned}
  \right.</code>
</p>

<p style="text-align: center;"><code class="reqn">B_{i,r}(x) = \frac{x - t_{i}}{t_{i+r}-t_{i}} B_{i,r-1}(x) + \frac{t_{i+r+1} - x}
    {t_{i+r+1} - t_{i+1}}B_{i+1,r-1}(x)</code>
</p>



<h3>Usage</h3>

<pre><code class='language-R'>bspline_basis_expansion(object, n_splines, bs_degree)

## S4 method for signature 'functional_variable,integer'
bspline_basis_expansion(object, n_splines, bs_degree)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bspline_basis_expansion_+3A_object">object</code></td>
<td>
<p>a <code><a href="#topic+functional_variable">functional_variable</a></code> class object.</p>
</td></tr>
<tr><td><code id="bspline_basis_expansion_+3A_n_splines">n_splines</code></td>
<td>
<p>the number of splines, equal to <code class="reqn">k+p+1</code>. See <code>df</code> in <code><a href="splines.html#topic+bs">bs</a></code>.</p>
</td></tr>
<tr><td><code id="bspline_basis_expansion_+3A_bs_degree">bs_degree</code></td>
<td>
<p>the degree of the piecewise polynomial of the b-splines. See <code>degree</code> in <code><a href="splines.html#topic+bs">bs</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a numeric matrix, <code class="reqn">(b_{ik})_{n\times p}</code>, where <code class="reqn">b_{ik} = \int_\Omega f(t)\rho_k(t) dt</code>.
</p>


<h3>Author(s)</h3>

<p>Heyang Ji
</p>

<hr>
<h2 id='bspline_basis-class'>b-spline basis</h2><span id='topic+bspline_basis-class'></span><span id='topic+bspline_basis'></span>

<h3>Description</h3>

<p>A s4 class that represents a b-spline basis <code class="reqn">\{B_{i,p}(x)\}_{i=-p}^{k}</code> on the interval <code class="reqn">[t_0,t_{k+1}]</code>,
where <code class="reqn">B_{i,p}(x)</code> is defined as
</p>
<p style="text-align: center;"><code class="reqn">B_{i,0}(x) = \left\{
  \begin{aligned}
  &amp;I_{(t_i,t_{i+1}]}(x), &amp; i = 0,1,\dots,k\\
  &amp;0, &amp;i&lt;0\ or\ i&gt;k
  \end{aligned}
  \right.</code>
</p>

<p style="text-align: center;"><code class="reqn">B_{i,r}(x) = \frac{x - t_{i}}{t_{i+r}-t_{i}} B_{i,r-1}(x) + \frac{t_{i+r+1} - x}
    {t_{i+r+1} - t_{i+1}}B_{i+1,r-1}(x)</code>
</p>

<p>For all the discontinuity points of <code class="reqn">B_{i,r}</code> (<code class="reqn">r&gt;0</code>) in the interval <code class="reqn">(t_0,t_k)</code>,
let the value equals its limit, which means
</p>
<p style="text-align: center;"><code class="reqn">B_{i,r}(x) = \lim_{t\to x} B_{i,r}(t)</code>
</p>



<h3>Slots</h3>


<dl>
<dt><code>Boundary.knots</code></dt><dd><p>boundary of the domain of the splines (start and end), which is <code class="reqn">t_0</code> and <code class="reqn">t_{k+1}</code>.
Default is <code class="reqn">[0,1]</code>. See <code>Boundary.knots</code> in <code><a href="splines.html#topic+bs">bs</a></code>.</p>
</dd>
<dt><code>knots</code></dt><dd><p>knots of the splines, which is <code class="reqn">(t_1,\dots,t_k)</code>,
equally spaced sequence is chosen by the function automatically with equal space
(<code class="reqn">t_j = t_0 + j\cdot\frac{t_{k+1}-t_0}{k+1}</code>) when not assigned.
See <code>knots</code> in <code><a href="splines.html#topic+bs">bs</a></code>.</p>
</dd>
<dt><code>intercept</code></dt><dd><p>Whether an intercept is included in the basis,
default value is <code>TRUE</code>, and must be <code>TRUE</code>. See <code>intercept</code> <code><a href="splines.html#topic+bs">bs</a></code>.</p>
</dd>
<dt><code>df</code></dt><dd><p>degree of freedom of the basis, which is the number of the splines, equal to <code class="reqn">p+k+1</code>.
By default <code class="reqn">k = 0</code>, and <code>df</code> <code class="reqn">= p+1</code>. See <code>df</code> <code><a href="splines.html#topic+bs">bs</a></code>.</p>
</dd>
<dt><code>degree</code></dt><dd><p>degree of the splines, which is the degree of piecewise polynomials <code class="reqn">p</code>, default value is 3.
See <code>degree</code> in <code><a href="splines.html#topic+bs">bs</a></code>.</p>
</dd>
</dl>


<h3>Author(s)</h3>

<p>Heyang Ji
</p>


<h3>Examples</h3>

<pre><code class='language-R'>bsb = bspline_basis(
            Boundary.knots = c(0,24),
            intercept      = TRUE,
            df             = NULL,
            degree         = 3
)
</code></pre>

<hr>
<h2 id='bspline_series-class'>b-splines summation series.</h2><span id='topic+bspline_series-class'></span><span id='topic+bspline_series'></span>

<h3>Description</h3>

<p>A s4 class that represents
the summation <code class="reqn">\sum_{i=0}^{k}b_i B_{i,p}(x)</code> by a bspline_basis object
and coefficients <code class="reqn">b_i</code> (<code class="reqn">i = 0,\dots,k</code>).
</p>


<h3>Slots</h3>


<dl>
<dt><code>coef</code></dt><dd><p>coefficients of the b-splines, <code class="reqn">b_i</code> (<code class="reqn">i = 0,\dots,k</code>).</p>
</dd>
<dt><code>bspline_basis</code></dt><dd><p>a <code><a href="#topic+bspline_basis">bspline_basis</a></code> object,
represents the b-splines basis used, <code class="reqn">\{B_{i,p}(x)\}_{i=-p}^{k}</code>.</p>
</dd>
</dl>


<h3>Author(s)</h3>

<p>Heyang Ji
</p>


<h3>Examples</h3>

<pre><code class='language-R'>bsb = bspline_basis(
            Boundary.knots = c(0,24),
            intercept      = TRUE,
            df             = NULL,
            degree         = 3
)
bss = bspline_series(
          coef = c(2,1,1.5,0.5),
          bspline_basis = bsb
)
</code></pre>

<hr>
<h2 id='bsplineSeries2fun'>Compute the value of the b-splines summation series at certain points.</h2><span id='topic+bsplineSeries2fun'></span><span id='topic+bsplineSeries2fun+2Cbspline_series+2Cnumeric-method'></span>

<h3>Description</h3>

<p>Compute the function <code class="reqn">f(x) = \sum_{i=0}^{k}b_i B_{i,p}(x)</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bsplineSeries2fun(object, x)

## S4 method for signature 'bspline_series,numeric'
bsplineSeries2fun(object, x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bsplineSeries2fun_+3A_object">object</code></td>
<td>
<p>an object of <code><a href="#topic+bspline_series">bspline_series</a></code> class.</p>
</td></tr>
<tr><td><code id="bsplineSeries2fun_+3A_x">x</code></td>
<td>
<p>Value of $x$.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric atomic vector
</p>


<h3>Author(s)</h3>

<p>Heyang Ji
</p>


<h3>Examples</h3>

<pre><code class='language-R'>bsb = bspline_basis(
            Boundary.knots = c(0,24),
            intercept      = TRUE,
            df             = NULL,
            degree         = 3
)
bss = bspline_series(
          coef = c(2,1,1.5,0.5),
          bspline_basis = bsb
)
bsplineSeries2fun(bss,(1:239)/10)
</code></pre>

<hr>
<h2 id='dim+2Cfunctional_variable-method'>Extract dimensionality of functional data.</h2><span id='topic+dim+2Cfunctional_variable-method'></span>

<h3>Description</h3>

<p>Extract the dimensionality of slot X of functional_variable object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'functional_variable'
dim(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dim+2B2Cfunctional_variable-method_+3A_x">x</code></td>
<td>
<p>a <code><a href="#topic+functional_variable">functional_variable</a></code> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Retruns a 2-element numeric vector.
</p>


<h3>Author(s)</h3>

<p>Heyang Ji
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fv = functional_variable(X=array(rnorm(12),dim = 4:3),period = 3)
dim(fv)
</code></pre>

<hr>
<h2 id='extractCoef'>Method of class Fourier_series to extract Fourier coefficients</h2><span id='topic+extractCoef'></span><span id='topic+extractCoef+2CFourier_series-method'></span>

<h3>Description</h3>

<p>Method of class Fourier_series to extract Fourier coefficients
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extractCoef(object)

## S4 method for signature 'Fourier_series'
extractCoef(object)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="extractCoef_+3A_object">object</code></td>
<td>
<p>an object of <code><a href="#topic+Fourier_series">Fourier_series</a></code> class.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list that contains the coefficients.
</p>


<h3>Author(s)</h3>

<p>Heyang Ji
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fsc = Fourier_series(
           double_constant = 0.5,
           cos = c(0,0.3),
           sin = c(1,0.7),
           k_cos = 1:2,
           )
 extractCoef(fsc)
</code></pre>

<hr>
<h2 id='fc.beta'>Extract the value of coefficient parameter function</h2><span id='topic+fc.beta'></span><span id='topic+fc.beta+2CfcRegression-method'></span><span id='topic+fc.beta+2CfcQR-method'></span>

<h3>Description</h3>

<p>Generic function to extract the value of coefficient parameter function of the covariates
from linear model with functional covariates at some certain points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fc.beta(object, ...)

## S4 method for signature 'fcRegression'
fc.beta(object, FC = 1, t_points = NULL)

## S4 method for signature 'fcQR'
fc.beta(object, FC = 1, t_points = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fc.beta_+3A_object">object</code></td>
<td>
<p>An object that represents a functional covariates linear model.</p>
</td></tr>
<tr><td><code id="fc.beta_+3A_...">...</code></td>
<td>
<p>More arguments.</p>
</td></tr>
<tr><td><code id="fc.beta_+3A_fc">FC</code></td>
<td>
<p>An integer, represent the ordinal number of the functional covariate.
Default is 1, which is take the first functional covariate.</p>
</td></tr>
<tr><td><code id="fc.beta_+3A_t_points">t_points</code></td>
<td>
<p>Sequence of the measurement (time) points.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric atomic vector
</p>


<h3>Author(s)</h3>

<p>Heyang Ji
</p>

<hr>
<h2 id='fcQR'>Solve quantile regression models with functional covariate(s).</h2><span id='topic+fcQR'></span>

<h3>Description</h3>

<p>Fit a quantile regression models below
</p>
<p style="text-align: center;"><code class="reqn">Q_{Y_i|X_i,Z_i}(\tau) = \sum_{l=1}^L\int_\Omega \beta_l(\tau,t) X_{li}(t) dt + (1,Z_i^T)\gamma</code>
</p>

<p>where <code class="reqn">Q_{Y_i}(\tau) = F_{Y_i|X_i,Z_i}^{-1}(\tau)</code> is the
<code class="reqn">\tau</code>-th quantile of <code class="reqn">Y_i</code> given <code class="reqn">X_i(t)</code> and <code class="reqn">Z_i</code>,
<code class="reqn">\tau\in(0,1)</code>.
<br /> Model allows one or multiple functional covariate(s) as fixed effect(s),
and zero, one, or multiple scalar-valued covariate(s).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fcQR(
  Y,
  FC,
  Z,
  formula.Z,
  tau = 0.5,
  basis.type = c("Fourier", "Bspline"),
  basis.order = 6L,
  bs_degree = 3
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fcQR_+3A_y">Y</code></td>
<td>
<p>Response variable, can be an atomic vector, a one-column matrix or data frame,
recommended form is a one-column data frame with column name</p>
</td></tr>
<tr><td><code id="fcQR_+3A_fc">FC</code></td>
<td>
<p>Functional covariate(s),
can be a &quot;functional_variable&quot; object or a matrix or a data frame or a list of these object(s)</p>
</td></tr>
<tr><td><code id="fcQR_+3A_z">Z</code></td>
<td>
<p>Scalar covariate(s), can be <code>NULL</code> or not input (when there's no scalar covariate),
an atomic vector (when only one scalar covariate), a matrix or data frame,
recommended form is a data frame with column name(s)</p>
</td></tr>
<tr><td><code id="fcQR_+3A_formula.z">formula.Z</code></td>
<td>
<p>A formula without the response variable, contains only scalar covariate(s).
If not assigned, include all scalar covariates and intercept term.</p>
</td></tr>
<tr><td><code id="fcQR_+3A_tau">tau</code></td>
<td>
<p>Quantile <code class="reqn">\tau\in(0,1)</code>, default is 0.5. See <code><a href="quantreg.html#topic+rq">rq</a></code>.</p>
</td></tr>
<tr><td><code id="fcQR_+3A_basis.type">basis.type</code></td>
<td>
<p>Type of funtion basis.
Can only be assigned as one type even if there is more than one functional covariates.
Available options: <code>'Fourier'</code> or <code>'Bspline'</code> or <code>'FPC'</code>,
represent Fourier basis, b-spline basis, and functional principal component (FPC) basis respectively.
For the detailed form for Fourier, b-splines, and FPC basis,
see
<code><a href="#topic+fourier_basis_expansion">fourier_basis_expansion</a></code>,
<code><a href="#topic+bspline_basis_expansion">bspline_basis_expansion</a></code>, and
<code><a href="#topic+FPC_basis_expansion">FPC_basis_expansion</a></code>.</p>
</td></tr>
<tr><td><code id="fcQR_+3A_basis.order">basis.order</code></td>
<td>
<p>Indicate number of the function basis.
When using Fourier basis <code class="reqn">\frac{1}{2},\sin k t, \cos k t, k = 1,\dots,K</code>,
<code>basis.order</code> is the number <code class="reqn">K</code>.
When using b-splines basis <code class="reqn">\{B_{i,p}(x)\}_{i=-p}^{k}</code>,
<code>basis.order</code> is the number of splines, equal to <code class="reqn">k+p+1</code>.
When using FPC basis, <code>basis.order</code> is the number of functional principal components.
(same as arguement <code>df</code> in <code><a href="splines.html#topic+bs">bs</a></code>.)
May set a individual number for each functional covariate.
When the element of this argument is less than the number of functional covariates,
it will be used recursively.</p>
</td></tr>
<tr><td><code id="fcQR_+3A_bs_degree">bs_degree</code></td>
<td>
<p>Degree of the piecewise polynomials if use b-splines basis, default is 3.
See <code>degree</code> in <code><a href="splines.html#topic+bs">bs</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>fcQR returns an object of class &quot;fcQR&quot;.
It is a list that contains the following elements.
</p>
<table role = "presentation">
<tr><td><code>regression_result</code></td>
<td>
<p>Result of the regression.</p>
</td></tr>
<tr><td><code>FC.BasisCoefficient</code></td>
<td>
<p>A list of Fourier_series or bspline_series object(s),
represents the functional linear coefficient(s) of the functional covariates.</p>
</td></tr>
<tr><td><code>function.basis.type</code></td>
<td>
<p>Type of funtion basis used.</p>
</td></tr>
<tr><td><code>basis.order</code></td>
<td>
<p>Same as in the arguemnets.</p>
</td></tr>
<tr><td><code>data</code></td>
<td>
<p>Original data.</p>
</td></tr>
<tr><td><code>bs_degree</code></td>
<td>
<p>Degree of the splines, returned only if b-splines basis is used.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Heyang Ji
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(MECfda.data.sim.0.0)
res = fcQR(FC = MECfda.data.sim.0.0$FC, Y=MECfda.data.sim.0.0$Y, Z=MECfda.data.sim.0.0$Z,
           basis.order = 5, basis.type = c('Bspline'))

</code></pre>

<hr>
<h2 id='fcRegression'>Solve linear models with functional covariate(s)</h2><span id='topic+fcRegression'></span>

<h3>Description</h3>

<p>Function to fit (generalized) linear model with functional covariate(s).
Model allows one or multiple functional covariate(s) as fixed effect(s), and zero,
one, or multiple scalar-valued fixed or random effect(s).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fcRegression(
  Y,
  FC,
  Z,
  formula.Z,
  family = gaussian(link = "identity"),
  basis.type = c("Fourier", "Bspline", "FPC"),
  basis.order = 6L,
  bs_degree = 3
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fcRegression_+3A_y">Y</code></td>
<td>
<p>Response variable, can be an atomic vector, a one-column matrix or data frame,
recommended form is a one-column data frame with column name.</p>
</td></tr>
<tr><td><code id="fcRegression_+3A_fc">FC</code></td>
<td>
<p>Functional covariate(s),
can be a &quot;functional_variable&quot; object or a matrix or a data frame or a list of these object(s).</p>
</td></tr>
<tr><td><code id="fcRegression_+3A_z">Z</code></td>
<td>
<p>Scalar covariate(s), can be <code>NULL</code> or not input (when there's no scalar covariate),
an atomic vector (when only one scalar covariate), a matrix or data frame,
recommended form is a data frame with column name(s).</p>
</td></tr>
<tr><td><code id="fcRegression_+3A_formula.z">formula.Z</code></td>
<td>
<p>A formula without the response variable,
contains only scalar covariate(s) (or intercept),
use the format of lme4 package if random effects exist. e.g. <code>~ Z_1 + (1|Z_2)</code>.
(See <code><a href="lme4.html#topic+lmer">lmer</a></code> and <code><a href="lme4.html#topic+glmer">glmer</a></code>)
If not assigned, include all scalar covariates and intercept term as fixed effects.</p>
</td></tr>
<tr><td><code id="fcRegression_+3A_family">family</code></td>
<td>
<p>A description of the error distribution and link function to be used in the model,
see <code><a href="stats.html#topic+family">family</a></code>.</p>
</td></tr>
<tr><td><code id="fcRegression_+3A_basis.type">basis.type</code></td>
<td>
<p>Type of funtion basis.
Can only be assigned as one type even if there is more than one functional covariates.
Available options: <code>'Fourier'</code> or <code>'Bspline'</code> or <code>'FPC'</code>,
represent Fourier basis, b-spline basis, and functional principal component (FPC) basis respectively.
For the detailed form for Fourier, b-splines, and FPC basis,
see
<code><a href="#topic+fourier_basis_expansion">fourier_basis_expansion</a></code>,
<code><a href="#topic+bspline_basis_expansion">bspline_basis_expansion</a></code>, and
<code><a href="#topic+FPC_basis_expansion">FPC_basis_expansion</a></code>.</p>
</td></tr>
<tr><td><code id="fcRegression_+3A_basis.order">basis.order</code></td>
<td>
<p>Indicate number of the function basis.
When using Fourier basis <code class="reqn">\frac{1}{2},\sin k t, \cos k t, k = 1,\dots,p_f</code>,
<code>basis.order</code> is the number <code class="reqn">p_f</code>.
When using b-splines basis <code class="reqn">\{B_{i,p}(x)\}_{i=-p}^{k}</code>,
<code>basis.order</code> is the number of splines, equal to <code class="reqn">k+p+1</code>.
(same as arguement <code>df</code> in <code><a href="splines.html#topic+bs">bs</a></code>.)
When using FPC basis, <code>basis.order</code> is the number of functional principal components.
May set a individual number for each functional covariate.
When the element of this argument is less than the number of functional covariates,
it will be used recursively.</p>
</td></tr>
<tr><td><code id="fcRegression_+3A_bs_degree">bs_degree</code></td>
<td>
<p>Degree of the piecewise polynomials if use b-splines basis,
default is 3. See <code>degree</code> in <code><a href="splines.html#topic+bs">bs</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Solve linear models with functional covariates below
</p>
<p style="text-align: center;"><code class="reqn">g(E(Y_i|X_i,Z_i)) = \sum_{l=1}^{L} \int_{\Omega_l} \beta_l(t) X_{li}(t) dt + (1,Z_i^T)\gamma</code>
</p>

<p>where the scalar-valued covariates can be fixed or random effect or doesn't exist
(may do not contain scalar-valued covariates).
</p>


<h3>Value</h3>

<p>fcRegression returns an object of class &quot;fcRegression&quot;.
It is a list that contains the following elements.
</p>
<table role = "presentation">
<tr><td><code>regression_result</code></td>
<td>
<p>Result of the regression.</p>
</td></tr>
<tr><td><code>FC.BasisCoefficient</code></td>
<td>
<p>A list of <code>Fourier_series</code> or <code>bspline_series</code> or <code>numeric_basis</code> object(s),
represents the functional linear coefficient(s) of the functional covariates.</p>
</td></tr>
<tr><td><code>function.basis.type</code></td>
<td>
<p>Type of funtion basis used.</p>
</td></tr>
<tr><td><code>basis.order</code></td>
<td>
<p>Same as in the arguemnets.</p>
</td></tr>
<tr><td><code>data</code></td>
<td>
<p>Original data.</p>
</td></tr>
<tr><td><code>bs_degree</code></td>
<td>
<p>Degree of the splines, returned only if b-splines basis is used.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Heyang Ji
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(MECfda.data.sim.0.0)
res = fcRegression(FC = MECfda.data.sim.0.0$FC, Y=MECfda.data.sim.0.0$Y, Z=MECfda.data.sim.0.0$Z,
                   basis.order = 5, basis.type = c('Bspline'),
                   formula.Z = ~ Z_1 + (1|Z_2))
</code></pre>

<hr>
<h2 id='fourier_basis_expansion'>Fourier basis expansion for functional variable data</h2><span id='topic+fourier_basis_expansion'></span><span id='topic+fourier_basis_expansion+2Cfunctional_variable+2Cinteger-method'></span>

<h3>Description</h3>

<p>For a function <code class="reqn">f(x), x\in\Omega</code>, and a basis function sequence <code class="reqn">\{\rho_k\}_{k\in\kappa}</code>,
basis expansion is to compute <code class="reqn">\int_\Omega f(t)\rho_k(t) dt</code>.
Here we do basis expansion for all <code class="reqn">f_i(t), t\in\Omega = [t_0,t_0+T]</code> in functional variable data, <code class="reqn">i=1,\dots,n</code>.
We compute a matrix <code class="reqn">(b_{ik})_{n\times p}</code>, where <code class="reqn">b_{ik} = \int_\Omega f(t)\rho_k(t) dt</code>.
The basis used here is the Fourier basis, </p>
<p style="text-align: center;"><code class="reqn">\frac{1}{2},\ \cos(\frac{2\pi}{T}k[x-t_0]),\ \sin (\frac{2\pi}{T}k[x-t_0])</code>
</p>

<p>where <code class="reqn">x\in[t_0,t_0+T]</code> and <code class="reqn">k = 1,\dots,p_f</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fourier_basis_expansion(object, order_fourier_basis)

## S4 method for signature 'functional_variable,integer'
fourier_basis_expansion(object, order_fourier_basis)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fourier_basis_expansion_+3A_object">object</code></td>
<td>
<p>a <code><a href="#topic+functional_variable">functional_variable</a></code> class object.</p>
</td></tr>
<tr><td><code id="fourier_basis_expansion_+3A_order_fourier_basis">order_fourier_basis</code></td>
<td>
<p>the order of Fourier basis, <code class="reqn">p_f</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a numeric matrix, <code class="reqn">(b_{ik})_{n\times p}</code>, where <code class="reqn">b_{ik} = \int_\Omega f(t)\rho_k(t) dt</code>.
</p>


<h3>Author(s)</h3>

<p>Heyang Ji
</p>

<hr>
<h2 id='Fourier_series-class'>s4 class of Fourier summation series</h2><span id='topic+Fourier_series-class'></span><span id='topic+Fourier_series'></span>

<h3>Description</h3>

<p>A s4 class that represents the linear combination of Fourier basis functions below:
</p>
<p style="text-align: center;"><code class="reqn">\frac{a_0}{2} +
\sum_{k=1}^{p_a} a_k \cos{(\frac{2\pi}{T}k(x-t_0))} +
\sum_{k=1}^{p_b} b_k \sin{(\frac{2\pi}{T}k(x-t_0))},
\qquad x\in[t_0,t_0+T]</code>
</p>



<h3>Details</h3>

<p>If not assigned, <code class="reqn">t_0 = 0</code>, <code class="reqn">T = 2\pi</code>.
If not assigned, k_cos and k_sin equals 1, 2, 3, ...
</p>


<h3>Slots</h3>


<dl>
<dt><code>double_constant</code></dt><dd><p>value of <code class="reqn">a_0</code>.</p>
</dd>
<dt><code>cos</code></dt><dd><p>values of coefficients of <code class="reqn">\cos</code> waves, <code class="reqn">a_k</code>.</p>
</dd>
<dt><code>sin</code></dt><dd><p>values of coefficients of <code class="reqn">\sin</code> waves, <code class="reqn">b_k</code>.</p>
</dd>
<dt><code>k_cos</code></dt><dd><p>values of <code class="reqn">k</code> corresponding to the coefficients of <code class="reqn">\cos</code> waves</p>
</dd>
<dt><code>k_sin</code></dt><dd><p>values of <code class="reqn">k</code> corresponding to the coefficients of <code class="reqn">\sin</code> waves</p>
</dd>
<dt><code>t_0</code></dt><dd><p>left end of the domain interval, <code class="reqn">t_0</code></p>
</dd>
<dt><code>period</code></dt><dd><p>length of the domain interval, <code class="reqn">T</code>.</p>
</dd>
</dl>


<h3>Author(s)</h3>

<p>Heyang Ji
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fsc = Fourier_series(
           double_constant = 0.5,
           cos = c(0,0.3),
           sin = c(1,0.7),
           k_cos = 1:2,
           )
</code></pre>

<hr>
<h2 id='FourierSeries2fun'>Compute the value of the Fourier summation series</h2><span id='topic+FourierSeries2fun'></span><span id='topic+FourierSeries2fun+2CFourier_series+2Cnumeric-method'></span>

<h3>Description</h3>

<p>Compute the value of the Fourier summation series
</p>
<p style="text-align: center;"><code class="reqn">f(x) = \frac{a_0}{2} +
\sum_{k=1}^{p_a} a_k \cos{(\frac{2\pi}{T}k(x-t_0))} +
\sum_{k=1}^{p_b} b_k \sin{(\frac{2\pi}{T}k(x-t_0))},
\qquad x\in[t_0,t_0+T]</code>
</p>

<p>at some certain point(s).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FourierSeries2fun(object, x)

## S4 method for signature 'Fourier_series,numeric'
FourierSeries2fun(object, x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="FourierSeries2fun_+3A_object">object</code></td>
<td>
<p>an object of <code><a href="#topic+Fourier_series">Fourier_series</a></code> class.</p>
</td></tr>
<tr><td><code id="FourierSeries2fun_+3A_x">x</code></td>
<td>
<p>Value of <code class="reqn">x</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric atomic vector
</p>


<h3>Author(s)</h3>

<p>Heyang Ji
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fsc = Fourier_series(
           double_constant = 0.5,
           cos = c(0,0.3),
           sin = c(1,0.7),
           k_cos = 1:2,
           )
          FourierSeries2fun(fsc,1:5)

</code></pre>

<hr>
<h2 id='FPC_basis_expansion'>Functional principal component basis expansion for functional variable data</h2><span id='topic+FPC_basis_expansion'></span><span id='topic+FPC_basis_expansion+2Cfunctional_variable+2Cinteger-method'></span>

<h3>Description</h3>

<p>For a function <code class="reqn">f(t), t\in\Omega</code>, and a basis function sequence <code class="reqn">\{\rho_k\}_{k\in\kappa}</code>,
basis expansion is to compute <code class="reqn">\int_\Omega f(t)\rho_k(t) dt</code>.
Here we do basis expansion for all <code class="reqn">f_i(t), t\in\Omega = [t_0,t_0+T]</code> in functional variable data, <code class="reqn">i=1,\dots,n</code>.
We compute a matrix <code class="reqn">(b_{ik})_{n\times p}</code>, where <code class="reqn">b_{ik} = \int_\Omega f(t)\rho_k(t) dt</code>.
The basis we use here is the functional principal component (FPC) basis induced by
the covariance function of the functional variable.
Suppose <code class="reqn">K(s,t)\in L^2(\Omega\times \Omega)</code>, <code class="reqn">f(t)\in L^2(\Omega)</code>.
Then <code class="reqn">K</code> induces an linear operator <code class="reqn">\mathcal{K}</code> by
</p>
<p style="text-align: center;"><code class="reqn">(\mathcal{K}f)(x) = \int_{\Omega} K(t,x)f(t)dt</code>
</p>

<p>If <code class="reqn">\xi(\cdot)\in L^2(\Omega)</code> such that
</p>
<p style="text-align: center;"><code class="reqn">\mathcal{K}\xi = \lambda \xi</code>
</p>

<p>where <code class="reqn">\lambda\in {C}</code>,
we call <code class="reqn">\xi</code> an eigenfunction/eigenvector of
<code class="reqn">\mathcal{K}</code>, and <code class="reqn">\lambda</code> an eigenvalue associated with <code class="reqn">\xi</code>.<br />
For a stochastic process <code class="reqn">\{X(t),t\in\Omega\}</code>
we call the orthogonal basis <code class="reqn">\{\xi_k\}_{k=1}^\infty</code>
corresponding to eigenvalues <code class="reqn">\{\lambda_k\}_{k=1}^\infty</code>
(<code class="reqn">\lambda_1\geq\lambda_2\geq\dots</code>),
induced by
</p>
<p style="text-align: center;"><code class="reqn">K(s,t)=\text{Cov}(X(t),X(s))</code>
</p>

<p>a functional principal component (FPC) basis for <code class="reqn">L^2(\Omega)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FPC_basis_expansion(object, npc)

## S4 method for signature 'functional_variable,integer'
FPC_basis_expansion(object, npc)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="FPC_basis_expansion_+3A_object">object</code></td>
<td>
<p>a <code><a href="#topic+functional_variable">functional_variable</a></code> class object.
The minimum and maximum of the slot <code>t_points</code> should be respectively
equal to the slot <code>t_0</code> and slot <code>t_0</code> plus slot <code>period</code>.</p>
</td></tr>
<tr><td><code id="FPC_basis_expansion_+3A_npc">npc</code></td>
<td>
<p>The number of functional principal components. See <code>npc</code> in <code><a href="refund.html#topic+fpca.sc">fpca.sc</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a numeric matrix, <code class="reqn">(b_{ik})_{n\times p}</code>,
with an extra attribute <code>numeric_basis</code>, which represents the FPC basis.
The attribute <code>numeric_basis</code> is a <code>numeric_basis</code> object. See <code><a href="#topic+numeric_basis">numeric_basis</a></code>.
The slot <code>basis_function</code> is also a numeric matrix, denoted as <code class="reqn">(\zeta_{jk})_{m\times p}</code>
</p>
<p style="text-align: center;"><code class="reqn">b_{ik} = \int_\Omega f(t)\xi_k(t) dt</code>
</p>

<p style="text-align: center;"><code class="reqn">\zeta_{jk} = \xi_k(t_j)</code>
</p>



<h3>Author(s)</h3>

<p>Heyang Ji
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n&lt;-50; ti&lt;-seq(0,1,length.out=101)
X&lt;-t(sin(2*pi*ti)%*%t(rnorm(n,0,1)))
object = functional_variable(X = X, t_0 = 0, period = 1, t_points = ti)
a = FPC_basis_expansion(object,3L)
dim(a)
</code></pre>

<hr>
<h2 id='functional_variable-class'>Function-valued variable data.</h2><span id='topic+functional_variable-class'></span><span id='topic+functional_variable'></span>

<h3>Description</h3>

<p>A s4 class that represents data of a function-valued variable.
The format is
<code class="reqn">f_i(t),\ t\in\Omega=[t_0,t_0 + T]</code>
where <code class="reqn">i</code> is the observation (subject) index, <code class="reqn">t</code> represents the measurement (time) points.
</p>


<h3>Slots</h3>


<dl>
<dt><code>X</code></dt><dd><p>a matrix <code class="reqn">(x_{ij})_{n\times m}</code>, where <code class="reqn">x_{ij} = f_i(t_j)</code>, represents the value of <code class="reqn">f_i(t_j)</code>, each row represent an observation (subject), each column is corresponding to a measurement (time) point.</p>
</dd>
<dt><code>t_0</code></dt><dd><p>start of the domain (time period), <code class="reqn">t_0</code>. Default is 0.</p>
</dd>
<dt><code>period</code></dt><dd><p>length of the domain (time period), <code class="reqn">T</code>. Default is 1.</p>
</dd>
<dt><code>t_points</code></dt><dd><p>sequence of the measurement points, <code class="reqn">(t_1,\dots,t_m)</code>. Default is <code class="reqn">t_k = t_0 + \frac{(2k-1)T}{2(m+1)}</code>.</p>
</dd>
</dl>


<h3>Author(s)</h3>

<p>Heyang Ji
</p>


<h3>Examples</h3>

<pre><code class='language-R'>X = array(rnorm(12),dim = 4:3)
functional_variable(X=X,period = 3)
</code></pre>

<hr>
<h2 id='ME.fcLR_IV'>Bias correction method of applying linear regression to one functional
covariate with measurement error using instrumental variable.</h2><span id='topic+ME.fcLR_IV'></span>

<h3>Description</h3>

<p>See detailed model in reference
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ME.fcLR_IV(
  data.Y,
  data.W,
  data.M,
  t_interval = c(0, 1),
  t_points = NULL,
  CI.bootstrap = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ME.fcLR_IV_+3A_data.y">data.Y</code></td>
<td>
<p>Response variable, can be an atomic vector, a one-column matrix or data frame,
recommended form is a one-column data frame with column name.</p>
</td></tr>
<tr><td><code id="ME.fcLR_IV_+3A_data.w">data.W</code></td>
<td>
<p>A dataframe or matrix, represents <code class="reqn">W</code>, the measurement of <code class="reqn">X</code>.
Each row represents a subject. Each column represent a measurement (time) point.</p>
</td></tr>
<tr><td><code id="ME.fcLR_IV_+3A_data.m">data.M</code></td>
<td>
<p>A dataframe or matrix, represents <code class="reqn">M</code>, the instrumental variable.
Each row represents a subject. Each column represent a measurement (time) point.</p>
</td></tr>
<tr><td><code id="ME.fcLR_IV_+3A_t_interval">t_interval</code></td>
<td>
<p>A 2-element vector, represents an interval,
means the domain of the functional covariate.
Default is <code>c(0,1)</code>, represent interval <code class="reqn">[0,1]</code>.</p>
</td></tr>
<tr><td><code id="ME.fcLR_IV_+3A_t_points">t_points</code></td>
<td>
<p>Sequence of the measurement (time) points,
default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="ME.fcLR_IV_+3A_ci.bootstrap">CI.bootstrap</code></td>
<td>
<p>Whether to return the confidence using bootstrap method.
Default is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a ME.fcLR_IV class object. It is a list that contains the following elements.
</p>
<table role = "presentation">
<tr><td><code>beta_tW</code></td>
<td>
<p>Parameter estimates.</p>
</td></tr>
<tr><td><code>CI</code></td>
<td>
<p>Confidence interval, returnd only when CI.bootstrap is TRUE. </p>
</td></tr>
</table>


<h3>References</h3>

<p>Tekwe, Carmen D., et al.
&quot;Instrumental variable approach to estimating the scalar‐on‐function regression model w
ith measurement error with application to energy expenditure assessment in childhood obesity.&quot;
Statistics in medicine 38.20 (2019): 3764-3781.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(MECfda.data.sim.0.3)
res = ME.fcLR_IV(data.Y = MECfda.data.sim.0.3$Y,
              data.W = MECfda.data.sim.0.3$W,
              data.M = MECfda.data.sim.0.3$M)
</code></pre>

<hr>
<h2 id='ME.fcQR_CLS'>Bias correction method of applying quantile linear regression to dataset
with one functional covariate with measurement error using corrected loss score method.</h2><span id='topic+ME.fcQR_CLS'></span>

<h3>Description</h3>

<p>Zhang et al. proposed a new corrected loss function for a
partially functional linear quantile model with functional measurement error in this manuscript.
They established a corrected quantile objective function of the observed measurement
that is an unbiased estimator of the quantile objective function
that would be obtained if the true measurements were available.
The estimators of the regression parameters are obtained
by optimizing the resulting corrected loss function.
The resulting estimator of the regression parameters is shown to be consistent.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ME.fcQR_CLS(
  data.Y,
  data.W,
  data.Z,
  tau = 0.5,
  t_interval = c(0, 1),
  t_points = NULL,
  grid_k,
  grid_h,
  degree = 45,
  observed_X = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ME.fcQR_CLS_+3A_data.y">data.Y</code></td>
<td>
<p>Response variable, can be an atomic vector, a one-column matrix or data frame,
recommended form is a one-column data frame with column name.</p>
</td></tr>
<tr><td><code id="ME.fcQR_CLS_+3A_data.w">data.W</code></td>
<td>
<p>A 3-dimensional array, represents <code class="reqn">W</code>, the measurement of <code class="reqn">X</code>.
Each row represents a subject.
Each column represent a measurement (time) point.
Each layer represents an observation.</p>
</td></tr>
<tr><td><code id="ME.fcQR_CLS_+3A_data.z">data.Z</code></td>
<td>
<p>Scalar covariate(s),
can be not input or <code>NULL</code> (when there's no scalar covariate),
an atomic vector (when only one scalar covariate),
a matrix or data frame, recommended form is a data frame with column name(s).</p>
</td></tr>
<tr><td><code id="ME.fcQR_CLS_+3A_tau">tau</code></td>
<td>
<p>Quantile <code class="reqn">\tau\in(0,1)</code>, default is 0.5.</p>
</td></tr>
<tr><td><code id="ME.fcQR_CLS_+3A_t_interval">t_interval</code></td>
<td>
<p>A 2-element vector, represents an interval,
means the domain of the functional covariate. Default is c(0,1), represent interval <code class="reqn">[0,1]</code>.</p>
</td></tr>
<tr><td><code id="ME.fcQR_CLS_+3A_t_points">t_points</code></td>
<td>
<p>Sequence of the measurement (time) points, default is <code>NULL</code></p>
</td></tr>
<tr><td><code id="ME.fcQR_CLS_+3A_grid_k">grid_k</code></td>
<td>
<p>An atomic vector, of which each element is candidate number of basis.</p>
</td></tr>
<tr><td><code id="ME.fcQR_CLS_+3A_grid_h">grid_h</code></td>
<td>
<p>A non-zero-value atomic vector, of which each element is candidate value of tunning parameter.</p>
</td></tr>
<tr><td><code id="ME.fcQR_CLS_+3A_degree">degree</code></td>
<td>
<p>Used in computation for derivative and integral, defult is 45, large enough for most scenario.</p>
</td></tr>
<tr><td><code id="ME.fcQR_CLS_+3A_observed_x">observed_X</code></td>
<td>
<p>For estimating parametric variance. Default is <code>NULL</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a ME.fcQR_CLS class object. It is a list that contains the following elements.
</p>
<table role = "presentation">
<tr><td><code>estimated_beta_hat</code></td>
<td>
<p>Estimated coefficients from corrected loss function (including functional part)</p>
</td></tr>
<tr><td><code>estimated_beta_t</code></td>
<td>
<p>Estimated functional curve</p>
</td></tr>
<tr><td><code>SE_est</code></td>
<td>
<p>Estimated parametric variance. Returned only if observed_X is not <code>NULL</code>.</p>
</td></tr>
<tr><td><code>estimated_Xbasis</code></td>
<td>
<p>The basis matrix we used</p>
</td></tr>
<tr><td><code>res_naive</code></td>
<td>
<p>results of naive method</p>
</td></tr>
</table>


<h3>References</h3>

<p>Zhang, Mengli, et al.
&quot;PARTIALLY FUNCTIONAL LINEAR QUANTILE REGRESSION WITH MEASUREMENT ERRORS.&quot;
Statistica Sinica 33 (2023): 2257-2280.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(MECfda.data.sim.0.1)

res = ME.fcQR_CLS(data.Y = MECfda.data.sim.0.1$Y,
                data.W = MECfda.data.sim.0.1$W,
               data.Z = MECfda.data.sim.0.1$Z,
               tau = 0.5,
               grid_k = 4:7,
               grid_h = 1:2)

</code></pre>

<hr>
<h2 id='ME.fcQR_IV.SIMEX'>Bias correction method of applying quantile linear regression to dataset
with one functional covariate with measurement error using instrumental variable.</h2><span id='topic+ME.fcQR_IV.SIMEX'></span>

<h3>Description</h3>

<p>Perform a two-stage strategy to correct the measurement error of
a function-valued covariate and then fit a linear quantile regression model.
In the first stage, an instrumental variable is used to estimate
the covariance matrix associated with the measurement error.
In the second stage, simulation extrapolation (SIMEX) is used to correct for
measurement error in the function-valued covariate. <br />
See detailed model in the reference.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ME.fcQR_IV.SIMEX(
  data.Y,
  data.W,
  data.Z,
  data.M,
  tau = 0.5,
  t_interval = c(0, 1),
  t_points = NULL,
  formula.Z,
  basis.type = c("Fourier", "Bspline"),
  basis.order = NULL,
  bs_degree = 3
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ME.fcQR_IV.SIMEX_+3A_data.y">data.Y</code></td>
<td>
<p>Response variable, can be an atomic vector, a one-column matrix or data frame,
recommended form is a one-column data frame with column name.</p>
</td></tr>
<tr><td><code id="ME.fcQR_IV.SIMEX_+3A_data.w">data.W</code></td>
<td>
<p>A dataframe or matrix, represents <code class="reqn">W</code>, the measurement of <code class="reqn">X</code>.
Each row represents a subject. Each column represent a measurement (time) point.</p>
</td></tr>
<tr><td><code id="ME.fcQR_IV.SIMEX_+3A_data.z">data.Z</code></td>
<td>
<p>Scalar covariate(s),
can be not input or <code>NULL</code> (when there's no scalar covariate),
an atomic vector (when only one scalar covariate), a matrix or data frame,
recommended form is a data frame with column name(s).</p>
</td></tr>
<tr><td><code id="ME.fcQR_IV.SIMEX_+3A_data.m">data.M</code></td>
<td>
<p>A dataframe or matrix, represents <code class="reqn">M</code>,
the instrumental variable. Each row represents a subject.
Each column represent a measurement (time) point.</p>
</td></tr>
<tr><td><code id="ME.fcQR_IV.SIMEX_+3A_tau">tau</code></td>
<td>
<p>Quantile <code class="reqn">\tau\in(0,1)</code>, default is 0.5.</p>
</td></tr>
<tr><td><code id="ME.fcQR_IV.SIMEX_+3A_t_interval">t_interval</code></td>
<td>
<p>A 2-element vector, represents an interval,
means the domain of the functional covariate. Default is c(0,1), represent interval <code class="reqn">[0,1]</code>.</p>
</td></tr>
<tr><td><code id="ME.fcQR_IV.SIMEX_+3A_t_points">t_points</code></td>
<td>
<p>Sequence of the measurement (time) points, default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="ME.fcQR_IV.SIMEX_+3A_formula.z">formula.Z</code></td>
<td>
<p>A formula without the response variable,
contains only scalar covariate(s), no random effects. If not assigned,
include all scalar covariates and intercept term.</p>
</td></tr>
<tr><td><code id="ME.fcQR_IV.SIMEX_+3A_basis.type">basis.type</code></td>
<td>
<p>Type of funtion basis.
Can only be assigned as one type even if there is more than one functional covariates.
Available options: 'Fourier' or 'Bspline', represent Fourier basis and b-spline basis respectively.
For the detailed form for Fourier and b-splines basis,
see <code><a href="#topic+fourier_basis_expansion">fourier_basis_expansion</a></code> and <code><a href="#topic+bspline_basis_expansion">bspline_basis_expansion</a></code>.</p>
</td></tr>
<tr><td><code id="ME.fcQR_IV.SIMEX_+3A_basis.order">basis.order</code></td>
<td>
<p>Indicate number of the function basis.
When using Fourier basis <code class="reqn">\frac{1}{2},\sin k t, \cos k t, k = 1,\dots,K</code>,
basis.order is the number <code class="reqn">K</code>.
When using b-splines basis <code class="reqn">\{B_{i,p}(x)\}_{i=-p}^{k}</code>,
basis.order is the number of splines, equal to <code class="reqn">k+p+1</code>.
(same as arguement <code>df</code> in <code><a href="splines.html#topic+bs">bs</a></code>.)
May set a individual number for each functional covariate.
When the element of this argument is less than the number of functional covariates,
it will be used recursively.</p>
</td></tr>
<tr><td><code id="ME.fcQR_IV.SIMEX_+3A_bs_degree">bs_degree</code></td>
<td>
<p>Degree of the piecewise polynomials if use b-splines basis,
default is 3. See <code>degree</code> in <code><a href="splines.html#topic+bs">bs</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a ME.fcQR_IV.SIMEX class object.
It is a list that contains the following elements.
</p>
<table role = "presentation">
<tr><td><code>coef.X</code></td>
<td>
<p>A Fourier_series or bspline_series object,
represents the functional coefficient parameter of the functional covariate.</p>
</td></tr>
<tr><td><code>coef.Z</code></td>
<td>
<p>The estimate of the linear coefficients of the scalar covariates.</p>
</td></tr>
<tr><td><code>coef.all</code></td>
<td>
<p>Original estimate of linear coefficients.</p>
</td></tr>
<tr><td><code>function.basis.type</code></td>
<td>
<p>Type of funtion basis used.</p>
</td></tr>
<tr><td><code>basis.order</code></td>
<td>
<p>Same as in the input arguements.</p>
</td></tr>
<tr><td><code>t_interval</code></td>
<td>
<p>A 2-element vector, represents an interval,
means the domain of the functional covariate.</p>
</td></tr>
<tr><td><code>t_points</code></td>
<td>
<p>Sequence of the measurement (time) points.</p>
</td></tr>
<tr><td><code>formula</code></td>
<td>
<p>Regression model.</p>
</td></tr>
<tr><td><code>formula.Z</code></td>
<td>
<p>formula object contains only the scalar covariate(s).</p>
</td></tr>
<tr><td><code>zlevels</code></td>
<td>
<p>levels of the non-continuous scalar covariate(s). </p>
</td></tr>
</table>


<h3>References</h3>

<p>Tekwe, Carmen D., et al.
&quot;Estimation of sparse functional quantile regression with measurement error: a SIMEX approach.&quot;
Biostatistics 23.4 (2022): 1218-1241.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(MECfda.data.sim.0.2)

res = ME.fcQR_IV.SIMEX(data.Y = MECfda.data.sim.0.2$Y,
                       data.W = MECfda.data.sim.0.2$W,
                       data.Z = MECfda.data.sim.0.2$Z,
                       data.M = MECfda.data.sim.0.2$M,
                       tau = 0.5,
                       basis.type = 'Bspline')

</code></pre>

<hr>
<h2 id='ME.fcRegression_MEM'>Use UP_MEM or MP_MEM substitution to apply
(generalized) linear regression with one functional covariate with measurement error.</h2><span id='topic+ME.fcRegression_MEM'></span>

<h3>Description</h3>

<p>The Mixed-effect model (MEM) approach is a two-stage-based method that employs functional mixed-effects models.
It allows us to delve into the nonlinear measurement error model,
where the relationship between the true and observed measurements is not constrained to be linear,
and the distribution assumption on the observed measurement is relaxed to encompass
the exponential family rather than being limited to the Gaussian distribution.
The MEM approach employs point-wise (UP_MEM) and multi-point-wise (MP_MEM) estimation
procedures to avoid potential computational complexities caused by analyses of
multi-level functional data and computations of potentially intractable and complex integrals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ME.fcRegression_MEM(
  data.Y,
  data.W,
  data.Z,
  method = c("UP_MEM", "MP_MEM", "average"),
  t_interval = c(0, 1),
  t_points = NULL,
  d = 3,
  family.W = c("gaussian", "poisson"),
  family.Y = "gaussian",
  formula.Z,
  basis.type = c("Fourier", "Bspline"),
  basis.order = NULL,
  bs_degree = 3,
  smooth = FALSE,
  silent = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ME.fcRegression_MEM_+3A_data.y">data.Y</code></td>
<td>
<p>Response variable, can be an atomic vector, a one-column matrix or data frame,
recommended form is a one-column data frame with column name.</p>
</td></tr>
<tr><td><code id="ME.fcRegression_MEM_+3A_data.w">data.W</code></td>
<td>
<p>A 3-dimensional array, represents <code class="reqn">W</code>, the measurement of <code class="reqn">X</code>.
Each row represents a subject.
Each column represent a measurement (time) point.
Each layer represents an observation.</p>
</td></tr>
<tr><td><code id="ME.fcRegression_MEM_+3A_data.z">data.Z</code></td>
<td>
<p>Scalar covariate(s), can be not input or <code>NULL</code> (when there's no scalar covariate),
an atomic vector (when only one scalar covariate), a matrix or data frame,
recommended form is a data frame with column name(s).</p>
</td></tr>
<tr><td><code id="ME.fcRegression_MEM_+3A_method">method</code></td>
<td>
<p>The method to construct the substitution <code class="reqn">X</code>.
Available options: 'UP_MEM', 'MP_MEM', 'average'.</p>
</td></tr>
<tr><td><code id="ME.fcRegression_MEM_+3A_t_interval">t_interval</code></td>
<td>
<p>A 2-element vector, represents an interval,
means the domain of the functional covariate. Default is c(0,1), represent interval <code class="reqn">[0,1]</code>.</p>
</td></tr>
<tr><td><code id="ME.fcRegression_MEM_+3A_t_points">t_points</code></td>
<td>
<p>Sequence of the measurement (time) points, default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="ME.fcRegression_MEM_+3A_d">d</code></td>
<td>
<p>The number of time points involved for MP_MEM (default and miniumn is 3).</p>
</td></tr>
<tr><td><code id="ME.fcRegression_MEM_+3A_family.w">family.W</code></td>
<td>
<p>Distribution of <code class="reqn">W</code> given <code class="reqn">X</code>,  Available options: &quot;gaussian&quot;,&quot;poisson&quot;.</p>
</td></tr>
<tr><td><code id="ME.fcRegression_MEM_+3A_family.y">family.Y</code></td>
<td>
<p>A description of the error distribution
and link function to be used in the model, see <code><a href="stats.html#topic+family">family</a></code>.</p>
</td></tr>
<tr><td><code id="ME.fcRegression_MEM_+3A_formula.z">formula.Z</code></td>
<td>
<p>A formula without the response variable,
contains only scalar covariate(s), use the format of lme4 package if random effects exist.
e.g. ~ Z_1 + (1|Z_2).
If not assigned, include all scalar covariates and intercept term as fixed effects.</p>
</td></tr>
<tr><td><code id="ME.fcRegression_MEM_+3A_basis.type">basis.type</code></td>
<td>
<p>Type of function basis.
Can only be assigned as one type even if there is more than one functional covariates.
Available options: 'Fourier' or 'Bspline',
represent Fourier basis and b-spline basis respectively.
For the detailed form for Fourier and b-splines basis,
see <code><a href="#topic+fourier_basis_expansion">fourier_basis_expansion</a></code> and <code><a href="#topic+bspline_basis_expansion">bspline_basis_expansion</a></code>.</p>
</td></tr>
<tr><td><code id="ME.fcRegression_MEM_+3A_basis.order">basis.order</code></td>
<td>
<p>Indicate number of the function basis.
When using Fourier basis <code class="reqn">\frac{1}{2},\sin k t, \cos k t, k = 1,\dots,K</code>,
basis.order is the number <code class="reqn">K</code>.
When using b-splines basis <code class="reqn">\{B_{i,p}(x)\}_{i=-p}^{k}</code>, basis.order is the number of splines,
equal to <code class="reqn">k+p+1</code>. (same as arguement <code>df</code> in <code><a href="splines.html#topic+bs">bs</a></code>.)
May set a individual number for each functional covariate.
When the element of this argument is less than the number of functional covariates, it will be used recursively.</p>
</td></tr>
<tr><td><code id="ME.fcRegression_MEM_+3A_bs_degree">bs_degree</code></td>
<td>
<p>Degree of the piecewise polynomials if use b-splines basis, default is 3.
See <code>degree</code> in <code><a href="splines.html#topic+bs">bs</a></code>.</p>
</td></tr>
<tr><td><code id="ME.fcRegression_MEM_+3A_smooth">smooth</code></td>
<td>
<p>Whether to smooth the substitution of <code class="reqn">X</code>. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="ME.fcRegression_MEM_+3A_silent">silent</code></td>
<td>
<p>Whether not to show the state of the running of the function. Default is <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a <code>fcRegression</code> object. See <code><a href="#topic+fcRegression">fcRegression</a></code>.
</p>


<h3>References</h3>

<p>Luan, Yuanyuan, et al. &quot;Scalable regression calibration approaches to
correcting measurement error in multi-level generalized functional linear regression models
with heteroscedastic measurement errors.&quot; arXiv preprint arXiv:2305.12624 (2023).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(MECfda.data.sim.0.1)
res = ME.fcRegression_MEM(data.Y = MECfda.data.sim.0.1$Y,
                          data.W = MECfda.data.sim.0.1$W,
                          data.Z = MECfda.data.sim.0.1$Z,
                          method = 'UP_MEM',
                          family.W = "gaussian",
                          basis.type = 'Bspline')

</code></pre>

<hr>
<h2 id='MECfda_simDataGen_fcReg'>Simulation Data Generation: Scalar-on-function Regression</h2><span id='topic+MECfda_simDataGen_fcReg'></span>

<h3>Description</h3>

<p>Generate data set for scalar-on-function regression
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MECfda_simDataGen_fcReg(
  N = 100,
  distribution = c("Gaussian", "Bernoulli"),
  t_interval,
  t_points,
  n_t = 100,
  seed = 0
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MECfda_simDataGen_fcReg_+3A_n">N</code></td>
<td>
<p>Sample size.</p>
</td></tr>
<tr><td><code id="MECfda_simDataGen_fcReg_+3A_distribution">distribution</code></td>
<td>
<p>Conditional distribution of response varaible given the covariate
(<code class="reqn">Y_i|X_i(t),Z_i</code>).
There are two options: <code>'Gaussian'</code> and <code>'Bernoulli'</code>.</p>
</td></tr>
<tr><td><code id="MECfda_simDataGen_fcReg_+3A_t_interval">t_interval</code></td>
<td>
<p>A 2-element vector, represents an interval,
means the domain of the functional covariate.
Default is <code>c(0,1)</code>, represent interval <code class="reqn">[0,1]</code>.</p>
</td></tr>
<tr><td><code id="MECfda_simDataGen_fcReg_+3A_t_points">t_points</code></td>
<td>
<p>the measurement points of functional variables,
should be numeric vector.</p>
</td></tr>
<tr><td><code id="MECfda_simDataGen_fcReg_+3A_n_t">n_t</code></td>
<td>
<p>Number of measurement time points.
Overwritten if argument <code>t_points</code> is assigned.</p>
</td></tr>
<tr><td><code id="MECfda_simDataGen_fcReg_+3A_seed">seed</code></td>
<td>
<p>Pseudo-random number generation seed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>return a list with following elements.
</p>
<table role = "presentation">
<tr><td><code>Y</code></td>
<td>
<p>An atomic vector of response variable</p>
</td></tr>
<tr><td><code>Z</code></td>
<td>
<p>A dataframe with a binary and a continuous scalar-valued covariate.</p>
</td></tr>
<tr><td><code>FC</code></td>
<td>
<p>A list of two 'functional_variable' class object.</p>
</td></tr>
<tr><td><code>t_interval</code></td>
<td>
<p>Same as in the input argument.</p>
</td></tr>
<tr><td><code>t_points</code></td>
<td>
<p>Sequence of the measurement (time) points.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>dat_sim = MECfda_simDataGen_fcReg(100,"Bernoulli")
res = fcRegression(FC = dat_sim$FC, Y=dat_sim$Y, Z=dat_sim$Z,
                   basis.order = 3, basis.type = c('Fourier'),
                   family = binomial(link = "logit"))
</code></pre>

<hr>
<h2 id='MECfda_simDataGen_ME'>Simulation Data Generation: Measurement Error Bias Correction of Scalar-on-function Regression</h2><span id='topic+MECfda_simDataGen_ME'></span>

<h3>Description</h3>

<p>Generate data set for measurement error bias correction methods
for scalar-on-function regression in package MECfda
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MECfda_simDataGen_ME(
  N = 100,
  J_W = 7,
  forwhich = c("MEM", "IV", "CLS", "IV.SIMEX"),
  t_interval = c(0, 1),
  n_t = 24,
  seed = 0
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MECfda_simDataGen_ME_+3A_n">N</code></td>
<td>
<p>Sample size.</p>
</td></tr>
<tr><td><code id="MECfda_simDataGen_ME_+3A_j_w">J_W</code></td>
<td>
<p>Number of repeated measurement (period), if applicable.</p>
</td></tr>
<tr><td><code id="MECfda_simDataGen_ME_+3A_forwhich">forwhich</code></td>
<td>
<p>For which method of measurement error bias correction method
the data set is generated.
There are two options: 'MEM','IV','CLS','IV.SIMEX'.</p>
</td></tr>
<tr><td><code id="MECfda_simDataGen_ME_+3A_t_interval">t_interval</code></td>
<td>
<p>A 2-element vector, represents an interval,
means the domain of the functional covariate.
Default is <code>c(0,1)</code>, represent interval <code class="reqn">[0,1]</code>.</p>
</td></tr>
<tr><td><code id="MECfda_simDataGen_ME_+3A_n_t">n_t</code></td>
<td>
<p>Number of measurement time points.</p>
</td></tr>
<tr><td><code id="MECfda_simDataGen_ME_+3A_seed">seed</code></td>
<td>
<p>Pseudo-random number generation seed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>return a list that possibly contains following elements.
</p>
<table role = "presentation">
<tr><td><code>Y</code></td>
<td>
<p>An atomic vector of response variable</p>
</td></tr>
<tr><td><code>Z</code></td>
<td>
<p>A dataframe with a binary and a continuous scalar-valued covariate.</p>
</td></tr>
<tr><td><code>W</code></td>
<td>
<p>Observed values of function-valued covariate.</p>
</td></tr>
<tr><td><code>M</code></td>
<td>
<p>Instrumental vairable.</p>
</td></tr>
<tr><td><code>t_interval</code></td>
<td>
<p>Same as in the input argument.</p>
</td></tr>
<tr><td><code>t_points</code></td>
<td>
<p>Sequence of the measurement (time) points.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>for (i in 1:4) {MECfda_simDataGen_ME(forwhich = c('MEM','IV','CLS','IV.SIMEX')[i])}
</code></pre>

<hr>
<h2 id='MECfda.data.sim.0.0'>Simulated data</h2><span id='topic+MECfda.data.sim.0.0'></span>

<h3>Description</h3>

<p>Simulated data
</p>

<hr>
<h2 id='MECfda.data.sim.0.1'>Simulated data</h2><span id='topic+MECfda.data.sim.0.1'></span>

<h3>Description</h3>

<p>Simulated data
</p>

<hr>
<h2 id='MECfda.data.sim.0.2'>Simulated data</h2><span id='topic+MECfda.data.sim.0.2'></span>

<h3>Description</h3>

<p>Simulated data
</p>

<hr>
<h2 id='MECfda.data.sim.0.3'>Simulated data</h2><span id='topic+MECfda.data.sim.0.3'></span>

<h3>Description</h3>

<p>Simulated data
</p>

<hr>
<h2 id='MECfda.data.sim.1.0'>Simulated data</h2><span id='topic+MECfda.data.sim.1.0'></span>

<h3>Description</h3>

<p>Simulated data
</p>

<hr>
<h2 id='MECfda.data.sim.1.1'>Simulated data</h2><span id='topic+MECfda.data.sim.1.1'></span>

<h3>Description</h3>

<p>Simulated data
</p>

<hr>
<h2 id='MECfda.data.sim.1.2'>Simulated data</h2><span id='topic+MECfda.data.sim.1.2'></span>

<h3>Description</h3>

<p>Simulated data
</p>

<hr>
<h2 id='MECfda.data.sim.1.3'>Simulated data</h2><span id='topic+MECfda.data.sim.1.3'></span>

<h3>Description</h3>

<p>Simulated data
</p>

<hr>
<h2 id='MEM_X_hat'>Get MEM substitution for
(generalized) linear regression with one functional covariate with measurement error.</h2><span id='topic+MEM_X_hat'></span>

<h3>Description</h3>

<p>The function to get the data of <code class="reqn">\hat X_i(t)</code> using the mixed model based
measurement error bias correction method
proposed by Luan et al.
See <code><a href="#topic+ME.fcRegression_MEM">ME.fcRegression_MEM</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MEM_X_hat(
  data.W,
  method = c("UP_MEM", "MP_MEM", "average"),
  d = 3,
  family.W = c("gaussian", "poisson"),
  smooth = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MEM_X_hat_+3A_data.w">data.W</code></td>
<td>
<p>A 3-dimensional array, represents <code class="reqn">W</code>, the measurement of <code class="reqn">X</code>.
Each row represents a subject.
Each column represent a measurement (time) point.
Each layer represents an observation.</p>
</td></tr>
<tr><td><code id="MEM_X_hat_+3A_method">method</code></td>
<td>
<p>The method to construct the substitution <code class="reqn">X</code>.
Available options: <code>'UP_MEM'</code>, <code>'MP_MEM'</code>, 'average'.</p>
</td></tr>
<tr><td><code id="MEM_X_hat_+3A_d">d</code></td>
<td>
<p>The number of time points involved for MP_MEM (default and miniumn is 3).</p>
</td></tr>
<tr><td><code id="MEM_X_hat_+3A_family.w">family.W</code></td>
<td>
<p>Distribution of <code class="reqn">W</code> given <code class="reqn">X</code>,  Available options: <code>"gaussian"</code>, <code>"poisson"</code>.</p>
</td></tr>
<tr><td><code id="MEM_X_hat_+3A_smooth">smooth</code></td>
<td>
<p>Whether to smooth the substitution of <code class="reqn">X</code>. Default is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric value matrix of <code class="reqn">\hat X_i(t)</code>.
</p>


<h3>References</h3>

<p>Luan, Yuanyuan, et al. &quot;Scalable regression calibration approaches to
correcting measurement error in multi-level generalized functional linear regression models
with heteroscedastic measurement errors.&quot; arXiv preprint arXiv:2305.12624 (2023).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(MECfda.data.sim.0.1)
X_hat = MEM_X_hat(data.W = MECfda.data.sim.0.1$W,
                  method = 'UP_MEM',
                  family.W = "gaussian")

</code></pre>

<hr>
<h2 id='numeric_basis_expansion'>Numeric basis expansion for functional variable data</h2><span id='topic+numeric_basis_expansion'></span><span id='topic+numeric_basis_expansion+2Cfunctional_variable+2Cnumeric_basis-method'></span>

<h3>Description</h3>

<p>For a function <code class="reqn">f(t), t\in\Omega</code>, and a basis function sequence <code class="reqn">\{\rho_k\}_{k\in\kappa}</code>,
basis expansion is to compute <code class="reqn">\int_\Omega f(t)\rho_k(t) dt</code>.
Here we do basis expansion for all <code class="reqn">f_i(t), t\in\Omega = [t_0,t_0+T]</code> in functional variable data, <code class="reqn">i=1,\dots,n</code>.
We compute a matrix <code class="reqn">(b_{ik})_{n\times p}</code>, where <code class="reqn">b_{ik} = \int_\Omega f(t)\rho_k(t) dt</code>.
The basis we use here is numerically represented by the value of basis functions
at some points in the domain.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>numeric_basis_expansion(object, num_basis)

## S4 method for signature 'functional_variable,numeric_basis'
numeric_basis_expansion(object, num_basis)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="numeric_basis_expansion_+3A_object">object</code></td>
<td>
<p>a <code><a href="#topic+functional_variable">functional_variable</a></code> class object.
The minimum and maximum of the slot <code>t_points</code> should be respectively
equal to the slot <code>t_0</code> and slot <code>t_0</code> plus slot <code>period</code>.</p>
</td></tr>
<tr><td><code id="numeric_basis_expansion_+3A_num_basis">num_basis</code></td>
<td>
<p>a <code>numeric_basis</code> class object, representing the function basis.
See <code><a href="#topic+numeric_basis">numeric_basis</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a numeric matrix, <code class="reqn">(b_{ik})_{n\times p}</code>,
with an extra attribute <code>numeric_basis</code>, which is the <code>numeric_basis</code> object input
by the argument <code>num_basis</code>.
</p>


<h3>Author(s)</h3>

<p>Heyang Ji
</p>

<hr>
<h2 id='numeric_basis-class'>Numeric representation of a function basis</h2><span id='topic+numeric_basis-class'></span><span id='topic+numeric_basis'></span>

<h3>Description</h3>

<p>A s4 class that numerically represents a basis of linear space of function. <br />
<code class="reqn">\{\rho_k\}_{k=1}^\infty</code> denotes a basis of function linear space.
Some times the basis cannot be expressed analytically.
But we can numerically store the space by the value of
a finite subset of the basis functions at some certain points in the domain,
<code class="reqn">\rho_k(t_j), k = 1,\dots,p, j = 1,\dots,m</code>.
The s4 class is to represent a finite sequence of functions by their values
at a finite sequence of points within their domain,
in which all the functions have the same domain and the domain is an interval.
</p>


<h3>Details</h3>

<p>The units of a basis of a linear space should be linearly independent.
But the program doesn't check the linear dependency of the basis function
when a <code>numeric_basis</code> object is initialized.
</p>


<h3>Slots</h3>


<dl>
<dt><code>basis_function</code></dt><dd><p>matrix of the value of the functions,
<code class="reqn">(\zeta_{jk})_{m\times p}</code>,
where <code class="reqn">\zeta_{ik} = \rho_k(t_j), j = 1,\dots,m, k = 1,\dots,p</code>.
Each row of the matrix is corresponding to a point of <code class="reqn">t</code>.
Each column of the matrix is corresponding to a basis function.</p>
</dd>
<dt><code>t_points</code></dt><dd><p>a numeric atomic vector,
represents the points in the domains of the function
where the function values are taken.
The <code class="reqn">j</code>th element is corresponding to <code class="reqn">j</code>th row of
slot <code>basis_function</code>.</p>
</dd>
<dt><code>t_0</code></dt><dd><p>left end of the domain interval.</p>
</dd>
<dt><code>period</code></dt><dd><p>length of the domain interval.</p>
</dd>
</dl>


<h3>Author(s)</h3>

<p>Heyang Ji
</p>


<h3>Examples</h3>

<pre><code class='language-R'>t_0 = 0
period = 1
t_points = seq(0.05,0.95,length.out = 19)
numeric_basis(
  basis_function = cbind(1/2,cos(t_points),sin(t_points)),
  t_points       = t_points,
  t_0            = t_0,
  period         = period
)
</code></pre>

<hr>
<h2 id='numericBasis_series-class'>Linear combination of a sequence of basis functions represented numerically</h2><span id='topic+numericBasis_series-class'></span><span id='topic+numericBasis_series'></span>

<h3>Description</h3>

<p>A linear combination of basis function <code class="reqn">\{\rho_k\}_{k=1}^p</code>,
</p>
<p style="text-align: center;"><code class="reqn">\sum_{k=1}^p c_k \rho_k(t).</code>
</p>



<h3>Slots</h3>


<dl>
<dt><code>coef</code></dt><dd><p>linear coefficient <code class="reqn">\{c_k\}_{k=1}^p</code>.</p>
</dd>
<dt><code>numeric_basis</code></dt><dd><p><code class="reqn">\{\rho_k\}_{k=1}^p</code> represented by a <code>numeric_basis</code> object.
See <code><a href="#topic+numeric_basis">numeric_basis</a></code>.</p>
</dd>
</dl>


<h3>Author(s)</h3>

<p>Heyang Ji
</p>


<h3>Examples</h3>

<pre><code class='language-R'>t_0 = 0
period = 1
t_points = seq(0.05,0.95,length.out = 19)
nb = numeric_basis(
  basis_function = cbind(1,cos(t_points),sin(t_points)),
  t_points       = t_points,
  t_0            = t_0,
  period         = period
)
ns = numericBasis_series(coef = c(0.8,1.2,1.6),numeric_basis = nb)
</code></pre>

<hr>
<h2 id='numericBasisSeries2fun'>Compute the value of the basis function summation series at certain points.</h2><span id='topic+numericBasisSeries2fun'></span><span id='topic+numericBasisSeries2fun+2CnumericBasis_series+2Cnumeric-method'></span>

<h3>Description</h3>

<p>Compute the function <code class="reqn">f(x) = \sum_{k=0}^{p}c_k \rho_{k}(x)</code>, <code class="reqn">x\in\Omega</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>numericBasisSeries2fun(object, x)

## S4 method for signature 'numericBasis_series,numeric'
numericBasisSeries2fun(object, x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="numericBasisSeries2fun_+3A_object">object</code></td>
<td>
<p>an object of <code><a href="#topic+numericBasis_series">numericBasis_series</a></code> class.</p>
</td></tr>
<tr><td><code id="numericBasisSeries2fun_+3A_x">x</code></td>
<td>
<p>Value of $x$.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric atomic vector
</p>


<h3>Author(s)</h3>

<p>Heyang Ji
</p>


<h3>Examples</h3>

<pre><code class='language-R'>t_0 = 0
period = 1
t_points = seq(0.05,0.95,length.out = 19)
nb = numeric_basis(
  basis_function = cbind(1/2,cos(2*pi*t_points),sin(2*pi*t_points)),
  t_points       = t_points,
  t_0            = t_0,
  period         = period
)
ns = numericBasis_series(coef = c(0.8,1.2,1.6),numeric_basis = nb)
numericBasisSeries2fun(ns,seq(0,1,length.out = 51))

</code></pre>

<hr>
<h2 id='plot+2Cbspline_series-method'>Plot b-splines basis summation series.</h2><span id='topic+plot+2Cbspline_series-method'></span>

<h3>Description</h3>

<p>Plot b-splines basis summation series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'bspline_series'
plot(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot+2B2Cbspline_series-method_+3A_x">x</code></td>
<td>
<p>A <code><a href="#topic+bspline_series">bspline_series</a></code> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value. Generate a scatter plot.
</p>


<h3>Author(s)</h3>

<p>Heyang Ji
</p>


<h3>Examples</h3>

<pre><code class='language-R'>bsb = bspline_basis(
Boundary.knots = c(0,24),
intercept      = TRUE,
df             = NULL,
degree         = 3
)
bss = bspline_series(
coef = c(2,1,1.5,3),
bspline_basis = bsb
)
plot(bss)
</code></pre>

<hr>
<h2 id='plot+2CFourier_series-method'>Plot Fourier basis summation series.</h2><span id='topic+plot+2CFourier_series-method'></span>

<h3>Description</h3>

<p>Plot Fourier basis summation series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Fourier_series'
plot(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot+2B2CFourier_series-method_+3A_x">x</code></td>
<td>
<p>A <code><a href="#topic+Fourier_series">Fourier_series</a></code> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value. Generate a scatter plot.
</p>


<h3>Author(s)</h3>

<p>Heyang Ji
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fsc = Fourier_series(
double_constant = 0.5,
cos = c(0,0.3),
sin = c(1,0.7),
k_cos = 1:2,
)
plot(fsc)
</code></pre>

<hr>
<h2 id='plot+2CnumericBasis_series-method'>Plot numeric basis function summation series.</h2><span id='topic+plot+2CnumericBasis_series-method'></span>

<h3>Description</h3>

<p>Plot numeric basis function summation series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'numericBasis_series'
plot(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot+2B2CnumericBasis_series-method_+3A_x">x</code></td>
<td>
<p>A <code><a href="#topic+numericBasis_series">numericBasis_series</a></code> object.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Heyang Ji
</p>


<h3>Examples</h3>

<pre><code class='language-R'>t_0 = 0
period = 1
t_points = seq(0.05,0.95,length.out = 19)
nb = numeric_basis(
  basis_function = cbind(1/2,cos(2*pi*t_points),sin(2*pi*t_points)),
  t_points       = t_points,
  t_0            = t_0,
  period         = period
)
ns = numericBasis_series(coef = c(0.8,1.2,1.6),numeric_basis = nb)
plot(ns)
</code></pre>

<hr>
<h2 id='predict.fcQR'>Predicted values based on fcQR object</h2><span id='topic+predict.fcQR'></span>

<h3>Description</h3>

<p>Predicted values based on the Quantile linear model with functional covariates represented by a &quot;fcQR&quot; class object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fcQR'
predict(object, newData.FC, newData.Z = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict.fcQR_+3A_object">object</code></td>
<td>
<p>A fcQR class object produced by <code><a href="#topic+fcQR">fcQR</a></code>.</p>
</td></tr>
<tr><td><code id="predict.fcQR_+3A_newdata.fc">newData.FC</code></td>
<td>
<p>A atomic vector or a matrix or a dataframe or a functional_variable class object or a list of objects above.
See argument FC in <code><a href="#topic+fcRegression">fcRegression</a></code>.</p>
</td></tr>
<tr><td><code id="predict.fcQR_+3A_newdata.z">newData.Z</code></td>
<td>
<p>A dataframe or a matrix or a atomic vector. See argument Z in <code><a href="#topic+fcRegression">fcRegression</a></code>.</p>
</td></tr>
<tr><td><code id="predict.fcQR_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods <code><a href="quantreg.html#topic+predict.rq">predict.rq</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If no new data is input, will return the fitted value.
</p>


<h3>Value</h3>

<p>See <code><a href="quantreg.html#topic+predict.rq">predict.rq</a></code>.
</p>


<h3>Author(s)</h3>

<p>Heyang Ji
</p>

<hr>
<h2 id='predict.fcRegression'>Predicted values based on fcRegression object</h2><span id='topic+predict.fcRegression'></span>

<h3>Description</h3>

<p>Predicted values based on the linear model with functional covariates represented by a &quot;fcRegression&quot; class object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fcRegression'
predict(object, newData.FC, newData.Z = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict.fcRegression_+3A_object">object</code></td>
<td>
<p>A fcRegression class object produced by <code><a href="#topic+fcRegression">fcRegression</a></code>.</p>
</td></tr>
<tr><td><code id="predict.fcRegression_+3A_newdata.fc">newData.FC</code></td>
<td>
<p>A atomic vector or a matrix or a dataframe or
a functional_variable class object or a list of objects above.
See argument FC in <code><a href="#topic+fcRegression">fcRegression</a></code>.</p>
</td></tr>
<tr><td><code id="predict.fcRegression_+3A_newdata.z">newData.Z</code></td>
<td>
<p>A dataframe or a matrix or a atomic vector.
See arguement Z in <code><a href="#topic+fcRegression">fcRegression</a></code>.</p>
</td></tr>
<tr><td><code id="predict.fcRegression_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods,
including <code><a href="stats.html#topic+predict.lm">predict.lm</a></code>, <code><a href="stats.html#topic+predict.glm">predict.glm</a></code>,
<code><a href="lme4.html#topic+predict.merMod">predict.merMod</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If no new data is input, will return the fitted value.
</p>


<h3>Value</h3>

<p>See <code><a href="stats.html#topic+predict.lm">predict.lm</a></code>, <code><a href="stats.html#topic+predict.glm">predict.glm</a></code>,
<code><a href="lme4.html#topic+predict.merMod">predict.merMod</a></code>.
</p>


<h3>Author(s)</h3>

<p>Heyang Ji
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(MECfda.data.sim.0.0)
res = fcRegression(FC = MECfda.data.sim.0.0$FC, Y=MECfda.data.sim.0.0$Y, Z=MECfda.data.sim.0.0$Z,
                   basis.order = 5, basis.type = c('Bspline'),
                   formula.Z = ~ Z_1 + (1|Z_2))
data(MECfda.data.sim.1.0)
predict(object = res, newData.FC = MECfda.data.sim.1.0$FC,newData.Z = MECfda.data.sim.1.0$Z)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
