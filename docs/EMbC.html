<!DOCTYPE html><html><head><title>Help for package EMbC</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {EMbC}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#binClst_instance'><p>binClst Instance definition</p></a></li>
<li><a href='#binClst-class'><p>Binary Clustering Class</p></a></li>
<li><a href='#binClstPath_instance'><p>binClstPath Instance definition</p></a></li>
<li><a href='#binClstPath-class'><p>Binary Clustering Path Class</p></a></li>
<li><a href='#binClstStck-class'><p>Binary Clustering Stack Class</p></a></li>
<li><a href='#bkml'><p>Generate a burstwise .kml file of a binClstPath_instance.</p></a></li>
<li><a href='#bmap'><p>Generate an HTML burstwise webmap of a binClstPath_instance.</p></a></li>
<li><a href='#chkp'><p>Check labeling profile</p></a></li>
<li><a href='#cnfm'><p>Confusion matrix</p></a></li>
<li><a href='#embc'><p>General pourpose multivariate binary Clustering (EMbC)</p></a></li>
<li><a href='#EMbC-package'><p>Expectation-Maximization binary Clustering package.</p></a></li>
<li><a href='#expth'><p>Synthetic path used in the examples</p></a></li>
<li><a href='#lblp'><p>labeling profile plot</p></a></li>
<li><a href='#lkhp'><p>Likelihood profile plots</p></a></li>
<li><a href='#pkml'><p>Generate a pointwise .kml file of a binClstPath_instance</p></a></li>
<li><a href='#pmap'><p>Generate an HTML pointwise webmap of a binClstPath_instance.</p></a></li>
<li><a href='#rlbl'><p>Manual relabeling of clusters.</p></a></li>
<li><a href='#sct3'><p>Dynamic 3D-scatterplot</p></a></li>
<li><a href='#sctr'><p>Clustering 2D-scatterplot</p></a></li>
<li><a href='#setc'><p>Sets binClst color palette .</p></a></li>
<li><a href='#slct'><p>Select a single path from a <code>binClstStck</code> instance.</p></a></li>
<li><a href='#smth'><p>Posterior smoothing of single local labels.</p></a></li>
<li><a href='#stbc'><p>speed/turn bivariate binary Clustering.</p></a></li>
<li><a href='#stts'><p>Clustering statistics.</p></a></li>
<li><a href='#varp'><p>Variables' profile plots</p></a></li>
<li><a href='#view'><p>Path fast view</p></a></li>
<li><a href='#x2d'><p>Synthetic 2D object used in the examples</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Expectation-Maximization Binary Clustering</td>
</tr>
<tr>
<td>Version:</td>
<td>2.0.4</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-09-26</td>
</tr>
<tr>
<td>Author:</td>
<td>Joan Garriga, John R.B. Palmer, Aitana Oltra, Frederic Bartumeus</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Joan Garriga &lt;jgarriga@ceab.csic.es&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Unsupervised, multivariate, binary clustering for meaningful annotation of data, taking into account the uncertainty in the data. A specific constructor for trajectory analysis in movement ecology yields behavioural annotation of trajectories based on estimated local measures of velocity and turning angle, eventually with solar position covariate as a daytime indicator, ("Expectation-Maximization Binary Clustering for Behavioural Annotation").</td>
</tr>
<tr>
<td>URL:</td>
<td>&lt;doi:10.1371/journal.pone.0151984&gt;</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> | file LICENSE</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 0.11.0), sp, methods, RColorBrewer, mnormt, suntools</td>
</tr>
<tr>
<td>Suggests:</td>
<td>move, sf, rgl, knitr</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-10-03 11:11:25 UTC; jgarriga</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-10-03 13:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='binClst_instance'>binClst Instance definition</h2><span id='topic+binClst_instance'></span>

<h3>Description</h3>

<p>Unless otherwise specified, a <code>binClst</code> instance refers to any of the binary clustering objects defined in the package, either a <code>binClst</code> object itself, or any of its child classes, a <code>binClstPath</code> or a <code>binClstMove</code> instance.  The latter inherit all slots and functionality defined for the former.
</p>

<hr>
<h2 id='binClst-class'>Binary Clustering Class</h2><span id='topic+binClst-class'></span>

<h3>Description</h3>

<p><code>binClst</code> is a generic multivariate binary clustering object.
</p>


<h3>Slots</h3>


<dl>
<dt><code>X</code></dt><dd><p>The input data set. A multivariate matrix where each row is a data point and each column is an input feature (a variable).</p>
</dd>
<dt><code>U</code></dt><dd><p>A multivariate matrix with same dimension as X with the values of certainty associated to each corresponding value in X. Ceartainties assign reliability to the data points so that the less reliable is a data point the less its leverage in the clustering. By default certainties are set to one for all variables of all data points.</p>
</dd>
<dt><code>stdv</code></dt><dd><p>A numeric vector with variable specific values for minimum standard deviation.</p>
</dd>
<dt><code>m</code></dt><dd><p>The number of input features.</p>
</dd>
<dt><code>k</code></dt><dd><p>The number of clusters.</p>
</dd>
<dt><code>n</code></dt><dd><p>The number of observations (data points).</p>
</dd>
<dt><code>R</code></dt><dd><p>A matrix with the values delimiting each binary region (the <code>Reference</code> values).</p>
</dd>
<dt><code>P</code></dt><dd><p>A list with the GMM (Gaussian Mixture Model) parameters. Each element of the list corresponds to a component of the GMM and it is a named-sublist itself, with elements '$M' (the component's mean) and '$S' (the component's covariance matrix).</p>
</dd>
<dt><code>W</code></dt><dd><p>A n*k matrix with the likelihood weights.</p>
</dd>
<dt><code>A</code></dt><dd><p>A numeric vector with the clustering labels (annotations) for each data-point (the basic output data). Labels are assigned based on the likelihood weights. Only in case of equal likelihoods the delimiters are used as a further criterion to assign labels.</p>
</dd>
<dt><code>L</code></dt><dd><p>The values of likelihood at each step of the optimization process.</p>
</dd>
<dt><code>C</code></dt><dd><p>Default color palette used for the plots. Can be changed by means of the setc() function.</p>
</dd>
</dl>

<hr>
<h2 id='binClstPath_instance'>binClstPath Instance definition</h2><span id='topic+binClstPath_instance'></span>

<h3>Description</h3>

<p>Unless otherwise specified, a <code>binClstPath</code> instance refers to a <code>binClstPath</code> object itself, as well as its child class <code>binClstMove</code>. The latter inherits all slots and functionality defined for the former.
</p>

<hr>
<h2 id='binClstPath-class'>Binary Clustering Path Class</h2><span id='topic+binClstPath-class'></span>

<h3>Description</h3>

<p><code>binClstPath</code> is a <code>binClst</code> subclass for fast and easy speed/turn-clustering of movement trajectories. The input trajectory is given as a data.frame with, at least, the columns (timeStamp,longitude,latitude). This format is described in detail in the class constructor <a href="#topic+stbc">stbc</a>. As a <code>binClst</code> subclass, this class inherits all slots and functionality of its parent class.
</p>


<h3>Slots</h3>


<dl>
<dt><code>pth</code></dt><dd><p>A data.frame with the trajectory timestamps and geolocation coordinates, plus eventual extra columns that were included in the input path data frame, (see the <a href="#topic+stbc">stbc</a> constructor).</p>
</dd>
<dt><code>spn</code></dt><dd><p>A numeric vector with the time intervals between locations (in seconds).</p>
</dd>
<dt><code>dst</code></dt><dd><p>A numeric vector with the distances between locations (in meters). We use loxodromic computations.</p>
</dd>
<dt><code>hdg</code></dt><dd><p>A numeric vector with local heading directions (in radians from North). We use loxodromic computations.</p>
</dd>
<dt><code>bursted</code></dt><dd><p>A logical value indicating whether the <code>binClstPath</code> instance has already been bursted. As bursting can be computationally demanding for long trajectories, an instance is bursted only when a burst wise representation of the trajectory' is requested for the first time, (unless this value is changed to FALSE).</p>
</dd>
<dt><code>tracks</code></dt><dd><p>If bursted=TRUE, a <code>SpatialLinesDataFrame</code> object (&quot;sp&quot; R-package) with the bursted track segments.</p>
</dd>
<dt><code>midPoints</code></dt><dd><p>If bursted=TRUE, a <code>SpatialPointsDataFrame</code> object (&quot;sp&quot; R-package) with the bursted track midpoints.</p>
</dd>
</dl>

<hr>
<h2 id='binClstStck-class'>Binary Clustering Stack Class</h2><span id='topic+binClstStck-class'></span>

<h3>Description</h3>

<p><code>binClstStck</code> is a special class for population level speed/turn-clustering of movement trajectories, given either as path data.frames or <code>move</code> objects.
</p>


<h3>Slots</h3>


<dl>
<dt><code>bCS</code></dt><dd><p>A list of either <code>binClstPath</code> or <code>binClstMove</code> objects, depending on how the input paths are given.</p>
</dd>
<dt><code>bC</code></dt><dd><p>A <code>binClst</code> instance with the global speed/turn clustering of the paths in the stack.</p>
</dd>
</dl>

<hr>
<h2 id='bkml'>Generate a burstwise .kml file of a <a href="#topic+binClstPath_instance">binClstPath_instance</a>.</h2><span id='topic+bkml'></span><span id='topic+bkml+2CbinClstPath-method'></span>

<h3>Description</h3>

<p><code>bkml</code> generates a burstwise .kml file of a
<a href="#topic+binClstPath_instance">binClstPath_instance</a>, which can be viewed using Google Earth or
other GIS software. At first issue, this command can take some time because
bursted segmentation has to be computed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bkml(obj, folder = "embcDocs", markerRadius = 15, display = FALSE)

## S4 method for signature 'binClstPath'
bkml(obj, folder = "embcDocs", markerRadius = 15, display = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bkml_+3A_obj">obj</code></td>
<td>
<p>A <a href="#topic+binClstPath_instance">binClstPath_instance</a>.</p>
</td></tr>
<tr><td><code id="bkml_+3A_folder">folder</code></td>
<td>
<p>A character string indicating the name of the folder in which
the .kml file will be saved. If the folder does not exist it is
automatically created, (defaults to '~/embcDocs').</p>
</td></tr>
<tr><td><code id="bkml_+3A_markerradius">markerRadius</code></td>
<td>
<p>A numeric value indicating the radius of the markers to
be plotted, (defaults to 5 pixels).</p>
</td></tr>
<tr><td><code id="bkml_+3A_display">display</code></td>
<td>
<p>A boolean value (defaults to FALSE) to automatically launch
Google-Earth from within R to visualize the generated .kml document.
(Google Earth must already be installed on the system. In Windows, it must
be associated with the .kml file type.)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The path/name of the saved kml file.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pkml">pkml</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# -- apply EMbC to the example path --
mybcp &lt;- stbc(expth,info=-1)
# -- generate a burstwise kml of the output --
bkml(mybcp)

## End(Not run)
</code></pre>

<hr>
<h2 id='bmap'>Generate an HTML burstwise webmap of a <a href="#topic+binClstPath_instance">binClstPath_instance</a>.</h2><span id='topic+bmap'></span><span id='topic+bmap+2CbinClstPath-method'></span>

<h3>Description</h3>

<p><code>bmap</code> generates a burstwise .html file map of a
<a href="#topic+binClstPath_instance">binClstPath_instance</a> in HTML5, using Google Maps JavaScript API v3
(<a href="https://developers.google.com/maps/documentation/javascript/">https://developers.google.com/maps/documentation/javascript/</a>). The
resulting file can be viewed locally in most browsers (an internet
connection is required for displaying the map tiles) or posted online.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bmap(
  obj,
  folder = "embcDocs",
  apiKey = "",
  mapType = "SATELLITE",
  markerRadius = 15,
  display = FALSE
)

## S4 method for signature 'binClstPath'
bmap(
  obj,
  folder = "embcDocs",
  apiKey = "",
  mapType = "SATELLITE",
  markerRadius = 15,
  display = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bmap_+3A_obj">obj</code></td>
<td>
<p>A <a href="#topic+binClstPath_instance">binClstPath_instance</a>.</p>
</td></tr>
<tr><td><code id="bmap_+3A_folder">folder</code></td>
<td>
<p>A character string indicating the name of the folder in which
the .html file will be saved. If the folder does not exist it is
automatically created, (defaults to '~/embcDocs').</p>
</td></tr>
<tr><td><code id="bmap_+3A_apikey">apiKey</code></td>
<td>
<p>A character string specifying the API Key to be passed to the
Google Maps server. No Key is needed for using Google Maps JavaScript API
v3, but users may wish to specify a key in order to monitor web traffic if
the document is being posted online.</p>
</td></tr>
<tr><td><code id="bmap_+3A_maptype">mapType</code></td>
<td>
<p>A character string specifying the type of map to be used in
the background. This value is passed directly to the Google Maps server,
and currently can be set to ROADMAP, SATELLITE, HYBRID, or TERRAIN. (See
the Google Maps API documentation for more information.)</p>
</td></tr>
<tr><td><code id="bmap_+3A_markerradius">markerRadius</code></td>
<td>
<p>A numeric value indicating the radius of the markers to
be plotted, (defaults to 5 pixels).</p>
</td></tr>
<tr><td><code id="bmap_+3A_display">display</code></td>
<td>
<p>A boolean value (defaults to FALSE) to automatically launch
the system's default browser from within R to visualize the generated .html
document.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The path/name of the saved .html file.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# -- apply EMbC to the example path --
mybcp &lt;- stbc(expth,info=-1)
# -- generate a burstwise HTML of the output --
bmap(mybcp)

## End(Not run)
</code></pre>

<hr>
<h2 id='chkp'>Check labeling profile</h2><span id='topic+chkp'></span><span id='topic+chkp+2CbinClst-method'></span>

<h3>Description</h3>

<p>Plots the labeling profile of a
<a href="#topic+binClst_instance">binClst_instance</a> against a control variable (e.g. environmental
information) depicted as background coloured bars.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>chkp(obj, ...)

## S4 method for signature 'binClst'
chkp(obj, ctrlLbls = NULL, ctrlClrs = NULL, ctrlLgnd = NULL, lims = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="chkp_+3A_obj">obj</code></td>
<td>
<p>A <a href="#topic+binClst_instance">binClst_instance</a>.</p>
</td></tr>
<tr><td><code id="chkp_+3A_...">...</code></td>
<td>
<p>Parameters <code>ctrLbls</code>, <code>ctrlClrs</code>, <code>ctrlLgnd</code> and
<code>lims</code> are optional.</p>
</td></tr>
<tr><td><code id="chkp_+3A_ctrllbls">ctrlLbls</code></td>
<td>
<p>A numeric vector with the control labels or a string
specifying one of 'height', 'azimuth' or 'both' solar covariates. By
default, for a <a href="#topic+binClstPath_instance">binClstPath_instance</a> it is set to the solar height
covariate, regardless it has been used or not for the clustering.</p>
</td></tr>
<tr><td><code id="chkp_+3A_ctrlclrs">ctrlClrs</code></td>
<td>
<p>A vector of colors to depict the control labeling. At least
one colour should be specified for each different control label. By default
white/grey colours are used for the default control labels.</p>
</td></tr>
<tr><td><code id="chkp_+3A_ctrllgnd">ctrlLgnd</code></td>
<td>
<p>A vector of strings identifying the labels for the legend of
the plot. They are automatically generated for the solar covariates.</p>
</td></tr>
<tr><td><code id="chkp_+3A_lims">lims</code></td>
<td>
<p>A numeric vector with lower and upper bounds to limit the plot.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># -- apply EMbC to \code{expth} --
mybcp &lt;- stbc(expth)
# -- plot the labeling profile against 'both' solar covariates --
chkp(mybcp,ctrlLbls='both',ctrlClrs=RColorBrewer::brewer.pal(8,'Oranges')[1:4])
</code></pre>

<hr>
<h2 id='cnfm'>Confusion matrix</h2><span id='topic+cnfm'></span><span id='topic+cnfm+2CbinClst+2Cnumeric-method'></span><span id='topic+cnfm+2CbinClstPath+2Cmissing-method'></span><span id='topic+cnfm+2CbinClstStck+2Cmissing-method'></span><span id='topic+cnfm+2CbinClst+2CbinClst-method'></span>

<h3>Description</h3>

<p><code>cnfm</code> computes the confusion matrix of the clustering with
respect to an expert/reference labeling of the data. Also, it can be used
to compare the labelings of two different clusterings of the same
trajectory, (see details).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cnfm(obj, ref, ...)

## S4 method for signature 'binClst,numeric'
cnfm(obj, ref, ret = FALSE, ...)

## S4 method for signature 'binClstPath,missing'
cnfm(obj, ref, ret = FALSE, ...)

## S4 method for signature 'binClstStck,missing'
cnfm(obj, ref, ret = FALSE, ...)

## S4 method for signature 'binClst,binClst'
cnfm(obj, ref, ret = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cnfm_+3A_obj">obj</code></td>
<td>
<p>A <a href="#topic+binClst_instance">binClst_instance</a> or <code>bnClstStck</code> instance.</p>
</td></tr>
<tr><td><code id="cnfm_+3A_ref">ref</code></td>
<td>
<p>A numeric vector with an expert/reference labeling of the data.
</p>
<p>A second <a href="#topic+binClst_instance">binClst_instance</a> (see details).</p>
</td></tr>
<tr><td><code id="cnfm_+3A_...">...</code></td>
<td>
<p>Parameters <code>ref</code> and <code>ret</code> are optional.</p>
</td></tr>
<tr><td><code id="cnfm_+3A_ret">ret</code></td>
<td>
<p>A boolean value (defaults to FALSE). If ret=TRUE the confusion
matrix is returned as a matrix object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The confusion matrix yields marginal counts and Recall for each row, and
marginal counts, Precision and class F-measure for each column. The 3x2
subset of cells at the bottom right show (in this order): the overall
Accuracy, the average Recall, the average Precision, NaN, NaN, and the
overall Macro-F-Measure. The number of classes (expert/reference labeling)
should match or, at least not be greater than the number of clusters. The
overall value of the Macro-F-Measure is an average of the class F-measure
values, hence it is underestimated if the number of classes is lower than the
number of clusters.
</p>
<p>If <code>obj</code> is a <a href="#topic+binClstPath_instance">binClstPath_instance</a> and there is a column &quot;lbl&quot; in
the obj@pth slot with an expert labeling, this labeling will be used by
default.
</p>
<p>If <code>obj</code> is a <code>binClstStck</code> instance and, for all paths in the
stack, there is a column &quot;lbl&quot; in the obj@pth slot of each, this labeling
will be used to compute the confusion matrix for the whole stack.
</p>
<p>If <code>obj</code> and <code>ref</code> are both a <a href="#topic+binClst_instance">binClst_instance</a> (e.g.
smoothed versus non-smoothed), the confusion matrix compares both labelings.
</p>


<h3>Value</h3>

<p>If ret=TRUE returns a matrix with the confusion matrix values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># -- apply EMbC to the example path --
mybcp &lt;- stbc(expth,info=-1)
# -- compute the confusion matrix --
cnfm(mybcp,expth$lbl)
# -- as we have expth$lbl the following also works --
cnfm(mybcp,mybcp@pth$lbl)
# -- or simply --
cnfm(mybcp)
# -- numerical differences with respect to the smoothed clustering --
cnfm(mybcp,smth(mybcp))
</code></pre>

<hr>
<h2 id='embc'>General pourpose multivariate binary Clustering (EMbC)</h2><span id='topic+embc'></span>

<h3>Description</h3>

<p><code>embc</code> implements the core function of the Expectation-Maximization multivariate binary clustering.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>embc(X, U = NULL, stdv = NULL, maxItr = 200, info = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="embc_+3A_x">X</code></td>
<td>
<p>The input data set. A multivariate matrix where each row is a data point and each column is an input feature (a variable).</p>
</td></tr>
<tr><td><code id="embc_+3A_u">U</code></td>
<td>
<p>A multivariate matrix with same dimension as X with the values of certainty associated to each corresponding value in X. Certainties assign reliability to the data points so that the less reliable is a data point the less its leverage in the clustering. By default certainties are set to one (no uncertainty in any value in X).</p>
</td></tr>
<tr><td><code id="embc_+3A_stdv">stdv</code></td>
<td>
<p>a vector with bounds for the maximum precision of clusters, given as minimum standard deviation for each variable, (by default is set to rep(sqrt(.Machine$double.eps),ncol(X))</p>
</td></tr>
<tr><td><code id="embc_+3A_maxitr">maxItr</code></td>
<td>
<p>A limit to the number of iterations in case of slow convergence (defaults to 200).</p>
</td></tr>
<tr><td><code id="embc_+3A_info">info</code></td>
<td>
<p>Level of information shown at each step:
info=0 (default) shows step likelihood, number of clusters, and number of changing labels;
info=1, include clustering statistics;
info=2, include delimiters information;
info&lt;0, suppress any step information.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a binClst object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# -- apply EMbC to the example set of data points x2d ---
mybc &lt;- embc(x2d@D)
</code></pre>

<hr>
<h2 id='EMbC-package'>Expectation-Maximization binary Clustering package.</h2><span id='topic+EMbC-package'></span><span id='topic+EMbC'></span>

<h3>Description</h3>

<p>The Expectation-maximization binary clustering (EMbC) is a general purpose,
unsupervised, multi-variate, clustering algorithm, driven by two main
motivations: (i) it looks for a good compromise between statistical soundness
and ease and generality of use - by minimizing prior assumptions and favouring
the semantic interpretation of the final clustering - and, (ii) it allows
taking into account the uncertainty in the data. These features make it
specially suitable for the behavioural annotation of animal's movement
trajectories.
</p>


<h3>Details</h3>

<p>The method is a variant of the well sounded Expectation-Maximization
Clustering (EMC) algorithm, - i.e. under the assumption of an underlying
Gaussian Mixture Model (GMM) describing the distribution of the data-set - but
constrained to generate a binary partition of the input space. This is achieved by
means of the *delimiters*, a set of parameters that discretizes the input features
into high and low values and define the binary regions of the input space.
As a result, each final cluster includes a unique  combination of either
low or high values of the input variables. Splitting the input features
into low and high values is what favours the semantic interpretation of the final
clustering.
</p>
<p>The  initial assumptions implemented in the EMbC algorithm aim at minimizing biases
and sensitivity to initial conditions: (i) each data point is assigned a uniform
probability of belonging to each cluster, (ii) the  prior mixture distribution  is
uniform (each  cluster starts with the  same number of  data points), (iii) the
starting partition, (*i.e.* initial delimiters position),  is selected  based
on  a global maximum  variance criterion,  thus conveying  the minimum  information
possible.
</p>
<p>The number of output clusters is $2^m$ determined by the number of input features
$m$. This number is only an upper bound as some of the clusters can be merged along
the likelihood optimization process. The EMbC algorithm is intended to be used with
not more than 5 or 6 input features, yielding a maximum of 32 or 64 clusters. This
limitation in the number of clusters is consistent with the main motivation of the
algorithm of favouring the semantic interpretation of the results.
</p>
<p>The algorithm deals very intuitively with data reliability: the larger the
uncertainty associated with a data point, the  smaller the leverage of that data
point in the clustering.
</p>
<p>Compared to close related methods like EMC and Hidden Markov Models (HMM),
the EMbC is specially useful when: (i) we can expect bi-modality, to some extent,
in the conditional distribution of the input features or, at least, we can assume
that a binary partition of the input space can provide useful information, and
(ii) a first order temporal dependence assumption, a necessary condition in HMM,
can not be guaranteed.
</p>
<p>The EMbC R-package is mainly intended for the behavioural annotation of animals'
movement trajectories where an easy interpretation of the final clustering and the
reliability of the data constitute two key issues, and the conditions of bi-modality
and unfair temporal dependence usually hold. In particular, the temporal dependence
condition is easily violated in animal's movement trajectories because of the
heterogeneity in empirical time series due to large gaps, or prefixed sampling
scheduling.
</p>
<p>Input movement trajectories are given either as a *data.frame* or a *Move* object
from the **move** R-package.  The package deals also with stacks of trajectories for
population level analysis. Segmentation is based on local estimates of velocity and
turning angle, eventually including a solar position covariate as a daytime
indicator.
</p>
<p>The core clustering method is complemented with a set of functions to easily
visualize and analyze the output:
</p>
<p>* clustering statistics,
* clustering scatterplot (2D and 3D)
* temporal labeling profile (ethogram),
* plotting of intermediate variables,
* confusion matrix (numerical validation with respect to an expert's labeling),
* visual validation with external information (e.g. environmental data),
* generation of kml or webmap docs for detailed inspection of the output.
</p>
<p>Also, some functions are provided to further refine the output, either by
pre-processing (smoothing) the input data or by post-processing (smoothing,
relabeling, merging) the output labeling.
</p>
<p>The results obtained for different empirical datasets suggest that the EMbC
algorithm  behaves reasonably well for a wide range  of tracking technologies,
species, and ecological contexts (e.g. migration, foraging).
</p>


<h3>Author(s)</h3>

<p>Joan Garriga <a href="mailto:jgarriga@ceab.csic.es">jgarriga@ceab.csic.es</a>
</p>

<hr>
<h2 id='expth'>Synthetic path used in the examples</h2><span id='topic+expth'></span>

<h3>Description</h3>

<p>A data.frame with a synthetically generated trajectory with column values (timeStamps, longitudes, latitudes, labels) and column headers ('dTm','lon','lat','lbl'). The order of the columns is important. Column headers can be whatever but are expected to be there. The only exception is the header for the labels column: if headed as 'lbl' it will be used automatically by any methods that can make use of it.
</p>


<h3>Format</h3>

<p>See parameter <code>pth</code> of the <a href="#topic+stbc">stbc</a> constructor.
</p>

<hr>
<h2 id='lblp'>labeling profile plot</h2><span id='topic+lblp'></span><span id='topic+lblp+2CbinClst+2Cmissing-method'></span><span id='topic+lblp+2CbinClstStck+2Cmissing-method'></span><span id='topic+lblp+2CbinClst+2Cnumeric-method'></span><span id='topic+lblp+2CbinClst+2CbinClst-method'></span>

<h3>Description</h3>

<p><code>lblp</code> plots the labeling profile of a
<a href="#topic+binClst_instance">binClst_instance</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lblp(obj, ref, ...)

## S4 method for signature 'binClst,missing'
lblp(obj, ref, lims = NULL, ...)

## S4 method for signature 'binClstStck,missing'
lblp(obj, ref, lims = NULL, ...)

## S4 method for signature 'binClst,numeric'
lblp(obj, ref, lims = NULL, ...)

## S4 method for signature 'binClst,binClst'
lblp(obj, ref, lims = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lblp_+3A_obj">obj</code></td>
<td>
<p>A <a href="#topic+binClst_instance">binClst_instance</a>.</p>
</td></tr>
<tr><td><code id="lblp_+3A_ref">ref</code></td>
<td>
<p>A numeric vector with an expert's labeling profile.
</p>
<p>A second <a href="#topic+binClst_instance">binClst_instance</a> to be compared with the first.</p>
</td></tr>
<tr><td><code id="lblp_+3A_...">...</code></td>
<td>
<p>Parameters <code>ref</code> and <code>lims</code> are optional.</p>
</td></tr>
<tr><td><code id="lblp_+3A_lims">lims</code></td>
<td>
<p>A numeric vector with lower and upper bounds to limit the plot.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># -- apply EMbC to the example path --
mybcp &lt;- stbc(expth)
# -- plot the labeling profile comparing with expert labeling --
lblp(mybcp,expth$lbl)
# -- compare original and smoothed labeling profiles --
lblp(mybcp,smth(mybcp))
</code></pre>

<hr>
<h2 id='lkhp'>Likelihood profile plots</h2><span id='topic+lkhp'></span><span id='topic+lkhp+2CbinClst-method'></span><span id='topic+lkhp+2Clist-method'></span>

<h3>Description</h3>

<p><code>lkhp</code> likelihood optimization plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lkhp(obj, offSet = 1)

## S4 method for signature 'binClst'
lkhp(obj, offSet = 1)

## S4 method for signature 'list'
lkhp(obj, offSet = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lkhp_+3A_obj">obj</code></td>
<td>
<p>A <code>BinClst_instance</code> or a list of them.</p>
</td></tr>
<tr><td><code id="lkhp_+3A_offset">offSet</code></td>
<td>
<p>A numeric value indicating an offset to avoid the initial
iterations. This is useful to see the likelihood evolution in the last
iterations where the changes in likelihood are of different order of
magnitude than those at the starting iterations.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># -- apply EMbC to the example path --
mybcp &lt;- stbc(expth)
# -- inspect the likelihood evolution --
lkhp(mybcp)
# -- avoid the initial values --
lkhp(mybcp,10)
</code></pre>

<hr>
<h2 id='pkml'>Generate a pointwise .kml file of a <a href="#topic+binClstPath_instance">binClstPath_instance</a></h2><span id='topic+pkml'></span><span id='topic+pkml+2CbinClstPath-method'></span>

<h3>Description</h3>

<p><code>pkml</code> generates a pointwise KML file of a
<a href="#topic+binClstPath_instance">binClstPath_instance</a>, which can be viewed using Google Earth or
other GIS software.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pkml(obj, folder = "embcDocs", markerRadius = 15, display = FALSE, ...)

## S4 method for signature 'binClstPath'
pkml(obj, folder, markerRadius, display, showClst = numeric(), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pkml_+3A_obj">obj</code></td>
<td>
<p>A <a href="#topic+binClstPath_instance">binClstPath_instance</a>.</p>
</td></tr>
<tr><td><code id="pkml_+3A_folder">folder</code></td>
<td>
<p>A character string indicating the name of the folder in which
the .kml file will be saved. If the folder does not exist it is
automatically created, (defaults to '~/embcDocs').</p>
</td></tr>
<tr><td><code id="pkml_+3A_markerradius">markerRadius</code></td>
<td>
<p>A numeric value indicating the radius of the markers to
be plotted, (defaults to 5 pixels).</p>
</td></tr>
<tr><td><code id="pkml_+3A_display">display</code></td>
<td>
<p>A boolean value (defaults to FALSE) to automatically launch
Google-Earth from within R to visualize the generated .kml document.
(Google Earth must already be installed on the system. In Windows, it must
be associated with the .kml file type.)</p>
</td></tr>
<tr><td><code id="pkml_+3A_...">...</code></td>
<td>
<p>Parameters <code>folder</code>, <code>markerRadius</code>, <code>display</code> and
<code>showClst</code> are optional.</p>
</td></tr>
<tr><td><code id="pkml_+3A_showclst">showClst</code></td>
<td>
<p>A numeric vector indicating a subset of clusters to be shown.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The path/name of the saved kml file.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bkml">bkml</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# -- apply EMbC to the example path --
mybcp &lt;- stbc(expth,info=-1)
# -- generate a pointwise .kml of the output --
pkml(mybcp)
# -- show only stopovers and automatically display the .kml document --
pkml(mybcp,showClst=c(1,2),display=TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='pmap'>Generate an HTML pointwise webmap of a <a href="#topic+binClstPath_instance">binClstPath_instance</a>.</h2><span id='topic+pmap'></span><span id='topic+pmap+2CbinClstPath-method'></span>

<h3>Description</h3>

<p><code>pmap</code> generates a pointwise .html file-map of a
<a href="#topic+binClstPath_instance">binClstPath_instance</a> in HTML5, using Google Maps JavaScript API v3
(<a href="https://developers.google.com/maps/documentation/javascript/">https://developers.google.com/maps/documentation/javascript/</a>). The
resulting file can be viewed locally in most browsers (an internet
connection is required for displaying the map tiles) or posted online.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pmap(
  obj,
  folder = "embcDocs",
  apiKey = "",
  mapType = "SATELLITE",
  markerRadius = 15,
  display = FALSE
)

## S4 method for signature 'binClstPath'
pmap(
  obj,
  folder = "embcDocs",
  apiKey = "",
  mapType = "SATELLITE",
  markerRadius = 15,
  display = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pmap_+3A_obj">obj</code></td>
<td>
<p>A <a href="#topic+binClstPath_instance">binClstPath_instance</a>.</p>
</td></tr>
<tr><td><code id="pmap_+3A_folder">folder</code></td>
<td>
<p>A character string indicating the name of the folder in which
the .html file will be saved. If the folder does not exist it is
automatically created, (defaults to '~/embcDocs').</p>
</td></tr>
<tr><td><code id="pmap_+3A_apikey">apiKey</code></td>
<td>
<p>A character string specifying the API Key to be passed to the
Google Maps server. No Key is needed for using Google Maps JavaScript API
v3, but users may wish to specify a key in order to monitor web traffic if
the document is being posted online.</p>
</td></tr>
<tr><td><code id="pmap_+3A_maptype">mapType</code></td>
<td>
<p>A character string specifying the type of map to be used in
the background. This value is passed directly to the Google Maps server,
and currently can be set to ROADMAP, SATELLITE, HYBRID, or TERRAIN. (See
the Google Maps API documentation for more information.)</p>
</td></tr>
<tr><td><code id="pmap_+3A_markerradius">markerRadius</code></td>
<td>
<p>A numeric value indicating the radius of the markers to
be plotted, (defaults to 5 pixels).</p>
</td></tr>
<tr><td><code id="pmap_+3A_display">display</code></td>
<td>
<p>A boolean value (defaults to FALSE) to automatically launch
the system's default browser from within R to visualize the generated .html
document.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The path/name of the saved html file.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# -- apply EMbC to the example path --
mybcp &lt;- stbc(expth,info=-1)
# -- generate a pointwise HTML of the output --
pmap(mybcp)

## End(Not run)
</code></pre>

<hr>
<h2 id='rlbl'>Manual relabeling of clusters.</h2><span id='topic+rlbl'></span><span id='topic+rlbl+2CbinClst-method'></span>

<h3>Description</h3>

<p><code>rlbl</code> Manual relabeling of clusters (to merge clusters or
relabel merged clusters).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rlbl(obj, old = 0, new = 0, reset = FALSE)

## S4 method for signature 'binClst'
rlbl(obj, old = 0, new = 0, reset = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rlbl_+3A_obj">obj</code></td>
<td>
<p>A <a href="#topic+binClst_instance">binClst_instance</a>.</p>
</td></tr>
<tr><td><code id="rlbl_+3A_old">old</code></td>
<td>
<p>The number of the cluster to be relabeled.</p>
</td></tr>
<tr><td><code id="rlbl_+3A_new">new</code></td>
<td>
<p>The new number of the cluster.</p>
</td></tr>
<tr><td><code id="rlbl_+3A_reset">reset</code></td>
<td>
<p>A boolean value (defaults to FALSE). If reset=TRUE the labeling
is reset to the original state.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Whenever two adjacent clusters are merged, the label identifying the
splitting variable between them both is meaningless, and the algorithm ends
up assigning either a L or H only depending on how it evolved until reaching
the merging point. Thus it can happen that the final labeling of the
resulting cluster is not the most intuitive one. With this method the labels
can be changed as desired. It can also be used to manually force the merging
of two clusters.
</p>
<p>This method does not return a relabeled copy of the input <code>obj</code>,
instead the <a href="#topic+binClst_instance">binClst_instance</a> itself is relabeled. However, this is
intended only for output and visualization purposes (sctr(), lblp(),
cnfm(), view()) as the <a href="#topic+binClst_instance">binClst_instance</a> parameters (GMM parameters and
binary delimiters) are not recomputed. Thus the input instance can always be
reset to its original state.
</p>


<h3>Value</h3>

<p>This method does not return a relabeled copy of the input
<code>obj</code>, instead the <a href="#topic+binClst_instance">binClst_instance</a> itself is relabeled. It is
intended only for visualization purposes, as it does not recompute the GMM
parameters nor the binary delimiters of the <a href="#topic+binClst_instance">binClst_instance</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># -- apply EMbC to the example path --
mybcp &lt;- stbc(expth,info=-1)
# -- manually merge clusters 1 and 2 --
rlbl(mybcp,1,2)
# -- reset to the original state --
rlbl(mybcp,reset=TRUE)
</code></pre>

<hr>
<h2 id='sct3'>Dynamic 3D-scatterplot</h2><span id='topic+sct3'></span><span id='topic+sct3+2CbinClst-method'></span>

<h3>Description</h3>

<p><code>sct3</code> generates a dynamic 3D-scatterplot of a multivariate
<a href="#topic+binClst_instance">binClst_instance</a>, showing clusters in different colors. The scatter
plot can be zoomed/rotated with the mouse.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sct3(obj, ...)

## S4 method for signature 'binClst'
sct3(obj, showVars = NULL, showClst = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sct3_+3A_obj">obj</code></td>
<td>
<p>A <a href="#topic+binClst_instance">binClst_instance</a>.</p>
</td></tr>
<tr><td><code id="sct3_+3A_...">...</code></td>
<td>
<p>Parameters <code>ref</code>, <code>showVars</code> and <code>showClst</code> are
optional.</p>
</td></tr>
<tr><td><code id="sct3_+3A_showvars">showVars</code></td>
<td>
<p>When the number of variables is greater than two, a length 3
numeric vector indicating one splitting variable and two variables to be
scattered (given in that order).</p>
</td></tr>
<tr><td><code id="sct3_+3A_showclst">showClst</code></td>
<td>
<p>When the number of variables is greater than two, a numeric
vector (of variable length) indicating a subset of the clusters that will
be shown in the scatter plot. This is useful in case of overlapping
clusters.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function needs the package &quot;rgl&quot; to be installed.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# -- apply EMbC to the example path with scv='height' --
mybcp &lt;- stbc(expth,scv='height')
# -- show a dynamic 3D-scatterplot --
sct3(mybcp)
# -- show only a subset of clusters --
sct3(mybcp,showClst=c(2,4,6))

## End(Not run)
</code></pre>

<hr>
<h2 id='sctr'>Clustering 2D-scatterplot</h2><span id='topic+sctr'></span><span id='topic+sctr+2CbinClst-method'></span><span id='topic+sctr+2CbinClstStck-method'></span>

<h3>Description</h3>

<p><code>sctr</code> generates a scatterplot from a
<a href="#topic+binClst_instance">binClst_instance</a>, showing clusters in different colors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sctr(obj, ...)

## S4 method for signature 'binClst'
sctr(obj, ref = NULL, showVars = NULL, showClst = NULL, bg = NULL, ...)

## S4 method for signature 'binClstStck'
sctr(obj, ref = NULL, showVars = NULL, showClst = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sctr_+3A_obj">obj</code></td>
<td>
<p>A <a href="#topic+binClst_instance">binClst_instance</a>.</p>
</td></tr>
<tr><td><code id="sctr_+3A_...">...</code></td>
<td>
<p>Parameters <code>ref</code>, <code>showVars</code> and <code>showClst</code> are
optional.</p>
</td></tr>
<tr><td><code id="sctr_+3A_ref">ref</code></td>
<td>
<p>A numeric vector with expert/reference labeling for visual validation of
the clustering.
</p>
<p>A second <a href="#topic+binClst_instance">binClst_instance</a> to be compared with the former.</p>
</td></tr>
<tr><td><code id="sctr_+3A_showvars">showVars</code></td>
<td>
<p>When the number of variables is greater than two, a length 3
numeric vector indicating one splitting variable and two variables to be
scattered (given in that order).</p>
</td></tr>
<tr><td><code id="sctr_+3A_showclst">showClst</code></td>
<td>
<p>When the number of variables is greater than two, a numeric
vector (of variable length) indicating a subset of the clusters that will
be shown in the scatter plot. This is useful in case of overlapping
clusters.</p>
</td></tr>
<tr><td><code id="sctr_+3A_bg">bg</code></td>
<td>
<p>A valid colour to be used as background colour for multivariate scatterplots. By default a light-grey colour is used to enhance data points visibility.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># -- apply EMbC to the example path --
mybcp &lt;- stbc(expth,info=-1)
# -- show the scatterplot compared with expert labeling--
sctr(mybcp,expth$lbl)
</code></pre>

<hr>
<h2 id='setc'>Sets binClst color palette .</h2><span id='topic+setc'></span>

<h3>Description</h3>

<p><code>setc</code> sets the color palette to a color family from the
RColorbrewer package
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setc(bC, fam = "RdYlBu")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setc_+3A_bc">bC</code></td>
<td>
<p>A <a href="#topic+binClst_instance">binClst_instance</a>.</p>
</td></tr>
<tr><td><code id="setc_+3A_fam">fam</code></td>
<td>
<p>The name of a color family from the Rcolorbrewer R-package,
(default color palette is 'RdYlBu' which is colorblind safe and print
friendly up to 6 colors).</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># -- change the color palette of mybc to "PuOr" --
## Not run: 
setc(mybc,'PuOr')

## End(Not run)
</code></pre>

<hr>
<h2 id='slct'>Select a single path from a <code>binClstStck</code> instance.</h2><span id='topic+slct'></span>

<h3>Description</h3>

<p><code>slct</code> selects a single path from a <code>binClstStck</code>
instance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>slct(stck, pathNmbr)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="slct_+3A_stck">stck</code></td>
<td>
<p>A <code>binClstStck</code> instance.</p>
</td></tr>
<tr><td><code id="slct_+3A_pathnmbr">pathNmbr</code></td>
<td>
<p>The number of the single path to be selected.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the single <a href="#topic+binClstPath_instance">binClstPath_instance</a> selected.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# -- select path number 3 in mybcpstack --
bcp3 &lt;- slct(mybcpstack,3)

## End(Not run)
</code></pre>

<hr>
<h2 id='smth'>Posterior smoothing of single local labels.</h2><span id='topic+smth'></span><span id='topic+smth+2CbinClst-method'></span><span id='topic+smth+2CbinClstStck-method'></span>

<h3>Description</h3>

<p><code>smth</code> Performs a posterior smoothing of single local
labels (locations that differ from their neighbouring locations while the
later have equal labels).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>smth(obj, dlta = 1)

## S4 method for signature 'binClst'
smth(obj, dlta = 1)

## S4 method for signature 'binClstStck'
smth(obj, dlta = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="smth_+3A_obj">obj</code></td>
<td>
<p>Either a <code>binClst_instance</code> or a <code>binClstStck_instance</code>.</p>
</td></tr>
<tr><td><code id="smth_+3A_dlta">dlta</code></td>
<td>
<p>A numeric value in the range (0,1) (default is 1) indicating the
user's will to accept a change of label. The change of label is done
whenever the decrease in likelihood is not greater then <code>dlta</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A smoothed copy of the input instance. In the case of a
<code>binClstStck_instance</code> smoothing is performed at population level
as well as at each individual trajectory in the stack.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># -- cluster the example path with a prior smooth of 1 hour --
mysmoothbcp &lt;- stbc(expth,smth=1,info=-1)
# -- apply a posterior smoothing --
mysmoothbcpsmoothed &lt;- smth(mysmoothbcp,dlta=0.5)
</code></pre>

<hr>
<h2 id='stbc'>speed/turn bivariate binary Clustering.</h2><span id='topic+stbc'></span>

<h3>Description</h3>

<p><code>stbc</code> is a specific constructor for movement ecology pourposes. By default it implements a bivariate (speed/turn) clustering for behavioural annotation of animals' movement trajectories. Alternatively, it can perform a trivariate clustering by including the solar position covariate (i.e. solar height or solar azimuth) as a daytime indicator.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stbc(
  obj,
  stdv = c(0.1, 5 * pi/180),
  spdLim = 40,
  smth = 0,
  scv = "None",
  maxItr = 200,
  info = 0
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stbc_+3A_obj">obj</code></td>
<td>
<p>A <code>data.frame</code> object with (timeStamp,lon,lat) values in columns 1:3 respectively. Timestamps must be given
as.POSIXct() with specific format &quot;%Y-%m-%d %H:%M:%S&quot;. Further columns of associated data are allowed and will be included in the <a href="#topic+binClstPath_instance">binClstPath_instance</a> @pth slot.
</p>
<p>A <code>Move</code> object from the &quot;move&quot; R-package.
</p>
<p>A <code>list</code> of trajectories given either as <code>data.frame</code> or <code>Move</code> objects, to perform a joined clustering of all of them. This is mainly intended to perform analysis at population level.</p>
</td></tr>
<tr><td><code id="stbc_+3A_stdv">stdv</code></td>
<td>
<p>a vector with bounds for the maximum precision of clusters, given as minimum standard deviation for each variable, (by default is set to 0.1 m/s for velocities and 5 degrees for turns).</p>
</td></tr>
<tr><td><code id="stbc_+3A_spdlim">spdLim</code></td>
<td>
<p>A speed limit for automatic detection of outliers. Trajectory locations with associated values of speed above
the spdLim are not eliminated but will play no part in the clustering. By default is set to 40 m/s.</p>
</td></tr>
<tr><td><code id="stbc_+3A_smth">smth</code></td>
<td>
<p>A smoothing time interval in hours. This is used to estimate local values of speed and turn computed as an average over a time window centered at each location.</p>
</td></tr>
<tr><td><code id="stbc_+3A_scv">scv</code></td>
<td>
<p>A solar position covariate to be used as a daytime indicator. It can be either 'height' (the solar height in degrees above the horizon) or 'azimuth' (the solar azimuth in degrees from north). If it is used, a trivariate clustering is performed, increasing to a maximum of 8 the number of clusters (behaviours) that can potentially be identified. By default this value is set to None (i.e. perform the standard bivariate speed/turn clustering).</p>
</td></tr>
<tr><td><code id="stbc_+3A_maxitr">maxItr</code></td>
<td>
<p>A limit to the number of iterations in case of slow convergence (defaults to 200).</p>
</td></tr>
<tr><td><code id="stbc_+3A_info">info</code></td>
<td>
<p>Level of information shown at each step:
info=0 (default) shows step likelihood, number of clusters, and number of changing labels;
info=1, include clustering statistics;
info=2, include delimiters information;
info&lt;0, suppress any step information.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a binClstPath object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># -- apply EMbC to the example path --
mybcp &lt;- stbc(expth)
## Not run: 
# --- binary clustering of a Move object ---
require(move)
mybcm &lt;- stbc(move(system.file("extdata","leroy.csv.gz",package="move")))
# --- binary clustering of a stack of trajetories ---
mybcm &lt;- stbc(list(mypth1,mypth2,mypth3))

## End(Not run)
</code></pre>

<hr>
<h2 id='stts'>Clustering statistics.</h2><span id='topic+stts'></span><span id='topic+stts+2CbinClst-method'></span><span id='topic+stts+2CbinClstStck-method'></span>

<h3>Description</h3>

<p><code>stts</code> clustering statistics information.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stts(obj, dec = 2, width = 8)

## S4 method for signature 'binClst'
stts(obj, dec = 2, width = 8)

## S4 method for signature 'binClstStck'
stts(obj, dec = 2, width = 8)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stts_+3A_obj">obj</code></td>
<td>
<p>Either a <a href="#topic+binClst_instance">binClst_instance</a> or a <code>binClstStck</code> instance.
In the latter case statistics are given at stack level.</p>
</td></tr>
<tr><td><code id="stts_+3A_dec">dec</code></td>
<td>
<p>The number of decimals for mean/stdv formatting.</p>
</td></tr>
<tr><td><code id="stts_+3A_width">width</code></td>
<td>
<p>The number of digits for mean/stdv formatting.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This method prints a line for each cluster with the following information:
the cluster number, the cluster binary label, the cluster mean and variance
of each input feature (two columns for each variable), and the size of the
cluster in number and proportion of points (the posterior marginal
distribution).
</p>


<h3>Examples</h3>

<pre><code class='language-R'># -- apply EMbC to the example path with solar covariate 'height'--
mybcp &lt;- stbc(expth,scv='height',info=-1)
# -- show clustering statistics --
stts(mybcp,width=5,dec=1)
## Not run: 
# -- show clustering statistics of mybcpstack at stack level --
stts(mybcpstack)
# -- show individual statistics for path number 3 in mybcpstack --
stts(slct(mybcpstack,3))

## End(Not run)
</code></pre>

<hr>
<h2 id='varp'>Variables' profile plots</h2><span id='topic+varp'></span><span id='topic+varp+2CbinClstPath-method'></span><span id='topic+varp+2Cmatrix-method'></span>

<h3>Description</h3>

<p><code>varp</code> easy plot of input, output and intermediate
variables of a <a href="#topic+binClstPath_instance">binClstPath_instance</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>varp(obj, ...)

## S4 method for signature 'binClstPath'
varp(obj, lims = NULL, ...)

## S4 method for signature 'matrix'
varp(obj, lims = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="varp_+3A_obj">obj</code></td>
<td>
<p>Either a matrix or a  <a href="#topic+binClstPath_instance">binClstPath_instance</a>.</p>
</td></tr>
<tr><td><code id="varp_+3A_...">...</code></td>
<td>
<p>Parameter <code>lims</code> is optional.</p>
</td></tr>
<tr><td><code id="varp_+3A_lims">lims</code></td>
<td>
<p>A numeric vector with lower and upper bounds to limit the plot.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>obj</code> is a matrix, axes labels are automatically generated from the
<code>colnames()</code> of the matrix, hence they can be changed as desired.
</p>
<p>If <code>obj</code> is a <a href="#topic+binClstPath_instance">binClstPath_instance</a> it plots the values of the
intermediate computations saved in slots mybcp@spn (span times), mybcp@dst
(distances) and mybcp@hdg (local heading directions).
</p>


<h3>Examples</h3>

<pre><code class='language-R'># -- apply EMbC to the example path --
mybcp &lt;- stbc(expth,info=-1)
# -- plot clustering data points --
varp(mybcp@X)
# -- plot data points' certainties --
varp(mybcp@U)
# -- plot intermediate computations (span-times, distances and headings) in one figure --
varp(mybcp)
## Not run: 
# -- plot only span-times between locations a and b --
plot(seq(a,b),mybcp@spn[a:b],col=4,type='l',xlab='loc',ylab='spanTime (s)')

## End(Not run)
</code></pre>

<hr>
<h2 id='view'>Path fast view</h2><span id='topic+view'></span><span id='topic+view+2CbinClstPath-method'></span><span id='topic+view+2Cdata.frame-method'></span>

<h3>Description</h3>

<p><code>view</code> provides a fast plot of a segmented trajectory or
specific chunks of it.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>view(obj, ...)

## S4 method for signature 'binClstPath'
view(obj, lbl = NULL, lims = NULL, bg = NULL, ...)

## S4 method for signature 'data.frame'
view(obj, lbl = NULL, lims = NULL, bg = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="view_+3A_obj">obj</code></td>
<td>
<p>A <a href="#topic+binClstPath_instance">binClstPath_instance</a> or a data.frame with the format
described for slot <code>binClstPath@pth</code>.</p>
</td></tr>
<tr><td><code id="view_+3A_...">...</code></td>
<td>
<p>Parameters <code>lbl</code> and <code>lims</code> are optional.</p>
</td></tr>
<tr><td><code id="view_+3A_lbl">lbl</code></td>
<td>
<p>A numeric vector with location labels. If <code>obj</code> is a
<a href="#topic+binClstPath_instance">binClstPath_instance</a> the clustering labels are used by default.</p>
</td></tr>
<tr><td><code id="view_+3A_lims">lims</code></td>
<td>
<p>A numeric vector with lower and upper limit locations to show
only a chunk of the trajectory.</p>
</td></tr>
<tr><td><code id="view_+3A_bg">bg</code></td>
<td>
<p>A valid colour to be used as background colour. By default a light-grey colour is used to enhance data points visibility.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># -- Fast view of the binClstPath instance included in the package --
view(expth)
# -- the same with reference labels --
view(expth,lbl=TRUE)
</code></pre>

<hr>
<h2 id='x2d'>Synthetic 2D object used in the examples</h2><span id='topic+x2d'></span>

<h3>Description</h3>

<p>An ad-hoc object with a set of bivariate data points synthetically generated by sampling from a four component GMM and their corresponding labels indicating which component of the mixture generated each data point.
</p>


<h3>Format</h3>

<p>See parameter <code>X</code> of the <a href="#topic+embc">embc</a> constructor.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
