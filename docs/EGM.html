<!DOCTYPE html><html><head><title>Help for package EGM</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {EGM}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#EGM-package'><p>EGM: Evaluating Cardiac Electrophysiology Signals</p></a></li>
<li><a href='#add_colors'><p>Add color scheme to a <code>ggm</code> object</p></a></li>
<li><a href='#annotation_table'><p>Annotation Table</p></a></li>
<li><a href='#color_channels'><p>Identify the color for a channel based on palettes</p></a></li>
<li><a href='#colors'><p>Theming and color options for <code>ggm</code> objects</p></a></li>
<li><a href='#egm'><p>Electrogram data class from electrophysiology studies</p></a></li>
<li><a href='#EGM-vctrs'><p>Internal vctrs methods</p></a></li>
<li><a href='#extract_signal'><p>Extract raw signal data from an <code>egm</code> object</p></a></li>
<li><a href='#ggm'><p>Visualization of EGMs using <code>ggplot</code></p></a></li>
<li><a href='#header_table'><p>Header Table</p></a></li>
<li><a href='#lspro'><p>Read in ECG and EGM data from LabSystem Pro</p></a></li>
<li><a href='#muse'><p>Read in ECG data from MUSE</p></a></li>
<li><a href='#segmentation'><p>Segmentation of electrical signal by wave specifications</p></a></li>
<li><a href='#signal_table'><p>Signal tables</p></a></li>
<li><a href='#wfdb'><p>Waveform Database (WFDB) Software Package</p></a></li>
<li><a href='#wfdb_annotations'><p>Read WFDB-compatible annotation file</p></a></li>
<li><a href='#wfdb_io'><p>I/O of WFDB-compatible signal &amp; header files from EP recording systems</p></a></li>
<li><a href='#wfdb_paths'><p>WFDB path utilities</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Evaluating Cardiac Electrophysiology Signals</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.0</td>
</tr>
<tr>
<td>Description:</td>
<td>A system for importing electrophysiological signal, based
    on the 'Waveform Database (WFDB)' software package, written by Moody et al 
    2022 &lt;<a href="https://doi.org/10.13026%2Fgjvw-1m31">doi:10.13026/gjvw-1m31</a>&gt;. A wrapper for utilizing 'WFDB' functions for
    reading and writing signal data, as well as functions for visualization and
    analysis are provided. A stable and broadly compatible class for working
    with signal data, supporting the reading in of cardiac electrophysiogical
    files such as intracardiac electrograms, is introduced.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.0), vctrs (&ge; 0.5.0), data.table (&ge; 1.15.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, fs, ggplot2, lifecycle, rlang, utils, xml2, base64enc,
checkmate, stringr,</td>
</tr>
<tr>
<td>Suggests:</td>
<td>covr, knitr, rmarkdown, testthat (&ge; 3.0.0), withr,</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://shah-in-boots.github.io/EGM/">https://shah-in-boots.github.io/EGM/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/shah-in-boots/EGM/issues">https://github.com/shah-in-boots/EGM/issues</a></td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-05-22 14:45:59 UTC; asshah4</td>
</tr>
<tr>
<td>Author:</td>
<td>Anish S. Shah <a href="https://orcid.org/0000-0002-9729-1558"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre, cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Anish S. Shah &lt;ashah282@uic.edu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-05-23 16:10:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='EGM-package'>EGM: Evaluating Cardiac Electrophysiology Signals</h2><span id='topic+EGM'></span><span id='topic+EGM-package'></span>

<h3>Description</h3>

<p>A system for importing electrophysiological signal, based on the 'Waveform Database (WFDB)' software package, written by Moody et al 2022 <a href="https://doi.org/10.13026/gjvw-1m31">doi:10.13026/gjvw-1m31</a>. A wrapper for utilizing 'WFDB' functions for reading and writing signal data, as well as functions for visualization and analysis are provided. A stable and broadly compatible class for working with signal data, supporting the reading in of cardiac electrophysiogical files such as intracardiac electrograms, is introduced.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Anish S. Shah <a href="mailto:ashah282@uic.edu">ashah282@uic.edu</a> (<a href="https://orcid.org/0000-0002-9729-1558">ORCID</a>) [copyright holder]
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://shah-in-boots.github.io/EGM/">https://shah-in-boots.github.io/EGM/</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/shah-in-boots/EGM/issues">https://github.com/shah-in-boots/EGM/issues</a>
</p>
</li></ul>


<hr>
<h2 id='add_colors'>Add color scheme to a <code>ggm</code> object</h2><span id='topic+add_colors'></span>

<h3>Description</h3>

<p>Using <code>add_colors()</code> is part of the theme process for a <code>ggm</code>
object, which in turn is a visual representation of an <code>egm</code> object. Often,
the <code>egm</code> dataset will contain default colors based on where the signal
data was brought in from. <code>add_colors()</code> can allow customization of those
features to some degree based on <em>opinionated</em> color palettes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_colors(object, palette, mode)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_colors_+3A_object">object</code></td>
<td>
<p>A <code>ggm</code> object</p>
</td></tr>
<tr><td><code id="add_colors_+3A_palette">palette</code></td>
<td>
<p>A <code>character</code> choice from the below options that describe the
color choices to be used for plotting. If set to the default, which is
<code>NULL</code>, no changes to the colors for individual channels will be performed.
If a positive choice is made, then the background <strong>mode</strong> argument will be
set to <em>dark</em> as the default, unless otherwise specified. <em>WARNING</em>: This is
an experimental argument, and may be moved in future version.
</p>

<ul>
<li> <p><strong>NULL</strong>: no changes to the colors will be made. DEFAULT.
</p>
</li>
<li> <p><strong>material</strong>: a colorscheme based off of the <a href="https://m3.material.io/styles/color/system/how-the-system-works">Material Design</a> color scheme
</p>
</li></ul>
</td></tr>
<tr><td><code id="add_colors_+3A_mode">mode</code></td>
<td>
<p>A <code>character</code> string from <code>c("dark", "light")</code> to describe the
base/background color settings to be used. If there are preset channel
colors that were exported in the <code>egm</code> object, these colors will be used
for the individual channels. If <strong>palette</strong> is specified, then the <em>dark</em>
option will be set automatically (a palette choice cannot be made without
understanding the background to plate it across). <em>WARNING</em>: This is an
experimental argument, and may be moved in future version.
</p>

<ul>
<li><p> The <em>dark</em> theme mimics the &quot;white on black&quot; scheme seen in <em>LabSystem Pro</em> format (and most other high-contrast visualizations), for minimizing eye strain. This calls the <code><a href="#topic+theme_egm_dark">theme_egm_dark()</a></code> function. DEFAULT.
</p>
</li>
<li><p> The <em>light</em> theme mimics the &quot;black on white&quot; colors seen in the <em>Prucka</em> system.
</p>
</li>
<li> <p><code>NULL</code> removes any theme, and uses the default <code><a href="ggplot2.html#topic+ggplot">ggplot2::ggplot()</a></code> settings
</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p>Currently, the color choices are individual decided based on the
channel source (e.g. lead) and are inspired by some modern palettes. The
eventual goal for this function is to accept a multitude of palette options
using heuristics similar to what is found in <code>{ggplot2}</code> or other graphing
packages.
</p>


<h3>Value</h3>

<p>Returns an updated <code>ggm</code> object
</p>

<hr>
<h2 id='annotation_table'>Annotation Table</h2><span id='topic+annotation_table'></span><span id='topic+is_annotation_table'></span>

<h3>Description</h3>

<p><code>annotation_table()</code> modifies the <code>data.table</code> class to work
with annotation data. The columns are of all equal length, and each row
describes a single annotation (although there may be duplicate time points).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>annotation_table(
  annotator = character(),
  time = character(),
  sample = integer(),
  frequency = integer(),
  type = character(),
  subtype = character(),
  channel = integer(),
  number = integer(),
  ...
)

is_annotation_table(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="annotation_table_+3A_annotator">annotator</code></td>
<td>
<p>String that is the name of a WFDB-compatible annotation
type, serving as the extension for the file that is written containing that
annotation. Please see <code><a href="#topic+read_annotation">read_annotation()</a></code> and <code><a href="#topic+write_annotation">write_annotation()</a></code> for
further details.</p>
</td></tr>
<tr><td><code id="annotation_table_+3A_time">time</code></td>
<td>
<p>A <code>character</code> time stamp of the annotation, written in the format
of <strong>HH:MM:SS.SSS</strong>, starting at <strong>00:00:00.000</strong>. This is converted to the
appropriate time based on the header file (which records the actual start
time and sampling frequency). This is often a missing variable and is
given for compatibility with the WFDB applications.</p>
</td></tr>
<tr><td><code id="annotation_table_+3A_sample">sample</code></td>
<td>
<p>An <code>integer</code> representing the sample number of the annotation</p>
</td></tr>
<tr><td><code id="annotation_table_+3A_frequency">frequency</code></td>
<td>
<p>An <code>integer</code> that represents the sampling frequency in Hertz</p>
</td></tr>
<tr><td><code id="annotation_table_+3A_type">type</code></td>
<td>
<p>A <code>character</code> or string representing the type of the annotation</p>
</td></tr>
<tr><td><code id="annotation_table_+3A_subtype">subtype</code></td>
<td>
<p>A <code>character</code> or string representing the subtype of the
annotation</p>
</td></tr>
<tr><td><code id="annotation_table_+3A_channel">channel</code></td>
<td>
<p>An <code>integer</code> representing the channel number of the
annotation, or a <code>character</code> representing the channel name</p>
</td></tr>
<tr><td><code id="annotation_table_+3A_number">number</code></td>
<td>
<p>An additional <code>integer</code> value or number that classifies the
annotation (allows for compatibility with multiple annotation types)</p>
</td></tr>
<tr><td><code id="annotation_table_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to the function</p>
</td></tr>
<tr><td><code id="annotation_table_+3A_x">x</code></td>
<td>
<p>A <code>data.table</code> object that represents an annotation table</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>annotation_table()</code> function creates a compatible table that
can be used with <code><a href="#topic+write_annotation">write_annotation()</a></code> and <code><a href="#topic+read_annotation">read_annotation()</a></code> functions.
</p>


<h3>Value</h3>

<p>A <code>data.table</code> that has invariant columns that are compatible with
the WFDB library. The key columns include the sample index, the type of
annotation (and its subtype and number qualifier), and the channel.
</p>


<h3>Annotation files</h3>

<p>The following annotation file types are described below.
</p>


<h4><code>ecgpuwave</code></h4>

<p><code>ecgpuwave</code> analyzes an ECG signal from the specified record, detecting the
QRS complexes and locating the beginning, peak, and end of the P, QRS, and
ST-T waveforms. The output of ecgpuwave is written as a standard WFDB-format
annotation file (the extension is &quot;*.ecgpuwave&quot;, as would be expected). This
file can be converted into text format using <code>rdann</code>. Further details are
given at the <a href="https://physionet.org/content/ecgpuwave/1.3.4/">ECGPUWAVE</a>
page.
</p>
<p>The <strong>type</strong> column can be <em>p</em>, <em>t</em>, or <em>N</em> for the peak of the P wave, T
wave, and QRS (R peak) directly. The output notation also includes waveform
onset XXX and waveform offset XXX. The <strong>number</strong> column gives further
information about each of these <strong>type</strong> labels.
</p>
<p>The <strong>number</strong> column gives modifier information. If the <strong>type</strong> classifier
is a T wave annotation, the <strong>number</strong> column can be 0 (normal), 1
(inverted), 2 (positive), 3 (negative), 4 (biphasic negative-positive), 5
(biphasic positive-negative). If the <strong>type</strong> is an waveform onset or offset,
then <strong>number</strong> can be 0 (P wave), 1 (QRS complex), 2 (T wave).
</p>


<hr>
<h2 id='color_channels'>Identify the color for a channel based on palettes</h2><span id='topic+color_channels'></span>

<h3>Description</h3>

<p>This primarily restricts the colors to color-space safe options. It is
intended to be used with <code><a href="#topic+add_colors">add_colors()</a></code> to provide a color scheme for the
<code>ggm</code> object. It has been exposed to users for custom or advanced theming
options.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>color_channels(x, palette, mode = "dark")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="color_channels_+3A_x">x</code></td>
<td>
<p>Vector of <code>character</code> names of requested ECG or EGM leads</p>
</td></tr>
<tr><td><code id="color_channels_+3A_palette">palette</code></td>
<td>
<p>A <code>character</code> choice from the below options that describe the
color choices to be used for plotting. If set to the default, which is
<code>NULL</code>, no changes to the colors for individual channels will be performed.
If a positive choice is made, then the background <strong>mode</strong> argument will be
set to <em>dark</em> as the default, unless otherwise specified. <em>WARNING</em>: This is
an experimental argument, and may be moved in future version.
</p>

<ul>
<li> <p><strong>NULL</strong>: no changes to the colors will be made. DEFAULT.
</p>
</li>
<li> <p><strong>material</strong>: a colorscheme based off of the <a href="https://m3.material.io/styles/color/system/how-the-system-works">Material Design</a> color scheme
</p>
</li></ul>
</td></tr>
<tr><td><code id="color_channels_+3A_mode">mode</code></td>
<td>
<p>A <code>character</code> string from <code>c("dark", "light")</code> to describe the
base/background color settings to be used. If there are preset channel
colors that were exported in the <code>egm</code> object, these colors will be used
for the individual channels. If <strong>palette</strong> is specified, then the <em>dark</em>
option will be set automatically (a palette choice cannot be made without
understanding the background to plate it across). <em>WARNING</em>: This is an
experimental argument, and may be moved in future version.
</p>

<ul>
<li><p> The <em>dark</em> theme mimics the &quot;white on black&quot; scheme seen in <em>LabSystem Pro</em> format (and most other high-contrast visualizations), for minimizing eye strain. This calls the <code><a href="#topic+theme_egm_dark">theme_egm_dark()</a></code> function. DEFAULT.
</p>
</li>
<li><p> The <em>light</em> theme mimics the &quot;black on white&quot; colors seen in the <em>Prucka</em> system.
</p>
</li>
<li> <p><code>NULL</code> removes any theme, and uses the default <code><a href="ggplot2.html#topic+ggplot">ggplot2::ggplot()</a></code> settings
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector of hex code colors as <code>character</code> based on the selected
palette and light/dark mode
</p>

<hr>
<h2 id='colors'>Theming and color options for <code>ggm</code> objects</h2><span id='topic+colors'></span><span id='topic+theme_egm'></span><span id='topic+theme_egm_light'></span><span id='topic+theme_egm_dark'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p>The general purpose is to improve visualization of electrical signals. There
is a pattern of colors that are generally given from different recording
software, and they can be replicated to help improve visibility.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>theme_egm()

theme_egm_light()

theme_egm_dark()
</code></pre>


<h3>Value</h3>

<p>A <code>ggm</code> object, with inheritance similar to
<code><a href="ggplot2.html#topic+ggtheme">ggplot2::theme_minimal()</a></code>
</p>

<hr>
<h2 id='egm'>Electrogram data class from electrophysiology studies</h2><span id='topic+egm'></span><span id='topic+is_egm'></span>

<h3>Description</h3>

<p>This class serves as a combinatorial class to describe
cardiovascular electrical signal data in R. It is based off of the formats
available in WFDB, but has been formatted for ease of use within the <code>R</code>
ecosystem. An <code>egm</code> object contains three components in a list:
</p>

<ul>
<li><p> signal data in multiple channels
</p>
</li>
<li><p> header information
</p>
</li>
<li><p> annotation labels at specified time points
</p>
</li></ul>

<p>These components help to navigate, and visualize data. The <code>egm</code> class is
the backbone for working with WFDB objects in R, and provides an interface
for integrating or converting other raw signal data to a WFDB format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>egm(
  signal = signal_table(),
  header = header_table(),
  annotation = annotation_table(),
  ...
)

is_egm(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="egm_+3A_signal">signal</code></td>
<td>
<p>A <code>signal_table</code> object generated by the <code><a href="#topic+signal_table">signal_table()</a></code>
function</p>
</td></tr>
<tr><td><code id="egm_+3A_header">header</code></td>
<td>
<p>A <code>header_table</code> object generated by the <code><a href="#topic+header_table">header_table()</a></code>
function</p>
</td></tr>
<tr><td><code id="egm_+3A_annotation">annotation</code></td>
<td>
<p>A <code>annotation_table</code> object generated by the
<code><a href="#topic+annotation_table">annotation_table()</a></code> function</p>
</td></tr>
<tr><td><code id="egm_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to the function</p>
</td></tr>
<tr><td><code id="egm_+3A_x">x</code></td>
<td>
<p>An <code>egm</code> object, typically generated by the <code><a href="#topic+egm">egm()</a></code> function, to be
used with support functions (e.g. <code><a href="#topic+is_egm">is_egm()</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The individual components of the class are further defined in their
respective children functions <code><a href="#topic+signal_table">signal_table()</a></code>, <code><a href="#topic+header_table">header_table()</a></code>,
<code><a href="#topic+annotation_table">annotation_table()</a></code>. They are very simple classes that build upon the
<code>data.table</code> class that allow for class safety checks when working with
different data types (particularly WFDB).
</p>
<p><strong>IMPORTANT</strong>: The <code>egm</code> class can be built from ground-up by the user,
however it is primarily generated for the user using the other read/write
functions, such as <code><a href="#topic+read_lspro">read_lspro()</a></code> or <code><a href="#topic+read_wfdb">read_wfdb()</a></code>.
</p>


<h3>Value</h3>

<p>An object of class <code>egm</code> that is always a list of the above three
components. Oftentimes, the <code>annotation_table</code> object may be missing, and
it is replaced with an empty table as a place holder.
</p>

<hr>
<h2 id='EGM-vctrs'>Internal vctrs methods</h2><span id='topic+EGM-vctrs'></span>

<h3>Description</h3>

<p>Internal vctrs methods
</p>

<hr>
<h2 id='extract_signal'>Extract raw signal data from an <code>egm</code> object</h2><span id='topic+extract_signal'></span>

<h3>Description</h3>

<p>Raw signal data may be all that is required, particularly when
storing or manipulating data, or for example, feeding it into an analytical
pipeline. This means the extraneous elements, such as the <em>meta</em> information,
may be unnecessary. This function helps to strip away and extract just the
signal data itself and channel names.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract_signal(object, data_format = c("data.frame", "matrix", "array"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extract_signal_+3A_object">object</code></td>
<td>
<p>An <code>egm</code> object that contains the signal data to be extracted</p>
</td></tr>
<tr><td><code id="extract_signal_+3A_data_format">data_format</code></td>
<td>
<p>A <code>character</code> choice of either <em>data.frame</em> (default),
<em>matrix</em>, or <em>array</em> that tells how the data should be structured.
Further explanation in the details.</p>
</td></tr>
<tr><td><code id="extract_signal_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to the function</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The options to return the data vary based on need. The data can be
extracted as follows:
</p>

<ul>
<li> <p><code>data.frame</code> containing an equal number of rows to the number of samples, with each column named after the recording channel it was derived from. Data frames, as they are columnar by nature, will also include the sample index position.
</p>
</li>
<li> <p><code>matrix</code> containing an equal number of rows to the number of samples, with each column named after the recording channel it was derived from
</p>
</li>
<li> <p><code>array</code> containing individual vectors of signal, each named after the channel they were derived from
</p>
</li></ul>



<h3>Value</h3>

<p>An object as described by the <strong>format</strong> option
</p>

<hr>
<h2 id='ggm'>Visualization of EGMs using <code>ggplot</code></h2><span id='topic+ggm'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p>The <code>ggm()</code> function is used to plot objects of the <code>egm</code> class. This
function however is more than just a plotting function - it serves as a
visualization tool and confirmation of patterns, annotations, and underlying
waveforms in the data. The power of this, instead of being a <code style="white-space: pre;">&#8288;geom_*()&#8288;</code>
object, is that annotations, intervals, and measurements can be added
incrementally.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ggm(
  data,
  channels = character(),
  time_frame = NULL,
  palette = NULL,
  mode = "dark",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ggm_+3A_data">data</code></td>
<td>
<p>Data of the <code>egm</code> class, which includes header (meta) and signal
information together.</p>
</td></tr>
<tr><td><code id="ggm_+3A_channels">channels</code></td>
<td>
<p>A <code>character</code> vector of which channels to use. Can give
either the channel label (e.g &quot;CS 1-2&quot;) or the recording device/catheter
type (e.g &quot;His&quot; or &quot;ECG&quot;). If no channels are selected, the default is all
channels.</p>
</td></tr>
<tr><td><code id="ggm_+3A_time_frame">time_frame</code></td>
<td>
<p>A time range that should be displaced given in the format
of a vector with a length of 2. The left value is the start, and right
value is the end time. This is given in seconds (decimals may be used).</p>
</td></tr>
<tr><td><code id="ggm_+3A_palette">palette</code></td>
<td>
<p>A <code>character</code> choice from the below options that describe the
color choices to be used for plotting. If set to the default, which is
<code>NULL</code>, no changes to the colors for individual channels will be performed.
If a positive choice is made, then the background <strong>mode</strong> argument will be
set to <em>dark</em> as the default, unless otherwise specified. <em>WARNING</em>: This is
an experimental argument, and may be moved in future version.
</p>

<ul>
<li> <p><strong>NULL</strong>: no changes to the colors will be made. DEFAULT.
</p>
</li>
<li> <p><strong>material</strong>: a colorscheme based off of the <a href="https://m3.material.io/styles/color/system/how-the-system-works">Material Design</a> color scheme
</p>
</li></ul>
</td></tr>
<tr><td><code id="ggm_+3A_mode">mode</code></td>
<td>
<p>A <code>character</code> string from <code>c("dark", "light")</code> to describe the
base/background color settings to be used. If there are preset channel
colors that were exported in the <code>egm</code> object, these colors will be used
for the individual channels. If <strong>palette</strong> is specified, then the <em>dark</em>
option will be set automatically (a palette choice cannot be made without
understanding the background to plate it across). <em>WARNING</em>: This is an
experimental argument, and may be moved in future version.
</p>

<ul>
<li><p> The <em>dark</em> theme mimics the &quot;white on black&quot; scheme seen in <em>LabSystem Pro</em> format (and most other high-contrast visualizations), for minimizing eye strain. This calls the <code><a href="#topic+theme_egm_dark">theme_egm_dark()</a></code> function. DEFAULT.
</p>
</li>
<li><p> The <em>light</em> theme mimics the &quot;black on white&quot; colors seen in the <em>Prucka</em> system.
</p>
</li>
<li> <p><code>NULL</code> removes any theme, and uses the default <code><a href="ggplot2.html#topic+ggplot">ggplot2::ggplot()</a></code> settings
</p>
</li></ul>
</td></tr>
<tr><td><code id="ggm_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to the function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code>{ggplot2}</code> compatible object with the <code>ggm</code> class, which
contains additional elements about the header and annotations of the
original data.
</p>

<hr>
<h2 id='header_table'>Header Table</h2><span id='topic+header_table'></span><span id='topic+is_header_table'></span>

<h3>Description</h3>

<p><code>header_table()</code> modifies the <code>data.table</code> class to work with
header data. The header data is read in from a similar format as to that of
WFDB files and should be compatible/interchangeable when writing out to disk.
The details extensively cover the type of data that is input. Generally, this
function is called by <code style="white-space: pre;">&#8288;read_*_header()&#8288;</code> functions and will generally not be
called by the end-user.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>header_table(
  record_name = character(),
  number_of_channels = integer(),
  frequency = 250,
  samples = integer(),
  start_time = strptime(Sys.time(), "%Y-%m-%d %H:%M:%OSn"),
  ADC_saturation = integer(),
  file_name = character(),
  storage_format = 16L,
  ADC_gain = 200L,
  ADC_baseline = ADC_zero,
  ADC_units = "mV",
  ADC_resolution = 12L,
  ADC_zero = 0L,
  initial_value = ADC_zero,
  checksum = 0L,
  blocksize = 0L,
  label = character(),
  info_strings = list(),
  additional_gain = 1,
  low_pass = integer(),
  high_pass = integer(),
  color = "#000000",
  scale = integer()
)

is_header_table(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="header_table_+3A_record_name">record_name</code></td>
<td>
<p>A <code>character</code> vector of record line information</p>
</td></tr>
<tr><td><code id="header_table_+3A_number_of_channels">number_of_channels</code></td>
<td>
<p>An <code>integer</code> describing number of signals</p>
</td></tr>
<tr><td><code id="header_table_+3A_frequency">frequency</code></td>
<td>
<p>A <code>numeric</code> value of sampling frequency, 250 Hz default</p>
</td></tr>
<tr><td><code id="header_table_+3A_samples">samples</code></td>
<td>
<p>An <code>integer</code> for the number of samples</p>
</td></tr>
<tr><td><code id="header_table_+3A_start_time">start_time</code></td>
<td>
<p>The <code>POSIXct</code> time of recording, with miliseconds included.
For example, <code>strptime(start_time, "%Y-%m-%d %H:%M%:%OSn")</code> where as
described in <code><a href="base.html#topic+strptime">base::strptime()</a></code></p>
</td></tr>
<tr><td><code id="header_table_+3A_adc_saturation">ADC_saturation</code></td>
<td>
<p>An <code>integer</code> representing ADC saturation</p>
</td></tr>
<tr><td><code id="header_table_+3A_file_name">file_name</code></td>
<td>
<p>A <code>character</code> for the signal specific information</p>
</td></tr>
<tr><td><code id="header_table_+3A_storage_format">storage_format</code></td>
<td>
<p>An <code>integer</code> of the bits for the storage format, 16-bit
default</p>
</td></tr>
<tr><td><code id="header_table_+3A_adc_gain">ADC_gain</code></td>
<td>
<p>An <code>integer</code> of ADC gain, default of 200</p>
</td></tr>
<tr><td><code id="header_table_+3A_adc_baseline">ADC_baseline</code></td>
<td>
<p>An <code>integer</code> of ADC baseline, defaults to <strong>ADC_zero</strong></p>
</td></tr>
<tr><td><code id="header_table_+3A_adc_units">ADC_units</code></td>
<td>
<p>A <code>character</code> to describe ADC units, &quot;mV&quot; is default</p>
</td></tr>
<tr><td><code id="header_table_+3A_adc_resolution">ADC_resolution</code></td>
<td>
<p>An <code>integer</code> for ADC resolution, default is 12</p>
</td></tr>
<tr><td><code id="header_table_+3A_adc_zero">ADC_zero</code></td>
<td>
<p>An <code>integer</code> for ADC zero, defaults to 0</p>
</td></tr>
<tr><td><code id="header_table_+3A_initial_value">initial_value</code></td>
<td>
<p>An <code>integer</code> for the initial value, defaults to
<strong>ADC_zero</strong> value</p>
</td></tr>
<tr><td><code id="header_table_+3A_checksum">checksum</code></td>
<td>
<p>An <code>integer</code> that serves as the checksum</p>
</td></tr>
<tr><td><code id="header_table_+3A_blocksize">blocksize</code></td>
<td>
<p>An <code>integer</code> of the block size</p>
</td></tr>
<tr><td><code id="header_table_+3A_label">label</code></td>
<td>
<p>A <code>character</code> description of the signal</p>
</td></tr>
<tr><td><code id="header_table_+3A_info_strings">info_strings</code></td>
<td>
<p>A <code>list</code> of strings that will be written as an appendix
to the header file, usually containing information about the channels,
(e.g. list of colors, extra labels, etc).</p>
</td></tr>
<tr><td><code id="header_table_+3A_additional_gain">additional_gain</code></td>
<td>
<p>A <code>numeric</code> Additional gain, defaults to 1.0</p>
</td></tr>
<tr><td><code id="header_table_+3A_low_pass">low_pass</code></td>
<td>
<p>An <code>integer</code> Low pass filter</p>
</td></tr>
<tr><td><code id="header_table_+3A_high_pass">high_pass</code></td>
<td>
<p>An <code>integer</code> High pass filter</p>
</td></tr>
<tr><td><code id="header_table_+3A_color">color</code></td>
<td>
<p>A <code>character</code> Color as hexadecimal format, defaults to black</p>
</td></tr>
<tr><td><code id="header_table_+3A_scale">scale</code></td>
<td>
<p>An <code>integer</code> Scale</p>
</td></tr>
<tr><td><code id="header_table_+3A_x">x</code></td>
<td>
<p>A <code>data.table</code> object that serves as the header table</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>header_table</code> object is relatively complex in that it directly
deals with properties of the signal, and allows compatibility with WFDB
files and other raw header files for other signal objects. It can be written
out using <code><a href="#topic+write_wfdb">write_wfdb()</a></code>.
</p>


<h3>Value</h3>

<p>A <code>header_table</code> object that is an extension of the <code>data.table</code>
class. This contains an adaptation of the function arguments, allowing for
compatibility with the WFDB class.
</p>


<h3>Header file structure</h3>

<p>There are three components to the header file:
</p>

<ol>
<li> <p><strong>Record line</strong> that contains the following information, in the order
documented, however pieces may be missing based on different parameters.
From left to right...
</p>

<ul>
<li><p> Record name
</p>
</li>
<li><p> Number of signals: represents number of segments/channels
</p>
</li>
<li><p> Sampling frequency (optional)
</p>
</li>
<li><p> Number of samples (optional)
</p>
</li>
<li><p> Time: in HH:MM:SS format (optional)
</p>
</li>
<li><p> Date: in DD/MM/YYYY (optional)
</p>
</li></ul>

</li>
<li> <p><strong>Signal specification lines</strong> contains specifications for individual
signals, and there must be as many signal lines as there are reported by the
above record line. From left to right....
</p>

<ul>
<li><p> File name: usually *.dat
</p>
</li>
<li><p> Format <code>integer</code>: represents storage type, e.g. 8-bit or 16-bit
</p>
</li>
<li><p> ADC gain: ADC units per physical unit (optional)
</p>

<ul>
<li><p> Baseline: corresponds to 0 physical units, sep = '*(0)&quot; (optional)
</p>
</li>
<li><p> Units: with '/' as a field separator e.g '*/mV' (optional)
</p>
</li></ul>

</li>
<li><p> ADC resolution <code>integer</code>: bits, usually 8 or 16 (optional)
</p>
</li>
<li><p> ADC zero: represents middle of ADC input range (optional)
</p>
</li>
<li><p> Initial value (optional)
</p>
</li>
<li><p> Checksum (optional)
</p>
</li>
<li><p> Block size (optional)
</p>
</li>
<li><p> Description: text or label information (optional)
</p>
</li></ul>

</li>
<li> <p><strong>Info strings</strong> are unstructured lines that contains information about
the record. Usually are descriptive. Starts with initial '#' without
preceding white space at beginning of line.
</p>
</li></ol>


<hr>
<h2 id='lspro'>Read in ECG and EGM data from LabSystem Pro</h2><span id='topic+lspro'></span><span id='topic+read_lspro'></span><span id='topic+read_lspro_header'></span><span id='topic+read_lspro_signal'></span>

<h3>Description</h3>

<p>This function allows for reading in LS Pro data based on their
text export of signals. Signals can be exported directly from the LS Pro
system.
</p>
<p>The <a href="https://www.bostonscientific.com/en-EU/medical-specialties/electrophysiology/arrhythmias/cardiac-mapping-system/electrophysiology-recording-system.html">LabSystem Pro</a>
was acquired by Boston Scientific from the original company
<a href="https://news.bostonscientific.com/2013-06-28-Boston-Scientific-To-Acquire-C-R-Bard-Electrophysiology-Business">Bard</a>.
They are a common electrophysiology signal processing device for
visualization and measurement of intracardiac signals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_lspro(file, n = Inf)

read_lspro_header(file)

read_lspro_signal(file, n = Inf)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lspro_+3A_file">file</code></td>
<td>
<p>The path to the file where the data is located. It must be a
<strong>*.txt</strong> file. See details below about its format.</p>
</td></tr>
<tr><td><code id="lspro_+3A_n">n</code></td>
<td>
<p>Number of signal values to return (this will be the same for each
channel of data). Defaults to all values.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code>egm</code> class object that is a list of <code>eps</code> signals the format of a
<code>data.table</code>, with an attached <strong>header</strong> attribute that contains
additional recording data.
</p>


<h3>Data Export</h3>

<p>The steps to data export are as follows.
</p>

<ol>
<li><p> Start LabSystem PRO
</p>
</li>
<li><p> Open a patient record
</p>
</li>
<li><p> Display a waveform recording in a Review Window
</p>
</li>
<li><p> Scroll to a point of interest in a waveform recording
</p>
</li>
<li><p> Right click on the review window to the left of the region of interest
</p>
</li>
<li><p> Select an Export option, either a default time range or the entire visible
page (which depends on the sweep speed).
</p>
</li></ol>



<h3>Data Format</h3>

<div class="sourceCode"><pre>[Header] Recording info â€“ contains (example):

[Header]&lt;CR&gt;&lt;LF&gt;
	 File Type: 1&lt;CR&gt;&lt;LF&gt;
	 Version: 1&lt;CR&gt;&lt;LF&gt;
	 Channels exported: 22&lt;CR&gt;&lt;LF&gt;
	 Samples per channel: 5000&lt;CR&gt;&lt;LF&gt;
	 Start time:  6:55:24&lt;CR&gt;&lt;LF&gt;
	 End time:  6:55:29&lt;CR&gt;&lt;LF&gt;
	 Ch. Info. Pointer: 320&lt;CR&gt;&lt;LF&gt;
	 Stamp Data: T&lt;CR&gt;&lt;LF&gt;
	 Mux format: 0&lt;CR&gt;&lt;LF&gt;
	 Mux Block Size: &lt;CR&gt;&lt;LF&gt;
	 Data Format 1&lt;CR&gt;&lt;LF&gt;
	 Sample Rate: 1000Hz&lt;CR&gt;&lt;LF&gt;

[Header] Channel info (per channel example):

  Channel #: 1&lt;CR&gt;&lt;LF&gt;
  Label: III&lt;CR&gt;&lt;LF&gt;
	 Range: 5mv &lt;CR&gt;&lt;LF&gt;
	 Low: 1Hz&lt;CR&gt;&lt;LF&gt;
	 High: 100Hz&lt;CR&gt;&lt;LF&gt;
	 Sample rate: 1000Hz&lt;CR&gt;&lt;LF&gt;
	 Color: 0000FF&lt;CR&gt;&lt;LF&gt;
	 Scale: -7&lt;CR&gt;&lt;LF&gt;

[Data] As described below:

	-256,-1056,576,-256,320,-736,144,576,-592,176,608,240,176,-560,496,-
	144,0,0,-32,-48,-32,-80&lt;CR&gt;&lt;LF&gt;

</pre></div>
<p>Channel Data is interleaved in the example above (sample indexed at 1):</p>

<table>
<tr>
 <td style="text-align: left;">
   1 </td><td style="text-align: left;"> 2 </td><td style="text-align: left;"> 3 </td><td style="text-align: left;"> ... </td><td style="text-align: left;"> 22 </td>
</tr>
<tr>
 <td style="text-align: left;">
   Ch1:1 </td><td style="text-align: left;"> Ch2:1 </td><td style="text-align: left;"> Ch3:1 </td><td style="text-align: left;"> ... </td><td style="text-align: left;"> Ch22:1 </td>
</tr>
<tr>
 <td style="text-align: left;">
   Ch1:2 </td><td style="text-align: left;"> Ch2:2 </td><td style="text-align: left;"> Ch3:2 </td><td style="text-align: left;"> ... </td><td style="text-align: left;"> Ch22:2 </td>
</tr>
<tr>
 <td style="text-align: left;">
   Ch1:3 </td><td style="text-align: left;"> Ch2:3 </td><td style="text-align: left;"> Ch3:3 </td><td style="text-align: left;"> ... </td><td style="text-align: left;"> Ch22:3 </td>
</tr>
<tr>
 <td style="text-align: left;">
   ... </td><td style="text-align: left;"> ... </td><td style="text-align: left;"> ... </td><td style="text-align: left;"> ... </td><td style="text-align: left;"> ... </td>
</tr>
<tr>
 <td style="text-align: left;">
   Ch1:5000 </td><td style="text-align: left;"> Ch2:5000 </td><td style="text-align: left;"> Ch3:5000 </td><td style="text-align: left;"> ... </td><td style="text-align: left;"> Ch22:5000 </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>


<hr>
<h2 id='muse'>Read in ECG data from MUSE</h2><span id='topic+muse'></span><span id='topic+read_muse'></span>

<h3>Description</h3>

<p>This function serves to read/convert XML based files from the MUSE system to
digital signal. This can subsequently be written into other formats. The MUSE
system is somewhat proprietary, and each version may or may not allow export
options into XML.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_muse(file)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="muse_+3A_file">file</code></td>
<td>
<p>An ECG file from MUSE in XML format</p>
</td></tr>
</table>


<h3>Details</h3>

<p><a href="https://www.gehealthcare.com/en-ph/products/diagnostic-ecg/cardio-data-management/muse-v9">GE Healthcare MUSE v9</a>
is currently the model that is being used. These functions have not been
tested in older models.
</p>


<h3>Value</h3>

<p>An <code>egm</code> class object that is a list of <code>eps</code> signals the format of a
<code>data.table</code>, with an attached <strong>header</strong> attribute that contains
additional recording data.
</p>

<hr>
<h2 id='segmentation'>Segmentation of electrical signal by wave specifications</h2><span id='topic+segmentation'></span><span id='topic+segment_by_sinus'></span><span id='topic+pad_sequence'></span><span id='topic+center_sequence'></span>

<h3>Description</h3>

<p>Segmentation of electrical signal by wave specifications
</p>


<h3>Usage</h3>

<pre><code class='language-R'>segmentation(
  object,
  by = "sinus",
  pad = "before",
  pad_length = 0L,
  center = NULL
)

segment_by_sinus(object)

pad_sequence(object, pad, pad_length)

center_sequence(object, center, pad_length)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="segmentation_+3A_object">object</code></td>
<td>
<p>Object of the <code>egm</code> class, which includes header, signal
information, and annotation information.</p>
</td></tr>
<tr><td><code id="segmentation_+3A_by">by</code></td>
<td>
<p>A <code>character</code> string naming waveform type to segment by. Options
include the following:
</p>

<ul>
<li><p> sinus = Will call <code><a href="#topic+segment_by_sinus">segment_by_sinus()</a></code> on <code>egm</code> object
</p>
</li></ul>
</td></tr>
<tr><td><code id="segmentation_+3A_pad">pad</code></td>
<td>
<p><code>character</code> String to specify which side of sequence to pad (or
both). Options include <code>c("before", "after", "both")</code>.
</p>
<p>Default is <em>before</em>. If <em>center</em> is being used, then the this argument is
ignored.</p>
</td></tr>
<tr><td><code id="segmentation_+3A_pad_length">pad_length</code></td>
<td>
<p>Offers padding of the segmented beats to a maximum length,
as an <code>integer</code>. The default is <em>0L</em>, which means no padding will be
applied. If <code>pad &gt; 0</code> then will add the baseline value (specified within
the header of the signal) to either before or after the signal. You can
also choose to <code>center</code> the sequence, which will also only occur if <code>pad &gt; 0</code>. I.e., if <code>pad = 500</code> then each segmented object will be increased TO a
max length of <code>500</code>. If the maximum size is larger than the padding size,
then a warning will be issued and the sequence will be truncated.</p>
</td></tr>
<tr><td><code id="segmentation_+3A_center">center</code></td>
<td>
<p>A single Roman alphabetic letter <code>character</code> that utilizes the
annotations given in the <code>egm</code> object to center the sequence. This is found
under the <strong>type</strong> variable in the annotation table.
</p>
<p>For example, if sinus waveforms were annotated as <code>c("P", "R", "T")</code> at
their peak, then could center around <em>R</em>. This will only occur if <code>pad &gt; 0L</code>. This is case-insensitive. The amount of padding will be determined by
the <strong>pad_length</strong> argument</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Requires a 12-lead ECG that has been digitized, and input as an
<code>egm</code> object. This object must have an annotation file associated with it
that contains demarcation annotations. Please see below for approaches based
on the annotation type. Current, the following are supported:
</p>

<ul>
<li><p> sinus = supports using <em>ecgpuwave</em> as the annotator
</p>
</li></ul>



<h3>Value</h3>

<p>Returns a list of <code>egm</code> objects. Each item is a segmentation of an
<code>egm</code>, using the selected channels (if available). It will attempt to
optimize and pick the best annotations to help create consistencies between
the signal channels as possible.
</p>


<h3>Sinus beat segmentation</h3>

<p>Identify individual sinus beats on surface ECG and extract as individual
beats, returning a list of sinus beats in the form of the <code>egm</code> class. a
consistent <strong>P</strong>, <strong>R</strong>, and <strong>T</strong> wave amongst all channels. If a channel
does not have, for example, a visible <strong>T</strong> wave, it will still label it as
information gained from other channels. This is based off of the algorithm
from the annotation tool named <code>ecgpuwave</code>. Please see <code><a href="#topic+read_annotation">read_annotation()</a></code>
for further details.
</p>

<hr>
<h2 id='signal_table'>Signal tables</h2><span id='topic+signal_table'></span><span id='topic+is_signal_table'></span>

<h3>Description</h3>

<p>The <code>signal_table()</code> function modifies the <code>data.table</code> class to
work with electrical signal data. The input should be a data set of equal
number of rows. It will add a column of index positions called <code>sample</code> if
it does not already exist.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>signal_table(...)

is_signal_table(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="signal_table_+3A_...">...</code></td>
<td>
<p>A <code>list</code> of equal lengths</p>
</td></tr>
<tr><td><code id="signal_table_+3A_x">x</code></td>
<td>
<p><code>data.frame</code> A data frame of signal data</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>signal_table</code>, which is an extension of the
<code>data.table</code> class. The <code>sample</code> column is <em>invariant</em> and will always be
present. The other columns represent additional channels.
</p>

<hr>
<h2 id='wfdb'>Waveform Database (WFDB) Software Package</h2><span id='topic+wfdb'></span>

<h3>Description</h3>

<p>This implementation of WFDB is a back-end for the WFDB using a combination of
<em>python</em>, <em>C++</em>, and <em>C</em> language. The related functions are documented
separately. This serves as an overview of the conversion of WFDB formats to R
formats. In this documentation, the specific WFDB generated files will be
described.
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="wfdb_+3A_record">record</code></td>
<td>
<p>String that will be used to name the WFDB record. Cannot
include extensions, and is not a filepath. alphanumeric characters are
acceptable, as well as hyphens (-) and underscores (_)</p>
</td></tr>
<tr><td><code id="wfdb_+3A_record_dir">record_dir</code></td>
<td>
<p>File path of directory that should be used read and write
files. Defaults to current directory.</p>
</td></tr>
<tr><td><code id="wfdb_+3A_annotator">annotator</code></td>
<td>
<p>String that is the name of a WFDB-compatible annotation
type, serving as the extension for the file that is written containing that
annotation. Please see <code><a href="#topic+read_annotation">read_annotation()</a></code> and <code><a href="#topic+write_annotation">write_annotation()</a></code> for
further details.</p>
</td></tr>
<tr><td><code id="wfdb_+3A_wfdb_path">wfdb_path</code></td>
<td>
<p>Path that leads to installed <code>wfdb</code> software package on
device. Needs to be directly set using <code>set_wfdb_path()</code>. Obtained from the
system options on loading of the package, <code>getOption('wfdb_path')</code></p>
</td></tr>
<tr><td><code id="wfdb_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to the function</p>
</td></tr>
</table>


<h3>WFDB</h3>

<p>The WFDB (Waveform Database) Software Package has been developed over the
past thirty years, providing a large collection of software for processing
and analyzing physiological waveforms. The package is written in highly
portable C and can be used on all popular platforms, including GNU/Linux,
MacOS X, MS-Windows, and all versions of Unix.
</p>
<p>The foundation of the WFDB Software Package is the WFDB library,
consisting of a set of functions for reading and writing digitized signals
and annotations. These functions can be used by programs written in C, C++,
or Fortran, running under any operating system for which an ANSI/ISO C
compiler is available, including all versions of Unix, MS-DOS, MS-Windows,
the Macintosh OS, and VMS.
</p>


<h3>Data format</h3>

<p>The records that the WFDB uses have three components...
</p>

<ol>
<li><p> Signals: integer values that are at equal intervals at a certain sampling
frequency
</p>
</li>
<li><p> Header attributes: recording information such as sample number, gain,
sampling frequency
</p>
</li>
<li><p> Annotations: information about the record such as abeat
labels or alarm triggers
</p>
</li></ol>



<h3>Author(s)</h3>

<p>Original software: George Moody, Tom Pollard, Benjamin Moody <br />
R implementation: Anish S. Shah <br />
Last updated: 2024-05-22 <br />
</p>

<hr>
<h2 id='wfdb_annotations'>Read WFDB-compatible annotation file</h2><span id='topic+wfdb_annotations'></span><span id='topic+read_annotation'></span><span id='topic+write_annotation'></span><span id='topic+annotate_wfdb'></span>

<h3>Description</h3>

<p>Individual annotation types are described as both a command-line
tool for annotating WFDB-files, as well as the extension that is appended to
the <code>record</code> name to notate the type. Generally, the types of annotations
that are supported are described below:
</p>

<ul>
<li><p> atr = manually reviewed and corrected reference annotation files
</p>
</li>
<li><p> ann = general annotator file
</p>
</li>
<li><p> ecgpuwave = files contain surface ECG demarcation (P, QRS, and T waves)
</p>
</li>
<li><p> sqrs/wqrs/gqrs = standard WFDB peak detection for R waves
</p>
</li></ul>

<p>A more thorough explanation is given in the details. Additionally, files when
being read in are converted from a binary format to a textual format. The raw
data however may be inadequate, as the original annotation may be erroneous.
In these cases, an empty <code>annotation_table</code> object will be returned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_annotation(
  record,
  record_dir = ".",
  annotator,
  wfdb_path = getOption("wfdb_path"),
  begin = "00:00:00",
  end = NA_character_,
  ...
)

write_annotation(
  data,
  annotator,
  record,
  record_dir = ".",
  wfdb_path = getOption("wfdb_path"),
  ...
)

annotate_wfdb(
  record,
  record_dir,
  annotator,
  wfdb_path = getOption("wfdb_path"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wfdb_annotations_+3A_record">record</code></td>
<td>
<p>String that will be used to name the WFDB record. Cannot
include extensions, and is not a filepath. alphanumeric characters are
acceptable, as well as hyphens (-) and underscores (_)</p>
</td></tr>
<tr><td><code id="wfdb_annotations_+3A_record_dir">record_dir</code></td>
<td>
<p>File path of directory that should be used read and write
files. Defaults to current directory.</p>
</td></tr>
<tr><td><code id="wfdb_annotations_+3A_annotator">annotator</code></td>
<td>
<p>String that is the name of a WFDB-compatible annotation
type, serving as the extension for the file that is written containing that
annotation. Please see <code><a href="#topic+read_annotation">read_annotation()</a></code> and <code><a href="#topic+write_annotation">write_annotation()</a></code> for
further details.</p>
</td></tr>
<tr><td><code id="wfdb_annotations_+3A_wfdb_path">wfdb_path</code></td>
<td>
<p>Path that leads to installed <code>wfdb</code> software package on
device. Needs to be directly set using <code>set_wfdb_path()</code>. Obtained from the
system options on loading of the package, <code>getOption('wfdb_path')</code></p>
</td></tr>
<tr><td><code id="wfdb_annotations_+3A_begin">begin</code>, <code id="wfdb_annotations_+3A_end">end</code></td>
<td>
<p>A <code>character</code> in the format of <em>HH:MM:SS</em> that will be used
to help parse the time of the annotation. These parameters together create
the time range to extract. The default of <em>0</em> is a shortcut for <em>00:00:00</em>.
The <em>seconds</em> argument can include a decimal place.</p>
</td></tr>
<tr><td><code id="wfdb_annotations_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to the function</p>
</td></tr>
<tr><td><code id="wfdb_annotations_+3A_data">data</code></td>
<td>
<p>An <code>annotation_table</code> containing the 6 invariant columns required
by the <code><a href="#topic+annotation_table">annotation_table()</a></code> function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function will either read in an annotation using the <code><a href="#topic+read_annotation">read_annotation()</a></code> function in the format of an <code>annotation_table</code> object, or write to file/disk an <code>annotation_table</code> to a WFDB-compatible annotation file using the <code><a href="#topic+write_annotation">write_annotation()</a></code> function.
</p>
<p><strong>IMPORTANT</strong>: as annotation files are created by annotators that were
developed independently, there is a higher chance of an erroroneous file
being created on disk. As such, this function will note an error an return an
empty <code>annotation_table</code> at times.
</p>


<h3>Annotation files</h3>

<p>The following annotation file types are described below.
</p>


<h4><code>ecgpuwave</code></h4>

<p><code>ecgpuwave</code> analyzes an ECG signal from the specified record, detecting the
QRS complexes and locating the beginning, peak, and end of the P, QRS, and
ST-T waveforms. The output of ecgpuwave is written as a standard WFDB-format
annotation file (the extension is &quot;*.ecgpuwave&quot;, as would be expected). This
file can be converted into text format using <code>rdann</code>. Further details are
given at the <a href="https://physionet.org/content/ecgpuwave/1.3.4/">ECGPUWAVE</a>
page.
</p>
<p>The <strong>type</strong> column can be <em>p</em>, <em>t</em>, or <em>N</em> for the peak of the P wave, T
wave, and QRS (R peak) directly. The output notation also includes waveform
onset XXX and waveform offset XXX. The <strong>number</strong> column gives further
information about each of these <strong>type</strong> labels.
</p>
<p>The <strong>number</strong> column gives modifier information. If the <strong>type</strong> classifier
is a T wave annotation, the <strong>number</strong> column can be 0 (normal), 1
(inverted), 2 (positive), 3 (negative), 4 (biphasic negative-positive), 5
(biphasic positive-negative). If the <strong>type</strong> is an waveform onset or offset,
then <strong>number</strong> can be 0 (P wave), 1 (QRS complex), 2 (T wave).
</p>


<hr>
<h2 id='wfdb_io'>I/O of WFDB-compatible signal &amp; header files from EP recording systems</h2><span id='topic+wfdb_io'></span><span id='topic+write_wfdb'></span><span id='topic+read_wfdb'></span><span id='topic+read_signal'></span><span id='topic+read_header'></span>

<h3>Description</h3>

<p>This function allows for WFDB files to be read from any WFDB-compatible
system, and also allows writing out WFDB-compatible files from specific EP
recording systems, as indicated in the details section. Writing WFDB leads to
creation of both a <strong>dat</strong> (signal) and <strong>hea</strong> (header) file. These are both
required for reading in files as well.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write_wfdb(
  data,
  record,
  record_dir,
  wfdb_path = getOption("wfdb_path"),
  header = list(frequency = 250, gain = 200L, label = character()),
  info_strings = list(),
  ...
)

read_wfdb(
  record,
  record_dir = ".",
  annotator = NA_character_,
  wfdb_path = getOption("wfdb_path"),
  begin = 0,
  end = NA_integer_,
  interval = NA_integer_,
  units = "digital",
  channels = character(),
  ...
)

read_signal(
  record,
  record_dir = ".",
  wfdb_path = getOption("wfdb_path"),
  begin = 0L,
  end = NA_integer_,
  interval = NA_integer_,
  units = "digital",
  channels = character(),
  ...
)

read_header(record, record_dir = ".", wfdb_path = getOption("wfdb_path"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wfdb_io_+3A_data">data</code></td>
<td>
<p>Can either be an <code>egm</code> object, or a <code>data.frame</code> (or similar)
object. The function will appropriately set defaults based on the type.
</p>

<ul>
<li> <p><code>egm</code> = Will extract signal and header data directly from object, and thus is simplest to convert to a WFDB format
</p>
</li>
<li> <p><code>signal_table</code> = This is a customized <code>data.table</code> class that has an invariant column containing sample information.
</p>
</li>
<li> <p><code>data.frame</code> or <code>data.table</code> = Must have a column that represents a time point or index, and columns that represent signal values (preferably integers)
</p>
</li></ul>
</td></tr>
<tr><td><code id="wfdb_io_+3A_record">record</code></td>
<td>
<p>String that will be used to name the WFDB record. Cannot
include extensions, and is not a filepath. alphanumeric characters are
acceptable, as well as hyphens (-) and underscores (_)</p>
</td></tr>
<tr><td><code id="wfdb_io_+3A_record_dir">record_dir</code></td>
<td>
<p>File path of directory that should be used read and write
files. Defaults to current directory.</p>
</td></tr>
<tr><td><code id="wfdb_io_+3A_wfdb_path">wfdb_path</code></td>
<td>
<p>Path that leads to installed <code>wfdb</code> software package on
device. Needs to be directly set using <code>set_wfdb_path()</code>. Obtained from the
system options on loading of the package, <code>getOption('wfdb_path')</code></p>
</td></tr>
<tr><td><code id="wfdb_io_+3A_header">header</code></td>
<td>
<p>A header file is an optional named list of parameters that
will be used to organize and describe the signal input from the <strong>data</strong>
argument. If the <strong>type</strong> is given, specific additional elements will be
searched for, such as the low or high pass filters, colors, or other signal
attributes. At minimum, the following elements are required (as cannot be
calculated):
</p>

<ul>
<li><p> frequency = sample frequency in Hertz as <code>integer</code>
</p>
</li>
<li><p> label = vector of names for each channel as <code>character</code>
</p>
</li>
<li><p> start_time = date/time object
</p>
</li></ul>
</td></tr>
<tr><td><code id="wfdb_io_+3A_info_strings">info_strings</code></td>
<td>
<p>A <code>list</code> of strings that will be written as an appendix
to the header file, usually containing information about the channels,
(e.g. list of colors, extra labels, etc).</p>
</td></tr>
<tr><td><code id="wfdb_io_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to the function</p>
</td></tr>
<tr><td><code id="wfdb_io_+3A_annotator">annotator</code></td>
<td>
<p>String that is the name of a WFDB-compatible annotation
type, serving as the extension for the file that is written containing that
annotation. Please see <code><a href="#topic+read_annotation">read_annotation()</a></code> and <code><a href="#topic+write_annotation">write_annotation()</a></code> for
further details.</p>
</td></tr>
<tr><td><code id="wfdb_io_+3A_begin">begin</code>, <code id="wfdb_io_+3A_end">end</code>, <code id="wfdb_io_+3A_interval">interval</code></td>
<td>
<p>Timepoint as an <code>integer</code> (representing seconds),
which is converted to an index position based on sampling frequency. The
default is to start at the beginning of the record. If <code>end</code> or <code>interval</code>
are given, the earlier of the two will be returned. The <code>end</code> argument
gives a time index to read until. The <code>interval</code> argument is the length of
time past the start point.</p>
</td></tr>
<tr><td><code id="wfdb_io_+3A_units">units</code></td>
<td>
<p>A <code>character</code> string representing either <em>digital</em> (DEFAULT) or <em>physical</em>
units that should be used, if available.
</p>

<ul>
<li><p> digital = Index in sample number, signal in integers (A/D units)
</p>
</li>
<li><p> physical = Index in elapsed time, signal in decimal voltage (e.g. mV).
This will <strong>include 1 additional row over the header/column names</strong> that
describes units
</p>
</li></ul>
</td></tr>
<tr><td><code id="wfdb_io_+3A_channels">channels</code></td>
<td>
<p>Either the signal/channel in a <code>character</code> vector as a name or number.
Allows for duplication of signal or to re-order signal if needed. If
nothing is given, will default to all channels available.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Depends on if it is a reading or writing function. For writing, will
output an WFDB-based object reflecting the function. For reading, will
output an extension of a <code>data.table</code> object reflecting the underlying
function (e.g. <code>signal_table()</code> will return an object of class).
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>write_wfdb()</code>: Writes out signal and header data into a WFDB-compatible
format from R.
</p>
</li>
<li> <p><code>read_wfdb()</code>: Reads a multicomponent WFDB-formatted set of files
directly into an <code>egm</code> object. This serves to pull together
<code><a href="#topic+read_signal">read_signal()</a></code>, <code><a href="#topic+read_header">read_header()</a></code>, and <code><a href="#topic+read_annotation">read_annotation()</a></code> for simplicity.
</p>
</li>
<li> <p><code>read_signal()</code>: Specifically reads the signal data from the WFDB binary
format, returning a <code>signal_table</code> object for evaluation in the R
environment
</p>
</li>
<li> <p><code>read_header()</code>: Specifically reads the header data from the WFDB header
text format, returning a <code>header_table</code> object for evaluation in the R
environment
</p>
</li></ul>


<h3>Recording systems</h3>

<p>Type of signal data, as specified by the recording system, that are currently
supported.
</p>

<ul>
<li> <p><em>lspro</em> = LabSystem Pro, e.g. <code><a href="#topic+read_lspro">read_lspro()</a></code>
</p>
</li>
<li> <p><em>muse</em> = GE MUSE, e.g. <code><a href="#topic+read_muse">read_muse()</a></code>
</p>
</li></ul>


<hr>
<h2 id='wfdb_paths'>WFDB path utilities</h2><span id='topic+wfdb_paths'></span><span id='topic+find_wfdb_software'></span><span id='topic+set_wfdb_path'></span><span id='topic+find_wfdb_command'></span>

<h3>Description</h3>

<p>These functions are used to help find and locate commands from the
installation of WFDB. They are helpful in setting and getting path options
and specific WFDB commands. They are primarily internal helper functions, but
are documented for troubleshooting purposes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find_wfdb_software()

set_wfdb_path(.path)

find_wfdb_command(.app, .path = getOption("wfdb_path"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wfdb_paths_+3A_.path">.path</code></td>
<td>
<p>A <code>character</code> string that describes the path to the WFDB binary
directory</p>
</td></tr>
<tr><td><code id="wfdb_paths_+3A_.app">.app</code></td>
<td>
<p>The name of WFDB software command or application as a <code>character</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>These functions are helper functions to work with the user-installed
WFDB software. They do not always return an object, and are primarily used
for their side effects. They are primarily developer functions, but are
exposed to the user to help troubleshoot issues with their installation of
WFDB.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
