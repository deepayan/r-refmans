<!DOCTYPE html><html><head><title>Help for package netropy</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {netropy}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#assoc_graph'><p>Association Graphs</p></a></li>
<li><a href='#entropy_bivar'><p>Bivariate Entropy</p></a></li>
<li><a href='#entropy_trivar'><p>Trivariate Entropy</p></a></li>
<li><a href='#get_dyad_var'><p>Get Dyad Variables</p></a></li>
<li><a href='#get_triad_var'><p>Get Triad Variables</p></a></li>
<li><a href='#joint_entropy'><p>Joint Entropy</p></a></li>
<li><a href='#lawdata'><p>Law Firm</p></a></li>
<li><a href='#prediction_power'><p>Prediction Power</p></a></li>
<li><a href='#redundancy'><p>Redundant Variables &amp; Dimensionality Reduction</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Statistical Entropy Analysis of Network Data</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Statistical entropy analysis of network data as introduced by Frank and Shafie (2016) &lt;<a href="https://doi.org/10.1177%2F0759106315615511">doi:10.1177/0759106315615511</a>&gt;, and in a forthcoming book by Nowicki, Shafie and Frank (2022).</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Imports:</td>
<td>ggraph, ggplot2, igraph</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.2</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.6)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 3.0.0), rmarkdown, knitr</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-02-01 12:19:22 UTC; termehshafie</td>
</tr>
<tr>
<td>Author:</td>
<td>Termeh Shafie [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Termeh Shafie &lt;termeh@schochastics.net&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-02-02 08:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='assoc_graph'>Association Graphs</h2><span id='topic+assoc_graph'></span>

<h3>Description</h3>

<p>Draws association graphs (graphical models) based on joint entropy values
to detect and visualize different dependence structures among the variables in the dataframe.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>assoc_graph(dat, cutoff = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="assoc_graph_+3A_dat">dat</code></td>
<td>
<p>dataframe with rows as observations and columns as variables. Variables must all be observed or transformed categorical with finite range spaces.</p>
</td></tr>
<tr><td><code id="assoc_graph_+3A_cutoff">cutoff</code></td>
<td>
<p>the cutoff point for the edges to be drawn based on joint entropies. Default is 0 and draws all edges.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Draws association graphs based on given thresholds of joint entropy values
between pairs of variables represented as nodes. Thickness of edges between pairs of nodes/variables
indicates the strength of dependence between them. Isolated nodes are completely
independent and paths through certain nodes/variables indicate conditional dependencies.
</p>


<h3>Value</h3>

<p>A ggraph object with nodes representing all variables in <code>dat</code> and edges
representing (the strength of) associations between them based on joint entropies.
</p>


<h3>Author(s)</h3>

<p>Termeh Shafie
</p>


<h3>References</h3>

<p>Frank, O., &amp; Shafie, T. (2016). Multivariate entropy analysis of network data.
<em>Bulletin of Sociological Methodology/Bulletin de Méthodologie Sociologique</em>, 129(1), 45-63.
<br />
</p>
<p>Nowicki, K., Shafie, T., &amp; Frank, O. (Forthcoming 2022). <em>Statistical Entropy Analysis of Network Data</em>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+joint_entropy">joint_entropy</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(ggraph)
# use internal data set
data(lawdata)
df.att &lt;- lawdata[[4]]

# three steps of data editing:
# 1. categorize variables 'years' and 'age' based on
# approximately three equally size groups (values based on cdf)
# 2. make sure all outcomes start from the value 0 (optional)
# 3. remove variable 'senior' as it consists of only unique values (thus redundant)
df.att.ed &lt;- data.frame(
   status   = df.att$status,
   gender   = df.att$gender,
   office   = df.att$office-1,
   years    = ifelse(df.att$years&lt;=3,0,
              ifelse(df.att$years&lt;=13,1,2)),
   age      = ifelse(df.att$age&lt;=35,0,
                ifelse(df.att$age&lt;=45,1,2)),
   practice = df.att$practice,
   lawschool= df.att$lawschool-1)

# association graph based on cutoff 0.15
assoc_graph(df.att.ed, 0.15)
</code></pre>

<hr>
<h2 id='entropy_bivar'>Bivariate Entropy</h2><span id='topic+entropy_bivar'></span>

<h3>Description</h3>

<p>Computes the bivariate entropies between all pairs of (discrete) variables in a multivariate data set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>entropy_bivar(dat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="entropy_bivar_+3A_dat">dat</code></td>
<td>
<p>dataframe with rows as observations and columns as variables. Variables must all be observed or transformed categorical with finite range spaces.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The bivariate entropy <em>H(X,Y)</em> of two discrete random variables <em>X</em> and <em>Y</em>
can be used to check for functional relationships and stochastic independence between pairs of variables.
The bivariate entropy is bounded according to <br />
</p>
<p><em>H(X) &lt;= H(X,Y) &lt;= H(X) + H(Y)</em>
<br />
</p>
<p>where <em>H(X)</em> and
<em>H(Y)</em> are the univariate entropies.
</p>


<h3>Value</h3>

<p>Upper triangular matrix giving bivariate entropies between pairs of variables given as
rows and columns of the matrix. The univariate entropies are given in the diagonal.
</p>


<h3>Author(s)</h3>

<p>Termeh Shafie
</p>


<h3>References</h3>

<p>Frank, O., &amp; Shafie, T. (2016). Multivariate entropy analysis of network data.
<em>Bulletin of Sociological Methodology/Bulletin de Méthodologie Sociologique</em>, 129(1), 45-63.
<br />
</p>
<p>Nowicki, K., Shafie, T., &amp; Frank, O. (Forthcoming 2022). <em>Statistical Entropy Analysis of Network Data</em>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+joint_entropy">joint_entropy</a></code>,  <code><a href="#topic+entropy_trivar">entropy_trivar</a></code>, <code><a href="#topic+redundancy">redundancy</a></code>, <code><a href="#topic+prediction_power">prediction_power</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># use internal data set
data(lawdata)
df.att &lt;- lawdata[[4]]

# three steps of data editing:
# 1. categorize variables 'years' and 'age' based on
# approximately three equally size groups (values based on cdf)
# 2. make sure all outcomes start from the value 0 (optional)
# 3. remove variable 'senior' as it consists of only unique values (thus redundant)
df.att.ed &lt;- data.frame(
   status   = df.att$status,
   gender   = df.att$gender,
   office   = df.att$office-1,
   years    = ifelse(df.att$years&lt;=3,0,
              ifelse(df.att$years&lt;=13,1,2)),
   age      = ifelse(df.att$age&lt;=35,0,
                ifelse(df.att$age&lt;=45,1,2)),
   practice = df.att$practice,
   lawschool= df.att$lawschool-1)

# calculate bivariate entropies
H.biv &lt;- entropy_bivar(df.att.ed)
# univariate entropies are then given as
diag(H.biv)
</code></pre>

<hr>
<h2 id='entropy_trivar'>Trivariate Entropy</h2><span id='topic+entropy_trivar'></span>

<h3>Description</h3>

<p>Computes trivariate entropies of all triples of (discrete)
variables in a multivariate data set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>entropy_trivar(dat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="entropy_trivar_+3A_dat">dat</code></td>
<td>
<p>dataframe with rows as observations and columns as variables.
Variables must all be observed or transformed categorical with finite range spaces.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Trivariate entropies can be used to check for functional relationships and
stochastic independence between triples of variables.
The trivariate entropy <em>H(X,Y,Z)</em> of three discrete random variables <em>X, Y</em> and <em>Z</em>
is bounded according to <br />
</p>
<p><em>H(X,Y) &lt;= H(X,Y,Z) &lt;= H(X,Z) + H(Y,Z) - H(Z)</em>.
<br />
</p>
<p>The increment between the trivariate entropy and its lower bound is equal to the expected conditional entropy.
</p>


<h3>Value</h3>

<p>Dataframe with the first three columns representing possible triples of variables (<code>V1,V2,V3</code>)
and the fourth column gives trivariate entropies <code>H(V1,V2,V3)</code>.
</p>


<h3>Author(s)</h3>

<p>Termeh Shafie
</p>


<h3>References</h3>

<p>Frank, O., &amp; Shafie, T. (2016). Multivariate entropy analysis of network data.
<em>Bulletin of Sociological Methodology/Bulletin de Méthodologie Sociologique</em>, 129(1), 45-63.
<br />
</p>
<p>Nowicki, K., Shafie, T., &amp; Frank, O. (Forthcoming 2022). <em>Statistical Entropy Analysis of Network Data</em>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+entropy_bivar">entropy_bivar</a></code>, <code><a href="#topic+prediction_power">prediction_power</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># use internal data set
data(lawdata)
df.att &lt;- lawdata[[4]]

# three steps of data editing:
# 1. categorize variables 'years' and 'age' based on
# approximately three equally size groups (values based on cdf)
# 2. make sure all outcomes start from the value 0 (optional)
# 3. remove variable 'senior' as it consists of only unique values (thus redundant)
df.att.ed &lt;- data.frame(
   status   = df.att$status,
   gender   = df.att$gender,
   office   = df.att$office-1,
   years    = ifelse(df.att$years&lt;=3,0,
              ifelse(df.att$years&lt;=13,1,2)),
   age      = ifelse(df.att$age&lt;=35,0,
                ifelse(df.att$age&lt;=45,1,2)),
   practice = df.att$practice,
   lawschool= df.att$lawschool-1)

# calculate trivariate entropies
H.triv &lt;- entropy_trivar(df.att.ed)
</code></pre>

<hr>
<h2 id='get_dyad_var'>Get Dyad Variables</h2><span id='topic+get_dyad_var'></span>

<h3>Description</h3>

<p>Transforms vertex variables or observed directed/undirected ties
into dyad variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_dyad_var(var, type = "att")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_dyad_var_+3A_var">var</code></td>
<td>
<p>variable vector (actor attribute) or adjacency matrix (ties)
to be transformed to a dyad variable.</p>
</td></tr>
<tr><td><code id="get_dyad_var_+3A_type">type</code></td>
<td>
<p>either 'att' for actor attribute (default) or 'tie' for relations.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Dyad variables are given as pairs of incident vertex variables
or actor attributes. Here, unique pairs of original attribute values
constitute the outcome space. Note that the actor  attributes need
to be categorical with finite range spaces. For example, binary
attribute yields outcome space (0,0), (0,1), (1,0), (1,1) coded as (0),(1),(2),(3).
Warning message is shown if actor attribute has too many unique outcomes
as it will yield too many possible outcomes once converted in to a dyad variable.
<br />
</p>
<p>For directed relations, pairs of indicators from the adjacency matrix constitute
the four outcomes representing possible combinations of sending and receiving ties:
(0,0), (0,1), (1,0), (1,1) coded as (0),(1),(2),(3).
<br />
</p>
<p>For undirected relations, an indicator variable which is directly read from the
adjacency matrix represents the dyadic variable.
<br />
</p>


<h3>Value</h3>

<p>Dataframe with three columns:
first two columns show the vertex pairs <code>u</code> and <code>v</code> where <code>u&lt;v</code> ,
and the third column gives the value of the transformed dyadic variable <code>var</code>.
</p>


<h3>Author(s)</h3>

<p>Termeh Shafie
</p>


<h3>References</h3>

<p>Frank, O., &amp; Shafie, T. (2016). Multivariate entropy analysis of network data.
<em>Bulletin of Sociological Methodology/Bulletin de Méthodologie Sociologique</em>, 129(1), 45-63.
<br />
</p>
<p>Nowicki, K., Shafie, T., &amp; Frank, O. (Forthcoming 2022). <em>Statistical Entropy Analysis of Network Data</em>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+get_triad_var">get_triad_var</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># use internal data set
data(lawdata)
adj.advice &lt;- lawdata[[1]]
adj.cowork &lt;-lawdata[[3]]
df.att &lt;- lawdata[[4]]

# three steps of data editing of attribute dataframe:
# 1. categorize variables 'years' and 'age' based on
# approximately three equally size groups (values based on cdf)
# 2. make sure all outcomes start from the value 0 (optional)
# 3. remove variable 'senior' as it consists of only unique values (thus redundant)
df.att.ed &lt;- data.frame(
   status   = df.att$status,
   gender   = df.att$gender,
   office   = df.att$office-1,
   years    = ifelse(df.att$years&lt;=3,0,
              ifelse(df.att$years&lt;=13,1,2)),
   age      = ifelse(df.att$age&lt;=35,0,
                ifelse(df.att$age&lt;=45,1,2)),
   practice = df.att$practice,
   lawschool= df.att$lawschool-1)

# actor attribute converted to dyad variable
dyad.gend &lt;- get_dyad_var(df.att.ed$gender, 'att')

# directed tie converted to dyad variable
dyad.adv &lt;- get_dyad_var(adj.advice, 'tie')

# undirected tie converted to dyad variable
dyad.cwk &lt;- get_dyad_var(adj.cowork, 'tie')
</code></pre>

<hr>
<h2 id='get_triad_var'>Get Triad Variables</h2><span id='topic+get_triad_var'></span>

<h3>Description</h3>

<p>Transforms vertex variables or observed directed/undirected ties
into triad variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_triad_var(var, type = "att")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_triad_var_+3A_var">var</code></td>
<td>
<p>variable vector (actor attribute) or adjacency matrix (ties)
to be transformed to a triad variable.</p>
</td></tr>
<tr><td><code id="get_triad_var_+3A_type">type</code></td>
<td>
<p>either 'att' for actor attribute (default) or 'tie' for relations.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For actor attributes, unique triples of original attribute values
constitute the outcome space. Note that the actor
attributes need to be categorical with finite range spaces.
For example, binary attributes have 8 possible triadic outcomes
(0,0,0),(1,0,0),(0,1,0),(1,1,0),(0,0,1),(1,0,1),(0,1,1),(1,1,1)
which are coded 0-7.
Warning message is shown if actor attribute has too many unique outcomes
as it will yield too many possible outcomes once converted in to a triad variable.
<br />
</p>
<p>For directed relations, a sequence of indicators of length 6 created from the adjacency matrix
constitutes the 64 outcomes representing possible combinations of sending and receiving ties.
<br />
</p>
<p>For undirected relations, triples of indicators are created from the adjacency matrix.
<br />
</p>


<h3>Value</h3>

<p>Dataframe with four columns:
first three columns show the vertex triad <code>u</code>, <code>v</code>, <code>w</code> ,
and the fourth column gives the value of the transformed triadic variable <code>var</code>.
</p>


<h3>Author(s)</h3>

<p>Termeh Shafie
</p>


<h3>References</h3>

<p>Frank, O., &amp; Shafie, T. (2016). Multivariate entropy analysis of network data.
<em>Bulletin of Sociological Methodology/Bulletin de Méthodologie Sociologique</em>, 129(1), 45-63.
<br />
</p>
<p>Nowicki, K., Shafie, T., &amp; Frank, O. (Forthcoming 2022). <em>Statistical Entropy Analysis of Network Data</em>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+get_dyad_var">get_dyad_var</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># use internal data set
data(lawdata)
adj.advice &lt;- lawdata[[1]]
adj.cowork &lt;-lawdata[[3]]
df.att &lt;- lawdata[[4]]

# three steps of data editing:
# 1. categorize variables 'years' and 'age' based on
# approximately three equally size groups (values based on cdf)
# 2. make sure all outcomes start from the value 0 (optional)
# 3. remove variable 'senior' as it consists of only unique values (thus redundant)
df.att.ed &lt;- data.frame(
   status   = df.att$status,
   gender   = df.att$gender,
   office   = df.att$office-1,
   years    = ifelse(df.att$years&lt;=3,0,
              ifelse(df.att$years&lt;=13,1,2)),
   age      = ifelse(df.att$age&lt;=35,0,
                ifelse(df.att$age&lt;=45,1,2)),
   practice = df.att$practice,
   lawschool= df.att$lawschool-1)

# actor attribute converted to triad variable
triad.gend &lt;- get_triad_var(df.att.ed$gender, 'att')

# directed tie converted to triad variable
triad.adv &lt;- get_triad_var(adj.advice, type = 'tie')

# undirected tie converted to triad variable
triad.cwk &lt;- get_triad_var(adj.cowork, type = 'tie')
</code></pre>

<hr>
<h2 id='joint_entropy'>Joint Entropy</h2><span id='topic+joint_entropy'></span>

<h3>Description</h3>

<p>Computes the joint entropies between all pairs of (discrete)
variables in a multivariate data set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>joint_entropy(dat, dec = 3)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="joint_entropy_+3A_dat">dat</code></td>
<td>
<p>dataframe with rows as observations and columns as variables.
Variables must all be observed or transformed categorical with finite range spaces.</p>
</td></tr>
<tr><td><code id="joint_entropy_+3A_dec">dec</code></td>
<td>
<p>the precision given in number of decimals for which
the frequency distribution of unique entropy values is created. Default is 3.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The joint entropy <em>J(X,Y)</em> of discrete variables <em>X</em> and <em>Y</em>
is a measure of dependence or association between them, defined as
<br />
</p>
<p><em>J(X,Y) = H(X) + H(Y) - H(X,Y)</em>.
<br />
</p>
<p>Two variables are independent if their joint entropy,
i.e. their mutual information, is equal to zero.
The frequency distributions can be used to decide upon convenient thresholds for
constructing association graphs.
</p>


<h3>Value</h3>

<p>List with
</p>
<table>
<tr><td><code>matrix</code></td>
<td>
<p>an upper triangular joint entropy matrix (univariate entropies in the diagonal).</p>
</td></tr>
<tr><td><code>freq</code></td>
<td>
<p>a dataframe giving the frequency distributions of unique joint entropy values.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Termeh Shafie
</p>


<h3>References</h3>

<p>Frank, O., &amp; Shafie, T. (2016). Multivariate entropy analysis of network data.
<em>Bulletin of Sociological Methodology/Bulletin de Méthodologie Sociologique</em>, 129(1), 45-63.
<br />
</p>
<p>Nowicki, K., Shafie, T., &amp; Frank, O. (Forthcoming 2022). <em>Statistical Entropy Analysis of Network Data</em>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+assoc_graph">assoc_graph</a></code>, <code><a href="#topic+entropy_bivar">entropy_bivar</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># use internal data set
data(lawdata)
df.att &lt;- lawdata[[4]]

# three steps of data editing:
# 1. categorize variables 'years' and 'age' based on
# approximately three equally size groups (values based on cdf)
# 2. make sure all outcomes start from the value 0 (optional)
# 3. remove variable 'senior' as it consists of only unique values (thus redundant)
df.att.ed &lt;- data.frame(
   status   = df.att$status,
   gender   = df.att$gender,
   office   = df.att$office-1,
   years    = ifelse(df.att$years&lt;=3,0,
              ifelse(df.att$years&lt;=13,1,2)),
   age      = ifelse(df.att$age&lt;=35,0,
                ifelse(df.att$age&lt;=45,1,2)),
   practice = df.att$practice,
   lawschool= df.att$lawschool-1)

# calculate joint entropies
J &lt;- joint_entropy(df.att.ed)
# joint entropy matrix
J$matrix
# frequency distribution of joint entropy values
J$freq
</code></pre>

<hr>
<h2 id='lawdata'>Law Firm</h2><span id='topic+lawdata'></span>

<h3>Description</h3>

<p>This data set comes from a network study of corporate
law partnership that was carried out in a Northeastern US corporate law firm,
referred to as SG&amp;R, 1988-1991 in New England.
It includes (among others) measurements of networks among the
71 attorneys (partners and associates) of this firm,
i.e. their strong- co-worker network, advice network, friendship network,
and indirect control networks.
Various members' attributes are also part of the data set,
including seniority, formal status, office in which they work, gender,
law school attended. The ethnography, organizational and network analyses
of this case are available in Lazega (2001).
</p>
<p><strong>Basic advice network</strong>:
&quot;Think back over the past year, consider all the lawyers in your Firm. To whom did you go for basic professional advice? For instance, you want to make sure that you are handling a case right, making a proper decision, and you want to consult someone whose professional opinions are in general of great value to you. By advice I do not mean simply technical advice.&quot;
</p>
<p><strong>Friendship network:</strong>
&quot;Would you go through this list, and check the names of those you socialize with outside work. You know their family, they know yours, for instance. I do not mean all the people you are simply on a friendly level with, or people you happen to meet at Firm functions.&quot;
</p>
<p><strong>Strong coworkers network:</strong>
&quot;Because most firms like yours are also organized very informally, it is difficult to get a clear idea of how the members really work together. Think back over the past year, consider all the lawyers in your Firm. Would you go through this list and check the names of those with whom you have worked with. (By &quot;worked with&quot; I mean that you have spent time together on at least one case, that you have been assigned to the same case, that they read or used your work product or that you have read or used their work product; this includes professional work done within the Firm like Bar association work, administration, etc.)&quot;
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(lawdata)
</code></pre>


<h3>Format</h3>

<p>List containing the following objects as numbered
</p>

<ol>
<li><p>adjacency matrix for advice seeking (directed)
</p>
</li>
<li><p>adjacency matrix for friendship (directed)
</p>
</li>
<li><p>adjacency matrix for cowork (undirected)
</p>
</li>
<li><p>dataframe with the following attributes on each lawyer:
</p>

<ul>
<li><p><code>senior</code> seniority (ranked from most to least senior)
</p>
</li>
<li><p><code>status</code> 1=partner; 2=associate
</p>
</li>
<li><p><code>gender</code> 1=man; 2=woman
</p>
</li>
<li><p><code>office</code> 1=Boston; 2=Hartford; 3=Providence
</p>
</li>
<li><p><code>years</code> years with the firm
</p>
</li>
<li><p><code>age</code> age of attorney
</p>
</li>
<li><p><code>practice</code> 1=litigation; 2=corporate
</p>
</li>
<li><p><code>lawschool</code> 1=harvard/yale; 2=ucon; 3= other
</p>
</li></ul>

<p>Note: the first 36 out of 71 respondents are the partners in the firm.
</p>
</li></ol>



<h3>Source</h3>

<p>https://www.stats.ox.ac.uk/~snijders/siena/Lazega_lawyers_data.htm
</p>


<h3>References</h3>

<p>Emmanuel Lazega, <em>The Collegial Phenomenon: The Social Mechanisms of Cooperation Among Peers in a Corporate Law Partnership</em>, Oxford University Press (2001).
</p>
<p>Tom A.B. Snijders, Philippa E. Pattison, Garry L. Robins, and Mark S. Handcock. New specifications for exponential random graph models. <em>Sociological Methodology</em> (2006), 99-153.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(lawdata)
## assign the correct names to the objects in the list
adj.advice &lt;- lawdata[[1]]
adj.friend &lt;- lawdata[[2]]
adj.cowork &lt;-lawdata[[3]]
df.att &lt;- lawdata[[4]]

</code></pre>

<hr>
<h2 id='prediction_power'>Prediction Power</h2><span id='topic+prediction_power'></span>

<h3>Description</h3>

<p>Computes prediction power when pairs of variables in a given dataframe are used
to predict a third variable from the same dataframe. The prediction strength is measured by
expected conditional entropies.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prediction_power(var, dat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prediction_power_+3A_var">var</code></td>
<td>
<p>character string representing the variable in
dataframe <code>dat</code> to be predicted by pairs of other variables in the dataframe <code>dat</code>.</p>
</td></tr>
<tr><td><code id="prediction_power_+3A_dat">dat</code></td>
<td>
<p>dataframe with rows as observations and columns as variables.
Variables must all be observed or transformed categorical with finite range spaces.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The expected conditional entropy given by<br />
</p>
<p><em>EH(Z|X,Y) = H(X,Y,Z) - H(X, Y)</em> <br />
</p>
<p>measures the prediction uncertainty when pairs of variables <em>X</em> and <em>Y</em>
are used to predict variable <em>Z</em>.
The lower the value of <em>EH</em> given different pairs of variables <em>X</em> and <em>Y</em>,
the stronger is the prediction of <em>Z</em>.
</p>


<h3>Value</h3>

<p>Upper triangular matrix giving the expected conditional entropies of pairs of variables
given as rows and columns of the matrix. The diagonal gives <em>EH(Z|X) = H(X,Z) - H(X)</em>, that is
when only one variable is used to predict <code>var</code>. Note that <code>NA</code>'s are in the entire
row and column representing the variable being predicted.
</p>


<h3>Author(s)</h3>

<p>Termeh Shafie
</p>


<h3>References</h3>

<p>Frank, O., &amp; Shafie, T. (2016). Multivariate entropy analysis of network data.
<em>Bulletin of Sociological Methodology/Bulletin de Méthodologie Sociologique</em>, 129(1), 45-63.
<br />
</p>
<p>Nowicki, K., Shafie, T., &amp; Frank, O. (Forthcoming 2022). <em>Statistical Entropy Analysis of Network Data</em>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+entropy_trivar">entropy_trivar</a></code>, <code><a href="#topic+entropy_bivar">entropy_bivar</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># use internal data set
data(lawdata)
df.att &lt;- lawdata[[4]]

# three steps of data editing:
# 1. categorize variables 'years' and 'age' based on
# approximately three equally size groups (values based on cdf)
# 2. make sure all outcomes start from the value 0 (optional)
# 3. remove variable 'senior' as it consists of only unique values (thus redundant)
df.att.ed &lt;- data.frame(
   status   = df.att$status,
   gender   = df.att$gender,
   office   = df.att$office-1,
   years    = ifelse(df.att$years&lt;=3,0,
              ifelse(df.att$years&lt;=13,1,2)),
   age      = ifelse(df.att$age&lt;=35,0,
                ifelse(df.att$age&lt;=45,1,2)),
   practice = df.att$practice,
   lawschool= df.att$lawschool-1)

# power of predicting 'status' using pairs of other variables
prediction_power('status', df.att.ed)
</code></pre>

<hr>
<h2 id='redundancy'>Redundant Variables &amp; Dimensionality Reduction</h2><span id='topic+redundancy'></span>

<h3>Description</h3>

<p>Finds redundant variables in a dataframe consisting of discrete variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>redundancy(dat, dec = 3)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="redundancy_+3A_dat">dat</code></td>
<td>
<p>dataframe with rows as observations and columns as variables.
Variables must all be observed or transformed categorical with finite range spaces.</p>
</td></tr>
<tr><td><code id="redundancy_+3A_dec">dec</code></td>
<td>
<p>the precision given as number of decimals used to round bivariate entropies
in order to find redundant variables (the more decimals, the harder to detect redundancy). Default is 3.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Redundancy is defined as two variables holding the same information (bivariate entropies)
as at least one of the variable alone (univariate entropies).
Consider removing one of these two variable from the dataframe for further analysis.
</p>


<h3>Value</h3>

<p>Binary matrix indicating which row and column variables hold the same information.
</p>


<h3>Author(s)</h3>

<p>Termeh Shafie
</p>


<h3>References</h3>

<p>Frank, O., &amp; Shafie, T. (2016). Multivariate entropy analysis of network data.
<em>Bulletin of Sociological Methodology/Bulletin de Méthodologie Sociologique</em>, 129(1), 45-63.
<br />
</p>
<p>Nowicki, K., Shafie, T., &amp; Frank, O. (Forthcoming 2022). <em>Statistical Entropy Analysis of Network Data</em>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+entropy_bivar">entropy_bivar</a></code>,
</p>


<h3>Examples</h3>

<pre><code class='language-R'># use internal data set
data(lawdata)
df.att &lt;- lawdata[[4]]

# two steps of data editing:
# 1. categorize variables 'years' and 'age' based on
# approximately three equally size groups (values based on cdf)
# 2. make sure all outcomes start from the value 0 (optional)
df.att.ed &lt;- data.frame(
   senior   = df.att$senior,
   status   = df.att$status,
   gender   = df.att$gender,
   office   = df.att$office-1,
   years    = ifelse(df.att$years&lt;=3,0,
              ifelse(df.att$years&lt;=13,1,2)),
   age      = ifelse(df.att$age&lt;=35,0,
                ifelse(df.att$age&lt;=45,1,2)),
   practice = df.att$practice,
   lawschool= df.att$lawschool-1)

# find redundant variables in dataframe
redundancy(df.att.ed) # variable 'senior' should be omitted
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
