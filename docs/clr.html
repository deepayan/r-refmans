<!DOCTYPE html><html><head><title>Help for package clr</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {clr}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#clr-package'><p>Curve Linear Regression</p></a></li>
<li><a href='#clr'><p>Curve Linear Regression via dimension reduction</p></a></li>
<li><a href='#clrdata'><p>Create an object of <code>clrdata</code></p></a></li>
<li><a href='#clust_test'><p>Electricity load example: clusters on test set</p></a></li>
<li><a href='#clust_train'><p>Electricity load example: clusters on train set</p></a></li>
<li><a href='#gb_load'><p>Electricity load from Great Britain</p></a></li>
<li><a href='#predict.clr'><p>Prediction from fitted CLR model(s)</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Curve Linear Regression via Dimension Reduction</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.2</td>
</tr>
<tr>
<td>Author:</td>
<td>Amandine Pierrot 
    with contributions and/or help from Qiwei Yao, Haeran Cho, Yannig Goude and 
    Tony Aldon.</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Amandine Pierrot &lt;amandine.m.pierrot@gmail.com&gt;</td>
</tr>
<tr>
<td>Copyright:</td>
<td>EDF R&amp;D 2017</td>
</tr>
<tr>
<td>Description:</td>
<td>A new methodology for linear regression with both curve response 
    and curve regressors, which is described in Cho, Goude, Brossat and Yao 
    (2013) &lt;<a href="https://doi.org/10.1080%2F01621459.2012.722900">doi:10.1080/01621459.2012.722900</a>&gt; and (2015) 
    &lt;<a href="https://doi.org/10.1007%2F978-3-319-18732-7_3">doi:10.1007/978-3-319-18732-7_3</a>&gt;. The key idea behind this methodology is 
    dimension reduction based on a singular value decomposition in a Hilbert 
    space, which reduces the curve regression problem to several scalar linear 
    regression problems. </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/LGPL-2">LGPL-2</a> | <a href="https://www.r-project.org/Licenses/LGPL-2.1">LGPL-2.1</a> | <a href="https://www.r-project.org/Licenses/LGPL-3">LGPL-3</a> [expanded from: LGPL (&ge; 2.0)]</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.1.1</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>Imports:</td>
<td>magrittr, lubridate, dplyr, stats</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2019-07-10 10:42:17 UTC; amandinepierrot</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2019-07-29 09:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='clr-package'>Curve Linear Regression</h2><span id='topic+clr-package'></span>

<h3>Description</h3>

<p><code>clr</code> provides functions for curve linear regression via dimension
reduction.
</p>


<h3>Details</h3>

<p>The package implements a new methodology for linear regression with both
curve response and curve regressors, which is described in Cho et al. (2013)
and Cho et al. (2015).
The CLR model performs a data-driven dimension reduction, based on a
singular value decomposition in a Hilbert Space, as well as a data
transformation so that the relationship between the transformed data is
linear and can be captured by simple regression models.
</p>


<h3>Author(s)</h3>

<p>Amandine Pierrot &lt;amandine.m.pierrot@gmail.com&gt;
</p>
<p>with contributions and help from Qiwei Yao, Haeran Cho, Yannig Goude and
Tony Aldon.
</p>


<h3>References</h3>

<p>These provide details for the underlying <code>clr</code> methods.
</p>
<p>Cho, H., Y. Goude, X. Brossat, and Q. Yao (2013) Modelling and Forecasting
Daily Electricity Load Curves: A Hybrid Approach. Journal of the American
Statistical Association 108: 7-21.
</p>
<p>Cho, H., Y. Goude, X. Brossat, and Q. Yao (2015) Modelling and Forecasting
Daily Electricity Load via Curve Linear Regression. In <em>Modeling and
Stochastic Learning for Forecasting in High Dimension</em>, edited by Anestis
Antoniadis and Xavier Brossat, 35-54, Springer.
</p>

<hr>
<h2 id='clr'>Curve Linear Regression via dimension reduction</h2><span id='topic+clr'></span>

<h3>Description</h3>

<p>Fits a curve linear regression (CLR) model to data, using dimension
reduction based on singular value decomposition.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clr(Y, X, clust = NULL, qx_estimation = list(method = "pctvar", param =
  0.999), ortho_Y = TRUE, qy_estimation = list(method = "pctvar", param
  = 0.999), d_estimation = list(method = "cor", param = 0.5))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="clr_+3A_y">Y</code></td>
<td>
<p>An object of class <code>clrdata</code> or <code>matrix</code>, of the response
curves (one curve a row).</p>
</td></tr>
<tr><td><code id="clr_+3A_x">X</code></td>
<td>
<p>An object of class <code>clrdata</code> or <code>matrix</code>, of the regressor
curves (one curve a row).</p>
</td></tr>
<tr><td><code id="clr_+3A_clust">clust</code></td>
<td>
<p>If needed, a list of row indices for each cluster, to obtain
(approximately) homogeneous dependence structure inside each cluster.</p>
</td></tr>
<tr><td><code id="clr_+3A_qx_estimation">qx_estimation</code></td>
<td>
<p>A list containing both values for 'method' (among
'ratio', 'ratioM', 'pctvar', 'fixed') and for 'param' (depending on the
selected method), in order to choose how to estimate the dimension of X (in
the sense that its Karhunen-Lo\'eve decomposition has qx terms only.</p>
</td></tr>
<tr><td><code id="clr_+3A_ortho_y">ortho_Y</code></td>
<td>
<p>If TRUE then Y is orthogonalized.</p>
</td></tr>
<tr><td><code id="clr_+3A_qy_estimation">qy_estimation</code></td>
<td>
<p>Same as for qx_estimation, if ortho_Y is set to TRUE.</p>
</td></tr>
<tr><td><code id="clr_+3A_d_estimation">d_estimation</code></td>
<td>
<p>A list containing both values for 'method' (among
'ratio', 'pctvar', 'cor') and for 'param' (depending on the
selected method), in order to choose how to estimate the correlation
dimension.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>clr</code>, which can be used to compute
predictions.
This <code>clr</code> object is a list of lists: one list by cluster of data, each
list including:
</p>
<table>
<tr><td><code>residuals</code></td>
<td>
<p>The matrix of the residuals of d_hat simple linear
regressions.</p>
</td></tr>
<tr><td><code>b_hat</code></td>
<td>
<p>The vector of the estimated coefficient of the d_hat simple
straight line regressions.</p>
</td></tr>
<tr><td><code>eta</code></td>
<td>
<p>The matrix of the projections of X.</p>
</td></tr>
<tr><td><code>xi</code></td>
<td>
<p>The matrix of the projections of Y.</p>
</td></tr>
<tr><td><code>qx_hat</code></td>
<td>
<p>The estimated dimension of X.</p>
</td></tr>
<tr><td><code>qy_hat</code></td>
<td>
<p>The estimated dimension of Y.</p>
</td></tr>
<tr><td><code>d_hat</code></td>
<td>
<p>The estimated correlation dimension.</p>
</td></tr>
<tr><td><code>X_mean</code></td>
<td>
<p>The mean of the regressor curves.</p>
</td></tr>
<tr><td><code>X_sd</code></td>
<td>
<p>The standard deviation of the regressor curves.</p>
</td></tr>
<tr><td><code>Y_mean</code></td>
<td>
<p>The mean of the response curves.</p>
</td></tr>
<tr><td><code>ortho_Y</code></td>
<td>
<p>The value which was selected for ortho_Y.</p>
</td></tr>
<tr><td><code>GAMMA</code></td>
<td>
<p>The standardized transformation for X.</p>
</td></tr>
<tr><td><code>INV_DELTA</code></td>
<td>
<p>The standardized transformation for Y to predict if ortho_Y
was set to TRUE.</p>
</td></tr>
<tr><td><code>phi</code></td>
<td>
<p>The eigenvectors for Y to predict if ortho_Y was set to FALSE.</p>
</td></tr>
<tr><td><code>idx</code></td>
<td>
<p>The indices of the rows selected from X and Y for the current
cluster.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+clr-package">clr-package</a></code>, <code><a href="#topic+clrdata">clrdata</a></code> and
<code><a href="#topic+predict.clr">predict.clr</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(clr)
data(gb_load)
data(clust_train)

clr_load &lt;- clrdata(x = gb_load$ENGLAND_WALES_DEMAND,
                    order_by = gb_load$TIMESTAMP,
                    support_grid = 1:48)

## data cleaning: replace zeros with NA
clr_load[rowSums((clr_load == 0) * 1) &gt; 0, ] &lt;- NA
matplot(t(clr_load), ylab = 'Daily loads', type = 'l')

Y &lt;- clr_load[2:nrow(clr_load), ]
X &lt;- clr_load[1:(nrow(clr_load) - 1), ]

begin_pred &lt;- which(substr(rownames(Y), 1, 4) == '2016')[1]
Y_train &lt;- Y[1:(begin_pred - 1), ]
X_train &lt;- X[1:(begin_pred - 1), ]

## Example without any cluster
model &lt;- clr(Y = Y_train, X = X_train)

## Example with clusters
model &lt;- clr(Y = Y_train, X = X_train, clust = clust_train)
</code></pre>

<hr>
<h2 id='clrdata'>Create an object of <code>clrdata</code></h2><span id='topic+clrdata'></span>

<h3>Description</h3>

<p><code>clrdata</code> is used to create a <code>clrdata</code> object from raw data
inputs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clrdata(x, order_by, support_grid)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="clrdata_+3A_x">x</code></td>
<td>
<p>A vector containing the time series values</p>
</td></tr>
<tr><td><code id="clrdata_+3A_order_by">order_by</code></td>
<td>
<p>A corresponding vector of unique time-dates - must be of
class 'POSIXct'</p>
</td></tr>
<tr><td><code id="clrdata_+3A_support_grid">support_grid</code></td>
<td>
<p>A vector corresponding to the support grid of functional
data</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>clrdata</code> with one function a row. As it
inherits the <code>matrix</code> class, all <code>matrix</code> methods remain valid.
If time-dates are missing in x, corresponding NA functions are added by
<code>clrdata</code> so that time sequence is preserved between successive rows.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(clr)
data(gb_load)

clr_load &lt;- clrdata(x = gb_load$ENGLAND_WALES_DEMAND,
                    order_by = gb_load$TIMESTAMP,
                    support_grid = 1:48)

head(clr_load)
dim(clr_load)
summary(clr_load)

matplot(t(clr_load), ylab = 'Daily loads', type = 'l')
lines(colMeans(clr_load, na.rm = TRUE),
      col = 'black', lwd = 2)


clr_weather &lt;- clrdata(x = gb_load$TEMPERATURE,
                       order_by = gb_load$TIMESTAMP,
                       support_grid = 1:48)
summary(clr_weather)
plot(1:48,
     colMeans(clr_weather, na.rm = TRUE),
     xlab = 'Instant', ylab = 'Mean of temperatures',
     type = 'l', col = 'cornflowerblue')
</code></pre>

<hr>
<h2 id='clust_test'>Electricity load example: clusters on test set</h2><span id='topic+clust_test'></span>

<h3>Description</h3>

<p>A list with observations by cluster for prediction
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clust_test
</code></pre>


<h3>Format</h3>

<p>A list of length 14: </p>

<p>14 clusters of loads, depending on both daily and seasonal classification,
banking holidays being removed</p>


<h3>Author(s)</h3>

<p>Amandine Pierrot &lt;amandine.m.pierrot@gmail.com&gt;
</p>

<hr>
<h2 id='clust_train'>Electricity load example: clusters on train set</h2><span id='topic+clust_train'></span>

<h3>Description</h3>

<p>A list with observations by cluster for fitting
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clust_train
</code></pre>


<h3>Format</h3>

<p>A list of length 14: </p>

<p>14 clusters of loads, depending on both daily and seasonal classification,
banking holidays being removed</p>


<h3>Author(s)</h3>

<p>Amandine Pierrot &lt;amandine.m.pierrot@gmail.com&gt;
</p>

<hr>
<h2 id='gb_load'>Electricity load from Great Britain</h2><span id='topic+gb_load'></span>

<h3>Description</h3>

<p>A dataset containing half-hourly electricity load from Great Britain from
2011 to 2016, together with observed temperatures. Temperatures are computed
from weather stations all over the country. It is a weighted averaged
temperature depending on population geographical distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gb_load
</code></pre>


<h3>Format</h3>

<p>A data frame with 105216 rows and 7 variables: </p>

<dl>
<dt>SETTLEMENT_DATE</dt><dd><p>date, the time zone being Europe/London</p>
</dd>
<dt>SETTLEMENT_PERIOD</dt><dd><p>time of the day</p>
</dd>
<dt>TIMESTAMP</dt><dd><p>date-time, the time zone being Europe/London</p>
</dd>
<dt>ENGLAND_WALES_DEMAND</dt><dd><p>British electric load, measured in MW, on
average over the half hour</p>
</dd>
<dt>TEMPERATURE</dt><dd><p>observed temperature in Celsius</p>
</dd>
<dt>MV</dt><dd><p>percentage of missing values when averaging over weather stations,
depending on the weight of the station</p>
</dd>
<dt>DAY_TYPE</dt><dd><p>type of the day of the week, from 1 for Sunday to 7 for
Saturday, 8 being banking holidays</p>
</dd></dl>


<h3>Author(s)</h3>

<p>Amandine Pierrot &lt;amandine.m.pierrot@gmail.com&gt;
</p>


<h3>Source</h3>

<p><a href="http://www2.nationalgrid.com/UK/Industry-information/Electricity-transmission-operational-data/Data-Explorer/">National Grid</a><br />
<a href="https://gis.ncdc.noaa.gov/maps/ncei/cdo/alltimes">National Centers for Environmental Information</a>
</p>

<hr>
<h2 id='predict.clr'>Prediction from fitted CLR model(s)</h2><span id='topic+predict.clr'></span>

<h3>Description</h3>

<p>Takes a fitted <code>clr</code> object produced by <code>clr()</code> and produces
predictions given a new set of functions or the original values used for
the model fit.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'clr'
predict(object, newX = NULL, newclust = NULL,
  newXmean = NULL, simplify = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.clr_+3A_object">object</code></td>
<td>
<p>A fitted <code>clr</code> object produced by <code>clr()</code>.</p>
</td></tr>
<tr><td><code id="predict.clr_+3A_newx">newX</code></td>
<td>
<p>An object of class <code>clrdata</code> or a matrix with one function a
row. If this is not provided then predictions corresponding to the original
data are returned. If <code>newX</code> is provided then it should contain the
same type of functions as the original ones (same dimension, same clusters
eventually, ...).</p>
</td></tr>
<tr><td><code id="predict.clr_+3A_newclust">newclust</code></td>
<td>
<p>A new list of indices to obtain (approximately) homogeneous
dependence structure inside each cluster of functions.</p>
</td></tr>
<tr><td><code id="predict.clr_+3A_newxmean">newXmean</code></td>
<td>
<p>To complete when done</p>
</td></tr>
<tr><td><code id="predict.clr_+3A_simplify">simplify</code></td>
<td>
<p>If TRUE, one matrix of predicted functions is returned
instead of a list of matrices (one matrix by cluster). In the final matrix,
rows are sorted by increasing row numbers.</p>
</td></tr>
<tr><td><code id="predict.clr_+3A_...">...</code></td>
<td>
<p>Further arguments are ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>predicted functions
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(clr)
data(gb_load)

clr_load &lt;- clrdata(x = gb_load$ENGLAND_WALES_DEMAND,
                    order_by = gb_load$TIMESTAMP,
                    support_grid = 1:48)

# data cleaning: replace zeros with NA
clr_load[rowSums((clr_load == 0) * 1) &gt; 0, ] &lt;- NA

Y &lt;- clr_load[2:nrow(clr_load), ]
X &lt;- clr_load[1:(nrow(clr_load) - 1), ]

begin_pred &lt;- which(substr(rownames(Y), 1, 4) == '2016')[1]
Y_train &lt;- Y[1:(begin_pred - 1), ]
X_train &lt;- X[1:(begin_pred - 1), ]
Y_test &lt;- Y[begin_pred:nrow(Y), ]
X_test &lt;- X[begin_pred:nrow(X), ]


## Example without any cluster
model &lt;- clr(Y = Y_train, X = X_train)

pred_on_train &lt;- predict(model)
head(pred_on_train[[1]])

pred_on_test &lt;- predict(model, newX = X_test)
head(pred_on_test[[1]])


## Example with clusters
model &lt;- clr(Y = Y_train, X = X_train, clust = clust_train)

pred_on_train &lt;- predict(model)
str(pred_on_train)
head(pred_on_train[[1]])

pred_on_test &lt;- predict(model, newX = X_test, newclust = clust_test,
                        simplify = TRUE)
str(pred_on_test)
head(pred_on_test)

# With dates as row names
rownames(pred_on_test) &lt;- rownames(Y_test)[as.numeric(rownames(pred_on_test))]
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
