<!DOCTYPE html><html lang="en"><head><title>Help for package GET</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {GET}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#GET-package'><p>Global Envelopes</p></a></li>
<li><a href='#abide_9002_23'><p>Local brain activity at resting state</p></a></li>
<li><a href='#adult_trees'><p>Adult trees data set</p></a></li>
<li><a href='#as.curve_set'><p>Convert an envelope or fdata object to a curve_set object</p></a></li>
<li><a href='#central_region'><p>Central region / Global envelope</p></a></li>
<li><a href='#cgec'><p>Centred government expenditure centralization ratios</p></a></li>
<li><a href='#combined_scaled_MAD_envelope_test'><p>Combined global scaled maximum absolute difference (MAD) envelope tests</p></a></li>
<li><a href='#create_image_set'><p>Create a curve set of images</p></a></li>
<li><a href='#crop_curves'><p>Crop the curves</p></a></li>
<li><a href='#curve_set'><p>Create a curve_set object</p></a></li>
<li><a href='#deviation_test'><p>Deviation test</p></a></li>
<li><a href='#fallen_trees'><p>Fallen trees</p></a></li>
<li><a href='#fBoxplot'><p>Functional boxplot</p></a></li>
<li><a href='#fclustering'><p>Functional clustering</p></a></li>
<li><a href='#fdr_envelope'><p>The FDR envelope</p></a></li>
<li><a href='#forder'><p>Functional ordering</p></a></li>
<li><a href='#frank.fanova'><p>Rank envelope F-test</p></a></li>
<li><a href='#frank.flm'><p>F rank functional GLM</p></a></li>
<li><a href='#GDP'><p>GDP</p></a></li>
<li><a href='#GDPtax'><p>GDP per capita with country groups and profit tax</p></a></li>
<li><a href='#geom_central_region'><p>Central region plot</p></a></li>
<li><a href='#GET.composite'><p>Adjusted global envelope tests</p></a></li>
<li><a href='#GET.distrequal'><p>Graphical n sample test of correspondence of distribution functions</p></a></li>
<li><a href='#GET.distrindep'><p>Test of independence of two general distributions</p></a></li>
<li><a href='#GET.localcor'><p>The test of local correlations</p></a></li>
<li><a href='#GET.spatialF'><p>Testing global and local dependence of point patterns on covariates</p></a></li>
<li><a href='#GET.variogram'><p>Variogram and residual variogram with global envelopes</p></a></li>
<li><a href='#global_envelope_test'><p>Global envelope test</p></a></li>
<li><a href='#global_rq'><p>Global quantile regression</p></a></li>
<li><a href='#graph.fanova'><p>One-way graphical functional ANOVA</p></a></li>
<li><a href='#graph.flm'><p>Graphical functional GLM</p></a></li>
<li><a href='#imageset3'><p>A simulated set of images</p></a></li>
<li><a href='#is.curve_set'><p>Check class.</p></a></li>
<li><a href='#naturalness'><p>Simulated data set</p></a></li>
<li><a href='#partial_forder'><p>Functional ordering in parts</p></a></li>
<li><a href='#plot.combined_fboxplot'><p>Plot method for the class 'combined_fboxplot'</p></a></li>
<li><a href='#plot.combined_global_envelope'><p>Plot method for the class 'combined_global_envelope'</p></a></li>
<li><a href='#plot.combined_global_envelope2d'><p>Plotting function for combined 2d global envelopes</p></a></li>
<li><a href='#plot.curve_set'><p>Plot method for the class 'curve_set'</p></a></li>
<li><a href='#plot.curve_set2d'><p>Plot method for the class 'curve_set2d'</p></a></li>
<li><a href='#plot.fboxplot'><p>Plot method for the class 'fboxplot'</p></a></li>
<li><a href='#plot.fclust'><p>Plot method for the class 'fclust'</p></a></li>
<li><a href='#plot.global_envelope'><p>Plot method for the class 'global_envelope'</p></a></li>
<li><a href='#plot.global_envelope2d'><p>Plotting function for 2d global envelopes</p></a></li>
<li><a href='#popgrowthmillion'><p>Population growth</p></a></li>
<li><a href='#print.combined_fboxplot'><p>Print method for the class 'combined_fboxplot'</p></a></li>
<li><a href='#print.combined_global_envelope'><p>Print method for the class 'combined_global_envelope'</p></a></li>
<li><a href='#print.curve_set'><p>Print method for the class 'curve_set'</p></a></li>
<li><a href='#print.deviation_test'><p>Print method for the class 'deviation_test'</p></a></li>
<li><a href='#print.fboxplot'><p>Print method for the class 'fboxplot'</p></a></li>
<li><a href='#print.fclust'><p>Print method for the class 'fclust'</p></a></li>
<li><a href='#print.fdr_envelope'><p>Print method for the class 'fdr_envelope'</p></a></li>
<li><a href='#print.GET_contingency'><p>Print method for the class 'GET_contingency'</p></a></li>
<li><a href='#print.global_envelope'><p>Print method for the class 'global_envelope'</p></a></li>
<li><a href='#qdir_envelope'><p>Global scaled maximum absolute difference (MAD) envelope tests</p></a></li>
<li><a href='#rank_envelope'><p>The rank envelope test</p></a></li>
<li><a href='#residual'><p>Residual form of the functions</p></a></li>
<li><a href='#rimov'><p>Year temperature curves</p></a></li>
<li><a href='#roadcrash'><p>Road crashes</p></a></li>
<li><a href='#saplings'><p>Saplings data set</p></a></li>
<li><a href='#StatCentralRegion'><p>Central region plot</p></a></li>
<li><a href='#subset.curve_set'><p>Subsetting curve sets</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Version:</td>
<td>1.0-4</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-11-30</td>
</tr>
<tr>
<td>Title:</td>
<td>Global Envelopes</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Mari Myllymäki &lt;mari.myllymaki@luke.fi&gt;</td>
</tr>
<tr>
<td>Imports:</td>
<td>cluster, ggplot2, grDevices, grid, gridExtra, parallel, stats,
utils, viridisLite</td>
</tr>
<tr>
<td>Suggests:</td>
<td>crayon, datasets, geoR, gstat, fda, fda.usc, locfit, mvtnorm,
patchwork, quantreg, R.rsp, sp, spatstat.geom,
spatstat.explore, spatstat.model, spatstat.linnet, testthat</td>
</tr>
<tr>
<td>Description:</td>
<td>Implementation of global envelopes for a set of general d-dimensional vectors T
    in various applications. A 100(1-alpha)% global envelope is a band bounded by two
    vectors such that the probability that T falls outside this envelope in any of the d
    points is equal to alpha. Global means that the probability is controlled simultaneously
    for all the d elements of the vectors. The global envelopes can be used for graphical
    Monte Carlo and permutation tests where the test statistic is a multivariate vector or
    function (e.g. goodness-of-fit testing for point patterns and random sets, functional
    analysis of variance, functional general linear model, n-sample test of correspondence
    of distribution functions), for central regions of functional or multivariate data (e.g.
    outlier detection, functional boxplot) and for global confidence and prediction bands
    (e.g. confidence band in polynomial regression, Bayesian posterior prediction). See
    Myllymäki and Mrkvička (2024) &lt;<a href="https://doi.org/10.18637%2Fjss.v111.i03">doi:10.18637/jss.v111.i03</a>&gt;,
    Myllymäki et al. (2017) &lt;<a href="https://doi.org/10.1111%2Frssb.12172">doi:10.1111/rssb.12172</a>&gt;,
    Mrkvička and Myllymäki (2023) &lt;<a href="https://doi.org/10.1007%2Fs11222-023-10275-7">doi:10.1007/s11222-023-10275-7</a>&gt;,
    Mrkvička et al. (2016) &lt;<a href="https://doi.org/10.1016%2Fj.spasta.2016.04.005">doi:10.1016/j.spasta.2016.04.005</a>&gt;,
    Mrkvička et al. (2017) &lt;<a href="https://doi.org/10.1007%2Fs11222-016-9683-9">doi:10.1007/s11222-016-9683-9</a>&gt;,
    Mrkvička et al. (2020) &lt;<a href="https://doi.org/10.14736%2Fkyb-2020-3-0432">doi:10.14736/kyb-2020-3-0432</a>&gt;,
    Mrkvička et al. (2021) &lt;<a href="https://doi.org/10.1007%2Fs11009-019-09756-y">doi:10.1007/s11009-019-09756-y</a>&gt;,
    Myllymäki et al. (2021) &lt;<a href="https://doi.org/10.1016%2Fj.spasta.2020.100436">doi:10.1016/j.spasta.2020.100436</a>&gt;,
    Mrkvička et al. (2022) &lt;<a href="https://doi.org/10.1002%2Fsim.9236">doi:10.1002/sim.9236</a>&gt;,
    Dai et al. (2022) &lt;<a href="https://doi.org/10.5772%2Fintechopen.100124">doi:10.5772/intechopen.100124</a>&gt;,
    Dvořák and Mrkvička (2022) &lt;<a href="https://doi.org/10.1007%2Fs00180-021-01134-y">doi:10.1007/s00180-021-01134-y</a>&gt;,
    Mrkvička et al. (2023) &lt;<a href="https://doi.org/10.48550%2FarXiv.2309.04746">doi:10.48550/arXiv.2309.04746</a>&gt;, and
    Konstantinou et al. (2024) &lt;<a href="https://doi.org/10.1007%2Fs00180-024-01569-z">doi:10.1007/s00180-024-01569-z</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/myllym/GET">https://github.com/myllym/GET</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/myllym/GET/issues">https://github.com/myllym/GET/issues</a></td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>R.rsp</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-12-01 08:56:10 UTC; 03080687</td>
</tr>
<tr>
<td>Author:</td>
<td>Mari Myllymäki [aut, cre],
  Tomáš Mrkvička [aut],
  Mikko Kuronen [ctb],
  Jiří Dvořák [ctb],
  Pavel Grabarnik [ctb],
  Ute Hahn [ctb],
  Michael Rost [ctb],
  Henri Seijo [ctb]</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-12-02 10:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='GET-package'>Global Envelopes</h2><span id='topic+GET-package'></span><span id='topic+GET'></span>

<h3>Description</h3>

<p>The <span class="pkg">GET</span> package provides implementation of global envelopes
for a set of general d-dimensional vectors T in various applications.
A 100(1-alpha)
the probability that T falls outside this envelope in any of the d points is
equal to alpha. Global means that the probability is controlled simultaneously
for all the d elements of the vectors.
The global envelopes can be used for central regions of functional or
multivariate data (e.g. outlier detection, functional boxplot),
for graphical Monte Carlo and permutation tests where the test statistic
is a multivariate vector or function (e.g. goodness-of-fit testing for point
patterns and random sets, functional ANOVA, functional GLM, n-sample test of
correspondence of distribution functions), and for global confidence and
prediction bands (e.g. confidence band in polynomial regression,
Bayesian posterior prediction).
</p>


<h3>Details</h3>

<p>The <span class="pkg">GET</span> package provides central regions (i.e. global envelopes) and
global envelope tests with intrinsic graphical interpretation.
The central regions can be constructed from (functional) data.
The tests are Monte Carlo or permutation tests, which demand simulations
from the tested null model. The methods are applicable for any multivariate
vector data and functional data (after discretization).
</p>
<p>To get an overview of the package, start R and type <code>library("GET")</code> and <code>vignette("GET")</code>.
</p>
<p>To get examples of point pattern analysis, start R and type <code>library("GET")</code> and <code>vignette("pointpatterns")</code>.
</p>
<p>To get examples of Mrkvička and Myllymäki (2022), start R and type <code>library("GET")</code> and <code>vignette("FDRenvelopes")</code>.
</p>


<h3>Key functions in <span class="pkg">GET</span></h3>


<ul>
<li> <p><em>Central regions</em> or <em>global envelopes</em> or <em>confidence bands</em>:
<code><a href="#topic+central_region">central_region</a></code>.
E.g. 50% central region of growth curves of girls <code><a href="fda.html#topic+growth">growth</a></code>.
</p>

<ul>
<li><p> First create a curve_set of the growth curves, e.g.
</p>
<p><code>
                   cset &lt;- curve_set(r = as.numeric(row.names(growth$hgtf)),
                                     obs = growth$hgtf)
                 </code>
</p>
</li>
<li><p> Then calculate 50% central region (see <code><a href="#topic+central_region">central_region</a></code> for further arguments)
</p>
<p><code>
                   cr &lt;- central_region(cset, coverage = 0.5)
                 </code>
</p>
</li>
<li><p> Plot the result (see <code><a href="#topic+plot.global_envelope">plot.global_envelope</a></code> for plotting options)
</p>
<p><code>
                   plot(cr)
                 </code>
</p>
</li></ul>

<p>It is also possible to do combined central regions for several sets of curves provided in a list
for the function, see examples in <code><a href="#topic+central_region">central_region</a></code>.
</p>
</li>
<li> <p><em>Global envelope tests</em>: <code><a href="#topic+global_envelope_test">global_envelope_test</a></code> is the main function.
E.g. A test of complete spatial randomness (CSR) for a point pattern <code>X</code>:
</p>
<p><code>X &lt;- spruces # an example pattern from spatstat</code>
</p>

<ul>
<li><p> Use the function <code>envelope</code> of <span class="pkg">spatstat</span> to create nsim simulations
under CSR and to calculate the functions you want (below K-functions by Kest).
Important: use the option 'savefuns=TRUE' and
specify the number of simulations <code>nsim</code>.
</p>
<p><code>
                   env &lt;- envelope(X, nsim=999, savefuns = TRUE, fun = Kest, simulate = expression(runifpoint(ex = X)))
                 </code>
</p>
</li>
<li><p> Perform the test (see <code><a href="#topic+global_envelope_test">global_envelope_test</a></code> for further arguments)
</p>
<p><code>
                   res &lt;- global_envelope_test(env)
                 </code>
</p>
</li>
<li><p> Plot the result (see <code><a href="#topic+plot.global_envelope">plot.global_envelope</a></code> for plotting options)
</p>
<p><code>
                   plot(res)
                 </code>
</p>
</li></ul>

<p>It is also possible to do combined global envelope tests for several sets of curves provided in a list
for the function, see examples in <code><a href="#topic+global_envelope_test">global_envelope_test</a></code>.
To obtain false discovery rate envelopes of Mrkvička and Myllymäki (2023) use the argument <code>typeone = "fdr"</code>.
</p>
</li></ul>


<ul>
<li> <p><em>Functional ordering</em>: <code><a href="#topic+central_region">central_region</a></code> and <code><a href="#topic+global_envelope_test">global_envelope_test</a></code>
are based on different measures for ordering the functions (or vectors) from
the most extreme to the least extreme ones. The core functionality of calculating the measures
is in the function <code><a href="#topic+forder">forder</a></code>, which can be used to obtain different measures for sets of
curves. Usually there is no need to call <code><a href="#topic+forder">forder</a></code> directly.
</p>
</li>
<li> <p><em>Functional boxplots</em>: <code><a href="#topic+fBoxplot">fBoxplot</a></code>
</p>
</li>
<li> <p><em>Adjusted</em> global envelope tests for composite null hypotheses
</p>

<ul>
<li> <p><code><a href="#topic+GET.composite">GET.composite</a></code>, see a detailed example in <code><a href="#topic+saplings">saplings</a></code>
</p>
</li></ul>

</li>
<li> <p><em>One-way functional ANOVA</em>:
</p>

<ul>
<li> <p><em>Graphical</em> functional ANOVA tests: <code><a href="#topic+graph.fanova">graph.fanova</a></code>
</p>
</li>
<li><p> Global rank envelope based on F-values: <code><a href="#topic+frank.fanova">frank.fanova</a></code>
</p>
</li></ul>

</li>
<li> <p><em>Functional general linear model (GLM)</em>:
</p>

<ul>
<li> <p><em>Graphical</em> functional GLM: <code><a href="#topic+graph.flm">graph.flm</a></code>
</p>
</li>
<li><p> Global rank envelope based on F-values: <code><a href="#topic+frank.flm">frank.flm</a></code>
</p>
</li>
<li><p> For large data (not fitting comfortably in memory): <code><a href="#topic+partial_forder">partial_forder</a></code>
</p>
</li></ul>

</li>
<li> <p><em>Functional clustering</em>: <code><a href="#topic+fclustering">fclustering</a></code>
</p>
</li>
<li> <p><em>Global quantile regression</em>: <code><a href="#topic+global_rq">global_rq</a></code>
</p>
</li>
<li><p> Functions for performing global envelopes for other specific purposes:
</p>

<ul>
<li><p> Graphical n sample test of correspondence of distribution functions: <code><a href="#topic+GET.distrequal">GET.distrequal</a></code>
</p>
</li>
<li><p> Permutation-based tests of independence to samples from any bivariate distribution: <code><a href="#topic+GET.distrindep">GET.distrindep</a></code>
</p>
</li>
<li><p> Testing global and local dependence of point patterns on covariates: <code><a href="#topic+GET.spatialF">GET.spatialF</a></code>
</p>
</li>
<li><p> Testing local correlations: <code><a href="#topic+GET.localcor">GET.localcor</a></code>
</p>
</li>
<li><p> Variogram and residual variogram with global envelopes: <code><a href="#topic+GET.variogram">GET.variogram</a></code>
</p>
</li></ul>

</li>
<li><p> Deviation tests (for simple hypothesis): <code><a href="#topic+deviation_test">deviation_test</a></code> (no graphical
interpretation)
</p>
</li>
<li><p> Most functions accept the curves provided in a <code>curve_set</code> object.
Use <code><a href="#topic+curve_set">curve_set</a></code> to create a <code>curve_set</code> object from the
functions. Other formats to provide the curves to the above functions are
also accepted, see the information on the help pages.
</p>
</li></ul>

<p>See the help files of the functions for examples.
</p>


<h3>Workflow for (single hypothesis) tests based on single functions</h3>

<p>To perform a test you always first need to obtain the test function <code class="reqn">T(r)</code>
for your data (<code class="reqn">T_1(r)</code>) and for each simulation
(<code class="reqn">T_2(r), \dots, T_{s+1}(r)</code>) in one way or another.
Given the set of the functions <code class="reqn">T_i(r), i=1, \dots, s+1</code>,
you can perform a test by <code><a href="#topic+global_envelope_test">global_envelope_test</a></code>.
</p>
<p>1) The workflow when using your own programs for simulations:
</p>

<ul>
<li><p> (Fit the model and) Create <code class="reqn">s</code> simulations from the (fitted) null model.
</p>
</li>
<li><p> Calculate the functions <code class="reqn">T_1(r), T_2(r), \dots, T_{s+1}(r)</code>.
</p>
</li>
<li><p> Use <code><a href="#topic+curve_set">curve_set</a></code> to create a <code>curve_set</code> object
from the functions <code class="reqn">T_i(r), i=1, \dots, s+1</code>.
</p>
</li>
<li><p> Perform the test
</p>
<p><code>res &lt;- global_envelope_test(curve_set)</code>
</p>
<p>where <code>curve_set</code> is the 'curve_set'-object you created, and plot the result
</p>
<p><code>plot(res)</code>
</p>
</li></ul>

<p>2) The workflow utilizing <span class="pkg">spatstat</span>: start R, type <code>library("GET")</code> and <code>vignette("pointpatterns")</code>,
which explains the workflow and gives many examples of point pattern analysis
</p>


<h3>Functions for modifying sets of functions</h3>

<p>It is possible to modify the curve set <code class="reqn">T_1(r), T_2(r), \dots, T_{s+1}(r)</code> for the test.
</p>

<ul>
<li><p> You can choose the interval of distances <code class="reqn">[r_{\min}, r_{\max}]</code> by <code><a href="#topic+crop_curves">crop_curves</a></code>.
</p>
</li>
<li><p> For better visualisation, you can take <code class="reqn">T(r)-T_0(r)</code> by <code><a href="#topic+residual">residual</a></code>.
Here <code class="reqn">T_0(r)</code> is the expectation of <code class="reqn">T(r)</code> under the null hypothesis.
</p>
</li></ul>



<h3>Example data (see references on the help pages of each data set)</h3>


<ul>
<li> <p><code><a href="#topic+abide_9002_23">abide_9002_23</a></code>: see help page
</p>
</li>
<li> <p><code><a href="#topic+adult_trees">adult_trees</a></code>: a point pattern of adult rees
</p>
</li>
<li> <p><code><a href="#topic+cgec">cgec</a></code>: centred government expenditure centralization (GEC) ratios (see <code><a href="#topic+graph.fanova">graph.fanova</a></code>)
</p>
</li>
<li> <p><code><a href="#topic+fallen_trees">fallen_trees</a></code>: a point pattern of fallen trees
</p>
</li>
<li> <p><code><a href="#topic+GDPtax">GDPtax</a></code>: GDP per capita with country groups and other covariates
</p>
</li>
<li> <p><code><a href="#topic+imageset3">imageset3</a></code>: a simulated set of images
</p>
</li>
<li> <p><code><a href="#topic+rimov">rimov</a></code>: water temperature curves in 365 days of the 36 years
</p>
</li>
<li> <p><code><a href="#topic+saplings">saplings</a></code>: a point pattern of saplings (see <code><a href="#topic+GET.composite">GET.composite</a></code>)
</p>
</li></ul>

<p>The data sets are used to show examples of the functions of the library.
</p>


<h3>Number of functions</h3>

<p>If the number of functions is low, the choice of the measure (or type or depth) playes a role,
as explained in <code>vignette("GET")</code> (Section 2.4).
</p>
<p>Note that the recommended minimum number of simulations for the rank
envelope test (Myllymäki et al., 2017) based on a single function in spatial statistics is nsim=2499.
When the number of argument values is large, also larger number simulations is needed in order to
have a narrow p-interval.
The &quot;erl&quot;, &quot;cont&quot;, &quot;area&quot;, &quot;qdir&quot; and &quot;st&quot; global envelope tests and deviation tests can be
used with a lower number of simulations, although the Monte Carlo error is obviously larger
with a lower number of simulations.
For increasing the number of simulations, all the global rank envelopes approach the same curves.
</p>
<p>Mrkvička et al. (2017) discussed the number of simulations for tests based on many functions.
</p>


<h3>Documentation</h3>

<p>Myllymäki and Mrkvička (2024) provides description of the package.
The material can also be found in the corresponding vignette, which is available by
starting R and typing <code>library("GET")</code> and <code>vignette("GET")</code>.
</p>
<p>In the special case of spatial processes (spatial point processes, random sets),
the functions are typically estimators of summary functions. The package supports
the use of the R package <span class="pkg">spatstat</span> for generating simulations and calculating
estimators of the chosen summary function, but alternatively these can be done by
any other way, thus allowing for any user-specified models/functions.
To see examples of global envelopes for analysing point pattern data,
start R, type <code>library("GET")</code> and <code>vignette("pointpatterns")</code>.
</p>
<p>Mrkvička and Myllymäki (2023) developed false discovery rate (FDR) envelopes.
Examples can be found by in associated vignette: start R, and type
<code>library("GET")</code> and <code>vignette("pointpatterns")</code>.
</p>
<p>Mrkvička et al. (2023a) proposed global quantile regression. An example of
global quantile regression is given in the vignette <code>vignette("QuantileRegression")</code>.
</p>
<p>The vignette <code>vignette("HotSpots")</code> illustrates the methodology proposed by
Mrkvička et al. (2023b) for detecting hotspots on a linear network.
</p>
<p>Type citation(&quot;GET&quot;) to get a full list of references.
</p>


<h3>Acknowledgements</h3>

<p>Mikko Kuronen has made substantial contributions of code.
Additional contributions and suggestions from Jiří Dvořák, Pavel Grabarnik,
Ute Hahn, Michael Rost and Henri Seijo.
</p>


<h3>Author(s)</h3>

<p>Mari Myllymäki (mari.myllymaki@luke.fi, mari.j.myllymaki@gmail.com) and
Tomáš Mrkvička (mrkvicka.toma@gmail.com)
</p>


<h3>References</h3>

<p>Dai, W., Athanasiadis, S., Mrkvička, T. (2021) A new functional clustering method with combined dissimilarity sources and graphical interpretation. Intech open, London, UK. doi: 10.5772/intechopen.100124
</p>
<p>Dvořák, J. and Mrkvička, T. (2022). Graphical tests of independence for general distributions. Computational Statistics 37, 671&ndash;699.
</p>
<p>Konstantinou, K., Mrkvička, T. and Myllymäki, M. (2024) The power of visualizing distributional differences: formal graphical n-sample tests. Computational Statistics. doi: 10.1007/s00180-024-01569-z
</p>
<p>Mrkvička, T., Konstantinou, K., Kuronen, M. and Myllymäki, M. (2023a) Global quantile regression. arXiv:2309.04746 [stat.ME]. https://doi.org/10.48550/arXiv.2309.04746
</p>
<p>Mrkvička, T., Kraft, S., Blažek, V. and Myllymäki, M. (2023b) Hotspots detection on a linear network with presence of covariates: a case study on road crash data. Available at SSRN: http://dx.doi.org/10.2139/ssrn.4598454
</p>
<p>Mrkvička, T., Myllymäki, M. and Hahn, U. (2017) Multiple Monte Carlo testing, with applications in spatial point processes. Statistics &amp; Computing 27(5), 1239-1255. doi: 10.1007/s11222-016-9683-9
</p>
<p>Mrkvička, T., Myllymäki, M., Jilek, M. and Hahn, U. (2020) A one-way ANOVA test for functional data with graphical interpretation. Kybernetika 56(3), 432-458. doi: 10.14736/kyb-2020-3-0432
</p>
<p>Mrkvička, T., Myllymäki, M., Kuronen, M. and Narisetty, N. N. (2022) New methods for multiple testing in permutation inference for the general linear model. Statistics in Medicine 41(2), 276-297. doi: 10.1002/sim.9236
</p>
<p>Mrkvička, T., Myllymäki, M. (2023) False discovery rate envelopes. Statistics and Computing 33, 109. https://doi.org/10.1007/s11222-023-10275-7
</p>
<p>Mrkvička, T., Roskovec, T. and Rost, M. (2021) A nonparametric graphical tests of significance in functional GLM. Methodology and Computing in Applied Probability 23, 593-612. doi: 10.1007/s11009-019-09756-y
</p>
<p>Mrkvička, T., Soubeyrand, S., Myllymäki, M., Grabarnik, P., and Hahn, U. (2016) Monte Carlo testing in spatial statistics, with applications to spatial residuals. Spatial Statistics 18, Part A, 40-53. doi: 10.1016/j.spasta.2016.04.005
</p>
<p>Myllymäki, M., Grabarnik, P., Seijo, H. and Stoyan. D. (2015) Deviation test construction and power comparison for marked spatial point patterns. Spatial Statistics 11, 19-34. doi: 10.1016/j.spasta.2014.11.004
</p>
<p>Myllymäki, M., Mrkvička, T., Grabarnik, P., Seijo, H. and Hahn, U. (2017) Global envelope tests for spatial point patterns. Journal of the Royal Statistical Society: Series B (Statistical Methodology) 79, 381-404. doi: 10.1111/rssb.12172
</p>
<p>Myllymäki, M. and Mrkvička, T. (2024). GET: Global envelopes in R. Journal of Statistical Software 111(3), 1-40. doi: 10.18637/jss.v111.i03
</p>
<p>Myllymäki, M., Kuronen, M. and Mrkvička, T. (2020). Testing global and local dependence of point patterns on covariates in parametric models. Spatial Statistics 42, 100436. doi: 10.1016/j.spasta.2020.100436
</p>

<hr>
<h2 id='abide_9002_23'>Local brain activity at resting state</h2><span id='topic+abide_9002_23'></span>

<h3>Description</h3>

<p>Imaging measurements for local brain activity at resting state
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("abide_9002_23")
</code></pre>


<h3>Format</h3>

<p>A list of the <code>curve_set</code> containing the data,
coordinates (x,y) where the data have been observed (third dimension is 23),
the discrete factor <code>Group</code> (1=Autism; 2=Control),
the discrete factor <code>Sex</code> (1=Male; 2=Female),
and the continuous factor <code>Age</code>.
</p>


<h3>Details</h3>

<p>The data are a small part of ABIDE fALFF data available at
ABIDE: http://fcon_1000.projects.nitrc.org/indi/abide/
fALFF: http://fcp-indi.github.io/docs/user/alff.html
and distributed under the CC BY-NC-SA 3.0 license,
https://creativecommons.org/licenses/by-nc-sa/3.0/.
</p>
<p>The data are fractional Amplitude of Low Frequency Fluctuations (fALFF) (Zou et al. 2008)
for Autism Brain Imaging Data Exchange collected resting state functional magnetic resonance
imaging (R-fMRI) datasets (Di Martino et al. 2013).
This data set in <span class="pkg">GET</span> contains only a tiny part of the whole brain, namely
the region 9002 (the right Cerebelum Crus 1) at slice 23
(see Figure 2 in Mrkvicka et al., 2019) for 514 individuals with the autism spectrum
disorder (ASD) and 557 typical controls (TC) as specified in the given Group variable.
Further the sex and age of each subject is given.
</p>


<h3>References</h3>

<p>Di Martino, A., Yan, C., Li, Q., Denio, E., Castellanos, F., Alaerts, K., Anderson, J., Assaf, M., Bookheimer, S., Dapretto, M., et al. (2013) The autism brain imaging data exchange: towards a large-scale evaluation of the intrinsic brain architecture in autism. Molecular psychiatry.
</p>
<p>Tzourio-Mazoyer, N., Landeau, B., Papathanassiou, D., Crivello, F., Etard, O., Delcroix, N., Mazoyer, B., and Joliot, M. (2002), Automated anatomical labeling of activations in SPM using a macroscopic anatomical parcellation of the MNI MRI single-subject brain. Neuroimage, 15, 273-289.
</p>
<p>Zou, Q.-H., Zhu, C.-Z., Yang, Y., Zuo, X.-N., Long, X.-Y., Cao, Q.-J., Wang, Y.-F., and Zang, Y.-F. (2008), An improved approach to detection of amplitude of low-frequency fluctuation (ALFF) for resting-state fMRI: fractional ALFF. Journal of neuroscience methods, 172, 137-141.
</p>
<p>Mrkvička, T., Myllymäki, M., Kuronen, M. and Narisetty, N. N. (2022) New methods for multiple testing in permutation inference for the general linear model. Statistics in Medicine 41(2), 276-297. doi: 10.1002/sim.9236
</p>

<hr>
<h2 id='adult_trees'>Adult trees data set</h2><span id='topic+adult_trees'></span>

<h3>Description</h3>

<p>Adult trees data set
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("adult_trees")
</code></pre>


<h3>Format</h3>

<p>A <code>data.frame</code> containing the locations (x- and y-coordinates) of 67 trees
in an area of 75 m x 75 m.
</p>


<h3>Details</h3>

<p>A pattern of large trees (height &gt; 25 m) originating from an uneven aged multi-species
broadleaf nonmanaged forest in Kaluzhskie Zaseki, Russia.
</p>
<p>The pattern is a sample part of data collected over 10 ha plot as a part of a research
program headed by project leader Prof. O.V. Smirnova.
</p>


<h3>References</h3>

<p>Grabarnik, P. and Chiu, S. N. (2002) Goodness-of-fit test for complete spatial randomness against
mixtures of regular and clustered spatial point processes. Biometrika, 89, 411–421.
</p>
<p>van Lieshout, M.-C. (2010) Spatial point process theory. In Handbook of Spatial Statistics (eds. A. E.
Gelfand, P. J. Diggle, M. Fuentes and P. Guttorp), Handbooks of Modern Statistical Methods. Boca
Raton: CRC Press.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+saplings">saplings</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(require("spatstat.geom", quietly=TRUE)) {
  data("adult_trees")
  adult_trees &lt;- as.ppp(adult_trees, W = square(75))
  plot(adult_trees)
}

</code></pre>

<hr>
<h2 id='as.curve_set'>Convert an envelope or fdata object to a curve_set object</h2><span id='topic+as.curve_set'></span>

<h3>Description</h3>

<p>If given an envelope object of <span class="pkg">spatstat</span> or a <code>fdata</code> object of
<span class="pkg">fda.usc</span>, convert it into a curve_set object. If given a curve_set
object, check its correctness and give it back.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.curve_set(curve_set, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as.curve_set_+3A_curve_set">curve_set</code></td>
<td>
<p>An object to be converted to a <code><a href="#topic+curve_set">curve_set</a></code> object.
The <code>envelope</code> objects of <span class="pkg">spatstat</span> and <code>fdata</code> objects of
<span class="pkg">fda.usc</span> are supported currently, besides curve_set objects.</p>
</td></tr>
<tr><td><code id="as.curve_set_+3A_...">...</code></td>
<td>
<p>Allows passing arguments to <code><a href="#topic+create_curve_set">create_curve_set</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If an <code>envelope</code> object of <span class="pkg">spatstat</span> or an
<code><a href="fda.usc.html#topic+fdata">fdata</a></code> object is given, return a corresponding
curve_set object. If a curve_set object was given, check it and return it
unharmed.
</p>

<hr>
<h2 id='central_region'>Central region / Global envelope</h2><span id='topic+central_region'></span><span id='topic+global_envelope'></span>

<h3>Description</h3>

<p>Provides central regions or global envelopes or confidence bands
</p>


<h3>Usage</h3>

<pre><code class='language-R'>central_region(
  curve_sets,
  type = "erl",
  coverage = 0.5,
  alternative = c("two.sided", "less", "greater"),
  probs = c(0.25, 0.75),
  quantile.type = 7,
  central = "median",
  nstep = 2,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="central_region_+3A_curve_sets">curve_sets</code></td>
<td>
<p>A <code><a href="#topic+curve_set">curve_set</a></code> object or a list of <code><a href="#topic+curve_set">curve_set</a></code> objects.
Also <code>envelope</code> objects of <span class="pkg">spatstat</span> and <code>fdata</code> of <span class="pkg">fda.usc</span>
are accepted instead of curve_set objects.</p>
</td></tr>
<tr><td><code id="central_region_+3A_type">type</code></td>
<td>
<p>The type of the global envelope with current options for 'rank', 'erl', 'cont', 'area',
'qdir', 'st' and 'unscaled'. See details.</p>
</td></tr>
<tr><td><code id="central_region_+3A_coverage">coverage</code></td>
<td>
<p>A number between 0 and 1. The 100*coverage% central region will be calculated.
A vector of values can also be provided, leading to the corresponding number of central regions.</p>
</td></tr>
<tr><td><code id="central_region_+3A_alternative">alternative</code></td>
<td>
<p>A character string specifying the alternative hypothesis.
Must be one of the following: &quot;two.sided&quot; (default), &quot;less&quot; or &quot;greater&quot;.
The last two options only available for types <code>'rank'</code>, <code>'erl'</code>,
<code>'cont'</code> and <code>'area'</code>.</p>
</td></tr>
<tr><td><code id="central_region_+3A_probs">probs</code></td>
<td>
<p>A two-element vector containing the lower and upper
quantiles for the measure 'q' or 'qdir', in that order and on the interval [0, 1].
The default values are 0.025 and 0.975, suggested by Myllymäki et al. (2015, 2017).</p>
</td></tr>
<tr><td><code id="central_region_+3A_quantile.type">quantile.type</code></td>
<td>
<p>As type argument of <code><a href="stats.html#topic+quantile">quantile</a></code>, how to
calculate quantiles for 'q' or 'qdir'.</p>
</td></tr>
<tr><td><code id="central_region_+3A_central">central</code></td>
<td>
<p>Either &quot;mean&quot; or &quot;median&quot;. If the curve sets do not contain the component
<code>theo</code> for the theoretical central function, then the central function (used for plotting only)
is calculated either as the mean or median of functions provided in the curve sets.
For 'qdir', 'st' and 'unscaled' only the mean is allowed as an option, due to their definition.</p>
</td></tr>
<tr><td><code id="central_region_+3A_nstep">nstep</code></td>
<td>
<p>1 or 2 for how to contruct a combined global envelope if list of curve sets
is provided. 2 (default) for a two-step combining procedure, 1 for one-step.</p>
</td></tr>
<tr><td><code id="central_region_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given a <code><a href="#topic+curve_set">curve_set</a></code> object,
or an <code>envelope</code> object of <span class="pkg">spatstat</span> or <code>fdata</code> object of <span class="pkg">fda.usc</span>,
the function <code>central_region</code> constructs a central region, i.e. a global envelope,
from the given set of functions (or vectors).
</p>
<p>Generally an envelope is a band bounded by the vectors (or functions)
<code class="reqn">T_{low}</code> and <code class="reqn">T_{hi}</code>.
A <code class="reqn">100(1-\alpha)</code>% or 100*coverage% global envelope is a set
<code class="reqn">(T_{low}, T_{hi})</code> of envelope vectors
such that the probability that <code class="reqn">T_i</code> falls outside this envelope
in any of the d points of the vector <code class="reqn">T_i</code> is less or equal to <code class="reqn">\alpha</code>.
The global envelopes can be constructed based on different measures
that order the functions from the most extreme one to the least extreme one.
We use such orderings of the functions for which we are able to construct global envelopes
with intrinsic graphical interpretation.
</p>
<p>The type of the global envelope can be chosen with the argument <code>type</code> and
the options are given in the following.
Further information about the measures, on which the global envelopes are based,
can be found in Myllymäki and Mrkvička (2020, Section 2.).
</p>

<ul>
<li> <p><code>'rank'</code>: The global rank envelope
proposed by Myllymäki et al. (2017) based on the extreme rank defined as the minimum of pointwise
ranks.
</p>
</li>
<li> <p><code>'erl'</code>: The global rank envelope based on the extreme rank
length (Myllymäki et al.,2017, Mrkvička et al., 2018).
This envelope is constructed as the convex hull of the functions which have extreme rank
length measure that is larger or equal to the critical <code class="reqn">\alpha</code> level of the
extreme rank length measure.
</p>
</li>
<li> <p><code>'cont'</code>: The global rank envelope based on the continuous rank
(Hahn, 2015; Mrkvička et al., 2019) based on minimum of continuous pointwise ranks.
It is contructed as the convex hull in a similar way as the <code>'erl'</code> envelope.
</p>
</li>
<li> <p><code>'area'</code>: The global rank envelope based on the area rank (Mrkvička et al., 2019)
which is based on area between continuous pointwise ranks and minimum pointwise ranks
for those argument (r) values for which pointwise ranks achieve the minimum
(it is a combination of erl and cont).
It is contructed as the convex hull in a similar way as the <code>'erl'</code> and <code>'area'</code> envelopes.
</p>
</li>
<li> <p><code>'qdir'</code>: The directional quantile envelope based on
the directional quantile maximum absolute deviation (MAD) test (Myllymäki et al., 2017, 2015),
which takes into account the unequal variances of the test function T(r) for
different distances r and is also protected against asymmetry of distribution of T(r).
</p>
</li>
<li> <p><code>'st'</code>: The studentised envelope based on the studentised MAD
measure (Myllymäki et al., 2017, 2015),
which takes into account the unequal variances of the test function T(r) for different distances r.
</p>
</li>
<li> <p><code>'unscaled'</code>: The unscaled envelope (Ripley, 1981),
which leads to envelopes with constant width. It corresponds to the classical
maximum deviation test without scaling. This test suffers from unequal variance
of T(r) over the distances r and from the asymmetry of distribution of T(r).
We recommend to use the other alternatives instead. This unscaled global envelope is
provided for reference.
</p>
</li></ul>

<p>The values of the chosen measure M are determined for each curve in the <code>curve_set</code>, and
based on the chosen measure, the central region, i.e. the global envelope, is constructed
for the given curves.
</p>
<p>If a list of (suitable) objects are provided in the argument <code>curve_sets</code>,
then by default (<code>nstep = 2</code>) the two-step combining procedure is used to
construct the combined global envelope as described in Myllymäki and Mrkvička (2020, Section 2.2.).
If <code>nstep = 1</code> and the lengths of the multivariate vectors in each component
of the list are equal, then the one-step combining procedure is used where the
functions are concatenated together into a one long vector (see again Myllymäki and Mrkvička, 2020, Section 2.2.).
</p>


<h3>Value</h3>

<p>Either an object of class <code>global_envelope</code> and or an <code>combined_global_envelope</code> object.
The former class is obtained when a set of curves is provided, while the latter in the case
that <code>curve_sets</code> is a list of objects. The print and plot function are defined for the
returned objects (see examples).
</p>
<p>The <code>global_envelope</code> object is essentially a data frame containing columns
</p>

<ul>
<li><p> r = the vector of values of the argument r at which the test was made
</p>
</li>
<li><p> lo = the lower envelope based on the simulated functions;
in case of a vector of coverage values, several 'lo' exist with names paste0(&quot;lo.&quot;, 100*coverage)
</p>
</li>
<li><p> hi = the upper envelope based on the simulated functions;
in case of a vector of coverage values, several 'lo' exist with names paste0(&quot;hi.&quot;, 100*coverage)
</p>
</li>
<li><p> central = If the <code>curve_set</code> (or <code>envelope</code> object) contains a theoretical curve,
then this function is used as the central curve and returned in this component.
Otherwise, the central curve is the mean or median (according to the argument <code>central</code>)
of the test functions T_i(r), i=2, ..., s+1. Used for visualization only.
</p>
</li></ul>

<p>and potentially additionally
</p>

<ul>
<li><p> obs = the data function, if there is only one data function in the given <code>curve_sets</code>.
Otherwise not existing.
</p>
</li></ul>

<p>(Most often <code>central_region</code> is directly applied to functional data where all curves are observed.)
Additionally, the returned object has some attributes, where
</p>

<ul>
<li><p> M = A vector of the values of the chosen measure for all the function.
If there is only one observed function, then M[1] gives the value of the measure for this.
</p>
</li>
<li><p> M_alpha = The critical value of M corresponding to the 100(1-alpha)% global envelope
(see Myllymäki and Mrkvička, 2020, Definition 1.1. IGI).
</p>
</li></ul>

<p>Further the object has some attributes for printing and plotting purposes, where
<code>alternative</code>, <code>type</code>, <code>ties</code>, <code>alpha</code> correspond to those in the function call
and <code>method</code> gives a name for the method.
Attributes of an object <code>res</code> can be obtained using the function
<code><a href="base.html#topic+attr">attr</a></code>, e.g. <code>attr(res, "M")</code> for the values of the ordering measure.
</p>
<p>If the given set of curves had the class <code>envelope</code> of <span class="pkg">spatstat</span>, then the returned
<code>global_envelope</code> object has also the class <code>fv</code> of spatstat, whereby one can utilize
also the plotting functions of <span class="pkg">spatstat</span>, see example in <code><a href="#topic+plot.global_envelope">plot.global_envelope</a></code>.
However, the <code>envelope</code> objects are most often used with <code><a href="#topic+global_envelope_test">global_envelope_test</a></code>
and not with <code>central_region</code>.
For an <code>fv</code> object, also some further attributes exists as required by <code>fv</code> of <span class="pkg">spatstat</span>.
</p>
<p>The <code>combined_global_envelope</code> is a list of <code>global_envelope</code> objects, where
the components correspond to the components of <code>curve_sets</code>.
The <code>combined_global_envelope</code> object constructed with <code>nstep = 2</code> contains,
in addition to some conventional ones (<code>method</code>, <code>alternative</code>, <code>type</code>, <code>alpha</code>,
<code>M</code>, <code>M_alpha</code>, see above), the second level envelope information as the attributes
</p>

<ul>
<li><p> level2_ge = The second level envelope on which the envelope construction is based
</p>
</li>
<li><p> level2_curve_set = The second level <code>curve_set</code> from which <code>level2_ge</code> is constructed
</p>
</li></ul>

<p>In the case that the given curve sets are two-dimensional, i.e., their arguments values are two-dimensional,
then the returned objects have in addition to the class <code>global_envelope</code> or <code>combined_global_envelope</code>,
the class <code>global_envelope2d</code> or <code>combined_global_envelope2d</code>, respectively. This class is assigned
for plotting purposes: For the 2d envelopes, also the default plots are 2d.
Otherwise the 1d and 2d objects are similar.
</p>


<h3>References</h3>

<p>Mrkvička, T., Myllymäki, M., Jilek, M. and Hahn, U. (2020) A one-way ANOVA test for functional data with graphical interpretation. Kybernetika 56(3), 432-458. doi: 10.14736/kyb-2020-3-0432
</p>
<p>Mrkvička, T., Myllymäki, M., Kuronen, M. and Narisetty, N. N. (2022) New methods for multiple testing in permutation inference for the general linear model. Statistics in Medicine 41(2), 276-297. doi: 10.1002/sim.9236
</p>
<p>Myllymäki, M., Grabarnik, P., Seijo, H. and Stoyan. D. (2015). Deviation test construction and power comparison for marked spatial point patterns. Spatial Statistics 11, 19-34. doi: 10.1016/j.spasta.2014.11.004
</p>
<p>Myllymäki, M., Mrkvička, T., Grabarnik, P., Seijo, H. and Hahn, U. (2017). Global envelope tests for spatial point patterns. Journal of the Royal Statistical Society: Series B (Statistical Methodology) 79, 381-404. doi: 10.1111/rssb.12172
</p>
<p>Myllymäki, M. and Mrkvička, T. (2024). GET: Global envelopes in R. Journal of Statistical Software 111(3), 1-40. doi: 10.18637/jss.v111.i03
</p>
<p>Ripley, B.D. (1981). Spatial statistics. Wiley, New Jersey.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+forder">forder</a></code>, <code><a href="#topic+global_envelope_test">global_envelope_test</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## A central region of a set of functions
#----------------------------------------
if(requireNamespace("fda", quietly=TRUE)) {
  cset &lt;- curve_set(r=as.numeric(row.names(fda::growth$hgtf)),
                    obs=fda::growth$hgtf)
  plot(cset) + ggplot2::ylab("height")
  cr &lt;- central_region(cset, coverage=0.50, type="erl")
  plot(cr)
}

## Confidence bands for linear or polynomial regression
#------------------------------------------------------
# Simulate regression data according to the cubic model
# f(x) = 0.8x - 1.8x^2 + 1.05x^3 for x in [0,1]
par &lt;- c(0,0.8,-1.8,1.05) # Parameters of the true polynomial model
res &lt;- 100 # Resolution
x &lt;- seq(0, 1, by=1/res); x2=x^2; x3=x^3;
f &lt;- par[1] + par[2]*x + par[3]*x^2 + par[4]*x^3 # The true function
d &lt;- f + rnorm(length(x), 0, 0.04) # Data
# Plot the true function and data
plot(f, type="l", ylim=range(d))
points(d)

# Estimate polynomial regression model
reg &lt;- lm(d ~ x + x2 + x3)
ftheta &lt;- reg$fitted.values
resid0 &lt;- reg$residuals
s0 &lt;- sd(resid0)

# Bootstrap regression
B &lt;- 2000 # Number of bootstrap samples

ftheta1 &lt;- array(0, c(B,length(x)))
s1 &lt;- array(0,B)
for(i in 1:B) {
  u &lt;- sample(resid0, size=length(resid0), replace=TRUE)
  reg1 &lt;- lm((ftheta+u) ~ x + x2 + x3)
  ftheta1[i,] &lt;- reg1$fitted.values
  s1[i] &lt;- sd(reg1$residuals)
}

# Centering and scaling
meanftheta &lt;- apply(ftheta1, 2, mean)
m &lt;- array(0, c(B,length(x)))
for(i in 1:B) { m[i,] &lt;- (ftheta1[i,]-meanftheta)/s1[i] }

# Central region computation
boot.cset &lt;- curve_set(r=1:length(x), obs=ftheta+s0*t(m))
cr &lt;- central_region(boot.cset, coverage=c(0.50, 0.80, 0.95), type="erl")

# Plotting the result
plot(cr) + ggplot2::labs(x=expression(italic(x)), y=expression(italic(f(x)))) +
  ggplot2::geom_point(data=data.frame(id=1:length(d), points=d),
                      ggplot2::aes(x=id, y=points)) + # data points
  ggplot2::geom_line(data=data.frame(id=1:length(d), points=f),
                     ggplot2::aes(x=id, y=points)) # true function
</code></pre>

<hr>
<h2 id='cgec'>Centred government expenditure centralization ratios</h2><span id='topic+cgec'></span>

<h3>Description</h3>

<p>Centred government expenditure centralization (GEC) ratios
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("cgec")
</code></pre>


<h3>Format</h3>

<p>A list of two components. The first one is the <code>curve_set</code> object containing the observed
values of centred GEC observed in year 1995-2016 for the above countries.
The second component <code>group</code> gives the grouping.
</p>


<h3>Details</h3>

<p>The data includes the government expenditure centralization (GEC) ratio in percent that has been
centred with respect to country average in order to remove the differences in absolute values of
GEC.
The GEC ratio is the ratio of central government expenditure to the total general government expenditure.
Data were collected from the Eurostat (2018) database.
Only those European countries were included, where the data were available from 1995 to 2016 without
interruption. Finally, 29 countries were classified into three groups in the following way:
</p>

<ul>
<li><p> Group 1: Countries joining EC between 1958 and 1986 (Belgium, Denmark, France, Germany
(until 1990 former territory of the FRG), Greece, Ireland, Italy, Luxembourg, Netherlands, Portugal,
Spain, United Kingdom. These countries have long history of European integration, representing the
core of integration process.
</p>
</li>
<li><p> Group 2: Countries joining the EU in 1995 (Austria, Sweden, Finland) and 2004 (Malta, Cyprus),
except CEEC (separate group), plus highly economically integrated non-EU countries, EFTA members
(Norway, Switzerland). Countries in this group have been, or in some case even still are standing
apart from the integration mainstream. Their level of economic integration is however very high.
</p>
</li>
<li><p> Group 3: Central and Eastern European Countries (CEEC), having similar features in political
end economic history. The process of economic and political integration have been initiated by
political changes in 1990s. CEEC joined the EU in 2004 and 2007 (Bulgaria, Czech Republic, Estonia,
Hungary, Latvia, Lithuania, Poland, Romania, Slovakia, Slovenia, data for Croatia joining in 2013 are
incomplete, therefore not included).
</p>
</li></ul>

<p>This grouping is used in examples.
</p>


<h3>References</h3>

<p>Eurostat (2018). &quot;Government revenue, expenditure and main aggregates (gov10amain)”. Retrieved from https://ec.europa.eu/eurostat/data/database(26/10/2018).
</p>
<p>Mrkvička, T., Myllymäki, M., Jilek, M. and Hahn, U. (2020) A one-way ANOVA test for functional data with graphical interpretation. Kybernetika 56 (3), 432-458. doi: 10.14736/kyb-2020-3-0432
</p>


<h3>See Also</h3>

<p><code><a href="#topic+graph.fanova">graph.fanova</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("cgec")
# Plot data in groups
for(i in 1:3)
  assign(paste0("p", i), plot(subset(cgec$cgec, cgec$group == i)) +
    ggplot2::labs(title=paste("Group ", i, sep=""), y="Centred GEC"))
p3
if(require("patchwork", quietly=TRUE))
  p1 + p2 + p3
</code></pre>

<hr>
<h2 id='combined_scaled_MAD_envelope_test'>Combined global scaled maximum absolute difference (MAD) envelope tests</h2><span id='topic+combined_scaled_MAD_envelope_test'></span>

<h3>Description</h3>

<p>Given a list of <code><a href="#topic+curve_set">curve_set</a></code> objects, a combined global scaled (directional quantile
or studentized) MAD envelope test is performed with the test functions saved in the curve set objects.
Details of this combined test can be found in Mrkvicka et al. (2017).
The implementation of this test is provided here for historical reasons:
we recommend now instead the use of <code><a href="#topic+global_envelope_test">global_envelope_test</a></code> also for combined tests;
these combined tests are there implemented as described in Myllymäki and Mrkvička (2024).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>combined_scaled_MAD_envelope_test(
  curve_sets,
  type = c("qdir", "st"),
  alpha = 0.05,
  probs = c(0.025, 0.975),
  central = "mean",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="combined_scaled_MAD_envelope_test_+3A_curve_sets">curve_sets</code></td>
<td>
<p>A <code><a href="#topic+curve_set">curve_set</a></code> object or a list of <code><a href="#topic+curve_set">curve_set</a></code>
objects containing a data function and simulated functions from which the envelope is
to be constructed.
Also <code>envelope</code> objects of <span class="pkg">spatstat</span> are accepted instead of curve_set objects.
If an envelope object is given, it must contain the summary
functions from simulated patterns which can be achieved by setting
<code>savefuns = TRUE</code> when calling the <code>envelope</code> function.</p>
</td></tr>
<tr><td><code id="combined_scaled_MAD_envelope_test_+3A_type">type</code></td>
<td>
<p>Either &quot;qdir&quot; for the direction quantile envelope test or
&quot;st&quot; for the studentized envelope test.</p>
</td></tr>
<tr><td><code id="combined_scaled_MAD_envelope_test_+3A_alpha">alpha</code></td>
<td>
<p>The significance level. The 100(1-alpha)% global envelope will be calculated
under the 'fwer' or 'fdr' control.
If a vector of values is provided, the global envelopes are calculated for each value.</p>
</td></tr>
<tr><td><code id="combined_scaled_MAD_envelope_test_+3A_probs">probs</code></td>
<td>
<p>A two-element vector containing the lower and upper
quantiles for the measure 'q' or 'qdir', in that order and on the interval [0, 1].
The default values are 0.025 and 0.975, suggested by Myllymäki et al. (2015, 2017).</p>
</td></tr>
<tr><td><code id="combined_scaled_MAD_envelope_test_+3A_central">central</code></td>
<td>
<p>Either &quot;mean&quot; or &quot;median&quot;. If the curve sets do not contain the component
<code>theo</code> for the theoretical central function, then the central function (used for plotting only)
is calculated either as the mean or median of functions provided in the curve sets.
For 'qdir', 'st' and 'unscaled' only the mean is allowed as an option, due to their definition.</p>
</td></tr>
<tr><td><code id="combined_scaled_MAD_envelope_test_+3A_...">...</code></td>
<td>
<p>Additional parameters to be passed to <code><a href="#topic+central_region">central_region</a></code>.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Mrkvička, T., Myllymäki, M. and Hahn, U. (2017) Multiple Monte Carlo testing, with applications in spatial point processes.
Statistics &amp; Computing 27(5): 1239–1255. DOI: 10.1007/s11222-016-9683-9
</p>
<p>Myllymäki, M. and Mrkvička, T. (2024). GET: Global envelopes in R. Journal of Statistical Software 111(3), 1-40. doi: 10.18637/jss.v111.i03
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(require("spatstat.explore", quietly=TRUE)) {
  # As an example test CSR of the saplings point pattern from spatstat by means of
  # L, F, G and J functions.
  data("saplings")
  X &lt;- as.ppp(saplings, W=square(75))

  nsim &lt;- 499 # Number of simulations for the tests
  
  # Specify distances for different test functions
  n &lt;- 500 # the number of r-values
  rmin &lt;- 0; rmax &lt;- 20; rstep &lt;- (rmax-rmin)/n
  rminJ &lt;- 0; rmaxJ &lt;- 8; rstepJ &lt;- (rmaxJ-rminJ)/n
  r &lt;- seq(0, rmax, by=rstep)    # r-distances for Lest
  rJ &lt;- seq(0, rmaxJ, by=rstepJ) # r-distances for Fest, Gest, Jest
  

  # Perform simulations of CSR and calculate the L-functions
  env_L &lt;- envelope(X, nsim=nsim,
   simulate=expression(runifpoint(ex=X)),
   fun="Lest", correction="translate",
   transform=expression(.-r), # Take the L(r)-r function instead of L(r)
   r=r,                         # Specify the distance vector
   savefuns=TRUE,               # Save the estimated functions
   savepatterns=TRUE)           # Save the simulated patterns
  # Take the simulations from the returned object
  simulations &lt;- attr(env_L, "simpatterns")
  # Then calculate the other test functions F, G, J for each simulated pattern
  env_F &lt;- envelope(X, nsim=nsim,
                    simulate=simulations,
                    fun="Fest", correction="Kaplan", r=rJ,
                    savefuns=TRUE)
  env_G &lt;- envelope(X, nsim=nsim,
                    simulate=simulations,
                    fun="Gest", correction="km", r=rJ,
                   savefuns=TRUE)
  env_J &lt;- envelope(X, nsim=nsim,
                    simulate=simulations,
                    fun="Jest", correction="none", r=rJ,
                    savefuns=TRUE)

  # Crop the curves to the desired r-interval I
  curve_set_L &lt;- crop_curves(env_L, r_min=rmin, r_max=rmax)
  curve_set_F &lt;- crop_curves(env_F, r_min=rminJ, r_max=rmaxJ)
  curve_set_G &lt;- crop_curves(env_G, r_min=rminJ, r_max=rmaxJ)
  curve_set_J &lt;- crop_curves(env_J, r_min=rminJ, r_max=rmaxJ)

  # The combined directional quantile envelope test
  res &lt;- combined_scaled_MAD_envelope_test(
             curve_sets=list(L=curve_set_L, F=curve_set_F,
                             G=curve_set_G, J=curve_set_J),
             type="qdir")
  plot(res)
}

</code></pre>

<hr>
<h2 id='create_image_set'>Create a curve set of images</h2><span id='topic+create_image_set'></span>

<h3>Description</h3>

<p>Create a curve set consisting of a set of images, given a list containing
the values of the 2d functions in the right form.
Only 2d functions in a rectangular windows are supported; the values are provided
in matrices (arrays). For more general 2d functions see <code><a href="#topic+create_curve_set">create_curve_set</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_image_set(image_set, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="create_image_set_+3A_image_set">image_set</code></td>
<td>
<p>A list containing elements <code>r</code>, <code>obs</code>, <code>sim_m</code> and <code>theo</code>.
<code>r</code>, <code>sim_m</code> and <code>theo</code> are optional, <code>obs</code> needs to be provided always.
If provided, <code>r</code> must be a <code>list</code> describing the argument values
where the images have been observed (or simulated). It must consist of the following two or
four components:
a) &quot;x&quot; and &quot;y&quot; giving the equally spaced argument values for the x- and y-coordinates
(first and second dimension of the 2d functions) where the data have been observed,
b) &quot;x&quot;, &quot;y&quot;, &quot;width&quot; and &quot;height&quot;, where the width and height give the width and height of the
pixels placed at x and y, or
c) &quot;xmin&quot;, &quot;xmax&quot;, &quot;ymin&quot; and &quot;ymax&quot; giving the corner coordinates of the pixels
where the data have been observed.
If not given, r is set to be a list of values from 1 to the number of first/second dimension
of 2d functions in <code>obs</code>.
<code>obs</code> must be either a 2d matrix (dimensions matching the lengths of r vectors)
or 3d array containing the observed 2d functions (the third dimension matching the number
of functions).
If <code>obs</code> is a 3d array, then <code>sim_m</code> is ignored.
If <code>obs</code> is a 2d array, then <code>sim_m</code> must be a 3d array containing the simulated
images (2d functions) (the third dimension matching the number of functions).
If included, <code>theo</code> corresponds to the theoretical function
(e.g., under the null hypothesis) and its dimensions must either match the dimensions
of 2d functions in <code>obs</code> or it must be a constant.</p>
</td></tr>
<tr><td><code id="create_image_set_+3A_...">...</code></td>
<td>
<p>Do not use. (For internal use only.)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The given list as a <code>curve_set</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>a &lt;- create_image_set(list(obs=array(runif(4*5*6), c(4,5,6))))
plot(a)
plot(a, idx=1:6)

a &lt;- create_image_set(list(r=list(x=c(10,20,30,40), y=1:5*0.1),
                           obs=array(runif(4*5*6), c(4,5,6))))
plot(a)

a &lt;- create_image_set(list(r=list(xmin=c(1, 2, 4, 7), xmax=c(2, 4, 7, 11),
                                  ymin=c(1,1.1,2,2.1,3), ymax=c(1.1,2,2.1,3,3.1)),
                           obs=array(runif(4*5*6), c(4,5,6))))
plot(a)
plot(a, idx=1:5)
</code></pre>

<hr>
<h2 id='crop_curves'>Crop the curves</h2><span id='topic+crop_curves'></span>

<h3>Description</h3>

<p>Crop the curves to a certain interval, or crop missing and infinite argument
values from the curves
</p>


<h3>Usage</h3>

<pre><code class='language-R'>crop_curves(curve_set, allfinite = TRUE, r_min = NULL, r_max = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="crop_curves_+3A_curve_set">curve_set</code></td>
<td>
<p>A <code><a href="#topic+curve_set">curve_set</a></code> object, or
an <code>envelope</code> object of <span class="pkg">spatstat</span>. If an envelope object is given,
it must contain the summary functions from the simulated patterns which can be
achieved by setting savefuns = TRUE when calling the <code>envelope</code> function.</p>
</td></tr>
<tr><td><code id="crop_curves_+3A_allfinite">allfinite</code></td>
<td>
<p>Logical. TRUE means that the argument values where any of the
curves have missing or infinite values are removed. FALSE means that only
<code>r_min</code> and <code>r_max</code> apply.</p>
</td></tr>
<tr><td><code id="crop_curves_+3A_r_min">r_min</code></td>
<td>
<p>The minimum radius to include.</p>
</td></tr>
<tr><td><code id="crop_curves_+3A_r_max">r_max</code></td>
<td>
<p>The maximum radius to include.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The curves can be cropped to a certain interval defined by the arguments r_min and r_max.
Also the argument values of the sets of curves which have missing or infinite
values for any of the curves can be removed from the set (<code>allfinite = TRUE</code>).
The interval should generally be chosen carefully for classical deviation tests.
</p>


<h3>Value</h3>

<p>A curve_set object containing the cropped summary functions and
the cropped radius vector.
</p>

<hr>
<h2 id='curve_set'>Create a curve_set object</h2><span id='topic+curve_set'></span><span id='topic+create_curve_set'></span>

<h3>Description</h3>

<p>Create a curve_set object out of data provided in the right form.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>curve_set(
  obs,
  sim = NULL,
  r = NULL,
  theo = NULL,
  allfinite = FALSE,
  verbose = TRUE
)

create_curve_set(curve_set, allfinite = FALSE, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="curve_set_+3A_obs">obs</code></td>
<td>
<p>The observed data. See details.</p>
</td></tr>
<tr><td><code id="curve_set_+3A_sim">sim</code></td>
<td>
<p>The simulated data. See details.</p>
</td></tr>
<tr><td><code id="curve_set_+3A_r">r</code></td>
<td>
<p>The argument values where the functions/vectors have been observed (or simulated). See details.</p>
</td></tr>
<tr><td><code id="curve_set_+3A_theo">theo</code></td>
<td>
<p>The theoretical function. See details.</p>
</td></tr>
<tr><td><code id="curve_set_+3A_allfinite">allfinite</code></td>
<td>
<p>Logical. TRUE requires that all values of the curves must be
finite (not infinite and not missing, see <code><a href="base.html#topic+is.finite">is.finite</a></code>). FALSE
allows for infinite or missing values in the curves. These infinite and missing
values can have consequences for the subsequent analyses. A warning is given
if infinite or missing values exists (when <code>verbose = TRUE</code>).</p>
</td></tr>
<tr><td><code id="curve_set_+3A_verbose">verbose</code></td>
<td>
<p>Logical flag indicating whether to warn about the content.</p>
</td></tr>
<tr><td><code id="curve_set_+3A_curve_set">curve_set</code></td>
<td>
<p>A list containing the element obs, and optionally
the elements r, sim_m (same as sim, but in matrix format only) and theo.
See details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The functions are used to clump together the functional data in the form
that can be handled by the other <span class="pkg">GET</span> functions (<code><a href="#topic+forder">forder</a></code>,
<code><a href="#topic+central_region">central_region</a></code>, <code><a href="#topic+global_envelope_test">global_envelope_test</a></code> etc.).
The functions take care of checking the content of the data,
and save relevant information of the curves for global envelope
methods to be used in particular for plotting the results with graphical
interpretation.
</p>
<p><code>obs</code> must be either
</p>

<ul>
<li><p> a vector containing the data function/vector, or
</p>
</li>
<li><p> a matrix containing the s data functions/vectors, in which case it is assumed that
each column corresponds to a data function/vector, or
</p>
</li>
<li><p> a list containing the s data functions/vectors.
</p>
</li></ul>

<p>If <code>obs</code> is a vector, <code>sim</code> must be either
</p>

<ul>
<li><p> a matrix containing the simulated functions/vectors, each column
corresponding to a function/vector and the number of rows matching the length
of <code>obs</code>, or
</p>
</li>
<li><p> a list containing the simulated functions/vectors.
</p>
</li></ul>

<p>If <code>obs</code> is a matrix or a list, <code>sim</code> is ignored.
</p>
<p>If given, <code>r</code> describes the 1- or 2-dimensional argument values where the functions/vectors
have been observed (or simulated). It must be either
</p>

<ul>
<li><p> a vector,
</p>
</li>
<li><p> a data.frame with columns &quot;x&quot;, &quot;y&quot;, &quot;width&quot; and &quot;height&quot;,
where the width and height give the width and height of the pixels placed at x and y, or
</p>
</li>
<li><p> a data.frame with columns &quot;xmin&quot;, &quot;xmax&quot;, &quot;ymin&quot; and &quot;ymax&quot; giving the corner
coordinates of the pixels where the data have been observed.
</p>
</li></ul>

<p>If <code>obs</code> is a vector, <code>theo</code> can be given and it should then correspond
to a theoretical function (e.g., under the null hypothesis). If present, its
length must match the length of <code>obs</code>.
</p>


<h3>Value</h3>

<p>An object of class <code>curve_set</code> containing the data.
If the argument values are two-dimensional, then the <code>curve_set</code> is additionally
a <code>curve_set2d</code> object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.curve_set">plot.curve_set</a></code>, <code><a href="#topic+plot.curve_set2d">plot.curve_set2d</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># 1d
cset &lt;- curve_set(r = 1:10, obs = matrix(runif(10*5), ncol=5))
plot(cset)
# 2d
cset &lt;- curve_set(r = data.frame(x=c(rep(1:3, 3), 4), y=c(rep(1:3, each=3), 1),
                                 width=1, height=1),
                  obs = matrix(runif(10*5), ncol=5))
plot(cset)
</code></pre>

<hr>
<h2 id='deviation_test'>Deviation test</h2><span id='topic+deviation_test'></span>

<h3>Description</h3>

<p>Crop the curve set to the interval of distances [r_min, r_max],
calculate residuals, scale the residuals and perform a deviation test
with a chosen deviation measure.
The deviation tests are well known in spatial statistics; in <span class="pkg">GET</span> they are
provided for comparative purposes. Some (maximum type) of the deviation test
have their corresponding envelope tests available, see Myllymäki et al., 2017
(and 'unscaled', 'st' and 'qdir' in <code><a href="#topic+global_envelope_test">global_envelope_test</a></code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>deviation_test(
  curve_set,
  r_min = NULL,
  r_max = NULL,
  use_theo = TRUE,
  scaling = "qdir",
  measure = "max",
  alternative = c("two.sided", "less", "greater"),
  savedevs = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="deviation_test_+3A_curve_set">curve_set</code></td>
<td>
<p>A residual curve_set object. Can be obtained by using
residual().</p>
</td></tr>
<tr><td><code id="deviation_test_+3A_r_min">r_min</code></td>
<td>
<p>The minimum radius to include.</p>
</td></tr>
<tr><td><code id="deviation_test_+3A_r_max">r_max</code></td>
<td>
<p>The maximum radius to include.</p>
</td></tr>
<tr><td><code id="deviation_test_+3A_use_theo">use_theo</code></td>
<td>
<p>Whether to use the theoretical summary function or the
mean of the functions in the curve_set.</p>
</td></tr>
<tr><td><code id="deviation_test_+3A_scaling">scaling</code></td>
<td>
<p>The name of the scaling to use. Options include 'none',
'q', 'qdir' and 'st'. 'qdir' is default.</p>
</td></tr>
<tr><td><code id="deviation_test_+3A_measure">measure</code></td>
<td>
<p>The deviation measure to use. Default is 'max'. Must be
one of the following: 'max', 'int' or 'int2'.</p>
</td></tr>
<tr><td><code id="deviation_test_+3A_alternative">alternative</code></td>
<td>
<p>A character string specifying the alternative hypothesis
when <code>measure = 'max'</code>; otherwise ignored. Must be one of the following:
&quot;two.sided&quot; (default), &quot;less&quot; or &quot;greater&quot;.</p>
</td></tr>
<tr><td><code id="deviation_test_+3A_savedevs">savedevs</code></td>
<td>
<p>Logical. Should the global rank values k_i, i=1,...,nsim+1 be returned? Default: FALSE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The deviation test is based on a test function <code class="reqn">T(r)</code> and it works as follows:
</p>
<p>1) The test function estimated for the data, <code class="reqn">T_1(r)</code>, and for nsim simulations
from the null model, <code class="reqn">T_2(r), ...., T_{nsim+1}(r)</code>, must be saved in 'curve_set'
and given to the deviation_test function.
</p>
<p>2) The deviation_test function then
</p>

<ul>
<li><p> Crops the functions to the chosen range of distances <code class="reqn">[r_{\min}, r_{\max}]</code>.
</p>
</li>
<li><p> If the curve_set does not consist of residuals (see <code><a href="#topic+residual">residual</a></code>),
then the residuals <code class="reqn">d_i(r) = T_i(r) - T_0(r)</code> are calculated, where <code class="reqn">T_0(r)</code> is the
expectation of <code class="reqn">T(r)</code> under the null hypothesis.
If use_theo = TRUE, the theoretical value given in the curve_set$theo is used for
as <code class="reqn">T_0(r)</code>, if it is given. Otherwise, <code class="reqn">T_0(r)</code> is estimated by the mean of <code class="reqn">T_j(r)</code>,
<code class="reqn">j=2,...,nsim+1</code>.
</p>
</li>
<li><p> Scales the residuals. Options are
</p>

<ul>
<li><p> 'none' No scaling. Nothing done.
</p>
</li>
<li><p> 'q' Quantile scaling.
</p>
</li>
<li><p> 'qdir' Directional quantile scaling.
</p>
</li>
<li><p> 'st' Studentised scaling.
</p>
</li></ul>

<p>See for details Myllymäki et al. (2013).
</p>
</li>
<li><p> Calculates the global deviation measure <code class="reqn">u_i</code>, <code class="reqn">i=1,...,nsim+1</code>, see options
for 'measure'.
</p>

<ul>
<li><p> 'max' is the maximum deviation measure
</p>
<p style="text-align: center;"><code class="reqn">u_i = \max_{r \in [r_{\min}, r_{\max}]} | w(r)(T_i(r) - T_0(r))|</code>
</p>

<p>If <code>alternative = "greater"</code>, then instead
</p>
<p style="text-align: center;"><code class="reqn">u_i = \max_{r \in [r_{\min}, r_{\max}]} [ w(r)(T_i(r) - T_0(r)) ] </code>
</p>

<p>i.e. the largest values will have the largest <code class="reqn">u_i</code>.
</p>
<p>If <code>alternative = "less"</code>, then instead
</p>
<p style="text-align: center;"><code class="reqn">u_i = \max_{r \in [r_{\min}, r_{\max}]} [- w(r)(T_i(r) - T_0(r)) ] </code>
</p>

<p>i.e. the smallest values will have the largest <code class="reqn">u_i</code>.
</p>
</li>
<li><p> 'int2' is the integral deviation measure
</p>
<p style="text-align: center;"><code class="reqn">u_i = \int_{r_{\min}}^{r_{\max}} ( w(r)(T_i(r) - T_0(r)) )^2 dr</code>
</p>

</li>
<li><p> 'int' is the 'absolute' integral deviation measure
</p>
<p style="text-align: center;"><code class="reqn">u_i = \int_{r_{\min}}^{r_{\max}} |w(r)(T_i(r) - T_0(r))| dr</code>
</p>

</li></ul>

</li>
<li><p> Calculates the p-value.
</p>
</li></ul>



<h3>Value</h3>

<p>If 'savedevs=FALSE' (default), the p-value is returned.
If 'savedevs=TRUE', then a list containing the p-value and calculated deviation measures
<code class="reqn">u_i</code>, <code class="reqn">i=1,...,\text{nsim}+1</code> (where <code class="reqn">u_1</code> corresponds to the data pattern) is returned.
</p>


<h3>References</h3>

<p>Myllymäki, M., Grabarnik, P., Seijo, H. and Stoyan. D. (2015). Deviation test construction and power comparison for marked spatial point patterns. Spatial Statistics 11: 19-34. doi: 10.1016/j.spasta.2014.11.004
</p>
<p>Myllymäki, M., Mrkvička, T., Grabarnik, P., Seijo, H. and Hahn, U. (2017). Global envelope tests for spatial point patterns. Journal of the Royal Statistical Society: Series B (Statistical Methodology), 79: 381–404. doi: 10.1111/rssb.12172
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Testing complete spatial randomness (CSR)
#-------------------------------------------
if(require("spatstat.explore", quietly=TRUE)) {
  pp &lt;- unmark(spruces)
  nsim &lt;- 999
  
  # Generate nsim simulations under CSR, calculate L-function for the data and simulations
  env &lt;- envelope(pp, fun="Lest", nsim=nsim, savefuns=TRUE, correction="translate")
  # The deviation test using the integral deviation measure
  res &lt;- deviation_test(env, measure='int')
  res
  # or
  res &lt;- deviation_test(env, r_min=0, r_max=7, measure='int2')
}

</code></pre>

<hr>
<h2 id='fallen_trees'>Fallen trees</h2><span id='topic+fallen_trees'></span>

<h3>Description</h3>

<p>Fallen trees
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("fallen_trees")
</code></pre>


<h3>Format</h3>

<p>A <code><a href="base.html#topic+list">list</a></code> of two data frames, where <code>trees</code> contains the locations (x and y coordinates)
and heights (=marks) of 232 trees in a window with polygonal boundary, and <code>window</code> species the polygonal
window (see examples).
</p>


<h3>Details</h3>

<p>The dataset comprised the locations and heights of 232 trees, which fell during two large wind
gusts (1967 and 1990) in the west of France (Pontailler et al., 1997). The study area was a
biological reserve, which had been preserved for at least four centuries, with little human
influence for a long period (Guinier, 1950). Thus, the forest stand followed almost natural
dynamics. It was an uneven-aged beech stand with a few old oaks.
</p>
<p>The data was analysed in Myllymäki et al. (2017, Supplementary material).
</p>


<h3>References</h3>

<p>Guinier, P. (1950) Foresterie et protection de la nature. l’exemple de fontainebleau. Rev Forestière Fr., II, 703-717.
</p>
<p>Pontailler, J.-Y., Faille, A. and Lemée, G. (1997) Storms drive successional dynamics in natural forests: a case study in fontainebleau forest (france). Forest Ecol. Manag., 98, 1-15.
</p>
<p>Myllymäki, M., Mrkvička, T., Grabarnik, P., Seijo, H. and Hahn, U. (2017). Global envelope tests for spatial point patterns. Journal of the Royal Statistical Society: Series B (Statistical Methodology), 79: 381–404. doi: 10.1111/rssb.12172
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("fallen_trees")
if(require("spatstat.geom", quietly=TRUE)) {
  fallen_trees &lt;- as.ppp(fallen_trees$trees, W = owin(poly=fallen_trees$window))
  plot(fallen_trees)
}
</code></pre>

<hr>
<h2 id='fBoxplot'>Functional boxplot</h2><span id='topic+fBoxplot'></span>

<h3>Description</h3>

<p>Functional boxplot based on central region computed by a specified measure.
The options of the measures can be found in <code><a href="#topic+central_region">central_region</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fBoxplot(curve_sets, factor = 1.5, coverage = 0.5, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fBoxplot_+3A_curve_sets">curve_sets</code></td>
<td>
<p>A <code><a href="#topic+curve_set">curve_set</a></code> object or a list of <code><a href="#topic+curve_set">curve_set</a></code> objects.
Also <code>envelope</code> objects of <span class="pkg">spatstat</span> and <code>fdata</code> of <span class="pkg">fda.usc</span>
are accepted instead of curve_set objects.</p>
</td></tr>
<tr><td><code id="fBoxplot_+3A_factor">factor</code></td>
<td>
<p>The constant factor to inflate the central region to produce a functional boxplot and
determine fences for outliers. Default is 1.5 as in a classical boxplot.</p>
</td></tr>
<tr><td><code id="fBoxplot_+3A_coverage">coverage</code></td>
<td>
<p>A number between 0 and 1. The 100*coverage% central region will be calculated.
A vector of values can also be provided, leading to the corresponding number of central regions.</p>
</td></tr>
<tr><td><code id="fBoxplot_+3A_...">...</code></td>
<td>
<p>Additional parameters to be passed to <code><a href="#topic+central_region">central_region</a></code>,
which is responsible for calculating the central region (global envelope) on which
the functional boxplot is based.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>if(requireNamespace("fda", quietly=TRUE)) {
  years &lt;- paste(1:18)
  curves &lt;- fda::growth[['hgtf']][years,]
  # Heights
  cset1 &lt;- curve_set(r = as.numeric(years),
                     obs = curves)
  bp &lt;- fBoxplot(cset1, coverage=0.50, type="area", factor=1)
  plot(bp)

  # Considering simultaneously heights and height differences
  cset2 &lt;- curve_set(r = as.numeric(years[-1]),
                     obs = curves[-1,] - curves[-nrow(curves),])
  csets &lt;- list(Height=cset1, Change=cset2)
  res &lt;- fBoxplot(csets, type='area', factor=1.5)
  plot(res) + ggplot2::labs(x="Age (years)", y="")
}
</code></pre>

<hr>
<h2 id='fclustering'>Functional clustering</h2><span id='topic+fclustering'></span>

<h3>Description</h3>

<p>Functional clustering based on a specified measure.
The options of the measures can be found in <code><a href="#topic+central_region">central_region</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fclustering(
  curve_sets,
  k,
  type = c("area", "st", "erl", "cont"),
  triangineq = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fclustering_+3A_curve_sets">curve_sets</code></td>
<td>
<p>A <code>curve_set</code> object or a list of <code>curve_set</code> objects to which
the functional clustering is to be applied. If list of <code>curve_set</code> objects is provided,
then the joined functional clustering is applied, which provides an equal weight combination
of <code>curve_set</code> objects, if the <code>curve_set</code> objects contain the same numbers of elements
(same lengths of vector <code class="reqn">r</code>).</p>
</td></tr>
<tr><td><code id="fclustering_+3A_k">k</code></td>
<td>
<p>The number of clusters.</p>
</td></tr>
<tr><td><code id="fclustering_+3A_type">type</code></td>
<td>
<p>The measure which is used to compute the dissimilarity matrix. The preferred options
are <code>"area"</code> and <code>"st"</code>, but <code>"erl"</code> and <code>"cont"</code> can be also used with caution.</p>
</td></tr>
<tr><td><code id="fclustering_+3A_triangineq">triangineq</code></td>
<td>
<p>Logical. Whether or not to compute the proportion of combinations
of functions which satisfies the triangular inequality, see 'Value'.</p>
</td></tr>
<tr><td><code id="fclustering_+3A_...">...</code></td>
<td>
<p>Additional parameters to be passed to <code><a href="#topic+central_region">central_region</a></code>,
which is responsible for calculating the central region (global envelope)
on which the functional clustering is based.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Functional clustering joins the list of <code>curve_set</code> objects in one <code>curve_set</code> with long functions and
applies on the differences of all functions the specified measure. This provides a dissimilarity matrix
which is used in partitioning around medoids procedure. The resulting clusters can then be shown by plotting
the function respectively for each <code>curve_set</code>. Thus for each <code>curve_set</code>, the panel with all the medoids
is shown followed by all clusters represented by central region, medoid and all curves belonging to it, when
the result object is plotted.
</p>
<p>If there are less than three curves in some of the groups, then the central region is not plotted.
This leads to a warning message from ggplot2.
</p>


<h3>Value</h3>

<p>An object having the class <code>fclust</code>, containing
</p>

<ul>
<li><p> curve_sets = The set(s) of functions determined for clustering
</p>
</li>
<li><p> k = Number of clusters
</p>
</li>
<li><p> type = Type of clustering method
</p>
</li>
<li><p> triangineq = The proportion of combinations of functions which satisfies the triangular inequality.
The triangular inequality must hold to ensure the chosen measure forms a metric. In some weird cases
it does not hold for ‘area’ measure, therefore this check is provided to ensure the data forms metric
with the ‘area’ measure. The triangineq must be 1 to ensure the inequality holds for all functions.
</p>
</li>
<li><p> dis = The joined dissimilarity matrix
</p>
</li>
<li><p> pam = Results of the partitioning around medoids (pam) method applied on the joined functions
with the dissimilarity matrix (dis). See <code><a href="cluster.html#topic+pam">pam</a></code>.
</p>
</li></ul>



<h3>References</h3>

<p>Dai, W., Athanasiadis, S., Mrkvička, T. (2021) A new functional clustering method with combined dissimilarity sources and graphical interpretation. Intech open, London, UK. DOI: 10.5772/intechopen.100124
</p>


<h3>See Also</h3>

<p><code><a href="#topic+central_region">central_region</a></code>, <code><a href="#topic+plot.fclust">plot.fclust</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Read raw data from population growth rdata
# with countries over million inhabitants
data("popgrowthmillion")

# Create centred data
m &lt;- apply(popgrowthmillion, 2, mean) # Country-wise means
cpopgrowthmillion &lt;- popgrowthmillion
for(i in 1:dim(popgrowthmillion)[1]) {
  cpopgrowthmillion[i,] &lt;- popgrowthmillion[i,] - m
}

# Create scaled data
t2 &lt;- function(v) { sqrt(sum(v^2)) }
s &lt;- apply(cpopgrowthmillion, 2, t2)
spopgrowthmillion &lt;- popgrowthmillion
for(i in 1:dim(popgrowthmillion)[1]) {
  spopgrowthmillion[i,] &lt;- cpopgrowthmillion[i,]/s
}

# Create curve sets
r &lt;- 1951:2015

cset1 &lt;- curve_set(r = r, obs = popgrowthmillion)
cset2 &lt;- curve_set(r = r, obs = spopgrowthmillion)
csets &lt;- list(Raw = cset1, Shape = cset2)

# Functional clustering with respect to joined "st" difference measure
# and "joined" central regions of each group
res &lt;- fclustering(csets, k=3, type="area")
p &lt;- plot(res, plotstyle = "marginal", coverage = 0.5)
p[[1]] # Central functions
p[[2]] # Groups: central functions and regions
# To collect the two figures into one use, e.g., patchwork:
if(require("patchwork", quietly=TRUE)) {
  p[[1]] + p[[2]] + plot_layout(widths = c(1, res$k))
}
# Silhouette plot of pam
plot(res$pam)
</code></pre>

<hr>
<h2 id='fdr_envelope'>The FDR envelope</h2><span id='topic+fdr_envelope'></span>

<h3>Description</h3>

<p>Calculate the FDR envelope based on the ATSE or IATSE algorithm
of Mrkvička and Myllymäki (2023).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fdr_envelope(
  curve_sets,
  alpha = 0.05,
  alternative = c("two.sided", "less", "greater"),
  algorithm = c("IATSE", "ATSE"),
  lower = NULL,
  upper = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fdr_envelope_+3A_curve_sets">curve_sets</code></td>
<td>
<p>A <code><a href="#topic+curve_set">curve_set</a></code> object or a list of <code><a href="#topic+curve_set">curve_set</a></code>
objects containing a data function and simulated functions from which the envelope is
to be constructed.
Also <code>envelope</code> objects of <span class="pkg">spatstat</span> are accepted instead of curve_set objects.
If an envelope object is given, it must contain the summary
functions from simulated patterns which can be achieved by setting
<code>savefuns = TRUE</code> when calling the <code>envelope</code> function.</p>
</td></tr>
<tr><td><code id="fdr_envelope_+3A_alpha">alpha</code></td>
<td>
<p>The significance level. The 100(1-alpha)% global envelope will be calculated
under the 'fwer' or 'fdr' control.
If a vector of values is provided, the global envelopes are calculated for each value.</p>
</td></tr>
<tr><td><code id="fdr_envelope_+3A_alternative">alternative</code></td>
<td>
<p>A character string specifying the alternative hypothesis.
Must be one of the following: &quot;two.sided&quot; (default), &quot;less&quot; or &quot;greater&quot;.
The last two options only available for types <code>'rank'</code>, <code>'erl'</code>,
<code>'cont'</code> and <code>'area'</code>.</p>
</td></tr>
<tr><td><code id="fdr_envelope_+3A_algorithm">algorithm</code></td>
<td>
<p>The algorithm for the computation of the FDR envelope.
Either &quot;IATSE&quot; or &quot;ATSE&quot; standing for the iteratively adaptive two-stage
envelope and the adaptive two-stage envelope, respectively, see Mrkvička and Myllymäki (2023).</p>
</td></tr>
<tr><td><code id="fdr_envelope_+3A_lower">lower</code></td>
<td>
<p>A single number (or a vector of suitable length) giving a lower bound
for the functions. Used only for the extension of the FDR envelope.</p>
</td></tr>
<tr><td><code id="fdr_envelope_+3A_upper">upper</code></td>
<td>
<p>A single number (or a vector of suitable length) giving an upper bound
for the functions. Used only for the extension of the FDR envelope.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Typical use of this function is through other functions.
<code>fdr_envelope(cset)</code> is the same as <code>global_envelope_test(cset, typeone = "fdr")</code>.
Functions such as <code><a href="#topic+graph.fanova">graph.fanova</a></code>, <code><a href="#topic+graph.flm">graph.flm</a></code>, <code><a href="#topic+frank.flm">frank.flm</a></code>
allow to use the FDR control by specifying <code>typeone = "fdr"</code> appropriately
(passing this to <code>global_envelope_test</code>).
</p>


<h3>References</h3>

<p>Mrkvička and Myllymäki (2023). False discovery rate envelopes. Statistics and Computing 33, 109. https://doi.org/10.1007/s11222-023-10275-7
</p>


<h3>Examples</h3>

<pre><code class='language-R'># A GLM example
data(rimov)
nsim &lt;- 1000 # Number of simulations

res &lt;- graph.flm(nsim=nsim,
                 formula.full = Y~Year,
                 formula.reduced = Y~1,
                 curve_sets = list(Y=rimov),
                 factors = data.frame(Year = 1979:2014),
                 GET.args = list(typeone = "fdr"))
plot(res)

</code></pre>

<hr>
<h2 id='forder'>Functional ordering</h2><span id='topic+forder'></span>

<h3>Description</h3>

<p>Calculates different measures for ordering the functions (or vectors)
from the most extreme to least extreme one
</p>


<h3>Usage</h3>

<pre><code class='language-R'>forder(
  curve_sets,
  measure = "erl",
  scaling = "qdir",
  alternative = c("two.sided", "less", "greater"),
  use_theo = TRUE,
  probs = c(0.025, 0.975),
  quantile.type = 7
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="forder_+3A_curve_sets">curve_sets</code></td>
<td>
<p>A <code><a href="#topic+curve_set">curve_set</a></code> object or a list of <code><a href="#topic+curve_set">curve_set</a></code> objects.
Also <code>envelope</code> objects of <span class="pkg">spatstat</span> and <code>fdata</code> of <span class="pkg">fda.usc</span>
are accepted instead of curve_set objects.</p>
</td></tr>
<tr><td><code id="forder_+3A_measure">measure</code></td>
<td>
<p>The measure to use to order the functions from the most extreme to the least extreme
one. Must be one of the following: 'rank', 'erl', 'cont', 'area', 'max', 'int', 'int2'. Default is 'erl'.</p>
</td></tr>
<tr><td><code id="forder_+3A_scaling">scaling</code></td>
<td>
<p>The name of the scaling to use if measure is 'max', 'int' or 'int2'.
Options include 'none', 'q', 'qdir' and 'st', where 'qdir' is the default.</p>
</td></tr>
<tr><td><code id="forder_+3A_alternative">alternative</code></td>
<td>
<p>A character string specifying the alternative hypothesis.
Must be one of the following: &quot;two.sided&quot; (default), &quot;less&quot; or &quot;greater&quot;.
The last two options only available for types <code>'rank'</code>, <code>'erl'</code>,
<code>'cont'</code> and <code>'area'</code>.</p>
</td></tr>
<tr><td><code id="forder_+3A_use_theo">use_theo</code></td>
<td>
<p>Logical. When calculating the measures 'max', 'int', 'int2',
should the theoretical function from <code>curve_set</code> be used (if 'theo' provided),
see <code><a href="#topic+deviation_test">deviation_test</a></code>.</p>
</td></tr>
<tr><td><code id="forder_+3A_probs">probs</code></td>
<td>
<p>A two-element vector containing the lower and upper
quantiles for the measure 'q' or 'qdir', in that order and on the interval [0, 1].
The default values are 0.025 and 0.975, suggested by Myllymäki et al. (2015, 2017).</p>
</td></tr>
<tr><td><code id="forder_+3A_quantile.type">quantile.type</code></td>
<td>
<p>As type argument of <code><a href="stats.html#topic+quantile">quantile</a></code>, how to
calculate quantiles for 'q' or 'qdir'.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given a <code><a href="#topic+curve_set">curve_set</a></code> object or an <code>envelope</code> object of <span class="pkg">spatstat</span>,
which contains curves <code class="reqn">T_1(r),\dots,T_s(r)</code>,
the functions are ordered from the most extreme one to the least extreme one
by one of the following measures (specified by the argument <code>measure</code>).
Note that <code>'erl'</code>, <code>'cont'</code> and <code>'area'</code> were proposed as a refinement to
the extreme ranks <code>'rank'</code>, because the extreme ranks can contain many ties.
All of these completely non-parametric measures are smallest for the most extreme functions
and largest for the least extreme ones,
whereas the deviation measures (<code>'max'</code>, <code>'int'</code> and <code>'int2'</code>) obtain largest values
for the most extreme functions.
</p>

<ul>
<li> <p><code>'rank'</code>: extreme rank (Myllymäki et al., 2017).
The extreme rank <code class="reqn">R_i</code> is defined as the minimum of pointwise ranks of the curve
<code class="reqn">T_i(r)</code>, where the pointwise rank is the rank of the value of the curve for a
specific r-value among the corresponding values of the s other curves such that the lowest
ranks correspond to the most extreme values of the curves. How the pointwise ranks are determined
exactly depends on the whether a one-sided (<code>alternative</code> is &quot;less&quot; or &quot;greater&quot;) or the
two-sided test (<code>alternative="two.sided"</code>) is chosen.
</p>
</li>
<li> <p><code>'erl'</code>: extreme rank length (Myllymäki et al., 2017).
Considering the vector of pointwise ordered ranks <code class="reqn">\mathbf{R}_i</code> of the ith curve,
the extreme rank length measure <code class="reqn">R_i^{erl}</code> is equal to
</p>
<p style="text-align: center;"><code class="reqn">R_i^{erl} = \frac{1}{s}\sum_{j=1}^{s} \mathbf{1}(\mathbf{R}_j "&lt;" \mathbf{R}_i)</code>
</p>

<p>where <code class="reqn">\mathbf{R}_j "&lt;" \mathbf{R}_i</code> if and only if
there exists <code class="reqn">n\leq d</code> such that for the first k, <code class="reqn">k&lt;n</code>, pointwise ordered
ranks of <code class="reqn">\mathbf{R}_j</code> and <code class="reqn">\mathbf{R}_i</code> are equal and the n'th rank of
<code class="reqn">\mathbf{R}_j</code> is smaller than that of <code class="reqn">\mathbf{R}_i</code>.
The scaling by </p>
<p style="text-align: center;"><code class="reqn">s</code>
</p>
<p> is applied to normalize the ranks following Mrkvička et al. (2019)
and Narisetty and Nair (2016).
</p>
</li>
<li> <p><code>'cont'</code>: continuous rank (Hahn, 2015; Mrkvička et al., 2019)
based on minimum of continuous pointwise ranks
</p>
</li>
<li> <p><code>'area'</code>: area rank (Mrkvička et al., 2019) based on area between continuous
pointwise ranks and minimum pointwise ranks for those argument (r) values for which pointwise
ranks achieve the minimum (it is a combination of erl and cont)
</p>
</li>
<li> <p><code>'max'</code> and <code>'int'</code> and <code>'int2'</code>:
Further options for the <code>measure</code> argument that can be used together with <code>scaling</code>.
See the help in <code><a href="#topic+deviation_test">deviation_test</a></code> for these options of <code>measure</code> and <code>scaling</code>.
These measures are largest for the most extreme functions and smallest for the least extreme ones.
The arguments <code>use_theo</code> and <code>probs</code> are relevant for these measures only (otherwise ignored).
</p>
</li></ul>

<p>For details see Myllymäki and Mrkvička et al. (2020, Section 2)
</p>


<h3>Value</h3>

<p>A vector containing one of the above mentioned measures k for each of the functions
in the curve set. If the component <code>obs</code> in the curve set is a vector, then its measure
will be the first component (named 'obs') in the returned vector.
</p>


<h3>References</h3>

<p>Hahn U (2015). “A note on simultaneous Monte Carlo tests.” Technical report, Centre for Stochastic Geometry and advanced Bioimaging, Aarhus University.
</p>
<p>Mrkvička, T., Myllymäki, M., Jilek, M. and Hahn, U. (2020) A one-way ANOVA test for functional data with graphical interpretation. Kybernetika 56(3), 432-458. doi: 10.14736/kyb-2020-3-0432
</p>
<p>Mrkvička, T., Myllymäki, M., Kuronen, M. and Narisetty, N. N. (2022) New methods for multiple testing in permutation inference for the general linear model. Statistics in Medicine 41(2), 276-297. doi: 10.1002/sim.9236
</p>
<p>Myllymäki, M., Grabarnik, P., Seijo, H. and Stoyan. D. (2015). Deviation test construction and power comparison for marked spatial point patterns. Spatial Statistics 11, 19-34. doi: 10.1016/j.spasta.2014.11.004
</p>
<p>Myllymäki, M., Mrkvička, T., Grabarnik, P., Seijo, H. and Hahn, U. (2017). Global envelope tests for spatial point patterns. Journal of the Royal Statistical Society: Series B (Statistical Methodology) 79, 381-404. doi: 10.1111/rssb.12172
</p>
<p>Narisetty, N. N. and Nair, V. J. (2016) Extremal depth for functional data and applications. Journal of the American Statistical Association 111, 1705-1714.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+partial_forder">partial_forder</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(requireNamespace("fda", quietly = TRUE)) {
  # Consider ordering of the girls in the Berkeley Growth Study data
  # available from the R package fda, see ?growth, according to their
  # annual heights or/and changes within years.
  # First create sets of curves (vectors), for raw heights and
  # for the differences within the years
  years &lt;- paste(1:18)
  curves &lt;- fda::growth[['hgtf']][years,]
  cset1 &lt;- curve_set(r = as.numeric(years),
                     obs = curves)
  cset2 &lt;- curve_set(r = as.numeric(years[-1]),
                     obs = curves[-1,] - curves[-nrow(curves),])

  # Order the girls from most extreme one to the least extreme one, below using the 'area' measure
  # a) according to their heights
  forder(cset1, measure = 'area')
  # Print the 10 most extreme girl indices
  order(forder(cset1, measure = 'area'))[1:10]
  # b) according to the changes (print indices)
  order(forder(cset2, measure = 'area'))[1:10]
  # c) simultaneously with respect to heights and changes (print indices)
  csets &lt;- list(Height = cset1, Change = cset2)
  order(forder(csets, measure = 'area'))[1:10]
}
</code></pre>

<hr>
<h2 id='frank.fanova'>Rank envelope F-test</h2><span id='topic+frank.fanova'></span>

<h3>Description</h3>

<p>A one-way functional ANOVA based on the rank envelope applied to F values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>frank.fanova(
  nsim,
  curve_set,
  groups,
  variances = "equal",
  test.equality = c("mean", "var", "cov"),
  cov.lag = 1,
  savefuns = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="frank.fanova_+3A_nsim">nsim</code></td>
<td>
<p>The number of random permutations.</p>
</td></tr>
<tr><td><code id="frank.fanova_+3A_curve_set">curve_set</code></td>
<td>
<p>The original data (an array of functions) provided as a
<code><a href="#topic+curve_set">curve_set</a></code> object or a <code>fdata</code> object of <span class="pkg">fda.usc</span>.
The curve set should include the argument values for the functions in the component <code>r</code>, and
the observed functions in the component <code>obs</code>.</p>
</td></tr>
<tr><td><code id="frank.fanova_+3A_groups">groups</code></td>
<td>
<p>The original groups (a factor vector representing the assignment to groups).</p>
</td></tr>
<tr><td><code id="frank.fanova_+3A_variances">variances</code></td>
<td>
<p>Either &quot;equal&quot; or &quot;unequal&quot;. If &quot;equal&quot;, then the traditional F-values are used.
If &quot;unequal&quot;, then the corrected F-values are used. The current implementation uses
<code><a href="stats.html#topic+lm">lm</a></code> to get the corrected F-values.</p>
</td></tr>
<tr><td><code id="frank.fanova_+3A_test.equality">test.equality</code></td>
<td>
<p>A character with possible values <code>mean</code> (default), <code>var</code> and
<code>cov</code>. If <code>mean</code>, the functional ANOVA is performed to compare the means in the groups.
If <code>var</code>, then the equality of variances of the curves in the groups is tested by performing
the graphical functional ANOVA test on the functions
</p>
<p style="text-align: center;"><code class="reqn">Z_{ij}(r) = T_{ij}(r) - \bar{T}_j(r).</code>
</p>

<p>If <code>cov</code>, then the equality of lag <code>cov.lag</code> covariance is tested by performing the fANOVA with
</p>
<p style="text-align: center;"><code class="reqn">W_{ij}(r) = \sqrt{|V_{ij}(r)|\cdot sign(V_{ij}(r))},</code>
</p>

<p>where
</p>
<p style="text-align: center;"><code class="reqn">V_{ij}(r) = (T_{ij}(r) - \bar{T}_j(r))((T_{ij}(r+s) - \bar{T}_j(r+s))).</code>
</p>

<p>See Mrkvicka et al. (2020) for more details.</p>
</td></tr>
<tr><td><code id="frank.fanova_+3A_cov.lag">cov.lag</code></td>
<td>
<p>The lag of the covariance for testing the equality of covariances,
see <code>test.equality</code>.</p>
</td></tr>
<tr><td><code id="frank.fanova_+3A_savefuns">savefuns</code></td>
<td>
<p>Logical. If TRUE, then the functions from permutations are saved to the attribute
simfuns.</p>
</td></tr>
<tr><td><code id="frank.fanova_+3A_...">...</code></td>
<td>
<p>Additional parameters to be passed to <code><a href="#topic+global_envelope_test">global_envelope_test</a></code>.
For example, the type of multiple testing control, FWER or FDR must be set by <code>typeone</code>.
And, if <code>typeone = "fwer"</code>, the type of the global envelope can be chosen by
specifying the argument <code>type</code>. See <code><a href="#topic+global_envelope_test">global_envelope_test</a></code>
for the defaults and available options.
(The test here uses <code>alternative="two.sided"</code> and <code>nstep=1</code> (when relevant),
but all the other specifications are to be given in <code>...</code>.)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The test assumes that there are <code class="reqn">J</code> groups which contain
<code class="reqn">n_1,\dots,n_J</code> functions
<code class="reqn">T_{ij}, i=\dots,J, j=1,\dots,n_j</code>.
The functions should be given in the argument x, and the groups in the argument groups.
The test assumes that there exists non random functions <code class="reqn">\mu(r)</code> and
<code class="reqn">\mu_i(r)</code> such that
</p>
<p style="text-align: center;"><code class="reqn">T_{ij}(r) =\mu(r) + \mu_i(r) + e_{ij}(r), i=1, \dots, J, j=1, \dots , n_j</code>
</p>

<p>where <code class="reqn">e_{ij}(r)</code> are independent and normally distributed.
The test vector is
</p>
<p style="text-align: center;"><code class="reqn">\mathbf{T} = (F(r_1), F(r_2), \dots , F(r_K)),</code>
</p>

<p>where <code class="reqn">F(r_i)</code> stands for the F-statistic. The simulations are performed by
permuting the test functions. Further details can be found in Mrkvička et al. (2020).
</p>
<p>The argument <code>variances="equal"</code> means that equal variances across groups are assumed.
The correction for unequal variances can be done by using the corrected F-statistic
(option <code>variances="unequal"</code>).
</p>
<p>Unfortunately this test is not able to detect which groups are different from each other.
</p>


<h3>References</h3>

<p>Mrkvička, T., Myllymäki, M., Jilek, M. and Hahn, U. (2020) A one-way ANOVA test for functional data with graphical interpretation. Kybernetika 56 (3), 432-458. doi: 10.14736/kyb-2020-3-0432
</p>


<h3>See Also</h3>

<p>graph.fanova
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("rimov")
groups &lt;- factor(c(rep(1, times=12), rep(2, times=12), rep(3, times=12)))
res &lt;- frank.fanova(nsim = 2499, curve_set = rimov, groups = groups)

plot(res)

data("imageset3")
res2 &lt;- frank.fanova(nsim = 19, # Increase nsim for serious analysis!
                     curve_set = imageset3$image_set,
                     groups = imageset3$Group)
plot(res2)
plot(res2, fixedscales=FALSE)
</code></pre>

<hr>
<h2 id='frank.flm'>F rank functional GLM</h2><span id='topic+frank.flm'></span>

<h3>Description</h3>

<p>Multiple testing in permutation inference for the general linear model (GLM)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>frank.flm(
  nsim,
  formula.full,
  formula.reduced,
  curve_sets,
  factors = NULL,
  savefuns = TRUE,
  lm.args = NULL,
  GET.args = NULL,
  mc.cores = 1,
  mc.args = NULL,
  cl = NULL,
  method = c("best", "mlm", "lm", "ne")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="frank.flm_+3A_nsim">nsim</code></td>
<td>
<p>The number of random permutations.</p>
</td></tr>
<tr><td><code id="frank.flm_+3A_formula.full">formula.full</code></td>
<td>
<p>The formula specifying the general linear model,
see <code>formula</code> in <code><a href="stats.html#topic+lm">lm</a></code>.</p>
</td></tr>
<tr><td><code id="frank.flm_+3A_formula.reduced">formula.reduced</code></td>
<td>
<p>The formula of the reduced model with nuisance factors only. This model
should be nested within the full model.</p>
</td></tr>
<tr><td><code id="frank.flm_+3A_curve_sets">curve_sets</code></td>
<td>
<p>A named list of sets of curves giving the dependent variable (Y), and
possibly additionally factors whose values vary across the argument values of the functions.
The dimensions of the elements should match with each other.
Note that factors that are fixed across the functions can be given in the argument <code>factors</code>.
Also <code><a href="fda.usc.html#topic+fdata">fdata</a></code> objects allowed.</p>
</td></tr>
<tr><td><code id="frank.flm_+3A_factors">factors</code></td>
<td>
<p>A data frame of factors. An alternative way to specify factors when they
are constant for all argument values of the functions. The number of rows of the data frame should be equal
to the number of curves. Each column should specify the values of a factor.</p>
</td></tr>
<tr><td><code id="frank.flm_+3A_savefuns">savefuns</code></td>
<td>
<p>Logical or &quot;return&quot;. If TRUE, then the functions from permutations are saved to the attribute simfuns.
If &quot;return&quot;, then the function returns the permutations in a curve_set, instead of the result of the envelope test on those;
this can be used by <code><a href="#topic+partial_forder">partial_forder</a></code>.</p>
</td></tr>
<tr><td><code id="frank.flm_+3A_lm.args">lm.args</code></td>
<td>
<p>A named list of additional arguments to be passed to <code><a href="stats.html#topic+lm">lm</a></code>. See details.</p>
</td></tr>
<tr><td><code id="frank.flm_+3A_get.args">GET.args</code></td>
<td>
<p>A named list of additional arguments to be passed to <code><a href="#topic+global_envelope_test">global_envelope_test</a></code>,
e.g. <code>typeone</code> specifies the type of multiple testing control, FWER or FDR.
See <code><a href="#topic+global_envelope_test">global_envelope_test</a></code> for the defaults and available options.</p>
</td></tr>
<tr><td><code id="frank.flm_+3A_mc.cores">mc.cores</code></td>
<td>
<p>The number of cores to use, i.e. at most how many child processes will be run simultaneously.
Must be at least one, and parallelization requires at least two cores. On a Windows computer mc.cores must be 1
(no parallelization). For details, see <code><a href="parallel.html#topic+mclapply">mclapply</a></code>, for which the argument is passed.
Parallelization can be used in generating simulations and in calculating the second stage tests.</p>
</td></tr>
<tr><td><code id="frank.flm_+3A_mc.args">mc.args</code></td>
<td>
<p>A named list of additional arguments to be passed to <code><a href="parallel.html#topic+mclapply">mclapply</a></code>.
Only relevant if <code>mc.cores</code> is more than 1.</p>
</td></tr>
<tr><td><code id="frank.flm_+3A_cl">cl</code></td>
<td>
<p>Allows parallelization through the use of <code><a href="parallel.html#topic+parLapply">parLapply</a></code> (works also
in Windows), see the argument <code>cl</code> there, and examples.</p>
</td></tr>
<tr><td><code id="frank.flm_+3A_method">method</code></td>
<td>
<p>For advanced use.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>frank.flm</code> performs
a nonparametric test of significance of a covariate in the functional GLM.
Similarly as in the graphical functional GLM (<code><a href="#topic+graph.flm">graph.flm</a></code>),
the Freedman-Lane algorithm (Freedman and Lane, 1983) is applied to permute the functions
(to obtain the simulations under the null hypothesis of &quot;no effects&quot;);
consequently, the test achieves the desired significance level only approximately.
If the reduced model contains only a constant, then the algorithm corresponds to
simple permutation of raw data.
In contrast to the graphical functional GLM, the F rank functional GLM is based on the
F-statistics that are calculated at each argument value of the functions.
The global envelope test is applied to the observed and simulated F-statistics.
The test is able to find if the factor of interest is significant and also which
argument values of the functional domain are responsible for the potential rejection.
</p>
<p>The specification of the full and reduced formulas is important. The reduced model should be
nested within the full model. The full model should include in addition to the reduced
model the interesting factors whose effects are under investigation.
</p>
<p>There are different versions of the implementation depending on the application.
</p>

<ul>
<li><p> If there are no extra arguments given by the user in <code>lm.args</code>, then a
fast implementation by solving the normal equations is used to directly compute the F-statistics.
</p>
</li>
<li><p> If all the covariates are constant across the functions, but there are some extra arguments,
then a linear model is fitted separately by least-squares estimation to
the data at each argument value of the functions fitting a multiple linear model by <code><a href="stats.html#topic+lm">lm</a></code>.
The possible extra arguments passed in <code>lm.args</code> to <code><a href="stats.html#topic+lm">lm</a></code> must be of the form that
<code><a href="stats.html#topic+lm">lm</a></code> accepts for fitting a multiple linear model. In the basic case, no extra arguments are
needed.
</p>
</li>
<li><p> If some of the covariates vary across the space and there are user specified extra arguments given in
<code>lm.args</code>, then the implementation fits a linear model at each argument value of the functions using
<code><a href="stats.html#topic+lm">lm</a></code>, which can be rather slow. The arguments <code>lm.args</code> are passed to <code><a href="stats.html#topic+lm">lm</a></code>
for fitting each linear model.
</p>
</li></ul>

<p>By default the fastest applicable method is used. This can be changed by setting <code>method</code> argument.
The cases above correspond to &quot;ne&quot;, &quot;mlm&quot; and &quot;lm&quot;. Changing the default can be useful for
checking the validity of the implementation.
</p>


<h3>Value</h3>

<p>A <code>global_envelope</code> object, which can be printed and plotted directly.
</p>


<h3>References</h3>

<p>Mrkvička, T., Myllymäki, M., Kuronen, M. and Narisetty, N. N. (2022) New methods for multiple testing in permutation inference for the general linear model. Statistics in Medicine 41(2), 276-297. doi: 10.1002/sim.9236
</p>
<p>Freedman, D., &amp; Lane, D. (1983) A nonstochastic interpretation of reported significance levels. Journal of Business &amp; Economic Statistics 1(4), 292-298. doi:10.2307/1391660
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("GDPtax")
factors.df &lt;- data.frame(Group = GDPtax$Group, Tax = GDPtax$Profittax)
nsim &lt;- 999

res.tax_within_group &lt;- frank.flm(nsim = nsim,
  formula.full = Y~Group+Tax+Group:Tax,
  formula.reduced = Y~Group+Tax,
  curve_sets = list(Y=GDPtax$GDP),
  factors = factors.df)
plot(res.tax_within_group)

# Image set examples
data("abide_9002_23")
iset &lt;- abide_9002_23$curve_set

res.F &lt;- frank.flm(nsim = 19, # Increase nsim for serious analysis!
  formula.full = Y ~ Group + Age + Sex,
  formula.reduced = Y ~ Age + Sex,
  curve_sets = list(Y = iset),
  factors = abide_9002_23[['factors']],
  GET.args = list(type = "area"))
plot(res.F)
</code></pre>

<hr>
<h2 id='GDP'>GDP</h2><span id='topic+GDP'></span>

<h3>Description</h3>

<p>Gross domestic product (GDP)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("GDP")
</code></pre>


<h3>Format</h3>

<p>A <code>curve_set</code> object containing the GDP values for different countries.
</p>


<h3>Details</h3>

<p>The data here was constructed based on the following data:
The GDP data are publicly available at
<a href="https://data.worldbank.org/indicator/NY.GDP.PCAP.CD">https://data.worldbank.org/indicator/NY.GDP.PCAP.CD</a>.
The excel file that we downloaded was called
<code>API_NY.GDP.PCAP.CD_DS2_en_excel_v2_3358980.xls</code>.
The inflation rates are publicly available at
<a href="https://data.worldbank.org/indicator/NY.GDP.DEFL.KD.ZG">https://data.worldbank.org/indicator/NY.GDP.DEFL.KD.ZG</a>.
The excel file that we downloaded was called
<code>API_NY.GDP.DEFL.KD.ZG_DS2_en_excel_v2_3469555.xls</code>,
from there we took only the inflation rates for United States.
Both are distributed under the CC-BY 4.0 license (see
https://datacatalog.worldbank.org/public-licenses#cc-by).
</p>
<p>Then we discounted the GDP of every country in the study to the 1960 USD,
and we extrapolated the missing values of the GDP of a country using the
closest known ratio of the GDP of the country and the median GDP in that year.
Further, the missing values of GDP were interpolated using linear
interpolation of the two closest ratios. Appendix of the
<code>vignette(FDRenvelopes)</code> includes the code to prepare the
<code>curve_set</code> object.
</p>

<hr>
<h2 id='GDPtax'>GDP per capita with country groups and profit tax</h2><span id='topic+GDPtax'></span>

<h3>Description</h3>

<p>GDP per capita with country groups and profit tax
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("GDPtax")
</code></pre>


<h3>Format</h3>

<p>A list of a three components. The first one (<code>GDP</code>) is a <code>curve_set</code> object with components <code>r</code> and <code>obs</code>
containing the years of observations and the GDP curves, i.e. the observed values of GDP in those years.
Each column of <code>obs</code> contains the GDP for the years for a particular country (seen as column names).
The country grouping is given in the list component <code>Group</code> and the profit tax in <code>Profittax</code>.
</p>


<h3>Details</h3>

<p>The data includes the GDP per capita (current US$) for years 1980-2017
(World Bank national accounts data, and OECD National Accounts data files).
The data have been downloaded from the webpage
https://datamarket.com/data/set/15c9/gdp-per-capita-current-us#!ds=15c9!hd1&amp;display=line,
distributed under the CC-BY 4.0 (https://datacatalog.worldbank.org/public-licenses#cc-by).
From the same webpage the profit tax in 2010 (World Bank, Doing Business Project (http://www.doingbusiness.org/ExploreTopics/PayingTaxes/)
and Total tax rate (
were downloaded.
Furthermore, different country groups were formed from
countries for which the GDP was available for 1980-2017 and profit tax for 2010:
</p>

<ul>
<li><p> Group 1 (Major Advanced Economies (G7)): &quot;Canada&quot;, &quot;France&quot;, &quot;Germany&quot;, &quot;Italy&quot;, Japan&quot;
</p>
</li>
<li><p> Group 2 (Euro Area excluding G7): &quot;Austria&quot;, &quot;Belgium&quot;, &quot;Cyprus&quot;, &quot;Finland&quot;, &quot;Greece&quot;, &quot;Ireland&quot;,
&quot;Luxembourg&quot;, &quot;Netherlands&quot;, &quot;Portugal&quot;, &quot;Spain&quot;
</p>
</li>
<li><p> Group 3 (Other Advanced Economies (Advanced Economies excluding G7 and Euro Area)):
&quot;Australia&quot;, &quot;Denmark&quot;, &quot;Iceland&quot;, &quot;Norway&quot;, &quot;Sweden&quot;, &quot;Switzerland&quot;
</p>
</li>
<li><p> Group 4 (Emerging and Developing Asia): &quot;Bangladesh&quot;, &quot;Bhutan&quot;, &quot;China&quot;, &quot;Fiji&quot;, &quot;India&quot;,
&quot;Indonesia&quot;, &quot;Malaysia&quot;, &quot;Nepal&quot;, &quot;Philippines&quot;, &quot;Thailand&quot;, &quot;Vanuatu&quot;
</p>
</li></ul>



<h3>References</h3>

<p>World Bank national accounts data, and OECD National Accounts data files. URL: https://data.worldbank.org/indicator/NY.GDP.PCAP.CD
World Bank, Doing Business Project (http://www.doingbusiness.org/ExploreTopics/PayingTaxes/). URL: https://data.worldbank.org/indicator/IC.TAX.PRFT.CP.ZS
</p>


<h3>See Also</h3>

<p><code><a href="#topic+graph.flm">graph.flm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("GDPtax")
# Plot data in groups
for(i in 1:4)
  assign(paste0("p", i), plot(subset(GDPtax$GDP, GDPtax$Group == i)) +
    ggplot2::labs(title=paste("Group ", i, sep=""), y="GDP"))
p4
if(require("patchwork", quietly=TRUE))
  p1 + p2 + p3 + p4
</code></pre>

<hr>
<h2 id='geom_central_region'>Central region plot</h2><span id='topic+geom_central_region'></span><span id='topic+stat_central_region'></span>

<h3>Description</h3>

<p><code>geom_central_region</code> and <code>stat_central_region</code> can be used to compute
and plot <code>central_region</code> from data arranged in a <code>data.frame</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geom_central_region(
  mapping = NULL,
  data = NULL,
  stat = "CentralRegion",
  position = "identity",
  ...,
  coverage = 0.5,
  type = "erl",
  filled = TRUE,
  drawcenterline = TRUE,
  colours = grey.colors(length(coverage), start = 0.9, end = 0.5),
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE
)

stat_central_region(
  mapping = NULL,
  data = NULL,
  position = "identity",
  ...,
  coverage = 0.5,
  type = "erl",
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="geom_central_region_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="ggplot2.html#topic+aes">aes()</a></code>. If specified and
<code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping
at the top level of the plot. You must supply <code>mapping</code> if there is no plot
mapping.</p>
</td></tr>
<tr><td><code id="geom_central_region_+3A_data">data</code></td>
<td>
<p>The data to be displayed in this layer. There are three
options:
</p>
<p>If <code>NULL</code>, the default, the data is inherited from the plot
data as specified in the call to <code><a href="ggplot2.html#topic+ggplot">ggplot()</a></code>.
</p>
<p>A <code>data.frame</code>, or other object, will override the plot
data. All objects will be fortified to produce a data frame. See
<code><a href="ggplot2.html#topic+fortify">fortify()</a></code> for which variables will be created.
</p>
<p>A <code>function</code> will be called with a single argument,
the plot data. The return value must be a <code>data.frame</code>, and
will be used as the layer data. A <code>function</code> can be created
from a <code>formula</code> (e.g. <code>~ head(.x, 10)</code>).</p>
</td></tr>
<tr><td><code id="geom_central_region_+3A_stat">stat</code></td>
<td>
<p>The statistical transformation to use on the data for this layer.
When using a <code style="white-space: pre;">&#8288;geom_*()&#8288;</code> function to construct a layer, the <code>stat</code>
argument can be used the override the default coupling between geoms and
stats. The <code>stat</code> argument accepts the following:
</p>

<ul>
<li><p> A <code>Stat</code> ggproto subclass, for example <code>StatCount</code>.
</p>
</li>
<li><p> A string naming the stat. To give the stat as a string, strip the
function name of the <code>stat_</code> prefix. For example, to use <code>stat_count()</code>,
give the stat as <code>"count"</code>.
</p>
</li>
<li><p> For more information and other ways to specify the stat, see the
<a href="ggplot2.html#topic+layer_stats">layer stat</a> documentation.
</p>
</li></ul>
</td></tr>
<tr><td><code id="geom_central_region_+3A_position">position</code></td>
<td>
<p>A position adjustment to use on the data for this layer. This
can be used in various ways, including to prevent overplotting and
improving the display. The <code>position</code> argument accepts the following:
</p>

<ul>
<li><p> The result of calling a position function, such as <code>position_jitter()</code>.
This method allows for passing extra arguments to the position.
</p>
</li>
<li><p> A string naming the position adjustment. To give the position as a
string, strip the function name of the <code>position_</code> prefix. For example,
to use <code>position_jitter()</code>, give the position as <code>"jitter"</code>.
</p>
</li>
<li><p> For more information and other ways to specify the position, see the
<a href="ggplot2.html#topic+layer_positions">layer position</a> documentation.
</p>
</li></ul>
</td></tr>
<tr><td><code id="geom_central_region_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to <code><a href="ggplot2.html#topic+layer">layer()</a></code>'s <code>params</code> argument. These
arguments broadly fall into one of 4 categories below. Notably, further
arguments to the <code>position</code> argument, or aesthetics that are required
can <em>not</em> be passed through <code>...</code>. Unknown arguments that are not part
of the 4 categories below are ignored.
</p>

<ul>
<li><p> Static aesthetics that are not mapped to a scale, but are at a fixed
value and apply to the layer as a whole. For example, <code>colour = "red"</code>
or <code>linewidth = 3</code>. The geom's documentation has an <strong>Aesthetics</strong>
section that lists the available options. The 'required' aesthetics
cannot be passed on to the <code>params</code>. Please note that while passing
unmapped aesthetics as vectors is technically possible, the order and
required length is not guaranteed to be parallel to the input data.
</p>
</li>
<li><p> When constructing a layer using
a <code style="white-space: pre;">&#8288;stat_*()&#8288;</code> function, the <code>...</code> argument can be used to pass on
parameters to the <code>geom</code> part of the layer. An example of this is
<code>stat_density(geom = "area", outline.type = "both")</code>. The geom's
documentation lists which parameters it can accept.
</p>
</li>
<li><p> Inversely, when constructing a layer using a
<code style="white-space: pre;">&#8288;geom_*()&#8288;</code> function, the <code>...</code> argument can be used to pass on parameters
to the <code>stat</code> part of the layer. An example of this is
<code>geom_area(stat = "density", adjust = 0.5)</code>. The stat's documentation
lists which parameters it can accept.
</p>
</li>
<li><p> The <code>key_glyph</code> argument of <code><a href="ggplot2.html#topic+layer">layer()</a></code> may also be passed on through
<code>...</code>. This can be one of the functions described as
<a href="ggplot2.html#topic+draw_key">key glyphs</a>, to change the display of the layer in the legend.
</p>
</li></ul>
</td></tr>
<tr><td><code id="geom_central_region_+3A_coverage">coverage</code></td>
<td>
<p>A number between 0 and 1. The 100*coverage% central region will be calculated.
A vector of values can also be provided, leading to the corresponding number of central regions.</p>
</td></tr>
<tr><td><code id="geom_central_region_+3A_type">type</code></td>
<td>
<p>The options and details for <code>type</code> are given in <code><a href="#topic+central_region">central_region</a></code>.</p>
</td></tr>
<tr><td><code id="geom_central_region_+3A_filled">filled</code></td>
<td>
<p>Boolean. Should the ribbon be filled?</p>
</td></tr>
<tr><td><code id="geom_central_region_+3A_drawcenterline">drawcenterline</code></td>
<td>
<p>Boolean. Should the center line be drawn?</p>
</td></tr>
<tr><td><code id="geom_central_region_+3A_colours">colours</code></td>
<td>
<p>Colours for different coverage levels</p>
</td></tr>
<tr><td><code id="geom_central_region_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code>FALSE</code>, the default, missing values are removed with
a warning. If <code>TRUE</code>, missing values are silently removed.</p>
</td></tr>
<tr><td><code id="geom_central_region_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.
It can also be a named logical vector to finely select the aesthetics to
display.</p>
</td></tr>
<tr><td><code id="geom_central_region_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics,
rather than combining with them. This is most useful for helper functions
that define both data and aesthetics and shouldn't inherit behaviour from
the default plot specification, e.g. <code><a href="ggplot2.html#topic+borders">borders()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Plots of central regions (global envelopes) with the specified <code>coverage</code>
and <code>type</code> (see <code><a href="#topic+central_region">central_region</a></code>).
When splitting the set of functions to groups by aesthetics or facets, see
examples, the central regions are constructed separately for each group,
each having the specified <code>coverage</code>.
</p>
<p>If Nfunc*(1-coverage) &lt; 1, where Nfunc is the number of functions/curves,
the curves are plotted instead of any region.
</p>


<h3>Aesthetics</h3>

<p><code>geom_central_region</code> requires <code>x</code>, <code>y</code> and <code>curveid</code>.
Additionally <code>geom_central_region</code> uses the same aesthetics as
<code><a href="ggplot2.html#topic+geom_ribbon">geom_ribbon</a></code> if <code>filled==TRUE</code> and
<code><a href="ggplot2.html#topic+geom_line">geom_line</a></code> otherwise.
For multiple coverage values additional aesthetics are not currently supported.
</p>


<h3>Computed variables</h3>

<p><code>stat_central_region</code> computes
<code>after_stat(ymax)</code> and <code>after_stat(ymin)</code> for the high and low value of the central region.
</p>
<p>For multiple coverages the variables use the same names as <code><a href="#topic+central_region">central_region</a></code>,
i.e. <code>hi.95</code> and <code>lo.95</code> for the region with 95% coverage.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+central_region">central_region</a></code> for the basic computation and,
<code><a href="ggplot2.html#topic+geom_ribbon">geom_ribbon</a></code> for the default base geom.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require("ggplot2")
## Generate some data
#------------------------------------------------------
# Simulate regression data according to the cubic model
# f(x) = 0.8x - 1.8x^2 + 1.05x^3 for x in [0,1]
par &lt;- c(0,0.8,-1.8,1.05) # Parameters of the true polynomial model
res &lt;- 100 # Resolution
x &lt;- seq(0, 1, by=1/res); x2=x^2; x3=x^3;

f &lt;- par[1] + par[2]*x + par[3]*x^2 + par[4]*x^3 # The true function
d &lt;- f + rnorm(length(x), 0, 0.04) # Data

# Estimate polynomial regression model
reg &lt;- lm(d ~ x + x2 + x3)
ftheta &lt;- reg$fitted.values
resid0 &lt;- reg$residuals

# Bootstrap regression
B &lt;- 200 # Number of bootstrap samples
df &lt;- NULL
for(i in 1:B) {
  u &lt;- sample(resid0, size=length(resid0), replace=TRUE)
  reg1 &lt;- lm((ftheta+u) ~ x + x2 + x3)
  df &lt;- rbind(df, data.frame(y=reg1$fitted.values, x=x, i=i,
    g=ifelse(i&lt;14, "A", "B"), g2=ifelse(i&lt;100, "A", "B")))
}

ggplot(df) + geom_line(aes(x, y, group=i))
ggplot(df) + geom_central_region(aes(x=x, y=y, curveid=i), coverage=0.50)
ggplot(df) + geom_central_region(aes(x=x, y=y, curveid=i), coverage=0.50, filled=FALSE)
# Central regions for two groups as specified by 'g2'
ggplot(df) + geom_central_region(aes(x=x, y=y, curveid=i, col=g2), coverage=0.90, filled=FALSE)
ggplot(df) + geom_central_region(aes(x=x, y=y, curveid=i), coverage=0.90) + facet_wrap(vars(g2))


# Central regions with multiple coverage levels
ggplot(df) + geom_central_region(aes(x=x, y=y, curveid=i), coverage=c(0.2,0.4,0.6)) +
  theme_minimal()
ggplot(df) + geom_central_region(aes(x=x, y=y, curveid=i), coverage=seq(0.1, 0.9, length=20),
  colours=rainbow(20))


# Colors for multiregions are not supported
ggplot(df) + geom_central_region(aes(x=x, y=y+0.1*(g2=="B"),
  curveid=i, col=as.factor(g2)), coverage=c(0.05, 0.2,0.4,0.6))

ggplot(df) + geom_central_region(aes(x=x, y=y, curveid=i),
  coverage=c(0.05, 0.2,0.4,0.6)) + facet_wrap(vars(g2))

# Using stat_central_region with geom_linerange and geom_rect
ggplot(df) +
  geom_linerange(aes(curveid=i, x=x, y=y, ymax=after_stat(ymax), ymin=after_stat(ymin),
               group=g2, col=factor(g2)),
               stat="central_region", coverage = 0.90, position=position_dodge(0.01))
ggplot(within(df, {x = x+0.004*(g2=="B")})) +
  geom_rect(aes(curveid=i, x=x, y=y, xmax=after_stat(x), xmin=after_stat(x+0.004),
              ymax=after_stat(ymax), ymin=after_stat(ymin), group=g2, fill=factor(g2)),
              stat="central_region", coverage = 0.90)

# Non-finite values are not supported
ggplot(within(df, {y = ifelse(runif(length(y)) &lt; 0.001, Inf, y)})) +
  geom_central_region(aes(x=x, y=y, curveid=i))

</code></pre>

<hr>
<h2 id='GET.composite'>Adjusted global envelope tests</h2><span id='topic+GET.composite'></span><span id='topic+dg.global_envelope_test'></span>

<h3>Description</h3>

<p>Adjusted global envelope tests for composite null hypothesis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GET.composite(
  X,
  X.ls = NULL,
  nsim = 499,
  nsimsub = nsim,
  simfun = NULL,
  fitfun = NULL,
  calcfun = function(X) {
     X
 },
  testfuns = NULL,
  ...,
  type = "erl",
  alpha = 0.05,
  alternative = c("two.sided", "less", "greater"),
  probs = c(0.025, 0.975),
  r_min = NULL,
  r_max = NULL,
  take_residual = FALSE,
  save.cons.envelope = savefuns,
  savefuns = FALSE,
  verbose = TRUE,
  MrkvickaEtal2017 = FALSE,
  mc.cores = 1L
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="GET.composite_+3A_x">X</code></td>
<td>
<p>An object containing the data in some form.
A <code><a href="#topic+curve_set">curve_set</a></code> object, or an <code>envelope</code> object of the <span class="pkg">spatstat</span> package,
as the <code>curve_sets</code> argument of <code><a href="#topic+global_envelope_test">global_envelope_test</a></code>
(need to provide <code>X.ls</code>), or
a fitted point process model of <span class="pkg">spatstat</span> (e.g. object of class <code>ppm</code> or
<code>kppm</code>), or a point pattern object of class <code>ppp</code> of <span class="pkg">spatstat</span>,
or another data object (need to provide <code>simfun</code>, <code>fitfun</code>, <code>calcfun</code>).</p>
</td></tr>
<tr><td><code id="GET.composite_+3A_x.ls">X.ls</code></td>
<td>
<p>A list of objects as <code>curve_sets</code> argument of <code><a href="#topic+global_envelope_test">global_envelope_test</a></code>,
giving the second stage simulations, see details.</p>
</td></tr>
<tr><td><code id="GET.composite_+3A_nsim">nsim</code></td>
<td>
<p>The number of simulations to be generated in the primary test.
Ignored if <code>X.ls</code> provided.</p>
</td></tr>
<tr><td><code id="GET.composite_+3A_nsimsub">nsimsub</code></td>
<td>
<p>Number of simulations in each basic test. There will be <code>nsim</code> repetitions
of the basic test, each involving <code>nsimsub</code> simulated realisations.
Total number of simulations will be nsim * (nsimsub + 1).</p>
</td></tr>
<tr><td><code id="GET.composite_+3A_simfun">simfun</code></td>
<td>
<p>A function for generating simulations from the null model. If given, this function
is called by <code>replicate(n=nsim, simfun(simfun.arg), simplify=FALSE)</code> to make nsim
simulations. Here <code>simfun.arg</code> is obtained by <code>fitfun(X)</code>.</p>
</td></tr>
<tr><td><code id="GET.composite_+3A_fitfun">fitfun</code></td>
<td>
<p>A function for estimating the parameters of the null model.
The function should return the fitted model in the form that it can be directly
passed to <code>simfun</code> as its argument.</p>
</td></tr>
<tr><td><code id="GET.composite_+3A_calcfun">calcfun</code></td>
<td>
<p>A function for calculating a summary function from a simulation of the model.
The default is the identity function, i.e. the simulations from the model are functions themselves.
The use of <code>calcfun</code> is still experimental. Preferably provide <code>X</code> and
<code>X.ls</code> instead, if <code>X</code> is not a point pattern or fitted point process model object
of <span class="pkg">spatstat</span>.</p>
</td></tr>
<tr><td><code id="GET.composite_+3A_testfuns">testfuns</code></td>
<td>
<p>A list of lists of parameters to be passed to the <code>envelope</code> function of <span class="pkg">spatstat</span>
if <code>X</code> is a point pattern of a fitted point process model of <span class="pkg">spatstat</span>.
A list of parameters should be provided for each test function that is to be used in the
combined test.</p>
</td></tr>
<tr><td><code id="GET.composite_+3A_...">...</code></td>
<td>
<p>Additional parameters to the <code>envelope</code> function of <span class="pkg">spatstat</span> in the case where
only one test function is used. In that case, this is an alternative to providing the parameters in the
argument testfuns. If <code>envelope</code> is also used to generate simulations under the null
hypothesis (if simfun not provided), then also recall to specify how to generate the simulations.</p>
</td></tr>
<tr><td><code id="GET.composite_+3A_type">type</code></td>
<td>
<p>The type of the global envelope with current options for 'rank', 'erl', 'cont', 'area',
'qdir', 'st' and 'unscaled'. See details.</p>
</td></tr>
<tr><td><code id="GET.composite_+3A_alpha">alpha</code></td>
<td>
<p>The significance level. The 100(1-alpha)% global envelope will be calculated
under the 'fwer' or 'fdr' control.
If a vector of values is provided, the global envelopes are calculated for each value.</p>
</td></tr>
<tr><td><code id="GET.composite_+3A_alternative">alternative</code></td>
<td>
<p>A character string specifying the alternative hypothesis.
Must be one of the following: &quot;two.sided&quot; (default), &quot;less&quot; or &quot;greater&quot;.
The last two options only available for types <code>'rank'</code>, <code>'erl'</code>,
<code>'cont'</code> and <code>'area'</code>.</p>
</td></tr>
<tr><td><code id="GET.composite_+3A_probs">probs</code></td>
<td>
<p>A two-element vector containing the lower and upper
quantiles for the measure 'q' or 'qdir', in that order and on the interval [0, 1].
The default values are 0.025 and 0.975, suggested by Myllymäki et al. (2015, 2017).</p>
</td></tr>
<tr><td><code id="GET.composite_+3A_r_min">r_min</code></td>
<td>
<p>The minimum argument value to include in the test.</p>
</td></tr>
<tr><td><code id="GET.composite_+3A_r_max">r_max</code></td>
<td>
<p>The maximum argument value to include in the test.
in calculating functions by the <code>envelope</code> function of <span class="pkg">spatstat</span>.</p>
</td></tr>
<tr><td><code id="GET.composite_+3A_take_residual">take_residual</code></td>
<td>
<p>Logical. If TRUE (needed for visual reasons only) the mean of the simulated
functions is reduced from the functions in each first and second stage test.</p>
</td></tr>
<tr><td><code id="GET.composite_+3A_save.cons.envelope">save.cons.envelope</code></td>
<td>
<p>Logical flag indicating whether to save the unadjusted envelope test results.</p>
</td></tr>
<tr><td><code id="GET.composite_+3A_savefuns">savefuns</code></td>
<td>
<p>Logical flag indicating whether to save all the simulated function values.
Similar to the same argument of the <code>envelope</code> function of <span class="pkg">spatstat</span>.</p>
</td></tr>
<tr><td><code id="GET.composite_+3A_verbose">verbose</code></td>
<td>
<p>Logical flag indicating whether to print progress reports during the simulations.
Similar to the same argument of <code>envelope</code> function of <span class="pkg">spatstat</span>.</p>
</td></tr>
<tr><td><code id="GET.composite_+3A_mrkvickaetal2017">MrkvickaEtal2017</code></td>
<td>
<p>Logical. If TRUE, type is &quot;st&quot; or &quot;qdir&quot; and several test functions are used,
then the combined scaled MAD envelope presented in Mrkvička et al. (2017) is calculated. Otherwise,
the two-step procedure described in <code><a href="#topic+global_envelope_test">global_envelope_test</a></code> is used for combining the tests.
Default to FALSE. The option is kept for historical reasons.</p>
</td></tr>
<tr><td><code id="GET.composite_+3A_mc.cores">mc.cores</code></td>
<td>
<p>The number of cores to use, i.e. at most how many child processes will be run simultaneously.
Must be at least one, and parallelization requires at least two cores. On a Windows computer mc.cores must be 1
(no parallelization). For details, see <code><a href="parallel.html#topic+mclapply">mclapply</a></code>, for which the argument is passed.
Parallelization can be used in generating simulations and in calculating the second stage tests.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The specification of X, X.ls, fitfun, simfun is important:
</p>

<ul>
<li><p> If <code>X.ls</code> is provided, then the global envelope test is calculated based on
functions in these objects. <code>X</code> should be a <code><a href="#topic+curve_set">curve_set</a></code> object,
or an <code>envelope</code> object of <span class="pkg">spatstat</span>, including the observed function and simulations
from the tested model. <code>X.ls</code> should be a list of <code>curve_set</code> or
envelope (of R package <span class="pkg">spatstat</span>) objects, where each component contains an &quot;observed&quot;
function f that has been simulated from the model fitted to the data and the simulations
that have been obtained from the same model that has been fitted to the &quot;observed&quot; f.
The user has the responsibility that the functions have been generated correctly,
the test is done based on these provided simulations. See the examples.
</p>
</li>
<li><p> Otherwise, if <code>simfun</code> and <code>fitfun</code> are provided, <code>X</code> can be general.
The function <code>fitfun</code> is used for fitting the desired model M and the function <code>simfun</code>
for simulating from a fitted model M. These functions should be coupled with each other such
that the object returned by <code>fitfun</code> is directly accepted as the (single) argument in
<code>simfun</code>.
In the case, that the global envelope should not be calculated directly for <code>X</code> (<code>X</code> is
not a function), <code>calcfun</code> can be used to specify how to calculate the function from
<code>X</code> and from simulations generated by <code>simfun</code>.
Special attention is needed in the correct specification of the functions, see examples.
</p>
</li>
<li><p> Otherwise, <code>X</code> should be either a fitted (point process) model object or a <code>ppp</code>
object of the R package <span class="pkg">spatstat</span>.
</p>

<ul>
<li><p> If <code>X</code> is a fitted (point process) model object of the R package <span class="pkg">spatstat</span>,
then the simulations from this model are generated and summary functions for testing calculated
by the <code>envelope</code> function of <span class="pkg">spatstat</span>. Which summary function to use and how to calculate it,
can be passed to <code>envelope</code> either in <code>...</code> or <code>testfuns</code>.
Unless otherwise specified the default function of <code>envelope</code>,
i.g. the K-function, is used. The argument <code>testfuns</code> should be used to specify the
test functions in the case where one wants to base the test on several test functions.
</p>
</li>
<li><p> If <code>X</code> is a <code>ppp</code> object of <span class="pkg">spatstat</span>, then the <code>envelope</code> function
is used for simulations and model fitting and the complete spatial randomness (CSR) is tested
(with intensity parameter).
</p>
</li></ul>

</li></ul>

<p>For the rank envelope test, the global envelope test is the test described in
Myllymäki et al. (2017) with the adjustment of Baddeley et al. (2017).
For other test types, the test (also) uses the two-stage procedure of Dao and Genton (2014) with
the adjustment of Baddeley et al. (2017) as descripbed in Myllymäki and Mrkvička (2024).
</p>
<p>See examples also in <code><a href="#topic+saplings">saplings</a></code>.
</p>


<h3>Value</h3>

<p>An object of class <code>global_envelope</code> or <code>combined_global_envelope</code>, which can be
printed and plotted directly. See <code><a href="#topic+global_envelope_test">global_envelope_test</a></code>.
</p>


<h3>References</h3>

<p>Baddeley, A., Hardegen, A., Lawrence, T., Milne, R. K., Nair, G. and Rakshit, S. (2017). On two-stage Monte Carlo tests of composite hypotheses. Computational Statistics and Data Analysis 114: 75-87. doi: http://dx.doi.org/10.1016/j.csda.2017.04.003
</p>
<p>Dao, N.A. and Genton, M. (2014). A Monte Carlo adjusted goodness-of-fit test for parametric models describing spatial point patterns. Journal of Graphical and Computational Statistics 23, 497-517.
</p>
<p>Mrkvička, T., Myllymäki, M. and Hahn, U. (2017) Multiple Monte Carlo testing, with applications in spatial point processes. Statistics &amp; Computing 27(5): 1239-1255. doi: 10.1007/s11222-016-9683-9
</p>
<p>Myllymäki, M., Mrkvička, T., Grabarnik, P., Seijo, H. and Hahn, U. (2017). Global envelope tests for spatial point patterns. Journal of the Royal Statistical Society: Series B (Statistical Methodology), 79: 381-404. doi: 10.1111/rssb.12172
</p>
<p>Myllymäki, M. and Mrkvička, T. (2024). GET: Global envelopes in R. Journal of Statistical Software 111(3), 1-40. doi: 10.18637/jss.v111.i03
</p>


<h3>See Also</h3>

<p><code><a href="#topic+global_envelope_test">global_envelope_test</a></code>, <code><a href="#topic+plot.global_envelope">plot.global_envelope</a></code>, <code><a href="#topic+saplings">saplings</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Graphical normality test (Myllymaki and Mrkvicka, 2020, Section 3.3.)
#=========================
if(require("fda.usc", quietly=TRUE)) {
  data("poblenou")
  dat &lt;- poblenou[['nox']][['data']][,'H10']
  n &lt;- length(dat)

  # The number of simulations
  nsim &lt;- nsimsub &lt;- 199
  

  set.seed(200127)
  # General setup
  #==============
  # 1. Fit the model
  mu &lt;- mean(dat)
  sigma &lt;- sd(dat)
  # 2. Simulate a sample from the fitted null model and
  #    compute the test vectors for data (obs) and each simulation (sim)
  r &lt;- seq(min(dat), max(dat), length=100)
  obs &lt;- stats::ecdf(dat)(r)
  sim &lt;- sapply(1:nsimsub, function(i) {
    x &lt;- rnorm(n, mean = mu, sd = sigma)
    stats::ecdf(x)(r)
  })
  cset &lt;- create_curve_set(list(r = r, obs = obs, sim_m = sim))

  # 3. Simulate another sample from the fitted null model.
  # 4. Fit the null model to each of the patterns,
  #    simulate a sample from the null model,
  #    and compute the test vectors for all.
  cset.ls &lt;- vector("list", nsim)
  for(rep in 1:nsim) {
    x &lt;- rnorm(n, mean = mu, sd = sigma)
    mu2 &lt;- mean(x)
    sigma2 &lt;- sd(x)
    obs2 &lt;- stats::ecdf(x)(r)
    sim2 &lt;- sapply(1:nsimsub, function(i) {
      x2 &lt;- rnorm(n, mean = mu2, sd = sigma2)
      stats::ecdf(x2)(r)
    })
    cset.ls[[rep]] &lt;- create_curve_set(list(r = r, obs = obs2, sim_m = sim2))
  }
  # Perform the adjusted test
  res &lt;- GET.composite(X = cset, X.ls = cset.ls, type = 'erl')
  plot(res) + ggplot2::labs(x = "NOx", y = "Ecdf")
}

# Example of a point pattern data
#================================
# Test the fit of a Matern cluster process.

if(require("spatstat.model", quietly=TRUE)) {
  data("saplings")
  saplings &lt;- as.ppp(saplings, W = square(75))

  # First choose the r-distances
  rmin &lt;- 0.3; rmax &lt;- 10; rstep &lt;- (rmax-rmin)/500
  r &lt;- seq(0, rmax, by = rstep)

  # Number of simulations
  nsim &lt;- 19 # Increase nsim for serious analysis!

  # Option 1: Give the fitted model object to GET.composite
  #--------------------------------------------------------
  # This can be done and is preferable when the model is
  # a point process model of spatstat.
  # 1. Fit the Matern cluster process to the pattern
  # (using minimum contrast estimation with the K-function)
  M1 &lt;- kppm(saplings~1, clusters = "MatClust", statistic = "K")
  summary(M1)
  # 2. Make the adjusted global area rank envelope test using the L(r)-r function
  adjenvL &lt;- GET.composite(X = M1, nsim = nsim,
              testfuns = list(L =list(fun="Lest", correction="translate",
                            transform=expression(.-r), r=r)), # passed to envelope
              type = "area", r_min = rmin, r_max = rmax)
  # Plot the test result
  plot(adjenvL)

  # Option 2: Generate the simulations "by yourself"
  #-------------------------------------------------
  # and provide them as curve_set or envelope objects
  # Preferable when you want to have a control
  # on the simulations yourself.
  # 1. Fit the model
  M1 &lt;- kppm(saplings~1, clusters = "MatClust", statistic = "K")
  # 2. Generate nsim simulations by the given function using the fitted model
  X &lt;- envelope(M1, nsim = nsim, savefuns = TRUE,
                fun = "Lest", correction = "translate",
                transform = expression(.-r), r = r)
  plot(X)
  # 3. Create another set of simulations to be used to estimate
  # the second-state p-value (as proposed by Baddeley et al., 2017).
  simpatterns2 &lt;- simulate(M1, nsim = nsim)
  # 4. Calculate the functions for each pattern
  simf &lt;- function(rep) {
    # Fit the model to the simulated pattern Xsims[[rep]]
    sim_fit &lt;- kppm(simpatterns2[[rep]], clusters = "MatClust", statistic = "K")
    # Generate nsim simulations from the fitted model
    envelope(sim_fit, nsim = nsim, savefuns = TRUE,
             fun = "Lest", correction = "translate",
             transform = expression(.-r), r = r)
  }
  X.ls &lt;- parallel::mclapply(X = 1:nsim, FUN = simf, mc.cores = 1) # list of envelope objects
  # 5. Perform the adjusted test
  res &lt;- GET.composite(X = X, X.ls = X.ls, type = "area",
                      r_min = rmin, r_max = rmax)
  plot(res)
}
</code></pre>

<hr>
<h2 id='GET.distrequal'>Graphical n sample test of correspondence of distribution functions</h2><span id='topic+GET.distrequal'></span><span id='topic+GET.necdf'></span>

<h3>Description</h3>

<p>Compare the distributions of two (or more) samples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GET.distrequal(
  x,
  stat = "ECDF",
  nsim,
  r = seq(min(unlist((lapply(x, min)))), max(unlist((lapply(x, max)))), length = 100),
  tau = seq(0.1, 0.9, length = 100),
  contrasts = FALSE,
  GET.args = NULL,
  density.args = NULL,
  approxfun.args = NULL,
  rq.args = NULL,
  savefuns = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="GET.distrequal_+3A_x">x</code></td>
<td>
<p>A list of numeric vectors, one for each sample.</p>
</td></tr>
<tr><td><code id="GET.distrequal_+3A_stat">stat</code></td>
<td>
<p>Character string indicating which test statistic to be used. See details.</p>
</td></tr>
<tr><td><code id="GET.distrequal_+3A_nsim">nsim</code></td>
<td>
<p>The number of random permutations.</p>
</td></tr>
<tr><td><code id="GET.distrequal_+3A_r">r</code></td>
<td>
<p>The sequence of argument values at which the test functions are to be compared.
The default is 100 equally spaced values between the minimum and maximum over all groups.</p>
</td></tr>
<tr><td><code id="GET.distrequal_+3A_tau">tau</code></td>
<td>
<p>The sequence of argument values for the QR test statistic.
The default values are 100 equally spaced values between 0.1 and 0.9.</p>
</td></tr>
<tr><td><code id="GET.distrequal_+3A_contrasts">contrasts</code></td>
<td>
<p>Logical. FALSE and TRUE specify the two test functions as described in
description part of this help file.</p>
</td></tr>
<tr><td><code id="GET.distrequal_+3A_get.args">GET.args</code></td>
<td>
<p>A named list of additional arguments to be passed to <code><a href="#topic+global_envelope_test">global_envelope_test</a></code>,
e.g. <code>typeone</code> specifies the type of multiple testing control, FWER or FDR.
See <code><a href="#topic+global_envelope_test">global_envelope_test</a></code> for the defaults and available options.</p>
</td></tr>
<tr><td><code id="GET.distrequal_+3A_density.args">density.args</code></td>
<td>
<p>A named list of additional arguments to be passed for the estimation of the test statistic <code>"DEN"</code>.
For more details see <code><a href="stats.html#topic+density">density</a></code>.</p>
</td></tr>
<tr><td><code id="GET.distrequal_+3A_approxfun.args">approxfun.args</code></td>
<td>
<p>A named list of additional arguments to be passed for the estimation of the the test statistic <code>"QQ"</code>.
For more details see <code><a href="stats.html#topic+approxfun">approxfun</a></code>.</p>
</td></tr>
<tr><td><code id="GET.distrequal_+3A_rq.args">rq.args</code></td>
<td>
<p>A named list of additional arguments to be passed for the estimation of the test statistic <code>"QR"</code>.
For more details see the function <code>rq</code> of <span class="pkg">quantreq</span>.</p>
</td></tr>
<tr><td><code id="GET.distrequal_+3A_savefuns">savefuns</code></td>
<td>
<p>Logical. If TRUE, then the functions from permutations are saved to the attribute
simfuns.</p>
</td></tr>
<tr><td><code id="GET.distrequal_+3A_...">...</code></td>
<td>
<p>Additional parameters to be passed to <code><a href="#topic+global_envelope_test">global_envelope_test</a></code>.
For example, the type of multiple testing control, FWER or FDR must be set by <code>typeone</code>.
And, if <code>typeone = "fwer"</code>, the type of the global envelope can be chosen by
specifying the argument <code>type</code>. See <code><a href="#topic+global_envelope_test">global_envelope_test</a></code>
for the defaults and available options.
(The test here uses <code>alternative="two.sided"</code> and <code>nstep=1</code> (when relevant),
but all the other specifications are to be given in <code>...</code>.)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A global envelope test can be performed to investigate whether the n distribution functions
differ from each other and how do they differ. This test is a generalization of
the two-sample Kolmogorov-Smirnov test with a graphical interpretation.
We assume that the observations in the sample <code class="reqn">i</code> are an i.i.d. sample from the distribution
<code class="reqn">F_i(r), i=1, \dots, n,</code>
and we want to test the hypothesis
</p>
<p style="text-align: center;"><code class="reqn">F_1(r)= \dots = F_n(r).</code>
</p>

<p>If <code>contrasts = FALSE</code> (default), then the default test statistic (&quot;ECDF&quot;) is taken to be
</p>
<p style="text-align: center;"><code class="reqn">\mathbf{T} = (\hat{F}_1(r), \dots, \hat{F}_n(r))</code>
</p>

<p>where <code class="reqn">\hat{F}_i(r) = (\hat{F}_i(r_1), \dots, \hat{F}_i(r_k))</code>
is the ecdf of the <code class="reqn">i</code>th sample evaluated at argument values
<code class="reqn">r = (r_1,\dots,r_k)</code>.
</p>
<p>Another possibility is given by <code>stat = "DIFF"</code>, and then the test statistic is
still based on the ECDFs and constructed from all pairwise differences,
</p>
<p style="text-align: center;"><code class="reqn">\mathbf{T} = (\hat{F}_1(r)-\hat{F}_2(r), \hat{F}_1(r)-\hat{F}_3(r), \dots, \hat{F}_{n-1}(r)-\hat{F}_n(r))</code>
</p>

<p>The choices <code>contrasts = TRUE</code> and <code>stat = "ECDF"</code> lead to the same test statistic.
For other (or multiple) values of <code>stat</code>, the argument <code>contrasts</code> is ignored.
</p>
<p>All the options as the test statistics are the following:
</p>

<ol>
<li> <p><code>"ECDF"</code>: The ECDFs of the n-samples, as specified above
</p>
</li>
<li> <p><code>"DIFF"</code>: The pairwise differences between the ECDFs, as specified above
</p>
</li>
<li> <p><code>"DEN"</code>: The kernel estimated density functions of the n-samples as the test statistic
</p>
</li>
<li> <p><code>"QQ"</code>: The pairwise comparisons of empirical quantiles
</p>
</li>
<li> <p><code>"SHIFT"</code> The de-trended QQ-plot (shift plot)
</p>
</li>
<li> <p><code>"QR"</code>: The quantile regression process, i.e. the <code class="reqn">\beta</code>-coefficients of the quantile regression.
By default, the reference category of this test statistic is the first sample.
</p>
</li></ol>

<p>The test statistics are described in detail in Konstantinou et al. (2024).
</p>
<p>The simulations under the null hypothesis that the distributions are the same are obtained
by permuting the individuals of the groups. The default number of permutation, if <code>nsim</code> is not specified,
is <code class="reqn">n \cdot 1000-1</code> for the case <code>contrasts = FALSE</code> and
<code class="reqn">(n \cdot (n-1)/2) \cdot 1000 - 1</code> for the case <code>contrasts = TRUE</code>,
where <code class="reqn">n</code> is the length of <code class="reqn">x</code>.
</p>


<h3>References</h3>

<p>Konstantinou K., Mrkvička T. and Myllymäki M. (2024) Graphical n-sample tests of correspondence of distributions. arXiv:2403.01838 [stat.ME] https://doi.org/10.48550/arXiv.2403.01838
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(require("fda", quietly=TRUE)) {
  # Heights of boys and girls at age 10
  f.a &lt;- growth$hgtf["10",] # girls at age 10
  m.a &lt;- growth$hgtm["10",] # boys at age 10
  # Empirical cumulative distribution functions
  plot(ecdf(f.a))
  plot(ecdf(m.a), col='grey70', add=TRUE)
  # Create a list of the data
  fm.list &lt;- list(Girls=f.a, Boys=m.a)
  
  res &lt;- GET.distrequal(fm.list)
  plot(res)
  # If you want to change the labels:
  plot(res, scales = "free", labels = c("Girls", "Boys"))
  # If you want to change the x-label (y-label similarly):
  require("ggplot2")
  myxlab &lt;- substitute(paste(italic(i), " (", j, ")", sep = ""),
                       list(i = "x", j = "Height in cm"))
  plot(res, scales = "free") + xlab(myxlab)
  # Use instead the test statistics QQ and DEN
  res &lt;- GET.distrequal(fm.list, stat = c("QQ", "DEN"))
  plot(res, scales = "free")
  
  

  # Heights of boys and girls at age 14
  f.a &lt;- growth$hgtf["14",] # girls at age 14
  m.a &lt;- growth$hgtm["14",] # boys at age 14
  # Empirical cumulative distribution functions
  plot(ecdf(f.a))
  plot(ecdf(m.a), col='grey70', add=TRUE)
  # Create a list of the data
  fm.list &lt;- list(Girls=f.a, Boys=m.a)
  
  res &lt;- GET.distrequal(fm.list)
  plot(res) + xlab(myxlab)
  res &lt;- GET.distrequal(fm.list, stat = c("QQ", "DEN"))
  plot(res, scales = "free") + xlab(myxlab)
  
  
}
if(require("datasets", quietly=TRUE)) {
  data("iris")
  virginica &lt;- subset(iris, Species == "virginica")
  setosa &lt;- subset(iris, Species == "setosa")
  versicolor &lt;- subset(iris, Species == "versicolor")
  
  res &lt;- GET.distrequal(x = list(virginica = virginica$Sepal.Length,
                                 setosa = setosa$Sepal.Length,
                                 versicolor = versicolor$Sepal.Length),
                        stat =  c("QQ", "DEN"))
  plot(res, scales = "free", ncol = 3)
  
  
}
</code></pre>

<hr>
<h2 id='GET.distrindep'>Test of independence of two general distributions</h2><span id='topic+GET.distrindep'></span>

<h3>Description</h3>

<p>Permutation-based test of independence in a bivariate vector
using as the test statistic either
1) the empirical joint cumulative distribution function,
2) the matrix of observed counts of a 2D contingency table, or
3) the smoothed Q-Q plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GET.distrindep(
  X,
  nsim = 999,
  statistic = c("cdf", "contingency", "qq"),
  ngrid,
  seq.x,
  seq.y,
  sigma,
  atoms.x,
  atoms.y,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="GET.distrindep_+3A_x">X</code></td>
<td>
<p>A matrix with n rows and 2 columns. Each row contains
one bivariate observation.</p>
</td></tr>
<tr><td><code id="GET.distrindep_+3A_nsim">nsim</code></td>
<td>
<p>The number of random permutations used.</p>
</td></tr>
<tr><td><code id="GET.distrindep_+3A_statistic">statistic</code></td>
<td>
<p>Either &quot;cdf&quot;, &quot;contingency&quot; or &quot;qq&quot; corresponding to the three
test functions.</p>
</td></tr>
<tr><td><code id="GET.distrindep_+3A_ngrid">ngrid</code></td>
<td>
<p>Vector with two elements, giving the number of grid
points to be used in the test statistic for each of the two marginals.
The default is 20 in each marginal for &quot;cdf&quot; and 64 for &quot;qq&quot;.
(This is not relevant for &quot;contingency&quot;.)</p>
</td></tr>
<tr><td><code id="GET.distrindep_+3A_seq.x">seq.x</code></td>
<td>
<p>For the first marginal, the values at which the
empirical cumulative distribution function will be evaluated.
If NULL (the default), sequence of quantiles will be used,
equidistant in terms of probability.
seq.x and seq.y only relevant for &quot;cdf&quot;.</p>
</td></tr>
<tr><td><code id="GET.distrindep_+3A_seq.y">seq.y</code></td>
<td>
<p>For the second marginal, the values at which the
empirical cumulative distribution function will be evaluated.
If NULL (the default), sequence of quantiles will be used,
equidistant in terms of probability.
seq.x and seq.y only relevant for &quot;cdf&quot;.</p>
</td></tr>
<tr><td><code id="GET.distrindep_+3A_sigma">sigma</code></td>
<td>
<p>Standard deviation of the smoothing kernel to be 
used for smoothing the Q-Q plot when computing the test statistic.
If NULL, sensible default value is used based on the number of observations.</p>
</td></tr>
<tr><td><code id="GET.distrindep_+3A_atoms.x">atoms.x</code></td>
<td>
<p>Vector specifying atomic values in the first marginal.
Only relevant for &quot;qq&quot;. See Examples.</p>
</td></tr>
<tr><td><code id="GET.distrindep_+3A_atoms.y">atoms.y</code></td>
<td>
<p>Vector specifying atomic values in the second marginal.
Only relevant for &quot;qq&quot;. See Examples.</p>
</td></tr>
<tr><td><code id="GET.distrindep_+3A_...">...</code></td>
<td>
<p>Additional parameters to be passed to <code><a href="#topic+global_envelope_test">global_envelope_test</a></code>.
In particularly, <code>alpha</code> specifies the nominal significance level of the test,
and <code>type</code> the type of the global envelope test.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function performs permutation-based test of independence in a bivariate sample
based on three different test statistics chosen by the argument <code>statistic</code>.
</p>
<p>If the observed data are the pairs <code class="reqn">\{(X_1, Y_1), \ldots, (X_n, Y_n)\}</code>,
the permutations are obtained by randomly permuting the values
in the second marginal, i.e. <code class="reqn">\{(X_1, Y_{\pi(1)}), \ldots, (X_n, Y_{\pi(n)})\}</code>.
</p>
<p>The first alternative <code>statistic = "cdf"</code> is the empirical joint cumulative distribution function
computed on a grid of <code>ngrid[1]</code> times <code>ngrid[2]</code> arguments.
The grid points are chosen according to the quantiles of the
marginal distributions.
The second alternative <code>statistic = "contingency"</code> is to test of independence in a 2D contingency table,
using the matrix of observed counts as the test statistic.
The third alternative <code>statistic = "qq"</code> is based on Q-Q representation and estimate of the intensity function
computed on a regular grid of <code>ngrid[1]</code> times <code>ngrid[2]</code> points.
</p>
<p>The test itself is in each case performed using the global envelope test of the chosen version,
see the argument <code>type</code> of <code><a href="#topic+global_envelope_test">global_envelope_test</a></code>.
</p>
<p>In the case of a 2D contingency table, instead of plotting,
text output can be printed in the console by typing the object name.
The cells in which the observed value exceeds the upper envelope printed in red,
and cells in which the observed value is lower than the lower
envelope printed in cyan. Standard output of the global envelope
test is also returned and can be plotted or analyzed accordingly.
</p>


<h3>References</h3>

<p>Dvořák, J. and Mrkvička, T. (2022). Graphical tests of independence for general distributions. Computational Statistics 37, 671&ndash;699.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#- Example of cdf
#----------------
# Generate sample data
data &lt;- matrix(rnorm(n=200), ncol=2) %*% matrix(c(1,1,0,1), ncol=2)
plot(data)

# Compute the CDF test and plot the significant regions
res &lt;- GET.distrindep(data, statistic="cdf", ngrid=c(20,15), nsim=1999)

plot(res) + ggplot2::scale_radius(range = 2 * c(1, 6))

# Extract the p-value
attr(res,"p")

#- Example of a 2D contingency table
#-----------------------------------
# Generate sample data:
data &lt;- matrix(c(sample(4, size=100, replace=TRUE), sample(2, size=100, replace=TRUE)), ncol=2)
data[,2] &lt;- data[,2] + data[,1]

# Observed contingency table (with row names and column names)
table(data[,1], data[,2])

# Permutation-based envelope test
res &lt;- GET.distrindep(data, statistic="contingency", nsim=999)

res
plot(res) + ggplot2::scale_radius(range = 5 * c(1, 6))

# Extract the p-value
attr(res,"p")

# Example of QQ
#--------------
# Generate sample data
data &lt;- matrix(rnorm(n=200), ncol=2) %*% matrix(c(1,1,0,1), ncol=2)

plot(data)

# Compute the QQ test and plot the significant regions
res &lt;- GET.distrindep(data, statistic="qq", ngrid=c(30,20), nsim=999)

plot(res)
# Extract the p-value
attr(res,"p")

# With atoms, independent
data &lt;- cbind(rnorm(n=100), sample(4, size=100, replace=TRUE))
plot(data)
res &lt;- GET.distrindep(data, statistic="qq", nsim=999, atoms.y=c(1,2,3,4))

plot(res)


# With atoms, dependent
data &lt;- cbind(sort(rnorm(n=100)), sort(sample(4, size=100, replace=TRUE)))
plot(data)
res &lt;- GET.distrindep(data, statistic="qq", nsim=999, atoms.y=c(1,2,3,4))
plot(res, sign.type="col", what=c("obs", "lo", "hi", "lo.sign", "hi.sign"))


# Atoms in both variables
data &lt;- cbind(rnorm(n=100), rnorm(n=100)) %*% matrix(c(1,1,0,1), ncol=2)
data[,1][data[,1]&lt;=-1] &lt;- -1
data[,2][data[,2]&lt;=-0.5] &lt;- -0.5
plot(data)

# Perform the test
res &lt;- GET.distrindep(data, statistic="qq", nsim=999, atoms.x=c(-1), atoms.y=c(-0.5))

plot(res, sign.type="col", what=c("obs", "lo", "hi", "lo.sign", "hi.sign"))
</code></pre>

<hr>
<h2 id='GET.localcor'>The test of local correlations</h2><span id='topic+GET.localcor'></span>

<h3>Description</h3>

<p>The test of local correlations using Vilodomat et al. (2014) procedure for resamples
and the FDR envelope of Mrkvička and Myllymäki (2023).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GET.localcor(
  data,
  Delta,
  nsim = 1000,
  ...,
  varying.bandwidth = FALSE,
  bandwidth.nn = 0.1,
  bandwidth.h = 5.281,
  maxk = 300,
  savefuns = FALSE,
  N_s = 1000,
  mc.cores = 1L,
  mc.args = NULL,
  cl = NULL,
  notest = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="GET.localcor_+3A_data">data</code></td>
<td>
<p>A data.frame where the first two columns correspond to the values of the two random fields,
whose correlations are to be studied, and the third and fourth columns correspond to the x- and y-coordinates
where these random fields have been observed. In addition, the width and height of the pixels at each (x,y)
can be given in the fifth and sixth column. Warning: no checks for the data input.</p>
</td></tr>
<tr><td><code id="GET.localcor_+3A_delta">Delta</code></td>
<td>
<p>A smoothing parameter of the local correlation.
According to Vilodomat et al. (2014): Delta is a set of values for the proportion of neighbors
to consider for the smoothing step. No default. The user may have to experiment with different
values to find one suitable for their data.</p>
</td></tr>
<tr><td><code id="GET.localcor_+3A_nsim">nsim</code></td>
<td>
<p>The number of resamples.</p>
</td></tr>
<tr><td><code id="GET.localcor_+3A_...">...</code></td>
<td>
<p>Additional parameters to be passed to <code><a href="#topic+global_envelope_test">global_envelope_test</a></code>.
Note that for testing local correlations, it may often be preferable to use FDR control.
This can be specified by setting <code>typeone = "fdr"</code>, while the default is FWER control.
See <code><a href="#topic+global_envelope_test">global_envelope_test</a></code> for defaults and available options.</p>
</td></tr>
<tr><td><code id="GET.localcor_+3A_varying.bandwidth">varying.bandwidth</code></td>
<td>
<p>Logical, whether to use a varying bandwidth to calculate the local correlations or not.
See Vilodomat et al. (2014).</p>
</td></tr>
<tr><td><code id="GET.localcor_+3A_bandwidth.nn">bandwidth.nn</code></td>
<td>
<p>Nearest neighbor component of the smoothing parameter for varying bandwidth to
be passed to the argument <code>nn</code> of the function <code>lp</code> of the <span class="pkg">locfit</span> package.
The user may have to experiment with different values to find one suitable for their data.
Default set to to 0.1 according to Vilodamat et al. (2014, supporting information).</p>
</td></tr>
<tr><td><code id="GET.localcor_+3A_bandwidth.h">bandwidth.h</code></td>
<td>
<p>Non-varying bandwidth, to be passed to the argument <code>h</code> of
the function <code>lp</code> of <span class="pkg">locfit</span>.
The user may have to experiment with different values to find one suitable for their data.
Default to 5.281 according to Vilodamat et al. (2014, supporting information).</p>
</td></tr>
<tr><td><code id="GET.localcor_+3A_maxk">maxk</code></td>
<td>
<p>See <code>locfit</code> and <code>locfit.raw</code> of <span class="pkg">locfit</span>. Default here to 300
following Vilodomat et al. (2014).</p>
</td></tr>
<tr><td><code id="GET.localcor_+3A_savefuns">savefuns</code></td>
<td>
<p>Logical. If TRUE, then the functions from permutations are saved to the attribute
simfuns.</p>
</td></tr>
<tr><td><code id="GET.localcor_+3A_n_s">N_s</code></td>
<td>
<p>If the number of observations is bigger than <code>N_s</code>, following Vilodomat et al. (2014)
a subsample of size N_s is taken every time when a variogram is calculated.</p>
</td></tr>
<tr><td><code id="GET.localcor_+3A_mc.cores">mc.cores</code></td>
<td>
<p>The number of cores to use, i.e. at most how many child processes will be run simultaneously.
Must be at least one, and parallelization requires at least two cores. On a Windows computer mc.cores must be 1
(no parallelization). For details, see <code><a href="parallel.html#topic+mclapply">mclapply</a></code>, for which the argument is passed.
Parallelization can be used in generating simulations and in calculating the second stage tests.</p>
</td></tr>
<tr><td><code id="GET.localcor_+3A_mc.args">mc.args</code></td>
<td>
<p>A named list of additional arguments to be passed to <code><a href="parallel.html#topic+mclapply">mclapply</a></code>.
Only relevant if <code>mc.cores</code> is more than 1.</p>
</td></tr>
<tr><td><code id="GET.localcor_+3A_cl">cl</code></td>
<td>
<p>Allows parallelization through the use of <code><a href="parallel.html#topic+parLapply">parLapply</a></code> (works also
in Windows), see the argument <code>cl</code> there, and examples.</p>
</td></tr>
<tr><td><code id="GET.localcor_+3A_notest">notest</code></td>
<td>
<p>Logical. FALSE means that the test is done. TRUE allows to calculate only local
correlation for the data, which can be beneficial for choosing the bandwidths before running
the test. If TRUE, then only the observed local correlations will be returned.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The code is a modification of the supporting information code of Vilodomat et al. (2014)
available at https://doi.org/10.1111/biom.12139. The modification includes the FDR or FWER envelopes
(as specified by the argument <code>typeone</code> in <code>...</code>, passed to <code><a href="#topic+global_envelope_test">global_envelope_test</a></code>)
for the test of local correlations, i.e. multiple testing correction and
graphical illustration of the test results.
</p>
<p>Variograms are calculated using the package <span class="pkg">geoR</span> and the local correlations using the R
package <span class="pkg">locfit</span>. These packages should be installed to use <code>GET.localcor</code>.
</p>
<p>Currently the data is provided in the format of Vilodomat et al. (2014, Supporting information).
Additionally width and height of area represented by a data point can be provided, see the argument <code>data</code>.
This information is used for plotting purposes when plotting the output by <code>plot()</code>.
</p>
<p>Examples are provided in the vignette 'FDRenvelopes', see e.g. https://cran.r-project.org/package=GET.
</p>


<h3>Value</h3>

<p>A global envelope object (with possible additional classes), see description of main components 
in <code><a href="#topic+global_envelope">global_envelope</a></code> (Value).
Additional attributes: <code>p_global</code> contains the Monte Carlo p-value for the global test of correlation.
<code>cor_global</code> and <code>cor_global_sim</code> contain the value of the correlation for data and permuted data,
respectively. If <code>savefuns = TRUE</code>, then <code>permutations</code> contain the permuted values of the first
random field according to Viladomat et al. (2014) procedure, and <code>cset</code> contains all the local correlations
for the data and permuted data in a <code>curve_set</code> object (see <code><a href="#topic+create_curve_set">create_curve_set</a></code>).
</p>


<h3>References</h3>

<p>Viladomat, J., Mazumder, R., McInturff, A., McCauley, D.J. and Hastie, T. (2014). Assessing the significance of global and local correlations under spatial autocorrelation: A nonparametric approach. Biometrics 70, 409-418. doi: 10.1111/biom.12139
</p>
<p>Mrkvička, T., Myllymäki, M. (2023) False discovery rate envelopes. Statistics and Computing 33, 109. https://doi.org/10.1007/s11222-023-10275-7
</p>

<hr>
<h2 id='GET.spatialF'>Testing global and local dependence of point patterns on covariates</h2><span id='topic+GET.spatialF'></span>

<h3>Description</h3>

<p>Compute the spatial F- and S-statistics and perform the one-stage global envelope tests
proposed by Myllymäki et al. (2020).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GET.spatialF(
  X,
  formula.full,
  formula.reduced,
  fitfun,
  covariates,
  nsim,
  bw = spatstat.explore::bw.scott(X),
  bw.S = bw,
  dimyx = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="GET.spatialF_+3A_x">X</code></td>
<td>
<p>A <code>ppp</code> object of <span class="pkg">spatstat</span> representing the observed point pattern.</p>
</td></tr>
<tr><td><code id="GET.spatialF_+3A_formula.full">formula.full</code></td>
<td>
<p>A formula for the trend of the full model.</p>
</td></tr>
<tr><td><code id="GET.spatialF_+3A_formula.reduced">formula.reduced</code></td>
<td>
<p>A formula for the trend of the reduced model
that is a submodel of the full model.</p>
</td></tr>
<tr><td><code id="GET.spatialF_+3A_fitfun">fitfun</code></td>
<td>
<p>A function of a point pattern, model formula and covariates,
giving a fitted model object that can be used with <code><a href="stats.html#topic+simulate">simulate</a></code>.</p>
</td></tr>
<tr><td><code id="GET.spatialF_+3A_covariates">covariates</code></td>
<td>
<p>A list of covariates.</p>
</td></tr>
<tr><td><code id="GET.spatialF_+3A_nsim">nsim</code></td>
<td>
<p>The number of simulations.</p>
</td></tr>
<tr><td><code id="GET.spatialF_+3A_bw">bw</code></td>
<td>
<p>The bandwidth for smoothed residuals.</p>
</td></tr>
<tr><td><code id="GET.spatialF_+3A_bw.s">bw.S</code></td>
<td>
<p>The radius for the local S(u)-statistic.</p>
</td></tr>
<tr><td><code id="GET.spatialF_+3A_dimyx">dimyx</code></td>
<td>
<p>Pixel array dimensions for smoothed residuals. See <code>as.mask</code> of <span class="pkg">spatstat</span>.</p>
</td></tr>
<tr><td><code id="GET.spatialF_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to <code><a href="#topic+global_envelope_test">global_envelope_test</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list with three components
</p>

<ul>
<li><p> F = the global envelope test based on the F(u) statistic
</p>
</li>
<li><p> S = the global envelope test based on the S(u) statistic
</p>
</li>
<li><p> coef = the coefficients of the full model given by fitfun
</p>
</li></ul>



<h3>References</h3>

<p>Myllymäki, M., Kuronen, M. and Mrkvička, T. (2020). Testing global and local dependence of point patterns on covariates in parametric models. Spatial Statistics 42, 100436. doi: 10.1016/j.spasta.2020.100436
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(require("spatstat.model", quietly=TRUE)) {
  # Example of tropical rain forest trees
  data("bei")

  fullmodel &lt;- ~ grad
  reducedmodel &lt;- ~ 1
  fitppm &lt;- function(X, model, covariates) {
    ppm(X, model, covariates=covariates)
  }
  
  
  nsim &lt;- 19 # Increase nsim for serious analysis!
  res &lt;- GET.spatialF(bei, fullmodel, reducedmodel, fitppm, bei.extra, nsim)
  
  plot(res$F)
  plot(res$S)

  
  # Example of forest fires
  data("clmfires")
  # Choose the locations of the lightnings in years 2004-2007:
  pp.lightning &lt;- unmark(subset(clmfires, cause == "lightning" &amp;
                   date &gt;= "2004-01-01" &amp; date &lt; "2008-01-01"))

  covariates &lt;- clmfires.extra$clmcov100
  covariates$forest &lt;- covariates$landuse == "conifer" | covariates$landuse == "denseforest" |
                        covariates$landuse == "mixedforest"

  fullmodel &lt;- ~ elevation + landuse
  reducedmodel &lt;- ~ landuse
  nsim &lt;- 19 # Increase nsim for serious analysis!
  res &lt;- GET.spatialF(pp.lightning, fullmodel, reducedmodel, fitppm, covariates, nsim)
  plot(res$F)
  plot(res$S)

  # Examples of the fitfun functions for clustered and regular processes
  # fitfun for the log Gaussian Cox Process with exponential covariance function
  fitLGCPexp &lt;- function(X, model, covariates) {
    kppm(X, model, clusters="LGCP", model="exponential", covariates=covariates)
  }
  # fitfun for the hardcore process with hardcore radius 0.01
  fitHardcore &lt;- function(X, model, covariates) {
    ppm(X, model, interaction=Hardcore(0.01), covariates=covariates)
  }
  
}
</code></pre>

<hr>
<h2 id='GET.variogram'>Variogram and residual variogram with global envelopes</h2><span id='topic+GET.variogram'></span>

<h3>Description</h3>

<p>The function accompanies the function <code><a href="gstat.html#topic+variogram">variogram</a></code> with global envelopes
that are based on permutations of the variable(s) or residuals for which the variogram is calculated.
Therefore, one can inspect the hypothesis of &quot;no spatial autocorrelation&quot; of the variable or the residuals
of the fitted model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GET.variogram(
  object,
  nsim = 999,
  data = NULL,
  ...,
  GET.args = NULL,
  savefuns = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="GET.variogram_+3A_object">object</code></td>
<td>
<p>An object of class <code>gstat</code> or a <code>variogram.formula</code>.
In the first case, direct (residual) variograms are calculated for the variable
defined in object. Only one variable allowed.
In the second case, a formula defining the response vector and (possible) regressors,
in case of absence of regressors, use e.g. z~1. See <code><a href="gstat.html#topic+variogram">variogram</a></code>.</p>
</td></tr>
<tr><td><code id="GET.variogram_+3A_nsim">nsim</code></td>
<td>
<p>The number of permutations.</p>
</td></tr>
<tr><td><code id="GET.variogram_+3A_data">data</code></td>
<td>
<p>A data frame where the names in formula are to be found. If NULL,
the data are assumed to be found in the <code>object</code>.</p>
</td></tr>
<tr><td><code id="GET.variogram_+3A_...">...</code></td>
<td>
<p>Additional parameters to be passed to <code><a href="gstat.html#topic+variogram">variogram</a></code>.</p>
</td></tr>
<tr><td><code id="GET.variogram_+3A_get.args">GET.args</code></td>
<td>
<p>A named list of additional arguments to be passed to <code><a href="#topic+global_envelope_test">global_envelope_test</a></code>.</p>
</td></tr>
<tr><td><code id="GET.variogram_+3A_savefuns">savefuns</code></td>
<td>
<p>Logical. If TRUE, then the functions from permutations are saved to the attribute
simfuns.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>if(require("sp", quietly=TRUE) &amp; require("gstat", quietly=TRUE)) {
  # Examples from gstat complemented with global envelopes
  #-------------------------------------------------------
  data("meuse")
  coordinates(meuse) &lt;- ~x+y
  # topsoil zinc concentration, mg kg-1 soil ("ppm")
  bubble(meuse, "zinc",
         col=c("#00ff0088", "#00ff0088"), main="zinc concentrations (ppm)")
  # Variogram can be calculated as follows by the function variogram of the gstat package.
  # The function variogram takes a formula as its first argument:
  # log(zinc)~1 means that we assume a constant trend for the variable log(zinc).
  lzn.vgm &lt;- variogram(object=log(zinc)~1, data=meuse)
  plot(lzn.vgm)
  # Variogram with global envelopes is as easy:
  lzn.vgm.GET &lt;- GET.variogram(object=log(zinc)~1, data=meuse)
  
  plot(lzn.vgm.GET)

  # Instead of the constant mean, denoted by ~1, a mean function can
  # be specified, e.g. using ~sqrt(dist) as a predictor variable:
  lznr.vgm &lt;- variogram(log(zinc)~sqrt(dist), meuse)
  # In this case, the variogram of residuals with respect
  # to a fitted mean function are shown.
  plot(lznr.vgm)
  # The variogram with global envelopes (obtained by permuting the residuals):
  lznr.vgm.GET &lt;- GET.variogram(object=log(zinc)~sqrt(dist), data=meuse)
  
  plot(lznr.vgm.GET)

  # Directional variograms
  lzn.dir &lt;- variogram(object=log(zinc)~1, data=meuse, alpha=c(0, 45, 90, 135))
  plot(lzn.dir)
  # with global envelopes
  lzn.dir.GET &lt;- GET.variogram(object=log(zinc)~1, data=meuse, alpha=c(0, 45, 90, 135))
  
  plot(lzn.dir.GET)

  # Use instead gstat objects
  g &lt;- gstat(id="ln.zinc", formula=log(zinc)~1, data=meuse)
  # or: g &lt;- gstat(id="ln.zinc", formula=log(zinc)~sqrt(dist), data=meuse)
  # The variogram
  plot(variogram(g))
  # The variogram with global envelopes:
  g.GET &lt;- GET.variogram(object=g)
  
  plot(g.GET)
}
</code></pre>

<hr>
<h2 id='global_envelope_test'>Global envelope test</h2><span id='topic+global_envelope_test'></span>

<h3>Description</h3>

<p>Global envelope test, global envelopes and p-values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>global_envelope_test(
  curve_sets,
  typeone = c("fwer", "fdr"),
  alpha = 0.05,
  alternative = c("two.sided", "less", "greater"),
  type = "erl",
  algorithm = c("IATSE", "ATSE"),
  ties = "erl",
  probs = c(0.025, 0.975),
  quantile.type = 7,
  central = "mean",
  nstep = 2,
  ...,
  lower = NULL,
  upper = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="global_envelope_test_+3A_curve_sets">curve_sets</code></td>
<td>
<p>A <code><a href="#topic+curve_set">curve_set</a></code> object or a list of <code><a href="#topic+curve_set">curve_set</a></code>
objects containing a data function and simulated functions from which the envelope is
to be constructed.
Also <code>envelope</code> objects of <span class="pkg">spatstat</span> are accepted instead of curve_set objects.
If an envelope object is given, it must contain the summary
functions from simulated patterns which can be achieved by setting
<code>savefuns = TRUE</code> when calling the <code>envelope</code> function.</p>
</td></tr>
<tr><td><code id="global_envelope_test_+3A_typeone">typeone</code></td>
<td>
<p>Character string indicating which type I error rate to control,
either the family-wise error rate ('fwer') or false discovery rate ('fdr').</p>
</td></tr>
<tr><td><code id="global_envelope_test_+3A_alpha">alpha</code></td>
<td>
<p>The significance level. The 100(1-alpha)% global envelope will be calculated
under the 'fwer' or 'fdr' control.
If a vector of values is provided, the global envelopes are calculated for each value.</p>
</td></tr>
<tr><td><code id="global_envelope_test_+3A_alternative">alternative</code></td>
<td>
<p>A character string specifying the alternative hypothesis.
Must be one of the following: &quot;two.sided&quot; (default), &quot;less&quot; or &quot;greater&quot;.
The last two options only available for types <code>'rank'</code>, <code>'erl'</code>,
<code>'cont'</code> and <code>'area'</code>.</p>
</td></tr>
<tr><td><code id="global_envelope_test_+3A_type">type</code></td>
<td>
<p>The type of the global envelope with current options for 'rank', 'erl', 'cont', 'area',
'qdir', 'st' and 'unscaled'. See details.</p>
</td></tr>
<tr><td><code id="global_envelope_test_+3A_algorithm">algorithm</code></td>
<td>
<p>The algorithm for the computation of the FDR envelope.
Either &quot;IATSE&quot; or &quot;ATSE&quot; standing for the iteratively adaptive two-stage
envelope and the adaptive two-stage envelope, respectively, see Mrkvička and Myllymäki (2023).</p>
</td></tr>
<tr><td><code id="global_envelope_test_+3A_ties">ties</code></td>
<td>
<p>The method to obtain a unique p-value when <code>typeone = 'fwer'</code> and <code>type = 'rank'</code>;
otherwise ignored.
Possible values are 'midrank', 'random', 'conservative', 'liberal' and 'erl'.
For 'conservative' the resulting p-value will be the highest possible.
For 'liberal' the p-value will be the lowest possible.
For 'random' the rank of the obs within the tied values is uniformly sampled so that the resulting
p-value is at most the conservative option and at least the liberal option.
For 'midrank' the mid-rank within the tied values is taken.
For 'erl' the extreme rank length p-value is calculated.
The default is 'erl'.</p>
</td></tr>
<tr><td><code id="global_envelope_test_+3A_probs">probs</code></td>
<td>
<p>A two-element vector containing the lower and upper
quantiles for the measure 'q' or 'qdir', in that order and on the interval [0, 1].
The default values are 0.025 and 0.975, suggested by Myllymäki et al. (2015, 2017).</p>
</td></tr>
<tr><td><code id="global_envelope_test_+3A_quantile.type">quantile.type</code></td>
<td>
<p>As type argument of <code><a href="stats.html#topic+quantile">quantile</a></code>, how to
calculate quantiles for 'q' or 'qdir'.</p>
</td></tr>
<tr><td><code id="global_envelope_test_+3A_central">central</code></td>
<td>
<p>Either &quot;mean&quot; or &quot;median&quot;. If the curve sets do not contain the component
<code>theo</code> for the theoretical central function, then the central function (used for plotting only)
is calculated either as the mean or median of functions provided in the curve sets.
For 'qdir', 'st' and 'unscaled' only the mean is allowed as an option, due to their definition.</p>
</td></tr>
<tr><td><code id="global_envelope_test_+3A_nstep">nstep</code></td>
<td>
<p>1 or 2 for how to contruct a combined global envelope if list of curve sets
is provided. 2 (default) for a two-step combining procedure, 1 for one-step.</p>
</td></tr>
<tr><td><code id="global_envelope_test_+3A_...">...</code></td>
<td>
<p>Additional parameters to be passed to <code><a href="#topic+central_region">central_region</a></code> for the computation
of the 'fwer' envelope.</p>
</td></tr>
<tr><td><code id="global_envelope_test_+3A_lower">lower</code></td>
<td>
<p>A single number (or a vector of suitable length) giving a lower bound
for the functions. Used only for the extension of the FDR envelope.</p>
</td></tr>
<tr><td><code id="global_envelope_test_+3A_upper">upper</code></td>
<td>
<p>A single number (or a vector of suitable length) giving an upper bound
for the functions. Used only for the extension of the FDR envelope.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given a <code><a href="#topic+curve_set">curve_set</a></code> object,
or an <code>envelope</code> object of <span class="pkg">spatstat</span>,
which contains both the data curve (or function or vector) <code class="reqn">T_1(r)</code>
(in the component <code>obs</code>) and
the simulated curves <code class="reqn">T_2(r),\dots,T_{s+1}(r)</code>
(in the component <code>sim_m</code>),
the function <code>global_envelope_test</code> performs a global envelope test,
either under the control of family-wise error rate (FWER) or false discovery rate (FDR),
as specified by the argument <code>typeone</code>.
The function <code>global_envelope_test</code> is the main function for global envelope tests
(for simple hypotheses).
</p>
<p>The case <code>typeone = "fdr"</code> corresponds to the FDR envelopes proposed by
Mrkvička and Myllymäki (2023). See details in <code><a href="#topic+fdr_envelope">fdr_envelope</a></code> and
in the vignette <code>vignette("FDRenvelopes")</code>. Note there also the arguments that are
the relevant ones for the FDR envelope specification.
The descriptions below concern the FWER envelopes.
</p>
<p>If <code>typeone = "fwer"</code>, the functionality of the function is rather similar to the
function <code><a href="#topic+central_region">central_region</a></code>, but in addition to ordering the functions from
the most extreme one to the least extreme one using different measures
and providing the global envelopes with intrinsic
graphical interpretation, p-values are calculated for the test.
Thus, while <code><a href="#topic+central_region">central_region</a></code> can be used to construct global
envelopes in a general setting, the function <code><a href="#topic+global_envelope_test">global_envelope_test</a></code>
is devoted to testing as its name suggests.
</p>
<p>Different <code>type</code> of global envelope tests under the control of FWER can be computed.
We use such ordering of the functions for which we are able to construct global
envelopes with intrinsic graphical interpretation (IGI, see Myllymäki and Mrkvička, 2023).
</p>

<ul>
<li> <p><code>'rank'</code>: the completely non-parametric rank envelope test (Myllymäki et al., 2017)
based on minimum of pointwise ranks
</p>
</li>
<li> <p><code>'erl'</code>: the completely non-parametric rank envelope test based on extreme rank lengths
(Myllymäki et al., 2017; Mrkvička et al., 2018) based on number of minimal pointwise ranks
</p>
</li>
<li> <p><code>'cont'</code>: the completely non-parametric rank envelope test based on continuous rank
(Hahn, 2015; Mrkvička et al., 2022) based on minimum of continuous pointwise ranks
</p>
</li>
<li> <p><code>'area'</code>: the completely non-parametric rank envelope test based on area rank
(Mrkvička et al., 2022) based on area between continuous pointwise ranks and minimum
pointwise ranks for those argument (r) values for which pointwise ranks achieve the minimum
(it is a combination of erl and cont)
</p>
</li>
<li><p> &quot;qdir&quot;, the directional quantile envelope test, protected against unequal variance and
asymmetry of T(r) for different distances r (Myllymäki et al., 2015, 2017)
</p>
</li>
<li><p> &quot;st&quot;, the studentised envelope test, protected against unequal variance of T(r) for
different distances r (Myllymäki et al., 2015, 2017)
</p>
</li>
<li><p> &quot;unscaled&quot;, the unscaled envelope (providing a baseline) that has a contant width and
that corresponds to the classical maximum deviation test (Ripley, 1981).
</p>
</li></ul>

<p>The first four types are global rank envelopes.
The <code>'rank'</code> envelope test is a completely non-parametric test,
which provides the 100(1-alpha)% global envelope for the chosen test function
T(r) on the chosen interval of distances and associated p-values.
The other three are modifications of <code>'rank'</code> to treat the ties in
the extreme rank ordering on which the <code>'rank'</code> test is based on.
The last three envelopes are global scaled maximum absolute difference (MAD)
envelope tests. The unscaled envelope test leads to envelopes with constant width over the
distances r. Thus, it suffers from unequal variance of T(r) over the distances r and
from the asymmetry of distribution of T(r). We recommend to use the other global
envelope tests available. The unscaled envelope is provided as a reference.
</p>
<p>See Myllymäki and Mrkvička (2023, Appendix.), i.e. <code>vignette("GET")</code>, for more detailed
description of the measures and the corresponding envelopes.
</p>
<p>See <code>vignette("pointpatterns")</code> for examples of point pattern analyses.
See <code>vignette("FDRenvelopes")</code> for examples of FDR envelopes obtained by
<code>typeone = "fdr"</code>.
</p>


<h3>Value</h3>

<p>Either an object of class &quot;global_envelope&quot; or &quot;combined_global_envelope&quot;,
similarly as the objects returned by <code><a href="#topic+central_region">central_region</a></code>.
Further, if <code>typeone = "fdr"</code>, the objects have the further class
&quot;fdr_envelope&quot; or &quot;combined_fdr_envelope&quot;.
</p>
<p>The <code>global_envelope</code> is essentially a data frame containing columns
</p>

<ul>
<li><p> the values of the argument r at which the test was made, copied from the argument <code>curve_sets</code> with the corresponding names
</p>
</li>
<li><p> obs = values of the data function, copied from the argument <code>curve_sets</code>
(unlike for central regions, <code>obs</code> always exists for a global envelope test)
</p>
</li>
<li><p> lo = the lower envelope; in case of a vector of alpha values, several 'lo' exist with names paste0(&quot;lo.&quot;, 100*(1-alpha))
</p>
</li>
<li><p> hi = the upper envelope; in case of a vector of alpha values, several 'lo' exist with names paste0(&quot;hi.&quot;, 100*(1-alpha))
</p>
</li>
<li><p> central = a central curve as specified in the argument <code>central</code>.
</p>
</li></ul>

<p>Moreover, the returned object has the same attributes as the <code>global_envelope</code> object returned by
<code><a href="#topic+central_region">central_region</a></code> and in addition
</p>

<ul>
<li><p> p = the p-value of the test
</p>
</li></ul>

<p>and in the case that <code>type = 'rank'</code> also
</p>

<ul>
<li><p> p_interval = The p-value interval <code class="reqn">[p_{liberal}, p_{conservative}]</code>.
</p>
</li>
<li><p> ties = As the argument <code>ties</code>.
</p>
</li></ul>

<p>The <code>combined_global_envelope</code> is a list of <code>global_envelope</code> objects
containing the above mentioned columns and which all together form the global envelope.
It has the same attributes as described in <code><a href="#topic+central_region">central_region</a></code>, and in addition also
the p-value <code>p</code>.
The 2d classes are attached as described in <code><a href="#topic+central_region">central_region</a></code>.
</p>


<h3>Procedure</h3>

<p>1) First the curves are ranked from the most extreme one to the least extreme one
by a measure that is specified by the argument <code>type</code>. The options are
</p>

<ul>
<li><p> 'rank': extreme ranks (Myllymäki et al., 2017)
</p>
</li>
<li><p> 'erl': extreme rank lengths (Myllymäki et al., 2017; Mrkvička et al., 2018)
</p>
</li>
<li><p> 'cont': continuous ranks (Hahn, 2015; Mrkvička et al., 2019)
</p>
</li>
<li><p> 'area': area ranks (Mrkvička et al., 2019)
</p>
</li>
<li><p> 'qdir': the directional quantile maximum absolute deviation (MAD) measure (Myllymäki et al., 2015, 2017)
</p>
</li>
<li><p> 'st': the studentized MAD measure (Myllymäki et al., 2015, 2017)
</p>
</li>
<li><p> 'unscaled': the unscaled MAD measure (Ripley, 1981)
</p>
</li></ul>

<p>2) Based on the measures used to rank the functions, the 100(1-alpha)% global envelope is provided.
It corresponds to the 100*coverage% central region.
</p>
<p>3) P-values:
In the case <code>type="rank"</code>, based on the extreme ranks <code class="reqn">k_i, i=1, ..., s+1</code>,
the p-interval is calculated. Because the extreme ranks contain ties, there is not just
one p-value. The p-interval is given by the most liberal and the most conservative p-value
estimate. Also a single p-value is calculated.
By default this single p-value is the extreme rank length p-value (&quot;erl&quot;) as specified by the argument <code>ties</code>.
If the case of other measures, a (single) p-value based on the given ordering
of the functions is calculated and returned in the attribute <code>p</code>.
</p>


<h3>Number of simulations</h3>

<p>For the global <code>"rank"</code> envelope test, Myllymäki et al. (2017) recommended to use
at least 2500 simulations for testing at the significance level alpha = 0.05 for single
function tests, based on experiments with summary functions for point processes evaluated
approximately at 500 argument values.
In this case, the width of the p-interval associated with the extreme rank measure tended
to be smaller than 0.01.
The tests <code>'erl'</code>, <code>'cont'</code> and <code>'area'</code>, similarly as
the MAD deviation/envelope tests <code>'qdir'</code>, <code>'st'</code> and <code>'unscaled'</code>,
allow in principle a lower number of simulations to be used than the test based on
extreme ranks (<code>'rank'</code>), because no ties occur for these measures.
If affordable, we recommend in any case some thousands of simulations for all the measures
to achieve a good power and repeatability of the test.
If the dimension of the test functions is higher, also the number of simulations should
preferably be higher.
</p>


<h3>Tests based on several functions</h3>

<p>If a list of (suitable) objects are provided in the argument <code>curve_sets</code>,
then by default (<code>nstep = 2</code>) the two-step combining procedure is used to
perform the combined global test as described in Myllymäki and Mrkvička (2024).
If <code>nstep = 1</code> and the lengths of the multivariate vectors in each component
of the list are equal, then the one-step combining procedure is used where the
functions are concatenated together into a one long vector.
</p>


<h3>References</h3>

<p>Mrkvička, T., Myllymäki, M. and Hahn, U. (2017). Multiple Monte Carlo testing, with applications in spatial point processes. Statistics &amp; Computing 27(5), 1239-1255. doi: 10.1007/s11222-016-9683-9
</p>
<p>Mrkvička, T., Myllymäki, M., Jilek, M. and Hahn, U. (2020) A one-way ANOVA test for functional data with graphical interpretation. Kybernetika 56(3), 432-458. doi: 10.14736/kyb-2020-3-0432
</p>
<p>Mrkvička, T., Myllymäki, M., Kuronen, M. and Narisetty, N. N. (2022) New methods for multiple testing in permutation inference for the general linear model. Statistics in Medicine 41(2), 276-297. doi: 10.1002/sim.9236
</p>
<p>Mrkvička and Myllymäki (2023). False discovery rate envelopes. Statistics and Computing 33, 109. https://doi.org/10.1007/s11222-023-10275-7
</p>
<p>Myllymäki, M., Grabarnik, P., Seijo, H. and Stoyan. D. (2015). Deviation test construction and power comparison for marked spatial point patterns. Spatial Statistics 11, 19-34. doi: 10.1016/j.spasta.2014.11.004
</p>
<p>Myllymäki, M., Mrkvička, T., Grabarnik, P., Seijo, H. and Hahn, U. (2017). Global envelope tests for spatial point patterns. Journal of the Royal Statistical Society: Series B (Statistical Methodology) 79, 381–404. doi: 10.1111/rssb.12172
</p>
<p>Myllymäki, M. and Mrkvička, T. (2024). GET: Global envelopes in R. Journal of Statistical Software 111(3), 1-40. doi: 10.18637/jss.v111.i03
</p>
<p>Ripley, B.D. (1981). Spatial statistics. Wiley, New Jersey.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.global_envelope">plot.global_envelope</a></code>, <code><a href="#topic+central_region">central_region</a></code>,
<code><a href="#topic+GET.composite">GET.composite</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Goodness-of-fit testing for simple hypothesis
if(require("spatstat.explore", quietly=TRUE)) {
  # Testing complete spatial randomness (CSR)
  #==========================================
  X &lt;- unmark(spruces)

  nsim &lt;- 1999 # Number of simulations
  

  # Illustration of general workflow for simple hypotheses
  #=======================================================
  # First illustrate the general workflow for the test by this example
  # of CSR test for a point pattern X using the empirical L-function.
  # Define the argument values at which the functions are evaluated
  obs.L &lt;- Lest(X, correction="translate")
  r &lt;- obs.L[['r']]
  # The test function for the data
  obs &lt;- obs.L[['trans']] - r
  # Prepare simulations and calculate test functions for them at same r as 'obs'
  sim &lt;- matrix(nrow=length(r), ncol=nsim)
  for(i in 1:nsim) {
    sim.X &lt;- runifpoint(ex=X) # simulation under CSR
    sim[, i] &lt;- Lest(sim.X, correction="translate", r=r)[['trans']] - r
  }
  # Create a curve_set containing argument values, observed and simulated functions
  cset &lt;- curve_set(r=r, obs=obs, sim=sim)
  # Perform the test
  res &lt;- global_envelope_test(cset, type="erl")
  plot(res) + ggplot2::ylab(expression(italic(hat(L)(r)-r)))

  # Simple hypothesis for a point pattern utilizing the spatstat package
  #=====================================================================
  # Generate nsim simulations under CSR, calculate L-function for the data and simulations
  env &lt;- envelope(X, fun="Lest", nsim=nsim,
                  savefuns=TRUE, # save the functions
                  correction="translate", # edge correction for L
                  transform=expression(.-r), # centering
                  simulate=expression(runifpoint(ex=X))) # Simulate CSR
  # The rank envelope test (ERL)
  res &lt;- global_envelope_test(env, type="erl")
  # Plot the result
  plot(res)

  ## Advanced use:
  # Choose the interval of distances [r_min, r_max] (at the same time create a curve_set from 'env')
  cset &lt;- crop_curves(env, r_min=1, r_max=7)
  # Do the rank envelope test (erl)
  res &lt;- global_envelope_test(cset, type="erl")
  plot(res) + ggplot2::ylab(expression(italic(L(r)-r)))

  # A combined global envelope test
  #================================
  # As an example test CSR of the saplings point pattern by means of
  # L, F, G and J functions.
  data(saplings)
  X &lt;- as.ppp(saplings, W=square(75))

  nsim &lt;- 499 # Number of simulations
  
  # Specify distances for different test functions
  n &lt;- 500 # the number of r-values
  rmin &lt;- 0; rmax &lt;- 20; rstep &lt;- (rmax-rmin)/n
  rminJ &lt;- 0; rmaxJ &lt;- 8; rstepJ &lt;- (rmaxJ-rminJ)/n
  r &lt;- seq(0, rmax, by=rstep)    # r-distances for Lest
  rJ &lt;- seq(0, rmaxJ, by=rstepJ) # r-distances for Fest, Gest, Jest
  

  # Perform simulations of CSR and calculate the L-functions
  env_L &lt;- envelope(X, nsim=nsim,
   simulate=expression(runifpoint(ex=X)),
   fun="Lest", correction="translate",
   transform=expression(.-r), # Take the L(r)-r function instead of L(r)
   r=r,                       # Specify the distance vector
   savefuns=TRUE,             # Save the estimated functions
   savepatterns=TRUE)         # Save the simulated patterns
  # Take the simulations from the returned object
  simulations &lt;- attr(env_L, "simpatterns")
  # Then calculate the other test functions F, G, J for each simulated pattern
  env_F &lt;- envelope(X, nsim=nsim, simulate=simulations,
                    fun="Fest", correction="Kaplan", r=rJ,
                    savefuns=TRUE)
  env_G &lt;- envelope(X, nsim=nsim, simulate=simulations,
                    fun="Gest", correction="km", r=rJ,
                    savefuns=TRUE)
  env_J &lt;- envelope(X, nsim=nsim, simulate=simulations,
                    fun="Jest", correction="none", r=rJ,
                    savefuns=TRUE)

  # Crop the curves to the desired r-interval I
  curve_set_L &lt;- crop_curves(env_L, r_min=rmin, r_max=rmax)
  curve_set_F &lt;- crop_curves(env_F, r_min=rminJ, r_max=rmaxJ)
  curve_set_G &lt;- crop_curves(env_G, r_min=rminJ, r_max=rmaxJ)
  curve_set_J &lt;- crop_curves(env_J, r_min=rminJ, r_max=rmaxJ)

  res &lt;- global_envelope_test(curve_sets=list(L=curve_set_L, F=curve_set_F,
                                              G=curve_set_G, J=curve_set_J))
  plot(res)
  plot(res, labels=c("L(r)-r", "F(r)", "G(r)", "J(r)"))
}

# A test based on a low dimensional random vector
#================================================
# Let us generate some example data.
X &lt;- matrix(c(-1.6,1.6),1,2) # data pattern X=(X_1,X_2)
if(requireNamespace("mvtnorm", quietly=TRUE)) {
  Y &lt;- mvtnorm::rmvnorm(200,c(0,0),matrix(c(1,0.5,0.5,1),2,2)) # simulations
  plot(Y, xlim=c(min(X[,1],Y[,1]), max(X[,1],Y[,1])), ylim=c(min(X[,2],Y[,2]), max(X[,2],Y[,2])))
  points(X, col=2)

  # Test the null hypothesis is that X is from the distribution of Y's (or if it is an outlier).

  # Case 1. The test vector is (X_1, X_2)
  cset1 &lt;- curve_set(r=1:2, obs=as.vector(X), sim=t(Y))
  res1 &lt;- global_envelope_test(cset1)
  plot(res1)

  # Case 2. The test vector is (X_1, X_2, (X_1-mean(Y_1))*(X_2-mean(Y_2))).
  t3 &lt;- function(x, y) { (x[,1]-mean(y[,1]))*(x[,2]-mean(y[,2])) }
  cset2 &lt;- curve_set(r=1:3, obs=c(X[,1],X[,2],t3(X,Y)), sim=rbind(t(Y), t3(Y,Y)))
  res2 &lt;- global_envelope_test(cset2)
  plot(res2)
}
</code></pre>

<hr>
<h2 id='global_rq'>Global quantile regression</h2><span id='topic+global_rq'></span>

<h3>Description</h3>

<p>Global tests of significance for the effect of covariates in quantile regression
</p>


<h3>Usage</h3>

<pre><code class='language-R'>global_rq(
  nsim,
  formula.full,
  formula.reduced,
  taus,
  data,
  contrasts = NULL,
  permutationstrategy = c("Freedman-Lane", "Freedman-Lane+remove zeros",
    "within nuisance", "remove location", "remove location scale", "remove quantile"),
  savefuns = FALSE,
  rq.args = NULL,
  lm.args = NULL,
  GET.args = NULL,
  mc.cores = 1L,
  mc.args = NULL,
  cl = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="global_rq_+3A_nsim">nsim</code></td>
<td>
<p>The number of random permutations.</p>
</td></tr>
<tr><td><code id="global_rq_+3A_formula.full">formula.full</code></td>
<td>
<p>The formula specifying the general linear model,
see <code>formula</code> in <code><a href="stats.html#topic+lm">lm</a></code>.</p>
</td></tr>
<tr><td><code id="global_rq_+3A_formula.reduced">formula.reduced</code></td>
<td>
<p>The formula of the reduced model with nuisance factors only. This model
should be nested within the full model.</p>
</td></tr>
<tr><td><code id="global_rq_+3A_taus">taus</code></td>
<td>
<p>The quantiles to be used.</p>
</td></tr>
<tr><td><code id="global_rq_+3A_data">data</code></td>
<td>
<p>data.frame where to look for variables.</p>
</td></tr>
<tr><td><code id="global_rq_+3A_contrasts">contrasts</code></td>
<td>
<p>Passed directly to <code>rq</code>.</p>
</td></tr>
<tr><td><code id="global_rq_+3A_permutationstrategy">permutationstrategy</code></td>
<td>
<p>The permutation strategy to be used. See details.</p>
</td></tr>
<tr><td><code id="global_rq_+3A_savefuns">savefuns</code></td>
<td>
<p>Logical. If TRUE, then the functions from permutations are saved to the attribute
simfuns.</p>
</td></tr>
<tr><td><code id="global_rq_+3A_rq.args">rq.args</code></td>
<td>
<p>Additional arguments passed to <code>rq</code>.</p>
</td></tr>
<tr><td><code id="global_rq_+3A_lm.args">lm.args</code></td>
<td>
<p>A named list of additional arguments to be passed to <code><a href="stats.html#topic+lm">lm</a></code>. See details.</p>
</td></tr>
<tr><td><code id="global_rq_+3A_get.args">GET.args</code></td>
<td>
<p>A named list of additional arguments to be passed to <code><a href="#topic+global_envelope_test">global_envelope_test</a></code>,
e.g. <code>typeone</code> specifies the type of multiple testing control, FWER or FDR.
See <code><a href="#topic+global_envelope_test">global_envelope_test</a></code> for the defaults and available options.</p>
</td></tr>
<tr><td><code id="global_rq_+3A_mc.cores">mc.cores</code></td>
<td>
<p>The number of cores to use, i.e. at most how many child processes will be run simultaneously.
Must be at least one, and parallelization requires at least two cores. On a Windows computer mc.cores must be 1
(no parallelization). For details, see <code><a href="parallel.html#topic+mclapply">mclapply</a></code>, for which the argument is passed.
Parallelization can be used in generating simulations and in calculating the second stage tests.</p>
</td></tr>
<tr><td><code id="global_rq_+3A_mc.args">mc.args</code></td>
<td>
<p>A named list of additional arguments to be passed to <code><a href="parallel.html#topic+mclapply">mclapply</a></code>.
Only relevant if <code>mc.cores</code> is more than 1.</p>
</td></tr>
<tr><td><code id="global_rq_+3A_cl">cl</code></td>
<td>
<p>Allows parallelization through the use of <code><a href="parallel.html#topic+parLapply">parLapply</a></code> (works also
in Windows), see the argument <code>cl</code> there, and examples.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The possible permutation strategies include
&quot;Freedman-Lane&quot; (FL), &quot;Freedman-Lane+remove zeros&quot; (FL+), &quot;within nuisance&quot; (WN),
&quot;remove location&quot; (RL), &quot;remove location scale&quot; (RLS), &quot;remove quantile&quot; (RQ),
which correspond to those in Mrkvička et al. (Section 4.1-4.6 and Table 1).
</p>


<h3>Value</h3>

<p>A <code>global_envelope</code> or <code>combined_global_envelope</code> object,
which can be printed and plotted directly.
</p>


<h3>References</h3>

<p>Mrkvička, T., Konstantinou, K., Kuronen, M. and Myllymäki, M. (2023) Global quantile regression. arXiv:2309.04746 [stat.ME]. https://doi.org/10.48550/arXiv.2309.04746
</p>
<p>Myllymäki, M. and Mrkvička, T. (2024). GET: Global envelopes in R. Journal of Statistical Software 111(3), 1-40. doi: 10.18637/jss.v111.i03
</p>
<p>Freedman, D., &amp; Lane, D. (1983) A nonstochastic interpretation of reported significance levels. Journal of Business &amp; Economic Statistics, 1(4), 292-298. doi:10.2307/1391660
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(require("quantreg", quietly=TRUE)) {
  data("stackloss")
  res &lt;- global_rq(nsim = 19, # Increase nsim for serious analysis!
    formula.full = stack.loss ~ Air.Flow + Water.Temp + Acid.Conc.,
    formula.reduced = stack.loss ~ Water.Temp,
    taus = seq(0.1, 0.9, length=10), permutationstrategy = "remove quantile",
    data = stackloss, GET.args = list(typeone = "fwer"))
  plot(res)
}

</code></pre>

<hr>
<h2 id='graph.fanova'>One-way graphical functional ANOVA</h2><span id='topic+graph.fanova'></span>

<h3>Description</h3>

<p>One-way ANOVA tests for functional data with graphical interpretation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>graph.fanova(
  nsim,
  curve_set,
  groups,
  variances = "equal",
  contrasts = FALSE,
  n.aver = 1L,
  mirror = FALSE,
  savefuns = FALSE,
  test.equality = c("mean", "var", "cov"),
  cov.lag = 1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="graph.fanova_+3A_nsim">nsim</code></td>
<td>
<p>The number of random permutations.</p>
</td></tr>
<tr><td><code id="graph.fanova_+3A_curve_set">curve_set</code></td>
<td>
<p>The original data (an array of functions) provided as a
<code><a href="#topic+curve_set">curve_set</a></code> object or a <code>fdata</code> object of <span class="pkg">fda.usc</span>.
The curve set should include the argument values for the functions in the component <code>r</code>, and
the observed functions in the component <code>obs</code>.</p>
</td></tr>
<tr><td><code id="graph.fanova_+3A_groups">groups</code></td>
<td>
<p>The original groups (a factor vector representing the assignment to groups).</p>
</td></tr>
<tr><td><code id="graph.fanova_+3A_variances">variances</code></td>
<td>
<p>Either &quot;equal&quot; or &quot;unequal&quot;. If &quot;unequal&quot;, then correction for unequal variances
as explained in details will be done. Only relevant for the case <code>test.equality = "means"</code> (default).</p>
</td></tr>
<tr><td><code id="graph.fanova_+3A_contrasts">contrasts</code></td>
<td>
<p>Logical. FALSE and TRUE specify the two test functions as described in
description part of this help file.</p>
</td></tr>
<tr><td><code id="graph.fanova_+3A_n.aver">n.aver</code></td>
<td>
<p>If variances = &quot;unequal&quot;, there is a possibility to use variances smoothed
by appying moving average to the estimated sample variances. n.aver determines
how many values on each side do contribute (incl. value itself).</p>
</td></tr>
<tr><td><code id="graph.fanova_+3A_mirror">mirror</code></td>
<td>
<p>The complement of the argument circular of <code><a href="stats.html#topic+filter">filter</a></code>. Another parameter
for the moving average to estimate sample variances (see <code>n.aver</code>).</p>
</td></tr>
<tr><td><code id="graph.fanova_+3A_savefuns">savefuns</code></td>
<td>
<p>Logical. If TRUE, then the functions from permutations are saved to the attribute
simfuns.</p>
</td></tr>
<tr><td><code id="graph.fanova_+3A_test.equality">test.equality</code></td>
<td>
<p>A character with possible values <code>mean</code> (default), <code>var</code> and
<code>cov</code>. If <code>mean</code>, the functional ANOVA is performed to compare the means in the groups.
If <code>var</code>, then the equality of variances of the curves in the groups is tested by performing
the graphical functional ANOVA test on the functions
</p>
<p style="text-align: center;"><code class="reqn">Z_{ij}(r) = T_{ij}(r) - \bar{T}_j(r).</code>
</p>

<p>If <code>cov</code>, then the equality of lag <code>cov.lag</code> covariance is tested by performing the fANOVA with
</p>
<p style="text-align: center;"><code class="reqn">W_{ij}(r) = \sqrt{|V_{ij}(r)|\cdot sign(V_{ij}(r))},</code>
</p>

<p>where
</p>
<p style="text-align: center;"><code class="reqn">V_{ij}(r) = (T_{ij}(r) - \bar{T}_j(r))((T_{ij}(r+s) - \bar{T}_j(r+s))).</code>
</p>

<p>See Mrkvicka et al. (2020) for more details.</p>
</td></tr>
<tr><td><code id="graph.fanova_+3A_cov.lag">cov.lag</code></td>
<td>
<p>The lag of the covariance for testing the equality of covariances,
see <code>test.equality</code>.</p>
</td></tr>
<tr><td><code id="graph.fanova_+3A_...">...</code></td>
<td>
<p>Additional parameters to be passed to <code><a href="#topic+global_envelope_test">global_envelope_test</a></code>.
For example, the type of multiple testing control, FWER or FDR must be set by <code>typeone</code>.
And, if <code>typeone = "fwer"</code>, the type of the global envelope can be chosen by
specifying the argument <code>type</code>. See <code><a href="#topic+global_envelope_test">global_envelope_test</a></code>
for the defaults and available options.
(The test here uses <code>alternative="two.sided"</code> and <code>nstep=1</code> (when relevant),
but all the other specifications are to be given in <code>...</code>.)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function can be used to perform one-way graphical functional ANOVA tests described
in Mrkvička et al. (2020). Both 1d and 2d functions are allowed in curve sets.
</p>
<p>The tests assume that there are <code class="reqn">J</code> groups which contain
<code class="reqn">n_1,\dots,n_J</code> functions
<code class="reqn">T_{ij}, i=\dots,J, j=1,\dots,n_j</code>.
The functions should be given in the argument <code>curve_set</code>,
and the groups in the argument <code>groups</code>.
The tests assume that <code class="reqn">T_{ij}, i=1,...,n_j</code> is an iid sample from
a stochastic process with mean function <code class="reqn">\mu_j</code> and
covariance function <code class="reqn">\gamma_j(s,t)</code> for s,t in R and j = 1,..., J.
</p>
<p>To test the hypothesis
</p>
<p style="text-align: center;"><code class="reqn">H_0 : \mu_1(r) \equiv \mu_2(r)\equiv \dots \equiv \mu_J(r),</code>
</p>

<p>you can use the test function
</p>
<p style="text-align: center;"><code class="reqn">\mathbf{T} = (\overline{T}_1({\bf r}), \overline{T}_2({\bf r}), \dots , \overline{T}_J({\bf r}))</code>
</p>

<p>where <code class="reqn">\overline{T}_i({\bf r})</code> is a vector of mean values of functions in the group j.
This test function is used when <code>contrasts = FALSE</code> (default).
</p>
<p>The hypothesis can equivalently be written as
</p>
<p style="text-align: center;"><code class="reqn">H_0 : \mu_i(r) - \mu_j(r) = 0, i=1,\dots,J-1, j=1,\dots,J.</code>
</p>

<p>and, alternatively, one can use the test function (vector)
taken to consist of the differences of the group averages,
</p>
<p style="text-align: center;"><code class="reqn">\mathbf{T'} = (\overline{T}_1({\bf r})-\overline{T}_2({\bf r}),
\overline{T}_1({\bf r})-\overline{T}_3({\bf r}), \dots , \overline{T}_{J-1}({\bf r})-\overline{T}_J({\bf r})).</code>
</p>

<p>The choice is available with the option <code>contrasts = TRUE</code>.
This test corresponds to the post-hoc test done usually after an ANOVA test is significant, but
it can be directed tested by means of the combined rank test (Mrkvička et al., 2017) with this test vector.
</p>
<p>The test as such assumes that the variances are equal across the groups of functions. To deal with
unequal variances, the differences are rescaled as the first step as follows
</p>
<p style="text-align: center;"><code class="reqn">S_{ij}(r) = \frac{T_{ij}(r) - \overline{T}(r))}{\sqrt{Var(T_j(r))}} \sqrt{Var(T(r))} + \overline{T}(r))</code>
</p>

<p>where <code class="reqn">\overline{T}({\bf r})</code> is the overall sample mean and
<code class="reqn">\sqrt{Var(T(r))}</code> is the overall sample standard deviation.
This scaling of the test functions can be obtained by giving the argument <code>variances = "unequal"</code>.
</p>


<h3>References</h3>

<p>Mrkvička, T., Myllymäki, M., Jilek, M. and Hahn, U. (2020) A one-way ANOVA test for functional data with graphical interpretation. Kybernetika 56 (3), 432-458. doi: 10.14736/kyb-2020-3-0432
</p>
<p>Mrkvička, T., Myllymäki, M., and Hahn, U. (2017). Multiple Monte Carlo testing, with applications in spatial point processes. Statistics and Computing 27 (5): 1239-1255. doi:10.1007/s11222-016-9683-9
</p>
<p>Myllymäki, M. and Mrkvička, T. (2024). GET: Global envelopes in R. Journal of Statistical Software 111(3), 1-40. doi: 10.18637/jss.v111.i03
</p>


<h3>See Also</h3>

<p><code><a href="#topic+frank.fanova">frank.fanova</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#-- NOx levels example (see for details Myllymaki and Mrkvicka, 2020)
if(require("fda.usc", quietly=TRUE)) {
  # Prepare data
  data("poblenou")
  fest &lt;- poblenou$df$day.festive; week &lt;- as.integer(poblenou$df$day.week)
  Type &lt;- vector(length=length(fest))
  Type[fest == 1 | week &gt;= 6] &lt;- "Free"
  Type[fest == 0 &amp; week %in% 1:4] &lt;- "MonThu"
  Type[fest == 0 &amp; week == 5] &lt;- "Fri"
  Type &lt;- factor(Type, levels = c("MonThu", "Fri", "Free"))

  # (log) Data as a curve_set
  cset &lt;- curve_set(r = 0:23,
     obs = t(log(poblenou[['nox']][['data']])))
  # Graphical functional ANOVA
  nsim &lt;- 2999
  
  res.c &lt;- graph.fanova(nsim = nsim, curve_set = cset,
                        groups = Type, variances = "unequal",
                        contrasts = TRUE)
  plot(res.c) + ggplot2::labs(x = "Hour", y = "Diff.")
}

#-- Centred government expenditure centralization ratios example
# This is an example analysis of the centred GEC in Mrkvicka et al.
data("cgec")

# Number of simulations
nsim &lt;- 2499 # increase to reduce Monte Carlo error


# Test for unequal lag 1 covariances
res.cov1 &lt;- graph.fanova(nsim = nsim, curve_set = cgec$cgec,
                         groups = cgec$group,
                         test.equality = "cov", cov.lag = 1)
plot(res.cov1)
# Add labels
plot(res.cov1, labels = paste("Group ", 1:3, sep="")) +
  ggplot2::xlab(substitute(paste(italic(i), " (", j, ")", sep=""), list(i="r", j="Year")))
# Test for equality of variances among groups
res.var &lt;- graph.fanova(nsim = nsim, curve_set = cgec$cgec,
                        groups = cgec$group,
                        test.equality = "var")
plot(res.var)

# Test for equality of means assuming equality of variances
# a) using 'means'
res &lt;- graph.fanova(nsim = nsim, curve_set = cgec$cgec,
                    groups = cgec$group,
                    variances = "equal", contrasts = FALSE)
plot(res)
# b) using 'contrasts'
res2 &lt;- graph.fanova(nsim = nsim, curve_set = cgec$cgec,
                     groups = cgec$group,
                     variances = "equal", contrasts = TRUE)
plot(res2)

# Image set examples
data("imageset3")

res &lt;- graph.fanova(nsim = 19, # Increase nsim for serious analysis!
                    curve_set = imageset3$image_set,
                    groups = imageset3$Group)
plot(res, what = c("obs", "lo.sign", "hi.sign"), sign.type = "col")

</code></pre>

<hr>
<h2 id='graph.flm'>Graphical functional GLM</h2><span id='topic+graph.flm'></span>

<h3>Description</h3>

<p>Non-parametric graphical tests of significance in functional general linear model (GLM)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>graph.flm(
  nsim,
  formula.full,
  formula.reduced,
  curve_sets,
  factors = NULL,
  contrasts = FALSE,
  lm.args = NULL,
  GET.args = NULL,
  mc.cores = 1L,
  mc.args = NULL,
  cl = NULL,
  savefuns = FALSE,
  fast = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="graph.flm_+3A_nsim">nsim</code></td>
<td>
<p>The number of random permutations.</p>
</td></tr>
<tr><td><code id="graph.flm_+3A_formula.full">formula.full</code></td>
<td>
<p>The formula specifying the general linear model,
see <code>formula</code> in <code><a href="stats.html#topic+lm">lm</a></code>.</p>
</td></tr>
<tr><td><code id="graph.flm_+3A_formula.reduced">formula.reduced</code></td>
<td>
<p>The formula of the reduced model with nuisance factors only. This model
should be nested within the full model.</p>
</td></tr>
<tr><td><code id="graph.flm_+3A_curve_sets">curve_sets</code></td>
<td>
<p>A named list of sets of curves giving the dependent variable (Y), and
possibly additionally factors whose values vary across the argument values of the functions.
The dimensions of the elements should match with each other.
Note that factors that are fixed across the functions can be given in the argument <code>factors</code>.
Also <code><a href="fda.usc.html#topic+fdata">fdata</a></code> objects allowed.</p>
</td></tr>
<tr><td><code id="graph.flm_+3A_factors">factors</code></td>
<td>
<p>A data frame of factors. An alternative way to specify factors when they
are constant for all argument values of the functions. The number of rows of the data frame should be equal
to the number of curves. Each column should specify the values of a factor.</p>
</td></tr>
<tr><td><code id="graph.flm_+3A_contrasts">contrasts</code></td>
<td>
<p>Logical or NULL. FALSE, TRUE and NULL specify the three test functions
as described in description part of this help file.</p>
</td></tr>
<tr><td><code id="graph.flm_+3A_lm.args">lm.args</code></td>
<td>
<p>A named list of additional arguments to be passed to <code><a href="stats.html#topic+lm">lm</a></code>. See details.</p>
</td></tr>
<tr><td><code id="graph.flm_+3A_get.args">GET.args</code></td>
<td>
<p>A named list of additional arguments to be passed to <code><a href="#topic+global_envelope_test">global_envelope_test</a></code>,
e.g. <code>typeone</code> specifies the type of multiple testing control, FWER or FDR.
See <code><a href="#topic+global_envelope_test">global_envelope_test</a></code> for the defaults and available options.</p>
</td></tr>
<tr><td><code id="graph.flm_+3A_mc.cores">mc.cores</code></td>
<td>
<p>The number of cores to use, i.e. at most how many child processes will be run simultaneously.
Must be at least one, and parallelization requires at least two cores. On a Windows computer mc.cores must be 1
(no parallelization). For details, see <code><a href="parallel.html#topic+mclapply">mclapply</a></code>, for which the argument is passed.
Parallelization can be used in generating simulations and in calculating the second stage tests.</p>
</td></tr>
<tr><td><code id="graph.flm_+3A_mc.args">mc.args</code></td>
<td>
<p>A named list of additional arguments to be passed to <code><a href="parallel.html#topic+mclapply">mclapply</a></code>.
Only relevant if <code>mc.cores</code> is more than 1.</p>
</td></tr>
<tr><td><code id="graph.flm_+3A_cl">cl</code></td>
<td>
<p>Allows parallelization through the use of <code><a href="parallel.html#topic+parLapply">parLapply</a></code> (works also
in Windows), see the argument <code>cl</code> there, and examples.</p>
</td></tr>
<tr><td><code id="graph.flm_+3A_savefuns">savefuns</code></td>
<td>
<p>Logical. If TRUE, then the functions from permutations are saved to the attribute
simfuns.</p>
</td></tr>
<tr><td><code id="graph.flm_+3A_fast">fast</code></td>
<td>
<p>Logical. See details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>graph.flm</code> performs the graphical functional GLM of Mrkvička et al. (2021),
described also in Section 3.6 of Myllymäki and Mrkvička (2024) (type <code>vignette("GET")</code> in R).
This is a nonparametric graphical test of significance of a covariate in functional GLM.
The test is able to find not only if the factor of interest is significant, but also which
functional domain is responsible for the potential rejection.
In the case of functional multi-way main effect ANOVA or functional main effect ANCOVA models,
the test is able to find which groups differ (and where they differ).
In the case of functional factorial ANOVA or functional factorial ANCOVA models,
the test is able to find which combination of levels (which interactions) differ (and where they differ).
The described tests are global envelope tests applied in the context of GLMs.
The Freedman-Lane algorithm (Freedman and Lane, 1983) is applied to permute the functions
(to obtain the simulations under the null hypothesis of &quot;no effects&quot;);
consequently, the test approximately achieves the desired significance level.
</p>
<p>The specification of the full and reduced formulas is important. The reduced model should be
nested within the full model. The full model should include in addition to the reduced
model the interesting factors whose effects are under investigation.
The implementation to find the coefficients of the interesting factors is based on
<code><a href="stats.html#topic+dummy.coef">dummy.coef</a></code> and the restrictions there apply.
</p>
<p>The regression coefficients serve as test functions in the graphical functional GLM.
For a continuous interesting factor, the test function is its regression coefficient across the
functional domain. For a discrete factor, there are three possibilities that are controlled by
the arguments <code>contrasts</code>. If <code>contrasts = FALSE</code>, then the test statistic is
the function/long vector where the coefficients related to all levels of the factor are joined
together. If <code>contrasts = TRUE</code>, then the differences between the same coefficients are
considered instead. Given the coefficients in a specific order that is obtained through the use
of <code><a href="stats.html#topic+lm">lm</a></code> and <code><a href="stats.html#topic+dummy.coef">dummy.coef</a></code>, the differences are taken for couples i and j
where i &lt; j and reducing j from i (e.g. for three groups 1,2,3, the constrasts are 1-2, 1-3, 2-3).
If <code>contrasts = NULL</code> the coefficients given by <code><a href="stats.html#topic+lm">lm</a></code> are used directly.
</p>
<p>There are different versions of the implementation depending on the application.
Given that the argument <code>fast</code> is TRUE, then
</p>

<ul>
<li><p> If all the covariates are continuous or <code>contrasts = NULL</code> and <code>lm.args = NULL</code>
the regression coefficients are computed using the normal equation approach instead of using <code><a href="stats.html#topic+lm">lm</a></code>.
</p>
</li>
<li><p> Otherwise, if all the covariates are constant across the functions, i.e. they can be provided in the
argument <code>factors</code>, then a linear model is fitted separately by least-squares estimation to
the data at each argument value of the functions fitting a multiple linear model by <code><a href="stats.html#topic+lm">lm</a></code>.
The possible extra arguments passed in <code>lm.args</code> to <code><a href="stats.html#topic+lm">lm</a></code> must be of the form that
<code><a href="stats.html#topic+lm">lm</a></code> accepts for fitting a multiple linear model. In the basic case, no extra arguments are
needed.
</p>
</li>
<li><p> Otherwise, if some of the covariates vary across the space and there are user specified extra arguments given in
<code>lm.args</code>, then the implementation fits a linear model at each argument value of the functions using
<code><a href="stats.html#topic+lm">lm</a></code>, which can be rather slow. The arguments <code>lm.args</code> are passed to <code><a href="stats.html#topic+lm">lm</a></code>
for fitting each linear model.
</p>
</li></ul>

<p>By setting <code>fast = FALSE</code>, it is possible to use the slow version (third option)
for any case. Usually this is not desired.
</p>


<h3>Value</h3>

<p>A <code>global_envelope</code> or <code>combined_global_envelope</code> object,
which can be printed and plotted directly.
</p>


<h3>References</h3>

<p>Mrkvička, T., Roskovec, T. and Rost, M. (2021) A nonparametric graphical tests of significance in functional GLM. Methodology and Computing in Applied Probability 23, 593-612. doi: 10.1007/s11009-019-09756-y
</p>
<p>Myllymäki, M. and Mrkvička, T. (2024). GET: Global envelopes in R. Journal of Statistical Software 111(3), 1-40. doi: 10.18637/jss.v111.i03
</p>
<p>Freedman, D., &amp; Lane, D. (1983) A nonstochastic interpretation of reported significance levels. Journal of Business &amp; Economic Statistics, 1(4), 292-298. doi:10.2307/1391660
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("rimov")
res &lt;- graph.flm(nsim=19, # Increase the number of simulations for serious analysis!
  formula.full = Y~Year,
  formula.reduced = Y~1,
  curve_sets = list(Y=rimov), factors = data.frame(Year = 1979:2014))
plot(res)

# Test if there is a change in the slope in 1994,
# i.e. the full model is T = a + b*year + c*year:Interv,
# where Interv is a dummy variable indicating the pre-intervention
# period (coded 0) or the post-intervention period (coded 1)
Year &lt;- 1979:2014
res &lt;- graph.flm(nsim = 19, # Increase the number of simulations for serious analysis!
  formula.full = Y ~ Year + Year:Interv,
  formula.reduced = Y ~ Year,
  curve_sets = list(Y=rimov),
  factors = data.frame(Year = Year,
                       Interv = factor(c(rep(0,times=1994-1979+1), rep(1,times=2014-1994)),
                                      levels=0:1)),
  contrasts = NULL)
plot(res)

# An example of testing the joint effect of a discrete and a continuous variable
nsim &lt;- 999

data("GDPtax")
factors.df &lt;- data.frame(Group = GDPtax$Group, Tax = GDPtax$Profittax)
res.tax_within_group &lt;- graph.flm(nsim = nsim,
  formula.full = Y~Group+Tax+Group:Tax,
  formula.reduced = Y~Group+Tax,
  curve_sets = list(Y=GDPtax$GDP),
  factors = factors.df)
plot(res.tax_within_group)

# Image data examples

data("abide_9002_23")
iset &lt;- abide_9002_23$curve_set


# Testing the discrete factor 'group' with contrasts
# (Use contrasts = FALSE for 'means'; and for continuous factors)
res &lt;- graph.flm(nsim = 19, # Increase nsim for serious analysis!
  formula.full = Y ~ Group + Sex + Age,
  formula.reduced = Y ~ Sex + Age,
  curve_sets = list(Y = iset),
  factors = abide_9002_23[['factors']],
  contrasts = TRUE,
  GET.args = list(type = "area"))
plot(res)

# Examples of modifying 2d plots
plot(res, sign.col="white") + ggplot2::scale_fill_viridis_c(option="magma")
plot(res, sign.col="white") + ggplot2::scale_fill_viridis_c(option="magma") +
  ggplot2::scale_radius(range = 2*c(1, 6))
plot(res, what=c("obs", "lo", "hi", "lo.sign", "hi.sign"))
plot(res, what=c("obs", "lo", "hi", "lo.sign", "hi.sign"), sign.type="col")
</code></pre>

<hr>
<h2 id='imageset3'>A simulated set of images</h2><span id='topic+imageset3'></span>

<h3>Description</h3>

<p>A simulated set of images with a categorical factor (with three levels)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("imageset3")
</code></pre>


<h3>Format</h3>

<p>A list of the <code>image_set</code> containing the simulated images, and
the discrete group factor in the list component <code>Group</code>.
</p>


<h3>Details</h3>

<p>We considered a categorical factor <code>Group</code> obtaining the values 0, 1 or 2
according to the group to which the image belongs to (10 images in each of the three
groups). The images were simulated in the square window [-1,1]^2 from the
general linear model (GLM)
</p>
<p style="text-align: center;"><code class="reqn">Y(r) = \exp(-10\cdot ||r||) \cdot (1 + \mathbf{1}(g=2)) + \epsilon(r),</code>
</p>

<p>where ||r|| denotes the Euclidean distance of the pixel to the origin, g is the group and
the error stems from an inhomogeneous distribution over $I$ with the normal and
bimodal errors in the middle and periphery of the image:
</p>
<p style="text-align: center;"><code class="reqn">\epsilon(r) = \mathbf{1}(\|r\| \leq 0.5) G(r) + \mathbf{1}(\|r\| &gt; 0.5) \frac{1}{2}G(r)^{1/5},</code>
</p>

<p>where G(r) is a Gaussian random field with the exponential correlation structure
with scale parameter 0.15 and standard deviation 0.2.
Consequently, the first two groups (0,1) have the same mean, while a bigger bump appears in the third group (2) in the middle of the image.
</p>


<h3>References</h3>

<p>Mrkvička, T., Myllymäki, M., Kuronen, M. and Narisetty, N. N. (2022) New methods for multiple testing in permutation inference for the general linear model. Statistics in Medicine 41(2), 276-297. doi: 10.1002/sim.9236
</p>


<h3>See Also</h3>

<p><code><a href="#topic+graph.fanova">graph.fanova</a></code>, <code><a href="#topic+frank.fanova">frank.fanova</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("imageset3")
plot(imageset3$image_set, idx=c(1:5, 11:15, 21:25), ncol=5)

# Colors can be changed as follows:
plot(imageset3$image_set, idx=c(1:5, 11:15, 21:25), ncol=5) +
  ggplot2::scale_fill_gradient(low="black", high="white")

</code></pre>

<hr>
<h2 id='is.curve_set'>Check class.</h2><span id='topic+is.curve_set'></span>

<h3>Description</h3>

<p>Check class.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.curve_set(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is.curve_set_+3A_x">x</code></td>
<td>
<p>An object to be checked.</p>
</td></tr>
</table>

<hr>
<h2 id='naturalness'>Simulated data set</h2><span id='topic+naturalness'></span>

<h3>Description</h3>

<p>Simulated data set mimicing stand age distributions in natural, near-natural
non-natural forests in the setup of Mrkvička et al. (2024).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("naturalness")
</code></pre>


<h3>Format</h3>

<p>A <code>data.frame</code> containing the dominant species (three categories:
Broadleaf, Conifer, Mixed), naturalness (Natural, Near-natural and Non-natural)
and simulated stand age.
</p>


<h3>Details</h3>

<p>The numbers of observations in the naturalness groups and in the dominant
species groups correspond to the numbers of plots in on rich mineral soils in
Finnish Lapland in the data set analysed in Myllymäki et al. (2023).
The stand age values are simulated values from the quantile regression model
of Mrkvička et al. (2024).
</p>


<h3>References</h3>

<p>Myllymäki, M., Tuominen, S., Kuronen, M., Packalen, P. and Kangas, A. (2023)
The relationship between forest structure and naturalness in the Finnish national forest inventory.
Forestry: An International Journal of Forest Research, cpad053.
DOI: https://doi.org/10.1093/forestry/cpad053
</p>
<p>Mrkvička, T., Konstantinou, K., Kuronen, M. and Myllymäki, M. (2024)
Global quantile regression. arXiv:2309.04746 [stat.ME]
DOI: https://doi.org/10.48550/arXiv.2309.04746
</p>


<h3>See Also</h3>

<p><code><a href="#topic+global_rq">global_rq</a></code>
</p>

<hr>
<h2 id='partial_forder'>Functional ordering in parts</h2><span id='topic+partial_forder'></span><span id='topic+combine_forder'></span>

<h3>Description</h3>

<p>If the functional data doesn't comfortably fit in memory it is possible to
compute functional ordering by splitting the domain of the data (voxels in
a brain image), using <code>partial_forder</code> on each part and finally
combining the results with <code>combine_forder</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>partial_forder(
  curve_set,
  measure = c("erl", "rank", "cont", "area"),
  alternative = c("two.sided", "less", "greater")
)

combine_forder(ls)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="partial_forder_+3A_curve_set">curve_set</code></td>
<td>
<p>A <code>curve_set</code> object, usually a part of a larger <code>curve_set</code>.
(No missing or infinite values allowed.)</p>
</td></tr>
<tr><td><code id="partial_forder_+3A_measure">measure</code></td>
<td>
<p>The measure to use to order the functions from the most extreme to the least extreme
one. Must be one of the following: 'rank', 'erl', 'cont', 'area', 'max', 'int', 'int2'. Default is 'erl'.</p>
</td></tr>
<tr><td><code id="partial_forder_+3A_alternative">alternative</code></td>
<td>
<p>A character string specifying the alternative hypothesis.
Must be one of the following: &quot;two.sided&quot; (default), &quot;less&quot; or &quot;greater&quot;.
The last two options only available for types <code>'rank'</code>, <code>'erl'</code>,
<code>'cont'</code> and <code>'area'</code>.</p>
</td></tr>
<tr><td><code id="partial_forder_+3A_ls">ls</code></td>
<td>
<p>List of objects returned by partial_forder</p>
</td></tr>
</table>


<h3>Value</h3>

<p>See <code><a href="#topic+forder">forder</a></code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+forder">forder</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("abide_9002_23")
res &lt;- lapply(list(1:100, 101:200, 201:261), function(part) {
  set.seed(123) # When using partial_forder, all parts must use the same seed.
  fset &lt;- frank.flm(nsim=99, formula.full = Y ~ Group + Sex + Age,
                  formula.reduced = Y ~ Group + Sex,
                  curve_sets = list(Y = abide_9002_23$curve_set[part,]),
                  factors = abide_9002_23$factors, savefuns = "return")
  partial_forder(fset, measure="erl")
})
combine_forder(res)
</code></pre>

<hr>
<h2 id='plot.combined_fboxplot'>Plot method for the class 'combined_fboxplot'</h2><span id='topic+plot.combined_fboxplot'></span>

<h3>Description</h3>

<p>Plot method for the class 'combined_fboxplot'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'combined_fboxplot'
plot(
  x,
  labels,
  scales = "free",
  ncol = 2 + 1 * (length(x) == 3),
  digits = 3,
  outliers = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.combined_fboxplot_+3A_x">x</code></td>
<td>
<p>an 'combined_fboxplot' object</p>
</td></tr>
<tr><td><code id="plot.combined_fboxplot_+3A_labels">labels</code></td>
<td>
<p>A character vector of suitable length.
If <code>dotplot = TRUE</code> (for the level 2 test), then labels for the tests at x-axis;
only valid/used when all components of <code>x</code> have the same dimension.
Otherwise labels for the separate plots.</p>
</td></tr>
<tr><td><code id="plot.combined_fboxplot_+3A_scales">scales</code></td>
<td>
<p>See <code><a href="ggplot2.html#topic+facet_wrap">facet_wrap</a></code>.
Use <code>scales = "free"</code> when the scales of the functions in the global envelope
vary. <code>scales = "fixed"</code> is a good choice, when you want the same y-axis for all components.
A sensible default based on r-values exists.</p>
</td></tr>
<tr><td><code id="plot.combined_fboxplot_+3A_ncol">ncol</code></td>
<td>
<p>The maximum number of columns for the figures.
Default 2 or 3, if the length of x equals 3.
(Relates to the number of curve_sets that have been combined.)</p>
</td></tr>
<tr><td><code id="plot.combined_fboxplot_+3A_digits">digits</code></td>
<td>
<p>The number of digits used for printing the p-value or p-interval
in the default main.</p>
</td></tr>
<tr><td><code id="plot.combined_fboxplot_+3A_outliers">outliers</code></td>
<td>
<p>Logical. If TRUE, then the functions outside the functional boxplot are drawn.</p>
</td></tr>
<tr><td><code id="plot.combined_fboxplot_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>

<hr>
<h2 id='plot.combined_global_envelope'>Plot method for the class 'combined_global_envelope'</h2><span id='topic+plot.combined_global_envelope'></span>

<h3>Description</h3>

<p>This function provides plots for combined global envelopes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'combined_global_envelope'
plot(
  x,
  labels,
  scales,
  sign.col = "red",
  dotplot = length(x[[1]]$obs) &lt; 5,
  ncol = 2 + 1 * (length(x) == 3),
  digits = 3,
  level = 1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.combined_global_envelope_+3A_x">x</code></td>
<td>
<p>An 'combined_global_envelope' object</p>
</td></tr>
<tr><td><code id="plot.combined_global_envelope_+3A_labels">labels</code></td>
<td>
<p>A character vector of suitable length.
If <code>dotplot = TRUE</code> (for the level 2 test), then labels for the tests at x-axis;
only valid/used when all components of <code>x</code> have the same dimension.
Otherwise labels for the separate plots.</p>
</td></tr>
<tr><td><code id="plot.combined_global_envelope_+3A_scales">scales</code></td>
<td>
<p>See <code><a href="ggplot2.html#topic+facet_wrap">facet_wrap</a></code>.
Use <code>scales = "free"</code> when the scales of the functions in the global envelope
vary. <code>scales = "fixed"</code> is a good choice, when you want the same y-axis for all components.
A sensible default based on r-values exists.</p>
</td></tr>
<tr><td><code id="plot.combined_global_envelope_+3A_sign.col">sign.col</code></td>
<td>
<p>The color for the observed curve when outside the global envelope
(significant regions). Default to &quot;red&quot;. Setting the color to <code>NULL</code> corresponds
to no coloring. If the object contains several envelopes, the coloring is done for
the widest one.</p>
</td></tr>
<tr><td><code id="plot.combined_global_envelope_+3A_dotplot">dotplot</code></td>
<td>
<p>Logical. If TRUE, then instead of envelopes a dot plot is done.
Suitable for low dimensional test vectors.</p>
</td></tr>
<tr><td><code id="plot.combined_global_envelope_+3A_ncol">ncol</code></td>
<td>
<p>The maximum number of columns for the figures.
Default 2 or 3, if the length of x equals 3.
(Relates to the number of curve_sets that have been combined.)</p>
</td></tr>
<tr><td><code id="plot.combined_global_envelope_+3A_digits">digits</code></td>
<td>
<p>The number of digits used for printing the p-value or p-interval
in the default main.</p>
</td></tr>
<tr><td><code id="plot.combined_global_envelope_+3A_level">level</code></td>
<td>
<p>1 or 2. In the case of two-step combined tests (with several test functions),
two different plots are available:
1 for plotting the combined global envelopes (default and most often wanted) or
2 for plotting the second level test result.</p>
</td></tr>
<tr><td><code id="plot.combined_global_envelope_+3A_...">...</code></td>
<td>
<p>Ignored in most cases. If <code>dotplot = TRUE</code>, then parameters
can be passed to <code><a href="grid.html#topic+arrow">arrow</a></code>, e.g. length = unit(0.25, &quot;cm&quot;).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Plotting method for the class 'combined_global_envelope', i.e. combined envelopes for
1d functions.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+central_region">central_region</a></code>
</p>

<hr>
<h2 id='plot.combined_global_envelope2d'>Plotting function for combined 2d global envelopes</h2><span id='topic+plot.combined_global_envelope2d'></span>

<h3>Description</h3>

<p>If fixedscales is FALSE (or 0) all images will have separate scale.
If fixedscales is TRUE (or 1) each x[[i]] will have a common scale.
If fixedscales is 2 all images will have common scale.
</p>
<p>If more than one envelope has been calculated (corresponding to several coverage/alpha),
only the largest one is plotted.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'combined_global_envelope2d'
plot(
  x,
  fixedscales = 2,
  labels,
  what = c("obs.sign", "obs", "lo", "hi", "lo.sign", "hi.sign"),
  sign.type = c("circles", "contour", "col"),
  sign.col = c("blue", "red"),
  transparency = 155/255,
  digits = 3,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.combined_global_envelope2d_+3A_x">x</code></td>
<td>
<p>A 'global_envelope' object for two-dimensional functions</p>
</td></tr>
<tr><td><code id="plot.combined_global_envelope2d_+3A_fixedscales">fixedscales</code></td>
<td>
<p>0, 1 or 2. See details.</p>
</td></tr>
<tr><td><code id="plot.combined_global_envelope2d_+3A_labels">labels</code></td>
<td>
<p>A character vector of suitable length giving the labels for the separate plots.
Default exists. This parameter allows replacing the default.</p>
</td></tr>
<tr><td><code id="plot.combined_global_envelope2d_+3A_what">what</code></td>
<td>
<p>Character vector specifying what information should be plotted for 2d functions.
A combination of:
Observed (<code>"obs"</code>), upper envelope (<code>"hi"</code>), lower envelope (<code>"lo"</code>),
observed with significantly higher values highlighted (<code>"hi.sign"</code>),
observed with significantly lower values highlighted (<code>"lo.sign"</code>),
observed with significantly (lower and higher) values highlighted (<code>"obs.sign"</code>).
Default to the last one. Combination c(&quot;obs&quot;, &quot;lo&quot;, &quot;hi&quot;, &quot;lo.sign&quot;, &quot;hi.sign&quot;) can
also be of interest (earlier default).</p>
</td></tr>
<tr><td><code id="plot.combined_global_envelope2d_+3A_sign.type">sign.type</code></td>
<td>
<p>Either <code>"col"</code> for color showing the significant region, or
<code>"contour"</code> for colored contour showing the significant region, or
<code>"circles"</code> for plotting circles at locations where the observed function
exceeds the envelope: diameters proportional to (obs-hi)/(hi-lo) for values
above the envelope and (lo-obs)/(hi-lo) for values below the envelope.
In the one-sided (testing) case, the divisors are instead (hi-central) (case 'greater')
and (central-lo) (case 'less').
Default to <code>"circles"</code>.</p>
</td></tr>
<tr><td><code id="plot.combined_global_envelope2d_+3A_sign.col">sign.col</code></td>
<td>
<p>A vector of length two giving the colors for significant parts
below the envelope (first value) and above the envelope (second value).</p>
</td></tr>
<tr><td><code id="plot.combined_global_envelope2d_+3A_transparency">transparency</code></td>
<td>
<p>A number between 0 and 1 (default 155/255, 60
Similar to alpha of <code><a href="grDevices.html#topic+rgb">rgb</a></code>. Used in plotting the significant regions for 2d
functions.</p>
</td></tr>
<tr><td><code id="plot.combined_global_envelope2d_+3A_digits">digits</code></td>
<td>
<p>The number of digits used for printing the p-value or p-interval
in the default main.</p>
</td></tr>
<tr><td><code id="plot.combined_global_envelope2d_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data("abide_9002_23")
iset &lt;- subset(abide_9002_23[['curve_set']], 1:50)
factors &lt;- abide_9002_23[['factors']][1:50,]

res &lt;- graph.flm(nsim = 19, # Increase nsim for serious analysis!
  formula.full = Y ~ Group + Sex + Age,
  formula.reduced = Y ~ Sex + Age,
  curve_sets = list(Y=iset), factors = factors,
  contrasts = FALSE, GET.args = list(type="area"))
plot(res)

plot(res, what=c("obs", "hi"))

plot(res, what=c("hi", "lo"), fixedscales=1)

plot(res, what=c("obs", "lo", "hi"), fixedscales=FALSE)

if(requireNamespace("gridExtra", quietly=TRUE)) {
  # Edit style of "fixedscales = 2" plots
  plot(res, what=c("obs", "hi")) + ggplot2::theme_minimal()
  plot(res, what=c("obs", "hi")) + ggplot2::theme_bw()

  # Edit style (e.g. theme) of "fixedscales = 1 or 0" plots
  gs &lt;- lapply(res, function(x, what) { plot(x, what=what) +
     ggplot2::ggtitle("") }, what=c("obs", "hi"))
  gridExtra::grid.arrange(grobs=gs, ncol=1, top="My main")

  gs &lt;- outer(res, c("obs", "hi"), FUN=Vectorize(function(res, what)
    list(plot(res, what=what) + ggplot2::ggtitle("") +
      ggplot2::theme(axis.ticks=ggplot2::element_blank(),
      axis.text=ggplot2::element_blank(), axis.title=ggplot2::element_blank()))))
  gridExtra::grid.arrange(grobs=t(gs))
}

</code></pre>

<hr>
<h2 id='plot.curve_set'>Plot method for the class 'curve_set'</h2><span id='topic+plot.curve_set'></span>

<h3>Description</h3>

<p>Plot method for the class 'curve_set'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'curve_set'
plot(x, idx, col_idx, idx_name = "", col = "grey70", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.curve_set_+3A_x">x</code></td>
<td>
<p>An <code>curve_set</code> object.</p>
</td></tr>
<tr><td><code id="plot.curve_set_+3A_idx">idx</code></td>
<td>
<p>Indices of functions to highlight with color <code>col_idx</code>.
Default to the observed function, if there is just one.
The legend of curves' colours is shown if indices are given or <code>x</code> contains one observed function.
See examples to remove the legend if desired.</p>
</td></tr>
<tr><td><code id="plot.curve_set_+3A_col_idx">col_idx</code></td>
<td>
<p>A color for the curves to highlight, or a vector of the same length as <code>idx</code>
containing the colors for the highlighted functions. Default exists.</p>
</td></tr>
<tr><td><code id="plot.curve_set_+3A_idx_name">idx_name</code></td>
<td>
<p>A variable name to be printed with the highlighted functions' idx. Default to empty.</p>
</td></tr>
<tr><td><code id="plot.curve_set_+3A_col">col</code></td>
<td>
<p>The basic color for the curves (which are not highlighted).</p>
</td></tr>
<tr><td><code id="plot.curve_set_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+create_curve_set">create_curve_set</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cset &lt;- curve_set(r = 1:10, obs = matrix(runif(10*5), ncol=5))
plot(cset)
# Highlight some functions
plot(cset, idx=c(1,3))
plot(cset, idx=c(1,3), col_idx=c("black", "red"))
# Change legend
plot(cset, idx=c(1,3), col_idx=c("black", "red"), idx_name="Special functions")
plot(cset, idx=c(1,3)) + ggplot2::theme(legend.position="bottom")
# Add labels
plot(cset, idx=c(1,3)) + ggplot2::labs(x="x", y="Value")
# and title
plot(cset) + ggplot2::labs(title="Example curves", x="x", y="Value")
# A curve_set with one observed function (other simulated)
if(requireNamespace("mvtnorm", quietly=TRUE)) {
  cset &lt;- curve_set(obs = c(-1.6, 1.6),
    sim = t(mvtnorm::rmvnorm(200, c(0,0), matrix(c(1,0.5,0.5,1), 2, 2))))
  plot(cset)
  # Remove legend
  plot(cset) + ggplot2::theme(legend.position="none")
}
</code></pre>

<hr>
<h2 id='plot.curve_set2d'>Plot method for the class 'curve_set2d'</h2><span id='topic+plot.curve_set2d'></span>

<h3>Description</h3>

<p>Plot method for the class 'curve_set2d', i.e. two-dimensional functions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'curve_set2d'
plot(x, idx = 1, ncol = 2 + 1 * (length(idx) == 3), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.curve_set2d_+3A_x">x</code></td>
<td>
<p>An <code>curve_set2d</code> object</p>
</td></tr>
<tr><td><code id="plot.curve_set2d_+3A_idx">idx</code></td>
<td>
<p>Indices of 2d functions to plot.</p>
</td></tr>
<tr><td><code id="plot.curve_set2d_+3A_ncol">ncol</code></td>
<td>
<p>The maximum number of columns for the figures.
Default 2 or 3, if the length of x equals 3.
(Relates to the number of curve_sets that have been combined.)</p>
</td></tr>
<tr><td><code id="plot.curve_set2d_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data("abide_9002_23")
plot(abide_9002_23$curve_set, idx=c(1, 27))
</code></pre>

<hr>
<h2 id='plot.fboxplot'>Plot method for the class 'fboxplot'</h2><span id='topic+plot.fboxplot'></span>

<h3>Description</h3>

<p>Plot method for the class 'fboxplot'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fboxplot'
plot(x, digits = 3, outliers = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.fboxplot_+3A_x">x</code></td>
<td>
<p>an 'fboxplot' object</p>
</td></tr>
<tr><td><code id="plot.fboxplot_+3A_digits">digits</code></td>
<td>
<p>The number of digits used for printing the p-value or p-interval
in the default main.</p>
</td></tr>
<tr><td><code id="plot.fboxplot_+3A_outliers">outliers</code></td>
<td>
<p>Logical. If TRUE, then the functions outside the functional boxplot are drawn.</p>
</td></tr>
<tr><td><code id="plot.fboxplot_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>if(requireNamespace("fda", quietly=TRUE)) {
  years &lt;- paste(1:18)
  curves &lt;- fda::growth[['hgtf']][years,]
  # Heights
  cset1 &lt;- curve_set(r = as.numeric(years),
                     obs = curves)
  bp &lt;- fBoxplot(cset1, coverage=0.50, type="area", factor=1)
  plot(bp)
  plot(bp) + ggplot2::theme(legend.position="bottom")
  plot(bp) + ggplot2::theme(legend.position="none")
  plot(bp, plot_outliers=FALSE)
}
</code></pre>

<hr>
<h2 id='plot.fclust'>Plot method for the class 'fclust'</h2><span id='topic+plot.fclust'></span>

<h3>Description</h3>

<p>Plot method for the 'fclust' objects returned by <code><a href="#topic+fclustering">fclustering</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fclust'
plot(x, plotstyle = c("marginal", "joined"), coverage = 0.5, nstep, ncol, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.fclust_+3A_x">x</code></td>
<td>
<p>An 'fclust' object.</p>
</td></tr>
<tr><td><code id="plot.fclust_+3A_plotstyle">plotstyle</code></td>
<td>
<p>The resulting central regions of clusters can be plotted by sorting the
appropriate <code>curve_set</code> only 'marginal' or by sorting the joined list of <code>curve_set</code>
objects 'joined'. If 'joined' is used the shown central regions corresponds to the joined
ordering used to cluster the functional data. If 'marginal' is used the shown central regions
do not correspond to the joined ordering used to cluster the functional data, but better express
the shape of cluster with respect to given <code>curve_set</code>.</p>
</td></tr>
<tr><td><code id="plot.fclust_+3A_coverage">coverage</code></td>
<td>
<p>The coverage of central regions to be used to show the clusters.</p>
</td></tr>
<tr><td><code id="plot.fclust_+3A_nstep">nstep</code></td>
<td>
<p>1 or 2 for how to contruct a combined (joined) global envelope
if there are more than one sets of curves. Default to 1, if the numbers of points
where the curves are observed (r) are the same in each set, and 2 otherwise.</p>
</td></tr>
<tr><td><code id="plot.fclust_+3A_ncol">ncol</code></td>
<td>
<p>The number of columns in the graphical output, when there is just one set of curves
that has been ordered. If not given, <code>c(1, k+1)</code> is used, which gives all plots in one row.
For more sets of curves, the rows are fixed to correspond to the sets (one row for each set).</p>
</td></tr>
<tr><td><code id="plot.fclust_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The clusters are shown respectively for each <code>curve_set</code>. Thus for each <code>curve_set</code>
the panel with all the medoids is shown followed by all clusters represented by central region,
medoid and all curves belonging to it.
</p>
<p>For all sources, the function plots the deepest curves for all clusters and
the deepest curve of each cluster together with the desired central region and
all the curves of the group.
</p>


<h3>References</h3>

<p>Dai, W., Athanasiadis, S., Mrkvička, T. (2021) A new functional clustering method with combined dissimilarity sources and graphical interpretation. Intech open, London, UK. DOI: 10.5772/intechopen.100124
</p>

<hr>
<h2 id='plot.global_envelope'>Plot method for the class 'global_envelope'</h2><span id='topic+plot.global_envelope'></span>

<h3>Description</h3>

<p>Plot method for the class 'global_envelope'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'global_envelope'
plot(
  x,
  dotplot = length(x$r) &lt; 10,
  sign.col = "red",
  labels = NULL,
  digits = 3,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.global_envelope_+3A_x">x</code></td>
<td>
<p>An 'global_envelope' object</p>
</td></tr>
<tr><td><code id="plot.global_envelope_+3A_dotplot">dotplot</code></td>
<td>
<p>Logical. If TRUE, then instead of envelopes a dot plot is done.
Suitable for low dimensional test vectors.
Default: TRUE if the dimension is less than 10, FALSE otherwise.</p>
</td></tr>
<tr><td><code id="plot.global_envelope_+3A_sign.col">sign.col</code></td>
<td>
<p>The color for the observed curve when outside the global envelope
(significant regions). Default to &quot;red&quot;. Setting the color to <code>NULL</code> corresponds
to no coloring. If the object contains several envelopes, the coloring is done for
the widest one.</p>
</td></tr>
<tr><td><code id="plot.global_envelope_+3A_labels">labels</code></td>
<td>
<p>A character vector of suitable length.
If <code>dotplot = TRUE</code>, then labels for the tests at x-axis.</p>
</td></tr>
<tr><td><code id="plot.global_envelope_+3A_digits">digits</code></td>
<td>
<p>The number of digits used for printing the p-value or p-interval
in the default main.</p>
</td></tr>
<tr><td><code id="plot.global_envelope_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If several envelopes have been computed, their are plotted in different
grey scales so that the smallest envelope has the darkest color and the widest
envelope consist of all grey scales with the lightest color in the outskirts.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+central_region">central_region</a></code>, <code><a href="#topic+global_envelope_test">global_envelope_test</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(require("spatstat.explore", quietly=TRUE)) {
  X &lt;- unmark(spruces)
  nsim &lt;- 1999 # Number of simulations
  
  env &lt;- envelope(X, fun="Kest", nsim=nsim,
                  savefuns=TRUE, # save the functions
                  correction="translate", # edge correction for K
                  simulate=expression(runifpoint(ex=X))) # Simulate CSR
  res &lt;- global_envelope_test(env, type="erl")

  # Default plot
  plot(res)
  # Plots can be edited, e.g.
  # Remove legend
  plot(res) + ggplot2::theme(legend.position="none")
  # Change its position
  plot(res) + ggplot2::theme(legend.position="right")
  # Change the outside color
  plot(res, sign.col="#5DC863FF")
  plot(res, sign.col=NULL)
  # Change default title and x- and y-labels
  plot(res) + ggplot2::labs(title="95% global envelope", x="x", y="f(x)")

  # Prior to the plot, you can set your preferred ggplot theme by theme_set
  old &lt;- ggplot2::theme_set(ggplot2::theme_bw())
  plot(res)

  # Do other edits, e.g. turn off expansion with the default limits
  plot(res) + ggplot2::coord_cartesian(expand=FALSE)

  # Go back to the old theme
  ggplot2::theme_set(old)

  # If you are working with the R package spatstat and its envelope-function,
  # you can obtain global envelope plots in the style of spatstat using plot.fv:
  plot.fv(res)
}
</code></pre>

<hr>
<h2 id='plot.global_envelope2d'>Plotting function for 2d global envelopes</h2><span id='topic+plot.global_envelope2d'></span>

<h3>Description</h3>

<p>If more than one envelope has been calculated (corresponding to several coverage/alpha),
only the largest one is plotted.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'global_envelope2d'
plot(
  x,
  fixedscales = TRUE,
  what = c("obs.sign", "obs", "lo", "hi", "lo.sign", "hi.sign"),
  sign.type = c("circles", "contour", "col"),
  sign.col = c("blue", "red"),
  transparency = 155/255,
  digits = 3,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.global_envelope2d_+3A_x">x</code></td>
<td>
<p>A 'global_envelope' object for two-dimensional functions</p>
</td></tr>
<tr><td><code id="plot.global_envelope2d_+3A_fixedscales">fixedscales</code></td>
<td>
<p>Logical. TRUE for the same scales for all images.</p>
</td></tr>
<tr><td><code id="plot.global_envelope2d_+3A_what">what</code></td>
<td>
<p>Character vector specifying what information should be plotted for 2d functions.
A combination of:
Observed (<code>"obs"</code>), upper envelope (<code>"hi"</code>), lower envelope (<code>"lo"</code>),
observed with significantly higher values highlighted (<code>"hi.sign"</code>),
observed with significantly lower values highlighted (<code>"lo.sign"</code>),
observed with significantly (lower and higher) values highlighted (<code>"obs.sign"</code>).
Default to the last one. Combination c(&quot;obs&quot;, &quot;lo&quot;, &quot;hi&quot;, &quot;lo.sign&quot;, &quot;hi.sign&quot;) can
also be of interest (earlier default).</p>
</td></tr>
<tr><td><code id="plot.global_envelope2d_+3A_sign.type">sign.type</code></td>
<td>
<p>Either <code>"col"</code> for color showing the significant region, or
<code>"contour"</code> for colored contour showing the significant region, or
<code>"circles"</code> for plotting circles at locations where the observed function
exceeds the envelope: diameters proportional to (obs-hi)/(hi-lo) for values
above the envelope and (lo-obs)/(hi-lo) for values below the envelope.
In the one-sided (testing) case, the divisors are instead (hi-central) (case 'greater')
and (central-lo) (case 'less').
Default to <code>"circles"</code>.</p>
</td></tr>
<tr><td><code id="plot.global_envelope2d_+3A_sign.col">sign.col</code></td>
<td>
<p>A vector of length two giving the colors for significant parts
below the envelope (first value) and above the envelope (second value).</p>
</td></tr>
<tr><td><code id="plot.global_envelope2d_+3A_transparency">transparency</code></td>
<td>
<p>A number between 0 and 1 (default 155/255, 60
Similar to alpha of <code><a href="grDevices.html#topic+rgb">rgb</a></code>. Used in plotting the significant regions for 2d
functions.</p>
</td></tr>
<tr><td><code id="plot.global_envelope2d_+3A_digits">digits</code></td>
<td>
<p>The number of digits used for printing the p-value or p-interval
in the default main.</p>
</td></tr>
<tr><td><code id="plot.global_envelope2d_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+graph.flm">graph.flm</a></code>
</p>

<hr>
<h2 id='popgrowthmillion'>Population growth</h2><span id='topic+popgrowthmillion'></span>

<h3>Description</h3>

<p>Population growth
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("popgrowthmillion")
</code></pre>


<h3>Format</h3>

<p>A matrix, where each row corresponds to a year and each column to a country.
Column names correspond to the countries, and row names to the years.
</p>


<h3>Details</h3>

<p>This dataset includes population growth, i.e. population at the end of the year divided
by population at the beginning of the year, in 134 countries in years from 1950 to 2015.
The dataset includes only countries over million inhabitants in 1950.
The data were extracted from the supplement of Nagy et al. (2017) distributed under the GPL-2 license.
</p>


<h3>References</h3>

<p>Nagy, S., I. Gijbels, and D. Hlubinka (2017). Depth-based recognition of shape outlying functions. Journal of Computational and Graphical Statistics 26 (4), 883-893.
</p>

<hr>
<h2 id='print.combined_fboxplot'>Print method for the class 'combined_fboxplot'</h2><span id='topic+print.combined_fboxplot'></span>

<h3>Description</h3>

<p>Print method for the class 'combined_fboxplot'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'combined_fboxplot'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.combined_fboxplot_+3A_x">x</code></td>
<td>
<p>an 'combined_fboxplot' object</p>
</td></tr>
<tr><td><code id="print.combined_fboxplot_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>

<hr>
<h2 id='print.combined_global_envelope'>Print method for the class 'combined_global_envelope'</h2><span id='topic+print.combined_global_envelope'></span>

<h3>Description</h3>

<p>Print method for the class 'combined_global_envelope'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'combined_global_envelope'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.combined_global_envelope_+3A_x">x</code></td>
<td>
<p>A 'combined_global_envelope' object</p>
</td></tr>
<tr><td><code id="print.combined_global_envelope_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>

<hr>
<h2 id='print.curve_set'>Print method for the class 'curve_set'</h2><span id='topic+print.curve_set'></span>

<h3>Description</h3>

<p>Print method for the class 'curve_set'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'curve_set'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.curve_set_+3A_x">x</code></td>
<td>
<p>an 'curve_set' object</p>
</td></tr>
<tr><td><code id="print.curve_set_+3A_...">...</code></td>
<td>
<p>Passed to <code><a href="utils.html#topic+str">str</a></code>.</p>
</td></tr>
</table>

<hr>
<h2 id='print.deviation_test'>Print method for the class 'deviation_test'</h2><span id='topic+print.deviation_test'></span>

<h3>Description</h3>

<p>Print method for the class 'deviation_test'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'deviation_test'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.deviation_test_+3A_x">x</code></td>
<td>
<p>an 'deviation_test' object</p>
</td></tr>
<tr><td><code id="print.deviation_test_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>

<hr>
<h2 id='print.fboxplot'>Print method for the class 'fboxplot'</h2><span id='topic+print.fboxplot'></span>

<h3>Description</h3>

<p>Print method for the class 'fboxplot'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fboxplot'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.fboxplot_+3A_x">x</code></td>
<td>
<p>an 'fboxplot' object</p>
</td></tr>
<tr><td><code id="print.fboxplot_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>

<hr>
<h2 id='print.fclust'>Print method for the class 'fclust'</h2><span id='topic+print.fclust'></span>

<h3>Description</h3>

<p>Print method for the 'fclust' objects returned by <code><a href="#topic+fclustering">fclustering</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fclust'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.fclust_+3A_x">x</code></td>
<td>
<p>A object of class 'fclust'.</p>
</td></tr>
<tr><td><code id="print.fclust_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>

<hr>
<h2 id='print.fdr_envelope'>Print method for the class 'fdr_envelope'</h2><span id='topic+print.fdr_envelope'></span>

<h3>Description</h3>

<p>Print method for the class 'fdr_envelope'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fdr_envelope'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.fdr_envelope_+3A_x">x</code></td>
<td>
<p>An 'fdr_envelope' object</p>
</td></tr>
<tr><td><code id="print.fdr_envelope_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>

<hr>
<h2 id='print.GET_contingency'>Print method for the class 'GET_contingency'</h2><span id='topic+print.GET_contingency'></span>

<h3>Description</h3>

<p>Print method for the class 'GET_contingency'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'GET_contingency'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.GET_contingency_+3A_x">x</code></td>
<td>
<p>A 'GET_contingency' object</p>
</td></tr>
<tr><td><code id="print.GET_contingency_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>

<hr>
<h2 id='print.global_envelope'>Print method for the class 'global_envelope'</h2><span id='topic+print.global_envelope'></span>

<h3>Description</h3>

<p>Print method for the class 'global_envelope'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'global_envelope'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.global_envelope_+3A_x">x</code></td>
<td>
<p>A 'global_envelope' object.</p>
</td></tr>
<tr><td><code id="print.global_envelope_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>

<hr>
<h2 id='qdir_envelope'>Global scaled maximum absolute difference (MAD) envelope tests</h2><span id='topic+qdir_envelope'></span><span id='topic+st_envelope'></span><span id='topic+unscaled_envelope'></span>

<h3>Description</h3>

<p>Performs the global scaled MAD envelope tests, either directional quantile or studentised,
or the unscaled MAD envelope test. These tests correspond to calling the
function <code><a href="#topic+global_envelope_test">global_envelope_test</a></code> with <code>type="qdir"</code>, <code>type = "st"</code> and
<code>type="unscaled"</code>, respectively. The functions <code>qdir_envelope</code>, <code>st_envelope</code> and
<code>unscaled_envelope</code> have been kept for historical reasons;
preferably use <code><a href="#topic+global_envelope_test">global_envelope_test</a></code> with the suitable <code>type</code> argument.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qdir_envelope(curve_set, ...)

st_envelope(curve_set, ...)

unscaled_envelope(curve_set, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="qdir_envelope_+3A_curve_set">curve_set</code></td>
<td>
<p>A <code><a href="#topic+curve_set">curve_set</a></code> object, or an <code>envelope</code> object of
<span class="pkg">spatstat</span>. If an envelope object is given, it must contain the summary
functions from the simulated patterns which can be achieved by setting
savefuns = TRUE when calling the function of <span class="pkg">spatstat</span>.</p>
</td></tr>
<tr><td><code id="qdir_envelope_+3A_...">...</code></td>
<td>
<p>Additional parameters to be passed to <code><a href="#topic+global_envelope_test">global_envelope_test</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The directional quantile envelope test (Myllymäki et al., 2015, 2017)
takes into account the unequal variances of the test function T(r)
for different distances r and is also protected against asymmetry of T(r).
</p>
<p>The studentised envelope test (Myllymäki et al., 2015, 2017)
takes into account the unequal variances of the test function T(r)
for different distances r.
</p>
<p>The unscaled envelope test (Ripley, 1981) corresponds to the classical maximum
deviation test without scaling, and leads to envelopes with constant width over the distances r.
Thus, it suffers from unequal variance of T(r) over the distances r and from the asymmetry of
distribution of T(r). We recommend to use the other global envelope tests available,
see <code><a href="#topic+global_envelope_test">global_envelope_test</a></code> for full list of alternatives.
</p>


<h3>Value</h3>

<p>An object of class <code>global_envelope</code> of <code>combined_global_envelope</code>
which can be printed and plotted directly. See <code><a href="#topic+global_envelope_test">global_envelope_test</a></code> for more details.
</p>


<h3>References</h3>

<p>Myllymäki, M., Grabarnik, P., Seijo, H. and Stoyan. D. (2015). Deviation test construction and power comparison for marked spatial point patterns. Spatial Statistics 11: 19-34. doi: 10.1016/j.spasta.2014.11.004
</p>
<p>Myllymäki, M., Mrkvička, T., Grabarnik, P., Seijo, H. and Hahn, U. (2017). Global envelope tests for spatial point patterns. Journal of the Royal Statistical Society: Series B (Statistical Methodology), 79: 381–404. doi: 10.1111/rssb.12172
</p>
<p>Ripley, B.D. (1981). Spatial statistics. Wiley, New Jersey.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+global_envelope_test">global_envelope_test</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># See more examples in ?global_envelope_test
## Testing complete spatial randomness (CSR)
#-------------------------------------------
if(require("spatstat.explore", quietly=TRUE)) {
  X &lt;- spruces
  nsim &lt;- 999 # Number of simulations
  
  ## Test for complete spatial randomness (CSR)
  # Generate nsim simulations under CSR, calculate centred L-function for the data and simulations
  env &lt;- envelope(X, fun="Lest", nsim=nsim, savefuns=TRUE,
                  correction="translate", transform=expression(.-r),
                  simulate=expression(runifpoint(ex=X)))
  res_qdir &lt;- qdir_envelope(env) # The directional quantile envelope test
  plot(res_qdir)

  ## Advanced use:
  # Create a curve set, choosing the interval of distances [r_min, r_max]
  curve_set &lt;- crop_curves(env, r_min=1, r_max=8)
  # The directional quantile envelope test
  res_qdir &lt;- qdir_envelope(curve_set); plot(res_qdir)
  # The studentised envelope test
  res_st &lt;- st_envelope(curve_set); plot(res_st)
  # The unscaled envelope test
  res_unscaled &lt;- unscaled_envelope(curve_set); plot(res_unscaled)
}
</code></pre>

<hr>
<h2 id='rank_envelope'>The rank envelope test</h2><span id='topic+rank_envelope'></span>

<h3>Description</h3>

<p>The rank envelope test, p-values and global envelopes.
The test corresponds to the global envelope test that can be carriet out by
<code><a href="#topic+global_envelope_test">global_envelope_test</a></code> by specifying the <code>type</code> for which the options
<code>"rank"</code>, <code>"erl"</code>, <code>"cont"</code> and <code>"area"</code> are available. The last
three are modifications of the first one to treat the ties in the extreme rank ordering
used in <code>"rank"</code>. This function is kept for historical reasons.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rank_envelope(curve_set, type = "rank", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rank_envelope_+3A_curve_set">curve_set</code></td>
<td>
<p>A <code><a href="#topic+curve_set">curve_set</a></code> object, or an <code>envelope</code> object of
<span class="pkg">spatstat</span>. If an envelope object is given, it must contain the summary
functions from the simulated patterns which can be achieved by setting
savefuns = TRUE when calling the function of <span class="pkg">spatstat</span>.</p>
</td></tr>
<tr><td><code id="rank_envelope_+3A_type">type</code></td>
<td>
<p>The type of the global envelope with current options for &quot;rank&quot;, &quot;erl&quot;, &quot;cont&quot; and &quot;area&quot;.
If &quot;rank&quot;, the global rank envelope accompanied by the p-interval is given (Myllymäki et al., 2017).
If &quot;erl&quot;, the global rank envelope based on extreme rank lengths accompanied by the extreme rank
length p-value is given (Myllymäki et al., 2017, Mrkvička et al., 2018). See details and additional
sections thereafter.</p>
</td></tr>
<tr><td><code id="rank_envelope_+3A_...">...</code></td>
<td>
<p>Additional parameters to be passed to <code><a href="#topic+global_envelope_test">global_envelope_test</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>"rank"</code> envelope test is a completely non-parametric test, which provides
the 100(1-alpha)% global envelope for the chosen test function T(r) on
the chosen interval of distances and associated p-values.
The other three types are solutions to break the ties in the extreme ranks
on which the <code>"rank"</code> envelope test is based on.
</p>
<p>Note: The method to break ties for the global <code>type = "rank"</code> envelope
(Myllymäki et al., 2017) can be done by the argument <code>ties</code> with default
to <code>ties = "erl"</code> corresponding to the extreme rank length breaking of ties.
In this case the global envelope corresponds to the extreme rank measure.
If instead choosing <code>type</code> to be <code>"erl"</code>, <code>"cont"</code> or <code>"area"</code>,
then the global envelope corresponds to these measures.
</p>


<h3>Value</h3>

<p>An object of class <code>global_envelope</code> of <code>combined_global_envelope</code>
which can be printed and plotted directly. See <code><a href="#topic+global_envelope_test">global_envelope_test</a></code> for more details.
</p>


<h3>Number of simulations</h3>

<p>The global <code>"erl"</code>, <code>"cont"</code>, <code>"area"</code> envelope tests allow 
in principle a lower number of simulations to be used than the global <code>"rank"</code> test
based on extreme ranks.
However, if feasible, we recommend some thousands of simulations in any case to achieve
a good power and repeatability of the test.
For the global <code>"rank"</code> envelope test, Myllymäki et al. (2017) recommended to use
at least 2500 simulations for testing at the significance level alpha = 0.05 for single
function tests, experimented with summary functions for point processes.
</p>


<h3>References</h3>

<p>Myllymäki, M., Mrkvička, T., Grabarnik, P., Seijo, H. and Hahn, U. (2017). Global envelope tests for spatial point patterns. Journal of the Royal Statistical Society: Series B (Statistical Methodology), 79: 381–404. doi: 10.1111/rssb.12172
</p>
<p>Mrkvička, T., Myllymäki, M. and Hahn, U. (2017). Multiple Monte Carlo testing, with applications in spatial point processes. Statistics &amp; Computing 27 (5): 1239-1255. doi: 10.1007/s11222-016-9683-9
</p>
<p>Mrkvička, T., Myllymäki, M., Jilek, M. and Hahn, U. (2020) A one-way ANOVA test for functional data with graphical interpretation. Kybernetika 56 (3), 432-458. doi: 10.14736/kyb-2020-3-0432
</p>


<h3>See Also</h3>

<p><code><a href="#topic+global_envelope_test">global_envelope_test</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># See ?global_envelope_test for more examples

## Testing complete spatial randomness (CSR)
#-------------------------------------------
if(require("spatstat.explore", quietly=TRUE)) {
  X &lt;- unmark(spruces)
  nsim &lt;- 2499 # Number of simulations
  
  # Generate nsim simulations under CSR, calculate centred L-function for the data and simulations
  env &lt;- envelope(X, fun="Lest", nsim=nsim, savefuns=TRUE,
                  correction="translate", transform=expression(.-r),
                  simulate=expression(runifpoint(ex=X)))
  # The rank envelope test
  res &lt;- rank_envelope(env)
  # Plot the result.
  plot(res)

  ## Advanced use:
  # Choose the interval of distances [r_min, r_max] (at the same time create a curve_set from 'env')
  curve_set &lt;- crop_curves(env, r_min=1, r_max=7)
  # Do the rank envelope test
  res &lt;- rank_envelope(curve_set); plot(res)
}
</code></pre>

<hr>
<h2 id='residual'>Residual form of the functions</h2><span id='topic+residual'></span>

<h3>Description</h3>

<p>Subtract the theoretical function <code class="reqn">S_{H_0}</code> or the mean of the functions
in the curve set. If the <code>curve_set</code> object contains already residuals
<code class="reqn">T_i(r) - T_0(r)</code>, <code>use_theo</code> ignored and the same object returned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>residual(curve_set, use_theo = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="residual_+3A_curve_set">curve_set</code></td>
<td>
<p>A <code><a href="#topic+curve_set">curve_set</a></code> object, or
an <code>envelope</code> object of <span class="pkg">spatstat</span>. If an envelope object is given,
it must contain the summary functions from the simulated patterns which can be
achieved by setting savefuns = TRUE when calling the <code>envelope</code> function.</p>
</td></tr>
<tr><td><code id="residual_+3A_use_theo">use_theo</code></td>
<td>
<p>Whether to use the theoretical summary function or the
mean of the functions in the curve_set.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The mean of the functions in the <code>curve_set</code> is the mean of all functions.
If <code>use_theo = TRUE</code>, but the component <code>theo</code> does not exist in the
<code>curve_set</code>, the mean of the functions is used silently.
</p>


<h3>Value</h3>

<p>A curve set object containing residual summary functions. theo is
no longer included.
</p>

<hr>
<h2 id='rimov'>Year temperature curves</h2><span id='topic+rimov'></span>

<h3>Description</h3>

<p>Year temperature curves
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("rimov")
</code></pre>


<h3>Format</h3>

<p>A <code>curve_set</code> object with water temperatures in 365 days of the 36 years.
The component <code>curve_set[['r']]</code> is a vector of days (from 1 to 365),
whereas <code>curve_set[['obs']]</code> contains the water temperatures such that
each column gives year temperatures in a year.
</p>


<h3>Details</h3>

<p>The water temperature data sampled at the water level of Rimov
reservoir in Czech republic every day for the 36 years between 1979 and 2014.
</p>


<h3>References</h3>

<p>Mrkvička, T., Myllymäki, M., Jilek, M. and Hahn, U. (2020) A one-way ANOVA test for functional data with graphical interpretation. Kybernetika 56 (3), 432-458. doi: 10.14736/kyb-2020-3-0432
</p>


<h3>See Also</h3>

<p>graph.fanova
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("rimov")
groups &lt;- factor(c(rep(1, times=12), rep(2, times=12), rep(3, times=12)))
for(i in 1:3)
  assign(paste0("p", i), plot(subset(rimov, groups==i)) +
    ggplot2::labs(title=paste("Group ", i, sep=""), y="Temperature"))
p3
if(require("patchwork", quietly=TRUE))
  p1 + p2 + p3
# See example analysis in ?graph.fanova
</code></pre>

<hr>
<h2 id='roadcrash'>Road crashes</h2><span id='topic+roadcrash'></span>

<h3>Description</h3>

<p>Road crashes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("roadcrash")
</code></pre>


<h3>Format</h3>

<p>A <code>list</code> with
</p>

<ul>
<li><p> x = x-coordinates of road accidents
</p>
</li>
<li><p> y = y-coordinates of road accidents
</p>
</li>
<li><p> xrange = x coordinate limits of enclosing box (-774936.86,-727048.86)
</p>
</li>
<li><p> yrange = y coordinate limits of enclosing box (-1201599.83,-1125679.83)
</p>
</li>
<li><p> Vertices.x = x-coordinates of vertices of the linear network
</p>
</li>
<li><p> Vertices.y = y-coordinates of vertices of the linear network
</p>
</li>
<li><p> Edges = a 2 column matrix giving the ID (index) of the origin and destination vectices
(in Vertices.x and Vertices.y)
</p>
</li>
<li><p> Traffic = matrix of traffic volume
</p>
</li>
<li><p> ForestDensity = matrix of forest density
</p>
</li>
<li><p> BuildingDensity = matrix of building density
</p>
</li></ul>



<h3>Details</h3>

<p>Mrkvička et al. (2023) worked with the database of road crashes
reported to the Police in the Czech Republic from 1 January 2016 to 31
December 2020. The data available here is a subpattern of this full data set,
included here with the permission of the Police in the Czech Republic.
The full data is published as open data, see
<a href="https://policyvisuals.eu/traffic-accidents-data-in-the-czech-republic/">https://policyvisuals.eu/traffic-accidents-data-in-the-czech-republic/</a>.
The subpattern 7700 crashes lying on a linear network with 269
vertices and 354 lines. Further average traffic volume (number of vehicles
per 24 hours), forest density and building density in the cell are available
in the region of the linear network.
</p>


<h3>References</h3>

<p>Mrkvička, T., Kraft, S., Blažek, V. and Myllymäki, M. (2023) Hotspots detection on a linear network with presence of covariates: a case study on road crash data.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(require("spatstat.geom", quietly = TRUE) &amp; require("spatstat.linnet", quietly = TRUE)) {
  data("roadcrash")
  win &lt;- owin(xrange = roadcrash$xrange,
              yrange = roadcrash$yrange)
  X &lt;- ppp(x = roadcrash$x, y = roadcrash$y, window = win)
  Vertices.pp &lt;- ppp(x = roadcrash$Vertices.x,
                     y = roadcrash$Vertices.y,
                     window=win)
  L &lt;- linnet(vertices=Vertices.pp,
              edges = roadcrash$Edges)
  PP &lt;- lpp(X, L)
  z1 &lt;- im(roadcrash$Traffic,
           xrange = roadcrash$xrange,
           yrange = roadcrash$yrange)
  z2 &lt;- im(roadcrash$ForestDensity,
           xrange = roadcrash$xrange,
           yrange = roadcrash$yrange)
  z3 &lt;- im(roadcrash$BuildingDensity,
           xrange = roadcrash$xrange,
           yrange = roadcrash$yrange)
}
</code></pre>

<hr>
<h2 id='saplings'>Saplings data set</h2><span id='topic+saplings'></span>

<h3>Description</h3>

<p>Saplings data set
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("saplings")
</code></pre>


<h3>Format</h3>

<p>A <code>data.frame</code> containing the locations (x- and y-coordinates) of 123 trees
in an area of 75 m x 75 m.
</p>


<h3>Details</h3>

<p>A pattern of small trees (height &lt;= 15 m) originating from an uneven aged multi-species
broadleaf nonmanaged forest in Kaluzhskie Zaseki, Russia.
</p>
<p>The pattern is a sample part of data collected over 10 ha plot as a part of a research
program headed by project leader Prof. O.V. Smirnova.
</p>


<h3>References</h3>

<p>Grabarnik, P. and Chiu, S. N. (2002) Goodness-of-fit test for complete spatial randomness against
mixtures of regular and clustered spatial point processes. <em>Biometrika</em>, <b>89</b>, 411–421.
</p>
<p>van Lieshout, M.-C. (2010) Spatial point process theory. In Handbook of Spatial Statistics (eds. A. E.
Gelfand, P. J. Diggle, M. Fuentes and P. Guttorp), Handbooks of Modern Statistical Methods. Boca
Raton: CRC Press.
</p>
<p>Myllymäki, M., Mrkvička, T., Grabarnik, P., Seijo, H. and Hahn, U. (2017). Global envelope tests for spatial point patterns. Journal of the Royal Statistical Society: Series B (Statistical Methodology), 79: 381-404. doi: 10.1111/rssb.12172
</p>


<h3>See Also</h3>

<p><code><a href="#topic+adult_trees">adult_trees</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># This is an example analysis of the saplings data set
#=====================================================
# Example of Myllymaki et al. (2017, Supplement S4).
if(require("spatstat.explore", quietly=TRUE)) {
  data("saplings")
  saplings &lt;- as.ppp(saplings, W=square(75))

  # First choose the r-distances for L (r) and J (rJ) functions, respectively.
  nr &lt;- 500
  rmin &lt;- 0.3; rminJ &lt;- 0.3
  rmax &lt;- 10; rmaxJ &lt;- 6
  rstep &lt;- (rmax-rmin)/nr; rstepJ &lt;- (rmaxJ-rminJ)/nr
  r &lt;- seq(0, rmax, by=rstep)
  rJ &lt;- seq(0, rmaxJ, by=rstepJ)

  #-- CSR test --# (a simple hypothesis)
  #--------------#
  # First, a CSR test using the L(r)-r function:
  # Note: CSR is simulated by fixing the number of points and generating nsim simulations
  # from the binomial process, i.e. we deal with a simple hypothesis.
  nsim &lt;- 999 # Number of simulations
  
  env &lt;- envelope(saplings, nsim=nsim,
   simulate=expression(runifpoint(ex=saplings)), # Simulate CSR
   fun="Lest", correction="translate", # T(r) = estimator of L with translational edge correction
   transform=expression(.-r),          # Take the L(r)-r function instead of L(r)
   r=r,                                # Specify the distance vector
   savefuns=TRUE)                      # Save the estimated functions
  # Crop the curves to the interval of distances [rmin, rmax]
  # (at the same time create a curve_set from 'env')
  curve_set &lt;- crop_curves(env, r_min=rmin, r_max=rmax)
  # Perform a global envelope test
  res &lt;- global_envelope_test(curve_set, type="erl") # type="rank" and larger nsim was used in S4.
  # Plot the result.
  plot(res) + ggplot2::ylab(expression(italic(hat(L)(r)-r)))

  # -&gt; The CSR hypothesis is clearly rejected and the rank envelope indicates clear
  # clustering of saplings. Next we explore the Matern cluster process as a null model.
}

if(require("spatstat.model", quietly=TRUE)) {
  #-- Testing the Matern cluster process --# (a composite hypothesis)
  #----------------------------------------#
  # Fit the Matern cluster process to the pattern (using minimum contrast estimation with the pair
  # correction function)
  fitted_model &lt;- kppm(saplings~1, clusters="MatClust", statistic="pcf")
  summary(fitted_model)

  nsim &lt;- 19 # 19 just for experimenting with the code!!
  #nsim &lt;- 499 # 499 is ok for type = 'qdir' (takes &gt; 1 h)

  # Make the adjusted directional quantile global envelope test using the L(r)-r function
  # (For the rank envelope test, choose type = "rank" instead and increase nsim.)
  adjenvL &lt;- GET.composite(X=fitted_model,
                     fun="Lest", correction="translate",
                     transform=expression(.-r), r=r,
                     type="qdir", nsim=nsim, nsimsub=nsim,
                     r_min=rmin, r_max=rmax)
  # Plot the test result
  plot(adjenvL) + ggplot2::ylab(expression(italic(L(r)-r)))

  # From the test with the L(r)-r function, it appears that the Matern cluster model would be
  # a reasonable model for the saplings pattern.
  # To further explore the goodness-of-fit of the Matern cluster process, test the
  # model with the J function:
  # This takes quite some time if nsim is reasonably large.
  adjenvJ &lt;- GET.composite(X=fitted_model,
                     fun="Jest", correction="none", r=rJ,
                     type="qdir", nsim=nsim, nsimsub=nsim,
                     r_min=rminJ, r_max=rmaxJ)
  # Plot the test result
  plot(adjenvJ) + ggplot2::ylab(expression(italic(J(r))))
  # -&gt; the Matern cluster process not adequate for the saplings data

  # Test with the two test functions jointly
  adjenvLJ &lt;- GET.composite(X=fitted_model,
                     testfuns=list(L=list(fun="Lest", correction="translate",
                                          transform=expression(.-r), r=r),
                                   J=list(fun="Jest", correction="none", r=rJ)),
                     type="erl", nsim=nsim, nsimsub=nsim,
                     r_min=c(rmin, rminJ), r_max=c(rmax, rmaxJ),
                     save.cons.envelope=TRUE)
  plot(adjenvLJ)
}
</code></pre>

<hr>
<h2 id='StatCentralRegion'>Central region plot</h2><span id='topic+StatCentralRegion'></span><span id='topic+GeomCentralRegion'></span><span id='topic+GeomCentralRegionMulti'></span>

<h3>Description</h3>

<p><code>ggproto</code> objects for central region plot. Not to be used directly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>StatCentralRegion

GeomCentralRegion

GeomCentralRegionMulti
</code></pre>


<h3>Format</h3>

<p>An object of class <code>StatCentralRegion</code> (inherits from <code>Stat</code>, <code>ggproto</code>, <code>gg</code>) of length 4.
</p>
<p>An object of class <code>GeomCentralRegion</code> (inherits from <code>Geom</code>, <code>ggproto</code>, <code>gg</code>) of length 4.
</p>
<p>An object of class <code>GeomCentralRegionMulti</code> (inherits from <code>Geom</code>, <code>ggproto</code>, <code>gg</code>) of length 4.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+geom_central_region">geom_central_region</a></code>
</p>

<hr>
<h2 id='subset.curve_set'>Subsetting curve sets</h2><span id='topic+subset.curve_set'></span>

<h3>Description</h3>

<p>Return subsets of curve sets which meet conditions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'curve_set'
subset(x, subset, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="subset.curve_set_+3A_x">x</code></td>
<td>
<p>A <code>curve_set</code> object.</p>
</td></tr>
<tr><td><code id="subset.curve_set_+3A_subset">subset</code></td>
<td>
<p>A logical expression indicating curves to keep.</p>
</td></tr>
<tr><td><code id="subset.curve_set_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>if(require("fda.usc", quietly=TRUE)) {
  # Prepare data
  data("poblenou")
  Free &lt;- poblenou$df$day.festive == 1 |
    as.integer(poblenou$df$day.week) &gt;= 6
  MonThu &lt;- poblenou$df$day.festive == 0 &amp; poblenou$df$day.week %in% 1:4
  Friday &lt;- poblenou$df$day.festive == 0 &amp; poblenou$df$day.week == 5

  # Data as a curve_set
  cset &lt;- curve_set(r=0:23, obs=t(poblenou[['nox']][['data']]))
  plot(subset(cset, MonThu))
  plot(subset(cset, Friday))
  plot(subset(cset, Free))
}
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
