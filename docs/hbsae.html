<!DOCTYPE html><html><head><title>Help for package hbsae</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {hbsae}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#hbsae-package'><p>A package for hierarchical Bayesian small area estimation.</p></a></li>
<li><a href='#aggr'><p>Compute aggregates of small area estimates and MSEs.</p></a></li>
<li><a href='#bench'><p>Benchmark small area estimates.</p></a></li>
<li><a href='#CVarea'><p>Compute area-level cross-validation measure for sae objects.</p></a></li>
<li><a href='#fSAE'><p>Fit a linear model with random area effects and compute small area estimates.</p></a></li>
<li><a href='#fSAE.Area'><p>Compute small area estimates based on the basic area-level model.</p></a></li>
<li><a href='#fSAE.Unit'><p>Compute small area estimates based on the basic unit-level model.</p></a></li>
<li><a href='#fSurvReg'><p>Compute small area estimates based on the survey regression estimator.</p></a></li>
<li><a href='#generateFakeData'><p>Generate artificial dataset for demonstration and testing purposes.</p></a></li>
<li><a href='#plot.sae'><p>Plot method for objects of class sae.</p></a></li>
<li><a href='#plot.weights'><p>Plot method for objects of class <code>weights</code>.</p></a></li>
<li><a href='#print.sae'><p>Print method for objects of class sae.</p></a></li>
<li><a href='#sae-class'><p>S3 class for the fitted model and SAE outcomes.</p></a></li>
<li><a href='#summary.weights'><p>Summary method for objects of class <code>weights</code>.</p></a></li>
<li><a href='#uweights'><p>Compute unit weights underlying the small area estimates or their aggregate.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>1.2</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Title:</td>
<td>Hierarchical Bayesian Small Area Estimation</td>
</tr>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Description:</td>
<td>Functions to compute small area estimates based on a basic area or
    unit-level model. The model is fit using restricted maximum likelihood, or
    in a hierarchical Bayesian way. In the latter case numerical integration is
    used to average over the posterior density for the between-area variance.
    The output includes the model fit, small area estimates and corresponding
    mean squared errors, as well as some model selection measures. Additional functions
    provide means to compute aggregate estimates and mean squared errors, to minimally
    adjust the small area estimates to benchmarks at a higher aggregation
    level, and to graphically compare different sets of small area estimates.</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-03-03</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.15.2)</td>
</tr>
<tr>
<td>Imports:</td>
<td>Matrix, methods</td>
</tr>
<tr>
<td>Suggests:</td>
<td>mcmcsae, survey, knitr, hypergeo, testthat</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.2</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-03-04 20:06:23 UTC; hbta</td>
</tr>
<tr>
<td>Author:</td>
<td>Harm Jan Boonstra [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Harm Jan Boonstra &lt;hjboonstra@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-03-05 15:40:13 UTC</td>
</tr>
</table>
<hr>
<h2 id='hbsae-package'>A package for hierarchical Bayesian small area estimation.</h2><span id='topic+hbsae-package'></span><span id='topic+hbsae'></span>

<h3>Description</h3>

<p>Package hbsae provides functions to compute small area estimates based on the
basic unit-level and area-level models. The models are fit and small area estimates are
computed in a hierarchical Bayesian way, using numerical integration.
</p>


<h3>Details</h3>

<p>The main function that does most of the computational work is <code><a href="#topic+fSAE.Unit">fSAE.Unit</a></code>.
Function <code><a href="#topic+fSAE">fSAE</a></code> is provided as a more convenient interface to
<code><a href="#topic+fSurvReg">fSurvReg</a></code>, <code><a href="#topic+fSAE.Area">fSAE.Area</a></code> and <code><a href="#topic+fSAE.Unit">fSAE.Unit</a></code>.
</p>

<hr>
<h2 id='aggr'>Compute aggregates of small area estimates and MSEs.</h2><span id='topic+aggr'></span>

<h3>Description</h3>

<p>Compute aggregates of small area estimates and MSEs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aggr(x, R)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="aggr_+3A_x">x</code></td>
<td>
<p>sae object.</p>
</td></tr>
<tr><td><code id="aggr_+3A_r">R</code></td>
<td>
<p>aggregation matrix, M x r matrix where M is the number of areas and r
the number of aggregate areas; default is aggregation over all areas.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Object of class <code>sae</code> with aggregated small area estimates and MSEs.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sae-class">sae-class</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>d &lt;- generateFakeData()

# compute small area estimates
sae &lt;- fSAE(y0 ~ x + area2, data=d$sam, area="area", popdata=d$Xpop)

# by default aggregate over all areas
global &lt;- aggr(sae)
EST(global); RMSE(global)

# aggregation to broad area
# first build aggregation matrix
M &lt;- d$Xpop[, c("area22", "area23", "area24")] / d$Xpop[, "(Intercept)"]
M &lt;- cbind(1 - rowSums(M), M); colnames(M)[1] &lt;- "area21"
est.area2 &lt;- aggr(sae, M)
EST(est.area2); RMSE(est.area2)
COV(est.area2)  # covariance matrix
</code></pre>

<hr>
<h2 id='bench'>Benchmark small area estimates.</h2><span id='topic+bench'></span>

<h3>Description</h3>

<p>Benchmark small area estimates to conform to given totals at aggregate levels.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bench(x, R, rhs, mseMethod = "no", Omega, Lambda)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bench_+3A_x">x</code></td>
<td>
<p>sae object to be benchmarked. As an alternative, a list can be supplied with at least components <code>Narea</code> with
area population sizes and <code>est</code> with small area estimates. In the latter case argument <code>Omega</code> cannot be left unspecified.</p>
</td></tr>
<tr><td><code id="bench_+3A_r">R</code></td>
<td>
<p>restriction matrix, M x r matrix where r is the number of restrictions and M the number of areas; default is a single constraint on the population total.
Note that <code>R</code> acts on the vector of area totals, not the vector of means.</p>
</td></tr>
<tr><td><code id="bench_+3A_rhs">rhs</code></td>
<td>
<p>r-vector of benchmark totals corresponding to the restrictions represented by (the columns of) <code>R</code>.</p>
</td></tr>
<tr><td><code id="bench_+3A_msemethod">mseMethod</code></td>
<td>
<p>if <code>"no"</code>, MSEs are not updated, if <code>"exact"</code>, constraints are treated as independent information
(exact identities by default), and if <code>"model"</code>, the squared differences between original and benchmarked estimates are added to the MSEs.</p>
</td></tr>
<tr><td><code id="bench_+3A_omega">Omega</code></td>
<td>
<p>M x M matrix <code class="reqn">\Omega</code> in objective function, see details. By default this is the covariance
matrix of the small area estimates.</p>
</td></tr>
<tr><td><code id="bench_+3A_lambda">Lambda</code></td>
<td>
<p>r x r matrix <code class="reqn">\Lambda</code> in objective function, see details. By specifying <code>Lambda</code>
it is possible to impose 'soft' constraints, i.e. constraints that need to hold only approximately.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function adjusts the small area estimates <code>EST(x)</code>, denoted by <code class="reqn">x_0</code>, to
</p>
<p style="text-align: center;"><code class="reqn">x_1 = x_0 + \Omega R_N (R_N' \Omega R_N + \Lambda)^{-1} (t - R_N' x_0)\,,</code>
</p>

<p>where
</p>

<ul>
<li> <p><code class="reqn">\Omega</code>
is a symmetric M x M matrix. By default, <code class="reqn">\Omega</code> is taken to be the covariance matrix <code class="reqn">V_0</code>
of the input sae-object <code>x</code>.
</p>
</li>
<li> <p><code class="reqn">R_N = {\rm diag}(N_1,\dots, N_M)\,R</code>
where <code class="reqn">R</code> is the matrix passed to <code>bench</code> and <code class="reqn">N_i</code> denotes the population size
of the <code class="reqn">i</code>th area, is a M x r matrix describing the aggregate level relative to the area level.
Note that the matrix <code class="reqn">R</code> acts on the vector of area totals whereas <code class="reqn">R_N</code> acts on the area means to
produce the aggregate totals.
The default for <code class="reqn">R</code> is a column vector of 1s representing an additivity constraint to the overall population total.
</p>
</li>
<li> <p><code class="reqn">t</code> is an r-vector of aggregate-level totals, specified as <code>rhs</code>, that the small area estimates should add up to.
</p>
</li>
<li> <p><code class="reqn">\Lambda</code> is a symmetric r x r matrix controlling the penalty associated with deviations from the constraints
<code class="reqn">R_N' x_1 = t</code>.
The default is <code class="reqn">\Lambda=0</code>, implying that the constraints must hold exactly.
</p>
</li></ul>

<p>The adjusted or benchmarked small area estimates minimize the expectation of the loss function
</p>
<p style="text-align: center;"><code class="reqn">L(x_1, \theta) = (x_1 - \theta)' \Omega^{-1} (x_1 - \theta) + 
       (R_N' x_1 - t)' \Lambda^{-1} (R_N' x_1 - t)</code>
</p>

<p>with respect to the posterior for the unknown small area means <code class="reqn">\theta</code>.
</p>
<p>Optionally, <code>MSE(x)</code> is updated as well. If <code>mseMethod="exact"</code> the covariance matrix is adjusted from
<code class="reqn">V_0</code> to
</p>
<p style="text-align: center;"><code class="reqn">V_1 = V_0 - V_0 R_N (R_N' \Omega R_N + \Lambda)^{-1} R_N' V_0\,,</code>
</p>

<p>and if <code>mseMethod</code> is <code>"model"</code> the adjusted covariance matrix is
</p>
<p style="text-align: center;"><code class="reqn">V_1 = V_0 + (x_1 - x_0) (x_1 - x_0)'\,.</code>
</p>

<p>The latter method treats the benchmark adjustments as incurring a bias
relative to the best predictor under the model.
</p>


<h3>Value</h3>

<p>An object of class <code>sae</code> with adjusted estimates.
</p>


<h3>References</h3>

<p>G.S. Datta, M. Ghosh, R. Steorts and J. Maples (2011). Bayesian benchmarking with applications to small area estimation. TEST 20(3), 574-588.
</p>
<p>Y. You, J.N.K. Rao and P. Dick (2004). Benchmarking Hierarchical Bayes Small Area Estimators
in the Canadian Census Undercoverage Estimation. Statistics in Transition 6(5), 631-640.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sae-class">sae-class</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>d &lt;- generateFakeData()

# compute small area estimates
sae &lt;- fSAE(y0 ~ x + area2, data=d$sam, area="area", popdata=d$Xpop)

# calibrate to overall population total
sae.c &lt;- bench(sae, rhs=sum(d$mY0*sae$Narea))
plot(sae, sae.c)
</code></pre>

<hr>
<h2 id='CVarea'>Compute area-level cross-validation measure for sae objects.</h2><span id='topic+CVarea'></span>

<h3>Description</h3>

<p>This function computes a cross-validation measure defined at the area level.
It can be used, for example, to compare the predictive ability of area and unit-level models.
The code is based in part on that of <code>cv.glm</code> from package <span class="pkg">boot</span>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CVarea(
  sae,
  weight = TRUE,
  cost = function(y, yhat, w) sum(w * (y - yhat)^2)/sum(w),
  K = 10L,
  method = "hybrid",
  seed
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CVarea_+3A_sae">sae</code></td>
<td>
<p>object of class sae, resulting from a call to <code><a href="#topic+fSAE">fSAE</a></code>,
<code><a href="#topic+fSAE.Area">fSAE.Area</a></code>, or <code><a href="#topic+fSAE.Unit">fSAE.Unit</a></code>.</p>
</td></tr>
<tr><td><code id="CVarea_+3A_weight">weight</code></td>
<td>
<p>if <code>TRUE</code>, use weights inversely proportional to the MSEs of y - yhat in the cost function.</p>
</td></tr>
<tr><td><code id="CVarea_+3A_cost">cost</code></td>
<td>
<p>cost function to be used. Defaults to a quadratic cost function.</p>
</td></tr>
<tr><td><code id="CVarea_+3A_k">K</code></td>
<td>
<p>K in K-fold cross-validation. Specifies in how many parts the dataset should be divided.</p>
</td></tr>
<tr><td><code id="CVarea_+3A_method">method</code></td>
<td>
<p>method used to refit the model. One of &quot;HB&quot;, &quot;hybrid&quot; (default) or &quot;REML&quot;, in the order of slow to fast.</p>
</td></tr>
<tr><td><code id="CVarea_+3A_seed">seed</code></td>
<td>
<p>random seed used in selecting groups of areas to leave out in K-fold cross-validation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The computed area-level cross-validation measure.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>d &lt;- generateFakeData()

# compute small area estimates based on area-level and unit-level models
saeArea &lt;- fSAE(y0 ~ x + area2, data=d$sam, area="area", popdata=d$Xpop,
                type="area", silent=TRUE, keep.data=TRUE)
saeUnit &lt;- fSAE(y0 ~ x + area2, data=d$sam, area="area", popdata=d$Xpop,
                type="unit", silent=TRUE, keep.data=TRUE)

# compare area and unit-level models based on area-level cross-validation

CVarea(saeArea, K=10, seed=1)  # 10-fold CV for area-level model
CVarea(saeUnit, K=10, seed=1)  # 10-fold CV for unit-level model

</code></pre>

<hr>
<h2 id='fSAE'>Fit a linear model with random area effects and compute small area estimates.</h2><span id='topic+fSAE'></span>

<h3>Description</h3>

<p>This function prepares the (unit-level) input data and calls one of the lower level functions <code><a href="#topic+fSurvReg">fSurvReg</a></code>, <code><a href="#topic+fSAE.Area">fSAE.Area</a></code> or <code><a href="#topic+fSAE.Unit">fSAE.Unit</a></code>
to compute survey regression, area-level model or unit-level model small area estimates. Area-level model estimates 
are computed by first computing survey regression estimates and using these as input for <code><a href="#topic+fSAE.Area">fSAE.Area</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fSAE(
  formula,
  data,
  area = NULL,
  popdata = NULL,
  type = "unit",
  model.direct = NULL,
  formula.area = NULL,
  contrasts.arg = NULL,
  remove.redundant = TRUE,
  redundancy.tol = 1e-07,
  sparse = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fSAE_+3A_formula">formula</code></td>
<td>
<p>model formula, indicating response variable and covariates.</p>
</td></tr>
<tr><td><code id="fSAE_+3A_data">data</code></td>
<td>
<p>unit-level data frame containing all variables used in <code>formula</code>, <code>area</code> and <code>formula.area</code> arguments.
These variables should not contain missing values.</p>
</td></tr>
<tr><td><code id="fSAE_+3A_area">area</code></td>
<td>
<p>name of area indicator variable in <code>data</code>; if <code>NULL</code>, no random effects are used in the model.</p>
</td></tr>
<tr><td><code id="fSAE_+3A_popdata">popdata</code></td>
<td>
<p>data frame or matrix containing area population totals for all covariates. The rows should correspond to areas
for which estimates are required.
Column names should include those produced by <code>model.matrix(formula, data, contrasts.arg)</code>, up to permutations of the names in interactions.
A column named '(Intercept)' is required and should contain the area population sizes.
If <code>popdata</code> is <code>NULL</code>, only the model fit is returned.</p>
</td></tr>
<tr><td><code id="fSAE_+3A_type">type</code></td>
<td>
<p>type of small area estimates: &quot;direct&quot; for survey regression, &quot;area&quot; for area-level model, &quot;unit&quot; for unit-level model estimates.
If <code>type</code> is &quot;data&quot; then only the data including the model matrix and population means are returned.</p>
</td></tr>
<tr><td><code id="fSAE_+3A_model.direct">model.direct</code></td>
<td>
<p>if type=&quot;area&quot;, this argument can be used to specify by means of a formula the covariates to use for the computation of the initial survey regression estimates.
If unspecified, the covariates specified by <code>formula</code> are used both at the unit level (for the initial estimates) and at the area level (for the area-level model estimates).</p>
</td></tr>
<tr><td><code id="fSAE_+3A_formula.area">formula.area</code></td>
<td>
<p>if type=&quot;unit&quot;, this is an optional formula specifying covariates that should be used at the area level.
These covariates should be available in <code>popdata</code>.</p>
</td></tr>
<tr><td><code id="fSAE_+3A_contrasts.arg">contrasts.arg</code></td>
<td>
<p>list for specification of contrasts for factor variables. Passed to <code>model.matrix</code>.</p>
</td></tr>
<tr><td><code id="fSAE_+3A_remove.redundant">remove.redundant</code></td>
<td>
<p>if <code>TRUE</code> redundant columns in the design matrix are removed. A warning is issued if
the same redundancy does not show also in the corresponding population totals. In the case of the
area-level model there may still be redundancy at the area level.</p>
</td></tr>
<tr><td><code id="fSAE_+3A_redundancy.tol">redundancy.tol</code></td>
<td>
<p>tolerance for detecting linear dependencies among the columns of the design matrix. Also used as tolerance in the check whether the design matrix redundancy is shared by the population totals.</p>
</td></tr>
<tr><td><code id="fSAE_+3A_sparse">sparse</code></td>
<td>
<p>if <code>TRUE</code> <code>sparse.model.matrix</code> (package <code>Matrix</code>) is used to compute the covariate design matrix. This can be efficient
for large datasets and a model containing categorical variables with many categories.</p>
</td></tr>
<tr><td><code id="fSAE_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code><a href="#topic+fSAE.Unit">fSAE.Unit</a></code> or <code><a href="#topic+fSurvReg">fSurvReg</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>sae</code> containing the small area estimates, their MSEs, and the model fit. If <code>type</code> is &quot;data&quot; a list containing
the model matrix, response vector, area indicator, area population sizes and matrix of population means is returned.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sae-class">sae-class</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>d &lt;- generateFakeData()

# model fitting only
(fit &lt;- fSAE(y0 ~ x + area2, data=d$sam, area="area"))

# model fitting and small area estimation, unit-level model
saeHB &lt;- fSAE(y0 ~ x + area2, data=d$sam, area="area", popdata=d$Xpop,
              silent=TRUE)
saeHB  # print a summary
EST(saeHB)  # small area estimates
RMSE(saeHB)  # error estimates
str(saeHB)
plot(saeHB, list(est=d$mY0), CI=2)  # compare to true population means

# unit-level model with REML model-fit instead of Bayesian approach
saeREML &lt;- fSAE(y0 ~ x + area2, data=d$sam, area="area", popdata=d$Xpop,
                method="REML", silent=TRUE)
plot(saeHB, saeREML)  # compare

# basic area-level model
saeA &lt;- fSAE(y0 ~ x + area2, data=d$sam, area="area", popdata=d$Xpop,
             type="area")
plot(saeHB, saeA)

# SAE estimates based on a linear unit-level model without area effects
saeL &lt;- fSAE(y0 ~ x + area2, data=d$sam, area="area", popdata=d$Xpop,
             method="synthetic")
plot(saeHB, saeL)

# model-based estimation of overall population mean without area effects
est.global &lt;- fSAE(y0 ~ x + area2, data=d$sam, area=NULL,
                   popdata=colSums(d$Xpop), method="synthetic")
EST(est.global); RMSE(est.global)

# no model fitting or estimation, but return design matrix, variable of interest,
#   area indicator, area population sizes and matrix of population means
dat &lt;- fSAE(y0 ~ x + area2, data=d$sam, area="area", popdata=d$Xpop,
            type="data")
str(dat)
</code></pre>

<hr>
<h2 id='fSAE.Area'>Compute small area estimates based on the basic area-level model.</h2><span id='topic+fSAE.Area'></span>

<h3>Description</h3>

<p>This function returns small area estimates based on the basic area-level model, also known as the Fay-Herriot model.
It calls <code><a href="#topic+fSAE.Unit">fSAE.Unit</a></code> to carry out the computations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fSAE.Area(est.init, var.init, X, x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fSAE.Area_+3A_est.init">est.init</code></td>
<td>
<p>m-vector of initial estimates, where m is the number of in-sample areas.</p>
</td></tr>
<tr><td><code id="fSAE.Area_+3A_var.init">var.init</code></td>
<td>
<p>m-vector of corresponding variance estimates.</p>
</td></tr>
<tr><td><code id="fSAE.Area_+3A_x">X</code></td>
<td>
<p>M x p matrix of area-level covariates (typically population means), where M is the number of areas for which estimates are computed.
If missing, a column vector of ones of the same length as <code>est.init</code> is used, corresponding to a model with an intercept only.
The M areas may or may not equal the m areas for which initial estimates are provided. For example, estimates
for out-of-sample areas, for which no initial estimates are available, are computed as long as the corresponding
rows of auxiliary means are in <code>X</code>. It is also possible to compute estimates only for a subset of sample areas,
see the help for argument <code>x</code>.</p>
</td></tr>
<tr><td><code id="fSAE.Area_+3A_x">x</code></td>
<td>
<p>an optional m x p matrix with auxiliary area-level covariates to be used for fitting the model,
where the rows correspond to the components of <code>est.init</code>.
If the M areas corresponding to the rows of <code>X</code> do not contain all m areas corresponding to
<code>est.init</code>, <code>x</code> must be provided separately in order to be able to fit the model.</p>
</td></tr>
<tr><td><code id="fSAE.Area_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code><a href="#topic+fSAE.Unit">fSAE.Unit</a></code>. For example, passing
an M-vector <code>Narea</code> with area population sizes (along with the matrix <code>X</code> of
population means) allows to compute aggregates of the small area estimates. See the
documentation of function <code><a href="#topic+fSAE.Unit">fSAE.Unit</a></code> for a description of other possible arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>sae</code> containing the small area estimates and MSEs, the model fit, and model selection measures.
</p>


<h3>References</h3>

<p>R.E. Fay and R.A. Herriot (1979). Estimates of Income for Small Places: An Application of James-Stein Procedures to Census Data.
Journal of the American Statistical Association 74(366), 269-277.
</p>
<p>J.N.K. Rao and I. Molina (2015). Small Area Estimation. Wiley.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sae-class">sae-class</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>d &lt;- generateFakeData()

# first compute input estimates without "borrowing strength" over areas
sae0 &lt;- fSAE(y0 ~ x + area2, data=d$sam, area="area", popdata=d$Xpop,
             type="direct", keep.data=TRUE)

# compute small area estimates based on the basic area-level model
#   using the above survey regression estimates as input
sae &lt;- fSAE.Area(EST(sae0), MSE(sae0), X=sae0$Xp)
EST(sae)  # estimates
RMSE(sae)  # standard errors
</code></pre>

<hr>
<h2 id='fSAE.Unit'>Compute small area estimates based on the basic unit-level model.</h2><span id='topic+fSAE.Unit'></span>

<h3>Description</h3>

<p>This is the function that carries out most of the computational work. It computes small area estimates based on the basic unit-level model, also known as the
Battese-Harter-Fuller model, although it is also called by <code><a href="#topic+fSurvReg">fSurvReg</a></code> and <code><a href="#topic+fSAE.Area">fSAE.Area</a></code> to compute survey regression
or area-level model small area estimates. By default, Hierarchical Bayes estimates are computed, using fast one-dimensional
numerical integration to average over the posterior density for the ratio of between and within area variance. This way, the small area estimates
and MSEs account for the uncertainty about this parameter. Besides hierarchical Bayes, REML and hybrid methods are supported.
These methods use the REML estimate or posterior mean of the variance ratio, respectively, as a plug-in estimate. Both methods do not account for uncertainty about this
parameter. Synthetic estimates are computed by setting the variance ratio to zero.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fSAE.Unit(
  y,
  X,
  area,
  Narea = NULL,
  Xpop = NULL,
  fpc = TRUE,
  v = NULL,
  vpop = NULL,
  w = NULL,
  wpop = NULL,
  method = "HB",
  beta0 = rep(0, ncol(X)),
  Omega0 = Diagonal(n = ncol(X), x = 0),
  nu0 = 0,
  s20 = 0,
  prior = function(x) rep.int(1L, length(x)),
  CV = prod(dim(X)) &lt; 1e+06,
  CVweights = NULL,
  silent = FALSE,
  keep.data = FALSE,
  full.cov = nrow(Xpop) &lt; 1000L,
  lambda0 = NULL,
  rel.int.tol = 0.01,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fSAE.Unit_+3A_y">y</code></td>
<td>
<p>response vector of length n.</p>
</td></tr>
<tr><td><code id="fSAE.Unit_+3A_x">X</code></td>
<td>
<p>n x p model matrix.</p>
</td></tr>
<tr><td><code id="fSAE.Unit_+3A_area">area</code></td>
<td>
<p>n-vector of area codes, typically a factor variable with m levels, where m is the number of in-sample areas.</p>
</td></tr>
<tr><td><code id="fSAE.Unit_+3A_narea">Narea</code></td>
<td>
<p>M-vector of area population sizes, where M is the number of areas for which estimates are required.
There should be a one-to-one correspondence with the rows of <code>Xpop</code>.
This argument is required unless <code>Xpop=NULL</code> or <code>fpc=FALSE</code>.</p>
</td></tr>
<tr><td><code id="fSAE.Unit_+3A_xpop">Xpop</code></td>
<td>
<p>M x p matrix of population means. If <code>Xpop</code> is not provided, only the model fit is returned.</p>
</td></tr>
<tr><td><code id="fSAE.Unit_+3A_fpc">fpc</code></td>
<td>
<p>whether a finite population correction should be used. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="fSAE.Unit_+3A_v">v</code></td>
<td>
<p>unit-level variance structure, n-vector. Defaults to a vector of 1s. In some cases it might be useful
to take v proportional to the sampling probabilities.</p>
</td></tr>
<tr><td><code id="fSAE.Unit_+3A_vpop">vpop</code></td>
<td>
<p>population area means of v, M-vector. Defaults to a vector of 1s. Not used when <code>fpc</code> is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="fSAE.Unit_+3A_w">w</code></td>
<td>
<p>area-level variance structure, m-vector. Defaults to a vector of 1s.</p>
</td></tr>
<tr><td><code id="fSAE.Unit_+3A_wpop">wpop</code></td>
<td>
<p>area-level variance structure, M-vector. Defaults to a vector of 1s.
Only components of <code>wpop</code> corresponding to out-of-sample areas are actually used.</p>
</td></tr>
<tr><td><code id="fSAE.Unit_+3A_method">method</code></td>
<td>
<p>one of &quot;HB&quot;, &quot;hybrid&quot;, &quot;REML&quot;, &quot;synthetic&quot;, &quot;survreg&quot;, &quot;BLUP&quot; where
&quot;HB&quot; (default) does the full hierarchical Bayes computation, i.e. numerical integration over the posterior density for the between area variance parameter,
&quot;hybrid&quot; computes the Best Linear Unbiased Predictor (BLUP) with the posterior mean for the variance parameter plugged in,
&quot;REML&quot; computes the BLUP with the restricted maximum likelihood estimate of the variance parameter plugged in,
&quot;synthetic&quot; computes synthetic estimates where the between area variance is set to 0, and
&quot;survreg&quot; computes survey regression estimates where the between area variance approaches infinity.
&quot;BLUP&quot; computes BLUP estimates with the value provided for <code>lambda0</code> as a fixed plug-in value for the ratio of between and within area variance.
Only method &quot;HB&quot; takes uncertainty about the between-area variance into account.</p>
</td></tr>
<tr><td><code id="fSAE.Unit_+3A_beta0">beta0</code></td>
<td>
<p>mean vector of normal prior for coefficient vector.</p>
</td></tr>
<tr><td><code id="fSAE.Unit_+3A_omega0">Omega0</code></td>
<td>
<p>inverse covariance matrix of normal prior for coefficient vector. Default prior
corresponds to the (improper) uniform distribution.</p>
</td></tr>
<tr><td><code id="fSAE.Unit_+3A_nu0">nu0</code></td>
<td>
<p>degrees of freedom parameter for inverse gamma prior for residual (within-area) variance. Default is 0.</p>
</td></tr>
<tr><td><code id="fSAE.Unit_+3A_s20">s20</code></td>
<td>
<p>scale parameter for inverse gamma prior for residual (within-area) variance. Default is 0.</p>
</td></tr>
<tr><td><code id="fSAE.Unit_+3A_prior">prior</code></td>
<td>
<p>prior density for the ratio lambda = between-area-variance / within-area variance. This should be a (vectorized) function that takes
a vector lambda and returns a vector of prior density values at lambda. The density does not have to be normalized. The default is
the (improper) uniform prior. The within-area variance and lambda are assumed independent a priori.</p>
</td></tr>
<tr><td><code id="fSAE.Unit_+3A_cv">CV</code></td>
<td>
<p>whether (an approximation to the) leave-one-out cross-validation measure should be computed. As this
requires the computation of a dense matrix the size of <code>X</code>, the
default is to set <code>CV</code> to <code>FALSE</code> if the size of <code>X</code> is larger
than a certain lower bound.</p>
</td></tr>
<tr><td><code id="fSAE.Unit_+3A_cvweights">CVweights</code></td>
<td>
<p>n-vector of weights to use for CV computation.</p>
</td></tr>
<tr><td><code id="fSAE.Unit_+3A_silent">silent</code></td>
<td>
<p>if <code>FALSE</code>, plot the posterior density for the variance ratio.</p>
</td></tr>
<tr><td><code id="fSAE.Unit_+3A_keep.data">keep.data</code></td>
<td>
<p>if <code>TRUE</code> return the input data (y,X,area,Xpop).
This is required input for the cross-validation function <code>CVArea</code>.</p>
</td></tr>
<tr><td><code id="fSAE.Unit_+3A_full.cov">full.cov</code></td>
<td>
<p>if <code>TRUE</code> compute the full covariance matrix for the small area estimates.
The computed correlations do not account for uncertainty about the variance ratio.</p>
</td></tr>
<tr><td><code id="fSAE.Unit_+3A_lambda0">lambda0</code></td>
<td>
<p>optional starting value for the ratio of between and within-area variance used in the numerical routines.
If <code>method="BLUP"</code> then this value will instead be used as a fixed plug-in value.</p>
</td></tr>
<tr><td><code id="fSAE.Unit_+3A_rel.int.tol">rel.int.tol</code></td>
<td>
<p>tolerance for the estimated relative integration error (default is 1 percent).
A warning is issued if the estimated relative error exceeds this value.</p>
</td></tr>
<tr><td><code id="fSAE.Unit_+3A_...">...</code></td>
<td>
<p>additional control parameters passed to function <code>integrate</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The default Hierarchical Bayes method uses numerical integration (as provided by function <code><a href="stats.html#topic+integrate">integrate</a></code>) to compute
small area estimates and MSEs. The model parameters returned, such as fixed and random effects, are currently not averaged over the
posterior distribution for the variance ratio. They are evaluated at the posterior mean of the variance ratio.
</p>


<h3>Value</h3>

<p>An object of class <code>sae</code> containing the small area estimates and MSEs, the model fit, and model selection measures.
</p>


<h3>References</h3>

<p>G.E. Battese, R.M. Harter and W.A. Fuller (1988).
An Error-Components Model for Prediction of County Crop Areas Using Survey and Satellite Data.
Journal of the American Statistical Association, 83(401), 28-36.
</p>
<p>G.S. Datta and M. Ghosh (1991). Bayesian Prediction in Linear Models: Applications to Small Area Estimation.
The Annals of Statistics 19(4), 1748-1770.
</p>
<p>J.N.K. Rao and I. Molina (2015). Small Area Estimation. Wiley.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sae-class">sae-class</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>d &lt;- generateFakeData()

# generate design matrix, variable of interest, area indicator and population data
dat &lt;- fSAE(y0 ~ x + area2, data=d$sam, area="area", popdata=d$Xpop,
            type="data")

# compute small area estimates based on the basic unit-level model
sae &lt;- fSAE.Unit(dat$y, dat$X, dat$area, dat$Narea, dat$PopMeans)
EST(sae)  # estimates
RMSE(sae)  # standard errors
</code></pre>

<hr>
<h2 id='fSurvReg'>Compute small area estimates based on the survey regression estimator.</h2><span id='topic+fSurvReg'></span>

<h3>Description</h3>

<p>This function computes survey regression estimates as a special case of unit-level model small area estimates with a (relatively) very large value for the between-area variance
but without including area effects in the model fit. The model assumes a single overall variance parameter, so that the resulting estimated variances are not area-specific but smoothed.
Varying inclusion probabilities may be taken into account by including them in the model, e.g. as an additional covariate,
and/or as model variance structure by specifying arguments v and vpop, see <code><a href="#topic+fSAE.Unit">fSAE.Unit</a></code>. The resulting estimates may be used as input estimates for area-level model small area estimation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fSurvReg(y, X, area, Narea, Xpop, removeEmpty = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fSurvReg_+3A_y">y</code></td>
<td>
<p>response vector of length n.</p>
</td></tr>
<tr><td><code id="fSurvReg_+3A_x">X</code></td>
<td>
<p>n x p model matrix.</p>
</td></tr>
<tr><td><code id="fSurvReg_+3A_area">area</code></td>
<td>
<p>n-vector of area codes, typically a factor variable with m levels, where m is the number of in-sample areas.</p>
</td></tr>
<tr><td><code id="fSurvReg_+3A_narea">Narea</code></td>
<td>
<p>M-vector of area population sizes.</p>
</td></tr>
<tr><td><code id="fSurvReg_+3A_xpop">Xpop</code></td>
<td>
<p>M x p matrix of population means.</p>
</td></tr>
<tr><td><code id="fSurvReg_+3A_removeempty">removeEmpty</code></td>
<td>
<p>whether out-of-sample areas should be removed from the results. If <code>FALSE</code> these areas are retained in the vectors of estimates,
but they will have (relatively) very large standard errors.</p>
</td></tr>
<tr><td><code id="fSurvReg_+3A_...">...</code></td>
<td>
<p>optional arguments v and vpop passed to <code><a href="#topic+fSAE.Unit">fSAE.Unit</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>sae</code> containing the survey regression small area estimates and their estimated variances.
</p>


<h3>References</h3>

<p>G.E. Battese, R.M. Harter and W.A. Fuller (1988).
An Error-Components Model for Prediction of County Crop Areas Using Survey and Satellite Data.
Journal of the American Statistical Association, 83(401), 28-36.
</p>
<p>J.N.K. Rao and I. Molina (2015). Small Area Estimation. Wiley.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sae-class">sae-class</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>d &lt;- generateFakeData()

# generate design matrix, variable of interest, area indicator and population data
dat &lt;- fSAE(y0 ~ x + area2, data=d$sam, area="area", popdata=d$Xpop,
            type="data")

sae &lt;- fSurvReg(dat$y, dat$X, dat$area, dat$Narea, dat$PopMeans)
EST(sae)  # estimates
RMSE(sae)  # standard errors
</code></pre>

<hr>
<h2 id='generateFakeData'>Generate artificial dataset for demonstration and testing purposes.</h2><span id='topic+generateFakeData'></span>

<h3>Description</h3>

<p>Generate artificial dataset for demonstration and testing purposes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generateFakeData(
  M = 50,
  meanNarea = 1000,
  sW = 100,
  sB = 50,
  sBx = 0.5,
  samplingFraction = 0.1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generateFakeData_+3A_m">M</code></td>
<td>
<p>number of areas.</p>
</td></tr>
<tr><td><code id="generateFakeData_+3A_meannarea">meanNarea</code></td>
<td>
<p>mean number of population units per area.</p>
</td></tr>
<tr><td><code id="generateFakeData_+3A_sw">sW</code></td>
<td>
<p>within area standard deviation.</p>
</td></tr>
<tr><td><code id="generateFakeData_+3A_sb">sB</code></td>
<td>
<p>between area standard deviation.</p>
</td></tr>
<tr><td><code id="generateFakeData_+3A_sbx">sBx</code></td>
<td>
<p>random slope standard deviation.</p>
</td></tr>
<tr><td><code id="generateFakeData_+3A_samplingfraction">samplingFraction</code></td>
<td>
<p>sampling fraction used to draw a random sample from the population units.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List containing sample (sam), population totals (Xpop), and true population means for four
target variables (mY0, mY1, mY2, mY3).
</p>

<hr>
<h2 id='plot.sae'>Plot method for objects of class sae.</h2><span id='topic+plot.sae'></span>

<h3>Description</h3>

<p>This function plots small area estimates with error bars.
Multiple sets of estimates can be compared. The default ordering of the estimates
is by their area population sizes.
This method uses a plot function that is adapted from function
<code>coefplot.default</code> of package <span class="pkg">arm</span>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sae'
plot(
  ...,
  n.se = 1,
  est.names,
  sort.by = NULL,
  decreasing = FALSE,
  index = NULL,
  maxrows = 50L,
  maxcols = 6L,
  type = "sae",
  offset = 0.1,
  cex.var = 0.8,
  mar = c(0.1, 2.1, 5.1, 0.1)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.sae_+3A_...">...</code></td>
<td>
<p><code>sae</code> objects, <code>dc_summary</code> objects (output by the <code>summary</code> method for
simulation objects of package <span class="pkg">mcmcsae</span>), or lists.
The first object must be a <code>sae</code> object.
In case of a list the components
used are those with name <code>est</code> for point estimates, <code>se</code>
for standard error based intervals or <code>lower</code> and <code>upper</code> for
custom intervals. Instead of <code>dc_summary</code> objects matrix objects are
also supported as long as they contain columns named &quot;Mean&quot; and &quot;SD&quot; as do
<code>dc_summary</code> objects. Named parameters of other types that do not match any
other argument names are passed to lower-level plot functions.</p>
</td></tr>
<tr><td><code id="plot.sae_+3A_n.se">n.se</code></td>
<td>
<p>number of standard errors below and above the point estimates
to use for error bars. By default equal to 1. This only refers to the
objects of class <code>dc_summary</code> and <code>sae</code>.</p>
</td></tr>
<tr><td><code id="plot.sae_+3A_est.names">est.names</code></td>
<td>
<p>labels to use in the legend for the components of the <code>...</code> argument</p>
</td></tr>
<tr><td><code id="plot.sae_+3A_sort.by">sort.by</code></td>
<td>
<p>vector by which to sort the coefficients, referring to the first object passed.</p>
</td></tr>
<tr><td><code id="plot.sae_+3A_decreasing">decreasing</code></td>
<td>
<p>if <code>TRUE</code>, sort in decreasing order (default).</p>
</td></tr>
<tr><td><code id="plot.sae_+3A_index">index</code></td>
<td>
<p>vector of names or indices of the selected areas to be plotted.</p>
</td></tr>
<tr><td><code id="plot.sae_+3A_maxrows">maxrows</code></td>
<td>
<p>maximum number of rows in a column.</p>
</td></tr>
<tr><td><code id="plot.sae_+3A_maxcols">maxcols</code></td>
<td>
<p>maximum number of columns of estimates on a page.</p>
</td></tr>
<tr><td><code id="plot.sae_+3A_type">type</code></td>
<td>
<p>&quot;sae&quot; for small area estimates (default), &quot;coef&quot; for
coefficients, &quot;raneff&quot; for random effects.</p>
</td></tr>
<tr><td><code id="plot.sae_+3A_offset">offset</code></td>
<td>
<p>space used between plots of multiple estimates for the same
area.</p>
</td></tr>
<tr><td><code id="plot.sae_+3A_cex.var">cex.var</code></td>
<td>
<p>the fontsize of the variable names, default=0.8.</p>
</td></tr>
<tr><td><code id="plot.sae_+3A_mar">mar</code></td>
<td>
<p>a numerical vector of the form c(bottom, left, top, right) which
gives the number of lines of margin to be specified on the four sides of
the plot.</p>
</td></tr>
</table>

<hr>
<h2 id='plot.weights'>Plot method for objects of class <code>weights</code>.</h2><span id='topic+plot.weights'></span>

<h3>Description</h3>

<p>Plot method for objects of class <code>weights</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'weights'
plot(
  x,
  log = FALSE,
  breaks = "Scott",
  main = "Distribution of weights",
  xlab = if (log) "log(weight)" else "weight",
  ylab = "frequency",
  col = "cyan",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.weights_+3A_x">x</code></td>
<td>
<p>object of class <code>weights</code> as returned by function <code><a href="#topic+uweights">uweights</a></code>.</p>
</td></tr>
<tr><td><code id="plot.weights_+3A_log">log</code></td>
<td>
<p>whether to log-transform the weights.</p>
</td></tr>
<tr><td><code id="plot.weights_+3A_breaks">breaks</code></td>
<td>
<p>breaks argument of function <code><a href="graphics.html#topic+hist">hist</a></code>. Default is &quot;Scott&quot;.</p>
</td></tr>
<tr><td><code id="plot.weights_+3A_main">main</code></td>
<td>
<p>main title of plot.</p>
</td></tr>
<tr><td><code id="plot.weights_+3A_xlab">xlab</code></td>
<td>
<p>x-axis label.</p>
</td></tr>
<tr><td><code id="plot.weights_+3A_ylab">ylab</code></td>
<td>
<p>y-axis label.</p>
</td></tr>
<tr><td><code id="plot.weights_+3A_col">col</code></td>
<td>
<p>colour.</p>
</td></tr>
<tr><td><code id="plot.weights_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code><a href="graphics.html#topic+hist">hist</a></code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+uweights">uweights</a></code>, <code><a href="#topic+summary.weights">summary.weights</a></code>
</p>

<hr>
<h2 id='print.sae'>Print method for objects of class sae.</h2><span id='topic+print.sae'></span>

<h3>Description</h3>

<p>Print method for objects of class sae.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sae'
print(x, digits = max(3L, getOption("digits") - 3L), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.sae_+3A_x">x</code></td>
<td>
<p>object of class <code>sae</code>.</p>
</td></tr>
<tr><td><code id="print.sae_+3A_digits">digits</code></td>
<td>
<p>number of digits to display.</p>
</td></tr>
<tr><td><code id="print.sae_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code>print.default</code>.</p>
</td></tr>
</table>

<hr>
<h2 id='sae-class'>S3 class for the fitted model and SAE outcomes.</h2><span id='topic+sae-class'></span><span id='topic+EST'></span><span id='topic+MSE'></span><span id='topic+SE'></span><span id='topic+RMSE'></span><span id='topic+COV'></span><span id='topic+COR'></span><span id='topic+relSE'></span><span id='topic+coef.sae'></span><span id='topic+vcov.sae'></span><span id='topic+raneff'></span><span id='topic+raneff.se'></span><span id='topic+residuals.sae'></span><span id='topic+fitted.sae'></span><span id='topic+se2'></span><span id='topic+sv2'></span><span id='topic+wDirect'></span><span id='topic+synthetic'></span><span id='topic+CV'></span><span id='topic+cAIC'></span><span id='topic+R2'></span>

<h3>Description</h3>

<p>Functions <code><a href="#topic+fSAE">fSAE</a></code>, <code><a href="#topic+fSurvReg">fSurvReg</a></code>, <code><a href="#topic+fSAE.Area">fSAE.Area</a></code> and <code><a href="#topic+fSAE.Unit">fSAE.Unit</a></code>
return an object of class <code>sae</code>. It contains information on the model fit as well as the
small area estimates, error estimates and a few model selection measures.
The functions listed below extract the main components from an object of class <code>sae</code>.
</p>

<dl>
<dt><code>EST(x, type="sae", tot=FALSE)</code></dt><dd><p>return the vector of small area estimates of <code>sae</code> object x. Alternatively,
with <code>type</code> &quot;coef&quot; or &quot;raneff&quot; fixed or random effect estimates are returned. If 'tot=TRUE' and 'type=&quot;sae&quot;' estimates
for area population totals instead of means are returned.</p>
</dd>
<dt><code>MSE(x, type="sae", tot=FALSE)</code></dt><dd><p>return the vector of mean squared errors of <code>sae</code> object x. Alternatively,
with <code>type</code> &quot;coef&quot; or &quot;raneff&quot; MSEs of fixed or random effects are returned. If 'tot=TRUE' and 'type=&quot;sae&quot;' MSEs
for area population totals instead of means are returned.</p>
</dd>
<dt><code>SE(x, type="sae", tot=FALSE)</code></dt><dd><p>extract standard errors, i.e. square roots of MSEs.</p>
</dd>
<dt><code>RMSE(x, type="sae", tot=FALSE)</code></dt><dd><p>alias for SE(x, type=&quot;sae&quot;, tot=FALSE)</p>
</dd>
<dt><code>relSE(x, type="sae")</code></dt><dd><p>extract relative standard errors.</p>
</dd>
<dt><code>COV(x)</code></dt><dd><p>extract the covariance matrix for the small area estimates.</p>
</dd>
<dt><code>COR(x)</code></dt><dd><p>extract the correlation matrix for the small area estimates.</p>
</dd>
<dt><code>coef(x)</code></dt><dd><p><code>coef</code> method for <code>sae</code> objects; returns vector of fixed effects.</p>
</dd>
<dt><code>vcov(x)</code></dt><dd><p><code>vcov</code> method for <code>sae</code> objects; returns covariance matrix for fixed effects.</p>
</dd>
<dt><code>raneff(x, pop)</code></dt><dd><p>return vector of random effects. If <code>pop=TRUE</code> returns a vector for predicted areas (zero for out-of-sample areas), otherwise a vector for in-sample areas.</p>
</dd>
<dt><code>raneff.se(x, pop)</code></dt><dd><p>return vector of standard errors for random effects.</p>
</dd>
<dt><code>residuals(x)</code></dt><dd><p><code>residuals</code> method for <code>sae</code> objects; returns a vector of residuals.</p>
</dd>
<dt><code>fitted(x)</code></dt><dd><p><code>fitted</code> method for <code>sae</code> objects; returns a vector of fitted values.</p>
</dd>
<dt><code>se2(x)</code></dt><dd><p>extracts within-area variance estimate.</p>
</dd>
<dt><code>sv2(x)</code></dt><dd><p>extracts between-area variance estimate.</p>
</dd>
<dt><code>wDirect(x, pop)</code></dt><dd><p>extract vector of weights of the survey regression components in the small area estimates. If <code>pop=TRUE</code> returns a vector for predicted areas (zero for out-of-sample areas), otherwise a vector for in-sample areas.</p>
</dd>
<dt><code>synthetic(x)</code></dt><dd><p>extract vector of synthetic estimates.</p>
</dd>
<dt><code>CV(x)</code></dt><dd><p>extract leave-one-out cross-validation measure.</p>
</dd>
<dt><code>cAIC(x)</code></dt><dd><p>extract conditional AIC measure.</p>
</dd>
<dt><code>R2(x)</code></dt><dd><p>extract unit-level R-squared goodness-of-fit measure.</p>
</dd>
</dl>

<p>Other components include
</p>

<dl>
<dt><code>relErrM,relErrV</code></dt><dd><p>relative numerical integration errors in estimates and MSEs, for <code>method</code> &quot;HB&quot;.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>d &lt;- generateFakeData()

# compute small area estimates
sae &lt;- fSAE(y0 ~ x + area2, data=d$sam, area="area", popdata=d$Xpop)

coef(sae)  # fixed effects
raneff(sae)  # random effects
sv2(sae)  # between-area variance
se2(sae)  # within-area variance
cAIC(sae)  # conditional AIC
</code></pre>

<hr>
<h2 id='summary.weights'>Summary method for objects of class <code>weights</code>.</h2><span id='topic+summary.weights'></span>

<h3>Description</h3>

<p>Summary method for objects of class <code>weights</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'weights'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.weights_+3A_object">object</code></td>
<td>
<p>object of class <code>weights</code> as returned by function <code><a href="#topic+uweights">uweights</a></code>.</p>
</td></tr>
<tr><td><code id="summary.weights_+3A_...">...</code></td>
<td>
<p>not used.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+uweights">uweights</a></code>, <code><a href="#topic+plot.weights">plot.weights</a></code>
</p>

<hr>
<h2 id='uweights'>Compute unit weights underlying the small area estimates or their aggregate.</h2><span id='topic+uweights'></span>

<h3>Description</h3>

<p>The small area estimates can be interpreted as weighted sums of the response variable. This function computes the weights
corresponding to the aggregated small area estimates or the weights corresponding to a specific small area estimate. The
weights applied to the response variable need not exactly reproduce the Hierarchical Bayes estimate since the latter
is averaged over the posterior distribution for the variance ratio whereas the weights are evaluated at the posterior mean.
Under the default prior for the fixed effects, the weights applied to the design matrix reproduce the corresponding population numbers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>uweights(x, areaID = NULL, forTotal = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="uweights_+3A_x">x</code></td>
<td>
<p>sae object.</p>
</td></tr>
<tr><td><code id="uweights_+3A_areaid">areaID</code></td>
<td>
<p>if left unspecified (<code>NULL</code>), weights corresponding to the overall (aggregated) estimate are returned.
Otherwise weights that reproduce the estimate for a specific area are returned.</p>
</td></tr>
<tr><td><code id="uweights_+3A_fortotal">forTotal</code></td>
<td>
<p>if <code>FALSE</code> weights will be divided by the corresponding population size.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>weights</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+summary.weights">summary.weights</a></code>, <code><a href="#topic+plot.weights">plot.weights</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>d &lt;- generateFakeData()

# compute small area estimates
sae &lt;- fSAE(y0 ~ x + area2, data=d$sam, area="area", popdata=d$Xpop,
            method="hybrid", keep.data=TRUE)

# compute unit weights
w &lt;- uweights(sae, forTotal=TRUE)
summary(w)  # summary statistics
plot(w)  # histogram of weights
# checks
all.equal(sum(w * sae$y), sum(EST(sae) * sae$Narea))
all.equal(colSums(w * as.matrix(sae$X)), colSums(sae$Xp * sae$Narea))
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
