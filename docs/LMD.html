<!DOCTYPE html><html><head><title>Help for package LMD</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {LMD}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#extract_product_function'><p>Extract Product Function</p></a></li>
<li><a href='#find_extrema'><p>Find Extreme Points</p></a></li>
<li><a href='#is_monotonous'><p>Monotonicity Check</p></a></li>
<li><a href='#lmd'><p>Local Mean Decomposition</p></a></li>
<li><a href='#local_mean_and_envelope'><p>Local Mean and Envelope</p></a></li>
<li><a href='#moving_average_smooth'><p>Weighted Moving Average</p></a></li>
<li><a href='#plot_lmd'><p>LMD Plot</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-09-10</td>
</tr>
<tr>
<td>Title:</td>
<td>A Self-Adaptive Approach for Demodulating Multi-Component Signal</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.0</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Shubhra Prakash &lt;shubhraprakash279@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Local Mean Decomposition is an iterative and self-adaptive approach for demodulating, processing, and analyzing multi-component amplitude modulated and frequency modulated signals. This R package is based on the approach suggested by Smith (2005) &lt;<a href="https://doi.org/10.1098%2Frsif.2005.0058">doi:10.1098/rsif.2005.0058</a>&gt; and the 'Python' library 'PyLMD'.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.apache.org/licenses/LICENSE-2.0">Apache License (&ge; 2)</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.6.0)</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/shubhra-opensource/LMD/issues">https://github.com/shubhra-opensource/LMD/issues</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/shubhra-opensource/LMD">https://github.com/shubhra-opensource/LMD</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.1</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, ggformula, testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Imports:</td>
<td>EMD, ggplot2, patchwork</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-09-20 02:27:01 UTC; shubh</td>
</tr>
<tr>
<td>Author:</td>
<td>Shubhra Prakash [trl, aut, cre]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-09-20 09:56:07 UTC</td>
</tr>
</table>
<hr>
<h2 id='extract_product_function'>Extract Product Function</h2><span id='topic+extract_product_function'></span>

<h3>Description</h3>

<p>Method for extracting product functions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract_product_function(
  signal,
  max_envelope_iteration = 200,
  envelope_epsilon = 0.01,
  convergence_epsilon = 0.01
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extract_product_function_+3A_signal">signal</code></td>
<td>
<p>Signal values (Numeric | vector)</p>
</td></tr>
<tr><td><code id="extract_product_function_+3A_max_envelope_iteration">max_envelope_iteration</code></td>
<td>
<p>Maximum number of iterations when separating local envelope signals (Integer)</p>
</td></tr>
<tr><td><code id="extract_product_function_+3A_envelope_epsilon">envelope_epsilon</code></td>
<td>
<p>Terminate processing when obtaining pure FM signal (Double)</p>
</td></tr>
<tr><td><code id="extract_product_function_+3A_convergence_epsilon">convergence_epsilon</code></td>
<td>
<p>Terminate processing when modulation signal converges (Double)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Product Function
</p>


<h3>Author(s)</h3>

<p>Shubhra Prakash, <a href="mailto:shubhraprakash279@gmail.com">shubhraprakash279@gmail.com</a>
</p>


<h3>References</h3>

<p><a href="https://pypi.org/project/PyLMD/">https://pypi.org/project/PyLMD/</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x=1:100
y = (2 / 3 )* sin(x * 30) + (2 / 3) * sin(x * 17.5) + (4 / 5) *cos(x * 2)
plot(y,type="l")
pf=extract_product_function(y)
</code></pre>

<hr>
<h2 id='find_extrema'>Find Extreme Points</h2><span id='topic+find_extrema'></span>

<h3>Description</h3>

<p>Method for finding Extreme Points
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find_extrema(signal, include_endpoints = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="find_extrema_+3A_signal">signal</code></td>
<td>
<p>Signal values (Numeric | vector)</p>
</td></tr>
<tr><td><code id="find_extrema_+3A_include_endpoints">include_endpoints</code></td>
<td>
<p>whether to include end points or not (Boolean)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A local extrema is the point at which a maximum or minimum value of the function in some open interval containing the point is obtained.
</p>


<h3>Value</h3>

<p>Indexes of all extrema values (including starting and ending points)
</p>


<h3>Author(s)</h3>

<p>Shubhra Prakash, <a href="mailto:shubhraprakash279@gmail.com">shubhraprakash279@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>signal=c( 0.841471 ,0.9092974,0.14112,-0.7568025,-0.9589243)
find_extrema(signal)
</code></pre>

<hr>
<h2 id='is_monotonous'>Monotonicity Check</h2><span id='topic+is_monotonous'></span>

<h3>Description</h3>

<p>Method for checking if signal is increasing or decreasing monotonously
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_monotonous(signal)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_monotonous_+3A_signal">signal</code></td>
<td>
<p>Signal values (Numeric | vector)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A monotonic signal is a function that keeps increasing or decreasing as its domain variable proceeds.#'
</p>


<h3>Value</h3>

<p>Boolean
</p>


<h3>Author(s)</h3>

<p>Shubhra Prakash, <a href="mailto:shubhraprakash279@gmail.com">shubhraprakash279@gmail.com</a>
</p>


<h3>References</h3>

<p><a href="https://pypi.org/project/PyLMD/">https://pypi.org/project/PyLMD/</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x=1:100
is_monotonous(x)
</code></pre>

<hr>
<h2 id='lmd'>Local Mean Decomposition</h2><span id='topic+lmd'></span>

<h3>Description</h3>

<p>Method for finding Product Functions (PFs)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lmd(
  signal,
  include_endpoints = TRUE,
  max_smooth_iteration = 12,
  max_envelope_iteration = 200,
  envelope_epsilon = 0.01,
  convergence_epsilon = 0.01,
  max_num_pf = 8
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lmd_+3A_signal">signal</code></td>
<td>
<p>Signal values (Numeric | vector)</p>
</td></tr>
<tr><td><code id="lmd_+3A_include_endpoints">include_endpoints</code></td>
<td>
<p>Whether to treat the endpoint of the signal as a pseudo-extreme point (Boolean)</p>
</td></tr>
<tr><td><code id="lmd_+3A_max_smooth_iteration">max_smooth_iteration</code></td>
<td>
<p>Maximum number of iterations of moving average algorithm (Integer)</p>
</td></tr>
<tr><td><code id="lmd_+3A_max_envelope_iteration">max_envelope_iteration</code></td>
<td>
<p>Maximum number of iterations when separating local envelope signals (Integer)</p>
</td></tr>
<tr><td><code id="lmd_+3A_envelope_epsilon">envelope_epsilon</code></td>
<td>
<p>Terminate processing when obtaining pure FM signal (Double)</p>
</td></tr>
<tr><td><code id="lmd_+3A_convergence_epsilon">convergence_epsilon</code></td>
<td>
<p>Terminate processing when modulation signal converges (Double)</p>
</td></tr>
<tr><td><code id="lmd_+3A_max_num_pf">max_num_pf</code></td>
<td>
<p>The maximum number of PFs generated(Integer)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>LMD is a method of decomposing signal into Product Functions (PFs) based on algorithm presented in Jonathan S. Smith. The local mean decomposition and its application to EEG perception data. Journal of the Royal Society Interface, 2005, 2(5):443-454
</p>


<h3>Value</h3>

<p>list(pf,residue) | PFs:The decompose functions arranged from high frequency to low frequency | residue:residual component
</p>


<h3>Author(s)</h3>

<p>Shubhra Prakash, <a href="mailto:shubhraprakash279@gmail.com">shubhraprakash279@gmail.com</a>
</p>


<h3>References</h3>

<p><a href="https://pypi.org/project/PyLMD/">https://pypi.org/project/PyLMD/</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x=1:100
y = (2 / 3 )* sin(x * 30) + (2 / 3) * sin(x * 17.5) + (4 / 5) *cos(x * 2)
plot(y,type="l")
lmd(y)
</code></pre>

<hr>
<h2 id='local_mean_and_envelope'>Local Mean and Envelope</h2><span id='topic+local_mean_and_envelope'></span>

<h3>Description</h3>

<p>Method for finding Local Mean and Envelope
</p>


<h3>Usage</h3>

<pre><code class='language-R'>local_mean_and_envelope(signal, extrema)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="local_mean_and_envelope_+3A_signal">signal</code></td>
<td>
<p>Signal values (Numeric | vector)</p>
</td></tr>
<tr><td><code id="local_mean_and_envelope_+3A_extrema">extrema</code></td>
<td>
<p>indexes for extreme values</p>
</td></tr>
</table>


<h3>Value</h3>

<p>mean, envelope and smoothed mean and envelope values
</p>


<h3>Author(s)</h3>

<p>Shubhra Prakash, <a href="mailto:shubhraprakash279@gmail.com">shubhraprakash279@gmail.com</a>
</p>


<h3>References</h3>

<p><a href="https://pypi.org/project/PyLMD/">https://pypi.org/project/PyLMD/</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>signal = sin(1:10)
extrema = c(1 , 2,  5,  8, 10)
local_mean_and_envelope(signal, extrema)
</code></pre>

<hr>
<h2 id='moving_average_smooth'>Weighted Moving Average</h2><span id='topic+moving_average_smooth'></span>

<h3>Description</h3>

<p>Weighted Moving Average Smoothing
</p>


<h3>Usage</h3>

<pre><code class='language-R'>moving_average_smooth(signal, window, max_smooth_iteration = 12)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="moving_average_smooth_+3A_signal">signal</code></td>
<td>
<p>Signal values (Numeric | vector)</p>
</td></tr>
<tr><td><code id="moving_average_smooth_+3A_window">window</code></td>
<td>
<p>filter weights for smoothing (Numeric | vector)</p>
</td></tr>
<tr><td><code id="moving_average_smooth_+3A_max_smooth_iteration">max_smooth_iteration</code></td>
<td>
<p>Maximum number of iterations of moving average algorithm (Integer)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Weighted Moving Average Smoothing is used to smooth en the mean and envelope signal
</p>


<h3>Value</h3>

<p>smooth signal
</p>


<h3>Author(s)</h3>

<p>Shubhra Prakash, <a href="mailto:shubhraprakash279@gmail.com">shubhraprakash279@gmail.com</a>
</p>


<h3>References</h3>

<p><a href="https://pypi.org/project/PyLMD/">https://pypi.org/project/PyLMD/</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x=0:100
y = (2 / 3 )* sin(x * 30) + (2 / 3) * sin(x * 17.5) + (4 / 5) *cos(x * 2)
plot(y,type="l")
wma=moving_average_smooth(y,5)
plot(wma,type="l")
</code></pre>

<hr>
<h2 id='plot_lmd'>LMD Plot</h2><span id='topic+plot_lmd'></span>

<h3>Description</h3>

<p>Method for plotting Product Functions (PFs) and Residue
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_lmd(
  lmd_obj,
  max_pf = length(lmd_obj[["pf"]]),
  show_residue = TRUE,
  pricolor_plot = "midnightblue",
  line_size_plot = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_lmd_+3A_lmd_obj">lmd_obj</code></td>
<td>
<p>LMD object created from LMD function</p>
</td></tr>
<tr><td><code id="plot_lmd_+3A_max_pf">max_pf</code></td>
<td>
<p>Number of PFs to Plot</p>
</td></tr>
<tr><td><code id="plot_lmd_+3A_show_residue">show_residue</code></td>
<td>
<p>Whether to plot residue or not</p>
</td></tr>
<tr><td><code id="plot_lmd_+3A_pricolor_plot">pricolor_plot</code></td>
<td>
<p>color of plots</p>
</td></tr>
<tr><td><code id="plot_lmd_+3A_line_size_plot">line_size_plot</code></td>
<td>
<p>Size of line in ggplot</p>
</td></tr>
</table>


<h3>Value</h3>

<p>ggplot plot for Product Functions (PFs) and Residue
</p>


<h3>Author(s)</h3>

<p>Shubhra Prakash, <a href="mailto:shubhraprakash279@gmail.com">shubhraprakash279@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x=1:100
y = (2 / 3 )* sin(x * 30) + (2 / 3) * sin(x * 17.5) + (4 / 5) *cos(x * 2)
plot_lmd(lmd(y))
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
