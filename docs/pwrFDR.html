<!DOCTYPE html><html lang="en"><head><title>Help for package pwrFDR</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {pwrFDR}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#+25over+25'>
<p>Division operator with divide by zero clobbering</p></a></li>
<li><a href='#arg.vals'>
<p>Extracts the full argument list and call attribute.</p></a></li>
<li><a href='#backsolve.seFDPoalpha'>
<p>Find missing argument giving required se[FDP]/alpha (or se[TPP]/average.power)</p></a></li>
<li><a href='#basic.tmPrint'>
<p>Wrapper to Print a Basic Nicely Formatted Table</p></a></li>
<li><a href='#cc.ROC'>
<p>Computes the optimal number of controls per case in hypothesis tests</p>
involving the ROC. Included here with the intent that it can be
used in conjunction with <code>pwrFDR</code> to allow power/sample
size calculation for multiple tests of ROC curve based hypothesis.
See details.</a></li>
<li><a href='#cCDF.Rom'>
<p>Computes the complimentary CDF for the significant call proportion, R_m/m.</p></a></li>
<li><a href='#cCDF.ToM'>
<p>Computes the complimentary CDF for the true positive proportion, T_m/M_m.</p></a></li>
<li><a href='#cCDF.VoR'>
<p>Computes the complimentary CDF for the false discovery proportion, V_m/R_m.</p></a></li>
<li><a href='#CDF.Pval'>
<p>CDF of pooled (H0 and HA) population p-values</p></a></li>
<li><a href='#CDF.Pval.apsi.eq.u'>
<p>Calculates the fixed point for the Romano procedure.</p></a></li>
<li><a href='#CDF.Pval.au.eq.u'>
<p>Function which solves the implicit equation u = G( u alpha)</p></a></li>
<li><a href='#CDF.Pval.HA'>
<p>CDF of p-values for test statistics distribted under HA.</p></a></li>
<li><a href='#controlFDP'>
<p>Helper function for the BHFDX FDP control method</p></a></li>
<li><a href='#criterion'>
<p>BH-FDR and Romano Criterion</p></a></li>
<li><a href='#detail'>
<p>The detail extraction function for simulated power objects</p></a></li>
<li><a href='#dists'>
<p>The Distribution family object</p></a></li>
<li><a href='#es.ROC'>
<p>Computes the equivalent Z-test effect size in hypothesis tests</p>
involving the ROC. Included here with the intent that it can be
used in conjunction with <code>pwrFDR</code> to allow power/sample
size calculation for multiple tests of ROC curve based hypothesis.
See details.</a></li>
<li><a href='#gentempfilenm'>
<p>Generate a tempfile name</p></a></li>
<li><a href='#if.0.rm'>
<p>A helper function&ndash; remove if zero.</p></a></li>
<li><a href='#if.na.x'>
<p>A helper function &ndash; substitute 'NA's with a specified 'x'.</p></a></li>
<li><a href='#if.y.z'>
<p>A helper function &ndash; substitute <code>y</code>'s with a specified 'z'.</p>
</p></a></li>
<li><a href='#join.tbl'>
<p>Combine pwrFDR Results</p></a></li>
<li><a href='#logit'>
<p>Computes the logit transform</p></a></li>
<li><a href='#logitInv'>
<p>Computes the inverse logit transform</p></a></li>
<li><a href='#nna'>
<p>A helper function&ndash; turns a missing column into 'NA's inside of a with statement</p></a></li>
<li><a href='#paste'><p>The paste operator</p></a></li>
<li><a href='#pwrFDR'>
<p>Ensemble power or sample size under selected control of the FDP</p></a></li>
<li><a href='#pwrFDR.grid'>
<p>Evaluate <code>pwrFDR</code> on a grid.</p></a></li>
<li><a href='#sd.rtm.Rom'>
<p>Extractor function for asymptotic sd[R_m/m] under selected FDP control method</p></a></li>
<li><a href='#sd.rtm.ToM'>
<p>Extractor function for asymptotic sd[T_m/M_m] under selected FDP control method</p></a></li>
<li><a href='#sd.rtm.VoR'>
<p>Extractor function for asymptotic sd[V_m/R_m] under selected FDP control method</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Version:</td>
<td>3.2.4</td>
</tr>
<tr>
<td>Title:</td>
<td>FDR Power</td>
</tr>
<tr>
<td>Imports:</td>
<td>flextable, ggplot2, methods, mvtnorm, stats, stringr,
TableMonster</td>
</tr>
<tr>
<td>Description:</td>
<td>Computing Average and TPX Power under various BHFDR type sequential
    procedures. All of these procedures involve control of some summary of the
    distribution of the FDP, e.g. the proportion of discoveries which are false
    in a given experiment. The most widely known of these, the BH-FDR procedure,
    controls the FDR which is the mean of the FDP. A lesser known procedure, due
    to Lehmann and Romano, controls the FDX, or probability that the FDP exceeds
    a user provided threshold. This is less conservative than FWE control
    procedures but much more conservative than the BH-FDR proceudre. This
    package and the references supporting it introduce a new procedure for
    controlling the FDX which we call the BH-FDX procedure. This procedure
    iteratively identifies, given alpha and lower threshold delta, an alpha*
    less than alpha at which BH-FDR guarantees FDX control.  This uses
    asymptotic approximation and is only slightly more conservative than the
    BH-FDR procedure. Likewise, we can think of the power in multiple testing
    experiments in terms of a summary of the distribution of the True Positive
    Proportion (TPP), the portion of tests truly non-null distributed that are
    called significant. The package will compute power, sample size or any other
    missing parameter required for power defined as (i) the mean of the TPP
    (average power) or (ii) the probability that the TPP exceeds a given value,
    lambda, (TPX power) via asymptotic approximation. All supplied theoretical
    results are also obtainable via simulation. The suggested approach is to
    narrow in on a design via the theoretical approaches and then make final
    adjustments/verify the results by simulation. The theoretical results are
    described in Izmirlian, G (2020) Statistics and Probability letters,
    "&lt;<a href="https://doi.org/10.1016%2Fj.spl.2020.108713">doi:10.1016/j.spl.2020.108713</a>&gt;", and an applied paper describing the
    methodology with a simulation study is in preparation.
    See citation("pwrFDR").</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-01-14 05:06:47 UTC; izmirlig</td>
</tr>
<tr>
<td>Author:</td>
<td>Grant Izmirlian [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Grant Izmirlian &lt;izmirlig@mail.nih.gov&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-01-14 17:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='+25over+25'>
Division operator with divide by zero clobbering
</h2><span id='topic++25over+25'></span>

<h3>Description</h3>

<p>x %over% y = x/y when y!=0, equals 0 when y==0.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  x %over% y
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="+2B25over+2B25_+3A_x">x</code>, <code id="+2B25over+2B25_+3A_y">y</code></td>
<td>

<p>Numeric or complex vectors or objects that can be coerced to such.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>x/y when y!=0, otherwise 0.
</p>


<h3>Author(s)</h3>

<p>Grant Izmirlian izmirlig at mail dot nih dot gov
</p>

<hr>
<h2 id='arg.vals'>
Extracts the full argument list and call attribute.
</h2><span id='topic+arg.vals'></span>

<h3>Description</h3>

<p>Extracts the full argument list and call attribute from
an object of class <code>pwr</code>, which is the result of a
call to <code>pwrFDR</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  arg.vals(object)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="arg.vals_+3A_object">object</code></td>
<td>

<p>An object of class 'pwr', which is the result of a call to <code>pwrFDR</code>
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with a <code>call</code> component and one component for each of the
possible arguments, <code>effect.size</code>, <code>n.sample</code>,<code>r.1</code>,
<code>alpha</code>, <code>N.tests</code>, <code>lambda</code>, <code>FDP.control.method</code>,
<code>delta</code>, <code>groups</code>, <code>type</code>, <code>grpj.per.grp1</code>,
<code>method</code> and <code>control</code>, with defaults filled in. 
</p>


<h3>Author(s)</h3>

<p>Grant Izmirlian &lt;izmirlian at nih dot gov&gt;
</p>


<h3>References</h3>

<p>Izmirlian G. (2020) Strong consistency and asymptotic normality for
quantities related to the Benjamini-Hochberg false discovery rate
procedure. Statistics and Probability Letters; 108713,
&lt;doi:10.1016/j.spl.2020.108713&gt;.
</p>
<p>Izmirlian G. (2017) Average Power and <code class="reqn">\lambda</code>-power in
Multiple Testing Scenarios when the Benjamini-Hochberg False
Discovery Rate Procedure is Used. &lt;arXiv:1801.03989&gt;
</p>
<p>Jung S-H. (2005) Sample size for FDR-control in microarray data
analysis. Bioinformatics; 21:3097-3104.
</p>
<p>Liu P. and Hwang J-T. G. (2007) Quick calculation for sample size while
controlling false discovery rate with application to microarray
analysis. Bioinformatics; 23:739-746.
</p>
<p>Lehmann E. L., Romano J. P.. Generalizations of the familywise error
rate. Ann. Stat.. 2005;33(3):1138-1154.
</p>
<p>Romano Joseph P., Shaikh Azeem M.. Stepup procedures for control of
generalizations of the familywise error rate. Ann. Stat..
2006;34(4):1850-1873. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   rslt &lt;- pwrFDR(effect.size = 0.79, n.sample = 46, r.1 = 2000/54675, alpha = 0.15, 
                  N.tests = 1000, FDP.control.method = "Auto")

   arg.vals(rslt)
</code></pre>

<hr>
<h2 id='backsolve.seFDPoalpha'>
Find missing argument giving required se[FDP]/alpha (or se[TPP]/average.power)
</h2><span id='topic+backsolve.seFDPoalpha'></span><span id='topic+backsolve.seTPPoavgpwr'></span>

<h3>Description</h3>

<p>backsolve.seFDPoalpha finds the missing argument, one of 'N.tests',
'r.1', 'n.sample' or 'effect size' giving the specified value of
se[FDP]/alpha under the BH-FDR procedure.
</p>
<p>backsolve.seTPPoavgpwr finds the missing argument, one of 'N.tests',
'r.1', 'n.sample' or 'effect size' giving the specified value of
se[TPP]/average.power under the BH-FDR procedure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>backsolve.seFDPoalpha(seFDPoalpha, effect.size, n.sample, r.1, alpha, groups = 2, N.tests,
                      type = "balanced", grpj.per.grp1 = 1, distopt = 1, rho, k.bs)

backsolve.seTPPoavgpwr(seTPPoavgpwr, effect.size, n.sample, r.1, alpha, groups = 2,
                       N.tests, type = "balanced", grpj.per.grp1 = 1, distopt = 1, rho,
                       k.bs)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="backsolve.seFDPoalpha_+3A_sefdpoalpha">seFDPoalpha</code></td>
<td>

<p>In backsolve.seFDPoalpha, the user specified value of se[FDP]/alpha
</p>
</td></tr>
<tr><td><code id="backsolve.seFDPoalpha_+3A_setppoavgpwr">seTPPoavgpwr</code></td>
<td>

<p>In backsolve.seTPPoavgpwr, the user specified value of se[TPP]/average.power
</p>
</td></tr>
<tr><td><code id="backsolve.seFDPoalpha_+3A_effect.size">effect.size</code></td>
<td>

<p>The effect size (mean over standard deviation) for test statistics 
having non-zero means. Assumed to be a constant (in magnitude) over
non-zero mean test statistics.
</p>
</td></tr>
<tr><td><code id="backsolve.seFDPoalpha_+3A_n.sample">n.sample</code></td>
<td>

<p>The number of experimental replicates. Required for calculation
of power
</p>
</td></tr>
<tr><td><code id="backsolve.seFDPoalpha_+3A_r.1">r.1</code></td>
<td>

<p>The proportion of simultaneous tests that are non-centrally located 
</p>
</td></tr>
<tr><td><code id="backsolve.seFDPoalpha_+3A_alpha">alpha</code></td>
<td>

<p>The false discovery rate (in the BH case) or the upper bound on the
probability that the FDP exceeds delta (BHFDX and Romano case)
</p>
</td></tr>
<tr><td><code id="backsolve.seFDPoalpha_+3A_groups">groups</code></td>
<td>

<p>The number of experimental groups to compare. Must be integral and
&gt;=1. The default value is 2.
</p>
</td></tr>
<tr><td><code id="backsolve.seFDPoalpha_+3A_n.tests">N.tests</code></td>
<td>

<p>The number of simultaneous hypothesis tests. 
</p>
</td></tr>
<tr><td><code id="backsolve.seFDPoalpha_+3A_type">type</code></td>
<td>

<p>A character string specifying, in the groups=2 case, whether the
test is 'paired', 'balanced', or 'unbalanced' and in the case when
groups &gt;=3, whether the test is 'balanced' or 'unbalanced'. The
default in all cases is 'balanced'. Left unspecified in the one
sample (groups=1) case. 
</p>
</td></tr>
<tr><td><code id="backsolve.seFDPoalpha_+3A_grpj.per.grp1">grpj.per.grp1</code></td>
<td>

<p>Required when <code>type</code>=&quot;unbalanced&quot;, specifies the group 0 to
group 1 ratio in the two group case, and in the case of 3 or more
groups, the group j to group 1 ratio, where group 1 is the group
with the largest effect under the alternative hypothesis. 
</p>
</td></tr>
<tr><td><code id="backsolve.seFDPoalpha_+3A_distopt">distopt</code></td>
<td>

<p>Test statistic distribution in among null and alternatively
distributed sub-populations. distopt=0 gives normal (2 groups),
distop=1 gives t- (2 groups) and distopt=2 gives F- (2+ groups)
</p>
</td></tr>
<tr><td><code id="backsolve.seFDPoalpha_+3A_rho">rho</code></td>
<td>

<p>This can be done under the assumption of tests that are correlated
identically in pair within blocks of given size.
</p>
</td></tr>
<tr><td><code id="backsolve.seFDPoalpha_+3A_k.bs">k.bs</code></td>
<td>

<p>When 'rho' is specified, the common block-size for correlated test
statistics. 
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector having components
</p>
<table role = "presentation">
<tr><td><code>&lt;missing argument&gt;</code></td>
<td>
<p>Value of missing argument giving required
se[FDP]/alpha (backsolve.seFDPoalpha) or se[TPP]/average.power
(backsolve.seTPPoavgpwr).</p>
</td></tr>
<tr><td><code>average.power</code></td>
<td>
<p>The average power at the given set of conditions</p>
</td></tr>
<tr><td><code>se.VoR/se.ToM</code></td>
<td>
<p>The standard error of the FDP
(backsolve.seFDPoalpha) or standard error of the TPP 
(backsolve.seTPPoavgpwr).</p>
</td></tr>
<tr><td><code>value</code></td>
<td>
<p>Value returned by the solver. Should be near zero if a
solution was found.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Grant Izmirlian Jr &lt;izmirlian at nih dot gov&gt;
</p>


<h3>References</h3>

<p>Izmirlian G. (2020) Strong consistency and asymptotic normality for
quantities related to the Benjamini-Hochberg false discovery rate
procedure. Statistics and Probability Letters; 108713,
&lt;doi:10.1016/j.spl.2020.108713&gt;
</p>
<p>Izmirlian G. (2017) Average Power and <code class="reqn">\lambda</code>-power in
Multiple Testing Scenarios when the Benjamini-Hochberg False
Discovery Rate Procedure is Used. &lt;arXiv:1801.03989&gt;
</p>
<p>Jung S-H. (2005) Sample size for FDR-control in microarray data
analysis. Bioinformatics; 21:3097-3104.
</p>
<p>Kluger D. M., Owen A. B. (2023) A central limit theorem for the
Benjamini-Hochberg false discovery proportion under a factor model.
Bernoulli; xx:xxx-xxx.
</p>
<p>Liu P. and Hwang J-T. G. (2007) Quick calculation for sample size while
controlling false discovery rate with application to microarray
analysis. Bioinformatics; 23:739-746.
</p>
<p>Lehmann E. L., Romano J. P.. Generalizations of the familywise error
rate. Ann. Stat.. 2005;33(3):1138-1154.
</p>
<p>Romano Joseph P., Shaikh Azeem M.. Stepup procedures for control of
generalizations of the familywise error rate. Ann. Stat..
2006;34(4):1850-1873. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>backsolve.seFDPoalpha(seFDPoalpha=0.50, n.sample=50, alpha=0.05, effect.size=0.8,
                      r.1=0.20)

backsolve.seTPPoavgpwr(seTPPoavgpwr=0.20, n.sample=30, alpha=0.05, effect.size=0.8,
                       r.1=0.20)
</code></pre>

<hr>
<h2 id='basic.tmPrint'>
Wrapper to Print a Basic Nicely Formatted Table
</h2><span id='topic+basic.tmPrint'></span>

<h3>Description</h3>

<p>Creates a generic call to print.TableMonster which in turn calls xtable
</p>


<h3>Usage</h3>

<pre><code class='language-R'>basic.tmPrint(x, special = NULL, simple = FALSE, dbg = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="basic.tmPrint_+3A_x">x</code></td>
<td>

<p>Any data.frame object. Here, the result of a call to pwrFDR.
</p>
</td></tr>
<tr><td><code id="basic.tmPrint_+3A_special">special</code></td>
<td>

<p>Special arguments to print.TableMonster. See package documentation.
</p>
</td></tr>
<tr><td><code id="basic.tmPrint_+3A_simple">simple</code></td>
<td>

<p>The simplest use case
</p>
</td></tr>
<tr><td><code id="basic.tmPrint_+3A_dbg">dbg</code></td>
<td>

<p>Set to a value &gt;= 1 for debugging
</p>
</td></tr>
<tr><td><code id="basic.tmPrint_+3A_...">...</code></td>
<td>

<p>Other arguments
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The value returned is an invisible version of the argument &lsquo;x&rsquo;.
</p>


<h3>Author(s)</h3>

<p>Grant Izmirlian
</p>

<hr>
<h2 id='cc.ROC'>
Computes the optimal number of controls per case in hypothesis tests
involving the ROC. Included here with the intent that it can be
used in conjunction with <code><a href="#topic+pwrFDR">pwrFDR</a></code> to allow power/sample
size calculation for multiple tests of ROC curve based hypothesis.
See details. 
</h2><span id='topic+cc.ROC'></span>

<h3>Description</h3>

<p>In hypothesis tests of TPR_1 vs TPR_0 at fixed FPR, or
FPR_1 vs FPR_0 at fixed TPR, this computes the optimal number
of controls per case. Required by <code><a href="#topic+es.ROC">es.ROC</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  cc.ROC(FPR0, FPR1 = NULL, TPR0, TPR1 = NULL, b = NULL)
  </code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cc.ROC_+3A_fpr0">FPR0</code></td>
<td>

<p>When the TPR is fixed, the FPR under the null. Otherwise the fixed FPR.
</p>
</td></tr>
<tr><td><code id="cc.ROC_+3A_fpr1">FPR1</code></td>
<td>

<p>When the TPR is fixed, the FPR under the alternative. Otherwise left blank.
</p>
</td></tr>
<tr><td><code id="cc.ROC_+3A_tpr0">TPR0</code></td>
<td>

<p>When the FPR is fixed, the TPR under the null. Otherwise the fixed TPR.
</p>
</td></tr>
<tr><td><code id="cc.ROC_+3A_tpr1">TPR1</code></td>
<td>

<p>When the FPR is fixed, the TPR under the alternative. Otherwise left blank.
</p>
</td></tr>
<tr><td><code id="cc.ROC_+3A_b">b</code></td>
<td>

<p>Nominal slope of the ROC at FPR0. Taken to be 1 by default.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The optimal number of controls per case.
</p>


<h3>Author(s)</h3>

<p>Grant Izmirlian &lt;izmirlian at nih dot gov&gt;
</p>


<h3>References</h3>

<p>Pepe M. S., Feng Z, Janes, H Bossuyt P. M. and Potter J. D. Pivotal
evaluation of the accuracy of a biomarker used for classification or
prediction. Supplement. J Natl Cancer Inst 2008;100: 1432&ndash;1438
</p>


<h3>See Also</h3>

<p><code><a href="#topic+es.ROC">es.ROC</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    cc.ROC(FPR0=0.15, TPR0=0.80, TPR1=0.90)
</code></pre>

<hr>
<h2 id='cCDF.Rom'>
Computes the complimentary CDF for the significant call proportion, R_m/m.
</h2><span id='topic+cCDF.Rom'></span>

<h3>Description</h3>

<p>Computes the complimentary CDF for the significant call proportion, R_m/m
via asymptotic approximation. Included here mainly for pedagogic purposes. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cCDF.Rom(u, effect.size, n.sample, r.1, alpha, delta, groups = 2, N.tests,
         type = c("paired", "balanced", "unbalanced"), grpj.per.grp1 = NULL,
         FDP.control.method = "BHFDR", distopt,
         control=list(tol=1e-08,max.iter=c(1000,20),sim.level=2,low.power.stop=TRUE,
                      FDP.meth.thresh=FDP.cntl.mth.thrsh.def,verb=FALSE)) 
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cCDF.Rom_+3A_u">u</code></td>
<td>

<p>A sorted vector of values on the interval [0, 1] for which the cCDF
of R_m/m should be computed.
</p>
</td></tr>
<tr><td><code id="cCDF.Rom_+3A_effect.size">effect.size</code></td>
<td>

<p>The effect size (mean over standard deviation) for test statistics 
having non-zero means. Assumed to be a constant (in magnitude) over
non-zero mean test statistics.
</p>
</td></tr>
<tr><td><code id="cCDF.Rom_+3A_n.sample">n.sample</code></td>
<td>

<p>The number of experimental replicates. Required for calculation
of power
</p>
</td></tr>
<tr><td><code id="cCDF.Rom_+3A_r.1">r.1</code></td>
<td>

<p>The proportion of simultaneous tests that are non-centrally located 
</p>
</td></tr>
<tr><td><code id="cCDF.Rom_+3A_alpha">alpha</code></td>
<td>

<p>The false discovery rate (in the BH case) or the upper bound on the
probability that the FDP exceeds delta (Romano case)
</p>
</td></tr>
<tr><td><code id="cCDF.Rom_+3A_delta">delta</code></td>
<td>

<p>If the &quot;FDP.control.method&quot; is set to 'Romano' or 'BHFDX', then the
user can set the exceedance thresh-hold for the FDP tail probability
control <code class="reqn">P\{ FDP &gt; \delta \} &lt; \alpha</code>. The default value is
<code class="reqn">\alpha</code>.
</p>
</td></tr>
<tr><td><code id="cCDF.Rom_+3A_groups">groups</code></td>
<td>

<p>The number of experimental groups to compare. Must be integral and
&gt;=1. The default value is 2.
</p>
</td></tr>
<tr><td><code id="cCDF.Rom_+3A_n.tests">N.tests</code></td>
<td>

<p>The number of simultaneous hypothesis tests. 
</p>
</td></tr>
<tr><td><code id="cCDF.Rom_+3A_type">type</code></td>
<td>

<p>A character string specifying, in the groups=2 case, whether the
test is 'paired', 'balanced', or 'unbalanced' and in the case when
groups &gt;=3, whether the test is 'balanced' or 'unbalanced'. The
default in all cases is 'balanced'. Left unspecified in the one
sample (groups=1) case. 
</p>
</td></tr>
<tr><td><code id="cCDF.Rom_+3A_grpj.per.grp1">grpj.per.grp1</code></td>
<td>

<p>Required when <code>type</code>=&quot;unbalanced&quot;, specifies the group 0 to
group 1 ratio in the two group case, and in the case of 3 or more
groups, the group j to group 1 ratio, where group 1 is the group
with the largest effect under the alternative hypothesis. 
</p>
</td></tr>
<tr><td><code id="cCDF.Rom_+3A_fdp.control.method">FDP.control.method</code></td>
<td>

<p>A character string specifying how the false discovery proportion (FDP) is to be
controlled. You may specify the whole word or any shortened uniquely
identifying truncation. <br />
&quot;BHFDR&quot;: the usual BH-FDR <br />
&quot;BHFDX&quot;: use asymptotic approximation to the distribution of the FDP 
to find a smaller FDR which guarantees probability less
than alpha that the FDP exceeds alpha. <br />
&quot;Romano&quot;: use Romano's method which guarantees probability less than 
alpha that the FDP exceeds alpha. <br />
&quot;Auto&quot;: in 'FixedPoint' mode, the program will use its own 
wisdom to determine which choice above to make. The 
order of conservatism is Romano &gt; BHFDX &gt; BHFDR, but 
BHFDR offers only expected control while the other two 
guarantee bounds on the excedance probabilty. If the 
distribution of the FDP is nearly degenerate, then BHFDR 
is the best option. Otherwise, if it can be reliably used, 
BHFDX would be the best choice. The 'effective' denominator, 
gamma*N.tests, in the CLT determines when the approximation 
is good enough and the asymptotic standard error of the FDP 
determines when the distribution is dispersed enough to matter.
Use &quot;Auto&quot; to run through these checks and determine the best. 
A return argument, 'Auto', displays the choice made. See 
output components and details. <br />
&quot;both&quot;: in 'simulation' mode, compute statistics R and T under BHFDX
and Romano (in addition to BHFDR). Corresponding
statistics are denoted R.st, T.st corresponding to BHFDX
control of the FDP, and R.R and T.R corresponding to
Romano control of the FDP. If sim.level is set to 2,
(default) the statistics R.st.ht and T.st.ht, which are
the number rejected and number true positives under BHFDX
where r_0 = 1-r_1, gamma, and alpha.star have been estimated 
from the P-value data and then alpha.star computed from
these.
</p>
</td></tr>
<tr><td><code id="cCDF.Rom_+3A_distopt">distopt</code></td>
<td>
<p>Test statistic distribution in among null and
alternatively distributed sub-populations.
distopt=0 gives normal (2 groups), distop=1 gives t- (2 groups)
and distopt=2 gives F- (2+ groups)
</p>
</td></tr>  
<tr><td><code id="cCDF.Rom_+3A_control">control</code></td>
<td>
<p>Optionally, a list with components with the following  
components: <br />
'tol' is a convergence criterion used in iterative 
methods which is set to 1e-8 by default.<br />
'max.iter' is an iteration limit, set to 20 for the iterated
function limit and 1000 for all others by default.<br />
'sim.level' sim level 2 (default) stipulates, when FDP.control.method
is set to &quot;BHFDX&quot;, or &quot;both&quot;, R.st.ht and T.st.ht are
computed in addition to R.st and T.st (see above). <br />
'low.power.stop' in simulation option, will result in an error message 
if the power computed via FixedPoint method is too low, which 
result in no solution for the BHFDX option. Default setting is TRUE. 
Set to FALSE to over-ride this behavior. <br />
'FDP.meth.thresh' fine-tunes the 'Auto' voodoo (see above). Leave 
this alone. <br />
'verb' vebosity level.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>cdf</code> which contains components
</p>
<table role = "presentation">
<tr><td><code>call</code></td>
<td>
<p>The call which produced the result
</p>
</td></tr>
<tr><td><code>cCDF.Rom</code></td>
<td>
<p>A data frame with columns <code>u</code> and <code>cCDF.Rom</code>
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Grant Izmirlian &lt;izmirlian at nih dot gov&gt;
</p>


<h3>References</h3>

<p>Izmirlian G. (2020) Strong consistency and asymptotic normality for
quantities related to the Benjamini-Hochberg false discovery rate
procedure. Statistics and Probability Letters; 108713,
&lt;doi:10.1016/j.spl.2020.108713&gt;.  
</p>
<p>Izmirlian G. (2017) Average Power and <code class="reqn">\lambda</code>-power in
Multiple Testing Scenarios when the Benjamini-Hochberg False
Discovery Rate Procedure is Used. &lt;arXiv:1801.03989&gt;
</p>
<p>Jung S-H. (2005) Sample size for FDR-control in microarray data
analysis. Bioinformatics; 21:3097-3104.
</p>
<p>Kluger D. M., Owen A. B. (2023) A central limit theorem for the
Benjamini-Hochberg false discovery proportion under a factor model.
Bernoulli; xx:xxx-xxx.
</p>
<p>Liu P. and Hwang J-T. G. (2007) Quick calculation for sample size while
controlling false discovery rate with application to microarray
analysis. Bioinformatics; 23:739-746.
</p>
<p>Lehmann E. L., Romano J. P.. Generalizations of the familywise error
rate. Ann. Stat.. 2005;33(3):1138-1154.
</p>
<p>Romano Joseph P., Shaikh Azeem M.. Stepup procedures for control of
generalizations of the familywise error rate. Ann. Stat..
2006;34(4):1850-1873. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cCDF.ToM">cCDF.ToM</a></code>
<code><a href="#topic+cCDF.VoR">cCDF.VoR</a></code>
<code><a href="#topic+pwrFDR">pwrFDR</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  library(pwrFDR)

  u &lt;- seq(from=0,to=1,len=100000)
  rslt &lt;- cCDF.Rom(u=u, effect.size=0.9, n.sample=70, r.1=0.05, alpha=0.15, N.tests=1000,
                   FDP.control.method="Auto")

  ## plot the result
  with(rslt$cCDF.Rom, plot(u, cCDF.Rom, type="s"))

  ## compute the mean and median as a check
  DX &lt;- function(x)c(x[1], diff(x))
  .mean. &lt;- with(rslt$cCDF.Rom, sum(cCDF.Rom*DX(u)))
  .median. &lt;- with(rslt$cCDF.Rom, u[max(which(cCDF.Rom&gt;0.5))])
</code></pre>

<hr>
<h2 id='cCDF.ToM'>
Computes the complimentary CDF for the true positive proportion, T_m/M_m.
</h2><span id='topic+cCDF.ToM'></span>

<h3>Description</h3>

<p>Computes the complimentary CDF for the true positive proportion, T_m/M_m
via asymptotic approximation. Included here mainly for pedagogic purposes. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cCDF.ToM(u, effect.size, n.sample, r.1, alpha, delta, groups = 2, N.tests,
         type = c("paired", "balanced", "unbalanced"), grpj.per.grp1 = NULL,
         FDP.control.method = "BHFDR", distopt, 
         control=list(tol=1e-08,max.iter=c(1000,20),sim.level=2,low.power.stop=TRUE,
                      FDP.meth.thresh=FDP.cntl.mth.thrsh.def,verb=FALSE))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cCDF.ToM_+3A_u">u</code></td>
<td>

<p>A sorted vector of values on the interval [0, 1] for which the cCDF
of T_m/M_m should be computed.
</p>
</td></tr>
<tr><td><code id="cCDF.ToM_+3A_effect.size">effect.size</code></td>
<td>

<p>The effect size (mean over standard deviation) for test statistics 
having non-zero means. Assumed to be a constant (in magnitude) over
non-zero mean test statistics.
</p>
</td></tr>
<tr><td><code id="cCDF.ToM_+3A_n.sample">n.sample</code></td>
<td>

<p>The number of experimental replicates. Required for calculation
of power
</p>
</td></tr>
<tr><td><code id="cCDF.ToM_+3A_r.1">r.1</code></td>
<td>

<p>The proportion of simultaneous tests that are non-centrally located 
</p>
</td></tr>
<tr><td><code id="cCDF.ToM_+3A_alpha">alpha</code></td>
<td>

<p>The false discovery rate (in the BH case) or the upper bound on the
probability that the FDP exceeds delta (Romano case)
</p>
</td></tr>
<tr><td><code id="cCDF.ToM_+3A_delta">delta</code></td>
<td>

<p>If the &quot;FDP.control.method&quot; is set to 'Romano' or 'BHFDX', then the
user can set the exceedance thresh-hold for the FDP tail probability
control <code class="reqn">P\{ FDP &gt; \delta \} &lt; \alpha</code>. The default value is
<code class="reqn">\alpha</code>.
</p>
</td></tr>
<tr><td><code id="cCDF.ToM_+3A_groups">groups</code></td>
<td>

<p>The number of experimental groups to compare. Must be integral and
&gt;=1. The default value is 2.
</p>
</td></tr>
<tr><td><code id="cCDF.ToM_+3A_n.tests">N.tests</code></td>
<td>

<p>The number of simultaneous hypothesis tests. 
</p>
</td></tr>
<tr><td><code id="cCDF.ToM_+3A_type">type</code></td>
<td>

<p>A character string specifying, in the groups=2 case, whether the
test is 'paired', 'balanced', or 'unbalanced' and in the case when
groups &gt;=3, whether the test is 'balanced' or 'unbalanced'. The
default in all cases is 'balanced'. Left unspecified in the one
sample (groups=1) case. 
</p>
</td></tr>
<tr><td><code id="cCDF.ToM_+3A_grpj.per.grp1">grpj.per.grp1</code></td>
<td>

<p>Required when <code>type</code>=&quot;unbalanced&quot;, specifies the group 0 to
group 1 ratio in the two group case, and in the case of 3 or more
groups, the group j to group 1 ratio, where group 1 is the group
with the largest effect under the alternative hypothesis. 
</p>
</td></tr>
<tr><td><code id="cCDF.ToM_+3A_fdp.control.method">FDP.control.method</code></td>
<td>

<p>A character string specifying how the false discovery proportion (FDP) is to be
controlled. You may specify the whole word or any shortened uniquely
identifying truncation. <br />
&quot;BHFDR&quot;: the usual BH-FDR <br />
&quot;BHFDX&quot;: use asymptotic approximation to the distribution of the FDP 
to find a smaller FDR which guarantees probability less
than alpha that the FDP exceeds alpha. <br />
&quot;Romano&quot;: use Romano's method which guarantees probability less than 
alpha that the FDP exceeds alpha. <br />
&quot;Auto&quot;: in 'FixedPoint' mode, the program will use its own 
wisdom to determine which choice above to make. The 
order of conservatism is Romano &gt; BHFDX &gt; BHFDR, but 
BHFDR offers only expected control while the other two 
guarantee bounds on the excedance probabilty. If the 
distribution of the FDP is nearly degenerate, then BHFDR 
is the best option. Otherwise, if it can be reliably used, 
BHFDX would be the best choice. The 'effective' denominator, 
gamma*N.tests, in the CLT determines when the approximation 
is good enough and the asymptotic standard error of the FDP 
determines when the distribution is dispersed enough to matter.
Use &quot;Auto&quot; to run through these checks and determine the best. 
A return argument, 'Auto', displays the choice made. See 
output components and details. <br />
&quot;both&quot;: in 'simulation' mode, compute statistics R and T under BHFDX
and Romano (in addition to BHFDR). Corresponding
statistics are denoted R.st, T.st corresponding to BHFDX
control of the FDP, and R.R and T.R corresponding to
Romano control of the FDP. If sim.level is set to 2,
(default) the statistics R.st.ht and T.st.ht, which are
the number rejected and number true positives under BHFDX
where r_0 = 1-r_1, gamma, and alpha.star have been estimated 
from the P-value data and then alpha.star computed from
these.
</p>
</td></tr>
<tr><td><code id="cCDF.ToM_+3A_distopt">distopt</code></td>
<td>
<p>Test statistic distribution in among null and
alternatively distributed sub-populations.
distopt=0 gives normal (2 groups), distop=1 gives t- (2 groups)
and distopt=2 gives F- (2+ groups)
</p>
</td></tr>  
<tr><td><code id="cCDF.ToM_+3A_control">control</code></td>
<td>
<p>Optionally, a list with components with the following  
components: <br />
'tol' is a convergence criterion used in iterative 
methods which is set to 1e-8 by default.<br />
'max.iter' is an iteration limit, set to 20 for the iterated
function limit and 1000 for all others by default.<br />
'sim.level' sim level 2 (default) stipulates, when FDP.control.method
is set to &quot;BHFDX&quot;, or &quot;both&quot;, R.st.ht and T.st.ht are
computed in addition to R.st and T.st (see above). <br />
'low.power.stop' in simulation option, will result in an error message 
if the power computed via FixedPoint method is too low, which 
result in no solution for the BHFDX option. Default setting is TRUE. 
Set to FALSE to over-ride this behavior. <br />
'FDP.meth.thresh' fine-tunes the 'Auto' voodoo (see above). Leave 
this alone. <br />
'verb' vebosity level.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>cdf</code> which contains components
</p>
<table role = "presentation">
<tr><td><code>call</code></td>
<td>
<p>The call which produced the result
</p>
</td></tr>
<tr><td><code>cCDF.ToM</code></td>
<td>
<p>A data frame with columns <code>u</code> and <code>cCDF.ToM</code>
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Grant Izmirlian &lt;izmirlian at nih dot gov&gt;
</p>


<h3>References</h3>

<p>Izmirlian G. (2020) Strong consistency and asymptotic normality for
quantities related to the Benjamini-Hochberg false discovery rate
procedure. Statistics and Probability Letters; 108713,
&lt;doi:10.1016/j.spl.2020.108713&gt;.
</p>
<p>Izmirlian G. (2017) Average Power and <code class="reqn">\lambda</code>-power in
Multiple Testing Scenarios when the Benjamini-Hochberg False
Discovery Rate Procedure is Used. &lt;arXiv:1801.03989&gt;
</p>
<p>Jung S-H. (2005) Sample size for FDR-control in microarray data
analysis. Bioinformatics; 21:3097-3104.
</p>
<p>Kluger D. M., Owen A. B. (2023) A central limit theorem for the
Benjamini-Hochberg false discovery proportion under a factor model.
Bernoulli; xx:xxx-xxx.
</p>
<p>Liu P. and Hwang J-T. G. (2007) Quick calculation for sample size while
controlling false discovery rate with application to microarray
analysis. Bioinformatics; 23:739-746.
</p>
<p>Lehmann E. L., Romano J. P.. Generalizations of the familywise error
rate. Ann. Stat.. 2005;33(3):1138-1154.
</p>
<p>Romano Joseph P., Shaikh Azeem M.. Stepup procedures for control of
generalizations of the familywise error rate. Ann. Stat..
2006;34(4):1850-1873. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cCDF.Rom">cCDF.Rom</a></code>
<code><a href="#topic+cCDF.VoR">cCDF.VoR</a></code>
<code><a href="#topic+pwrFDR">pwrFDR</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  library(pwrFDR)

  u &lt;- seq(from=0,to=1,len=100000)
  rslt &lt;- cCDF.ToM(u=u, effect.size=0.9, n.sample=70, r.1=0.05, alpha=0.15, N.tests=1000,
                   FDP.control.method="Auto")

  ## plot the result
  with(rslt$cCDF.ToM, plot(u, cCDF.ToM, type="s"))

  ## compute the mean and median as a check 
  DX &lt;- function(x)c(x[1], diff(x))
  .mean. &lt;- with(rslt$cCDF.ToM, sum(cCDF.ToM*DX(u)))
  .median. &lt;- with(rslt$cCDF.ToM, u[max(which(cCDF.ToM&gt;0.5))])
</code></pre>

<hr>
<h2 id='cCDF.VoR'>
Computes the complimentary CDF for the false discovery proportion, V_m/R_m.
</h2><span id='topic+cCDF.VoR'></span>

<h3>Description</h3>

<p>Computes the complimentary CDF for the false discovery proportion, V_m/R_m
via asymptotic approximation. Included here mainly for pedagogic purposes. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cCDF.VoR(u, effect.size, n.sample, r.1, alpha, delta, groups = 2, N.tests,
         type = c("paired", "balanced", "unbalanced"), grpj.per.grp1 = NULL,
         FDP.control.method = "BHFDR", distopt,
         control=list(tol=1e-08,max.iter=c(1000,20),sim.level=2,low.power.stop=TRUE,
                      FDP.meth.thresh=FDP.cntl.mth.thrsh.def,verb=FALSE))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cCDF.VoR_+3A_u">u</code></td>
<td>

<p>A sorted vector of values on the interval [0, 1] for which the cCDF
of T_m/M_m should be computed.
</p>
</td></tr>
<tr><td><code id="cCDF.VoR_+3A_effect.size">effect.size</code></td>
<td>

<p>The effect size (mean over standard deviation) for test statistics 
having non-zero means. Assumed to be a constant (in magnitude) over
non-zero mean test statistics.
</p>
</td></tr>
<tr><td><code id="cCDF.VoR_+3A_n.sample">n.sample</code></td>
<td>

<p>The number of experimental replicates. Required for calculation
of power
</p>
</td></tr>
<tr><td><code id="cCDF.VoR_+3A_r.1">r.1</code></td>
<td>

<p>The proportion of simultaneous tests that are non-centrally located 
</p>
</td></tr>
<tr><td><code id="cCDF.VoR_+3A_alpha">alpha</code></td>
<td>

<p>The false discovery rate (in the BH case) or the upper bound on the
probability that the FDP exceeds delta (Romano case)
</p>
</td></tr>
<tr><td><code id="cCDF.VoR_+3A_delta">delta</code></td>
<td>

<p>If the &quot;FDP.control.method&quot; is set to 'Romano' or 'BHFDX', then the
user can set the exceedance thresh-hold for the FDP tail probability
control <code class="reqn">P\{ FDP &gt; \delta \} &lt; \alpha</code>. The default value is
<code class="reqn">\alpha</code>.
</p>
</td></tr>
<tr><td><code id="cCDF.VoR_+3A_groups">groups</code></td>
<td>

<p>The number of experimental groups to compare. Must be integral and
&gt;=1. The default value is 2.
</p>
</td></tr>
<tr><td><code id="cCDF.VoR_+3A_n.tests">N.tests</code></td>
<td>

<p>The number of simultaneous hypothesis tests. 
</p>
</td></tr>
<tr><td><code id="cCDF.VoR_+3A_type">type</code></td>
<td>

<p>A character string specifying, in the groups=2 case, whether the
test is 'paired', 'balanced', or 'unbalanced' and in the case when
groups &gt;=3, whether the test is 'balanced' or 'unbalanced'. The
default in all cases is 'balanced'. Left unspecified in the one
sample (groups=1) case. 
</p>
</td></tr>
<tr><td><code id="cCDF.VoR_+3A_grpj.per.grp1">grpj.per.grp1</code></td>
<td>

<p>Required when <code>type</code>=&quot;unbalanced&quot;, specifies the group 0 to
group 1 ratio in the two group case, and in the case of 3 or more
groups, the group j to group 1 ratio, where group 1 is the group
with the largest effect under the alternative hypothesis. 
</p>
</td></tr>
<tr><td><code id="cCDF.VoR_+3A_fdp.control.method">FDP.control.method</code></td>
<td>

<p>A character string specifying how the false discovery proportion (FDP) is to be
controlled. You may specify the whole word or any shortened uniquely
identifying truncation. <br />
&quot;BHFDR&quot;: the usual BH-FDR <br />
&quot;BHFDX&quot;: use asymptotic approximation to the distribution of the FDP 
to find a smaller FDR which guarantees probability less
than alpha that the FDP exceeds alpha. <br />
&quot;Romano&quot;: use Romano's method which guarantees probability less than 
alpha that the FDP exceeds alpha. <br />
&quot;Auto&quot;: in 'FixedPoint' mode, the program will use its own 
wisdom to determine which choice above to make. The 
order of conservatism is Romano &gt; BHFDX &gt; BHFDR, but 
BHFDR offers only expected control while the other two 
guarantee bounds on the excedance probabilty. If the 
distribution of the FDP is nearly degenerate, then BHFDR 
is the best option. Otherwise, if it can be reliably used, 
BHFDX would be the best choice. The 'effective' denominator, 
gamma*N.tests, in the CLT determines when the approximation 
is good enough and the asymptotic standard error of the FDP 
determines when the distribution is dispersed enough to matter.
Use &quot;Auto&quot; to run through these checks and determine the best. 
A return argument, 'Auto', displays the choice made. See 
output components and details. <br />
&quot;both&quot;: in 'simulation' mode, compute statistics R and T under BHFDX
and Romano (in addition to BHFDR). Corresponding
statistics are denoted R.st, T.st corresponding to BHFDX
control of the FDP, and R.R and T.R corresponding to
Romano control of the FDP. If sim.level is set to 2,
(default) the statistics R.st.ht and T.st.ht, which are
the number rejected and number true positives under BHFDX
where r_0 = 1-r_1, gamma, and alpha.star have been estimated 
from the P-value data and then alpha.star computed from
these.
</p>
</td></tr>
<tr><td><code id="cCDF.VoR_+3A_distopt">distopt</code></td>
<td>
<p>Test statistic distribution in among null and
alternatively distributed sub-populations.
distopt=0 gives normal (2 groups), distop=1 gives t- (2 groups)
and distopt=2 gives F- (2+ groups)
</p>
</td></tr>  
<tr><td><code id="cCDF.VoR_+3A_control">control</code></td>
<td>
<p>Optionally, a list with components with the following  
components: <br />
'tol' is a convergence criterion used in iterative 
methods which is set to 1e-8 by default.<br />
'max.iter' is an iteration limit, set to 20 for the iterated
function limit and 1000 for all others by default.<br />
'sim.level' sim level 2 (default) stipulates, when FDP.control.method
is set to &quot;BHFDX&quot;, or &quot;both&quot;, R.st.ht and T.st.ht are
computed in addition to R.st and T.st (see above). <br />
'low.power.stop' in simulation option, will result in an error message 
if the power computed via FixedPoint method is too low, which 
result in no solution for the BHFDX option. Default setting is TRUE. 
Set to FALSE to over-ride this behavior. <br />
'FDP.meth.thresh' fine-tunes the 'Auto' voodoo (see above). Leave 
this alone. <br />
'verb' vebosity level.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>cdf</code> which contains components
</p>
<table role = "presentation">
<tr><td><code>call</code></td>
<td>
<p>The call which produced the result
</p>
</td></tr>
<tr><td><code>cCDF.VoR</code></td>
<td>
<p>A data frame with columns <code>u</code> and <code>cCDF.VoR</code>
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Grant Izmirlian &lt;izmirlian at nih dot gov&gt;
</p>


<h3>References</h3>

<p>Izmirlian G. (2020) Strong consistency and asymptotic normality for
quantities related to the Benjamini-Hochberg false discovery rate
procedure. Statistics and Probability Letters; 108713,
&lt;doi:10.1016/j.spl.2020.108713&gt;.
</p>
<p>Izmirlian G. (2017) Average Power and <code class="reqn">\lambda</code>-power in
Multiple Testing Scenarios when the Benjamini-Hochberg False
Discovery Rate Procedure is Used. &lt;arXiv:1801.03989&gt;
</p>
<p>Jung S-H. (2005) Sample size for FDR-control in microarray data
analysis. Bioinformatics; 21:3097-3104.
</p>
<p>Kluger D. M., Owen A. B. (2023) A central limit theorem for the
Benjamini-Hochberg false discovery proportion under a factor model.
Bernoulli; xx:xxx-xxx.
</p>
<p>Liu P. and Hwang J-T. G. (2007) Quick calculation for sample size while
controlling false discovery rate with application to microarray
analysis. Bioinformatics; 23:739-746.
</p>
<p>Lehmann E. L., Romano J. P.. Generalizations of the familywise error
rate. Ann. Stat.. 2005;33(3):1138-1154.
</p>
<p>Romano Joseph P., Shaikh Azeem M.. Stepup procedures for control of
generalizations of the familywise error rate. Ann. Stat..
2006;34(4):1850-1873. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cCDF.Rom">cCDF.Rom</a></code>
<code><a href="#topic+cCDF.ToM">cCDF.ToM</a></code>
<code><a href="#topic+pwrFDR">pwrFDR</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  library(pwrFDR)

  u &lt;- seq(from=0,to=1,len=100000)
  rslt &lt;- cCDF.VoR(u=u, effect.size=0.9, n.sample=70, r.1=0.05, alpha=0.15, N.tests=1000,
                   FDP.control.method="Auto")

  ## plot the result
  with(rslt$cCDF.VoR, plot(u, cCDF.VoR, type="s"))

  ## compute the mean and median as a check 
  DX &lt;- function(x)c(x[1], diff(x))
  .mean. &lt;- with(rslt$cCDF.VoR, sum(cCDF.VoR*DX(u)))
  .median. &lt;- with(rslt$cCDF.VoR, u[max(which(cCDF.VoR&gt;0.5))])
</code></pre>

<hr>
<h2 id='CDF.Pval'>
CDF of pooled (H0 and HA) population p-values
</h2><span id='topic+CDF.Pval'></span>

<h3>Description</h3>

<p>Computes the CDF of the pooled population p-values under the
mixture model, e.g. the p-values are i.i.d. with CDF 
a mixture between a uniform (CDF in the null distributed
population) and a concave function (CDF in the non-null 
distributed population).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  CDF.Pval(u, effect.size, n.sample, r.1, groups=2, type="balanced",
           grpj.per.grp1=1, distopt, control)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CDF.Pval_+3A_u">u</code></td>
<td>

<p>Argument of the CDF. Result will be Pr( P_i &lt;= u )
</p>
</td></tr>
<tr><td><code id="CDF.Pval_+3A_effect.size">effect.size</code></td>
<td>

<p>The effect size (mean over standard deviation) for test statistics 
having non-zero means. Assumed to be a constant (in magnitude) over
non-zero mean test statistics.
</p>
</td></tr>
<tr><td><code id="CDF.Pval_+3A_n.sample">n.sample</code></td>
<td>

<p>The number of experimental replicates.
</p>
</td></tr>
<tr><td><code id="CDF.Pval_+3A_r.1">r.1</code></td>
<td>

<p>The proportion of all test statistics that are distributed under HA.
</p>
</td></tr>
<tr><td><code id="CDF.Pval_+3A_groups">groups</code></td>
<td>

<p>The number of experimental groups to compare. Default value is 2.
</p>
</td></tr>
<tr><td><code id="CDF.Pval_+3A_type">type</code></td>
<td>

<p>A character string specifying, in the groups=2 case, whether the
test is 'paired', 'balanced', or 'unbalanced' and in the case when
groups &gt;=3, whether the test is 'balanced' or 'unbalanced'. The
default in all cases is 'balanced'. Left unspecified in the one
sample (groups=1) case. 
</p>
</td></tr>
<tr><td><code id="CDF.Pval_+3A_grpj.per.grp1">grpj.per.grp1</code></td>
<td>

<p>Required when <code>type</code>=&quot;unbalanced&quot;, specifies the group 0 to
group 1 ratio in the two group case, and in the case of 3 or more
groups, the group j to group 1 ratio, where group 1 is the group
with the largest effect under the alternative hypothesis. 
</p>
</td></tr>
<tr><td><code id="CDF.Pval_+3A_distopt">distopt</code></td>
<td>
<p>Test statistic distribution in among null and
alternatively distributed sub-populations.
distopt=0 gives normal (2 groups), distop=1 gives t- (2 groups)
and distopt=2 gives F- (2+ groups)
</p>
</td></tr>  
<tr><td><code id="CDF.Pval_+3A_control">control</code></td>
<td>

<p>Optionally, a list with components with the following components:
'groups', used when distop=3 (F-dist), specifying number of groups. 
'tol' is a convergence criterion used in iterative methods
which is set to 1e-8 by default
'max.iter' is an iteration limit, set to 1000 by default
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Computes the CDF of the pooled population p-values under the
mixture model, e.g. the p-values are i.i.d. with CDF 
a mixture between a uniform (CDF in the null distributed
population) and a concave function (CDF in the non-null 
distributed population). If Fc_0 is the cCDF of a test 
statistic under H0 and Fc_A is the cCDF of a test statistic
under HA then the CDF of the P-values is
</p>
<p><code>G(u) = (1-r) u  + r Fc_A(Fc_0^{-1}(u))</code>
</p>
<p>The limiting positve call fraction, lim_m V_m/m = gamma (a.s.)
is the solution to the equation 
</p>
<p>G( gamma alpha) = gamma 
</p>
<p>where alpha is the nominal FDR.
</p>


<h3>Value</h3>

<p>A list with components
</p>
<table role = "presentation">
<tr><td><code>call</code></td>
<td>
<p>The call which produced the result</p>
</td></tr>
<tr><td><code>u</code></td>
<td>
<p>The argument that was passed to the function</p>
</td></tr>
<tr><td><code>CDF.Pval</code></td>
<td>
<p>The value of the CDF</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Grant Izmirlian &lt;izmirlian at nih dot gov&gt;
</p>


<h3>References</h3>

<p>Izmirlian G. (2020) Strong consistency and asymptotic normality for
quantities related to the Benjamini-Hochberg false discovery rate
procedure. Statistics and Probability Letters; 108713,
&lt;doi:10.1016/j.spl.2020.108713&gt;.
</p>
<p>Izmirlian G. (2017) Average Power and <code class="reqn">\lambda</code>-power in
Multiple Testing Scenarios when the Benjamini-Hochberg False
Discovery Rate Procedure is Used. arXiv:1801.03989
</p>
<p>Genovese, C. and L. Wasserman. (2004) A stochastic process approach to
false discovery control. Annals of Statistics. 32 (3), 1035-1061.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+CDF.Pval.HA">CDF.Pval.HA</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  ## First calculate an average power for a given set of parameters
  rslt.avgp &lt;- pwrFDR(effect.size=0.79, n.sample=46, r.1=2000/54675, alpha=0.15)

  ## Now verify that G( gamma alpha ) = gamma

  gma &lt;- rslt.avgp$gamma
  alpha &lt;- rslt.avgp$call$alpha

  G.gma.a &lt;- CDF.Pval(u=gma*alpha, r.1=2000/54675, effect.size=0.79, n.sample=46)$CDF.Pval$CDF.Pval

  c(G.of.gamma.alpha=G.gma.a, gamma=gma) 
</code></pre>

<hr>
<h2 id='CDF.Pval.apsi.eq.u'>
Calculates the fixed point for the Romano procedure.
</h2><span id='topic+CDF.Pval.apsi.eq.u'></span>

<h3>Description</h3>

<p>Calculates the fixed point for the Romano procedure, e.g. finds
u which solves u = G( psi(u, d) a) where G is the common
p-value CDF, and psi(u, d) = u d/(1 - (1-a) u). Essentially an
internal function and included at the user level for pedagogic
purposes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  CDF.Pval.apsi.eq.u(effect.size, n.sample, r.1, alpha, delta, groups, type,
                     grpj.per.grp1, distopt, control)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CDF.Pval.apsi.eq.u_+3A_effect.size">effect.size</code></td>
<td>

<p>The effect size (mean over standard deviation) for test statistics 
having non-zero means. Assumed to be a constant (in magnitude) over
non-zero mean test statistics.
</p>
</td></tr>
<tr><td><code id="CDF.Pval.apsi.eq.u_+3A_n.sample">n.sample</code></td>
<td>

<p>The number of experimental replicates. Required for calculation
of power
</p>
</td></tr>
<tr><td><code id="CDF.Pval.apsi.eq.u_+3A_r.1">r.1</code></td>
<td>

<p>The proportion of simultaneous tests that are non-centrally located 
</p>
</td></tr>
<tr><td><code id="CDF.Pval.apsi.eq.u_+3A_alpha">alpha</code></td>
<td>

<p>The upper bound on the probability that the FDP exceeds delta.
</p>
</td></tr>
<tr><td><code id="CDF.Pval.apsi.eq.u_+3A_delta">delta</code></td>
<td>

<p>The exceedance thresh-hold for the FDP tail probability control method 
(BHFDX or Romano) <code class="reqn">P\{ FDP &gt; \delta \} &lt; \alpha</code>. The default 
value is <code class="reqn">\alpha</code>.
</p>
</td></tr>
<tr><td><code id="CDF.Pval.apsi.eq.u_+3A_groups">groups</code></td>
<td>

<p>The number of experimental groups to compare. Must be integral and
&gt;=1. The default value is 2.
</p>
</td></tr>
<tr><td><code id="CDF.Pval.apsi.eq.u_+3A_type">type</code></td>
<td>

<p>A character string specifying, in the groups=2 case, whether the
test is 'paired', 'balanced', or 'unbalanced' and in the case when
groups &gt;=3, whether the test is 'balanced' or 'unbalanced'. The
default in all cases is 'balanced'. Left unspecified in the one
sample (groups=1) case. 
</p>
</td></tr>
<tr><td><code id="CDF.Pval.apsi.eq.u_+3A_grpj.per.grp1">grpj.per.grp1</code></td>
<td>

<p>Required when <code>type</code>=&quot;unbalanced&quot;, specifies the group 0 to
group 1 ratio in the two group case, and in the case of 3 or more
groups, the group j to group 1 ratio, where group 1 is the group
with the largest effect under the alternative hypothesis. 
</p>
</td></tr>
<tr><td><code id="CDF.Pval.apsi.eq.u_+3A_distopt">distopt</code></td>
<td>
<p>Test statistic distribution in among null and
alternatively distributed sub-populations.
distopt=0 gives normal (2 groups), distop=1 gives t- (2 groups)
and distopt=2 gives F- (2+ groups)
</p>
</td></tr>  
<tr><td><code id="CDF.Pval.apsi.eq.u_+3A_control">control</code></td>
<td>
<p>Optionally, a list with components with the following  
components: <br />
'tol' is a convergence criterion used in iterative 
methods which is set to 1e-8 by default.
'max.iter' is an iteration limit, set to 20 for the iterated
function limit and 1000 for all others by default.
'sim.level' sim level 2 (default) stipulates, when FDP.control.method
is set to &quot;BHFDX&quot;, or &quot;both&quot;, R.st.ht and T.st.ht are
computed in addition to R.st and T.st (see above). <br />
'low.power.stop' in simulation option, will result in an error message 
if the power computed via FixedPoint method is too low, which 
result in no solution for the BHFDX option. Default setting is TRUE. 
Set to FALSE to over-ride this behavior. <br />
'FDP.meth.thresh' fine-tunes the 'Auto' voodoo (see above). Leave 
this alone. <br />
'verb' vebosity level.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>cdf</code> which contains components
</p>
<table role = "presentation">
<tr><td><code>call</code></td>
<td>
<p>The call which produced the result
</p>
</td></tr>
<tr><td><code>gamma</code></td>
<td>
<p>The fixed point for the Romano method.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Grant Izmirlian &lt;izmirlian at nih dot gov&gt;
</p>


<h3>References</h3>

<p>Izmirlian G. (2020) Strong consistency and asymptotic normality for
quantities related to the Benjamini-Hochberg false discovery rate
procedure. Statistics and Probability Letters; 108713,
&lt;doi:10.1016/j.spl.2020.108713&gt;.
</p>
<p>Izmirlian G. (2017) Average Power and <code class="reqn">\lambda</code>-power in
Multiple Testing Scenarios when the Benjamini-Hochberg False
Discovery Rate Procedure is Used. &lt;arXiv:1801.03989&gt;
</p>
<p>Jung S-H. (2005) Sample size for FDR-control in microarray data
analysis. Bioinformatics; 21:3097-3104.
</p>
<p>Liu P. and Hwang J-T. G. (2007) Quick calculation for sample size while
controlling false discovery rate with application to microarray
analysis. Bioinformatics; 23:739-746.
</p>
<p>Lehmann E. L., Romano J. P.. Generalizations of the familywise error
rate. Ann. Stat.. 2005;33(3):1138-1154.
</p>
<p>Romano Joseph P., Shaikh Azeem M.. Stepup procedures for control of
generalizations of the familywise error rate. Ann. Stat..
2006;34(4):1850-1873. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+CDF.Pval.au.eq.u">CDF.Pval.au.eq.u</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  ## An example showing that the Romano method is more conservative than the BHFDX method
  ## which is in turn more conservative than the BH-FDR method based upon ordering of the
  ## significant call proportions, R_m/m

  ## First find alpha.star for the BH-CLT method at level alpha=0.15
  a.st.BHFDX &lt;-controlFDP(effect.size=0.8,r.1=0.05,N.tests=1000,n.sample=70,alpha=0.15)$alpha.star

  ## now find the significant call fraction under the BH-FDR method at level alpha=0.15
  gamma.BHFDR &lt;- CDF.Pval.au.eq.u(effect.size = 0.8, n.sample = 70, r.1 = 0.05, alpha=0.15)

  ## now find the significant call fraction under the Romano method at level alpha=0.15
  gamma.romano &lt;- CDF.Pval.apsi.eq.u(effect.size = 0.8, n.sample = 70, r.1 = 0.05, alpha=0.15)

  ## now find the significant call fraction under the BH-CLT method at level alpha=0.15
  gamma.BHFDX &lt;- CDF.Pval.au.eq.u(effect.size = 0.8, n.sample = 70, r.1 = 0.05, alpha=a.st.BHFDX)
</code></pre>

<hr>
<h2 id='CDF.Pval.au.eq.u'>
Function which solves the implicit equation u = G( u alpha) 
</h2><span id='topic+CDF.Pval.au.eq.u'></span>

<h3>Description</h3>

<p>Function which solves the implicit equation u = G( u alpha) where G is
the pooled P-value CDF and alpha is the FDR
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  CDF.Pval.au.eq.u(effect.size, n.sample, r.1, alpha, groups, type, 
                   grpj.per.grp1, distopt, control)
  </code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CDF.Pval.au.eq.u_+3A_effect.size">effect.size</code></td>
<td>

<p>The per statistic effect size
</p>
</td></tr>
<tr><td><code id="CDF.Pval.au.eq.u_+3A_n.sample">n.sample</code></td>
<td>

<p>The per statistic sample size
</p>
</td></tr>
<tr><td><code id="CDF.Pval.au.eq.u_+3A_r.1">r.1</code></td>
<td>

<p>The proportion of Statistics distributed according to the alternative distribution
</p>
</td></tr>
<tr><td><code id="CDF.Pval.au.eq.u_+3A_alpha">alpha</code></td>
<td>

<p>The false discovery rate.
</p>
</td></tr>
<tr><td><code id="CDF.Pval.au.eq.u_+3A_groups">groups</code></td>
<td>

<p>Number of experimental groups from which the test statistic is calculated
</p>
</td></tr>
<tr><td><code id="CDF.Pval.au.eq.u_+3A_type">type</code></td>
<td>

<p>A character string specifying, in the groups=2 case, whether the
test is 'paired', 'balanced', or 'unbalanced' and in the case when
groups &gt;=3, whether the test is 'balanced' or 'unbalanced'. The
default in all cases is 'balanced'. Left unspecified in the one
sample (groups=1) case. 
</p>
</td></tr>
<tr><td><code id="CDF.Pval.au.eq.u_+3A_grpj.per.grp1">grpj.per.grp1</code></td>
<td>

<p>Required when <code>type</code>=&quot;unbalanced&quot;, specifies the group 0 to
group 1 ratio in the two group case, and in the case of 3 or more
groups, the group j to group 1 ratio, where group 1 is the group
with the largest effect under the alternative hypothesis. 
</p>
</td></tr>
<tr><td><code id="CDF.Pval.au.eq.u_+3A_distopt">distopt</code></td>
<td>
<p>Test statistic distribution in among null and
alternatively distributed sub-populations.
distopt=0 gives normal (2 groups), distop=1 gives t- (2 groups)
and distopt=2 gives F- (2+ groups)
</p>
</td></tr>  
<tr><td><code id="CDF.Pval.au.eq.u_+3A_control">control</code></td>
<td>

<p>Optionally, a list with components with the following components:
'groups', used when distop=3 (F-dist), specifying number of groups. 
'max.iter' is an iteration limit, set to 1000 by default
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with a single component, 
</p>
<table role = "presentation">
<tr><td><code>gamma</code></td>
<td>

<p>The solution of the implicit equation u = G( u alpha), where G is
the pooled P-value CDF. This represents the infinite tests limiting
proportion of hypothesis tests that are called significant by the
BH-FDR procedure at alpha.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Grant Izmirlian &lt;izmirlian at nih dot gov&gt;
</p>


<h3>References</h3>

<p>Izmirlian G. (2020) Strong consistency and asymptotic normality for
quantities related to the Benjamini-Hochberg false discovery rate
procedure. Statistics and Probability Letters; 108713,
&lt;doi:10.1016/j.spl.2020.108713&gt;.
</p>
<p>Izmirlian G. (2017) Average Power and <code class="reqn">\lambda</code>-power in
Multiple Testing Scenarios when the Benjamini-Hochberg False
Discovery Rate Procedure is Used. &lt;arXiv:1801.03989&gt;
</p>
<p>Jung S-H. (2005) Sample size for FDR-control in microarray data
analysis. Bioinformatics; 21:3097-3104.
</p>
<p>Liu P. and Hwang J-T. G. (2007) Quick calculation for sample size while
controlling false discovery rate with application to microarray
analysis. Bioinformatics; 23:739-746.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+CDF.Pval.apsi.eq.u">CDF.Pval.apsi.eq.u</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  ## An example showing that the Romano method is more conservative than the BHFDX method
  ## which is in turn more conservative than the BH-FDR method based upon ordering of the
  ## significant call proportions, R_m/m

  ## First find alpha.star for the BH-CLT method at level alpha=0.15
  a.st.BHFDX &lt;-controlFDP(effect.size=0.8,r.1=0.05,N.tests=1000,n.sample=70,alpha=0.15)$alpha.star

  ## now find the significant call fraction under the BH-FDR method at level alpha=0.15
  gamma.BHFDR &lt;- CDF.Pval.au.eq.u(effect.size = 0.8, n.sample = 70, r.1 = 0.05, alpha=0.15)

  ## now find the significant call fraction under the Romano method at level alpha=0.15
  gamma.romano &lt;- CDF.Pval.apsi.eq.u(effect.size = 0.8, n.sample = 70, r.1 = 0.05, alpha=0.15)

  ## now find the significant call fraction under the BH-CLT method at level alpha=0.15
  gamma.BHFDX &lt;- CDF.Pval.au.eq.u(effect.size = 0.8, n.sample = 70, r.1 = 0.05, alpha=a.st.BHFDX)
</code></pre>

<hr>
<h2 id='CDF.Pval.HA'>
CDF of p-values for test statistics distribted under HA.
</h2><span id='topic+CDF.Pval.HA'></span>

<h3>Description</h3>

<p>Computes the CDF of p-values for test statistics distribted under HA.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CDF.Pval.HA(u, effect.size, n.sample, r.1, groups = 2, type="balanced",
            grpj.per.grp1=1, distopt, control)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CDF.Pval.HA_+3A_u">u</code></td>
<td>

<p>Argument of the CDF. Result will be Pr( P_i &lt;= u )
</p>
</td></tr>
<tr><td><code id="CDF.Pval.HA_+3A_effect.size">effect.size</code></td>
<td>

<p>The effect size (mean over standard deviation) for test statistics 
having non-zero means. Assumed to be a constant (in magnitude) over
non-zero mean test statistics.
</p>
</td></tr>
<tr><td><code id="CDF.Pval.HA_+3A_n.sample">n.sample</code></td>
<td>

<p>The number of experimental replicates.
</p>
</td></tr>
<tr><td><code id="CDF.Pval.HA_+3A_r.1">r.1</code></td>
<td>

<p>The proportion of all test statistics that are distributed under HA.
</p>
</td></tr>
<tr><td><code id="CDF.Pval.HA_+3A_groups">groups</code></td>
<td>

<p>The number of experimental groups to compare. Default value is 2.
</p>
</td></tr>
<tr><td><code id="CDF.Pval.HA_+3A_type">type</code></td>
<td>

<p>A character string specifying, in the groups=2 case, whether the
test is 'paired', 'balanced', or 'unbalanced' and in the case when
groups &gt;=3, whether the test is 'balanced' or 'unbalanced'. The
default in all cases is 'balanced'. Left unspecified in the one
sample (groups=1) case. 
</p>
</td></tr>
<tr><td><code id="CDF.Pval.HA_+3A_grpj.per.grp1">grpj.per.grp1</code></td>
<td>

<p>Required when <code>type</code>=&quot;unbalanced&quot;, specifies the group 0 to
group 1 ratio in the two group case, and in the case of 3 or more
groups, the group j to group 1 ratio, where group 1 is the group
with the largest effect under the alternative hypothesis. 
</p>
</td></tr>
<tr><td><code id="CDF.Pval.HA_+3A_distopt">distopt</code></td>
<td>
<p>Test statistic distribution in among null and
alternatively distributed sub-populations.
distopt=0 gives normal (2 groups), distop=1 gives t- (2 groups)
and distopt=2 gives F- (2+ groups)
</p>
</td></tr>  
<tr><td><code id="CDF.Pval.HA_+3A_control">control</code></td>
<td>

<p>Optionally, a list with components with the following components:
'groups', used when distop=3 (F-dist), specifying number of groups. 
'tol' is a convergence criterion used in iterative methods
which is set to 1e-8 by default
'max.iter' is an iteration limit, set to 20 for function iteration
and 1000 for all others by default
'distop', specifying the distribution family of the central and
non-centrally located sub-populations. =1 gives normal (2 groups)
=2 gives t- (2 groups) and =3 gives F- (2+ groups)    
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Computes the CDF of p-values for test statistics distribted under HA.
If Fc_0 is the cCDF of a test statistic under H0 and Fc_A is the cCDF
of a test statistic under HA then the CDF of a P-value for a test
statistic distributed under HA is
</p>
<p><code>G_A(u) = Fc_A(Fc_0^{-1}(u))</code>
</p>
<p>The limiting true positive fraction is the infinite simultaneous tests
average power,
</p>
<p>lim_m T_m/M_m = average.power (a.s.),
</p>
<p>which is used to approximate the average power for finite 'm', is
G_1 at gamma alpha:
</p>
<p>G_1( gamma alpha) = average.pwer
</p>
<p>where alpha is the nominal FDR and gamma = lim_m R_m/m (a.s.) is the limiting
positive call fraction.
</p>


<h3>Value</h3>

<p>A list with components
</p>
<table role = "presentation">
<tr><td><code>call</code></td>
<td>
<p>The call which produced the result</p>
</td></tr>
<tr><td><code>u</code></td>
<td>
<p>The argument that was passed to the function</p>
</td></tr>
<tr><td><code>CDF.Pval.HA</code></td>
<td>
<p>The value of the CDF</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Grant Izmirlian &lt;izmirlian at nih dot gov&gt;
</p>


<h3>References</h3>

<p>Izmirlian G. (2020) Strong consistency and asymptotic normality for
quantities related to the Benjamini-Hochberg false discovery rate
procedure. Statistics and Probability Letters; 108713,
&lt;doi:10.1016/j.spl.2020.108713&gt;.  
</p>
<p>Izmirlian G. (2017) Average Power and <code class="reqn">\lambda</code>-power in
Multiple Testing Scenarios when the Benjamini-Hochberg False
Discovery Rate Procedure is Used. &lt;arXiv:1801.03989&gt;
</p>
<p>Genovese, C. and L. Wasserman. (2004) A stochastic process approach to
false discovery control. Annals of Statistics. 32 (3), 1035-1061.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+CDF.Pval">CDF.Pval</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  ## First calculate an average power for a given set of parameters
  rslt.avgp &lt;- pwrFDR(effect.size=0.79, n.sample=42, r.1=0.05, alpha=0.15)

  ## Now verify that G_A( gamma f ) = average.power

  gma &lt;- rslt.avgp$gamma
  alpha &lt;- rslt.avgp$call$alpha

  GA.gma.alpha &lt;- CDF.Pval.HA(u=gma*alpha, r.1=0.05, effect.size=0.79, n.sample=42)

  c(G.gm.alpha=GA.gma.alpha$CDF.Pval.HA$CDF.Pval.HA, average.power=rslt.avgp$average.power)
</code></pre>

<hr>
<h2 id='controlFDP'>
Helper function for the BHFDX FDP control method
</h2><span id='topic+controlFDP'></span>

<h3>Description</h3>

<p>Helper function for the BHFDX FDP control method. Calculates
a reduced FDR required to bound the the false discovery proportion
in probability using asymptotic approximation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  controlFDP(effect.size, n.sample, r.1, alpha, delta, groups = 2, 
    N.tests, type, grpj.per.grp1, corr.struct, control, formula, data, distopt) 
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="controlFDP_+3A_effect.size">effect.size</code></td>
<td>

<p>The effect size (mean over standard deviation) for test statistics 
having non-zero means. Assumed to be a constant (in magnitude) over
non-zero mean test statistics.
</p>
</td></tr>
<tr><td><code id="controlFDP_+3A_n.sample">n.sample</code></td>
<td>

<p>The number of experimental replicates.
</p>
</td></tr>
<tr><td><code id="controlFDP_+3A_r.1">r.1</code></td>
<td>

<p>The proportion of simultaneous tests that are non-centrally located 
</p>
</td></tr>
<tr><td><code id="controlFDP_+3A_alpha">alpha</code></td>
<td>

<p>The upper bound on the probability that the FDP exceeds delta.
</p>
</td></tr>
<tr><td><code id="controlFDP_+3A_delta">delta</code></td>
<td>

<p>The exceedance thresh-hold for the FDP tail probability control method 
(BHFDX or Romano) <code class="reqn">P\{ FDP &gt; \delta \} &lt; \alpha</code>. The default 
value is <code class="reqn">\alpha</code>.
</p>
</td></tr>
<tr><td><code id="controlFDP_+3A_groups">groups</code></td>
<td>

<p>The number of experimental groups to compare. Default value is 2.
</p>
</td></tr>
<tr><td><code id="controlFDP_+3A_n.tests">N.tests</code></td>
<td>

<p>The number of simultaneous hypothesis tests. 
</p>
</td></tr>
<tr><td><code id="controlFDP_+3A_type">type</code></td>
<td>

<p>A character string specifying, in the groups=2 case, whether the
test is 'paired', 'balanced', or 'unbalanced' and in the case when
groups &gt;=3, whether the test is 'balanced' or 'unbalanced'. The
default in all cases is 'balanced'. Left unspecified in the one
sample (groups=1) case. 
</p>
</td></tr>
<tr><td><code id="controlFDP_+3A_grpj.per.grp1">grpj.per.grp1</code></td>
<td>

<p>Required when <code>type</code>=&quot;unbalanced&quot;, specifies the group 0 to
group 1 ratio in the two group case, and in the case of 3 or more
groups, the group j to group 1 ratio, where group 1 is the group
with the largest effect under the alternative hypothesis. 
</p>
</td></tr>
<tr><td><code id="controlFDP_+3A_corr.struct">corr.struct</code></td>
<td>
<p>Specifies a block correlation structure between test
statistics which is used in both the simulation routine, and in the
computations based upon asymptotic approximation, e.g. the AFDX
control and the ATPP method. Its form is specified via the following
named elements.<br />
&quot;type&quot;: &quot;CS-Blocks&quot; for compound symmetry within blocks or 
&quot;Toeplitz-Blocks&quot; for toeplitz within blocks.<br />
&quot;block.size&quot;: the size of the correlated blocks
&quot;rho&quot;: When type=&quot;CS-Blocks&quot;, then 'rho' is a correlation of length 1
when type=&quot;Toeplitz-Blocks&quot;, then 'rho' is a vector of
correlations of length 'block.size' - 1
</p>
</td></tr>
<tr><td><code id="controlFDP_+3A_control">control</code></td>
<td>

<p>Optionally, a list with components with the following components:
'groups', used when distop=3 (F-dist), specifying number of groups.<br />
'tol' is a convergence criterion used in iterative methods
which is set to 1e-8 by default<br /> 
'max.iter' is an iteration limit, set to 20 for the iterated
function limit and 1000 for all others by default<br />
'sim.level' sim level 2 results in more detail at the expense of
slightly more computational time.<br />
'low.power.stop' in simulation option, will result in an error message if
the power computed via FixedPoint method is too low, which
result in no solution for the BHFDX option. Default setting
is TRUE. Set to FALSE to over-ride.<br />
'FDP.meth.thresh' fine-tunes the 'Auto' voodoo (see above). Leave
this alone.<br />
'verb' vebosity level.
</p>
</td></tr>
<tr><td><code id="controlFDP_+3A_formula">formula</code></td>
<td>
<p>Optionally, the function can be used to _estimate_ f*
from a given dataset of sorted p-values.  In this case we specify
formula, which is a formula of the form <code>pval~1</code> where 'pval'
is the name of the p-value variable in the dataset, <code>dataset</code>
(see 
</p>
</td></tr>
<tr><td><code id="controlFDP_+3A_data">data</code></td>
<td>

<p>The name of the dataset.
</p>
</td></tr>
<tr><td><code id="controlFDP_+3A_distopt">distopt</code></td>
<td>
<p>Test statistic distribution in among null and
alternatively distributed sub-populations.
distopt=0 gives normal (2 groups), distop=1 gives t- (2 groups)
and distopt=2 gives F- (2+ groups)
</p>
</td></tr>  
</table>


<h3>Details</h3>

<p>Uses a CLT for the FDP to calculate a reduced alpha required to
bound the the false discovery rate in probability...e.g. finds
alpha* so that when the BH-FDR procedure is controlled at alpha*,
we ensure that
</p>
<p>Pr( V_m/R_m &gt; (1-r) alpha ) &lt; (1-r) alpha
</p>
<p>where 'alpha' is the original false discovery rate and
'r' is the proportion of non-null distributed test
statistics.
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>alpha.star</code></td>
<td>
<p>The reduced alpha required to bound the FDP in probability</p>
</td></tr>
<tr><td><code>obj</code></td>
<td>
<p>Objective value at 'alpha.star'... should be close to 0</p>
</td></tr>
<tr><td><code>L.star</code></td>
<td>
<p>The bound on the FDP, should be (1-r) f.  See above.</p>
</td></tr>
<tr><td><code>P.star</code></td>
<td>
<p>The probability that the FDP is greater than L.star. See above.</p>
</td></tr>
<tr><td><code>average.power</code></td>
<td>
<p>Resulting average power.</p>
</td></tr>
<tr><td><code>c.g</code></td>
<td>
<p>The BH-FDR threshold on the scale of the test statistics.</p>
</td></tr>
<tr><td><code>gamma</code></td>
<td>
<p>The proportion of all 'm' tests declared significant.</p>
</td></tr>
<tr><td><code>objective</code></td>
<td>
<p>Result of optimization yielding the 'average.power'.</p>
</td></tr>
<tr><td><code>err.III</code></td>
<td>
<p>Mass on the wrong side of the threshold.</p>
</td></tr>
<tr><td><code>sigma.rtm.SoM</code></td>
<td>
<p>Asymptotic variance of the true positive fraction.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Grant Izmirlian &lt;izmirlian at nih dot gov&gt;
</p>


<h3>References</h3>

<p>Izmirlian G. (2020) Strong consistency and asymptotic normality for
quantities related to the Benjamini-Hochberg false discovery rate
procedure. Statistics and Probability Letters; 108713,
&lt;doi:10.1016/j.spl.2020.108713&gt;
</p>
<p>Izmirlian G. (2017) Average Power and <code class="reqn">\lambda</code>-power in
Multiple Testing Scenarios when the Benjamini-Hochberg False
Discovery Rate Procedure is Used. &lt;arXiv:1801.03989&gt;
</p>
<p>Kluger D. M., Owen A. B. (2023) A central limit theorem for the
Benjamini-Hochberg false discovery proportion under a factor model.
Bernoulli; xx:xxx-xxx.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pwrFDR">pwrFDR</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## at alpha=0.15 and other parameters, it takes n.sample=46 replicates for 
## average power &gt; 80%
pwr.46.15 &lt;- pwrFDR(alpha=0.15, r.1=0.03, N.tests=1000, effect.size=0.79, n.sample=46)

## when there are 'only' N.tests=1000 simultaneous tests, the distribution of the
## false discovery fraction, FDP, is not so highly spiked at the alpha=0.15
## You need to set the alpha down to alpha=0.0657 to ensure that  Pr( T/J &gt; 0.145 ) &lt; 0.0657
fstr &lt;- controlFDP(alpha=0.15, r.1=0.03, N.tests=1000, effect.size=0.8, n.sample=46)

## at all the above settings, with alpha=0.0657 at an n.sample of 46, we only have 69% 
## average power.
pwr.46.0657 &lt;- pwrFDR(alpha=0.065747, r.1=0.03, N.tests=1000, effect.size=0.79, n.sample=46)

## it'll cost 7 more replicates to get the average power up over 80%.
pwr.53.0657 &lt;- pwrFDR(alpha=0.065747, r.1=0.03, N.tests=1000, effect.size=0.8, n.sample=53)

## it costs only 8.75% more to get it right!
</code></pre>

<hr>
<h2 id='criterion'>
BH-FDR and Romano Criterion
</h2><span id='topic+criterion'></span>

<h3>Description</h3>

<p>Compute BH-FDR step up criterion, or Romano step-down criterion
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  criterion(alpha, delta, N.tests, FDP.control.method = c("BHFDR", "Romano"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="criterion_+3A_alpha">alpha</code></td>
<td>

<p>The false discovery rate (in the BH case) or the upper bound on the
probability that the FDP exceeds lambda (Romano case)
</p>
</td></tr>
<tr><td><code id="criterion_+3A_delta">delta</code></td>
<td>

<p>If the &quot;FDP.control.method&quot; is set to 'Romano' then the user can set the 
exceedance thresh-hold for the FDP tail probability control
<code class="reqn">P\{ FDP &gt; \delta \} &lt; \alpha</code>. The default value is <code class="reqn">\alpha</code>.
</p>
</td></tr>
<tr><td><code id="criterion_+3A_n.tests">N.tests</code></td>
<td>

<p>The number of simultaneous hypothesis tests. 
</p>
</td></tr>
<tr><td><code id="criterion_+3A_fdp.control.method">FDP.control.method</code></td>
<td>

<p>A character string specifying how the false discovery proportion (FDP) is to be
controlled. You may specify the whole word or any shortened uniquely
identifying truncation. <br />
&quot;BHFDR&quot;: the usual BH-FDR <br />
&quot;Romano&quot;: use Romano's method which guarantees probability less than 
alpha that the FDP exceeds alpha. 
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The step down or step up criterion, which is a vector of length N.tests
</p>


<h3>Author(s)</h3>

<p>Grant Izmirlian &lt;izmirlian at nih dot gov&gt;
</p>


<h3>References</h3>

<p>Benjamini Y, Hochberg Y. Controlling the false discovery rate - a practical
and powerful approach to multiple testing. J. R. Stat. Soc. Ser. B
Stat. Methodol. 1995; 57(1):289-300.
</p>
<p>Romano J.P. and Shaikh A.M. On stepdown control of the false discovery
proportion. IMS Lecture Notes&ndash;Monograph Series. 2006; 49:33-50.
DOI: 10.1214/074921706000000383.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  library(pwrFDR)

  crit.b &lt;- criterion(N.tests=1000, alpha=0.15, FDP.control.method="BHFDR")
  crit.r &lt;- criterion(N.tests=1000, alpha=0.15, FDP.control.method="Romano")
  crit.r.17 &lt;- criterion(N.tests=1000, alpha=0.15, delta=0.17, FDP.control.method="Romano")
  matplot(1:1000, cbind(crit.b, crit.r, crit.r.17), type="l", lty=1, col=2:4)
</code></pre>

<hr>
<h2 id='detail'>
The detail extraction function for simulated power objects
</h2><span id='topic+detail'></span>

<h3>Description</h3>

<p>Objects created by the <code>pwrFDR</code> function with option
<code>method</code>==&quot;simulation&quot; are returned with an attribute named
<code>detail</code>. This is its extractor function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>detail(obj)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="detail_+3A_obj">obj</code></td>
<td>

<p>An object created by the <code>pwrFDR</code> function with option
<code>method</code>==&quot;simulation&quot;.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with components
</p>
<table role = "presentation">
<tr><td><code>reps</code></td>
<td>
<p>A data frame of <code>n.sim</code> rows containing the results of 
the simulations as columns: <code>M1</code>, the # of non-null distributed
statistics, <code>R</code>, the # of statistical tests rejected under the
BH-FDR procedure, and <code>T</code>, the # of true positives.
Depending on the value of <code>FDP.control.method</code>, additional
values are returned:<br />
FDP.control.method:<br />
&quot;BHFDR&quot;: nothing further<br />
&quot;BHFDX&quot;: In addition to <code>M1</code>, <code>R</code> and <code>T</code>, we compute
<code>R.st</code> and <code>T.st</code>, the # of tests rejected under
the BHFDX procedure, and among those tests rejected, the #
of true positives.<br />
&quot;Romano&quot;: In addition to <code>M1</code>, <code>R</code> and <code>T</code>, we compute
<code>R.R</code> and <code>T.R</code>, the # of tests rejected under
Romano's procedure, and among those tests rejected, the #
of true positives.<br />
&quot;both&quot;: If 'both' is specified then counts of all rejected tests
and of true positive tests under BHFDX and under Romano
are returned along with those counts for BHFDr.    
</p>
</td></tr>
<tr><td><code>X</code></td>
<td>
<p>A single simulation replicate of the <code>m</code> raw test
statistics, included as a sanity check</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Grant Izmirlian izmirlig at mail dot nih dot gov
</p>

<hr>
<h2 id='dists'>
The Distribution family object
</h2><span id='topic+dists'></span>

<h3>Description</h3>

<p>The <code>pwrFDR</code> package currently incorporates 3 distribution types,
normal, t and F. The first two of these are strictly for statistics formed 
from two group comparison while the third is for statistics formed from the 
omnibus test of any difference among an arbitrary number of groups &gt;=2. The
structure is general and user expandable. One must specify the density, 
CDF and quantile function for a given distribution and its parameters under
the null and under the alternative. These parameters must be expressions
to be evaluated inside the kernel of the power program, functions of the
arguments <code>n.sample</code>, <code>groups</code> and <code>effect.size</code>. This is 
not used directly by the user at all unless she (he) wants to add a 
distribution type. 
</p>


<h3>Format</h3>

<p>A data frame with 3 observations on the following 6 variables.
</p>

<dl>
<dt><code>pars0</code></dt><dd><p>a list vector having components 'c(nd, p1, p2, ...)'
where 'nd' is the distribution number starting with 0,
and p1, p2, ..., are paramters of the distribution,
which are functions of 'n.sample', 'groups' and 
'effect.size' as mentioned above.  These must be 
expressed as a call e.g.  
as.call(expression(c, nd, p1, p2, ...))  etc.
'pars0' are the parameters under the null.</p>
</dd>
<dt><code>pars1</code></dt><dd><p>a list vector. See directly above. Parameters under the 
alternative.</p>
</dd>
<dt><code>minv</code></dt><dd><p>a list vector with components given the values -Inf or 0,
which will be used to decide if the two sided corrections
are used or not.</p>
</dd>
<dt><code>ddist</code></dt><dd><p>a list vector with components set to functions, each one 
computing the probability density function corresponding
to the particular distribution. A function of
arguments 'x' and 'par'. See details below.</p>
</dd>
<dt><code>pdist</code></dt><dd><p>a list vector with components set to the functions, each
one computing the cumulative distribution function 
corresponding to the particular distribution. A function
of arguments 'x' and 'par'. See details below.</p>
</dd>
<dt><code>qdist</code></dt><dd><p>a list vector with components set to the functions, each
one computing the quantile function (inverse cumulative 
distribution function) corresponding to the particular 
distribution. A function of arguments 'x' and 'par'. 
See details below.</p>
</dd>
<dt><code>rdist</code></dt><dd><p>a list vector with components set to the functions, each
one capable of simulating a specified number of
replicates corresponding to the particular 
distribution. A function of arguments 'n' and 'par'. 
See details below.</p>
</dd>
</dl>



<h3>Details</h3>

<p><code>dists</code> is a data.frame with components <code>pars0</code>, <code>pars1</code>, 
<code>minv</code>, <code>ddist</code>, <code>pdist</code>, <code>qdist</code> and <code>rdist</code>. 
For the three available distribution options, &quot;normal&quot;, &quot;t&quot; and &quot;f&quot;,
the components <code>pars0</code> and <code>pars1</code> take the following form:<br />
</p>

<table>
<tr>
 <td style="text-align: left;">
1. pars0                              </td><td style="text-align: left;">  pars1                                    </td>
</tr>
<tr>
 <td style="text-align: left;">
2. c(0,ncp=0,sd=1)                    </td><td style="text-align: left;">  c(0,ncp=.NCP.,sd=1)                      </td>
</tr>
<tr>
 <td style="text-align: left;">
3. c(1,ncp=0,ndf=.DF.)                </td><td style="text-align: left;">  c(1,ncp=.NCP.,ndf=.DF.)                  </td>
</tr>
<tr>
 <td style="text-align: left;">
4. c(2,ncp=0,ndf1=groups-1,ndf2=.DF.) </td><td style="text-align: left;">  c(2,ncp=.NCP.^2,ndf1=groups-1,ndf2=.DF.) </td>
</tr>

</table>

<p>The component <code>minv</code> gives the minumum value of the support set of the
distribution. For the above named three available distribution options,
<code>minv</code> is set to the values -Inf, -Inf and 0, respectively. The components
<code>ddist</code>, <code>pdist</code>, <code>qdist</code>, and <code>rdist</code> contain functions
defining the density, CDF, quantile, and simulator function, respectively. For
the above named three available distribution options, <code>ddist</code> takes
the following form:<br />
</p>

<table>
<tr>
 <td style="text-align: left;">
1. ddist                                                             </td>
</tr>
<tr>
 <td style="text-align: left;">
2. function (x, par) dnorm(x, mean = par[2], sd = par[3])            </td>
</tr>
<tr>
 <td style="text-align: left;">
3. function (x, par) dt(x, ncp = par[2], df = par[3])                </td>
</tr>
<tr>
 <td style="text-align: left;">
4. function (x, par) df(x, ncp = par[2], df1 = par[3], df2 = par[4]) </td>
</tr>
<tr>
 <td style="text-align: left;">
exept for rdist, which has arguments 'n' and 'par'</td>
</tr>

</table>

<p>The components <code>pdist</code> and <code>qdist</code> are nearly identical to the
component <code>ddist</code>, but with pnorm, pt, pf and qnorm, qt, qf replacing
dnorm, dt and df, respectively.<br />
The variables, <code>.NCP.</code> and <code>.DF.</code> named above are defined within the
functions in which <code>ddist</code> is used based upon corresponding expressions,
<code>NCP</code> and <code>DF</code>. These expressions currently contain 3 component
expressions, one for each of the available test types, &quot;paired&quot;, &quot;balanced&quot;
and &quot;unbalanced&quot;.<br />
<code>NCP</code> is currently defined:<br />
</p>

<table>
<tr>
 <td style="text-align: left;">
1. NCP                                                                  </td>
</tr>
<tr>
 <td style="text-align: left;">
expression(n.sample^0.5*effect.size,(n.sample/groups)^0.5*effect.size,  </td>
</tr>
<tr>
 <td style="text-align: left;">
   ((n.sample-1)/(1+sum((n.sample-1)/(nii.sample-1))))^0.5*effect.size) </td>
</tr>

</table>

<p>and <code>DF</code> is currently defined:<br />
</p>

<table>
<tr>
 <td style="text-align: left;">
1. DF                                                                   </td>
</tr>
<tr>
 <td style="text-align: left;">
expression(n.sample - 1, groups * (n.sample - 1),                       </td>
</tr>
<tr>
 <td style="text-align: left;">
           groups^2*(n.sample-1)/(1+sum((n.sample-1)/(nii.sample-1))))	</td>
</tr>

</table>



<h3>Source</h3>

<p>This isn't 'data' data, its a kind of a 'family' object.
</p>
<p>Izmirlian G. (2020) Strong consistency and asymptotic normality for
quantities related to the Benjamini-Hochberg false discovery rate
procedure. Statistics and Probability Letters;
&lt;doi:10.1016/j.spl.2020.108713&gt;
</p>
<p>Izmirlian G. (2017) Average Power and <code class="reqn">\lambda</code>-power in
Multiple Testing Scenarios when the Benjamini-Hochberg False
Discovery Rate Procedure is Used. &lt;arXiv:1801.03989&gt;
</p>

<hr>
<h2 id='es.ROC'>
Computes the equivalent Z-test effect size in hypothesis tests
involving the ROC. Included here with the intent that it can be
used in conjunction with <code><a href="#topic+pwrFDR">pwrFDR</a></code> to allow power/sample
size calculation for multiple tests of ROC curve based hypothesis.
See details. 
</h2><span id='topic+es.ROC'></span>

<h3>Description</h3>

<p>In hypothesis tests of TPR_1 vs TPR_0 at fixed FPR, or
FPR_1 vs FPR_0 at fixed TPR, this computes the
equivalent Z-test effect size. This can then be passed
the <code>effect.size</code> argument in a call to
<code><a href="#topic+pwrFDR">pwrFDR</a></code> or <code><a href="#topic+controlFDP">controlFDP</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  es.ROC(FPR0, FPR1 = NULL, TPR0, TPR1 = NULL, b = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="es.ROC_+3A_fpr0">FPR0</code></td>
<td>

<p>When the TPR is fixed, the FPR under the null. Otherwise the fixed FPR.
</p>
</td></tr>
<tr><td><code id="es.ROC_+3A_fpr1">FPR1</code></td>
<td>

<p>When the TPR is fixed, the FPR under the alternative. Otherwise left blank.
</p>
</td></tr>
<tr><td><code id="es.ROC_+3A_tpr0">TPR0</code></td>
<td>

<p>When the FPR is fixed, the TPR under the null. Otherwise the fixed TPR.
</p>
</td></tr>
<tr><td><code id="es.ROC_+3A_tpr1">TPR1</code></td>
<td>

<p>When the FPR is fixed, the TPR under the alternative. Otherwise left blank.
</p>
</td></tr>
<tr><td><code id="es.ROC_+3A_b">b</code></td>
<td>

<p>Nominal slope of the ROC at FPR0. Taken to be 1 by default.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The equivalent Z-test effect size in a hypothesis test for
difference in TPR at fixed FPR or difference in FPR at fixed TPR
</p>


<h3>Author(s)</h3>

<p>Grant Izmirlian &lt;izmirlian at nih dot gov&gt;
</p>


<h3>References</h3>

<p>Pepe M. S., Feng Z, Janes, H Bossuyt P. M. and Potter J. D. Pivotal
evaluation of the accuracy of a biomarker used for classification or
prediction. Supplement. J Natl Cancer Inst 2008;100: 1432&ndash;1438
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cc.ROC">cc.ROC</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    es.ROC(FPR0=0.15, TPR0=0.80, TPR1=0.90)
</code></pre>

<hr>
<h2 id='gentempfilenm'>
Generate a tempfile name
</h2><span id='topic+gentempfilenm'></span>

<h3>Description</h3>

<p>Generates a tempfile name with an optional user specified prefix and suffix
Result is a character string
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  gentempfilenm(prfx = "temp", sfx = ".txt")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gentempfilenm_+3A_prfx">prfx</code></td>
<td>

<p>prefix for the file name, e.g. &quot;temp&quot;
</p>
</td></tr>
<tr><td><code id="gentempfilenm_+3A_sfx">sfx</code></td>
<td>

<p>suffix (file extension) for the file name, e.g. &quot;.txt&quot;
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a character string containing the randomly generated name of the
tempfile.
</p>


<h3>Author(s)</h3>

<p>Grant Izmirlian izmirlig at mail dot nih dot gov
</p>

<hr>
<h2 id='if.0.rm'>
A helper function&ndash; remove if zero.
</h2><span id='topic+if.0.rm'></span>

<h3>Description</h3>

<p>A helper function&ndash; remove if zero. Included at the user level because
it's useful for setting up batch jobs. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  if.0.rm(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="if.0.rm_+3A_x">x</code></td>
<td>

<p>A numeric vector.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector, equal to the input vector, <code>x</code>, except with 0's
removed.
</p>


<h3>Author(s)</h3>

<p>Grant Izmirlian &lt;izmirlian at nih dot gov&gt;  
</p>

<hr>
<h2 id='if.na.x'>
A helper function &ndash; substitute 'NA's with a specified 'x'.
</h2><span id='topic+if.na.x'></span>

<h3>Description</h3>

<p>A helper function &ndash; substitute 'NA's with a specified 'x'. Included
at the user level because it's useful for setting up batch jobs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  if.na.x(x, x0 = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="if.na.x_+3A_x">x</code></td>
<td>

<p>A numeric or boolean vector.
</p>
</td></tr>
<tr><td><code id="if.na.x_+3A_x0">x0</code></td>
<td>

<p>Value with which to replace <code>NA</code>'s. Defaults to 0 or <code>FALSE</code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector, equal to the input vector, <code>x</code>, except with <code>NA</code>'s
replaced by the value, <code>x0</code>, which the user suplied. 
</p>


<h3>Author(s)</h3>

<p>Grant Izmirlian &lt;izmirlian at nih dot gov&gt;  
</p>

<hr>
<h2 id='if.y.z'>
A helper function &ndash; substitute <code>y</code>'s with a specified 'z'.
</h2><span id='topic+if.y.z'></span>

<h3>Description</h3>

<p>A helper function &ndash; in a numeric vector, substitute values equal to
'y' with user specified 'z'. Included at the user level because it's
useful for setting up batch jobs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  if.y.z(x, y = 0, z = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="if.y.z_+3A_x">x</code></td>
<td>

<p>A numeric, character or boolean vector
</p>
</td></tr>
<tr><td><code id="if.y.z_+3A_y">y</code></td>
<td>

<p>The valued to be swapped out
</p>
</td></tr>
<tr><td><code id="if.y.z_+3A_z">z</code></td>
<td>

<p>The value which replaces swapped out values
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric, character or boolean vector, equal to the input vector,
<code>x</code>, except with occurences <code>y</code> replaced with the value <code>z</code>
</p>


<h3>Author(s)</h3>

<p>Grant Izmirlian &lt;izmirlian at nih dot gov&gt;  
</p>

<hr>
<h2 id='join.tbl'>
Combine pwrFDR Results
</h2><span id='topic+join.tbl'></span>

<h3>Description</h3>

<p>Joins pwrFDR objects into a single table.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>join.tbl(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="join.tbl_+3A_...">...</code></td>
<td>

<p>obj1, obj2, ... each being the result of a call to pwrFDR.
See the example below.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The table of joined pwrFDR objects as a data.frame 
</p>


<h3>Author(s)</h3>

<p>Grant Izmirlian
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  rslt.avgp.r15 &lt;- pwrFDR(effect.size = 0.79, average.power=0.80, r.1 = 0.15, alpha = 0.15)
  rslt.avgp.r10 &lt;- update(rslt.avgp.r15, r.1 = 0.10)
  rslt.avgp.r05 &lt;- update(rslt.avgp.r15, r.1 = 0.05)

  join.tbl(rslt.avgp.r15, rslt.avgp.r10, rslt.avgp.r05)
</code></pre>

<hr>
<h2 id='logit'>
Computes the logit transform
</h2><span id='topic+logit'></span>

<h3>Description</h3>

<p>Computes the logit transform for objects of type numeric and 
objects of class &quot;pwr&quot;.   
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  logit(mu)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="logit_+3A_mu">mu</code></td>
<td>

<p>A real number on the interval [0, 1]
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric equal to the logit of mu, a real number.
</p>


<h3>Author(s)</h3>

<p>Grant Izmirlian &lt;izmirlian at mail.nih.gov&gt;
</p>

<hr>
<h2 id='logitInv'>
Computes the inverse logit transform
</h2><span id='topic+logitInv'></span>

<h3>Description</h3>

<p>Computes the inverse logit transform for objects of type 
numeric and objects of class &quot;pwr&quot;.   
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  logitInv(eta)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="logitInv_+3A_eta">eta</code></td>
<td>

<p>Any real number 
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric equal to the logit inverse of mu, a real 
number on the interval [0, 1]
</p>


<h3>Author(s)</h3>

<p>Grant Izmirlian &lt;izmirlian at mail.nih.gov&gt;
</p>

<hr>
<h2 id='nna'>
A helper function&ndash; turns a missing column into 'NA's inside of a with statement
</h2><span id='topic+nna'></span>

<h3>Description</h3>

<p>A helper function&ndash; turns a missing column into 'NA's inside of a with
statement. Included at the user level because its useful in setting up
batch jobs, especially since the 'pwrFDR' return argument list varies
depending on the manner called.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  nna(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nna_+3A_x">x</code></td>
<td>

<p>A named numeric vector component of a data frame which may or may not be present.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Either the values in the component <code>x</code> of the data.frame or NA\'s of equal length
</p>


<h3>Author(s)</h3>

<p>Grant Izmirlian &lt;izmirlian at nih dot gov&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  sim.1 &lt;- pwrFDR(effect.size=0.8, n.sample=60, lambda=0.90, r.1=0.05, N.tests=450, alpha=0.15,
                  method="sim", FDP.control.method="BHFDX")

  sim.2 &lt;- pwrFDR(effect.size=0.8, n.sample=60, lambda=0.90, r.1=0.05, N.tests=450, alpha=0.15,
                  method="sim", FDP.control.method="both", control=list(sim.level=2))

  with(detail(sim.1)$reps, cbind(R.st/100, nna(R.R)/450))

  with(detail(sim.2)$reps, cbind(R.st/100, nna(R.R)/450))
</code></pre>

<hr>
<h2 id='paste'>The paste operator</h2><span id='topic+paste'></span><span id='topic++25+2C+25'></span>

<h3>Description</h3>

<p>A binary operator shortcut for paste(x,y)</p>


<h3>Usage</h3>

<pre><code class='language-R'>x %,% y
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="paste_+3A_x">x</code></td>
<td>
<p>a character string</p>
</td></tr>
<tr><td><code id="paste_+3A_y">y</code></td>
<td>
<p>a character string</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The concatenated character string 
</p>


<h3>Author(s)</h3>

<p>Grant Izmirlian <a href="mailto:izmirlian@nih.gov">izmirlian@nih.gov</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>  library(pwrFDR)
  "var" %,% (1:10)
</code></pre>

<hr>
<h2 id='pwrFDR'>
Ensemble power or sample size under selected control of the FDP 
</h2><span id='topic+pwrFDR'></span>

<h3>Description</h3>

<p>This is a function for calculating two differing notions of power, or deriving sample
sizes for specified requisite power in multiple testing experiments under a variety of methods for
control of the distribution of the False Discovery Proportion (FDP). More specifically, one can
choose to control the FDP distribution according to control of its (i) mean, e.g. the usual BH-FDR
procedure, or via the probability that it exceeds a given value, delta, via (ii) the Romano
procedure, or via (iii) my procedure based upon asymptotic approximation. Likewise, we can think of
the power in multiple testing experiments in terms of a summary of the distribution of the
True Positive Proportion (TPP). The package will compute power, sample size or any other missing
parameter required for power based upon (i) the mean of the TPP which is the average power
(ii) the probability that the TPP exceeds a given value, lambda, via my asymptotic approximation
procedure. The theoretical results are described in Izmirlian, G. (2020), and an applied paper 
describing the methodology with a simulation study is in preparation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  pwrFDR(effect.size, n.sample, r.1, alpha, delta = NULL, groups = 2, N.tests,
         average.power, TPX.power, lambda, type = c("paired","balanced","unbalanced"),
         grpj.per.grp1=NULL, corr.struct=list(type=c("CS-Blocks","Toeplitz-Blocks"),
                                              block.size=NA, rho = NA),
         FDP.control.method = c("BHFDR","BHFDX","Romano","Auto","both","Holm","Hochberg",
                                "Bonferroni"),
         distopt=1, method = c("Theoretical","simulation"), n.sim = 1000, temp.file,
         control=list(tol=1e-08, max.iter=c(1000, 20), sim.level=2, low.power.stop=TRUE, 
                      FDP.meth.thresh=FDP.cntl.mth.thrsh.def, ast.le.a=TRUE, verb=FALSE,
                      show.footer=TRUE)) 
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pwrFDR_+3A_effect.size">effect.size</code></td>
<td>

<p>The effect size (mean over standard deviation) for test statistics 
having non-zero means. Assumed to be a constant (in magnitude) over
non-zero mean test statistics.
</p>
</td></tr>
<tr><td><code id="pwrFDR_+3A_n.sample">n.sample</code></td>
<td>

<p>The number of experimental replicates. Required for calculation
of power
</p>
</td></tr>
<tr><td><code id="pwrFDR_+3A_r.1">r.1</code></td>
<td>

<p>The proportion of simultaneous tests that are non-centrally located 
</p>
</td></tr> 
<tr><td><code id="pwrFDR_+3A_alpha">alpha</code></td>
<td>

<p>The false discovery rate (in the BH case) or the upper bound on the
probability that the FDP exceeds delta (BHFDX and Romano case)
</p>
</td></tr>
<tr><td><code id="pwrFDR_+3A_delta">delta</code></td>
<td>

<p>If the &quot;FDP.control.method&quot; is set to 'Romano' or 'BHFDX', then the
user can set the exceedance thresh-hold for the FDP tail probability
control <code class="reqn">P\{ FDP &gt; \delta \} &lt; \alpha</code>. The default value is
<code class="reqn">\alpha</code>.
</p>
</td></tr>
<tr><td><code id="pwrFDR_+3A_groups">groups</code></td>
<td>

<p>The number of experimental groups to compare. Must be integral and
&gt;=1. The default value is 2.
</p>
</td></tr>
<tr><td><code id="pwrFDR_+3A_n.tests">N.tests</code></td>
<td>

<p>The number of simultaneous hypothesis tests. 
</p>
</td></tr>
<tr><td><code id="pwrFDR_+3A_average.power">average.power</code></td>
<td>

<p>The desired average power. Sample size calculation requires
specification of either 'average.power' or 'TPX.power'.
</p>
</td></tr>
<tr><td><code id="pwrFDR_+3A_tpx.power">TPX.power</code></td>
<td>

<p>The desired tp-power (see details for explanation). Sample
size calculation requires specification of either 'average.power'
or 'TPX.power'.
</p>
</td></tr>
<tr><td><code id="pwrFDR_+3A_lambda">lambda</code></td>
<td>

<p>The tp-power threshold, required when calculating the tp-power
(see details for explanation) or when calculating the sample size
required for tp-power.    
</p>
</td></tr>
<tr><td><code id="pwrFDR_+3A_type">type</code></td>
<td>

<p>A character string specifying, in the groups=2 case, whether the
test is 'paired', 'balanced', or 'unbalanced' and in the case when
groups &gt;=3, whether the test is 'balanced' or 'unbalanced'. The
default in all cases is 'balanced'. Left unspecified in the one
sample (groups=1) case. 
</p>
</td></tr>
<tr><td><code id="pwrFDR_+3A_grpj.per.grp1">grpj.per.grp1</code></td>
<td>

<p>Required when <code>type</code>=&quot;unbalanced&quot;, specifies the group 0 to
group 1 ratio in the two group case, and in the case of 3 or more
groups, the group j to group 1 ratio, where group 1 is the group
with the largest effect under the alternative hypothesis. 
</p>
</td></tr>
<tr><td><code id="pwrFDR_+3A_corr.struct">corr.struct</code></td>
<td>
<p>Specifies a block correlation structure between test
statistics which is used in both the simulation routine, and in the
computations based upon asymptotic approximation, e.g. the AFDX
control and the ATPP method. Its form is specified via the following
named elements.<br />
&quot;type&quot;: a string taking the value &quot;CS-Blocks&quot; for compound 
compound symmetry within blocks or &quot;Toeplitz-Blocks&quot;
for toeplitz within blocks, respectively.<br />
&quot;block.size&quot;: the size of the correlated blocks<br />
&quot;rho&quot;: When type=&quot;CS-Blocks&quot;, then 'rho' is a correlation of length 1
when type=&quot;Toeplitz-Blocks&quot;, then 'rho' is a vector of
correlations of length 'block.size' - 1
</p>
</td></tr>
<tr><td><code id="pwrFDR_+3A_fdp.control.method">FDP.control.method</code></td>
<td>

<p>A character string specifying how the false discovery proportion (FDP) is to be
controlled. You may specify the whole word or any shortened uniquely
identifying truncation. <br />
&quot;BHFDR&quot;: the usual BH-FDR <br />
&quot;BHFDX&quot;: guarantees control of the FDX e.g. probability that the FDP exceeds 
delta will be less than alpha. Uses asymptotic approximationto the 
distribution of the FDP to find alpha* such that the BHFDR
procedure controls the FDX at alpha. Only slightly more conservative
than BHFDR control at alpha. Allows dependence which must be specified.
Not guaranteed to have a solution in all cases, in which case Romano's
procedure is used as a fall-back.<br />
&quot;Romano&quot;: use Romano's method which guarantees control of the FDX,
e.g. the probability that the FDP exceeds delta will
be less than alpha. <br />
&quot;Auto&quot;: in 'FixedPoint' mode, the program will use its own 
wisdom to determine which choice above to make. The 
order of conservatism is<br />
Bonferroni &gt; Holm &gt; Hochberg &gt; Romano &gt; BHFDX &gt; BHFDR,<br />
but BHFDR offers only expected control, the most
conservative 3 control the FWER and the other two 
guarantee bounds on the excedance probabilty. If the 
distribution of the FDP is nearly degenerate, then BHFDR 
is the best option. Otherwise, if it can be reliably used, 
BHFDX would be the best choice. The 'effective' denominator, 
gamma*N.tests, in the CLT determines when the approximation 
is good enough and the asymptotic standard error of the FDP 
determines when the distribution is dispersed enough to matter.
Use &quot;Auto&quot; to run through these checks and determine the best. 
A return argument, 'Auto', displays the choice made. See 
output components and details. <br />
&quot;both&quot;: in 'simulation' mode, compute statistics R and T under BHFDX
and Romano (in addition to BHFDR). Corresponding
statistics are denoted R.st, T.st corresponding to BHFDX
control of the FDP, and R.R and T.R corresponding to
Romano control of the FDP. If sim.level is set to 2,
(default) the statistics R.st.ht and T.st.ht, which are
the number rejected and number true positives under BHFDX
where r_0 = 1-r_1, gamma, and alpha.star have been estimated 
from the P-value data and then alpha.star computed from
these.<br />
&quot;Holm&quot;: Use Holm's step-down procedure which guarantees control of the
family-wise error rate (FWER)
&quot;Hochberg&quot;: Use Hochberg's step-up procedure which guarantees control
of the FWER if the tests are independent. Less conservative 
than Holm and Bonferroni but more conservative than all other 
procedures here.<br />
&quot;Bonferroni&quot;: Use the Bonferroni procedure. Guarantees control of the FWER.
the most conservative of procedures offered here.
</p>
</td></tr>
<tr><td><code id="pwrFDR_+3A_distopt">distopt</code></td>
<td>
<p>Test statistic distribution in among null and
alternatively distributed sub-populations.
distopt=0 gives normal (2 groups), distop=1 gives t- (2 groups)
and distopt=2 gives F- (2+ groups)
</p>
</td></tr>  
<tr><td><code id="pwrFDR_+3A_method">method</code></td>
<td>
<p>Specify the method whereby the average power is calculated. 
You may specify the whole word or any unqiuely indentifying  
truncation.<br />
&quot;Theoretical&quot;: for all procedures but Bonferroni, use the fixed
point method, e.g., first find the solution to the equation 
u = G(alpha u) where G is the CDF of the pooled P-values. 
This solution gives 'gamma', the positive proportion. The average 
power and TPX power can then be determined e.g.
average.power = G_1( gamma alpha), where G_1 is the CDF
of the P-values corresponding to statistics drawn under H_A. 
TPX power is determined via asymptotic approximation.<br />
&quot;simulation&quot;: uses brute force simulation to determine the
average power and TPX power. 
</p>
</td></tr>
<tr><td><code id="pwrFDR_+3A_control">control</code></td>
<td>
<p>Optionally, a list with components with the following  
components: <br />
'tol' is a convergence criterion used in iterative 
methods which is set to 1e-8 by default.<br />
'max.iter' is an iteration limit, set to 20 for the iterated
function limit and 1000 for all others by default.<br />
'sim.level' sim level 2 (default) stipulates, when FDP.control.method
is set to &quot;BHFDX&quot;, or &quot;both&quot;, R.st.ht and T.st.ht are
computed in addition to R.st and T.st (see above). <br />
'low.power.stop' in simulation option, will result in an error message 
if the power computed via FixedPoint method is too low, which 
result in no solution for the BHFDX option. Default setting is TRUE. 
Set to FALSE to over-ride this behavior. <br />
'FDP.meth.thresh' fine-tunes the 'Auto' voodoo (see above). Leave 
this alone. <br />
'ast.le.a' leaving this at the default value TRUE forces
'alpha.star', the solution under FDP.method.control=&quot;BHFDX&quot;,
to be less than the specified 'alpha'.<br />
'verb' vebosity level.<br />
'show.footer' optionally, show a textual output
</p>
</td></tr>
<tr><td><code id="pwrFDR_+3A_n.sim">n.sim</code></td>
<td>
<p>If 'simulation' method is chosen you may specify number of
simulations. Default is 1000.
</p>
</td></tr>
<tr><td><code id="pwrFDR_+3A_temp.file">temp.file</code></td>
<td>
<p>If 'simulation' method is chosen you may specify a tempfile 
where the current simulation replicate is updated. Very 
usefull for batch runs. You can use the included utility
'gentempfilenm'
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function will compute one of a variety of ensemble powers
under a given choice of FDP control methods. The underlying
model assumes that the m simultaneous test statistics are
i.i.d., each being formed from k samples which can be paired
(k=2), balanced or unbalanced (k&gt;=2), k=1,2,..., and distributed
according to one of the available relevent distribution types
(see above). The location parameter for each of the statistical
tests is either 0 (null hypothesis) or a specified constant
effect size (alternative hypothesis), with the identity of these
two possibilities in each of the m cases being an i.i.d. unmeasured 
latent bernouli variable with density r.1, the mixing
proportion. The m simultaneous statistical tests partition into
those which are distributed according to the alternative,
numbering M_m, and those distributed according to the NULL,
numbering m-M_m. Once a selected thresholding method is
applied, the m statistics can also be partitioned into those
which are called significant, numbering R_m, and those which
are not, numbering m-R_m. Each of the test statistics is thus
given two labels, alternative hypothesis membership and whether
a significant call was made. Of the R_m significant calls, T_m
are true positives and V_m are false positives. This results in
the following table.  
</p>

<table>
<tr>
 <td style="text-align: right;">
         1. </td><td style="text-align: right;">             </td><td style="text-align: center;"> rej H0  </td><td style="text-align: center;"> acc H0	         </td><td style="text-align: center;"> row Total </td>
</tr>
<tr>
 <td style="text-align: right;">
         2. </td><td style="text-align: right;"> H0 is FALSE </td><td style="text-align: center;"> T_m     </td><td style="text-align: center;"> M.1-T             </td><td style="text-align: center;">	 M_m    </td>
</tr>
<tr>
 <td style="text-align: right;">
         3. </td><td style="text-align: right;"> H0 is TRUE  </td><td style="text-align: center;"> R_m-T_m </td><td style="text-align: center;"> (m-M_m)-(R_m-T_m) </td><td style="text-align: center;">  m - M_m  </td>
</tr>
<tr>
 <td style="text-align: right;">
         4. </td><td style="text-align: right;"> col Total   </td><td style="text-align: center;"> R       </td><td style="text-align: center;"> m-R_m	         </td><td style="text-align: center;">	 m      </td>
</tr>

</table>

<p>The ratio of the false positive count to the significant call
count, V_m/R_m, is called the False Discovery Proportion
(FDP). Thresholding methods which result in the most 
reproducibility seek to control the FDP distribution. The most
well known is the Benjamini-Hochberg False Discovery Rate
(BH-FDR) procedure. It guarantees that the FDR, which is the
expected FDP, will be less than a stipulated alpha
</p>
<p><code class="reqn">E[ V_m / R_m ] &lt; \alpha</code>
</p>
<p>While it is true that for large m, the distribution of the FDP,
V_m/M_m will become spiked at its mean, <code class="reqn">(1-r_1)\alpha</code>, in
many commonly occuring situations, there will still be
non-negligible dispersion in the distribution of the FDP. For
this reason, any validity promised by the BH-FDR procedure does
not actually apply on a case to case basis, and individual FDP's
may differ non-negligibly from the FDR. For this reason, the
function supplies two other methods of FDP control in addition to
FDP.control.method=&quot;BHFDR&quot;. These two alternate methods,
FDP.control.method=&quot;Romano&quot; and FDP.control.method=&quot;BHFDX&quot;
guarantee control of the tail probability of the FDP
distribution:
</p>
<p><code class="reqn">P\{ V_m/R_m &gt; \delta \} &lt; \alpha</code>
</p>
<p>The lower bound <code class="reqn">\delta</code> is left arbitrary for greater
flexibility, <code class="reqn">\delta=\alpha</code> being the default. There is
also an automatic option, FDP.control.method=&quot;Auto&quot;, which lets
the function decide which of the three FDP control methods is
the most advisable in a given situation. The two tail
probability control options are preferred when the standard
error of the FDP exceeds a cutoff given in the default
'control' settings:
</p>
<p>se[V_m/R_m] / alpha &gt; FDP.cntl.mth.thrsh.def[1]
</p>
<p>The default is 10%. When the standard error to alpha ratio is
10% or less then the BHFDR, being the least conservative, is
preferred. When the se to alpha ratio is 10% or more, then
Romano and BHFDX are decided between, with the BHFDX (asymptotic
approximation) being less conservative than Romano and therefor
preferred if the CLT approximation is adequate. This will be the
case provided <code class="reqn">m</code> is large enough,
</p>
<p><code class="reqn">m \geq</code> FDP.cntl.mth.thrsh.def[2]. The default is 50. 
</p>
<p>The concept of ensemble power for the purposes of this function,
concern the distribution of the true positive proportion (TPP),
<code class="reqn">T_m/M_m</code>. The most well known is the average power, which
is the expected value of the TPP, which is called the true
positve rate (TPR):
</p>
<p><code class="reqn">E[ T_m/M_m ] = average power</code>
</p>
<p>For large m, the distribution of the TPP will be spiked at its
mean, which is the asymptotic average power. This is used in
the function in the average power computation. As was the case
for the FDP, there are many commonly occuring situations when
the distribution of the TPP will still be non-negligibly
dispersed. For this reason, we provide an alternate notion of
power which is based upon the tail probability of the TPP
distribution: 
</p>
<p><code class="reqn">P\{ T_m/M_m &gt; \lambda \} = tp-power</code>
</p>
<p>This is computed via asymptotic approximation and also requires
that <code class="reqn">m</code> be large enough: <code class="reqn">m &gt; 50</code>. The user decides
when the tp-power is to be preferred. A good check is to look
at the ratio of the se[TPP] to average power ratio which is the
sigma.rtm.TPP/average.power/N.tests^0.5 If this ratio is
unacceptibly large (10% or so) than the tp-power is preferred.
</p>
<p>For the &quot;FixedPoint&quot; method (default) and for any specified choice 
of FDP.control method, the function can be used in the following ways:
</p>
<p>1. Specify 'n.sample', 'effect.size', 'r.1' and 'alpha'. Calculates
'average power'
</p>
<p>2. Specify 'n.sample', 'effect.size', 'r.1', 'alpha' and 'lambda'. 
'N.tests' is also required. The function wil calculate the 'TPX.power'
in addition to the 'average power'.
</p>
<p>3. Specify the 'average.power' or the pair 'TPX.power' and 'lambda'. 
Specify all but one of the parameters, 'n.sample', 'effect.size', 'r.1' 
and 'alpha'. The function will calculate the value of the missing 
parameter required for the specified 'average power' or 'tp-power'. 
Note: a solution is guaranteed for missing 'n.sample' and missing
'effect.size', but not necessarily for missing 'r.1' or
'alpha'. 
</p>
<p>The Holm, Hochberg and Bonferroni procedures for controlling
the FWER under the assumption of independent test statistics
are also provided for sake of completeness.
</p>


<h3>Value</h3>

<p>An object of class &quot;pwr&quot; with with components including:
</p>
<table role = "presentation">
<tr><td><code>call</code></td>
<td>
<p>The call which produced the result</p>
</td></tr>
<tr><td><code>average.power</code></td>
<td>
<p>Resulting average power.</p>
</td></tr>
<tr><td><code>TPX.power</code></td>
<td>
<p>When 'lambda' is specified, the tp-power is also computed</p>
</td></tr>
<tr><td><code>L.eq</code></td>
<td>
<p>The lambda at which the tp-power and average-power are equal.</p>
</td></tr>
<tr><td><code>n.sample</code></td>
<td>
<p>If 'n.sample' is missing from the argument list, then
the sample size required for the specified average- or lambda-
power.</p>
</td></tr>
<tr><td><code>alpha.star</code></td>
<td>
<p>If 'FDP.control.method' was set to &quot;BHFDX&quot; or it
resulted from the &quot;Auto&quot; setting, the alpha at which the probability
that the FDP exceeds alpha.star is less than or equal to the
originally specified alpha.</p>
</td></tr> 
<tr><td><code>c.g</code></td>
<td>
<p>The FDP control method threshold on the scale of the test statistics.</p>
</td></tr>
<tr><td><code>gamma</code></td>
<td>
<p>The proportion of all 'm' tests declared significant.</p>
</td></tr>
<tr><td><code>objective</code></td>
<td>
<p>Result of optimization yielding the average or tp- power.</p>
</td></tr>
<tr><td><code>err.III</code></td>
<td>
<p>Mass on the wrong side of the threshold.</p>
</td></tr>
<tr><td><code>sigma.rtm.ToM</code></td>
<td>
<p>Asymptotic standard deviation of the true positive
fraction.</p>
</td></tr>
<tr><td><code>Auto</code></td>
<td>
<p>If 'FDP.control.method' was set to &quot;Auto&quot;, this returns
the resulting choice (a string) which was made internally.</p>
</td></tr>
<tr><td><code>se.by.a</code></td>
<td>
<p>The ratio of the standard error of the FDP to alpha,
the nominal FDR, which gives an indication of the dispersion of its
distribution relative to the nominal FDP. Used by the &quot;Auto&quot;
specification.</p>
</td></tr>
<tr><td><code>gma.Ntsts</code></td>
<td>
<p>the effective denominator in the CLT asymptotic
approximation to the distribution of the FDP, which equals
the positive proportion, 'gamma', times the number of simultaneous
tests, 'm'.</p>
</td></tr>
<tr><td><code>detail</code></td>
<td>
<p>The extractor function, <code><a href="#topic+detail">detail</a></code>, will
return simulation replicates. See the linked documentation</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Grant Izmirlian &lt;izmirlian at nih dot gov&gt;
</p>


<h3>References</h3>

<p>Izmirlian G. (2020) Strong consistency and asymptotic normality for
quantities related to the Benjamini-Hochberg false discovery rate
procedure. Statistics and Probability Letters; 108713,
&lt;doi:10.1016/j.spl.2020.108713&gt;
</p>
<p>Izmirlian G. (2017) Average Power and <code class="reqn">\lambda</code>-power in
Multiple Testing Scenarios when the Benjamini-Hochberg False
Discovery Rate Procedure is Used. &lt;arXiv:1801.03989&gt;
</p>
<p>Jung S-H. (2005) Sample size for FDR-control in microarray data
analysis. Bioinformatics; 21:3097-3104.
</p>
<p>Kluger D. M., Owen A. B. (2023) A central limit theorem for the
Benjamini-Hochberg false discovery proportion under a factor model.
Bernoulli; xx:xxx-xxx.
</p>
<p>Liu P. and Hwang J-T. G. (2007) Quick calculation for sample size while
controlling false discovery rate with application to microarray
analysis. Bioinformatics; 23:739-746.
</p>
<p>Lehmann E. L., Romano J. P.. Generalizations of the familywise error
rate. Ann. Stat.. 2005;33(3):1138-1154.
</p>
<p>Romano Joseph P., Shaikh Azeem M.. Stepup procedures for control of
generalizations of the familywise error rate. Ann. Stat..
2006;34(4):1850-1873. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pwrFDR.grid">pwrFDR.grid</a></code>
<code><a href="#topic+controlFDP">controlFDP</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Example 1a: average power

   rslt.avgp &lt;- pwrFDR(effect.size=0.79, n.sample=46, r.1=2000/54675, alpha=0.15)
   rslt.avgp

## Example 1b: average power, FDP.control.method set to "Auto", N.tests=1000

   rslt.avgp.auto &lt;- pwrFDR(effect.size = 0.79, n.sample = 46, r.1 = 2000/54675, alpha = 0.15, 
                            N.tests = 1000, FDP.control.method = "Auto")
   rslt.avgp.auto

## Example 1c: average power, FDP.control.method set to "Auto", N.tests=2000

   rslt.avgp.auto &lt;- update(rslt.avgp.auto, N.tests = 2000)
   rslt.avgp.auto

## Example 1d: tp-power

   rslt.lpwr &lt;- pwrFDR(effect.size=0.79, n.sample=46, r.1=2000/54675,
                       alpha=0.15, lambda=0.80, N.tests=54675)
   rslt.lpwr

## Example 1e: sample size required for given average power

   rslt.ss.avgp &lt;- pwrFDR(effect.size=0.79, average.power=0.82,
                          r.1=2000/54675, alpha=0.15)
   rslt.ss.avgp

## Example 1f: sample size required for given tp-power

   rslt.ss.lpwr &lt;- pwrFDR(effect.size=0.79, TPX.power=0.82, lambda=0.80,
                          r.1=2000/54675, alpha=0.15, N.tests=54675)
   rslt.ss.lpwr

## Example 1g: simulation

   rslt.sim &lt;- update(rslt.avgp, method="sim", n.sim=500, N.tests=1000)
   rslt.sim

## Example 1h: simulation

   rslt.sim &lt;- update(rslt.avgp, method="sim", FDP.control.method="both",
                      n.sim=500, N.tests=1000)
   rslt.sim

## Example 2: methods for adding, subtracting, multiplying, dividing, exp, log,
## logit and inverse logit

   rslt.avgp - rslt.sim
   logit(rslt.avgp)       ## etc
   
## Example 3: Compare the asymptotic distribution of T/M with kernel
##            density estimate from simulated data 

   pdf &lt;- with(detail(rslt.sim)$reps, density(T/M1))

   med &lt;- with(detail(rslt.sim)$reps, median(T/M1))
   avg &lt;- rslt.sim$average.power
   sd &lt;- rslt.sim$se.ToM

   rng.x &lt;- range(pdf$x)
   rng.y &lt;- range(c(pdf$y, dnorm(pdf$x, mean=avg, sd=sd)))

   plot(rng.x, rng.y, xlab="u", ylab="PDF for T/M", type="n")
   with(pdf, lines(x, y))
   lines(rep(rslt.sim$average.power, 2), rng.y, lty=2)
   lines(pdf$x, dnorm(pdf$x, mean=avg, sd=sd), lty=3)
</code></pre>

<hr>
<h2 id='pwrFDR.grid'>
Evaluate <code>pwrFDR</code> on a grid.
</h2><span id='topic+pwrFDR.grid'></span>

<h3>Description</h3>

<p>Function for evaluating <code>pwrFDR</code> on a factorial design of
possible parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  pwrFDR.grid(effect.size, n.sample, r.1, alpha, delta, groups, N.tests,
              average.power, TPX.power, lambda, type, grpj.per.grp1,
              corr.struct, FDP.control.method, distopt, control)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pwrFDR.grid_+3A_effect.size">effect.size</code></td>
<td>

<p>A vector of effect sizes to be looped over. The effect size
(mean over standard deviation) for test statistics having non-zero
means. Assumed to be a constant (in magnitude) over non-zero mean
test statistics.
</p>
</td></tr>
<tr><td><code id="pwrFDR.grid_+3A_n.sample">n.sample</code></td>
<td>

<p>A vector of sample sizes to be looped over. The sample size is the
number of experimental replicates. Required for calculation of power
</p>
</td></tr>
<tr><td><code id="pwrFDR.grid_+3A_r.1">r.1</code></td>
<td>

<p>A vector of mixing proportions to be looped over. The mixing
proportion is the proportion of simultaneous tests that are
non-centrally located 
</p>
</td></tr>
<tr><td><code id="pwrFDR.grid_+3A_alpha">alpha</code></td>
<td>

<p>The false discovery rate (in the BH case) or the upper bound on the
probability that the FDP exceeds delta (BHFDX and Romano case)
</p>
</td></tr>
<tr><td><code id="pwrFDR.grid_+3A_delta">delta</code></td>
<td>

<p>If the &quot;FDP.control.method&quot; is set to 'Romano' or 'BHFDX', then this
optional argument can be set to the exceedance thresh-hold in
defining the FDP-tp: <code class="reqn">P\{ FDP &gt; \delta \} &lt; \alpha</code>. The default
value is <code class="reqn">\alpha</code>.
</p>
</td></tr>
<tr><td><code id="pwrFDR.grid_+3A_groups">groups</code></td>
<td>

<p>The number of experimental groups to compare. Must be integral and
&gt;=1. The default value is 2.
</p>
</td></tr>
<tr><td><code id="pwrFDR.grid_+3A_n.tests">N.tests</code></td>
<td>

<p>The number of simultaneous hypothesis tests. 
</p>
</td></tr>
<tr><td><code id="pwrFDR.grid_+3A_average.power">average.power</code></td>
<td>

<p>The desired average power. Calculation of sample size, effect size
mixing proportion or alpha requires specification of either
'average.power' or 'TPX.power'.
</p>
</td></tr>
<tr><td><code id="pwrFDR.grid_+3A_tpx.power">TPX.power</code></td>
<td>

<p>The desired tp-power (see <code><a href="#topic+pwrFDR">pwrFDR</a></code> documentation).
Calculation of sample size, effect size mixing proportion or alpha
requires specification of either 'average.power' or 'TPX.power'.
</p>
</td></tr>
<tr><td><code id="pwrFDR.grid_+3A_lambda">lambda</code></td>
<td>

<p>The tp-power threshold, required when calculating the tp-power
(see <code><a href="#topic+pwrFDR">pwrFDR</a></code> documentation) or when calculating the
sample size, effect size mixing proportion or alpha required for
tp-power.
</p>
</td></tr>
<tr><td><code id="pwrFDR.grid_+3A_type">type</code></td>
<td>

<p>A character string specifying, in the groups=2 case, whether the
test is 'paired', 'balanced', or 'unbalanced' and in the case when
groups &gt;=3, whether the test is 'balanced' or 'unbalanced'. The
default in all cases is 'balanced'. Left unspecified in the one
sample (groups=1) case. 
</p>
</td></tr>
<tr><td><code id="pwrFDR.grid_+3A_grpj.per.grp1">grpj.per.grp1</code></td>
<td>

<p>Required when <code>type</code>=&quot;unbalanced&quot;, specifies the group 0 to
group 1 ratio in the two group case, and in the case of 3 or more
groups, the group j to group 1 ratio, where group 1 is the group
with the largest effect under the alternative hypothesis. 
</p>
</td></tr>
<tr><td><code id="pwrFDR.grid_+3A_corr.struct">corr.struct</code></td>
<td>
<p>Specifies a block correlation structure between test
statistics which is used in both the simulation routine, and in the
computations based upon asymptotic approximation, e.g. the AFDX
control and the ATPP method. Its form is specified via the following
named elements.<br />
&quot;type&quot;: &quot;CS-Blocks&quot; for compound symmetry within blocks, or
&quot;Toeplitz-Blocks&quot; for toeplitz blocks.<br />
&quot;block.size&quot;: the size of the correlated blocks
&quot;rho&quot;: When type=&quot;CS-Blocks&quot;, then 'rho' is a correlation of length 1
when type=&quot;Toeplitz-Blocks&quot;, then 'rho' is a vector of
correlations of length 'block.size' - 1
</p>
</td></tr>  
<tr><td><code id="pwrFDR.grid_+3A_fdp.control.method">FDP.control.method</code></td>
<td>

<p>A character string specifying how the false discovery proportion (FDP) is to be
controlled. You may specify the whole word or any shortened uniquely
identifying truncation. <br />
&quot;BHFDR&quot;: the usual BH-FDR <br />
&quot;BHFDX&quot;: guarantees control of the FDX e.g. probability that the FDP exceeds 
delta will be less than alpha. Uses asymptotic approximationto the 
distribution of the FDP to find alpha* such that the BHFDR
procedure controls the FDX at alpha. Only slightly more conservative
than BHFDR control at alpha. Allows dependence which must be specified.
Not guaranteed to have a solution in all cases, in which case Romano's
procedure is used as a fall-back.<br />
&quot;Romano&quot;: use Romano's method which guarantees control of the FDX,
e.g. the probability that the FDP exceeds delta will
be less than alpha. <br />
&quot;Auto&quot;: in 'FixedPoint' mode, the program will use its own 
wisdom to determine which choice above to make. The 
order of conservatism is<br />
Bonferroni &gt; Holm &gt; Hochberg &gt; Romano &gt; BHFDX &gt; BHFDR,<br />
but BHFDR offers only expected control, the most
conservative 3 control the FWER and the other two 
guarantee bounds on the excedance probabilty. If the 
distribution of the FDP is nearly degenerate, then BHFDR 
is the best option. Otherwise, if it can be reliably used, 
BHFDX would be the best choice. The 'effective' denominator, 
gamma*N.tests, in the CLT determines when the approximation 
is good enough and the asymptotic standard error of the FDP 
determines when the distribution is dispersed enough to matter.
Use &quot;Auto&quot; to run through these checks and determine the best. 
A return argument, 'Auto', displays the choice made. See 
output components and details. <br />
&quot;both&quot;: in 'simulation' mode, compute statistics R and T under BHFDX
and Romano (in addition to BHFDR). Corresponding
statistics are denoted R.st, T.st corresponding to BHFDX
control of the FDP, and R.R and T.R corresponding to
Romano control of the FDP. If sim.level is set to 2,
(default) the statistics R.st.ht and T.st.ht, which are
the number rejected and number true positives under BHFDX
where r_0 = 1-r_1, gamma, and alpha.star have been estimated 
from the P-value data and then alpha.star computed from
these.<br />
&quot;Holm&quot;: Use Holm's step-down procedure which guarantees control of the
family-wise error rate (FWER)<br />
&quot;Hochberg&quot;: Use Hochberg's step-up procedure which guarantees control
of the FWER if the tests are independent. Less conservative 
than Holm and Bonferroni but more conservative than all other 
procedures here.<br />
&quot;Bonferroni&quot;: Use the Bonferroni procedure. Guarantees control of the FWER.
the most conservative of procedures offered here.
</p>
</td></tr>
<tr><td><code id="pwrFDR.grid_+3A_distopt">distopt</code></td>
<td>
<p>Test statistic distribution in among null and
alternatively distributed sub-populations.
distopt=0 gives normal (2 groups), distop=1 gives t- (2 groups)
and distopt=2 gives F- (2+ groups)
</p>
</td></tr>  
<tr><td><code id="pwrFDR.grid_+3A_control">control</code></td>
<td>
<p>Optionally, a list with components with the following  
components: <br />
'tol' is a convergence criterion used in iterative 
methods which is set to 1e-8 by default.<br />
'max.iter' is an iteration limit, set to 20 for the iterated
function limit and 1000 for all others by default.<br />
'sim.level' sim level 2 (default) stipulates, when FDP.control.method
is set to &quot;BHFDX&quot;, or &quot;both&quot;, R.st.ht and T.st.ht are
computed in addition to R.st and T.st (see above). <br />
'low.power.stop' in simulation option, will result in an error message 
if the power computed via FixedPoint method is too low, which 
result in no solution for the BHFDX option. Default setting is TRUE. 
Set to FALSE to over-ride this behavior. <br />
'FDP.meth.thresh' fine-tunes the 'Auto' voodoo (see above). Leave 
this alone. <br />
'verb' vebosity level.<br />
'ast.le.a' leaving this at the default value TRUE forces
'alpha.star', the solution under FDP.method.control=&quot;BHFDX&quot;,
to be less than the specified 'alpha'.
</p>
</td></tr>	    
</table>


<h3>Details</h3>

<p>Arguments may be specified as vectors of possible values or can be
set to a single constant value.
</p>


<h3>Value</h3>

<p>A list having two components:
</p>
<table role = "presentation">
<tr><td><code>conditions</code></td>
<td>
<p>A data.frame with one column for each argument
listing the distinct settings for all parameters.</p>
</td></tr>
<tr><td><code>results</code></td>
<td>
<p>A list with components objects of class <code>pwr</code>,
the results of the calls to <code>pwrFDR</code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Grant Izmirlian &lt;izmirlian at nih dot gov&gt;
</p>


<h3>References</h3>

<p>Izmirlian G. (2020) Strong consistency and asymptotic normality for
quantities related to the Benjamini-Hochberg false discovery rate
procedure. Statistics and Probability Letters; 108713,
&lt;doi:10.1016/j.spl.2020.108713&gt;
</p>
<p>Izmirlian G. (2017) Average Power and <code class="reqn">\lambda</code>-power in
Multiple Testing Scenarios when the Benjamini-Hochberg False
Discovery Rate Procedure is Used. &lt;arXiv:1801.03989&gt;
</p>
<p>Jung S-H. (2005) Sample size for FDR-control in microarray data
analysis. Bioinformatics; 21:3097-3104.
</p>
<p>Kluger D. M., Owen A. B. (2023) A central limit theorem for the
Benjamini-Hochberg false discovery proportion under a factor model.
Bernoulli; xx:xxx-xxx.
</p>
<p>Liu P. and Hwang J-T. G. (2007) Quick calculation for sample size while
controlling false discovery rate with application to microarray
analysis. Bioinformatics; 23:739-746.
</p>
<p>Lehmann E. L., Romano J. P.. Generalizations of the familywise error
rate. Ann. Stat.. 2005;33(3):1138-1154.
</p>
<p>Romano Joseph P., Shaikh Azeem M.. Stepup procedures for control of
generalizations of the familywise error rate. Ann. Stat..
2006;34(4):1850-1873. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pwrFDR.grid">pwrFDR.grid</a></code>
<code><a href="#topic+controlFDP">controlFDP</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tst &lt;- pwrFDR.grid(effect.size=c(0.6,0.9), n.sample=c(50,60,70), r.1=0.4+0.2*(0:1),
                   alpha=0.05+0.05*(0:3), N.tests=1000, FDP.control.method="Auto")

</code></pre>

<hr>
<h2 id='sd.rtm.Rom'>
Extractor function for asymptotic sd[R_m/m] under selected FDP control method
</h2><span id='topic+sd.rtm.Rom'></span>

<h3>Description</h3>

<p>A function which extracts the asymptotic standard deviation for the
postive call proportion, R_m/m, under the selected FDP control method
from the supplied <code>pwr</code> object, which is the result of a call to
the main function, <a href="#topic+pwrFDR">pwrFDR</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  sd.rtm.Rom(object)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sd.rtm.Rom_+3A_object">object</code></td>
<td>

<p>An object of class, <code>pwr</code>, which is the result of a call to
the main function, <a href="#topic+pwrFDR">pwrFDR</a>
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The siginificant call proportion (SCP), R_m/m, under the selected
FDP control method, is directly related to the ensemble power, which
in turn, is determined by the effect size for tests distributed under
the alternative, the sample size, the proportion of tests which are
distributed according to the alternative and the size, alpha, in the
selected FDP control method. Its asymptotic standard error, e.g. the
asymptotic standard deviation over the square root of the number of
simultaneous tests, m, gives an indication of the range of values
one can expect for the significant call proportion. The standard
deviations of the ratios R_m/m, T_m/M_m, and V_m/R_m are used
internally in control of the distribution of V_m/R_m for the BHFDX
FDP control method, and in calculation of the tail probability power
for T_m/M_m. 
</p>


<h3>Value</h3>

<p>Returns the asymptotic standard deviation of the significant call
proportion, sd[R_m/m], as an un-named numeric.
</p>


<h3>Author(s)</h3>

<p>Grant Izmirlian &lt;izmirlig at mail dot nih dot gov&gt;
</p>


<h3>References</h3>

<p>Izmirlian G. (2020) Strong consistency and asymptotic normality for
quantities related to the Benjamini-Hochberg false discovery rate
procedure. Statistics and Probability Letters; 108713,
&lt;doi:10.1016/j.spl.2020.108713&gt;.
</p>
<p>Izmirlian G. (2017) Average Power and <code class="reqn">\lambda</code>-power in
Multiple Testing Scenarios when the Benjamini-Hochberg False
Discovery Rate Procedure is Used. &lt;arXiv:1801.03989&gt;
</p>
<p>Kluger D. M., Owen A. B. (2023) A central limit theorem for the
Benjamini-Hochberg false discovery proportion under a factor model.
Bernoulli; xx:xxx-xxx.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sd.rtm.VoR">sd.rtm.VoR</a></code>
<code><a href="#topic+sd.rtm.ToM">sd.rtm.ToM</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  rslt.BHFDR  &lt;- pwrFDR(effect.size=0.79, n.sample=46, r.1=0.05, alpha=0.15)
  rslt.Auto.1 &lt;- pwrFDR(effect.size=0.79, n.sample=46, r.1=0.05, alpha=0.15, N.tests=51,
                       FDP.control.method="Auto")
  rslt.Auto.2 &lt;- pwrFDR(effect.size=0.79, n.sample=46, r.1=0.05, alpha=0.15, N.tests=49,
                       FDP.control.method="Auto")

  ## Asymptotic standard deviation of positive call proportion under BHFDR
  sdrtmRomBHFDR  &lt;- sd.rtm.Rom(rslt.BHFDR)

  ## Asymptotic standard deviation of positive call proportion under BHFDX
  sdrtmRomAuto1 &lt;- sd.rtm.Rom(rslt.Auto.1)

  ## Asymptotic standard deviation of positive call proportionunder Romano
  sdrtmRomAuto2 &lt;- sd.rtm.Rom(rslt.Auto.2)
</code></pre>

<hr>
<h2 id='sd.rtm.ToM'>
Extractor function for asymptotic sd[T_m/M_m] under selected FDP control method
</h2><span id='topic+sd.rtm.ToM'></span>

<h3>Description</h3>

<p>A function which extracts the asymptotic standard deviation for the
true positive proportion, T_m/M_m, under the selected FDP control method
from the supplied <code>pwr</code> object, which is the result of a call to
the main function, <a href="#topic+pwrFDR">pwrFDR</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  sd.rtm.ToM(object)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sd.rtm.ToM_+3A_object">object</code></td>
<td>

<p>An object of class, <code>pwr</code>, which is the result of a call to
the main function, <a href="#topic+pwrFDR">pwrFDR</a>
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The true positive proportion (TPP), T_m/M_m, is the proportion
of all test statistics distributed according to the alternative that
are declared significant by the selected FDP control method. Whereas
the ensemble type I error in the multiple testing experiment is
handled via control of the distribution of the FDP, V_m/R_m, the
ensemble power is optimized via the distribution of the TPP. The
most commonly used ensemble power is based upon the expected TPP,
or true postive rate, E[TPP], which also called the average power.
In situations of just adequate power or near adequate power,
especially when testing less than 1000 simultaneous tests or so, the
distribution of the TPP will be non-negligiby dispersed and this
means that the TPP in a given multiple testing experiment for which
sample size was based on the average power will likely not be close
to the promised average power. For this reason, it is preferable to
use a concept of ensemble power which is based upon the excedance
probability for the TPP, or tail probability of the TPP (tp-TPP).
</p>
<p><code class="reqn">P(TPP &gt; \lambda) &gt;= 1- \epsilon_{II}</code>
</p>
<p>This package uses asymptotic approximation to derive the tp-TPP
ensemble power under any one of the avaialbe FDP control methods,
BHFDR, BHFDX or Romano.
</p>


<h3>Value</h3>

<p>Returns the asymptotic standard deviation of the true postive 
proportion, sd[T_m/M_m], as an un-named numeric.
</p>


<h3>Author(s)</h3>

<p>Grant Izmirlian &lt;izmirlig at mail dot nih dot gov&gt;
</p>


<h3>References</h3>

<p>Izmirlian G. (2020) Strong consistency and asymptotic normality for
quantities related to the Benjamini-Hochberg false discovery rate
procedure. Statistics and Probability Letters; 108713,
&lt;doi:10.1016/j.spl.2020.108713&gt;.
</p>
<p>Izmirlian G. (2017) Average Power and <code class="reqn">\lambda</code>-power in
Multiple Testing Scenarios when the Benjamini-Hochberg False
Discovery Rate Procedure is Used. &lt;arXiv:1801.03989&gt;
</p>
<p>Kluger D. M., Owen A. B. (2023) A central limit theorem for the
Benjamini-Hochberg false discovery proportion under a factor model.
Bernoulli; xx:xxx-xxx.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sd.rtm.Rom">sd.rtm.Rom</a></code>
<code><a href="#topic+sd.rtm.VoR">sd.rtm.VoR</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  rslt.BHFDR  &lt;- pwrFDR(effect.size=0.79, n.sample=46, r.1=0.05, alpha=0.15)
  rslt.Auto.1 &lt;- pwrFDR(effect.size=0.79, n.sample=46, r.1=0.05, alpha=0.15, N.tests=51,
                       FDP.control.method="Auto")
  rslt.Auto.2 &lt;- pwrFDR(effect.size=0.79, n.sample=46, r.1=0.05, alpha=0.15, N.tests=49,
                       FDP.control.method="Auto")

  ## Asymptotic standard deviation under BHFDR
  sdrtmToMBHFDR  &lt;- sd.rtm.ToM(rslt.BHFDR)

  ## Asymptotic standard deviation under BHFDX
  sdrtmToMAuto1 &lt;- sd.rtm.ToM(rslt.Auto.1)

  ## Asymptotic standard deviation under Romano
  sdrtmToMAuto2 &lt;- sd.rtm.ToM(rslt.Auto.2)
</code></pre>

<hr>
<h2 id='sd.rtm.VoR'>
Extractor function for asymptotic sd[V_m/R_m] under selected FDP control method
</h2><span id='topic+sd.rtm.VoR'></span>

<h3>Description</h3>

<p>A function which extracts the asymptotic standard deviation for the
false discovery proportion, V_m/R_m, under the selected FDP control method
from the supplied <code>pwr</code> object, which is the result of a call to
the main function, <a href="#topic+pwrFDR">pwrFDR</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  sd.rtm.VoR(object)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sd.rtm.VoR_+3A_object">object</code></td>
<td>

<p>An object of class, <code>pwr</code>, which is the result of a call to
the main function, <a href="#topic+pwrFDR">pwrFDR</a>
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The false discovery proportion (FDP), V_m/R_m, under the selected
FDP control method, is the proportion of null distributed test
statistics that were deemed significant calls by the FDP control
method. The most well known of available FDP methods is the
Benjamini-Hochberg False Discovery Rate (BH-FDR) procedure. It
ensures that the expected value of the FDP will be less than
alpha, E[FDP] &lt; alpha. The other two included FDP control methods,
&quot;Romano&quot; and &quot;BHFDX&quot;, control the probability that the FDP exceeds
a given value, delta:
</p>
<p><code class="reqn">P( V_m/R_m &gt; \delta ) &lt; \alpha</code>
</p>
<p>In most cases, the choice <code class="reqn">\delta=\alpha</code> is appropriate but
<code class="reqn">\delta</code> is a distinct parameter to allow greater flexibility.
The choice &quot;Auto&quot; will select the most appropriate choice from the
three, BHFDR, BHFDX and Romano. If the asymptotic standard error,
sd.rtm.VoR/m^0.5 is greater than a control parameter (default value
10%), then one of the choices &quot;BHFDX&quot; or &quot;Romano&quot; will be made. As
the &quot;Romano&quot; FDP control method is more conservative, there is a
preference for the &quot;BHFDX&quot; method, which can be used if the number
of simultaneous tests, m, is larger than 50. All of this is
handled internally within the function <code>pwrFDR</code>. These
extractor functions exist to allow the user 'under the hood'. 
</p>


<h3>Value</h3>

<p>Returns the asymptotic standard deviation of the false discovery 
proportion, sd[V_m/R_m], as an un-named numeric.
</p>


<h3>Author(s)</h3>

<p>Grant Izmirlian &lt;izmirlig at mail dot nih dot gov&gt;
</p>


<h3>References</h3>

<p>Izmirlian G. (2020) Strong consistency and asymptotic normality for
quantities related to the Benjamini-Hochberg false discovery rate
procedure. Statistics and Probability Letters; 108713,
&lt;doi:10.1016/j.spl.2020.108713&gt;.
</p>
<p>Izmirlian G. (2017) Average Power and <code class="reqn">\lambda</code>-power in
Multiple Testing Scenarios when the Benjamini-Hochberg False
Discovery Rate Procedure is Used. &lt;arXiv:1801.03989&gt;
</p>
<p>Kluger D. M., Owen A. B. (2023) A central limit theorem for the
Benjamini-Hochberg false discovery proportion under a factor model.
Bernoulli; xx:xxx-xxx.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sd.rtm.Rom">sd.rtm.Rom</a></code>
<code><a href="#topic+sd.rtm.ToM">sd.rtm.ToM</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  rslt.BHFDR  &lt;- pwrFDR(effect.size=0.79, n.sample=46, r.1=0.05, alpha=0.15)
  rslt.Auto.1 &lt;- pwrFDR(effect.size=0.79, n.sample=46, r.1=0.05, alpha=0.15, N.tests=51,
                       FDP.control.method="Auto")
  rslt.Auto.2 &lt;- pwrFDR(effect.size=0.79, n.sample=46, r.1=0.05, alpha=0.15, N.tests=49,
                       FDP.control.method="Auto")

  ## Asymptotic standard deviation under BHFDR
  sdrtmVoRBHFDR  &lt;- sd.rtm.VoR(rslt.BHFDR)

  ## Asymptotic standard deviation under BHFDX
  sdrtmVoRAuto1 &lt;- sd.rtm.VoR(rslt.Auto.1)

  ## Asymptotic standard deviation under Romano
  sdrtmVoRAuto2 &lt;- sd.rtm.VoR(rslt.Auto.2)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
