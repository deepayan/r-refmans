<!DOCTYPE html><html lang="en"><head><title>Help for package VARcpDetectOnline</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {VARcpDetectOnline}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#applyThreshold'><p>Apply Thresholding to VAR Coefficients</p></a></li>
<li><a href='#computeResiduals'><p>Compute VAR Model Residuals</p></a></li>
<li><a href='#cvVAR'><p>Cross-Validated VAR Estimation using Elastic Net</p></a></li>
<li><a href='#cvVAR_ENET'><p>Cross Validation for Elastic Net VAR Estimation</p></a></li>
<li><a href='#duplicateMatrix'><p>Construct Lagged Design Matrix for VAR</p></a></li>
<li><a href='#estimateCovariance'><p>Estimate Covariance Matrix from Residuals</p></a></li>
<li><a href='#fitVAR'><p>Fit VAR Model with Elastic Net via Cross Validation</p></a></li>
<li><a href='#generateVAR'><p>Generate VAR Data</p></a></li>
<li><a href='#get_cps'><p>Identify the Beginning of the Alarm Clusters</p></a></li>
<li><a href='#sp500'><p>S&amp;P 500 Daily Log Returns and Corresponding Dates</p></a></li>
<li><a href='#splitMatrix'><p>Split Coefficient Matrix into VAR Lags</p></a></li>
<li><a href='#transformData'><p>Transform Data for VAR Estimation</p></a></li>
<li><a href='#VAR_cpDetect_Online'><p>VAR_cpDetect_Online: Sequential change point Detection for Vector Auto-Regressive Models</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Sequential Change Point Detection for High-Dimensional VAR
Models</td>
</tr>
<tr>
<td>Version:</td>
<td>0.2.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Implements the algorithm introduced in Tian, Y., and Safikhani, A. (2024)
    &lt;<a href="https://doi.org/10.5705%2Fss.202024.0182">doi:10.5705/ss.202024.0182</a>&gt;, "Sequential Change Point Detection in High-dimensional 
    Vector Auto-regressive Models". This package provides tools for detecting change points 
    in the transition matrices of VAR models, effectively identifying shifts in temporal 
    and cross-correlations within high-dimensional time series data.</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>Imports:</td>
<td>MASS, corpcor, Matrix, glmnet, doParallel, stats</td>
</tr>
<tr>
<td>Suggests:</td>
<td>ggplot2</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/Helloworld9293/VARcpDetectOnline">https://github.com/Helloworld9293/VARcpDetectOnline</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/Helloworld9293/VARcpDetectOnline/issues">https://github.com/Helloworld9293/VARcpDetectOnline/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-02-12 18:06:25 UTC; AAA</td>
</tr>
<tr>
<td>Author:</td>
<td>Yuhan Tian [aut, cre],
  Abolfazl Safikhani [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Yuhan Tian &lt;yuhan.tian@ufl.edu&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-02-13 08:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='applyThreshold'>Apply Thresholding to VAR Coefficients</h2><span id='topic+applyThreshold'></span>

<h3>Description</h3>

<p>Applies a thresholding rule to a coefficient matrix by setting entries below a
certain threshold to zero. Two types of thresholding are available: &quot;soft&quot; and &quot;hard&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>applyThreshold(a_mat, nr, nc, p, type = "soft")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="applyThreshold_+3A_a_mat">a_mat</code></td>
<td>
<p>Numeric matrix. The coefficient matrix to be thresholded.</p>
</td></tr>
<tr><td><code id="applyThreshold_+3A_nr">nr</code></td>
<td>
<p>Integer. The number of rows in the original data.</p>
</td></tr>
<tr><td><code id="applyThreshold_+3A_nc">nc</code></td>
<td>
<p>Integer. The number of variables (columns) in the original data.</p>
</td></tr>
<tr><td><code id="applyThreshold_+3A_p">p</code></td>
<td>
<p>Integer. The order of the VAR model.</p>
</td></tr>
<tr><td><code id="applyThreshold_+3A_type">type</code></td>
<td>
<p>Character. The type of threshold to apply; either <code>"soft"</code> (default)
or <code>"hard"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The thresholded coefficient matrix.
</p>

<hr>
<h2 id='computeResiduals'>Compute VAR Model Residuals</h2><span id='topic+computeResiduals'></span>

<h3>Description</h3>

<p>Computes the residuals from a VAR model by subtracting the fitted values (obtained
from the estimated coefficient matrices) from the original time series data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>computeResiduals(data, A)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="computeResiduals_+3A_data">data</code></td>
<td>
<p>A numeric matrix of the original time series (observations in rows).</p>
</td></tr>
<tr><td><code id="computeResiduals_+3A_a">A</code></td>
<td>
<p>List. A list of VAR coefficient matrices (one for each lag).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric matrix of residuals.
</p>

<hr>
<h2 id='cvVAR'>Cross-Validated VAR Estimation using Elastic Net</h2><span id='topic+cvVAR'></span>

<h3>Description</h3>

<p>This internal function performs cross validation for VAR estimation using the elastic net
penalty. It prepares the data, calls the elastic net CV routine, reshapes the estimated coefficients,
applies optional thresholding, computes residuals, and estimates the error covariance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cvVAR(data, p, opt = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cvVAR_+3A_data">data</code></td>
<td>
<p>A numeric matrix with time series data (observations in rows, variables in columns).</p>
</td></tr>
<tr><td><code id="cvVAR_+3A_p">p</code></td>
<td>
<p>Integer. The order of the VAR model.</p>
</td></tr>
<tr><td><code id="cvVAR_+3A_opt">opt</code></td>
<td>
<p>List. A list of options (see <code>fitVAR</code> for details).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with components:
</p>
<table role = "presentation">
<tr><td><code>mu</code></td>
<td>
<p>Vector of means of the original series.</p>
</td></tr>
<tr><td><code>A</code></td>
<td>
<p>List of VAR coefficient matrices (one for each lag).</p>
</td></tr>
<tr><td><code>fit</code></td>
<td>
<p>The complete elastic net CV fit (if requested).</p>
</td></tr>
<tr><td><code>lambda</code></td>
<td>
<p>The optimal lambda value chosen by CV.</p>
</td></tr>
<tr><td><code>mse</code></td>
<td>
<p>The minimum mean squared error from CV.</p>
</td></tr>
<tr><td><code>mse_sd</code></td>
<td>
<p>Standard deviation of the MSE.</p>
</td></tr>
<tr><td><code>time</code></td>
<td>
<p>Elapsed time for the ENET estimation.</p>
</td></tr>
<tr><td><code>series</code></td>
<td>
<p>The transformed series (after centering/scaling).</p>
</td></tr>
<tr><td><code>residuals</code></td>
<td>
<p>Residuals from the VAR model.</p>
</td></tr>
<tr><td><code>sigma</code></td>
<td>
<p>Estimated covariance matrix of the residuals.</p>
</td></tr>
</table>

<hr>
<h2 id='cvVAR_ENET'>Cross Validation for Elastic Net VAR Estimation</h2><span id='topic+cvVAR_ENET'></span>

<h3>Description</h3>

<p>This internal function performs cross validation using elastic net (ENET)
estimation via the <code>glmnet</code> package. It supports parallel processing if requested.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cvVAR_ENET(X, y, nvar, opt)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cvVAR_ENET_+3A_x">X</code></td>
<td>
<p>A numeric matrix of predictors.</p>
</td></tr>
<tr><td><code id="cvVAR_ENET_+3A_y">y</code></td>
<td>
<p>Numeric vector of responses.</p>
</td></tr>
<tr><td><code id="cvVAR_ENET_+3A_nvar">nvar</code></td>
<td>
<p>Integer. The number of variables in the original VAR (number of columns in data).</p>
</td></tr>
<tr><td><code id="cvVAR_ENET_+3A_opt">opt</code></td>
<td>
<p>List. A list of options including:
</p>

<ul>
<li> <p><code>alpha</code>: The elastic net mixing parameter (default = 1).
</p>
</li>
<li> <p><code>nlambda</code>: Number of lambda values (default = 100).
</p>
</li>
<li> <p><code>type.measure</code>: Error measure for CV (default = &quot;mse&quot;).
</p>
</li>
<li> <p><code>nfolds</code>: Number of folds for CV (default = 10).
</p>
</li>
<li> <p><code>parallel</code>: Logical. Whether to use parallel processing (default = FALSE).
</p>
</li>
<li> <p><code>ncores</code>: Number of cores for parallel processing (default = 1).
</p>
</li>
<li> <p><code>lambdas_list</code>: Optionally, a user-specified list of lambdas.
</p>
</li>
<li> <p><code>folds_ids</code>: Optionally, user-specified fold IDs for CV.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>cv.glmnet</code> as returned by <code>glmnet::cv.glmnet</code>.
</p>

<hr>
<h2 id='duplicateMatrix'>Construct Lagged Design Matrix for VAR</h2><span id='topic+duplicateMatrix'></span>

<h3>Description</h3>

<p>Duplicates the original data matrix to create a lagged predictor matrix for VAR estimation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>duplicateMatrix(data, p)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="duplicateMatrix_+3A_data">data</code></td>
<td>
<p>A numeric matrix with time series data (observations in rows).</p>
</td></tr>
<tr><td><code id="duplicateMatrix_+3A_p">p</code></td>
<td>
<p>Integer. The order of the VAR model (number of lags).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric matrix with duplicated columns corresponding to lagged observations.
</p>

<hr>
<h2 id='estimateCovariance'>Estimate Covariance Matrix from Residuals</h2><span id='topic+estimateCovariance'></span>

<h3>Description</h3>

<p>Estimates the covariance (or variance) matrix of the residuals using shrinkage estimation.
This function utilizes <code>corpcor::cov.shrink</code> for covariance estimation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimateCovariance(res, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="estimateCovariance_+3A_res">res</code></td>
<td>
<p>A numeric matrix of residuals from the VAR model.</p>
</td></tr>
<tr><td><code id="estimateCovariance_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code>corpcor::cov.shrink</code> (if any).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric covariance matrix.
</p>

<hr>
<h2 id='fitVAR'>Fit VAR Model with Elastic Net via Cross Validation</h2><span id='topic+fitVAR'></span>

<h3>Description</h3>

<p>Estimates a (possibly high-dimensional) VAR model using penalized least squares
with an elastic net penalty and cross validation.
This function is adapted from the <em>sparsevar</em> package
(<a href="https://github.com/svazzole/sparsevar/tree/master">https://github.com/svazzole/sparsevar/tree/master</a>), which is distributed under
the GNU General Public License v2. The code has been modified to specifically implement
the elastic net penalty (penalty = &quot;ENET&quot;) and cross validation (method = &quot;cv&quot;).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fitVAR(data, p = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fitVAR_+3A_data">data</code></td>
<td>
<p>A numeric matrix or data frame with time series data (observations in rows,
variables in columns).</p>
</td></tr>
<tr><td><code id="fitVAR_+3A_p">p</code></td>
<td>
<p>Integer. The order of the VAR model.</p>
</td></tr>
<tr><td><code id="fitVAR_+3A_...">...</code></td>
<td>
<p>Additional options for estimation. Global options include:
</p>

<ul>
<li> <p><code>threshold</code>: Logical. If <code>TRUE</code>, all entries smaller than the oracle
threshold are set to zero.
</p>
</li>
<li> <p><code>scale</code>: Logical. Whether to scale the data (default is <code>FALSE</code>).
</p>
</li>
<li> <p><code>nfolds</code>: Integer. The number of folds used for cross validation (default is 10).
</p>
</li>
<li> <p><code>parallel</code>: Logical. If <code>TRUE</code>, use multicore backend (default is <code>FALSE</code>).
</p>
</li>
<li> <p><code>ncores</code>: Integer. If <code>parallel = TRUE</code>, specify the number of cores to use.
</p>
</li>
<li> <p><code>alpha</code>: Numeric. The elastic net mixing parameter (default is 1, i.e. LASSO).
</p>
</li>
<li> <p><code>type.measure</code>: Character. The error measure for CV (e.g., <code>"mse"</code> or <code>"mae"</code>).
</p>
</li>
<li> <p><code>nlambda</code>: Integer. The number of lambda values to use in cross validation (default is 100).
</p>
</li>
<li> <p><code>leaveOut</code>: Integer. In time slice validation, leave out the last observations (default is 15).
</p>
</li>
<li> <p><code>horizon</code>: Integer. The forecast horizon to use for estimating error (default is 1).
</p>
</li>
<li> <p><code>lambda</code>: Either a numeric vector of lambda values or a string indicating which
lambda to use (default is <code>"lambda.min"</code>).
</p>
</li>
<li> <p><code>return_fit</code>: Logical. If <code>TRUE</code>, return the complete fit object.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following components:
</p>
<table role = "presentation">
<tr><td><code>mu</code></td>
<td>
<p>A vector of means for each variable.</p>
</td></tr>
<tr><td><code>A</code></td>
<td>
<p>A list (of length <code>p</code>) of the estimated coefficient matrices for the VAR process.</p>
</td></tr>
<tr><td><code>fit</code></td>
<td>
<p>(Optional) The complete results of the penalized least squares estimation.</p>
</td></tr>
<tr><td><code>lambda</code></td>
<td>
<p>The chosen lambda value (by cross validation).</p>
</td></tr>
<tr><td><code>mse</code></td>
<td>
<p>The minimum mean squared error from cross validation.</p>
</td></tr>
<tr><td><code>mse_sd</code></td>
<td>
<p>The standard deviation of the mean squared error.</p>
</td></tr>
<tr><td><code>time</code></td>
<td>
<p>Elapsed time for the estimation.</p>
</td></tr>
<tr><td><code>series</code></td>
<td>
<p>The (possibly transformed) input time series.</p>
</td></tr>
<tr><td><code>residuals</code></td>
<td>
<p>The residuals of the VAR model.</p>
</td></tr>
<tr><td><code>sigma</code></td>
<td>
<p>The estimated variance/covariance matrix of the residuals.</p>
</td></tr>
</table>


<h3>References</h3>

<p>The original source code is adapted from the
<a href="https://github.com/svazzole/sparsevar/tree/master">sparsevar package</a>,
which is distributed under the GNU General Public License v2.
</p>

<hr>
<h2 id='generateVAR'>Generate VAR Data</h2><span id='topic+generateVAR'></span>

<h3>Description</h3>

<p>This function generates Vector Auto-Regressive (VAR) data based on the provided parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generateVAR(n, As, Sig, h, isOldProvided = FALSE, oldxs = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="generateVAR_+3A_n">n</code></td>
<td>
<p>Integer. The length of the VAR data to be generated.</p>
</td></tr>
<tr><td><code id="generateVAR_+3A_as">As</code></td>
<td>
<p>List. A list containing the transition matrices for the VAR process.</p>
</td></tr>
<tr><td><code id="generateVAR_+3A_sig">Sig</code></td>
<td>
<p>Matrix. The covariance matrix of errors.</p>
</td></tr>
<tr><td><code id="generateVAR_+3A_h">h</code></td>
<td>
<p>Integer. The order of the VAR process.</p>
</td></tr>
<tr><td><code id="generateVAR_+3A_isoldprovided">isOldProvided</code></td>
<td>
<p>Logical. If TRUE, the VAR data will be generated based on the
last observations from the previous segment of data. Defaults to FALSE.</p>
</td></tr>
<tr><td><code id="generateVAR_+3A_oldxs">oldxs</code></td>
<td>
<p>Matrix. A <code>p</code> by <code>h</code> matrix containing the last observations from
the previous segment of data. Required if <code>isOldProvided = TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data matrix of dimensions <code>p</code> by <code>n</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example usage
As &lt;- list(matrix(c(0.5, 0.2, 0.1, 0.4), 2, 2))
Sig &lt;- diag(2)
data &lt;- generateVAR(n = 100, As = As, Sig = Sig, h = 1)
</code></pre>

<hr>
<h2 id='get_cps'>Identify the Beginning of the Alarm Clusters</h2><span id='topic+get_cps'></span>

<h3>Description</h3>

<p>This function clusters alarms into groups and identifies the starting points of the alarm clusters.
If the next alarm occurs within a specified window size (<code>w</code>) from the current alarm,
it will be considered part of the current cluster. Otherwise, a new cluster will be formed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_cps(alarms, w)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_cps_+3A_alarms">alarms</code></td>
<td>
<p>A numeric vector. The alarms raised during the monitoring process.</p>
</td></tr>
<tr><td><code id="get_cps_+3A_w">w</code></td>
<td>
<p>An integer. The window size used to group alarms into clusters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector containing the starting points of the alarm clusters.
If the next alarm is within <code>w</code> observations of the current alarm,
the next alarm will be considered part of the current alarm cluster.
Otherwise, a new cluster is formed and the next alarm is considered the beginning
of a new alarm cluster.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example usage:
alarms &lt;- c(10, 15, 30, 35, 60)
change_points &lt;- get_cps(alarms, w = 10)

</code></pre>

<hr>
<h2 id='sp500'>S&amp;P 500 Daily Log Returns and Corresponding Dates</h2><span id='topic+sp500'></span>

<h3>Description</h3>

<p>This dataset contains daily log returns for 186 stocks in the S&amp;P 500
index from February 6, 2004, to March 2, 2016. The daily log returns
are calculated using the adjusted daily closing prices. The dataset also
contains the corresponding dates for each log return.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(sp500)
</code></pre>


<h3>Format</h3>

<p>A list with two elements:
</p>

<dl>
<dt><code>sp500$log_daily_return</code></dt><dd><p>A matrix with dimensions 3037 (rows, trading days) by 186 (columns, stocks).</p>
</dd>
<dt><code>sp500$date</code></dt><dd><p>A vector of length 3037, containing the dates for each trading day.</p>
</dd>
</dl>



<h3>Details</h3>

<p>The dataset is provided as an <code>.RData</code> file containing:
</p>

<ul>
<li> <p><code>sp500$log_daily_return</code>: A matrix of daily log returns with 3037 rows (trading days) and 186 columns (stocks).
</p>
</li>
<li> <p><code>sp500$date</code>: A vector of length 3037 containing the dates for each daily log return.
</p>
</li></ul>



<h3>Source</h3>

<p>Data from the S&amp;P 500 stock index (2004-2016).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+VAR_cpDetect_Online">VAR_cpDetect_Online</a></code>, <code><a href="#topic+get_cps">get_cps</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example Usage: Applying Change Point Detection to S&amp;P 500 Data
# This is an example of how to apply the change point detection method
# (using the VAR_cpDetect_Online function) on the daily log return
# dataset from the S&amp;P 500 (stored in the sp500 dataset). The code
# below calculates the average return volatility for all stocks, applies
# the change point detection algorithm, and plots the results with detected
# change points shown as vertical red and black lines.

# Load the dataset
data(sp500)

# Set parameters
library(ggplot2)
set.seed(2024)
n_sp &lt;- nrow(sp500$log_daily_return)
p_sp &lt;- ncol(sp500$log_daily_return)

# Calculate average return volatility for all data points
volatility_sum &lt;- rep(0, (n_sp - 21))
for(col in 1:p_sp){
  temp &lt;- as.numeric(sp500$log_daily_return[, col])
  temp1 &lt;- rep(0, (n_sp - 21))
  for(row in 1:(n_sp - 21)){
    temp1[row] &lt;- sd(temp[(row):(row + 21)])
  }
  volatility_sum &lt;- volatility_sum + temp1
}
volatility_ave &lt;- volatility_sum / p_sp

# Apply change point detection method
n0 &lt;- 200
w &lt;- 22
alpha &lt;- 1 / 5000

res &lt;- VAR_cpDetect_Online(t(sp500$log_daily_return), n0, w, alpha, 1, FALSE, TRUE, 5 / w, TRUE)
res_sp &lt;- res$alarm_locations + n0
res_sp_cps &lt;- res$cp_locations + n0
# Get the estimated starting points of each alarm cluster
cps_est_sp &lt;- unique(res_sp_cps[which(res_sp %in% get_cps(res_sp, w))])

# Prepare data for plotting
y_values &lt;- c(volatility_ave)
x_values &lt;- sp500$date[1:(n_sp - 21)]
df &lt;- data.frame(y_values, x_values)
plot_sp &lt;- ggplot(df, aes(y = y_values, x = x_values)) +
  geom_line() +
  theme(legend.position = "none") +
  labs(title = "", x = "", y = "") +
  scale_x_date(date_breaks = "1 year", date_labels = "%Y") +
  geom_vline(xintercept = sp500$date[res_sp], linetype = "solid", color = "red", alpha = .1) +
  geom_vline(xintercept = sp500$date[cps_est_sp], linetype = "solid", color = "black")

# Print the detected change points
sp500$date[cps_est_sp] # The dates for the starting of the alarm clusters
plot_sp

</code></pre>

<hr>
<h2 id='splitMatrix'>Split Coefficient Matrix into VAR Lags</h2><span id='topic+splitMatrix'></span>

<h3>Description</h3>

<p>Splits a matrix of estimated coefficients into a list of matrices,
each corresponding to one lag of the VAR model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>splitMatrix(M, p)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="splitMatrix_+3A_m">M</code></td>
<td>
<p>A numeric matrix of coefficients.</p>
</td></tr>
<tr><td><code id="splitMatrix_+3A_p">p</code></td>
<td>
<p>Integer. The order of the VAR model (number of lags).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of <code>p</code> matrices, each of dimension (number of variables) x (number of variables).
</p>

<hr>
<h2 id='transformData'>Transform Data for VAR Estimation</h2><span id='topic+transformData'></span>

<h3>Description</h3>

<p>Transforms the input time series data into the design matrices required for VAR estimation.
This includes centering, optional scaling, and constructing the lagged predictor matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>transformData(data, p, opt)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="transformData_+3A_data">data</code></td>
<td>
<p>A numeric matrix or data frame with time series data (observations in rows,
variables in columns).</p>
</td></tr>
<tr><td><code id="transformData_+3A_p">p</code></td>
<td>
<p>Integer. The order of the VAR model (number of lags).</p>
</td></tr>
<tr><td><code id="transformData_+3A_opt">opt</code></td>
<td>
<p>List. Options for data transformation. Supported options include:
</p>

<ul>
<li> <p><code>scale</code>: Logical. Whether to scale the data columns (default is <code>FALSE</code>).
</p>
</li>
<li> <p><code>center</code>: Logical. Whether to center the data columns (default is <code>TRUE</code>).
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following components:
</p>
<table role = "presentation">
<tr><td><code>X</code></td>
<td>
<p>The design matrix (via the Kronecker product) for lagged predictors.</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>A vectorized response corresponding to the lagged data.</p>
</td></tr>
<tr><td><code>series</code></td>
<td>
<p>The (centered and possibly scaled) original time series matrix.</p>
</td></tr>
<tr><td><code>mu</code></td>
<td>
<p>A row vector of the column means used for centering.</p>
</td></tr>
</table>

<hr>
<h2 id='VAR_cpDetect_Online'>VAR_cpDetect_Online: Sequential change point Detection for Vector Auto-Regressive Models</h2><span id='topic+VAR_cpDetect_Online'></span>

<h3>Description</h3>

<p>This function performs sequential change point detection in high-dimensional time series data modeled as a Vector Auto-Regressive (VAR) process, targeting changes in the transition matrices that encode temporal and cross-correlations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>VAR_cpDetect_Online(
  data,
  n0,
  w,
  alpha,
  h,
  RLmode = TRUE,
  needRefine = TRUE,
  refineSize = 1/5,
  needRefineCorrection = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="VAR_cpDetect_Online_+3A_data">data</code></td>
<td>
<p>A matrix where rows represent different dimensions (features) and columns represent observations. The first <code>n0</code> columns are treated as historical data.</p>
</td></tr>
<tr><td><code id="VAR_cpDetect_Online_+3A_n0">n0</code></td>
<td>
<p>Integer. The size of the historical data (number of columns in <code>data</code> treated as historical).</p>
</td></tr>
<tr><td><code id="VAR_cpDetect_Online_+3A_w">w</code></td>
<td>
<p>Integer. The size of the sliding window used for calculating test statistics; referred to as the pre-specified detection delay.</p>
</td></tr>
<tr><td><code id="VAR_cpDetect_Online_+3A_alpha">alpha</code></td>
<td>
<p>Numeric. The desired false alarm rate, where 1/alpha represents the targeted average run length (ARL), which should exceed the length of the data to be monitored.</p>
</td></tr>
<tr><td><code id="VAR_cpDetect_Online_+3A_h">h</code></td>
<td>
<p>Integer. The order of the VAR process.</p>
</td></tr>
<tr><td><code id="VAR_cpDetect_Online_+3A_rlmode">RLmode</code></td>
<td>
<p>Logical. If <code>TRUE</code>, the algorithm terminates when the first alarm is issued.</p>
</td></tr>
<tr><td><code id="VAR_cpDetect_Online_+3A_needrefine">needRefine</code></td>
<td>
<p>Logical. If <code>TRUE</code>, a refinement process is conducted to pinpoint the change point location.</p>
</td></tr>
<tr><td><code id="VAR_cpDetect_Online_+3A_refinesize">refineSize</code></td>
<td>
<p>Numeric. The proportion of the new window size to the original window size, used during refinement.</p>
</td></tr>
<tr><td><code id="VAR_cpDetect_Online_+3A_needrefinecorrection">needRefineCorrection</code></td>
<td>
<p>Logical. If <code>TRUE</code>, a confirmation step is performed during the refinement process to verify the detected change point.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function fits a VAR model to the historical data using the l1 penalty and calculates test statistics for the sliding window to detect change points. If refinement is enabled, a second step narrows down the change point location. Optionally, a correction step can verify the detected change points.
</p>


<h3>Value</h3>

<p>A list containing:
</p>

<dl>
<dt><code>RL</code></dt><dd><p>The index (ignoring historical data) of the last observation read by the algorithm when the first alarm is issued. This is returned only if <code>RLmode = TRUE</code>.</p>
</dd>
<dt><code>cp_refined</code></dt><dd><p>The refined estimate for the location (ignoring historical data) of the change point. This is returned only if <code>RLmode = TRUE</code> and <code>needRefine = TRUE</code>.</p>
</dd>
<dt><code>alarm_locations</code></dt><dd><p>A vector of indices (ignoring historical data) where alarms were raised. This is returned only if <code>RLmode = FALSE</code>.</p>
</dd>
<dt><code>cp_locations</code></dt><dd><p>A vector of refined change point locations (ignoring historical data), corresponding 1-to-1 with the <code>alarm_locations</code>. This is returned only if <code>RLmode = FALSE</code> and <code>needRefine = TRUE</code>.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>library(MASS)
set.seed(2024)
As &lt;- list(matrix(c(0.5, 0.2, 0.1, 0.4), 2, 2))
As_new &lt;- list(matrix(c(-0.5, 0.2, 0.1, -0.4), 2, 2))
Sig &lt;- diag(2)
data_IC &lt;- generateVAR(n = 400, As = As, Sig = Sig, h = 1)
data_OC &lt;- generateVAR(n = 100, As = As_new, Sig = Sig, h = 1,
                       isOldProvided = TRUE, oldxs = data_IC[, ncol(data_IC)])
data &lt;- cbind(data_IC, data_OC)
result &lt;- VAR_cpDetect_Online(data, n0 = 300, w = 20, alpha = 1/200, h = 1,
                              RLmode = TRUE, needRefine = TRUE, refineSize = 1/5,
                              needRefineCorrection = TRUE)
print(result)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
