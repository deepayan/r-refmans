<!DOCTYPE html><html><head><title>Help for package ExpertChoice</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {ExpertChoice}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#augment_levels'><p>Augment levels and B-matrix to Full Factorial Design.</p></a></li>
<li><a href='#check_overshadow'><p>Check Overshadow - Pareto Dominate Solutions</p></a></li>
<li><a href='#construct_question_frame'><p>Convert from choice_sets to a question data</p></a></li>
<li><a href='#dce_efficiency'><p>Efficiency Measures for Discrete Choice Experiments</p></a></li>
<li><a href='#fractional_factorial_efficiency'><p>Fractional Factorial Design Efficiency</p></a></li>
<li><a href='#full_factorial'><p>Full Factorial Design</p></a></li>
<li><a href='#modulo_method'><p>Modulo Method - Described by Street et al.</p></a></li>
<li><a href='#search_design'><p>Search Full Factorial for Fractional Factorial Design</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Design of Discrete Choice and Conjoint Analysis</td>
</tr>
<tr>
<td>Version:</td>
<td>0.2.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Supports designing efficient discrete choice experiments (DCEs). Experimental designs can be formed on the basis of orthogonal arrays or search methods for optimal designs (Federov or mixed integer programs). Various methods for converting these experimental designs into a discrete choice experiment. Many efficiency measures! Draws from literature of Kuhfeld (2010) and Street et. al (2005) &lt;<a href="https://doi.org/10.1016%2Fj.ijresmar.2005.09.003">doi:10.1016/j.ijresmar.2005.09.003</a>&gt;.</td>
</tr>
<tr>
<td>ByteCompile:</td>
<td>true</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/JedStephens/ExpertChoice/issues">https://github.com/JedStephens/ExpertChoice/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.6.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, far, dplyr, DoE.base, rlist, purrr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.0</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2020-04-03 14:11:56 UTC; Jed Stephens</td>
</tr>
<tr>
<td>Author:</td>
<td>Jed Stephens <a href="https://orcid.org/0000-0002-0131-703X"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Jed Stephens &lt;STPJED001@myuct.ac.za&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2020-04-03 14:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='augment_levels'>Augment levels and B-matrix to Full Factorial Design.</h2><span id='topic+augment_levels'></span>

<h3>Description</h3>

<p>Augments the full factorial design with a column summarising the levels of that design. Importantly, it also adds the B-matrix as an attribute.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>augment_levels(full_factorial)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="augment_levels_+3A_full_factorial">full_factorial</code></td>
<td>
<p>a 'data.table' generated from the 'full_factorial' function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a 'data.frame' with an additional column identifying the level and the B-matrix attribute.
</p>


<h3>References</h3>

<p>Street, D. J.; Burgess, L. &amp; Louviere, J. J. Quick and easy choice sets: Constructing optimal and nearly optimal stated choice experiments International Journal of Research in Marketing, 2005 , 22 , 459 - 470
</p>


<h3>Examples</h3>

<pre><code class='language-R'># See Practical Introduction to ExpertChoice Vignette. Step 2.

#Step 1
attrshort  = list(condition = c("0", "1", "2"),
technical =c("0", "1", "2"),
provenance = c("0", "1"))

#Step 2! - the augment_levels function
#' # ff stands for "full fatorial"
 ff  &lt;-  full_factorial(attrshort)
 af  &lt;-  augment_levels(ff)
# af stands for "augmented factorial"
af
# Compare ff and af. - do not confuse them. They serve different purposes.
</code></pre>

<hr>
<h2 id='check_overshadow'>Check Overshadow - Pareto Dominate Solutions</h2><span id='topic+check_overshadow'></span>

<h3>Description</h3>

<p>Check Overshadow - Pareto Dominate Solutions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_overshadow(choice_sets)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_overshadow_+3A_choice_sets">choice_sets</code></td>
<td>
<p>An object of the choiceset class made by one of the DCE methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of logicals indicating which if any card for a given row is Pareto dominate.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#See Step 7 of the Practical Introduction to ExpertChoice Vignette.
# Step 1
attrshort  = list(condition = c("0", "1", "2"),
technical =c("0", "1", "2"),
provenance = c("0", "1"))

#Step 2
#' # ff stands for "full fatorial"
 ff  &lt;-  full_factorial(attrshort)
 af  &lt;-  augment_levels(ff)
# af stands for "augmented factorial"

# Step 3
# Choose a design type: Federov or Orthogonal. Here an Orthogonal one is used.
nlevels &lt;- unlist(purrr::map(ff, function(x){length(levels(x))}))
fractional_factorial &lt;- DoE.base::oa.design(nlevels = nlevels, columns = "min34")

# Step 4 &amp; 5
# The functional draws out the rows from the original augmented full factorial design.
colnames(fractional_factorial) &lt;- colnames(ff)
fractional &lt;- search_design(ff, fractional_factorial)
# Step 5 - Skipped, but important, see vignette.

# Step 6
# Two modulators c(1,1,1) and c(0,1,1) are specified.
dce_modulo &lt;- modulo_method(
fractional,
list(c(1,1,1),c(0,1,1))
)

# Step 7! -- Check for Pareto dominate solutions
check_overshadow(dce_modulo)
</code></pre>

<hr>
<h2 id='construct_question_frame'>Convert from choice_sets to a question data</h2><span id='topic+construct_question_frame'></span>

<h3>Description</h3>

<p>Convert from choice_sets to a question data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>construct_question_frame(
  augmented_full_factorial,
  choice_sets,
  randomise_choice_sets = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="construct_question_frame_+3A_augmented_full_factorial">augmented_full_factorial</code></td>
<td>
<p>The augmented full factorial object.</p>
</td></tr>
<tr><td><code id="construct_question_frame_+3A_choice_sets">choice_sets</code></td>
<td>
<p>The choice sets list generated from one of the methods. (See Step 6 of the tutorial)</p>
</td></tr>
<tr><td><code id="construct_question_frame_+3A_randomise_choice_sets">randomise_choice_sets</code></td>
<td>
<p>A binary variable indicating if the order of the choice sets should be randomised. Some methods create choice sets which have a systematic order. Randomising the order of the choice sets does not change the alternatives within the choice sets. It simply rearranges the choice_set object in a random manner.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data.frame object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#See Step 9 of Practical Introduction to ExpertChoice vignette.

# Step 1
attrshort  = list(condition = c("0", "1", "2"),
technical =c("0", "1", "2"),
provenance = c("0", "1"))

#Step 2
# ff stands for "full fatorial"
 ff  &lt;-  full_factorial(attrshort)
 af  &lt;-  augment_levels(ff)
# af stands for "augmented factorial"

# Step 3
# Choose a design type: Federov or Orthogonal. Here an Orthogonal one is used.
nlevels &lt;- unlist(purrr::map(ff, function(x){length(levels(x))}))
fractional_factorial &lt;- DoE.base::oa.design(nlevels = nlevels, columns = "min34")

# Step 4 &amp; 5
# The functional draws out the rows from the original augmented full factorial design.
colnames(fractional_factorial) &lt;- colnames(ff)
fractional &lt;- search_design(ff, fractional_factorial)
# Step 5 (skipped, but important, see vignette)

# Step 6
# Two modulators c(1,1,1) and c(0,1,1) are specified.
dce_modulo &lt;- modulo_method(
fractional,
list(c(1,1,1),c(0,1,1))
)

# Step 7 and Step 8 are very important for the design, but skipped here.

# Step 9! -- Construct a question frame to use with your study.
# Note the use of af here.
questions &lt;- construct_question_frame(af, dce_modulo)
levels(questions$condition) &lt;- c("bad", "good", "excellent")
levels(questions$technical) &lt;- c("poor", "fair", "skilled")
levels(questions$provenance) &lt;- c("none", "present")
questions
</code></pre>

<hr>
<h2 id='dce_efficiency'>Efficiency Measures for Discrete Choice Experiments</h2><span id='topic+dce_efficiency'></span>

<h3>Description</h3>

<p>Efficiency Measures for Discrete Choice Experiments
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dce_efficiency(augmented_full_factorial, choice_sets)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dce_efficiency_+3A_augmented_full_factorial">augmented_full_factorial</code></td>
<td>
<p>The level augmented full factorial. See tutorial step 2.</p>
</td></tr>
<tr><td><code id="dce_efficiency_+3A_choice_sets">choice_sets</code></td>
<td>
<p>A list of choice sets generated by one of the methods used to convert from fractional factorial designs.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of named output.
</p>


<h3>References</h3>

<p>Street, D.J., Burgess, L. and Louviere, J.J., 2005. Quick and easy choice sets: constructing optimal and nearly optimal stated choice experiments. International Journal of Research in Marketing, 22(4), pp.459-470.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># See Step 8 of the Practical Introduction to ExpertChoice vignette.
# Step 1
attrshort  = list(condition = c("0", "1", "2"),
technical =c("0", "1", "2"),
provenance = c("0", "1"))

#Step 2
# ff stands for "full fatorial"
 ff  &lt;-  full_factorial(attrshort)
 af  &lt;-  augment_levels(ff)
# af stands for "augmented factorial"

# Step 3
# Choose a design type: Federov or Orthogonal. Here an Orthogonal one is used.
nlevels &lt;- unlist(purrr::map(ff, function(x){length(levels(x))}))
fractional_factorial &lt;- DoE.base::oa.design(nlevels = nlevels, columns = "min34")

# Step 4 &amp; 5
# The functional draws out the rows from the original augmented full factorial design.
colnames(fractional_factorial) &lt;- colnames(ff)
fractional &lt;- search_design(ff, fractional_factorial)
# Step 5 (skipped, but important, see vignette)

# Step 6
# Two modulators c(1,1,1) and c(0,1,1) are specified.
dce_modulo &lt;- modulo_method(
fractional,
list(c(1,1,1),c(0,1,1))
)

# Step 7 (skipped)

# Step 8! -- Inspect the D-efficiency using the Street et. al method of the DCE design.
# NOTE: the af is used at this stage not the ff.
dce_efficiency(af, dce_modulo)
</code></pre>

<hr>
<h2 id='fractional_factorial_efficiency'>Fractional Factorial Design Efficiency</h2><span id='topic+fractional_factorial_efficiency'></span>

<h3>Description</h3>

<p>Fractional Factorial Design Efficiency
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fractional_factorial_efficiency(formula, searched_fractional_factorial)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fractional_factorial_efficiency_+3A_formula">formula</code></td>
<td>
<p>A specification, in formula form, of the desired effects sought to be estimated.</p>
</td></tr>
<tr><td><code id="fractional_factorial_efficiency_+3A_searched_fractional_factorial">searched_fractional_factorial</code></td>
<td>
<p>a fractional factorial generated as the result of a 'search_design'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with the following objects:
1. X - This is the formula expanded version of the fractional factorial which was passed to the function.
2. information_mat - This is the information matrix described by the associated note. Note: it is rounded to three decimal places to ease reading.
3. inv_information_mat - This is the inverse of the information matrix. Note: it is rounded to three decimal places to ease reading.
4. lamda_mat - This is the diagonal elements of the Lamda Matrix described by Kuhfeld (pg. 62). The elements are the eigen values of the inv_information_mat.
5. inv_diag - This is the diagonal elements of the inv_information_mat. (May be of use to some researchers...)
6. GWLP - This is the generalised world lengths for the searched design. (Note: this would not change depending on what is in the formula expansion.)
7. A_eff - This is the A-efficiency of the design given the particular formula expansion.
8. D_eff - This is the D-efficiency of the design given the particular formula expansion.
</p>


<h3>References</h3>

<p>Kuhfeld, W. F. Marketing Research Methods in SAS Experimental Design, Choice, Conjoint, and Graphical Techniques 2010.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># See step 5 of the Practical Introduction to ExpertChoice vignette.

# Step 1
attrshort  = list(condition = c("0", "1", "2"),
technical =c("0", "1", "2"),
provenance = c("0", "1"))

#Step 2
# ff stands for "full fatorial"
 ff  &lt;-  full_factorial(attrshort)
 af  &lt;-  augment_levels(ff)
# af stands for "augmented factorial"

# Step 3
# Choose a design type: Federov or Orthogonal. Here an Orthogonal one is used.
nlevels &lt;- unlist(purrr::map(ff, function(x){length(levels(x))}))
fractional_factorial &lt;- DoE.base::oa.design(nlevels = nlevels, columns = "min34")

# Step 4
# The functional draws out the rows from the original augmented full factorial design.
colnames(fractional_factorial) &lt;- colnames(ff)
fractional &lt;- search_design(ff, fractional_factorial)

# Step 5! - The fractional_factorial_efficiency function
# The formula requires reference to the original attributes of the design.
# Check for the main effects.
fractional_factorial_efficiency(~ condition + technical + provenance, fractional)
# Check for the main effects with some interaction.
fractional_factorial_efficiency(~ condition + technical * provenance, fractional)
</code></pre>

<hr>
<h2 id='full_factorial'>Full Factorial Design</h2><span id='topic+full_factorial'></span>

<h3>Description</h3>

<p>Generates the full factorial design with all the factors coded using standardised orthogonal contrast coding.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>full_factorial(attributes_list)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="full_factorial_+3A_attributes_list">attributes_list</code></td>
<td>
<p>A named list: giving the variable name and the levels as characters. The levels should start from the base of either &quot;0&quot; or &quot;1&quot; and go up in integer values.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a 'data.frame' with the full factorial design and factors coded using standardised orthogonal contrast coding.
</p>


<h3>References</h3>

<p>Kuhfeld, W. F. Marketing Research Methods in SAS Experimental Design, Choice, Conjoint, and Graphical Techniques 2010.
</p>
<p>JÃ¶rg Suckut (https://stats.stackexchange.com/users/237455/j
</p>


<h3>Examples</h3>

<pre><code class='language-R'># See step 1 of the Practical Introduction to ExpertChoice vignette.
attrshort  = list(condition = c("0", "1", "2"),
technical =c("0", "1", "2"),
provenance = c("0", "1"))
full_factorial(attrshort)
</code></pre>

<hr>
<h2 id='modulo_method'>Modulo Method - Described by Street et al.</h2><span id='topic+modulo_method'></span>

<h3>Description</h3>

<p>Modulo Method - Described by Street et al.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>modulo_method(fractional_fatorial, generators)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="modulo_method_+3A_fractional_fatorial">fractional_fatorial</code></td>
<td>
<p>The usual.</p>
</td></tr>
<tr><td><code id="modulo_method_+3A_generators">generators</code></td>
<td>
<p>a list of generators</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a choiceset list.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># See step 6 of the Practical Introduction to ExpertChoice vignette.

# Step 1
attrshort  = list(condition = c("0", "1", "2"),
technical =c("0", "1", "2"),
provenance = c("0", "1"))

#Step 2
# ff stands for "full fatorial"
 ff  &lt;-  full_factorial(attrshort)
 af  &lt;-  augment_levels(ff)
# af stands for "augmented factorial"

# Step 3
# Choose a design type: Federov or Orthogonal. Here an Orthogonal one is used.
nlevels &lt;- unlist(purrr::map(ff, function(x){length(levels(x))}))
fractional_factorial &lt;- DoE.base::oa.design(nlevels = nlevels, columns = "min34")

# Step 4
# The functional draws out the rows from the original augmented full factorial design.
colnames(fractional_factorial) &lt;- colnames(ff)
fractional &lt;- search_design(ff, fractional_factorial)
# Step 5 - Skipped, but important, see vignette.

# Step 6! -- The modulo_method function
# Two modulators c(1,1,1) and c(0,1,1) are specified.
dce_modulo &lt;- modulo_method(
fractional,
list(c(1,1,1),c(0,1,1))
)
dce_modulo
</code></pre>

<hr>
<h2 id='search_design'>Search Full Factorial for Fractional Factorial Design</h2><span id='topic+search_design'></span>

<h3>Description</h3>

<p>Returns a consistent fractional factorial design from the input fractional factorial design. The key advantage of this function is that it ensures factors are coded and enchances the attributes of the output.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>search_design(full_factorial, fractional_factorial_design)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="search_design_+3A_full_factorial">full_factorial</code></td>
<td>
<p>a 'data.table' generated by the 'full_factorial' function</p>
</td></tr>
<tr><td><code id="search_design_+3A_fractional_factorial_design">fractional_factorial_design</code></td>
<td>
<p>a means of creating a fractional design using either orthogonal arrays or Federov. See the tutorial for examples.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a 'data.frame' with only the rows of your chosen fractional factorial design.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># The use of this function depends on what the input to the argument fractional_factorial_design
# will be. See Step 4 of Practical Introduction to ExpertChoice vignette.

# Step 1
attrshort  = list(condition = c("0", "1", "2"),
technical =c("0", "1", "2"),
provenance = c("0", "1"))

#Step 2
# ff stands for "full fatorial"
 ff  &lt;-  full_factorial(attrshort)
 af  &lt;-  augment_levels(ff)
# af stands for "augmented factorial"

# Step 3
# Choose a design type: Federov or Orthogonal. Here an Orthogonal one is used.
nlevels &lt;- unlist(purrr::map(ff, function(x){length(levels(x))}))
fractional_factorial &lt;- DoE.base::oa.design(nlevels = nlevels, columns = "min34")

# Step 4! - The search_design function.
# The functional draws out the rows from the original augmented full factorial design.
colnames(fractional_factorial) &lt;- colnames(ff)
fractional &lt;- search_design(ff, fractional_factorial)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
