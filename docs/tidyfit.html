<!DOCTYPE html><html><head><title>Help for package tidyfit</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {tidyfit}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#.fit.adalasso'><p>Adaptive Lasso regression or classification for <code>tidyfit</code></p></a></li>
<li><a href='#.fit.anova'><p>ANOVA for <code>tidyfit</code></p></a></li>
<li><a href='#.fit.bayes'><p>Bayesian generalized linear regression for <code>tidyfit</code></p></a></li>
<li><a href='#.fit.blasso'><p>Bayesian Lasso regression for <code>tidyfit</code></p></a></li>
<li><a href='#.fit.bma'><p>Bayesian model averaging for <code>tidyfit</code></p></a></li>
<li><a href='#.fit.boost'><p>Gradient boosting regression for <code>tidyfit</code></p></a></li>
<li><a href='#.fit.bridge'><p>Bayesian ridge regression for <code>tidyfit</code></p></a></li>
<li><a href='#.fit.chisq'><p>Pearson's Chi-squared test for <code>tidyfit</code></p></a></li>
<li><a href='#.fit.cor'><p>Pearson's correlation for <code>tidyfit</code></p></a></li>
<li><a href='#.fit.enet'><p>ElasticNet regression or classification for <code>tidyfit</code></p></a></li>
<li><a href='#.fit.genetic'><p>Genetic algorithm with linear regression fitness evaluator for <code>tidyfit</code></p></a></li>
<li><a href='#.fit.gets'><p>General-to-specific regression for <code>tidyfit</code></p></a></li>
<li><a href='#.fit.glm'><p>Generalized linear regression for <code>tidyfit</code></p></a></li>
<li><a href='#.fit.glmm'><p>Generalized linear mixed-effects model for <code>tidyfit</code></p></a></li>
<li><a href='#.fit.hfr'><p>Hierarchical feature regression for <code>tidyfit</code></p></a></li>
<li><a href='#.fit.lasso'><p>Lasso regression and classification for <code>tidyfit</code></p></a></li>
<li><a href='#.fit.lm'><p>Linear regression for <code>tidyfit</code></p></a></li>
<li><a href='#.fit.mrmr'><p>Minimum redundancy, maximum relevance feature selection for <code>tidyfit</code></p></a></li>
<li><a href='#.fit.mslm'><p>Markov-Switching Regression for <code>tidyfit</code></p></a></li>
<li><a href='#.fit.nnet'><p>Neural Network regression for <code>tidyfit</code></p></a></li>
<li><a href='#.fit.pcr'><p>Principal Components Regression for <code>tidyfit</code></p></a></li>
<li><a href='#.fit.plsr'><p>Partial Least Squares Regression for <code>tidyfit</code></p></a></li>
<li><a href='#.fit.quantile'><p>Quantile regression for <code>tidyfit</code></p></a></li>
<li><a href='#.fit.quantile_rf'><p>Quantile regression forest for <code>tidyfit</code></p></a></li>
<li><a href='#.fit.relief'><p>ReliefF and RReliefF feature selection algorithm for <code>tidyfit</code></p></a></li>
<li><a href='#.fit.rf'><p>Random Forest regression or classification for <code>tidyfit</code></p></a></li>
<li><a href='#.fit.ridge'><p>Ridge regression and classification for <code>tidyfit</code></p></a></li>
<li><a href='#.fit.robust'><p>Robust regression for <code>tidyfit</code></p></a></li>
<li><a href='#.fit.spikeslab'><p>Bayesian Spike and Slab regression or classification for <code>tidyfit</code></p></a></li>
<li><a href='#.fit.subset'><p>Best subset regression and classification for <code>tidyfit</code></p></a></li>
<li><a href='#.fit.svm'><p>Support vector regression or classification for <code>tidyfit</code></p></a></li>
<li><a href='#.fit.tvp'><p>Bayesian Time-Varying Regression for <code>tidyfit</code></p></a></li>
<li><a href='#classify'><p>Classification on tidy data</p></a></li>
<li><a href='#coef.tidyfit.models'><p>Extract coefficients from a <code>tidyfit.models</code> frame</p></a></li>
<li><a href='#explain'><p>An interface for variable importance measures for a fitted tidyfit.models frames</p></a></li>
<li><a href='#explain.tidyfit.models'><p>An interface for variable importance measures for a fitted tidyfit.models frames</p></a></li>
<li><a href='#Factor_Industry_Returns'><p>Industry-Factor Returns Data Set</p></a></li>
<li><a href='#fitted.tidyfit.models'><p>Obtain fitted values from models in a <code>tidyfit.models</code> frame</p></a></li>
<li><a href='#m'><p>Generic model wrapper for <code>tidyfit</code></p></a></li>
<li><a href='#predict.tidyfit.models'><p>Predict using a <code>tidyfit.models</code> frame</p></a></li>
<li><a href='#regress'><p>Linear regression on tidy data</p></a></li>
<li><a href='#residuals.tidyfit.models'><p>Obtain residuals from models in a <code>tidyfit.models</code> frame</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Regularized Linear Modeling with Tidy Data</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-03-23</td>
</tr>
<tr>
<td>Version:</td>
<td>0.7.1</td>
</tr>
<tr>
<td>Author:</td>
<td>Johann Pfitzinger [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Johann Pfitzinger &lt;johann.pfitzinger@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>An extension to the 'R' tidy data environment for automated machine learning. The package allows fitting and cross validation of linear regression and classification algorithms on grouped data. </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://tidyfit.residualmetrics.com">https://tidyfit.residualmetrics.com</a>,
<a href="https://github.com/jpfitzinger/tidyfit">https://github.com/jpfitzinger/tidyfit</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5)</td>
</tr>
<tr>
<td>Imports:</td>
<td>broom, crayon, dials, dplyr, furrr, generics, magrittr, MASS,
methods, progressr, purrr, rlang, rsample, stats, tibble,
tidyr, utils, vctrs, yardstick</td>
</tr>
<tr>
<td>Suggests:</td>
<td>arm, bestglm, BMS, BoomSpikeSlab, CORElearn, e1071, gaselect,
gets, ggplot2, glmnet, hfr, iml, kableExtra, knitr, lme4,
lmtest, lubridate, markdown, mboost, monomvn, mRMRe, MSwM,
nnet, pls, quantreg, quantregForest, randomForest, sandwich,
sensitivity, shrinkTVP, stringr, rmarkdown, testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-03-23 14:15:50 UTC; johann</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-03-23 15:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='.fit.adalasso'>Adaptive Lasso regression or classification for <code>tidyfit</code></h2><span id='topic+.fit.adalasso'></span>

<h3>Description</h3>

<p>Fits an adaptive Lasso regression or classification on a 'tidyFit' <code>R6</code> class. The function can be used with <code><a href="#topic+regress">regress</a></code> and <code><a href="#topic+classify">classify</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'adalasso'
.fit(self, data = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".fit.adalasso_+3A_self">self</code></td>
<td>
<p>a 'tidyFit' R6 class.</p>
</td></tr>
<tr><td><code id=".fit.adalasso_+3A_data">data</code></td>
<td>
<p>a data frame, data frame extension (e.g. a tibble), or a lazy data frame (e.g. from dbplyr or dtplyr).</p>
</td></tr>
</table>


<h3>Details</h3>

<p><strong>Hyperparameters:</strong>
</p>

<ul>
<li> <p><code>lambda</code> <em>(L1 penalty)</em>
</p>
</li>
<li> <p><code>lambda_ridge</code> <em>(L2 penalty (default = 0.01) used in the first step to determine the penalty factor)</em>
</p>
</li></ul>

<p><strong>Important method arguments (passed to <code><a href="#topic+m">m</a></code>)</strong>
</p>
<p>The adaptive Lasso is a weighted implementation of the Lasso algorithm, with covariate-specific weights obtained using an initial regression fit (in this case, a ridge regression with <code>lambda = lambda_ridge</code>, where <code>lambda_ridge</code> can be passed as an argument). The adaptive Lasso is computed using the <code>glmnet::glmnet</code> function. See <code>?glmnet</code> for more details. For classification pass <code>family = "binomial"</code> to <code>...</code> in <code><a href="#topic+m">m</a></code> or use <code><a href="#topic+classify">classify</a></code>.
</p>
<p><strong>Implementation</strong>
</p>
<p>Features are standardized by default with coefficients transformed to the original scale.
</p>
<p>If no hyperparameter grid is passed (<code>is.null(control$lambda)</code>), <code>dials::grid_regular()</code> is used to determine a sensible default grid. The grid size is 100. Note that the grid selection tools provided by <code>glmnet::glmnet</code> cannot be used (e.g. <code>dfmax</code>). This is to guarantee identical grids across groups in the tibble.
</p>


<h3>Value</h3>

<p>A fitted 'tidyFit' class model.
</p>


<h3>Author(s)</h3>

<p>Johann Pfitzinger
</p>


<h3>References</h3>

<p>Zou, H. (2006).
The Adaptive Lasso and Its Oracle Properties.
Journal of the American Statistical Association, 101(476), 1418-1429.
</p>
<p>Jerome Friedman, Trevor Hastie, Robert Tibshirani (2010). Regularization Paths for Generalized Linear Models via Coordinate Descent. Journal of Statistical Software, 33(1), 1-22. URL https://www.jstatsoft.org/v33/i01/.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+.fit.lasso">.fit.lasso</a></code>, <code><a href="#topic+.fit.enet">.fit.enet</a></code>, <code><a href="#topic+.fit.ridge">.fit.ridge</a></code> and <code><a href="#topic+m">m</a></code> methods
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load data
data &lt;- tidyfit::Factor_Industry_Returns

# Stand-alone function
fit &lt;- m("adalasso", Return ~ ., data, lambda = 0.5)
fit

# Within 'regress' function
fit &lt;- regress(data, Return ~ ., m("adalasso", lambda = c(0.1, 0.5)),
               .mask = c("Date", "Industry"))
coef(fit)

</code></pre>

<hr>
<h2 id='.fit.anova'>ANOVA for <code>tidyfit</code></h2><span id='topic+.fit.anova'></span>

<h3>Description</h3>

<p>Performs Analysis of Variance on a 'tidyFit' <code>R6</code> class. The function can be used with <code><a href="#topic+regress">regress</a></code> or <code><a href="#topic+classify">classify</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'anova'
.fit(self, data = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".fit.anova_+3A_self">self</code></td>
<td>
<p>a 'tidyFit' R6 class.</p>
</td></tr>
<tr><td><code id=".fit.anova_+3A_data">data</code></td>
<td>
<p>a data frame, data frame extension (e.g. a tibble), or a lazy data frame (e.g. from dbplyr or dtplyr).</p>
</td></tr>
</table>


<h3>Details</h3>

<p><strong>Hyperparameters:</strong>
</p>
<p><em>None. Cross validation not applicable.</em>
</p>
<p><strong>Important method arguments (passed to <code><a href="#topic+m">m</a></code>)</strong>
</p>
<p>The function provides a wrapper for <code>stats::anova</code>. See <code>?anova</code> for more details.
</p>
<p>First a <code>glm</code> model is fitted which is passed to <code>anova</code>.
</p>


<h3>Value</h3>

<p>A fitted 'tidyFit' class model.
</p>


<h3>Author(s)</h3>

<p>Johann Pfitzinger
</p>


<h3>See Also</h3>

<p><code><a href="#topic+.fit.lm">.fit.lm</a></code>, <code><a href="#topic+.fit.glm">.fit.glm</a></code> and <code><a href="#topic+m">m</a></code> methods
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load data
data &lt;- tidyfit::Factor_Industry_Returns

# Stand-alone function
fit &lt;- m("anova", Return ~ `Mkt-RF` + HML + SMB, data)
fit

# Within 'regress' function
fit &lt;- regress(data, Return ~ ., m("anova"), .mask = c("Date", "Industry"))
tidyr::unnest(coef(fit), model_info)

</code></pre>

<hr>
<h2 id='.fit.bayes'>Bayesian generalized linear regression for <code>tidyfit</code></h2><span id='topic+.fit.bayes'></span>

<h3>Description</h3>

<p>Fits a Bayesian regression on a 'tidyFit' <code>R6</code> class. The function can be used with <code><a href="#topic+regress">regress</a></code> and <code><a href="#topic+classify">classify</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bayes'
.fit(self, data = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".fit.bayes_+3A_self">self</code></td>
<td>
<p>a 'tidyFit' R6 class.</p>
</td></tr>
<tr><td><code id=".fit.bayes_+3A_data">data</code></td>
<td>
<p>a data frame, data frame extension (e.g. a tibble), or a lazy data frame (e.g. from dbplyr or dtplyr).</p>
</td></tr>
</table>


<h3>Details</h3>

<p><strong>Hyperparameters:</strong>
</p>
<p><em>None. Cross validation not applicable.</em>
</p>
<p><strong>Important method arguments (passed to <code><a href="#topic+m">m</a></code>)</strong>
</p>
<p>The function provides a wrapper for <code>arm::bayesglm</code>. See <code>?bayesglm</code> for more details.
</p>
<p><strong>Implementation</strong>
</p>
<p><em>No implementation notes</em>
</p>


<h3>Value</h3>

<p>A fitted 'tidyFit' class model.
</p>
<p>A 'tibble'.
</p>


<h3>Author(s)</h3>

<p>Johann Pfitzinger
</p>


<h3>References</h3>

<p>Gelman A, Su Y (2021). <em>arm: Data Analysis Using Regression and Multilevel/Hierarchical Models</em>. R package version 1.12-2, <a href="https://CRAN.R-project.org/package=arm">https://CRAN.R-project.org/package=arm</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+.fit.glm">.fit.glm</a></code> and <code><a href="#topic+m">m</a></code> methods
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load data
data &lt;- tidyfit::Factor_Industry_Returns

# Stand-alone function
fit &lt;- m("bayes", Return ~ ., data)
fit

# Within 'regress' function
fit &lt;- regress(data, Return ~ ., m("bayes"), .mask = c("Date", "Industry"))
coef(fit)


</code></pre>

<hr>
<h2 id='.fit.blasso'>Bayesian Lasso regression for <code>tidyfit</code></h2><span id='topic+.fit.blasso'></span>

<h3>Description</h3>

<p>Fits a Bayesian Lasso regression on a 'tidyFit' <code>R6</code> class. The function can be used with <code><a href="#topic+regress">regress</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'blasso'
.fit(self, data = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".fit.blasso_+3A_self">self</code></td>
<td>
<p>a tidyFit R6 class.</p>
</td></tr>
<tr><td><code id=".fit.blasso_+3A_data">data</code></td>
<td>
<p>a data frame, data frame extension (e.g. a tibble), or a lazy data frame (e.g. from dbplyr or dtplyr).</p>
</td></tr>
</table>


<h3>Details</h3>

<p><strong>Hyperparameters:</strong>
</p>
<p><em>None. Cross validation not applicable.</em>
</p>
<p><strong>Important method arguments (passed to <code><a href="#topic+m">m</a></code>)</strong>
</p>
<p>The function provides a wrapper for <code>monomvn::blasso</code>. See <code>?blasso</code> for more details.
</p>
<p><strong>Implementation</strong>
</p>
<p>Features are standardized by default with coefficients transformed to the original scale.
</p>


<h3>Value</h3>

<p>A fitted tidyFit class model.
</p>


<h3>Author(s)</h3>

<p>Johann Pfitzinger
</p>


<h3>References</h3>

<p>Gramacy RB, (qpgen2/quadprog) wFcfCMaubBAT (2023). <em>monomvn: Estimation for MVN and Student-t Data with Monotone Missingness</em>. R package version 1.9-17, <a href="https://CRAN.R-project.org/package=monomvn">https://CRAN.R-project.org/package=monomvn</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+.fit.lasso">.fit.lasso</a></code>, <code><a href="#topic+.fit.bridge">.fit.bridge</a></code> and <code><a href="#topic+m">m</a></code> methods
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load data
data &lt;- tidyfit::Factor_Industry_Returns

# Stand-alone function
fit &lt;- m("blasso", Return ~ ., data, T = 100)
fit

# Within 'regress' function
fit &lt;- regress(data, Return ~ ., m("blasso", T = 100),
               .mask = c("Date", "Industry"))
coef(fit)

</code></pre>

<hr>
<h2 id='.fit.bma'>Bayesian model averaging for <code>tidyfit</code></h2><span id='topic+.fit.bma'></span>

<h3>Description</h3>

<p>Fits a Bayesian model averaging regression on a 'tidyFit' <code>R6</code> class. The function can be used with <code><a href="#topic+regress">regress</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bma'
.fit(self, data = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".fit.bma_+3A_self">self</code></td>
<td>
<p>a 'tidyFit' R6 class.</p>
</td></tr>
<tr><td><code id=".fit.bma_+3A_data">data</code></td>
<td>
<p>a data frame, data frame extension (e.g. a tibble), or a lazy data frame (e.g. from dbplyr or dtplyr).</p>
</td></tr>
</table>


<h3>Details</h3>

<p><strong>Hyperparameters:</strong>
</p>
<p><em>None. Cross validation not applicable.</em>
</p>
<p><strong>Important method arguments (passed to <code><a href="#topic+m">m</a></code>)</strong>
</p>

<ul>
<li> <p><code>iter</code> (<em>number of iteration draws</em>)
</p>
</li>
<li> <p><code>mcmc</code> (<em>model sampler used (default 'bd')</em>)
</p>
</li></ul>

<p>The function provides a wrapper for <code>BMS::bms</code>. See <code>?bms</code> for more details.
</p>
<p><strong>Implementation</strong>
</p>
<p>The underlying function automatically generates plotting output, which is not suppressed.
</p>
<p>Use <code>coef(fit)</code> to obtain posterior mean, standard deviation as well as posterior inclusion probabilities for the features.
</p>


<h3>Value</h3>

<p>A fitted 'tidyFit' class model.
</p>


<h3>Author(s)</h3>

<p>Johann Pfitzinger
</p>


<h3>References</h3>

<p>Feldkircher, M. and S. Zeugner (2015).
<em>Bayesian Model Averaging Employing Fixed and Flexible Priors: The BMS Package for R</em>,
Journal of Statistical Software 68(4).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+.fit.bayes">.fit.bayes</a></code> and <code><a href="#topic+m">m</a></code> methods
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load data
data &lt;- tidyfit::Factor_Industry_Returns

# Stand-alone function
fit &lt;- m("bma", Return ~ `Mkt-RF` + HML + SMB + RMW + CMA, data)
fit

# Within 'regress' function
fit &lt;- regress(data, Return ~ ., m("bma"), .mask = c("Date", "Industry"))
coef(fit)

</code></pre>

<hr>
<h2 id='.fit.boost'>Gradient boosting regression for <code>tidyfit</code></h2><span id='topic+.fit.boost'></span>

<h3>Description</h3>

<p>Fits a gradient boosting regression or classification on a 'tidyFit' <code>R6</code> class. The function can be used with <code><a href="#topic+regress">regress</a></code> and <code><a href="#topic+classify">classify</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'boost'
.fit(self, data = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".fit.boost_+3A_self">self</code></td>
<td>
<p>a 'tidyFit' R6 class.</p>
</td></tr>
<tr><td><code id=".fit.boost_+3A_data">data</code></td>
<td>
<p>a data frame, data frame extension (e.g. a tibble), or a lazy data frame (e.g. from dbplyr or dtplyr).</p>
</td></tr>
</table>


<h3>Details</h3>

<p><strong>Hyperparameters:</strong>
</p>

<ul>
<li> <p><code>mstop</code> (<em>number of boosting iterations</em>)
</p>
</li>
<li> <p><code>nu</code> (<em>step size</em>)
</p>
</li></ul>

<p><strong>Important method arguments (passed to <code><a href="#topic+m">m</a></code>)</strong>
</p>
<p>The gradient boosting regression is performed using <code>mboost::glmboost</code>. See <code>?glmboost</code> for more details.
</p>
<p><strong>Implementation</strong>
</p>
<p>Features are standardized by default with coefficients transformed to the original scale.
</p>
<p>If no hyperparameter grid is passed (<code>is.null(control$mstop)</code> and <code>is.null(control$nu)</code>), the default grid is used with <code>mstop = c(100, 500, 1000, 5000)</code> and <code>nu = c(0.01, 0.05, 0.1, 0.15, 0.2, 0.25)</code>.
</p>


<h3>Value</h3>

<p>A fitted 'tidyFit' class model.
</p>
<p>A 'tibble'.
</p>


<h3>Author(s)</h3>

<p>Johann Pfitzinger
</p>


<h3>References</h3>

<p>T. Hothorn, P. Buehlmann, T. Kneib, M. Schmid, and B. Hofner (2022). mboost: Model-Based Boosting, R package version 2.9-7,https://CRAN.R-project.org/package=mboost.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+m">m</a></code> method
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load data
data &lt;- tidyfit::Factor_Industry_Returns

# Stand-alone function
fit &lt;- m("boost", Return ~ ., data, nu = 0.1, mstop = 100)
fit

# Within 'regress' function
fit &lt;- regress(data, Return ~ ., m("boost", nu = c(0.1, 0.05), mstop = 100),
               .mask = c("Date", "Industry"))
coef(fit)

</code></pre>

<hr>
<h2 id='.fit.bridge'>Bayesian ridge regression for <code>tidyfit</code></h2><span id='topic+.fit.bridge'></span>

<h3>Description</h3>

<p>Fits a Bayesian ridge regression on a 'tidyFit' <code>R6</code> class. The function can be used with <code><a href="#topic+regress">regress</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bridge'
.fit(self, data = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".fit.bridge_+3A_self">self</code></td>
<td>
<p>a tidyFit R6 class.</p>
</td></tr>
<tr><td><code id=".fit.bridge_+3A_data">data</code></td>
<td>
<p>a data frame, data frame extension (e.g. a tibble), or a lazy data frame (e.g. from dbplyr or dtplyr).</p>
</td></tr>
</table>


<h3>Details</h3>

<p><strong>Hyperparameters:</strong>
</p>
<p><em>None. Cross validation not applicable.</em>
</p>
<p><strong>Important method arguments (passed to <code><a href="#topic+m">m</a></code>)</strong>
</p>
<p>The function provides a wrapper for <code>monomvn::bridge</code>. See <code>?bridge</code> for more details.
</p>
<p><strong>Implementation</strong>
</p>
<p>Features are standardized by default with coefficients transformed to the original scale.
</p>


<h3>Value</h3>

<p>A fitted tidyFit class model.
</p>


<h3>Author(s)</h3>

<p>Johann Pfitzinger
</p>


<h3>References</h3>

<p>Gramacy RB, (qpgen2/quadprog) wFcfCMaubBAT (2023). <em>monomvn: Estimation for MVN and Student-t Data with Monotone Missingness</em>. R package version 1.9-17, <a href="https://CRAN.R-project.org/package=monomvn">https://CRAN.R-project.org/package=monomvn</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+.fit.ridge">.fit.ridge</a></code>, <code><a href="#topic+.fit.blasso">.fit.blasso</a></code> and <code><a href="#topic+m">m</a></code> methods
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load data
data &lt;- tidyfit::Factor_Industry_Returns

# Stand-alone function
fit &lt;- m("bridge", Return ~ ., data, T = 100)
fit

# Within 'regress' function
fit &lt;- regress(data, Return ~ ., m("bridge", T = 100),
               .mask = c("Date", "Industry"))
coef(fit)

</code></pre>

<hr>
<h2 id='.fit.chisq'>Pearson's Chi-squared test for <code>tidyfit</code></h2><span id='topic+.fit.chisq'></span>

<h3>Description</h3>

<p>Calculates Pearson's Chi-squared test on a 'tidyFit' <code>R6</code> class. The function can be used with <code><a href="#topic+classify">classify</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'chisq'
.fit(self, data = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".fit.chisq_+3A_self">self</code></td>
<td>
<p>a 'tidyFit' R6 class.</p>
</td></tr>
<tr><td><code id=".fit.chisq_+3A_data">data</code></td>
<td>
<p>a data frame, data frame extension (e.g. a tibble), or a lazy data frame (e.g. from dbplyr or dtplyr).</p>
</td></tr>
</table>


<h3>Details</h3>

<p><strong>Hyperparameters:</strong>
</p>
<p><em>None. Cross validation not applicable.</em>
</p>
<p><strong>Important method arguments (passed to <code><a href="#topic+m">m</a></code>)</strong>
</p>
<p>The function provides a wrapper for <code>stats::chisq.test</code>. See <code>?chisq.test</code> for more details.
</p>
<p><strong>Implementation</strong>
</p>
<p>Results can be viewed using <code>coef</code>.
</p>


<h3>Value</h3>

<p>A fitted 'tidyFit' class model.
</p>


<h3>Author(s)</h3>

<p>Johann Pfitzinger
</p>


<h3>See Also</h3>

<p><code><a href="#topic+.fit.cor">.fit.cor</a></code> and <code><a href="#topic+m">m</a></code> methods
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load data
data &lt;- tidyfit::Factor_Industry_Returns
data &lt;- dplyr::mutate_at(data, dplyr::vars(-Date, -Industry), dplyr::ntile, n = 10)

# Within 'classify' function
fit &lt;- classify(data, Return ~ ., m("chisq"), .mask = c("Date", "Industry"))
tidyr::unnest(coef(fit), model_info)

</code></pre>

<hr>
<h2 id='.fit.cor'>Pearson's correlation for <code>tidyfit</code></h2><span id='topic+.fit.cor'></span>

<h3>Description</h3>

<p>Calculates Pearson's correlation coefficient on a 'tidyFit' <code>R6</code> class. The function can be used with <code><a href="#topic+regress">regress</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cor'
.fit(self, data = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".fit.cor_+3A_self">self</code></td>
<td>
<p>a 'tidyFit' R6 class.</p>
</td></tr>
<tr><td><code id=".fit.cor_+3A_data">data</code></td>
<td>
<p>a data frame, data frame extension (e.g. a tibble), or a lazy data frame (e.g. from dbplyr or dtplyr).</p>
</td></tr>
</table>


<h3>Details</h3>

<p><strong>Hyperparameters:</strong>
</p>
<p><em>None. Cross validation not applicable.</em>
</p>
<p><strong>Important method arguments (passed to <code><a href="#topic+m">m</a></code>)</strong>
</p>
<p>The function provides a wrapper for <code>stats::cor.test</code>. See <code>?cor.test</code> for more details.
</p>
<p><strong>Implementation</strong>
</p>
<p>Results can be viewed using <code>coef</code>.
</p>


<h3>Value</h3>

<p>A fitted 'tidyFit' class model.
</p>


<h3>Author(s)</h3>

<p>Johann Pfitzinger
</p>


<h3>See Also</h3>

<p><code><a href="#topic+.fit.chisq">.fit.chisq</a></code> and <code><a href="#topic+m">m</a></code> methods
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load data
data &lt;- tidyfit::Factor_Industry_Returns

# Stand-alone function
fit &lt;- m("cor", Return ~ `Mkt-RF` + HML + SMB, data)
fit

# Within 'regress' function
fit &lt;- regress(data, Return ~ ., m("cor"), .mask = c("Date", "Industry"))
tidyr::unnest(coef(fit), model_info)

</code></pre>

<hr>
<h2 id='.fit.enet'>ElasticNet regression or classification for <code>tidyfit</code></h2><span id='topic+.fit.enet'></span>

<h3>Description</h3>

<p>Fits an ElasticNet regression or classification on a 'tidyFit' <code>R6</code> class. The function can be used with <code><a href="#topic+regress">regress</a></code> and <code><a href="#topic+classify">classify</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'enet'
.fit(self, data = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".fit.enet_+3A_self">self</code></td>
<td>
<p>a 'tidyFit' R6 class.</p>
</td></tr>
<tr><td><code id=".fit.enet_+3A_data">data</code></td>
<td>
<p>a data frame, data frame extension (e.g. a tibble), or a lazy data frame (e.g. from dbplyr or dtplyr).</p>
</td></tr>
</table>


<h3>Details</h3>

<p><strong>Hyperparameters:</strong>
</p>

<ul>
<li> <p><code>lambda</code> <em>(penalty)</em>
</p>
</li>
<li> <p><code>alpha</code> <em>(L1-L2 mixing parameter)</em>
</p>
</li></ul>

<p><strong>Important method arguments (passed to <code><a href="#topic+m">m</a></code>)</strong>
</p>
<p>The ElasticNet regression is estimated using <code>glmnet::glmnet</code>. See <code>?glmnet</code> for more details. For classification pass <code>family = "binomial"</code> to <code>...</code> in <code><a href="#topic+m">m</a></code> or use <code><a href="#topic+classify">classify</a></code>.
</p>
<p><strong>Implementation</strong>
</p>
<p>If the response variable contains more than 2 classes, a multinomial response is used automatically.
</p>
<p>An intercept is always included and features are standardized with coefficients transformed to the original scale.
</p>
<p>If no hyperparameter grid is passed (<code>is.null(control$lambda)</code> and <code>is.null(control$alpha)</code>), <code>dials::grid_regular()</code> is used to determine a sensible default grid. The grid size is 100 for <code>lambda</code> and 5 for <code>alpha</code>. Note that the grid selection tools provided by <code>glmnet::glmnet</code> cannot be used (e.g. <code>dfmax</code>). This is to guarantee identical grids across groups in the tibble.
</p>


<h3>Value</h3>

<p>A fitted 'tidyFit' class model.
</p>


<h3>Author(s)</h3>

<p>Johann Pfitzinger
</p>


<h3>References</h3>

<p>Jerome Friedman, Trevor Hastie, Robert Tibshirani (2010). Regularization Paths for Generalized Linear Models via Coordinate Descent. Journal of Statistical Software, 33(1), 1-22. URL https://www.jstatsoft.org/v33/i01/.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+.fit.lasso">.fit.lasso</a></code>, <code><a href="#topic+.fit.adalasso">.fit.adalasso</a></code>, <code><a href="#topic+.fit.ridge">.fit.ridge</a></code> and <code><a href="#topic+m">m</a></code> methods
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load data
data &lt;- tidyfit::Factor_Industry_Returns

# Stand-alone function
fit &lt;- m("enet", Return ~ ., data, lambda = c(0, 0.1), alpha = 0.5)
fit

# Within 'regress' function
fit &lt;- regress(data, Return ~ ., m("enet", alpha = c(0, 0.5), lambda = c(0.1)),
               .mask = c("Date", "Industry"), .cv = "vfold_cv")
coef(fit)

</code></pre>

<hr>
<h2 id='.fit.genetic'>Genetic algorithm with linear regression fitness evaluator for <code>tidyfit</code></h2><span id='topic+.fit.genetic'></span>

<h3>Description</h3>

<p>Fits a linear regression with variable selection using a genetic algorithm on a 'tidyFit' <code>R6</code> class. The function can be used with <code><a href="#topic+regress">regress</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'genetic'
.fit(self, data = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".fit.genetic_+3A_self">self</code></td>
<td>
<p>a tidyFit R6 class.</p>
</td></tr>
<tr><td><code id=".fit.genetic_+3A_data">data</code></td>
<td>
<p>a data frame, data frame extension (e.g. a tibble), or a lazy data frame (e.g. from dbplyr or dtplyr).</p>
</td></tr>
</table>


<h3>Details</h3>

<p><strong>Hyperparameters:</strong>
</p>
<p><em>None. Cross validation not applicable.</em>
</p>
<p><strong>Important method arguments (passed to <code><a href="#topic+m">m</a></code>)</strong>
</p>

<ul>
<li><p> statistic
</p>
</li>
<li><p> populationSize
</p>
</li>
<li><p> numGenerations
</p>
</li>
<li><p> minVariables
</p>
</li>
<li><p> maxVariables
</p>
</li></ul>

<p>The function provides a wrapper for <code>gaselect::genAlg</code>. See <code>?genAlg</code> for more details.
</p>
<p><strong>Implementation</strong>
</p>
<p>Control arguments are passed to gaselect::genAlgControl (the function automatically identifies which arguments are for the control object, and which for gaselect::genAlg).
</p>
<p>gaselect::evaluatorLM is used as the evaluator with the relevant arguments automatically identified by the function.
</p>


<h3>Value</h3>

<p>A fitted tidyFit class model.
</p>


<h3>Author(s)</h3>

<p>Johann Pfitzinger
</p>


<h3>References</h3>

<p>Kepplinger D (2023). <em>gaselect: Genetic Algorithm (GA) for Variable Selection from High-Dimensional Data</em>. R package version 1.0.21, <a href="https://CRAN.R-project.org/package=gaselect">https://CRAN.R-project.org/package=gaselect</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+.fit.lm">.fit.lm</a></code>, <code><a href="#topic+.fit.bayes">.fit.bayes</a></code> and <code><a href="#topic+m">m</a></code> methods
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load data
data &lt;- tidyfit::Factor_Industry_Returns

# Stand-alone function
fit &lt;- m("genetic", Return ~ ., data)
fit

# Within 'regress' function
fit &lt;- regress(data, Return ~ ., m("genetic"),
               .mask = c("Date", "Industry"))
coef(fit)

</code></pre>

<hr>
<h2 id='.fit.gets'>General-to-specific regression for <code>tidyfit</code></h2><span id='topic+.fit.gets'></span>

<h3>Description</h3>

<p>Fits a general-to-specific (GETS) regression on a 'tidyFit' <code>R6</code> class. The function can be used with <code><a href="#topic+regress">regress</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gets'
.fit(self, data = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".fit.gets_+3A_self">self</code></td>
<td>
<p>a 'tidyFit' R6 class.</p>
</td></tr>
<tr><td><code id=".fit.gets_+3A_data">data</code></td>
<td>
<p>a data frame, data frame extension (e.g. a tibble), or a lazy data frame (e.g. from dbplyr or dtplyr).</p>
</td></tr>
</table>


<h3>Details</h3>

<p><strong>Hyperparameters:</strong>
</p>
<p><em>None. Cross validation not applicable.</em>
</p>
<p><strong>Important method arguments (passed to <code><a href="#topic+m">m</a></code>)</strong>
</p>

<ul>
<li> <p><code>max.paths</code> <em>(Number of paths to search)</em>
</p>
</li></ul>

<p>The function provides a wrapper for <code>gets::gets</code>. See <code>?gets</code> for more details.
</p>
<p><strong>Implementation</strong>
</p>
<p>Print output is suppressed by default. Use 'print.searchinfo = TRUE' for print output.
</p>


<h3>Value</h3>

<p>A fitted 'tidyFit' class model.
</p>


<h3>Author(s)</h3>

<p>Johann Pfitzinger
</p>


<h3>References</h3>

<p>Pretis F, Reade JJ, Sucarrat G (2018).
<em>Automated General-to-Specific (GETS) Regression Modeling and Indicator Saturation for Outliers and Structural Breaks.</em>
Journal of Statistical Software 86(3), 1-44.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+.fit.robust">.fit.robust</a></code>, <code><a href="#topic+.fit.glm">.fit.glm</a></code> and <code><a href="#topic+m">m</a></code> methods
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load data
data &lt;- tidyfit::Factor_Industry_Returns

# Stand-alone function
fit &lt;- m("gets", Return ~ `Mkt-RF` + HML + SMB, data)
fit

# Within 'regress' function
fit &lt;- regress(data, Return ~ ., m("gets"), .mask = c("Date", "Industry"))
coef(fit)

</code></pre>

<hr>
<h2 id='.fit.glm'>Generalized linear regression for <code>tidyfit</code></h2><span id='topic+.fit.glm'></span>

<h3>Description</h3>

<p>Fits a linear or logistic regression on a 'tidyFit' <code>R6</code> class. The function can be used with <code><a href="#topic+regress">regress</a></code> and <code><a href="#topic+classify">classify</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'glm'
.fit(self, data = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".fit.glm_+3A_self">self</code></td>
<td>
<p>a 'tidyFit' R6 class.</p>
</td></tr>
<tr><td><code id=".fit.glm_+3A_data">data</code></td>
<td>
<p>a data frame, data frame extension (e.g. a tibble), or a lazy data frame (e.g. from dbplyr or dtplyr).</p>
</td></tr>
</table>


<h3>Details</h3>

<p><strong>Hyperparameters:</strong>
</p>
<p><em>None. Cross validation not applicable.</em>
</p>
<p><strong>Important method arguments (passed to <code><a href="#topic+m">m</a></code>)</strong>
</p>
<p>The function provides a wrapper for <code>stats::glm</code>. See <code>?glm</code> for more details.
</p>
<p><strong>Implementation</strong>
</p>
<p><em>No implementation notes</em>
</p>


<h3>Value</h3>

<p>A fitted 'tidyFit' class model.
</p>


<h3>Author(s)</h3>

<p>Johann Pfitzinger
</p>


<h3>See Also</h3>

<p><code><a href="#topic+.fit.lm">.fit.lm</a></code> and <code><a href="#topic+m">m</a></code> methods
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load data
data &lt;- tidyfit::Factor_Industry_Returns
data$Return &lt;- ifelse(data$Return &gt; 0, 1, 0)

# Stand-alone function
fit &lt;- m("glm", Return ~ ., data)
fit

# Within 'classify' function
fit &lt;- classify(data, Return ~ ., m("glm"), .mask = c("Date", "Industry"))
coef(fit)

</code></pre>

<hr>
<h2 id='.fit.glmm'>Generalized linear mixed-effects model for <code>tidyfit</code></h2><span id='topic+.fit.glmm'></span>

<h3>Description</h3>

<p>Fits a linear or logistic mixed-effects model (GLMM) on a 'tidyFit' <code>R6</code> class. The function can be used with <code><a href="#topic+regress">regress</a></code> and <code><a href="#topic+classify">classify</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'glmm'
.fit(self, data = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".fit.glmm_+3A_self">self</code></td>
<td>
<p>a 'tidyFit' R6 class.</p>
</td></tr>
<tr><td><code id=".fit.glmm_+3A_data">data</code></td>
<td>
<p>a data frame, data frame extension (e.g. a tibble), or a lazy data frame (e.g. from dbplyr or dtplyr).</p>
</td></tr>
</table>


<h3>Details</h3>

<p><strong>Hyperparameters:</strong>
</p>
<p><em>None. Cross validation not applicable.</em>
</p>
<p><strong>Important method arguments (passed to <code><a href="#topic+m">m</a></code>)</strong>
</p>
<p>The function provides a wrapper for <code>lme4::glmer</code>. See <code>?glmer</code> for more details.
</p>
<p><strong>Implementation</strong>
</p>
<p><em>No implementation notes</em>
</p>


<h3>Value</h3>

<p>A fitted 'tidyFit' class model.
</p>


<h3>Author(s)</h3>

<p>Johann Pfitzinger
</p>


<h3>References</h3>

<p>Douglas Bates, Martin Maechler, Ben Bolker, Steve Walker (2015). Fitting Linear Mixed-Effects Models Using lme4. Journal of Statistical Software, 67(1), 1-48. doi:10.18637/jss.v067.i01.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+.fit.glm">.fit.glm</a></code> and <code><a href="#topic+m">m</a></code> methods
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load data
data &lt;- tidyfit::Factor_Industry_Returns
data$Return &lt;- ifelse(data$Return &gt; 0, 1, 0)

# Estimate model with random effects
fit &lt;- classify(data, Return ~ CMA + (CMA | Industry), logit = m("glmm"),
                .mask = "Date")
fit


</code></pre>

<hr>
<h2 id='.fit.hfr'>Hierarchical feature regression for <code>tidyfit</code></h2><span id='topic+.fit.hfr'></span>

<h3>Description</h3>

<p>Fits a hierarchical feature regression on a 'tidyFit' <code>R6</code> class. The function can be used with <code><a href="#topic+regress">regress</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'hfr'
.fit(self, data = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".fit.hfr_+3A_self">self</code></td>
<td>
<p>a 'tidyFit' R6 class.</p>
</td></tr>
<tr><td><code id=".fit.hfr_+3A_data">data</code></td>
<td>
<p>a data frame, data frame extension (e.g. a tibble), or a lazy data frame (e.g. from dbplyr or dtplyr).</p>
</td></tr>
</table>


<h3>Details</h3>

<p><strong>Hyperparameters:</strong>
</p>

<ul>
<li><p> kappa (<em>proportional size of regression graph</em>)
</p>
</li></ul>

<p><strong>Important method arguments (passed to <code><a href="#topic+m">m</a></code>)</strong>
</p>
<p>The hierarchical feature regression is estimated using the <code>hfr::cv.hfr</code> function. See <code>?cv.hfr</code> for more details.
</p>
<p><strong>Implementation</strong>
</p>
<p>Features are standardized by default with coefficients transformed to the original scale.
</p>
<p>If no hyperparameter grid is provided (<code>is.null(control$kappa)</code>), the default is <code>seq(0, 1, by = 0.1)</code>.
</p>


<h3>Value</h3>

<p>A fitted 'tidyFit' class model.
</p>


<h3>Author(s)</h3>

<p>Johann Pfitzinger
</p>


<h3>References</h3>

<p>Pfitzinger J (2022).
<em>hfr: Estimate Hierarchical Feature Regression Models</em>.
R package version 0.5.0, <a href="https://CRAN.R-project.org/package=hfr">https://CRAN.R-project.org/package=hfr</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+.fit.plsr">.fit.plsr</a></code> and <code><a href="#topic+m">m</a></code> methods
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load data
data &lt;- tidyfit::Factor_Industry_Returns

# Stand-alone function
fit &lt;- m("hfr", Return ~ ., data, kappa = 0.5)
fit

# Within 'regress' function
fit &lt;- regress(data, Return ~ ., m("hfr", kappa = c(0.1, 0.5)),
               .mask = c("Date", "Industry"))
coef(fit)

</code></pre>

<hr>
<h2 id='.fit.lasso'>Lasso regression and classification for <code>tidyfit</code></h2><span id='topic+.fit.lasso'></span>

<h3>Description</h3>

<p>Fits a linear regression or classification with L1 penalty on a 'tidyFit' <code>R6</code> class. The function can be used with <code><a href="#topic+regress">regress</a></code> and <code><a href="#topic+classify">classify</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lasso'
.fit(self, data = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".fit.lasso_+3A_self">self</code></td>
<td>
<p>a 'tidyFit' R6 class.</p>
</td></tr>
<tr><td><code id=".fit.lasso_+3A_data">data</code></td>
<td>
<p>a data frame, data frame extension (e.g. a tibble), or a lazy data frame (e.g. from dbplyr or dtplyr).</p>
</td></tr>
</table>


<h3>Details</h3>

<p><strong>Hyperparameters:</strong>
</p>

<ul>
<li> <p><code>lambda</code> <em>(L1 penalty)</em>
</p>
</li></ul>

<p><strong>Important method arguments (passed to <code><a href="#topic+m">m</a></code>)</strong>
</p>
<p>The Lasso regression is estimated using <code>glmnet::glmnet</code> with <code>alpha = 1</code>. See <code>?glmnet</code> for more details. For classification pass <code>family = "binomial"</code> to <code>...</code> in <code><a href="#topic+m">m</a></code> or use <code><a href="#topic+classify">classify</a></code>.
</p>
<p><strong>Implementation</strong>
</p>
<p>If the response variable contains more than 2 classes, a multinomial response is used automatically.
</p>
<p>Features are standardized by default with coefficients transformed to the original scale.
</p>
<p>If no hyperparameter grid is passed (<code>is.null(control$lambda)</code>), <code>dials::grid_regular()</code> is used to determine a sensible default grid. The grid size is 100. Note that the grid selection tools provided by <code>glmnet::glmnet</code> cannot be used (e.g. <code>dfmax</code>). This is to guarantee identical grids across groups in the tibble.
</p>


<h3>Value</h3>

<p>A fitted 'tidyFit' class model.
</p>


<h3>Author(s)</h3>

<p>Johann Pfitzinger
</p>


<h3>References</h3>

<p>Jerome Friedman, Trevor Hastie, Robert Tibshirani (2010). Regularization Paths for Generalized Linear Models via Coordinate Descent. Journal of Statistical Software, 33(1), 1-22. URL https://www.jstatsoft.org/v33/i01/.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+.fit.enet">.fit.enet</a></code>, <code><a href="#topic+.fit.ridge">.fit.ridge</a></code>, <code><a href="#topic+.fit.adalasso">.fit.adalasso</a></code> and <code><a href="#topic+m">m</a></code> methods
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load data
data &lt;- tidyfit::Factor_Industry_Returns

# Stand-alone function
fit &lt;- m("lasso", Return ~ ., data, lambda = 0.5)
fit

# Within 'regress' function
fit &lt;- regress(data, Return ~ ., m("lasso", lambda = c(0.1, 0.5)),
               .mask = c("Date", "Industry"))
coef(fit)

</code></pre>

<hr>
<h2 id='.fit.lm'>Linear regression for <code>tidyfit</code></h2><span id='topic+.fit.lm'></span>

<h3>Description</h3>

<p>Fits a linear regression on a 'tidyFit' <code>R6</code> class. The function can be used with <code><a href="#topic+regress">regress</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lm'
.fit(self, data = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".fit.lm_+3A_self">self</code></td>
<td>
<p>a 'tidyFit' R6 class.</p>
</td></tr>
<tr><td><code id=".fit.lm_+3A_data">data</code></td>
<td>
<p>a data frame, data frame extension (e.g. a tibble), or a lazy data frame (e.g. from dbplyr or dtplyr).</p>
</td></tr>
</table>


<h3>Details</h3>

<p><strong>Hyperparameters:</strong>
</p>
<p><em>None. Cross validation not applicable.</em>
</p>
<p><strong>Important method arguments (passed to <code><a href="#topic+m">m</a></code>)</strong>
</p>
<p>The function provides a wrapper for <code>stats::lm</code>. See <code>?lm</code> for more details.
</p>
<p><strong>Implementation</strong>
</p>
<p>An argument <code>vcov.</code> can be passed in control or to <code>...</code> in <code><a href="#topic+m">m</a></code> to estimate the model with robust standard errors. <code>vcov.</code> can be one of &quot;BS&quot;, &quot;HAC&quot;, &quot;HC&quot; and &quot;OPG&quot; and is passed to the <code>sandwich</code> package.
</p>


<h3>Value</h3>

<p>A fitted 'tidyFit' class model.
</p>


<h3>Author(s)</h3>

<p>Johann Pfitzinger
</p>


<h3>See Also</h3>

<p><code><a href="#topic+.fit.robust">.fit.robust</a></code>, <code><a href="#topic+.fit.glm">.fit.glm</a></code> and <code><a href="#topic+m">m</a></code> methods
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load data
data &lt;- tidyfit::Factor_Industry_Returns

# Stand-alone function
fit &lt;- m("lm", Return ~ `Mkt-RF` + HML + SMB, data)
fit

# Within 'regress' function
fit &lt;- regress(data, Return ~ ., m("lm"), .mask = c("Date", "Industry"))
coef(fit)

# With robust standard errors
fit &lt;- m("lm", Return ~ `Mkt-RF` + HML + SMB, data, vcov. = "HAC")
fit

</code></pre>

<hr>
<h2 id='.fit.mrmr'>Minimum redundancy, maximum relevance feature selection for <code>tidyfit</code></h2><span id='topic+.fit.mrmr'></span>

<h3>Description</h3>

<p>Selects features for continuous or (ordered) factor data using MRMR on a 'tidyFit' <code>R6</code> class. The function can be used with <code><a href="#topic+regress">regress</a></code> and <code><a href="#topic+classify">classify</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mrmr'
.fit(self, data = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".fit.mrmr_+3A_self">self</code></td>
<td>
<p>a 'tidyFit' R6 class.</p>
</td></tr>
<tr><td><code id=".fit.mrmr_+3A_data">data</code></td>
<td>
<p>a data frame, data frame extension (e.g. a tibble), or a lazy data frame (e.g. from dbplyr or dtplyr).</p>
</td></tr>
</table>


<h3>Details</h3>

<p><strong>Hyperparameters:</strong>
</p>
<p><em>None. Cross validation not applicable.</em>
</p>
<p><strong>Important method arguments (passed to <code><a href="#topic+m">m</a></code>)</strong>
</p>

<ul>
<li><p> feature_count (<em>number of features to select</em>)
</p>
</li>
<li><p> solution_count (<em>ensemble size</em>)
</p>
</li></ul>

<p>The MRMR algorithm is estimated using the <code>mRMRe::mRMR.ensemble</code> function. See <code>?mRMR.ensemble</code> for more details.
</p>
<p><strong>Implementation</strong>
</p>
<p>Use with <code><a href="#topic+regress">regress</a></code> for regression problems and with <code><a href="#topic+classify">classify</a></code> for classification problems. The selected features can be obtained using <code>coef</code>.
</p>
<p>The MRMR objects have no <code>predict</code> and related methods.
</p>


<h3>Value</h3>

<p>A fitted 'tidyFit' class model.
</p>


<h3>Author(s)</h3>

<p>Johann Pfitzinger
</p>


<h3>References</h3>

<p>De Jay N, Papillon-Cavanagh S, Olsen C, Bontempi G and Haibe-Kains B (2012).
<em>mRMRe: an R package for parallelized mRMR ensemble feature selection</em>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+m">m</a></code> methods
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load data
data &lt;- tidyfit::Factor_Industry_Returns
data &lt;- dplyr::filter(data, Industry == "HiTec")
data &lt;- dplyr::select(data, SMB, HML, RMW, CMA, Return)

## Not run: 
fit &lt;- m("mrmr", Return ~ ., data, feature_count = 2)

# Retrieve selected features
coef(fit)

## End(Not run)

</code></pre>

<hr>
<h2 id='.fit.mslm'>Markov-Switching Regression for <code>tidyfit</code></h2><span id='topic+.fit.mslm'></span>

<h3>Description</h3>

<p>Fits a Markov-Switching regression on a 'tidyFit' <code>R6</code> class. The function can be used with <code><a href="#topic+regress">regress</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mslm'
.fit(self, data = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".fit.mslm_+3A_self">self</code></td>
<td>
<p>a 'tidyFit' R6 class.</p>
</td></tr>
<tr><td><code id=".fit.mslm_+3A_data">data</code></td>
<td>
<p>a data frame, data frame extension (e.g. a tibble), or a lazy data frame (e.g. from dbplyr or dtplyr).</p>
</td></tr>
</table>


<h3>Details</h3>

<p><strong>Hyperparameters:</strong>
</p>
<p><em>None. Cross validation not applicable.</em>
</p>
<p><strong>Important method arguments (passed to <code><a href="#topic+m">m</a></code>)</strong>
</p>

<ul>
<li> <p><code>k</code> (the number of regimes)
</p>
</li>
<li> <p><code>sw</code> (logical vector indicating which coefficients switch)
</p>
</li>
<li> <p><code>control</code> (additional fitting parameters)
</p>
</li></ul>

<p>The function provides a wrapper for <code>MSwM::msmFit</code>. See <code>?msmFit</code> for more details.
</p>
<p><strong>Implementation</strong>
</p>
<p>Note that only the regression method with 'lm' is implemented at this stage.
</p>
<p>An argument <code>index_col</code> can be passed, which allows a custom index to be added to <code>coef(m("mslm"))</code> (e.g. a date index).
</p>
<p>If no <code>sw</code> argument is passed, all coefficients are permitted to switch between regimes.&ldquo;
</p>


<h3>Value</h3>

<p>A fitted 'tidyFit' class model.
</p>


<h3>Author(s)</h3>

<p>Johann Pfitzinger
</p>


<h3>References</h3>

<p>Sanchez-Espigares JA, Lopez-Moreno A (2021). <em>MSwM: Fitting Markov Switching Models</em>. R package version 1.5, <a href="https://CRAN.R-project.org/package=MSwM">https://CRAN.R-project.org/package=MSwM</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+.fit.tvp">.fit.tvp</a></code> and <code><a href="#topic+m">m</a></code> methods
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load data
data &lt;- tidyfit::Factor_Industry_Returns
data &lt;- dplyr::filter(data, Industry == "HiTec", Date &gt;= 201801)
data &lt;- dplyr::select(data, -Industry)

ctr &lt;- list(maxiter = 100, parallelization = FALSE)

# Stand-alone function
fit &lt;- m("mslm", Return ~ HML, data, index_col = "Date", k = 2, control = ctr)
fit

# Within 'regress' function
fit &lt;- regress(data, Return ~ HML,
               m("mslm", index_col = "Date", k = 2, control = ctr))
tidyr::unnest(coef(fit), model_info)

</code></pre>

<hr>
<h2 id='.fit.nnet'>Neural Network regression for <code>tidyfit</code></h2><span id='topic+.fit.nnet'></span>

<h3>Description</h3>

<p>Fits a single-hidden-layer neural network regression on a 'tidyFit' <code>R6</code> class.
The function can be used with <code><a href="#topic+regress">regress</a></code> and <code><a href="#topic+classify">classify</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'nnet'
.fit(self, data = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".fit.nnet_+3A_self">self</code></td>
<td>
<p>a 'tidyFit' R6 class.</p>
</td></tr>
<tr><td><code id=".fit.nnet_+3A_data">data</code></td>
<td>
<p>a data frame, data frame extension (e.g. a tibble), or a lazy data frame (e.g. from dbplyr or dtplyr).</p>
</td></tr>
</table>


<h3>Details</h3>

<p><strong>Hyperparameters:</strong>
</p>

<ul>
<li> <p><code>size</code> <em>(number of units in the hidden layer)</em>
</p>
</li>
<li> <p><code>decay</code> <em>(parameter for weight decay)</em>
</p>
</li>
<li> <p><code>maxit</code> <em>(maximum number of iterations)</em>
</p>
</li></ul>

<p><strong>Important method arguments (passed to <code><a href="#topic+m">m</a></code>)</strong>
</p>
<p>The function provides a wrapper for <code>nnet::nnet.formula</code>. See <code>?nnet</code> for more details.
</p>
<p><strong>Implementation</strong>
</p>
<p>For <code><a href="#topic+regress">regress</a></code>, linear output units (<code>linout=True</code>) are used, while <code><a href="#topic+classify">classify</a></code> implements
the default logic of  <code>nnet</code> (<code>entropy=TRUE</code> for 2 target classes and <code>softmax=TRUE</code> for more classes).
</p>


<h3>Value</h3>

<p>A fitted 'tidyFit' class model.
</p>


<h3>Author(s)</h3>

<p>Phil Holzmeister
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load data
data &lt;- tidyfit::Factor_Industry_Returns

# Stand-alone function
fit &lt;- m("nnet", Return ~ ., data)
fit

# Within 'regress' function
fit &lt;- regress(data, Return ~ ., m("nnet", decay=0.5, size = 8),
               .mask = c("Date", "Industry"))

# Within 'classify' function
fit &lt;- classify(iris, Species ~ ., m("nnet", decay=0.5, size = 8))

</code></pre>

<hr>
<h2 id='.fit.pcr'>Principal Components Regression for <code>tidyfit</code></h2><span id='topic+.fit.pcr'></span>

<h3>Description</h3>

<p>Fits a principal components regression on a 'tidyFit' <code>R6</code> class. The function can be used with <code><a href="#topic+regress">regress</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pcr'
.fit(self, data = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".fit.pcr_+3A_self">self</code></td>
<td>
<p>a 'tidyFit' R6 class.</p>
</td></tr>
<tr><td><code id=".fit.pcr_+3A_data">data</code></td>
<td>
<p>a data frame, data frame extension (e.g. a tibble), or a lazy data frame (e.g. from dbplyr or dtplyr).</p>
</td></tr>
</table>


<h3>Details</h3>

<p><strong>Hyperparameters:</strong>
</p>

<ul>
<li> <p><code>ncomp</code> <em>(number of components)</em>
</p>
</li>
<li> <p><code>ncomp_pct</code> <em>(number of components, percentage of features)</em>
</p>
</li></ul>

<p><strong>Important method arguments (passed to <code><a href="#topic+m">m</a></code>)</strong>
</p>
<p>The principal components regression is fitted using <code>pls</code> package. See <code>?pcr</code> for more details.
</p>
<p><strong>Implementation</strong>
</p>
<p>Covariates are standardized, with coefficients back-transformed to the original scale. An intercept is always included.
</p>
<p>If no hyperparameter grid is passed (<code>is.null(control$ncomp) &amp; is.null(control$ncomp_pct)</code>), the default is <code>ncomp_pct = seq(0, 1, length.out = 20)</code>, where 0 results in one component and 1 results in the number of features.
</p>
<p>When 'jackknife = TRUE' is passed (and a 'validation' method is chosen), <code>coef</code> also returns the jack-knife standard errors, t-statistics and p-values.
</p>
<p>Note that at present <code>pls</code> does not offer weighted implementations or non-gaussian response. The method can therefore only be used with <code><a href="#topic+regress">regress</a></code>
</p>


<h3>Value</h3>

<p>A fitted 'tidyFit' class model.
</p>


<h3>Author(s)</h3>

<p>Johann Pfitzinger
</p>


<h3>References</h3>

<p>Liland K, Mevik B, Wehrens R (2022). <em>pls: Partial Least Squares and Principal Component Regression</em>. R package version 2.8-1, <a href="https://CRAN.R-project.org/package=pls">https://CRAN.R-project.org/package=pls</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+.fit.plsr">.fit.plsr</a></code> and <code><a href="#topic+m">m</a></code> methods
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load data
data &lt;- tidyfit::Factor_Industry_Returns
data &lt;- dplyr::filter(data, Industry == "HiTec")
data &lt;- dplyr::select(data, -Industry)

# Stand-alone function
fit &lt;- m("pcr", Return ~ ., data, ncomp = 1:3)
fit

# Within 'regress' function
fit &lt;- regress(data, Return ~ .,
               m("pcr", jackknife = TRUE, validation = "LOO", ncomp_pct = 0.5),
               .mask = c("Date"))
tidyr::unnest(coef(fit), model_info)

</code></pre>

<hr>
<h2 id='.fit.plsr'>Partial Least Squares Regression for <code>tidyfit</code></h2><span id='topic+.fit.plsr'></span>

<h3>Description</h3>

<p>Fits a partial least squares regression on a 'tidyFit' <code>R6</code> class. The function can be used with <code><a href="#topic+regress">regress</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'plsr'
.fit(self, data = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".fit.plsr_+3A_self">self</code></td>
<td>
<p>a 'tidyFit' R6 class.</p>
</td></tr>
<tr><td><code id=".fit.plsr_+3A_data">data</code></td>
<td>
<p>a data frame, data frame extension (e.g. a tibble), or a lazy data frame (e.g. from dbplyr or dtplyr).</p>
</td></tr>
</table>


<h3>Details</h3>

<p><strong>Hyperparameters:</strong>
</p>

<ul>
<li> <p><code>ncomp</code> <em>(number of components)</em>
</p>
</li>
<li> <p><code>ncomp_pct</code> <em>(number of components, percentage of features)</em>
</p>
</li></ul>

<p><strong>Important method arguments (passed to <code><a href="#topic+m">m</a></code>)</strong>
</p>
<p>The partial least squares regression is fitted using <code>pls</code> package. See <code>?plsr</code> for more details.
</p>
<p><strong>Implementation</strong>
</p>
<p>Covariates are standardized, with coefficients back-transformed to the original scale. An intercept is always included.
</p>
<p>If no hyperparameter grid is passed (<code>is.null(control$ncomp) &amp; is.null(control$ncomp_pct)</code>), the default is <code>ncomp_pct = seq(0, 1, length.out = 20)</code>, where 0 results in one component and 1 results in the number of features.
</p>
<p>When 'jackknife = TRUE' is passed (and a 'validation' method is chosen), <code>coef</code> also returns the jack-knife standard errors, t-statistics and p-values.
</p>
<p>Note that at present <code>pls</code> does not offer weighted implementations or non-gaussian response. The method can therefore only be used with <code><a href="#topic+regress">regress</a></code>
</p>


<h3>Value</h3>

<p>A fitted 'tidyFit' class model.
</p>


<h3>Author(s)</h3>

<p>Johann Pfitzinger
</p>


<h3>References</h3>

<p>Liland K, Mevik B, Wehrens R (2022). <em>pls: Partial Least Squares and Principal Component Regression</em>. R package version 2.8-1, <a href="https://CRAN.R-project.org/package=pls">https://CRAN.R-project.org/package=pls</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+.fit.pcr">.fit.pcr</a></code> and <code><a href="#topic+m">m</a></code> methods
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load data
data &lt;- tidyfit::Factor_Industry_Returns
data &lt;- dplyr::filter(data, Industry == "HiTec")
data &lt;- dplyr::select(data, -Industry)

# Stand-alone function
fit &lt;- m("plsr", Return ~ ., data, ncomp = 1:3)
fit

# Within 'regress' function
fit &lt;- regress(data, Return ~ .,
               m("pcr", jackknife = TRUE, validation = "LOO", ncomp_pct = 0.5),
               .mask = c("Date"))
tidyr::unnest(coef(fit), model_info)

</code></pre>

<hr>
<h2 id='.fit.quantile'>Quantile regression for <code>tidyfit</code></h2><span id='topic+.fit.quantile'></span>

<h3>Description</h3>

<p>Fits a linear quantile regression on a 'tidyFit' <code>R6</code> class. The function can be used with <code><a href="#topic+regress">regress</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'quantile'
.fit(self, data = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".fit.quantile_+3A_self">self</code></td>
<td>
<p>a 'tidyFit' R6 class.</p>
</td></tr>
<tr><td><code id=".fit.quantile_+3A_data">data</code></td>
<td>
<p>a data frame, data frame extension (e.g. a tibble), or a lazy data frame (e.g. from dbplyr or dtplyr).</p>
</td></tr>
</table>


<h3>Details</h3>

<p><strong>Hyperparameters:</strong>
</p>
<p><em>None. Cross validation not applicable.</em>
</p>
<p><strong>Important method arguments (passed to <code><a href="#topic+m">m</a></code>)</strong>
</p>

<ul>
<li> <p><code>tau</code> (the quantile(s) to be estimated)
</p>
</li></ul>

<p>The function provides a wrapper for <code>quantreg::rq</code>. See <code>?rq</code> for more details. The argument <code>tau</code> is the chosen quantile (default <code>tau = 0.5</code>).
</p>
<p><strong>Implementation</strong>
</p>
<p><em>No implementation notes</em>
</p>


<h3>Value</h3>

<p>A fitted 'tidyFit' class model.
</p>


<h3>Author(s)</h3>

<p>Johann Pfitzinger
</p>


<h3>References</h3>

<p>Koenker R (2022). <em>quantreg: Quantile Regression</em>. R package version 5.94, <a href="https://CRAN.R-project.org/package=quantreg">https://CRAN.R-project.org/package=quantreg</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+.fit.lm">.fit.lm</a></code>, <code><a href="#topic+.fit.bayes">.fit.bayes</a></code> and <code><a href="#topic+m">m</a></code> methods
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load data
data &lt;- tidyfit::Factor_Industry_Returns

fit &lt;- regress(data, Return ~ .,
               m("quantile", tau = c(0.1, 0.5, 0.9)),
               .mask = c("Date", "Industry"))
coef(fit)

</code></pre>

<hr>
<h2 id='.fit.quantile_rf'>Quantile regression forest for <code>tidyfit</code></h2><span id='topic+.fit.quantile_rf'></span>

<h3>Description</h3>

<p>Fits a nonlinear quantile regression forest on a 'tidyFit' <code>R6</code> class. The function can be used with <code><a href="#topic+regress">regress</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'quantile_rf'
.fit(self, data = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".fit.quantile_rf_+3A_self">self</code></td>
<td>
<p>a 'tidyFit' R6 class.</p>
</td></tr>
<tr><td><code id=".fit.quantile_rf_+3A_data">data</code></td>
<td>
<p>a data frame, data frame extension (e.g. a tibble), or a lazy data frame (e.g. from dbplyr or dtplyr).</p>
</td></tr>
</table>


<h3>Details</h3>

<p><strong>Hyperparameters:</strong>
</p>

<ul>
<li><p> ntree (<em>number of trees</em>)
</p>
</li>
<li><p> mtry (<em>number of variables randomly sampled at each split</em>)
</p>
</li></ul>

<p><strong>Important method arguments (passed to <code><a href="#topic+m">m</a></code>)</strong>
</p>

<ul>
<li> <p><code>tau</code> (the quantile(s) to be estimated)
</p>
</li></ul>

<p>The function provides a wrapper for <code>quantregForest::quantregForest</code>. See <code>?quantregForest</code> for more details.
The argument <code>tau</code> is the chosen quantile (default <code>tau = 0.5</code>).
<code>tau</code> is passed directly to <code>m('quantile_rf', tau = c(0.1, 0.5, 0.9)</code> and is not passed to <code>predict</code> as in the <code>quantregForest::quantregForest</code> package. This is done to ensure a consistent interface with the quantile regression from <code>quantreg</code>.
</p>
<p><strong>Implementation</strong>
</p>
<p><em>No implementation notes</em>
</p>


<h3>Value</h3>

<p>A fitted 'tidyFit' class model.
</p>


<h3>Author(s)</h3>

<p>Johann Pfitzinger
</p>


<h3>References</h3>

<p>Meinshausen N (2017). <em>quantregForest: Quantile Regression Forests</em>. R package version 1.3-7, <a href="https://CRAN.R-project.org/package=quantregForest">https://CRAN.R-project.org/package=quantregForest</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+.fit.quantile">.fit.quantile</a></code>, <code><a href="#topic+.fit.rf">.fit.rf</a></code> and <code><a href="#topic+m">m</a></code> methods
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load data
data &lt;- tidyfit::Factor_Industry_Returns
data &lt;- dplyr::filter(data, Industry == "HiTec")
data &lt;- dplyr::select(data, -Date, -Industry)

# Stand-alone function
fit &lt;- m("quantile_rf", Return ~ ., data, tau = 0.5, ntree = 50)
fit

# Within 'regress' function
fit &lt;- regress(data, Return ~ .,
               m("quantile_rf", tau = c(0.1, 0.5, 0.9), ntree = 50))
explain(fit)

</code></pre>

<hr>
<h2 id='.fit.relief'>ReliefF and RReliefF feature selection algorithm for <code>tidyfit</code></h2><span id='topic+.fit.relief'></span>

<h3>Description</h3>

<p>Selects features for continuous or factor data using ReliefF on a 'tidyFit' <code>R6</code> class. The function can be used with <code><a href="#topic+regress">regress</a></code> and <code><a href="#topic+classify">classify</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'relief'
.fit(self, data = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".fit.relief_+3A_self">self</code></td>
<td>
<p>a 'tidyFit' R6 class.</p>
</td></tr>
<tr><td><code id=".fit.relief_+3A_data">data</code></td>
<td>
<p>a data frame, data frame extension (e.g. a tibble), or a lazy data frame (e.g. from dbplyr or dtplyr).</p>
</td></tr>
</table>


<h3>Details</h3>

<p><strong>Hyperparameters:</strong>
</p>
<p><em>None. Cross validation not applicable.</em>
</p>
<p><strong>Important method arguments (passed to <code><a href="#topic+m">m</a></code>)</strong>
</p>

<ul>
<li><p> estimator (<em>selection algorithm to use (default is 'ReliefFequalK')</em>)
</p>
</li></ul>

<p>The ReliefF algorithm is estimated using the <code>CORElearn::attrEval</code> function. See <code>?attrEval</code> for more details.
</p>
<p><strong>Implementation</strong>
</p>
<p>Use with <code><a href="#topic+regress">regress</a></code> for regression problems and with <code><a href="#topic+classify">classify</a></code> for classification problems. <code>coef</code> returns the score for each feature. Select the required number of features with the largest scores.
</p>
<p>The Relief objects have no <code>predict</code> and related methods.
</p>


<h3>Value</h3>

<p>A fitted 'tidyFit' class model.
</p>


<h3>Author(s)</h3>

<p>Johann Pfitzinger
</p>


<h3>References</h3>

<p>Robnik-Sikonja M, Savicky P (2021).
<em>CORElearn: Classification, Regression and Feature Evaluation</em>.
R package version 1.56.0, <a href="https://CRAN.R-project.org/package=CORElearn">https://CRAN.R-project.org/package=CORElearn</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+.fit.mrmr">.fit.mrmr</a></code> and <code><a href="#topic+m">m</a></code> methods
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load data
data &lt;- tidyfit::Factor_Industry_Returns
data &lt;- dplyr::filter(data, Industry == "HiTec")
data &lt;- dplyr::select(data, -Date, -Industry)

# Stand-alone function
fit &lt;- m("relief", Return ~ ., data)
coef(fit)

# Within 'regress' function
fit &lt;- regress(data, Return ~ ., m("relief"))
coef(fit)

</code></pre>

<hr>
<h2 id='.fit.rf'>Random Forest regression or classification for <code>tidyfit</code></h2><span id='topic+.fit.rf'></span>

<h3>Description</h3>

<p>Fits a random forest on a 'tidyFit' <code>R6</code> class. The function can be used with <code><a href="#topic+regress">regress</a></code> and <code><a href="#topic+classify">classify</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'rf'
.fit(self, data = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".fit.rf_+3A_self">self</code></td>
<td>
<p>a 'tidyFit' R6 class.</p>
</td></tr>
<tr><td><code id=".fit.rf_+3A_data">data</code></td>
<td>
<p>a data frame, data frame extension (e.g. a tibble), or a lazy data frame (e.g. from dbplyr or dtplyr).</p>
</td></tr>
</table>


<h3>Details</h3>

<p><strong>Hyperparameters:</strong>
</p>

<ul>
<li><p> ntree (<em>number of trees</em>)
</p>
</li>
<li><p> mtry (<em>number of variables randomly sampled at each split</em>)
</p>
</li></ul>

<p><strong>Important method arguments (passed to <code><a href="#topic+m">m</a></code>)</strong>
</p>
<p>The function provides a wrapper for <code>randomForest::randomForest</code>. See <code>?randomForest</code> for more details.
</p>
<p><strong>Implementation</strong>
</p>
<p>The random forest is always fit with <code>importance = TRUE</code>. The feature importance values are extracted using <code>coef()</code>.
</p>


<h3>Value</h3>

<p>A fitted 'tidyFit' class model.
</p>


<h3>Author(s)</h3>

<p>Johann Pfitzinger
</p>


<h3>References</h3>

<p>Liaw, A. and Wiener, M. (2002).
<em>Classification and Regression by randomForest.</em>
R News 2(3), 18&ndash;22.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+.fit.svm">.fit.svm</a></code>, <code><a href="#topic+.fit.boost">.fit.boost</a></code> and <code><a href="#topic+m">m</a></code> methods
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load data
data &lt;- tidyfit::Factor_Industry_Returns
data &lt;- dplyr::filter(data, Industry == "HiTec")
data &lt;- dplyr::select(data, -Date, -Industry)

# Stand-alone function
fit &lt;- m("rf", Return ~ ., data)
fit

# Within 'regress' function
fit &lt;- regress(data, Return ~ ., m("rf"))
explain(fit)

</code></pre>

<hr>
<h2 id='.fit.ridge'>Ridge regression and classification for <code>tidyfit</code></h2><span id='topic+.fit.ridge'></span>

<h3>Description</h3>

<p>Fits a linear regression or classification with L2 penalty on a 'tidyFit' <code>R6</code> class. The function can be used with <code><a href="#topic+regress">regress</a></code> and <code><a href="#topic+classify">classify</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ridge'
.fit(self, data = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".fit.ridge_+3A_self">self</code></td>
<td>
<p>a tidyFit R6 class.</p>
</td></tr>
<tr><td><code id=".fit.ridge_+3A_data">data</code></td>
<td>
<p>a data frame, data frame extension (e.g. a tibble), or a lazy data frame (e.g. from dbplyr or dtplyr).</p>
</td></tr>
</table>


<h3>Details</h3>

<p><strong>Hyperparameters:</strong>
</p>

<ul>
<li> <p><code>lambda</code> <em>(L2 penalty)</em>
</p>
</li></ul>

<p><strong>Important method arguments (passed to <code><a href="#topic+m">m</a></code>)</strong>
</p>
<p>The ridge regression is estimated using <code>glmnet::glmnet</code> with <code>alpha = 0</code>. See <code>?glmnet</code> for more details. For classification pass <code>family = "binomial"</code> to <code>...</code> in <code><a href="#topic+m">m</a></code> or use <code><a href="#topic+classify">classify</a></code>.
</p>
<p><strong>Implementation</strong>
</p>
<p>If the response variable contains more than 2 classes, a multinomial response is used automatically.
</p>
<p>Features are standardized by default with coefficients transformed to the original scale.
</p>
<p>If no hyperparameter grid is passed (<code>is.null(control$lambda)</code>), <code>dials::grid_regular()</code> is used to determine a sensible default grid. The grid size is 100. Note that the grid selection tools provided by <code>glmnet::glmnet</code> cannot be used (e.g. <code>dfmax</code>). This is to guarantee identical grids across groups in the tibble.
</p>


<h3>Value</h3>

<p>A fitted tidyFit class model.
</p>


<h3>Author(s)</h3>

<p>Johann Pfitzinger
</p>


<h3>References</h3>

<p>Jerome Friedman, Trevor Hastie, Robert Tibshirani (2010). Regularization Paths for Generalized Linear Models via Coordinate Descent. Journal of Statistical Software, 33(1), 1-22. URL https://www.jstatsoft.org/v33/i01/.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+.fit.lasso">.fit.lasso</a></code>, <code><a href="#topic+.fit.adalasso">.fit.adalasso</a></code>, <code><a href="#topic+.fit.enet">.fit.enet</a></code> and <code><a href="#topic+m">m</a></code> methods
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load data
data &lt;- tidyfit::Factor_Industry_Returns

# Stand-alone function
fit &lt;- m("ridge", Return ~ ., data, lambda = 0.5)
fit

# Within 'regress' function
fit &lt;- regress(data, Return ~ ., m("ridge", lambda = c(0.1, 0.5)),
               .mask = c("Date", "Industry"))
coef(fit)

</code></pre>

<hr>
<h2 id='.fit.robust'>Robust regression for <code>tidyfit</code></h2><span id='topic+.fit.robust'></span>

<h3>Description</h3>

<p>Fits a robust linear regression on a 'tidyFit' <code>R6</code> class. The function can be used with <code><a href="#topic+regress">regress</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'robust'
.fit(self, data = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".fit.robust_+3A_self">self</code></td>
<td>
<p>a 'tidyFit' R6 class.</p>
</td></tr>
<tr><td><code id=".fit.robust_+3A_data">data</code></td>
<td>
<p>a data frame, data frame extension (e.g. a tibble), or a lazy data frame (e.g. from dbplyr or dtplyr).</p>
</td></tr>
</table>


<h3>Details</h3>

<p><strong>Hyperparameters:</strong>
</p>
<p><em>None. Cross validation not applicable.</em>
</p>
<p><strong>Important method arguments (passed to <code><a href="#topic+m">m</a></code>)</strong>
</p>

<ul>
<li> <p><code>method</code> (estimation algorithm, e.g. 'M', 'MM')
</p>
</li></ul>

<p>The function provides a wrapper for <code>MASS::rlm</code>. See <code>?rlm</code> for more details.
</p>
<p><strong>Implementation</strong>&ldquo;
</p>
<p>An argument <code>vcov.</code> can be passed in control or to <code>...</code> in <code><a href="#topic+m">m</a></code> to estimate the model with robust standard errors. <code>vcov.</code> can be one of &quot;BS&quot;, &quot;HAC&quot;, &quot;HC&quot; and &quot;OPG&quot; and is passed to the <code>sandwich</code> package.
</p>


<h3>Value</h3>

<p>A fitted 'tidyFit' class model.
</p>


<h3>Author(s)</h3>

<p>Johann Pfitzinger
</p>


<h3>References</h3>

<p>W. N. Venables and B. D. Ripley (2002).
<em>Modern Applied Statistics with S. 4th ed., Springer, New York.</em>
URL https://www.stats.ox.ac.uk/pub/MASS4/.<br />
</p>


<h3>See Also</h3>

<p><code><a href="#topic+.fit.lm">.fit.lm</a></code> and <code><a href="#topic+m">m</a></code> methods
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load data
data &lt;- tidyfit::Factor_Industry_Returns

fit &lt;- regress(data, Return ~ ., m("robust"), .mask = c("Date", "Industry"))
coef(fit)

# With robust standard errors
fit &lt;- m("robust", Return ~ `Mkt-RF` + HML + SMB, data, vcov. = "HAC")
tidyr::unnest(coef(fit), model_info)

</code></pre>

<hr>
<h2 id='.fit.spikeslab'>Bayesian Spike and Slab regression or classification for <code>tidyfit</code></h2><span id='topic+.fit.spikeslab'></span>

<h3>Description</h3>

<p>Fits a Bayesian Spike and Slab regression or classification on a 'tidyFit' <code>R6</code> class. The function can be used with <code><a href="#topic+regress">regress</a></code> and <code><a href="#topic+classify">classify</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'spikeslab'
.fit(self, data = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".fit.spikeslab_+3A_self">self</code></td>
<td>
<p>a tidyFit R6 class.</p>
</td></tr>
<tr><td><code id=".fit.spikeslab_+3A_data">data</code></td>
<td>
<p>a data frame, data frame extension (e.g. a tibble), or a lazy data frame (e.g. from dbplyr or dtplyr).</p>
</td></tr>
</table>


<h3>Details</h3>

<p><strong>Hyperparameters:</strong>
</p>
<p><em>None. Cross validation not applicable.</em>
</p>
<p><strong>Important method arguments (passed to <code><a href="#topic+m">m</a></code>)</strong>
</p>
<p>In the case of <strong>regression</strong>, arguments are passed to <code>BoomSpikeSlab::lm.spike</code> and <code>BoomSpikeSlab::SpikeSlabPrior</code>. Check those functions for details.
</p>
<p><code>BoomSpikeSlab::SpikeSlabPrior</code>
</p>

<ul>
<li><p> expected.r2
</p>
</li>
<li><p> prior.df
</p>
</li>
<li><p> expected.model.size
</p>
</li></ul>

<p><code>BoomSpikeSlab::lm.spike</code>
</p>

<ul>
<li><p> niter
</p>
</li></ul>

<p>In the case of <strong>classification</strong>, arguments are passed to <code>BoomSpikeSlab::logit.spike</code> and <code>BoomSpikeSlab::SpikeSlabGlmPrior</code>. Check those functions for details.
</p>
<p><code>BoomSpikeSlab::logit.spike</code>
</p>

<ul>
<li><p> niter
</p>
</li></ul>

<p>I advise against the use of <code>BoomSpikeSlab::SpikeSlabGlmPrior</code> at the moment, since it appears to be buggy.
</p>
<p>The function provides wrappers for <code>BoomSpikeSlab::lm.spike</code> and <code>BoomSpikeSlab::logit.spike</code>. See <code>?lm.spike</code> and <code>?logit.spike</code> for more details.
</p>
<p><strong>Implementation</strong>
</p>
<p>Prior arguments are passed to <code>BoomSpikeSlab::SpikeSlabPrior</code> and <code>BoomSpikeSlab::SpikeSlabGlmPrior</code> (the function automatically identifies which arguments are for the prior, and which for <code>BoomSpikeSlab::lm.spike</code> or <code>BoomSpikeSlab::logit.spike</code>).
</p>
<p><code>BoomSpikeSlab::logit.spike</code> is automatically selected when using <code>classify</code>.
</p>


<h3>Value</h3>

<p>A fitted tidyFit class model.
</p>


<h3>Author(s)</h3>

<p>Johann Pfitzinger
</p>


<h3>References</h3>

<p>Scott SL (2022). <em>BoomSpikeSlab: MCMC for Spike and Slab Regression</em>. R package version 1.2.5, <a href="https://CRAN.R-project.org/package=BoomSpikeSlab">https://CRAN.R-project.org/package=BoomSpikeSlab</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+.fit.lasso">.fit.lasso</a></code>, <code><a href="#topic+.fit.blasso">.fit.blasso</a></code> and <code><a href="#topic+m">m</a></code> methods
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load data
data &lt;- tidyfit::Factor_Industry_Returns

# Stand-alone function
fit &lt;- m("spikeslab", Return ~ ., data, niter = 100)
fit

# Within 'regress' function
fit &lt;- regress(data, Return ~ ., m("spikeslab", niter = 100),
               .mask = c("Date", "Industry"))
coef(fit)

</code></pre>

<hr>
<h2 id='.fit.subset'>Best subset regression and classification for <code>tidyfit</code></h2><span id='topic+.fit.subset'></span>

<h3>Description</h3>

<p>Fits a best subset regression or classification on a 'tidyFit' <code>R6</code> class. The function can be used with <code><a href="#topic+regress">regress</a></code> and <code><a href="#topic+classify">classify</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'subset'
.fit(self, data = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".fit.subset_+3A_self">self</code></td>
<td>
<p>a 'tidyFit' R6 class.</p>
</td></tr>
<tr><td><code id=".fit.subset_+3A_data">data</code></td>
<td>
<p>a data frame, data frame extension (e.g. a tibble), or a lazy data frame (e.g. from dbplyr or dtplyr).</p>
</td></tr>
</table>


<h3>Details</h3>

<p><strong>Hyperparameters:</strong>
</p>
<p><em>None. Cross validation not applicable.</em>
</p>
<p><strong>Important method arguments (passed to <code><a href="#topic+m">m</a></code>)</strong>
</p>

<ul>
<li> <p><code>method</code> (e.g. 'forward', 'backward')
</p>
</li>
<li> <p><code>IC</code> (information criterion, e.g. 'AIC')
</p>
</li></ul>

<p>The best subset regression is estimated using <code>bestglm::bestglm</code> which is a wrapper around <code>leaps::regsubsets</code> for the regression case, and performs an exhaustive search for the classification case. See <code>?bestglm</code> for more details.
</p>
<p><strong>Implementation</strong>
</p>
<p>Forward or backward selection can be performed by passing <code>method = "forward"</code> or <code>method = "backward"</code> to <code><a href="#topic+m">m</a></code>.
</p>


<h3>Value</h3>

<p>A fitted 'tidyFit' class model.
</p>


<h3>Author(s)</h3>

<p>Johann Pfitzinger
</p>


<h3>References</h3>

<p>A.I. McLeod, Changjiang Xu and Yuanhao Lai (2020).
<em>bestglm: Best Subset GLM and Regression Utilities.
R package version 0.37.3.</em> URL https://CRAN.R-project.org/package=bestglm.<br />
</p>


<h3>See Also</h3>

<p><code><a href="#topic+.fit.lm">.fit.lm</a></code> and <code><a href="#topic+m">m</a></code> methods
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load data
data &lt;- tidyfit::Factor_Industry_Returns

# Stand-alone function
fit &lt;- m("subset", Return ~ ., data, method = c("forward", "backward"))
tidyr::unnest(fit, settings)

# Within 'regress' function
fit &lt;- regress(data, Return ~ ., m("subset", method = "forward"),
               .mask = c("Date", "Industry"))
coef(fit)

</code></pre>

<hr>
<h2 id='.fit.svm'>Support vector regression or classification for <code>tidyfit</code></h2><span id='topic+.fit.svm'></span>

<h3>Description</h3>

<p>Fits a support vector regression or classification on a 'tidyFit' <code>R6</code> class. The function can be used with <code><a href="#topic+regress">regress</a></code> or <code><a href="#topic+classify">classify</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'svm'
.fit(self, data = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".fit.svm_+3A_self">self</code></td>
<td>
<p>a 'tidyFit' R6 class.</p>
</td></tr>
<tr><td><code id=".fit.svm_+3A_data">data</code></td>
<td>
<p>a data frame, data frame extension (e.g. a tibble), or a lazy data frame (e.g. from dbplyr or dtplyr).</p>
</td></tr>
</table>


<h3>Details</h3>

<p><strong>Hyperparameters:</strong>
</p>

<ul>
<li><p> cost (<em>cost of constraint violation</em>)
</p>
</li>
<li><p> epsilon (<em>epsilon in the insensitive-loss function</em>)
</p>
</li></ul>

<p><strong>Important method arguments (passed to <code><a href="#topic+m">m</a></code>)</strong>
</p>
<p>The function provides a wrapper for <code>e1071::svm</code>. See <code>?svm</code> for more details.
</p>
<p><strong>Implementation</strong>
</p>
<p>The default value for the <code>kernel</code> argument is set to 'linear'. If set to a different value, no coefficients will be returned.
</p>


<h3>Value</h3>

<p>A fitted 'tidyFit' class model.
</p>


<h3>Author(s)</h3>

<p>Johann Pfitzinger
</p>


<h3>References</h3>

<p>Meyer D, Dimitriadou E, Hornik K, Weingessel A, Leisch F (2022).
<em>e1071: Misc Functions of the Department of Statistics, Probability Theory Group (Formerly: E1071), TU Wien</em>.
R package version 1.7-12, <a href="https://CRAN.R-project.org/package=e1071">https://CRAN.R-project.org/package=e1071</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+.fit.boost">.fit.boost</a></code>, <code><a href="#topic+.fit.lasso">.fit.lasso</a></code> and <code><a href="#topic+m">m</a></code> methods
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load data
data &lt;- tidyfit::Factor_Industry_Returns
data &lt;- dplyr::filter(data, Industry == "HiTec")

# Stand-alone function
fit &lt;- m("svm", Return ~ `Mkt-RF` + HML + SMB, data, cost = 0.1)
fit

# Within 'regress' function
fit &lt;- regress(data, Return ~ ., m("svm", cost = 0.1),
               .mask = c("Date", "Industry"))
coef(fit)

</code></pre>

<hr>
<h2 id='.fit.tvp'>Bayesian Time-Varying Regression for <code>tidyfit</code></h2><span id='topic+.fit.tvp'></span>

<h3>Description</h3>

<p>Fits a Bayesian time-varying regression on a 'tidyFit' <code>R6</code> class. The function can be used with <code><a href="#topic+regress">regress</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'tvp'
.fit(self, data = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".fit.tvp_+3A_self">self</code></td>
<td>
<p>a 'tidyFit' R6 class.</p>
</td></tr>
<tr><td><code id=".fit.tvp_+3A_data">data</code></td>
<td>
<p>a data frame, data frame extension (e.g. a tibble), or a lazy data frame (e.g. from dbplyr or dtplyr).</p>
</td></tr>
</table>


<h3>Details</h3>

<p><strong>Hyperparameters:</strong>
</p>
<p><em>None. Cross validation not applicable.</em>
</p>
<p><strong>Important method arguments (passed to <code><a href="#topic+m">m</a></code>)</strong>
</p>

<ul>
<li> <p><code>mod_type</code>
</p>
</li>
<li> <p><code>niter</code> (number of MCMC iterations)
</p>
</li></ul>

<p>The function provides a wrapper for <code>shrinkTVP::shrinkTVP</code>. See <code>?shrinkTVP</code> for more details.
</p>
<p><strong>Implementation</strong>
</p>
<p>An argument <code>index_col</code> can be passed, which allows a custom index to be added to <code>coef(m("tvp"))</code> (e.g. a date index, see Examples).
</p>


<h3>Value</h3>

<p>A fitted 'tidyFit' class model.
</p>


<h3>Author(s)</h3>

<p>Johann Pfitzinger
</p>


<h3>References</h3>

<p>Peter Knaus, Angela Bitto-Nemling, Annalisa Cadonna and Sylvia Frühwirth-Schnatter (2021).
<em>Shrinkage in the Time-Varying Parameter Model Framework Using the R Package shrinkTVP.
Journal of Statistical Software 100(13), 1&ndash;32</em>.
<a href="https://doi.org/10.18637/jss.v100.i13">doi:10.18637/jss.v100.i13</a>.<br />
</p>


<h3>See Also</h3>

<p><code><a href="#topic+.fit.bayes">.fit.bayes</a></code>, <code><a href="#topic+.fit.mslm">.fit.mslm</a></code> and <code><a href="#topic+m">m</a></code> methods
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load data
data &lt;- tidyfit::Factor_Industry_Returns
data &lt;- dplyr::filter(data, Industry == "HiTec")
data &lt;- dplyr::select(data, -Industry)

# Within 'regress' function (using low niter for illustration)
fit &lt;- regress(data, Return ~ ., m("tvp", niter = 50, index_col = "Date"))
tidyr::unnest(coef(fit), model_info)

</code></pre>

<hr>
<h2 id='classify'>Classification on tidy data</h2><span id='topic+classify'></span>

<h3>Description</h3>

<p>This function is a wrapper to fit many different types of linear
classification models on a (grouped) <code>tibble</code>.
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="classify_+3A_.data">.data</code></td>
<td>
<p>a data frame, data frame extension (e.g. a tibble), or a lazy data frame (e.g. from dbplyr or dtplyr). The data frame can be grouped.</p>
</td></tr>
<tr><td><code id="classify_+3A_formula">formula</code></td>
<td>
<p>an object of class &quot;formula&quot;: a symbolic description of the model to be fitted.</p>
</td></tr>
<tr><td><code id="classify_+3A_...">...</code></td>
<td>
<p>name-function pairs of models to be estimated. See 'Details'.</p>
</td></tr>
<tr><td><code id="classify_+3A_.cv">.cv</code></td>
<td>
<p>type of 'rsample' cross validation procedure to use to determine optimal hyperparameter values. Default is <code>.cv = "none"</code>. See 'Details'.</p>
</td></tr>
<tr><td><code id="classify_+3A_.cv_args">.cv_args</code></td>
<td>
<p>additional settings to pass to the 'rsample' cross validation function.</p>
</td></tr>
<tr><td><code id="classify_+3A_.weights">.weights</code></td>
<td>
<p>optional name of column containing sample weights.</p>
</td></tr>
<tr><td><code id="classify_+3A_.mask">.mask</code></td>
<td>
<p>optional vector of columns names to ignore. Can be useful when using 'y ~ .' formula syntax.</p>
</td></tr>
<tr><td><code id="classify_+3A_.return_slices">.return_slices</code></td>
<td>
<p>logical. Should the output of individual cross validation slices be returned or only the final fit. Default is <code>.return_slices=FALSE</code>.</p>
</td></tr>
<tr><td><code id="classify_+3A_.return_grid">.return_grid</code></td>
<td>
<p>logical. Should the output of the individual hyperparameter grids be returned or only the best fitting set of hyperparameters. Default is <code>.return_grid=FALSE</code>.</p>
</td></tr>
<tr><td><code id="classify_+3A_.tune_each_group">.tune_each_group</code></td>
<td>
<p>logical. Should optimal hyperparameters be selected for each group or once across all groups. Default is <code>.tune_each_group=TRUE</code>.</p>
</td></tr>
<tr><td><code id="classify_+3A_.force_cv">.force_cv</code></td>
<td>
<p>logical. Should models be evaluated across all cross validation slices, even if no hyperparameters are tuned. Default is <code>.force_cv=FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>classify</code> fits all models passed in <code>...</code> using the <code><a href="#topic+m">m</a></code> function. The models can be passed as name-function pairs (e.g. <code>ols = m("lm")</code>) or without including a name.
</p>
<p>Hyperparameters are tuned automatically using the '.cv' and '.cv_args' arguments, or can be passed to <code>m()</code> (e.g. <code>lasso = m("lasso", lambda = 0.5)</code>). See the individual model functions (<code>?m()</code>) for an overview of hyperparameters.
</p>
<p>Cross validation is performed using the 'rsample' package with possible methods including
</p>

<ul>
<li><p> 'initial_split' (simple train-test split)
</p>
</li>
<li><p> 'initial_time_split' (train-test split with retained order)
</p>
</li>
<li><p> 'vfold_cv' (aka kfold cross validation)
</p>
</li>
<li><p> 'loo_cv' (leave-one-out)
</p>
</li>
<li><p> 'rolling_origin' (generalized time series cross validation, e.g. rolling or expanding windows)
</p>
</li>
<li><p> 'sliding_window', 'sliding_index', 'sliding_period' (specialized time series splits)
</p>
</li>
<li><p> 'bootstraps'
</p>
</li>
<li><p> 'group_vfold_cv', 'group_bootstraps'
</p>
</li></ul>

<p>See package documentation for 'rsample' for all available methods.
</p>
<p>The negative log loss is used to validate performance in the cross validation.
</p>
<p>Note that arguments for weights are automatically passed to the functions by setting the '.weights' argument. Weights are also considered during cross validation by calculating weighted versions of the cross validation loss function.
</p>
<p><code>classify</code> can handle both binomial and multinomial response distributions, however not all underlying methods are capable of handling a multinomial response.
</p>


<h3>Value</h3>

<p>A <code>tidyfit.models</code> frame containing model details for each group.
</p>
<p>The <strong>'tidyfit.models' frame</strong> consists of 4 different components:
</p>

<ol>
<li><p> A group of identifying columns (e.g. model name, data groups, grid IDs)
</p>
</li>
<li><p> A 'model_object' column, which contains the fitted model.
</p>
</li>
<li><p> A nested 'settings' column containing model arguments and hyperparameters
</p>
</li>
<li><p> Columns showing errors, warnings and messages (if applicable)
</p>
</li></ol>

<p>Coefficients, predictions, fitted values or residuals can be accessed using the built-in <code>coef</code>, <code>predict</code>, <code>fitted</code> and <code>resid</code> methods. Note that all coefficients are transformed to ensure comparability across methods.
</p>


<h3>Author(s)</h3>

<p>Johann Pfitzinger
</p>


<h3>See Also</h3>

<p><code><a href="#topic+regress">regress</a></code>, <code><a href="#topic+coef.tidyfit.models">coef.tidyfit.models</a></code> and <code><a href="#topic+predict.tidyfit.models">predict.tidyfit.models</a></code> method
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data &lt;- tidyfit::Factor_Industry_Returns
data &lt;- dplyr::mutate(data, Return = ifelse(Return &gt; 0, 1, 0))
fit &lt;- classify(data, Return ~ ., m("lasso", lambda = c(0.001, 0.1)), .mask = c("Date", "Industry"))

# Print the models frame
tidyr::unnest(fit, settings)

# View coefficients
coef(fit)

</code></pre>

<hr>
<h2 id='coef.tidyfit.models'>Extract coefficients from a <code>tidyfit.models</code> frame</h2><span id='topic+coef.tidyfit.models'></span>

<h3>Description</h3>

<p>The function extracts and prepares coefficients from all models in a <code>tidyfit.models</code> frame and outputs a tidy frame of estimates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'tidyfit.models'
coef(
  object,
  ...,
  .add_bootstrap_interval = FALSE,
  .bootstrap_alpha = 0.05,
  .keep_grid_id = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coef.tidyfit.models_+3A_object">object</code></td>
<td>
<p><code>model.frame</code> created using <code><a href="#topic+regress">regress</a></code>, <code><a href="#topic+classify">classify</a></code> or <code><a href="#topic+m">m</a></code></p>
</td></tr>
<tr><td><code id="coef.tidyfit.models_+3A_...">...</code></td>
<td>
<p>currently not used</p>
</td></tr>
<tr><td><code id="coef.tidyfit.models_+3A_.add_bootstrap_interval">.add_bootstrap_interval</code></td>
<td>
<p>calculate bootstrap intervals for the parameters. See 'Details'.</p>
</td></tr>
<tr><td><code id="coef.tidyfit.models_+3A_.bootstrap_alpha">.bootstrap_alpha</code></td>
<td>
<p>confidence level used for the bootstrap interval. Default is <code>.bootstrap_alpha = 0.05</code>.</p>
</td></tr>
<tr><td><code id="coef.tidyfit.models_+3A_.keep_grid_id">.keep_grid_id</code></td>
<td>
<p>boolean. By default the grid ID column is dropped, if there is only one unique setting per model or group. <code>.keep_grid_id = TRUE</code> ensures that the column is never dropped.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function uses the 'model_object' column in a <code>tidyfit.model</code> frame to return a data frame of estimated coefficients.
</p>
<p>Results are 'tidied' using <code>broom::tidy</code> whenever possible.
</p>
<p>All coefficients are transformed to ensure statistical comparability. For instance, standardized coefficients are always transformed back to the original data scale, naming conventions are harmonized etc.
</p>


<h4>Bootstrap intervals</h4>

<p>Bootstrap intervals can be calculated using <code>rsample::int_pctl</code>. Only set <code>.add_bootstrap_interval = TRUE</code> if you are using <code>.cv = "bootstraps"</code> in combination with <code>.return_slices = TRUE</code> to generate the model frame.
</p>



<h3>Value</h3>

<p>A 'tibble'.
</p>


<h3>Author(s)</h3>

<p>Johann Pfitzinger
</p>


<h3>See Also</h3>

<p><code><a href="#topic+predict.tidyfit.models">predict.tidyfit.models</a></code>, <code><a href="#topic+fitted.tidyfit.models">fitted.tidyfit.models</a></code> and <code><a href="#topic+residuals.tidyfit.models">residuals.tidyfit.models</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data &lt;- tidyfit::Factor_Industry_Returns
fit &lt;- regress(data, Return ~ ., m("lm"), .mask = c("Date", "Industry"))
coef(fit)

</code></pre>

<hr>
<h2 id='explain'>An interface for variable importance measures for a fitted tidyfit.models frames</h2><span id='topic+explain'></span>

<h3>Description</h3>

<p>A generic method for calculating XAI and variable importance methods for tidyfit.models frames.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>explain(object, use_package = NULL, use_method = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="explain_+3A_object">object</code></td>
<td>
<p><code>model.frame</code> created using <code><a href="#topic+regress">regress</a></code>, <code><a href="#topic+classify">classify</a></code> or <code><a href="#topic+m">m</a></code></p>
</td></tr>
<tr><td><code id="explain_+3A_use_package">use_package</code></td>
<td>
<p>the package to use to calculate variable importance. See 'Details' for possible options.</p>
</td></tr>
<tr><td><code id="explain_+3A_use_method">use_method</code></td>
<td>
<p>the method from 'use_package' that should be used to calculate variable importance.</p>
</td></tr>
<tr><td><code id="explain_+3A_...">...</code></td>
<td>
<p>additional arguments passed to the importance method</p>
</td></tr>
</table>


<h3>Details</h3>

<p><strong>WARNING</strong>
This function is currently in an experimental stage.
</p>
<p>The function uses the 'model_object' column in a <code>tidyfit.model</code> frame to return variable importance measures for each model.
</p>
<p><strong>Possible packages and methods include:</strong>
</p>


<h4><code>sensitivity</code> package:</h4>

<p>The package provides methods to assess variable importance in linear regressions ('lm') and classifications ('glm').
</p>
<p><em>Usage:</em> <code>use_package="sensitivity"</code>
<em>Methods:</em>
</p>

<ul>
<li><p> &quot;lmg&quot; (Shapley regression),
</p>
</li>
<li><p> &quot;pmvd&quot; (Proportional marginal variance decomposition),
</p>
</li>
<li><p> &quot;src&quot; (standardized regression coefficients),
</p>
</li>
<li><p> &quot;pcc&quot; (partial correlation coefficients),
</p>
</li>
<li><p> &quot;johnson&quot; (Johnson indices)
</p>
</li></ul>

<p>See <code>?sensitivity::lmg</code> for more information and additional arguments.
</p>



<h4><code>iml</code> package:</h4>

<p>Integration with iml is currently in progress. The methods can be used for 'nnet', 'rf', 'lasso', 'enet', 'ridge', 'adalasso', 'glm' and 'lm'.
</p>
<p><em>Usage:</em> <code>use_package="iml"</code>
<em>Methods:</em>
</p>

<ul>
<li><p> &quot;Shapley&quot; (SHAP values)
</p>
</li>
<li><p> &quot;LocalModel&quot; (LIME)
</p>
</li>
<li><p> &quot;FeatureImp&quot; (Permutation-based feature importance)
</p>
</li></ul>

<p>The argument 'which_rows' (vector of integer indexes) can be used to explain specific rows in the data set for Shapley and LocalModel methods.
</p>



<h4><code>randomForest</code> package:</h4>

<p>This uses the native importance method of the randomForest package and can be used with 'rf' and 'quantile_rf' regression and classification.
</p>
<p><em>Usage:</em> <code>use_package="randomForest"</code>
<em>Methods:</em>
</p>

<ul>
<li><p> &quot;mean_decrease_accuracy&quot;
</p>
</li></ul>




<h3>Value</h3>

<p>A 'tibble'.
</p>


<h3>Author(s)</h3>

<p>Johann Pfitzinger
</p>


<h3>References</h3>

<p>Molnar C, Bischl B, Casalicchio G (2018). “iml: An R package for Interpretable Machine Learning.” <em>JOSS</em>,
<em>3</em>(26), 786. <a href="https://doi.org/10.21105/joss.00786">doi:10.21105/joss.00786</a>.
</p>
<p>Iooss B, Veiga SD, Janon A, Pujol G, Broto wcfB, Boumhaout K, Clouvel L, Delage T, Amri RE, Fruth J, Gilquin
L, Guillaume J, Herin M, Idrissi MI, Le Gratiet L, Lemaitre P, Marrel A, Meynaoui A, Nelson BL, Monari F,
Oomen R, Rakovec O, Ramos B, Rochet P, Roustant O, Sarazin G, Song E, Staum J, Sueur R, Touati T, Verges V,
Weber F (2024). <em>sensitivity: Global Sensitivity Analysis of Model Outputs and Importance Measures</em>. R
package version 1.30.0, <a href="https://CRAN.R-project.org/package=sensitivity">https://CRAN.R-project.org/package=sensitivity</a>.
</p>
<p>A. Liaw and M. Wiener (2002). Classification and Regression by randomForest. R News 2(3), 18&ndash;22.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data &lt;- dplyr::group_by(tidyfit::Factor_Industry_Returns, Industry)
fit &lt;- regress(data, Return ~ ., m("lm"), .mask = "Date")
explain(fit, use_package = "sensitivity", use_method = "src")

data &lt;- dplyr::filter(tidyfit::Factor_Industry_Returns, Industry == Industry[1])
fit &lt;- regress(data, Return ~ ., m("lm"), .mask = c("Date", "Industry"))
explain(fit, use_package = "iml", use_method = "Shapley", which_rows = c(1))

</code></pre>

<hr>
<h2 id='explain.tidyfit.models'>An interface for variable importance measures for a fitted tidyfit.models frames</h2><span id='topic+explain.tidyfit.models'></span>

<h3>Description</h3>

<p>A generic method for calculating XAI and variable importance methods for tidyfit.models frames.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'tidyfit.models'
explain(
  object,
  use_package = NULL,
  use_method = NULL,
  ...,
  .keep_grid_id = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="explain.tidyfit.models_+3A_object">object</code></td>
<td>
<p><code>model.frame</code> created using <code><a href="#topic+regress">regress</a></code>, <code><a href="#topic+classify">classify</a></code> or <code><a href="#topic+m">m</a></code></p>
</td></tr>
<tr><td><code id="explain.tidyfit.models_+3A_use_package">use_package</code></td>
<td>
<p>the package to use to calculate variable importance. See 'Details' for possible options.</p>
</td></tr>
<tr><td><code id="explain.tidyfit.models_+3A_use_method">use_method</code></td>
<td>
<p>the method from 'use_package' that should be used to calculate variable importance.</p>
</td></tr>
<tr><td><code id="explain.tidyfit.models_+3A_...">...</code></td>
<td>
<p>additional arguments passed to the importance method</p>
</td></tr>
<tr><td><code id="explain.tidyfit.models_+3A_.keep_grid_id">.keep_grid_id</code></td>
<td>
<p>boolean. By default the grid ID column is dropped, if there is only one unique setting per model or group. <code>.keep_grid_id = TRUE</code> ensures that the column is never dropped.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><strong>WARNING</strong>
This function is currently in an experimental stage.
</p>
<p>The function uses the 'model_object' column in a <code>tidyfit.model</code> frame to return variable importance measures for each model.
</p>
<p><strong>Possible packages and methods include:</strong>
</p>


<h4><code>sensitivity</code> package:</h4>

<p>The package provides methods to assess variable importance in linear regressions ('lm') and classifications ('glm').
</p>
<p><em>Usage:</em> <code>use_package="sensitivity"</code>
<em>Methods:</em>
</p>

<ul>
<li><p> &quot;lmg&quot; (Shapley regression),
</p>
</li>
<li><p> &quot;pmvd&quot; (Proportional marginal variance decomposition),
</p>
</li>
<li><p> &quot;src&quot; (standardized regression coefficients),
</p>
</li>
<li><p> &quot;pcc&quot; (partial correlation coefficients),
</p>
</li>
<li><p> &quot;johnson&quot; (Johnson indices)
</p>
</li></ul>

<p>See <code>?sensitivity::lmg</code> for more information and additional arguments.
</p>



<h4><code>iml</code> package:</h4>

<p>Integration with iml is currently in progress. The methods can be used for 'nnet', 'rf', 'lasso', 'enet', 'ridge', 'adalasso', 'glm' and 'lm'.
</p>
<p><em>Usage:</em> <code>use_package="iml"</code>
<em>Methods:</em>
</p>

<ul>
<li><p> &quot;Shapley&quot; (SHAP values)
</p>
</li>
<li><p> &quot;LocalModel&quot; (LIME)
</p>
</li>
<li><p> &quot;FeatureImp&quot; (Permutation-based feature importance)
</p>
</li></ul>

<p>The argument 'which_rows' (vector of integer indexes) can be used to explain specific rows in the data set for Shapley and LocalModel methods.
</p>



<h4><code>randomForest</code> package:</h4>

<p>This uses the native importance method of the randomForest package and can be used with 'rf' and 'quantile_rf' regression and classification.
</p>
<p><em>Usage:</em> <code>use_package="randomForest"</code>
<em>Methods:</em>
</p>

<ul>
<li><p> &quot;mean_decrease_accuracy&quot;
</p>
</li></ul>




<h3>Value</h3>

<p>A 'tibble'.
</p>


<h3>Author(s)</h3>

<p>Johann Pfitzinger
</p>


<h3>References</h3>

<p>Molnar C, Bischl B, Casalicchio G (2018). “iml: An R package for Interpretable Machine Learning.” <em>JOSS</em>,
<em>3</em>(26), 786. <a href="https://doi.org/10.21105/joss.00786">doi:10.21105/joss.00786</a>.
</p>
<p>Iooss B, Veiga SD, Janon A, Pujol G, Broto wcfB, Boumhaout K, Clouvel L, Delage T, Amri RE, Fruth J, Gilquin
L, Guillaume J, Herin M, Idrissi MI, Le Gratiet L, Lemaitre P, Marrel A, Meynaoui A, Nelson BL, Monari F,
Oomen R, Rakovec O, Ramos B, Rochet P, Roustant O, Sarazin G, Song E, Staum J, Sueur R, Touati T, Verges V,
Weber F (2024). <em>sensitivity: Global Sensitivity Analysis of Model Outputs and Importance Measures</em>. R
package version 1.30.0, <a href="https://CRAN.R-project.org/package=sensitivity">https://CRAN.R-project.org/package=sensitivity</a>.
</p>
<p>A. Liaw and M. Wiener (2002). Classification and Regression by randomForest. R News 2(3), 18&ndash;22.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data &lt;- dplyr::group_by(tidyfit::Factor_Industry_Returns, Industry)
fit &lt;- regress(data, Return ~ ., m("lm"), .mask = "Date")
explain(fit, use_package = "sensitivity", use_method = "src")

data &lt;- dplyr::filter(tidyfit::Factor_Industry_Returns, Industry == Industry[1])
fit &lt;- regress(data, Return ~ ., m("lm"), .mask = c("Date", "Industry"))
explain(fit, use_package = "iml", use_method = "Shapley", which_rows = c(1))

</code></pre>

<hr>
<h2 id='Factor_Industry_Returns'>Industry-Factor Returns Data Set</h2><span id='topic+Factor_Industry_Returns'></span>

<h3>Description</h3>

<p>The data set includes monthly returns between 1963 and 2022 for 10 industries, as well as factor values for 5 Fama-French factors.
</p>


<h3>References</h3>

<p><a href="https://mba.tuck.dartmouth.edu/pages/faculty/ken.french/data_library.html">https://mba.tuck.dartmouth.edu/pages/faculty/ken.french/data_library.html</a>
</p>

<hr>
<h2 id='fitted.tidyfit.models'>Obtain fitted values from models in a <code>tidyfit.models</code> frame</h2><span id='topic+fitted.tidyfit.models'></span>

<h3>Description</h3>

<p>The function generates fitted values for all models in a <code>tidyfit.models</code> frame and outputs a tidy frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'tidyfit.models'
fitted(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitted.tidyfit.models_+3A_object">object</code></td>
<td>
<p><code>model.frame</code> created using <code><a href="#topic+regress">regress</a></code>, <code><a href="#topic+classify">classify</a></code> or <code><a href="#topic+m">m</a></code></p>
</td></tr>
<tr><td><code id="fitted.tidyfit.models_+3A_...">...</code></td>
<td>
<p>currently not used</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function uses the 'model_object' column in a <code>tidyfit.model</code> frame to return fitted values for each model.
</p>


<h3>Value</h3>

<p>A 'tibble'.
</p>


<h3>Author(s)</h3>

<p>Johann Pfitzinger
</p>


<h3>See Also</h3>

<p><code><a href="#topic+coef.tidyfit.models">coef.tidyfit.models</a></code>, <code><a href="#topic+predict.tidyfit.models">predict.tidyfit.models</a></code> and <code><a href="#topic+residuals.tidyfit.models">residuals.tidyfit.models</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data &lt;- dplyr::group_by(tidyfit::Factor_Industry_Returns, Industry)
fit &lt;- regress(data, Return ~ ., m("lm"), .mask = "Date")
fitted(fit)

</code></pre>

<hr>
<h2 id='m'>Generic model wrapper for <code>tidyfit</code></h2><span id='topic+m'></span>

<h3>Description</h3>

<p>The function can fit various regression or classification models and returns the results as a tibble. <code>m()</code> can be used in conjunction with <code><a href="#topic+regress">regress</a></code> and <code><a href="#topic+classify">classify</a></code>, or as a stand-alone function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>m(model_method, formula = NULL, data = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="m_+3A_model_method">model_method</code></td>
<td>
<p>The name of the method to fit. See Details.</p>
</td></tr>
<tr><td><code id="m_+3A_formula">formula</code></td>
<td>
<p>an object of class &quot;formula&quot;: a symbolic description of the model to be fitted.</p>
</td></tr>
<tr><td><code id="m_+3A_data">data</code></td>
<td>
<p>a data frame, data frame extension (e.g. a tibble), or a lazy data frame (e.g. from dbplyr or dtplyr).</p>
</td></tr>
<tr><td><code id="m_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to the underlying method function (e.g. <code>lm</code> or <code>glm</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>model_method</code> specifies the model to fit to the data and can take one of several options:
</p>


<h4>Linear (generalized) regression or classification</h4>

<p><code>"lm"</code> performs an OLS regression using <code>stats::lm</code>. See <code><a href="#topic+.fit.lm">.fit.lm</a></code> for details.
</p>
<p><code>"glm"</code> performs a generalized regression or classification using <code>stats::glm</code>. See <code><a href="#topic+.fit.glm">.fit.glm</a></code> for details.
</p>
<p><code>"anova"</code> performs analysis of variance using <code>stats::anova</code>. See <code><a href="#topic+.fit.anova">.fit.anova</a></code> for details.
</p>
<p><code>"robust"</code> performs a robust regression using <code>MASS::rlm</code>. See <code><a href="#topic+.fit.robust">.fit.robust</a></code> for details.
</p>
<p><code>"quantile"</code> performs a quantile regression using <code>quantreg::rq</code>. See <code><a href="#topic+.fit.quantile">.fit.quantile</a></code> for details.
</p>



<h4>Regression and classification with L1 and L2 penalties</h4>

<p><code>"lasso"</code> performs a linear regression or classification with L1 penalty using <code>glmnet::glmnet</code>. See <code><a href="#topic+.fit.lasso">.fit.lasso</a></code> for details.
</p>
<p><code>"ridge"</code> performs a linear regression or classification with L2 penalty using <code>glmnet::glmnet</code>. See <code><a href="#topic+.fit.ridge">.fit.ridge</a></code> for details.
</p>
<p><code>"adalasso"</code> performs an Adaptive Lasso regression or classification using <code>glmnet::glmnet</code>. See <code><a href="#topic+.fit.adalasso">.fit.adalasso</a></code> for details.
</p>
<p><code>"enet"</code> performs a linear regression or classification with L1 and L2 penalties using <code>glmnet::glmnet</code>. See <code><a href="#topic+.fit.enet">.fit.enet</a></code> for details.
</p>



<h4>Other Machine Learning</h4>

<p><code>"boost"</code> performs gradient boosting regression or classification using <code>mboost::glmboost</code>. See <code><a href="#topic+.fit.boost">.fit.boost</a></code> for details.
</p>
<p><code>"rf"</code> performs a random forest regression or classification using <code>randomForest::randomForest</code>. See <code><a href="#topic+.fit.rf">.fit.rf</a></code> for details.
</p>
<p><code>"svm"</code> performs a support vector regression or classification using <code>e1071::svm</code>. See <code><a href="#topic+.fit.svm">.fit.svm</a></code> for details.
</p>
<p><code>"nnet"</code> performs a neural network regression or classification using <code>nnet::nnet</code>. See <code><a href="#topic+.fit.nnet">.fit.nnet</a></code> for details.
</p>



<h4>Factor regressions</h4>

<p><code>"pcr"</code> performs a principal components regression using <code>pls::pcr</code>. See <code><a href="#topic+.fit.pcr">.fit.pcr</a></code> for details.
</p>
<p><code>"plsr"</code> performs a partial least squares regression using <code>pls::plsr</code>. See <code><a href="#topic+.fit.plsr">.fit.plsr</a></code> for details.
</p>
<p><code>"hfr"</code> performs a hierarchical feature regression using <code>hfr::hfr</code>. See <code><a href="#topic+.fit.hfr">.fit.hfr</a></code> for details.
</p>



<h4>Best subset selection</h4>

<p><code>"subset"</code> performs a best subset regression or classification using <code>bestglm::bestglm</code> (wrapper for <code>leaps</code>). See <code><a href="#topic+.fit.subset">.fit.subset</a></code> for details.
</p>
<p><code>"gets"</code> performs a general-to-specific regression using <code>gets::gets</code>. See <code><a href="#topic+.fit.gets">.fit.gets</a></code> for details.
</p>



<h4>Bayesian methods</h4>

<p><code>"bayes"</code> performs a Bayesian generalized regression or classification using <code>arm::bayesglm</code>. See <code><a href="#topic+.fit.bayes">.fit.bayes</a></code> for details.
</p>
<p><code>"bridge"</code> performs a Bayesian ridge regression using <code>monomvn::bridge</code>. See <code><a href="#topic+.fit.bridge">.fit.bridge</a></code> for details.
</p>
<p><code>"blasso"</code> performs a Bayesian Lasso regression using <code>monomvn::blasso</code>. See <code><a href="#topic+.fit.blasso">.fit.blasso</a></code> for details.
</p>
<p><code>"spikeslab"</code> performs a Bayesian Spike and Slab regression using <code>BoomSpikeSlab::lm.spike</code>. See <code><a href="#topic+.fit.spikeslab">.fit.spikeslab</a></code> for details.
</p>
<p><code>"bma"</code> performs a Bayesian model averaging regression using <code>BMS::bms</code>. See <code><a href="#topic+.fit.bma">.fit.bma</a></code> for details.
</p>
<p><code>"tvp"</code> performs a Bayesian time-varying parameter regression using <code>shrinkTVP::shrinkTVP</code>. See <code><a href="#topic+.fit.tvp">.fit.tvp</a></code> for details.
</p>



<h4>Mixed-effects modeling</h4>

<p><code>"glmm"</code> performs a mixed-effects GLM using <code>lme4::glmer</code>. See <code><a href="#topic+.fit.glmm">.fit.glmm</a></code> for details.
</p>



<h4>Specialized time series methods</h4>

<p><code>"mslm"</code> performs a Markov-switching regression using <code>MSwM::msmFit</code>. See <code><a href="#topic+.fit.mslm">.fit.mslm</a></code> for details.
</p>



<h4>Feature selection</h4>

<p><code>"cor"</code> calculates Pearson's correlation coefficient using <code>stats::cor.test</code>. See <code><a href="#topic+.fit.cor">.fit.cor</a></code> for details.
</p>
<p><code>"chisq"</code> calculates Pearson's Chi-squared test using <code>stats::chisq.test</code>. See <code><a href="#topic+.fit.chisq">.fit.chisq</a></code> for details.
</p>
<p><code>"mrmr"</code> performs a minimum redundancy, maximum relevance features selection routine using <code>mRMRe::mRMR.ensemble</code>. See <code><a href="#topic+.fit.mrmr">.fit.mrmr</a></code> for details.
</p>
<p><code>"relief"</code> performs a ReliefF feature selection routine using <code>CORElearn::attrEval</code>. See <code><a href="#topic+.fit.relief">.fit.relief</a></code> for details.
</p>
<p><code>"genetic"</code> performs a linear regression with feature selection using the genetic algorithm implemented in <code>gaselect::genAlg</code>. See <code><a href="#topic+.fit.genetic">.fit.genetic</a></code> for details.
</p>
<p>When called without <code>formula</code> and <code>data</code> arguments, the function returns a 'tidyfit.models' data frame with unfitted models.
</p>



<h3>Value</h3>

<p>A 'tidyfit.models' data frame.
</p>


<h3>Author(s)</h3>

<p>Johann Pfitzinger
</p>


<h3>See Also</h3>

<p><code><a href="#topic+regress">regress</a></code> and <code><a href="#topic+classify">classify</a></code> methods
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load data
data &lt;- tidyfit::Factor_Industry_Returns

# Stand-alone function
fit &lt;- m("lm", Return ~ ., data)
fit

# Within 'regress' function
fit &lt;- regress(data, Return ~ ., m("lm"), .mask = "Date")
fit

</code></pre>

<hr>
<h2 id='predict.tidyfit.models'>Predict using a <code>tidyfit.models</code> frame</h2><span id='topic+predict.tidyfit.models'></span>

<h3>Description</h3>

<p>The function generates predictions for all models in a <code>tidyfit.models</code> frame and outputs a tidy frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'tidyfit.models'
predict(object, newdata, ..., .keep_grid_id = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.tidyfit.models_+3A_object">object</code></td>
<td>
<p><code>model.frame</code> created using <code><a href="#topic+regress">regress</a></code>, <code><a href="#topic+classify">classify</a></code> or <code><a href="#topic+m">m</a></code></p>
</td></tr>
<tr><td><code id="predict.tidyfit.models_+3A_newdata">newdata</code></td>
<td>
<p>New values at which predictions are to made</p>
</td></tr>
<tr><td><code id="predict.tidyfit.models_+3A_...">...</code></td>
<td>
<p>currently not used</p>
</td></tr>
<tr><td><code id="predict.tidyfit.models_+3A_.keep_grid_id">.keep_grid_id</code></td>
<td>
<p>boolean. By default the grid ID column is dropped, if there is only one unique setting per model or group. <code>.keep_grid_id = TRUE</code> ensures that the column is never dropped.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function uses the 'model_object' column in a <code>tidyfit.model</code> frame to return predictions using the <code>newdata</code> argument for each model.
</p>
<p>When the response variable is found in <code>newdata</code>, it is automatically included as a 'truth' column.
</p>


<h3>Value</h3>

<p>A 'tibble'.
</p>


<h3>Author(s)</h3>

<p>Johann Pfitzinger
</p>


<h3>See Also</h3>

<p><code><a href="#topic+coef.tidyfit.models">coef.tidyfit.models</a></code>, <code><a href="#topic+residuals.tidyfit.models">residuals.tidyfit.models</a></code> and <code><a href="#topic+fitted.tidyfit.models">fitted.tidyfit.models</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data &lt;- dplyr::group_by(tidyfit::Factor_Industry_Returns, Industry)
fit &lt;- regress(data, Return ~ ., m("lm"), .mask = "Date")
predict(fit, data)

</code></pre>

<hr>
<h2 id='regress'>Linear regression on tidy data</h2><span id='topic+regress'></span>

<h3>Description</h3>

<p>This function is a wrapper to fit many different types of linear
regression models on a (grouped) <code>tibble</code>.
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="regress_+3A_.data">.data</code></td>
<td>
<p>a data frame, data frame extension (e.g. a tibble), or a lazy data frame (e.g. from dbplyr or dtplyr). The data frame can be grouped.</p>
</td></tr>
<tr><td><code id="regress_+3A_formula">formula</code></td>
<td>
<p>an object of class &quot;formula&quot;: a symbolic description of the model to be fitted.</p>
</td></tr>
<tr><td><code id="regress_+3A_...">...</code></td>
<td>
<p>name-function pairs of models to be estimated. See 'Details'.</p>
</td></tr>
<tr><td><code id="regress_+3A_.cv">.cv</code></td>
<td>
<p>type of 'rsample' cross validation procedure to use to determine optimal hyperparameter values. Default is <code>.cv = "none"</code>. See 'Details'.</p>
</td></tr>
<tr><td><code id="regress_+3A_.cv_args">.cv_args</code></td>
<td>
<p>additional settings to pass to the 'rsample' cross validation function.</p>
</td></tr>
<tr><td><code id="regress_+3A_.weights">.weights</code></td>
<td>
<p>optional name of column containing sample weights.</p>
</td></tr>
<tr><td><code id="regress_+3A_.mask">.mask</code></td>
<td>
<p>optional vector of columns names to ignore. Can be useful when using 'y ~ .' formula syntax.</p>
</td></tr>
<tr><td><code id="regress_+3A_.return_slices">.return_slices</code></td>
<td>
<p>logical. Should the output of individual cross validation slices be returned or only the final fit. Default is <code>.return_slices=FALSE</code>.</p>
</td></tr>
<tr><td><code id="regress_+3A_.return_grid">.return_grid</code></td>
<td>
<p>logical. Should the output of the individual hyperparameter grids be returned or only the best fitting set of hyperparameters. Default is <code>.return_grid=FALSE</code>.</p>
</td></tr>
<tr><td><code id="regress_+3A_.tune_each_group">.tune_each_group</code></td>
<td>
<p>logical. Should optimal hyperparameters be selected for each group or once across all groups. Default is <code>.tune_each_group=TRUE</code>.</p>
</td></tr>
<tr><td><code id="regress_+3A_.force_cv">.force_cv</code></td>
<td>
<p>logical. Should models be evaluated across all cross validation slices, even if no hyperparameters are tuned. Default is <code>.force_cv=FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>regress</code> fits all models passed in <code>...</code> using the <code><a href="#topic+m">m</a></code> function. The models can be passed as name-function pairs (e.g. <code>ols = m("lm")</code>) or without including a name.
</p>
<p>Hyperparameters are tuned automatically using the '.cv' and '.cv_args' arguments, or can be passed to <code>m()</code> (e.g. <code>lasso = m("lasso", lambda = 0.5)</code>). See the individual model functions (<code>?m()</code>) for an overview of hyperparameters.
</p>
<p>Cross validation is performed using the 'rsample' package with possible methods including
</p>

<ul>
<li><p> 'initial_split' (simple train-test split)
</p>
</li>
<li><p> 'initial_time_split' (train-test split with retained order)
</p>
</li>
<li><p> 'vfold_cv' (aka kfold cross validation)
</p>
</li>
<li><p> 'loo_cv' (leave-one-out)
</p>
</li>
<li><p> 'rolling_origin' (generalized time series cross validation, e.g. rolling or expanding windows)
</p>
</li>
<li><p> 'sliding_window', 'sliding_index', 'sliding_period' (specialized time series splits)
</p>
</li>
<li><p> 'bootstraps'
</p>
</li>
<li><p> 'group_vfold_cv', 'group_bootstraps'
</p>
</li></ul>

<p>See package documentation for 'rsample' for all available methods.
</p>
<p>The mean squared error loss is used to validate performance in the cross validation.
</p>
<p>Note that arguments for weights are automatically passed to the functions by setting the '.weights' argument. Weights are also considered during cross validation by calculating weighted versions of the cross validation loss function.
</p>


<h3>Value</h3>

<p>A <code>tidyfit.models</code> frame containing model details for each group.
</p>
<p>The <strong>'tidyfit.models' frame</strong> consists of 4 different components:
</p>

<ol>
<li><p> A group of identifying columns (e.g. model name, data groups, grid IDs)
</p>
</li>
<li><p> A 'model_object' column, which contains the fitted model.
</p>
</li>
<li><p> A nested 'settings' column containing model arguments and hyperparameters
</p>
</li>
<li><p> Columns showing errors, warnings and messages (if applicable)
</p>
</li></ol>

<p>Coefficients, predictions, fitted values or residuals can be accessed using the built-in <code>coef</code>, <code>predict</code>, <code>fitted</code> and <code>resid</code> methods. Note that all coefficients are transformed to ensure comparability across methods.
</p>


<h3>Author(s)</h3>

<p>Johann Pfitzinger
</p>


<h3>See Also</h3>

<p><code><a href="#topic+classify">classify</a></code>, <code><a href="#topic+coef.tidyfit.models">coef.tidyfit.models</a></code> and <code><a href="#topic+predict.tidyfit.models">predict.tidyfit.models</a></code> method
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data &lt;- tidyfit::Factor_Industry_Returns
fit &lt;- regress(data, Return ~ ., m("lasso", lambda = c(0.001, 0.1)), .mask = c("Date", "Industry"))

# Print the models frame
tidyr::unnest(fit, settings)

# View coefficients
coef(fit)

</code></pre>

<hr>
<h2 id='residuals.tidyfit.models'>Obtain residuals from models in a <code>tidyfit.models</code> frame</h2><span id='topic+residuals.tidyfit.models'></span>

<h3>Description</h3>

<p>The function generates residuals for all models in a <code>tidyfit.models</code> frame and outputs a tidy frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'tidyfit.models'
residuals(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="residuals.tidyfit.models_+3A_object">object</code></td>
<td>
<p><code>model.frame</code> created using <code><a href="#topic+regress">regress</a></code>, <code><a href="#topic+classify">classify</a></code> or <code><a href="#topic+m">m</a></code></p>
</td></tr>
<tr><td><code id="residuals.tidyfit.models_+3A_...">...</code></td>
<td>
<p>currently not used</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function uses the 'model_object' column in a <code>tidyfit.model</code> frame to return residuals for each model.
</p>


<h3>Value</h3>

<p>A 'tibble'.
</p>


<h3>Author(s)</h3>

<p>Johann Pfitzinger
</p>


<h3>See Also</h3>

<p><code><a href="#topic+coef.tidyfit.models">coef.tidyfit.models</a></code>, <code><a href="#topic+predict.tidyfit.models">predict.tidyfit.models</a></code> and <code><a href="#topic+fitted.tidyfit.models">fitted.tidyfit.models</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data &lt;- dplyr::group_by(tidyfit::Factor_Industry_Returns, Industry)
fit &lt;- regress(data, Return ~ ., m("lm"), .mask = "Date")
resid(fit)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
