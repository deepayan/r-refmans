<!DOCTYPE html><html lang="en"><head><title>Help for package netgsa</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {netgsa}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#netgsa-package'><p>Network-Based Gene Set Analysis</p></a></li>
<li><a href='#bic.netEst.undir'>
<p>Bayesian information criterion to select the tuning parameters for <code>netEst.undir</code></p></a></li>
<li><a href='#breastcancer2012_subset'>
<p>Breast cancer data from TCGA (2012). This is a 750 gene subset</p></a></li>
<li><a href='#edgelist'><p>A data frame of edges, each row corresponding to one edge</p></a></li>
<li><a href='#formatPathways'><p>Format cytoscape nested networks</p></a></li>
<li><a href='#group'><p>The vector of class indicators</p></a></li>
<li><a href='#netEst.dir'>
<p>Constrained estimation of directed networks</p></a></li>
<li><a href='#netEst.undir'>
<p>Constrained estimation of undirected networks</p></a></li>
<li><a href='#NetGSA'><p>Network-based Gene Set Analysis</p></a></li>
<li><a href='#NetGSAq'><p>&quot;Quick&quot; Network-based Gene Set Analysis</p></a></li>
<li><a href='#nonedgelist'><p>A data frame of nonedges, each row corresponding to one negative edge</p></a></li>
<li><a href='#obtainClusters'><p>Estimate optimal gene clustering structure</p></a></li>
<li><a href='#obtainEdgeList'><p>Obtain edgelist from graphite databases. To be used within prepareAdjMat</p></a></li>
<li><a href='#pathways'><p>A list of KEGG pathways</p></a></li>
<li><a href='#pathways_mat'><p>Matrix with pathway indicators</p></a></li>
<li><a href='#plot.NetGSA'><p>Generates NetGSA plots</p></a></li>
<li><a href='#prepareAdjMat'><p>Construct adjacency matrices from graphite databases and/or user provided network information</p></a></li>
<li><a href='#stackDatabases'><p>Combine edges from databases into a data.table</p></a></li>
<li><a href='#x'><p>Data matrix p by n</p></a></li>
<li><a href='#zoomPathway'><p>Zoom in on pathway in igraph</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Network-Based Gene Set Analysis</td>
</tr>
<tr>
<td>Version:</td>
<td>4.0.5</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-11-13</td>
</tr>
<tr>
<td>Description:</td>
<td>Carry out network-based gene set analysis by incorporating external information about interactions among genes, as well as novel interactions learned from data. Implements methods described in Shojaie A, Michailidis G (2010) &lt;<a href="https://doi.org/10.1093%2Fbiomet%2Fasq038">doi:10.1093/biomet/asq038</a>&gt;, Shojaie A, Michailidis G (2009) &lt;<a href="https://doi.org/10.1089%2Fcmb.2008.0081">doi:10.1089/cmb.2008.0081</a>&gt;, and Ma J, Shojaie A, Michailidis G (2016) &lt;<a href="https://doi.org/10.1093%2Fbioinformatics%2Fbtw410">doi:10.1093/bioinformatics/btw410</a>&gt;.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>AnnotationDbi, corpcor, data.table, dplyr, genefilter, graph,
graphite, glmnet, glassoFast, httr, igraph, magrittr, Matrix,
msigdbr, org.Hs.eg.db, quadprog, RCy3, reshape2, rlang, Rcpp
(&ge; 1.0.2)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, MASS, rmarkdown</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppEigen</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/mikehellstern/netgsa">https://github.com/mikehellstern/netgsa</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-11-13 20:24:11 UTC; mike</td>
</tr>
<tr>
<td>Author:</td>
<td>Michael Hellstern [aut, cre],
  Ali Shojaie [aut],
  Jing Ma [aut],
  Kun Yue [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Michael Hellstern &lt;mikeh1@uw.edu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-11-14 14:10:06 UTC</td>
</tr>
</table>
<hr>
<h2 id='netgsa-package'>Network-Based Gene Set Analysis</h2><span id='topic+netgsa-package'></span>

<h3>Description</h3>

<p>The netgsa-package provides functions for carrying out Network-based Gene Set Analysis by incorporating external information about interactions among genes, as well as novel interactions learned from data.</p>


<h3>Author(s)</h3>

<p>Ali Shojaie &lt;ashojaie@uw.edu&gt;, Jing Ma, Michael Hellstern &lt;mikeh1@uw.edu&gt;m and Kun Yue</p>


<h3>References</h3>

<p>Ma, J., Shojaie, A. &amp; Michailidis, G. (2016) Network-based pathway enrichment analysis with incomplete network information. Bioinformatics 32(20):165&ndash;3174. <a href="https://doi.org/10.1093/bioinformatics/btw410">doi:10.1093/bioinformatics/btw410</a>
</p>
<p>Shojaie, A., &amp; Michailidis, G. (2010a). Penalized likelihood methods for estimation of sparse high-dimensional directed acyclic graphs. Biometrika 97(3), 519-538. <a href="https://academic.oup.com/biomet/article-abstract/97/3/519/243918">https://academic.oup.com/biomet/article-abstract/97/3/519/243918</a>
</p>
<p>Shojaie, A., &amp; Michailidis, G. (2010b). Network enrichment analysis in complex experiments. Statistical applications in genetics and molecular biology, 9(1), Article 22. <a href="https://pubmed.ncbi.nlm.nih.gov/20597848/">https://pubmed.ncbi.nlm.nih.gov/20597848/</a>.
</p>
<p>Shojaie, A., &amp; Michailidis, G. (2009). Analysis of gene sets based on the underlying regulatory network. Journal of Computational Biology, 16(3), 407-426. <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC3131840/">https://www.ncbi.nlm.nih.gov/pmc/articles/PMC3131840/</a>
</p>


<h3>See Also</h3>

<p><code><a href="glmnet.html#topic+glmnet">glmnet</a></code>
</p>

<hr>
<h2 id='bic.netEst.undir'>
Bayesian information criterion to select the tuning parameters for <code>netEst.undir</code>
</h2><span id='topic+bic.netEst.undir'></span>

<h3>Description</h3>

<p>This function uses the Bayesian information criterion to select the optimal tuning parameters needed in <code>netEst.undir</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bic.netEst.undir(x, zero = NULL, one = NULL, lambda, rho = NULL, weight = NULL, 
                 eta = 0, verbose = FALSE, eps = 1e-08)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bic.netEst.undir_+3A_x">x</code></td>
<td>
<p>The <code class="reqn">p \times n</code> data matrix as in <code>netEst.undir</code>.</p>
</td></tr>
<tr><td><code id="bic.netEst.undir_+3A_zero">zero</code></td>
<td>
<p>(Optional) indices of entries of the matrix to be constrained to be zero. The input should be a matrix of <code class="reqn">p \times p</code>, with 1 at entries to be constrained to be zero and 0 elsewhere. The matrix must be symmetric.</p>
</td></tr>
<tr><td><code id="bic.netEst.undir_+3A_one">one</code></td>
<td>
<p>(Optional) indices of entries of the matrix to be kept regardless of the regularization parameter for lasso. The input is similar to that of <code>zero</code> and needs to be symmetric.</p>
</td></tr>
<tr><td><code id="bic.netEst.undir_+3A_lambda">lambda</code></td>
<td>
<p>(Non-negative) user-supplied lambda sequence.</p>
</td></tr>
<tr><td><code id="bic.netEst.undir_+3A_rho">rho</code></td>
<td>
<p>(Non-negative) numeric scalar representing the regularization parameter for estimating the weights in the inverse covariance matrix. This is the same as <code>rho</code> in the graphical lasso algorithm <code>glassoFast</code>.</p>
</td></tr>
<tr><td><code id="bic.netEst.undir_+3A_weight">weight</code></td>
<td>
<p>(Optional) whether to add penalty to known edges. If NULL (default), then the known edges are assumed to be true. If nonzero, then a penalty equal to <code>lambda * weight</code> is added to penalize the known edges to account for possible uncertainty. Only non-negative values are accepted for the weight parameter. </p>
</td></tr>
<tr><td><code id="bic.netEst.undir_+3A_eta">eta</code></td>
<td>
<p>(Non-negative) a small constant added to the diagonal of the empirical covariance matrix of <code>X</code> to ensure it is well conditioned. By default, <code>eta</code> is set to 0.</p>
</td></tr>
<tr><td><code id="bic.netEst.undir_+3A_verbose">verbose</code></td>
<td>
<p>Whether to print out information as estimation proceeds. Default=<code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="bic.netEst.undir_+3A_eps">eps</code></td>
<td>
<p>Numeric scalar <code class="reqn">&gt;=0</code>, indicating the tolerance level for differentiating zero and non-zero edges: entries <code class="reqn">&lt;</code> <code>eps</code> will be set to 0. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Let <code class="reqn">\hat\Sigma</code> represent the empirical covariance matrix of data <code>x</code>. For a given <code class="reqn">\lambda</code>, denote the estimated inverse covariance matrix by <code class="reqn">\hat\Omega_{\lambda}</code>. the Bayesian information criterion (BIC) is defined as
</p>
<p style="text-align: center;"><code class="reqn">trace(\hat\Sigma \hat\Omega_{\lambda}) - \log \det (\hat\Omega_{\lambda}) + \frac{\log n}{n} \cdot df,</code>
</p>

<p>where <code class="reqn">df</code> represents the degrees of freedom in the selected model and can be estimated via the number of edges in <code class="reqn">\hat\Omega_{\lambda}</code>. The optimal tuning parameter is selected as the one that minimizes the BIC over the range of <code>lambda</code>.
</p>
<p>Note when the penalty parameter <code>lambda</code> is too large, the estimated adjacency matrix may be zero. The function will thus return a warning message. 
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>lambda</code></td>
<td>
<p>The values of <code>lambda</code> used.</p>
</td></tr>
<tr><td><code>weight</code></td>
<td>
<p>The values of <code>weight</code> used.</p>
</td></tr>
<tr><td><code>BIC</code></td>
<td>
<p>If <code>weight=NULL</code>, then a numeric vector of the same length as <code>lambda</code> with the corresponding BIC. If <code>weight</code> is a vector, then a matrix of size <code>length(lambda)</code> by <code>length(weight)</code> with the corresponding BIC.</p>
</td></tr>
<tr><td><code>df</code></td>
<td>
<p>The degrees of freedom corresponding to each BIC.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jing Ma
</p>


<h3>References</h3>

<p>Ma, J., Shojaie, A. &amp; Michailidis, G. (2016) Network-based pathway enrichment analysis with incomplete network information. Bioinformatics 32(20):165&ndash;3174. <a href="https://doi.org/10.1093/bioinformatics/btw410">doi:10.1093/bioinformatics/btw410</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+netEst.undir">netEst.undir</a></code>
</p>

<hr>
<h2 id='breastcancer2012_subset'>
Breast cancer data from TCGA (2012). This is a 750 gene subset
</h2><span id='topic+breastcancer2012_subset'></span>

<h3>Description</h3>

<p>An example data set consisting of RNA-seq gene expression data, KEGG pathways, edge list and non-edge list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(breastcancer2012_subset)</code></pre>


<h3>Format</h3>

<p>A list with components
</p>

<dl>
<dt><code>x</code></dt><dd><p>The <code class="reqn">p \times n</code> data matrix.</p>
</dd>
<dt><code>group</code></dt><dd><p>The vector of class indicators of length <code class="reqn">n</code>.</p>
</dd>
<dt><code>pathways</code></dt><dd><p>A list of KEGG pathways.</p>
</dd>
<dt><code>edgelist</code></dt><dd><p>A data frame of edges, each row corresponding to one edge.</p>
</dd>
<dt><code>nonedgelist</code></dt><dd><p>A data frame of nonedges, each row corresponding to one negative edge.</p>
</dd>
<dt><code>pathways_mat</code></dt><dd><p>Matrix with pathway indicators</p>
</dd>
</dl>



<h3>References</h3>

<p>Cancer Genome Atlas Network. (2012). Comprehensive molecular portraits of human breast tumours. Nature, 490(7418), 61.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("breastcancer2012_subset")
</code></pre>

<hr>
<h2 id='edgelist'>A data frame of edges, each row corresponding to one edge</h2><span id='topic+edgelist'></span>

<h3>Description</h3>

<p>A data frame of edges, each row corresponding to one edge
</p>


<h3>Usage</h3>

<pre><code class='language-R'>edgelist
</code></pre>


<h3>Format</h3>

<p>An object of class <code>data.frame</code> with 19 rows and 4 columns.
</p>

<hr>
<h2 id='formatPathways'>Format cytoscape nested networks</h2><span id='topic+formatPathways'></span>

<h3>Description</h3>

<p>Format cytoscape nested networks using preset NetGSA format</p>


<h3>Usage</h3>

<pre><code class='language-R'>formatPathways(x, pways, graph_layout = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="formatPathways_+3A_x">x</code></td>
<td>
<p>A NetGSA object returned from calling <code>NetGSA()</code></p>
</td></tr>
<tr><td><code id="formatPathways_+3A_pways">pways</code></td>
<td>
<p>Character vector of pathways to format</p>
</td></tr>
<tr><td><code id="formatPathways_+3A_graph_layout">graph_layout</code></td>
<td>
<p>(Optional) Layout to pass to plots. Must be a string for Cytoscape which will be passed to <code>RCy3::layoutNetwork</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Loads gene testing data into each pathway. Genes are tested using an F-test if there are 2 or more conditions or a two-sided one-class t-test against the null hypothesis of mean = 0 if there is only one condition. FDR corrected q-values are mapped to the color of the node. The scale ranges from 0 to 1 with red represents q-values of 0 and white representing q-values of 1. Loaded data includes: p-value from the F-test/t-test (pval), FDR corrected q-value (pFdr), test statistic from the F-test/t-test (teststat).
</p>
<p>Custom formatting can be applied using the cytoscape GUI or the RCy3 pacakge.
</p>


<h3>Value</h3>

<p>No return value, called for side effects
</p>


<h3>Author(s)</h3>

<p>Michael Hellstern
</p>


<h3>References</h3>

<p>Ma, J., Shojaie, A. &amp; Michailidis, G. (2016) Network-based pathway enrichment analysis with incomplete network information. Bioinformatics 32(20):165&ndash;3174. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.NetGSA">plot.NetGSA</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## load the data
data("breastcancer2012_subset")

## consider genes from just 2 pathways
genenames    &lt;- unique(c(pathways[["Adipocytokine signaling pathway"]], 
                         pathways[["Adrenergic signaling in cardiomyocytes"]]))
sx           &lt;- x[match(rownames(x), genenames, nomatch = 0L) &gt; 0L,]

db_edges       &lt;- obtainEdgeList(rownames(sx), databases = c("kegg", "reactome"))
adj_cluster    &lt;- prepareAdjMat(sx, group, databases = db_edges, cluster = TRUE)
out_cluster    &lt;- NetGSA(adj_cluster[["Adj"]], sx, group, 
                         pathways_mat[c(1,2), rownames(sx)], lklMethod = "REHE", sampling = FALSE)
plot(out_cluster)
formatPathways(out_netgsa, "Adipocytokine signaling pathway")

## End(Not run)
</code></pre>

<hr>
<h2 id='group'>The vector of class indicators</h2><span id='topic+group'></span>

<h3>Description</h3>

<p>The vector of class indicators
</p>


<h3>Usage</h3>

<pre><code class='language-R'>group
</code></pre>


<h3>Format</h3>

<p>An object of class <code>numeric</code> of length 520.
</p>

<hr>
<h2 id='netEst.dir'>
Constrained estimation of directed networks
</h2><span id='topic+netEst.dir'></span>

<h3>Description</h3>

<p>Estimates a directed network using a lasso (L1) penalty.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>netEst.dir(x, zero = NULL, one = NULL, lambda, verbose = FALSE, eps = 1e-08)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="netEst.dir_+3A_x">x</code></td>
<td>
<p>The <code class="reqn">p \times n</code> data matrix.</p>
</td></tr>
<tr><td><code id="netEst.dir_+3A_zero">zero</code></td>
<td>
<p>(Optional) indices of entries of the matrix to be constrained to be zero. The input should be a matrix of <code class="reqn">p \times p</code>, with 1 at entries to be constrained to be zero and 0 elsewhere.</p>
</td></tr>
<tr><td><code id="netEst.dir_+3A_one">one</code></td>
<td>
<p>(Optional) indices of entries of the matrix to be kept regardless of the regularization parameter for lasso. The input is similar to that of <code>zero</code>.</p>
</td></tr>
<tr><td><code id="netEst.dir_+3A_lambda">lambda</code></td>
<td>
<p>(Non-negative) numeric scalar or a vector of length <code class="reqn">p-1</code> representing the regularization parameters for nodewise lasso. If <code>lambda</code> is a scalar, the same penalty will be used for all <code class="reqn">p-1</code> lasso regressions. By default (<code>lambda=NULL</code>), the vector of <code>lambda</code> is defined as
</p>
<p style="text-align: center;"><code class="reqn">\lambda_j(\alpha) = 2 n^{-1/2} Z^*_{\frac{\alpha}{2p(j-1)}}, \quad j=2,\ldots,p.</code>
</p>

<p>Here <code class="reqn">Z^*_q</code> represents the <code class="reqn">(1-q)</code>-th quantile of the standard normal distribution and <code class="reqn">\alpha</code> is a positive constant between 0 and 1. See Shojaie and Michailidis (2010a) for details on the choice of tuning parameters.
</p>
</td></tr>
<tr><td><code id="netEst.dir_+3A_verbose">verbose</code></td>
<td>
<p>Whether to print out information as estimation proceeds. Default = <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="netEst.dir_+3A_eps">eps</code></td>
<td>
<p>(Non-negative) numeric scalar indicating the tolerance level for differentiating zero and non-zero edges: entries with magnitude <code class="reqn">&lt;</code> <code>eps</code> will be set to 0. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>netEst.dir</code> performs constrained estimation of a directed network using a lasso (L1) penalty, as described in Shojaie and Michailidis (2010a). Two sets of constraints determine subsets of entries of the weighted adjacency matrix that should be exactly zero (the option <code>zero</code> argument), or should take non-zero values (option <code>one</code> argument). The remaining entries will be estimated from data.
</p>
<p>The arguments <code>one</code> and/or <code>zero</code> can come from external knowledge on the 0-1 structure of underlying network, such as a list of edges and/or non-edges learned from available databases.
</p>
<p>In this function, it is assumed that the columns of <code class="reqn">x</code> are ordered according to a correct (Wald) causal order, such that no <code class="reqn">x_j</code> is a parent of <code class="reqn">x_k</code> (<code class="reqn">k \le j</code>). Given the causal ordering of nodes, the resulting adjacency matrix is lower triangular (see Shojaie &amp; Michailidis, 2010b). Thus, only lower triangular parts of <code>zero</code> and <code>one</code> are used in this function. For this reason, it is important that both of these matrices are also ordered according to the causal order of the nodes in <code class="reqn">x</code>. To estimate the network, first each node is regressed on the known edges (<code>one</code>). The residual obtained from this regression is then used to find the additional edges, among the nodes that could potentially interact with the given node (those not in <code>zero</code>).
</p>
<p>This function is closely related to <code>NetGSA</code>, which requires the weighted adjacency matrix as input. When the user does not have complete information on the weighted adjacency matrix, but has data (not necessarily the same as the <code>x</code> in <code>NetGSA</code>) and external information (<code>one</code> and/or <code>zero</code>) on the adjacency matrix, then <code>netEst.dir</code> can be used to estimate the remaining interactions in the adjacency matrix using the data.
Further, when it is anticipated that the adjacency matrices under different conditions are different, and data from different conditions are available, the user needs to run <code>netEst.dir</code> separately to obtain estimates of the adjacency matrices under each condition.
</p>
<p>The algorithm used in <code>netEst.undir</code> is based on <code>glmnet</code>. Please refer to <code>glmnet</code> for computational details.
</p>


<h3>Value</h3>

<p>A list with components
</p>
<table role = "presentation">
<tr><td><code>Adj</code></td>
<td>
<p>The weighted adjacency matrix of dimension <code class="reqn">p \times p</code>. This is the matrix that will be used in <code>NetGSA</code>.</p>
</td></tr>
<tr><td><code>infmat</code></td>
<td>
<p>The influence matrix of dimension <code class="reqn">p \times p</code>.</p>
</td></tr>
<tr><td><code>lambda</code></td>
<td>
<p>The values of tuning parameters used.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Ali Shojaie
</p>


<h3>References</h3>

<p>Shojaie, A., &amp; Michailidis, G. (2010a). Penalized likelihood methods for estimation of sparse high-dimensional directed acyclic graphs. Biometrika 97(3), 519-538. <a href="https://academic.oup.com/biomet/article-abstract/97/3/519/243918">https://academic.oup.com/biomet/article-abstract/97/3/519/243918</a>
</p>
<p>Shojaie, A., &amp; Michailidis, G. (2010b). Network enrichment analysis in complex experiments. Statistical applications in genetics and molecular biology, 9(1), Article 22. <a href="https://pubmed.ncbi.nlm.nih.gov/20597848/">https://pubmed.ncbi.nlm.nih.gov/20597848/</a>.
</p>
<p>Shojaie, A., &amp; Michailidis, G. (2009). Analysis of gene sets based on the underlying regulatory network. Journal of Computational Biology, 16(3), 407-426. <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC3131840/">https://www.ncbi.nlm.nih.gov/pmc/articles/PMC3131840/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+prepareAdjMat">prepareAdjMat</a></code>, <code><a href="glmnet.html#topic+glmnet">glmnet</a></code>
</p>

<hr>
<h2 id='netEst.undir'>
Constrained estimation of undirected networks
</h2><span id='topic+netEst.undir'></span>

<h3>Description</h3>

<p>Estimates a sparse inverse covariance matrix using a lasso (L1) penalty.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>netEst.undir(x, zero = NULL, one = NULL, lambda, rho=NULL, 
             penalize_diag = TRUE, weight = NULL, 
             eta = 0, verbose = FALSE, eps = 1e-08)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="netEst.undir_+3A_x">x</code></td>
<td>
<p>The <code class="reqn">p \times n</code> data matrix with rows referring to genes and columns to samples.</p>
</td></tr>
<tr><td><code id="netEst.undir_+3A_zero">zero</code></td>
<td>
<p>(Optional) indices of entries of the weighted adjacency matrix to be constrained to be zero. The input should be a matrix of <code class="reqn">p \times p</code>, with 1 at entries to be constrained to be zero and 0 elsewhere. The matrix must be symmetric.</p>
</td></tr>
<tr><td><code id="netEst.undir_+3A_one">one</code></td>
<td>
<p>(Optional) indices of entries of the weighted adjacency matrix to be kept regardless of the regularization parameter for lasso. The input is similar to that of <code>zero</code> and needs to be symmetric.</p>
</td></tr>
<tr><td><code id="netEst.undir_+3A_lambda">lambda</code></td>
<td>
<p>(Non-negative) numeric vector representing the regularization parameters for lasso. Can choose best based on BIC using <code>bic.netEst.undir</code></p>
</td></tr>
<tr><td><code id="netEst.undir_+3A_rho">rho</code></td>
<td>
<p>(Non-negative) numeric scalar or symmetric <code class="reqn">p \times p</code> matrix representing the regularization parameter for estimating the weights in the inverse covariance matrix. This is the same as <code>rho</code> in the graphical lasso algorithm <code>glassoFast</code>.</p>
</td></tr>
<tr><td><code id="netEst.undir_+3A_penalize_diag">penalize_diag</code></td>
<td>
<p>Logical. Whether or not to penalize diagonal entries when estimating weighted adjacency matrix. If TRUE a small penalty is used, otherwise no penalty is used.</p>
</td></tr>
<tr><td><code id="netEst.undir_+3A_weight">weight</code></td>
<td>
<p>(Optional) whether to add penalty to known edges. If NULL (default), then the known edges are assumed to be true. If nonzero, then a penalty equal to lambda * weight is added to penalize the known edges to account for possible uncertainty. Only non-negative values are accepted for the weight parameter.  </p>
</td></tr>
<tr><td><code id="netEst.undir_+3A_eta">eta</code></td>
<td>
<p>(Non-negative) a small constant added to the diagonal of the empirical covariance matrix of <code>X</code> to ensure it is well conditioned. By default, <code>eta</code> is set to 0.</p>
</td></tr>
<tr><td><code id="netEst.undir_+3A_verbose">verbose</code></td>
<td>
<p>Whether to print out information as estimation proceeds. Default = <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="netEst.undir_+3A_eps">eps</code></td>
<td>
<p>(Non-negative) numeric scalar indicating the tolerance level for differentiating zero and non-zero edges: entries with magnitude <code class="reqn">&lt;</code> <code>eps</code> will be set to 0. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>netEst.undir</code> performs constrained estimation of sparse inverse covariance (concentration) matrices using a lasso (L1) penalty, as described in Ma, Shojaie and Michailidis (2016). Two sets of constraints determine subsets of entries of the inverse covariance matrix that should be exactly zero (the option <code>zero</code> argument), or should take non-zero values (option <code>one</code> argument). The remaining entries will be estimated from data.
</p>
<p>The arguments <code>one</code> and/or <code>zero</code> can come from external knowledge on the 0-1 structure of underlying concentration matrix, such as a list of edges and/or non-edges learned from available databases.
</p>
<p><code>netEst.undir</code> estimates both the support (0-1 structure) of the concentration matrix, or equivalently, the adjacency matrix of the corresponding Gaussian graphical model, for a given tuning parameter, <code>lambda</code>; and the concentration matrix with diagonal entries set to 0, or equivalently, the weighted adjacency matrix.
The weighted adjacency matrix is estimated using maximum likelihood based on the estimated support. The parameter <code>rho</code> controls the amount of regularization used in the maximum likelihood step. A small <code>rho</code> is recommended, as a large value of <code>rho</code> may result in too much regularization in the maximum likelihood estimation, thus further penalizing the support of the weighted adjacency matrix.  
Note this function is suitable only for estimating the adjacency matrix of a undirected graph. The <code>weight</code> parameter allows one to specify whether to penalize the known edges. If known edges obtained from external information contain uncertainty such that some of them are spurious, then it is recommended to use a small positive <code>weight</code> parameter to select the most probable edges from the collection of known ones. 
</p>
<p>This function is closely related to <code>NetGSA</code>, which requires the weighted adjacency matrix as input. When the user does not have complete information on the weighted adjacency matrix, but has data (<code>x</code>, not necessarily the same as the <code>x</code> in <code>NetGSA</code>) and external information (<code>one</code> and/or <code>zero</code>) on the adjacency matrix, then <code>netEst.undir</code> can be used to estimate the remaining interactions in the adjacency matrix using the data.
Further, when it is anticipated that the adjacency matrices under different conditions are different, and data from different conditions are available, the user needs to run <code>netEst.undir</code> separately to obtain estimates of the adjacency matrices under each condition.
</p>
<p>The algorithm used in <code>netEst.undir</code> is based on <code>glmnet</code> and <code>glasso</code>. Please refer to <code>glmnet</code> and <code>glasso</code> for computational details.
</p>


<h3>Value</h3>

<p>A list with components
</p>
<table role = "presentation">
<tr><td><code>Adj</code></td>
<td>
<p>List of weighted adjacency matrices (partial correlations) of dimension <code class="reqn">p \times p</code>, with diagonal entries set to 0. Each element in the list is the weighted adjacency matric corresponding to each value in <code>lambda</code>. Each element is a matrix that will be used in <code>NetGSA</code>.</p>
</td></tr>
<tr><td><code>invcov</code></td>
<td>
<p>List of estimated inverse covariance matrix of dimension <code class="reqn">p \times p</code>.</p>
</td></tr>
<tr><td><code>lambda</code></td>
<td>
<p>List of values of tuning parameters used.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jing Ma &amp; Michael Hellstern
</p>


<h3>References</h3>

<p>Ma, J., Shojaie, A. &amp; Michailidis, G. (2016) Network-based pathway enrichment analysis with incomplete network information. Bioinformatics 32(20):165&ndash;3174. <a href="https://doi.org/10.1093/bioinformatics/btw410">doi:10.1093/bioinformatics/btw410</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+prepareAdjMat">prepareAdjMat</a></code>, <code><a href="#topic+bic.netEst.undir">bic.netEst.undir</a></code>, <code><a href="glmnet.html#topic+glmnet">glmnet</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(glassoFast)
library(graphite)
library(igraph)

set.seed(1)

## load the data
data(breastcancer2012_subset)

## consider genes from the "Estrogen signaling pathway" and "Jak-STAT signaling pathway"
genenames &lt;- unique(c(pathways[[25]], pathways[[52]]))
sx &lt;- x[match(genenames, rownames(x)),]
if (sum(is.na(rownames(sx)))&gt;0){
  sx &lt;- sx[-which(is.na(rownames(sx))),]
}
p &lt;- length(genenames)

## zero/one matrices should be based on known non-edges/known edges. Random used as an example
one &lt;- matrix(sample(c(0,1), length(rownames(sx))**2, 
              replace = TRUE, prob = c(0.9, 0.1)), length(rownames(sx)), 
              dimnames = list(rownames(sx), rownames(sx)))

ncond &lt;- length(unique(group))
Amat &lt;- vector("list",ncond)
for (k in 1:ncond){
    data_c &lt;- sx[,(group==k)]
    fitBIC &lt;- bic.netEst.undir(data_c,one=one,
                               lambda=seq(1,10)*sqrt(log(p)/ncol(data_c)),eta=0.1)
    fit &lt;- netEst.undir(data_c,one=one,
                        lambda=which.min(fitBIC$BIC)*sqrt(log(p)/ncol(data_c)),eta=0.1)
    Amat[[k]] &lt;- fit$Adj
}

</code></pre>

<hr>
<h2 id='NetGSA'>Network-based Gene Set Analysis</h2><span id='topic+NetGSA'></span>

<h3>Description</h3>

<p>Tests the significance of pre-defined sets of genes (pathways) with respect to an outcome variable, such as the condition indicator (e.g. cancer vs. normal, etc.), based on the underlying biological networks.</p>


<h3>Usage</h3>

<pre><code class='language-R'>NetGSA(A, x, group, pathways, lklMethod = "REHE", 
       sampling=FALSE, sample_n = NULL, sample_p = NULL, minsize=5, 
       eta = 0.1, lim4kappa = 500)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="NetGSA_+3A_a">A</code></td>
<td>
<p>A list of weighted adjacency matrices. Typically returned from <code>prepareAdjMat</code></p>
</td></tr>
<tr><td><code id="NetGSA_+3A_x">x</code></td>
<td>
<p>The <code class="reqn">p \times n</code> data matrix with rows referring to genes and columns to samples. It is very important that the adjacency matrices <code>A</code> share the same rownames as the data matrix <code>x</code>.</p>
</td></tr>
<tr><td><code id="NetGSA_+3A_group">group</code></td>
<td>
<p>Vector of class indicators of length <code class="reqn">n</code>.</p>
</td></tr>
<tr><td><code id="NetGSA_+3A_pathways">pathways</code></td>
<td>
<p>The npath by <code class="reqn">p</code> indicator matrix for pathways.</p>
</td></tr>
<tr><td><code id="NetGSA_+3A_lklmethod">lklMethod</code></td>
<td>
<p>Method used for variance component calculation: options are <code>ML</code> (maximum likelihood), <code>REML</code> (restricted maximum likelihood), <code>HE</code> (Haseman-Elston regression) or <code>REHE</code> (restricted Haseman-Elston regression). See details.</p>
</td></tr>
<tr><td><code id="NetGSA_+3A_sampling">sampling</code></td>
<td>
<p>(Logical) whether to subsample the observations and/or variables. See details.</p>
</td></tr>
<tr><td><code id="NetGSA_+3A_sample_n">sample_n</code></td>
<td>
<p>The ratio for subsampling the observations if <code>sampling=TRUE</code>.</p>
</td></tr>
<tr><td><code id="NetGSA_+3A_sample_p">sample_p</code></td>
<td>
<p>The ratio for subsampling the variables if <code>sampling=TRUE</code>.</p>
</td></tr>
<tr><td><code id="NetGSA_+3A_minsize">minsize</code></td>
<td>
<p>Minimum number of genes in pathways to be considered.</p>
</td></tr>
<tr><td><code id="NetGSA_+3A_eta">eta</code></td>
<td>
<p>Approximation limit for the Influence matrix. See 'Details'.</p>
</td></tr>
<tr><td><code id="NetGSA_+3A_lim4kappa">lim4kappa</code></td>
<td>
<p>Limit for condition number (used to adjust <code>eta</code>). See 'Details'.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>NetGSA</code> carries out a Network-based Gene Set Analysis, using the method described in Shojaie and Michailidis (2009) and Shojaie and Michailidis (2010). It can be used for gene set (pathway) enrichment analysis where the data come from <code class="reqn">K</code> heterogeneous conditions, where <code class="reqn">K</code>, or more. NetGSA differs from Gene Set Analysis (Efron and Tibshirani, 2007) in that it incorporates the underlying biological networks. Therefore, when the networks encoded in <code>A</code> are empty, one should instead consider alternative approaches such as Gene Set Analysis (Efron and Tibshirani, 2007).
</p>
<p>The NetGSA method is formulated in terms of a mixed linear model. Let <code class="reqn">X</code> represent the rearrangement of data <code>x</code> into an <code class="reqn">np \times 1</code> column vector.  
</p>
<p style="text-align: center;"><code class="reqn">X=\Psi \beta + \Pi \gamma + \epsilon</code>
</p>

<p>where <code class="reqn">\beta</code> is the vector of fixed effects, <code class="reqn">\gamma</code> and <code class="reqn">\epsilon</code> are random effects and random errors, respectively. The underlying biological networks are encoded in the weighted adjacency matrices, which determine the influence matrix under each condition. The influence matrices further determine the design matrices <code class="reqn">\Psi</code> and <code class="reqn">\Pi</code> in the mixed linear model. Formally, the influence matrix under each condition represents the effect of each gene on all the other genes in the network and is calculated from the adjacency matrix (<code>A[[k]]</code> for the <code class="reqn">k</code>-th condition). A small value of <code>eta</code> is used to make sure that the influence matrices are well-conditioned (i.e. their condition numbers are bounded by <code>lim4kappa</code>.)
</p>
<p>The problem is then to test the null hypothesis <code class="reqn">\ell\beta = 0</code> against the alternative <code class="reqn">\ell\beta \neq 0</code>, where <code class="reqn">\ell</code> is a contrast vector, optimally defined through the underlying networks. 
For a one-sample or two-sample test, the test statistic <code class="reqn">T</code> for each gene set has approximately a t-distribution under the null, whose degrees of freedom are estimated using the Satterthwaite approximation method. When analyzing complex experiments involving multiple conditions, often multiple contrast vectors of interest are considered for a specific subnetwork. Alternatively, one can combine the contrast vectors into a contrast matrix <code class="reqn">L</code>. A different test statistic <code class="reqn">F</code> will be used. Under the null, <code class="reqn">F</code> has an F-distribution, whose degrees of freedom are calculated based on the contrast matrix <code class="reqn">L</code> as well as variances of <code class="reqn">\gamma</code> and <code class="reqn">\epsilon</code>. The fixed effects <code class="reqn">\beta</code> are estimated by generalized least squares, and the estimate depends on estimated variance components of <code class="reqn">\gamma</code> and <code class="reqn">\epsilon</code>. 
</p>
<p>Estimation of the variance components (<code class="reqn">\sigma^2_{\epsilon}</code> and <code class="reqn">\sigma^2_{\gamma}</code>) can be done in several different ways after profiling out <code class="reqn">\sigma^2_{\epsilon}</code>, including <code>REML/ML</code> which uses Newton's method or <code>HE/REHE</code> which is based on the Haseman-Elston regression method. The latter notes the fact that <code class="reqn">Var(X)=\sigma^2_{\gamma}\Pi*\Pi' + \sigma^2_{\epsilon}I</code>, and uses an ordinary least squares to solve for the unknown coefficients after vectorizing both sides. In particular, <code>REHE</code> uses nonnegative least squares for the regression and therefore ensures nonnegative estimate of the variance components. Due to the simple formulation, <code>HE/REHE</code> also allows subsampling with respect to both the samples and the variables, and is recommended especially when the problem is large (i.e. large <code class="reqn">p</code> and/or large <code class="reqn">n</code>).
</p>
<p>The pathway membership information is stored in <code>pathways</code>, which should be a matrix of <code class="reqn">npath</code> x <code class="reqn">p</code>. See <code><a href="#topic+prepareAdjMat">prepareAdjMat</a></code> for details on how to prepare a suitable pathway membership object.
</p>
<p>This function can deal with both directed and undirected networks, which are specified via the option <code>directed</code>. Note <code>NetGSA</code> uses slightly different procedures to calculate the influence matrices for directed and undirected networks. 
In either case, the user can still apply <code>NetGSA</code> if only partial information on the adjacency matrices is available. The functions <code>netEst.undir</code> and <code>netEst.dir</code> provide details on how to estimate the weighted adjacency matrices from data based on available network information. 
</p>


<h3>Value</h3>

<p>A list with components
</p>
<table role = "presentation">
<tr><td><code>results</code></td>
<td>
<p>A data frame with pathway names, pathway sizes, p-values and false discovery rate corrected q-values, and test statistic for all pathways.</p>
</td></tr>
<tr><td><code>beta</code></td>
<td>
<p>Vector of fixed effects of length <code class="reqn">kp</code>, the first k elements corresponds to condition 1, the second k to condition 2, etc</p>
</td></tr>
<tr><td><code>s2.epsilon</code></td>
<td>
<p>Variance of the random errors <code class="reqn">\epsilon</code>.</p>
</td></tr>
<tr><td><code>s2.gamma</code></td>
<td>
<p>Variance of the random effects <code class="reqn">\gamma</code>.</p>
</td></tr>
<tr><td><code>graph</code></td>
<td>
<p>List of components needed in <code>plot.NetGSA</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Ali Shojaie and Jing Ma
</p>


<h3>References</h3>

<p>Ma, J., Shojaie, A. &amp; Michailidis, G. (2016) Network-based pathway enrichment analysis with incomplete network information. Bioinformatics 32(20):165&ndash;3174. <a href="https://doi.org/10.1093/bioinformatics/btw410">doi:10.1093/bioinformatics/btw410</a>
</p>
<p>Shojaie, A., &amp; Michailidis, G. (2010). Network enrichment analysis in complex experiments. Statistical applications in genetics and molecular biology, 9(1), Article 22. <a href="https://pubmed.ncbi.nlm.nih.gov/20597848/">https://pubmed.ncbi.nlm.nih.gov/20597848/</a>.
</p>
<p>Shojaie, A., &amp; Michailidis, G. (2009). Analysis of gene sets based on the underlying regulatory network. Journal of Computational Biology, 16(3), 407-426. <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC3131840/">https://www.ncbi.nlm.nih.gov/pmc/articles/PMC3131840/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+prepareAdjMat">prepareAdjMat</a></code>, <code><a href="#topic+netEst.dir">netEst.dir</a></code>, <code><a href="#topic+netEst.undir">netEst.undir</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## load the data
data("breastcancer2012_subset")

## consider genes from just 2 pathways
genenames    &lt;- unique(c(pathways[["Adipocytokine signaling pathway"]], 
                         pathways[["Adrenergic signaling in cardiomyocytes"]]))
sx           &lt;- x[match(rownames(x), genenames, nomatch = 0L) &gt; 0L,]

db_edges       &lt;- obtainEdgeList(rownames(sx), databases = c("kegg", "reactome"))
adj_cluster    &lt;- prepareAdjMat(sx, group, databases = db_edges, cluster = TRUE)
out_cluster    &lt;- NetGSA(adj_cluster[["Adj"]], sx, group, 
                         pathways_mat[c(1,2), rownames(sx)], lklMethod = "REHE", sampling = FALSE)

</code></pre>

<hr>
<h2 id='NetGSAq'>&quot;Quick&quot; Network-based Gene Set Analysis</h2><span id='topic+NetGSAq'></span>

<h3>Description</h3>

<p>Quick version of <code>NetGSA</code></p>


<h3>Usage</h3>

<pre><code class='language-R'>NetGSAq(x, group, pathways, lambda_c = 1, file_e = NULL, file_ne = NULL,
    lklMethod="REHE", cluster = TRUE, sampling = TRUE, sample_n = NULL,
    sample_p = NULL, minsize=5, eta=0.1, lim4kappa=500)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="NetGSAq_+3A_x">x</code></td>
<td>
<p>See <code>x</code> argument in <code>NetGSA</code></p>
</td></tr>
<tr><td><code id="NetGSAq_+3A_group">group</code></td>
<td>
<p>See <code>group</code> argument in <code>NetGSA</code></p>
</td></tr>
<tr><td><code id="NetGSAq_+3A_pathways">pathways</code></td>
<td>
<p>See <code>pathways</code> argument in <code>NetGSA</code></p>
</td></tr>
<tr><td><code id="NetGSAq_+3A_lambda_c">lambda_c</code></td>
<td>
<p>See <code>lambda_c</code> argument in <code>prepareAdjMat</code></p>
</td></tr>
<tr><td><code id="NetGSAq_+3A_file_e">file_e</code></td>
<td>
<p>See <code>file_e</code> argument in <code>prepareAdjMat</code></p>
</td></tr>
<tr><td><code id="NetGSAq_+3A_file_ne">file_ne</code></td>
<td>
<p>See <code>file_ne</code> argument in <code>prepareAdjMat</code></p>
</td></tr>
<tr><td><code id="NetGSAq_+3A_lklmethod">lklMethod</code></td>
<td>
<p>See <code>lklMethod</code> argument in <code>NetGSA</code></p>
</td></tr>
<tr><td><code id="NetGSAq_+3A_cluster">cluster</code></td>
<td>
<p>See <code>cluster</code> argument in <code>prepareAdjMat</code></p>
</td></tr>
<tr><td><code id="NetGSAq_+3A_sampling">sampling</code></td>
<td>
<p>See <code>sampling</code> argument in <code>NetGSA</code></p>
</td></tr>
<tr><td><code id="NetGSAq_+3A_sample_n">sample_n</code></td>
<td>
<p>See <code>sample_n</code> argument in <code>NetGSA</code></p>
</td></tr>
<tr><td><code id="NetGSAq_+3A_sample_p">sample_p</code></td>
<td>
<p>See <code>sample_p</code> argument in <code>NetGSA</code></p>
</td></tr>
<tr><td><code id="NetGSAq_+3A_minsize">minsize</code></td>
<td>
<p>See <code>minsize</code> argument in <code>NetGSA</code></p>
</td></tr>
<tr><td><code id="NetGSAq_+3A_eta">eta</code></td>
<td>
<p>See <code>eta</code> argument in <code>NetGSA</code></p>
</td></tr>
<tr><td><code id="NetGSAq_+3A_lim4kappa">lim4kappa</code></td>
<td>
<p>See <code>lim4kappa</code> argument in <code>NetGSA</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a wrapper function to perform weighted adjacency matrix estimation and pathway enrichment in one step. For more details see <code>?prepareAdjMat</code> and <code>?NetGSA</code>.
</p>


<h3>Value</h3>

<p>A list with components
</p>
<table role = "presentation">
<tr><td><code>results</code></td>
<td>
<p>A data frame with pathway names, pathway sizes, p-values and false discovery rate corrected q-values, and test statistic for all pathways.</p>
</td></tr>
<tr><td><code>beta</code></td>
<td>
<p>Vector of fixed effects of length <code class="reqn">kp</code>, the first k elements corresponds to condition 1, the second k to condition 2, etc.</p>
</td></tr>
<tr><td><code>s2.epsilon</code></td>
<td>
<p>Variance of the random errors <code class="reqn">\epsilon</code>.</p>
</td></tr>
<tr><td><code>s2.gamma</code></td>
<td>
<p>Variance of the random effects <code class="reqn">\gamma</code>.</p>
</td></tr>
<tr><td><code>graph</code></td>
<td>
<p>List of components needed in <code>plot.NetGSA</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Michael Hellstern
</p>


<h3>References</h3>

<p>Ma, J., Shojaie, A. &amp; Michailidis, G. (2016) Network-based pathway enrichment analysis with incomplete network information. Bioinformatics 32(20):165&ndash;3174. <a href="https://doi.org/10.1093/bioinformatics/btw410">doi:10.1093/bioinformatics/btw410</a>
</p>
<p>Shojaie, A., &amp; Michailidis, G. (2010). Network enrichment analysis in complex experiments. Statistical applications in genetics and molecular biology, 9(1), Article 22. <a href="https://pubmed.ncbi.nlm.nih.gov/20597848/">https://pubmed.ncbi.nlm.nih.gov/20597848/</a>.
</p>
<p>Shojaie, A., &amp; Michailidis, G. (2009). Analysis of gene sets based on the underlying regulatory network. Journal of Computational Biology, 16(3), 407-426. <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC3131840/">https://www.ncbi.nlm.nih.gov/pmc/articles/PMC3131840/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+prepareAdjMat">prepareAdjMat</a></code>, <code><a href="#topic+netEst.dir">netEst.dir</a></code>, <code><a href="#topic+netEst.undir">netEst.undir</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Example takes ~3 minutes to run depending on computer
## load the data
data("breastcancer2012_subset")

## consider genes from just 2 pathways
genenames    &lt;- unique(c(pathways[["Adipocytokine signaling pathway"]], 
                         pathways[["Adrenergic signaling in cardiomyocytes"]]))
sx           &lt;- x[match(rownames(x), genenames, nomatch = 0L) &gt; 0L,]

out_clusterq &lt;- NetGSAq(sx, group, pathways_mat[c(1, 2), rownames(sx)])

</code></pre>

<hr>
<h2 id='nonedgelist'>A data frame of nonedges, each row corresponding to one negative edge</h2><span id='topic+nonedgelist'></span>

<h3>Description</h3>

<p>A data frame of nonedges, each row corresponding to one negative edge
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nonedgelist
</code></pre>


<h3>Format</h3>

<p>An object of class <code>data.frame</code> with 1 rows and 4 columns.
</p>

<hr>
<h2 id='obtainClusters'>Estimate optimal gene clustering structure</h2><span id='topic+obtainClusters'></span>

<h3>Description</h3>

<p>Tries six different clustering methods and chooses the one with the best results. This is a helper function in <code>prepareAdjMat</code> and should not be called by the user.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>obtainClusters(A, order, cluster)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="obtainClusters_+3A_a">A</code></td>
<td>
<p>A 0-1 adjacency matrix</p>
</td></tr>
<tr><td><code id="obtainClusters_+3A_order">order</code></td>
<td>
<p>Final ordering of genes/metabs to be consistent with order you passed data in</p>
</td></tr>
<tr><td><code id="obtainClusters_+3A_cluster">cluster</code></td>
<td>
<p>Whether or not to cluster (TRUE/FALSE). We always cluster connected components, but if cluster = TRUE we cluster further</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function tries the six different clustering methods in igraph and chooses the best one. As stated in <code>prepareAdjMat</code> the six methods evaluated are: <code>cluster_walktrap</code>, <code>cluster_leading_eigen</code>, <code>cluster_fast_greedy</code>, <code>cluster_label_prop</code>, <code>cluster_infomap</code>, and <code>cluster_louvain</code>. See <code>prepareAdjMat</code> for how the best is chosen. Even if <code>cluster = FALSE</code>, connected components of the 0-1 adjacency matrix are used as clusters.
</p>
<p>It is essential that the order of the returned named numeric vector must be in the same order as the rows of the data matrix.
</p>


<h3>Value</h3>

<p>Named numeric vector of membership. The name of each element is the corresponding gene and the value is the cluster it belongs to.
</p>


<h3>Author(s)</h3>

<p>Michael Hellstern
</p>


<h3>References</h3>

<p>Ma, J., Shojaie, A. &amp; Michailidis, G. (2016) Network-based pathway enrichment analysis with incomplete network information. Bioinformatics 32(20):165&ndash;3174. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+prepareAdjMat">prepareAdjMat</a></code>
</p>

<hr>
<h2 id='obtainEdgeList'>Obtain edgelist from graphite databases. To be used within prepareAdjMat</h2><span id='topic+obtainEdgeList'></span>

<h3>Description</h3>

<p>Find all edges between genes in the specified graphite databases.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>obtainEdgeList(genes, databases)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="obtainEdgeList_+3A_genes">genes</code></td>
<td>
<p>Character vector of gene ID and gene value. The ID and gene value should be separated by a colon. E.g. &quot;ENTREZID:127550&quot;. It is very important to have these separated by a colon since <code>obtainEdgeList</code> uses regular expressions to split this into gene value and gene ID.</p>
</td></tr>
<tr><td><code id="obtainEdgeList_+3A_databases">databases</code></td>
<td>
<p>Character vector of graphite databases you wish to search for edges. Options are: biocarta, kegg, nci, panther, pathbank, pharmgkb, reactome, smpdb, ndex. Note NDEx is recommended for expert users and is only available for the development version of netgsa (https://github.com/mikehellstern/netgsa), see details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>obtainEdgeList</code> searches through the specified databases to find edges between genes in the <code>genes</code> argument. Since one can search in multiple databases with different identifiers, genes are converted using <code>AnnotationDbi::select</code> and metabolites are converted using <code>graphite:::metabolites()</code>. Databases are also used to specify non-edges. This function searches through <code>graphite</code> databases and also has the option to search NDEx (public databases only). However, since NDEx is open-source and does not contain curated edge information like <code>graphite</code>, NDEx database search is a beta function and is only recommended for expert users. When searching through NDEx, gene identifiers are not converted. Only, the gene identifiers passed to the <code>genes</code> argument are used to search through NDEx. NDEx contains some very large networks with millions of edges and extracting those of interest can be slow.
</p>
<p>This function is particularly useful if the user wants to create an edgelist outside of <code>prepareAdjMat</code>. <code>graphite</code> and it's databases are constantly updated. Creating and storing an edgelist outside of <code>prepareAdjMat</code> may help reproducibility as this guarantees the same external information is used. It can also speed up computation since if only a character vector of databases is passed to <code>prepareAdjMat</code>, it calls <code>obtainEdgeList</code> each time and each call can take several minutes. The edges from <code>obtainEdgeList</code> are used to create the 0-1 adjacency matrices used in <code>netEst.undir</code> and <code>netEst.dir</code>.
</p>
<p>Using <code>obtainEdgeList</code> to generate edge information is highly recommended as this performs all the searching and conversion of genes to common identifiers. Inclusion of additional edges, removal of edges, or other user modifications to edgelists should be through the <code>file_e</code> and <code>file_ne</code> arguments in <code>prepareAdjMat</code>.
</p>


<h3>Value</h3>

<p>A list of class <code>obtainedEdgeList</code> with components
</p>
<table role = "presentation">
<tr><td><code>edgelist</code></td>
<td>
<p>A <code>data.table</code> listing the edges. One row per edge. Edges are assumed to be directed. So if an edge is undirected there will be two rows.</p>
</td></tr>
<tr><td><code>genes_not_in_dbs</code></td>
<td>
<p>A vector of genes specified, but were not found in the databases searched</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Michael Hellstern
</p>


<h3>See Also</h3>

<p><code><a href="#topic+prepareAdjMat">prepareAdjMat</a></code>, <code><a href="#topic+netEst.dir">netEst.dir</a></code>, <code><a href="#topic+netEst.undir">netEst.undir</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
genes &lt;- paste0("ENTREZID:", c("10000", "10298", "106821730", 
                               "10718", "1398", "1399", "145957", 
                               "1839", "1950", "1956"))

out &lt;- obtainEdgeList(genes, c("kegg", "reactome"))

</code></pre>

<hr>
<h2 id='pathways'>A list of KEGG pathways</h2><span id='topic+pathways'></span>

<h3>Description</h3>

<p>A list of KEGG pathways
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pathways
</code></pre>


<h3>Format</h3>

<p>An object of class <code>list</code> of length 100.
</p>

<hr>
<h2 id='pathways_mat'>Matrix with pathway indicators</h2><span id='topic+pathways_mat'></span>

<h3>Description</h3>

<p>Matrix with pathway indicators
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pathways_mat
</code></pre>


<h3>Format</h3>

<p>An object of class <code>matrix</code> (inherits from <code>array</code>) with 51 rows and 250 columns.
</p>

<hr>
<h2 id='plot.NetGSA'>Generates NetGSA plots</h2><span id='topic+plot.NetGSA'></span>

<h3>Description</h3>

<p>Generates network plots in Cytoscape and igraph</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'NetGSA'
plot(x, graph_layout = NULL, rescale_node = c(2,10), rescale_label = c(0.5,0.6), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.NetGSA_+3A_x">x</code></td>
<td>
<p>An object of class &quot;NetGSA&quot; returned from calling <code>NetGSA()</code></p>
</td></tr>
<tr><td><code id="plot.NetGSA_+3A_graph_layout">graph_layout</code></td>
<td>
<p>(Optional) Layout to pass to plots. Either a function for igraph plots (when Cytoscape not open) or a string for Cytoscape. The igraph function should only take one parameter (an igraph object). See <code>igraph::layout_</code> for more details. For example one might create a custom layout by setting the spring.length and spring.constant with: <code>my_layout &lt;- function(graph) layout_with_graphopt(graph = graph, spring.length = 1000, spring.constant = 0.00004)</code>. The string for Cytoscape will be passed to <code>RCy3::layoutNetwork</code>.</p>
</td></tr>
<tr><td><code id="plot.NetGSA_+3A_rescale_node">rescale_node</code></td>
<td>
<p>(Optional) Node size rescaling to pass to igraph plots. Must be a vector of length 2 with the first element being the minimum node size and the second being the maximum.</p>
</td></tr>
<tr><td><code id="plot.NetGSA_+3A_rescale_label">rescale_label</code></td>
<td>
<p>(Optional) Label size rescaling to pass to igraph plots. Must be a vector of length 2 with the first element being the minimum node size and the second being the maximum.</p>
</td></tr>
<tr><td><code id="plot.NetGSA_+3A_...">...</code></td>
<td>
<p>Other arguments not used by this method</p>
</td></tr>
</table>


<h3>Details</h3>

<p>One of two options can occur.
</p>
<p>(1) If Cytoscape is open on the user's computer, a nested network will be created. The main network is the interactions between pathways. In this graph, there is one node for each pathway. An edge is drawn between pathways if there is at least one edge between genes of each pathway. That is if gene A is in pathway 1 and gene B is in pathway 2, pathway 1 and pathway 2 will have an edge if gene A and gene B have an edge. Note self-edges are not drawn. The value of the test statistic is mapped to node color. Large negative values of the test statistic are orange, values around 0 are white and large positive values are blue. FDR corrected q-values are mapped to the border color of the node. The scale ranges from 0 to 1 with red representing q-values of 0 and white representing q-values of 1. Pathway size is mapped to node size so pathways with more genes are larger. Each pathway node is also linked to its network of genes so the user can see individual gene interactions within a pathway. These can be accessed by right clicking the node -&gt; Nested Networks -&gt; Go To Nested Network. Alternatively, the corresponding nested network has the same name as the pathway so the user can click on the network directly in the Control Panel/Network menu. It is important to note that <code>plot.NetGSA</code> generates default plots and loads in data into Cytoscape, but the user can customize the plots however they like using RCy3 or the Cytoscape GUI directly.
</p>
<p>To save time, the nested networks are not formatted. One can apply NetGSA's formatting using <code>formatPathways</code>
</p>
<p>For custom formatting, the node data that is loaded into Cytoscape includes the pathway results from NetGSA: Pathway size (pSize), p-value (pval), FDR corrected q-value (pFDR), test statistic (teststat) and pathway name. The edge data loaded into Cytoscape is: total number of edges between two pathways (weight). For example weight of 10 between pathway 1 and pathway 2 means there are 10 edges between the genes of pathway 1 and the genes of pathway 2.
</p>
<p>There are two R plots also generated. The first is the legend for Cytoscape. The legend shows the mapping for node color (test statistic) and node border color (FDR corrected q-value). This is generated in R because there does not seem to be a reliable way to plot the legend for the main network (interactions between pathways). The second plot is a plot of the main network created in igraph. It mimics the Cytoscape plot as closely as possible. NetGSA exports the x and y coordinates of the nodes in the Cytoscape layout and uses them in the igraph layout. Custom layouts can be passed to this using the <code>graph_layout</code> argument. The user can also zoom-in on individual pathways in igraph using the <code>zoomPathway</code> function.
</p>
<p>(2) If Cytoscape is not open, the <code>igraph::rglplot</code> function is used to plot the main network (interactions between pathways). The default layout used is <code>layout_on_sphere</code>, but custom layouts can be specified with the <code>graph_layout</code> argument. The other plot generated is the legend since it is difficult to plot on <code>rglplot</code>.
</p>


<h3>Value</h3>

<p>No return value, called for plotting</p>


<h3>Author(s)</h3>

<p>Michael Hellstern
</p>


<h3>References</h3>

<p>Ma, J., Shojaie, A. &amp; Michailidis, G. (2016) Network-based pathway enrichment analysis with incomplete network information. Bioinformatics 32(20):165&ndash;3174. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+NetGSA">NetGSA</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## load the data
data("breastcancer2012_subset")

## consider genes from just 2 pathways
genenames    &lt;- unique(c(pathways[["Adipocytokine signaling pathway"]], 
                         pathways[["Adrenergic signaling in cardiomyocytes"]]))
sx           &lt;- x[match(rownames(x), genenames, nomatch = 0L) &gt; 0L,]

db_edges       &lt;- obtainEdgeList(rownames(sx), databases = c("kegg", "reactome"))
adj_cluster    &lt;- prepareAdjMat(sx, group, databases = db_edges, cluster = TRUE)
out_cluster    &lt;- NetGSA(adj_cluster[["Adj"]], sx, group, 
                         pathways_mat[c(1,2), rownames(sx)], lklMethod = "REHE", sampling = FALSE)
plot(out_cluster)

## End(Not run)
</code></pre>

<hr>
<h2 id='prepareAdjMat'>Construct adjacency matrices from graphite databases and/or user provided network information</h2><span id='topic+prepareAdjMat'></span>

<h3>Description</h3>

<p>Read the network information from any of the graphite databases specified by the user and construct the adjacency matrices needed for NetGSA. This function also allows for clustering. See details for more information</p>


<h3>Usage</h3>

<pre><code class='language-R'>prepareAdjMat(x, group, databases = NULL, cluster = TRUE,
       file_e=NULL, file_ne=NULL, lambda_c=1, penalize_diag=TRUE, eta=0.5)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="prepareAdjMat_+3A_x">x</code></td>
<td>
<p>The <code class="reqn">p \times n</code> data matrix with rows referring to genes and columns to samples. Row names should be unique and have gene ID types appended to them. The id and gene number must be separated by a colon. E.g. &quot;ENTREZID:127550&quot;</p>
</td></tr>
<tr><td><code id="prepareAdjMat_+3A_group">group</code></td>
<td>
<p>Vector of class indicators of length <code class="reqn">n</code>. Identifies the condition for each of the <code class="reqn">n</code> samples</p>
</td></tr>
<tr><td><code id="prepareAdjMat_+3A_databases">databases</code></td>
<td>
<p>(Optional) Either (1) the result of a call to <code>obtainEdgeList</code> or (2) a character vector of graphite databases you wish to search for edges. Since one can search in multiple databases with different identifiers, converts genes using <code>AnnotationDbi::select</code> and convert metabolites using <code>graphite:::metabolites()</code>. Databases are also used to specify non-edges. If <code>NULL</code> no external database information will be used. See Details for more information</p>
</td></tr>
<tr><td><code id="prepareAdjMat_+3A_cluster">cluster</code></td>
<td>
<p>(Optional) Logical indicating whether or not to cluster genes to estimate adjacency matrix. If not specified, set to TRUE if there are &gt; 2,500 genes (p &gt; 2,500). The main use of clustering is to speed up calculation time. If the dimension of the problem, or equivalently the total number of unique genes across all pathways, is large, <code>prepareAdjMat</code> may be slow.
</p>
<p>If clustering is set to TRUE, the 0-1 adjacency matrix is used to detect clusters of genes within the connected components. Once gene clusterings are chosen, the weighted adjacency matrices are estimated for each cluster separately using <code>netEst.undir</code> or <code>netEst.dir</code>. Thus, the adjacency matrix for the full network is block diagonal with the blocks being the adjacency matrices from the clusters. Any edges between clusters are set to 0, so this can be thought of as an approximate weighted adjacency matrix. Six clustering algorithms from the <code>igraph</code> package are considered: <code>cluster_walktrap</code>, <code>cluster_leading_eigen</code>, <code>cluster_fast_greedy</code>, <code>cluster_label_prop</code>, <code>cluster_infomap</code>, and <code>cluster_louvain</code>. Clustering is performed on each connected component of size &gt;1,000 genes. To ensure increases in speed, algorithms which produce a maximum cluster size of &lt; 1,000 genes are considered first. Among those, the algorithm with the smallest edge loss is chosen. If all algorithms have a maximum cluster size &gt; 1,000 genes the one with the smallest maximum cluster size is chosen. Edge loss is defined as the number of edges between genes of different clusters. These edges are &quot;lost&quot; since they are set to 0 in the block diagonal adjacency matrix.
</p>
<p>If clustering is set to FALSE, the 0-1 adjacency matrix is used to detect connected components and the weighted adjacency matrices are estimated for each connected component.
</p>
<p>Singleton clusters are combined into one cluster. This should not affect performance much since the gene in a singleton cluster should not have any edges to other genes.
</p>
</td></tr>
<tr><td><code id="prepareAdjMat_+3A_file_e">file_e</code></td>
<td>
<p>(Optional) The name of the file which the list of edges is to read from. This file is read in with <code>data.table::fread</code>. Must have 4 columns in the following order. The columns do not necessarily need to be named, but they must be in this specific order:
</p>

<ul>
<li><p> 1st column - Source gene (base_gene_src), e.g. &quot;7534&quot;&quot;
</p>
</li>
<li><p> 2nd column - Gene identifier of the source gene (base_id_src), e.g. &quot;ENTREZID&quot;
</p>
</li>
<li><p> 3rd column - Destination gene (base_gene_dest), e.g. &quot;8607&quot;
</p>
</li>
<li><p> 4th column - Gene identifier of the destination gene (base_id_dest) e.g. &quot;UNIPROT&quot; 
</p>
</li></ul>

<p>This information cannot conflict with the user specified non-edges. That is, one cannot have the same edge in <code>file_e</code> and <code>file_ne</code>. In the case where the graph is undirected everything will be converted to an undirected edge or non-edge. Thus if the user specifies A-&gt;B as a directed non-edge it will be changed to an undirected non-edge if the graph is undirected. See Details for more information.
</p>
</td></tr>
<tr><td><code id="prepareAdjMat_+3A_file_ne">file_ne</code></td>
<td>
<p>(Optional) The name of the file which the list of non-edges is to read from. This file is read in with <code>data.table::fread</code>. The edges in this file are negative in the sense that the corresponding vertices are not connected. Format of the file must be the same as <code>file_e</code>. Again, each observation is assumed to be a directed edge. Thus for a negative undirected edge, input two separate negative edges.
</p>
<p>In the case of conflicting information between <code>file_ne</code> and edges identified in a database, user non-edges are used. That is if the user specifies A-&gt;B in <code>file_ne</code>, but there is an edge between A-&gt;B in KEGG, the information in KEGG will be ignored and A-&gt;B will be treated as a non-edge. In the case where the graph is undirected everything will be converted to an undirected edge or non-edge. Thus if the user specifies A-&gt;B as a directed non-edge it will be changed to an undirected non-edge if the graph is undirected. See Details for more information.
</p>
</td></tr>
<tr><td><code id="prepareAdjMat_+3A_lambda_c">lambda_c</code></td>
<td>
<p>(Non-negative) a vector or constant. <code>lambda_c</code> is multiplied by a constant depending on the data to determine the actual tuning parameter, <code>lambda</code>, used in estimating the network. If <code>lambda_c</code> is a vector, the optimal <code>lambda</code> will be chosen from this vector using <code><a href="#topic+bic.netEst.undir">bic.netEst.undir</a></code>. Note that <code>lambda</code> is only used if the network is undirected. If the network is directed, the default value in <code><a href="#topic+netEst.dir">netEst.dir</a></code> is used instead . By default, <code>lambda_c</code> is set to 1. See <code><a href="#topic+netEst.undir">netEst.undir</a></code> and <code><a href="#topic+netEst.dir">netEst.dir</a></code> for more details.</p>
</td></tr>
<tr><td><code id="prepareAdjMat_+3A_penalize_diag">penalize_diag</code></td>
<td>
<p>Logical. Whether or not to penalize diagonal entries when estimating weighted adjacency matrix. If TRUE a small penalty is used, otherwise no penalty is used.</p>
</td></tr>
<tr><td><code id="prepareAdjMat_+3A_eta">eta</code></td>
<td>
<p>(Non-negative) a small constant needed for estimating the edge weights. By default, <code>eta</code> is set to 0.5. See <code><a href="#topic+netEst.undir">netEst.undir</a></code> for more details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>prepareAdjMat</code> accepts both network information from user specified sources as well as a list of graphite databases to search for edges in. <code>prepareAdjMat</code> calculates the 0-1 adjacency matrices and runs <code><a href="#topic+netEst.undir">netEst.undir</a></code> or <code><a href="#topic+netEst.dir">netEst.dir</a></code> if the graph is undirected or directed. 
</p>
<p>When searching for network information, <code>prepareAdjMat</code> makes some important assumptions about edges and non-edges. As already stated, the first is that in the case of conflicting information, user specified non-edges are given precedence. 
</p>
<p><code>prepareAdjMat</code> uses <code><a href="#topic+obtainEdgeList">obtainEdgeList</a></code> to standardize and search the <code>graphite</code> databases for edges. For more information see <code>?obtainEdgeList</code>. <code>prepareAdjMat</code> also uses database information to identify non-edges. If two genes are identified in the <code>databases</code> edges but there is no edge between them this will be coded as a non-edge. The rationale is that if there was an edge between these two genes it would be present.
</p>
<p><code>prepareAdjMat</code> assumes no information about genes not identified in <code>databases</code> edgelists. That is, if the user passes gene A, but gene A is not found in any of the edges in <code>databases</code> no information about Gene A is assumed. Gene A will have neither edges nor non-edges.
</p>
<p>Once all the network and clustering information has been compiled, <code>prepareAdjMat</code> estimates the network. <code>prepareAdjMat</code> will automatically detect directed graphs, rearrange them to the correct order and use <code>netEst.dir</code> to estimate the network. When the graph is undirected <code>netEst.undir</code> will be used. For more information on these methods see <code>?netEst.dir</code> and <code>?netEst.undir</code>.
</p>
<p>Importantly, <code>prepareAdjMat</code> returns the list of weighted adjacency matrices to be used as an input in <code>NetGSA</code>.
</p>


<h3>Value</h3>

<p>A list with components
</p>
<table role = "presentation">
<tr><td><code>Adj</code></td>
<td>
<p>A list of weighted adjacency matrices estimated from either <code>netEst.undir</code> or <code>netEst.dir</code>. That is <code>length(Adj) = length(unique(group))</code>. One list of weighted adjacency matrix will be returned for each condition in group. If cluster = TRUE is specified, the length of the list of adjacency matrices for each condition will be the same length as the number of clusters. The structure of Adj is Adj[[condition_number]][[cluster_adj_matrix]]. Note that even when <code>cluster = FALSE</code> the connected components are used as clusters. The last element which is needed for plotting and is passed through to the output of <code>NetGSA</code> is <code>edgelist</code>.</p>
</td></tr>
<tr><td><code>invcov</code></td>
<td>
<p>A list of inverse covariance matrices estimated from either <code>netEst.undir</code> or <code>netEst.dir</code>. That is <code>length(invcov) = length(unique(group))</code>. One list of inverse covariance matrix will be returned for each condition in group. If cluster = TRUE is specified, the length of the list of inverse covariance matrices for each condition will be the same length as the number of clusters. The structure of invcov is invcov[[condition_number]][[cluster_adj_matrix]]</p>
</td></tr>
<tr><td><code>lambda</code></td>
<td>
<p>A list of values of tuning parameters used for each condition in <code>group</code>. If cluster = TRUE is specified, the length of the list of tuning parameters for each condition will be the same length as the number of clusters.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Michael Hellstern
</p>


<h3>References</h3>

<p>Ma, J., Shojaie, A. &amp; Michailidis, G. (2016) Network-based pathway enrichment analysis with incomplete network information. Bioinformatics 32(20):165&ndash;3174. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+NetGSA">NetGSA</a></code>, <code><a href="#topic+netEst.dir">netEst.dir</a></code>, <code><a href="#topic+netEst.undir">netEst.undir</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## load the data
data("breastcancer2012_subset")

## consider genes from just 2 pathways
genenames    &lt;- unique(c(pathways[[1]], pathways[[2]]))
sx           &lt;- x[match(rownames(x), genenames, nomatch = 0L) &gt; 0L,]

adj_cluster    &lt;- prepareAdjMat(sx, group, 
                                databases = c("kegg", "reactome"), 
                                cluster = TRUE)
adj_no_cluster &lt;- prepareAdjMat(sx, group, 
                                databases = c("kegg", "reactome"), 
                                cluster = FALSE)

</code></pre>

<hr>
<h2 id='stackDatabases'>Combine edges from databases into a data.table</h2><span id='topic+stackDatabases'></span>

<h3>Description</h3>

<p>Retrieves edges from specified databases and stacks them into one data.table.This is a helper function in <code>prepareAdjMat</code> and should not be called by the user.</p>


<h3>Usage</h3>

<pre><code class='language-R'>stackDatabases(databases)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="stackDatabases_+3A_databases">databases</code></td>
<td>
<p>Character vector of databases to compile. Should be one of the options from hspaiens in <code>graphite::pathwayDatabases()</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function compiles all the edges from all databases specified into one data.table
</p>


<h3>Value</h3>

<p>A data.table with columns:
</p>
<table role = "presentation">
<tr><td><code>database</code></td>
<td>
<p>Which database the edge comes from</p>
</td></tr>
<tr><td><code>src</code></td>
<td>
<p>Source gene</p>
</td></tr>
<tr><td><code>src_type</code></td>
<td>
<p>Source gene identifier type</p>
</td></tr>
<tr><td><code>dest</code></td>
<td>
<p>Destination gene</p>
</td></tr>
<tr><td><code>dest_type</code></td>
<td>
<p>Destination gene identifier type</p>
</td></tr>
<tr><td><code>direction</code></td>
<td>
<p>Direction of edge. Either Directed or Undirected</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Michael Hellstern
</p>


<h3>References</h3>

<p>Ma, J., Shojaie, A. &amp; Michailidis, G. (2016) Network-based pathway enrichment analysis with incomplete network information. Bioinformatics 32(20):165&ndash;3174. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+obtainEdgeList">obtainEdgeList</a></code>
</p>

<hr>
<h2 id='x'>Data matrix p by n</h2><span id='topic+x'></span>

<h3>Description</h3>

<p>Data matrix p by n
</p>


<h3>Usage</h3>

<pre><code class='language-R'>x
</code></pre>


<h3>Format</h3>

<p>An object of class <code>matrix</code> (inherits from <code>array</code>) with 250 rows and 520 columns.
</p>

<hr>
<h2 id='zoomPathway'>Zoom in on pathway in igraph</h2><span id='topic+zoomPathway'></span>

<h3>Description</h3>

<p>Plots the gene to gene interactions for a given pathway in igraph.</p>


<h3>Usage</h3>

<pre><code class='language-R'>zoomPathway(x, pway, graph_layout = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="zoomPathway_+3A_x">x</code></td>
<td>
<p>A NetGSA object returned from calling <code>NetGSA()</code></p>
</td></tr>
<tr><td><code id="zoomPathway_+3A_pway">pway</code></td>
<td>
<p>Name of pathway to plot</p>
</td></tr>
<tr><td><code id="zoomPathway_+3A_graph_layout">graph_layout</code></td>
<td>
<p>(Optional) Layout function to pass to igraph plots. This function should only take one parameter (an igraph object). For example one might create a custom layout by setting the spring.length and spring.constant with: <code>my_layout &lt;- function(graph) layout_with_graphopt(graph = graph, spring.length = 1000, spring.constant = 0.00004)</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Generates igraph plot for gene to gene interactions for a given pathway
</p>


<h3>Value</h3>

<p>No return value, called for side effects
</p>


<h3>Author(s)</h3>

<p>Michael Hellstern
</p>


<h3>References</h3>

<p>Ma, J., Shojaie, A. &amp; Michailidis, G. (2016) Network-based pathway enrichment analysis with incomplete network information. Bioinformatics 32(20):165&ndash;3174. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.NetGSA">plot.NetGSA</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## load the data
data("breastcancer2012_subset")

## consider genes from just 2 pathways
genenames    &lt;- unique(c(pathways[["Adipocytokine signaling pathway"]], 
                         pathways[["Adrenergic signaling in cardiomyocytes"]]))
sx           &lt;- x[match(rownames(x), genenames, nomatch = 0L) &gt; 0L,]

db_edges       &lt;- obtainEdgeList(rownames(sx), databases = c("kegg", "reactome"))
adj_cluster    &lt;- prepareAdjMat(sx, group, databases = db_edges, cluster = TRUE)
out_cluster    &lt;- NetGSA(adj_cluster[["Adj"]], sx, group, 
                         pathways_mat[c(1,2), rownames(sx)], lklMethod = "REHE", sampling = FALSE)
plot(out_cluster)
my_layout &lt;- function(graph) layout_with_graphopt(graph = graph, 
                                                  spring.length = 1000, 
                                                  spring.constant = 0.00004)
zoomPathway(out_cluster, "Adipocytokine signaling pathway", my_layout)

## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
