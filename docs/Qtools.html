<!DOCTYPE html><html><head><title>Help for package Qtools</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {Qtools}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#ao'>
<p>Transformations</p></a></li>
<li><a href='#Chemistry'><p>A-level Chemistry Scores</p></a></li>
<li><a href='#cmidecdf'>
<p>Mid-distribution Functions</p></a></li>
<li><a href='#coef.midrq'>
<p>Extract Coefficients</p></a></li>
<li><a href='#coef.qrr'>
<p>Extract Coefficients</p></a></li>
<li><a href='#coef.rq.counts'>
<p>Extract Coefficients</p></a></li>
<li><a href='#coef.rqt'>
<p>Extract Coefficients</p></a></li>
<li><a href='#confint.midquantile'>
<p>Mid-distribution Functions</p></a></li>
<li><a href='#dqc'>
<p>Directional Quantile Classification</p></a></li>
<li><a href='#dqcControl'>
<p>Control parameters for dqc estimation</p></a></li>
<li><a href='#esterase'><p>Esterase Essay Data</p></a></li>
<li><a href='#fitted.midrq'>
<p>Extract Fitted Values from Mid-Quantile Transformation Models</p></a></li>
<li><a href='#fitted.rq.counts'>
<p>Extract Fitted Values from Quantile Regression Models for Counts</p></a></li>
<li><a href='#fitted.rqt'>
<p>Extract Fitted Values from Quantile Regression Transformation Models</p></a></li>
<li><a href='#GOFTest'>
<p>Goodness-of-Fit Tests for Quantile Regression Models</p></a></li>
<li><a href='#KhmaladzeFormat'>
<p>Khmaladze Test</p></a></li>
<li><a href='#labor'><p>Labor Pain Data</p></a></li>
<li><a href='#maref.rqt'>
<p>Marginal Effects</p></a></li>
<li><a href='#mice.impute.rq'>
<p>QR-based Multiple Imputation</p></a></li>
<li><a href='#midq2q'>
<p>Recover Ordinary Conditional Quantiles from Conditional Mid-Quantiles</p></a></li>
<li><a href='#midquantile'>
<p>Mid-distribution Functions</p></a></li>
<li><a href='#midrq'>
<p>Mid-Quantile Regression for Discrete Responses</p></a></li>
<li><a href='#midrqControl'>
<p>Control parameters for midrq estimation</p></a></li>
<li><a href='#nlControl'>
<p>Control parameters for gradient search estimation</p></a></li>
<li><a href='#Orthodont'><p>Growth curve data on an orthdontic measurement</p></a></li>
<li><a href='#plot.midq2q'>
<p>Plot Quantile Functions</p></a></li>
<li><a href='#plot.midquantile'>
<p>Plot Mid-distribution Functions</p></a></li>
<li><a href='#plot.qlss'>
<p>Quantile-based Summary Statistics for Location, Scale and Shape</p></a></li>
<li><a href='#predict.midrq'>
<p>Predictions from Mid-Quantile Regression Models</p></a></li>
<li><a href='#predict.qlss'>
<p>Predictions from Conditional LSS Objects</p></a></li>
<li><a href='#predict.qrr'>
<p>Predictions from Quantile Ratio Regression Models</p></a></li>
<li><a href='#predict.rq.counts'>
<p>Predictions from rq.counts Objects</p></a></li>
<li><a href='#predict.rqt'>
<p>Predictions from Quantile Regression Transformation Models</p></a></li>
<li><a href='#predict.rrq'>
<p>Predictions from Restricted Quantile Regression Models</p></a></li>
<li><a href='#print.cmidecdf'>
<p>Print Mid-distribution Functions</p></a></li>
<li><a href='#print.dqc'>
<p>Print Directional Quantile Classification Objects</p></a></li>
<li><a href='#print.GOFTest'>
<p>Print Goodness-of-Fit Test for Quantile Regression Models</p></a></li>
<li><a href='#print.midquantile'>
<p>Print Mid-distribution Functions</p></a></li>
<li><a href='#print.midrq'>
<p>Print Mid-Quantile Models</p></a></li>
<li><a href='#print.qlss'>
<p>Print Quantile-based Summary Statistics for Location, Scale and Shape</p></a></li>
<li><a href='#print.qrr'>
<p>Print Quantile Ratio Regression Models</p></a></li>
<li><a href='#print.rq.counts'>
<p>Print rq.counts</p></a></li>
<li><a href='#print.rqt'>
<p>Print Transformation Models</p></a></li>
<li><a href='#print.rrq'>
<p>Print Restricted Quantile Regression Models</p></a></li>
<li><a href='#qexact'>
<p>Exact Confidence Intervals for Quantiles</p></a></li>
<li><a href='#qlss'>
<p>Quantile-based Summary Statistics for Location, Scale and Shape</p></a></li>
<li><a href='#qrr'>
<p>Quantile Ratio Regression</p></a></li>
<li><a href='#Qtools-internal'><p>Internal Qtools objects</p></a></li>
<li><a href='#Qtools-package'><p>Utilities for Quantilies</p></a></li>
<li><a href='#residuals.midrq'>
<p>Residuals from a midrq Objects</p></a></li>
<li><a href='#residuals.rq.counts'>
<p>Residuals from an rq.counts Object</p></a></li>
<li><a href='#residuals.rqt'>
<p>Residuals from an rqt Objects</p></a></li>
<li><a href='#rq.counts'>
<p>Quantile Regression for Counts</p></a></li>
<li><a href='#rrq'>
<p>Restricted Regression Quantiles</p></a></li>
<li><a href='#sparsity.rqt'>
<p>Sparsity Estimation</p></a></li>
<li><a href='#summary.midrq'>
<p>Summary for Mid-Quantile Regression Models</p></a></li>
<li><a href='#summary.qrr'>
<p>Summary for Quantile Ratio Regression Models</p></a></li>
<li><a href='#summary.rqt'>
<p>Summary for Quantile Regression Tranformation Models</p></a></li>
<li><a href='#summary.rrq'>
<p>Summary for Restricted Quantile Regression Models</p></a></li>
<li><a href='#tsrq'>
<p>Quantile Regression Transformation Models</p></a></li>
<li><a href='#vcov.midrq'>
<p>Variance-Covariance Matrix for a Fitted Mid-Quantile Regression Model Object</p></a></li>
<li><a href='#vcov.qrr'>
<p>Variance-Covariance Matrix for a Fitted Quantile Ratio Regression Model Object</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Utilities for Quantiles</td>
</tr>
<tr>
<td>Version:</td>
<td>1.5.9</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-10-28</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Marco Geraci &lt;marco.geraci@uniroma1.it&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>boot, conquer, glmx, graphics, grDevices, gtools, MASS,
Matrix, np, numDeriv (&ge; 2016.8-1), quantdr, quantreg, Rcpp (&ge;
0.12.13), stats, utils</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, mice, rmarkdown, survey</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Description:</td>
<td>Functions for unconditional and conditional quantiles. These
    include methods for transformation-based quantile regression,
    quantile-based measures of location, scale and shape, methods for quantiles
    of discrete variables, quantile-based multiple imputation, restricted
    quantile regression, directional quantile classification, and quantile
	ratio regression.
	A vignette is given in Geraci (2016, The R Journal) &lt;<a href="https://doi.org/10.32614%2FRJ-2016-037">doi:10.32614/RJ-2016-037</a>&gt; and included in the package.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-10-28 13:08:20 UTC; marco</td>
</tr>
<tr>
<td>Author:</td>
<td>Marco Geraci <a href="https://orcid.org/0000-0002-6311-8685"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cph, cre],
  Alessio Farcomeni <a href="https://orcid.org/0000-0002-7104-5826"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb] (Contributions to midrq and qrr code),
  Cinzia Viroli <a href="https://orcid.org/0000-0002-3278-5266"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb] (Contributions to dqc code)</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-10-28 15:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='ao'>
Transformations
</h2><span id='topic+bc'></span><span id='topic+mcjI'></span><span id='topic+mcjII'></span><span id='topic+invao'></span><span id='topic+invbc'></span><span id='topic+invmcjI'></span><span id='topic+invmcjII'></span><span id='topic+ao'></span>

<h3>Description</h3>

<p>Functions used in quantile regression transformation models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ao(theta, lambda, symm = TRUE, omega = 0.001)
invao(x, lambda, symm = TRUE, replace = TRUE)
bc(x, lambda)
invbc(x, lambda, replace = TRUE)
mcjI(x, lambda, symm = TRUE, dbounded = FALSE, omega = 0.001)
invmcjI(x, lambda, symm = TRUE, dbounded = FALSE)
mcjII(x, lambda, delta, dbounded = FALSE, omega = 0.001)
invmcjII(x, lambda, delta, dbounded = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ao_+3A_x">x</code>, <code id="ao_+3A_theta">theta</code></td>
<td>

<p>numeric vector of singly (<code>x</code>) or doubly (<code>theta</code>) bounded observations; <code>theta</code> must be between 0 and 1 (see <code><a href="#topic+map">map</a></code> to map generic [a,b] intervals to [0,1]).
</p>
</td></tr>
<tr><td><code id="ao_+3A_lambda">lambda</code>, <code id="ao_+3A_delta">delta</code></td>
<td>

<p>transformation parameters.
</p>
</td></tr>
<tr><td><code id="ao_+3A_symm">symm</code></td>
<td>

<p>logical flag. If <code>TRUE</code> (default) a symmetric transformation is used.
</p>
</td></tr>
<tr><td><code id="ao_+3A_dbounded">dbounded</code></td>
<td>

<p>logical flag. If <code>TRUE</code> the argument <code>x</code> is assumed to be bounded between 0 and 1.
</p>
</td></tr>
<tr><td><code id="ao_+3A_omega">omega</code></td>
<td>

<p>small constant to avoid numerical problems when <code>theta</code> is exactly 0 or 1.
</p>
</td></tr>
<tr><td><code id="ao_+3A_replace">replace</code></td>
<td>

<p>logical flag. If <code>TRUE</code> (default), values that are outside the admissible range after the Box-Cox or the Aranda-Ordaz back-transformations are replaced by the range bounds.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions transform (back-transform) <code>x</code> or <code>theta</code> conditional on the parameters <code>lambda</code> and <code>theta</code>, using the Box&ndash;Cox (<code>bc</code>), Aranda-Ordaz (<code>ao</code>), Proposal I (<code>mcjI</code>) and Proposal II (<code>mcjII</code>) transformations. 
</p>


<h3>Value</h3>

<p>Transformed or back-transformed values.
</p>


<h3>Author(s)</h3>

<p>Marco Geraci
</p>


<h3>References</h3>

<p>Aranda-Ordaz FJ. On two families of transformations to additivity for binary response data. Biometrika 1981;68(2):357-363.
</p>
<p>Box GEP, Cox DR. An analysis of transformations. Journal of the Royal Statistical Society Series B-Statistical Methodology 1964;26(2):211-252.
</p>
<p>Dehbi H-M, Cortina-Borja M, and Geraci M. Aranda-Ordaz quantile regression for student performance assessment. Journal of Applied Statistics. 2016;43(1):58-71.
</p>
<p>Geraci M and Jones MC. Improved transformation-based quantile regression. Canadian Journal of Statistics 2015;43(1):118-132.
</p>
<p>Jones MC. Connecting distributions with power tails on the real line, the half line and the interval. International Statistical Review 2007;75(1):58-69.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+tsrq">tsrq</a></code>, <code><a href="#topic+tsrq2">tsrq2</a></code>, <code><a href="#topic+rcrq">rcrq</a></code>, <code><a href="#topic+nlrq2">nlrq2</a></code>
</p>

<hr>
<h2 id='Chemistry'>A-level Chemistry Scores</h2><span id='topic+Chemistry'></span>

<h3>Description</h3>

<p>The <code>Chemistry</code> data frame has 31022 rows and 7 columns of the
A-level scores in Chemistry for England and Wales students, 1997.
</p>


<h3>Format</h3>

<p>This data frame contains the following columns:
</p>

<dl>
<dt>lea</dt><dd>
<p>school district ID.
</p>
</dd>
<dt>school</dt><dd>
<p>school ID.
</p>
</dd>
<dt>id</dt><dd>
<p>subject ID.
</p>
</dd>
<dt>score</dt><dd>
<p>a numeric vector of A-level scores in Chemistry.
</p>
</dd>
<dt>sex</dt><dd>
<p>a factor with levels
<code>male</code> and
<code>female</code> 
</p>
</dd>
<dt>age</dt><dd>
<p>a numeric vector of ages of the subjects (months).
</p>
</dd>
<dt>gcse</dt><dd>
<p>a numeric vector of average GCSE scores.
</p>
</dd>
</dl>



<h3>Source</h3>

<p>Fielding, A., Yang, M., and Goldstein, H. (2003) &ldquo;Multilevel ordinal models
for examination grades&rdquo;. Statistical Modelling, 3, 127&ndash;53.
</p>

<hr>
<h2 id='cmidecdf'>
Mid-distribution Functions
</h2><span id='topic+cmidecdf.fit'></span><span id='topic+cmidecdf'></span>

<h3>Description</h3>

<p>Compute conditional mid-cumulative probabilities
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cmidecdf(formula, data, ecdf_est = "npc", npc_args = list(),
	theta = NULL, subset, weights, na.action,
	contrasts = NULL)
cmidecdf.fit(x, y, intercept, ecdf_est, npc_args = list(),
	theta = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cmidecdf_+3A_formula">formula</code></td>
<td>

<p>an object of class &quot;<code><a href="stats.html#topic+formula">formula</a></code>&quot; (or one that can be coerced to that class): a symbolic description of the model to be fitted. The details of model specification are given under &lsquo;Details&rsquo;.
</p>
</td></tr>
<tr><td><code id="cmidecdf_+3A_data">data</code></td>
<td>

<p>an optional data frame, list or environment (or object coercible by as.data.frame to a data frame) containing the variables in the model. By default the variables are taken from the environment from which the call is made.
</p>
</td></tr>
<tr><td><code id="cmidecdf_+3A_ecdf_est">ecdf_est</code></td>
<td>

<p>estimator of the (standard) conditional cumulative distribution. The options are: <code>npc</code> (default) for kernel estimator (Li and Racine, 2008); <code>logit</code>, <code>probit</code>, <code>cloglog</code> for binomial regression; <code>ao</code> for Aranda-Ordaz binomial regression.
</p>
</td></tr>
<tr><td><code id="cmidecdf_+3A_npc_args">npc_args</code></td>
<td>

<p>named list of arguments for <code>npcdistbw</code> when <code>ecdf_est = npc</code>.
</p>
</td></tr>
<tr><td><code id="cmidecdf_+3A_theta">theta</code></td>
<td>

<p>values of the Aranda-Ordaz transformation parameter for grid search when <code>ecdf_est = "ao"</code>.
</p>
</td></tr>
<tr><td><code id="cmidecdf_+3A_subset">subset</code></td>
<td>

<p>an optional vector specifying a subset of observations to be used in the fitting process.
</p>
</td></tr>
<tr><td><code id="cmidecdf_+3A_weights">weights</code></td>
<td>

<p>an optional vector of weights to be used in the fitting process. Not currently implemented.
</p>
</td></tr>
<tr><td><code id="cmidecdf_+3A_na.action">na.action</code></td>
<td>

<p>a function which indicates what should happen when the data contain <code>NA</code>s.
</p>
</td></tr>
<tr><td><code id="cmidecdf_+3A_contrasts">contrasts</code></td>
<td>

<p>an optional list. See the contrasts.arg of <code><a href="stats.html#topic+model.matrix.default">model.matrix.default</a></code>.
</p>
</td></tr>
<tr><td><code id="cmidecdf_+3A_x">x</code></td>
<td>

<p>design matrix of dimension <code class="reqn">n * p</code>.
</p>
</td></tr>
<tr><td><code id="cmidecdf_+3A_y">y</code></td>
<td>

<p>vector of observations of length <code class="reqn">n</code>.
</p>
</td></tr>
<tr><td><code id="cmidecdf_+3A_intercept">intercept</code></td>
<td>

<p>logical flag. Does <code>x</code> include a vector of ones?
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code><a href="base.html#topic+class">class</a></code> <code>cmidecdf</code> with mid-cumulative probabilities. This is a list that contains:
</p>
<table>
<tr><td><code>G</code></td>
<td>
<p>Estimated conditional mid-probabilities. This is a <code class="reqn">n * k</code> matrix, where <code class="reqn">n</code> is the sample size and <code class="reqn">k</code> is the number of unique values of <code>y</code>.</p>
</td></tr>
<tr><td><code>Fhat</code></td>
<td>
<p>Estimated (standard) cumulative probabilities.</p>
</td></tr>
<tr><td><code>Fse</code></td>
<td>
<p>Standard error for Fhat.</p>
</td></tr>
<tr><td><code>yo</code></td>
<td>
<p>unique values of <code>y</code>.</p>
</td></tr>
<tr><td><code>bw</code></td>
<td>
<p><code>npcdistbw</code> object.</p>
</td></tr>
<tr><td><code>ecdf_est</code></td>
<td>
<p>estimator used.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Marco Geraci with contributions from Alessio Farcomeni
</p>


<h3>References</h3>

<p>Geraci, M. and A. Farcomeni. Mid-quantile regression for discrete responses. arXiv:1907.01945 [stat.ME]. URL: <a href="https://arxiv.org/abs/1907.01945">https://arxiv.org/abs/1907.01945</a>.
</p>
<p>Li, Q. and J. S. Racine (2008). Nonparametric estimation of conditional cdf and quantile functions with mixed categorical and continuous data. Journal of Business and Economic Statistics 26(4), 423-434.
</p>
<p>Peracchi, F. (2002). On estimating conditional quantiles and distribution functions. Computational Statistics and Data Analysis 38(4), 433-447.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+midecdf">midecdf</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
n &lt;- 100
x &lt;- rnorm(n, 0, 3)
y &lt;- floor(1 + 2*x) + sample(1:5, n, replace = TRUE)
cmidecdf(y ~ x, ecdf_est = "logit")

## End(Not run)

</code></pre>

<hr>
<h2 id='coef.midrq'>
Extract Coefficients
</h2><span id='topic+coefficients.midrq'></span><span id='topic+coef.midrq'></span>

<h3>Description</h3>

<p><code>coef</code> extracts model coefficients from <code>midrq</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'midrq'
coef(object, ...)
## S3 method for class 'midrq'
coefficients(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coef.midrq_+3A_object">object</code></td>
<td>

<p>an <code>midrq</code> object.
</p>
</td></tr>
<tr><td><code id="coef.midrq_+3A_...">...</code></td>
<td>

<p>not used.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector for single quantiles or a matrix for multiple quantiles. 
</p>


<h3>Author(s)</h3>

<p>Marco Geraci
</p>


<h3>See Also</h3>

<p><code><a href="#topic+midrq">midrq</a></code>
</p>

<hr>
<h2 id='coef.qrr'>
Extract Coefficients
</h2><span id='topic+coefficients.qrr'></span><span id='topic+coef.qrr'></span>

<h3>Description</h3>

<p><code>coef</code> extracts model coefficients from <code>qrr</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'qrr'
coef(object, ...)
## S3 method for class 'qrr'
coefficients(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coef.qrr_+3A_object">object</code></td>
<td>

<p>an object of <code><a href="base.html#topic+class">class</a></code> <code>qrr</code>.
</p>
</td></tr>
<tr><td><code id="coef.qrr_+3A_...">...</code></td>
<td>

<p>not used.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of estimated coefficients. 
</p>


<h3>Author(s)</h3>

<p>Marco Geraci
</p>


<h3>See Also</h3>

<p><code><a href="#topic+qrr">qrr</a></code>
</p>

<hr>
<h2 id='coef.rq.counts'>
Extract Coefficients
</h2><span id='topic+coefficients.rq.counts'></span><span id='topic+coef.rq.counts'></span>

<h3>Description</h3>

<p><code>coef</code> extracts model coefficients from <code>rq.counts</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'rq.counts'
coef(object, ...)
## S3 method for class 'rq.counts'
coefficients(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coef.rq.counts_+3A_object">object</code></td>
<td>

<p>an <code>rq.counts</code> object.
</p>
</td></tr>
<tr><td><code id="coef.rq.counts_+3A_...">...</code></td>
<td>

<p>not used.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector for single quantiles or a matrix for multiple quantiles. 
</p>


<h3>Author(s)</h3>

<p>Marco Geraci
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rq.counts">rq.counts</a></code>
</p>

<hr>
<h2 id='coef.rqt'>
Extract Coefficients
</h2><span id='topic+coefficients.rqt'></span><span id='topic+coef.rqt'></span>

<h3>Description</h3>

<p><code>coef</code> extracts model coefficients from <code>rqt</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'rqt'
coef(object, all = FALSE, ...)
## S3 method for class 'rqt'
coefficients(object, all = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coef.rqt_+3A_object">object</code></td>
<td>

<p>an <code>rqt</code> object.
</p>
</td></tr>
<tr><td><code id="coef.rqt_+3A_all">all</code></td>
<td>

<p>logical flag. If <code>FALSE</code> (default), only the regression coefficients are returned. If <code>TRUE</code>, the transformation parameter(s) too is returned.
</p>
</td></tr>
<tr><td><code id="coef.rqt_+3A_...">...</code></td>
<td>

<p>not used.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector for single quantiles or a matrix for multiple quantiles. 
</p>


<h3>Author(s)</h3>

<p>Marco Geraci
</p>


<h3>See Also</h3>

<p><code><a href="#topic+tsrq">tsrq</a></code>
</p>

<hr>
<h2 id='confint.midquantile'>
Mid-distribution Functions
</h2><span id='topic+confint.midquantile'></span>

<h3>Description</h3>

<p>Compute mid-quantiles confidence intervals 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'midquantile'
confint(object, parm = NULL, level = 0.95, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="confint.midquantile_+3A_object">object</code></td>
<td>

<p>an object of class <code>midquantile</code>.
</p>
</td></tr>
<tr><td><code id="confint.midquantile_+3A_parm">parm</code></td>
<td>

<p>not used (included for consistency with <code><a href="stats.html#topic+confint.default">confint.default</a></code>).
</p>
</td></tr>
<tr><td><code id="confint.midquantile_+3A_level">level</code></td>
<td>

<p>nominal coverage level of the confidence interval.
</p>
</td></tr>
<tr><td><code id="confint.midquantile_+3A_...">...</code></td>
<td>

<p>not used.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Marco Geraci
</p>


<h3>References</h3>

<p>Ma Y., Genton M., and Parzen E. Asymptotic properties of sample quantiles of discrete distributions. Annals of the Institute of Statistical Mathematics 2011;63(2):227-243
</p>
<p>Parzen E. Quantile probability and statistical data modeling. Statistical Science 2004;19(4):652-62.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- rpois(100, lambda = 3)
mq &lt;- midquantile(x)
confint(mq, level = 0.95)

# print standard errors
attributes(confint(mq, level = 0.95))$stderr

</code></pre>

<hr>
<h2 id='dqc'>
Directional Quantile Classification</h2><span id='topic+dqc.fit'></span><span id='topic+dqc'></span>

<h3>Description</h3>

<p>This function is used to classify multivariate observations by means of directional quantiles.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dqc(formula, data, df.test, subset, weights, na.action, control = list(),
	fit = TRUE)
dqc.fit(x, z, y, control)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dqc_+3A_formula">formula</code></td>
<td>

<p>an object of class <code><a href="stats.html#topic+formula">formula</a></code>: a two-sided formula of the form <code>y ~ x1 + ... + xn</code> where <code>y</code> represents the groups (i.e., labels) for the observations and <code>x1</code>, ..., <code>xn</code> are the variables used for classification.
</p>
</td></tr>
<tr><td><code id="dqc_+3A_data">data</code></td>
<td>

<p>an optional data frame, list or environment (or object coercible by as.data.frame to a data frame) containing the variables for classification (training). If not found in data, the variables are taken from environment(formula), typically the environment from which <code>dqc</code> is called.
</p>
</td></tr>
<tr><td><code id="dqc_+3A_df.test">df.test</code></td>
<td>

<p>a required data frame, list or environment (or object coercible by as.data.frame to a data frame) containing the variables for prediction.
</p>
</td></tr>
<tr><td><code id="dqc_+3A_subset">subset</code></td>
<td>

<p>an optional vector specifying a subset of observations to be used in the fitting process.
</p>
</td></tr>
<tr><td><code id="dqc_+3A_weights">weights</code></td>
<td>

<p>an optional vector of weights to be used in the fitting process.
</p>
</td></tr>
<tr><td><code id="dqc_+3A_na.action">na.action</code></td>
<td>

<p>a function which indicates what should happen when the data contain <code>NA</code>s.
</p>
</td></tr>
<tr><td><code id="dqc_+3A_control">control</code></td>
<td>

<p>list of control parameters of the fitting process. See <code><a href="#topic+dqcControl">dqcControl</a></code>.
</p>
</td></tr>
<tr><td><code id="dqc_+3A_fit">fit</code></td>
<td>

<p>logical flag. If <code>FALSE</code> the function returns a list of arguments for fitting.
</p>
</td></tr>
<tr><td><code id="dqc_+3A_x">x</code></td>
<td>

<p>design matrix of dimension <code class="reqn">nx * p</code> for training.
</p>
</td></tr>
<tr><td><code id="dqc_+3A_z">z</code></td>
<td>

<p>design matrix of dimension <code class="reqn">nz * p</code> for prediction.
</p>
</td></tr>
<tr><td><code id="dqc_+3A_y">y</code></td>
<td>

<p>vector of labels of length <code class="reqn">nx</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Directional quantile classification is described in the article by Viroli et al (2020).</p>


<h3>Value</h3>

<p>a list of class <code>dqc</code> containing the following components
</p>
<table>
<tr><td><code>call</code></td>
<td>
<p>the matched call.</p>
</td></tr>
<tr><td><code>ans</code></td>
<td>
<p>a data frame with predictions.</p>
</td></tr>
<tr><td><code>nx</code></td>
<td>
<p>number of observations in the training dataset.</p>
</td></tr>
<tr><td><code>nz</code></td>
<td>
<p>number of observations in the prediction dataset.</p>
</td></tr>
<tr><td><code>p</code></td>
<td>
<p>number of variables.</p>
</td></tr>
<tr><td><code>control</code></td>
<td>
<p>control parameters used for fitting.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Marco Geraci with contributions from Cinzia Viroli
</p>


<h3>References</h3>

<p>Viroli C, Farcomeni A, Geraci M (2020). Directional quantile-based classifiers (in preparation).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dqcControl">dqcControl</a></code> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
# Iris data
data(iris)

# Create training and prediction datasets

n &lt;- nrow(iris)
ng &lt;- length(unique(iris$Species))
df1 &lt;- iris[c(1:40, 51:90, 101:140),]
df2 &lt;- iris[c(41:50, 91:100, 141:150),]

# Classify
ctrl &lt;- dqcControl(nt = 10, ndir = 5000, seed = 123)
fit &lt;- dqc(Species ~ Sepal.Length + Petal.Length,
	data = df1, df.test = df2, control = ctrl)

# Data frame with predictions
fit$ans

# Confusion matrix
print(cm &lt;- xtabs( ~ fit$ans$groups + df2$Species))

# Misclassification rate
1-sum(diag(cm))/nrow(df2)

## End(Not run)

</code></pre>

<hr>
<h2 id='dqcControl'>
Control parameters for dqc estimation
</h2><span id='topic+dqcControl'></span>

<h3>Description</h3>

<p>A list of parameters for controlling the fitting process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dqcControl(tau.range = c(0.001, 0.999), nt = 10, ndir = 50, seed = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dqcControl_+3A_tau.range">tau.range</code></td>
<td>

<p>vector with range of quantile probabilities. See details. 
</p>
</td></tr>
<tr><td><code id="dqcControl_+3A_nt">nt</code></td>
<td>

<p>length of grid of quantiles within <code>tau.range</code>.
</p>
</td></tr>
<tr><td><code id="dqcControl_+3A_ndir">ndir</code></td>
<td>

<p>number of directions.
</p>
</td></tr>
<tr><td><code id="dqcControl_+3A_seed">seed</code></td>
<td>

<p>seed for <code><a href="base.html#topic+set.seed">set.seed</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A directional quantile classifier (Viroli et al, 2020) is computed over a grid of quantile probabilities. The vector <code>tau.range</code> must be of length 2, providing a minimum and a maximum for the grid, or of length 1, in which case the grid will have only one probability equal to tau.range. In the latter case <code>nt</code> is ignored and set equal to 1.
</p>


<h3>Value</h3>

<p>a list of control parameters.
</p>


<h3>Author(s)</h3>

<p>Marco Geraci</p>


<h3>References</h3>

<p>Viroli C, Farcomeni A, Geraci M (2020). Directional quantile-based classifiers (in preparation).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dqc">dqc</a></code>
</p>

<hr>
<h2 id='esterase'>Esterase Essay Data</h2><span id='topic+esterase'></span>

<h3>Description</h3>

<p>The <code>esterase</code> data frame has 113 rows and 2 columns with the
results of an essay for the concentration of an enzyme esterase.
</p>


<h3>Format</h3>

<p>This data frame contains the following columns:
</p>

<dl>
<dt>Esterase</dt><dd>
<p>amount of esterase.
</p>
</dd>
<dt>Count</dt><dd>
<p>observed count.
</p>
</dd>
</dl>



<h3>Details</h3>

<p>The esterase essay data were reported by Caroll and Ruppert (1988) and successively analyzed by Zhao (2000).
</p>


<h3>Source</h3>

<p>R. J. Carroll and D. Ruppert, Transformation and Weighting in Regression. London: Chapman and Hall, 1988.
</p>


<h3>References</h3>

<p>Zhao QS. Restricted regression quantiles. Journal of Multivariate Analysis 2000;72(1):78-99.
</p>

<hr>
<h2 id='fitted.midrq'>
Extract Fitted Values from Mid-Quantile Transformation Models
</h2><span id='topic+fitted.midrq'></span>

<h3>Description</h3>

<p>This function extracts fitted values from objects of class <code>midrq</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'midrq'
fitted(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitted.midrq_+3A_object">object</code></td>
<td>

<p>an object of <code><a href="base.html#topic+class">class</a></code> <code>midrq</code>.
</p>
</td></tr>
<tr><td><code id="fitted.midrq_+3A_...">...</code></td>
<td>

<p>other arguments.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector or a matrix or an array of fitted values.
</p>


<h3>Author(s)</h3>

<p>Marco Geraci
</p>


<h3>See Also</h3>

<p><code><a href="#topic+predict.midrq">predict.midrq</a></code>
</p>

<hr>
<h2 id='fitted.rq.counts'>
Extract Fitted Values from Quantile Regression Models for Counts
</h2><span id='topic+fitted.rq.counts'></span>

<h3>Description</h3>

<p>This function extracts fitted values from objects of class <code>rq.counts</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'rq.counts'
fitted(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitted.rq.counts_+3A_object">object</code></td>
<td>

<p>an object of <code><a href="base.html#topic+class">class</a></code> <code>rq.counts</code>.
</p>
</td></tr>
<tr><td><code id="fitted.rq.counts_+3A_...">...</code></td>
<td>

<p>other arguments.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector or a matrix or an array of fitted values.
</p>


<h3>Author(s)</h3>

<p>Marco Geraci
</p>


<h3>See Also</h3>

<p><code><a href="#topic+predict.rq.counts">predict.rq.counts</a></code>
</p>

<hr>
<h2 id='fitted.rqt'>
Extract Fitted Values from Quantile Regression Transformation Models
</h2><span id='topic+fitted.rqt'></span>

<h3>Description</h3>

<p>This function extracts fitted values from objects of class <code>rqt</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'rqt'
fitted(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitted.rqt_+3A_object">object</code></td>
<td>

<p>an object of <code><a href="base.html#topic+class">class</a></code> <code>rqt</code>.
</p>
</td></tr>
<tr><td><code id="fitted.rqt_+3A_...">...</code></td>
<td>

<p>other arguments.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector or a matrix or an array of fitted values.
</p>


<h3>Author(s)</h3>

<p>Marco Geraci
</p>


<h3>See Also</h3>

<p><code><a href="#topic+predict.rqt">predict.rqt</a></code>
</p>

<hr>
<h2 id='GOFTest'>
Goodness-of-Fit Tests for Quantile Regression Models
</h2><span id='topic+GOFTest'></span>

<h3>Description</h3>

<p>This function calculates a goodness-of-fit test for quantile regression models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GOFTest(object, type = "cusum", alpha = 0.05, B = 100, seed = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GOFTest_+3A_object">object</code></td>
<td>

<p>an object of <code><a href="base.html#topic+class">class</a></code> &quot;rq&quot;,&quot;rqs&quot;, &quot;rqt&quot;, &quot;rrq&quot;, or &quot;rq.counts&quot;.
</p>
</td></tr>
<tr><td><code id="GOFTest_+3A_type">type</code></td>
<td>

<p>the type of the test. See details.
</p>
</td></tr>
<tr><td><code id="GOFTest_+3A_alpha">alpha</code></td>
<td>

<p>the significance level for the test. This argument is relevant for <code>type = "cusum"</code> only.
</p>
</td></tr>
<tr><td><code id="GOFTest_+3A_b">B</code></td>
<td>

<p>the number of Monte Carlo samples. This argument is relevant for <code>type = "cusum"</code> only.
</p>
</td></tr>
<tr><td><code id="GOFTest_+3A_seed">seed</code></td>
<td>

<p>see for random numbers. This argument is relevant for <code>type = "cusum"</code> only.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function provides goodness-of-fit tests for quantile regression. Currently, there is only one method available (<code>type = "cusum"</code>), for a test based on the cusum process of the gradient vector (He and Zhu, 2013). The critical value at level <code>alpha</code> is obtained by resampling. Other methods will be implemented in future versions of the package.
</p>


<h3>Value</h3>

<p><code>GOFTest</code> returns an object of <code><a href="base.html#topic+class">class</a></code> <code>GOFtest</code>.
</p>


<h3>Author(s)</h3>

<p>Marco Geraci
</p>


<h3>References</h3>

<p>He XM, Zhu LX. A lack-of-fit test for quantile regression. Journal of the American Statistical Association (2003);98:1013-1022. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
data(barro, package = "quantreg")
fit &lt;- quantreg::rq(y.net ~ lgdp2 + fse2 + gedy2 + Iy2 + gcony2, data = barro, tau = c(.1,.5,.9))
GOFTest(fit)

## End(Not run)

</code></pre>

<hr>
<h2 id='KhmaladzeFormat'>
Khmaladze Test
</h2><span id='topic+KhmaladzeFormat'></span>

<h3>Description</h3>

<p>This function provides significance levels of the Khmaladze Test using a (hard-coded) table of asymptotic critical values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>KhmaladzeFormat(object, epsilon)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="KhmaladzeFormat_+3A_object">object</code></td>
<td>

<p>an object of <code><a href="base.html#topic+class">class</a></code> &quot;KhmaladzeTest&quot;.
</p>
</td></tr>
<tr><td><code id="KhmaladzeFormat_+3A_epsilon">epsilon</code></td>
<td>

<p>trimming value. One of <code>c(0.05,0.10,0.15,0.20,0.25,0.30)</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is applied to an object produced by <code><a href="quantreg.html#topic+KhmaladzeTest">KhmaladzeTest</a></code>. The Khmaladze test is used to test for location&ndash;shift and location-scale&ndash;shift hypotheses (Koenker, 2005). The test statistic is computed over the interval <em>[epsilon, 1 - epsilon]</em>, where <em>epsilon</em> is the trimming value.
</p>


<h3>Author(s)</h3>

<p>Marco Geraci
</p>


<h3>References</h3>

<p>Appendix B in Koenker R. Quantile regression. New York, NY: Cambridge University Press; 2005.
</p>
<p>Koenker R. and Xiao Z. Inference on the quantile regression process. Avalilable at <a href="http://www.econ.uiuc.edu/~roger/research/inference/khmal6ap.pdf">http://www.econ.uiuc.edu/~roger/research/inference/khmal6ap.pdf</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(barro, package = "quantreg")
eps &lt;- 0.05
kt &lt;- quantreg::KhmaladzeTest( y.net ~ lgdp2 + fse2 + gedy2 + Iy2 + gcony2, 
		data = barro, taus = seq(.05,.95,by = .01), trim = c(eps, 1 - eps))
class(kt)
KhmaladzeFormat(kt, epsilon = eps)

</code></pre>

<hr>
<h2 id='labor'>Labor Pain Data</h2><span id='topic+labor'></span>

<h3>Description</h3>

<p>The <code>labor</code> data frame has 358 rows and 4 columns of the
change in pain over time for several 83 women in labor.
</p>


<h3>Format</h3>

<p>This data frame contains the following columns:
</p>

<dl>
<dt>subject</dt><dd>
<p>an ordered factor indicating the subject on which the
measurement was made.  The levels are labelled <code>1</code>
to <code>83</code>.
</p>
</dd>
<dt>pain</dt><dd>
<p>a numeric vector of self&ndash;reported pain scores on a 100mm line.
</p>
</dd>
<dt>treatment</dt><dd>
<p>a dummy variable with values
<code>1</code> for subjects who received a pain medication and
<code>0</code> for subjects who received a placebo. 
</p>
</dd>
<dt>time</dt><dd>
<p>a numeric vector of times (minutes since randomization) at which <code>pain</code> was measured.
</p>
</dd>
</dl>



<h3>Details</h3>

<p>The labor pain data were reported by Davis (1991) and successively analyzed by Jung (1996) and Geraci and Bottai (2007). The data
set consists of repeated measurements of self&ndash;reported amount of pain on N = 83 women in labor, of which 43 were randomly assigned to a pain medication group and 40 to a placebo group. The response was measured every 30 min on a 100&ndash;mm line, where 0 means no pain and 100 means extreme pain. A nearly monotone pattern of missing data was found for the response variable and the maximum number of measurements for each woman was six.
</p>


<h3>Source</h3>

<p>Davis CS (1991). Semi&ndash;parametric and non&ndash;parametric methods for the analysis of repeated measurements with applications to clinical trials. Statistics in Medicine 10, 1959&ndash;80.
</p>


<h3>References</h3>

<p>Geraci M and Bottai M (2007). Quantile regression for longitudinal data using the asymmetric Laplace distribution. Biostatistics 8(1), 140&ndash;154.
</p>
<p>Jung S (1996). Quasi&ndash;likelihood for median regression models. Journal of the American Statistical Association 91, 251&ndash;7.
</p>

<hr>
<h2 id='maref.rqt'>
Marginal Effects
</h2><span id='topic+maref'></span><span id='topic+maref.rq.counts'></span><span id='topic+maref.rqt'></span>

<h3>Description</h3>

<p>This function computes marginal effects for <code>rqt</code> and <code>rq.counts</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>maref(object, namevec)
## S3 method for class 'rqt'
maref(object, namevec)
## S3 method for class 'rq.counts'
maref(object, namevec)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="maref.rqt_+3A_object">object</code></td>
<td>

<p>an <code>rqt</code> or an <code>rq.counts</code> object.
</p>
</td></tr>
<tr><td><code id="maref.rqt_+3A_namevec">namevec</code></td>
<td>

<p>character giving the name of the covariate with respect to which the marginal effect is to be computed.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given the <code class="reqn">\tau</code>th conditional quantile function <code class="reqn">Q_{h(Y)|X}(\tau) = \eta = Xb</code>, where <code class="reqn">Y</code> is the response variable, <code class="reqn">X</code> a design matrix, and <code class="reqn">h</code> is a one-parameter transformation with inverse <code class="reqn">h^{-1} = g</code>, <code>maref</code> computes the marginal effect:
</p>
<p style="text-align: center;"><code class="reqn">
\frac{dQ_{Y|X}(\tau)}{dx_{j}} = \frac{dg\{Q_{h(Y)|X}(\tau)\}}{dx_{j}}
</code>
</p>

<p>where <code class="reqn">x_{j}</code> is the <em>j</em>-th covariate with respect to which the marginal effect is to be computed and its name is given in the argument <code>namevec</code>.
</p>
<p>The derivative of the quantile function is the the product of two components
</p>
<p style="text-align: center;"><code class="reqn">\frac{dQ_{Y|X}(\tau)}{dx_{j}} = \frac{dg(\eta)}{d\eta} \cdot \frac{d\eta}{dx_{j}}
</code>
</p>

<p>The derivative w.r.t. the linear predictor <code class="reqn">\eta</code> is calculated symbolically after parsing the <code>object</code>'s formula and is evaluated using the <code>object</code>'s model frame. The function that parses formulae has a limited scope. It recognizes interactions and basic operators (e.g., log, exp, etc.). Therefore, it is recommended to use simple expressions for the model's formula.
</p>
<p>This function can be applied to models of class <code>rqt</code> and <code>rq.counts</code>. Note that marginal effects can be similarly obtained using <code><a href="#topic+predict.rqt">predict.rqt</a></code> or <code><a href="#topic+predict.rq.counts">predict.rq.counts</a></code> with argument <code>type = "maref"</code> which, in addition, allows for an optional data frame to be specified via <code>newdata</code>.
</p>


<h3>Value</h3>

<p>a vector for single quantiles or a matrix for multiple quantiles of marginal effects.
</p>


<h3>Author(s)</h3>

<p>Marco Geraci
</p>


<h3>See Also</h3>

<p><code><a href="#topic+tsrq">tsrq</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Box-Cox quantile regression model (dataset trees from package 'datasets')
fit &lt;- tsrq(Volume ~ Height, data = trees, tsf = "bc", tau = 0.9)

# Coefficients (transformed scale)
coef(fit)

# Design matrix
head(fit$x)

# Marginal effect of 'Height'
maref(fit, namevec = "Height")

# Predict marginal effects over grid of values for Height
nd &lt;- data.frame(Height = seq(min(trees$Height), max(trees$Height), length = 100))
x &lt;- predict(fit, newdata = nd, type = "maref", namevec = "Height")

# Plot
plot(nd$Height, x, xlab = "Height", ylab = "Marginal effect on volume")

# Include 'Girth' and interaction between 'Height' and 'Girth'
fit &lt;- tsrq(Volume ~ Height * Girth, data = trees, tsf = "bc", tau = 0.5)
head(fit$x)

# Predict marginal effects over grid of values for Height (for fixed girth)
nd$Girth &lt;- rep(mean(trees$Girth), 100)
x &lt;- predict(fit, newdata = nd, type = "maref", namevec = "Height")
plot(nd$Height, x, xlab = "Height", ylab = "Marginal effect on volume")

# Quantile regression for counts (log transformation)
data(esterase)
fit &lt;- rq.counts(Count ~ Esterase, tau = 0.25, data = esterase, M = 50)
maref(fit, namevec = "Esterase")

## End(Not run)
</code></pre>

<hr>
<h2 id='mice.impute.rq'>
QR-based Multiple Imputation
</h2><span id='topic+mice.impute.rrq'></span><span id='topic+mice.impute.rq'></span>

<h3>Description</h3>

<p>This function is used to multiply impute missing values using quantile regression imputation models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mice.impute.rq(y, ry, x, tsf = "none", symm = TRUE, dbounded = FALSE,
	lambda = NULL, x.r = NULL, par = NULL, conditional = TRUE,
	epsilon = 0.001, method.rq = "fn", ...)
mice.impute.rrq(y, ry, x, tsf = "none", symm = TRUE, dbounded = FALSE,
	lambda = NULL, epsilon = 0.001, method.rq = "fn", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mice.impute.rq_+3A_y">y</code></td>
<td>

<p>numeric vector of length <code>n</code> with <code>nmis</code> missing values.
</p>
</td></tr>
<tr><td><code id="mice.impute.rq_+3A_ry">ry</code></td>
<td>

<p>missing data indicator. Logical vector of length <code>n</code>: <code>FALSE</code> if <code>y</code> is missing, <code>TRUE</code> if <code>y</code> is observed.
</p>
</td></tr>
<tr><td><code id="mice.impute.rq_+3A_x">x</code></td>
<td>

<p>matrix <code>n x p</code> of completely observed covariates.
</p>
</td></tr>
<tr><td><code id="mice.impute.rq_+3A_tsf">tsf</code></td>
<td>

<p>transformation to be used. Possible options are <code>mcjI</code> for Proposal I, <code>bc</code> for Box-Cox and <code>ao</code> for Aranda-Ordaz transformation models. No transformation is used by default.
</p>
</td></tr>
<tr><td><code id="mice.impute.rq_+3A_symm">symm</code></td>
<td>

<p>logical flag. If <code>TRUE</code> (default) a symmetric transformation is used.
</p>
</td></tr>
<tr><td><code id="mice.impute.rq_+3A_dbounded">dbounded</code></td>
<td>

<p>logical flag. If <code>TRUE</code> the response <code>y</code> is assumed to be bounded between 0 and 1.
</p>
</td></tr>
<tr><td><code id="mice.impute.rq_+3A_lambda">lambda</code></td>
<td>

<p>if <code>conditional = TRUE</code>, a numerical value for the transformation parameter. This is provided by the user or set to zero if not specified. If <code>conditional = FALSE</code>, this argument is ignored.
</p>
</td></tr>
<tr><td><code id="mice.impute.rq_+3A_x.r">x.r</code></td>
<td>

<p>range of the mapping for doubly bounded variables.
</p>
</td></tr>
<tr><td><code id="mice.impute.rq_+3A_par">par</code></td>
<td>

<p>if <code>conditional = FALSE</code>, starting values for <code><a href="#topic+nlrq1">nlrq1</a></code> can be provided via this argument. See argument <code>start</code> in <code>nlrq1</code> for details.
</p>
</td></tr>
<tr><td><code id="mice.impute.rq_+3A_conditional">conditional</code></td>
<td>

<p>logical flag. If <code>TRUE</code> (default), the transformation parameter is assumed to be known and this must be provided via the argument <code>lambda</code>. Otherwise, it is estimated via <code><a href="#topic+nlrq1">nlrq1</a></code>.
</p>
</td></tr>
<tr><td><code id="mice.impute.rq_+3A_epsilon">epsilon</code></td>
<td>

<p>constant used to trim the values of the sample space.
</p>
</td></tr>
<tr><td><code id="mice.impute.rq_+3A_method.rq">method.rq</code></td>
<td>

<p>linear programming algorithm (see <code><a href="quantreg.html#topic+rq">rq</a></code>).
</p>
</td></tr>
<tr><td><code id="mice.impute.rq_+3A_...">...</code></td>
<td>

<p>additional arguments.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function implements the methods proposed by Geraci (2016) and Geraci and McLain (2018) to impute missing values using quantile regression models. Uniform values are sampled from <em>[epsilon, 1 - epsilon]</em>, therefore allowing the interval to be bounded away from 0 and 1 (default is 0.001). It is possible to specify a quantile regression transformation model with parameter <code>lambda</code> (Geraci and Jones). The function <code>mice.impute.rrq</code> performs imputation based on restricted regression quantiles to avoid quantile crossing (see Geraci 2016 for details).
</p>


<h3>Value</h3>

<p>A vector of length <code>nmis</code> with imputations.
</p>


<h3>Author(s)</h3>

<p>Marco Geraci
</p>


<h3>References</h3>

<p>Bottai, M., &amp; Zhen, H. (2013). Multiple imputation based on conditional quantile estimation. Epidemiology, Biostatistics, and Public Health, 10(1), e8758.
</p>
<p>Geraci, M. (2016). Estimation of regression quantiles in complex surveys with data missing at random: An application to birthweight determinants. Statistical Methods in Medical Research, 25(4), 1393-1421.
</p>
<p>Geraci, M., and Jones, M. C. (2015). Improved transformation-based quantile regression. Canadian Journal of Statistics, 43(1), 118-132.
</p>
<p>Geraci, M., and McLain, A. (2018). Multiple imputation for bounded variables. Psychometrika, 83(4), 919-940.
</p>
<p>van Buuren, S., and Groothuis-Oudshoorn, K. (2011). mice: Multivariate imputation by chained equations in R. Journal of Statistical Software, 45(3), 1&ndash;67. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ao">ao</a></code>, <code><a href="#topic+tsrq">tsrq</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

# Load package 'mice'
require(mice)

# Load data nhanes
data(nhanes)
nhanes2 &lt;- nhanes
nhanes2$hyp &lt;- as.factor(nhanes2$hyp)

# Impute continuous variables using quantile regression
set.seed(199)
imp &lt;- mice(nhanes2, meth = c("polyreg", "rq", "logreg", "rq"), m = 5)

# estimate linear regression and pool results
fit &lt;- lm.mids(bmi ~ hyp + chl, data = imp)
pool(fit)

# Impute using restricted quantile regression
set.seed(199)
imp &lt;- mice(nhanes2, meth = c("polyreg", "rrq", "logreg", "rrq"), m = 5)
fit &lt;- lm.mids(bmi ~ hyp + chl, data = imp)
pool(fit)

# Impute using quantile regression + Box-Cox transformation with parameter
# lambda = 0 (ie, log transformation)

set.seed(199)
imp &lt;- mice(nhanes2, meth = c("polyreg", "rq", "logreg", "rq"), m = 5, tsf = "bc", lambda = 0)
fit &lt;- lm.mids(bmi ~ hyp + chl, data = imp)
pool(fit)



## End(Not run)

</code></pre>

<hr>
<h2 id='midq2q'>
Recover Ordinary Conditional Quantiles from Conditional Mid-Quantiles</h2><span id='topic+midq2q'></span>

<h3>Description</h3>

<p>This function recovers ordinary conditional quantile functions based on fitted mid-quantile regression models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>midq2q(object, newdata, observed = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="midq2q_+3A_object">object</code></td>
<td>

<p>an object of <code><a href="base.html#topic+class">class</a></code> <code>midrq</code>.
</p>
</td></tr>
<tr><td><code id="midq2q_+3A_newdata">newdata</code></td>
<td>

<p>a required data frame in which to look for variables with which to predict.
</p>
</td></tr>
<tr><td><code id="midq2q_+3A_observed">observed</code></td>
<td>

<p>logical flag. If <code>TRUE</code>, ordinary quantiles are recovered from observed sample values. Otherwise, they are calcuated as rounded mid-quantiles. See details.
</p>
</td></tr>
<tr><td><code id="midq2q_+3A_...">...</code></td>
<td>

<p>not used.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the values of the support of the random variable are equally spaced integers, then <code>observed</code> should ideally be set to <code>FALSE</code> so that the ordinary quantile is obtained by rounding the predicted mid-quantile. Otherwise, the function returns an integer observed in the sample. See Geraci and Farcomeni for more details.
</p>


<h3>Value</h3>

<p>a vector or a matrix of estimated ordinary quantiles. The attribute <code>Fhat</code> provides the corresponding estimated cumulative distribution.
</p>


<h3>Author(s)</h3>

<p>Marco Geraci
</p>


<h3>References</h3>

<p>Geraci, M. and A. Farcomeni. Mid-quantile regression for discrete responses. arXiv:1907.01945 [stat.ME]. URL: <a href="https://arxiv.org/abs/1907.01945">https://arxiv.org/abs/1907.01945</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.midq2q">plot.midq2q</a></code>, <code><a href="#topic+predict.midrq">predict.midrq</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
# Esterase data
data(esterase)

# Fit quantiles 0.1, 0.15, ..., 0.85
fit &lt;- midrq(Count ~ Esterase, tau = 2:17/20, data = esterase, type = 3, lambda = 0)

# Recover ordinary quantile function
xx &lt;- seq(min(esterase$Esterase), max(esterase$Esterase), length = 5)
print(Qhat &lt;- midq2q(fit, newdata = data.frame(Esterase = xx)))

# Plot
plot(Qhat, sub = TRUE)


## End(Not run)

</code></pre>

<hr>
<h2 id='midquantile'>
Mid-distribution Functions
</h2><span id='topic+midecdf'></span><span id='topic+midquantile'></span>

<h3>Description</h3>

<p>Compute mid-cumulative probabilities and mid-quantiles
</p>


<h3>Usage</h3>

<pre><code class='language-R'>midecdf(x, na.rm = FALSE)
midquantile(x, probs = 1:3/4, na.rm = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="midquantile_+3A_x">x</code></td>
<td>

<p>numeric vector of observations used to estimate the mid-cumulative distribution or the mid-quantiles.
</p>
</td></tr>
<tr><td><code id="midquantile_+3A_probs">probs</code></td>
<td>

<p>numeric vector of probabilities with values in [0,1].
</p>
</td></tr>
<tr><td><code id="midquantile_+3A_na.rm">na.rm</code></td>
<td>

<p>logical value indicating whether NA values should be stripped before the computation proceeds.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code><a href="base.html#topic+class">class</a></code> <code>midecdf</code> or <code>midquantile</code> with mid-cumulative probabilities and mid-quantiles. For <code>midecdf</code>, this is a list that contains:
</p>
<table>
<tr><td><code>x</code></td>
<td>
<p>unique values of the vector <code>x</code> at which mid-cumulative probabilities are calculated.</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>estimated mid-cumulative probabilities.</p>
</td></tr>
<tr><td><code>fn</code></td>
<td>
<p>interpolating function of the points <code>(x,y)</code>.</p>
</td></tr>
<tr><td><code>data</code></td>
<td>
<p>input values.</p>
</td></tr>
</table>
<p>For <code>midquantile</code>, this is a list that contains:
</p>
<table>
<tr><td><code>x</code></td>
<td>
<p>probabilities <code>probs</code> at which mid-quantiles are calculated.</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>estimated mid-cumulative probabilities.</p>
</td></tr>
<tr><td><code>fn</code></td>
<td>
<p>interpolating function of the points <code>(x,y)</code>.</p>
</td></tr>
<tr><td><code>data</code></td>
<td>
<p>input values.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Marco Geraci
</p>


<h3>References</h3>

<p>Ma Y., Genton M., and Parzen E. Asymptotic properties of sample quantiles of discrete distributions. Annals of the Institute of Statistical Mathematics 2011;63(2):227-243
</p>
<p>Parzen E. Quantile probability and statistical data modeling. Statistical Science 2004;19(4):652-62.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+confint.midquantile">confint.midquantile</a></code>, <code><a href="#topic+plot.midquantile">plot.midquantile</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- rpois(100, lambda = 3)
midquantile(x)

</code></pre>

<hr>
<h2 id='midrq'>
Mid-Quantile Regression for Discrete Responses</h2><span id='topic+midrq.fit'></span><span id='topic+midrq'></span>

<h3>Description</h3>

<p>This function is used to fit a mid-quantile regression model when the response is discrete.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>midrq(formula, data, tau = 0.5, lambda = NULL, subset, weights, na.action,
	contrasts = NULL, offset, type = 3, midFit = NULL, control = list())
midrq.fit(x, y, offset, lambda, binary, midFit, type, tau, method)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="midrq_+3A_formula">formula</code></td>
<td>

<p>an object of class <code><a href="stats.html#topic+formula">formula</a></code>: a symbolic description of the model to be fitted.
</p>
</td></tr>
<tr><td><code id="midrq_+3A_data">data</code></td>
<td>

<p>an optional data frame, list or environment (or object coercible by as.data.frame to a data frame) containing the variables in the model. If not found in data, the variables are taken from environment(formula), typically the environment from which <code>midrq</code> is called.
</p>
</td></tr>
<tr><td><code id="midrq_+3A_tau">tau</code></td>
<td>

<p>quantile to be estimated. This can be a vector of quantiles in <code>midrq</code>, but must be one single quantile in <code>midrq.fit</code>.
</p>
</td></tr>
<tr><td><code id="midrq_+3A_lambda">lambda</code></td>
<td>

<p>a numerical value for the transformation parameter. This is provided by the user or set to <code>NULL</code>. The transformation is always Box-Cox, unless the response is binary (0-1) in which case the trasformation is Aranda-Ordaz. See <code><a href="#topic+bc">bc</a></code> and <code><a href="#topic+ao">ao</a></code>.
</p>
</td></tr>
<tr><td><code id="midrq_+3A_subset">subset</code></td>
<td>

<p>an optional vector specifying a subset of observations to be used in the fitting process.
</p>
</td></tr>
<tr><td><code id="midrq_+3A_weights">weights</code></td>
<td>

<p>an optional vector of weights to be used in the fitting process.
</p>
</td></tr>
<tr><td><code id="midrq_+3A_na.action">na.action</code></td>
<td>

<p>a function which indicates what should happen when the data contain <code>NA</code>s.
</p>
</td></tr>
<tr><td><code id="midrq_+3A_contrasts">contrasts</code></td>
<td>

<p>an optional list. See the <code>contrasts.arg</code> of <code><a href="stats.html#topic+model.matrix.default">model.matrix.default</a></code>.
</p>
</td></tr>
<tr><td><code id="midrq_+3A_offset">offset</code></td>
<td>

<p>an optional offset to be included in the model frame. This must be provided in <code>midrq.fit</code> (e.g., a vector of zeros).
</p>
</td></tr>
<tr><td><code id="midrq_+3A_type">type</code></td>
<td>

<p>estimation method for the fitting process. See details.
</p>
</td></tr>
<tr><td><code id="midrq_+3A_midfit">midFit</code></td>
<td>

<p><code>cmidecdf</code> object used for fitting conditional mid-quantiles. If set to <code>NULL</code> in <code>midrq</code>, it is automatically created. It must be provided in <code>midrq.fit</code>.
</p>
</td></tr>
<tr><td><code id="midrq_+3A_control">control</code></td>
<td>

<p>list of control parameters of the fitting process. See <code><a href="#topic+midrqControl">midrqControl</a></code>.
</p>
</td></tr>
<tr><td><code id="midrq_+3A_x">x</code></td>
<td>

<p>design matrix of dimension <code class="reqn">n * p</code>.
</p>
</td></tr>
<tr><td><code id="midrq_+3A_y">y</code></td>
<td>

<p>vector of observations of length <code class="reqn">n</code>.
</p>
</td></tr>
<tr><td><code id="midrq_+3A_binary">binary</code></td>
<td>

<p>logical flag. Is the response binary?
</p>
</td></tr>
<tr><td><code id="midrq_+3A_method">method</code></td>
<td>

<p>character vector that specifies the optimization algorithm in <code><a href="stats.html#topic+optim">optim</a></code> to fit a conditional mid-quantile model when <code>type = 1</code> or <code>type = 2</code>. Only <code>"Nelder-Mead"</code> has been tested.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A linear mid-quantile regression model is fitted to the transformed response. The transformation of the response can be changed with the argument <code>lambda</code>. If <code>lambda = NULL</code>, then no transformation is applied (i.e., identity); if <code>lambda</code> is a numeric value, then the Box-Cox transformation is applied (e.g., 0 for log-transformation). However, <code>midrq</code> will automatically detect whether the response is binary, in which case the Aranda-Ordaz transformation is applied. In contrast, the user must declare whether the response is binary in <code>midrq.fit</code>.
</p>
<p>There are 3 different estimators. <code>type = 1</code> is based on a general-purpose estimator (i.e., <code><a href="stats.html#topic+optim">optim</a></code>). <code>type = 2</code> is similar to <code>type = 1</code>, except the loss function is averaged over the space of the predictors (i.e., CUSUM). <code>type = 3</code> is the least-squares estimator discussed by Geraci and Farcomeni (2019).
</p>
<p>The warning &lsquo;tau is outside mid-probabilities range&rsquo; indicates that there are observations for which tau is below or above the range of the corresponding estimated conditional mid-probabilities. This affects estimation in a way similar to censoring.
</p>


<h3>Value</h3>

<p>a list of class <code>midrq</code> containing the following components
</p>
<table>
<tr><td><code>call</code></td>
<td>
<p>the matched call.</p>
</td></tr>
<tr><td><code>x</code></td>
<td>
<p>the model matrix.</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>the model response.</p>
</td></tr>
<tr><td><code>hy</code></td>
<td>
<p>the tranformed model response.</p>
</td></tr>
<tr><td><code>tau</code></td>
<td>
<p>the order of the estimated quantile(s).</p>
</td></tr>
<tr><td><code>coefficients</code></td>
<td>
<p>regression quantile (on the log&ndash;scale).</p>
</td></tr>
<tr><td><code>fitted.values</code></td>
<td>
<p>fitted values (on the response scale).</p>
</td></tr>
<tr><td><code>offset</code></td>
<td>
<p>offset.</p>
</td></tr>
<tr><td><code>terms</code></td>
<td>
<p>the terms object used.</p>
</td></tr>
<tr><td><code>term.labels</code></td>
<td>
<p>names of coefficients.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Marco Geraci with contributions from Alessio Farcomeni
</p>


<h3>References</h3>

<p>Geraci, M. and A. Farcomeni. Mid-quantile regression for discrete responses. arXiv:1907.01945 [stat.ME]. URL: <a href="https://arxiv.org/abs/1907.01945">https://arxiv.org/abs/1907.01945</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+residuals.midrq">residuals.midrq</a></code>, <code><a href="#topic+predict.midrq">predict.midrq</a></code>, <code><a href="#topic+coef.midrq">coef.midrq</a></code> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
# Esterase data
data(esterase)

# Fit quantiles 0.25 and 0.75
fit &lt;- midrq(Count ~ Esterase, tau = c(0.25, 0.75), data = esterase, type = 3, lambda = 0)
coef(fit)

# Plot
with(esterase, plot(Count ~ Esterase))
lines(esterase$Esterase, fit$fitted.values[,1], col = "blue")
lines(esterase$Esterase, fit$fitted.values[,2], col = "red")
legend(8, 1000, lty = c(1,1), col = c("blue", "red"), legend = c("tau = 0.25","tau = 0.75"))


## End(Not run)

</code></pre>

<hr>
<h2 id='midrqControl'>
Control parameters for midrq estimation
</h2><span id='topic+midrqControl'></span>

<h3>Description</h3>

<p>A list of parameters for controlling the fitting process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>midrqControl(method = "Nelder-Mead", ecdf_est = "npc", npc_args = list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="midrqControl_+3A_method">method</code></td>
<td>

<p>character vector that specifies the optimization algorithm in <code><a href="stats.html#topic+optim">optim</a></code> to fit a conditional mid-quantile model when <code>type = 1</code> or <code>type = 2</code>. Only <code>"Nelder-Mead"</code> has been tested.
</p>
</td></tr>
<tr><td><code id="midrqControl_+3A_ecdf_est">ecdf_est</code></td>
<td>

<p>estimator of the (standard) conditional cumulative distribution. The options are: <code>npc</code> (default) for kernel estimator (Li and Racine, 2008); <code>logit</code>, <code>probit</code>, <code>cloglog</code> for binomial regression; <code>ao</code> for Aranda-Ordaz binomial regression.
</p>
</td></tr>
<tr><td><code id="midrqControl_+3A_npc_args">npc_args</code></td>
<td>

<p>named list of arguments for <code>npcdistbw</code> when <code>ecdf_est = npc</code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of control parameters.
</p>


<h3>Author(s)</h3>

<p>Marco Geraci</p>


<h3>References</h3>

<p>Geraci, M. and A. Farcomeni. Mid-quantile regression for discrete responses. arXiv:1907.01945 [stat.ME]. URL: <a href="https://arxiv.org/abs/1907.01945">https://arxiv.org/abs/1907.01945</a>.
</p>
<p>Li, Q. and J. S. Racine (2008). Nonparametric estimation of conditional cdf and quantile functions with mixed categorical and continuous data. Journal of Business and Economic Statistics 26(4), 423-434.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+midrq">midrq</a></code>
</p>

<hr>
<h2 id='nlControl'>
Control parameters for gradient search estimation
</h2><span id='topic+nlControl'></span>

<h3>Description</h3>

<p>A list of parameters for controlling the fitting process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nlControl(tol_ll = 1e-05, tol_theta = 0.001, check_theta = FALSE,
	step = NULL, beta = 0.5, gamma = 1.25, reset_step = FALSE,
	maxit = 1000, smooth = FALSE, omicron = 0.001, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nlControl_+3A_tol_ll">tol_ll</code></td>
<td>

<p>tolerance expressed as relative change of the objective function.
</p>
</td></tr>
<tr><td><code id="nlControl_+3A_tol_theta">tol_theta</code></td>
<td>

<p>tolerance expressed as relative change of the estimates.
</p>
</td></tr>
<tr><td><code id="nlControl_+3A_check_theta">check_theta</code></td>
<td>

<p>logical flag. If <code>TRUE</code> the algorithm performs a check on the change in the estimates in addition to the likelihood.
</p>
</td></tr>
<tr><td><code id="nlControl_+3A_step">step</code></td>
<td>

<p>step size (default standard deviation of response).
</p>
</td></tr>
<tr><td><code id="nlControl_+3A_beta">beta</code></td>
<td>

<p>decreasing step factor for line search (0,1).
</p>
</td></tr>
<tr><td><code id="nlControl_+3A_gamma">gamma</code></td>
<td>

<p>nondecreasing step factor for line search (&gt;= 1).
</p>
</td></tr>
<tr><td><code id="nlControl_+3A_reset_step">reset_step</code></td>
<td>

<p>logical flag. If <code>TRUE</code> the step size is re-setted to the initial value at each iteration.
</p>
</td></tr>
<tr><td><code id="nlControl_+3A_maxit">maxit</code></td>
<td>

<p>maximum number of iterations.
</p>
</td></tr>
<tr><td><code id="nlControl_+3A_smooth">smooth</code></td>
<td>

<p>logical flag. If <code>TRUE</code> the standard loss function is replaced with a smooth approximation.
</p>
</td></tr>
<tr><td><code id="nlControl_+3A_omicron">omicron</code></td>
<td>

<p>small constant for smoothing the loss function when using <code>smooth = TRUE</code>. See details.
</p>
</td></tr>
<tr><td><code id="nlControl_+3A_verbose">verbose</code></td>
<td>

<p>logical flag.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The optimization algorithm is along the lines of the gradient search algorithm (Bottai et al, 2015). If <code>smooth = TRUE</code>, the classical non-differentiable loss function is replaced with a smooth version (Chen and Wei, 2005).
</p>


<h3>Value</h3>

<p>a list of control parameters.
</p>


<h3>Author(s)</h3>

<p>Marco Geraci</p>


<h3>References</h3>

<p>Bottai M, Orsini N, Geraci M (2015). A Gradient Search Maximization Algorithm for the Asymmetric Laplace Likelihood, Journal of Statistical Computation and Simulation, 85(10), 1919-1925.
</p>
<p>Chen C, Wei Y (2005). Computational issues for quantile regression. Sankhya: The Indian Journal of Statistics, 67(2), 399-417.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+nlrq1">nlrq1</a></code>
</p>

<hr>
<h2 id='Orthodont'>Growth curve data on an orthdontic measurement</h2><span id='topic+Orthodont'></span>

<h3>Description</h3>

<p>The <code>Orthodont</code> data frame has 108 rows and 4 columns of the
change in an orthdontic measurement over time for several young subjects.
</p>


<h3>Format</h3>

<p>This data frame contains the following columns:
</p>

<dl>
<dt>distance</dt><dd>
<p>a numeric vector of distances from the pituitary to the
pterygomaxillary fissure (mm).  These distances are measured
on x-ray images of the skull.
</p>
</dd>
<dt>age</dt><dd>
<p>a numeric vector of ages of the subject (yr).
</p>
</dd>
<dt>Subject</dt><dd>
<p>an ordered factor indicating the subject on which the
measurement was made.  The levels are labelled <code>M01</code>
to <code>M16</code> for the males and <code>F01</code> to <code>F13</code> for
the females.  The ordering is by increasing average distance
within sex.
</p>
</dd>
<dt>Sex</dt><dd>
<p>a factor with levels
<code>Male</code> and
<code>Female</code> 
</p>
</dd>
</dl>



<h3>Details</h3>

<p>Investigators at the University of North Carolina Dental School
followed the growth of 27 children (16 males, 11 females) from age 8
until age 14.  Every two years they measured the distance between the
pituitary and the pterygomaxillary fissure, two points that are easily
identified on x-ray exposures of the side of the head.
</p>


<h3>Source</h3>

<p>Pinheiro, J. C. and Bates, D. M. (2000), <em>Mixed-Effects Models in S
and S-PLUS</em>, Springer, New York.  (Appendix A.17)
</p>
<p>Potthoff, R. F. and Roy,  S. N. (1964), &ldquo;A generalized multivariate
analysis of variance model useful especially for growth curve
problems&rdquo;, Biometrika, 51, 313&ndash;326.
</p>
<p>Jose Pinheiro, Douglas Bates, Saikat DebRoy, Deepayan Sarkar and the R Development Core Team (2011). nlme: Linear and Nonlinear Mixed Effects Models. R package version 3.1-100.
</p>

<hr>
<h2 id='plot.midq2q'>
Plot Quantile Functions
</h2><span id='topic+plot.midq2q'></span>

<h3>Description</h3>

<p>Plot an object generated by <code><a href="#topic+midq2q">midq2q</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'midq2q'
plot(x, ..., xlab = "p", ylab = "Quantile",
	main = "Ordinary Quantile Function", sub = TRUE, verticals = TRUE,
	col.steps = "gray70", cex.points = 1, jumps = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.midq2q_+3A_x">x</code></td>
<td>

<p>a <code>midq2q</code> object.
</p>
</td></tr>
<tr><td><code id="plot.midq2q_+3A_...">...</code></td>
<td>

<p>additional arguments for <code><a href="graphics.html#topic+plot.default">plot.default</a></code>.
</p>
</td></tr>
<tr><td><code id="plot.midq2q_+3A_xlab">xlab</code></td>
<td>

<p>a label for the x axis.
</p>
</td></tr>
<tr><td><code id="plot.midq2q_+3A_ylab">ylab</code></td>
<td>

<p>a label for the y axis.
</p>
</td></tr>
<tr><td><code id="plot.midq2q_+3A_main">main</code></td>
<td>

<p>a main title for the plot.
</p>
</td></tr>
<tr><td><code id="plot.midq2q_+3A_sub">sub</code></td>
<td>

<p>if <code>TRUE</code>, a subtitle with indication of the row of <code>x</code>.
</p>
</td></tr>
<tr><td><code id="plot.midq2q_+3A_verticals">verticals</code></td>
<td>

<p>logical. If <code>TRUE</code>, draw vertical lines at steps.
</p>
</td></tr>
<tr><td><code id="plot.midq2q_+3A_col.steps">col.steps</code></td>
<td>

<p>the color for the steps of ordinary quantiles.
</p>
</td></tr>
<tr><td><code id="plot.midq2q_+3A_cex.points">cex.points</code></td>
<td>

<p>amount by which plotting characters and symbols should be scaled relative to the default. 
</p>
</td></tr>
<tr><td><code id="plot.midq2q_+3A_jumps">jumps</code></td>
<td>

<p>logical flag. Should values at jumps be marked?
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Marco Geraci
</p>


<h3>See Also</h3>

<p><code><a href="#topic+midq2q">midq2q</a></code>, <code><a href="#topic+midecdf">midecdf</a></code>, <code><a href="#topic+midquantile">midquantile</a></code>
</p>

<hr>
<h2 id='plot.midquantile'>
Plot Mid-distribution Functions
</h2><span id='topic+plot.midecdf'></span><span id='topic+plot.midquantile'></span>

<h3>Description</h3>

<p>Plot an object generated by <code><a href="#topic+midecdf">midecdf</a></code> or <code><a href="#topic+midquantile">midquantile</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'midecdf'
plot(x, ..., ylab = "p", main = "Ordinary and Mid-ECDF", verticals = FALSE,
	col.01line = "gray70", col.steps = "gray70", col.midline ="black", cex.points = 1,
	lty.midline = 2, lwd = 1, jumps = FALSE)
## S3 method for class 'midquantile'
plot(x, ..., xlab = "p", ylab = "Quantile", main = "Ordinary and Mid-Quantiles",
	col.steps = "gray70", col.midline = "black", cex.points = 1, lty.midline = 2,
	lwd = 1, jumps = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.midquantile_+3A_x">x</code></td>
<td>

<p>a <code>midecdf</code> or a <code>midquantile</code> object.
</p>
</td></tr>
<tr><td><code id="plot.midquantile_+3A_...">...</code></td>
<td>

<p>additional arguments for <code><a href="graphics.html#topic+plot.default">plot.default</a></code>.
</p>
</td></tr>
<tr><td><code id="plot.midquantile_+3A_xlab">xlab</code></td>
<td>

<p>a label for the x axis.
</p>
</td></tr>
<tr><td><code id="plot.midquantile_+3A_ylab">ylab</code></td>
<td>

<p>a label for the y axis.
</p>
</td></tr>
<tr><td><code id="plot.midquantile_+3A_main">main</code></td>
<td>

<p>a main title for the plot.
</p>
</td></tr>
<tr><td><code id="plot.midquantile_+3A_verticals">verticals</code></td>
<td>

<p>logical. If <code>TRUE</code>, draw vertical lines at steps.
</p>
</td></tr>
<tr><td><code id="plot.midquantile_+3A_col.01line">col.01line</code></td>
<td>

<p>numeric or character specifying the color of the horizontal lines at y = 0 and 1.
</p>
</td></tr>
<tr><td><code id="plot.midquantile_+3A_col.steps">col.steps</code></td>
<td>

<p>the color for the steps of ordinary quantiles.
</p>
</td></tr>
<tr><td><code id="plot.midquantile_+3A_col.midline">col.midline</code></td>
<td>

<p>the color for the mid-ecdf or the mid-quantile line.
</p>
</td></tr>
<tr><td><code id="plot.midquantile_+3A_cex.points">cex.points</code></td>
<td>

<p>amount by which plotting characters and symbols should be scaled relative to the default. 
</p>
</td></tr>
<tr><td><code id="plot.midquantile_+3A_lty.midline">lty.midline</code></td>
<td>

<p>line type for the mid-ecdf or the mid-quantile line.
</p>
</td></tr>
<tr><td><code id="plot.midquantile_+3A_lwd">lwd</code></td>
<td>

<p>line width of the mid-ecdf or the mid-quantile line. 
</p>
</td></tr>
<tr><td><code id="plot.midquantile_+3A_jumps">jumps</code></td>
<td>

<p>logical flag. Should values at jumps be marked (with the convention that, at the point of discontinuity or 'jump', the function takes its value corresponding to the ordinate of the filled circle as opposed to that of the hollow circle)?
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Marco Geraci
</p>


<h3>See Also</h3>

<p><code><a href="#topic+midecdf">midecdf</a></code>, <code><a href="#topic+midquantile">midquantile</a></code>
</p>

<hr>
<h2 id='plot.qlss'>
Quantile-based Summary Statistics for Location, Scale and Shape
</h2><span id='topic+plot.qlss'></span>

<h3>Description</h3>

<p>This function plots location, scale and shape of a conditional distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'qlss'
plot(x, z, whichp = NULL, interval = FALSE, type = "l", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.qlss_+3A_x">x</code></td>
<td>

<p>an object of class <code>qlss</code> as returned by <code><a href="#topic+qlss.formula">qlss.formula</a></code>.
</p>
</td></tr>
<tr><td><code id="plot.qlss_+3A_z">z</code></td>
<td>

<p>numeric vector of values against which LSS measures are plotted. This argument is required.
</p>
</td></tr>
<tr><td><code id="plot.qlss_+3A_whichp">whichp</code></td>
<td>

<p>when <code>probs</code> in <code>qlss</code> is a vector, the argument <code>whichp</code> specifies one of the probabilities (and one only) in <code>probs</code> that should be used for plotting. If <code>whichp = NULL</code> (default), the first value in <code>probs</code> is used.
</p>
</td></tr>
<tr><td><code id="plot.qlss_+3A_interval">interval</code></td>
<td>

<p>logical flag. If <code>TRUE</code>, confidence intervals for the predictions are plotted.
</p>
</td></tr>
<tr><td><code id="plot.qlss_+3A_type">type</code></td>
<td>

<p>1-character string giving the type of plot desired. See <code><a href="graphics.html#topic+plot.default">plot.default</a></code>.
</p>
</td></tr>
<tr><td><code id="plot.qlss_+3A_...">...</code></td>
<td>

<p>other arguments for <code><a href="graphics.html#topic+plot.default">plot.default</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function plots a <code>qlss</code> object from <code><a href="#topic+qlss">qlss</a></code> or <code><a href="#topic+predict.qlss">predict.qlss</a></code>.
</p>


<h3>Author(s)</h3>

<p>Marco Geraci
</p>


<h3>See Also</h3>

<p><code><a href="#topic+qlss">qlss</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
trees2 &lt;- trees[order(trees$Height),]
fit &lt;- qlss(Volume ~ Height, data = trees2, probs = c(.05, .1))
# Plot the results for probs = 0.1
plot(fit, z = trees2$Height, whichp = 0.1, xlab = "height")

</code></pre>

<hr>
<h2 id='predict.midrq'>
Predictions from Mid-Quantile Regression Models
</h2><span id='topic+predict.midrq'></span>

<h3>Description</h3>

<p>This function computes predictions based on fitted mid-quantile regression models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'midrq'
predict(object, newdata, offset, na.action = na.pass,
	type = "response", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.midrq_+3A_object">object</code></td>
<td>

<p>an object of <code><a href="base.html#topic+class">class</a></code> <code>midrq</code>.
</p>
</td></tr>
<tr><td><code id="predict.midrq_+3A_newdata">newdata</code></td>
<td>

<p>an optional data frame in which to look for variables with which to predict. If omitted, the fitted values are used.
</p>
</td></tr>
<tr><td><code id="predict.midrq_+3A_offset">offset</code></td>
<td>

<p>an optional offset to be included in the model frame (when <code>newdata</code> is provided).
</p>
</td></tr>
<tr><td><code id="predict.midrq_+3A_na.action">na.action</code></td>
<td>

<p>function determining what should be done with missing values in <code>newdata</code>. The default is to predict <code>NA</code>.
</p>
</td></tr>
<tr><td><code id="predict.midrq_+3A_type">type</code></td>
<td>

<p>the type of prediction required. The default <code>"response"</code> is on the scale of the response variable, i.e. the values are back-transformed using the inverse of the transformation <code class="reqn">h^{-1}(Xb)</code>; the alternative <code>"link"</code> is on the scale of the linear predictors <code class="reqn">h(y) = Xb</code>.
</p>
</td></tr>
<tr><td><code id="predict.midrq_+3A_...">...</code></td>
<td>

<p>not used.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector or a matrix or an array of predictions.
</p>


<h3>Author(s)</h3>

<p>Marco Geraci
</p>


<h3>See Also</h3>

<p><code><a href="#topic+residuals.midrq">residuals.midrq</a></code>, <code><a href="#topic+midrq">midrq</a></code>, <code><a href="#topic+coef.midrq">coef.midrq</a></code>
</p>

<hr>
<h2 id='predict.qlss'>
Predictions from Conditional LSS Objects
</h2><span id='topic+predict.qlss'></span>

<h3>Description</h3>

<p>This function computes predictions based on fitted conditional QLSS objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'qlss'
predict(object, newdata, interval = FALSE, level = 0.95, R = 200,
	na.action = na.pass, trim = 0.05, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.qlss_+3A_object">object</code></td>
<td>

<p>an object as returned by <code><a href="#topic+qlss.formula">qlss.formula</a></code>.
</p>
</td></tr>
<tr><td><code id="predict.qlss_+3A_newdata">newdata</code></td>
<td>

<p>an optional data frame in which to look for variables with which to predict. If omitted, the fitted values are used.
</p>
</td></tr>
<tr><td><code id="predict.qlss_+3A_interval">interval</code></td>
<td>

<p>logical flag. If <code>TRUE</code>, confidence intervals for predictions are computed by bootstrap.
</p>
</td></tr>
<tr><td><code id="predict.qlss_+3A_level">level</code></td>
<td>

<p>nominal coverage level of the confidence interval.
</p>
</td></tr>
<tr><td><code id="predict.qlss_+3A_r">R</code></td>
<td>

<p>number of bootstrap replications used to compute confidence intervals.
</p>
</td></tr>
<tr><td><code id="predict.qlss_+3A_na.action">na.action</code></td>
<td>

<p>function determining what should be done with missing values in <code>newdata</code>. The default is to predict <code>NA</code>.
</p>
</td></tr>
<tr><td><code id="predict.qlss_+3A_trim">trim</code></td>
<td>

<p>proportion of extreme bootstrap replications to be trimmed before standard errors are computed.
</p>
</td></tr>
<tr><td><code id="predict.qlss_+3A_...">...</code></td>
<td>

<p>not used.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Marco Geraci
</p>


<h3>See Also</h3>

<p><code><a href="#topic+qlss.formula">qlss.formula</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
# Fit QLSS object
trees2 &lt;- trees[order(trees$Height),]
fit &lt;- qlss(Volume ~ Height, data = trees2)

## Predict using newdata. Calculate confidence intervals using 200 bootstrap replications
# large confidence intervals for shape index due to small IQR at low values of height
#xx &lt;- seq(min(trees2$Height), max(trees2$Height), length = 100)
#new &lt;- data.frame(Height = xx)
#set.seed(121)
#fit.pred &lt;- predict(fit, newdata = new, interval = TRUE, level = 0.95, R = 200)
#plot(fit.pred, z = xx, interval = TRUE, xlab = "height")

# Restrict range for Height

xx &lt;- seq(65, 87, length = 100)
new &lt;- data.frame(Height = xx)
set.seed(121)
fit.pred &lt;- predict(fit, newdata = new, interval = TRUE, level = 0.95, R = 200)
plot(fit.pred, z = xx, interval = TRUE, xlab = "height") # better


## End(Not run)
</code></pre>

<hr>
<h2 id='predict.qrr'>
Predictions from Quantile Ratio Regression Models
</h2><span id='topic+predict.qrr'></span>

<h3>Description</h3>

<p>This function computes predictions based on quantile ratio regression models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'qrr'
predict(object, newdata, na.action = na.pass,
type = "response", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.qrr_+3A_object">object</code></td>
<td>

<p>an object of <code><a href="base.html#topic+class">class</a></code> <code>qrr</code>.
</p>
</td></tr>
<tr><td><code id="predict.qrr_+3A_newdata">newdata</code></td>
<td>

<p>an optional data frame in which to look for variables with which to predict. If omitted, the fitted values are used.
</p>
</td></tr>
<tr><td><code id="predict.qrr_+3A_na.action">na.action</code></td>
<td>

<p>function determining what should be done with missing values in <code>newdata</code>. The default is to predict <code>NA</code>.
</p>
</td></tr>
<tr><td><code id="predict.qrr_+3A_type">type</code></td>
<td>

<p>the type of prediction required. The default <code>"response"</code> is on the scale of the response variable, i.e. the values are back-transformed using the inverse of the link function <code class="reqn">g^{-1}(Xb) = 1 + exp(Xb)</code>; the alternative <code>"link"</code> is on the scale of the linear predictor.
</p>
</td></tr>
<tr><td><code id="predict.qrr_+3A_...">...</code></td>
<td>

<p>not used.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of predictions.
</p>


<h3>Author(s)</h3>

<p>Marco Geraci
</p>


<h3>See Also</h3>

<p><code><a href="#topic+qrr">qrr</a></code>
</p>

<hr>
<h2 id='predict.rq.counts'>
Predictions from rq.counts Objects
</h2><span id='topic+predict.rq.counts'></span>

<h3>Description</h3>

<p>This function computes predictions based on fitted linear quantile models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'rq.counts'
predict(object, newdata, offset,
	na.action = na.pass, type = "response",
	namevec = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.rq.counts_+3A_object">object</code></td>
<td>

<p>an <code>rq.counts</code> object.
</p>
</td></tr>
<tr><td><code id="predict.rq.counts_+3A_newdata">newdata</code></td>
<td>

<p>an optional data frame in which to look for variables with which to predict. If omitted, the fitted values are used.
</p>
</td></tr>
<tr><td><code id="predict.rq.counts_+3A_offset">offset</code></td>
<td>

<p>an offset to be used with <code>newdata</code>.
</p>
</td></tr>
<tr><td><code id="predict.rq.counts_+3A_na.action">na.action</code></td>
<td>

<p>function determining what should be done with missing values in <code>newdata</code>. The default is to predict <code>NA</code>.</p>
</td></tr>
<tr><td><code id="predict.rq.counts_+3A_type">type</code></td>
<td>

<p>the type of prediction required. The default <code>"response"</code> is on the scale of the response variable, i.e. the values are back-transformed using the inverse of the transformation <code class="reqn">h^{-1}(Xb)</code>; the alternative <code>"link"</code> is on the scale of the linear predictors <code class="reqn">h(y) = Xb</code>; finally, predictions for marginal effects are given with <code>"maref"</code>.
</p>
</td></tr>
<tr><td><code id="predict.rq.counts_+3A_namevec">namevec</code></td>
<td>

<p>character giving the name of the covariate with respect to which the marginal effect is to be computed. If <code>type = "maref"</code>, this argument is required. See <code><a href="#topic+maref.rq.counts">maref.rq.counts</a></code>.
</p>
</td></tr>
<tr><td><code id="predict.rq.counts_+3A_...">...</code></td>
<td>

<p>not used.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector or a matrix or an array of predictions.
</p>


<h3>Author(s)</h3>

<p>Marco Geraci
</p>


<h3>See Also</h3>

<p><code><a href="#topic+residuals.rq.counts">residuals.rq.counts</a></code>, <code><a href="#topic+rq.counts">rq.counts</a></code>, <code><a href="#topic+coef.rq.counts">coef.rq.counts</a></code>, <code><a href="#topic+maref.rq.counts">maref.rq.counts</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Esterase data
data(esterase)

# Fit quantiles 0.25 and 0.75
fit &lt;- rq.counts(Count ~ Esterase, tau = 0.5, data = esterase, M = 50)
cbind(fit$fitted.values, predict(fit, type = "response"))

</code></pre>

<hr>
<h2 id='predict.rqt'>
Predictions from Quantile Regression Transformation Models
</h2><span id='topic+predict.rqt'></span>

<h3>Description</h3>

<p>This function computes predictions based on fitted quantile regression transformation models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'rqt'
predict(object, newdata, na.action = na.pass,
type = "response", namevec = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.rqt_+3A_object">object</code></td>
<td>

<p>an object of <code><a href="base.html#topic+class">class</a></code> <code>rqt</code>.
</p>
</td></tr>
<tr><td><code id="predict.rqt_+3A_newdata">newdata</code></td>
<td>

<p>an optional data frame in which to look for variables with which to predict. If omitted, the fitted values are used.
</p>
</td></tr>
<tr><td><code id="predict.rqt_+3A_na.action">na.action</code></td>
<td>

<p>function determining what should be done with missing values in <code>newdata</code>. The default is to predict <code>NA</code>.
</p>
</td></tr>
<tr><td><code id="predict.rqt_+3A_type">type</code></td>
<td>

<p>the type of prediction required. The default <code>"response"</code> is on the scale of the response variable, i.e. the values are back-transformed using the inverse of the transformation <code class="reqn">h^{-1}(Xb)</code>; the alternative <code>"link"</code> is on the scale of the linear predictors <code class="reqn">h(y) = Xb</code>; finally, predictions for marginal effects are given with <code>"maref"</code>.
</p>
</td></tr>
<tr><td><code id="predict.rqt_+3A_namevec">namevec</code></td>
<td>

<p>character giving the name of the covariate with respect to which the marginal effect is to be computed. If <code>type = "maref"</code>, this argument is required. See <code><a href="#topic+maref.rqt">maref.rqt</a></code>.
</p>
</td></tr>
<tr><td><code id="predict.rqt_+3A_...">...</code></td>
<td>

<p>not used.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector or a matrix or an array of predictions.
</p>


<h3>Author(s)</h3>

<p>Marco Geraci
</p>


<h3>See Also</h3>

<p><code><a href="#topic+residuals.rqt">residuals.rqt</a></code>, <code><a href="#topic+tsrq">tsrq</a></code>, <code><a href="#topic+coef.rqt">coef.rqt</a></code>, <code><a href="#topic+maref.rqt">maref.rqt</a></code>
</p>

<hr>
<h2 id='predict.rrq'>
Predictions from Restricted Quantile Regression Models
</h2><span id='topic+predict.rrq'></span>

<h3>Description</h3>

<p>This function computes predictions based on fitted restricted quantile regression models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'rrq'
predict(object, newdata, na.action = na.pass, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.rrq_+3A_object">object</code></td>
<td>

<p>an object of <code><a href="base.html#topic+class">class</a></code> <code>rrq</code>.
</p>
</td></tr>
<tr><td><code id="predict.rrq_+3A_newdata">newdata</code></td>
<td>

<p>an optional data frame in which to look for variables with which to predict. If omitted, the fitted values are used.
</p>
</td></tr>
<tr><td><code id="predict.rrq_+3A_na.action">na.action</code></td>
<td>

<p>function determining what should be done with missing values in <code>newdata</code>. The default is to predict <code>NA</code>.
</p>
</td></tr>
<tr><td><code id="predict.rrq_+3A_...">...</code></td>
<td>

<p>not used.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector or a matrix or an array of predictions.
</p>


<h3>Author(s)</h3>

<p>Marco Geraci
</p>

<hr>
<h2 id='print.cmidecdf'>
Print Mid-distribution Functions
</h2><span id='topic+print.cmidecdf'></span>

<h3>Description</h3>

<p>Print an object generated by <code><a href="#topic+cmidecdf">cmidecdf</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cmidecdf'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.cmidecdf_+3A_x">x</code></td>
<td>

<p>a <code>midecdf</code> or a <code>midquantile</code> object.
</p>
</td></tr>
<tr><td><code id="print.cmidecdf_+3A_...">...</code></td>
<td>

<p>not used.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Marco Geraci
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cmidecdf">cmidecdf</a></code>
</p>

<hr>
<h2 id='print.dqc'>
Print Directional Quantile Classification Objects
</h2><span id='topic+print.dqc'></span>

<h3>Description</h3>

<p>Print an object of class <code>dqc</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dqc'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.dqc_+3A_x">x</code></td>
<td>

<p>an object of <code><a href="base.html#topic+class">class</a></code> <code>dqc</code>.
</p>
</td></tr>
<tr><td><code id="print.dqc_+3A_...">...</code></td>
<td>

<p>other arguments used by <code><a href="base.html#topic+print.default">print.default</a></code>.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Marco Geraci
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dqc">dqc</a></code>
</p>

<hr>
<h2 id='print.GOFTest'>
Print Goodness-of-Fit Test for Quantile Regression Models
</h2><span id='topic+print.GOFTest'></span>

<h3>Description</h3>

<p>Print an object generated by <code><a href="#topic+GOFTest">GOFTest</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'GOFTest'
print(x, digits = max(3, getOption("digits") - 3), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.GOFTest_+3A_x">x</code></td>
<td>

<p>an <code>GOFTest</code> object.
</p>
</td></tr>
<tr><td><code id="print.GOFTest_+3A_digits">digits</code></td>
<td>

<p>a non-null value for digits specifies the minimum number of significant digits to be printed in values.
</p>
</td></tr>
<tr><td><code id="print.GOFTest_+3A_...">...</code></td>
<td>

<p>not used.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Marco Geraci
</p>


<h3>See Also</h3>

<p><code><a href="#topic+GOFTest">GOFTest</a></code>
</p>

<hr>
<h2 id='print.midquantile'>
Print Mid-distribution Functions
</h2><span id='topic+print.midecdf'></span><span id='topic+print.midquantile'></span>

<h3>Description</h3>

<p>Print an object generated by <code><a href="#topic+midecdf">midecdf</a></code> or <code><a href="#topic+midquantile">midquantile</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'midecdf'
print(x, ...)
## S3 method for class 'midquantile'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.midquantile_+3A_x">x</code></td>
<td>

<p>a <code>midecdf</code> or a <code>midquantile</code> object.
</p>
</td></tr>
<tr><td><code id="print.midquantile_+3A_...">...</code></td>
<td>

<p>not used.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Marco Geraci
</p>


<h3>See Also</h3>

<p><code><a href="#topic+midecdf">midecdf</a></code>, <code><a href="#topic+midquantile">midquantile</a></code>
</p>

<hr>
<h2 id='print.midrq'>
Print Mid-Quantile Models
</h2><span id='topic+print.summary.midrq'></span><span id='topic+print.midrq'></span>

<h3>Description</h3>

<p>Print an object of class <code>midrq</code> or <code>summary.midrq</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'midrq'
print(x, ...)
## S3 method for class 'summary.midrq'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.midrq_+3A_x">x</code></td>
<td>

<p>an object of <code><a href="base.html#topic+class">class</a></code> <code>midrq</code> or <code>summary.midrq</code>.
</p>
</td></tr>
<tr><td><code id="print.midrq_+3A_...">...</code></td>
<td>

<p>other arguments used by <code><a href="base.html#topic+print.default">print.default</a></code>.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Marco Geraci
</p>


<h3>See Also</h3>

<p><code><a href="#topic+midrq">midrq</a></code>
</p>

<hr>
<h2 id='print.qlss'>
Print Quantile-based Summary Statistics for Location, Scale and Shape
</h2><span id='topic+print.qlss'></span>

<h3>Description</h3>

<p>Print an object generated by <code><a href="#topic+qlss">qlss</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'qlss'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.qlss_+3A_x">x</code></td>
<td>

<p>an <code>qlss</code> object.
</p>
</td></tr>
<tr><td><code id="print.qlss_+3A_...">...</code></td>
<td>

<p>not used.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Marco Geraci
</p>


<h3>See Also</h3>

<p><code><a href="#topic+qlss">qlss</a></code>
</p>

<hr>
<h2 id='print.qrr'>
Print Quantile Ratio Regression Models
</h2><span id='topic+print.summary.qrr'></span><span id='topic+print.qrr'></span>

<h3>Description</h3>

<p>Print an object of class <code>qrr</code> or <code>summary.qrr</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'qrr'
print(x, ...)
## S3 method for class 'summary.qrr'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.qrr_+3A_x">x</code></td>
<td>

<p>an object of <code><a href="base.html#topic+class">class</a></code> <code>qrr</code> or <code>summary.qrr</code>.
</p>
</td></tr>
<tr><td><code id="print.qrr_+3A_...">...</code></td>
<td>

<p>other arguments used by <code><a href="base.html#topic+print.default">print.default</a></code>.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Marco Geraci
</p>


<h3>See Also</h3>

<p><code><a href="#topic+qrr">qrr</a></code>
</p>

<hr>
<h2 id='print.rq.counts'>
Print rq.counts
</h2><span id='topic+print.rq.counts'></span>

<h3>Description</h3>

<p>Print an object generated by <code><a href="#topic+rq.counts">rq.counts</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'rq.counts'
print(x, digits = max(3, getOption("digits") - 3), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.rq.counts_+3A_x">x</code></td>
<td>

<p>an <code>rq.counts</code> object.
</p>
</td></tr>
<tr><td><code id="print.rq.counts_+3A_digits">digits</code></td>
<td>

<p>a non-null value for digits specifies the minimum number of significant digits to be printed in values.
</p>
</td></tr>
<tr><td><code id="print.rq.counts_+3A_...">...</code></td>
<td>

<p>not used.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Marco Geraci
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rq.counts">rq.counts</a></code>
</p>

<hr>
<h2 id='print.rqt'>
Print Transformation Models
</h2><span id='topic+print.summary.rqt'></span><span id='topic+print.rqt'></span>

<h3>Description</h3>

<p>Print an object of class <code>rqt</code> or <code>summary.rqt</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'rqt'
print(x, ...)
## S3 method for class 'summary.rqt'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.rqt_+3A_x">x</code></td>
<td>

<p>an object of <code><a href="base.html#topic+class">class</a></code> <code>rqt</code> or <code>summary.rqt</code>.
</p>
</td></tr>
<tr><td><code id="print.rqt_+3A_...">...</code></td>
<td>

<p>other arguments used by <code><a href="base.html#topic+print.default">print.default</a></code>.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Marco Geraci
</p>


<h3>See Also</h3>

<p><code><a href="#topic+tsrq">tsrq</a></code>, <code><a href="#topic+rcrq">rcrq</a></code>, <code><a href="#topic+tsrq2">tsrq2</a></code> or <code><a href="#topic+nlrq2">nlrq2</a></code>
</p>

<hr>
<h2 id='print.rrq'>
Print Restricted Quantile Regression Models
</h2><span id='topic+print.summary.rrq'></span><span id='topic+print.rrq'></span>

<h3>Description</h3>

<p>Print an object of class <code>rrq</code> or <code>summary.rrq</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'rrq'
print(x, ...)
## S3 method for class 'summary.rrq'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.rrq_+3A_x">x</code></td>
<td>

<p>an object of <code><a href="base.html#topic+class">class</a></code> <code>rrq</code> or <code>summary.rrq</code>.
</p>
</td></tr>
<tr><td><code id="print.rrq_+3A_...">...</code></td>
<td>

<p>other arguments used by <code><a href="base.html#topic+print.default">print.default</a></code>.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Marco Geraci
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rrq">rrq</a></code>
</p>

<hr>
<h2 id='qexact'>
Exact Confidence Intervals for Quantiles
</h2><span id='topic+qexact'></span>

<h3>Description</h3>

<p>Compute exact confidence intervals for quantiles of continuous random variables using binomial probabilities
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qexact(x, probs = 0.5, level = 0.95)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="qexact_+3A_x">x</code></td>
<td>

<p>numeric vector whose sample quantile and confidence intervals are to be calculated.
</p>
</td></tr>
<tr><td><code id="qexact_+3A_probs">probs</code></td>
<td>

<p>numeric vector of probabilities with values in <code>[0,1]</code>.
</p>
</td></tr>
<tr><td><code id="qexact_+3A_level">level</code></td>
<td>

<p>nominal coverage level of the confidence interval.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function calculates exact confidence intervals for quantiles at level <code>probs</code> from a vector <code>x</code> of length <code>n</code>. It does so by first determining the confidence level for all possible pairwise combinations of order statistics from 1 to <code>n</code>. This entails &quot;<code>n</code> choose <code>2</code>&quot; possible confidence intervals before selecting the one with the level closest to <code>level</code>. If the procedure yields more than one such confidence intervals, then the interval with smallest width is returned.
</p>
<p>Caution: for large <code>n</code>, the procedure may reach the limit on the number of nested expressions. See <code>gtools::combinations</code> and <code><a href="base.html#topic+options">options</a>(expressions)</code> for additional information. However, if you have a large <code>n</code>, then consider estimating an asymptotic approximation of the confidence interval.
</p>


<h3>Author(s)</h3>

<p>Marco Geraci
</p>


<h3>References</h3>

<p>Thompson W. R. On confidence ranges for the median and other expectation distributions for populations of unknown distribution form. The Annals of Mathematical Statistics 1936;7(3):122-128.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rnorm(100)
qexact(x, p = c(0.1,0.5), level = 0.9)
</code></pre>

<hr>
<h2 id='qlss'>
Quantile-based Summary Statistics for Location, Scale and Shape
</h2><span id='topic+qlss.default'></span><span id='topic+qlss.formula'></span><span id='topic+qlss.numeric'></span><span id='topic+qlss'></span>

<h3>Description</h3>

<p>This function calculates quantile-based summary statistics for location, scale and shape of a distribution, unconditional or conditional.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qlss(...)
## Default S3 method:
qlss(fun = "qnorm", probs = 0.1, ...)
## S3 method for class 'numeric'
qlss(x, probs = 0.1, ...)
## S3 method for class 'formula'
qlss(formula, probs = 0.1, data = sys.frame(sys.parent()), subset, weights,
	na.action, contrasts = NULL, method = "fn", type = "rq", tsf = "mcjI",
	symm = TRUE, dbounded = FALSE, lambda = NULL, conditional = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="qlss_+3A_fun">fun</code></td>
<td>

<p>quantile function.
</p>
</td></tr>
<tr><td><code id="qlss_+3A_x">x</code></td>
<td>

<p>a numeric vector.
</p>
</td></tr>
<tr><td><code id="qlss_+3A_formula">formula</code></td>
<td>

<p>an object of class <code><a href="stats.html#topic+formula">formula</a></code>: a symbolic description of the model to be fitted. The details of model specification are given under &quot;Details&quot;.
</p>
</td></tr>
<tr><td><code id="qlss_+3A_probs">probs</code></td>
<td>

<p>a vector of probabilities.
</p>
</td></tr>
<tr><td><code id="qlss_+3A_data">data</code></td>
<td>

<p>an optional data frame, list or environment (or object coercible by as.data.frame to a data frame) containing the variables in the model. By default the variables are taken from the environment from which the call is made.
</p>
</td></tr>
<tr><td><code id="qlss_+3A_subset">subset</code></td>
<td>

<p>an optional vector specifying a subset of observations to be used in the fitting process.
</p>
</td></tr>
<tr><td><code id="qlss_+3A_weights">weights</code></td>
<td>

<p>an optional vector of weights to be used in the fitting process. Should be NULL or a numeric vector. 
</p>
</td></tr>
<tr><td><code id="qlss_+3A_na.action">na.action</code></td>
<td>

<p>a function which indicates what should happen when the data contain <code>NA</code>s.
</p>
</td></tr>
<tr><td><code id="qlss_+3A_contrasts">contrasts</code></td>
<td>

<p>an optional list. See the <code>contrasts.arg</code> of <code><a href="stats.html#topic+model.matrix.default">model.matrix.default</a></code>.
</p>
</td></tr>
<tr><td><code id="qlss_+3A_method">method</code></td>
<td>

<p>the algorithm used to solve the linear program. See <code><a href="quantreg.html#topic+rq">rq</a></code> for further details. The Frisch-Newton interior point method is the default.
</p>
</td></tr>
<tr><td><code id="qlss_+3A_type">type</code></td>
<td>

<p>possible options are <code>rq</code> for linear quantile regression (default) or <code>rqt</code> for transformation-based quantile regression.
</p>
</td></tr>
<tr><td><code id="qlss_+3A_tsf">tsf</code></td>
<td>

<p>transformation to be used. Possible options are <code>mcjI</code> for Proposal I transformation models (default), <code>bc</code> for Box-Cox and <code>ao</code> for Aranda-Ordaz transformation models. See <code><a href="#topic+tsrq">tsrq</a></code> for further details.
</p>
</td></tr>
<tr><td><code id="qlss_+3A_symm">symm</code></td>
<td>

<p>logical flag. If <code>TRUE</code> (default) a symmetric transformation is used.
</p>
</td></tr>
<tr><td><code id="qlss_+3A_dbounded">dbounded</code></td>
<td>

<p>logical flag. If <code>TRUE</code> the response is assumed to be doubly bounded on [a,b]. If <code>FALSE</code> the response is assumed to be singly bounded (ie, strictly positive).
</p>
</td></tr>
<tr><td><code id="qlss_+3A_lambda">lambda</code></td>
<td>

<p>values of transformation parameters for grid search.
</p>
</td></tr>
<tr><td><code id="qlss_+3A_conditional">conditional</code></td>
<td>

<p>logical flag. If <code>TRUE</code>, the transformation parameter is assumed to be known and this must be provided via the arguments <code>lambda</code> using a vector of length <code>3 + 2 x length(probs)</code> (see details).
</p>
</td></tr>
<tr><td><code id="qlss_+3A_...">...</code></td>
<td>

<p>other arguments for <code>fun</code>, <code>rq</code> or <code>tsrq</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function computes a number of quantile-based summary statistics for location (median), scale (inter-quartile range and inter-quantile range), and shape (Bowley skewness and shape index) of a distribution. These statistics can be computed for unconditional and conditional distributions.
</p>
<p>Let <code class="reqn">Y</code> be a continuous random variable and let <code class="reqn">Q(p)</code> be its <em>p</em>th quantile. The function <code>qlss</code> computes the median <code class="reqn">Q(0.5)</code>, the inter-quartile range <code class="reqn">IQR = Q(0.75) - Q(0.25)</code>, the inter-quantile range <code class="reqn">IPR(p) = Q(1-p) - Q(p)</code>, the Bowley skewness index <code class="reqn">A(p) = (Q(1-p) + Q(p) - 2Q(0.5))/IPR(p)</code>, and the shape index <code class="reqn">T(p) = IPR(p)/IQR</code>, for <code class="reqn">0 &lt; p &lt; 0.25</code>.
</p>
<p>The default <code>qlss</code> function computes the summary statistics of a standard normal distribution or any other theoretical distribution via the argument <code>fun</code>. The latter must be a function with <code>p</code> as its probability argument (see for example <code><a href="stats.html#topic+qnorm">qnorm</a></code>, <code><a href="stats.html#topic+qt">qt</a></code>, <code><a href="stats.html#topic+qchisq">qchisq</a></code>, <code><a href="stats.html#topic+qgamma">qgamma</a></code>, etc.). When a variable <code>x</code> is provided, LSS measures are computed using empirical (sample) quantiles.
</p>
<p>The argument <code>formula</code> specifies a quantile function for <code class="reqn">Y</code> conditional on predictors <code class="reqn">X</code>. Linear models are fitted via standard quantile regression with <code>type = "rq"</code>. Nonlinear models are fitted via transformation-based quantile regression with <code>type = "rqt"</code> (proposal II transformation models are not available.). When <code>conditional = TRUE</code>, <code>lambda</code> is a vector of transformation parameters of length <code>3 + 2 x np</code>, where <code>np = length(probs)</code> (3 quartiles, <code>np</code> quantiles at level <code class="reqn">p</code>, <code>np</code> quantiles at level <code class="reqn">1 - p</code>).
</p>


<h3>Value</h3>

<p><code>qlss</code> returns an object of <code><a href="base.html#topic+class">class</a></code> <code>qlss</code>. This is a list that contains at least three elements:
</p>
<table>
<tr><td><code>location</code></td>
<td>
<p>summary statistic(s) for location.</p>
</td></tr>
<tr><td><code>scale</code></td>
<td>
<p>summary statistic(s) for scale.</p>
</td></tr>
<tr><td><code>shape</code></td>
<td>
<p>summary statistic(s) for shape.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Marco Geraci
</p>


<h3>References</h3>

<p>Geraci M and Jones MC. Improved transformation-based quantile regression. Canadian Journal of Statistics 2015;43(1):118-132.
</p>
<p>Gilchrist W. Statistical modelling with quantile functions. Chapman and Hall/CRC; 2000.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+predict.qlss">predict.qlss</a></code>, <code><a href="#topic+plot.qlss">plot.qlss</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Compute summary statistics of a normal distribution
qlss()

# Compute summary statistics of a t distribution with 3 df
qlss(fun = "qt", df = 3, probs = 0.05)

# Compute summary statistics for a sample using a sequence of probabilities
x &lt;- rnorm(1000)
qlss(x, probs = c(0.1, 0.2, 0.3, 0.4))

# Compute summary statistics for Volume conditional on Height
trees2 &lt;- trees[order(trees$Height),]
fit &lt;- qlss(Volume ~ Height, data = trees2)
plot(fit, z = trees2$Height, xlab = "height")

# Use a quadratic model for Height
fit &lt;- qlss(Volume ~ poly(Height,2), data = trees2)
plot(fit, z = trees2$Height, xlab = "height")


</code></pre>

<hr>
<h2 id='qrr'>
Quantile Ratio Regression
</h2><span id='topic+qrr'></span>

<h3>Description</h3>

<p>This function fits a quantile ratio regression model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qrr(formula, data, taus, start = "rq", beta = NULL,
tsf = "bc", symm = TRUE, dbounded = FALSE, linearize = TRUE, 
kernel = "Gaussian", maxIter = 10, epsilon = 1e-05,
verbose = FALSE, method.rq = "fn", method.nlrq = "L-BFGS-B")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="qrr_+3A_formula">formula</code></td>
<td>

<p>a formula object, with the response on the left of a <code>~</code> operator, and the terms, separated by <code>+</code> operators, on the right.
</p>
</td></tr>
<tr><td><code id="qrr_+3A_data">data</code></td>
<td>

<p>a data frame in which to interpret the variables named in the formula.
</p>
</td></tr>
<tr><td><code id="qrr_+3A_taus">taus</code></td>
<td>

<p>a vector of two quantiles for the ratio to be estimated (the order is irrelevant).
</p>
</td></tr>
<tr><td><code id="qrr_+3A_start">start</code></td>
<td>

<p>the algorithm with which obtain the starting values for one of the quantiles in the ratio. Possible options are <code>"rq"</code> (linear regression model &ndash; see <code><a href="quantreg.html#topic+rq">rq</a></code>), <code>"tsrq"</code> (quantile regression transformation model &ndash; see <code><a href="#topic+tsrq">tsrq</a></code>), <code>"conquer"</code> (fast linear regression model &ndash; see <code><a href="conquer.html#topic+conquer">conquer</a></code>), <code>"llqr"</code> (nonparametric linear regression model &ndash; see <code><a href="quantdr.html#topic+llqr">llqr</a></code>)
</p>
</td></tr>
<tr><td><code id="qrr_+3A_beta">beta</code></td>
<td>

<p>starting values for the regression coefficients. If left <code>NULL</code>, these are set to 0.
</p>
</td></tr>
<tr><td><code id="qrr_+3A_tsf">tsf</code></td>
<td>

<p>if <code>start = "tsrq"</code>, see <code><a href="#topic+tsrq">tsrq</a></code>.
</p>
</td></tr>
<tr><td><code id="qrr_+3A_symm">symm</code></td>
<td>

<p>if <code>start = "tsrq"</code>, see <code><a href="#topic+tsrq">tsrq</a></code>.
</p>
</td></tr>
<tr><td><code id="qrr_+3A_dbounded">dbounded</code></td>
<td>

<p>if <code>start = "tsrq"</code>, see <code><a href="#topic+tsrq">tsrq</a></code>.
</p>
</td></tr>
<tr><td><code id="qrr_+3A_linearize">linearize</code></td>
<td>

<p>logical flag. If <code>TRUE</code> (default), estimation is carried out with the linearized iterative algorithm of Farcomeni and Geraci (2023) by repeated calls to an appropriate linear estimation algorithm. Otherwise, the algorithm calls a nonlinear estimation routine. See argument <code>method.rq</code> and <code>method.nlrq</code> further below.
</p>
</td></tr>
<tr><td><code id="qrr_+3A_kernel">kernel</code></td>
<td>

<p>an optional vector of weights to be used in the fitting process. Should be NULL or a numeric vector. 
</p>
</td></tr>
<tr><td><code id="qrr_+3A_maxiter">maxIter</code></td>
<td>

<p>maximum number of iterations for fitting.
</p>
</td></tr>
<tr><td><code id="qrr_+3A_epsilon">epsilon</code></td>
<td>

<p>tolerance for convergence.
</p>
</td></tr>
<tr><td><code id="qrr_+3A_verbose">verbose</code></td>
<td>

<p>logical flag. If <code>TRUE</code>, progress on estimation is print out.
</p>
</td></tr>
<tr><td><code id="qrr_+3A_method.rq">method.rq</code></td>
<td>

<p>the method used to compute the linear fit. If <code>linearize = TRUE</code>, the options are <code>"conquer"</code> or any of those from <code><a href="quantreg.html#topic+rq">rq</a></code> (see the argument <code>method</code>).
</p>
</td></tr>
<tr><td><code id="qrr_+3A_method.nlrq">method.nlrq</code></td>
<td>

<p>the method used to compute the nonlinear fit. If <code>linearize = FALSE</code>, the options are those from <code><a href="quantreg.html#topic+nlrq">nlrq</a></code> (see the argument <code>method</code>).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These function implements quantile ratio regression as discussed by Farcomeni and Geraci (see references). The general model is assumed to be <code class="reqn">g(Q_{Y|X}(\tau_{1})/Q_{Y|X}(\tau_{2})) = \eta = Xb</code> where <code class="reqn">Q</code> denotes the conditional quantile function, <code class="reqn">Y</code> is the response variable, <code class="reqn">X</code> a design matrix, <code class="reqn">g</code> is a monotone link function, and <code class="reqn">\tau_{1}</code> and <code class="reqn">\tau_{2}</code> the levels of the two quantiles in the ratio. In the current implementation, <code class="reqn">g(u) = log(u - 1)</code>, which ensures monotonocity (non-crossing) of the quantiles and leads to the familiar interpretation of the inverse logistic transformation. 
</p>


<h3>Author(s)</h3>

<p>Marco Geraci
</p>


<h3>References</h3>

<p>Farcomeni A. and Geraci M. Quantile ratio regression. 2023. Working Paper.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+coef.qrr">coef.qrr</a></code>, <code><a href="#topic+predict.qrr">predict.qrr</a></code>, <code><a href="#topic+summary.qrr">summary.qrr</a></code>, <code><a href="#topic+vcov.qrr">vcov.qrr</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(123)
n &lt;- 5000
x &lt;- runif(n, -0.5, 0.5)
R &lt;- 1 + exp(0.5 + 0.5*x)

# fit quintile ratio regression
alpha &lt;- 1/log(R)*log(log(1-0.8)/log(1-0.2))
y &lt;- rweibull(n, shape = alpha, scale = 1)
dd &lt;- data.frame(x = x, y = y)
qrr(y ~ x, data = dd, taus = c(.2,.8))

# fit Palma ratio regression
alpha &lt;- 1/log(R)*log(log(1-0.9)/log(1-0.4))
y &lt;- rweibull(n, shape = alpha, scale = 1)
dd &lt;- data.frame(x = x, y = y)
qrr(y ~ x, data = dd, taus = c(.4,.9))

</code></pre>

<hr>
<h2 id='Qtools-internal'>Internal Qtools objects</h2><span id='topic+.First.lib'></span><span id='topic+.Last.lib'></span><span id='topic+logit'></span><span id='topic+invlogit'></span><span id='topic+cloglog'></span><span id='topic+invcloglog'></span><span id='topic+powerbase'></span><span id='topic+invpowerbase'></span><span id='topic+map'></span><span id='topic+invmap'></span><span id='topic+powrecbase'></span><span id='topic+d1bc'></span><span id='topic+d1ao'></span><span id='topic+d1mcjI'></span><span id='topic+d2bc'></span><span id='topic+d2ao'></span><span id='topic+d2mcjI'></span><span id='topic+terms2expr'></span><span id='topic+fastDoCall'></span><span id='topic+boot.rrq'></span><span id='topic+boot.rqt'></span><span id='topic+se_rqt'></span><span id='topic+qlssPredRq'></span><span id='topic+qlssPredRqt'></span><span id='topic+qprime'></span><span id='topic+vcov_conquer'></span><span id='topic+rcLoss'></span><span id='topic+l1Loss'></span><span id='topic+nlLoss'></span><span id='topic+nl.fit.rqt'></span><span id='topic+switch_check'></span><span id='topic+addnoise'></span><span id='topic+normalize'></span><span id='topic+rcTest'></span><span id='topic+KhmaladzeTable'></span><span id='topic+C_midrqLoss'></span><span id='topic+C_midrqLoss_bc'></span><span id='topic+C_midrqLoss_ao'></span><span id='topic+C_rcTest'></span><span id='topic+C_projfun'></span><span id='topic+C_phifun'></span><span id='topic+_Qtools_C_midrqLoss'></span><span id='topic+_Qtools_C_midrqLoss_bc'></span><span id='topic+_Qtools_C_midrqLoss_ao'></span><span id='topic+_Qtools_C_rcTest'></span><span id='topic+_Qtools_C_projfun'></span><span id='topic+_Qtools_C_phifun'></span>

<h3>Description</h3>

<p>Internal Qtools objects.</p>


<h3>Details</h3>

<p>These are not to be called by the user.</p>

<hr>
<h2 id='Qtools-package'>Utilities for Quantilies</h2><span id='topic+Qtools-package'></span>

<h3>Description</h3>

<p>The package Qtools provides functions for unconditional and conditional quantiles. These include methods for transformation-based quantile regression, quantile-based measures of location, scale and shape, methods for quantiles of discrete variables, quantile-based multiple imputation, restricted quantile regression, and directional quantile classification.
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> Qtools</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 1.5.9</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2023-10-28</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL (&gt;=2)</td>
</tr>
<tr>
 <td style="text-align: left;">
LazyLoad: </td><td style="text-align: left;"> yes</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Author(s)</h3>

<p>Marco Geraci
</p>
<p>Maintainer: Marco Geraci &lt;marco.geraci@uniroma1.it&gt;
</p>

<hr>
<h2 id='residuals.midrq'>
Residuals from a midrq Objects
</h2><span id='topic+residuals.midrq'></span>

<h3>Description</h3>

<p>This function computes the residuals from a fitted mid-quantile regression model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'midrq'
residuals(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="residuals.midrq_+3A_object">object</code></td>
<td>

<p>an <code>midrq</code> object.
</p>
</td></tr>
<tr><td><code id="residuals.midrq_+3A_...">...</code></td>
<td>

<p>not used.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector or matrix of residuals.
</p>


<h3>Author(s)</h3>

<p>Marco Geraci
</p>


<h3>See Also</h3>

<p><code><a href="#topic+midrq">midrq</a></code>
</p>

<hr>
<h2 id='residuals.rq.counts'>
Residuals from an rq.counts Object
</h2><span id='topic+residuals.rq.counts'></span>

<h3>Description</h3>

<p>This function computes the residuals from a fitted linear quantile model for counts.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'rq.counts'
residuals(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="residuals.rq.counts_+3A_object">object</code></td>
<td>

<p>an <code>rq.counts</code> object.
</p>
</td></tr>
<tr><td><code id="residuals.rq.counts_+3A_...">...</code></td>
<td>

<p>not used.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector or matrix of residuals.
</p>


<h3>Author(s)</h3>

<p>Marco Geraci
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rq.counts">rq.counts</a></code>
</p>

<hr>
<h2 id='residuals.rqt'>
Residuals from an rqt Objects
</h2><span id='topic+residuals.rqt'></span>

<h3>Description</h3>

<p>This function computes the residuals from a fitted quantile regression transformation model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'rqt'
residuals(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="residuals.rqt_+3A_object">object</code></td>
<td>

<p>an <code>rqt</code> object.
</p>
</td></tr>
<tr><td><code id="residuals.rqt_+3A_...">...</code></td>
<td>

<p>not used.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector or matrix of residuals.
</p>


<h3>Author(s)</h3>

<p>Marco Geraci
</p>


<h3>See Also</h3>

<p><code><a href="#topic+tsrq">tsrq</a></code>
</p>

<hr>
<h2 id='rq.counts'>
Quantile Regression for Counts</h2><span id='topic+rq.counts'></span>

<h3>Description</h3>

<p>This function is used to fit a (log-linear) quantile regression model when the response is a count variable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rq.counts(formula, data = sys.frame(sys.parent()), tau = 0.5, subset, weights,
	na.action, contrasts = NULL, offset = NULL, method = "fn", M = 50,
	zeta = 1e-5, B = 0.999, cn = NULL, alpha = 0.05)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rq.counts_+3A_formula">formula</code></td>
<td>

<p>an object of class <code><a href="stats.html#topic+formula">formula</a></code>: a symbolic description of the model to be fitted.
</p>
</td></tr>
<tr><td><code id="rq.counts_+3A_data">data</code></td>
<td>

<p>an optional data frame, list or environment (or object coercible by as.data.frame to a data frame) containing the variables in the model. If not found in data, the variables are taken from environment(formula), typically the environment from which <code>rq.counts</code> is called.
</p>
</td></tr>
<tr><td><code id="rq.counts_+3A_tau">tau</code></td>
<td>

<p>quantile to be estimated.
</p>
</td></tr>
<tr><td><code id="rq.counts_+3A_subset">subset</code></td>
<td>

<p>an optional vector specifying a subset of observations to be used in the fitting process.
</p>
</td></tr>
<tr><td><code id="rq.counts_+3A_weights">weights</code></td>
<td>

<p>an optional vector of weights to be used in the fitting process.
</p>
</td></tr>
<tr><td><code id="rq.counts_+3A_na.action">na.action</code></td>
<td>

<p>a function which indicates what should happen when the data contain <code>NA</code>s.
</p>
</td></tr>
<tr><td><code id="rq.counts_+3A_contrasts">contrasts</code></td>
<td>

<p>an optional list. See the <code>contrasts.arg</code> of <code><a href="stats.html#topic+model.matrix.default">model.matrix.default</a></code>.
</p>
</td></tr>
<tr><td><code id="rq.counts_+3A_offset">offset</code></td>
<td>

<p>an optional offset to be included in the model frame.  
</p>
</td></tr>
<tr><td><code id="rq.counts_+3A_method">method</code></td>
<td>

<p>estimation method for the fitting process. See <code><a href="quantreg.html#topic+rq">rq</a></code>.
</p>
</td></tr>
<tr><td><code id="rq.counts_+3A_m">M</code></td>
<td>

<p>number of dithered samples.
</p>
</td></tr>
<tr><td><code id="rq.counts_+3A_zeta">zeta</code></td>
<td>

<p>small constant (see References).
</p>
</td></tr>
<tr><td><code id="rq.counts_+3A_b">B</code></td>
<td>

<p>right boundary for uniform random noise U[0,B] to be added to the response variable (see References).
</p>
</td></tr>
<tr><td><code id="rq.counts_+3A_cn">cn</code></td>
<td>

<p>small constant to be passed to <code>Fn</code> (see Theorem 3, Machado and Santos Silva).
</p>
</td></tr>
<tr><td><code id="rq.counts_+3A_alpha">alpha</code></td>
<td>

<p>significance level.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A linear quantile regression model is fitted to the log&ndash;transformed response. The notation used here follows closely that of Machado and Santos Silva (2005). This function is based on routines from package <code>quantreg</code> (Koenker, 2016). See also <code>lqm.counts</code> from package <code>lqmm</code> (Geraci, 2014) for Laplace gradient estimation.
</p>
<p>As of version 1.4, the transformation of the response cannot be changed. This option may be reinstated in future versions.
</p>


<h3>Value</h3>

<p>a list of class <code>rq.counts</code> containing the following components
</p>
<table>
<tr><td><code>call</code></td>
<td>
<p>the matched call.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>the fitting algorithm for <code>rq</code>.</p>
</td></tr>
<tr><td><code>x</code></td>
<td>
<p>the model matrix.</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>the model response.</p>
</td></tr>
<tr><td><code>tau</code></td>
<td>
<p>the order of the estimated quantile(s).</p>
</td></tr>
<tr><td><code>tsf</code></td>
<td>
<p>tranformation used (see also <code>attributes(tsf)</code>).</p>
</td></tr>
<tr><td><code>coefficients</code></td>
<td>
<p>regression quantile (on the log&ndash;scale).</p>
</td></tr>
<tr><td><code>fitted.values</code></td>
<td>
<p>fitted values (on the response scale).</p>
</td></tr>
<tr><td><code>tTable</code></td>
<td>
<p>coefficients, standard errors, etc.</p>
</td></tr>
<tr><td><code>offset</code></td>
<td>
<p>offset.</p>
</td></tr>
<tr><td><code>M</code></td>
<td>
<p>specified number of dithered samples for standard error estimation.</p>
</td></tr>
<tr><td><code>Mn</code></td>
<td>
<p>actual number of dithered samples used for standard error estimation that gave an invertible D matrix (Machado and Santos Silva, 2005).</p>
</td></tr>
<tr><td><code>InitialPar</code></td>
<td>
<p>starting values for coefficients.</p>
</td></tr>
<tr><td><code>terms</code></td>
<td>
<p>the terms object used.</p>
</td></tr>
<tr><td><code>term.labels</code></td>
<td>
<p>names of coefficients.</p>
</td></tr>
<tr><td><code>rdf</code></td>
<td>
<p>the number of residual degrees of freedom.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Marco Geraci
</p>


<h3>References</h3>

<p>Geraci M. Linear quantile mixed models: The lqmm package for Laplace quantile regression. Journal of Statistical Software. 2014;57(13):1-29.
</p>
<p>Geraci M and Jones MC. Improved transformation-based quantile regression. Canadian Journal of Statistics 2015;43(1):118-132.
</p>
<p>Koenker R. quantreg: Quantile Regression. 2016. R package version 5.29.
</p>
<p>Machado JAF, Santos Silva JMC. Quantiles for counts. Journal of the American Statistical Association. 2005;100(472):1226-37.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+residuals.rq.counts">residuals.rq.counts</a></code>, <code><a href="#topic+predict.rq.counts">predict.rq.counts</a></code>, <code><a href="#topic+coef.rq.counts">coef.rq.counts</a></code>, <code><a href="#topic+maref.rq.counts">maref.rq.counts</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Esterase data
data(esterase)

# Fit quantiles 0.25 and 0.75
fit1 &lt;- rq.counts(Count ~ Esterase, tau = 0.25, data = esterase, M = 50)
coef(fit1)
fit2 &lt;- rq.counts(Count ~ Esterase, tau = 0.75, data = esterase, M = 50)
coef(fit2)

# Plot
with(esterase, plot(Count ~ Esterase))
lines(esterase$Esterase, fit1$fitted.values, col = "blue")
lines(esterase$Esterase, fit2$fitted.values, col = "red")
legend(8, 1000, lty = c(1,1), col = c("blue", "red"), legend = c("tau = 0.25","tau = 0.75"))

</code></pre>

<hr>
<h2 id='rrq'>
Restricted Regression Quantiles
</h2><span id='topic+rrq.fit'></span><span id='topic+rrq.wfit'></span><span id='topic+rrq'></span>

<h3>Description</h3>

<p>This function fits a restricted quantile regression model to avoid crossing of quantile curves.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rrq(formula, tau, data, subset, weights, na.action, method = "fn",
model = TRUE, contrasts = NULL, ...)
rrq.fit(x, y, tau, method = "fn", ...)
rrq.wfit(x, y, tau, weights, method = "fn", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rrq_+3A_formula">formula</code></td>
<td>

<p>a formula object, with the response on the left of a <code>~</code> operator, and the terms, separated by <code>+</code> operators, on the right.
</p>
</td></tr>
<tr><td><code id="rrq_+3A_x">x</code></td>
<td>

<p>the design matrix.
</p>
</td></tr>
<tr><td><code id="rrq_+3A_y">y</code></td>
<td>

<p>the response variable.
</p>
</td></tr>
<tr><td><code id="rrq_+3A_tau">tau</code></td>
<td>

<p>the quantile(s) to be estimated.
</p>
</td></tr>
<tr><td><code id="rrq_+3A_data">data</code></td>
<td>

<p>a data frame in which to interpret the variables named in the formula.
</p>
</td></tr>
<tr><td><code id="rrq_+3A_subset">subset</code></td>
<td>

<p>an optional vector specifying a subset of observations to be used in the fitting process.
</p>
</td></tr>
<tr><td><code id="rrq_+3A_weights">weights</code></td>
<td>

<p>an optional vector of weights to be used in the fitting process. Should be NULL or a numeric vector. 
</p>
</td></tr>
<tr><td><code id="rrq_+3A_na.action">na.action</code></td>
<td>

<p>a function which indicates what should happen when the data contain <code>NA</code>s.
</p>
</td></tr>
<tr><td><code id="rrq_+3A_method">method</code></td>
<td>

<p>the algorithm used to compute the fit (see <code><a href="quantreg.html#topic+rq">rq</a></code>).
</p>
</td></tr>
<tr><td><code id="rrq_+3A_model">model</code></td>
<td>

<p>if <code>TRUE</code> then the model frame is returned. This is essential if one wants to call summary subsequently.
</p>
</td></tr>
<tr><td><code id="rrq_+3A_contrasts">contrasts</code></td>
<td>

<p>a list giving contrasts for some or all of the factors default = NULL appearing in the model formula. The elements of the list should have the same name as the variable and should be either a contrast matrix (specifically, any full-rank matrix with as many rows as there are levels in the factor), or else a function to compute such a matrix given the number of levels.
</p>
</td></tr>
<tr><td><code id="rrq_+3A_...">...</code></td>
<td>

<p>optional arguments passed to <code>rq.fit</code> or <code>rq.wfit</code>.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Marco Geraci
</p>


<h3>References</h3>

<p>He X. Quantile curves without crossing. The American Statistician 1997;51(2):186-192.
</p>
<p>Koenker R. quantreg: Quantile Regression. 2016. R package version 5.29.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(esterase)

# Fit standard quantile regression
fit &lt;- quantreg::rq(Count ~ Esterase, data = esterase, tau = c(.1,.25,.5,.75,.9))
yhat &lt;- fit$fitted.values

# Fit restricted quantile regression
fitr &lt;- rrq(Count ~ Esterase, data = esterase, tau = c(.1,.25,.5,.75,.9))
yhat2 &lt;- predict(fitr)


# Plot results
par(mfrow = c(1, 2))

# Plot regression quantiles
with(esterase, plot(Count ~ Esterase, pch = 16, cex = .8))
apply(yhat, 2, function(y,x) lines(x,y,lwd = 1.5), x = esterase$Esterase)

# Plot restricted regression quantiles
with(esterase, plot(Count ~ Esterase, pch = 16, cex = .8))
apply(yhat2, 2, function(y,x) lines(x,y,lwd = 1.5), x = esterase$Esterase)

</code></pre>

<hr>
<h2 id='sparsity.rqt'>
Sparsity Estimation
</h2><span id='topic+sparsity'></span><span id='topic+sparsity.rq'></span><span id='topic+sparsity.rqs'></span><span id='topic+sparsity.rqt'></span>

<h3>Description</h3>

<p>This function estimates the density and sparsity functions of the residuals from a <code>rq</code> or a <code>rqt</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sparsity(object, se = "nid", hs = TRUE)
## S3 method for class 'rq'
sparsity(object, se = "nid", hs = TRUE)
## S3 method for class 'rqs'
sparsity(object, se = "nid", hs = TRUE)
## S3 method for class 'rqt'
sparsity(object, se = "nid", hs = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sparsity.rqt_+3A_object">object</code></td>
<td>

<p>a <code>rq</code>, <code>rqs</code> or <code>rqt</code> object.
</p>
</td></tr>
<tr><td><code id="sparsity.rqt_+3A_se">se</code></td>
<td>

<p>&quot;iid&quot; if errors are assumed independent and identically distributed; &quot;nid&quot; (default) if independent but not identically distributed; &quot;ker&quot; which uses a kernel estimate of the sandwich as proposed by Powell (1991).
</p>
</td></tr>
<tr><td><code id="sparsity.rqt_+3A_hs">hs</code></td>
<td>

<p>logical flag. If <code>TRUE</code> (default) the Hall-Sheather rule is used. Otherwise, the Bofinger's rule is used.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is based on the code from <code>quantreg::summary.rq</code> and <code>quantreg::bandwidth.rq</code> to estimate the sparsity function for linear quantile regression models (Koenker and Bassett, 1978) and transformation models of Geraci and Jones (2014).
</p>


<h3>Value</h3>

<p><code>sparsity</code> returns an object of <code><a href="base.html#topic+class">class</a></code> <code>list</code> that contains three elements:
</p>
<table>
<tr><td><code>density</code></td>
<td>
<p>estimate of the density of the residuals.</p>
</td></tr>
<tr><td><code>sparsity</code></td>
<td>
<p>estimate of the sparsity of the residuals.</p>
</td></tr>
<tr><td><code>bandwidth</code></td>
<td>
<p>bandwidth used for estimation.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Marco Geraci
</p>


<h3>References</h3>

<p>Geraci M and Jones MC. Improved transformation-based quantile regression. Canadian Journal of Statistics 2015;43(1):118-132.
</p>
<p>Koenker R. quantreg: Quantile Regression. 2016. R package version 5.29.
</p>
<p>Koenker R, Bassett G. Regression quantiles. Econometrica. 1978;46(1):33-50.
</p>
<p>Powell JL. Estimation of monotonic regression models under quantile restrictions. In: Barnett W, Powell J, Tauchen G, editors. Nonparametric and Semiparametric Methods in Econometrics and Statistics: Proceedings of the Fifth International Symposium on Economic Theory and Econometrics. New York, NY: Cambridge University Press 1991. p. 357-84.
</p>


<h3>See Also</h3>

<p><code><a href="quantreg.html#topic+rq">rq</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

data(trees)

# 'rqt' object

fit.rqt &lt;- tsrq(Volume ~ Height, tsf = "bc", symm = FALSE, data = trees,
	lambda = seq(-10, 10, by = 0.01), tau = 0.5)
sparsity(fit.rqt)

# 'rq' object

fit.rq &lt;- rq(Volume ~ Height, data = trees)
sparsity(fit.rq, se = "iid")
sparsity(fit.rq, se = "nid")
sparsity(fit.rq, se = "ker")

## End(Not run)

</code></pre>

<hr>
<h2 id='summary.midrq'>
Summary for Mid-Quantile Regression Models
</h2><span id='topic+summary.midrq'></span>

<h3>Description</h3>

<p>This functions gives a summary list for a mid-quantile regression model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'midrq'
summary(object, alpha = 0.05, numerical = FALSE, robust = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.midrq_+3A_object">object</code></td>
<td>

<p>an object of <code><a href="base.html#topic+class">class</a></code> <code>midrq</code>.
</p>
</td></tr>
<tr><td><code id="summary.midrq_+3A_alpha">alpha</code></td>
<td>

<p>numeric value to determine the confidence level <code>(1-alpha)</code> of the required interval.
</p>
</td></tr>
<tr><td><code id="summary.midrq_+3A_numerical">numerical</code></td>
<td>

<p>logical flag. If <code>TRUE</code>, the variance-covariance estimate is approximated by the inverse of the numerical Hessian.
</p>
</td></tr>
<tr><td><code id="summary.midrq_+3A_robust">robust</code></td>
<td>

<p>logical flag. If <code>TRUE</code>, the Huber-White covariance estimate is computed using the Huberized residuals.
</p>
</td></tr>
<tr><td><code id="summary.midrq_+3A_...">...</code></td>
<td>

<p>not used.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Marco Geraci
</p>


<h3>References</h3>

<p>Geraci, M. and A. Farcomeni. Mid-quantile regression for discrete responses. arXiv:1907.01945 [stat.ME]. URL: <a href="https://arxiv.org/abs/1907.01945">https://arxiv.org/abs/1907.01945</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+midrq">midrq</a></code>
</p>

<hr>
<h2 id='summary.qrr'>
Summary for Quantile Ratio Regression Models
</h2><span id='topic+summary.qrr'></span>

<h3>Description</h3>

<p>This functions gives a summary list for a quantile ratio regression model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'qrr'
summary(object, se = "approximate", R = 200,
update = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.qrr_+3A_object">object</code></td>
<td>

<p>an object of <code><a href="base.html#topic+class">class</a></code> <code>summary.qrr</code>.
</p>
</td></tr>
<tr><td><code id="summary.qrr_+3A_se">se</code></td>
<td>

<p>specifies the method used to compute standard errors. See argument <code>method</code> in <code><a href="#topic+vcov.qrr">vcov.qrr</a></code>.
</p>
</td></tr>
<tr><td><code id="summary.qrr_+3A_r">R</code></td>
<td>

<p>number of bootstrap replications.
</p>
</td></tr>
<tr><td><code id="summary.qrr_+3A_update">update</code></td>
<td>

<p>see argument <code>update</code> in <code><a href="#topic+vcov.qrr">vcov.qrr</a></code>.
</p>
</td></tr>
<tr><td><code id="summary.qrr_+3A_...">...</code></td>
<td>

<p>not used.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Marco Geraci
</p>


<h3>References</h3>

<p>Farcomeni A. and Geraci M. Quantile ratio regression. 2023. Working Paper.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+qrr">qrr</a></code>
</p>

<hr>
<h2 id='summary.rqt'>
Summary for Quantile Regression Tranformation Models
</h2><span id='topic+summary.rqt'></span>

<h3>Description</h3>

<p>This functions gives a summary list for a quantile regression transformation model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'rqt'
summary(object, alpha = 0.05, se = "boot", R = 50,
	sim = "ordinary", stype = "i", conditional = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.rqt_+3A_object">object</code></td>
<td>

<p>an object of <code><a href="base.html#topic+class">class</a></code> <code>rqt</code>.
</p>
</td></tr>
<tr><td><code id="summary.rqt_+3A_alpha">alpha</code></td>
<td>

<p>numeric value to determine the confidence level <code>(1-alpha)</code> of the required interval.
</p>
</td></tr>
<tr><td><code id="summary.rqt_+3A_se">se</code></td>
<td>

<p>specifies the method used to compute standard errors. For conditional inference (<code>conditional = TRUE</code>), see argument <code>se</code> in <code><a href="quantreg.html#topic+summary.rq">summary.rq</a></code>. For unconditional inference (<code>conditional = FALSE</code>), see details below.
</p>
</td></tr>
<tr><td><code id="summary.rqt_+3A_r">R</code></td>
<td>

<p>number of bootstrap replications.
</p>
</td></tr>
<tr><td><code id="summary.rqt_+3A_sim">sim</code></td>
<td>

<p>see argument <code>sim</code> in <code><a href="boot.html#topic+boot">boot</a></code>.
</p>
</td></tr>
<tr><td><code id="summary.rqt_+3A_stype">stype</code></td>
<td>

<p>see argument <code>stype</code> in <code><a href="boot.html#topic+boot">boot</a></code>.
</p>
</td></tr>
<tr><td><code id="summary.rqt_+3A_conditional">conditional</code></td>
<td>

<p>logical flag. If <code>TRUE</code>, the transformation parameter is assumed to be known and conditional inference is carried out.
</p>
</td></tr>
<tr><td><code id="summary.rqt_+3A_...">...</code></td>
<td>

<p>if <code>conditional = TRUE</code>, additional arguments for <code><a href="quantreg.html#topic+summary.rq">summary.rq</a></code> in package <code>quantreg</code>. If <code>conditional = FALSE</code>, additional arguments for <code><a href="boot.html#topic+boot">boot</a></code> in package <code>boot</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If inference is carried out conditionally on the transformation parameter (ie, assuming this is <em>known</em> rather than estimated), any type of summary for regression quantiles can be used (see <code><a href="quantreg.html#topic+summary.rq">summary.rq</a></code>).
</p>
<p>For unconditional inference (<code>conditional = FALSE</code>), there are three methods available: <code>boot</code> for bootstrap; <code>iid</code> for large-<em>n</em> approximation of the standard errors under IID assumptions; <code>nid</code> for large-<em>n</em> approximation of the standard errors under NID assumptions. See Powell (1991), Chamberlain (1994) and Geraci and Jones (2015).
</p>


<h3>Author(s)</h3>

<p>Marco Geraci
</p>


<h3>References</h3>

<p>Canty A and Ripley B (2014). boot: Bootstrap R (S-Plus) Functions. R package version 1.3-11.
</p>
<p>Chamberlain G. Quantile regression, censoring, and the structure of wages. In: Sims C, editor. Advances in Econometrics: Sixth World Congress. 1. Cambridge, UK: Cambridge University Press; 1994.
</p>
<p>Davison AC and Hinkley DV (1997). Bootstrap Methods and Their Applications. Cambridge University Press, Cambridge.
</p>
<p>Geraci M and Jones MC. Improved transformation-based quantile regression. Canadian Journal of Statistics 2015;43(1):118-132.
</p>
<p>Mu YM, He XM. Power transformation toward a linear regression quantile. Journal of the American Statistical Association 2007;102(477):269-279.
</p>
<p>Powell JL. Estimation of monotonic regression models under quantile restrictions. In: Barnett W, Powell J, Tauchen G, editors. Nonparametric and Semiparametric Methods in Econometrics and Statistics: Proceedings of the Fifth International Symposium on Economic Theory and Econometrics. New York, NY: Cambridge University Press 1991. p. 357-84.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+tsrq">tsrq</a></code>, <code><a href="#topic+rcrq">rcrq</a></code>, <code><a href="#topic+tsrq2">tsrq2</a></code> or <code><a href="#topic+nlrq2">nlrq2</a></code>
</p>

<hr>
<h2 id='summary.rrq'>
Summary for Restricted Quantile Regression Models
</h2><span id='topic+summary.rrq'></span>

<h3>Description</h3>

<p>This functions gives a summary list for a restricted quantile regression model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'rrq'
summary(object, alpha = 0.05, se = "boot", R = 50,
	sim = "ordinary", stype = "i", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.rrq_+3A_object">object</code></td>
<td>

<p>an object of <code><a href="base.html#topic+class">class</a></code> <code>rrq</code>.
</p>
</td></tr>
<tr><td><code id="summary.rrq_+3A_alpha">alpha</code></td>
<td>

<p>numeric value to determine the confidence level <code>(1-alpha)</code> of the required interval.
</p>
</td></tr>
<tr><td><code id="summary.rrq_+3A_se">se</code></td>
<td>

<p>specifies the method used to compute standard errors. Currently, bootstrap is the only method available.
</p>
</td></tr>
<tr><td><code id="summary.rrq_+3A_r">R</code></td>
<td>

<p>number of bootstrap replications.
</p>
</td></tr>
<tr><td><code id="summary.rrq_+3A_sim">sim</code></td>
<td>

<p>see argument <code>sim</code> in <code><a href="boot.html#topic+boot">boot</a></code>.
</p>
</td></tr>
<tr><td><code id="summary.rrq_+3A_stype">stype</code></td>
<td>

<p>see argument <code>stype</code> in <code><a href="boot.html#topic+boot">boot</a></code>.
</p>
</td></tr>
<tr><td><code id="summary.rrq_+3A_...">...</code></td>
<td>

<p>additional arguments for <code><a href="boot.html#topic+boot">boot</a></code> in package <code>boot</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A bootstrap approach is used for inference. Future developments of this function will include asymptotic standard errors.
</p>


<h3>Author(s)</h3>

<p>Marco Geraci
</p>


<h3>References</h3>

<p>Canty A and Ripley B (2014). boot: Bootstrap R (S-Plus) Functions. R package version 1.3-15.
</p>
<p>Davison AC and Hinkley DV (1997). Bootstrap Methods and Their Applications. Cambridge University Press, Cambridge.
</p>
<p>He X (1997). Quantile Curves without Crossing. The American Statistician, 51(2), 186-192.
</p>

<hr>
<h2 id='tsrq'>
Quantile Regression Transformation Models
</h2><span id='topic+rcrq'></span><span id='topic+nlrq1'></span><span id='topic+tsrq2'></span><span id='topic+nlrq2'></span><span id='topic+tsrq'></span>

<h3>Description</h3>

<p>These functions are used to fit quantile regression transformation models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tsrq(formula, data = sys.frame(sys.parent()), tsf = "mcjI", symm = TRUE,
	dbounded = FALSE, lambda = NULL, conditional = FALSE, tau = 0.5,
	subset,	weights, na.action,	contrasts = NULL, method = "fn")
tsrq2(formula, data = sys.frame(sys.parent()), dbounded = FALSE, lambda = NULL,
	delta = NULL, conditional = FALSE, tau = 0.5, subset, weights, na.action,
	contrasts = NULL, method = "fn")
rcrq(formula, data = sys.frame(sys.parent()), tsf = "mcjI", symm = TRUE,
	dbounded = FALSE, lambda = NULL, tau = 0.5, subset, weights, na.action,
	contrasts = NULL, method = "fn")
nlrq1(formula, data = sys.frame(sys.parent()), tsf = "mcjI", symm = TRUE,
	dbounded = FALSE, start = NULL, tau = 0.5,
	subset,	weights, na.action, contrasts = NULL, control = list())
nlrq2(formula, data = sys.frame(sys.parent()), dbounded = FALSE,
	start = NULL, tau = 0.5, subset, weights, na.action, contrasts = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tsrq_+3A_formula">formula</code></td>
<td>

<p>an object of class &quot;<code><a href="stats.html#topic+formula">formula</a></code>&quot; (or one that can be coerced to that class): a symbolic description of the model to be fitted. The details of model specification are given under &lsquo;Details&rsquo;.
</p>
</td></tr>
<tr><td><code id="tsrq_+3A_data">data</code></td>
<td>

<p>an optional data frame, list or environment (or object coercible by as.data.frame to a data frame) containing the variables in the model. By default the variables are taken from the environment from which the call is made.</p>
</td></tr>
<tr><td><code id="tsrq_+3A_tsf">tsf</code></td>
<td>

<p>transformation to be used. Possible options are <code>mcjI</code> for Proposal I transformation models (default), <code>bc</code> for Box-Cox and <code>ao</code> for Aranda-Ordaz transformation models.
</p>
</td></tr>
<tr><td><code id="tsrq_+3A_symm">symm</code></td>
<td>

<p>logical flag. If <code>TRUE</code> (default) a symmetric transformation is used.
</p>
</td></tr>
<tr><td><code id="tsrq_+3A_dbounded">dbounded</code></td>
<td>

<p>logical flag. If <code>TRUE</code> the response is assumed to be doubly bounded on [a,b]. If <code>FALSE</code> (default) the response is assumed to be singly bounded (ie, strictly positive).
</p>
</td></tr>
<tr><td><code id="tsrq_+3A_lambda">lambda</code>, <code id="tsrq_+3A_delta">delta</code></td>
<td>

<p>values of transformation parameters for grid search.
</p>
</td></tr>
<tr><td><code id="tsrq_+3A_conditional">conditional</code></td>
<td>

<p>logical flag. If <code>TRUE</code>, the transformation parameter is assumed to be known and this must be provided via the arguments <code>lambda</code>, <code>delta</code> in vectors of the same length as <code>tau</code>.
</p>
</td></tr>
<tr><td><code id="tsrq_+3A_start">start</code></td>
<td>

<p>vector of length <code>1 + p</code> (nlrq1) or <code>2 + p</code> (nlrq2) of initial values for the parameters to be optimized over. The first one (nlrq1) or two (nlrq2) values for the transformation parameter <code>lambda</code>, or <code>lambda</code> and <code>delta</code>, while the last <code>p</code> values are for the regression coefficients. These initial values are passed to <code>nl.fit.rqt</code> or to <code><a href="stats.html#topic+optim">optim</a></code>.
</p>
</td></tr>
<tr><td><code id="tsrq_+3A_control">control</code></td>
<td>

<p>list of control parameters of the fitting process (nlrq1). See <code><a href="#topic+nlControl">nlControl</a></code>.
</p>
</td></tr>
<tr><td><code id="tsrq_+3A_tau">tau</code></td>
<td>

<p>the quantile(s) to be estimated. See <code><a href="quantreg.html#topic+rq">rq</a></code>.
</p>
</td></tr>
<tr><td><code id="tsrq_+3A_subset">subset</code></td>
<td>

<p>an optional vector specifying a subset of observations to be used in the fitting process.
</p>
</td></tr>
<tr><td><code id="tsrq_+3A_weights">weights</code></td>
<td>

<p>an optional vector of weights to be used in the fitting process. Should be NULL or a numeric vector. 
</p>
</td></tr>
<tr><td><code id="tsrq_+3A_na.action">na.action</code></td>
<td>

<p>a function which indicates what should happen when the data contain <code>NA</code>s.
</p>
</td></tr>
<tr><td><code id="tsrq_+3A_contrasts">contrasts</code></td>
<td>

<p>an optional list. See the <code>contrasts.arg</code> of <code><a href="stats.html#topic+model.matrix.default">model.matrix.default</a></code>.
</p>
</td></tr>
<tr><td><code id="tsrq_+3A_method">method</code></td>
<td>

<p>fitting algorithm for <code><a href="quantreg.html#topic+rq">rq</a></code> (default is Frisch-Newton interior point method &quot;<code>fn</code>&quot;).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions implement quantile regression transformation models as discussed by Geraci and Jones (see references). The general model is assumed to be <code class="reqn">Q_{h(Y)|X}(\tau) = \eta = Xb</code>, where <code class="reqn">Q</code> denotes the conditional quantile function, <code class="reqn">Y</code> is the response variable, <code class="reqn">X</code> a design matrix, and <code class="reqn">h</code> is a monotone one- or two-parameter transformation. A typical model specified in <code>formula</code> has the form <code>response ~ terms</code> where <code>response</code> is the (numeric) response vector and <code>terms</code> is a series of terms which specifies a linear predictor for the quantile of the transformed response. The <code>response</code>, which is singly or doubly bounded, i.e. <code>response &gt; 0</code> or <code>0 &lt;= response &lt;= 1</code> respectively, undergoes the transformation specified in <code>tsf</code>. If the response is bounded in the generic <code class="reqn">[a,b]</code> interval, the latter is automatically mapped to <code class="reqn">[0,1]</code> and no further action is required. If, however, the response is singly bounded and contains negative values, it is left to the user to offset the response or the code will produce an error.
</p>
<p>The functions <code>tsrq</code> and <code>tsrq2</code> use a two-stage (TS) estimator (Fitzenberger et al, 2010) for, respectively, one- and two-parameter transformations. The function <code>rcrq</code> (one-parameter tranformations) is based on the residual cusum process estimator proposed by Mu and He (2007). The functions <code>nlrq1</code> (one-parameter tranformations) and <code>nlrq2</code> (two-parameter tranformations) are based on, respectively, gradient search and Nelder-Mead optimization.
</p>


<h3>Value</h3>

<p><code>tsrq</code>, <code>tsrq2</code>, <code>rcrq</code>, <code>nlrq2</code> return an object of <code><a href="base.html#topic+class">class</a></code> <code>rqt</code>. This is a list that contains as typical components:
</p>
<table>
<tr><td><code>...</code></td>
<td>
<p>the first <code>nt = length(tau)</code> elements of the list store the results from fitting linear quantile models on the tranformed scale of the response.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>the matched call.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>the fitting algorithm for <code>rq</code> or <code>optim</code>.</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>the response &ndash; untransformed scale.</p>
</td></tr>
<tr><td><code>theta</code></td>
<td>
<p>if <code>dbounded = TRUE</code>, the response mapped to the unit interval.</p>
</td></tr>
<tr><td><code>x</code></td>
<td>
<p>the model matrix.</p>
</td></tr>
<tr><td><code>weights</code></td>
<td>
<p>the weights used in the fitting process (a vector of 1's if <code>weights</code> is missing or <code>NULL</code>).</p>
</td></tr>
<tr><td><code>tau</code></td>
<td>
<p>the order of the estimated quantile(s).</p>
</td></tr>
<tr><td><code>lambda</code></td>
<td>
<p>the estimated parameter lambda.</p>
</td></tr>
<tr><td><code>eta</code></td>
<td>
<p>the estimated parameters lambda and delta in the two-parameter Proposal II tranformation.</p>
</td></tr>
<tr><td><code>lambda.grid</code></td>
<td>
<p>grid of lambda values used for estimation.</p>
</td></tr>
<tr><td><code>delta.grid</code></td>
<td>
<p>grid of delta values used for estimation.</p>
</td></tr>
<tr><td><code>tsf</code></td>
<td>
<p>tranformation used (see also <code>attributes(tsf)</code>).</p>
</td></tr>
<tr><td><code>objective</code></td>
<td>
<p>values of the objective function minimised over the tranformation parameter(s). This is an array of dimension <code>c(nl,nt)</code> or <code>c(nl,nd,nt)</code>, where <code>nl = length(lambda.grid)</code>, <code>nd = length(delta.grid)</code> and <code>nt = length(tau)</code>.</p>
</td></tr>
<tr><td><code>optimum</code></td>
<td>
<p>value of the objective function at solution.</p>
</td></tr>
<tr><td><code>coefficients</code></td>
<td>
<p>quantile regression coefficients &ndash; transformed scale.</p>
</td></tr>
<tr><td><code>fitted.values</code></td>
<td>
<p>fitted values.</p>
</td></tr>
<tr><td><code>rejected</code></td>
<td>
<p>proportion of inadmissible observations (Fitzenberger et al, 2010).</p>
</td></tr>
<tr><td><code>terms</code></td>
<td>
<p>the <code><a href="stats.html#topic+terms">terms</a></code> used.</p>
</td></tr>
<tr><td><code>term.labels</code></td>
<td>
<p>names of coefficients.</p>
</td></tr>
<tr><td><code>rdf</code></td>
<td>
<p>residual degrees of freedom.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Marco Geraci
</p>


<h3>References</h3>

<p>Aranda-Ordaz FJ. On two families of transformations to additivity for binary response data. Biometrika 1981;68(2):357-363.
</p>
<p>Box GEP, Cox DR. An analysis of transformations. Journal of the Royal Statistical Society Series B-Statistical Methodology 1964;26(2):211-252.
</p>
<p>Dehbi H-M, Cortina-Borja M, and Geraci M. Aranda-Ordaz quantile regression for student performance assessment. Journal of Applied Statistics. 2016;43(1):58-71.
</p>
<p>Fitzenberger B, Wilke R, Zhang X. Implementing Box-Cox quantile regression. Econometric Reviews 2010;29(2):158-181.
</p>
<p>Geraci M and Jones MC. Improved transformation-based quantile regression. Canadian Journal of Statistics 2015;43(1):118-132.
</p>
<p>Jones MC. Connecting distributions with power tails on the real line, the half line and the interval. International Statistical Review 2007;75(1):58-69.
</p>
<p>Koenker R. quantreg: Quantile Regression. 2016. R package version 5.29.
</p>
<p>Mu YM, He XM. Power transformation toward a linear regression quantile. Journal of the American Statistical Association 2007;102(477):269-279.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+predict.rqt">predict.rqt</a></code>, <code><a href="#topic+summary.rqt">summary.rqt</a></code>, <code><a href="#topic+coef.rqt">coef.rqt</a></code>, <code><a href="#topic+maref.rqt">maref.rqt</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
###########################################################
## Example 1 - singly bounded (from Geraci and Jones, 2014)

## Not run: 

data(trees)
require(MASS)

dx &lt;- 0.01

lambda0 &lt;- boxcox(Volume ~ log(Height), data = trees,
	lambda = seq(-0.9, 0.5, by = dx))
lambda0 &lt;- lambda0$x[which.max(lambda0$y)]
trees$z &lt;- bc(trees$Volume,lambda0)
trees$y &lt;- trees$Volume
trees$x &lt;- log(trees$Height)
trees$x &lt;- trees$x - mean(log(trees$Height))

fit.lm &lt;- lm(z ~ x, data = trees)
newd &lt;- data.frame(x = log(seq(min(trees$Height),
	max(trees$Height), by = 0.1)))
newd$x &lt;- newd$x - mean(log(trees$Height))
ylm &lt;- invbc(predict(fit.lm, newdata = newd), lambda0)

lambdas &lt;- list(bc = seq(-10, 10, by=dx),
	mcjIs = seq(0,10,by = dx), mcjIa = seq(0,20,by = dx))

taus &lt;- 1:3/4
fit0 &lt;- tsrq(y ~ x, data = trees, tsf = "bc", symm = FALSE,
	lambda = lambdas$bc, tau = taus)
fit1 &lt;- tsrq(y ~ x, data = trees, tsf = "mcjI", symm = TRUE,
	dbounded = FALSE, lambda = lambdas$mcjIs, tau = taus)
fit2 &lt;- tsrq(y ~ x, data = trees, tsf = "mcjI", symm = FALSE,
	dbounded = FALSE, lambda = lambdas$mcjIa, tau = taus)


par(mfrow = c(1,3), mar = c(7.1, 7.1, 5.1, 2.1), mgp = c(5, 2, 0))

cx.lab &lt;- 2.5
cx.ax &lt;- 2
lw &lt;- 2
cx &lt;- 2
xb &lt;- "log(Height)"
yb &lt;- "Volume"
xl &lt;- range(trees$x)
yl &lt;- c(5,80)

yhat &lt;- predict(fit0, newdata = newd)
plot(y ~ x, data = trees, xlim = xl, ylim = yl, main = "Box-Cox",
	cex.lab = cx.lab, cex.axis = cx.ax, cex.main = cx.lab,
	cex = cx, xlab = xb, ylab = yb)
lines(newd$x, yhat[,1], lwd = lw)
lines(newd$x, yhat[,2], lwd = lw)
lines(newd$x, yhat[,3], lwd = lw)
lines(newd$x, ylm, lwd = lw, lty = 2)

yhat &lt;- predict(fit1, newdata = newd)
plot(y ~ x, data = trees, xlim = xl, ylim = yl, main = "Proposal I (symmetric)",
	cex.lab = cx.lab, cex.axis = cx.ax, cex.main = cx.lab,
	cex = cx, xlab = xb, ylab = yb)
lines(newd$x, yhat[,1], lwd = lw)
lines(newd$x, yhat[,2], lwd = lw)
lines(newd$x, yhat[,3], lwd = lw)
lines(newd$x, ylm, lwd = lw, lty = 2)

yhat &lt;- predict(fit2, newdata = newd)
plot(y ~ x, data = trees, xlim = xl, ylim = yl, main = "Proposal I (asymmetric)",
	cex.lab = cx.lab, cex.axis = cx.ax, cex.main = cx.lab,
	cex = cx, xlab = xb, ylab = yb)
lines(newd$x, yhat[,1], lwd = lw)
lines(newd$x, yhat[,2], lwd = lw)
lines(newd$x, yhat[,3], lwd = lw)
lines(newd$x, ylm, lwd = lw, lty = 2)

## End(Not run)

###########################################################
## Example 2 - doubly bounded

## Not run: 

data(Chemistry)

Chemistry$gcse_gr &lt;- cut(Chemistry$gcse, c(0,seq(4,8,by=0.5)))
with(Chemistry, plot(score ~ gcse_gr, xlab = "GCSE score",
	ylab = "A-level Chemistry score"))


# The dataset has &gt; 31000 observations and computation can be slow
set.seed(178)
chemsub &lt;- Chemistry[sample(1:nrow(Chemistry), 2000), ]

# Fit symmetric Aranda-Ordaz quantile 0.9
tsrq(score ~ gcse, data = chemsub, tsf = "ao", symm = TRUE,
	lambda = seq(0,2,by=0.01), tau = 0.9)

# Fit symmetric Proposal I quantile 0.9
tsrq(score ~ gcse, data = chemsub, tsf = "mcjI", symm = TRUE,
	dbounded = TRUE, lambda = seq(0,2,by=0.01), tau = 0.9)

# Fit Proposal II quantile 0.9 (Nelder-Mead)
nlrq2(score ~ gcse, data = chemsub, dbounded = TRUE, tau = 0.9)

# Fit Proposal II quantile 0.9 (grid search)
# This is slower than nlrq2 but more stable numerically
tsrq2(score ~ gcse, data = chemsub, dbounded = TRUE,
	lambda = seq(0, 2, by = 0.1), delta = seq(0, 2, by = 0.1),
	tau = 0.9)


## End(Not run)

###########################################################
## Example 3 - doubly bounded

data(labor)

new &lt;- labor
new$y &lt;- new$pain
new$x &lt;- (new$time-30)/30
new$x_gr &lt;- as.factor(new$x)

par(mfrow = c(2,2))

cx.lab &lt;- 1
cx.ax &lt;- 2.5
cx &lt;- 2.5
yl &lt;- c(0,0.06)

hist(new$y[new$treatment == 1], xlab = "Pain score", main = "Medication group",
	freq = FALSE, ylim = yl)

plot(y ~ x_gr, new, subset = new$treatment == 1, xlab = "Time (min)",
	ylab = "Pain score", axes = FALSE, range = 0)
axis(1, at = 1:6, labels = c(0:5)*30 + 30)
axis(2)
box()

hist(new$y[new$treatment == 0], xlab = "Pain score", main = "Placebo group",
	freq = FALSE, ylim = yl)

plot(y ~ x_gr, new, subset = new$treatment == 0, xlab = "Time (min)",
	ylab = "Pain score", axes = FALSE, range = 0)
axis(1, at = 1:6, labels = (0:5)*30 + 30)
axis(2)
box()

#

## Not run: 

taus &lt;- c(1:3/4)
ls &lt;- seq(0,3.5,by=0.1)

fit.aos &lt;- tsrq(y ~ x*treatment, data = new, tsf = "ao", symm = TRUE,
	dbounded = TRUE, tau = taus, lambda = ls)
fit.aoa &lt;- tsrq(y ~ x*treatment, data = new, tsf = "ao", symm = FALSE,
	dbounded = TRUE, tau = taus, lambda = ls)
fit.mcjs &lt;- tsrq(y ~ x*treatment, data = new, tsf = "mcjI", symm = TRUE,
	dbounded = TRUE, tau = taus, lambda = ls)
fit.mcja &lt;- tsrq(y ~ x*treatment, data = new, tsf = "mcjI", symm = FALSE,
	dbounded = TRUE, tau = taus, lambda = ls)
fit.mcj2 &lt;- tsrq2(y ~ x*treatment, data = new, dbounded = TRUE, tau = taus,
	lambda = seq(0,2,by=0.1), delta = seq(0,1.5,by=0.3))
fit.nlrq &lt;- nlrq2(y ~ x*treatment, data = new, start = coef(fit.mcj2, all = TRUE)[,1],
	dbounded = TRUE, tau = taus)

sel &lt;- 0 # placebo (change to sel == 1 for medication group)
x &lt;- new$x
nd &lt;- data.frame(x = seq(min(x), max(x), length=200), treatment = sel)
xx &lt;- nd$x+1

par(mfrow = c(2,2))

fit &lt;- fit.aos
yhat &lt;- predict(fit, newdata = nd)

plot(y ~ x_gr, new, subset = new$treatment == sel, xlab = "",
	ylab = "Pain score", axes = FALSE, main = "Aranda-Ordaz (s)",
	range = 0, col = grey(4/5))
apply(yhat, 2, function(y,x) lines(x, y, lwd = 2), x = xx)
axis(1, at = 1:6, labels = (0:5)*30 + 30)
axis(2, at = c(0, 25, 50, 75, 100))
box()

fit &lt;- fit.aoa
yhat &lt;- predict(fit, newdata = nd)

plot(y ~ x_gr, new, subset = new$treatment == sel, xlab = "", ylab = "",
	axes = FALSE, main = "Aranda-Ordaz (a)", range = 0, col = grey(4/5))
apply(yhat, 2, function(y,x) lines(x, y, lwd = 2), x = xx)
axis(1, at = 1:6, labels = (0:5)*30 + 30)
axis(2, at = c(0, 25, 50, 75, 100))
box()

fit &lt;- fit.mcjs
yhat &lt;- predict(fit, newdata = nd)

plot(y ~ x_gr, new, subset = new$treatment == sel, xlab = "Time (min)",
	ylab = "Pain score", axes = FALSE, main = "Proposal I (s)",
	range = 0, col = grey(4/5))
apply(yhat, 2, function(y,x) lines(x, y, lwd = 2), x = xx)
axis(1, at = 1:6, labels = (0:5)*30 + 30)
axis(2, at = c(0, 25, 50, 75, 100))
box()

fit &lt;- fit.mcj2
yhat &lt;- predict(fit, newdata = nd)

plot(y ~ x_gr, new, subset = new$treatment == sel, xlab = "Time (min)",
	ylab = "", axes = FALSE, main = "Proposal II", range = 0, col = grey(4/5))
apply(yhat, 2, function(y,x) lines(x, y, lwd = 2), x = xx)
axis(1, at = 1:6, labels = (0:5)*30 + 30)
axis(2, at = c(0, 25, 50, 75, 100))
box()

## End(Not run)

</code></pre>

<hr>
<h2 id='vcov.midrq'>
Variance-Covariance Matrix for a Fitted Mid-Quantile Regression Model Object
</h2><span id='topic+vcov.midrq'></span>

<h3>Description</h3>

<p>This functions returns the variance-covariance matrix of the main parameters of a fitted <code>midrq</code> model object. The &lsquo;main&rsquo; parameters of the model correspond to those returned by <code><a href="stats.html#topic+coef">coef</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'midrq'
vcov(object, numerical = FALSE, robust = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vcov.midrq_+3A_object">object</code></td>
<td>

<p>an object of <code><a href="base.html#topic+class">class</a></code> <code>midrq</code>.
</p>
</td></tr>
<tr><td><code id="vcov.midrq_+3A_numerical">numerical</code></td>
<td>

<p>logical flag. If <code>TRUE</code>, the variance-covariance estimate is approximated by the inverse of the numerical Hessian.
</p>
</td></tr>
<tr><td><code id="vcov.midrq_+3A_robust">robust</code></td>
<td>

<p>logical flag. If <code>TRUE</code>, the Huber-White covariance estimate is computed using the Huberized residuals.
</p>
</td></tr>
<tr><td><code id="vcov.midrq_+3A_...">...</code></td>
<td>

<p>not used.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Marco Geraci with contributions from Alessio Farcomeni
</p>


<h3>References</h3>

<p>Geraci, M. and A. Farcomeni. Mid-quantile regression for discrete responses. arXiv:1907.01945 [stat.ME]. URL: <a href="https://arxiv.org/abs/1907.01945">https://arxiv.org/abs/1907.01945</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+midrq">midrq</a></code>
</p>

<hr>
<h2 id='vcov.qrr'>
Variance-Covariance Matrix for a Fitted Quantile Ratio Regression Model Object
</h2><span id='topic+vcov.qrr'></span>

<h3>Description</h3>

<p>This functions returns the variance-covariance matrix of the coefficients of a fitted <code>qrr</code> model object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'qrr'
vcov(object, method = "approximate", R = 200, update = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vcov.qrr_+3A_object">object</code></td>
<td>

<p>an object of <code><a href="base.html#topic+class">class</a></code> <code>qrr</code>.
</p>
</td></tr>
<tr><td><code id="vcov.qrr_+3A_method">method</code></td>
<td>

<p>if <code>"approximate"</code>, the variance-covariance estimate is approximated by the inverse of the numerical Hessian. The latter is calculated as detailed in Farcomeni and Geraci (2023). If <code>"boot"</code>, the variance-covariance estimate is calculated by means of ordinary bootstrap (see <code><a href="boot.html#topic+boot">boot</a></code>).
</p>
</td></tr>
<tr><td><code id="vcov.qrr_+3A_r">R</code></td>
<td>

<p>the number of bootstrap replications.
</p>
</td></tr>
<tr><td><code id="vcov.qrr_+3A_update">update</code></td>
<td>

<p>logical flag. If <code>TRUE</code> (the default), the statistic to be resampled is obtained via an <code><a href="stats.html#topic+update">update</a></code> of the <code>qrr</code> object. If <code>FALSE</code>, then the statistic to be resampled is obtained via a <code><a href="base.html#topic+do.call">do.call</a></code> of the <code>qrr</code> object. See details.
</p>
</td></tr>
<tr><td><code id="vcov.qrr_+3A_...">...</code></td>
<td>

<p>not used.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The use of <code>update = FALSE</code> is preferred when the function <code>vcov.qrr</code> is called from within another function.
</p>


<h3>Author(s)</h3>

<p>Marco Geraci with contributions from Alessio Farcomeni
</p>


<h3>References</h3>

<p>Farcomeni A. and Geraci M. Quantile ratio regression. 2023. Working Paper.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+qrr">qrr</a></code>
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
