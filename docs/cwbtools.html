<!DOCTYPE html><html><head><title>Help for package cwbtools</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {cwbtools}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#as.vrt'><p>Consolidate vrt files for CWB import.</p></a></li>
<li><a href='#conll_get_regions'><p>Extract regions from NER annotations (CoNNL format).</p></a></li>
<li><a href='#corpus_install'><p>Install and manage corpora.</p></a></li>
<li><a href='#CorpusData'><p>Manage Corpus Data and Encode CWB Corpus.</p></a></li>
<li><a href='#cwb_corpus_dir'><p>Manage directories for indexed corpora</p></a></li>
<li><a href='#cwb_install'><p>Utilities to install the Corpus Workbench (CWB)</p></a></li>
<li><a href='#cwbtools-package'><p>cwbtools-package</p></a></li>
<li><a href='#encode'><p>Encode CWB Corpus.</p></a></li>
<li><a href='#get_encoding'><p>Get Encoding of Character Vector.</p></a></li>
<li><a href='#p_attribute_encode'><p>Encode Positional Attribute(s).</p></a></li>
<li><a href='#pkg_utils'><p>Create and manage packages with corpus data.</p></a></li>
<li><a href='#registry_file_parse'><p>Parse and create registry files.</p></a></li>
<li><a href='#s_attribute_encode'><p>Read, process and write data on structural attributes.</p></a></li>
<li><a href='#zenodo_get_tarball'><p>Download corpus tarball from Zenodo</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Tools to Create, Modify and Manage 'CWB' Corpora</td>
</tr>
<tr>
<td>Version:</td>
<td>0.4.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-03-28</td>
</tr>
<tr>
<td>Description:</td>
<td>The 'Corpus Workbench' ('CWB', <a href="https://cwb.sourceforge.io/">https://cwb.sourceforge.io/</a>) offers a classic and mature
 approach for working with large, linguistically and structurally annotated corpora. The 'CWB'
 is memory efficient and its design makes running queries fast, see Evert (2011)
 <a href="https://eprints.lancs.ac.uk/id/eprint/62721">https://eprints.lancs.ac.uk/id/eprint/62721</a>. The 'cwbtools' package offers
 pure 'R' tools to create indexed corpus files as well as high-level wrappers for the original 'C'
 implementation of 'CWB' as exposed by the 'RcppCWB' package
 (<a href="https://CRAN.R-project.org/package=RcppCWB">https://CRAN.R-project.org/package=RcppCWB</a>). Additional functionality to add and
 modify annotations of corpora from within 'R' makes working with 'CWB' indexed corpora
 much more flexible and convenient. The 'cwbtools' package in combination with the 'R' packages
 'RcppCWB' (<a href="https://CRAN.R-project.org/package=RcppCWB">https://CRAN.R-project.org/package=RcppCWB</a>) and 'polmineR'
 (<a href="https://CRAN.R-project.org/package=polmineR">https://CRAN.R-project.org/package=polmineR</a>) offers a lightweight infrastructure
 to support the combination of quantitative and qualitative approaches for working
 with textual data.</td>
</tr>
<tr>
<td>Imports:</td>
<td>data.table, R6, xml2, stringi, curl, RcppCWB (&ge; 0.6.3),
pbapply, methods, tools, cli, jsonlite, httr, rstudioapi, zen4R
(&ge; 0.9), lifecycle, fs</td>
</tr>
<tr>
<td>Suggests:</td>
<td>tm (&ge; 0.7.3), knitr, markdown, tokenizers (&ge; 0.2.1),
tidytext, SnowballC, janeaustenr, testthat, rmarkdown, aws.s3,
quanteda, dplyr</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/PolMine/cwbtools">https://github.com/PolMine/cwbtools</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/PolMine/cwbtools/issues">https://github.com/PolMine/cwbtools/issues</a></td>
</tr>
<tr>
<td>Collate:</td>
<td>'CorpusData.R' 'corpus.R' 'cwb.R' 'cwbtools.R' 'directories.R'
'encoding.R' 'encode.R' 'ner.R' 'p_attribute.R' 'pkg.R'
'registry_file.R' 's_attribute.R' 'vrt.R' 'zenodo.R'</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>RdMacros:</td>
<td>lifecycle</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-03-28 16:42:32 UTC; andreasblatte</td>
</tr>
<tr>
<td>Author:</td>
<td>Andreas Blaette [aut, cre],
  Christoph Leonhardt [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Andreas Blaette &lt;andreas.blaette@uni-due.de&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-03-29 00:40:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='as.vrt'>Consolidate vrt files for CWB import.</h2><span id='topic+as.vrt'></span>

<h3>Description</h3>

<p>Files resulting from tagging/annotation may violate the requirements of the
Corpus Workbench (CWB).  Consolidate the known issues the vrt files may cause.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.vrt(x, replacements = list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.vrt_+3A_x">x</code></td>
<td>
<p>a character vector providing a directory with vrt files</p>
</td></tr>
<tr><td><code id="as.vrt_+3A_replacements">replacements</code></td>
<td>
<p>a list of character vectors (length 2 each) with regular expressions / replacements</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Known issues resulting from annotating files (with the treetagger in particular)
are whitespace characters invalid for XML, XML elements at the end of a line
rather than in a seperate line, characters invalid for XML (such as ampersands),
inter alia.
</p>
<p>Before doing respective corrections, the method tests whether there is any text at
all in the files. Empty files (files that contain nothing but XML tags) are dropped.
</p>

<hr>
<h2 id='conll_get_regions'>Extract regions from NER annotations (CoNNL format).</h2><span id='topic+conll_get_regions'></span>

<h3>Description</h3>

<p>Extract regions from NER annotations (CoNNL format).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>conll_get_regions(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="conll_get_regions_+3A_x">x</code></td>
<td>
<p>A <code>data.frame</code>, a <code>data.table</code>, or any other object that
can be coerced to a <code>data.table</code>. The input table is expected to have
the columns &quot;token&quot; and &quot;ner&quot;, and &quot;cpos&quot;.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- data.frame(
  token = c(
    "Die",
    "Bundeskanzlerin",
    "Angela",
    "Merkel",
    "spricht",
    "im",
    "Bundestag",
    "zur",
    "Lage",
    "der",
    "Nation",
    "."
  ),
  ne = c("O", "O", "B-PERS", "I-PERS", "O", "O", "B-ORG", "O", "O", "O", "O", "O"),
  stringsAsFactors = FALSE
)
x[["cpos"]] &lt;- 100L:(100L + nrow(x) - 1L)
tab &lt;- conll_get_regions(x)
</code></pre>

<hr>
<h2 id='corpus_install'>Install and manage corpora.</h2><span id='topic+corpus_install'></span><span id='topic+corpus_packages'></span><span id='topic+corpus_rename'></span><span id='topic+corpus_remove'></span><span id='topic+corpus_as_tarball'></span><span id='topic+corpus_copy'></span><span id='topic+corpus_recode'></span><span id='topic+corpus_testload'></span><span id='topic+corpus_get_version'></span><span id='topic+corpus_reload'></span>

<h3>Description</h3>

<p>Utility functions to assist the installation and management of indexed CWB
corpora.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>corpus_install(
  pkg = NULL,
  repo = "https://PolMine.github.io/drat/",
  tarball = NULL,
  doi = NULL,
  checksum = NULL,
  lib = .libPaths()[1],
  registry_dir,
  corpus_dir,
  ask = interactive(),
  load = TRUE,
  verbose = TRUE,
  user = NULL,
  password = NULL,
  ...
)

corpus_packages()

corpus_rename(
  old,
  new,
  registry_dir = Sys.getenv("CORPUS_REGISTRY"),
  verbose = TRUE
)

corpus_remove(corpus, registry_dir, ask = interactive(), verbose = TRUE)

corpus_as_tarball(
  corpus,
  registry_dir,
  data_dir = registry_file_parse(corpus, registry_dir)[["home"]],
  tarfile,
  verbose = TRUE
)

corpus_copy(
  corpus,
  registry_dir,
  data_dir = registry_file_parse(corpus, registry_dir)[["home"]],
  registry_dir_new = fs::path(tempdir(), "cwb", "registry"),
  data_dir_new = fs::path(tempdir(), "cwb", "indexed_corpora", tolower(corpus)),
  remove = FALSE,
  verbose = interactive(),
  progress = TRUE
)

corpus_recode(
  corpus,
  registry_dir = Sys.getenv("CORPUS_REGISTRY"),
  data_dir = registry_file_parse(corpus, registry_dir)[["home"]],
  skip = character(),
  to = c("latin1", "UTF-8"),
  verbose = TRUE
)

corpus_testload(
  corpus,
  registry_dir = Sys.getenv("CORPUS_REGISTRY"),
  verbose = TRUE
)

corpus_get_version(corpus, registry_dir = Sys.getenv("CORPUS_REGISTRY"))

corpus_reload(corpus, registry_dir, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="corpus_install_+3A_pkg">pkg</code></td>
<td>
<p>Name of a package (length-one <code>character</code> vector).</p>
</td></tr>
<tr><td><code id="corpus_install_+3A_repo">repo</code></td>
<td>
<p>URL of the repository.</p>
</td></tr>
<tr><td><code id="corpus_install_+3A_tarball">tarball</code></td>
<td>
<p>URL,  S3-URI or local filename of a tarball with a CWB indexed
corpus. If <code>NULL</code> (default) and argument <code>doi</code> is stated, the
whereabouts of a corpus tarball will be derived from DOI.</p>
</td></tr>
<tr><td><code id="corpus_install_+3A_doi">doi</code></td>
<td>
<p>The DOI (Digital Object Identifier) of a corpus deposited at
Zenodo (e.g. &quot;10.5281/zenodo.3748858&quot;.)</p>
</td></tr>
<tr><td><code id="corpus_install_+3A_checksum">checksum</code></td>
<td>
<p>A length-one <code>character</code> vector with a MD5 checksum to
check for the integrity of a downloaded tarball. If the tarball is
downloaded from Zenodo by stating a DOI (argument <code>doi</code>), the checksum
included in the metadata for the record is used for the check.</p>
</td></tr>
<tr><td><code id="corpus_install_+3A_lib">lib</code></td>
<td>
<p>Directory for R packages, defaults to <code>.libPaths()[1]</code>.</p>
</td></tr>
<tr><td><code id="corpus_install_+3A_registry_dir">registry_dir</code></td>
<td>
<p>The corpus registry directory. If missing, the result of
<code>cwb_registry_dir()</code>.</p>
</td></tr>
<tr><td><code id="corpus_install_+3A_corpus_dir">corpus_dir</code></td>
<td>
<p>The directory that contains the data directories of indexed
corpora. If missing, the value of <code>cwb_corpus_dir()</code> will be used.</p>
</td></tr>
<tr><td><code id="corpus_install_+3A_ask">ask</code></td>
<td>
<p>A <code>logical</code> value, whether to ask user for confirmation before
removing a corpus.</p>
</td></tr>
<tr><td><code id="corpus_install_+3A_load">load</code></td>
<td>
<p>A <code>logical</code> value, whether to load corpus after installation.</p>
</td></tr>
<tr><td><code id="corpus_install_+3A_verbose">verbose</code></td>
<td>
<p>Logical, whether to be verbose.</p>
</td></tr>
<tr><td><code id="corpus_install_+3A_user">user</code></td>
<td>
<p>A user name that can be specified to download a corpus from a
password protected site.</p>
</td></tr>
<tr><td><code id="corpus_install_+3A_password">password</code></td>
<td>
<p>A password that can be specified to download a corpus from a
password protected site.</p>
</td></tr>
<tr><td><code id="corpus_install_+3A_...">...</code></td>
<td>
<p>Further parameters that will be passed into <code>download.file()</code>, if
<code>tarball</code> is specified.</p>
</td></tr>
<tr><td><code id="corpus_install_+3A_old">old</code></td>
<td>
<p>Name of the (old) corpus.</p>
</td></tr>
<tr><td><code id="corpus_install_+3A_new">new</code></td>
<td>
<p>Name of the (new) corpus.</p>
</td></tr>
<tr><td><code id="corpus_install_+3A_corpus">corpus</code></td>
<td>
<p>The ID of a CWB indexed corpus (in upper case).</p>
</td></tr>
<tr><td><code id="corpus_install_+3A_data_dir">data_dir</code></td>
<td>
<p>The data directory where the files of the CWB corpus live.</p>
</td></tr>
<tr><td><code id="corpus_install_+3A_tarfile">tarfile</code></td>
<td>
<p>Filename of tarball.</p>
</td></tr>
<tr><td><code id="corpus_install_+3A_registry_dir_new">registry_dir_new</code></td>
<td>
<p>Target directory with for (new) registry files.</p>
</td></tr>
<tr><td><code id="corpus_install_+3A_data_dir_new">data_dir_new</code></td>
<td>
<p>Target directory for corpus files.</p>
</td></tr>
<tr><td><code id="corpus_install_+3A_remove">remove</code></td>
<td>
<p>A <code>logical</code> value, whether to remove orginal files after having
created the copy.</p>
</td></tr>
<tr><td><code id="corpus_install_+3A_progress">progress</code></td>
<td>
<p>Logical, whether to show a progress bar.</p>
</td></tr>
<tr><td><code id="corpus_install_+3A_skip">skip</code></td>
<td>
<p>A character vector with s_attributes to skip.</p>
</td></tr>
<tr><td><code id="corpus_install_+3A_to">to</code></td>
<td>
<p>Character string describing the target encoding of the corpus.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A CWB corpus consists a set of binary files with corpus data
kept together in a data directory, and a registry file, which is a
plain test file that details the corpus id, corpus properties,
structural and positional attributes. The registry file also specifies
the path to the corpus data directory. Typically, the registry directory
and a corpus directory with the data directories for individual corpora
are within one parent folder (which might be called &quot;cwb&quot; by default).
See the following stylized directory structure.
</p>
<pre>
  .
  |- registry/
  |  |- corpus1
  |  +- corpus2
  |
  + indexed_corpora/
    |- corpus1/
    |  |- file1
    |  |- file2
    |  +- file3
    |
    +- corpus2/
       |- file1
       |- file2
       +- file3
</pre>
<p>The <code>corpus_install()</code> function will assist the installation of a
corpus. The following scenarios are offered:
</p>

<ul>
<li><p>If argument <code>tarball</code> is a local tarball, the tarball will
be extracted and files will be moved.
</p>
</li>
<li><p>If <code>tarball</code> is a URL, the tarball will be downloaded from the online
location. It is possible to state user credentials using the arguments
<code>user</code> and <code>password</code>. Then the aforementioned installation (scenario 1) is
executed. If argument <code>pkg</code> is the name of an installed package, corpus
files will be moved into this package.
</p>
</li>
<li><p>If argument <code>doi</code> is Document Object Identifier (DOI), the URL from
which a corpus tarball can be downloaded is derived from the information
available at that location. The tarball is downloaded and the corpus
installed. If argument <code>pkg</code> is defined, files will be moved into a R
package, the syste registry and corpus directories are used otherwise. Note
that at this stage, it is assumed that the DOI has been awarded by
<a href="https://zenodo.org/">Zenodo</a>
</p>
</li>
<li><p>If argument <code>pkg</code> is provided and <code>tarball</code> is <code>NULL</code>, corpora
included in the package will be installed as system corpora, using the
storage location specified by <code>registry_dir</code>. 
</p>
</li></ul>

<p>If the corpus to be installed is already available, a dialogue will ask the
user whether an existing corpus shall be deleted and installed anew, if
argument <code>ask</code> is <code>TRUE</code>.
</p>
<p><code>corpus_packages()</code> will detect the packages that include CWB
corpora. Note that the directory structure of all installed packages is
evaluated which may be slow on network-mounted file systems.
</p>
<p><code>corpus_rename()</code> will rename a corpus, affecting the name of the
registry file, the corpus id, and the name of the directory where data
files reside.
</p>
<p><code>corpus_remove()</code> can be used to delete a corpus.
</p>
<p><code>corpus_as_tarball()</code> will create a tarball (.tar.gz-file) with
two subdirectories. The 'registry' subdirectory will host the registry file
for the tarred corpus. The data files will be put in a subdirectory with
the corpus name in the 'indexed_corpora' subdirectory.
</p>
<p><code>corpus_copy()</code> will create a copy of a corpus (useful for
experimental modifications, for instance).
</p>
<p><code>corpus_get_version</code> parses the registry file and derives the
corpus version number from the corpus properties. The return value is a
<code>numeric_version</code> class object. The corpus version is expected to follow
semantic versioning (three digits, e.g. '0.8.1'). If the corpus version
has another format or if it is not available, the return value is <code>NA</code>.
</p>
<p><code>corpus_reload()</code> will unload a corpus if necessary and reload it.
Useful to make new features of a corpus available after modification.
Returns logical value <code>TRUE</code> if succesful, <code>FALSE</code> if not.
</p>


<h3>Value</h3>

<p>Logical value <code>TRUE</code> if installation has been successful, or <code>FALSE</code>
if not.
</p>


<h3>See Also</h3>

<p>For managing registry files, see <code><a href="#topic+registry_file_parse">registry_file_parse</a></code>
for switching to a packaged corpus.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>registry_file_new &lt;- fs::path(tempdir(), "cwb", "registry", "reuters")
if (file.exists(registry_file_new)) file.remove(registry_file_new)
corpus_copy(
  corpus = "REUTERS",
  registry_dir = system.file(package = "RcppCWB", "extdata", "cwb", "registry"),
  data_dir = system.file(
    package = "RcppCWB",
    "extdata", "cwb", "indexed_corpora", "reuters"
  )
)
unlink(fs::path(tempdir(), "cwb"), recursive = TRUE)
corpus &lt;- "REUTERS"
pkg &lt;- "RcppCWB"
s_attr &lt;- "places"
Q &lt;- '"oil"'

registry_dir_src &lt;- system.file(package = pkg, "extdata", "cwb", "registry")
data_dir_src &lt;- system.file(package = pkg, "extdata", "cwb", "indexed_corpora", tolower(corpus))

registry_dir_tmp &lt;- fs::path(tempdir(), "cwb", "registry")
registry_file_tmp &lt;- fs::path(registry_dir_tmp, tolower(corpus))
data_dir_tmp &lt;- fs::path(tempdir(), "cwb", "indexed_corpora", tolower(corpus))

if (file.exists(registry_file_tmp)) file.remove(registry_file_tmp)
if (!dir.exists(data_dir_tmp)){
   dir.create(data_dir_tmp, recursive = TRUE)
} else {
  if (length(list.files(data_dir_tmp)) &gt; 0L)
    file.remove(list.files(data_dir_tmp, full.names = TRUE))
}

corpus_copy(
  corpus = corpus,
  registry_dir = registry_dir_src,
  data_dir = data_dir_src,
  registry_dir_new = registry_dir_tmp,
  data_dir_new = data_dir_tmp
)

RcppCWB::cl_charset_name(corpus = corpus, registry = registry_dir_tmp)

corpus_recode(
  corpus = corpus,
  registry_dir = registry_dir_tmp,
  data_dir = data_dir_tmp,
  to = "UTF-8"
)

RcppCWB::cl_delete_corpus(corpus = corpus, registry = registry_dir_tmp)
RcppCWB::cqp_initialize(registry_dir_tmp)
RcppCWB::cl_charset_name(corpus = corpus, registry = registry_dir_tmp)

n_strucs &lt;- RcppCWB::cl_attribute_size(
  corpus = corpus, attribute = s_attr, attribute_type = "s", registry = registry_dir_tmp
)
strucs &lt;- 0L:(n_strucs - 1L)
struc_values &lt;- RcppCWB::cl_struc2str(
  corpus = corpus, s_attribute = s_attr, struc = strucs, registry = registry_dir_tmp
)
speakers &lt;- unique(struc_values)

Sys.setenv("CORPUS_REGISTRY" = registry_dir_tmp)
if (RcppCWB::cqp_is_initialized()) RcppCWB::cqp_reset_registry() else RcppCWB::cqp_initialize()
RcppCWB::cqp_query(corpus = corpus, query = Q)
cpos &lt;- RcppCWB::cqp_dump_subcorpus(corpus = corpus)
ids &lt;- RcppCWB::cl_cpos2id(
  corpus = corpus, p_attribute = "word", registry = registry_dir_tmp, cpos = cpos
)
str &lt;- RcppCWB::cl_id2str(
  corpus = corpus, p_attribute = "word", registry = registry_dir_tmp, id = ids
)
unique(str)

unlink(fs::path(tempdir(), "cwb"), recursive = TRUE)
</code></pre>

<hr>
<h2 id='CorpusData'>Manage Corpus Data and Encode CWB Corpus.</h2><span id='topic+CorpusData'></span>

<h3>Description</h3>

<p>Manage Corpus Data and Encode CWB Corpus.
</p>
<p>Manage Corpus Data and Encode CWB Corpus.
</p>


<h3>Details</h3>

<p>See the <a href="https://cwb.sourceforge.io/files/CWB_Encoding_Tutorial.pdf">CWB Encoding Tutorial</a> on
characters allowed for encoding attributes: &quot;By convention, all attribute
names must be lowercase (more precisely, they may only contain the characters
a-z, 0-9, -, and _, and may not start with a digit). Therefore, the names of
XML elements to be included in the CWB corpus must not contain any non-ASCII
or uppercase letters.&quot; (section 2)
</p>
<p>Import XML files.
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>chunktable</code></dt><dd><p>A <code>data.table</code> with column &quot;id&quot; (unique values),
columns with metadata, and a column with text chunks.</p>
</dd>
<dt><code>tokenstream</code></dt><dd><p>A <code>data.table</code> with a column &quot;cpos&quot; (corpus position), and
columns with positional attributes, such as &quot;word&quot;, &quot;lemma&quot;, &quot;pos&quot;, &quot;stem&quot;.</p>
</dd>
<dt><code>metadata</code></dt><dd><p>A <code>data.table</code> with a column &quot;id&quot;, to link data with
chunks/tokenstream, columns with document-level metadata, and a column
&quot;cpos_left&quot; and &quot;cpos_right&quot;, which can be generated using method
<code style="white-space: pre;">&#8288;$add_corpus_positions()&#8288;</code>.</p>
</dd>
<dt><code>sentences</code></dt><dd><p>A <code>data.table</code>.</p>
</dd>
<dt><code>named_entities</code></dt><dd><p>A <code>data.table</code>.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-CorpusData-new"><code>CorpusData$new()</code></a>
</p>
</li>
<li> <p><a href="#method-CorpusData-print"><code>CorpusData$print()</code></a>
</p>
</li>
<li> <p><a href="#method-CorpusData-tokenize"><code>CorpusData$tokenize()</code></a>
</p>
</li>
<li> <p><a href="#method-CorpusData-import_xml"><code>CorpusData$import_xml()</code></a>
</p>
</li>
<li> <p><a href="#method-CorpusData-add_corpus_positions"><code>CorpusData$add_corpus_positions()</code></a>
</p>
</li>
<li> <p><a href="#method-CorpusData-purge"><code>CorpusData$purge()</code></a>
</p>
</li>
<li> <p><a href="#method-CorpusData-encode"><code>CorpusData$encode()</code></a>
</p>
</li>
<li> <p><a href="#method-CorpusData-clone"><code>CorpusData$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-CorpusData-new"></a>



<h4>Method <code>new()</code></h4>

<p>Initialize a new instance of class <code>CorpusData</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>CorpusData$new()</pre></div>



<h5>Returns</h5>

<p>A class <code>CorpusData</code> object.
</p>


<hr>
<a id="method-CorpusData-print"></a>



<h4>Method <code>print()</code></h4>

<p>Print summary of <code>CorpusData</code> object.
</p>


<h5>Usage</h5>

<div class="r"><pre>CorpusData$print()</pre></div>


<hr>
<a id="method-CorpusData-tokenize"></a>



<h4>Method <code>tokenize()</code></h4>

<p>Simple tokenization of text in chunktable.
</p>


<h5>Usage</h5>

<div class="r"><pre>CorpusData$tokenize(..., verbose = TRUE, progress = TRUE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p>Arguments that are passed into <code>tokenizers::tokenize_words()</code>.</p>
</dd>
<dt><code>verbose</code></dt><dd><p>A logical value, whether to be verbose.</p>
</dd>
<dt><code>progress</code></dt><dd><p>A logical value, whether to show progress bar.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-CorpusData-import_xml"></a>



<h4>Method <code>import_xml()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>CorpusData$import_xml(
  filenames,
  body = "//body",
  meta = NULL,
  mc = NULL,
  progress = TRUE
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>filenames</code></dt><dd><p>A vector of files to process.</p>
</dd>
<dt><code>body</code></dt><dd><p>An xpath expression defining the body of the XML document.</p>
</dd>
<dt><code>meta</code></dt><dd><p>A named character vector with XPath expressions.</p>
</dd>
<dt><code>mc</code></dt><dd><p>A numeric/integer value, number of cores to use.</p>
</dd>
<dt><code>progress</code></dt><dd><p>A logical value, whether to show progress bar.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>The <code>CorpusData</code> object is returned invisibly.
</p>


<hr>
<a id="method-CorpusData-add_corpus_positions"></a>



<h4>Method <code>add_corpus_positions()</code></h4>

<p>Add column 'cpos' to tokenstream and columns 'cpos_left' and
'cpos_right' to metadata.
</p>


<h5>Usage</h5>

<div class="r"><pre>CorpusData$add_corpus_positions(verbose = TRUE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>verbose</code></dt><dd><p>A logical value, whether to be verbose.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-CorpusData-purge"></a>



<h4>Method <code>purge()</code></h4>

<p>Remove patterns from chunkdata that are known to cause problems. This is
done most efficiently at the chunkdata level of data preparation as the
length of the character vector to handle is much smaller than when
tokenization/annotation has been performed.
</p>


<h5>Usage</h5>

<div class="r"><pre>CorpusData$purge(
  replacements = list(c("^\\s*&lt;.*?&gt;\\s*$", ""), c("’", "'"))
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>replacements</code></dt><dd><p>A list of length-two character vectors with regular
expressions and replacements.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-CorpusData-encode"></a>



<h4>Method <code>encode()</code></h4>

<p>Encode corpus. If the corpus already exists, it will be removed.
</p>


<h5>Usage</h5>

<div class="r"><pre>CorpusData$encode(
  corpus,
  p_attributes = "word",
  s_attributes = NULL,
  encoding,
  registry_dir = Sys.getenv("CORPUS_REGISTRY"),
  data_dir = NULL,
  method = c("R", "CWB"),
  verbose = TRUE,
  compress = FALSE,
  reload = TRUE,
  quietly = TRUE
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>corpus</code></dt><dd><p>The name of the CWB corpus.</p>
</dd>
<dt><code>p_attributes</code></dt><dd><p>Positional attributes.</p>
</dd>
<dt><code>s_attributes</code></dt><dd><p>Columns that will be encoded as structural attributes.</p>
</dd>
<dt><code>encoding</code></dt><dd><p>Encoding/charset of the CWB corpus.</p>
</dd>
<dt><code>registry_dir</code></dt><dd><p>Corpus registry, the directory where registry files are
stored.</p>
</dd>
<dt><code>data_dir</code></dt><dd><p>Directory where to create directory for indexed corpus files.</p>
</dd>
<dt><code>method</code></dt><dd><p>Either &quot;R&quot; or &quot;CWB&quot;.</p>
</dd>
<dt><code>verbose</code></dt><dd><p>A logical value, whether to be verbose.</p>
</dd>
<dt><code>compress</code></dt><dd><p>A logical value, whether to compress corpus.</p>
</dd>
<dt><code>reload</code></dt><dd><p>A <code>logical</code> value, whether to reload corpus.</p>
</dd>
<dt><code>quietly</code></dt><dd><p>A <code>logical</code> value passed into <code>RcppCWB::cwb_makeall()</code>,
<code>RcppCWB::cwb_huffcode()</code> and <code>RcppCWB::cwb_compress_rdx</code> to control
verbosity of these functions.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-CorpusData-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>CorpusData$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'>library(RcppCWB)
library(data.table)

# this example relies on the R method to write data to disk, there is also a method "CWB"
# that relies on CWB tools to generate the indexed corpus. The CWB can downloaded
# and installed within the package by calling cwb_install()

# create temporary registry file so that data in RcppCWB package can be used

registry_rcppcwb &lt;- system.file(package = "RcppCWB", "extdata", "cwb", "registry")
registry_tmp &lt;- fs::path(tempdir(), "registry")
if (!dir.exists(registry_tmp)) dir.create(registry_tmp)
r &lt;- registry_file_parse("REUTERS", registry_dir = registry_rcppcwb)
r[["home"]] &lt;- system.file(package = "RcppCWB", "extdata", "cwb", "indexed_corpora", "reuters")
registry_file_write(r, corpus = "REUTERS", registry_dir = registry_tmp)

# decode structural attribute 'places'

s_attrs_places &lt;- RcppCWB::s_attribute_decode(
  corpus = "REUTERS",
  data_dir = system.file(package = "RcppCWB", "extdata", "cwb", "indexed_corpora", "reuters"),
  s_attribute = "places", method = "R"
)
s_attrs_places[["id"]] &lt;- 1L:nrow(s_attrs_places)
setnames(s_attrs_places, old = "value", new = "places")

# decode positional attribute 'word'

tokens &lt;- apply(s_attrs_places, 1, function(row){
  ids &lt;- cl_cpos2id(
    corpus = "REUTERS", cpos = row[1]:row[2],
    p_attribute = "word", registry = registry_tmp
  )
  cl_id2str(corpus = "REUTERS", id = ids, p_attribute = "word", registry = registry_tmp)
})
tokenstream &lt;- rbindlist(
lapply(
  1L:length(tokens),
  function(i) data.table(id = i, word = tokens[[i]]))
  )
tokenstream[["cpos"]] &lt;- 0L:(nrow(tokenstream) - 1L)

# create CorpusData object (see vignette for further explanation)

CD &lt;- CorpusData$new()
CD$tokenstream &lt;- as.data.table(tokenstream)
CD$metadata &lt;- as.data.table(s_attrs_places)

# Remove temporary registry with home dir still pointing to RcppCWB data dir
# to prevent data from being deleted
file.remove(fs::path(registry_tmp, "reuters"))
file.remove(registry_tmp)

# create temporary directories (registry directory and one for indexed corpora)

registry_tmp &lt;- fs::path(tempdir(), "registry")
data_dir_tmp &lt;- fs::path(tempdir(), "data_dir")
if (!dir.exists(registry_tmp)) dir.create(registry_tmp)
if (!dir.exists(data_dir_tmp)) dir.create(data_dir_tmp)

CD$encode(
  corpus = "REUTERS", encoding = "utf8",
  p_attributes = "word", s_attributes = "places",
  registry_dir = registry_tmp, data_dir = data_dir_tmp,
  method = "R"
)
reg &lt;- registry_data(name = "REUTERS", id = "REUTERS", home = data_dir_tmp, p_attributes = "word")
registry_file_write(data = reg, corpus = "REUTERS", registry_dir = registry_tmp)

# see whether it works

cl_cpos2id(corpus = "REUTERS", p_attribute = "word", cpos = 0L:4049L, registry = registry_tmp)
</code></pre>

<hr>
<h2 id='cwb_corpus_dir'>Manage directories for indexed corpora</h2><span id='topic+cwb_corpus_dir'></span><span id='topic+cwb_registry_dir'></span><span id='topic+cwb_directories'></span><span id='topic+create_cwb_directories'></span><span id='topic+use_corpus_registry_envvar'></span>

<h3>Description</h3>

<p>The Corpus Workbench (CWB) stores the binary files for
structural and positional attributes in an individual 'data directory'
(referred to by argument <code>data_dir</code>) for each corpus. The data
directories will typically be subdirectories of a parent directory called
'corpus directory' (argument <code>corpus_dir</code>). Irrespective of the
location of the data directories, all corpora available on a machine are
described by so-called (plain text) registry files stored in a so-called
'registry directory' (referred to by argument <code>registry_dir</code>).  The
functionality to manage theses directories is used as auxiliary
functionality by higher-level functionality to download and install
corpora.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cwb_corpus_dir(registry_dir, verbose = TRUE)

cwb_registry_dir(verbose = TRUE)

cwb_directories(registry_dir = NULL, corpus_dir = NULL, verbose = TRUE)

create_cwb_directories(prefix = "~/cwb", ask = interactive(), verbose = TRUE)

use_corpus_registry_envvar(registry_dir)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cwb_corpus_dir_+3A_registry_dir">registry_dir</code></td>
<td>
<p>Path to the directory with registry files.</p>
</td></tr>
<tr><td><code id="cwb_corpus_dir_+3A_verbose">verbose</code></td>
<td>
<p>A <code>logical</code> value, whether to output status messages.</p>
</td></tr>
<tr><td><code id="cwb_corpus_dir_+3A_corpus_dir">corpus_dir</code></td>
<td>
<p>Path to the directory with data directories for corpora.</p>
</td></tr>
<tr><td><code id="cwb_corpus_dir_+3A_prefix">prefix</code></td>
<td>
<p>The base path that will be prefixed</p>
</td></tr>
<tr><td><code id="cwb_corpus_dir_+3A_ask">ask</code></td>
<td>
<p>A <code>logical</code> value, whether to prompt user before creating
directories.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>cwb_corpus_dir</code> will make a plausible suggestion for a corpus
directory where data directories for corpora reside. The procedure requires
that  the registry directory (argument <code>registry_dir</code>) is known. If
the argument <code>registry_dir</code> is missing, the registry directory will be
guessed by calling <code>cwb_registry_dir</code>. The heuristic to detect the
corpus directory is as follows: First, directories in the parent directory
of the registry directory that contain &quot;corpus&quot; or &quot;corpora&quot; are suggested.
If this does not yield a result, the data directories stated in the
registry files are evaluated. If there is one unique parent directory of
data directories (after removing temporary directories and directories
within packages), this unique directory is suggested. <code>cwb_corpus_dir</code>
will return a length-one <code>character</code> vector with the path of the
suggested corpus directory, or <code>NULL</code> if the heuristic does not yield
a result.
</p>
<p><code>cwb_registry_dir()</code> will return return the system registry
directory. By default, the environment variable CORPUS_REGISTRY defines the
system registry directory. If the polmineR-package is loaded, a temporary
registry directory is used, replacing the system registry directory. In
this case, <code>cwb_registry_dir()</code> will retrieve the directory from the option
'polmineR.corpus_registry'. The return value is a length-one character
vector or <code>NULL</code>, if no registry directory can be detected.
</p>
<p><code>cwb_directories</code> will return a named character vector with the
registry directory and the corpus directory.
</p>
<p><code>create_cwb_directories</code> will create a 'registry' and an
'indexed_corpora' directory as subdirectories of the directory indicated by
argument <code>prefix</code>. Argument <code>ask</code> indicates whether to create
directories, and whether user feedback is asked for before creating the
directories. The function returns a named character vector with the
registry and the corpus directory.
</p>
<p><code>use_corpus_registry_envvar()</code> is a convenience function that will
assist users to define the environment variable CORPUS_REGSITRY in the
.Renviron-file.  making it available across sessions. The function is
intended to be used in an interactive R session. An error is thrown if this
is not the case. The user will be prompted whether the cwbtools package
shall take care of creating / modifying the .Renviron-file. If not, the
file will be opened for manual modification with some instructions shown in
the terminal.
</p>

<hr>
<h2 id='cwb_install'>Utilities to install the Corpus Workbench (CWB)</h2><span id='topic+cwb_install'></span><span id='topic+cwb_get_url'></span><span id='topic+cwb_get_bindir'></span><span id='topic+cwb_is_installed'></span>

<h3>Description</h3>

<p>The CWB comprises a set of command line tools for corpus preparation and
management. Functionality for installing and managing these Tools.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cwb_install(
  url_cwb = cwb_get_url(),
  md5 = attr(url_cwb, "md5"),
  cwb_dir = fs::path(fs::path_temp(), "cwb"),
  verbose = TRUE
)

cwb_get_url()

cwb_get_bindir(bindir = Sys.getenv("CWB_BINDIR"), verbose = TRUE)

cwb_is_installed()
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cwb_install_+3A_url_cwb">url_cwb</code></td>
<td>
<p>URL for downloading the CWB.</p>
</td></tr>
<tr><td><code id="cwb_install_+3A_md5">md5</code></td>
<td>
<p>The md5 checksum of the compressed file to be downloaded.</p>
</td></tr>
<tr><td><code id="cwb_install_+3A_cwb_dir">cwb_dir</code></td>
<td>
<p>The directory where the CWB shall be installed.</p>
</td></tr>
<tr><td><code id="cwb_install_+3A_verbose">verbose</code></td>
<td>
<p>Logical, whether to show progress messages.</p>
</td></tr>
<tr><td><code id="cwb_install_+3A_bindir">bindir</code></td>
<td>
<p>The directory with CWB binaries.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Use <code>cwb_install()</code> to download and install CWB binaries (v3.5) from
<a href="https://cwb.sourceforge.io/">SourceForge</a>. If successful, <code>cwb_install()</code>
returns the directory of the CWB, otherwiese <code>NULL</code>. For the installation
on macOS and Linux, see <a href="https://cwb.sourceforge.io/install.php">https://cwb.sourceforge.io/install.php</a>.
</p>
<p><code>cwb_get_url()</code> will return the URL for downloading the appropriate
binary (Linux / macOS) of the CWB (v3.5), or the source tarball
(Linux). The md5 checksum of the file to be downloaded is part of the
return value as &quot;md5&quot; attribute.
</p>
<p><code>cwb_get_bindir()</code> detects the directory with the cwb command line
programs. Defaults to using the value of the environment
variable &quot;CWB_BINDIR&quot;. If unset, the value of <code>cwb-config --bindir</code> is
used. Returns <code>NULL</code> if CWB installation is not found.
</p>
<p><code>cwb_is_installed()</code> will check whether the CWB is installed.
</p>

<hr>
<h2 id='cwbtools-package'>cwbtools-package</h2><span id='topic+cwbtools-package'></span><span id='topic+cwbtools'></span>

<h3>Description</h3>

<p>Tools to Create, Modify and Manage CWB Corpora.
</p>


<h3>Details</h3>

<p>The <a href="https://cwb.sourceforge.io/"><em>Corpus Workbench</em></a> (CWB) offers
a classic approach for working with large, linguistically and structurally
annotated corpora. Its design ensures memory efficiency and makes running
queries fast (Evert and Hardie 2011). Technically, indexing and compressing
corpora as suggested by Witten et al. (1999) is the approach implemented by
the CWB (Christ 1994).
</p>
<p>The C implementation of the CWB is mature and efficient. However, the
convenience and flexibility of traditional CWB command line tools is limited.
These tools are not portable across platforms, inhibiting the ideal of
reproducible research.
</p>
<p>The 'cwbtools' package combines portable pure R tools to create indexed
corpus files and convenience wrappers for the original C implementation of
CWB as exposed by the
<a href="https://CRAN.R-project.org/package=RcppCWB">RcppCWB</a> package.
Additional functionality to add and modify annotations of corpora from within
R makes working with CWB indexed corpora much more flexible. &quot;Pure R&quot; workflows
to enrich corpora with annotations using standard NLP tools or generated
manually can be implemented seamlessly and conveniently.
</p>
<p>The <em>cwbtools</em> package is a companion of the
<a href="https://CRAN.R-project.org/package=RcppCWB">RcppCWB</a> and the
<a href="https://CRAN.R-project.org/package=polmineR">polmineR</a> package and is a
building block of an infrastructure to support the combination of
quantitative and qualitative approaches when working with textual data.
</p>


<h3>Author(s)</h3>

<p>Andreas Blaette
</p>


<h3>References</h3>

<p>Christ, Oliver (1994): &quot;A Modular and Flexible Architecture for
an Integrated Corpus Query System&quot;. <em>Proceedings of COMPLEX'94</em>,
pp.23-32. <a href="https://arxiv.org/pdf/cmp-lg/9408005.pdf">(available online here)</a>
</p>
<p>Evert, Stefan and Andrew Hardie (2011): &quot;Twenty-first
century Corpus Workbench: Updating a query architecture for the new
millennium.&quot; In: <em>Proceedings of the Corpus Linguistics 2011 conference</em>,
University of Birmingham, UK.
<a href="https://www.birmingham.ac.uk/documents/college-artslaw/corpus/conference-archives/2011/Paper-153.pdf">(available online here)</a>
</p>
<p>Witten, Ian H., Alistair Moffat and Timothy C. Bell (1999):
<em>Managing Gigabytes: Compressing and Indexing Documents and Images.</em>
2nd edition. San Francisco et al.: Morgan Kaufmann.
</p>

<hr>
<h2 id='encode'>Encode CWB Corpus.</h2><span id='topic+encode'></span><span id='topic+encode+2Cdata.frame-method'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>encode(x, ...)

## S4 method for signature 'data.frame'
encode(
  x,
  corpus,
  s_attributes = NULL,
  encoding = "utf8",
  registry_dir = fs::path(tempdir(), "cwb_registry"),
  data_dir = fs::path(tempdir(), "cwb_data_dir", tolower(corpus)),
  properties = c(),
  method = c("R", "CWB"),
  verbose = TRUE,
  compress = FALSE,
  reload = TRUE,
  quietly = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="encode_+3A_x">x</code></td>
<td>
<p>A <code>data.frame</code> or an object inheriting from <code>data.frame</code> (such as
<code>tibble</code>, <code>data.table</code>).</p>
</td></tr>
<tr><td><code id="encode_+3A_...">...</code></td>
<td>
<p>Further arguments (unused).</p>
</td></tr>
<tr><td><code id="encode_+3A_corpus">corpus</code></td>
<td>
<p>ID of the CWB corpus to create.</p>
</td></tr>
<tr><td><code id="encode_+3A_s_attributes">s_attributes</code></td>
<td>
<p>A <code>list</code> of <code>data.frame</code> objects with columns 'cpos_left'
and 'cpos_right' and columns with s-attributes, the names of which will
serve as names of s-attributes. It <code>s_attributes</code> is a <code>data.frame</code>, it will
be coerced to a <code>list</code>.</p>
</td></tr>
<tr><td><code id="encode_+3A_encoding">encoding</code></td>
<td>
<p>Encoding as defined in the charset corpus property of the
registry file for the corpus ('latin1' to 'latin9', and 'utf8').</p>
</td></tr>
<tr><td><code id="encode_+3A_registry_dir">registry_dir</code></td>
<td>
<p>Registry directory.</p>
</td></tr>
<tr><td><code id="encode_+3A_data_dir">data_dir</code></td>
<td>
<p>The data directory for the binary files of the corpus.</p>
</td></tr>
<tr><td><code id="encode_+3A_properties">properties</code></td>
<td>
<p>A named <code>character</code> vector with corpus properties that will
be added to the registry file describing the corpus. Names of the vector
indicate a property (such as &quot;version&quot;) and the values of the vector the
values of a corpus property.</p>
</td></tr>
<tr><td><code id="encode_+3A_method">method</code></td>
<td>
<p>Either 'CWB' or 'R', defaults to 'R'. See section 'Details'.</p>
</td></tr>
<tr><td><code id="encode_+3A_verbose">verbose</code></td>
<td>
<p>A <code>logical</code> value, whether to output progress messages.</p>
</td></tr>
<tr><td><code id="encode_+3A_compress">compress</code></td>
<td>
<p>A <code>logical</code> value, whether to run <code>RcppCWB::cwb_huffcode()</code>
and <code>RcppCWB::cwb_compress_rdx()</code> (method 'R'), or command line tools
<code>cwb-huffcode</code> and <code>cwb-compress-rdx</code> (method 'CWB'). Defaults to <code>FALSE</code>
as compression is not stable on Windows.</p>
</td></tr>
<tr><td><code id="encode_+3A_reload">reload</code></td>
<td>
<p>A logical value, whether to reload the corpus to make it
immediatedly available.</p>
</td></tr>
<tr><td><code id="encode_+3A_quietly">quietly</code></td>
<td>
<p>A <code>logical</code> value passed into <code>RcppCWB::cwb_makeall()</code>,
<code>RcppCWB::cwb_huffcode()</code> and <code>RcppCWB::cwb_compress_rdx</code> to control
verbosity of these functions.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
library(tidytext)

registry_tmp &lt;- fs::path(tempdir(), "cwb_registry")
dir.create(registry_tmp)

tidydata &lt;- quanteda::data_char_ukimmig2010 %&gt;%
   as.data.frame() %&gt;%
   as_tibble(rownames = "party") %&gt;%
   rename(`text` = ".")
   
tokenstream &lt;- tidydata %&gt;%
   unnest_tokens(word, text, to_lower = FALSE, strip_punct = FALSE) %&gt;%
   mutate(cpos = 0L:(nrow(.) - 1L))
   
metadata &lt;- tokenstream %&gt;% 
  group_by(party) %&gt;% 
  summarise(cpos_left = min(cpos), cpos_right = max(cpos))

tokenstream %&gt;%
  select(-cpos, -party) %&gt;%
  encode(
    corpus = "UKIMMIG2010",
    s_attributes = metadata,
    properties = c(lang = "en")
  )
</code></pre>

<hr>
<h2 id='get_encoding'>Get Encoding of Character Vector.</h2><span id='topic+get_encoding'></span>

<h3>Description</h3>

<p>Get Encoding of Character Vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_encoding(x, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_encoding_+3A_x">x</code></td>
<td>
<p>a character vector</p>
</td></tr>
<tr><td><code id="get_encoding_+3A_verbose">verbose</code></td>
<td>
<p>logical, whether to output messages</p>
</td></tr>
</table>

<hr>
<h2 id='p_attribute_encode'>Encode Positional Attribute(s).</h2><span id='topic+p_attribute_encode'></span><span id='topic+p_attribute_recode'></span><span id='topic+p_attribute_rename'></span>

<h3>Description</h3>

<p>Generate positional attribute from a character vector of
tokens (the token stream).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>p_attribute_encode(
  token_stream,
  p_attribute = "word",
  registry_dir,
  corpus,
  data_dir,
  method = c("R", "CWB"),
  verbose = TRUE,
  quietly = FALSE,
  encoding = get_encoding(token_stream),
  compress = FALSE,
  reload = TRUE
)

p_attribute_recode(
  data_dir,
  p_attribute,
  from = c("UTF-8", "latin1"),
  to = c("UTF-8", "latin1")
)

p_attribute_rename(
  corpus,
  old,
  new,
  registry_dir,
  verbose = TRUE,
  dryrun = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="p_attribute_encode_+3A_token_stream">token_stream</code></td>
<td>
<p>A <code>character</code> vector with the tokens of the corpus. The
maximum length is 2 147 483 647 (2^31 - 1); a warning is issued if this
threshold is exceeded. See the <a href="https://cwb.sourceforge.io/files/CWB_Encoding_Tutorial.pdf">CWB Encoding Tutorial</a> for
size limitations of corpora. May also be a file.</p>
</td></tr>
<tr><td><code id="p_attribute_encode_+3A_p_attribute">p_attribute</code></td>
<td>
<p>The positional attribute to create - a <code>character</code> vector
containing only lowercase ASCII characters (a-z), digits (0-9), -, and _:
No non-ASCII or uppercase letters allowed. If method is &quot;R&quot;, only one
positional attribute can be encoded at a time. If <code>method</code> is &quot;CWB&quot;, more
than one p-attribute allowed.</p>
</td></tr>
<tr><td><code id="p_attribute_encode_+3A_registry_dir">registry_dir</code></td>
<td>
<p>Registry directory.</p>
</td></tr>
<tr><td><code id="p_attribute_encode_+3A_corpus">corpus</code></td>
<td>
<p>ID of the CWB corpus to create.</p>
</td></tr>
<tr><td><code id="p_attribute_encode_+3A_data_dir">data_dir</code></td>
<td>
<p>The data directory for the binary files of the corpus.</p>
</td></tr>
<tr><td><code id="p_attribute_encode_+3A_method">method</code></td>
<td>
<p>Either 'CWB' or 'R', defaults to 'R'. See section 'Details'.</p>
</td></tr>
<tr><td><code id="p_attribute_encode_+3A_verbose">verbose</code></td>
<td>
<p>A <code>logical</code> value, whether to output progress messages.</p>
</td></tr>
<tr><td><code id="p_attribute_encode_+3A_quietly">quietly</code></td>
<td>
<p>A <code>logical</code> value passed into <code>RcppCWB::cwb_makeall()</code>,
<code>RcppCWB::cwb_huffcode()</code> and <code>RcppCWB::cwb_compress_rdx</code> to control
verbosity of these functions.</p>
</td></tr>
<tr><td><code id="p_attribute_encode_+3A_encoding">encoding</code></td>
<td>
<p>Encoding as defined in the charset corpus property of the
registry file for the corpus ('latin1' to 'latin9', and 'utf8').</p>
</td></tr>
<tr><td><code id="p_attribute_encode_+3A_compress">compress</code></td>
<td>
<p>A <code>logical</code> value, whether to run <code>RcppCWB::cwb_huffcode()</code>
and <code>RcppCWB::cwb_compress_rdx()</code> (method 'R'), or command line tools
<code>cwb-huffcode</code> and <code>cwb-compress-rdx</code> (method 'CWB'). Defaults to <code>FALSE</code>
as compression is not stable on Windows.</p>
</td></tr>
<tr><td><code id="p_attribute_encode_+3A_reload">reload</code></td>
<td>
<p>A <code>logical</code> value that defaults to <code>TRUE</code> to ensure that all
features are available.</p>
</td></tr>
<tr><td><code id="p_attribute_encode_+3A_from">from</code></td>
<td>
<p>Character string describing the current encoding of the attribute.</p>
</td></tr>
<tr><td><code id="p_attribute_encode_+3A_to">to</code></td>
<td>
<p>Character string describing the target encoding of the attribute.</p>
</td></tr>
<tr><td><code id="p_attribute_encode_+3A_old">old</code></td>
<td>
<p>A <code>character</code> vector with p-attributes to be renamed.</p>
</td></tr>
<tr><td><code id="p_attribute_encode_+3A_new">new</code></td>
<td>
<p>A <code>character</code> vector with new names of p-attributes. The vector
needs to have the same length as vector <code>old</code>.</p>
</td></tr>
<tr><td><code id="p_attribute_encode_+3A_dryrun">dryrun</code></td>
<td>
<p>A <code>logical</code> value, whether to suppress actual renaming
operation for inspecting output messages</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Four steps generate the binary CWB corpus data format for positional
attributes: (1) Encode the token stream of the corpus, (2) create index
files, (3) compress token stream and (4) compress index files. Whereas steps
1 and 2 are required to make a corpus work, steps 3 and 4 are optional yet
useful to reduce disk usage and improve performance. See the <a href="https://cwb.sourceforge.io/files/CWB_Encoding_Tutorial.pdf">CQP Corpus Encoding Tutorial</a>
(sections 2-4) for an explanation of the procedure.
</p>
<p><code>p_attribute_encode()</code> offers an R and a CWB implementation controlled by
argument <code>method</code>. When choosing method 'R', the token stream is encoded in
'pure R', then the C implementation of CWB functionality as exposed to R via
the RcppCWB package is used (functions <code>RcppCWB::cwb_makeall()</code> for indexing,
<code>RcppCWB::cwb_huffcode()</code> and <code>RcppCWB::cwb_compress_rdx()</code> for compression).
When choosing method 'CWB', the token stream is written to disk, then CWB
command line utilities 'cwb-encode', cwb-makeall', 'cwb-huffcode' and
'cwb-compress-rdx' are called using <code>system2()</code>. The CWB-method requires an
installation of the 'CWB'. The <code>cwb_install()</code> function will download and #
install the CWB command line tools within the package. The 'CWB'-method is
still supported as it is used in the test suite of the packaage. The
'R'-method is robust and is recommended.
</p>
<p><code>p_attribute_recode()</code> will recode the values in the avs-file and
change the attribute value index in the avx file. The rng-file remains
unchanged. The registry file remains unchanged, and it is highly
recommended to consider <code>s_attribute_recode()</code> as a helper for
<code>corpus_recode()</code> that will recode all s-attributes, all p-attributes, and
will reset the encoding in the registry file.
</p>
<p>Function <code>p_attribute_rename()</code> can be used to rename a
positional attribute. Note that the corpus is not refreshed (unloaded,
re-loaded), so it may be necessary to restart R for changes to become
effective.
</p>


<h3>Value</h3>

<p><code>TRUE</code> is returned invisibly, if encoding has been successful.
<code>FALSE</code> indicates an error has occurred.
</p>


<h3>Author(s)</h3>

<p>Christoph Leonhardt, Andreas Blaette
</p>


<h3>Examples</h3>

<pre><code class='language-R'># In this example, we follow a "pure R" approach. 
library(dplyr)

reu &lt;- system.file(package = "RcppCWB", "extdata", "examples", "reuters.txt")
tokens &lt;- readLines(reu)

# Create new (and empty) directory structure

registry_tmp &lt;- fs::path(tempdir(), "registry")
data_dir_tmp &lt;- fs::path(tempdir(), "data_dir", "reuters")

if (dir.exists(registry_tmp)) unlink(registry_tmp, recursive = TRUE)
if (dir.exists(data_dir_tmp)) unlink(data_dir_tmp, recursive = TRUE)

dir.create(registry_tmp)
dir.create(data_dir_tmp, recursive = TRUE)

# Encode token stream (without compression)

p_attribute_encode(
  corpus = "reuters",
  token_stream = tokens,
  p_attribute = "word",
  data_dir = data_dir_tmp,
  registry_dir = registry_tmp,
  method = "R",
  compress = FALSE,
  quietly = TRUE,
  encoding = "utf8"
)

# Augment registry file 

registry_file_parse(corpus = "REUTERS", registry_dir = registry_tmp) %&gt;%
  registry_set_name("Reuters Sample Corpus") %&gt;%
  registry_set_property("charset", "utf8") %&gt;%
  registry_set_property("language", "en") %&gt;%
  registry_set_property("build_date", as.character(Sys.Date())) %&gt;%
  registry_file_write()

# Run query as a test

library(RcppCWB)

cqp_query(corpus = "REUTERS", query = '[]{3} "oil" []{3};')
regions &lt;- cqp_dump_subcorpus(corpus = "REUTERS")

kwic &lt;- apply(
  regions, 1,
  function(region){
    ids &lt;- cl_cpos2id(
      "REUTERS",
      p_attribute = "word",
      registry = registry_tmp,
      cpos = region[1]:region[2]
    )
    words &lt;- cl_id2str(
      corpus = "REUTERS",
      p_attribute = "word",
      registry = registry_tmp,
      id = ids
    )
    paste0(words, collapse = " ")
  }
)
kwic[1:10]
</code></pre>

<hr>
<h2 id='pkg_utils'>Create and manage packages with corpus data.</h2><span id='topic+pkg_utils'></span><span id='topic+pkg_create_cwb_dirs'></span><span id='topic+pkg_add_corpus'></span><span id='topic+pkg_add_configure_scripts'></span><span id='topic+pkg_add_description'></span><span id='topic+pkg_add_creativecommons_license'></span><span id='topic+pkg_add_gitattributes_file'></span>

<h3>Description</h3>

<p>Putting CWB indexed corpora into R data packages is a convenient way to ship
and share corpora, and to keep documentation and supplementary functionality
with the data.
</p>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pkg_create_cwb_dirs(pkg = ".", verbose = TRUE)

pkg_add_corpus(
  pkg = ".",
  corpus,
  registry = Sys.getenv("CORPUS_REGISTRY"),
  verbose = TRUE
)

pkg_add_configure_scripts(pkg = ".")

pkg_add_description(
  pkg = ".",
  package = NULL,
  version = "0.0.1",
  date = Sys.Date(),
  author,
  maintainer = NULL,
  description = "",
  license = "",
  verbose = TRUE
)

pkg_add_creativecommons_license(
  pkg = ".",
  license = "CC-BY-NC-SA",
  file = system.file(package = "cwbtools", "txt", "licenses", "CC_BY-NC-SA_3.0.txt")
)

pkg_add_gitattributes_file(pkg = ".")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pkg_utils_+3A_pkg">pkg</code></td>
<td>
<p>Path to directory of data package or package name.</p>
</td></tr>
<tr><td><code id="pkg_utils_+3A_verbose">verbose</code></td>
<td>
<p>A <code>logical</code> value, whether to be verbose.</p>
</td></tr>
<tr><td><code id="pkg_utils_+3A_corpus">corpus</code></td>
<td>
<p>Name of the CWB corpus to insert into the package.</p>
</td></tr>
<tr><td><code id="pkg_utils_+3A_registry">registry</code></td>
<td>
<p>Registry directory.</p>
</td></tr>
<tr><td><code id="pkg_utils_+3A_package">package</code></td>
<td>
<p>The package name (<code>character</code>), may not include special
chars, and no underscores ('_').</p>
</td></tr>
<tr><td><code id="pkg_utils_+3A_version">version</code></td>
<td>
<p>The version number of the corpus (defaults to &quot;0.0.1&quot;)</p>
</td></tr>
<tr><td><code id="pkg_utils_+3A_date">date</code></td>
<td>
<p>The date of creation, defaults to <code>Sys.Date()</code>.</p>
</td></tr>
<tr><td><code id="pkg_utils_+3A_author">author</code></td>
<td>
<p>The author of the package, either character vector or object of class <code>person</code>.</p>
</td></tr>
<tr><td><code id="pkg_utils_+3A_maintainer">maintainer</code></td>
<td>
<p>Maintainer, R package style, either <code>character</code> vector or <code>person</code>.</p>
</td></tr>
<tr><td><code id="pkg_utils_+3A_description">description</code></td>
<td>
<p>description of the data package.</p>
</td></tr>
<tr><td><code id="pkg_utils_+3A_license">license</code></td>
<td>
<p>The license.</p>
</td></tr>
<tr><td><code id="pkg_utils_+3A_file">file</code></td>
<td>
<p>Path to file with fulltext of Creative Commons license.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>pkg_creage_cwb_dirs</code> will create the standard directory
structure for storing registry files and indexed corpora within a package
(<code>./inst/extdata/cwb/registry</code> and
<code>./inst/extdata/cwb/indexed_corpora</code>, respectively).
</p>
<p><code>pkg_add_corpus</code> will add the corpus described in registry directory to
the package defined by <code>pkg</code>.
</p>
<p><code>add_configure_script</code> will add standardized and tested
configure scripts <code>configure</code> for Linux and macOS, and
<code>configure.win</code> for Windows to the top level directory of the data
package, and file <code>setpaths.R</code> to <code>tools</code> subdirectory. The
configuration mechanism ensures that the data directory is specified
correctly in the registry files during the installation of the data
package.
</p>
<p><code>pkg_add_description</code> will add a description file to the package.
</p>
<p><code>pkg_add_creativecommons_license</code> will license information to
the DESCRIPTION file, and move file LICENSE to top level directory of the
package.
</p>
<p><code>pkg_add_gitattributes_file</code> will add a file '.gitattributes'
to the package. The file defines types of files that will be tracked by Git
LFS, i.e. they will not be under conventional version control. This is
suitable for large binary files, which is the scenario applicable for
indexed corpus data.
</p>


<h3>References</h3>

<p>Blätte, Andreas (2018). &quot;Using Data Packages to Ship Annotated
Corpora of Parliamentary Protocols: The GermaParl R Package&quot;,
<em>ParlaCLARIN 2018 Workshop Proceedings</em>, available online
<a href="http://lrec-conf.org/workshops/lrec2018/W2/pdf/15_W2.pdf">here</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pkgdir &lt;- fs::path_temp()
pkg_create_cwb_dirs(pkg = pkgdir)
pkg_add_description(
  pkg = pkgdir,
  package = "reuters",
  author = "cwbtools",
  description = "Reuters data package"
 )
pkg_add_corpus(
  pkg = pkgdir, corpus = "REUTERS",
  registry = system.file(package = "RcppCWB", "extdata", "cwb", "registry")
)
pkg_add_gitattributes_file(pkg = pkgdir)
pkg_add_configure_scripts(pkg = pkgdir)
pkg_add_creativecommons_license(pkg = pkgdir)
</code></pre>

<hr>
<h2 id='registry_file_parse'>Parse and create registry files.</h2><span id='topic+registry_file_parse'></span><span id='topic+registry_file_compose'></span><span id='topic+registry_data'></span><span id='topic+registry_file_write'></span><span id='topic+registry_set_property'></span><span id='topic+registry_set_info'></span><span id='topic+registry_set_name'></span>

<h3>Description</h3>

<p>A set of functions to parse, create and write registry files.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>registry_file_parse(corpus, registry_dir = Sys.getenv("CORPUS_REGISTRY"))

registry_file_compose(x)

registry_data(
  name,
  id,
  home,
  info = fs::path(home, ".info"),
  properties = c(charset = "utf-8"),
  p_attributes,
  s_attributes = character()
)

registry_file_write(
  data,
  corpus,
  registry_dir = Sys.getenv("CORPUS_REGISTRY"),
  ...
)

registry_set_property(data, property, value)

registry_set_info(data, info_file)

registry_set_name(data, name)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="registry_file_parse_+3A_corpus">corpus</code></td>
<td>
<p>A CWB corpus indicated by a length-one <code>character</code> vector.</p>
</td></tr>
<tr><td><code id="registry_file_parse_+3A_registry_dir">registry_dir</code></td>
<td>
<p>Directory with registry files.</p>
</td></tr>
<tr><td><code id="registry_file_parse_+3A_x">x</code></td>
<td>
<p>An object of class <code>registry_data</code>.</p>
</td></tr>
<tr><td><code id="registry_file_parse_+3A_name">name</code></td>
<td>
<p>Long descriptive name of the corpus.</p>
</td></tr>
<tr><td><code id="registry_file_parse_+3A_id">id</code></td>
<td>
<p>Short name of corpus (<code>character</code> vector).</p>
</td></tr>
<tr><td><code id="registry_file_parse_+3A_home">home</code></td>
<td>
<p>Path with data directory for indexed corpus.</p>
</td></tr>
<tr><td><code id="registry_file_parse_+3A_info">info</code></td>
<td>
<p>A <code>character</code> vector containing path name of info file.</p>
</td></tr>
<tr><td><code id="registry_file_parse_+3A_properties">properties</code></td>
<td>
<p>Named <code>character</code> vector with corpus properties,
should at least include 'charset'.</p>
</td></tr>
<tr><td><code id="registry_file_parse_+3A_p_attributes">p_attributes</code></td>
<td>
<p>A <code>character</code> vector with positional attributes to
declare.</p>
</td></tr>
<tr><td><code id="registry_file_parse_+3A_s_attributes">s_attributes</code></td>
<td>
<p>A <code>character</code> vector with structural attributes to
declare.</p>
</td></tr>
<tr><td><code id="registry_file_parse_+3A_data">data</code></td>
<td>
<p>A <code>registry_data</code> object.</p>
</td></tr>
<tr><td><code id="registry_file_parse_+3A_...">...</code></td>
<td>
<p>further parameters</p>
</td></tr>
<tr><td><code id="registry_file_parse_+3A_property">property</code></td>
<td>
<p>A single corpus property (<code>character</code> vector).</p>
</td></tr>
<tr><td><code id="registry_file_parse_+3A_value">value</code></td>
<td>
<p>Value of a corpus property (<code>character</code> vector).</p>
</td></tr>
<tr><td><code id="registry_file_parse_+3A_info_file">info_file</code></td>
<td>
<p>Path to the info file providing information on the corpus.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>registry_file_parse()</code> will return an object of class <code>registry_data</code>.
</p>
<p>See the appendix to the 'Corpus Encoding Tutorial'
(https://cwb.sourceforge.io/files/CWB_Encoding_Tutorial.pdf), which includes an
explanation of the registry file format.
</p>
<p><code>registry_file_compose</code> will turn an
<code>registry_data</code>-object into a character vector with a registry file
that can be written to disk.
</p>
<p><code>registry_file_write()</code> will compose a registry file from
<code>data</code> and write it to disk.
</p>
<p><code>registry_set_property()</code> will set a single corpus property.
</p>
<p><code>registry_set_info()</code> will set the path to the info file.
</p>
<p><code>registry_set_name()</code> sets the long descriptive name of the corpus.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>regdata &lt;- registry_file_parse(
  corpus = "REUTERS",
  registry_dir = system.file(package = "RcppCWB", "extdata", "cwb", "registry")
  )
</code></pre>

<hr>
<h2 id='s_attribute_encode'>Read, process and write data on structural attributes.</h2><span id='topic+s_attribute_encode'></span><span id='topic+s_attribute_recode'></span><span id='topic+s_attribute_files'></span><span id='topic+s_attribute_get_values'></span><span id='topic+s_attribute_get_regions'></span><span id='topic+s_attribute_merge'></span><span id='topic+s_attribute_delete'></span><span id='topic+s_attribute_rename'></span>

<h3>Description</h3>

<p>Read, process and write data on structural attributes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>s_attribute_encode(
  values,
  data_dir,
  s_attribute,
  corpus,
  region_matrix,
  method = c("R", "CWB"),
  registry_dir = Sys.getenv("CORPUS_REGISTRY"),
  encoding,
  delete = FALSE,
  verbose = TRUE
)

s_attribute_recode(
  data_dir,
  s_attribute,
  from = c("UTF-8", "latin1"),
  to = c("UTF-8", "latin1")
)

s_attribute_files(s_attribute, data_dir)

s_attribute_get_values(s_attribute, data_dir)

s_attribute_get_regions(s_attribute, data_dir)

s_attribute_merge(x, y)

s_attribute_delete(corpus, s_attribute)

s_attribute_rename(corpus, old, new, registry_dir, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="s_attribute_encode_+3A_values">values</code></td>
<td>
<p>A <code>character</code> vector with the values of the structural
attribute.</p>
</td></tr>
<tr><td><code id="s_attribute_encode_+3A_data_dir">data_dir</code></td>
<td>
<p>The data directory where to write the files.</p>
</td></tr>
<tr><td><code id="s_attribute_encode_+3A_s_attribute">s_attribute</code></td>
<td>
<p>Name of the structural attribute, an atomic <code>character</code>
vector containing only lowercase ASCII characters (a-z), digits (0-9), -,
and _: No non-ASCII or uppercase letters allowed.</p>
</td></tr>
<tr><td><code id="s_attribute_encode_+3A_corpus">corpus</code></td>
<td>
<p>A CWB corpus.</p>
</td></tr>
<tr><td><code id="s_attribute_encode_+3A_region_matrix">region_matrix</code></td>
<td>
<p>A two-column <code>matrix</code> with corpus positions.</p>
</td></tr>
<tr><td><code id="s_attribute_encode_+3A_method">method</code></td>
<td>
<p>Either 'R' or 'CWB'.</p>
</td></tr>
<tr><td><code id="s_attribute_encode_+3A_registry_dir">registry_dir</code></td>
<td>
<p>Path name of the registry directory.</p>
</td></tr>
<tr><td><code id="s_attribute_encode_+3A_encoding">encoding</code></td>
<td>
<p>Encoding of the data.</p>
</td></tr>
<tr><td><code id="s_attribute_encode_+3A_delete">delete</code></td>
<td>
<p>Logical, whether to call <code>RcppCWB::cl_delete_corpus()</code>.</p>
</td></tr>
<tr><td><code id="s_attribute_encode_+3A_verbose">verbose</code></td>
<td>
<p>Logical.</p>
</td></tr>
<tr><td><code id="s_attribute_encode_+3A_from">from</code></td>
<td>
<p>Character string describing the current encoding of the attribute.</p>
</td></tr>
<tr><td><code id="s_attribute_encode_+3A_to">to</code></td>
<td>
<p>Character string describing the target encoding of the attribute.</p>
</td></tr>
<tr><td><code id="s_attribute_encode_+3A_x">x</code></td>
<td>
<p>Data defining a first s-attribute, a <code>data.table</code> (or an object
coercible to a <code>data.table</code>) with three columns (&quot;cpos_left&quot;,
&quot;cpos_right&quot;, &quot;value&quot;).</p>
</td></tr>
<tr><td><code id="s_attribute_encode_+3A_y">y</code></td>
<td>
<p>Data defining a second s-attribute, a <code>data.table</code> (or an
object coercible to a <code>data.table</code>) with three columns (&quot;cpos_left&quot;,
&quot;cpos_right&quot;, &quot;value&quot;).</p>
</td></tr>
<tr><td><code id="s_attribute_encode_+3A_old">old</code></td>
<td>
<p>A <code>character</code> vector with s-attributes to be renamed.</p>
</td></tr>
<tr><td><code id="s_attribute_encode_+3A_new">new</code></td>
<td>
<p>A <code>character</code> vector with new names of s-attributes. The vector
needs to have the same length as vector <code>old</code>. The 1st, 2nd, 3rd ... nth
attribute stated in vector <code>old</code> will get the new names at the 1st, 2nd,
3rd, ... nth position of vector <code>new</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>s_attribute_encode()</code> implements a 'pure R' implementation to add
or modify structural attributes of an existing CWB corpus.
</p>
<p>If the corpus has been loaded/used before, a new s-attribute may not be
available unless <code>RcppCWB::cl_delete_corpus()</code> has been called. Use the
argument <code>delete</code> for calling this function.
</p>
<p><code>s_attribute_recode</code> will recode the values in the avs-file and change
the attribute value index in the avx file. The rng-file remains unchanged. The registry
file remains unchanged, and it is highly recommended to consider <code>s_attribute_recode</code>
as a helper for <code>corpus_recode</code> that will recode all s-attributes, all p-attributes,
and will reset the encoding in the registry file.
</p>
<p><code>s_attribute_files()</code> will return a named character vector with
the data files (extensions: &quot;avs&quot;, &quot;avx&quot;, &quot;rng&quot;) in the directory indicated
by <code>data_dir</code> for the structural attribute <code>s_attribute</code>.
</p>
<p><code>s_attribute_get_values()</code> is equivalent to performing the CL
function cl_struc2id for all strucs of a structural attribute. It is a
&quot;pure R&quot; operation that is faster than using CL, as it processes entire
files for the s-attribute directly. The return value is a <code>character</code>
vector with all string values for the s-attribute.
</p>
<p><code>s_attribute_get_regions</code> will return a two-column integer
matrix with regions for the strucs of a given s-attribute. Left corpus
positions are in the first column, right corpus positions in the second
column. The result is equivalent to calling RcppCWB::get_region_matrix for
all strucs of a s-attribute, but may be somewhat faster. It is a &quot;pure R&quot;
function which is fast as it processes files entirely and directly.
</p>
<p><code>s_attribute_merge()</code> combines two tables with regions for
s-attributes checking for intersections that may cause problems. The
heuristic is to keep all non-intersecting annotations and those annotations
that define the same region in object <code>x</code> and object <code>y</code>.
Annotations of <code>x</code> and <code>y</code> which overlap uncleanly, i.e. without
an identity of the left and the right corpus position (&quot;cpos_left&quot; /
&quot;cpos_right&quot;) are dropped. The scenario for using the function is to decode
a s-attribute (using <code>s_attribute_decode()</code>), mix in an additional
annotation, and to re-encode the enhanced s-attribute (using
<code>s_attribute_encode()</code>).
</p>
<p>Function <code>s_attribute_delete()</code> is not yet implemented.
</p>
<p>Function <code>s_attribute_rename()</code> can be used to rename a structural
attribute.
</p>


<h3>See Also</h3>

<p>To decode a structural attribute, see
<code><a href="RcppCWB.html#topic+s_attribute_decode">s_attribute_decode</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require("RcppCWB")
registry_tmp &lt;- fs::path(tempdir(), "cwb", "registry")
data_dir_tmp &lt;- fs::path(tempdir(), "cwb", "indexed_corpora", "reuters")

cwb_dir_rcppcwb &lt;- system.file(package = "RcppCWB", "extdata", "cwb")
registry_dir_rcppcwb &lt;- fs::path(cwb_dir_rcppcwb, "registry")
data_dir_rcppcwb &lt;- fs::path(cwb_dir_rcppcwb,"indexed_corpora", "reuters")

corpus_copy(
  corpus = "REUTERS",
  registry_dir = registry_dir_rcppcwb,
  data_dir = data_dir_rcppcwb,
  registry_dir_new = registry_tmp,
  data_dir_new = data_dir_tmp
)

no_strucs &lt;- cl_attribute_size(
  corpus = "REUTERS",
  attribute = "id",
  attribute_type = "s",
  registry = registry_tmp
)

cpos_matrix &lt;- get_region_matrix(
      corpus = "REUTERS",
      struc = 0L:(no_strucs - 1L),
      s_attribute = "id",
      registry = registry_tmp
)

s_attribute_encode(
  values = 1L:nrow(cpos_matrix),
  data_dir = data_dir_tmp,
  s_attribute = "article_id",
  corpus = "REUTERS",
  region_matrix = cpos_matrix,
  method = "R",
  registry_dir = registry_tmp,
  encoding = "latin1",
  verbose = TRUE,
  delete = TRUE
)

cl_struc2str(
  "REUTERS",
  struc = 0L:(nrow(cpos_matrix) - 1L),
  s_attribute = "article_id",
  registry = registry_tmp
)

unlink(registry_tmp, recursive = TRUE)
unlink(data_dir_tmp, recursive = TRUE)
data_dir &lt;- system.file(
  package = "RcppCWB",
  "extdata",
  "cwb",
  "indexed_corpora",
  "reuters"
)
avs &lt;- s_attribute_get_values(s_attribute = "id", data_dir = data_dir)
rng &lt;- s_attribute_get_regions(
  s_attribute = "id",
  data_dir = system.file(package = "RcppCWB", "extdata", "cwb", "indexed_corpora", "reuters")
)
x &lt;- data.frame(
  cpos_left =  c(1L, 5L, 10L, 20L, 25L),
  cpos_right = c(2L, 5L, 12L, 21L, 27L),
  value = c("ORG", "LOC", "ORG", "PERS", "ORG"),
  stringsAsFactors = FALSE
)
y &lt;- data.frame(
  cpos_left =  c(5, 11, 20, 25L, 30L),
  cpos_right = c(5, 12, 22, 27L, 33L),
  value = c("LOC", "ORG", "ORG", "ORG", "ORG"),
  stringsAsFactors = FALSE
)
s_attribute_merge(x,y)
</code></pre>

<hr>
<h2 id='zenodo_get_tarball'>Download corpus tarball from Zenodo</h2><span id='topic+zenodo_get_tarball'></span><span id='topic+gparlsample_url_restricted'></span>

<h3>Description</h3>

<p>Download corpus tarball from Zenodo. Downloading both freely available data
and data with restricted access is supported.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>zenodo_get_tarball(
  url,
  destfile = tempfile(fileext = ".tar.gz"),
  checksum = TRUE,
  verbose = TRUE,
  progress = TRUE
)

gparlsample_url_restricted
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="zenodo_get_tarball_+3A_url">url</code></td>
<td>
<p>Landing page at Zenodo for resource. Can also be the URL for
restricted access (?token= appended with a long key), or a DOI referencing
objects deposited with Zenodo.</p>
</td></tr>
<tr><td><code id="zenodo_get_tarball_+3A_destfile">destfile</code></td>
<td>
<p>A <code>character</code> vector with the file path where the downloaded
file is to be saved. Tilde-expansion is performed. Defaults to a temporary
file.</p>
</td></tr>
<tr><td><code id="zenodo_get_tarball_+3A_checksum">checksum</code></td>
<td>
<p>A <code>logical</code> value, whether to check md5 sum.</p>
</td></tr>
<tr><td><code id="zenodo_get_tarball_+3A_verbose">verbose</code></td>
<td>
<p>A <code>logical</code> value, whether to output progess messages.</p>
</td></tr>
<tr><td><code id="zenodo_get_tarball_+3A_progress">progress</code></td>
<td>
<p>A <code>logical</code> value, whether to report progress during
download.</p>
</td></tr>
</table>


<h3>Format</h3>

<p>An object of class <code>character</code> of length 1.
</p>


<h3>Details</h3>

<p>A sample subset of the GermaParl corpus is deposited at Zenodo for
testing purposes. There are identical open access and restricted versions
of GermaParlSample to test different flavours of downloading a resource
from Zenodo. The URL for restricted access includes an access token which
is very lengthy. This URL is included as a dataset in the package to avoid
excessive line in sample code. Note that URLs that give access to
restricted data are usually not to be shared.
</p>


<h3>Value</h3>

<p>The filename of the downloaded corpus tarball, designed to serve as
input for <code><a href="#topic+corpus_install">corpus_install</a></code> (as argument <code>tarball</code>). If the
resource is not available, <code>NULL</code> is returned.
</p>
<p>The path of the downloaded resource, or <code>NULL</code> if the operation has
not been successful.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Temporary directory structure as a preparatory step
Sys.setenv(CORPUS_REGISTRY = "")
cwb_dirs &lt;- create_cwb_directories(
  prefix = tempdir(),
  ask = FALSE,
  verbose = FALSE
)
Sys.setenv(CORPUS_REGISTRY = cwb_dirs[["registry_dir"]])

# Download and install open access resource
gparl_url_pub &lt;- "https://doi.org/10.5281/zenodo.3823245"
tarball_tmp &lt;- zenodo_get_tarball(url = gparl_url_pub)
if (!is.null(tarball_tmp)) corpus_install(tarball = tarball_tmp)

# Download and install resource with restricted access
tarball_tmp &lt;- zenodo_get_tarball(url = gparlsample_url_restricted)
if (!is.null(tarball_tmp)) corpus_install(tarball = tarball_tmp)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
