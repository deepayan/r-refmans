<!DOCTYPE html><html><head><title>Help for package hhsmm</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {hhsmm}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#additive_reg_mstep'><p>the M step function of the EM algorithm</p></a></li>
<li><a href='#addreg_hhsmm_predict'><p>predicting the response values for the regime switching model</p></a></li>
<li><a href='#cov.miss.mix.wt'><p>weighted covariance for data with missing values</p></a></li>
<li><a href='#cov.mix.wt'><p>weighted covariance</p></a></li>
<li><a href='#dmixlm'><p>pdf of the mixture of Gaussian linear (Markov-switching) models for hhsmm</p></a></li>
<li><a href='#dmixmvnorm'><p>pdf of the mixture of multivariate normals for hhsmm</p></a></li>
<li><a href='#dmultinomial.hhsmm'><p>pdf of the multinomial emission distribution for hhsmm</p></a></li>
<li><a href='#dnonpar'><p>pdf of the mixture of B-splines for hhsmm</p></a></li>
<li><a href='#dnorm_additive_reg'><p>pdf of the Gaussian additive (Markov-switching) model for hhsmm</p></a></li>
<li><a href='#hhsmmdata'><p>convert to hhsmm data</p></a></li>
<li><a href='#hhsmmfit'><p>hhsmm model fit</p></a></li>
<li><a href='#hhsmmspec'><p>hhsmm specification</p></a></li>
<li><a href='#homogeneity'><p>Computing maximum homogeneity of two state sequences</p></a></li>
<li><a href='#initial_cluster'><p>initial clustering of the data set</p></a></li>
<li><a href='#initial_estimate'><p>initial estimation of the model parameters for a specified emission distribution</p></a></li>
<li><a href='#initialize_model'><p>initialize the hhsmmspec model for a specified emission distribution</p></a></li>
<li><a href='#lagdata'><p>Create hhsmm data of lagged time series</p></a></li>
<li><a href='#ltr_clus'><p>left to right clustering</p></a></li>
<li><a href='#ltr_reg_clus'><p>left to right linear regression clustering</p></a></li>
<li><a href='#make_model'><p>make a hhsmmspec model for a specified emission distribution</p></a></li>
<li><a href='#miss_mixmvnorm_mstep'><p>the M step function of the EM algorithm</p></a></li>
<li><a href='#mixdiagmvnorm_mstep'><p>the M step function of the EM algorithm</p></a></li>
<li><a href='#mixlm_mstep'><p>the M step function of the EM algorithm</p></a></li>
<li><a href='#mixmvnorm_mstep'><p>the M step function of the EM algorithm</p></a></li>
<li><a href='#mstep.multinomial'><p>the M step function of the EM algorithm</p></a></li>
<li><a href='#nonpar_mstep'><p>the M step function of the EM algorithm</p></a></li>
<li><a href='#predict.hhsmm'><p>prediction of state sequence for hhsmm</p></a></li>
<li><a href='#predict.hhsmmspec'><p>prediction of state sequence for hhsmm</p></a></li>
<li><a href='#raddreg'><p>Random data generation from the Gaussian additive (Markov-switching) model for hhsmm model</p></a></li>
<li><a href='#rmixar'><p>Random data generation from the mixture of Gaussian linear (Markov-switching) autoregressive models for hhsmm model</p></a></li>
<li><a href='#rmixlm'><p>Random data generation from the mixture of Gaussian linear (Markov-switching) models for hhsmm model</p></a></li>
<li><a href='#rmixmvnorm'><p>Random data generation from the mixture of multivariate normals for hhsmm model</p></a></li>
<li><a href='#rmultinomial.hhsmm'><p>Random data generation from the multinomial emission distribution for hhsmm model</p></a></li>
<li><a href='#score'><p>the score of new observations</p></a></li>
<li><a href='#simulate.hhsmmspec'><p>Simulation of data from hhsmm model</p></a></li>
<li><a href='#train_test_split'><p>Splitting the data sets to train and test</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Date:</td>
<td>2023-08-08</td>
</tr>
<tr>
<td>Title:</td>
<td>Hidden Hybrid Markov/Semi-Markov Model Fitting</td>
</tr>
<tr>
<td>Version:</td>
<td>0.3.6</td>
</tr>
<tr>
<td>Description:</td>
<td>Develops algorithms for fitting, prediction, simulation 
  and initialization of the hidden hybrid Markov/semi-Markov model, 
  introduced by Guedon (2005) &lt;<a href="https://doi.org/10.1016%2Fj.csda.2004.05.033">doi:10.1016/j.csda.2004.05.033</a>&gt;, 
  which also includes several tools for handling missing data, 
  nonparametric mixture of B-splines emissions (Langrock et al., 2015
  &lt;<a href="https://doi.org/10.1111%2Fbiom.12282">doi:10.1111/biom.12282</a>&gt;), fitting regime switching regression 
  (Kim et al., 2008 &lt;<a href="https://doi.org/10.1016%2Fj.jeconom.2007.10.002">doi:10.1016/j.jeconom.2007.10.002</a>&gt;) and auto-regressive 
  hidden hybrid Markov/semi-Markov model, spline-based nonparametric 
  estimation of additive state-switching models  
  (Langrock et al., 2018 &lt;<a href="https://doi.org/10.1111%2Fstan.12133">doi:10.1111/stan.12133</a>&gt;)
  and many other useful tools 
  (read for more description: Amini et al., 2022 &lt;<a href="https://doi.org/10.1007%2Fs00180-022-01248-x">doi:10.1007/s00180-022-01248-x</a>&gt; and its 
  arxiv version: &lt;<a href="https://doi.org/10.48550/arXiv.2109.12489">doi:10.48550/arXiv.2109.12489</a>&gt;). </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp, Rdpack, MASS, mice, progress, magic, splines2</td>
</tr>
<tr>
<td>RdMacros:</td>
<td>Rdpack</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.1.0), CMAPSS, mvtnorm</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/mortamini/hhsmm/issues">https://github.com/mortamini/hhsmm/issues</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.1</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-08-08 03:42:19 UTC; LENOVO.PIESC</td>
</tr>
<tr>
<td>Author:</td>
<td>Morteza Amini [aut, cre, cph],
  Afarin Bayat [aut],
  Reza Salehian [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Morteza Amini &lt;morteza.amini@ut.ac.ir&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-08-08 08:10:08 UTC</td>
</tr>
</table>
<hr>
<h2 id='additive_reg_mstep'>the M step function of the EM algorithm</h2><span id='topic+additive_reg_mstep'></span>

<h3>Description</h3>

<p>The M step function of the EM algorithm for the Gaussian linear (Markov-switching) regression
as the emission distribution using the
responses and covariates matrices and the estimated weight vectors
</p>


<h3>Usage</h3>

<pre><code class='language-R'>additive_reg_mstep(x, wt, control = list(K = 5, lambda0 = 0.01, resp.ind = 1))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="additive_reg_mstep_+3A_x">x</code></td>
<td>
<p>the observation matrix</p>
</td></tr>
<tr><td><code id="additive_reg_mstep_+3A_wt">wt</code></td>
<td>
<p>the state probabilities matrix (number of observations
times number of states)</p>
</td></tr>
<tr><td><code id="additive_reg_mstep_+3A_control">control</code></td>
<td>
<p>the parameters to control the M-step function.
The simillar name is chosen with that of <code><a href="#topic+dnorm_additive_reg">dnorm_additive_reg</a></code>,
to be used in <code>...</code> argument of the <code><a href="#topic+hhsmmfit">hhsmmfit</a></code> function.
Here, it contains the following items:
</p>

<ul>
<li> <p><code>K</code> the degrees of freedom for the B-spline, default is <code>K=5</code>
</p>
</li>
<li> <p><code>lambda0</code> the initial value of the smoothing parameter, default is <code>lambda0=0.01</code>
</p>
</li>
<li> <p><code>resp.ind</code> a vector of the column numbers of <code>x</code> which contain response variables. 
The default is 1, which means that the first column of <code>x</code> is the univariate 
response variable
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>list of emission (nonparametric mixture of splines) parameters:
</p>


<h3>Author(s)</h3>

<p>Morteza Amini, <a href="mailto:morteza.amini@ut.ac.ir">morteza.amini@ut.ac.ir</a>,
Reza Salehian,  <a href="mailto:reza.salehian@ut.ac.ir">reza.salehian@ut.ac.ir</a>
</p>


<h3>References</h3>

<p>Langrock, R., Adam, T., Leos-Barajas, V.,
Mews, S., Miller, D. L., and Papastamatiou, Y. P. (2018).
Spline-based nonparametric inference in general state-switching models.
Statistica Neerlandica, 72(3), 179-200.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>J &lt;- 3
initial &lt;- c(1, 0, 0)
semi &lt;- rep(FALSE, 3)
P &lt;- matrix(c(0.5, 0.2, 0.3, 0.2, 0.5, 0.3, 0.1, 0.4, 0.5), nrow = J, 
byrow = TRUE)
par &lt;- list(intercept = list(3, list(-10, -1), 14),
coefficient = list(-1, list(1, 5), -7),
csigma = list(1.2, list(2.3, 3.4), 1.1),
mix.p = list(1, c(0.4, 0.6), 1))
model &lt;- hhsmmspec(init = initial, transition = P, parms.emis = par,
dens.emis = dmixlm, semi = semi)
train &lt;- simulate(model, nsim = c(20, 30, 42, 50), seed = 1234, 
remission = rmixlm, covar = list(mean = 0, cov = 1))
clus = initial_cluster(train = train, nstate = 3, nmix = NULL,
ltr = FALSE, final.absorb = FALSE, verbose = TRUE, regress = TRUE)
initmodel = initialize_model(clus = clus ,mstep = additive_reg_mstep,
dens.emission = dnorm_additive_reg, sojourn = NULL, semi = rep(FALSE, 3),
M = max(train$N),verbose = TRUE)
fit1 = hhsmmfit(x = train, model = initmodel, mstep = additive_reg_mstep,
M = max(train$N))
plot(train$x[, 1] ~ train$x[, 2], col = train$s, pch = fit1$yhat, 
xlab = "x", ylab = "y")
text(0,30, "colors are real states",col="red")
text(0,28, "characters are predicted states")
pred &lt;- addreg_hhsmm_predict(fit1, train$x[, 2], 5)
yhat1 &lt;- pred[[1]]
yhat2 &lt;- pred[[2]]
yhat3 &lt;- pred[[3]]

lines(yhat1[order(train$x[, 2])]~sort(train$x[, 2]),col = 2)
lines(yhat2[order(train$x[, 2])]~sort(train$x[, 2]),col = 1)
lines(yhat3[order(train$x[, 2])]~sort(train$x[, 2]),col = 3)

</code></pre>

<hr>
<h2 id='addreg_hhsmm_predict'>predicting the response values for the regime switching model</h2><span id='topic+addreg_hhsmm_predict'></span>

<h3>Description</h3>

<p>This function computes the predictions of the response variable for the Gaussian linear (Markov-switching) regression
model for different states for any observation matrix of the covariates
</p>


<h3>Usage</h3>

<pre><code class='language-R'>addreg_hhsmm_predict(object, x, K)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="addreg_hhsmm_predict_+3A_object">object</code></td>
<td>
<p>a fitted model of class <code>"hhsmm"</code> estimated by <code>hhsmmfit</code></p>
</td></tr>
<tr><td><code id="addreg_hhsmm_predict_+3A_x">x</code></td>
<td>
<p>the observation matrix of the covariates</p>
</td></tr>
<tr><td><code id="addreg_hhsmm_predict_+3A_k">K</code></td>
<td>
<p>the degrees of freedom for the B-spline</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of predictions of the response variable
</p>


<h3>Author(s)</h3>

<p>Morteza Amini, <a href="mailto:morteza.amini@ut.ac.ir">morteza.amini@ut.ac.ir</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>J &lt;- 3
initial &lt;- c(1, 0, 0)
semi &lt;- rep(FALSE, 3)
P &lt;- matrix(c(0.5, 0.2, 0.3, 0.2, 0.5, 0.3, 0.1, 0.4, 0.5), nrow = J, 
byrow = TRUE)
par &lt;- list(intercept = list(3, list(-10, -1), 14),
coefficient = list(-1, list(1, 5), -7),
csigma = list(1.2, list(2.3, 3.4), 1.1),
mix.p = list(1, c(0.4, 0.6), 1))
model &lt;- hhsmmspec(init = initial, transition = P, parms.emis = par,
dens.emis = dmixlm, semi = semi)
train &lt;- simulate(model, nsim = c(20, 30, 42, 50), seed = 1234, 
remission = rmixlm, covar = list(mean = 0, cov = 1))
clus = initial_cluster(train = train, nstate = 3, nmix = NULL,
ltr = FALSE, final.absorb = FALSE, verbose = TRUE, regress = TRUE)
initmodel = initialize_model(clus = clus ,mstep = additive_reg_mstep,
dens.emission = dnorm_additive_reg, sojourn = NULL, semi = rep(FALSE, 3),
M = max(train$N),verbose = TRUE)
fit1 = hhsmmfit(x = train, model = initmodel, mstep = additive_reg_mstep,
M = max(train$N))
plot(train$x[, 1] ~ train$x[, 2], col = train$s, pch = fit1$yhat, 
xlab = "x", ylab = "y")
text(0,30, "colors are real states",col="red")
text(0,28, "characters are predicted states")
pred &lt;- addreg_hhsmm_predict(fit1, train$x[, 2], 5)
yhat1 &lt;- pred[[1]]
yhat2 &lt;- pred[[2]]
yhat3 &lt;- pred[[3]]

lines(yhat1[order(train$x[, 2])]~sort(train$x[, 2]),col = 2)
lines(yhat2[order(train$x[, 2])]~sort(train$x[, 2]),col = 1)
lines(yhat3[order(train$x[, 2])]~sort(train$x[, 2]),col = 3)

</code></pre>

<hr>
<h2 id='cov.miss.mix.wt'>weighted covariance for data with missing values</h2><span id='topic+cov.miss.mix.wt'></span>

<h3>Description</h3>

<p>The weighted means and variances using the
observation matrix and the estimated weight
vectors for a data matrix containing missing values (NA or NaN)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cov.miss.mix.wt(
  x,
  means,
  secm,
  wt1 = rep(1/nrow(x), nrow(x)),
  wt2 = rep(1/nrow(x), nrow(x)),
  cor = FALSE,
  center = TRUE,
  method = c("unbiased", "ML")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cov.miss.mix.wt_+3A_x">x</code></td>
<td>
<p>the observation matrix, which can contain missing values (NA or NaN)</p>
</td></tr>
<tr><td><code id="cov.miss.mix.wt_+3A_means">means</code></td>
<td>
<p>a list containing the means of the missing values given observed values</p>
</td></tr>
<tr><td><code id="cov.miss.mix.wt_+3A_secm">secm</code></td>
<td>
<p>a list containing the second moments of the missing values given observed values</p>
</td></tr>
<tr><td><code id="cov.miss.mix.wt_+3A_wt1">wt1</code></td>
<td>
<p>the state probabilities matrix (number of observations
times number of states)</p>
</td></tr>
<tr><td><code id="cov.miss.mix.wt_+3A_wt2">wt2</code></td>
<td>
<p>the mixture components probabilities list (of length
nstate) of matrices (number of observations times number of
mixture components)</p>
</td></tr>
<tr><td><code id="cov.miss.mix.wt_+3A_cor">cor</code></td>
<td>
<p>logical. if TRUE the weighted correlation is also given</p>
</td></tr>
<tr><td><code id="cov.miss.mix.wt_+3A_center">center</code></td>
<td>
<p>logical. if TRUE the weighted mean is also given</p>
</td></tr>
<tr><td><code id="cov.miss.mix.wt_+3A_method">method</code></td>
<td>
<p>with two possible entries:
</p>

<ul>
<li> <p><code>"unbiased"</code> the unbiased estimator is given
</p>
</li>
<li> <p><code>"ML"</code> the maximum likelihood estimator is given
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>list containing the following items:
</p>

<ul>
<li> <p><code>center</code> the weighted mean of <code>x</code>
</p>
</li>
<li> <p><code>cov</code> the weighted covariance of <code>x</code>
</p>
</li>
<li> <p><code>n.obs</code> the number of observations in <code>x</code>
</p>
</li>
<li> <p><code>cor</code> the weighted correlation of <code>x</code>, 
if the parameter <code>cor</code> is TRUE
</p>
</li>
<li> <p><code>wt1</code> the state weighs <code>wt1</code>
</p>
</li>
<li> <p><code>wt2</code> the mixture component weights <code>wt2</code>
</p>
</li>
<li> <p><code>pmix</code> the estimated mixture proportions
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Morteza Amini, <a href="mailto:morteza.amini@ut.ac.ir">morteza.amini@ut.ac.ir</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(CMAPSS)
x0 = CMAPSS$train$x[1:CMAPSS$train$N[1], ]
n = nrow(x0)
wt1 = runif(n)
wt2 = runif(n)
p = ncol(x0)
sammissall = sample(1:n, trunc(n / 20))
means = secm = list()
for(ii in 1:n){ 
	if(ii %in% sammissall){
   means[[ii]] = colMeans(x0[sammissall, ])
   secm[[ii]] = t(x0[sammissall, ]) %*% x0[sammissall, ]
 }else{
  means[[ii]] = secm[[ii]] = NA
 }
}
x0[sammissall,] = NA

cov.miss.mix.wt(x0, means, secm, wt1, wt2)

</code></pre>

<hr>
<h2 id='cov.mix.wt'>weighted covariance</h2><span id='topic+cov.mix.wt'></span>

<h3>Description</h3>

<p>The weighted means and variances using the
observation matrix and the estimated weight vectors
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cov.mix.wt(
  x,
  wt1 = rep(1/nrow(x), nrow(x)),
  wt2 = rep(1/nrow(x), nrow(x)),
  cor = FALSE,
  center = TRUE,
  method = c("unbiased", "ML")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cov.mix.wt_+3A_x">x</code></td>
<td>
<p>the observation matrix</p>
</td></tr>
<tr><td><code id="cov.mix.wt_+3A_wt1">wt1</code></td>
<td>
<p>the state probabilities matrix (number of observations
times number of states)</p>
</td></tr>
<tr><td><code id="cov.mix.wt_+3A_wt2">wt2</code></td>
<td>
<p>the mixture components probabilities list (of length
nstate) of matrices (number of observations times number of
mixture components)</p>
</td></tr>
<tr><td><code id="cov.mix.wt_+3A_cor">cor</code></td>
<td>
<p>logical. if TRUE the weighted correlation is also given</p>
</td></tr>
<tr><td><code id="cov.mix.wt_+3A_center">center</code></td>
<td>
<p>logical. if TRUE the weighted mean is also given</p>
</td></tr>
<tr><td><code id="cov.mix.wt_+3A_method">method</code></td>
<td>
<p>with two possible entries:
</p>

<ul>
<li> <p><code>"unbiased"</code> the unbiased estimator is given
</p>
</li>
<li> <p><code>"ML"</code> the maximum likelihood estimator is given
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>list containing the following items:
</p>

<ul>
<li> <p><code>center</code> the weighted mean of <code>x</code>
</p>
</li>
<li> <p><code>cov</code> the weighted covariance of <code>x</code>
</p>
</li>
<li> <p><code>n.obs</code> the number of observations in <code>x</code>
</p>
</li>
<li> <p><code>cor</code> the weighted correlation of <code>x</code>, 
if the parameter <code>cor</code> is TRUE
</p>
</li>
<li> <p><code>wt1</code> the state weighs <code>wt1</code>
</p>
</li>
<li> <p><code>wt2</code> the mixture component weights <code>wt2</code>
</p>
</li>
<li> <p><code>pmix</code> the estimated mixture proportions
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Morteza Amini, <a href="mailto:morteza.amini@ut.ac.ir">morteza.amini@ut.ac.ir</a>, Afarin Bayat, <a href="mailto:aftbayat@gmail.com">aftbayat@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(CMAPSS)
n = nrow(CMAPSS$train$x)
wt1 = runif(n)
wt2 = runif(n)
cov.mix.wt(CMAPSS$train$x, wt1, wt2)

</code></pre>

<hr>
<h2 id='dmixlm'>pdf of the mixture of Gaussian linear (Markov-switching) models for hhsmm</h2><span id='topic+dmixlm'></span>

<h3>Description</h3>

<p>The probability density function of a mixture Gaussian linear (Markov-switching) models
for a specified observation vector, a specified state and a specified
model's parameters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dmixlm(x, j, model, resp.ind = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dmixlm_+3A_x">x</code></td>
<td>
<p>the observation matrix including responses and covariates</p>
</td></tr>
<tr><td><code id="dmixlm_+3A_j">j</code></td>
<td>
<p>a specified state between 1 to nstate</p>
</td></tr>
<tr><td><code id="dmixlm_+3A_model">model</code></td>
<td>
<p>a hhsmmspec model</p>
</td></tr>
<tr><td><code id="dmixlm_+3A_resp.ind">resp.ind</code></td>
<td>
<p>a vector of the column numbers of <code>x</code> which contain response variables.
The default is 1, which means that the first column of <code>x</code> is the univariate
response variable</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the probability density function value
</p>


<h3>Author(s)</h3>

<p>Morteza Amini, <a href="mailto:morteza.amini@ut.ac.ir">morteza.amini@ut.ac.ir</a>
</p>


<h3>References</h3>

<p>Kim, C. J., Piger, J. and Startz, R. (2008). Estimation of Markov
regime-switching regression models with endogenous switching.
Journal of Econometrics, 143(2), 263-273.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>J &lt;- 3
initial &lt;- c(1, 0, 0)
semi &lt;- rep(FALSE, 3)
P &lt;- matrix(c(0.5, 0.2, 0.3, 0.2, 0.5, 0.3, 0.1, 0.4, 0.5), 
nrow = J, byrow = TRUE)
par &lt;- list(intercept = list(3, list(-10, -1), 14),
coefficient = list(-1, list(1, 5), -7),
csigma = list(1.2, list(2.3, 3.4), 1.1),
mix.p = list(1, c(0.4, 0.6), 1))
model &lt;- hhsmmspec(init = initial, transition = P, parms.emis = par,
dens.emis = dmixlm, semi = semi)
train &lt;- simulate(model, nsim = c(20, 30, 42, 50), seed = 1234, 
remission = rmixlm, covar = list(mean = 0, cov = 1))
clus = initial_cluster(train = train, nstate = 3, nmix = c(1, 2, 1), 
ltr = FALSE, final.absorb = FALSE, verbose = TRUE, regress = TRUE)
initmodel = initialize_model(clus = clus, mstep = mixlm_mstep,
dens.emission = dmixlm, sojourn = NULL, semi = rep(FALSE, 3), 
M = max(train$N),verbose = TRUE)
fit1 = hhsmmfit(x = train, model = initmodel, mstep = mixlm_mstep,
M = max(train$N))
plot(train$x[,1] ~ train$x[, 2], col = train$s, pch = 16, 
xlab = "x", ylab = "y")
abline(fit1$model$parms.emission$intercept[[1]],
fit1$model$parms.emission$coefficient[[1]], col = 1)
abline(fit1$model$parms.emission$intercept[[2]][[1]],
fit1$model$parms.emission$coefficient[[2]][[1]], col = 2)
abline(fit1$model$parms.emission$intercept[[2]][[2]],
fit1$model$parms.emission$coefficient[[2]][[2]], col = 2)
abline(fit1$model$parms.emission$intercept[[3]],
fit1$model$parms.emission$coefficient[[3]], col = 3)

</code></pre>

<hr>
<h2 id='dmixmvnorm'>pdf of the mixture of multivariate normals for hhsmm</h2><span id='topic+dmixmvnorm'></span>

<h3>Description</h3>

<p>The probability density function of a mixture multivariate normal
for a specified observation vector, a specified state and a specified
model's parameters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dmixmvnorm(x, j, model)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dmixmvnorm_+3A_x">x</code></td>
<td>
<p>an observation vector or matrix</p>
</td></tr>
<tr><td><code id="dmixmvnorm_+3A_j">j</code></td>
<td>
<p>a specified state between 1 to nstate</p>
</td></tr>
<tr><td><code id="dmixmvnorm_+3A_model">model</code></td>
<td>
<p>a hhsmmspec model</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the probability density function value
</p>


<h3>Author(s)</h3>

<p>Morteza Amini, <a href="mailto:morteza.amini@ut.ac.ir">morteza.amini@ut.ac.ir</a>, Afarin Bayat, <a href="mailto:aftbayat@gmail.com">aftbayat@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>J &lt;- 3
initial &lt;- c(1, 0, 0)
semi &lt;- c(FALSE, TRUE, FALSE)
P &lt;- matrix(c(0.8, 0.1, 0.1, 0.5, 0, 0.5, 0.1, 0.2, 0.7), 
nrow = J, byrow = TRUE)
par &lt;- list(mu = list(list(7, 8),list(10, 9, 11), list(12, 14)),
sigma = list(list(3.8, 4.9), list(4.3, 4.2, 5.4), list(4.5, 6.1)),
mix.p = list(c(0.3, 0.7), c(0.2, 0.3, 0.5), c(0.5, 0.5)))
sojourn &lt;- list(shape = c(0, 3, 0), scale = c(0, 10, 0), type = "gamma")
model &lt;- hhsmmspec(init = initial, transition = P, parms.emis = par,
dens.emis = dmixmvnorm, sojourn = sojourn, semi = semi)
train &lt;- simulate(model, nsim = c(10, 8, 8, 18), seed = 1234, 
remission = rmixmvnorm)
p = dmixmvnorm(train$x, 1, model)

</code></pre>

<hr>
<h2 id='dmultinomial.hhsmm'>pdf of the multinomial emission distribution for hhsmm</h2><span id='topic+dmultinomial.hhsmm'></span>

<h3>Description</h3>

<p>The probability density function of a multinomial emission distribution
for a specified observation vector, a specified state and a specified
model's parameters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dmultinomial.hhsmm(x, j, model, n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dmultinomial.hhsmm_+3A_x">x</code></td>
<td>
<p>the observation vector</p>
</td></tr>
<tr><td><code id="dmultinomial.hhsmm_+3A_j">j</code></td>
<td>
<p>a specified state between 1 to nstate</p>
</td></tr>
<tr><td><code id="dmultinomial.hhsmm_+3A_model">model</code></td>
<td>
<p>a hhsmmspec model</p>
</td></tr>
<tr><td><code id="dmultinomial.hhsmm_+3A_n">n</code></td>
<td>
<p>the maximum possible level of the multinomial vector (i.e. from 1 to n)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the probability density function value
</p>


<h3>Author(s)</h3>

<p>Morteza Amini, <a href="mailto:morteza.amini@ut.ac.ir">morteza.amini@ut.ac.ir</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>J &lt;- 2
initial &lt;- c(1, 0)
semi &lt;- rep(TRUE, 2)
P &lt;- matrix(c(0, 1, 1, 0), 
nrow = J, byrow = TRUE)
par &lt;- list(prob = list(c(0.6,  0.2, 0.2),
                           c(0.2, 0.6,  0.2)))
sojourn &lt;- list(shape = c(1, 3), scale = c(2, 10), type = "gamma")
model &lt;- hhsmmspec(init = initial, transition = P, parms.emis = par,
dens.emis = dmultinomial.hhsmm, remission = rmultinomial.hhsmm,
 mstep = mstep.multinomial,sojourn = sojourn, semi = semi)
train &lt;- simulate(model, nsim = c(20, 30, 42, 50), seed = 1234, 
remission = rmultinomial.hhsmm)
clus = initial_cluster(train = train, nstate = 2, nmix = NULL,
ltr = FALSE, final.absorb = FALSE, verbose = TRUE)
initmodel = initialize_model(clus = clus, mstep = mstep.multinomial, n = 3,
dens.emission = dmultinomial.hhsmm, sojourn = "gamma", semi = rep(TRUE, 2), 
M = max(train$N),verbose = TRUE)
fit1 = hhsmmfit(x = train, model = initmodel, mstep = mstep.multinomial, n = 3, 
M = max(train$N))
homogeneity(fit1$yhat,train$s)

</code></pre>

<hr>
<h2 id='dnonpar'>pdf of the mixture of B-splines for hhsmm</h2><span id='topic+dnonpar'></span>

<h3>Description</h3>

<p>The probability density function of a mixture of B-splines
for a specified observation vector, a specified state and a specified
model's parameters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dnonpar(x, j, model, control = list(K = 5))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dnonpar_+3A_x">x</code></td>
<td>
<p>an observation vector or matrix</p>
</td></tr>
<tr><td><code id="dnonpar_+3A_j">j</code></td>
<td>
<p>a specified state between 1 to nstate</p>
</td></tr>
<tr><td><code id="dnonpar_+3A_model">model</code></td>
<td>
<p>a hhsmmspec model</p>
</td></tr>
<tr><td><code id="dnonpar_+3A_control">control</code></td>
<td>
<p>the parameters to control the density function.
The simillar name is chosen with that of <code><a href="#topic+nonpar_mstep">nonpar_mstep</a></code>,
to be used in <code>...</code> argument of the <code><a href="#topic+hhsmmfit">hhsmmfit</a></code> function.
Here, it contains only the parameter <code>K</code> which is the degrees of freedom for
the B-spline, default is <code>K=5</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>the probability density function value
</p>


<h3>Author(s)</h3>

<p>Morteza Amini, <a href="mailto:morteza.amini@ut.ac.ir">morteza.amini@ut.ac.ir</a>,
Reza Salehian,  <a href="mailto:reza.salehian@ut.ac.ir">reza.salehian@ut.ac.ir</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>J &lt;- 3
initial &lt;- c(1, 0, 0)
semi &lt;- c(FALSE, TRUE, FALSE)
P &lt;- matrix(c(0.8, 0.1, 0.1, 0.5, 0, 0.5, 0.1, 0.2, 0.7), 
nrow = J, byrow = TRUE)
par &lt;- list(mu = list(list(7, 8), list(10, 9, 11), list(12, 14)),
sigma = list(list(3.8, 4.9), list(4.3, 4.2, 5.4), list(4.5, 6.1)),
mix.p = list(c(0.3, 0.7), c(0.2, 0.3, 0.5), c(0.5, 0.5)))
sojourn &lt;- list(shape = c(0, 3, 0), scale = c(0, 10, 0), type = "gamma")
model &lt;- hhsmmspec(init = initial, transition = P, parms.emis = par,
dens.emis = dmixmvnorm, sojourn = sojourn, semi = semi)
train &lt;- simulate(model, nsim = c(10, 8, 8, 18), seed = 1234, 
remission = rmixmvnorm)
clus = initial_cluster(train, nstate = 3, nmix = NULL, ltr = FALSE,
final.absorb = FALSE, verbose = TRUE)
semi &lt;- c(FALSE, TRUE, FALSE)
initmodel = initialize_model(clus = clus, mstep = nonpar_mstep,
	sojourn = "gamma", M = max(train$N), semi = semi)
p = dnonpar(train$x, 1, initmodel)

</code></pre>

<hr>
<h2 id='dnorm_additive_reg'>pdf of the Gaussian additive (Markov-switching) model for hhsmm</h2><span id='topic+dnorm_additive_reg'></span>

<h3>Description</h3>

<p>The probability density function of a Gaussian additive (Markov-switching) model
for a specified observation vector, a specified state and a specified
model's parameters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dnorm_additive_reg(x, j, model, control = list(K = 5, resp.ind = 1))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dnorm_additive_reg_+3A_x">x</code></td>
<td>
<p>the observation matrix including responses and covariates</p>
</td></tr>
<tr><td><code id="dnorm_additive_reg_+3A_j">j</code></td>
<td>
<p>a specified state between 1 to nstate</p>
</td></tr>
<tr><td><code id="dnorm_additive_reg_+3A_model">model</code></td>
<td>
<p>a hhsmmspec model</p>
</td></tr>
<tr><td><code id="dnorm_additive_reg_+3A_control">control</code></td>
<td>
<p>the parameters to control the density function.
The simillar name is chosen with that of <code><a href="#topic+additive_reg_mstep">additive_reg_mstep</a></code>,
to be used in <code>...</code> argument of the <code><a href="#topic+hhsmmfit">hhsmmfit</a></code> function.
Here, it contains the following items:
</p>

<ul>
<li> <p><code>K</code> the degrees of freedom for the B-spline, default is <code>K=5</code>
</p>
</li>
<li> <p><code>resp.ind</code> a vector of the column numbers of <code>x</code> which contain response variables. 
The default is 1, which means that the first column of <code>x</code> is the univariate 
response variable
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>the probability density function value
</p>


<h3>Author(s)</h3>

<p>Morteza Amini, <a href="mailto:morteza.amini@ut.ac.ir">morteza.amini@ut.ac.ir</a>,
Reza Salehian,  <a href="mailto:reza.salehian@ut.ac.ir">reza.salehian@ut.ac.ir</a>
</p>


<h3>References</h3>

<p>Langrock, R., Adam, T., Leos-Barajas, V.,
Mews, S., Miller, D. L., and Papastamatiou, Y. P. (2018).
Spline-based nonparametric inference in general state-switching models.
Statistica Neerlandica, 72(3), 179-200.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>J &lt;- 3
initial &lt;- c(1, 0, 0)
semi &lt;- rep(FALSE, 3)
P &lt;- matrix(c(0.5, 0.2, 0.3, 0.2, 0.5, 0.3, 0.1, 0.4, 0.5), nrow = J, 
byrow = TRUE)
par &lt;- list(intercept = list(3, list(-10, -1), 14),
coefficient = list(-1, list(1, 5), -7),
csigma = list(1.2, list(2.3, 3.4), 1.1),
mix.p = list(1, c(0.4, 0.6), 1))
model &lt;- hhsmmspec(init = initial, transition = P, parms.emis = par,
dens.emis = dmixlm, semi = semi)
train &lt;- simulate(model, nsim = c(20, 30, 42, 50), seed = 1234, 
remission = rmixlm, covar = list(mean = 0, cov = 1))
clus = initial_cluster(train = train, nstate = 3, nmix = NULL,
ltr = FALSE, final.absorb = FALSE, verbose = TRUE, regress = TRUE)
initmodel = initialize_model(clus = clus ,mstep = additive_reg_mstep,
dens.emission = dnorm_additive_reg, sojourn = NULL, semi = rep(FALSE, 3),
M = max(train$N),verbose = TRUE)
fit1 = hhsmmfit(x = train, model = initmodel, mstep = additive_reg_mstep,
M = max(train$N))
plot(train$x[, 1] ~ train$x[, 2], col = train$s, pch = fit1$yhat, 
xlab = "x", ylab = "y")
text(0,30, "colors are real states",col="red")
text(0,28, "characters are predicted states")
pred &lt;- addreg_hhsmm_predict(fit1, train$x[, 2], 5)
yhat1 &lt;- pred[[1]]
yhat2 &lt;- pred[[2]]
yhat3 &lt;- pred[[3]]

lines(yhat1[order(train$x[, 2])]~sort(train$x[, 2]),col = 2)
lines(yhat2[order(train$x[, 2])]~sort(train$x[, 2]),col = 1)
lines(yhat3[order(train$x[, 2])]~sort(train$x[, 2]),col = 3)

</code></pre>

<hr>
<h2 id='hhsmmdata'>convert to hhsmm data</h2><span id='topic+hhsmmdata'></span>

<h3>Description</h3>

<p>Converts a matrix of data and its associated vector of sequence lengths
to a data list of class <code>"hhsmmdata"</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hhsmmdata(x, N = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hhsmmdata_+3A_x">x</code></td>
<td>
<p>a matrix of data</p>
</td></tr>
<tr><td><code id="hhsmmdata_+3A_n">N</code></td>
<td>
<p>a vector of sequence lengths. If NULL then <code>N = nrow(x)</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data list of class <code>"hhsmmdata"</code> containing <code>x</code> and <code>N</code>
</p>


<h3>Author(s)</h3>

<p>Morteza Amini, <a href="mailto:morteza.amini@ut.ac.ir">morteza.amini@ut.ac.ir</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x = sapply(c(1, 2), function(i) rnorm(100, i, i/2))
N = c(10, 15, 50, 25)
data = hhsmmdata(x, N)

</code></pre>

<hr>
<h2 id='hhsmmfit'>hhsmm model fit</h2><span id='topic+hhsmmfit'></span>

<h3>Description</h3>

<p>Fits a hidden hybrid Markov-semi-Markov model to a data of class <code>"hhsmmdata"</code> and using an initial
model created  by <code><a href="#topic+hhsmmspec">hhsmmspec</a></code> or <code><a href="#topic+initialize_model">initialize_model</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hhsmmfit(
  x,
  model,
  mstep = NULL,
  ...,
  M = NA,
  par = list(maxit = 100, lock.transition = FALSE, lock.d = FALSE, lock.init = FALSE,
    graphical = FALSE, verbose = TRUE)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hhsmmfit_+3A_x">x</code></td>
<td>
<p>a data of class <code>"hhsmmdata"</code>, which can also contain missing values (NA or NaN)</p>
</td></tr>
<tr><td><code id="hhsmmfit_+3A_model">model</code></td>
<td>
<p>an initial model created  by <code>hhsmm.spec</code> or <code>initialize_model</code></p>
</td></tr>
<tr><td><code id="hhsmmfit_+3A_mstep">mstep</code></td>
<td>
<p>the M step function for the EM algorithm, which also can be given in the model</p>
</td></tr>
<tr><td><code id="hhsmmfit_+3A_...">...</code></td>
<td>
<p>additional parameters for the dens.emission and mstep functions</p>
</td></tr>
<tr><td><code id="hhsmmfit_+3A_m">M</code></td>
<td>
<p>the maximum duration in each state</p>
</td></tr>
<tr><td><code id="hhsmmfit_+3A_par">par</code></td>
<td>
<p>additional list of control parameters of the <code>hhsmmfit</code> function
including the following items:
</p>

<ul>
<li> <p><code>maxit</code> the maximum number of iterations for the EM algorithm
</p>
</li>
<li> <p><code>lock.transition</code> logical. if TRUE the transition matrix will not be updated through the EM algorithm
</p>
</li>
<li> <p><code>lock.d</code> logical. if TRUE the sojourn probability matrix d will not be updated through the EM algorithm
</p>
</li>
<li> <p><code>lock.init</code> logical. if TRUE the initial probability vector will not be updated through the EM algorithm
</p>
</li>
<li> <p><code>graphical</code> logical. if TRUE a plot of the sojourn probabilities will be plotted through the EM algorithm
</p>
</li>
<li> <p><code>verbose</code> logical. if TRUE the outputs will be printed
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of class <code>"hhsmm"</code> containing the following items:
</p>

<ul>
<li> <p><code>loglike</code> the log-likelihood of the fitted model
</p>
</li>
<li> <p><code>AIC</code> the Akaike information criterion of the fitted model
</p>
</li>
<li> <p><code>BIC</code> the Bayesian information criterion of the fitted model
</p>
</li>
<li> <p><code>model</code> the fitted model
</p>
</li>
<li> <p><code>estep_variables</code> the E step (forward-backward) probabilities of the final iteration of the EM algorithm
</p>
</li>
<li> <p><code>M</code> the maximum duration in each state
</p>
</li>
<li> <p><code>J</code> the number of states
</p>
</li>
<li> <p><code>NN</code> the vector of sequence lengths
</p>
</li>
<li> <p><code>f</code> the emission probability density function
</p>
</li>
<li> <p><code>mstep</code> the M step function of the EM algorithm
</p>
</li>
<li> <p><code>yhat</code> the estimated sequence of states
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Morteza Amini, <a href="mailto:morteza.amini@ut.ac.ir">morteza.amini@ut.ac.ir</a>, Afarin Bayat, <a href="mailto:aftbayat@gmail.com">aftbayat@gmail.com</a>
</p>


<h3>References</h3>

<p>Guedon, Y. (2005). Hidden hybrid Markov/semi-Markov chains.
<em>Computational statistics and Data analysis</em>, 49(3), 663-688.
</p>
<p>OConnell, J., &amp; Hojsgaard, S. (2011). Hidden semi Markov
models for multiple observation sequences: The mhsmm package
for R. <em>Journal of Statistical Software</em>, 39(4), 1-22.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>J &lt;- 3
initial &lt;- c(1, 0, 0)
semi &lt;- c(FALSE, TRUE, FALSE)
P &lt;- matrix(c(0.8, 0.1, 0.1, 0.5, 0, 0.5, 0.1, 0.2, 0.7), nrow = J, 
byrow = TRUE)
par &lt;- list(mu = list(list(7, 8), list(10, 9, 11), list(12, 14)),
sigma = list(list(3.8, 4.9), list(4.3, 4.2, 5.4), list(4.5, 6.1)),
mix.p = list(c(0.3, 0.7), c(0.2, 0.3, 0.5), c(0.5, 0.5)))
sojourn &lt;- list(shape = c(0, 3, 0), scale = c(0, 10, 0), type = "gamma")
model &lt;- hhsmmspec(init = initial, transition = P, parms.emis = par,
dens.emis = dmixmvnorm, sojourn = sojourn, semi = semi)
train &lt;- simulate(model, nsim = c(10, 8, 8, 18), seed = 1234, 
remission = rmixmvnorm)
clus = initial_cluster(train, nstate = 3, nmix = c(2 ,2, 2),ltr = FALSE,
final.absorb = FALSE, verbose = TRUE)
initmodel1 = initialize_model(clus = clus, sojourn = "gamma", 
M = max(train$N), semi = semi)
fit1 = hhsmmfit(x = train, model = initmodel1, M = max(train$N))

</code></pre>

<hr>
<h2 id='hhsmmspec'>hhsmm specification</h2><span id='topic+hhsmmspec'></span>

<h3>Description</h3>

<p>Specify a model of class <code>"hhsmmspec"</code> using the model parameters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hhsmmspec(
  init,
  transition,
  parms.emission,
  sojourn = NULL,
  dens.emission,
  remission = NULL,
  mstep = NULL,
  semi = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hhsmmspec_+3A_init">init</code></td>
<td>
<p>vector of initial probabilities</p>
</td></tr>
<tr><td><code id="hhsmmspec_+3A_transition">transition</code></td>
<td>
<p>the transition matrix</p>
</td></tr>
<tr><td><code id="hhsmmspec_+3A_parms.emission">parms.emission</code></td>
<td>
<p>the parameters of the emission distribution</p>
</td></tr>
<tr><td><code id="hhsmmspec_+3A_sojourn">sojourn</code></td>
<td>
<p>the sojourn distribution, which is one of the following cases:
</p>

<ul>
<li><p> a list containing <code>d</code>, which is a <code>nobs</code>
(number of observations) times
<code>nstates</code> (number of states) matrix of probabilities,
and <code>type = "nonparametric"</code> for non-parametric sojourn distribution
</p>
</li>
<li><p> a list containing the parameters
<code>mu</code>, <code>shift</code> and <code>size</code> of a shifted
negative binomial distribution, for each semi-Markovian state, and
<code>type = "nbinom"</code> for negative binomial sojourn distribution
</p>
</li>
<li><p> a list containing the parameters
<code>shape</code> and <code>shift</code> of a shifted logarithmic
distribution, for each semi-Markovian state, and
<code>type = "logarithmic"</code> for logarithmic sojourn distribution
</p>
</li>
<li><p> a list containing the parameters
<code>lambda</code> and <code>shift</code> of the
shifted poisson distribution, for each semi-Markovian state, and
<code>type = "poisson"</code> for Poisson sojourn distribution
</p>
</li>
<li><p> a list containing the parameters
<code>shape</code> and <code>scale</code> of the gamma distribution,
for each semi-Markovian state, and
<code>type = "gamma"</code> for gamma sojourn distribution
</p>
</li>
<li><p> a list containing the parameters
<code>shape</code> and <code>scale</code> of the Weibull distribution,
for each semi-Markovian state, and
<code>type = "weibull"</code> for Weibull sojourn distribution
</p>
</li>
<li><p> a list containing the parameters
<code>meanlog</code> and <code>sdlog</code> of the log-normal distribution,
for each semi-Markovian state,
and <code>type = "lnorm"</code> for log-normal sojourn distribution
</p>
</li></ul>
</td></tr>
<tr><td><code id="hhsmmspec_+3A_dens.emission">dens.emission</code></td>
<td>
<p>the probability density function of the emission</p>
</td></tr>
<tr><td><code id="hhsmmspec_+3A_remission">remission</code></td>
<td>
<p>the random sample generation from the emission distribution</p>
</td></tr>
<tr><td><code id="hhsmmspec_+3A_mstep">mstep</code></td>
<td>
<p>the M step function for the EM algorithm</p>
</td></tr>
<tr><td><code id="hhsmmspec_+3A_semi">semi</code></td>
<td>
<p>a logical vector of length nstate: the TRUE associated states are considered as semi-markov</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a model of class <code>"hhsmmspec"</code>
</p>


<h3>Author(s)</h3>

<p>Morteza Amini, <a href="mailto:morteza.amini@ut.ac.ir">morteza.amini@ut.ac.ir</a>, Afarin Bayat,  <a href="mailto:aftbayat@gmail.com">aftbayat@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>init = c(1, 0)
transition = matrix(c(0, 1, 1, 0), 2, 2)
parms.emission = list(mix.p = list(c(0.5, 0.5), 1),
				mu = list(list(c(1, 2), c(5, 1)), c(2, 7)),
              sigma = list(list(diag(2), 2 * diag(2)), 0.5 * diag(2)))
sojourn = list(lambda = 1, shift = 5, type = "poisson")
dens.emission = dmixmvnorm
remission = rmixmvnorm
mstep = mixmvnorm_mstep
semi = rep(TRUE,2)
model = hhsmmspec(init, transition, parms.emission, sojourn, 
dens.emission, remission, mstep, semi)

</code></pre>

<hr>
<h2 id='homogeneity'>Computing maximum homogeneity of two state sequences</h2><span id='topic+homogeneity'></span>

<h3>Description</h3>

<p>A function to compute the maximum homogeneity of two state sequences.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>homogeneity(state.seq1, state.seq2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="homogeneity_+3A_state.seq1">state.seq1</code></td>
<td>
<p>first state sequence</p>
</td></tr>
<tr><td><code id="homogeneity_+3A_state.seq2">state.seq2</code></td>
<td>
<p>second state sequence</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of a length equal to the maximum number of states giving
the maximum homogeneity ratios
</p>


<h3>Author(s)</h3>

<p>Morteza Amini, <a href="mailto:morteza.amini@ut.ac.ir">morteza.amini@ut.ac.ir</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>state.seq1 = c(3, 3, 3, 1, 1, 2, 2, 2, 2)
state.seq2 = c(2, 2, 2, 3, 3, 1, 1, 1, 1)
homogeneity(state.seq1, state.seq2)

</code></pre>

<hr>
<h2 id='initial_cluster'>initial clustering of the data set</h2><span id='topic+initial_cluster'></span>

<h3>Description</h3>

<p>Provides an initial clustering for a data of class <code>"hhsmmdata"</code> which
determines the initial states and mixture components (if necessary)
to be used for initial parameter and model estimation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>initial_cluster(
  train,
  nstate,
  nmix,
  ltr = FALSE,
  equispace = FALSE,
  final.absorb = FALSE,
  verbose = FALSE,
  regress = FALSE,
  resp.ind = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="initial_cluster_+3A_train">train</code></td>
<td>
<p>the train data set of class <code>"hhsmmdata"</code>,
which can also contain missing data (NA or NaN)</p>
</td></tr>
<tr><td><code id="initial_cluster_+3A_nstate">nstate</code></td>
<td>
<p>number of states</p>
</td></tr>
<tr><td><code id="initial_cluster_+3A_nmix">nmix</code></td>
<td>
<p>number of mixture components which is of one of the following forms:
</p>

<ul>
<li><p> a vector of positive (non-zero) integers of length <code>nstate</code>
</p>
</li>
<li><p> a positive (non-zero) integer
</p>
</li>
<li><p> the text <code>"auto"</code>: the number of mixture components will be determined
automatically based on the within cluster sum of squares
</p>
</li>
<li><p> NULL if no mixture distribution is not considered as the emission. This option is
usefull for the nonparametric emission distribution (<code>nonpar_mstep</code> and <code>dnonpar</code>)
</p>
</li></ul>
</td></tr>
<tr><td><code id="initial_cluster_+3A_ltr">ltr</code></td>
<td>
<p>logical. if TRUE a left to right hidden hybrid Markov/semi-Markov model is assumed</p>
</td></tr>
<tr><td><code id="initial_cluster_+3A_equispace">equispace</code></td>
<td>
<p>logical. if TRUE the left to right clustering will be performed simply with equal time spaces.
This option is suitable for speech recognition applications</p>
</td></tr>
<tr><td><code id="initial_cluster_+3A_final.absorb">final.absorb</code></td>
<td>
<p>logical. if TRUE the final state of the sequence is assumed to be the absorbance state</p>
</td></tr>
<tr><td><code id="initial_cluster_+3A_verbose">verbose</code></td>
<td>
<p>logical. if TRUE the outputs will be printed</p>
</td></tr>
<tr><td><code id="initial_cluster_+3A_regress">regress</code></td>
<td>
<p>logical. if TRUE the linear regression clustering will be performed</p>
</td></tr>
<tr><td><code id="initial_cluster_+3A_resp.ind">resp.ind</code></td>
<td>
<p>the column indices of the response variables for the linear regression clustering approach. The
default is 1, which means that the first column is the univariate response variable</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In reliability applications, the hhsmm models are often left-to-right
and the modeling aims to predict the future states. In such cases, the
<code>ltr</code>=TRUE and <code>final.absorb</code>=TRUE should be set.
</p>


<h3>Value</h3>

<p>a list containing the following items:
</p>

<ul>
<li> <p><code>clust.X</code> a list of clustered observations for each sequence and state
</p>
</li>
<li> <p><code>mix.clus</code> a list of the clusters for the mixtures for each state
</p>
</li>
<li> <p><code>state.clus</code> the exact state clusters of each observation (available if <code>ltr</code>=FALSE)
</p>
</li>
<li> <p><code>nmix</code> the number of mixture components (a vector of positive (non-zero) integers of length <code>nstate</code>)
</p>
</li>
<li> <p><code>ltr</code> logical. if TRUE a left to right hidden hybrid Markov/semi-Markov model is assumed
</p>
</li>
<li> <p><code>final.absorb</code> logical. if TRUE the final state of the sequence is assumed to be the absorbance state
</p>
</li>
<li> <p><code>miss</code> logical. if TRUE the <code>train$x</code> matrix contains missing 
data (NA or NaN)
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Morteza Amini, <a href="mailto:morteza.amini@ut.ac.ir">morteza.amini@ut.ac.ir</a>, Afarin Bayat,  <a href="mailto:aftbayat@gmail.com">aftbayat@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>J &lt;- 3
initial &lt;- c(1, 0, 0)
semi &lt;- c(FALSE, TRUE, FALSE)
P &lt;- matrix(c(0.8, 0.1, 0.1, 0.5, 0, 0.5, 0.1, 0.2, 0.7), nrow = J, 
byrow = TRUE)
par &lt;- list(mu = list(list(7, 8), list(10, 9, 11), list(12, 14)),
sigma = list(list(3.8, 4.9), list(4.3, 4.2, 5.4), list(4.5, 6.1)),
mix.p = list(c(0.3, 0.7), c(0.2, 0.3, 0.5), c(0.5, 0.5)))
sojourn &lt;- list(shape = c(0, 3, 0), scale = c(0, 10, 0), type = "gamma")
model &lt;- hhsmmspec(init = initial, transition = P, parms.emis = par,
dens.emis = dmixmvnorm, sojourn = sojourn, semi = semi)
train &lt;- simulate(model, nsim = c(10, 8, 8, 18), seed = 1234, 
remission = rmixmvnorm)
clus = initial_cluster(train, nstate = 3, nmix = c(2 ,2, 2),ltr = FALSE,
final.absorb = FALSE, verbose = TRUE)

</code></pre>

<hr>
<h2 id='initial_estimate'>initial estimation of the model parameters for a specified emission distribution</h2><span id='topic+initial_estimate'></span>

<h3>Description</h3>

<p>Provides the initial estimates of the model parameters of a specified emission
distribution characterized by the <code>mstep</code> function, for an initial clustering
obtained by <code><a href="#topic+initial_cluster">initial_cluster</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>initial_estimate(clus, mstep = mixmvnorm_mstep, verbose = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="initial_estimate_+3A_clus">clus</code></td>
<td>
<p>an initial clustering obtained by <code>initial_cluster</code></p>
</td></tr>
<tr><td><code id="initial_estimate_+3A_mstep">mstep</code></td>
<td>
<p>the mstep function of the EM algorithm with an style simillar to that of <code><a href="#topic+mixmvnorm_mstep">mixmvnorm_mstep</a></code></p>
</td></tr>
<tr><td><code id="initial_estimate_+3A_verbose">verbose</code></td>
<td>
<p>logical. if TRUE the outputs will be printed</p>
</td></tr>
<tr><td><code id="initial_estimate_+3A_...">...</code></td>
<td>
<p>additional parameters of the <code>mstep</code> function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list containing the following items:
</p>

<ul>
<li> <p><code>emission</code> list the estimated parameterers of the emission distribution
</p>
</li>
<li> <p><code>leng</code> list of waiting times in each state for each sequence
</p>
</li>
<li> <p><code>clusters</code> the exact clusters of each observation (available if <code>ltr</code>=FALSE)
</p>
</li>
<li> <p><code>nmix</code> the number of mixture components (a vector of positive (non-zero) integers of length <code>nstate</code>)
</p>
</li>
<li> <p><code>ltr</code> logical. if TRUE a left to right hidden hybrid Markovian/semi-Markovianmodel is assumed
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Morteza Amini, <a href="mailto:morteza.amini@ut.ac.ir">morteza.amini@ut.ac.ir</a>, Afarin Bayat,  <a href="mailto:aftbayat@gmail.com">aftbayat@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>J &lt;- 3
initial &lt;- c(1, 0, 0)
semi &lt;- c(FALSE, TRUE, FALSE)
P &lt;- matrix(c(0.8, 0.1, 0.1, 0.5, 0, 0.5, 0.1, 0.2, 0.7), nrow = J, 
byrow = TRUE)
par &lt;- list(mu = list(list(7, 8), list(10, 9, 11), list(12, 14)),
sigma = list(list(3.8, 4.9), list(4.3, 4.2, 5.4), list(4.5, 6.1)),
mix.p = list(c(0.3, 0.7), c(0.2, 0.3, 0.5), c(0.5, 0.5)))
sojourn &lt;- list(shape = c(0, 3, 0), scale = c(0, 10, 0), type = "gamma")
model &lt;- hhsmmspec(init = initial, transition = P, parms.emis = par,
dens.emis = dmixmvnorm, sojourn = sojourn, semi = semi)
train &lt;- simulate(model, nsim = c(10, 8, 8, 18), seed = 1234, 
remission = rmixmvnorm)
clus = initial_cluster(train, nstate = 3, nmix = c(2 ,2, 2),ltr = FALSE,
final.absorb = FALSE, verbose = TRUE)
par = initial_estimate(clus, verbose = TRUE)

</code></pre>

<hr>
<h2 id='initialize_model'>initialize the hhsmmspec model for a specified emission distribution</h2><span id='topic+initialize_model'></span>

<h3>Description</h3>

<p>Initialize the <code><a href="#topic+hhsmmspec">hhsmmspec</a></code> model by using an initial clustering
obtained by <code><a href="#topic+initial_cluster">initial_cluster</a></code> and the emission distribution
characterized by mstep and dens.emission
</p>


<h3>Usage</h3>

<pre><code class='language-R'>initialize_model(
  clus,
  mstep = NULL,
  dens.emission = dmixmvnorm,
  sojourn = NULL,
  semi = NULL,
  M,
  verbose = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="initialize_model_+3A_clus">clus</code></td>
<td>
<p>initial clustering obtained by <code>initial_cluster</code></p>
</td></tr>
<tr><td><code id="initialize_model_+3A_mstep">mstep</code></td>
<td>
<p>the mstep function of the EM algorithm with an style
simillar to that of <code><a href="#topic+mixmvnorm_mstep">mixmvnorm_mstep</a></code>. If NULL, the
<code><a href="#topic+mixmvnorm_mstep">mixmvnorm_mstep</a></code> is considered for the complete data set and
<code><a href="#topic+miss_mixmvnorm_mstep">miss_mixmvnorm_mstep</a></code> is considered for the data with missing
values (NA or NaN)</p>
</td></tr>
<tr><td><code id="initialize_model_+3A_dens.emission">dens.emission</code></td>
<td>
<p>the density of the emission distribution with an style simillar to that of <code><a href="#topic+dmixmvnorm">dmixmvnorm</a></code></p>
</td></tr>
<tr><td><code id="initialize_model_+3A_sojourn">sojourn</code></td>
<td>
<p>one of the following cases:
</p>

<ul>
<li> <p><code>"nonparametric"</code> non-parametric sojourn distribution
</p>
</li>
<li> <p><code>"nbinom"</code> negative binomial sojourn distribution
</p>
</li>
<li> <p><code>"logarithmic"</code> logarithmic sojourn distribution
</p>
</li>
<li> <p><code>"poisson"</code> poisson sojourn distribution
</p>
</li>
<li> <p><code>"gamma"</code> gamma sojourn distribution
</p>
</li>
<li> <p><code>"weibull"</code> weibull sojourn distribution
</p>
</li>
<li> <p><code>"lnorm"</code> log-normal sojourn distribution
</p>
</li>
<li> <p><code>"auto"</code>automatic determination of the sojourn distribution using the chi-square test
</p>
</li></ul>
</td></tr>
<tr><td><code id="initialize_model_+3A_semi">semi</code></td>
<td>
<p>logical and of one of the following forms:
</p>

<ul>
<li><p> a logical value: if TRUE all states are considered as semi-Markovian else Markovian
</p>
</li>
<li><p> a logical vector of length nstate: the TRUE associated states are considered as semi-Markovian
and FALSE associated states are considered as Markovian
</p>
</li>
<li> <p><code>NULL</code> if <code>ltr</code>=TRUE then <code>semi = c(rep(TRUE,nstate-1),FALSE)</code>, else 
<code>semi = rep(TRUE,nstate)</code>
</p>
</li></ul>
</td></tr>
<tr><td><code id="initialize_model_+3A_m">M</code></td>
<td>
<p>maximum number of waiting times in each state</p>
</td></tr>
<tr><td><code id="initialize_model_+3A_verbose">verbose</code></td>
<td>
<p>logical. if TRUE the outputs will be printed
the normal distributions will be estimated</p>
</td></tr>
<tr><td><code id="initialize_model_+3A_...">...</code></td>
<td>
<p>additional parameters of the <code>mstep</code> function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code><a href="#topic+hhsmmspec">hhsmmspec</a></code> model containing the following items:
</p>

<ul>
<li> <p><code>init</code> initial probabilities of states
</p>
</li>
<li> <p><code>transition</code> transition matrix
</p>
</li>
<li> <p><code>parms.emission</code> parameters of the mixture normal emission (<code>mu</code>, <code>sigma</code>, <code>mix.p</code>)
</p>
</li>
<li> <p><code>sojourn</code> list of sojourn time distribution parameters and its <code>type</code>
</p>
</li>
<li> <p><code>dens.emission</code> the emission probability density function
</p>
</li>
<li> <p><code>mstep</code> the M step function of the EM algorithm
</p>
</li>
<li> <p><code>semi</code> a logical vector of length nstate with the TRUE associated states are considered as semi-Markovian
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Morteza Amini, <a href="mailto:morteza.amini@ut.ac.ir">morteza.amini@ut.ac.ir</a>, Afarin Bayat,  <a href="mailto:aftbayat@gmail.com">aftbayat@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>J &lt;- 3
initial &lt;- c(1, 0, 0)
semi &lt;- c(FALSE, TRUE, FALSE)
P &lt;- matrix(c(0.8, 0.1, 0.1, 0.5, 0, 0.5, 0.1, 0.2, 0.7), nrow = J, 
byrow = TRUE)
par &lt;- list(mu = list(list(7, 8), list(10, 9, 11), list(12, 14)),
sigma = list(list(3.8, 4.9), list(4.3, 4.2, 5.4), list(4.5, 6.1)),
mix.p = list(c(0.3, 0.7), c(0.2, 0.3, 0.5), c(0.5, 0.5)))
sojourn &lt;- list(shape = c(0, 3, 0), scale = c(0, 10, 0), type = "gamma")
model &lt;- hhsmmspec(init = initial, transition = P, parms.emis = par,
dens.emis = dmixmvnorm, sojourn = sojourn, semi = semi)
train &lt;- simulate(model, nsim = c(10, 8, 8, 18), seed = 1234, 
remission = rmixmvnorm)
clus = initial_cluster(train, nstate = 3, nmix = c(2 ,2, 2),ltr = FALSE,
final.absorb = FALSE, verbose = TRUE)
initmodel = initialize_model(clus = clus, sojourn = "gamma", 
M = max(train$N))

</code></pre>

<hr>
<h2 id='lagdata'>Create hhsmm data of lagged time series</h2><span id='topic+lagdata'></span>

<h3>Description</h3>

<p>Creates a data of class <code>hhsmmdata</code> containing lagged time series
which can be used for fitting auto-regressive hidden hybrid Makrov/semi-Markov
model (AR-HHSMM)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lagdata(data, lags = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lagdata_+3A_data">data</code></td>
<td>
<p>a data of class <code>hhsmmdata</code> containing a multivariate and multi-state time series</p>
</td></tr>
<tr><td><code id="lagdata_+3A_lags">lags</code></td>
<td>
<p>a positive integer which is the number of lags to be calculated</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data of class <code>hhsmmdata</code> containing lagged time series
</p>


<h3>Author(s)</h3>

<p>Morteza Amini, <a href="mailto:morteza.amini@ut.ac.ir">morteza.amini@ut.ac.ir</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>J &lt;- 3
initial &lt;- c(1, 0, 0)
semi &lt;- rep(FALSE, 3)
P &lt;- matrix(c(0.5, 0.2, 0.3, 0.2, 0.5, 0.3, 0.1, 0.4, 0.5), nrow = J, 
byrow = TRUE)
par &lt;- list(intercept = list(0.1, -0.1, 0.2),
coefficient = list(-0.6, 0.7, -0.5),
csigma = list(5.5, 4, 3.5), mix.p = list(1, 1, 1))
model &lt;- hhsmmspec(init = initial, transition = P, parms.emis = par,
dens.emis = dmixlm, semi = semi)
train &lt;- simulate(model, nsim = c(50, 60, 84, 100), seed = 1234, 
emission.control = list(autoregress = TRUE))
laggedtrain = lagdata(train)

</code></pre>

<hr>
<h2 id='ltr_clus'>left to right clustering</h2><span id='topic+ltr_clus'></span>

<h3>Description</h3>

<p>A left to right initial clustering method using the
mean differences and Hotelling's T-squared test
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ltr_clus(Dat, k)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ltr_clus_+3A_dat">Dat</code></td>
<td>
<p>a data matrix</p>
</td></tr>
<tr><td><code id="ltr_clus_+3A_k">k</code></td>
<td>
<p>number of clusters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a (left to right) clustering vector
</p>


<h3>Author(s)</h3>

<p>Morteza Amini, <a href="mailto:morteza.amini@ut.ac.ir">morteza.amini@ut.ac.ir</a>, Afarin Bayat,  <a href="mailto:aftbayat@gmail.com">aftbayat@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(CMAPSS)
clus = ltr_clus(CMAPSS$train$x[1:CMAPSS$train$N[1], ], 3)

</code></pre>

<hr>
<h2 id='ltr_reg_clus'>left to right linear regression clustering</h2><span id='topic+ltr_reg_clus'></span>

<h3>Description</h3>

<p>A left to right initial linear regression clustering method using the
coefficient differences and Hotelling's T-squared test
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ltr_reg_clus(Dat, k, resp.ind = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ltr_reg_clus_+3A_dat">Dat</code></td>
<td>
<p>a data matrix</p>
</td></tr>
<tr><td><code id="ltr_reg_clus_+3A_k">k</code></td>
<td>
<p>number of clusters</p>
</td></tr>
<tr><td><code id="ltr_reg_clus_+3A_resp.ind">resp.ind</code></td>
<td>
<p>the column indices of the response variables for the linear regression clustering approach. The
default is 1, which means that the first column is the univariate response variable</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a (left to right) clustering vector
</p>


<h3>Author(s)</h3>

<p>Morteza Amini, <a href="mailto:morteza.amini@ut.ac.ir">morteza.amini@ut.ac.ir</a>
</p>

<hr>
<h2 id='make_model'>make a hhsmmspec model for a specified emission distribution</h2><span id='topic+make_model'></span>

<h3>Description</h3>

<p>Provides a hhsmmspec model by using the parameters
obtained by <code><a href="#topic+initial_estimate">initial_estimate</a></code> for the emission distribution
characterized by mstep and dens.emission
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_model(
  par,
  mstep = mixmvnorm_mstep,
  dens.emission = dmixmvnorm,
  semi = NULL,
  M,
  sojourn
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_model_+3A_par">par</code></td>
<td>
<p>the parameters obtained by <code><a href="#topic+initial_estimate">initial_estimate</a></code></p>
</td></tr>
<tr><td><code id="make_model_+3A_mstep">mstep</code></td>
<td>
<p>the mstep function of the EM algorithm with an style simillar to that of <code><a href="#topic+mixmvnorm_mstep">mixmvnorm_mstep</a></code></p>
</td></tr>
<tr><td><code id="make_model_+3A_dens.emission">dens.emission</code></td>
<td>
<p>the density of the emission distribution with an style simillar to that of <code><a href="#topic+dmixmvnorm">dmixmvnorm</a></code></p>
</td></tr>
<tr><td><code id="make_model_+3A_semi">semi</code></td>
<td>
<p>logical and of one of the following forms:
</p>

<ul>
<li><p> a logical value: if TRUE all states are considered as semi-Markovian else Markovian
</p>
</li>
<li><p> a logical vector of length nstate: the TRUE associated states are considered as semi-Markovian
and FALSE associated states are considered as Markovian
</p>
</li>
<li> <p><code>NULL</code> if <code>ltr</code>=TRUE then <code>semi = c(rep(TRUE,nstate-1),FALSE)</code>, else 
<code>semi = rep(TRUE,nstate)</code>
</p>
</li></ul>
</td></tr>
<tr><td><code id="make_model_+3A_m">M</code></td>
<td>
<p>maximum number of waiting times in each state</p>
</td></tr>
<tr><td><code id="make_model_+3A_sojourn">sojourn</code></td>
<td>
<p>the sojourn time distribution which is one of the following cases:
</p>

<ul>
<li> <p><code>"nonparametric"</code> non-parametric sojourn distribution
</p>
</li>
<li> <p><code>"nbinom"</code> negative binomial sojourn distribution
</p>
</li>
<li> <p><code>"logarithmic"</code> logarithmic sojourn distribution
</p>
</li>
<li> <p><code>"poisson"</code> poisson sojourn distribution
</p>
</li>
<li> <p><code>"gamma"</code> gamma sojourn distribution
</p>
</li>
<li> <p><code>"weibull"</code> weibull sojourn distribution
</p>
</li>
<li> <p><code>"lnorm"</code> log-normal sojourn distribution
</p>
</li>
<li> <p><code>"auto"</code> automatic determination of the sojourn distribution using the chi-square test
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code><a href="#topic+hhsmmspec">hhsmmspec</a></code> model containing the following items:
</p>

<ul>
<li> <p><code>init</code> initial probabilities of states
</p>
</li>
<li> <p><code>transition</code> transition matrix
</p>
</li>
<li> <p><code>parms.emission</code> parameters of the mixture normal emission (<code>mu</code>, <code>sigma</code>, <code>mix.p</code>)
</p>
</li>
<li> <p><code>sojourn</code> list of sojourn distribution parameters and its <code>type</code>
</p>
</li>
<li> <p><code>dens.emission</code> the emission probability density function
</p>
</li>
<li> <p><code>mstep</code> the M step function of the EM algorithm
</p>
</li>
<li> <p><code>semi</code> a logical vector of length nstate with the TRUE associated states are considered as semi-Markovian
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Morteza Amini, <a href="mailto:morteza.amini@ut.ac.ir">morteza.amini@ut.ac.ir</a>, Afarin Bayat,  <a href="mailto:aftbayat@gmail.com">aftbayat@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>J &lt;- 3
initial &lt;- c(1, 0, 0)
semi &lt;- c(FALSE, TRUE, FALSE)
P &lt;- matrix(c(0.8, 0.1, 0.1, 0.5, 0, 0.5, 0.1, 0.2, 0.7), nrow = J, 
byrow = TRUE)
par &lt;- list(mu = list(list(7, 8), list(10, 9, 11), list(12, 14)),
sigma = list(list(3.8, 4.9), list(4.3, 4.2, 5.4), list(4.5, 6.1)),
mix.p = list(c(0.3, 0.7), c(0.2, 0.3, 0.5), c(0.5, 0.5)))
sojourn &lt;- list(shape = c(0, 3, 0), scale = c(0, 10, 0), type = "gamma")
model &lt;- hhsmmspec(init = initial, transition = P, parms.emis = par,
dens.emis = dmixmvnorm, sojourn = sojourn, semi = semi)
train &lt;- simulate(model, nsim = c(10, 8, 8, 18), seed = 1234, remission = rmixmvnorm)
clus = initial_cluster(train, nstate = 3, nmix = c(2, 2, 2), ltr = FALSE,
final.absorb = FALSE, verbose = TRUE)
par = initial_estimate(clus, verbose = TRUE)
model = make_model(par, semi = NULL, M = max(train$N), sojourn = "gamma")

</code></pre>

<hr>
<h2 id='miss_mixmvnorm_mstep'>the M step function of the EM algorithm</h2><span id='topic+miss_mixmvnorm_mstep'></span>

<h3>Description</h3>

<p>The M step function of the EM algorithm for the mixture
of multivariate normals as the emission distribution with
missing values using the observation matrix and the estimated
weight vectors
</p>


<h3>Usage</h3>

<pre><code class='language-R'>miss_mixmvnorm_mstep(x, wt1, wt2, par)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="miss_mixmvnorm_mstep_+3A_x">x</code></td>
<td>
<p>the observation matrix which can contain missing values (NA or NaN)</p>
</td></tr>
<tr><td><code id="miss_mixmvnorm_mstep_+3A_wt1">wt1</code></td>
<td>
<p>the state probabilities matrix (number of observations
times number of states)</p>
</td></tr>
<tr><td><code id="miss_mixmvnorm_mstep_+3A_wt2">wt2</code></td>
<td>
<p>the mixture components probabilities list (of length
nstate) of matrices (number of observations times number of
mixture components)</p>
</td></tr>
<tr><td><code id="miss_mixmvnorm_mstep_+3A_par">par</code></td>
<td>
<p>the parameters of the model in the previous step of
the EM algorithm. For initialization of the model when the data
is initially imputed, <code>par</code> can be NULL</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of emission (mixture multivariate normal) parameters:
(<code>mu</code>, <code>sigma</code> and <code>mix.p</code>)
</p>


<h3>Author(s)</h3>

<p>Morteza Amini, <a href="mailto:morteza.amini@ut.ac.ir">morteza.amini@ut.ac.ir</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(CMAPSS)
n = nrow(CMAPSS$train$x)
wt1 = matrix(runif(3*n),nrow=n,ncol=3)
wt2 = list()
for(j in 1:3) wt2[[j]] = matrix(runif(5*n),nrow=n,ncol=5)
emission = miss_mixmvnorm_mstep(CMAPSS$train$x, wt1, wt2, par=NULL)

</code></pre>

<hr>
<h2 id='mixdiagmvnorm_mstep'>the M step function of the EM algorithm</h2><span id='topic+mixdiagmvnorm_mstep'></span>

<h3>Description</h3>

<p>The M step function of the EM algorithm for the mixture
of multivariate normals with diagonal covariance matrix
as the emission distribution using the
observation matrix and the estimated weight vectors
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mixdiagmvnorm_mstep(x, wt1, wt2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mixdiagmvnorm_mstep_+3A_x">x</code></td>
<td>
<p>the observation matrix</p>
</td></tr>
<tr><td><code id="mixdiagmvnorm_mstep_+3A_wt1">wt1</code></td>
<td>
<p>the state probabilities matrix (number of observations
times number of states)</p>
</td></tr>
<tr><td><code id="mixdiagmvnorm_mstep_+3A_wt2">wt2</code></td>
<td>
<p>the mixture components probabilities list (of length
nstate) of matrices (number of observations times number of
mixture components)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of emission (mixture multivariate normal) parameters:
(<code>mu</code>, <code>sigma</code> and <code>mix.p</code>), where <code>sigma</code> is a diagonal matrix
</p>


<h3>Author(s)</h3>

<p>Morteza Amini, <a href="mailto:morteza.amini@ut.ac.ir">morteza.amini@ut.ac.ir</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(CMAPSS)
n = nrow(CMAPSS$train$x)
wt1 &lt;- matrix(runif(3 * n), nrow = n, ncol = 3)
wt2 &lt;- list()
for(j in 1:3) wt2[[j]] &lt;- matrix(runif(5 * n), nrow = n, ncol = 5)
emission &lt;- mixdiagmvnorm_mstep(CMAPSS$train$x, wt1, wt2)


</code></pre>

<hr>
<h2 id='mixlm_mstep'>the M step function of the EM algorithm</h2><span id='topic+mixlm_mstep'></span>

<h3>Description</h3>

<p>The M step function of the EM algorithm for the mixture
of Gaussian linear (Markov-switching) regressions as the emission distribution using the
responses and covariates matrices and the estimated weight vectors
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mixlm_mstep(x, wt1, wt2, resp.ind = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mixlm_mstep_+3A_x">x</code></td>
<td>
<p>the observation matrix including responses and covariates</p>
</td></tr>
<tr><td><code id="mixlm_mstep_+3A_wt1">wt1</code></td>
<td>
<p>the state probabilities matrix (number of observations
times number of states)</p>
</td></tr>
<tr><td><code id="mixlm_mstep_+3A_wt2">wt2</code></td>
<td>
<p>the mixture components probabilities list (of length
nstate) of matrices (number of observations times number of
mixture components)</p>
</td></tr>
<tr><td><code id="mixlm_mstep_+3A_resp.ind">resp.ind</code></td>
<td>
<p>a vector of the column numbers of <code>x</code> which contain response variables.
The default is 1, which means that the first column of <code>x</code> is the univariate
response variable</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of emission (mixture of Gaussian linear regression models) parameters:
(<code>intercept</code>, <code>coefficients</code>, <code>csigma</code> (conditional covariance) and <code>mix.p</code>)
</p>


<h3>Author(s)</h3>

<p>Morteza Amini, <a href="mailto:morteza.amini@ut.ac.ir">morteza.amini@ut.ac.ir</a>
</p>


<h3>References</h3>

<p>Kim, C. J., Piger, J. and Startz, R. (2008). Estimation of Markov
regime-switching regression models with endogenous switching.
Journal of Econometrics, 143(2), 263-273.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>J &lt;- 3
initial &lt;- c(1, 0, 0)
semi &lt;- rep(FALSE, 3)
P &lt;- matrix(c(0.5, 0.2, 0.3, 0.2, 0.5, 0.3, 0.1, 0.4, 0.5), nrow = J, 
byrow = TRUE)
par &lt;- list(intercept = list(3, list(-10, -1), 14),
coefficient = list(-1, list(1, 5), -7),
csigma = list(1.2, list(2.3, 3.4), 1.1),
mix.p = list(1, c(0.4, 0.6), 1))
model &lt;- hhsmmspec(init = initial, transition = P, parms.emis = par,
dens.emis = dmixlm, semi = semi)
train &lt;- simulate(model, nsim = c(20, 30, 42, 50), seed = 1234, 
remission = rmixlm, covar = list(mean = 0, cov = 1))
clus = initial_cluster(train = train, nstate = 3, nmix = c(1, 2, 1),
ltr = FALSE, final.absorb = FALSE, verbose = TRUE, regress = TRUE)
initmodel = initialize_model(clus = clus ,mstep = mixlm_mstep,
dens.emission = dmixlm, sojourn = NULL, semi = rep(FALSE, 3),
M = max(train$N),verbose = TRUE)
fit1 = hhsmmfit(x = train, model = initmodel, mstep = mixlm_mstep,
M = max(train$N))
plot(train$x[, 1] ~ train$x[, 2], col = train$s, pch = 16, 
xlab = "x", ylab = "y")
abline(fit1$model$parms.emission$intercept[[1]],
fit1$model$parms.emission$coefficient[[1]], col = 1)
abline(fit1$model$parms.emission$intercept[[2]][[1]],
fit1$model$parms.emission$coefficient[[2]][[1]], col = 2)
abline(fit1$model$parms.emission$intercept[[2]][[2]],
fit1$model$parms.emission$coefficient[[2]][[2]], col = 2)
abline(fit1$model$parms.emission$intercept[[3]],
fit1$model$parms.emission$coefficient[[3]], col = 3)

</code></pre>

<hr>
<h2 id='mixmvnorm_mstep'>the M step function of the EM algorithm</h2><span id='topic+mixmvnorm_mstep'></span>

<h3>Description</h3>

<p>The M step function of the EM algorithm for the mixture
of multivariate normals as the emission distribution using the
observation matrix and the estimated weight vectors
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mixmvnorm_mstep(x, wt1, wt2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mixmvnorm_mstep_+3A_x">x</code></td>
<td>
<p>the observation matrix</p>
</td></tr>
<tr><td><code id="mixmvnorm_mstep_+3A_wt1">wt1</code></td>
<td>
<p>the state probabilities matrix (number of observations
times number of states)</p>
</td></tr>
<tr><td><code id="mixmvnorm_mstep_+3A_wt2">wt2</code></td>
<td>
<p>the mixture components probabilities list (of length
nstate) of matrices (number of observations times number of
mixture components)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of emission (mixture multivariate normal) parameters:
(<code>mu</code>, <code>sigma</code> and <code>mix.p</code>)
</p>


<h3>Author(s)</h3>

<p>Morteza Amini, <a href="mailto:morteza.amini@ut.ac.ir">morteza.amini@ut.ac.ir</a>, Afarin Bayat,  <a href="mailto:aftbayat@gmail.com">aftbayat@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(CMAPSS)
n = nrow(CMAPSS$train$x)
wt1 = matrix(runif(3*n),nrow=n,ncol=3)
wt2 = list()
for(j in 1:3) wt2[[j]] = matrix(runif(5*n),nrow=n,ncol=5)
emission = mixmvnorm_mstep(CMAPSS$train$x, wt1, wt2)

</code></pre>

<hr>
<h2 id='mstep.multinomial'>the M step function of the EM algorithm</h2><span id='topic+mstep.multinomial'></span>

<h3>Description</h3>

<p>The M step function of the EM algorithm for estimation of the
parameters of the multinomial emission distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mstep.multinomial(x, wt, n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mstep.multinomial_+3A_x">x</code></td>
<td>
<p>the observation matrix</p>
</td></tr>
<tr><td><code id="mstep.multinomial_+3A_wt">wt</code></td>
<td>
<p>the state probabilities matrix (number of observations
times number of states)</p>
</td></tr>
<tr><td><code id="mstep.multinomial_+3A_n">n</code></td>
<td>
<p>the maximum possible level of the multinomial vector (i.e. from 1 to n)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of multinomial emission parameters:
(<code>prob</code>)
</p>


<h3>Author(s)</h3>

<p>Morteza Amini, <a href="mailto:morteza.amini@ut.ac.ir">morteza.amini@ut.ac.ir</a>,
</p>


<h3>Examples</h3>

<pre><code class='language-R'>J &lt;- 2
initial &lt;- c(1, 0)
semi &lt;- rep(TRUE, 2)
P &lt;- matrix(c(0, 1, 1, 0), 
nrow = J, byrow = TRUE)
par &lt;- list(prob = list(c(0.6,  0.2, 0.2),
                           c(0.2, 0.6,  0.2)))
sojourn &lt;- list(shape = c(1, 3), scale = c(2, 10), type = "gamma")
model &lt;- hhsmmspec(init = initial, transition = P, parms.emis = par,
dens.emis = dmultinomial.hhsmm, remission = rmultinomial.hhsmm,
 mstep = mstep.multinomial,sojourn = sojourn, semi = semi)
train &lt;- simulate(model, nsim = c(20, 30, 42, 50), seed = 1234, 
remission = rmultinomial.hhsmm)
clus = initial_cluster(train = train, nstate = 2, nmix = NULL,
ltr = FALSE, final.absorb = FALSE, verbose = TRUE)
initmodel = initialize_model(clus = clus, mstep = mstep.multinomial, n = 3,
dens.emission = dmultinomial.hhsmm, sojourn = "gamma", semi = rep(TRUE, 2), 
M = max(train$N),verbose = TRUE)
fit1 = hhsmmfit(x = train, model = initmodel, mstep = mstep.multinomial, n = 3, 
M = max(train$N))
homogeneity(fit1$yhat,train$s)

</code></pre>

<hr>
<h2 id='nonpar_mstep'>the M step function of the EM algorithm</h2><span id='topic+nonpar_mstep'></span>

<h3>Description</h3>

<p>The M step function of the EM algorithm for the mixture
of splines nonparametric density estimator
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nonpar_mstep(x, wt, control = list(K = 5, lambda0 = 0.5))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nonpar_mstep_+3A_x">x</code></td>
<td>
<p>the observation matrix</p>
</td></tr>
<tr><td><code id="nonpar_mstep_+3A_wt">wt</code></td>
<td>
<p>the state probabilities matrix (number of observations
times number of states)</p>
</td></tr>
<tr><td><code id="nonpar_mstep_+3A_control">control</code></td>
<td>
<p>the parameters to control the M-step function.
The simillar name is chosen with that of <code><a href="#topic+dnonpar">dnonpar</a></code>,
to be used in <code>...</code> argument of the <code><a href="#topic+hhsmmfit">hhsmmfit</a></code> function.
Here, it contains the following items:
</p>

<ul>
<li> <p><code>K</code> the degrees of freedom for the B-spline, default is <code>K=5</code>
</p>
</li>
<li> <p><code>lambda0</code> the initial value of the smoothing parameter, default is <code>lambda0=0.5</code>
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>list of emission (nonparametric mixture of splines) parameters:
(<code>coef</code>)
</p>


<h3>Author(s)</h3>

<p>Morteza Amini, <a href="mailto:morteza.amini@ut.ac.ir">morteza.amini@ut.ac.ir</a>,
Reza Salehian,  <a href="mailto:reza.salehian@ut.ac.ir">reza.salehian@ut.ac.ir</a>
</p>


<h3>References</h3>

<p>Langrock, R., Kneib, T., Sohn, A., &amp; DeRuiter, S. L. (2015).
Nonparametric inference in hidden Markov
models using P-splines. <em>Biometrics</em>, 71(2), 520-528.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rmvnorm(100, rep(0, 2), matrix(c(4, 2, 2, 3), 2, 2))
wt &lt;- matrix(rep(1, 100), 100, 1)
emission = nonpar_mstep(x, wt)
coef &lt;- emission$coef[[1]]
x_axis &lt;- seq(min(x[, 1]), max(x[, 1]), length.out = 100)
y_axis &lt;- seq(min(x[, 2]), max(x[, 2]), length.out = 100)
f1 &lt;- function(x, y) { 
  data = matrix(c(x, y), ncol = 2)
  tmpmodel = list(parms.emission = emission)
	 dnonpar(data, 1, tmpmodel)
}
z1 &lt;- outer(x_axis, y_axis, f1)
f2 &lt;- function(x, y) { 
  data = matrix(c(x, y), ncol = 2)
  dmvnorm(data, rep(0, 2), matrix(c(4, 2, 2, 3), 2, 2))
}
z2 &lt;- outer(x_axis, y_axis, f2)
par(mfrow = c(1, 2))
persp(x_axis, y_axis, z1, theta = -60, phi = 45, col = rainbow(50))
persp(x_axis, y_axis, z2, theta = -60, phi = 45, col = rainbow(50))

</code></pre>

<hr>
<h2 id='predict.hhsmm'>prediction of state sequence for hhsmm</h2><span id='topic+predict.hhsmm'></span>

<h3>Description</h3>

<p>Predicts the state sequence of a fitted hidden hybrid Markov/semi-Markov model estimated by
<code><a href="#topic+hhsmmfit">hhsmmfit</a></code> for a new (test) data of class <code>"hhsmmdata"</code> with an optional prediction of the
residual useful lifetime (RUL) for a left to right model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'hhsmm'
predict(
  object,
  newdata,
  future = 0,
  method = "viterbi",
  RUL.estimate = FALSE,
  confidence = "max",
  conf.level = 0.95,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.hhsmm_+3A_object">object</code></td>
<td>
<p>a fitted model of class <code>"hhsmm"</code> estimated by <code>hhsmmfit</code></p>
</td></tr>
<tr><td><code id="predict.hhsmm_+3A_newdata">newdata</code></td>
<td>
<p>a new (test) data of class <code>"hhsmmdata"</code>,
which also can contain missing values (NA or NaN)</p>
</td></tr>
<tr><td><code id="predict.hhsmm_+3A_future">future</code></td>
<td>
<p>number of future states to be predicted</p>
</td></tr>
<tr><td><code id="predict.hhsmm_+3A_method">method</code></td>
<td>
<p>the prediction method with two options:
</p>

<ul>
<li> <p><code>"viterbi"</code> (default) uses the Viterbi algorithm for prediction
</p>
</li>
<li> <p><code>"smoothing"</code> uses the smoothing algorithm for prediction
</p>
</li></ul>
</td></tr>
<tr><td><code id="predict.hhsmm_+3A_rul.estimate">RUL.estimate</code></td>
<td>
<p>logical. if TRUE the residual useful lifetime (RUL) of a left to right model, as well as
the prediction interval will also be predicted (default is FALSE)</p>
</td></tr>
<tr><td><code id="predict.hhsmm_+3A_confidence">confidence</code></td>
<td>
<p>the method for obtaining the prediction interval of the RUL, with two cases:
</p>

<ul>
<li> <p><code>"max"</code> (default) the maximum probability as the point predict and the high probability critical
values as the lower and upper bounds
</p>
</li>
<li> <p><code>"mean"</code> the mean value as the point predict and the normal confidence lower and upper bounds as the 
prediction interval
</p>
</li></ul>
</td></tr>
<tr><td><code id="predict.hhsmm_+3A_conf.level">conf.level</code></td>
<td>
<p>the confidence level of the prediction interval (default 0.95)</p>
</td></tr>
<tr><td><code id="predict.hhsmm_+3A_...">...</code></td>
<td>
<p>additional parameters for the dens.emission and mstep functions</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list containing the following items:
</p>

<ul>
<li> <p><code>x</code> the observation sequence
</p>
</li>
<li> <p><code>s</code> the predicted state sequence
</p>
</li>
<li> <p><code>N</code> the vector of sequence lengths
</p>
</li>
<li> <p><code>p</code> the state probabilities 
</p>
</li>
<li> <p><code>RUL</code> the point predicts of the RUL
</p>
</li>
<li> <p><code>RUL.low</code> the lower bounds for the prediction intervals of the RUL
</p>
</li>
<li> <p><code>RUL.up</code> the upper bounds for the prediction intervals of the RUL
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Morteza Amini, <a href="mailto:morteza.amini@ut.ac.ir">morteza.amini@ut.ac.ir</a>, Afarin Bayat,  <a href="mailto:aftbayat@gmail.com">aftbayat@gmail.com</a>
</p>


<h3>References</h3>

<p>Guedon, Y. (2005). Hidden hybrid Markov/semi-Markov chains.
<em>Computational statistics and Data analysis</em>, 49(3), 663-688.
</p>
<p>OConnell, J., &amp; Hojsgaard, S. (2011). Hidden semi Markov
models for multiple observation sequences: The mhsmm package
for R. <em>Journal of Statistical Software</em>, 39(4), 1-22.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+predict.hhsmmspec">predict.hhsmmspec</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>J &lt;- 3
initial &lt;- c(1, 0, 0)
semi &lt;- c(FALSE, TRUE, FALSE)
P &lt;- matrix(c(0.8, 0.1, 0.1, 0.5, 0, 0.5, 0.1, 0.2, 0.7), nrow = J, 
byrow = TRUE)
par &lt;- list(mu = list(list(7, 8), list(10, 9, 11), list(12, 14)),
sigma = list(list(3.8, 4.9), list(4.3, 4.2, 5.4), list(4.5, 6.1)),
mix.p = list(c(0.3, 0.7), c(0.2, 0.3, 0.5), c(0.5, 0.5)))
sojourn &lt;- list(shape = c(0, 3, 0), scale = c(0, 10, 0), type = "gamma")
model &lt;- hhsmmspec(init = initial, transition = P, parms.emis = par,
dens.emis = dmixmvnorm, sojourn = sojourn, semi = semi)
train &lt;- simulate(model, nsim = c(10, 8, 8, 18), seed = 1234, remission = rmixmvnorm)
test &lt;-  simulate(model, nsim = c(7, 3, 3, 8), seed = 1234, remission = rmixmvnorm)
clus = initial_cluster(train, nstate = 3, nmix = c(2, 2, 2),ltr = FALSE,
final.absorb = FALSE, verbose = TRUE)
semi &lt;- c(FALSE, TRUE, FALSE)
initmodel1 = initialize_model(clus = clus,sojourn = "gamma",
M = max(train$N), semi = semi)
fit1 = hhsmmfit(x = train, model = initmodel1, M = max(train$N))
yhat1 &lt;- predict(fit1, test)

</code></pre>

<hr>
<h2 id='predict.hhsmmspec'>prediction of state sequence for hhsmm</h2><span id='topic+predict.hhsmmspec'></span>

<h3>Description</h3>

<p>Predicts the state sequence of a hidden hybrid Markov/semi-Markov model
for a new (test) data of class <code>"hhsmmdata"</code> with an optional prediction of the
residual useful lifetime (RUL) for a left to right model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'hhsmmspec'
predict(object, newdata, method = "viterbi", M = NA, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.hhsmmspec_+3A_object">object</code></td>
<td>
<p>a hidden hybrid Markov/semi-Markov model</p>
</td></tr>
<tr><td><code id="predict.hhsmmspec_+3A_newdata">newdata</code></td>
<td>
<p>a new (test) data of class <code>"hhsmmdata"</code></p>
</td></tr>
<tr><td><code id="predict.hhsmmspec_+3A_method">method</code></td>
<td>
<p>the prediction method with two options:
</p>

<ul>
<li> <p><code>"viterbi"</code> (default) uses the Viterbi algorithm for prediction
</p>
</li>
<li> <p><code>"smoothing"</code> uses the smoothing algorithm for prediction
</p>
</li></ul>
</td></tr>
<tr><td><code id="predict.hhsmmspec_+3A_m">M</code></td>
<td>
<p>maximum duration in states</p>
</td></tr>
<tr><td><code id="predict.hhsmmspec_+3A_...">...</code></td>
<td>
<p>additional parameters of the function <code><a href="#topic+predict.hhsmm">predict.hhsmm</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list containing the following items:
</p>

<ul>
<li> <p><code>x</code> the observation sequence
</p>
</li>
<li> <p><code>s</code> the predicted state sequence
</p>
</li>
<li> <p><code>N</code> the vector of sequence lengths
</p>
</li>
<li> <p><code>p</code> the state probabilities 
</p>
</li>
<li> <p><code>RUL</code> the point predicts of the RUL
</p>
</li>
<li> <p><code>RUL.low</code> the lower bounds for the prediction intervals of the RUL
</p>
</li>
<li> <p><code>RUL.up</code> the upper bounds for the prediction intervals of the RUL
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Morteza Amini, <a href="mailto:morteza.amini@ut.ac.ir">morteza.amini@ut.ac.ir</a>, Afarin Bayat,  <a href="mailto:aftbayat@gmail.com">aftbayat@gmail.com</a>
</p>


<h3>References</h3>

<p>Guedon, Y. (2005). Hidden hybrid Markov/semi-Markov chains.
<em>Computational statistics and Data analysis</em>, 49(3), 663-688.
</p>
<p>OConnell, J., &amp; Hojsgaard, S. (2011). Hidden semi Markov
models for multiple observation sequences: The mhsmm package
for R. <em>Journal of Statistical Software</em>, 39(4), 1-22.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+predict.hhsmm">predict.hhsmm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>J &lt;- 3
initial &lt;- c(1, 0, 0)
semi &lt;- c(FALSE, TRUE, FALSE)
P &lt;- matrix(c(0.8, 0.1, 0.1, 0.5, 0, 0.5, 0.1, 0.2, 0.7), nrow = J, 
byrow = TRUE)
par &lt;- list(mu = list(list(7, 8), list(10, 9, 11), list(12, 14)),
sigma = list(list(3.8, 4.9), list(4.3, 4.2, 5.4), list(4.5, 6.1)),
mix.p = list(c(0.3, 0.7), c(0.2, 0.3, 0.5), c(0.5, 0.5)))
sojourn &lt;- list(shape = c(0, 3, 0), scale = c(0, 10, 0), type = "gamma")
model &lt;- hhsmmspec(init = initial, transition = P, parms.emis = par,
dens.emis = dmixmvnorm, sojourn = sojourn, semi = semi)
train &lt;- simulate(model, nsim = c(10, 8, 8, 18), seed = 1234, remission = rmixmvnorm)
test &lt;-  simulate(model, nsim = c(5, 3, 3, 8), seed = 1234, remission = rmixmvnorm)
clus = initial_cluster(train, nstate = 3, nmix = c(2, 2, 2), ltr = FALSE,
final.absorb = FALSE, verbose = TRUE)
semi &lt;- c(FALSE, TRUE, FALSE)
initmodel1 = initialize_model(clus = clus, sojourn = "gamma", M = max(train$N), semi = semi)
yhat1 &lt;- predict(initmodel1, test)

</code></pre>

<hr>
<h2 id='raddreg'>Random data generation from the Gaussian additive (Markov-switching) model for hhsmm model</h2><span id='topic+raddreg'></span>

<h3>Description</h3>

<p>Generates vectors of covariate and response observations
from the Gaussian additive (Markov-switching) model, using B-Splines in a specified state and using the
parameters of a specified model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>raddreg(j, model, covar, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="raddreg_+3A_j">j</code></td>
<td>
<p>a specified state</p>
</td></tr>
<tr><td><code id="raddreg_+3A_model">model</code></td>
<td>
<p>a <code><a href="#topic+hhsmmspec">hhsmmspec</a></code> model</p>
</td></tr>
<tr><td><code id="raddreg_+3A_covar">covar</code></td>
<td>
<p>either a function which generates the covariate vector or a list containing the following items:
</p>

<ul>
<li> <p><code>mean</code> the mean vector of covariates (to be generated from multivariate normal distribution)
</p>
</li>
<li> <p><code>cov</code> the variance-covariance matrix of covariates (to be generated from multivariate normal distribution)
</p>
</li></ul>
</td></tr>
<tr><td><code id="raddreg_+3A_...">...</code></td>
<td>
<p>additional arguments of the <code>covar</code> function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a random matrix of observations from Gaussian additive (Markov-switching) model,
in which the first columns are associated with the responses
and the last columns are associated with the covariates
</p>


<h3>Author(s)</h3>

<p>Morteza Amini, <a href="mailto:morteza.amini@ut.ac.ir">morteza.amini@ut.ac.ir</a>
</p>


<h3>References</h3>

<p>Langrock, R., Adam, T., Leos-Barajas, V.,
Mews, S., Miller, D. L., and Papastamatiou, Y. P. (2018).
Spline-based nonparametric inference in general state-switching models.
Statistica Neerlandica, 72(3), 179-200.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>J &lt;- 3
initial &lt;- c(1, 0, 0)
semi &lt;- rep(FALSE, 3)
P &lt;- matrix(c(0.5, 0.2, 0.3, 0.2, 0.5, 0.3, 0.1, 0.4, 0.5), nrow = J, 
byrow = TRUE)
par &lt;- list(intercept = list(-21, -83, 33),
coef = list(array(c(1, 8, 52, 27, 38), dim = c(5, 1, 1)),  
array(c(99, 87, 94, 77, 50), dim = c(5, 1, 1)), 
array(c(-1, -8, -40, -22, -28), dim = c(5, 1, 1))),
sigma = list(0.2, 0.4, 0.1))
model &lt;- hhsmmspec(init = initial, transition = P, parms.emis = par,
dens.emis = dnorm_additive_reg, semi = semi)
train &lt;- simulate(model, nsim = 70, seed = 1234, 
remission = raddreg, covar = list(mean = 0, cov = 1))
plot(train$x[, 1] ~ train$x[, 2], col = train$s, pch = 16, 
xlab = "x", ylab = "y")

</code></pre>

<hr>
<h2 id='rmixar'>Random data generation from the mixture of Gaussian linear (Markov-switching) autoregressive models for hhsmm model</h2><span id='topic+rmixar'></span>

<h3>Description</h3>

<p>Generates vectors of observations
from mixture of Gaussian linear (Markov-switching) autoregressive
model in a specified state and using the
parameters of a specified model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rmixar(j, model, x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rmixar_+3A_j">j</code></td>
<td>
<p>a specified state</p>
</td></tr>
<tr><td><code id="rmixar_+3A_model">model</code></td>
<td>
<p>a <code><a href="#topic+hhsmmspec">hhsmmspec</a></code> model</p>
</td></tr>
<tr><td><code id="rmixar_+3A_x">x</code></td>
<td>
<p>the previous x vector as the covariate of the autoregressive model</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a random matrix of observations from mixture of Gaussian linear
(Markov-switching) autoregressive model
</p>


<h3>Author(s)</h3>

<p>Morteza Amini, <a href="mailto:morteza.amini@ut.ac.ir">morteza.amini@ut.ac.ir</a>
</p>

<hr>
<h2 id='rmixlm'>Random data generation from the mixture of Gaussian linear (Markov-switching) models for hhsmm model</h2><span id='topic+rmixlm'></span>

<h3>Description</h3>

<p>Generates vectors of covariate and response observations
from mixture of Gaussian linear (Markov-switching) models in a specified state and using the
parameters of a specified model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rmixlm(j, model, covar, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rmixlm_+3A_j">j</code></td>
<td>
<p>a specified state</p>
</td></tr>
<tr><td><code id="rmixlm_+3A_model">model</code></td>
<td>
<p>a <code><a href="#topic+hhsmmspec">hhsmmspec</a></code> model</p>
</td></tr>
<tr><td><code id="rmixlm_+3A_covar">covar</code></td>
<td>
<p>either a function which generates the covariate vector or a list containing the following items:
</p>

<ul>
<li> <p><code>mean</code> the mean vector of covariates (to be generated from multivariate normal distribution)
</p>
</li>
<li> <p><code>cov</code> the variance-covariance matrix of covariates (to be generated from multivariate normal distribution)
</p>
</li></ul>
</td></tr>
<tr><td><code id="rmixlm_+3A_...">...</code></td>
<td>
<p>additional arguments of the <code>covar</code> function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a random matrix of observations from mixture of Gaussian linear (Markov-switching) models,
in which the first columns are associated with the responses
and the last columns are associated with the covariates
</p>


<h3>Author(s)</h3>

<p>Morteza Amini, <a href="mailto:morteza.amini@ut.ac.ir">morteza.amini@ut.ac.ir</a>
</p>


<h3>References</h3>

<p>Kim, C. J., Piger, J. and Startz, R. (2008). Estimation of Markov
regime-switching regression models with endogenous switching.
Journal of Econometrics, 143(2), 263-273.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>J &lt;- 3
initial &lt;- c(1, 0, 0)
semi &lt;- rep(FALSE, 3)
P &lt;- matrix(c(0.5, 0.2, 0.3, 0.2, 0.5, 0.3, 0.1, 0.4, 0.5), nrow = J, 
byrow = TRUE)
par &lt;- list(intercept = list(3, list(-10, -1), 14),
coefficient = list(-1, list(1, 5), -7),
csigma = list(1.2, list(2.3, 3.4), 1.1),
mix.p = list(1, c(0.4, 0.6), 1))
model &lt;- hhsmmspec(init = initial, transition = P, parms.emis = par,
dens.emis = dmixlm, semi = semi)

#use the covar as the list of mean and 
#variance of the normal distribution 

train1 &lt;- simulate(model, nsim = c(20, 30, 42, 50), seed = 1234, 
remission = rmixlm, covar = list(mean = 0, cov = 1))
plot(train1$x[,1] ~ train1$x[,2], col = train1$s, pch = 16, 
xlab = "x", ylab = "y")

#use the covar as the runif function 
#to generate one covariate from standard uniform distribution 

train2 &lt;- simulate(model, nsim = c(20, 30, 42, 50), seed = 1234, 
remission = rmixlm, covar = runif, 1)
plot(train2$x[,1] ~ train2$x[,2], col = train2$s, pch = 16, 
xlab = "x", ylab = "y")

</code></pre>

<hr>
<h2 id='rmixmvnorm'>Random data generation from the mixture of multivariate normals for hhsmm model</h2><span id='topic+rmixmvnorm'></span>

<h3>Description</h3>

<p>Generates a vector of observations from mixture multivariate
normal distribution in a specified state and using the
parameters of a specified model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rmixmvnorm(j, model)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rmixmvnorm_+3A_j">j</code></td>
<td>
<p>a specified state</p>
</td></tr>
<tr><td><code id="rmixmvnorm_+3A_model">model</code></td>
<td>
<p>a <code><a href="#topic+hhsmmspec">hhsmmspec</a></code> model</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a random vector of observations from mixture of multivariate
normal distributions
</p>


<h3>Author(s)</h3>

<p>Morteza Amini, <a href="mailto:morteza.amini@ut.ac.ir">morteza.amini@ut.ac.ir</a>, Afarin Bayat,  <a href="mailto:aftbayat@gmail.com">aftbayat@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>J &lt;- 3
initial &lt;- c(1, 0, 0)
semi &lt;- c(FALSE, TRUE, FALSE)
P &lt;- matrix(c(0.8, 0.1, 0.1, 0.5, 0, 0.5, 0.1, 0.2, 0.7), nrow = J, 
byrow = TRUE)
par &lt;- list(mu = list(list(7, 8), list(10, 9, 11), list(12, 14)),
sigma = list(list(3.8, 4.9), list(4.3, 4.2, 5.4), list(4.5, 6.1)),
mix.p = list(c(0.3, 0.7), c(0.2, 0.3, 0.5), c(0.5, 0.5)))
sojourn &lt;- list(shape = c(0, 3, 0), scale = c(0, 10, 0), type = "gamma")
model &lt;- hhsmmspec(init = initial, transition = P, parms.emis = par,
dens.emis = dmixmvnorm, sojourn = sojourn, semi = semi)
x = rmixmvnorm(1, model)

</code></pre>

<hr>
<h2 id='rmultinomial.hhsmm'>Random data generation from the multinomial emission distribution for hhsmm model</h2><span id='topic+rmultinomial.hhsmm'></span>

<h3>Description</h3>

<p>Generates a vector of observations from multinomial emission distribution
in a specified state and using the parameters of a specified model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rmultinomial.hhsmm(j, model)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rmultinomial.hhsmm_+3A_j">j</code></td>
<td>
<p>a specified state</p>
</td></tr>
<tr><td><code id="rmultinomial.hhsmm_+3A_model">model</code></td>
<td>
<p>a <code><a href="#topic+hhsmmspec">hhsmmspec</a></code> model</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a random vector of observations from multinomial emission distribution
</p>


<h3>Author(s)</h3>

<p>Morteza Amini, <a href="mailto:morteza.amini@ut.ac.ir">morteza.amini@ut.ac.ir</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>J &lt;- 2
initial &lt;- c(1, 0)
semi &lt;- rep(TRUE, 2)
P &lt;- matrix(c(0, 1, 1, 0), 
nrow = J, byrow = TRUE)
par &lt;- list(prob = list(c(0.6,  0.2, 0.2),
                           c(0.2, 0.6,  0.2)))
sojourn &lt;- list(shape = c(1, 3), scale = c(2, 10), type = "gamma")
model &lt;- hhsmmspec(init = initial, transition = P, parms.emis = par,
dens.emis = dmultinomial.hhsmm, remission = rmultinomial.hhsmm,
 mstep = mstep.multinomial,sojourn = sojourn, semi = semi)
train &lt;- simulate(model, nsim = c(20, 30, 42, 50), seed = 1234, 
remission = rmultinomial.hhsmm)
plot(train)


</code></pre>

<hr>
<h2 id='score'>the score of new observations</h2><span id='topic+score'></span>

<h3>Description</h3>

<p>computes the score (log-likelihood) of new observations using a trained model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>score(xnew, fit)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="score_+3A_xnew">xnew</code></td>
<td>
<p>a new single observation, observation matrix
or a list of the class <code><a href="#topic+hhsmmdata">hhsmmdata</a></code> containing $x and $N elements</p>
</td></tr>
<tr><td><code id="score_+3A_fit">fit</code></td>
<td>
<p>a fitted model using the <code><a href="#topic+hhsmmfit">hhsmmfit</a></code> function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the vector of scores (log-likelihood) of <code>xnew</code>
</p>


<h3>Author(s)</h3>

<p>Morteza Amini, <a href="mailto:morteza.amini@ut.ac.ir">morteza.amini@ut.ac.ir</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>J &lt;- 3
initial &lt;- c(1, 0, 0)
semi &lt;- c(FALSE, TRUE, FALSE)
P &lt;- matrix(c(0.8, 0.1, 0.1, 0.5, 0, 0.5, 0.1, 0.2, 0.7), nrow = J, 
byrow = TRUE)
par &lt;- list(mu = list(list(7, 8), list(10, 9, 11), list(12, 14)),
sigma = list(list(3.8, 4.9), list(4.3, 4.2, 5.4), list(4.5, 6.1)),
mix.p = list(c(0.3, 0.7), c(0.2, 0.3, 0.5), c(0.5, 0.5)))
sojourn &lt;- list(shape = c(0, 3, 0), scale = c(0, 10, 0), type = "gamma")
model &lt;- hhsmmspec(init = initial, transition = P, parms.emis = par,
dens.emis = dmixmvnorm, sojourn = sojourn, semi = semi)
train &lt;- simulate(model, nsim = c(10, 8, 8, 18), seed = 1234, 
remission = rmixmvnorm)
test &lt;- simulate(model, nsim = c(5, 4, 6, 7), seed = 1234, 
remission = rmixmvnorm)
clus = initial_cluster(train, nstate = 3, nmix = c(2, 2, 2), ltr = FALSE,
final.absorb = FALSE, verbose = TRUE)
semi &lt;- c(FALSE, TRUE, FALSE)
initmodel1 = initialize_model(clus = clus, sojourn = "gamma",
M = max(train$N), semi = semi)
fit1 = hhsmmfit(x = train, model = initmodel1, M = max(train$N))
score(test, fit1)

</code></pre>

<hr>
<h2 id='simulate.hhsmmspec'>Simulation of data from hhsmm model</h2><span id='topic+simulate.hhsmmspec'></span>

<h3>Description</h3>

<p>Simulates a data set of class <code>"hhsmmdata"</code> using a <code><a href="#topic+hhsmmspec">hhsmmspec</a></code> model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'hhsmmspec'
simulate(
  object,
  nsim,
  seed = NULL,
  remission = rmixmvnorm,
  ...,
  emission.control = list(autoregress = FALSE, lags = 1, start = list(mean = NULL, cov =
    NULL))
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simulate.hhsmmspec_+3A_object">object</code></td>
<td>
<p>a <code><a href="#topic+hhsmmspec">hhsmmspec</a></code> model</p>
</td></tr>
<tr><td><code id="simulate.hhsmmspec_+3A_nsim">nsim</code></td>
<td>
<p>a vector of sequence lengths (might be of length 1)</p>
</td></tr>
<tr><td><code id="simulate.hhsmmspec_+3A_seed">seed</code></td>
<td>
<p>a random seed to be set</p>
</td></tr>
<tr><td><code id="simulate.hhsmmspec_+3A_remission">remission</code></td>
<td>
<p>a random emission generation function (default = <code><a href="#topic+rmixmvnorm">rmixmvnorm</a></code>)</p>
</td></tr>
<tr><td><code id="simulate.hhsmmspec_+3A_...">...</code></td>
<td>
<p>additional parameters of the <code>remission</code> function</p>
</td></tr>
<tr><td><code id="simulate.hhsmmspec_+3A_emission.control">emission.control</code></td>
<td>
<p>a list of additional control parameters including the
following items:
</p>

<ul>
<li> <p><code>autoregress</code> logical. if TRUE the auto-regressive data generation will be considered with 
<code>rmixar</code> function
</p>
</li>
<li> <p><code>lags</code> a positive integer which is the number of lags to be considered for the 
auto-regressive sequence
</p>
</li>
<li> <p><code>start</code> a list containing the items <code>mean</code> which is the mean vector 
and <code>cov</code> which is the covarince matrix for starting value of the auto-regressive 
sequence (if <code>autoregress == TRUE</code>). 
If <code>start</code> is not specified the zero mean vector and the identity matrix 
will be considered as <code>mean</code> and <code>cov</code>, respectively.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of class <code>"hsmm.data"</code> containing the following items:
</p>

<ul>
<li> <p><code>s</code> the vector of states
</p>
</li>
<li> <p><code>x</code> observation matrix
</p>
</li>
<li><p><code>N</code> vector of sequence lengths
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Morteza Amini, <a href="mailto:morteza.amini@ut.ac.ir">morteza.amini@ut.ac.ir</a>, Afarin Bayat, <a href="mailto:aftbayat@gmail.com">aftbayat@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>J &lt;- 3
initial &lt;- c(1, 0, 0)
semi &lt;- c(FALSE, TRUE, FALSE)
P &lt;- matrix(c(0.8, 0.1, 0.1, 0.5, 0, 0.5, 0.1, 0.2, 0.7), nrow = J, 
byrow = TRUE)
par &lt;- list(mu = list(list(7, 8), list(10, 9, 11), list(12, 14)),
sigma = list(list(3.8, 4.9), list(4.3, 4.2, 5.4), list(4.5, 6.1)),
mix.p = list(c(0.3, 0.7),c(0.2, 0.3, 0.5), c(0.5, 0.5)))
sojourn &lt;- list(shape = c(0, 3, 0), scale = c(0, 8, 0), type = "gamma")
model &lt;- hhsmmspec(init = initial, transition = P, parms.emis = par,
dens.emis = dmixmvnorm, sojourn = sojourn, semi = semi)
train &lt;- simulate(model, nsim = c(8, 5, 5, 10), seed = 1234, 
remission = rmixmvnorm)

</code></pre>

<hr>
<h2 id='train_test_split'>Splitting the data sets to train and test</h2><span id='topic+train_test_split'></span>

<h3>Description</h3>

<p>A function to split the train data of class <code>"hhsmmdata"</code>
to train and test subsets with an option to right trim the sequences
</p>


<h3>Usage</h3>

<pre><code class='language-R'>train_test_split(train, train.ratio = 0.7, trim = FALSE, trim.ratio = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="train_test_split_+3A_train">train</code></td>
<td>
<p>the train data of class <code>"hhsmmdata"</code></p>
</td></tr>
<tr><td><code id="train_test_split_+3A_train.ratio">train.ratio</code></td>
<td>
<p>a number in (0,1] which determines the ratio of the train subset. It can be
equal to 1, if we need the test set to be equal to the train set and we only
need to right trim the sequences</p>
</td></tr>
<tr><td><code id="train_test_split_+3A_trim">trim</code></td>
<td>
<p>logical. if TRUE the sequences will be right trimmed with random lengths</p>
</td></tr>
<tr><td><code id="train_test_split_+3A_trim.ratio">trim.ratio</code></td>
<td>
<p>a vector of trim ratios with a length equal to that of <code>train$N</code>,
or a single trim ratio for all sequences. If it is <code>NULL</code>, then random trim
ratios will be used</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function splits the sample to train and test samples and
trims the test sample from right, in order to provide a sample for examination
of the prediction tools.
In reliability applications, the hhsmm models are often left-to-right
and the modeling aims to predict the future states. In such cases, the
test sets are right trimmed and the prediction aims to predict the
residual useful lifetime (RUL) of a new sequence.
</p>


<h3>Value</h3>

<p>a list containing:
</p>

<ul>
<li><p><code>train</code> the randomly selected subset of train data of class <code>"hhsmmdata"</code>
</p>
</li>
<li><p><code>test</code> the randomly selected subset of test data of class <code>"hhsmmdata"</code>
</p>
</li>
<li><p><code>trimmed</code> right trimmed test subset, if <code>trim</code>=TRUE, with trim ratios equal to <code>trim.ratio</code> 
</p>
</li>
<li><p><code>trimmed.count</code> the number of right trimmed individuals in each sequence of the test subset, if <code>trim</code>=TRUE 
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Morteza Amini, <a href="mailto:morteza.amini@ut.ac.ir">morteza.amini@ut.ac.ir</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(CMAPSS)
tt = train_test_split(CMAPSS$train, train.ratio = 0.7, trim = TRUE)


</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
