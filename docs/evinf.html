<!DOCTYPE html><html><head><title>Help for package evinf</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {evinf}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#coefficient_extractor'><p>Bootstrap coefficient extractor</p></a></li>
<li><a href='#coefficient_extractor.evinb'><p>Bootstrap coefficient extractor</p></a></li>
<li><a href='#coefficient_extractor.evzinb'><p>Bootstrap coefficient extractor</p></a></li>
<li><a href='#coefficient_extractor.nbboot'><p>Bootstrap coefficient extractor</p></a></li>
<li><a href='#coefficient_extractor.zinbboot'><p>Bootstrap coefficient extractor</p></a></li>
<li><a href='#compare_models'><p>Function to compare evzinb or evinb models with zinb and nb models</p></a></li>
<li><a href='#evinb'><p>Running an extreme value inflated negative binomial model with bootstrapping</p></a></li>
<li><a href='#evinf-package'><p>evinf: Inference with Extreme Value Inflated Count Data</p></a></li>
<li><a href='#evzinb'><p>Running an extreme value and zero inflated negative binomial model with bootstrapping</p></a></li>
<li><a href='#genevzinb'><p>Simulated data from the EVZBINB distribution</p></a></li>
<li><a href='#genevzinb2'><p>Simulated data from the EVZBINB distribution</p></a></li>
<li><a href='#glance.evinb'><p>EVZINB and EVINB glance functions</p></a></li>
<li><a href='#glance.evzinb'><p>EVZINB and EVINB glance functions</p></a></li>
<li><a href='#glance.nbboot'><p>zinbboot and nboot glance functions</p></a></li>
<li><a href='#glance.zinbboot'><p>zinbboot and nboot glance functions</p></a></li>
<li><a href='#gm_evzinb'><p>A goodness-of-fit gof tibble for GOF metrics when using modelsummary</p></a></li>
<li><a href='#hks'><p>Replication data for Hultman, Kathman, and Shannon (2013) United Nations Peacekeeping and Civilian Protection in Civil War</p></a></li>
<li><a href='#lr_test'><p>Likelihood ratio test for individual variables of evzinb</p></a></li>
<li><a href='#oob_evaluation'><p>Out of bag predictive performance of EVZINB and EVINB models</p></a></li>
<li><a href='#predict.evinb'><p>Predictions from evinb object</p></a></li>
<li><a href='#predict.evzinb'><p>Predictions from evzinb object</p></a></li>
<li><a href='#predict.zinbboot'><p>Prediction for zinbboot</p></a></li>
<li><a href='#print.evinb'><p>EVINB print function</p></a></li>
<li><a href='#print.evzinb'><p>EVZINB print function</p></a></li>
<li><a href='#print.evzinbcomp'><p>Compare_models print function</p></a></li>
<li><a href='#revinb_fit'><p>Random draws from a fitted evinb model</p></a></li>
<li><a href='#revzinb_fit'><p>Random draws from a fitted evzinb model</p></a></li>
<li><a href='#summary.evinb'><p>EVINB summary function</p></a></li>
<li><a href='#summary.evzinb'><p>EVZINB summary function</p></a></li>
<li><a href='#tidy.evinb'><p>EVINB tidy function</p></a></li>
<li><a href='#tidy.evzinb'><p>EVZINB tidy function</p></a></li>
<li><a href='#tidy.nbboot'><p>Tidy function for nbboot</p></a></li>
<li><a href='#tidy.zinbboot'><p>Tidy function for zinbboot</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Inference with Extreme Value Inflated Count Data</td>
</tr>
<tr>
<td>Version:</td>
<td>0.8.8</td>
</tr>
<tr>
<td>Description:</td>
<td>Allows users to model and draw inferences from extreme value inflated count data, and to evaluate these models and compare to non extreme-value inflated counterparts. The package is built to be compatible with standard presentation tools such as 'broom', 'tidy', and 'modelsummary'.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Imports:</td>
<td>dplyr, Rcpp, RcppArmadillo, foreach, doParallel, magrittr,
doRNG, tibble, mistr, tidyr, purrr, MASS, pscl, MLmetrics,
Rdpack, stringi, stringr, rlang, methods, stats, utils,
parallel</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>RdMacros:</td>
<td>Rdpack</td>
</tr>
<tr>
<td>Depends:</td>
<td>generics, R (&ge; 2.10)</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/Doktorandahl/evinf">https://github.com/Doktorandahl/evinf</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/Doktorandahl/evinf/issues">https://github.com/Doktorandahl/evinf/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-02-22 22:14:49 UTC; david</td>
</tr>
<tr>
<td>Author:</td>
<td>David Randahl [cre, aut],
  Johan Vegelius [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>David Randahl &lt;david.randahl@pcr.uu.se&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-02-23 09:40:11 UTC</td>
</tr>
</table>
<hr>
<h2 id='coefficient_extractor'>Bootstrap coefficient extractor</h2><span id='topic+coefficient_extractor'></span>

<h3>Description</h3>

<p>Bootstrap coefficient extractor
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coefficient_extractor(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coefficient_extractor_+3A_object">object</code></td>
<td>
<p>a fitted model with bootstraps of class evzinb, evinb, nbboot, or zinbboot</p>
</td></tr>
<tr><td><code id="coefficient_extractor_+3A_...">...</code></td>
<td>
<p>Component to be extracted (not for nbboot). Alternatives are 'nb','zi','evinf','pareto', and 'all'</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble with coefficient values, one row per bootstrap and component
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(genevzinb2)
model &lt;- evzinb(y~x1+x2+x3,data=genevzinb2, n_bootstraps = 10, multicore = TRUE, ncores = 2)
coefficient_extractor(model, component = 'all')

</code></pre>

<hr>
<h2 id='coefficient_extractor.evinb'>Bootstrap coefficient extractor</h2><span id='topic+coefficient_extractor.evinb'></span>

<h3>Description</h3>

<p>Bootstrap coefficient extractor
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'evinb'
coefficient_extractor(
  object,
  component = c("nb", "evinf", "pareto", "all"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coefficient_extractor.evinb_+3A_object">object</code></td>
<td>
<p>A fitted evinb model with bootstraps</p>
</td></tr>
<tr><td><code id="coefficient_extractor.evinb_+3A_component">component</code></td>
<td>
<p>Which component should be extracted</p>
</td></tr>
<tr><td><code id="coefficient_extractor.evinb_+3A_...">...</code></td>
<td>
<p>Not in use</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble with coefficient values, one row per bootstrap and component
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(genevzinb2)
model &lt;- evinb(y~x1+x2+x3,data=genevzinb2, n_bootstraps = 10, multicore = TRUE, ncores = 2)
coefficient_extractor(model, component = 'all')

</code></pre>

<hr>
<h2 id='coefficient_extractor.evzinb'>Bootstrap coefficient extractor</h2><span id='topic+coefficient_extractor.evzinb'></span>

<h3>Description</h3>

<p>Bootstrap coefficient extractor
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'evzinb'
coefficient_extractor(
  object,
  component = c("nb", "zi", "evinf", "pareto", "all"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coefficient_extractor.evzinb_+3A_object">object</code></td>
<td>
<p>A fitted evzinb model with bootstraps</p>
</td></tr>
<tr><td><code id="coefficient_extractor.evzinb_+3A_component">component</code></td>
<td>
<p>Which component should be extracted</p>
</td></tr>
<tr><td><code id="coefficient_extractor.evzinb_+3A_...">...</code></td>
<td>
<p>Not in use</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble with coefficient values, one row per bootstrap and component
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(genevzinb2)
model &lt;- evzinb(y~x1+x2+x3,data=genevzinb2, n_bootstraps = 10, multicore = TRUE, ncores = 2)
coefficient_extractor(model, component = 'all')

</code></pre>

<hr>
<h2 id='coefficient_extractor.nbboot'>Bootstrap coefficient extractor</h2><span id='topic+coefficient_extractor.nbboot'></span>

<h3>Description</h3>

<p>Bootstrap coefficient extractor
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'nbboot'
coefficient_extractor(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coefficient_extractor.nbboot_+3A_object">object</code></td>
<td>
<p>A fitted nbboot model with bootstraps</p>
</td></tr>
<tr><td><code id="coefficient_extractor.nbboot_+3A_...">...</code></td>
<td>
<p>Not in use</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble with coefficient value, one row per bootstrap
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(genevzinb2)
model &lt;- evzinb(y~x1+x2+x3,data=genevzinb2, n_bootstraps = 10, multicore = TRUE, ncores = 2)
zinb_comp &lt;- compare_models(model)
coefficient_extractor(zinb_comp$nb)

</code></pre>

<hr>
<h2 id='coefficient_extractor.zinbboot'>Bootstrap coefficient extractor</h2><span id='topic+coefficient_extractor.zinbboot'></span>

<h3>Description</h3>

<p>Bootstrap coefficient extractor
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'zinbboot'
coefficient_extractor(object, component = c("nb", "zi", "all"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coefficient_extractor.zinbboot_+3A_object">object</code></td>
<td>
<p>A fitted evinb model with bootstraps</p>
</td></tr>
<tr><td><code id="coefficient_extractor.zinbboot_+3A_component">component</code></td>
<td>
<p>Which component should be extracted</p>
</td></tr>
<tr><td><code id="coefficient_extractor.zinbboot_+3A_...">...</code></td>
<td>
<p>Not in use</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble with coefficient values, one row per bootstrap and component
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(genevzinb2)
model &lt;- evzinb(y~x1+x2+x3,data=genevzinb2, n_bootstraps=10)
zinb_comp &lt;- compare_models(model)
coefficient_extractor(zinb_comp$zinb)

</code></pre>

<hr>
<h2 id='compare_models'>Function to compare evzinb or evinb models with zinb and nb models</h2><span id='topic+compare_models'></span>

<h3>Description</h3>

<p>Function to compare evzinb or evinb models with zinb and nb models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compare_models(
  object,
  nb_comparison = TRUE,
  zinb_comparison = TRUE,
  winsorize = FALSE,
  razorize = FALSE,
  cutoff_value = 10,
  init_theta = NULL,
  multicore = FALSE,
  ncores = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compare_models_+3A_object">object</code></td>
<td>
<p>A fitted evzinb or evinb model object</p>
</td></tr>
<tr><td><code id="compare_models_+3A_nb_comparison">nb_comparison</code></td>
<td>
<p>Should comparison be made with a negative binomial model?</p>
</td></tr>
<tr><td><code id="compare_models_+3A_zinb_comparison">zinb_comparison</code></td>
<td>
<p>Should comparions be made with the zinb model?</p>
</td></tr>
<tr><td><code id="compare_models_+3A_winsorize">winsorize</code></td>
<td>
<p>Should winsorizing be done in the comparisons?</p>
</td></tr>
<tr><td><code id="compare_models_+3A_razorize">razorize</code></td>
<td>
<p>Should razorizing (trimming) be done in the comparisons?</p>
</td></tr>
<tr><td><code id="compare_models_+3A_cutoff_value">cutoff_value</code></td>
<td>
<p>Integer: Which observation should be used as a basis for winsorizing/razorising. E.g. 10 means that everything larger than the 10th observation will be winsorized/razorised</p>
</td></tr>
<tr><td><code id="compare_models_+3A_init_theta">init_theta</code></td>
<td>
<p>Optional initial value for theta in the NB specification</p>
</td></tr>
<tr><td><code id="compare_models_+3A_multicore">multicore</code></td>
<td>
<p>Logical: should multiple cores be used</p>
</td></tr>
<tr><td><code id="compare_models_+3A_ncores">ncores</code></td>
<td>
<p>Number of cores if multicore is used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the original model as the first object and compared models as the following objects
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(genevzinb2)
model &lt;- evzinb(y~x1+x2+x3,data=genevzinb2, n_bootstraps = 10, multicore = TRUE, ncores = 2)
compare_models(model)

</code></pre>

<hr>
<h2 id='evinb'>Running an extreme value inflated negative binomial model with bootstrapping</h2><span id='topic+evinb'></span>

<h3>Description</h3>

<p>Running an extreme value inflated negative binomial model with bootstrapping
</p>


<h3>Usage</h3>

<pre><code class='language-R'>evinb(
  formula_nb,
  formula_evi = NULL,
  formula_pareto = NULL,
  data,
  bootstrap = TRUE,
  n_bootstraps = 100,
  multicore = FALSE,
  ncores = NULL,
  block = NULL,
  boot_seed = NULL,
  max.diff.par = 0.01,
  max.no.em.steps = 500,
  max.no.em.steps.warmup = 5,
  c.lim = c(50, 1000),
  max.upd.par.pl.multinomial = 0.5,
  max.upd.par.nb = 0.5,
  max.upd.par.pl = 0.5,
  no.m.bfgs.steps.multinomial = 3,
  no.m.bfgs.steps.nb = 3,
  no.m.bfgs.steps.pl = 3,
  pdf.pl.type = "approx",
  eta.int = c(-1, 1),
  init.Beta.multinom.PL = NULL,
  init.Beta.NB = NULL,
  init.Beta.PL = NULL,
  init.Alpha.NB = 0.01,
  init.C = 200,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="evinb_+3A_formula_nb">formula_nb</code></td>
<td>
<p>Formula for the negative binomial (count) component of the model</p>
</td></tr>
<tr><td><code id="evinb_+3A_formula_evi">formula_evi</code></td>
<td>
<p>Formula for the extreme-value inflation component of the model. If NULL taken as the same formula as nb</p>
</td></tr>
<tr><td><code id="evinb_+3A_formula_pareto">formula_pareto</code></td>
<td>
<p>Formula for the pareto (extreme value) component of the model. If NULL taken as the same formula as nb</p>
</td></tr>
<tr><td><code id="evinb_+3A_data">data</code></td>
<td>
<p>Data to run the model on</p>
</td></tr>
<tr><td><code id="evinb_+3A_bootstrap">bootstrap</code></td>
<td>
<p>Should bootstrapping be performed. Needed to obtain standard errors and p-values</p>
</td></tr>
<tr><td><code id="evinb_+3A_n_bootstraps">n_bootstraps</code></td>
<td>
<p>Number of bootstraps to run. For use of bootstrapped p-values, at least 1,000 bootstraps are recommended. For approximate p-values, a lower number can be sufficient</p>
</td></tr>
<tr><td><code id="evinb_+3A_multicore">multicore</code></td>
<td>
<p>Should multiple cores be used?</p>
</td></tr>
<tr><td><code id="evinb_+3A_ncores">ncores</code></td>
<td>
<p>Number of cores if multicore is used. Default (NULL) is one less than the available number of cores</p>
</td></tr>
<tr><td><code id="evinb_+3A_block">block</code></td>
<td>
<p>Optional string indicating a case-identifier variable when using block bootstrapping</p>
</td></tr>
<tr><td><code id="evinb_+3A_boot_seed">boot_seed</code></td>
<td>
<p>Optional bootstrap seed to ensure reproducible results.</p>
</td></tr>
<tr><td><code id="evinb_+3A_max.diff.par">max.diff.par</code></td>
<td>
<p>Tolerance for EM algorithm. Will be considered to have converged if the maximum absolute difference in the parameter estimates are lower than this value</p>
</td></tr>
<tr><td><code id="evinb_+3A_max.no.em.steps">max.no.em.steps</code></td>
<td>
<p>Maximum number of EM steps to run. Will be considered to not have converged if this number is reached and convergence is not reached</p>
</td></tr>
<tr><td><code id="evinb_+3A_max.no.em.steps.warmup">max.no.em.steps.warmup</code></td>
<td>
<p>Number of EM steps in the warmup rounds</p>
</td></tr>
<tr><td><code id="evinb_+3A_c.lim">c.lim</code></td>
<td>
<p>Integer range defining the possible values of C</p>
</td></tr>
<tr><td><code id="evinb_+3A_max.upd.par.pl.multinomial">max.upd.par.pl.multinomial</code></td>
<td>
<p>Maximum parameter change step size in the extreme value inflation component</p>
</td></tr>
<tr><td><code id="evinb_+3A_max.upd.par.nb">max.upd.par.nb</code></td>
<td>
<p>Maximum parameter change step size in the count component</p>
</td></tr>
<tr><td><code id="evinb_+3A_max.upd.par.pl">max.upd.par.pl</code></td>
<td>
<p>Maximum parameter change step size in the pareto component</p>
</td></tr>
<tr><td><code id="evinb_+3A_no.m.bfgs.steps.multinomial">no.m.bfgs.steps.multinomial</code></td>
<td>
<p>Number of BFGS steps for the multinomial model</p>
</td></tr>
<tr><td><code id="evinb_+3A_no.m.bfgs.steps.nb">no.m.bfgs.steps.nb</code></td>
<td>
<p>Number of BFGS steps for the negative binomial model</p>
</td></tr>
<tr><td><code id="evinb_+3A_no.m.bfgs.steps.pl">no.m.bfgs.steps.pl</code></td>
<td>
<p>Number of BFGS steps for the pareto model</p>
</td></tr>
<tr><td><code id="evinb_+3A_pdf.pl.type">pdf.pl.type</code></td>
<td>
<p>Probability density function type for the pareto component. Either 'approx' or 'exact'. 'approx' is adviced in most cases</p>
</td></tr>
<tr><td><code id="evinb_+3A_eta.int">eta.int</code></td>
<td>
<p>Initial values for eta</p>
</td></tr>
<tr><td><code id="evinb_+3A_init.beta.multinom.pl">init.Beta.multinom.PL</code></td>
<td>
<p>Initial values for beta parameters in the extreme value inflation component. Vector of same length as number of parameters in the extreme value inflation component or NULL (which gives starting values of 0)</p>
</td></tr>
<tr><td><code id="evinb_+3A_init.beta.nb">init.Beta.NB</code></td>
<td>
<p>Initial values for beta parameters in the count component. Vector of same length as number of parameters in the count component or NULL (which gives starting values of 0)</p>
</td></tr>
<tr><td><code id="evinb_+3A_init.beta.pl">init.Beta.PL</code></td>
<td>
<p>Initial values for beta parameters in the pareto component. Vector of same length as number of parameters in the pareto component or NULL (which gives starting values of 0)</p>
</td></tr>
<tr><td><code id="evinb_+3A_init.alpha.nb">init.Alpha.NB</code></td>
<td>
<p>Initial value of Alpha NB, integer or NULL (giving a starting value of 0)</p>
</td></tr>
<tr><td><code id="evinb_+3A_init.c">init.C</code></td>
<td>
<p>Initial value of C. Integer which should be within the C_lim range.</p>
</td></tr>
<tr><td><code id="evinb_+3A_verbose">verbose</code></td>
<td>
<p>Should progress be printed for the first run of evinb</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class 'evinb'
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(genevzinb2)
model &lt;- evinb(y~x1+x2+x3,data=genevzinb2, n_bootstraps = 10)

</code></pre>

<hr>
<h2 id='evinf-package'>evinf: Inference with Extreme Value Inflated Count Data</h2><span id='topic+evinf'></span><span id='topic+evinf-package'></span>

<h3>Description</h3>

<p>Allows users to model and draw inferences from extreme value inflated count data, and to evaluate these models and compare to non extreme-value inflated counterparts. The package is built to be compatible with standard presentation tools such as 'broom', 'tidy', and 'modelsummary'.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: David Randahl <a href="mailto:david.randahl@pcr.uu.se">david.randahl@pcr.uu.se</a>
</p>
<p>Authors:
</p>

<ul>
<li><p> Johan Vegelius
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/Doktorandahl/evinf">https://github.com/Doktorandahl/evinf</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/Doktorandahl/evinf/issues">https://github.com/Doktorandahl/evinf/issues</a>
</p>
</li></ul>


<hr>
<h2 id='evzinb'>Running an extreme value and zero inflated negative binomial model with bootstrapping</h2><span id='topic+evzinb'></span>

<h3>Description</h3>

<p>Running an extreme value and zero inflated negative binomial model with bootstrapping
</p>


<h3>Usage</h3>

<pre><code class='language-R'>evzinb(
  formula_nb,
  formula_zi = NULL,
  formula_evi = NULL,
  formula_pareto = NULL,
  data,
  bootstrap = TRUE,
  n_bootstraps = 100,
  multicore = FALSE,
  ncores = NULL,
  block = NULL,
  boot_seed = NULL,
  max.diff.par = 0.01,
  max.no.em.steps = 500,
  max.no.em.steps.warmup = 5,
  c.lim = c(50, 1000),
  max.upd.par.zc.multinomial = 0.5,
  max.upd.par.pl.multinomial = 0.5,
  max.upd.par.nb = 0.5,
  max.upd.par.pl = 0.5,
  no.m.bfgs.steps.multinomial = 3,
  no.m.bfgs.steps.nb = 3,
  no.m.bfgs.steps.pl = 3,
  pdf.pl.type = "approx",
  eta.int = c(-1, 1),
  init.Beta.multinom.ZC = NULL,
  init.Beta.multinom.PL = NULL,
  init.Beta.NB = NULL,
  init.Beta.PL = NULL,
  init.Alpha.NB = 0.01,
  init.C = 200,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="evzinb_+3A_formula_nb">formula_nb</code></td>
<td>
<p>Formula for the negative binomial (count) component of the model</p>
</td></tr>
<tr><td><code id="evzinb_+3A_formula_zi">formula_zi</code></td>
<td>
<p>Formula for the zero-inflation component of the model. If NULL taken as the same formula as nb</p>
</td></tr>
<tr><td><code id="evzinb_+3A_formula_evi">formula_evi</code></td>
<td>
<p>Formula for the extreme-value inflation component of the model. If NULL taken as the same formula as nb</p>
</td></tr>
<tr><td><code id="evzinb_+3A_formula_pareto">formula_pareto</code></td>
<td>
<p>Formula for the pareto (extreme value) component of the model. If NULL taken as the same formula as nb</p>
</td></tr>
<tr><td><code id="evzinb_+3A_data">data</code></td>
<td>
<p>data to run the model on</p>
</td></tr>
<tr><td><code id="evzinb_+3A_bootstrap">bootstrap</code></td>
<td>
<p>Should bootstrapping be performed. Needed to obtain standard errors and p-values</p>
</td></tr>
<tr><td><code id="evzinb_+3A_n_bootstraps">n_bootstraps</code></td>
<td>
<p>Number of bootstraps to run. For use of bootstrapped p-values, at least 1,000 bootstraps are recommended. For approximate p-values, a lower number can be sufficient</p>
</td></tr>
<tr><td><code id="evzinb_+3A_multicore">multicore</code></td>
<td>
<p>Should multiple cores be used?</p>
</td></tr>
<tr><td><code id="evzinb_+3A_ncores">ncores</code></td>
<td>
<p>Number of cores if multicore is used. Default (NULL) is one less than the available number of cores</p>
</td></tr>
<tr><td><code id="evzinb_+3A_block">block</code></td>
<td>
<p>Optional string indicating a case-identifier variable when using block bootstrapping</p>
</td></tr>
<tr><td><code id="evzinb_+3A_boot_seed">boot_seed</code></td>
<td>
<p>Optional bootstrap seed to ensure reproducible results.</p>
</td></tr>
<tr><td><code id="evzinb_+3A_max.diff.par">max.diff.par</code></td>
<td>
<p>Tolerance for EM algorithm. Will be considered to have converged if the maximum absolute difference in the parameter estimates are lower than this value</p>
</td></tr>
<tr><td><code id="evzinb_+3A_max.no.em.steps">max.no.em.steps</code></td>
<td>
<p>Maximum number of EM steps to run. Will be considered to not have converged if this number is reached and convergence is not reached</p>
</td></tr>
<tr><td><code id="evzinb_+3A_max.no.em.steps.warmup">max.no.em.steps.warmup</code></td>
<td>
<p>Number of EM steps in the warmup rounds</p>
</td></tr>
<tr><td><code id="evzinb_+3A_c.lim">c.lim</code></td>
<td>
<p>Integer range defining the possible values of C</p>
</td></tr>
<tr><td><code id="evzinb_+3A_max.upd.par.zc.multinomial">max.upd.par.zc.multinomial</code></td>
<td>
<p>Maximum parameter change step size in the zero inflation component</p>
</td></tr>
<tr><td><code id="evzinb_+3A_max.upd.par.pl.multinomial">max.upd.par.pl.multinomial</code></td>
<td>
<p>Maximum parameter change step size in the extreme value inflation component</p>
</td></tr>
<tr><td><code id="evzinb_+3A_max.upd.par.nb">max.upd.par.nb</code></td>
<td>
<p>Maximum parameter change step size in the count component</p>
</td></tr>
<tr><td><code id="evzinb_+3A_max.upd.par.pl">max.upd.par.pl</code></td>
<td>
<p>Maximum parameter change step size in the pareto component</p>
</td></tr>
<tr><td><code id="evzinb_+3A_no.m.bfgs.steps.multinomial">no.m.bfgs.steps.multinomial</code></td>
<td>
<p>Number of BFGS steps for the multinomial model</p>
</td></tr>
<tr><td><code id="evzinb_+3A_no.m.bfgs.steps.nb">no.m.bfgs.steps.nb</code></td>
<td>
<p>Number of BFGS steps for the negative binomial model</p>
</td></tr>
<tr><td><code id="evzinb_+3A_no.m.bfgs.steps.pl">no.m.bfgs.steps.pl</code></td>
<td>
<p>Number of BFGS steps for the pareto model</p>
</td></tr>
<tr><td><code id="evzinb_+3A_pdf.pl.type">pdf.pl.type</code></td>
<td>
<p>Probability density function type for the pareto component. Either 'approx' or 'exact'. 'approx' is adviced in most cases</p>
</td></tr>
<tr><td><code id="evzinb_+3A_eta.int">eta.int</code></td>
<td>
<p>Initial values for eta</p>
</td></tr>
<tr><td><code id="evzinb_+3A_init.beta.multinom.zc">init.Beta.multinom.ZC</code></td>
<td>
<p>Initial values for beta parameters in the zero value inflation component. Vector of same length as number of parameters in the zero value inflation component or NULL (which gives starting values of 0)</p>
</td></tr>
<tr><td><code id="evzinb_+3A_init.beta.multinom.pl">init.Beta.multinom.PL</code></td>
<td>
<p>Initial values for beta parameters in the extreme value inflation component. Vector of same length as number of parameters in the extreme value inflation component or NULL (which gives starting values of 0)</p>
</td></tr>
<tr><td><code id="evzinb_+3A_init.beta.nb">init.Beta.NB</code></td>
<td>
<p>Initial values for beta parameters in the count component. Vector of same length as number of parameters in the count component or NULL (which gives starting values of 0)</p>
</td></tr>
<tr><td><code id="evzinb_+3A_init.beta.pl">init.Beta.PL</code></td>
<td>
<p>Initial values for beta parameters in the pareto component. Vector of same length as number of parameters in the pareto component or NULL (which gives starting values of 0)</p>
</td></tr>
<tr><td><code id="evzinb_+3A_init.alpha.nb">init.Alpha.NB</code></td>
<td>
<p>Initial value of Alpha NB, integer or NULL (giving a starting value of 0)</p>
</td></tr>
<tr><td><code id="evzinb_+3A_init.c">init.C</code></td>
<td>
<p>Initial value of C. Integer which should be within the C_lim range.</p>
</td></tr>
<tr><td><code id="evzinb_+3A_verbose">verbose</code></td>
<td>
<p>Logical: should progress of the full run of the model be tracked?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class 'evzinb'
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(genevzinb2)
model &lt;- evzinb(y~x1+x2+x3,data=genevzinb2, n_bootstraps = 10)

</code></pre>

<hr>
<h2 id='genevzinb'>Simulated data from the EVZBINB distribution</h2><span id='topic+genevzinb'></span>

<h3>Description</h3>

<p>A simulated dataset of 1,000 observations with one dependent and three dependent variables generated using the EVZINB distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>genevzinb
</code></pre>


<h3>Format</h3>

<p>## 'genevzinb'
A tibble with 1,000 rows and 4 columns:
</p>

<dl>
<dt>y</dt><dd><p>Dependent variable following EVZINB distribution</p>
</dd>
<dt>x1, x2, x3</dt><dd><p>Continuous independent variables following the random normal distribution</p>
</dd>
</dl>


<hr>
<h2 id='genevzinb2'>Simulated data from the EVZBINB distribution</h2><span id='topic+genevzinb2'></span>

<h3>Description</h3>

<p>A simulated dataset of 100 observations with one dependent and three dependent variables generated using the EVZINB distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>genevzinb2
</code></pre>


<h3>Format</h3>

<p>## 'genevzinb2'
A tibble with 100 rows and 4 columns:
</p>

<dl>
<dt>y</dt><dd><p>Dependent variable following EVZINB distribution</p>
</dd>
<dt>x1, x2, x3</dt><dd><p>Continuous independent variables following the random normal distribution</p>
</dd>
</dl>


<hr>
<h2 id='glance.evinb'>EVZINB and EVINB glance functions</h2><span id='topic+glance.evinb'></span>

<h3>Description</h3>

<p>EVZINB and EVINB glance functions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'evinb'
glance(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="glance.evinb_+3A_x">x</code></td>
<td>
<p>An EVZINB or EVINB object</p>
</td></tr>
<tr><td><code id="glance.evinb_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed to glance()</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An EVZINB glance function
</p>


<h3>See Also</h3>

<p><code><a href="generics.html#topic+glance">glance</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(genevzinb2)
model &lt;- evinb(y~x1+x2+x3,data=genevzinb2, n_bootstraps = 10)
glance(model)

</code></pre>

<hr>
<h2 id='glance.evzinb'>EVZINB and EVINB glance functions</h2><span id='topic+glance.evzinb'></span>

<h3>Description</h3>

<p>EVZINB and EVINB glance functions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'evzinb'
glance(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="glance.evzinb_+3A_x">x</code></td>
<td>
<p>An EVZINB or EVINB object</p>
</td></tr>
<tr><td><code id="glance.evzinb_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed to glance()</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An EVZINB glance function
</p>


<h3>See Also</h3>

<p><code><a href="generics.html#topic+glance">glance</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(genevzinb2)
model &lt;- evzinb(y~x1+x2+x3,data=genevzinb2, n_bootstraps = 10)
glance(model)

</code></pre>

<hr>
<h2 id='glance.nbboot'>zinbboot and nboot glance functions</h2><span id='topic+glance.nbboot'></span>

<h3>Description</h3>

<p>zinbboot and nboot glance functions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'nbboot'
glance(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="glance.nbboot_+3A_x">x</code></td>
<td>
<p>An nbboot or zinbboot object</p>
</td></tr>
<tr><td><code id="glance.nbboot_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed to glance()</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An nbboot glance function
</p>


<h3>See Also</h3>

<p><code><a href="generics.html#topic+glance">glance</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(genevzinb2)
model &lt;- evzinb(y~x1+x2+x3,data=genevzinb2, n_bootstraps = 10, multicore = TRUE, ncores = 2)
zinb_comp &lt;- compare_models(model)
glance(zinb_comp$nb)

</code></pre>

<hr>
<h2 id='glance.zinbboot'>zinbboot and nboot glance functions</h2><span id='topic+glance.zinbboot'></span>

<h3>Description</h3>

<p>zinbboot and nboot glance functions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'zinbboot'
glance(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="glance.zinbboot_+3A_x">x</code></td>
<td>
<p>An nbboot or zinbboot object</p>
</td></tr>
<tr><td><code id="glance.zinbboot_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed to glance()</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An nbboot glance function
</p>


<h3>See Also</h3>

<p><code><a href="generics.html#topic+glance">glance</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(genevzinb2)
model &lt;- evzinb(y~x1+x2+x3,data=genevzinb2, n_bootstraps = 10, multicore = TRUE, ncores = 2)
zinb_comp &lt;- compare_models(model)
glance(zinb_comp$zinb)

</code></pre>

<hr>
<h2 id='gm_evzinb'>A goodness-of-fit gof tibble for GOF metrics when using modelsummary</h2><span id='topic+gm_evzinb'></span>

<h3>Description</h3>

<p>A goodness-of-fit gof tibble for GOF metrics when using modelsummary. The GM tibble can be used to obtain correct table output when making regression tables with modelsummary
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gm_evzinb
</code></pre>


<h3>Format</h3>

<p>## 'gm_evzinb'
A tibble with 7 rows and 3 columns:
</p>

<dl>
<dt>raw</dt><dd><p>The modelsummary/broom internal name for the statistic</p>
</dd>
<dt>clean</dt><dd><p>The table output for the statistic</p>
</dd>
<dt>fmt</dt><dd><p>The number of decimals reported for each statistic by default (can be adapted)</p>
</dd></dl>


<hr>
<h2 id='hks'>Replication data for Hultman, Kathman, and Shannon (2013) United Nations Peacekeeping and Civilian Protection in Civil War</h2><span id='topic+hks'></span>

<h3>Description</h3>

<p>A reduced replication data set from Hultman et al. (2013) United Nations Peacekeeping and Civilian Protection in Civil War. Used to reproduce the the results from Randahl and Vegelius (2023). Note, to reproduce any other results from Hultman et al. (2013) please download the original replication dataset using the link under source.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hks
</code></pre>


<h3>Format</h3>

<p>A tibble with 3746 rows and 12 columns:
</p>

<dl>
<dt>conflict_id</dt><dd><p>The Uppsala Conflict Data Programme conflict ID for the conflict</p>
</dd>
<dt>osvAll</dt><dd><p>The number of observed fatalities from one-sided violence against civilian in the specified conflict-month</p>
</dd>
<dt>troopLag</dt><dd><p>The number of UN military troops in thousands of troops (lagged)</p>
</dd>
<dt>policeLag</dt><dd><p>The number of UN police in thousands of troops (lagged)</p>
</dd>
<dt>militaryobserversLag</dt><dd><p>The number of UN military troops in thousands of troops (lagged)</p>
</dd>
<dt>epduration</dt><dd><p>The number of months the current conflict-episode has been ongoing</p>
</dd>
<dt>lntpop</dt><dd><p>The natural logarithm of the population of the country in which the conflict takes place</p>
</dd>
<dt>lnbrv_AllLag</dt><dd><p>The natural logarithm of the total number of battle related deaths in the conflict in the previous month</p>
</dd>
<dt>osvAllLagDum</dt><dd><p>A dummy variable taking the value 1 if any one-sided violence against civilians took place in the previous conflict month</p>
</dd>
<dt>incomp</dt><dd><p>A dummy variable taking the value 1 if the conflict is about government and 0 otherwise</p>
</dd>
<dt>lntroopLag</dt><dd><p>The log1p logarithm of troopLag</p>
</dd>
<dt>lnepdur</dt><dd><p>The log1p logarithm of the episode duration</p>
</dd>
</dl>



<h3>Source</h3>

<p>https://dataverse.harvard.edu/dataset.xhtml?persistentId=doi:10.7910/DVN/6EBCGA
</p>


<h3>References</h3>

<p>Hultman L, Kathman J, Shannon M (2013).
&ldquo;United Nations peacekeeping and civilian protection in civil war.&rdquo;
<em>American Journal of Political Science</em>, <b>57</b>(4), 875&ndash;891.<br /><br /> Randahl D, Vegelius J (2023).
&ldquo;Inference with Extremes: Accounting for Extreme Values in Count Regression Models.&rdquo;
<em>International Studies Quarterly</em>, <b>x</b>(x), x.
</p>

<hr>
<h2 id='lr_test'>Likelihood ratio test for individual variables of evzinb</h2><span id='topic+lr_test'></span>

<h3>Description</h3>

<p>Likelihood ratio test for individual variables of evzinb
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lr_test(
  object,
  vars,
  single = TRUE,
  bootstrap = FALSE,
  multicore = FALSE,
  ncores = NULL,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lr_test_+3A_object">object</code></td>
<td>
<p>EVZINB or EVZINB object to perform likelihood ratio test on</p>
</td></tr>
<tr><td><code id="lr_test_+3A_vars">vars</code></td>
<td>
<p>Either a list of character vectors with variable names which to be restricted in the LR test or a character vector of variable names. If a list, each character vector of the list will be run separately, allowing for multiple variables to be restricted as once. If a character vector, parameter 'single' can be used to determine whether all variables in the vector should be restricted at once (single = FALSE) or if the variables should be restricted one by one (single = TRUE)</p>
</td></tr>
<tr><td><code id="lr_test_+3A_single">single</code></td>
<td>
<p>Logical. Determining whether variables in 'vars' should be restricted individually (single = TRUE) or all at once (single = FALSE)</p>
</td></tr>
<tr><td><code id="lr_test_+3A_bootstrap">bootstrap</code></td>
<td>
<p>Should LR tests be conducted on each bootstrapped sample or only on the original sample.</p>
</td></tr>
<tr><td><code id="lr_test_+3A_multicore">multicore</code></td>
<td>
<p>Logical. Should the function be run in parallel?</p>
</td></tr>
<tr><td><code id="lr_test_+3A_ncores">ncores</code></td>
<td>
<p>Number of cores to use if multicore = TRUE</p>
</td></tr>
<tr><td><code id="lr_test_+3A_verbose">verbose</code></td>
<td>
<p>Logical. Should the function be verbose?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble with one row per performed LR test
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(genevzinb2)
model &lt;- evzinb(y~x1+x2+x3,data=genevzinb2, n_bootstraps = 10)
 lr_test(model,'x1')
 
</code></pre>

<hr>
<h2 id='oob_evaluation'>Out of bag predictive performance of EVZINB and EVINB models</h2><span id='topic+oob_evaluation'></span>

<h3>Description</h3>

<p>Out of bag predictive performance of EVZINB and EVINB models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>oob_evaluation(
  object,
  predict_type = c("harmonic", "explog"),
  metric = c("rmsle", "rmse", "mse", "mae")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="oob_evaluation_+3A_object">object</code></td>
<td>
<p>A fitted evzinb or evinb with bootstraps on which to conduct out-of-bag evaluation</p>
</td></tr>
<tr><td><code id="oob_evaluation_+3A_predict_type">predict_type</code></td>
<td>
<p>What type of prediction should be made? Harmonic mean, or exp(log(prediction))?</p>
</td></tr>
<tr><td><code id="oob_evaluation_+3A_metric">metric</code></td>
<td>
<p>What metric should be used for the out of bag evaluation? Default options include rmsle, rmse, mse, and mae. Can also take a user supplied function of the form function(y_pred,y_true) which returns a single value</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of oob evaluation metrics of the length of the number of bootstraps in the evzinb/evinb object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(genevzinb2)
model &lt;- evzinb(y~x1+x2+x3,data=genevzinb2, n_bootstraps = 10)
oob_evaluation(model)

</code></pre>

<hr>
<h2 id='predict.evinb'>Predictions from evinb object</h2><span id='topic+predict.evinb'></span>

<h3>Description</h3>

<p>Predictions from evinb object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'evinb'
predict(
  object,
  newdata = NULL,
  type = c("harmonic", "explog", "counts", "pareto_alpha", "evinf", "count_state",
    "states", "all", "quantile"),
  pred = c("original", "bootstrap_median", "bootstrap_mean"),
  quantile = NULL,
  confint = FALSE,
  conf_level = 0.9,
  multicore = FALSE,
  ncores = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.evinb_+3A_object">object</code></td>
<td>
<p>An evinb object for which to produce predicted values</p>
</td></tr>
<tr><td><code id="predict.evinb_+3A_newdata">newdata</code></td>
<td>
<p>Optional new data (tibble) to produce predicted values from</p>
</td></tr>
<tr><td><code id="predict.evinb_+3A_type">type</code></td>
<td>
<p>Character string, 'harmonic' for the harmonic mean and 'explog' for exponentiated expected log, 'counts' for predicted count of the negative binomial component, 'pareto_alpha' for the predicted pareto alpha value, 'states' for the predicted component states (prior), 'count_state' for predicted probability of the count state, 'evinf' for predicted probability of the pareto state, 'all' for all predicted values, and 'quantile' for quantile prediction.</p>
</td></tr>
<tr><td><code id="predict.evinb_+3A_pred">pred</code></td>
<td>
<p>Type of prediction to be used, defaults to the original prediction from the fitted model, with alternatives being the bootstrapped median or mean. Note that bootstrap mean may yield infinite values, especially when doing quantile prediction</p>
</td></tr>
<tr><td><code id="predict.evinb_+3A_quantile">quantile</code></td>
<td>
<p>Quantile for which to produce quantile prediction</p>
</td></tr>
<tr><td><code id="predict.evinb_+3A_confint">confint</code></td>
<td>
<p>Should confidence intervals be made for the predictions? Note: only available for vector type predictions and not 'states' and 'all'.</p>
</td></tr>
<tr><td><code id="predict.evinb_+3A_conf_level">conf_level</code></td>
<td>
<p>What confidence level should be used for confidence intervals</p>
</td></tr>
<tr><td><code id="predict.evinb_+3A_multicore">multicore</code></td>
<td>
<p>Should multicore be used when calculating quantile prediction? Often it is enough to run quantile prediction on a single core, but in cases of large data or very skewed distributions it may be useful to run multicore</p>
</td></tr>
<tr><td><code id="predict.evinb_+3A_ncores">ncores</code></td>
<td>
<p>Number of cores to be used for multicore.</p>
</td></tr>
<tr><td><code id="predict.evinb_+3A_...">...</code></td>
<td>
<p>Other arguments passed to predict function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of predicted values for type 'harmonic', 'explog', 'counts', 'pareto_alpha','evinf', 'count_state', and 'quantile' or a tibble of predicted values for type 'states' and 'all' or if confint=T
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(genevzinb2)
model &lt;- evinb(y~x1+x2+x3,data=genevzinb2, n_bootstraps = 10)
predict(model)
predict(model, type='all') # Getting all of the available predicted values

</code></pre>

<hr>
<h2 id='predict.evzinb'>Predictions from evzinb object</h2><span id='topic+predict.evzinb'></span>

<h3>Description</h3>

<p>Predictions from evzinb object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'evzinb'
predict(
  object,
  newdata = NULL,
  type = c("harmonic", "explog", "counts", "pareto_alpha", "zi", "evinf", "count_state",
    "states", "all", "quantile"),
  pred = c("original", "bootstrap_median", "bootstrap_mean"),
  quantile = NULL,
  confint = FALSE,
  conf_level = 0.9,
  multicore = FALSE,
  ncores = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.evzinb_+3A_object">object</code></td>
<td>
<p>An evzinb object for which to produce predicted values</p>
</td></tr>
<tr><td><code id="predict.evzinb_+3A_newdata">newdata</code></td>
<td>
<p>Optional new data (tibble) to produce predicted values from</p>
</td></tr>
<tr><td><code id="predict.evzinb_+3A_type">type</code></td>
<td>
<p>Character string, 'harmonic' for the harmonic mean and 'explog' for exponentiated expected log, 'counts' for predicted count of the negative binomial component, 'pareto_alpha' for the predicted pareto alpha value, 'states' for the predicted component states (prior), 'count_state' for predicted probability of the count state, 'evinf' for predicted probability of the pareto state,'zi' for the predicted probability of the zero state, 'all' for all predicted values, and 'quantile' for quantile prediction.</p>
</td></tr>
<tr><td><code id="predict.evzinb_+3A_pred">pred</code></td>
<td>
<p>Type of prediction to be used, defaults to the original prediction from the fitted model, with alternatives being the bootstrapped median or mean. Note that bootstrap mean may yield infinite values, especially when doing quantile prediction</p>
</td></tr>
<tr><td><code id="predict.evzinb_+3A_quantile">quantile</code></td>
<td>
<p>Quantile for which to produce quantile prediction</p>
</td></tr>
<tr><td><code id="predict.evzinb_+3A_confint">confint</code></td>
<td>
<p>Should confidence intervals be made for the predictions? Note: only available for vector type predictions and not 'states' and 'all'.</p>
</td></tr>
<tr><td><code id="predict.evzinb_+3A_conf_level">conf_level</code></td>
<td>
<p>What confidence level should be used for confidence intervals</p>
</td></tr>
<tr><td><code id="predict.evzinb_+3A_multicore">multicore</code></td>
<td>
<p>Should multicore be used when calculating quantile prediction? Often it is enough to run quantile prediction on a single core, but in cases of large data or very skewed distributions it may be useful to run multicore</p>
</td></tr>
<tr><td><code id="predict.evzinb_+3A_ncores">ncores</code></td>
<td>
<p>Number of cores to be used for multicore.</p>
</td></tr>
<tr><td><code id="predict.evzinb_+3A_...">...</code></td>
<td>
<p>Other arguments passed to predict function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of predicted values for type 'harmonic', 'explog', 'counts', 'pareto_alpha','zi','evinf', 'count_state', and 'quantile' or a tibble of predicted values for type 'states' and 'all' or if confint=T
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(genevzinb2)
model &lt;- evzinb(y~x1+x2+x3,data=genevzinb2, n_bootstraps = 10)
predict(model)
predict(model, type='all') # Getting all of the available predicted values

</code></pre>

<hr>
<h2 id='predict.zinbboot'>Prediction for zinbboot</h2><span id='topic+predict.zinbboot'></span>

<h3>Description</h3>

<p>Prediction for zinbboot
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'zinbboot'
predict(
  object,
  newdata = NULL,
  type = c("predicted", "counts", "zi", "evinf", "count_state", "states", "all",
    "quantile"),
  pred = c("original", "bootstrap_median", "bootstrap_mean"),
  quantile = NULL,
  confint = FALSE,
  conf_level = 0.9,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.zinbboot_+3A_object">object</code></td>
<td>
<p>a fitted zinbboot object</p>
</td></tr>
<tr><td><code id="predict.zinbboot_+3A_newdata">newdata</code></td>
<td>
<p>Data to make predictions on</p>
</td></tr>
<tr><td><code id="predict.zinbboot_+3A_type">type</code></td>
<td>
<p>What prediction should be computed?</p>
</td></tr>
<tr><td><code id="predict.zinbboot_+3A_pred">pred</code></td>
<td>
<p>Prediction type, 'original', 'bootstra_median', or 'bootstrap_mean'</p>
</td></tr>
<tr><td><code id="predict.zinbboot_+3A_quantile">quantile</code></td>
<td>
<p>Quantile for quantile prediction</p>
</td></tr>
<tr><td><code id="predict.zinbboot_+3A_confint">confint</code></td>
<td>
<p>Should confidence intervals be created?</p>
</td></tr>
<tr><td><code id="predict.zinbboot_+3A_conf_level">conf_level</code></td>
<td>
<p>Confidence level when predicting with CIs</p>
</td></tr>
<tr><td><code id="predict.zinbboot_+3A_...">...</code></td>
<td>
<p>Not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Predictions from zinbboot
</p>

<hr>
<h2 id='print.evinb'>EVINB print function</h2><span id='topic+print.evinb'></span>

<h3>Description</h3>

<p>EVINB print function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'evinb'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.evinb_+3A_x">x</code></td>
<td>
<p>A fitted evinb model</p>
</td></tr>
<tr><td><code id="print.evinb_+3A_...">...</code></td>
<td>
<p>Not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An evinb print function
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(genevzinb2)
model &lt;- evinb(y~x1+x2+x3,data=genevzinb2, n_bootstraps = 10)
print(model)

</code></pre>

<hr>
<h2 id='print.evzinb'>EVZINB print function</h2><span id='topic+print.evzinb'></span>

<h3>Description</h3>

<p>EVZINB print function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'evzinb'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.evzinb_+3A_x">x</code></td>
<td>
<p>A fitted evzinb model</p>
</td></tr>
<tr><td><code id="print.evzinb_+3A_...">...</code></td>
<td>
<p>Not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An evzinb print function
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(genevzinb2)
model &lt;- evzinb(y~x1+x2+x3,data=genevzinb2, n_bootstraps = 10)
print(model)

</code></pre>

<hr>
<h2 id='print.evzinbcomp'>Compare_models print function</h2><span id='topic+print.evzinbcomp'></span>

<h3>Description</h3>

<p>Compare_models print function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'evzinbcomp'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.evzinbcomp_+3A_x">x</code></td>
<td>
<p>A fitted evinb model</p>
</td></tr>
<tr><td><code id="print.evzinbcomp_+3A_...">...</code></td>
<td>
<p>Not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An evinb print function
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(genevzinb2)
model &lt;- evinb(y~x1+x2+x3,data=genevzinb2, n_bootstraps = 10)
print(model)

</code></pre>

<hr>
<h2 id='revinb_fit'>Random draws from a fitted evinb model</h2><span id='topic+revinb_fit'></span>

<h3>Description</h3>

<p>Random draws from a fitted evinb model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>revinb_fit(object, newdata = NULL, n_draws = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="revinb_fit_+3A_object">object</code></td>
<td>
<p>A fitted EVINB object</p>
</td></tr>
<tr><td><code id="revinb_fit_+3A_newdata">newdata</code></td>
<td>
<p>Optional newdata</p>
</td></tr>
<tr><td><code id="revinb_fit_+3A_n_draws">n_draws</code></td>
<td>
<p>Number of random draws to make</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of randomly drawn values from the fitted evinb if n_draws == 1, or a list of length n_draws with random drawn values if n_draws &gt; 1
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(genevzinb2)
model &lt;- evinb(y~x1+x2+x3, data=genevzinb2, n_bootstraps = 10, multicore = TRUE, ncores = 2)
revinb_fit(model)

</code></pre>

<hr>
<h2 id='revzinb_fit'>Random draws from a fitted evzinb model</h2><span id='topic+revzinb_fit'></span>

<h3>Description</h3>

<p>Random draws from a fitted evzinb model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>revzinb_fit(object, newdata = NULL, n_draws = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="revzinb_fit_+3A_object">object</code></td>
<td>
<p>A fitted EVZINB object</p>
</td></tr>
<tr><td><code id="revzinb_fit_+3A_newdata">newdata</code></td>
<td>
<p>Optional newdata</p>
</td></tr>
<tr><td><code id="revzinb_fit_+3A_n_draws">n_draws</code></td>
<td>
<p>Number of random draws to make</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of randomly drawn values from the fitted evzinb if n_draws == 1, or a list of length n_draws with random drawn values if n_draws &gt; 1
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(genevzinb2)
model &lt;- evzinb(y~x1+x2+x3, data=genevzinb2, n_bootstraps = 10, multicore = TRUE, ncores = 2)
revzinb_fit(model)

</code></pre>

<hr>
<h2 id='summary.evinb'>EVINB summary function</h2><span id='topic+summary.evinb'></span>

<h3>Description</h3>

<p>EVINB summary function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'evinb'
summary(
  object,
  coef = c("original", "bootstrapped_mean", "bootstrapped_median"),
  standard_error = TRUE,
  p_value = c("bootstrapped", "approx", "both", "none"),
  bootstrapped_props = c("none", "mean", "median"),
  approx_t_value = TRUE,
  symmetric_bootstrap_p = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.evinb_+3A_object">object</code></td>
<td>
<p>an EVINB object with bootstraps</p>
</td></tr>
<tr><td><code id="summary.evinb_+3A_coef">coef</code></td>
<td>
<p>Type of coefficients. Original are the coefficient estimates from the non-bootstrapped version of the model. 'bootstrapped_mean' are the mean coefficients across bootstraps, and 'bootstrapped_median' are the median coefficients across bootstraps</p>
</td></tr>
<tr><td><code id="summary.evinb_+3A_standard_error">standard_error</code></td>
<td>
<p>Should standard errors be computed?</p>
</td></tr>
<tr><td><code id="summary.evinb_+3A_p_value">p_value</code></td>
<td>
<p>What type of p_values should be computed? 'bootstrapped' are bootstrapped p_values through confidence interval inversion. 'approx' are p-values based on the t-value produced by dividing the coefficient with the standard error.</p>
</td></tr>
<tr><td><code id="summary.evinb_+3A_bootstrapped_props">bootstrapped_props</code></td>
<td>
<p>Type of bootstrapped proportions of component proportions to be returned</p>
</td></tr>
<tr><td><code id="summary.evinb_+3A_approx_t_value">approx_t_value</code></td>
<td>
<p>Should approximate t-values be returned</p>
</td></tr>
<tr><td><code id="summary.evinb_+3A_symmetric_bootstrap_p">symmetric_bootstrap_p</code></td>
<td>
<p>Should bootstrap p-values be computed as symmetric (leaving alpha/2 percent in each tail)? FALSE gives non-symmetric, but narrower, intervals. TRUE corresponds most closely to conventional p-values.</p>
</td></tr>
<tr><td><code id="summary.evinb_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to the summary function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An EVINB summary object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(genevzinb2)
model &lt;- evinb(y~x1+x2+x3,data=genevzinb2, n_bootstraps = 10, multicore = TRUE, ncores = 2)
summary(model)

</code></pre>

<hr>
<h2 id='summary.evzinb'>EVZINB summary function</h2><span id='topic+summary.evzinb'></span>

<h3>Description</h3>

<p>EVZINB summary function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'evzinb'
summary(
  object,
  coef = c("original", "bootstrapped_mean", "bootstrapped_median"),
  standard_error = TRUE,
  p_value = c("bootstrapped", "approx", "both", "none"),
  bootstrapped_props = c("none", "mean", "median"),
  approx_t_value = TRUE,
  symmetric_bootstrap_p = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.evzinb_+3A_object">object</code></td>
<td>
<p>an EVZINB object with bootstraps</p>
</td></tr>
<tr><td><code id="summary.evzinb_+3A_coef">coef</code></td>
<td>
<p>Type of coefficients. Original are the coefficient estimates from the non-bootstrapped version of the model. 'bootstrapped_mean' are the mean coefficients across bootstraps, and 'bootstrapped_median' are the median coefficients across bootstraps</p>
</td></tr>
<tr><td><code id="summary.evzinb_+3A_standard_error">standard_error</code></td>
<td>
<p>Should standard errors be computed?</p>
</td></tr>
<tr><td><code id="summary.evzinb_+3A_p_value">p_value</code></td>
<td>
<p>What type of p_values should be computed? 'bootstrapped' are bootstrapped p_values through confidence interval inversion. 'approx' are p-values based on the t-value produced by dividing the coefficient with the standard error.</p>
</td></tr>
<tr><td><code id="summary.evzinb_+3A_bootstrapped_props">bootstrapped_props</code></td>
<td>
<p>Type of bootstrapped proportions of component proportions to be returned</p>
</td></tr>
<tr><td><code id="summary.evzinb_+3A_approx_t_value">approx_t_value</code></td>
<td>
<p>Should approximate t-values be returned</p>
</td></tr>
<tr><td><code id="summary.evzinb_+3A_symmetric_bootstrap_p">symmetric_bootstrap_p</code></td>
<td>
<p>Should bootstrap p-values be computed as symmetric (leaving alpha/2 percent in each tail)? FALSE gives non-symmetric, but narrower, intervals. TRUE corresponds most closely to conventional p-values.</p>
</td></tr>
<tr><td><code id="summary.evzinb_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to the summary function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An EVZINB summary object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(genevzinb2)
model &lt;- evzinb(y~x1+x2+x3,data=genevzinb2, n_bootstraps = 10, multicore = TRUE, ncores = 2)
summary(model)

</code></pre>

<hr>
<h2 id='tidy.evinb'>EVINB tidy function</h2><span id='topic+tidy.evinb'></span>

<h3>Description</h3>

<p>EVINB tidy function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'evinb'
tidy(
  x,
  component = c("evi", "count", "pareto", "all"),
  coef_type = c("original", "bootstrap_mean", "bootstrap_median"),
  standard_error = TRUE,
  p_value = c("bootstrapped", "approx", "none"),
  confint = c("none", "bootstrapped", "approx"),
  conf_level = 0.95,
  approx_t_value = TRUE,
  symmetric_bootstrap_p = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tidy.evinb_+3A_x">x</code></td>
<td>
<p>An evinb object</p>
</td></tr>
<tr><td><code id="tidy.evinb_+3A_component">component</code></td>
<td>
<p>Which component should be shown?</p>
</td></tr>
<tr><td><code id="tidy.evinb_+3A_coef_type">coef_type</code></td>
<td>
<p>Type of coefficients. Original are the coefficient estimates from the non-bootstrapped version of the model. 'bootstrapped_mean' are the mean coefficients across bootstraps, and 'bootstrapped_median' are the median coefficients across bootstraps</p>
</td></tr>
<tr><td><code id="tidy.evinb_+3A_standard_error">standard_error</code></td>
<td>
<p>Should standard errors be computed?</p>
</td></tr>
<tr><td><code id="tidy.evinb_+3A_p_value">p_value</code></td>
<td>
<p>What type of p_values should be computed? 'bootstrapped' are bootstrapped p_values through confidence interval inversion. 'approx' are p-values based on the t-value produced by dividing the coefficient with the standard error.</p>
</td></tr>
<tr><td><code id="tidy.evinb_+3A_confint">confint</code></td>
<td>
<p>What type of confidence should be computed. Same options as p_value</p>
</td></tr>
<tr><td><code id="tidy.evinb_+3A_conf_level">conf_level</code></td>
<td>
<p>What confidence level should be used for the confidence interval</p>
</td></tr>
<tr><td><code id="tidy.evinb_+3A_approx_t_value">approx_t_value</code></td>
<td>
<p>Should approximate t-values be returned</p>
</td></tr>
<tr><td><code id="tidy.evinb_+3A_symmetric_bootstrap_p">symmetric_bootstrap_p</code></td>
<td>
<p>Should bootstrap p-values be computed as symmetric (leaving alpha/2 percent in each tail)? FALSE gives non-symmetric, but narrower, intervals. TRUE corresponds most closely to conventional p-values.</p>
</td></tr>
<tr><td><code id="tidy.evinb_+3A_...">...</code></td>
<td>
<p>Other arguments passsed to tidy function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An EVINB tidy function
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(genevzinb2)
model &lt;- evinb(y~x1+x2+x3,data=genevzinb2, n_bootstraps = 10, multicore = TRUE, ncores = 2)
tidy(model)

</code></pre>

<hr>
<h2 id='tidy.evzinb'>EVZINB tidy function</h2><span id='topic+tidy.evzinb'></span>

<h3>Description</h3>

<p>EVZINB tidy function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'evzinb'
tidy(
  x,
  component = c("zi", "evi", "count", "pareto", "all"),
  coef_type = c("original", "bootstrap_mean", "bootstrap_median"),
  standard_error = TRUE,
  p_value = c("bootstrapped", "approx", "none"),
  confint = c("none", "bootstrapped", "approx"),
  conf_level = 0.95,
  approx_t_value = TRUE,
  symmetric_bootstrap_p = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tidy.evzinb_+3A_x">x</code></td>
<td>
<p>An evzinb object</p>
</td></tr>
<tr><td><code id="tidy.evzinb_+3A_component">component</code></td>
<td>
<p>Which component should be shown?</p>
</td></tr>
<tr><td><code id="tidy.evzinb_+3A_coef_type">coef_type</code></td>
<td>
<p>Type of coefficients. Original are the coefficient estimates from the non-bootstrapped version of the model. 'bootstrapped_mean' are the mean coefficients across bootstraps, and 'bootstrapped_median' are the median coefficients across bootstraps</p>
</td></tr>
<tr><td><code id="tidy.evzinb_+3A_standard_error">standard_error</code></td>
<td>
<p>Should standard errors be computed?</p>
</td></tr>
<tr><td><code id="tidy.evzinb_+3A_p_value">p_value</code></td>
<td>
<p>What type of p_values should be computed? 'bootstrapped' are bootstrapped p_values through confidence interval inversion. 'approx' are p-values based on the t-value produced by dividing the coefficient with the standard error.</p>
</td></tr>
<tr><td><code id="tidy.evzinb_+3A_confint">confint</code></td>
<td>
<p>What type of confidence should be computed. Same options as p_value</p>
</td></tr>
<tr><td><code id="tidy.evzinb_+3A_conf_level">conf_level</code></td>
<td>
<p>What confidence level should be used for the confidence interval</p>
</td></tr>
<tr><td><code id="tidy.evzinb_+3A_approx_t_value">approx_t_value</code></td>
<td>
<p>Should approximate t-values be returned</p>
</td></tr>
<tr><td><code id="tidy.evzinb_+3A_symmetric_bootstrap_p">symmetric_bootstrap_p</code></td>
<td>
<p>Should bootstrap p-values be computed as symmetric (leaving alpha/2 percent in each tail)? FALSE gives non-symmetric, but narrower, intervals. TRUE corresponds most closely to conventional p-values.</p>
</td></tr>
<tr><td><code id="tidy.evzinb_+3A_...">...</code></td>
<td>
<p>Other arguments passsed to tidy function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An EVZINB tidy function
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(genevzinb2)
model &lt;- evzinb(y~x1+x2+x3,data=genevzinb2, n_bootstraps = 10, multicore = TRUE, ncores = 2)
tidy(model)

</code></pre>

<hr>
<h2 id='tidy.nbboot'>Tidy function for nbboot</h2><span id='topic+tidy.nbboot'></span>

<h3>Description</h3>

<p>Tidy function for nbboot
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'nbboot'
tidy(
  x,
  coef_type = c("original", "bootstrap_mean", "bootstrap_median"),
  standard_error = TRUE,
  p_value = c("bootstrapped", "approx", "none"),
  confint = c("none", "bootstrapped", "approx"),
  conf_level = 0.95,
  approx_t_value = TRUE,
  symmetric_bootstrap_p = TRUE,
  include_ylev = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tidy.nbboot_+3A_x">x</code></td>
<td>
<p>A fitted bootstrapped zero-inflated model</p>
</td></tr>
<tr><td><code id="tidy.nbboot_+3A_coef_type">coef_type</code></td>
<td>
<p>What type of coefficient should be reported, original, bootstrapped mean, or bootstrapped median</p>
</td></tr>
<tr><td><code id="tidy.nbboot_+3A_standard_error">standard_error</code></td>
<td>
<p>Should bootstrapped standard errors be reported?</p>
</td></tr>
<tr><td><code id="tidy.nbboot_+3A_p_value">p_value</code></td>
<td>
<p>What type of p-value should be reported? Bootstrapped p_values, approximate p-values, or none?</p>
</td></tr>
<tr><td><code id="tidy.nbboot_+3A_confint">confint</code></td>
<td>
<p>What type of confidence intervals should be reported? Bootstrapped p_values, approximate p-values, or none?</p>
</td></tr>
<tr><td><code id="tidy.nbboot_+3A_conf_level">conf_level</code></td>
<td>
<p>Confidence level for confidence intervals</p>
</td></tr>
<tr><td><code id="tidy.nbboot_+3A_approx_t_value">approx_t_value</code></td>
<td>
<p>Should approximate t_values be reported</p>
</td></tr>
<tr><td><code id="tidy.nbboot_+3A_symmetric_bootstrap_p">symmetric_bootstrap_p</code></td>
<td>
<p>Should bootstrap p-values be computed as symmetric (leaving alpha/2 percent in each tail)? FALSE gives non-symmetric, but narrower, intervals. TRUE corresponds most closely to conventional p-values.</p>
</td></tr>
<tr><td><code id="tidy.nbboot_+3A_include_ylev">include_ylev</code></td>
<td>
<p>Logical. Should y.lev be included in the tidy output? Makes for nicer tables when using modelsummary</p>
</td></tr>
<tr><td><code id="tidy.nbboot_+3A_...">...</code></td>
<td>
<p>Other arguments to be passed to tidy</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tidy function for a bootstrapped nb model
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(genevzinb2)
model &lt;- evzinb(y~x1+x2+x3,data=genevzinb2, n_bootstraps = 10, multicore = TRUE, ncores = 2)
zinb_comp &lt;- compare_models(model)
tidy(zinb_comp$nb) 

</code></pre>

<hr>
<h2 id='tidy.zinbboot'>Tidy function for zinbboot</h2><span id='topic+tidy.zinbboot'></span>

<h3>Description</h3>

<p>Tidy function for zinbboot
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'zinbboot'
tidy(
  x,
  component = c("zi", "count", "all"),
  coef_type = c("original", "bootstrap_mean", "bootstrap_median"),
  standard_error = TRUE,
  p_value = c("bootstrapped", "approx", "none"),
  confint = c("none", "bootstrapped", "approx"),
  conf_level = 0.95,
  approx_t_value = TRUE,
  symmetric_bootstrap_p = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tidy.zinbboot_+3A_x">x</code></td>
<td>
<p>A fitted bootstrapped zero-inflated model</p>
</td></tr>
<tr><td><code id="tidy.zinbboot_+3A_component">component</code></td>
<td>
<p>Which component should be shown?</p>
</td></tr>
<tr><td><code id="tidy.zinbboot_+3A_coef_type">coef_type</code></td>
<td>
<p>What type of coefficient should be reported, original, bootstrapped mean, or bootstrapped median</p>
</td></tr>
<tr><td><code id="tidy.zinbboot_+3A_standard_error">standard_error</code></td>
<td>
<p>Should bootstrapped standard errors be reported?</p>
</td></tr>
<tr><td><code id="tidy.zinbboot_+3A_p_value">p_value</code></td>
<td>
<p>What type of p-value should be reported? Bootstrapped p_values, approximate p-values, or none?</p>
</td></tr>
<tr><td><code id="tidy.zinbboot_+3A_confint">confint</code></td>
<td>
<p>What type of confidence intervals should be reported? Bootstrapped p_values, approximate p-values, or none?</p>
</td></tr>
<tr><td><code id="tidy.zinbboot_+3A_conf_level">conf_level</code></td>
<td>
<p>Confidence level for confidence intervals</p>
</td></tr>
<tr><td><code id="tidy.zinbboot_+3A_approx_t_value">approx_t_value</code></td>
<td>
<p>Should approximate t_values be reported</p>
</td></tr>
<tr><td><code id="tidy.zinbboot_+3A_symmetric_bootstrap_p">symmetric_bootstrap_p</code></td>
<td>
<p>Should bootstrap p-values be computed as symmetric (leaving alpha/2 percent in each tail)? FALSE gives non-symmetric, but narrower, intervals. TRUE corresponds most closely to conventional p-values.</p>
</td></tr>
<tr><td><code id="tidy.zinbboot_+3A_...">...</code></td>
<td>
<p>Other arguments to be passed to tidy</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tidy function for a bootstrapped zinb model
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(genevzinb2)
model &lt;- evzinb(y~x1+x2+x3,data=genevzinb2, n_bootstraps = 10, multicore = TRUE, ncores = 2)
zinb_comp &lt;- compare_models(model)
tidy(zinb_comp$zinb)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
