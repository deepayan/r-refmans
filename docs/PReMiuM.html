<!DOCTYPE html><html><head><title>Help for package PReMiuM</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {PReMiuM}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#PReMiuM-package'>
<p>Dirichlet Process Bayesian Clustering</p></a></li>
<li><a href='#calcAvgRiskAndProfile'><p>Calculation of the average risks and profiles</p></a></li>
<li><a href='#calcDissimilarityMatrix'><p>Calculates the dissimilarity matrix</p></a></li>
<li><a href='#calcOptimalClustering'><p>Calculation of the optimal clustering</p></a></li>
<li><a href='#calcPredictions'><p>Calculates the predictions</p></a></li>
<li><a href='#clusSummaryBernoulliDiscrete'><p>Sample datasets for profile regression</p></a></li>
<li><a href='#computeRatioOfVariance'><p>computeRatioOfVariance</p></a></li>
<li><a href='#generateSampleDataFile'><p>Generate sample data files for profile regression</p></a></li>
<li><a href='#globalParsTrace'><p>Plot of the trace of some of the global parameters</p></a></li>
<li><a href='#heatDissMat'><p>Plot the heatmap of the dissimilarity matrix</p></a></li>
<li><a href='#is.wholenumber'><p>Function to check if a number is a whole number</p></a></li>
<li><a href='#mapforGeneratedData'><p>Map generated data</p></a></li>
<li><a href='#margModelPosterior'><p>Marginal Model Posterior</p></a></li>
<li><a href='#plotPredictions'><p>Plot the conditional density using the predicted scenarios</p></a></li>
<li><a href='#plotRiskProfile'><p>Plot the Risk Profiles</p></a></li>
<li><a href='#profRegr'><p>Profile Regression</p></a></li>
<li><a href='#rALD'><p>Asymmetric Laplace Distribution</p></a></li>
<li><a href='#setHyperparams'><p>Definition of characteristics of sample datasets for profile regression</p></a></li>
<li><a href='#simBenchmark'><p>Benchmark for simulated examples</p></a></li>
<li><a href='#summariseVarSelectRho'><p>summariseVarSelectRho</p></a></li>
<li><a href='#vec2mat'><p>Vector to upper triangular matrix</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Dirichlet Process Bayesian Clustering, Profile Regression</td>
</tr>
<tr>
<td>Version:</td>
<td>3.2.13</td>
</tr>
<tr>
<td>Author:</td>
<td>David I. Hastie, Silvia Liverani &lt;liveranis@gmail.com&gt; and Sylvia Richardson with contributions from Aurore J. Lavigne, Lucy Leigh, Lamiae Azizi, Xi Liu, Ruizhu Huang, Austin Gratton, Wei Jing</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Silvia Liverani &lt;liveranis@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Bayesian clustering using a Dirichlet process mixture model. This model is an alternative to regression models, non-parametrically linking a response vector to covariate data through cluster membership. The package allows Bernoulli, Binomial, Poisson, Normal, survival and categorical response, as well as Normal and discrete covariates. It also allows for fixed effects in the response model, where a spatial CAR (conditional autoregressive) term can be also included. Additionally, predictions may be made for the response, and missing values for the covariates are handled. Several samplers and label switching moves are implemented along with diagnostic tools to assess convergence. A number of R functions for post-processing of the output are also provided. In addition to fitting mixtures, it may additionally be of interest to determine which covariates actively drive the mixture components. This is implemented in the package as variable selection. The main reference for the package is Liverani, Hastie, Azizi, Papathomas and Richardson (2015) &lt;<a href="https://doi.org/10.18637%2Fjss.v064.i07">doi:10.18637/jss.v064.i07</a>&gt;.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://www.silvialiverani.com/software/">https://www.silvialiverani.com/software/</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.1)</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 0.12.13), ggplot2 (&ge; 2.2), cluster, plotrix (&ge;
3.6-6), gamlss.dist (&ge; 4.3-1), data.table (&ge; 1.10.4-3), spdep
(&ge; 0.7-7), sf (&ge; 1.0-8)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 1.0.2)</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppEigen (&ge; 0.3.3.3.0), BH (&ge; 1.65.0-1)</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>GNU make</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-01-09 12:57:31 UTC; root</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-01-09 13:30:09 UTC</td>
</tr>
</table>
<hr>
<h2 id='PReMiuM-package'>
Dirichlet Process Bayesian Clustering
</h2><span id='topic+PReMiuMpackage'></span><span id='topic+PReMiuM'></span><span id='topic+PReMiuM-package'></span>

<h3>Description</h3>

<p>Dirichlet process Bayesian clustering and functions for the post-processing of its output. 
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> PReMiuM</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 3.2.9</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2023-06-02</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL2</td>
</tr>
<tr>
 <td style="text-align: left;">
LazyLoad: </td><td style="text-align: left;"> yes</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>Program to implement Dirichlet Process Bayesian Clustering as described in
Liverani et al. 2014. This is a package for Bayesian clustering using a Dirichlet process mixture model. This model is an alternative to regression models, non-parametrically linking a response vector to covariate data through cluster membership. The package allows Bernoulli, Binomial, Poisson, Normal, survival and categorical response, as well as Normal and discrete covariates. It also allows for fixed effects in the response model, where a spatial CAR (conditional autoregressive) term can be also included. Additionally, predictions may be made for the response, and missing values for the covariates are handled. Several samplers and label switching moves are implemented along with diagnostic tools to assess convergence. A number of R functions for post-processing of the output are also provided. In addition to fitting mixtures, it may additionally be of interest to determine which covariates actively drive the mixture components. This is implemented in the package as variable selection. 
</p>
<p>The R package PReMiuM is supported through research grants. One key requirement of such funding applications is the ability to demonstrate the impact of the work we seek funding for can. Whatever you are using PReMiuM for, it would be very helpful for us to learn about our users, to tailor our future methodological developments to your needs. Please email us at liveranis@gmail.com or visit http://www.silvialiverani.com/support-premium/. 
</p>


<h3>Details</h3>

<p><span class="pkg">PReMiuM</span> provides the following:
</p>

<ul>
<li><p> Implements an infinite Dirichlet process model
</p>
</li>
<li><p> Can do dependent or independent slice sampling (Kalli et al., 2011) 
or truncated Dirichlet process model (Ishwaran and James, 2001)
</p>
</li>
<li><p> Handles categorical or Normal covariates, or a mixture of them
</p>
</li>
<li><p> Handles Bernoulli, Binomial, Categorical, Poisson, survival or Normal responses
</p>
</li>
<li><p> Handles inclusion of fixed effects in the response model, including a spatial CAR (conditional autoregressive) term
</p>
</li>
<li><p> Handles Extra Variation in the response (for Bernoulli, Binomial and Poisson response only)
</p>
</li>
<li><p> Handles variable selection (tested in Discrete covariate case only)
</p>
</li>
<li><p> Includes label switching moves for better mixing
</p>
</li>
<li><p> Allows user to exclude the response from the model
</p>
</li>
<li><p> Allows user to compute the entropy of the allocation
</p>
</li>
<li><p> Allows user to run with a fixed alpha or update alpha (default)
</p>
</li>
<li><p> Allows users to run predictive scenarios (at C++ run time)
</p>
</li>
<li><p> Basic or Rao-Blackwellised predictions can be produced
</p>
</li>
<li><p> Handling of missing data
</p>
</li>
<li><p> C++ for model fitting
</p>
</li>
<li><p> Uses Eigen Linear Algebra Library and Boost C++
</p>
</li>
<li><p> Completely self contained (all library code in included in distribution)
</p>
</li>
<li><p> Adaptive MCMC where appropriate
</p>
</li>
<li><p> R package for generating simulation data and post processing
</p>
</li>
<li><p> R plotting functions allow user choice of what to order clusters by
</p>
</li></ul>



<h3>Authors</h3>

<p>David Hastie, Department of Epidemiology and Biostatistics, Imperial College London, UK
</p>
<p>Silvia Liverani, Department of Epidemiology and Biostatistics, Imperial College London and MRC Biostatistics Unit, Cambridge, UK
</p>
<p>Aurore J. Lavigne, Department of Epidemiology and Biostatistics, Imperial College London, UK
</p>
<p>Maintainer: Silvia Liverani &lt;liveranis@gmail.com&gt;
</p>


<h3>Acknowledgements</h3>

<p>Silvia Liverani thanks The Leverhulme Trust for financial support. 
</p>
<p>The R package PReMiuM is supported through research grants. One key requirement of such funding applications is the ability to demonstrate the impact of the work we seek funding for can. Whatever you are using PReMiuM for, it would be very helpful for us to learn about our users, to tailor our future methodological developments to your needs. Please email us at liveranis@gmail.com or visit http://www.silvialiverani.com/support-premium/. 
</p>


<h3>References</h3>

<p>Molitor J, Papathomas M, Jerrett M and Richardson S. (2010) Bayesian Profile Regression with an Application to the National Survey of Children's Health, Biostatistics 11: 484-498.
</p>
<p>Papathomas M, Molitor J, Richardson S. et al (2011) Examining the joint effect of multiple risk factors using exposure risk profiles: lung cancer in non smokers. Environmental Health Perspectives 119: 84-91.
</p>
<p>Hastie, D. I., Liverani, S., Azizi, L., Richardson, S. and Stucker I. (2013) A semi-parametric approach to estimate risk functions associated with multi-dimensional exposure profiles: application to smoking and lung cancer. <em>BMC Medical Research Methodology</em>. 13 (1), 129.
</p>
<p>Molitor, J., Brown, I. J., Papathomas, M., Molitor, N., Liverani, S., Chan, Q., Richardson, S., Van Horn, L., Daviglus, M. L., Stamler, J. and Elliott, P. (2014) Blood pressure differences associated with DASH-like lower sodium compared with typical American higher sodium nutrient profile: INTERMAP USA.
Hypertension 64 (6), 1198-1204. Available at http://www.ncbi.nlm.nih.gov/pubmed/25201893
</p>
<p>Silvia Liverani, David I. Hastie, Lamiae Azizi, Michail Papathomas, Sylvia Richardson (2015). PReMiuM: An R Package for Profile Regression Mixture Models Using Dirichlet Processes. Journal of Statistical Software, 64(7), 1-30. <a href="https://doi.org/10.18637/jss.v064.i07">doi:10.18637/jss.v064.i07</a>.
</p>
<p>Hastie, D. I., Liverani, S. and Richardson, S. (2014) Sampling from Dirichlet process mixture models with unknown concentration parameter: Mixing issues in large data implementations. <em>Statistics and Computing</em>. Available at http://link.springer.com/article/10.1007
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# example for Poisson outcome and Discrete covariates
inputs &lt;- generateSampleDataFile(clusSummaryPoissonDiscrete())
runInfoObj&lt;-profRegr(yModel=inputs$yModel, 
    xModel=inputs$xModel, nSweeps=10, nClusInit=20,
    nBurn=20, data=inputs$inputData, output="output", 
    covNames = inputs$covNames, outcomeT = inputs$outcomeT,
    fixedEffectsNames = inputs$fixedEffectNames)

dissimObj&lt;-calcDissimilarityMatrix(runInfoObj)
clusObj&lt;-calcOptimalClustering(dissimObj)
riskProfileObj&lt;-calcAvgRiskAndProfile(clusObj)
clusterOrderObj&lt;-plotRiskProfile(riskProfileObj,"summary.png")

## End(Not run)
</code></pre>

<hr>
<h2 id='calcAvgRiskAndProfile'>Calculation of the average risks and profiles</h2><span id='topic+calcAvgRiskAndProfile'></span>

<h3>Description</h3>

<p>Calculation of the average risks and profiles.</p>


<h3>Usage</h3>

<pre><code class='language-R'>calcAvgRiskAndProfile(clusObj, includeFixedEffects=F,
    proportionalHazards=F)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calcAvgRiskAndProfile_+3A_clusobj">clusObj</code></td>
<td>
<p>Object of type clusObj.</p>
</td></tr>
<tr><td><code id="calcAvgRiskAndProfile_+3A_includefixedeffects">includeFixedEffects</code></td>
<td>
<p>By default this is set to FALSE. If it is set to FALSE then the risk profile is computed with the parameters beta of the fixed effects assumed equal to zero. If it is set to TRUE, then risk profile at each sweep is computed adjusting for the sample of the beta parameter at that sweep.</p>
</td></tr>
<tr><td><code id="calcAvgRiskAndProfile_+3A_proportionalhazards">proportionalHazards</code></td>
<td>
<p>Whether the risk matrix should include lambda only for the yModel=&quot;Survival&quot; case so that the proportional hazards can be computed in the plotting function. The default is the average survival time.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following components. This is an object of type riskProfileObj.
</p>
<table>
<tr><td><code>riskProfClusObj</code></td>
<td>
<p>The object of type clusObj as given in the input of this function.</p>
</td></tr>
<tr><td><code>risk</code></td>
<td>
<p>A matrix that has a column for each cluster and a row for each sweep. Each element of the matrix represents the estimated risk at each sweep for each cluster.</p>
</td></tr>
<tr><td><code>profile</code></td>
<td>
<p>An array whose first dimension is the number of sweeps, the second is the number of clusters, the third is the number of discrete covariates and the fourth is the number of categories of each of the covariates. Each element of the array represents the covariate profile at each sweep for each cluster. The fourth dimension does not exists if the covariate type is Normal. If the covariate type is mixed, then instead of this element, the two elements below are defined, 'profilePhi' and 'profileMu'.</p>
</td></tr>
<tr><td><code>profileStar</code></td>
<td>
<p>This is NULL if there has not been any variable selection. otherwise it contains the </p>
</td></tr>
<tr><td><code>empiricals</code></td>
<td>
<p>A vector of length of the optimal number of clusters, where each value is the empirical mean of the outcome for each cluster.</p>
</td></tr>
<tr><td><code>profileStdDev</code></td>
<td>
<p>An array whose first dimension is the number of sweeps, the second is the number of clusters, the third and the fourth are the number of continuous covariates. Each square matrix identified by the first and second dimension of the array represents the standard deviation at each sweep for each cluster. This element is only available if the covariate type is continuous or mixed.</p>
</td></tr>
<tr><td><code>profilePhi</code></td>
<td>
<p>This array is the equivalent of the 'profile' above for discrete covariates in case of mixed covariates.</p>
</td></tr>
<tr><td><code>profileStarPhi</code></td>
<td>
<p>This array is defined as profile and profilePhi, but the values are computed only if a variable selection procedure has been run. The definition of the star profile is given in Liverani, S., Hastie, D. I. and Richardson, S. (2013) PReMiuM: An R package for Bayesian profile regression.</p>
</td></tr>
<tr><td><code>profileMu</code></td>
<td>
<p>This array is the equivalent of the 'profile' above for Normal covariates in case of mixed covariates.</p>
</td></tr>
<tr><td><code>profileStarMu</code></td>
<td>
<p>This array is defined as profile and profileMu, but the values are computed only if a variable selection procedure has been run. The definition of the star profile is given in Liverani, S., Hastie, D. I. and Richardson, S. (2013) PReMiuM: An R package for Bayesian profile regression.</p>
</td></tr>
<tr><td><code>nuArray</code></td>
<td>
<p>For yModel=Survival when weibullFixedShape=FALSE this array contains the sampled values of the shape parameter nu. The first dimension is the number of sweeps, the second is the number of clusters.</p>
</td></tr>
</table>


<h3>Authors</h3>

<p>David Hastie, Department of Epidemiology and Biostatistics, Imperial College London, UK
</p>
<p>Silvia Liverani, Department of Epidemiology and Biostatistics, Imperial College London and MRC Biostatistics Unit, Cambridge, UK
</p>
<p>Maintainer: Silvia Liverani &lt;liveranis@gmail.com&gt;
</p>


<h3>References</h3>

<p>Silvia Liverani, David I. Hastie, Lamiae Azizi, Michail Papathomas, Sylvia Richardson (2015). PReMiuM: An R Package for Profile Regression Mixture Models Using Dirichlet Processes. Journal of Statistical Software, 64(7), 1-30. <a href="https://doi.org/10.18637/jss.v064.i07">doi:10.18637/jss.v064.i07</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
generateDataList &lt;- clusSummaryBernoulliDiscrete()
inputs &lt;- generateSampleDataFile(generateDataList)
runInfoObj&lt;-profRegr(yModel=inputs$yModel, xModel=inputs$xModel, nSweeps=10, 
    nBurn=20, data=inputs$inputData, output="output", nClusInit=15,
    covNames=inputs$covNames)

dissimObj&lt;-calcDissimilarityMatrix(runInfoObj)
clusObj&lt;-calcOptimalClustering(dissimObj)
riskProfileObj&lt;-calcAvgRiskAndProfile(clusObj)

## End(Not run)
</code></pre>

<hr>
<h2 id='calcDissimilarityMatrix'>Calculates the dissimilarity matrix</h2><span id='topic+calcDissimilarityMatrix'></span>

<h3>Description</h3>

<p>Calculates the dissimilarity matrix.</p>


<h3>Usage</h3>

<pre><code class='language-R'>calcDissimilarityMatrix(runInfoObj, onlyLS=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calcDissimilarityMatrix_+3A_runinfoobj">runInfoObj</code></td>
<td>
<p>Object of type runInfoObj.</p>
</td></tr>
<tr><td><code id="calcDissimilarityMatrix_+3A_onlyls">onlyLS</code></td>
<td>
<p>Logical. It is set to FALSE by default. When it is equal to TRUE the dissimilarity matrix is not returned and the only method available to identify the optimal partition using 'calcOptimalClustering' is least squares. This parameter is to be used for datasets with many subjects, as C++ can compute the dissimilarity matrix but it cannot pass it to R for usage in the function 'calcOptimalClustering'. As guidance, be aware that a dataset with 85,000 subjects will require a RAM of about 26Gb, even if onlyLS=TRUE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Need to write this 
</p>
<table>
<tr><td><code>disSimRunInfoObj</code></td>
<td>
<p>These are details regarding the run and in the same format as runInfoObj.</p>
</td></tr>
<tr><td><code>disSimMat</code></td>
<td>
<p>The dissimilarity matrix, in vector format. Note that it is diagonal, so this contains the upper triangle diagonal entries.</p>
</td></tr>
<tr><td><code>disSimMatPred</code></td>
<td>
<p>The dissimilarity matrix, again in vector format as above, for the predicted subjects.</p>
</td></tr>
<tr><td><code>lsOptSweep</code></td>
<td>
<p>The optimal partition among those explored by the MCMC, as defined by the least squares method. See Dahl (2006).</p>
</td></tr>
<tr><td><code>onlyLS</code></td>
<td>
<p>Logical. If it set to TRUE the only method available to identify the optimal partition using 'calcOptimalClustering' is least squares.</p>
</td></tr>
</table>


<h3>Authors</h3>

<p>David Hastie, Department of Epidemiology and Biostatistics, Imperial College London, UK
</p>
<p>Silvia Liverani, Department of Epidemiology and Biostatistics, Imperial College London and MRC Biostatistics Unit, Cambridge, UK
</p>
<p>Maintainer: Silvia Liverani &lt;liveranis@gmail.com&gt;
</p>


<h3>References</h3>

<p>Silvia Liverani, David I. Hastie, Lamiae Azizi, Michail Papathomas, Sylvia Richardson (2015). PReMiuM: An R Package for Profile Regression Mixture Models Using Dirichlet Processes. Journal of Statistical Software, 64(7), 1-30. <a href="https://doi.org/10.18637/jss.v064.i07">doi:10.18637/jss.v064.i07</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
generateDataList &lt;- clusSummaryBernoulliDiscrete()
inputs &lt;- generateSampleDataFile(generateDataList)
runInfoObj&lt;-profRegr(yModel=inputs$yModel, xModel=inputs$xModel, 
    nSweeps=10, nBurn=20, data=inputs$inputData, output="output", 
    covNames=inputs$covNames,nClusInit=15)

dissimObj&lt;-calcDissimilarityMatrix(runInfoObj)

## End(Not run)
</code></pre>

<hr>
<h2 id='calcOptimalClustering'>Calculation of the optimal clustering</h2><span id='topic+calcOptimalClustering'></span>

<h3>Description</h3>

<p>Calculates the optimal clustering.</p>


<h3>Usage</h3>

<pre><code class='language-R'>calcOptimalClustering(disSimObj, maxNClusters=NULL, useLS=F)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calcOptimalClustering_+3A_dissimobj">disSimObj</code></td>
<td>
<p>A dissimilarity matrix (in vector format, as the output of the function calcDissimilarityMatrix(), and as described in ?calcDissimilarityMatrix) or a list of dissimilarity matrix, to combine the output of several runs of the MCMC.</p>
</td></tr>
<tr><td><code id="calcOptimalClustering_+3A_maxnclusters">maxNClusters</code></td>
<td>
<p>Set the maximum number of clusters allowed. This is set to the maximum number explored.</p>
</td></tr>
<tr><td><code id="calcOptimalClustering_+3A_usels">useLS</code></td>
<td>
<p>This is set to FALSE by default. If it is set to TRUE then the least-squares method is used for the calculation of the optimal clustering, as described in Molitor et al (2010). Note that this is set to TRUE by default if disSimObj$onlyLS is set to TRUE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the output is a list with the following elements. This is an object of type clusObj.
</p>
<table>
<tr><td><code>clusObjRunInfoObj</code></td>
<td>
<p>Details on this run. An object of type runInfoObj.</p>
</td></tr>
<tr><td><code>clusterSizes</code></td>
<td>
<p>Cluster sizes.</p>
</td></tr>
<tr><td><code>clusteringPred</code></td>
<td>
<p>The predicted cluster memberships for the predicted scenarios.</p>
</td></tr>
<tr><td><code>clusObjDisSimMat</code></td>
<td>
<p>Dissimilarity matrix.</p>
</td></tr>
<tr><td><code>clustering</code></td>
<td>
<p>Cluster memberships.</p>
</td></tr>
<tr><td><code>nClusters</code></td>
<td>
<p>Optimal number of clusters.</p>
</td></tr>
<tr><td><code>avgSilhouetteWidth</code></td>
<td>
<p>Average silhouette width when using medoids method for clustering.</p>
</td></tr>
</table>


<h3>Authors</h3>

<p>David Hastie, Department of Epidemiology and Biostatistics, Imperial College London, UK
</p>
<p>Silvia Liverani, Department of Epidemiology and Biostatistics, Imperial College London and MRC Biostatistics Unit, Cambridge, UK
</p>
<p>Maintainer: Silvia Liverani &lt;liveranis@gmail.com&gt;
</p>


<h3>References</h3>

<p>Silvia Liverani, David I. Hastie, Lamiae Azizi, Michail Papathomas, Sylvia Richardson (2015). PReMiuM: An R Package for Profile Regression Mixture Models Using Dirichlet Processes. Journal of Statistical Software, 64(7), 1-30. <a href="https://doi.org/10.18637/jss.v064.i07">doi:10.18637/jss.v064.i07</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
generateDataList &lt;- clusSummaryBernoulliDiscrete()
inputs &lt;- generateSampleDataFile(generateDataList)
runInfoObj&lt;-profRegr(yModel=inputs$yModel, xModel=inputs$xModel, 
    nSweeps=10, nBurn=20, data=inputs$inputData, output="output", 
    covNames=inputs$covNames, nClusInit=15)

dissimObj&lt;-calcDissimilarityMatrix(runInfoObj)
clusObj&lt;-calcOptimalClustering(dissimObj)

## End(Not run)
</code></pre>

<hr>
<h2 id='calcPredictions'>Calculates the predictions</h2><span id='topic+calcPredictions'></span>

<h3>Description</h3>

<p>Calculates the predictions.</p>


<h3>Usage</h3>

<pre><code class='language-R'>calcPredictions(riskProfObj, predictResponseFileName=NULL,
    doRaoBlackwell=F, fullSweepPredictions=F, fullSweepLogOR=F,
    fullSweepHazardRatio=F,referenceClusterOR=NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calcPredictions_+3A_riskprofobj">riskProfObj</code></td>
<td>
<p>Object of type riskProfObj.</p>
</td></tr>
<tr><td><code id="calcPredictions_+3A_predictresponsefilename">predictResponseFileName</code></td>
<td>
<p>If this function is run after the function profRegr, and outcome (and possibly fixed effects) are known for the predicted profiles, then there is no need to set this, as the function profRegr will have produced a file ending in &quot;_predictFull.txt&quot;. This file allows the computation of measures of fit for cross-validation. If the file has not been produced automatically, it can be produced manually and it can be provided here. We discourage this and we provide no documentation for doing so.</p>
</td></tr>
<tr><td><code id="calcPredictions_+3A_doraoblackwell">doRaoBlackwell</code></td>
<td>
<p>By default this is set to FALSE. If it is set to TRUE then Rao-Blackwell predictions are computed.</p>
</td></tr>
<tr><td><code id="calcPredictions_+3A_fullsweeppredictions">fullSweepPredictions</code></td>
<td>
<p>By default this is set to FALSE. If it is set to TRUE then a prediction is computed for each sweep.</p>
</td></tr>
<tr><td><code id="calcPredictions_+3A_fullsweeplogor">fullSweepLogOR</code></td>
<td>
<p>By default this is set to FALSE. If it is set to TRUE then a prediction log OR is computed for each sweep.</p>
</td></tr>
<tr><td><code id="calcPredictions_+3A_fullsweephazardratio">fullSweepHazardRatio</code></td>
<td>
<p>By default this is set to FALSE. If it is set to TRUE then a prediction hazard ratio is computed for each sweep, only for Survival response.</p>
</td></tr>
<tr><td><code id="calcPredictions_+3A_referenceclusteror">referenceClusterOR</code></td>
<td>
<p>The cluster of reference for the odds ratios. If this is not provided then the first of the predictive profiles provided is used as the reference.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The output is a list with the following elements.
</p>
<table>
<tr><td><code>bias</code></td>
<td>
<p>The bias of the predicted values with respect to the observed outcome. If the response is not provided, this is set to NA.</p>
</td></tr>
<tr><td><code>rmse</code></td>
<td>
<p>The root mean square error of the predicted values with respect to the observed outcome. If the response is not provided, this is set to NA.</p>
</td></tr>
<tr><td><code>mae</code></td>
<td>
<p>The mean absolute error of the predicted values with respect to the observed outcome. If the response is not provided, this is set to NA.</p>
</td></tr>
<tr><td><code>observedY</code></td>
<td>
<p>The values of the outcome provided by the user. This is in the case that predictions are run as a validation tool. If the response is not provided, this is set to NA.</p>
</td></tr>
<tr><td><code>predictedY</code></td>
<td>
<p>This matrix has as many rows as predictions requested by the user. It is the median of the predicted values over all the sweeps that have been run after the burn-in period.</p>
</td></tr>
<tr><td><code>doRaoBlackwell</code></td>
<td>
<p>This is set to TRUE if it has done Rao-Blackwell predictions, and FALSE otherwise.</p>
</td></tr>
<tr><td><code>predictedYPerSweep</code></td>
<td>
<p>This array has the first dimension equivalent to the number of sweeps and the second dimension as large as the number of predictions requested by the user. It contains the predicted values per sweep.</p>
</td></tr>
<tr><td><code>logORPerSweep</code></td>
<td>
<p>This array has the first dimension equivalent to the number of sweeps and the second dimension as large as the number of predictions requested by the user. It contains the predicted log OR values per sweep (not available for Poisson and Normal outcome).</p>
</td></tr>
<tr><td><code>fullHR</code></td>
<td>
<p>This array has the first dimension equivalent to the number of sweeps and the second dimension as large as the number of predictions requested by the user. It contains the predicted hazard ratio values per sweep (only for Survival outcome).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This functions computes predicted responses, for various prediction scenarios. It is assumed that the predictive
allocations and Rao-Blackwell predictions have already been done in profRegr using the 'predict' input. 
</p>
<p>The user can provide the function profRegr with a data.frame through the predict argument. This data.frame has a row for each subject, where each row contains values for the response, fixed effects and offset / number of trials (depending
on the response model) where available. Missing values in this data.frame are denoted by 'NA'. If the data.frame is not provided then the response, fixed effect and offset data is treated as missing for all subjects. If a subject is missing fixed
effect values, then the mean value or 0 category fixed effect is used in the
predictions (i.e. no fixed effect contribution to predicted response). If the
offset / number of trials is missing this value is taken to be 1 when making
predictions. If the response is provided for all subjects, the predicted
responses are compared with the observed responses and the bias and rmse are
computed. If the response is provided in the data frame it must be in a column called &quot;outcome&quot;. 
</p>
<p>The function can produce predicted values based on simple allocations
(the default), or a Rao-Blackwellised estimate of predictions, where
the probabilities of allocations are used instead of actually performing a
random allocation.
</p>


<h3>Authors</h3>

<p>David Hastie, Department of Epidemiology and Biostatistics, Imperial College London, UK
</p>
<p>Silvia Liverani, Department of Epidemiology and Biostatistics, Imperial College London and MRC Biostatistics Unit, Cambridge, UK
</p>
<p>Maintainer: Silvia Liverani &lt;liveranis@gmail.com&gt;
</p>


<h3>References</h3>

<p>Silvia Liverani, David I. Hastie, Lamiae Azizi, Michail Papathomas, Sylvia Richardson (2015). PReMiuM: An R Package for Profile Regression Mixture Models Using Dirichlet Processes. Journal of Statistical Software, 64(7), 1-30. <a href="https://doi.org/10.18637/jss.v064.i07">doi:10.18637/jss.v064.i07</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
inputs &lt;- generateSampleDataFile(clusSummaryBernoulliDiscrete())
     
# prediction profiles
preds&lt;-data.frame(matrix(c(0, 0, 1, 0, 0,
0, 0, 1, NA, 0),ncol=5,byrow=TRUE))
colnames(preds)&lt;-names(inputs$inputData)[2:(inputs$nCovariates+1)]
     
# run profile regression
runInfoObj&lt;-profRegr(yModel=inputs$yModel, xModel=inputs$xModel, 
    nSweeps=100, nBurn=1000, data=inputs$inputData, output="output", 
    covNames=inputs$covNames,predict=preds)
     
# postprocessing
dissimObj &lt;- calcDissimilarityMatrix(runInfoObj)
clusObj &lt;- calcOptimalClustering(dissimObj)
riskProfileObj &lt;- calcAvgRiskAndProfile(clusObj)
clusterOrderObj &lt;- plotRiskProfile(riskProfileObj,"summary.png",
    whichCovariates=c(1,2))
output_predictions &lt;- calcPredictions(riskProfileObj,fullSweepPredictions=TRUE)

# example where the fixed effects can be provided for prediction 
# but the observed response is missing 
# (there are 2 fixed effects in this example). 
# in this example we also use the Rao Blackwellised predictions

inputs &lt;- generateSampleDataFile(clusSummaryPoissonNormal())

# prediction profiles
predsPoisson&lt;- data.frame(matrix(c(7, 2.27, -0.66, 1.07, 9, 
     -0.01, -0.18, 0.91, 12, -0.09, -1.76, 1.04, 16, 1.55, 1.20, 0.89,
     10, -1.35, 0.79, 0.95),ncol=5,byrow=TRUE))
colnames(predsPoisson)&lt;-names(inputs$inputData)[2:(inputs$nCovariates+1)]

# run profile regression
runInfoObj&lt;-profRegr(yModel=inputs$yModel, 
         xModel=inputs$xModel, nSweeps=100, 
         nBurn=100, data=inputs$inputData, output="output", 
         covNames = inputs$covNames, outcomeT="outcomeT",
         fixedEffectsNames = inputs$fixedEffectNames,predict=predsPoisson)

# postprocessing
dissimObj&lt;-calcDissimilarityMatrix(runInfoObj)
clusObj&lt;-calcOptimalClustering(dissimObj)
riskProfileObj&lt;-calcAvgRiskAndProfile(clusObj)
output_predictions &lt;- calcPredictions(riskProfileObj,fullSweepPredictions=TRUE)


# example where both the observed response and fixed effects are present 
#(there are no fixed effects in this example, but 
# these would just be added as columns between the first and last columns). 

inputs &lt;- generateSampleDataFile(clusSummaryPoissonNormal())

# prediction profiles
predsPoisson&lt;- data.frame(matrix(c(NA, 2.27, -0.66, 1.07, NA, 
     -0.01, -0.18, 0.91, NA, -0.09, -1.76, 1.04, NA, 1.55, 1.20, 0.89,
     NA, -1.35, 0.79, 0.95),ncol=5,byrow=TRUE))
colnames(predsPoisson)&lt;-names(inputs$inputData)[2:(inputs$nCovariates+1)]

# run profile regression
runInfoObj&lt;-profRegr(yModel=inputs$yModel, 
         xModel=inputs$xModel, nSweeps=10, 
         nBurn=20, data=inputs$inputData, output="output", 
         covNames = inputs$covNames, outcomeT="outcomeT",
         fixedEffectsNames = inputs$fixedEffectNames,
         nClusInit=15, predict=predsPoisson)

# postprocessing
dissimObj&lt;-calcDissimilarityMatrix(runInfoObj)
clusObj&lt;-calcOptimalClustering(dissimObj)
riskProfileObj&lt;-calcAvgRiskAndProfile(clusObj)
output_predictions &lt;- calcPredictions(riskProfileObj,fullSweepPredictions=TRUE)


## End(Not run)
</code></pre>

<hr>
<h2 id='clusSummaryBernoulliDiscrete'>Sample datasets for profile regression</h2><span id='topic+clusSummaryBernoulliDiscrete'></span><span id='topic+clusSummaryBernoulliNormal'></span><span id='topic+clusSummaryBernoulliDiscreteSmall'></span><span id='topic+clusSummaryBinomialNormal'></span><span id='topic+clusSummaryCategoricalDiscrete'></span><span id='topic+clusSummaryNormalDiscrete'></span><span id='topic+clusSummaryNormalNormal'></span><span id='topic+clusSummaryNormalNormalSpatial'></span><span id='topic+clusSummaryPoissonDiscrete'></span><span id='topic+clusSummaryPoissonNormal'></span><span id='topic+clusSummaryPoissonNormalSpatial'></span><span id='topic+clusSummaryVarSelectBernoulliDiscrete'></span><span id='topic+clusSummaryBernoulliMixed'></span><span id='topic+clusSummaryWeibullDiscrete'></span><span id='topic+clusSummaryQuantileNormal'></span><span id='topic+clusSummaryGammaNormal'></span>

<h3>Description</h3>

<p>Definition of skeleton of sample datasets for profile regression.</p>


<h3>Usage</h3>

<pre><code class='language-R'>clusSummaryBernoulliDiscrete()
clusSummaryBernoulliNormal
clusSummaryBernoulliDiscreteSmall()
clusSummaryBinomialNormal()
clusSummaryCategoricalDiscrete()
clusSummaryNormalDiscrete()
clusSummaryNormalNormal()
clusSummaryNormalNormalSpatial()
clusSummaryPoissonDiscrete()
clusSummaryPoissonNormal()
clusSummaryPoissonNormalSpatial()
clusSummaryVarSelectBernoulliDiscrete()
clusSummaryBernoulliMixed()
clusSummaryWeibullDiscrete()
clusSummaryQuantileNormal()
clusSummaryGammaNormal()
</code></pre>


<h3>Value</h3>

<p>The output of these function is a list with the following components. These can be used as inputs for profile regression function profRegr().
</p>
<table>
<tr><td><code>outcomeType</code></td>
<td>
<p>The outcome type of the dataset.</p>
</td></tr>
<tr><td><code>covariateType</code></td>
<td>
<p>The covariate type of the dataset.</p>
</td></tr>
<tr><td><code>nCovariates</code></td>
<td>
<p>The number of covariates generated.</p>
</td></tr>
<tr><td><code>nCategories</code></td>
<td>
<p>The number of categories of the covariates if the covariates are discrete or mixed.</p>
</td></tr>
<tr><td><code>nFixedEffects</code></td>
<td>
<p>The number of fixed effects.</p>
</td></tr>
<tr><td><code>fixedEffectsCoeffs</code></td>
<td>
<p>The names of the fixed effects.</p>
</td></tr>
<tr><td><code>missingDataProb</code></td>
<td>
<p>The pobability of generating missing data.</p>
</td></tr>
<tr><td><code>nClusters</code></td>
<td>
<p>The number of clusters.</p>
</td></tr>
<tr><td><code>clusterSizes</code></td>
<td>
<p>The number of observations in each cluster.</p>
</td></tr>
<tr><td><code>clusterData</code></td>
<td>
<p>The dataset, including the outcome, the covariates, the fixed effects, the number of trials (if Binomial outcome) and the offset (for Poisson outcome).</p>
</td></tr>
<tr><td><code>covNames</code></td>
<td>
<p>The names of the covariates of the dataset.</p>
</td></tr>
<tr><td><code>nDiscreteCovs</code></td>
<td>
<p>The number of discrete covariates, if the covariate type is mixed.</p>
</td></tr>
<tr><td><code>nContinuousCovs</code></td>
<td>
<p>The number of continuous covariates, if the covariate type is mixed.</p>
</td></tr>
<tr><td><code>outcomeT</code></td>
<td>
<p>The name of the column of the dataset containing the number of trials (if Binomial outcome) or the offset (for Poisson outcome).</p>
</td></tr>
<tr><td><code>includeCAR</code></td>
<td>
<p>A boolean specifying wether a spatial CAR term is included.</p>
</td></tr>
<tr><td><code>TauCAR</code></td>
<td>
<p>The precision for the spatial CAR term.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>clusSummaryBernoulliDiscrete generates a dataset with Bernoulli outcome and discrete covariates.
</p>
<p>clusSummaryBernoulliNormal generates a dataset with Bernoulli outcome and Normal covariates.
</p>
<p>clusSummaryBernoulliDiscreteSmall generates a dataset with Bernoulli outcome and discrete covariates (with smaller cluster sizes).
</p>
<p>clusSummaryBinomialNormal generates a dataset with Binomial outcome and discrete covariates.
</p>
<p>clusSummaryCategoricalDiscrete generates a dataset with categorical outcome and discrete covariates.
</p>
<p>clusSummaryNormalDiscrete generates a dataset with Normal outcome and discrete covariates.
</p>
<p>clusSummaryNormalNormal generates a dataset with Normal outcome and Normal covariates.
</p>
<p>clusSummaryNormalNormalSpatial generates a dataset with Normal outcome, Normal covariates and a spatial conditional autoregressive term in the log relative risk.
</p>
<p>clusSummaryPoissonDiscrete generates a dataset with Poisson outcome and discrete covariates.
</p>
<p>clusSummaryPoissonNormal generates a dataset with Poisson outcome and Normal covariates.
</p>
<p>clusSummaryPoissonNormalSpatial generates a dataset with Poisson outcome, Normal covariates and a spatial conditional autoregressive term in the log relative risk.
</p>
<p>clusSummaryVarSelectBernoulliDiscrete generates a dataset with Bernoulli outcome and discrete covariates, suitable for variable selection as some covariates are not driving the clustering.
</p>
<p>clusSummaryBernoulliMixed generates a dataset with Bernoulli outcome and mixed covariates.
</p>
<p>clusSummaryWeibullDiscrete generates a dataset with a Weibull outcome and censored observations.
</p>
<p>clusSummaryQuantileNormal generates a dataset with a Quantile outcome.
</p>
<p>clusSummaryGammaNormal generates a dataset with a Gamma outcome with scale=1.
</p>


<h3>Authors</h3>

<p>David Hastie, Department of Epidemiology and Biostatistics, Imperial College London, UK
</p>
<p>Silvia Liverani, Department of Epidemiology and Biostatistics, Imperial College London and MRC Biostatistics Unit, Cambridge, UK
</p>
<p>Aurore J. Lavigne, Department of Epidemiology and Biostatistics, Imperial College London, UK
</p>
<p>Maintainer: Silvia Liverani &lt;liveranis@gmail.com&gt;
</p>


<h3>References</h3>

<p>Silvia Liverani, David I. Hastie, Lamiae Azizi, Michail Papathomas, Sylvia Richardson (2015). PReMiuM: An R Package for Profile Regression Mixture Models Using Dirichlet Processes. Journal of Statistical Software, 64(7), 1-30. <a href="https://doi.org/10.18637/jss.v064.i07">doi:10.18637/jss.v064.i07</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>names(clusSummaryBernoulliDiscrete())

</code></pre>

<hr>
<h2 id='computeRatioOfVariance'>computeRatioOfVariance</h2><span id='topic+computeRatioOfVariance'></span>

<h3>Description</h3>

<p>Computes of the ratio between the variance of the extra variation and the total variance.</p>


<h3>Usage</h3>

<pre><code class='language-R'>computeRatioOfVariance(runInfoObj)
</code></pre>


<h3>Arguments</h3>

<p>This function can only be used when the extra variation is included in the response model.
</p>
<table>
<tr><td><code id="computeRatioOfVariance_+3A_runinfoobj">runInfoObj</code></td>
<td>
<p>Object of type runInfoObj</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For each sweep this function outputs the ratio between the variance of the thetas' and the sum of the variances of the thetas' and the extra variation epsilon as described in Liverani et al. (2013). 
</p>


<h3>Authors</h3>

<p>David Hastie, Department of Epidemiology and Biostatistics, Imperial College London, UK
</p>
<p>Silvia Liverani, Department of Epidemiology and Biostatistics, Imperial College London and MRC Biostatistics Unit, Cambridge, UK
</p>
<p>Maintainer: Silvia Liverani &lt;liveranis@gmail.com&gt;
</p>


<h3>References</h3>

<p>Silvia Liverani, David I. Hastie, Lamiae Azizi, Michail Papathomas, Sylvia Richardson (2015). PReMiuM: An R Package for Profile Regression Mixture Models Using Dirichlet Processes. Journal of Statistical Software, 64(7), 1-30. <a href="https://doi.org/10.18637/jss.v064.i07">doi:10.18637/jss.v064.i07</a>.
</p>

<hr>
<h2 id='generateSampleDataFile'>Generate sample data files for profile regression</h2><span id='topic+generateSampleDataFile'></span>

<h3>Description</h3>

<p>Generation of random sample datasets for profile regression.</p>


<h3>Usage</h3>

<pre><code class='language-R'>generateSampleDataFile(clusterSummary, pQuantile=0.05)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generateSampleDataFile_+3A_clustersummary">clusterSummary</code></td>
<td>
<p>A vector of strings of the covariate names as by the column names in the data argument.</p>
</td></tr>
<tr><td><code id="generateSampleDataFile_+3A_pquantile">pQuantile</code></td>
<td>
<p>pQuantile is the quantile parameter of the Asymmetric Laplace Distribution used to generate data to test the model for the quantiles.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The output of this function is a list with the following elements
</p>
<table>
<tr><td><code>yModel</code></td>
<td>
<p>The outcome model according to which the data has been generated.</p>
</td></tr>
<tr><td><code>xModel</code></td>
<td>
<p>The covariate model according to which the data has been generated.</p>
</td></tr>
<tr><td><code>inputData</code></td>
<td>
<p>The data.frame that contains the data.</p>
</td></tr>
<tr><td><code>covNames</code></td>
<td>
<p>The names of the covariates.</p>
</td></tr>
<tr><td><code>fixedEffectNames</code></td>
<td>
<p>The names of the fixed effects.</p>
</td></tr>
<tr><td><code>uCAR</code></td>
<td>
<p>The spatial gaussian effect. It is sample into the intrinsic autoregressive model with precision TauCAR under the constraint that the sum of term is null. Only used if includeCAR is TRUE.</p>
</td></tr>
<tr><td><code>TauCAR</code></td>
<td>
<p>The precision of the spatial CAR effect. Only used if includeCAR is TRUE.</p>
</td></tr>
<tr><td><code>Permutation</code></td>
<td>
<p>A vector of size nSubject given the cluster name of each subject. When spatial CAR is added to the model, for preventing potential identifiability problems, the clusters are randomly distributed within the all subjects. Only used if includeCAR is TRUE.</p>
</td></tr>
</table>


<h3>Authors</h3>

<p>David Hastie, Department of Epidemiology and Biostatistics, Imperial College London, UK
</p>
<p>Silvia Liverani, Department of Epidemiology and Biostatistics, Imperial College London and MRC Biostatistics Unit, Cambridge, UK
</p>
<p>Aurore J. Lavigne, Department of Epidemiology and Biostatistics, Imperial College London, UK
</p>
<p>Maintainer: Silvia Liverani &lt;liveranis@gmail.com&gt;
</p>


<h3>References</h3>

<p>Silvia Liverani, David I. Hastie, Lamiae Azizi, Michail Papathomas, Sylvia Richardson (2015). PReMiuM: An R Package for Profile Regression Mixture Models Using Dirichlet Processes. Journal of Statistical Software, 64(7), 1-30. <a href="https://doi.org/10.18637/jss.v064.i07">doi:10.18637/jss.v064.i07</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># generation of data for clustering

generateDataList &lt;- clusSummaryBernoulliDiscrete()
inputs &lt;- generateSampleDataFile(generateDataList)

</code></pre>

<hr>
<h2 id='globalParsTrace'>Plot of the trace of some of the global parameters</h2><span id='topic+globalParsTrace'></span>

<h3>Description</h3>

<p>Function to lot the trace of some global parameters</p>


<h3>Usage</h3>

<pre><code class='language-R'>globalParsTrace(runInfoObj, parameters = "nClusters",plotBurnIn=FALSE,whichBeta=1)
</code></pre>


<h3>Arguments</h3>

<p>This function allows to visualise the trace of the global parameters. 
</p>
<p>Note that this function has not been optimised for large datasets. 
</p>
<table>
<tr><td><code id="globalParsTrace_+3A_runinfoobj">runInfoObj</code></td>
<td>
<p>An object of class runInfoObj.</p>
</td></tr>
<tr><td><code id="globalParsTrace_+3A_parameters">parameters</code></td>
<td>
<p>The parameter whose trace will be plotted. This can be set equal to &quot;nClusters&quot; (default), &quot;alpha&quot;, &quot;mpp&quot; and &quot;beta&quot;, as by the model. As beta can be a vector, we advise to also set the option &quot;whichBeta&quot; below to select which fixed effect parameter to visualise in the plot. &quot;mpp&quot; stands for marginal partition posterior, also referred to as marginal model posterior. </p>
</td></tr>
<tr><td><code id="globalParsTrace_+3A_plotburnin">plotBurnIn</code></td>
<td>
<p>Set to FALSE (default) it does not plot the trace for the burn in period. Set to TRUE it plots the trace including the burn in period.</p>
</td></tr>
<tr><td><code id="globalParsTrace_+3A_whichbeta">whichBeta</code></td>
<td>
<p>Integer which selects which fixed effect parameter is plotted.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Plot of trace of some global parameters.
</p>


<h3>Authors</h3>

<p>Silvia Liverani, Department of Epidemiology and Biostatistics, Imperial College London and MRC Biostatistics Unit, Cambridge, UK
</p>
<p>Maintainer: Silvia Liverani &lt;liveranis@gmail.com&gt;
</p>


<h3>References</h3>

<p>Silvia Liverani, David I. Hastie, Lamiae Azizi, Michail Papathomas, Sylvia Richardson (2015). PReMiuM: An R Package for Profile Regression Mixture Models Using Dirichlet Processes. Journal of Statistical Software, 64(7), 1-30. <a href="https://doi.org/10.18637/jss.v064.i07">doi:10.18637/jss.v064.i07</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# generate simulated dataset
generateDataList &lt;- clusSummaryBernoulliDiscreteSmall()
inputs &lt;- generateSampleDataFile(generateDataList)

# run profile regression
runInfoObj&lt;-profRegr(yModel=inputs$yModel, xModel=inputs$xModel, 
 nSweeps=10, nBurn=20, data=inputs$inputData, output="output", nFilter=3,
 covNames=inputs$covNames,nClusInit=15,reportBurnIn=FALSE,
 fixedEffectsNames = inputs$fixedEffectNames)

# plot trace for alpha
globalParsTrace(runInfoObj,parameters="alpha",plotBurnIn=FALSE)

## End(Not run)
</code></pre>

<hr>
<h2 id='heatDissMat'>Plot the heatmap of the dissimilarity matrix</h2><span id='topic+heatDissMat'></span>

<h3>Description</h3>

<p>Function to plot the heatmap of the dissimilarity matrix</p>


<h3>Usage</h3>

<pre><code class='language-R'>heatDissMat(dissimObj, main=NULL, xlab=NULL, ylab=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="heatDissMat_+3A_dissimobj">dissimObj</code></td>
<td>
<p>An object of class dissimObj.</p>
</td></tr>
<tr><td><code id="heatDissMat_+3A_main">main</code></td>
<td>
<p>The usual plot option, to be passed to the heatmap function.</p>
</td></tr>
<tr><td><code id="heatDissMat_+3A_ylab">ylab</code></td>
<td>
<p>The usual plot option, to be passed to the heatmap function.</p>
</td></tr>
<tr><td><code id="heatDissMat_+3A_xlab">xlab</code></td>
<td>
<p>The usual plot option, to be passed to the heatmap function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Plot of the heatmap of the dissimilary matrix. This functions uses the function 'heatmap' of package 'stats'. Note that this function has not been optimised for large datasets. 
</p>


<h3>Authors</h3>

<p>Silvia Liverani, Department of Epidemiology and Biostatistics, Imperial College London and MRC Biostatistics Unit, Cambridge, UK
</p>
<p>Maintainer: Silvia Liverani &lt;liveranis@gmail.com&gt;
</p>


<h3>References</h3>

<p>Silvia Liverani, David I. Hastie, Lamiae Azizi, Michail Papathomas, Sylvia Richardson (2015). PReMiuM: An R Package for Profile Regression Mixture Models Using Dirichlet Processes. Journal of Statistical Software, 64(7), 1-30. <a href="https://doi.org/10.18637/jss.v064.i07">doi:10.18637/jss.v064.i07</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# generate simulated dataset
generateDataList &lt;- clusSummaryBernoulliDiscreteSmall()
inputs &lt;- generateSampleDataFile(generateDataList)

# run profile regression
runInfoObj&lt;-profRegr(yModel=inputs$yModel, xModel=inputs$xModel, 
 nSweeps=10, nBurn=2000, data=inputs$inputData, output="output", 
 covNames=inputs$covNames,nClusInit=15)

# compute dissimilarity matrix     
dissimObj&lt;-calcDissimilarityMatrix(runInfoObj)

# plot heatmap
heatDissMat(dissimObj)

## End(Not run)
</code></pre>

<hr>
<h2 id='is.wholenumber'>Function to check if a number is a whole number</h2><span id='topic+is.wholenumber'></span>

<h3>Description</h3>

<p>Function to check if a number is whole, accounting for a rounding error.</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.wholenumber(x, tol = .Machine$double.eps^0.5) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.wholenumber_+3A_x">x</code></td>
<td>
<p>The number to be checked.</p>
</td></tr>
<tr><td><code id="is.wholenumber_+3A_tol">tol</code></td>
<td>
<p>Tolerance level.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The default method for 'is.wholenumber' returns 'TRUE' if the number provided is a whole number.
</p>


<h3>Authors</h3>

<p>David Hastie, Department of Epidemiology and Biostatistics, Imperial College London, UK
</p>
<p>Silvia Liverani, Department of Epidemiology and Biostatistics, Imperial College London and MRC Biostatistics Unit, Cambridge, UK
</p>
<p>Maintainer: Silvia Liverani &lt;liveranis@gmail.com&gt;
</p>


<h3>References</h3>

<p>Silvia Liverani, David I. Hastie, Lamiae Azizi, Michail Papathomas, Sylvia Richardson (2015). PReMiuM: An R Package for Profile Regression Mixture Models Using Dirichlet Processes. Journal of Statistical Software, 64(7), 1-30. <a href="https://doi.org/10.18637/jss.v064.i07">doi:10.18637/jss.v064.i07</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>is.wholenumber(4) # TRUE
is.wholenumber(3.4) # FALSE
</code></pre>

<hr>
<h2 id='mapforGeneratedData'>Map generated data</h2><span id='topic+mapforGeneratedData'></span>

<h3>Description</h3>

<p>Function to draw the map of a vector when data are generated. </p>


<h3>Usage</h3>

<pre><code class='language-R'>mapforGeneratedData(u, del=NULL, palette='RGB', main='' )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mapforGeneratedData_+3A_u">u</code></td>
<td>
<p>A vector of size nSubject to map. The function is only useful when data are generated by generateSampleDataFile.</p>
</td></tr>
<tr><td><code id="mapforGeneratedData_+3A_del">del</code></td>
<td>
<p>A numeric vector of increasing order given the breaks to color the map. By default the centiles of u are used.</p>
</td></tr>
<tr><td><code id="mapforGeneratedData_+3A_palette">palette</code></td>
<td>
<p>Color palette to be used. Either 'RGB' (default) Red-Green-Blue, or 'BW' for black and white.</p>
</td></tr>
<tr><td><code id="mapforGeneratedData_+3A_main">main</code></td>
<td>
<p>A string for title.</p>
</td></tr>
</table>


<h3>Authors</h3>

<p>Aurore J. Lavigne, Department of Epidemiology and Biostatistics, Imperial College London and MRC Biostatistics Unit, Cambridge, UK
</p>
<p>Maintainer: Silvia Liverani &lt;liveranis@gmail.com&gt;
</p>


<h3>References</h3>

<p>Silvia Liverani, David I. Hastie, Lamiae Azizi, Michail Papathomas, Sylvia Richardson (2015). PReMiuM: An R Package for Profile Regression Mixture Models Using Dirichlet Processes. Journal of Statistical Software, 64(7), 1-30. <a href="https://doi.org/10.18637/jss.v064.i07">doi:10.18637/jss.v064.i07</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
inputs=generateSampleDataFile(clusSummaryPoissonNormalSpatial())
mapforGeneratedData(inputs$uCAR)

## End(Not run)
</code></pre>

<hr>
<h2 id='margModelPosterior'>Marginal Model Posterior</h2><span id='topic+margModelPosterior'></span>

<h3>Description</h3>

<p>Compute the marginal model posterior.</p>


<h3>Usage</h3>

<pre><code class='language-R'>margModelPosterior(runInfoObj,allocation)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="margModelPosterior_+3A_runinfoobj">runInfoObj</code></td>
<td>
<p>An object of type runInfoObj.</p>
</td></tr>
<tr><td><code id="margModelPosterior_+3A_allocation">allocation</code></td>
<td>
<p>By default, if allocation is not provided, the _z.txt file is read to compute the marginal model posterior for all the partitions available there. If allocation is equal to a vector that corresponds to a partition, the marginal model posterior is computed for that given partition.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>It returns a file in the output folder, with name ending in &quot;_margModPost.txt&quot;, that contains the marginal model posterior. It also returns a list. The first argument is called margModPost and it is the mean of the values of the marginal model posterior as they appear in the file ending in &quot;_margModPost.txt&quot; in the output folder. The second argument is an updated runInfoObj which also include some hyperparameter values. 
</p>


<h3>Authors</h3>

<p>Silvia Liverani, Department of Epidemiology and Biostatistics, Imperial College London and MRC Biostatistics Unit, Cambridge, UK
</p>
<p>Maintainer: Silvia Liverani &lt;liveranis@gmail.com&gt;
</p>


<h3>References</h3>

<p>Silvia Liverani, David I. Hastie, Lamiae Azizi, Michail Papathomas, Sylvia Richardson (2015). PReMiuM: An R Package for Profile Regression Mixture Models Using Dirichlet Processes. Journal of Statistical Software, 64(7), 1-30. <a href="https://doi.org/10.18637/jss.v064.i07">doi:10.18637/jss.v064.i07</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
inputs &lt;- generateSampleDataFile(clusSummaryBernoulliDiscrete())

runInfoObj&lt;-profRegr(yModel=inputs$yModel, 
         xModel=inputs$xModel, nSweeps=5, 
         nBurn=10, data=inputs$inputData, output="output", 
         covNames = inputs$covNames, nClusInit=15,
         fixedEffectsNames = inputs$fixedEffectNames)

margModelPost&lt;-margModelPosterior(runInfoObj)

## End(Not run)
</code></pre>

<hr>
<h2 id='plotPredictions'>Plot the conditional density using the predicted scenarios</h2><span id='topic+plotPredictions'></span>

<h3>Description</h3>

<p>Plots the conditional density for the predicted scenarios provided. It produces a pdf with a page for each predictive scenario provided. Each page has a plot of the predicted response, in the order as they were provided to the function. Note that fixed effects are not processed in this function. This function has been developed for Bernoulli, Normal and Survival response only. This function has been developed for Discrete and Normal covariates only.</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotPredictions(outfile, runInfoObj, predictions,
    logOR=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotPredictions_+3A_outfile">outfile</code></td>
<td>
<p>String. The name of the output PDF file. The default is &quot;condDensity.pdf&quot;.</p>
</td></tr>
<tr><td><code id="plotPredictions_+3A_runinfoobj">runInfoObj</code></td>
<td>
<p>An object of type runInfoObj which contains all the details about the run of profRegr.</p>
</td></tr>
<tr><td><code id="plotPredictions_+3A_predictions">predictions</code></td>
<td>
<p>An object of type predictions which contains all the details about the run of calcPredictions.</p>
</td></tr>
<tr><td><code id="plotPredictions_+3A_logor">logOR</code></td>
<td>
<p>Whether to plot the response probability or log odds ratios. The default is FALSE and the response probability is plotted. </p>
</td></tr>
</table>


<h3>Value</h3>

<p>The output is a plot in PDF format.
</p>


<h3>Authors</h3>

<p>Silvia Liverani, Department of Epidemiology and Biostatistics, Imperial College London and MRC Biostatistics Unit, Cambridge, UK
</p>
<p>Maintainer: Silvia Liverani &lt;liveranis@gmail.com&gt;
</p>


<h3>References</h3>

<p>Silvia Liverani, David I. Hastie, Lamiae Azizi, Michail Papathomas, Sylvia Richardson (2015). PReMiuM: An R Package for Profile Regression Mixture Models Using Dirichlet Processes. Journal of Statistical Software, 64(7), 1-30. <a href="https://doi.org/10.18637/jss.v064.i07">doi:10.18637/jss.v064.i07</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# example with Bernoulli outcome and Discrete covariates
inputs &lt;- generateSampleDataFile(clusSummaryBernoulliDiscrete())
# prediction profiles
preds&lt;-data.frame(matrix(c(
2, 2, 2, 2, 2,
0, 0, NA, 0, 0),ncol=5,byrow=TRUE))

colnames(preds)&lt;-names(inputs$inputData)[2:(inputs$nCovariates+1)]
# run profile regression
runInfoObj&lt;-profRegr(yModel=inputs$yModel, xModel=inputs$xModel, 
 nSweeps=10000, nBurn=10000, data=inputs$inputData, output="output", 
 covNames=inputs$covNames,predict=preds,
 fixedEffectsNames = inputs$fixedEffectNames)        
dissimObj &lt;- calcDissimilarityMatrix(runInfoObj)
clusObj &lt;- calcOptimalClustering(dissimObj)
riskProfileObj &lt;- calcAvgRiskAndProfile(clusObj)
predictions &lt;- calcPredictions(riskProfileObj,fullSweepPredictions=TRUE,fullSweepLogOR=TRUE)

plotPredictions(outfile="predictiveDensity.pdf",runInfoObj=runInfoObj,
 predictions=predictions,logOR=TRUE)


## End(Not run)
</code></pre>

<hr>
<h2 id='plotRiskProfile'>Plot the Risk Profiles</h2><span id='topic+plotRiskProfile'></span>

<h3>Description</h3>

<p>Plots the risk profiles for a profile regression model.</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotRiskProfile(riskProfObj, outFile, showRelativeRisk=F, 
    orderBy=NULL, whichClusters=NULL, 
    whichCovariates=NULL, useProfileStar=F,riskLim=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotRiskProfile_+3A_riskprofobj">riskProfObj</code></td>
<td>
<p>An object of type riskProfObj.</p>
</td></tr>
<tr><td><code id="plotRiskProfile_+3A_outfile">outFile</code></td>
<td>
<p>Path and file name to save the plot.</p>
</td></tr>
<tr><td><code id="plotRiskProfile_+3A_showrelativerisk">showRelativeRisk</code></td>
<td>
<p>Whether to show the relative risk (with respect to the risk of the first cluster). This option is not available for Normal outcome. For Survival outcomes it computed proportional hazards, but only if the option proportionalHazards=T was used in the function calcAvgRiskAndProfile().</p>
</td></tr> 
<tr><td><code id="plotRiskProfile_+3A_orderby">orderBy</code></td>
<td>
<p>Order by which the clusters are to be displayed. It can take values &quot;Empirical&quot;, &quot;ClusterSize&quot; and &quot;Risk&quot; (the latter only if the outcome is provided). It can also take the name of a covariate to order the clusters, in which case the clusters are ordered.</p>
</td></tr>
<tr><td><code id="plotRiskProfile_+3A_whichclusters">whichClusters</code></td>
<td>
<p>Either a vector of indeces that corresponds to the clusters that are to be displayed. The length of this vector must be greater than 1. The default is that all clusters are shown.</p>
</td></tr>
<tr><td><code id="plotRiskProfile_+3A_whichcovariates">whichCovariates</code></td>
<td>
<p>Either a vector of indeces or a vector of strings that corresponds to the covariates that are to be displayed. The length of this vector must be greater than 1. The default is that all covariates are shown.</p>
</td></tr>
<tr><td><code id="plotRiskProfile_+3A_useprofilestar">useProfileStar</code></td>
<td>
<p>To be set equal to TRUE only if a variable selection procedure has been run. The definition of the star profile is given in Liverani, S., Hastie, D. I. and Richardson, S. (2013) PReMiuM: An R package for Bayesian profile regression.</p>
</td></tr>
<tr><td><code id="plotRiskProfile_+3A_risklim">riskLim</code></td>
<td>
<p>Limits of the y-axis for the plot of the boxplots for the response variable. The default is NULL. If the riskLim are provided, they should be a vector of length 2. </p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function creates a png plot saved in the path given by outFile. All clusters are visually displayed together.
</p>
<p>For discrete covariates, instead of plotting the probability that a phi is above
or below the mean value, we plot the actual phi values (and plot the mean value
across clusters as a horizontal line).
</p>
<p>For normal covariates, for each covariate the upper plot is the posterior
distribution for the mean mu, and the lower plot is the posterior distribution
of sqrt(Sigma[j,j]) (i.e. the standard deviation for that covariate).
</p>
<p>The coloured points on the boxplots highlight the 5
</p>
<p>It also returns the following vector.
</p>
<table>
<tr><td><code>meanSortIndex</code></td>
<td>
<p>This vector is the index that represents the order that the clusters are represented. The default ordering is by empirical risk.</p>
</td></tr>
</table>


<h3>Authors</h3>

<p>David Hastie, Department of Epidemiology and Biostatistics, Imperial College London, UK
</p>
<p>Silvia Liverani, Department of Epidemiology and Biostatistics, Imperial College London and MRC Biostatistics Unit, Cambridge, UK
</p>
<p>Maintainer: Silvia Liverani &lt;liveranis@gmail.com&gt;
</p>


<h3>References</h3>

<p>Silvia Liverani, David I. Hastie, Lamiae Azizi, Michail Papathomas, Sylvia Richardson (2015). PReMiuM: An R Package for Profile Regression Mixture Models Using Dirichlet Processes. Journal of Statistical Software, 64(7), 1-30. <a href="https://doi.org/10.18637/jss.v064.i07">doi:10.18637/jss.v064.i07</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# example for Poisson outcome and Discrete covariates
inputs &lt;- generateSampleDataFile(clusSummaryPoissonDiscrete())
runInfoObj&lt;-profRegr(yModel=inputs$yModel, 
    xModel=inputs$xModel, nSweeps=10, nClusInit=15,
    nBurn=20, data=inputs$inputData, output="output", 
    covNames = inputs$covNames, outcomeT = inputs$outcomeT,
    fixedEffectsNames = inputs$fixedEffectNames)

dissimObj&lt;-calcDissimilarityMatrix(runInfoObj)
clusObj&lt;-calcOptimalClustering(dissimObj)
riskProfileObj&lt;-calcAvgRiskAndProfile(clusObj)
clusterOrderObj&lt;-plotRiskProfile(riskProfileObj,"summary.png")

## End(Not run)
</code></pre>

<hr>
<h2 id='profRegr'>Profile Regression</h2><span id='topic+profRegr'></span>

<h3>Description</h3>

<p>Fit a profile regression model.</p>


<h3>Usage</h3>

<pre><code class='language-R'>profRegr(covNames, fixedEffectsNames, outcome="outcome", 
  outcomeT=NA, data, output="output", hyper, predict, 
	predictType="RaoBlackwell",
  nSweeps=1000, nBurn=1000, nProgress=500, nFilter=1, 
  nClusInit, seed, yModel="Bernoulli", xModel="Discrete", 
  sampler="SliceDependent", alpha=-2, dPitmanYor = 0, excludeY=FALSE, 
  extraYVar=FALSE, varSelectType="None", entropy,reportBurnIn=FALSE,
  run=TRUE, discreteCovs, continuousCovs, whichLabelSwitch="123",
  includeCAR=FALSE, neighboursFile="Neighbours.txt", uCARinit=FALSE,
  PoissonCARadaptive=FALSE,weibullFixedShape=TRUE, 
  useNormInvWishPrior=FALSE, useHyperpriorR1=TRUE, 
  useIndependentNormal=FALSE, useSeparationPrior=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="profRegr_+3A_covnames">covNames</code></td>
<td>
<p>A vector of strings of the covariate names as by the column names in the data argument. The names of the covariates cannot include space characters.</p>
</td></tr>
<tr><td><code id="profRegr_+3A_fixedeffectsnames">fixedEffectsNames</code></td>
<td>
<p>A vector of strings of the fixed effect names as by the column names in the data argument. Each fixed effect must be of class 'numeric'. If a fixed effect is of class 'character', an error message will appear and the fixed effect will need to be recoded as numeric. The names of the fixed effects cannot include space characters.</p>
</td></tr>
<tr><td><code id="profRegr_+3A_outcome">outcome</code></td>
<td>
<p>A string of column of the data argument that contains the outcome. The outcome cannot have missing values - you could consider predicting the value of the outcome for those subjects for which it has not been observed. The name cannot include space characters.</p>
</td></tr>
<tr><td><code id="profRegr_+3A_outcomet">outcomeT</code></td>
<td>
<p>A string of column of the data argument that contains the offset (for Poisson outcome) or the number of trials (for Binomial outcome) or censoring for Survival reponse (coded as 0 or 1). The name cannot include space characters.</p>
</td></tr>
<tr><td><code id="profRegr_+3A_data">data</code></td>
<td>
<p>A data frame which has as columns the outcome, the covariates, the fixed effects if any and the offset (for Poisson outcome) or the number of trials (for Binomial outcome) or censoring (for Survival outcome). The outcome cannot have missing values - you could consider predicting the value of the outcome for those subjects for which it has not been observed. For Survival response censoring must be coded as 0 if the event has not occurred (ie, there has been censoring) and 1 if the event has occurred (no censoring has taken place). The names of the columns cannot include space characters.</p>
</td></tr>
<tr><td><code id="profRegr_+3A_output">output</code></td>
<td>
<p>Path to folder to save all output files. The covariates can have missing values, which must be coded as 'NA'. There cannot be missing values in the fixed effects - if there are, use an imputation method before using profile regression.</p>
</td></tr>
<tr><td><code id="profRegr_+3A_hyper">hyper</code></td>
<td>
<p>Object of type setHyperparams with hyperparameters specifications. This is optional, default values are provided for all hyperparameters. See ?setHyperparams for details.</p>
</td></tr>
<tr><td><code id="profRegr_+3A_predict">predict</code></td>
<td>
<p>Data frame containing the predictive scenarios. This is only required if predictions are requested. 
</p>
<p>At each iteration the predictive subjects are assigned to one of the current
clusters according to their covariate profiles (but ignoring missing values), or
their Rao Blackwellised estimate of theta is recorded (a weighted average of all
theta, weighted by the probability of allocation into each cluster. For Normal and Quantile response they can also be randomly allocated. See also the option predictType below.
</p>
<p>The predictive subjects have no impact on the likelihood and so do not determine
the clustering or parameters at each iteration. The predictive allocations are
then recorded as extra entries in each row of the output_z.txt file. This can
then be processed in the post processing to create a dissimilarity matrix with
the fitting subjects. The post procesing function calcPredictions will create
predicted response values for these subjects.
</p>
<p>See ?calcPredictions for more details and examples. 
</p>
</td></tr>
<tr><td><code id="profRegr_+3A_predicttype">predictType</code></td>
<td>
<p>This can be set equal to &quot;RaoBlackwell&quot; and &quot;random&quot;. The default is RaoBlackwell. The random option can only be used for Normal and Quantile response, where the estimated variance of the clusters is considered and the predictive subjects are randomly assigned to a mixture component and then are also randomly sampled within that component.</p>
</td></tr>
<tr><td><code id="profRegr_+3A_nsweeps">nSweeps</code></td>
<td>
<p>Number of iterations of the MCMC after the burn-in period. By default this is 1000.</p>
</td></tr>
<tr><td><code id="profRegr_+3A_nburn">nBurn</code></td>
<td>
<p>Number of initial iterations of the MCMC to be discarded. By default this is 1000.</p>
</td></tr>
<tr><td><code id="profRegr_+3A_reportburnin">reportBurnIn</code></td>
<td>
<p>If TRUE then the burn in iterations are reported in the output files, if set to FALSE they are not. It is set to FALSE by default.</p>
</td></tr>
<tr><td><code id="profRegr_+3A_nprogress">nProgress</code></td>
<td>
<p>The number of sweeps at which to print a progress update. By default this is 500.</p>
</td></tr>
<tr><td><code id="profRegr_+3A_nfilter">nFilter</code></td>
<td>
<p>The frequency (in sweeps) with which to write the output to file. The default value is 1.</p>
</td></tr>
<tr><td><code id="profRegr_+3A_nclusinit">nClusInit</code></td>
<td>
<p>The number of clusters individuals should be initially randomly assigned to (Unif[50,60]).</p>
</td></tr>
<tr><td><code id="profRegr_+3A_seed">seed</code></td>
<td>
<p>The value for the seed for the random number generator. The default value is the current time.</p>
</td></tr>
<tr><td><code id="profRegr_+3A_ymodel">yModel</code></td>
<td>
<p>The model type for the outcome variable. The options currently available are &quot;Bernoulli&quot;, &quot;Poisson&quot;, &quot;Binomial&quot;, &quot;Categorical&quot;, &quot;Normal&quot;, &quot;Quantile&quot; and &quot;Survival&quot;. The default value is Bernoulli.</p>
</td></tr>
<tr><td><code id="profRegr_+3A_xmodel">xModel</code></td>
<td>
<p>The model type for the covariates. The options currently available are &quot;Discrete&quot;, &quot;Normal&quot; and &quot;Mixed&quot;. The default value is &quot;Discrete&quot;.</p>
</td></tr>
<tr><td><code id="profRegr_+3A_sampler">sampler</code></td>
<td>
<p>The sampler type to be used. Options are &quot;SliceDependent&quot;, &quot;SliceIndependent&quot; and &quot;Truncated&quot;.  The default value is &quot;SliceDependent&quot;.</p>
</td></tr>
<tr><td><code id="profRegr_+3A_alpha">alpha</code></td>
<td>
<p>The value to be used if alpha is fixed. If a value smaller than or equal to -1 is used then alpha is random, if dPitmanYor is equal to zero (the random alpha option is available for Dirichlet process prior only). The default value is -2 (random alpha). For fixed alpha, if dPitmanYor is in the interval (0,1) then a Pitman-Yor process prior is used instead of a Dirichlet process prior.</p>
</td></tr>
<tr><td><code id="profRegr_+3A_dpitmanyor">dPitmanYor</code></td>
<td>
<p>The discount parameter for the Pitman-Yor process prior. The default value is 0, which is equivalent to a Dirichlet process prior. This parameter must belong to the interval [0,1) and it must be provided together with a non-negative value for alpha. The Pitman-Yor process prior is only available for non-random parameters. Note that the third label switching move is only available for Dirichlet process priors, so it will not be run if dPitmanYor&gt;0. Therefore setting dPitmanYor to a value greater than zero will forse whichLabelSwitch=12.</p>
</td></tr>
<tr><td><code id="profRegr_+3A_excludey">excludeY</code></td>
<td>
<p>If TRUE only the covariate data X is modelled. By default this is set to FALSE.</p>
</td></tr>
<tr><td><code id="profRegr_+3A_extrayvar">extraYVar</code></td>
<td>
<p>If set equal to TRUE extra Gaussian variance is included in the response model. This option is available only for Bernoulli, Binomial and Poisson response. By default the extra Gaussian variance is not included, so extraYVar=FALSE.</p>
</td></tr>
<tr><td><code id="profRegr_+3A_varselecttype">varSelectType</code></td>
<td>
<p>The type of variable selection to be used &quot;None&quot;, &quot;BinaryCluster&quot; or &quot;Continuous&quot;.  The &quot;Continuous&quot; variable selection is the implementation of the novel variable selection formulation proposed by Papathomas, Molitor, Hoggart, Hastie, Richardson (2012) &quot;Exploring data from genetic association studies using Bayesian variable selection and the Dirichlet process: application to searching for gene x gene patterns&quot; in Genetic Epidemiology. The &quot;BinaryCluster&quot; variable selection is based on the method proposed by Chung and Dunson (2009) &quot;Nonparametric Bayes conditional distribution modelling with variable selection&quot; in the Journal of the American Statistical Association. Both types of variable selection can be used with discrete, continuous or mixed covariates. The default value is &quot;None&quot;.</p>
</td></tr>
<tr><td><code id="profRegr_+3A_entropy">entropy</code></td>
<td>
<p>If included then we compute allocation entropy. By default the allocation entropy is not included.</p>
</td></tr>
<tr><td><code id="profRegr_+3A_run">run</code></td>
<td>
<p>Logical. If TRUE then the MCMC is run. Set run=FALSE if the MCMC has been run already and it is only required to collect information about the run.</p>
</td></tr>
<tr><td><code id="profRegr_+3A_discretecovs">discreteCovs</code></td>
<td>
<p>The names of the discrete covariates among the covariate names, if xModel=&quot;Mixed&quot;. This and continuousCovs must be defined if xModel=&quot;Mixed&quot;, while covNames is ignored.</p>
</td></tr>
<tr><td><code id="profRegr_+3A_continuouscovs">continuousCovs</code></td>
<td>
<p>The names of the discrete covariates among the covariate names, if xModel=&quot;Mixed&quot;. This and continuousCovs must be defined if xModel=&quot;Mixed&quot;, while covNames is ignored.</p>
</td></tr>
<tr><td><code id="profRegr_+3A_whichlabelswitch">whichLabelSwitch</code></td>
<td>
<p>The label switching moves to run. The options available are moves 1, 2 and 3 (&quot;123&quot;), moves 1 and 2 (&quot;12&quot;) and move 3 only (&quot;3&quot;). The moves are described in Hastie et al. (2013). Note that the third label switching move is only available for Dirichlet process priors, so it will not be run if dPitmanYor&gt;0. Therefore setting dPitmanYor to a value greater than zero will forse whichLabelSwitch=12.</p>
</td></tr>
<tr><td><code id="profRegr_+3A_includecar">includeCAR</code></td>
<td>
<p>A boolean specifying wether a conditional autoregressive term should be introduced within the model, to take into account possible spatial correlation within residuals. Only for Poisson and Normal response models.</p>
</td></tr>
<tr><td><code id="profRegr_+3A_neighboursfile">neighboursFile</code></td>
<td>
<p>The file name of the file specifying neighbourhood graph. It should have the same structure than neighbourhood graph files used in the &quot;INLA&quot; package, and can be produced from a nb object of package &quot;spdep&quot;, by the function &quot;nb2INLA&quot; of package &quot;spdep&quot;. See ?nb2INLA for details. Each file must have at least one neighbour.</p>
</td></tr>
<tr><td><code id="profRegr_+3A_ucarinit">uCARinit</code></td>
<td>
<p>This parameter gives the possibility of giving initialisation values for the spatial residuals u of the spatial CAR. It is set to FALSE by default (meaning that the spatial residuals are initialised randomly). It can be set alternatively to a vector of values, one for each of the observations available.</p>
</td></tr>
<tr><td><code id="profRegr_+3A_poissoncaradaptive">PoissonCARadaptive</code></td>
<td>
<p>This parameter controls which sampler is used for the parameters of the spatial random effect when the outcome is Poisson. When it is set to TRUE, the adaptive rejection sampler is used. When it is set to FALSE (default) a random walk Metropolis is used. </p>
</td></tr>
<tr><td><code id="profRegr_+3A_weibullfixedshape">weibullFixedShape</code></td>
<td>
<p>This parameter controls whether the shape parameter of the Weibull distribution (for yModel=Survival only) is a global parameter (fixed) or cluster specific. It is equal to TRUE by default.</p>
</td></tr>
<tr><td><code id="profRegr_+3A_usenorminvwishprior">useNormInvWishPrior</code></td>
<td>
<p>By default this variable equals FALSE. When this variable equals TRUE, the conjugate Normal-inverse-Wishart prior is used rather
than the independant normal and inverse Wishart priors. If this prior is used, variable selection cannot be used as it has not been implemented.</p>
</td></tr>
<tr><td><code id="profRegr_+3A_usehyperpriorr1">useHyperpriorR1</code></td>
<td>
<p>Adds hyperpriors for the hyperparameter R1, kappa1, mu0 and Sigma0 for xModel=Normal or Mixed. The default for this option is TRUE.</p>
</td></tr>
<tr><td><code id="profRegr_+3A_useindependentnormal">useIndependentNormal</code></td>
<td>
<p>If the data contains continuous variables (xModel=Normal or Mixed) and the variables are assumed to be independent for each cluster, the multivariate normal likelihood should be replaced by the independent normal likelihood. Therefore, this option should set to TRUE. The default for this option is FALSE. When useIndependentNormal=TRUE, useHyperpriorR1 must be TRUE.</p>
</td></tr>
<tr><td><code id="profRegr_+3A_useseparationprior">useSeparationPrior</code></td>
<td>
<p> A separation prior is used to model the within-cluster covariance matrix for each cluster when the data contains continuous variables (xModel=Normal or Mixed). The default for this option is FALSE. When useSeparationPrior=TRUE, useHyperpriorR1 must be TRUE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Once the C++ has completed the output from fitting the regression is stored in a number of text files in the directory specified. Files are produced
containing the MCMC traces for all of the values of interest, along with a log file and files for monitoring the acceptance rates of the adaptive Metropolis Hastings moves.
</p>
<p>It returns a number of files in the output directory as well as a list with the following elements. This an object of type runInfoObj. The files that are produced in the output directory are described below. 
</p>
<table>
<tr><td><code>directoryPath</code></td>
<td>
<p>String. Directory path of the output files.</p>
</td></tr>
<tr><td><code>fileStem</code></td>
<td>
<p>String. The </p>
</td></tr>
<tr><td><code>inputFileName</code></td>
<td>
<p>String. Location and file name of input dataset as created by this function for the C++ routines</p>
</td></tr>
<tr><td><code>nSweeps</code></td>
<td>
<p>Integer. The number of sweeps of the MCMC after the burn-in.</p>
</td></tr>
<tr><td><code>nBurn</code></td>
<td>
<p>Integer. The number of iterations in the burn-in period of the MCMC.</p>
</td></tr>
<tr><td><code>reportBurnIn</code></td>
<td>
<p>Logical. Whether the output of the burn-in report should be included.</p>
</td></tr>
<tr><td><code>nFilter</code></td>
<td>
<p>Integer. The frequency (in sweeps) with which to write the output to file.</p>
</td></tr>
<tr><td><code>nProgress</code></td>
<td>
<p>The number of sweeps at which to print a progress update.</p>
</td></tr>
<tr><td><code>nSubjects</code></td>
<td>
<p>Integer. The number of subjects.</p>
</td></tr>
<tr><td><code>nPredictSubjects</code></td>
<td>
<p>Integer. The number of subjects for which to run predictions.</p>
</td></tr>
<tr><td><code>fullPredictFile</code></td>
<td>
<p>Logical. It is FALSE by default. It is equal to TRUE if the outcome or the outcome and the fixed effects were included in the dataframe provided in the input predict. If TRUE, the function will have a produced a file ending in &quot;_predictFull.txt&quot; which contains the values of the outcome and fixed effects for the computation of measures of fit in the function calcPredictions.</p>
</td></tr>
<tr><td><code>covNames</code></td>
<td>
<p>A vector of strings with the names of the covariates.</p>
</td></tr>
<tr><td><code>xModel</code></td>
<td>
<p>String. The model type for the covariates.</p>
</td></tr>
<tr><td><code>includeResponse</code></td>
<td>
<p>Logical. If FALSE only the covariate data X is modelled.</p>
</td></tr>
<tr><td><code>yModel</code></td>
<td>
<p>String. The model type for the outcome.</p>
</td></tr>
<tr><td><code>varSelect</code></td>
<td>
<p>Logical. If FALSE no variable selection is performed.</p>
</td></tr>
<tr><td><code>varSelectType</code></td>
<td>
<p>String. It specifies what type of variable selection has been performed, if any.</p>
</td></tr> 
<tr><td><code>nCovariates</code></td>
<td>
<p>Integer. The number of covariates.</p>
</td></tr>
<tr><td><code>nFixedEffects</code></td>
<td>
<p>Integer. The number of fixed effects.</p>
</td></tr>
<tr><td><code>nCategoriesY</code></td>
<td>
<p>Integer. The number of categories of the outcome, if yModel = &quot;Categorical&quot;. It is 1 otherwise.</p>
</td></tr>
<tr><td><code>nCategories</code></td>
<td>
<p>Vector of integers. The number of categories of each covariate, if xModel = &quot;Discrete&quot;. It is 1 otherwise.</p>
</td></tr>
<tr><td><code>extraYVar</code></td>
<td>
<p>TRUE if extra Gaussian variance is included in the response model.</p>
</td></tr>
<tr><td><code>xMat</code></td>
<td>
<p>A matrix of the covariate data.</p>
</td></tr>
<tr><td><code>yMat</code></td>
<td>
<p>A matrix of the outcome data, including the offset if the outcome is Poisson, the number of trials if the outcome is Binomial and 0 or 1 for Survival outcome (1 for censored individuals, 0 otherwise).</p>
</td></tr>
<tr><td><code>wMat</code></td>
<td>
<p>A matrix of the fixed effect data.</p>
</td></tr>
<tr><td><code>whichLabelSwitch</code></td>
<td>
<p>The label switching moves that have been run. The options available are moves 1, 2 and 3 (&quot;123&quot;), moves 1 and 2 (&quot;12&quot;) and move 3 only (&quot;3&quot;). The moves are described in Hastie et al. (2013).</p>
</td></tr>
<tr><td><code>includeCAR</code></td>
<td>
<p>Logical. Whether a spatial CAR term is included.</p>
</td></tr>
<tr><td><code>predictType</code></td>
<td>
<p>String. Whether a RaoBlackwell or random predictions have been computed.</p>
</td></tr>
<tr><td><code>weibullFixedShape</code></td>
<td>
<p>Logical. Whether the shape parameter of the Weibull distribution for the survival response is fixed or cluster specific.</p>
</td></tr>
</table>
<p>These are the files produced in the output directory. We refer to Liverani et al. (2015) 
</p>
<table>
<tr><td><code>_alpha.txt</code></td>
<td>
<p>If alpha is random, each row is a draw from a posterior distribution of alpha (including burn in if reportBurnIn=TRUE).</p>
</td></tr>
<tr><td><code>_beta.txt</code></td>
<td>
<p>If fixed effects are included, this file provides the draws from the posterior distribution of the beta parameters at each sweep. Each row represents the vector of beta's at each sweep (including burn in if reportBurnIn=TRUE).</p>
</td></tr>
<tr><td><code>_hyper.txt</code></td>
<td>
<p>Internal file to communicate between R and C++ the values of the hyperparamters.</p>
</td></tr>
<tr><td><code>_input_txt</code></td>
<td>
<p>Internal file to communicate the data between R and C++.</p>
</td></tr>
<tr><td><code>_log.txt</code></td>
<td>
<p>This file logs some information about the run, such as what variables were included, which hyperparameters were used, the seed of the random numbers, the acceptance rates of the MCMC moves that were included in the run.</p>
</td></tr>
<tr><td><code>_logPost.txt</code></td>
<td>
<p>This file report the logPosterior, the logLikelihood and logPrior for the model fit at each sweep (including burn in if reportBurnIn=TRUE).</p>
</td></tr>
<tr><td><code>_nClusters.txt</code></td>
<td>
<p>This file includes the number of clusters at each sweep. Each row represents a sweep (including burn in if reportBurnIn=TRUE) and each element in the rows is the number of clusters per sweep. This includes the number of empty clusters, if any.</p>
</td></tr>
<tr><td><code>_nMembers.txt</code></td>
<td>
<p>This file includes the number of observations in each cluster at each sweep. Each row represents a sweep (including burn in if reportBurnIn=TRUE) and each element in the rows is the number of observations in each cluster per sweep. The last number in each row is the total number of observations, computed as the sum of the elements in the row as a check that all observations have been assigned to a cluster.</p>
</td></tr>
<tr><td><code>_theta.xt</code></td>
<td>
<p>This file includes the value of theta (cluster specific parameter for the response variable) for each cluster at each sweep. Each row represents a sweep (including burn in if reportBurnIn=TRUE) and each element in the rows is the value of theta for each cluster at that sweep. The thetas provided her are in the same order as the clusters in _nMembers.txt and they are drawn from the prior when they correspond to empty clusters.</p>
</td></tr>
<tr><td><code>_z.txt</code></td>
<td>
<p>This file includes the cluster membership for each observation at each sweep. Each row represents a sweep (including burn in if reportBurnIn=TRUE) and each element in the rows is the cluster membership for each of the observations, ordered as they are provided to profRegr in the dataframe.</p>
</td></tr>
</table>
<p>There are more files that can be in the output, depending on which options are used in profRegr. The file _mu.txt for example reports the mean for xModel=Normal, _phi.txt reports the multinomial probabilities for xModel=Discrete, _rho.txt reports the paramters for variable selection, etc. The files usually report one line for each sweep (including burn in if reportBurnIn=TRUE). See Liverani et al. (2015) for more details of the parameters. 
</p>
<p>Note that for the _gamma.txt for variable selection the results are reported per sweep (each line is a sweep) and within each line by cluster (so for each covariate the switches per cluster are reported in order, before the second covariate is reported for each cluster, etc).
</p>


<h3>Authors</h3>

<p>David Hastie, Department of Epidemiology and Biostatistics, Imperial College London, UK
</p>
<p>Silvia Liverani, Department of Epidemiology and Biostatistics, Imperial College London and MRC Biostatistics Unit, Cambridge, UK
</p>
<p>Aurore J. Lavigne, Department of Epidemiology and Biostatistics, Imperial College London, UK
</p>
<p>Lamiae Azizi, MRC Biostatistics Unit, Cambridge, UK
</p>
<p>Maintainer: Silvia Liverani &lt;liveranis@gmail.com&gt;
</p>
<p>The R package PReMiuM is supported through research grants. One key requirement of such funding applications is the ability to demonstrate the impact of the work we seek funding for can. Whatever you are using PReMiuM for, it would be very helpful for us to learn about our users, to tailor our future methodological developments to your needs. Please email us at liveranis@gmail.com or visit http://www.silvialiverani.com/support-premium/. 
</p>


<h3>References</h3>

<p>Silvia Liverani, David I. Hastie, Lamiae Azizi, Michail Papathomas, Sylvia Richardson (2015). PReMiuM: An R Package for Profile Regression Mixture Models Using Dirichlet Processes. Journal of Statistical Software, 64(7), 1-30. <a href="https://doi.org/10.18637/jss.v064.i07">doi:10.18637/jss.v064.i07</a>.
</p>
<p>Hastie, D. I., Liverani, S. and Richardson, S. (2014) Sampling from Dirichlet process mixture models with unknown concentration parameter: Mixing issues in large data implementations. <em>Statistics and Computing</em>. Available at http://link.springer.com/article/10.1007
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# example for Poisson outcome and Discrete covariates
inputs &lt;- generateSampleDataFile(clusSummaryPoissonDiscrete())
runInfoObj&lt;-profRegr(yModel=inputs$yModel, 
    xModel=inputs$xModel, nSweeps=10, nClusInit=20,
    nBurn=20, data=inputs$inputData, output="output", 
    covNames = inputs$covNames, outcomeT = inputs$outcomeT,
    fixedEffectsNames = inputs$fixedEffectNames)


# example with Bernoulli outcome and Mixed covariates
inputs &lt;- generateSampleDataFile(clusSummaryBernoulliMixed())
runInfoObj&lt;-profRegr(yModel=inputs$yModel, 
    xModel=inputs$xModel, nSweeps=10, nClusInit=15,
    nBurn=20, data=inputs$inputData, output="output", 
    discreteCovs = inputs$discreteCovs,
    continuousCovs = inputs$continuousCovs)

## End(Not run)
</code></pre>

<hr>
<h2 id='rALD'>Asymmetric Laplace Distribution</h2><span id='topic+rALD'></span><span id='topic+qALD'></span>

<h3>Description</h3>

<p>Random generation and quantile function for a Three Parameter Asymmetric Laplace Distribution as defined in Koenker and Machado (1999) for quantile regression with location parameter equal to mu, scale parameter sigma and skewness parameter p..</p>


<h3>Usage</h3>

<pre><code class='language-R'>rALD(n, mu = 0, sigma = 1, p = 0.5)
qALD(prob, mu = 0, sigma = 1, p = 0.5, lower.tail = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rALD_+3A_prob">prob</code></td>
<td>
<p>Vector of probabilities.</p>
</td></tr>
<tr><td><code id="rALD_+3A_n">n</code></td>
<td>
<p>Number of observations.</p>
</td></tr>
<tr><td><code id="rALD_+3A_mu">mu</code></td>
<td>
<p>Location parameter.</p>
</td></tr>
<tr><td><code id="rALD_+3A_sigma">sigma</code></td>
<td>
<p>Scale parameter.</p>
</td></tr>
<tr><td><code id="rALD_+3A_p">p</code></td>
<td>
<p>Skewness parameter.</p>
</td></tr>
<tr><td><code id="rALD_+3A_lower.tail">lower.tail</code></td>
<td>
<p>Logical; if TRUE (default), probabilities are P[X strictly smaller than x] otherwise, P[X &gt; x].</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If mu, sigma or p are not specified they assume the default values of 0, 1 and 0.5, respectively, belonging to the Symmetric Standard Laplace Distribution denoted by ALD(0,1,0.5).
</p>
<p>As discussed in Koenker and Machado (1999) and Yu and Moyeed (2001) we say that a random variable Y is distributed as an ALD with location parameter mu, scale parameter sigma&gt;0 and skewness parameter p in (0,1), if its probability density function (pdf) is given by
</p>
<p>f(y|mu,sigma,p)=p(1-p)/sigma * e^(-p_p(y-mu)/sigma))
</p>
<p>where p_p(.) is the so called check (or loss) function defined by
</p>
<p>p_p(u)=u(p - I(u&lt;0))
</p>
<p>with I() denoting the usual indicator function. This distribution is denoted by ALD(mu,sigma,p) and it's p-th quantile is equal to mu.
</p>
<p>The scale parameter sigma must be positive and non zero. The skew parameter p must be between zero and one (0&lt;p&lt;1).
</p>


<h3>Value</h3>

<p>The length of the result is determined by n for rALD, and is the maximum of the lengths of the numerical arguments for the other functions dALD, pALD and qALD.
</p>


<h3>Authors</h3>

<p>Silvia Liverani, Queen Mary University of London, UK. 
</p>
<p>Maintainer: Silvia Liverani &lt;liveranis@gmail.com&gt;
</p>


<h3>References</h3>

<p>Galarza Morales, C., Lachos Davila, V., Barbosa Cabral, C., and Castro Cepero, L. (2017) Robust quantile regression using a generalized class of skewed distributions. Stat,6: 113-130 <a href="https://doi.org/10.1002/sta4.140">doi:10.1002/sta4.140</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>is.wholenumber(4) # TRUE
is.wholenumber(3.4) # FALSE
</code></pre>

<hr>
<h2 id='setHyperparams'>Definition of characteristics of sample datasets for profile regression</h2><span id='topic+setHyperparams'></span>

<h3>Description</h3>

<p>Hyperparameters for the priors can be specified here and passed as an argument to profRegr. 
</p>
<p>The user can specify some or all hyperparameters.
Those hyperparameters not specified will take their default values. Where the
file is not provided, all hyperparameters will take their default values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setHyperparams(shapeAlpha=NULL,rateAlpha=NULL,
     aPhi=NULL,mu0=NULL,Tau0=NULL, TauIndep0 = NULL, R0=NULL,
     RIndep0 = NULL, kappa0=NULL, kappa1=NULL,
     nu0=NULL,muTheta=NULL,sigmaTheta=NULL,dofTheta=NULL,muBeta=NULL,
     sigmaBeta=NULL,dofBeta=NULL,shapeTauEpsilon=NULL,
     rateTauEpsilon=NULL,aRho=NULL,bRho=NULL,atomRho=NULL,shapeSigmaSqY=NULL,
     scaleSigmaSqY=NULL,pQuantile=NULL,rSlice=NULL,truncationEps=NULL,
     shapeTauCAR=NULL,rateTauCAR=NULL,shapeNu=NULL,scaleNu=NULL,
     initAlloc=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setHyperparams_+3A_shapealpha">shapeAlpha</code></td>
<td>
<p>The shape parameter for Gamma prior on alpha (default=2)</p>
</td></tr>
<tr><td><code id="setHyperparams_+3A_ratealpha">rateAlpha</code></td>
<td>
<p>The inverse-scale (rate) parameter for the Gamma prior on alpha (default=1)</p>
</td></tr>
<tr><td><code id="setHyperparams_+3A_aphi">aPhi</code></td>
<td>
<p>The vector of parameters for the Dirichlet prior on phi_j. Element j corresponds to covariate j which then has a prior Dirichlet(aPhi[j],aPhi[j],....,aPhi[j]). Only used in discrete case, default=(1 1 1 ... 1).</p>
</td></tr>
<tr><td><code id="setHyperparams_+3A_mu0">mu0</code></td>
<td>
<p>The mean vector for mu_c in the multivariate Normal covariate case (only used in multivariate Normal covariate case (useIndependentNormal=FALSE), default=empirical covariate means)</p>
</td></tr>
<tr><td><code id="setHyperparams_+3A_tau0">Tau0</code></td>
<td>
<p>The precision matrix for mu_c in the multivariate Normal covariate case (only used in multivariate Normal covariate case, when useIndependentNormal=FALSE). The default value is default=inverse of diagonal matrix with elements equal to square of empirical range for each covariate</p>
</td></tr>
<tr><td><code id="setHyperparams_+3A_tauindep0">TauIndep0</code></td>
<td>
<p>The precision parameter of each covariate (in a vector form) for mu_c in the independent Normal covariate case (only used in independent Normal covariate case, when useIndependentNormal=TRUE). The default value is default=a vector with elements equal to inverse of the square of empirical range for each covariate)</p>
</td></tr>
<tr><td><code id="setHyperparams_+3A_r0">R0</code></td>
<td>
<p>The scale parameter for the Wishart distribution for Tau_c if useHyperpriorR1=FALSE in the function profRegr. If useHyperpriorR1=TRUE in the function profRegr, then R0 is the scale parameter for the prior distribution on the scale parameter of the precision matrix Tau_c (in this case Tau_c has Wishart distribution with parameters R0 and kappa0). In both cases the default is  default=1/nCovariates * inverse of empirical covariance matrix. These parameters can only be used for Normal or Mixed covariates.</p>
</td></tr>
<tr><td><code id="setHyperparams_+3A_rindep0">RIndep0</code></td>
<td>
<p>The rate parameter in the gamma distribution for R1_indep of each covariate (in a vector form) if useIndependentNormal=TRUE in the function profRegr. The default is default= a vector with elements equal to 10/square of empirical range for each covariate. The parameter can only be used for Normal or Mixed covariates.</p>
</td></tr>
<tr><td><code id="setHyperparams_+3A_kappa0">kappa0</code></td>
<td>
<p>The degrees of freedom for the Wishart distribution for Tau_c if useHyperpriorR1=FALSE in the function profRegr. If useHyperpriorR1=TRUE in the function profRegr, then kappa0 are the degrees of freedom for the prior distribution on the scale parameter of the precision matrix Tau_c (in this case Tau_c has Wishart distribution with parameters R0 and kappa0). In both cases the default is nCovariates. These parameters can only be used for Normal or Mixed covariates.</p>
</td></tr>
<tr><td><code id="setHyperparams_+3A_kappa1">kappa1</code></td>
<td>
<p>The degrees of freedom parameter for the Wishart distribution for Tau_c (only used in Normal covariate case, default=nCovariates). Only used when the prior for R1 is included in the model (by setting the option useHyperpriorR1=TRUE in the function profRegr).</p>
</td></tr>
<tr><td><code id="setHyperparams_+3A_nu0">nu0</code></td>
<td>
<p>Hyperparameter for the conjugate Normal inverse Wishart prior for Normal covariates. The Normal distribution of mu_c has covariance Sigma_c/nu0. The default value is 0.01. The other hyperparameters for this parametrisation are re-used from the independant priors. This hyperparameter is only useful when the option useNormInvWishPrior=TRUE in the function profRegr().</p>
</td></tr>
<tr><td><code id="setHyperparams_+3A_mutheta">muTheta</code></td>
<td>
<p>The location parameter for the t-Distribution for theta_c (only used if response included in model, default=0)</p>
</td></tr>
<tr><td><code id="setHyperparams_+3A_sigmatheta">sigmaTheta</code></td>
<td>
<p>The scale parameter for the t-Distribution for theta_c (only used if response included in model, default=2.5)</p>
</td></tr>
<tr><td><code id="setHyperparams_+3A_doftheta">dofTheta</code></td>
<td>
<p>The degrees of freedom parameter for the t-Distribution for theta_c (only used if response included in model, default=7)</p>
</td></tr>
<tr><td><code id="setHyperparams_+3A_mubeta">muBeta</code></td>
<td>
<p>The location parameter for the t-Distribution for beta (only used when fixed effects present, default=0)</p>
</td></tr>
<tr><td><code id="setHyperparams_+3A_sigmabeta">sigmaBeta</code></td>
<td>
<p>The scale parameter for the t-Distribution for beta (only used when fixed effects present, default=2.5)</p>
</td></tr>
<tr><td><code id="setHyperparams_+3A_dofbeta">dofBeta</code></td>
<td>
<p>The dof parameter for the t-Distribution for beta (only used when fixed effects present, default=7)</p>
</td></tr>
<tr><td><code id="setHyperparams_+3A_shapetauepsilon">shapeTauEpsilon</code></td>
<td>
<p>Shape parameter for gamma distribution for prior for precision tau of extra variation errors epsilon (only used if extra variation is used i.e. extraYVar argument is included, default=5.0)</p>
</td></tr>
<tr><td><code id="setHyperparams_+3A_ratetauepsilon">rateTauEpsilon</code></td>
<td>
<p>Inverse-scale (rate) parameter for gamma distribution for prior for precision tau of extra variation errors epsilon (only used if extra variation is used i.e. extraYVar argument is used, default=0.5)</p>
</td></tr>
<tr><td><code id="setHyperparams_+3A_arho">aRho</code></td>
<td>
<p>Parameter for beta distribution for prior on rho in variable selection (default=0.5)</p>
</td></tr>
<tr><td><code id="setHyperparams_+3A_brho">bRho</code></td>
<td>
<p>Parameter for beta distribution for prior on rho in variable selection (default=0.5)</p>
</td></tr>
<tr><td><code id="setHyperparams_+3A_atomrho">atomRho</code></td>
<td>
<p>Parameter for the probability for the atom at zero, i.e. the 0.5 probability in w_j distributed Bernoulli(0.5) in the formulation of the sparsity inducing prior (default=0.5). This parameter must be in the interval (0,1], where atomRho=1 corresponds to the case where the prior for rho is a Beta(aRho,bRho).</p>
</td></tr>
<tr><td><code id="setHyperparams_+3A_shapesigmasqy">shapeSigmaSqY</code></td>
<td>
<p>Shape parameter of inverse-gamma prior for sigma_Y^2 (only used in the Normal response model, default =2.5)</p>
</td></tr>
<tr><td><code id="setHyperparams_+3A_scalesigmasqy">scaleSigmaSqY</code></td>
<td>
<p>Scale parameter of inverse-gamma prior for sigma_Y^2 (only used in the Normal response model, default =2.5)</p>
</td></tr>
<tr><td><code id="setHyperparams_+3A_pquantile">pQuantile</code></td>
<td>
<p>Quantile for the yModel=Quantile option (default = 0.5)</p>
</td></tr>
<tr><td><code id="setHyperparams_+3A_rslice">rSlice</code></td>
<td>
<p>Slice parameter for independent slice sampler such that xi_c = (1-rSlice)*rSlice^c for c=0,1,2,... (only used for slice independent sampler i.e. sampler=SliceIndependent, default 0.75).</p>
</td></tr>
<tr><td><code id="setHyperparams_+3A_truncationeps">truncationEps</code></td>
<td>
<p>Parameter for determining the truncation level of the finite Dirichlet process (only used for truncated sampler i.e. sampler=Truncated</p>
</td></tr>
<tr><td><code id="setHyperparams_+3A_shapetaucar">shapeTauCAR</code></td>
<td>
<p>Shape parameter for gamma distribution for precision TauCAR of spatial CAR term (only used if a spatial term is included i.e. includeCAR argument is TRUE, default=0.001)</p>
</td></tr>
<tr><td><code id="setHyperparams_+3A_ratetaucar">rateTauCAR</code></td>
<td>
<p>Inverse-scale (rate) parameter for gamma distribution for precision TauCAR of spatial CAR term (only used if a spatial term is included i.e. includeCAR argument is TRUE, default=0.001)</p>
</td></tr>
<tr><td><code id="setHyperparams_+3A_shapenu">shapeNu</code></td>
<td>
<p>Shape parameter of Gamma prior for the shape parameter of the Weibull for survival response (only used in the Survival response model, default = 2.5)</p>
</td></tr>
<tr><td><code id="setHyperparams_+3A_scalenu">scaleNu</code></td>
<td>
<p>Scale parameter of Gamma prior for the shape parameter of the Weibull for survival response  (only used in the Survival response model, default = 1)</p>
</td></tr>
<tr><td><code id="setHyperparams_+3A_initalloc">initAlloc</code></td>
<td>
<p>Vector of the initial allocation of the individuals to clusters. This is NULL by default, which implies a random start. Useful for starting the MCMC from a specific partition. Note that if this overwrites the option nClusInit in the function profRegr: nClusInit is set equal to the maximum value in initAlloc. </p>
</td></tr>
</table>


<h3>Value</h3>

<p>The output of this function is a list with the components defined as above.
</p>


<h3>Authors</h3>

<p>David Hastie, Department of Epidemiology and Biostatistics, Imperial College London, UK
</p>
<p>Silvia Liverani, Department of Epidemiology and Biostatistics, Imperial College London and MRC Biostatistics Unit, Cambridge, UK
</p>
<p>Maintainer: Silvia Liverani &lt;liveranis@gmail.com&gt;
</p>


<h3>References</h3>

<p>Silvia Liverani, David I. Hastie, Lamiae Azizi, Michail Papathomas, Sylvia Richardson (2015). PReMiuM: An R Package for Profile Regression Mixture Models Using Dirichlet Processes. Journal of Statistical Software, 64(7), 1-30. <a href="https://doi.org/10.18637/jss.v064.i07">doi:10.18637/jss.v064.i07</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
hyp &lt;- setHyperparams(shapeAlpha=3,rateAlpha=2,mu0=c(30,13),R0=3.2*diag(2))

inputs &lt;- generateSampleDataFile(clusSummaryPoissonNormal())
runInfoObj&lt;-profRegr(yModel=inputs$yModel, 
    xModel=inputs$xModel, nSweeps=2, nClusInit=15,
    nBurn=2, data=inputs$inputData, output="output", 
    covNames = inputs$covNames, outcomeT = inputs$outcomeT,
    fixedEffectsNames = inputs$fixedEffectNames,
    hyper=hyp)

## End(Not run)
</code></pre>

<hr>
<h2 id='simBenchmark'>Benchmark for simulated examples</h2><span id='topic+simBenchmark'></span>

<h3>Description</h3>

<p>This function checks the cluster allocation of profile regression against the generating clusters for a selection of the simulated dataset provided within the package. This can be used to compute confusion matrices for simulated examples, as shown in the example below.</p>


<h3>Usage</h3>

<pre><code class='language-R'>simBenchmark(whichModel = "clusSummaryBernoulliDiscrete",
  nSweeps = 1000, nBurn = 1000, seedProfRegr = 123)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simBenchmark_+3A_whichmodel">whichModel</code></td>
<td>
<p>Which simulated dataset this benchmark should be carried out for. At the moment this function works only for these datasets structures provided in the package: &quot;clusSummaryBernoulliNormal&quot;,&quot;clusSummaryBernoulliDiscreteSmall&quot;,&quot;clusSummaryCategoricalDiscrete&quot;, &quot;clusSummaryNormalDiscrete&quot;,&quot;clusSummaryNormalNormal&quot;, &quot;clusSummaryNormalNormalSpatial&quot;,
&quot;clusSummaryVarSelectBernoulliDiscrete&quot;, &quot;clusSummaryBernoulliMixed&quot;. These dataset structures can be used by the function generateSampleDataFile to create simulated datasets.</p>
</td></tr>
<tr><td><code id="simBenchmark_+3A_nsweeps">nSweeps</code></td>
<td>
<p>The number of sweeps of the profile regression algorithm for this benchmarking.</p>
</td></tr>
<tr><td><code id="simBenchmark_+3A_nburn">nBurn</code></td>
<td>
<p>The number of sweeps in the burn in of the profile regression algorithm for this benchmarking.</p>
</td></tr> 
<tr><td><code id="simBenchmark_+3A_seedprofregr">seedProfRegr</code></td>
<td>
<p>Sets the seed for the random number generation in profile regression (ie. sets the seed for the portion of the MCMC code in C++). Note that setting this seed does not mean that the function simBenchmark will give the same answer. This is because the first step of this function generates a random sample, which will vary in each run unless a global seed is set in R using the function set.seed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function creates a data.frame. Each row corresponds to each observation in the generated dataset. The columns are: 
</p>
<table>
<tr><td><code>clusterAllocation</code></td>
<td>
<p>Cluster allocation carried out by profile regression. These values are integers, corresponding to cluster numbers.</p>
</td></tr>
<tr><td><code>outcome</code></td>
<td>
<p>Value of the outcome (y) in the dataset.</p>
</td></tr>
<tr><td><code>generatingCluster</code></td>
<td>
<p>Cluster allocation in the data generating mechanism. These values are characters which include the word 'Known' and then the original numbering of the cluster. The word 'Known' is included to avoid confusion with the cluster allocations identified by profile regression. </p>
</td></tr>
</table>


<h3>Authors</h3>

<p>Silvia Liverani, Queen Mary University of London, UK
</p>
<p>Austin Gratton, University of North Carolina Wilmington, USA
</p>
<p>Maintainer: Silvia Liverani &lt;liveranis@gmail.com&gt;
</p>


<h3>References</h3>

<p>Silvia Liverani, David I. Hastie, Lamiae Azizi, Michail Papathomas, Sylvia Richardson (2015). PReMiuM: An R Package for Profile Regression Mixture Models Using Dirichlet Processes. Journal of Statistical Software, 64(7), 1-30. <a href="https://doi.org/10.18637/jss.v064.i07">doi:10.18637/jss.v064.i07</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# vector of all test datasets allowed by this benchmarking function
testDatasets&lt;-c("clusSummaryBernoulliNormal",
  "clusSummaryBernoulliDiscreteSmall","clusSummaryCategoricalDiscrete",
  "clusSummaryNormalDiscrete","clusSummaryNormalNormal", 
  "clusSummaryNormalNormalSpatial","clusSummaryVarSelectBernoulliDiscrete", 
  "clusSummaryBernoulliMixed")

# runs profile regression on all datasets and 
# computes confusion matrix for each one
for (i in 1:length(testDatasets)){
  tester&lt;-simBenchmark(testDatasets[i])
  print(table(tester[,c(1,3)]))
}



## End(Not run)
</code></pre>

<hr>
<h2 id='summariseVarSelectRho'>summariseVarSelectRho</h2><span id='topic+summariseVarSelectRho'></span>

<h3>Description</h3>

<p>This function summarises the posterior distribution of rho, a parameter for variable selection only.</p>


<h3>Usage</h3>

<pre><code class='language-R'>summariseVarSelectRho(runInfoObj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summariseVarSelectRho_+3A_runinfoobj">runInfoObj</code></td>
<td>
<p>Object of type runInfoObj</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following elements.
</p>
<table>
<tr><td><code>rho</code></td>
<td>
<p>A matrix that has as many columns as the number of covariates and as many rows as the number of sweeps. This matrix records the samples from the posterior distribution of rho for each covariate at each sweep.</p>
</td></tr>
<tr><td><code>rhoMean</code></td>
<td>
<p>Vector with the column means of the matrix rho above. Each value corresponds to the posterior mean of rho for each covariate.</p>
</td></tr>
<tr><td><code>rhoMedian</code></td>
<td>
<p>Vector with the column medians of the matrix rho above. Each value corresponds to the posterior median of rho for each covariate.</p>
</td></tr>
<tr><td><code>rhoLowerCI</code></td>
<td>
<p>Vector with the column lower confidence intervals of the matrix rho above. Each value corresponds to the lower confidence interval of the posterior distribution of rho for each covariate.</p>
</td></tr>
<tr><td><code>rhoUpperCI</code></td>
<td>
<p>Vector with the column upper confidence intervals of the matrix rho above. Each value corresponds to the upper confidence interval of the posterior distribution of rho for each covariate.</p>
</td></tr>
</table>


<h3>Authors</h3>

<p>David Hastie, Department of Epidemiology and Biostatistics, Imperial College London, UK
</p>
<p>Silvia Liverani, Department of Epidemiology and Biostatistics, Imperial College London and MRC Biostatistics Unit, Cambridge, UK
</p>
<p>Maintainer: Silvia Liverani &lt;liveranis@gmail.com&gt;
</p>


<h3>References</h3>

<p>Silvia Liverani, David I. Hastie, Lamiae Azizi, Michail Papathomas, Sylvia Richardson (2015). PReMiuM: An R Package for Profile Regression Mixture Models Using Dirichlet Processes. Journal of Statistical Software, 64(7), 1-30. <a href="https://doi.org/10.18637/jss.v064.i07">doi:10.18637/jss.v064.i07</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
inputs &lt;- generateSampleDataFile(clusSummaryVarSelectBernoulliDiscrete())

runInfoObj&lt;-profRegr(yModel=inputs$yModel, 
    xModel=inputs$xModel, nSweeps=10, nClusInit=15, 
    nBurn=20, data=inputs$inputData, output="output", 
    covNames = inputs$covNames, varSelect="Continuous")

rho&lt;-summariseVarSelectRho(runInfoObj)

## End(Not run)
</code></pre>

<hr>
<h2 id='vec2mat'>Vector to upper triangular matrix</h2><span id='topic+vec2mat'></span>

<h3>Description</h3>

<p>Function to convert a vector to an upper triangular matrix. The vector does not include the diagonal values, which are then set equal to 1 in the matrix. The matrix is filled by row. </p>


<h3>Usage</h3>

<pre><code class='language-R'>vec2mat(data = NA, nrow = 1) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vec2mat_+3A_data">data</code></td>
<td>
<p>The vector to be converted, excluding the diagonal which is set equal to 1.</p>
</td></tr>
<tr><td><code id="vec2mat_+3A_nrow">nrow</code></td>
<td>
<p>The number of rows (and columns) of the resulting matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The symmetric matrix. The matrix is filled by column.
</p>


<h3>Authors</h3>

<p>Silvia Liverani, Department of Epidemiology and Biostatistics, Imperial College London and MRC Biostatistics Unit, Cambridge, UK
</p>
<p>Maintainer: Silvia Liverani &lt;liveranis@gmail.com&gt;
</p>


<h3>References</h3>

<p>Silvia Liverani, David I. Hastie, Lamiae Azizi, Michail Papathomas, Sylvia Richardson (2015). PReMiuM: An R Package for Profile Regression Mixture Models Using Dirichlet Processes. Journal of Statistical Software, 64(7), 1-30. <a href="https://doi.org/10.18637/jss.v064.i07">doi:10.18637/jss.v064.i07</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>vec2mat(data=c(1,2,3),nrow=3)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
