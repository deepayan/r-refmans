<!DOCTYPE html><html lang="en"><head><title>Help for package fdesigns</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {fdesigns}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#fdesigns-package'>
<p>Optimal Experimental Designs for Functional/Dynamic Models</p></a></li>
<li><a href='#fglmobjects'><p>Print and Summary of <code>fglm</code> Objects</p></a></li>
<li><a href='#flmobjects'><p>Print and Summary of <code>flm</code> Objects</p></a></li>
<li><a href='#P'><p>Compute Profile Factor Polynomials</p></a></li>
<li><a href='#pfglm'><p>Optimal designs for functional generalised linear</p>
models using the coordinate exchange algorithm</a></li>
<li><a href='#pflm'><p>Optimal designs for functional linear models</p>
using the coordinate exchange algorithm</a></li>
<li><a href='#plot.fglm'><p>Plot of <code>fglm</code> Objects</p></a></li>
<li><a href='#plot.flm'><p>Plot of <code>flm</code> Objects</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Optimal Experimental Designs for Functional/Dynamic Models</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-08-10</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Damianos Michaelides &lt;dm3g15@soton.ac.uk&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Optimal experimental designs for functional linear and functional generalised linear models, for scalar responses and profile/dynamic factors. The designs are optimised using the coordinate exchange algorithm. The methods are discussed by Michaelides (2023) <a href="https://eprints.soton.ac.uk/474982/1/Thesis_DamianosMichaelides_Final_pdfa_1_.pdf">https://eprints.soton.ac.uk/474982/1/Thesis_DamianosMichaelides_Final_pdfa_1_.pdf</a>.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp, Matrix, parallel, mvQuad, mvtnorm, stats, graphics</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-08-26 13:31:48 UTC; damianosmichaelides</td>
</tr>
<tr>
<td>Author:</td>
<td>Damianos Michaelides [aut, cre],
  Antony Overstall [aut],
  Dave Woods [aut]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-08-29 19:10:06 UTC</td>
</tr>
</table>
<hr>
<h2 id='fdesigns-package'>
Optimal Experimental Designs for Functional/Dynamic Models
</h2><span id='topic+fdesigns-package'></span><span id='topic+fdesigns'></span>

<h3>Description</h3>

<p>Optimal experimental designs for functional linear and functional generalised linear models, for scalar responses and profile/dynamic factors. The designs are optimised using the coordinate exchange algorithm. The methods are discussed by Michaelides (2023) &lt;https://eprints.soton.ac.uk/474982/1/Thesis_DamianosMichaelides_Final_pdfa_1_.pdf&gt;.
</p>


<h3>Details</h3>

<p>The DESCRIPTION file:
</p>

<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> fdesigns</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Title: </td><td style="text-align: left;"> Optimal Experimental Designs for Functional/Dynamic Models</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 1.0</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2024-08-10</td>
</tr>
<tr>
 <td style="text-align: left;">
Authors@R: </td><td style="text-align: left;"> c(person(given = "Damianos",
                      family = "Michaelides",
                      role = c("aut", "cre"),
                      email = "dm3g15@soton.ac.uk"),
               person(given = "Antony",
                      family = "Overstall",
                      role = "aut"),
               person(given = "Dave",
                      family = "Woods",
                      role = "aut"))</td>
</tr>
<tr>
 <td style="text-align: left;">
Maintainer: </td><td style="text-align: left;"> Damianos Michaelides &lt;dm3g15@soton.ac.uk&gt;</td>
</tr>
<tr>
 <td style="text-align: left;">
Description: </td><td style="text-align: left;"> Optimal experimental designs for functional linear and functional generalised linear models, for scalar responses and profile/dynamic factors. The designs are optimised using the coordinate exchange algorithm. The methods are discussed by Michaelides (2023) &lt;https://eprints.soton.ac.uk/474982/1/Thesis_DamianosMichaelides_Final_pdfa_1_.pdf&gt;.</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL-2</td>
</tr>
<tr>
 <td style="text-align: left;">
Imports: </td><td style="text-align: left;"> Rcpp, Matrix, parallel, mvQuad, mvtnorm, stats, graphics</td>
</tr>
<tr>
 <td style="text-align: left;">
LinkingTo: </td><td style="text-align: left;"> Rcpp, RcppArmadillo</td>
</tr>
<tr>
 <td style="text-align: left;">
Author: </td><td style="text-align: left;"> Damianos Michaelides [aut, cre],
  Antony Overstall [aut],
  Dave Woods [aut]</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>The most important functions are <a href="#topic+pflm">pflm</a> and <a href="#topic+pfglm">pfglm</a> which can be used to identify optimal designs for functional linear and generalised linear models, respectively, using the coordinate exchange algorithm.</p>


<h3>Author(s)</h3>

<p>Damianos Michaelides [aut, cre],
  Antony Overstall [aut],
  Dave Woods [aut]
</p>
<p>Maintainer: Damianos Michaelides &lt;dm3g15@soton.ac.uk&gt;
</p>


<h3>References</h3>

<p>Michaelides, D. (2023). Design of experiments for models involving profile factors (Doctoral dissertation, University of Southampton).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Example 1:
## This example involves finding an A-optimal design for a functional linear model of 4 runs
## depending on one profile factor. The settings of the profile factor are represented by a 
## B-spline basis of degree zero and a single knot at (0.5). The single functional parameter 
## is represented with a linear power series basis. Five random starts are chosen.

example1 &lt;- pflm(formula = ~ x1, nsd = 5, mc.cores = 1, npf = 1,
  tbounds = c(0, 1), nruns = 4, startd = NULL,  dx = c(0), 
  knotsx = list(c(0.5)), pars = c("power"), db = c(1), 
  knotsb = list(c()), criterion = "A", lambda = 0, 
  dlbound = -1, dubound = 1, tol = 0.0001, progress = FALSE)

print(example1) ##  prints the output of example1.
##
## The number of profile factors is: 1
##
## The number of runs is: 4
##
## The objective criterion is: A-optimality
##
## The objective value is: 8.75
##
## The number of iterations is: 6
##
## The computing elapsed time is: 00:00:00


## Example 2:
## This example involves finding an A-optimal design for a functional logistic
## model of 12 runs depending on one profile factor. The settings of the profile 
## factor are represented by a B-spline basis of degree zero and a three interior knots 
## at (0.25, 0.50, 0.75). The single functional parameter is represented with a linear 
## power series basis. The method of approximation is Monte Carlo with the prior 
## specified by the function prmc. Three random starts are chosen.

set.seed(100) ## Set seed to achieve reproducibility.

prmc &lt;- function(B,Q) {
  matrix(rnorm(B*Q, mean=0, sd=sqrt(2)), nrow=B, ncol=Q)
}
## A function which specifies the prior. This function returns a 
## B by Q matrix of randomly generated values from the prior 
## distribution for the model parameters.


example2 &lt;- pfglm(formula = ~ 1 + x1, nsd = 3, mc.cores = 1, npf = 1, 
             tbounds = c(0,1), nruns = 12, startd = NULL, 
             dx = c(0), knotsx = list(c(0.25,0.50,0.75)), 
             pars = c("power"), db = c(1), knotsb = list(c()), 
             lambda = 0, criterion = "A", family = binomial,
             method=c("MC"), level = 6, B = 10000, prior = prmc,
             dlbound = -1, dubound = 1, tol = 0.0001, progress = TRUE)

print(example2) ##  prints the output of example1.
##
## The number of profile factors is: 1
##
## The number of runs is: 12
##
## The objective criterion is: A-optimality
##
## The objective value is: 20.23283
##
## The number of iterations is: 5
##
## The method of approximation is: MC
##
## The family distribution and the link function are: binomial and logit
##
## The computing elapsed time is: 00:00:12

</code></pre>

<hr>
<h2 id='fglmobjects'>Print and Summary of <code>fglm</code> Objects</h2><span id='topic+print.fglm'></span><span id='topic+summary.fglm'></span>

<h3>Description</h3>

<p>Print and Summary of objects of class <code>"fglm"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fglm'
print(x, ...)
## S3 method for class 'fglm'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fglmobjects_+3A_x">x</code></td>
<td>
<p>An object of class <code>"fglm"</code>.</p>
</td></tr>
<tr><td><code id="fglmobjects_+3A_object">object</code></td>
<td>
<p>An object of class <code>"fglm"</code>.</p>
</td></tr>
<tr><td><code id="fglmobjects_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The functions return the number of profile factors in the functional generalised linear 
model, the number of runs, the criterion, the objective value of the final design,
the number of iterations of the coordinate exchange algorithm to get to the final
design, the method of approximation of the expectation of the objective function, the family 
distribution and link function, and the computational elapsed time in hours:minutes:seconds. 
</p>


<h3>Note</h3>

<p>For examples see <a href="#topic+pfglm">pfglm</a>.
</p>


<h3>Author(s)</h3>

<p>Damianos Michaelides &lt;<a href="mailto:dm3g15@soton.ac.uk">dm3g15@soton.ac.uk</a>&gt;, Antony Overstall, Dave Woods
</p>

<hr>
<h2 id='flmobjects'>Print and Summary of <code>flm</code> Objects</h2><span id='topic+print.flm'></span><span id='topic+summary.flm'></span>

<h3>Description</h3>

<p>Print and Summary of objects of class <code>"flm"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'flm'
print(x, ...)
## S3 method for class 'flm'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="flmobjects_+3A_x">x</code></td>
<td>
<p>An object of class <code>"flm"</code>.</p>
</td></tr>
<tr><td><code id="flmobjects_+3A_object">object</code></td>
<td>
<p>An object of class <code>"flm"</code>.</p>
</td></tr>
<tr><td><code id="flmobjects_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The functions return the number of profile factors in the functional linear model, 
the number of runs, the criterion, the objective value of the final design,
the number of iterations of the coordinate exchange algorithm to get to the final
design, and the computational elapsed time in hours:minutes:seconds. 
</p>


<h3>Note</h3>

<p>For examples see <a href="#topic+pflm">pflm</a>.
</p>


<h3>Author(s)</h3>

<p>Damianos Michaelides &lt;<a href="mailto:dm3g15@soton.ac.uk">dm3g15@soton.ac.uk</a>&gt;, Antony Overstall, Dave Woods
</p>

<hr>
<h2 id='P'>Compute Profile Factor Polynomials</h2><span id='topic+P'></span>

<h3>Description</h3>

<p>A function to be used in the formula argument in <a href="#topic+pflm">pflm</a> and <a href="#topic+pfglm">pfglm</a>. 
It computes polynomials of the basis functions of profile factors to be passed 
in functional models and find optimal designs. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>P(x, deg)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="P_+3A_x">x</code></td>
<td>
<p>A coefficient matrix from the basis expansion of a profile factor. The name passed needs
to match the name of the profile factor in startd in <a href="#topic+pflm">pflm</a> and <a href="#topic+pfglm">pfglm</a>.</p>
</td></tr>
<tr><td><code id="P_+3A_deg">deg</code></td>
<td>
<p>The degree of the polynomial effect for the profile factor.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <a href="#topic+P">P</a> is intented to be used in the formula argument in the 
function <a href="#topic+pflm">pflm</a> and <a href="#topic+pfglm">pfglm</a>. 
</p>
<p>In the traditional linear models, polynomial effects of factors are handled using the 
function <a href="base.html#topic+I">I</a>. However, profile factors are expanded using basis functions
and the coefficients are a matrix instead of a vector. 
</p>
<p>In other words, the function <a href="#topic+P">P</a> is an extension to the function <a href="base.html#topic+I">I</a>,
but for functional models with profile factors. 
</p>


<h3>Value</h3>

<p>The function returns an attributes list. The list contains the polynomial coefficient matrix,
the argument x, and the argument deg.
</p>


<h3>Author(s)</h3>

<p>Damianos Michaelides &lt;<a href="mailto:dm3g15@soton.ac.uk">dm3g15@soton.ac.uk</a>&gt;, Antony Overstall, Dave Woods
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Example 1:

d &lt;- list(x1=matrix(runif(48), nrow=12))
within(d, example1 &lt;- P(x = x1, deg = 2))


## Example 2: Use the function in a formula
## This example involves finding a D-optimal design for a functional linear model of n=20 runs
## depending on two profile factors. In addition to the main effects, the model includes the
## interaction of the profile factors and the quadratic effect of the second profile factor. 
## The quadratic effect is identified in the formula argument using the \link[fdesigns]{P} function. 

example2 &lt;- pflm(formula = ~ x1 + x2 + x1:x2 + P(x2, 2), nsd = 1, mc.cores = 1,
  npf = 2, tbounds = c(0, 1), nruns = 20, startd=NULL, dx = c(2, 2),
  knotsx = list(c(0.33, 0.66), c(0.25, 0.50, 0.75)), 
  pars = c("power", "power", "bspline", "bspline"), db = c(1, 1, 2, 2), 
  knotsb = list(c(), c(), c(0.25, 0.50, 0.75), c(0.25, 0.50, 0.75)), 
  criterion = "D", lambda = 1, tol = 0.0001, dlbound = -1, dubound = 1, 
  progress = FALSE)

</code></pre>

<hr>
<h2 id='pfglm'>Optimal designs for functional generalised linear 
models using the coordinate exchange algorithm</h2><span id='topic+pfglm'></span>

<h3>Description</h3>

<p>Optimal designs for functional generalised linear models for which the functional factors are represented
as B-spline basis functions and the functional parameters are represented as power series basis functions
or as B-spline basis functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pfglm(formula, nsd = 1, mc.cores = 1, npf, tbounds, nruns, startd = NULL, 
        dx, knotsx, pars, db, knotsb = NULL, lambda = 0, criterion = c("A","D"),
        family, method = c("quadrature", "MC"), level = NULL, B = NULL, prior, 
        dlbound = -1, dubound = 1, tol = 0.0001, progress = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pfglm_+3A_formula">formula</code></td>
<td>
<p>Object of type formula, to create the model equation. Elements need to match the list names for startd. Main effects are called using the names of the profile factors in startd, interactions are called using the names of the profile factors in startd seperated with :, and polynomial effects are called using
the function <a href="#topic+P">P</a>. Scalar factors are called using the same way and degree and knots through the arguments dx and knotsx are used to specify the scalar factors. A scalar factor is equivalent to a profile factor with degree 0 and no interior knots.</p>
</td></tr>
<tr><td><code id="pfglm_+3A_nsd">nsd</code></td>
<td>
<p>The number of starting designs. The default entry is 1.</p>
</td></tr>
<tr><td><code id="pfglm_+3A_mc.cores">mc.cores</code></td>
<td>
<p>The number of cores to use. The option is initialized from environment variable MC_CORES if set. Must be at least one, and for parallel computing at least two cores are required. The default entry is 1.</p>
</td></tr>
<tr><td><code id="pfglm_+3A_npf">npf</code></td>
<td>
<p>The total number of (functional) factors in the model.</p>
</td></tr>
<tr><td><code id="pfglm_+3A_tbounds">tbounds</code></td>
<td>
<p>A time vector of length 2, representing the boundaries of time, i.e., 0 and T.</p>
</td></tr>
<tr><td><code id="pfglm_+3A_nruns">nruns</code></td>
<td>
<p>The number of runs of the experiment.</p>
</td></tr>
<tr><td><code id="pfglm_+3A_startd">startd</code></td>
<td>
<p>Representing the starting design but if NULL then random designs are automatically generated. 
It should be a list of length nsd, and each component should be a list of length npf.</p>
</td></tr>
<tr><td><code id="pfglm_+3A_dx">dx</code></td>
<td>
<p>A vector of length npf, representing the degree of B-spline basis functions for the functions of the
functional factors. A scalar factor must have a zero degree entry.</p>
</td></tr>
<tr><td><code id="pfglm_+3A_knotsx">knotsx</code></td>
<td>
<p>A list of length npf, with every object in the list representing the knot vectors of 
each functional factor. A Scalar factor must have no interior knots, i.e., an empty knot vector.</p>
</td></tr>
<tr><td><code id="pfglm_+3A_pars">pars</code></td>
<td>
<p>A vector of length equal to the total terms in formula, representing the basis choice for 
the (functional) parameters. Entries should be &quot;power&quot; or &quot;bspline&quot;. A scalar parameter is represented through a &quot;power&quot; basis.</p>
</td></tr>
<tr><td><code id="pfglm_+3A_db">db</code></td>
<td>
<p>A vector of length equal to the total terms in formula, representing the degree of the basis for
the (functional) parameters. For power series basis the degree is: 1 for linear, 2 for quadratic, etc. A scalar parameter must have degree 0.</p>
</td></tr>
<tr><td><code id="pfglm_+3A_knotsb">knotsb</code></td>
<td>
<p>A list of length equal to the total terms in formula, representing the knot vector of each 
(functional) parameter. For parameters represented by a power series basis, the knot vector should be empty or NULL.</p>
</td></tr>
<tr><td><code id="pfglm_+3A_lambda">lambda</code></td>
<td>
<p>Smoothing parameter to penalise the complexity of the functions of the profile factors. The default value is 0, i.e., no penalty.</p>
</td></tr>
<tr><td><code id="pfglm_+3A_criterion">criterion</code></td>
<td>
<p>The choice of objective function. Currently there are two available choices:
1. A-optimality (criterion = &quot;A&quot;);
2. D-optimality (criterion = &quot;D&quot;).</p>
</td></tr>
<tr><td><code id="pfglm_+3A_family">family</code></td>
<td>
<p>Specifies the error distribution and the link function of the functional generalised linear model. It can be the name of a family in the form of a character string or an R family function; see <a href="stats.html#topic+family">family</a> for details. Currently, the methodology is implemented only for the binomial family with the logit link, i.e., family = binomial(link = &quot;logit&quot;), and the Poisson family with the log link, i.e., family = poisson(link = &quot;log&quot;).</p>
</td></tr>
<tr><td><code id="pfglm_+3A_method">method</code></td>
<td>
<p>A character argument specifying the method of approximation of the expectation of the objective function with respect to a prior distribution of the parameters. Currently there are two available choices:
1. Deterministic quadrature approximation (method = &quot;quadrature&quot;);
2. Stochastic Monte Carlo approximation (method = &quot;MC&quot;).</p>
</td></tr>
<tr><td><code id="pfglm_+3A_level">level</code></td>
<td>
<p>An optional argument that specifies the accuracy level in the quadrature approximation. It is the number of points in each dimension. If NULL and method = &quot;quadrature&quot;, then it defaults to 5. A high value of level may increase the computation time; especially for complicated models. If the model is complicated, i.e., several profile factors or interactions and polynomials, prefer to use method = &quot;MC&quot;.</p>
</td></tr>
<tr><td><code id="pfglm_+3A_b">B</code></td>
<td>
<p>An optional argument that specifies the size of the Monte Carlo samples. If NULL and method = &quot;MC&quot;, then it defaults to 10000. For method = &quot;quadrature&quot;, B is computer automatically according to the dimensionality of the functional model and the level argument.</p>
</td></tr>
<tr><td><code id="pfglm_+3A_prior">prior</code></td>
<td>
<p>An argument to specify the prior distribution.
For method = &quot;MC&quot;, it should be a function of two arguments B and Q. Both arguments are integers. The value of B corresponds to the argument B, and the value of Q represents the total number of basis functions of the functional parameters. The function must generate a matrix of dimensions B by Q, that contains a random sample from the prior distribution of the parameters.
For method = &quot;quadrature&quot;, normal and uniform prior distribution for the parameters are allowed. For a normal prior distribution, the argument prior needs to be a list of length 2, with the entries named &quot;mu&quot; for the prior mean and &quot;sigma2&quot; for the prior variance-covariance matrix. The prior mean can be a scalar value that means all parameters have the same prior mean, or a vector of prior means with length equal to the number of parameters in the functional model. The prior variance-covariance can be a scalar value that means all parameters have a common variance, or a vector of prior variances with length equal to the number of parameters in the functional model, or a square matrix with the number of rows and columns equal to he number of parameters in the functional model. For a uniform prior distribution, the argument prior needs to be a list of a single entry named &quot;unifbound&quot; for the lower and upper bounds of the prior distribution. The bounds can be a vector of length 2 that means all parameters have the same bounds, or a matrix with the number of rows equal to 2 and the number of columns equal to the number of parameters in the functional model.</p>
</td></tr>
<tr><td><code id="pfglm_+3A_dlbound">dlbound</code></td>
<td>
<p>The design's lower bound. The default lower bound is -1.</p>
</td></tr>
<tr><td><code id="pfglm_+3A_dubound">dubound</code></td>
<td>
<p>The design's upper bound. The default upper bound is 1.</p>
</td></tr>
<tr><td><code id="pfglm_+3A_tol">tol</code></td>
<td>
<p>The tolerance value in the optimisation algorithm. Default value is 0.0001.</p>
</td></tr>
<tr><td><code id="pfglm_+3A_progress">progress</code></td>
<td>
<p>If TRUE, it returns the progress of iterations from the optimisation process. The default entry is FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns an object of class &quot;pfglm&quot; which is a list with the following components:
</p>
<table role = "presentation">
<tr><td><code>objective.value</code></td>
<td>
<p>The objective value of the final design found from pfglm.</p>
</td></tr> 
<tr><td><code>design</code></td>
<td>
<p>The final design found from pfglm. The final design is a list of length equal to the number
of profile factors, exactly as the starting design startd.</p>
</td></tr>
<tr><td><code>n.iterations</code></td>
<td>
<p>The total number of iterations needed to identify the final design.</p>
</td></tr> 
<tr><td><code>time</code></td>
<td>
<p>The computational elapsed time in finding the final design.</p>
</td></tr> 
<tr><td><code>startd</code></td>
<td>
<p>If starting designs were passed as an argument in pfglm, then this is the argument startd. 
If no starting designs were passed to pfglm, this is the starting design generated randomly by pfglm.</p>
</td></tr>
<tr><td><code>tbounds</code></td>
<td>
<p>The argument tbounds.</p>
</td></tr>
<tr><td><code>npf</code></td>
<td>
<p>The argument npf.</p>
</td></tr>
<tr><td><code>criterion</code></td>
<td>
<p>The argument criterion.</p>
</td></tr>
<tr><td><code>nruns</code></td>
<td>
<p>The argument nruns.</p>
</td></tr>
<tr><td><code>formula</code></td>
<td>
<p>The argument formula.</p>
</td></tr>
<tr><td><code>family</code></td>
<td>
<p>A vector of length equal to 2, containing the family and the link function.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>The argument method.</p>
</td></tr>
<tr><td><code>B</code></td>
<td>
<p>The argument B.</p>
</td></tr>
<tr><td><code>prior</code></td>
<td>
<p>The argument prior.</p>
</td></tr>
<tr><td><code>dx</code></td>
<td>
<p>The argument dx.</p>
</td></tr>
<tr><td><code>knotsx</code></td>
<td>
<p>The argument knotsx.</p>
</td></tr>
<tr><td><code>lambda</code></td>
<td>
<p>The argument lambda.</p>
</td></tr>
<tr><td><code>dbounds</code></td>
<td>
<p>A vector of length 2, containing the arguments dlbound and dubound.</p>
</td></tr>
<tr><td><code>bestrep</code></td>
<td>
<p>A scalar value indicating the repetition that led to the final design.</p>
</td></tr>
<tr><td><code>allobjvals</code></td>
<td>
<p>A vector of length equal to nsd, representing the objective value from all of the repetitions.</p>
</td></tr>
<tr><td><code>alldesigns</code></td>
<td>
<p>A list of length equal to nsd of all the final designs. Each component of the list is a list of length equal to npf representing the final design in each repetition of the coordinate exchange algorithm.</p>
</td></tr>
<tr><td><code>allstartd</code></td>
<td>
<p>If starting designs were passed as an argument in pfglm, then this is the argument. If no starting designs were passed to pfglm, this is the starting designs generated randomly by pfglm.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Damianos Michaelides &lt;<a href="mailto:dm3g15@soton.ac.uk">dm3g15@soton.ac.uk</a>&gt;, Antony Overstall, Dave Woods
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Example 1:
## This example involves finding an A-optimal design for a functional logistic
## model of 12 runs depending on one profile factor. The settings of the profile 
## factor are represented by a B-spline basis of degree zero and a three interior knots 
## at (0.25, 0.50, 0.75). The single functional parameter is represented with a linear 
## power series basis. The method of approximation is Monte Carlo with the prior 
## specified by the function prmc. Three random starts are chosen.

set.seed(100) ## Set seed to achieve reproducibility.

prmc &lt;- function(B,Q) {
  matrix(rnorm(B*Q, mean=0, sd=sqrt(2)), nrow=B, ncol=Q)
}
## A function which specifies the prior. This function returns a 
## B by Q matrix of randomly generated values from the prior 
## distribution for the model parameters.

example1 &lt;- pfglm(formula = ~ 1 + x1, nsd = 3, mc.cores = 1, npf = 1, 
             tbounds = c(0,1), nruns = 12, startd = NULL, 
             dx = c(0), knotsx = list(c(0.25,0.50,0.75)), 
             pars = c("power"), db = c(1), knotsb = list(c()), 
             lambda = 0, criterion = "A", family = binomial,
             method=c("MC"), level = 6, B = 10000, prior = prmc,
             dlbound = -1, dubound = 1, tol = 0.0001, progress = FALSE)

print(example1) ##  prints the output of example1.
##
## The number of profile factors is: 1
##
## The number of runs is: 12
##
## The objective criterion is: A-optimality
##
## The objective value is: 20.23283
##
## The number of iterations is: 5
##
## The method of approximation is: MC
##
## The family distribution and the link function are: binomial and logit
##
## The computing elapsed time is: 00:00:12
##
## plot(example1)
## then give the number of profile factor to plot


## Example 2:
## This example involves finding a A-optimal design for a functional logistic
## model of 8 runs depending on one profile factor. The settings of the profile 
## factor are represented by a B-spline basis of degree zero and a single interior knot 
## at 0.50. The single functional parameter is represented with a linear 
## power series basis. The method of approximation is Quadrature with Normal prior 
## distribution, with all parameters having mean 0 and variance 2. 
## Five random starts are chosen.

example2 &lt;- pfglm(formula = ~ 1 + x1, nsd = 5, mc.cores = 1, npf = 1, 
                  tbounds = c(0,1), nruns = 8, startd = NULL, 
                  dx = c(0), knotsx = list(c(0.25,0.50,0.75)), 
                  pars = c("power"), db = c(1), knotsb = list(c()), 
                  lambda = 0, criterion = "A", family = binomial, 
                  method = c("quadrature"), level = NULL, B = NULL, 
                  prior = list(mu = c(0), sigma2 = c(2)), 
                  dlbound = -1, dubound = 1, tol = 0.0001, 
                  progress = FALSE)

## The number of profile factors is: 1
## 
## The number of runs is: 8
## 
## The objective criterion is: A-optimality
## 
## The objective value is: 31.32342
## 
## The number of iterations is: 9
## 
## The method of approximation is: quadrature
## 
## The family distribution and the link function are: binomial and logit
## 
## The computing elapsed time is: 00:00:00
</code></pre>

<hr>
<h2 id='pflm'>Optimal designs for functional linear models 
using the coordinate exchange algorithm</h2><span id='topic+pflm'></span>

<h3>Description</h3>

<p>Optimal designs for functional linear models for which the functional factors are represented
as B-spline basis functions and the functional parameters are represented as power series basis functions
or as B-spline basis functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pflm(formula, nsd = 1, mc.cores = 1, npf, tbounds, 
  nruns, startd = NULL, dx, knotsx, pars, db, 
  knotsb = NULL, criterion = c("A", "D"), lambda = 0,
  dlbound = -1, dubound = 1, tol = 1e-04, progress = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pflm_+3A_formula">formula</code></td>
<td>
<p>Object of type formula, to create the model equation. Elements need to match the list names for startd. Main effects are called using the names of the profile factors in startd, interactions are called using the names of the profile factors in startd seperated with :, and polynomial effects are called using
the function <a href="#topic+P">P</a>. Scalar factors are called using the same way and degree and knots through the arguments dx and knotsx are used to specify the scalar factors. A scalar factor is equivalent to a profile factor with degree 0 and no interior knots.</p>
</td></tr>
<tr><td><code id="pflm_+3A_nsd">nsd</code></td>
<td>
<p>The number of starting designs. The default entry is 1.</p>
</td></tr>
<tr><td><code id="pflm_+3A_mc.cores">mc.cores</code></td>
<td>
<p>The number of cores to use. The option is initialized from environment variable MC_CORES if set. Must be at least one, and for parallel computing at least two cores are required. The default entry is 1.</p>
</td></tr>
<tr><td><code id="pflm_+3A_npf">npf</code></td>
<td>
<p>The total number of (profile) factors in the model.</p>
</td></tr>
<tr><td><code id="pflm_+3A_tbounds">tbounds</code></td>
<td>
<p>A time vector of length 2, representing the boundaries of time, i.e., 0 and T.</p>
</td></tr>
<tr><td><code id="pflm_+3A_nruns">nruns</code></td>
<td>
<p>The number of runs of the experiment.</p>
</td></tr>
<tr><td><code id="pflm_+3A_startd">startd</code></td>
<td>
<p>Representing the starting design but if NULL then random designs are automatically generated. 
It should be a list of length nsd, and each component should be a list of length npf.</p>
</td></tr>
<tr><td><code id="pflm_+3A_dx">dx</code></td>
<td>
<p>A vector of length npf, representing the degree of B-spline basis functions for the functions of the
functional factors. A scalar factor must have a zero degree entry.</p>
</td></tr>
<tr><td><code id="pflm_+3A_knotsx">knotsx</code></td>
<td>
<p>A list of length npf, with every object in the list representing the knot vectors of 
each functional factor. A Scalar factor must have no interior knots, i.e., an empty knot vector.</p>
</td></tr>
<tr><td><code id="pflm_+3A_pars">pars</code></td>
<td>
<p>A vector of length equal to the total terms in formula, representing the basis choice for 
the (functional) parameters. Entries should be &quot;power&quot; or &quot;bspline&quot;. A scalar parameter is represented through a &quot;power&quot; basis.</p>
</td></tr>
<tr><td><code id="pflm_+3A_db">db</code></td>
<td>
<p>A vector of length equal to the total terms in formula, representing the degree of the basis for
the (functional) parameters. For power series basis the degree is: 1 for linear, 2 for quadratic, etc. A scalar parameter must have degree 0.</p>
</td></tr>
<tr><td><code id="pflm_+3A_knotsb">knotsb</code></td>
<td>
<p>A list of length equal to the total terms in formula, representing the knot vector of each 
(functional) parameter. For parameters represented by a power series basis, the knot vector should be empty or NULL.</p>
</td></tr>
<tr><td><code id="pflm_+3A_lambda">lambda</code></td>
<td>
<p>Smoothing parameter to penalise the complexity of the functions of the profile factors. The default value is 0, i.e., no penalty.</p>
</td></tr>
<tr><td><code id="pflm_+3A_criterion">criterion</code></td>
<td>
<p>The choice of objective function. Currently there are two available choices:
1. A-optimality (criterion = &quot;A&quot;);
2. D-optimality (criterion = &quot;D&quot;).</p>
</td></tr>
<tr><td><code id="pflm_+3A_tol">tol</code></td>
<td>
<p>The tolerance value in the optimisation algorithm. Default value is 0.0001.</p>
</td></tr>
<tr><td><code id="pflm_+3A_dlbound">dlbound</code></td>
<td>
<p>The design's lower bound. The default lower bound is -1.</p>
</td></tr>
<tr><td><code id="pflm_+3A_dubound">dubound</code></td>
<td>
<p>The design's upper bound. The default upper bound is 1.</p>
</td></tr>
<tr><td><code id="pflm_+3A_progress">progress</code></td>
<td>
<p>If TRUE, it returns the progress of iterations from the optimisation process. The default entry is FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns an object of class &quot;pflm&quot; which is a list with the following components:
</p>
<table role = "presentation">
<tr><td><code>objval</code></td>
<td>
<p>The objective value of the final design found from pflm.</p>
</td></tr> 
<tr><td><code>design</code></td>
<td>
<p>The final design found from pflm. The final design is a list of length equal to the number
of profile factors, exactly as the starting design startd.</p>
</td></tr>
<tr><td><code>nits</code></td>
<td>
<p>The total number of iterations needed to identify the final design.</p>
</td></tr> 
<tr><td><code>time</code></td>
<td>
<p>The computational elapsed time in finding the final design.</p>
</td></tr> 
<tr><td><code>startd</code></td>
<td>
<p>If starting designs were passed as an argument in pflm, then this is the starting design from the argument startd that led to the final design. If no starting designs were passed to pflm, this is the starting design generated randomly by pflm that led to the final design.</p>
</td></tr>
<tr><td><code>tbounds</code></td>
<td>
<p>The argument tbounds.</p>
</td></tr>
<tr><td><code>npf</code></td>
<td>
<p>The argument npf.</p>
</td></tr>
<tr><td><code>criterion</code></td>
<td>
<p>The argument criterion.</p>
</td></tr>
<tr><td><code>nruns</code></td>
<td>
<p>The argument nruns.</p>
</td></tr>
<tr><td><code>formula</code></td>
<td>
<p>The argument formula.</p>
</td></tr>
<tr><td><code>dx</code></td>
<td>
<p>The argument dx.</p>
</td></tr>
<tr><td><code>knotsx</code></td>
<td>
<p>The argument knotsx.</p>
</td></tr>
<tr><td><code>lambda</code></td>
<td>
<p>The argument lambda.</p>
</td></tr>
<tr><td><code>dbounds</code></td>
<td>
<p>A vector of length 2, containing the arguments dlbound and dubound.</p>
</td></tr>
<tr><td><code>bestrep</code></td>
<td>
<p>A scalar value indicating the repetition that led to the final design.</p>
</td></tr>
<tr><td><code>allobjvals</code></td>
<td>
<p>A vector of length equal to nsd, representing the objective value from all of the repetitions.</p>
</td></tr>
<tr><td><code>alldesigns</code></td>
<td>
<p>A list of length equal to nsd of all the final designs. Each component of the list is a list of length equal to npf representing the final design in each repetition of the coordinate exchange algorithm.</p>
</td></tr>
<tr><td><code>allstartd</code></td>
<td>
<p>If starting designs were passed as an argument in pflm, then this is the argument. If no starting designs were passed to pflm, this is the starting designs generated randomly by pflm.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Damianos Michaelides &lt;<a href="mailto:dm3g15@soton.ac.uk">dm3g15@soton.ac.uk</a>&gt;, Antony Overstall, Dave Woods
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Example 1:
## This example involves finding an A-optimal design for a functional linear model of 4 runs
## depending on one profile factor. The settings of the profile factor are represented by a 
## B-spline basis of degree zero and a single knot at (0.5). The single functional parameter 
## is represented with a linear power series basis. Five random starts are chosen.

example1 &lt;- pflm(formula = ~ x1, nsd = 5, mc.cores = 1, npf = 1,
  tbounds = c(0, 1), nruns = 4, startd = NULL,  dx = c(0), 
  knotsx = list(c(0.5)), pars = c("power"), db = c(1), 
  knotsb = list(c()), criterion = "A", lambda = 0, 
  dlbound = -1, dubound = 1, tol = 0.0001, progress = FALSE)

print(example1) ##  prints the output of example1.
##
## The number of profile factors is: 1
##
## The number of runs is: 4
##
## The objective criterion is: A-optimality
##
## The objective value is: 8.75
##
## The number of iterations is: 6
##
## The computing elapsed time is: 00:00:00

## plot(example1)
## then give the number of profile factor to plot


## Example 2:
## This example involves finding a D-optimal design for a functional linear model of n=20 runs
## depending on two profile factors. In addition to the main effects, the model includes the
## interaction of the profile factors and the quadratic effect of the second profile factor. 
## The settings of the profile factors are represented by B-spline basis of quadratic degrees
## and knots at (0.33, 0.66) and (0.25, 0.50, 0.75). The functional parameters are represented 
## with linear power basis and quadratic B-spline basis with knots at (0.25, 0.50, 0.75). 
## The complexity of the designs is penalised with the smoothing value equal to 1.

example2 &lt;- pflm(formula = ~ x1 + x2 + x1:x2 + P(x2, 2), nsd = 1, mc.cores = 1,
  npf = 2, tbounds = c(0, 1), nruns = 20, startd = NULL, dx = c(2, 2),
  knotsx = list(c(0.33, 0.66), c(0.25, 0.50, 0.75)), 
  pars = c("power", "power", "bspline", "bspline"), db = c(1, 1, 2, 2), 
  knotsb = list(c(), c(), c(0.25, 0.50, 0.75), c(0.25, 0.50, 0.75)), 
  criterion = "D", lambda = 1, tol = 0.0001, dlbound = -1, dubound = 1, 
  progress = FALSE)

print(example2) ##  prints the output of example2.
##
## The number of profile factors is: 2
##
## The number of runs is: 20
##
## The objective criterion is: D-optimality
##
## The objective value is: 0.05706758
##
## The number of iterations is: 6
##
## The computing elapsed time is: 00:00:17

</code></pre>

<hr>
<h2 id='plot.fglm'>Plot of <code>fglm</code> Objects</h2><span id='topic+plot.fglm'></span>

<h3>Description</h3>

<p>Plot of <code>"fglm"</code> objects. For the choice of a profile factor, the optimal functions are plotted.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fglm'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.fglm_+3A_x">x</code></td>
<td>
<p>An object of class <code>"fglm"</code>.</p>
</td></tr>
<tr><td><code id="plot.fglm_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns the question:
&quot;Which profile factor to plot?&quot;.
The answer needs to be an integer to specify the profile factor for which 
to plot the optimal functions in every run. The value needs to be between 
1 and the argument npf from the function <a href="#topic+pfglm">pfglm</a>. 
</p>
<p>After that, the function returns n.runs (see <a href="#topic+pfglm">pfglm</a>) plots of the optimal functions, 
of the profile factor indicated. The x-axis represents the time, the y-axis represents the
values of the function of the profile factor, and the title indicated the number of run of 
each plot. 
</p>


<h3>Note</h3>

<p>For examples see <a href="#topic+pflm">pflm</a>.
</p>


<h3>Author(s)</h3>

<p>Damianos Michaelides &lt;<a href="mailto:dm3g15@soton.ac.uk">dm3g15@soton.ac.uk</a>&gt;, Antony Overstall, Dave Woods
</p>

<hr>
<h2 id='plot.flm'>Plot of <code>flm</code> Objects</h2><span id='topic+plot.flm'></span>

<h3>Description</h3>

<p>Plot of <code>"flm"</code> objects. For the choice of a profile factor, the optimal functions are plotted.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'flm'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.flm_+3A_x">x</code></td>
<td>
<p>An object of class <code>"flm"</code>.</p>
</td></tr>
<tr><td><code id="plot.flm_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns the question:
&quot;Which profile factor to plot?&quot;.
The answer needs to be an integer to specify the profile factor for which 
to plot the optimal functions in every run. The value needs to be between 
1 and the argument npf from the function <a href="#topic+pflm">pflm</a>. 
</p>
<p>After that, the function returns n.runs (see <a href="#topic+pflm">pflm</a>) plots of the optimal functions 
of the profile factor indicated. The x-axis represents the time, the y-axis represents the
values of the function of the profile factor, and the title indicated the number of run of 
each plot. 
</p>


<h3>Note</h3>

<p>For examples see <a href="#topic+pflm">pflm</a>.
</p>


<h3>Author(s)</h3>

<p>Damianos Michaelides &lt;<a href="mailto:dm3g15@soton.ac.uk">dm3g15@soton.ac.uk</a>&gt;, Antony Overstall, Dave Woods
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
