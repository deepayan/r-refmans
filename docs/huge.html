<!DOCTYPE html><html><head><title>Help for package huge</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {huge}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#huge-package'><p>High-Dimensional Undirected Graph Estimation</p></a></li>
<li><a href='#huge'><p>High-dimensional undirected graph estimation</p></a></li>
<li><a href='#huge.ct'><p>Graph estimation via correlation thresholding (ct)</p></a></li>
<li><a href='#huge.generator'><p>Data generator</p></a></li>
<li><a href='#huge.glasso'><p>The graphical lasso (glasso) using sparse matrix output</p></a></li>
<li><a href='#huge.inference'><p>Graph inference</p></a></li>
<li><a href='#huge.mb'><p>Meinshausen &amp; Buhlmann graph estimation</p></a></li>
<li><a href='#huge.npn'><p>Nonparanormal(npn) transformation</p></a></li>
<li><a href='#huge.plot'><p>Graph visualization</p></a></li>
<li><a href='#huge.roc'><p>Draw ROC Curve for a graph path</p></a></li>
<li><a href='#huge.select'><p>Model selection for high-dimensional undirected graph estimation</p></a></li>
<li><a href='#huge.tiger'><p>Tuning-insensitive graph estimation</p></a></li>
<li><a href='#plot.huge'><p>Plot function for S3 class &quot;huge&quot;</p></a></li>
<li><a href='#plot.roc'><p>Plot function for S3 class &quot;roc&quot;</p></a></li>
<li><a href='#plot.select'><p>Plot function for S3 class &quot;select&quot;</p></a></li>
<li><a href='#plot.sim'><p>Plot function for S3 class &quot;sim&quot;</p></a></li>
<li><a href='#print.huge'><p>Print function for S3 class &quot;huge&quot;</p></a></li>
<li><a href='#print.roc'><p>Print function for S3 class &quot;roc&quot;</p></a></li>
<li><a href='#print.select'><p>Print function for S3 class &quot;select&quot;</p></a></li>
<li><a href='#print.sim'><p>Print function for S3 class &quot;sim&quot;</p></a></li>
<li><a href='#stockdata'><p>Stock price of S&amp;P 500 companies from 2003 to 2008</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>High-Dimensional Undirected Graph Estimation</td>
</tr>
<tr>
<td>Version:</td>
<td>1.3.5</td>
</tr>
<tr>
<td>Author:</td>
<td>Haoming Jiang, Xinyu Fei, Han Liu, Kathryn Roeder, John Lafferty, Larry
        Wasserman,  Xingguo Li, and Tuo Zhao</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Haoming Jiang &lt;jianghm.ustc@gmail.com&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>Matrix, igraph, MASS, grDevices, graphics, methods, stats,
utils, Rcpp</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppEigen</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides a general framework for
        high-dimensional undirected graph estimation. It integrates
        data preprocessing, neighborhood screening, graph estimation,
        and model selection techniques into a pipeline. In
        preprocessing stage, the nonparanormal(npn) transformation is
        applied to help relax the normality assumption. In the graph
        estimation stage, the graph structure is estimated by
        Meinshausen-Buhlmann graph estimation or the graphical lasso,
        and both methods can be further accelerated by the lossy
        screening rule preselecting the neighborhood of each variable
        by correlation thresholding. We target on high-dimensional data
        analysis usually d &gt;&gt; n, and the computation is
        memory-optimized using the sparse matrix output. We also
        provide a computationally efficient approach, correlation
        thresholding graph estimation. Three
        regularization/thresholding parameter selection methods are
        included in this package: (1)stability approach for
        regularization selection (2) rotation information criterion (3)
        extended Bayesian information criterion which is only available
        for the graphical lasso.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-06-30 19:55:18 UTC; jhaoming</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-06-30 20:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='huge-package'>High-Dimensional Undirected Graph Estimation</h2><span id='topic+huge-package'></span><span id='topic+_PACKAGE'></span>

<h3>Description</h3>

<p>A package for high-dimensional undirected graph estimation
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
  Package: </td><td style="text-align: left;"> huge</td>
</tr>
<tr>
 <td style="text-align: left;">
  Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
  Version: </td><td style="text-align: left;"> 1.2.7</td>
</tr>
<tr>
 <td style="text-align: left;">
  Date: </td><td style="text-align: left;"> 2015-09-14</td>
</tr>
<tr>
 <td style="text-align: left;">
  License: </td><td style="text-align: left;"> GPL-2</td>
</tr>
<tr>
 <td style="text-align: left;">
  LazyLoad: </td><td style="text-align: left;"> yes</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>The package &quot;huge&quot; provides 8 main functions:<br />
(1) the data generator creates random samples from multivariate normal distributions with different graph structures. Please refer to <code><a href="#topic+huge.generator">huge.generator</a></code>.<br />
(2) the nonparanormal (npn) transformation helps relax the normality assumption. Please refer to <code><a href="#topic+huge.npn">huge.npn</a></code>.<br />
(3) The correlation thresholding graph estimation. Please refer to <code><a href="#topic+huge">huge</a></code>.<br />
(4) The Meinshausen-Buhlmann graph estimation. Please refer to <code><a href="#topic+huge">huge</a></code>.<br />
(5) The graphical Lasso algorithm using lossless screening rule. Please refer and <code><a href="#topic+huge">huge</a></code>.<br />
<br />
**Both (4) and (5) can be further accelerated by the lossy screening rule preselecting the neighborhood of each node via thresholding sample correlation.
<br />
(6) The model selection using the stability approach to regularization selection. Please refer to <code><a href="#topic+huge.select">huge.select</a></code>.<br />
(7) The model selection using the rotation information criterion. Please refer to <code><a href="#topic+huge.select">huge.select</a></code>.<br />
(8) The model selection using the extended Bayesian information criterion. Please refer to <code><a href="#topic+huge.select">huge.select</a></code>.<br />
</p>


<h3>Author(s)</h3>

<p>Tuo Zhao, Han Liu, Haoming Jiang, Kathryn Roeder, John Lafferty, and Larry Wasserman <br />
Maintainers: Haoming Jiang&lt;hjiang98@gatech.edu&gt;;
</p>


<h3>References</h3>

<p>1.  T. Zhao and H. Liu. The huge Package for High-dimensional Undirected Graph Estimation in R. <em>Journal of Machine Learning Research</em>, 2012<br />
2.  H. Liu, F. Han, M. Yuan, J. Lafferty and L. Wasserman. High Dimensional Semiparametric Gaussian Copula Graphical Models. <em>Annals of Statistics</em>,2012 <br />
3.  D. Witten and J. Friedman. New insights and faster computations for the graphical lasso. <em>Journal of Computational and Graphical Statistics</em>, to appear, 2011.
4.  Han Liu, Kathryn Roeder and Larry Wasserman. Stability Approach to Regularization Selection (StARS) for High Dimensional Graphical Models. <em>Advances in Neural Information Processing Systems</em>, 2010.<br />
5.  R. Foygel and M. Drton. Extended bayesian information criteria for gaussian graphical models. <em>Advances in Neural Information Processing Systems</em>, 2010.<br />
6.  H. Liu, J. Lafferty and L. Wasserman. The Nonparanormal: Semiparametric Estimation of High Dimensional Undirected Graphs. <em>Journal of Machine Learning Research</em>, 2009 <br />
7.  J. Fan and J. Lv. Sure independence screening for ultra-high dimensional feature space (with discussion). <em>Journal of Royal Statistical Society B</em>, 2008.<br />
8.  O. Banerjee, L. E. Ghaoui, A. d'Aspremont: Model Selection Through Sparse Maximum Likelihood Estimation for Multivariate Gaussian or Binary Data. <em>Journal of Machine Learning Research</em>, 2008.<br />
9.  J. Friedman, T. Hastie and R. Tibshirani. Regularization Paths for Generalized Linear Models via Coordinate Descent. <em>Journal of Statistical Software</em>, 2008. <br />
10. J. Friedman, T. Hastie and R. Tibshirani. Sparse inverse covariance estimation with the lasso, <em>Biostatistics</em>, 2007.<br />
11. N. Meinshausen and P. Buhlmann. High-dimensional Graphs and Variable Selection with the Lasso. <em>The Annals of Statistics</em>, 2006.<br />
</p>


<h3>See Also</h3>

<p><code><a href="#topic+huge.generator">huge.generator</a></code>, <code><a href="#topic+huge.npn">huge.npn</a></code>, <code><a href="#topic+huge">huge</a></code>, <code><a href="#topic+huge.plot">huge.plot</a></code> and <code><a href="#topic+huge.roc">huge.roc</a></code>
</p>

<hr>
<h2 id='huge'>High-dimensional undirected graph estimation</h2><span id='topic+huge'></span>

<h3>Description</h3>

<p>The main function for high-dimensional undirected graph estimation. Three graph estimation methods, including (1) Meinshausen-Buhlmann graph estimation (<code>mb</code>) (2) graphical lasso (<code>glasso</code>) (3) correlation thresholding graph estimation (<code>ct</code>) and (4) tuning-insensitive graph estimation (<code>tiger</code>), are available for data analysis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>huge(
  x,
  lambda = NULL,
  nlambda = NULL,
  lambda.min.ratio = NULL,
  method = "mb",
  scr = NULL,
  scr.num = NULL,
  cov.output = FALSE,
  sym = "or",
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="huge_+3A_x">x</code></td>
<td>
<p>There are 2 options: (1) <code>x</code> is an <code>n</code> by <code>d</code> data matrix (2) a <code>d</code> by <code>d</code> sample covariance matrix. The program automatically identifies the input matrix by checking the symmetry. (<code>n</code> is the sample size and <code>d</code> is the dimension).</p>
</td></tr>
<tr><td><code id="huge_+3A_lambda">lambda</code></td>
<td>
<p>A sequence of decreasing positive numbers to control the regularization when <code>method = "mb"</code>, <code>"glasso"</code> or <code>"tiger"</code>, or the thresholding in <code>method = "ct"</code>. Typical usage is to leave the input <code>lambda = NULL</code> and have the program compute its own <code>lambda</code> sequence based on <code>nlambda</code> and <code>lambda.min.ratio</code>. Users can also specify a sequence to override this. When <code>method = "mb"</code>, <code>"glasso"</code> or <code>"tiger"</code>, use with care - it is better to supply a decreasing sequence values than a single (small) value.</p>
</td></tr>
<tr><td><code id="huge_+3A_nlambda">nlambda</code></td>
<td>
<p>The number of regularization/thresholding parameters. The default value is <code>30</code> for <code>method = "ct"</code> and <code>10</code> for <code>method = "mb"</code>, <code>"glasso"</code> or <code>"tiger"</code>.</p>
</td></tr>
<tr><td><code id="huge_+3A_lambda.min.ratio">lambda.min.ratio</code></td>
<td>
<p>If <code>method = "mb"</code>, <code>"glasso"</code> or <code>"tiger"</code>, it is the smallest value for <code>lambda</code>, as a fraction of the upperbound (<code>MAX</code>) of the regularization/thresholding parameter which makes all estimates equal to <code>0</code>. The program can automatically generate <code>lambda</code> as a sequence of length = <code>nlambda</code> starting from <code>MAX</code> to <code>lambda.min.ratio*MAX</code> in log scale. If <code>method = "ct"</code>, it is the largest sparsity level for estimated graphs. The program can automatically generate <code>lambda</code> as a sequence of length = <code>nlambda</code>, which makes the sparsity level of the graph path increases from <code>0</code> to <code>lambda.min.ratio</code> evenly.The default value is <code>0.1</code> when <code>method = "mb"</code>, <code>"glasso"</code> or <code>"tiger"</code>, and 0.05 <code>method = "ct"</code>.</p>
</td></tr>
<tr><td><code id="huge_+3A_method">method</code></td>
<td>
<p>Graph estimation methods with 4 options: <code>"mb"</code>, <code>"ct"</code>, <code>"glasso"</code> and <code>"tiger"</code>. The default value is <code>"mb"</code>.</p>
</td></tr>
<tr><td><code id="huge_+3A_scr">scr</code></td>
<td>
<p>If <code>scr = TRUE</code>, the lossy screening rule is applied to preselect the neighborhood before the graph estimation. The default value is  <code>FALSE</code>. NOT applicable when <code>method = "ct"</code>, &quot;mb&quot;, or &quot;tiger&quot;.</p>
</td></tr>
<tr><td><code id="huge_+3A_scr.num">scr.num</code></td>
<td>
<p>The neighborhood size after the lossy screening rule (the number of remaining neighbors per node). ONLY applicable when <code>scr = TRUE</code>. The default value is <code>n-1</code>. An alternative value is <code>n/log(n)</code>. ONLY applicable when <code>scr = TRUE</code> and <code>method = "mb"</code>.</p>
</td></tr>
<tr><td><code id="huge_+3A_cov.output">cov.output</code></td>
<td>
<p>If <code>cov.output = TRUE</code>, the output will include a path of estimated covariance matrices. ONLY applicable when <code>method = "glasso"</code>. Since the estimated covariance matrices are generally not sparse, please use it with care, or it may take much memory under high-dimensional setting. The default value is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="huge_+3A_sym">sym</code></td>
<td>
<p>Symmetrize the output graphs. If <code>sym = "and"</code>, the edge between node <code>i</code> and node <code>j</code> is selected ONLY when both node <code>i</code> and node <code>j</code> are selected as neighbors for each other. If <code>sym = "or"</code>, the edge is selected when either node <code>i</code> or node <code>j</code> is selected as the neighbor for each other. The default value is <code>"or"</code>. ONLY applicable when <code>method = "mb"</code> or &quot;tiger&quot;.</p>
</td></tr>
<tr><td><code id="huge_+3A_verbose">verbose</code></td>
<td>
<p>If <code>verbose = FALSE</code>, tracing information printing is disabled. The default value is <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The graph structure is estimated by Meinshausen-Buhlmann graph estimation or the graphical lasso, and both methods can be further accelerated via the lossy screening rule by preselecting the neighborhood of each variable by correlation thresholding. We target on high-dimensional data analysis usually d &gt;&gt; n, and the computation is memory-optimized using the sparse matrix output. We also provide a highly computationally efficient approaches correlation thresholding graph estimation.
</p>


<h3>Value</h3>

<p>An object with S3 class <code>"huge"</code> is returned:
</p>
<table>
<tr><td><code>data</code></td>
<td>

<p>The <code>n</code> by <code>d</code> data matrix or <code>d</code> by <code>d</code> sample covariance matrix from the input
</p>
</td></tr>
<tr><td><code>cov.input</code></td>
<td>

<p>An indicator of the sample covariance.
</p>
</td></tr>
<tr><td><code>ind.mat</code></td>
<td>

<p>The <code>scr.num</code> by <code>k</code> matrix with each column corresponding to a variable in <code>ind.group</code> and contains the indices of the remaining neighbors after the GSS. ONLY applicable when <code>scr = TRUE</code> and <code>approx = FALSE</code>
</p>
</td></tr>
<tr><td><code>lambda</code></td>
<td>

<p>The sequence of regularization parameters used in mb or thresholding parameters in ct.
</p>
</td></tr>
<tr><td><code>sym</code></td>
<td>

<p>The <code>sym</code> from the input. ONLY applicable when <code>method = "mb"</code> or <code>"tiger"</code>.
</p>
</td></tr>
<tr><td><code>scr</code></td>
<td>

<p>The <code>scr</code> from the input. ONLY applicable when <code>method = "mb"</code> or <code>"glasso"</code>.
</p>
</td></tr>
<tr><td><code>path</code></td>
<td>

<p>A list of <code>k</code> by <code>k</code> adjacency matrices of estimated graphs as a graph path corresponding to <code>lambda</code>.
</p>
</td></tr>
<tr><td><code>sparsity</code></td>
<td>

<p>The sparsity levels of the graph path.
</p>
</td></tr>
<tr><td><code>icov</code></td>
<td>

<p>A list of <code>d</code> by <code>d</code> precision matrices as an alternative graph path (numerical path) corresponding to <code>lambda</code>. ONLY applicable when <code>method = "glasso"</code> or <code>"tiger"</code>.
</p>
</td></tr>
<tr><td><code>cov</code></td>
<td>

<p>A list of <code>d</code> by <code>d</code> estimated covariance matrices corresponding to <code>lambda</code>. ONLY applicable when <code>cov.output = TRUE</code> and <code>method = "glasso"</code>
</p>
</td></tr>
<tr><td><code>method</code></td>
<td>

<p>The method used in the graph estimation stage.
</p>
</td></tr>
<tr><td><code>df</code></td>
<td>

<p>If <code>method = "mb"</code> or <code>"tiger"</code>, it is a <code>k</code> by <code>nlambda</code> matrix. Each row contains the number of nonzero coefficients along the lasso solution path. If <code>method = "glasso"</code>, it is a <code>nlambda</code> dimensional vector containing the number of nonzero coefficients along the graph path <code>icov</code>.
</p>
</td></tr>
<tr><td><code>loglik</code></td>
<td>

<p>A <code>nlambda</code> dimensional vector containing the likelihood scores along the graph path (<code>icov</code>). ONLY applicable when <code>method = "glasso"</code>. For an estimated inverse covariance Z, the program only calculates log(det(Z)) - trace(SZ) where S is the empirical covariance matrix. For the likelihood for n observations, please multiply by n/2.
</p>
</td></tr>
</table>


<h3>Note</h3>

<p>This function ONLY estimates the graph path. For more information about the optimal graph selection, please refer to <code><a href="#topic+huge.select">huge.select</a></code>.<br />
</p>


<h3>See Also</h3>

<p><code><a href="#topic+huge.generator">huge.generator</a></code>, <code><a href="#topic+huge.select">huge.select</a></code>, <code><a href="#topic+huge.plot">huge.plot</a></code>, <code><a href="#topic+huge.roc">huge.roc</a></code>, and <code><a href="#topic+huge-package">huge-package</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#generate data
L = huge.generator(n = 50, d = 12, graph = "hub", g = 4)

#graph path estimation using mb
out1 = huge(L$data)
out1
plot(out1)         #Not aligned
plot(out1, align = TRUE) #Aligned
huge.plot(out1$path[[3]])

#graph path estimation using the sample covariance matrix as the input.
#out1 = huge(cor(L$data), method = "glasso")
#out1
#plot(out1)         #Not aligned
#plot(out1, align = TRUE) #Aligned
#huge.plot(out1$path[[3]])

#graph path estimation using ct
#out2 = huge(L$data,method = "ct")
#out2
#plot(out2)

#graph path estimation using glasso
#out3 = huge(L$data, method = "glasso")
#out3
#plot(out3)

#graph path estimation using tiger
#out4 = huge(L$data, method = "tiger")
#out4
#plot(out4)
</code></pre>

<hr>
<h2 id='huge.ct'>Graph estimation via correlation thresholding (ct)</h2><span id='topic+huge.ct'></span>

<h3>Description</h3>

<p>See more details in <code><a href="#topic+huge">huge</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>huge.ct(
  x,
  nlambda = NULL,
  lambda.min.ratio = NULL,
  lambda = NULL,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="huge.ct_+3A_x">x</code></td>
<td>
<p>There are 2 options: (1) <code>x</code> is an <code>n</code> by <code>d</code> data matrix (2) a <code>d</code> by <code>d</code> sample covariance matrix. The program automatically identifies the input matrix by checking the symmetry. (<code>n</code> is the sample size and <code>d</code> is the dimension).</p>
</td></tr>
<tr><td><code id="huge.ct_+3A_nlambda">nlambda</code></td>
<td>
<p>The number of regularization/thresholding parameters. The default value is <code>30</code> for <code>method = "ct"</code> and <code>10</code> for <code>method = "mb"</code>, <code>"glasso"</code> or <code>"tiger"</code>.</p>
</td></tr>
<tr><td><code id="huge.ct_+3A_lambda.min.ratio">lambda.min.ratio</code></td>
<td>
<p>If <code>method = "mb"</code>, <code>"glasso"</code> or <code>"tiger"</code>, it is the smallest value for <code>lambda</code>, as a fraction of the upperbound (<code>MAX</code>) of the regularization/thresholding parameter which makes all estimates equal to <code>0</code>. The program can automatically generate <code>lambda</code> as a sequence of length = <code>nlambda</code> starting from <code>MAX</code> to <code>lambda.min.ratio*MAX</code> in log scale. If <code>method = "ct"</code>, it is the largest sparsity level for estimated graphs. The program can automatically generate <code>lambda</code> as a sequence of length = <code>nlambda</code>, which makes the sparsity level of the graph path increases from <code>0</code> to <code>lambda.min.ratio</code> evenly.The default value is <code>0.1</code> when <code>method = "mb"</code>, <code>"glasso"</code> or <code>"tiger"</code>, and 0.05 <code>method = "ct"</code>.</p>
</td></tr>
<tr><td><code id="huge.ct_+3A_lambda">lambda</code></td>
<td>
<p>A sequence of decreasing positive numbers to control the regularization when <code>method = "mb"</code>, <code>"glasso"</code> or <code>"tiger"</code>, or the thresholding in <code>method = "ct"</code>. Typical usage is to leave the input <code>lambda = NULL</code> and have the program compute its own <code>lambda</code> sequence based on <code>nlambda</code> and <code>lambda.min.ratio</code>. Users can also specify a sequence to override this. When <code>method = "mb"</code>, <code>"glasso"</code> or <code>"tiger"</code>, use with care - it is better to supply a decreasing sequence values than a single (small) value.</p>
</td></tr>
<tr><td><code id="huge.ct_+3A_verbose">verbose</code></td>
<td>
<p>If <code>verbose = FALSE</code>, tracing information printing is disabled. The default value is <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+huge">huge</a></code>, and <code><a href="#topic+huge-package">huge-package</a></code>.
</p>

<hr>
<h2 id='huge.generator'>Data generator</h2><span id='topic+huge.generator'></span>

<h3>Description</h3>

<p>Implements the data generation from multivariate normal distributions with different graph structures, including <code>"random"</code>, <code>"hub"</code>, <code>"cluster"</code>, <code>"band"</code> and <code>"scale-free"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>huge.generator(
  n = 200,
  d = 50,
  graph = "random",
  v = NULL,
  u = NULL,
  g = NULL,
  prob = NULL,
  vis = FALSE,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="huge.generator_+3A_n">n</code></td>
<td>
<p>The number of observations (sample size). The default value is <code>200</code>.</p>
</td></tr>
<tr><td><code id="huge.generator_+3A_d">d</code></td>
<td>
<p>The number of variables (dimension). The default value is <code>50</code>.</p>
</td></tr>
<tr><td><code id="huge.generator_+3A_graph">graph</code></td>
<td>
<p>The graph structure with 4 options: <code>"random"</code>, <code>"hub"</code>, <code>"cluster"</code>, <code>"band"</code> and <code>"scale-free"</code>.</p>
</td></tr>
<tr><td><code id="huge.generator_+3A_v">v</code></td>
<td>
<p>The off-diagonal elements of the precision matrix, controlling the magnitude of partial correlations with <code>u</code>. The default value is <code>0.3</code>.</p>
</td></tr>
<tr><td><code id="huge.generator_+3A_u">u</code></td>
<td>
<p>A positive number being added to the diagonal elements of the precision matrix, to control the magnitude of partial correlations. The default value is <code>0.1</code>.</p>
</td></tr>
<tr><td><code id="huge.generator_+3A_g">g</code></td>
<td>
<p>For <code>"cluster"</code> or <code>"hub"</code> graph, <code>g</code> is the number of hubs or clusters in the graph. The default value is about <code>d/20</code> if <code>d &gt;= 40</code> and <code>2</code> if <code>d &lt; 40</code>. For <code>"band"</code> graph, <code>g</code> is the bandwidth and the default value is <code>1</code>. NOT applicable to <code>"random"</code> graph.</p>
</td></tr>
<tr><td><code id="huge.generator_+3A_prob">prob</code></td>
<td>
<p>For <code>"random"</code> graph, it is the probability that a pair of nodes has an edge. The default value is <code>3/d</code>. For <code>"cluster"</code> graph, it is the probability that a pair of nodes has an edge in each cluster. The default value is <code>6*g/d</code> if <code>d/g &lt;= 30</code> and <code>0.3</code> if <code>d/g &gt; 30</code>. NOT applicable to <code>"hub"</code> or <code>"band"</code> graphs.</p>
</td></tr>
<tr><td><code id="huge.generator_+3A_vis">vis</code></td>
<td>
<p>Visualize the adjacency matrix of the true graph structure, the graph pattern, the covariance matrix and the empirical covariance matrix. The default value is <code>FALSE</code></p>
</td></tr>
<tr><td><code id="huge.generator_+3A_verbose">verbose</code></td>
<td>
<p>If <code>verbose = FALSE</code>, tracing information printing is disabled. The default value is <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given the adjacency matrix <code>theta</code>, the graph patterns are generated as below:<br /><br />
(I) <code>"random"</code>: Each pair of off-diagonal elements are randomly set <code>theta[i,j]=theta[j,i]=1</code> for <code>i!=j</code> with probability <code>prob</code>, and <code>0</code> other wise. It results in about <code>d*(d-1)*prob/2</code> edges in the graph.<br /><br />
(II)<code>"hub"</code>:The row/columns are evenly partitioned into <code>g</code> disjoint groups. Each group is associated with a &quot;center&quot; row <code>i</code> in that group. Each pair of off-diagonal elements are set <code>theta[i,j]=theta[j,i]=1</code> for <code>i!=j</code> if <code>j</code> also belongs to the same group as <code>i</code> and <code>0</code> otherwise. It results in <code>d - g</code> edges in the graph.<br /><br />
(III)<code>"cluster"</code>:The row/columns are evenly partitioned into <code>g</code> disjoint groups. Each pair of off-diagonal elements are set <code>theta[i,j]=theta[j,i]=1</code> for <code>i!=j</code> with the probability <code>prob</code>if both <code>i</code> and <code>j</code> belong to the same group, and <code>0</code> other wise. It results in about <code>g*(d/g)*(d/g-1)*prob/2</code> edges in the graph.<br /><br />
(IV)<code>"band"</code>: The off-diagonal elements are set to be <code>theta[i,j]=1</code> if <code>1&lt;=|i-j|&lt;=g</code> and <code>0</code> other wise. It results in <code>(2d-1-g)*g/2</code> edges in the graph.<br /><br />
(V) <code>"scale-free"</code>: The graph is generated using B-A algorithm. The initial graph has two connected nodes and each new node is connected to only one node in the existing graph with the probability proportional to the degree of the each node in the existing graph. It results in <code>d</code> edges in the graph.
</p>
<p>The adjacency matrix <code>theta</code> has all diagonal elements equal to <code>0</code>. To obtain a positive definite precision matrix, the smallest eigenvalue of <code>theta*v</code> (denoted by <code>e</code>) is computed. Then we set the precision matrix equal to <code>theta*v+(|e|+0.1+u)I</code>. The covariance matrix is then computed to generate multivariate normal data.
</p>


<h3>Value</h3>

<p>An object with S3 class &quot;sim&quot; is returned:
</p>
<table>
<tr><td><code>data</code></td>
<td>

<p>The <code>n</code> by <code>d</code> matrix for the generated data
</p>
</td></tr>
<tr><td><code>sigma</code></td>
<td>

<p>The covariance matrix for the generated data
</p>
</td></tr>
<tr><td><code>omega</code></td>
<td>

<p>The precision matrix for the generated data
</p>
</td></tr>
<tr><td><code>sigmahat</code></td>
<td>

<p>The empirical covariance matrix for the generated data
</p>
</td></tr>
<tr><td><code>theta</code></td>
<td>

<p>The adjacency matrix of true graph structure (in sparse matrix representation) for the generated data
</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+huge">huge</a></code> and <code><a href="#topic+huge-package">huge-package</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## band graph with bandwidth 3
L = huge.generator(graph = "band", g = 3)
plot(L)

## random sparse graph
L = huge.generator(vis = TRUE)

## random dense graph
L = huge.generator(prob = 0.5, vis = TRUE)

## hub graph with 6 hubs
L = huge.generator(graph = "hub", g = 6, vis = TRUE)

## hub graph with 8 clusters
L = huge.generator(graph = "cluster", g = 8, vis = TRUE)

## scale-free graphs
L = huge.generator(graph="scale-free", vis = TRUE)
</code></pre>

<hr>
<h2 id='huge.glasso'>The graphical lasso (glasso) using sparse matrix output</h2><span id='topic+huge.glasso'></span>

<h3>Description</h3>

<p>See more details in <code><a href="#topic+huge">huge</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>huge.glasso(
  x,
  lambda = NULL,
  lambda.min.ratio = NULL,
  nlambda = NULL,
  scr = NULL,
  cov.output = FALSE,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="huge.glasso_+3A_x">x</code></td>
<td>
<p>There are 2 options: (1) <code>x</code> is an <code>n</code> by <code>d</code> data matrix (2) a <code>d</code> by <code>d</code> sample covariance matrix. The program automatically identifies the input matrix by checking the symmetry. (<code>n</code> is the sample size and <code>d</code> is the dimension).</p>
</td></tr>
<tr><td><code id="huge.glasso_+3A_lambda">lambda</code></td>
<td>
<p>A sequence of decreasing positive numbers to control the regularization when <code>method = "mb"</code>, <code>"glasso"</code> or <code>"tiger"</code>, or the thresholding in <code>method = "ct"</code>. Typical usage is to leave the input <code>lambda = NULL</code> and have the program compute its own <code>lambda</code> sequence based on <code>nlambda</code> and <code>lambda.min.ratio</code>. Users can also specify a sequence to override this. When <code>method = "mb"</code>, <code>"glasso"</code> or <code>"tiger"</code>, use with care - it is better to supply a decreasing sequence values than a single (small) value.</p>
</td></tr>
<tr><td><code id="huge.glasso_+3A_lambda.min.ratio">lambda.min.ratio</code></td>
<td>
<p>If <code>method = "mb"</code>, <code>"glasso"</code> or <code>"tiger"</code>, it is the smallest value for <code>lambda</code>, as a fraction of the upperbound (<code>MAX</code>) of the regularization/thresholding parameter which makes all estimates equal to <code>0</code>. The program can automatically generate <code>lambda</code> as a sequence of length = <code>nlambda</code> starting from <code>MAX</code> to <code>lambda.min.ratio*MAX</code> in log scale. If <code>method = "ct"</code>, it is the largest sparsity level for estimated graphs. The program can automatically generate <code>lambda</code> as a sequence of length = <code>nlambda</code>, which makes the sparsity level of the graph path increases from <code>0</code> to <code>lambda.min.ratio</code> evenly.The default value is <code>0.1</code> when <code>method = "mb"</code>, <code>"glasso"</code> or <code>"tiger"</code>, and 0.05 <code>method = "ct"</code>.</p>
</td></tr>
<tr><td><code id="huge.glasso_+3A_nlambda">nlambda</code></td>
<td>
<p>The number of regularization/thresholding parameters. The default value is <code>30</code> for <code>method = "ct"</code> and <code>10</code> for <code>method = "mb"</code>, <code>"glasso"</code> or <code>"tiger"</code>.</p>
</td></tr>
<tr><td><code id="huge.glasso_+3A_scr">scr</code></td>
<td>
<p>If <code>scr = TRUE</code>, the lossy screening rule is applied to preselect the neighborhood before the graph estimation. The default value is  <code>FALSE</code>. NOT applicable when <code>method = "ct"</code>, &quot;mb&quot;, or &quot;tiger&quot;.</p>
</td></tr>
<tr><td><code id="huge.glasso_+3A_cov.output">cov.output</code></td>
<td>
<p>If <code>cov.output = TRUE</code>, the output will include a path of estimated covariance matrices. ONLY applicable when <code>method = "glasso"</code>. Since the estimated covariance matrices are generally not sparse, please use it with care, or it may take much memory under high-dimensional setting. The default value is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="huge.glasso_+3A_verbose">verbose</code></td>
<td>
<p>If <code>verbose = FALSE</code>, tracing information printing is disabled. The default value is <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+huge">huge</a></code>, and <code><a href="#topic+huge-package">huge-package</a></code>.
</p>

<hr>
<h2 id='huge.inference'>Graph inference</h2><span id='topic+huge.inference'></span>

<h3>Description</h3>

<p>Implements the inference for high dimensional graphical models, including Gaussian and Nonparanormal graphical models
We consider the problems of testing the presence of a single edge and the hypothesis is that the edge is absent.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>huge.inference(data, T, adj, alpha = 0.05, type = "Gaussian", method = "score")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="huge.inference_+3A_data">data</code></td>
<td>
<p>The input <code>n</code> by <code>d</code> data matrix(<code>n</code> is the sample size and <code>d</code> is the dimension).</p>
</td></tr>
<tr><td><code id="huge.inference_+3A_t">T</code></td>
<td>
<p>The estimated inverse of correlation matrix of the data.</p>
</td></tr>
<tr><td><code id="huge.inference_+3A_adj">adj</code></td>
<td>
<p>The adjacency matrix corresponding to the graph.</p>
</td></tr>
<tr><td><code id="huge.inference_+3A_alpha">alpha</code></td>
<td>
<p>The significance level of hypothesis.The default value is <code>0.05</code>.</p>
</td></tr>
<tr><td><code id="huge.inference_+3A_type">type</code></td>
<td>
<p>The type of input data. There are 2 options: <code>"Gaussian"</code> and <code>"Nonparanormal"</code>. The default value is <code>"Gaussian"</code>.</p>
</td></tr>
<tr><td><code id="huge.inference_+3A_method">method</code></td>
<td>
<p>When using nonparanormal graphical model. Test method with 2 options: <code>"score"</code> and <code>"wald"</code>. The default value is <code>"score"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For Nonparanormal graphical model we provide Score test method and Wald Test. However it is really slow for inferencing on Nonparanormal model, especially for large data.
</p>


<h3>Value</h3>

<p>An object is returned:
</p>
<table>
<tr><td><code>data</code></td>
<td>

<p>The <code>n</code> by <code>d</code> data matrix from the input.
</p>
</td></tr>
<tr><td><code>p</code></td>
<td>

<p>The <code>d</code> by <code>d</code> p-value matrix of hypothesis.
</p>
</td></tr>
<tr><td><code>error</code></td>
<td>

<p>The type I error of hypothesis at alpha significance level.
</p>
</td></tr>
</table>


<h3>References</h3>

<p>1.Q Gu, Y Cao, Y Ning, H Liu. Local and global inference for high dimensional nonparanormal graphical models.<br />
2.J Jankova, S Van De Geer. Confidence intervals for high-dimensional inverse covariance estimation. <em>Electronic Journal of Statistics</em>, 2015.<br />
</p>


<h3>See Also</h3>

<p><code><a href="#topic+huge">huge</a></code>, and <code><a href="#topic+huge-package">huge-package</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#generate data
L = huge.generator(n = 50, d = 12, graph = "hub", g = 4)

#graph path estimation using glasso
est = huge(L$data, method = "glasso")

#inference of Gaussian graphical model at 0.05 significance level
T = tail(est$icov, 1)[[1]]
out1 = huge.inference(L$data, T, L$theta)

#inference of Nonparanormal graphical model using score test at 0.05 significance level
T = tail(est$icov, 1)[[1]]
out2 = huge.inference(L$data, T, L$theta, type = "Nonparanormal")

#inference of Nonparanormal graphical model using wald test at 0.05 significance level
T = tail(est$icov, 1)[[1]]
out3 = huge.inference(L$data, T, L$theta, type = "Nonparanormal", method = "wald")

#inference of Nonparanormal graphical model using wald test at 0.1 significance level
T = tail(est$icov, 1)[[1]]
out4 = huge.inference(L$data, T, L$theta, 0.1, type = "Nonparanormal", method = "wald")
</code></pre>

<hr>
<h2 id='huge.mb'>Meinshausen &amp; Buhlmann graph estimation</h2><span id='topic+huge.mb'></span>

<h3>Description</h3>

<p>See more details in <code><a href="#topic+huge">huge</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>huge.mb(
  x,
  lambda = NULL,
  nlambda = NULL,
  lambda.min.ratio = NULL,
  scr = NULL,
  scr.num = NULL,
  idx.mat = NULL,
  sym = "or",
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="huge.mb_+3A_x">x</code></td>
<td>
<p>There are 2 options: (1) <code>x</code> is an <code>n</code> by <code>d</code> data matrix (2) a <code>d</code> by <code>d</code> sample covariance matrix. The program automatically identifies the input matrix by checking the symmetry. (<code>n</code> is the sample size and <code>d</code> is the dimension).</p>
</td></tr>
<tr><td><code id="huge.mb_+3A_lambda">lambda</code></td>
<td>
<p>A sequence of decreasing positive numbers to control the regularization when <code>method = "mb"</code>, <code>"glasso"</code> or <code>"tiger"</code>, or the thresholding in <code>method = "ct"</code>. Typical usage is to leave the input <code>lambda = NULL</code> and have the program compute its own <code>lambda</code> sequence based on <code>nlambda</code> and <code>lambda.min.ratio</code>. Users can also specify a sequence to override this. When <code>method = "mb"</code>, <code>"glasso"</code> or <code>"tiger"</code>, use with care - it is better to supply a decreasing sequence values than a single (small) value.</p>
</td></tr>
<tr><td><code id="huge.mb_+3A_nlambda">nlambda</code></td>
<td>
<p>The number of regularization/thresholding parameters. The default value is <code>30</code> for <code>method = "ct"</code> and <code>10</code> for <code>method = "mb"</code>, <code>"glasso"</code> or <code>"tiger"</code>.</p>
</td></tr>
<tr><td><code id="huge.mb_+3A_lambda.min.ratio">lambda.min.ratio</code></td>
<td>
<p>If <code>method = "mb"</code>, <code>"glasso"</code> or <code>"tiger"</code>, it is the smallest value for <code>lambda</code>, as a fraction of the upperbound (<code>MAX</code>) of the regularization/thresholding parameter which makes all estimates equal to <code>0</code>. The program can automatically generate <code>lambda</code> as a sequence of length = <code>nlambda</code> starting from <code>MAX</code> to <code>lambda.min.ratio*MAX</code> in log scale. If <code>method = "ct"</code>, it is the largest sparsity level for estimated graphs. The program can automatically generate <code>lambda</code> as a sequence of length = <code>nlambda</code>, which makes the sparsity level of the graph path increases from <code>0</code> to <code>lambda.min.ratio</code> evenly.The default value is <code>0.1</code> when <code>method = "mb"</code>, <code>"glasso"</code> or <code>"tiger"</code>, and 0.05 <code>method = "ct"</code>.</p>
</td></tr>
<tr><td><code id="huge.mb_+3A_scr">scr</code></td>
<td>
<p>If <code>scr = TRUE</code>, the lossy screening rule is applied to preselect the neighborhood before the graph estimation. The default value is  <code>FALSE</code>. NOT applicable when <code>method = "ct"</code>, &quot;mb&quot;, or &quot;tiger&quot;.</p>
</td></tr>
<tr><td><code id="huge.mb_+3A_scr.num">scr.num</code></td>
<td>
<p>The neighborhood size after the lossy screening rule (the number of remaining neighbors per node). ONLY applicable when <code>scr = TRUE</code>. The default value is <code>n-1</code>. An alternative value is <code>n/log(n)</code>. ONLY applicable when <code>scr = TRUE</code> and <code>method = "mb"</code>.</p>
</td></tr>
<tr><td><code id="huge.mb_+3A_idx.mat">idx.mat</code></td>
<td>
<p>Index matrix for screening.</p>
</td></tr>
<tr><td><code id="huge.mb_+3A_sym">sym</code></td>
<td>
<p>Symmetrize the output graphs. If <code>sym = "and"</code>, the edge between node <code>i</code> and node <code>j</code> is selected ONLY when both node <code>i</code> and node <code>j</code> are selected as neighbors for each other. If <code>sym = "or"</code>, the edge is selected when either node <code>i</code> or node <code>j</code> is selected as the neighbor for each other. The default value is <code>"or"</code>. ONLY applicable when <code>method = "mb"</code> or &quot;tiger&quot;.</p>
</td></tr>
<tr><td><code id="huge.mb_+3A_verbose">verbose</code></td>
<td>
<p>If <code>verbose = FALSE</code>, tracing information printing is disabled. The default value is <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+huge">huge</a></code>, and <code><a href="#topic+huge-package">huge-package</a></code>.
</p>

<hr>
<h2 id='huge.npn'>Nonparanormal(npn) transformation</h2><span id='topic+huge.npn'></span>

<h3>Description</h3>

<p>Implements the Gausianization to help relax the assumption of normality.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>huge.npn(x, npn.func = "shrinkage", npn.thresh = NULL, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="huge.npn_+3A_x">x</code></td>
<td>
<p>The <code>n</code> by <code>d</code> data matrix representing <code>n</code> observations in <code>d</code> dimensions</p>
</td></tr>
<tr><td><code id="huge.npn_+3A_npn.func">npn.func</code></td>
<td>
<p>The transformation function used in the npn transformation. If <code>npn.func = "truncation"</code>, the truncated ECDF is applied. If <code>npn.func = "shrinkage"</code>, the shrunken ECDF is applied. The default is <code>"shrinkage"</code>. If <code>npn.func = "skeptic"</code>, the nonparanormal skeptic is applied.</p>
</td></tr>
<tr><td><code id="huge.npn_+3A_npn.thresh">npn.thresh</code></td>
<td>
<p>The truncation threshold used in nonparanormal transformation, ONLY applicable when <code>npn.func = "truncation"</code>. The default value is <code>1/(4*(n^0.25)*</code> <code>sqrt(pi*log(n)))</code>.</p>
</td></tr>
<tr><td><code id="huge.npn_+3A_verbose">verbose</code></td>
<td>
<p>If <code>verbose = FALSE</code>, tracing information printing is disabled. The default value is <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The nonparanormal extends Gaussian graphical models to semiparametric Gaussian copula models.Motivated by sparse additive models, the nonparanormal method estimates the Gaussian copula by marginally transforming the variables using smooth functions.Computationally, the estimation of a nonparanormal transformation is very efficient and only requires one pass of the data matrix.
</p>


<h3>Value</h3>

<table>
<tr><td><code>data</code></td>
<td>

<p>A <code>d</code> by <code>d</code> nonparanormal correlation matrix if <code>npn.func = "skeptic"</code>, and A <code>n</code> by <code>d</code> data matrix representing <code>n</code> observations in <code>d</code> transformed dimensions other wise.
</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+huge">huge</a></code> and <code><a href="#topic+huge-package">huge-package</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># generate nonparanormal data
L = huge.generator(graph = "cluster", g = 5)
L$data = L$data^5

# transform the data using the shrunken ECDF
Q = huge.npn(L$data)

# transform the non-Gaussian data using the truncated ECDF
Q = huge.npn(L$data, npn.func = "truncation")

# transform the non-Gaussian data using the truncated ECDF
Q = huge.npn(L$data, npn.func = "skeptic")
</code></pre>

<hr>
<h2 id='huge.plot'>Graph visualization</h2><span id='topic+huge.plot'></span>

<h3>Description</h3>

<p>Implements the graph visualization using adjacency matrix. It can automatic organize 2D embedding layout.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>huge.plot(
  G,
  epsflag = FALSE,
  graph.name = "default",
  cur.num = 1,
  location = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="huge.plot_+3A_g">G</code></td>
<td>
<p>The adjacency matrix corresponding to the graph.</p>
</td></tr>
<tr><td><code id="huge.plot_+3A_epsflag">epsflag</code></td>
<td>
<p>If <code>epsflag = TRUE</code>, save the plot as an eps file in the target directory. The default value is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="huge.plot_+3A_graph.name">graph.name</code></td>
<td>
<p>The name of the output eps files. The default value is &quot;default&quot;.</p>
</td></tr>
<tr><td><code id="huge.plot_+3A_cur.num">cur.num</code></td>
<td>
<p>The number of plots saved as eps files. Only applicale when <code>epsflag = TRUE</code>. The default value is 1.</p>
</td></tr>
<tr><td><code id="huge.plot_+3A_location">location</code></td>
<td>
<p>Target directory. The default value is the current working directory.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The user can change <code>cur.num</code> to plot several figures and select the best one. The implementation is based on the popular package &quot;igraph&quot;.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+huge">huge</a></code> and <code><a href="#topic+huge-package">huge-package</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## visualize the hub graph
L = huge.generator(graph = "hub")
huge.plot(L$theta)

## visualize the band graph
L = huge.generator(graph = "band",g=5)
huge.plot(L$theta)

## visualize the cluster graph
L = huge.generator(graph = "cluster")
huge.plot(L$theta)

## plot 5 graphs and save the plots as eps files in the tempdir()
huge.plot(L$theta, epsflag = TRUE, cur.num = 5, location = tempdir())
</code></pre>

<hr>
<h2 id='huge.roc'>Draw ROC Curve for a graph path</h2><span id='topic+huge.roc'></span>

<h3>Description</h3>

<p>Draws ROC curve for a graph path according to the true graph structure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>huge.roc(path, theta, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="huge.roc_+3A_path">path</code></td>
<td>
<p>A graph path.</p>
</td></tr>
<tr><td><code id="huge.roc_+3A_theta">theta</code></td>
<td>
<p>The true graph structure.</p>
</td></tr>
<tr><td><code id="huge.roc_+3A_verbose">verbose</code></td>
<td>
<p>If <code>verbose = FALSE</code>, tracing information printing is disabled. The default value is <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>To avoid the horizontal oscillation, false positive rates is automatically sorted in the ascent order and true positive rates also follow the same order.
</p>


<h3>Value</h3>

<p>An object with S3 class &quot;roc&quot; is returned:
</p>
<table>
<tr><td><code>F1</code></td>
<td>

<p>The F1 scores along the graph path.
</p>
</td></tr>
<tr><td><code>tp</code></td>
<td>

<p>The true positive rates along the graph path
</p>
</td></tr>
<tr><td><code>fp</code></td>
<td>

<p>The false positive rates along the graph paths
</p>
</td></tr>
<tr><td><code>AUC</code></td>
<td>

<p>Area under the ROC curve
</p>
</td></tr>
</table>


<h3>Note</h3>

<p>For a lasso regression,  the number of nonzero coefficients is at most <code>n-1</code>. If <code>d&gt;&gt;n</code>, even when regularization parameter is very small, the estimated graph may still be sparse. In this case, the AUC may not be a good choice to evaluate the performance.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+huge">huge</a></code> and <code><a href="#topic+huge-package">huge-package</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#generate data
L = huge.generator(d = 200, graph = "cluster", prob = 0.3)
out1 = huge(L$data)

#draw ROC curve
Z1 = huge.roc(out1$path,L$theta)

#Maximum F1 score
max(Z1$F1)
</code></pre>

<hr>
<h2 id='huge.select'>Model selection for high-dimensional undirected graph estimation</h2><span id='topic+huge.select'></span>

<h3>Description</h3>

<p>Implements the regularization parameter selection for high dimensional undirected graph estimation. The optional approaches are rotation information criterion (ric), stability approach to regularization selection (stars) and extended Bayesian information criterion (ebic).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>huge.select(
  est,
  criterion = NULL,
  ebic.gamma = 0.5,
  stars.thresh = 0.1,
  stars.subsample.ratio = NULL,
  rep.num = 20,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="huge.select_+3A_est">est</code></td>
<td>
<p>An object with S3 class <code>"huge"</code>.</p>
</td></tr>
<tr><td><code id="huge.select_+3A_criterion">criterion</code></td>
<td>
<p>Model selection criterion. <code>"ric"</code> and <code>"stars"</code> are available for all 3 graph estimation methods. <code>ebic</code> is only applicable when <code>est$method = "glasso"</code> in <code>huge()</code>. The default value is <code>"ric"</code>.</p>
</td></tr>
<tr><td><code id="huge.select_+3A_ebic.gamma">ebic.gamma</code></td>
<td>
<p>The tuning parameter for ebic. The default value is 0.5. Only applicable when <code>est$method = "glasso"</code> and <code>criterion = "ebic"</code>.</p>
</td></tr>
<tr><td><code id="huge.select_+3A_stars.thresh">stars.thresh</code></td>
<td>
<p>The variability threshold in stars. The default value is <code>0.1</code>. An alternative value is <code>0.05</code>. Only applicable when <code>criterion = "stars"</code>.</p>
</td></tr>
<tr><td><code id="huge.select_+3A_stars.subsample.ratio">stars.subsample.ratio</code></td>
<td>
<p>The subsampling ratio. The default value is <code>10*sqrt(n)/n</code> when <code>n&gt;144</code> and <code>0.8</code> when <code>n&lt;=144</code>, where <code>n</code> is the sample size. Only applicable when <code>criterion = "stars"</code>.</p>
</td></tr>
<tr><td><code id="huge.select_+3A_rep.num">rep.num</code></td>
<td>
<p>The number of subsamplings when <code>criterion = "stars"</code> or rotations when <code>criterion = "ric"</code>. The default value is <code>20</code>. NOT applicable when <code>criterion = "ebic"</code>.</p>
</td></tr>
<tr><td><code id="huge.select_+3A_verbose">verbose</code></td>
<td>
<p>If <code>verbose = FALSE</code>, tracing information printing is disabled. The default value is <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Stability approach to regularization selection (stars) is a natural way to select optimal regularization parameter for all three estimation methods. It selects the optimal graph by variability of subsamplings and tends to overselect edges in Gaussian graphical models. Besides selecting the regularization parameters, stars can also provide an additional estimated graph by merging the corresponding subsampled graphs using the frequency counts. The subsampling procedure in stars may NOT be very efficient, we also provide the recent developed highly efficient, rotation information criterion approach (ric). Instead of tuning over a grid by cross-validation or subsampling, we directly estimate the optimal regularization parameter based on random Rotations. However, ric usually has very good empirical performances but suffers from underselections sometimes. Therefore, we suggest if user are sensitive of false negative rates, they should either consider increasing <code>r.num</code> or applying the stars to model selection. Extended Bayesian information criterion (ebic) is another competitive approach, but the <code>ebic.gamma</code> can only be tuned by experience.
</p>


<h3>Value</h3>

<p>An object with S3 class &quot;select&quot; is returned:
</p>
<table>
<tr><td><code>refit</code></td>
<td>

<p>The optimal graph selected from the graph path
</p>
</td></tr>
<tr><td><code>opt.icov</code></td>
<td>

<p>The optimal precision matrix from the path only applicable when <code>method = "glasso"</code>
</p>
</td></tr>
<tr><td><code>opt.cov</code></td>
<td>

<p>The optimal covariance matrix from the path only applicable when <code>method = "glasso"</code> and <code>est$cov</code> is available.
</p>
</td></tr>
<tr><td><code>merge</code></td>
<td>

<p>The graph path estimated by merging the subsampling paths. Only applicable when the input <code>criterion = "stars"</code>.
</p>
</td></tr>
<tr><td><code>variability</code></td>
<td>

<p>The variability along the subsampling paths. Only applicable when the input <code>criterion = "stars"</code>.
</p>
</td></tr>
<tr><td><code>ebic.scores</code></td>
<td>

<p>Extended BIC scores for regularization parameter selection. Only applicable when <code>criterion = "ebic"</code>.
</p>
</td></tr>
<tr><td><code>opt.index</code></td>
<td>

<p>The index of the selected regularization parameter. NOT applicable when the input <code>criterion = "ric"</code>
</p>
</td></tr>
<tr><td><code>opt.lambda</code></td>
<td>

<p>The selected regularization/thresholding parameter.
</p>
</td></tr>
<tr><td><code>opt.sparsity</code></td>
<td>

<p>The sparsity level of <code>"refit"</code>.
</p>
</td></tr>
</table>
<p>and anything else included in the input <code>est</code>
</p>


<h3>Note</h3>

<p>The model selection is NOT available when the data input is the sample covariance matrix.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+huge">huge</a></code> and <code><a href="#topic+huge-package">huge-package</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#generate data
L = huge.generator(d = 20, graph="hub")
out.mb = huge(L$data)
out.ct = huge(L$data, method = "ct")
out.glasso = huge(L$data, method = "glasso")

#model selection using ric
out.select = huge.select(out.mb)
plot(out.select)

#model selection using stars
#out.select = huge.select(out.ct, criterion = "stars", stars.thresh = 0.05,rep.num=10)
#plot(out.select)

#model selection using ebic
out.select = huge.select(out.glasso,criterion = "ebic")
plot(out.select)
</code></pre>

<hr>
<h2 id='huge.tiger'>Tuning-insensitive graph estimation</h2><span id='topic+huge.tiger'></span>

<h3>Description</h3>

<p>See more details in <code><a href="#topic+huge">huge</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>huge.tiger(
  x,
  lambda = NULL,
  nlambda = NULL,
  lambda.min.ratio = NULL,
  sym = "or",
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="huge.tiger_+3A_x">x</code></td>
<td>
<p>There are 2 options: (1) <code>x</code> is an <code>n</code> by <code>d</code> data matrix (2) a <code>d</code> by <code>d</code> sample covariance matrix. The program automatically identifies the input matrix by checking the symmetry. (<code>n</code> is the sample size and <code>d</code> is the dimension).</p>
</td></tr>
<tr><td><code id="huge.tiger_+3A_lambda">lambda</code></td>
<td>
<p>A sequence of decreasing positive numbers to control the regularization when <code>method = "mb"</code>, <code>"glasso"</code> or <code>"tiger"</code>, or the thresholding in <code>method = "ct"</code>. Typical usage is to leave the input <code>lambda = NULL</code> and have the program compute its own <code>lambda</code> sequence based on <code>nlambda</code> and <code>lambda.min.ratio</code>. Users can also specify a sequence to override this. When <code>method = "mb"</code>, <code>"glasso"</code> or <code>"tiger"</code>, use with care - it is better to supply a decreasing sequence values than a single (small) value.</p>
</td></tr>
<tr><td><code id="huge.tiger_+3A_nlambda">nlambda</code></td>
<td>
<p>The number of regularization/thresholding parameters. The default value is <code>30</code> for <code>method = "ct"</code> and <code>10</code> for <code>method = "mb"</code>, <code>"glasso"</code> or <code>"tiger"</code>.</p>
</td></tr>
<tr><td><code id="huge.tiger_+3A_lambda.min.ratio">lambda.min.ratio</code></td>
<td>
<p>If <code>method = "mb"</code>, <code>"glasso"</code> or <code>"tiger"</code>, it is the smallest value for <code>lambda</code>, as a fraction of the upperbound (<code>MAX</code>) of the regularization/thresholding parameter which makes all estimates equal to <code>0</code>. The program can automatically generate <code>lambda</code> as a sequence of length = <code>nlambda</code> starting from <code>MAX</code> to <code>lambda.min.ratio*MAX</code> in log scale. If <code>method = "ct"</code>, it is the largest sparsity level for estimated graphs. The program can automatically generate <code>lambda</code> as a sequence of length = <code>nlambda</code>, which makes the sparsity level of the graph path increases from <code>0</code> to <code>lambda.min.ratio</code> evenly.The default value is <code>0.1</code> when <code>method = "mb"</code>, <code>"glasso"</code> or <code>"tiger"</code>, and 0.05 <code>method = "ct"</code>.</p>
</td></tr>
<tr><td><code id="huge.tiger_+3A_sym">sym</code></td>
<td>
<p>Symmetrize the output graphs. If <code>sym = "and"</code>, the edge between node <code>i</code> and node <code>j</code> is selected ONLY when both node <code>i</code> and node <code>j</code> are selected as neighbors for each other. If <code>sym = "or"</code>, the edge is selected when either node <code>i</code> or node <code>j</code> is selected as the neighbor for each other. The default value is <code>"or"</code>. ONLY applicable when <code>method = "mb"</code> or &quot;tiger&quot;.</p>
</td></tr>
<tr><td><code id="huge.tiger_+3A_verbose">verbose</code></td>
<td>
<p>If <code>verbose = FALSE</code>, tracing information printing is disabled. The default value is <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+huge">huge</a></code>, and <code><a href="#topic+huge-package">huge-package</a></code>.
</p>

<hr>
<h2 id='plot.huge'>Plot function for S3 class &quot;huge&quot;</h2><span id='topic+plot.huge'></span>

<h3>Description</h3>

<p>Plot sparsity level information and 3 typical sparse graphs from the graph path.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'huge'
plot(x, align = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.huge_+3A_x">x</code></td>
<td>
<p>An object with S3 class <code>"huge"</code></p>
</td></tr>
<tr><td><code id="plot.huge_+3A_align">align</code></td>
<td>
<p>If <code>align = FALSE</code>, 3 plotted graphs are aligned</p>
</td></tr>
<tr><td><code id="plot.huge_+3A_...">...</code></td>
<td>
<p>System reserved (No specific usage)</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+huge">huge</a></code>
</p>

<hr>
<h2 id='plot.roc'>Plot function for S3 class &quot;roc&quot;</h2><span id='topic+plot.roc'></span>

<h3>Description</h3>

<p>Plot the ROC curve for an object with S3 class <code>"roc"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'roc'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.roc_+3A_x">x</code></td>
<td>
<p>An object with S3 class <code>"roc"</code></p>
</td></tr>
<tr><td><code id="plot.roc_+3A_...">...</code></td>
<td>
<p>System reserved (No specific usage)</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+huge.roc">huge.roc</a></code>
</p>

<hr>
<h2 id='plot.select'>Plot function for S3 class &quot;select&quot;</h2><span id='topic+plot.select'></span>

<h3>Description</h3>

<p>Plot the optimal graph by model selection.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'select'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.select_+3A_x">x</code></td>
<td>
<p>An object with S3 class <code>"select"</code></p>
</td></tr>
<tr><td><code id="plot.select_+3A_...">...</code></td>
<td>
<p>System reserved (No specific usage)</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+huge.select">huge.select</a></code>
</p>

<hr>
<h2 id='plot.sim'>Plot function for S3 class &quot;sim&quot;</h2><span id='topic+plot.sim'></span>

<h3>Description</h3>

<p>Visualize the covariance matrix, the empirical covariance matrix, the adjacency matrix and the graph pattern of the true graph structure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sim'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.sim_+3A_x">x</code></td>
<td>
<p>An object with S3 class <code>"sim"</code></p>
</td></tr>
<tr><td><code id="plot.sim_+3A_...">...</code></td>
<td>
<p>System reserved (No specific usage)</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+huge.generator">huge.generator</a></code> and <code><a href="#topic+huge">huge</a></code>
</p>

<hr>
<h2 id='print.huge'>Print function for S3 class &quot;huge&quot;</h2><span id='topic+print.huge'></span>

<h3>Description</h3>

<p>Print the information about the model usage, the graph path length, graph dimension, sparsity level.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'huge'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.huge_+3A_x">x</code></td>
<td>
<p>An object with S3 class <code>"huge"</code>.</p>
</td></tr>
<tr><td><code id="print.huge_+3A_...">...</code></td>
<td>
<p>System reserved (No specific usage)</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+huge">huge</a></code>
</p>

<hr>
<h2 id='print.roc'>Print function for S3 class &quot;roc&quot;</h2><span id='topic+print.roc'></span>

<h3>Description</h3>

<p>Print the information about true positive rates, false positive rates, the area under curve and maximum F1 score.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'roc'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.roc_+3A_x">x</code></td>
<td>
<p>An object with S3 class <code>"roc"</code>.</p>
</td></tr>
<tr><td><code id="print.roc_+3A_...">...</code></td>
<td>
<p>System reserved (No specific usage)</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+huge.roc">huge.roc</a></code>
</p>

<hr>
<h2 id='print.select'>Print function for S3 class &quot;select&quot;</h2><span id='topic+print.select'></span>

<h3>Description</h3>

<p>Print the information about the model usage, graph dimension, model selection criterion, sparsity level of the optimal graph.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'select'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.select_+3A_x">x</code></td>
<td>
<p>An object with S3 class <code>"select"</code>.</p>
</td></tr>
<tr><td><code id="print.select_+3A_...">...</code></td>
<td>
<p>System reserved (No specific usage)</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+huge.select">huge.select</a></code>
</p>

<hr>
<h2 id='print.sim'>Print function for S3 class &quot;sim&quot;</h2><span id='topic+print.sim'></span>

<h3>Description</h3>

<p>Print the information about the sample size, the dimension, the pattern and sparsity of the true graph structure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sim'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.sim_+3A_x">x</code></td>
<td>
<p>An object with S3 class <code>"sim"</code>.</p>
</td></tr>
<tr><td><code id="print.sim_+3A_...">...</code></td>
<td>
<p>System reserved (No specific usage)</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+huge.generator">huge.generator</a></code>
</p>

<hr>
<h2 id='stockdata'>Stock price of S&amp;P 500 companies from 2003 to 2008</h2><span id='topic+stockdata'></span>

<h3>Description</h3>

<p>This data set consists of stock price and company information.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(stockdata)
</code></pre>


<h3>Format</h3>

<p>The format is a list containing contains two matrices.
1. data - 1258x452, represents the 452 stocks' close prices for 1258 trading days.
2. info - 452x3:
The 1st column: the query symbol for each company.
The 2nd column: the category for each company.
The 3rd column: the full name of each company.
</p>


<h3>Details</h3>

<p>This data set can be used to perform high-dimensional graph estimation to analyze the relationships between S&amp;P 500 companies.
</p>


<h3>Source</h3>

<p>It was publicly available at finance.yahoo, which is now out of date
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(stockdata)
image(stockdata$data)
stockdata$info
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
