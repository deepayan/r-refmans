<!DOCTYPE html><html lang="en"><head><title>Help for package DEXiR</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {DEXiR}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#DEXiR-package'><p>DEXiR: A package for using DEXi models in R</p></a></li>
<li><a href='#alt_values'><p>alt_values</p></a></li>
<li><a href='#and_function'><p>and_function</p></a></li>
<li><a href='#att_names'><p>att_names</p></a></li>
<li><a href='#attribute_effect'><p>attribute_effect</p></a></li>
<li><a href='#bounded_scale_value'><p>bounded_scale_value</p></a></li>
<li><a href='#compare_alternatives'><p>compare_alternatives</p></a></li>
<li><a href='#compare_two_alternatives'><p>compare_two_alternatives</p></a></li>
<li><a href='#compare_values'><p>compare_values</p></a></li>
<li><a href='#compare_values_by_preference'><p>compare_values_by_preference</p></a></li>
<li><a href='#compare_values_on_scale'><p>compare_values_on_scale</p></a></li>
<li><a href='#convert_alternatives'><p>convert_alternatives</p></a></li>
<li><a href='#convert_data_continuous'><p>convert_data_continuous</p></a></li>
<li><a href='#convert_data_discrete'><p>convert_data_discrete</p></a></li>
<li><a href='#default_quality'><p>default_quality</p></a></li>
<li><a href='#dexi_bool'><p>dexi_bool</p></a></li>
<li><a href='#dexi_index'><p>dexi_index</p></a></li>
<li><a href='#dexi_option_value'><p>dexi_option_value</p></a></li>
<li><a href='#dexi_table'><p>dexi_table</p></a></li>
<li><a href='#dexi_value'><p>dexi_value</p></a></li>
<li><a href='#dexi_vector'><p>dexi_vector</p></a></li>
<li><a href='#DexiAttribute-class'><p>DexiAttribute</p></a></li>
<li><a href='#DexiContinuousScale-class'><p>DexiContinuousScale</p></a></li>
<li><a href='#DexiDiscreteScale-class'><p>DexiDiscreteScale</p></a></li>
<li><a href='#DexiDiscretizeFunction-class'><p>DexiDiscretizeFunction</p></a></li>
<li><a href='#DexiFunction-class'><p>DexiFunction</p></a></li>
<li><a href='#DexiModel-class'><p>DexiModel</p></a></li>
<li><a href='#DexiScale-class'><p>DexiScale</p></a></li>
<li><a href='#DexiTabularFunction-class'><p>DexiTabularFunction</p></a></li>
<li><a href='#distr_to_set'><p>distr_to_set</p></a></li>
<li><a href='#distribution'><p>distribution</p></a></li>
<li><a href='#equal_scales'><p>equal_scales</p></a></li>
<li><a href='#evaluate'><p>evaluate</p></a></li>
<li><a href='#evaluate_attribute'><p>evaluate_attribute</p></a></li>
<li><a href='#evaluate_attributes'><p>evaluate_attributes</p></a></li>
<li><a href='#evaluation_order'><p>evaluation_order</p></a></li>
<li><a href='#evaluation_parameters'><p>evaluation_parameters</p></a></li>
<li><a href='#expand_value_to_points'><p>expand_value_to_points</p></a></li>
<li><a href='#export_alternatives'><p>export_alternatives</p></a></li>
<li><a href='#export_dexi_value'><p>export_dexi_value</p></a></li>
<li><a href='#flat_text'><p>flat_text</p></a></li>
<li><a href='#ggplot_parallel'><p>ggplot_parallel</p></a></li>
<li><a href='#has_bad'><p>has_bad</p></a></li>
<li><a href='#has_good'><p>has_good</p></a></li>
<li><a href='#has_none'><p>has_none</p></a></li>
<li><a href='#has_quality'><p>has_quality</p></a></li>
<li><a href='#is_distribution'><p>is_distribution</p></a></li>
<li><a href='#is_in_range'><p>is_in_range</p></a></li>
<li><a href='#lin_map'><p>lin_map</p></a></li>
<li><a href='#make_args'><p>make_args</p></a></li>
<li><a href='#norm_max'><p>norm_max</p></a></li>
<li><a href='#norm_none'><p>norm_none</p></a></li>
<li><a href='#norm_sum'><p>norm_sum</p></a></li>
<li><a href='#normalize_function'><p>normalize_function</p></a></li>
<li><a href='#or_function'><p>or_function</p></a></li>
<li><a href='#plotalt_parallel'><p>plotalt_parallel</p></a></li>
<li><a href='#plotalt_radar'><p>plotalt_radar</p></a></li>
<li><a href='#plotalt1'><p>plotalt1</p></a></li>
<li><a href='#plotalt2'><p>plotalt2</p></a></li>
<li><a href='#plus_minus'><p>plus_minus</p></a></li>
<li><a href='#plus_minus_setup'><p>plus_minus_setup</p></a></li>
<li><a href='#print_selective_explanation'><p>print_selective_explanation</p></a></li>
<li><a href='#read_dexi'><p>read_dexi</p></a></li>
<li><a href='#reverse_value'><p>reverse_value</p></a></li>
<li><a href='#rule_value'><p>rule_value</p></a></li>
<li><a href='#rule_values'><p>rule_values</p></a></li>
<li><a href='#scale_alternatives'><p>scale_alternatives</p></a></li>
<li><a href='#scale_of'><p>scale_of</p></a></li>
<li><a href='#scale_value'><p>scale_value</p></a></li>
<li><a href='#scale_values'><p>scale_values</p></a></li>
<li><a href='#select_quality'><p>select_quality</p></a></li>
<li><a href='#selective_explanation'><p>selective_explanation</p></a></li>
<li><a href='#set_alternative'><p>set_alternative</p></a></li>
<li><a href='#set_to_distr'><p>set_to_distr</p></a></li>
<li><a href='#transparent_colors'><p>transparent_colors</p></a></li>
<li><a href='#unique_names'><p>unique_names</p></a></li>
<li><a href='#value_qualities'><p>value_qualities</p></a></li>
<li><a href='#value_text'><p>value_text</p></a></li>
<li><a href='#value_to_set'><p>value_to_set</p></a></li>
<li><a href='#values_to_str'><p>values_to_str</p></a></li>
<li><a href='#write_alternatives'><p>write_alternatives</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>'DEXi' Library</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.2</td>
</tr>
<tr>
<td>Description:</td>
<td>A software package for using 'DEXi' models. 'DEXi' models are
  hierarchical qualitative multi-criteria decision models developed according to the method
  DEX (Decision EXpert, <a href="https://dex.ijs.si/documentation/DEX_Method/DEX_Method.html">https://dex.ijs.si/documentation/DEX_Method/DEX_Method.html</a>),
  using the program 'DEXi' (<a href="https://kt.ijs.si/MarkoBohanec/dexi.html">https://kt.ijs.si/MarkoBohanec/dexi.html</a>) or
  'DEXiWin' (<a href="https://dex.ijs.si/dexisuite/dexiwin.html">https://dex.ijs.si/dexisuite/dexiwin.html</a>).
  A typical workflow with 'DEXiR' consists of:
  (1) reading a '.dxi' file, previously made using the 'DEXi' software (function read_dexi()),
  (2) making a data frame containing input values of one or more decision alternatives,
  (3) evaluating those alternatives (function evaluate()),
  (4) analyzing alternatives (selective_explanation(), plus_minus(), compare_alternatives()),
  (5) drawing charts.
  'DEXiR' is restricted to using models produced externally by the 'DEXi' software and does not
  provide functionality for creating and/or editing 'DEXi' models directly in 'R'.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 3.0.0), grDevices, ggplot2, GGally, fmsb</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Imports:</td>
<td>utils, xml2, methods, stringr, graphics</td>
</tr>
<tr>
<td>Collate:</td>
<td>'DEXiR.R' 'DexiClasses.R' 'DexiAlternatives.R' 'DexiUtils.R'
'DexiAnalysis.R' 'DexiFunctions.R' 'DexiScales.R'
'DexiAttributes.R' 'DexiCharts.R' 'DexiData.R' 'DexiEvaluate.R'
'DexiModels.R' 'DexiValues.R'</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-09-16 09:52:20 UTC; Mare</td>
</tr>
<tr>
<td>Author:</td>
<td>Marko Bohanec <a href="https://orcid.org/0000-0003-4317-2833"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Marko Bohanec &lt;marko.bohanec@ijs.si&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-09-17 16:30:09 UTC</td>
</tr>
</table>
<hr>
<h2 id='DEXiR-package'>DEXiR: A package for using DEXi models in R</h2><span id='topic+DEXiR'></span><span id='topic+DEXiR-package'></span>

<h3>Description</h3>

<p>DEXiR is a software package for using DEXi models in R. The main function
is evaluating decision alternatives using a model previously developed by DEXi software.
</p>


<h3>DEXi Models</h3>

<p>DEXi models are hierarchical qualitative rule-based multi-criteria decision models developed using
the method DEX (Decision EXpert, <a href="https://en.wikipedia.org/wiki/Decision_EXpert">https://en.wikipedia.org/wiki/Decision_EXpert</a>),
using the program DEXi (<a href="https://kt.ijs.si/MarkoBohanec/dexi.html">https://kt.ijs.si/MarkoBohanec/dexi.html</a>)
or DEXiWin (<a href="https://dex.ijs.si/dexisuite/dexiwin.html">https://dex.ijs.si/dexisuite/dexiwin.html</a>).
</p>
<p>In general, a DEXi model consists of a hierarchy of qualitative (symbolic linguistic, discrete)
variables, called <em>attributes</em>. Each attribute represents some observable property
(such as Price or Performance) of decision alternatives under study. An attribute can take
values from a set of words (such as &quot;low; medium; high&quot; or &quot;unacc; acc; good; exc&quot;), which is usually
small (up to five elements) and preferentially ordered from &quot;bad&quot; to &quot;good&quot; values.
</p>
<p>The <em>hierarchy</em> of attributes represents a decomposition of a decision problem into
sub-problems, so that higher-level attributes depend on the lower-level ones. Consequently,
the terminal nodes represent inputs, and non-terminal attributes represent the outputs of the model.
Among these, the most important are one or more root attributes, which represent the final
evaluation(s) of the alternatives.
</p>
<p>The <em>evaluation</em> of decision alternatives (i.e., hierarchical aggregation of values
from model inputs to outputs) is governed by <em>decision rules</em>, defined for each
non-terminal attribute by the creator of the model (usually referred to as a &quot;decision maker&quot;).
</p>


<h3>Terminological remarks</h3>


<dl>
<dt>DEX</dt><dd><p>DEX (Decision EXpert) refers to a general multi-attribute decision modeling method,
characterized by using qualitative attribute hierarchies and decision tables.
For further information, see (Trdin, Bohanec, 2018) and (Bohanec, 2022).</p>
</dd>
<dt>DEXi</dt><dd><p>DEXi (&quot;DEX for instruction&quot;) refers to DEXi software.
DEXi implements a subset of DEX, for instance, it is restricted to set-based evaluation methods.
DEXi supports the creation and editing of <em>DEXi models</em>, which are saved on <code>.dxi</code> files and
subsequently read by DEXiR for processing in R. For further information on DEXi, see
<a href="https://kt.ijs.si/MarkoBohanec/dexi.html">https://kt.ijs.si/MarkoBohanec/dexi.html</a>.</p>
</dd>
<dt>DEXiWin</dt><dd><p>A new backward-compatible implementation of DEXi, aimed at gradually
replacing it in the future. For further information on DEXiWin and
related software, see <a href="https://dex.ijs.si/dexisuite/dexisuite.html">https://dex.ijs.si/dexisuite/dexisuite.html</a>.</p>
</dd>
<dt>DEXiR</dt><dd><p>DEXiR is this R package. It is capable of reading and processing DEXi models with
some extensions towards the full DEX (for example, using value distributions).</p>
</dd>
</dl>



<h3>DEXiR Functionality</h3>

<p>Models developed using the DEXi software are stored in XML-formatted <code>.dxi</code> files. In
order to use DEXi models in R, DEXiR supports the following tasks:
</p>

<ol>
<li><p> Reading DEXi models from <code>.dxi</code> files into the R environment, using <code><a href="#topic+read_dexi">read_dexi</a></code>.
</p>
</li>
<li><p> Making data frames containing data (both input and output) about considered decision alternatives,
using <code><a href="#topic+set_alternative">set_alternative</a></code>.
</p>
</li>
<li><p> Evaluating decision alternatives, using <code><a href="#topic+evaluate">evaluate</a></code>.
</p>
</li>
<li><p> Analyzing alternatives (<code><a href="#topic+selective_explanation">selective_explanation</a></code>, <code><a href="#topic+plus_minus">plus_minus</a></code>,
<code><a href="#topic+compare_alternatives">compare_alternatives</a></code>).
</p>
</li>
<li><p> Drawing charts.
</p>
</li></ol>

<p>By default, evaluation is based on sets, which is a standard evaluation procedure of DEXi. DEXiR
extends this by supporting:
</p>

<ul>
<li><p> evaluations using probabilistic and fuzzy value distributions (see <code><a href="#topic+evaluate">evaluate</a></code>);
</p>
</li>
<li><p> &quot;pruned&quot; evaluation, when the evaluation starts from selected non-terminal  attribute(s) upwards.
</p>
</li></ul>



<h3>Limitations</h3>

<p>DEXiR has been designed to facilitate <em>using</em> DEXi models in R
produced externally by the DEXi software.
DEXiR does not provide any explicit means for creating and/or editing DEXi models in R.
</p>


<h3>A typical DEXiR workflow</h3>

<p>This example uses a simple DEXi model for evaluating cars, which is distributed
together with the DEXi software (including DEXiR) and is used throughout DEX literature
to illustrate the methodological approach (<a href="https://en.wikipedia.org/wiki/Decision_EXpert">https://en.wikipedia.org/wiki/Decision_EXpert</a>).
</p>
<p>First, this model is loaded into R and printed as follows:
</p>
<pre>
&gt; Car &lt;- read_dexi("data/Car.dxi")
&gt; Car
DEXi Model:  CAR_MODEL
Description: Car demo
index id          structure          scale                     funct
  [1] CAR_MODEL   CAR_MODEL
  [2] CAR         +- CAR             unacc; acc; good; exc (+) 12 3x4
  [3] PRICE         |- PRICE         high; medium; low (+)     9 3x3
  [4] BUY.PRICE     | |- BUY.PRICE   high; medium; low (+)
  [5] MAINT.PRICE   | +- MAINT.PRICE high; medium; low (+)
  [6] TECH.CHAR.    +- TECH.CHAR.    bad; acc; good; exc (+)   9 3x3
  [7] COMFORT         |- COMFORT     small; medium; high (+)   36 3x4x3
  [8] X.PERS          | |- #PERS     to_2; 3-4; more (+)
  [9] X.DOORS         | |- #DOORS    2; 3; 4; more (+)
 [10] LUGGAGE         | +- LUGGAGE   small; medium; big (+)
 [11] SAFETY          +- SAFETY      small; medium; high (+)
</pre>
<p>Rows in the table correspond to individual attributes. The columns represent the following:
</p>

<dl>
<dt><code>index</code></dt><dd><p>Indices of attributes.</p>
</dd>
<dt><code>id</code></dt><dd><p>Unique attribute names, generated by DEXiR from original DEXi names, in order
to provide syntactically correct variable names in R and allow unambiguous referencing of attributes.</p>
</dd>
<dt><code>structure</code></dt><dd><p>The hierarchical structure of attributes, named as in the original DEXi model.</p>
</dd>
<dt><code>scale</code></dt><dd><p>Value scales associated with each attribute. The symbol &quot;(+)&quot; indicates that the corresponding scale
is ordered preferentially in increasing order.</p>
</dd>
<dt><code>funct</code></dt><dd><p>Information about the size (number of rules) and dimensions of the corresponding decision tables.</p>
</dd>
</dl>

<p>Looking at the structure of attributes, please notice that the attribute at index <code style="white-space: pre;">&#8288;[1]&#8288;</code> is virtual and
does not actually appear in the original DEXi model. It is necessary in DEXiR to facilitate models that
have multiple root attributes. The &quot;real&quot; root of the Car model is actually <code style="white-space: pre;">&#8288;[2]&#8288;</code> CAR. It depends on
two lower-level attributes, PRICE and TECH.CHAR. These are decomposed further. Overall, the model consists of
</p>

<ul>
<li><p> six input (<em>basic</em>) attributes: BUY.PRICE, MAINT.PRICE, X.PERS, X.DOORS, LUGGAGE and SAFETY, and
</p>
</li>
<li><p> four output (<em>aggregate</em>) attributes: CAR, PRICE, TECH.CHAR. and COMFORT.
</p>
</li></ul>

<p>Among the latter, CAR is the most important and represents the overall evaluation of cars.
</p>
<p>The next step usually consists of defining a data frame representing decision alternatives
(i.e., cars in this case).
The Car model already comes with a data table about two cars:
</p>
<pre>
&gt; Car$alternatives
  name CAR PRICE BUY.PRICE MAINT.PRICE TECH.CHAR. COMFORT X.PERS X.DOORS LUGGAGE SAFETY
1 Car1   4     3         2           3          4       3      3       3       3      3
2 Car2   3     2         2           2          3       3      3       3       3      2
</pre>
<p>In this data frame, attribute values are represented by ordinal numbers w.r.t. the corresponding scales.
A more readable output can be made using <code>DexiModel$as_character</code>:
</p>
<pre>
&gt; Car$as_character(Car$alternatives)
  name  CAR  PRICE BUY.PRICE MAINT.PRICE TECH.CHAR. COMFORT X.PERS X.DOORS LUGGAGE SAFETY
1 Car1  exc    low    medium         low        exc    high   more       4     big   high
2 Car2 good medium    medium      medium       good    high   more       4     big medium
</pre>
<p>This data can be edited using common R data.frame functions. Also, DEXiR provides the method
<code>DexiModel$alternative</code> for defining a single decision alternative, for example:
</p>
<pre>
&gt; alt &lt;- Car$alternative("MyCar1",
         BUY.PRICE="low", MAINT.PRICE=2, X.PERS="more", X.DOORS="4",
         LUGGAGE=2, SAFETY="medium")
&gt; alt
    name CAR PRICE BUY.PRICE MAINT.PRICE TECH.CHAR. COMFORT X.PERS X.DOORS LUGGAGE SAFETY
1 MyCar1  NA    NA         3           2         NA      NA      3       3       2      2
</pre>
<p>Finally, such data tables can be evaluated using <code>DexiModel$evaluate</code>:
</p>
<pre>
&gt; eval &lt;- Car$evaluate(alt)
&gt; eval
    name CAR PRICE BUY.PRICE MAINT.PRICE TECH.CHAR. COMFORT X.PERS X.DOORS LUGGAGE SAFETY
1 MyCar1   4     3         3           2          3       3      3       3       2      2
&gt; Car$as_character(eval)
    name CAR PRICE BUY.PRICE MAINT.PRICE TECH.CHAR. COMFORT X.PERS X.DOORS LUGGAGE SAFETY
1 MyCar1 exc   low       low      medium       good    high   more       4  medium medium
</pre>


<h3>Analysis of alternatives</h3>

<p>Once defined and evaluated, alternatives can be analysed further.
DEXiR provides three analysis methods:
</p>

<dl>
<dt><code><a href="#topic+selective_explanation">selective_explanation</a></code></dt><dd><p>Exposing particular weak and strong points of alternatives.</p>
</dd>
<dt><code><a href="#topic+plus_minus">plus_minus</a></code> analysis</dt><dd><p>Exploring effects of changing individual attributes to evaluation results.</p>
</dd>
<dt><code><a href="#topic+compare_alternatives">compare_alternatives</a></code></dt><dd><p>Comparison of an alternative with other alternatives.</p>
</dd>
</dl>

<p>Examples:
</p>
<pre>
&gt; Car$selective_explanation(1)

Selective explanation of Car1

Weak points:
None

Strong points:
 id          structure         Car1
 CAR.1       +-CAR             4
 PRICE         |-PRICE         3
 MAINT.PRICE   | +-MAINT.PRICE 3
 TECH.CHAR.    +-TECH.CHAR.    4
 COMFORT         |-COMFORT     3
 X.PERS          | |-#PERS     3
 LUGGAGE         | +-LUGGAGE   3
 SAFETY          +-SAFETY      3

&gt; Car$plus_minus(1, as_character = TRUE)
 id          structure         -2    -1    CAR.1=exc 1
 BUY.PRICE     | |-BUY.PRICE   [     unacc medium    exc
 MAINT.PRICE   | +-MAINT.PRICE unacc exc   low       ]
 X.PERS          | |-#PERS     unacc exc   more      ]
 X.DOORS         | |-#DOORS    unacc exc   4         exc
 LUGGAGE         | +-LUGGAGE   unacc exc   big       ]
 SAFETY          +-SAFETY      unacc exc   high      ]

&gt; Car$compare_alternatives(1, as_character = TRUE)
 id          structure         Car1   Car2
 CAR         CAR               NULL   NULL
 CAR.1       +-CAR             exc    &gt; good
 PRICE         |-PRICE         low    &gt; medium
 BUY.PRICE     | |-BUY.PRICE   medium
 MAINT.PRICE   | +-MAINT.PRICE low    &gt; medium
 TECH.CHAR.    +-TECH.CHAR.    exc    &gt; good
 COMFORT         |-COMFORT     high
 X.PERS          | |-#PERS     more
 X.DOORS         | |-#DOORS    4
 LUGGAGE         | +-LUGGAGE   big
 SAFETY          +-SAFETY      high   &gt; medium
</pre>


<h3>Charts</h3>

<p>Evaluation results can be drawn on charts. DEXiR provides four charts that display multiple alternatives:
</p>

<dl>
<dt><code><a href="#topic+plotalt1">plotalt1</a></code></dt><dd><p>with respect to a single attribute, drawing a scatterplot &quot;alternatives by attribute-values&quot;</p>
</dd>
<dt><code><a href="#topic+plotalt2">plotalt2</a></code></dt><dd><p>with respect to two attributes, drawing a scatterplot &quot;attribute1 by attribute2&quot;</p>
</dd>
<dt><code><a href="#topic+plotalt_parallel">plotalt_parallel</a></code></dt><dd><p>with respect to multiple attributes, drawing evaluation results  using parallel axes</p>
</dd>
<dt><code><a href="#topic+plotalt_radar">plotalt_radar</a></code></dt><dd><p>with respect to multiple attributes, drawing evaluation results on a radar chart</p>
</dd>
</dl>

<p>The latter two plots scale evaluation results to the <code style="white-space: pre;">&#8288;[0:1]&#8288;</code> interval.
Evaluation values represented by sets or distributions are plotted either as intervals
(<code>aggregate = "minmax"</code>) or are aggregated to a single value
(<code>aggregate = "min"</code>, <code>"max"</code> or <code>"mean"</code>).
</p>
<p>Examples:
</p>
<pre>
Plot all Car alternatives with respect to Car$first() ("CAR.1"))
&gt; plotalt1(Car)

Plot evaluation results of all Car alternatives with respect to attribute "PRICE"
&gt; plotalt1(Car, "PRICE")

Draw "TECH.CHAR." by "PRICE" scatterplot of all Car alternatives
&gt; plotalt2(Car, "TECH.CHAR.", "PRICE")

Draw a "TECH.CHAR." by "PRICE" scatterplot of the second Car alternative
&gt; plotalt2(Car, "TECH.CHAR.", "PRICE", 2)

Draw all Car alternatives on parallel axes
&gt; plotalt_parallel(Car)

Draw all Car alternatives on a radar chart
&gt; plotalt_radar(Car)
</pre>


<h3>On the use of values in DEXi models</h3>

<p><em>DEXi values</em> are used throughout DEXi models.
They provide input values and carry results of evaluations in data frames that contain data
about decision alternatives.
Values are also used in definitions of <a href="#topic+DexiFunction">DexiFunction</a>s and are returned by
<code>DexiFunction$evaluate</code> when evaluating some function for a given set of arguments.
</p>
<p>In DEXi, values are always bound to the context provided by a <a href="#topic+DexiScale">DexiScale</a>. Since each
fully defined <a href="#topic+DexiAttribute">DexiAttribute</a> is associated with some scale, we can generalize the
scale context to attributes and speak about &quot;assigning some value to an attribute&quot;.
</p>
<p>The scale type determines the type and possible range of values that can be assigned to an attribute.
DEXiR implements two scale types: <a href="#topic+DexiContinuousScale">DexiContinuousScale</a> and <a href="#topic+DexiDiscreteScale">DexiDiscreteScale</a>.
Regarding the values, the former is really simple: it allows assigning any single real number to the
corresponding attribute. In other words, continuous DEXi values are of type numeric(1).
</p>
<p><a href="#topic+DexiDiscreteScale">DexiDiscreteScale</a> is the main scale type used throughout DEXi models and supports
a wider range of value types.
</p>
<p>The &quot;normal&quot; and most common discrete value is a &quot;single qualitative value&quot;.
For illustration, let us use the scale composed of four qualitative values:
<code>"unacc"</code>, <code>"acc"</code>, <code>"good"</code>, <code>"exc"</code>. Then, &quot;a single qualitative value&quot; denotes
one of these words. Internally in DEXiR, such values are not represented by character strings, but rather
by ordinal numbers, so that ord(<code>"unacc"</code>) = 1, ord(<code>"acc"</code>) = 2, etc. Some DEXiR functions
can convert between the two representations, see <code>DexiModel$as_character</code>
and <code><a href="#topic+set_alternative">set_alternative()</a></code>.
</p>
<p>In order to cope with missing, incomplete or uncertain data, DEX extends the concept of single values
to value <em>sets</em> and <em>distributions</em>. In DEXiR, wherever it is possible to use a single qualitative
value, it is also possible to use a value set or distribution. This is the main reason that all DEXiR
data structures related to DEXi values are represented by lists rather than plain vectors.
This includes all data frames that represent decision alternatives and all functions that return
qualitative values. Also note that while sets are fully implemented in the current DEXi software,
distributions are not and are thus considered extensions towards the full DEX method.
</p>
<p>A <em>DEXi value set</em> is a subset of the full range of a <a href="#topic+DexiDiscreteScale">DexiDiscreteScale</a> values.
For the above example, the full range of ordinal values is <code>1:4</code>, and some possible subsets are
<code>c(2)</code>, <code>c(2, 4)</code>, <code>c(1, 2, 3)</code> and <code>1:4</code>. Internally, sets are represented by
plain integer vectors or plain numeric vectors containing integer numbers.
</p>
<p>A <em>DEXi value distribution</em> associates each <a href="#topic+DexiDiscreteScale">DexiDiscreteScale</a> value with some
number, generally denoted <code class="reqn">p</code> and normally expected to be in the [0,1] interval.
Depending on the context and used evaluation method (see <code><a href="#topic+evaluate">evaluate()</a></code>), <code class="reqn">p</code> can be
interpreted as <em>probability</em> or <em>fuzzy set membership</em>. In DEXiR, value distributions are
represented using the S3 class &quot;distribution&quot; (see <a href="#topic+distribution">distribution</a>).
For example, <code>distribution(0.5, 0, 0.2, 0.3)</code> represents a value distribution over the
above scale example, assigning
<code class="reqn">p = 0.5</code> to <code>"unacc"</code>,
<code class="reqn">p = 0.0</code> to <code>"acc"</code>,
<code class="reqn">p = 0.2</code> to <code>"good"</code> and
<code class="reqn">p = 0.3</code> to <code>"exc"</code>.
</p>
<p>Remarks:
</p>

<ul>
<li><p> The value <code>distribution(0.5, 0, 0.2, 0.3)</code> is internally represented as <code>c(0.5, 0, 0.2, 0.3)</code>,
whose <code>class()</code> is <code>"distribution"</code>.
</p>
</li>
<li><p> Using a special class for distributions is necessary to distinguish them from sets. For instance, the
notation <code>c(1, 1)</code> is ambiguous and would be interpreted differently as a set or distribution.
</p>
</li>
<li><p> Some DEXiR functions (see <code>DexiModel$as_character</code> and <code><a href="#topic+set_alternative">set_alternative()</a></code>)
support the formulation of distributions in the form of named vectors or lists, for instance
<code>list(unacc=0.5, good=0.2, exc=0.3)</code>.
</p>
</li>
<li><p> In data frames that contain data about decision alternatives, numeric vectors that contain
non-integer values are implicitly interpreted as distributions rather than sets.
</p>
</li></ul>



<h3>Examples of using value sets and distributions</h3>

<p>First, let us consider a car for which we have no evidence about its possible maintenance costs.
For the value of <code>MAINT.PRICE</code>, we may use <code>"*"</code>, which denotes the full range of
the corresponding attribute values (equivalent to <code>1:3</code> or <code>c(1, 2, 3)</code> in this case).
Notice how the evaluation method considers all the possible values of <code>MAINT.PRICE</code>
and propagates them upwards.
</p>
<pre>
alt &lt;- Car$alternative("MyCar1a",
       BUY.PRICE="low", MAINT.PRICE="*", X.PERS="more", X.DOORS="4", LUGGAGE=2, SAFETY=2)
Car$evaluate(alt)
     name  CAR PRICE BUY.PRICE MAINT.PRICE TECH.CHAR. COMFORT X.PERS X.DOORS LUGGAGE SAFETY
1 MyCar1a 1, 4  1, 3         3     1, 2, 3          3       3      3       3       2      2
</pre>
<p>The above evaluation result is not really useful, as the car turns out to be <code>c(1, 4)</code>, that is,
either <code>"unacc"</code> or <code>"exc"</code>, depending on maintenance costs.
Thus, let us try using value distribution for MAINT.PRICE, telling DEXiR that low maintenance costs
are somewhat unexpected (<code class="reqn">p = 0.1</code>) and that medium costs (<code class="reqn">p = 0.6</code>) are more likely than
high (<code class="reqn">p = 0.3</code>). Using the evaluation method <code>"prob"</code> (where <code class="reqn">p</code>'s are interpreted
as probabilities) gives the following results:
</p>
<pre>
alt &lt;- Car$alternative("MyCar1b",
       BUY.PRICE="low", MAINT.PRICE=distribution(0.1, 0.6, 0.3),
       X.PERS="more", X.DOORS="4", LUGGAGE=2, SAFETY=2)
Car$evaluate(alt, method = "prob")
     name                CAR         PRICE BUY.PRICE   MAINT.PRICE TECH.CHAR. COMFORT X.PERS X.DOORS LUGGAGE SAFETY
1 MyCar1b 0.1, 0.0, 0.0, 0.9 0.1, 0.0, 0.9         3 0.1, 0.6, 0.3 0, 0, 1, 0 0, 0, 1      3       3       2      2
</pre>
<p>In this case, the final evaluation of <code>CAR</code> is <code>distribution(0.1, 0.0, 0.0, 0.9)</code>, that is,
<code>list(unacc=0.1, exc=0.9)</code>. It is much more likely that <code>MyCar1b</code> is <code>"exc"</code> than <code>"unacc"</code>.
</p>


<h3>References</h3>


<ul>
<li> <p><em>Decision EXpert</em>. Wikipedia, <a href="https://en.wikipedia.org/wiki/Decision_EXpert">https://en.wikipedia.org/wiki/Decision_EXpert</a>.
</p>
</li>
<li><p> Trdin, N., Bohanec, M.: Extending the multi-criteria decision making method DEX
with numeric attributes, value distributions and relational models.
<em>Central European Journal of Operations Research</em>, 1-24, 2018
<a href="https://doi.org/10.1007/s10100-017-0468-9">doi:10.1007/s10100-017-0468-9</a>.
</p>
</li>
<li><p> Bohanec, M.: DEX (Decision EXpert): A Qualitative Hierarchical Multi-criteria Method.
In: Kulkarni, A.J. (ed.):
<em>Multiple Criteria Decision Making: Techniques, Analysis and Applications</em>.
Singapore: Springer, 39-78, 2022
<a href="https://doi.org/10.1007/978-981-16-7414-3_3">doi:10.1007/978-981-16-7414-3_3</a>.
</p>
</li>
<li> <p><em>DEXi: A Program for Multi-Attribute Decision Making</em>.
<a href="https://kt.ijs.si/MarkoBohanec/dexi.html">https://kt.ijs.si/MarkoBohanec/dexi.html</a>.
</p>
</li>
<li><p> Bohanec, M.: <em>DEXi: Program for Multi-Attribute Decision Making, User's Manual, Version 5.04</em>.
IJS Report DP-13100, Jožef Stefan Institute, Ljubljana, 2020.
<a href="https://kt.ijs.si/MarkoBohanec/pub/DEXiManual504.pdf">https://kt.ijs.si/MarkoBohanec/pub/DEXiManual504.pdf</a>.
</p>
</li>
<li><p> Bohanec, M.: <em> DEXiWin: DEX Decision Modeling Software, User’s Manual, Version 1.2</em>.
IJS Report DP-14741, Jožef Stefan Institute, Ljubljana, 2024.
<a href="https://kt.ijs.si/MarkoBohanec/pub/2024_DP14747_DEXiWin.pdf">https://kt.ijs.si/MarkoBohanec/pub/2024_DP14747_DEXiWin.pdf</a>.
</p>
</li>
<li> <p><em>DEX Software</em>. <a href="https://dex.ijs.si">https://dex.ijs.si</a>.
</p>
</li></ul>



<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Marko Bohanec <a href="mailto:marko.bohanec@ijs.si">marko.bohanec@ijs.si</a> (<a href="https://orcid.org/0000-0003-4317-2833">ORCID</a>)
</p>

<hr>
<h2 id='alt_values'>alt_values</h2><span id='topic+alt_values'></span>

<h3>Description</h3>

<p>Make a list of <code>alternative</code>'s values corresponding to <code>attributes</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>alt_values(alt, attributes, as_character = TRUE, round = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="alt_values_+3A_alt">alt</code></td>
<td>
<p><code>data.frame</code> representing a single alternative.</p>
</td></tr>
<tr><td><code id="alt_values_+3A_attributes">attributes</code></td>
<td>
<p>A vector of <a href="#topic+DexiAttribute">DexiAttribute</a> objects.</p>
</td></tr>
<tr><td><code id="alt_values_+3A_as_character">as_character</code></td>
<td>
<p><code style="white-space: pre;">&#8288;logical(1).&#8288;</code>. Determines whether to represent alternative values numerically
(&quot;internal representation&quot;) (<code>FALSE</code>) or as character strings (using <code><a href="#topic+value_text">value_text()</a></code>) (<code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="alt_values_+3A_round">round</code></td>
<td>
<p>A single integer. An optional argument to <code><a href="#topic+value_text">value_text()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>character(length(attributes))</code>. String representation of <code>alt</code>'s values.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+value_text">value_text()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load "Car.dxi"
CarDxi &lt;- system.file("extdata", "Car.dxi", package = "DEXiR")
Car &lt;- read_dexi(CarDxi)

unlist(alt_values(Car$alternatives[1,], Car$attributes, as_character = TRUE))
# c("NULL", "exc", "low", "medium", "low", "exc", "high", "more", "4", "big", "high")
</code></pre>

<hr>
<h2 id='and_function'>and_function</h2><span id='topic+and_function'></span>

<h3>Description</h3>

<p>Determine the function to be used in the conjunctive aggregation step of <code><a href="#topic+evaluate">evaluate()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>and_function(method = EnumEvalMethod, and = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="and_function_+3A_method">method</code></td>
<td>
<p>One of: <code>"set"</code> (default), <code>"prob"</code>, <code>"fuzzy"</code> or <code>"fuzzynorm"</code>.</p>
</td></tr>
<tr><td><code id="and_function_+3A_and">and</code></td>
<td>
<p>Some conjunctive aggregation function of the form <code style="white-space: pre;">&#8288;function(num_vector)&#8288;</code>, or <code>NULL</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the function <code>and</code> if not <code>NULL</code>.
Otherwise, it determines the result depending on <code>method</code>:
</p>

<dl>
<dt><code>"set"</code>:</dt><dd><p><code>function(x) 0</code></p>
</dd>
<dt><code>"prob"</code>:</dt><dd><p><code><a href="base.html#topic+prod">prod</a></code></p>
</dd>
<dt><code>"fuzzy"</code>:</dt><dd><p><code><a href="base.html#topic+min">min</a></code></p>
</dd>
<dt><code>"fuzzynorm"</code>:</dt><dd><p><code><a href="base.html#topic+min">min</a></code></p>
</dd>
</dl>

<p>Fails with an error if the result is not an R function.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+evaluate">evaluate</a></code>, <code><a href="#topic+or_function">or_function()</a></code>.
</p>

<hr>
<h2 id='att_names'>att_names</h2><span id='topic+att_names'></span>

<h3>Description</h3>

<p>Return names or IDs of <a href="#topic+DexiAttribute">DexiAttribute</a> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>att_names(atts, use_id = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="att_names_+3A_atts">atts</code></td>
<td>
<p>A vector of <a href="#topic+DexiAttribute">DexiAttribute</a>s.</p>
</td></tr>
<tr><td><code id="att_names_+3A_use_id">use_id</code></td>
<td>
<p>Determines whether to return attribute IDs or original DEXi names.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector of attribute IDs or names.
</p>

<hr>
<h2 id='attribute_effect'>attribute_effect</h2><span id='topic+attribute_effect'></span>

<h3>Description</h3>

<p>Given a single <code>alternative</code>, determine the effects of varying <code>attribute</code> on <code>target</code> attribute.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>attribute_effect(model, attribute, alternative, target = NULL, seq = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="attribute_effect_+3A_model">model</code></td>
<td>
<p>A <a href="#topic+DexiModel">DexiModel</a> object. Required.</p>
</td></tr>
<tr><td><code id="attribute_effect_+3A_attribute">attribute</code></td>
<td>
<p>A <a href="#topic+DexiAttribute">DexiAttribute</a> with assigned discrete or continuous scale.</p>
</td></tr>
<tr><td><code id="attribute_effect_+3A_alternative">alternative</code></td>
<td>
<p>A <code>data.frame</code> containing a single alternative.</p>
</td></tr>
<tr><td><code id="attribute_effect_+3A_target">target</code></td>
<td>
<p>Target <a href="#topic+DexiAttribute">DexiAttribute</a>. Defaults to <code>model$first()</code>.</p>
</td></tr>
<tr><td><code id="attribute_effect_+3A_seq">seq</code></td>
<td>
<p>A sequence of <code>attribute</code>'s numeric values for which to evaluate <code>alternative</code>.
For discrete scales: Must be a sequence of integers. Defaults to <code>attribute$scale$full_range()</code>.
For continuous scales: <code>seq</code> is required.</p>
</td></tr>
<tr><td><code id="attribute_effect_+3A_...">...</code></td>
<td>
<p>Optional parameters passed to <code><a href="#topic+evaluate_attribute">evaluate_attribute()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of <code>target</code> evaluation results, indexed by the values of <code>seq</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+evaluate_attribute">evaluate_attribute()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load "Car.dxi"
CarDxi &lt;- system.file("extdata", "Car.dxi", package = "DEXiR")
Car &lt;- read_dexi(CarDxi)

alt &lt;- Car$alternative("MyCar",
         BUY.PRICE="low", MAINT.PRICE=2, X.PERS="more", X.DOORS="4", LUGGAGE=2, SAFETY="medium")
# Determine the effect of changing "SAFETY" balues on "CAR.1"
attribute_effect(Car, "SAFETY", alt)
# Returns a list of "CAR.1" values corresponding to consecutive values of "SAFETY"
attribute_effect(Car, "LUGGAGE", alt, "TECH.CHAR.")
# Returns a list of "TECH.CHAR." values corresponding to consecutive values of "LUGGAGE"
</code></pre>

<hr>
<h2 id='bounded_scale_value'>bounded_scale_value</h2><span id='topic+bounded_scale_value'></span>

<h3>Description</h3>

<p><code>bounded_scale_value</code> is a wrapper around <code><a href="#topic+scale_value">scale_value()</a></code> that makes sure that
the resulting values lie within the bounds set up by the <code>scale</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bounded_scale_value(value, scale)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bounded_scale_value_+3A_value">value</code></td>
<td>
<p>Any DEXi value, including value sets and distributions.</p>
</td></tr>
<tr><td><code id="bounded_scale_value_+3A_scale">scale</code></td>
<td>
<p>A <a href="#topic+DexiScale">DexiScale</a> or derived object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For continuous scales, <code>value</code> is returned &quot;as is&quot;. For discrete scales, all elements
of <code>value</code> that lie outside of <code>scale$full_range()</code> are removed. If this results in
an empty value set or distribution, <code>NULL</code> is returned.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+scale_value">scale_value()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>scl &lt;- DexiDiscreteScale(values = c("low", "med", "high"))
bounded_scale_value(NA, scl)                               # NA
bounded_scale_value(1, scl)                                # 1
bounded_scale_value(4, scl)                                # NULL
bounded_scale_value(c(0, 1, 3,  4, 5), scl)                # c(1, 3)
bounded_scale_value(distribution(0.1, 0.2, 0.3, 0.4), scl) # distribution(0.1, 0.2, 0.3)

</code></pre>

<hr>
<h2 id='compare_alternatives'>compare_alternatives</h2><span id='topic+compare_alternatives'></span>

<h3>Description</h3>

<p>Compare Alternatives Analysis: Compare <code>alternative</code> with each of <code>alternatives</code>.
Display only values that differ and, optionally when <code>compare = TRUE</code>, include
preference-relational operators.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compare_alternatives(
  model,
  alternative,
  alternatives = NULL,
  root = NULL,
  compare = TRUE,
  deep = TRUE,
  print = TRUE,
  as_character = FALSE,
  round = NULL,
  id = NULL,
  evaluate = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="compare_alternatives_+3A_model">model</code></td>
<td>
<p>A <a href="#topic+DexiModel">DexiModel</a> object. Required.</p>
</td></tr>
<tr><td><code id="compare_alternatives_+3A_alternative">alternative</code></td>
<td>
<p>Either a <code>data.frame</code> representing a single alternative or
an integer index to <code>model$alternatives</code>.</p>
</td></tr>
<tr><td><code id="compare_alternatives_+3A_alternatives">alternatives</code></td>
<td>
<p>Either a <code>data.frame</code> representing one or more alternatives,
or an integer numeric vector representing indices to <code>model$alternatives</code>.
By default, <code>alternatives</code> are set to <code>model$alternatives</code>,
possibly excluding <code>alternative</code> when indexed.</p>
</td></tr>
<tr><td><code id="compare_alternatives_+3A_root">root</code></td>
<td>
<p>Optional <a href="#topic+DexiAttribute">DexiAttribute</a> object.
When specified, only attributes that affect <code>root</code> are included in the analysis.
Otherwise, all <code>model$attributes</code> are included.</p>
</td></tr>
<tr><td><code id="compare_alternatives_+3A_compare">compare</code></td>
<td>
<p><code>logical(1)</code>.
Whether or not preference relations <code style="white-space: pre;">&#8288;"&lt;", "&gt;", "&lt;=", "&gt;="&#8288;</code> are included in results.</p>
</td></tr>
<tr><td><code id="compare_alternatives_+3A_deep">deep</code></td>
<td>
<p><code>logical(1)</code>.
Whether of not &quot;deep&quot; comparison (see <code><a href="#topic+compare_two_alternatives">compare_two_alternatives()</a></code>) is carried out.</p>
</td></tr>
<tr><td><code id="compare_alternatives_+3A_print">print</code></td>
<td>
<p><code>logical(1)</code>. When <code>TRUE</code>, pretty print (left justify) the results.</p>
</td></tr>
<tr><td><code id="compare_alternatives_+3A_as_character">as_character</code></td>
<td>
<p><code>logical(1)</code>. Whether to represent alternative values
numerically (<code>FALSE</code>) or using text (<code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="compare_alternatives_+3A_round">round</code></td>
<td>
<p>An integer number, argument to <code><a href="#topic+value_text">value_text()</a></code>.</p>
</td></tr>
<tr><td><code id="compare_alternatives_+3A_id">id</code></td>
<td>
<p><code>character(1)</code>.
Determines the contents of the first or first two columns of the resulting <code>data.frame</code>:
</p>

<dl>
<dt><code>"id"</code></dt><dd><p>Attribute ID.</p>
</dd>
<dt><code>"structure"</code></dt><dd><p>Attribute <code style="white-space: pre;">&#8288;$structure() + $name&#8288;</code>.</p>
</dd>
<dt>anything else</dt><dd><p>Equivalent to both <code>"id"</code> and <code>"structure"</code>.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="compare_alternatives_+3A_evaluate">evaluate</code></td>
<td>
<p><code>logical(1)</code>. Whether or not to evaluate <code>alternative</code> and <code>alternatives</code> beforehand.</p>
</td></tr>
<tr><td><code id="compare_alternatives_+3A_...">...</code></td>
<td>
<p>Optional parameters for <code><a href="#topic+evaluate">evaluate()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns or prints a <code>data.frame</code> consisting of columns:
<code>id</code> (if requested), <code>structure</code> (if requested),
values of <code>alternative</code> and comparison results for each alternative from <code>alternatives</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+compare_two_alternatives">compare_two_alternatives()</a></code>, <code><a href="#topic+evaluate">evaluate()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load "Car.dxi"
CarDxi &lt;- system.file("extdata", "Car.dxi", package = "DEXiR")
Car &lt;- read_dexi(CarDxi)

# Extend Car$alternatives
car3 &lt;- set_alternative(Car, Car$alternatives[2,], name = "Car3", LUGGAGE = 2)
Car$alternatives[3,] &lt;- car3
car4 &lt;- set_alternative(Car, Car$alternatives[2,], name = "Car4", LUGGAGE = 1)

# Compare Car1 with the other two, varying some arguments
compare_alternatives(Car, 1, evaluate=TRUE, compare=FALSE)
compare_alternatives(Car, 1, evaluate=TRUE, compare=TRUE)
compare_alternatives(Car, 1, evaluate=TRUE, compare=TRUE, deep=FALSE)

# Compare Car2 with Car1
compare_alternatives(Car, 2, 1)

# Compare car3 with Car1 and Car2
compare_alternatives(Car, car3, 1:2)

# Compare car4 with Car$alternatives
compare_alternatives(Car, car4)

# Compare Car$alternatives[1,] with car3
compare_alternatives(Car, 1, car3)
compare_alternatives(Car, Car$alternatives[1,], car3)
</code></pre>

<hr>
<h2 id='compare_two_alternatives'>compare_two_alternatives</h2><span id='topic+compare_two_alternatives'></span>

<h3>Description</h3>

<p>Compare alternatives <code>alt1</code> and <code>alt2</code> with respect to <code>attributes</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compare_two_alternatives(alt1, alt2, attributes, deep = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="compare_two_alternatives_+3A_alt1">alt1</code></td>
<td>
<p><code>data.frame</code>. First alternative.</p>
</td></tr>
<tr><td><code id="compare_two_alternatives_+3A_alt2">alt2</code></td>
<td>
<p><code>data.frame</code>. Second alternative.</p>
</td></tr>
<tr><td><code id="compare_two_alternatives_+3A_attributes">attributes</code></td>
<td>
<p>Vector of <a href="#topic+DexiAttribute">DexiAttribute</a> objects.</p>
</td></tr>
<tr><td><code id="compare_two_alternatives_+3A_deep">deep</code></td>
<td>
<p><code>logical(1)</code>. When <code>TRUE</code> and compared values are equal,
input attributes are additionally investigated for possible preferential differences.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>numeric(length(attributes))</code>.
Each element represents the outcome of comparison w.r.t. the corresponding attribute.
Possible outcomes:
</p>

<dl>
<dt><code>0</code></dt><dd><p>Values are equal.</p>
</dd>
<dt><code>-1</code></dt><dd><p><code>alt1</code>'s value is worse than <code>alt2</code>'s.</p>
</dd>
<dt><code>+1</code></dt><dd><p><code>alt1</code>'s value is better than <code>alt2</code>'s.</p>
</dd>
<dt><code>NA</code></dt><dd><p>Values are incomparable.</p>
</dd>
</dl>

<p>When <code>deep = TRUE</code>, the so-called deep comparison is performed:
when the compared attribute's values are equal,
subordinate attributes are checked for differences, possibly returning
<code>-0.5</code> (indicating the weak preference relation &quot;&lt;=&quot;) or
<code>+0.5</code> (indicating the weak preference relation &quot;&gt;=&quot;).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+compare_values_on_scale">compare_values_on_scale()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load "Car.dxi"
CarDxi &lt;- system.file("extdata", "Car.dxi", package = "DEXiR")
Car &lt;- read_dexi(CarDxi)

compare_two_alternatives(Car$alternatives[1,], Car$alternatives[2,], Car$attributes)
# c(NA, 1, 1, 0, 1, 1, 0, 0, 0, 0, 1)
</code></pre>

<hr>
<h2 id='compare_values'>compare_values</h2><span id='topic+compare_values'></span>

<h3>Description</h3>

<p>Compare two DEXi values.
Internal representation is assumed for <code>value1</code> and <code>value2</code>, i.e.,
a single number, an integer vector representing a set or <code><a href="#topic+distribution">distribution()</a></code>.
Distributions are compared as sets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compare_values(value1, value2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="compare_values_+3A_value1">value1</code></td>
<td>
<p>First value.</p>
</td></tr>
<tr><td><code id="compare_values_+3A_value2">value2</code></td>
<td>
<p>Second value.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>0</code> if values are equal, <code>-1</code> if <code>value1 &lt; value2</code>, <code>+1</code> if <code>value1 &gt; value2</code>
and <code>NA</code> if values are incomparable. Values are incomparable if they are of a non-DEXiValue
type or if they represent two overlapping sets.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>compare_values(c(1,2), c(1,2))       # 0
compare_values(c(1,2), c(1,3))       # NA
compare_values(c(1,2), c(3,4))       # -1
compare_values(c(1,2), c(2,4))       # NA
compare_values(c(1,2), c(2.1,4))     # -1
compare_values(c(1,2.05), c(2.1,4))  # -1
compare_values(c(3,4), c(3,4))       # 0
compare_values(c(5,5), c(3,4))       # +1
compare_values(c(5,5), 2)            # +1
compare_values(c(5,2), 2)            # NA
compare_values(c(5,3), 2)            # +1
compare_values(distribution(5,3), 2) # NA
compare_values(distribution(5,3), 5) # -1
</code></pre>

<hr>
<h2 id='compare_values_by_preference'>compare_values_by_preference</h2><span id='topic+compare_values_by_preference'></span>

<h3>Description</h3>

<p>Compare values, considering preference <code>order</code>. For value arguments, see <code><a href="#topic+compare_values">compare_values()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compare_values_by_preference(value1, value2, order = EnumOrder)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="compare_values_by_preference_+3A_value1">value1</code></td>
<td>
<p>First value.</p>
</td></tr>
<tr><td><code id="compare_values_by_preference_+3A_value2">value2</code></td>
<td>
<p>Second value.</p>
</td></tr>
<tr><td><code id="compare_values_by_preference_+3A_order">order</code></td>
<td>
<p><code>EnumOrder</code>, i.e., one of the strings <code style="white-space: pre;">&#8288;"ascending", "descending", "none"&#8288;</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code><a href="#topic+compare_values">compare_values()</a></code> result, modified according to <code>order</code>.
Results <code>0</code> (equal values) and <code>NA</code> (incomparable values) are always retained.
Results <code>-1</code> and <code>+1</code> are retained when <code>order="ascending"</code> and
reversed when <code>order="descending"</code>.
When <code>order="none"</code>, non-equal values return <code>NA</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+compare_values">compare_values()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>compare_values_by_preference(1, 1, "none")       # 0
compare_values_by_preference(1, 2, "none")       # NA
compare_values_by_preference(3, 2, "none")       # NA
compare_values_by_preference(1, 1, "ascending")  # 0
compare_values_by_preference(1, 2, "ascending")  # -1
compare_values_by_preference(3, 2, "ascending")  # +1
compare_values_by_preference(1, 1, "descending") # 0
compare_values_by_preference(1, 2, "descending") # +1
compare_values_by_preference(3, 2, "descending") # -1
</code></pre>

<hr>
<h2 id='compare_values_on_scale'>compare_values_on_scale</h2><span id='topic+compare_values_on_scale'></span>

<h3>Description</h3>

<p>Compare values <code>value1</code> and <code>value2</code> considering <code>scale$order</code>.
Internal DEXi representation is assumed for values, i.e.,
a single number, an integer vector representing a set or <code><a href="#topic+distribution">distribution()</a></code>.
Distributions are compared as sets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compare_values_on_scale(value1, value2, scale, force_compare = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="compare_values_on_scale_+3A_value1">value1</code></td>
<td>
<p>First value.</p>
</td></tr>
<tr><td><code id="compare_values_on_scale_+3A_value2">value2</code></td>
<td>
<p>Second value.</p>
</td></tr>
<tr><td><code id="compare_values_on_scale_+3A_scale">scale</code></td>
<td>
<p>Normally a <code>DEXiScale</code> object or a <code>DexiAttribute</code> object with defined <code style="white-space: pre;">&#8288;$scale&#8288;</code>.</p>
</td></tr>
<tr><td><code id="compare_values_on_scale_+3A_force_compare">force_compare</code></td>
<td>
<p><code>logical(1)</code>. Applies when <code>scale</code> is <code>NULL</code> or anything other than expected.
When <code>force_compare = TRUE</code>, comparison is enforced, assuming <code>"ascending"</code> scale order.
When <code>force_compare = FALSE</code>, NA is returned.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code><a href="#topic+compare_values">compare_values()</a></code> result, modified according to <code>scale$order</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+compare_values">compare_values()</a></code>, <code><a href="#topic+compare_values_by_preference">compare_values_by_preference()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>compare_values_on_scale(1, 2, NULL)                       # NA
compare_values_on_scale(2, 1, "")                         # NA
compare_values_on_scale(1, 2, NULL, force_compare = TRUE) # -1
compare_values_on_scale(2, 1, "", force_compare = TRUE)   # +1

scl &lt;- DexiDiscreteScale(values = c("a", "b", "c"))
compare_values_on_scale(1, 1, scl)             # 0
compare_values_on_scale(1, 2, scl)             # -1
compare_values_on_scale(3, 2, scl)             # +1
compare_values_on_scale(c(1, 2), c(1, 2), scl) # 0
compare_values_on_scale(c(1, 2), c(2, 3), scl) # NA

scl &lt;- DexiDiscreteScale(order = "descending", values = c("a", "b", "c"))
compare_values_on_scale(1, 1, scl)             # 0
compare_values_on_scale(1, 2, scl)             # +1
compare_values_on_scale(3, 2, scl)             # -1
compare_values_on_scale(c(1, 2), c(1, 2), scl) # 0
compare_values_on_scale(c(1, 2), c(2, 3), scl) # NA

scl &lt;- DexiDiscreteScale(order = "none", values = c("a", "b", "c"))
compare_values_on_scale(1, 1, scl)             # 0
compare_values_on_scale(1, 2, scl)             # NA
compare_values_on_scale(3, 2, scl)             # NA
compare_values_on_scale(c(1, 2), c(1, 2), scl) # 0
compare_values_on_scale(c(1, 2), c(2, 3), scl) # NA
</code></pre>

<hr>
<h2 id='convert_alternatives'>convert_alternatives</h2><span id='topic+convert_alternatives'></span>

<h3>Description</h3>

<p>Converts a <code>data.frame</code> of alternatives' data to another <code>data.frame</code>. The conversion
generally involves: aggregating DEXi values originally represented by sets or distributions,
scaling aggregated values to a given interval and/or reversing values assigned to &quot;descending&quot;
<a href="#topic+DexiScale">DexiScale</a>s.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convert_alternatives(
  model,
  alternatives = NULL,
  interpret = c("set", "distribution", "none"),
  aggregate = min,
  omin = 0,
  omax = 1,
  map_values = TRUE,
  reverse_descending = TRUE,
  verbatim = "name",
  skip = NULL,
  continuous = convert_data_continuous,
  discrete = convert_data_discrete
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="convert_alternatives_+3A_model">model</code></td>
<td>
<p>A <a href="#topic+DexiModel">DexiModel</a> object. Required.</p>
</td></tr>
<tr><td><code id="convert_alternatives_+3A_alternatives">alternatives</code></td>
<td>
<p>A <code>data.frame</code> of alternatives (normally an output of <code><a href="#topic+evaluate">evaluate()</a></code>) or
indices to <code>model$alternatives</code>. The default value <code>NULL</code> selects <code>model$alternatives</code>.</p>
</td></tr>
<tr><td><code id="convert_alternatives_+3A_interpret">interpret</code></td>
<td>
<p><code>character(1)</code>. Determines how the original values in <code>alternatives</code> are
interpreted, i.e., converted prior to submitting them to <code>aggregate()</code>:
</p>

<dl>
<dt><code>"set"</code></dt><dd><p>As a set of values. Any <a href="#topic+distribution">distribution</a>-type value is converted to a set,
thus discarding the numeric membership information.</p>
</dd>
<dt><code>"distribution"</code></dt><dd><p>As a value distribution, i.e., a numeric vector of membership values.</p>
</dd>
<dt><code>"none"</code></dt><dd><p>No conversion.</p>
</dd>
</dl>

<p>Values corresponding to continuous attributes are not converted nor affected by these settings.</p>
</td></tr>
<tr><td><code id="convert_alternatives_+3A_aggregate">aggregate</code></td>
<td>
<p>A function accepting the interpreted DEXi value (see <code>interpret</code>) and converting
it to become part of the output data frame. Normally, this function is assumed to accept
a numeric vector argument and aggregate it in a single numeric value.
The default aggregation function is <code><a href="base.html#topic+min">min()</a></code>. Typical alternatives include <code><a href="base.html#topic+max">max()</a></code> and <code><a href="base.html#topic+mean">mean()</a></code>.</p>
</td></tr>
<tr><td><code id="convert_alternatives_+3A_omin">omin</code></td>
<td>
<p><code>numeric(1)</code>. Lower bound of the output value interval (see <code>map_values</code>). Default: <code>0</code>.</p>
</td></tr>
<tr><td><code id="convert_alternatives_+3A_omax">omax</code></td>
<td>
<p><code>numeric(1)</code>. Upper bound of the output value interval (see <code>map_values</code>). Default: <code>1</code>.</p>
</td></tr>
<tr><td><code id="convert_alternatives_+3A_map_values">map_values</code></td>
<td>
<p><code style="white-space: pre;">&#8288;logical(1).&#8288;</code> When <code>TRUE</code>, values produced by <code>aggregate()</code> are further scaled
to the interval <code style="white-space: pre;">&#8288;[omin:omax]&#8288;</code>. Input bounds are determined from
the corresponding attribute scales (for discrete attributes) or
as minimum/maximum values from <code>alternatives</code> (for continuous attributes).</p>
</td></tr>
<tr><td><code id="convert_alternatives_+3A_reverse_descending">reverse_descending</code></td>
<td>
<p><code style="white-space: pre;">&#8288;logical(1).&#8288;</code> Whether or not to reverse the values of attributes
whose scales are of a &quot;descending&quot; preference order.</p>
</td></tr>
<tr><td><code id="convert_alternatives_+3A_verbatim">verbatim</code></td>
<td>
<p><code>character()</code>. Names of <code>alternatives</code>' data columns
that are included in the output without conversion. Default: <code>"name"</code>.</p>
</td></tr>
<tr><td><code id="convert_alternatives_+3A_skip">skip</code></td>
<td>
<p><code>character()</code>. Names of <code>alternatives</code>' data columns
that are ignored in the process. Default: <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="convert_alternatives_+3A_continuous">continuous</code></td>
<td>
<p>A function converting a data column that corresponds to a continuous attribute.
Default: <code><a href="#topic+convert_data_continuous">convert_data_continuous()</a></code>.
Setting <code>continuous</code> to <code>NULL</code> excludes all continuous attributes from conversion.</p>
</td></tr>
<tr><td><code id="convert_alternatives_+3A_discrete">discrete</code></td>
<td>
<p>A function converting a data column that corresponds to a discrete attribute.
Default: <code><a href="#topic+convert_data_discrete">convert_data_discrete()</a></code>.
Setting <code>discrete</code> to <code>NULL</code> excludes all discrete attributes from conversion.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The rationale for <code>convert_alternatives()</code> is that data frames representing alternatives,
particularly those produced by <code><a href="#topic+evaluate">evaluate()</a></code>, generally contain DEXi values of various
and mixed data types, such as numbers and numeric vectors (sets and distributions).
As such, this data is difficult to work with in R,
as most R functions expect simpler and more uniform data structures.
<code>convert_alternatives()</code> produces data frames that are more suitable for standard R data analysis
and graph drawing. However, as the conversion generally involves aggregation and mapping
of DEXi values, it may distort or lose information along the way.
</p>


<h3>Value</h3>

<p>A converted <code>data.frame</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+convert_data_continuous">convert_data_continuous()</a></code>, <code><a href="#topic+convert_data_discrete">convert_data_discrete()</a></code>, <code><a href="#topic+scale_alternatives">scale_alternatives()</a></code>,
<a href="#topic+DEXiR-package">DEXiR-package</a> notes on values in DEXi models.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load "Car.dxi"
CarDxi &lt;- system.file("extdata", "Car.dxi", package = "DEXiR")
Car &lt;- read_dexi(CarDxi)

# Map Car$alternatives' values to the [0, 1] interval.
convert_alternatives(Car)

#  name     CAR.1 PRICE BUY.PRICE MAINT.PRICE TECH.CHAR. COMFORT X.PERS   X.DOORS LUGGAGE SAFETY
# 1 Car1 1.0000000   1.0       0.5         1.0  1.0000000       1      1 0.6666667       1    1.0
# 2 Car2 0.6666667   0.5       0.5         0.5  0.6666667       1      1 0.6666667       1    0.5

</code></pre>

<hr>
<h2 id='convert_data_continuous'>convert_data_continuous</h2><span id='topic+convert_data_continuous'></span>

<h3>Description</h3>

<p>A helper function for converting individual columns of alternatives' data.
It is assumed that <code>data</code>  contains numeric data corresponding to a continuous
<a href="#topic+DexiAttribute">DexiAttribute</a>. During conversion,
values are optionally converted from some interval to another, using <code><a href="#topic+lin_map">lin_map()</a></code>, and/or
reversed using <code><a href="#topic+reverse_value">reverse_value()</a></code> for scales whose <code style="white-space: pre;">&#8288;$order = "descending"&#8288;</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convert_data_continuous(
  data,
  scale,
  imin = NULL,
  imax = NULL,
  omin = 0,
  omax = 1,
  map_values = TRUE,
  reverse_descending = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="convert_data_continuous_+3A_data">data</code></td>
<td>
<p>A vector containing floating point numbers.
Typically a <code>data.frame</code> column of DEXi alternatives' data.</p>
</td></tr>
<tr><td><code id="convert_data_continuous_+3A_scale">scale</code></td>
<td>
<p>A <a href="#topic+DexiContinuousScale">DexiContinuousScale</a> object or a continuous <a href="#topic+DexiAttribute">DexiAttribute</a> object.</p>
</td></tr>
<tr><td><code id="convert_data_continuous_+3A_imin">imin</code></td>
<td>
<p>Lower input bound. Default: determined as <code>min(data)</code>.</p>
</td></tr>
<tr><td><code id="convert_data_continuous_+3A_imax">imax</code></td>
<td>
<p>Upper input bound. Default: determined as <code>max(data)</code>.</p>
</td></tr>
<tr><td><code id="convert_data_continuous_+3A_omin">omin</code></td>
<td>
<p>Lower output bound for <code><a href="#topic+lin_map">lin_map()</a></code> value scaling.</p>
</td></tr>
<tr><td><code id="convert_data_continuous_+3A_omax">omax</code></td>
<td>
<p>Upper output bound for <code><a href="#topic+lin_map">lin_map()</a></code> value scaling.</p>
</td></tr>
<tr><td><code id="convert_data_continuous_+3A_map_values">map_values</code></td>
<td>
<p><code>logical(1)</code>. Whether or not to perform value scaling using <code><a href="#topic+lin_map">lin_map()</a></code>.</p>
</td></tr>
<tr><td><code id="convert_data_continuous_+3A_reverse_descending">reverse_descending</code></td>
<td>
<p><code>logical(1)</code>. Whether or not to reverse values of a &quot;descending&quot; scale.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>numeric()</code>. Vector of converted values.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lin_map">lin_map()</a></code>, <code><a href="#topic+reverse_value">reverse_value()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>scl &lt;- DexiContinuousScale()
convert_data_continuous(c(1, 2, 5), scl) # c(0.0, 0.25, 1.00)
convert_data_continuous(c(1, 2, 5), scl, imin = 0, imax = 10, omin = 0, omax = 100)
# c(10, 20, 50)

</code></pre>

<hr>
<h2 id='convert_data_discrete'>convert_data_discrete</h2><span id='topic+convert_data_discrete'></span>

<h3>Description</h3>

<p>#' A helper function for converting individual columns of alternatives' data.
It is assumed that <code>data</code>  contains data corresponding to a discrete
<a href="#topic+DexiAttribute">DexiAttribute</a>. During conversion, <code>data</code> elements are converted either
to sets or distributions, and function <code>aggregate</code> if applied on them.
When <code>interpret = "set"</code>, values are also optionally converted to the interval <code style="white-space: pre;">&#8288;[omin:omax]&#8288;</code>,
and reversed using <code><a href="#topic+reverse_value">reverse_value()</a></code> for scales whose <code style="white-space: pre;">&#8288;$order = "descending"&#8288;</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convert_data_discrete(
  data,
  scale,
  interpret = c("set", "distribution", "none"),
  aggregate = min,
  omin = 0,
  omax = 1,
  map_values = TRUE,
  reverse_descending = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="convert_data_discrete_+3A_data">data</code></td>
<td>
<p>A vector containing DEXi values: single numbers, integer vectors or distribuions.
Typically a <code>data.frame</code> column of DEXi alternatives' data.</p>
</td></tr>
<tr><td><code id="convert_data_discrete_+3A_scale">scale</code></td>
<td>
<p>A <a href="#topic+DexiDiscreteScale">DexiDiscreteScale</a> object or a discrete <a href="#topic+DexiAttribute">DexiAttribute</a> object.</p>
</td></tr>
<tr><td><code id="convert_data_discrete_+3A_interpret">interpret</code></td>
<td>
<p>Either <code>"set"</code> (default), <code>"distribution"</code> or <code>"none"</code>.
Determines how are individual <code>data</code> elements interpreted: as sets or distributions.
Actually, each element is converted either to a set or distribution prior do applying <code>aggregate()</code>.
When <code>interpret = "none"</code>, just <code>aggregate()</code> is applied on the original <code>value</code> from <code>data</code>,
without any value scaling or reversal.</p>
</td></tr>
<tr><td><code id="convert_data_discrete_+3A_aggregate">aggregate</code></td>
<td>
<p>A function applied on each interpreted <code>data</code> element.
Normally a function that maps a numeric vector (set or distribution) to a single number.
Default: <code><a href="base.html#topic+min">min()</a></code>.</p>
</td></tr>
<tr><td><code id="convert_data_discrete_+3A_omin">omin</code></td>
<td>
<p>Lower output bound for <code><a href="#topic+lin_map">lin_map()</a></code> value scaling. Applies only when <code>interpret = "set"</code>.</p>
</td></tr>
<tr><td><code id="convert_data_discrete_+3A_omax">omax</code></td>
<td>
<p>Upper output bound for <code><a href="#topic+lin_map">lin_map()</a></code> value scaling  Applies only when <code>interpret = "set"</code>.</p>
</td></tr>
<tr><td><code id="convert_data_discrete_+3A_map_values">map_values</code></td>
<td>
<p><code>logical(1)</code>. Whether or not to perform value scaling using <code><a href="#topic+lin_map">lin_map()</a></code>.
Applies only when <code>interpret = "set"</code>.</p>
</td></tr>
<tr><td><code id="convert_data_discrete_+3A_reverse_descending">reverse_descending</code></td>
<td>
<p><code>logical(1)</code>. Whether or not to reverse values of a &quot;descending&quot; scale.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector of converted values.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lin_map">lin_map()</a></code>, <code><a href="#topic+reverse_value">reverse_value()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>scla &lt;- DexiDiscreteScale(values = c("L", "M", "H"))
scld &lt;- DexiDiscreteScale(values = c("L", "M", "H"), order = "descending")
convert_data_discrete(c(1, 2, 3), scla)    # 0.0 0.5 1.0
convert_data_discrete(c(1, 2, 3), scld)    # 1.0 0.5 0.0
convert_data_discrete(list(1, 2, 3), scla) # 0.0 0.5 1.0
convert_data_discrete(list(1, 2, 3), scld) # 1.0 0.5 0.0
convert_data_discrete(list(1, 2, 3), scld, omax=10) # 10  5  0
data &lt;- list(1, c(1,2), distribution(0.2, 0, 0.8), NA)
convert_data_discrete(data, scla, omax=10) #  0  0  0 NA
convert_data_discrete(data, scld, omax=10) # 10 10 10 NA
convert_data_discrete(data, scla, aggregate=max, omax=10)  #  0  5 10 NA
convert_data_discrete(data, scla, aggregate=mean, omax=10) # 0.0 2.5 5.0  NA

</code></pre>

<hr>
<h2 id='default_quality'>default_quality</h2><span id='topic+default_quality'></span>

<h3>Description</h3>

<p>Make a default discrete scale quality vector depending on the scale's <code>order</code> and <code>nvals</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>default_quality(order = EnumOrder, nvals)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="default_quality_+3A_order">order</code></td>
<td>
<p>'character(1)1, one of &quot;ascending&quot;, &quot;descending&quot; or &quot;none&quot;.</p>
</td></tr>
<tr><td><code id="default_quality_+3A_nvals">nvals</code></td>
<td>
<p><code>integer(1)</code>. The number of qualitative values of considered <a href="#topic+DexiDiscreteScale">DexiDiscreteScale</a>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>character vector of length <code>nvals</code>, containing
<code>"bad"</code>, <code>"none"</code> or <code>"good"</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>default_quality("ascending", 5)
default_quality("descending", 5)
default_quality("none", 5)
default_quality("ascending", 2)
default_quality("ascending", 1)

</code></pre>

<hr>
<h2 id='dexi_bool'>dexi_bool</h2><span id='topic+dexi_bool'></span>

<h3>Description</h3>

<p>Convert a DEXi string to logical. <code>"TRUE"</code>, <code>"T"</code> and <code>"1"</code> are interpreted as <code>TRUE</code>,
all other strings as <code>FALSE</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dexi_bool(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dexi_bool_+3A_x">x</code></td>
<td>
<p>character(1).</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>logical(1)</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dexi_bool("TRUE")
sapply(c("TRUE", "T", "1", TRUE, 1, "FALSE", "F", "0", NULL, NA, NaN), dexi_bool)

</code></pre>

<hr>
<h2 id='dexi_index'>dexi_index</h2><span id='topic+dexi_index'></span>

<h3>Description</h3>

<p>Return the index of argument vector <code>vec</code> in the decision space <code>dim</code>.
The index is calculated according to DEXi's sorting rules, which are different to R's.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dexi_index(vec, dim)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dexi_index_+3A_vec">vec</code></td>
<td>
<p>Integer vector, representing arguments of some decision rule.</p>
</td></tr>
<tr><td><code id="dexi_index_+3A_dim">dim</code></td>
<td>
<p>Integer vector, representing dimensions of the corresponding decision space.
Assumptions: <code>length(vec) == length(dim)</code> and, for each <code>i</code>,
<code style="white-space: pre;">&#8288;1 &lt;= vec[[i]] &lt;= dim[[i]]&#8288;</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Integer, index of <code>vec</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dexi_index(c(1,1,1), c(2,2,3))
dexi_index(c(1,1,2), c(2,2,3))
dexi_index(c(1,2,3), c(2,2,3))

</code></pre>

<hr>
<h2 id='dexi_option_value'>dexi_option_value</h2><span id='topic+dexi_option_value'></span>

<h3>Description</h3>

<p>Conversion of a string to a &quot;DEXi value&quot; (see <a href="#topic+DEXiR-package">DEXiR-package</a>) according to &quot;old&quot;
DEXi syntax. In <code>.dxi</code> files, the old syntax is used with <code>OPTION</code> XML tags.
The reason for replacing the old with the new syntax (see <code><a href="#topic+dexi_value">dexi_value()</a></code>) was
that the old syntax can not unambiguously represent value distributions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dexi_option_value(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dexi_option_value_+3A_x">x</code></td>
<td>
<p><code>character(1)</code>. Contains a sequence of characters, each of which represents an individual ordinal number.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector. The conversion uses <code>rule_values(x, add = 1)</code>.
For special-type parameters, the conversion results are:
</p>
<pre>
 x                              result
 ------------------------------+------
 NULL                           NULL
 a non-character object         NA
 "" or "*"                      "*"
 a string starting with "undef" NA
</pre>


<h3>See Also</h3>

<p><a href="#topic+DEXiR-package">DEXiR-package</a>, <code><a href="#topic+dexi_value">dexi_value()</a></code>, <code><a href="#topic+rule_value">rule_value()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dexi_option_value(NULL)
dexi_option_value(NA)
dexi_option_value("")
dexi_option_value("*")
dexi_option_value("undef")
dexi_option_value("1")
dexi_option_value("012")


</code></pre>

<hr>
<h2 id='dexi_table'>dexi_table</h2><span id='topic+dexi_table'></span>

<h3>Description</h3>

<p>Create a representation of DEXi's decision table in R.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dexi_table(dim, low, high = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dexi_table_+3A_dim">dim</code></td>
<td>
<p>An integer vector, representing dimensions of the underlying decision space.</p>
</td></tr>
<tr><td><code id="dexi_table_+3A_low">low</code></td>
<td>
<p><code>character(1)</code>. A string normally read from a <code>.dxi</code> file, representing the lower bounds
of the corresponding decision rule values (assuming the order according to <code><a href="#topic+dexi_index">dexi_index()</a></code>).
Notice that the string contains zero-based characters, which are converted to one-based integer values used in R.</p>
</td></tr>
<tr><td><code id="dexi_table_+3A_high">high</code></td>
<td>
<p><code>character(1)</code> or <code>NULL</code>. A string representing the upper bounds
of corresponding decision rule values. If <code>high = NULL</code>, <code>high</code> is assumed
to be equal to <code>low</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>length(dim)</code>-dimensional matrix of rule values, which are normally single integer values,
but might also be sets of values. Each set is represented by a numeric vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Converting DEXi's value strings to R's numeric vectors.
dexi_table(c(2, 3), "011012")
dexi_table(c(2, 3), "011012", "012112")

</code></pre>

<hr>
<h2 id='dexi_value'>dexi_value</h2><span id='topic+dexi_value'></span>

<h3>Description</h3>

<p>Conversion of a string to a &quot;DEXi value&quot; (see <a href="#topic+DEXiR-package">DEXiR-package</a>) according to &quot;new&quot;
DEXi syntax rules. In <code>.dxi</code> files, this syntax is used in <code>ALTERNATIVE</code> and
<code>RULE</code> XML tags. Examples of possible options include:
</p>
<pre>
 x                              result
 ------------------------------+-------------------------------------------------
 NULL or ""                     NULL
 "*"                            "*"
 a string starting with "undef" NA
 "2"                            a single ordinal value, c(2) in this case
 "2.1"                          a single number, c(2.1) in this case
 "1:3"                          interval, equivalent to c(1, 2, 3)
 "{0;2;3}"                      a value set, equivalent to c(0, 2, 3)
 "&lt;0;0.3;0.7&gt;"                  a value distribution, distribution(0.0, 0.3, 0.7)
</pre>


<h3>Usage</h3>

<pre><code class='language-R'>dexi_value(x, add = 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dexi_value_+3A_x">x</code></td>
<td>
<p>character(1).</p>
</td></tr>
<tr><td><code id="dexi_value_+3A_add">add</code></td>
<td>
<p>A numeric constant to be added to the result. Useful
when converting DEXi's zero-based representation to one-based representation used in R,
which requires the setting <code>add = 1</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A single integer or real number, an integer numeric vector, or a <a href="#topic+distribution">distribution</a>.
</p>


<h3>See Also</h3>

<p><a href="#topic+DEXiR-package">DEXiR-package</a>, <code><a href="#topic+dexi_option_value">dexi_option_value()</a></code>, <a href="#topic+distribution">distribution</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dexi_value("")
dexi_value(NULL)
dexi_value("*")
dexi_value("UNDEF")
dexi_value("2")
dexi_value("2.1")
dexi_value("1:3")
dexi_value("{0;2;3}")
dexi_value("{0;2;3}", add = 1)
dexi_value("&lt;0;0.3;0.7&gt;")

</code></pre>

<hr>
<h2 id='dexi_vector'>dexi_vector</h2><span id='topic+dexi_vector'></span>

<h3>Description</h3>

<p>Interpret a string, composed of <code>";"</code>-separated numbers, as a numeric vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dexi_vector(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dexi_vector_+3A_x">x</code></td>
<td>
<p><code>character(1)</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dexi_vector("1;2")
dexi_vector("1.2; 2.3")

</code></pre>

<hr>
<h2 id='DexiAttribute-class'>DexiAttribute</h2><span id='topic+DexiAttribute-class'></span><span id='topic+DexiAttribute'></span>

<h3>Description</h3>

<p><code>DexiAttribute</code> is a RC class representing a DEXi attribute in R.
</p>


<h3>Details</h3>

<p>In a DEXi model, attributes are variables that represent observed properties of decision alternatives.
Attributes are structured in a tree, so each attribute may, but need not, have one or more direct
descendants (lower-level attributes) in the tree. Attributes without descendants are called <em>basic</em>
and serve as model inputs. Attributes with one or more descendants are called <em>aggregate</em> and
represent model outputs. In order to represent attribute hierarchies rather than plain trees, some attributes
may be <em>linked</em>: two attributes of which one links to another one collectively represent,
in a conceptual sense, a single attribute in the hierarchy.
</p>
<p>When completely defined, each attribute is associated with a value scale represented by a
<a href="#topic+DexiScale">DexiScale</a> object.
An object <a href="#topic+DexiFunction">DexiFunction</a> is also defined for each aggregate attribute, aimed at
defining the aggregation of the attribute's inputs to values of that attribute.
</p>


<h3>Fields</h3>


<dl>
<dt><code>name</code></dt><dd><p>character. Name of the attribute as defined in the original DEXi model. Notice that such names
may not be unique and may contain characters that cannot be used for variable names in R.</p>
</dd>
<dt><code>id</code></dt><dd><p>character. A unique identification of the attribute in the model. Derived from <code>name</code>
so that it can be used as a variable name in R.</p>
</dd>
<dt><code>description</code></dt><dd><p>character. An optional textual description of the attribute.</p>
</dd>
<dt><code>inputs</code></dt><dd><p>list of <a href="#topic+DexiAttribute">DexiAttribute</a>s. A list of immediate descendants of this attribute in
the tree/hierarchy. <code>NULL</code> for basic attributes.</p>
</dd>
<dt><code>link</code></dt><dd><p><a href="#topic+DexiAttribute">DexiAttribute</a>. <code>NULL</code> or a link to another <a href="#topic+DexiAttribute">DexiAttribute</a></p>
</dd>
<dt><code>scale</code></dt><dd><p><a href="#topic+DexiScale">DexiScale</a>. Value scale associated with this attribute, or <code>NULL</code>.</p>
</dd>
<dt><code>funct</code></dt><dd><p><a href="#topic+DexiFunction">DexiFunction</a>. Aggregation function associated with this attribute, or <code>NULL</code>.</p>
</dd>
<dt><code>parent</code></dt><dd><p><a href="#topic+DexiAttribute">DexiAttribute</a> or <a href="#topic+DexiModel">DexiModel</a> (only for <code>DexiModel$root</code>). Parent
attribute of this attribute in the tree/hierarchy. The <code>DexiModel$root</code>'s parent
is the <a href="#topic+DexiModel">DexiModel</a>, which contains all those attributes.</p>
</dd>
<dt><code>.alternatives</code></dt><dd><p>list. An internal field providing temporary storage for names or values of alternatives
while reading them from a <code>.dxi</code> file.</p>
</dd>
</dl>


<h3>Methods</h3>


<dl>
<dt><code>affects(ant)</code></dt><dd><p><code>ant</code> (as &quot;antecedent&quot;) is some <code><a href="#topic+DexiAttribute">DexiAttribute</a></code>.
The function returns <code>TRUE</code> if <code>ant</code> lies on the path leading from this attribute
towards the root, and is therefore affected by this attribute.</p>
</dd>
<dt><code>count()</code></dt><dd><p>Return the number of <code>input</code>s of this attribute.</p>
</dd>
<dt><code>dim()</code></dt><dd><p>Dimensions of the value space determined by this attribute's <code>inputs</code>.
Result: a numeric vector of length equal to <code>ninp()</code>, containing <code>DexiScale$count()</code> of
all descendant attributes, or <code>NA</code> for attributes without associated scales.
For basic attributes, <code>dim()</code> returns <code>NULL</code>.</p>
</dd>
<dt><code>initialize(
  name = "",
  description = "",
  inputs = list(),
  id = "",
  link = NULL,
  scale = NULL,
  funct = NULL,
  parent = NULL,
  ...
)</code></dt><dd><p>Initialize a <code>DexiAttribute</code> object.</p>
</dd>
<dt><code>inp_index(inp)</code></dt><dd><p>Return the index of attribute <code>inp</code> in <code>inputs</code> of this attribute.</p>
</dd>
<dt><code>is_aggregate()</code></dt><dd><p>Logical: <code>TRUE</code> for aggregate attributes (attributes whose <code>ninp() &gt; 0</code>).</p>
</dd>
<dt><code>is_basic(include_linked = TRUE)</code></dt><dd><p>Logical: <code>TRUE</code> for basic attributes (attributes whose <code>ninp() == 0</code>.
<code>include_linked</code> determines whether linked attributes are counted as basic
(<code>TRUE</code>) or not (<code>FALSE</code>).</p>
</dd>
<dt><code>is_continuous()</code></dt><dd><p>Logical: Indicates whether or not this is a continuous attribute.</p>
</dd>
<dt><code>is_discrete()</code></dt><dd><p>Logical: Indicates whether or not this is a discrete attribute.</p>
</dd>
<dt><code>is_link()</code></dt><dd><p>Logical: Indicates whether or not this is a linked attribute.</p>
</dd>
<dt><code>level()</code></dt><dd><p>Return the level of this attribute in the hierarchy.
The level of <code>DexiModel$root</code> is 0.</p>
</dd>
<dt><code>model()</code></dt><dd><p>Return the <code>DexiModel</code> that contains this attribute.</p>
</dd>
<dt><code>ninp()</code></dt><dd><p>Return the number of <code>input</code>s of this attribute.</p>
</dd>
<dt><code>structure()</code></dt><dd><p>Make an indentation string for this attribute, used for printing it in <code>show()</code>.</p>
</dd>
<dt><code>tree_indent(none = " ", thru = "|", link = "*", last = "+", line = "-")</code></dt><dd><p>Construct a string for representing the indentation of this attribute in the model structure.
The arguments <code>none</code>, <code>thru</code>, <code>link</code>, <code>last</code> and <code>line</code> are
character strings to be used in the construction.</p>
</dd>
<dt><code>verify()</code></dt><dd><p>Check the correctnes of a <code>DexiAttribute</code> object and its fields. Result: <code>error()</code> or <code>TRUE</code>.</p>
</dd>
</dl>


<h3>Examples</h3>

<pre><code class='language-R'># Load "Car.dxi"
CarDxi &lt;- system.file("extdata", "Car.dxi", package = "DEXiR")
Car &lt;- read_dexi(CarDxi)

# For example, consider attribute PRICE
att &lt;- Car$attrib("PRICE")

# Print fields and basic properties of att
att$verify()
att$name
att$id
att$description
att_names(att$inputs)
att$link
att$scale
att$funct
att_names(att$parent)
att$is_aggregate()
att$is_basic()
att$is_link()
att$level()
att$count()
att$ninp()
att$dim()
att$model()
att$structure()

# Check if att affects attribute CAR
att$affects(Car$attrib("CAR"))

# Find the index of other attributes in att's inputs
att$inp_index(Car$attrib("MAINT.PRICE"))
att$inp_index(Car$attrib("CAR"))
</code></pre>

<hr>
<h2 id='DexiContinuousScale-class'>DexiContinuousScale</h2><span id='topic+DexiContinuousScale-class'></span><span id='topic+DexiContinuousScale'></span>

<h3>Description</h3>

<p><code>DexiContinuousScale</code> is a RC class, derived from <code>DexiScale</code>,
representing continuous value scales in R.
</p>


<h3>Details</h3>

<p>An attribute associated with a continuous scale can take any single numeric value from
<code style="white-space: pre;">&#8288;[-Inf, +Inf]&#8288;</code>.
</p>
<p><code>DexiContinuousScale</code> defines two numeric bounds, called <code>low_point</code> and
<code>high_point</code>, such that <code>low_point &lt;= high_point</code>. These values partition
preferentially ordered scales in three preferential classes (&quot;qualities&quot;):
<code>"bad"</code>, <code>"none"</code> (in the sense of <code>"neutral"</code>), and <code>"good"</code>.
For a scale with <code>order = "ascending"</code>, the three corresponding intervals are
<code style="white-space: pre;">&#8288;[-Inf, low_point]&#8288;</code>, <code style="white-space: pre;">&#8288;(low_point, high_point)&#8288;</code> and <code style="white-space: pre;">&#8288;[high_point, +Inf]&#8288;</code>.
For <code>order = "descending"</code>, the order of qualities is reversed.
Scales with <code>order = "none"</code> have only one associated quality,
<code>"none"</code>, for the whole range of values.
</p>
<p>Continuous scales are supported in DEXi Suite software (DEXiWin),
but not in older DEXi Classic software (DEXi).
</p>


<h3>Fields</h3>


<dl>
<dt><code>low_point</code></dt><dd><p>numeric. A bound for the quality interval <code style="white-space: pre;">&#8288;[-Inf, low_point]&#8288;</code>.</p>
</dd>
<dt><code>high_point</code></dt><dd><p>numeric. A bound for the quality interval <code style="white-space: pre;">&#8288;[high_point, +Inf]&#8288;</code>.</p>
</dd>
</dl>


<h3>Methods</h3>


<dl>
<dt><code>count()</code></dt><dd><p>Return the number of scale elements.
Equal to <code>NA</code> for <code>DexiScale</code>, <code>0</code> for <code>DexiContinuousScale</code>, and
equal to <code>nvals &gt;= 0</code> for <code>DexiDiscreteScale</code>.</p>
</dd>
<dt><code>equal(scl)</code></dt><dd><p>Check if this scale is equal to scale <code>scl</code>. Needed for attribute linking.</p>
</dd>
<dt><code>initialize(order = EnumOrder, ...)</code></dt><dd><p>Initialize a <code>DexiScale</code> object.</p>
</dd>
<dt><code>to_string()</code></dt><dd><p>Return a string representation of this scale for printing.</p>
</dd>
<dt><code>value_quality(value)</code></dt><dd><p>Return the quality (preferential class) of <code>value</code> on this scale:
one of the strings <code>"bad"</code>, <code>"none"</code> or <code>"good"</code>.
Always <code>"none"</code> for <code>DexiScale</code> and scales with <code>order = "none"</code>.</p>
</dd>
<dt><code>verify()</code></dt><dd><p>Check the correctnes of this scale object and its fields.
Result: <code>error()</code> or <code>TRUE</code>.</p>
</dd>
</dl>

<hr>
<h2 id='DexiDiscreteScale-class'>DexiDiscreteScale</h2><span id='topic+DexiDiscreteScale-class'></span><span id='topic+DexiDiscreteScale'></span>

<h3>Description</h3>

<p><code>DexiDiscreteScale</code> is a RC class, derived from <a href="#topic+DexiScale">DexiScale</a>,
representing qualitative (symbolic, discrete, verbal) value scales in R. Such scales are
typical for DEXi models and are the only scale type supported by the DEXi software.
DEXiWin software supports both continuous and discrete scales.
</p>


<h3>Details</h3>

<p>An attribute associated with a discrete scale can take values from a finite (and usually small)
set of string values contained in the character vector <code>values</code>. Additionally, each of these values is
associated with one of the qualities <code>"bad"</code>, <code>"none"</code> or <code>"good"</code>.
The latter are contained in the character vector <code>quality</code>,
which is of the same length as <code>values</code>.
</p>


<h3>Fields</h3>


<dl>
<dt><code>values</code></dt><dd><p>character. Vector of qualitative scale values.
Example: <code>scale$values &lt;- c("low", "medium", "high")</code>.</p>
</dd>
<dt><code>nvals</code></dt><dd><p>integer. Equal to <code>length(values)</code>.</p>
</dd>
<dt><code>quality</code></dt><dd><p>character. Vector of qualities, corresponding to <code>values</code>.
Should be the of the same length as <code>values</code>.
Example: <code>scale$quality &lt;- c("bad", "none", "good")</code>.</p>
</dd>
<dt><code>descriptions</code></dt><dd><p>character. A vector of textual descriptions of the corresponding
<code>values</code>. Should be of the same length as <code>values</code>.</p>
</dd>
</dl>


<h3>Methods</h3>


<dl>
<dt><code>count()</code></dt><dd><p>Return the number of scale elements.
Equal to <code>NA</code> for <code>DexiScale</code>, <code>0</code> for <code>DexiContinuousScale</code>, and
equal to <code>nvals &gt;= 0</code> for <code>DexiDiscreteScale</code>.</p>
</dd>
<dt><code>equal(scl)</code></dt><dd><p>Check if this scale is equal to scale <code>scl</code>. Needed for attribute linking.</p>
</dd>
<dt><code>full_range()</code></dt><dd><p>Return the vector that represents the full range of values on this scale.
Equal to <code>NA</code> for <code>DexiScale</code> and <code>DexiContinuousScale</code>,
and <code>1 : scale$nvals</code> for <code>DexiDiscreteScale</code>.</p>
</dd>
<dt><code>initialize(order = EnumOrder, ...)</code></dt><dd><p>Initialize a <code>DexiScale</code> object.</p>
</dd>
<dt><code>is_discrete()</code></dt><dd><p>Logical: Is this scale discrete?</p>
</dd>
<dt><code>to_string()</code></dt><dd><p>Return a string representation of this scale for printing.</p>
</dd>
<dt><code>value_index(value)</code></dt><dd><p>Find the index of <code>value</code> (character(1)) on this scale.
Equal to <code>NA</code> for <code>DexiScale</code> and <code>DexiContinuousScale</code>.
With <code>DexiDiscreteScale</code> objects, it returns a numeric index or <code>NA</code>
of <code>value</code> in <code>scale$values</code>.</p>
</dd>
<dt><code>value_quality(value)</code></dt><dd><p>Return the quality (preferential class) of <code>value</code> on this scale:
one of the strings <code>"bad"</code>, <code>"none"</code> or <code>"good"</code>.
Always <code>"none"</code> for <code>DexiScale</code> and scales with <code>order = "none"</code>.</p>
</dd>
<dt><code>verify()</code></dt><dd><p>Check the correctnes of this scale object and its fields.
Result: <code>error()</code> or <code>TRUE</code>.</p>
</dd>
</dl>


<h3>Examples</h3>

<pre><code class='language-R'># Load "Car.dxi"
CarDxi &lt;- system.file("extdata", "Car.dxi", package = "DEXiR")
Car &lt;- read_dexi(CarDxi)

# For example, consider the scale of attribute PRICE
scl &lt;- Car$attrib("PRICE")$scale

# Print fields and basic properties of scl
scl$verify()
scl$values
scl$quality
scl$descriptions
scl$nvals
scl$count()
scl$is_discrete()
scl$is_continuous()
scl$to_string()
scl$full_range()

# Find value indices
scl$value_index("medium")
scl$value_index("med")

# Is scl equal to the scale of BUY.PRICE?
scl$equal(Car$attrib("PRICE")$scale)

</code></pre>

<hr>
<h2 id='DexiDiscretizeFunction-class'>DexiDiscretizeFunction</h2><span id='topic+DexiDiscretizeFunction-class'></span><span id='topic+DexiDiscretizeFunction'></span>

<h3>Description</h3>

<p><code>DexiDiscretizeFunction</code> is a RC class, derived from <a href="#topic+DexiFunction">DexiFunction</a>.
Functions of this type discretize numerical values of continuous attributes to qualitative
values of discrete attributes. More precisely, a <code>DexiDiscretizeFunction</code> can be defined
only for a discrete attribute that has exactly one continuous input. Then, the function discretizes
numeric values of the input attribute and maps them to discrete values of the parent attribute.
</p>


<h3>Details</h3>

<p>Objects of class <code>DexiDiscretizeFunction</code>  define discretization rules in terms of three lists:
<code>values</code>, <code>bounds</code> and <code>assoc</code>. Using <code>n &lt;- nvals()</code> to denote the length of
<code>values</code>, the required lengths of <code>bounds</code> and <code>assoc</code> are <code>n - 1</code>.
</p>
<p>The list <code>bounds</code> refers to values of the input attribute and partitions its scale in <code>n</code> intervals
<code style="white-space: pre;">&#8288;[-Inf, bound[[1]]]&#8288;</code>, <code style="white-space: pre;">&#8288;[bound[[1]], bound[[2]]],&#8288;</code> ..., <code style="white-space: pre;">&#8288;[bound[[n - 1]]], +Inf]&#8288;</code>.
The list <code>values</code> then defines the output values for each interval.
The list <code>assoc</code> contains strings <code>"up"</code> or <code>"down"</code> that indicate to which interval,
lower or higher, belong the corresponding <code>bounds</code>.
</p>


<h3>Fields</h3>


<dl>
<dt><code>attribute</code></dt><dd><p><a href="#topic+DexiAttribute">DexiAttribute</a>. The attribute this function is associated with.
Requirements: <code>attribute</code> must be discrete (i.e., associated with a <a href="#topic+DexiDiscreteScale">DexiDiscreteScale</a>) and
must have exactly one continuous input attribute (i.e., associated with a <a href="#topic+DexiContinuousScale">DexiContinuousScale</a>).</p>
</dd>
<dt><code>values</code></dt><dd><p>A list of output values corresponding to each interval defined by <code>bounds</code>.
List elements are in general value sets, i.e., integer vectors of value indices w.r.t. <code>attribute$scale</code>.</p>
</dd>
<dt><code>bounds</code></dt><dd><p>A vector of numeric values that partitions the input scale in intervals.</p>
</dd>
<dt><code>assoc</code></dt><dd><p>A vector of strings <code>"up"</code> or <code>"down"</code>.
For each <code style="white-space: pre;">&#8288;i in 1:n-1&#8288;</code>, <code>assoc[[i]]</code> indicates how to map the value of
<code>bounds[[i]]</code>: to <code>value[[i]]</code> (<code>"down"</code>) or <code>value[[i + 1]]</code> (<code>"up"</code>).</p>
</dd>
</dl>


<h3>Methods</h3>


<dl>
<dt><code>bound_assoc(idx, default = "down")</code></dt><dd><p>Given <code>idx</code>, a <code>bounds</code> index, return the corresponing association
(<code>"down"</code> or <code>"up"</code>).</p>
</dd>
<dt><code>evaluate(x)</code></dt><dd><p>A silent wrapper around <code>value(x)</code>; it returns <code>NULL</code> when
<code>value(x)</code> fails with an error.</p>
</dd>
<dt><code>nargs()</code></dt><dd><p>Return the number of function arguments.</p>
</dd>
<dt><code>nvals()</code></dt><dd><p>Return the length of <code>values</code>.</p>
</dd>
<dt><code>to_string()</code></dt><dd><p>Return an informative string about this function's <code>values</code> and <code>bounds</code>.</p>
</dd>
<dt><code>value(x)</code></dt><dd><p>Return the function value for arguments <code>x</code>, where arguments are
a numeric vector of length equal to <code>att$inputs</code>.
Additionally, arguments of a <code>DexiTabularFunctions$value()</code> must be integer numbers,
and the argument of <code>DexiDiscretizeFunctions$value()</code> must be a single number.</p>
</dd>
<dt><code>verify()</code></dt><dd><p>Check the correctnes of this function object and its fields.
Result: <code>error()</code> or <code>TRUE</code>.</p>
</dd>
</dl>


<h3>Examples</h3>

<pre><code class='language-R'># Create a DexiDiscretizeFunction (without association to any attributes or scales)
fnc &lt;- DexiDiscretizeFunction(bounds = c(-1, 2), values = list(1, 3, 5), assoc = c("up", "down"))

# Print fields and basic properties of fnc

fnc$verify()
fnc$nargs()
fnc$nvals()
fnc$to_string()

fnc$bound_assoc(1)
fnc$bound_assoc(2)

# Try some discretizations
sapply(c(-1.1, -1, 0, 1, 2, 3), fnc$evaluate)

</code></pre>

<hr>
<h2 id='DexiFunction-class'>DexiFunction</h2><span id='topic+DexiFunction-class'></span><span id='topic+DexiFunction'></span>

<h3>Description</h3>

<p><code>DexiFunction</code> is a base RC class for representing DEXi aggregation and discretization functions in R.
</p>


<h3>Details</h3>

<p>DEXi functions are generally associated with aggregate attributes. For some aggregate attribute <code>att</code>,
<code>att$funct</code> defines the mapping from values of <code>att$inputs</code> to values of <code>att</code>.
</p>
<p><a href="#topic+DexiFunction">DexiFunction</a> is a base class that defines fields and methods common to all functions:
</p>

<ul>
<li><p> method <code>value(x)</code>: returns the function value for arguments <code>x</code>. Arguments are
assumed to be a numeric vector of length equal to <code>att$inputs</code>.
</p>
</li>
<li><p> method <code>evaluate(x)</code> is a silent wrapper around <code>value(x)</code>; it returns <code>NULL</code> when
<code>value(x)</code> fails with an error.
</p>
</li></ul>

<p>DEXiR implements two other function classes derived from <code>DexiFunction</code>:
<a href="#topic+DexiTabularFunction">DexiTabularFunction</a> and <a href="#topic+DexiDiscretizeFunction">DexiDiscretizeFunction</a>.
</p>


<h3>Methods</h3>


<dl>
<dt><code>evaluate(x)</code></dt><dd><p>A silent wrapper around <code>value(x)</code>; it returns <code>NULL</code> when
<code>value(x)</code> fails with an error.</p>
</dd>
<dt><code>value(x)</code></dt><dd><p>Return the function value for arguments <code>x</code>, where arguments are
a numeric vector of length equal to <code>att$inputs</code>.
Additionally, arguments of a <code>DexiTabularFunctions$value()</code> must be integer numbers,
and the argument of <code>DexiDiscretizeFunctions$value()</code> must be a single number.</p>
</dd>
<dt><code>verify()</code></dt><dd><p>Check the correctnes of this function object and its fields.
Result: <code>error()</code> or <code>TRUE</code>.</p>
</dd>
</dl>

<hr>
<h2 id='DexiModel-class'>DexiModel</h2><span id='topic+DexiModel-class'></span><span id='topic+DexiModel'></span>

<h3>Description</h3>

<p><code>DexiModel</code> is a RC class representing a DEXi model in R.
</p>


<h3>Details</h3>

<p>Normally, <code>DexiModel</code> objects are created by reading from a <code>.dxi</code> file,
previously developed by the DEXi software. In principle, all fields of a <code>DexiModel</code>
should be considered read-only. DEXiR does not provide any explicit
functionality for creating and changing DEXi models in R. Of course, models can still be created
and modified in R, but without integrity and consistency guarantees.
</p>


<h3>Fields</h3>


<dl>
<dt><code>name</code></dt><dd><p>character. Name of the model.</p>
</dd>
<dt><code>description</code></dt><dd><p>character. An optional textual description of the model.</p>
</dd>
<dt><code>linking</code></dt><dd><p>logical. Indicates whether or not the model uses linked attributes,
which are used in DEXi to represent hierarchies of attributes (i.e., directed acyclic graphs) rather than trees.</p>
</dd>
<dt><code>root</code></dt><dd><p><a href="#topic+DexiAttribute">DexiAttribute</a>. The virtual root of all subtrees/hierarchies of attributes in the model.</p>
</dd>
<dt><code>attributes</code></dt><dd><p>list. A list of all <a href="#topic+DexiAttribute">DexiAttribute</a>s that constitute the model.</p>
</dd>
<dt><code>att_names</code></dt><dd><p>character. A list of all attribute names, as defined in the original DEXi model. Notice that
these names may contain whitespace and other &quot;strange&quot; characters, and may not be unique.</p>
</dd>
<dt><code>att_ids</code></dt><dd><p>character. A list of unique attribute IDs generated by DEXiR from <code>att_names</code>
using <code><a href="base.html#topic+make.unique">make.unique</a></code>. When using the DEXiR package, it is strongly advised to refer to
attributes with their IDs rather than DEXi names.</p>
</dd>
<dt><code>basic</code></dt><dd><p>list. A list of all basic (input) <a href="#topic+DexiAttribute">DexiAttribute</a>s in the model.</p>
</dd>
<dt><code>aggregate</code></dt><dd><p>list. A list of all aggregate (output) <a href="#topic+DexiAttribute">DexiAttribute</a>s in the model.</p>
</dd>
<dt><code>links</code></dt><dd><p>list. A list of all linked <a href="#topic+DexiAttribute">DexiAttribute</a>s in the model.</p>
</dd>
<dt><code>basic_ids</code></dt><dd><p>character. A vector of all basic attributes' unique names.</p>
</dd>
<dt><code>aggregate_ids</code></dt><dd><p>character.  A vector of all aggregate attributes' unique names.</p>
</dd>
<dt><code>link_ids</code></dt><dd><p>character. A vector of all linked attributes' unique names.</p>
</dd>
<dt><code>alternatives</code></dt><dd><p>data.frame. A data frame representing decision alternatives contained
in the <code>.dxi</code> file.</p>
</dd>
</dl>


<h3>Methods</h3>


<dl>
<dt><code>alternative(name = "NewAlternative", ...)</code></dt><dd><p>Create a data frame containing data of one decision alternative.
<code>name</code>, character(1), represents the alternative's name. The arguments <code>...</code>
define the alternative's values to be put in the data frame.
Please see <code><a href="#topic+set_alternative">set_alternative</a></code> for the syntax of <code>...</code>.</p>
</dd>
<dt><code>as_character(alt, transpose = FALSE, structure = FALSE, round = NULL)</code></dt><dd><p>The argument <code>alt</code> is assumed to be a data frame containing data of one or more decision alternatives
with values represented by numeric vectors. <code>as_character(alt)</code> transforms the values of
<code>alt</code> into a more human-readable form using character strings.
Additionally, <code>transpose = TRUE</code> transposes the data frame,
so that rows correspod to attributes and columns to alternatives.
<code>structure = TRUE</code> additionally displays the tree structure of attributes;
the latter works only with <code>transpose = TRUE</code>.
<code>round</code> denotes the number of decimal digits for printing numeric values.</p>
</dd>
<dt><code>att_index(atts, use_id = TRUE)</code></dt><dd><p>Find the indices of attributes.
<code>atts</code> is a character vector of attribute IDs (when <code>use_id = TRUE</code>) or original DEXi attribute
names (when <code>use_id = FALSE</code>). Result: a numeric vector containing the set of indices.
Example: <code>Car$att_index(c("PRICE", "TECH.CHAR."))</code></p>
</dd>
<dt><code>att_stat()</code></dt><dd><p>Count the number of all attributes (including the virtual root),
as well as the number of basic, aggregate and linked attributes in the model.
Result: a list of the form list(all=..., basic=..., aggregate=..., link=...).</p>
</dd>
<dt><code>attrib(atts)</code></dt><dd><p>A general function for finding attributes in the model. <code>atts</code> is a vector or list of
<code>DexiAttribute</code>s, attribute indices (integer) or attribute IDs (character).
Result: a list of found <code>DexiAttribute</code>s (or <code>NA</code>s if not found).
Example: <code>Car$attrib(list(5, "PRICE", "TECH.CHAR."))</code></p>
</dd>
<dt><code>compare_alternatives(...)</code></dt><dd><p>Calls <code><a href="#topic+compare_alternatives">compare_alternatives</a>(.self, ...)</code> to carry out Comparison of Alternatives.
Please see <code><a href="#topic+compare_alternatives">compare_alternatives</a></code> for the description of <code>...</code> arguments.</p>
</dd>
<dt><code>convert(...)</code></dt><dd><p>Calls <code><a href="#topic+convert_alternatives">convert_alternatives</a>(.self, ...)</code> to convert decision alternatives' data.
Please see <code><a href="#topic+convert_alternatives">convert_alternatives</a></code> for the description of <code>...</code> arguments.</p>
</dd>
<dt><code>evaluate(...)</code></dt><dd><p>Calls <code><a href="#topic+evaluate">evaluate</a>(.self, ...)</code> to evaluate decision alternatives.
Please see <code><a href="#topic+evaluate">evaluate</a></code> for the description of <code>...</code> arguments.</p>
</dd>
<dt><code>first()</code></dt><dd><p>Return first non-virtual model attribute, i.e., first descendant of model$root.</p>
</dd>
<dt><code>initialize(name = "", description = "", root = NULL, linking = FALSE, ...)</code></dt><dd><p>Initialize a <code>DexiModel</code> object.</p>
</dd>
<dt><code>link_attributes()</code></dt><dd><p>Carries out the linking of attributes.
DEXi attributes that have the same names and value scales,
and satisfy some other constraints to prevent making cycles in the model,
are linked together so that they logically represent a single attribute.
In this way, a tree of attributes is conceptually turned in a hierarchy (directed acyclic graph).
If <code>linking = TRUE</code>, <code>link_attributes</code> is called by <code>setup()</code> after reading the model.</p>
</dd>
<dt><code>plus_minus(...)</code></dt><dd><p>Calls <code><a href="#topic+plus_minus">plus_minus</a>(.self, ...)</code> to carry out Plus-Minus Analysis.
Please see <code><a href="#topic+plus_minus">plus_minus</a></code> for the description of <code>...</code> arguments.</p>
</dd>
<dt><code>scale(atts)</code></dt><dd><p>Find attribute scales. <code>atts</code> is a vector of <code>DexiAttribute</code>s.
Result: a vector of the corresponding <code><a href="#topic+DexiScale">DexiScale</a></code>s (or <code>NA</code>s).</p>
</dd>
<dt><code>selective_explanation(...)</code></dt><dd><p>Calls <code><a href="#topic+selective_explanation">selective_explanation</a>(.self, ...)</code> to carry out Selective Explanation.
Please see <code><a href="#topic+selective_explanation">selective_explanation</a></code> for the description of <code>...</code> arguments.</p>
</dd>
<dt><code>setup()</code></dt><dd><p>Called by <code>initialize()</code> as the last step that establishes consistent internal data structures by
making unique attribute IDs, linking attributes (if required), making lists of attributes and their IDs,
and creating a data frame of alternatives.</p>
</dd>
<dt><code>verify()</code></dt><dd><p>Check the correctnes of a <code>DexiModel</code> object and its fields. Result: <code>error()</code> or <code>TRUE</code>.</p>
</dd>
</dl>


<h3>See Also</h3>

<p><code><a href="#topic+evaluate">evaluate</a></code>, <code><a href="#topic+set_alternative">set_alternative</a></code>, <code><a href="#topic+read_dexi">read_dexi()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Get ".dxi" file name
CarDxi &lt;- system.file("extdata", "Car.dxi", package = "DEXiR")

# Read DEXi model
Car &lt;- read_dexi(CarDxi)

# Print fields of Car
Car
Car$verify()
Car$name
Car$description
Car$linking
att_names(Car$attributes)
Car$att_names
Car$att_ids
Car$basic_ids
Car$aggregate_ids
Car$att_stat()
Car$scale(Car$aggregate)

# Find some attributes in the model
Car$first()
Car$attributes[[3]]
Car$attrib("PRICE")
Car$att_index("PRICE")

# Display alternatives loaded from "Car.dxi"
Car$alternatives
Car$as_character(Car$alternatives)
Car$as_character(Car$alternatives, transpose = TRUE)
Car$as_character(Car$alternatives, transpose = TRUE, structure = TRUE)

# Define and evaluate a decision alternative (some car)
alt &lt;- Car$alternative("MyCar",
         BUY.PRICE="low", MAINT.PRICE=2, X.PERS=3, X.DOORS=3, LUGGAGE="medium", SAFETY=2)
Car$evaluate(alt)
Car$as_character(Car$evaluate(alt))

# Employ the set-based evaluation (notice how the value of SAFETY propagates upwards to TECH.CHAR.)
alt &lt;- Car$alternative("MyCar",
         BUY.PRICE="low", MAINT.PRICE=2, X.PERS=3, X.DOORS=3, LUGGAGE="medium", SAFETY=c(2,3))
Car$evaluate(alt)
Car$as_character(Car$evaluate(alt))

# Analysis of alternatives
Car$selective_explanation(1)
Car$selective_explanation(alt)
Car$plus_minus(alt)
Car$compare_alternatives(alt)
Car$compare_alternatives(1, 2)
Car$compare_alternatives(1, alt)

</code></pre>

<hr>
<h2 id='DexiScale-class'>DexiScale</h2><span id='topic+DexiScale-class'></span><span id='topic+DexiScale'></span>

<h3>Description</h3>

<p><code>DexiScale</code> is a base RC class representing value scales in R.
</p>


<h3>Details</h3>

<p>A value scale defines the type and set of values that can be assigned to some <a href="#topic+DexiAttribute">DexiAttribute</a>.
<a href="#topic+DexiScale">DexiScale</a> is a base scale class that defines fields and methods common to all scales:
</p>

<ul>
<li><p> whether or not the scale is preferentially ordered (and in which direction),
</p>
</li>
<li><p> scale type (discrete or continuous),
</p>
</li>
<li><p> the number of scale elements, if countable,
</p>
</li>
<li><p> partition of scale elements in three preferential classes: <code>"bad"</code>, <code>"good"</code> and <code>"none"</code>,
</p>
</li>
<li><p> helper methods <code>value_index()</code> and <code>full_range()</code>.
</p>
</li></ul>

<p>DEXiR implements two other scale classes derived from <code>DexiScale</code>:
<a href="#topic+DexiContinuousScale">DexiContinuousScale</a> and <a href="#topic+DexiDiscreteScale">DexiDiscreteScale</a>.
</p>


<h3>Fields</h3>


<dl>
<dt><code>order</code></dt><dd><p>character. Preferential order of the scale.
Possible values: <code>"ascending"</code>, <code>"descending"</code> or <code>"none"</code>.</p>
</dd>
</dl>


<h3>Methods</h3>


<dl>
<dt><code>count()</code></dt><dd><p>Return the number of scale elements.
Equal to <code>NA</code> for <code>DexiScale</code>, <code>0</code> for <code>DexiContinuousScale</code>, and
equal to <code>nvals &gt;= 0</code> for <code>DexiDiscreteScale</code>.</p>
</dd>
<dt><code>equal(scl)</code></dt><dd><p>Check if this scale is equal to scale <code>scl</code>. Needed for attribute linking.</p>
</dd>
<dt><code>full_range()</code></dt><dd><p>Return the vector that represents the full range of values on this scale.
Equal to <code>NA</code> for <code>DexiScale</code> and <code>DexiContinuousScale</code>,
and <code>1 : scale$nvals</code> for <code>DexiDiscreteScale</code>.</p>
</dd>
<dt><code>initialize(order = EnumOrder, ...)</code></dt><dd><p>Initialize a <code>DexiScale</code> object.</p>
</dd>
<dt><code>is_continuous()</code></dt><dd><p>Logical: Is this scale continuos?</p>
</dd>
<dt><code>is_discrete()</code></dt><dd><p>Logical: Is this scale discrete?</p>
</dd>
<dt><code>to_string()</code></dt><dd><p>Return a string representation of this scale for printing.</p>
</dd>
<dt><code>value_index(value)</code></dt><dd><p>Find the index of <code>value</code> (character(1)) on this scale.
Equal to <code>NA</code> for <code>DexiScale</code> and <code>DexiContinuousScale</code>.
With <code>DexiDiscreteScale</code> objects, it returns a numeric index or <code>NA</code>
of <code>value</code> in <code>scale$values</code>.</p>
</dd>
<dt><code>value_quality(value)</code></dt><dd><p>Return the quality (preferential class) of <code>value</code> on this scale:
one of the strings <code>"bad"</code>, <code>"none"</code> or <code>"good"</code>.
Always <code>"none"</code> for <code>DexiScale</code> and scales with <code>order = "none"</code>.</p>
</dd>
<dt><code>verify()</code></dt><dd><p>Check the correctnes of this scale object and its fields.
Result: <code>error()</code> or <code>TRUE</code>.</p>
</dd>
</dl>

<hr>
<h2 id='DexiTabularFunction-class'>DexiTabularFunction</h2><span id='topic+DexiTabularFunction-class'></span><span id='topic+DexiTabularFunction'></span>

<h3>Description</h3>

<p><code>DexiTabularFunction</code> is a RC class, derived from <a href="#topic+DexiFunction">DexiFunction</a>.
Functions of this type aggregate attribute values according to <em>decision rules</em>,
defined in terms of a <em>decision table</em>.
</p>


<h3>Details</h3>

<p>A decision table contains as many decision rules as there are possible combinations of
input attributes' values. For instance, if some <code>attribute</code> has two inputs whose
discrete scales have three and four values, respectively (i.e., <code>attribute$dim() == c(3,4)</code>),
then the number of rules is equal to <code>prod(attribute$dim()) == 12</code>. Each rule defines the
value of <code>attribute</code> for one of the possible combinations of values of <code>attribute$inputs</code>.
Thus, a decision table can be interpreted as a lookup table that, given a vector
of values of <code>attribute$inputs</code> (i.e., function arguments) returns the corresponding
<code>attribute</code> value.
</p>
<p>Objects of class <code>DexiTabularFunction</code> store decision rules in <code>values</code>, a multi-dimensional
list that contains rule values. In most cases, a rule value is a single integer,
representing an ordinal number of some value from <code>attribute$scale</code>. In a general case, however,
a rule value can be an integer vector, representing a (sub)set of values from <code>attribute$scale</code>.
</p>


<h3>Fields</h3>


<dl>
<dt><code>attribute</code></dt><dd><p><a href="#topic+DexiAttribute">DexiAttribute</a>. The attribute this function is associated with.
Both the attribute and its inputs are required to be discrete (i.e., associated with
<code>DexiDiscreteScale</code>s).</p>
</dd>
<dt><code>values</code></dt><dd><p>A multi-dimensional list of rule values. The dimensions of the list are equal to
<code>attribute$dim()</code>, and the length of the list is <code>nvals() == prod(dim)</code>. The list
contains rule values that are in general value sets, i.e., integer vectors of value indices
w.r.t. <code>attribute$scale</code>.</p>
</dd>
<dt><code>args</code></dt><dd><p>A list of integer vectors, containing all possible combinations of values of <code>attribute$inputs</code>.
<code>args</code> and <code>values</code> are of the same length and ordered so that, for each <code>i</code>, <code>args[[i]]</code>
defines function arguments that map to <code>values[[i]]</code>).</p>
</dd>
</dl>


<h3>Methods</h3>


<dl>
<dt><code>evaluate(x)</code></dt><dd><p>A silent wrapper around <code>value(x)</code>; it returns <code>NULL</code> when
<code>value(x)</code> fails with an error.</p>
</dd>
<dt><code>nargs()</code></dt><dd><p>Return the number of function arguments.</p>
</dd>
<dt><code>nvals()</code></dt><dd><p>Return the function size (number of rules).</p>
</dd>
<dt><code>to_string()</code></dt><dd><p>Return a short informative string about the size and dimensions of <code>values</code>.</p>
</dd>
<dt><code>value(x)</code></dt><dd><p>Return the function value for arguments <code>x</code>, where arguments are
a numeric vector of length equal to <code>att$inputs</code>.
Additionally, arguments of a <code>DexiTabularFunctions$value()</code> must be integer numbers,
and the argument of <code>DexiDiscretizeFunctions$value()</code> must be a single number.</p>
</dd>
<dt><code>verify()</code></dt><dd><p>Check the correctnes of this function object and its fields.
Result: <code>error()</code> or <code>TRUE</code>.</p>
</dd>
</dl>


<h3>See Also</h3>

<p><code><a href="#topic+dexi_index">dexi_index()</a></code>, <code><a href="#topic+dexi_table">dexi_table()</a></code>, <code><a href="#topic+make_args">make_args()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load "Car.dxi"
CarDxi &lt;- system.file("extdata", "Car.dxi", package = "DEXiR")
Car &lt;- read_dexi(CarDxi)

# For example, consider the function of attribute CAR
fnc &lt;- Car$attrib("CAR")$funct

# Print fields and basic properties of fnc
fnc$verify()
att_names(fnc$attribute)
fnc$values
fnc$args
fnc$nargs()
fnc$nvals()
fnc$to_string()

# Try some args to value mappings
fnc$evaluate(c(1, 1))
fnc$evaluate(c(2, 2))
fnc$evaluate(c(3, 4))
fnc$evaluate(c(4, 4)) # the first argument is out of bounds, returns NULL

</code></pre>

<hr>
<h2 id='distr_to_set'>distr_to_set</h2><span id='topic+distr_to_set'></span>

<h3>Description</h3>

<p>Convert a DEXi value distribution to a DEXi value set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distr_to_set(distr, eps = .Machine$double.eps)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="distr_to_set_+3A_distr">distr</code></td>
<td>
<p>An S3 object of class <code>distribution</code>.</p>
</td></tr>
<tr><td><code id="distr_to_set_+3A_eps">eps</code></td>
<td>
<p>A numeric value representing the threshold value of <code class="reqn">p</code> (see <a href="#topic+DEXiR-package">DEXiR-package</a>)
above which the corresponding elements are considered set members.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector determined as <code>which(distr &gt; eps)</code>. Notice that <code>distr_to_set</code>
is generally a lossy conversion, so that multiple different <code>distr</code>s are converted to the same sets.
</p>


<h3>See Also</h3>

<p><a href="#topic+DEXiR-package">DEXiR-package</a>, <a href="#topic+distribution">distribution</a>, <code><a href="#topic+set_to_distr">set_to_distr()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>distr_to_set(distribution(0.2, 0, 0.5, 0.3))
distr_to_set(distribution(0.1, 0, 0.7, 0.2))
distr_to_set(distribution(0.1, 0, 0.7, 0.2), eps = 0.5)

</code></pre>

<hr>
<h2 id='distribution'>distribution</h2><span id='topic+distribution'></span>

<h3>Description</h3>

<p>Create an object as a S3 class <code>distribution</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distribution(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="distribution_+3A_...">...</code></td>
<td>
<p>Expected a comma-separated list of numeric values.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object, call it <code>obj</code>, such that <code>all(obj == c(...))</code> and
<code>class(obj) == "distribution"</code>.
</p>


<h3>See Also</h3>

<p><a href="#topic+DEXiR-package">DEXiR-package</a>, <code><a href="#topic+set_to_distr">set_to_distr()</a></code>, <code><a href="#topic+distr_to_set">distr_to_set()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>distribution(0.1, 0.2, 0.7)

</code></pre>

<hr>
<h2 id='equal_scales'>equal_scales</h2><span id='topic+equal_scales'></span>

<h3>Description</h3>

<p>Check if two scales are equal. <code>NULL</code> arguments, indicating undefined scales, are allowed.
Two <code>NULL</code> scales are considered equal.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>equal_scales(scl1, scl2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="equal_scales_+3A_scl1">scl1</code></td>
<td>
<p>A <a href="#topic+DexiScale">DexiScale</a> (or derived) object, or <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="equal_scales_+3A_scl2">scl2</code></td>
<td>
<p>A <a href="#topic+DexiScale">DexiScale</a> (or derived) object, or <code>NULL</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>logical(1)</code>.
</p>

<hr>
<h2 id='evaluate'>evaluate</h2><span id='topic+evaluate'></span>

<h3>Description</h3>

<p>Evaluates decision alternatives. Essentially, this is a bottom-up aggregation method:
starting with basic attributes (or <code>prune</code>d aggregate attributes), values of each
alternative are gradually aggregated towards the <code>root</code> attribute,
according to <code><a href="#topic+evaluation_order">evaluation_order()</a></code>. The aggregation
at each individual <a href="#topic+DexiAttribute">DexiAttribute</a> is governed by the corresponding <code>DexiAttribute$funct</code>.
When alternative values are sets or distributions (see <a href="#topic+DEXiR-package">DEXiR-package</a>),
then <code><a href="#topic+evaluate">evaluate()</a></code> tries all possible combinations of values of the descendant attributes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>evaluate(
  model,
  alternatives = model$alternatives,
  root = model$root,
  method = EnumEvalMethod,
  bounding = FALSE,
  prune = list(),
  norm = NULL,
  and = NULL,
  or = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="evaluate_+3A_model">model</code></td>
<td>
<p><a href="#topic+DexiModel">DexiModel</a>.</p>
</td></tr>
<tr><td><code id="evaluate_+3A_alternatives">alternatives</code></td>
<td>
<p>A data frame containing data of one or more decision alternatives.</p>
</td></tr>
<tr><td><code id="evaluate_+3A_root">root</code></td>
<td>
<p><a href="#topic+DexiAttribute">DexiAttribute</a>. Default: <code>model$root</code>.</p>
</td></tr>
<tr><td><code id="evaluate_+3A_method">method</code></td>
<td>
<p>One of: <code>"set"</code> (default), <code>"prob"</code>, <code>"fuzzy"</code> or <code>"fuzzynorm"</code>.</p>
</td></tr>
<tr><td><code id="evaluate_+3A_bounding">bounding</code></td>
<td>
<p><code>logical(1)</code>. When <code>TRUE</code>, evaluation results are additionally subjected to
<code><a href="#topic+bounded_scale_value">bounded_scale_value()</a></code> to keep them in the bounds set up by the corresponding scale.</p>
</td></tr>
<tr><td><code id="evaluate_+3A_prune">prune</code></td>
<td>
<p><code>character()</code>, containing IDs of aggregate attributes that should be treated as
evaluation inputs (rather than basic attributes).</p>
</td></tr>
<tr><td><code id="evaluate_+3A_norm">norm</code></td>
<td>
<p>Some normalization function of the form <code style="white-space: pre;">&#8288;function(num_vector)&#8288;</code>, or <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="evaluate_+3A_and">and</code></td>
<td>
<p>Some conjunctive aggregation function of the form <code style="white-space: pre;">&#8288;function(num_vector)&#8288;</code>, or <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="evaluate_+3A_or">or</code></td>
<td>
<p>Some disjunctive aggregation function of the form <code style="white-space: pre;">&#8288;function(num_vector)&#8288;</code>, or <code>NULL</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code><a href="#topic+evaluate">evaluate()</a></code> implements four aggregation methods:
<code>"set"</code>, <code>"prob"</code>, <code>"fuzzy"</code> and <code>"fuzzynorm"</code>.
</p>
<p>The <code>"set"</code> method interprets DEXi values as sets. The output value assigned to some <code>attribute</code> is
composed of the union of all <code>attribute$funct</code> evaluations for all possible combinations of values of
<code>attribute$inputs</code>.
</p>
<p>The remaining three methods interpret DEXi values as value distributions. They follow the same algorithm,
but use different functions (see <code><a href="#topic+evaluation_parameters">evaluation_parameters()</a></code>) in three algorithm steps:
normalization, and conjunctive and disjunctive aggregation. All values distributions involved in
calculations are normalized by the function <code>norm()</code>. All combinations of <code>attribute$input</code>
values are individually evaluated by the corresponding tabular function <code>attribute$funct</code>.
The value <code class="reqn">p</code> of each set of <code>attribute$funct</code> arguments is determined by the conjunctive
aggregation function <code>and()</code> over <code class="reqn">p</code>'s of individual arguments.
Finally, the <code class="reqn">p</code> of some output value <code>val</code> is determined by the
disjunctive aggregation function <code>or()</code>, applied on the <code class="reqn">p</code>'s of all partial evaluations that
map to <code>val</code>.
</p>
<p>For the mathematical background and more details about aggregation in DEX, please see
(Trdin, Bohanec, 2018). For default normalization and aggregation functions,
see <code><a href="#topic+normalize_function">normalize_function()</a></code>, <code><a href="#topic+and_function">and_function()</a></code> and <code><a href="#topic+or_function">or_function()</a></code>.
</p>


<h3>Value</h3>

<p>A data frame containing both input and output (evaluated) values of <code>alternatives</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+evaluation_parameters">evaluation_parameters()</a></code>, <code><a href="#topic+normalize_function">normalize_function()</a></code>,
<code><a href="#topic+norm_none">norm_none()</a></code>, <code><a href="#topic+norm_max">norm_max()</a></code>, <code><a href="#topic+norm_sum">norm_sum()</a></code>, <code><a href="#topic+and_function">and_function()</a></code>, <code><a href="#topic+or_function">or_function()</a></code>, <code><a href="#topic+bounded_scale_value">bounded_scale_value()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load "Car.dxi"
CarDxi &lt;- system.file("extdata", "Car.dxi", package = "DEXiR")
Car &lt;- read_dexi(CarDxi)

alt &lt;- Car$alternative("MyCar_set",
         BUY.PRICE="low", MAINT.PRICE=2, X.PERS="more", X.DOORS="4", LUGGAGE=2, SAFETY="medium")
Car$evaluate(alt)

# Try the set-based evaluation using the default "set" method
alt &lt;- Car$alternative("MyCar2",
       BUY.PRICE="low", MAINT.PRICE="*", X.PERS="more", X.DOORS="4", LUGGAGE=2, SAFETY=2)
Car$evaluate(alt)

# Use value distributions and try the methods "prob", "fuzzy" and "fuzzynorm"
alt &lt;- Car$alternative("MyCar_distr",
       BUY.PRICE="low", MAINT.PRICE=distribution(0.1, 0.6, 0.3),
       X.PERS="more", X.DOORS="4", LUGGAGE=2, SAFETY=2)
Car$evaluate(alt, method = "prob")
Car$evaluate(alt, method = "fuzzy")
Car$evaluate(alt, method = "fuzzynorm")

</code></pre>

<hr>
<h2 id='evaluate_attribute'>evaluate_attribute</h2><span id='topic+evaluate_attribute'></span>

<h3>Description</h3>

<p>Evaluate <code>alternative</code> for a sequence of <code>attribute</code> values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>evaluate_attribute(model, attribute, alternative, seq = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="evaluate_attribute_+3A_model">model</code></td>
<td>
<p>A <a href="#topic+DexiModel">DexiModel</a>.</p>
</td></tr>
<tr><td><code id="evaluate_attribute_+3A_attribute">attribute</code></td>
<td>
<p>A <a href="#topic+DexiAttribute">DexiAttribute</a> with an assigned discrete or continuous scale.</p>
</td></tr>
<tr><td><code id="evaluate_attribute_+3A_alternative">alternative</code></td>
<td>
<p>A <code>data.frame</code> containing a single alternative.</p>
</td></tr>
<tr><td><code id="evaluate_attribute_+3A_seq">seq</code></td>
<td>
<p>A sequence of <code>attribute</code> numeric values for which to evaluate <code>alternative</code>.
For discrete scales: Must be a sequence of integers. Defaults to <code>attribute$scale$full_range()</code>.
For continuous scales: <code>seq</code> is required.</p>
</td></tr>
<tr><td><code id="evaluate_attribute_+3A_...">...</code></td>
<td>
<p>Optional parameters passed to <code><a href="#topic+evaluate">evaluate()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of evaluated alternatives for consecutive <code>attribute</code> values from <code>seq</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+evaluate">evaluate()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load "Car.dxi"
CarDxi &lt;- system.file("extdata", "Car.dxi", package = "DEXiR")
Car &lt;- read_dexi(CarDxi)

alt &lt;- Car$alternative("MyCar",
         BUY.PRICE="low", MAINT.PRICE=2, X.PERS="more", X.DOORS="4", LUGGAGE=2, SAFETY="medium")
safety &lt;- Car$attrib("SAFETY")
# Evaluate alt for all values of att
evaluate_attribute(Car, safety, alt)
# Returns a list of three alternatives for values SAFETY=c("small", "medium", "high")
</code></pre>

<hr>
<h2 id='evaluate_attributes'>evaluate_attributes</h2><span id='topic+evaluate_attributes'></span>

<h3>Description</h3>

<p>Apply <code>evaluate_attribute()</code> for all discrete <code>attributes</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>evaluate_attributes(model, alternative, attributes = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="evaluate_attributes_+3A_model">model</code></td>
<td>
<p>A <a href="#topic+DexiModel">DexiModel</a> object. Required.</p>
</td></tr>
<tr><td><code id="evaluate_attributes_+3A_alternative">alternative</code></td>
<td>
<p>A <code>data.frame</code> containing a single alternative.</p>
</td></tr>
<tr><td><code id="evaluate_attributes_+3A_attributes">attributes</code></td>
<td>
<p>List of attributes or vector of attribute names, ID's or indices.
Default: All basic attributes of <code>model</code>.</p>
</td></tr>
<tr><td><code id="evaluate_attributes_+3A_...">...</code></td>
<td>
<p>Optional parameters passed to <code><a href="#topic+evaluate_attribute">evaluate_attribute()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of <code><a href="#topic+evaluate_attribute">evaluate_attribute()</a></code> results for each <code>attribute</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+evaluate_attribute">evaluate_attribute()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load "Car.dxi"
CarDxi &lt;- system.file("extdata", "Car.dxi", package = "DEXiR")
Car &lt;- read_dexi(CarDxi)

alt &lt;- Car$alternative("MyCar",
         BUY.PRICE="low", MAINT.PRICE=2, X.PERS="more", X.DOORS="4", LUGGAGE=2, SAFETY="medium")
safety &lt;- Car$attrib("SAFETY")
# Perform evaluate_attribute() for all basic attributes of CarDxi
evaluate_attributes(Car, alt)
# Returns a list of evaluate_attribute() results corresponding to all basic attributes,
# indexed by attribute id
</code></pre>

<hr>
<h2 id='evaluation_order'>evaluation_order</h2><span id='topic+evaluation_order'></span>

<h3>Description</h3>

<p>Determine the evaluation order of attributes. Interpreted as a sequence, the order guarantees
that whenever some attribute is reached as a candidate for evaluation,
all the previous attributes have been already evaluated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>evaluation_order(att, prune = list())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="evaluation_order_+3A_att">att</code></td>
<td>
<p><a href="#topic+DexiAttribute">DexiAttribute</a>. The starting point of evaluation.</p>
</td></tr>
<tr><td><code id="evaluation_order_+3A_prune">prune</code></td>
<td>
<p>A character vector. May contain IDs of aggregate attributes at which the evaluation should
stop, treating them as if they were basic attributes.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector of attribute IDs.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+evaluate">evaluate()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load "Car.dxi"
CarDxi &lt;- system.file("extdata", "Car.dxi", package = "DEXiR")
Car &lt;- read_dexi(CarDxi)

# Full evaluation order, starting with Car$root and without pruning
evaluation_order(Car$root)

# Evaluation order, starting with the TECH.CHAR. attribute
evaluation_order(Car$attrib("TECH.CHAR."))

# evaluation order, starting with Car$root and pruned at "PRICE"
evaluation_order(Car$root, prune = "PRICE")

</code></pre>

<hr>
<h2 id='evaluation_parameters'>evaluation_parameters</h2><span id='topic+evaluation_parameters'></span>

<h3>Description</h3>

<p>Make a list containing parameters of DEXi evaluation. The parameters determine which method
and normalization/aggregation functions should be used by <code><a href="#topic+evaluate">evaluate()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>evaluation_parameters(
  method = EnumEvalMethod,
  norm = NULL,
  and = NULL,
  or = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="evaluation_parameters_+3A_method">method</code></td>
<td>
<p>One of: <code>"set"</code> (default), <code>"prob"</code>, <code>"fuzzy"</code> or <code>"fuzzynorm"</code>.</p>
</td></tr>
<tr><td><code id="evaluation_parameters_+3A_norm">norm</code></td>
<td>
<p>Some normalization function of the form <code style="white-space: pre;">&#8288;function(num_vector)&#8288;</code>, or <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="evaluation_parameters_+3A_and">and</code></td>
<td>
<p>Some conjunctive aggregation function of the form <code style="white-space: pre;">&#8288;function(num_vector)&#8288;</code>, or <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="evaluation_parameters_+3A_or">or</code></td>
<td>
<p>Some disjunctive aggregation function of the form <code style="white-space: pre;">&#8288;function(num_vector)&#8288;</code>, or <code>NULL</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>list(method, norm, and, or)</code>.
For <code>NULL</code> <code>norm</code>, <code>and</code>, and <code>or</code> arguments, defaults are
taken depending on the <code>method</code>.
</p>


<h3>See Also</h3>

<p><a href="#topic+evaluate">evaluate</a>, <code><a href="#topic+normalize_function">normalize_function()</a></code>,
<code><a href="#topic+norm_none">norm_none()</a></code>, <code><a href="#topic+norm_max">norm_max()</a></code>, <code><a href="#topic+norm_sum">norm_sum()</a></code>, <code><a href="#topic+and_function">and_function()</a></code>, <code><a href="#topic+or_function">or_function()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>evaluation_parameters("prob", norm = norm_none)

</code></pre>

<hr>
<h2 id='expand_value_to_points'>expand_value_to_points</h2><span id='topic+expand_value_to_points'></span>

<h3>Description</h3>

<p>Expand a DEXi <code>value</code> to a sequence of individual elements (points).
Particularly aimed for graphic functions that display DEXi values
with dots of different sizes and colors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expand_value_to_points(value, scale, colors = c("red", "black", "green"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="expand_value_to_points_+3A_value">value</code></td>
<td>
<p>A DEXi value: a single value (integer or float), a set (integer vector) or a <a href="#topic+distribution">distribution</a>.</p>
</td></tr>
<tr><td><code id="expand_value_to_points_+3A_scale">scale</code></td>
<td>
<p>A <a href="#topic+DexiScale">DexiScale</a> object.</p>
</td></tr>
<tr><td><code id="expand_value_to_points_+3A_colors">colors</code></td>
<td>
<p><code>numeric(3)</code> representing colors to display &quot;bad&quot;, &quot;neutral&quot; and &quot;good&quot; values, respectively.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code> consisting of:
</p>

<dl>
<dt><code>points</code></dt><dd><p><code>numeric()</code>. <code>value</code> expanded to a vector of ordinal values.</p>
</dd>
<dt><code>sizes</code></dt><dd><p><code>numeric()</code>. Numeric values assigned to each corresponding ordinal values.
Normally <code>1.0</code> for set elements and in the <code style="white-space: pre;">&#8288;(0,1]&#8288;</code> interval for distribution membership values.</p>
</dd>
<dt><code>colors</code></dt><dd><p>Colors assigned to corresponding value qualities.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>scl &lt;- DexiDiscreteScale(values = c("L", "M", "H"))

expand_value_to_points(c(1, 3), scl)
# points sizes colors
# 1      1     1    red
# 2      3     1  green

expand_value_to_points(distribution(0.1, 0, 0.9), scl)
# points sizes colors
# 1      1   0.1    red
# 2      3   0.9  green

</code></pre>

<hr>
<h2 id='export_alternatives'>export_alternatives</h2><span id='topic+export_alternatives'></span>

<h3>Description</h3>

<p>Convert <code>alternatives</code>' data to a data frame formatted so that it can be
imported by DEXi/DEXiWin software.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>export_alternatives(model, alternatives = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="export_alternatives_+3A_model">model</code></td>
<td>
<p>A <a href="#topic+DexiModel">DexiModel</a> object. Required.</p>
</td></tr>
<tr><td><code id="export_alternatives_+3A_alternatives">alternatives</code></td>
<td>
<p>A <code>data.frame</code> of alternatives (normally an output of <code><a href="#topic+evaluate">evaluate()</a></code>) or
indices to <code>model$alternatives</code>. The default value <code>NULL</code> selects <code>model$alternatives</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In order to import the output of <code>export_alternative()</code> in DEXi/DEXiWin software,
proper <code>Import/Export</code> settings must be ensured in these programs:
</p>

<dl>
<dt>DEXi</dt><dd><p>Option values: &quot;base 1&quot;, Attributes: &quot;all&quot;, Orientation: &quot;normal&quot;,
Indent: &quot;indent&quot;.</p>
</dd>
<dt>DEXiWin</dt><dd><p>Option values: &quot;Base 1&quot;, Attributes: &quot;All&quot;,
Orientation: &quot;Attributes \ Alternatives&quot;,
Indent: &quot;Indent tree levels&quot;,
CSV Format: &quot;Invariant&quot; when <code>format = "csv"</code> and &quot;Local&quot; when <code>format = "csv2"</code>.</p>
</dd>
</dl>

<p>If <code>alternatives</code> contain value distributions,
they can be imported only by DEXiWin and not by DEXi.
</p>


<h3>Value</h3>

<p>A data frame consisting of character strings that can be further written out by <code><a href="#topic+write_alternatives">write_alternatives()</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+write_alternatives">write_alternatives()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load "Car.dxi"
CarDxi &lt;- system.file("extdata", "Car.dxi", package = "DEXiR")
Car &lt;- read_dexi(CarDxi)

export_alternatives(Car)    # export both alternatives from Car
export_alternatives(Car, 1) # export only the first alternative

</code></pre>

<hr>
<h2 id='export_dexi_value'>export_dexi_value</h2><span id='topic+export_dexi_value'></span>

<h3>Description</h3>

<p>Convert a DEXi <code>value</code> to a character string that is understood by DEXi/DEXiWin software
while importing data about alternatives.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>export_dexi_value(value)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="export_dexi_value_+3A_value">value</code></td>
<td>
<p>A DEXi value: <code>NA</code>, <code>NULL</code>, a single number, integer vector (a set) or a distribution.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A string representation of <code>value</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>export_dexi_value(NULL)                            # "&lt;undefined&gt;"
export_dexi_value(NA)                              # "&lt;undefined&gt;"
export_dexi_value(1)                               # "1"
export_dexi_value(3.2)                             # "3.2"
export_dexi_value(c(1, 3, 5))                      # "1;3;5"
export_dexi_value(distribution(0.1, 0.9))          # "1/0.1;2/0.9"
export_dexi_value(distribution(0, 0.1, 0, 0.9, 0)) # "2/0.1;4/0.9"

</code></pre>

<hr>
<h2 id='flat_text'>flat_text</h2><span id='topic+flat_text'></span>

<h3>Description</h3>

<p>&quot;Flatten&quot; the function argument using <code>c(value)</code>, concatenate the elements and separate them by
a single space.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>flat_text(value)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="flat_text_+3A_value">value</code></td>
<td>
<p>Any object that can occur as an argument of <code><a href="base.html#topic+c">c()</a></code> and <code><a href="base.html#topic+as.character">as.character()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>character(1)</code>.
</p>

<hr>
<h2 id='ggplot_parallel'>ggplot_parallel</h2><span id='topic+ggplot_parallel'></span>

<h3>Description</h3>

<p>Makes a basic <code>ggplot2</code> chart for displaying DEXi alternatives using parallel axes.
Generally, axes are uniformly scaled to the <code style="white-space: pre;">&#8288;[0,1]&#8288;</code> interval.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ggplot_parallel(
  model,
  alternatives = NULL,
  attids = NULL,
  aggregate = c("minmax", "min", "max", "mean", "none"),
  name = "name",
  shift = 0.01
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ggplot_parallel_+3A_model">model</code></td>
<td>
<p>A <a href="#topic+DexiModel">DexiModel</a> object. Required.</p>
</td></tr>
<tr><td><code id="ggplot_parallel_+3A_alternatives">alternatives</code></td>
<td>
<p>A <code>data.frame</code> of alternatives (normally an output of <code><a href="#topic+evaluate">evaluate()</a></code>) or
indices to <code>model$alternatives</code>. The default value <code>NULL</code> selects the whole <code>model$alternatives</code>.</p>
</td></tr>
<tr><td><code id="ggplot_parallel_+3A_attids">attids</code></td>
<td>
<p><code>character()</code>. A character vector of <a href="#topic+DexiAttribute">DexiAttribute</a> IDs to be included in the result.
Default: all <code>model</code> attributes.</p>
</td></tr>
<tr><td><code id="ggplot_parallel_+3A_aggregate">aggregate</code></td>
<td>
<p>One of <code>"minmax"</code>, <code>"min"</code>, <code>"max"</code>, <code>"mean"</code> or &quot;<code>none</code>&quot;. Determines how
to aggregate <code>alternatives</code>' values that are represented by sets or distributions.</p>
</td></tr>
<tr><td><code id="ggplot_parallel_+3A_name">name</code></td>
<td>
<p><code>character(1)</code>, The name of the column in <code>alternatives</code> that contains
alternatives' names. Default: <code>"name"</code>.</p>
</td></tr>
<tr><td><code id="ggplot_parallel_+3A_shift">shift</code></td>
<td>
<p><code>numeric(1)</code>. Used to &quot;shift&quot; numeric values by a small amount to avoid overlapping
lines in charts. Default: <code>0.01</code>.
You may want to experiment with charts to determine the right value,</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Uses <code><a href="GGally.html#topic+ggparcoord">GGally::ggparcoord()</a></code> and requires package &quot;GGally&quot; to be installed.
Data presented in the chart is prepared by <code><a href="#topic+scale_alternatives">scale_alternatives()</a></code>.
</p>


<h3>Value</h3>

<p>A basic 'ggplot2' chart. Generally, this chart needs to be further enhanced
by graph layers, such as themes, labels, <code>geom_points()</code> and <code>geom_line()</code>.
See <code><a href="#topic+plotalt_parallel">plotalt_parallel()</a></code> that already provides some such layers.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+scale_alternatives">scale_alternatives()</a></code>, <code><a href="#topic+plotalt_parallel">plotalt_parallel()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (requireNamespace("GGally", quietly = TRUE)) {

# Load "Car.dxi"
CarDxi &lt;- system.file("extdata", "Car.dxi", package = "DEXiR")
Car &lt;- read_dexi(CarDxi)

# Plot all Car$alternatives with points and lines
ggplot_parallel(Car) + ggplot2::geom_line(linewidth = 2) + ggplot2::geom_point(size = 3)
}
</code></pre>

<hr>
<h2 id='has_bad'>has_bad</h2><span id='topic+has_bad'></span>

<h3>Description</h3>

<p>has_bad
</p>


<h3>Usage</h3>

<pre><code class='language-R'>has_bad(value, scale)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="has_bad_+3A_value">value</code></td>
<td>
<p>A DEXi value.</p>
</td></tr>
<tr><td><code id="has_bad_+3A_scale">scale</code></td>
<td>
<p>A <a href="#topic+DexiScale">DexiScale</a> or derived object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>logical(1)</code>. Whether or not <code>value_qualities(value, scale)</code> contains <code>"bad"</code>.
</p>

<hr>
<h2 id='has_good'>has_good</h2><span id='topic+has_good'></span>

<h3>Description</h3>

<p>has_good
</p>


<h3>Usage</h3>

<pre><code class='language-R'>has_good(value, scale)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="has_good_+3A_value">value</code></td>
<td>
<p>A DEXi value.</p>
</td></tr>
<tr><td><code id="has_good_+3A_scale">scale</code></td>
<td>
<p>A <a href="#topic+DexiScale">DexiScale</a> or derived object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>logical(1)</code>. Whether or not <code style="white-space: pre;">&#8288;value_qualities(value, scale) contains &#8288;</code>&quot;good&quot;'.
</p>

<hr>
<h2 id='has_none'>has_none</h2><span id='topic+has_none'></span>

<h3>Description</h3>

<p>has_none
</p>


<h3>Usage</h3>

<pre><code class='language-R'>has_none(value, scale)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="has_none_+3A_value">value</code></td>
<td>
<p>A DEXi value.</p>
</td></tr>
<tr><td><code id="has_none_+3A_scale">scale</code></td>
<td>
<p>A <a href="#topic+DexiScale">DexiScale</a> or derived object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>logical(1)</code>. Whether or not <code>value_qualities(value, scale)</code> contains <code>"none"</code>.
</p>

<hr>
<h2 id='has_quality'>has_quality</h2><span id='topic+has_quality'></span>

<h3>Description</h3>

<p>has_quality
</p>


<h3>Usage</h3>

<pre><code class='language-R'>has_quality(quality = EnumQuality, value, scale)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="has_quality_+3A_quality">quality</code></td>
<td>
<p>A character string from <code>EnumQuality</code>.</p>
</td></tr>
<tr><td><code id="has_quality_+3A_value">value</code></td>
<td>
<p>A DEXi value.</p>
</td></tr>
<tr><td><code id="has_quality_+3A_scale">scale</code></td>
<td>
<p>A <a href="#topic+DexiScale">DexiScale</a> or derived object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>logical(1)</code>. Whether or not <code>value_qualities(value, scale)</code> contains <code>quality</code>.
</p>

<hr>
<h2 id='is_distribution'>is_distribution</h2><span id='topic+is_distribution'></span>

<h3>Description</h3>

<p>Checks whether <code>value</code> is of <code>DexDistributionClass</code> or not.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_distribution(value)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is_distribution_+3A_value">value</code></td>
<td>
<p>Any value or object to be checked.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>logical(1)</code>. Returns <code>TRUE</code> if <code>value</code> is distribution.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>is_distribution(NULL)
is_distribution(3)
is_distribution("text")
is_distribution(c(1,2,3))
is_distribution(distribution(1,0,2))

</code></pre>

<hr>
<h2 id='is_in_range'>is_in_range</h2><span id='topic+is_in_range'></span>

<h3>Description</h3>

<p>Check whether or not <code>x</code> lies the specified range.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_in_range(x, lb, hb, lassoc = c("up", "down"), hassoc = c("down", "up"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is_in_range_+3A_x">x</code></td>
<td>
<p>Any object type, but using a non-numeric argument always returns <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="is_in_range_+3A_lb">lb</code></td>
<td>
<p><code>numeric(1)</code>. Lower bound of the interval.</p>
</td></tr>
<tr><td><code id="is_in_range_+3A_hb">hb</code></td>
<td>
<p><code>numeric(1)</code>. Ipper bound of the interval.</p>
</td></tr>
<tr><td><code id="is_in_range_+3A_lassoc">lassoc</code></td>
<td>
<p><code>"up"</code> or <code>"down"</code>, indicating whether <code>lb</code> is included
in the <code style="white-space: pre;">&#8288;[lb:hb]&#8288;</code> interval (<code>"up"</code>) or not (<code>"down"</code>). The default is <code>"up"</code>.</p>
</td></tr>
<tr><td><code id="is_in_range_+3A_hassoc">hassoc</code></td>
<td>
<p><code>"up"</code> or <code>"down"</code>, indicating whether <code>hb</code> is included
in the <code style="white-space: pre;">&#8288;[lb:hb]&#8288;</code> interval (<code>"down"</code>) or not (<code>"up"</code>). The default is <code>"down"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>logical(1)</code>, indicating whether or not <code>x</code> lies in the interval <code style="white-space: pre;">&#8288;[lb:hb]&#8288;</code>
according to function arguments.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>is_in_range(3, 2, 5)
is_in_range(7, 2, 5)
is_in_range(3, 3, 5)
is_in_range(3, 3, 5, lassoc = "down")

</code></pre>

<hr>
<h2 id='lin_map'>lin_map</h2><span id='topic+lin_map'></span>

<h3>Description</h3>

<p>Map value <code>x</code> linearly from interval <code style="white-space: pre;">&#8288;[imin:imax]&#8288;</code> to <code style="white-space: pre;">&#8288;[omax:omax]&#8288;</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lin_map(x, imin, imax, omin = 0, omax = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lin_map_+3A_x">x</code></td>
<td>
<p><code>numeric()</code>. Value(s) to be mapped.</p>
</td></tr>
<tr><td><code id="lin_map_+3A_imin">imin</code></td>
<td>
<p><code>numeric()</code>. Lower bound of the input range.</p>
</td></tr>
<tr><td><code id="lin_map_+3A_imax">imax</code></td>
<td>
<p><code>numeric()</code>. Upper bound of the input range.</p>
</td></tr>
<tr><td><code id="lin_map_+3A_omin">omin</code></td>
<td>
<p><code>numeric()</code>. Lower bound of the output range.</p>
</td></tr>
<tr><td><code id="lin_map_+3A_omax">omax</code></td>
<td>
<p><code>numeric()</code>. Upper bound of the output range.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>numeric()</code>. Mapped value(s).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>lin_map(2, 1, 3) # 0.5
</code></pre>

<hr>
<h2 id='make_args'>make_args</h2><span id='topic+make_args'></span>

<h3>Description</h3>

<p>Make a list of all possible combinations of values in a decision space defined by <code>dim</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_args(dim)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="make_args_+3A_dim">dim</code></td>
<td>
<p>A numeric vector containing upper bounds of the corresponding decision space dimensions.
For example, <code>dim = c(3, 4)</code> defines the space of <code>3 * 4 == 12</code> combinations.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing all possible value combinations. List elements are numeric vectors
of length equal to <code>length(dim)</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>make_args(c(3, 4))

</code></pre>

<hr>
<h2 id='norm_max'>norm_max</h2><span id='topic+norm_max'></span>

<h3>Description</h3>

<p>Normalize <code>values</code> so that <code>max(values) == max</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>norm_max(values, max = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="norm_max_+3A_values">values</code></td>
<td>
<p>A numeric vector.</p>
</td></tr>
<tr><td><code id="norm_max_+3A_max">max</code></td>
<td>
<p><code>numeric(1)</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>values</code> normalized so that <code>max(result) == max</code>.
Returns unchanged <code>values</code> when <code>max(values) == 0</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+norm_none">norm_none()</a></code>, <code><a href="#topic+norm_sum">norm_sum()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>norm_max(c(0, 0.5, 0.7))

</code></pre>

<hr>
<h2 id='norm_none'>norm_none</h2><span id='topic+norm_none'></span>

<h3>Description</h3>

<p>A &quot;do nothing&quot; normalization function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>norm_none(values)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="norm_none_+3A_values">values</code></td>
<td>
<p>A numeric vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns unchanged <code>values</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+norm_max">norm_max()</a></code>, <code><a href="#topic+norm_sum">norm_sum()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>norm_none(c(0, 0.5, 0.7))

</code></pre>

<hr>
<h2 id='norm_sum'>norm_sum</h2><span id='topic+norm_sum'></span>

<h3>Description</h3>

<p>Normalize <code>values</code> so that <code>sum(values) == sum</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>norm_sum(values, sum = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="norm_sum_+3A_values">values</code></td>
<td>
<p>A numeric vector.</p>
</td></tr>
<tr><td><code id="norm_sum_+3A_sum">sum</code></td>
<td>
<p><code>numeric(1)</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>values</code> normalized so that <code>sum(result) == sum</code>.
Returns unchanged <code>values</code> when <code>sum(values) == 0</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+norm_none">norm_none()</a></code>, <code><a href="#topic+norm_max">norm_max()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>norm_sum(c(0, 0.5, 0.7))

</code></pre>

<hr>
<h2 id='normalize_function'>normalize_function</h2><span id='topic+normalize_function'></span>

<h3>Description</h3>

<p>Determine the function to be used in the normalization step of <code><a href="#topic+evaluate">evaluate()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>normalize_function(method = EnumEvalMethod, norm = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="normalize_function_+3A_method">method</code></td>
<td>
<p>One of: <code>"set"</code> (default), <code>"prob"</code>, <code>"fuzzy"</code> or <code>"fuzzynorm"</code>.</p>
</td></tr>
<tr><td><code id="normalize_function_+3A_norm">norm</code></td>
<td>
<p>Some normalization function of the form <code style="white-space: pre;">&#8288;function(num_vector)&#8288;</code>, or <code>NULL</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns function <code>norm</code> if not <code>NULL</code>.
Otherwise, it determines the result depending on <code>method</code>:
</p>

<dl>
<dt><code>"set"</code>:</dt><dd><p><code><a href="#topic+norm_none">norm_none()</a></code></p>
</dd>
<dt><code>"prob"</code>:</dt><dd><p><code><a href="#topic+norm_sum">norm_sum()</a></code></p>
</dd>
<dt><code>"fuzzy"</code>:</dt><dd><p><code><a href="#topic+norm_none">norm_none()</a></code></p>
</dd>
<dt><code>"fuzzynorm"</code>:</dt><dd><p><code><a href="#topic+norm_max">norm_max()</a></code></p>
</dd>
</dl>

<p>Fails with an error if the result is not an R function.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+evaluate">evaluate</a></code>, <code><a href="#topic+norm_none">norm_none()</a></code>, <code><a href="#topic+norm_max">norm_max()</a></code>, <code><a href="#topic+norm_sum">norm_sum()</a></code>,
</p>

<hr>
<h2 id='or_function'>or_function</h2><span id='topic+or_function'></span>

<h3>Description</h3>

<p>Determine the function to be used in the disjunctive aggregation step of <code><a href="#topic+evaluate">evaluate()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>or_function(method = EnumEvalMethod, or = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="or_function_+3A_method">method</code></td>
<td>
<p>One of: <code>"set"</code> (default), <code>"prob"</code>, <code>"fuzzy"</code> or <code>"fuzzynorm"</code>.</p>
</td></tr>
<tr><td><code id="or_function_+3A_or">or</code></td>
<td>
<p>Some disjunctive aggregation function of the form <code style="white-space: pre;">&#8288;function(num_vector)&#8288;</code>, or <code>NULL</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the function <code>or</code> if not <code>NULL</code>.
Otherwise, it determines the result depending on <code>method</code>:
</p>

<dl>
<dt><code>"set"</code>:</dt><dd><p><code>function(x) 1</code></p>
</dd>
<dt><code>"prob"</code>:</dt><dd><p><code><a href="base.html#topic+sum">sum</a></code></p>
</dd>
<dt><code>"fuzzy"</code>:</dt><dd><p><code><a href="base.html#topic+max">max</a></code></p>
</dd>
<dt><code>"fuzzynorm"</code>:</dt><dd><p><code><a href="base.html#topic+max">max</a></code></p>
</dd>
</dl>

<p>Fails with an error if the result is not an R function.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+evaluate">evaluate</a></code>, <code><a href="#topic+and_function">and_function()</a></code>.
</p>

<hr>
<h2 id='plotalt_parallel'>plotalt_parallel</h2><span id='topic+plotalt_parallel'></span>

<h3>Description</h3>

<p>Makes and plots DEXi alternatives on parallel axes, corresponding to attributes.
Generally, axes are uniformly scaled to the <code style="white-space: pre;">&#8288;[0,1]&#8288;</code> interval.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotalt_parallel(
  model,
  alternatives = NULL,
  attids = NULL,
  aggregate = c("minmax", "min", "max", "mean", "none"),
  name = "name",
  shift = 0.01,
  linewidth = 2,
  pointsize = 3,
  split = c("no", "h", "v")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plotalt_parallel_+3A_model">model</code></td>
<td>
<p>A <a href="#topic+DexiModel">DexiModel</a> object. Required.</p>
</td></tr>
<tr><td><code id="plotalt_parallel_+3A_alternatives">alternatives</code></td>
<td>
<p>A <code>data.frame</code> of alternatives (normally an output of <code><a href="#topic+evaluate">evaluate()</a></code>) or
indices to <code>model$alternatives</code>. The default value <code>NULL</code> selects the whole <code>model$alternatives</code>.</p>
</td></tr>
<tr><td><code id="plotalt_parallel_+3A_attids">attids</code></td>
<td>
<p><code>character()</code>. A character vector of <a href="#topic+DexiAttribute">DexiAttribute</a> IDs to be included in the result.
Default: all <code>model</code> attributes.</p>
</td></tr>
<tr><td><code id="plotalt_parallel_+3A_aggregate">aggregate</code></td>
<td>
<p>One of <code>"minmax"</code>, <code>"min"</code>, <code>"max"</code>, <code>"mean"</code> or &quot;<code>none</code>&quot;. Determines how
to aggregate <code>alternatives</code> values that are represented by sets or distributions.</p>
</td></tr>
<tr><td><code id="plotalt_parallel_+3A_name">name</code></td>
<td>
<p><code>character(1)</code>, The name of the column in <code>alternatives</code> that contains
alternatives' names. Default: <code>"name"</code>.</p>
</td></tr>
<tr><td><code id="plotalt_parallel_+3A_shift">shift</code></td>
<td>
<p><code>numeric(1)</code>. Used to &quot;shift&quot; numeric results by a small amount to avoid overlapping
lines in charts. Default: <code>0.01</code>.
You may want to experiment with charts to determine the right value,</p>
</td></tr>
<tr><td><code id="plotalt_parallel_+3A_linewidth">linewidth</code></td>
<td>
<p><code>numeric(1)</code>. Widths of lines drawn.</p>
</td></tr>
<tr><td><code id="plotalt_parallel_+3A_pointsize">pointsize</code></td>
<td>
<p><code>numeric(1)</code>. Size of points drawn.</p>
</td></tr>
<tr><td><code id="plotalt_parallel_+3A_split">split</code></td>
<td>
<p>One of:
</p>

<dl>
<dt><code>"no"</code></dt><dd><p>Draw all alternatives on the same chart.</p>
</dd>
<dt><code>"v"</code></dt><dd><p>Split the chart vertically and draw alternatives separately.</p>
</dd>
<dt><code>"h"</code></dt><dd><p>Split the chart horizontally and draw alternatives separately.</p>
</dd>
</dl>
</td></tr>
</table>


<h3>Details</h3>

<p>Data presented in the chart is prepared by <code><a href="#topic+scale_alternatives">scale_alternatives()</a></code>.
<code>plotalt_parallel()</code> invokes <code><a href="#topic+ggplot_parallel">ggplot_parallel()</a></code> to make a basic chart and then
enhances it with graphic layers that are suitable for presenting DEXi alternatives.
</p>


<h3>Value</h3>

<p>A 'ggplot2' chart, enhanced with additional graph layers.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+scale_alternatives">scale_alternatives()</a></code>, <code><a href="#topic+ggplot_parallel">ggplot_parallel()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (requireNamespace("GGally", quietly = TRUE)) {

# Load "Car.dxi"
CarDxi &lt;- system.file("extdata", "Car.dxi", package = "DEXiR")
Car &lt;- read_dexi(CarDxi)

# Plot all Car$alternatives with points and lines
plotalt_parallel(Car)

# Show alternatives on two separate chart segments, shown one above the other.
plotalt_parallel(Car, split = "v")

alts3 &lt;- structure(
list(
  name = c("MyCar", "MyCar2", "MyCar1b"),
    CAR.1 = list(4L, 4L, c(1L, 4L)),
    PRICE = list(3L, 3L, c(1L, 3L)),
    BUY.PRICE = list(3L, 3L, 3L),
    MAINT.PRICE = list(2, 1, structure(c(0.1, 0.6, 0.3), class = "distribution")),
    TECH.CHAR. = list(3L, 3:4, 3L),
    COMFORT = list(3L, 2, 3L),
    X.PERS = list(3, 3, 3L),
    X.DOORS = list(3, 3, 3L),
    LUGGAGE = list(2L, 2L, 2),
    SAFETY = list(2, c(2, 3), 2)
    ),
    row.names = c(NA, -3L),
    class = "data.frame"
 )

# Plot `alts2` with points and lines.
# Notice the "minmax" aggregation of sets and distributions.
plotalt_parallel(Car, alts3)
plotalt_parallel(Car, alts3, split = "v")

# Now with "mean" aggregation
plotalt_parallel(Car, alts3, split = "v", aggregate = "mean")
}
</code></pre>

<hr>
<h2 id='plotalt_radar'>plotalt_radar</h2><span id='topic+plotalt_radar'></span>

<h3>Description</h3>

<p>Plots DEXi alternatives on a radar chart.
Generally, axes are uniformly scaled to the <code style="white-space: pre;">&#8288;[0,1]&#8288;</code> interval.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotalt_radar(
  model,
  alternatives = NULL,
  attids = NULL,
  aggregate = c("minmax", "min", "max", "mean", "none"),
  name = "name",
  shift = 0.01,
  linewidth = 2,
  ptype = 16,
  colors = NULL,
  unicolors = NULL,
  fillcolors = NULL,
  transparency = 85,
  circular = FALSE,
  split = FALSE,
  fill = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plotalt_radar_+3A_model">model</code></td>
<td>
<p>A <a href="#topic+DexiModel">DexiModel</a> object. Required.</p>
</td></tr>
<tr><td><code id="plotalt_radar_+3A_alternatives">alternatives</code></td>
<td>
<p>A <code>data.frame</code> of alternatives (normally an output of <code><a href="#topic+evaluate">evaluate()</a></code>) or
indices to <code>model$alternatives</code>. The default value <code>NULL</code> selects the whole <code>model$alternatives</code>.</p>
</td></tr>
<tr><td><code id="plotalt_radar_+3A_attids">attids</code></td>
<td>
<p><code>character()</code>. A character vector of <a href="#topic+DexiAttribute">DexiAttribute</a> IDs to be included in the result.
Default: all <code>model</code> attributes.</p>
</td></tr>
<tr><td><code id="plotalt_radar_+3A_aggregate">aggregate</code></td>
<td>
<p>One of <code>"minmax"</code>, <code>"min"</code>, <code>"max"</code>, <code>"mean"</code> or &quot;<code>none</code>&quot;. Determines how
to aggregate <code>alternatives</code> values that are represented by sets or distributions.</p>
</td></tr>
<tr><td><code id="plotalt_radar_+3A_name">name</code></td>
<td>
<p><code>character(1)</code>, The name of the column in <code>alternatives</code> that contains
alternatives' names. Default: <code>"name"</code>.</p>
</td></tr>
<tr><td><code id="plotalt_radar_+3A_shift">shift</code></td>
<td>
<p><code>numeric(1)</code>. Used to &quot;shift&quot; numeric values by a small amount to avoid overlapping
lines in charts. Default: <code>0.01</code>.
You may want to experiment with charts to determine the right value,</p>
</td></tr>
<tr><td><code id="plotalt_radar_+3A_linewidth">linewidth</code></td>
<td>
<p><code>numeric(1)</code>. Widths of lines drawn.</p>
</td></tr>
<tr><td><code id="plotalt_radar_+3A_ptype">ptype</code></td>
<td>
<p>A vector to specify point symbol: Default <code>16</code> (closed circle).
Should be 32 to not plot the points. This vector is repeatedly used for data series.</p>
</td></tr>
<tr><td><code id="plotalt_radar_+3A_colors">colors</code></td>
<td>
<p>Colors to be used (repeatably) for data series. Default <code>1:8</code>.</p>
</td></tr>
<tr><td><code id="plotalt_radar_+3A_unicolors">unicolors</code></td>
<td>
<p>A vector of one or two colors to be used for displaying the
minimum and maximum data series, respectively. Applies only when <code>split = TRUE</code>.</p>
</td></tr>
<tr><td><code id="plotalt_radar_+3A_fillcolors">fillcolors</code></td>
<td>
<p>A vector of color codes for filling polygons. Applies only when <code>fill = TRUE</code>.</p>
</td></tr>
<tr><td><code id="plotalt_radar_+3A_transparency">transparency</code></td>
<td>
<p>A number between <code>0</code> and <code>100</code> representing the transparency of
colors used for filling polygons.</p>
</td></tr>
<tr><td><code id="plotalt_radar_+3A_circular">circular</code></td>
<td>
<p><code>logical(1)</code>. Whether to make a circular (using <code><a href="fmsb.html#topic+radarchart">fmsb::radarchartcirc()</a></code>)
or polygonal (<code><a href="fmsb.html#topic+radarchart">fmsb::radarchart()</a></code>) radar grid.</p>
</td></tr>
<tr><td><code id="plotalt_radar_+3A_split">split</code></td>
<td>
<p><code>logical(1)</code>. Whether to plot all alternatives on a single chart (<code>FALSE</code>, default)
or make a series of plots of individual alternatives (<code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="plotalt_radar_+3A_fill">fill</code></td>
<td>
<p><code>logical(1)</code>. Whether or not to fill polygons using <code>fillcolors</code>.</p>
</td></tr>
<tr><td><code id="plotalt_radar_+3A_...">...</code></td>
<td>
<p>Optional parameters passed to <code><a href="fmsb.html#topic+radarchart">fmsb::radarchart()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Uses <code><a href="fmsb.html#topic+radarchart">fmsb::radarchart()</a></code> and requires package &quot;fmsb&quot; to be installed.
Data presented in the chart is prepared by <code><a href="#topic+scale_alternatives">scale_alternatives()</a></code>.
</p>


<h3>Value</h3>

<p>Draws a chart or, when <code>split = TRUE</code> a series of charts corresponding to individual alternatives.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+scale_alternatives">scale_alternatives()</a></code>, <code><a href="fmsb.html#topic+radarchart">fmsb::radarchart()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (requireNamespace("fmsb", quietly = TRUE)) {

# Load "Car.dxi"
CarDxi &lt;- system.file("extdata", "Car.dxi", package = "DEXiR")
Car &lt;- read_dexi(CarDxi)

# Plot all Car$alternatives with points and lines
plotalt_radar(Car)

# Use different colors and fill polygons
plotalt_radar(Car, colors = c("blue", "brown"), fill = TRUE)
plotalt_radar(Car, colors = c("blue", "brown"), fillcolors = c("green", "red"), fill = TRUE)

# Draw separate charts
plotalt_radar(Car, split = TRUE)

# Draw separate charts, using the same color settings on all charts
plotalt_radar(Car, split = TRUE, unicolors = c("green", "red"))
plotalt_radar(Car, split = TRUE, unicolors = c("green", "red"), circular = TRUE)

alts3 &lt;- structure(
list(
  name = c("MyCar", "MyCar2", "MyCar1b"),
    CAR.1 = list(4L, 4L, c(1L, 4L)),
    PRICE = list(3L, 3L, c(1L, 3L)),
    BUY.PRICE = list(3L, 3L, 3L),
    MAINT.PRICE = list(2, 1, structure(c(0.1, 0.6, 0.3), class = "distribution")),
    TECH.CHAR. = list(3L, 3:4, 3L),
    COMFORT = list(3L, 2, 3L),
    X.PERS = list(3, 3, 3L),
    X.DOORS = list(3, 3, 3L),
    LUGGAGE = list(2L, 2L, 2),
    SAFETY = list(2, c(2, 3), 2)
    ),
    row.names = c(NA, -3L),
    class = "data.frame"
 )

# The same chart types as above, but using more varied alternatives data
# Plot all Car$alternatives with points and lines
plotalt_radar(Car, alts3)

# Use different colors and fill polygons
plotalt_radar(Car, alts3, colors = c("blue", "brown", "purple"), fill = TRUE)
plotalt_radar(Car, alts3, colors = c("blue", "brown", "purple"),
  fillcolors = c("green", "red", "yellow"), fill = TRUE)

# Draw separate charts
plotalt_radar(Car, alts3, split = TRUE)
plotalt_radar(Car, alts3, split = TRUE, fill = TRUE)

# Draw separate charts, using the same color settings on all charts
plotalt_radar(Car, alts3, split = TRUE, unicolors = c("red", "green"))
plotalt_radar(Car, alts3, split = TRUE, unicolors = c("green", "darkgreen"), fill = TRUE)
plotalt_radar(Car, alts3, split = TRUE, unicolors = c("red", "green"), circular = TRUE)

}
</code></pre>

<hr>
<h2 id='plotalt1'>plotalt1</h2><span id='topic+plotalt1'></span>

<h3>Description</h3>

<p>Plot <code>alternatives</code> with respect to a single <code>attribute</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotalt1(
  model,
  attribute = model$first(),
  alternatives = NULL,
  colors = c("red", "black", "green"),
  pch = 20,
  size = 5,
  linetype = 2,
  margins = NULL,
  lm = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plotalt1_+3A_model">model</code></td>
<td>
<p>A <a href="#topic+DexiModel">DexiModel</a> object. Required.</p>
</td></tr>
<tr><td><code id="plotalt1_+3A_attribute">attribute</code></td>
<td>
<p>A single <a href="#topic+DexiAttribute">DexiAttribute</a> selector. It may be an <a href="#topic+DexiAttribute">DexiAttribute</a> object or
an argument to <code>model$attrib()</code>. <code>attribute$scale</code> must be defined. Default: <code>model$first()</code>.</p>
</td></tr>
<tr><td><code id="plotalt1_+3A_alternatives">alternatives</code></td>
<td>
<p>A <code>data.frame</code> of alternatives (normally an output of <code><a href="#topic+evaluate">evaluate()</a></code>) or
indices to <code>model$alternatives</code>. The default value <code>NULL</code> selects the whole <code>model$alternatives</code>.</p>
</td></tr>
<tr><td><code id="plotalt1_+3A_colors">colors</code></td>
<td>
<p><code>character(3)</code> representing colors corresponding to &quot;bad&quot;, &quot;neutral&quot; and &quot;good&quot;
scale values, respectively. Default: <code>c("red", "black", "green")</code>.</p>
</td></tr>
<tr><td><code id="plotalt1_+3A_pch">pch</code></td>
<td>
<p>Plotting character, see <code><a href="graphics.html#topic+points">graphics::points()</a></code>. Default: <code>20</code>.</p>
</td></tr>
<tr><td><code id="plotalt1_+3A_size">size</code></td>
<td>
<p><code>numeric(1)</code>. Multiplication size factor for drawing individual points.
Base point size depends on <code>pch</code>.</p>
</td></tr>
<tr><td><code id="plotalt1_+3A_linetype">linetype</code></td>
<td>
<p><code>integer()</code>. Line type for drawing chart grid. Default: <code>2</code>.</p>
</td></tr>
<tr><td><code id="plotalt1_+3A_margins">margins</code></td>
<td>
<p><code>numeric(4)</code>. Chart margins, passed to <code><a href="graphics.html#topic+par">graphics::par()</a></code> prior to drawing.</p>
</td></tr>
<tr><td><code id="plotalt1_+3A_lm">lm</code></td>
<td>
<p><code>numeric(1)</code>. Left chart margin. May be used to adjust the display of alternatives' names.</p>
</td></tr>
<tr><td><code id="plotalt1_+3A_...">...</code></td>
<td>
<p>Optional parameters passed to <code><a href="graphics.html#topic+plot.default">graphics::plot()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Standard scatterplot <a href="base.html#topic+plot">base::plot</a> is used.
</p>


<h3>Value</h3>

<p>Draws a chart.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load "Car.dxi"
CarDxi &lt;- system.file("extdata", "Car.dxi", package = "DEXiR")
Car &lt;- read_dexi(CarDxi)

# Plot all Car$alternatives with respect to "TECH.CHAR." attribute
plotalt1(Car, "TECH.CHAR.")

# Plot the first Car alternative with respect to "MAINT.PRICE" attribute
plotalt1(Car, "MAINT.PRICE", 1)

</code></pre>

<hr>
<h2 id='plotalt2'>plotalt2</h2><span id='topic+plotalt2'></span>

<h3>Description</h3>

<p>Draw a scatterpolot of <code>alternatives</code> with <code>attribute1</code> and <code>attribute2</code> on the
<code class="reqn">x</code> and <code class="reqn">y</code> axis, respectively.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotalt2(
  model,
  attribute1,
  attribute2,
  alternatives = NULL,
  colors = NULL,
  pch = 20,
  size = 5,
  margins = NULL,
  lm = NULL,
  pos = 4,
  offset = 1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plotalt2_+3A_model">model</code></td>
<td>
<p>A <a href="#topic+DexiModel">DexiModel</a> object. Required.</p>
</td></tr>
<tr><td><code id="plotalt2_+3A_attribute1">attribute1</code></td>
<td>
<p>First attribute. It may be an <a href="#topic+DexiAttribute">DexiAttribute</a> object or
an argument to <code>model$attrib()</code>. The attribute must be discrete.</p>
</td></tr>
<tr><td><code id="plotalt2_+3A_attribute2">attribute2</code></td>
<td>
<p>Second attribute. It may be an <a href="#topic+DexiAttribute">DexiAttribute</a> object or
an argument to <code>model$attrib()</code>. The attribute must be discrete.</p>
</td></tr>
<tr><td><code id="plotalt2_+3A_alternatives">alternatives</code></td>
<td>
<p>A <code>data.frame</code> of alternatives (normally an output of <code><a href="#topic+evaluate">evaluate()</a></code>) or
indices to <code>model$alternatives</code>. The default value <code>NULL</code> selects the whole <code>model$alternatives</code>.</p>
</td></tr>
<tr><td><code id="plotalt2_+3A_colors">colors</code></td>
<td>
<p><code>character()</code>. Colors for displaying subsequent alternatives.</p>
</td></tr>
<tr><td><code id="plotalt2_+3A_pch">pch</code></td>
<td>
<p>Plotting character, see <code><a href="graphics.html#topic+points">graphics::points()</a></code>. Default: <code>20</code>.</p>
</td></tr>
<tr><td><code id="plotalt2_+3A_size">size</code></td>
<td>
<p><code>numeric(1)</code>. Multiplication size factor for drawing individual points.
Base point size depends on <code>pch</code>.</p>
</td></tr>
<tr><td><code id="plotalt2_+3A_margins">margins</code></td>
<td>
<p><code>numeric(4)</code>. Chart margins, passed to <code><a href="graphics.html#topic+par">graphics::par()</a></code> prior to drawing.</p>
</td></tr>
<tr><td><code id="plotalt2_+3A_lm">lm</code></td>
<td>
<p><code>numeric(1)</code>. Left chart margin. May be used to adjust the display of <code>attribute2</code>'s values.</p>
</td></tr>
<tr><td><code id="plotalt2_+3A_pos">pos</code></td>
<td>
<p>A position specifier for legent text, see <code><a href="graphics.html#topic+text">graphics::text()</a></code>. Default: <code>4</code>.</p>
</td></tr>
<tr><td><code id="plotalt2_+3A_offset">offset</code></td>
<td>
<p>When <code>pos</code> is specified, this value controls the distance of the text label
from the specified coordinate in fractions of a character width. Default: <code>1</code>.</p>
</td></tr>
<tr><td><code id="plotalt2_+3A_...">...</code></td>
<td>
<p>Optional parameters passed to <code><a href="graphics.html#topic+plot.default">graphics::plot()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Standard scatterplot <code><a href="graphics.html#topic+plot.default">graphics::plot()</a></code> is used.
Continuous attributes are not supported.
</p>


<h3>Value</h3>

<p>Draws a chart.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load "Car.dxi"
CarDxi &lt;- system.file("extdata", "Car.dxi", package = "DEXiR")
Car &lt;- read_dexi(CarDxi)

# Plot all Car$alternatives with respect to "PRICE" and "TECH.CHAR." attributes
plotalt2(Car, "PRICE", "TECH.CHAR.")

# Plot the first Car alternative with respect to "BUY.PRICE" and "MAINT.PRICE" attributes
plotalt2(Car, "BUY.PRICE", "MAINT.PRICE", 1)

</code></pre>

<hr>
<h2 id='plus_minus'>plus_minus</h2><span id='topic+plus_minus'></span>

<h3>Description</h3>

<p>Plus-Minus Analysis:
Investigate the effects of changing single attributes values on the evaluation of <code>alternative</code>.
The values of discrete basic attributes (&quot;input attributes&quot;) are changed, one attribute at a time,
by a particular number of steps downwards (<code>minus</code>) and upwards (<code>plus</code>),
while observing the changes of the <code>target</code> attribute values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plus_minus(
  model,
  alternative,
  target = model$first(),
  minus = .Machine$integer.max,
  plus = .Machine$integer.max,
  print = TRUE,
  as_character = FALSE,
  round = NULL,
  id = NULL,
  evaluate = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plus_minus_+3A_model">model</code></td>
<td>
<p>A <a href="#topic+DexiModel">DexiModel</a> object.</p>
</td></tr>
<tr><td><code id="plus_minus_+3A_alternative">alternative</code></td>
<td>
<p>Either a <code>data.frame</code> representing a single alternative
or an index to <code>model$alternatives</code>.</p>
</td></tr>
<tr><td><code id="plus_minus_+3A_target">target</code></td>
<td>
<p>The attribute on which effects are observed. Default: <code>model$first()</code>.</p>
</td></tr>
<tr><td><code id="plus_minus_+3A_minus">minus</code></td>
<td>
<p>The maximum number of downward steps to be made for each input attribute.
Default: <code>.Machine$integer.max</code>.
The actual <code>minus</code> value is further determined with respect to
<code>alternative</code> values and involved attributes' scales.</p>
</td></tr>
<tr><td><code id="plus_minus_+3A_plus">plus</code></td>
<td>
<p>The maximum number of upward steps to be made for each input attribute.
Default: <code>.Machine$integer.max</code>.
The actual <code>plus</code> value is further determined with respect to
<code>alternative</code> values and involved attributes' scales.</p>
</td></tr>
<tr><td><code id="plus_minus_+3A_print">print</code></td>
<td>
<p><code>logical(1)</code>. When <code>TRUE</code>, pretty print (left justify) the results.</p>
</td></tr>
<tr><td><code id="plus_minus_+3A_as_character">as_character</code></td>
<td>
<p><code>logical(1)</code>. Whether to represent alternative values
numerically (<code>FALSE</code>) or using text (<code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="plus_minus_+3A_round">round</code></td>
<td>
<p>An integer number, argument to <code><a href="#topic+value_text">value_text()</a></code>.</p>
</td></tr>
<tr><td><code id="plus_minus_+3A_id">id</code></td>
<td>
<p><code>character(1)</code>.
Determines the contents of the first or first two columns of the resulting <code>data.frame</code>s:
</p>

<dl>
<dt><code>"id"</code></dt><dd><p>Attribute ID.</p>
</dd>
<dt><code>"structure"</code></dt><dd><p>Attribute <code style="white-space: pre;">&#8288;$structure() + $name&#8288;</code>.</p>
</dd>
<dt>anything else</dt><dd><p>Equivalent to both <code>"id"</code> and <code>"structure"</code>.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="plus_minus_+3A_evaluate">evaluate</code></td>
<td>
<p><code>logical(1)</code>. Whether or not to evaluate <code>alternative</code> beforehand.</p>
</td></tr>
<tr><td><code id="plus_minus_+3A_...">...</code></td>
<td>
<p>Optional parameters for <code><a href="#topic+evaluate">evaluate()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame consisting of columns:
</p>

<dl>
<dt><code>id</code></dt><dd><p>IDs of input attributes (unless excluded by the <code>id</code> argument).</p>
</dd>
<dt><code>structure</code></dt><dd><p>Structure and names of input attributes (unless excluded by the <code>id</code> argument).</p>
</dd>
<dt>'For <code>-minus</code> to <code>-1</code></dt><dd><p>Evaluation value of <code>target</code> when decreasing the corresponding attribute value by the corresponding number of steps.</p>
</dd>
<dt><code>target$id</code></dt><dd><p>Original <code>alternative</code> value assigned to the corresponding attribute <code>id</code>.</p>
</dd>
<dt>For <code>1</code> to <code>plus</code></dt><dd><p>Evaluation value of <code>target</code> when increasing the corresponding attribute value by the corresponding number of steps.</p>
</dd>
</dl>

<p>Special values <code>"["</code> and <code>"]"</code> denote that it is not possible to decrease of increase, respectively,
the corresponding attributes value further.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+evaluate">evaluate()</a></code>, <code><a href="#topic+value_text">value_text()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load "Car.dxi"
CarDxi &lt;- system.file("extdata", "Car.dxi", package = "DEXiR")
Car &lt;- read_dexi(CarDxi)

alt &lt;- Car$alternative("MyCar",
       BUY.PRICE="low", MAINT.PRICE="*", X.PERS="more", X.DOORS="4", LUGGAGE=2, SAFETY=c(1, 3))
alte &lt;- Car$evaluate(alt)

# Default plus-minus analysis, evaluating `alt`.
plus_minus(Car, alt, evaluate = TRUE)

# Plus-minus analysis of `alte`, using character strings,
# no pretty-printing and excluding structure info.
plus_minus(Car, alte, as_character=TRUE, print=FALSE, id = "id")

# Plus-minus analysis on `target="PRICE"`, using character strings.
plus_minus(Car, alt, target="PRICE", as_character=TRUE, evaluate=TRUE)
</code></pre>

<hr>
<h2 id='plus_minus_setup'>plus_minus_setup</h2><span id='topic+plus_minus_setup'></span>

<h3>Description</h3>

<p>A helper function: Initializes a data frame for <code><a href="#topic+plus_minus">plus_minus()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plus_minus_setup(evaluated, attributes, minus, plus)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plus_minus_setup_+3A_evaluated">evaluated</code></td>
<td>
<p>An evaluated alternative.</p>
</td></tr>
<tr><td><code id="plus_minus_setup_+3A_attributes">attributes</code></td>
<td>
<p>Vector of <a href="#topic+DexiAttribute">DexiAttribute</a> objects involved in <code>plus-minus</code> analysis.</p>
</td></tr>
<tr><td><code id="plus_minus_setup_+3A_minus">minus</code></td>
<td>
<p>A single integer: Maximum steps down.</p>
</td></tr>
<tr><td><code id="plus_minus_setup_+3A_plus">plus</code></td>
<td>
<p>A single integer: Maximum steps up.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame consisting of columns:
</p>

<dl>
<dt><code>"id"</code></dt><dd><p>Attribute IDs.</p>
</dd>
<dt><code>"structure"</code></dt><dd><p>Attribute <code style="white-space: pre;">&#8288;$structure() + $name&#8288;</code>.</p>
</dd>
<dt><code>counts</code></dt><dd><p>Attributes' scale sizes.</p>
</dd>
<dt><code>low_bounds</code></dt><dd><p>Low bounds of attributes' values.</p>
</dd>
<dt><code>high_bounds</code></dt><dd><p>High bounds of attributes' values.</p>
</dd>
<dt><code>low_diff</code></dt><dd><p>Maximum possible value decrease given <code>low_bound</code> and attribute scale.</p>
</dd>
<dt><code>high_diff</code></dt><dd><p>Maximum possible value increase given <code>high_bound</code> and attribute scale.</p>
</dd>
<dt><code>evals</code></dt><dd><p>Alternative evaluation for the corresponding attribute (from <code>evaluated</code>).</p>
</dd>
<dt><code>sets</code></dt><dd><p><code>evals</code> represented as value sets.</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+plus_minus">plus_minus()</a></code>
</p>

<hr>
<h2 id='print_selective_explanation'>print_selective_explanation</h2><span id='topic+print_selective_explanation'></span>

<h3>Description</h3>

<p>A helper function for <code><a href="#topic+selective_explanation">selective_explanation()</a></code>: Pretty-prints its results.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>print_selective_explanation(explanation)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print_selective_explanation_+3A_explanation">explanation</code></td>
<td>
<p>A list of lists,
containing selective explanation results produced by <code><a href="#topic+selective_explanation">selective_explanation()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>NULL</code>. Pretty-prints the contents of <code>explanation</code>.
</p>

<hr>
<h2 id='read_dexi'>read_dexi</h2><span id='topic+read_dexi'></span>

<h3>Description</h3>

<p><code>read_dexi()</code> reads a definition of a DEXi model from a <code>.dxi</code> file or XML string.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_dexi(dxi)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="read_dexi_+3A_dxi">dxi</code></td>
<td>
<p>character(1). A <code>.dxi</code> file name or XML string.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <a href="#topic+DexiModel">DexiModel</a> RC object.
</p>


<h3>See Also</h3>

<p><a href="#topic+DexiModel">DexiModel</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>CarDxi &lt;- system.file("extdata", "Car.dxi", package = "DEXiR")
Car &lt;- read_dexi(CarDxi)

</code></pre>

<hr>
<h2 id='reverse_value'>reverse_value</h2><span id='topic+reverse_value'></span>

<h3>Description</h3>

<p>Numeric value(s) <code>x</code> are assumed to lie within the <code style="white-space: pre;">&#8288;[lb:hb]&#8288;</code> interval.
The function &quot;reverses&quot; <code>x</code> linearly so that <code>x = lb</code> maps to <code>hb</code> and <code>x = hb</code> maps to <code>lb</code>.
In DEXiR, this function is used to reverse values defined on a <a href="#topic+DexiScale">DexiScale</a> from
&quot;ascending&quot; to &quot;descending&quot; order or vice versa.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reverse_value(x, lb, hb)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="reverse_value_+3A_x">x</code></td>
<td>
<p><code>numeric()</code>. Value(s) to be reversed.</p>
</td></tr>
<tr><td><code id="reverse_value_+3A_lb">lb</code></td>
<td>
<p><code>numeric()</code>. Lower interval bound(s).</p>
</td></tr>
<tr><td><code id="reverse_value_+3A_hb">hb</code></td>
<td>
<p><code>numeric()</code>. Upper interval bound(s).</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>numeric()</code>. Reversed <code>value</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>reverse_value(1, 1, 5) # 5
reverse_value(3, 1, 5) # 3
reverse_value(5, 1, 5) # 1
reverse_value(c(1, 3, 5), 1, 5) # c(5, 3, 1)
</code></pre>

<hr>
<h2 id='rule_value'>rule_value</h2><span id='topic+rule_value'></span>

<h3>Description</h3>

<p>Values of decision rules are in <code>.dxi</code> files encoded using character strings, where each
individual character encodes some function value. The encoding is zero-based, so that
<code>"0"</code> represents the lowest ordinal number on the corresponding discrete scale.
<code>rule_value(char)</code> converts a single character to the corresponding ordinal value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rule_value(ch)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rule_value_+3A_ch">ch</code></td>
<td>
<p>A single character, such as <code>"3"</code> or <code>"Z"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Corresponding integer value.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rule_value("1")
rule_value("Z")

</code></pre>

<hr>
<h2 id='rule_values'>rule_values</h2><span id='topic+rule_values'></span>

<h3>Description</h3>

<p>Values of decision rules are in <code>.dxi</code> files encoded using character strings, where each
individual character encodes some function value. The encoding is zero-based, so that
the character <code>"0"</code> represents the lowest ordinal number on the corresponding discrete scale.
Encoding of characters is according to ASCII, starting with <code>"0"</code>.
<code>rule_values(str)</code> converts the character string to a numeric vector of corresponding
ordinal values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rule_values(str, add = 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rule_values_+3A_str">str</code></td>
<td>
<p><code>character(1)</code>, a DEXi encoding of a vector of ordinal numbers.</p>
</td></tr>
<tr><td><code id="rule_values_+3A_add">add</code></td>
<td>
<p>An integer constant to be added to the resulting vector. The default is <code>add = 0</code>,
however DEXi's ordinal numbers should normally be converted to R's using <code>add = 1</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector of the same length as <code>str</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rule_values("01122:")
rule_values("01122:", add = 1)

</code></pre>

<hr>
<h2 id='scale_alternatives'>scale_alternatives</h2><span id='topic+scale_alternatives'></span>

<h3>Description</h3>

<p>A helper function for preparing alternatives' data for charts that involve multiple
attributes (such as <code><a href="#topic+plotalt_parallel">plotalt_parallel()</a></code>) and <code><a href="#topic+plotalt_radar">plotalt_radar()</a></code>).
<code>scale_alternatives()</code> carries out three main operations:
</p>

<ol>
<li><p>Aggregates DEXi values, represented by sets and distributions,
into single numeric values, using one of the <code>aggregate</code> operators:
<code>"minmax"</code>, <code>"min"</code>, <code>"max"</code> or <code>"mean"</code>,
</p>
</li>
<li><p>scales the aggregated values to the <code style="white-space: pre;">&#8288;[0,1]&#8288;</code> interval so that they can be
drawn uniformly on multiple chart axes,
</p>
</li>
<li><p>optionally &quot;shifts&quot; the values by a small amount to avoid overlapping chart lines.
</p>
</li></ol>



<h3>Usage</h3>

<pre><code class='language-R'>scale_alternatives(
  model,
  alternatives = NULL,
  attids = NULL,
  aggregate = c("minmax", "min", "max", "mean", "none"),
  name = "name",
  shift = 0.01
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="scale_alternatives_+3A_model">model</code></td>
<td>
<p>A <a href="#topic+DexiModel">DexiModel</a> object. Required.</p>
</td></tr>
<tr><td><code id="scale_alternatives_+3A_alternatives">alternatives</code></td>
<td>
<p>A <code>data.frame</code> of alternatives (normally an output of <code><a href="#topic+evaluate">evaluate()</a></code>) or
indices to <code>model$alternatives</code>. The default value <code>NULL</code> selects the whole <code>model$alternatives</code>.</p>
</td></tr>
<tr><td><code id="scale_alternatives_+3A_attids">attids</code></td>
<td>
<p><code>character()</code>. A character vector of <a href="#topic+DexiAttribute">DexiAttribute</a> IDs to be included in the result.
Default: all <code>model</code> attributes.</p>
</td></tr>
<tr><td><code id="scale_alternatives_+3A_aggregate">aggregate</code></td>
<td>
<p>Determines how to aggregate DEXi values that are represented/interpreted
as sets in <code>alternatives</code>:
</p>

<dl>
<dt><code>"min"</code></dt><dd><p>Uses the function <code><a href="base.html#topic+min">min()</a></code> to take the minimal set element.</p>
</dd>
<dt><code>"max"</code></dt><dd><p>Uses the function <code><a href="base.html#topic+max">max()</a></code> to take the maximal set element.</p>
</dd>
<dt><code>"mean"</code></dt><dd><p>Uses the function <code><a href="base.html#topic+mean">mean()</a></code> to take the average set value.</p>
</dd>
<dt><code>"minmax"</code> (default)</dt><dd><p>Takes both <code>"min"</code> and <code>"max"</code>, so that each alternative
appears in the result twice.</p>
</dd>
<dt><code>"none"</code></dt><dd><p>No aggregation.</p>
</dd>
</dl>

<p>Any distributions that appear in <code>alternatives</code> are interpreted as sets prior to aggregation.
The default operator <code>"minmax"</code> is suitable particularly for alternatives containing non-single-values
(sets and/or distributions). For alternatives containing only single numeric values, any of the
other three operators is preferred.</p>
</td></tr>
<tr><td><code id="scale_alternatives_+3A_name">name</code></td>
<td>
<p><code>character(1)</code>, The name of the column in <code>alternatives</code> that contains
alternatives' names. Default: <code>"name"</code>.</p>
</td></tr>
<tr><td><code id="scale_alternatives_+3A_shift">shift</code></td>
<td>
<p><code>numeric(1)</code>. Used to &quot;shift&quot; numerical values by a small amount to avoid overlapping
lines in charts. Default: <code>0.01</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the elements:
</p>

<dl>
<dt><code>data</code></dt><dd><p>A data frame containing the aggregated/scaled/shifted numeric values.</p>
</dd>
<dt><code>nalt</code></dt><dd><p>The number of alternatives. Notice that with <code>aggregate = "minmax"</code>,
<code>data</code> contains twice as many rows.</p>
</dd>
<dt><code>groups</code></dt><dd><p>A numeric vector mapping <code>data</code> rows to <code>alternatives</code>' indices.</p>
</dd>
<dt><code>altnames</code></dt><dd><p>Names of alternatives.</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+plotalt_parallel">plotalt_parallel()</a></code>), <code><a href="#topic+plotalt_radar">plotalt_radar()</a></code>)
</p>

<hr>
<h2 id='scale_of'>scale_of</h2><span id='topic+scale_of'></span>

<h3>Description</h3>

<p>scale_of
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scale_of(obj)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="scale_of_+3A_obj">obj</code></td>
<td>
<p>A <a href="#topic+DexiAttribute">DexiAttribute</a> or <a href="#topic+DexiScale">DexiScale</a>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <a href="#topic+DexiScale">DexiScale</a> associated with <code>obj</code>, or <code>NA</code> for an undefined scale.
</p>

<hr>
<h2 id='scale_value'>scale_value</h2><span id='topic+scale_value'></span>

<h3>Description</h3>

<p>Check and interpret <code>value</code> on <code>scale</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scale_value(value, scale)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="scale_value_+3A_value">value</code></td>
<td>
<p>A wide range of possible value types, including  integer, double, character and list vectors.</p>
</td></tr>
<tr><td><code id="scale_value_+3A_scale">scale</code></td>
<td>
<p>A <a href="#topic+DexiScale">DexiScale</a> or derived object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The result is produced depending on <code>value</code> and <code>scale</code> according to the following tables.
For any scale type:
</p>
<pre>
value                          result
------------------------------+------------------
NULL                           NULL
length(value == 0)             NULL
NA                             scale$full_range()
other types                    ERROR
value contains any NULL or NA  ERROR
------------------------------+------------------
</pre>
<p>For continuous scales:
</p>
<pre>
value                          result
------------------------------+------------------
length(value != 1)             ERROR
character                      ERROR
named object                   ERROR
length(value == 1)             unclass(value)
------------------------------+------------------
</pre>
<p>For discrete scales:
</p>
<pre>
value                          result
------------------------------+------------------
distribution class             value
all-integer numeric vector     value
non all-integer numeric vector distribution(value)
"*" or "undef"...              scale$full_range()
list of value names            matched value set
list of name=p                 distribution(value)
------------------------------+------------------
</pre>


<h3>Examples</h3>

<pre><code class='language-R'># Examples of successfully checked (witout error) values on a continuous scale
scl &lt;- DexiContinuousScale()
scale_value(NULL, scl)               # NA
scale_value(c(), scl)                # NA
scale_value(list(), scl)             # NA
scale_value(character(), scl)        # NA
scale_value(NA, scl)                 # NA
scale_value(c(NA), scl)              # NA
scale_value(15.5, scl)               # 15.5
scale_value(distribution(15.5), scl) # 15.5

# Examples of successfully checked (without error) values on a discrete scale
scl &lt;- DexiDiscreteScale(values = c("low", "med", "high"))
scale_value(NULL, scl)                        # NA
scale_value(c(), scl)                         # NA
scale_value(list(), scl)                      # NA
scale_value(NA, scl)                          # NA
scale_value("*", scl)                         # 1:3
scale_value("Undefined", scl)                 # 1:3
scale_value(2, scl)                           # 2
scale_value(c(-1, 2, 4), scl)                 # c(-1, 2, 4))
scale_value(distribution(c(-1, 2, 4)), scl)   # distribution(c(-1, 2, 4)))
scale_value(c(-1, 2.2, 4), scl)               # distribution(c(-1, 2.2, 4)))
scale_value("high", scl)                      # 3
scale_value(c("low", "high"), scl)            # c(1,3))
v &lt;- c(0.5, 0.4)
names(v) &lt;- c("low", "high")
scale_value(v, scl)                           # distribution(c(0.5, 0, 0.4)))
scale_value(list(high = 1.1, low = 2.2), scl) # distribution(c(2.2, 0, 1.1)))

</code></pre>

<hr>
<h2 id='scale_values'>scale_values</h2><span id='topic+scale_values'></span>

<h3>Description</h3>

<p>A vectorized version of <code>scale_value</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scale_values(values, scale)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="scale_values_+3A_values">values</code></td>
<td>
<p>A list of values. For possible value types, see <code><a href="#topic+scale_value">scale_value()</a></code>.</p>
</td></tr>
<tr><td><code id="scale_values_+3A_scale">scale</code></td>
<td>
<p>A <a href="#topic+DexiScale">DexiScale</a> or derived object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list determined as <code>lapply(values, function (v) scale_value(v, scale))</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+scale_value">scale_value()</a></code>
</p>

<hr>
<h2 id='select_quality'>select_quality</h2><span id='topic+select_quality'></span>

<h3>Description</h3>

<p>Select from <code>alt</code> only those attributes whose values have the given <code>quality</code>.
Used primarily in <code>selective_explanation()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>select_quality(model, alt, quality)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="select_quality_+3A_model">model</code></td>
<td>
<p>A <a href="#topic+DexiModel">DexiModel</a> object.</p>
</td></tr>
<tr><td><code id="select_quality_+3A_alt">alt</code></td>
<td>
<p><code>data.frame</code>. A single DEXi alternative.</p>
</td></tr>
<tr><td><code id="select_quality_+3A_quality">quality</code></td>
<td>
<p>Requested <code>EnumQuality</code>: <code>"bad"</code>, <code>"good"</code> or <code>"none"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>alt</code> containing only values that have the requested quality.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+value_qualities">value_qualities()</a></code>, <code><a href="#topic+selective_explanation">selective_explanation()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load "Car.dxi"
CarDxi &lt;- system.file("extdata", "Car.dxi", package = "DEXiR")
Car &lt;- read_dexi(CarDxi)

alt &lt;- Car$alternative("MyCar",
       BUY.PRICE="low", MAINT.PRICE="*", X.PERS="more", X.DOORS="4", LUGGAGE=2, SAFETY=c(1, 3))
alte &lt;- Car$evaluate(alt)
alts &lt;- select_quality(Car, alte, "bad")
names(alts)
# c("CAR", "PRICE", "MAINT.PRICE", "TECH.CHAR.", "SAFETY")
alts &lt;- select_quality(Car, alte, "none")
names(alts)
# c("MAINT.PRICE", "X.DOORS", "LUGGAGE")
alts &lt;- select_quality(Car, alte, "good")
names(alts)
# c("CAR", "PRICE", "BUY.PRICE", "MAINT.PRICE", "TECH.CHAR.", "COMFORT", "X.PERS", "SAFETY")
</code></pre>

<hr>
<h2 id='selective_explanation'>selective_explanation</h2><span id='topic+selective_explanation'></span>

<h3>Description</h3>

<p>Selective Explanation: Displays subtrees of alternatives' values in which
values are particularly weak (value quality is &quot;bad&quot;) and
particularly strong (value quality is &quot;good&quot;).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>selective_explanation(
  model,
  alternatives = NULL,
  print = TRUE,
  as_character = FALSE,
  round = NULL,
  id = NULL,
  evaluate = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="selective_explanation_+3A_model">model</code></td>
<td>
<p>A <a href="#topic+DexiModel">DexiModel</a> object. Required.</p>
</td></tr>
<tr><td><code id="selective_explanation_+3A_alternatives">alternatives</code></td>
<td>
<p>A <code>data.frame</code> of alternatives or indices to <code>model$alternatives</code>.
The default value <code>NULL</code> selects <code>model$alternatives</code>.</p>
</td></tr>
<tr><td><code id="selective_explanation_+3A_print">print</code></td>
<td>
<p><code>logical(1)</code>. When <code>TRUE</code>, pretty print (add headings and left justify) the results,
using <code><a href="#topic+print_selective_explanation">print_selective_explanation()</a></code>.</p>
</td></tr>
<tr><td><code id="selective_explanation_+3A_as_character">as_character</code></td>
<td>
<p><code>logical(1)</code>. Whether to represent alternative values
numerically (<code>FALSE</code>) or using text (<code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="selective_explanation_+3A_round">round</code></td>
<td>
<p>An integer number, argument to <code><a href="#topic+value_text">value_text()</a></code>.</p>
</td></tr>
<tr><td><code id="selective_explanation_+3A_id">id</code></td>
<td>
<p><code>character(1)</code>.
Determines the contents of the first or first two columns of the resulting <code>data.frame</code>s:
</p>

<dl>
<dt><code>"id"</code></dt><dd><p>Attribute IDs.</p>
</dd>
<dt><code>"structure"</code></dt><dd><p>Attribute <code style="white-space: pre;">&#8288;$structure() + $name&#8288;</code>.</p>
</dd>
<dt>anything else</dt><dd><p>Equivalent to both <code>"id"</code> and <code>"structure"</code>.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="selective_explanation_+3A_evaluate">evaluate</code></td>
<td>
<p><code>logical(1)</code>. Whether or not to evaluate <code>alternatives</code> beforehand.</p>
</td></tr>
<tr><td><code id="selective_explanation_+3A_...">...</code></td>
<td>
<p>Optional parameters for <code><a href="#topic+evaluate">evaluate()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of lists: For each alternative contains a list of two data.frames, corresponding
to <code>"bad"</code> and <code>"good"</code> qualities, respectively.
May be pretty-printed using <code><a href="#topic+print_selective_explanation">print_selective_explanation()</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+value_qualities">value_qualities()</a></code>, <code><a href="#topic+value_text">value_text()</a></code>, <code><a href="#topic+print_selective_explanation">print_selective_explanation()</a></code>, <code><a href="#topic+evaluate">evaluate()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load "Car.dxi"
CarDxi &lt;- system.file("extdata", "Car.dxi", package = "DEXiR")
Car &lt;- read_dexi(CarDxi)

# Print selective explanation of two Car$alternatives.
selective_explanation(Car)

alt &lt;- Car$alternative("MyCar",
       BUY.PRICE="low", MAINT.PRICE="*", X.PERS="more", X.DOORS="4", LUGGAGE=2, SAFETY=c(1, 3))
alte &lt;- Car$evaluate(alt)

# Print selective explanation of `alte`.
selective_explanation(Car, alte)

# Print selective explanation of both `alt` and `alte`.
selective_explanation(Car, rbind.data.frame(alt, alte))
</code></pre>

<hr>
<h2 id='set_alternative'>set_alternative</h2><span id='topic+set_alternative'></span>

<h3>Description</h3>

<p>Set values of a single decision alternative and represent it with a data frame.
Usually, only input values are set in this way. The data frame can then be
<a href="#topic+evaluate">evaluate</a>d to set the values of output attributes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_alternative(model, alternative, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="set_alternative_+3A_model">model</code></td>
<td>
<p>A <a href="#topic+DexiModel">DexiModel</a> object. Required.</p>
</td></tr>
<tr><td><code id="set_alternative_+3A_alternative">alternative</code></td>
<td>
<p><code>character(1)</code> or <code>data.frame</code>. The first form sets the name of the
newly created decision alternative. The second form copies values from <code>alternative[1, ]</code>
to initialize the corresponding columns of the resulting data frame.</p>
</td></tr>
<tr><td><code id="set_alternative_+3A_...">...</code></td>
<td>
<p>A list of parameters specifying the values of the newly created decision alternative.
Each parameter is expected to be in the form <code>attribute_id=attribute_value</code>, or is a list of
elements of the same form.
</p>
<p>There are several possible ways to specify <code>attribute_value</code>.
Taking the scale <code>CAR = {"unacc"; "acc"; "good"; "exc"}</code> as an example, the options are:
</p>

<dl>
<dt><code>CAR="unacc"</code></dt><dd><p>A single qualitative value.</p>
</dd>
<dt><code>CAR=2</code></dt><dd><p>An ordinal number, indicating <code>"acc"</code> in this case.</p>
</dd>
<dt><code>CAR=c("good", "exc")</code></dt><dd><p>A set of qualitative values.</p>
</dd>
<dt><code>CAR=c(3, 4)</code></dt><dd><p>A set of ordinal numbers, equivalent to the above.</p>
</dd>
<dt><code>CAR=list("good", 4)</code></dt><dd><p>A set specified by a mixture of qualitative values and ordinal numbers.</p>
</dd>
<dt><code>CAR="*"</code></dt><dd><p>A full range of ordinal numbers, in this case equivalent to <code>1:4</code>.</p>
</dd>
<dt><code>CAR=distribution(0, 0, 0.7, 0.3)</code></dt><dd><p>A value distribution.</p>
</dd>
<dt><code>CAR=list("good"=0.7, "exc"=0.3)</code></dt><dd><p>A value distribution, equivalent to the above.</p>
</dd>
<dt><code>CAR="undef"</code></dt><dd><p>An unknown value, interpreted as <code>NA</code>.</p>
</dd>
</dl>

<p>For attributes associated with continuous scales,
only <code>numeric(1)</code> <code>attribute_value</code>s are allowed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A one-row data frame with columns corresponding to <code>model</code>'s attributes, collectively
representing a single decision alternative. The columns not copied from <code>alternative</code> (as a data frame)
nor set by any parameter contain <code>NA</code>s.
</p>


<h3>See Also</h3>

<p><a href="#topic+DEXiR-package">DEXiR-package</a> notes on values in DEXi models.
</p>

<hr>
<h2 id='set_to_distr'>set_to_distr</h2><span id='topic+set_to_distr'></span>

<h3>Description</h3>

<p>Convert a DEXi value set to DEXi value distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_to_distr(set, length = 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="set_to_distr_+3A_set">set</code></td>
<td>
<p>Normally a numeric vector containing integer numbers.</p>
</td></tr>
<tr><td><code id="set_to_distr_+3A_length">length</code></td>
<td>
<p>The required length of the resulting distribution vector. The actual length
is determined as <code>max(length, max(set))</code>, so the <code>length</code> is extended when too small
to hold the whole distribution.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <a href="#topic+distribution">distribution</a> object of length <code>length</code>. Arguments that
are already distributions are returned &quot;as is&quot;. Input vectors of length 0 and other types
of objects return <code>NA</code>.
</p>


<h3>See Also</h3>

<p><a href="#topic+DEXiR-package">DEXiR-package</a>, <a href="#topic+distribution">distribution</a>, <code><a href="#topic+distr_to_set">distr_to_set()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set_to_distr(c(1, 3, 4))
set_to_distr(c(1, 3, 4), length = 5)
set_to_distr(c(1, 3, 4), length = 0)

</code></pre>

<hr>
<h2 id='transparent_colors'>transparent_colors</h2><span id='topic+transparent_colors'></span>

<h3>Description</h3>

<p>A helper function for making <code>colors</code> transparent.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>transparent_colors(colors, percent = 50)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="transparent_colors_+3A_colors">colors</code></td>
<td>
<p>A vector of color numbers or names.</p>
</td></tr>
<tr><td><code id="transparent_colors_+3A_percent">percent</code></td>
<td>
<p>Required color transparency, in the range <code style="white-space: pre;">&#8288;[0:100]&#8288;</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Requires installed package &quot;grDevices&quot;.
</p>


<h3>Value</h3>

<p>A vector of colors of the same length as <code>colors</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>transparent_colors(c("red", "green", "blue"), 50)
# c("#FF00007F", "#00FF007F", "#0000FF7F")
</code></pre>

<hr>
<h2 id='unique_names'>unique_names</h2><span id='topic+unique_names'></span>

<h3>Description</h3>

<p>Convert <code>names</code> strings to ID strings that are unique and conformant
with R's syntactic rules for variable names.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unique_names(names, reserved = c())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="unique_names_+3A_names">names</code></td>
<td>
<p><code>character()</code>. Names to be converted to IDs.</p>
</td></tr>
<tr><td><code id="unique_names_+3A_reserved">reserved</code></td>
<td>
<p><code>character()</code>. Reserved names that should not be used as IDs.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>character()</code>.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+make.unique">base::make.unique()</a></code>]
</p>

<hr>
<h2 id='value_qualities'>value_qualities</h2><span id='topic+value_qualities'></span>

<h3>Description</h3>

<p>Returns a vector of qualities corresponding to consecutive elements of <code>value</code>.
In contrast with <code>DexiScale$value_quality(value)</code>, which can handle only single values,
this function can handle <code>value</code> arguments that contain multiple elements,
such as value sets and distributions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>value_qualities(value, scale)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="value_qualities_+3A_value">value</code></td>
<td>
<p>A DEXi value, internal representation: numeric value or vector, or <a href="#topic+distribution">distribution</a>.</p>
</td></tr>
<tr><td><code id="value_qualities_+3A_scale">scale</code></td>
<td>
<p>A <a href="#topic+DexiScale">DexiScale</a> or derived object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector consisting of <code>EnumQuality</code> elements corresponding to individual <code>value</code> elements.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>scl &lt;- DexiDiscreteScale(values = c("low", "med", "high"))
value_qualities(1, scl)       # "bad"
value_qualities(1:3, scl)     # c("bad", "none", "good")
value_qualities(c(3, 2), scl) # c("good", "none")
</code></pre>

<hr>
<h2 id='value_text'>value_text</h2><span id='topic+value_text'></span>

<h3>Description</h3>

<p>Converts a DEXi <code>value</code> to a human-readable character string that can be printed.
Used, for instance, by <code>DexiModel$as_character()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>value_text(value, scale, round = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="value_text_+3A_value">value</code></td>
<td>
<p>Any DEXi value type (see <a href="#topic+DEXiR-package">DEXiR-package</a>).</p>
</td></tr>
<tr><td><code id="value_text_+3A_scale">scale</code></td>
<td>
<p>A <a href="#topic+DexiScale">DexiScale</a> or derived object.</p>
</td></tr>
<tr><td><code id="value_text_+3A_round">round</code></td>
<td>
<p>An integer number. Indicates the number of decimals for
rounding numeric values prior to printing. If <code>NULL</code>, no rounding takes place.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>character.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>scl &lt;- DexiDiscreteScale(values = c("low", "med", "high"))
value_text(NA, scl)
value_text(1, scl)
value_text(c(1, 3), scl)
value_text(distribution(0.1, 0.2, 0.3), scl)

</code></pre>

<hr>
<h2 id='value_to_set'>value_to_set</h2><span id='topic+value_to_set'></span>

<h3>Description</h3>

<p>value_to_set
</p>


<h3>Usage</h3>

<pre><code class='language-R'>value_to_set(value, scale)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="value_to_set_+3A_value">value</code></td>
<td>
<p>A DEXi value, internal representation: numeric value or vector, or <a href="#topic+distribution">distribution</a>.</p>
</td></tr>
<tr><td><code id="value_to_set_+3A_scale">scale</code></td>
<td>
<p>A <a href="#topic+DexiScale">DexiScale</a> or derived object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An integer vector or <code>NA</code> for: non-discrete scale, <code>NA</code>/<code>NULL</code> value(s), non-integer value(s).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>scl &lt;- DexiDiscreteScale(values = c("low", "med", "high"))
value_to_set(1, scl)                       # 1
value_to_set(1:2, scl)                     # c(1, 2)
value_to_set(c(1,3), scl)                  # c(1, 3)
value_to_set(distribution(1, 0, 0.5), scl) # c(1, 3)
</code></pre>

<hr>
<h2 id='values_to_str'>values_to_str</h2><span id='topic+values_to_str'></span>

<h3>Description</h3>

<p>Convert numbers to a DEXi string. Implements the reverse operation of <code><a href="#topic+rule_values">rule_values()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>values_to_str(vals, add = 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="values_to_str_+3A_vals">vals</code></td>
<td>
<p>Numeric vector, containing ordinal values.</p>
</td></tr>
<tr><td><code id="values_to_str_+3A_add">add</code></td>
<td>
<p>An integer constant to be added to <code>vals</code> prior to conversion.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A string representing DEXi's representation of ordinal values. Fails when
<code>vals + add</code> contains negative numbers.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>values_to_str(c(0, 1, 1, 2, 2, 10, 12))
values_to_str(c(1, 2, 2, 3, 3, 11, 13), -1)

</code></pre>

<hr>
<h2 id='write_alternatives'>write_alternatives</h2><span id='topic+write_alternatives'></span>

<h3>Description</h3>

<p>Write out <code>alternatives</code>' data. First convert DEXi alternatives to a data frame using
<code><a href="#topic+export_alternatives">export_alternatives()</a></code> and then write it to a file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write_alternatives(
  model,
  alternatives = NULL,
  file = "",
  quote = FALSE,
  format = c("tab", "csv", "csv2"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="write_alternatives_+3A_model">model</code></td>
<td>
<p>A <a href="#topic+DexiModel">DexiModel</a> object. Required.</p>
</td></tr>
<tr><td><code id="write_alternatives_+3A_alternatives">alternatives</code></td>
<td>
<p>A <code>data.frame</code> of alternatives (normally an output of <code><a href="#topic+evaluate">evaluate()</a></code>) or
indices to <code>model$alternatives</code>. The default value <code>NULL</code> selects <code>model$alternatives</code>.</p>
</td></tr>
<tr><td><code id="write_alternatives_+3A_file">file</code></td>
<td>
<p>Write the data frame contents to a file.
When <code>file = ""</code>, the contents is written to the console (default).
<code>file = "clipboard"</code> might also work to copy the contents to the clipboard.</p>
</td></tr>
<tr><td><code id="write_alternatives_+3A_quote">quote</code></td>
<td>
<p><code>logical(1)</code>. Whether or not to quote output character strings.</p>
</td></tr>
<tr><td><code id="write_alternatives_+3A_format">format</code></td>
<td>
<p>One of <code>"tab"</code>, <code>"csv"</code> or <code>"csv2"</code> to
invoke <code><a href="utils.html#topic+write.table">write.table()</a></code>, <code><a href="utils.html#topic+write.csv">write.csv()</a></code> or <code><a href="utils.html#topic+write.csv2">write.csv2()</a></code>, respectively.</p>
</td></tr>
<tr><td><code id="write_alternatives_+3A_...">...</code></td>
<td>
<p>Optional parameters to <code><a href="utils.html#topic+write.table">write.table()</a></code> functions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Writes a &quot;tab&quot;- or &quot;csv&quot;-formatted <code>alternatives</code>' data to a file,
console or clipboard. This data is meant to be subsequently imported to
'DEXi' software.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+export_alternatives">export_alternatives()</a></code>, <code><a href="utils.html#topic+write.table">write.table()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load "Car.dxi"
CarDxi &lt;- system.file("extdata", "Car.dxi", package = "DEXiR")
Car &lt;- read_dexi(CarDxi)

# Write both Car alternatives to console
write_alternatives(Car, file = "")
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
