<!DOCTYPE html><html><head><title>Help for package groupedSurv</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {groupedSurv}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#groupedSurv-package'>
<p>Efficient Estimation of Grouped Survival Models Using the Exact Likelihood Function</p></a></li>
<li><a href='#alphaEstFam'>
<p>Estimate the Interval Baseline Survival Rates for the Grouped Failure Time Model</p></a></li>
<li><a href='#betaEst'>
<p>Estimate the Parameter of Interest for the Grouped Survival Model</p></a></li>
<li><a href='#betaEstFam'>
<p>Estimate the Fixed Effect Parameter for the Frailty Model</p></a></li>
<li><a href='#geneStat'>
<p>Compute Gene-Level Statistics Based on Efficient Score Statistics for the Grouped Survival Model</p></a></li>
<li><a href='#groupedSurv'>
<p>Compute the Efficient Score Statistic for the Grouped Survival Model</p></a></li>
<li><a href='#groupedSurvFam'>
<p>Compute the Efficient Score Statistic for the Frailty Model</p></a></li>
<li><a href='#PvalueFam'>
<p>Estimate P-values of the Efficient Score Statistics for the Frailty Model</p></a></li>
<li><a href='#thetaEst'>
<p>Estimate the Baseline Survival Rates and Covariate Parameters for the Grouped Survival Model</p></a></li>
<li><a href='#varEstFam'>
<p>Estimate the Frailty Variance for the Frailty Model</p></a></li>
<li><a href='#varLLFam'>
<p>Log-Likelihood of the Frailty Variance for the Discrete-Time Frailty Model</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Efficient Estimation of Grouped Survival Models Using the Exact
Likelihood Function</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.5.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-09-28</td>
</tr>
<tr>
<td>Author:</td>
<td>Jiaxing Lin [aut], 
  Alexander Sibley [aut], 
  Tracy Truong [aut], 
  Kouros Owzar [aut], 
  Zhiguo Li [aut],
  Layne Rogers [ctb],
  Yu Jiang [ctb], 
  Janice McCarthy [ctb], 
  Andrew Allen [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Alexander Sibley &lt;dcibioinformatics@duke.edu&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>These 'Rcpp'-based functions compute the efficient score statistics for grouped time-to-event data (Prentice and Gloeckler, 1978), with the optional inclusion of baseline covariates. Functions for estimating the parameter of interest and nuisance parameters, including baseline hazards, using maximum likelihood are also provided. A parallel set of functions allow for the incorporation of family structure of related individuals (e.g., trios). Note that the current implementation of the frailty model (Ripatti and Palmgren, 2000) is sensitive to departures from model assumptions, and should be considered experimental. For these data, the exact proportional-hazards-model-based likelihood is computed by evaluating multiple variable integration. The integration is accomplished using the 'Cuba' library (Hahn, 2005), and the source files are included in this package. The maximization process is carried out using Brent's algorithm, with the C++ code file from John Burkardt and John Denker (Brent, 2002).</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 0.12.4), doParallel, parallel, foreach, qvalue</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppEigen, BH</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, snplist, BEDMatrix</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>BuildVignettes:</td>
<td>yes</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.0.1</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-09-28 19:10:36 UTC; lwr11</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-09-28 20:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='groupedSurv-package'>
Efficient Estimation of Grouped Survival Models Using the Exact Likelihood Function
</h2><span id='topic+groupedSurv-package'></span>

<h3>Description</h3>

<p>These <code>Rcpp</code>-based functions compute the efficient score statistics for grouped time-to-event data (Prentice and Gloeckler, 1978), with the optional inclusion of baseline covariates. Functions for estimating the parameter of interest and nuisance parameters, including baseline hazards, using maximum likelihood are also provided. A parallel set of functions allow for the incorporation of family structure of related individuals (e.g., trios). Note that the current implementation of the frailty model (Ripatti and Palmgren, 2000) is sensitive to departures from model assumptions, and should be considered experimental. For these data, the exact proportional-hazards-model-based likelihood is computed by evaluating multiple variable integration. The integration is accomplished using the <code>Cuhre</code> algorithm from the <code>Cuba</code> library (Hahn, 2005), and the source files of the <code>Cuhre</code> function are included in this package. The maximization process is carried out using Brent's algorithm, with the <code>C++</code> code file from John Burkardt and John Denker (Brent, 2002). 
</p>
<p>License: GPL (&gt;= 2)</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> groupedSurv</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 1.0.5.1</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2023-09-28</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL-3</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>Please refer to the individual function documentation or the included vignette for more information. The package vignette serves as a tutorial for using this package.
</p>


<h3>Author(s)</h3>

<p>Jiaxing Lin <a href="mailto:jiaxing.lin@duke.edu">jiaxing.lin@duke.edu</a>, Alexander Sibley, Tracy Truong, Kouros Owzar, Zhiguo Li; Contributors: Yu Jiang, Janice McCarthy, Andrew Allen
</p>


<h3>References</h3>

<p>Prentice, R.L. and Gloeckler, L.A. (1978). Regression analysis of grouped survival data with application to breast cancer data. Biometrics, 34:1, 57-67.<br />
Ripatti, S. and Palmgren, J. (2000). Estimation of Multivariate Frailty Models Using Penalized Partial Likelihood. Biometrics, 56, 1016-1022.<br />
Hahn, T. (2005). Cuba-a library for multidimensional numerical integration, Computer Physics Communications, 168, 78-95.<br />
Brent, R. (2002). Algorithms for Minimization without Derivatives. Dover, ISBN 0-486-41998-3
</p>

<hr>
<h2 id='alphaEstFam'>
Estimate the Interval Baseline Survival Rates for the Grouped Failure Time Model
</h2><span id='topic+alphaEstFam'></span>

<h3>Description</h3>

<p>A method to estimate the baseline survival rate for each time interval for a grouped failure time model. The estimation is conducted under the null hypothesis, i.e., that there is no effect from the variable of interest, and is naive to family structure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  alphaEstFam(gtime, delta)  	
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="alphaEstFam_+3A_gtime">gtime</code></td>
<td>
<p>Vector of observed survival times for each sample.</p>
</td></tr>
<tr><td><code id="alphaEstFam_+3A_delta">delta</code></td>
<td>
<p>Vector of event indicators for each sample: 1 indicates observed event, 0 indicates censored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector of estimates of the baseline survival rates for each time interval.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate dummy data	
gtime &lt;- c(1, 3, 3, 2, 1, 1, 2, 3, 1)
delta &lt;- c(1, 0, 1, 1, 1, 0, 1, 0, 1)

#res   &lt;- alphaEstFam(gtime, delta) 
#res
</code></pre>

<hr>
<h2 id='betaEst'>
Estimate the Parameter of Interest for the Grouped Survival Model
</h2><span id='topic+betaEst'></span>

<h3>Description</h3>

<p>A method to estimate the parameter of interest given the baseline survival rates for each time interval and optional covariate nuisance parameters for a grouped survival model. The function supports zero, single, or multiple covariates as dictated by the input data. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  betaEst(x, Z=NULL, alpha, theta=NULL, gtime, delta)  	
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="betaEst_+3A_x">x</code></td>
<td>
<p>Vector of numeric variable of interest for each sample.</p>
</td></tr>
<tr><td><code id="betaEst_+3A_z">Z</code></td>
<td>
<p>Optional <code>data.frame</code> or <code>matrix</code> of numeric covariate values for each sample.</p>
</td></tr>
<tr><td><code id="betaEst_+3A_alpha">alpha</code></td>
<td>
<p>Vector of baseline survival rates for each time interval.</p>
</td></tr>
<tr><td><code id="betaEst_+3A_theta">theta</code></td>
<td>
<p>Optional vector of estimated nuisance parameters for the covariates.</p>
</td></tr>
<tr><td><code id="betaEst_+3A_gtime">gtime</code></td>
<td>
<p>Vector of observed survival times for each sample.</p>
</td></tr>
<tr><td><code id="betaEst_+3A_delta">delta</code></td>
<td>
<p>Vector of event indicators for each sample: 1 indicates observed event, 0 indicates censored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Scalar estimate of the parameter of interest.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate dummy data	
x     &lt;- c(1, 0, 1, 1, 1, 0, 1, 0, 1)
cov1  &lt;- c(1, 2, 2, 2, 1, 1, 0, 1, 1)
cov2  &lt;- c(2, 2, 1, 0, 1, 0, 1, 1, 0.5) 
Z     &lt;- cbind(cov1, cov2)
gtime &lt;- c(1, 3, 3, 2, 1, 1, 2, 3, 1)
delta &lt;- c(1, 0, 1, 1, 1, 0, 1, 0, 1)

#theta &lt;- thetaEst(Z, gtime, delta) 

#res   &lt;- betaEst(x, Z, theta$alpha, theta$theta, gtime, delta) 
#res
</code></pre>

<hr>
<h2 id='betaEstFam'>
Estimate the Fixed Effect Parameter for the Frailty Model
</h2><span id='topic+betaEstFam'></span>

<h3>Description</h3>

<p>A method to estimate the fixed effect parameter for a frailty model accounting for family structure of related individuals (e.g., trios). The input data is assumed to be organized such that records for each family occur consecutively, and that records for offspring precede those for parents. The variance matrix for the random effects is assumed to be of the form <code>var*K</code>, where <code>K</code> is a matrix of kinship coefficients between family members. The following family structures are permitted: (Individual), (Offspring, Offspring), (Offspring, Parent), (Offspring, Parent, Parent), and (Offspring, Offspring, Parent, Parent). Other family structures have not been implemented. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  betaEstFam(x, fam_group, fam_role, alpha, var, gtime, delta, lower, upper)  	
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="betaEstFam_+3A_x">x</code></td>
<td>
<p>Vector of numeric variables of interest for each sample.</p>
</td></tr>
<tr><td><code id="betaEstFam_+3A_fam_group">fam_group</code></td>
<td>
<p>Vector of family IDs for each sample.</p>
</td></tr>
<tr><td><code id="betaEstFam_+3A_fam_role">fam_role</code></td>
<td>
<p>Vector of indicators for the role within a family of each sample, i.e., {&quot;Offspring&quot;,&quot;Mother&quot;,&quot;Father&quot;}, or {&quot;o&quot;,&quot;m&quot;,&quot;f&quot;}.</p>
</td></tr>
<tr><td><code id="betaEstFam_+3A_alpha">alpha</code></td>
<td>
<p>Vector of baseline survival rates for each time interval.</p>
</td></tr>
<tr><td><code id="betaEstFam_+3A_var">var</code></td>
<td>
<p>Scalar for frailty variance.</p>
</td></tr>
<tr><td><code id="betaEstFam_+3A_gtime">gtime</code></td>
<td>
<p>Vector of observed survival times for each sample.</p>
</td></tr>
<tr><td><code id="betaEstFam_+3A_delta">delta</code></td>
<td>
<p>Vector of event indicators for each sample: 1 indicates observed event, 0 indicates censored.</p>
</td></tr>
<tr><td><code id="betaEstFam_+3A_lower">lower</code></td>
<td>
<p>Scalar for the lower bound of the fixed effect parameter estimation search region.</p>
</td></tr>
<tr><td><code id="betaEstFam_+3A_upper">upper</code></td>
<td>
<p>Scalar for the upper bound of the fixed effect parameter estimation search region.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Scalar estimate of the fixed effect parameter.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate dummy data	
x     &lt;- c(0, 1, 1, 1, 2, 2, 0, 0, 0)
fam_group &lt;- c('1', '1', '1', '2', '2', '2', '3', '3', '3')
fam_role  &lt;- c("o","f","m","o","f","m","o","f","m")
alpha &lt;- c(0.7500000, 0.6666667, 0.5000000, 0.0000000)
var   &lt;- 0.2
gtime &lt;- c(1, 3, 3, 2, 1, 1, 2, 3, 1)
delta &lt;- c(1, 0, 1, 1, 1, 0, 1, 0, 1)
lower &lt;- 0
upper &lt;- 2

#res   &lt;- betaEstFam(x, fam_group, fam_role, alpha, var, gtime, delta, lower, upper) 
#res
</code></pre>

<hr>
<h2 id='geneStat'>
Compute Gene-Level Statistics Based on Efficient Score Statistics for the Grouped Survival Model
</h2><span id='topic+geneStat'></span>

<h3>Description</h3>

<p>A method to compute gene-level statistics using the contributions of individual samples to the efficient score statistics of SNPs under a grouped survival model. The function supports zero, single, or multiple covariates as dictated by the input data. The function can take either a <code>gwaa.data</code> object or a standard <code>data.frame</code> or <code>matrix</code> as input. The contribution of each sample to the efficient score will be computed separately for each SNP being tested, and then gene-level statistics will be computed using either the default Sequence Kernel Association Test (SKAT) or a user-provided function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>	geneStat(x, Z=NULL, GenABEL.data=NULL, alpha, theta=NULL, gtime, delta,
           beta=0, nCores=1, 
           FUN=function(Uij,weight){sum((colSums(Uij)*weight)^2)}, geneSet)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geneStat_+3A_x">x</code></td>
<td>
<p>Vector, <code>data.frame</code>, or <code>matrix</code>  of numeric variables of interest for each sample. Alternatively, if a <code>gwaa.data</code> object is given for <code>GenABEL.data</code>, this argument may be a vector of strings corresponding to column names in <code>GenABEL.data@gtdata</code> to use as variables of interest.</p>
</td></tr>  
<tr><td><code id="geneStat_+3A_z">Z</code></td>
<td>
<p>Optional <code>data.frame</code> or <code>matrix</code> of numeric covariate values for each sample. Alternatively, if a <code>gwaa.data</code> object is given for <code>GenABEL.data</code>, this argument may be a vector of strings corresponding to column names in <code>GenABEL.data@phdata</code> to use as covariates.</p>
</td></tr>
<tr><td><code id="geneStat_+3A_genabel.data">GenABEL.data</code></td>
<td>
<p>Optional <code>gwaa.data</code> object.</p>
</td></tr>
<tr><td><code id="geneStat_+3A_alpha">alpha</code></td>
<td>
<p>Vector of baseline survival rates for each time interval.</p>
</td></tr>
<tr><td><code id="geneStat_+3A_theta">theta</code></td>
<td>
<p>Optional vector of estimated nuisance parameters for the covariates.</p>
</td></tr>
<tr><td><code id="geneStat_+3A_gtime">gtime</code></td>
<td>
<p>Vector of observed survival times for each sample.</p>
</td></tr>
<tr><td><code id="geneStat_+3A_delta">delta</code></td>
<td>
<p>Vector of event indicators for each sample: 1 indicates observed event, 0 indicates censored.</p>
</td></tr>
<tr><td><code id="geneStat_+3A_beta">beta</code></td>
<td>
<p>Scalar for the parameter of interest. Default is 0.</p>
</td></tr>
<tr><td><code id="geneStat_+3A_ncores">nCores</code></td>
<td>
<p>Integer representing the number of cores to be used for multi-threaded computation. Default is 1.</p>
</td></tr>
<tr><td><code id="geneStat_+3A_fun">FUN</code></td>
<td>
<p>A function to compute the gene-level statistics base on the SNP-level efficient scores. The function arguments should include a matrix of each samples' contribution to the efficient scores, <code>Uij</code>, and a vector of weights, <code>weight</code>. Default is the SKAT statistic.</p>
</td></tr>
<tr><td><code id="geneStat_+3A_geneset">geneSet</code></td>
<td>
<p>A list of lists, where each sub-list contains two vectors: a vector of column names of the variables of interest to be included in that set, and a vector of numerical weights corresponding to each specified variable of interest.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>list</code> with two elements: <code>stat</code>, a list of return objects from the default or user-defined <code>FUN</code>, and <code>U</code>, a list of matrices of the contribution of each subject to the efficient score statistics for each SNP in each gene set. Rows correspond to samples, and columns correspond to the variables of interest.
</p>


<h3>References</h3>

<p>Wu, M.C., Lee, S., Cai, T., Li, Y., Boehnke, M. and Lin, X. (2011). Rare-variant association testing for sequencing data with the sequence kernel association test. American Journal of Human Genetics, 89:1, 82-93.<br />
Ionita-Laza, I., Lee, S., Makarov, V., Buxbaum, J.D., and Lin, X. (2013). Sequence kernel association tests for the combined effect of rare and common variants. American Journal of Human Genetics, 92:6, 841-53.<br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate dummy data
rm(list=ls())
set.seed(111)
n &lt;- 1000

# covariate parameters
theta &lt;- c(0.2, 0.2)

# covariate data (centered at 0)
z1 &lt;- rnorm(n)
z2 &lt;- rbinom(n, 1, 0.5) - 0.5
Z &lt;- matrix(cbind(z1, z2), ncol = 2)

# continuous survival time
lam0 &lt;- 1
cmax &lt;- 3
lami &lt;- lam0 * exp(Z[,1]*theta[1]+Z[,2]*theta[2])
stime &lt;- rexp(n, lami)
ctime &lt;- runif(n, 0, cmax)
delta &lt;- stime &lt; ctime
otime &lt;- pmin(stime, ctime)

# number of observation times
ntps &lt;- 5

# number of intervals
r &lt;- ntps + 1

# last observation time
maxbreakq &lt;- 0.85
maxbreak &lt;- qexp(maxbreakq, lam0)

# grouped survival times
breaks &lt;- (1:ntps) * (maxbreak/ntps)
gtime &lt;- findInterval(otime, breaks) + 1
delta[gtime == r] &lt;- FALSE
dctime &lt;- findInterval(ctime, breaks) + 1
delta[gtime == dctime] &lt;- FALSE
delta &lt;- as.numeric(delta)
gtime[which(gtime == r)] &lt;- Inf

# estimate nuisance parameters
#thetaest &lt;- thetaEst(Z, gtime, delta)

# SNP and gene information
#geneInfo &lt;- data.frame(gene=c("BRCA1","BRCA2"), chr=c(17,13),
#                       start=c(41196312, 32889611), end=c(41277500, 32973805),
#                       stringsAsFactors=FALSE)
#snpInfo &lt;- data.frame(chr=c(17,17,13,13),
#                      pos=c(41211653,41213996,32890026,32890572),
#                      rsid=c("rs8176273","rs8176265","rs9562605","rs1799943"),
#                      stringsAsFactors=FALSE)

# use snplist package to create gene sets
#library(snplist)
#setGeneTable(geneInfo)
#setSNPTable(snpInfo)
#geneset &lt;- makeGeneSet()

# simulate sample values for SNPs
#G &lt;- matrix(rbinom(n*nrow(snpInfo), 2, 0.5), ncol=nrow(snpInfo))
#colnames(G) &lt;- snpInfo$rsid

# dummy weights for the SNPs in the gene sets
#for(i in seq_len(length(geneset))){
#    weight &lt;- rep(1, length(geneset[[i]]))
#    geneset[[i]] &lt;- list(geneset[[i]], weight)

#}

# compute gene-level statistics based on the default SKAT function
#res &lt;- geneStat(x=G, Z=Z, alpha=thetaest$alpha, theta=thetaest$theta,
#                gtime=gtime, delta=delta, geneSet=geneset, beta=0, nCores=1)
#res$stat
</code></pre>

<hr>
<h2 id='groupedSurv'>
Compute the Efficient Score Statistic for the Grouped Survival Model
</h2><span id='topic+groupedSurv'></span>

<h3>Description</h3>

<p>A method to compute the efficient score statistic for a grouped survival model. The function supports zero, single, or multiple covariates as dictated by the input data. The function can take either a <code>gwaa.data</code> object or a standard <code>data.frame</code> or <code>matrix</code> as input. If more than one variable of interest is provided, the efficient score will be computed for each one separately. For each variable tested, the function returns the unadjusted marginal asymptotic p-value, as well as the family-wise error rate (FWER, Bonferroni correction) adjusted p-value and local false-discovery rates (FDR, Storey's Q-values).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  groupedSurv(x, Z=NULL, GenABEL.data=NULL, alpha, theta=NULL, 
    gtime, delta, beta=0, nCores=1, reScore=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="groupedSurv_+3A_x">x</code></td>
<td>
<p>Vector, <code>data.frame</code>, or <code>matrix</code> of numeric variables of interest for each sample. Alternatively, if a <code>gwaa.data</code> object is given for <code>GenABEL.data</code>, this argument may be a vector of strings corresponding to column names in <code>GenABEL.data@gtdata</code> to use as variables of interest, set <code>NULL</code> will use all the variables in <code>GenABEL.data@gtdata</code> as variables of interest.</p>
</td></tr>  
<tr><td><code id="groupedSurv_+3A_z">Z</code></td>
<td>
<p>Optional <code>data.frame</code> or <code>matrix</code> of numeric covariate values for each sample. Alternatively, if a <code>gwaa.data</code> object is given for <code>GenABEL.data</code>, this argument may be a vector of strings corresponding to column names in <code>GenABEL.data@phdata</code> to use as covariates.</p>
</td></tr>
<tr><td><code id="groupedSurv_+3A_genabel.data">GenABEL.data</code></td>
<td>
<p>Optional <code>gwaa.data</code> object.</p>
</td></tr>
<tr><td><code id="groupedSurv_+3A_alpha">alpha</code></td>
<td>
<p>Vector of baseline survival rates for each time interval.</p>
</td></tr>
<tr><td><code id="groupedSurv_+3A_theta">theta</code></td>
<td>
<p>Optional vector of estimated nuisance parameters for the covariates.</p>
</td></tr>
<tr><td><code id="groupedSurv_+3A_gtime">gtime</code></td>
<td>
<p>Vector of observed survival times for each sample.</p>
</td></tr>
<tr><td><code id="groupedSurv_+3A_delta">delta</code></td>
<td>
<p>Vector of event indicators for each sample: 1 indicates observed event, 0 indicates censored.</p>
</td></tr>
<tr><td><code id="groupedSurv_+3A_beta">beta</code></td>
<td>
<p>Scalar for the parameter of interest. Default is 0.</p>
</td></tr>
<tr><td><code id="groupedSurv_+3A_ncores">nCores</code></td>
<td>
<p>Integer representing the number of cores to be used for multi-threaded computation. Default is 1.</p>
</td></tr>
<tr><td><code id="groupedSurv_+3A_rescore">reScore</code></td>
<td>
<p>Boolean indicating whether to return the full efficient scores matrix. Default is <code>FALSE</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>reScore=FALSE</code>, the function returns a <code>data.frame</code> with one row for each variables of interest and four columns: <code>stat</code>, the efficient score statistic, <code>pvalue</code>, unadjusted p-value, <code>FWER</code>, the family-wise error rate adjusted p-value (Bonferroni correction), and <code>FDR</code>, the local false-discovery rate (Storey's Q-value). If <code>reScore=TRUE</code>, a <code>list</code> is returned. The first element is the <code>data.frame</code> of efficient score statistics and p-values, and the second is a matrix of contributions of each sample to the efficient score statistics of each variable of interest. Rows correspond to samples, and columns correspond to the variables of interest.
</p>


<h3>References</h3>

<p>Bonferroni, C.E. (1935). Il calcolo delle assicurazioni su gruppi di teste. Studi in Onore del Professore Salvatore Ortu Carbon, 13-60.<br />
Storey, J.D. (2003). The positive false discovery rate: a Bayesian interpretation and the q-value. Annals of Statistics, 31:6, 2013-2035.<br />
Storey, J.D., Taylor, J.E., and Siegmund, D. (2004). Strong control, conservative point estimation and simultaneous conservative consistency of false discovery rates: a unified approach. Journal of the Royal Statistical Society Series B-Statistical Methodology, 66, 187-205<br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate dummy data
set.seed(111)
n &lt;- 1000

# effect size
beta &lt;- 0.4

# covariate parameters
theta &lt;- c(0.2, 0.2)

# variable of interest associated with outcome
MAF &lt;- 0.05
x &lt;- matrix(rbinom(n, 2, MAF), ncol = 1)

# covariate data (centered at 0)
z1 &lt;- rnorm(n)
z2 &lt;- rbinom(n, 1, 0.5) - 0.5
Z  &lt;- matrix(cbind(z1, z2), ncol = 2)

# continuous survival time
lam0 &lt;- 1
cmax &lt;- 3
lami &lt;- lam0 * exp(x*beta + Z[,1]*theta[1]+Z[,2]*theta[2])
stime &lt;- rexp(n, lami)
ctime &lt;- runif(n, 0, cmax)
delta &lt;- stime &lt; ctime
otime &lt;- pmin(stime, ctime)

# additional variables of interest
xMore &lt;- matrix(rbinom(n*100, 2, MAF), ncol = 100)
xMore &lt;- cbind(x, xMore)

# number of observation times
ntps &lt;- 5

# number of intervals
r &lt;- ntps + 1

# last observation time
maxbreakq &lt;- 0.85
maxbreak &lt;- qexp(maxbreakq, lam0)

# grouped failure times
breaks &lt;- (1:ntps) * (maxbreak/ntps)
gtime &lt;- findInterval(otime, breaks) + 1
delta[gtime == r] &lt;- FALSE
dctime &lt;- findInterval(ctime, breaks) + 1
delta[gtime == dctime] &lt;- FALSE
delta &lt;- as.numeric(delta)
gtime[which(gtime == r)] &lt;- Inf

# estimate nuisance parameters
#thetaest &lt;- thetaEst(Z, gtime, delta)

# compute efficient score statistics
# eff &lt;- groupedSurv(x=xMore, Z=Z, alpha=thetaest$alpha, theta=thetaest$theta,
#		gtime=gtime, delta=delta, beta=0, nCores=1)
# head(eff)
</code></pre>

<hr>
<h2 id='groupedSurvFam'>
Compute the Efficient Score Statistic for the Frailty Model
</h2><span id='topic+groupedSurvFam'></span>

<h3>Description</h3>

<p>A method to compute the efficient score statistic for a frailty model,
accounting for family structure of related individuals (e.g., trios). The
input data is assumed to be organized such that records for each family occur
consecutively, and that records for offspring precede those for parents. The
variance matrix for the random effects is assumed to be of the form
<code>var*K</code>, where <code>K</code> is a matrix of kinship coefficients between
family members. The following groupings are permitted: (Individual),
(Offspring, Offspring), (Offspring, Parent), (Offspring, Parent, Parent), and
(Offspring, Offspring, Parent, Parent). Other family structures have not been
implemented. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  groupedSurvFam(x, fam_group, fam_role, alpha, var, gtime, delta, beta=0, nCores=1)  	
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="groupedSurvFam_+3A_x">x</code></td>
<td>
<p>Vector or <code>matrix</code> of numeric variables of interest for each sample.</p>
</td></tr>
<tr><td><code id="groupedSurvFam_+3A_fam_group">fam_group</code></td>
<td>
<p>Vector of family IDs for each sample.</p>
</td></tr>
<tr><td><code id="groupedSurvFam_+3A_fam_role">fam_role</code></td>
<td>
<p>Vector of indicators for the role within a family of each sample, i.e., {&quot;Offspring&quot;,&quot;Mother&quot;,&quot;Father&quot;}, or {&quot;o&quot;,&quot;m&quot;,&quot;f&quot;}.</p>
</td></tr>
<tr><td><code id="groupedSurvFam_+3A_alpha">alpha</code></td>
<td>
<p>Vector of baseline survival rates for each time interval.</p>
</td></tr>
<tr><td><code id="groupedSurvFam_+3A_var">var</code></td>
<td>
<p>Scalar for frailty variance.</p>
</td></tr>
<tr><td><code id="groupedSurvFam_+3A_gtime">gtime</code></td>
<td>
<p>Vector of observed survival times for each sample.</p>
</td></tr>
<tr><td><code id="groupedSurvFam_+3A_delta">delta</code></td>
<td>
<p>Vector of event indicators for each sample: 1 indicates observed event, 0 indicates censored.</p>
</td></tr>
<tr><td><code id="groupedSurvFam_+3A_beta">beta</code></td>
<td>
<p>Scalar for the fixed effect size. Default is 0.</p>
</td></tr>
<tr><td><code id="groupedSurvFam_+3A_ncores">nCores</code></td>
<td>
<p>Integer representing the number of cores to be used for multi-threaded computation. Default is 1.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Matrix of contributions of each family to the efficient score statistics of each variable of interest. Rows correspond to families, and columns correspond to the variables of interest.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate dummy data
set.seed(111)
n &lt;- 24

# effect size
beta &lt;- 0.3

# covariate parameters
theta &lt;- c(0.2, 0.2)

# variable of interest
MAF &lt;- 0.05
x &lt;- matrix(rbinom(n, 2, MAF), ncol = 1)

# covariate data (centered at 0)
z1 &lt;- rnorm(n)
z2 &lt;- rbinom(n, 1, 0.5) - 0.5
Z  &lt;- matrix(cbind(z1, z2), ncol = 2)

# continuous survival time
lam0 &lt;- 1
cmax &lt;- 3
lami &lt;- lam0 * exp(x*beta + Z[,1]*theta[1]+Z[,2]*theta[2])
stime &lt;- rexp(n, lami)
ctime &lt;- runif(n, 0, cmax)
delta &lt;- stime &lt; ctime
otime &lt;- pmin(stime, ctime)

# number of observation times
ntps &lt;- 5

# number of intervals
r &lt;- ntps + 1

# last observation time
maxbreakq &lt;- 0.85
maxbreak &lt;- qexp(maxbreakq, lam0)

# grouped failure times
breaks &lt;- (1:ntps) * (maxbreak/ntps)
gtime &lt;- findInterval(otime, breaks) + 1
delta[gtime == r] &lt;- FALSE
dctime &lt;- findInterval(ctime, breaks) + 1
delta[gtime == dctime] &lt;- FALSE
delta &lt;- as.numeric(delta)

# family-specific information
m &lt;- n/3
fam_role &lt;- rep(c("o","f","m"),m)
fam_group &lt;- as.character(rep(1:m,rep(3,m)))

# nuisance parameters
#alpha &lt;- thetaEst(Z, gtime,delta)$alpha
#var &lt;- 0.2

# compute efficient score statistics
#res   &lt;- groupedSurvFam(x, fam_group, fam_role, alpha, var, gtime, delta) 
#res
</code></pre>

<hr>
<h2 id='PvalueFam'>
Estimate P-values of the Efficient Score Statistics for the Frailty Model
</h2><span id='topic+PvalueFam'></span>

<h3>Description</h3>

<p>A method to estimate the p-value for the efficient score statistics for the frailty model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  PvalueFam(U)  	
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PvalueFam_+3A_u">U</code></td>
<td>
<p><code>Matrix</code> of contributions of each family to the efficient score statistics of each variable of interest, (i.e., the output from <code>groupedSurvFam</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code> with one row for each variables of interest and four columns: <code>stat</code>, the efficient score statistic, <code>pvalue</code>, unadjusted p-value, <code>FWER</code>, the family-wise error rate adjusted p-value (Bonferroni correction), and <code>FDR</code>, the local false-discovery rate (Storey's Q-value).
</p>


<h3>References</h3>

<p>Bonferroni, C.E. (1935). Il calcolo delle assicurazioni su gruppi di teste. Studi in Onore del Professore Salvatore Ortu Carbon, 13-60.<br />
Storey, J.D. (2003). The positive false discovery rate: a Bayesian interpretation and the q-value. Annals of Statistics, 31:6, 2013-2035.<br />
Storey, J.D., Taylor, J.E., and Siegmund, D. (2004). Strong control, conservative point estimation and simultaneous conservative consistency of false discovery rates: a unified approach. Journal of the Royal Statistical Society Series B-Statistical Methodology, 66, 187-205<br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate dummy data	
U &lt;- matrix(rnorm(10000), ncol=50)

#res   &lt;- PvalueFam(U) 
#res
</code></pre>

<hr>
<h2 id='thetaEst'>
Estimate the Baseline Survival Rates and Covariate Parameters for the Grouped Survival Model
</h2><span id='topic+thetaEst'></span>

<h3>Description</h3>

<p>A method to estimate the baseline survival rate for each time interval and the covariate nuisance parameters for a grouped survival model. The estimation is conducted under the null hypothesis, i.e., that there is no effect from the variable of interest.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  thetaEst(Z=NULL, gtime, delta, method="BFGS")  	
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="thetaEst_+3A_z">Z</code></td>
<td>
<p>Optional <code>data.frame</code> or <code>matrix</code> of numeric covariate values for each sample.</p>
</td></tr>
<tr><td><code id="thetaEst_+3A_gtime">gtime</code></td>
<td>
<p>Vector of observed survival times for each sample.</p>
</td></tr>
<tr><td><code id="thetaEst_+3A_delta">delta</code></td>
<td>
<p>Vector of event indicators for each sample: 1 indicates observed event, 0 indicates censored.</p>
</td></tr>
<tr><td><code id="thetaEst_+3A_method">method</code></td>
<td>
<p>String indicating optimization method, passed to <code>stats::optim</code>. Supports <code>"BFGS"</code> and <code>"CG"</code>. Default is <code>"BFGS"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing two vectors: <code>alpha</code>, the baseline survival rate for each time interval, and <code>theta</code>, the estimated nuisance parameters of the covariates.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate dummy data	
cov1  &lt;- c(1, 2, 2, 2, 1, 1, 0, 1, 1)
cov2  &lt;- c(2, 2, 1, 0, 1, 0, 1, 1, 0.5) 
Z     &lt;- cbind(cov1, cov2)
gtime &lt;- c(1, 3, 3, 2, 1, 1, 2, 3, 1)
delta &lt;- c(1, 0, 1, 1, 1, 0, 1, 0, 1)

#res   &lt;- thetaEst(Z, gtime, delta) 
#res
</code></pre>

<hr>
<h2 id='varEstFam'>
Estimate the Frailty Variance for the Frailty Model
</h2><span id='topic+varEstFam'></span>

<h3>Description</h3>

<p>A method to estimate the frailty variance for a frailty model accounting for family structure of related individuals (e.g., trios). The input data is assumed to be organized such that records for each family occur consecutively, and that records for offspring precede those for parents. The variance matrix for the random effects is assumed to be of the form <code>var*K</code>, where <code>K</code> is a matrix of kinship coefficients between family members. The following groupings are permitted: (Individual), (Offspring, Offspring), (Offspring, Parent), (Offspring, Parent, Parent), and (Offspring, Offspring, Parent, Parent). Other family structures have not been implemented. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  varEstFam(x, fam_group, fam_role, alpha, gtime, delta, lower, upper, beta=0)  	
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="varEstFam_+3A_x">x</code></td>
<td>
<p>Vector of numeric variables of interest for each sample.</p>
</td></tr>
<tr><td><code id="varEstFam_+3A_fam_group">fam_group</code></td>
<td>
<p>Vector of family IDs for each sample.</p>
</td></tr>
<tr><td><code id="varEstFam_+3A_fam_role">fam_role</code></td>
<td>
<p>Vector of indicators for the role within a family of each sample, i.e., {&quot;Offspring&quot;,&quot;Mother&quot;,&quot;Father&quot;}, or {&quot;o&quot;,&quot;m&quot;,&quot;f&quot;}.</p>
</td></tr>
<tr><td><code id="varEstFam_+3A_alpha">alpha</code></td>
<td>
<p>Vector of baseline survival rates for each time interval.</p>
</td></tr>
<tr><td><code id="varEstFam_+3A_gtime">gtime</code></td>
<td>
<p>Vector of observed survival times for each sample.</p>
</td></tr>
<tr><td><code id="varEstFam_+3A_delta">delta</code></td>
<td>
<p>Vector of event indicators for each sample: 1 indicates observed event, 0 indicates censored.</p>
</td></tr>
<tr><td><code id="varEstFam_+3A_lower">lower</code></td>
<td>
<p>Scalar for the lower bound of the variance estimation search region.</p>
</td></tr>
<tr><td><code id="varEstFam_+3A_upper">upper</code></td>
<td>
<p>Scalar for the upper bound of the variance estimation search region.</p>
</td></tr>
<tr><td><code id="varEstFam_+3A_beta">beta</code></td>
<td>
<p>Scalar for the fixed effect size. Default is 0.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Scalar estimate of the frailty variance.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate dummy data	
x     &lt;- c(0, 1, 1, 1, 2, 2, 0, 0, 0)
fam_group &lt;- c('1', '1', '1', '2', '2', '2', '3', '3', '3')
fam_role  &lt;- c("o","f","m","o","f","m","o","f","m")
alpha &lt;- c(0.7500000, 0.6666667, 0.5000000, 0.0000000)
gtime &lt;- c(1, 3, 3, 2, 1, 1, 2, 3, 1)
delta &lt;- c(1, 0, 1, 1, 1, 0, 1, 0, 1)
lower &lt;- 0
upper &lt;- 2
beta  &lt;- 1

#res   &lt;- varEstFam(x, fam_group, fam_role, alpha, gtime, delta, lower, upper, beta) 
#res
</code></pre>

<hr>
<h2 id='varLLFam'>
Log-Likelihood of the Frailty Variance for the Discrete-Time Frailty Model
</h2><span id='topic+varLLFam'></span>

<h3>Description</h3>

<p>A method to compute the log-likelihood of the frailty variance for a frailty model accounting for family structure of related individuals (e.g., trios). The input data is assumed to be organized such that records for each family occur consecutively, and that records for offspring precede those for parents. The variance matrix for the random effects is assumed to be of the form <code>var*K</code>, where <code>K</code> is a matrix of kinship coefficients between family members. The following groupings are permitted: (Individual), (Offspring, Offspring), (Offspring, Parent), (Offspring, Parent, Parent), and (Offspring, Offspring, Parent, Parent). Other family structures have not been implemented. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  varLLFam(x, fam_group, fam_role, alpha, var, gtime, delta, beta=0)  	
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="varLLFam_+3A_x">x</code></td>
<td>
<p>Vector of numeric variables of interest for each sample.</p>
</td></tr>
<tr><td><code id="varLLFam_+3A_fam_group">fam_group</code></td>
<td>
<p>Vector of family IDs for each sample.</p>
</td></tr>
<tr><td><code id="varLLFam_+3A_fam_role">fam_role</code></td>
<td>
<p>Vector of indicators for the role within a family of each sample, i.e., {&quot;Offspring&quot;,&quot;Mother&quot;,&quot;Father&quot;}, or {&quot;o&quot;,&quot;m&quot;,&quot;f&quot;}.</p>
</td></tr>
<tr><td><code id="varLLFam_+3A_alpha">alpha</code></td>
<td>
<p>Vector of baseline survival rates for each time interval.</p>
</td></tr>
<tr><td><code id="varLLFam_+3A_var">var</code></td>
<td>
<p>Scalar for frailty variance.</p>
</td></tr>
<tr><td><code id="varLLFam_+3A_gtime">gtime</code></td>
<td>
<p>Vector of observed survival times for each sample.</p>
</td></tr>
<tr><td><code id="varLLFam_+3A_delta">delta</code></td>
<td>
<p>Vector of event indicators for each sample: 1 indicates observed event, 0 indicates censored.</p>
</td></tr>
<tr><td><code id="varLLFam_+3A_beta">beta</code></td>
<td>
<p>Scalar for the fixed effect size. Default is 0.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Scalar for the log-likelihood of the frailty variance.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate dummy data	
x     &lt;- c(0, 1, 1, 1, 2, 2, 0, 0, 0)
fam_group &lt;- c('1', '1', '1', '2', '2', '2', '3', '3', '3')
fam_role &lt;- c("o","f","m","o","f","m","o","f","m")
alpha &lt;- c(0.7500000, 0.6666667, 0.5000000, 0.0000000)
var &lt;- 0.1
gtime &lt;- c(1, 3, 3, 2, 1, 1, 2, 3, 1)
delta &lt;- c(1, 0, 1, 1, 1, 0, 1, 0, 1)
beta  &lt;- 1.0

#res   &lt;- varLLFam(x, fam_group, fam_role, alpha, var, gtime, delta, beta) 
#res
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
