<!DOCTYPE html><html lang="en"><head><title>Help for package modehunt</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {modehunt}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#modehunt-package'><p>Multiscale Analysis for Density Functions</p></a></li>
<li><a href='#blocks'><p>Computes number of observations for each block</p></a></li>
<li><a href='#criticalValuesAll'><p>Compute critical values based on the set of all intervals</p></a></li>
<li><a href='#criticalValuesApprox'><p>Compute critical values for (1) the original test statistic with or without additive correction,</p>
based on the aprroximating set of intervals and (2) for the block procedure</a></li>
<li><a href='#cvModeAll'><p>Critical values for test statistic based on all intervals</p></a></li>
<li><a href='#cvModeApprox'><p>Critical values for test statistic based on the approximating set of intervals</p></a></li>
<li><a href='#cvModeBlock'><p>Critical values for test statistic based on the block procedure</p></a></li>
<li><a href='#lin'><p>Perturbed Uniform Distribution</p></a></li>
<li><a href='#minimalIntervals'><p>Compute set of minimal intervals</p></a></li>
<li><a href='#modeHunting'><p>Multiscale analysis of a density on all possible intervals</p></a></li>
<li><a href='#modeHuntingApprox'><p>Multiscale analysis of a density on the approximating set of intervals</p></a></li>
<li><a href='#modeHuntingBlock'><p>Multiscale analysis of a density via block procedure</p></a></li>
<li><a href='#myRound'><p>Round 5 up to the next higher integer</p></a></li>
<li><a href='#preProcessX'><p>Prepare data vector according to available information on support endpoints of f</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Multiscale Analysis for Density Functions</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.7</td>
</tr>
<tr>
<td>Date:</td>
<td>2015-07-03</td>
</tr>
<tr>
<td>Author:</td>
<td>Kaspar Rufibach &lt;kaspar.rufibach@gmail.com&gt; and Guenther Walther &lt;gwalther@stanford.edu&gt;</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Kaspar Rufibach &lt;kaspar.rufibach@gmail.com&gt;</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, utils</td>
</tr>
<tr>
<td>Description:</td>
<td>Given independent and identically distributed observations X(1), ..., X(n) from a density f,
 provides five methods to perform a multiscale analysis about f as well as the necessary critical
 values. The first method, introduced in Duembgen and Walther (2008), provides simultaneous confidence statements
 for the existence and location of local increases (or decreases) of f, based on all intervals I(all) spanned by
 any two observations X(j), X(k). The second method approximates the latter approach by using only a subset of
 I(all) and is therefore computationally much more efficient, but asymptotically equivalent. Omitting the additive
 correction term Gamma in either method offers another two approaches which are more powerful on small scales and
 less powerful on large scales, however, not asymptotically minimax optimal anymore. Finally, the block procedure is a
 compromise between adding Gamma or not, having intermediate power properties. The latter is again asymptotically
 equivalent to the first and was introduced in Rufibach and Walther (2010).</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="http://www.kasparrufibach.ch">http://www.kasparrufibach.ch</a>,
<a href="http://www-stat.stanford.edu/~gwalther">http://www-stat.stanford.edu/~gwalther</a></td>
</tr>
<tr>
<td>Packaged:</td>
<td>2015-07-03 05:35:44 UTC; rufibach</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2015-07-03 08:47:50</td>
</tr>
</table>
<hr>
<h2 id='modehunt-package'>Multiscale Analysis for Density Functions</h2><span id='topic+modehunt-package'></span><span id='topic+modehunt'></span><span id='topic+mode+20hunting'></span><span id='topic+multiscale'></span>

<h3>Description</h3>

<p>Provides five methods and corresponding critical values to perform mode hunting, i.e. to 
compute multiscale test statistics based on local order statistics and spacings that provide simultaneous confidence 
statements for the existence and location of local increases and decreases of a density.</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> modehunt </td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package </td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 1.0.7 </td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2015-07-03 </td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL (&gt;=2) </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>In Duembgen and Walther (2008) a multiscale test statistic based on spacings was introduced. This method provides 
simultaneous confidence statements for the existence and location of local increases and decreases of a density. 
The procedure guarantees finite&ndash;sample significance levels and possesses certain asymptotic optimality 
and adaptivity properties. However, since the local test statistics are computed on all <code class="reqn">O(n^2)</code> intervals in 
the set 
</p>
<p style="text-align: center;"><code class="reqn">\mathcal{I}_{all} = \Bigl\{(j, \ k ) \ : \ 0 \le j &lt; k \le n+1, \ k - j &gt; 1\Bigr\},</code>
</p>

<p>this latter procedure is computationally very expensive. Furthermore, the correction term <code class="reqn">\Gamma</code> employed
by Duembgen and Walther (2008) to prevent the global test statistic to be dominated by the values of the local 
test statistics on small scales needs in principle to be re&ndash;derived for any new local test statistic, a non&ndash;trivial
task in general. In Rufibach and Walther (2010), two new procedures are proposed: One that within the original framework
of Duembgen and Walther (2008) approximates the set <code class="reqn">\mathcal{I}_{all}</code> by a specific subset of intervals 
<code class="reqn">\mathcal{I}_{app}</code> that only contains <code class="reqn">O(n \log n )</code> intervals. It is shown that considering 
<code class="reqn">\mathcal{I}_{app}</code> yields a procedure that is in terms of power asymptotically equivalent to that based 
on <code class="reqn">\mathcal{I}_{all}</code>, however, computationally much more efficient.
</p>
<p>Finally, Rufibach and Walther (2010) propose a <em>block procedure</em>. Here, all intervals under consideration are
grouped into blocks, where each interval in a block contains approximately the same number of original observations.
Critical values are then computed per block. Again, this procedure is basically asymptotically equivalent to the
standard approach proposed in Duembgen and Walther (2008), but again computationally much faster. It further offers
a (finite&ndash;sample) tradeoff between employing or omitting the additive correction <code class="reqn">\Gamma</code>.
</p>
<p>The initial procedure by Duembgen and Walther (2008) is implemented as the function
<code><a href="#topic+modeHunting">modeHunting</a></code>. The help file to the latter function also contains some more description of the mathematical details.
<code><a href="#topic+criticalValuesAll">criticalValuesAll</a></code> can be used to compute critical values for this approach and 
<code><a href="#topic+cvModeAll">cvModeAll</a></code> contains a table of critical values (with and without correction term) for some 
<code class="reqn">n</code> and <code class="reqn">alpha</code>.
</p>
<p>The corresonding functions and <code class="reqn">p</code>-values for the approximation are made available as 
<code><a href="#topic+modeHuntingApprox">modeHuntingApprox</a></code>, <code><a href="#topic+criticalValuesApprox">criticalValuesApprox</a></code>, and <code><a href="#topic+cvModeApprox">cvModeApprox</a></code>
and for the block method as <code><a href="#topic+modeHuntingBlock">modeHuntingBlock</a></code>, <code><a href="#topic+criticalValuesBlock">criticalValuesBlock</a></code>, and
<code><a href="#topic+cvModeBlock">cvModeBlock</a></code>.
</p>


<h3>Author(s)</h3>

<p>Kaspar Rufibach (maintainer), <a href="mailto:kaspar.rufibach@gmail.com">kaspar.rufibach@gmail.com</a>, <br /> <a href="http://www.kasparrufibach.ch">http://www.kasparrufibach.ch</a>
</p>
<p>Guenther Walther, <a href="mailto:gwalther@stanford.edu">gwalther@stanford.edu</a>, <br /> <a href="www-stat.stanford.edu/~gwalther">www-stat.stanford.edu/~gwalther</a>
</p>
<p>Kaspar Rufibach acknowledges support by the Swiss National Science Foundation SNF, <a href="http://www.snf.ch">http://www.snf.ch</a>.
</p>
<p>Guenther Walther acknowledges support by NSF grants DMS-9875598, DMS-0505682, and NIH grant 5R33HL068522.
</p>


<h3>References</h3>

<p>Duembgen, L. and Walther, G. (2008).
Multiscale Inference about a density.
<em>Ann. Statist.</em>, <b>36</b>, 1758&ndash;1785.
</p>
<p>Rufibach, K. and Walther, G. (2010).
A general criterion for multiscale inference. 
<em>J. Comput. Graph. Statist.</em>, <b>19</b>, 175&ndash;190.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## generate random sample
set.seed(1977)
n &lt;- 200; a &lt;- 0; b &lt;- 0.5; s &lt;- 2 / (b - a) 
X.raw &lt;- rlin(n, a, b, s)

## input critical values
alpha &lt;- 0.05
data(cvModeAll); data(cvModeApprox); data(cvModeBlock)
cv.all &lt;- cvModeAll[cvModeAll$alpha == alpha &amp; cvModeAll$n == n, 3:4]
cv.approx &lt;- cvModeApprox[cvModeApprox$alpha == alpha &amp; cvModeApprox$n == n, 3:4]
cv.block &lt;- cvModeBlock[cvModeBlock$alpha == alpha &amp; cvModeBlock$n == n, 3:11]

## standard procedure from Duembgen and Walther (2008)
mod1 &lt;- modeHunting(X.raw, lower = 0, upper = 1, cv.all, min.int = TRUE)

## procedure from Rufibach and Walther (2010) based on I_app
mod2 &lt;- modeHuntingApprox(X.raw, lower = 0, upper = 1, 
                          crit.vals = cv.approx, min.int = TRUE)

## block procedure from Rufibach and Walther (2010)
mod3 &lt;- modeHuntingBlock(X.raw, lower = 0, upper = 1, 
                         crit.vals = cv.block, min.int = TRUE)

## display
mod1; mod2; mod3
</code></pre>

<hr>
<h2 id='blocks'>Computes number of observations for each block</h2><span id='topic+blocks'></span>

<h3>Description</h3>

<p>In Rufibach and Walther (2010) a new multiscale mode hunting procedure is presented
that compares the local test statistics with critical values given by blocks. Blocks are collection
of intervals on a given grid that contain roughly the same number of original observations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>blocks(n, m0 = 10, fm = 2)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="blocks_+3A_n">n</code></td>
<td>
<p>Number of observations.</p>
</td></tr>
<tr><td><code id="blocks_+3A_m0">m0</code></td>
<td>
<p>Initial parameter that determines the number of observations in one block.</p>
</td></tr>
<tr><td><code id="blocks_+3A_fm">fm</code></td>
<td>
<p>Factor by which <code class="reqn">m</code> is increased from block to block.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In our block procedure, we only consider a subset <code class="reqn">\mathcal{I}_{app}</code> of all possible intervals
<code class="reqn">\mathcal{I}_{all}</code> where
</p>
<p style="text-align: center;"><code class="reqn">\mathcal{I}_{all} = \Bigl\{(j, \ k ) \ : \ 0 \le j &lt; k \le n+1, \ k - j &gt; 1\Bigr\}.</code>
</p>

<p>This subset <code class="reqn">\mathcal{I}_{app}</code> is computed as follows: 
</p>
<p>Set <code class="reqn">d_1, m_1, f_m &gt; 1</code>. Then:
</p>
<p><code class="reqn">for \ \ r = 1,\ldots,\#blocks</code>
</p>
<p><code class="reqn">d_r := round(d_1 f_m^{(r-1)/2}), \ m_r := m_1 f_m^{r-1}.</code>
</p>
<p>Include <code class="reqn">(j,k)</code> in <code class="reqn">\mathcal{I}_{app}</code> if 
</p>
<p>(a) <code class="reqn">j, k \in \{1+i d_r, \ i = 0, 1, \dots \}</code> \ \ (we only consider every <code class="reqn">d</code>&ndash;th observation) and 
</p>
<p>(b) <code class="reqn">m_r \le k-j-1 \le 2m_r-1</code> \ \ (<code class="reqn">\mathcal{I}_{jk}</code> contains between <code class="reqn">m_r</code> and <code class="reqn">2m_r - 1</code> observations)
</p>
<p><code class="reqn">end \ \ for</code>
</p>


<h3>Value</h3>

<p><code class="reqn">b \times 2</code>&ndash;matrix, where <code class="reqn">b</code> is the number of blocks and the columns contain the lower
and the upper number of observations that form each block.
</p>


<h3>Note</h3>

<p>The asymptotic results in Rufibach and Walther (2010) are only derived for <code class="reqn">f_m = 2</code>.</p>


<h3>Author(s)</h3>

<p>Kaspar Rufibach, <a href="mailto:kaspar.rufibach@gmail.com">kaspar.rufibach@gmail.com</a>, <br /> <a href="http://www.kasparrufibach.ch">http://www.kasparrufibach.ch</a> 
</p>
<p>Guenther Walther, <a href="mailto:gwalther@stanford.edu">gwalther@stanford.edu</a>, <br /> <a href="www-stat.stanford.edu/~gwalther">www-stat.stanford.edu/~gwalther</a>
</p>


<h3>References</h3>

<p>Rufibach, K. and Walther, G. (2010).
A general criterion for multiscale inference. 
<em>J. Comput. Graph. Statist.</em>, <b>19</b>, 175&ndash;190.
</p>


<h3>See Also</h3>

<p>This function is called by <code><a href="#topic+modeHuntingBlock">modeHuntingBlock</a></code>.</p>

<hr>
<h2 id='criticalValuesAll'>Compute critical values based on the set of all intervals</h2><span id='topic+criticalValuesAll'></span>

<h3>Description</h3>

<p>This function computes critical values that are needed to perform the multiscale analysis about a 
density using the function <code><a href="#topic+modeHunting">modeHunting</a></code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>criticalValuesAll(n, alpha, M, display, path)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="criticalValuesAll_+3A_n">n</code></td>
<td>
<p>Number of observations.</p>
</td></tr>
<tr><td><code id="criticalValuesAll_+3A_alpha">alpha</code></td>
<td>
<p>Significance level, real number in <code class="reqn">(0,1)</code>.</p>
</td></tr>
<tr><td><code id="criticalValuesAll_+3A_m">M</code></td>
<td>
<p>Number of runs to perform.</p>
</td></tr>
<tr><td><code id="criticalValuesAll_+3A_display">display</code></td>
<td>
<p>If <code>display == 1</code>, every <code class="reqn">100</code>&ndash;th step is indicated in the output window, else not.</p>
</td></tr>
<tr><td><code id="criticalValuesAll_+3A_path">path</code></td>
<td>
<p>If <code>path != NA</code>, the current number of performed simulations is saved in this location.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For more details see the function <code><a href="#topic+modeHunting">modeHunting</a></code> and the data set <code><a href="#topic+cvModeAll">cvModeAll</a></code>.</p>


<h3>Value</h3>

<p>A 2-dimensional vector containing the critical value for the test statistic with or without additive 
correction <code class="reqn">\Gamma</code>.
</p>


<h3>Author(s)</h3>

<p>Kaspar Rufibach, <a href="mailto:kaspar.rufibach@gmail.com">kaspar.rufibach@gmail.com</a>, <br /> <a href="http://www.kasparrufibach.ch">http://www.kasparrufibach.ch</a> 
</p>
<p>Guenther Walther, <a href="mailto:gwalther@stanford.edu">gwalther@stanford.edu</a>, <br /> <a href="www-stat.stanford.edu/~gwalther">www-stat.stanford.edu/~gwalther</a>
</p>


<h3>References</h3>

<p>Rufibach, K. and Walther, G. (2010).
A general criterion for multiscale inference. 
<em>J. Comput. Graph. Statist.</em>, <b>19</b>, 175&ndash;190.
</p>


<h3>See Also</h3>

<p>The resulting critical values can be used by the function <code><a href="#topic+modeHunting">modeHunting</a></code>. Critical values
for some combinations of <code class="reqn">n</code> and <code class="reqn">\alpha</code> are available in <code><a href="#topic+cvModeAll">cvModeAll</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>## compute critical values and compare to those in cvModeAll 
## (to see output in R, press CTRL + W)
cv1 &lt;- criticalValuesAll(n = 200, alpha = 0.05, M = 10 ^ 2, display = 1, path = NA)
data(cvModeAll)
cv2 &lt;- cvModeAll[cvModeAll$alpha == 0.05 &amp; cvModeAll$n == 200, 3:4]
rbind(cv1, cv2)
</code></pre>

<hr>
<h2 id='criticalValuesApprox'>Compute critical values for (1) the original test statistic with or without additive correction, 
based on the aprroximating set of intervals and (2) for the block procedure</h2><span id='topic+criticalValuesApprox'></span><span id='topic+criticalValuesBlock'></span>

<h3>Description</h3>

<p>This function computes critical values that can be used to perform the multiscale analysis about a 
density with the functions <code><a href="#topic+modeHuntingApprox">modeHuntingApprox</a></code> and <code><a href="#topic+modeHuntingBlock">modeHuntingBlock</a></code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>criticalValuesApprox(n, d0 = 2, m0 = 10, fm = 2, alpha = 0.05, 
        gam = 2, tail = 10, M = 10 ^ 5, display = 0, path = NA)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="criticalValuesApprox_+3A_n">n</code></td>
<td>
<p>Number of observations.</p>
</td></tr>
<tr><td><code id="criticalValuesApprox_+3A_d0">d0</code></td>
<td>
<p>Initial parameter for the grid resolution.</p>
</td></tr>
<tr><td><code id="criticalValuesApprox_+3A_m0">m0</code></td>
<td>
<p>Initial parameter for the number of observations in one block.</p>
</td></tr>
<tr><td><code id="criticalValuesApprox_+3A_fm">fm</code></td>
<td>
<p>Factor by which <code class="reqn">m</code> is increased from block to block.</p>
</td></tr>
<tr><td><code id="criticalValuesApprox_+3A_alpha">alpha</code></td>
<td>
<p>Significance level, real number in <code class="reqn">(0,1)</code>.</p>
</td></tr>
<tr><td><code id="criticalValuesApprox_+3A_gam">gam</code></td>
<td>
<p>Weighting exponent for level in each block.</p>
</td></tr>
<tr><td><code id="criticalValuesApprox_+3A_tail">tail</code></td>
<td>
<p>Offset, determines together with <code>gam</code> the decrease of the level from one block to another.</p>
</td></tr>
<tr><td><code id="criticalValuesApprox_+3A_m">M</code></td>
<td>
<p>Number of runs to perform.</p>
</td></tr>
<tr><td><code id="criticalValuesApprox_+3A_display">display</code></td>
<td>
<p>If <code>display == 1</code>, every <code class="reqn">100</code>&ndash;th step is indicated in the output window, else not.</p>
</td></tr>
<tr><td><code id="criticalValuesApprox_+3A_path">path</code></td>
<td>
<p>If <code>path != NA</code>, the current number of performed simulations is saved in this location.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For details see the function <code><a href="#topic+modeHuntingApprox">modeHuntingApprox</a></code> and the data set <code><a href="#topic+cvModeApprox">cvModeApprox</a></code>.</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>approx</code></td>
<td>
<p>A 2-dimensional vector containing the critical value for the test statistic with or without
additive correction <code class="reqn">\Gamma</code>.</p>
</td></tr>
<tr><td><code>block</code></td>
<td>
<p>A vector containing the critical value for each block.</p>
</td></tr>             
</table>


<h3>Note</h3>

<p>The asymptotic results in Rufibach and Walther (2010) are only derived for <code class="reqn">f_m = 2</code>.</p>


<h3>Author(s)</h3>

<p>Kaspar Rufibach, <a href="mailto:kaspar.rufibach@gmail.com">kaspar.rufibach@gmail.com</a>, <br /> <a href="http://www.kasparrufibach.ch">http://www.kasparrufibach.ch</a> 
</p>
<p>Guenther Walther, <a href="mailto:gwalther@stanford.edu">gwalther@stanford.edu</a>, <br /> <a href="www-stat.stanford.edu/~gwalther">www-stat.stanford.edu/~gwalther</a>
</p>


<h3>References</h3>

<p>Rufibach, K. and Walther, G. (2010).
A general criterion for multiscale inference. 
<em>J. Comput. Graph. Statist.</em>, <b>19</b>, 175&ndash;190.
</p>


<h3>See Also</h3>

<p>The resulting critical values are used by the functions <code><a href="#topic+modeHuntingApprox">modeHuntingApprox</a></code> 
and <br /> <code><a href="#topic+modeHuntingBlock">modeHuntingBlock</a></code>. Critical values
for some combinations of <code class="reqn">n</code> and <code class="reqn">\alpha</code> are available in <code><a href="#topic+cvModeApprox">cvModeApprox</a></code> and
<code><a href="#topic+cvModeBlock">cvModeBlock</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>## compute critical values and compare to those in cvModeAll and cvModeBlock
## (to see output in R, press CTRL + W)
cv &lt;- criticalValuesApprox(n = 200, d0 = 2, m0 = 10, fm = 2, 
     alpha = 0.05, gam = 2, tail = 10, M = 10 ^ 2, display = 1, path = NA)
cv1 &lt;- cv$approx; cv2 &lt;- cv$block

data(cvModeApprox); data(cvModeBlock)
cv3 &lt;- cvModeApprox[cvModeApprox$alpha == 0.05 &amp; cvModeApprox$n == 200, 3:4]
cv4 &lt;- cvModeBlock[cvModeBlock$alpha == 0.05 &amp; cvModeBlock$n == 200, 3:6]
rbind(cv1, cv3)
rbind(cv2, cv4)
</code></pre>

<hr>
<h2 id='cvModeAll'>Critical values for test statistic based on all intervals</h2><span id='topic+cvModeAll'></span>

<h3>Description</h3>

<p>This dataset contains critical values for some <code class="reqn">n</code> and <code class="reqn">\alpha</code> for the test statistic based on 
all intervals, with or without additive correction term <code class="reqn">\Gamma</code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(cvModeAll)</code></pre>


<h3>Format</h3>

<p>A data frame providing 15 different combinations of <code class="reqn">n</code> and <code class="reqn">\alpha</code> and the following columns:
</p>

<table>
<tr>
 <td style="text-align: left;">
    <code>alpha</code>   </td><td style="text-align: left;"> The levels at which critical values were simulated. </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>n</code>       </td><td style="text-align: left;"> The number of observations for which critical values were simulated. </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>withadd</code> </td><td style="text-align: left;"> Critical values based on <code class="reqn">T_n^+({\bf{U}})</code> and the set of all intervals <code class="reqn">\mathcal{I}_{all}</code>. </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>noadd</code>   </td><td style="text-align: left;"> Critical values based on <code class="reqn">T_n({\bf{U}})</code> and the set of all intervals <code class="reqn">\mathcal{I}_{all}</code>.
  </td>
</tr>

</table>



<h3>Details</h3>

<p>For details on the above test statistics see <code><a href="#topic+modeHunting">modeHunting</a></code>. Critical values are based on 
<code class="reqn">M=100'000</code> simulations of i.i.d. random vectors
</p>
<p style="text-align: center;"><code class="reqn">{\bf{U}} = (U_1,\dots,U_n)</code>
</p>

<p>where <code class="reqn">U_i</code> is a uniformly on <code class="reqn">[0,1]</code> distributed random variable, <code class="reqn">i=1,\dots,M</code>.
</p>


<h3>Remember</h3>

<p><code class="reqn">n</code> is the number of <em>interior observations</em>, i.e. if you are analyzing a sample of size
<code class="reqn">m</code>, then you need critical values corresponding to
</p>

<table>
<tr>
 <td style="text-align: left;">
    <code>n = m-2</code> </td><td style="text-align: left;"> If no additional information on <code class="reqn">a</code> and <code class="reqn">b</code> is available. </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>n = m-1</code> </td><td style="text-align: left;"> If either <code class="reqn">a</code> or <code class="reqn">b</code> is known to be a certain finite number. </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>n = m  </code> </td><td style="text-align: left;"> If both <code class="reqn">a</code> and <code class="reqn">b</code> are known to be certain finite numbers,
  </td>
</tr>

</table>

<p>where <code class="reqn">[a,b] = \{x \ : \ f(x) &gt; 0\}</code> is the support of <code class="reqn">f</code>.
</p>


<h3>Source</h3>

<p>These critical values were generated using the function <code><a href="#topic+criticalValuesAll">criticalValuesAll</a></code>. Critical values
for other combinations for <code class="reqn">\alpha</code> and <code class="reqn">n</code> can be computed using this latter function.</p>


<h3>References</h3>

<p>Rufibach, K. and Walther, G. (2010).
A general criterion for multiscale inference. 
<em>J. Comput. Graph. Statist.</em>, <b>19</b>, 175&ndash;190.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## extract critical values for alpha = 0.05, n = 200
data(cvModeAll)
cv &lt;- cvModeAll[cvModeAll$alpha == 0.05 &amp; cvModeAll$n == 200, 3:4]
cv
</code></pre>

<hr>
<h2 id='cvModeApprox'>Critical values for test statistic based on the approximating set of intervals</h2><span id='topic+cvModeApprox'></span>

<h3>Description</h3>

<p>This dataset contains critical values for some <code class="reqn">n</code> and <code class="reqn">\alpha</code> for the test statistic based on 
the approximating set of intervals, with or without additive correction term <code class="reqn">\Gamma</code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(cvModeApprox)</code></pre>


<h3>Format</h3>

<p>A data frame providing 15 different combinations of <code class="reqn">n</code> and <code class="reqn">\alpha</code> and the following columns:
</p>

<table>
<tr>
 <td style="text-align: left;">
    <code>alpha</code>   </td><td style="text-align: left;"> The levels at which critical values were simulated. </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>n</code>       </td><td style="text-align: left;"> The number of observations for which critical values were simulated. </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>withadd</code> </td><td style="text-align: left;"> Critical values based on <code class="reqn">T_n^+({\bf{U}})</code> and the approximating set of intervals <code class="reqn">\mathcal{I}_{app}</code>. </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>noadd</code>   </td><td style="text-align: left;"> Critical values based on <code class="reqn">T_n({\bf{U}})</code> and the approximating set of intervals <code class="reqn">\mathcal{I}_{app}</code>.
  </td>
</tr>

</table>



<h3>Details</h3>

<p>For details see <code><a href="#topic+modeHunting">modeHunting</a></code>. Critical values are based on 
<code class="reqn">M=100'000</code> simulations of i.i.d. random vectors
</p>
<p style="text-align: center;"><code class="reqn">{\bf{U}} = (U_1,\dots,U_n)</code>
</p>

<p>where <code class="reqn">U_i</code> is a uniformly on <code class="reqn">[0,1]</code> distributed random variable, <code class="reqn">i=1,\dots,M</code>.
</p>


<h3>Remember</h3>

<p><code class="reqn">n</code> is the number of <em>interior observations</em>, i.e. if you are analyzing a sample of size
<code class="reqn">m</code>, then you need critical values corresponding to
</p>

<table>
<tr>
 <td style="text-align: left;">
    <code>n = m-2</code> </td><td style="text-align: left;"> If no additional information on <code class="reqn">a</code> and <code class="reqn">b</code> is available. </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>n = m-1</code> </td><td style="text-align: left;"> If either <code class="reqn">a</code> or <code class="reqn">b</code> is known to be a certain finite number. </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>n = m  </code> </td><td style="text-align: left;"> If both <code class="reqn">a</code> and <code class="reqn">b</code> are known to be certain finite numbers,
  </td>
</tr>

</table>

<p>where <code class="reqn">[a,b] = \{x \ : \ f(x) &gt; 0\}</code> is the support of <code class="reqn">f</code>.
</p>


<h3>Source</h3>

<p>These critical values were generated using the function <code><a href="#topic+criticalValuesApprox">criticalValuesApprox</a></code>. Critical values
for other combinations for <code class="reqn">\alpha</code> and <code class="reqn">n</code> can be computed using this latter function.</p>


<h3>References</h3>

<p>Rufibach, K. and Walther, G. (2010).
A general criterion for multiscale inference. 
<em>J. Comput. Graph. Statist.</em>, <b>19</b>, 175&ndash;190.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## extract critical values for alpha = 0.05, n = 200
data(cvModeApprox)
cv &lt;- cvModeApprox[cvModeApprox$alpha == 0.05 &amp; cvModeApprox$n == 200, 3:4]
cv
</code></pre>

<hr>
<h2 id='cvModeBlock'>Critical values for test statistic based on the block procedure</h2><span id='topic+cvModeBlock'></span>

<h3>Description</h3>

<p>This dataset contains critical values for some <code class="reqn">n</code> and <code class="reqn">\alpha</code> for the block procedure.</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(cvModeBlock)</code></pre>


<h3>Format</h3>

<p>A data frame providing 15 different combinations of <code class="reqn">n</code> and <code class="reqn">\alpha</code> and the following columns:
</p>

<table>
<tr>
 <td style="text-align: left;">
    <code>alpha      </code> </td><td style="text-align: left;"> The levels at which critical values were simulated. </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>n          </code> </td><td style="text-align: left;"> The number of observations for which critical values were simulated. </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>block 1 - 9</code> </td><td style="text-align: left;"> Critical values for the respective blocks. 
  </td>
</tr>

</table>



<h3>Details</h3>

<p>For details see <code><a href="#topic+modeHunting">modeHunting</a></code>. Critical values are based on 
<code class="reqn">M=100'000</code> simulations of i.i.d. random vectors
</p>
<p style="text-align: center;"><code class="reqn">{\bf{U}} = (U_1,\dots,U_n)</code>
</p>

<p>where <code class="reqn">U_i</code> is a uniformly on <code class="reqn">[0,1]</code> distributed random variable, <code class="reqn">i=1,\dots,M</code>.
</p>


<h3>Remember</h3>

<p><code class="reqn">n</code> is the number of <em>interior observations</em>, i.e. if you are analyzing a sample of size
<code class="reqn">m</code>, then you need critical values corresponding to
</p>

<table>
<tr>
 <td style="text-align: left;">
    <code>n = m-2</code> </td><td style="text-align: left;"> If no additional information on <code class="reqn">a</code> and <code class="reqn">b</code> is available. </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>n = m-1</code> </td><td style="text-align: left;"> If either <code class="reqn">a</code> or <code class="reqn">b</code> is known to be a certain finite number. </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>n = m  </code> </td><td style="text-align: left;"> If both <code class="reqn">a</code> and <code class="reqn">b</code> are known to be certain finite numbers,
  </td>
</tr>

</table>

<p>where <code class="reqn">[a,b] = \{x \ : \ f(x) &gt; 0\}</code> is the support of <code class="reqn">f</code>.
</p>


<h3>Source</h3>

<p>These critical values were generated using the function <code><a href="#topic+criticalValuesBlock">criticalValuesBlock</a></code>. Critical values
for other combinations for <code class="reqn">\alpha</code> and <code class="reqn">n</code> can be computed using this latter function.</p>


<h3>References</h3>

<p>Rufibach, K. and Walther, G. (2010).
A general criterion for multiscale inference. 
<em>J. Comput. Graph. Statist.</em>, <b>19</b>, 175&ndash;190.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## extract critical values for alpha = 0.05, n = 200
data(cvModeBlock)
cv &lt;- cvModeBlock[cvModeBlock$alpha == 0.05 &amp; cvModeBlock$n == 200, 3:11]
cv
</code></pre>

<hr>
<h2 id='lin'>Perturbed Uniform Distribution</h2><span id='topic+lin'></span><span id='topic+dlin'></span><span id='topic+plin'></span><span id='topic+qlin'></span><span id='topic+rlin'></span>

<h3>Description</h3>

<p>Density function, distribution function, quantile function and
random generation for the perturbed uniform distribution having a linear increase of slope <code class="reqn">s</code> 
on an interval <code class="reqn">[a,b] \in [0,1]</code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>dlin(x, a, b, s) 
plin(q, a, b, s) 
qlin(p, a, b, s)
rlin(n, a, b, s)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lin_+3A_x">x</code>, <code id="lin_+3A_q">q</code></td>
<td>
<p>Vector of quantiles.</p>
</td></tr>
<tr><td><code id="lin_+3A_p">p</code></td>
<td>
<p>Vector of probabilities.</p>
</td></tr>
<tr><td><code id="lin_+3A_n">n</code></td>
<td>
<p>Number of observations.</p>
</td></tr>
<tr><td><code id="lin_+3A_a">a</code></td>
<td>
<p>Left interval endpoint, real number in <code class="reqn">[0,1)</code>.</p>
</td></tr>
<tr><td><code id="lin_+3A_b">b</code></td>
<td>
<p>Right interval endpoint, real number in <code class="reqn">(0,1]</code>.</p>
</td></tr>
<tr><td><code id="lin_+3A_s">s</code></td>
<td>
<p>Slope parameter, real number such that <code class="reqn">|s| \le 2/(b-a)</code>.</p>
</td></tr>  
</table>


<h3>Details</h3>

<p>The what we call perturbed uniform distribution (PUD) with perturbation on an 
interval <code class="reqn">[a,b] \in [0,1]</code> with slope parameter <code class="reqn">s</code> such that
<code class="reqn">|s| \le 2 / (b-a)</code> has density function
</p>
<p style="text-align: center;"><code class="reqn">f_{a, b, s}(x) = \Bigl(sx-s\frac{a+b}{2}\Bigr)1\{x \in [a,b)\} + 1\{[0,a) \cup [b,1]\},</code>
</p>

<p>distribution function
</p>
<p style="text-align: center;"><code class="reqn">F_{a, b, s}(q) = \Bigl(q+\frac{s}{2}(q^2-a^2+(a-x)(a+b)) \Bigr)1\{q \in [a,b)\} + q\{[0,a) \cup [b,1]\},</code>
</p>

<p>and quantile function
</p>
<p style="text-align: center;"><code class="reqn">F_{a, b, s}^{-1}(p) = \Bigl(-s^{-1}+\frac{a+b}{2}+\frac{s \sqrt{(a-b)^2+\frac{4}{s}(\frac{1}{s}-(a+b)+2p)}}{2|s|}  \Bigr) \ 1\{p \in [a,b)\} + p\{[0,a) \cup [b,1]\}.</code>
</p>

<p>This function was used to carry out the simulations to compute the power curves given in Rufibach and Walther (2010).
</p>


<h3>Value</h3>

<p><code><a href="#topic+dlin">dlin</a></code> gives the values of the density function, <code><a href="#topic+plin">plin</a></code> those of the distribution
function, and <code><a href="#topic+qlin">qlin</a></code> those of the quantile function of the PUD at <code class="reqn">x, q,</code> and <code class="reqn">p</code>, 
respectively. <code><a href="#topic+rlin">rlin</a></code> generates <code class="reqn">n</code> random numbers, returned as an ordered vector.
</p>


<h3>Author(s)</h3>

<p>Kaspar Rufibach, <a href="mailto:kaspar.rufibach@gmail.com">kaspar.rufibach@gmail.com</a>, <br /> <a href="http://www.kasparrufibach.ch">http://www.kasparrufibach.ch</a> 
</p>
<p>Guenther Walther, <a href="mailto:gwalther@stanford.edu">gwalther@stanford.edu</a>, <br /> <a href="www-stat.stanford.edu/~gwalther">www-stat.stanford.edu/~gwalther</a></p>


<h3>References</h3>

<p>Rufibach, K. and Walther, G. (2010).
A general criterion for multiscale inference. 
<em>J. Comput. Graph. Statist.</em>, <b>19</b>, 175&ndash;190.
</p>

<hr>
<h2 id='minimalIntervals'>Compute set of minimal intervals</h2><span id='topic+minimalIntervals'></span>

<h3>Description</h3>

<p>In general, all intervals that have a test statistic bigger than the respective critical value
are output. For a given set of intervals <code class="reqn">\mathcal{K}</code>, all intervals <code class="reqn">J</code> such that <code class="reqn">\mathcal{K}</code> 
does not contain a proper subset of <code class="reqn">J</code> are called <em>minimal</em>. Given <code class="reqn">\mathcal{K}</code>, this function 
computes the set of minimal intervals.</p>


<h3>Usage</h3>

<pre><code class='language-R'>minimalIntervals(ints)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="minimalIntervals_+3A_ints">ints</code></td>
<td>
<p>Either one of the sets <code class="reqn">\mathcal{D}^+</code> or <code class="reqn">\mathcal{D}^-</code> as output by one of the functions
<code><a href="#topic+modeHunting">modeHunting</a></code>, <code><a href="#topic+modeHuntingApprox">modeHuntingApprox</a></code>, or <code><a href="#topic+modeHuntingBlock">modeHuntingBlock</a></code>.</p>
</td></tr></table>


<h3>Value</h3>

<p>Returns the set of minimal elements <code class="reqn">\bf{D}^\pm</code>, corresponding to the set of input intervals
<code class="reqn">\mathcal{D}^\pm</code>.</p>


<h3>Note</h3>

<p>Depending on the value of <code class="reqn">min.int</code>, this function is called by <code><a href="#topic+modeHunting">modeHunting</a></code>, <br /> 
<code><a href="#topic+modeHuntingApprox">modeHuntingApprox</a></code>, and <code><a href="#topic+modeHuntingBlock">modeHuntingBlock</a></code>.</p>


<h3>Author(s)</h3>

<p>Kaspar Rufibach, <a href="mailto:kaspar.rufibach@gmail.com">kaspar.rufibach@gmail.com</a>, <br /> <a href="http://www.kasparrufibach.ch">http://www.kasparrufibach.ch</a> 
</p>
<p>Guenther Walther, <a href="mailto:gwalther@stanford.edu">gwalther@stanford.edu</a>, <br /> <a href="www-stat.stanford.edu/~gwalther">www-stat.stanford.edu/~gwalther</a></p>


<h3>References</h3>

<p>Minimal intervals were first introduced (although for a different multiscale procedure) on p. 517 in 
</p>
<p>Lutz Dümbgen (2002).
Application of Local Rank Tests to Nonparametric Regression.
<em>Journal of Nonparametric Statistics</em>, <b>14</b>, 511&ndash;537.
</p>
<p>Rufibach, K. and Walther, G. (2010).
A general criterion for multiscale inference. 
<em>J. Comput. Graph. Statist.</em>, <b>19</b>, 175&ndash;190.
</p>

<hr>
<h2 id='modeHunting'>Multiscale analysis of a density on all possible intervals</h2><span id='topic+modeHunting'></span>

<h3>Description</h3>

<p>Simultanous confidence statements for the existence and location of local increases and decreases 
of a density f, computed on all intervals spanned by two observations.</p>


<h3>Usage</h3>

<pre><code class='language-R'>modeHunting(X.raw, lower = -Inf, upper = Inf, crit.vals, min.int = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="modeHunting_+3A_x.raw">X.raw</code></td>
<td>
<p>Vector of observations.</p>
</td></tr>
<tr><td><code id="modeHunting_+3A_lower">lower</code></td>
<td>
<p>Lower support point of <code class="reqn">f</code>, if known.</p>
</td></tr>
<tr><td><code id="modeHunting_+3A_upper">upper</code></td>
<td>
<p>Upper support point of <code class="reqn">f</code>, if known.</p>
</td></tr>
<tr><td><code id="modeHunting_+3A_crit.vals">crit.vals</code></td>
<td>
<p>2-dimensional vector giving the critical values for the desired level.</p>
</td></tr>
<tr><td><code id="modeHunting_+3A_min.int">min.int</code></td>
<td>
<p>If <code>min.int = TRUE</code>, the set of minimal intervals is output, otherwise all intervals with a test 
statistic above the critical value are given.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In general, the methods <code><a href="#topic+modeHunting">modeHunting</a></code>, <code><a href="#topic+modeHuntingApprox">modeHuntingApprox</a></code>, and 
<code><a href="#topic+modeHuntingBlock">modeHuntingBlock</a></code> compute for a given level <code class="reqn">\alpha \in (0, 1)</code> and the corresponding
critical value <code class="reqn">c_{jk}(\alpha)</code> two sets of intervals
</p>
<p style="text-align: center;"><code class="reqn">\mathcal{D}^\pm(\alpha) = \Bigl\{ \mathcal{I}_{jk} \ : \ \pm T_{jk}({\bf{X}} ) &gt; c_{jk}(\alpha) \Bigr\}</code>
</p>

<p>where <code class="reqn">\mathcal{I}_{jk}:=(X_{(j)},X_{(k)})</code> for <code class="reqn">0\le j &lt; k \le n+1, k-j&gt; 1</code> and <code class="reqn">c_{jk}</code> are
appropriate critical values.
</p>
<p>Specifically, the function <code><a href="#topic+modeHunting">modeHunting</a></code> computes <code class="reqn">\mathcal{D}^\pm(\alpha)</code> based on the two 
test statistics
</p>
<p style="text-align: center;"><code class="reqn">T_n^+({\bf{X}}, \mathcal{I}) = \max_{(j,k) \in \mathcal{I}} \Bigl( |T_{jk}({\bf{X}})| / \sigma_{jk} - \Gamma \Bigl(\frac{k-j}{n+2}\Bigr)\Bigr)</code>
</p>

<p>and
</p>
<p style="text-align: center;"><code class="reqn">T_n({\bf{X}}, \mathcal{I}) = \max_{(j,k) \in \mathcal{I}} ( |T_{jk}({\bf{X}})| / \sigma_{jk} ),</code>
</p>

<p>using the set <code class="reqn">\mathcal{I} := \mathcal{I}_{all}</code> of all intervals spanned by two observations 
<code class="reqn">(X_{(j)}, X_{(k)})</code>:
</p>
<p style="text-align: center;"><code class="reqn">\mathcal{I}_{all} = \Bigl\{(j, \ k ) \ : \ 0 \le j &lt; k \le n+1, \ k - j &gt; 1\Bigr\}.</code>
</p>

<p>We introduced the local test statistics
</p>
<p style="text-align: center;"><code class="reqn">T_{jk}({\bf{X}}) := \sum_{i=j+1}^{k-1} ( 2 X_{(i; j, k)} - 1) 1\{X_{(i; j, k)} \in (0,1)\},</code>
</p>

<p>for local order statistics
</p>
<p style="text-align: center;"><code class="reqn">X_{(i; j, k)} := \frac{X_{(i)}-X_{(j)}}{X_{(k)} - X_{(j)}},</code>
</p>

<p>the standard deviation <code class="reqn">\sigma_{jk} :=  \sqrt{(k-j-1)/3}</code> and the additive correction term 
<code class="reqn">\Gamma(\delta) := \sqrt{2 \log(e / \delta)}</code> for <code class="reqn">\delta &gt; 0</code>.
</p>
<p>If <code>min.int = TRUE</code>, the set <code class="reqn">\mathcal{D}^\pm(\alpha)</code> is replaced by the set <code class="reqn">{\bf{D}}^\pm(\alpha)</code>
of its <em>minimal elements</em>. An interval <code class="reqn">J \in \mathcal{D}^\pm(\alpha)</code> is called <em>minimal</em> if 
<code class="reqn">\mathcal{D}^\pm(\alpha)</code> contains no proper subset of <code class="reqn">J</code>. This <em>minimization</em> post-processing 
step typically massively reduces the number of intervals. If we are mainly interested in locating the ranges
of increases and decreases of <code class="reqn">f</code> as precisely as possible, the intervals in 
<code class="reqn">\mathcal{D}^\pm(\alpha) \setminus \bf{D}^\pm(\alpha)</code> do not contain relevant information.
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>Dp</code></td>
<td>
<p>The set <code class="reqn">\mathcal{D}^+(\alpha)</code> (or <code class="reqn">\bf{D}^+(\alpha)</code>), based on the test statistic with additive correction <code class="reqn">\Gamma</code>.</p>
</td></tr>
<tr><td><code>Dm</code></td>
<td>
<p>The set <code class="reqn">\mathcal{D}^-(\alpha)</code> (or <code class="reqn">\bf{D}^-(\alpha)</code>), based on the test statistic with <code class="reqn">\Gamma</code>.</p>
</td></tr>
<tr><td><code>Dp.noadd</code></td>
<td>
<p>The set <code class="reqn">\mathcal{D}^+(\alpha)</code> (or <code class="reqn">\bf{D}^+(\alpha)</code>), based on the test statistic without <code class="reqn">\Gamma</code>.</p>
</td></tr>  
<tr><td><code>Dm.noadd</code></td>
<td>
<p>The set <code class="reqn">\mathcal{D}^+(\alpha)</code> (or <code class="reqn">\bf{D}^-(\alpha)</code>), based on the test statistic without <code class="reqn">\Gamma</code>.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Critical values for <code><a href="#topic+modeHunting">modeHunting</a></code> and some combinations of <code class="reqn">n</code> and <code class="reqn">\alpha</code> are provided in the 
data set <code><a href="#topic+cvModeAll">cvModeAll</a></code>. Critical values for other values of <code class="reqn">n</code> and <code class="reqn">\alpha</code> can be generated 
using <code><a href="#topic+criticalValuesAll">criticalValuesAll</a></code>.
</p>
<p>Parts of this function were derived from MatLab code provided on Lutz Duembgen's webpage, <br />
<a href="http://www.staff.unibe.ch/duembgen">http://www.staff.unibe.ch/duembgen</a>.</p>


<h3>Author(s)</h3>

<p>Kaspar Rufibach, <a href="mailto:kaspar.rufibach@gmail.com">kaspar.rufibach@gmail.com</a>, <br /> <a href="http://www.kasparrufibach.ch">http://www.kasparrufibach.ch</a> 
</p>
<p>Guenther Walther, <a href="mailto:gwalther@stanford.edu">gwalther@stanford.edu</a>, <br /> <a href="www-stat.stanford.edu/~gwalther">www-stat.stanford.edu/~gwalther</a>
</p>


<h3>References</h3>

<p>Duembgen, L. and Walther, G. (2008).
Multiscale Inference about a density.
<em>Ann. Statist.</em>, <b>36</b>, 1758&ndash;1785.
</p>
<p>Rufibach, K. and Walther, G. (2010).
A general criterion for multiscale inference. 
<em>J. Comput. Graph. Statist.</em>, <b>19</b>, 175&ndash;190.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+modeHuntingApprox">modeHuntingApprox</a></code>, <code><a href="#topic+modeHuntingBlock">modeHuntingBlock</a></code>, and <code><a href="#topic+cvModeAll">cvModeAll</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>## for examples type
help("mode hunting")
## and check the examples there</code></pre>

<hr>
<h2 id='modeHuntingApprox'>Multiscale analysis of a density on the approximating set of intervals</h2><span id='topic+modeHuntingApprox'></span>

<h3>Description</h3>

<p>Simultanous confidence statements for the existence and location of local increases and decreases 
of a density f, computed on the approximating set of intervals.</p>


<h3>Usage</h3>

<pre><code class='language-R'>modeHuntingApprox(X.raw, lower = -Inf, upper = Inf, 
    d0 = 2, m0 = 10, fm = 2, crit.vals, min.int = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="modeHuntingApprox_+3A_x.raw">X.raw</code></td>
<td>
<p>Vector of observations.</p>
</td></tr>
<tr><td><code id="modeHuntingApprox_+3A_lower">lower</code></td>
<td>
<p>Lower support point of <code class="reqn">f</code>, if known.</p>
</td></tr>
<tr><td><code id="modeHuntingApprox_+3A_upper">upper</code></td>
<td>
<p>Upper support point of <code class="reqn">f</code>, if known.</p>
</td></tr>
<tr><td><code id="modeHuntingApprox_+3A_d0">d0</code></td>
<td>
<p>Initial parameter for the grid resolution.</p>
</td></tr>
<tr><td><code id="modeHuntingApprox_+3A_m0">m0</code></td>
<td>
<p>Initial parameter for the number of observations in one block.</p>
</td></tr>
<tr><td><code id="modeHuntingApprox_+3A_fm">fm</code></td>
<td>
<p>Factor by which <code class="reqn">m</code> is increased from block to block.</p>
</td></tr>
<tr><td><code id="modeHuntingApprox_+3A_crit.vals">crit.vals</code></td>
<td>
<p>2-dimensional vector giving the critical values for the desired level.</p>
</td></tr>
<tr><td><code id="modeHuntingApprox_+3A_min.int">min.int</code></td>
<td>
<p>If <code>min.int = TRUE</code>, the set of minimal intervals is output, otherwise all intervals with a test 
statistic above the critical value are given.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <code><a href="#topic+blocks">blocks</a></code> for details how <code class="reqn">\mathcal{I}_{app}</code> is generated and <code><a href="#topic+modeHunting">modeHunting</a></code> for 
a proper introduction to the notation used here.
The function <code><a href="#topic+modeHuntingApprox">modeHuntingApprox</a></code> computes <code class="reqn">\mathcal{D}^\pm(\alpha)</code> based on the two 
test statistics <code class="reqn">T_n^+({\bf{X}}, \mathcal{I}_{app})</code> and <code class="reqn">T_n({\bf{X}}, \mathcal{I}_{app})</code>. 
</p>
<p>If <code>min.int = TRUE</code>, the set <code class="reqn">\mathcal{D}^\pm(\alpha)</code> is replaced by the set <code class="reqn">{\bf{D}}^\pm(\alpha)</code>
of its <em>minimal elements</em>. An interval <code class="reqn">J \in \mathcal{D}^\pm(\alpha)</code> is called <em>minimal</em> if 
<code class="reqn">\mathcal{D}^\pm(\alpha)</code> contains no proper subset of <code class="reqn">J</code>. This <em>minimization</em> post-processing 
step typically massively reduces the number of intervals. If we are mainly interested in locating the ranges
of increases and decreases of <code class="reqn">f</code> as precisely as possible, the intervals in 
<code class="reqn">\mathcal{D}^\pm(\alpha) \setminus \bf{D}^\pm(\alpha)</code> do not contain relevant information.
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>Dp</code></td>
<td>
<p>The set <code class="reqn">\mathcal{D}^+(\alpha)</code> (or <code class="reqn">\bf{D}^+(\alpha)</code>), based on the test statistic with additive correction <code class="reqn">\Gamma</code>.</p>
</td></tr>
<tr><td><code>Dm</code></td>
<td>
<p>The set <code class="reqn">\mathcal{D}^-(\alpha)</code> (or <code class="reqn">\bf{D}^-(\alpha)</code>), based on the test statistic with <code class="reqn">\Gamma</code>.</p>
</td></tr>
<tr><td><code>Dp.noadd</code></td>
<td>
<p>The set <code class="reqn">\mathcal{D}^+(\alpha)</code> (or <code class="reqn">\bf{D}^+(\alpha)</code>), based on the test statistic without <code class="reqn">\Gamma</code>.</p>
</td></tr>  
<tr><td><code>Dm.noadd</code></td>
<td>
<p>The set <code class="reqn">\mathcal{D}^+(\alpha)</code> (or <code class="reqn">\bf{D}^-(\alpha)</code>), based on the test statistic without <code class="reqn">\Gamma</code>.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Critical values for <code><a href="#topic+modeHuntingApprox">modeHuntingApprox</a></code> and some combinations of <code class="reqn">n</code> and <code class="reqn">\alpha</code> are 
provided in the data set <code><a href="#topic+cvModeApprox">cvModeApprox</a></code>. Critical values for other
values of <code class="reqn">n</code> and <code class="reqn">\alpha</code> can be generated using <code><a href="#topic+criticalValuesApprox">criticalValuesApprox</a></code>.
</p>


<h3>Author(s)</h3>

<p>Kaspar Rufibach, <a href="mailto:kaspar.rufibach@gmail.com">kaspar.rufibach@gmail.com</a>, <br /> <a href="http://www.kasparrufibach.ch">http://www.kasparrufibach.ch</a> 
</p>
<p>Guenther Walther, <a href="mailto:gwalther@stanford.edu">gwalther@stanford.edu</a>, <br /> <a href="www-stat.stanford.edu/~gwalther">www-stat.stanford.edu/~gwalther</a>
</p>


<h3>References</h3>

<p>Duembgen, L. and Walther, G. (2008).
Multiscale Inference about a density.
<em>Ann. Statist.</em>, <b>36</b>, 1758&ndash;1785.
</p>
<p>Rufibach, K. and Walther, G. (2010).
A general criterion for multiscale inference. 
<em>J. Comput. Graph. Statist.</em>, <b>19</b>, 175&ndash;190.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+modeHunting">modeHunting</a></code>, <code><a href="#topic+modeHuntingBlock">modeHuntingBlock</a></code>, and <code><a href="#topic+cvModeApprox">cvModeApprox</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>## for examples type
help("mode hunting")
## and check the examples there</code></pre>

<hr>
<h2 id='modeHuntingBlock'>Multiscale analysis of a density via block procedure</h2><span id='topic+modeHuntingBlock'></span>

<h3>Description</h3>

<p>Simultanous confidence statements for the existence and location of local increases and decreases 
of a density f, computed via the block procedure.</p>


<h3>Usage</h3>

<pre><code class='language-R'>modeHuntingBlock(X.raw, lower = -Inf, upper = Inf, d0 = 2, 
    m0 = 10, fm = 2, crit.vals, min.int = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="modeHuntingBlock_+3A_x.raw">X.raw</code></td>
<td>
<p>Vector of observations.</p>
</td></tr>
<tr><td><code id="modeHuntingBlock_+3A_lower">lower</code></td>
<td>
<p>Lower support point of <code class="reqn">f</code>, if known.</p>
</td></tr>
<tr><td><code id="modeHuntingBlock_+3A_upper">upper</code></td>
<td>
<p>Upper support point of <code class="reqn">f</code>, if known.</p>
</td></tr>
<tr><td><code id="modeHuntingBlock_+3A_d0">d0</code></td>
<td>
<p>Initial parameter for the grid resolution.</p>
</td></tr>
<tr><td><code id="modeHuntingBlock_+3A_m0">m0</code></td>
<td>
<p>Initial parameter for the number of observations in one block.</p>
</td></tr>
<tr><td><code id="modeHuntingBlock_+3A_fm">fm</code></td>
<td>
<p>Factor by which <code class="reqn">m</code> is increased from block to block.</p>
</td></tr>
<tr><td><code id="modeHuntingBlock_+3A_crit.vals">crit.vals</code></td>
<td>
<p>2-dimensional vector giving the critical values for the desired level.</p>
</td></tr>
<tr><td><code id="modeHuntingBlock_+3A_min.int">min.int</code></td>
<td>
<p>If <code>min.int = TRUE</code>, the set of minimal intervals is output, otherwise all intervals with a test 
statistic above the critical value (in their respective block) are given.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <code><a href="#topic+blocks">blocks</a></code> for details how <code class="reqn">\mathcal{I}_{app}</code> is generated and <code><a href="#topic+modeHunting">modeHunting</a></code> for 
a proper introduction to the notation used here.
The function <code><a href="#topic+modeHuntingBlock">modeHuntingBlock</a></code> uses the test statistic <code class="reqn">T^+_n({\bf X}, \mathcal{B}_r)</code>,
where <code class="reqn">\mathcal{B}_r</code> contains all intervals of Block <code class="reqn">r</code>, <code class="reqn">r=1,\ldots,\#blocks</code>. 
Critical values for each block individually are received via finding an <code class="reqn">\tilde \alpha</code> such that
</p>
<p style="text-align: center;"><code class="reqn">P(B_n({\bf{X}}) &gt; q_{r,\tilde \alpha / (r+tail)^\gamma} \ for \ at \ least \ one \ r) \le \alpha,</code>
</p>

<p>where <code class="reqn">q_{r,\alpha}</code> is the <code class="reqn">(1-\alpha)</code>&ndash;quantile of the distribution of <code class="reqn">T^+_n({\bf X}, \mathcal{B}_r).</code>
We then define the sets <code class="reqn">\mathcal{D}^\pm(\alpha)</code> as
</p>
<p style="text-align: center;"><code class="reqn">\mathcal{D}^\pm(\alpha) := \Bigl\{\mathcal{I}_{jk} \ : \ \pm T_{jk}({\bf{X}}) &gt; q_{r,\tilde \alpha / (r+tail)^\gamma} \, , \ r = 1,\ldots \#blocks\Bigr\}.</code>
</p>

<p>Note that <code class="reqn">\gamma</code> and <code class="reqn">tail</code> are automatically determined by <code class="reqn">crit.vals</code>.
</p>
<p>If <code>min.int = TRUE</code>, the set <code class="reqn">\mathcal{D}^\pm(\alpha)</code> is replaced by the set <code class="reqn">{\bf{D}}^\pm(\alpha)</code>
of its <em>minimal elements</em>. An interval <code class="reqn">J \in \mathcal{D}^\pm(\alpha)</code> is called <em>minimal</em> if 
<code class="reqn">\mathcal{D}^\pm(\alpha)</code> contains no proper subset of <code class="reqn">J</code>. This <em>minimization</em> post-processing 
step typically massively reduces the number of intervals. If we are mainly interested in locating the ranges
of increases and decreases of <code class="reqn">f</code> as precisely as possible, the intervals in 
<code class="reqn">\mathcal{D}^\pm(\alpha) \setminus \bf{D}^\pm(\alpha)</code> do not contain relevant information.
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>Dp</code></td>
<td>
<p>The set <code class="reqn">\mathcal{D}^+(\alpha)</code> (or <code class="reqn">\bf{D}^+(\alpha)</code>).</p>
</td></tr>
<tr><td><code>Dm</code></td>
<td>
<p>The set <code class="reqn">\mathcal{D}^-(\alpha)</code> (or <code class="reqn">\bf{D}^-(\alpha)</code>).</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Critical values for some combinations of <code class="reqn">n</code> and <code class="reqn">\alpha</code> are provided in the 
data sets <code><a href="#topic+cvModeBlock">cvModeBlock</a></code>. Critical values for other
values of <code class="reqn">n</code> and <code class="reqn">\alpha</code> can be generated using <code><a href="#topic+criticalValuesApprox">criticalValuesApprox</a></code>.
</p>


<h3>Author(s)</h3>

<p>Kaspar Rufibach, <a href="mailto:kaspar.rufibach@gmail.com">kaspar.rufibach@gmail.com</a>, <br /> <a href="http://www.kasparrufibach.ch">http://www.kasparrufibach.ch</a> 
</p>
<p>Guenther Walther, <a href="mailto:gwalther@stanford.edu">gwalther@stanford.edu</a>, <br /> <a href="www-stat.stanford.edu/~gwalther">www-stat.stanford.edu/~gwalther</a></p>


<h3>References</h3>

<p>Duembgen, L. and Walther, G. (2008).
Multiscale Inference about a density.
<em>Ann. Statist.</em>, <b>36</b>, 1758&ndash;1785.
</p>
<p>Rufibach, K. and Walther, G. (2010).
A general criterion for multiscale inference. 
<em>J. Comput. Graph. Statist.</em>, <b>19</b>, 175&ndash;190.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+modeHunting">modeHunting</a></code>, <code><a href="#topic+modeHuntingApprox">modeHuntingApprox</a></code>, and <code><a href="#topic+cvModeBlock">cvModeBlock</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>## for examples type
help("mode hunting")
## and check the examples there</code></pre>

<hr>
<h2 id='myRound'>Round 5 up to the next higher integer</h2><span id='topic+myRound'></span>

<h3>Description</h3>

<p>The built-in <span class="rlang"><b>R</b></span> function <code><a href="base.html#topic+round">round</a></code> rounds a 5 to the even digit. Instead, we preferred
the more intuitive rounding meaning that a 5 is always rounded to the next higher digit. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>myRound(d)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="myRound_+3A_d">d</code></td>
<td>
<p>Real number.</p>
</td></tr></table>


<h3>Value</h3>

<p>The biggest integer not bigger than <code class="reqn">d</code> if <code class="reqn">d - \lfloor d \rfloor &lt; 0.5</code> and the smallest integer greater than
<code class="reqn">d</code> if <code class="reqn">d - \lfloor d \rfloor \ge 0.5</code>.</p>


<h3>Author(s)</h3>

<p>Kaspar Rufibach, <a href="mailto:kaspar.rufibach@gmail.com">kaspar.rufibach@gmail.com</a>, <br /> <a href="http://www.kasparrufibach.ch">http://www.kasparrufibach.ch</a>
</p>
<p>Guenther Walther, <a href="mailto:gwalther@stanford.edu">gwalther@stanford.edu</a>, <br /> <a href="www-stat.stanford.edu/~gwalther">www-stat.stanford.edu/~gwalther</a></p>


<h3>See Also</h3>

<p>The built-in <span class="rlang"><b>R</b></span> function <code><a href="base.html#topic+round">round</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c(1.5, 2.5)

## built in R function
round(x)
## [1] 2 2

## this function
myRound(x)
## [1] 2 3
</code></pre>

<hr>
<h2 id='preProcessX'>Prepare data vector according to available information on support endpoints of f</h2><span id='topic+preProcessX'></span>

<h3>Description</h3>

<p>Preprocesses the initial data vector X.raw according to whether the upper and/or lower endpoint of the support
of f is known.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>preProcessX(X.raw, lower = -Inf, upper = Inf)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="preProcessX_+3A_x.raw">X.raw</code></td>
<td>
<p>Vector of observations.</p>
</td></tr>
<tr><td><code id="preProcessX_+3A_lower">lower</code></td>
<td>
<p>Lower support point of <code class="reqn">f</code>, if known.</p>
</td></tr>
<tr><td><code id="preProcessX_+3A_upper">upper</code></td>
<td>
<p>Upper support point of <code class="reqn">f</code>, if known.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Depending whether <code class="reqn">lower</code> and <code class="reqn">upper</code> are known, the vector of raw observations <code class="reqn">X.raw</code>
is supplemented by <code class="reqn">lower</code> and/or <code class="reqn">upper</code> and finally sorted.</p>


<h3>Value</h3>

<p>Sorted vector of (processed) observations.</p>


<h3>Note</h3>

<p>This function is called by <code><a href="#topic+modeHunting">modeHunting</a></code>, <code><a href="#topic+modeHuntingApprox">modeHuntingApprox</a></code>, 
and <code><a href="#topic+modeHuntingBlock">modeHuntingBlock</a></code>.
</p>
<p>This function was derived from MatLab code provided on Lutz Duembgen's webpage, <br /> <a href="http://www.staff.unibe.ch/duembgen">http://www.staff.unibe.ch/duembgen</a>.   
</p>


<h3>Author(s)</h3>

<p>Kaspar Rufibach, <a href="mailto:kaspar.rufibach@gmail.com">kaspar.rufibach@gmail.com</a>, <br /> <a href="http://www.kasparrufibach.ch">http://www.kasparrufibach.ch</a> 
</p>
<p>Guenther Walther, <a href="mailto:gwalther@stanford.edu">gwalther@stanford.edu</a>, <br /> <a href="www-stat.stanford.edu/~gwalther">www-stat.stanford.edu/~gwalther</a></p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
