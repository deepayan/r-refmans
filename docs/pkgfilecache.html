<!DOCTYPE html><html><head><title>Help for package pkgfilecache</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {pkgfilecache}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#are_files_available'><p>Check whether the given files exist in the package cache.</p></a></li>
<li><a href='#download_files_with_md5_mismatch'><p>Download files marked as mismatch to package cache.</p></a></li>
<li><a href='#ensure_files_available'><p>Ensure all given files exist in the file cache, download them if they are not.</p></a></li>
<li><a href='#erase_file_cache'><p>Delete the full package cache directory for the given package.</p></a></li>
<li><a href='#files_exist_md5'><p>Check whether files exist, optionally with MD5 check.</p></a></li>
<li><a href='#flatten_filepath'><p>Turn a filepath into a flat string.</p></a></li>
<li><a href='#get_abs_filenames'><p>Join all relative filenames to a datadir.</p></a></li>
<li><a href='#get_absolute_path_for_files'><p>Construct absolute path for package cache files.</p></a></li>
<li><a href='#get_cache_dir'><p>Get the absolute path of the package cache.</p></a></li>
<li><a href='#get_filepath'><p>Retrieve the path to a single file from the package cache.</p></a></li>
<li><a href='#get_pkg_info'><p>Construct a pkg_info object to be used with all other functions.</p></a></li>
<li><a href='#get_relative_file_subdir'><p>Given a relative file, determine its subdir in the package cache.</p></a></li>
<li><a href='#list_available'><p>List files that are available locally in the package cache.</p></a></li>
<li><a href='#make_pgk_cache_subdir_for_all_relative_files'><p>Given a relative file, create the subdir in the package cache if needed.</p></a></li>
<li><a href='#make_pgk_cache_subdir_for_relative_file'><p>Given a relative file, create the subdir in the package cache if needed.</p></a></li>
<li><a href='#remove_cached_files'><p>Delete all the given files from the package cache.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Download and Manage Optional Package Data</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.5</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Tim Schäfer &lt;ts+code@rcmd.org&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Manage optional data for your package. The data can be hosted anywhere, and you have to give a Uniform Resource Locator (URL) for each file. File integrity checks are supported. This is useful for package authors who need to ship more than the 5 Megabyte of data currently allowed by the the Comprehensive R Archive Network (CRAN).</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/dfsp-spirit/pkgfilecache">https://github.com/dfsp-spirit/pkgfilecache</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/dfsp-spirit/pkgfilecache/issues">https://github.com/dfsp-spirit/pkgfilecache/issues</a></td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, testthat (&ge; 2.1.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>downloader, rappdirs, curl</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-02-02 18:17:05 UTC; spirit</td>
</tr>
<tr>
<td>Author:</td>
<td>Tim Schäfer <a href="https://orcid.org/0000-0002-3683-8070"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cre]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-02-02 20:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='are_files_available'>Check whether the given files exist in the package cache.</h2><span id='topic+are_files_available'></span>

<h3>Description</h3>

<p>Check whether the given files exist in the package cache. You can pass MD5 sums, which will be verified and only files with correct MD5 hash will count as existing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>are_files_available(pkg_info, relative_filenames, md5sums = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="are_files_available_+3A_pkg_info">pkg_info</code></td>
<td>
<p>named list. Package identifier, see get_pkg_info() on how to get one.</p>
</td></tr>
<tr><td><code id="are_files_available_+3A_relative_filenames">relative_filenames</code></td>
<td>
<p>vector of strings. A vector of filenames, relative to the package cache.</p>
</td></tr>
<tr><td><code id="are_files_available_+3A_md5sums">md5sums</code></td>
<td>
<p>vector of strings or NULL. A list of MD5 checksums, one for each file in param 'relative_filenames', if not NULL. If given, the files will only be reported as existing if the MD5 sums match.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>logical vector. For each file, whether it passed the check.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    pkg_info = get_pkg_info("mypackage")
    is_available = are_files_available(pkg_info, c("file1.txt", "file2.txt"))

</code></pre>

<hr>
<h2 id='download_files_with_md5_mismatch'>Download files marked as mismatch to package cache.</h2><span id='topic+download_files_with_md5_mismatch'></span>

<h3>Description</h3>

<p>Download files marked as mismatched to package cache. You should check afterwards whether this was successful, e.g., via 'files_exist_md5'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>download_files_with_md5_mismatch(
  local_files_absolute,
  local_files_md5_ok,
  urls,
  files_are_binary = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="download_files_with_md5_mismatch_+3A_local_files_absolute">local_files_absolute</code></td>
<td>
<p>vector of strings. A vector of filenames, must already include the package cache part.</p>
</td></tr>
<tr><td><code id="download_files_with_md5_mismatch_+3A_local_files_md5_ok">local_files_md5_ok</code></td>
<td>
<p>logical vector. For each file, whether the local copy is OK. Only files for which this lists FALSE will be downloaded.</p>
</td></tr>
<tr><td><code id="download_files_with_md5_mismatch_+3A_urls">urls</code></td>
<td>
<p>vector of strings. For each file, a remote URL where to download the file. Will be passed to 'downloader::download', see that function for URL encoding details.</p>
</td></tr>
<tr><td><code id="download_files_with_md5_mismatch_+3A_files_are_binary">files_are_binary</code></td>
<td>
<p>logical vector. For each file, whether it is binary. Only required on Windows, when files need to be downloaded. See 'downloader::download' docs for details.</p>
</td></tr>
</table>

<hr>
<h2 id='ensure_files_available'>Ensure all given files exist in the file cache, download them if they are not.</h2><span id='topic+ensure_files_available'></span>

<h3>Description</h3>

<p>Ensure all given files exist in the file cache, download them if they are not.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ensure_files_available(
  pkg_info,
  relative_filenames,
  urls,
  files_are_binary = NULL,
  md5sums = NULL,
  on_errors = "warn",
  download = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ensure_files_available_+3A_pkg_info">pkg_info</code></td>
<td>
<p>named list. Package identifier, see get_pkg_info() on how to get one.</p>
</td></tr>
<tr><td><code id="ensure_files_available_+3A_relative_filenames">relative_filenames</code></td>
<td>
<p>vector of strings. A vector of filenames, realtive to the package cache.</p>
</td></tr>
<tr><td><code id="ensure_files_available_+3A_urls">urls</code></td>
<td>
<p>vector of strings. For each file, a remote URL where to download the file. Will be passed to 'downloader::download', see that function for URL encoding details.</p>
</td></tr>
<tr><td><code id="ensure_files_available_+3A_files_are_binary">files_are_binary</code></td>
<td>
<p>logical vector. For each file, whether it is binary. Only required on Windows, when files need to be downloaded. See 'downloader::download' docs for details.</p>
</td></tr>
<tr><td><code id="ensure_files_available_+3A_md5sums">md5sums</code></td>
<td>
<p>vector of strings or NULL. A list of MD5 checksums, one for each file in param 'relative_filenames', if not NULL. If given, the files will only be reported as existing if the MD5 sums match.</p>
</td></tr>
<tr><td><code id="ensure_files_available_+3A_on_errors">on_errors</code></td>
<td>
<p>string. What to do if getting the files failed. One of c(&quot;warn&quot;, &quot;stop&quot;, &quot;ignore&quot;). At the end, files are checked using 'files_available'(including MD5 if given). Depending on the check results, the behaviours triggered are: &quot;warn&quot;: Print a warning for each file that failed the check. &quot;stop&quot;: Stop the script, i.e., the whole application. &quot;ignore&quot;: Do nothing. You can still react using the return value.</p>
</td></tr>
<tr><td><code id="ensure_files_available_+3A_download">download</code></td>
<td>
<p>logical. Whether to try downloading missing files. Defaults to TRUE. Existing files (with correct MD5 if available) will never be downloaded.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Named list. The list has entries: &quot;available&quot;: vector of strings. The names of the files that are available in the local file cache. You can access them using get_filepath(). &quot;missing&quot;: vector of strings. The names of the files that this function was unable to retrieve. &quot;file_status&quot;: Logical array indicating whether the files are available. Order is identical to the one in argument 'relative_filenames'.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   pkg_info = get_pkg_info("mypackage");
   local_relative_filenames = c("local_file1.txt", "local_file2.txt");
   bu = "https://raw.githubusercontent.com/dfsp-spirit/";
   url1 = paste(bu, "pkgfilecache/master/inst/extdata/file1.txt", sep="");
   url2 = paste(bu, "pkgfilecache/master/inst/extdata/file2.txt", sep="");
   urls = c(url1, url2);
   md5sums = c("35261471bcd198583c3805ee2a543b1f", "85ffec2e6efb476f1ee1e3e7fddd86de");
   res = ensure_files_available(pkg_info, local_relative_filenames, urls, md5sums=md5sums);
   erase_file_cache(pkg_info); # clear full cache

</code></pre>

<hr>
<h2 id='erase_file_cache'>Delete the full package cache directory for the given package.</h2><span id='topic+erase_file_cache'></span>

<h3>Description</h3>

<p>Delete the full package cache directory for the given package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>erase_file_cache(pkg_info)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="erase_file_cache_+3A_pkg_info">pkg_info</code></td>
<td>
<p>named list. Package identifier, see get_pkg_info() on how to get one.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>integer. The return value of the unlink() call: 0 for success, 1 for failure. See the unlink() documentation for details.
</p>

<hr>
<h2 id='files_exist_md5'>Check whether files exist, optionally with MD5 check.</h2><span id='topic+files_exist_md5'></span>

<h3>Description</h3>

<p>Check whether files exist. If MD5 hashes are given, they will be verified.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>files_exist_md5(files_absolute, md5sums = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="files_exist_md5_+3A_files_absolute">files_absolute</code></td>
<td>
<p>vector of strings. A vector of filenames. Files are check as given, so they must already include the package cache part of the path.</p>
</td></tr>
<tr><td><code id="files_exist_md5_+3A_md5sums">md5sums</code></td>
<td>
<p>vector of strings or NULL. A list of MD5 checksums, one for each file in param 'files', if not NULL. If given, the files will only be reported as existing if the MD5 sums match.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>logical vector. Whether the files exist. If the md5sums were given, whether the files exist and the MD5 sum matches.
</p>

<hr>
<h2 id='flatten_filepath'>Turn a filepath into a flat string.</h2><span id='topic+flatten_filepath'></span>

<h3>Description</h3>

<p>Turn a filepath into a flat string.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>flatten_filepath(filepath)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="flatten_filepath_+3A_filepath">filepath</code></td>
<td>
<p>string or list of strings</p>
</td></tr>
</table>


<h3>Value</h3>

<p>string, the flattened filepath
</p>

<hr>
<h2 id='get_abs_filenames'>Join all relative filenames to a datadir.</h2><span id='topic+get_abs_filenames'></span>

<h3>Description</h3>

<p>For each file, create a full path by joining the datadir with the filename.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_abs_filenames(datadir, relative_filenames)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_abs_filenames_+3A_datadir">datadir</code></td>
<td>
<p>string, the path to the package cache directory.</p>
</td></tr>
<tr><td><code id="get_abs_filenames_+3A_relative_filenames">relative_filenames</code></td>
<td>
<p>vector of strings. A vector of filenames, relative to the package cache. Can be a list of vectors, which will be interpreted as files with subdirs.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector of strings, the absolute file names.
</p>

<hr>
<h2 id='get_absolute_path_for_files'>Construct absolute path for package cache files.</h2><span id='topic+get_absolute_path_for_files'></span>

<h3>Description</h3>

<p>Construct absolute path for package cache files.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_absolute_path_for_files(pkg_info, relative_filenames)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_absolute_path_for_files_+3A_pkg_info">pkg_info</code></td>
<td>
<p>named list. Package identifier, see get_pkg_info() on how to get one.</p>
</td></tr>
<tr><td><code id="get_absolute_path_for_files_+3A_relative_filenames">relative_filenames</code></td>
<td>
<p>vector of strings. A vector of filenames, relative to the package cache.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector of strings. The absolute paths.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    rel_files = c("file1.txt", "file2.txt")
    pkg_info = get_pkg_info("mypackage")
    abs_paths = get_absolute_path_for_files(pkg_info, rel_files)

</code></pre>

<hr>
<h2 id='get_cache_dir'>Get the absolute path of the package cache.</h2><span id='topic+get_cache_dir'></span>

<h3>Description</h3>

<p>Get the absolute path of the package cache.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_cache_dir(pkg_info)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_cache_dir_+3A_pkg_info">pkg_info</code></td>
<td>
<p>named list. Package identifier, see get_pkg_info() on how to get one.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>string. The absolute path of the package cache. It is constructed by calling 'rappdirs::user_data_dir' with the package, author, and version if available. If the author is null, the package name is also used as the author name.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    pkg_info = get_pkg_info("mypackage")
    opt_data_dir = get_cache_dir(pkg_info)


</code></pre>

<hr>
<h2 id='get_filepath'>Retrieve the path to a single file from the package cache.</h2><span id='topic+get_filepath'></span>

<h3>Description</h3>

<p>Retrieve the path to a single file from the package cache.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_filepath(pkg_info, relative_filename, mustWork = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_filepath_+3A_pkg_info">pkg_info</code></td>
<td>
<p>named list. Package identifier, see get_pkg_info() on how to get one.</p>
</td></tr>
<tr><td><code id="get_filepath_+3A_relative_filename">relative_filename</code></td>
<td>
<p>string. A filename, relative to the package cache.</p>
</td></tr>
<tr><td><code id="get_filepath_+3A_mustwork">mustWork</code></td>
<td>
<p>logical. Whether an error should be created if the file does not exist.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>string. The path to the file. If mustWork=TRUE, the file is guaranteed to exist if the function returns (an error will occur if it does not). If mustWork=FALSE and the file does not exist, the empty string is returned.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    pkg_info = get_pkg_info("mypackage")
    full_path_of_file = get_filepath(pkg_info, "file1.txt", mustWork=FALSE)

</code></pre>

<hr>
<h2 id='get_pkg_info'>Construct a pkg_info object to be used with all other functions.</h2><span id='topic+get_pkg_info'></span>

<h3>Description</h3>

<p>This functions constructs an object that uniquely identifies your package, i.e., the package that want to use the package cache. This is not a secret.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_pkg_info(packagename, author = NULL, version = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_pkg_info_+3A_packagename">packagename</code></td>
<td>
<p>string. The name of the package using the package cache. Must be a valid directory name. Should not contain spaces. Passed as 'appname' to 'rappdirs::user_data_dir'.</p>
</td></tr>
<tr><td><code id="get_pkg_info_+3A_author">author</code></td>
<td>
<p>string. The author of the package using the package cache, or NULL. Must be a valid directory name if given, no need for the real author name. Should not contain spaces. Defaults to NULL. Passed as 'appauthor' to 'rappdirs::user_data_dir'. Leave at NULL if in doubt.</p>
</td></tr>
<tr><td><code id="get_pkg_info_+3A_version">version</code></td>
<td>
<p>string or NULL. An optional version path element to append to the path. You might want to use this if you want multiple versions of your pacakge to be able to have independent data. If used, this would typically be &quot;&lt;major&gt;.&lt;minor&gt;&quot;. Must be a valid directory name. Should not contain spaces or special characters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>named list. This can be passed to all function which require a 'pkg_info' argument. You should not care for the inner structure and treat it as some identifier.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    pkg_info = get_pkg_info("mypackage")
    pkg_info = get_pkg_info("mypackage", author="me")
    pkg_info = get_pkg_info("mypackage", author="me", version="0.3")

</code></pre>

<hr>
<h2 id='get_relative_file_subdir'>Given a relative file, determine its subdir in the package cache.</h2><span id='topic+get_relative_file_subdir'></span>

<h3>Description</h3>

<p>Given a relative file, determine its subdir in the package cache.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_relative_file_subdir(pkg_info, relative_file)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_relative_file_subdir_+3A_pkg_info">pkg_info</code></td>
<td>
<p>named list. Package identifier, see get_pkg_info() on how to get one.</p>
</td></tr>
<tr><td><code id="get_relative_file_subdir_+3A_relative_file">relative_file</code></td>
<td>
<p>string or vector of strings. If a string, this function does nothing. If a vector of strings, a path is created from the elements using file.path, and the directory of it (determined by dirname()) is created.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>named list. The entries are: &quot;has_subdir&quot;: logical, whether the file has a subdir. &quot;relative_filepath&quot;: string. The input relative_file, flattened to a string. For files without subdir, this is identical to string in the parameter 'relative_file'. For others, it is the result of applying file.path() to the elements of the vector 'relative_file'. If &quot;has_subdir&quot; is TRUE, the following 2 fields also exist: &quot;relative_subdir&quot;: string, subdir path relative to package cache dir. &quot;absolute_subdir&quot;: string, absolute subdir path.
</p>

<hr>
<h2 id='list_available'>List files that are available locally in the package cache.</h2><span id='topic+list_available'></span>

<h3>Description</h3>

<p>List files that are available locally in the package cache.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>list_available(pkg_info)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="list_available_+3A_pkg_info">pkg_info</code></td>
<td>
<p>named list. Package identifier, see get_pkg_info() on how to get one.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector of strings. The file names available, relative to the package cache. The returned names may include a subdirectory part. The subdirectories are not listed separately.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    pkg_info = get_pkg_info("mypackage")
    available_files_in_cache = list_available(pkg_info)

</code></pre>

<hr>
<h2 id='make_pgk_cache_subdir_for_all_relative_files'>Given a relative file, create the subdir in the package cache if needed.</h2><span id='topic+make_pgk_cache_subdir_for_all_relative_files'></span>

<h3>Description</h3>

<p>Given a relative file, create the subdir in the package cache if needed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_pgk_cache_subdir_for_all_relative_files(pkg_info, relative_filenames)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_pgk_cache_subdir_for_all_relative_files_+3A_pkg_info">pkg_info</code></td>
<td>
<p>named list. Package identifier, see get_pkg_info() on how to get one.</p>
</td></tr>
<tr><td><code id="make_pgk_cache_subdir_for_all_relative_files_+3A_relative_filenames">relative_filenames</code></td>
<td>
<p>vector of strings. A vector of filenames, relative to the package cache. Can be a list of vectors, which will be interpreted as files with subdirs.</p>
</td></tr>
</table>

<hr>
<h2 id='make_pgk_cache_subdir_for_relative_file'>Given a relative file, create the subdir in the package cache if needed.</h2><span id='topic+make_pgk_cache_subdir_for_relative_file'></span>

<h3>Description</h3>

<p>Given a relative file, create the subdir in the package cache if needed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_pgk_cache_subdir_for_relative_file(pkg_info, relative_file)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_pgk_cache_subdir_for_relative_file_+3A_pkg_info">pkg_info</code></td>
<td>
<p>named list. Package identifier, see get_pkg_info() on how to get one.</p>
</td></tr>
<tr><td><code id="make_pgk_cache_subdir_for_relative_file_+3A_relative_file">relative_file</code></td>
<td>
<p>string or vector of strings. If a string, this function does nothing. If a vector of strings, a path is created from the elements using file.path, and the directory of it (determined by dirname()) is created.</p>
</td></tr>
</table>

<hr>
<h2 id='remove_cached_files'>Delete all the given files from the package cache.</h2><span id='topic+remove_cached_files'></span>

<h3>Description</h3>

<p>Delete all the given files from the package cache.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>remove_cached_files(pkg_info, relative_filenames)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="remove_cached_files_+3A_pkg_info">pkg_info</code></td>
<td>
<p>named list. Package identifier, see get_pkg_info() on how to get one.</p>
</td></tr>
<tr><td><code id="remove_cached_files_+3A_relative_filenames">relative_filenames</code></td>
<td>
<p>vector of strings. A vector of filenames, relative to the package cache.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>logical vector. For each file, whether it was deleted. Note that files which did not exist were not deleted! You should check the results using 'files_available'.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    pkg_info = get_pkg_info("mypackage")
    deleted = remove_cached_files(pkg_info, "some_file.txt")

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
