<!DOCTYPE html><html><head><title>Help for package blockTools</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {blockTools}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#blockTools-package'><p>Block, Randomly Assign, and Diagnose Potential Interference in Randomized Experiments</p></a></li>
<li><a href='#assg2xBalance'><p>Calculate balance statistics from an assignment object</p></a></li>
<li><a href='#assignment'><p>Randomly assign blocked units to treatment conditions</p></a></li>
<li><a href='#block'><p>Block units into homogeneous experimental blocks</p></a></li>
<li><a href='#block2seqblock'><p>Prepare prior nonsequential assignments for subsequent sequential assignments</p></a></li>
<li><a href='#createBlockIDs'><p>Create vector of integers containing block identifiers</p></a></li>
<li><a href='#diagnose'><p>Diagnose whether units assigned to different treatment</p>
conditions may be subject to interference or pairwise imbalance</a></li>
<li><a href='#extract_conditions'><p>Create vector of integers containing treatment condition identifiers</p></a></li>
<li><a href='#invertRIconfInt'><p>Calculate treatment effect confidence intervals by inverting the randomization test</p></a></li>
<li><a href='#outCSV'><p>Export blocked or assigned data to .csv format files</p></a></li>
<li><a href='#outTeX'><p>Export blocked or assigned data to .tex format files</p></a></li>
<li><a href='#seqblock'><p>Sequential assignment of unit(s) into experimental conditions using covariates</p></a></li>
<li><a href='#x100'><p>Simulated data for demonstrating blockTools functionality</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Block, Assign, and Diagnose Potential Interference in Randomized
Experiments</td>
</tr>
<tr>
<td>Version:</td>
<td>0.6.4</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-02-03</td>
</tr>
<tr>
<td>Imports:</td>
<td>dplyr, MASS, tibble</td>
</tr>
<tr>
<td>Suggests:</td>
<td>nbpMatching, RItools, testthat (&ge; 3.0.0), xtable</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Description:</td>
<td>Blocks units into experimental blocks, with one unit per treatment condition, by creating a measure of multivariate distance between all possible pairs of units.  Maximum, minimum, or an allowable range of differences between units on one variable can be set.  Randomly assign units to treatment conditions.  Diagnose potential interference between units assigned to different treatment conditions.  Write outputs to .tex and .csv files.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> | file LICENSE [expanded from: GPL (&ge; 2) | file LICENSE]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://www.ryantmoore.org/html/software.blockTools.html">https://www.ryantmoore.org/html/software.blockTools.html</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-02-04 20:29:12 UTC; rtm</td>
</tr>
<tr>
<td>Author:</td>
<td>Ryan T. Moore <a href="https://orcid.org/0000-0002-3916-8113"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Keith Schnakenberg [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Ryan T. Moore &lt;rtm@american.edu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-02-06 08:22:38 UTC</td>
</tr>
</table>
<hr>
<h2 id='blockTools-package'>Block, Randomly Assign, and Diagnose Potential Interference in Randomized Experiments</h2><span id='topic+blockTools-package'></span><span id='topic+blockTools'></span>

<h3>Description</h3>

<p>Block units into experimental blocks, with one unit per
treatment condition, by creating a measure of multivariate distance
between all possible pairs of units.  Maximum, minimum, or an
allowable range of differences between units on one variable can be
set.  Randomly assign units to treatment conditions.  Diagnose
potential interference problems between units assigned to different
treatment conditions. Write outputs to .tex and .csv files.
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> blockTools</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 0.6.4</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2023-02-03</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;">  GPL (&gt;=2)</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>Given raw data, <code>block</code> creates experimental blocks,
<code>assignment</code> assigns units to treatment conditions, <code>diagnose</code>
detects possible interference problems, and <code>outTeX</code> and
<code>outCSV</code> write block or assignment output objects to a set of .tex
and .csv files, respectively.  In sequential experiments, <code>seqblock</code> assigns units to treatment conditions.
</p>


<h3>Author(s)</h3>

<p>Ryan T. Moore <a href="mailto:rtm@american.edu">rtm@american.edu</a> and Keith Schnakenberg <a href="mailto:keith.schnakenberg@gmail.com">keith.schnakenberg@gmail.com</a>
</p>
<p>Maintainer: Ryan T. Moore <a href="mailto:rtm@american.edu">rtm@american.edu</a>
</p>


<h3>References</h3>

<p><a href="https://www.ryantmoore.org/html/software.blockTools.html">https://www.ryantmoore.org/html/software.blockTools.html</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(x100)

# block
out &lt;- block(x100, groups = "g", n.tr = 2, id.vars = c("id"), block.vars
             = c("b1", "b2"), algorithm="optGreedy", distance =
             "mahalanobis", level.two = FALSE, valid.var = "b1",
             valid.range = c(0,500), verbose = TRUE)

# assign
assg &lt;- assignment(out, seed = 123)

# diagnose
diag &lt;- diagnose(object = assg, data = x100, id.vars = "id",
                suspect.var = "b2", suspect.range = c(0,50))

# create .tex files of assigned blocks
# outTeX(assg)

# create .csv files of unassigned blocks
# outCSV(out)

# create block IDs
createBlockIDs(out, x100, id.var = "id")

# block ID integers are unique, even with several groups
axb &lt;- assg2xBalance(assg, x100, id.var = "id", bal.vars = c("b1", "b2"))
</code></pre>

<hr>
<h2 id='assg2xBalance'>Calculate balance statistics from an assignment object</h2><span id='topic+assg2xBalance'></span>

<h3>Description</h3>

<p>Calculate several balance statistics for experimental units assigned to treatment conditions.  Naturally accepts output from the <code>assignment</code> function, and passes it to <code>xBalance</code> from <code>library(RItools)</code>.  Provides balance summaries for the entire experiment and by group.    
</p>


<h3>Usage</h3>

<pre><code class='language-R'>assg2xBalance(assg.obj, data, id.var, bal.vars, to.report = "all")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="assg2xBalance_+3A_assg.obj">assg.obj</code></td>
<td>
<p>an output object from <code>assignment</code>.</p>
</td></tr>
<tr><td><code id="assg2xBalance_+3A_data">data</code></td>
<td>
<p>the data frame that was input into <code>block</code> for blocking.</p>
</td></tr>
<tr><td><code id="assg2xBalance_+3A_id.var">id.var</code></td>
<td>
<p>a string specifying the column of <code>data</code> containing identifying information.</p>
</td></tr>
<tr><td><code id="assg2xBalance_+3A_bal.vars">bal.vars</code></td>
<td>
<p>a string or vector of strings specifying which column(s) of <code>data</code> contain the variables on which balance is to be checked.</p>
</td></tr>
<tr><td><code id="assg2xBalance_+3A_to.report">to.report</code></td>
<td>
<p>a string or vector of strings passed to <code>xBalance</code> listing the measures to report for each group.  See Details for more information.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>As of <code>RItools</code> version 0.1-11, <code>to.report</code> must be a subset of <code>c("std.diffs","z.scores","adj.means", "adj.mean.diffs","adj.mean.diffs.null.sd", "chisquare.test","p.values", "all")</code>.  The default, <code>all</code>, returns all measures.
</p>


<h3>Value</h3>

<p>A list of output objects from <code>xBalance</code>.  For each group defined in the <code>assignment</code> object, one list element is assigned the name of that group and summarizes the balance in that group according to <code>to.report</code>.  The last element of the list is named <code>"Overall"</code> and summarizes balance across all groups.  The elements of this list are themselves objects of class <code>c("xbal", "list")</code>.  
</p>
<p>If <code>assg.obj</code> has only one group, the first element of the output list is named <code>"Group1"</code>, and the second is named <code>"Output"</code>.  In this case, these two elements will be identical.
</p>


<h3>Author(s)</h3>

<p>Ryan T. Moore</p>


<h3>References</h3>

<p>Hansen, Ben B. and Jake Bowers. 2008. &quot;Covariate balance in simple,
stratified and clustered comparative studies&quot;. <em>Statistical
Science</em> 23(2):219&ndash;236.
</p>
<p>Bowers, Jake and Mark Fredrickson and Ben
Hansen. 2010. &quot;RItools:Randomization Inference Tools&quot;. R package
version 0.1-11.
</p>
<p>Moore, Ryan T. 2012. &quot;Multivariate Continuous Blocking to Improve Political Science
Experiments&quot;. <em>Political Analysis</em>, 20(4):460&ndash;479, Autumn.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+assignment">assignment</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(x100)
b &lt;- block(x100, groups = "g", id.vars = "id", block.vars = c("b1", "b2"))
a &lt;- assignment(b)
axb &lt;- assg2xBalance(a, x100, id.var = "id", bal.vars = c("b1", "b2"))
axb

# axb is a list with 4 elements (one for each of 3 groups, plus one for 'Overall')
</code></pre>

<hr>
<h2 id='assignment'>Randomly assign blocked units to treatment conditions</h2><span id='topic+assignment'></span>

<h3>Description</h3>

<p>Using an output object from <code>block</code>, assign elements
of each row to treatment condition columns.  Each element is equally 
likely to be assigned to each column.</p>


<h3>Usage</h3>

<pre><code class='language-R'> assignment(block.obj, seed = NULL, namesCol = NULL) </code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="assignment_+3A_block.obj">block.obj</code></td>
<td>
<p>an output object from <code>block</code>, or a user-specified
block object.</p>
</td></tr>
<tr><td><code id="assignment_+3A_seed">seed</code></td>
<td>
<p>a user-specified random seed.</p>
</td></tr>
<tr><td><code id="assignment_+3A_namescol">namesCol</code></td>
<td>
<p>an optional vector of column names for the output
table.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>block.obj</code> can be specified directly by the user.  It can be a
single dataframe or matrix with blocks as rows and treatment
conditions as columns.  <code>assignment</code> is designed to take a list
with two elements.  The first element should be named <code>$blocks</code>,
and should be a list of dataframes.  Each dataframe should have blocks
as rows and treatment conditions as columns.  The second element
should be a logical named <code>$level.two</code>.  A third element, such as
<code>$call</code> in a <code>block</code> output object, is currently ignored.
</p>
<p>Specifying the random seed yields constant assignment, and thus allows
for easy replication of experimental protocols.
</p>
<p>If <code>namesCol = NULL</code>, then &ldquo;Treatment 1&rdquo;,
&ldquo;Treatment 2&rdquo;, ... are used.  If <code>namesCol</code> is supplied by the user 
and is of length <code>n.tr</code> (or 2*<code>n.tr</code>, where <code>level.two = TRUE</code>), 
then either <code>"Distance"</code> or <code>"Max Distance"</code> is appended to it as 
appropriate (consistent with <code>namesCol</code> usage in <code>block</code>).  If 
<code>namesCol</code> is supplied and is of length <code>n.tr</code>+1 (or 2*<code>n.tr</code>+1, 
where <code>level.two = TRUE</code>), then the last user-supplied name is used for the 
last column of each dataframe.
</p>


<h3>Value</h3>

<p>A list with elements
</p>
<table>
<tr><td><code>assg</code></td>
<td>
<p>a list of dataframes, each containing a group's blocked
units assigned to treatment conditions.  If there are two treatment
conditions, then the last column of each dataframe displays the
multivariate distance between the two units.  If there are more than
two treatment conditions, then the last column of each dataframe
displays the largest of the multivariate distances between all
possible pairs in the block.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>the orginal call to <code>assignment</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Ryan T. Moore</p>


<h3>See Also</h3>

<p><code><a href="#topic+block">block</a></code>, <code><a href="#topic+diagnose">diagnose</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(x100)

# First, block
out &lt;- block(x100, groups = "g", n.tr = 2, id.vars = c("id"), block.vars
             = c("b1", "b2"), algorithm="optGreedy", distance =
             "mahalanobis", level.two = FALSE, valid.var = "b1",
             valid.range = c(0,500), verbose = TRUE)

# Second, assign
assigned &lt;- assignment(out, seed = 123)

# assigned$assg contains 3 data frames
</code></pre>

<hr>
<h2 id='block'>Block units into homogeneous experimental blocks</h2><span id='topic+block'></span>

<h3>Description</h3>

<p>Block units into experimental blocks, with one unit per treatment
condition.  Blocking begins by creating a measure of
multivariate distance between all possible pairs of units.  Maximum,
minimum, or an allowable range of differences between units on one
variable can be set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>block(data, vcov.data = NULL, groups = NULL, n.tr = 2, id.vars,
  block.vars = NULL, algorithm = "optGreedy", distance = "mahalanobis",
  weight = NULL, optfactor = 10^7, row.sort = NULL, level.two = FALSE, 
  valid.var = NULL, valid.range = NULL, seed.dist, namesCol = NULL, verbose = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="block_+3A_data">data</code></td>
<td>
<p>a dataframe or matrix, with units in rows and variables in
columns.</p>
</td></tr>
<tr><td><code id="block_+3A_vcov.data">vcov.data</code></td>
<td>
<p>an optional matrix of data used to estimate the
variance-covariance matrix for calculating multivariate distance.</p>
</td></tr>
<tr><td><code id="block_+3A_groups">groups</code></td>
<td>
<p>an optional column name from <code>data</code>, specifying subgroups
within which blocking occurs.</p>
</td></tr>
<tr><td><code id="block_+3A_n.tr">n.tr</code></td>
<td>
<p>the number of treatment conditions per block.</p>
</td></tr>
<tr><td><code id="block_+3A_id.vars">id.vars</code></td>
<td>
<p>a required string or vector of two strings specifying which
column(s) of <code>data</code> contain identifying information.</p>
</td></tr>
<tr><td><code id="block_+3A_block.vars">block.vars</code></td>
<td>
<p>an optional string or vector of strings specifying which
column(s) of <code>data</code> contain the numeric blocking variables.</p>
</td></tr>
<tr><td><code id="block_+3A_algorithm">algorithm</code></td>
<td>
<p>a string specifying the blocking algorithm.
<code>"optGreedy"</code>, <code>"optimal"</code>, <code>"naiveGreedy"</code>, <code>"randGreedy"</code>, and
<code>"sortGreedy"</code> algorithms are currently available.  See Details
for more information.</p>
</td></tr>
<tr><td><code id="block_+3A_distance">distance</code></td>
<td>
<p>either a) a string defining how the multivariate
distance used for blocking is calculated (options include
<code>"mahalanobis"</code>, <code>"mcd"</code>, <code>"mve"</code>, and <code>"euclidean"</code>), or b) a
user-defined $k$-by-$k$ matrix of distances, where $k$ is the number of rows in 
<code>data</code>.</p>
</td></tr>
<tr><td><code id="block_+3A_weight">weight</code></td>
<td>
<p>either a vector of length equal to the number of blocking 
variables or a square matrix with dimensions equal to the number of 
blocking variables used to explicitly weight blocking variables.</p>
</td></tr>
<tr><td><code id="block_+3A_optfactor">optfactor</code></td>
<td>
<p>a number by which distances are multiplied then divided when <code>algorithm = "optimal"</code>.</p>
</td></tr>
<tr><td><code id="block_+3A_row.sort">row.sort</code></td>
<td>
<p>an optional vector of integers from 1 to
<code>nrow(data)</code> used to sort the rows of data when
<code>algorithm = "sortGreedy"</code>.</p>
</td></tr>
<tr><td><code id="block_+3A_level.two">level.two</code></td>
<td>
<p>a logical defining the level of blocking.</p>
</td></tr>
<tr><td><code id="block_+3A_valid.var">valid.var</code></td>
<td>
<p>an optional string defining a variable on which
units in the same block must fall within the range defined by
<code>valid.range</code>.</p>
</td></tr> 
<tr><td><code id="block_+3A_valid.range">valid.range</code></td>
<td>
<p>an optional vector defining the range of
<code>valid.var</code> within which units in the same block must fall.</p>
</td></tr>
<tr><td><code id="block_+3A_seed.dist">seed.dist</code></td>
<td>
<p>an optional integer value for the random seed set in
<code>cov.rob</code>, used to calculate measures of the
variance-covariance matrix robust to outliers.</p>
</td></tr>
<tr><td><code id="block_+3A_namescol">namesCol</code></td>
<td>
<p>an optional vector of column names for the output
table.</p>
</td></tr>
<tr><td><code id="block_+3A_verbose">verbose</code></td>
<td>
<p>a logical specifying whether <code>groups</code> names and 
block numbers are printed as blocks are created.</p>
</td></tr>
<tr><td><code id="block_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code>cov.rob</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>vcov.data = NULL</code>, then <code>block</code> calculates the
variance-covariance matrix using the <code>block.vars</code> from
<code>data</code>. 
</p>
<p>If <code>groups</code> is not user-specified, <code>block</code> temporarily creates
a variable in <code>data</code> called <code>groups</code>, which takes the value
1 for every unit.
</p>
<p>Where possible, one unit is assigned to each condition in each block.
If there are fewer available units than treatment conditions, available
units are used.
</p>
<p>If <code>n.tr</code> $&gt; 2$, then the <code>optGreedy</code> algorithm finds the best
possible pair match, then the best match to either member of the pair,
then the best match to any member of the triple, etc.  After finding the best pair match to a given unit, the other greedy algorithms proceed by finding the third, fourth, etc. best match to that given unit.
</p>
<p>An example of <code>id.vars</code> is <code>id.vars = c("id", "id2")</code>.  If
two-level blocking is selected, <code>id.vars</code> should be ordered 
(unit id, subunit id).  See details for <code>level.two</code> below for more 
information.
</p>
<p>If <code>block.vars = NULL</code>, then all variables in <code>data</code> except
the <code>id.vars</code> are taken as blocking variables.  E.g.,
<code>block.vars = c("b1", "b2")</code>.  
</p>
<p>The algorithm <code>optGreedy</code> calls an optimal-greedy algorithm, repeatedly
finding the best remaining match in the entire dataset;
<code>optimal</code> finds the set of blocks that minimizes the sum of the
distances in all blocks; <code>naiveGreedy</code> finds the best match
proceeding down the dataset from the first unit to the last;
<code>randGreedy</code> randomly selects a unit, finds its best match, and
repeats; <code>sortGreedy</code> resorts the dataset according to
<code>row.sort</code>, then implements the <code>naiveGreedy</code> algorithm.
</p>
<p>The <code>optGreedy</code> algorithm breaks ties by randomly selecting one of
the minimum-distance pairs.  The <code>naiveGreedy</code>, <code>sortGreedy</code>,
and <code>randGreedy</code> algorithms break ties by randomly selecting one of
the minimum-distance matches to the particular unit in question.
</p>
<p>As of version 0.5-1, blocking is done in C for all algorithms except
<code>optimal</code> (see following paragraphs for more details on the
<code>optimal</code> algorithm implementation).
</p>
<p>The <code>optimal</code> algorithm uses two functions from the
<span class="pkg">nbpMatching</span> package: <code>distancematrix</code> prepares a distance
matrix for optimal blocking, and <code>nonbimatch</code> performs the
optimal blocking by minimizing the sum of distances in blocks.
<code>nonbimatch</code>, and thus the <code>block</code> algorithm
<code>optimal</code>, requires that <code>n.tr = 2</code>.
</p>
<p>Because <code>distancematrix</code> takes the integer <code>floor</code> of the
distances, and one may want much finer precision, the multivariate
distances calculated within <code>block</code> are multiplied by
<code>optfactor</code> prior to optimal blocking.  Then
<code>distancematrix</code> prepares the resulting distance matrix, and
<code>nonbimatch</code> is called on the output.  The distances are then
untransformed by dividing by <code>optfactor</code> before being returned by
<code>block</code>.
</p>
<p>The choice of <code>optfactor</code> can determine whether the Fortran code
can allocate enough memory to solve the optimization problem.  For
example, blocking the first 14 units of <code><a href="#topic+x100">x100</a></code> by executing
<code>block(x100[1:14, ], id.vars = "id", block.vars = c("b1", "b2"),
algorithm = "optimal", optfactor = 10^8)</code> fails for Fortran memory
reasons, while the same code with <code>optfactor = 10^5</code> runs
successfully.  Smaller values of <code>optfactor</code> imply easier
computation, but less precision.
</p>
<p>Most of the algorithms in <code>block</code> make prohibited blockings by
using a distance of <code>Inf</code>.  However, the optimal algorithm calls
<code>Fortran</code> code from <span class="pkg">nbpMatching</span> and requires integers.
Thus, a distance of <code>99999*max(dist.mat)</code> is used to effectively
prohibit blockings.  This follows the procedure demonstrated in the
example of <code>help(nonbimatch)</code>.
</p>
<p>In order to enable comparisons of block-quality across groups, when
<code>distance</code> is a string, $Sigma$ is calculated using units from
all groups.
</p>
<p>The <code>distance = "mcd"</code> and <code>distance = "mve"</code> options call
<code>cov.rob</code> to calculate measures of multivariate spread robust to
outliers.  The <code>distance = "mcd"</code> option calculates the Minimum
Covariance Determinant estimate (Rousseeuw 1985); the <code>distance = "mve"</code> option
calculates the Minimum Volume Ellipsoid estimate (Rousseeuw and van Zomeren 1990).  When <code>distance = "mcd"</code>, the interquartile range on blocking variables should not be zero.
</p>
<p>A user-specified distance matrix must have diagonals equal to 0,
indicating zero distance between a unit and itself.  Only the lower
triangle of the matrix is used.
</p>
<p>If <code>weight</code> is a vector, then it is used as the diagonal of a square 
weighting matrix with non-diagonal elements equal to zero.  The
weighting is done by using as the Mahalanobis distance scaling matrix
$((((chol(Sigma))')^{-1})'W((chol(Sigma))')^{-1})^{-1}$, where 
$chol(Sigma)$ is the Cholesky decomposition of the usual variance-covariance 
matrix and $W$ is the weighting matrix.  Differences should be smaller 
on covariates given higher weights.
</p>
<p>If <code>level.two = TRUE</code>, then the best subunit block-matches in
different units are found.  E.g., provinces could be matched based on
the most similar cities within them.  All subunits in the data should
have unique names.  Thus, if subunits are numbered 1 to (number of
subunits in unit) within each unit, then they should be renumbered,
e.g., 1 to (total number of subunits in all units).  <code>level.two</code>
blocking is not currently implemented for <code>algorithm =
"optimal"</code>.  Units with no blocked subunit are put into their own
blocks.  However, unblocked subunits within a unit that does have a
blocked subunit are not put into their own blocks.
</p>
<p>An example of a variable restriction is <code>valid.var = "b2"</code>,
<code>valid.range = c(10,50)</code>, which requires that units in the same
block be at least 10 units apart, but no more than 50 units apart, on
variable <code>"b2"</code>.  As of version 0.5-3, variable restrictions are
implemented in all algorithms except <code>optimal</code>.  Note that
employing a variable restriction may result in fewer than the maximum possible number of blocks.  See 
<a href="https://www.ryantmoore.org/html/software.blockTools.html">https://www.ryantmoore.org/html/software.blockTools.html</a> for details.
</p>
<p>If <code>namesCol = NULL</code>, then &ldquo;Unit 1&rdquo;,
&ldquo;Unit 2&rdquo;, ... are used.  If <code>level.two = FALSE</code>, then <code>namesCol</code> should be of length <code>n.tr</code>; if <code>level.two = TRUE</code>, then <code>namesCol</code> should be of length 2*<code>n.tr</code>, and in the order shown in the example below.
</p>


<h3>Value</h3>

<p> A list with elements
</p>
<table>
<tr><td><code>blocks</code></td>
<td>
<p>a list of dataframes, each containing a group's blocked
units.  If there are two treatment conditions, then the last column
of each dataframe displays the multivariate distance between the two
units.  If there are more than two treatment conditions, then the
last column of each dataframe displays the largest of the
multivariate distances between all possible pairs in the block.</p>
</td></tr>
<tr><td><code>level.two</code></td>
<td>
<p>a logical indicating whether <code>level.two =
      TRUE</code>.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>the orginal call to <code>block</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Ryan T. Moore <a href="mailto:rtm@american.edu">rtm@american.edu</a> and Keith Schnakenberg <a href="mailto:keith.schnakenberg@gmail.com">keith.schnakenberg@gmail.com</a></p>


<h3>References</h3>

<p>King, Gary, Emmanuela Gakidou, Nirmala Ravishankar, Ryan T. Moore, Jason
Lakin, Manett Vargas, Martha Mar\'ia T\'ellez-Rojo and Juan Eugenio
Hern\'andez \'Avila and Mauricio Hern\'andez \'Avila and H\'ector
Hern\'andez Llamas.  2007.  &quot;A 'Politically Robust' Experimental Design
for Public Policy Evaluation, with Application to the Mexican Universal
Health Insurance Program&quot;. <em>Journal of Policy Analysis and
Management</em> 26(3):  479-509.
</p>
<p>Moore, Ryan T. 2012. &quot;Multivariate Continuous Blocking to Improve Political Science
Experiments.&quot; <em>Political Analysis</em> 20(4):460-479.
</p>
<p>Rousseeuw, Peter J. 1985. &quot;Multivariate Estimation with High Breakdown Point&quot;. <em>Mathematical Statistics and Applications</em> 8:283-297.
</p>
<p>Rousseeuw, Peter J. and Bert C. van Zomeren. 1990. &quot;Unmasking Multivariate Outliers and Leverage Points&quot;. <em>Journal of the American Statistical Association</em> 85(411):633-639.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+assignment">assignment</a></code>, <code><a href="#topic+diagnose">diagnose</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(x100)
out &lt;- block(x100, groups = "g", n.tr = 2, id.vars = c("id"), block.vars
             = c("b1", "b2"), algorithm="optGreedy", distance =
             "mahalanobis", level.two = FALSE, valid.var = "b1",
             valid.range = c(0,500), verbose = TRUE)
## out$blocks contains 3 data frames

## To illustrate two-level blocking, with multiple level two units per
##  level one unit:
for(i in (1:nrow(x100))){if((i %% 2) == 0){x100$id[i] &lt;- x100$id[i-1]}}

out2 &lt;- block(x100, groups = "g", n.tr = 2, id.vars = c("id", "id2"),
              block.vars = c("b1", "b2"), algorithm="optGreedy",
              distance = "mahalanobis", level.two = TRUE, valid.var =
              "b1", valid.range = c(0,500), namesCol = c("State 1", "City 1", 
	      "State 2", "City 2"), verbose = TRUE) 
</code></pre>

<hr>
<h2 id='block2seqblock'>Prepare prior nonsequential assignments for subsequent sequential assignments</h2><span id='topic+block2seqblock'></span>

<h3>Description</h3>

<p>Converts output objects from the <code>block</code> and <code>assignment</code> functions
into an object in the format of one output by the <code>seqblock</code> function. This allows the
user to block and assign multiple units at the beginning of an experiment (using <code>block</code> and
<code>assignment</code>) and then sequentially block and assign more units to the experiment over time
(using <code>seqblock</code>).</p>


<h3>Usage</h3>

<pre><code class='language-R'>block2seqblock(block.obj, assg.obj, data, exact.restr = NULL, covar.restr = NULL, 
  covar.order = NULL, trn = NULL, apstat = "mean", mtrim = 0.1, apmeth = "ktimes", 
  kfac = 2, assgpr = c(0.5, 0.5), distance = NULL, datetime = NULL, orig, seed = NULL,
  file.name = "sbout.RData", verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="block2seqblock_+3A_block.obj">block.obj</code></td>
<td>
<p>an output object from <code>block</code>, or a user-specified block object</p>
</td></tr>
<tr><td><code id="block2seqblock_+3A_assg.obj">assg.obj</code></td>
<td>
<p>an output object from <code>assignment</code>, or a user-specified assignment object</p>
</td></tr>
<tr><td><code id="block2seqblock_+3A_data">data</code></td>
<td>
<p>a matrix or dataframe containing the original data used to block the units in the study</p>
</td></tr>
<tr><td><code id="block2seqblock_+3A_exact.restr">exact.restr</code></td>
<td>
<p>a list object containing the restricted values that the exact blocking variables can take on. Thus the first element of <code>exact.restr</code> is a vector containing all of the possible values that the first exact blocking variable can take on; the second element is a vector containing all of the possible values for the second exact blocking variable; and so on</p>
</td></tr>
<tr><td><code id="block2seqblock_+3A_covar.restr">covar.restr</code></td>
<td>
<p>a list object containing the restricted values that the non-exact blocking variables can take on. Thus the first element of <code>covar.restr</code> is a vector containing all of the possible values that the first non-exact blocking variable can take on; the second element is a vector containing all of the possible values for the second non-exact blocking variable; and so on</p>
</td></tr>
<tr><td><code id="block2seqblock_+3A_covar.order">covar.order</code></td>
<td>
<p>a string or vector of strings containing the name of the non-exact blocking variables ordered so that the highest priority covariate comes first, followed by the second highest priority covariate, then the third, etc.</p>
</td></tr>
<tr><td><code id="block2seqblock_+3A_trn">trn</code></td>
<td>
<p>a string or vector of strings containing the names of the different treatment groups</p>
</td></tr>
<tr><td><code id="block2seqblock_+3A_apstat">apstat</code></td>
<td>
<p>a string specifying the assignment probability summary statistic that was used</p>
</td></tr>
<tr><td><code id="block2seqblock_+3A_mtrim">mtrim</code></td>
<td>
<p>a numeric value specifying the proportion of observations to be dropped when the assignment probability statistic takes on the value <code>"trimmean"</code>.</p>
</td></tr>
<tr><td><code id="block2seqblock_+3A_apmeth">apmeth</code></td>
<td>
<p>a string specifying the assignment probability algorithm that was used.</p>
</td></tr>
<tr><td><code id="block2seqblock_+3A_kfac">kfac</code></td>
<td>
<p>the assignment probability <em>kfactor</em>; see <em>assg.prob.kfac</em> in the Arguments section above</p>
</td></tr> 
<tr><td><code id="block2seqblock_+3A_assgpr">assgpr</code></td>
<td>
<p>a vector of assignment probabilities to each treatment group</p>
</td></tr>
<tr><td><code id="block2seqblock_+3A_distance">distance</code></td>
<td>
<p>a string specifying how the multivarite distance used for blocking is calculated</p>
</td></tr> 
<tr><td><code id="block2seqblock_+3A_datetime">datetime</code></td>
<td>
<p>the date and time that the units were assigned to the treatment group; by default this is set to be a vector of NA; however the user could also specify a specific datetime and all of the units from the block object will be given the same datetime stamp</p>
</td></tr> 
<tr><td><code id="block2seqblock_+3A_orig">orig</code></td>
<td>
<p>a dataframe containing the names and values for the different id and blocking variables, as well as each unit's initial treatment assignment</p>
</td></tr>
<tr><td><code id="block2seqblock_+3A_seed">seed</code></td>
<td>
<p>an optional integer value for the random seed set which is used when assigning units to treatment groups</p>
</td></tr> 
<tr><td><code id="block2seqblock_+3A_file.name">file.name</code></td>
<td>
<p>a string containing the name of the file that one would like the output to be written to. Ideally this file name should have the extension .RData</p>
</td></tr>
<tr><td><code id="block2seqblock_+3A_verbose">verbose</code></td>
<td>
<p>a logical stating whether the function should print the name of the output file, the current working directory, and the dataframe <code>x</code> returned by the function as part of the <code>bdata</code> list</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function converts data from a blocked experiment into a form allowing subsequent sequential blocking.  Minimally, the user sets only the arguments <code>block.obj</code>, <code>assg.obj</code> and <code>data</code>.  Then, <code>block2seqblock</code> uses the call to <code>block</code>, the assignment object, and the original data to create an object that is ready to be input into <code>seqblock</code>.
</p>
<p>If the user explicitly specifies <code>groups</code>, <code>id.vars</code> and <code>block.vars</code> in the initial <code>block</code> function that is used to create the <code>block.obj</code>, <code>block2seqblock</code> will order the variables in the output it produces according to the order specified in the initial <code>block</code> function call. If the user does not explicitly specify the blocking variables in the <code>block</code> function call, <code>block2seqblock</code> will order the variables according to the order in the initial matrix or dataframe that was used to run the original <code>block</code> function.
</p>
<p>As part of the function, variables that are of class <code>factor</code> in the original matrix or dataframe specified in <code>data</code>, will be converted into class <code>character</code>. 
</p>
<p>The <code>trn</code> argument uses the <code>n.tr</code> argument from <code>block</code> to extract the names of the treatment variables. Most other arguments are set to default values that mirror those in the <code>seqblock</code> function.  One exception is the <code>datetime</code> argument, which defaults to a vector of <code>NA</code>'s instead of the current datetime.</p>


<h3>Value</h3>

<p>A list (called <code>bdata</code>) with elements
</p>
<table>
<tr><td><code>x</code></td>
<td>
<p>a dataframe containing the names and values for the different ID and blocking variables, as well as each unit's initial treatment assignment.</p>
</td></tr>
<tr><td><code>nid</code></td>
<td>
<p>a string or vector of strings containing the name(s) of the ID variable(s).</p>
</td></tr>
<tr><td><code>nex</code></td>
<td>
<p>a string or vector of strings containing the name(s) of the exact blocking variable(s).</p>
</td></tr>
<tr><td><code>ncv</code></td>
<td>
<p>a string or vector of strings containing the name(s) of the non-exact blocking variable(s).</p>
</td></tr>
<tr><td><code>rex</code></td>
<td>
<p>a list of the restricted values of the exact blocking variables.</p>
</td></tr>
<tr><td><code>rcv</code></td>
<td>
<p>a list of the restricted values of the non-exact blocking variables.</p>
</td></tr>
<tr><td><code>ocv</code></td>
<td>
<p>a vector of the order of the non-exact blocking variables.</p>
</td></tr>
<tr><td><code>trn</code></td>
<td>
<p>a string or vector of strings containing the name(s) of the different treatment groups.</p>
</td></tr>
<tr><td><code>apstat</code></td>
<td>
<p>a string specifying the assignment probability summary statistic that was used.</p>
</td></tr>
<tr><td><code>mtrim</code></td>
<td>
<p>a numeric value specifying the proportion of observations to be dropped when the assignment probability statistic takes on the value <code>"trimmean"</code>.</p>
</td></tr>
<tr><td><code>apmeth</code></td>
<td>
<p>a string specifying the assignment probability algorithm that was used.</p>
</td></tr>
<tr><td><code>kfac</code></td>
<td>
<p>the assignment probability <em>kfactor</em>; see <em>assg.prob.kfac</em> in the Arguments section above.</p>
</td></tr>
<tr><td><code>assgpr</code></td>
<td>
<p>a vector of assignment probabilities to each treatment group.</p>
</td></tr>
<tr><td><code>distance</code></td>
<td>
<p>a string specifying how the multivarite distance used for blocking is calculated</p>
</td></tr>
<tr><td><code>trd</code></td>
<td>
<p>a list with the length equal to the number of previously assigned treatment conditions; each object in the list contains a vector of the distance between each unit in one treatment group and the new unit.  Set to <code>NULL</code> when there are no non-exact blocking variables.</p>
</td></tr>
<tr><td><code>tr.sort</code></td>
<td>
<p>a string vector of treatment conditions, sorted from the largest to the smallest</p>
</td></tr>
<tr><td><code>p</code></td>
<td>
<p>a vector of assignment probabilities to each treatment group used in assigning a treatment condition to the new unit.</p>
</td></tr>
<tr><td><code>trcount</code></td>
<td>
<p>a table containing the counts for each experimental/treatment conditions.</p>
</td></tr>
<tr><td><code>datetime</code></td>
<td>
<p>the date and time that the user was assigned a treatment group.</p>
</td></tr>
<tr><td><code>orig</code></td>
<td>
<p>a dataframe containing the names and values for the different id and blocking variables, as well as each unit's initial treatment assignment.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Tommy Carroll <a href="mailto:tcarroll22@wustl.edu">tcarroll22@wustl.edu</a>, Jonathan Homola <a href="mailto:homola@wustl.edu">homola@wustl.edu</a>, and Ryan T. Moore <a href="mailto:rtm@wustl.edu">rtm@wustl.edu</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+block">block</a></code>, <code><a href="#topic+assignment">assignment</a></code>, <code><a href="#topic+seqblock">seqblock</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'># data(x100)
# out &lt;- block(x100, n.tr = 2, id.vars = c("id"), block.vars = c("b1", "b2"), 
#   algorithm = "optGreedy", distance = "mahalanobis", valid.var = "b1", valid.range = c(0,500))
# assg.out &lt;- assignment(out, seed = 123)
# b2sb &lt;- block2seqblock(block.obj = out, assg.obj = assg.out, data = x100)
# sb &lt;- seqblock("sbout.RData", id.vals = 1101, covar.vals = c(100, 200), file.name = "sb101.RData")
</code></pre>

<hr>
<h2 id='createBlockIDs'>Create vector of integers containing block identifiers</h2><span id='topic+createBlockIDs'></span>

<h3>Description</h3>

<p>Creates a vector of integers which represent unique blocks in an
object output from <code>block</code> or <code>assignment</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>createBlockIDs(obj, data, id.var)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="createBlockIDs_+3A_obj">obj</code></td>
<td>
<p>an output object from <code>block</code> or <code>assignment</code>.</p>
</td></tr>
<tr><td><code id="createBlockIDs_+3A_data">data</code></td>
<td>
<p>the data frame that was input into <code>block</code> for blocking.</p>
</td></tr>
<tr><td><code id="createBlockIDs_+3A_id.var">id.var</code></td>
<td>
<p>a string specifying which column of <code>data</code> contains identifying information.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Under the current implementation, <code>level.two</code> in <code>block</code>
should be set to <code>FALSE</code>.
</p>
<p>If blocking was performed specifying a <code>groups</code> argument,
<code>createBlockIDs</code> will assign block ID values that are unique
across groups.  In other words, <code>createBlockIDs</code> does not restart
numbering when it encounters a new group of blocks.
</p>


<h3>Value</h3>

 
<p>A numeric vector of integers with <code>nrow(data)</code> elements with
lowest value equal to 1, corresponding to the block each unit is in.
For units in <code>data</code> that are not in <code>obj</code>, the value of NA
is assigned.
</p>


<h3>Author(s)</h3>

<p>Ryan T. Moore</p>


<h3>See Also</h3>

<p><code><a href="#topic+block">block</a></code>, <code><a href="#topic+assignment">assignment</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(x100)
out &lt;- block(x100, groups = "g", n.tr = 2, id.vars = c("id"), block.vars
             = c("b1", "b2"))
createBlockIDs(out, x100, id.var = "id")
## block ID integers are unique, even with several groups
</code></pre>

<hr>
<h2 id='diagnose'>Diagnose whether units assigned to different treatment
conditions may be subject to interference or pairwise imbalance</h2><span id='topic+diagnose'></span>

<h3>Description</h3>

<p>List all pairs of units assigned to different treatment
conditions whose difference on a specified variable falls within a
specified range.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>diagnose(object, data, id.vars, suspect.var, suspect.range = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="diagnose_+3A_object">object</code></td>
<td>
<p>a dataframe or list of dataframes of assigned units,
such as output from <code>assignment</code>.</p>
</td></tr>
<tr><td><code id="diagnose_+3A_data">data</code></td>
<td>
<p>a dataframe with auxiliary information on assigned units,
including the specified variable <code>suspect.var</code>.</p>
</td></tr>
<tr><td><code id="diagnose_+3A_id.vars">id.vars</code></td>
<td>
<p>a required string or vector of two strings specifying which
column(s) of <code>data</code> contain identifying information.</p>
</td></tr>
<tr><td><code id="diagnose_+3A_suspect.var">suspect.var</code></td>
<td>
<p>a string specifying which column of <code>data</code>
contains the variable suspected of interference or imbalance.</p>
</td></tr>
<tr><td><code id="diagnose_+3A_suspect.range">suspect.range</code></td>
<td>
<p>a vector defining the range of
<code>suspect.var</code> within which units in different treatment
conditions must fall to be considered suspect.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>object</code> requires rows to correspond to blocks and columns to
correspond to treatment conditions, such as output from <code>assignment</code>.
</p>
<p><code>data</code> should include identifying variables and variable suspected
of interference or imbalance.  Typically, <code>data</code> may be the same
dataframe input into <code>block</code>.
</p>
<p>An example of specified identifying variables is <code>id.vars = c("id",
  "id2")</code>.  Unlike <code>block</code>, <code>diagnose</code> requires that the length of
<code>id.vars</code> correspond to the level of the original blocking.  See
<code>block</code> documentation for details.
</p>
<p>An example of specified suspect range is <code>suspect.var = "b2"</code>,
<code>suspect.range = c(0,50)</code> identifies all units assigned to
different treatment conditions no more than 50 units apart on variable
<code>"b2"</code>. 
</p>


<h3>Value</h3>

<p>A list of dataframes, each containing a group's pairs of units assigned
to different treatments falling within <code>suspect.range</code> on the
variable <code>suspect.var</code>.  The last column of each dataframe displays
the observed difference between the two units. 
</p>


<h3>Author(s)</h3>

<p>Ryan T. Moore</p>


<h3>See Also</h3>

<p><code><a href="#topic+assignment">assignment</a></code>, <code><a href="#topic+block">block</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(x100)

## First, block
out &lt;- block(x100, groups = "g", n.tr = 2, id.vars = c("id"), block.vars
             = c("b1", "b2"), algorithm="optGreedy", distance =
             "mahalanobis", level.two = FALSE, valid.var = "b1",
             valid.range = c(0,500), verbose = TRUE)
## Second, assign
assg &lt;- assignment(out, seed = 123)
## Third, diagnose
diag &lt;- diagnose(object = assg, data = x100, id.vars = "id",
                suspect.var = "b2", suspect.range = c(0,50))
</code></pre>

<hr>
<h2 id='extract_conditions'>Create vector of integers containing treatment condition identifiers</h2><span id='topic+extract_conditions'></span>

<h3>Description</h3>

<p>Creates a vector of integers which represent unique treatment conditions 
in an object output from <code>assignment</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract_conditions(assg.obj, data, id.var)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extract_conditions_+3A_assg.obj">assg.obj</code></td>
<td>
<p>an output object from <code>assignment</code>.</p>
</td></tr>
<tr><td><code id="extract_conditions_+3A_data">data</code></td>
<td>
<p>the data frame that was input into <code>block</code> for blocking.</p>
</td></tr>
<tr><td><code id="extract_conditions_+3A_id.var">id.var</code></td>
<td>
<p>a string specifying which column of <code>data</code> contains identifying information.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Under the current implementation, <code>level.two</code> in <code>block</code>
should be set to <code>FALSE</code>.
</p>


<h3>Value</h3>

 
<p>A numeric vector of integers with <code>nrow(data)</code> elements with
lowest value equal to 1, corresponding to the treatment condition column 
from the assignment object each unit is in. For example, if the columns of the assignment object are <code>Treatment</code> and <code>Control</code> (in that order), then <code>Treatment</code> will be represented by a <code>1</code> and <code>Control</code> will be represented by a <code>2</code>. 
</p>
<p>For units in <code>data</code> that are not in <code>assg.obj</code>, the value of NA
is assigned.
</p>


<h3>Author(s)</h3>

<p>Ryan T. Moore</p>


<h3>See Also</h3>

<p><code><a href="#topic+assignment">assignment</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(x100)
out &lt;- block(x100, groups = "g", n.tr = 2, id.vars = c("id"), 
             block.vars = c("b1", "b2"))

assg &lt;- assignment(out)

extract_conditions(assg, x100, id.var = "id")

# Treatment conditions represented by integers.
</code></pre>

<hr>
<h2 id='invertRIconfInt'>Calculate treatment effect confidence intervals by inverting the randomization test</h2><span id='topic+invertRIconfInt'></span>

<h3>Description</h3>

<p>Using an output object from <code>seqblock</code> or any other matrix or dataframe that includes a treatment and an outcome variable for multiple units, as well as blocking and non-blocking variables for the respective unit(s), <code>invertRIconfInt</code> calculates treatment effect confidence intervals by inverting the randomization inference test.</p>


<h3>Usage</h3>

<pre><code class='language-R'>invertRIconfInt(dat, outcome.var, tr.var, tau.abs.min = -1, tau.abs.max = 1, 
  tau.length = 10, n.sb.p = 100, id.vars, id.vals, exact.vars = NULL, exact.vals = NULL,
  exact.restr = NULL, exact.alg = "single", covar.vars = NULL, covar.vals = NULL, 
  covar.restr = NULL, covars.ord = NULL, n.tr = 2, tr.names = NULL, assg.prob = NULL,
  seed = NULL, seed.dist, assg.prob.stat = NULL, trim = NULL, assg.prob.method = NULL, 
  assg.prob.kfac = NULL, distance = "mahalanobis", file.name = "sbout.RData", 
  query = FALSE, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="invertRIconfInt_+3A_dat">dat</code></td>
<td>
<p>a matrix or dataframe containing the names and values of the different blocking and non-blocking variables, as well as each unit's treatment assignment and outcome</p>
</td></tr>
<tr><td><code id="invertRIconfInt_+3A_outcome.var">outcome.var</code></td>
<td>
<p>a string specifying the name of the outcome variable</p>
</td></tr>
<tr><td><code id="invertRIconfInt_+3A_tr.var">tr.var</code></td>
<td>
<p>a string specifying the name of the treatment variable</p>
</td></tr>
<tr><td><code id="invertRIconfInt_+3A_tau.abs.min">tau.abs.min</code></td>
<td>
<p>lower bound of the range across which the confidence intervals will be computed</p>
</td></tr>
<tr><td><code id="invertRIconfInt_+3A_tau.abs.max">tau.abs.max</code></td>
<td>
<p>upper bound of the range across which the confidence intervals will be computed</p>
</td></tr>
<tr><td><code id="invertRIconfInt_+3A_tau.length">tau.length</code></td>
<td>
<p>the number of (evenly spaced) possible treatment effects across the range specified by <code>tau.abs.min</code> and <code>tau.abs.max</code> for which location inside or outside the confidence intervals will be computed</p>
</td></tr>
<tr><td><code id="invertRIconfInt_+3A_n.sb.p">n.sb.p</code></td>
<td>
<p>the number of times that sequential blocking will be performed on the dataset</p>
</td></tr>
<tr><td><code id="invertRIconfInt_+3A_id.vars">id.vars</code></td>
<td>
<p>see the <code>seqblock</code> documentation</p>
</td></tr>
<tr><td><code id="invertRIconfInt_+3A_id.vals">id.vals</code></td>
<td>
<p>see the <code>seqblock</code> documentation</p>
</td></tr>
<tr><td><code id="invertRIconfInt_+3A_exact.vars">exact.vars</code></td>
<td>
<p>see the <code>seqblock</code> documentation</p>
</td></tr>
<tr><td><code id="invertRIconfInt_+3A_exact.vals">exact.vals</code></td>
<td>
<p>see the <code>seqblock</code> documentation</p>
</td></tr>
<tr><td><code id="invertRIconfInt_+3A_exact.restr">exact.restr</code></td>
<td>
<p>see the <code>seqblock</code> documentation</p>
</td></tr>
<tr><td><code id="invertRIconfInt_+3A_exact.alg">exact.alg</code></td>
<td>
<p>see the <code>seqblock</code> documentation</p>
</td></tr>
<tr><td><code id="invertRIconfInt_+3A_covar.vars">covar.vars</code></td>
<td>
<p>see the <code>seqblock</code> documentation</p>
</td></tr>
<tr><td><code id="invertRIconfInt_+3A_covar.vals">covar.vals</code></td>
<td>
<p>see the <code>seqblock</code> documentation</p>
</td></tr>
<tr><td><code id="invertRIconfInt_+3A_covar.restr">covar.restr</code></td>
<td>
<p>see the <code>seqblock</code> documentation</p>
</td></tr>
<tr><td><code id="invertRIconfInt_+3A_covars.ord">covars.ord</code></td>
<td>
<p>see the <code>seqblock</code> documentation</p>
</td></tr>
<tr><td><code id="invertRIconfInt_+3A_n.tr">n.tr</code></td>
<td>
<p>see the <code>seqblock</code> documentation</p>
</td></tr>
<tr><td><code id="invertRIconfInt_+3A_tr.names">tr.names</code></td>
<td>
<p>see the <code>seqblock</code> documentation</p>
</td></tr>
<tr><td><code id="invertRIconfInt_+3A_assg.prob">assg.prob</code></td>
<td>
<p>see the <code>seqblock</code> documentation</p>
</td></tr>
<tr><td><code id="invertRIconfInt_+3A_seed">seed</code></td>
<td>
<p>see the <code>seqblock</code> documentation</p>
</td></tr>
<tr><td><code id="invertRIconfInt_+3A_seed.dist">seed.dist</code></td>
<td>
<p>see the <code>seqblock</code> documentation</p>
</td></tr>
<tr><td><code id="invertRIconfInt_+3A_assg.prob.stat">assg.prob.stat</code></td>
<td>
<p>see the <code>seqblock</code> documentation</p>
</td></tr>
<tr><td><code id="invertRIconfInt_+3A_trim">trim</code></td>
<td>
<p>see the <code>seqblock</code> documentation</p>
</td></tr>
<tr><td><code id="invertRIconfInt_+3A_assg.prob.method">assg.prob.method</code></td>
<td>
<p>see the <code>seqblock</code> documentation</p>
</td></tr>
<tr><td><code id="invertRIconfInt_+3A_assg.prob.kfac">assg.prob.kfac</code></td>
<td>
<p>see the <code>seqblock</code> documentation</p>
</td></tr>
<tr><td><code id="invertRIconfInt_+3A_distance">distance</code></td>
<td>
<p>see the <code>seqblock</code> documentation</p>
</td></tr>
<tr><td><code id="invertRIconfInt_+3A_file.name">file.name</code></td>
<td>
<p>see the <code>seqblock</code> documentation</p>
</td></tr>
<tr><td><code id="invertRIconfInt_+3A_query">query</code></td>
<td>
<p>see the <code>seqblock</code> documentation</p>
</td></tr>
<tr><td><code id="invertRIconfInt_+3A_verbose">verbose</code></td>
<td>
<p>see the <code>seqblock</code> documentation</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>invertRIconfInt</code> takes a data matrix (or data frame) containing names and values of different blocking and non-blocking variables, as well as each unit's treatment assignment and outcome as input and returns a list of treatment effect confidence intervals.
</p>
<p>Apart from specifying the treatment and outcome variable, the user can set all other arguments to <code>seqblock</code> when running <code>invertRIconfInt</code>. The function will then calculate the confidence intervals by employing a method described in Ho and Imai (2006), which inverts Fisher's exact test. The resulting confidence intervals are distribution-free, nonparametric and have accurate coverage probabilities.
</p>


<h3>Value</h3>

<p>A list with elements
</p>
<table>
<tr><td><code>ci95</code></td>
<td>
<p>vector of treatment effects within the 95% confidence interval</p>
</td></tr>
<tr><td><code>ci90</code></td>
<td>
<p>vector of treatment effects within the 90% confidence interval</p>
</td></tr>
<tr><td><code>ci80</code></td>
<td>
<p>vector of treatment effects within the 80% confidence interval</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Ryan T. Moore <a href="mailto:rtm@wustl.edu">rtm@wustl.edu</a> and Jonathan Homola <a href="mailto:homola@wustl.edu">homola@wustl.edu</a></p>


<h3>References</h3>

<p>Moore, Ryan T. and Sally A. Moore. 2013. &quot;Blocking for Sequential Political Experiments.&quot; <em>Political Analysis</em> 21(4): 507-523. 
</p>
<p>Ho, Daniel E., and Kosuke Imai. 2006. &quot;Randomization inference with natural experiments: An analysis of ballot effects in the 2003 California recall election.&quot; <em>Journal of the American Statistical Association</em> 101(475): 888-900.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+seqblock">seqblock</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Create an example data matrix with 50 observations that contains an ID variable, 
##   a dummy variable indicating gender, an age variable (between 18 and 55), a 
##   treatment variable and an outcome variable (between 15 and 20). 
## id &lt;- seq(1,50,1)
## gender &lt;- sample(c(1,2),50,replace=T)
## age &lt;- sample(seq(18,55,1),50,replace=T)
## treat &lt;- sample(c(1,2),50,replace=T)
## out &lt;- treat + sample(seq(15,20,1),50,replace=T)
## data &lt;- cbind(id, gender, age, out, treat)

## Check summary statistics for the created data
## aggregate(out~treat, data, mean)

## Run invertRIconfInt()
## invertRIconfInt(data, outcome.var="out", tr.var="treat", tau.abs.min = -3, 
##  tau.abs.max = 3, id.vars = "id", id.vals = "id", exact.vars = c("gender", "age"), 
##  exact.vals = c("gender", "age"))
</code></pre>

<hr>
<h2 id='outCSV'>Export blocked or assigned data to .csv format files</h2><span id='topic+outCSV'></span>

<h3>Description</h3>

<p>Exports output from <code>block</code> or <code>assignment</code> to a
set of .csv files using <code>write.csv</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>outCSV(block.obj, namesCol = NULL, file.names = NULL, digits = 2, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="outCSV_+3A_block.obj">block.obj</code></td>
<td>
<p>a list of dataframes, such as output from
<code>block</code> or <code>assignment</code>.</p>
</td></tr>
<tr><td><code id="outCSV_+3A_namescol">namesCol</code></td>
<td>
<p>an optional vector of column names to be used in
output files.</p>
</td></tr>
<tr><td><code id="outCSV_+3A_file.names">file.names</code></td>
<td>
<p>an optional list of strings specifying the output file names.</p>
</td></tr>
<tr><td><code id="outCSV_+3A_digits">digits</code></td>
<td>
<p>number of digits to which to round multivariate
distances in output files.</p>
</td></tr>
<tr><td><code id="outCSV_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code>write.csv</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Under the default (<code>file.names =
NULL</code>), each file is named &ldquo;GroupXXX.csv&rdquo;, where &ldquo;XXX&rdquo;
is the group name taken from the input object. 
</p>


<h3>Value</h3>

<p> A set of .csv files, one for each element of the input list of
blocked or assigned units.</p>


<h3>Author(s)</h3>

<p>Ryan T. Moore</p>


<h3>See Also</h3>

<p><code><a href="#topic+outTeX">outTeX</a></code>, <code><a href="utils.html#topic+write.csv">write.csv</a></code>,
<code><a href="#topic+block">block</a></code>, <code><a href="#topic+assignment">assignment</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(x100)

# First, block
out &lt;- block(x100, groups = "g", n.tr = 2, id.vars = c("id"), block.vars
             = c("b1", "b2"), algorithm="optGreedy", distance =
             "mahalanobis", level.two = FALSE, valid.var = "b1",
             valid.range = c(0,500), verbose = TRUE)
# Second, assign
assg &lt;- assignment(out, seed = 123)

# create three .csv files of blocks
## Not run: outCSV(out)

# create three .csv files of assigned blocks
#   (note: overwrites blocked .csv files)
## Not run: outCSV(assg)

# create three .csv files with custom file names
## Not run: outCSV(assg, file.names = list("file1", "file2", "file3"))
</code></pre>

<hr>
<h2 id='outTeX'>Export blocked or assigned data to .tex format files</h2><span id='topic+outTeX'></span>

<h3>Description</h3>

<p>Exports output from <code>block</code> or <code>assignment</code> to a
set of .tex files using <code>xtable</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>outTeX(block.obj, namesCol = NULL, file.names = NULL, captions = NULL, digits = 2, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="outTeX_+3A_block.obj">block.obj</code></td>
<td>
<p>a list of dataframes, such as output from
<code>block</code> or <code>assignment</code>.</p>
</td></tr>
<tr><td><code id="outTeX_+3A_namescol">namesCol</code></td>
<td>
<p>an optional vector of column names to be used in
output files.</p>
</td></tr>
<tr><td><code id="outTeX_+3A_file.names">file.names</code></td>
<td>
<p>an optional list of strings specifying the output file names.</p>
</td></tr>
<tr><td><code id="outTeX_+3A_captions">captions</code></td>
<td>
<p>an optional list of strings specifying the table captions.  See Details below.</p>
</td></tr>
<tr><td><code id="outTeX_+3A_digits">digits</code></td>
<td>
<p>the number of digits to which to round multivariate
distances in output files.</p>
</td></tr>
<tr><td><code id="outTeX_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code>xtable</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Under the default (<code>file.names =
NULL</code>), each file is named &ldquo;GroupXXX.tex&rdquo;, where &ldquo;XXX&rdquo;
is the group name taken from the input object.  Under the default (<code>captions =
NULL</code>), each caption is &ldquo;Group XXX.&rdquo;, where &ldquo;XXX&rdquo;
is the group name taken from the input object.
</p>
<p><code>outTeX</code> appends <code>.tex</code> to the user-specified <code>file.names</code>.
</p>
<p>The table reference labels are created as <code>t:XXX</code>, where <code>XXX</code> is the file name (without <code>.tex</code>) for the <code>.tex</code> file containing that table.
</p>
<p><code>captions</code> takes a list of strings of length equal to the number of groups in <code>block.obj$blocks</code>, if <code>block.obj</code> is output from <code>block</code>, or the number of groups in <code>block.obj$assg</code>, if <code>block.obj</code> is output from <code>assignment</code>.
</p>
<p>The tables in the output .tex files can easily be integrated into an existing .tex document
using LaTeX code &lsquo;<span class="samp">&#8288;\include{GroupXXX}&#8288;</span>&rsquo;.
</p>


<h3>Value</h3>

<p> A set of .tex files, one for each element of the input list of
blocked or assigned units. </p>


<h3>Author(s)</h3>

<p>Ryan T. Moore</p>


<h3>See Also</h3>

<p><code><a href="#topic+outCSV">outCSV</a></code>, <code><a href="#topic+block">block</a></code>, <code><a href="#topic+assignment">assignment</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(x100)

# First, block
out &lt;- block(x100, groups = "g", n.tr = 2, id.vars = c("id"), block.vars
             = c("b1", "b2"), algorithm="optGreedy", distance =
             "mahalanobis", level.two = FALSE, valid.var = "b1",
             valid.range = c(0,500), verbose = TRUE)
# Second, assign
assg &lt;- assignment(out, seed = 123)

# create three .tex files of blocks
## Not run: outTeX(out)

# create three .tex files of assigned blocks
#   (note: overwrites blocked .tex files)
## Not run: outTeX(assg)

# create three .tex files with custom file names and captions
## Not run: outTeX(assg, file.names = list("file1", "file2", "file3"), 
       captions = list("This is caption 1.", "Caption 2.", "Caption 3?"))
## End(Not run)
</code></pre>

<hr>
<h2 id='seqblock'>Sequential assignment of unit(s) into experimental conditions using covariates</h2><span id='topic+seqblock'></span>

<h3>Description</h3>

<p>Sequentially assign units into experimental conditions. Blocking begins by creating a measure of multivariate distance between a <em>current</em> unit and one or multiple <em>prior</em>, already-assigned unit(s). Then, average distance between current unit and each treatment condition is calculated, and random assignment is biased toward conditions more dissimilar to current unit. Argument values can be specified either as argument to the function, or via a query. The query directly asks the user to identify the blocking variables and to input, one-by-one, each unit's variable values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seqblock(object = NULL, id.vars, id.vals, exact.vars = NULL, exact.vals = NULL, 
  exact.restr = NULL, exact.alg = "single", covar.vars = NULL, covar.vals = NULL, 
  covar.restr = NULL, covars.ord = NULL, n.tr = 2, tr.names = NULL, assg.prob = NULL,
  seed = NULL, seed.dist, assg.prob.stat = NULL, trim = NULL, assg.prob.method = NULL,
  assg.prob.kfac = NULL, distance = NULL, file.name = NULL, query = FALSE, 
  verbose = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seqblock_+3A_object">object</code></td>
<td>
<p>a character string giving the file name of a <code>.RData</code> file containing a list output from the <code>seqblock</code> function which contains at least one previously assigned unit.</p>
</td></tr>
<tr><td><code id="seqblock_+3A_id.vars">id.vars</code></td>
<td>
<p>a string or vector of strings specifying the name of the identifying variable(s); if <code>query = FALSE</code> and the object argument is not given, then the <code>id.vars</code> argument is required.</p>
</td></tr>
<tr><td><code id="seqblock_+3A_id.vals">id.vals</code></td>
<td>
<p>a vector of ID values for every unit being assigned to a treatment group; those are corresponding to the <code>id.vars</code>.</p>
</td></tr>
<tr><td><code id="seqblock_+3A_exact.vars">exact.vars</code></td>
<td>
<p>a string or vector of strings containing the names of each of the exact blocking variables.</p>
</td></tr>
<tr><td><code id="seqblock_+3A_exact.vals">exact.vals</code></td>
<td>
<p>a vector containing the unit's values on each of the exact blocking variables.</p>
</td></tr>
<tr><td><code id="seqblock_+3A_exact.restr">exact.restr</code></td>
<td>
<p>a list object containing the restricted values that the exact blocking variables can take on. Thus the first element of <code>exact.restr</code> is a vector containing all of the possible values that the first exact blocking variable (see <code>exact.vars</code> above) can take on; the second element is a vector containing all of the possible values for the second exact blocking variable; and so on.</p>
</td></tr>
<tr><td><code id="seqblock_+3A_exact.alg">exact.alg</code></td>
<td>
<p>a string specifying the blocking algorithm. Currently the only acceptable value is <code>"single"</code>. This algorithm creates a variable with a unique level for every possible combination of the values in all of the exact variables. See Details section below.</p>
</td></tr>
<tr><td><code id="seqblock_+3A_covar.vars">covar.vars</code></td>
<td>
<p>a string or vector of strings containing the names of each of the non-exact blocking variables.</p>
</td></tr>
<tr><td><code id="seqblock_+3A_covar.vals">covar.vals</code></td>
<td>
<p>a vector containing the unit's values on each of the non-exact blocking variables.</p>
</td></tr>
<tr><td><code id="seqblock_+3A_covar.restr">covar.restr</code></td>
<td>
<p>a list object containing the restricted values that the non-exact blocking variables can take on. Thus the first element of <code>covar.restr</code> is a vector containing all of the possible values that the first non-exact blocking variable (see <code>covar.vars</code> above) can take on; the second element is a vector containing all of the possible values for the second non-exact blocking variable; and so on.</p>
</td></tr>
<tr><td><code id="seqblock_+3A_covars.ord">covars.ord</code></td>
<td>
<p>a string or vector of strings containing the name of the non-exact blocking variables ordered so that the highest priority covariate comes first, followed by the second highest priority covariate, then the third, etc.</p>
</td></tr>
<tr><td><code id="seqblock_+3A_n.tr">n.tr</code></td>
<td>
<p>the number of treatment groups. If not specified, this defaults to <code>n.tr = 2</code>.</p>
</td></tr>
<tr><td><code id="seqblock_+3A_tr.names">tr.names</code></td>
<td>
<p>a string or vector of strings containing the names of the different treatment groups.</p>
</td></tr>
<tr><td><code id="seqblock_+3A_assg.prob">assg.prob</code></td>
<td>
<p>a numeric vector containing the probabilities that a unit will be assigned to the treatment groups; this vector should sum to 1.</p>
</td></tr>
<tr><td><code id="seqblock_+3A_seed">seed</code></td>
<td>
<p>an optional integer value for the random seed, which is used when assigning units to treatment groups.</p>
</td></tr>
<tr><td><code id="seqblock_+3A_seed.dist">seed.dist</code></td>
<td>
<p>an optional integer value for the random seed set in <code>cov.rob</code>, used to calculate measures of the variance-covariance matrix robust to outliers.</p>
</td></tr>
<tr><td><code id="seqblock_+3A_assg.prob.stat">assg.prob.stat</code></td>
<td>
<p>a string specifying which assignment probability summary statistic to use; valid values are <code>mean</code>, <code>median</code>, and <code>trimmean</code>. If not specified, this defaults to <code>assg.prob.stat = "mean"</code>.</p>
</td></tr>
<tr><td><code id="seqblock_+3A_trim">trim</code></td>
<td>
<p>a numeric value specifying what proportion of the observations are to be dropped from each tail when the assignment probability summary statistic (<code>assg.prob.stat</code>) is set equal to <code>trimmean</code>. Blocks on each tail of the distribution are dropped before the mean is calculated. If not specified, this defaults to <code>trim = 0.1</code>.</p>
</td></tr>
<tr><td><code id="seqblock_+3A_assg.prob.method">assg.prob.method</code></td>
<td>
<p>a string specifying which algorithm should be used when assigning treatment probabilities. Acceptable values are <code>ktimes</code>, <code>fixed</code>, <code>prop</code>, <code>prop2</code>, and <code>wprop</code>. If not specified, this defaults to <code>assg.prob.method = "ktimes"</code>.</p>
</td></tr>
<tr><td><code id="seqblock_+3A_assg.prob.kfac">assg.prob.kfac</code></td>
<td>
<p>a numeric value for <code>k</code>, the factor by which the most likely experimental condition will be multiplied relative to the other conditions. If not specified, this defaults to <code>assg.prob.kfac = 2</code>.</p>
</td></tr>
<tr><td><code id="seqblock_+3A_distance">distance</code></td>
<td>
<p>a string specifying how the multivariate distance used for blocking covariates are calculated. If not specified, this defaults to <code>distance = "mahalanobis"</code>.</p>
</td></tr>
<tr><td><code id="seqblock_+3A_file.name">file.name</code></td>
<td>
<p>a string containing the name of the file that one would like the output to be written to. Ideally this file name should have the extension .RData.</p>
</td></tr>
<tr><td><code id="seqblock_+3A_query">query</code></td>
<td>
<p>a logical stating whether the console should ask the user questions to input the data and assign a treatment condition. If not specified, this defaults to <code>query = FALSE</code>.</p>
</td></tr>
<tr><td><code id="seqblock_+3A_verbose">verbose</code></td>
<td>
<p>a logical stating whether the function should print the name of the output file, the current working directory, the treatment group that the most recent unit was assigned to, and the dataframe <code>x</code> returned by the function as part of the <code>bdata</code> list. If not specified, this defaults to <code>verbose = TRUE</code>.</p>
</td></tr>
<tr><td><code id="seqblock_+3A_...">...</code></td>
<td>
<p>additional arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>seqblock</code> function's code is primarily divided into two parts: the first half deals with instances, in which the unit being assigned is the first unit in a given study to receive an assignment; the second half addresses subsequent units that are assigned after at least one first assignment has already been made. If the <code>object</code> argument is left as <code>NULL</code>, the function will run the first half; if the <code>object</code> argument is specified, the second part will be executed. When <code>object = NULL</code>, the researcher has no past file from which to pull variable names and past data; this corresponds to the case when the unit being assigned is the first one. If the researcher does specify <code>object</code>, it implies the user is drawing data from a past file, which means this is not the first unit in the study to be assigned to a treatment.
</p>
<p>However, the function can be called for subsequent units even when <code>object</code> is not specified. By setting <code>query = TRUE</code>, the console will ask the researcher whether this is the first unit to be assigned in the study. Based on the researcher's response, it will decide which part of the code to run.
</p>
<p>If the <code>object</code> and <code>file.name</code> arguments are set to the same value, then <code>seqblock</code> overwrites the specified file with a new file, which now contains both the previously-assigned units and the newly-assigned unit. To create a new file when a new unit is assigned, use a new <code>file.name</code>. 
</p>
<p>The <code>single</code> algorithm (see <code>exact.alg</code> in the Arguments section above) creates a variable that has a unique level for every possible combination of the exact variables. As an example, say that there were 3 exact blocking variables: <em>party</em> (Democrat, Republican); <em>region</em> (North, South); and <em>education</em> (HS, NHS). The <code>single</code> algorithm creates one level for units with the following values: Democrat-North-HS. It would create another level for Democrat-North-NHS; a third level for Republican-North-HS; and so forth, until every possible combination of these 3 variables has its own level. Thus if there are <code class="reqn">k</code> exact blocking variables and each exact blocking variable has <code class="reqn">q_{i}</code> values it can take on, then there are a total of <code class="reqn">\prod_{1}^{k} q_{i}</code> levels created.
</p>
<p>The <code>distance = "mcd"</code> and <code>distance = "mve"</code> options call <code>cov.rob</code> to calculate measures of multivariate spread robust to outliers. The <code>distance = "mcd"</code> option calculates the Minimum Covariance Determinant estimate (Rousseeuw 1985); the <code>distance = "mve"</code> option calculates the Minimum Volume Ellipsoid estimate (Rousseeuw and van Zomeren 1990). When <code>distance = "mcd"</code>, the interquartile range on blocking variables should not be zero. The <code>distance = "euclidean"</code> option calculates the Euclidean distance between the new unit and the previously-assigned units. The default <code>distance = "mahalanobis"</code> option calculates the Mahalanobis distance.
</p>


<h3>Value</h3>

<p> A list (called <code>bdata</code>) with elements
</p>
<table>
<tr><td><code>x</code></td>
<td>
<p>a dataframe containing the names and values for the different ID and blocking variables, as well as each unit's initial treatment assignment.</p>
</td></tr>
<tr><td><code>nid</code></td>
<td>
<p>a string or vector of strings containing the name(s) of the ID variable(s).</p>
</td></tr>
<tr><td><code>nex</code></td>
<td>
<p>a string or vector of strings containing the name(s) of the exact blocking variable(s).</p>
</td></tr>
<tr><td><code>ncv</code></td>
<td>
<p>a string or vector of strings containing the name(s) of the non-exact blocking variable(s).</p>
</td></tr>
<tr><td><code>rex</code></td>
<td>
<p>a list of the restricted values of the exact blocking variables.</p>
</td></tr>
<tr><td><code>rcv</code></td>
<td>
<p>a list of the restricted values of the non-exact blocking variables.</p>
</td></tr>
<tr><td><code>ocv</code></td>
<td>
<p>a vector of the order of the non-exact blocking variables.</p>
</td></tr>
<tr><td><code>trn</code></td>
<td>
<p>a string or vector of strings containing the name(s) of the different treatment groups.</p>
</td></tr>
<tr><td><code>apstat</code></td>
<td>
<p>a string specifying the assignment probability summary statistic that was used.</p>
</td></tr>
<tr><td><code>mtrim</code></td>
<td>
<p>a numeric value specifying the proportion of observations to be dropped when the assignment probability statistic takes on the value <code>"trimmean"</code>.</p>
</td></tr>
<tr><td><code>apmeth</code></td>
<td>
<p>a string specifying the assignment probability algorithm that was used.</p>
</td></tr>
<tr><td><code>kfac</code></td>
<td>
<p>the assignment probability <em>kfactor</em>; see <em>assg.prob.kfac</em> in the Arguments section above.</p>
</td></tr>
<tr><td><code>assgpr</code></td>
<td>
<p>a vector of assignment probabilities to each treatment group.</p>
</td></tr>
<tr><td><code>distance</code></td>
<td>
<p>a string specifying how the multivarite distance used for blocking was calculated. </p>
</td></tr>
<tr><td><code>trd</code></td>
<td>
<p>a list with the length equal to the number of previously assigned treatment conditions; each object in the list contains a vector of the distance between each unit in one treatment group and the new unit. This will be <code>NULL</code> when there are no non-exact blocking variables.</p>
</td></tr>
<tr><td><code>tr.sort</code></td>
<td>
<p>a string vector of treatment conditions, sorted from the largest to the smallest. Set to <code>NULL</code> when there are no non-exact blocking variables.</p>
</td></tr>
<tr><td><code>p</code></td>
<td>
<p>a vector of assignment probabilities to each treatment group used in assigning a treatment condition to the new unit.</p>
</td></tr>
<tr><td><code>distance</code></td>
<td>
<p>a string specifying how the multivarite distance used for blocking is calculated</p>
</td></tr>
<tr><td><code>trcount</code></td>
<td>
<p>a table containing the counts for each experimental/treatment conditions.</p>
</td></tr>
<tr><td><code>datetime</code></td>
<td>
<p>the date and time at which each unit was assigned their treatment group.</p>
</td></tr>
<tr><td><code>orig</code></td>
<td>
<p>a dataframe containing the names and values for the different id and blocking variables, as well as each unit's treatment assignment.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Ryan T. Moore <a href="mailto:rtm@wustl.edu">rtm@wustl.edu</a>, Tommy Carroll <a href="mailto:tcarroll22@wustl.edu">tcarroll22@wustl.edu</a>, Jonathan Homola <a href="mailto:homola@wustl.edu">homola@wustl.edu</a> and Jeong Hyun Kim <a href="mailto:jeonghyun.kim@wustl.edu">jeonghyun.kim@wustl.edu</a></p>


<h3>References</h3>

<p>Moore, Ryan T. and Sally A. Moore. 2013. &quot;Blocking for Sequential Political Experiments.&quot; <em>Political Analysis</em> 21(4):507-523. 
</p>
<p>Moore, Ryan T. 2012. &quot;Multivariate Continuous Blocking to Improve Political Science
Experiments.&quot; <em>Political Analysis</em> 20(4):460-479.
</p>
<p>Rousseeuw, Peter J. 1985. &quot;Multivariate Estimation with High Breakdown Point&quot;. <em>Mathematical Statistics and Applications</em> 8:283-297.
</p>
<p>Rousseeuw, Peter J. and Bert C. van Zomeren. 1990. &quot;Unmasking Multivariate Outliers and Leverage Points&quot;. <em>Journal of the American Statistical Association</em> 85(411):633-639.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+assignment">assignment</a></code>, <code><a href="#topic+block">block</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Assign first unit (assume a 25 year old member of the Republican Party) to a treatment group.
## Save the results in file "sdata.RData":
## seqblock(query = FALSE, id.vars = "ID", id.vals = 001, exact.vars = "party", 
##   exact.vals = "Republican", covar.vars = "age", covar.vals = 25, file.name = "sdata.RData")

## Assign next unit (age 30, Democratic Party):
## seqblock(query = FALSE, object = "sdata.RData", id.vals = 002, exact.vals = "Democrat", 
##   covar.vars = "age", covar.vals = 30, file.name = "sdata.RData")
</code></pre>

<hr>
<h2 id='x100'>Simulated data for demonstrating blockTools functionality</h2><span id='topic+x100'></span>

<h3>Description</h3>

<p>Simulated data for demonstrating <code>blockTools</code> functionality.</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(x100)</code></pre>


<h3>Format</h3>

<p>A dataframe with 100 rows and 6 columns.  Columns <code>id</code> and
<code>id2</code> are unit and subunit identifying variables, <code>b1</code> and
<code>b2</code> are blocking variables, <code>g</code> identifies which of three
groups each unit is in (&ldquo;a&quot;, &ldquo;b&quot;, or &ldquo;c&quot;), and <code>ig</code> is an 
ignored
variable. 
</p>


<h3>Author(s)</h3>

<p>Ryan T. Moore</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(x100)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
