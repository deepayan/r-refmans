<!DOCTYPE html><html><head><title>Help for package spOccupancy</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {spOccupancy}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#spOccupancy-package'><p>Single-Species, Multi-Species, and Integrated Spatial Occupancy Models</p></a></li>
<li><a href='#fitted.intPGOcc'><p>Extract Model Fitted Values for intPGOcc Object</p></a></li>
<li><a href='#fitted.lfJSDM'><p>Extract Model Fitted Values for lfJSDM Object</p></a></li>
<li><a href='#fitted.lfMsPGOcc'><p>Extract Model Fitted Values for lfMsPGOcc Object</p></a></li>
<li><a href='#fitted.msPGOcc'><p>Extract Model Fitted Values for msPGOcc Object</p></a></li>
<li><a href='#fitted.PGOcc'><p>Extract Model Fitted Values for PGOcc Object</p></a></li>
<li><a href='#fitted.sfJSDM'><p>Extract Model Fitted Values for sfJSDM Object</p></a></li>
<li><a href='#fitted.sfMsPGOcc'><p>Extract Model Fitted Values for sfMsPGOcc Object</p></a></li>
<li><a href='#fitted.spIntPGOcc'><p>Extract Model Fitted Values for spIntPGOcc Object</p></a></li>
<li><a href='#fitted.spMsPGOcc'><p>Extract Model Fitted Values for spMsPGOcc Object</p></a></li>
<li><a href='#fitted.spPGOcc'><p>Extract Model Fitted Values for spPGOcc Object</p></a></li>
<li><a href='#fitted.stMsPGOcc'><p>Extract Model Fitted Values for stMsPGOcc Object</p></a></li>
<li><a href='#fitted.stPGOcc'><p>Extract Model Fitted Values for stPGOcc Object</p></a></li>
<li><a href='#fitted.svcMsPGOcc'><p>Extract Model Fitted Values for svcMsPGOcc Object</p></a></li>
<li><a href='#fitted.svcPGBinom'><p>Extract Model Fitted Values for svcPGBinom Object</p></a></li>
<li><a href='#fitted.svcPGOcc'><p>Extract Model Fitted Values for svcPGOcc Object</p></a></li>
<li><a href='#fitted.svcTMsPGOcc'><p>Extract Model Fitted Values for svcTMsPGOcc Object</p></a></li>
<li><a href='#fitted.svcTPGBinom'><p>Extract Model Fitted Values for svcTPGBinom Object</p></a></li>
<li><a href='#fitted.svcTPGOcc'><p>Extract Model Fitted Values for svcTPGOcc Object</p></a></li>
<li><a href='#fitted.tMsPGOcc'><p>Extract Model Fitted Values for tMsPGOcc Object</p></a></li>
<li><a href='#fitted.tPGOcc'><p>Extract Model Fitted Values for tPGOcc Object</p></a></li>
<li><a href='#getSVCSamples'><p>Extract spatially-varying coefficient MCMC samples</p></a></li>
<li><a href='#hbef2015'><p>Detection-nondetection data of 12 foliage gleaning bird species</p>
in 2015 in the Hubbard Brook Experimental Forest</a></li>
<li><a href='#hbefElev'><p>Elevation in meters extracted at a 30m resolution across the Hubbard Brook Experimental Forest</p></a></li>
<li><a href='#hbefTrends'><p>Detection-nondetection data of 12 foliage gleaning bird species</p>
from 2010-2018 in the Hubbard Brook Experimental Forest</a></li>
<li><a href='#intMsPGOcc'><p>Function for Fitting Integrated Multi-Species Occupancy Models Using Polya-Gamma Latent Variables</p></a></li>
<li><a href='#intPGOcc'><p>Function for Fitting Single-Species Integrated Occupancy Models Using Polya-Gamma Latent Variables</p></a></li>
<li><a href='#lfJSDM'><p>Function for Fitting a Latent Factor Joint Species Distribution Model</p></a></li>
<li><a href='#lfMsPGOcc'><p>Function for Fitting Latent Factor Multi-Species Occupancy Models</p></a></li>
<li><a href='#msPGOcc'><p>Function for Fitting Multi-Species Occupancy Models Using Polya-Gamma Latent Variables</p></a></li>
<li><a href='#neon2015'><p>Detection-nondetection data of 12 foliage gleaning bird species</p>
in 2015 in Bartlett Experimental Forest in New Hampshire, USA</a></li>
<li><a href='#PGOcc'><p>Function for Fitting Single-Species Occupancy Models Using Polya-Gamma Latent Variables</p></a></li>
<li><a href='#postHocLM'><p>Function for Fitting Linear Mixed Models with Previous Model Estimates</p></a></li>
<li><a href='#ppcOcc'><p>Function for performing posterior predictive checks</p></a></li>
<li><a href='#predict.intMsPGOcc'><p>Function for prediction at new locations for integrated multi-species occupancy models</p></a></li>
<li><a href='#predict.intPGOcc'><p>Function for prediction at new locations for single-species integrated occupancy models</p></a></li>
<li><a href='#predict.lfJSDM'><p>Function for prediction at new locations for latent factor joint species distribution models</p></a></li>
<li><a href='#predict.lfMsPGOcc'><p>Function for prediction at new locations for latent factor multi-species occupancy models</p></a></li>
<li><a href='#predict.msPGOcc'><p>Function for prediction at new locations for multi-species occupancy models</p></a></li>
<li><a href='#predict.PGOcc'><p>Function for prediction at new locations for single-species occupancy models</p></a></li>
<li><a href='#predict.sfJSDM'><p>Function for prediction at new locations for spatial factor joint species distribution model</p></a></li>
<li><a href='#predict.sfMsPGOcc'><p>Function for prediction at new locations for spatial factor multi-species occupancy models</p></a></li>
<li><a href='#predict.spIntPGOcc'><p>Function for prediction at new locations for single-species integrated spatial occupancy models</p></a></li>
<li><a href='#predict.spMsPGOcc'><p>Function for prediction at new locations for multi-species spatial occupancy models</p></a></li>
<li><a href='#predict.spPGOcc'><p>Function for prediction at new locations for single-species spatial occupancy models</p></a></li>
<li><a href='#predict.stMsPGOcc'><p>Function for prediction at new locations for multi-season multi-species spatial occupancy models</p></a></li>
<li><a href='#predict.stPGOcc'><p>Function for prediction at new locations for multi-season single-species spatial occupancy models</p></a></li>
<li><a href='#predict.svcMsPGOcc'><p>Function for prediction at new locations for spatially varying coefficient multi-species occupancy models</p></a></li>
<li><a href='#predict.svcPGBinom'><p>Function for prediction at new locations for single-species spatially-varying coefficient Binomial models</p></a></li>
<li><a href='#predict.svcPGOcc'><p>Function for prediction at new locations for single-species spatially-varying coefficient occupancy models</p></a></li>
<li><a href='#predict.svcTMsPGOcc'><p>Function for prediction at new locations for multi-season multi-species spatially-varying coefficient occupancy models</p></a></li>
<li><a href='#predict.svcTPGBinom'><p>Function for prediction at new locations for multi-season single-species spatially-varying coefficient binomial models</p></a></li>
<li><a href='#predict.svcTPGOcc'><p>Function for prediction at new locations for multi-season single-species spatially-varying coefficient occupancy models</p></a></li>
<li><a href='#predict.tMsPGOcc'><p>Function for prediction at new locations for multi-season multi-species occupancy models</p></a></li>
<li><a href='#predict.tPGOcc'><p>Function for prediction at new locations for multi-season single-species occupancy models</p></a></li>
<li><a href='#sfJSDM'><p>Function for Fitting a Spatial Factor Joint Species Distribution Model</p></a></li>
<li><a href='#sfMsPGOcc'><p>Function for Fitting Spatial Factor Multi-Species Occupancy Models</p></a></li>
<li><a href='#simBinom'><p>Simulate Single-Species Binomial Data</p></a></li>
<li><a href='#simIntMsOcc'><p>Simulate Multi-Species Detection-Nondetection Data from Multiple Data Sources</p></a></li>
<li><a href='#simIntOcc'><p>Simulate Single-Species Detection-Nondetection Data from Multiple Data Sources</p></a></li>
<li><a href='#simMsOcc'><p>Simulate Multi-Species Detection-Nondetection Data</p></a></li>
<li><a href='#simOcc'><p>Simulate Single-Species Detection-Nondetection Data</p></a></li>
<li><a href='#simTBinom'><p>Simulate Multi-Season Single-Species Binomial Data</p></a></li>
<li><a href='#simTMsOcc'><p>Simulate Multi-Species Multi-Season Detection-Nondetection Data</p></a></li>
<li><a href='#simTOcc'><p>Simulate Multi-Season Single-Species Detection-Nondetection Data</p></a></li>
<li><a href='#spIntPGOcc'><p>Function for Fitting Single-Species Integrated Spatial Occupancy Models Using Polya-Gamma Latent Variables</p></a></li>
<li><a href='#spMsPGOcc'><p>Function for Fitting Multi-Species Spatial Occupancy Models Using Polya-Gamma Latent Variables</p></a></li>
<li><a href='#spPGOcc'><p>Function for Fitting Single-Species Spatial Occupancy Models Using Polya-Gamma Latent Variables</p></a></li>
<li><a href='#stMsPGOcc'><p>Function for Fitting Multi-Species Multi-Season Spatial Occupancy Models</p></a></li>
<li><a href='#stPGOcc'><p>Function for Fitting Multi-Season Single-Species Spatial Occupancy Models Using Polya-Gamma Latent Variables</p></a></li>
<li><a href='#summary.intMsPGOcc'><p>Methods for intMsPGOcc Object</p></a></li>
<li><a href='#summary.intPGOcc'><p>Methods for intPGOcc Object</p></a></li>
<li><a href='#summary.lfJSDM'><p>Methods for lfJSDM Object</p></a></li>
<li><a href='#summary.lfMsPGOcc'><p>Methods for lfMsPGOcc Object</p></a></li>
<li><a href='#summary.msPGOcc'><p>Methods for msPGOcc Object</p></a></li>
<li><a href='#summary.PGOcc'><p>Methods for PGOcc Object</p></a></li>
<li><a href='#summary.postHocLM'><p>Methods for postHocLM Object</p></a></li>
<li><a href='#summary.ppcOcc'><p>Methods for ppcOcc Object</p></a></li>
<li><a href='#summary.sfJSDM'><p>Methods for sfJSDM Object</p></a></li>
<li><a href='#summary.sfMsPGOcc'><p>Methods for sfMsPGOcc Object</p></a></li>
<li><a href='#summary.spIntPGOcc'><p>Methods for spIntPGOcc Object</p></a></li>
<li><a href='#summary.spMsPGOcc'><p>Methods for spMsPGOcc Object</p></a></li>
<li><a href='#summary.spPGOcc'><p>Methods for spPGOcc Object</p></a></li>
<li><a href='#summary.stMsPGOcc'><p>Methods for stMsPGOcc Object</p></a></li>
<li><a href='#summary.stPGOcc'><p>Methods for stPGOcc Object</p></a></li>
<li><a href='#summary.svcMsPGOcc'><p>Methods for svcMsPGOcc Object</p></a></li>
<li><a href='#summary.svcPGBinom'><p>Methods for svcPGBinom Object</p></a></li>
<li><a href='#summary.svcPGOcc'><p>Methods for svcPGOcc Object</p></a></li>
<li><a href='#summary.svcTMsPGOcc'><p>Methods for svcTMsPGOcc Object</p></a></li>
<li><a href='#summary.svcTPGBinom'><p>Methods for svcTPGBinom Object</p></a></li>
<li><a href='#summary.svcTPGOcc'><p>Methods for svcTPGOcc Object</p></a></li>
<li><a href='#summary.tMsPGOcc'><p>Methods for tMsPGOcc Object</p></a></li>
<li><a href='#summary.tPGOcc'><p>Methods for tPGOcc Object</p></a></li>
<li><a href='#svcMsPGOcc'><p>Function for Fitting Multi-Species Spatially-Varying Coefficient Occupancy Models</p></a></li>
<li><a href='#svcPGBinom'><p>Function for Fitting Single-Species Spatially-Varying Coefficient Binomial Models Using Polya-Gamma Latent Variables</p></a></li>
<li><a href='#svcPGOcc'><p>Function for Fitting Single-Species Spatially-Varying Coefficient Occupancy Models Using Polya-Gamma Latent Variables</p></a></li>
<li><a href='#svcTMsPGOcc'><p>Function for Fitting Multi-Species Multi-Season Spatially-Varying Coefficient Occupancy Models</p></a></li>
<li><a href='#svcTPGBinom'><p>Function for Fitting Multi-Season Single-Species Spatially-Varying Coefficient Binomial Models Using Polya-Gamma Latent Variables</p></a></li>
<li><a href='#svcTPGOcc'><p>Function for Fitting Multi-Season Single-Species Spatially-Varying Coefficient Occupancy Models Using Polya-Gamma Latent Variables</p></a></li>
<li><a href='#tMsPGOcc'><p>Function for Fitting Multi-Species Multi-Season Occupancy Models</p></a></li>
<li><a href='#tPGOcc'><p>Function for Fitting Multi-Season Single-Species Occupancy Models Using Polya-Gamma Latent Variables</p></a></li>
<li><a href='#updateMCMC'><p>Update a spOccupancy or spAbundance model run with more MCMC iterations</p></a></li>
<li><a href='#waicOcc'><p>Compute Widely Applicable Information Criterion for spOccupancy Model Objects</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Single-Species, Multi-Species, and Integrated Spatial Occupancy
Models</td>
</tr>
<tr>
<td>Version:</td>
<td>0.7.6</td>
</tr>
<tr>
<td>Author:</td>
<td>Jeffrey Doser [aut, cre],
  Andrew Finley [aut],
  Marc Kery [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Jeffrey Doser &lt;doserjef@msu.edu&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Fits single-species, multi-species, and integrated non-spatial and spatial occupancy models using Markov Chain Monte Carlo (MCMC). Models are fit using Polya-Gamma data augmentation detailed in Polson, Scott, and Windle (2013) &lt;<a href="https://doi.org/10.1080%2F01621459.2013.829001">doi:10.1080/01621459.2013.829001</a>&gt;. Spatial models are fit using either Gaussian processes or Nearest Neighbor Gaussian Processes (NNGP) for large spatial datasets. Details on NNGP models are given in Datta, Banerjee, Finley, and Gelfand (2016) &lt;<a href="https://doi.org/10.1080%2F01621459.2015.1044091">doi:10.1080/01621459.2015.1044091</a>&gt; and Finley, Datta, and Banerjee (2022) &lt;<a href="https://doi.org/10.18637%2Fjss.v103.i05">doi:10.18637/jss.v103.i05</a>&gt;. Provides functionality for data integration of multiple single-species occupancy data sets using a joint likelihood framework. Details on data integration are given in Miller, Pacifici, Sanderlin, and Reich (2019) &lt;<a href="https://doi.org/10.1111%2F2041-210X.13110">doi:10.1111/2041-210X.13110</a>&gt;. Details on single-species and multi-species models are found in MacKenzie, Nichols, Lachman, Droege, Royle, and Langtimm (2002) &lt;<a href="https://doi.org/10.1890%2F0012-9658%282002%29083%5B2248%3AESORWD%5D2.0.CO%3B2">doi:10.1890/0012-9658(2002)083[2248:ESORWD]2.0.CO;2</a>&gt; and Dorazio and Royle &lt;<a href="https://doi.org/10.1198%2F016214505000000015">doi:10.1198/016214505000000015</a>&gt;, respectively. </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://www.jeffdoser.com/files/spoccupancy-web">https://www.jeffdoser.com/files/spoccupancy-web</a>,
<a href="https://github.com/doserjef/spOccupancy">https://github.com/doserjef/spOccupancy</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/doserjef/spOccupancy/issues">https://github.com/doserjef/spOccupancy/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, coda, abind, RANN, lme4, foreach, doParallel,
spAbundance, methods</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-04-18 17:37:25 UTC; jeff</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-04-19 12:22:41 UTC</td>
</tr>
</table>
<hr>
<h2 id='spOccupancy-package'>Single-Species, Multi-Species, and Integrated Spatial Occupancy Models</h2><span id='topic+spOccupancy-package'></span><span id='topic+spOccupancy'></span>

<h3>Description</h3>

<p>Fits single-species, multi-species, and integrated non-spatial and spatial 
occupancy models using Markov Chain Monte Carlo (MCMC). Models are fit using 
Polya-Gamma data augmentation detailed in Polson, Scott, and Windle (2013). 
Spatial models are fit using either Gaussian processes or Nearest Neighbor 
Gaussian Processes (NNGP) for large spatial datasets. Details on NNGPs are 
given in Datta, Banerjee, Finley, and Gelfand (2016). Provides functionality 
for data integration of multiple occupancy data sets using a 
joint likelihood framework. Details on data integration are given in 
Miller, Pacifici, Sanderlin, and Reich (2019). Details on single-species and 
multi-species models are found in MacKenzie et al. (2002) and Dorazio and Royle (2005), 
respectively. Details on the package functionality is given in Doser et al. (2022), 
Doser, Finley, Banerjee (2023), Doser et al. (2024a,b). 
See <code>citation('spOccupancy')</code> for how to cite spOccupancy in publications.
</p>
<p><strong>Single-species models</strong>
</p>
<p><code><a href="#topic+PGOcc">PGOcc</a></code> fits single-species occupancy models.
</p>
<p><code><a href="#topic+spPGOcc">spPGOcc</a></code> fits single-species spatial occupancy models.
</p>
<p><code><a href="#topic+intPGOcc">intPGOcc</a></code> fits single-species integrated occupancy models (i.e., an occupancy model with multiple data sources).
</p>
<p><code><a href="#topic+spIntPGOcc">spIntPGOcc</a></code> fits single-species integrated spatial occupancy models.
</p>
<p><code><a href="#topic+tPGOcc">tPGOcc</a></code> fits a multi-season single-species occupancy model.
</p>
<p><code><a href="#topic+stPGOcc">stPGOcc</a></code> fits a multi-season single-species spatial occupancy model.
</p>
<p><code><a href="#topic+svcPGBinom">svcPGBinom</a></code> fits a single-species spatially-varying coefficient GLM.
</p>
<p><code><a href="#topic+svcPGOcc">svcPGOcc</a></code> fits a single-species spatially-varying coefficient occupancy model.
</p>
<p><code><a href="#topic+svcTPGBinom">svcTPGBinom</a></code> fits a single-species spatially-varying coefficient multi-season GLM.
</p>
<p><code><a href="#topic+svcTPGOcc">svcTPGOcc</a></code> fits a single-species spatially-varying coefficient multi-season occupancy model.
</p>
<p><strong>Multi-species models</strong>
</p>
<p><code><a href="#topic+msPGOcc">msPGOcc</a></code> fits multi-species occupancy models.
</p>
<p><code><a href="#topic+spMsPGOcc">spMsPGOcc</a></code> fits multi-species spatial occupancy models.
</p>
<p><code><a href="#topic+lfJSDM">lfJSDM</a></code> fits a joint species distribution model without imperfect detection. 
</p>
<p><code><a href="#topic+sfJSDM">sfJSDM</a></code> fits a spatial joint species distribution model without imperfect detection.
</p>
<p><code><a href="#topic+lfMsPGOcc">lfMsPGOcc</a></code> fits a joint species distribution model with imperfect detection (i.e., a multi-species occupancy model with residual species correlations).
</p>
<p><code><a href="#topic+sfMsPGOcc">sfMsPGOcc</a></code> fits a spatial joint species distribution model with imperfect detection.
</p>
<p><code><a href="#topic+svcMsPGOcc">svcMsPGOcc</a></code> fits a multi-species spatially-varying coefficient occupancy model.
</p>
<p><code><a href="#topic+tMsPGOcc">tMsPGOcc</a></code> fits a multi-season multi-species occupancy model.
</p>
<p><code><a href="#topic+stMsPGOcc">stMsPGOcc</a></code> fits a multi-season multi-species spatial occupancy model.
</p>
<p><code><a href="#topic+svcTMsPGOcc">svcTMsPGOcc</a></code> fits a multi-season multi-species spatially-varying coefficient occupancy model.
</p>
<p><strong>Goodness of Fit and Model Assessment Functions</strong>
</p>
<p><code><a href="#topic+ppcOcc">ppcOcc</a></code> performs posterior predictive checks.
</p>
<p><code><a href="#topic+waicOcc">waicOcc</a></code> computes the Widely Applicable Information Criterion for spOccupancy model objects.
</p>
<p><strong>Data Simulation Functions</strong>
</p>
<p><code><a href="#topic+simOcc">simOcc</a></code> simulates single-species occupancy data.
</p>
<p><code><a href="#topic+simTOcc">simTOcc</a></code> simulates single-species multi-season occupancy data.
</p>
<p><code><a href="#topic+simBinom">simBinom</a></code> simulates detection-nondetection data with perfect detection.
</p>
<p><code><a href="#topic+simTBinom">simTBinom</a></code> simulates multi-season detection-nondetection data with perfect detection.
</p>
<p><code><a href="#topic+simMsOcc">simMsOcc</a></code> simulates multi-species occupancy data.
</p>
<p><code><a href="#topic+simIntOcc">simIntOcc</a></code> simulates single-species occupancy data from multiple data sources. 
</p>
<p><code><a href="#topic+simTMsOcc">simTMsOcc</a></code> simulates multi-species multi-season occupancy data from multiple data sources. 
</p>
<p><strong>Miscellaneous</strong>
</p>
<p><code><a href="#topic+postHocLM">postHocLM</a></code> fits post-hoc linear (mixed) models.
</p>
<p><code><a href="#topic+getSVCSamples">getSVCSamples</a></code> extracts spatially varying coefficient MCMC samples.
</p>
<p><code><a href="#topic+updateMCMC">updateMCMC</a></code> updates a spOccupancy or spAbundance model object with more MCMC iterations.
</p>
<p>All objects from model-fitting functions have support with the <code>summary</code> function for 
displaying a concise summary of model results, the <code>fitted</code> function for extracting 
model fitted values, and the <code>predict</code> function for predicting occupancy and/or detection
across an area of interest.
</p>


<h3>Author(s)</h3>

<p>Jeffrey W. Doser, Andrew O. Finley, Marc Kery
</p>


<h3>References</h3>

<p>Doser, J. W., Finley, A. O., Kery, M., &amp; Zipkin, E. F. (2022). 
spOccupancy: An R package for single-species, multi-species, and 
integrated spatial occupancy models. 
Methods in Ecology and Evolution, 13, 1670-1678. <a href="https://doi.org/10.1111/2041-210X.13897">doi:10.1111/2041-210X.13897</a>.
</p>
<p>Doser, J. W., Finley, A. O., &amp; Banerjee, S. (2023). Joint species 
distribution models with imperfect detection for high-dimensional 
spatial data. Ecology, 104(9), e4137. <a href="https://doi.org/10.1002/ecy.4137">doi:10.1002/ecy.4137</a>.
</p>
<p>Doser, J. W., Finley, A. O., Saunders, S. P., Kery, M., Weed, A. S., &amp;
Zipkin, E. F. (2024A). Modeling complex species-environment
relationships through spatially-varying coefficient occupancy models.
Journal of Agricultural, Biological and Environmental Statistics.
<a href="https://doi.org/10.1007/s13253-023-00595-6">doi:10.1007/s13253-023-00595-6</a>.
</p>
<p>Doser, J. W., Kery, M., Saunders, S. P., Finley, A. O., Bateman, B. L.,
Grand, J., Reault, S., Weed, A. S., &amp; Zipkin, E. F. (2024B). Guidelines
for the use of spatially varying coefficients in species distribution
models. Global Ecology and Biogeography, 33, e13814.
<a href="https://doi.org/10.1111/geb.13814">doi:10.1111/geb.13814</a>.
</p>

<hr>
<h2 id='fitted.intPGOcc'>Extract Model Fitted Values for intPGOcc Object</h2><span id='topic+fitted.intPGOcc'></span>

<h3>Description</h3>

<p>Method for extracting model fitted values and detection probability values from a fitted single-species integrated occupancy (<code>intPGOcc</code>) model. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'intPGOcc'
fitted(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitted.intPGOcc_+3A_object">object</code></td>
<td>
<p>object of class <code>intPGOcc</code>.</p>
</td></tr>
<tr><td><code id="fitted.intPGOcc_+3A_...">...</code></td>
<td>
<p>currently no additional arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A method to the generic <code><a href="stats.html#topic+fitted">fitted</a></code> function to extract fitted values and detection probability values for fitted model objects of class <code>intPGOcc</code>. 
</p>


<h3>Value</h3>

<p>A list comprised of
</p>
<table>
<tr><td><code>y.rep.samples</code></td>
<td>
<p>A list of three-dimensional numeric arrays of fitted values for each individual data source for use in Goodness of Fit assessments.</p>
</td></tr>
<tr><td><code>p.samples</code></td>
<td>
<p>A list of three-dimensional numeric arrays of detection probability values.</p>
</td></tr>
</table>

<hr>
<h2 id='fitted.lfJSDM'>Extract Model Fitted Values for lfJSDM Object</h2><span id='topic+fitted.lfJSDM'></span>

<h3>Description</h3>

<p>Method for extracting model fitted values and probability values from a fitted latent factor joint species distribution model (<code>lfJSDM</code>). 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lfJSDM'
fitted(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitted.lfJSDM_+3A_object">object</code></td>
<td>
<p>object of class <code>lfJSDM</code>.</p>
</td></tr>
<tr><td><code id="fitted.lfJSDM_+3A_...">...</code></td>
<td>
<p>currently no additional arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A method to the generic <code><a href="stats.html#topic+fitted">fitted</a></code> function to extract fitted values and probability values for fitted model objects of class <code>lfJSDM</code>. 
</p>


<h3>Value</h3>

<p>A list comprised of: 
</p>
<table>
<tr><td><code>z.samples</code></td>
<td>
<p>A three-dimensional numeric array of fitted values for use in Goodness of Fit assessments. Array dimensions correspond to MCMC samples, species, and sites.</p>
</td></tr>
<tr><td><code>psi.samples</code></td>
<td>
<p>A three-dimensional numeric array of probability values. Array dimensions correspond to MCMC samples, species, and sites.</p>
</td></tr>
</table>

<hr>
<h2 id='fitted.lfMsPGOcc'>Extract Model Fitted Values for lfMsPGOcc Object</h2><span id='topic+fitted.lfMsPGOcc'></span>

<h3>Description</h3>

<p>Method for extracting model fitted values and detection probability values from a fitted latent factor multi-species occupancy (<code>lfMsPGOcc</code>) model. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lfMsPGOcc'
fitted(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitted.lfMsPGOcc_+3A_object">object</code></td>
<td>
<p>object of class <code>lfMsPGOcc</code>.</p>
</td></tr>
<tr><td><code id="fitted.lfMsPGOcc_+3A_...">...</code></td>
<td>
<p>currently no additional arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A method to the generic <code><a href="stats.html#topic+fitted">fitted</a></code> function to extract fitted values and detection probability values for fitted model objects of class <code>lfMsPGOcc</code>. 
</p>


<h3>Value</h3>

<p>A list comprised of: 
</p>
<table>
<tr><td><code>y.rep.samples</code></td>
<td>
<p>A four-dimensional numeric array of fitted values for use in Goodness of Fit assessments. Array dimensions correspond to MCMC samples, species, sites, and replicates.</p>
</td></tr>
<tr><td><code>p.samples</code></td>
<td>
<p>A four-dimensional numeric array of detection probability values. Array dimensions correspond to MCMC samples, species, sites, and replicates.</p>
</td></tr>
</table>

<hr>
<h2 id='fitted.msPGOcc'>Extract Model Fitted Values for msPGOcc Object</h2><span id='topic+fitted.msPGOcc'></span>

<h3>Description</h3>

<p>Method for extracting model fitted values and detection probability values from a fitted multi-species occupancy (<code>msPGOcc</code>) model. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'msPGOcc'
fitted(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitted.msPGOcc_+3A_object">object</code></td>
<td>
<p>object of class <code>msPGOcc</code>.</p>
</td></tr>
<tr><td><code id="fitted.msPGOcc_+3A_...">...</code></td>
<td>
<p>currently no additional arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A method to the generic <code><a href="stats.html#topic+fitted">fitted</a></code> function to extract fitted values and detection probability values for fitted model objects of class <code>msPGOcc</code>. 
</p>


<h3>Value</h3>

<p>A list comprised of: 
</p>
<table>
<tr><td><code>y.rep.samples</code></td>
<td>
<p>A four-dimensional numeric array of fitted values for use in Goodness of Fit assessments. Array dimensions correspond to MCMC samples, species, sites, and replicates.</p>
</td></tr>
<tr><td><code>p.samples</code></td>
<td>
<p>A four-dimensional numeric array of detection probability values. Array dimensions correspond to MCMC samples, species, sites, and replicates.</p>
</td></tr>
</table>

<hr>
<h2 id='fitted.PGOcc'>Extract Model Fitted Values for PGOcc Object</h2><span id='topic+fitted.PGOcc'></span>

<h3>Description</h3>

<p>Method for extracting model fitted values and detection probabilities from a fitted single-species occupancy (<code>PGOcc</code>) model. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'PGOcc'
fitted(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitted.PGOcc_+3A_object">object</code></td>
<td>
<p>object of class <code>PGOcc</code>.</p>
</td></tr>
<tr><td><code id="fitted.PGOcc_+3A_...">...</code></td>
<td>
<p>currently no additional arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A method to the generic <code><a href="stats.html#topic+fitted">fitted</a></code> function to extract fitted values and detection probabilities for fitted model objects of class <code>PGOcc</code>. 
</p>


<h3>Value</h3>

<p>A list comprised of: 
</p>
<table>
<tr><td><code>y.rep.samples</code></td>
<td>
<p>A three-dimensional numeric array of fitted values for use in Goodness of Fit assessments. Array dimensions correspond to MCMC samples, sites, and replicates.</p>
</td></tr>
<tr><td><code>p.samples</code></td>
<td>
<p>A three-dimensional numeric array of detection probability values. Array dimensions correspond to MCMC samples, sites, and replicates.</p>
</td></tr>
</table>

<hr>
<h2 id='fitted.sfJSDM'>Extract Model Fitted Values for sfJSDM Object</h2><span id='topic+fitted.sfJSDM'></span>

<h3>Description</h3>

<p>Method for extracting model fitted values and probability values from a fitted spatial factor joint species distribution model (<code>sfJSDM</code>). 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sfJSDM'
fitted(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitted.sfJSDM_+3A_object">object</code></td>
<td>
<p>object of class <code>sfJSDM</code>.</p>
</td></tr>
<tr><td><code id="fitted.sfJSDM_+3A_...">...</code></td>
<td>
<p>currently no additional arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A method to the generic <code><a href="stats.html#topic+fitted">fitted</a></code> function to extract fitted values and probability values for fitted model objects of class <code>sfJSDM</code>. 
</p>


<h3>Value</h3>

<p>A list comprised of: 
</p>
<table>
<tr><td><code>z.samples</code></td>
<td>
<p>A three-dimensional numeric array of fitted values for use in Goodness of Fit assessments. Array dimensions correspond to MCMC samples, species, and sites.</p>
</td></tr>
<tr><td><code>psi.samples</code></td>
<td>
<p>A three-dimensional numeric array of probability values. Array dimensions correspond to MCMC samples, species, and sites.</p>
</td></tr>
</table>

<hr>
<h2 id='fitted.sfMsPGOcc'>Extract Model Fitted Values for sfMsPGOcc Object</h2><span id='topic+fitted.sfMsPGOcc'></span>

<h3>Description</h3>

<p>Method for extracting model fitted values and detection probability values from a fitted spatial factor multi-species occupancy (<code>sfMsPGOcc</code>) model. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sfMsPGOcc'
fitted(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitted.sfMsPGOcc_+3A_object">object</code></td>
<td>
<p>object of class <code>sfMsPGOcc</code>.</p>
</td></tr>
<tr><td><code id="fitted.sfMsPGOcc_+3A_...">...</code></td>
<td>
<p>currently no additional arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A method to the generic <code><a href="stats.html#topic+fitted">fitted</a></code> function to extract fitted values and detection probability values for fitted model objects of class <code>sfMsPGOcc</code>. 
</p>


<h3>Value</h3>

<p>A list comprised of: 
</p>
<table>
<tr><td><code>y.rep.samples</code></td>
<td>
<p>A four-dimensional numeric array of fitted values for use in Goodness of Fit assessments. Array dimensions correspond to MCMC samples, species, sites, and replicates.</p>
</td></tr>
<tr><td><code>p.samples</code></td>
<td>
<p>A four-dimensional numeric array of detection probability values. Array dimensions correspond to MCMC samples, species, sites, and replicates.</p>
</td></tr>
</table>

<hr>
<h2 id='fitted.spIntPGOcc'>Extract Model Fitted Values for spIntPGOcc Object</h2><span id='topic+fitted.spIntPGOcc'></span>

<h3>Description</h3>

<p>Method for extracting model fitted values and detection probability values from a fitted single-species integrated spatial occupancy (<code>spIntPGOcc</code>) model. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'spIntPGOcc'
fitted(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitted.spIntPGOcc_+3A_object">object</code></td>
<td>
<p>object of class <code>spIntPGOcc</code>.</p>
</td></tr>
<tr><td><code id="fitted.spIntPGOcc_+3A_...">...</code></td>
<td>
<p>currently no additional arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A method to the generic <code><a href="stats.html#topic+fitted">fitted</a></code> function to extract fitted values and detection probability values for fitted model objects of class <code>spIntPGOcc</code>. 
</p>


<h3>Value</h3>

<p>A list comprised of 
</p>
<table>
<tr><td><code>y.rep.samples</code></td>
<td>
<p>A list of three-dimensional numeric arrays of fitted values for each individual data source for use in Goodness of Fit assessments.</p>
</td></tr>
<tr><td><code>p.samples</code></td>
<td>
<p>A list of three-dimensional numeric arrays of detection probability values.</p>
</td></tr>
</table>

<hr>
<h2 id='fitted.spMsPGOcc'>Extract Model Fitted Values for spMsPGOcc Object</h2><span id='topic+fitted.spMsPGOcc'></span>

<h3>Description</h3>

<p>Method for extracting model fitted values and detection probability values from a fitted multi-species spatial occupancy (<code>spMsPGOcc</code>) model. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'spMsPGOcc'
fitted(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitted.spMsPGOcc_+3A_object">object</code></td>
<td>
<p>object of class <code>spMsPGOcc</code>.</p>
</td></tr>
<tr><td><code id="fitted.spMsPGOcc_+3A_...">...</code></td>
<td>
<p>currently no additional arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A method to the generic <code><a href="stats.html#topic+fitted">fitted</a></code> function to extract fitted values and detection probability values for fitted model objects of class <code>spMsPGOcc</code>. 
</p>


<h3>Value</h3>

<p>A list comprised of: 
</p>
<table>
<tr><td><code>y.rep.samples</code></td>
<td>
<p>A four-dimensional numeric array of fitted values for use in Goodness of Fit assessments. Array dimensions correspond to MCMC samples, species, sites, and replicates.</p>
</td></tr>
<tr><td><code>p.samples</code></td>
<td>
<p>A four-dimensional numeric array of detection probability values. Array dimensions correspond to MCMC samples, species, sites, and replicates.</p>
</td></tr>
</table>

<hr>
<h2 id='fitted.spPGOcc'>Extract Model Fitted Values for spPGOcc Object</h2><span id='topic+fitted.spPGOcc'></span>

<h3>Description</h3>

<p>Method for extracting model fitted values and detection probabilities from a fitted single-species spatial occupancy (<code>spPGOcc</code>) model. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'spPGOcc'
fitted(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitted.spPGOcc_+3A_object">object</code></td>
<td>
<p>object of class <code>spPGOcc</code>.</p>
</td></tr>
<tr><td><code id="fitted.spPGOcc_+3A_...">...</code></td>
<td>
<p>currently no additional arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A method to the generic <code><a href="stats.html#topic+fitted">fitted</a></code> function to extract fitted values and detection probabilities for fitted model objects of class <code>spPGOcc</code>. 
</p>


<h3>Value</h3>

<p>A list comprised of: 
</p>
<table>
<tr><td><code>y.rep.samples</code></td>
<td>
<p>A three-dimensional numeric array of fitted values for use in Goodness of Fit assessments. Array dimensions correspond to MCMC samples, sites, and replicates.</p>
</td></tr>
<tr><td><code>p.samples</code></td>
<td>
<p>A three-dimensional numeric array of detection probability values. Array dimensions correspond to MCMC samples, sites, and replicates.</p>
</td></tr>
</table>

<hr>
<h2 id='fitted.stMsPGOcc'>Extract Model Fitted Values for stMsPGOcc Object</h2><span id='topic+fitted.stMsPGOcc'></span>

<h3>Description</h3>

<p>Method for extracting model fitted values and detection probability values from a fitted multi-species multi-season spatial occupancy (<code>stMsPGOcc</code>) model. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'stMsPGOcc'
fitted(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitted.stMsPGOcc_+3A_object">object</code></td>
<td>
<p>object of class <code>stMsPGOcc</code>.</p>
</td></tr>
<tr><td><code id="fitted.stMsPGOcc_+3A_...">...</code></td>
<td>
<p>currently no additional arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A method to the generic <code><a href="stats.html#topic+fitted">fitted</a></code> function to extract fitted values and detection probability values for fitted model objects of class <code>stMsPGOcc</code>. 
</p>


<h3>Value</h3>

<p>A list comprised of: 
</p>
<table>
<tr><td><code>y.rep.samples</code></td>
<td>
<p>A five-dimensional numeric array of fitted values for use in Goodness of Fit assessments. Array dimensions correspond to MCMC samples, species, sites, primary time period, and replicates.</p>
</td></tr>
<tr><td><code>p.samples</code></td>
<td>
<p>A five-dimensional numeric array of detection probability values. Array dimensions correspond to MCMC samples, species, sites, primary time period, and replicates.</p>
</td></tr>
</table>

<hr>
<h2 id='fitted.stPGOcc'>Extract Model Fitted Values for stPGOcc Object</h2><span id='topic+fitted.stPGOcc'></span>

<h3>Description</h3>

<p>Method for extracting model fitted values and detection probabilities from a fitted multi-season single-species spatial occupancy (<code>stPGOcc</code>) model. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'stPGOcc'
fitted(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitted.stPGOcc_+3A_object">object</code></td>
<td>
<p>object of class <code>stPGOcc</code>.</p>
</td></tr>
<tr><td><code id="fitted.stPGOcc_+3A_...">...</code></td>
<td>
<p>currently no additional arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A method to the generic <code><a href="stats.html#topic+fitted">fitted</a></code> function to extract fitted values and detection probabilities for fitted model objects of class <code>stPGOcc</code>. 
</p>


<h3>Value</h3>

<p>A list comprised of: 
</p>
<table>
<tr><td><code>y.rep.samples</code></td>
<td>
<p>A four-dimensional numeric array of fitted values for use in Goodness of Fit assessments. Array dimensions correspond to MCMC samples, sites, primary time periods, and replicates.</p>
</td></tr>
<tr><td><code>p.samples</code></td>
<td>
<p>A four-dimensional numeric array of detection probability values. Array dimensions correspond to MCMC samples, sites, primary time periods, and replicates.</p>
</td></tr>
</table>

<hr>
<h2 id='fitted.svcMsPGOcc'>Extract Model Fitted Values for svcMsPGOcc Object</h2><span id='topic+fitted.svcMsPGOcc'></span>

<h3>Description</h3>

<p>Method for extracting model fitted values and detection probability values from a fitted multi-species spatially varying coefficient occupancy (<code>svcMsPGOcc</code>) model. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'svcMsPGOcc'
fitted(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitted.svcMsPGOcc_+3A_object">object</code></td>
<td>
<p>object of class <code>svcMsPGOcc</code>.</p>
</td></tr>
<tr><td><code id="fitted.svcMsPGOcc_+3A_...">...</code></td>
<td>
<p>currently no additional arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A method to the generic <code><a href="stats.html#topic+fitted">fitted</a></code> function to extract fitted values and detection probability values for fitted model objects of class <code>svcMsPGOcc</code>. 
</p>


<h3>Value</h3>

<p>A list comprised of: 
</p>
<table>
<tr><td><code>y.rep.samples</code></td>
<td>
<p>A four-dimensional numeric array of fitted values for use in Goodness of Fit assessments. Array dimensions correspond to MCMC samples, species, sites, and replicates.</p>
</td></tr>
<tr><td><code>p.samples</code></td>
<td>
<p>A four-dimensional numeric array of detection probability values. Array dimensions correspond to MCMC samples, species, sites, and replicates.</p>
</td></tr>
</table>

<hr>
<h2 id='fitted.svcPGBinom'>Extract Model Fitted Values for svcPGBinom Object</h2><span id='topic+fitted.svcPGBinom'></span>

<h3>Description</h3>

<p>Method for extracting model fitted values from a fitted single-species spatially-varying coefficients binomial model (<code>svcPGBinom</code>). 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'svcPGBinom'
fitted(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitted.svcPGBinom_+3A_object">object</code></td>
<td>
<p>object of class <code>svcPGBinom</code>.</p>
</td></tr>
<tr><td><code id="fitted.svcPGBinom_+3A_...">...</code></td>
<td>
<p>currently no additional arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A method to the generic <code><a href="stats.html#topic+fitted">fitted</a></code> function to extract fitted values for fitted model objects of class <code>svcPGBinom</code>. 
</p>


<h3>Value</h3>

<p>A two-dimensional matrix of fitted values for use in Goodness of Fit assessments. Dimensions correspond to MCMC samples and sites.
</p>

<hr>
<h2 id='fitted.svcPGOcc'>Extract Model Fitted Values for svcPGOcc Object</h2><span id='topic+fitted.svcPGOcc'></span>

<h3>Description</h3>

<p>Method for extracting model fitted values and detection probabilities from a fitted single-species spatially-varying coefficients occupancy (<code>svcPGOcc</code>) model. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'svcPGOcc'
fitted(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitted.svcPGOcc_+3A_object">object</code></td>
<td>
<p>object of class <code>svcPGOcc</code>.</p>
</td></tr>
<tr><td><code id="fitted.svcPGOcc_+3A_...">...</code></td>
<td>
<p>currently no additional arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A method to the generic <code><a href="stats.html#topic+fitted">fitted</a></code> function to extract fitted values and detection probabilities for fitted model objects of class <code>svcPGOcc</code>. 
</p>


<h3>Value</h3>

<p>A list comprised of: 
</p>
<table>
<tr><td><code>y.rep.samples</code></td>
<td>
<p>A three-dimensional numeric array of fitted values for use in Goodness of Fit assessments. Array dimensions correspond to MCMC samples, sites, and replicates.</p>
</td></tr>
<tr><td><code>p.samples</code></td>
<td>
<p>A three-dimensional numeric array of detection probability values. Array dimensions correspond to MCMC samples, sites, and replicates.</p>
</td></tr>
</table>

<hr>
<h2 id='fitted.svcTMsPGOcc'>Extract Model Fitted Values for svcTMsPGOcc Object</h2><span id='topic+fitted.svcTMsPGOcc'></span>

<h3>Description</h3>

<p>Method for extracting model fitted values and detection probability values from a fitted multi-species multi-season spatially varying coefficient occupancy (<code>svcTMsPGOcc</code>) model. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'svcTMsPGOcc'
fitted(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitted.svcTMsPGOcc_+3A_object">object</code></td>
<td>
<p>object of class <code>svcTMsPGOcc</code>.</p>
</td></tr>
<tr><td><code id="fitted.svcTMsPGOcc_+3A_...">...</code></td>
<td>
<p>currently no additional arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A method to the generic <code><a href="stats.html#topic+fitted">fitted</a></code> function to extract fitted values and detection probability values for fitted model objects of class <code>svcTMsPGOcc</code>. 
</p>


<h3>Value</h3>

<p>A list comprised of: 
</p>
<table>
<tr><td><code>y.rep.samples</code></td>
<td>
<p>A five-dimensional numeric array of fitted values for use in Goodness of Fit assessments. Array dimensions correspond to MCMC samples, species, sites, primary time period, and replicates.</p>
</td></tr>
<tr><td><code>p.samples</code></td>
<td>
<p>A five-dimensional numeric array of detection probability values. Array dimensions correspond to MCMC samples, species, sites, primary time period, and replicates.</p>
</td></tr>
</table>

<hr>
<h2 id='fitted.svcTPGBinom'>Extract Model Fitted Values for svcTPGBinom Object</h2><span id='topic+fitted.svcTPGBinom'></span>

<h3>Description</h3>

<p>Method for extracting model fitted values from a fitted multi-season single-species spatially-varying coefficients binomial model (<code>svcTPGBinom</code>). 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'svcTPGBinom'
fitted(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitted.svcTPGBinom_+3A_object">object</code></td>
<td>
<p>object of class <code>svcTPGBinom</code>.</p>
</td></tr>
<tr><td><code id="fitted.svcTPGBinom_+3A_...">...</code></td>
<td>
<p>currently no additional arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A method to the generic <code><a href="stats.html#topic+fitted">fitted</a></code> function to extract fitted values for fitted model objects of class <code>svcTPGBinom</code>. 
</p>


<h3>Value</h3>

<p>A three-dimensional matrix of fitted values for use in Goodness of Fit assessments. Dimensions correspond to MCMC samples, sites, and primary time periods.
</p>

<hr>
<h2 id='fitted.svcTPGOcc'>Extract Model Fitted Values for svcTPGOcc Object</h2><span id='topic+fitted.svcTPGOcc'></span>

<h3>Description</h3>

<p>Method for extracting model fitted values and detection probabilities from a fitted multi-season single-species spatially-varying coefficients occupancy (<code>svcTPGOcc</code>) model. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'svcTPGOcc'
fitted(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitted.svcTPGOcc_+3A_object">object</code></td>
<td>
<p>object of class <code>svcTPGOcc</code>.</p>
</td></tr>
<tr><td><code id="fitted.svcTPGOcc_+3A_...">...</code></td>
<td>
<p>currently no additional arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A method to the generic <code><a href="stats.html#topic+fitted">fitted</a></code> function to extract fitted values and detection probabilities for fitted model objects of class <code>svcTPGOcc</code>. 
</p>


<h3>Value</h3>

<p>A list comprised of: 
</p>
<table>
<tr><td><code>y.rep.samples</code></td>
<td>
<p>A four-dimensional numeric array of fitted values for use in Goodness of Fit assessments. Array dimensions correspond to MCMC samples, sites, primary time periods, and replicates.</p>
</td></tr>
<tr><td><code>p.samples</code></td>
<td>
<p>A four-dimensional numeric array of detection probability values. Array dimensions correspond to MCMC samples, sites, primary time periods, and replicates.</p>
</td></tr>
</table>

<hr>
<h2 id='fitted.tMsPGOcc'>Extract Model Fitted Values for tMsPGOcc Object</h2><span id='topic+fitted.tMsPGOcc'></span>

<h3>Description</h3>

<p>Method for extracting model fitted values and detection probability values from a fitted multi-species multi-season occupancy (<code>tMsPGOcc</code>) model. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'tMsPGOcc'
fitted(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitted.tMsPGOcc_+3A_object">object</code></td>
<td>
<p>object of class <code>tMsPGOcc</code>.</p>
</td></tr>
<tr><td><code id="fitted.tMsPGOcc_+3A_...">...</code></td>
<td>
<p>currently no additional arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A method to the generic <code><a href="stats.html#topic+fitted">fitted</a></code> function to extract fitted values and detection probability values for fitted model objects of class <code>tMsPGOcc</code>. 
</p>


<h3>Value</h3>

<p>A list comprised of: 
</p>
<table>
<tr><td><code>y.rep.samples</code></td>
<td>
<p>A five-dimensional numeric array of fitted values for use in Goodness of Fit assessments. Array dimensions correspond to MCMC samples, species, sites, primary time period, and replicates.</p>
</td></tr>
<tr><td><code>p.samples</code></td>
<td>
<p>A five-dimensional numeric array of detection probability values. Array dimensions correspond to MCMC samples, species, sites, primary time period, and replicates.</p>
</td></tr>
</table>

<hr>
<h2 id='fitted.tPGOcc'>Extract Model Fitted Values for tPGOcc Object</h2><span id='topic+fitted.tPGOcc'></span>

<h3>Description</h3>

<p>Method for extracting model fitted values and detection probabilities from a fitted multi-season single-species occupancy (<code>tPGOcc</code>) model. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'tPGOcc'
fitted(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitted.tPGOcc_+3A_object">object</code></td>
<td>
<p>object of class <code>tPGOcc</code>.</p>
</td></tr>
<tr><td><code id="fitted.tPGOcc_+3A_...">...</code></td>
<td>
<p>currently no additional arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A method to the generic <code><a href="stats.html#topic+fitted">fitted</a></code> function to extract fitted values and detection probabilities for fitted model objects of class <code>tPGOcc</code>. 
</p>


<h3>Value</h3>

<p>A list comprised of: 
</p>
<table>
<tr><td><code>y.rep.samples</code></td>
<td>
<p>A four-dimensional numeric array of fitted values for use in Goodness of Fit assessments. Array dimensions correspond to MCMC samples, sites, primary time periods, and replicates.</p>
</td></tr>
<tr><td><code>p.samples</code></td>
<td>
<p>A four-dimensional numeric array of detection probability values. Array dimensions correspond to MCMC samples, sites, primary time periods, and replicates.</p>
</td></tr>
</table>

<hr>
<h2 id='getSVCSamples'>Extract spatially-varying coefficient MCMC samples</h2><span id='topic+getSVCSamples'></span>

<h3>Description</h3>

<p>Function for extracting the full spatially-varying coefficient MCMC samples
from an spOccupancy model object. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getSVCSamples(object, pred.object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getSVCSamples_+3A_object">object</code></td>
<td>
<p>an object of class <code>svcPGOcc</code>, <code>svcPGBinom</code>, 
<code>svcTPGOcc</code>, <code>svcTPGBinom</code>, <code>svcMsPGOcc</code>, <code>svcTMsPGOcc</code>.</p>
</td></tr>
<tr><td><code id="getSVCSamples_+3A_pred.object">pred.object</code></td>
<td>
<p>a prediction object from a spatially-varying coefficient 
model fit using spOccupancy. Should be of class <code>predict.svcPGOcc</code>, 
<code>predict.svcPGBinom</code>, <code>predict.svcTPGOcc</code>, <code>predict.svcTPGBinom</code>, 
<code>predict.svcMsPGOcc</code>, or <code>predict.svcTMsPGOcc</code>. 
If specified, SVC samples are extracted at the prediction locations.</p>
</td></tr>
<tr><td><code id="getSVCSamples_+3A_...">...</code></td>
<td>
<p>currently no additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of <code>coda::mcmc</code> objects of the spatially-varying coefficient MCMC samples
for all spatially-varying coefficients estimated in the model (including the
intercept if specified). Note these values correspond to the sum of the estimated
spatial and non-spatial effect to give the overall effect of the covariate at
each location. Each element of the list is a two-dimensional matrix 
where dimensions correspond to MCMC sample and site. If <code>pred.object</code> is specified, 
values are returned for the prediction locations instead of the sampled locations. 
</p>


<h3>Note</h3>

<p>For multi-species models, the value of the SVC will be returned at all 
spatial locations for each species even when <code>range.ind</code> is specified
in the data list when fitting the model. This may not be desirable for complete
summaries of the SVC for each species, so if specifying <code>range.ind</code> in 
the data list, you may want to subsequently process the SVC samples for each species
to be restricted to each species range.
</p>


<h3>Author(s)</h3>

<p>Jeffrey W. Doser <a href="mailto:doserjef@msu.edu">doserjef@msu.edu</a>, <br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(400)
# Simulate Data -----------------------------------------------------------
J.x &lt;- 8
J.y &lt;- 8
J &lt;- J.x * J.y
n.rep &lt;- sample(2:4, J, replace = TRUE)
beta &lt;- c(0.5, 2)
p.occ &lt;- length(beta)
alpha &lt;- c(0, 1)
p.det &lt;- length(alpha)
phi &lt;- c(3 / .6, 3 / .8)
sigma.sq &lt;- c(1.2, 0.7)
svc.cols &lt;- c(1, 2)
dat &lt;- simOcc(J.x = J.x, J.y = J.y, n.rep = n.rep, beta = beta, alpha = alpha, 
              sigma.sq = sigma.sq, phi = phi, sp = TRUE, cov.model = 'exponential', 
              svc.cols = svc.cols)
# Detection-nondetection data
y &lt;- dat$y
# Occupancy covariates
X &lt;- dat$X
# Detection covarites
X.p &lt;- dat$X.p
# Spatial coordinates
coords &lt;- dat$coords

# Package all data into a list
occ.covs &lt;- X[, -1, drop = FALSE]
colnames(occ.covs) &lt;- c('occ.cov')
det.covs &lt;- list(det.cov.1 = X.p[, , 2])
data.list &lt;- list(y = y, 
                  occ.covs = occ.covs, 
                  det.covs = det.covs, 
                  coords = coords)

# Number of batches
n.batch &lt;- 10
# Batch length
batch.length &lt;- 25
n.iter &lt;- n.batch * batch.length
# Priors 
prior.list &lt;- list(beta.normal = list(mean = 0, var = 2.72), 
                   alpha.normal = list(mean = 0, var = 2.72),
                   sigma.sq.ig = list(a = 2, b = 1), 
                   phi.unif = list(a = 3/1, b = 3/.1)) 
# Initial values
inits.list &lt;- list(alpha = 0, beta = 0,
                   phi = 3 / .5, 
                   sigma.sq = 2,
                   w = matrix(0, nrow = length(svc.cols), ncol = nrow(X)),
                   z = apply(y, 1, max, na.rm = TRUE))
# Tuning
tuning.list &lt;- list(phi = 1) 

out &lt;- svcPGOcc(occ.formula = ~ occ.cov, 
                det.formula = ~ det.cov.1, 
                data = data.list, 
                inits = inits.list, 
                n.batch = n.batch, 
                batch.length = batch.length, 
                accept.rate = 0.43, 
                priors = prior.list,
                cov.model = 'exponential', 
                svc.cols = c(1, 2),
                tuning = tuning.list, 
                n.omp.threads = 1, 
                verbose = TRUE, 
                NNGP = TRUE, 
                n.neighbors = 5, 
                search.type = 'cb', 
                n.report = 10, 
                n.burn = 50, 
                n.thin = 1)

svc.samples &lt;- getSVCSamples(out)
str(svc.samples)
</code></pre>

<hr>
<h2 id='hbef2015'>Detection-nondetection data of 12 foliage gleaning bird species
in 2015 in the Hubbard Brook Experimental Forest</h2><span id='topic+hbef2015'></span>

<h3>Description</h3>

<p>Detection-nondetection data of 12 foliage gleaning bird species in 2015 in the 
Hubbard Brook Experimental Forest (HBEF) in New Hampshire, USA. Data were collected at 373
sites over three replicate point counts each of 10 minutes in length, with a detection 
radius of 100m. Some sites were not visited for all three replicates. The 12 species
included in the data set are as follows: (1) AMRE: American Redstart; (2) BAWW: 
Black-and-white Warbler; (3) BHVI: Blue-headed Vireo; (4) BLBW: Blackburnian Warbler; 
(5) BLPW: Blackpoll Warbler; (6) BTBW: Black-throated Blue Warbler; (7) BTNW: 
BLack-throated Green Warbler; (8) CAWA: Canada Warbler; (9) MAWA: Magnolia Warbler; 
(10) NAWA: Nashville Warbler; (11) OVEN: Ovenbird; (12) REVI: Red-eyed Vireo. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(hbef2015)
</code></pre>


<h3>Format</h3>

<p><code>hbef2015</code> is a list with four elements: 
</p>
<p><code>y</code>: a three-dimensional array of detection-nondetection data with 
dimensions of species (12), sites (373) and replicates (3). 
</p>
<p><code>occ.covs</code>: a numeric matrix with 373 rows and one column consisting of the 
elevation at each site.
</p>
<p><code>det.covs</code>: a list of two numeric matrices with 373 rows and 3 columns. 
The first element is the day of year when the survey was 
conducted for a given site and replicate. The second element is the
time of day when the survey was conducted. 
</p>
<p><code>coords</code>: a numeric matrix with 373 rows and two columns containing the 
site coordinates (Easting and Northing) in UTM Zone 19. The proj4string is
&quot;+proj=utm +zone=19 +units=m +datum=NAD83&quot;.
</p>


<h3>Source</h3>

<p>Rodenhouse, N. and S. Sillett. 2019. Valleywide Bird Survey, Hubbard Brook 
Experimental Forest, 1999-2016 (ongoing) ver 3. Environmental Data Initiative. 
<a href="https://doi.org/10.6073/pasta/faca2b2cf2db9d415c39b695cc7fc217">doi:10.6073/pasta/faca2b2cf2db9d415c39b695cc7fc217</a> 
(Accessed 2021-09-07)</p>


<h3>References</h3>

<p>Doser, J. W., Leuenberger, W., Sillett, T. S., Hallworth, M. T. &amp; Zipkin, E. F. (2022). 
Integrated community occupancy models: A framework to assess occurrence and biodiversity 
dynamics using multiple data sources. Methods in Ecology and Evolution, 00, 1-14. <a href="https://doi.org/10.1111/2041-210X.13811">doi:10.1111/2041-210X.13811</a>
</p>

<hr>
<h2 id='hbefElev'>Elevation in meters extracted at a 30m resolution across the Hubbard Brook Experimental Forest</h2><span id='topic+hbefElev'></span>

<h3>Description</h3>

<p>Elevation in meters extracted at a 30m resolution of the Hubbard Brook Experimental Forest. 
Data come from the National Elevation Dataset. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(hbefElev)
</code></pre>


<h3>Format</h3>

<p><code>hbefElev</code> is a data frame with three columns:
</p>
<p><code>val</code>: the elevation value in meters.
</p>
<p><code>Easting</code>: the x coordinate of the point. The proj4string is 
&quot;+proj=utm +zone=19 +units=m +datum=NAD83&quot;.
</p>
<p><code>Northing</code>: the y coordinate of the point. The proj4string is 
&quot;+proj=utm +zone=19 +units=m +datum=NAD83&quot;.
</p>


<h3>Source</h3>

<p>Gesch, D., Oimoen, M., Greenlee, S., Nelson, C., Steuck, M., &amp; Tyler, D. (2002). 
The national elevation dataset. Photogrammetric engineering and remote sensing, 
68(1), 5-32.
</p>


<h3>References</h3>

<p>Gesch, D., Oimoen, M., Greenlee, S., Nelson, C., Steuck, M., &amp; Tyler, D. (2002). 
The national elevation dataset. Photogrammetric engineering and remote sensing, 
68(1), 5-32.
</p>

<hr>
<h2 id='hbefTrends'>Detection-nondetection data of 12 foliage gleaning bird species
from 2010-2018 in the Hubbard Brook Experimental Forest</h2><span id='topic+hbefTrends'></span>

<h3>Description</h3>

<p>Detection-nondetection data of 12 foliage gleaning bird species in 2010-2018 in the 
Hubbard Brook Experimental Forest (HBEF) in New Hampshire, USA. Data were collected at 373
sites over three replicate point counts each of 10 minutes in length, with a detection 
radius of 100m. Some sites were not visited for all three replicates. The 12 species
included in the data set are as follows: (1) AMRE: American Redstart; (2) BAWW: 
Black-and-white Warbler; (3) BHVI: Blue-headed Vireo; (4) BLBW: Blackburnian Warbler; 
(5) BLPW: Blackpoll Warbler; (6) BTBW: Black-throated Blue Warbler; (7) BTNW: 
BLack-throated Green Warbler; (8) CAWA: Canada Warbler; (9) MAWA: Magnolia Warbler; 
(10) NAWA: Nashville Warbler; (11) OVEN: Ovenbird; (12) REVI: Red-eyed Vireo. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(hbefTrends)
</code></pre>


<h3>Format</h3>

<p><code>hbefTrends</code> is a list with four elements: 
</p>
<p><code>y</code>: a four-dimensional array of detection-nondetection data with 
dimensions of species (12), sites (373), years (9), and replicates (3). 
</p>
<p><code>occ.covs</code>: a list of potential covariates for inclusion in the 
occurrence portion of an occupancy model. There are two covariates: 
elevation (a site-level covariate), and years (a temporal covariate.
)
<code>det.covs</code>: a list of two numeric three-dimensional arrays with
dimensions corresponding to sites (373), years (9), and replicates (3).
The first element is the day of year when the survey was 
conducted for a given site, year, and replicate. The second element is the
time of day when the survey was conducted. 
</p>
<p><code>coords</code>: a numeric matrix with 373 rows and two columns containing the 
site coordinates (Easting and Northing) in UTM Zone 19. The proj4string is
&quot;+proj=utm +zone=19 +units=m +datum=NAD83&quot;.
</p>


<h3>Source</h3>

<p>Rodenhouse, N. and S. Sillett. 2019. Valleywide Bird Survey, Hubbard Brook 
Experimental Forest, 1999-2016 (ongoing) ver 3. Environmental Data Initiative. 
<a href="https://doi.org/10.6073/pasta/faca2b2cf2db9d415c39b695cc7fc217">doi:10.6073/pasta/faca2b2cf2db9d415c39b695cc7fc217</a> 
(Accessed 2021-09-07)</p>


<h3>References</h3>

<p>Doser, J. W., Leuenberger, W., Sillett, T. S., Hallworth, M. T. &amp; Zipkin, E. F. (2022). 
Integrated community occupancy models: A framework to assess occurrence and biodiversity 
dynamics using multiple data sources. Methods in Ecology and Evolution, 00, 1-14. <a href="https://doi.org/10.1111/2041-210X.13811">doi:10.1111/2041-210X.13811</a>
</p>

<hr>
<h2 id='intMsPGOcc'>Function for Fitting Integrated Multi-Species Occupancy Models Using Polya-Gamma Latent Variables</h2><span id='topic+intMsPGOcc'></span>

<h3>Description</h3>

<p>Function for fitting integrated multi-species occupancy models using Polya-Gamma latent variables. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>intMsPGOcc(occ.formula, det.formula, data, inits, priors, n.samples,
           n.omp.threads = 1, verbose = TRUE, n.report = 100, 
           n.burn = round(.10 * n.samples), n.thin = 1, n.chains = 1,
           k.fold, k.fold.threads = 1, k.fold.seed, k.fold.only = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="intMsPGOcc_+3A_occ.formula">occ.formula</code></td>
<td>
<p>a symbolic description of the model to be fit
for the occurrence portion of the model using R's model syntax. Only
right-hand side of formula is specified. See example below. Random 
intercepts are allowed using <span class="pkg">lme4</span> syntax (Bates et al. 2015).</p>
</td></tr>
<tr><td><code id="intMsPGOcc_+3A_det.formula">det.formula</code></td>
<td>
<p>a list of symbolic descriptions of the models to be fit
for the detection portion of the model using R's model syntax for 
each data set. Each element in the list is a formula for the detection 
model of a given data set. Only right-hand side of formula is specified. 
Random effects are not currently supported. See example below.</p>
</td></tr>
<tr><td><code id="intMsPGOcc_+3A_data">data</code></td>
<td>
<p>a list containing data necessary for model fitting.
Valid tags are <code>y</code>, <code>occ.covs</code>, <code>det.covs</code>, <code>sites</code>,
and <code>species</code>. <code>y</code> is a list of three-dimensional arrays. Each 
element of the list has first dimension equal to the number of species
observed in that data source, second dimension equal to the number of 
sites observed in that data source, and thir dimension equal to the 
maximum number of replicates at a given site. 
<code>occ.covs</code> is a matrix or data frame containing the variables 
used in the occurrence portion of the model, with the number of rows
being the number of sites with at least one data source for each 
column (variable). <code>det.covs</code> is a list of variables included
in the detection portion of the model for each data source. <code>det.covs</code>
should have the same number of elements as <code>y</code>, where each element
is itself a list. Each element of the list for a given data source is a
different detection covariate, which can be site-level or observational-level.
Site-level covariates are specified as a vector with length equal to the
number of observed sites of that data source, while observational-level
covariates are specified as a matrix or data frame with the number of 
rows equal to the number of observed sites of that data source and number
of columns equal to the maximum number of replicates at a given site. <code>sites</code>
is a list of site indices with number of elements equal to the number of data sources being 
modeled. Each element contains a vector of length equal to the number of 
sites that specific data source contains. Each value in the vector indicates
the row in <code>occ.covs</code> that corresponds with the specific row of the 
detection-nondetection data for the data source. This is used to properly link sites across
data sets. <code>species</code> is a list with number of data sources being modeled. Each
element of the list is a vector of codes (these can be numeric or character) that
indicate the species modeled in the specific data set.</p>
</td></tr>
<tr><td><code id="intMsPGOcc_+3A_inits">inits</code></td>
<td>
<p>a list with each tag corresponding to a parameter name.
Valid tags are <code>alpha.comm</code>, <code>beta.comm</code>, <code>beta</code>, 
<code>alpha</code>, <code>tau.sq.beta</code>, <code>tau.sq.alpha</code>, <code>sigma.sq.psi</code>, 
and <code>z</code>. The value portion of each tag is the parameter's initial value. See 
<code>priors</code> description for definition of each parameter name.
Additionally, the tag <code>fix</code> can be set to <code>TRUE</code> 
to fix the starting values across all chains. If <code>fix</code> is not specified
(the default), starting values are varied randomly across chains.</p>
</td></tr>
<tr><td><code id="intMsPGOcc_+3A_priors">priors</code></td>
<td>
<p>a list with each tag corresponding to a parameter name. 
Valid tags are <code>beta.comm.normal</code>, <code>alpha.comm.normal</code>, 
<code>tau.sq.beta.ig</code>, <code>tau.sq.alpha.ig</code>, <code>sigma.sq.psi.ig</code>, and 
<code>sigma.sq.p.ig</code>. Community-level occurrence 
(<code>beta.comm</code>) regression coefficients are assumed to 
follow a normal distribution. The hyperparameters of the 
normal distribution are passed as a list of length two with the first
and second elements corresponding to the mean and variance of the normal
distribution, which are each specified as vectors of 
length equal to the number of coefficients to be estimated or of length one
if priors are the same for all coefficients. If not
specified, prior means are set to 0 and prior variances set to 2.72. For the 
community-level detection means (<code>alpha.comm</code>), the mean and variance
hyperparameters are themselves passed in as lists, with each element of the list
corresponding to the specific hyperparameters for the detection parameters in a 
given data source. If not specified, prior means are set to 0 and prior 
variances set to 2.72. Community-level variance parameters for occurrence (<code>tau.sq.beta</code>) and
detection (<code>tau.sq.alpha</code>) are assumed to follow an inverse Gamma 
distribution. For the occurrence parameters, the hyperparameters of the inverse gamma distribution are 
passed as a list of length two with the first and second elements 
corresponding to the shape and scale parameters, which are each specified
as vectors of length equal to the number of coefficients to be estimated 
or a single value if all parameters are assigned the same prior. 
If not specified, prior shape and scale parameters are set to 0.1. For the detection
community-level variance parameters (<code>tau.sq.alpha</code>), the shape and scale 
parameters are passed in as lists, with each element of the list corresponding 
to the specific hyperparameters for the detection variances in a given 
data source. <code>sigma.sq.psi</code> and are the random effect variances for any occurrence
random effects, respectively, and are assumed to follow an inverse
Gamma distribution. The hyperparameters of the inverse-Gamma distribution
are passed as a list of length two with first and second elements corresponding
to the shape and scale parameters, respectively, which are each specified as
vectors of length equal to the number of random intercepts or of length one 
if priors are the same for all random effect variances.</p>
</td></tr>
<tr><td><code id="intMsPGOcc_+3A_n.samples">n.samples</code></td>
<td>
<p>the number of posterior samples to collect in each chain.</p>
</td></tr>
<tr><td><code id="intMsPGOcc_+3A_n.omp.threads">n.omp.threads</code></td>
<td>
<p>a positive integer indicating the number of threads
to use for SMP parallel processing. The package must be compiled for 
OpenMP support. For most Intel-based machines, we recommend setting 
<code>n.omp.threads</code> up to the number of hypterthreaded cores. Note, 
<code>n.omp.threads</code> &gt; 1 might not work on some systems. Currently only 
relevant for spatial models.</p>
</td></tr>
<tr><td><code id="intMsPGOcc_+3A_verbose">verbose</code></td>
<td>
<p>if <code>TRUE</code>, messages about data preparation, 
model specification, and progress of the sampler are printed to the screen. 
Otherwise, no messages are printed.</p>
</td></tr>
<tr><td><code id="intMsPGOcc_+3A_n.report">n.report</code></td>
<td>
<p>the interval to report MCMC progress.</p>
</td></tr>
<tr><td><code id="intMsPGOcc_+3A_n.burn">n.burn</code></td>
<td>
<p>the number of samples out of the total <code>n.samples</code> to 
discard as burn-in for each chain. By default, the first 10% of samples is discarded.</p>
</td></tr>
<tr><td><code id="intMsPGOcc_+3A_n.thin">n.thin</code></td>
<td>
<p>the thinning interval for collection of MCMC samples. The
thinning occurs after the <code>n.burn</code> samples are discarded. Default 
value is set to 1.</p>
</td></tr>
<tr><td><code id="intMsPGOcc_+3A_n.chains">n.chains</code></td>
<td>
<p>the number of chains to run in sequence.</p>
</td></tr>
<tr><td><code id="intMsPGOcc_+3A_k.fold">k.fold</code></td>
<td>
<p>cross-validation is not currently supported for integrated 
multi-species occupancy models.</p>
</td></tr>
<tr><td><code id="intMsPGOcc_+3A_k.fold.threads">k.fold.threads</code></td>
<td>
<p>cross-validation is not currently supported for 
integrated multi-species occupancy models.</p>
</td></tr> 
<tr><td><code id="intMsPGOcc_+3A_k.fold.seed">k.fold.seed</code></td>
<td>
<p>cross-validation is not currently supported for integrated
multi-species occupancy models.</p>
</td></tr>
<tr><td><code id="intMsPGOcc_+3A_k.fold.only">k.fold.only</code></td>
<td>
<p>cross-validation is not currently supported for integrated
multi-species occupancy models.</p>
</td></tr> 
<tr><td><code id="intMsPGOcc_+3A_...">...</code></td>
<td>
<p>currently no additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>intMsPGOcc</code> that is a list comprised of: 
</p>
<table>
<tr><td><code>beta.comm.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the community level occurrence regression coefficients.</p>
</td></tr>
<tr><td><code>alpha.comm.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the community level detection regression coefficients for all 
data sources.</p>
</td></tr>
<tr><td><code>tau.sq.beta.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the occurrence community variance parameters.</p>
</td></tr>
<tr><td><code>tau.sq.alpha.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the detection community variance parameters for all data sources.</p>
</td></tr>
<tr><td><code>beta.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the species level occurrence regression coefficients.</p>
</td></tr>
<tr><td><code>alpha.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the species level detection regression coefficients for all 
data sources.</p>
</td></tr>
<tr><td><code>z.samples</code></td>
<td>
<p>a three-dimensional array of posterior samples for
the latent occurrence values for each species.</p>
</td></tr>
<tr><td><code>psi.samples</code></td>
<td>
<p>a three-dimensional array of posterior samples for
the latent occurrence probability values for each species.</p>
</td></tr>
<tr><td><code>sigma.sq.psi.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for variances of random intercepts included in the occurrence portion
of the model. Only included if random intercepts are specified in 
<code>occ.formula</code>.</p>
</td></tr>
<tr><td><code>beta.star.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the occurrence random effects. Only included if random intercepts
are specified in <code>occ.formula</code>.</p>
</td></tr>
<tr><td><code>like.samples</code></td>
<td>
<p>a three-dimensional array of posterior samples
for the likelihood value associated with each site and species. 
Used for calculating WAIC.</p>
</td></tr>
<tr><td><code>rhat</code></td>
<td>
<p>a list of Gelman-Rubin diagnostic values for some of the model
parameters.</p>
</td></tr>
<tr><td><code>ESS</code></td>
<td>
<p>a list of effective sample sizes for some of the model parameters.</p>
</td></tr>
<tr><td><code>run.time</code></td>
<td>
<p>MCMC sampler execution time reported using <code>proc.time()</code>.</p>
</td></tr>
</table>
<p>The return object will include additional objects used for 
subsequent prediction and/or model fit evaluation. 
</p>


<h3>Note</h3>

<p>Basic functionality of this function is stable, but some components are still in development and not currently available. Please create a GitHub issue on the package GitHub page if you use this function and encounter an error. 
</p>


<h3>Author(s)</h3>

<p>Jeffrey W. Doser <a href="mailto:doserjef@msu.edu">doserjef@msu.edu</a>, <br />
</p>


<h3>References</h3>

<p>Polson, N.G., J.G. Scott, and J. Windle. (2013) Bayesian Inference for
Logistic Models Using Polya-Gamma Latent Variables.
<em>Journal of the American Statistical Association</em>, 108:1339-1349.
</p>
<p>Bates, Douglas, Martin Maechler, Ben Bolker, Steve Walker (2015).
Fitting Linear Mixed-Effects Models Using lme4. Journal of
Statistical Software, 67(1), 1-48. <a href="https://doi.org/10.18637/jss.v067.i01">doi:10.18637/jss.v067.i01</a>.
</p>
<p>Dorazio, R. M., and Royle, J. A. (2005). Estimating size and composition 
of biological communities by modeling the occurrence of species. 
Journal of the American Statistical Association, 100(470), 389-398.
</p>
<p>Doser, J. W., Leuenberger, W., Sillett, T. S., Hallworth, M. T. 
&amp; Zipkin, E. F. (2022). Integrated community occupancy models: A framework 
to assess occurrence and biodiversity dynamics using multiple data 
sources. Methods in Ecology and Evolution, 00, 1-14. <a href="https://doi.org/10.1111/2041-210X.13811">doi:10.1111/2041-210X.13811</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(91)
J.x &lt;- 10
J.y &lt;- 10
# Total number of data sources across the study region
J.all &lt;- J.x * J.y
# Number of data sources.
n.data &lt;- 2
# Sites for each data source.
J.obs &lt;- sample(ceiling(0.2 * J.all):ceiling(0.5 * J.all), n.data, replace = TRUE)
n.rep &lt;- list()
n.rep[[1]] &lt;- rep(3, J.obs[1])
n.rep[[2]] &lt;- rep(4, J.obs[2])

# Number of species observed in each data source
N &lt;- c(8, 3)

# Community-level covariate effects
# Occurrence
beta.mean &lt;- c(0.2, 0.5)
p.occ &lt;- length(beta.mean)
tau.sq.beta &lt;- c(0.4, 0.3)
# Detection
# Detection covariates
alpha.mean &lt;- list()
tau.sq.alpha &lt;- list()
# Number of detection parameters in each data source
p.det.long &lt;- c(4, 3)
for (i in 1:n.data) {
  alpha.mean[[i]] &lt;- runif(p.det.long[i], -1, 1)
  tau.sq.alpha[[i]] &lt;- runif(p.det.long[i], 0.1, 1)
}
# Random effects
psi.RE &lt;- list()
p.RE &lt;- list()
beta &lt;- matrix(NA, nrow = max(N), ncol = p.occ)
for (i in 1:p.occ) {
  beta[, i] &lt;- rnorm(max(N), beta.mean[i], sqrt(tau.sq.beta[i]))
}
alpha &lt;- list()
for (i in 1:n.data) {
  alpha[[i]] &lt;- matrix(NA, nrow = N[i], ncol = p.det.long[i])
  for (t in 1:p.det.long[i]) {
    alpha[[i]][, t] &lt;- rnorm(N[i], alpha.mean[[i]][t], sqrt(tau.sq.alpha[[i]])[t])
  }
}
sp &lt;- FALSE
factor.model &lt;- FALSE
# Simulate occupancy data
dat &lt;- simIntMsOcc(n.data = n.data, J.x = J.x, J.y = J.y,
                   J.obs = J.obs, n.rep = n.rep, N = N, beta = beta, alpha = alpha,
                   psi.RE = psi.RE, p.RE = p.RE, sp = sp, factor.model = factor.model,
                   n.factors = n.factors)
J &lt;- nrow(dat$coords.obs)
y &lt;- dat$y
X &lt;- dat$X.obs
X.p &lt;- dat$X.p
X.re &lt;- dat$X.re.obs
X.p.re &lt;- dat$X.p.re
sites &lt;- dat$sites
species &lt;- dat$species

# Package all data into a list
occ.covs &lt;- cbind(X)
colnames(occ.covs) &lt;- c('int', 'occ.cov.1')
#colnames(occ.covs) &lt;- c('occ.cov')
det.covs &lt;- list()
# Add covariates one by one
det.covs[[1]] &lt;- list(det.cov.1.1 = X.p[[1]][, , 2], 
                      det.cov.1.2 = X.p[[1]][, , 3], 
                      det.cov.1.3 = X.p[[1]][, , 4])
det.covs[[2]] &lt;- list(det.cov.2.1 = X.p[[2]][, , 2], 
                      det.cov.2.2 = X.p[[2]][, , 3]) 

data.list &lt;- list(y = y, 
                  occ.covs = occ.covs, 
                  det.covs = det.covs, 
                  sites = sites, 
                  species = species)
# Take a look at the data.list structure for integrated multi-species
# occupancy models.
# Priors 
prior.list &lt;- list(beta.comm.normal = list(mean = 0,var = 2.73),
                   alpha.comm.normal = list(mean = list(0, 0),
                                            var = list(2.72, 2.72)), 
                   tau.sq.beta.ig = list(a = 0.1, b = 0.1), 
                   tau.sq.alpha.ig = list(a = list(0.1, 0.1), 
                                          b = list(0.1, 0.1)))
inits.list &lt;- list(alpha.comm = list(0, 0), 
                   beta.comm = 0, 
                   tau.sq.beta = 1, 
                   tau.sq.alpha = list(1, 1), 
                   alpha = list(a = matrix(rnorm(p.det.long[1] * N[1]), N[1], p.det.long[1]), 
                                b = matrix(rnorm(p.det.long[2] * N[2]), N[2], p.det.long[2])),
                   beta = 0)

# Fit the model. 
out &lt;- intMsPGOcc(occ.formula = ~ occ.cov.1,
                  det.formula = list(f.1 = ~ det.cov.1.1 + det.cov.1.2 + det.cov.1.3,
                                     f.2 = ~ det.cov.2.1 + det.cov.2.2),
                  inits = inits.list,
                  priors = prior.list,
                  data = data.list, 
                  n.samples = 100, 
                  n.omp.threads = 1, 
                  verbose = TRUE, 
                  n.report = 10, 
                  n.burn = 50, 
                  n.thin = 1, 
                  n.chains = 1) 
summary(out, level = 'community')
</code></pre>

<hr>
<h2 id='intPGOcc'>Function for Fitting Single-Species Integrated Occupancy Models Using Polya-Gamma Latent Variables</h2><span id='topic+intPGOcc'></span>

<h3>Description</h3>

<p>Function for fitting single-species integrated occupancy models using Polya-Gamma latent variables. Data integration is done using a joint likelihood framework, assuming distinct detection models for each data source that are each conditional on a single latent occurrence process. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>intPGOcc(occ.formula, det.formula, data, inits, priors, n.samples, 
         n.omp.threads = 1, verbose = TRUE, n.report = 1000, 
         n.burn = round(.10 * n.samples), n.thin = 1, n.chains = 1,
         k.fold, k.fold.threads = 1, k.fold.seed, 
         k.fold.data, k.fold.only = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="intPGOcc_+3A_occ.formula">occ.formula</code></td>
<td>
<p>a symbolic description of the model to be fit
for the occurrence portion of the model using R's model syntax. Only
right-hand side of formula is specified. See example below.</p>
</td></tr>
<tr><td><code id="intPGOcc_+3A_det.formula">det.formula</code></td>
<td>
<p>a list of symbolic descriptions of the models to be fit
for the detection portion of the model using R's model syntax for 
each data set. Each element in the list is a formula for the detection 
model of a given data set. Only right-hand side of formula is specified. 
See example below.</p>
</td></tr>
<tr><td><code id="intPGOcc_+3A_data">data</code></td>
<td>
<p>a list containing data necessary for model fitting.
Valid tags are <code>y</code>, <code>occ.covs</code>, <code>det.covs</code>, and <code>sites</code>. 
<code>y</code> is a list of matrices or data frames for each data set used in 
the integrated model. Each element of the list has first dimension equal 
to the number of sites with that data source and second dimension equal 
to the maximum number of replicates at a given site. <code>occ.covs</code> is 
a matrix or data frame containing the variables used in the occupancy 
portion of the model, with the number of rows being the number of sites 
with at least one data source for each column (variable). <code>det.covs</code> is a list of
variables included in the detection portion of the model for each data source. 
<code>det.covs</code> should have the same number of elements as <code>y</code>, where
each element is itself a list. Each element of the list for a given data
source is a different detection covariate, which can be site-level or 
observational-level. Site-level covariates are specified as a vector 
with length equal to the number of observed sites of that data source,
while observation-level covariates are specified as a matrix or data frame 
with the number of rows equal to the number of observed sites of that data source
and number of columns equal to the maximum number of replicates at a given site.</p>
</td></tr>
<tr><td><code id="intPGOcc_+3A_inits">inits</code></td>
<td>
<p>a list with each tag corresponding to a parameter name.
Valid tags are <code>z</code>, <code>beta</code>, and <code>alpha</code>. The value portion
of tags <code>z</code> and <code>beta</code> is the parameter's initial value. The tag
<code>alpha</code> is a list comprised of the initial values for the detection 
parameters for each data source. Each element of the list should be a vector of 
initial values for all detection parameters in the given data source or a single value
for each data source to assign all parameters for a given data source
the same initial value. See <code>priors</code> description for definition of 
each parameter name. Additionally, the tag <code>fix</code> can be set to <code>TRUE</code> 
to fix the starting values across all chains. If <code>fix</code> is not specified
(the default), starting values are varied randomly across chains.</p>
</td></tr>
<tr><td><code id="intPGOcc_+3A_priors">priors</code></td>
<td>
<p>a list with each tag corresponding to a parameter name. 
Valid tags are <code>beta.normal</code> and <code>alpha.normal</code>. Occurrence 
(<code>beta</code>) and detection (<code>alpha</code>) regression coefficients 
are assumed to follow a normal distribution. For <code>beta</code> hyperparameters of the 
normal distribution are passed as a list of length two with the first
and second elements corresponding to the mean and variance of the normal
distribution, which are each specified as vectors of 
length equal to the number of coefficients to be estimated or of 
length one if priors are the same for all coefficients. For 
the detection coefficients <code>alpha</code>, the mean and variance 
hyperparameters are themselves passed in as lists, with each element 
of the list corresponding to the specific hyperparameters for the 
detection parameters in a given data source. If not specified, prior means 
are set to 0 and prior variances set to 2.72.</p>
</td></tr>
<tr><td><code id="intPGOcc_+3A_n.samples">n.samples</code></td>
<td>
<p>the number of posterior samples to collect in each chain.</p>
</td></tr>
<tr><td><code id="intPGOcc_+3A_n.omp.threads">n.omp.threads</code></td>
<td>
<p>a positive integer indicating the number of threads
to use for SMP parallel processing. The package must be compiled for 
OpenMP support. For most Intel-based machines, we recommend setting 
<code>n.omp.threads</code> up to the number of hypterthreaded cores. Note, 
<code>n.omp.threads</code> &gt; 1 might not work on some systems.</p>
</td></tr>
<tr><td><code id="intPGOcc_+3A_verbose">verbose</code></td>
<td>
<p>if <code>TRUE</code>, messages about data preparation, 
model specification, and progress of the sampler are printed to the screen. 
Otherwise, no messages are printed.</p>
</td></tr>
<tr><td><code id="intPGOcc_+3A_n.report">n.report</code></td>
<td>
<p>the interval to report MCMC progress.</p>
</td></tr>
<tr><td><code id="intPGOcc_+3A_n.burn">n.burn</code></td>
<td>
<p>the number of samples out of the total <code>n.samples</code> to 
discard as burn-in. By default, the first 10% of samples is discarded.</p>
</td></tr>
<tr><td><code id="intPGOcc_+3A_n.thin">n.thin</code></td>
<td>
<p>the thinning interval for collection of MCMC samples. The
thinning occurs after the <code>n.burn</code> samples are discarded. Default 
value is set to 1.</p>
</td></tr>
<tr><td><code id="intPGOcc_+3A_n.chains">n.chains</code></td>
<td>
<p>the number of chains to run in sequence.</p>
</td></tr>
<tr><td><code id="intPGOcc_+3A_k.fold">k.fold</code></td>
<td>
<p>specifies the number of <em>k</em> folds for cross-validation.
If not specified as an argument, then cross-validation is not performed
and <code>k.fold.threads</code> and <code>k.fold.seed</code> are ignored. In <em>k</em>-fold
cross-validation, the data specified in <code>data</code> is randomly
partitioned into <em>k</em> equal sized subsamples. Of the <em>k</em> subsamples,
<em>k</em> - 1 subsamples are used to fit the model and the remaining <em>k</em>
samples are used for prediction. The cross-validation process is repeated
<em>k</em> times (the folds). As a scoring rule, we use the model deviance
as described in Hooten and Hobbs (2015). Cross-validation is performed
after the full model is fit using all the data. Cross-validation results
are reported in the <code>k.fold.deviance</code> object in the return list.</p>
</td></tr>
<tr><td><code id="intPGOcc_+3A_k.fold.threads">k.fold.threads</code></td>
<td>
<p>number of threads to use for cross-validation. If
<code>k.fold.threads &gt; 1</code> parallel processing is accomplished using the
<span class="pkg">foreach</span> and <span class="pkg">doParallel</span> packages. Ignored if <code>k.fold</code>
is not specified.</p>
</td></tr>
<tr><td><code id="intPGOcc_+3A_k.fold.seed">k.fold.seed</code></td>
<td>
<p>seed used to split data set into <code>k.fold</code> parts
for k-fold cross-validation. Ignored if <code>k.fold</code> is not specified.</p>
</td></tr>
<tr><td><code id="intPGOcc_+3A_k.fold.data">k.fold.data</code></td>
<td>
<p>an integer specifying the specific data set to hold out
values from. If not specified, data from all data set locations will 
be incorporated into the k-fold cross-validation.</p>
</td></tr>
<tr><td><code id="intPGOcc_+3A_k.fold.only">k.fold.only</code></td>
<td>
<p>a logical value indicating whether to only perform 
cross-validation (<code>TRUE</code>) or perform cross-validation after fitting 
the full model (<code>FALSE</code>). Default value is <code>FALSE</code>.</p>
</td></tr> 
<tr><td><code id="intPGOcc_+3A_...">...</code></td>
<td>
<p>currently no additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>intPGOcc</code> that is a list comprised of: 
</p>
<table>
<tr><td><code>beta.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the occupancy regression coefficients.</p>
</td></tr>
<tr><td><code>alpha.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the detection regression coefficients for all data sources.</p>
</td></tr>
<tr><td><code>z.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples 
for the latent occupancy values</p>
</td></tr>
<tr><td><code>psi.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the latent occupancy probability values</p>
</td></tr>
<tr><td><code>rhat</code></td>
<td>
<p>a list of Gelman-Rubin diagnostic values for some of the model
parameters.</p>
</td></tr>
<tr><td><code>ESS</code></td>
<td>
<p>a list of effective sample sizes for some of the model parameters.</p>
</td></tr>
<tr><td><code>run.time</code></td>
<td>
<p>execution time reported using <code>proc.time()</code>.</p>
</td></tr>
<tr><td><code>k.fold.deviance</code></td>
<td>
<p>scoring rule (deviance) from k-fold cross-validation. A 
separate deviance value is returned for each data source. Only included if 
<code>k.fold</code> is specified in function call. Only a single value is returned
if <code>k.fold.data</code> is specified.</p>
</td></tr>
</table>
<p>The return object will include additional objects used for 
subsequent prediction and/or model fit evaluation. Note that detection
probability estimated values are not included in the model object, but can be 
extracted using <code>fitted()</code>.
</p>


<h3>Note</h3>

<p>Some of the underlying code used for generating random numbers from the
Polya-Gamma distribution is taken from the <span class="pkg">pgdraw</span> package written
by Daniel F. Schmidt and Enes Makalic. Their code implements Algorithm
6 in PhD thesis of Jesse Bennett Windle (2013) <a href="https://repositories.lib.utexas.edu/handle/2152/21842">https://repositories.lib.utexas.edu/handle/2152/21842</a>.
</p>


<h3>Author(s)</h3>

<p>Jeffrey W. Doser <a href="mailto:doserjef@msu.edu">doserjef@msu.edu</a>, <br />
Andrew O. Finley <a href="mailto:finleya@msu.edu">finleya@msu.edu</a>
</p>


<h3>References</h3>

<p>Polson, N.G., J.G. Scott, and J. Windle. (2013) Bayesian Inference for
Logistic Models Using Polya-Gamma Latent Variables. 
<em>Journal of the American Statistical Association</em>, 108:1339-1349.
</p>
<p>Hooten, M. B., and Hobbs, N. T. (2015). A guide to Bayesian model 
selection for ecologists. Ecological monographs, 85(1), 3-28.
</p>
<p>Finley, A. O., Datta, A., and Banerjee, S. (2020). spNNGP R 
package for nearest neighbor Gaussian process models. 
arXiv preprint arXiv:2001.09111.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1008)

# Simulate Data -----------------------------------------------------------
J.x &lt;- 15
J.y &lt;- 15
J.all &lt;- J.x * J.y
# Number of data sources.
n.data &lt;- 4
# Sites for each data source. 
J.obs &lt;- sample(ceiling(0.2 * J.all):ceiling(0.5 * J.all), n.data, replace = TRUE)
# Replicates for each data source.
n.rep &lt;- list()
for (i in 1:n.data) {
  n.rep[[i]] &lt;- sample(1:4, size = J.obs[i], replace = TRUE)
}
# Occupancy covariates
beta &lt;- c(0.5, 1)
p.occ &lt;- length(beta)
# Detection covariates
alpha &lt;- list()
for (i in 1:n.data) {
  alpha[[i]] &lt;- runif(2, -1, 1)
}
p.det.long &lt;- sapply(alpha, length)
p.det &lt;- sum(p.det.long)

# Simulate occupancy data. 
dat &lt;- simIntOcc(n.data = n.data, J.x = J.x, J.y = J.y, J.obs = J.obs, 
                 n.rep = n.rep, beta = beta, alpha = alpha, sp = FALSE)

y &lt;- dat$y
X &lt;- dat$X.obs
X.p &lt;- dat$X.p
sites &lt;- dat$sites

# Package all data into a list
occ.covs &lt;- X[, 2, drop = FALSE]
colnames(occ.covs) &lt;- c('occ.cov')
det.covs &lt;- list()
# Add covariates one by one
det.covs[[1]] &lt;- list(det.cov.1.1 = X.p[[1]][, , 2]) 
det.covs[[2]] &lt;- list(det.cov.2.1 = X.p[[2]][, , 2]) 
det.covs[[3]] &lt;- list(det.cov.3.1 = X.p[[3]][, , 2]) 
det.covs[[4]] &lt;- list(det.cov.4.1 = X.p[[4]][, , 2]) 
data.list &lt;- list(y = y, 
                  occ.covs = occ.covs,
                  det.covs = det.covs, 
                  sites = sites)

J &lt;- length(dat$z.obs)
# Initial values
inits.list &lt;- list(alpha = list(0, 0, 0, 0), 
                   beta = 0, 
                   z = rep(1, J))
# Priors
prior.list &lt;- list(beta.normal = list(mean = 0, var = 2.72), 
                   alpha.normal = list(mean = list(0, 0, 0, 0), 
                                       var = list(2.72, 2.72, 2.72, 2.72)))
n.samples &lt;- 5000
out &lt;- intPGOcc(occ.formula = ~ occ.cov, 
                det.formula = list(f.1 = ~ det.cov.1.1, 
                                   f.2 = ~ det.cov.2.1, 
                                   f.3 = ~ det.cov.3.1, 
                                   f.4 = ~ det.cov.4.1), 
                data = data.list,
                inits = inits.list,
                n.samples = n.samples, 
                priors = prior.list, 
                n.omp.threads = 1, 
                verbose = TRUE, 
                n.report = 1000, 
                n.burn = 1000, 
                n.thin = 1, 
                n.chains = 1)

summary(out)
</code></pre>

<hr>
<h2 id='lfJSDM'>Function for Fitting a Latent Factor Joint Species Distribution Model</h2><span id='topic+lfJSDM'></span>

<h3>Description</h3>

<p>Function for fitting a joint species distribution model with species correlations. This model does not explicitly account for imperfect detection (see <code>lfMsPGOcc()</code>). We use Polya-gamma latent variables and a factor modeling approach.</p>


<h3>Usage</h3>

<pre><code class='language-R'>lfJSDM(formula, data, inits, priors, n.factors, 
       n.samples, n.omp.threads = 1, verbose = TRUE, n.report = 100, 
       n.burn = round(.10 * n.samples), n.thin = 1, n.chains = 1,
       k.fold, k.fold.threads = 1, k.fold.seed, k.fold.only = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lfJSDM_+3A_formula">formula</code></td>
<td>
<p>a symbolic description of the model to be fit
for the model using R's model syntax. Only right-hand side of formula 
is specified. See example below. Random intercepts are allowed 
using <span class="pkg">lme4</span> syntax (Bates et al. 2015).</p>
</td></tr>
<tr><td><code id="lfJSDM_+3A_data">data</code></td>
<td>
<p>a list containing data necessary for model fitting.
Valid tags are <code>y</code>, <code>covs</code>, and <code>coords</code>. <code>y</code>
is a two-dimensional array with first dimension equal to the number 
of species and second dimension equal to the number of sites. Note how this differs
from other <code>spOccupancy</code> functions in that <code>y</code> does not have any 
replicate surveys. This is because <code>lfJSDM</code> does not account for imperfect
detection. <code>covs</code> is a matrix or data frame containing the variables 
used in the model, with <code class="reqn">J</code> rows for 
each column (variable). <code>coords</code> is a matrix with <code class="reqn">J</code> 
rows and 2 columns consisting of the spatial coordinates of each site in 
the data. Note that <code>spOccupancy</code> assumes coordinates are specified 
in a projected coordinate system.</p>
</td></tr>
<tr><td><code id="lfJSDM_+3A_inits">inits</code></td>
<td>
<p>a list with each tag corresponding to a parameter name.
Valid tags are <code>beta.comm</code>, <code>beta</code>, <code>tau.sq.beta</code>, <code>sigma.sq.psi</code>,
<code>lambda</code>. The value portion of each tag is the parameter's initial value. See 
<code>priors</code> description for definition of each parameter name.
Additionally, the tag <code>fix</code> can be set to <code>TRUE</code> 
to fix the starting values across all chains. If <code>fix</code> is not specified
(the default), starting values are varied randomly across chains.</p>
</td></tr>
<tr><td><code id="lfJSDM_+3A_priors">priors</code></td>
<td>
<p>a list with each tag corresponding to a parameter name. 
Valid tags are <code>beta.comm.normal</code>, <code>tau.sq.beta.ig</code>, and 
<code>sigma.sq.psi.ig</code>. Community-level (<code>beta.comm</code>) regression coefficients 
are assumed to follow a normal distribution. The hyperparameters of the 
normal distribution are passed as a list of length two with the first
and second elements corresponding to the mean and variance of the normal
distribution, which are each specified as vectors of 
length equal to the number of coefficients to be estimated or of length one
if priors are the same for all coefficients. If not
specified, prior means are set to 0 and prior variances set to 2.72. 
Community-level variance parameters (<code>tau.sq.beta</code>)
are assumed to follow an inverse Gamma distribution. 
The hyperparameters of the inverse gamma distribution are 
passed as a list of length two with the first and second elements 
corresponding to the shape and scale parameters, which are each specified
as vectors of length equal to the number of coefficients to be estimated 
or a single value if all parameters are assigned the same prior. 
If not specified, prior shape and scale parameters are set to 0.1. The 
factor model fits <code>n.factors</code> independent latent factors. The priors for the 
factor loadings matrix <code>lambda</code> are fixed following standard approaches to 
ensure parameter identifiability. The upper triangular elements of the <code>N x n.factors</code> 
matrix are fixed at 0 and the diagonal elements are fixed at 1. The lower 
triangular elements are assigned a standard normal prior (i.e., mean 0 and variance 1). 
<code>sigma.sq.psi</code> is the random effect variance for any random effects, and is assumed
to follow an inverse Gamma distribution. The hyperparameters of the inverse-Gamma distribution
are passed as a list of length two with first and second elements corresponding to the shape
and scale parameters, respectively, which are each specified as vectors of length equal to 
the number of random intercepts or of length one if priors are the same for all random 
effect variances.</p>
</td></tr>
<tr><td><code id="lfJSDM_+3A_n.factors">n.factors</code></td>
<td>
<p>the number of factors to use in the latent factor model approach.
Typically, the number of factors is set to be small (e.g., 4-5) relative to the
total number of species in the community, which will lead to substantial
decreases in computation time. However, the value can be anywhere
between 0 and N (the number of species in the community). When set to 0, the model
assumes there are no residual species correlations, which is equivalent to the 
<code>msPGOcc()</code> function but without imperfect detection.</p>
</td></tr>
<tr><td><code id="lfJSDM_+3A_n.samples">n.samples</code></td>
<td>
<p>the number of posterior samples to collect in each chain.</p>
</td></tr>
<tr><td><code id="lfJSDM_+3A_n.omp.threads">n.omp.threads</code></td>
<td>
<p>a positive integer indicating the number of threads
to use for SMP parallel processing. The package must be compiled for 
OpenMP support. For most Intel-based machines, we recommend setting 
<code>n.omp.threads</code> up to the number of hypterthreaded cores. Note, 
<code>n.omp.threads</code> &gt; 1 might not work on some systems.</p>
</td></tr>
<tr><td><code id="lfJSDM_+3A_verbose">verbose</code></td>
<td>
<p>if <code>TRUE</code>, messages about data preparation, 
model specification, and progress of the sampler are printed to the screen. 
Otherwise, no messages are printed.</p>
</td></tr>
<tr><td><code id="lfJSDM_+3A_n.report">n.report</code></td>
<td>
<p>the interval to report MCMC progress.</p>
</td></tr>
<tr><td><code id="lfJSDM_+3A_n.burn">n.burn</code></td>
<td>
<p>the number of samples out of the total <code>n.samples</code> to 
discard as burn-in for each chain. By default, the first 10% of samples is discarded.</p>
</td></tr>
<tr><td><code id="lfJSDM_+3A_n.thin">n.thin</code></td>
<td>
<p>the thinning interval for collection of MCMC samples. The
thinning occurs after the <code>n.burn</code> samples are discarded. Default 
value is set to 1.</p>
</td></tr>
<tr><td><code id="lfJSDM_+3A_n.chains">n.chains</code></td>
<td>
<p>the number of chains to run in sequence.</p>
</td></tr>
<tr><td><code id="lfJSDM_+3A_k.fold">k.fold</code></td>
<td>
<p>specifies the number of <em>k</em> folds for cross-validation. 
If not specified as an argument, then cross-validation is not performed
and <code>k.fold.threads</code> and <code>k.fold.seed</code> are ignored. In <em>k</em>-fold
cross-validation, the data specified in <code>data</code> is randomly
partitioned into <em>k</em> equal sized subsamples. Of the <em>k</em> subsamples, 
<em>k</em> - 1 subsamples are used to fit the model and the remaining <em>k</em>
samples are used for prediction. The cross-validation process is repeated 
<em>k</em> times (the folds). As a scoring rule, we use the model deviance 
as described in Hooten and Hobbs (2015). Cross-validation is performed
after the full model is fit using all the data. Cross-validation results
are reported in the <code>k.fold.deviance</code> object in the return list.</p>
</td></tr>
<tr><td><code id="lfJSDM_+3A_k.fold.threads">k.fold.threads</code></td>
<td>
<p>number of threads to use for cross-validation. If 
<code>k.fold.threads &gt; 1</code> parallel processing is accomplished using the 
<span class="pkg">foreach</span> and <span class="pkg">doParallel</span> packages. Ignored if <code>k.fold</code>
is not specified.</p>
</td></tr> 
<tr><td><code id="lfJSDM_+3A_k.fold.seed">k.fold.seed</code></td>
<td>
<p>seed used to split data set into <code>k.fold</code> parts
for k-fold cross-validation. Ignored if <code>k.fold</code> is not specified.</p>
</td></tr>
<tr><td><code id="lfJSDM_+3A_k.fold.only">k.fold.only</code></td>
<td>
<p>a logical value indicating whether to only perform 
cross-validation (<code>TRUE</code>) or perform cross-validation after fitting 
the full model (<code>FALSE</code>). Default value is <code>FALSE</code>.</p>
</td></tr> 
<tr><td><code id="lfJSDM_+3A_...">...</code></td>
<td>
<p>currently no additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>lfJSDM</code> that is a list comprised of: 
</p>
<table>
<tr><td><code>beta.comm.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the community level occurrence regression coefficients.</p>
</td></tr>
<tr><td><code>tau.sq.beta.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the occurrence community variance parameters.</p>
</td></tr>
<tr><td><code>beta.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the species level occurrence regression coefficients.</p>
</td></tr>
<tr><td><code>lambda.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the latent factor loadings.</p>
</td></tr>
<tr><td><code>psi.samples</code></td>
<td>
<p>a three-dimensional array of posterior samples for
the latent probability of occurrence/detection values for each species.</p>
</td></tr>
<tr><td><code>sigma.sq.psi.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for variances of random intercepts included in the occurrence portion
of the model. Only included if random intercepts are specified in 
<code>occ.formula</code>.</p>
</td></tr>
<tr><td><code>w.samples</code></td>
<td>
<p>a three-dimensional array of posterior samples for 
the latent effects for each latent factor.</p>
</td></tr>
<tr><td><code>beta.star.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the occurrence random effects. Only included if random intercepts
are specified in <code>occ.formula</code>.</p>
</td></tr>
<tr><td><code>like.samples</code></td>
<td>
<p>a three-dimensional array of posterior samples
for the likelihood value associated with each site and species. 
Used for calculating WAIC.</p>
</td></tr>
<tr><td><code>rhat</code></td>
<td>
<p>a list of Gelman-Rubin diagnostic values for some of the model
parameters.</p>
</td></tr>
<tr><td><code>ESS</code></td>
<td>
<p>a list of effective sample sizes for some of the model parameters.</p>
</td></tr>
<tr><td><code>run.time</code></td>
<td>
<p>MCMC sampler execution time reported using <code>proc.time()</code>.</p>
</td></tr>
<tr><td><code>k.fold.deviance</code></td>
<td>
<p>vector of scoring rules (deviance) from k-fold cross-validation. 
A separate value is reported for each species. 
Only included if <code>k.fold</code> is specified in function call.</p>
</td></tr>
</table>
<p>The return object will include additional objects used for 
subsequent prediction and/or model fit evaluation. Note that detection probability
estimated values are not included in the model object, but can be extracted
using <code>fitted()</code>. 
</p>


<h3>Note</h3>

<p>Some of the underlying code used for generating random numbers from the
Polya-Gamma distribution is taken from the <span class="pkg">pgdraw</span> package written
by Daniel F. Schmidt and Enes Makalic. Their code implements Algorithm
6 in PhD thesis of Jesse Bennett Windle (2013) <a href="https://repositories.lib.utexas.edu/handle/2152/21842">https://repositories.lib.utexas.edu/handle/2152/21842</a>.
</p>


<h3>Author(s)</h3>

<p>Jeffrey W. Doser <a href="mailto:doserjef@msu.edu">doserjef@msu.edu</a>, <br />
Andrew O. Finley <a href="mailto:finleya@msu.edu">finleya@msu.edu</a>
</p>


<h3>References</h3>

<p>Polson, N.G., J.G. Scott, and J. Windle. (2013) Bayesian Inference for
Logistic Models Using Polya-Gamma Latent Variables.
<em>Journal of the American Statistical Association</em>, 108:1339-1349.
</p>
<p>Bates, Douglas, Martin Maechler, Ben Bolker, Steve Walker (2015).
Fitting Linear Mixed-Effects Models Using lme4. Journal of
Statistical Software, 67(1), 1-48. <a href="https://doi.org/10.18637/jss.v067.i01">doi:10.18637/jss.v067.i01</a>.
</p>
<p>Hooten, M. B., and Hobbs, N. T. (2015). A guide to Bayesian model 
selection for ecologists. Ecological monographs, 85(1), 3-28.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(400)
J.x &lt;- 10
J.y &lt;- 10
J &lt;- J.x * J.y
n.rep &lt;- rep(1, J)
N &lt;- 10
# Community-level covariate effects
# Occurrence
beta.mean &lt;- c(0.2, 0.6, 1.5)
p.occ &lt;- length(beta.mean)
tau.sq.beta &lt;- c(0.6, 1.2, 1.7)
# Detection
# Fix this to be constant and really close to 1. 
alpha.mean &lt;- c(9)
tau.sq.alpha &lt;- c(0.05)
p.det &lt;- length(alpha.mean)
# Random effects
# Include a single random effect
psi.RE &lt;- list(levels = c(20), 
               sigma.sq.psi = c(2))
p.RE &lt;- list()
# Draw species-level effects from community means.
beta &lt;- matrix(NA, nrow = N, ncol = p.occ)
alpha &lt;- matrix(NA, nrow = N, ncol = p.det)
for (i in 1:p.occ) {
  beta[, i] &lt;- rnorm(N, beta.mean[i], sqrt(tau.sq.beta[i]))
}
for (i in 1:p.det) {
  alpha[, i] &lt;- rnorm(N, alpha.mean[i], sqrt(tau.sq.alpha[i]))
}
alpha.true &lt;- alpha
# Factor model
factor.model &lt;- TRUE
n.factors &lt;- 4

dat &lt;- simMsOcc(J.x = J.x, J.y = J.y, n.rep = n.rep, N = N, beta = beta, alpha = alpha,
                psi.RE = psi.RE, p.RE = p.RE, sp = FALSE,
                factor.model = TRUE, n.factors = 4)

X &lt;- dat$X
y &lt;- dat$y
X.re &lt;- dat$X.re
coords &lt;- dat$coords
occ.covs &lt;- cbind(X, X.re)
colnames(occ.covs) &lt;- c('int', 'occ.cov.1', 'occ.cov.2', 'occ.re.1')
data.list &lt;- list(y = y[, , 1], 
                  covs = occ.covs, 
                  coords = coords) 
# Priors
prior.list &lt;- list(beta.comm.normal = list(mean = 0, var = 2.72),
                   tau.sq.beta.ig = list(a = 0.1, b = 0.1)) 
inits.list &lt;- list(beta.comm = 0, beta = 0, tau.sq.beta = 1) 
out &lt;- lfJSDM(formula = ~ occ.cov.1 + occ.cov.2 + (1 | occ.re.1), 
              data = data.list, 
              inits = inits.list, 
              priors = prior.list, 
              n.factors = 4, 
              n.samples = 1000,
              n.report = 500, 
              n.burn = 500,
              n.thin = 2,
              n.chains = 1) 
summary(out)
</code></pre>

<hr>
<h2 id='lfMsPGOcc'>Function for Fitting Latent Factor Multi-Species Occupancy Models</h2><span id='topic+lfMsPGOcc'></span>

<h3>Description</h3>

<p>Function for fitting multi-species occupancy models with species correlations (i.e., a joint species distribution model with imperfect detection). We use Polya-gamma latent variables and a factor modeling approach for dimension reduction.</p>


<h3>Usage</h3>

<pre><code class='language-R'>lfMsPGOcc(occ.formula, det.formula, data, inits, priors, n.factors, 
          n.samples, n.omp.threads = 1, verbose = TRUE, n.report = 100, 
          n.burn = round(.10 * n.samples), n.thin = 1, n.chains = 1,
          k.fold, k.fold.threads = 1, k.fold.seed, k.fold.only = FALSE, ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lfMsPGOcc_+3A_occ.formula">occ.formula</code></td>
<td>
<p>a symbolic description of the model to be fit
for the occurrence portion of the model using R's model syntax. Only
right-hand side of formula is specified. See example below. Random 
intercepts are allowed using <span class="pkg">lme4</span> syntax (Bates et al. 2015).</p>
</td></tr>
<tr><td><code id="lfMsPGOcc_+3A_det.formula">det.formula</code></td>
<td>
<p>a symbolic description of the model to be fit
for the detection portion of the model using R's model syntax. Only
right-hand side of formula is specified. See example below. Random 
intercepts are allowed using <span class="pkg">lme4</span> syntax (Bates et al. 2015).</p>
</td></tr>
<tr><td><code id="lfMsPGOcc_+3A_data">data</code></td>
<td>
<p>a list containing data necessary for model fitting.
Valid tags are <code>y</code>, <code>occ.covs</code>, <code>det.covs</code>, and <code>coords</code>. <code>y</code>
is a three-dimensional array with first dimension equal to the number 
of species, second dimension equal to the number of sites, and third 
dimension equal to the maximum number of replicates at a given site. 
<code>occ.covs</code> is a matrix or data frame containing the variables 
used in the occurrence portion of the model, with <code class="reqn">J</code> rows for 
each column (variable). <code>det.covs</code> is a list of variables included 
in the detection portion of the model. Each list element is a different 
detection covariate, which can be site-level or observational-level. 
Site-level covariates are specified as a vector of length <code class="reqn">J</code> while 
observation-level covariates are specified as a matrix or data frame 
with the number of rows equal to <code class="reqn">J</code> and number of columns equal 
to the maximum number of replicates at a given site. <code>coords</code> is a matrix
or data frame with two columns that contain the spatial coordinates of each 
site. Note that <code>spOccupancy</code> assumes coordinates are specified 
in a projected coordinate system.</p>
</td></tr>
<tr><td><code id="lfMsPGOcc_+3A_inits">inits</code></td>
<td>
<p>a list with each tag corresponding to a parameter name.
Valid tags are <code>alpha.comm</code>, <code>beta.comm</code>, <code>beta</code>, 
<code>alpha</code>, <code>tau.sq.beta</code>, <code>tau.sq.alpha</code>, <code>lambda</code>, 
<code>sigma.sq.psi</code>, <code>sigma.sq.p</code>, <code>z</code>. 
The value portion of each tag is the parameter's initial value. See 
<code>priors</code> description for definition of each parameter name.
Additionally, the tag <code>fix</code> can be set to <code>TRUE</code> 
to fix the starting values across all chains. If <code>fix</code> is not specified
(the default), starting values are varied randomly across chains.</p>
</td></tr>
<tr><td><code id="lfMsPGOcc_+3A_priors">priors</code></td>
<td>
<p>a list with each tag corresponding to a parameter name. 
Valid tags are <code>beta.comm.normal</code>, <code>alpha.comm.normal</code>, 
<code>tau.sq.beta.ig</code>, <code>tau.sq.alpha.ig</code>, <code>sigma.sq.psi.ig</code>, and 
<code>sigma.sq.p.ig</code>. Community-level occurrence 
(<code>beta.comm</code>) and detection (<code>alpha.comm</code>) regression coefficients 
are assumed to follow a normal distribution. The hyperparameters of the 
normal distribution are passed as a list of length two with the first
and second elements corresponding to the mean and variance of the normal
distribution, which are each specified as vectors of 
length equal to the number of coefficients to be estimated or of length one
if priors are the same for all coefficients. If not
specified, prior means are set to 0 and prior variances set to 2.72. 
Community-level variance parameters for occurrence (<code>tau.sq.beta</code>) and
detection (<code>tau.sq.alpha</code>) are assumed to follow an inverse Gamma 
distribution. The hyperparameters of the inverse gamma distribution are 
passed as a list of length two with the first and second elements 
corresponding to the shape and scale parameters, which are each specified
as vectors of length equal to the number of coefficients to be estimated 
or a single value if all parameters are assigned the same prior. 
If not specified, prior shape and scale parameters are set to 0.1. The 
factor model fits <code>n.factors</code> independent latent factors. The priors for the 
factor loadings matrix <code>lambda</code> are fixed following standard approaches to 
ensure parameter identifiability. The upper triangular elements of the <code>N x n.factors</code> 
matrix are fixed at 0 and the diagonal elements are fixed at 1. The lower 
triangular elements are assigned a standard normal prior (i.e., mean 0 and variance 1). 
<code>sigma.sq.psi</code> and <code>sigma.sq.p</code> are the random 
effect variances for any occurrence or
detection random effects, respectively, and are assumed to follow an inverse
Gamma distribution. The hyperparameters of the inverse-Gamma distribution
are passed as a list of length two with first and second elements corresponding
to the shape and scale parameters, respectively, which are each specified as
vectors of length equal to the number of random intercepts or of length one 
if priors are the same for all random effect variances.</p>
</td></tr>
<tr><td><code id="lfMsPGOcc_+3A_n.factors">n.factors</code></td>
<td>
<p>the number of factors to use in the latent factor model approach.
Typically, the number of factors is set to be small (e.g., 4-5) relative to the
total number of species in the community, which will lead to substantial
decreases in computation time. However, the value can be anywhere
between 1 and N (the number of species in the community).</p>
</td></tr>
<tr><td><code id="lfMsPGOcc_+3A_n.samples">n.samples</code></td>
<td>
<p>the number of posterior samples to collect in each chain.</p>
</td></tr>
<tr><td><code id="lfMsPGOcc_+3A_n.omp.threads">n.omp.threads</code></td>
<td>
<p>a positive integer indicating the number of threads
to use for SMP parallel processing. The package must be compiled for 
OpenMP support. For most Intel-based machines, we recommend setting 
<code>n.omp.threads</code> up to the number of hypterthreaded cores. Note, 
<code>n.omp.threads</code> &gt; 1 might not work on some systems.</p>
</td></tr>
<tr><td><code id="lfMsPGOcc_+3A_verbose">verbose</code></td>
<td>
<p>if <code>TRUE</code>, messages about data preparation, 
model specification, and progress of the sampler are printed to the screen. 
Otherwise, no messages are printed.</p>
</td></tr>
<tr><td><code id="lfMsPGOcc_+3A_n.report">n.report</code></td>
<td>
<p>the interval to report MCMC progress.</p>
</td></tr>
<tr><td><code id="lfMsPGOcc_+3A_n.burn">n.burn</code></td>
<td>
<p>the number of samples out of the total <code>n.samples</code> to 
discard as burn-in for each chain. By default, the first 10% of samples is discarded.</p>
</td></tr>
<tr><td><code id="lfMsPGOcc_+3A_n.thin">n.thin</code></td>
<td>
<p>the thinning interval for collection of MCMC samples. The
thinning occurs after the <code>n.burn</code> samples are discarded. Default 
value is set to 1.</p>
</td></tr>
<tr><td><code id="lfMsPGOcc_+3A_n.chains">n.chains</code></td>
<td>
<p>the number of chains to run in sequence.</p>
</td></tr>
<tr><td><code id="lfMsPGOcc_+3A_k.fold">k.fold</code></td>
<td>
<p>specifies the number of <em>k</em> folds for cross-validation. 
If not specified as an argument, then cross-validation is not performed
and <code>k.fold.threads</code> and <code>k.fold.seed</code> are ignored. In <em>k</em>-fold
cross-validation, the data specified in <code>data</code> is randomly
partitioned into <em>k</em> equal sized subsamples. Of the <em>k</em> subsamples, 
<em>k</em> - 1 subsamples are used to fit the model and the remaining <em>k</em>
samples are used for prediction. The cross-validation process is repeated 
<em>k</em> times (the folds). As a scoring rule, we use the model deviance 
as described in Hooten and Hobbs (2015). Cross-validation is performed
after the full model is fit using all the data. Cross-validation results
are reported in the <code>k.fold.deviance</code> object in the return list.</p>
</td></tr>
<tr><td><code id="lfMsPGOcc_+3A_k.fold.threads">k.fold.threads</code></td>
<td>
<p>number of threads to use for cross-validation. If 
<code>k.fold.threads &gt; 1</code> parallel processing is accomplished using the 
<span class="pkg">foreach</span> and <span class="pkg">doParallel</span> packages. Ignored if <code>k.fold</code>
is not specified.</p>
</td></tr> 
<tr><td><code id="lfMsPGOcc_+3A_k.fold.seed">k.fold.seed</code></td>
<td>
<p>seed used to split data set into <code>k.fold</code> parts
for k-fold cross-validation. Ignored if <code>k.fold</code> is not specified.</p>
</td></tr>
<tr><td><code id="lfMsPGOcc_+3A_k.fold.only">k.fold.only</code></td>
<td>
<p>a logical value indicating whether to only perform 
cross-validation (<code>TRUE</code>) or perform cross-validation after fitting 
the full model (<code>FALSE</code>). Default value is <code>FALSE</code>.</p>
</td></tr> 
<tr><td><code id="lfMsPGOcc_+3A_...">...</code></td>
<td>
<p>currently no additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>lfMsPGOcc</code> that is a list comprised of: 
</p>
<table>
<tr><td><code>beta.comm.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the community level occurrence regression coefficients.</p>
</td></tr>
<tr><td><code>alpha.comm.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the community level detection regression coefficients.</p>
</td></tr>
<tr><td><code>tau.sq.beta.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the occurrence community variance parameters.</p>
</td></tr>
<tr><td><code>tau.sq.alpha.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the detection community variance parameters.</p>
</td></tr>
<tr><td><code>beta.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the species level occurrence regression coefficients.</p>
</td></tr>
<tr><td><code>alpha.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the species level detection regression coefficients.</p>
</td></tr>
<tr><td><code>lambda.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the latent factor loadings.</p>
</td></tr>
<tr><td><code>z.samples</code></td>
<td>
<p>a three-dimensional array of posterior samples for
the latent occurrence values for each species.</p>
</td></tr>
<tr><td><code>psi.samples</code></td>
<td>
<p>a three-dimensional array of posterior samples for
the latent occurrence probability values for each species.</p>
</td></tr>
<tr><td><code>sigma.sq.psi.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for variances of random intercepts included in the occurrence portion
of the model. Only included if random intercepts are specified in 
<code>occ.formula</code>.</p>
</td></tr>
<tr><td><code>sigma.sq.p.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for variances of random intercepts included in the detection portion 
of the model. Only included if random intercepts are specified in 
<code>det.formula</code>.</p>
</td></tr>
<tr><td><code>w.samples</code></td>
<td>
<p>a three-dimensional array of posterior samples for 
the latent effects for each latent factor.</p>
</td></tr>
<tr><td><code>beta.star.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the occurrence random effects. Only included if random intercepts
are specified in <code>occ.formula</code>.</p>
</td></tr>
<tr><td><code>alpha.star.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the detection random effects. Only included if random intercepts 
are specified in <code>det.formula</code>.</p>
</td></tr>
<tr><td><code>like.samples</code></td>
<td>
<p>a three-dimensional array of posterior samples
for the likelihood value associated with each site and species. 
Used for calculating WAIC.</p>
</td></tr>
<tr><td><code>rhat</code></td>
<td>
<p>a list of Gelman-Rubin diagnostic values for some of the model
parameters.</p>
</td></tr>
<tr><td><code>ESS</code></td>
<td>
<p>a list of effective sample sizes for some of the model parameters.</p>
</td></tr>
<tr><td><code>run.time</code></td>
<td>
<p>MCMC sampler execution time reported using <code>proc.time()</code>.</p>
</td></tr>
<tr><td><code>k.fold.deviance</code></td>
<td>
<p>vector of scoring rules (deviance) from k-fold cross-validation. 
A separate value is reported for each species. 
Only included if <code>k.fold</code> is specified in function call.</p>
</td></tr>
</table>
<p>The return object will include additional objects used for 
subsequent prediction and/or model fit evaluation. Note that detection 
probability estimated values are not included in the model object, but can
be extracted using <code>fitted()</code>.
</p>


<h3>Note</h3>

<p>Some of the underlying code used for generating random numbers from the
Polya-Gamma distribution is taken from the <span class="pkg">pgdraw</span> package written
by Daniel F. Schmidt and Enes Makalic. Their code implements Algorithm
6 in PhD thesis of Jesse Bennett Windle (2013) <a href="https://repositories.lib.utexas.edu/handle/2152/21842">https://repositories.lib.utexas.edu/handle/2152/21842</a>.
</p>


<h3>Author(s)</h3>

<p>Jeffrey W. Doser <a href="mailto:doserjef@msu.edu">doserjef@msu.edu</a>, <br />
Andrew O. Finley <a href="mailto:finleya@msu.edu">finleya@msu.edu</a>
</p>


<h3>References</h3>

<p>Polson, N.G., J.G. Scott, and J. Windle. (2013) Bayesian Inference for
Logistic Models Using Polya-Gamma Latent Variables.
<em>Journal of the American Statistical Association</em>, 108:1339-1349.
</p>
<p>Bates, Douglas, Martin Maechler, Ben Bolker, Steve Walker (2015).
Fitting Linear Mixed-Effects Models Using lme4. Journal of
Statistical Software, 67(1), 1-48. <a href="https://doi.org/10.18637/jss.v067.i01">doi:10.18637/jss.v067.i01</a>.
</p>
<p>Hooten, M. B., and Hobbs, N. T. (2015). A guide to Bayesian model 
selection for ecologists. Ecological monographs, 85(1), 3-28.
</p>
<p>Dorazio, R. M., and Royle, J. A. (2005). Estimating size and composition 
of biological communities by modeling the occurrence of species. 
Journal of the American Statistical Association, 100(470), 389-398.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(400)
J.x &lt;- 8
J.y &lt;- 8
J &lt;- J.x * J.y
n.rep&lt;- sample(2:4, size = J, replace = TRUE)
N &lt;- 8
# Community-level covariate effects
# Occurrence
beta.mean &lt;- c(0.2, 0.5)
p.occ &lt;- length(beta.mean)
tau.sq.beta &lt;- c(0.6, 0.3)
# Detection
alpha.mean &lt;- c(0.5, 0.2, -0.1)
tau.sq.alpha &lt;- c(0.2, 0.3, 1)
p.det &lt;- length(alpha.mean)
# Draw species-level effects from community means.
beta &lt;- matrix(NA, nrow = N, ncol = p.occ)
alpha &lt;- matrix(NA, nrow = N, ncol = p.det)
p.RE &lt;- list()
# Include a random intercept on detection
p.RE &lt;- list(levels = c(40),
             sigma.sq.p = c(2))
for (i in 1:p.occ) {
  beta[, i] &lt;- rnorm(N, beta.mean[i], sqrt(tau.sq.beta[i]))
}
for (i in 1:p.det) {
  alpha[, i] &lt;- rnorm(N, alpha.mean[i], sqrt(tau.sq.alpha[i]))
}
n.factors &lt;- 4

dat &lt;- simMsOcc(J.x = J.x, J.y = J.y, n.rep = n.rep, N = N, beta = beta, alpha = alpha,
                sp = FALSE, factor.model = TRUE, n.factors = n.factors, p.RE = p.RE)
y &lt;- dat$y
X &lt;- dat$X
X.p &lt;- dat$X.p
X.p.re &lt;- dat$X.p.re
# Package all data into a list
occ.covs &lt;- X[, 2, drop = FALSE]
colnames(occ.covs) &lt;- c('occ.cov')
det.covs &lt;- list(det.cov.1 = X.p[, , 2], 
                 det.cov.2 = X.p[, , 3],
                 det.re = X.p.re[, , 1])
data.list &lt;- list(y = y, 
                  occ.covs = occ.covs,
                  det.covs = det.covs, 
                  coords = dat$coords)

# Occupancy initial values
prior.list &lt;- list(beta.comm.normal = list(mean = 0, var = 2.72), 
                   alpha.comm.normal = list(mean = 0, var = 2.72), 
                   tau.sq.beta.ig = list(a = 0.1, b = 0.1), 
                   tau.sq.alpha.ig = list(a = 0.1, b = 0.1))
# Initial values
lambda.inits &lt;- matrix(0, N, n.factors)
diag(lambda.inits) &lt;- 1
lambda.inits[lower.tri(lambda.inits)] &lt;- rnorm(sum(lower.tri(lambda.inits)))
inits.list &lt;- list(alpha.comm = 0, 
                   beta.comm = 0, 
                   beta = 0, 
                   alpha = 0,
                   tau.sq.beta = 1, 
                   tau.sq.alpha = 1, 
                   lambda = lambda.inits,
                   z = apply(y, c(1, 2), max, na.rm = TRUE))

n.samples &lt;- 300
n.burn &lt;- 200
n.thin &lt;- 1

out &lt;- lfMsPGOcc(occ.formula = ~ occ.cov, 
                 det.formula = ~ det.cov.1 + det.cov.2 + (1 | det.re), 
                 data = data.list, 
                 inits = inits.list, 
                 n.samples = n.samples, 
                 priors = prior.list, 
                 n.factors = n.factors,
                 n.omp.threads = 1, 
                 verbose = TRUE, 
                 n.report = 100, 
                 n.burn = n.burn, 
                 n.thin = n.thin, 
                 n.chains = 1)

summary(out, level = 'community')
</code></pre>

<hr>
<h2 id='msPGOcc'>Function for Fitting Multi-Species Occupancy Models Using Polya-Gamma Latent Variables</h2><span id='topic+msPGOcc'></span>

<h3>Description</h3>

<p>Function for fitting multi-species occupancy models using Polya-Gamma latent variables. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>msPGOcc(occ.formula, det.formula, data, inits, priors, n.samples,
        n.omp.threads = 1, verbose = TRUE, n.report = 100, 
        n.burn = round(.10 * n.samples), n.thin = 1, n.chains = 1,
        k.fold, k.fold.threads = 1, k.fold.seed, k.fold.only = FALSE, ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="msPGOcc_+3A_occ.formula">occ.formula</code></td>
<td>
<p>a symbolic description of the model to be fit
for the occurrence portion of the model using R's model syntax. Only
right-hand side of formula is specified. See example below. Random 
intercepts are allowed using <span class="pkg">lme4</span> syntax (Bates et al. 2015).</p>
</td></tr>
<tr><td><code id="msPGOcc_+3A_det.formula">det.formula</code></td>
<td>
<p>a symbolic description of the model to be fit
for the detection portion of the model using R's model syntax. Only
right-hand side of formula is specified. See example below. Random 
intercepts are allowed using <span class="pkg">lme4</span> syntax (Bates et al. 2015).</p>
</td></tr>
<tr><td><code id="msPGOcc_+3A_data">data</code></td>
<td>
<p>a list containing data necessary for model fitting.
Valid tags are <code>y</code>, <code>occ.covs</code>, and <code>det.covs</code>. <code>y</code>
is a three-dimensional array with first dimension equal to the number 
of species, second dimension equal to the number of sites, and third 
dimension equal to the maximum number of replicates at a given site. 
<code>occ.covs</code> is a matrix or data frame containing the variables 
used in the occurrence portion of the model, with <code class="reqn">J</code> rows for 
each column (variable). <code>det.covs</code> is a list of variables included 
in the detection portion of the model. Each list element is a different 
detection covariate, which can be site-level or observational-level. 
Site-level covariates are specified as a vector of length <code class="reqn">J</code> while 
observation-level covariates are specified as a matrix or data frame 
with the number of rows equal to <code class="reqn">J</code> and number of columns equal 
to the maximum number of replicates at a given site.</p>
</td></tr>
<tr><td><code id="msPGOcc_+3A_inits">inits</code></td>
<td>
<p>a list with each tag corresponding to a parameter name.
Valid tags are <code>alpha.comm</code>, <code>beta.comm</code>, <code>beta</code>, 
<code>alpha</code>, <code>tau.sq.beta</code>, <code>tau.sq.alpha</code>, <code>sigma.sq.psi</code>, 
<code>sigma.sq.p</code>, and <code>z</code>. 
The value portion of each tag is the parameter's initial value. See 
<code>priors</code> description for definition of each parameter name.
Additionally, the tag <code>fix</code> can be set to <code>TRUE</code> 
to fix the starting values across all chains. If <code>fix</code> is not specified
(the default), starting values are varied randomly across chains.</p>
</td></tr>
<tr><td><code id="msPGOcc_+3A_priors">priors</code></td>
<td>
<p>a list with each tag corresponding to a parameter name. 
Valid tags are <code>beta.comm.normal</code>, <code>alpha.comm.normal</code>, 
<code>tau.sq.beta.ig</code>, <code>tau.sq.alpha.ig</code>, <code>sigma.sq.psi.ig</code>, and 
<code>sigma.sq.p.ig</code>. Community-level occurrence 
(<code>beta.comm</code>) and detection (<code>alpha.comm</code>) regression coefficients 
are assumed to follow a normal distribution. The hyperparameters of the 
normal distribution are passed as a list of length two with the first
and second elements corresponding to the mean and variance of the normal
distribution, which are each specified as vectors of 
length equal to the number of coefficients to be estimated or of length one
if priors are the same for all coefficients. If not
specified, prior means are set to 0 and prior variances set to 2.72. 
Community-level variance parameters for occurrence (<code>tau.sq.beta</code>) and
detection (<code>tau.sq.alpha</code>) are assumed to follow an inverse Gamma 
distribution. The hyperparameters of the inverse gamma distribution are 
passed as a list of length two with the first and second elements 
corresponding to the shape and scale parameters, which are each specified
as vectors of length equal to the number of coefficients to be estimated 
or a single value if all parameters are assigned the same prior. 
If not specified, prior shape and scale parameters are set to 0.1. <code>sigma.sq.psi</code> and 
<code>sigma.sq.p</code> are the random effect variances for any occurrence or 
detection random effects, respectively, and are assumed to follow an inverse
Gamma distribution. The hyperparameters of the inverse-Gamma distribution
are passed as a list of length two with first and second elements corresponding
to the shape and scale parameters, respectively, which are each specified as
vectors of length equal to the number of random intercepts or of length one 
if priors are the same for all random effect variances.</p>
</td></tr>
<tr><td><code id="msPGOcc_+3A_n.samples">n.samples</code></td>
<td>
<p>the number of posterior samples to collect in each chain.</p>
</td></tr>
<tr><td><code id="msPGOcc_+3A_n.omp.threads">n.omp.threads</code></td>
<td>
<p>a positive integer indicating the number of threads
to use for SMP parallel processing. The package must be compiled for 
OpenMP support. For most Intel-based machines, we recommend setting 
<code>n.omp.threads</code> up to the number of hypterthreaded cores. Note, 
<code>n.omp.threads</code> &gt; 1 might not work on some systems. Currently only 
relevant for spatial models.</p>
</td></tr>
<tr><td><code id="msPGOcc_+3A_verbose">verbose</code></td>
<td>
<p>if <code>TRUE</code>, messages about data preparation, 
model specification, and progress of the sampler are printed to the screen. 
Otherwise, no messages are printed.</p>
</td></tr>
<tr><td><code id="msPGOcc_+3A_n.report">n.report</code></td>
<td>
<p>the interval to report MCMC progress.</p>
</td></tr>
<tr><td><code id="msPGOcc_+3A_n.burn">n.burn</code></td>
<td>
<p>the number of samples out of the total <code>n.samples</code> to 
discard as burn-in for each chain. By default, the first 10% of samples is discarded.</p>
</td></tr>
<tr><td><code id="msPGOcc_+3A_n.thin">n.thin</code></td>
<td>
<p>the thinning interval for collection of MCMC samples. The
thinning occurs after the <code>n.burn</code> samples are discarded. Default 
value is set to 1.</p>
</td></tr>
<tr><td><code id="msPGOcc_+3A_n.chains">n.chains</code></td>
<td>
<p>the number of chains to run in sequence.</p>
</td></tr>
<tr><td><code id="msPGOcc_+3A_k.fold">k.fold</code></td>
<td>
<p>specifies the number of <em>k</em> folds for cross-validation. 
If not specified as an argument, then cross-validation is not performed
and <code>k.fold.threads</code> and <code>k.fold.seed</code> are ignored. In <em>k</em>-fold
cross-validation, the data specified in <code>data</code> is randomly
partitioned into <em>k</em> equal sized subsamples. Of the <em>k</em> subsamples, 
<em>k</em> - 1 subsamples are used to fit the model and the remaining <em>k</em>
samples are used for prediction. The cross-validation process is repeated 
<em>k</em> times (the folds). As a scoring rule, we use the model deviance 
as described in Hooten and Hobbs (2015). Cross-validation is performed
after the full model is fit using all the data. Cross-validation results
are reported in the <code>k.fold.deviance</code> object in the return list.</p>
</td></tr>
<tr><td><code id="msPGOcc_+3A_k.fold.threads">k.fold.threads</code></td>
<td>
<p>number of threads to use for cross-validation. If 
<code>k.fold.threads &gt; 1</code> parallel processing is accomplished using the 
<span class="pkg">foreach</span> and <span class="pkg">doParallel</span> packages. Ignored if <code>k.fold</code>
is not specified.</p>
</td></tr> 
<tr><td><code id="msPGOcc_+3A_k.fold.seed">k.fold.seed</code></td>
<td>
<p>seed used to split data set into <code>k.fold</code> parts
for k-fold cross-validation. Ignored if <code>k.fold</code> is not specified.</p>
</td></tr>
<tr><td><code id="msPGOcc_+3A_k.fold.only">k.fold.only</code></td>
<td>
<p>a logical value indicating whether to only perform 
cross-validation (<code>TRUE</code>) or perform cross-validation after fitting 
the full model (<code>FALSE</code>). Default value is <code>FALSE</code>.</p>
</td></tr> 
<tr><td><code id="msPGOcc_+3A_...">...</code></td>
<td>
<p>currently no additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>msPGOcc</code> that is a list comprised of: 
</p>
<table>
<tr><td><code>beta.comm.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the community level occurrence regression coefficients.</p>
</td></tr>
<tr><td><code>alpha.comm.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the community level detection regression coefficients.</p>
</td></tr>
<tr><td><code>tau.sq.beta.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the occurrence community variance parameters.</p>
</td></tr>
<tr><td><code>tau.sq.alpha.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the detection community variance parameters.</p>
</td></tr>
<tr><td><code>beta.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the species level occurrence regression coefficients.</p>
</td></tr>
<tr><td><code>alpha.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the species level detection regression coefficients.</p>
</td></tr>
<tr><td><code>z.samples</code></td>
<td>
<p>a three-dimensional array of posterior samples for
the latent occurrence values for each species.</p>
</td></tr>
<tr><td><code>psi.samples</code></td>
<td>
<p>a three-dimensional array of posterior samples for
the latent occurrence probability values for each species.</p>
</td></tr>
<tr><td><code>sigma.sq.psi.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for variances of random intercepts included in the occurrence portion
of the model. Only included if random intercepts are specified in 
<code>occ.formula</code>.</p>
</td></tr>
<tr><td><code>sigma.sq.p.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for variances of random intercepts included in the detection portion 
of the model. Only included if random intercepts are specified in 
<code>det.formula</code>.</p>
</td></tr>
<tr><td><code>beta.star.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the occurrence random effects. Only included if random intercepts
are specified in <code>occ.formula</code>.</p>
</td></tr>
<tr><td><code>alpha.star.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the detection random effects. Only included if random intercepts 
are specified in <code>det.formula</code>.</p>
</td></tr>
<tr><td><code>like.samples</code></td>
<td>
<p>a three-dimensional array of posterior samples
for the likelihood value associated with each site and species. 
Used for calculating WAIC.</p>
</td></tr>
<tr><td><code>rhat</code></td>
<td>
<p>a list of Gelman-Rubin diagnostic values for some of the model
parameters.</p>
</td></tr>
<tr><td><code>ESS</code></td>
<td>
<p>a list of effective sample sizes for some of the model parameters.</p>
</td></tr>
<tr><td><code>run.time</code></td>
<td>
<p>MCMC sampler execution time reported using <code>proc.time()</code>.</p>
</td></tr>
<tr><td><code>k.fold.deviance</code></td>
<td>
<p>vector of scoring rules (deviance) from k-fold cross-validation. 
A separate value is reported for each species. 
Only included if <code>k.fold</code> is specified in function call.</p>
</td></tr>
</table>
<p>The return object will include additional objects used for 
subsequent prediction and/or model fit evaluation. Note that detection probability
estimated values are not included in the model object, but can be extracted
using <code>fitted()</code>. 
</p>


<h3>Note</h3>

<p>Some of the underlying code used for generating random numbers from the
Polya-Gamma distribution is taken from the <span class="pkg">pgdraw</span> package written
by Daniel F. Schmidt and Enes Makalic. Their code implements Algorithm
6 in PhD thesis of Jesse Bennett Windle (2013) <a href="https://repositories.lib.utexas.edu/handle/2152/21842">https://repositories.lib.utexas.edu/handle/2152/21842</a>.
</p>


<h3>Author(s)</h3>

<p>Jeffrey W. Doser <a href="mailto:doserjef@msu.edu">doserjef@msu.edu</a>, <br />
Andrew O. Finley <a href="mailto:finleya@msu.edu">finleya@msu.edu</a>
</p>


<h3>References</h3>

<p>Polson, N.G., J.G. Scott, and J. Windle. (2013) Bayesian Inference for
Logistic Models Using Polya-Gamma Latent Variables.
<em>Journal of the American Statistical Association</em>, 108:1339-1349.
</p>
<p>Bates, Douglas, Martin Maechler, Ben Bolker, Steve Walker (2015).
Fitting Linear Mixed-Effects Models Using lme4. Journal of
Statistical Software, 67(1), 1-48. <a href="https://doi.org/10.18637/jss.v067.i01">doi:10.18637/jss.v067.i01</a>.
</p>
<p>Hooten, M. B., and Hobbs, N. T. (2015). A guide to Bayesian model 
selection for ecologists. Ecological monographs, 85(1), 3-28.
</p>
<p>Dorazio, R. M., and Royle, J. A. (2005). Estimating size and composition 
of biological communities by modeling the occurrence of species. 
Journal of the American Statistical Association, 100(470), 389-398.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(400)
J.x &lt;- 8
J.y &lt;- 8
J &lt;- J.x * J.y
n.rep &lt;- sample(2:4, size = J, replace = TRUE)
N &lt;- 6
# Community-level covariate effects
# Occurrence
beta.mean &lt;- c(0.2, 0.5)
p.occ &lt;- length(beta.mean)
tau.sq.beta &lt;- c(0.6, 0.3)
# Detection
alpha.mean &lt;- c(0.5, 0.2, -0.1)
tau.sq.alpha &lt;- c(0.2, 0.3, 1)
p.det &lt;- length(alpha.mean)
# Draw species-level effects from community means.
beta &lt;- matrix(NA, nrow = N, ncol = p.occ)
alpha &lt;- matrix(NA, nrow = N, ncol = p.det)
for (i in 1:p.occ) {
  beta[, i] &lt;- rnorm(N, beta.mean[i], sqrt(tau.sq.beta[i]))
}
for (i in 1:p.det) {
  alpha[, i] &lt;- rnorm(N, alpha.mean[i], sqrt(tau.sq.alpha[i]))
}

dat &lt;- simMsOcc(J.x = J.x, J.y = J.y, n.rep = n.rep, N = N, beta = beta, alpha = alpha,
                sp = FALSE)
y &lt;- dat$y
X &lt;- dat$X
X.p &lt;- dat$X.p
# Package all data into a list
occ.covs &lt;- X[, 2, drop = FALSE]
colnames(occ.covs) &lt;- c('occ.cov')
det.covs &lt;- list(det.cov.1 = X.p[, , 2], 
                 det.cov.2 = X.p[, , 3])
data.list &lt;- list(y = y, 
                  occ.covs = occ.covs,
                  det.covs = det.covs)

# Occupancy initial values
prior.list &lt;- list(beta.comm.normal = list(mean = 0, var = 2.72), 
                   alpha.comm.normal = list(mean = 0, var = 2.72), 
                   tau.sq.beta.ig = list(a = 0.1, b = 0.1), 
                   tau.sq.alpha.ig = list(a = 0.1, b = 0.1))
# Initial values
inits.list &lt;- list(alpha.comm = 0, 
                   beta.comm = 0, 
                   beta = 0, 
                   alpha = 0,
                   tau.sq.beta = 1, 
                   tau.sq.alpha = 1, 
                   z = apply(y, c(1, 2), max, na.rm = TRUE))

n.samples &lt;- 3000
n.burn &lt;- 2000
n.thin &lt;- 1

out &lt;- msPGOcc(occ.formula = ~ occ.cov, 
               det.formula = ~ det.cov.1 + det.cov.2, 
               data = data.list, 
               inits = inits.list, 
               n.samples = n.samples, 
               priors = prior.list, 
               n.omp.threads = 1, 
               verbose = TRUE, 
               n.report = 1000, 
               n.burn = n.burn, 
               n.thin = n.thin, 
               n.chains = 1)

summary(out, level = 'community')
</code></pre>

<hr>
<h2 id='neon2015'>Detection-nondetection data of 12 foliage gleaning bird species
in 2015 in Bartlett Experimental Forest in New Hampshire, USA</h2><span id='topic+neon2015'></span>

<h3>Description</h3>

<p>Detection-nondetection data of 12 foliage gleaning bird species in 2015 in the 
Bartlett Experimental Forest in New Hampshire, USA. These data were collected as 
part of the National Ecological Observatory Network (NEON). Data were collected
at 80 sites where observers recorded the number of all bird species observed during a
six minute, 125m radius point count survey once during the breeding season. The six
minute survey was split into three two-minute intervals following a removal design
where the observer recorded the interval during which a species was first observed
(if any) with a 1, intervals prior to observation with a 0, and then mentally removed
the species from subsequent intervals (marked with NA), which enables modeling of data 
in an occupancy modeling framework. The 12 species included in the data set are as follows: 
(1) AMRE: American Redstart; (2) BAWW: Black-and-white Warbler; 
(3) BHVI: Blue-headed Vireo; (4) BLBW: Blackburnian Warbler; 
(5) BLPW: Blackpoll Warbler; (6) BTBW: Black-throated Blue Warbler; (7) BTNW: 
BLack-throated Green Warbler; (8) CAWA: Canada Warbler; (9) MAWA: Magnolia Warbler; 
(10) NAWA: Nashville Warbler; (11) OVEN: Ovenbird; (12) REVI: Red-eyed Vireo. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(neon2015)
</code></pre>


<h3>Format</h3>

<p><code>neon2015</code> is a list with four elements: 
</p>
<p><code>y</code>: a three-dimensional array of detection-nondetection data with 
dimensions of species (12), sites (80) and replicates (3). 
</p>
<p><code>occ.covs</code>: a numeric matrix with 80 rows and one column consisting of the 
elevation at each site.
</p>
<p><code>det.covs</code>: a list of two numeric vectors with 80 elements. The 
first element is the day of year when the survey was conducted for a given 
site. The second element is the time of day when the survey began.
</p>
<p><code>coords</code>: a numeric matrix with 80 rows and two columns containing the 
site coordinates (Easting and Northing) in UTM Zone 19. The proj4string is
&quot;+proj=utm +zone=19 +units=m +datum=NAD83&quot;.
</p>


<h3>Source</h3>

<p>NEON (National Ecological Observatory Network). Breeding landbird point counts, 
RELEASE-2021 (DP1.10003.001). https://doi.org/10.48443/s730-dy13. 
Dataset accessed from https://data.neonscience.org on October 10, 2021</p>


<h3>References</h3>

<p>Doser, J. W., Leuenberger, W., Sillett, T. S., Hallworth, M. T. &amp; Zipkin, E. F. (2022). 
Integrated community occupancy models: A framework to assess occurrence and biodiversity 
dynamics using multiple data sources. Methods in Ecology and Evolution, 00, 1-14. <a href="https://doi.org/10.1111/2041-210X.13811">doi:10.1111/2041-210X.13811</a>
</p>
<p>Barnett, D. T., Duffy, P. A., Schimel, D. S., Krauss, R. E., Irvine, K. M., 
Davis, F. W.,Gross, J. E., Azuaje, E. I., Thorpe, A. S., Gudex-Cross, D., et al. (2019). 
The terrestrial organism and biogeochemistry spatial sampling design for 
the national ecological observatory network. Ecosphere, 10(2):e02540.
</p>

<hr>
<h2 id='PGOcc'>Function for Fitting Single-Species Occupancy Models Using Polya-Gamma Latent Variables</h2><span id='topic+PGOcc'></span>

<h3>Description</h3>

<p>Function for fitting single-species occupancy models using Polya-Gamma latent variables. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PGOcc(occ.formula, det.formula, data, inits, priors, n.samples, 
      n.omp.threads = 1, verbose = TRUE, n.report = 100, 
      n.burn = round(.10 * n.samples), n.thin = 1, n.chains = 1,
      k.fold, k.fold.threads = 1, k.fold.seed, k.fold.only = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PGOcc_+3A_occ.formula">occ.formula</code></td>
<td>
<p>a symbolic description of the model to be fit
for the occurrence portion of the model using R's model syntax. Only
right-hand side of formula is specified. See example below. Random intercepts
are allowed using lme4 syntax (Bates et al. 2015).</p>
</td></tr>
<tr><td><code id="PGOcc_+3A_det.formula">det.formula</code></td>
<td>
<p>a symbolic description of the model to be fit
for the detection portion of the model using R's model syntax. Only
right-hand side of formula is specified. See example below. Random intercepts
are allowed using lme4 syntax (Bates et al. 2015).</p>
</td></tr>
<tr><td><code id="PGOcc_+3A_data">data</code></td>
<td>
<p>a list containing data necessary for model fitting.
Valid tags are <code>y</code>, <code>occ.covs</code>, and <code>det.covs</code>. <code>y</code>
is a matrix or data frame with first dimension equal to the number of 
sites (<code class="reqn">J</code>) and second dimension equal to the maximum number of 
replicates at a given site. <code>occ.covs</code> is a matrix or data frame
containing the variables used in the occurrence portion of the model, with
<code class="reqn">J</code> rows for each column (variable). <code>det.covs</code> is a list of
variables included in the detection portion of the model. Each list element
is a different detection covariate, which can be site-level or 
observational-level. Site-level covariates are specified as a vector 
of length <code class="reqn">J</code> while observation-level covariates are specified 
as a matrix or data frame with the number of rows equal to <code class="reqn">J</code> and 
number of columns equal to the maximum number of replicates at a given site.</p>
</td></tr>
<tr><td><code id="PGOcc_+3A_inits">inits</code></td>
<td>
<p>a list with each tag corresponding to a parameter name.
Valid tags are <code>z</code>, <code>beta</code>, <code>alpha</code>, <code>sigma.sq.psi</code>,
and <code>sigma.sq.p</code>. The value portion of each tag is the 
parameter's initial value. <code>sigma.sq.psi</code> and <code>sigma.sq.p</code> are 
only relevant when including random effects in the occurrence and 
detection portion of the occupancy model, respectively. See <code>priors</code> 
description for definition of each parameter name.
Additionally, the tag <code>fix</code> can be set to <code>TRUE</code> 
to fix the starting values across all chains. If <code>fix</code> is not specified
(the default), starting values are varied randomly across chains.</p>
</td></tr>
<tr><td><code id="PGOcc_+3A_priors">priors</code></td>
<td>
<p>a list with each tag corresponding to a parameter name. 
Valid tags are <code>beta.normal</code>, <code>alpha.normal</code>, <code>sigma.sq.psi.ig</code>, 
and <code>sigma.sq.p.ig</code>. Occupancy (<code>beta</code>) and detection (<code>alpha</code>) 
regression coefficients are assumed to follow a normal distribution. 
The hyperparameters of the normal distribution are passed as a list of 
length two with the first and second elements corresponding to the mean 
and variance of the normal distribution, which are each specified as vectors of 
length equal to the number of coefficients to be estimated or of length one
if priors are the same for all coefficients. If not specified, prior means 
are set to 0 and prior variances set to 2.72. <code>sigma.sq.psi</code> and 
<code>sigma.sq.p</code> are the random effect variances for any occurrence or 
detection random effects, respectively, and are assumed to follow an inverse
Gamma distribution. The hyperparameters of the inverse-Gamma distribution
are passed as a list of length two with first and second elements corresponding
to the shape and scale parameters, respectively, which are each specified as
vectors of length equal to the number of random intercepts or of length one 
if priors are the same for all random effect variances.</p>
</td></tr>
<tr><td><code id="PGOcc_+3A_n.samples">n.samples</code></td>
<td>
<p>the number of posterior samples to collect in each chain.</p>
</td></tr>
<tr><td><code id="PGOcc_+3A_n.omp.threads">n.omp.threads</code></td>
<td>
<p>a positive integer indicating the number of threads
to use for SMP parallel processing. The package must be compiled for 
OpenMP support. For most Intel-based machines, we recommend setting 
<code>n.omp.threads</code> up to the number of hypterthreaded cores. Note, 
<code>n.omp.threads</code> &gt; 1 might not work on some systems. Currently only 
relevant for spatial models.</p>
</td></tr>
<tr><td><code id="PGOcc_+3A_verbose">verbose</code></td>
<td>
<p>if <code>TRUE</code>, messages about data preparation, 
model specification, and progress of the sampler are printed to the screen. 
Otherwise, no messages are printed.</p>
</td></tr>
<tr><td><code id="PGOcc_+3A_n.report">n.report</code></td>
<td>
<p>the interval to report MCMC progress.</p>
</td></tr>
<tr><td><code id="PGOcc_+3A_n.burn">n.burn</code></td>
<td>
<p>the number of samples out of the total <code>n.samples</code> to 
discard as burn-in for each chain. By default, the first 10% of samples is discarded.</p>
</td></tr>
<tr><td><code id="PGOcc_+3A_n.thin">n.thin</code></td>
<td>
<p>the thinning interval for collection of MCMC samples. The
thinning occurs after the <code>n.burn</code> samples are discarded. Default 
value is set to 1.</p>
</td></tr>
<tr><td><code id="PGOcc_+3A_n.chains">n.chains</code></td>
<td>
<p>the number of chains to run in sequence.</p>
</td></tr>
<tr><td><code id="PGOcc_+3A_k.fold">k.fold</code></td>
<td>
<p>specifies the number of <em>k</em> folds for cross-validation. 
If not specified as an argument, then cross-validation is not performed
and <code>k.fold.threads</code> and <code>k.fold.seed</code> are ignored. In <em>k</em>-fold
cross-validation, the data specified in <code>data</code> is randomly
partitioned into <em>k</em> equal sized subsamples. Of the <em>k</em> subsamples, 
<em>k</em> - 1 subsamples are used to fit the model and the remaining <em>k</em>
samples are used for prediction. The cross-validation process is repeated 
<em>k</em> times (the folds). As a scoring rule, we use the model deviance 
as described in Hooten and Hobbs (2015). Cross-validation is performed
after the full model is fit using all the data. Cross-validation results
are reported in the <code>k.fold.deviance</code> object in the return list.</p>
</td></tr>
<tr><td><code id="PGOcc_+3A_k.fold.threads">k.fold.threads</code></td>
<td>
<p>number of threads to use for cross-validation. If 
<code>k.fold.threads &gt; 1</code> parallel processing is accomplished using the 
<span class="pkg">foreach</span> and <span class="pkg">doParallel</span> packages. Ignored if <code>k.fold</code>
is not specified.</p>
</td></tr> 
<tr><td><code id="PGOcc_+3A_k.fold.seed">k.fold.seed</code></td>
<td>
<p>seed used to split data set into <code>k.fold</code> parts
for k-fold cross-validation. Ignored if <code>k.fold</code> is not specified.</p>
</td></tr>
<tr><td><code id="PGOcc_+3A_k.fold.only">k.fold.only</code></td>
<td>
<p>a logical value indicating whether to only perform 
cross-validation (<code>TRUE</code>) or perform cross-validation after fitting 
the full model (<code>FALSE</code>). Default value is <code>FALSE</code>.</p>
</td></tr> 
<tr><td><code id="PGOcc_+3A_...">...</code></td>
<td>
<p>currently no additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>PGOcc</code> that is a list comprised of: 
</p>
<table>
<tr><td><code>beta.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the occupancy regression coefficients.</p>
</td></tr>
<tr><td><code>alpha.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the detection regression coefficients.</p>
</td></tr>
<tr><td><code>z.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples 
for the latent occupancy values</p>
</td></tr>
<tr><td><code>psi.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the latent occupancy probability values</p>
</td></tr>
<tr><td><code>sigma.sq.psi.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for variances of random intercepts included in the occupancy portion
of the model. Only included if random intercepts are specified in 
<code>occ.formula</code>.</p>
</td></tr>
<tr><td><code>sigma.sq.p.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for variances of random intercpets included in the detection portion 
of the model. Only included if random intercepts are specified in 
<code>det.formula</code>.</p>
</td></tr>
<tr><td><code>beta.star.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the occurrence random effects. Only included if random intercepts
are specified in <code>occ.formula</code>.</p>
</td></tr>
<tr><td><code>alpha.star.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the detection random effects. Only included if random intercepts 
are specified in <code>det.formula</code>.</p>
</td></tr>
<tr><td><code>like.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the likelihood value associated with each site. Used for calculating
WAIC.</p>
</td></tr>
<tr><td><code>rhat</code></td>
<td>
<p>a list of Gelman-Rubin diagnostic values for some of the model
parameters.</p>
</td></tr>
<tr><td><code>ESS</code></td>
<td>
<p>a list of effective sample sizes for some of the model parameters.</p>
</td></tr>
<tr><td><code>run.time</code></td>
<td>
<p>execution time reported using <code>proc.time()</code>.</p>
</td></tr>
<tr><td><code>k.fold.deviance</code></td>
<td>
<p>scoring rule (deviance) from k-fold cross-validation. 
Only included if <code>k.fold</code> is specified in function call.</p>
</td></tr>
</table>
<p>The return object will include additional objects used for 
subsequent prediction and/or model fit evaluation. Note that detection
probability estimated values are not included in the model object, but can be 
extracted using <code>fitted()</code>. 
</p>


<h3>Note</h3>

<p>Some of the underlying code used for generating random numbers from the
Polya-Gamma distribution is taken from the <span class="pkg">pgdraw</span> package written
by Daniel F. Schmidt and Enes Makalic. Their code implements Algorithm
6 in PhD thesis of Jesse Bennett Windle (2013) <a href="https://repositories.lib.utexas.edu/handle/2152/21842">https://repositories.lib.utexas.edu/handle/2152/21842</a>.
</p>


<h3>Author(s)</h3>

<p>Jeffrey W. Doser <a href="mailto:doserjef@msu.edu">doserjef@msu.edu</a>, <br />
Andrew O. Finley <a href="mailto:finleya@msu.edu">finleya@msu.edu</a>
</p>


<h3>References</h3>

<p>Polson, N.G., J.G. Scott, and J. Windle. (2013) Bayesian Inference for
Logistic Models Using Polya-Gamma Latent Variables. 
<em>Journal of the American Statistical Association</em>, 108:1339-1349.
</p>
<p>Bates, Douglas, Martin Maechler, Ben Bolker, Steve Walker (2015).
Fitting Linear Mixed-Effects Models Using lme4. Journal of
Statistical Software, 67(1), 1-48. <a href="https://doi.org/10.18637/jss.v067.i01">doi:10.18637/jss.v067.i01</a>.
</p>
<p>Hooten, M. B., and Hobbs, N. T. (2015). A guide to Bayesian model 
selection for ecologists. Ecological monographs, 85(1), 3-28.
</p>
<p>MacKenzie, D. I., J. D. Nichols, G. B. Lachman, S. Droege, 
J. Andrew Royle, and C. A. Langtimm. 2002. Estimating Site Occupancy 
Rates When Detection Probabilities Are Less Than One. Ecology 83: 2248-2255.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(400)
J.x &lt;- 10
J.y &lt;- 10
J &lt;- J.x * J.y
n.rep &lt;- sample(2:4, J, replace = TRUE)
beta &lt;- c(0.5, -0.15)
p.occ &lt;- length(beta)
alpha &lt;- c(0.7, 0.4)
p.det &lt;- length(alpha)
dat &lt;- simOcc(J.x = J.x, J.y = J.y, n.rep = n.rep, beta = beta, alpha = alpha,
              sp = FALSE)
occ.covs &lt;- dat$X[, 2, drop = FALSE]
colnames(occ.covs) &lt;- c('occ.cov')
det.covs &lt;- list(det.cov = dat$X.p[, , 2])
# Data bundle
data.list &lt;- list(y = dat$y, 
                  occ.covs = occ.covs, 
                  det.covs = det.covs)

# Priors
prior.list &lt;- list(beta.normal = list(mean = 0, var = 2.72),
                   alpha.normal = list(mean = 0, var = 2.72))
# Initial values
inits.list &lt;- list(alpha = 0, beta = 0,
                   z = apply(data.list$y, 1, max, na.rm = TRUE))

n.samples &lt;- 5000
n.report &lt;- 1000

out &lt;- PGOcc(occ.formula = ~ occ.cov, 
             det.formula = ~ det.cov, 
             data = data.list, 
             inits = inits.list,
             n.samples = n.samples,
             priors = prior.list,
             n.omp.threads = 1,
             verbose = TRUE,
             n.report = n.report, 
             n.burn = 1000, 
             n.thin = 1, 
             n.chains = 1)
summary(out)
</code></pre>

<hr>
<h2 id='postHocLM'>Function for Fitting Linear Mixed Models with Previous Model Estimates</h2><span id='topic+postHocLM'></span>

<h3>Description</h3>

<p>Function for fitting a linear (mixed) model as a second-stage model where
the response variable itself comes from a previous model fit and has 
uncertainty associated with it. The response variable is assumed to be 
a set of estimates from a previous model fit, where each value in the 
response variable has a posterior MCMC sample of estimates. This function
is useful for doing &quot;posthoc&quot; analyses of model estimates (e.g., 
exploring how species traits relate to species-specific parameter estimates
from a multi-species occupancy model). Such analyses are sometimes referred
to as &quot;two-stage&quot; analyses.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>postHocLM(formula, data, inits, priors, verbose = FALSE, 
          n.report = 100, n.samples, n.chains = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="postHocLM_+3A_formula">formula</code></td>
<td>
<p>a symbolic description of the model to be fit
for the model using R's model syntax. Only right-hand side of 
formula is specified. See example below. Random intercepts
are allowed using lme4 syntax (Bates et al. 2015).</p>
</td></tr>
<tr><td><code id="postHocLM_+3A_data">data</code></td>
<td>
<p>a list containing data necessary for model fitting.
Valid tags are <code>y</code> and <code>covs</code>. <code>y</code>
is a matrix or data frame with first dimension equal to the number of 
posterior samples of each value in the response variable and the 
second dimension is equal to the number of values in the response
variable. For example, if the response is species-specific covariate 
effect estimates from a multi-species occupancy model, the rows correspond
to the posterior MCMC samples and the columns correspond to species. <code>covs</code>
is a matrix or data frame containing the independent variables used in the model. 
Note the number of rows of <code>covs</code> should be equal to the number of columns
in <code>y</code>.</p>
</td></tr> 
<tr><td><code id="postHocLM_+3A_inits">inits</code></td>
<td>
<p>a list with each tag corresponding to a parameter name.
Valid tags are <code>beta</code>, <code>tau.sq</code>, and <code>sigma.sq</code>.
The value portion of each tag is the 
parameter's initial value. <code>sigma.sq</code> is 
only relevant when including random effects in the model. See <code>priors</code> 
description for definition of each parameter name.
Additionally, the tag <code>fix</code> can be set to <code>TRUE</code> 
to fix the starting values across all chains. If <code>fix</code> is not specified
(the default), starting values are varied randomly across chains.</p>
</td></tr>
<tr><td><code id="postHocLM_+3A_priors">priors</code></td>
<td>
<p>a list with each tag corresponding to a parameter name. 
Valid tags are <code>beta.normal</code>, <code>tau.sq.ig</code>, and <code>sigma.sq.ig</code>. 
Regression coefficients (<code>beta</code>) are assumed to follow a normal distribution. 
The hyperparameters of the normal distribution are passed as a list of 
length two with the first and second elements corresponding to the mean 
and variance of the normal distribution, which are each specified as vectors of 
length equal to the number of coefficients to be estimated or of length one
if priors are the same for all coefficients. If not specified, prior means 
are set to 0 and prior variances set to 100. <code>tau.sq</code> is the residual variance, 
and is assumed to follow an inverse-Gamma distribution. 
The hyperparameters of the inverse-Gamma distribution
are passed as a vector of length two with first and second elements corresponding
to the shape and scale parameters, respectively. <code>sigma.sq</code> are 
the variances of any random intercepts included in the model, which similarly to 
<code>tau.sq</code> follow an inverse-Gamma distribution. The hyperparameters of the 
inverse-Gamma distribution are passed as a list of length two with first and second
elements corresponding to the shape and scale parameters, respectively, which are 
each specified as vectors of length equal to the number of random intercepts or 
of length one if priors are the same for all random effect variances.</p>
</td></tr>
<tr><td><code id="postHocLM_+3A_verbose">verbose</code></td>
<td>
<p>if <code>TRUE</code>, messages about data preparation, 
model specification, and progress of the sampler are printed to the screen. 
Otherwise, no messages are printed.</p>
</td></tr>
<tr><td><code id="postHocLM_+3A_n.report">n.report</code></td>
<td>
<p>the interval to report MCMC progress.</p>
</td></tr>
<tr><td><code id="postHocLM_+3A_n.samples">n.samples</code></td>
<td>
<p>the number of posterior samples to collect in each chain. Note that
by default, the same number of MCMC samples fit in the first stage model is 
assumed to be fit for the second stage model. If <code>n.samples</code> is specified, 
it must be a multiple of the number of samples fit in the first stage, otherwise
an error will be reported.</p>
</td></tr>
<tr><td><code id="postHocLM_+3A_n.chains">n.chains</code></td>
<td>
<p>the number of chains to run in sequence.</p>
</td></tr>
<tr><td><code id="postHocLM_+3A_...">...</code></td>
<td>
<p>currently no additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>postHocLM</code> that is a list comprised of: 
</p>
<table>
<tr><td><code>beta.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the regression coefficients.</p>
</td></tr>
<tr><td><code>tau.sq.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the residual variances.</p>
</td></tr>
<tr><td><code>y.hat.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples 
of fitted values.</p>
</td></tr>
<tr><td><code>sigma.sq.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the random effect variances if any random intercepts were included
in the model.</p>
</td></tr>
<tr><td><code>beta.star.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the random effects. Only included if random intercepts
are specified in <code>formula</code>.</p>
</td></tr>
<tr><td><code>rhat</code></td>
<td>
<p>a list of Gelman-Rubin diagnostic values for some of the model
parameters.</p>
</td></tr>
<tr><td><code>ESS</code></td>
<td>
<p>a list of effective sample sizes for some of the model parameters.</p>
</td></tr>
<tr><td><code>run.time</code></td>
<td>
<p>execution time reported using <code>proc.time()</code>.</p>
</td></tr>
<tr><td><code>bayes.R2</code></td>
<td>
<p>a <code>coda</code> object of posterior samples 
of the Bayesian R-squared as a measure of model fit. Note that when 
random intercepts are included in the model, this is the conditional
Bayesian R-squared, not the marginal Bayesian R-squared.</p>
</td></tr>
</table>
<p>The return object will include additional objects used for 
subsequent summarization. 
</p>


<h3>Author(s)</h3>

<p>Jeffrey W. Doser <a href="mailto:doserjef@msu.edu">doserjef@msu.edu</a>, <br />
</p>


<h3>References</h3>

<p>Bates, Douglas, Martin Maechler, Ben Bolker, Steve Walker (2015).
Fitting Linear Mixed-Effects Models Using lme4. Journal of
Statistical Software, 67(1), 1-48. <a href="https://doi.org/10.18637/jss.v067.i01">doi:10.18637/jss.v067.i01</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simulate Data -----------------------------------------------------------
set.seed(100)
N &lt;- 100
beta &lt;- c(0, 0.5, 1.2)
tau.sq &lt;- 1 
p &lt;- length(beta)
X &lt;- matrix(1, nrow = N, ncol = p)
if (p &gt; 1) {
  for (i in 2:p) {
    X[, i] &lt;- rnorm(N)
  } # i
}
mu &lt;- X[, 1] * beta[1] + X[, 2] * beta[2] + X[, 3] * beta[3]
y &lt;- rnorm(N, mu, sqrt(tau.sq))
# Replicate y n.samples times and add a small amount of noise that corresponds
# to uncertainty from a first stage model.
n.samples &lt;- 1000
y &lt;- matrix(y, n.samples, N, byrow = TRUE)
y &lt;- y + rnorm(length(y), 0, 0.25)

# Package data for use with postHocLM -------------------------------------
colnames(X) &lt;- c('int', 'cov.1', 'cov.2')
data.list &lt;- list(y = y, covs = X)
data &lt;- data.list
inits &lt;- list(beta = 0, tau.sq = 1)
priors &lt;- list(beta.normal = list(mean = 0, var = 10000),
               tau.sq.ig = c(0.001, 0.001))

# Run the model -----------------------------------------------------------
out &lt;- postHocLM(formula = ~ cov.1 + cov.2, 
                 inits = inits, 
                 data = data.list, 
                 priors = priors, 
                 verbose = FALSE, 
                 n.chains = 1)
summary(out)
</code></pre>

<hr>
<h2 id='ppcOcc'>Function for performing posterior predictive checks</h2><span id='topic+ppcOcc'></span>

<h3>Description</h3>

<p>Function for performing posterior predictive checks on <code>spOccupancy</code> model objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ppcOcc(object, fit.stat, group, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ppcOcc_+3A_object">object</code></td>
<td>
<p>an object of class <code>PGOcc</code>, <code>spPGOcc</code>, <code>msPGOcc</code>, 
<code>spMsPGOcc</code>, <code>intPGOcc</code>, <code>spIntPGOcc</code>, <code>lfMsPGOcc</code>, <code>sfMsPGOcc</code>, 
<code>tPGOcc</code>, <code>stPGOcc</code>, <code>svcPGOcc</code>, <code>svcMsPGOcc</code>, <code>tMsPGOcc</code>, 
<code>stMsPGOcc</code>, <code>svcTMsPGOcc</code>.</p>
</td></tr>
<tr><td><code id="ppcOcc_+3A_fit.stat">fit.stat</code></td>
<td>
<p>a quoted keyword that specifies the fit statistic
to use in the posterior predictive check. Supported fit statistics are
<code>"freeman-tukey"</code> and <code>"chi-squared"</code>.</p>
</td></tr>
<tr><td><code id="ppcOcc_+3A_group">group</code></td>
<td>
<p>a positive integer indicating the way to group the
detection-nondetection data for the posterior predictive check. Value 
1 will group values by row (site) and value 2 will group values by 
column (replicate).</p>
</td></tr> 
<tr><td><code id="ppcOcc_+3A_...">...</code></td>
<td>
<p>currently no additional arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Standard GoF assessments are not valid for binary data, and posterior
predictive checks must be performed on some sort of binned data. 
</p>


<h3>Value</h3>

<p>An object of class <code>ppcOcc</code> that is a list comprised of: 
</p>
<table>
<tr><td><code>fit.y</code></td>
<td>
<p>a numeric vector of posterior samples for the 
fit statistic calculated on the observed data when <code>object</code> is 
of class <code>PGOcc</code>, <code>spPGOcc</code>, or <code>svcPGOcc</code>. When <code>object</code> is of 
class <code>msPGOcc</code>, <code>spMsPGOcc</code>, <code>lfMsPGOcc</code>, 
<code>sfMsPGOcc</code>, or <code>svcMsPGOcc</code> 
this is a numeric matrix with rows corresponding to posterior samples
and columns corresponding to species. When <code>object</code> is of class
<code>intPGOcc</code> or <code>spIntPGOcc</code>, this is a list, with each element 
of the list being a vector of posterior samples for each data set. 
When <code>object</code> is of class <code>tPGOcc</code> or <code>stPGOcc</code>, this is a
numeric matrix with rows corresponding to posterior samples and columns 
corresponding to primary sampling periods. When <code>object</code> is of class <code>tMsPGOcc</code>, 
<code>stMsPGOcc</code>, or <code>svcTMsPGOcc</code>, this is a three-dimensional array with dimensions
corresponding to MCMC sample, species, and primary time period. </p>
</td></tr>
<tr><td><code>fit.y.rep</code></td>
<td>
<p>a numeric vector of posterior samples for the 
fit statistic calculated on a replicate data set generated from the 
model when <code>object</code> is of class <code>PGOcc</code>, <code>spPGOcc</code>, or <code>svcPGOcc</code>. 
When <code>object</code> is of class <code>msPGOcc</code>, <code>spMsPGOcc</code>, 
<code>lfMsPGOcc</code>, <code>sfMsPGOcc</code>, or <code>svcMsPGOcc</code>
this is a numeric matrix with rows corresponding to posterior samples
and columns corresponding to species. When <code>object</code> is of class
<code>intPGOcc</code> or <code>spIntPGOcc</code>, this is a list, with each element 
of the list being a vector of posterior samples for each data set. 
When <code>object</code> is of class <code>tPGOcc</code> or <code>stPGOcc</code>, this is a
numeric matrix with rows corresponding to posterior samples and columns 
corresponding to primary sampling periods. When <code>object</code> is of class <code>tMsPGOcc</code>, 
<code>stMsPGOcc</code>, or <code>svcTMsPGOcc</code>, this is a three-dimensional array with dimensions
corresponding to MCMC sample, species, and primary time period. </p>
</td></tr>
<tr><td><code>fit.y.group.quants</code></td>
<td>
<p>a matrix consisting of posterior quantiles
for the fit statistic using the observed data for each unique element
the fit statistic is calculated for (i.e., sites when group = 1, 
replicates when group = 2) when <code>object</code> is of class <code>PGOcc</code>, <code>spPGOcc</code>, or <code>svcPGOcc</code>. 
When <code>object</code> is of class <code>msPGOcc</code>, <code>spMsPGOcc</code>, 
<code>lfMsPGOcc</code>, <code>sfMsPGOcc</code>, <code>svcMsPGOcc</code>, this is a three-dimensional
array with the additional dimension corresponding to species. When <code>object</code> is 
of class <code>intPGOcc</code> or <code>spIntPGOcc</code>, this is a list, with each element 
consisting of the posterior quantile matrix for each data set. When <code>object</code> 
is of class <code>tPGOcc</code> or <code>stPGOcc</code>, this is a three-dimensional array 
with the additional dimension corresponding to primary sampling periods. When <code>object</code>
is of class <code>tMsPGOcc</code>, <code>stMsPGOcc</code>, <code>svcTMsPGOcc</code>, this is a four-dimensional array
with dimensions corresponding to quantile, species, grouping element, and primary time period.</p>
</td></tr>
<tr><td><code>fit.y.rep.group.quants</code></td>
<td>
<p>a matrix consisting of posterior quantiles
for the fit statistic using the model replicated data for each unique element
the fit statistic is calculated for (i.e., sites when group = 1, 
replicates when group = 2) when <code>object</code> is of class <code>PGOcc</code>, <code>spPGOcc</code>, <code>svcPGOcc</code>. 
When <code>object</code> is of class <code>msPGOcc</code>, 
<code>spMsPGOcc</code>, <code>lfMsPGOcc</code>, <code>sfMsPGOcc</code>, or <code>svcMsPGOcc</code>, 
this is a three-dimensional
array with the additional dimension corresponding to species. When <code>object</code> is 
of class <code>intPGOcc</code> or <code>spIntPGOcc</code>, this is a list, with each element 
consisting of the posterior quantile matrix for each data set. When <code>object</code> 
is of class <code>tPGOcc</code> or <code>stPGOcc</code>, this is a three-dimensional array 
with the additional dimension corresponding to primary sampling periods. When <code>object</code>
is of class <code>tMsPGOcc</code>, <code>stMsPGOcc</code>, <code>svcTMsPGOcc</code>, this is a four-dimensional array
with dimensions corresponding to quantile, species, grouping element, and primary time period.</p>
</td></tr>
</table>
<p>The return object will include additional objects used for 
standard extractor functions. 
</p>


<h3>Author(s)</h3>

<p>Jeffrey W. Doser <a href="mailto:doserjef@msu.edu">doserjef@msu.edu</a>, <br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(400)
# Simulate Data -----------------------------------------------------------
J.x &lt;- 8
J.y &lt;- 8
J &lt;- J.x * J.y
n.rep &lt;- sample(2:4, J, replace = TRUE)
beta &lt;- c(0.5, -0.15)
p.occ &lt;- length(beta)
alpha &lt;- c(0.7, 0.4)
p.det &lt;- length(alpha)
dat &lt;- simOcc(J.x = J.x, J.y = J.y, n.rep = n.rep, beta = beta, alpha = alpha,
              sp = FALSE)
occ.covs &lt;- dat$X[, 2, drop = FALSE]
colnames(occ.covs) &lt;- c('occ.cov')
det.covs &lt;- list(det.cov = dat$X.p[, , 2])
# Data bundle
data.list &lt;- list(y = dat$y, 
                  occ.covs = occ.covs, 
                  det.covs = det.covs)

# Priors
prior.list &lt;- list(beta.normal = list(mean = 0, var = 2.72),
                   alpha.normal = list(mean = 0, var = 2.72))
# Initial values
inits.list &lt;- list(alpha = 0, beta = 0,
                   z = apply(data.list$y, 1, max, na.rm = TRUE))

n.samples &lt;- 5000
n.report &lt;- 1000

out &lt;- PGOcc(occ.formula = ~ occ.cov, 
             det.formula = ~ det.cov, 
             data = data.list, 
             inits = inits.list,
             n.samples = n.samples,
             priors = prior.list,
             n.omp.threads = 1,
             verbose = TRUE,
             n.report = n.report, 
             n.burn = 4000, 
             n.thin = 1)

# Posterior predictive check
ppc.out &lt;- ppcOcc(out, fit.stat = 'chi-squared', group = 1)
summary(ppc.out)
</code></pre>

<hr>
<h2 id='predict.intMsPGOcc'>Function for prediction at new locations for integrated multi-species occupancy models</h2><span id='topic+predict.intMsPGOcc'></span>

<h3>Description</h3>

<p>The function <code>predict</code> collects posterior predictive samples for a set of new locations given an object of class 'intMsPGOcc'. Prediction is currently possible only for the latent occupancy state.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'intMsPGOcc'
predict(object, X.0, ignore.RE = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.intMsPGOcc_+3A_object">object</code></td>
<td>
<p>an object of class intMsPGOcc</p>
</td></tr>
<tr><td><code id="predict.intMsPGOcc_+3A_x.0">X.0</code></td>
<td>
<p>the design matrix of covariates at the prediction locations. This should include a column of 1s for the intercept if an intercept is included in the model. If random effects are included in the occupancy (or detection if <code>type = 'detection'</code>) portion of the model, the levels of the random effects at the new locations should be included as a column in the design matrix. The ordering of the levels should match the ordering used to fit the data in <code>intMsPGOcc</code>. Columns should correspond to the order of how covariates were specified in the corresponding formula argument of <code>intMsPGOcc</code>. Column names of the random effects must match the name of the random effects, if specified in the corresponding formula argument of <code>intMsPGOcc</code>.</p>
</td></tr>
<tr><td><code id="predict.intMsPGOcc_+3A_ignore.re">ignore.RE</code></td>
<td>
<p>a logical value indicating whether to include unstructured random effects for prediction. If TRUE, random effects will be ignored and prediction will only use the fixed effects. If FALSE, random effects will be included in the prediction for both observed and unobserved levels of the random effect.</p>
</td></tr>
<tr><td><code id="predict.intMsPGOcc_+3A_...">...</code></td>
<td>
<p>currently no additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list object of class <code>predict.intMsPGOcc</code> consisting of:   
</p>
<table>
<tr><td><code>psi.0.samples</code></td>
<td>
<p>a three-dimensional array of posterior predictive samples for the
latent occurrence probability values.</p>
</td></tr>
<tr><td><code>z.0.samples</code></td>
<td>
<p>a three-dimensional array of posterior predictive samples for the
latent occurrence values.</p>
</td></tr>
</table>
<p>The return object will include additional objects used for standard 
extractor functions. 
</p>


<h3>Note</h3>

<p>When <code>ignore.RE = FALSE</code>, both sampled levels and non-sampled levels of random effects are supported for prediction. For sampled levels, the posterior distribution for the random intercept corresponding to that level of the random effect will be used in the prediction. For non-sampled levels, random values are drawn from a normal distribution using the posterior samples of the random effect variance, which results in fully propagated uncertainty in predictions with models that incorporate random effects.
</p>


<h3>Author(s)</h3>

<p>Jeffrey W. Doser <a href="mailto:doserjef@msu.edu">doserjef@msu.edu</a>, <br />
Andrew O. Finley <a href="mailto:finleya@msu.edu">finleya@msu.edu</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(91)
J.x &lt;- 10
J.y &lt;- 10
# Total number of data sources across the study region
J.all &lt;- J.x * J.y
# Number of data sources.
n.data &lt;- 2
# Sites for each data source.
J.obs &lt;- sample(ceiling(0.2 * J.all):ceiling(0.5 * J.all), n.data, replace = TRUE)
n.rep &lt;- list()
n.rep[[1]] &lt;- rep(3, J.obs[1])
n.rep[[2]] &lt;- rep(4, J.obs[2])

# Number of species observed in each data source
N &lt;- c(8, 3)

# Community-level covariate effects
# Occurrence
beta.mean &lt;- c(0.2, 0.5)
p.occ &lt;- length(beta.mean)
tau.sq.beta &lt;- c(0.4, 0.3)
# Detection
# Detection covariates
alpha.mean &lt;- list()
tau.sq.alpha &lt;- list()
# Number of detection parameters in each data source
p.det.long &lt;- c(4, 3)
for (i in 1:n.data) {
  alpha.mean[[i]] &lt;- runif(p.det.long[i], -1, 1)
  tau.sq.alpha[[i]] &lt;- runif(p.det.long[i], 0.1, 1)
}
# Random effects
psi.RE &lt;- list()
p.RE &lt;- list()
beta &lt;- matrix(NA, nrow = max(N), ncol = p.occ)
for (i in 1:p.occ) {
  beta[, i] &lt;- rnorm(max(N), beta.mean[i], sqrt(tau.sq.beta[i]))
}
alpha &lt;- list()
for (i in 1:n.data) {
  alpha[[i]] &lt;- matrix(NA, nrow = N[i], ncol = p.det.long[i])
  for (t in 1:p.det.long[i]) {
    alpha[[i]][, t] &lt;- rnorm(N[i], alpha.mean[[i]][t], sqrt(tau.sq.alpha[[i]])[t])
  }
}
sp &lt;- FALSE
factor.model &lt;- FALSE
# Simulate occupancy data
dat &lt;- simIntMsOcc(n.data = n.data, J.x = J.x, J.y = J.y,
		   J.obs = J.obs, n.rep = n.rep, N = N, beta = beta, alpha = alpha,
	           psi.RE = psi.RE, p.RE = p.RE, sp = sp, factor.model = factor.model,
                   n.factors = n.factors)
J &lt;- nrow(dat$coords.obs)
y &lt;- dat$y
X &lt;- dat$X.obs
X.p &lt;- dat$X.p
X.re &lt;- dat$X.re.obs
X.p.re &lt;- dat$X.p.re
sites &lt;- dat$sites
species &lt;- dat$species

# Package all data into a list
occ.covs &lt;- cbind(X)
colnames(occ.covs) &lt;- c('int', 'occ.cov.1')
#colnames(occ.covs) &lt;- c('occ.cov')
det.covs &lt;- list()
# Add covariates one by one
det.covs[[1]] &lt;- list(det.cov.1.1 = X.p[[1]][, , 2],
		      det.cov.1.2 = X.p[[1]][, , 3],
		      det.cov.1.3 = X.p[[1]][, , 4])
det.covs[[2]] &lt;- list(det.cov.2.1 = X.p[[2]][, , 2],
		      det.cov.2.2 = X.p[[2]][, , 3])

data.list &lt;- list(y = y,
		  occ.covs = occ.covs,
		  det.covs = det.covs,
                  sites = sites,
                  species = species)
# Take a look at the data.list structure for integrated multi-species
# occupancy models.
# Priors
prior.list &lt;- list(beta.comm.normal = list(mean = 0,
				      var = 2.73),

		   alpha.comm.normal = list(mean = list(0, 0),
			                    var = list(2.72, 2.72)),
                   tau.sq.beta.ig = list(a = 0.1, b = 0.1),
                   tau.sq.alpha.ig = list(a = list(0.1, 0.1),
					  b = list(0.1, 0.1)))
inits.list &lt;- list(alpha.comm = list(0, 0),
		   beta.comm = 0,
		   tau.sq.beta = 1,
		   tau.sq.alpha = list(1, 1),
                   alpha = list(a = matrix(rnorm(p.det.long[1] * N[1]), N[1], p.det.long[1]),
 				b = matrix(rnorm(p.det.long[2] * N[2]), N[2], p.det.long[2])),
		   beta = 0)

# Fit the model.
out &lt;- intMsPGOcc(occ.formula = ~ occ.cov.1,
                  det.formula = list(f.1 = ~ det.cov.1.1 + det.cov.1.2 + det.cov.1.3,
                                     f.2 = ~ det.cov.2.1 + det.cov.2.2),
		 inits = inits.list,
		 priors = prior.list,
	         data = data.list,
	         n.samples = 100,
                 n.omp.threads = 1,
	         verbose = TRUE,
	         n.report = 10,
	         n.burn = 50,
	         n.thin = 1,
	         n.chains = 1)
#Predict at new locations. 
X.0 &lt;- dat$X.pred
psi.0 &lt;- dat$psi.pred
out.pred &lt;- predict(out, X.0, ignore.RE = TRUE)

# Create prediction for one species. 
curr.sp &lt;- 2
psi.hat.quants &lt;- apply(out.pred$psi.0.samples[,curr.sp, ], 
			2, quantile, c(0.025, 0.5, 0.975))
plot(psi.0[curr.sp, ], psi.hat.quants[2, ], pch = 19, xlab = 'True',
     ylab = 'Predicted', ylim = c(min(psi.hat.quants), max(psi.hat.quants)), 
     main = paste("Species ", curr.sp, sep = ''))
segments(psi.0[curr.sp, ], psi.hat.quants[1, ], psi.0[curr.sp, ], psi.hat.quants[3, ])
lines(psi.0[curr.sp, ], psi.0[curr.sp, ])
</code></pre>

<hr>
<h2 id='predict.intPGOcc'>Function for prediction at new locations for single-species integrated occupancy models</h2><span id='topic+predict.intPGOcc'></span>

<h3>Description</h3>

<p>The function <code>predict</code> collects posterior predictive samples for a set of new locations given an object of class 'intPGOcc'. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'intPGOcc'
predict(object, X.0, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.intPGOcc_+3A_object">object</code></td>
<td>
<p>an object of class intPGOcc</p>
</td></tr>
<tr><td><code id="predict.intPGOcc_+3A_x.0">X.0</code></td>
<td>
<p>the design matrix for prediction locations. This should include a column of 1s for the intercept. Covariates should have the same column names as those used when fitting the model with <code>intPGOcc</code>.</p>
</td></tr>
<tr><td><code id="predict.intPGOcc_+3A_...">...</code></td>
<td>
<p>currently no additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>predict.intPGOcc</code> that is a list comprised of: 
</p>
<table>
<tr><td><code>psi.0.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior predictive samples for the
latent occurrence probability values.</p>
</td></tr>
<tr><td><code>z.0.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior predictive samples for the
latent occurrence values.</p>
</td></tr>
</table>
<p>The return object will include additional objects used for standard 
extractor functions. 
</p>


<h3>Author(s)</h3>

<p>Jeffrey W. Doser <a href="mailto:doserjef@msu.edu">doserjef@msu.edu</a>, <br />
Andrew O. Finley <a href="mailto:finleya@msu.edu">finleya@msu.edu</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1008)

# Simulate Data -----------------------------------------------------------
J.x &lt;- 10
J.y &lt;- 10
J.all &lt;- J.x * J.y
# Number of data sources.
n.data &lt;- 4
# Sites for each data source. 
J.obs &lt;- sample(ceiling(0.2 * J.all):ceiling(0.5 * J.all), n.data, replace = TRUE)
# Replicates for each data source.
n.rep &lt;- list()
for (i in 1:n.data) {
  n.rep[[i]] &lt;- sample(1:4, size = J.obs[i], replace = TRUE)
}
# Occupancy covariates
beta &lt;- c(0.5, 1)
p.occ &lt;- length(beta)
# Detection covariates
alpha &lt;- list()
for (i in 1:n.data) {
  alpha[[i]] &lt;- runif(2, -1, 1)
}
p.det.long &lt;- sapply(alpha, length)
p.det &lt;- sum(p.det.long)

# Simulate occupancy data. 
dat &lt;- simIntOcc(n.data = n.data, J.x = J.x, J.y = J.y, J.obs = J.obs, 
                 n.rep = n.rep, beta = beta, alpha = alpha, sp = FALSE)

y &lt;- dat$y
X &lt;- dat$X.obs
X.p &lt;- dat$X.p
sites &lt;- dat$sites

# Package all data into a list
occ.covs &lt;- X[, 2, drop = FALSE]
colnames(occ.covs) &lt;- c('occ.cov')
det.covs &lt;- list()
# Add covariates one by one
det.covs[[1]] &lt;- list(det.cov.1.1 = X.p[[1]][, , 2]) 
det.covs[[2]] &lt;- list(det.cov.2.1 = X.p[[2]][, , 2]) 
det.covs[[3]] &lt;- list(det.cov.3.1 = X.p[[3]][, , 2]) 
det.covs[[4]] &lt;- list(det.cov.4.1 = X.p[[4]][, , 2]) 
data.list &lt;- list(y = y, 
                  occ.covs = occ.covs,
                  det.covs = det.covs, 
                  sites = sites)

J &lt;- length(dat$z.obs)
# Initial values
inits.list &lt;- list(alpha = list(0, 0, 0, 0), 
                   beta = 0, 
                   z = rep(1, J))
# Priors
prior.list &lt;- list(beta.normal = list(mean = 0, var = 2.72), 
                   alpha.normal = list(mean = list(0, 0, 0, 0), 
                                       var = list(2.72, 2.72, 2.72, 2.72)))
n.samples &lt;- 5000
out &lt;- intPGOcc(occ.formula = ~ occ.cov, 
                det.formula = list(f.1 = ~ det.cov.1.1, 
                                   f.2 = ~ det.cov.2.1, 
                                   f.3 = ~ det.cov.3.1, 
                                   f.4 = ~ det.cov.4.1), 
                data = data.list,
                inits = inits.list,
                n.samples = n.samples, 
                priors = prior.list, 
                n.omp.threads = 1, 
                verbose = TRUE, 
                n.report = 1000, 
                n.burn = 4000, 
                n.thin = 1)

summary(out)

# Prediction
X.0 &lt;- dat$X.pred
psi.0 &lt;- dat$psi.pred

out.pred &lt;- predict(out, X.0)
psi.hat.quants &lt;- apply(out.pred$psi.0.samples, 2, quantile, c(0.025, 0.5, 0.975))
plot(psi.0, psi.hat.quants[2, ], pch = 19, xlab = 'True', 
     ylab = 'Fitted', ylim = c(min(psi.hat.quants), max(psi.hat.quants)))
segments(psi.0, psi.hat.quants[1, ], psi.0, psi.hat.quants[3, ])
lines(psi.0, psi.0)
</code></pre>

<hr>
<h2 id='predict.lfJSDM'>Function for prediction at new locations for latent factor joint species distribution models</h2><span id='topic+predict.lfJSDM'></span>

<h3>Description</h3>

<p>The function <code>predict</code> collects posterior predictive samples for a set of new locations given an object of class 'lfJSDM'. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lfJSDM'
predict(object, X.0, coords.0, 
        ignore.RE = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.lfJSDM_+3A_object">object</code></td>
<td>
<p>an object of class lfJSDM</p>
</td></tr>
<tr><td><code id="predict.lfJSDM_+3A_x.0">X.0</code></td>
<td>
<p>the design matrix of covariates at the prediction locations. This should include a column of 1s for the intercept if an intercept is included in the model. If random effects are included in the model, the levels of the random effects at the new locations should be included as a column in the design matrix. The ordering of the levels should match the ordering used to fit the data in <code>lfJSDM</code>. Columns should correspond to the order of how covariates were specified in the formula argument of <code>lfJSDM</code>. Column names of the random effects must match the name of the random effects, if specified in the formula argument of <code>lfJSDM</code>.</p>
</td></tr>
<tr><td><code id="predict.lfJSDM_+3A_coords.0">coords.0</code></td>
<td>
<p>the spatial coordinates corresponding to <code>X.0</code>. Note that <code>spOccupancy</code> assumes coordinates are specified 
in a projected coordinate system.</p>
</td></tr>
<tr><td><code id="predict.lfJSDM_+3A_ignore.re">ignore.RE</code></td>
<td>
<p>a logical value indicating whether to include unstructured random effects for prediction. If TRUE, random effects will be ignored and prediction will only use the fixed effects. If FALSE, random effects will be included in the prediction for both observed and unobserved levels of the random effect.</p>
</td></tr>
<tr><td><code id="predict.lfJSDM_+3A_...">...</code></td>
<td>
<p>currently no additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list object of class <code>predict.lfJSDM</code> that consists of:  
</p>
<table>
<tr><td><code>psi.0.samples</code></td>
<td>
<p>a three-dimensional array of posterior predictive samples for the
latent occurrence probability values.</p>
</td></tr>
<tr><td><code>z.0.samples</code></td>
<td>
<p>a three-dimensional array of posterior predictive samples for the
latent occurrence values.</p>
</td></tr>
<tr><td><code>w.0.samples</code></td>
<td>
<p>a three-dimensional array of posterior predictive samples
for the latent factors.</p>
</td></tr>
</table>
<p>The return object will include additional objects used for standard 
extractor functions. 
</p>


<h3>Note</h3>

<p>When <code>ignore.RE = FALSE</code>, both sampled levels and non-sampled levels of random effects are supported for prediction. For sampled levels, the posterior distribution for the random intercept corresponding to that level of the random effect will be used in the prediction. For non-sampled levels, random values are drawn from a normal distribution using the posterior samples of the random effect variance, which results in fully propagated uncertainty in predictions with models that incorporate random effects.
</p>


<h3>Author(s)</h3>

<p>Jeffrey W. Doser <a href="mailto:doserjef@msu.edu">doserjef@msu.edu</a>, <br />
Andrew O. Finley <a href="mailto:finleya@msu.edu">finleya@msu.edu</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(400)
J.x &lt;- 8
J.y &lt;- 8
J &lt;- J.x * J.y
n.rep&lt;- sample(2:4, size = J, replace = TRUE)
N &lt;- 6
# Community-level covariate effects
# Occurrence
beta.mean &lt;- c(0.2, 0.5)
p.occ &lt;- length(beta.mean)
tau.sq.beta &lt;- c(0.6, 0.3)
# Detection
alpha.mean &lt;- c(0.5, 0.2, -0.1)
tau.sq.alpha &lt;- c(0.2, 0.3, 1)
p.det &lt;- length(alpha.mean)
# Draw species-level effects from community means.
beta &lt;- matrix(NA, nrow = N, ncol = p.occ)
alpha &lt;- matrix(NA, nrow = N, ncol = p.det)
for (i in 1:p.occ) {
  beta[, i] &lt;- rnorm(N, beta.mean[i], sqrt(tau.sq.beta[i]))
}
for (i in 1:p.det) {
  alpha[, i] &lt;- rnorm(N, alpha.mean[i], sqrt(tau.sq.alpha[i]))
}

n.factors &lt;- 3
dat &lt;- simMsOcc(J.x = J.x, J.y = J.y, n.rep = n.rep, N = N, beta = beta, alpha = alpha,
                sp = FALSE, factor.model = TRUE, n.factors = n.factors)
n.samples &lt;- 5000
# Split into fitting and prediction data set
pred.indx &lt;- sample(1:J, round(J * .25), replace = FALSE)
# Summarize the multiple replicates into a single value for use in a JSDM
y &lt;- apply(dat$y[, -pred.indx, ], c(1, 2), max, na.rm = TRUE)
# Covariates
X &lt;- dat$X[-pred.indx, ]
# Spatial coordinates
coords &lt;- dat$coords[-pred.indx, ]
# Prediction values
X.0 &lt;- dat$X[pred.indx, ]
psi.0 &lt;- dat$psi[, pred.indx]
coords.0 &lt;- dat$coords[pred.indx, ]
# Package all data into a list
covs &lt;- X[, 2, drop = FALSE]
colnames(covs) &lt;- c('occ.cov')
data.list &lt;- list(y = y, 
                  covs = covs,
                  coords = coords)

# Occupancy initial values
prior.list &lt;- list(beta.comm.normal = list(mean = 0, var = 2.72), 
                   tau.sq.beta.ig = list(a = 0.1, b = 0.1))
# Initial values
lambda.inits &lt;- matrix(0, N, n.factors)
diag(lambda.inits) &lt;- 1
lambda.inits[lower.tri(lambda.inits)] &lt;- rnorm(sum(lower.tri(lambda.inits)))
inits.list &lt;- list(alpha.comm = 0, 
                   beta.comm = 0, 
                   beta = 0, 
                   tau.sq.beta = 1, 
                   lambda = lambda.inits)

out &lt;- lfJSDM(formula = ~ occ.cov, 
              data = data.list, 
              inits = inits.list, 
              n.samples = n.samples, 
              n.factors = 3, 
              priors = prior.list, 
              n.omp.threads = 1, 
              verbose = TRUE, 
              n.report = 1000, 
              n.burn = 4000)

summary(out)

# Predict at new locations ------------------------------------------------
out.pred &lt;- predict(out, X.0, coords.0)
</code></pre>

<hr>
<h2 id='predict.lfMsPGOcc'>Function for prediction at new locations for latent factor multi-species occupancy models</h2><span id='topic+predict.lfMsPGOcc'></span>

<h3>Description</h3>

<p>The function <code>predict</code> collects posterior predictive samples for a set of new locations given an object of class 'lfMsPGOcc'. Prediction is possible for both the latent occupancy state as well as detection.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lfMsPGOcc'
predict(object, X.0, coords.0, 
        ignore.RE = FALSE, type = 'occupancy', ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.lfMsPGOcc_+3A_object">object</code></td>
<td>
<p>an object of class lfMsPGOcc</p>
</td></tr>
<tr><td><code id="predict.lfMsPGOcc_+3A_x.0">X.0</code></td>
<td>
<p>the design matrix of covariates at the prediction locations. This should include a column of 1s for the intercept if an intercept is included in the model. If random effects are included in the occupancy (or detection if <code>type = 'detection'</code>) portion of the model, the levels of the random effects at the new locations should be included as a column in the design matrix. The ordering of the levels should match the ordering used to fit the data in <code>lfMsPGOcc</code>. Columns should correspond to the order of how covariates were specified in the corresponding formula argument of <code>lfMsPGOcc</code>. Column names of the random effects must match the name of the random effects, if specified in the corresponding formula argument of <code>lfMsPGOcc</code>.</p>
</td></tr>
<tr><td><code id="predict.lfMsPGOcc_+3A_coords.0">coords.0</code></td>
<td>
<p>the spatial coordinates corresponding to <code>X.0</code>. Note that <code>spOccupancy</code> assumes coordinates are specified 
in a projected coordinate system.</p>
</td></tr>
<tr><td><code id="predict.lfMsPGOcc_+3A_ignore.re">ignore.RE</code></td>
<td>
<p>a logical value indicating whether to include unstructured random effects for prediction. If TRUE, random effects will be ignored and prediction will only use the fixed effects. If FALSE, random effects will be included in the prediction for both observed and unobserved levels of the random effect.</p>
</td></tr>
<tr><td><code id="predict.lfMsPGOcc_+3A_...">...</code></td>
<td>
<p>currently no additional arguments</p>
</td></tr>
<tr><td><code id="predict.lfMsPGOcc_+3A_type">type</code></td>
<td>
<p>a quoted keyword indicating what type of prediction to produce. Valid keywords are 'occupancy' to predict latent occupancy probability and latent occupancy values (this is the default), or 'detection' to predict detection probability given new values of detection covariates.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list object of class <code>predict.lfMsPGOcc</code>. When <code>type = 'occupancy'</code>, the list consists of:  
</p>
<table>
<tr><td><code>psi.0.samples</code></td>
<td>
<p>a three-dimensional array of posterior predictive samples for the
latent occurrence probability values.</p>
</td></tr>
<tr><td><code>z.0.samples</code></td>
<td>
<p>a three-dimensional array of posterior predictive samples for the
latent occurrence values.</p>
</td></tr>
<tr><td><code>w.0.samples</code></td>
<td>
<p>a three-dimensional array of posterior predictive samples
for the latent factors.</p>
</td></tr>
</table>
<p>When <code>type = 'detection'</code>, the list consists of: 
</p>
<table>
<tr><td><code>p.0.samples</code></td>
<td>
<p>a three-dimensional array of posterior predictive samples for the 
detection probability values.</p>
</td></tr>
</table>
<p>The return object will include additional objects used for standard 
extractor functions. 
</p>


<h3>Note</h3>

<p>When <code>ignore.RE = FALSE</code>, both sampled levels and non-sampled levels of random effects are supported for prediction. For sampled levels, the posterior distribution for the random intercept corresponding to that level of the random effect will be used in the prediction. For non-sampled levels, random values are drawn from a normal distribution using the posterior samples of the random effect variance, which results in fully propagated uncertainty in predictions with models that incorporate random effects.
</p>


<h3>Author(s)</h3>

<p>Jeffrey W. Doser <a href="mailto:doserjef@msu.edu">doserjef@msu.edu</a>, <br />
Andrew O. Finley <a href="mailto:finleya@msu.edu">finleya@msu.edu</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(400)
J.x &lt;- 8
J.y &lt;- 8
J &lt;- J.x * J.y
n.rep&lt;- sample(2:4, size = J, replace = TRUE)
N &lt;- 6
# Community-level covariate effects
# Occurrence
beta.mean &lt;- c(0.2, 0.5)
p.occ &lt;- length(beta.mean)
tau.sq.beta &lt;- c(0.6, 0.3)
# Detection
alpha.mean &lt;- c(0.5, 0.2, -0.1)
tau.sq.alpha &lt;- c(0.2, 0.3, 1)
p.det &lt;- length(alpha.mean)
# Draw species-level effects from community means.
beta &lt;- matrix(NA, nrow = N, ncol = p.occ)
alpha &lt;- matrix(NA, nrow = N, ncol = p.det)
for (i in 1:p.occ) {
  beta[, i] &lt;- rnorm(N, beta.mean[i], sqrt(tau.sq.beta[i]))
}
for (i in 1:p.det) {
  alpha[, i] &lt;- rnorm(N, alpha.mean[i], sqrt(tau.sq.alpha[i]))
}

n.factors &lt;- 3
dat &lt;- simMsOcc(J.x = J.x, J.y = J.y, n.rep = n.rep, N = N, beta = beta, alpha = alpha,
                sp = FALSE, factor.model = TRUE, n.factors = n.factors)
n.samples &lt;- 5000
# Split into fitting and prediction data set
pred.indx &lt;- sample(1:J, round(J * .25), replace = FALSE)
y &lt;- dat$y[, -pred.indx, ]
# Occupancy covariates
X &lt;- dat$X[-pred.indx, ]
# Spatial coordinates
coords &lt;- dat$coords[-pred.indx, ]
# Detection covariates
X.p &lt;- dat$X.p[-pred.indx, , ]
# Prediction values
X.0 &lt;- dat$X[pred.indx, ]
psi.0 &lt;- dat$psi[, pred.indx]
coords.0 &lt;- dat$coords[pred.indx, ]
# Package all data into a list
occ.covs &lt;- X[, 2, drop = FALSE]
colnames(occ.covs) &lt;- c('occ.cov')
det.covs &lt;- list(det.cov.1 = X.p[, , 2], 
                 det.cov.2 = X.p[, , 3])
data.list &lt;- list(y = y, 
                  occ.covs = occ.covs,
                  det.covs = det.covs, 
                  coords = coords)

# Occupancy initial values
prior.list &lt;- list(beta.comm.normal = list(mean = 0, var = 2.72), 
                   alpha.comm.normal = list(mean = 0, var = 2.72), 
                   tau.sq.beta.ig = list(a = 0.1, b = 0.1), 
                   tau.sq.alpha.ig = list(a = 0.1, b = 0.1))
# Initial values
lambda.inits &lt;- matrix(0, N, n.factors)
diag(lambda.inits) &lt;- 1
lambda.inits[lower.tri(lambda.inits)] &lt;- rnorm(sum(lower.tri(lambda.inits)))
inits.list &lt;- list(alpha.comm = 0, 
                   beta.comm = 0, 
                   beta = 0, 
                   alpha = 0,
                   tau.sq.beta = 1, 
                   tau.sq.alpha = 1, 
                   lambda = lambda.inits, 
                   z = apply(y, c(1, 2), max, na.rm = TRUE))

out &lt;- lfMsPGOcc(occ.formula = ~ occ.cov, 
                 det.formula = ~ det.cov.1 + det.cov.2, 
                 data = data.list, 
                 inits = inits.list, 
                 n.samples = n.samples, 
                 n.factors = 3, 
                 priors = prior.list, 
                 n.omp.threads = 1, 
                 verbose = TRUE, 
                 n.report = 1000, 
                 n.burn = 4000)

summary(out, level = 'community')

# Predict at new locations ------------------------------------------------
out.pred &lt;- predict(out, X.0, coords.0)
</code></pre>

<hr>
<h2 id='predict.msPGOcc'>Function for prediction at new locations for multi-species occupancy models</h2><span id='topic+predict.msPGOcc'></span>

<h3>Description</h3>

<p>The function <code>predict</code> collects posterior predictive samples for a set of new locations given an object of class 'msPGOcc'. Prediction is possible for both the latent occupancy state as well as detection.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'msPGOcc'
predict(object, X.0, ignore.RE = FALSE, type = 'occupancy', ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.msPGOcc_+3A_object">object</code></td>
<td>
<p>an object of class msPGOcc</p>
</td></tr>
<tr><td><code id="predict.msPGOcc_+3A_x.0">X.0</code></td>
<td>
<p>the design matrix of covariates at the prediction locations. This should include a column of 1s for the intercept if an intercept is included in the model. If random effects are included in the occupancy (or detection if <code>type = 'detection'</code>) portion of the model, the levels of the random effects at the new locations should be included as a column in the design matrix. The ordering of the levels should match the ordering used to fit the data in <code>msPGOcc</code>. Columns should correspond to the order of how covariates were specified in the corresponding formula argument of <code>msPGOcc</code>. Column names of the random effects must match the name of the random effects, if specified in the corresponding formula argument of <code>msPGOcc</code>.</p>
</td></tr>
<tr><td><code id="predict.msPGOcc_+3A_ignore.re">ignore.RE</code></td>
<td>
<p>a logical value indicating whether to include unstructured random effects for prediction. If TRUE, random effects will be ignored and prediction will only use the fixed effects. If FALSE, random effects will be included in the prediction for both observed and unobserved levels of the random effect.</p>
</td></tr>
<tr><td><code id="predict.msPGOcc_+3A_...">...</code></td>
<td>
<p>currently no additional arguments</p>
</td></tr>
<tr><td><code id="predict.msPGOcc_+3A_type">type</code></td>
<td>
<p>a quoted keyword indicating what type of prediction to produce. Valid keywords are 'occupancy' to predict latent occupancy probability and latent occupancy values (this is the default), or 'detection' to predict detection probability given new values of detection covariates.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list object of class <code>predict.msPGOcc</code>. When <code>type = 'occupancy'</code>, the list consists of:  
</p>
<table>
<tr><td><code>psi.0.samples</code></td>
<td>
<p>a three-dimensional array of posterior predictive samples for the
latent occurrence probability values.</p>
</td></tr>
<tr><td><code>z.0.samples</code></td>
<td>
<p>a three-dimensional array of posterior predictive samples for the
latent occurrence values.</p>
</td></tr>
</table>
<p>When <code>type = 'detection'</code>, the list consists of: 
</p>
<table>
<tr><td><code>p.0.samples</code></td>
<td>
<p>a three-dimensional array of posterior predictive samples for the 
detection probability values.</p>
</td></tr>
</table>
<p>The return object will include additional objects used for standard 
extractor functions. 
</p>


<h3>Note</h3>

<p>When <code>ignore.RE = FALSE</code>, both sampled levels and non-sampled levels of random effects are supported for prediction. For sampled levels, the posterior distribution for the random intercept corresponding to that level of the random effect will be used in the prediction. For non-sampled levels, random values are drawn from a normal distribution using the posterior samples of the random effect variance, which results in fully propagated uncertainty in predictions with models that incorporate random effects.
</p>


<h3>Author(s)</h3>

<p>Jeffrey W. Doser <a href="mailto:doserjef@msu.edu">doserjef@msu.edu</a>, <br />
Andrew O. Finley <a href="mailto:finleya@msu.edu">finleya@msu.edu</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(400)
J.x &lt;- 8
J.y &lt;- 8
J &lt;- J.x * J.y
n.rep&lt;- sample(2:4, size = J, replace = TRUE)
N &lt;- 6
# Community-level covariate effects
# Occurrence
beta.mean &lt;- c(0.2, 0.5)
p.occ &lt;- length(beta.mean)
tau.sq.beta &lt;- c(0.6, 0.3)
# Detection
alpha.mean &lt;- c(0.5, 0.2, -0.1)
tau.sq.alpha &lt;- c(0.2, 0.3, 1)
p.det &lt;- length(alpha.mean)
# Draw species-level effects from community means.
beta &lt;- matrix(NA, nrow = N, ncol = p.occ)
alpha &lt;- matrix(NA, nrow = N, ncol = p.det)
for (i in 1:p.occ) {
  beta[, i] &lt;- rnorm(N, beta.mean[i], sqrt(tau.sq.beta[i]))
}
for (i in 1:p.det) {
  alpha[, i] &lt;- rnorm(N, alpha.mean[i], sqrt(tau.sq.alpha[i]))
}

dat &lt;- simMsOcc(J.x = J.x, J.y = J.y, n.rep = n.rep, N = N, beta = beta, alpha = alpha,
                sp = FALSE)
n.samples &lt;- 5000
# Split into fitting and prediction data set
pred.indx &lt;- sample(1:J, round(J * .25), replace = FALSE)
y &lt;- dat$y[, -pred.indx, ]
# Occupancy covariates
X &lt;- dat$X[-pred.indx, ]
# Detection covariates
X.p &lt;- dat$X.p[-pred.indx, , ]
# Prediction values
X.0 &lt;- dat$X[pred.indx, ]
psi.0 &lt;- dat$psi[, pred.indx]
# Package all data into a list
occ.covs &lt;- X[, 2, drop = FALSE]
colnames(occ.covs) &lt;- c('occ.cov')
det.covs &lt;- list(det.cov.1 = X.p[, , 2], 
                 det.cov.2 = X.p[, , 3])
data.list &lt;- list(y = y, 
                  occ.covs = occ.covs,
                  det.covs = det.covs)

# Occupancy initial values
prior.list &lt;- list(beta.comm.normal = list(mean = 0, var = 2.72), 
                   alpha.comm.normal = list(mean = 0, var = 2.72), 
                   tau.sq.beta.ig = list(a = 0.1, b = 0.1), 
                   tau.sq.alpha.ig = list(a = 0.1, b = 0.1))
# Initial values
inits.list &lt;- list(alpha.comm = 0, 
                   beta.comm = 0, 
                   beta = 0, 
                   alpha = 0,
                   tau.sq.beta = 1, 
                   tau.sq.alpha = 1, 
                   z = apply(y, c(1, 2), max, na.rm = TRUE))

out &lt;- msPGOcc(occ.formula = ~ occ.cov, 
               det.formula = ~ det.cov.1 + det.cov.2, 
               data = data.list, 
               inits = inits.list, 
               n.samples = n.samples, 
               priors = prior.list, 
               n.omp.threads = 1, 
               verbose = TRUE, 
               n.report = 1000, 
               n.burn = 4000)

summary(out, level = 'community')

# Predict at new locations ------------------------------------------------
out.pred &lt;- predict(out, X.0)
</code></pre>

<hr>
<h2 id='predict.PGOcc'>Function for prediction at new locations for single-species occupancy models</h2><span id='topic+predict.PGOcc'></span>

<h3>Description</h3>

<p>The function <code>predict</code> collects posterior predictive samples for a set of new locations given an object of class 'PGOcc'. Prediction is possible for both the latent occupancy state as well as detection. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'PGOcc'
predict(object, X.0, ignore.RE = FALSE, type = 'occupancy', ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.PGOcc_+3A_object">object</code></td>
<td>
<p>an object of class PGOcc</p>
</td></tr>
<tr><td><code id="predict.PGOcc_+3A_x.0">X.0</code></td>
<td>
<p>the design matrix of covariates at the prediction locations. This should include a column of 1s for the intercept if an intercept is included in the model. If random effects are included in the occupancy (or detection if <code>type = 'detection'</code>) portion of the model, the levels of the random effects at the new locations should be included as a column in the design matrix. The ordering of the levels should match the ordering used to fit the data in <code>PGOcc</code>. Columns should correspond to the order of how covariates were specified in the corresponding formula argument of <code>PGOcc</code>. Column names of the random effects must match the name of the random effects, if specified in the corresponding formula argument of <code>PGOcc</code>.</p>
</td></tr>
<tr><td><code id="predict.PGOcc_+3A_ignore.re">ignore.RE</code></td>
<td>
<p>logical value that specifies whether or not to remove random occurrence (or detection if <code>type = 'detection'</code>) effects from the subsequent predictions. If <code>TRUE</code>, random effects will be included. If <code>FALSE</code>, random effects will be set to 0 and predictions will only be generated from the fixed effects.</p>
</td></tr>
<tr><td><code id="predict.PGOcc_+3A_type">type</code></td>
<td>
<p>a quoted keyword indicating what type of prediction to produce. Valid keywords are 'occupancy' to predict latent occupancy probability and latent occupancy values (this is the default), or 'detection' to predict detection probability given new values of detection covariates.</p>
</td></tr>
<tr><td><code id="predict.PGOcc_+3A_...">...</code></td>
<td>
<p>currently no additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list object of class <code>predict.PGOcc</code>. When <code>type = 'occupancy'</code>, the list consists of: 
</p>
<table>
<tr><td><code>psi.0.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior predictive samples for the
latent occupancy probability values.</p>
</td></tr>
<tr><td><code>z.0.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior predictive samples for the
latent occupancy values.</p>
</td></tr>
</table>
<p>When <code>type = 'detection'</code>, the list consists of: 
</p>
<table>
<tr><td><code>p.0.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior predictive samples for the 
detection probability values.</p>
</td></tr>
</table>
<p>The return object will include additional objects used for standard 
extractor functions. 
</p>


<h3>Note</h3>

<p>When <code>ignore.RE = FALSE</code>, both sampled levels and non-sampled levels of random effects are supported for prediction. For sampled levels, the posterior distribution for the random intercept corresponding to that level of the random effect will be used in the prediction. For non-sampled levels, random values are drawn from a normal distribution using the posterior samples of the random effect variance, which results in fully propagated uncertainty in predictions with models that incorporate random effects. 
</p>


<h3>Author(s)</h3>

<p>Jeffrey W. Doser <a href="mailto:doserjef@msu.edu">doserjef@msu.edu</a>, <br />
Andrew O. Finley <a href="mailto:finleya@msu.edu">finleya@msu.edu</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(400)
# Simulate Data -----------------------------------------------------------
J.x &lt;- 10
J.y &lt;- 10
J &lt;- J.x * J.y
n.rep &lt;- sample(2:4, J, replace = TRUE)
beta &lt;- c(0.5, 2)
p.occ &lt;- length(beta)
alpha &lt;- c(0, 1)
p.det &lt;- length(alpha)
dat &lt;- simOcc(J.x = J.x, J.y = J.y, n.rep = n.rep, beta = beta, alpha = alpha,
              sp = FALSE)
# Split into fitting and prediction data set
pred.indx &lt;- sample(1:J, round(J * .25), replace = FALSE)
y &lt;- dat$y[-pred.indx, ]
# Occupancy covariates
X &lt;- dat$X[-pred.indx, ]
# Prediction covariates
X.0 &lt;- dat$X[pred.indx, ]
# Detection covariates
X.p &lt;- dat$X.p[-pred.indx, , ]

# Package all data into a list
occ.covs &lt;- X[, 2, drop = FALSE]
colnames(occ.covs) &lt;- c('occ.cov')
det.covs &lt;- list(det.cov = X.p[, , 2])
data.list &lt;- list(y = y, 
                  occ.covs = occ.covs,
                  det.covs = det.covs)
# Priors
prior.list &lt;- list(beta.normal = list(mean = rep(0, p.occ),
                                      var = rep(2.72, p.occ)),
                   alpha.normal = list(mean = rep(0, p.det),
                                       var = rep(2.72, p.det)))
# Initial values
inits.list &lt;- list(alpha = rep(0, p.det),
                   beta = rep(0, p.occ),
                   z = apply(y, 1, max, na.rm = TRUE))

n.samples &lt;- 5000
n.report &lt;- 1000

out &lt;- PGOcc(occ.formula = ~ occ.cov, 
             det.formula = ~ det.cov,
             data = data.list, 
             inits = inits.list,
             n.samples = n.samples,
             priors = prior.list,
             n.omp.threads = 1,
             verbose = TRUE,
             n.report = n.report, 
             n.burn = 4000, 
             n.thin = 1)

summary(out)

# Predict at new locations ------------------------------------------------
colnames(X.0) &lt;- c('intercept', 'occ.cov')
out.pred &lt;- predict(out, X.0)
psi.0.quants &lt;- apply(out.pred$psi.0.samples, 2, quantile, c(0.025, 0.5, 0.975))
plot(dat$psi[pred.indx], psi.0.quants[2, ], pch = 19, xlab = 'True', 
     ylab = 'Fitted', ylim = c(min(psi.0.quants), max(psi.0.quants)))
segments(dat$psi[pred.indx], psi.0.quants[1, ], dat$psi[pred.indx], psi.0.quants[3, ])
lines(dat$psi[pred.indx], dat$psi[pred.indx])
</code></pre>

<hr>
<h2 id='predict.sfJSDM'>Function for prediction at new locations for spatial factor joint species distribution model</h2><span id='topic+predict.sfJSDM'></span>

<h3>Description</h3>

<p>The function <code>predict</code> collects posterior predictive samples for a set of new locations given an object of class 'sfJSDM'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sfJSDM'
predict(object, X.0, coords.0, n.omp.threads = 1, verbose = TRUE, 
        n.report = 100, ignore.RE = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.sfJSDM_+3A_object">object</code></td>
<td>
<p>an object of class sfJSDM</p>
</td></tr>
<tr><td><code id="predict.sfJSDM_+3A_x.0">X.0</code></td>
<td>
<p>the design matrix of covariates at the prediction locations. This should include a column of 1s for the intercept if an intercept is included in the model. If random effects are included in the model, the levels of the random effects at the new locations should be included as a column in the design matrix. The ordering of the levels should match the ordering used to fit the data in <code>sfJSDM</code>. Columns should correspond to the order of how covariates were specified in the formula argument of <code>sfJSDM</code>. Column names of the random effects must match the name of the random effects, if specified in the formula argument of <code>sfJSDM</code>.</p>
</td></tr>
<tr><td><code id="predict.sfJSDM_+3A_coords.0">coords.0</code></td>
<td>
<p>the spatial coordinates corresponding to <code>X.0</code>. Note that <code>spOccupancy</code> assumes coordinates are specified 
in a projected coordinate system.</p>
</td></tr>
<tr><td><code id="predict.sfJSDM_+3A_n.omp.threads">n.omp.threads</code></td>
<td>
<p>a positive integer indicating
the number of threads to use for SMP parallel processing. The package must
be compiled for OpenMP support. For most Intel-based machines, we recommend setting
<code>n.omp.threads</code> up to the number of hyperthreaded cores. 
Note, <code>n.omp.threads</code> &gt; 1 might not work on some systems.</p>
</td></tr>
<tr><td><code id="predict.sfJSDM_+3A_verbose">verbose</code></td>
<td>
<p>if <code>TRUE</code>, model specification and progress of the 
sampler is printed to the screen. Otherwise, nothing is printed to
the screen.</p>
</td></tr>
<tr><td><code id="predict.sfJSDM_+3A_n.report">n.report</code></td>
<td>
<p>the interval to report sampling progress.</p>
</td></tr>
<tr><td><code id="predict.sfJSDM_+3A_ignore.re">ignore.RE</code></td>
<td>
<p>a logical value indicating whether to include unstructured random 
effects for prediction. If TRUE, unstructured random effects will be ignored and 
prediction will only use the fixed effects and the spatial random effects. If FALSE, 
random effects will be included in the prediction for both observed and unobserved 
levels of the unstructured random effects.</p>
</td></tr>
<tr><td><code id="predict.sfJSDM_+3A_...">...</code></td>
<td>
<p>currently no additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An list object of class <code>predict.sfJSDM</code> that consists of:  
</p>
<table>
<tr><td><code>psi.0.samples</code></td>
<td>
<p>a three-dimensional array of posterior predictive samples for the
latent occurrence probability values.</p>
</td></tr>
<tr><td><code>z.0.samples</code></td>
<td>
<p>a three-dimensional array of posterior predictive samples for the
latent occurrence values.</p>
</td></tr>
<tr><td><code>w.0.samples</code></td>
<td>
<p>a three-dimensional array of posterior predictive samples
for the latent spatial factors.</p>
</td></tr>
<tr><td><code>run.time</code></td>
<td>
<p>execution time reported using <code>proc.time()</code>.</p>
</td></tr>
</table>
<p>The return object will include additional objects used for standard 
extractor functions. 
</p>


<h3>Note</h3>

<p>When <code>ignore.RE = FALSE</code>, both sampled levels and non-sampled levels of random effects are supported for prediction. For sampled levels, the posterior distribution for the random intercept corresponding to that level of the random effect will be used in the prediction. For non-sampled levels, random values are drawn from a normal distribution using the posterior samples of the random effect variance, which results in fully propagated uncertainty in predictions with models that incorporate random effects.
</p>


<h3>Author(s)</h3>

<p>Jeffrey W. Doser <a href="mailto:doserjef@msu.edu">doserjef@msu.edu</a>, <br />
Andrew O. Finley <a href="mailto:finleya@msu.edu">finleya@msu.edu</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(400)

# Simulate Data -----------------------------------------------------------
J.x &lt;- 7
J.y &lt;- 7
J &lt;- J.x * J.y
n.rep &lt;- sample(2:4, size = J, replace = TRUE)
N &lt;- 5
# Community-level covariate effects
# Occurrence
beta.mean &lt;- c(0.2, -0.15)
p.occ &lt;- length(beta.mean)
tau.sq.beta &lt;- c(0.6, 0.3)
# Detection
alpha.mean &lt;- c(0.5, 0.2, -.2)
tau.sq.alpha &lt;- c(0.2, 0.3, 0.8)
p.det &lt;- length(alpha.mean)
# Draw species-level effects from community means.
beta &lt;- matrix(NA, nrow = N, ncol = p.occ)
alpha &lt;- matrix(NA, nrow = N, ncol = p.det)
for (i in 1:p.occ) {
  beta[, i] &lt;- rnorm(N, beta.mean[i], sqrt(tau.sq.beta[i]))
}
for (i in 1:p.det) {
  alpha[, i] &lt;- rnorm(N, alpha.mean[i], sqrt(tau.sq.alpha[i]))
}
n.factors &lt;- 3
phi &lt;- runif(n.factors, 3/1, 3/.4)
sp &lt;- TRUE

dat &lt;- simMsOcc(J.x = J.x, J.y = J.y, n.rep = n.rep, N = N, beta = beta, alpha = alpha,
                phi = phi, sigma.sq = sigma.sq, sp = TRUE, cov.model = 'exponential', 
                factor.model = TRUE, n.factors = n.factors)

# Number of batches
n.batch &lt;- 10
# Batch length
batch.length &lt;- 25
n.samples &lt;- n.batch * batch.length

# Split into fitting and prediction data set
pred.indx &lt;- sample(1:J, round(J * .25), replace = FALSE)
# Summarize the multiple replicates into a single value for use in a JSDM
y &lt;- apply(dat$y[, -pred.indx, ], c(1, 2), max, na.rm = TRUE)
# Occupancy covariates
X &lt;- dat$X[-pred.indx, ]
# Coordinates
coords &lt;- as.matrix(dat$coords[-pred.indx, ])
# Prediction values
X.0 &lt;- dat$X[pred.indx, ]
coords.0 &lt;- as.matrix(dat$coords[pred.indx, ])
psi.0 &lt;- dat$psi[, pred.indx]

# Package all data into a list
covs &lt;- X[, 2, drop = FALSE]
colnames(covs) &lt;- c('occ.cov')
data.list &lt;- list(y = y, 
                  covs = covs,
                  coords = coords)

# Priors 
prior.list &lt;- list(beta.comm.normal = list(mean = 0, var = 2.72), 
                   tau.sq.beta.ig = list(a = 0.1, b = 0.1), 
                   phi.unif = list(a = 3/1, b = 3/.1)) 
# Starting values
lambda.inits &lt;- matrix(0, N, n.factors)
diag(lambda.inits) &lt;- 1
lambda.inits[lower.tri(lambda.inits)] &lt;- rnorm(sum(lower.tri(lambda.inits)))
inits.list &lt;- list(beta.comm = 0, 
                   beta = 0, 
                   tau.sq.beta = 1, 
                   phi = 3 / .5, 
                   sigma.sq = 2,
                   lambda = lambda.inits)
# Tuning
tuning.list &lt;- list(phi = 1) 

out &lt;- sfJSDM(formula = ~ occ.cov, 
              data = data.list,
              inits = inits.list, 
              n.batch = n.batch, 
              batch.length = batch.length, 
              accept.rate = 0.43, 
              n.factors = 3,
              priors = prior.list, 
              cov.model = "exponential", 
              tuning = tuning.list, 
              n.omp.threads = 1, 
              verbose = TRUE, 
              NNGP = TRUE, 
              n.neighbors = 5, 
              search.type = 'cb', 
              n.report = 10, 
              n.burn = 100, 
              n.thin = 1)

summary(out, level = 'both')

# Predict at new locations ------------------------------------------------
out.pred &lt;- predict(out, X.0, coords.0, verbose = FALSE)
</code></pre>

<hr>
<h2 id='predict.sfMsPGOcc'>Function for prediction at new locations for spatial factor multi-species occupancy models</h2><span id='topic+predict.sfMsPGOcc'></span>

<h3>Description</h3>

<p>The function <code>predict</code> collects posterior predictive samples for a set of new locations given an object of class 'sfMsPGOcc'. Prediction is possible for both the latent occupancy state as well as detection.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sfMsPGOcc'
predict(object, X.0, coords.0, n.omp.threads = 1, verbose = TRUE, 
        n.report = 100, ignore.RE = FALSE, type = 'occupancy', grid.index.0, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.sfMsPGOcc_+3A_object">object</code></td>
<td>
<p>an object of class sfMsPGOcc</p>
</td></tr>
<tr><td><code id="predict.sfMsPGOcc_+3A_x.0">X.0</code></td>
<td>
<p>the design matrix of covariates at the prediction locations. This should include a column of 1s for the intercept if an intercept is included in the model. If random effects are included in the occupancy (or detection if <code>type = 'detection'</code>) portion of the model, the levels of the random effects at the new locations should be included as a column in the design matrix. The ordering of the levels should match the ordering used to fit the data in <code>sfMsPGOcc</code>. Columns should correspond to the order of how covariates were specified in the corresponding formula argument of <code>sfMsPGOcc</code>. Column names of the random effects must match the name of the random effects, if specified in the corresponding formula argument of <code>sfMsPGOcc</code>.</p>
</td></tr>
<tr><td><code id="predict.sfMsPGOcc_+3A_coords.0">coords.0</code></td>
<td>
<p>the spatial coordinates corresponding to <code>X.0</code>. Note that <code>spOccupancy</code> assumes coordinates are specified 
in a projected coordinate system.</p>
</td></tr>
<tr><td><code id="predict.sfMsPGOcc_+3A_n.omp.threads">n.omp.threads</code></td>
<td>
<p>a positive integer indicating
the number of threads to use for SMP parallel processing. The package must
be compiled for OpenMP support. For most Intel-based machines, we recommend setting
<code>n.omp.threads</code> up to the number of hyperthreaded cores. 
Note, <code>n.omp.threads</code> &gt; 1 might not work on some systems.</p>
</td></tr>
<tr><td><code id="predict.sfMsPGOcc_+3A_verbose">verbose</code></td>
<td>
<p>if <code>TRUE</code>, model specification and progress of the 
sampler is printed to the screen. Otherwise, nothing is printed to
the screen.</p>
</td></tr>
<tr><td><code id="predict.sfMsPGOcc_+3A_n.report">n.report</code></td>
<td>
<p>the interval to report sampling progress.</p>
</td></tr>
<tr><td><code id="predict.sfMsPGOcc_+3A_ignore.re">ignore.RE</code></td>
<td>
<p>a logical value indicating whether to include unstructured random 
effects for prediction. If TRUE, unstructured random effects will be ignored and 
prediction will only use the fixed effects and the spatial random effects. If FALSE, 
random effects will be included in the prediction for both observed and unobserved 
levels of the unstructured random effects.</p>
</td></tr>
<tr><td><code id="predict.sfMsPGOcc_+3A_type">type</code></td>
<td>
<p>a quoted keyword indicating what type of prediction to produce. Valid keywords are 'occupancy' to predict latent occupancy probability and latent occupancy values (this is the default), or 'detection' to predict detection probability given new values of detection covariates.</p>
</td></tr>
<tr><td><code id="predict.sfMsPGOcc_+3A_grid.index.0">grid.index.0</code></td>
<td>
<p>an indexing vector used to specify how each row in <code>X.0</code> corresponds to the coordinates specified in <code>coords.0</code>. Only relevant if the spatial random effect was estimated at a higher spatial resolution (e.g., grid cells) than point locations.</p>
</td></tr>
<tr><td><code id="predict.sfMsPGOcc_+3A_...">...</code></td>
<td>
<p>currently no additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An list object of class <code>predict.sfMsPGOcc</code>. When <code>type = 'occupancy'</code>, the list consists of:  
</p>
<table>
<tr><td><code>psi.0.samples</code></td>
<td>
<p>a three-dimensional array of posterior predictive samples for the
latent occurrence probability values.</p>
</td></tr>
<tr><td><code>z.0.samples</code></td>
<td>
<p>a three-dimensional array of posterior predictive samples for the
latent occurrence values.</p>
</td></tr>
<tr><td><code>w.0.samples</code></td>
<td>
<p>a three-dimensional array of posterior predictive samples
for the latent spatial factors.</p>
</td></tr>
<tr><td><code>run.time</code></td>
<td>
<p>execution time reported using <code>proc.time()</code>.</p>
</td></tr>
</table>
<p>When <code>type = 'detection'</code>, the list consists of: 
</p>
<table>
<tr><td><code>p.0.samples</code></td>
<td>
<p>a three-dimensional array of posterior predictive samples for the 
detection probability values.</p>
</td></tr>
<tr><td><code>run.time</code></td>
<td>
<p>execution time reported using <code>proc.time()</code>.</p>
</td></tr>
</table>
<p>The return object will include additional objects used for standard 
extractor functions. 
</p>


<h3>Note</h3>

<p>When <code>ignore.RE = FALSE</code>, both sampled levels and non-sampled levels of random effects are supported for prediction. For sampled levels, the posterior distribution for the random intercept corresponding to that level of the random effect will be used in the prediction. For non-sampled levels, random values are drawn from a normal distribution using the posterior samples of the random effect variance, which results in fully propagated uncertainty in predictions with models that incorporate random effects.
</p>


<h3>Author(s)</h3>

<p>Jeffrey W. Doser <a href="mailto:doserjef@msu.edu">doserjef@msu.edu</a>, <br />
Andrew O. Finley <a href="mailto:finleya@msu.edu">finleya@msu.edu</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(400)

# Simulate Data -----------------------------------------------------------
J.x &lt;- 7
J.y &lt;- 7
J &lt;- J.x * J.y
n.rep &lt;- sample(2:4, size = J, replace = TRUE)
N &lt;- 5
# Community-level covariate effects
# Occurrence
beta.mean &lt;- c(0.2, -0.15)
p.occ &lt;- length(beta.mean)
tau.sq.beta &lt;- c(0.6, 0.3)
# Detection
alpha.mean &lt;- c(0.5, 0.2, -.2)
tau.sq.alpha &lt;- c(0.2, 0.3, 0.8)
p.det &lt;- length(alpha.mean)
# Draw species-level effects from community means.
beta &lt;- matrix(NA, nrow = N, ncol = p.occ)
alpha &lt;- matrix(NA, nrow = N, ncol = p.det)
for (i in 1:p.occ) {
  beta[, i] &lt;- rnorm(N, beta.mean[i], sqrt(tau.sq.beta[i]))
}
for (i in 1:p.det) {
  alpha[, i] &lt;- rnorm(N, alpha.mean[i], sqrt(tau.sq.alpha[i]))
}
n.factors &lt;- 3
phi &lt;- runif(n.factors, 3/1, 3/.4)
sp &lt;- TRUE

dat &lt;- simMsOcc(J.x = J.x, J.y = J.y, n.rep = n.rep, N = N, beta = beta, alpha = alpha,
                phi = phi, sigma.sq = sigma.sq, sp = TRUE, cov.model = 'exponential', 
                factor.model = TRUE, n.factors = n.factors)

# Number of batches
n.batch &lt;- 10
# Batch length
batch.length &lt;- 25
n.samples &lt;- n.batch * batch.length

# Split into fitting and prediction data set
pred.indx &lt;- sample(1:J, round(J * .25), replace = FALSE)
y &lt;- dat$y[, -pred.indx, ]
# Occupancy covariates
X &lt;- dat$X[-pred.indx, ]
# Coordinates
coords &lt;- as.matrix(dat$coords[-pred.indx, ])
# Detection covariates
X.p &lt;- dat$X.p[-pred.indx, , ]
# Prediction values
X.0 &lt;- dat$X[pred.indx, ]
coords.0 &lt;- as.matrix(dat$coords[pred.indx, ])
psi.0 &lt;- dat$psi[, pred.indx]

# Package all data into a list
occ.covs &lt;- X[, 2, drop = FALSE]
colnames(occ.covs) &lt;- c('occ.cov')
det.covs &lt;- list(det.cov.1 = X.p[, , 2], 
                 det.cov.2 = X.p[, , 3])
data.list &lt;- list(y = y, 
                  occ.covs = occ.covs,
                  det.covs = det.covs, 
                  coords = coords)

# Priors 
prior.list &lt;- list(beta.comm.normal = list(mean = 0, var = 2.72), 
                   alpha.comm.normal = list(mean = 0, var = 2.72), 
                   tau.sq.beta.ig = list(a = 0.1, b = 0.1), 
                   tau.sq.alpha.ig = list(a = 0.1, b = 0.1),
                   phi.unif = list(a = 3/1, b = 3/.1), 
                   sigma.sq.ig = list(a = 2, b = 2)) 
# Starting values
lambda.inits &lt;- matrix(0, N, n.factors)
diag(lambda.inits) &lt;- 1
lambda.inits[lower.tri(lambda.inits)] &lt;- rnorm(sum(lower.tri(lambda.inits)))
inits.list &lt;- list(alpha.comm = 0, 
                   beta.comm = 0, 
                   beta = 0, 
                   alpha = 0,
                   tau.sq.beta = 1, 
                   tau.sq.alpha = 1, 
                   phi = 3 / .5, 
                   sigma.sq = 2,
                   lambda = lambda.inits,
                   z = apply(y, c(1, 2), max, na.rm = TRUE))
# Tuning
tuning.list &lt;- list(phi = 1) 

out &lt;- sfMsPGOcc(occ.formula = ~ occ.cov, 
                 det.formula = ~ det.cov.1 + det.cov.2, 
                 data = data.list,
                 inits = inits.list, 
                 n.batch = n.batch, 
                 batch.length = batch.length, 
                 accept.rate = 0.43, 
                 n.factors = 3,
                 priors = prior.list, 
                 cov.model = "exponential", 
                 tuning = tuning.list, 
                 n.omp.threads = 1, 
                 verbose = TRUE, 
                 NNGP = TRUE, 
                 n.neighbors = 5, 
                 search.type = 'cb', 
                 n.report = 10, 
                 n.burn = 100, 
                 n.thin = 1)

summary(out, level = 'both')

# Predict at new locations ------------------------------------------------
out.pred &lt;- predict(out, X.0, coords.0, verbose = FALSE)
</code></pre>

<hr>
<h2 id='predict.spIntPGOcc'>Function for prediction at new locations for single-species integrated spatial occupancy models</h2><span id='topic+predict.spIntPGOcc'></span>

<h3>Description</h3>

<p>The function <code>predict</code> collects posterior predictive samples for a set of new locations given an object of class 'spIntPGOcc'. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'spIntPGOcc'
predict(object, X.0, coords.0, n.omp.threads = 1, verbose = TRUE, 
        n.report = 100, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.spIntPGOcc_+3A_object">object</code></td>
<td>
<p>an object of class <code>spIntPGOcc</code>.</p>
</td></tr>
<tr><td><code id="predict.spIntPGOcc_+3A_x.0">X.0</code></td>
<td>
<p>the design matrix for prediction locations. This should include a column of 1s for the intercept. Covariates should have the same column names as those used when fitting the model with <code>spIntPGOcc</code>.</p>
</td></tr>
<tr><td><code id="predict.spIntPGOcc_+3A_coords.0">coords.0</code></td>
<td>
<p>the spatial coordinates corresponding to <code>X.0</code>. Note that <code>spOccupancy</code> assumes coordinates are specified 
in a projected coordinate system.</p>
</td></tr>
<tr><td><code id="predict.spIntPGOcc_+3A_n.omp.threads">n.omp.threads</code></td>
<td>
<p>a positive integer indicating
the number of threads to use for SMP parallel processing. The package must
be compiled for OpenMP support. For most Intel-based machines, we recommend setting
<code>n.omp.threads</code> up to the number of hyperthreaded cores. 
Note, <code>n.omp.threads</code> &gt; 1 might not work on some systems.</p>
</td></tr>
<tr><td><code id="predict.spIntPGOcc_+3A_verbose">verbose</code></td>
<td>
<p>if <code>TRUE</code>, model specification and progress of the 
sampler is printed to the screen. Otherwise, nothing is printed to
the screen.</p>
</td></tr>
<tr><td><code id="predict.spIntPGOcc_+3A_n.report">n.report</code></td>
<td>
<p>the interval to report sampling progress.</p>
</td></tr>
<tr><td><code id="predict.spIntPGOcc_+3A_...">...</code></td>
<td>
<p>currently no additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>predict.spIntPGOcc</code> that is a list comprised of: 
</p>
<table>
<tr><td><code>psi.0.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior predictive samples for the
latent occurrence probability values.</p>
</td></tr>
<tr><td><code>z.0.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior predictive samples for the
latent occurrence values.</p>
</td></tr>
</table>
<p>The return object will include additional objects used for standard 
extractor functions. 
</p>


<h3>Author(s)</h3>

<p>Jeffrey W. Doser <a href="mailto:doserjef@msu.edu">doserjef@msu.edu</a>, <br />
Andrew O. Finley <a href="mailto:finleya@msu.edu">finleya@msu.edu</a>
</p>


<h3>References</h3>

<p>Hooten, M. B., and Hefley, T. J. (2019). Bringing Bayesian models to life. CRC Press.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(400)

# Simulate Data -----------------------------------------------------------
# Number of locations in each direction. This is the total region of interest
# where some sites may or may not have a data source. 
J.x &lt;- 8
J.y &lt;- 8
J.all &lt;- J.x * J.y
# Number of data sources.
n.data &lt;- 4
# Sites for each data source. 
J.obs &lt;- sample(ceiling(0.2 * J.all):ceiling(0.5 * J.all), n.data, replace = TRUE)
# Replicates for each data source.
n.rep &lt;- list()
for (i in 1:n.data) {
  n.rep[[i]] &lt;- sample(1:4, size = J.obs[i], replace = TRUE)
}
# Occupancy covariates
beta &lt;- c(0.5, 0.5)
p.occ &lt;- length(beta)
# Detection covariates
alpha &lt;- list()
alpha[[1]] &lt;- runif(2, 0, 1)
alpha[[2]] &lt;- runif(3, 0, 1)
alpha[[3]] &lt;- runif(2, -1, 1)
alpha[[4]] &lt;- runif(4, -1, 1)
p.det.long &lt;- sapply(alpha, length)
p.det &lt;- sum(p.det.long)
sigma.sq &lt;- 2
phi &lt;- 3 / .5
sp &lt;- TRUE

# Simulate occupancy data. 
dat &lt;- simIntOcc(n.data = n.data, J.x = J.x, J.y = J.y, J.obs = J.obs, 
                 n.rep = n.rep, beta = beta, alpha = alpha, sp = sp, 
                 phi = phi, sigma.sq = sigma.sq, cov.model = 'spherical')

y &lt;- dat$y
X &lt;- dat$X.obs
X.p &lt;- dat$X.p
sites &lt;- dat$sites
X.0 &lt;- dat$X.pred
psi.0 &lt;- dat$psi.pred
coords &lt;- as.matrix(dat$coords.obs)
coords.0 &lt;- as.matrix(dat$coords.pred)

# Package all data into a list
occ.covs &lt;- X[, 2, drop = FALSE]
colnames(occ.covs) &lt;- c('occ.cov')
det.covs &lt;- list()
# Add covariates one by one
det.covs[[1]] &lt;- list(det.cov.1.1 = X.p[[1]][, , 2])
det.covs[[2]] &lt;- list(det.cov.2.1 = X.p[[2]][, , 2], 
                      det.cov.2.2 = X.p[[2]][, , 3])
det.covs[[3]] &lt;- list(det.cov.3.1 = X.p[[3]][, , 2])
det.covs[[4]] &lt;- list(det.cov.4.1 = X.p[[4]][, , 2], 
                      det.cov.4.2 = X.p[[4]][, , 3], 
                      det.cov.4.3 = X.p[[4]][, , 4])
data.list &lt;- list(y = y, 
                  occ.covs = occ.covs,
                  det.covs = det.covs, 
                  sites = sites, 
                  coords = coords)

J &lt;- length(dat$z.obs)

# Initial values
inits.list &lt;- list(alpha = list(0, 0, 0, 0), 
                   beta = 0, 
                   phi = 3 / .5, 
                   sigma.sq = 2, 
                   w = rep(0, J), 
                   z = rep(1, J))
# Priors
prior.list &lt;- list(beta.normal = list(mean = 0, var = 2.72), 
                   alpha.normal = list(mean = list(0, 0, 0, 0), 
                                       var = list(2.72, 2.72, 2.72, 2.72)),
                   phi.unif = c(3/1, 3/.1), 
                   sigma.sq.ig = c(2, 2))
# Tuning
tuning.list &lt;- list(phi = 1) 

# Number of batches
n.batch &lt;- 40
# Batch length
batch.length &lt;- 25

out &lt;- spIntPGOcc(occ.formula = ~ occ.cov, 
                  det.formula = list(f.1 = ~ det.cov.1.1, 
                                     f.2 = ~ det.cov.2.1 + det.cov.2.2, 
                                     f.3 = ~ det.cov.3.1, 
                                     f.4 = ~ det.cov.4.1 + det.cov.4.2 + det.cov.4.3), 
                  data = data.list,  
                  inits = inits.list, 
                  n.batch = n.batch, 
                  batch.length = batch.length, 
                  accept.rate = 0.43, 
                  priors = prior.list, 
                  cov.model = "spherical", 
                  tuning = tuning.list, 
                  n.omp.threads = 1, 
                  verbose = TRUE, 
                  NNGP = TRUE, 
                  n.neighbors = 5, 
                  search.type = 'cb', 
                  n.report = 10, 
                  n.burn = 500, 
                  n.thin = 1)
summary(out)

# Predict at new locations ------------------------------------------------
out.pred &lt;- predict(out, X.0, coords.0, verbose = FALSE)
</code></pre>

<hr>
<h2 id='predict.spMsPGOcc'>Function for prediction at new locations for multi-species spatial occupancy models</h2><span id='topic+predict.spMsPGOcc'></span>

<h3>Description</h3>

<p>The function <code>predict</code> collects posterior predictive samples for a set of new locations given an object of class 'spMsPGOcc'. Prediction is possible for both the latent occupancy state as well as detection.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'spMsPGOcc'
predict(object, X.0, coords.0, n.omp.threads = 1, verbose = TRUE, 
                            n.report = 100, ignore.RE = FALSE, type = 'occupancy', ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.spMsPGOcc_+3A_object">object</code></td>
<td>
<p>an object of class spMsPGOcc</p>
</td></tr>
<tr><td><code id="predict.spMsPGOcc_+3A_x.0">X.0</code></td>
<td>
<p>the design matrix of covariates at the prediction locations. This should include a column of 1s for the intercept if an intercept is included in the model. If random effects are included in the occupancy (or detection if <code>type = 'detection'</code>) portion of the model, the levels of the random effects at the new locations should be included as a column in the design matrix. The ordering of the levels should match the ordering used to fit the data in <code>spMsPGOcc</code>. Columns should correspond to the order of how covariates were specified in the corresponding formula argument of <code>spMsPGOcc</code>. Column names of the random effects must match the name of the random effects, if specified in the corresponding formula argument of <code>spMsPGOcc</code>.</p>
</td></tr>
<tr><td><code id="predict.spMsPGOcc_+3A_coords.0">coords.0</code></td>
<td>
<p>the spatial coordinates corresponding to <code>X.0</code>. Note that <code>spOccupancy</code> assumes coordinates are specified 
in a projected coordinate system.</p>
</td></tr>
<tr><td><code id="predict.spMsPGOcc_+3A_n.omp.threads">n.omp.threads</code></td>
<td>
<p>a positive integer indicating
the number of threads to use for SMP parallel processing. The package must
be compiled for OpenMP support. For most Intel-based machines, we recommend setting
<code>n.omp.threads</code> up to the number of hyperthreaded cores. 
Note, <code>n.omp.threads</code> &gt; 1 might not work on some systems.</p>
</td></tr>
<tr><td><code id="predict.spMsPGOcc_+3A_verbose">verbose</code></td>
<td>
<p>if <code>TRUE</code>, model specification and progress of the 
sampler is printed to the screen. Otherwise, nothing is printed to
the screen.</p>
</td></tr>
<tr><td><code id="predict.spMsPGOcc_+3A_n.report">n.report</code></td>
<td>
<p>the interval to report sampling progress.</p>
</td></tr>
<tr><td><code id="predict.spMsPGOcc_+3A_ignore.re">ignore.RE</code></td>
<td>
<p>a logical value indicating whether to include unstructured random 
effects for prediction. If TRUE, unstructured random effects will be ignored and 
prediction will only use the fixed effects and the spatial random effects. If FALSE, 
random effects will be included in the prediction for both observed and unobserved 
levels of the unstructured random effects.</p>
</td></tr>
<tr><td><code id="predict.spMsPGOcc_+3A_type">type</code></td>
<td>
<p>a quoted keyword indicating what type of prediction to produce. Valid keywords are 'occupancy' to predict latent occupancy probability and latent occupancy values (this is the default), or 'detection' to predict detection probability given new values of detection covariates.</p>
</td></tr>
<tr><td><code id="predict.spMsPGOcc_+3A_...">...</code></td>
<td>
<p>currently no additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An list object of class <code>predict.spMsPGOcc</code>. When <code>type = 'occupancy'</code>, the list consists of:  
</p>
<table>
<tr><td><code>psi.0.samples</code></td>
<td>
<p>a three-dimensional array of posterior predictive samples for the
latent occurrence probability values.</p>
</td></tr>
<tr><td><code>z.0.samples</code></td>
<td>
<p>a three-dimensional array of posterior predictive samples for the
latent occurrence values.</p>
</td></tr>
<tr><td><code>w.0.samples</code></td>
<td>
<p>a three-dimensional array of posterior predictive samples
for the latent spatial random effects.</p>
</td></tr>
<tr><td><code>run.time</code></td>
<td>
<p>execution time reported using <code>proc.time()</code>.</p>
</td></tr>
</table>
<p>When <code>type = 'detection'</code>, the list consists of: 
</p>
<table>
<tr><td><code>p.0.samples</code></td>
<td>
<p>a three-dimensional array of posterior predictive samples for the 
detection probability values.</p>
</td></tr>
<tr><td><code>run.time</code></td>
<td>
<p>execution time reported using <code>proc.time()</code>.</p>
</td></tr>
</table>
<p>The return object will include additional objects used for standard 
extractor functions. 
</p>


<h3>Note</h3>

<p>When <code>ignore.RE = FALSE</code>, both sampled levels and non-sampled levels of random effects are supported for prediction. For sampled levels, the posterior distribution for the random intercept corresponding to that level of the random effect will be used in the prediction. For non-sampled levels, random values are drawn from a normal distribution using the posterior samples of the random effect variance, which results in fully propagated uncertainty in predictions with models that incorporate random effects.
</p>


<h3>Author(s)</h3>

<p>Jeffrey W. Doser <a href="mailto:doserjef@msu.edu">doserjef@msu.edu</a>, <br />
Andrew O. Finley <a href="mailto:finleya@msu.edu">finleya@msu.edu</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(400)

# Simulate Data -----------------------------------------------------------
J.x &lt;- 7
J.y &lt;- 7
J &lt;- J.x * J.y
n.rep &lt;- sample(2:4, size = J, replace = TRUE)
N &lt;- 5
# Community-level covariate effects
# Occurrence
beta.mean &lt;- c(0.2, -0.15)
p.occ &lt;- length(beta.mean)
tau.sq.beta &lt;- c(0.6, 0.3)
# Detection
alpha.mean &lt;- c(0.5, 0.2, -.2)
tau.sq.alpha &lt;- c(0.2, 0.3, 0.8)
p.det &lt;- length(alpha.mean)
# Draw species-level effects from community means.
beta &lt;- matrix(NA, nrow = N, ncol = p.occ)
alpha &lt;- matrix(NA, nrow = N, ncol = p.det)
for (i in 1:p.occ) {
  beta[, i] &lt;- rnorm(N, beta.mean[i], sqrt(tau.sq.beta[i]))
}
for (i in 1:p.det) {
  alpha[, i] &lt;- rnorm(N, alpha.mean[i], sqrt(tau.sq.alpha[i]))
}
phi &lt;- runif(N, 3/1, 3/.4)
sigma.sq &lt;- runif(N, 0.3, 3)
sp &lt;- TRUE

dat &lt;- simMsOcc(J.x = J.x, J.y = J.y, n.rep = n.rep, N = N, beta = beta, alpha = alpha,
		phi = phi, sigma.sq = sigma.sq, sp = TRUE, cov.model = 'exponential')

# Number of batches
n.batch &lt;- 30
# Batch length
batch.length &lt;- 25
n.samples &lt;- n.batch * batch.length

# Split into fitting and prediction data set
pred.indx &lt;- sample(1:J, round(J * .25), replace = FALSE)
y &lt;- dat$y[, -pred.indx, ]
# Occupancy covariates
X &lt;- dat$X[-pred.indx, ]
# Coordinates
coords &lt;- as.matrix(dat$coords[-pred.indx, ])
# Detection covariates
X.p &lt;- dat$X.p[-pred.indx, , ]
# Prediction values
X.0 &lt;- dat$X[pred.indx, ]
coords.0 &lt;- as.matrix(dat$coords[pred.indx, ])
psi.0 &lt;- dat$psi[, pred.indx]

# Package all data into a list
occ.covs &lt;- X[, 2, drop = FALSE]
colnames(occ.covs) &lt;- c('occ.cov')
det.covs &lt;- list(det.cov.1 = X.p[, , 2], 
		 det.cov.2 = X.p[, , 3]
		 )
data.list &lt;- list(y = y, 
		  occ.covs = occ.covs,
		  det.covs = det.covs, 
		  coords = coords)

# Priors 
prior.list &lt;- list(beta.comm.normal = list(mean = 0, var = 2.72), 
		   alpha.comm.normal = list(mean = 0, var = 2.72), 
		   tau.sq.beta.ig = list(a = 0.1, b = 0.1), 
		   tau.sq.alpha.ig = list(a = 0.1, b = 0.1),
		   phi.unif = list(a = 3/1, b = 3/.1), 
		   sigma.sq.ig = list(a = 2, b = 2)) 
# Starting values
inits.list &lt;- list(alpha.comm = 0, 
		      beta.comm = 0, 
		      beta = 0, 
		      alpha = 0,
		      tau.sq.beta = 1, 
		      tau.sq.alpha = 1, 
		      phi = 3 / .5, 
		      sigma.sq = 2,
		      w = matrix(0, nrow = N, ncol = nrow(X)),
		      z = apply(y, c(1, 2), max, na.rm = TRUE))
# Tuning
tuning.list &lt;- list(phi = 1) 

out &lt;- spMsPGOcc(occ.formula = ~ occ.cov, 
		 det.formula = ~ det.cov.1 + det.cov.2, 
		 data = data.list,
		 inits = inits.list, 
		 n.batch = n.batch, 
		 batch.length = batch.length, 
		 accept.rate = 0.43, 
	         priors = prior.list, 
		 cov.model = "exponential", 
		 tuning = tuning.list, 
	         n.omp.threads = 1, 
	         verbose = TRUE, 
		 NNGP = TRUE, 
		 n.neighbors = 5, 
		 search.type = 'cb', 
	         n.report = 10, 
		 n.burn = 500, 
		 n.thin = 1)

summary(out, level = 'both')

# Predict at new locations ------------------------------------------------
out.pred &lt;- predict(out, X.0, coords.0, verbose = FALSE)
</code></pre>

<hr>
<h2 id='predict.spPGOcc'>Function for prediction at new locations for single-species spatial occupancy models</h2><span id='topic+predict.spPGOcc'></span>

<h3>Description</h3>

<p>The function <code>predict</code> collects posterior predictive samples for a set of new 
locations given an object of class 'spPGOcc'. Prediction is possible for both the 
latent occupancy state as well as detection.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'spPGOcc'
predict(object, X.0, coords.0, n.omp.threads = 1, verbose = TRUE, 
        n.report = 100, ignore.RE = FALSE, type = 'occupancy', grid.index.0, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.spPGOcc_+3A_object">object</code></td>
<td>
<p>an object of class <code>spPGOcc</code></p>
</td></tr>
<tr><td><code id="predict.spPGOcc_+3A_x.0">X.0</code></td>
<td>
<p>the design matrix of covariates at the prediction locations. This should include a column of 1s for the intercept if an intercept is included in the model. If random effects are included in the occupancy (or detection if <code>type = 'detection'</code>) portion of the model, the levels of the random effects at the new locations should be included as a column in the design matrix. The ordering of the levels should match the ordering used to fit the data in <code>spPGOcc</code>. Columns should correspond to the order of how covariates were specified in the corresponding formula argument of <code>spPGOcc</code>. Column names of the random effects must match the name of the random effects, if specified in the corresponding formula argument of <code>spPGOcc</code>.</p>
</td></tr>
<tr><td><code id="predict.spPGOcc_+3A_coords.0">coords.0</code></td>
<td>
<p>the spatial coordinates corresponding to <code>X.0</code>. Note that <code>spOccupancy</code> assumes coordinates are specified 
in a projected coordinate system.</p>
</td></tr>
<tr><td><code id="predict.spPGOcc_+3A_n.omp.threads">n.omp.threads</code></td>
<td>
<p>a positive integer indicating
the number of threads to use for SMP parallel processing. The package must
be compiled for OpenMP support. For most Intel-based machines, we recommend setting
<code>n.omp.threads</code> up to the number of hyperthreaded cores. 
Note, <code>n.omp.threads</code> &gt; 1 might not work on some systems.</p>
</td></tr>
<tr><td><code id="predict.spPGOcc_+3A_verbose">verbose</code></td>
<td>
<p>if <code>TRUE</code>, model specification and progress of the 
sampler is printed to the screen. Otherwise, nothing is printed to
the screen.</p>
</td></tr>
<tr><td><code id="predict.spPGOcc_+3A_ignore.re">ignore.RE</code></td>
<td>
<p>a logical value indicating whether to include unstructured random 
effects for prediction. If TRUE, unstructured random effects will be ignored and 
prediction will only use the fixed effects and the spatial random effects. If FALSE, 
random effects will be included in the prediction for both observed and unobserved 
levels of the unstructured random effects.</p>
</td></tr>
<tr><td><code id="predict.spPGOcc_+3A_n.report">n.report</code></td>
<td>
<p>the interval to report sampling progress.</p>
</td></tr>
<tr><td><code id="predict.spPGOcc_+3A_type">type</code></td>
<td>
<p>a quoted keyword indicating what type of prediction to produce. Valid keywords are 'occupancy' to predict latent occupancy probability and latent occupancy values (this is the default), or 'detection' to predict detection probability given new values of detection covariates.</p>
</td></tr>
<tr><td><code id="predict.spPGOcc_+3A_grid.index.0">grid.index.0</code></td>
<td>
<p>an indexing vector used to specify how each row in <code>X.0</code> corresponds to the coordinates specified in <code>coords.0</code>. Only relevant if the spatial random effect was estimated at a higher spatial resolution (e.g., grid cells) than point locations.</p>
</td></tr>
<tr><td><code id="predict.spPGOcc_+3A_...">...</code></td>
<td>
<p>currently no additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list object of class <code>predict.spPGOcc</code>. When <code>type = 'occupancy'</code>, the list consists of:  
</p>
<table>
<tr><td><code>psi.0.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior predictive samples 
for the latent occurrence probability values.</p>
</td></tr>
<tr><td><code>z.0.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior predictive samples 
for the latent occurrence values.</p>
</td></tr>
<tr><td><code>w.0.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior predictive samples 
for the latent spatial random effects.</p>
</td></tr>
<tr><td><code>run.time</code></td>
<td>
<p>execution time reported using <code>proc.time()</code>.</p>
</td></tr>
</table>
<p>When <code>type = 'detection'</code>, the list consists of: 
</p>
<table>
<tr><td><code>p.0.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior predictive samples for the 
detection probability values.</p>
</td></tr>
<tr><td><code>run.time</code></td>
<td>
<p>execution time reported using <code>proc.time()</code>.</p>
</td></tr>
</table>
<p>The return object will include additional objects used for standard 
extractor functions. 
</p>


<h3>Note</h3>

<p>When <code>ignore.RE = FALSE</code>, both sampled levels and non-sampled levels of random effects are supported for prediction. For sampled levels, the posterior distribution for the random intercept corresponding to that level of the random effect will be used in the prediction. For non-sampled levels, random values are drawn from a normal distribution using the posterior samples of the random effect variance, which results in fully propagated uncertainty in predictions with models that incorporate random effects.
</p>


<h3>Author(s)</h3>

<p>Jeffrey W. Doser <a href="mailto:doserjef@msu.edu">doserjef@msu.edu</a>, <br />
Andrew O. Finley <a href="mailto:finleya@msu.edu">finleya@msu.edu</a>
</p>


<h3>References</h3>

<p>Hooten, M. B., and Hefley, T. J. (2019). Bringing Bayesian models to life. CRC Press.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(400)
# Simulate Data -----------------------------------------------------------
J.x &lt;- 8
J.y &lt;- 8
J &lt;- J.x * J.y
n.rep &lt;- sample(2:4, J, replace = TRUE)
beta &lt;- c(0.5, 2)
p.occ &lt;- length(beta)
alpha &lt;- c(0, 1)
p.det &lt;- length(alpha)
phi &lt;- 3 / .6
sigma.sq &lt;- 2
dat &lt;- simOcc(J.x = J.x, J.y = J.y, n.rep = n.rep, beta = beta, alpha = alpha, 
              sigma.sq = sigma.sq, phi = phi, sp = TRUE, cov.model = 'exponential')
# Split into fitting and prediction data set
pred.indx &lt;- sample(1:J, round(J * .5), replace = FALSE)
y &lt;- dat$y[-pred.indx, ]
# Occupancy covariates
X &lt;- dat$X[-pred.indx, ]
# Prediction covariates
X.0 &lt;- dat$X[pred.indx, ]
# Detection covariates
X.p &lt;- dat$X.p[-pred.indx, , ]
coords &lt;- as.matrix(dat$coords[-pred.indx, ])
coords.0 &lt;- as.matrix(dat$coords[pred.indx, ])
psi.0 &lt;- dat$psi[pred.indx]
w.0 &lt;- dat$w[pred.indx]

# Package all data into a list
occ.covs &lt;- X[, -1, drop = FALSE]
colnames(occ.covs) &lt;- c('occ.cov')
det.covs &lt;- list(det.cov.1 = X.p[, , 2])
data.list &lt;- list(y = y, 
                  occ.covs = occ.covs, 
                  det.covs = det.covs, 
                  coords = coords)

# Number of batches
n.batch &lt;- 10
# Batch length
batch.length &lt;- 25
n.iter &lt;- n.batch * batch.length
# Priors 
prior.list &lt;- list(beta.normal = list(mean = 0, var = 2.72), 
                   alpha.normal = list(mean = 0, var = 2.72),
                   sigma.sq.ig = c(2, 2), 
                   phi.unif = c(3/1, 3/.1)) 
# Initial values
inits.list &lt;- list(alpha = 0, beta = 0,
                   phi = 3 / .5, 
                   sigma.sq = 2,
                   w = rep(0, nrow(X)),
                   z = apply(y, 1, max, na.rm = TRUE))
# Tuning
tuning.list &lt;- list(phi = 1) 

out &lt;- spPGOcc(occ.formula = ~ occ.cov, 
               det.formula = ~ det.cov.1, 
               data = data.list, 
               inits = inits.list, 
               n.batch = n.batch, 
               batch.length = batch.length, 
               accept.rate = 0.43, 
               priors = prior.list,
               cov.model = 'exponential', 
               tuning = tuning.list, 
               n.omp.threads = 1, 
               verbose = TRUE, 
               NNGP = FALSE, 
               n.neighbors = 15, 
               search.type = 'cb', 
               n.report = 10, 
               n.burn = 50, 
               n.thin = 1)

summary(out) 

# Predict at new locations ------------------------------------------------
out.pred &lt;- predict(out, X.0, coords.0, verbose = FALSE)
</code></pre>

<hr>
<h2 id='predict.stMsPGOcc'>Function for prediction at new locations for multi-season multi-species spatial occupancy models</h2><span id='topic+predict.stMsPGOcc'></span>

<h3>Description</h3>

<p>The function <code>predict</code> collects posterior predictive samples for a set of new locations given an object of class 'stMsPGOcc'. Prediction is possible for both the latent occupancy state as well as detection. Predictions are currently only possible for sampled primary time periods.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'stMsPGOcc'
predict(object, X.0, coords.0, t.cols, n.omp.threads = 1, 
                          verbose = TRUE, n.report = 100, 
                          ignore.RE = FALSE, type = 'occupancy', grid.index.0, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.stMsPGOcc_+3A_object">object</code></td>
<td>
<p>an object of class stMsPGOcc</p>
</td></tr>
<tr><td><code id="predict.stMsPGOcc_+3A_x.0">X.0</code></td>
<td>
<p>the design matrix of covariates at the prediction locations. This should be a three-dimensional array, with dimensions corresponding to site, primary time period, and covariate, respectively. Note that the first covariate should consist of all 1s for the intercept if an intercept is included in the model. If random effects are included in the occupancy (or detection if <code>type = 'detection'</code>) portion of the model, the levels of the random effects at the new locations/time periods should be included as an element of the three-dimensional array. The ordering of the levels should match the ordering used to fit the data in <code>stMsPGOcc</code>. The covariates should be organized in the same order as they were specified in the corresponding formula argument of <code>stMsPGOcc</code>. Names of the third dimension (covariates) of any random effects in X.0 must match the name of the random effects used to fit the model, if specified in the corresponding formula argument of <code>stMsPGOcc</code>. See example below.</p>
</td></tr>
<tr><td><code id="predict.stMsPGOcc_+3A_coords.0">coords.0</code></td>
<td>
<p>the spatial coordinates corresponding to <code>X.0</code>. Note that <code>spOccupancy</code> assumes coordinates are specified 
in a projected coordinate system.</p>
</td></tr>
<tr><td><code id="predict.stMsPGOcc_+3A_t.cols">t.cols</code></td>
<td>
<p>an indexing vector used to denote which primary time periods are contained in the design matrix of covariates at the prediction locations (<code>X.0</code>). The values should denote the specific primary time periods used to fit the model. The values should indicate the columns in <code>data$y</code> used to fit the model for which prediction is desired. See example below.</p>
</td></tr> 
<tr><td><code id="predict.stMsPGOcc_+3A_n.omp.threads">n.omp.threads</code></td>
<td>
<p>a positive integer indicating
the number of threads to use for SMP parallel processing. The package must
be compiled for OpenMP support. For most Intel-based machines, we recommend setting
<code>n.omp.threads</code> up to the number of hyperthreaded cores. 
Note, <code>n.omp.threads</code> &gt; 1 might not work on some systems.</p>
</td></tr>
<tr><td><code id="predict.stMsPGOcc_+3A_verbose">verbose</code></td>
<td>
<p>if <code>TRUE</code>, model specification and progress of the 
sampler is printed to the screen. Otherwise, nothing is printed to
the screen.</p>
</td></tr>
<tr><td><code id="predict.stMsPGOcc_+3A_ignore.re">ignore.RE</code></td>
<td>
<p>logical value that specifies whether or not to remove random unstructured occurrence (or detection if <code>type = 'detection'</code>) effects from the subsequent predictions. If <code>TRUE</code>, random effects will be included. If <code>FALSE</code>, unstructured random effects will be set to 0 and predictions will only be generated from the fixed effects, the spatial random effects, and AR(1) random effects if the model was fit with <code>ar1 = TRUE</code>.</p>
</td></tr>
<tr><td><code id="predict.stMsPGOcc_+3A_n.report">n.report</code></td>
<td>
<p>the interval to report sampling progress.</p>
</td></tr>
<tr><td><code id="predict.stMsPGOcc_+3A_type">type</code></td>
<td>
<p>a quoted keyword indicating what type of prediction to produce. Valid keywords are 'occupancy' to predict latent occupancy probability and latent occupancy values (this is the default), or 'detection' to predict detection probability given new values of detection covariates.</p>
</td></tr>
<tr><td><code id="predict.stMsPGOcc_+3A_grid.index.0">grid.index.0</code></td>
<td>
<p>an indexing vector used to specify how each row in <code>X.0</code> corresponds to the coordinates specified in <code>coords.0</code>. Only relevant if the spatial random effect was estimated at a higher spatial resolution (e.g., grid cells) than point locations.</p>
</td></tr>
<tr><td><code id="predict.stMsPGOcc_+3A_...">...</code></td>
<td>
<p>currently no additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list object of class <code>predict.stMsPGOcc</code>. When <code>type = 'occupancy'</code>, the list consists of: 
</p>
<table>
<tr><td><code>psi.0.samples</code></td>
<td>
<p>a four-dimensional object of posterior predictive samples for the
latent occupancy probability values with dimensions corresponding to posterior predictive
sample, species, site, and primary time period.</p>
</td></tr>
<tr><td><code>z.0.samples</code></td>
<td>
<p>a three-dimensional object of posterior predictive samples for the
latent occupancy values with dimensions corresponding to posterior predictive sample, species, 
site, and primary time period.</p>
</td></tr>
<tr><td><code>w.0.samples</code></td>
<td>
<p>a three-dimensional array of posterior predictive samples
for the latent spatial factors with dimensions correpsonding to MCMC sample, latent factor, 
and site.</p>
</td></tr>
</table>
<p>When <code>type = 'detection'</code>, the list consists of: 
</p>
<table>
<tr><td><code>p.0.samples</code></td>
<td>
<p>a four-dimensional object of posterior predictive samples for the 
detection probability values with dimensions corresponding to posterior predictive 
sample, site, and primary time period.</p>
</td></tr>
</table>
<p>The return object will include additional objects used for standard 
extractor functions. 
</p>


<h3>Note</h3>

<p>When <code>ignore.RE = FALSE</code>, both sampled levels and non-sampled levels of unstructured random effects are supported for prediction. For sampled levels, the posterior distribution for the random intercept corresponding to that level of the random effect will be used in the prediction. For non-sampled levels, random values are drawn from a normal distribution using the posterior samples of the random effect variance, which results in fully propagated uncertainty in predictions with models that incorporate random effects. 
</p>
<p>Occurrence predictions at sites that are only sampled for a subset of the total number of primary time periods are obtained directly when fitting the model. See the <code>psi.samples</code> and <code>z.samples</code> portions of the output list from the model object of class <code>stMsPGOcc</code>. 
</p>


<h3>Author(s)</h3>

<p>Jeffrey W. Doser <a href="mailto:doserjef@msu.edu">doserjef@msu.edu</a>, <br />
Andrew O. Finley <a href="mailto:finleya@msu.edu">finleya@msu.edu</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simulate Data -----------------------------------------------------------
set.seed(500)
J.x &lt;- 8
J.y &lt;- 8
J &lt;- J.x * J.y
# Years sampled
n.time &lt;- sample(3:10, J, replace = TRUE)
# n.time &lt;- rep(10, J)
n.time.max &lt;- max(n.time)
# Replicates
n.rep &lt;- matrix(NA, J, max(n.time))
for (j in 1:J) {
  n.rep[j, 1:n.time[j]] &lt;- sample(2:4, n.time[j], replace = TRUE)
  # n.rep[j, 1:n.time[j]] &lt;- rep(4, n.time[j])
}
N &lt;- 7
# Community-level covariate effects
# Occurrence
beta.mean &lt;- c(-3, -0.2, 0.5)
trend &lt;- FALSE
sp.only &lt;- 0
p.occ &lt;- length(beta.mean)
tau.sq.beta &lt;- c(0.6, 1.5, 1.4)
# Detection
alpha.mean &lt;- c(0, 1.2, -1.5)
tau.sq.alpha &lt;- c(1, 0.5, 2.3)
p.det &lt;- length(alpha.mean)
# Random effects
psi.RE &lt;- list()
p.RE &lt;- list()
# Draw species-level effects from community means.
beta &lt;- matrix(NA, nrow = N, ncol = p.occ)
alpha &lt;- matrix(NA, nrow = N, ncol = p.det)
for (i in 1:p.occ) {
  beta[, i] &lt;- rnorm(N, beta.mean[i], sqrt(tau.sq.beta[i]))
}
for (i in 1:p.det) {
  alpha[, i] &lt;- rnorm(N, alpha.mean[i], sqrt(tau.sq.alpha[i]))
}
sp &lt;- TRUE
svc.cols &lt;- c(1)
p.svc &lt;- length(svc.cols)
n.factors &lt;- 3
phi &lt;- runif(p.svc * n.factors, 3 / .9, 3 / .3)
factor.model &lt;- TRUE
cov.model &lt;- 'exponential'
ar1 &lt;- TRUE
sigma.sq.t &lt;- runif(N, 0.05, 1)
rho &lt;- runif(N, 0.1, 1)

dat &lt;- simTMsOcc(J.x = J.x, J.y = J.y, n.time = n.time, n.rep = n.rep, N = N,
		 beta = beta, alpha = alpha, sp.only = sp.only, trend = trend,
		 psi.RE = psi.RE, p.RE = p.RE, factor.model = factor.model,
                 svc.cols = svc.cols, n.factors = n.factors, phi = phi, sp = sp,
                 cov.model = cov.model, ar1 = ar1, sigma.sq.t = sigma.sq.t, rho = rho)

# Subset data for prediction
pred.indx &lt;- sample(1:J, round(J * .25), replace = FALSE)
y &lt;- dat$y[, -pred.indx, , , drop = FALSE]
# Occupancy covariates
X &lt;- dat$X[-pred.indx, , , drop = FALSE]
# Prediction covariates
X.0 &lt;- dat$X[pred.indx, , , drop = FALSE]
# Detection covariates
X.p &lt;- dat$X.p[-pred.indx, , , , drop = FALSE]
# Coordinates
coords &lt;- dat$coords[-pred.indx, ]
coords.0 &lt;- dat$coords[pred.indx, ]

occ.covs &lt;- list(occ.cov.1 = X[, , 2],
		 occ.cov.2 = X[, , 3])
det.covs &lt;- list(det.cov.1 = X.p[, , , 2],
		 det.cov.2 = X.p[, , , 3])

data.list &lt;- list(y = y, occ.covs = occ.covs,
                  det.covs = det.covs,
                  coords = coords)
# Priors
prior.list &lt;- list(beta.comm.normal = list(mean = 0, var = 2.72),
		   alpha.comm.normal = list(mean = 0, var = 2.72),
		   tau.sq.beta.ig = list(a = 0.1, b = 0.1),
		   tau.sq.alpha.ig = list(a = 0.1, b = 0.1),
		   rho.unif = list(a = -1, b = 1),
		   sigma.sq.t.ig = list(a = 0.1, b = 0.1),
                   phi.unif = list(a = 3 / .9, b = 3 / .1))
z.init &lt;- apply(y, c(1, 2, 3), function(a) as.numeric(sum(a, na.rm = TRUE) &gt; 0))
inits.list &lt;- list(alpha.comm = 0, beta.comm = 0, beta = 0,
		   alpha = 0, tau.sq.beta = 1, tau.sq.alpha = 1,
		   rho = 0.5, sigma.sq.t = 0.5,
		   phi = 3 / .5, z = z.init)
# Tuning
tuning.list &lt;- list(phi = 1, rho = 0.5)

# Number of batches
n.batch &lt;- 5
# Batch length
batch.length &lt;- 25
n.burn &lt;- 25
n.thin &lt;- 1
n.samples &lt;- n.batch * batch.length

out &lt;- stMsPGOcc(occ.formula = ~ occ.cov.1 + occ.cov.2,
                det.formula = ~ det.cov.1 + det.cov.2,
                data = data.list,
                inits = inits.list,
                n.batch = n.batch,
                batch.length = batch.length,
                accept.rate = 0.43,
		ar1 = TRUE,
		NNGP = TRUE,
		n.neighbors = 5,
		n.factors = n.factors,
		cov.model = 'exponential',
                priors = prior.list,
                tuning = tuning.list,
                n.omp.threads = 1,
                verbose = TRUE,
                n.report = 1,
                n.burn = n.burn,
		n.thin = n.thin,
		n.chains = 1)

summary(out)

# Predict at new sites across all n.max.years
# Take a look at array of covariates for prediction
str(X.0)
# Subset to only grab time periods 1, 2, and 5
t.cols &lt;- c(1, 2, 5)
X.pred &lt;- X.0[, t.cols, ]
out.pred &lt;- predict(out, X.pred, coords.0, t.cols = t.cols, type = 'occupancy')
str(out.pred)
</code></pre>

<hr>
<h2 id='predict.stPGOcc'>Function for prediction at new locations for multi-season single-species spatial occupancy models</h2><span id='topic+predict.stPGOcc'></span>

<h3>Description</h3>

<p>The function <code>predict</code> collects posterior predictive samples for a set of new locations given an object of class 'stPGOcc'. Prediction is possible for both the latent occupancy state as well as detection. Predictions are currently only possible for sampled primary time periods.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'stPGOcc'
predict(object, X.0, coords.0, t.cols, n.omp.threads = 1, 
                          verbose = TRUE, n.report = 100, 
                          ignore.RE = FALSE, type = 'occupancy', 
                          forecast = FALSE, grid.index.0, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.stPGOcc_+3A_object">object</code></td>
<td>
<p>an object of class stPGOcc</p>
</td></tr>
<tr><td><code id="predict.stPGOcc_+3A_x.0">X.0</code></td>
<td>
<p>the design matrix of covariates at the prediction locations. This should be a three-dimensional array, with dimensions corresponding to site, primary time period, and covariate, respectively. Note that the first covariate should consist of all 1s for the intercept if an intercept is included in the model. If random effects are included in the occupancy (or detection if <code>type = 'detection'</code>) portion of the model, the levels of the random effects at the new locations/time periods should be included as an element of the three-dimensional array. The ordering of the levels should match the ordering used to fit the data in <code>stPGOcc</code>. The covariates should be organized in the same order as they were specified in the corresponding formula argument of <code>stPGOcc</code>. Names of the third dimension (covariates) of any random effects in X.0 must match the name of the random effects used to fit the model, if specified in the corresponding formula argument of <code>stPGOcc</code>. See example below.</p>
</td></tr>
<tr><td><code id="predict.stPGOcc_+3A_coords.0">coords.0</code></td>
<td>
<p>the spatial coordinates corresponding to <code>X.0</code>. Note that <code>spOccupancy</code> assumes coordinates are specified 
in a projected coordinate system.</p>
</td></tr>
<tr><td><code id="predict.stPGOcc_+3A_t.cols">t.cols</code></td>
<td>
<p>an indexing vector used to denote which primary time periods are contained in the design matrix of covariates at the prediction locations (<code>X.0</code>). The values should denote the specific primary time periods used to fit the model. The values should indicate the columns in <code>data$y</code> used to fit the model for which prediction is desired. See example below. Not required when <code>forecast = TRUE</code>.</p>
</td></tr> 
<tr><td><code id="predict.stPGOcc_+3A_n.omp.threads">n.omp.threads</code></td>
<td>
<p>a positive integer indicating
the number of threads to use for SMP parallel processing. The package must
be compiled for OpenMP support. For most Intel-based machines, we recommend setting
<code>n.omp.threads</code> up to the number of hyperthreaded cores. 
Note, <code>n.omp.threads</code> &gt; 1 might not work on some systems.</p>
</td></tr>
<tr><td><code id="predict.stPGOcc_+3A_verbose">verbose</code></td>
<td>
<p>if <code>TRUE</code>, model specification and progress of the 
sampler is printed to the screen. Otherwise, nothing is printed to
the screen.</p>
</td></tr>
<tr><td><code id="predict.stPGOcc_+3A_ignore.re">ignore.RE</code></td>
<td>
<p>logical value that specifies whether or not to remove random unstructured occurrence (or detection if <code>type = 'detection'</code>) effects from the subsequent predictions. If <code>TRUE</code>, random effects will be included. If <code>FALSE</code>, unstructured random effects will be set to 0 and predictions will only be generated from the fixed effects, the spatial random effects, and AR(1) random effects if the model was fit with <code>ar1 = TRUE</code>.</p>
</td></tr>
<tr><td><code id="predict.stPGOcc_+3A_n.report">n.report</code></td>
<td>
<p>the interval to report sampling progress.</p>
</td></tr>
<tr><td><code id="predict.stPGOcc_+3A_type">type</code></td>
<td>
<p>a quoted keyword indicating what type of prediction to produce. Valid keywords are 'occupancy' to predict latent occupancy probability and latent occupancy values (this is the default), or 'detection' to predict detection probability given new values of detection covariates.</p>
</td></tr>
<tr><td><code id="predict.stPGOcc_+3A_forecast">forecast</code></td>
<td>
<p>a logical value indicating whether prediction is occurring at non-sampled primary time periods (e.g., forecasting).</p>
</td></tr>
<tr><td><code id="predict.stPGOcc_+3A_grid.index.0">grid.index.0</code></td>
<td>
<p>an indexing vector used to specify how each row in <code>X.0</code> corresponds to the coordinates specified in <code>coords.0</code>. Only relevant if the spatial random effect was estimated at a higher spatial resolution (e.g., grid cells) than point locations.</p>
</td></tr>
<tr><td><code id="predict.stPGOcc_+3A_...">...</code></td>
<td>
<p>currently no additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list object of class <code>predict.stPGOcc</code>. When <code>type = 'occupancy'</code>, the list consists of: 
</p>
<table>
<tr><td><code>psi.0.samples</code></td>
<td>
<p>a three-dimensional object of posterior predictive samples for the
latent occupancy probability values with dimensions corresponding to posterior predictive
sample, site, and primary time period.</p>
</td></tr>
<tr><td><code>z.0.samples</code></td>
<td>
<p>a three-dimensional object of posterior predictive samples for the
latent occupancy values with dimensions corresponding to posterior predictive sample, site, 
and primary time period.</p>
</td></tr>
<tr><td><code>w.0.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior predictive samples 
for the latent spatial random effects.</p>
</td></tr>
</table>
<p>When <code>type = 'detection'</code>, the list consists of: 
</p>
<table>
<tr><td><code>p.0.samples</code></td>
<td>
<p>a three-dimensional object of posterior predictive samples for the 
detection probability values with dimensions corresponding to posterior predictive 
sample, site, and primary time period.</p>
</td></tr>
</table>
<p>The return object will include additional objects used for standard 
extractor functions. 
</p>


<h3>Note</h3>

<p>When <code>ignore.RE = FALSE</code>, both sampled levels and non-sampled levels of unstructured random effects are supported for prediction. For sampled levels, the posterior distribution for the random intercept corresponding to that level of the random effect will be used in the prediction. For non-sampled levels, random values are drawn from a normal distribution using the posterior samples of the random effect variance, which results in fully propagated uncertainty in predictions with models that incorporate random effects. 
</p>
<p>Occurrence predictions at sites that are only sampled for a subset of the total number of primary time periods are obtained directly when fitting the model. See the <code>psi.samples</code> and <code>z.samples</code> portions of the output list from the model object of class <code>stPGOcc</code>. 
</p>


<h3>Author(s)</h3>

<p>Jeffrey W. Doser <a href="mailto:doserjef@msu.edu">doserjef@msu.edu</a>, <br />
Andrew O. Finley <a href="mailto:finleya@msu.edu">finleya@msu.edu</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(500)
# Sites
J.x &lt;- 10
J.y &lt;- 10
J &lt;- J.x * J.y
# Primary time periods
n.time &lt;- sample(10, J, replace = TRUE)
n.time.max &lt;- max(n.time)
# Replicates
n.rep &lt;- matrix(NA, J, max(n.time))
for (j in 1:J) {
  n.rep[j, 1:n.time[j]] &lt;- sample(1:4, n.time[j], replace = TRUE)
}
# Occurrence --------------------------
beta &lt;- c(0.4, 0.5, -0.9)
trend &lt;- TRUE 
sp.only &lt;- 0
psi.RE &lt;- list()
# Detection ---------------------------
alpha &lt;- c(-1, 0.7, -0.5)
p.RE &lt;- list()
# Spatial -----------------------------
sp &lt;- TRUE
cov.model &lt;- "exponential"
sigma.sq &lt;- 2
phi &lt;- 3 / .4

# Get all the data
dat &lt;- simTOcc(J.x = J.x, J.y = J.y, n.time = n.time, n.rep = n.rep, 
               beta = beta, alpha = alpha, sp.only = sp.only, trend = trend, 
               psi.RE = psi.RE, p.RE = p.RE, sp = TRUE, sigma.sq = sigma.sq, 
               phi = phi, cov.model = cov.model, ar1 = FALSE)

# Subset data for prediction
pred.indx &lt;- sample(1:J, round(J * .25), replace = FALSE)
y &lt;- dat$y[-pred.indx, , , drop = FALSE]
# Occupancy covariates
X &lt;- dat$X[-pred.indx, , , drop = FALSE]
# Prediction covariates
X.0 &lt;- dat$X[pred.indx, , , drop = FALSE]
# Detection covariates
X.p &lt;- dat$X.p[-pred.indx, , , , drop = FALSE]
psi.0 &lt;- dat$psi[pred.indx, ]
# Coordinates
coords &lt;- dat$coords[-pred.indx, ]
coords.0 &lt;- dat$coords[pred.indx, ]

# Package all data into a list
# Occurrence
occ.covs &lt;- list(int = X[, , 1], 
                 trend = X[, , 2], 
                 occ.cov.1 = X[, , 3]) 
# Detection
det.covs &lt;- list(det.cov.1 = X.p[, , , 2], 
                 det.cov.2 = X.p[, , , 3]) 
# Data list bundle
data.list &lt;- list(y = y, 
                  occ.covs = occ.covs,
                  det.covs = det.covs, 
                  coords = coords) 
# Priors
prior.list &lt;- list(beta.normal = list(mean = 0, var = 2.72), 
                   alpha.normal = list(mean = 0, var = 2.72), 
                   sigma.sq.ig = c(2, 2), 
                   phi.unif = c(3 / 1, 3 / 0.1))

# Initial values
z.init &lt;- apply(y, c(1, 2), function(a) as.numeric(sum(a, na.rm = TRUE) &gt; 0))
inits.list &lt;- list(beta = 0, alpha = 0, z = z.init, phi = 3 / .5, sigma.sq = 2, 
                   w = rep(0, J))
# Tuning
tuning.list &lt;- list(phi = 1)
# Number of batches
n.batch &lt;- 10
# Batch length
batch.length &lt;- 25
n.iter &lt;- n.batch * batch.length

# Run the model
out &lt;- stPGOcc(occ.formula = ~ trend + occ.cov.1, 
               det.formula = ~ det.cov.1 + det.cov.2, 
               data = data.list, 
               inits = inits.list, 
               n.batch = n.batch, 
               batch.length = batch.length, 
               priors = prior.list,
               cov.model = "exponential", 
               tuning = tuning.list, 
               NNGP = TRUE, 
               ar1 = FALSE,
               n.neighbors = 5, 
               search.type = 'cb', 
               n.report = 10, 
               n.burn = 50, 
               n.chains = 1)

summary(out)

# Predict at new sites across all n.max.years
# Take a look at array of covariates for prediction
str(X.0)
# Subset to only grab time periods 1, 2, and 5
t.cols &lt;- c(1, 2, 5)
X.pred &lt;- X.0[, t.cols, ]
out.pred &lt;- predict(out, X.0, coords.0, t.cols = t.cols, type = 'occupancy')
str(out.pred)
</code></pre>

<hr>
<h2 id='predict.svcMsPGOcc'>Function for prediction at new locations for spatially varying coefficient multi-species occupancy models</h2><span id='topic+predict.svcMsPGOcc'></span>

<h3>Description</h3>

<p>The function <code>predict</code> collects posterior predictive samples for a set of new locations given an object of class 'svcMsPGOcc'. Prediction is possible for both the latent occupancy state as well as detection.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'svcMsPGOcc'
predict(object, X.0, coords.0, n.omp.threads = 1, verbose = TRUE, 
        n.report = 100, ignore.RE = FALSE, type = 'occupancy', ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.svcMsPGOcc_+3A_object">object</code></td>
<td>
<p>an object of class svcMsPGOcc</p>
</td></tr>
<tr><td><code id="predict.svcMsPGOcc_+3A_x.0">X.0</code></td>
<td>
<p>the design matrix of covariates at the prediction locations. This should include a column of 1s for the intercept if an intercept is included in the model. If random effects are included in the occupancy (or detection if <code>type = 'detection'</code>) portion of the model, the levels of the random effects at the new locations should be included as a column in the design matrix. The ordering of the levels should match the ordering used to fit the data in <code>svcMsPGOcc</code>. Columns should correspond to the order of how covariates were specified in the corresponding formula argument of <code>svcMsPGOcc</code>. Column names of the random effects must match the name of the random effects, if specified in the corresponding formula argument of <code>svcMsPGOcc</code>.</p>
</td></tr>
<tr><td><code id="predict.svcMsPGOcc_+3A_coords.0">coords.0</code></td>
<td>
<p>the spatial coordinates corresponding to <code>X.0</code>. Note that <code>spOccupancy</code> assumes coordinates are specified 
in a projected coordinate system.</p>
</td></tr>
<tr><td><code id="predict.svcMsPGOcc_+3A_n.omp.threads">n.omp.threads</code></td>
<td>
<p>a positive integer indicating
the number of threads to use for SMP parallel processing. The package must
be compiled for OpenMP support. For most Intel-based machines, we recommend setting
<code>n.omp.threads</code> up to the number of hyperthreaded cores. 
Note, <code>n.omp.threads</code> &gt; 1 might not work on some systems.</p>
</td></tr>
<tr><td><code id="predict.svcMsPGOcc_+3A_verbose">verbose</code></td>
<td>
<p>if <code>TRUE</code>, model specification and progress of the 
sampler is printed to the screen. Otherwise, nothing is printed to
the screen.</p>
</td></tr>
<tr><td><code id="predict.svcMsPGOcc_+3A_n.report">n.report</code></td>
<td>
<p>the interval to report sampling progress.</p>
</td></tr>
<tr><td><code id="predict.svcMsPGOcc_+3A_ignore.re">ignore.RE</code></td>
<td>
<p>a logical value indicating whether to include unstructured random 
effects for prediction. If TRUE, unstructured random effects will be ignored and 
prediction will only use the fixed effects and the spatial random effects. If FALSE, 
random effects will be included in the prediction for both observed and unobserved 
levels of the unstructured random effects.</p>
</td></tr>
<tr><td><code id="predict.svcMsPGOcc_+3A_type">type</code></td>
<td>
<p>a quoted keyword indicating what type of prediction to produce. Valid keywords are 'occupancy' to predict latent occupancy probability and latent occupancy values (this is the default), or 'detection' to predict detection probability given new values of detection covariates.</p>
</td></tr>
<tr><td><code id="predict.svcMsPGOcc_+3A_...">...</code></td>
<td>
<p>currently no additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An list object of class <code>predict.svcMsPGOcc</code>. When <code>type = 'occupancy'</code>, the list consists of:  
</p>
<table>
<tr><td><code>psi.0.samples</code></td>
<td>
<p>a three-dimensional array of posterior predictive samples for the
latent occurrence probability values.</p>
</td></tr>
<tr><td><code>z.0.samples</code></td>
<td>
<p>a three-dimensional array of posterior predictive samples for the
latent occurrence values.</p>
</td></tr>
<tr><td><code>w.0.samples</code></td>
<td>
<p>a four-dimensional array of posterior predictive samples
for the spatially-varying coefficients, with dimensions corresponding to 
MCMC sample, spatial factor, site, and spatially varying coefficient.</p>
</td></tr>
<tr><td><code>run.time</code></td>
<td>
<p>execution time reported using <code>proc.time()</code>.</p>
</td></tr>
</table>
<p>When <code>type = 'detection'</code>, the list consists of: 
</p>
<table>
<tr><td><code>p.0.samples</code></td>
<td>
<p>a three-dimensional array of posterior predictive samples for the 
detection probability values.</p>
</td></tr>
<tr><td><code>run.time</code></td>
<td>
<p>execution time reported using <code>proc.time()</code>.</p>
</td></tr>
</table>
<p>The return object will include additional objects used for standard 
extractor functions. 
</p>


<h3>Note</h3>

<p>When <code>ignore.RE = FALSE</code>, both sampled levels and non-sampled levels of random effects are supported for prediction. For sampled levels, the posterior distribution for the random intercept corresponding to that level of the random effect will be used in the prediction. For non-sampled levels, random values are drawn from a normal distribution using the posterior samples of the random effect variance, which results in fully propagated uncertainty in predictions with models that incorporate random effects.
</p>


<h3>Author(s)</h3>

<p>Jeffrey W. Doser <a href="mailto:doserjef@msu.edu">doserjef@msu.edu</a>, <br />
Andrew O. Finley <a href="mailto:finleya@msu.edu">finleya@msu.edu</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(400)

# Simulate Data -----------------------------------------------------------
J.x &lt;- 10
J.y &lt;- 10
J &lt;- J.x * J.y
n.rep &lt;- sample(5, size = J, replace = TRUE)
N &lt;- 6
# Community-level covariate effects
# Occurrence
beta.mean &lt;- c(0.2, -0.2, 0.3, -0.1, 0.4)
p.occ &lt;- length(beta.mean)
tau.sq.beta &lt;- c(0.6, 1.5, 0.4, 0.5, 0.3)
# Detection
alpha.mean &lt;- c(0, 1.2, -0.5)
tau.sq.alpha &lt;- c(1, 0.5, 1.3)
p.det &lt;- length(alpha.mean)
# No random effects
psi.RE &lt;- list()
p.RE &lt;- list()
# Draw species-level effects from community means.
beta &lt;- matrix(NA, nrow = N, ncol = p.occ)
alpha &lt;- matrix(NA, nrow = N, ncol = p.det)
for (i in 1:p.occ) {
  beta[, i] &lt;- rnorm(N, beta.mean[i], sqrt(tau.sq.beta[i]))
}
for (i in 1:p.det) {
  alpha[, i] &lt;- rnorm(N, alpha.mean[i], sqrt(tau.sq.alpha[i]))
}
# Number of spatial factors for each SVC
n.factors &lt;- 2
# The intercept and first two covariates have spatially-varying effects
svc.cols &lt;- c(1, 2, 3)
p.svc &lt;- length(svc.cols)
q.p.svc &lt;- n.factors * p.svc
# Spatial decay parameters
phi &lt;- runif(q.p.svc, 3 / 0.9, 3 / 0.1)
# A length N vector indicating the proportion of simulated locations
# that are within the range for a given species.
range.probs &lt;- runif(N, 1, 1)
factor.model &lt;- TRUE
cov.model &lt;- 'spherical'
sp &lt;- TRUE

dat &lt;- simMsOcc(J.x = J.x, J.y = J.y, n.rep = n.rep, N = N, beta = beta, alpha = alpha,
		psi.RE = psi.RE, p.RE = p.RE, phi = phi, sp = sp, svc.cols = svc.cols,
		cov.model = cov.model, n.factors = n.factors,
		factor.model = factor.model, range.probs = range.probs)

# Split into fitting and prediction data set
pred.indx &lt;- sample(1:J, round(J * .25), replace = FALSE)
y &lt;- dat$y[, -pred.indx, ]
# Occupancy covariates
X &lt;- dat$X[-pred.indx, ]
# Coordinates
coords &lt;- as.matrix(dat$coords[-pred.indx, ])
# Detection covariates
X.p &lt;- dat$X.p[-pred.indx, , ]
# Prediction values
X.0 &lt;- dat$X[pred.indx, ]
coords.0 &lt;- as.matrix(dat$coords[pred.indx, ])

# Prep data for spOccupancy -----------------------------------------------
# Occurrence covariates
occ.covs &lt;- cbind(X)
colnames(occ.covs) &lt;- c('int', 'occ.cov.1', 'occ.cov.2', 'occ.cov.3',
			'occ.cov.4')
# Detection covariates
det.covs &lt;- list(det.cov.1 = X.p[, , 2],
		 det.cov.2 = X.p[, , 3])
# Data list
data.list &lt;- list(y = y, coords = coords, occ.covs = occ.covs,
                  det.covs = det.covs)
# Priors
prior.list &lt;- list(beta.comm.normal = list(mean = 0, var = 2.72),
		   alpha.comm.normal = list(mean = 0, var = 2.72),
		   tau.sq.beta.ig = list(a = 0.1, b = 0.1),
		   tau.sq.alpha.ig = list(a = 0.1, b = 0.1),
                   phi.unif = list(a = 3 / 1, b = 3 / .1))
inits.list &lt;- list(alpha.comm = 0,
		   beta.comm = 0,
		   beta = 0,
		   alpha = 0,
		   tau.sq.beta = 1,
		   tau.sq.alpha = 1,
		   z = apply(y, c(1, 2), max, na.rm = TRUE))
# Tuning
tuning.list &lt;- list(phi = 1)

# Number of batches
n.batch &lt;- 2
# Batch length
batch.length &lt;- 25
n.burn &lt;- 0
n.thin &lt;- 1
n.samples &lt;- n.batch * batch.length

out &lt;- svcMsPGOcc(occ.formula = ~ occ.cov.1 + occ.cov.2 + occ.cov.3 +
                                  occ.cov.4,
                  det.formula = ~ det.cov.1 + det.cov.2,
                  data = data.list,
                  inits = inits.list,
                  n.batch = n.batch,
		  n.factors = n.factors,
                  batch.length = batch.length,
		  std.by.sp = TRUE,
                  accept.rate = 0.43,
                  priors = prior.list,
		  svc.cols = svc.cols,
                  cov.model = "spherical",
                  tuning = tuning.list,
                  n.omp.threads = 1,
                  verbose = TRUE,
                  NNGP = TRUE,
                  n.neighbors = 5,
                  search.type = 'cb',
                  n.report = 10,
                  n.burn = n.burn,
		  n.thin = n.thin,
		  n.chains = 1)

summary(out)
# Predict at new locations ------------------------------------------------
out.pred &lt;- predict(out, X.0, coords.0, verbose = FALSE)

# Get SVC samples for each species at prediction locations
svc.samples &lt;- getSVCSamples(out, out.pred)
</code></pre>

<hr>
<h2 id='predict.svcPGBinom'>Function for prediction at new locations for single-species spatially-varying coefficient Binomial models</h2><span id='topic+predict.svcPGBinom'></span>

<h3>Description</h3>

<p>The function <code>predict</code> collects posterior predictive samples for a set of new 
locations given an object of class 'svcPGBinom'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'svcPGBinom'
predict(object, X.0, coords.0, weights.0, n.omp.threads = 1, verbose = TRUE, 
        n.report = 100, ignore.RE = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.svcPGBinom_+3A_object">object</code></td>
<td>
<p>an object of class <code>svcPGBinom</code></p>
</td></tr>
<tr><td><code id="predict.svcPGBinom_+3A_x.0">X.0</code></td>
<td>
<p>the design matrix of covariates at the prediction locations. Note that for spatially-varying coefficients models the order of covariates in <code>X.0</code> must be the same as the order of covariates specified in the model formula. This should include a column of 1s for the intercept if an intercept is included in the model. If unstructured random effects are included in the model, the levels of the random effects at the new locations should be included as a column in the design matrix. The ordering of the levels should match the ordering used to fit the data in <code>svcPGBinom</code>. Columns should correspond to the order of how covariates were specified in the corresponding formula argument of <code>svcPGBinom</code>. Column names of the random effects must match the name of the random effects, if specified in the corresponding formula argument of <code>svcPGBinom</code>.</p>
</td></tr>
<tr><td><code id="predict.svcPGBinom_+3A_coords.0">coords.0</code></td>
<td>
<p>the spatial coordinates corresponding to <code>X.0</code>. Note that <code>spOccupancy</code> assumes coordinates are specified in a projected coordinate system.</p>
</td></tr>
<tr><td><code id="predict.svcPGBinom_+3A_weights.0">weights.0</code></td>
<td>
<p>a numeric vector containing the binomial weights (i.e., the total number of 
Bernoulli trials) at each site. If <code>weights.0</code> is not specified, 
we assume 1 trial at each site (i.e., presence/absence).</p>
</td></tr>
<tr><td><code id="predict.svcPGBinom_+3A_n.omp.threads">n.omp.threads</code></td>
<td>
<p>a positive integer indicating
the number of threads to use for SMP parallel processing. The package must
be compiled for OpenMP support. For most Intel-based machines, we recommend setting
<code>n.omp.threads</code> up to the number of hyperthreaded cores. 
Note, <code>n.omp.threads</code> &gt; 1 might not work on some systems.</p>
</td></tr>
<tr><td><code id="predict.svcPGBinom_+3A_verbose">verbose</code></td>
<td>
<p>if <code>TRUE</code>, model specification and progress of the 
sampler is printed to the screen. Otherwise, nothing is printed to
the screen.</p>
</td></tr>
<tr><td><code id="predict.svcPGBinom_+3A_ignore.re">ignore.RE</code></td>
<td>
<p>a logical value indicating whether to include unstructured random 
effects for prediction. If TRUE, unstructured random effects will be ignored and 
prediction will only use the fixed effects and the spatial random effects. If FALSE, 
random effects will be included in the prediction for both observed and unobserved 
levels of the unstructured random effects.</p>
</td></tr>
<tr><td><code id="predict.svcPGBinom_+3A_n.report">n.report</code></td>
<td>
<p>the interval to report sampling progress.</p>
</td></tr>
<tr><td><code id="predict.svcPGBinom_+3A_...">...</code></td>
<td>
<p>currently no additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list object of class <code>predict.svcPGBinom</code> consisting of:  
</p>
<table>
<tr><td><code>psi.0.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior predictive samples 
for the binomial probability values.</p>
</td></tr>
<tr><td><code>y.0.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior predictive samples 
for the binomial data.</p>
</td></tr>
<tr><td><code>w.0.samples</code></td>
<td>
<p>a three-dimensional array of posterior predictive samples
for the spatial random effects, with dimensions corresponding to MCMC iteration, 
coefficient, and site.</p>
</td></tr>
<tr><td><code>run.time</code></td>
<td>
<p>execution time reported using <code>proc.time()</code>.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>When <code>ignore.RE = FALSE</code>, both sampled levels and non-sampled levels of random effects are supported for prediction. For sampled levels, the posterior distribution for the random intercept corresponding to that level of the random effect will be used in the prediction. For non-sampled levels, random values are drawn from a normal distribution using the posterior samples of the random effect variance, which results in fully propagated uncertainty in predictions with models that incorporate random effects.
</p>


<h3>Author(s)</h3>

<p>Jeffrey W. Doser <a href="mailto:doserjef@msu.edu">doserjef@msu.edu</a>, <br />
Andrew O. Finley <a href="mailto:finleya@msu.edu">finleya@msu.edu</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1000)
# Sites
J.x &lt;- 10
J.y &lt;- 10
J &lt;- J.x * J.y
# Binomial weights
weights &lt;- sample(10, J, replace = TRUE)
beta &lt;- c(0, 0.5, -0.2, 0.75)
p &lt;- length(beta)
# No unstructured random effects
psi.RE &lt;- list()
# Spatial parameters
sp &lt;- TRUE
# Two spatially-varying covariates. 
svc.cols &lt;- c(1, 2)
p.svc &lt;- length(svc.cols)
cov.model &lt;- "exponential"
sigma.sq &lt;- runif(p.svc, 0.4, 1.5)
phi &lt;- runif(p.svc, 3/1, 3/0.2)

# Simulate the data  
dat &lt;- simBinom(J.x = J.x, J.y = J.y, weights = weights, beta = beta, 
                psi.RE = psi.RE, sp = sp, svc.cols = svc.cols, 
                cov.model = cov.model, sigma.sq = sigma.sq, phi = phi)

# Binomial data
y &lt;- dat$y
# Covariates
X &lt;- dat$X
# Spatial coordinates
coords &lt;- dat$coords

# Subset data for prediction if desired
pred.indx &lt;- sample(1:J, round(J * .25), replace = FALSE)
y.0 &lt;- y[pred.indx, drop = FALSE]
X.0 &lt;- X[pred.indx, , drop = FALSE]
coords.0 &lt;- coords[pred.indx, ]
y &lt;- y[-pred.indx, drop = FALSE]
X &lt;- X[-pred.indx, , drop = FALSE]
coords &lt;- coords[-pred.indx, ]
weights.0 &lt;- weights[pred.indx]
weights &lt;- weights[-pred.indx]

# Package all data into a list
# Covariates
covs &lt;- cbind(X)
colnames(covs) &lt;- c('int', 'cov.1', 'cov.2', 'cov.3')

# Data list bundle
data.list &lt;- list(y = y, 
                  covs = covs,
                  coords = coords, 
                  weights = weights)
# Priors
prior.list &lt;- list(beta.normal = list(mean = 0, var = 2.72), 
                   sigma.sq.ig = list(a = 2, b = 1), 
                   phi.unif = list(a = 3 / 1, b = 3 / 0.1)) 

# Starting values
inits.list &lt;- list(beta = 0, alpha = 0,
                   sigma.sq = 1, phi = phi)
# Tuning
tuning.list &lt;- list(phi = 1) 

n.batch &lt;- 10
batch.length &lt;- 25
n.burn &lt;- 100
n.thin &lt;- 1

out &lt;- svcPGBinom(formula = ~ cov.1 + cov.2 + cov.3, 
                  svc.cols = c(1, 2),
                  data = data.list, 
                  n.batch = n.batch, 
                  batch.length = batch.length, 
                  inits = inits.list, 
                  priors = prior.list,
                  accept.rate = 0.43, 
                  cov.model = "exponential", 
                  tuning = tuning.list, 
                  n.omp.threads = 1, 
                  verbose = TRUE, 
                  NNGP = TRUE, 
                  n.neighbors = 5,
                  n.report = 2, 
                  n.burn = n.burn, 
                  n.thin = n.thin, 
                  n.chains = 1) 

summary(out)

# Predict at new locations ------------------------------------------------
out.pred &lt;- predict(out, X.0, coords.0, weights.0, verbose = FALSE)
str(out.pred)
</code></pre>

<hr>
<h2 id='predict.svcPGOcc'>Function for prediction at new locations for single-species spatially-varying coefficient occupancy models</h2><span id='topic+predict.svcPGOcc'></span>

<h3>Description</h3>

<p>The function <code>predict</code> collects posterior predictive samples for a set of new 
locations given an object of class 'svcPGOcc'. Prediction is possible for both the 
latent occupancy state as well as detection.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
## S3 method for class 'svcPGOcc'
predict(object, X.0, coords.0, weights.0, n.omp.threads = 1, verbose = TRUE, 
        n.report = 100, ignore.RE = FALSE, type = 'occupancy', grid.index.0, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.svcPGOcc_+3A_object">object</code></td>
<td>
<p>an object of class <code>svcPGOcc</code></p>
</td></tr>
<tr><td><code id="predict.svcPGOcc_+3A_x.0">X.0</code></td>
<td>
<p>the design matrix of covariates at the prediction locations. This should include a column of 1s for the intercept if an intercept is included in the model. If random effects are included in the occupancy (or detection if <code>type = 'detection'</code>) portion of the model, the levels of the random effects at the new locations should be included as a column in the design matrix. The ordering of the levels should match the ordering used to fit the data in <code>svcPGOcc</code>. Columns should correspond to the order of how covariates were specified in the corresponding formula argument of <code>svcPGOcc</code>. Column names of the random effects must match the name of the random effects, if specified in the corresponding formula argument of <code>svcPGOcc</code>.</p>
</td></tr>
<tr><td><code id="predict.svcPGOcc_+3A_coords.0">coords.0</code></td>
<td>
<p>the spatial coordinates corresponding to <code>X.0</code>. Note that <code>spOccupancy</code> assumes coordinates are specified 
in a projected coordinate system.</p>
</td></tr>
<tr><td><code id="predict.svcPGOcc_+3A_weights.0">weights.0</code></td>
<td>
<p>not used for objects of class <code>svcTPGOcc</code>. Used when 
calling other functions.</p>
</td></tr>
<tr><td><code id="predict.svcPGOcc_+3A_n.omp.threads">n.omp.threads</code></td>
<td>
<p>a positive integer indicating
the number of threads to use for SMP parallel processing. The package must
be compiled for OpenMP support. For most Intel-based machines, we recommend setting
<code>n.omp.threads</code> up to the number of hyperthreaded cores. 
Note, <code>n.omp.threads</code> &gt; 1 might not work on some systems.</p>
</td></tr>
<tr><td><code id="predict.svcPGOcc_+3A_verbose">verbose</code></td>
<td>
<p>if <code>TRUE</code>, model specification and progress of the 
sampler is printed to the screen. Otherwise, nothing is printed to
the screen.</p>
</td></tr>
<tr><td><code id="predict.svcPGOcc_+3A_ignore.re">ignore.RE</code></td>
<td>
<p>a logical value indicating whether to include unstructured random 
effects for prediction. If TRUE, unstructured random effects will be ignored and 
prediction will only use the fixed effects and the spatial random effects. If FALSE, 
random effects will be included in the prediction for both observed and unobserved 
levels of the unstructured random effects.</p>
</td></tr>
<tr><td><code id="predict.svcPGOcc_+3A_n.report">n.report</code></td>
<td>
<p>the interval to report sampling progress.</p>
</td></tr>
<tr><td><code id="predict.svcPGOcc_+3A_type">type</code></td>
<td>
<p>a quoted keyword indicating what type of prediction to produce. Valid keywords are 'occupancy' to predict latent occupancy probability and latent occupancy values (this is the default), or 'detection' to predict detection probability given new values of detection covariates.</p>
</td></tr>
<tr><td><code id="predict.svcPGOcc_+3A_grid.index.0">grid.index.0</code></td>
<td>
<p>an indexing vector used to specify how each row in <code>X.0</code> corresponds to the coordinates specified in <code>coords.0</code>. Only relevant if the SVCs were estimated at a higher spatial resolution (e.g., grid cells) than point locations.</p>
</td></tr>
<tr><td><code id="predict.svcPGOcc_+3A_...">...</code></td>
<td>
<p>currently no additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list object of class <code>predict.svcPGOcc</code>. When <code>type = 'occupancy'</code>, the list consists of:  
</p>
<table>
<tr><td><code>psi.0.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior predictive samples 
for the latent occurrence probability values.</p>
</td></tr>
<tr><td><code>z.0.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior predictive samples 
for the latent occurrence values.</p>
</td></tr>
<tr><td><code>w.0.samples</code></td>
<td>
<p>a three-dimensional array of posterior predictive samples
for the spatial random effects, with dimensions corresponding to MCMC iteration, 
coefficient, and site.</p>
</td></tr>
<tr><td><code>run.time</code></td>
<td>
<p>execution time reported using <code>proc.time()</code>.</p>
</td></tr>
</table>
<p>When <code>type = 'detection'</code>, the list consists of: 
</p>
<table>
<tr><td><code>p.0.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior predictive samples for the 
detection probability values.</p>
</td></tr>
<tr><td><code>run.time</code></td>
<td>
<p>execution time reported using <code>proc.time()</code>.</p>
</td></tr>
</table>
<p>The return object will include additional objects used for standard 
extractor functions. 
</p>


<h3>Note</h3>

<p>When <code>ignore.RE = FALSE</code>, both sampled levels and non-sampled levels of random effects are supported for prediction. For sampled levels, the posterior distribution for the random intercept corresponding to that level of the random effect will be used in the prediction. For non-sampled levels, random values are drawn from a normal distribution using the posterior samples of the random effect variance, which results in fully propagated uncertainty in predictions with models that incorporate random effects.
</p>


<h3>Author(s)</h3>

<p>Jeffrey W. Doser <a href="mailto:doserjef@msu.edu">doserjef@msu.edu</a>, <br />
Andrew O. Finley <a href="mailto:finleya@msu.edu">finleya@msu.edu</a>
</p>


<h3>References</h3>

<p>Hooten, M. B., and Hefley, T. J. (2019). Bringing Bayesian models to life. CRC Press.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(400)
# Simulate Data -----------------------------------------------------------
J.x &lt;- 8
J.y &lt;- 8
J &lt;- J.x * J.y
n.rep &lt;- sample(2:4, J, replace = TRUE)
beta &lt;- c(0.5, 2)
p.occ &lt;- length(beta)
alpha &lt;- c(0, 1)
p.det &lt;- length(alpha)
phi &lt;- c(3 / .6, 3 / .8)
sigma.sq &lt;- c(0.5, 0.9)
svc.cols &lt;- c(1, 2)
dat &lt;- simOcc(J.x = J.x, J.y = J.y, n.rep = n.rep, beta = beta, alpha = alpha, 
              sigma.sq = sigma.sq, phi = phi, sp = TRUE, cov.model = 'exponential', 
              svc.cols = svc.cols)
# Split into fitting and prediction data set
pred.indx &lt;- sample(1:J, round(J * .5), replace = FALSE)
y &lt;- dat$y[-pred.indx, ]
# Occupancy covariates
X &lt;- dat$X[-pred.indx, ]
# Prediction covariates
X.0 &lt;- dat$X[pred.indx, ]
# Detection covariates
X.p &lt;- dat$X.p[-pred.indx, , ]
coords &lt;- as.matrix(dat$coords[-pred.indx, ])
coords.0 &lt;- as.matrix(dat$coords[pred.indx, ])
psi.0 &lt;- dat$psi[pred.indx]
w.0 &lt;- dat$w[pred.indx, , drop = FALSE]

# Package all data into a list
occ.covs &lt;- X[, -1, drop = FALSE]
colnames(occ.covs) &lt;- c('occ.cov')
det.covs &lt;- list(det.cov.1 = X.p[, , 2])
data.list &lt;- list(y = y, 
                  occ.covs = occ.covs, 
                  det.covs = det.covs, 
                  coords = coords)

# Number of batches
n.batch &lt;- 10
# Batch length
batch.length &lt;- 25
n.iter &lt;- n.batch * batch.length
# Priors 
prior.list &lt;- list(beta.normal = list(mean = 0, var = 2.72), 
                   alpha.normal = list(mean = 0, var = 2.72),
                   sigma.sq.ig = list(a = 2, b = 0.5), 
                   phi.unif = list(a = 3/1, b = 3/.1)) 
# Initial values
inits.list &lt;- list(alpha = 0, beta = 0,
                   phi = 3 / .5, 
                   sigma.sq = 0.5,
                   z = apply(y, 1, max, na.rm = TRUE))
# Tuning
tuning.list &lt;- list(phi = 1) 

out &lt;- svcPGOcc(occ.formula = ~ occ.cov, 
                det.formula = ~ det.cov.1, 
                data = data.list, 
                inits = inits.list, 
                n.batch = n.batch, 
                batch.length = batch.length, 
                accept.rate = 0.43, 
                priors = prior.list,
                cov.model = 'exponential', 
                tuning = tuning.list, 
                n.omp.threads = 1, 
                verbose = TRUE, 
                NNGP = TRUE, 
                svc.cols = c(1, 2),
                n.neighbors = 15, 
                search.type = 'cb', 
                n.report = 10, 
                n.burn = 50, 
                n.thin = 1)

summary(out) 

# Predict at new locations ------------------------------------------------
out.pred &lt;- predict(out, X.0, coords.0, verbose = FALSE)
</code></pre>

<hr>
<h2 id='predict.svcTMsPGOcc'>Function for prediction at new locations for multi-season multi-species spatially-varying coefficient occupancy models</h2><span id='topic+predict.svcTMsPGOcc'></span>

<h3>Description</h3>

<p>The function <code>predict</code> collects posterior predictive samples for a set of new locations given an object of class 'svcTMsPGOcc'. Prediction is possible for both the latent occupancy state as well as detection. Predictions are currently only possible for sampled primary time periods.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'svcTMsPGOcc'
predict(object, X.0, coords.0, t.cols, n.omp.threads = 1, 
                          verbose = TRUE, n.report = 100, 
                          ignore.RE = FALSE, type = 'occupancy', grid.index.0, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.svcTMsPGOcc_+3A_object">object</code></td>
<td>
<p>an object of class svcTMsPGOcc</p>
</td></tr>
<tr><td><code id="predict.svcTMsPGOcc_+3A_x.0">X.0</code></td>
<td>
<p>the design matrix of covariates at the prediction locations. This should be a three-dimensional array, with dimensions corresponding to site, primary time period, and covariate, respectively. Note that the first covariate should consist of all 1s for the intercept if an intercept is included in the model. If random effects are included in the occupancy (or detection if <code>type = 'detection'</code>) portion of the model, the levels of the random effects at the new locations/time periods should be included as an element of the three-dimensional array. The ordering of the levels should match the ordering used to fit the data in <code>svcTMsPGOcc</code>. The covariates should be organized in the same order as they were specified in the corresponding formula argument of <code>svcTMsPGOcc</code>. Names of the third dimension (covariates) of any random effects in X.0 must match the name of the random effects used to fit the model, if specified in the corresponding formula argument of <code>svcTMsPGOcc</code>. See example below.</p>
</td></tr>
<tr><td><code id="predict.svcTMsPGOcc_+3A_coords.0">coords.0</code></td>
<td>
<p>the spatial coordinates corresponding to <code>X.0</code>. Note that <code>spOccupancy</code> assumes coordinates are specified 
in a projected coordinate system.</p>
</td></tr>
<tr><td><code id="predict.svcTMsPGOcc_+3A_t.cols">t.cols</code></td>
<td>
<p>an indexing vector used to denote which primary time periods are contained in the design matrix of covariates at the prediction locations (<code>X.0</code>). The values should denote the specific primary time periods used to fit the model. The values should indicate the columns in <code>data$y</code> used to fit the model for which prediction is desired. See example below.</p>
</td></tr> 
<tr><td><code id="predict.svcTMsPGOcc_+3A_n.omp.threads">n.omp.threads</code></td>
<td>
<p>a positive integer indicating
the number of threads to use for SMP parallel processing. The package must
be compiled for OpenMP support. For most Intel-based machines, we recommend setting
<code>n.omp.threads</code> up to the number of hyperthreaded cores. 
Note, <code>n.omp.threads</code> &gt; 1 might not work on some systems.</p>
</td></tr>
<tr><td><code id="predict.svcTMsPGOcc_+3A_verbose">verbose</code></td>
<td>
<p>if <code>TRUE</code>, model specification and progress of the 
sampler is printed to the screen. Otherwise, nothing is printed to
the screen.</p>
</td></tr>
<tr><td><code id="predict.svcTMsPGOcc_+3A_ignore.re">ignore.RE</code></td>
<td>
<p>logical value that specifies whether or not to remove random unstructured occurrence (or detection if <code>type = 'detection'</code>) effects from the subsequent predictions. If <code>TRUE</code>, random effects will be included. If <code>FALSE</code>, unstructured random effects will be set to 0 and predictions will only be generated from the fixed effects, the spatial random effects, and AR(1) random effects if the model was fit with <code>ar1 = TRUE</code>.</p>
</td></tr>
<tr><td><code id="predict.svcTMsPGOcc_+3A_n.report">n.report</code></td>
<td>
<p>the interval to report sampling progress.</p>
</td></tr>
<tr><td><code id="predict.svcTMsPGOcc_+3A_type">type</code></td>
<td>
<p>a quoted keyword indicating what type of prediction to produce. Valid keywords are 'occupancy' to predict latent occupancy probability and latent occupancy values (this is the default), or 'detection' to predict detection probability given new values of detection covariates.</p>
</td></tr>
<tr><td><code id="predict.svcTMsPGOcc_+3A_grid.index.0">grid.index.0</code></td>
<td>
<p>an indexing vector used to specify how each row in <code>X.0</code> corresponds to the coordinates specified in <code>coords.0</code>. Only relevant if the spatial random effect was estimated at a higher spatial resolution (e.g., grid cells) than point locations.</p>
</td></tr>
<tr><td><code id="predict.svcTMsPGOcc_+3A_...">...</code></td>
<td>
<p>currently no additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list object of class <code>predict.svcTMsPGOcc</code>. When <code>type = 'occupancy'</code>, the list consists of: 
</p>
<table>
<tr><td><code>psi.0.samples</code></td>
<td>
<p>a four-dimensional object of posterior predictive samples for the
latent occupancy probability values with dimensions corresponding to posterior predictive
sample, species, site, and primary time period.</p>
</td></tr>
<tr><td><code>z.0.samples</code></td>
<td>
<p>a three-dimensional object of posterior predictive samples for the
latent occupancy values with dimensions corresponding to posterior predictive sample, species, 
site, and primary time period.</p>
</td></tr>
<tr><td><code>w.0.samples</code></td>
<td>
<p>a four-dimensional array of posterior predictive samples
for the latent spatial factors with dimensions correpsonding to MCMC sample, latent factor, 
site, and spatially-varying coefficient.</p>
</td></tr>
</table>
<p>When <code>type = 'detection'</code>, the list consists of: 
</p>
<table>
<tr><td><code>p.0.samples</code></td>
<td>
<p>a four-dimensional object of posterior predictive samples for the 
detection probability values with dimensions corresponding to posterior predictive 
sample, site, and primary time period.</p>
</td></tr>
</table>
<p>The return object will include additional objects used for standard 
extractor functions. 
</p>


<h3>Note</h3>

<p>When <code>ignore.RE = FALSE</code>, both sampled levels and non-sampled levels of unstructured random effects are supported for prediction. For sampled levels, the posterior distribution for the random intercept corresponding to that level of the random effect will be used in the prediction. For non-sampled levels, random values are drawn from a normal distribution using the posterior samples of the random effect variance, which results in fully propagated uncertainty in predictions with models that incorporate random effects. 
</p>
<p>Occurrence predictions at sites that are only sampled for a subset of the total number of primary time periods are obtained directly when fitting the model. See the <code>psi.samples</code> and <code>z.samples</code> portions of the output list from the model object of class <code>svcTMsPGOcc</code>. 
</p>


<h3>Author(s)</h3>

<p>Jeffrey W. Doser <a href="mailto:doserjef@msu.edu">doserjef@msu.edu</a>, <br />
Andrew O. Finley <a href="mailto:finleya@msu.edu">finleya@msu.edu</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simulate Data -----------------------------------------------------------
set.seed(500)
J.x &lt;- 8
J.y &lt;- 8
J &lt;- J.x * J.y
# Years sampled
n.time &lt;- sample(3:10, J, replace = TRUE)
# n.time &lt;- rep(10, J)
n.time.max &lt;- max(n.time)
# Replicates
n.rep &lt;- matrix(NA, J, max(n.time))
for (j in 1:J) {
  n.rep[j, 1:n.time[j]] &lt;- sample(2:4, n.time[j], replace = TRUE)
  # n.rep[j, 1:n.time[j]] &lt;- rep(4, n.time[j])
}
N &lt;- 7
# Community-level covariate effects
# Occurrence
beta.mean &lt;- c(-3, -0.2, 0.5)
trend &lt;- FALSE
sp.only &lt;- 0
p.occ &lt;- length(beta.mean)
tau.sq.beta &lt;- c(0.6, 1.5, 1.4)
# Detection
alpha.mean &lt;- c(0, 1.2, -1.5)
tau.sq.alpha &lt;- c(1, 0.5, 2.3)
p.det &lt;- length(alpha.mean)
# Random effects
psi.RE &lt;- list()
p.RE &lt;- list()
# Draw species-level effects from community means.
beta &lt;- matrix(NA, nrow = N, ncol = p.occ)
alpha &lt;- matrix(NA, nrow = N, ncol = p.det)
for (i in 1:p.occ) {
  beta[, i] &lt;- rnorm(N, beta.mean[i], sqrt(tau.sq.beta[i]))
}
for (i in 1:p.det) {
  alpha[, i] &lt;- rnorm(N, alpha.mean[i], sqrt(tau.sq.alpha[i]))
}
sp &lt;- TRUE
svc.cols &lt;- c(1, 2)
p.svc &lt;- length(svc.cols)
n.factors &lt;- 2
phi &lt;- runif(p.svc * n.factors, 3 / .9, 3 / .3)
factor.model &lt;- TRUE
cov.model &lt;- 'exponential'
ar1 &lt;- TRUE
sigma.sq.t &lt;- runif(N, 0.05, 1)
rho &lt;- runif(N, 0.1, 1)

dat &lt;- simTMsOcc(J.x = J.x, J.y = J.y, n.time = n.time, n.rep = n.rep, N = N,
		 beta = beta, alpha = alpha, sp.only = sp.only, trend = trend,
		 psi.RE = psi.RE, p.RE = p.RE, factor.model = factor.model,
                 svc.cols = svc.cols, n.factors = n.factors, phi = phi, sp = sp,
                 cov.model = cov.model, ar1 = ar1, sigma.sq.t = sigma.sq.t, rho = rho)

# Subset data for prediction
pred.indx &lt;- sample(1:J, round(J * .25), replace = FALSE)
y &lt;- dat$y[, -pred.indx, , , drop = FALSE]
# Occupancy covariates
X &lt;- dat$X[-pred.indx, , , drop = FALSE]
# Prediction covariates
X.0 &lt;- dat$X[pred.indx, , , drop = FALSE]
# Detection covariates
X.p &lt;- dat$X.p[-pred.indx, , , , drop = FALSE]
# Coordinates
coords &lt;- dat$coords[-pred.indx, ]
coords.0 &lt;- dat$coords[pred.indx, ]

occ.covs &lt;- list(occ.cov.1 = X[, , 2],
		 occ.cov.2 = X[, , 3])
det.covs &lt;- list(det.cov.1 = X.p[, , , 2],
		 det.cov.2 = X.p[, , , 3])

data.list &lt;- list(y = y, occ.covs = occ.covs,
                  det.covs = det.covs,
                  coords = coords)
# Priors
prior.list &lt;- list(beta.comm.normal = list(mean = 0, var = 2.72),
		   alpha.comm.normal = list(mean = 0, var = 2.72),
		   tau.sq.beta.ig = list(a = 0.1, b = 0.1),
		   tau.sq.alpha.ig = list(a = 0.1, b = 0.1),
		   rho.unif = list(a = -1, b = 1),
		   sigma.sq.t.ig = list(a = 0.1, b = 0.1),
                   phi.unif = list(a = 3 / .9, b = 3 / .1))
z.init &lt;- apply(y, c(1, 2, 3), function(a) as.numeric(sum(a, na.rm = TRUE) &gt; 0))
inits.list &lt;- list(alpha.comm = 0, beta.comm = 0, beta = 0,
		   alpha = 0, tau.sq.beta = 1, tau.sq.alpha = 1,
		   rho = 0.5, sigma.sq.t = 0.5,
		   phi = 3 / .5, z = z.init)
# Tuning
tuning.list &lt;- list(phi = 1, rho = 0.5)

# Number of batches
n.batch &lt;- 5
# Batch length
batch.length &lt;- 25
n.burn &lt;- 25
n.thin &lt;- 1
n.samples &lt;- n.batch * batch.length

out &lt;- svcTMsPGOcc(occ.formula = ~ occ.cov.1 + occ.cov.2,
                det.formula = ~ det.cov.1 + det.cov.2,
                data = data.list,
                inits = inits.list,
                n.batch = n.batch,
                batch.length = batch.length,
                accept.rate = 0.43,
		ar1 = TRUE,
		svc.cols = svc.cols,
		NNGP = TRUE,
		n.neighbors = 5,
		n.factors = n.factors,
		cov.model = 'exponential',
                priors = prior.list,
                tuning = tuning.list,
                n.omp.threads = 1,
                verbose = TRUE,
                n.report = 1,
                n.burn = n.burn,
		n.thin = n.thin,
		n.chains = 1)

summary(out)

# Predict at new sites across all n.max.years
# Take a look at array of covariates for prediction
str(X.0)
# Subset to only grab time periods 1, 2, and 5
t.cols &lt;- c(1, 2, 5)
X.pred &lt;- X.0[, t.cols, ]
out.pred &lt;- predict(out, X.pred, coords.0, t.cols = t.cols, type = 'occupancy')
str(out.pred)

# Extract SVC samples for each species at prediction locations
svc.samples &lt;- getSVCSamples(out, out.pred)
str(svc.samples)
</code></pre>

<hr>
<h2 id='predict.svcTPGBinom'>Function for prediction at new locations for multi-season single-species spatially-varying coefficient binomial models</h2><span id='topic+predict.svcTPGBinom'></span>

<h3>Description</h3>

<p>The function <code>predict</code> collects posterior predictive samples for a set of new locations given an object of class 'svcTPGBinom'. Prediction is possible for both the latent occupancy state as well as detection. Predictions are currently only possible for sampled primary time periods.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'svcTPGBinom'
predict(object, X.0, coords.0, t.cols, weights.0,  n.omp.threads = 1, 
        verbose = TRUE, n.report = 100, ignore.RE = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.svcTPGBinom_+3A_object">object</code></td>
<td>
<p>an object of class svcTPGBinom</p>
</td></tr>
<tr><td><code id="predict.svcTPGBinom_+3A_x.0">X.0</code></td>
<td>
<p>the design matrix of covariates at the prediction locations. This should be a three-dimensional array, with dimensions corresponding to site, primary time period, and covariate, respectively. Note that the first covariate should consist of all 1s for the intercept if an intercept is included in the model. If random effects are included in the occupancy (or detection if <code>type = 'detection'</code>) portion of the model, the levels of the random effects at the new locations/time periods should be included as an element of the three-dimensional array. The ordering of the levels should match the ordering used to fit the data in <code>svcTPGBinom</code>. The covariates should be organized in the same order as they were specified in the corresponding formula argument of <code>svcTPGBinom</code>. Names of the third dimension (covariates) of any random effects in X.0 must match the name of the random effects used to fit the model, if specified in the corresponding formula argument of <code>svcTPGBinom</code>. See example below.</p>
</td></tr>
<tr><td><code id="predict.svcTPGBinom_+3A_coords.0">coords.0</code></td>
<td>
<p>the spatial coordinates corresponding to <code>X.0</code>. Note that <code>spOccupancy</code> assumes coordinates are specified 
in a projected coordinate system.</p>
</td></tr>
<tr><td><code id="predict.svcTPGBinom_+3A_weights.0">weights.0</code></td>
<td>
<p>a numeric site by primary time period matrix containing the binomial weights (i.e., the total number of 
Bernoulli trials) at each site and primary time period. If <code>weights.0</code> is not specified, 
we assume 1 trial at each site/primary time period (i.e., presence/absence).</p>
</td></tr>
<tr><td><code id="predict.svcTPGBinom_+3A_t.cols">t.cols</code></td>
<td>
<p>an indexing vector used to denote which primary time periods are contained in the design matrix of covariates at the prediction locations (<code>X.0</code>). The values should denote the specific primary time periods used to fit the model. The values should indicate the columns in <code>data$y</code> used to fit the model for which prediction is desired. See example below.</p>
</td></tr> 
<tr><td><code id="predict.svcTPGBinom_+3A_n.omp.threads">n.omp.threads</code></td>
<td>
<p>a positive integer indicating
the number of threads to use for SMP parallel processing. The package must
be compiled for OpenMP support. For most Intel-based machines, we recommend setting
<code>n.omp.threads</code> up to the number of hyperthreaded cores. 
Note, <code>n.omp.threads</code> &gt; 1 might not work on some systems.</p>
</td></tr>
<tr><td><code id="predict.svcTPGBinom_+3A_verbose">verbose</code></td>
<td>
<p>if <code>TRUE</code>, model specification and progress of the 
sampler is printed to the screen. Otherwise, nothing is printed to
the screen.</p>
</td></tr>
<tr><td><code id="predict.svcTPGBinom_+3A_ignore.re">ignore.RE</code></td>
<td>
<p>logical value that specifies whether or not to remove random unstructured occurrence (or detection if <code>type = 'detection'</code>) effects from the subsequent predictions. If <code>TRUE</code>, random effects will be included. If <code>FALSE</code>, unstructured random effects will be set to 0 and predictions will only be generated from the fixed effects, the spatial random effects, and AR(1) random effects if the model was fit with <code>ar1 = TRUE</code>.</p>
</td></tr>
<tr><td><code id="predict.svcTPGBinom_+3A_n.report">n.report</code></td>
<td>
<p>the interval to report sampling progress.</p>
</td></tr>
<tr><td><code id="predict.svcTPGBinom_+3A_...">...</code></td>
<td>
<p>currently no additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list object of class <code>predict.svcTPGBinom</code> that consists of: 
</p>
<table>
<tr><td><code>psi.0.samples</code></td>
<td>
<p>a three-dimensional object of posterior predictive samples for the
occurrence probability values with dimensions corresponding to posterior predictive
sample, site, and primary time period.</p>
</td></tr>
<tr><td><code>y.0.samples</code></td>
<td>
<p>a three-dimensional object of posterior predictive samples for the
predicted binomial data with dimensions corresponding to posterior predictive sample, site, 
and primary time period.</p>
</td></tr>
<tr><td><code>w.0.samples</code></td>
<td>
<p>a three-dimensional array of posterior predictive samples
for the spatial random effects, with dimensions corresponding to MCMC iteration, 
coefficient, and site.</p>
</td></tr>
<tr><td><code>run.time</code></td>
<td>
<p>execution time reported using <code>proc.time()</code>.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>When <code>ignore.RE = FALSE</code>, both sampled levels and non-sampled levels of unstructured random effects are supported for prediction. For sampled levels, the posterior distribution for the random intercept corresponding to that level of the random effect will be used in the prediction. For non-sampled levels, random values are drawn from a normal distribution using the posterior samples of the random effect variance, which results in fully propagated uncertainty in predictions with models that incorporate random effects. 
</p>
<p>Occurrence predictions at sites that are only sampled for a subset of the total number of primary time periods are obtained directly when fitting the model. See the <code>psi.samples</code> and <code>y.rep.samples</code> portions of the output list from the model object of class <code>svcTPGBinom</code>. 
</p>


<h3>Author(s)</h3>

<p>Jeffrey W. Doser <a href="mailto:doserjef@msu.edu">doserjef@msu.edu</a>, <br />
Andrew O. Finley <a href="mailto:finleya@msu.edu">finleya@msu.edu</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1000)
# Sites
J.x &lt;- 15
J.y &lt;- 15
J &lt;- J.x * J.y
# Years sampled
n.time &lt;- sample(10, J, replace = TRUE)
# Binomial weights
weights &lt;- matrix(NA, J, max(n.time))
for (j in 1:J) {
  weights[j, 1:n.time[j]] &lt;- sample(5, n.time[j], replace = TRUE)
}
# Occurrence --------------------------
beta &lt;- c(-2, -0.5, -0.2, 0.75)
p.occ &lt;- length(beta)
trend &lt;- TRUE
sp.only &lt;- 0
psi.RE &lt;- list()
# Spatial parameters ------------------
sp &lt;- TRUE
svc.cols &lt;- c(1, 2, 3)
p.svc &lt;- length(svc.cols)
cov.model &lt;- "exponential"
sigma.sq &lt;- runif(p.svc, 0.1, 1)
phi &lt;- runif(p.svc, 3/1, 3/0.2)
# Temporal parameters -----------------
ar1 &lt;- TRUE
rho &lt;- 0.8
sigma.sq.t &lt;- 1

# Get all the data
dat &lt;- simTBinom(J.x = J.x, J.y = J.y, n.time = n.time, weights = weights, beta = beta,
                 psi.RE = psi.RE, sp.only = sp.only, trend = trend, 
                 sp = sp, svc.cols = svc.cols,
                 cov.model = cov.model, sigma.sq = sigma.sq, phi = phi,
                 rho = rho, sigma.sq.t = sigma.sq.t, ar1 = TRUE, x.positive = FALSE)

# Prep the data for spOccupancy -------------------------------------------
# Subset data for prediction
pred.indx &lt;- sample(1:J, round(J * .25), replace = FALSE)
y &lt;- dat$y[-pred.indx, , drop = FALSE]
y.0 &lt;- dat$y[pred.indx, , drop = FALSE]
# Occupancy covariates
X &lt;- dat$X[-pred.indx, , , drop = FALSE]
# Prediction covariates
X.0 &lt;- dat$X[pred.indx, , , drop = FALSE]
# Spatial coordinates
coords &lt;- as.matrix(dat$coords[-pred.indx, ])
coords.0 &lt;- as.matrix(dat$coords[pred.indx, ])
psi.0 &lt;- dat$psi[pred.indx, ]
w.0 &lt;- dat$w[pred.indx, ]
weights.0 &lt;- weights[pred.indx, ]
weights &lt;- weights[-pred.indx, ]

# Package all data into a list
covs &lt;- list(int = X[, , 1],
             trend = X[, , 2],
             cov.1 = X[, , 3],
             cov.2 = X[, , 4])
# Data list bundle
data.list &lt;- list(y = y,
                  covs = covs,
                  weights = weights,
                  coords = coords)
# Priors
prior.list &lt;- list(beta.normal = list(mean = 0, var = 2.72),
                   sigma.sq.ig = list(a = 2, b = 1),
                   phi.unif = list(a = 3/1, b = 3/.1))

# Starting values
inits.list &lt;- list(beta = beta, alpha = 0,
                   sigma.sq = 1, phi = 3 / 0.5, nu = 1)
# Tuning
tuning.list &lt;- list(phi = 0.4, nu = 0.3, rho = 0.2)

# MCMC information
n.batch &lt;- 2
n.burn &lt;- 0
n.thin &lt;- 1


out &lt;- svcTPGBinom(formula = ~ trend + cov.1 + cov.2,
                   svc.cols = svc.cols,
                   data = data.list,
                   n.batch = n.batch,
                   batch.length = 25,
                   inits = inits.list,
                   priors = prior.list,
                   accept.rate = 0.43,
                   cov.model = "exponential",
                   ar1 = TRUE,
                   tuning = tuning.list,
                   n.omp.threads = 1,
                   verbose = TRUE,
                   NNGP = TRUE,
                   n.neighbors = 5,
                   n.report = 25,
                   n.burn = n.burn,
                   n.thin = n.thin,
                   n.chains = 1)
# Predict at new locations ------------------------------------------------
out.pred &lt;- predict(out, X.0, coords.0, t.cols = 1:max(n.time), 
                    weights = weights.0, n.report = 10)
str(out.pred)
</code></pre>

<hr>
<h2 id='predict.svcTPGOcc'>Function for prediction at new locations for multi-season single-species spatially-varying coefficient occupancy models</h2><span id='topic+predict.svcTPGOcc'></span>

<h3>Description</h3>

<p>The function <code>predict</code> collects posterior predictive samples for a set of new locations given an object of class 'svcTPGOcc'. Prediction is possible for both the latent occupancy state as well as detection. Predictions are currently only possible for sampled primary time periods.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'svcTPGOcc'
predict(object, X.0, coords.0, t.cols, weights.0, n.omp.threads = 1, 
        verbose = TRUE, n.report = 100, 
        ignore.RE = FALSE, type = 'occupancy', forecast = FALSE, 
        grid.index.0, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.svcTPGOcc_+3A_object">object</code></td>
<td>
<p>an object of class svcTPGOcc</p>
</td></tr>
<tr><td><code id="predict.svcTPGOcc_+3A_x.0">X.0</code></td>
<td>
<p>the design matrix of covariates at the prediction locations. This should be a three-dimensional array, with dimensions corresponding to site, primary time period, and covariate, respectively. Note that the first covariate should consist of all 1s for the intercept if an intercept is included in the model. If random effects are included in the occupancy (or detection if <code>type = 'detection'</code>) portion of the model, the levels of the random effects at the new locations/time periods should be included as an element of the three-dimensional array. The ordering of the levels should match the ordering used to fit the data in <code>svcTPGOcc</code>. The covariates should be organized in the same order as they were specified in the corresponding formula argument of <code>svcTPGOcc</code>. Names of the third dimension (covariates) of any random effects in X.0 must match the name of the random effects used to fit the model, if specified in the corresponding formula argument of <code>svcTPGOcc</code>. See example below.</p>
</td></tr>
<tr><td><code id="predict.svcTPGOcc_+3A_coords.0">coords.0</code></td>
<td>
<p>the spatial coordinates corresponding to <code>X.0</code>. Note that <code>spOccupancy</code> assumes coordinates are specified 
in a projected coordinate system.</p>
</td></tr>
<tr><td><code id="predict.svcTPGOcc_+3A_t.cols">t.cols</code></td>
<td>
<p>an indexing vector used to denote which primary time periods are contained in the design matrix of covariates at the prediction locations (<code>X.0</code>). The values should denote the specific primary time periods used to fit the model. The values should indicate the columns in <code>data$y</code> used to fit the model for which prediction is desired. See example below. Not required when <code>forecast = TRUE</code>.</p>
</td></tr> 
<tr><td><code id="predict.svcTPGOcc_+3A_weights.0">weights.0</code></td>
<td>
<p>not used for objects of class <code>svcTPGOcc</code>. Used when 
calling other functions.</p>
</td></tr>
<tr><td><code id="predict.svcTPGOcc_+3A_n.omp.threads">n.omp.threads</code></td>
<td>
<p>a positive integer indicating
the number of threads to use for SMP parallel processing. The package must
be compiled for OpenMP support. For most Intel-based machines, we recommend setting
<code>n.omp.threads</code> up to the number of hyperthreaded cores. 
Note, <code>n.omp.threads</code> &gt; 1 might not work on some systems.</p>
</td></tr>
<tr><td><code id="predict.svcTPGOcc_+3A_verbose">verbose</code></td>
<td>
<p>if <code>TRUE</code>, model specification and progress of the 
sampler is printed to the screen. Otherwise, nothing is printed to
the screen.</p>
</td></tr>
<tr><td><code id="predict.svcTPGOcc_+3A_ignore.re">ignore.RE</code></td>
<td>
<p>logical value that specifies whether or not to remove random unstructured occurrence (or detection if <code>type = 'detection'</code>) effects from the subsequent predictions. If <code>TRUE</code>, random effects will be included. If <code>FALSE</code>, unstructured random effects will be set to 0 and predictions will only be generated from the fixed effects, the spatial random effects, and AR(1) random effects if the model was fit with <code>ar1 = TRUE</code>.</p>
</td></tr>
<tr><td><code id="predict.svcTPGOcc_+3A_n.report">n.report</code></td>
<td>
<p>the interval to report sampling progress.</p>
</td></tr>
<tr><td><code id="predict.svcTPGOcc_+3A_type">type</code></td>
<td>
<p>a quoted keyword indicating what type of prediction to produce. Valid keywords are 'occupancy' to predict latent occupancy probability and latent occupancy values (this is the default), or 'detection' to predict detection probability given new values of detection covariates.</p>
</td></tr>
<tr><td><code id="predict.svcTPGOcc_+3A_grid.index.0">grid.index.0</code></td>
<td>
<p>an indexing vector used to specify how each row in <code>X.0</code> corresponds to the coordinates specified in <code>coords.0</code>. Only relevant if the spatial random effect was estimated at a higher spatial resolution (e.g., grid cells) than point locations.</p>
</td></tr>
<tr><td><code id="predict.svcTPGOcc_+3A_forecast">forecast</code></td>
<td>
<p>a logical value indicating whether prediction is occurring at non-sampled primary time periods (e.g., forecasting).</p>
</td></tr>
<tr><td><code id="predict.svcTPGOcc_+3A_...">...</code></td>
<td>
<p>currently no additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list object of class <code>predict.svcTPGOcc</code>. When <code>type = 'occupancy'</code>, the list consists of: 
</p>
<table>
<tr><td><code>psi.0.samples</code></td>
<td>
<p>a three-dimensional object of posterior predictive samples for the
latent occupancy probability values with dimensions corresponding to posterior predictive
sample, site, and primary time period.</p>
</td></tr>
<tr><td><code>z.0.samples</code></td>
<td>
<p>a three-dimensional object of posterior predictive samples for the
latent occupancy values with dimensions corresponding to posterior predictive sample, site, 
and primary time period.</p>
</td></tr>
<tr><td><code>w.0.samples</code></td>
<td>
<p>a three-dimensional array of posterior predictive samples
for the spatial random effects, with dimensions corresponding to MCMC iteration,
coefficient, and site.</p>
</td></tr>
</table>
<p>When <code>type = 'detection'</code>, the list consists of: 
</p>
<table>
<tr><td><code>p.0.samples</code></td>
<td>
<p>a three-dimensional object of posterior predictive samples for the 
detection probability values with dimensions corresponding to posterior predictive 
sample, site, and primary time period.</p>
</td></tr>
</table>
<p>The return object will include additional objects used for standard 
extractor functions. 
</p>


<h3>Note</h3>

<p>When <code>ignore.RE = FALSE</code>, both sampled levels and non-sampled levels of unstructured random effects are supported for prediction. For sampled levels, the posterior distribution for the random intercept corresponding to that level of the random effect will be used in the prediction. For non-sampled levels, random values are drawn from a normal distribution using the posterior samples of the random effect variance, which results in fully propagated uncertainty in predictions with models that incorporate random effects. 
</p>
<p>Occurrence predictions at sites that are only sampled for a subset of the total number of primary time periods are obtained directly when fitting the model. See the <code>psi.samples</code> and <code>z.samples</code> portions of the output list from the model object of class <code>svcTPGOcc</code>. 
</p>


<h3>Author(s)</h3>

<p>Jeffrey W. Doser <a href="mailto:doserjef@msu.edu">doserjef@msu.edu</a>, <br />
Andrew O. Finley <a href="mailto:finleya@msu.edu">finleya@msu.edu</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(500)
# Sites
J.x &lt;- 10
J.y &lt;- 10
J &lt;- J.x * J.y
# Primary time periods
n.time &lt;- sample(10, J, replace = TRUE)
n.time.max &lt;- max(n.time)
# Replicates
n.rep &lt;- matrix(NA, J, max(n.time))
for (j in 1:J) {
  n.rep[j, 1:n.time[j]] &lt;- sample(1:4, n.time[j], replace = TRUE)
}
# Occurrence --------------------------
beta &lt;- c(0.4, 0.5, -0.9)
trend &lt;- TRUE 
sp.only &lt;- 0
psi.RE &lt;- list()
# Detection ---------------------------
alpha &lt;- c(-1, 0.7, -0.5)
p.RE &lt;- list()
# Spatial -----------------------------
svc.cols &lt;- c(1, 2)
p.svc &lt;- length(svc.cols)
sp &lt;- TRUE
cov.model &lt;- "exponential"
sigma.sq &lt;- runif(p.svc, 0.1, 1)
phi &lt;- runif(p.svc, 3 / .9, 3 / .1)

# Get all the data
dat &lt;- simTOcc(J.x = J.x, J.y = J.y, n.time = n.time, n.rep = n.rep, 
               beta = beta, alpha = alpha, sp.only = sp.only, trend = trend, 
               psi.RE = psi.RE, p.RE = p.RE, sp = TRUE, sigma.sq = sigma.sq, 
               phi = phi, cov.model = cov.model, ar1 = FALSE, svc.cols = svc.cols)

# Subset data for prediction
pred.indx &lt;- sample(1:J, round(J * .25), replace = FALSE)
y &lt;- dat$y[-pred.indx, , , drop = FALSE]
# Occupancy covariates
X &lt;- dat$X[-pred.indx, , , drop = FALSE]
# Prediction covariates
X.0 &lt;- dat$X[pred.indx, , , drop = FALSE]
# Detection covariates
X.p &lt;- dat$X.p[-pred.indx, , , , drop = FALSE]
psi.0 &lt;- dat$psi[pred.indx, ]
# Coordinates
coords &lt;- dat$coords[-pred.indx, ]
coords.0 &lt;- dat$coords[pred.indx, ]

# Package all data into a list
# Occurrence
occ.covs &lt;- list(int = X[, , 1], 
                 trend = X[, , 2], 
                 occ.cov.1 = X[, , 3]) 
# Detection
det.covs &lt;- list(det.cov.1 = X.p[, , , 2], 
                 det.cov.2 = X.p[, , , 3]) 
# Data list bundle
data.list &lt;- list(y = y, 
                  occ.covs = occ.covs,
                  det.covs = det.covs, 
                  coords = coords) 
# Priors
prior.list &lt;- list(beta.normal = list(mean = 0, var = 2.72), 
                   alpha.normal = list(mean = 0, var = 2.72), 
                   sigma.sq.ig = list(a = 2, b = 0.5), 
                   phi.unif = list(a = 3 / 1, b = 3 / 0.1))

# Initial values
z.init &lt;- apply(y, c(1, 2), function(a) as.numeric(sum(a, na.rm = TRUE) &gt; 0))
inits.list &lt;- list(beta = 0, alpha = 0, z = z.init, phi = 3 / .5, sigma.sq = 2, 
                   w = rep(0, J))
# Tuning
tuning.list &lt;- list(phi = 1)
# Number of batches
n.batch &lt;- 10
# Batch length
batch.length &lt;- 25
n.iter &lt;- n.batch * batch.length

# Run the model
out &lt;- svcTPGOcc(occ.formula = ~ trend + occ.cov.1, 
               det.formula = ~ det.cov.1 + det.cov.2, 
               data = data.list, 
               inits = inits.list, 
               n.batch = n.batch, 
               batch.length = batch.length, 
               priors = prior.list,
               cov.model = "exponential", 
               svc.cols = svc.cols, 
               tuning = tuning.list, 
               NNGP = TRUE, 
               ar1 = FALSE,
               n.neighbors = 5, 
               search.type = 'cb', 
               n.report = 10, 
               n.burn = 50, 
               n.chains = 1)

summary(out)

# Predict at new sites across all n.max.years
# Take a look at array of covariates for prediction
str(X.0)
# Subset to only grab time periods 1, 2, and 5
t.cols &lt;- c(1, 2, 5)
X.pred &lt;- X.0[, t.cols, ]
out.pred &lt;- predict(out, X.0, coords.0, t.cols = t.cols, type = 'occupancy')
str(out.pred)
</code></pre>

<hr>
<h2 id='predict.tMsPGOcc'>Function for prediction at new locations for multi-season multi-species occupancy models</h2><span id='topic+predict.tMsPGOcc'></span>

<h3>Description</h3>

<p>The function <code>predict</code> collects posterior predictive samples for a set of new locations given an object of class 'tMsPGOcc'. Prediction is possible for both the latent occupancy state as well as detection. Predictions are currently only possible for sampled primary time periods. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'tMsPGOcc'
predict(object, X.0, t.cols, ignore.RE = FALSE, type = 'occupancy', ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.tMsPGOcc_+3A_object">object</code></td>
<td>
<p>an object of class tMsPGOcc</p>
</td></tr>
<tr><td><code id="predict.tMsPGOcc_+3A_x.0">X.0</code></td>
<td>
<p>the design matrix of covariates at the prediction locations. This should be a three-dimensional array, with dimensions corresponding to site, primary time period, and covariate, respectively. Note that the first covariate should consist of all 1s for the intercept if an intercept is included in the model. If random effects are included in the occupancy (or detection if <code>type = 'detection'</code>) portion of the model, the levels of the random effects at the new locations/time periods should be included as an element of the three-dimensional array. The ordering of the levels should match the ordering used to fit the data in <code>tMsPGOcc</code>. The covariates should be organized in the same order as they were specified in the corresponding formula argument of <code>tMsPGOcc</code>. Names of the third dimension (covariates) of any random effects in X.0 must match the name of the random effects used to fit the model, if specified in the corresponding formula argument of <code>tMsPGOcc</code>. See example below.</p>
</td></tr>
<tr><td><code id="predict.tMsPGOcc_+3A_t.cols">t.cols</code></td>
<td>
<p>an indexing vector used to denote which primary time periods are contained in the design matrix of covariates at the prediction locations (<code>X.0</code>). The values should denote the specific primary time periods used to fit the model. The values should indicate the columns in <code>data$y</code> used to fit the model for which prediction is desired. See example below.</p>
</td></tr> 
<tr><td><code id="predict.tMsPGOcc_+3A_ignore.re">ignore.RE</code></td>
<td>
<p>logical value that specifies whether or not to remove random unstructured occurrence (or detection if <code>type = 'detection'</code>) effects from the subsequent predictions. If <code>TRUE</code>, unstructured random effects will be included. If <code>FALSE</code>, unstructured random effects will be set to 0 and predictions will only be generated from the fixed effects and AR(1) random effects if the model was fit with <code>ar1 = TRUE</code>.</p>
</td></tr>
<tr><td><code id="predict.tMsPGOcc_+3A_type">type</code></td>
<td>
<p>a quoted keyword indicating what type of prediction to produce. Valid keywords are 'occupancy' to predict latent occupancy probability and latent occupancy values (this is the default), or 'detection' to predict detection probability given new values of detection covariates.</p>
</td></tr>
<tr><td><code id="predict.tMsPGOcc_+3A_...">...</code></td>
<td>
<p>currently no additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list object of class <code>predict.tMsPGOcc</code>. When <code>type = 'occupancy'</code>, the list consists of: 
</p>
<table>
<tr><td><code>psi.0.samples</code></td>
<td>
<p>a four-dimensional object of posterior predictive samples for the
latent occupancy probability values with dimensions corresponding to posterior predictive
sample, species, site, and primary time period.</p>
</td></tr>
<tr><td><code>z.0.samples</code></td>
<td>
<p>a four-dimensional object of posterior predictive samples for the
latent occupancy values with dimensions corresponding to posterior predictive sample, species, site, 
and primary time period.</p>
</td></tr>
</table>
<p>When <code>type = 'detection'</code>, the list consists of: 
</p>
<table>
<tr><td><code>p.0.samples</code></td>
<td>
<p>a four-dimensional object of posterior predictive samples for the 
detection probability values with dimensions corresponding to posterior predictive 
sample, species, site, and primary time period.</p>
</td></tr>
</table>
<p>The return object will include additional objects used for standard 
extractor functions. 
</p>


<h3>Note</h3>

<p>When <code>ignore.RE = FALSE</code>, both sampled levels and non-sampled levels of unstructured random effects are supported for prediction. For sampled levels, the posterior distribution for the random intercept corresponding to that level of the random effect will be used in the prediction. For non-sampled levels, random values are drawn from a normal distribution using the posterior samples of the random effect variance, which results in fully propagated uncertainty in predictions with models that incorporate random effects. 
</p>
<p>Occurrence predictions at sites that are only sampled for a subset of the total number of primary time periods are obtained directly when fitting the model. See the <code>psi.samples</code> and <code>z.samples</code> portions of the output list from the model object of class <code>tMsPGOcc</code>. 
</p>


<h3>Author(s)</h3>

<p>Jeffrey W. Doser <a href="mailto:doserjef@msu.edu">doserjef@msu.edu</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simulate Data -----------------------------------------------------------
set.seed(500)
J.x &lt;- 8
J.y &lt;- 8
J &lt;- J.x * J.y
# Years sampled
n.time &lt;- sample(3:10, J, replace = TRUE)
# n.time &lt;- rep(10, J)
n.time.max &lt;- max(n.time)
# Replicates
n.rep &lt;- matrix(NA, J, max(n.time))
for (j in 1:J) {
  n.rep[j, 1:n.time[j]] &lt;- sample(2:4, n.time[j], replace = TRUE)
  # n.rep[j, 1:n.time[j]] &lt;- rep(4, n.time[j])
}
N &lt;- 7
# Community-level covariate effects
# Occurrence
beta.mean &lt;- c(-3, -0.2, 0.5)
trend &lt;- FALSE
sp.only &lt;- 0
p.occ &lt;- length(beta.mean)
tau.sq.beta &lt;- c(0.6, 1.5, 1.4)
# Detection
alpha.mean &lt;- c(0, 1.2, -1.5)
tau.sq.alpha &lt;- c(1, 0.5, 2.3)
p.det &lt;- length(alpha.mean)
# Random effects
psi.RE &lt;- list()
p.RE &lt;- list()
# Draw species-level effects from community means.
beta &lt;- matrix(NA, nrow = N, ncol = p.occ)
alpha &lt;- matrix(NA, nrow = N, ncol = p.det)
for (i in 1:p.occ) {
  beta[, i] &lt;- rnorm(N, beta.mean[i], sqrt(tau.sq.beta[i]))
}
for (i in 1:p.det) {
  alpha[, i] &lt;- rnorm(N, alpha.mean[i], sqrt(tau.sq.alpha[i]))
}
sp &lt;- FALSE

dat &lt;- simTMsOcc(J.x = J.x, J.y = J.y, n.time = n.time, n.rep = n.rep, N = N,
		 beta = beta, alpha = alpha, sp.only = sp.only, trend = trend,
		 psi.RE = psi.RE, p.RE = p.RE, sp = sp)

# Subset data for prediction
pred.indx &lt;- sample(1:J, round(J * .25), replace = FALSE)
y &lt;- dat$y[, -pred.indx, , , drop = FALSE]
# Occupancy covariates
X &lt;- dat$X[-pred.indx, , , drop = FALSE]
# Prediction covariates
X.0 &lt;- dat$X[pred.indx, , , drop = FALSE]
# Detection covariates
X.p &lt;- dat$X.p[-pred.indx, , , , drop = FALSE]

occ.covs &lt;- list(occ.cov.1 = X[, , 2],
		 occ.cov.2 = X[, , 3])
det.covs &lt;- list(det.cov.1 = X.p[, , , 2],
		 det.cov.2 = X.p[, , , 3])

data.list &lt;- list(y = y, occ.covs = occ.covs,
                  det.covs = det.covs)
# Priors
prior.list &lt;- list(beta.comm.normal = list(mean = 0, var = 2.72),
		   alpha.comm.normal = list(mean = 0, var = 2.72),
		   tau.sq.beta.ig = list(a = 0.1, b = 0.1),
		   tau.sq.alpha.ig = list(a = 0.1, b = 0.1))
z.init &lt;- apply(y, c(1, 2, 3), function(a) as.numeric(sum(a, na.rm = TRUE) &gt; 0))
inits.list &lt;- list(alpha.comm = 0, beta.comm = 0, beta = 0,
		   alpha = 0, tau.sq.beta = 1, tau.sq.alpha = 1,
		   z = z.init)
# Tuning
tuning.list &lt;- list(phi = 1)

# Number of batches
n.batch &lt;- 5
# Batch length
batch.length &lt;- 25
n.burn &lt;- 25
n.thin &lt;- 1
n.samples &lt;- n.batch * batch.length

out &lt;- tMsPGOcc(occ.formula = ~ occ.cov.1 + occ.cov.2,
                det.formula = ~ det.cov.1 + det.cov.2,
                data = data.list,
                inits = inits.list,
                n.batch = n.batch,
                batch.length = batch.length,
                accept.rate = 0.43,
                priors = prior.list,
                n.omp.threads = 1,
                verbose = TRUE,
                n.report = 1,
                n.burn = n.burn,
		n.thin = n.thin,
		n.chains = 1)

summary(out)

# Predict at new sites during time periods 1, 2, and 5
# Take a look at array of covariates for prediction
str(X.0)
# Subset to only grab time periods 1, 2, and 5
t.cols &lt;- c(1, 2, 5)
X.pred &lt;- X.0[, t.cols, ]
out.pred &lt;- predict(out, X.pred, t.cols = t.cols, type = 'occupancy')
str(out.pred)
</code></pre>

<hr>
<h2 id='predict.tPGOcc'>Function for prediction at new locations for multi-season single-species occupancy models</h2><span id='topic+predict.tPGOcc'></span>

<h3>Description</h3>

<p>The function <code>predict</code> collects posterior predictive samples for a set of new locations given an object of class 'tPGOcc'. Prediction is possible for both the latent occupancy state as well as detection. Predictions are currently only possible for sampled primary time periods. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'tPGOcc'
predict(object, X.0, t.cols, ignore.RE = FALSE, type = 'occupancy', ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.tPGOcc_+3A_object">object</code></td>
<td>
<p>an object of class tPGOcc</p>
</td></tr>
<tr><td><code id="predict.tPGOcc_+3A_x.0">X.0</code></td>
<td>
<p>the design matrix of covariates at the prediction locations. This should be a three-dimensional array, with dimensions corresponding to site, primary time period, and covariate, respectively. Note that the first covariate should consist of all 1s for the intercept if an intercept is included in the model. If random effects are included in the occupancy (or detection if <code>type = 'detection'</code>) portion of the model, the levels of the random effects at the new locations/time periods should be included as an element of the three-dimensional array. The ordering of the levels should match the ordering used to fit the data in <code>tPGOcc</code>. The covariates should be organized in the same order as they were specified in the corresponding formula argument of <code>tPGOcc</code>. Names of the third dimension (covariates) of any random effects in X.0 must match the name of the random effects used to fit the model, if specified in the corresponding formula argument of <code>tPGOcc</code>. See example below.</p>
</td></tr>
<tr><td><code id="predict.tPGOcc_+3A_t.cols">t.cols</code></td>
<td>
<p>an indexing vector used to denote which primary time periods are contained in the design matrix of covariates at the prediction locations (<code>X.0</code>). The values should denote the specific primary time periods used to fit the model. The values should indicate the columns in <code>data$y</code> used to fit the model for which prediction is desired. See example below.</p>
</td></tr> 
<tr><td><code id="predict.tPGOcc_+3A_ignore.re">ignore.RE</code></td>
<td>
<p>logical value that specifies whether or not to remove random unstructured occurrence (or detection if <code>type = 'detection'</code>) effects from the subsequent predictions. If <code>TRUE</code>, unstructured random effects will be included. If <code>FALSE</code>, unstructured random effects will be set to 0 and predictions will only be generated from the fixed effects and AR(1) random effects if the model was fit with <code>ar1 = TRUE</code>.</p>
</td></tr>
<tr><td><code id="predict.tPGOcc_+3A_type">type</code></td>
<td>
<p>a quoted keyword indicating what type of prediction to produce. Valid keywords are 'occupancy' to predict latent occupancy probability and latent occupancy values (this is the default), or 'detection' to predict detection probability given new values of detection covariates.</p>
</td></tr>
<tr><td><code id="predict.tPGOcc_+3A_...">...</code></td>
<td>
<p>currently no additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list object of class <code>predict.tPGOcc</code>. When <code>type = 'occupancy'</code>, the list consists of: 
</p>
<table>
<tr><td><code>psi.0.samples</code></td>
<td>
<p>a three-dimensional object of posterior predictive samples for the
latent occupancy probability values with dimensions corresponding to posterior predictive
sample, site, and primary time period.</p>
</td></tr>
<tr><td><code>z.0.samples</code></td>
<td>
<p>a three-dimensional object of posterior predictive samples for the
latent occupancy values with dimensions corresponding to posterior predictive sample, site, 
and primary time period.</p>
</td></tr>
</table>
<p>When <code>type = 'detection'</code>, the list consists of: 
</p>
<table>
<tr><td><code>p.0.samples</code></td>
<td>
<p>a three-dimensional object of posterior predictive samples for the 
detection probability values with dimensions corresponding to posterior predictive 
sample, site, and primary time period.</p>
</td></tr>
</table>
<p>The return object will include additional objects used for standard 
extractor functions. 
</p>


<h3>Note</h3>

<p>When <code>ignore.RE = FALSE</code>, both sampled levels and non-sampled levels of unstructured random effects are supported for prediction. For sampled levels, the posterior distribution for the random intercept corresponding to that level of the random effect will be used in the prediction. For non-sampled levels, random values are drawn from a normal distribution using the posterior samples of the random effect variance, which results in fully propagated uncertainty in predictions with models that incorporate random effects. 
</p>
<p>Occurrence predictions at sites that are only sampled for a subset of the total number of primary time periods are obtained directly when fitting the model. See the <code>psi.samples</code> and <code>z.samples</code> portions of the output list from the model object of class <code>tPGOcc</code>. 
</p>


<h3>Author(s)</h3>

<p>Jeffrey W. Doser <a href="mailto:doserjef@msu.edu">doserjef@msu.edu</a>, <br />
Andrew O. Finley <a href="mailto:finleya@msu.edu">finleya@msu.edu</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(990)
# Sites
J.x &lt;- 10
J.y &lt;- 10
J &lt;- J.x * J.y
# Primary time periods
n.time &lt;- sample(10, J, replace = TRUE)
n.time.max &lt;- max(n.time)
# Replicates
n.rep &lt;- matrix(NA, J, max(n.time))
for (j in 1:J) {
  n.rep[j, 1:n.time[j]] &lt;- sample(1:4, n.time[j], replace = TRUE)
}
# Occurrence --------------------------
beta &lt;- c(0.4, 0.5, -0.9)
trend &lt;- TRUE 
sp.only &lt;- 0
psi.RE &lt;- list()
# Detection ---------------------------
alpha &lt;- c(-1, 0.7, -0.5)
p.RE &lt;- list()

# Get all the data
dat &lt;- simTOcc(J.x = J.x, J.y = J.y, n.time = n.time, n.rep = n.rep, 
               beta = beta, alpha = alpha, sp.only = sp.only, trend = trend, 
               psi.RE = psi.RE, p.RE = p.RE, sp = FALSE, ar1 = FALSE)

# Subset data for prediction
pred.indx &lt;- sample(1:J, round(J * .25), replace = FALSE)
y &lt;- dat$y[-pred.indx, , , drop = FALSE]
# Occupancy covariates
X &lt;- dat$X[-pred.indx, , , drop = FALSE]
# Prediction covariates
X.0 &lt;- dat$X[pred.indx, , , drop = FALSE]
# Detection covariates
X.p &lt;- dat$X.p[-pred.indx, , , , drop = FALSE]
psi.0 &lt;- dat$psi[pred.indx, ]

# Package all data into a list
# Occurrence
occ.covs &lt;- list(int = X[, , 1], 
                 trend = X[, , 2], 
                 occ.cov.1 = X[, , 3]) 
# Detection
det.covs &lt;- list(det.cov.1 = X.p[, , , 2], 
                 det.cov.2 = X.p[, , , 3]) 
# Data list bundle
data.list &lt;- list(y = y, 
                  occ.covs = occ.covs,
                  det.covs = det.covs) 
# Priors
prior.list &lt;- list(beta.normal = list(mean = 0, var = 2.72), 
                   alpha.normal = list(mean = 0, var = 2.72))

# Starting values
z.init &lt;- apply(y, c(1, 2), function(a) as.numeric(sum(a, na.rm = TRUE) &gt; 0))
inits.list &lt;- list(beta = 0, alpha = 0, z = z.init)

n.batch &lt;- 100
batch.length &lt;- 25
n.burn &lt;- 2000
n.thin &lt;- 1

# Run the model
out &lt;- tPGOcc(occ.formula = ~ trend + occ.cov.1, 
              det.formula = ~ det.cov.1 + det.cov.2, 
              data = data.list,
              inits = inits.list,
              priors = prior.list, 
              n.batch = n.batch,
              batch.length = batch.length,
              ar1 = FALSE,
              verbose = TRUE, 
              n.report = 500,
              n.burn = n.burn, 
              n.thin = n.thin,
              n.chains = 1) 

# Predict at new sites across during time periods 1, 2, and 5
# Take a look at array of covariates for prediction
str(X.0)
# Subset to only grab time periods 1, 2, and 5
t.cols &lt;- c(1, 2, 5)
X.pred &lt;- X.0[, t.cols, ]
out.pred &lt;- predict(out, X.pred, t.cols = t.cols, type = 'occupancy')
str(out.pred)
</code></pre>

<hr>
<h2 id='sfJSDM'>Function for Fitting a Spatial Factor Joint Species Distribution Model</h2><span id='topic+sfJSDM'></span>

<h3>Description</h3>

<p>The function <code>sfJSDM</code> fits a spatially-explicit joint species distribution model. This model does not explicitly account for imperfect detection (see <code>sfMsPGOcc()</code>). We use Polya-Gamma latent variables and a spatial factor modeling approach. Currently, models are implemented using a Nearest Neighbor Gaussian Process.</p>


<h3>Usage</h3>

<pre><code class='language-R'>sfJSDM(formula, data, inits, priors, tuning, 
       cov.model = 'exponential', NNGP = TRUE, 
       n.neighbors = 15, search.type = 'cb', 
       std.by.sp = FALSE, n.factors, n.batch, 
       batch.length, accept.rate = 0.43, n.omp.threads = 1, 
       verbose = TRUE, n.report = 100, 
       n.burn = round(.10 * n.batch * batch.length), n.thin = 1, 
       n.chains = 1, k.fold, k.fold.threads = 1, k.fold.seed = 100, 
       k.fold.only = FALSE, monitors, keep.only.mean.95, shared.spatial = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sfJSDM_+3A_formula">formula</code></td>
<td>
<p>a symbolic description of the model to be fit
for the model using R's model syntax. Only right-hand side of formula 
is specified. See example below. Random intercepts are allowed 
using <span class="pkg">lme4</span> syntax (Bates et al. 2015).</p>
</td></tr>
<tr><td><code id="sfJSDM_+3A_data">data</code></td>
<td>
<p>a list containing data necessary for model fitting.
Valid tags are <code>y</code>, <code>covs</code>, <code>coords</code>, <code>range.ind</code>, and <code>grid.index</code>. <code>y</code>
is a two-dimensional array with first dimension equal to the number 
of species and second dimension equal to the number of sites. Note how this differs
from other <code>spOccupancy</code> functions in that <code>y</code> does not have any 
replicate surveys. This is because <code>sfJSDM</code> does not account for imperfect
detection. <code>covs</code> is a matrix or data frame containing the variables 
used in the model, with <code class="reqn">J</code> rows for 
each column (variable). <code>coords</code> is a matrix of the observation coordinates used
to estimate the SVCs for each site. <code>coords</code> has two columns for the 
easting and northing coordinate, respectively. Typically, each site in the data 
set will have it's own coordinate, such that <code>coords</code> is a <code class="reqn">J \times 2</code> 
matrix and <code>grid.index</code> should not be specified. 
If you desire to estimate SVCs at some larger spatial level, 
e.g., if points fall within grid cells and you want to estimate an SVC for 
each grid cell instead of each point, <code>coords</code> can be specified as the coordinate for 
each grid cell. In such a case, <code>grid.index</code> is an indexing vector of length J, where each 
value of <code>grid.index</code> indicates the corresponding row in <code>coords</code> that the given 
site corresponds to. Note that <code>spOccupancy</code> assumes coordinates are specified 
in a projected coordinate system. 
<code>range.ind</code> is a matrix with rows corresponding to species and columns
corresponding to sites, with each element taking value 1 if that site is 
within the range of the corresponding species and 0 if it is outside of the 
range. This matrix is not required, but it can be helpful to restrict the 
modeled area for each individual species to be within the realistic range
of locations for that species when estimating the model parameters.</p>
</td></tr>
<tr><td><code id="sfJSDM_+3A_inits">inits</code></td>
<td>
<p>a list with each tag corresponding to a parameter name.
Valid tags are <code>beta.comm</code>, <code>beta</code>,  <code>tau.sq.beta</code>, 
<code>phi</code>, <code>lambda</code>, <code>sigma.sq.psi</code>, and <code>nu</code>. 
<code>nu</code> is only specified if <code>cov.model = "matern"</code>. 
<code>sigma.sq.psi</code> is only specified if
random intercepts are included in <code>formula</code>. The value portion of each tag is 
the parameter's initial value. See <code>priors</code> description for definition
of each parameter name. Additionally, the tag <code>fix</code> can be set to <code>TRUE</code> 
to fix the starting values across all chains. If <code>fix</code> is not specified
(the default), starting values are varied randomly across chains.</p>
</td></tr>
<tr><td><code id="sfJSDM_+3A_priors">priors</code></td>
<td>
<p>a list with each tag corresponding to a parameter name. 
Valid tags are <code>beta.comm.normal</code>, <code>tau.sq.beta.ig</code>, <code>phi.unif</code>, 
<code>nu.unif</code>, and <code>sigma.sq.psi.ig</code>. Community-level occurrence 
(<code>beta.comm</code>) regression coefficients are assumed to follow a 
normal distribution. The hyperparameters of the normal distribution
are passed as a list of length two with the first and second elements 
corresponding to the mean and variance of the normal distribution, 
which are each specified as vectors of length equal to the number of 
coefficients to be estimated or of length one if priors are the same for 
all coefficients. If not specified, prior means are set 
to 0 and prior variances set to 2.73. Community-level variance parameters 
(<code>tau.sq.beta</code>) are assumed to follow an 
inverse Gamma distribution. The hyperparameters of 
the inverse gamma distribution are passed as a list of length two with 
the first and second elements corresponding to the shape and scale parameters,
which are each specified as vectors of length equal to the number of 
coefficients to be estimated or a single value if priors are the same for all 
parameters. If not specified, prior shape and scale 
parameters are set to 0.1. If desired, the species-specific regression coefficients
(<code>beta</code>) can also be estimated indepdendently by specifying the 
tag <code>independent.betas = TRUE</code>. If specified, this will not estimate species-specific
coefficients as random effects from a common-community-level distribution, and rather
the values of <code>beta.comm</code> and <code>tau.sq.beta</code> will be fixed at the 
specified initial values. This is equivalent to specifying a Gaussian, independent
prior for each of the species-specific effects.
The spatial factor model fits <code>n.factors</code> independent
spatial processes. The spatial decay <code>phi</code> and smoothness <code>nu</code> parameters 
for each latent factor are assumed to follow Uniform distributions. 
The hyperparameters of the Uniform are passed as a list with two elements, 
with both elements being vectors of length <code>n.factors</code> corresponding to the lower and 
upper support, respectively, or as a single value if the same value is assigned
for all factors. The priors for the factor loadings matrix <code>lambda</code> are fixed
following the standard spatial factor model to ensure parameter 
identifiability (Christensen and Amemlya 2002). The
upper triangular elements of the <code>N x n.factors</code> matrix are fixed at 0 and the 
diagonal elements are fixed at 1. The lower triangular elements are assigned a 
standard normal prior (i.e., mean 0 and variance 1).
<code>sigma.sq.psi</code> is the random effect variance for any random effects, and is assumed
to follow an inverse Gamma distribution. The hyperparameters of the inverse-Gamma distribution
are passed as a list of length two with first and second elements corresponding to the shape
and scale parameters, respectively, which are each specified as vectors of length equal to 
the number of random intercepts or of length one if priors are the same for all random 
effect variances.</p>
</td></tr>
<tr><td><code id="sfJSDM_+3A_tuning">tuning</code></td>
<td>
<p>a list with each tag corresponding to a parameter
name. Valid tags are <code>phi</code> and <code>nu</code>. The value portion of each
tag defines the initial variance of the adaptive sampler. We assume the 
initial variance of the adaptive sampler is the same for each species, 
although the adaptive sampler will adjust the tuning variances separately
for each species. See Roberts and Rosenthal (2009) for details.</p>
</td></tr>
<tr><td><code id="sfJSDM_+3A_cov.model">cov.model</code></td>
<td>
<p>a quoted keyword that specifies the covariance
function used to model the spatial dependence structure among the
observations.  Supported covariance model key words are:
<code>"exponential"</code>, <code>"matern"</code>, <code>"spherical"</code>, and
<code>"gaussian"</code>.</p>
</td></tr>
<tr><td><code id="sfJSDM_+3A_nngp">NNGP</code></td>
<td>
<p>if <code>TRUE</code>, model is fit with an NNGP. If <code>FALSE</code>, 
a full Gaussian process is used. See Datta et al. (2016) and 
Finley et al. (2019) for more information. For spatial factor models, only 
<code>NNGP = TRUE</code> is currently supported.</p>
</td></tr>
<tr><td><code id="sfJSDM_+3A_n.neighbors">n.neighbors</code></td>
<td>
<p>number of neighbors used in the NNGP. Only used if 
<code>NNGP = TRUE</code>. Datta et al. (2016) showed that 15 neighbors is usually 
sufficient, but that as few as 5 neighbors can be adequate for certain data
sets, which can lead to even greater decreases in run time. We recommend
starting with 15 neighbors (the default) and if additional gains in computation
time are desired, subsequently compare the results with a smaller number
of neighbors using WAIC or k-fold cross-validation.</p>
</td></tr>
<tr><td><code id="sfJSDM_+3A_search.type">search.type</code></td>
<td>
<p>a quoted keyword that specifies the type of nearest
neighbor search algorithm. Supported method key words are: <code>"cb"</code> and
<code>"brute"</code>. The <code>"cb"</code> should generally be much
faster. If locations do not have identical coordinate values on
the axis used for the nearest neighbor ordering then <code>"cb"</code> 
and <code>"brute"</code> should produce identical neighbor sets. 
However, if there are identical coordinate values on the axis used 
for nearest neighbor ordering, then <code>"cb"</code> and <code>"brute"</code> 
might produce different, but equally valid, neighbor sets, 
e.g., if data are on a grid. </p>
</td></tr>
<tr><td><code id="sfJSDM_+3A_std.by.sp">std.by.sp</code></td>
<td>
<p>a logical value indicating whether the covariates are standardized
separately for each species within the corresponding range for each species (<code>TRUE</code>) 
or not (<code>FALSE</code>). Note that if <code>range.ind</code> is specified in <code>data.list</code>, 
this will result in the covariates being standardized differently for each species
based on the sites where <code>range.ind == 1</code> for that given species. If <code>range.ind</code> is not specified 
and <code>std.by.sp = TRUE</code>, this will simply be equivalent to standardizing 
the covariates across all locations prior to fitting the model. Note that the covariates
in <code>formula</code> should still be standardized across all locations. This can be done
either outside the function, or can be done by specifying <code>scale()</code> in the model formula 
around the continuous covariates.</p>
</td></tr>
<tr><td><code id="sfJSDM_+3A_n.factors">n.factors</code></td>
<td>
<p>the number of factors to use in the spatial factor model approach. 
Typically, the number of factors is set to be small (e.g., 4-5) relative to the 
total number of species in the community, which will lead to substantial 
decreases in computation time. However, the value can be anywhere 
between 1 and N (the number of species in the community).</p>
</td></tr>
<tr><td><code id="sfJSDM_+3A_n.batch">n.batch</code></td>
<td>
<p>the number of MCMC batches  in each chain to run for the Adaptive MCMC 
sampler. See Roberts and Rosenthal (2009) for details.</p>
</td></tr>
<tr><td><code id="sfJSDM_+3A_batch.length">batch.length</code></td>
<td>
<p>the length of each MCMC batch to run for the Adaptive 
MCMC sampler. See Roberts and Rosenthal (2009) for details.</p>
</td></tr>
<tr><td><code id="sfJSDM_+3A_accept.rate">accept.rate</code></td>
<td>
<p>target acceptance rate for Adaptive MCMC. Defaul is 
0.43. See Roberts and Rosenthal (2009) for details.</p>
</td></tr>
<tr><td><code id="sfJSDM_+3A_n.omp.threads">n.omp.threads</code></td>
<td>
<p>a positive integer indicating
the number of threads to use for SMP parallel processing. The package must
be compiled for OpenMP support. For most Intel-based machines, we
recommend setting <code>n.omp.threads</code> up to the number of
hyperthreaded cores. Note, <code>n.omp.threads</code> &gt; 1 might not
work on some systems.</p>
</td></tr>
<tr><td><code id="sfJSDM_+3A_verbose">verbose</code></td>
<td>
<p>if <code>TRUE</code>, messages about data preparation, 
model specification, and progress of the sampler are printed to the screen. 
Otherwise, no messages are printed.</p>
</td></tr>
<tr><td><code id="sfJSDM_+3A_n.report">n.report</code></td>
<td>
<p>the interval to report Metropolis sampler acceptance and
MCMC progress. Note this is specified in terms of batches and not overall
samples for spatial models.</p>
</td></tr>
<tr><td><code id="sfJSDM_+3A_n.burn">n.burn</code></td>
<td>
<p>the number of samples out of the total <code>n.samples</code> to 
discard as burn-in for each chain. By default, the first 10% of samples is discarded.</p>
</td></tr>
<tr><td><code id="sfJSDM_+3A_n.thin">n.thin</code></td>
<td>
<p>the thinning interval for collection of MCMC samples. The
thinning occurs after the <code>n.burn</code> samples are discarded. Default 
value is set to 1.</p>
</td></tr>
<tr><td><code id="sfJSDM_+3A_n.chains">n.chains</code></td>
<td>
<p>the number of chains to run in sequence.</p>
</td></tr>
<tr><td><code id="sfJSDM_+3A_k.fold">k.fold</code></td>
<td>
<p>specifies the number of <em>k</em> folds for cross-validation. 
If not specified as an argument, then cross-validation is not performed
and <code>k.fold.threads</code> and <code>k.fold.seed</code> are ignored. In <em>k</em>-fold
cross-validation, the data specified in <code>data</code> is randomly
partitioned into <em>k</em> equal sized subsamples. Of the <em>k</em> subsamples, 
<em>k</em> - 1 subsamples are used to fit the model and the remaining <em>k</em>
samples are used for prediction. The cross-validation process is repeated 
<em>k</em> times (the folds). As a scoring rule, we use the model deviance 
as described in Hooten and Hobbs (2015). Cross-validation is performed
after the full model is fit using all the data. Cross-validation results
are reported in the <code>k.fold.deviance</code> object in the return list.</p>
</td></tr>
<tr><td><code id="sfJSDM_+3A_k.fold.threads">k.fold.threads</code></td>
<td>
<p>number of threads to use for cross-validation. If 
<code>k.fold.threads &gt; 1</code> parallel processing is accomplished using the 
<span class="pkg">foreach</span> and <span class="pkg">doParallel</span> packages. Ignored if <code>k.fold</code>
is not specified.</p>
</td></tr> 
<tr><td><code id="sfJSDM_+3A_k.fold.seed">k.fold.seed</code></td>
<td>
<p>seed used to split data set into <code>k.fold</code> parts
for k-fold cross-validation. Ignored if <code>k.fold</code> is not specified.</p>
</td></tr>
<tr><td><code id="sfJSDM_+3A_k.fold.only">k.fold.only</code></td>
<td>
<p>a logical value indicating whether to only perform 
cross-validation (<code>TRUE</code>) or perform cross-validation after fitting 
the full model (<code>FALSE</code>). Default value is <code>FALSE</code>.</p>
</td></tr> 
<tr><td><code id="sfJSDM_+3A_monitors">monitors</code></td>
<td>
<p>a character vector used to indicate if only a subset of the model
model parameters are desired to be monitored. If posterior samples of all parameters
are desired, then don't specify the argument (this is the default). When working
with a large number of species and/or sites, the full model object can be quite
large, and so this argument can be used to only return samples of specific 
parameters to help reduce the size of this resulting object. Valid tags include
<code>beta.comm</code>, <code>tau.sq.beta</code>, <code>beta</code>, <code>z</code>, <code>psi</code>, <code>lambda</code>, 
<code>theta</code>, <code>w</code>, <code>like</code> (used for WAIC calculation), 
<code>beta.star</code>, <code>sigma.sq.psi</code>. Note that if all parameters are not returned, 
subsequent functions that require the model object may not work. We only recommend
specifying this option when working with large data sets (e.g., &gt; 100 species and/or 
&gt; 10,000 sites).</p>
</td></tr> 
<tr><td><code id="sfJSDM_+3A_keep.only.mean.95">keep.only.mean.95</code></td>
<td>
<p>not currently supported.</p>
</td></tr>
<tr><td><code id="sfJSDM_+3A_shared.spatial">shared.spatial</code></td>
<td>
<p>a logical value used to specify whether a common spatial process 
should be estimated for all species instead of the factor modeling approach. If true, 
a spatial variance parameter <code>sigma.sq</code> is estimated for the model, which can 
be specified in the initial values and prior distributions (<code>sigma.sq.ig</code>).</p>
</td></tr>
<tr><td><code id="sfJSDM_+3A_...">...</code></td>
<td>
<p>currently no additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>sfJSDM</code> that is a list comprised of: 
</p>
<table>
<tr><td><code>beta.comm.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the community level occurrence regression coefficients.</p>
</td></tr>
<tr><td><code>tau.sq.beta.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the occurrence community variance parameters.</p>
</td></tr>
<tr><td><code>beta.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the species level occurrence regression coefficients.</p>
</td></tr>
<tr><td><code>theta.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the species level correlation parameters.</p>
</td></tr>
<tr><td><code>lambda.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the latent spatial factor loadings.</p>
</td></tr>
<tr><td><code>psi.samples</code></td>
<td>
<p>a three-dimensional array of posterior samples for
the latent occurrence probability values for each species.</p>
</td></tr>
<tr><td><code>w.samples</code></td>
<td>
<p>a three-dimensional array of posterior samples for 
the latent spatial random effects for each latent factor. Array
dimensions correspond to MCMC sample, latent factor, and site. 
If <code>shared.spatial = TRUE</code>, this is still returned as a 
three-dimensional array where the first dimension is MCMC sample, 
second dimension is 1, and third dimension is site.</p>
</td></tr>
<tr><td><code>sigma.sq.psi.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for variances of random intercepts included in the occurrence portion
of the model. Only included if random intercepts are specified in 
<code>formula</code>.</p>
</td></tr>
<tr><td><code>beta.star.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the occurrence random effects. Only included if random intercepts
are specified in <code>formula</code>.</p>
</td></tr>
<tr><td><code>like.samples</code></td>
<td>
<p>a three-dimensional array of posterior samples
for the likelihood value associated with each site and species. 
Used for calculating WAIC.</p>
</td></tr>
<tr><td><code>rhat</code></td>
<td>
<p>a list of Gelman-Rubin diagnostic values for some of the model
parameters.</p>
</td></tr>
<tr><td><code>ESS</code></td>
<td>
<p>a list of effective sample sizes for some of the model parameters.</p>
</td></tr>
<tr><td><code>run.time</code></td>
<td>
<p>MCMC sampler execution time reported using <code>proc.time()</code>.</p>
</td></tr>
<tr><td><code>k.fold.deviance</code></td>
<td>
<p>vector of scoring rules (deviance) from k-fold cross-validation. 
A separate value is reported for each species. 
Only included if <code>k.fold</code> is specified in function call.</p>
</td></tr>
</table>
<p>The return object will include additional objects used for 
subsequent prediction and/or model fit evaluation. Note that detection probability
estimated values are not included in the model object, but can be extracted
using <code>fitted()</code>.
</p>


<h3>Note</h3>

<p>Some of the underlying code used for generating random numbers from the
Polya-Gamma distribution is taken from the <span class="pkg">pgdraw</span> package written
by Daniel F. Schmidt and Enes Makalic. Their code implements Algorithm
6 in PhD thesis of Jesse Bennett Windle (2013) <a href="https://repositories.lib.utexas.edu/handle/2152/21842">https://repositories.lib.utexas.edu/handle/2152/21842</a>.
</p>


<h3>Author(s)</h3>

<p>Jeffrey W. Doser <a href="mailto:doserjef@msu.edu">doserjef@msu.edu</a>, <br />
Andrew O. Finley <a href="mailto:finleya@msu.edu">finleya@msu.edu</a>
</p>


<h3>References</h3>

<p>Datta, A., S. Banerjee, A.O. Finley, and A.E. Gelfand. (2016)
Hierarchical Nearest-Neighbor Gaussian process models for large
geostatistical datasets. <em>Journal of the American Statistical
Association</em>, <a href="https://doi.org/10.1080/01621459.2015.1044091">doi:10.1080/01621459.2015.1044091</a>.
</p>
<p>Finley, A.O., A. Datta, B.D. Cook, D.C. Morton, H.E. Andersen, and
S. Banerjee. (2019) Efficient algorithms for Bayesian Nearest Neighbor
Gaussian Processes. <em>Journal of Computational and Graphical
Statistics</em>, <a href="https://doi.org/10.1080/10618600.2018.1537924">doi:10.1080/10618600.2018.1537924</a>.
</p>
<p>Finley, A. O., Datta, A., and Banerjee, S. (2020). spNNGP R package 
for nearest neighbor Gaussian process models. <em>arXiv</em> preprint arXiv:2001.09111.
</p>
<p>Polson, N.G., J.G. Scott, and J. Windle. (2013) Bayesian Inference for
Logistic Models Using Polya-Gamma Latent Variables.
<em>Journal of the American Statistical Association</em>, 108:1339-1349.
</p>
<p>Roberts, G.O. and Rosenthal J.S. (2009) Examples  of adaptive MCMC.
<em>Journal of Computational and Graphical Statistics</em>, 18(2):349-367.
</p>
<p>Bates, Douglas, Martin Maechler, Ben Bolker, Steve Walker (2015).
Fitting Linear Mixed-Effects Models Using lme4. Journal of
Statistical Software, 67(1), 1-48. <a href="https://doi.org/10.18637/jss.v067.i01">doi:10.18637/jss.v067.i01</a>.
</p>
<p>Hooten, M. B., and Hobbs, N. T. (2015). A guide to Bayesian model 
selection for ecologists. <em>Ecological Monographs</em>, 85(1), 3-28.
</p>
<p>Christensen, W. F., and Amemiya, Y. (2002). Latent variable analysis 
of multivariate spatial data. <em>Journal of the American Statistical Association</em>, 
97(457), 302-317.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>J.x &lt;- 8
J.y &lt;- 8
J &lt;- J.x * J.y
n.rep&lt;- sample(2:4, size = J, replace = TRUE)
N &lt;- 6
# Community-level covariate effects
# Occurrence
beta.mean &lt;- c(0.2)
p.occ &lt;- length(beta.mean)
tau.sq.beta &lt;- c(0.6)
# Detection
alpha.mean &lt;- c(0)
tau.sq.alpha &lt;- c(1)
p.det &lt;- length(alpha.mean)
# Random effects
psi.RE &lt;- list()
p.RE &lt;- list()
# Draw species-level effects from community means.
beta &lt;- matrix(NA, nrow = N, ncol = p.occ)
alpha &lt;- matrix(NA, nrow = N, ncol = p.det)
for (i in 1:p.occ) {
  beta[, i] &lt;- rnorm(N, beta.mean[i], sqrt(tau.sq.beta[i]))
}
for (i in 1:p.det) {
  alpha[, i] &lt;- rnorm(N, alpha.mean[i], sqrt(tau.sq.alpha[i]))
}
alpha.true &lt;- alpha
n.factors &lt;- 3
phi &lt;- rep(3 / .7, n.factors)
sigma.sq &lt;- rep(2, n.factors)
nu &lt;- rep(2, n.factors)

dat &lt;- simMsOcc(J.x = J.x, J.y = J.y, n.rep = n.rep, N = N, beta = beta, alpha = alpha,
                psi.RE = psi.RE, p.RE = p.RE, sp = TRUE, sigma.sq = sigma.sq,
                phi = phi, nu = nu, cov.model = 'matern', factor.model = TRUE,
                n.factors = n.factors)

pred.indx &lt;- sample(1:J, round(J * .25), replace = FALSE)
y &lt;- dat$y[, -pred.indx, , drop = FALSE]
# Occupancy covariates
X &lt;- dat$X[-pred.indx, , drop = FALSE]
coords &lt;- as.matrix(dat$coords[-pred.indx, , drop = FALSE])
# Prediction covariates
X.0 &lt;- dat$X[pred.indx, , drop = FALSE]
coords.0 &lt;- as.matrix(dat$coords[pred.indx, , drop = FALSE])
# Detection covariates
X.p &lt;- dat$X.p[-pred.indx, , , drop = FALSE]

y &lt;- apply(y, c(1, 2), max, na.rm = TRUE)
data.list &lt;- list(y = y, coords = coords)
# Priors
prior.list &lt;- list(beta.comm.normal = list(mean = 0, var = 2.72),
                   tau.sq.beta.ig = list(a = 0.1, b = 0.1),
                   nu.unif = list(0.5, 2.5))
# Starting values
inits.list &lt;- list(beta.comm = 0,
                   beta = 0,
                   fix = TRUE,
                   tau.sq.beta = 1)
# Tuning
tuning.list &lt;- list(phi = 1, nu = 0.25)

batch.length &lt;- 25
n.batch &lt;- 5
n.report &lt;- 100
formula &lt;- ~ 1

out &lt;- sfJSDM(formula = formula,
              data = data.list,
              inits = inits.list,
              n.batch = n.batch,
              batch.length = batch.length,
              accept.rate = 0.43,
              priors = prior.list,
              cov.model = "matern",
              tuning = tuning.list,
              n.factors = 3,
              n.omp.threads = 1,
              verbose = TRUE,
              NNGP = TRUE,
              n.neighbors = 5,
              search.type = 'cb',
              n.report = 10,
              n.burn = 0,
              n.thin = 1,
              n.chains = 2)
summary(out)
</code></pre>

<hr>
<h2 id='sfMsPGOcc'>Function for Fitting Spatial Factor Multi-Species Occupancy Models</h2><span id='topic+sfMsPGOcc'></span>

<h3>Description</h3>

<p>The function <code>sfMsPGOcc</code> fits multi-species spatial occupancy models with species correlations (i.e., a spatially-explicit joint species distribution model with imperfect detection). We use Polya-Gamma latent variables and a spatial factor modeling approach. Currently, models are implemented using a Nearest Neighbor Gaussian Process.</p>


<h3>Usage</h3>

<pre><code class='language-R'>sfMsPGOcc(occ.formula, det.formula, data, inits, priors, tuning, 
          cov.model = 'exponential', NNGP = TRUE, 
          n.neighbors = 15, search.type = 'cb', n.factors, n.batch, 
          batch.length, accept.rate = 0.43, n.omp.threads = 1, 
          verbose = TRUE, n.report = 100, 
          n.burn = round(.10 * n.batch * batch.length), n.thin = 1, 
          n.chains = 1, k.fold, k.fold.threads = 1, k.fold.seed, 
          k.fold.only = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sfMsPGOcc_+3A_occ.formula">occ.formula</code></td>
<td>
<p>a symbolic description of the model to be fit
for the occurrence portion of the model using R's model syntax. Random
intercepts are allowed using lme4 syntax (Bates et al. 2015). Only
right-hand side of formula is specified. See example below.</p>
</td></tr>
<tr><td><code id="sfMsPGOcc_+3A_det.formula">det.formula</code></td>
<td>
<p>a symbolic description of the model to be fit
for the detection portion of the model using R's model syntax. Only
right-hand side of formula is specified. See example below. Random 
intercepts are allowed using lme4 syntax (Bates et al. 2015).</p>
</td></tr>
<tr><td><code id="sfMsPGOcc_+3A_data">data</code></td>
<td>
<p>a list containing data necessary for model fitting.
Valid tags are <code>y</code>, <code>occ.covs</code>, <code>det.covs</code>, <code>coords</code>, 
and <code>grid.index</code>. 
<code>y</code> is a three-dimensional array with first dimension equal to the 
number of species, second dimension equal to the number of sites, and 
third dimension equal to the maximum number of replicates at a given site. 
<code>occ.covs</code> is a matrix or data frame containing the variables 
used in the occurrence portion of the model, with <code class="reqn">J</code> rows for 
each column (variable). <code>det.covs</code> is a list of variables included 
in the detection portion of the model. Each list element is a different 
detection covariate, which can be site-level or observational-level. 
Site-level covariates are specified as a vector of length <code class="reqn">J</code> while 
observation-level covariates are specified as a matrix or data frame 
with the number of rows equal to <code class="reqn">J</code> and number of columns equal 
to the maximum number of replicates at a given site. 
<code>coords</code> is a matrix of the observation coordinates used
to estimate the spatial random effect for each site. <code>coords</code> has two columns for the 
easting and northing coordinate, respectively. Typically, each site in the data 
set will have it's own coordinate, such that <code>coords</code> is a <code class="reqn">J \times 2</code> 
matrix and <code>grid.index</code> should not be specified. 
If you desire to estimate spatial random effects at some larger spatial level, 
e.g., if points fall within grid cells and you want to estimate a spatial random effect for 
each grid cell instead of each point, <code>coords</code> can be specified as the coordinate for 
each grid cell. In such a case, <code>grid.index</code> is an indexing vector of length J, where each 
value of <code>grid.index</code> indicates the corresponding row in <code>coords</code> that the given 
site corresponds to. Note that <code>spOccupancy</code> assumes coordinates are specified 
in a projected coordinate system.</p>
</td></tr>
<tr><td><code id="sfMsPGOcc_+3A_inits">inits</code></td>
<td>
<p>a list with each tag corresponding to a parameter name.
Valid tags are <code>alpha.comm</code>, <code>beta.comm</code>, <code>beta</code>, 
<code>alpha</code>, <code>tau.sq.beta</code>, <code>tau.sq.alpha</code>, 
<code>sigma.sq.psi</code>, <code>sigma.sq.p</code>, <code>z</code>, 
<code>phi</code>, <code>lambda</code>, and <code>nu</code>. <code>nu</code> is only specified if 
<code>cov.model = "matern"</code>, and <code>sigma.sq.psi</code> and <code>sigma.sq.p</code> are
only specified if random effects are included in <code>occ.formula</code> or 
<code>det.formula</code>, respectively. The value portion of each tag is 
the parameter's initial value. See <code>priors</code> description for definition
of each parameter name. Additionally, the tag <code>fix</code> can be set to <code>TRUE</code> 
to fix the starting values across all chains. If <code>fix</code> is not specified
(the default), starting values are varied randomly across chains.</p>
</td></tr>
<tr><td><code id="sfMsPGOcc_+3A_priors">priors</code></td>
<td>
<p>a list with each tag corresponding to a parameter name. 
Valid tags are <code>beta.comm.normal</code>, <code>alpha.comm.normal</code>, 
<code>tau.sq.beta.ig</code>, <code>tau.sq.alpha.ig</code>, <code>tau.beta.half.t</code>, 
<code>tau.alpha.half.t</code>, <code>sigma.sq.psi</code>, 
<code>sigma.sq.p</code>, <code>phi.unif</code>, 
and <code>nu.unif</code>. Community-level occurrence (<code>beta.comm</code>) and detection 
(<code>alpha.comm</code>) regression coefficients are assumed to follow a 
normal distribution. The hyperparameters of the normal distribution
are passed as a list of length two with the first and second elements 
corresponding to the mean and variance of the normal distribution, 
which are each specified as vectors of length equal to the number of 
coefficients to be estimated or of length one if priors are the same for 
all coefficients. If not specified, prior means are set 
to 0 and prior variances set to 2.73. By default, community-level variance parameters 
for occupancy (<code>tau.sq.beta</code>) and detection (<code>tau.sq.alpha</code>) are 
assumed to follow an inverse Gamma distribution. The hyperparameters of 
the inverse gamma distribution are passed as a list of length two with 
the first and second elements corresponding to the shape and scale parameters,
which are each specified as vectors of length equal to the number of 
coefficients to be estimated or a single value if priors are the same for all 
parameters. If not specified, prior shape and scale 
parameters are set to 0.1. Alternatively, half-t priors can be specified for the 
community level occurrence/detection standard deviation parameters using the tags
<code>tau.beta.half.t</code> and <code>tau.alpha.half.t</code>. The hyperparameters of the half-t
distribution are passed as a list of length two with the first and second elements
corresponding to the degrees of freedom and scale parameters, which are each 
specified as vectors of length equal to the number of coefficients to be estimated
or a single value if priors are the same for all parameters.
The spatial factor model fits <code>n.factors</code> independent
spatial processes. The spatial decay <code>phi</code> and smoothness <code>nu</code> parameters 
for each latent factor are assumed to follow Uniform distributions. 
The hyperparameters of the Uniform are passed as a list with two elements, 
with both elements being vectors of length <code>n.factors</code> corresponding to the lower and 
upper support, respectively, or as a single value if the same value is assigned
for all factors. The priors for the factor loadings matrix <code>lambda</code> are fixed
following the standard spatial factor model to ensure parameter 
identifiability (Christensen and Amemlya 2002). The
upper triangular elements of the <code>N x n.factors</code> matrix are fixed at 0 and the 
diagonal elements are fixed at 1. The lower triangular elements are assigned a 
standard normal prior (i.e., mean 0 and variance 1).
<code>sigma.sq.psi</code> and <code>sigma.sq.p</code> are the random 
effect variances for any occurrence or
detection random effects, respectively, and are assumed to follow an inverse
Gamma distribution. The hyperparameters of the inverse-Gamma distribution
are passed as a list of length two with first and second elements corresponding
to the shape and scale parameters, respectively, which are each specified as
vectors of length equal to the number of random intercepts or of length one 
if priors are the same for all random effect variances.</p>
</td></tr>
<tr><td><code id="sfMsPGOcc_+3A_tuning">tuning</code></td>
<td>
<p>a list with each tag corresponding to a parameter
name. Valid tags are <code>phi</code> and <code>nu</code>. The value portion of each
tag defines the initial variance of the adaptive sampler. We assume the 
initial variance of the adaptive sampler is the same for each species, 
although the adaptive sampler will adjust the tuning variances separately
for each species. See Roberts and Rosenthal (2009) for details.</p>
</td></tr>
<tr><td><code id="sfMsPGOcc_+3A_cov.model">cov.model</code></td>
<td>
<p>a quoted keyword that specifies the covariance
function used to model the spatial dependence structure among the
observations.  Supported covariance model key words are:
<code>"exponential"</code>, <code>"matern"</code>, <code>"spherical"</code>, and
<code>"gaussian"</code>.</p>
</td></tr>
<tr><td><code id="sfMsPGOcc_+3A_nngp">NNGP</code></td>
<td>
<p>if <code>TRUE</code>, model is fit with an NNGP. If <code>FALSE</code>, 
a full Gaussian process is used. See Datta et al. (2016) and 
Finley et al. (2019) for more information. For spatial factor models, only 
<code>NNGP = TRUE</code> is currently supported.</p>
</td></tr>
<tr><td><code id="sfMsPGOcc_+3A_n.neighbors">n.neighbors</code></td>
<td>
<p>number of neighbors used in the NNGP. Only used if 
<code>NNGP = TRUE</code>. Datta et al. (2016) showed that 15 neighbors is usually 
sufficient, but that as few as 5 neighbors can be adequate for certain data
sets, which can lead to even greater decreases in run time. We recommend
starting with 15 neighbors (the default) and if additional gains in computation
time are desired, subsequently compare the results with a smaller number
of neighbors using WAIC or k-fold cross-validation.</p>
</td></tr>
<tr><td><code id="sfMsPGOcc_+3A_search.type">search.type</code></td>
<td>
<p>a quoted keyword that specifies the type of nearest
neighbor search algorithm. Supported method key words are: <code>"cb"</code> and
<code>"brute"</code>. The <code>"cb"</code> should generally be much
faster. If locations do not have identical coordinate values on
the axis used for the nearest neighbor ordering then <code>"cb"</code> 
and <code>"brute"</code> should produce identical neighbor sets. 
However, if there are identical coordinate values on the axis used 
for nearest neighbor ordering, then <code>"cb"</code> and <code>"brute"</code> 
might produce different, but equally valid, neighbor sets, 
e.g., if data are on a grid. </p>
</td></tr>
<tr><td><code id="sfMsPGOcc_+3A_n.factors">n.factors</code></td>
<td>
<p>the number of factors to use in the spatial factor model approach. 
Typically, the number of factors is set to be small (e.g., 4-5) relative to the 
total number of species in the community, which will lead to substantial 
decreases in computation time. However, the value can be anywhere 
between 1 and N (the number of species in the community).</p>
</td></tr>
<tr><td><code id="sfMsPGOcc_+3A_n.batch">n.batch</code></td>
<td>
<p>the number of MCMC batches  in each chain to run for the Adaptive MCMC 
sampler. See Roberts and Rosenthal (2009) for details.</p>
</td></tr>
<tr><td><code id="sfMsPGOcc_+3A_batch.length">batch.length</code></td>
<td>
<p>the length of each MCMC batch to run for the Adaptive 
MCMC sampler. See Roberts and Rosenthal (2009) for details.</p>
</td></tr>
<tr><td><code id="sfMsPGOcc_+3A_accept.rate">accept.rate</code></td>
<td>
<p>target acceptance rate for Adaptive MCMC. Defaul is 
0.43. See Roberts and Rosenthal (2009) for details.</p>
</td></tr>
<tr><td><code id="sfMsPGOcc_+3A_n.omp.threads">n.omp.threads</code></td>
<td>
<p>a positive integer indicating
the number of threads to use for SMP parallel processing. The package must
be compiled for OpenMP support. For most Intel-based machines, we
recommend setting <code>n.omp.threads</code> up to the number of
hyperthreaded cores. Note, <code>n.omp.threads</code> &gt; 1 might not
work on some systems.</p>
</td></tr>
<tr><td><code id="sfMsPGOcc_+3A_verbose">verbose</code></td>
<td>
<p>if <code>TRUE</code>, messages about data preparation, 
model specification, and progress of the sampler are printed to the screen. 
Otherwise, no messages are printed.</p>
</td></tr>
<tr><td><code id="sfMsPGOcc_+3A_n.report">n.report</code></td>
<td>
<p>the interval to report Metropolis sampler acceptance and
MCMC progress. Note this is specified in terms of batches and not overall
samples for spatial models.</p>
</td></tr>
<tr><td><code id="sfMsPGOcc_+3A_n.burn">n.burn</code></td>
<td>
<p>the number of samples out of the total <code>n.samples</code> to 
discard as burn-in for each chain. By default, the first 10% of samples is discarded.</p>
</td></tr>
<tr><td><code id="sfMsPGOcc_+3A_n.thin">n.thin</code></td>
<td>
<p>the thinning interval for collection of MCMC samples. The
thinning occurs after the <code>n.burn</code> samples are discarded. Default 
value is set to 1.</p>
</td></tr>
<tr><td><code id="sfMsPGOcc_+3A_n.chains">n.chains</code></td>
<td>
<p>the number of chains to run in sequence.</p>
</td></tr>
<tr><td><code id="sfMsPGOcc_+3A_k.fold">k.fold</code></td>
<td>
<p>specifies the number of <em>k</em> folds for cross-validation. 
If not specified as an argument, then cross-validation is not performed
and <code>k.fold.threads</code> and <code>k.fold.seed</code> are ignored. In <em>k</em>-fold
cross-validation, the data specified in <code>data</code> is randomly
partitioned into <em>k</em> equal sized subsamples. Of the <em>k</em> subsamples, 
<em>k</em> - 1 subsamples are used to fit the model and the remaining <em>k</em>
samples are used for prediction. The cross-validation process is repeated 
<em>k</em> times (the folds). As a scoring rule, we use the model deviance 
as described in Hooten and Hobbs (2015). Cross-validation is performed
after the full model is fit using all the data. Cross-validation results
are reported in the <code>k.fold.deviance</code> object in the return list.</p>
</td></tr>
<tr><td><code id="sfMsPGOcc_+3A_k.fold.threads">k.fold.threads</code></td>
<td>
<p>number of threads to use for cross-validation. If 
<code>k.fold.threads &gt; 1</code> parallel processing is accomplished using the 
<span class="pkg">foreach</span> and <span class="pkg">doParallel</span> packages. Ignored if <code>k.fold</code>
is not specified.</p>
</td></tr> 
<tr><td><code id="sfMsPGOcc_+3A_k.fold.seed">k.fold.seed</code></td>
<td>
<p>seed used to split data set into <code>k.fold</code> parts
for k-fold cross-validation. Ignored if <code>k.fold</code> is not specified.</p>
</td></tr>
<tr><td><code id="sfMsPGOcc_+3A_k.fold.only">k.fold.only</code></td>
<td>
<p>a logical value indicating whether to only perform 
cross-validation (<code>TRUE</code>) or perform cross-validation after fitting 
the full model (<code>FALSE</code>). Default value is <code>FALSE</code>.</p>
</td></tr> 
<tr><td><code id="sfMsPGOcc_+3A_...">...</code></td>
<td>
<p>currently no additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>sfMsPGOcc</code> that is a list comprised of: 
</p>
<table>
<tr><td><code>beta.comm.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the community level occurrence regression coefficients.</p>
</td></tr>
<tr><td><code>alpha.comm.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the community level detection regression coefficients.</p>
</td></tr>
<tr><td><code>tau.sq.beta.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the occurrence community variance parameters.</p>
</td></tr>
<tr><td><code>tau.sq.alpha.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the detection community variance parameters.</p>
</td></tr>
<tr><td><code>beta.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the species level occurrence regression coefficients.</p>
</td></tr>
<tr><td><code>alpha.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the species level detection regression coefficients.</p>
</td></tr>
<tr><td><code>theta.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the species level correlation parameters.</p>
</td></tr>
<tr><td><code>lambda.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the latent spatial factor loadings.</p>
</td></tr>
<tr><td><code>z.samples</code></td>
<td>
<p>a three-dimensional array of posterior samples for
the latent occurrence values for each species.</p>
</td></tr>
<tr><td><code>psi.samples</code></td>
<td>
<p>a three-dimensional array of posterior samples for
the latent occupancy probability values for each species.</p>
</td></tr>
<tr><td><code>w.samples</code></td>
<td>
<p>a three-dimensional array of posterior samples for 
the latent spatial random effects for each latent factor.</p>
</td></tr>
<tr><td><code>sigma.sq.psi.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for variances of random intercepts included in the occurrence portion
of the model. Only included if random intercepts are specified in 
<code>occ.formula</code>.</p>
</td></tr>
<tr><td><code>sigma.sq.p.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for variances of random intercpets included in the detection portion 
of the model. Only included if random intercepts are specified in 
<code>det.formula</code>.</p>
</td></tr>
<tr><td><code>beta.star.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the occurrence random effects. Only included if random intercepts
are specified in <code>occ.formula</code>.</p>
</td></tr>
<tr><td><code>alpha.star.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the detection random effects. Only included if random intercepts 
are specified in <code>det.formula</code>.</p>
</td></tr>
<tr><td><code>like.samples</code></td>
<td>
<p>a three-dimensional array of posterior samples
for the likelihood value associated with each site and species. 
Used for calculating WAIC.</p>
</td></tr>
<tr><td><code>rhat</code></td>
<td>
<p>a list of Gelman-Rubin diagnostic values for some of the model
parameters.</p>
</td></tr>
<tr><td><code>ESS</code></td>
<td>
<p>a list of effective sample sizes for some of the model parameters.</p>
</td></tr>
<tr><td><code>run.time</code></td>
<td>
<p>MCMC sampler execution time reported using <code>proc.time()</code>.</p>
</td></tr>
<tr><td><code>k.fold.deviance</code></td>
<td>
<p>vector of scoring rules (deviance) from k-fold cross-validation. 
A separate value is reported for each species. 
Only included if <code>k.fold</code> is specified in function call.</p>
</td></tr>
</table>
<p>The return object will include additional objects used for 
subsequent prediction and/or model fit evaluation. Note that detection 
probability estimated values are not included in the model object, but can
be extracted using <code>fitted()</code>.
</p>


<h3>Note</h3>

<p>Some of the underlying code used for generating random numbers from the
Polya-Gamma distribution is taken from the <span class="pkg">pgdraw</span> package written
by Daniel F. Schmidt and Enes Makalic. Their code implements Algorithm
6 in PhD thesis of Jesse Bennett Windle (2013) <a href="https://repositories.lib.utexas.edu/handle/2152/21842">https://repositories.lib.utexas.edu/handle/2152/21842</a>.
</p>


<h3>Author(s)</h3>

<p>Jeffrey W. Doser <a href="mailto:doserjef@msu.edu">doserjef@msu.edu</a>, <br />
Andrew O. Finley <a href="mailto:finleya@msu.edu">finleya@msu.edu</a>
</p>


<h3>References</h3>

<p>Datta, A., S. Banerjee, A.O. Finley, and A.E. Gelfand. (2016)
Hierarchical Nearest-Neighbor Gaussian process models for large
geostatistical datasets. <em>Journal of the American Statistical
Association</em>, <a href="https://doi.org/10.1080/01621459.2015.1044091">doi:10.1080/01621459.2015.1044091</a>.
</p>
<p>Finley, A.O., A. Datta, B.D. Cook, D.C. Morton, H.E. Andersen, and
S. Banerjee. (2019) Efficient algorithms for Bayesian Nearest Neighbor
Gaussian Processes. <em>Journal of Computational and Graphical
Statistics</em>, <a href="https://doi.org/10.1080/10618600.2018.1537924">doi:10.1080/10618600.2018.1537924</a>.
</p>
<p>Finley, A. O., Datta, A., and Banerjee, S. (2020). spNNGP R package 
for nearest neighbor Gaussian process models. <em>arXiv</em> preprint arXiv:2001.09111.
</p>
<p>Polson, N.G., J.G. Scott, and J. Windle. (2013) Bayesian Inference for
Logistic Models Using Polya-Gamma Latent Variables.
<em>Journal of the American Statistical Association</em>, 108:1339-1349.
</p>
<p>Roberts, G.O. and Rosenthal J.S. (2009) Examples  of adaptive MCMC.
<em>Journal of Computational and Graphical Statistics</em>, 18(2):349-367.
</p>
<p>Bates, Douglas, Martin Maechler, Ben Bolker, Steve Walker (2015).
Fitting Linear Mixed-Effects Models Using lme4. Journal of
Statistical Software, 67(1), 1-48. <a href="https://doi.org/10.18637/jss.v067.i01">doi:10.18637/jss.v067.i01</a>.
</p>
<p>Hooten, M. B., and Hobbs, N. T. (2015). A guide to Bayesian model 
selection for ecologists. <em>Ecological Monographs</em>, 85(1), 3-28.
</p>
<p>Christensen, W. F., and Amemiya, Y. (2002). Latent variable analysis 
of multivariate spatial data. <em>Journal of the American Statistical Association</em>, 
97(457), 302-317.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(400)

# Simulate Data -----------------------------------------------------------
J.x &lt;- 7
J.y &lt;- 7
J &lt;- J.x * J.y
n.rep &lt;- sample(2:4, size = J, replace = TRUE)
N &lt;- 8
# Community-level covariate effects
# Occurrence
beta.mean &lt;- c(0.2, -0.15)
p.occ &lt;- length(beta.mean)
tau.sq.beta &lt;- c(0.6, 0.3)
# Detection
alpha.mean &lt;- c(0.5, 0.2, -.2)
tau.sq.alpha &lt;- c(0.2, 0.3, 0.8)
p.det &lt;- length(alpha.mean)
# Random effects
psi.RE &lt;- list()
# Include a non-spatial random effect on occurrence
psi.RE &lt;- list(levels = c(20),
               sigma.sq.psi = c(0.5))
p.RE &lt;- list()
# Include a random effect on detection
p.RE &lt;- list(levels = c(40),
	     sigma.sq.p = c(2))
# Draw species-level effects from community means.
beta &lt;- matrix(NA, nrow = N, ncol = p.occ)
alpha &lt;- matrix(NA, nrow = N, ncol = p.det)
for (i in 1:p.occ) {
  beta[, i] &lt;- rnorm(N, beta.mean[i], sqrt(tau.sq.beta[i]))
}
for (i in 1:p.det) {
  alpha[, i] &lt;- rnorm(N, alpha.mean[i], sqrt(tau.sq.alpha[i]))
}
n.factors &lt;- 4
phi &lt;- runif(n.factors, 3/1, 3/.4)

dat &lt;- simMsOcc(J.x = J.x, J.y = J.y, n.rep = n.rep, N = N, beta = beta, alpha = alpha,
                phi = phi, sp = TRUE, cov.model = 'exponential', 
                factor.model = TRUE, n.factors = n.factors, psi.RE = psi.RE, 
                p.RE = p.RE)

# Number of batches
n.batch &lt;- 10
# Batch length
batch.length &lt;- 25
n.samples &lt;- n.batch * batch.length

y &lt;- dat$y
X &lt;- dat$X
X.p &lt;- dat$X.p
X.p.re &lt;- dat$X.p.re
X.re &lt;- dat$X.re
coords &lt;- as.matrix(dat$coords)

# Package all data into a list
occ.covs &lt;- cbind(X, X.re)
colnames(occ.covs) &lt;- c('int', 'occ.cov', 'occ.re')
det.covs &lt;- list(det.cov.1 = X.p[, , 2], 
                 det.cov.2 = X.p[, , 3], 
                 det.re = X.p.re[, , 1])
data.list &lt;- list(y = y, 
                  occ.covs = occ.covs,
                  det.covs = det.covs, 
                  coords = coords)
# Priors
prior.list &lt;- list(beta.comm.normal = list(mean = 0, var = 2.72), 
                   alpha.comm.normal = list(mean = 0, var = 2.72), 
                   tau.sq.beta.ig = list(a = 0.1, b = 0.1), 
                   tau.sq.alpha.ig = list(a = 0.1, b = 0.1),
                   phi.unif = list(a = 3/1, b = 3/.1)) 
# Initial values
lambda.inits &lt;- matrix(0, N, n.factors)
diag(lambda.inits) &lt;- 1
lambda.inits[lower.tri(lambda.inits)] &lt;- rnorm(sum(lower.tri(lambda.inits)))

inits.list &lt;- list(alpha.comm = 0, 
                   beta.comm = 0, 
                   beta = 0, 
                   alpha = 0,
                   tau.sq.beta = 1, 
                   tau.sq.alpha = 1, 
                   phi = 3 / .5, 
                   lambda = lambda.inits,
                   z = apply(y, c(1, 2), max, na.rm = TRUE))
# Tuning
tuning.list &lt;- list(phi = 1) 

out &lt;- sfMsPGOcc(occ.formula = ~ occ.cov + (1 | occ.re), 
                 det.formula = ~ det.cov.1 + det.cov.2 + (1 | det.re), 
                 data = data.list,
                 inits = inits.list, 
                 n.batch = n.batch, 
                 batch.length = batch.length, 
                 accept.rate = 0.43, 
                 priors = prior.list, 
                 cov.model = "exponential", 
                 tuning = tuning.list, 
                 n.omp.threads = 1, 
                 verbose = TRUE, 
                 NNGP = TRUE, 
                 n.neighbors = 5, 
                 n.factors = n.factors,
                 search.type = 'cb', 
                 n.report = 10, 
                 n.burn = 50, 
                 n.thin = 1, 
                 n.chains = 1)

summary(out)
</code></pre>

<hr>
<h2 id='simBinom'>Simulate Single-Species Binomial Data</h2><span id='topic+simBinom'></span>

<h3>Description</h3>

<p>The function <code>simBinom</code> simulates single-species binomial data for simulation studies, power assessments, or function testing. Data can be optionally simulated with a spatial Gaussian Process in the model. Non-spatial random intercepts can also be included in the model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simBinom(J.x, J.y, weights, beta, psi.RE = list(), 
         sp = FALSE, svc.cols = 1, cov.model, sigma.sq, phi, nu, 
         x.positive = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simBinom_+3A_j.x">J.x</code></td>
<td>
<p>a single numeric value indicating the number of sites to simulate data along the horizontal axis. Total number of sites with simulated data is <code class="reqn">J.x \times J.y</code>.</p>
</td></tr>
<tr><td><code id="simBinom_+3A_j.y">J.y</code></td>
<td>
<p>a single numeric value indicating the number of sites to simulate data along the vertical axis. Total number of sites with simulated data is <code class="reqn">J.x \times J.y</code>.</p>
</td></tr>
<tr><td><code id="simBinom_+3A_weights">weights</code></td>
<td>
<p>a numeric vector of length <code class="reqn">J = J.x \times J.y</code> indicating the number of Bernoulli trials at each of the <code class="reqn">J</code> sites.</p>
</td></tr>
<tr><td><code id="simBinom_+3A_beta">beta</code></td>
<td>
<p>a numeric vector containing the intercept and regression coefficient parameters for the model.</p>
</td></tr>
<tr><td><code id="simBinom_+3A_psi.re">psi.RE</code></td>
<td>
<p>a list used to specify the non-spatial random intercepts included in the model. The list must have two tags: <code>levels</code> and <code>sigma.sq.psi</code>. <code>levels</code> is a vector of length equal to the number of distinct random intercepts to include in the model and contains the number of levels there are in each intercept. <code>sigma.sq.psi</code> is a vector of length equal to the number of distinct random intercepts to include in the model and contains the variances for each random effect. If not specified, no random effects are included in the model.</p>
</td></tr>
<tr><td><code id="simBinom_+3A_sp">sp</code></td>
<td>
<p>a logical value indicating whether to simulate a spatially-explicit occupancy model with a Gaussian process. By default set to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="simBinom_+3A_svc.cols">svc.cols</code></td>
<td>
<p>a vector indicating the variables whose effects will be
estimated as spatially-varying coefficients. <code>svc.cols</code> is an
integer vector with values indicating the order of covariates specified
in the model formula (with 1 being the intercept if specified).</p>
</td></tr>
<tr><td><code id="simBinom_+3A_cov.model">cov.model</code></td>
<td>
<p>a quoted keyword that specifies the covariance function used to model the spatial dependence structure among the latent occurrence values.  Supported covariance model key words are: <code>"exponential"</code>, <code>"matern"</code>, <code>"spherical"</code>, and <code>"gaussian"</code>.</p>
</td></tr>
<tr><td><code id="simBinom_+3A_sigma.sq">sigma.sq</code></td>
<td>
<p>a numeric value indicating the spatial variance parameter. Ignored when <code>sp = FALSE</code>. If <code>svc.cols</code> has more than one value, there should be a distinct spatial variance parameter for each spatially-varying coefficient.</p>
</td></tr>
<tr><td><code id="simBinom_+3A_phi">phi</code></td>
<td>
<p>a numeric value indicating the spatial decay parameter. Ignored when <code>sp = FALSE</code>. If <code>svc.cols</code> has more than one value, there should be a distinct spatial decay parameter for each spatially-varying coefficient.</p>
</td></tr>
<tr><td><code id="simBinom_+3A_nu">nu</code></td>
<td>
<p>a numeric value indicating the spatial smoothness parameter. Only used when <code>sp = TRUE</code> and <code>cov.model = "matern"</code>. If <code>svc.cols</code> has more than one value, there should be a distinct spatial smoothness parameter for each spatially-varying coefficient.</p>
</td></tr> 
<tr><td><code id="simBinom_+3A_x.positive">x.positive</code></td>
<td>
<p>a logical value indicating whether the simulated covariates should be simulated as random standard normal covariates (<code>x.positive = FALSE</code>) or restricted to positive values using a uniform distribution with lower bound 0 and upper bound 1 (<code>x.positive = TRUE</code>).</p>
</td></tr>
<tr><td><code id="simBinom_+3A_...">...</code></td>
<td>
<p>currently no additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list comprised of: 
</p>
<table>
<tr><td><code>X</code></td>
<td>
<p>a <code class="reqn">J \times p.occ</code> numeric design matrix for the model.</p>
</td></tr>
<tr><td><code>coords</code></td>
<td>
<p>a <code class="reqn">J \times 2</code> numeric matrix of coordinates of each occupancy site. Required for spatial models.</p>
</td></tr>
<tr><td><code>w</code></td>
<td>
<p>a matrix of the spatial random effect values for each site. The number of columns is determined by the <code>svc.cols</code> argument (the number of spatially-varying coefficients).</p>
</td></tr>
<tr><td><code>psi</code></td>
<td>
<p>a <code class="reqn">J \times 1</code> matrix of the binomial probabilities for each site.</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>a length <code>J</code> vector of the binomial data for each site.</p>
</td></tr>
<tr><td><code>X.w</code></td>
<td>
<p>a two dimensional matrix containing the covariate effects (including an intercept) whose effects are assumed to be spatially-varying. Rows correspond to sites and columns correspond to covariate effects.</p>
</td></tr>
<tr><td><code>X.re</code></td>
<td>
<p>a numeric matrix containing the levels of any unstructured random effect included in the model. Only relevant when random effects are specified in <code>psi.RE</code>.</p>
</td></tr>
<tr><td><code>beta.star</code></td>
<td>
<p>a numeric vector that contains the simulated random effects for each given level of the random effects included in the model. Only relevant when random effects are included in the model.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jeffrey W. Doser <a href="mailto:doserjef@msu.edu">doserjef@msu.edu</a>, <br />
Andrew O. Finley <a href="mailto:finleya@msu.edu">finleya@msu.edu</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(400)
J.x &lt;- 10
J.y &lt;- 10
weights &lt;- rep(4, J.x * J.y)
beta &lt;- c(0.5, -0.15)
svc.cols &lt;- c(1, 2)
phi &lt;- c(3 / .6, 3 / 0.2)
sigma.sq &lt;- c(1.2, 0.9)
psi.RE &lt;- list(levels = 10, 
               sigma.sq.psi = 1.2)
dat &lt;- simBinom(J.x = J.x, J.y = J.y, weights = weights, beta = beta, 
                psi.RE = psi.RE, sp = TRUE, svc.cols = svc.cols, 
                cov.model = 'spherical', sigma.sq = sigma.sq, phi = phi)
</code></pre>

<hr>
<h2 id='simIntMsOcc'>Simulate Multi-Species Detection-Nondetection Data from Multiple Data Sources</h2><span id='topic+simIntMsOcc'></span>

<h3>Description</h3>

<p>The function <code>simIntMsOcc</code> simulates multi-species detection-nondetection data from multiple data sources for simulation studies, power assessments, or function testing of integrated occupancy models. Data can optionally be simulated with a spatial Gaussian Process on the occurrence process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simIntMsOcc(n.data, J.x, J.y, J.obs, n.rep, N, beta, alpha, psi.RE = list(),
            p.RE = list(), sp = FALSE, cov.model, sigma.sq, phi, nu,
            factor.model = FALSE, n.factors, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simIntMsOcc_+3A_n.data">n.data</code></td>
<td>
<p>an integer indicating the number of detection-nondetection data sources to simulate.</p>
</td></tr>
<tr><td><code id="simIntMsOcc_+3A_j.x">J.x</code></td>
<td>
<p>a single numeric value indicating the number of sites across the region of interest along the horizontal axis. Total number of sites across the simulated region of interest is <code class="reqn">J.x \times J.y</code>. </p>
</td></tr>
<tr><td><code id="simIntMsOcc_+3A_j.y">J.y</code></td>
<td>
<p>a single numeric value indicating the number of sites across the region of interest along the vertical axis. Total number of sites across the simulated region of interest is <code class="reqn">J.x \times J.y</code>. </p>
</td></tr>
<tr><td><code id="simIntMsOcc_+3A_j.obs">J.obs</code></td>
<td>
<p>a numeric vector of length <code>n.data</code> containing the number of sites to simulate each data source at. Data sources can be obtained at completely different sites, the same sites, or anywhere inbetween. Maximum number of sites a given data source is available at is equal to <code class="reqn">J = J.x \times J.y</code>.</p>
</td></tr>
<tr><td><code id="simIntMsOcc_+3A_n.rep">n.rep</code></td>
<td>
<p>a list of length <code>n.data</code>. Each element is a numeric vector with length corresponding to the number of sites that given data source is observed at (in <code>J.obs</code>). Each vector indicates the number of repeat visits at each of the sites for a given data source.</p>
</td></tr>
<tr><td><code id="simIntMsOcc_+3A_n">N</code></td>
<td>
<p>a numeric vector of length <code>N</code> containing the number of species each data source samples. These can be the same if both data sets sample the same species, or can be different.</p>
</td></tr>
<tr><td><code id="simIntMsOcc_+3A_beta">beta</code></td>
<td>
<p>a numeric matrix with <code>max(N)</code> rows containing the intercept and regression coefficient parameters for the occurrence portion of the multi-species occupancy model. Each row corresponds to the regression coefficients for a given species.</p>
</td></tr> 
<tr><td><code id="simIntMsOcc_+3A_alpha">alpha</code></td>
<td>
<p>a list of length <code>n.data</code>. Each element is a numeric matrix with the rows corresponding to the number of species that data source contains and columns corresponding to the regression coefficients for each data source.</p>
</td></tr>
<tr><td><code id="simIntMsOcc_+3A_psi.re">psi.RE</code></td>
<td>
<p>a list used to specify the non-spatial random intercepts included in the occurrence portion of the model. The list must have two tags: <code>levels</code> and <code>sigma.sq.psi</code>. <code>levels</code> is a vector of length equal to the number of distinct random intercepts to include in the model and contains the number of levels there are in each intercept. <code>sigma.sq.psi</code> is a vector of length equal to the number of distinct random intercepts to include in the model and contains the variances for each random effect. If not specified, no random effects are included in the occurrence portion of the model.</p>
</td></tr>
<tr><td><code id="simIntMsOcc_+3A_p.re">p.RE</code></td>
<td>
<p>this argument is not currently supported. In a later version, this argument will allow for simulating data with detection random effects in the different data sources.</p>
</td></tr>
<tr><td><code id="simIntMsOcc_+3A_sp">sp</code></td>
<td>
<p>a logical value indicating whether to simulate a spatially-explicit occupancy model with a Gaussian process. By default set to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="simIntMsOcc_+3A_cov.model">cov.model</code></td>
<td>
<p>a quoted keyword that specifies the covariance function used to model the spatial dependence structure among the latent occurrence values.  Supported covariance model key words are: <code>"exponential"</code>, <code>"matern"</code>, <code>"spherical"</code>, and <code>"gaussian"</code>.</p>
</td></tr>
<tr><td><code id="simIntMsOcc_+3A_sigma.sq">sigma.sq</code></td>
<td>
<p>a numeric vector of length <code>max(N)</code> containing the spatial variance parameter for each species. Ignored when <code>sp = FALSE</code> or when <code>factor.model = TRUE</code>.</p>
</td></tr>
<tr><td><code id="simIntMsOcc_+3A_phi">phi</code></td>
<td>
<p>a numeric vector of length <code>max(N)</code> containing the spatial decay parameter for each species. Ignored when <code>sp = FALSE</code>. If <code>factor.model = TRUE</code>, this should be of length <code>n.factors</code>.</p>
</td></tr>
<tr><td><code id="simIntMsOcc_+3A_nu">nu</code></td>
<td>
<p>a numeric vector of length <code>max(N)</code> containing the spatial smoothness parameter for each species. Only used when <code>sp = TRUE</code> and <code>cov.model = 'matern'</code>. If <code>factor.model = TRUE</code>, this should be of length <code>n.factors</code>.</p>
</td></tr> 
<tr><td><code id="simIntMsOcc_+3A_factor.model">factor.model</code></td>
<td>
<p>a logical value indicating whether to simulate data following a factor modeling approach that explicitly incoporates species correlations. If <code>sp = TRUE</code>, the latent factors are simulated from independent spatial processes. If <code>sp = FALSE</code>, the latent factors are simulated from standard normal distributions.</p>
</td></tr>
<tr><td><code id="simIntMsOcc_+3A_n.factors">n.factors</code></td>
<td>
<p>a single numeric value specifying the number of latent factors to use to simulate the data if <code>factor.model = TRUE</code>.</p>
</td></tr>
<tr><td><code id="simIntMsOcc_+3A_...">...</code></td>
<td>
<p>currently no additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list comprised of: 
</p>
<table>
<tr><td><code>X.obs</code></td>
<td>
<p>a numeric design matrix for the occurrence portion of the model. This matrix contains the intercept and regression coefficients for only the observed sites.</p>
</td></tr>
<tr><td><code>X.pred</code></td>
<td>
<p>a numeric design matrix for the occurrence portion of the model at sites where there are no observed data sources.</p>
</td></tr> 
<tr><td><code>X.p</code></td>
<td>
<p>a list of design matrices for the detection portions of the integrated multi-species occupancy model. Each element in the list is a design matrix of detection covariates for each data source.</p>
</td></tr>
<tr><td><code>coords.obs</code></td>
<td>
<p>a numeric matrix of coordinates of each observed site. Required for spatial models.</p>
</td></tr>
<tr><td><code>coords.pred</code></td>
<td>
<p>a numeric matrix of coordinates of each site in the study region without any data sources. Only used for spatial models.</p>
</td></tr>
<tr><td><code>w</code></td>
<td>
<p>a species (or factor) x site matrix of the spatial random effects for each species. Only used to simulate data when <code>sp = TRUE</code>. If <code>factor.model = TRUE</code>, the first dimension is <code>n.factors</code>.</p>
</td></tr>
<tr><td><code>w.pred</code></td>
<td>
<p>a matrix of the spatial random random effects for each species (or factor) at locations without any observation.</p>
</td></tr>
<tr><td><code>psi.obs</code></td>
<td>
<p>a species x site matrix of the occurrence probabilities for each species at the observed sites. Note that values are provided for all species, even if some species are only monitored at a subset of these points.</p>
</td></tr>
<tr><td><code>psi.pred</code></td>
<td>
<p>a species x site matrix of the occurrence probabilities for sites without any observations.</p>
</td></tr>
<tr><td><code>z.obs</code></td>
<td>
<p>a species x site matrix of the latent occurrence states at each observed site. Note that values are provided for all species, even if some species are only monitored at a subset of these points.</p>
</td></tr>
<tr><td><code>z.pred</code></td>
<td>
<p>a species x site matrix of the latent occurrence states at each site without any observations.</p>
</td></tr>
<tr><td><code>p</code></td>
<td>
<p>a list of detection probability arrays for each of the <code>n.data</code> data sources. Each array has dimensions corresponding to species, site, and replicate, respectively.</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>a list of arrays of the raw detection-nondetection data for each site and replicate combination for each species in the data set. Each array has dimensions corresponding to species, site, and replicate, respectively.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jeffrey W. Doser <a href="mailto:doserjef@msu.edu">doserjef@msu.edu</a>, <br />
</p>


<h3>References</h3>

<p>Doser, J. W., Leuenberger, W., Sillett, T. S., Hallworth, M. T. &amp; Zipkin, E. F. (2022). 
Integrated community occupancy models: A framework to assess occurrence and biodiversity 
dynamics using multiple data sources. Methods in Ecology and Evolution, 00, 1-14. <a href="https://doi.org/10.1111/2041-210X.13811">doi:10.1111/2041-210X.13811</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(91)
J.x &lt;- 10
J.y &lt;- 10
# Total number of data sources across the study region
J.all &lt;- J.x * J.y
# Number of data sources.
n.data &lt;- 2
# Sites for each data source.
J.obs &lt;- sample(ceiling(0.2 * J.all):ceiling(0.5 * J.all), n.data, replace = TRUE)
n.rep &lt;- list()
n.rep[[1]] &lt;- rep(3, J.obs[1])
n.rep[[2]] &lt;- rep(4, J.obs[2])

# Number of species observed in each data source
N &lt;- c(8, 3)

# Community-level covariate effects
# Occurrence
beta.mean &lt;- c(0.2, 0.5)
p.occ &lt;- length(beta.mean)
tau.sq.beta &lt;- c(0.4, 0.3)
# Detection
# Detection covariates
alpha.mean &lt;- list()
tau.sq.alpha &lt;- list()
# Number of detection parameters in each data source
p.det.long &lt;- c(4, 3)
for (i in 1:n.data) {
  alpha.mean[[i]] &lt;- runif(p.det.long[i], -1, 1)
  tau.sq.alpha[[i]] &lt;- runif(p.det.long[i], 0.1, 1)
}
# Random effects
psi.RE &lt;- list()
p.RE &lt;- list()
beta &lt;- matrix(NA, nrow = max(N), ncol = p.occ)
for (i in 1:p.occ) {
  beta[, i] &lt;- rnorm(max(N), beta.mean[i], sqrt(tau.sq.beta[i]))
}
alpha &lt;- list()
for (i in 1:n.data) {
  alpha[[i]] &lt;- matrix(NA, nrow = N[i], ncol = p.det.long[i])
  for (t in 1:p.det.long[i]) {
    alpha[[i]][, t] &lt;- rnorm(N[i], alpha.mean[[i]][t], sqrt(tau.sq.alpha[[i]])[t])
  }
}
sp &lt;- FALSE
factor.model &lt;- FALSE
# Simulate occupancy data
dat &lt;- simIntMsOcc(n.data = n.data, J.x = J.x, J.y = J.y,
		   J.obs = J.obs, n.rep = n.rep, N = N, beta = beta, alpha = alpha,
	           psi.RE = psi.RE, p.RE = p.RE, sp = sp, factor.model = factor.model,
                   n.factors = n.factors)
str(dat)
</code></pre>

<hr>
<h2 id='simIntOcc'>Simulate Single-Species Detection-Nondetection Data from Multiple Data Sources</h2><span id='topic+simIntOcc'></span>

<h3>Description</h3>

<p>The function <code>simIntOcc</code> simulates single-species detection-nondetection data from multiple data sources for simulation studies, power assessments, or function testing of integrated occupancy models. Data can optionally be simulated with a spatial Gaussian Process on the occurrence process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simIntOcc(n.data, J.x, J.y, J.obs, n.rep, n.rep.max, beta, alpha,
          sp = FALSE, cov.model, sigma.sq, phi, nu, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simIntOcc_+3A_n.data">n.data</code></td>
<td>
<p>an integer indicating the number of detection-nondetection data sources to simulate.</p>
</td></tr>
<tr><td><code id="simIntOcc_+3A_j.x">J.x</code></td>
<td>
<p>a single numeric value indicating the number of sites across the region of interest along the horizontal axis. Total number of sites across the simulated region of interest is <code class="reqn">J.x \times J.y</code>. </p>
</td></tr>
<tr><td><code id="simIntOcc_+3A_j.y">J.y</code></td>
<td>
<p>a single numeric value indicating the number of sites across the region of interest along the vertical axis. Total number of sites across the simulated region of interest is <code class="reqn">J.x \times J.y</code>. </p>
</td></tr>
<tr><td><code id="simIntOcc_+3A_j.obs">J.obs</code></td>
<td>
<p>a numeric vector of length <code>n.data</code> containing the number of sites to simulate each data source at. Data sources can be obtained at completely different sites, the same sites, or anywhere inbetween. Maximum number of sites a given data source is available at is equal to <code class="reqn">J = J.x \times J.y</code>.</p>
</td></tr>
<tr><td><code id="simIntOcc_+3A_n.rep">n.rep</code></td>
<td>
<p>a list of length <code>n.data</code>. Each element is a numeric vector with length corresponding to the number of sites that given data source is observed at (in <code>J.obs</code>). Each vector indicates the number of repeat visits at each of the sites for a given data source.</p>
</td></tr>
<tr><td><code id="simIntOcc_+3A_n.rep.max">n.rep.max</code></td>
<td>
<p>a vector of numeric values indicating the maximum number of replicate surveys for each data set. This is an optional argument, with its default value set to <code>max(n.rep)</code> for each data set. This can be used to generate data sets with different types of missingness (e.g., simulate data across 20 days (replicate surveys) but sites are only sampled a maximum of ten times each).</p>
</td></tr>
<tr><td><code id="simIntOcc_+3A_beta">beta</code></td>
<td>
<p>a numeric vector containing the intercept and regression coefficient parameters for the occurrence portion of the single-species occupancy model.</p>
</td></tr>
<tr><td><code id="simIntOcc_+3A_alpha">alpha</code></td>
<td>
<p>a list of length <code>n.data</code>. Each element is a numeric vector containing the intercept and regression coefficient parameters for the detection portion of the single-species occupancy model for each data source.</p>
</td></tr>		
<tr><td><code id="simIntOcc_+3A_sp">sp</code></td>
<td>
<p>a logical value indicating whether to simulate a spatially-explicit occupancy model with a Gaussian process. By default set to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="simIntOcc_+3A_cov.model">cov.model</code></td>
<td>
<p>a quoted keyword that specifies the covariance function used to model the spatial dependence structure among the latent occurrence values.  Supported covariance model key words are: <code>"exponential"</code>, <code>"matern"</code>, <code>"spherical"</code>, and <code>"gaussian"</code>.</p>
</td></tr>
<tr><td><code id="simIntOcc_+3A_sigma.sq">sigma.sq</code></td>
<td>
<p>a numeric value indicating the spatial variance parameter. Ignored when <code>sp = FALSE</code>.</p>
</td></tr>
<tr><td><code id="simIntOcc_+3A_phi">phi</code></td>
<td>
<p>a numeric value indicating the spatial range parameter. Ignored when <code>sp = FALSE</code>. </p>
</td></tr>
<tr><td><code id="simIntOcc_+3A_nu">nu</code></td>
<td>
<p>a numeric value indicating the spatial smoothness parameter. Only used when <code>sp = TRUE</code> and <code>cov.model = "matern"</code>.</p>
</td></tr>
<tr><td><code id="simIntOcc_+3A_...">...</code></td>
<td>
<p>currently no additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list comprised of: 
</p>
<table>
<tr><td><code>X.obs</code></td>
<td>
<p>a numeric design matrix for the occurrence portion of the model. This matrix contains the intercept and regression coefficients for only the observed sites.</p>
</td></tr>
<tr><td><code>X.pred</code></td>
<td>
<p>a numeric design matrix for the occurrence portion of the model at sites where there are no observed data sources.</p>
</td></tr> 
<tr><td><code>X.p</code></td>
<td>
<p>a list of design matrices for the detection portions of the integrated occupancy model. Each element in the list is a design matrix of detection covariates for each data source.</p>
</td></tr>
<tr><td><code>coords.obs</code></td>
<td>
<p>a numeric matrix of coordinates of each observed site. Required for spatial models.</p>
</td></tr>
<tr><td><code>coords.pred</code></td>
<td>
<p>a numeric matrix of coordinates of each site in the study region without any data sources. Only used for spatial models.</p>
</td></tr>
<tr><td><code>D.obs</code></td>
<td>
<p>a distance matrix of observed sites. Only used for spatial models.</p>
</td></tr>
<tr><td><code>D.pred</code></td>
<td>
<p>a distance matrix of sites in the study region without any observed data. Only used for spatial models.</p>
</td></tr>
<tr><td><code>w.obs</code></td>
<td>
<p>a matrix of the spatial random effects at observed locations. Only used to simulate data when <code>sp = TRUE</code></p>
</td></tr></table>
<p>. 
</p>
<table>
<tr><td><code>w.pred</code></td>
<td>
<p>a matrix of the spatial random random effects at locations without any observation.</p>
</td></tr>
<tr><td><code>psi.obs</code></td>
<td>
<p>a matrix of the occurrence probabilities for each observed site.</p>
</td></tr>
<tr><td><code>psi.pred</code></td>
<td>
<p>a matrix of the occurrence probabilities for sites without any observations.</p>
</td></tr>
<tr><td><code>z.obs</code></td>
<td>
<p>a vector of the latent occurrence states at each observed site.</p>
</td></tr>
<tr><td><code>z.pred</code></td>
<td>
<p>a vector of the latent occurrence states at each site without any observations.</p>
</td></tr>
<tr><td><code>p</code></td>
<td>
<p>a list of detection probability matrices for each of the <code>n.data</code> data sources.</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>a list of matrices of the raw detection-nondetection data for each site and replicate combination.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jeffrey W. Doser <a href="mailto:doserjef@msu.edu">doserjef@msu.edu</a>, <br />
Andrew O. Finley <a href="mailto:finleya@msu.edu">finleya@msu.edu</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(400)

# Simulate Data -----------------------------------------------------------
J.x &lt;- 15
J.y &lt;- 15
J.all &lt;- J.x * J.y
# Number of data sources.
n.data &lt;- 4
# Sites for each data source. 
J.obs &lt;- sample(ceiling(0.2 * J.all):ceiling(0.5 * J.all), n.data, replace = TRUE)
# Replicates for each data source.
n.rep &lt;- list()
for (i in 1:n.data) {
  n.rep[[i]] &lt;- sample(1:4, size = J.obs[i], replace = TRUE)
}
# Occupancy covariates
beta &lt;- c(0.5, 1, -3)
p.occ &lt;- length(beta)
# Detection covariates
alpha &lt;- list()
for (i in 1:n.data) {
  alpha[[i]] &lt;- runif(sample(1:4, 1), -1, 1)
}
p.det.long &lt;- sapply(alpha, length)
p.det &lt;- sum(p.det.long)
sigma.sq &lt;- 2
phi &lt;- 3 / .5
sp &lt;- TRUE

# Simulate occupancy data. 
dat &lt;- simIntOcc(n.data = n.data, J.x = J.x, J.y = J.y, J.obs = J.obs, 
                 n.rep = n.rep, beta = beta, alpha = alpha, sp = TRUE, 
                 cov.model = 'gaussian', sigma.sq = sigma.sq, phi = phi)
</code></pre>

<hr>
<h2 id='simMsOcc'>Simulate Multi-Species Detection-Nondetection Data</h2><span id='topic+simMsOcc'></span>

<h3>Description</h3>

<p>The function <code>simMsOcc</code> simulates multi-species detection-nondetection data for simulation studies, power assessments, or function testing. Data can be optionally simulated with a spatial Gaussian Process in the occurrence portion of the model, as well as an option to allow for species correlations using a factor modeling approach. Non-spatial random intercepts can also be included in the detection or occurrence portions of the occupancy model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simMsOcc(J.x, J.y, n.rep, n.rep.max, N, beta, alpha, psi.RE = list(), 
         p.RE = list(), sp = FALSE, svc.cols = 1, cov.model, 
	 sigma.sq, phi, nu, factor.model = FALSE, n.factors, 
         range.probs, shared.spatial = FALSE, grid, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simMsOcc_+3A_j.x">J.x</code></td>
<td>
<p>a single numeric value indicating the number of sites to simulate detection-nondetection data along the horizontal axis. Total number of sites with simulated data is <code class="reqn">J.x \times J.y</code>. </p>
</td></tr>
<tr><td><code id="simMsOcc_+3A_j.y">J.y</code></td>
<td>
<p>a single numeric value indicating the number of sites to simulate detection-nondetection data along the vertical axis. Total number of sites with simulated data is <code class="reqn">J.x \times J.y</code>. </p>
</td></tr>
<tr><td><code id="simMsOcc_+3A_n.rep">n.rep</code></td>
<td>
<p>a numeric vector of length <code class="reqn">J = J.x \times J.y</code> indicating the number of repeat visits at each of the <code class="reqn">J</code> sites.</p>
</td></tr>
<tr><td><code id="simMsOcc_+3A_n.rep.max">n.rep.max</code></td>
<td>
<p>a single numeric value indicating the maximum number of replicate surveys. This is an optional argument, with its default value set to <code>max(n.rep)</code>. This can be used to generate data sets with different types of missingness (e.g., simulate data across 20 days (replicate surveys) but sites are only sampled a maximum of ten times each).</p>
</td></tr>
<tr><td><code id="simMsOcc_+3A_n">N</code></td>
<td>
<p>a single numeric value indicating the number of species to simulate detection-nondetection data.</p>
</td></tr>
<tr><td><code id="simMsOcc_+3A_beta">beta</code></td>
<td>
<p>a numeric matrix with <code class="reqn">N</code> rows containing the intercept and regression coefficient parameters for the occurrence portion of the multi-species occupancy model. Each row corresponds to the regression coefficients for a given species.</p>
</td></tr> 
<tr><td><code id="simMsOcc_+3A_alpha">alpha</code></td>
<td>
<p>a numeric matrix with <code class="reqn">N</code> rows containing the intercept and regression coefficient parameters for the detection portion of the multi-species occupancy model. Each row corresponds to the regression coefficients for a given species.</p>
</td></tr>
<tr><td><code id="simMsOcc_+3A_psi.re">psi.RE</code></td>
<td>
<p>a list used to specify the non-spatial random intercepts included in the occurrence portion of the model. The list must have two tags: <code>levels</code> and <code>sigma.sq.psi</code>. <code>levels</code> is a vector of length equal to the number of distinct random intercepts to include in the model and contains the number of levels there are in each intercept. <code>sigma.sq.psi</code> is a vector of length equal to the number of distinct random intercepts to include in the model and contains the variances for each random effect. If not specified, no random effects are included in the occurrence portion of the model.</p>
</td></tr>
<tr><td><code id="simMsOcc_+3A_p.re">p.RE</code></td>
<td>
<p>a list used to specify the non-spatial random intercepts included in the detection portion of the model. The list must have two tags: <code>levels</code> and <code>sigma.sq.p</code>. <code>levels</code> is a vector of length equal to the number of distinct random intercepts to include in the model and contains the number of levels there are in each intercept. <code>sigma.sq.p</code> is a vector of length equal to the number of distinct random intercepts to include in the model and contains the variances for each random effect. If not specified, no random effects are included in the detection portion of the model.</p>
</td></tr>
<tr><td><code id="simMsOcc_+3A_sp">sp</code></td>
<td>
<p>a logical value indicating whether to simulate a spatially-explicit occupancy model with a Gaussian process. By default set to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="simMsOcc_+3A_svc.cols">svc.cols</code></td>
<td>
<p>a vector indicating the variables whose effects will be
estimated as spatially-varying coefficients. <code>svc.cols</code> is an
integer vector with values indicating the order of covariates specified
in the model formula (with 1 being the intercept if specified).</p>
</td></tr>
<tr><td><code id="simMsOcc_+3A_cov.model">cov.model</code></td>
<td>
<p>a quoted keyword that specifies the covariance function used to model the spatial dependence structure among the latent occurrence values.  Supported covariance model key words are: <code>"exponential"</code>, <code>"matern"</code>, <code>"spherical"</code>, and <code>"gaussian"</code>.</p>
</td></tr>
<tr><td><code id="simMsOcc_+3A_sigma.sq">sigma.sq</code></td>
<td>
<p>a numeric vector of length <code class="reqn">N</code> containing the spatial variance parameter for each species. Ignored when <code>sp = FALSE</code> or when <code>factor.model = TRUE</code>.</p>
</td></tr>
<tr><td><code id="simMsOcc_+3A_phi">phi</code></td>
<td>
<p>a numeric vector of length <code class="reqn">N</code> containing the spatial decay parameter for each species. Ignored when <code>sp = FALSE</code>. If <code>factor.model = TRUE</code>, this should be of length <code>n.factors</code>.</p>
</td></tr>
<tr><td><code id="simMsOcc_+3A_nu">nu</code></td>
<td>
<p>a numeric vector of length <code class="reqn">N</code> containing the spatial smoothness parameter for each species. Only used when <code>sp = TRUE</code> and <code>cov.model = 'matern'</code>. If <code>factor.model = TRUE</code>, this should be of length <code>n.factors</code>.</p>
</td></tr> 
<tr><td><code id="simMsOcc_+3A_factor.model">factor.model</code></td>
<td>
<p>a logical value indicating whether to simulate data following a factor modeling approach that explicitly incoporates species correlations. If <code>sp = TRUE</code>, the latent factors are simulated from independent spatial processes. If <code>sp = FALSE</code>, the latent factors are simulated from standard normal distributions.</p>
</td></tr>
<tr><td><code id="simMsOcc_+3A_n.factors">n.factors</code></td>
<td>
<p>a single numeric value specifying the number of latent factors to use to simulate the data if <code>factor.model = TRUE</code>.</p>
</td></tr>
<tr><td><code id="simMsOcc_+3A_range.probs">range.probs</code></td>
<td>
<p>a numeric vector of length <code>N</code> where each value should fall between 0 and 1, and indicates the probability that one of the <code>J</code> spatial locations simulated is within the simulated range of the given species. If set to 1, every species has the potential of being present at each location.</p>
</td></tr>
<tr><td><code id="simMsOcc_+3A_shared.spatial">shared.spatial</code></td>
<td>
<p>a logical value indicating used to specify whether a common spatial process should be estimated for all species instead of the factor modeling approach.</p>
</td></tr>
<tr><td><code id="simMsOcc_+3A_grid">grid</code></td>
<td>
<p>an atomic vector used to specify the grid across which to simulate the latent spatial processes. This argument is used to simulate the underlying spatial processes at a different resolution than the coordinates (e.g., if coordinates are distributed across a grid).</p>
</td></tr>
<tr><td><code id="simMsOcc_+3A_...">...</code></td>
<td>
<p>currently no additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list comprised of: 
</p>
<table>
<tr><td><code>X</code></td>
<td>
<p>a <code class="reqn">J \times p.occ</code> numeric design matrix for the occurrence portion of the model.</p>
</td></tr>
<tr><td><code>X.p</code></td>
<td>
<p>a three-dimensional numeric array with dimensions corresponding to sites, repeat visits, and number of detection regression coefficients. This is the design matrix used for the detection portion of the occupancy model.</p>
</td></tr>
<tr><td><code>coords</code></td>
<td>
<p>a <code class="reqn">J \times 2</code> numeric matrix of coordinates of each occupancy site. Required for spatial models.</p>
</td></tr>
<tr><td><code>w</code></td>
<td>
<p>a <code class="reqn">N \times J</code> matrix of the spatial random effects for each species. Only used to simulate data when <code>sp = TRUE</code>. If <code>factor.model = TRUE</code>, the first dimension is <code>n.factors</code>.</p>
</td></tr>
<tr><td><code>psi</code></td>
<td>
<p>a <code class="reqn">N \times J</code> matrix of the occurrence probabilities for each species at each site.</p>
</td></tr>
<tr><td><code>z</code></td>
<td>
<p>a <code class="reqn">N \times J</code> matrix of the latent occurrence states for each species at each site.</p>
</td></tr>
<tr><td><code>p</code></td>
<td>
<p>a <code>N x J x max(n.rep)</code> array of the detection probabilities for each species at each site and replicate combination. Sites with fewer than <code>max(n.rep)</code> replicates will contain <code>NA</code> values.</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>a <code>N x J x max(n.rep)</code> array of the raw detection-nondetection data for each species at each site and replicate combination. Sites with fewer than <code>max(n.rep)</code> replicates will contain <code>NA</code> values.</p>
</td></tr>
<tr><td><code>X.p.re</code></td>
<td>
<p>a three-dimensional numeric array containing the levels of any detection random effect included in the model. Only relevant when detection random effects are specified in <code>p.RE</code>.</p>
</td></tr>
<tr><td><code>X.lambda.re</code></td>
<td>
<p>a numeric matrix containing the levels of any occurrence random effect included in the model. Only relevant when occurrence random effects are specified in <code>psi.RE</code>.</p>
</td></tr>
<tr><td><code>alpha.star</code></td>
<td>
<p>a numeric matrix where each row contains the simulated detection random effects for each given level of the random effects included in the detection model. Only relevant when detection random effects are included in the model.</p>
</td></tr>
<tr><td><code>beta.star</code></td>
<td>
<p>a numeric matrix where each row contains the simulated occurrence random effects for each given level of the random effects included in the occurrence model. Only relevant when occurrence random effects are included in the model.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jeffrey W. Doser <a href="mailto:doserjef@msu.edu">doserjef@msu.edu</a>, <br />
Andrew O. Finley <a href="mailto:finleya@msu.edu">finleya@msu.edu</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>J.x &lt;- 8
J.y &lt;- 8
J &lt;- J.x * J.y
n.rep &lt;- sample(2:4, size = J, replace = TRUE)
N &lt;- 10
# Community-level covariate effects
# Occurrence
beta.mean &lt;- c(0.2, -0.15)
p.occ &lt;- length(beta.mean)
tau.sq.beta &lt;- c(0.6, 0.3)
# Detection
alpha.mean &lt;- c(0.5, 0.2)
tau.sq.alpha &lt;- c(0.2, 0.3)
p.det &lt;- length(alpha.mean)
psi.RE &lt;- list(levels = c(10), 
               sigma.sq.psi = c(1.5))
p.RE &lt;- list(levels = c(15), 
             sigma.sq.p = 0.8)
# Draw species-level effects from community means.
beta &lt;- matrix(NA, nrow = N, ncol = p.occ)
alpha &lt;- matrix(NA, nrow = N, ncol = p.det)
for (i in 1:p.occ) {
  beta[, i] &lt;- rnorm(N, beta.mean[i], sqrt(tau.sq.beta[i]))
}
for (i in 1:p.det) {
  alpha[, i] &lt;- rnorm(N, alpha.mean[i], sqrt(tau.sq.alpha[i]))
}
# Spatial parameters if desired
phi &lt;- runif(N, 3/1, 3/.1)
sigma.sq &lt;- runif(N, 0.3, 3)
sp &lt;- TRUE

dat &lt;- simMsOcc(J.x = J.x, J.y = J.y, n.rep = n.rep, N = N, beta = beta, 
                alpha = alpha, psi.RE = psi.RE, p.RE = p.RE, sp = TRUE, 
                cov.model = 'exponential', phi = phi, sigma.sq = sigma.sq)
</code></pre>

<hr>
<h2 id='simOcc'>Simulate Single-Species Detection-Nondetection Data</h2><span id='topic+simOcc'></span>

<h3>Description</h3>

<p>The function <code>simOcc</code> simulates single-species occurrence data for simulation studies, power assessments, or function testing. Data can be optionally simulated with a spatial Gaussian Process in the occurrence portion of the model. Non-spatial random intercepts can also be included in the detection or occurrence portions of the occupancy model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simOcc(J.x, J.y, n.rep, n.rep.max, beta, alpha, psi.RE = list(), 
       p.RE = list(), sp = FALSE, svc.cols = 1, cov.model, 
       sigma.sq, phi, nu, x.positive = FALSE, grid, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simOcc_+3A_j.x">J.x</code></td>
<td>
<p>a single numeric value indicating the number of sites to simulate detection-nondetection data along the horizontal axis. Total number of sites with simulated data is <code class="reqn">J.x \times J.y</code>. </p>
</td></tr>
<tr><td><code id="simOcc_+3A_j.y">J.y</code></td>
<td>
<p>a single numeric value indicating the number of sites to simulate detection-nondetection data along the vertical axis. Total number of sites with simulated data is <code class="reqn">J.x \times J.y</code>. </p>
</td></tr>
<tr><td><code id="simOcc_+3A_n.rep">n.rep</code></td>
<td>
<p>a numeric vector of length <code class="reqn">J = J.x \times J.y</code> indicating the number of repeat visits at each of the <code class="reqn">J</code> sites.</p>
</td></tr>
<tr><td><code id="simOcc_+3A_n.rep.max">n.rep.max</code></td>
<td>
<p>a single numeric value indicating the maximum number of replicate surveys. This is an optional argument, with its default value set to <code>max(n.rep)</code>. This can be used to generate data sets with different types of missingness (e.g., simulate data across 20 days (replicate surveys) but sites are only sampled a maximum of ten times each).</p>
</td></tr>
<tr><td><code id="simOcc_+3A_beta">beta</code></td>
<td>
<p>a numeric vector containing the intercept and regression coefficient parameters for the occupancy portion of the single-species occupancy model.</p>
</td></tr>
<tr><td><code id="simOcc_+3A_alpha">alpha</code></td>
<td>
<p>a numeric vector containing the intercept and regression coefficient parameters for the detection portion of the single-species occupancy model.</p>
</td></tr>
<tr><td><code id="simOcc_+3A_psi.re">psi.RE</code></td>
<td>
<p>a list used to specify the non-spatial random intercepts included in the occupancy portion of the model. The list must have two tags: <code>levels</code> and <code>sigma.sq.psi</code>. <code>levels</code> is a vector of length equal to the number of distinct random intercepts to include in the model and contains the number of levels there are in each intercept. <code>sigma.sq.psi</code> is a vector of length equal to the number of distinct random intercepts to include in the model and contains the variances for each random effect. If not specified, no random effects are included in the occupancy portion of the model.</p>
</td></tr>
<tr><td><code id="simOcc_+3A_p.re">p.RE</code></td>
<td>
<p>a list used to specify the non-spatial random intercepts included in the detection portion of the model. The list must have two tags: <code>levels</code> and <code>sigma.sq.p</code>. <code>levels</code> is a vector of length equal to the number of distinct random intercepts to include in the model and contains the number of levels there are in each intercept. <code>sigma.sq.p</code> is a vector of length equal to the number of distinct random intercepts to include in the model and contains the variances for each random effect. If not specified, no random effects are included in the detection portion of the model.</p>
</td></tr>
<tr><td><code id="simOcc_+3A_sp">sp</code></td>
<td>
<p>a logical value indicating whether to simulate a spatially-explicit occupancy model with a Gaussian process. By default set to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="simOcc_+3A_svc.cols">svc.cols</code></td>
<td>
<p>a vector indicating the variables whose effects will be
estimated as spatially-varying coefficients. <code>svc.cols</code> is an
integer vector with values indicating the order of covariates specified
in the model formula (with 1 being the intercept if specified).</p>
</td></tr>
<tr><td><code id="simOcc_+3A_cov.model">cov.model</code></td>
<td>
<p>a quoted keyword that specifies the covariance function used to model the spatial dependence structure among the latent occurrence values.  Supported covariance model key words are: <code>"exponential"</code>, <code>"matern"</code>, <code>"spherical"</code>, and <code>"gaussian"</code>.</p>
</td></tr>
<tr><td><code id="simOcc_+3A_sigma.sq">sigma.sq</code></td>
<td>
<p>a numeric value indicating the spatial variance parameter. Ignored when <code>sp = FALSE</code>.</p>
</td></tr>
<tr><td><code id="simOcc_+3A_phi">phi</code></td>
<td>
<p>a numeric value indicating the spatial decay parameter. Ignored when <code>sp = FALSE</code>. </p>
</td></tr>
<tr><td><code id="simOcc_+3A_nu">nu</code></td>
<td>
<p>a numeric value indicating the spatial smoothness parameter. Only used when <code>sp = TRUE</code> and <code>cov.model = "matern"</code>.</p>
</td></tr> 
<tr><td><code id="simOcc_+3A_x.positive">x.positive</code></td>
<td>
<p>a logical value indicating whether the simulated covariates should be simulated as random standard normal covariates (<code>x.positive = FALSE</code>) or restricted to positive values using a uniform distribution with lower bound 0 and upper bound 1 (<code>x.positive = TRUE</code>).</p>
</td></tr>
<tr><td><code id="simOcc_+3A_grid">grid</code></td>
<td>
<p>an atomic vector used to specify the grid across which to simulate the latent spatial processes. This argument is used to simulate the underlying spatial processes at a different resolution than the coordinates (e.g., if coordinates are distributed across a grid).</p>
</td></tr>
<tr><td><code id="simOcc_+3A_...">...</code></td>
<td>
<p>currently no additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list comprised of: 
</p>
<table>
<tr><td><code>X</code></td>
<td>
<p>a <code class="reqn">J \times p.occ</code> numeric design matrix for the occupancy portion of the model.</p>
</td></tr>
<tr><td><code>X.p</code></td>
<td>
<p>a three-dimensional numeric array with dimensions corresponding to sites, repeat visits, and number of detection regression coefficients. This is the design matrix used for the detection portion of the occupancy model.</p>
</td></tr>
<tr><td><code>coords</code></td>
<td>
<p>a <code class="reqn">J \times 2</code> numeric matrix of coordinates of each occupancy site. Required for spatial models.</p>
</td></tr>
<tr><td><code>w</code></td>
<td>
<p>a matrix of the spatial random effect values for each site. The number of columns is determined by the <code>svc.cols</code> argument (the number of spatially-varying coefficients).</p>
</td></tr>
<tr><td><code>psi</code></td>
<td>
<p>a <code class="reqn">J \times 1</code> matrix of the occupancy probabilities for each site.</p>
</td></tr>
<tr><td><code>z</code></td>
<td>
<p>a length <code class="reqn">J</code> vector of the latent occupancy states at each site.</p>
</td></tr>
<tr><td><code>p</code></td>
<td>
<p>a <code>J x max(n.rep)</code> matrix of the detection probabilities for each site and replicate combination. Sites with fewer than <code>max(n.rep)</code> replicates will contain <code>NA</code> values.</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>a <code>J x max(n.rep)</code> matrix of the raw detection-nondetection data for each site and replicate combination.</p>
</td></tr>
<tr><td><code>X.p.re</code></td>
<td>
<p>a three-dimensional numeric array containing the levels of any detection random effect included in the model. Only relevant when detection random effects are specified in <code>p.RE</code>.</p>
</td></tr>
<tr><td><code>X.re</code></td>
<td>
<p>a numeric matrix containing the levels of any occurrence random effect included in the model. Only relevant when occurrence random effects are specified in <code>psi.RE</code>.</p>
</td></tr>
<tr><td><code>alpha.star</code></td>
<td>
<p>a numeric vector that contains the simulated detection random effects for each given level of the random effects included in the detection model. Only relevant when detection random effects are included in the model.</p>
</td></tr>
<tr><td><code>beta.star</code></td>
<td>
<p>a numeric vector that contains the simulated occurrence random effects for each given level of the random effects included in the occurrence model. Only relevant when occurrence random effects are included in the model.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jeffrey W. Doser <a href="mailto:doserjef@msu.edu">doserjef@msu.edu</a>, <br />
Andrew O. Finley <a href="mailto:finleya@msu.edu">finleya@msu.edu</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(400)
J.x &lt;- 10
J.y &lt;- 10
n.rep &lt;- rep(4, J.x * J.y)
beta &lt;- c(0.5, -0.15)
alpha &lt;- c(0.7, 0.4)
phi &lt;- 3 / .6
sigma.sq &lt;- 2
psi.RE &lt;- list(levels = 10, 
               sigma.sq.psi = 1.2)
p.RE &lt;- list(levels = 15, 
             sigma.sq.p = 0.8)
dat &lt;- simOcc(J.x = J.x, J.y = J.y, n.rep = n.rep, beta = beta, alpha = alpha,
              psi.RE = psi.RE, p.RE = p.RE, sp = TRUE, cov.model = 'spherical', 
              sigma.sq = sigma.sq, phi = phi)
</code></pre>

<hr>
<h2 id='simTBinom'>Simulate Multi-Season Single-Species Binomial Data</h2><span id='topic+simTBinom'></span>

<h3>Description</h3>

<p>The function <code>simTBinom</code> simulates multi-season single-species binomial data for simulation studies, power assessments, or function testing. Data can be optionally simulated with a spatial Gaussian Process in the model. Non-spatial random intercepts can also be included in the model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simTBinom(J.x, J.y, n.time, weights, beta, sp.only = 0, 
          trend = TRUE, psi.RE = list(), sp = FALSE, 
          cov.model, sigma.sq, phi, nu, svc.cols = 1, 
          ar1 = FALSE, rho, sigma.sq.t, x.positive = FALSE, ...) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simTBinom_+3A_j.x">J.x</code></td>
<td>
<p>a single numeric value indicating the number of sites to simulate data along the horizontal axis. Total number of sites with simulated data is <code class="reqn">J.x \times J.y</code>.</p>
</td></tr>
<tr><td><code id="simTBinom_+3A_j.y">J.y</code></td>
<td>
<p>a single numeric value indicating the number of sites to simulate data along the vertical axis. Total number of sites with simulated data is <code class="reqn">J.x \times J.y</code>.</p>
</td></tr>
<tr><td><code id="simTBinom_+3A_n.time">n.time</code></td>
<td>
<p>a single numeric value indicating the number of primary time periods (denoted T) over which sampling occurs.</p>
</td></tr> 
<tr><td><code id="simTBinom_+3A_weights">weights</code></td>
<td>
<p>a numeric matrix with rows corresponding to sites and columns corresponding to primary time periods that indicates the number of Bernoulli trials at each of the site/time period combinations.</p>
</td></tr>
<tr><td><code id="simTBinom_+3A_beta">beta</code></td>
<td>
<p>a numeric vector containing the intercept and regression coefficient parameters for the model.</p>
</td></tr>
<tr><td><code id="simTBinom_+3A_sp.only">sp.only</code></td>
<td>
<p>a numeric vector specifying which occurrence covariates should only vary over space and not over time. The numbers in the vector correspond to the elements in the vector of regression coefficients (<code>beta</code>). By default, all simulated occurrence covariates are assumed to vary over both space and time.</p>
</td></tr>
<tr><td><code id="simTBinom_+3A_trend">trend</code></td>
<td>
<p>a logical value. If <code>TRUE</code>, a temporal trend will be used to simulate the detection-nondetection data and the second element of <code>beta</code> is assumed to be the trend parameter. If <code>FALSE</code> no trend is used to simulate the data and all elements of <code>beta</code> (except the first value which is the intercept) correspond to covariate effects.</p>
</td></tr>
<tr><td><code id="simTBinom_+3A_psi.re">psi.RE</code></td>
<td>
<p>a list used to specify the non-spatial random intercepts included in the model. The list must have two tags: <code>levels</code> and <code>sigma.sq.psi</code>. <code>levels</code> is a vector of length equal to the number of distinct random intercepts to include in the model and contains the number of levels there are in each intercept. <code>sigma.sq.psi</code> is a vector of length equal to the number of distinct random intercepts to include in the model and contains the variances for each random effect. If not specified, no random effects are included in the model.</p>
</td></tr>
<tr><td><code id="simTBinom_+3A_sp">sp</code></td>
<td>
<p>a logical value indicating whether to simulate a spatially-explicit occupancy model with a Gaussian process. By default set to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="simTBinom_+3A_svc.cols">svc.cols</code></td>
<td>
<p>a vector indicating the variables whose effects will be
estimated as spatially-varying coefficients. <code>svc.cols</code> is an
integer vector with values indicating the order of covariates specified
in the model formula (with 1 being the intercept if specified).</p>
</td></tr>
<tr><td><code id="simTBinom_+3A_cov.model">cov.model</code></td>
<td>
<p>a quoted keyword that specifies the covariance function used to model the spatial dependence structure among the latent occurrence values.  Supported covariance model key words are: <code>"exponential"</code>, <code>"matern"</code>, <code>"spherical"</code>, and <code>"gaussian"</code>.</p>
</td></tr>
<tr><td><code id="simTBinom_+3A_sigma.sq">sigma.sq</code></td>
<td>
<p>a numeric value indicating the spatial variance parameter. Ignored when <code>sp = FALSE</code>. If <code>svc.cols</code> has more than one value, there should be a distinct spatial variance parameter for each spatially-varying coefficient.</p>
</td></tr>
<tr><td><code id="simTBinom_+3A_phi">phi</code></td>
<td>
<p>a numeric value indicating the spatial decay parameter. Ignored when <code>sp = FALSE</code>. If <code>svc.cols</code> has more than one value, there should be a distinct spatial decay parameter for each spatially-varying coefficient.</p>
</td></tr>
<tr><td><code id="simTBinom_+3A_nu">nu</code></td>
<td>
<p>a numeric value indicating the spatial smoothness parameter. Only used when <code>sp = TRUE</code> and <code>cov.model = "matern"</code>. If <code>svc.cols</code> has more than one value, there should be a distinct spatial smoothness parameter for each spatially-varying coefficient.</p>
</td></tr> 
<tr><td><code id="simTBinom_+3A_ar1">ar1</code></td>
<td>
<p>a logical value indicating whether to simulate a temporal random effect with an AR(1) process. By default, set to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="simTBinom_+3A_rho">rho</code></td>
<td>
<p>a numeric value indicating the AR(1) temporal correlation parameter. Ignored when <code>ar1 = FALSE</code>.</p>
</td></tr>
<tr><td><code id="simTBinom_+3A_sigma.sq.t">sigma.sq.t</code></td>
<td>
<p>a numeric value indicating the AR(1) temporal variance parameter. Ignored when <code>ar1 = FALSE</code>.</p>
</td></tr>
<tr><td><code id="simTBinom_+3A_x.positive">x.positive</code></td>
<td>
<p>a logical value indicating whether the simulated covariates should be simulated as random standard normal covariates (<code>x.positive = FALSE</code>) or restricted to positive values (<code>x.positive = TRUE</code>). If <code>x.positive = TRUE</code>, covariates are simulated from a random normal and then the minimum value is added to each covariate value to ensure non-negative covariate values.</p>
</td></tr>
<tr><td><code id="simTBinom_+3A_...">...</code></td>
<td>
<p>currently no additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list comprised of: 
</p>
<table>
<tr><td><code>X</code></td>
<td>
<p>a <code class="reqn">J \times T \times p.occ</code> numeric array containing the design matrix for the model.</p>
</td></tr>
<tr><td><code>coords</code></td>
<td>
<p>a <code class="reqn">J \times 2</code> numeric matrix of coordinates of each occupancy site. Required for spatial models.</p>
</td></tr>
<tr><td><code>w</code></td>
<td>
<p>a matrix of the spatial random effect values for each site. The number of columns is determined by the <code>svc.cols</code> argument (the number of spatially-varying coefficients).</p>
</td></tr>
<tr><td><code>psi</code></td>
<td>
<p>a <code class="reqn">J \times T</code> matrix of the occupancy probabilities for each site during each primary time period.</p>
</td></tr>
<tr><td><code>z</code></td>
<td>
<p>a  <code class="reqn">J \times T</code> matrix of the binomial data at each site during each primary time period.</p>
</td></tr>
<tr><td><code>X.w</code></td>
<td>
<p>a three dimensional array containing the covariate effects (including an intercept) whose effects are assumed to be spatially-varying. Dimensions correspond to sites, primary time periods, and covariate.</p>
</td></tr>
<tr><td><code>X.re</code></td>
<td>
<p>a numeric matrix containing the levels of any unstructured random effect included in the model. Only relevant when random effects are specified in <code>psi.RE</code>.</p>
</td></tr>
<tr><td><code>beta.star</code></td>
<td>
<p>a numeric vector that contains the simulated random effects for each given level of the random effects included in the model. Only relevant when random effects are included in the model.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jeffrey W. Doser <a href="mailto:doserjef@msu.edu">doserjef@msu.edu</a>, <br />
Andrew O. Finley <a href="mailto:finleya@msu.edu">finleya@msu.edu</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1000)
# Sites
J.x &lt;- 15
J.y &lt;- 15 
J &lt;- J.x * J.y
# Years sampled
n.time &lt;- sample(10, J, replace = TRUE)
# Binomial weights
weights &lt;- matrix(NA, J, max(n.time))
for (j in 1:J) {
  weights[j, 1:n.time[j]] &lt;- sample(5, n.time[j], replace = TRUE)
}
# Occurrence --------------------------
beta &lt;- c(-2, -0.5, -0.2, 0.75)
p.occ &lt;- length(beta)
trend &lt;- TRUE
sp.only &lt;- 0
psi.RE &lt;- list()
# Spatial parameters ------------------
sp &lt;- TRUE
svc.cols &lt;- c(1, 2, 3)
p.svc &lt;- length(svc.cols)
cov.model &lt;- "exponential"
sigma.sq &lt;- runif(p.svc, 0.1, 1)
phi &lt;- runif(p.svc, 3/1, 3/0.2)
# Temporal parameters -----------------
ar1 &lt;- TRUE 
rho &lt;- 0.8
sigma.sq.t &lt;- 1

dat &lt;- simTBinom(J.x = J.x, J.y = J.y, n.time = n.time, weights = weights, beta = beta, 
                 psi.RE = psi.RE, sp.only = sp.only, trend = trend, 
                 sp = sp, svc.cols = svc.cols, 
                 cov.model = cov.model, sigma.sq = sigma.sq, phi = phi,
                 rho = rho, sigma.sq.t = sigma.sq.t, ar1 = TRUE, x.positive = FALSE)
</code></pre>

<hr>
<h2 id='simTMsOcc'>Simulate Multi-Species Multi-Season Detection-Nondetection Data</h2><span id='topic+simTMsOcc'></span>

<h3>Description</h3>

<p>The function <code>simTMsOcc</code> simulates multi-species multi-season detection-nondetection data for simulation studies, power assessments, or function testing. Data can be optionally simulated with a spatial Gaussian Process in the occurrence portion of the model, as well as an option to allow for species correlations using a factor modeling approach. Non-spatial random intercepts can also be included in the detection or occurrence portions of the occupancy model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simTMsOcc(J.x, J.y, n.time, n.rep, N, beta, alpha, sp.only = 0, 
	  trend = TRUE, psi.RE = list(), p.RE = list(), 
          sp = FALSE, svc.cols = 1, cov.model, 
	  sigma.sq, phi, nu, ar1 = FALSE, rho, sigma.sq.t, 
	  factor.model = FALSE, n.factors, range.probs, grid, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simTMsOcc_+3A_j.x">J.x</code></td>
<td>
<p>a single numeric value indicating the number of sites to simulate detection-nondetection data along the horizontal axis. Total number of sites with simulated data is <code class="reqn">J.x \times J.y</code>. </p>
</td></tr>
<tr><td><code id="simTMsOcc_+3A_j.y">J.y</code></td>
<td>
<p>a single numeric value indicating the number of sites to simulate detection-nondetection data along the vertical axis. Total number of sites with simulated data is <code class="reqn">J.x \times J.y</code>. </p>
</td></tr>
<tr><td><code id="simTMsOcc_+3A_n.time">n.time</code></td>
<td>
<p>a single numeric value indicating the number of primary time periods (denoted T) over which sampling occurs.</p>
</td></tr>
<tr><td><code id="simTMsOcc_+3A_n.rep">n.rep</code></td>
<td>
<p>a numeric matrix indicating the number of replicates at each site during each primary time period. The matrix must have <code class="reqn">J = J.x \times J.y</code> rows and T columns, where T is the number of primary time periods (e.g., years or seasons) over which sampling occurs.</p>
</td></tr> 
<tr><td><code id="simTMsOcc_+3A_n">N</code></td>
<td>
<p>a single numeric value indicating the number of species to simulate detection-nondetection data.</p>
</td></tr>
<tr><td><code id="simTMsOcc_+3A_beta">beta</code></td>
<td>
<p>a numeric matrix with <code class="reqn">N</code> rows containing the intercept and regression coefficient parameters for the occurrence portion of the multi-species occupancy model. Each row corresponds to the regression coefficients for a given species.</p>
</td></tr> 
<tr><td><code id="simTMsOcc_+3A_alpha">alpha</code></td>
<td>
<p>a numeric matrix with <code class="reqn">N</code> rows containing the intercept and regression coefficient parameters for the detection portion of the multi-species occupancy model. Each row corresponds to the regression coefficients for a given species.</p>
</td></tr>
<tr><td><code id="simTMsOcc_+3A_sp.only">sp.only</code></td>
<td>
<p>a numeric vector specifying which occurrence covariates should only vary over space and not over time. The numbers in the vector correspond to the elements in the vector of regression coefficients (<code>beta</code>). By default, all simulated occurrence covariates are assumed to vary over both space and time.</p>
</td></tr>
<tr><td><code id="simTMsOcc_+3A_trend">trend</code></td>
<td>
<p>a logical value. If <code>TRUE</code>, a temporal trend will be used to simulate the detection-nondetection data and the second element of <code>beta</code> is assumed to be the trend parameter. If <code>FALSE</code> no trend is used to simulate the data and all elements of <code>beta</code> (except the first value which is the intercept) correspond to covariate effects.</p>
</td></tr>
<tr><td><code id="simTMsOcc_+3A_psi.re">psi.RE</code></td>
<td>
<p>a list used to specify the non-spatial random intercepts included in the occurrence portion of the model. The list must have two tags: <code>levels</code> and <code>sigma.sq.psi</code>. <code>levels</code> is a vector of length equal to the number of distinct random intercepts to include in the model and contains the number of levels there are in each intercept. <code>sigma.sq.psi</code> is a vector of length equal to the number of distinct random intercepts to include in the model and contains the variances for each random effect. If not specified, no random effects are included in the occurrence portion of the model.</p>
</td></tr>
<tr><td><code id="simTMsOcc_+3A_p.re">p.RE</code></td>
<td>
<p>a list used to specify the non-spatial random intercepts included in the detection portion of the model. The list must have two tags: <code>levels</code> and <code>sigma.sq.p</code>. <code>levels</code> is a vector of length equal to the number of distinct random intercepts to include in the model and contains the number of levels there are in each intercept. <code>sigma.sq.p</code> is a vector of length equal to the number of distinct random intercepts to include in the model and contains the variances for each random effect. If not specified, no random effects are included in the detection portion of the model.</p>
</td></tr>
<tr><td><code id="simTMsOcc_+3A_sp">sp</code></td>
<td>
<p>a logical value indicating whether to simulate a spatially-explicit occupancy model with a Gaussian process. By default set to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="simTMsOcc_+3A_svc.cols">svc.cols</code></td>
<td>
<p>a vector indicating the variables whose effects will be
estimated as spatially-varying coefficients. <code>svc.cols</code> is an
integer vector with values indicating the order of covariates specified
in the model formula (with 1 being the intercept if specified).</p>
</td></tr>
<tr><td><code id="simTMsOcc_+3A_cov.model">cov.model</code></td>
<td>
<p>a quoted keyword that specifies the covariance function used to model the spatial dependence structure among the latent occurrence values.  Supported covariance model key words are: <code>"exponential"</code>, <code>"matern"</code>, <code>"spherical"</code>, and <code>"gaussian"</code>.</p>
</td></tr>
<tr><td><code id="simTMsOcc_+3A_sigma.sq">sigma.sq</code></td>
<td>
<p>a numeric vector of length <code class="reqn">N</code> containing the spatial variance parameter for each species. Ignored when <code>sp = FALSE</code> or when <code>factor.model = TRUE</code>.</p>
</td></tr>
<tr><td><code id="simTMsOcc_+3A_phi">phi</code></td>
<td>
<p>a numeric vector of length <code class="reqn">N</code> containing the spatial decay parameter for each species. Ignored when <code>sp = FALSE</code>. If <code>factor.model = TRUE</code>, this should be of length <code>n.factors</code>.</p>
</td></tr>
<tr><td><code id="simTMsOcc_+3A_nu">nu</code></td>
<td>
<p>a numeric vector of length <code class="reqn">N</code> containing the spatial smoothness parameter for each species. Only used when <code>sp = TRUE</code> and <code>cov.model = 'matern'</code>. If <code>factor.model = TRUE</code>, this should be of length <code>n.factors</code>.</p>
</td></tr> 
<tr><td><code id="simTMsOcc_+3A_ar1">ar1</code></td>
<td>
<p>a logical value indicating whether to simulate a temporal random effect with an AR(1) process. By default, set to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="simTMsOcc_+3A_rho">rho</code></td>
<td>
<p>a vector of <code>N</code> values indicating the AR(1) temporal correlation parameter for each species. Ignored when <code>ar1 = FALSE</code>.</p>
</td></tr>
<tr><td><code id="simTMsOcc_+3A_sigma.sq.t">sigma.sq.t</code></td>
<td>
<p>a vector of <code>N</code> values indicating the AR(1) temporal variance parameter for each species. Ignored when <code>ar1 = FALSE</code>.</p>
</td></tr>
<tr><td><code id="simTMsOcc_+3A_factor.model">factor.model</code></td>
<td>
<p>a logical value indicating whether to simulate data following a factor modeling approach that explicitly incoporates species correlations. If <code>sp = TRUE</code>, the latent factors are simulated from independent spatial processes. If <code>sp = FALSE</code>, the latent factors are simulated from standard normal distributions.</p>
</td></tr>
<tr><td><code id="simTMsOcc_+3A_n.factors">n.factors</code></td>
<td>
<p>a single numeric value specifying the number of latent factors to use to simulate the data if <code>factor.model = TRUE</code>.</p>
</td></tr>
<tr><td><code id="simTMsOcc_+3A_range.probs">range.probs</code></td>
<td>
<p>a numeric vector of length <code>N</code> where each value should fall between 0 and 1, and indicates the probability that one of the <code>J</code> spatial locations simulated is within the simulated range of the given species. If set to 1, every species has the potential of being present at each location.</p>
</td></tr>
<tr><td><code id="simTMsOcc_+3A_grid">grid</code></td>
<td>
<p>an atomic vector used to specify the grid across which to simulate the latent spatial processes. This argument is used to simulate the underlying spatial processes at a different resolution than the coordinates (e.g., if coordinates are distributed across a grid).</p>
</td></tr>
<tr><td><code id="simTMsOcc_+3A_...">...</code></td>
<td>
<p>currently no additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list comprised of: 
</p>
<table>
<tr><td><code>X</code></td>
<td>
<p>a <code class="reqn">J \times T \times p.occ</code> numeric array containing the design matrix for the occurrence portion of the occupancy model.</p>
</td></tr>
<tr><td><code>X.p</code></td>
<td>
<p>a four-dimensional numeric array with dimensions corresponding to sites, primary time periods, repeat visits, and number of detection regression coefficients. This is the design matrix used for the detection portion of the occupancy model.</p>
</td></tr>
<tr><td><code>coords</code></td>
<td>
<p>a <code class="reqn">J \times 2</code> numeric matrix of coordinates of each occupancy site. Required for spatial models.</p>
</td></tr>
<tr><td><code>w</code></td>
<td>
<p>a <code class="reqn">N \times J</code> matrix of the spatial random effects for each species. Only used to simulate data when <code>sp = TRUE</code>. If <code>factor.model = TRUE</code>, the first dimension is <code>n.factors</code>.</p>
</td></tr>
<tr><td><code>psi</code></td>
<td>
<p>a <code class="reqn">N \times J \times T</code> array of the occurrence probabilities for each species at each site during each primary time period.</p>
</td></tr>
<tr><td><code>z</code></td>
<td>
<p>a <code class="reqn">N \times J \times T</code> array of the latent occurrence status for each species at each site during each primary time period.</p>
</td></tr>
<tr><td><code>p</code></td>
<td>
<p>a <code>N x J x T x max(n.rep)</code> array of the detection probabilities for each species at each site, primary time period, and secondyary replicate combination. Sites with fewer than <code>max(n.rep)</code> replicates will contain <code>NA</code> values.</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>a <code>N x J x T x max(n.rep)</code> array of the raw detection-nondetection data for each species at each site, primary time period, and replicate combination. Sites with fewer than <code>max(n.rep)</code> replicates will contain <code>NA</code> values.</p>
</td></tr>
<tr><td><code>X.p.re</code></td>
<td>
<p>a four-dimensional numeric array containing the levels of any detection random effect included in the model. Only relevant when detection random effects are specified in <code>p.RE</code>.</p>
</td></tr>
<tr><td><code>X.re</code></td>
<td>
<p>a numeric matrix containing the levels of any occurrence random effect included in the model. Only relevant when occurrence random effects are specified in <code>psi.RE</code>.</p>
</td></tr>
<tr><td><code>alpha.star</code></td>
<td>
<p>a numeric matrix where each row contains the simulated detection random effects for each given level of the random effects included in the detection model. Only relevant when detection random effects are included in the model.</p>
</td></tr>
<tr><td><code>beta.star</code></td>
<td>
<p>a numeric matrix where each row contains the simulated occurrence random effects for each given level of the random effects included in the occurrence model. Only relevant when occurrence random effects are included in the model.</p>
</td></tr>
<tr><td><code>eta</code></td>
<td>
<p>a numeric matrix with each row corresponding to species and column corresponding to time period of the AR(1) temporal random effects.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jeffrey W. Doser <a href="mailto:doserjef@msu.edu">doserjef@msu.edu</a>, <br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simulate Data -----------------------------------------------------------
set.seed(500)
J.x &lt;- 8
J.y &lt;- 8
J &lt;- J.x * J.y
# Years sampled
n.time &lt;- sample(3:10, J, replace = TRUE)
# n.time &lt;- rep(10, J)
n.time.max &lt;- max(n.time)
# Replicates
n.rep &lt;- matrix(NA, J, max(n.time))
for (j in 1:J) {
  n.rep[j, 1:n.time[j]] &lt;- sample(2:4, n.time[j], replace = TRUE)
  # n.rep[j, 1:n.time[j]] &lt;- rep(4, n.time[j])
}
N &lt;- 7
# Community-level covariate effects
# Occurrence
beta.mean &lt;- c(-3, -0.2, 0.5)
trend &lt;- FALSE
sp.only &lt;- 0
p.occ &lt;- length(beta.mean)
tau.sq.beta &lt;- c(0.6, 1.5, 1.4)
# Detection
alpha.mean &lt;- c(0, 1.2, -1.5)
tau.sq.alpha &lt;- c(1, 0.5, 2.3)
p.det &lt;- length(alpha.mean)
# Random effects
psi.RE &lt;- list()
p.RE &lt;- list()
# Draw species-level effects from community means.
beta &lt;- matrix(NA, nrow = N, ncol = p.occ)
alpha &lt;- matrix(NA, nrow = N, ncol = p.det)
for (i in 1:p.occ) {
  beta[, i] &lt;- rnorm(N, beta.mean[i], sqrt(tau.sq.beta[i]))
}
for (i in 1:p.det) {
  alpha[, i] &lt;- rnorm(N, alpha.mean[i], sqrt(tau.sq.alpha[i]))
}
sp &lt;- TRUE
svc.cols &lt;- c(1, 2)
p.svc &lt;- length(svc.cols)
n.factors &lt;- 3
phi &lt;- runif(p.svc * n.factors, 3 / .9, 3 / .3)
factor.model &lt;- TRUE
cov.model &lt;- 'exponential'

dat &lt;- simTMsOcc(J.x = J.x, J.y = J.y, n.time = n.time, n.rep = n.rep, N = N,
		 beta = beta, alpha = alpha, sp.only = sp.only, trend = trend,
		 psi.RE = psi.RE, p.RE = p.RE, factor.model = factor.model,
                 svc.cols = svc.cols, n.factors = n.factors, phi = phi, sp = sp,
                 cov.model = cov.model)
str(dat)
</code></pre>

<hr>
<h2 id='simTOcc'>Simulate Multi-Season Single-Species Detection-Nondetection Data</h2><span id='topic+simTOcc'></span>

<h3>Description</h3>

<p>The function <code>simTOcc</code> simulates multi-season single-species occurrence data for simulation studies, power assessments, or function testing. Data can be optionally simulated with a spatial Gaussian Process in the occurrence portion of the model. Non-spatial random intercepts can also be included in the detection or occurrence portions of the occupancy model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simTOcc(J.x, J.y, n.time, n.rep, n.rep.max, beta, alpha, sp.only = 0, trend = TRUE, 
        psi.RE = list(), p.RE = list(), sp = FALSE, svc.cols = 1, cov.model, 
        sigma.sq, phi, nu, ar1 = FALSE, rho, sigma.sq.t, x.positive = FALSE, 
	mis.spec.type = 'none', scale.param = 1, avail, grid, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simTOcc_+3A_j.x">J.x</code></td>
<td>
<p>a single numeric value indicating the number of sites to simulate detection-nondetection data along the horizontal axis. Total number of sites with simulated data is <code class="reqn">J.x \times J.y</code>. </p>
</td></tr>
<tr><td><code id="simTOcc_+3A_j.y">J.y</code></td>
<td>
<p>a single numeric value indicating the number of sites to simulate detection-nondetection data along the vertical axis. Total number of sites with simulated data is <code class="reqn">J.x \times J.y</code>. </p>
</td></tr>
<tr><td><code id="simTOcc_+3A_n.time">n.time</code></td>
<td>
<p>a single numeric value indicating the number of primary time periods (denoted T) over which sampling occurs.</p>
</td></tr> 
<tr><td><code id="simTOcc_+3A_n.rep">n.rep</code></td>
<td>
<p>a numeric matrix indicating the number of replicates at each site during each primary time period. The matrix must have <code class="reqn">J = J.x \times J.y</code> rows and T columns, where T is the number of primary time periods (e.g., years or seasons) over which sampling occurs.</p>
</td></tr> 
<tr><td><code id="simTOcc_+3A_n.rep.max">n.rep.max</code></td>
<td>
<p>a single numeric value indicating the maximum number of replicate surveys. This is an optional argument, with its default value set to <code>max(n.rep)</code>. This can be used to generate data sets with different types of missingness (e.g., simulate data across 20 days (replicate surveys) but sites are only sampled a maximum of ten times each).</p>
</td></tr>
<tr><td><code id="simTOcc_+3A_beta">beta</code></td>
<td>
<p>a numeric vector containing the intercept and regression coefficient parameters for the occupancy portion of the single-species occupancy model. Note that if <code>trend = TRUE</code>, the second value in the vector corresponds to the estimated occurrence trend.</p>
</td></tr>
<tr><td><code id="simTOcc_+3A_alpha">alpha</code></td>
<td>
<p>a numeric vector containing the intercept and regression coefficient parameters for the detection portion of the single-species occupancy model.</p>
</td></tr>
<tr><td><code id="simTOcc_+3A_sp.only">sp.only</code></td>
<td>
<p>a numeric vector specifying which occurrence covariates should only vary over space and not over time. The numbers in the vector correspond to the elements in the vector of regression coefficients (<code>beta</code>). By default, all simulated occurrence covariates are assumed to vary over both space and time.</p>
</td></tr>
<tr><td><code id="simTOcc_+3A_trend">trend</code></td>
<td>
<p>a logical value. If <code>TRUE</code>, a temporal trend will be used to simulate the detection-nondetection data and the second element of <code>beta</code> is assumed to be the trend parameter. If <code>FALSE</code> no trend is used to simulate the data and all elements of <code>beta</code> (except the first value which is the intercept) correspond to covariate effects.</p>
</td></tr>
<tr><td><code id="simTOcc_+3A_psi.re">psi.RE</code></td>
<td>
<p>a list used to specify the unstructured random intercepts included in the occupancy portion of the model. The list must have two tags: <code>levels</code> and <code>sigma.sq.psi</code>. <code>levels</code> is a vector of length equal to the number of distinct random intercepts to include in the model and contains the number of levels there are in each intercept. <code>sigma.sq.psi</code> is a vector of length equal to the number of distinct random intercepts to include in the model and contains the variances for each random effect. An additional tag <code>site.RE</code> can be set to <code>TRUE</code> to simulate data with a site-specific non-spatial random effect on occurrence. If not specified, no random effects are included in the occupancy portion of the model.</p>
</td></tr>
<tr><td><code id="simTOcc_+3A_p.re">p.RE</code></td>
<td>
<p>a list used to specify the unstructured random intercepts included in the detection portion of the model. The list must have two tags: <code>levels</code> and <code>sigma.sq.p</code>. <code>levels</code> is a vector of length equal to the number of distinct random intercepts to include in the model and contains the number of levels there are in each intercept. <code>sigma.sq.p</code> is a vector of length equal to the number of distinct random intercepts to include in the model and contains the variances for each random effect. If not specified, no random effects are included in the detection portion of the model.</p>
</td></tr>
<tr><td><code id="simTOcc_+3A_sp">sp</code></td>
<td>
<p>a logical value indicating whether to simulate a spatially-explicit occupancy model with a Gaussian process. By default set to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="simTOcc_+3A_svc.cols">svc.cols</code></td>
<td>
<p>a vector indicating the variables whose effects will be
estimated as spatially-varying coefficients. <code>svc.cols</code> is an
integer vector with values indicating the order of covariates specified
in the model formula (with 1 being the intercept if specified).</p>
</td></tr>
<tr><td><code id="simTOcc_+3A_cov.model">cov.model</code></td>
<td>
<p>a quoted keyword that specifies the covariance function used to model the spatial dependence structure among the latent occurrence values.  Supported covariance model key words are: <code>"exponential"</code>, <code>"matern"</code>, <code>"spherical"</code>, and <code>"gaussian"</code>.</p>
</td></tr>
<tr><td><code id="simTOcc_+3A_sigma.sq">sigma.sq</code></td>
<td>
<p>a numeric value indicating the spatial variance parameter. Ignored when <code>sp = FALSE</code>.</p>
</td></tr>
<tr><td><code id="simTOcc_+3A_phi">phi</code></td>
<td>
<p>a numeric value indicating the spatial decay parameter. Ignored when <code>sp = FALSE</code>. </p>
</td></tr>
<tr><td><code id="simTOcc_+3A_nu">nu</code></td>
<td>
<p>a numeric value indicating the spatial smoothness parameter. Only used when <code>sp = TRUE</code> and <code>cov.model = "matern"</code>.</p>
</td></tr> 
<tr><td><code id="simTOcc_+3A_ar1">ar1</code></td>
<td>
<p>a logical value indicating whether to simulate a temporal random effect with an AR(1) process. By default, set to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="simTOcc_+3A_rho">rho</code></td>
<td>
<p>a numeric value indicating the AR(1) temporal correlation parameter. Ignored when <code>ar1 = FALSE</code>.</p>
</td></tr>
<tr><td><code id="simTOcc_+3A_sigma.sq.t">sigma.sq.t</code></td>
<td>
<p>a numeric value indicating the AR(1) temporal variance parameter. Ignored when <code>ar1 = FALSE</code>.</p>
</td></tr>
<tr><td><code id="simTOcc_+3A_x.positive">x.positive</code></td>
<td>
<p>a logical value indicating whether the simulated covariates should be simulated as random standard normal covariates (<code>x.positive = FALSE</code>) or restricted to positive values (<code>x.positive = TRUE</code>). If <code>x.positive = TRUE</code>, covariates are simulated from a random normal and then the minimum value is added to each covariate value to ensure non-negative covariate values.</p>
</td></tr>
<tr><td><code id="simTOcc_+3A_mis.spec.type">mis.spec.type</code></td>
<td>
<p>a quoted keyword indicating the type of model mis-specification to use when simulating the data. These correspond to model mis-specification of the functional relationship between occupancy/detection probability and covariates. Valid keywords are: <code>"none"</code> (no model mis-specification, i.e., logit link), <code>"scale"</code> (scaled logistic link), <code>"line"</code> (linear link), and <code>"probit"</code> (probit link). Defaults to <code>"none"</code>.</p>
</td></tr>
<tr><td><code id="simTOcc_+3A_scale.param">scale.param</code></td>
<td>
<p>a positive number between 0 and 1 that indicates the scale parameter for the occupancy portion of the model when <code>mis.spec.type = 'scale'</code>. When specified, <code>scale.param</code> corresponds to the scale parameter for the occupancy portion of the model, while the reciprocal of <code>scale.param</code> is used for the detection portion of the model.</p>
</td></tr>
<tr><td><code id="simTOcc_+3A_avail">avail</code></td>
<td>
<p>a site x primary time period x visit array indicating the availability probability of the species during each survey simulated at the given site/primary time period/visit combination. This can be used to assess impacts of non-constant availability across replicate surveys in simulation studies. Values should fall between 0 and 1. When not specified, availability is set to 1 for all surveys.</p>
</td></tr>
<tr><td><code id="simTOcc_+3A_grid">grid</code></td>
<td>
<p>an atomic vector used to specify the grid across which to simulate the latent spatial processes. This argument is used to simulate the underlying spatial processes at a different resolution than the coordinates (e.g., if coordinates are distributed across a grid).</p>
</td></tr>
<tr><td><code id="simTOcc_+3A_...">...</code></td>
<td>
<p>currently no additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list comprised of: 
</p>
<table>
<tr><td><code>X</code></td>
<td>
<p>a <code class="reqn">J \times T \times p.occ</code> numeric array containing the design matrix for the occurrence portion of the occupancy model.</p>
</td></tr>
<tr><td><code>X.p</code></td>
<td>
<p>a four-dimensional numeric array with dimensions corresponding to sites, primary time periods, repeat visits, and number of detection regression coefficients. This is the design matrix used for the detection portion of the occupancy model.</p>
</td></tr>
<tr><td><code>coords</code></td>
<td>
<p>a <code class="reqn">J \times 2</code> numeric matrix of coordinates of each occupancy site. Required for spatial models.</p>
</td></tr>
<tr><td><code>w</code></td>
<td>
<p>a <code class="reqn">J \times 1</code> matrix of the spatial random effects. Only used to simulate data when <code>sp = TRUE</code>.</p>
</td></tr>
<tr><td><code>psi</code></td>
<td>
<p>a <code class="reqn">J \times T</code> matrix of the occupancy probabilities for each site during each primary time period.</p>
</td></tr>
<tr><td><code>z</code></td>
<td>
<p>a  <code class="reqn">J \times T</code> matrix of the latent occupancy states at each site during each primary time period.</p>
</td></tr>
<tr><td><code>p</code></td>
<td>
<p>a <code>J x T x max(n.rep)</code> array of the detection probabilities for each site, primary time period, and replicate combination. Site/time periods with fewer than <code>max(n.rep)</code> replicates will contain <code>NA</code> values.</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>a <code>J x T x max(n.rep)</code> array of the raw detection-nondetection data for each sit, primary time period, and replicate combination.</p>
</td></tr>
<tr><td><code>X.p.re</code></td>
<td>
<p>a four-dimensional numeric array containing the levels of any detection random effect included in the model. Only relevant when detection random effects are specified in <code>p.RE</code>.</p>
</td></tr>
<tr><td><code>X.re</code></td>
<td>
<p>a numeric matrix containing the levels of any occurrence random effect included in the model. Only relevant when occurrence random effects are specified in <code>psi.RE</code>.</p>
</td></tr>
<tr><td><code>alpha.star</code></td>
<td>
<p>a numeric vector that contains the simulated detection random effects for each given level of the random effects included in the detection model. Only relevant when detection random effects are included in the model.</p>
</td></tr>
<tr><td><code>beta.star</code></td>
<td>
<p>a numeric vector that contains the simulated occurrence random effects for each given level of the random effects included in the occurrence model. Only relevant when occurrence random effects are included in the model.</p>
</td></tr>
<tr><td><code>eta</code></td>
<td>
<p>a <code class="reqn">T \times 1</code> matrix of the latent AR(1) random effects. Only included when <code>ar1 = TRUE</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jeffrey W. Doser <a href="mailto:doserjef@msu.edu">doserjef@msu.edu</a>, <br />
</p>


<h3>References</h3>

<p>Stoudt, S., P. de Valpine, and W. Fithian. Non-parametric identifiability in species distribution and abundance models: why it matters and how to diagnose a lack of fit using simulation. Journal of Statistical Theory and Practice 17, 39 (2023). https://doi.org/10.1007/s42519-023-00336-5.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>J.x &lt;- 10
J.y &lt;- 10
J &lt;- J.x * J.y
# Number of time periods sampled
n.time &lt;- sample(10, J, replace = TRUE)
n.time.max &lt;- max(n.time)
# Replicates
n.rep &lt;- matrix(NA, J, max(n.time))
for (j in 1:J) {
  n.rep[j, 1:n.time[j]] &lt;- sample(1:4, n.time[j], replace = TRUE)
}
# Occurrence --------------------------
# Fixed
beta &lt;- c(0.4, 0.5, -0.9)
trend &lt;- TRUE 
sp.only &lt;- 0
psi.RE &lt;- list(levels = c(10), 
               sigma.sq.psi = c(1))
# Detection ---------------------------
alpha &lt;- c(-1, 0.7, -0.5)
p.RE &lt;- list(levels = c(10), 
             sigma.sq.p = c(0.5))
# Spatial parameters ------------------
sp &lt;- TRUE
cov.model &lt;- "exponential"
sigma.sq &lt;- 2
phi &lt;- 3 / .4
nu &lt;- 1
# Temporal parameters -----------------
ar1 &lt;- TRUE
rho &lt;- 0.5
sigma.sq.t &lt;- 0.8
# Get all the data
dat &lt;- simTOcc(J.x = J.x, J.y = J.y, n.time = n.time, n.rep = n.rep, 
               beta = beta, alpha = alpha, sp.only = sp.only, trend = trend, 
               psi.RE = psi.RE, p.RE = p.RE, 
               sp = sp, cov.model = cov.model, sigma.sq = sigma.sq, phi = phi, 
               ar1 = ar1, rho = rho, sigma.sq.t = sigma.sq.t)
str(dat)
</code></pre>

<hr>
<h2 id='spIntPGOcc'>Function for Fitting Single-Species Integrated Spatial Occupancy Models Using Polya-Gamma Latent Variables</h2><span id='topic+spIntPGOcc'></span>

<h3>Description</h3>

<p>The function <code>spIntPGOcc</code> fits single-species integrated spatial occupancy models using Polya-Gamma latent variables. Models can be fit using either a full Gaussian process or a Nearest Neighbor Gaussian Process for large data sets. Data integration is done using a joint likelihood framework, assuming distinct detection models for each data source that are each conditional on a single latent occupancy process. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spIntPGOcc(occ.formula, det.formula, data, inits, priors, 
           tuning, cov.model = "exponential", NNGP = TRUE, 
           n.neighbors = 15, search.type = 'cb', n.batch, 
           batch.length, accept.rate = 0.43, n.omp.threads = 1, 
           verbose = TRUE, n.report = 100, 
           n.burn = round(.10 * n.batch * batch.length), 
           n.thin = 1, n.chains = 1, k.fold, k.fold.threads = 1, 
           k.fold.seed, k.fold.data, k.fold.only = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spIntPGOcc_+3A_occ.formula">occ.formula</code></td>
<td>
<p>a symbolic description of the model to be fit
for the occurrence portion of the model using R's model syntax. Only
right-hand side of formula is specified. See example below.</p>
</td></tr>
<tr><td><code id="spIntPGOcc_+3A_det.formula">det.formula</code></td>
<td>
<p>a list of symbolic descriptions of the models to be fit
for the detection portion of the model using R's model syntax for 
each data set. Each element in the list is a formula for the detection 
model of a given data set. Only right-hand side of formula is specified. 
See example below.</p>
</td></tr>
<tr><td><code id="spIntPGOcc_+3A_data">data</code></td>
<td>
<p>a list containing data necessary for model fitting.
Valid tags are <code>y</code>, <code>occ.covs</code>, <code>det.covs</code>, <code>sites</code> and <code>coords</code>. 
<code>y</code> is a list of matrices or data frames for each data set used in 
the integrated model. Each element of the list has first dimension equal 
to the number of sites with that data source and second dimension equal 
to the maximum number of replicates at a given site. <code>occ.covs</code> is 
a matrix or data frame containing the variables used in the occurrence 
portion of the model, with the number of rows being the number of sites 
with at least one data source for each column (variable). <code>det.covs</code> is a list of
variables included in the detection portion of the model for each data source. 
<code>det.covs</code> should have the same number of elements as <code>y</code>, where
each element is itself a list. Each element of the list for a given data
source is a different detection covariate, which can be site-level or 
observational-level. Site-level covariates are specified as a vector 
with length equal to the number of observed sites of that data source,
while observation-level covariates are specified as a matrix or data frame 
with the number of rows equal to the number of observed sites of that data source
and number of columns equal to the maximum number of replicates at a given site. 
<code>coords</code> is a matrix of the observation site coordinates. Note that <code>spOccupancy</code> assumes coordinates are specified 
in a projected coordinate system.</p>
</td></tr>
<tr><td><code id="spIntPGOcc_+3A_inits">inits</code></td>
<td>
<p>a list with each tag corresponding to a parameter name.
Valid tags are <code>z</code>, <code>beta</code>, <code>alpha</code>, <code>sigma.sq</code>, <code>phi</code>, 
<code>w</code>, and <code>nu</code>. The value portion of all tags except <code>alpha</code> 
is the parameter's initial value. The tag <code>alpha</code> is a list comprised 
of the initial values for the detection parameters for each data source. 
Each element of the list should be a vector of initial values for all detection 
parameters in the given data source or a single value for each data source to 
assign all parameters for a given data source the same initial value. See 
<code>priors</code> description for definition of each parameter name.
Additionally, the tag <code>fix</code> can be set to <code>TRUE</code> 
to fix the starting values across all chains. If <code>fix</code> is not specified
(the default), starting values are varied randomly across chains.</p>
</td></tr>
<tr><td><code id="spIntPGOcc_+3A_priors">priors</code></td>
<td>
<p>a list with each tag corresponding to a parameter name. 
Valid tags are <code>beta.normal</code>, <code>alpha.normal</code>, <code>phi.unif</code>, 
<code>sigma.sq.ig</code>, <code>sigma.sq.unif</code>, and <code>nu.unif</code>. 
Occurrence (<code>beta</code>) and detection 
(<code>alpha</code>) regression coefficients are assumed to follow a normal 
distribution. For <code>beta</code> hyperparameters of the normal distribution 
are passed as a list of length two with the first and second elements 
corresponding to the mean and variance of the normal distribution, which are 
each specified as vectors of length equal to the number of coefficients 
to be estimated or of length one if priors are the same for all coefficients. 
For the detection coefficients <code>alpha</code>, the mean 
and variance hyperparameters are themselves passed in as lists, with each 
element of the list corresponding to the specific hyperparameters for the 
detection parameters in a given data source. If not specified, prior means 
are set to 0 and prior variances set to 2.73 for normal priors. The 
spatial variance parameter, <code>sigma.sq</code>, is assumed to follow an 
inverse-Gamma distribution or a uniform distribution (default is 
inverse-Gamma). <code>sigma.sq</code> can also be fixed at its 
initial value by setting the prior value to 
<code>"fixed"</code>. The spatial decay <code>phi</code> and 
smoothness <code>nu</code> parameters are assumed to follow Uniform 
distributions. The hyperparameters of the inverse-Gamma are passed as 
a vector of length two, with the first and second elements corresponding
to the <em>shape</em> and <em>scale</em>, respectively. The hyperparameters
of the Uniform are also passed as a vector of length two with the first 
and second elements corresponding to the lower and upper support, 
respectively.</p>
</td></tr>
<tr><td><code id="spIntPGOcc_+3A_tuning">tuning</code></td>
<td>
<p>a list with each tag corresponding to a parameter
name. Valid tags are <code>phi</code> and <code>nu</code>. The value portion of each
tag defines the initial variance of the Adaptive sampler. See
Roberts and Rosenthal (2009) for details.</p>
</td></tr>
<tr><td><code id="spIntPGOcc_+3A_cov.model">cov.model</code></td>
<td>
<p>a quoted keyword that specifies the covariance
function used to model the spatial dependence structure among the
observations.  Supported covariance model key words are:
<code>"exponential"</code>, <code>"matern"</code>, <code>"spherical"</code>, and
<code>"gaussian"</code>.</p>
</td></tr>
<tr><td><code id="spIntPGOcc_+3A_nngp">NNGP</code></td>
<td>
<p>if <code>TRUE</code>, model is fit with an NNGP. If <code>FALSE</code>, 
a full Gaussian process is used. See Datta et al. (2016) and 
Finley et al. (2019) for more information.</p>
</td></tr>
<tr><td><code id="spIntPGOcc_+3A_n.neighbors">n.neighbors</code></td>
<td>
<p>number of neighbors used in the NNGP. Only used if 
<code>NNGP = TRUE</code>. Datta et al. (2016) showed that 15 neighbors is usually 
sufficient, but that as few as 5 neighbors can be adequate for certain data
sets, which can lead to even greater decreases in run time. We recommend
starting with 15 neighbors (the default) and if additional gains in computation
time are desired, subsequently compare the results with a smaller number
of neighbors using WAIC or k-fold cross-validation.</p>
</td></tr>
<tr><td><code id="spIntPGOcc_+3A_search.type">search.type</code></td>
<td>
<p>a quoted keyword that specifies the type of nearest
neighbor search algorithm. Supported method key words are: <code>"cb"</code> and
<code>"brute"</code>. The <code>"cb"</code> should generally be much
faster. If locations do not have identical coordinate values on
the axis used for the nearest neighbor ordering then <code>"cb"</code> 
and <code>"brute"</code> should produce identical neighbor sets. 
However, if there are identical coordinate values on the axis used 
for nearest neighbor ordering, then <code>"cb"</code> and <code>"brute"</code> 
might produce different, but equally valid, neighbor sets, 
e.g., if data are on a grid. </p>
</td></tr>
<tr><td><code id="spIntPGOcc_+3A_n.batch">n.batch</code></td>
<td>
<p>the number of MCMC batches to run for each chain for the Adaptive MCMC 
sampler. See Roberts and Rosenthal (2009) for details.</p>
</td></tr>
<tr><td><code id="spIntPGOcc_+3A_batch.length">batch.length</code></td>
<td>
<p>the length of each MCMC batch to run for the Adaptive 
MCMC sampler. See Roberts and Rosenthal (2009) for details.</p>
</td></tr>
<tr><td><code id="spIntPGOcc_+3A_accept.rate">accept.rate</code></td>
<td>
<p>target acceptance rate for Adaptive MCMC. Default is 
0.43. See Roberts and Rosenthal (2009) for details.</p>
</td></tr>
<tr><td><code id="spIntPGOcc_+3A_n.omp.threads">n.omp.threads</code></td>
<td>
<p>a positive integer indicating
the number of threads to use for SMP parallel processing. The package must
be compiled for OpenMP support. For most Intel-based machines, we
recommend setting <code>n.omp.threads</code> up to the number of
hyperthreaded cores. Note, <code>n.omp.threads</code> &gt; 1 might not
work on some systems.</p>
</td></tr>
<tr><td><code id="spIntPGOcc_+3A_verbose">verbose</code></td>
<td>
<p>if <code>TRUE</code>, messages about data preparation, 
model specification, and progress of the sampler are printed to the screen. 
Otherwise, no messages are printed.</p>
</td></tr>
<tr><td><code id="spIntPGOcc_+3A_n.report">n.report</code></td>
<td>
<p>the interval to report Metropolis sampler acceptance and
MCMC progress. Note this is specified in terms of batches and not overall
samples for spatial models.</p>
</td></tr>
<tr><td><code id="spIntPGOcc_+3A_n.burn">n.burn</code></td>
<td>
<p>the number of samples out of the total <code>n.batch * batch.length</code> 
samples to discard as burn-in. By default, the first 10% of samples is discarded.</p>
</td></tr>
<tr><td><code id="spIntPGOcc_+3A_n.thin">n.thin</code></td>
<td>
<p>the thinning interval for collection of MCMC samples. The
thinning occurs after the <code>n.burn</code> samples are discarded. Default 
value is set to 1.</p>
</td></tr>
<tr><td><code id="spIntPGOcc_+3A_n.chains">n.chains</code></td>
<td>
<p>the number of chains to run in sequence.</p>
</td></tr>
<tr><td><code id="spIntPGOcc_+3A_k.fold">k.fold</code></td>
<td>
<p>specifies the number of <em>k</em> folds for cross-validation.
If not specified as an argument, then cross-validation is not performed
and <code>k.fold.threads</code> and <code>k.fold.seed</code> are ignored. In <em>k</em>-fold
cross-validation, the data specified in <code>data</code> is randomly
partitioned into <em>k</em> equal sized subsamples. Of the <em>k</em> subsamples,
<em>k</em> - 1 subsamples are used to fit the model and the remaining <em>k</em>
samples are used for prediction. The cross-validation process is repeated
<em>k</em> times (the folds). As a scoring rule, we use the model deviance
as described in Hooten and Hobbs (2015). Cross-validation is performed
after the full model is fit using all the data. Cross-validation results
are reported in the <code>k.fold.deviance</code> object in the return list.</p>
</td></tr>
<tr><td><code id="spIntPGOcc_+3A_k.fold.threads">k.fold.threads</code></td>
<td>
<p>number of threads to use for cross-validation. If
<code>k.fold.threads &gt; 1</code> parallel processing is accomplished using the
<span class="pkg">foreach</span> and <span class="pkg">doParallel</span> packages. Ignored if <code>k.fold</code>
is not specified.</p>
</td></tr>
<tr><td><code id="spIntPGOcc_+3A_k.fold.seed">k.fold.seed</code></td>
<td>
<p>seed used to split data set into <code>k.fold</code> parts
for k-fold cross-validation. Ignored if <code>k.fold</code> is not specified.</p>
</td></tr>
<tr><td><code id="spIntPGOcc_+3A_k.fold.data">k.fold.data</code></td>
<td>
<p>an integer specifying the specific data set to hold out
values from. If not specified, data from all data set locations will 
be incorporated into the k-fold cross-validation.</p>
</td></tr>
<tr><td><code id="spIntPGOcc_+3A_k.fold.only">k.fold.only</code></td>
<td>
<p>a logical value indicating whether to only perform 
cross-validation (<code>TRUE</code>) or perform cross-validation after fitting 
the full model (<code>FALSE</code>). Default value is <code>FALSE</code>.</p>
</td></tr> 
<tr><td><code id="spIntPGOcc_+3A_...">...</code></td>
<td>
<p>currently no additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>spIntPGOcc</code> that is a list comprised of: 
</p>
<table>
<tr><td><code>beta.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the occurrence regression coefficients.</p>
</td></tr>
<tr><td><code>alpha.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the detection regression coefficients for all data sources.</p>
</td></tr>
<tr><td><code>z.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples 
for the latent occurrence values</p>
</td></tr>
<tr><td><code>psi.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the latent occurrence probability values</p>
</td></tr>
<tr><td><code>theta.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for covariance parameters.</p>
</td></tr>
<tr><td><code>w.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for latent spatial random effects.</p>
</td></tr>
<tr><td><code>rhat</code></td>
<td>
<p>a list of Gelman-Rubin diagnostic values for some of the model
parameters.</p>
</td></tr>
<tr><td><code>ESS</code></td>
<td>
<p>a list of effective sample sizes for some of the model parameters.</p>
</td></tr>
<tr><td><code>run.time</code></td>
<td>
<p>execution time reported using <code>proc.time()</code>.</p>
</td></tr>
<tr><td><code>k.fold.deviance</code></td>
<td>
<p>scoring rule (deviance) from k-fold cross-validation. A 
separate deviance value is returned for each data source. Only included if 
<code>k.fold</code> is specified in function call. Only a single value is returned
if <code>k.fold.data</code> is specified.</p>
</td></tr>
</table>
<p>The return object will include additional objects used for 
subsequent prediction and/or model fit evaluation. Note that detection
probability estimated values are not included in the model object, but can be 
extracted using <code>fitted()</code>.
</p>


<h3>Note</h3>

<p>Some of the underlying code used for generating random numbers from the
Polya-Gamma distribution is taken from the <span class="pkg">pgdraw</span> package written
by Daniel F. Schmidt and Enes Makalic. Their code implements Algorithm
6 in PhD thesis of Jesse Bennett Windle (2013) <a href="https://repositories.lib.utexas.edu/handle/2152/21842">https://repositories.lib.utexas.edu/handle/2152/21842</a>.
</p>


<h3>Author(s)</h3>

<p>Jeffrey W. Doser <a href="mailto:doserjef@msu.edu">doserjef@msu.edu</a>, <br />
Andrew O. Finley <a href="mailto:finleya@msu.edu">finleya@msu.edu</a>
</p>


<h3>References</h3>

<p>Datta, A., S. Banerjee, A.O. Finley, and A.E. Gelfand. (2016)
Hierarchical Nearest-Neighbor Gaussian process models for large
geostatistical datasets. <em>Journal of the American Statistical
Association</em>, <a href="https://doi.org/10.1080/01621459.2015.1044091">doi:10.1080/01621459.2015.1044091</a>.
</p>
<p>Finley, A.O., A. Datta, B.D. Cook, D.C. Morton, H.E. Andersen, and
S. Banerjee. (2019) Efficient algorithms for Bayesian Nearest Neighbor
Gaussian Processes. <em>Journal of Computational and Graphical
Statistics</em>, <a href="https://doi.org/10.1080/10618600.2018.1537924">doi:10.1080/10618600.2018.1537924</a>.
</p>
<p>Finley, A. O., Datta, A., and Banerjee, S. (2020). spNNGP R package 
for nearest neighbor Gaussian process models. <em>arXiv</em> preprint arXiv:2001.09111.
</p>
<p>Hooten, M. B., and Hobbs, N. T. (2015). A guide to Bayesian model 
selection for ecologists. <em>Ecological Monographs</em>, 85(1), 3-28.
</p>
<p>Hooten, M. B., and Hefley, T. J. (2019). Bringing Bayesian models to life. 
<em>CRC Press</em>.
</p>
<p>Polson, N.G., J.G. Scott, and J. Windle. (2013) Bayesian Inference for
Logistic Models Using Polya-Gamma Latent Variables.
<em>Journal of the American Statistical Association</em>, 108:1339-1349.
</p>
<p>Roberts, G.O. and Rosenthal J.S. (2009) Examples  of adaptive MCMC. 
<em>Journal of Computational and Graphical Statistics</em>, 18(2):349-367.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(400)

# Simulate Data -----------------------------------------------------------
# Number of locations in each direction. This is the total region of interest
# where some sites may or may not have a data source. 
J.x &lt;- 8
J.y &lt;- 8
J.all &lt;- J.x * J.y
# Number of data sources.
n.data &lt;- 4
# Sites for each data source. 
J.obs &lt;- sample(ceiling(0.2 * J.all):ceiling(0.5 * J.all), n.data, replace = TRUE)
# Replicates for each data source.
n.rep &lt;- list()
for (i in 1:n.data) {
  n.rep[[i]] &lt;- sample(1:4, size = J.obs[i], replace = TRUE)
}
# Occupancy covariates
beta &lt;- c(0.5, 0.5)
p.occ &lt;- length(beta)
# Detection covariates
alpha &lt;- list()
alpha[[1]] &lt;- runif(2, 0, 1)
alpha[[2]] &lt;- runif(3, 0, 1)
alpha[[3]] &lt;- runif(2, -1, 1)
alpha[[4]] &lt;- runif(4, -1, 1)
p.det.long &lt;- sapply(alpha, length)
p.det &lt;- sum(p.det.long)
sigma.sq &lt;- 2
phi &lt;- 3 / .5
sp &lt;- TRUE

# Simulate occupancy data from multiple data sources. 
dat &lt;- simIntOcc(n.data = n.data, J.x = J.x, J.y = J.y, J.obs = J.obs, 
                 n.rep = n.rep, beta = beta, alpha = alpha, sp = sp, 
                 sigma.sq = sigma.sq, phi = phi, cov.model = 'exponential')

y &lt;- dat$y
X &lt;- dat$X.obs
X.p &lt;- dat$X.p
sites &lt;- dat$sites
X.0 &lt;- dat$X.pred
psi.0 &lt;- dat$psi.pred
coords &lt;- as.matrix(dat$coords.obs)
coords.0 &lt;- as.matrix(dat$coords.pred)

# Package all data into a list
occ.covs &lt;- X[, 2, drop = FALSE]
colnames(occ.covs) &lt;- c('occ.cov')
det.covs &lt;- list()
# Add covariates one by one
det.covs[[1]] &lt;- list(det.cov.1.1 = X.p[[1]][, , 2])
det.covs[[2]] &lt;- list(det.cov.2.1 = X.p[[2]][, , 2], 
                      det.cov.2.2 = X.p[[2]][, , 3])
det.covs[[3]] &lt;- list(det.cov.3.1 = X.p[[3]][, , 2])
det.covs[[4]] &lt;- list(det.cov.4.1 = X.p[[4]][, , 2], 
                      det.cov.4.2 = X.p[[4]][, , 3], 
                      det.cov.4.3 = X.p[[4]][, , 4])
data.list &lt;- list(y = y, 
                  occ.covs = occ.covs,
                  det.covs = det.covs, 
                  sites = sites, 
                  coords = coords)

J &lt;- length(dat$z.obs)

# Initial values
inits.list &lt;- list(alpha = list(0, 0, 0, 0), 
                   beta = 0, 
                   phi = 3 / .5, 
                   sigma.sq = 2, 
                   w = rep(0, J), 
                   z = rep(1, J))
# Priors
prior.list &lt;- list(beta.normal = list(mean = 0, var = 2.72), 
                   alpha.normal = list(mean = list(0, 0, 0, 0), 
                                       var = list(2.72, 2.72, 2.72, 2.72)),
                   phi.unif = c(3/1, 3/.1), 
                   sigma.sq.ig = c(2, 2))
# Tuning
tuning.list &lt;- list(phi = 0.3) 

# Number of batches
n.batch &lt;- 2
# Batch length
batch.length &lt;- 25

out &lt;- spIntPGOcc(occ.formula = ~ occ.cov, 
                  det.formula = list(f.1 = ~ det.cov.1.1, 
                                     f.2 = ~ det.cov.2.1 + det.cov.2.2, 
                                     f.3 = ~ det.cov.3.1, 
                                     f.4 = ~ det.cov.4.1 + det.cov.4.2 + det.cov.4.3), 
                  data = data.list,  
                  inits = inits.list, 
                  n.batch = n.batch, 
                  batch.length = batch.length, 
                  accept.rate = 0.43, 
                  priors = prior.list, 
                  cov.model = "exponential", 
                  tuning = tuning.list, 
                  n.omp.threads = 1, 
                  verbose = TRUE, 
                  NNGP = FALSE, 
                  n.report = 10, 
                  n.burn = 10, 
                  n.thin = 1)

summary(out)
</code></pre>

<hr>
<h2 id='spMsPGOcc'>Function for Fitting Multi-Species Spatial Occupancy Models Using Polya-Gamma Latent Variables</h2><span id='topic+spMsPGOcc'></span>

<h3>Description</h3>

<p>The function <code>spMsPGOcc</code> fits multi-species spatial occupancy models using Polya-Gamma latent variables. Models can be fit using either a full Gaussian process or a Nearest Neighbor Gaussian Process for large data sets. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spMsPGOcc(occ.formula, det.formula, data, inits, priors, tuning, 
          cov.model = 'exponential', NNGP = TRUE, 
          n.neighbors = 15, search.type = 'cb', n.batch, 
          batch.length, accept.rate = 0.43, n.omp.threads = 1, 
          verbose = TRUE, n.report = 100, 
          n.burn = round(.10 * n.batch * batch.length), n.thin = 1, 
          n.chains = 1, k.fold, k.fold.threads = 1, k.fold.seed, 
          k.fold.only = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spMsPGOcc_+3A_occ.formula">occ.formula</code></td>
<td>
<p>a symbolic description of the model to be fit
for the occurrence portion of the model using R's model syntax. Only
right-hand side of formula is specified. See example below. Random 
intercepts are allowed using lme4 syntax (Bates et al. 2015).</p>
</td></tr>
<tr><td><code id="spMsPGOcc_+3A_det.formula">det.formula</code></td>
<td>
<p>a symbolic description of the model to be fit
for the detection portion of the model using R's model syntax. Only
right-hand side of formula is specified. See example below. Random 
intercepts are allowed using lme4 syntax (Bates et al. 2015).</p>
</td></tr>
<tr><td><code id="spMsPGOcc_+3A_data">data</code></td>
<td>
<p>a list containing data necessary for model fitting.
Valid tags are <code>y</code>, <code>occ.covs</code>, <code>det.covs</code>, <code>coords</code>. 
<code>y</code> is a three-dimensional array with first dimension equal to the 
number of species, second dimension equal to the number of sites, and 
third dimension equal to the maximum number of replicates at a given site. 
<code>occ.covs</code> is a matrix or data frame containing the variables 
used in the occurrence portion of the model, with <code class="reqn">J</code> rows for 
each column (variable). <code>det.covs</code> is a list of variables included 
in the detection portion of the model. Each list element is a different 
detection covariate, which can be site-level or observational-level. 
Site-level covariates are specified as a vector of length <code class="reqn">J</code> while 
observation-level covariates are specified as a matrix or data frame 
with the number of rows equal to <code class="reqn">J</code> and number of columns equal 
to the maximum number of replicates at a given site. <code>coords</code> is a 
<code class="reqn">J \times 2</code> matrix of the observation coordinates. 
Note that <code>spOccupancy</code> assumes coordinates are specified 
in a projected coordinate system.</p>
</td></tr>
<tr><td><code id="spMsPGOcc_+3A_inits">inits</code></td>
<td>
<p>a list with each tag corresponding to a parameter name.
Valid tags are <code>alpha.comm</code>, <code>beta.comm</code>, <code>beta</code>, 
<code>alpha</code>, <code>tau.sq.beta</code>, <code>tau.sq.alpha</code>, <code>sigma.sq.psi</code>, 
<code>sigma.sq.p</code>, <code>z</code>, <code>sigma.sq</code>, 
<code>phi</code>, <code>w</code>, and <code>nu</code>. <code>nu</code> is only specified if 
<code>cov.model = "matern"</code>, <code>sigma.sq.psi</code> is only specified if
there are random intercepts in <code>occ.formula</code>, and <code>sigma.sq.p</code> is
only specified if there are random intercpets in <code>det.formula</code>. The value portion of each tag is 
the parameter's initial value. See <code>priors</code> description for definition
of each parameter name. Additionally, the tag <code>fix</code> can be set to <code>TRUE</code> 
to fix the starting values across all chains. If <code>fix</code> is not specified
(the default), starting values are varied randomly across chains.</p>
</td></tr>
<tr><td><code id="spMsPGOcc_+3A_priors">priors</code></td>
<td>
<p>a list with each tag corresponding to a parameter name. 
Valid tags are <code>beta.comm.normal</code>, <code>alpha.comm.normal</code>, 
<code>tau.sq.beta.ig</code>, <code>tau.sq.alpha.ig</code>, <code>phi.unif</code>, <code>sigma.sq.ig</code>, 
<code>sigma.sq.unif</code>, <code>nu.unif</code>, <code>sigma.sq.psi</code>, <code>sigma.sq.p</code>. 
Community-level occurrence (<code>beta.comm</code>) and detection 
(<code>alpha.comm</code>) regression coefficients are assumed to follow a 
normal distribution. The hyperparameters of the normal distribution
are passed as a list of length two with the first and second elements 
corresponding to the mean and variance of the normal distribution, 
which are each specified as vectors of length equal to the number of 
coefficients to be estimated or of length one if priors are the same for 
all coefficients. If not specified, prior means are set 
to 0 and prior variances set to 2.73. Community-level variance parameters 
for occupancy (<code>tau.sq.beta</code>) and detection (<code>tau.sq.alpha</code>) are 
assumed to follow an inverse Gamma distribution. The hyperparameters of 
the inverse gamma distribution are passed as a list of length two with 
the first and second elements corresponding to the shape and scale parameters,
which are each specified as vectors of length equal to the number of 
coefficients to be estimated or a single value if priors are the same for all 
parameters. If not specified, prior shape and scale 
parameters are set to 0.1. The species-specific spatial variance parameter, 
<code>sigma.sq</code>, is assumed to follow an inverse-Gamma distribution or a uniform
distribution (default is inverse-Gamma). <code>sigma.sq</code> of all species
can also be fixed at its initial value by setting the prior value to <code>"fixed"</code>.
The spatial decay <code>phi</code> and smoothness <code>nu</code> parameters are assumed
to follow Uniform distributions. The hyperparameters of the inverse-Gamma are
passed as a list of length two, with the list elements being vectors of length 
N corresponding to the species-specific shape and scale parameters, respectively, 
or a single value if the same value is assigned for all species. 
The hyperparameters of the Uniform are also passed as a list with two elements, 
with both elements being vectors of length N corresponding to the lower and 
upper support, respectively, or as a single value if the same value is assigned
for all species. <code>sigma.sq.psi</code> and 
<code>sigma.sq.p</code> are the random effect variances for any occurrence or 
detection random effects, respectively, and are assumed to follow an inverse
Gamma distribution. The hyperparameters of the inverse-Gamma distribution
are passed as a list of length two with first and second elements corresponding
to the shape and scale parameters, respectively, which are each specified as
vectors of length equal to the number of random intercepts or of length one 
if priors are the same for all random effect variances.</p>
</td></tr>
<tr><td><code id="spMsPGOcc_+3A_tuning">tuning</code></td>
<td>
<p>a list with each tag corresponding to a parameter
name. Valid tags are <code>phi</code> and <code>nu</code>. The value portion of each
tag defines the initial variance of the adaptive sampler. We assume the 
initial variance of the adaptive sampler is the same for each species, 
although the adaptive sampler will adjust the tuning variances separately
for each species. See Roberts and Rosenthal (2009) for details.</p>
</td></tr>
<tr><td><code id="spMsPGOcc_+3A_cov.model">cov.model</code></td>
<td>
<p>a quoted keyword that specifies the covariance
function used to model the spatial dependence structure among the
observations.  Supported covariance model key words are:
<code>"exponential"</code>, <code>"matern"</code>, <code>"spherical"</code>, and
<code>"gaussian"</code>.</p>
</td></tr>
<tr><td><code id="spMsPGOcc_+3A_nngp">NNGP</code></td>
<td>
<p>if <code>TRUE</code>, model is fit with an NNGP. If <code>FALSE</code>, 
a full Gaussian process is used. See Datta et al. (2016) and 
Finley et al. (2019) for more information.</p>
</td></tr>
<tr><td><code id="spMsPGOcc_+3A_n.neighbors">n.neighbors</code></td>
<td>
<p>number of neighbors used in the NNGP. Only used if 
<code>NNGP = TRUE</code>. Datta et al. (2016) showed that 15 neighbors is usually 
sufficient, but that as few as 5 neighbors can be adequate for certain data
sets, which can lead to even greater decreases in run time. We recommend
starting with 15 neighbors (the default) and if additional gains in computation
time are desired, subsequently compare the results with a smaller number
of neighbors using WAIC or k-fold cross-validation.</p>
</td></tr>
<tr><td><code id="spMsPGOcc_+3A_search.type">search.type</code></td>
<td>
<p>a quoted keyword that specifies the type of nearest
neighbor search algorithm. Supported method key words are: <code>"cb"</code> and
<code>"brute"</code>. The <code>"cb"</code> should generally be much
faster. If locations do not have identical coordinate values on
the axis used for the nearest neighbor ordering then <code>"cb"</code> 
and <code>"brute"</code> should produce identical neighbor sets. 
However, if there are identical coordinate values on the axis used 
for nearest neighbor ordering, then <code>"cb"</code> and <code>"brute"</code> 
might produce different, but equally valid, neighbor sets, 
e.g., if data are on a grid. </p>
</td></tr>
<tr><td><code id="spMsPGOcc_+3A_n.batch">n.batch</code></td>
<td>
<p>the number of MCMC batches in each chain to run for the Adaptive MCMC 
sampler. See Roberts and Rosenthal (2009) for details.</p>
</td></tr>
<tr><td><code id="spMsPGOcc_+3A_batch.length">batch.length</code></td>
<td>
<p>the length of each MCMC batch to run for the Adaptive 
MCMC sampler. See Roberts and Rosenthal (2009) for details.</p>
</td></tr>
<tr><td><code id="spMsPGOcc_+3A_accept.rate">accept.rate</code></td>
<td>
<p>target acceptance rate for Adaptive MCMC. Defaul is 
0.43. See Roberts and Rosenthal (2009) for details.</p>
</td></tr>
<tr><td><code id="spMsPGOcc_+3A_n.omp.threads">n.omp.threads</code></td>
<td>
<p>a positive integer indicating
the number of threads to use for SMP parallel processing. The package must
be compiled for OpenMP support. For most Intel-based machines, we
recommend setting <code>n.omp.threads</code> up to the number of
hyperthreaded cores. Note, <code>n.omp.threads</code> &gt; 1 might not
work on some systems.</p>
</td></tr>
<tr><td><code id="spMsPGOcc_+3A_verbose">verbose</code></td>
<td>
<p>if <code>TRUE</code>, messages about data preparation, 
model specification, and progress of the sampler are printed to the screen. 
Otherwise, no messages are printed.</p>
</td></tr>
<tr><td><code id="spMsPGOcc_+3A_n.report">n.report</code></td>
<td>
<p>the interval to report Metropolis sampler acceptance and
MCMC progress. Note this is specified in terms of batches and not overall
samples for spatial models.</p>
</td></tr>
<tr><td><code id="spMsPGOcc_+3A_n.burn">n.burn</code></td>
<td>
<p>the number of samples out of the total <code>n.samples</code> to 
discard as burn-in for each chain. By default, the first 10% of samples is discarded.</p>
</td></tr>
<tr><td><code id="spMsPGOcc_+3A_n.thin">n.thin</code></td>
<td>
<p>the thinning interval for collection of MCMC samples. The
thinning occurs after the <code>n.burn</code> samples are discarded. Default 
value is set to 1.</p>
</td></tr>
<tr><td><code id="spMsPGOcc_+3A_n.chains">n.chains</code></td>
<td>
<p>the number of chains to run in sequence.</p>
</td></tr>
<tr><td><code id="spMsPGOcc_+3A_k.fold">k.fold</code></td>
<td>
<p>specifies the number of <em>k</em> folds for cross-validation. 
If not specified as an argument, then cross-validation is not performed
and <code>k.fold.threads</code> and <code>k.fold.seed</code> are ignored. In <em>k</em>-fold
cross-validation, the data specified in <code>data</code> is randomly
partitioned into <em>k</em> equal sized subsamples. Of the <em>k</em> subsamples, 
<em>k</em> - 1 subsamples are used to fit the model and the remaining <em>k</em>
samples are used for prediction. The cross-validation process is repeated 
<em>k</em> times (the folds). As a scoring rule, we use the model deviance 
as described in Hooten and Hobbs (2015). Cross-validation is performed
after the full model is fit using all the data. Cross-validation results
are reported in the <code>k.fold.deviance</code> object in the return list.</p>
</td></tr>
<tr><td><code id="spMsPGOcc_+3A_k.fold.threads">k.fold.threads</code></td>
<td>
<p>number of threads to use for cross-validation. If 
<code>k.fold.threads &gt; 1</code> parallel processing is accomplished using the 
<span class="pkg">foreach</span> and <span class="pkg">doParallel</span> packages. Ignored if <code>k.fold</code>
is not specified.</p>
</td></tr> 
<tr><td><code id="spMsPGOcc_+3A_k.fold.seed">k.fold.seed</code></td>
<td>
<p>seed used to split data set into <code>k.fold</code> parts
for k-fold cross-validation. Ignored if <code>k.fold</code> is not specified.</p>
</td></tr>
<tr><td><code id="spMsPGOcc_+3A_k.fold.only">k.fold.only</code></td>
<td>
<p>a logical value indicating whether to only perform 
cross-validation (<code>TRUE</code>) or perform cross-validation after fitting 
the full model (<code>FALSE</code>). Default value is <code>FALSE</code>.</p>
</td></tr> 
<tr><td><code id="spMsPGOcc_+3A_...">...</code></td>
<td>
<p>currently no additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>spMsPGOcc</code> that is a list comprised of: 
</p>
<table>
<tr><td><code>beta.comm.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the community level occurrence regression coefficients.</p>
</td></tr>
<tr><td><code>alpha.comm.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the community level detection regression coefficients.</p>
</td></tr>
<tr><td><code>tau.sq.beta.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the occurrence community variance parameters.</p>
</td></tr>
<tr><td><code>tau.sq.alpha.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the detection community variance parameters.</p>
</td></tr>
<tr><td><code>beta.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the species level occurrence regression coefficients.</p>
</td></tr>
<tr><td><code>alpha.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the species level detection regression coefficients.</p>
</td></tr>
<tr><td><code>theta.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the species level covariance parameters.</p>
</td></tr>
<tr><td><code>z.samples</code></td>
<td>
<p>a three-dimensional array of posterior samples for
the latent occurrence values for each species.</p>
</td></tr>
<tr><td><code>psi.samples</code></td>
<td>
<p>a three-dimensional array of posterior samples for
the latent occupancy probability values for each species.</p>
</td></tr>
<tr><td><code>w.samples</code></td>
<td>
<p>a three-dimensional array of posterior samples for 
the latent spatial random effects for each species.</p>
</td></tr>
<tr><td><code>sigma.sq.psi.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for variances of random intercepts included in the occurrence portion
of the model. Only included if random intercepts are specified in 
<code>occ.formula</code>.</p>
</td></tr>
<tr><td><code>sigma.sq.p.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for variances of random intercpets included in the detection portion 
of the model. Only included if random intercepts are specified in 
<code>det.formula</code>.</p>
</td></tr>
<tr><td><code>alpha.star.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the detection random effects. Only included if random intercepts 
are specified in <code>det.formula</code>.</p>
</td></tr>
<tr><td><code>beta.star.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the occurrence random effects. Only included if random intercepts
are specified in <code>occ.formula</code>.</p>
</td></tr>
<tr><td><code>like.samples</code></td>
<td>
<p>a three-dimensional array of posterior samples
for the likelihood value associated with each site and species. 
Used for calculating WAIC.</p>
</td></tr>
<tr><td><code>rhat</code></td>
<td>
<p>a list of Gelman-Rubin diagnostic values for some of the model
parameters.</p>
</td></tr>
<tr><td><code>ESS</code></td>
<td>
<p>a list of effective sample sizes for some of the model parameters.</p>
</td></tr>
<tr><td><code>run.time</code></td>
<td>
<p>MCMC sampler execution time reported using <code>proc.time()</code>.</p>
</td></tr>
<tr><td><code>k.fold.deviance</code></td>
<td>
<p>vector of scoring rules (deviance) from k-fold cross-validation. 
A separate value is reported for each species. 
Only included if <code>k.fold</code> is specified in function call.</p>
</td></tr>
</table>
<p>The return object will include additional objects used for 
subsequent prediction and/or model fit evaluation. Note that detection probability
estimated values are not included in the model object, but can be extracted using <code>fitted()</code>.
</p>


<h3>Note</h3>

<p>Some of the underlying code used for generating random numbers from the
Polya-Gamma distribution is taken from the <span class="pkg">pgdraw</span> package written
by Daniel F. Schmidt and Enes Makalic. Their code implements Algorithm
6 in PhD thesis of Jesse Bennett Windle (2013) <a href="https://repositories.lib.utexas.edu/handle/2152/21842">https://repositories.lib.utexas.edu/handle/2152/21842</a>.
</p>


<h3>Author(s)</h3>

<p>Jeffrey W. Doser <a href="mailto:doserjef@msu.edu">doserjef@msu.edu</a>, <br />
Andrew O. Finley <a href="mailto:finleya@msu.edu">finleya@msu.edu</a>
</p>


<h3>References</h3>

<p>Datta, A., S. Banerjee, A.O. Finley, and A.E. Gelfand. (2016)
Hierarchical Nearest-Neighbor Gaussian process models for large
geostatistical datasets. <em>Journal of the American Statistical
Association</em>, <a href="https://doi.org/10.1080/01621459.2015.1044091">doi:10.1080/01621459.2015.1044091</a>.
</p>
<p>Finley, A.O., A. Datta, B.D. Cook, D.C. Morton, H.E. Andersen, and
S. Banerjee. (2019) Efficient algorithms for Bayesian Nearest Neighbor
Gaussian Processes. <em>Journal of Computational and Graphical
Statistics</em>, <a href="https://doi.org/10.1080/10618600.2018.1537924">doi:10.1080/10618600.2018.1537924</a>.
</p>
<p>Finley, A. O., Datta, A., and Banerjee, S. (2020). spNNGP R package 
for nearest neighbor Gaussian process models. <em>arXiv</em> preprint arXiv:2001.09111.
</p>
<p>Polson, N.G., J.G. Scott, and J. Windle. (2013) Bayesian Inference for
Logistic Models Using Polya-Gamma Latent Variables.
<em>Journal of the American Statistical Association</em>, 108:1339-1349.
</p>
<p>Roberts, G.O. and Rosenthal J.S. (2009) Examples  of adaptive MCMC.
<em>Journal of Computational and Graphical Statistics</em>, 18(2):349-367.
</p>
<p>Bates, Douglas, Martin Maechler, Ben Bolker, Steve Walker (2015).
Fitting Linear Mixed-Effects Models Using lme4. Journal of
Statistical Software, 67(1), 1-48. <a href="https://doi.org/10.18637/jss.v067.i01">doi:10.18637/jss.v067.i01</a>.
</p>
<p>Hooten, M. B., and Hobbs, N. T. (2015). A guide to Bayesian model 
selection for ecologists. <em>Ecological Monographs</em>, 85(1), 3-28.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(400)

# Simulate Data -----------------------------------------------------------
J.x &lt;- 7
J.y &lt;- 7
J &lt;- J.x * J.y
n.rep &lt;- sample(2:4, size = J, replace = TRUE)
N &lt;- 5
# Community-level covariate effects
# Occurrence
beta.mean &lt;- c(0.2, -0.15)
p.occ &lt;- length(beta.mean)
tau.sq.beta &lt;- c(0.6, 0.3)
# Detection
alpha.mean &lt;- c(0.5, 0.2, -.2)
tau.sq.alpha &lt;- c(0.2, 0.3, 0.8)
p.det &lt;- length(alpha.mean)
# Draw species-level effects from community means.
beta &lt;- matrix(NA, nrow = N, ncol = p.occ)
alpha &lt;- matrix(NA, nrow = N, ncol = p.det)
for (i in 1:p.occ) {
  beta[, i] &lt;- rnorm(N, beta.mean[i], sqrt(tau.sq.beta[i]))
}
for (i in 1:p.det) {
  alpha[, i] &lt;- rnorm(N, alpha.mean[i], sqrt(tau.sq.alpha[i]))
}
phi &lt;- runif(N, 3/1, 3/.4)
sigma.sq &lt;- runif(N, 0.3, 3)
sp &lt;- TRUE

dat &lt;- simMsOcc(J.x = J.x, J.y = J.y, n.rep = n.rep, N = N, beta = beta, alpha = alpha,
                phi = phi, sigma.sq = sigma.sq, sp = TRUE, cov.model = 'exponential')

# Number of batches
n.batch &lt;- 30
# Batch length
batch.length &lt;- 25
n.samples &lt;- n.batch * batch.length

y &lt;- dat$y
X &lt;- dat$X
X.p &lt;- dat$X.p
coords &lt;- as.matrix(dat$coords)

# Package all data into a list
occ.covs &lt;- X[, 2, drop = FALSE]
colnames(occ.covs) &lt;- c('occ.cov')
det.covs &lt;- list(det.cov.1 = X.p[, , 2], 
                 det.cov.2 = X.p[, , 3])
data.list &lt;- list(y = y, 
                  occ.covs = occ.covs,
                  det.covs = det.covs, 
                  coords = coords)
# Priors
prior.list &lt;- list(beta.comm.normal = list(mean = 0, var = 2.72), 
                   alpha.comm.normal = list(mean = 0, var = 2.72), 
                   tau.sq.beta.ig = list(a = 0.1, b = 0.1), 
                   tau.sq.alpha.ig = list(a = 0.1, b = 0.1),
                   phi.unif = list(a = 3/1, b = 3/.1), 
                   sigma.sq.ig = list(a = 2, b = 2)) 
# Initial values
inits.list &lt;- list(alpha.comm = 0, 
                   beta.comm = 0, 
                   beta = 0, 
                   alpha = 0,
                   tau.sq.beta = 1, 
                   tau.sq.alpha = 1, 
                   phi = 3 / .5, 
                   sigma.sq = 2,
                   w = matrix(0, nrow = N, ncol = nrow(X)),
                   z = apply(y, c(1, 2), max, na.rm = TRUE))
# Tuning
tuning.list &lt;- list(phi = 1) 

out &lt;- spMsPGOcc(occ.formula = ~ occ.cov, 
                 det.formula = ~ det.cov.1 + det.cov.2, 
                 data = data.list,
                 inits = inits.list, 
                 n.batch = n.batch, 
                 batch.length = batch.length, 
                 accept.rate = 0.43, 
                 priors = prior.list, 
                 cov.model = "exponential", 
                 tuning = tuning.list, 
                 n.omp.threads = 1, 
                 verbose = TRUE, 
                 NNGP = TRUE, 
                 n.neighbors = 5, 
                 search.type = 'cb', 
                 n.report = 10, 
                 n.burn = 500, 
                 n.thin = 1, 
                 n.chains = 1)

summary(out, level = 'both')
</code></pre>

<hr>
<h2 id='spPGOcc'>Function for Fitting Single-Species Spatial Occupancy Models Using Polya-Gamma Latent Variables</h2><span id='topic+spPGOcc'></span>

<h3>Description</h3>

<p>The function <code>spPGOcc</code> fits single-species spatial occupancy models using Polya-Gamma latent variables. Models can be fit using either a full Gaussian process or a Nearest Neighbor Gaussian Process for large data sets. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spPGOcc(occ.formula, det.formula, data, inits, priors, 
        tuning, cov.model = "exponential", NNGP = TRUE, 
        n.neighbors = 15, search.type = "cb", n.batch,
        batch.length, accept.rate = 0.43, 
        n.omp.threads = 1, verbose = TRUE, n.report = 100, 
        n.burn = round(.10 * n.batch * batch.length), 
        n.thin = 1, n.chains = 1, k.fold, k.fold.threads = 1, 
        k.fold.seed = 100, k.fold.only = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spPGOcc_+3A_occ.formula">occ.formula</code></td>
<td>
<p>a symbolic description of the model to be fit
for the occurrence portion of the model using R's model syntax. Only
right-hand side of formula is specified. See example below. Random intercepts
are allowed using lme4 syntax (Bates et al. 2015).</p>
</td></tr>
<tr><td><code id="spPGOcc_+3A_det.formula">det.formula</code></td>
<td>
<p>a symbolic description of the model to be fit
for the detection portion of the model using R's model syntax. Only
right-hand side of formula is specified. See example below. Random intercepts
are allowed using lme4 syntax (Bates et al. 2015).</p>
</td></tr>
<tr><td><code id="spPGOcc_+3A_data">data</code></td>
<td>
<p>a list containing data necessary for model fitting.
Valid tags are <code>y</code>, <code>occ.covs</code>, <code>det.covs</code>, 
<code>coords</code>, and <code>grid.index</code>. 
<code>y</code> is the detection-nondetection data matrix or data frame with 
first dimension equal to the number of sites (<code class="reqn">J</code>) and second 
dimension equal to the maximum number of replicates at a given site. 
<code>occ.covs</code> is a matrix or data frame containing the variables used 
in the occupancy portion of the model, with <code class="reqn">J</code> rows for each column 
(variable). <code>det.covs</code> is a list of variables included in the 
detection portion of the model. Each list element is a different detection 
covariate, which can be site-level or observational-level. Site-level 
covariates are specified as a vector of length <code class="reqn">J</code> while 
observation-level covariates are specified 
as a matrix or data frame with the number of rows equal to <code class="reqn">J</code> and 
number of columns equal to the maximum number of replicates at a given site. 
<code>coords</code> is a matrix of the observation coordinates used
to estimate the spatial random effect for each site. <code>coords</code> has two columns for the 
easting and northing coordinate, respectively. Typically, each site in the data 
set will have it's own coordinate, such that <code>coords</code> is a <code class="reqn">J \times 2</code> 
matrix and <code>grid.index</code> should not be specified. 
If you desire to estimate spatial random effects at some larger spatial level, 
e.g., if points fall within grid cells and you want to estimate a spatial random effect for 
each grid cell instead of each point, <code>coords</code> can be specified as the coordinate for 
each grid cell. In such a case, <code>grid.index</code> is an indexing vector of length J, where each 
value of <code>grid.index</code> indicates the corresponding row in <code>coords</code> that the given 
site corresponds to. Note that <code>spOccupancy</code> assumes coordinates are specified 
in a projected coordinate system.</p>
</td></tr>
<tr><td><code id="spPGOcc_+3A_inits">inits</code></td>
<td>
<p>a list with each tag corresponding to a parameter name.
Valid tags are <code>z</code>, <code>beta</code>, <code>alpha</code>, <code>sigma.sq</code>, 
<code>phi</code>, <code>w</code>, <code>nu</code>, <code>sigma.sq.psi</code>, <code>sigma.sq.p</code>. 
<code>nu</code> is only specified if <code>cov.model = "matern"</code>, <code>sigma.sq.p</code>
is only specified if there are random effects in <code>det.formula</code>, and <code>sigma.sq.psi</code>
is only specified if there are random effects in <code>occ.formula</code>. 
The value portion of each tag is the parameter's initial value. See <code>priors</code>
description for definition of each parameter name.
Additionally, the tag <code>fix</code> can be set to <code>TRUE</code> 
to fix the starting values across all chains. If <code>fix</code> is not specified
(the default), starting values are varied randomly across chains.</p>
</td></tr>
<tr><td><code id="spPGOcc_+3A_priors">priors</code></td>
<td>
<p>a list with each tag corresponding to a parameter name. 
Valid tags are <code>beta.normal</code>, <code>alpha.normal</code>, <code>phi.unif</code>, 
<code>sigma.sq.ig</code>, <code>sigma.sq.unif</code>, <code>nu.unif</code>, 
<code>sigma.sq.psi.ig</code>, and <code>sigma.sq.p.ig</code>. Occurrence 
(<code>beta</code>) and detection (<code>alpha</code>) regression coefficients 
are assumed to follow a normal distribution. The hyperparameters of the 
normal distribution are passed as a list of length two with the first
and second elements corresponding to the mean and variance of the normal
distribution, which are each specified as vectors of 
length equal to the number of coefficients to be estimated or of length
one if priors are the same for all coefficients. If not
specified, prior means are set to 0 and prior variances set to 2.73. The 
spatial variance parameter, <code>sigma.sq</code>, is assumed to follow an 
inverse-Gamma distribution or a uniform distribution (default is 
inverse-Gamma). <code>sigma.sq</code> can also be fixed at its 
initial value by setting the prior value to 
<code>"fixed"</code>. The spatial decay <code>phi</code> and 
smoothness <code>nu</code> parameters are assumed to follow Uniform 
distributions. The hyperparameters of the inverse-Gamma for <code>sigma.sq</code> 
are passed as a vector of length two, with the first and second 
elements corresponding to the <em>shape</em> and <em>scale</em>, respectively. 
The hyperparameters of the Uniform are also passed as a vector of 
length two with the first and second elements corresponding to 
the lower and upper support, respectively. <code>sigma.sq.psi</code> and 
<code>sigma.sq.p</code> are the random effect variances for any occurrence or 
detection random effects, respectively, and are assumed to follow an 
inverse-Gamma distribution. The hyperparameters of
the inverse-Gamma distribution are passed as a list of length two with the 
first and second elements corresponding to the shape and scale parameters, 
respectively, which are each specified as vectors of length equal to the 
number of random intercepts or of length one if priors are the same for all
random effect variances.</p>
</td></tr>
<tr><td><code id="spPGOcc_+3A_cov.model">cov.model</code></td>
<td>
<p>a quoted keyword that specifies the covariance
function used to model the spatial dependence structure among the
observations.  Supported covariance model key words are:
<code>"exponential"</code>, <code>"matern"</code>, <code>"spherical"</code>, and
<code>"gaussian"</code>.</p>
</td></tr>
<tr><td><code id="spPGOcc_+3A_tuning">tuning</code></td>
<td>
<p>a list with each tag corresponding to a parameter
name. Valid tags are <code>phi</code> and <code>nu</code>. The value portion of each
tag defines the initial variance of the Adaptive sampler. See
Roberts and Rosenthal (2009) for details.</p>
</td></tr>
<tr><td><code id="spPGOcc_+3A_nngp">NNGP</code></td>
<td>
<p>if <code>TRUE</code>, model is fit with an NNGP. If <code>FALSE</code>, 
a full Gaussian process is used. See Datta et al. (2016) and 
Finley et al. (2019) for more information.</p>
</td></tr>
<tr><td><code id="spPGOcc_+3A_n.neighbors">n.neighbors</code></td>
<td>
<p>number of neighbors used in the NNGP. Only used if 
<code>NNGP = TRUE</code>. Datta et al. (2016) showed that 15 neighbors is usually 
sufficient, but that as few as 5 neighbors can be adequate for certain data
sets, which can lead to even greater decreases in run time. We recommend
starting with 15 neighbors (the default) and if additional gains in computation
time are desired, subsequently compare the results with a smaller number
of neighbors using WAIC or k-fold cross-validation.</p>
</td></tr>
<tr><td><code id="spPGOcc_+3A_search.type">search.type</code></td>
<td>
<p>a quoted keyword that specifies the type of nearest
neighbor search algorithm. Supported method key words are: <code>"cb"</code> and
<code>"brute"</code>. The <code>"cb"</code> should generally be much
faster. If locations do not have identical coordinate values on
the axis used for the nearest neighbor ordering then <code>"cb"</code> 
and <code>"brute"</code> should produce identical neighbor sets. 
However, if there are identical coordinate values on the axis used 
for nearest neighbor ordering, then <code>"cb"</code> and <code>"brute"</code> 
might produce different, but equally valid, neighbor sets, 
e.g., if data are on a grid. </p>
</td></tr>
<tr><td><code id="spPGOcc_+3A_n.batch">n.batch</code></td>
<td>
<p>the number of MCMC batches in each chain to run for the Adaptive MCMC 
sampler. See Roberts and Rosenthal (2009) for details.</p>
</td></tr>
<tr><td><code id="spPGOcc_+3A_batch.length">batch.length</code></td>
<td>
<p>the length of each MCMC batch in each chain to run for the Adaptive 
MCMC sampler. See Roberts and Rosenthal (2009) for details.</p>
</td></tr>
<tr><td><code id="spPGOcc_+3A_accept.rate">accept.rate</code></td>
<td>
<p>target acceptance rate for Adaptive MCMC. Default is 
0.43. See Roberts and Rosenthal (2009) for details.</p>
</td></tr>
<tr><td><code id="spPGOcc_+3A_n.omp.threads">n.omp.threads</code></td>
<td>
<p>a positive integer indicating
the number of threads to use for SMP parallel processing. The package must
be compiled for OpenMP support. For most Intel-based machines, we
recommend setting <code>n.omp.threads</code> up to the number of
hyperthreaded cores. Note, <code>n.omp.threads</code> &gt; 1 might not
work on some systems.</p>
</td></tr>
<tr><td><code id="spPGOcc_+3A_verbose">verbose</code></td>
<td>
<p>if <code>TRUE</code>, messages about data preparation, 
model specification, and progress of the sampler are printed to the screen. 
Otherwise, no messages are printed.</p>
</td></tr>
<tr><td><code id="spPGOcc_+3A_n.report">n.report</code></td>
<td>
<p>the interval to report Metropolis sampler acceptance and
MCMC progress.</p>
</td></tr>
<tr><td><code id="spPGOcc_+3A_n.burn">n.burn</code></td>
<td>
<p>the number of samples out of the total <code>n.batch * batch.length</code> 
samples in each chain to discard as burn-in. By default, the first 
10% of samples is discarded.</p>
</td></tr>
<tr><td><code id="spPGOcc_+3A_n.thin">n.thin</code></td>
<td>
<p>the thinning interval for collection of MCMC samples. The
thinning occurs after the <code>n.burn</code> samples are discarded. Default 
value is set to 1.</p>
</td></tr>
<tr><td><code id="spPGOcc_+3A_n.chains">n.chains</code></td>
<td>
<p>the number of MCMC chains to run in sequence.</p>
</td></tr>
<tr><td><code id="spPGOcc_+3A_k.fold">k.fold</code></td>
<td>
<p>specifies the number of <em>k</em> folds for cross-validation. 
If not specified as an argument, then cross-validation is not performed
and <code>k.fold.threads</code> and <code>k.fold.seed</code> are ignored. In <em>k</em>-fold
cross-validation, the data specified in <code>data</code> is randomly
partitioned into <em>k</em> equal sized subsamples. Of the <em>k</em> subsamples, 
<em>k</em> - 1 subsamples are used to fit the model and the remaining <em>k</em>
samples are used for prediction. The cross-validation process is repeated 
<em>k</em> times (the folds). As a scoring rule, we use the model deviance 
as described in Hooten and Hobbs (2015). Cross-validation is performed
after the full model is fit using all the data. Cross-validation results
are reported in the <code>k.fold.deviance</code> object in the return list.</p>
</td></tr>
<tr><td><code id="spPGOcc_+3A_k.fold.threads">k.fold.threads</code></td>
<td>
<p>number of threads to use for cross-validation. If 
<code>k.fold.threads &gt; 1</code> parallel processing is accomplished using the 
<span class="pkg">foreach</span> and <span class="pkg">doParallel</span> packages. Ignored if <code>k.fold</code>
is not specified.</p>
</td></tr> 
<tr><td><code id="spPGOcc_+3A_k.fold.seed">k.fold.seed</code></td>
<td>
<p>seed used to split data set into <code>k.fold</code> parts
for k-fold cross-validation. Ignored if <code>k.fold</code> is not specified.</p>
</td></tr>
<tr><td><code id="spPGOcc_+3A_k.fold.only">k.fold.only</code></td>
<td>
<p>a logical value indicating whether to only perform 
cross-validation (<code>TRUE</code>) or perform cross-validation after fitting 
the full model (<code>FALSE</code>). Default value is <code>FALSE</code>.</p>
</td></tr> 
<tr><td><code id="spPGOcc_+3A_...">...</code></td>
<td>
<p>currently no additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>spPGOcc</code> that is a list comprised of: 
</p>
<table>
<tr><td><code>beta.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the occurrence regression coefficients.</p>
</td></tr>
<tr><td><code>alpha.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the detection regression coefficients.</p>
</td></tr>
<tr><td><code>z.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples 
for the latent occurrence values</p>
</td></tr>
<tr><td><code>psi.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the latent occurrence probability values</p>
</td></tr>
<tr><td><code>theta.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for covariance parameters.</p>
</td></tr>
<tr><td><code>w.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for latent spatial random effects.</p>
</td></tr>
<tr><td><code>sigma.sq.psi.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for variances of random intercepts included in the occupancy portion
of the model. Only included if random intercepts are specified in 
<code>occ.formula</code>.</p>
</td></tr>
<tr><td><code>sigma.sq.p.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for variances of random intercpets included in the detection portion 
of the model. Only included if random intercepts are specified in 
<code>det.formula</code>.</p>
</td></tr>
<tr><td><code>beta.star.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the occurrence random effects. Only included if random intercepts
are specified in <code>occ.formula</code>.</p>
</td></tr>
<tr><td><code>alpha.star.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the detection random effects. Only included if random intercepts 
are specified in <code>det.formula</code>.</p>
</td></tr>
<tr><td><code>like.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the likelihood value associated with each site. Used for calculating
WAIC.</p>
</td></tr>
<tr><td><code>rhat</code></td>
<td>
<p>a list of Gelman-Rubin diagnostic values for some of the model
parameters.</p>
</td></tr>
<tr><td><code>ESS</code></td>
<td>
<p>a list of effective sample sizes for some of the model parameters.</p>
</td></tr>
<tr><td><code>run.time</code></td>
<td>
<p>execution time reported using <code>proc.time()</code>.</p>
</td></tr>
<tr><td><code>k.fold.deviance</code></td>
<td>
<p>soring rule (deviance) from k-fold cross-validation. 
Only included if <code>k.fold</code> is specified in function call.</p>
</td></tr>
</table>
<p>The return object will include additional objects used for 
subsequent prediction and/or model fit evaluation. Note that detection
probability values are not included in the model object, but can be 
extracted using <code>fitted()</code>.
</p>


<h3>Author(s)</h3>

<p>Jeffrey W. Doser <a href="mailto:doserjef@msu.edu">doserjef@msu.edu</a>, <br />
Andrew O. Finley <a href="mailto:finleya@msu.edu">finleya@msu.edu</a>
</p>


<h3>References</h3>

<p>Bates, Douglas, Martin Maechler, Ben Bolker, Steve Walker (2015).
Fitting Linear Mixed-Effects Models Using lme4. Journal of
Statistical Software, 67(1), 1-48. <a href="https://doi.org/10.18637/jss.v067.i01">doi:10.18637/jss.v067.i01</a>.
</p>
<p>Datta, A., S. Banerjee, A.O. Finley, and A.E. Gelfand. (2016)
Hierarchical Nearest-Neighbor Gaussian process models for large
geostatistical datasets. <em>Journal of the American Statistical
Association</em>, <a href="https://doi.org/10.1080/01621459.2015.1044091">doi:10.1080/01621459.2015.1044091</a>.
</p>
<p>Finley, A.O., A. Datta, B.D. Cook, D.C. Morton, H.E. Andersen, and
S. Banerjee. (2019) Efficient algorithms for Bayesian Nearest Neighbor
Gaussian Processes. <em>Journal of Computational and Graphical
Statistics</em>, <a href="https://doi.org/10.1080/10618600.2018.1537924">doi:10.1080/10618600.2018.1537924</a>.
</p>
<p>Finley, A. O., Datta, A., and Banerjee, S. (2020). spNNGP R package 
for nearest neighbor Gaussian process models. <em>arXiv</em> preprint arXiv:2001.09111.
</p>
<p>Hooten, M. B., and Hobbs, N. T. (2015). A guide to Bayesian model 
selection for ecologists. <em>Ecological Monographs</em>, 85(1), 3-28.
</p>
<p>Hooten, M. B., and Hefley, T. J. (2019). Bringing Bayesian models to life. 
<em>CRC Press</em>.
</p>
<p>Polson, N.G., J.G. Scott, and J. Windle. (2013) Bayesian Inference for
Logistic Models Using Polya-Gamma Latent Variables. 
<em>Journal of the American Statistical Association</em>, 108:1339-1349.
</p>
<p>Roberts, G.O. and Rosenthal J.S. (2009) Examples  of adaptive MCMC. 
<em>Journal of Computational and Graphical Statistics</em>, 18(2):349-367.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(350)
# Simulate Data -----------------------------------------------------------
J.x &lt;- 8
J.y &lt;- 8
J &lt;- J.x * J.y
n.rep &lt;- sample(2:4, J, replace = TRUE)
beta &lt;- c(0.5, -0.15)
p.occ &lt;- length(beta)
alpha &lt;- c(0.7, 0.4, -0.2)
p.det &lt;- length(alpha)
phi &lt;- 3 / .6
sigma.sq &lt;- 2
dat &lt;- simOcc(J.x = J.x, J.y = J.y, n.rep = n.rep, beta = beta, alpha = alpha, 
              sigma.sq = sigma.sq, phi = phi, sp = TRUE, cov.model = 'exponential')
y &lt;- dat$y
X &lt;- dat$X
X.p &lt;- dat$X.p
coords &lt;- as.matrix(dat$coords)

# Package all data into a list
occ.covs &lt;- X[, -1, drop = FALSE]
colnames(occ.covs) &lt;- c('occ.cov')
det.covs &lt;- list(det.cov.1 = X.p[, , 2], 
                 det.cov.2 = X.p[, , 3])
data.list &lt;- list(y = y, 
                  occ.covs = occ.covs, 
                  det.covs = det.covs, 
                  coords = coords)

# Number of batches
n.batch &lt;- 10
# Batch length
batch.length &lt;- 25
n.iter &lt;- n.batch * batch.length
# Priors 
prior.list &lt;- list(beta.normal = list(mean = 0, var = 2.72), 
                   alpha.normal = list(mean = 0, var = 2.72),
                   sigma.sq.ig = c(2, 2), 
                   phi.unif = c(3/1, 3/.1)) 
# Initial values
inits.list &lt;- list(alpha = 0, beta = 0,
                   phi = 3 / .5, 
                   sigma.sq = 2,
                   w = rep(0, nrow(X)),
                   z = apply(y, 1, max, na.rm = TRUE))
# Tuning
tuning.list &lt;- list(phi = 1) 

out &lt;- spPGOcc(occ.formula = ~ occ.cov, 
               det.formula = ~ det.cov.1 + det.cov.2, 
               data = data.list, 
               inits = inits.list, 
               n.batch = n.batch, 
               batch.length = batch.length, 
               priors = prior.list,
               cov.model = "exponential", 
               tuning = tuning.list, 
               NNGP = FALSE, 
               n.neighbors = 5, 
               search.type = 'cb', 
               n.report = 10, 
               n.burn = 50, 
               n.chains = 1)

summary(out)
</code></pre>

<hr>
<h2 id='stMsPGOcc'>Function for Fitting Multi-Species Multi-Season Spatial Occupancy Models</h2><span id='topic+stMsPGOcc'></span>

<h3>Description</h3>

<p>The function <code>stMsPGOcc</code> fits multi-species multi-season spatial occupancy models with species correlations (i.e., a spatially-explicit joint species distribution model with imperfect detection). We use Polya-Gamma latent variables and a spatial factor modeling approach. Models are implemented using a Nearest Neighbor Gaussian Process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stMsPGOcc(occ.formula, det.formula, data, inits, priors, tuning, 
          cov.model = 'exponential', NNGP = TRUE, 
          n.neighbors = 15, search.type = 'cb', 
          n.factors, n.batch, batch.length, 
          accept.rate = 0.43, n.omp.threads = 1, 
          verbose = TRUE, ar1 = FALSE, n.report = 100, 
          n.burn = round(.10 * n.batch * batch.length), n.thin = 1, 
          n.chains = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stMsPGOcc_+3A_occ.formula">occ.formula</code></td>
<td>
<p>a symbolic description of the model to be fit
for the occurrence portion of the model using R's model syntax. Random
intercepts are allowed using lme4 syntax (Bates et al. 2015). Only
right-hand side of formula is specified. See example below.</p>
</td></tr>
<tr><td><code id="stMsPGOcc_+3A_det.formula">det.formula</code></td>
<td>
<p>a symbolic description of the model to be fit
for the detection portion of the model using R's model syntax. Only
right-hand side of formula is specified. See example below. Random 
intercepts are allowed using lme4 syntax (Bates et al. 2015).</p>
</td></tr>
<tr><td><code id="stMsPGOcc_+3A_data">data</code></td>
<td>
<p>a list containing data necessary for model fitting.
Valid tags are <code>y</code>, <code>occ.covs</code>, <code>det.covs</code>, 
<code>coords</code>, and <code>grid.index</code>. 
<code>y</code> is a four-dimensional array with first dimension equal to the 
number of species, second dimension equal to the number of sites, third
dimension equal to the number of primary time periods, and 
fourth dimension equal to the maximum number of secondary replicates at a given site. 
<code>occ.covs</code> is a list of variables included in the occurrence portion of the model. Each
list element is a different occurrence covariate, which can be site level
or site/primary time period level. Site-level covariates are specified as a vector of 
length <code class="reqn">J</code> while site/primary time period level covariates are specified as a matrix
with rows corresponding to sites and columns correspond to primary time periods.
Similarly, <code>det.covs</code> is a list of variables included in the detection
portion of the model, with each list element corresponding to an individual variable.    
In addition to site-level and/or site/primary time period-level, 
detection covariates can also be observational-level. Observation-level covariates
are specified as a three-dimensional array with first dimension corresponding to 
sites, second dimension corresponding to primary time period, and third 
dimension corresponding to replicate. <code>coords</code> is a matrix of the observation coordinates used
to estimate the SVCs for each site. <code>coords</code> has two columns for the 
easting and northing coordinate, respectively. Typically, each site in the data 
set will have it's own coordinate, such that <code>coords</code> is a <code class="reqn">J \times 2</code> 
matrix and <code>grid.index</code> should not be specified. 
If you desire to estimate SVCs at some larger spatial level, 
e.g., if points fall within grid cells and you want to estimate an SVC for 
each grid cell instead of each point, <code>coords</code> can be specified as the coordinate for 
each grid cell. In such a case, <code>grid.index</code> is an indexing vector of length J, where each 
value of <code>grid.index</code> indicates the corresponding row in <code>coords</code> that the given 
site corresponds to. Note that <code>spOccupancy</code> assumes coordinates are specified 
in a projected coordinate system.</p>
</td></tr>
<tr><td><code id="stMsPGOcc_+3A_inits">inits</code></td>
<td>
<p>a list with each tag corresponding to a parameter name.
Valid tags are <code>alpha.comm</code>, <code>beta.comm</code>, <code>beta</code>, 
<code>alpha</code>, <code>tau.sq.beta</code>, <code>tau.sq.alpha</code>, 
<code>sigma.sq.psi</code>, <code>sigma.sq.p</code>, <code>z</code>, 
<code>phi</code>, <code>lambda</code>, <code>nu</code>, <code>sigma.sq.t</code>, 
and <code>rho</code>. <code>nu</code> is only specified if 
<code>cov.model = "matern"</code>, and <code>sigma.sq.psi</code> and <code>sigma.sq.p</code> are
only specified if random effects are included in <code>occ.formula</code> or 
<code>det.formula</code>, respectively. <code>sigma.sq.t</code> and <code>rho</code> are only 
relevant when <code>ar1 = TRUE</code>. The value portion of each tag is 
the parameter's initial value. See <code>priors</code> description for definition
of each parameter name. Additionally, the tag <code>fix</code> can be set to <code>TRUE</code> 
to fix the starting values across all chains. If <code>fix</code> is not specified
(the default), starting values are varied randomly across chains.</p>
</td></tr>
<tr><td><code id="stMsPGOcc_+3A_priors">priors</code></td>
<td>
<p>a list with each tag corresponding to a parameter name. 
Valid tags are <code>beta.comm.normal</code>, <code>alpha.comm.normal</code>, 
<code>tau.sq.beta.ig</code>, <code>tau.sq.alpha.ig</code>, <code>sigma.sq.psi</code>, 
<code>sigma.sq.p</code>, <code>phi.unif</code>, <code>nu.unif</code>, <code>sigma.sq.t.ig</code>, and 
<code>rho.unif</code>. Community-level occurrence (<code>beta.comm</code>) and detection 
(<code>alpha.comm</code>) regression coefficients are assumed to follow a 
normal distribution. The hyperparameters of the normal distribution
are passed as a list of length two with the first and second elements 
corresponding to the mean and variance of the normal distribution, 
which are each specified as vectors of length equal to the number of 
coefficients to be estimated or of length one if priors are the same for 
all coefficients. If not specified, prior means are set 
to 0 and prior variances set to 2.73. By default, community-level variance parameters 
for occupancy (<code>tau.sq.beta</code>) and detection (<code>tau.sq.alpha</code>) are 
assumed to follow an inverse Gamma distribution. The hyperparameters of 
the inverse gamma distribution are passed as a list of length two with 
the first and second elements corresponding to the shape and scale parameters,
which are each specified as vectors of length equal to the number of 
coefficients to be estimated or a single value if priors are the same for all 
parameters. If not specified, prior shape and scale 
parameters are set to 0.1. 
The spatial factor model fits <code>n.factors</code> independent spatial processes. 
The spatial decay <code>phi</code> and smoothness <code>nu</code> parameters 
for each latent factor are assumed to follow Uniform distributions. 
The hyperparameters of the Uniform are passed as a list with two elements, 
with both elements being vectors of length <code>n.factors</code> 
corresponding to the lower and 
upper support, respectively, or as a single value if the same value is assigned
for all factor combinations. The priors for the factor loadings 
matrix <code>lambda</code> are fixed
following the standard spatial factor model to ensure parameter 
identifiability (Christensen and Amemlya 2002). The
upper triangular elements of the <code>N x n.factors</code> matrix are fixed at 0 and the 
diagonal elements are fixed at 1. The lower triangular elements are assigned a 
standard normal prior (i.e., mean 0 and variance 1).
<code>sigma.sq.psi</code> and <code>sigma.sq.p</code> are the random 
effect variances for any occurrence or
detection random effects, respectively, and are assumed to follow an inverse
Gamma distribution. The hyperparameters of the inverse-Gamma distribution
are passed as a list of length two with first and second elements corresponding
to the shape and scale parameters, respectively, which are each specified as
vectors of length equal to the number of random intercepts or of length one 
if priors are the same for all random effect variances. 
parameters are set to 0.1. <code>sigma.sq.t</code> and <code>rho</code> 
are the AR(1) variance and correlation parameters for the AR(1) zero-mean
temporal random effects, respectively. <code>sigma.sq.t</code> is assumed to follow an inverse-Gamma
distribution, where the hyperparameters are specified as a list of length two with the 
first and second elements corresponding to the shape and scale parameters, respectively, 
which can each be specified as vector equal to the number of species in the model or a single value
if the same prior is used for all species. <code>rho</code> is assumed to follow a 
uniform distribution, where the hyperparameters are specified similarly as a list of length two
with the first and second elements corresponding to the lower and upper bounds of the 
uniform prior, which can each be specified as vector equal to the number of species in the 
model or a single value if the same prior is used for all species. 
</p>
</td></tr>
<tr><td><code id="stMsPGOcc_+3A_tuning">tuning</code></td>
<td>
<p>a list with each tag corresponding to a parameter
name. Valid tags are <code>phi</code>, <code>nu</code>, <code>rho</code>. The value portion of each
tag defines the initial variance of the adaptive sampler. We assume the 
initial variance of the adaptive sampler is the same for each species, 
although the adaptive sampler will adjust the tuning variances separately
for each species. See Roberts and Rosenthal (2009) for details.</p>
</td></tr>
<tr><td><code id="stMsPGOcc_+3A_cov.model">cov.model</code></td>
<td>
<p>a quoted keyword that specifies the covariance
function used to model the spatial dependence structure among the
observations.  Supported covariance model key words are:
<code>"exponential"</code>, <code>"matern"</code>, <code>"spherical"</code>, and
<code>"gaussian"</code>.</p>
</td></tr>
<tr><td><code id="stMsPGOcc_+3A_nngp">NNGP</code></td>
<td>
<p>if <code>TRUE</code>, model is fit with an NNGP. If <code>FALSE</code>, 
a full Gaussian process is used. See Datta et al. (2016) and 
Finley et al. (2019) for more information. Only 
<code>NNGP = TRUE</code> is currently supported.</p>
</td></tr>
<tr><td><code id="stMsPGOcc_+3A_n.neighbors">n.neighbors</code></td>
<td>
<p>number of neighbors used in the NNGP. Only used if 
<code>NNGP = TRUE</code>. Datta et al. (2016) showed that 15 neighbors is usually 
sufficient, but that as few as 5 neighbors can be adequate for certain data
sets, which can lead to even greater decreases in run time. We recommend
starting with 15 neighbors (the default) and if additional gains in computation
time are desired, subsequently compare the results with a smaller number
of neighbors using WAIC.</p>
</td></tr>
<tr><td><code id="stMsPGOcc_+3A_search.type">search.type</code></td>
<td>
<p>a quoted keyword that specifies the type of nearest
neighbor search algorithm. Supported method key words are: <code>"cb"</code> and
<code>"brute"</code>. The <code>"cb"</code> should generally be much
faster. If locations do not have identical coordinate values on
the axis used for the nearest neighbor ordering then <code>"cb"</code> 
and <code>"brute"</code> should produce identical neighbor sets. 
However, if there are identical coordinate values on the axis used 
for nearest neighbor ordering, then <code>"cb"</code> and <code>"brute"</code> 
might produce different, but equally valid, neighbor sets, 
e.g., if data are on a grid. </p>
</td></tr>
<tr><td><code id="stMsPGOcc_+3A_n.factors">n.factors</code></td>
<td>
<p>the number of factors to use in the spatial factor model approach. 
Typically, the number of factors is set to be small (e.g., 4-5) relative to the 
total number of species in the community, which will lead to substantial 
decreases in computation time. However, the value can be anywhere 
between 1 and N (the number of species in the community).</p>
</td></tr>
<tr><td><code id="stMsPGOcc_+3A_n.batch">n.batch</code></td>
<td>
<p>the number of MCMC batches  in each chain to run for the Adaptive MCMC 
sampler. See Roberts and Rosenthal (2009) for details.</p>
</td></tr>
<tr><td><code id="stMsPGOcc_+3A_batch.length">batch.length</code></td>
<td>
<p>the length of each MCMC batch to run for the Adaptive 
MCMC sampler. See Roberts and Rosenthal (2009) for details.</p>
</td></tr>
<tr><td><code id="stMsPGOcc_+3A_accept.rate">accept.rate</code></td>
<td>
<p>target acceptance rate for Adaptive MCMC. Defaul is 
0.43. See Roberts and Rosenthal (2009) for details.</p>
</td></tr>
<tr><td><code id="stMsPGOcc_+3A_n.omp.threads">n.omp.threads</code></td>
<td>
<p>a positive integer indicating
the number of threads to use for SMP parallel processing. The package must
be compiled for OpenMP support. For most Intel-based machines, we
recommend setting <code>n.omp.threads</code> up to the number of
hyperthreaded cores. Note, <code>n.omp.threads</code> &gt; 1 might not
work on some systems.</p>
</td></tr>
<tr><td><code id="stMsPGOcc_+3A_verbose">verbose</code></td>
<td>
<p>if <code>TRUE</code>, messages about data preparation, 
model specification, and progress of the sampler are printed to the screen. 
Otherwise, no messages are printed.</p>
</td></tr>
<tr><td><code id="stMsPGOcc_+3A_ar1">ar1</code></td>
<td>
<p>logical value indicating whether to include an AR(1) zero-mean
temporal random effect in the model. If <code>FALSE</code>, the model is
fit without an AR(1) temporal autocovariance structure. If <code>TRUE</code>,
an AR(1) random effect is included in the model to account for temporal
autocorrelation across the primary time periods.</p>
</td></tr>
<tr><td><code id="stMsPGOcc_+3A_n.report">n.report</code></td>
<td>
<p>the interval to report Metropolis sampler acceptance and
MCMC progress. Note this is specified in terms of batches and not overall
samples for spatial models.</p>
</td></tr>
<tr><td><code id="stMsPGOcc_+3A_n.burn">n.burn</code></td>
<td>
<p>the number of samples out of the total <code>n.samples</code> to 
discard as burn-in for each chain. By default, the first 10% of samples is discarded.</p>
</td></tr>
<tr><td><code id="stMsPGOcc_+3A_n.thin">n.thin</code></td>
<td>
<p>the thinning interval for collection of MCMC samples. The
thinning occurs after the <code>n.burn</code> samples are discarded. Default 
value is set to 1.</p>
</td></tr>
<tr><td><code id="stMsPGOcc_+3A_n.chains">n.chains</code></td>
<td>
<p>the number of chains to run in sequence.</p>
</td></tr>
<tr><td><code id="stMsPGOcc_+3A_...">...</code></td>
<td>
<p>currently no additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>stMsPGOcc</code> that is a list comprised of: 
</p>
<table>
<tr><td><code>beta.comm.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the community level occurrence regression coefficients.</p>
</td></tr>
<tr><td><code>alpha.comm.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the community level detection regression coefficients.</p>
</td></tr>
<tr><td><code>tau.sq.beta.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the occurrence community variance parameters.</p>
</td></tr>
<tr><td><code>tau.sq.alpha.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the detection community variance parameters.</p>
</td></tr>
<tr><td><code>beta.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the species level occurrence regression coefficients.</p>
</td></tr>
<tr><td><code>alpha.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the species level detection regression coefficients.</p>
</td></tr>
<tr><td><code>theta.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the species level correlation parameters and the species-level
temporal autocorrelation parameters.</p>
</td></tr>
<tr><td><code>lambda.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the latent spatial factor loadings.</p>
</td></tr>
<tr><td><code>z.samples</code></td>
<td>
<p>a four-dimensional array of posterior samples for
the latent occurrence values for each species. Dimensions corresopnd to 
MCMC sample, species, site, and primary time period.</p>
</td></tr>
<tr><td><code>psi.samples</code></td>
<td>
<p>a four-dimensional array of posterior samples for
the latent occupancy probability values for each species. Dimensions correspond
to MCMC sample, species, site, and primary time period.</p>
</td></tr>
<tr><td><code>w.samples</code></td>
<td>
<p>a three-dimensional array of posterior samples for 
the latent spatial random effects for each spatial factor. 
Dimensions correspond to MCMC sample, factor, and site.</p>
</td></tr>
<tr><td><code>sigma.sq.psi.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for variances of random intercepts included in the occurrence portion
of the model. Only included if random intercepts are specified in 
<code>occ.formula</code>.</p>
</td></tr>
<tr><td><code>sigma.sq.p.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for variances of random intercpets included in the detection portion 
of the model. Only included if random intercepts are specified in 
<code>det.formula</code>.</p>
</td></tr>
<tr><td><code>beta.star.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the occurrence random effects. Only included if random intercepts
are specified in <code>occ.formula</code>.</p>
</td></tr>
<tr><td><code>alpha.star.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the detection random effects. Only included if random intercepts 
are specified in <code>det.formula</code>.</p>
</td></tr>
<tr><td><code>like.samples</code></td>
<td>
<p>a four-dimensional array of posterior samples
for the likelihood value used for calculating WAIC. Dimensions correspond 
to MCMC sample, species, site, and time period.</p>
</td></tr>
<tr><td><code>rhat</code></td>
<td>
<p>a list of Gelman-Rubin diagnostic values for some of the model
parameters.</p>
</td></tr>
<tr><td><code>ESS</code></td>
<td>
<p>a list of effective sample sizes for some of the model parameters.</p>
</td></tr>
<tr><td><code>run.time</code></td>
<td>
<p>MCMC sampler execution time reported using <code>proc.time()</code>.</p>
</td></tr>
</table>
<p>The return object will include additional objects used for 
subsequent prediction and/or model fit evaluation. Note that detection 
probability estimated values are not included in the model object, but can
be extracted using <code>fitted()</code>.
</p>


<h3>Note</h3>

<p>Some of the underlying code used for generating random numbers from the
Polya-Gamma distribution is taken from the <span class="pkg">pgdraw</span> package written
by Daniel F. Schmidt and Enes Makalic. Their code implements Algorithm
6 in PhD thesis of Jesse Bennett Windle (2013) <a href="https://repositories.lib.utexas.edu/handle/2152/21842">https://repositories.lib.utexas.edu/handle/2152/21842</a>.
</p>


<h3>Author(s)</h3>

<p>Jeffrey W. Doser <a href="mailto:doserjef@msu.edu">doserjef@msu.edu</a>, <br />
Andrew O. Finley <a href="mailto:finleya@msu.edu">finleya@msu.edu</a>
</p>


<h3>References</h3>

<p>Datta, A., S. Banerjee, A.O. Finley, and A.E. Gelfand. (2016)
Hierarchical Nearest-Neighbor Gaussian process models for large
geostatistical datasets. <em>Journal of the American Statistical
Association</em>, <a href="https://doi.org/10.1080/01621459.2015.1044091">doi:10.1080/01621459.2015.1044091</a>.
</p>
<p>Finley, A.O., A. Datta, B.D. Cook, D.C. Morton, H.E. Andersen, and
S. Banerjee. (2019) Efficient algorithms for Bayesian Nearest Neighbor
Gaussian Processes. <em>Journal of Computational and Graphical
Statistics</em>, <a href="https://doi.org/10.1080/10618600.2018.1537924">doi:10.1080/10618600.2018.1537924</a>.
</p>
<p>Finley, A. O., Datta, A., and Banerjee, S. (2020). spNNGP R package 
for nearest neighbor Gaussian process models. <em>arXiv</em> preprint arXiv:2001.09111.
</p>
<p>Polson, N.G., J.G. Scott, and J. Windle. (2013) Bayesian Inference for
Logistic Models Using Polya-Gamma Latent Variables.
<em>Journal of the American Statistical Association</em>, 108:1339-1349.
</p>
<p>Roberts, G.O. and Rosenthal J.S. (2009) Examples  of adaptive MCMC.
<em>Journal of Computational and Graphical Statistics</em>, 18(2):349-367.
</p>
<p>Bates, Douglas, Martin Maechler, Ben Bolker, Steve Walker (2015).
Fitting Linear Mixed-Effects Models Using lme4. Journal of
Statistical Software, 67(1), 1-48. <a href="https://doi.org/10.18637/jss.v067.i01">doi:10.18637/jss.v067.i01</a>.
</p>
<p>Hooten, M. B., and Hobbs, N. T. (2015). A guide to Bayesian model 
selection for ecologists. <em>Ecological Monographs</em>, 85(1), 3-28.
</p>
<p>Christensen, W. F., and Amemiya, Y. (2002). Latent variable analysis 
of multivariate spatial data. <em>Journal of the American Statistical Association</em>, 
97(457), 302-317.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simulate Data -----------------------------------------------------------
set.seed(500)
J.x &lt;- 8
J.y &lt;- 8
J &lt;- J.x * J.y
# Years sampled
n.time &lt;- sample(3:10, J, replace = TRUE)
# n.time &lt;- rep(10, J)
n.time.max &lt;- max(n.time)
# Replicates
n.rep &lt;- matrix(NA, J, max(n.time))
for (j in 1:J) {
  n.rep[j, 1:n.time[j]] &lt;- sample(2:4, n.time[j], replace = TRUE)
}
N &lt;- 7
# Community-level covariate effects
# Occurrence
beta.mean &lt;- c(-3, -0.2, 0.5)
trend &lt;- FALSE
sp.only &lt;- 0
p.occ &lt;- length(beta.mean)
tau.sq.beta &lt;- c(0.6, 1.5, 1.4)
# Detection
alpha.mean &lt;- c(0, 1.2, -1.5)
tau.sq.alpha &lt;- c(1, 0.5, 2.3)
p.det &lt;- length(alpha.mean)
# Random effects
psi.RE &lt;- list()
p.RE &lt;- list()
# Draw species-level effects from community means.
beta &lt;- matrix(NA, nrow = N, ncol = p.occ)
alpha &lt;- matrix(NA, nrow = N, ncol = p.det)
for (i in 1:p.occ) {
  beta[, i] &lt;- rnorm(N, beta.mean[i], sqrt(tau.sq.beta[i]))
}
for (i in 1:p.det) {
  alpha[, i] &lt;- rnorm(N, alpha.mean[i], sqrt(tau.sq.alpha[i]))
}
sp &lt;- TRUE
svc.cols &lt;- c(1)
p.svc &lt;- length(svc.cols)
n.factors &lt;- 3
phi &lt;- runif(p.svc * n.factors, 3 / .9, 3 / .3)
factor.model &lt;- TRUE
cov.model &lt;- 'exponential'
ar1 &lt;- TRUE
sigma.sq.t &lt;- runif(N, 0.05, 1)
rho &lt;- runif(N, 0.1, 1)

dat &lt;- simTMsOcc(J.x = J.x, J.y = J.y, n.time = n.time, n.rep = n.rep, N = N,
                 beta = beta, alpha = alpha, sp.only = sp.only, trend = trend,
                 psi.RE = psi.RE, p.RE = p.RE, factor.model = factor.model,
                 svc.cols = svc.cols, n.factors = n.factors, phi = phi, sp = sp,
                 cov.model = cov.model, ar1 = ar1, sigma.sq.t = sigma.sq.t, rho = rho)

y &lt;- dat$y
X &lt;- dat$X
X.p &lt;- dat$X.p
coords &lt;- dat$coords
X.re &lt;- dat$X.re
X.p.re &lt;- dat$X.p.re

occ.covs &lt;- list(occ.cov.1 = X[, , 2],
                 occ.cov.2 = X[, , 3])
det.covs &lt;- list(det.cov.1 = X.p[, , , 2],
                 det.cov.2 = X.p[, , , 3])

data.list &lt;- list(y = y, occ.covs = occ.covs,
                  det.covs = det.covs,
                  coords = coords)
# Priors
prior.list &lt;- list(beta.comm.normal = list(mean = 0, var = 2.72),
                   alpha.comm.normal = list(mean = 0, var = 2.72),
                   tau.sq.beta.ig = list(a = 0.1, b = 0.1),
                   tau.sq.alpha.ig = list(a = 0.1, b = 0.1),
                   rho.unif = list(a = -1, b = 1),
                   sigma.sq.t.ig = list(a = 0.1, b = 0.1),
                   phi.unif = list(a = 3 / .9, b = 3 / .1))
z.init &lt;- apply(y, c(1, 2, 3), function(a) as.numeric(sum(a, na.rm = TRUE) &gt; 0))
inits.list &lt;- list(alpha.comm = 0, beta.comm = 0, beta = 0,
                   alpha = 0, tau.sq.beta = 1, tau.sq.alpha = 1,
                   rho = 0.5, sigma.sq.t = 0.5,
                   phi = 3 / .5, z = z.init)
# Tuning
tuning.list &lt;- list(phi = 1, rho = 0.5)

# Number of batches
n.batch &lt;- 5
# Batch length
batch.length &lt;- 25
n.burn &lt;- 25
n.thin &lt;- 1
n.samples &lt;- n.batch * batch.length

out &lt;- stMsPGOcc(occ.formula = ~ occ.cov.1 + occ.cov.2,
                 det.formula = ~ det.cov.1 + det.cov.2,
                 data = data.list,
                 inits = inits.list,
                 n.batch = n.batch,
                 batch.length = batch.length,
                 accept.rate = 0.43,
                 ar1 = TRUE,
                 NNGP = TRUE,
                 n.neighbors = 5,
                 n.factors = n.factors,
                 cov.model = 'exponential',
                 priors = prior.list,
                 tuning = tuning.list,
                 n.omp.threads = 1,
                 verbose = TRUE,
                 n.report = 1,
                 n.burn = n.burn,
                 n.thin = n.thin,
                 n.chains = 1)

summary(out)
</code></pre>

<hr>
<h2 id='stPGOcc'>Function for Fitting Multi-Season Single-Species Spatial Occupancy Models Using Polya-Gamma Latent Variables</h2><span id='topic+stPGOcc'></span>

<h3>Description</h3>

<p>Function for fitting multi-season single-species spatial occupancy models using Polya-Gamma latent variables. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stPGOcc(occ.formula, det.formula, data, inits, priors, 
        tuning, cov.model = 'exponential', NNGP = TRUE, 
        n.neighbors = 15, search.type = 'cb', n.batch, 
        batch.length, accept.rate = 0.43, n.omp.threads = 1, 
        verbose = TRUE, ar1 = FALSE, n.report = 100, 
        n.burn = round(.10 * n.batch * batch.length), 
        n.thin = 1, n.chains = 1, k.fold, k.fold.threads = 1, 
        k.fold.seed = 100, k.fold.only = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stPGOcc_+3A_occ.formula">occ.formula</code></td>
<td>
<p>a symbolic description of the model to be fit
for the occurrence portion of the model using R's model syntax. Only
right-hand side of formula is specified. See example below. Random intercepts
are allowed using lme4 syntax (Bates et al. 2015).</p>
</td></tr>
<tr><td><code id="stPGOcc_+3A_det.formula">det.formula</code></td>
<td>
<p>a symbolic description of the model to be fit
for the detection portion of the model using R's model syntax. Only
right-hand side of formula is specified. See example below. Random intercepts
are allowed using lme4 syntax (Bates et al. 2015).</p>
</td></tr>
<tr><td><code id="stPGOcc_+3A_data">data</code></td>
<td>
<p>a list containing data necessary for model fitting.
Valid tags are <code>y</code>, <code>occ.covs</code>, <code>det.covs</code>, <code>coords</code>, and <code>grid.index</code>. <code>y</code>
is a three-dimensional array with first dimension equal to the number of 
sites (<code class="reqn">J</code>), second dimension equal to the maximum number of 
primary time periods (i.e., years or seasons), and third dimension equal 
to the maximum number of replicates at a given site. <code>occ.covs</code> is a
list of variables included in the occurrence portion of the model. Each
list element is a different occurrence covariate, which can be site level
or site/primary timer period level. Site-level covariates are specified as a vector of 
length <code class="reqn">J</code> while site/primary time period level covariates are specified as a matrix
with rows corresponding to sites and columns correspond to primary time periods.
Similarly, <code>det.covs</code> is a list of variables included in the detection
portion of the model, with each list element corresponding to an 
individual variable. In addition to site-level and/or site/primary time period-level, 
detection covariates can also be observational-level. Observation-level covariates
are specified as a three-dimensional array with first dimension corresponding to 
sites, second dimension corresponding to primary time period, and third 
dimension corresponding to replicate. 
<code>coords</code> is a matrix of the observation coordinates used
to estimate the spatial random effect for each site. <code>coords</code> has two columns for the 
easting and northing coordinate, respectively. Typically, each site in the data 
set will have it's own coordinate, such that <code>coords</code> is a <code class="reqn">J \times 2</code> 
matrix and <code>grid.index</code> should not be specified. 
If you desire to estimate spatial random effects at some larger spatial level, 
e.g., if points fall within grid cells and you want to estimate a spatial random effect for 
each grid cell instead of each point, <code>coords</code> can be specified as the coordinate for 
each grid cell. In such a case, <code>grid.index</code> is an indexing vector of length J, where each 
value of <code>grid.index</code> indicates the corresponding row in <code>coords</code> that the given 
site corresponds to. Note that <code>spOccupancy</code> assumes coordinates are specified 
in a projected coordinate system.</p>
</td></tr>
<tr><td><code id="stPGOcc_+3A_inits">inits</code></td>
<td>
<p>a list with each tag corresponding to a parameter name.
Valid tags are <code>z</code>, <code>beta</code>, <code>alpha</code>, <code>sigma.sq</code>, <code>phi</code>, 
<code>w</code>, <code>nu</code>, <code>sigma.sq.psi</code>, <code>sigma.sq.p</code>, <code>sigma.sq.t</code>, 
<code>rho</code>. The value portion of each tag is the 
parameter's initial value. <code>sigma.sq.psi</code> and <code>sigma.sq.p</code> are 
only relevant when including random effects in the occurrence and 
detection portion of the occupancy model, respectively. <code>nu</code> is only
specified if <code>cov.model = "matern"</code>. <code>sigma.sq.t</code> and <code>rho</code> 
are only relevant when <code>ar1 = TRUE</code>. See <code>priors</code> 
description for definition of each parameter name.
Additionally, the tag <code>fix</code> can be set to <code>TRUE</code> 
to fix the starting values across all chains. If <code>fix</code> is not specified
(the default), starting values are varied randomly across chains.</p>
</td></tr>
<tr><td><code id="stPGOcc_+3A_priors">priors</code></td>
<td>
<p>a list with each tag corresponding to a parameter name. 
Valid tags are <code>beta.normal</code>, <code>alpha.normal</code>, <code>sigma.sq.psi.ig</code>, 
<code>sigma.sq.p.ig</code>, <code>phi.unif</code>, <code>sigma.sq.ig</code>, <code>nu.unif</code>, 
<code>sigma.sq.t.ig</code>, and <code>rho.unif</code>. 
Occupancy (<code>beta</code>) and detection (<code>alpha</code>) 
regression coefficients are assumed to follow a normal distribution. 
The hyperparameters of the normal distribution are passed as a list of 
length two with the first and second elements corresponding to the mean 
and variance of the normal distribution, which are each specified as vectors of 
length equal to the number of coefficients to be estimated or of length one
if priors are the same for all coefficients. If not specified, prior means 
are set to 0 and prior variances set to 2.72. <code>sigma.sq.psi</code> and 
<code>sigma.sq.p</code> are the random effect variances for any occurrence or 
detection random effects, respectively, and are assumed to follow an inverse
Gamma distribution. The hyperparameters of the inverse-Gamma distribution
are passed as a list of length two with first and second elements corresponding
to the shape and scale parameters, respectively, which are each specified as
vectors of length equal to the number of random intercepts or of length one 
if priors are the same for all random effect variances. The spatial variance
parameter, <code>sigma.sq</code>, is assumed to follow an inverse-Gamma distribution. 
The spatial decay <code>phi</code> and smoothness <code>nu</code> parameters are assumed 
to follow Uniform distributions. The hyperparameters of the inverse-Gamma for 
<code>sigma.sq.ig</code> are passed as a vector of length two, with the first and second
elements corresponding to the shape and scale parameters, respectively. The 
hyperparameters of the uniform are also passed as a vector of length two
with the first and second elements corresponding to the lower and upper support, 
respectively. <code>sigma.sq.t</code> and 
<code>rho</code> are the AR(1) variance and correlation parameters for the AR(1) zero-mean
temporal random effects, respectively. <code>sigma.sq.t</code> is assumed to follow an inverse-Gamma
distribution, where the hyperparameters are specified as a vector with elements
corresponding to the shape and scale parameters, respectively. <code>rho</code> is 
assumed to follow a uniform distribution, where the hyperparameters are specified in 
a vector of length two with elements corresponding to the lower and upper bounds of
the uniform prior.</p>
</td></tr>
<tr><td><code id="stPGOcc_+3A_cov.model">cov.model</code></td>
<td>
<p>a quoted keyword that specifies the covariance
function used to model the spatial dependence structure among the
observations.  Supported covariance model key words are:
<code>"exponential"</code>, <code>"matern"</code>, <code>"spherical"</code>, and
<code>"gaussian"</code>.</p>
</td></tr>
<tr><td><code id="stPGOcc_+3A_tuning">tuning</code></td>
<td>
<p>a list with each tag corresponding to a parameter
name. Valid tags are <code>phi</code>, <code>nu</code>, and <code>rho</code>. The value portion of each
tag defines the initial variance of the Adaptive sampler. See
Roberts and Rosenthal (2009) for details.</p>
</td></tr>
<tr><td><code id="stPGOcc_+3A_nngp">NNGP</code></td>
<td>
<p>if <code>TRUE</code>, model is fit with an NNGP. If <code>FALSE</code>, 
a full Gaussian process is used. See Datta et al. (2016) and 
Finley et al. (2019) for more information. Currently only <code>NNGP = TRUE</code> is
supported for multi-season single-species trend occupancy models.</p>
</td></tr>
<tr><td><code id="stPGOcc_+3A_n.neighbors">n.neighbors</code></td>
<td>
<p>number of neighbors used in the NNGP. Only used if 
<code>NNGP = TRUE</code>. Datta et al. (2016) showed that 15 neighbors is usually 
sufficient, but that as few as 5 neighbors can be adequate for certain data
sets, which can lead to even greater decreases in run time. We recommend
starting with 15 neighbors (the default) and if additional gains in computation
time are desired, subsequently compare the results with a smaller number
of neighbors using WAIC or k-fold cross-validation.</p>
</td></tr>
<tr><td><code id="stPGOcc_+3A_search.type">search.type</code></td>
<td>
<p>a quoted keyword that specifies the type of nearest
neighbor search algorithm. Supported method key words are: <code>"cb"</code> and
<code>"brute"</code>. The <code>"cb"</code> should generally be much
faster. If locations do not have identical coordinate values on
the axis used for the nearest neighbor ordering then <code>"cb"</code> 
and <code>"brute"</code> should produce identical neighbor sets. 
However, if there are identical coordinate values on the axis used 
for nearest neighbor ordering, then <code>"cb"</code> and <code>"brute"</code> 
might produce different, but equally valid, neighbor sets, 
e.g., if data are on a grid. </p>
</td></tr>
<tr><td><code id="stPGOcc_+3A_n.batch">n.batch</code></td>
<td>
<p>the number of MCMC batches in each chain to run for the Adaptive MCMC 
sampler. See Roberts and Rosenthal (2009) for details.</p>
</td></tr>
<tr><td><code id="stPGOcc_+3A_batch.length">batch.length</code></td>
<td>
<p>the length of each MCMC batch in each chain to run for the Adaptive 
MCMC sampler. See Roberts and Rosenthal (2009) for details.</p>
</td></tr>
<tr><td><code id="stPGOcc_+3A_accept.rate">accept.rate</code></td>
<td>
<p>target acceptance rate for Adaptive MCMC. Default is 
0.43. See Roberts and Rosenthal (2009) for details.</p>
</td></tr>
<tr><td><code id="stPGOcc_+3A_n.omp.threads">n.omp.threads</code></td>
<td>
<p>a positive integer indicating the number of threads
to use for SMP parallel processing. The package must be compiled for 
OpenMP support. For most Intel-based machines, we recommend setting 
<code>n.omp.threads</code> up to the number of hyperthreaded cores. Note, 
<code>n.omp.threads</code> &gt; 1 might not work on some systems. Currently only 
relevant for spatial models.</p>
</td></tr>
<tr><td><code id="stPGOcc_+3A_verbose">verbose</code></td>
<td>
<p>if <code>TRUE</code>, messages about data preparation, 
model specification, and progress of the sampler are printed to the screen. 
Otherwise, no messages are printed.</p>
</td></tr>
<tr><td><code id="stPGOcc_+3A_ar1">ar1</code></td>
<td>
<p>logical value indicating whether to include an AR(1) zero-mean
temporal random effect in the model. If <code>FALSE</code>, the model is
fit without an AR(1) temporal autocovariance structure. If <code>TRUE</code>,
an AR(1) random effect is included in the model to account for temporal
autocorrelation across the primary time periods.</p>
</td></tr>
<tr><td><code id="stPGOcc_+3A_n.report">n.report</code></td>
<td>
<p>the interval to report MCMC progress.</p>
</td></tr>
<tr><td><code id="stPGOcc_+3A_n.burn">n.burn</code></td>
<td>
<p>the number of samples out of the total <code>n.samples</code> to 
discard as burn-in for each chain. By default, the first 10% of samples is discarded.</p>
</td></tr>
<tr><td><code id="stPGOcc_+3A_n.thin">n.thin</code></td>
<td>
<p>the thinning interval for collection of MCMC samples. The
thinning occurs after the <code>n.burn</code> samples are discarded. Default 
value is set to 1.</p>
</td></tr>
<tr><td><code id="stPGOcc_+3A_n.chains">n.chains</code></td>
<td>
<p>the number of chains to run in sequence.</p>
</td></tr>
<tr><td><code id="stPGOcc_+3A_k.fold">k.fold</code></td>
<td>
<p>specifies the number of <em>k</em> folds for cross-validation. 
If not specified as an argument, then cross-validation is not performed
and <code>k.fold.threads</code> and <code>k.fold.seed</code> are ignored. In <em>k</em>-fold
cross-validation, the data specified in <code>data</code> is randomly
partitioned into <em>k</em> equal sized subsamples. Of the <em>k</em> subsamples, 
<em>k</em> - 1 subsamples are used to fit the model and the remaining <em>k</em>
samples are used for prediction. The cross-validation process is repeated 
<em>k</em> times (the folds). As a scoring rule, we use the model deviance 
as described in Hooten and Hobbs (2015). For cross-validation in multi-season
models, the data are split along the site dimension, such that each hold-out
data set consists of a <code>J / k.fold</code> sites sampled over all primary time
periods during which data are available at each given site. Cross-validation is performed
after the full model is fit using all the data. Cross-validation results
are reported in the <code>k.fold.deviance</code> object in the return list.</p>
</td></tr>
<tr><td><code id="stPGOcc_+3A_k.fold.threads">k.fold.threads</code></td>
<td>
<p>number of threads to use for cross-validation. If 
<code>k.fold.threads &gt; 1</code> parallel processing is accomplished using the 
<span class="pkg">foreach</span> and <span class="pkg">doParallel</span> packages. Ignored if <code>k.fold</code>
is not specified.</p>
</td></tr> 
<tr><td><code id="stPGOcc_+3A_k.fold.seed">k.fold.seed</code></td>
<td>
<p>seed used to split data set into <code>k.fold</code> parts
for k-fold cross-validation. Ignored if <code>k.fold</code> is not specified.</p>
</td></tr>
<tr><td><code id="stPGOcc_+3A_k.fold.only">k.fold.only</code></td>
<td>
<p>a logical value indicating whether to only perform 
cross-validation (<code>TRUE</code>) or perform cross-validation after fitting 
the full model (<code>FALSE</code>). Default value is <code>FALSE</code>.</p>
</td></tr> 
<tr><td><code id="stPGOcc_+3A_...">...</code></td>
<td>
<p>currently no additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>stPGOcc</code> that is a list comprised of: 
</p>
<table>
<tr><td><code>beta.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the occupancy regression coefficients.</p>
</td></tr>
<tr><td><code>alpha.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the detection regression coefficients.</p>
</td></tr>
<tr><td><code>z.samples</code></td>
<td>
<p>a three-dimensional array of posterior samples 
for the latent occupancy values, with dimensions corresponding to 
posterior sample, site, and primary time period.</p>
</td></tr>
<tr><td><code>psi.samples</code></td>
<td>
<p>a three-dimensional array of posterior samples
for the latent occupancy probability values, with dimensions 
corresponding to posterior sample, site, and primary time period.</p>
</td></tr>
<tr><td><code>theta.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for spatial covariance parameters and temporal covariance parameters
if <code>ar1 = TRUE</code>.</p>
</td></tr>
<tr><td><code>w.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for latent spatial random effects.</p>
</td></tr>
<tr><td><code>sigma.sq.psi.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for variances of random intercepts included in the occupancy portion
of the model. Only included if random intercepts are specified in 
<code>occ.formula</code>.</p>
</td></tr>
<tr><td><code>sigma.sq.p.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for variances of random intercpets included in the detection portion 
of the model. Only included if random intercepts are specified in 
<code>det.formula</code>.</p>
</td></tr>
<tr><td><code>beta.star.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the occurrence random effects. Only included if random intercepts
are specified in <code>occ.formula</code>.</p>
</td></tr>
<tr><td><code>alpha.star.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the detection random effects. Only included if random intercepts 
are specified in <code>det.formula</code>.</p>
</td></tr>
<tr><td><code>eta.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples for the 
AR(1) random effects for each primary time period. Only included if 
<code>ar1 = TRUE</code></p>
</td></tr></table>
<p>.
</p>
<table>
<tr><td><code>like.samples</code></td>
<td>
<p>a three-dimensional array of posterior samples
for the likelihood values associated with each site and primary
time period. Used for calculating WAIC.</p>
</td></tr>
<tr><td><code>rhat</code></td>
<td>
<p>a list of Gelman-Rubin diagnostic values for some of the model
parameters.</p>
</td></tr>
<tr><td><code>ESS</code></td>
<td>
<p>a list of effective sample sizes for some of the model parameters.</p>
</td></tr>
<tr><td><code>run.time</code></td>
<td>
<p>execution time reported using <code>proc.time()</code>.</p>
</td></tr>
<tr><td><code>k.fold.deviance</code></td>
<td>
<p>scoring rule (deviance) from k-fold cross-validation. 
Only included if <code>k.fold</code> is specified in function call.</p>
</td></tr>
</table>
<p>The return object will include additional objects used for 
subsequent prediction and/or model fit evaluation. Note that detection
probability estimated values are not included in the model object, but can be 
extracted using <code>fitted()</code>. Note that if <code>k.fold.only = TRUE</code>, the
return list object will only contain <code>run.time</code> and <code>k.fold.deviance</code>.
</p>


<h3>Note</h3>

<p>Some of the underlying code used for generating random numbers from the
Polya-Gamma distribution is taken from the <span class="pkg">pgdraw</span> package written
by Daniel F. Schmidt and Enes Makalic. Their code implements Algorithm
6 in PhD thesis of Jesse Bennett Windle (2013) <a href="https://repositories.lib.utexas.edu/handle/2152/21842">https://repositories.lib.utexas.edu/handle/2152/21842</a>.
</p>


<h3>Author(s)</h3>

<p>Jeffrey W. Doser <a href="mailto:doserjef@msu.edu">doserjef@msu.edu</a>, <br />
Andrew O. Finley <a href="mailto:finleya@msu.edu">finleya@msu.edu</a>
</p>


<h3>References</h3>

<p>Polson, N.G., J.G. Scott, and J. Windle. (2013) Bayesian Inference for
Logistic Models Using Polya-Gamma Latent Variables. 
<em>Journal of the American Statistical Association</em>, 108:1339-1349.
</p>
<p>Bates, Douglas, Martin Maechler, Ben Bolker, Steve Walker (2015).
Fitting Linear Mixed-Effects Models Using lme4. Journal of
Statistical Software, 67(1), 1-48. <a href="https://doi.org/10.18637/jss.v067.i01">doi:10.18637/jss.v067.i01</a>.
</p>
<p>Kery, M., &amp; Royle, J. A. (2021). Applied hierarchical modeling in ecology: 
Analysis of distribution, abundance and species richness in R and BUGS: 
Volume 2: Dynamic and advanced models. Academic Press. Section 4.6.
</p>
<p>Hooten, M. B., and Hobbs, N. T. (2015). A guide to Bayesian model 
selection for ecologists. Ecological monographs, 85(1), 3-28.
</p>
<p>MacKenzie, D. I., J. D. Nichols, G. B. Lachman, S. Droege, 
J. Andrew Royle, and C. A. Langtimm. 2002. Estimating Site Occupancy 
Rates When Detection Probabilities Are Less Than One. Ecology 83: 2248-2255.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(500)
# Sites
J.x &lt;- 10
J.y &lt;- 10
J &lt;- J.x * J.y
# Primary time periods
n.time &lt;- sample(10, J, replace = TRUE)
n.time.max &lt;- max(n.time)
# Replicates
n.rep &lt;- matrix(NA, J, max(n.time))
for (j in 1:J) {
  n.rep[j, 1:n.time[j]] &lt;- sample(1:4, n.time[j], replace = TRUE)
}
# Occurrence --------------------------
beta &lt;- c(0.4, 0.5, -0.9)
trend &lt;- TRUE 
sp.only &lt;- 0
psi.RE &lt;- list()
# Detection ---------------------------
alpha &lt;- c(-1, 0.7, -0.5)
p.RE &lt;- list()
# Spatial -----------------------------
sp &lt;- TRUE
cov.model &lt;- "exponential"
sigma.sq &lt;- 2
phi &lt;- 3 / .4
# Temporal ----------------------------
rho &lt;- 0.5
sigma.sq.t &lt;- 1

# Get all the data
dat &lt;- simTOcc(J.x = J.x, J.y = J.y, n.time = n.time, n.rep = n.rep, 
               beta = beta, alpha = alpha, sp.only = sp.only, trend = trend, 
               psi.RE = psi.RE, p.RE = p.RE, sp = TRUE, sigma.sq = sigma.sq, 
               phi = phi, cov.model = cov.model, ar1 = TRUE, 
               sigma.sq.t = sigma.sq.t, rho = rho)

# Package all data into a list
# Occurrence
occ.covs &lt;- list(int = dat$X[, , 1], 
                 trend = dat$X[, , 2], 
                 occ.cov.1 = dat$X[, , 3]) 
# Detection
det.covs &lt;- list(det.cov.1 = dat$X.p[, , , 2], 
                 det.cov.2 = dat$X.p[, , , 3]) 
# Data list bundle
data.list &lt;- list(y = dat$y, 
                  occ.covs = occ.covs,
                  det.covs = det.covs, 
                  coords = dat$coords) 
# Priors
prior.list &lt;- list(beta.normal = list(mean = 0, var = 2.72), 
                   alpha.normal = list(mean = 0, var = 2.72), 
                   sigma.sq.ig = c(2, 2), 
                   phi.unif = c(3 / 1, 3 / 0.1), 
                   rho.unif = c(-1, 1),
                   sigma.sq.t.ig = c(2, 1))

# Initial values
z.init &lt;- apply(dat$y, c(1, 2), function(a) as.numeric(sum(a, na.rm = TRUE) &gt; 0))
inits.list &lt;- list(beta = 0, alpha = 0, z = z.init, phi = 3 / .5, sigma.sq = 2, 
                   w = rep(0, J), rho = 0, sigma.sq.t = 0.5)
# Tuning
tuning.list &lt;- list(phi = 1, rho = 1)
# Number of batches
n.batch &lt;- 10
# Batch length
batch.length &lt;- 25
n.iter &lt;- n.batch * batch.length

# Run the model
out &lt;- stPGOcc(occ.formula = ~ trend + occ.cov.1, 
               det.formula = ~ det.cov.1 + det.cov.2, 
               data = data.list, 
               inits = inits.list, 
               n.batch = n.batch, 
               batch.length = batch.length, 
               priors = prior.list,
               cov.model = "exponential", 
               tuning = tuning.list, 
               NNGP = TRUE, 
               ar1 = TRUE,
               n.neighbors = 5, 
               search.type = 'cb', 
               n.report = 10, 
               n.burn = 50, 
               n.chains = 1)

summary(out)
</code></pre>

<hr>
<h2 id='summary.intMsPGOcc'>Methods for intMsPGOcc Object</h2><span id='topic+summary.intMsPGOcc'></span><span id='topic+print.intMsPGOcc'></span><span id='topic+plot.intMsPGOcc'></span>

<h3>Description</h3>

<p>Methods for extracting information from fitted integrated multi-species occupancy (<code>intMsPGOcc</code>) models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'intMsPGOcc'
summary(object, level = 'both', quantiles = c(0.025, 0.5, 0.975), 
        digits = max(3L, getOption("digits") - 3L), ...)
## S3 method for class 'intMsPGOcc'
print(x, ...)
## S3 method for class 'intMsPGOcc'
plot(x, param, density = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.intMsPGOcc_+3A_object">object</code>, <code id="summary.intMsPGOcc_+3A_x">x</code></td>
<td>
<p>object of class <code>intMsPGOcc</code>.</p>
</td></tr>
<tr><td><code id="summary.intMsPGOcc_+3A_level">level</code></td>
<td>
<p>a quoted keyword that indicates the level to summarize the 
model results. Valid key words are: <code>"community"</code>, 
<code>"species"</code>, or <code>"both"</code>.</p>
</td></tr>
<tr><td><code id="summary.intMsPGOcc_+3A_quantiles">quantiles</code></td>
<td>
<p>for <code>summary</code>, posterior distribution quantiles to compute.</p>
</td></tr>
<tr><td><code id="summary.intMsPGOcc_+3A_digits">digits</code></td>
<td>
<p>for <code>summary</code>, number of digits to report.</p>
</td></tr>
<tr><td><code id="summary.intMsPGOcc_+3A_param">param</code></td>
<td>
<p>parameter name for which to generate a traceplot. Valid names are 
<code>"beta", "beta.comm", "tau.sq.beta", 
		     "alpha", "tau.sq.alpha"</code>.</p>
</td></tr>
<tr><td><code id="summary.intMsPGOcc_+3A_density">density</code></td>
<td>
<p>logical value indicating whether to also generate a density plot for each parameter
in addition to the MCMC traceplot.</p>
</td></tr>
<tr><td><code id="summary.intMsPGOcc_+3A_...">...</code></td>
<td>
<p>currently no additional arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A set of standard extractor functions for fitted model objects of
class <code>intMsPGOcc</code>, including methods to the generic functions <code><a href="base.html#topic+print">print</a></code>, <code><a href="base.html#topic+summary">summary</a></code>, and <code><a href="base.html#topic+plot">plot</a></code>. 
</p>


<h3>Value</h3>

<p>No return value, called to display summary information of a <code>intMsPGOcc</code> object.
</p>

<hr>
<h2 id='summary.intPGOcc'>Methods for intPGOcc Object</h2><span id='topic+summary.intPGOcc'></span><span id='topic+print.intPGOcc'></span><span id='topic+plot.intPGOcc'></span>

<h3>Description</h3>

<p>Methods for extracting information from fitted single species integrated occupancy (<code>intPGOcc</code>) model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'intPGOcc'
summary(object, quantiles = c(0.025, 0.5, 0.975), 
        digits = max(3L, getOption("digits") - 3L), ...)
## S3 method for class 'intPGOcc'
print(x, ...)
## S3 method for class 'intPGOcc'
plot(x, param, density = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.intPGOcc_+3A_object">object</code>, <code id="summary.intPGOcc_+3A_x">x</code></td>
<td>
<p>object of class <code>intPGOcc</code>.</p>
</td></tr>
<tr><td><code id="summary.intPGOcc_+3A_quantiles">quantiles</code></td>
<td>
<p>for <code>summary</code>, posterior distribution quantiles to compute.</p>
</td></tr>
<tr><td><code id="summary.intPGOcc_+3A_digits">digits</code></td>
<td>
<p>for <code>summary</code>, number of digits to report.</p>
</td></tr>
<tr><td><code id="summary.intPGOcc_+3A_param">param</code></td>
<td>
<p>parameter name for which to generate a traceplot. Valid names are 
<code>"beta", "alpha"</code>.</p>
</td></tr>
<tr><td><code id="summary.intPGOcc_+3A_density">density</code></td>
<td>
<p>logical value indicating whether to also generate a density plot for each parameter
in addition to the MCMC traceplot.</p>
</td></tr>
<tr><td><code id="summary.intPGOcc_+3A_...">...</code></td>
<td>
<p>currently no additional arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A set of standard extractor functions for fitted model objects of
class <code>intPGOcc</code>, including methods to the generic functions <code><a href="base.html#topic+print">print</a></code>, <code><a href="base.html#topic+summary">summary</a></code>, and <code><a href="base.html#topic+plot">plot</a></code>. 
</p>


<h3>Value</h3>

<p>No return value, called to display summary information of a <code>intPGOcc</code> object.
</p>

<hr>
<h2 id='summary.lfJSDM'>Methods for lfJSDM Object</h2><span id='topic+summary.lfJSDM'></span><span id='topic+print.lfJSDM'></span><span id='topic+plot.lfJSDM'></span>

<h3>Description</h3>

<p>Methods for extracting information from a fitted latent factor joint species distribution model (<code>lfJSDM</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lfJSDM'
summary(object, level = 'both', quantiles = c(0.025, 0.5, 0.975), 
        digits = max(3L, getOption("digits") - 3L), ...)
## S3 method for class 'lfJSDM'
print(x, ...)
## S3 method for class 'lfJSDM'
plot(x, param, density = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.lfJSDM_+3A_object">object</code>, <code id="summary.lfJSDM_+3A_x">x</code></td>
<td>
<p>object of class <code>lfJSDM</code>.</p>
</td></tr>
<tr><td><code id="summary.lfJSDM_+3A_level">level</code></td>
<td>
<p>a quoted keyword that indicates the level to summarize the 
model results. Valid key words are: <code>"community"</code>, 
<code>"species"</code>, or <code>"both"</code>.</p>
</td></tr>
<tr><td><code id="summary.lfJSDM_+3A_quantiles">quantiles</code></td>
<td>
<p>for <code>summary</code>, posterior distribution quantiles to compute.</p>
</td></tr>
<tr><td><code id="summary.lfJSDM_+3A_digits">digits</code></td>
<td>
<p>for <code>summary</code>, number of digits to report.</p>
</td></tr>
<tr><td><code id="summary.lfJSDM_+3A_param">param</code></td>
<td>
<p>parameter name for which to generate a traceplot. Valid names are 
<code>"beta", "beta.star", "sigma.sq.psi", "beta.comm", "tau.sq.beta", 
		     "lambda"</code>.</p>
</td></tr>
<tr><td><code id="summary.lfJSDM_+3A_density">density</code></td>
<td>
<p>logical value indicating whether to also generate a density plot for each parameter
in addition to the MCMC traceplot.</p>
</td></tr>
<tr><td><code id="summary.lfJSDM_+3A_...">...</code></td>
<td>
<p>currently no additional arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A set of standard extractor functions for fitted model objects of
class <code>lfJSDM</code>, including methods to the generic functions <code><a href="base.html#topic+print">print</a></code>, <code><a href="base.html#topic+summary">summary</a></code>, and <code><a href="base.html#topic+plot">plot</a></code>. 
</p>


<h3>Value</h3>

<p>No return value, called to display summary information of a <code>lfJSDM</code> object.
</p>

<hr>
<h2 id='summary.lfMsPGOcc'>Methods for lfMsPGOcc Object</h2><span id='topic+summary.lfMsPGOcc'></span><span id='topic+print.lfMsPGOcc'></span><span id='topic+plot.lfMsPGOcc'></span>

<h3>Description</h3>

<p>Methods for extracting information from a fitted latent factor multi-species occupancy model (<code>lfMsPGOcc</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lfMsPGOcc'
summary(object, level = 'both', quantiles = c(0.025, 0.5, 0.975), 
        digits = max(3L, getOption("digits") - 3L), ...)
## S3 method for class 'lfMsPGOcc'
print(x, ...)
## S3 method for class 'lfMsPGOcc'
plot(x, param, density = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.lfMsPGOcc_+3A_object">object</code>, <code id="summary.lfMsPGOcc_+3A_x">x</code></td>
<td>
<p>object of class <code>lfMsPGOcc</code>.</p>
</td></tr>
<tr><td><code id="summary.lfMsPGOcc_+3A_level">level</code></td>
<td>
<p>a quoted keyword that indicates the level to summarize the 
model results. Valid key words are: <code>"community"</code>, 
<code>"species"</code>, or <code>"both"</code>.</p>
</td></tr>
<tr><td><code id="summary.lfMsPGOcc_+3A_quantiles">quantiles</code></td>
<td>
<p>for <code>summary</code>, posterior distribution quantiles to compute.</p>
</td></tr>
<tr><td><code id="summary.lfMsPGOcc_+3A_digits">digits</code></td>
<td>
<p>for <code>summary</code>, number of digits to report.</p>
</td></tr>
<tr><td><code id="summary.lfMsPGOcc_+3A_param">param</code></td>
<td>
<p>parameter name for which to generate a traceplot. Valid names are 
<code>"beta", "beta.star", "sigma.sq.psi", "beta.comm", "tau.sq.beta", 
		     "alpha", "alpha.star", "sigma.sq.p", "alpha.comm", "tau.sq.alpha", 
		     "lambda"</code>.</p>
</td></tr>
<tr><td><code id="summary.lfMsPGOcc_+3A_density">density</code></td>
<td>
<p>logical value indicating whether to also generate a density plot for each parameter
in addition to the MCMC traceplot.</p>
</td></tr>
<tr><td><code id="summary.lfMsPGOcc_+3A_...">...</code></td>
<td>
<p>currently no additional arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A set of standard extractor functions for fitted model objects of
class <code>lfMsPGOcc</code>, including methods to the generic functions <code><a href="base.html#topic+print">print</a></code>, <code><a href="base.html#topic+summary">summary</a></code>, and <code><a href="base.html#topic+plot">plot</a></code>. 
</p>


<h3>Value</h3>

<p>No return value, called to display summary information of a <code>lfMsPGOcc</code> object.
</p>

<hr>
<h2 id='summary.msPGOcc'>Methods for msPGOcc Object</h2><span id='topic+summary.msPGOcc'></span><span id='topic+print.msPGOcc'></span><span id='topic+plot.msPGOcc'></span>

<h3>Description</h3>

<p>Methods for extracting information from fitted multi-species occupancy (<code>msPGOcc</code>) model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'msPGOcc'
summary(object, level = 'both', quantiles = c(0.025, 0.5, 0.975), 
        digits = max(3L, getOption("digits") - 3L), ...)
## S3 method for class 'msPGOcc'
print(x, ...)
## S3 method for class 'msPGOcc'
plot(x, param, density = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.msPGOcc_+3A_object">object</code>, <code id="summary.msPGOcc_+3A_x">x</code></td>
<td>
<p>object of class <code>msPGOcc</code>.</p>
</td></tr>
<tr><td><code id="summary.msPGOcc_+3A_level">level</code></td>
<td>
<p>a quoted keyword that indicates the level to summarize the 
model results. Valid key words are: <code>"community"</code>, 
<code>"species"</code>, or <code>"both"</code>.</p>
</td></tr>
<tr><td><code id="summary.msPGOcc_+3A_quantiles">quantiles</code></td>
<td>
<p>for <code>summary</code>, posterior distribution quantiles to compute.</p>
</td></tr>
<tr><td><code id="summary.msPGOcc_+3A_digits">digits</code></td>
<td>
<p>for <code>summary</code>, number of digits to report.</p>
</td></tr>
<tr><td><code id="summary.msPGOcc_+3A_param">param</code></td>
<td>
<p>parameter name for which to generate a traceplot. Valid names are 
<code>"beta", "beta.star", "sigma.sq.psi", "beta.comm", "tau.sq.beta", 
		     "alpha", "alpha.star", "sigma.sq.p", "alpha.comm", "tau.sq.alpha"</code>.</p>
</td></tr>
<tr><td><code id="summary.msPGOcc_+3A_density">density</code></td>
<td>
<p>logical value indicating whether to also generate a density plot for each parameter
in addition to the MCMC traceplot.</p>
</td></tr>
<tr><td><code id="summary.msPGOcc_+3A_...">...</code></td>
<td>
<p>currently no additional arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A set of standard extractor functions for fitted model objects of
class <code>msPGOcc</code>, including methods to the generic functions <code><a href="base.html#topic+print">print</a></code>, <code><a href="base.html#topic+summary">summary</a></code>, and <code><a href="base.html#topic+plot">plot</a></code>. 
</p>


<h3>Value</h3>

<p>No return value, called to display summary information of a <code>msPGOcc</code> object.
</p>

<hr>
<h2 id='summary.PGOcc'>Methods for PGOcc Object</h2><span id='topic+summary.PGOcc'></span><span id='topic+print.PGOcc'></span><span id='topic+plot.PGOcc'></span>

<h3>Description</h3>

<p>Methods for extracting information from fitted single-species occupancy (<code>PGOcc</code>) model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'PGOcc'
summary(object, quantiles = c(0.025, 0.5, 0.975), 
        digits = max(3L, getOption("digits") - 3L), ...)
## S3 method for class 'PGOcc'
print(x, ...)
## S3 method for class 'PGOcc'
plot(x, param, density = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.PGOcc_+3A_object">object</code>, <code id="summary.PGOcc_+3A_x">x</code></td>
<td>
<p>object of class <code>PGOcc</code>.</p>
</td></tr>
<tr><td><code id="summary.PGOcc_+3A_quantiles">quantiles</code></td>
<td>
<p>for <code>summary</code>, posterior distribution quantiles to compute.</p>
</td></tr>
<tr><td><code id="summary.PGOcc_+3A_digits">digits</code></td>
<td>
<p>for <code>summary</code>, number of digits to report.</p>
</td></tr>
<tr><td><code id="summary.PGOcc_+3A_param">param</code></td>
<td>
<p>parameter name for which to generate a traceplot. Valid names are 
<code>"beta", "beta.star", "sigma.sq.psi", "alpha", "alpha.star", "sigma.sq.p"</code>.</p>
</td></tr>
<tr><td><code id="summary.PGOcc_+3A_density">density</code></td>
<td>
<p>logical value indicating whether to also generate a density plot for each parameter
in addition to the MCMC traceplot.</p>
</td></tr>
<tr><td><code id="summary.PGOcc_+3A_...">...</code></td>
<td>
<p>currently no additional arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A set of standard extractor functions for fitted model objects of
class <code>PGOcc</code>, including methods to the generic functions <code><a href="base.html#topic+print">print</a></code>, <code><a href="base.html#topic+summary">summary</a></code>, and <code><a href="base.html#topic+plot">plot</a></code>. 
</p>


<h3>Value</h3>

<p>No return value, called to display summary information of a <code>PGOcc</code> object.
</p>

<hr>
<h2 id='summary.postHocLM'>Methods for postHocLM Object</h2><span id='topic+summary.postHocLM'></span><span id='topic+print.postHocLM'></span>

<h3>Description</h3>

<p>Methods for extracting information from fitted posthoc linear models (<code>postHocLM</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'postHocLM'
summary(object, quantiles = c(0.025, 0.5, 0.975), 
        digits = max(3L, getOption("digits") - 3L), ...)
## S3 method for class 'postHocLM'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.postHocLM_+3A_object">object</code>, <code id="summary.postHocLM_+3A_x">x</code></td>
<td>
<p>object of class <code>postHocLM</code>.</p>
</td></tr>
<tr><td><code id="summary.postHocLM_+3A_quantiles">quantiles</code></td>
<td>
<p>for <code>summary</code>, posterior distribution quantiles to compute.</p>
</td></tr>
<tr><td><code id="summary.postHocLM_+3A_digits">digits</code></td>
<td>
<p>for <code>summary</code>, number of digits to report.</p>
</td></tr>
<tr><td><code id="summary.postHocLM_+3A_...">...</code></td>
<td>
<p>currently no additional arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A set of standard extractor functions for fitted model objects of
class <code>postHocLM</code>, including methods to the generic functions <code><a href="base.html#topic+print">print</a></code> and <code><a href="base.html#topic+summary">summary</a></code>. 
</p>


<h3>Value</h3>

<p>No return value, called to display summary information of a <code>postHocLM</code> object.
</p>

<hr>
<h2 id='summary.ppcOcc'>Methods for ppcOcc Object</h2><span id='topic+summary.ppcOcc'></span>

<h3>Description</h3>

<p>Methods for extracting information from posterior predictive check objects of class <code>ppcOcc</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ppcOcc'
summary(object, level, digits = max(3L, getOption("digits") - 3L), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.ppcOcc_+3A_object">object</code></td>
<td>
<p>object of class <code>ppcOcc</code>.</p>
</td></tr>
<tr><td><code id="summary.ppcOcc_+3A_level">level</code></td>
<td>
<p>a quoted keyword for multi-species models that indicates 
the level to summarize the posterior predictive check. Valid key words
are: <code>"community"</code>, <code>"species"</code>, or <code>"both"</code>.</p>
</td></tr>
<tr><td><code id="summary.ppcOcc_+3A_digits">digits</code></td>
<td>
<p>number of digits to report.</p>
</td></tr>
<tr><td><code id="summary.ppcOcc_+3A_...">...</code></td>
<td>
<p>currently no additional arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A set of standard extractor functions for fitted posterior predictive
check objects of class <code>ppcOcc</code>, including methods to the generic function
<code><a href="base.html#topic+summary">summary</a></code>. 
</p>


<h3>Value</h3>

<p>No return value, called to display summary information of a <code>ppcOcc</code> object.
</p>

<hr>
<h2 id='summary.sfJSDM'>Methods for sfJSDM Object</h2><span id='topic+summary.sfJSDM'></span><span id='topic+print.sfJSDM'></span><span id='topic+plot.sfJSDM'></span>

<h3>Description</h3>

<p>Methods for extracting information from fitted spatial factor joint species distribution models (<code>sfJSDM</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sfJSDM'
summary(object, level, quantiles = c(0.025, 0.5, 0.975), 
        digits = max(3L, getOption("digits") - 3L), ...)
## S3 method for class 'sfJSDM'
print(x, ...)
## S3 method for class 'sfJSDM'
plot(x, param, density = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.sfJSDM_+3A_object">object</code>, <code id="summary.sfJSDM_+3A_x">x</code></td>
<td>
<p>object of class <code>sfJSDM</code>.</p>
</td></tr>
<tr><td><code id="summary.sfJSDM_+3A_level">level</code></td>
<td>
<p>a quoted keyword that indicates the level to summarize the 
model results. Valid key words are: <code>"community"</code>, 
<code>"species"</code>, or <code>"both"</code>.</p>
</td></tr>
<tr><td><code id="summary.sfJSDM_+3A_quantiles">quantiles</code></td>
<td>
<p>for <code>summary</code>, posterior distribution quantiles to compute.</p>
</td></tr>
<tr><td><code id="summary.sfJSDM_+3A_digits">digits</code></td>
<td>
<p>for <code>summary</code>, number of digits to report.</p>
</td></tr>
<tr><td><code id="summary.sfJSDM_+3A_param">param</code></td>
<td>
<p>parameter name for which to generate a traceplot. Valid names are 
<code>"beta", "beta.star", "sigma.sq.psi", "beta.comm", "tau.sq.beta", 
		     "theta", "lambda"</code>.</p>
</td></tr>
<tr><td><code id="summary.sfJSDM_+3A_density">density</code></td>
<td>
<p>logical value indicating whether to also generate a density plot for each parameter
in addition to the MCMC traceplot.</p>
</td></tr>
<tr><td><code id="summary.sfJSDM_+3A_...">...</code></td>
<td>
<p>currently no additional arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A set of standard extractor functions for fitted model objects of
class <code>sfJSDM</code>, including methods to the generic functions <code><a href="base.html#topic+print">print</a></code>, <code><a href="base.html#topic+summary">summary</a></code>, and <code><a href="base.html#topic+plot">plot</a></code>. 
</p>


<h3>Value</h3>

<p>No return value, called to display summary information of a <code>sfJSDM</code> object.
</p>

<hr>
<h2 id='summary.sfMsPGOcc'>Methods for sfMsPGOcc Object</h2><span id='topic+summary.sfMsPGOcc'></span><span id='topic+print.sfMsPGOcc'></span><span id='topic+plot.sfMsPGOcc'></span>

<h3>Description</h3>

<p>Methods for extracting information from fitted spatial factor multi-species occupancy model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sfMsPGOcc'
summary(object, level, quantiles = c(0.025, 0.5, 0.975), 
        digits = max(3L, getOption("digits") - 3L), ...)
## S3 method for class 'sfMsPGOcc'
print(x, ...)
## S3 method for class 'sfMsPGOcc'
plot(x, param, density = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.sfMsPGOcc_+3A_object">object</code>, <code id="summary.sfMsPGOcc_+3A_x">x</code></td>
<td>
<p>object of class <code>sfMsPGOcc</code>.</p>
</td></tr>
<tr><td><code id="summary.sfMsPGOcc_+3A_level">level</code></td>
<td>
<p>a quoted keyword that indicates the level to summarize the 
model results. Valid key words are: <code>"community"</code>, 
<code>"species"</code>, or <code>"both"</code>.</p>
</td></tr>
<tr><td><code id="summary.sfMsPGOcc_+3A_quantiles">quantiles</code></td>
<td>
<p>for <code>summary</code>, posterior distribution quantiles to compute.</p>
</td></tr>
<tr><td><code id="summary.sfMsPGOcc_+3A_digits">digits</code></td>
<td>
<p>for <code>summary</code>, number of digits to report.</p>
</td></tr>
<tr><td><code id="summary.sfMsPGOcc_+3A_param">param</code></td>
<td>
<p>parameter name for which to generate a traceplot. Valid names are 
<code>"beta", "beta.star", "sigma.sq.psi", "beta.comm", "tau.sq.beta", 
		     "alpha", "alpha.star", "sigma.sq.p", "alpha.comm", "tau.sq.alpha", 
		     "lambda", "theta"</code>.</p>
</td></tr>
<tr><td><code id="summary.sfMsPGOcc_+3A_density">density</code></td>
<td>
<p>logical value indicating whether to also generate a density plot for each parameter
in addition to the MCMC traceplot.</p>
</td></tr>
<tr><td><code id="summary.sfMsPGOcc_+3A_...">...</code></td>
<td>
<p>currently no additional arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A set of standard extractor functions for fitted model objects of
class <code>sfMsPGOcc</code>, including methods to the generic functions <code><a href="base.html#topic+print">print</a></code>, <code><a href="base.html#topic+summary">summary</a></code>, and <code><a href="base.html#topic+plot">plot</a></code>. 
</p>


<h3>Value</h3>

<p>No return value, called to display summary information of a <code>sfMsPGOcc</code> object.
</p>

<hr>
<h2 id='summary.spIntPGOcc'>Methods for spIntPGOcc Object</h2><span id='topic+summary.spIntPGOcc'></span><span id='topic+print.spIntPGOcc'></span><span id='topic+plot.spIntPGOcc'></span>

<h3>Description</h3>

<p>Methods for extracting information from fitted single-species spatial integrated occupancy (<code>spIntPGOcc</code>) model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'spIntPGOcc'
summary(object, quantiles = c(0.025, 0.5, 0.975), 
        digits = max(3L, getOption("digits") - 3L), ...)
## S3 method for class 'spIntPGOcc'
print(x, ...)
## S3 method for class 'spIntPGOcc'
plot(x, param, density = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.spIntPGOcc_+3A_object">object</code>, <code id="summary.spIntPGOcc_+3A_x">x</code></td>
<td>
<p>object of class <code>spIntPGOcc</code>.</p>
</td></tr>
<tr><td><code id="summary.spIntPGOcc_+3A_quantiles">quantiles</code></td>
<td>
<p>for <code>summary</code>, posterior distribution quantiles to compute.</p>
</td></tr>
<tr><td><code id="summary.spIntPGOcc_+3A_digits">digits</code></td>
<td>
<p>for <code>summary</code>, number of digits to report.</p>
</td></tr>
<tr><td><code id="summary.spIntPGOcc_+3A_param">param</code></td>
<td>
<p>parameter name for which to generate a traceplot. Valid names are 
<code>"beta", "alpha", "theta"</code>.</p>
</td></tr>
<tr><td><code id="summary.spIntPGOcc_+3A_density">density</code></td>
<td>
<p>logical value indicating whether to also generate a density plot for each parameter
in addition to the MCMC traceplot.</p>
</td></tr>
<tr><td><code id="summary.spIntPGOcc_+3A_...">...</code></td>
<td>
<p>currently no additional arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A set of standard extractor functions for fitted model objects of
class <code>spIntPGOcc</code>, including methods to the generic functions <code><a href="base.html#topic+print">print</a></code>, <code><a href="base.html#topic+summary">summary</a></code>, and <code><a href="base.html#topic+plot">plot</a></code>. 
</p>


<h3>Value</h3>

<p>No return value, called to display summary information of a <code>spIntPGOcc</code> object.
</p>

<hr>
<h2 id='summary.spMsPGOcc'>Methods for spMsPGOcc Object</h2><span id='topic+summary.spMsPGOcc'></span><span id='topic+print.spMsPGOcc'></span><span id='topic+plot.spMsPGOcc'></span>

<h3>Description</h3>

<p>Methods for extracting information from fitted multi-species spatial occupancy (<code>spMsPGOcc</code>) model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'spMsPGOcc'
summary(object, level, quantiles = c(0.025, 0.5, 0.975), 
        digits = max(3L, getOption("digits") - 3L), ...)
## S3 method for class 'spMsPGOcc'
print(x, ...)
## S3 method for class 'spMsPGOcc'
plot(x, param, density = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.spMsPGOcc_+3A_object">object</code>, <code id="summary.spMsPGOcc_+3A_x">x</code></td>
<td>
<p>object of class <code>spMsPGOcc</code>.</p>
</td></tr>
<tr><td><code id="summary.spMsPGOcc_+3A_level">level</code></td>
<td>
<p>a quoted keyword that indicates the level to summarize the 
model results. Valid key words are: <code>"community"</code>, 
<code>"species"</code>, or <code>"both"</code>.</p>
</td></tr>
<tr><td><code id="summary.spMsPGOcc_+3A_quantiles">quantiles</code></td>
<td>
<p>for <code>summary</code>, posterior distribution quantiles to compute.</p>
</td></tr>
<tr><td><code id="summary.spMsPGOcc_+3A_digits">digits</code></td>
<td>
<p>for <code>summary</code>, number of digits to report.</p>
</td></tr>
<tr><td><code id="summary.spMsPGOcc_+3A_param">param</code></td>
<td>
<p>parameter name for which to generate a traceplot. Valid names are 
<code>"beta", "beta.star", "sigma.sq.psi", "beta.comm", "tau.sq.beta", 
		     "alpha", "alpha.star", "sigma.sq.p", "alpha.comm", "tau.sq.alpha", "theta"</code>.</p>
</td></tr>
<tr><td><code id="summary.spMsPGOcc_+3A_density">density</code></td>
<td>
<p>logical value indicating whether to also generate a density plot for each parameter
in addition to the MCMC traceplot.</p>
</td></tr>
<tr><td><code id="summary.spMsPGOcc_+3A_...">...</code></td>
<td>
<p>currently no additional arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A set of standard extractor functions for fitted model objects of
class <code>spMsPGOcc</code>, including methods to the generic functions <code><a href="base.html#topic+print">print</a></code>, <code><a href="base.html#topic+summary">summary</a></code>, and <code><a href="base.html#topic+plot">plot</a></code>. 
</p>


<h3>Value</h3>

<p>No return value, called to display summary information of a <code>spMsPGOcc</code> object.
</p>

<hr>
<h2 id='summary.spPGOcc'>Methods for spPGOcc Object</h2><span id='topic+summary.spPGOcc'></span><span id='topic+print.spPGOcc'></span><span id='topic+plot.spPGOcc'></span>

<h3>Description</h3>

<p>Methods for extracting information from fitted single-species spatial 
occupancy (<code>spPGOcc</code>) model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'spPGOcc'
summary(object, quantiles = c(0.025, 0.5, 0.975), 
        digits = max(3L, getOption("digits") - 3L), ...)
## S3 method for class 'spPGOcc'
print(x, ...)
## S3 method for class 'spPGOcc'
plot(x, param, density = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.spPGOcc_+3A_object">object</code>, <code id="summary.spPGOcc_+3A_x">x</code></td>
<td>
<p>object of class <code>spPGOcc</code>.</p>
</td></tr>
<tr><td><code id="summary.spPGOcc_+3A_quantiles">quantiles</code></td>
<td>
<p>for <code>summary</code>, posterior distribution quantiles to compute.</p>
</td></tr>
<tr><td><code id="summary.spPGOcc_+3A_digits">digits</code></td>
<td>
<p>for <code>summary</code>, number of digits to report.</p>
</td></tr>
<tr><td><code id="summary.spPGOcc_+3A_param">param</code></td>
<td>
<p>parameter name for which to generate a traceplot. Valid names are 
<code>"beta", "beta.star", "sigma.sq.psi", "alpha", "alpha.star", "sigma.sq.p", "theta"</code>.</p>
</td></tr>
<tr><td><code id="summary.spPGOcc_+3A_density">density</code></td>
<td>
<p>logical value indicating whether to also generate a density plot for each parameter
in addition to the MCMC traceplot.</p>
</td></tr>
<tr><td><code id="summary.spPGOcc_+3A_...">...</code></td>
<td>
<p>currently no additional arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A set of standard extractor functions for fitted model objects of
class <code>spPGOcc</code>, including methods to the generic functions 
<code><a href="base.html#topic+print">print</a></code>, <code><a href="base.html#topic+summary">summary</a></code>, and <code><a href="base.html#topic+plot">plot</a></code>. 
</p>


<h3>Value</h3>

<p>No return value, called to display summary information of a <code>spPGOcc</code> object.
</p>

<hr>
<h2 id='summary.stMsPGOcc'>Methods for stMsPGOcc Object</h2><span id='topic+summary.stMsPGOcc'></span><span id='topic+print.stMsPGOcc'></span><span id='topic+plot.stMsPGOcc'></span>

<h3>Description</h3>

<p>Methods for extracting information from fitted multi-species, multi-season spatial occupancy (<code>stMsPGOcc</code>) model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'stMsPGOcc'
summary(object, level = 'both', quantiles = c(0.025, 0.5, 0.975), 
        digits = max(3L, getOption("digits") - 3L), ...)
## S3 method for class 'stMsPGOcc'
print(x, ...)
## S3 method for class 'stMsPGOcc'
plot(x, param, density = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.stMsPGOcc_+3A_object">object</code>, <code id="summary.stMsPGOcc_+3A_x">x</code></td>
<td>
<p>object of class <code>stMsPGOcc</code>.</p>
</td></tr>
<tr><td><code id="summary.stMsPGOcc_+3A_level">level</code></td>
<td>
<p>a quoted keyword that indicates the level to summarize the 
model results. Valid key words are: <code>"community"</code>, 
<code>"species"</code>, or <code>"both"</code>.</p>
</td></tr>
<tr><td><code id="summary.stMsPGOcc_+3A_quantiles">quantiles</code></td>
<td>
<p>for <code>summary</code>, posterior distribution quantiles to compute.</p>
</td></tr>
<tr><td><code id="summary.stMsPGOcc_+3A_digits">digits</code></td>
<td>
<p>for <code>summary</code>, number of digits to report.</p>
</td></tr>
<tr><td><code id="summary.stMsPGOcc_+3A_param">param</code></td>
<td>
<p>parameter name for which to generate a traceplot. Valid names are 
<code>"beta", "beta.star", "sigma.sq.psi", "beta.comm", "tau.sq.beta", 
		     "alpha", "alpha.star", "sigma.sq.p", "alpha.comm", "tau.sq.alpha", 
		     "lambda", "theta"</code>.</p>
</td></tr>
<tr><td><code id="summary.stMsPGOcc_+3A_density">density</code></td>
<td>
<p>logical value indicating whether to also generate a density plot for each parameter
in addition to the MCMC traceplot.</p>
</td></tr>
<tr><td><code id="summary.stMsPGOcc_+3A_...">...</code></td>
<td>
<p>currently no additional arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A set of standard extractor functions for fitted model objects of
class <code>stMsPGOcc</code>, including methods to the generic functions <code><a href="base.html#topic+print">print</a></code>, <code><a href="base.html#topic+summary">summary</a></code>, and <code><a href="base.html#topic+plot">plot</a></code>. 
</p>


<h3>Value</h3>

<p>No return value, called to display summary information of a <code>stMsPGOcc</code> object.
</p>

<hr>
<h2 id='summary.stPGOcc'>Methods for stPGOcc Object</h2><span id='topic+summary.stPGOcc'></span><span id='topic+print.stPGOcc'></span><span id='topic+plot.stPGOcc'></span>

<h3>Description</h3>

<p>Methods for extracting information from fitted multi-season single-species spatial occupancy (<code>stPGOcc</code>) model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'stPGOcc'
summary(object, quantiles = c(0.025, 0.5, 0.975), 
        digits = max(3L, getOption("digits") - 3L), ...)
## S3 method for class 'stPGOcc'
print(x, ...)
## S3 method for class 'stPGOcc'
plot(x, param, density = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.stPGOcc_+3A_object">object</code>, <code id="summary.stPGOcc_+3A_x">x</code></td>
<td>
<p>object of class <code>stPGOcc</code>.</p>
</td></tr>
<tr><td><code id="summary.stPGOcc_+3A_quantiles">quantiles</code></td>
<td>
<p>for <code>summary</code>, posterior distribution quantiles to compute.</p>
</td></tr>
<tr><td><code id="summary.stPGOcc_+3A_digits">digits</code></td>
<td>
<p>for <code>summary</code>, number of digits to report.</p>
</td></tr>
<tr><td><code id="summary.stPGOcc_+3A_param">param</code></td>
<td>
<p>parameter name for which to generate a traceplot. Valid names are 
<code>"beta", "beta.star", "sigma.sq.psi", "alpha", "alpha.star", "sigma.sq.p", "theta"</code>.</p>
</td></tr>
<tr><td><code id="summary.stPGOcc_+3A_density">density</code></td>
<td>
<p>logical value indicating whether to also generate a density plot for each parameter
in addition to the MCMC traceplot.</p>
</td></tr>
<tr><td><code id="summary.stPGOcc_+3A_...">...</code></td>
<td>
<p>currently no additional arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A set of standard extractor functions for fitted model objects of
class <code>stPGOcc</code>, including methods to the generic functions <code><a href="base.html#topic+print">print</a></code>, <code><a href="base.html#topic+summary">summary</a></code>, and <code><a href="base.html#topic+plot">plot</a></code>. 
</p>


<h3>Value</h3>

<p>No return value, called to display summary information of a <code>stPGOcc</code> object.
</p>

<hr>
<h2 id='summary.svcMsPGOcc'>Methods for svcMsPGOcc Object</h2><span id='topic+summary.svcMsPGOcc'></span><span id='topic+print.svcMsPGOcc'></span><span id='topic+plot.svcMsPGOcc'></span>

<h3>Description</h3>

<p>Methods for extracting information from fitted multi-species spatially-varying coefficient occupancy model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'svcMsPGOcc'
summary(object, level, quantiles = c(0.025, 0.5, 0.975), 
        digits = max(3L, getOption("digits") - 3L), ...)
## S3 method for class 'svcMsPGOcc'
print(x, ...)
## S3 method for class 'svcMsPGOcc'
plot(x, param, density = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.svcMsPGOcc_+3A_object">object</code>, <code id="summary.svcMsPGOcc_+3A_x">x</code></td>
<td>
<p>object of class <code>svcMsPGOcc</code>.</p>
</td></tr>
<tr><td><code id="summary.svcMsPGOcc_+3A_level">level</code></td>
<td>
<p>a quoted keyword that indicates the level to summarize the 
model results. Valid key words are: <code>"community"</code>, 
<code>"species"</code>, or <code>"both"</code>.</p>
</td></tr>
<tr><td><code id="summary.svcMsPGOcc_+3A_quantiles">quantiles</code></td>
<td>
<p>for <code>summary</code>, posterior distribution quantiles to compute.</p>
</td></tr>
<tr><td><code id="summary.svcMsPGOcc_+3A_digits">digits</code></td>
<td>
<p>for <code>summary</code>, number of digits to report.</p>
</td></tr>
<tr><td><code id="summary.svcMsPGOcc_+3A_param">param</code></td>
<td>
<p>parameter name for which to generate a traceplot. Valid names are 
<code>"beta", "beta.star", "sigma.sq.psi", "beta.comm", "tau.sq.beta", 
		     "alpha", "alpha.star", "sigma.sq.p", "alpha.comm", "tau.sq.alpha", 
		     "lambda", "theta"</code>.</p>
</td></tr>
<tr><td><code id="summary.svcMsPGOcc_+3A_density">density</code></td>
<td>
<p>logical value indicating whether to also generate a density plot for each parameter
in addition to the MCMC traceplot.</p>
</td></tr>
<tr><td><code id="summary.svcMsPGOcc_+3A_...">...</code></td>
<td>
<p>currently no additional arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A set of standard extractor functions for fitted model objects of
class <code>svcMsPGOcc</code>, including methods to the generic functions <code><a href="base.html#topic+print">print</a></code>, <code><a href="base.html#topic+summary">summary</a></code>, and <code><a href="base.html#topic+plot">plot</a></code>. 
</p>


<h3>Value</h3>

<p>No return value, called to display summary information of a <code>svcMsPGOcc</code> object.
</p>

<hr>
<h2 id='summary.svcPGBinom'>Methods for svcPGBinom Object</h2><span id='topic+summary.svcPGBinom'></span><span id='topic+print.svcPGBinom'></span><span id='topic+plot.svcPGBinom'></span>

<h3>Description</h3>

<p>Methods for extracting information from fitted single-species spatially-varying 
coefficient binomial model (<code>svcPGBinom</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'svcPGBinom'
summary(object, quantiles = c(0.025, 0.5, 0.975), 
        digits = max(3L, getOption("digits") - 3L), ...)
## S3 method for class 'svcPGBinom'
print(x, ...)
## S3 method for class 'svcPGBinom'
plot(x, param, density = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.svcPGBinom_+3A_object">object</code>, <code id="summary.svcPGBinom_+3A_x">x</code></td>
<td>
<p>object of class <code>svcPGBinom</code>.</p>
</td></tr>
<tr><td><code id="summary.svcPGBinom_+3A_quantiles">quantiles</code></td>
<td>
<p>for <code>summary</code>, posterior distribution quantiles to compute.</p>
</td></tr>
<tr><td><code id="summary.svcPGBinom_+3A_digits">digits</code></td>
<td>
<p>for <code>summary</code>, number of digits to report.</p>
</td></tr>
<tr><td><code id="summary.svcPGBinom_+3A_param">param</code></td>
<td>
<p>parameter name for which to generate a traceplot. Valid names are 
<code>"beta", "beta.star", "sigma.sq.psi", "theta"</code>.</p>
</td></tr>
<tr><td><code id="summary.svcPGBinom_+3A_density">density</code></td>
<td>
<p>logical value indicating whether to also generate a density plot for each parameter
in addition to the MCMC traceplot.</p>
</td></tr>
<tr><td><code id="summary.svcPGBinom_+3A_...">...</code></td>
<td>
<p>currently no additional arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A set of standard extractor functions for fitted model objects of
class <code>svcPGBinom</code>, including methods to the generic functions 
<code><a href="base.html#topic+print">print</a></code>, <code><a href="base.html#topic+summary">summary</a></code>, and <code><a href="base.html#topic+plot">plot</a></code>. 
</p>


<h3>Value</h3>

<p>No return value, called to display summary information of a <code>svcPGBinom</code> object.
</p>

<hr>
<h2 id='summary.svcPGOcc'>Methods for svcPGOcc Object</h2><span id='topic+summary.svcPGOcc'></span><span id='topic+print.svcPGOcc'></span><span id='topic+plot.svcPGOcc'></span>

<h3>Description</h3>

<p>Methods for extracting information from fitted single-species 
spatially-varying coefficient occupancy (<code>svcPGOcc</code>) model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'svcPGOcc'
summary(object, quantiles = c(0.025, 0.5, 0.975), 
        digits = max(3L, getOption("digits") - 3L), ...)
## S3 method for class 'svcPGOcc'
print(x, ...)
## S3 method for class 'svcPGOcc'
plot(x, param, density = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.svcPGOcc_+3A_object">object</code>, <code id="summary.svcPGOcc_+3A_x">x</code></td>
<td>
<p>object of class <code>svcPGOcc</code>.</p>
</td></tr>
<tr><td><code id="summary.svcPGOcc_+3A_quantiles">quantiles</code></td>
<td>
<p>for <code>summary</code>, posterior distribution quantiles to compute.</p>
</td></tr>
<tr><td><code id="summary.svcPGOcc_+3A_digits">digits</code></td>
<td>
<p>for <code>summary</code>, number of digits to report.</p>
</td></tr>
<tr><td><code id="summary.svcPGOcc_+3A_param">param</code></td>
<td>
<p>parameter name for which to generate a traceplot. Valid names are 
<code>"beta", "beta.star", "sigma.sq.psi", "alpha", "alpha.star", "sigma.sq.p", "theta"</code>.</p>
</td></tr>
<tr><td><code id="summary.svcPGOcc_+3A_density">density</code></td>
<td>
<p>logical value indicating whether to also generate a density plot for each parameter
in addition to the MCMC traceplot.</p>
</td></tr>
<tr><td><code id="summary.svcPGOcc_+3A_...">...</code></td>
<td>
<p>currently no additional arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A set of standard extractor functions for fitted model objects of
class <code>svcPGOcc</code>, including methods to the generic functions 
<code><a href="base.html#topic+print">print</a></code>, <code><a href="base.html#topic+summary">summary</a></code>, and <code><a href="base.html#topic+plot">plot</a></code>. 
</p>


<h3>Value</h3>

<p>No return value, called to display summary information of a <code>svcPGOcc</code> object.
</p>

<hr>
<h2 id='summary.svcTMsPGOcc'>Methods for svcTMsPGOcc Object</h2><span id='topic+summary.svcTMsPGOcc'></span><span id='topic+print.svcTMsPGOcc'></span><span id='topic+plot.svcTMsPGOcc'></span>

<h3>Description</h3>

<p>Methods for extracting information from fitted multi-species, multi-season spatially-varying coefficient occupancy (<code>svcTMsPGOcc</code>) model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'svcTMsPGOcc'
summary(object, level = 'both', quantiles = c(0.025, 0.5, 0.975), 
        digits = max(3L, getOption("digits") - 3L), ...)
## S3 method for class 'svcTMsPGOcc'
print(x, ...)
## S3 method for class 'svcTMsPGOcc'
plot(x, param, density = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.svcTMsPGOcc_+3A_object">object</code>, <code id="summary.svcTMsPGOcc_+3A_x">x</code></td>
<td>
<p>object of class <code>svcTMsPGOcc</code>.</p>
</td></tr>
<tr><td><code id="summary.svcTMsPGOcc_+3A_level">level</code></td>
<td>
<p>a quoted keyword that indicates the level to summarize the 
model results. Valid key words are: <code>"community"</code>, 
<code>"species"</code>, or <code>"both"</code>.</p>
</td></tr>
<tr><td><code id="summary.svcTMsPGOcc_+3A_quantiles">quantiles</code></td>
<td>
<p>for <code>summary</code>, posterior distribution quantiles to compute.</p>
</td></tr>
<tr><td><code id="summary.svcTMsPGOcc_+3A_digits">digits</code></td>
<td>
<p>for <code>summary</code>, number of digits to report.</p>
</td></tr>
<tr><td><code id="summary.svcTMsPGOcc_+3A_param">param</code></td>
<td>
<p>parameter name for which to generate a traceplot. Valid names are 
<code>"beta", "beta.star", "sigma.sq.psi", "beta.comm", "tau.sq.beta", 
		     "alpha", "alpha.star", "sigma.sq.p", "alpha.comm", "tau.sq.alpha", 
		     "lambda", "theta"</code>.</p>
</td></tr>
<tr><td><code id="summary.svcTMsPGOcc_+3A_density">density</code></td>
<td>
<p>logical value indicating whether to also generate a density plot for each parameter
in addition to the MCMC traceplot.</p>
</td></tr>
<tr><td><code id="summary.svcTMsPGOcc_+3A_...">...</code></td>
<td>
<p>currently no additional arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A set of standard extractor functions for fitted model objects of
class <code>svcTMsPGOcc</code>, including methods to the generic functions <code><a href="base.html#topic+print">print</a></code>, <code><a href="base.html#topic+summary">summary</a></code>, and <code><a href="base.html#topic+plot">plot</a></code>. 
</p>


<h3>Value</h3>

<p>No return value, called to display summary information of a <code>svcTMsPGOcc</code> object.
</p>

<hr>
<h2 id='summary.svcTPGBinom'>Methods for svcTPGBinom Object</h2><span id='topic+summary.svcTPGBinom'></span><span id='topic+print.svcTPGBinom'></span><span id='topic+plot.svcTPGBinom'></span>

<h3>Description</h3>

<p>Methods for extracting information from fitted multi-season single-species 
spatially-varying coefficient binomial model (<code>svcTPGBinom</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'svcTPGBinom'
summary(object, quantiles = c(0.025, 0.5, 0.975), 
        digits = max(3L, getOption("digits") - 3L), ...)
## S3 method for class 'svcTPGBinom'
print(x, ...)
## S3 method for class 'svcTPGBinom'
plot(x, param, density = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.svcTPGBinom_+3A_object">object</code>, <code id="summary.svcTPGBinom_+3A_x">x</code></td>
<td>
<p>object of class <code>svcTPGBinom</code>.</p>
</td></tr>
<tr><td><code id="summary.svcTPGBinom_+3A_quantiles">quantiles</code></td>
<td>
<p>for <code>summary</code>, posterior distribution quantiles to compute.</p>
</td></tr>
<tr><td><code id="summary.svcTPGBinom_+3A_digits">digits</code></td>
<td>
<p>for <code>summary</code>, number of digits to report.</p>
</td></tr>
<tr><td><code id="summary.svcTPGBinom_+3A_param">param</code></td>
<td>
<p>parameter name for which to generate a traceplot. Valid names are 
<code>"beta", "beta.star", "sigma.sq.psi", "theta"</code>.</p>
</td></tr>
<tr><td><code id="summary.svcTPGBinom_+3A_density">density</code></td>
<td>
<p>logical value indicating whether to also generate a density plot for each parameter
in addition to the MCMC traceplot.</p>
</td></tr>
<tr><td><code id="summary.svcTPGBinom_+3A_...">...</code></td>
<td>
<p>currently no additional arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A set of standard extractor functions for fitted model objects of
class <code>svcTPGBinom</code>, including methods to the generic functions 
<code><a href="base.html#topic+print">print</a></code>, <code><a href="base.html#topic+summary">summary</a></code>, <code><a href="base.html#topic+plot">plot</a></code>. 
</p>


<h3>Value</h3>

<p>No return value, called to display summary information of a <code>svcTPGBinom</code> object.
</p>

<hr>
<h2 id='summary.svcTPGOcc'>Methods for svcTPGOcc Object</h2><span id='topic+summary.svcTPGOcc'></span><span id='topic+print.svcTPGOcc'></span><span id='topic+plot.svcTPGOcc'></span>

<h3>Description</h3>

<p>Methods for extracting information from fitted multi-season single-species spatially-varying coefficient occupancy (<code>svcTPGOcc</code>) model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'svcTPGOcc'
summary(object, quantiles = c(0.025, 0.5, 0.975), 
        digits = max(3L, getOption("digits") - 3L), ...)
## S3 method for class 'svcTPGOcc'
print(x, ...)
## S3 method for class 'svcTPGOcc'
plot(x, param, density = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.svcTPGOcc_+3A_object">object</code>, <code id="summary.svcTPGOcc_+3A_x">x</code></td>
<td>
<p>object of class <code>svcTPGOcc</code>.</p>
</td></tr>
<tr><td><code id="summary.svcTPGOcc_+3A_quantiles">quantiles</code></td>
<td>
<p>for <code>summary</code>, posterior distribution quantiles to compute.</p>
</td></tr>
<tr><td><code id="summary.svcTPGOcc_+3A_digits">digits</code></td>
<td>
<p>for <code>summary</code>, number of digits to report.</p>
</td></tr>
<tr><td><code id="summary.svcTPGOcc_+3A_param">param</code></td>
<td>
<p>parameter name for which to generate a traceplot. Valid names are 
<code>"beta", "beta.star", "sigma.sq.psi", "alpha", "alpha.star", "sigma.sq.p", "theta"</code>.</p>
</td></tr>
<tr><td><code id="summary.svcTPGOcc_+3A_density">density</code></td>
<td>
<p>logical value indicating whether to also generate a density plot for each parameter
in addition to the MCMC traceplot.</p>
</td></tr>
<tr><td><code id="summary.svcTPGOcc_+3A_...">...</code></td>
<td>
<p>currently no additional arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A set of standard extractor functions for fitted model objects of
class <code>svcTPGOcc</code>, including methods to the generic functions <code><a href="base.html#topic+print">print</a></code>, <code><a href="base.html#topic+summary">summary</a></code>, and <code><a href="base.html#topic+plot">plot</a></code>. 
</p>


<h3>Value</h3>

<p>No return value, called to display summary information of a <code>svcTPGOcc</code> object.
</p>

<hr>
<h2 id='summary.tMsPGOcc'>Methods for tMsPGOcc Object</h2><span id='topic+summary.tMsPGOcc'></span><span id='topic+print.tMsPGOcc'></span><span id='topic+plot.tMsPGOcc'></span>

<h3>Description</h3>

<p>Methods for extracting information from fitted multi-species, multi-season occupancy (<code>tMsPGOcc</code>) model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'tMsPGOcc'
summary(object, level = 'both', quantiles = c(0.025, 0.5, 0.975), 
        digits = max(3L, getOption("digits") - 3L), ...)
## S3 method for class 'tMsPGOcc'
print(x, ...)
## S3 method for class 'tMsPGOcc'
plot(x, param, density = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.tMsPGOcc_+3A_object">object</code>, <code id="summary.tMsPGOcc_+3A_x">x</code></td>
<td>
<p>object of class <code>tMsPGOcc</code>.</p>
</td></tr>
<tr><td><code id="summary.tMsPGOcc_+3A_level">level</code></td>
<td>
<p>a quoted keyword that indicates the level to summarize the 
model results. Valid key words are: <code>"community"</code>, 
<code>"species"</code>, or <code>"both"</code>.</p>
</td></tr>
<tr><td><code id="summary.tMsPGOcc_+3A_quantiles">quantiles</code></td>
<td>
<p>for <code>summary</code>, posterior distribution quantiles to compute.</p>
</td></tr>
<tr><td><code id="summary.tMsPGOcc_+3A_digits">digits</code></td>
<td>
<p>for <code>summary</code>, number of digits to report.</p>
</td></tr>
<tr><td><code id="summary.tMsPGOcc_+3A_param">param</code></td>
<td>
<p>parameter name for which to generate a traceplot. Valid names are 
<code>"beta", "beta.star", "sigma.sq.psi", "beta.comm", "tau.sq.beta", 
		     "alpha", "alpha.star", "sigma.sq.p", "alpha.comm", "tau.sq.alpha", "theta"</code>.</p>
</td></tr>
<tr><td><code id="summary.tMsPGOcc_+3A_density">density</code></td>
<td>
<p>logical value indicating whether to also generate a density plot for each parameter
in addition to the MCMC traceplot.</p>
</td></tr>
<tr><td><code id="summary.tMsPGOcc_+3A_...">...</code></td>
<td>
<p>currently no additional arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A set of standard extractor functions for fitted model objects of
class <code>tMsPGOcc</code>, including methods to the generic functions <code><a href="base.html#topic+print">print</a></code>, <code><a href="base.html#topic+summary">summary</a></code>, and <code><a href="base.html#topic+plot">plot</a></code>. 
</p>


<h3>Value</h3>

<p>No return value, called to display summary information of a <code>tMsPGOcc</code> object.
</p>

<hr>
<h2 id='summary.tPGOcc'>Methods for tPGOcc Object</h2><span id='topic+summary.tPGOcc'></span><span id='topic+print.tPGOcc'></span><span id='topic+plot.tPGOcc'></span>

<h3>Description</h3>

<p>Methods for extracting information from fitted multi-season single-species occupancy (<code>tPGOcc</code>) model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'tPGOcc'
summary(object, quantiles = c(0.025, 0.5, 0.975), 
        digits = max(3L, getOption("digits") - 3L), ...)
## S3 method for class 'tPGOcc'
print(x, ...)
## S3 method for class 'tPGOcc'
plot(x, param, density = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.tPGOcc_+3A_object">object</code>, <code id="summary.tPGOcc_+3A_x">x</code></td>
<td>
<p>object of class <code>tPGOcc</code>.</p>
</td></tr>
<tr><td><code id="summary.tPGOcc_+3A_quantiles">quantiles</code></td>
<td>
<p>for <code>summary</code>, posterior distribution quantiles to compute.</p>
</td></tr>
<tr><td><code id="summary.tPGOcc_+3A_digits">digits</code></td>
<td>
<p>for <code>summary</code>, number of digits to report.</p>
</td></tr>
<tr><td><code id="summary.tPGOcc_+3A_param">param</code></td>
<td>
<p>parameter name for which to generate a traceplot. Valid names are 
<code>"beta", "beta.star", "sigma.sq.psi", "alpha", "alpha.star", "sigma.sq.p", "theta"</code>.</p>
</td></tr>
<tr><td><code id="summary.tPGOcc_+3A_density">density</code></td>
<td>
<p>logical value indicating whether to also generate a density plot for each parameter
in addition to the MCMC traceplot.</p>
</td></tr>
<tr><td><code id="summary.tPGOcc_+3A_...">...</code></td>
<td>
<p>currently no additional arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A set of standard extractor functions for fitted model objects of
class <code>tPGOcc</code>, including methods to the generic functions <code><a href="base.html#topic+print">print</a></code>, <code><a href="base.html#topic+summary">summary</a></code>, and <code><a href="base.html#topic+plot">plot</a></code>. 
</p>


<h3>Value</h3>

<p>No return value, called to display summary information of a <code>tPGOcc</code> object.
</p>

<hr>
<h2 id='svcMsPGOcc'>Function for Fitting Multi-Species Spatially-Varying Coefficient Occupancy Models</h2><span id='topic+svcMsPGOcc'></span>

<h3>Description</h3>

<p>The function <code>svcMsPGOcc</code> fits multi-species spatially-varying coefficient occupancy models with species correlations (i.e., a spatially-explicit joint species distribution model with imperfect detection). We use Polya-Gamma latent variables and a spatial factor modeling approach. Models are implemented using a Nearest Neighbor Gaussian Process. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>svcMsPGOcc(occ.formula, det.formula, data, inits, priors, tuning, 
           svc.cols = 1, cov.model = 'exponential', NNGP = TRUE, 
           n.neighbors = 15, search.type = 'cb', std.by.sp = FALSE, 
           n.factors, n.batch, batch.length, 
           accept.rate = 0.43, n.omp.threads = 1, 
           verbose = TRUE, n.report = 100, 
           n.burn = round(.10 * n.batch * batch.length), n.thin = 1, 
           n.chains = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="svcMsPGOcc_+3A_occ.formula">occ.formula</code></td>
<td>
<p>a symbolic description of the model to be fit
for the occurrence portion of the model using R's model syntax. Random
intercepts are allowed using lme4 syntax (Bates et al. 2015). Only
right-hand side of formula is specified. See example below.</p>
</td></tr>
<tr><td><code id="svcMsPGOcc_+3A_det.formula">det.formula</code></td>
<td>
<p>a symbolic description of the model to be fit
for the detection portion of the model using R's model syntax. Only
right-hand side of formula is specified. See example below. Random 
intercepts are allowed using lme4 syntax (Bates et al. 2015).</p>
</td></tr>
<tr><td><code id="svcMsPGOcc_+3A_data">data</code></td>
<td>
<p>a list containing data necessary for model fitting.
Valid tags are <code>y</code>, <code>occ.covs</code>, <code>det.covs</code>, 
<code>coords</code>, and <code>range.ind</code>. 
<code>y</code> is a three-dimensional array with first dimension equal to the 
number of species, second dimension equal to the number of sites, and 
third dimension equal to the maximum number of replicates at a given site. 
<code>occ.covs</code> is a matrix or data frame containing the variables 
used in the occurrence portion of the model, with <code class="reqn">J</code> rows for 
each column (variable). <code>det.covs</code> is a list of variables included 
in the detection portion of the model. Each list element is a different 
detection covariate, which can be site-level or observational-level. 
Site-level covariates are specified as a vector of length <code class="reqn">J</code> while 
observation-level covariates are specified as a matrix or data frame 
with the number of rows equal to <code class="reqn">J</code> and number of columns equal 
to the maximum number of replicates at a given site. <code>coords</code> is a 
<code class="reqn">J \times 2</code> matrix of the observation coordinates. Note that 
<code>spOccupancy</code> assumes coordinates are specified in a projected coordinate system.
<code>range.ind</code> is a matrix with rows corresponding to species and columns
corresponding to sites, with each element taking value 1 if that site is 
within the range of the corresponding species and 0 if it is outside of the 
range. This matrix is not required, but it can be helpful to restrict the 
modeled area for each individual species to be within the realistic range
of locations for that species when estimating the model parameters. This is
applicable when auxiliary data sources are available on the realistic range
of the species.</p>
</td></tr>
<tr><td><code id="svcMsPGOcc_+3A_inits">inits</code></td>
<td>
<p>a list with each tag corresponding to a parameter name.
Valid tags are <code>alpha.comm</code>, <code>beta.comm</code>, <code>beta</code>, 
<code>alpha</code>, <code>tau.sq.beta</code>, <code>tau.sq.alpha</code>, 
<code>sigma.sq.psi</code>, <code>sigma.sq.p</code>, <code>z</code>, 
<code>phi</code>, <code>lambda</code>, and <code>nu</code>. <code>nu</code> is only specified if 
<code>cov.model = "matern"</code>, and <code>sigma.sq.psi</code> and <code>sigma.sq.p</code> are
only specified if random effects are included in <code>occ.formula</code> or 
<code>det.formula</code>, respectively. The value portion of each tag is 
the parameter's initial value. See <code>priors</code> description for definition
of each parameter name. Additionally, the tag <code>fix</code> can be set to <code>TRUE</code> 
to fix the starting values across all chains. If <code>fix</code> is not specified
(the default), starting values are varied randomly across chains.</p>
</td></tr>
<tr><td><code id="svcMsPGOcc_+3A_priors">priors</code></td>
<td>
<p>a list with each tag corresponding to a parameter name. 
Valid tags are <code>beta.comm.normal</code>, <code>alpha.comm.normal</code>, 
<code>tau.sq.beta.ig</code>, <code>tau.sq.alpha.ig</code>, <code>sigma.sq.psi</code>, 
<code>sigma.sq.p</code>, <code>phi.unif</code>, 
and <code>nu.unif</code>. Community-level occurrence (<code>beta.comm</code>) and detection 
(<code>alpha.comm</code>) regression coefficients are assumed to follow a 
normal distribution. The hyperparameters of the normal distribution
are passed as a list of length two with the first and second elements 
corresponding to the mean and variance of the normal distribution, 
which are each specified as vectors of length equal to the number of 
coefficients to be estimated or of length one if priors are the same for 
all coefficients. If not specified, prior means are set 
to 0 and prior variances set to 2.72. By default, community-level variance parameters 
for occupancy (<code>tau.sq.beta</code>) and detection (<code>tau.sq.alpha</code>) are 
assumed to follow an inverse Gamma distribution. The hyperparameters of 
the inverse gamma distribution are passed as a list of length two with 
the first and second elements corresponding to the shape and scale parameters,
which are each specified as vectors of length equal to the number of 
coefficients to be estimated or a single value if priors are the same for all 
parameters. If not specified, prior shape and scale 
parameters are set to 0.1. 
The spatial factor model fits <code>n.factors</code> independent
spatial processes for each spatially-varying coefficient specified in <code>svc.cols</code>. 
The spatial decay <code>phi</code> and smoothness <code>nu</code> parameters 
for each latent factor are assumed to follow Uniform distributions. 
The hyperparameters of the Uniform are passed as a list with two elements, 
with both elements being vectors of length <code>n.factors * length(svc.cols)</code> 
corresponding to the lower and 
upper support, respectively, or as a single value if the same value is assigned
for all factor/SVC combinations. The priors for the factor loadings 
matrix <code>lambda</code> for each SVC are fixed
following the standard spatial factor model to ensure parameter 
identifiability (Christensen and Amemlya 2002). The
upper triangular elements of the <code>N x n.factors</code> matrix are fixed at 0 and the 
diagonal elements are fixed at 1 for each SVC. The lower triangular elements are assigned a 
standard normal prior (i.e., mean 0 and variance 1).
<code>sigma.sq.psi</code> and <code>sigma.sq.p</code> are the random 
effect variances for any occurrence or
detection random effects, respectively, and are assumed to follow an inverse
Gamma distribution. The hyperparameters of the inverse-Gamma distribution
are passed as a list of length two with first and second elements corresponding
to the shape and scale parameters, respectively, which are each specified as
vectors of length equal to the number of random intercepts or of length one 
if priors are the same for all random effect variances.</p>
</td></tr>
<tr><td><code id="svcMsPGOcc_+3A_tuning">tuning</code></td>
<td>
<p>a list with each tag corresponding to a parameter
name. Valid tags are <code>phi</code> and <code>nu</code>. The value portion of each
tag defines the initial variance of the adaptive sampler. We assume the 
initial variance of the adaptive sampler is the same for each species, 
although the adaptive sampler will adjust the tuning variances separately
for each species. See Roberts and Rosenthal (2009) for details.</p>
</td></tr>
<tr><td><code id="svcMsPGOcc_+3A_svc.cols">svc.cols</code></td>
<td>
<p>a vector indicating the variables whose effects will be 
estimated as spatially-varying coefficients. <code>svc.cols</code> can be an 
integer vector with values indicating the order of covariates specified 
in the model formula (with 1 being the intercept if specified), or it can 
be specified as a character vector with names corresponding to variable 
names in <code>occ.covs</code> (for the intercept, use <code>'(Intercept)'</code>). <code>svc.cols</code>
default argument of 1 results in a spatial occupancy model analogous to 
<code>sfMsPGOcc</code> (assuming an intercept is included in the model).</p>
</td></tr> 
<tr><td><code id="svcMsPGOcc_+3A_cov.model">cov.model</code></td>
<td>
<p>a quoted keyword that specifies the covariance
function used to model the spatial dependence structure among the
observations.  Supported covariance model key words are:
<code>"exponential"</code>, <code>"matern"</code>, <code>"spherical"</code>, and
<code>"gaussian"</code>.</p>
</td></tr>
<tr><td><code id="svcMsPGOcc_+3A_nngp">NNGP</code></td>
<td>
<p>if <code>TRUE</code>, model is fit with an NNGP. If <code>FALSE</code>, 
a full Gaussian process is used. See Datta et al. (2016) and 
Finley et al. (2019) for more information. Only 
<code>NNGP = TRUE</code> is currently supported.</p>
</td></tr>
<tr><td><code id="svcMsPGOcc_+3A_n.neighbors">n.neighbors</code></td>
<td>
<p>number of neighbors used in the NNGP. Only used if 
<code>NNGP = TRUE</code>. Datta et al. (2016) showed that 15 neighbors is usually 
sufficient, but that as few as 5 neighbors can be adequate for certain data
sets, which can lead to even greater decreases in run time. We recommend
starting with 15 neighbors (the default) and if additional gains in computation
time are desired, subsequently compare the results with a smaller number
of neighbors using WAIC.</p>
</td></tr>
<tr><td><code id="svcMsPGOcc_+3A_search.type">search.type</code></td>
<td>
<p>a quoted keyword that specifies the type of nearest
neighbor search algorithm. Supported method key words are: <code>"cb"</code> and
<code>"brute"</code>. The <code>"cb"</code> should generally be much
faster. If locations do not have identical coordinate values on
the axis used for the nearest neighbor ordering then <code>"cb"</code> 
and <code>"brute"</code> should produce identical neighbor sets. 
However, if there are identical coordinate values on the axis used 
for nearest neighbor ordering, then <code>"cb"</code> and <code>"brute"</code> 
might produce different, but equally valid, neighbor sets, 
e.g., if data are on a grid. </p>
</td></tr>
<tr><td><code id="svcMsPGOcc_+3A_std.by.sp">std.by.sp</code></td>
<td>
<p>a logical value indicating whether the covariates are standardized
separately for each species within the corresponding range for each species (<code>TRUE</code>) 
or not (<code>FALSE</code>). Note that if <code>range.ind</code> is specified in <code>data.list</code>, 
this will result in the covariates being standardized differently for each species
based on the sites where <code>range.ind == 1</code> for that given species. If <code>range.ind</code> is not specified 
and <code>std.by.sp = TRUE</code>, this will simply be equivalent to standardizing 
the covariates across all locations prior to fitting the model. Note that the covariates
in <code>occ.formula</code> should still be standardized across all locations. This can be done
either outside the function, or can be done by specifying <code>scale()</code> in the model formula 
around the continuous covariates.</p>
</td></tr>
<tr><td><code id="svcMsPGOcc_+3A_n.factors">n.factors</code></td>
<td>
<p>the number of factors to use in the spatial factor model approach. 
Note this corresponds to the number of factors used for each spatially-varying
coefficient that is estimated in the model.
Typically, the number of factors is set to be small (e.g., 4-5) relative to the 
total number of species in the community, which will lead to substantial 
decreases in computation time. However, the value can be anywhere 
between 1 and N (the number of species in the community).</p>
</td></tr>
<tr><td><code id="svcMsPGOcc_+3A_n.batch">n.batch</code></td>
<td>
<p>the number of MCMC batches  in each chain to run for the Adaptive MCMC 
sampler. See Roberts and Rosenthal (2009) for details.</p>
</td></tr>
<tr><td><code id="svcMsPGOcc_+3A_batch.length">batch.length</code></td>
<td>
<p>the length of each MCMC batch to run for the Adaptive 
MCMC sampler. See Roberts and Rosenthal (2009) for details.</p>
</td></tr>
<tr><td><code id="svcMsPGOcc_+3A_accept.rate">accept.rate</code></td>
<td>
<p>target acceptance rate for Adaptive MCMC. Defaul is 
0.43. See Roberts and Rosenthal (2009) for details.</p>
</td></tr>
<tr><td><code id="svcMsPGOcc_+3A_n.omp.threads">n.omp.threads</code></td>
<td>
<p>a positive integer indicating
the number of threads to use for SMP parallel processing. The package must
be compiled for OpenMP support. For most Intel-based machines, we
recommend setting <code>n.omp.threads</code> up to the number of
hyperthreaded cores. Note, <code>n.omp.threads</code> &gt; 1 might not
work on some systems.</p>
</td></tr>
<tr><td><code id="svcMsPGOcc_+3A_verbose">verbose</code></td>
<td>
<p>if <code>TRUE</code>, messages about data preparation, 
model specification, and progress of the sampler are printed to the screen. 
Otherwise, no messages are printed.</p>
</td></tr>
<tr><td><code id="svcMsPGOcc_+3A_n.report">n.report</code></td>
<td>
<p>the interval to report Metropolis sampler acceptance and
MCMC progress. Note this is specified in terms of batches and not overall
samples for spatial models.</p>
</td></tr>
<tr><td><code id="svcMsPGOcc_+3A_n.burn">n.burn</code></td>
<td>
<p>the number of samples out of the total <code>n.samples</code> to 
discard as burn-in for each chain. By default, the first 10% of samples is discarded.</p>
</td></tr>
<tr><td><code id="svcMsPGOcc_+3A_n.thin">n.thin</code></td>
<td>
<p>the thinning interval for collection of MCMC samples. The
thinning occurs after the <code>n.burn</code> samples are discarded. Default 
value is set to 1.</p>
</td></tr>
<tr><td><code id="svcMsPGOcc_+3A_n.chains">n.chains</code></td>
<td>
<p>the number of chains to run in sequence.</p>
</td></tr>
<tr><td><code id="svcMsPGOcc_+3A_...">...</code></td>
<td>
<p>currently no additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>svcMsPGOcc</code> that is a list comprised of: 
</p>
<table>
<tr><td><code>beta.comm.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the community level occurrence regression coefficients.</p>
</td></tr>
<tr><td><code>alpha.comm.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the community level detection regression coefficients.</p>
</td></tr>
<tr><td><code>tau.sq.beta.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the occurrence community variance parameters.</p>
</td></tr>
<tr><td><code>tau.sq.alpha.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the detection community variance parameters.</p>
</td></tr>
<tr><td><code>beta.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the species level occurrence regression coefficients.</p>
</td></tr>
<tr><td><code>alpha.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the species level detection regression coefficients.</p>
</td></tr>
<tr><td><code>theta.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the species level correlation parameters for each spatially-varying coefficient.</p>
</td></tr>
<tr><td><code>lambda.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the latent spatial factor loadings for each spatially-varying coefficient.</p>
</td></tr>
<tr><td><code>z.samples</code></td>
<td>
<p>a three-dimensional array of posterior samples for
the latent occurrence values for each species.</p>
</td></tr>
<tr><td><code>psi.samples</code></td>
<td>
<p>a three-dimensional array of posterior samples for
the latent occupancy probability values for each species.</p>
</td></tr>
<tr><td><code>w.samples</code></td>
<td>
<p>a four-dimensional array of posterior samples for 
the latent spatial random effects for each spatial factor within each 
spatially-varying coefficient. Dimensions correspond to MCMC sample, 
factor, site, and spatially-varying coefficient.</p>
</td></tr>
<tr><td><code>sigma.sq.psi.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for variances of random intercepts included in the occurrence portion
of the model. Only included if random intercepts are specified in 
<code>occ.formula</code>.</p>
</td></tr>
<tr><td><code>sigma.sq.p.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for variances of random intercpets included in the detection portion 
of the model. Only included if random intercepts are specified in 
<code>det.formula</code>.</p>
</td></tr>
<tr><td><code>beta.star.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the occurrence random effects. Only included if random intercepts
are specified in <code>occ.formula</code>.</p>
</td></tr>
<tr><td><code>alpha.star.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the detection random effects. Only included if random intercepts 
are specified in <code>det.formula</code>.</p>
</td></tr>
<tr><td><code>like.samples</code></td>
<td>
<p>a three-dimensional array of posterior samples
for the likelihood value associated with each site and species. 
Used for calculating WAIC.</p>
</td></tr>
<tr><td><code>rhat</code></td>
<td>
<p>a list of Gelman-Rubin diagnostic values for some of the model
parameters.</p>
</td></tr>
<tr><td><code>ESS</code></td>
<td>
<p>a list of effective sample sizes for some of the model parameters.</p>
</td></tr>
<tr><td><code>run.time</code></td>
<td>
<p>MCMC sampler execution time reported using <code>proc.time()</code>.</p>
</td></tr>
</table>
<p>The return object will include additional objects used for 
subsequent prediction and/or model fit evaluation. Note that detection 
probability estimated values are not included in the model object, but can
be extracted using <code>fitted()</code>.
</p>


<h3>Note</h3>

<p>Some of the underlying code used for generating random numbers from the
Polya-Gamma distribution is taken from the <span class="pkg">pgdraw</span> package written
by Daniel F. Schmidt and Enes Makalic. Their code implements Algorithm
6 in PhD thesis of Jesse Bennett Windle (2013) <a href="https://repositories.lib.utexas.edu/handle/2152/21842">https://repositories.lib.utexas.edu/handle/2152/21842</a>.
</p>


<h3>Author(s)</h3>

<p>Jeffrey W. Doser <a href="mailto:doserjef@msu.edu">doserjef@msu.edu</a>, <br />
Andrew O. Finley <a href="mailto:finleya@msu.edu">finleya@msu.edu</a>
</p>


<h3>References</h3>

<p>Datta, A., S. Banerjee, A.O. Finley, and A.E. Gelfand. (2016)
Hierarchical Nearest-Neighbor Gaussian process models for large
geostatistical datasets. <em>Journal of the American Statistical
Association</em>, <a href="https://doi.org/10.1080/01621459.2015.1044091">doi:10.1080/01621459.2015.1044091</a>.
</p>
<p>Finley, A.O., A. Datta, B.D. Cook, D.C. Morton, H.E. Andersen, and
S. Banerjee. (2019) Efficient algorithms for Bayesian Nearest Neighbor
Gaussian Processes. <em>Journal of Computational and Graphical
Statistics</em>, <a href="https://doi.org/10.1080/10618600.2018.1537924">doi:10.1080/10618600.2018.1537924</a>.
</p>
<p>Finley, A. O., Datta, A., and Banerjee, S. (2020). spNNGP R package 
for nearest neighbor Gaussian process models. <em>arXiv</em> preprint arXiv:2001.09111.
</p>
<p>Polson, N.G., J.G. Scott, and J. Windle. (2013) Bayesian Inference for
Logistic Models Using Polya-Gamma Latent Variables.
<em>Journal of the American Statistical Association</em>, 108:1339-1349.
</p>
<p>Roberts, G.O. and Rosenthal J.S. (2009) Examples  of adaptive MCMC.
<em>Journal of Computational and Graphical Statistics</em>, 18(2):349-367.
</p>
<p>Bates, Douglas, Martin Maechler, Ben Bolker, Steve Walker (2015).
Fitting Linear Mixed-Effects Models Using lme4. Journal of
Statistical Software, 67(1), 1-48. <a href="https://doi.org/10.18637/jss.v067.i01">doi:10.18637/jss.v067.i01</a>.
</p>
<p>Hooten, M. B., and Hobbs, N. T. (2015). A guide to Bayesian model 
selection for ecologists. <em>Ecological Monographs</em>, 85(1), 3-28.
</p>
<p>Christensen, W. F., and Amemiya, Y. (2002). Latent variable analysis 
of multivariate spatial data. <em>Journal of the American Statistical Association</em>, 
97(457), 302-317.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(400)

# Simulate Data -----------------------------------------------------------
J.x &lt;- 10
J.y &lt;- 10 
J &lt;- J.x * J.y
n.rep &lt;- sample(5, size = J, replace = TRUE)
N &lt;- 6
# Community-level covariate effects
# Occurrence
beta.mean &lt;- c(0.2, -0.2, 0.3, -0.1, 0.4)
p.occ &lt;- length(beta.mean)
tau.sq.beta &lt;- c(0.6, 1.5, 0.4, 0.5, 0.3)
# Detection
alpha.mean &lt;- c(0, 1.2, -0.5)
tau.sq.alpha &lt;- c(1, 0.5, 1.3)
p.det &lt;- length(alpha.mean)
# Random effects
psi.RE &lt;- list(levels = 15, 
               sigma.sq.psi = 0.7)
p.RE &lt;- list(levels = 20, 
             sigma.sq.p = 0.5)
# Draw species-level effects from community means.
beta &lt;- matrix(NA, nrow = N, ncol = p.occ)
alpha &lt;- matrix(NA, nrow = N, ncol = p.det)
for (i in 1:p.occ) {
  beta[, i] &lt;- rnorm(N, beta.mean[i], sqrt(tau.sq.beta[i]))
}
for (i in 1:p.det) {
  alpha[, i] &lt;- rnorm(N, alpha.mean[i], sqrt(tau.sq.alpha[i]))
}
# Number of spatial factors for each SVC
n.factors &lt;- 2
# The intercept and first two covariates have spatially-varying effects
svc.cols &lt;- c(1, 2, 3)
p.svc &lt;- length(svc.cols)
q.p.svc &lt;- n.factors * p.svc
# Spatial decay parameters
phi &lt;- runif(q.p.svc, 3 / 0.9, 3 / 0.1)
# A length N vector indicating the proportion of simulated locations
# that are within the range for a given species.
range.probs &lt;- runif(N, 0.4, 1)
factor.model &lt;- TRUE
cov.model &lt;- 'spherical'
sp &lt;- TRUE

dat &lt;- simMsOcc(J.x = J.x, J.y = J.y, n.rep = n.rep, N = N, beta = beta, alpha = alpha,
                psi.RE = psi.RE, p.RE = p.RE, phi = phi, sp = sp, svc.cols = svc.cols,
                cov.model = cov.model, n.factors = n.factors, 
                factor.model = factor.model, range.probs = range.probs)

y &lt;- dat$y
X &lt;- dat$X
X.re &lt;- dat$X.re
X.p &lt;- dat$X.p
X.p.re &lt;- dat$X.p.re
coords &lt;- dat$coords
range.ind &lt;- dat$range.ind

# Prep data for spOccupancy -----------------------------------------------
# Occurrence covariates
occ.covs &lt;- cbind(X, X.re)
colnames(occ.covs) &lt;- c('int', 'occ.cov.1', 'occ.cov.2', 'occ.cov.3', 
                        'occ.cov.4', 'occ.factor.1')
# Detection covariates
det.covs &lt;- list(det.cov.1 = X.p[, , 2], 
                 det.cov.2 = X.p[, , 3], 
                 det.factor.1 = X.p.re[, , 1]) 
# Data list
data.list &lt;- list(y = y, coords = coords, occ.covs = occ.covs, 
                  det.covs = det.covs, range.ind = range.ind)
# Priors
prior.list &lt;- list(beta.comm.normal = list(mean = 0, var = 2.72),
                   alpha.comm.normal = list(mean = 0, var = 2.72), 
                   tau.sq.beta.ig = list(a = 0.1, b = 0.1), 
                   tau.sq.alpha.ig = list(a = 0.1, b = 0.1), 
                   phi.unif = list(a = 3 / 1, b = 3 / .1)) 
inits.list &lt;- list(alpha.comm = 0, 
                   beta.comm = 0, 
                   beta = 0, 
                   alpha = 0,
                   tau.sq.beta = 1, 
                   tau.sq.alpha = 1, 
                   z = apply(y, c(1, 2), max, na.rm = TRUE)) 
# Tuning
tuning.list &lt;- list(phi = 1)

# Number of batches
n.batch &lt;- 2
# Batch length
batch.length &lt;- 25
n.burn &lt;- 0
n.thin &lt;- 1
n.samples &lt;- n.batch * batch.length

out &lt;- svcMsPGOcc(occ.formula = ~ occ.cov.1 + occ.cov.2 + occ.cov.3 + 
                                  occ.cov.4 + (1 | occ.factor.1),
                  det.formula = ~ det.cov.1 + det.cov.2 + (1 | det.factor.1),
                  data = data.list,
                  inits = inits.list,
                  n.batch = n.batch,
                  n.factors = n.factors,
                  batch.length = batch.length,
                  std.by.sp = TRUE,
                  accept.rate = 0.43,
                  priors = prior.list,
                  svc.cols = svc.cols,
                  cov.model = "spherical",
                  tuning = tuning.list,
                  n.omp.threads = 1,
                  verbose = TRUE,
                  NNGP = TRUE,
                  n.neighbors = 5,
                  search.type = 'cb',
                  n.report = 10,
                  n.burn = n.burn,
                  n.thin = n.thin,
                  n.chains = 1) 

summary(out)
</code></pre>

<hr>
<h2 id='svcPGBinom'>Function for Fitting Single-Species Spatially-Varying Coefficient Binomial Models Using Polya-Gamma Latent Variables</h2><span id='topic+svcPGBinom'></span>

<h3>Description</h3>

<p>The function <code>svcPGBinom</code> fits single-species spatially-varying coefficient binomial models using Polya-Gamma latent variables. Models are fit using Nearest Neighbor Gaussian Processes. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>svcPGBinom(formula, data, inits, priors, tuning, svc.cols = 1, 
           cov.model = "exponential", NNGP = TRUE, 
           n.neighbors = 15, search.type = "cb", n.batch,
           batch.length, accept.rate = 0.43, 
           n.omp.threads = 1, verbose = TRUE, n.report = 100, 
           n.burn = round(.10 * n.batch * batch.length), 
           n.thin = 1, n.chains = 1, k.fold, k.fold.threads = 1, 
           k.fold.seed = 100, k.fold.only = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="svcPGBinom_+3A_formula">formula</code></td>
<td>
<p>a symbolic description of the model to be fit using R's model syntax. Only
right-hand side of formula is specified. See example below. Random intercepts
are allowed using lme4 syntax (Bates et al. 2015).</p>
</td></tr>
<tr><td><code id="svcPGBinom_+3A_data">data</code></td>
<td>
<p>a list containing data necessary for model fitting.
Valid tags are <code>y</code>, <code>covs</code>, <code>weights</code>, and <code>coords</code>. 
<code>y</code> is a numeric vector containing the binomial data with length equal
to the total number of sites (<code class="reqn">J</code>). 
<code>covs</code> is a matrix or data frame containing the covariates used in 
the model, with <code class="reqn">J</code> rows for each column (variable). <code>weights</code> is a 
numeric vector containing the binomial weights (i.e., the total number of 
Bernoulli trials) at each site. If <code>weights</code> is not specified, 
<code>svcPGBinom</code> assumes 1 trial at each site (i.e., presence/absence). 
<code>coords</code> is a <code class="reqn">J \times 2</code> matrix 
of the observation coordinates. Note that <code>spOccupancy</code> assumes coordinates are specified 
in a projected coordinate system.</p>
</td></tr>
<tr><td><code id="svcPGBinom_+3A_inits">inits</code></td>
<td>
<p>a list with each tag corresponding to a parameter name.
Valid tags are <code>beta</code>, <code>sigma.sq</code>, 
<code>phi</code>, <code>w</code>, <code>nu</code>, and <code>sigma.sq.psi</code>.  
<code>nu</code> is only specified if <code>cov.model = "matern"</code>, and <code>sigma.sq.psi</code>
is only specified if there are random effects in <code>formula</code>. 
The value portion of each tag is the parameter's initial value. See <code>priors</code>
description for definition of each parameter name.
Additionally, the tag <code>fix</code> can be set to <code>TRUE</code> 
to fix the starting values across all chains. If <code>fix</code> is not specified
(the default), starting values are varied randomly across chains.</p>
</td></tr>
<tr><td><code id="svcPGBinom_+3A_priors">priors</code></td>
<td>
<p>a list with each tag corresponding to a parameter name. 
Valid tags are <code>beta.normal</code>, <code>phi.unif</code>, 
<code>sigma.sq.ig</code>, <code>sigma.sq.unif</code>, <code>nu.unif</code>, and
<code>sigma.sq.psi.ig</code>. Regression coefficients (<code>beta</code>)
are assumed to follow a normal distribution. The hyperparameters of the 
normal distribution are passed as a list of length two with the first
and second elements corresponding to the mean and variance of the normal
distribution, which are each specified as vectors of 
length equal to the number of coefficients to be estimated or of length
one if priors are the same for all coefficients. If not
specified, prior means are set to 0 and prior variances set to 2.73. The 
spatial variance parameter, <code>sigma.sq</code>, for each spatially-varying 
coefficient is assumed to follow an 
inverse-Gamma distribution or a uniform distribution (default is 
inverse-Gamma). The spatial decay <code>phi</code> and 
smoothness <code>nu</code> parameters are assumed to follow Uniform 
distributions. The hyperparameters of the inverse-Gamma for <code>sigma.sq</code>
are passed as a list with two elements corresponding to the 
shape and scale parametters, respetively, with each element comprised of 
a vector equal to the number of spatially-varying coefficients to be estimated
or of length one if priors are the same for all coefficients.
The hyperparameters of any uniform priors are also passed as a list of 
length two with the first and second elements corresponding to 
the lower and upper support, respectively, which can be passed as
a vector equal to the total number of spatially-varying coefficients to 
be estimated or of length one if priors are the same for all coefficients.
<code>sigma.sq.psi</code> are the random effect variances for any random effects, 
respectively, and are assumed to follow an 
inverse-Gamma distribution. The hyperparameters of
the inverse-Gamma distribution are passed as a list of length two with the 
first and second elements corresponding to the shape and scale parameters, 
respectively, which are each specified as vectors of length equal to the 
number of random intercepts or of length one if priors are the same for all
random effect variances.</p>
</td></tr>
<tr><td><code id="svcPGBinom_+3A_svc.cols">svc.cols</code></td>
<td>
<p>a vector indicating the variables whose effects will be 
estimated as spatially-varying coefficients. <code>svc.cols</code> can be an 
integer vector with values indicating the order of covariates specified 
in the model formula (with 1 being the intercept if specified), or it can 
be specified as a character vector with names corresponding to variable 
names in <code>covs</code> (for the intercept, use <code>'(Intercept)'</code>).</p>
</td></tr> 
<tr><td><code id="svcPGBinom_+3A_cov.model">cov.model</code></td>
<td>
<p>a quoted keyword that specifies the covariance
function used to model the spatial dependence structure among the
observations.  Supported covariance model key words are:
<code>"exponential"</code>, <code>"matern"</code>, <code>"spherical"</code>, and
<code>"gaussian"</code>.</p>
</td></tr>
<tr><td><code id="svcPGBinom_+3A_tuning">tuning</code></td>
<td>
<p>a list with each tag corresponding to a parameter
name. Valid tags are <code>phi</code>, <code>sigma.sq</code>, and <code>nu</code>. 
The value portion of each tag defines the initial variance of the Adaptive sampler. See
Roberts and Rosenthal (2009) for details.</p>
</td></tr>
<tr><td><code id="svcPGBinom_+3A_nngp">NNGP</code></td>
<td>
<p>if <code>TRUE</code>, model is fit with an NNGP. If <code>FALSE</code>, 
a full Gaussian process is used. See Datta et al. (2016) and 
Finley et al. (2019) for more information.</p>
</td></tr>
<tr><td><code id="svcPGBinom_+3A_n.neighbors">n.neighbors</code></td>
<td>
<p>number of neighbors used in the NNGP. Only used if 
<code>NNGP = TRUE</code>. Datta et al. (2016) showed that 15 neighbors is usually 
sufficient, but that as few as 5 neighbors can be adequate for certain data
sets, which can lead to even greater decreases in run time. We recommend
starting with 15 neighbors (the default) and if additional gains in computation
time are desired, subsequently compare the results with a smaller number
of neighbors using WAIC or k-fold cross-validation.</p>
</td></tr>
<tr><td><code id="svcPGBinom_+3A_search.type">search.type</code></td>
<td>
<p>a quoted keyword that specifies the type of nearest
neighbor search algorithm. Supported method key words are: <code>"cb"</code> and
<code>"brute"</code>. The <code>"cb"</code> should generally be much
faster. If locations do not have identical coordinate values on
the axis used for the nearest neighbor ordering then <code>"cb"</code> 
and <code>"brute"</code> should produce identical neighbor sets. 
However, if there are identical coordinate values on the axis used 
for nearest neighbor ordering, then <code>"cb"</code> and <code>"brute"</code> 
might produce different, but equally valid, neighbor sets, 
e.g., if data are on a grid. </p>
</td></tr>
<tr><td><code id="svcPGBinom_+3A_n.batch">n.batch</code></td>
<td>
<p>the number of MCMC batches in each chain to run for the Adaptive MCMC 
sampler. See Roberts and Rosenthal (2009) for details.</p>
</td></tr>
<tr><td><code id="svcPGBinom_+3A_batch.length">batch.length</code></td>
<td>
<p>the length of each MCMC batch in each chain to run for the Adaptive 
MCMC sampler. See Roberts and Rosenthal (2009) for details.</p>
</td></tr>
<tr><td><code id="svcPGBinom_+3A_accept.rate">accept.rate</code></td>
<td>
<p>target acceptance rate for Adaptive MCMC. Default is 
0.43. See Roberts and Rosenthal (2009) for details.</p>
</td></tr>
<tr><td><code id="svcPGBinom_+3A_n.omp.threads">n.omp.threads</code></td>
<td>
<p>a positive integer indicating
the number of threads to use for SMP parallel processing. The package must
be compiled for OpenMP support. For most Intel-based machines, we
recommend setting <code>n.omp.threads</code> up to the number of
hyperthreaded cores. Note, <code>n.omp.threads</code> &gt; 1 might not
work on some systems.</p>
</td></tr>
<tr><td><code id="svcPGBinom_+3A_verbose">verbose</code></td>
<td>
<p>if <code>TRUE</code>, messages about data preparation, 
model specification, and progress of the sampler are printed to the screen. 
Otherwise, no messages are printed.</p>
</td></tr>
<tr><td><code id="svcPGBinom_+3A_n.report">n.report</code></td>
<td>
<p>the interval to report Metropolis sampler acceptance and
MCMC progress.</p>
</td></tr>
<tr><td><code id="svcPGBinom_+3A_n.burn">n.burn</code></td>
<td>
<p>the number of samples out of the total <code>n.batch * batch.length</code> 
samples in each chain to discard as burn-in. By default, the first 
10% of samples is discarded.</p>
</td></tr>
<tr><td><code id="svcPGBinom_+3A_n.thin">n.thin</code></td>
<td>
<p>the thinning interval for collection of MCMC samples. The
thinning occurs after the <code>n.burn</code> samples are discarded. Default 
value is set to 1.</p>
</td></tr>
<tr><td><code id="svcPGBinom_+3A_n.chains">n.chains</code></td>
<td>
<p>the number of MCMC chains to run in sequence.</p>
</td></tr>
<tr><td><code id="svcPGBinom_+3A_k.fold">k.fold</code></td>
<td>
<p>specifies the number of <em>k</em> folds for cross-validation. 
If not specified as an argument, then cross-validation is not performed
and <code>k.fold.threads</code> and <code>k.fold.seed</code> are ignored. In <em>k</em>-fold
cross-validation, the data specified in <code>data</code> is randomly
partitioned into <em>k</em> equal sized subsamples. Of the <em>k</em> subsamples, 
<em>k</em> - 1 subsamples are used to fit the model and the remaining <em>k</em>
samples are used for prediction. The cross-validation process is repeated 
<em>k</em> times (the folds). As a scoring rule, we use the model deviance 
as described in Hooten and Hobbs (2015). Cross-validation is performed
after the full model is fit using all the data. Cross-validation results
are reported in the <code>k.fold.deviance</code> object in the return list.</p>
</td></tr>
<tr><td><code id="svcPGBinom_+3A_k.fold.threads">k.fold.threads</code></td>
<td>
<p>number of threads to use for cross-validation. If 
<code>k.fold.threads &gt; 1</code> parallel processing is accomplished using the 
<span class="pkg">foreach</span> and <span class="pkg">doParallel</span> packages. Ignored if <code>k.fold</code>
is not specified.</p>
</td></tr> 
<tr><td><code id="svcPGBinom_+3A_k.fold.seed">k.fold.seed</code></td>
<td>
<p>seed used to split data set into <code>k.fold</code> parts
for k-fold cross-validation. Ignored if <code>k.fold</code> is not specified.</p>
</td></tr>
<tr><td><code id="svcPGBinom_+3A_k.fold.only">k.fold.only</code></td>
<td>
<p>a logical value indicating whether to only perform 
cross-validation (<code>TRUE</code>) or perform cross-validation after fitting 
the full model (<code>FALSE</code>). Default value is <code>FALSE</code>.</p>
</td></tr> 
<tr><td><code id="svcPGBinom_+3A_...">...</code></td>
<td>
<p>currently no additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>svcPGBinom</code> that is a list comprised of: 
</p>
<table>
<tr><td><code>beta.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the regression coefficients.</p>
</td></tr>
<tr><td><code>y.rep.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples 
for the fitted data values</p>
</td></tr>
<tr><td><code>psi.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the occurrence probability values</p>
</td></tr>
<tr><td><code>theta.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for spatial covariance parameters.</p>
</td></tr>
<tr><td><code>w.samples</code></td>
<td>
<p>a three-dimensional array of posterior samples for the 
latent spatial random effects for all spatially-varying coefficients. 
Dimensions correspond to MCMC sample, coefficient, and sites.</p>
</td></tr>
<tr><td><code>sigma.sq.psi.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for variances of unstructured random intercepts included in the 
model. Only included if random intercepts are specified in 
<code>formula</code>.</p>
</td></tr>
<tr><td><code>beta.star.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the unstructured random effects. Only included if random intercepts
are specified in <code>formula</code>.</p>
</td></tr>
<tr><td><code>like.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the likelihood value associated with each site. Used for calculating
WAIC.</p>
</td></tr>
<tr><td><code>rhat</code></td>
<td>
<p>a list of Gelman-Rubin diagnostic values for some of the model
parameters.</p>
</td></tr>
<tr><td><code>ESS</code></td>
<td>
<p>a list of effective sample sizes for some of the model parameters.</p>
</td></tr>
<tr><td><code>run.time</code></td>
<td>
<p>execution time reported using <code>proc.time()</code>.</p>
</td></tr>
<tr><td><code>k.fold.deviance</code></td>
<td>
<p>soring rule (deviance) from k-fold cross-validation. 
Only included if <code>k.fold</code> is specified in function call.</p>
</td></tr>
</table>
<p>The return object will include additional objects used for 
subsequent prediction and/or model fit evaluation.
</p>


<h3>Author(s)</h3>

<p>Jeffrey W. Doser <a href="mailto:doserjef@msu.edu">doserjef@msu.edu</a>, <br />
Andrew O. Finley <a href="mailto:finleya@msu.edu">finleya@msu.edu</a>
</p>


<h3>References</h3>

<p>Bates, Douglas, Martin Maechler, Ben Bolker, Steve Walker (2015).
Fitting Linear Mixed-Effects Models Using lme4. Journal of
Statistical Software, 67(1), 1-48. <a href="https://doi.org/10.18637/jss.v067.i01">doi:10.18637/jss.v067.i01</a>.
</p>
<p>Datta, A., S. Banerjee, A.O. Finley, and A.E. Gelfand. (2016)
Hierarchical Nearest-Neighbor Gaussian process models for large
geostatistical datasets. <em>Journal of the American Statistical
Association</em>, <a href="https://doi.org/10.1080/01621459.2015.1044091">doi:10.1080/01621459.2015.1044091</a>.
</p>
<p>Finley, A.O., A. Datta, B.D. Cook, D.C. Morton, H.E. Andersen, and
S. Banerjee. (2019) Efficient algorithms for Bayesian Nearest Neighbor
Gaussian Processes. <em>Journal of Computational and Graphical
Statistics</em>, <a href="https://doi.org/10.1080/10618600.2018.1537924">doi:10.1080/10618600.2018.1537924</a>.
</p>
<p>Finley, A. O., and  Banerjee, S. (2020). Bayesian spatially varying coefficient 
models in the spBayes R package. <em>Environmental Modelling and Software</em>, 
125, 104608.
</p>
<p>Polson, N.G., J.G. Scott, and J. Windle. (2013) Bayesian Inference for
Logistic Models Using Polya-Gamma Latent Variables. 
<em>Journal of the American Statistical Association</em>, 108:1339-1349.
</p>
<p>Roberts, G.O. and Rosenthal J.S. (2009) Examples  of adaptive MCMC. 
<em>Journal of Computational and Graphical Statistics</em>, 18(2):349-367.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1000)
# Sites
J.x &lt;- 10
J.y &lt;- 10
J &lt;- J.x * J.y
# Binomial weights
weights &lt;- sample(10, J, replace = TRUE)
beta &lt;- c(0, 0.5, -0.2, 0.75)
p &lt;- length(beta)
# No unstructured random effects
psi.RE &lt;- list()
# Spatial parameters
sp &lt;- TRUE
# Two spatially-varying covariates. 
svc.cols &lt;- c(1, 2)
p.svc &lt;- length(svc.cols)
cov.model &lt;- "exponential"
sigma.sq &lt;- runif(p.svc, 0.4, 1.5)
phi &lt;- runif(p.svc, 3/1, 3/0.2)

# Simulate the data  
dat &lt;- simBinom(J.x = J.x, J.y = J.y, weights = weights, beta = beta, 
                psi.RE = psi.RE, sp = sp, svc.cols = svc.cols, 
                cov.model = cov.model, sigma.sq = sigma.sq, phi = phi)

# Binomial data
y &lt;- dat$y
# Covariates
X &lt;- dat$X
# Spatial coordinates
coords &lt;- dat$coords

# Package all data into a list
# Covariates
covs &lt;- cbind(X)
colnames(covs) &lt;- c('int', 'cov.1', 'cov.2', 'cov.3')

# Data list bundle
data.list &lt;- list(y = y, 
                  covs = covs,
                  coords = coords, 
                  weights = weights)
# Priors
prior.list &lt;- list(beta.normal = list(mean = 0, var = 2.72), 
                   sigma.sq.ig = list(a = 2, b = 1), 
                   phi.unif = list(a = 3 / 1, b = 3 / 0.1)) 

# Starting values
inits.list &lt;- list(beta = 0, alpha = 0,
                   sigma.sq = 1, phi = phi)
# Tuning
tuning.list &lt;- list(phi = 1) 

n.batch &lt;- 10
batch.length &lt;- 25
n.burn &lt;- 100
n.thin &lt;- 1

out &lt;- svcPGBinom(formula = ~ cov.1 + cov.2 + cov.3, 
                  svc.cols = c(1, 2),
                  data = data.list, 
                  n.batch = n.batch, 
                  batch.length = batch.length, 
                  inits = inits.list, 
                  priors = prior.list,
                  accept.rate = 0.43, 
                  cov.model = "exponential", 
                  tuning = tuning.list, 
                  n.omp.threads = 1, 
                  verbose = TRUE, 
                  NNGP = TRUE, 
                  n.neighbors = 5,
                  n.report = 2, 
                  n.burn = n.burn, 
                  n.thin = n.thin, 
                  n.chains = 1) 

summary(out)
</code></pre>

<hr>
<h2 id='svcPGOcc'>Function for Fitting Single-Species Spatially-Varying Coefficient Occupancy Models Using Polya-Gamma Latent Variables</h2><span id='topic+svcPGOcc'></span>

<h3>Description</h3>

<p>The function <code>svcPGOcc</code> fits single-species spatially-varying coefficient occupancy models using Polya-Gamma latent variables. Models are fit using Nearest Neighbor Gaussian Processes. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>svcPGOcc(occ.formula, det.formula, data, inits, priors, 
         tuning, svc.cols = 1, cov.model = "exponential", NNGP = TRUE, 
         n.neighbors = 15, search.type = "cb", n.batch,
         batch.length, accept.rate = 0.43, 
         n.omp.threads = 1, verbose = TRUE, n.report = 100, 
         n.burn = round(.10 * n.batch * batch.length), 
         n.thin = 1, n.chains = 1, k.fold, k.fold.threads = 1, 
         k.fold.seed = 100, k.fold.only = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="svcPGOcc_+3A_occ.formula">occ.formula</code></td>
<td>
<p>a symbolic description of the model to be fit
for the occurrence portion of the model using R's model syntax. Only
right-hand side of formula is specified. See example below. Random intercepts
are allowed using lme4 syntax (Bates et al. 2015).</p>
</td></tr>
<tr><td><code id="svcPGOcc_+3A_det.formula">det.formula</code></td>
<td>
<p>a symbolic description of the model to be fit
for the detection portion of the model using R's model syntax. Only
right-hand side of formula is specified. See example below. Random intercepts
are allowed using lme4 syntax (Bates et al. 2015).</p>
</td></tr>
<tr><td><code id="svcPGOcc_+3A_data">data</code></td>
<td>
<p>a list containing data necessary for model fitting.
Valid tags are <code>y</code>, <code>occ.covs</code>, <code>det.covs</code>, <code>coords</code>, and <code>grid.index</code>. 
<code>y</code> is the detection-nondetection data matrix or data frame with 
first dimension equal to the number of sites (<code class="reqn">J</code>) and second 
dimension equal to the maximum number of replicates at a given site. 
<code>occ.covs</code> is a matrix or data frame containing the variables used 
in the occupancy portion of the model, with <code class="reqn">J</code> rows for each column 
(variable). <code>det.covs</code> is a list of variables included in the 
detection portion of the model. Each list element is a different detection 
covariate, which can be site-level or observational-level. Site-level 
covariates are specified as a vector of length <code class="reqn">J</code> while 
observation-level covariates are specified 
as a matrix or data frame with the number of rows equal to <code class="reqn">J</code> and 
number of columns equal to the maximum number of replicates at a given site. 
<code>coords</code> is a matrix of the observation coordinates used
to estimate the spatial random effect for each site. <code>coords</code> has two columns for the 
easting and northing coordinate, respectively. Typically, each site in the data 
set will have it's own coordinate, such that <code>coords</code> is a <code class="reqn">J \times 2</code> 
matrix and <code>grid.index</code> should not be specified. 
If you desire to estimate the SVCs at some larger spatial level, 
e.g., if points fall within grid cells and you want to estimate SVCs for 
each grid cell instead of each point, <code>coords</code> can be specified as the coordinate for 
each grid cell. In such a case, <code>grid.index</code> is an indexing vector of length J, where each 
value of <code>grid.index</code> indicates the corresponding row in <code>coords</code> that the given 
site corresponds to. Note that <code>spOccupancy</code> assumes coordinates are specified 
in a projected coordinate system.</p>
</td></tr>
<tr><td><code id="svcPGOcc_+3A_inits">inits</code></td>
<td>
<p>a list with each tag corresponding to a parameter name.
Valid tags are <code>z</code>, <code>beta</code>, <code>alpha</code>, <code>sigma.sq</code>, 
<code>phi</code>, <code>w</code>, <code>nu</code>, <code>sigma.sq.psi</code>, <code>sigma.sq.p</code>. 
<code>nu</code> is only specified if <code>cov.model = "matern"</code>, <code>sigma.sq.p</code>
is only specified if there are random effects in <code>det.formula</code>, and <code>sigma.sq.psi</code>
is only specified if there are random effects in <code>occ.formula</code>. 
The value portion of each tag is the parameter's initial value. See <code>priors</code>
description for definition of each parameter name.
Additionally, the tag <code>fix</code> can be set to <code>TRUE</code> 
to fix the starting values across all chains. If <code>fix</code> is not specified
(the default), starting values are varied randomly across chains.</p>
</td></tr>
<tr><td><code id="svcPGOcc_+3A_priors">priors</code></td>
<td>
<p>a list with each tag corresponding to a parameter name. 
Valid tags are <code>beta.normal</code>, <code>alpha.normal</code>, <code>phi.unif</code>, 
<code>sigma.sq.ig</code>, <code>sigma.sq.unif</code>, <code>nu.unif</code>, 
<code>sigma.sq.psi.ig</code>, and <code>sigma.sq.p.ig</code>. Occurrence 
(<code>beta</code>) and detection (<code>alpha</code>) regression coefficients 
are assumed to follow a normal distribution. The hyperparameters of the 
normal distribution are passed as a list of length two with the first
and second elements corresponding to the mean and variance of the normal
distribution, which are each specified as vectors of 
length equal to the number of coefficients to be estimated or of length
one if priors are the same for all coefficients. If not
specified, prior means are set to 0 and prior variances set to 2.73. The 
spatial variance parameter, <code>sigma.sq</code>, is assumed to follow an 
inverse-Gamma distribution or a uniform distribution (default is 
inverse-Gamma). The spatial decay <code>phi</code> and 
smoothness <code>nu</code> parameters are assumed to follow Uniform 
distributions. The hyperparameters of the inverse-Gamma for <code>sigma.sq</code>
are passed as a list with two elements corresponding to the 
shape and scale parameters, respetively, with each element comprised of 
a vector equal to the number of spatially-varying coefficients to be estimated
or of length one if priors are the same for all coefficients.
The hyperparameters of any uniform priors are also passed as a list of 
length two with the first and second elements corresponding to 
the lower and upper support, respectively, which can be passed as
a vector equal to the total number of spatially-varying coefficients to 
be estimated or of length one if priors are the same for all coefficients. <code>sigma.sq.psi</code> and 
<code>sigma.sq.p</code> are the random effect variances for any occurrence or 
detection random effects, respectively, and are assumed to follow an 
inverse-Gamma distribution. The hyperparameters of
the inverse-Gamma distribution are passed as a list of length two with the 
first and second elements corresponding to the shape and scale parameters, 
respectively, which are each specified as vectors of length equal to the 
number of random intercepts or of length one if priors are the same for all
random effect variances.</p>
</td></tr>
<tr><td><code id="svcPGOcc_+3A_svc.cols">svc.cols</code></td>
<td>
<p>a vector indicating the variables whose effects will be 
estimated as spatially-varying coefficients. <code>svc.cols</code> can be an 
integer vector with values indicating the order of covariates specified 
in the model formula (with 1 being the intercept if specified), or it can 
be specified as a character vector with names corresponding to variable 
names in <code>occ.covs</code> (for the intercept, use <code>'(Intercept)'</code>). <code>svc.cols</code>
default argument of 1 results in a spatial occupancy model analogous to 
<code>spPGOcc</code> (assuming an intercept is included in the model).</p>
</td></tr> 
<tr><td><code id="svcPGOcc_+3A_cov.model">cov.model</code></td>
<td>
<p>a quoted keyword that specifies the covariance
function used to model the spatial dependence structure among the
observations.  Supported covariance model key words are:
<code>"exponential"</code>, <code>"matern"</code>, <code>"spherical"</code>, and
<code>"gaussian"</code>.</p>
</td></tr>
<tr><td><code id="svcPGOcc_+3A_tuning">tuning</code></td>
<td>
<p>a list with each tag corresponding to a parameter
name. Valid tags are <code>phi</code>, <code>nu</code>, and <code>sigma.sq</code>. The value portion of each
tag defines the initial variance of the Adaptive sampler. See
Roberts and Rosenthal (2009) for details.</p>
</td></tr>
<tr><td><code id="svcPGOcc_+3A_nngp">NNGP</code></td>
<td>
<p>if <code>TRUE</code>, model is fit with an NNGP. If <code>FALSE</code>, 
a full Gaussian process is used. See Datta et al. (2016) and 
Finley et al. (2019) for more information. Only <code>NNGP = TRUE</code> is 
currently supported for spatially-varying coefficient models.</p>
</td></tr>
<tr><td><code id="svcPGOcc_+3A_n.neighbors">n.neighbors</code></td>
<td>
<p>number of neighbors used in the NNGP. Only used if 
<code>NNGP = TRUE</code>. Datta et al. (2016) showed that 15 neighbors is usually 
sufficient, but that as few as 5 neighbors can be adequate for certain data
sets, which can lead to even greater decreases in run time. We recommend
starting with 15 neighbors (the default) and if additional gains in computation
time are desired, subsequently compare the results with a smaller number
of neighbors using WAIC or k-fold cross-validation.</p>
</td></tr>
<tr><td><code id="svcPGOcc_+3A_search.type">search.type</code></td>
<td>
<p>a quoted keyword that specifies the type of nearest
neighbor search algorithm. Supported method key words are: <code>"cb"</code> and
<code>"brute"</code>. The <code>"cb"</code> should generally be much
faster. If locations do not have identical coordinate values on
the axis used for the nearest neighbor ordering then <code>"cb"</code> 
and <code>"brute"</code> should produce identical neighbor sets. 
However, if there are identical coordinate values on the axis used 
for nearest neighbor ordering, then <code>"cb"</code> and <code>"brute"</code> 
might produce different, but equally valid, neighbor sets, 
e.g., if data are on a grid. </p>
</td></tr>
<tr><td><code id="svcPGOcc_+3A_n.batch">n.batch</code></td>
<td>
<p>the number of MCMC batches in each chain to run for the Adaptive MCMC 
sampler. See Roberts and Rosenthal (2009) for details.</p>
</td></tr>
<tr><td><code id="svcPGOcc_+3A_batch.length">batch.length</code></td>
<td>
<p>the length of each MCMC batch in each chain to run for the Adaptive 
MCMC sampler. See Roberts and Rosenthal (2009) for details.</p>
</td></tr>
<tr><td><code id="svcPGOcc_+3A_accept.rate">accept.rate</code></td>
<td>
<p>target acceptance rate for Adaptive MCMC. Default is 
0.43. See Roberts and Rosenthal (2009) for details.</p>
</td></tr>
<tr><td><code id="svcPGOcc_+3A_n.omp.threads">n.omp.threads</code></td>
<td>
<p>a positive integer indicating
the number of threads to use for SMP parallel processing. The package must
be compiled for OpenMP support. For most Intel-based machines, we
recommend setting <code>n.omp.threads</code> up to the number of
hyperthreaded cores. Note, <code>n.omp.threads</code> &gt; 1 might not
work on some systems.</p>
</td></tr>
<tr><td><code id="svcPGOcc_+3A_verbose">verbose</code></td>
<td>
<p>if <code>TRUE</code>, messages about data preparation, 
model specification, and progress of the sampler are printed to the screen. 
Otherwise, no messages are printed.</p>
</td></tr>
<tr><td><code id="svcPGOcc_+3A_n.report">n.report</code></td>
<td>
<p>the interval to report Metropolis sampler acceptance and
MCMC progress.</p>
</td></tr>
<tr><td><code id="svcPGOcc_+3A_n.burn">n.burn</code></td>
<td>
<p>the number of samples out of the total <code>n.batch * batch.length</code> 
samples in each chain to discard as burn-in. By default, the first 
10% of samples is discarded.</p>
</td></tr>
<tr><td><code id="svcPGOcc_+3A_n.thin">n.thin</code></td>
<td>
<p>the thinning interval for collection of MCMC samples. The
thinning occurs after the <code>n.burn</code> samples are discarded. Default 
value is set to 1.</p>
</td></tr>
<tr><td><code id="svcPGOcc_+3A_n.chains">n.chains</code></td>
<td>
<p>the number of MCMC chains to run in sequence.</p>
</td></tr>
<tr><td><code id="svcPGOcc_+3A_k.fold">k.fold</code></td>
<td>
<p>specifies the number of <em>k</em> folds for cross-validation. 
If not specified as an argument, then cross-validation is not performed
and <code>k.fold.threads</code> and <code>k.fold.seed</code> are ignored. In <em>k</em>-fold
cross-validation, the data specified in <code>data</code> is randomly
partitioned into <em>k</em> equal sized subsamples. Of the <em>k</em> subsamples, 
<em>k</em> - 1 subsamples are used to fit the model and the remaining <em>k</em>
samples are used for prediction. The cross-validation process is repeated 
<em>k</em> times (the folds). As a scoring rule, we use the model deviance 
as described in Hooten and Hobbs (2015). Cross-validation is performed
after the full model is fit using all the data. Cross-validation results
are reported in the <code>k.fold.deviance</code> object in the return list.</p>
</td></tr>
<tr><td><code id="svcPGOcc_+3A_k.fold.threads">k.fold.threads</code></td>
<td>
<p>number of threads to use for cross-validation. If 
<code>k.fold.threads &gt; 1</code> parallel processing is accomplished using the 
<span class="pkg">foreach</span> and <span class="pkg">doParallel</span> packages. Ignored if <code>k.fold</code>
is not specified.</p>
</td></tr> 
<tr><td><code id="svcPGOcc_+3A_k.fold.seed">k.fold.seed</code></td>
<td>
<p>seed used to split data set into <code>k.fold</code> parts
for k-fold cross-validation. Ignored if <code>k.fold</code> is not specified.</p>
</td></tr>
<tr><td><code id="svcPGOcc_+3A_k.fold.only">k.fold.only</code></td>
<td>
<p>a logical value indicating whether to only perform 
cross-validation (<code>TRUE</code>) or perform cross-validation after fitting 
the full model (<code>FALSE</code>). Default value is <code>FALSE</code>.</p>
</td></tr> 
<tr><td><code id="svcPGOcc_+3A_...">...</code></td>
<td>
<p>currently no additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>svcPGOcc</code> that is a list comprised of: 
</p>
<table>
<tr><td><code>beta.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the occurrence regression coefficients.</p>
</td></tr>
<tr><td><code>alpha.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the detection regression coefficients.</p>
</td></tr>
<tr><td><code>z.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples 
for the latent occurrence values</p>
</td></tr>
<tr><td><code>psi.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the latent occurrence probability values</p>
</td></tr>
<tr><td><code>theta.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for spatial covariance parameters.</p>
</td></tr>
<tr><td><code>w.samples</code></td>
<td>
<p>a three-dimensional array of posterior samples for the 
latent spatial random effects for all spatially-varying coefficients. 
Dimensions correspond to MCMC sample, coefficient, and sites.</p>
</td></tr>
<tr><td><code>sigma.sq.psi.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for variances of random intercepts included in the occupancy portion
of the model. Only included if random intercepts are specified in 
<code>occ.formula</code>.</p>
</td></tr>
<tr><td><code>sigma.sq.p.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for variances of random intercpets included in the detection portion 
of the model. Only included if random intercepts are specified in 
<code>det.formula</code>.</p>
</td></tr>
<tr><td><code>beta.star.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the occurrence random effects. Only included if random intercepts
are specified in <code>occ.formula</code>.</p>
</td></tr>
<tr><td><code>alpha.star.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the detection random effects. Only included if random intercepts 
are specified in <code>det.formula</code>.</p>
</td></tr>
<tr><td><code>like.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the likelihood value associated with each site. Used for calculating
WAIC.</p>
</td></tr>
<tr><td><code>rhat</code></td>
<td>
<p>a list of Gelman-Rubin diagnostic values for some of the model
parameters.</p>
</td></tr>
<tr><td><code>ESS</code></td>
<td>
<p>a list of effective sample sizes for some of the model parameters.</p>
</td></tr>
<tr><td><code>run.time</code></td>
<td>
<p>execution time reported using <code>proc.time()</code>.</p>
</td></tr>
<tr><td><code>k.fold.deviance</code></td>
<td>
<p>soring rule (deviance) from k-fold cross-validation. 
Only included if <code>k.fold</code> is specified in function call.</p>
</td></tr>
</table>
<p>The return object will include additional objects used for 
subsequent prediction and/or model fit evaluation. Note that detection
probability values are not included in the model object, but can be 
extracted using <code>fitted()</code>.
</p>


<h3>Author(s)</h3>

<p>Jeffrey W. Doser <a href="mailto:doserjef@msu.edu">doserjef@msu.edu</a>, <br />
Andrew O. Finley <a href="mailto:finleya@msu.edu">finleya@msu.edu</a>
</p>


<h3>References</h3>

<p>Bates, Douglas, Martin Maechler, Ben Bolker, Steve Walker (2015).
Fitting Linear Mixed-Effects Models Using lme4. Journal of
Statistical Software, 67(1), 1-48. <a href="https://doi.org/10.18637/jss.v067.i01">doi:10.18637/jss.v067.i01</a>.
</p>
<p>Datta, A., S. Banerjee, A.O. Finley, and A.E. Gelfand. (2016)
Hierarchical Nearest-Neighbor Gaussian process models for large
geostatistical datasets. <em>Journal of the American Statistical
Association</em>, <a href="https://doi.org/10.1080/01621459.2015.1044091">doi:10.1080/01621459.2015.1044091</a>.
</p>
<p>Finley, A.O., A. Datta, B.D. Cook, D.C. Morton, H.E. Andersen, and
S. Banerjee. (2019) Efficient algorithms for Bayesian Nearest Neighbor
Gaussian Processes. <em>Journal of Computational and Graphical
Statistics</em>, <a href="https://doi.org/10.1080/10618600.2018.1537924">doi:10.1080/10618600.2018.1537924</a>.
</p>
<p>Finley, A. O., and  Banerjee, S. (2020). Bayesian spatially varying coefficient 
models in the spBayes R package. <em>Environmental Modelling and Software</em>, 
125, 104608.
</p>
<p>Polson, N.G., J.G. Scott, and J. Windle. (2013) Bayesian Inference for
Logistic Models Using Polya-Gamma Latent Variables. 
<em>Journal of the American Statistical Association</em>, 108:1339-1349.
</p>
<p>Roberts, G.O. and Rosenthal J.S. (2009) Examples  of adaptive MCMC. 
<em>Journal of Computational and Graphical Statistics</em>, 18(2):349-367.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(400)
# Simulate Data -----------------------------------------------------------
J.x &lt;- 8
J.y &lt;- 8
J &lt;- J.x * J.y
n.rep &lt;- sample(2:4, J, replace = TRUE)
beta &lt;- c(0.5, 2)
p.occ &lt;- length(beta)
alpha &lt;- c(0, 1)
p.det &lt;- length(alpha)
phi &lt;- c(3 / .6, 3 / .8)
sigma.sq &lt;- c(1.2, 0.7)
svc.cols &lt;- c(1, 2)
dat &lt;- simOcc(J.x = J.x, J.y = J.y, n.rep = n.rep, beta = beta, alpha = alpha, 
              sigma.sq = sigma.sq, phi = phi, sp = TRUE, cov.model = 'exponential', 
              svc.cols = svc.cols)
# Detection-nondetection data
y &lt;- dat$y
# Occupancy covariates
X &lt;- dat$X
# Detection covarites
X.p &lt;- dat$X.p
# Spatial coordinates
coords &lt;- dat$coords

# Package all data into a list
occ.covs &lt;- X[, -1, drop = FALSE]
colnames(occ.covs) &lt;- c('occ.cov')
det.covs &lt;- list(det.cov.1 = X.p[, , 2])
data.list &lt;- list(y = y, 
                  occ.covs = occ.covs, 
                  det.covs = det.covs, 
                  coords = coords)

# Number of batches
n.batch &lt;- 10
# Batch length
batch.length &lt;- 25
n.iter &lt;- n.batch * batch.length
# Priors 
prior.list &lt;- list(beta.normal = list(mean = 0, var = 2.72), 
                   alpha.normal = list(mean = 0, var = 2.72),
                   sigma.sq.ig = list(a = 2, b = 1), 
                   phi.unif = list(a = 3/1, b = 3/.1)) 
# Initial values
inits.list &lt;- list(alpha = 0, beta = 0,
                   phi = 3 / .5, 
                   sigma.sq = 2,
                   w = matrix(0, nrow = length(svc.cols), ncol = nrow(X)),
                   z = apply(y, 1, max, na.rm = TRUE))
# Tuning
tuning.list &lt;- list(phi = 1) 

out &lt;- svcPGOcc(occ.formula = ~ occ.cov, 
                det.formula = ~ det.cov.1, 
                data = data.list, 
                inits = inits.list, 
                n.batch = n.batch, 
                batch.length = batch.length, 
                accept.rate = 0.43, 
                priors = prior.list,
                cov.model = 'exponential', 
                svc.cols = c(1, 2),
                tuning = tuning.list, 
                n.omp.threads = 1, 
                verbose = TRUE, 
                NNGP = TRUE, 
                n.neighbors = 5, 
                search.type = 'cb', 
                n.report = 10, 
                n.burn = 50, 
                n.thin = 1)

summary(out) 
</code></pre>

<hr>
<h2 id='svcTMsPGOcc'>Function for Fitting Multi-Species Multi-Season Spatially-Varying Coefficient Occupancy Models</h2><span id='topic+svcTMsPGOcc'></span>

<h3>Description</h3>

<p>The function <code>svcTMsPGOcc</code> fits multi-species multi-season spatially-varying coefficient occupancy models with species correlations (i.e., a spatially-explicit joint species distribution model with imperfect detection). We use Polya-Gamma latent variables and a spatial factor modeling approach. Models are implemented using a Nearest Neighbor Gaussian Process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>svcTMsPGOcc(occ.formula, det.formula, data, inits, priors, tuning, 
            svc.cols = 1, cov.model = 'exponential', NNGP = TRUE, 
            n.neighbors = 15, search.type = 'cb', std.by.sp = FALSE, 
            n.factors, svc.by.sp, n.batch, batch.length, 
            accept.rate = 0.43, n.omp.threads = 1, 
            verbose = TRUE, ar1 = FALSE, n.report = 100, 
            n.burn = round(.10 * n.batch * batch.length), n.thin = 1, 
            n.chains = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="svcTMsPGOcc_+3A_occ.formula">occ.formula</code></td>
<td>
<p>a symbolic description of the model to be fit
for the occurrence portion of the model using R's model syntax. Random
intercepts are allowed using lme4 syntax (Bates et al. 2015). Only
right-hand side of formula is specified. See example below.</p>
</td></tr>
<tr><td><code id="svcTMsPGOcc_+3A_det.formula">det.formula</code></td>
<td>
<p>a symbolic description of the model to be fit
for the detection portion of the model using R's model syntax. Only
right-hand side of formula is specified. See example below. Random 
intercepts are allowed using lme4 syntax (Bates et al. 2015).</p>
</td></tr>
<tr><td><code id="svcTMsPGOcc_+3A_data">data</code></td>
<td>
<p>a list containing data necessary for model fitting.
Valid tags are <code>y</code>, <code>occ.covs</code>, <code>det.covs</code>, 
<code>coords</code>, <code>range.ind</code>, and <code>grid.index</code>. 
<code>y</code> is a four-dimensional array with first dimension equal to the 
number of species, second dimension equal to the number of sites, third
dimension equal to the number of primary time periods, and 
fourth dimension equal to the maximum number of secondary replicates at a given site. 
<code>occ.covs</code> is a list of variables included in the occurrence portion of the model. Each
list element is a different occurrence covariate, which can be site level
or site/primary time period level. Site-level covariates are specified as a vector of 
length <code class="reqn">J</code> while site/primary time period level covariates are specified as a matrix
with rows corresponding to sites and columns correspond to primary time periods.
Similarly, <code>det.covs</code> is a list of variables included in the detection
portion of the model, with each list element corresponding to an individual variable.    
In addition to site-level and/or site/primary time period-level, 
detection covariates can also be observational-level. Observation-level covariates
are specified as a three-dimensional array with first dimension corresponding to 
sites, second dimension corresponding to primary time period, and third 
dimension corresponding to replicate. <code>coords</code> is a matrix of the observation coordinates used
to estimate the SVCs for each site. <code>coords</code> has two columns for the 
easting and northing coordinate, respectively. Typically, each site in the data 
set will have it's own coordinate, such that <code>coords</code> is a <code class="reqn">J \times 2</code> 
matrix and <code>grid.index</code> should not be specified. 
If you desire to estimate SVCs at some larger spatial level, 
e.g., if points fall within grid cells and you want to estimate an SVC for 
each grid cell instead of each point, <code>coords</code> can be specified as the coordinate for 
each grid cell. In such a case, <code>grid.index</code> is an indexing vector of length J, where each 
value of <code>grid.index</code> indicates the corresponding row in <code>coords</code> that the given 
site corresponds to. Note that <code>spOccupancy</code> assumes coordinates are specified 
in a projected coordinate system.
<code>range.ind</code> is a matrix with rows corresponding to species and columns
corresponding to sites, with each element taking value 1 if that site is 
within the range of the corresponding species and 0 if it is outside of the 
range. This matrix is not required, but it can be helpful to restrict the 
modeled area for each individual species to be within the realistic range
of locations for that species when estimating the model parameters. This is
applicable when auxiliary data sources are available on the realistic range
of the species.</p>
</td></tr>
<tr><td><code id="svcTMsPGOcc_+3A_inits">inits</code></td>
<td>
<p>a list with each tag corresponding to a parameter name.
Valid tags are <code>alpha.comm</code>, <code>beta.comm</code>, <code>beta</code>, 
<code>alpha</code>, <code>tau.sq.beta</code>, <code>tau.sq.alpha</code>, 
<code>sigma.sq.psi</code>, <code>sigma.sq.p</code>, <code>z</code>, 
<code>phi</code>, <code>lambda</code>, <code>nu</code>, <code>sigma.sq.t</code>, and <code>rho</code>. 
<code>nu</code> is only specified if <code>cov.model = "matern"</code>, 
<code>sigma.sq.t</code> and <code>rho</code> are only specified if <code>ar1 = TRUE</code>, 
and <code>sigma.sq.psi</code> and <code>sigma.sq.p</code> are
only specified if random effects are included in <code>occ.formula</code> or 
<code>det.formula</code>, respectively. The value portion of each tag is 
the parameter's initial value. See <code>priors</code> description for definition
of each parameter name. Additionally, the tag <code>fix</code> can be set to <code>TRUE</code> 
to fix the starting values across all chains. If <code>fix</code> is not specified
(the default), starting values are varied randomly across chains.</p>
</td></tr>
<tr><td><code id="svcTMsPGOcc_+3A_priors">priors</code></td>
<td>
<p>a list with each tag corresponding to a parameter name. 
Valid tags are <code>beta.comm.normal</code>, <code>alpha.comm.normal</code>, 
<code>tau.sq.beta.ig</code>, <code>tau.sq.alpha.ig</code>, <code>sigma.sq.psi</code>, 
<code>sigma.sq.p</code>, <code>phi.unif</code>, <code>nu.unif</code>, <code>sigma.sq.t.ig</code>, 
and <code>rho.unif</code>. Community-level occurrence (<code>beta.comm</code>) and detection 
(<code>alpha.comm</code>) regression coefficients are assumed to follow a 
normal distribution. The hyperparameters of the normal distribution
are passed as a list of length two with the first and second elements 
corresponding to the mean and variance of the normal distribution, 
which are each specified as vectors of length equal to the number of 
coefficients to be estimated or of length one if priors are the same for 
all coefficients. If not specified, prior means are set 
to 0 and prior variances set to 2.73. By default, community-level variance parameters 
for occupancy (<code>tau.sq.beta</code>) and detection (<code>tau.sq.alpha</code>) are 
assumed to follow an inverse Gamma distribution. The hyperparameters of 
the inverse gamma distribution are passed as a list of length two with 
the first and second elements corresponding to the shape and scale parameters,
which are each specified as vectors of length equal to the number of 
coefficients to be estimated or a single value if priors are the same for all 
parameters. If not specified, prior shape and scale 
parameters are set to 0.1. 
If desired, the species-specific occupancy coefficients
(<code>beta</code>) and/or detection coefficients (<code>alpha</code>) can also be estimated indepdendently by specifying the 
tag <code>independent.betas = TRUE</code> and/or <code>independent.alphas = TRUE</code>, respectively. 
If specified, this will not estimate species-specific
coefficients as random effects from a common-community-level distribution, and rather
the values of <code>beta.comm</code>/<code>alpha.comm</code> and <code>tau.sq.beta</code>/<code>tau.sq.alpha</code> will be fixed at the 
specified initial values. This is equivalent to specifying a Gaussian, independent
prior for each of the species-specific effects.
The spatial factor model fits <code>n.factors</code> independent
spatial processes for each spatially-varying coefficient specified in <code>svc.cols</code>. 
The spatial decay <code>phi</code> and smoothness <code>nu</code> parameters 
for each latent factor are assumed to follow Uniform distributions. 
The hyperparameters of the Uniform are passed as a list with two elements, 
with both elements being vectors of length <code>n.factors * length(svc.cols)</code> 
corresponding to the lower and 
upper support, respectively, or as a single value if the same value is assigned
for all factor/SVC combinations. The priors for the factor loadings 
matrix <code>lambda</code> for each SVC are fixed
following the standard spatial factor model to ensure parameter 
identifiability (Christensen and Amemlya 2002). The
upper triangular elements of the <code>N x n.factors</code> matrix are fixed at 0 and the 
diagonal elements are fixed at 1 for each SVC. The lower triangular elements are assigned a 
standard normal prior (i.e., mean 0 and variance 1).
<code>sigma.sq.psi</code> and <code>sigma.sq.p</code> are the random 
effect variances for any occurrence or
detection random effects, respectively, and are assumed to follow an inverse
Gamma distribution. The hyperparameters of the inverse-Gamma distribution
are passed as a list of length two with first and second elements corresponding
to the shape and scale parameters, respectively, which are each specified as
vectors of length equal to the number of random intercepts or of length one 
if priors are the same for all random effect variances. <code>sigma.sq.t</code> and 
<code>rho</code> are the AR(1) variance and correlation parameters for the AR(1) zero-mean
temporal random effects, respectively. <code>sigma.sq.t</code> is assumed to follow an inverse-Gamma
distribution, where the hyperparameters are specified as a list of length two with the 
first and second elements corresponding to the shape and scale parameters, respectively, 
which can each be specified as vector equal to the number of species in the model or a single value
if the same prior is used for all species. <code>rho</code> is assumed to follow a 
uniform distribution, where the hyperparameters are specified similarly as a list of length two
with the first and second elements corresponding to the lower and upper bounds of the 
uniform prior, which can each be specified as vector equal to the number of species in the 
model or a single value if the same prior is used for all species.</p>
</td></tr>
<tr><td><code id="svcTMsPGOcc_+3A_tuning">tuning</code></td>
<td>
<p>a list with each tag corresponding to a parameter
name. Valid tags are <code>phi</code>, <code>nu</code>, and <code>rho</code>. The value portion of each
tag defines the initial variance of the adaptive sampler. We assume the 
initial variance of the adaptive sampler is the same for each species, 
although the adaptive sampler will adjust the tuning variances separately
for each species. See Roberts and Rosenthal (2009) for details.</p>
</td></tr>
<tr><td><code id="svcTMsPGOcc_+3A_svc.cols">svc.cols</code></td>
<td>
<p>a vector indicating the variables whose effects will be 
estimated as spatially-varying coefficients. <code>svc.cols</code> can be an 
integer vector with values indicating the order of covariates specified 
in the model formula (with 1 being the intercept if specified), or it can 
be specified as a character vector with names corresponding to variable 
names in <code>occ.covs</code> (for the intercept, use '(Intercept)'). <code>svc.cols</code>
default argument of 1 results in a spatial occupancy model analogous to 
<code>sfMsPGOcc</code> (assuming an intercept is included in the model).</p>
</td></tr> 
<tr><td><code id="svcTMsPGOcc_+3A_cov.model">cov.model</code></td>
<td>
<p>a quoted keyword that specifies the covariance
function used to model the spatial dependence structure among the
observations.  Supported covariance model key words are:
<code>"exponential"</code>, <code>"matern"</code>, <code>"spherical"</code>, and
<code>"gaussian"</code>.</p>
</td></tr>
<tr><td><code id="svcTMsPGOcc_+3A_nngp">NNGP</code></td>
<td>
<p>if <code>TRUE</code>, model is fit with an NNGP. If <code>FALSE</code>, 
a full Gaussian process is used. See Datta et al. (2016) and 
Finley et al. (2019) for more information. Only 
<code>NNGP = TRUE</code> is currently supported.</p>
</td></tr>
<tr><td><code id="svcTMsPGOcc_+3A_n.neighbors">n.neighbors</code></td>
<td>
<p>number of neighbors used in the NNGP. Only used if 
<code>NNGP = TRUE</code>. Datta et al. (2016) showed that 15 neighbors is usually 
sufficient, but that as few as 5 neighbors can be adequate for certain data
sets, which can lead to even greater decreases in run time. We recommend
starting with 15 neighbors (the default) and if additional gains in computation
time are desired, subsequently compare the results with a smaller number
of neighbors using WAIC.</p>
</td></tr>
<tr><td><code id="svcTMsPGOcc_+3A_search.type">search.type</code></td>
<td>
<p>a quoted keyword that specifies the type of nearest
neighbor search algorithm. Supported method key words are: <code>"cb"</code> and
<code>"brute"</code>. The <code>"cb"</code> should generally be much
faster. If locations do not have identical coordinate values on
the axis used for the nearest neighbor ordering then <code>"cb"</code> 
and <code>"brute"</code> should produce identical neighbor sets. 
However, if there are identical coordinate values on the axis used 
for nearest neighbor ordering, then <code>"cb"</code> and <code>"brute"</code> 
might produce different, but equally valid, neighbor sets, 
e.g., if data are on a grid. </p>
</td></tr>
<tr><td><code id="svcTMsPGOcc_+3A_std.by.sp">std.by.sp</code></td>
<td>
<p>a logical value indicating whether the covariates are standardized
separately for each species within the corresponding range for each species (<code>TRUE</code>) 
or not (<code>FALSE</code>). Note that if <code>range.ind</code> is specified in <code>data.list</code>, 
this will result in the covariates being standardized differently for each species
based on the sites where <code>range.ind == 1</code> for that given species. If <code>range.ind</code> is not specified 
and <code>std.by.sp = TRUE</code>, this will simply be equivalent to standardizing 
the covariates across all locations prior to fitting the model. Note that the covariates
in <code>occ.formula</code> should still be standardized across all locations. This can be done
either outside the function, or can be done by specifying <code>scale()</code> in the model formula 
around the continuous covariates.</p>
</td></tr>
<tr><td><code id="svcTMsPGOcc_+3A_n.factors">n.factors</code></td>
<td>
<p>the number of factors to use in the spatial factor model approach. 
Note this corresponds to the number of factors used for each spatially-varying
coefficient that is estimated in the model.
Typically, the number of factors is set to be small (e.g., 4-5) relative to the 
total number of species in the community, which will lead to substantial 
decreases in computation time. However, the value can be anywhere 
between 1 and N (the number of species in the community).</p>
</td></tr>
<tr><td><code id="svcTMsPGOcc_+3A_svc.by.sp">svc.by.sp</code></td>
<td>
<p>an optional list with length equal to <code>length(svc.cols)</code>. Each element
of the list should be a logical vector of length <code>N</code> (number of species) where each 
element is TRUE, which indicates the SVC should be estimated for that species, or 0, which
indicates the SVC should be set to 0 and no SVC for that parameter will be estimated. Note
the first <code>n.factors</code> SVCs for all spatially-varying coefficients must be set to 
<code>TRUE</code>. By default, SVCs are modeled for all species.</p>
</td></tr>
<tr><td><code id="svcTMsPGOcc_+3A_n.batch">n.batch</code></td>
<td>
<p>the number of MCMC batches  in each chain to run for the Adaptive MCMC 
sampler. See Roberts and Rosenthal (2009) for details.</p>
</td></tr>
<tr><td><code id="svcTMsPGOcc_+3A_batch.length">batch.length</code></td>
<td>
<p>the length of each MCMC batch to run for the Adaptive 
MCMC sampler. See Roberts and Rosenthal (2009) for details.</p>
</td></tr>
<tr><td><code id="svcTMsPGOcc_+3A_accept.rate">accept.rate</code></td>
<td>
<p>target acceptance rate for Adaptive MCMC. Defaul is 
0.43. See Roberts and Rosenthal (2009) for details.</p>
</td></tr>
<tr><td><code id="svcTMsPGOcc_+3A_n.omp.threads">n.omp.threads</code></td>
<td>
<p>a positive integer indicating
the number of threads to use for SMP parallel processing. The package must
be compiled for OpenMP support. For most Intel-based machines, we
recommend setting <code>n.omp.threads</code> up to the number of
hyperthreaded cores. Note, <code>n.omp.threads</code> &gt; 1 might not
work on some systems.</p>
</td></tr>
<tr><td><code id="svcTMsPGOcc_+3A_verbose">verbose</code></td>
<td>
<p>if <code>TRUE</code>, messages about data preparation, 
model specification, and progress of the sampler are printed to the screen. 
Otherwise, no messages are printed.</p>
</td></tr>
<tr><td><code id="svcTMsPGOcc_+3A_ar1">ar1</code></td>
<td>
<p>logical value indicating whether to include an AR(1) zero-mean
temporal random effect in the model. If <code>FALSE</code>, the model is
fit without an AR(1) temporal autocovariance structure. If <code>TRUE</code>,
an AR(1) random effect is included in the model to account for temporal
autocorrelation across the primary time periods.</p>
</td></tr>
<tr><td><code id="svcTMsPGOcc_+3A_n.report">n.report</code></td>
<td>
<p>the interval to report Metropolis sampler acceptance and
MCMC progress. Note this is specified in terms of batches and not overall
samples for spatial models.</p>
</td></tr>
<tr><td><code id="svcTMsPGOcc_+3A_n.burn">n.burn</code></td>
<td>
<p>the number of samples out of the total <code>n.samples</code> to 
discard as burn-in for each chain. By default, the first 10% of samples is discarded.</p>
</td></tr>
<tr><td><code id="svcTMsPGOcc_+3A_n.thin">n.thin</code></td>
<td>
<p>the thinning interval for collection of MCMC samples. The
thinning occurs after the <code>n.burn</code> samples are discarded. Default 
value is set to 1.</p>
</td></tr>
<tr><td><code id="svcTMsPGOcc_+3A_n.chains">n.chains</code></td>
<td>
<p>the number of chains to run in sequence.</p>
</td></tr>
<tr><td><code id="svcTMsPGOcc_+3A_...">...</code></td>
<td>
<p>currently no additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>svcTMsPGOcc</code> that is a list comprised of: 
</p>
<table>
<tr><td><code>beta.comm.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the community level occurrence regression coefficients.</p>
</td></tr>
<tr><td><code>alpha.comm.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the community level detection regression coefficients.</p>
</td></tr>
<tr><td><code>tau.sq.beta.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the occurrence community variance parameters.</p>
</td></tr>
<tr><td><code>tau.sq.alpha.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the detection community variance parameters.</p>
</td></tr>
<tr><td><code>beta.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the species level occurrence regression coefficients.</p>
</td></tr>
<tr><td><code>alpha.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the species level detection regression coefficients.</p>
</td></tr>
<tr><td><code>theta.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the species level correlation parameters for each spatially-varying coefficient and
the temporal autocorrelation parameters for each species when <code>ar1 = TRUE</code>.</p>
</td></tr>
<tr><td><code>lambda.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the latent spatial factor loadings for each spatially-varying coefficient.</p>
</td></tr>
<tr><td><code>z.samples</code></td>
<td>
<p>a four-dimensional array of posterior samples for
the latent occurrence values for each species. Dimensions corresopnd to 
MCMC sample, species, site, and primary time period.</p>
</td></tr>
<tr><td><code>psi.samples</code></td>
<td>
<p>a four-dimensional array of posterior samples for
the latent occupancy probability values for each species. Dimensions correspond
to MCMC sample, species, site, and primary time period.</p>
</td></tr>
<tr><td><code>w.samples</code></td>
<td>
<p>a four-dimensional array of posterior samples for 
the latent spatial random effects for each spatial factor within each 
spatially-varying coefficient. Dimensions correspond to MCMC sample, 
factor, site, and spatially-varying coefficient.</p>
</td></tr>
<tr><td><code>sigma.sq.psi.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for variances of random intercepts included in the occurrence portion
of the model. Only included if random intercepts are specified in 
<code>occ.formula</code>.</p>
</td></tr>
<tr><td><code>sigma.sq.p.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for variances of random intercpets included in the detection portion 
of the model. Only included if random intercepts are specified in 
<code>det.formula</code>.</p>
</td></tr>
<tr><td><code>beta.star.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the occurrence random effects. Only included if random intercepts
are specified in <code>occ.formula</code>.</p>
</td></tr>
<tr><td><code>alpha.star.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the detection random effects. Only included if random intercepts 
are specified in <code>det.formula</code>.</p>
</td></tr>
<tr><td><code>like.samples</code></td>
<td>
<p>a four-dimensional array of posterior samples
for the likelihood value used for calculating WAIC. Dimensions correspond 
to MCMC sample, species, site, and time period.</p>
</td></tr>
<tr><td><code>rhat</code></td>
<td>
<p>a list of Gelman-Rubin diagnostic values for some of the model
parameters.</p>
</td></tr>
<tr><td><code>ESS</code></td>
<td>
<p>a list of effective sample sizes for some of the model parameters.</p>
</td></tr>
<tr><td><code>run.time</code></td>
<td>
<p>MCMC sampler execution time reported using <code>proc.time()</code>.</p>
</td></tr>
</table>
<p>The return object will include additional objects used for 
subsequent prediction and/or model fit evaluation. Note that detection 
probability estimated values are not included in the model object, but can
be extracted using <code>fitted()</code>.
</p>


<h3>Note</h3>

<p>Some of the underlying code used for generating random numbers from the
Polya-Gamma distribution is taken from the <span class="pkg">pgdraw</span> package written
by Daniel F. Schmidt and Enes Makalic. Their code implements Algorithm
6 in PhD thesis of Jesse Bennett Windle (2013) <a href="https://repositories.lib.utexas.edu/handle/2152/21842">https://repositories.lib.utexas.edu/handle/2152/21842</a>.
</p>


<h3>Author(s)</h3>

<p>Jeffrey W. Doser <a href="mailto:doserjef@msu.edu">doserjef@msu.edu</a>, <br />
Andrew O. Finley <a href="mailto:finleya@msu.edu">finleya@msu.edu</a>
</p>


<h3>References</h3>

<p>Datta, A., S. Banerjee, A.O. Finley, and A.E. Gelfand. (2016)
Hierarchical Nearest-Neighbor Gaussian process models for large
geostatistical datasets. <em>Journal of the American Statistical
Association</em>, <a href="https://doi.org/10.1080/01621459.2015.1044091">doi:10.1080/01621459.2015.1044091</a>.
</p>
<p>Finley, A.O., A. Datta, B.D. Cook, D.C. Morton, H.E. Andersen, and
S. Banerjee. (2019) Efficient algorithms for Bayesian Nearest Neighbor
Gaussian Processes. <em>Journal of Computational and Graphical
Statistics</em>, <a href="https://doi.org/10.1080/10618600.2018.1537924">doi:10.1080/10618600.2018.1537924</a>.
</p>
<p>Finley, A. O., Datta, A., and Banerjee, S. (2020). spNNGP R package 
for nearest neighbor Gaussian process models. <em>arXiv</em> preprint arXiv:2001.09111.
</p>
<p>Polson, N.G., J.G. Scott, and J. Windle. (2013) Bayesian Inference for
Logistic Models Using Polya-Gamma Latent Variables.
<em>Journal of the American Statistical Association</em>, 108:1339-1349.
</p>
<p>Roberts, G.O. and Rosenthal J.S. (2009) Examples  of adaptive MCMC.
<em>Journal of Computational and Graphical Statistics</em>, 18(2):349-367.
</p>
<p>Bates, Douglas, Martin Maechler, Ben Bolker, Steve Walker (2015).
Fitting Linear Mixed-Effects Models Using lme4. Journal of
Statistical Software, 67(1), 1-48. <a href="https://doi.org/10.18637/jss.v067.i01">doi:10.18637/jss.v067.i01</a>.
</p>
<p>Hooten, M. B., and Hobbs, N. T. (2015). A guide to Bayesian model 
selection for ecologists. <em>Ecological Monographs</em>, 85(1), 3-28.
</p>
<p>Christensen, W. F., and Amemiya, Y. (2002). Latent variable analysis 
of multivariate spatial data. <em>Journal of the American Statistical Association</em>, 
97(457), 302-317.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simulate Data -----------------------------------------------------------
set.seed(500)
J.x &lt;- 8
J.y &lt;- 8
J &lt;- J.x * J.y
# Years sampled
n.time &lt;- sample(3:10, J, replace = TRUE)
# n.time &lt;- rep(10, J)
n.time.max &lt;- max(n.time)
# Replicates
n.rep &lt;- matrix(NA, J, max(n.time))
for (j in 1:J) {
  n.rep[j, 1:n.time[j]] &lt;- sample(2:4, n.time[j], replace = TRUE)
}
N &lt;- 7
# Community-level covariate effects
# Occurrence
beta.mean &lt;- c(-3, -0.2, 0.5)
trend &lt;- FALSE
sp.only &lt;- 0
p.occ &lt;- length(beta.mean)
tau.sq.beta &lt;- c(0.6, 1.5, 1.4)
# Detection
alpha.mean &lt;- c(0, 1.2, -1.5)
tau.sq.alpha &lt;- c(1, 0.5, 2.3)
p.det &lt;- length(alpha.mean)
# Random effects
psi.RE &lt;- list()
p.RE &lt;- list()
# Draw species-level effects from community means.
beta &lt;- matrix(NA, nrow = N, ncol = p.occ)
alpha &lt;- matrix(NA, nrow = N, ncol = p.det)
for (i in 1:p.occ) {
  beta[, i] &lt;- rnorm(N, beta.mean[i], sqrt(tau.sq.beta[i]))
}
for (i in 1:p.det) {
  alpha[, i] &lt;- rnorm(N, alpha.mean[i], sqrt(tau.sq.alpha[i]))
}
sp &lt;- TRUE
svc.cols &lt;- c(1, 2)
p.svc &lt;- length(svc.cols)
n.factors &lt;- 3
phi &lt;- runif(p.svc * n.factors, 3 / .9, 3 / .3)
factor.model &lt;- TRUE
cov.model &lt;- 'exponential'

dat &lt;- simTMsOcc(J.x = J.x, J.y = J.y, n.time = n.time, n.rep = n.rep, N = N,
                 beta = beta, alpha = alpha, sp.only = sp.only, trend = trend,
                 psi.RE = psi.RE, p.RE = p.RE, factor.model = factor.model,
                 svc.cols = svc.cols, n.factors = n.factors, phi = phi, sp = sp,
                 cov.model = cov.model)

y &lt;- dat$y
X &lt;- dat$X
X.p &lt;- dat$X.p
coords &lt;- dat$coords
X.re &lt;- dat$X.re
X.p.re &lt;- dat$X.p.re

occ.covs &lt;- list(occ.cov.1 = X[, , 2],
                 occ.cov.2 = X[, , 3])
det.covs &lt;- list(det.cov.1 = X.p[, , , 2],
                 det.cov.2 = X.p[, , , 3])

data.list &lt;- list(y = y, occ.covs = occ.covs,
                  det.covs = det.covs,
                  coords = coords)
# Priors
prior.list &lt;- list(beta.comm.normal = list(mean = 0, var = 2.72),
                   alpha.comm.normal = list(mean = 0, var = 2.72),
                   tau.sq.beta.ig = list(a = 0.1, b = 0.1),
                   tau.sq.alpha.ig = list(a = 0.1, b = 0.1),
                   phi.unif = list(a = 3 / .9, b = 3 / .1))
z.init &lt;- apply(y, c(1, 2, 3), function(a) as.numeric(sum(a, na.rm = TRUE) &gt; 0))
inits.list &lt;- list(alpha.comm = 0, beta.comm = 0, beta = 0,
                   alpha = 0, tau.sq.beta = 1, tau.sq.alpha = 1,
                   phi = 3 / .5, z = z.init)
# Tuning
tuning.list &lt;- list(phi = 1)

# Number of batches
n.batch &lt;- 5
# Batch length
batch.length &lt;- 25
n.burn &lt;- 25
n.thin &lt;- 1
n.samples &lt;- n.batch * batch.length

out &lt;- svcTMsPGOcc(occ.formula = ~ occ.cov.1 + occ.cov.2,
                   det.formula = ~ det.cov.1 + det.cov.2,
                   data = data.list,
                   inits = inits.list,
                   n.batch = n.batch,
                   batch.length = batch.length,
                   accept.rate = 0.43,
                   NNGP = TRUE,
                   n.neighbors = 5,
                   n.factors = n.factors,
                   svc.cols = svc.cols,
                   cov.model = 'exponential',
                   priors = prior.list,
                   tuning = tuning.list,
                   n.omp.threads = 1,
                   verbose = TRUE,
                   n.report = 1,
                   n.burn = n.burn,
                   n.thin = n.thin,
                   n.chains = 1)

summary(out)
</code></pre>

<hr>
<h2 id='svcTPGBinom'>Function for Fitting Multi-Season Single-Species Spatially-Varying Coefficient Binomial Models Using Polya-Gamma Latent Variables</h2><span id='topic+svcTPGBinom'></span>

<h3>Description</h3>

<p>The function <code>svcTPGBinom</code> fits multi-season single-species spatially-varying coefficient binomial models using Polya-Gamma latent variables. Models are fit using Nearest Neighbor Gaussian Processes. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>svcTPGBinom(formula, data, inits, priors, 
            tuning, svc.cols = 1, cov.model = 'exponential', NNGP = TRUE, 
            n.neighbors = 15, search.type = 'cb', n.batch, 
            batch.length, accept.rate = 0.43, n.omp.threads = 1, 
            verbose = TRUE, ar1 = FALSE, n.report = 100, 
            n.burn = round(.10 * n.batch * batch.length), 
            n.thin = 1, n.chains = 1, k.fold, k.fold.threads = 1, 
            k.fold.seed = 100, k.fold.only = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="svcTPGBinom_+3A_formula">formula</code></td>
<td>
<p>a symbolic description of the model to be fit using R's model syntax. Only
right-hand side of formula is specified. See example below. Random intercepts
are allowed using lme4 syntax (Bates et al. 2015).</p>
</td></tr>
<tr><td><code id="svcTPGBinom_+3A_data">data</code></td>
<td>
<p>a list containing data necessary for model fitting.
Valid tags are <code>y</code>, <code>covs</code>, <code>weights</code>, and <code>coords</code>. <code>y</code>
is a two-dimensional array with the rows corresponding to the number of
sites (<code class="reqn">J</code>) and columns corresponding to the maximum number of
primary time periods (i.e., years or seasons). <code>covs</code> is a
list of variables included in the occurrence portion of the model. Each
list element is a different occurrence covariate, which can be site level
or site/primary time period level. Site-level covariates are specified as a vector of
length <code class="reqn">J</code> while site/primary time period level covariates are specified as a matrix
with rows corresponding to sites and columns correspond to primary time periods.
<code>weights</code> is a site by time period matrix containing the binomial weights 
(i.e., the total number of Bernoulli trials) at each site/time period combination. Note
that missing values are allowed and should be specified as NA. 
<code>coords</code> is a <code class="reqn">J \times 2</code>
matrix of the observation coordinates. Note that <code>spOccupancy</code> assumes
coordinates are specified in a projected coordinate system.</p>
</td></tr>
<tr><td><code id="svcTPGBinom_+3A_inits">inits</code></td>
<td>
<p>a list with each tag corresponding to a parameter name.
Valid tags are <code>beta</code>, <code>sigma.sq</code>, 
<code>phi</code>, <code>w</code>, <code>nu</code>, <code>sigma.sq.psi</code>, <code>sigma.sq.t</code>, and <code>rho</code>.  
<code>nu</code> is only specified if <code>cov.model = "matern"</code>, and <code>sigma.sq.psi</code>
is only specified if there are random effects in <code>formula</code>. 
<code>sigma.sq.t</code> and <code>rho</code> are only relevant when <code>ar1 = TRUE</code>.
The value portion of each tag is the parameter's initial value. See <code>priors</code>
description for definition of each parameter name.
Additionally, the tag <code>fix</code> can be set to <code>TRUE</code> 
to fix the starting values across all chains. If <code>fix</code> is not specified
(the default), starting values are varied randomly across chains.</p>
</td></tr>
<tr><td><code id="svcTPGBinom_+3A_priors">priors</code></td>
<td>
<p>a list with each tag corresponding to a parameter name. 
Valid tags are <code>beta.normal</code>, <code>phi.unif</code>, 
<code>sigma.sq.ig</code>, <code>sigma.sq.unif</code>, <code>nu.unif</code>,
<code>sigma.sq.psi.ig</code>, <code>sigma.sq.t.ig</code>, and <code>rho.unif</code>. 
Regression coefficients (<code>beta</code>)
are assumed to follow a normal distribution. The hyperparameters of the 
normal distribution are passed as a list of length two with the first
and second elements corresponding to the mean and variance of the normal
distribution, which are each specified as vectors of 
length equal to the number of coefficients to be estimated or of length
one if priors are the same for all coefficients. If not
specified, prior means are set to 0 and prior variances set to 2.73. The 
spatial variance parameter, <code>sigma.sq</code>, for each spatially-varying 
coefficient is assumed to follow an 
inverse-Gamma distribution or a uniform distribution (default is 
inverse-Gamma). The spatial decay <code>phi</code> and 
smoothness <code>nu</code> parameters are assumed to follow Uniform 
distributions. The hyperparameters of the inverse-Gamma for <code>sigma.sq</code>
are passed as a list with two elements corresponding to the 
shape and scale parametters, respetively, with each element comprised of 
a vector equal to the number of spatially-varying coefficients to be estimated
or of length one if priors are the same for all coefficients.
The hyperparameters of any uniform priors are also passed as a list of 
length two with the first and second elements corresponding to 
the lower and upper support, respectively, which can be passed as
a vector equal to the total number of spatially-varying coefficients to 
be estimated or of length one if priors are the same for all coefficients.
<code>sigma.sq.psi</code> are the random effect variances for any random effects, 
respectively, and are assumed to follow an 
inverse-Gamma distribution. The hyperparameters of
the inverse-Gamma distribution are passed as a list of length two with the 
first and second elements corresponding to the shape and scale parameters, 
respectively, which are each specified as vectors of length equal to the 
number of random intercepts or of length one if priors are the same for all
random effect variances. <code>sigma.sq.t</code> and 
<code>rho</code> are the AR(1) variance and correlation parameters for the AR(1) zero-mean
temporal random effects, respectively. 
<code>sigma.sq.t</code> is assumed to follow an inverse-Gamma
distribution, where the hyperparameters are specified as a vector with elements
corresponding to the shape and scale parameters, respectively. <code>rho</code> is 
assumed to follow a uniform distribution, where the hyperparameters are specified in 
a vector of length two with elements corresponding to the lower and upper bounds of
the uniform prior.</p>
</td></tr>
<tr><td><code id="svcTPGBinom_+3A_svc.cols">svc.cols</code></td>
<td>
<p>a vector indicating the variables whose effects will be 
estimated as spatially-varying coefficients. <code>svc.cols</code> can be an 
integer vector with values indicating the order of covariates specified 
in the model formula (with 1 being the intercept if specified), or it can 
be specified as a character vector with names corresponding to variable 
names in <code>covs</code> (for the intercept, use '(Intercept)').</p>
</td></tr> 
<tr><td><code id="svcTPGBinom_+3A_cov.model">cov.model</code></td>
<td>
<p>a quoted keyword that specifies the covariance
function used to model the spatial dependence structure among the
observations.  Supported covariance model key words are:
<code>"exponential"</code>, <code>"matern"</code>, <code>"spherical"</code>, and
<code>"gaussian"</code>.</p>
</td></tr>
<tr><td><code id="svcTPGBinom_+3A_tuning">tuning</code></td>
<td>
<p>a list with each tag corresponding to a parameter
name. Valid tags are <code>phi</code>, <code>sigma.sq</code>, <code>nu</code>, and <code>rho</code>. 
The value portion of each tag defines the initial variance of the Adaptive sampler. See
Roberts and Rosenthal (2009) for details.</p>
</td></tr>
<tr><td><code id="svcTPGBinom_+3A_nngp">NNGP</code></td>
<td>
<p>if <code>TRUE</code>, model is fit with an NNGP. If <code>FALSE</code>, 
a full Gaussian process is used. See Datta et al. (2016) and 
Finley et al. (2019) for more information. Currently, only <code>NNGP = TRUE</code> is
supported for multi-season occupancy models.</p>
</td></tr>
<tr><td><code id="svcTPGBinom_+3A_n.neighbors">n.neighbors</code></td>
<td>
<p>number of neighbors used in the NNGP. Only used if 
<code>NNGP = TRUE</code>. Datta et al. (2016) showed that 15 neighbors is usually 
sufficient, but that as few as 5 neighbors can be adequate for certain data
sets, which can lead to even greater decreases in run time. We recommend
starting with 15 neighbors (the default) and if additional gains in computation
time are desired, subsequently compare the results with a smaller number
of neighbors using WAIC or k-fold cross-validation.</p>
</td></tr>
<tr><td><code id="svcTPGBinom_+3A_search.type">search.type</code></td>
<td>
<p>a quoted keyword that specifies the type of nearest
neighbor search algorithm. Supported method key words are: <code>"cb"</code> and
<code>"brute"</code>. The <code>"cb"</code> should generally be much
faster. If locations do not have identical coordinate values on
the axis used for the nearest neighbor ordering then <code>"cb"</code> 
and <code>"brute"</code> should produce identical neighbor sets. 
However, if there are identical coordinate values on the axis used 
for nearest neighbor ordering, then <code>"cb"</code> and <code>"brute"</code> 
might produce different, but equally valid, neighbor sets, 
e.g., if data are on a grid. </p>
</td></tr>
<tr><td><code id="svcTPGBinom_+3A_n.batch">n.batch</code></td>
<td>
<p>the number of MCMC batches in each chain to run for the Adaptive MCMC 
sampler. See Roberts and Rosenthal (2009) for details.</p>
</td></tr>
<tr><td><code id="svcTPGBinom_+3A_batch.length">batch.length</code></td>
<td>
<p>the length of each MCMC batch in each chain to run for the Adaptive 
MCMC sampler. See Roberts and Rosenthal (2009) for details.</p>
</td></tr>
<tr><td><code id="svcTPGBinom_+3A_accept.rate">accept.rate</code></td>
<td>
<p>target acceptance rate for Adaptive MCMC. Default is 
0.43. See Roberts and Rosenthal (2009) for details.</p>
</td></tr>
<tr><td><code id="svcTPGBinom_+3A_n.omp.threads">n.omp.threads</code></td>
<td>
<p>a positive integer indicating
the number of threads to use for SMP parallel processing. The package must
be compiled for OpenMP support. For most Intel-based machines, we
recommend setting <code>n.omp.threads</code> up to the number of
hyperthreaded cores. Note, <code>n.omp.threads</code> &gt; 1 might not
work on some systems.</p>
</td></tr>
<tr><td><code id="svcTPGBinom_+3A_verbose">verbose</code></td>
<td>
<p>if <code>TRUE</code>, messages about data preparation, 
model specification, and progress of the sampler are printed to the screen. 
Otherwise, no messages are printed.</p>
</td></tr>
<tr><td><code id="svcTPGBinom_+3A_ar1">ar1</code></td>
<td>
<p>logical value indicating whether to include an AR(1) zero-mean
temporal random effect in the model. If <code>FALSE</code>, the model is
fit without an AR(1) temporal autocovariance structure. If <code>TRUE</code>,
an AR(1) random effect is included in the model to account for temporal
autocorrelation across the primary time periods.</p>
</td></tr>
<tr><td><code id="svcTPGBinom_+3A_n.report">n.report</code></td>
<td>
<p>the interval to report Metropolis sampler acceptance and
MCMC progress.</p>
</td></tr>
<tr><td><code id="svcTPGBinom_+3A_n.burn">n.burn</code></td>
<td>
<p>the number of samples out of the total <code>n.batch * batch.length</code> 
samples in each chain to discard as burn-in. By default, the first 
10% of samples is discarded.</p>
</td></tr>
<tr><td><code id="svcTPGBinom_+3A_n.thin">n.thin</code></td>
<td>
<p>the thinning interval for collection of MCMC samples. The
thinning occurs after the <code>n.burn</code> samples are discarded. Default 
value is set to 1.</p>
</td></tr>
<tr><td><code id="svcTPGBinom_+3A_n.chains">n.chains</code></td>
<td>
<p>the number of MCMC chains to run in sequence.</p>
</td></tr>
<tr><td><code id="svcTPGBinom_+3A_k.fold">k.fold</code></td>
<td>
<p>specifies the number of <em>k</em> folds for cross-validation. 
If not specified as an argument, then cross-validation is not performed
and <code>k.fold.threads</code> and <code>k.fold.seed</code> are ignored. In <em>k</em>-fold
cross-validation, the data specified in <code>data</code> is randomly
partitioned into <em>k</em> equal sized subsamples. Of the <em>k</em> subsamples, 
<em>k</em> - 1 subsamples are used to fit the model and the remaining <em>k</em>
samples are used for prediction. The cross-validation process is repeated 
<em>k</em> times (the folds). As a scoring rule, we use the model deviance 
as described in Hooten and Hobbs (2015). For cross-validation in multi-season
models, the data are split along the site dimension, such that each hold-out
data set consists of a <code>J / k.fold</code> sites sampled over all primary time
periods during which data are available at each given site. Cross-validation is performed
after the full model is fit using all the data. Cross-validation results
are reported in the <code>k.fold.deviance</code> object in the return list.</p>
</td></tr>
<tr><td><code id="svcTPGBinom_+3A_k.fold.threads">k.fold.threads</code></td>
<td>
<p>number of threads to use for cross-validation. If 
<code>k.fold.threads &gt; 1</code> parallel processing is accomplished using the 
<span class="pkg">foreach</span> and <span class="pkg">doParallel</span> packages. Ignored if <code>k.fold</code>
is not specified.</p>
</td></tr> 
<tr><td><code id="svcTPGBinom_+3A_k.fold.seed">k.fold.seed</code></td>
<td>
<p>seed used to split data set into <code>k.fold</code> parts
for k-fold cross-validation. Ignored if <code>k.fold</code> is not specified.</p>
</td></tr>
<tr><td><code id="svcTPGBinom_+3A_k.fold.only">k.fold.only</code></td>
<td>
<p>a logical value indicating whether to only perform 
cross-validation (<code>TRUE</code>) or perform cross-validation after fitting 
the full model (<code>FALSE</code>). Default value is <code>FALSE</code>.</p>
</td></tr> 
<tr><td><code id="svcTPGBinom_+3A_...">...</code></td>
<td>
<p>currently no additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>svcTPGBinom</code> that is a list comprised of: 
</p>
<table>
<tr><td><code>beta.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the regression coefficients.</p>
</td></tr>
<tr><td><code>y.rep.samples</code></td>
<td>
<p>a three-dimensional array of posterior samples 
for the fitted data values, with dimensions corresponding to posterior
sample, site, and primary time period.</p>
</td></tr>
<tr><td><code>psi.samples</code></td>
<td>
<p>a three-dimensional array of posterior samples 
for the occurrence probability values, with dimensions corresponding to posterior
sample, site, and primary time period.</p>
</td></tr>
<tr><td><code>theta.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for spatial covariance parameters and temporal covariance parameters
if <code>ar1 = TRUE</code>.</p>
</td></tr>
<tr><td><code>w.samples</code></td>
<td>
<p>a three-dimensional array of posterior samples for the 
latent spatial random effects for all spatially-varying coefficients. 
Dimensions correspond to MCMC sample, coefficient, and sites.</p>
</td></tr>
<tr><td><code>sigma.sq.psi.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for variances of unstructured random intercepts included in the 
model. Only included if random intercepts are specified in 
<code>formula</code>.</p>
</td></tr>
<tr><td><code>beta.star.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the unstructured random effects. Only included if random intercepts
are specified in <code>formula</code>.</p>
</td></tr>
<tr><td><code>eta.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples for the 
AR(1) random effects for each primary time period. Only included if 
<code>ar1 = TRUE</code>.</p>
</td></tr>
<tr><td><code>like.samples</code></td>
<td>
<p>a three-dimensional array of posterior samples
for the likelihood values associated with each site and primary
time period. Used for calculating WAIC.</p>
</td></tr>
<tr><td><code>rhat</code></td>
<td>
<p>a list of Gelman-Rubin diagnostic values for some of the model
parameters.</p>
</td></tr>
<tr><td><code>ESS</code></td>
<td>
<p>a list of effective sample sizes for some of the model parameters.</p>
</td></tr>
<tr><td><code>run.time</code></td>
<td>
<p>execution time reported using <code>proc.time()</code>.</p>
</td></tr>
<tr><td><code>k.fold.deviance</code></td>
<td>
<p>soring rule (deviance) from k-fold cross-validation. 
Only included if <code>k.fold</code> is specified in function call.</p>
</td></tr>
</table>
<p>The return object will include additional objects used for 
subsequent prediction and/or model fit evaluation. 
Note that if <code>k.fold.only = TRUE</code>, the
return list object will only contain <code>run.time</code> and <code>k.fold.deviance</code>
</p>


<h3>Author(s)</h3>

<p>Jeffrey W. Doser <a href="mailto:doserjef@msu.edu">doserjef@msu.edu</a>, <br />
Andrew O. Finley <a href="mailto:finleya@msu.edu">finleya@msu.edu</a>
</p>


<h3>References</h3>

<p>Bates, Douglas, Martin Maechler, Ben Bolker, Steve Walker (2015).
Fitting Linear Mixed-Effects Models Using lme4. Journal of
Statistical Software, 67(1), 1-48. <a href="https://doi.org/10.18637/jss.v067.i01">doi:10.18637/jss.v067.i01</a>.
</p>
<p>Datta, A., S. Banerjee, A.O. Finley, and A.E. Gelfand. (2016)
Hierarchical Nearest-Neighbor Gaussian process models for large
geostatistical datasets. <em>Journal of the American Statistical
Association</em>, <a href="https://doi.org/10.1080/01621459.2015.1044091">doi:10.1080/01621459.2015.1044091</a>.
</p>
<p>Finley, A.O., A. Datta, B.D. Cook, D.C. Morton, H.E. Andersen, and
S. Banerjee. (2019) Efficient algorithms for Bayesian Nearest Neighbor
Gaussian Processes. <em>Journal of Computational and Graphical
Statistics</em>, <a href="https://doi.org/10.1080/10618600.2018.1537924">doi:10.1080/10618600.2018.1537924</a>.
</p>
<p>Finley, A. O., and  Banerjee, S. (2020). Bayesian spatially varying coefficient 
models in the spBayes R package. <em>Environmental Modelling and Software</em>, 
125, 104608.
</p>
<p>Polson, N.G., J.G. Scott, and J. Windle. (2013) Bayesian Inference for
Logistic Models Using Polya-Gamma Latent Variables. 
<em>Journal of the American Statistical Association</em>, 108:1339-1349.
</p>
<p>Roberts, G.O. and Rosenthal J.S. (2009) Examples  of adaptive MCMC. 
<em>Journal of Computational and Graphical Statistics</em>, 18(2):349-367.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1000)
# Sites
J.x &lt;- 15
J.y &lt;- 15 
J &lt;- J.x * J.y
# Years sampled
n.time &lt;- sample(10, J, replace = TRUE)
# Binomial weights
weights &lt;- matrix(NA, J, max(n.time))
for (j in 1:J) {
  weights[j, 1:n.time[j]] &lt;- sample(5, n.time[j], replace = TRUE)
}
# Occurrence --------------------------
beta &lt;- c(-2, -0.5, -0.2, 0.75)
p.occ &lt;- length(beta)
trend &lt;- TRUE
sp.only &lt;- 0
psi.RE &lt;- list()
# Spatial parameters ------------------
sp &lt;- TRUE
svc.cols &lt;- c(1, 2, 3)
p.svc &lt;- length(svc.cols)
cov.model &lt;- "exponential"
sigma.sq &lt;- runif(p.svc, 0.1, 1)
phi &lt;- runif(p.svc, 3/1, 3/0.2)
# Temporal parameters -----------------
ar1 &lt;- TRUE 
rho &lt;- 0.8
sigma.sq.t &lt;- 1

# Get all the data
dat &lt;- simTBinom(J.x = J.x, J.y = J.y, n.time = n.time, weights = weights, beta = beta, 
                 psi.RE = psi.RE, sp.only = sp.only, trend = trend, 
                 sp = sp, svc.cols = svc.cols, 
                 cov.model = cov.model, sigma.sq = sigma.sq, phi = phi,
                 rho = rho, sigma.sq.t = sigma.sq.t, ar1 = TRUE, x.positive = FALSE)

# Prep the data for spOccupancy -------------------------------------------
y &lt;- dat$y
X &lt;- dat$X
X.re &lt;- dat$X.re
coords &lt;- dat$coords

# Package all data into a list
covs &lt;- list(int = X[, , 1],
             trend = X[, , 2],
             cov.1 = X[, , 3], 
             cov.2 = X[, , 4])
# Data list bundle
data.list &lt;- list(y = y,
                  covs = covs,
                  weights = weights, 
                  coords = coords)
# Priors
prior.list &lt;- list(beta.normal = list(mean = 0, var = 2.72),
                   sigma.sq.ig = list(a = 2, b = 1),
                   phi.unif = list(a = 3/1, b = 3/.1), 
                   sigma.sq.t.ig = c(2, 0.5), 
                   rho.unif = c(-1, 1))

# Starting values
inits.list &lt;- list(beta = beta, alpha = 0,
                   sigma.sq = 1, phi = 3 / 0.5, 
                   sigma.sq.t = 0.5, rho = 0)
# Tuning
tuning.list &lt;- list(phi = 0.4, nu = 0.3, rho = 0.2)

# MCMC settings
n.batch &lt;- 2
n.burn &lt;- 0
n.thin &lt;- 1

out &lt;- svcTPGBinom(formula = ~ trend + cov.1 + cov.2, 
                   svc.cols = svc.cols,
                   data = data.list, 
                   n.batch = n.batch, 
                   batch.length = 25, 
                   inits = inits.list, 
                   priors = prior.list,
                   accept.rate = 0.43, 
                   cov.model = "exponential", 
                   ar1 = TRUE,
                   tuning = tuning.list, 
                   n.omp.threads = 1, 
                   verbose = TRUE, 
                   NNGP = TRUE, 
                   n.neighbors = 5,
                   n.report = 1, 
                   n.burn = n.burn, 
                   n.thin = n.thin, 
                   n.chains = 1) 
</code></pre>

<hr>
<h2 id='svcTPGOcc'>Function for Fitting Multi-Season Single-Species Spatially-Varying Coefficient Occupancy Models Using Polya-Gamma Latent Variables</h2><span id='topic+svcTPGOcc'></span>

<h3>Description</h3>

<p>Function for fitting multi-season single-species spatially-varying coefficient occupancy models using Polya-Gamma latent variables. Models are fit using Nearest Neighbor Gaussian Processes. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>svcTPGOcc(occ.formula, det.formula, data, inits, priors, 
          tuning, svc.cols = 1, cov.model = 'exponential', NNGP = TRUE, 
          n.neighbors = 15, search.type = 'cb', n.batch, 
          batch.length, accept.rate = 0.43, n.omp.threads = 1, 
          verbose = TRUE, ar1 = FALSE, n.report = 100, 
          n.burn = round(.10 * n.batch * batch.length), 
          n.thin = 1, n.chains = 1, k.fold, k.fold.threads = 1, 
          k.fold.seed = 100, k.fold.only = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="svcTPGOcc_+3A_occ.formula">occ.formula</code></td>
<td>
<p>a symbolic description of the model to be fit
for the occurrence portion of the model using R's model syntax. Only
right-hand side of formula is specified. See example below. Random intercepts
are allowed using lme4 syntax (Bates et al. 2015).</p>
</td></tr>
<tr><td><code id="svcTPGOcc_+3A_det.formula">det.formula</code></td>
<td>
<p>a symbolic description of the model to be fit
for the detection portion of the model using R's model syntax. Only
right-hand side of formula is specified. See example below. Random intercepts
are allowed using lme4 syntax (Bates et al. 2015).</p>
</td></tr>
<tr><td><code id="svcTPGOcc_+3A_data">data</code></td>
<td>
<p>a list containing data necessary for model fitting.
Valid tags are <code>y</code>, <code>occ.covs</code>, <code>det.covs</code>, <code>coords</code>, and <code>grid.index</code>. <code>y</code>
is a three-dimensional array with first dimension equal to the number of 
sites (<code class="reqn">J</code>), second dimension equal to the maximum number of 
primary time periods (i.e., years or seasons), and third dimension equal 
to the maximum number of replicates at a given site. <code>occ.covs</code> is a
list of variables included in the occurrence portion of the model. Each
list element is a different occurrence covariate, which can be site level
or site/primary time period level. Site-level covariates are specified as a vector of 
length <code class="reqn">J</code> while site/primary time period level covariates are specified as a matrix
with rows corresponding to sites and columns correspond to primary time periods.
Similarly, <code>det.covs</code> is a list of variables included in the detection
portion of the model, with each list element corresponding to an 
individual variable. In addition to site-level and/or site/primary time period-level, 
detection covariates can also be observational-level. Observation-level covariates
are specified as a three-dimensional array with first dimension corresponding to 
sites, second dimension corresponding to primary time period, and third 
dimension corresponding to replicate. 
<code>coords</code> is a matrix of the observation coordinates used
to estimate the SVCs for each site. <code>coords</code> has two columns for the 
easting and northing coordinate, respectively. Typically, each site in the data 
set will have it's own coordinate, such that <code>coords</code> is a <code class="reqn">J \times 2</code> 
matrix and <code>grid.index</code> should not be specified. 
If you desire to estimate SVCs at some larger spatial level, 
e.g., if points fall within grid cells and you want to estimate an SVC for 
each grid cell instead of each point, <code>coords</code> can be specified as the coordinate for 
each grid cell. In such a case, <code>grid.index</code> is an indexing vector of length J, where each 
value of <code>grid.index</code> indicates the corresponding row in <code>coords</code> that the given 
site corresponds to. Note that <code>spOccupancy</code> assumes coordinates are specified 
in a projected coordinate system.</p>
</td></tr>
<tr><td><code id="svcTPGOcc_+3A_inits">inits</code></td>
<td>
<p>a list with each tag corresponding to a parameter name.
Valid tags are <code>z</code>, <code>beta</code>, <code>alpha</code>, <code>sigma.sq</code>, <code>phi</code>, 
<code>w</code>, <code>nu</code>, <code>sigma.sq.psi</code>, <code>sigma.sq.p</code>, <code>sigma.sq.t</code>, 
<code>rho</code>. The value portion of each tag is the 
parameter's initial value. <code>sigma.sq.psi</code> and <code>sigma.sq.p</code> are 
only relevant when including random effects in the occurrence and 
detection portion of the occupancy model, respectively. <code>nu</code> is only
specified if <code>cov.model = "matern"</code>. <code>sigma.sq.t</code> and <code>rho</code> 
are only relevant when <code>ar1 = TRUE</code>. See <code>priors</code> 
description for definition of each parameter name.
Additionally, the tag <code>fix</code> can be set to <code>TRUE</code> 
to fix the starting values across all chains. If <code>fix</code> is not specified
(the default), starting values are varied randomly across chains.</p>
</td></tr>
<tr><td><code id="svcTPGOcc_+3A_priors">priors</code></td>
<td>
<p>a list with each tag corresponding to a parameter name. 
Valid tags are <code>beta.normal</code>, <code>alpha.normal</code>, <code>sigma.sq.psi.ig</code>, 
<code>sigma.sq.p.ig</code>, <code>phi.unif</code>, <code>sigma.sq.ig</code>, <code>nu.unif</code>, 
<code>sigma.sq.t.ig</code>, and <code>rho.unif</code>. 
Occupancy (<code>beta</code>) and detection (<code>alpha</code>) 
regression coefficients are assumed to follow a normal distribution. 
The hyperparameters of the normal distribution are passed as a list of 
length two with the first and second elements corresponding to the mean 
and variance of the normal distribution, which are each specified as vectors of 
length equal to the number of coefficients to be estimated or of length one
if priors are the same for all coefficients. If not specified, prior means 
are set to 0 and prior variances set to 2.72. <code>sigma.sq.psi</code> and 
<code>sigma.sq.p</code> are the random effect variances for any occurrence or 
detection random effects, respectively, and are assumed to follow an inverse
Gamma distribution. The hyperparameters of the inverse-Gamma distribution
are passed as a list of length two with first and second elements corresponding
to the shape and scale parameters, respectively, which are each specified as
vectors of length equal to the number of random intercepts or of length one 
if priors are the same for all random effect variances. The spatial variance
parameter, <code>sigma.sq</code>, is assumed to follow an inverse-Gamma distribution. 
The spatial decay <code>phi</code> and smoothness <code>nu</code> parameters are assumed 
to follow Uniform distributions. The hyperparameters of the inverse-Gamma for 
<code>sigma.sq.ig</code> are passed as a list of length two, with the first and second
elements corresponding to the shape and scale parameters, respectively, with each 
element comprised of a vector equal to the number of spatially-varying coefficients to 
be estimated or of length one if priors are the same for all coefficients. The 
hyperparameters of the uniform are also passed as a list of length two
with the first and second elements corresponding to the lower and upper support, 
respectively, which can be passed as a vector equal to the number of spatially-varying coefficients
to be estimated or of length one if priors are the same for all coefficients. <code>sigma.sq.t</code> and 
<code>rho</code> are the AR(1) variance and correlation parameters for the AR(1) zero-mean
temporal random effects, respectively. <code>sigma.sq.t</code> is assumed to follow an inverse-Gamma
distribution, where the hyperparameters are specified as a vector with elements
corresponding to the shape and scale parameters, respectively. <code>rho</code> is 
assumed to follow a uniform distribution, where the hyperparameters are specified in 
a vector of length two with elements corresponding to the lower and upper bounds of
the uniform prior.</p>
</td></tr>
<tr><td><code id="svcTPGOcc_+3A_tuning">tuning</code></td>
<td>
<p>a list with each tag corresponding to a parameter
name. Valid tags are <code>phi</code>, <code>sigma.sq</code>, <code>nu</code>, and <code>rho</code>. 
The value portion of each tag defines the initial variance of the Adaptive sampler. See
Roberts and Rosenthal (2009) for details.</p>
</td></tr>
<tr><td><code id="svcTPGOcc_+3A_svc.cols">svc.cols</code></td>
<td>
<p>a vector indicating the variables whose effects will be 
estimated as spatially-varying coefficients. <code>svc.cols</code> can be an 
integer vector with values indicating the order of covariates specified 
in the model formula (with 1 being the intercept if specified), or it can 
be specified as a character vector with names corresponding to variable 
names in <code>occ.covs</code> (for the intercept, use <code>'(Intercept)'</code>). <code>svc.cols</code>
default argument of 1 results in a spatial occupancy model analogous to 
<code>stPGOcc</code> (assuming an intercept is included in the model).</p>
</td></tr> 
<tr><td><code id="svcTPGOcc_+3A_cov.model">cov.model</code></td>
<td>
<p>a quoted keyword that specifies the covariance
function used to model the spatial dependence structure among the
observations.  Supported covariance model key words are:
<code>"exponential"</code>, <code>"matern"</code>, <code>"spherical"</code>, and
<code>"gaussian"</code>.</p>
</td></tr>
<tr><td><code id="svcTPGOcc_+3A_nngp">NNGP</code></td>
<td>
<p>if <code>TRUE</code>, model is fit with an NNGP. If <code>FALSE</code>, 
a full Gaussian process is used. See Datta et al. (2016) and 
Finley et al. (2019) for more information. Currently only <code>NNGP = TRUE</code> is
supported for multi-season single-species occupancy models.</p>
</td></tr>
<tr><td><code id="svcTPGOcc_+3A_n.neighbors">n.neighbors</code></td>
<td>
<p>number of neighbors used in the NNGP. Only used if 
<code>NNGP = TRUE</code>. Datta et al. (2016) showed that 15 neighbors is usually 
sufficient, but that as few as 5 neighbors can be adequate for certain data
sets, which can lead to even greater decreases in run time. We recommend
starting with 15 neighbors (the default) and if additional gains in computation
time are desired, subsequently compare the results with a smaller number
of neighbors using WAIC or k-fold cross-validation.</p>
</td></tr>
<tr><td><code id="svcTPGOcc_+3A_search.type">search.type</code></td>
<td>
<p>a quoted keyword that specifies the type of nearest
neighbor search algorithm. Supported method key words are: <code>"cb"</code> and
<code>"brute"</code>. The <code>"cb"</code> should generally be much
faster. If locations do not have identical coordinate values on
the axis used for the nearest neighbor ordering then <code>"cb"</code> 
and <code>"brute"</code> should produce identical neighbor sets. 
However, if there are identical coordinate values on the axis used 
for nearest neighbor ordering, then <code>"cb"</code> and <code>"brute"</code> 
might produce different, but equally valid, neighbor sets, 
e.g., if data are on a grid. </p>
</td></tr>
<tr><td><code id="svcTPGOcc_+3A_n.batch">n.batch</code></td>
<td>
<p>the number of MCMC batches in each chain to run for the Adaptive MCMC 
sampler. See Roberts and Rosenthal (2009) for details.</p>
</td></tr>
<tr><td><code id="svcTPGOcc_+3A_batch.length">batch.length</code></td>
<td>
<p>the length of each MCMC batch in each chain to run for the Adaptive 
MCMC sampler. See Roberts and Rosenthal (2009) for details.</p>
</td></tr>
<tr><td><code id="svcTPGOcc_+3A_accept.rate">accept.rate</code></td>
<td>
<p>target acceptance rate for Adaptive MCMC. Default is 
0.43. See Roberts and Rosenthal (2009) for details.</p>
</td></tr>
<tr><td><code id="svcTPGOcc_+3A_n.omp.threads">n.omp.threads</code></td>
<td>
<p>a positive integer indicating the number of threads
to use for SMP parallel processing. The package must be compiled for 
OpenMP support. For most Intel-based machines, we recommend setting 
<code>n.omp.threads</code> up to the number of hyperthreaded cores. Note, 
<code>n.omp.threads</code> &gt; 1 might not work on some systems. Currently only 
relevant for spatial models.</p>
</td></tr>
<tr><td><code id="svcTPGOcc_+3A_verbose">verbose</code></td>
<td>
<p>if <code>TRUE</code>, messages about data preparation, 
model specification, and progress of the sampler are printed to the screen. 
Otherwise, no messages are printed.</p>
</td></tr>
<tr><td><code id="svcTPGOcc_+3A_ar1">ar1</code></td>
<td>
<p>logical value indicating whether to include an AR(1) zero-mean
temporal random effect in the model. If <code>FALSE</code>, the model is
fit without an AR(1) temporal autocovariance structure. If <code>TRUE</code>,
an AR(1) random effect is included in the model to account for temporal
autocorrelation across the primary time periods.</p>
</td></tr>
<tr><td><code id="svcTPGOcc_+3A_n.report">n.report</code></td>
<td>
<p>the interval to report MCMC progress.</p>
</td></tr>
<tr><td><code id="svcTPGOcc_+3A_n.burn">n.burn</code></td>
<td>
<p>the number of samples out of the total <code>n.samples</code> to 
discard as burn-in for each chain. By default, the first 10% of samples is discarded.</p>
</td></tr>
<tr><td><code id="svcTPGOcc_+3A_n.thin">n.thin</code></td>
<td>
<p>the thinning interval for collection of MCMC samples. The
thinning occurs after the <code>n.burn</code> samples are discarded. Default 
value is set to 1.</p>
</td></tr>
<tr><td><code id="svcTPGOcc_+3A_n.chains">n.chains</code></td>
<td>
<p>the number of chains to run in sequence.</p>
</td></tr>
<tr><td><code id="svcTPGOcc_+3A_k.fold">k.fold</code></td>
<td>
<p>specifies the number of <em>k</em> folds for cross-validation. 
If not specified as an argument, then cross-validation is not performed
and <code>k.fold.threads</code> and <code>k.fold.seed</code> are ignored. In <em>k</em>-fold
cross-validation, the data specified in <code>data</code> is randomly
partitioned into <em>k</em> equal sized subsamples. Of the <em>k</em> subsamples, 
<em>k</em> - 1 subsamples are used to fit the model and the remaining <em>k</em>
samples are used for prediction. The cross-validation process is repeated 
<em>k</em> times (the folds). As a scoring rule, we use the model deviance 
as described in Hooten and Hobbs (2015). For cross-validation in multi-season
models, the data are split along the site dimension, such that each hold-out
data set consists of a <code>J / k.fold</code> sites sampled over all primary time
periods during which data are available at each given site. Cross-validation is performed
after the full model is fit using all the data. Cross-validation results
are reported in the <code>k.fold.deviance</code> object in the return list.</p>
</td></tr>
<tr><td><code id="svcTPGOcc_+3A_k.fold.threads">k.fold.threads</code></td>
<td>
<p>number of threads to use for cross-validation. If 
<code>k.fold.threads &gt; 1</code> parallel processing is accomplished using the 
<span class="pkg">foreach</span> and <span class="pkg">doParallel</span> packages. Ignored if <code>k.fold</code>
is not specified.</p>
</td></tr> 
<tr><td><code id="svcTPGOcc_+3A_k.fold.seed">k.fold.seed</code></td>
<td>
<p>seed used to split data set into <code>k.fold</code> parts
for k-fold cross-validation. Ignored if <code>k.fold</code> is not specified.</p>
</td></tr>
<tr><td><code id="svcTPGOcc_+3A_k.fold.only">k.fold.only</code></td>
<td>
<p>a logical value indicating whether to only perform 
cross-validation (<code>TRUE</code>) or perform cross-validation after fitting 
the full model (<code>FALSE</code>). Default value is <code>FALSE</code>.</p>
</td></tr> 
<tr><td><code id="svcTPGOcc_+3A_...">...</code></td>
<td>
<p>currently no additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>svcTPGOcc</code> that is a list comprised of: 
</p>
<table>
<tr><td><code>beta.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the occupancy regression coefficients.</p>
</td></tr>
<tr><td><code>alpha.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the detection regression coefficients.</p>
</td></tr>
<tr><td><code>z.samples</code></td>
<td>
<p>a three-dimensional array of posterior samples 
for the latent occupancy values, with dimensions corresponding to 
posterior sample, site, and primary time period.</p>
</td></tr>
<tr><td><code>psi.samples</code></td>
<td>
<p>a three-dimensional array of posterior samples
for the latent occupancy probability values, with dimensions 
corresponding to posterior sample, site, and primary time period.</p>
</td></tr>
<tr><td><code>theta.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for spatial covariance parameters and temporal covariance parameters
if <code>ar1 = TRUE</code>.</p>
</td></tr>
<tr><td><code>w.samples</code></td>
<td>
<p>a three-dimensional array of posterior samples for the 
latent spatial random effects for all spatially-varying coefficients. 
Dimensions correspond to MCMC sample, coefficient, and sites.</p>
</td></tr>
<tr><td><code>sigma.sq.psi.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for variances of random intercepts included in the occupancy portion
of the model. Only included if random intercepts are specified in 
<code>occ.formula</code>.</p>
</td></tr>
<tr><td><code>sigma.sq.p.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for variances of random intercpets included in the detection portion 
of the model. Only included if random intercepts are specified in 
<code>det.formula</code>.</p>
</td></tr>
<tr><td><code>beta.star.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the occurrence random effects. Only included if random intercepts
are specified in <code>occ.formula</code>.</p>
</td></tr>
<tr><td><code>alpha.star.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the detection random effects. Only included if random intercepts 
are specified in <code>det.formula</code>.</p>
</td></tr>
<tr><td><code>eta.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples for the 
AR(1) random effects for each primary time period. Only included if 
<code>ar1 = TRUE</code>.</p>
</td></tr>
<tr><td><code>like.samples</code></td>
<td>
<p>a three-dimensional array of posterior samples
for the likelihood values associated with each site and primary
time period. Used for calculating WAIC.</p>
</td></tr>
<tr><td><code>rhat</code></td>
<td>
<p>a list of Gelman-Rubin diagnostic values for some of the model
parameters.</p>
</td></tr>
<tr><td><code>ESS</code></td>
<td>
<p>a list of effective sample sizes for some of the model parameters.</p>
</td></tr>
<tr><td><code>run.time</code></td>
<td>
<p>execution time reported using <code>proc.time()</code>.</p>
</td></tr>
<tr><td><code>k.fold.deviance</code></td>
<td>
<p>scoring rule (deviance) from k-fold cross-validation. 
Only included if <code>k.fold</code> is specified in function call.</p>
</td></tr>
</table>
<p>The return object will include additional objects used for 
subsequent prediction and/or model fit evaluation. Note that detection
probability estimated values are not included in the model object, but can be 
extracted using <code>fitted()</code>. Note that if <code>k.fold.only = TRUE</code>, the
return list object will only contain <code>run.time</code> and <code>k.fold.deviance</code>.
</p>


<h3>Note</h3>

<p>Some of the underlying code used for generating random numbers from the
Polya-Gamma distribution is taken from the <span class="pkg">pgdraw</span> package written
by Daniel F. Schmidt and Enes Makalic. Their code implements Algorithm
6 in PhD thesis of Jesse Bennett Windle (2013) <a href="https://repositories.lib.utexas.edu/handle/2152/21842">https://repositories.lib.utexas.edu/handle/2152/21842</a>.
</p>


<h3>Author(s)</h3>

<p>Jeffrey W. Doser <a href="mailto:doserjef@msu.edu">doserjef@msu.edu</a>, <br />
Andrew O. Finley <a href="mailto:finleya@msu.edu">finleya@msu.edu</a>
</p>


<h3>References</h3>

<p>Polson, N.G., J.G. Scott, and J. Windle. (2013) Bayesian Inference for
Logistic Models Using Polya-Gamma Latent Variables. 
<em>Journal of the American Statistical Association</em>, 108:1339-1349.
</p>
<p>Bates, Douglas, Martin Maechler, Ben Bolker, Steve Walker (2015).
Fitting Linear Mixed-Effects Models Using lme4. Journal of
Statistical Software, 67(1), 1-48. <a href="https://doi.org/10.18637/jss.v067.i01">doi:10.18637/jss.v067.i01</a>.
</p>
<p>Kery, M., &amp; Royle, J. A. (2021). Applied hierarchical modeling in ecology: 
Analysis of distribution, abundance and species richness in R and BUGS: 
Volume 2: Dynamic and advanced models. Academic Press. Section 4.6.
</p>
<p>Finley, A. O., and  Banerjee, S. (2020). Bayesian spatially varying coefficient 
models in the spBayes R package. <em>Environmental Modelling and Software</em>, 
125, 104608.
</p>
<p>Hooten, M. B., and Hobbs, N. T. (2015). A guide to Bayesian model 
selection for ecologists. Ecological monographs, 85(1), 3-28.
</p>
<p>MacKenzie, D. I., J. D. Nichols, G. B. Lachman, S. Droege, 
J. Andrew Royle, and C. A. Langtimm. 2002. Estimating Site Occupancy 
Rates When Detection Probabilities Are Less Than One. Ecology 83: 2248-2255.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1000)
# Sites
J.x &lt;- 15
J.y &lt;- 15
J &lt;- J.x * J.y
# Years sampled
n.time &lt;- sample(10, J, replace = TRUE)
n.time.max &lt;- max(n.time)
# Replicates
n.rep &lt;- matrix(NA, J, max(n.time))
for (j in 1:J) {
  n.rep[j, 1:n.time[j]] &lt;- sample(4, n.time[j], replace = TRUE)
}
# Occurrence --------------------------
beta &lt;- c(-2, -0.5, -0.2, 0.75)
trend &lt;- TRUE 
sp.only &lt;- 0
psi.RE &lt;- list()
# Detection ---------------------------
alpha &lt;- c(1, 0.7, -0.5)
p.RE &lt;- list()
# Spatial parameters ------------------
sp &lt;- TRUE
svc.cols &lt;- c(1, 2, 3)
p.svc &lt;- length(svc.cols)
cov.model &lt;- "exponential"
sigma.sq &lt;- runif(p.svc, 0.1, 1)
phi &lt;- runif(p.svc, 3 / 1, 3 / 0.2)
rho &lt;- 0.8
sigma.sq.t &lt;- 1
ar1 &lt;- TRUE	 
x.positive &lt;- FALSE 

# Get all the data
dat &lt;- simTOcc(J.x = J.x, J.y = J.y, n.time = n.time, n.rep = n.rep, 
               beta = beta, alpha = alpha, sp.only = sp.only, trend = trend, 
               psi.RE = psi.RE, p.RE = p.RE, 
               sp = sp, cov.model = cov.model, sigma.sq = sigma.sq, phi = phi, 
               svc.cols = svc.cols, ar1 = ar1, rho = rho, sigma.sq.t = sigma.sq.t, 
               x.positive = x.positive)

# Prep the data for svcTPGOcc ---------------------------------------------
# Full data set 
y &lt;- dat$y
X &lt;- dat$X
X.re &lt;- dat$X.re
X.p &lt;- dat$X.p
X.p.re &lt;- dat$X.p.re
coords &lt;- dat$coords

# Package all data into a list
occ.covs &lt;- list(int = X[, , 1], 
                 trend = X[, , 2], 
                 occ.cov.1 = X[, , 3], 
                 occ.cov.2 = X[, , 4]) 
# Detection
det.covs &lt;- list(det.cov.1 = X.p[, , , 2], 
                 det.cov.2 = X.p[, , , 3]) 
# Data list bundle
data.list &lt;- list(y = y, 
                  occ.covs = occ.covs,
                  det.covs = det.covs, 
                  coords = coords)
# Priors
prior.list &lt;- list(beta.normal = list(mean = 0, var = 2.72), 
                   alpha.normal = list(mean = 0, var = 2.72),
                   phi.unif = list(a = 3/1, b = 3/.1)) 

# Starting values
z.init &lt;- apply(y, c(1, 2), function(a) as.numeric(sum(a, na.rm = TRUE) &gt; 0))
inits.list &lt;- list(beta = 0, alpha = 0,
                   sigma.sq = 1, phi = 3 / 0.5,
                   z = z.init, nu = 1)
# Tuning
tuning.list &lt;- list(phi = 0.4, nu = 0.3, rho = 0.5, sigma.sq = 0.5) 

# MCMC settings
n.batch &lt;- 2 
n.burn &lt;- 0 
n.thin &lt;- 1

# Run the model
out &lt;- svcTPGOcc(occ.formula = ~ trend + occ.cov.1 + occ.cov.2, 
                 det.formula = ~ det.cov.1 + det.cov.2, 
                 data = data.list,
                 inits = inits.list,
                 tuning = tuning.list,
                 priors = prior.list, 
                 cov.model = "exponential", 
                 svc.cols = svc.cols,
                 NNGP = TRUE, 
                 ar1 = TRUE,
                 n.neighbors = 5, 
                 n.batch = n.batch,
                 batch.length = 25,
                 verbose = TRUE, 
                 n.report = 25,
                 n.burn = n.burn, 
                 n.thin = n.thin,
                 n.chains = 1) 
</code></pre>

<hr>
<h2 id='tMsPGOcc'>Function for Fitting Multi-Species Multi-Season Occupancy Models</h2><span id='topic+tMsPGOcc'></span>

<h3>Description</h3>

<p>The function <code>tMsPGOcc</code> fits multi-species multi-season occupancy models using Polya-Gamma data augmentation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tMsPGOcc(occ.formula, det.formula, data, inits, priors, tuning, 
         n.batch, batch.length, 
         accept.rate = 0.43, n.omp.threads = 1, 
         verbose = TRUE, ar1 = FALSE, n.report = 100, 
         n.burn = round(.10 * n.batch * batch.length), n.thin = 1, 
         n.chains = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tMsPGOcc_+3A_occ.formula">occ.formula</code></td>
<td>
<p>a symbolic description of the model to be fit
for the occurrence portion of the model using R's model syntax. Random
intercepts are allowed using lme4 syntax (Bates et al. 2015). Only
right-hand side of formula is specified. See example below.</p>
</td></tr>
<tr><td><code id="tMsPGOcc_+3A_det.formula">det.formula</code></td>
<td>
<p>a symbolic description of the model to be fit
for the detection portion of the model using R's model syntax. Only
right-hand side of formula is specified. See example below. Random 
intercepts are allowed using lme4 syntax (Bates et al. 2015).</p>
</td></tr>
<tr><td><code id="tMsPGOcc_+3A_data">data</code></td>
<td>
<p>a list containing data necessary for model fitting.
Valid tags are <code>y</code>, <code>occ.covs</code>, and <code>det.covs</code>. 
<code>y</code> is a four-dimensional array with first dimension equal to the 
number of species, second dimension equal to the number of sites, third
dimension equal to the number of primary time periods, and 
fourth dimension equal to the maximum number of secondary replicates at a given site. 
<code>occ.covs</code> is a list of variables included in the occurrence portion of the model. Each
list element is a different occurrence covariate, which can be site level
or site/primary time period level. Site-level covariates are specified as a vector of 
length <code class="reqn">J</code> while site/primary time period level covariates are specified as a matrix
with rows corresponding to sites and columns correspond to primary time periods.
Similarly, <code>det.covs</code> is a list of variables included in the detection
portion of the model, with each list element corresponding to an individual variable.    
In addition to site-level and/or site/primary time period-level, 
detection covariates can also be observational-level. Observation-level covariates
are specified as a three-dimensional array with first dimension corresponding to 
sites, second dimension corresponding to primary time period, and third 
dimension corresponding to replicate.</p>
</td></tr>
<tr><td><code id="tMsPGOcc_+3A_inits">inits</code></td>
<td>
<p>a list with each tag corresponding to a parameter name.
Valid tags are <code>alpha.comm</code>, <code>beta.comm</code>, <code>beta</code>, 
<code>alpha</code>, <code>tau.sq.beta</code>, <code>tau.sq.alpha</code>, 
<code>sigma.sq.psi</code>, <code>sigma.sq.p</code>, <code>z</code>, 
<code>sigma.sq.t</code>, and <code>rho</code>. <code>sigma.sq.t</code> and <code>rho</code> are only
relevant when <code>ar1 = TRUE</code>, and <code>sigma.sq.psi</code> and <code>sigma.sq.p</code> are
only specified if random effects are included in <code>occ.formula</code> or 
<code>det.formula</code>, respectively. The value portion of each tag is 
the parameter's initial value. See <code>priors</code> description for definition
of each parameter name. Additionally, the tag <code>fix</code> can be set to <code>TRUE</code> 
to fix the starting values across all chains. If <code>fix</code> is not specified
(the default), starting values are varied randomly across chains.</p>
</td></tr>
<tr><td><code id="tMsPGOcc_+3A_priors">priors</code></td>
<td>
<p>a list with each tag corresponding to a parameter name. 
Valid tags are <code>beta.comm.normal</code>, <code>alpha.comm.normal</code>, 
<code>tau.sq.beta.ig</code>, <code>tau.sq.alpha.ig</code>, <code>sigma.sq.psi</code>, 
<code>sigma.sq.p</code>, <code>sigma.sq.t.ig</code>, and <code>rho.unif</code>. 
Community-level occurrence (<code>beta.comm</code>) and detection 
(<code>alpha.comm</code>) regression coefficients are assumed to follow a 
normal distribution. The hyperparameters of the normal distribution
are passed as a list of length two with the first and second elements 
corresponding to the mean and variance of the normal distribution, 
which are each specified as vectors of length equal to the number of 
coefficients to be estimated or of length one if priors are the same for 
all coefficients. If not specified, prior means are set 
to 0 and prior variances set to 2.72. By default, community-level variance parameters 
for occupancy (<code>tau.sq.beta</code>) and detection (<code>tau.sq.alpha</code>) are 
assumed to follow an inverse Gamma distribution. The hyperparameters of 
the inverse gamma distribution are passed as a list of length two with 
the first and second elements corresponding to the shape and scale parameters,
which are each specified as vectors of length equal to the number of 
coefficients to be estimated or a single value if priors are the same for all 
parameters. If not specified, prior shape and scale 
parameters are set to 0.1. <code>sigma.sq.t</code> and 
<code>rho</code> are the AR(1) variance and correlation parameters for the AR(1) zero-mean
temporal random effects, respectively. <code>sigma.sq.t</code> is assumed to follow an inverse-Gamma
distribution, where the hyperparameters are specified as a list of length two with the 
first and second elements corresponding to the shape and scale parameters, respectively, 
which can each be specified as vector equal to the number of species in the model or a single value
if the same prior is used for all species. <code>rho</code> is assumed to follow a 
uniform distribution, where the hyperparameters are specified similarly as a list of length two
with the first and second elements corresponding to the lower and upper bounds of the 
uniform prior, which can each be specified as vector equal to the number of species in the 
model or a single value if the same prior is used for all species. 
<code>sigma.sq.psi</code> and <code>sigma.sq.p</code> are the random effect variances for any occurrence or
detection random effects, respectively, and are assumed to follow an inverse
Gamma distribution. The hyperparameters of the inverse-Gamma distribution
are passed as a list of length two with first and second elements corresponding
to the shape and scale parameters, respectively, which are each specified as
vectors of length equal to the number of random intercepts or of length one 
if priors are the same for all random effect variances.</p>
</td></tr>
<tr><td><code id="tMsPGOcc_+3A_tuning">tuning</code></td>
<td>
<p>a list with each tag corresponding to a parameter
name. Valid tags are <code>rho</code>. The value portion of each
tag defines the initial tuning variance of the Adaptive sampler. See
Roberts and Rosenthal (2009) for details.</p>
</td></tr>
<tr><td><code id="tMsPGOcc_+3A_n.batch">n.batch</code></td>
<td>
<p>the number of MCMC batches  in each chain to run for the Adaptive MCMC 
sampler. See Roberts and Rosenthal (2009) for details.</p>
</td></tr>
<tr><td><code id="tMsPGOcc_+3A_batch.length">batch.length</code></td>
<td>
<p>the length of each MCMC batch to run for the Adaptive 
MCMC sampler. See Roberts and Rosenthal (2009) for details.</p>
</td></tr>
<tr><td><code id="tMsPGOcc_+3A_accept.rate">accept.rate</code></td>
<td>
<p>target acceptance rate for Adaptive MCMC. Defaul is 
0.43. See Roberts and Rosenthal (2009) for details.</p>
</td></tr>
<tr><td><code id="tMsPGOcc_+3A_n.omp.threads">n.omp.threads</code></td>
<td>
<p>a positive integer indicating
the number of threads to use for SMP parallel processing. The package must
be compiled for OpenMP support. For most Intel-based machines, we
recommend setting <code>n.omp.threads</code> up to the number of
hyperthreaded cores. Note, <code>n.omp.threads</code> &gt; 1 might not
work on some systems.</p>
</td></tr>
<tr><td><code id="tMsPGOcc_+3A_verbose">verbose</code></td>
<td>
<p>if <code>TRUE</code>, messages about data preparation, 
model specification, and progress of the sampler are printed to the screen. 
Otherwise, no messages are printed.</p>
</td></tr>
<tr><td><code id="tMsPGOcc_+3A_ar1">ar1</code></td>
<td>
<p>logical value indicating whether to include an AR(1) zero-mean 
temporal random effect in the model for each species. If <code>FALSE</code>, the model is
fit without an AR(1) temporal autocovariance structure. If <code>TRUE</code>,
a species-specific AR(1) random effect is included in the model to account for temporal 
autocorrelation across the primary time periods.</p>
</td></tr>
<tr><td><code id="tMsPGOcc_+3A_n.report">n.report</code></td>
<td>
<p>the interval to report Metropolis sampler acceptance and
MCMC progress. Note this is specified in terms of batches and not overall
samples for spatial models.</p>
</td></tr>
<tr><td><code id="tMsPGOcc_+3A_n.burn">n.burn</code></td>
<td>
<p>the number of samples out of the total <code>n.samples</code> to 
discard as burn-in for each chain. By default, the first 10% of samples is discarded.</p>
</td></tr>
<tr><td><code id="tMsPGOcc_+3A_n.thin">n.thin</code></td>
<td>
<p>the thinning interval for collection of MCMC samples. The
thinning occurs after the <code>n.burn</code> samples are discarded. Default 
value is set to 1.</p>
</td></tr>
<tr><td><code id="tMsPGOcc_+3A_n.chains">n.chains</code></td>
<td>
<p>the number of chains to run in sequence.</p>
</td></tr>
<tr><td><code id="tMsPGOcc_+3A_...">...</code></td>
<td>
<p>currently no additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>tMsPGOcc</code> that is a list comprised of: 
</p>
<table>
<tr><td><code>beta.comm.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the community level occurrence regression coefficients.</p>
</td></tr>
<tr><td><code>alpha.comm.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the community level detection regression coefficients.</p>
</td></tr>
<tr><td><code>tau.sq.beta.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the occurrence community variance parameters.</p>
</td></tr>
<tr><td><code>tau.sq.alpha.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the detection community variance parameters.</p>
</td></tr>
<tr><td><code>beta.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the species level occurrence regression coefficients.</p>
</td></tr>
<tr><td><code>alpha.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the species level detection regression coefficients.</p>
</td></tr>
<tr><td><code>theta.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the species level AR(1) variance (<code>sigma.sq.t</code>) and 
correlation (<code>rho</code>) parameters. Only included if <code>ar1 = TRUE</code>.</p>
</td></tr>
<tr><td><code>eta.samples</code></td>
<td>
<p>a three-dimensional array of posterior samples for 
the species-specific AR(1) random effects for each primary time period.
Dimensions correspond to MCMC sample, species, and primary time period.</p>
</td></tr>
<tr><td><code>z.samples</code></td>
<td>
<p>a four-dimensional array of posterior samples for
the latent occurrence values for each species. Dimensions corresopnd to 
MCMC sample, species, site, and primary time period.</p>
</td></tr>
<tr><td><code>psi.samples</code></td>
<td>
<p>a four-dimensional array of posterior samples for
the latent occupancy probability values for each species. Dimensions correspond
to MCMC sample, species, site, and primary time period.</p>
</td></tr>
<tr><td><code>sigma.sq.psi.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for variances of random intercepts included in the occurrence portion
of the model. Only included if random intercepts are specified in 
<code>occ.formula</code>.</p>
</td></tr>
<tr><td><code>sigma.sq.p.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for variances of random intercpets included in the detection portion 
of the model. Only included if random intercepts are specified in 
<code>det.formula</code>.</p>
</td></tr>
<tr><td><code>beta.star.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the occurrence random effects. Only included if random intercepts
are specified in <code>occ.formula</code>.</p>
</td></tr>
<tr><td><code>alpha.star.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the detection random effects. Only included if random intercepts 
are specified in <code>det.formula</code>.</p>
</td></tr>
<tr><td><code>like.samples</code></td>
<td>
<p>a four-dimensional array of posterior samples
for the likelihood value used for calculating WAIC. Dimensions correspond 
to MCMC sample, species, site, and time period.</p>
</td></tr>
<tr><td><code>rhat</code></td>
<td>
<p>a list of Gelman-Rubin diagnostic values for some of the model
parameters.</p>
</td></tr>
<tr><td><code>ESS</code></td>
<td>
<p>a list of effective sample sizes for some of the model parameters.</p>
</td></tr>
<tr><td><code>run.time</code></td>
<td>
<p>MCMC sampler execution time reported using <code>proc.time()</code>.</p>
</td></tr>
</table>
<p>The return object will include additional objects used for 
subsequent prediction and/or model fit evaluation. Note that detection 
probability estimated values are not included in the model object, but can
be extracted using <code>fitted()</code>.
</p>


<h3>Note</h3>

<p>Some of the underlying code used for generating random numbers from the
Polya-Gamma distribution is taken from the <span class="pkg">pgdraw</span> package written
by Daniel F. Schmidt and Enes Makalic. Their code implements Algorithm
6 in PhD thesis of Jesse Bennett Windle (2013) <a href="https://repositories.lib.utexas.edu/handle/2152/21842">https://repositories.lib.utexas.edu/handle/2152/21842</a>.
</p>


<h3>Author(s)</h3>

<p>Jeffrey W. Doser <a href="mailto:doserjef@msu.edu">doserjef@msu.edu</a>, <br />
Andrew O. Finley <a href="mailto:finleya@msu.edu">finleya@msu.edu</a>
</p>


<h3>References</h3>

<p>Polson, N.G., J.G. Scott, and J. Windle. (2013) Bayesian Inference for
Logistic Models Using Polya-Gamma Latent Variables.
<em>Journal of the American Statistical Association</em>, 108:1339-1349.
</p>
<p>Roberts, G.O. and Rosenthal J.S. (2009) Examples  of adaptive MCMC.
<em>Journal of Computational and Graphical Statistics</em>, 18(2):349-367.
</p>
<p>Bates, Douglas, Martin Maechler, Ben Bolker, Steve Walker (2015).
Fitting Linear Mixed-Effects Models Using lme4. Journal of
Statistical Software, 67(1), 1-48. <a href="https://doi.org/10.18637/jss.v067.i01">doi:10.18637/jss.v067.i01</a>.
</p>
<p>Kery, M., &amp; Royle, J. A. (2021). Applied hierarchical modeling in ecology: 
Analysis of distribution, abundance and species richness in R and BUGS: 
Volume 2: Dynamic and advanced models. Academic Press. Section 4.6.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simulate Data -----------------------------------------------------------
set.seed(500)
J.x &lt;- 8
J.y &lt;- 8
J &lt;- J.x * J.y
# Years sampled
n.time &lt;- sample(3:10, J, replace = TRUE)
# n.time &lt;- rep(10, J)
n.time.max &lt;- max(n.time)
# Replicates
n.rep &lt;- matrix(NA, J, max(n.time))
for (j in 1:J) {
  n.rep[j, 1:n.time[j]] &lt;- sample(2:4, n.time[j], replace = TRUE)
}
N &lt;- 7
# Community-level covariate effects
# Occurrence
beta.mean &lt;- c(-3, -0.2, 0.5)
trend &lt;- FALSE
sp.only &lt;- 0
p.occ &lt;- length(beta.mean)
tau.sq.beta &lt;- c(0.6, 1.5, 1.4)
# Detection
alpha.mean &lt;- c(0, 1.2, -1.5)
tau.sq.alpha &lt;- c(1, 0.5, 2.3)
p.det &lt;- length(alpha.mean)
# Random effects
psi.RE &lt;- list()
p.RE &lt;- list()
# Draw species-level effects from community means.
beta &lt;- matrix(NA, nrow = N, ncol = p.occ)
alpha &lt;- matrix(NA, nrow = N, ncol = p.det)
for (i in 1:p.occ) {
  beta[, i] &lt;- rnorm(N, beta.mean[i], sqrt(tau.sq.beta[i]))
}
for (i in 1:p.det) {
  alpha[, i] &lt;- rnorm(N, alpha.mean[i], sqrt(tau.sq.alpha[i]))
}
sp &lt;- FALSE

dat &lt;- simTMsOcc(J.x = J.x, J.y = J.y, n.time = n.time, n.rep = n.rep, N = N,
                 beta = beta, alpha = alpha, sp.only = sp.only, trend = trend,
                 psi.RE = psi.RE, p.RE = p.RE, sp = sp)

y &lt;- dat$y
X &lt;- dat$X
X.p &lt;- dat$X.p
X.re &lt;- dat$X.re
X.p.re &lt;- dat$X.p.re

occ.covs &lt;- list(occ.cov.1 = X[, , 2],
                 occ.cov.2 = X[, , 3])
det.covs &lt;- list(det.cov.1 = X.p[, , , 2],
                 det.cov.2 = X.p[, , , 3])

data.list &lt;- list(y = y, occ.covs = occ.covs,
                  det.covs = det.covs)
# Priors
prior.list &lt;- list(beta.comm.normal = list(mean = 0, var = 2.72),
                   alpha.comm.normal = list(mean = 0, var = 2.72),
                   tau.sq.beta.ig = list(a = 0.1, b = 0.1),
                   tau.sq.alpha.ig = list(a = 0.1, b = 0.1))
z.init &lt;- apply(y, c(1, 2, 3), function(a) as.numeric(sum(a, na.rm = TRUE) &gt; 0))
inits.list &lt;- list(alpha.comm = 0, beta.comm = 0, beta = 0,
                   alpha = 0, tau.sq.beta = 1, tau.sq.alpha = 1,
                   z = z.init)
# Tuning
tuning.list &lt;- list(phi = 1)

# Number of batches
n.batch &lt;- 5
# Batch length
batch.length &lt;- 25
n.burn &lt;- 25
n.thin &lt;- 1
n.samples &lt;- n.batch * batch.length

out &lt;- tMsPGOcc(occ.formula = ~ occ.cov.1 + occ.cov.2,
                det.formula = ~ det.cov.1 + det.cov.2,
                data = data.list,
                inits = inits.list,
                n.batch = n.batch,
                batch.length = batch.length,
                accept.rate = 0.43,
                priors = prior.list,
                n.omp.threads = 1,
                verbose = TRUE,
                n.report = 1,
                n.burn = n.burn,
                n.thin = n.thin,
                n.chains = 1)

summary(out)
</code></pre>

<hr>
<h2 id='tPGOcc'>Function for Fitting Multi-Season Single-Species Occupancy Models Using Polya-Gamma Latent Variables</h2><span id='topic+tPGOcc'></span>

<h3>Description</h3>

<p>Function for fitting multi-season single-species occupancy models using Polya-Gamma latent variables. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tPGOcc(occ.formula, det.formula, data, inits, priors, tuning, 
       n.batch, batch.length, accept.rate = 0.43, n.omp.threads = 1, 
       verbose = TRUE, ar1 = FALSE, n.report = 100, 
       n.burn = round(.10 * n.batch * batch.length), n.thin = 1, n.chains = 1,
       k.fold, k.fold.threads = 1, k.fold.seed = 100, k.fold.only = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tPGOcc_+3A_occ.formula">occ.formula</code></td>
<td>
<p>a symbolic description of the model to be fit
for the occurrence portion of the model using R's model syntax. Only
right-hand side of formula is specified. See example below. Random intercepts
are allowed using lme4 syntax (Bates et al. 2015).</p>
</td></tr>
<tr><td><code id="tPGOcc_+3A_det.formula">det.formula</code></td>
<td>
<p>a symbolic description of the model to be fit
for the detection portion of the model using R's model syntax. Only
right-hand side of formula is specified. See example below. Random intercepts
are allowed using lme4 syntax (Bates et al. 2015).</p>
</td></tr>
<tr><td><code id="tPGOcc_+3A_data">data</code></td>
<td>
<p>a list containing data necessary for model fitting.
Valid tags are <code>y</code>, <code>occ.covs</code>, and <code>det.covs</code>. <code>y</code>
is a three-dimensional array with first dimension equal to the number of 
sites (<code class="reqn">J</code>), second dimension equal to the maximum number of 
primary time periods (i.e., years or seasons), and third dimension equal 
to the maximum number of replicates at a given site. <code>occ.covs</code> is a
list of variables included in the occurrence portion of the model. Each
list element is a different occurrence covariate, which can be site level
or site/primary time period level. Site-level covariates are specified as a vector of 
length <code class="reqn">J</code> while site/primary time period level covariates are specified as a matrix
with rows corresponding to sites and columns correspond to primary time periods.
Similarly, <code>det.covs</code> is a list of variables included in the detection
portion of the model, with each list element corresponding to an 
individual variable. In addition to site-level and/or site/primary time period-level, 
detection covariates can also be observational-level. Observation-level covariates
are specified as a three-dimensional array with first dimension corresponding to 
sites, second dimension corresponding to primary time period, and third 
dimension corresponding to replicate.</p>
</td></tr>
<tr><td><code id="tPGOcc_+3A_inits">inits</code></td>
<td>
<p>a list with each tag corresponding to a parameter name.
Valid tags are <code>z</code>, <code>beta</code>, <code>alpha</code>, <code>sigma.sq.psi</code>, 
<code>sigma.sq.p</code>, <code>sigma.sq.t</code>, and <code>rho</code>. The value portion of each tag is the 
parameter's initial value. <code>sigma.sq.psi</code> and <code>sigma.sq.p</code> are 
only relevant when including random effects in the occurrence and 
detection portion of the occupancy model, respectively. <code>sigma.sq.t</code> and <code>rho</code>
are only relevant when <code>ar1 = TRUE</code>. See <code>priors</code> 
description for definition of each parameter name.
Additionally, the tag <code>fix</code> can be set to <code>TRUE</code> 
to fix the starting values across all chains. If <code>fix</code> is not specified
(the default), starting values are varied randomly across chains.</p>
</td></tr>
<tr><td><code id="tPGOcc_+3A_priors">priors</code></td>
<td>
<p>a list with each tag corresponding to a parameter name. 
Valid tags are <code>beta.normal</code>, <code>alpha.normal</code>, <code>sigma.sq.psi.ig</code>, 
<code>sigma.sq.p.ig</code>, <code>sigma.sq.t.ig</code>, and <code>rho.unif</code>. 
Occupancy (<code>beta</code>) and detection (<code>alpha</code>) 
regression coefficients are assumed to follow a normal distribution. 
The hyperparameters of the normal distribution are passed as a list of 
length two with the first and second elements corresponding to the mean 
and variance of the normal distribution, which are each specified as vectors of 
length equal to the number of coefficients to be estimated or of length one
if priors are the same for all coefficients. If not specified, prior means 
are set to 0 and prior variances set to 2.72. <code>sigma.sq.psi</code> and 
<code>sigma.sq.p</code> are the random effect variances for any unstructured occurrence or 
detection random effects, respectively, and are assumed to follow an inverse
Gamma distribution. The hyperparameters of the inverse-Gamma distribution
are passed as a list of length two with first and second elements corresponding
to the shape and scale parameters, respectively, which are each specified as
vectors of length equal to the number of random intercepts or of length one 
if priors are the same for all random effect variances. <code>sigma.sq.t</code> and 
<code>rho</code> are the AR(1) variance and correlation parameters for the AR(1) zero-mean
temporal random effects, respectively. <code>sigma.sq.t</code> is assumed to follow an inverse-Gamma
distribution, where the hyperparameters are specified as a vector with elements
corresponding to the shape and scale parameters, respectively. <code>rho</code> is 
assumed to follow a uniform distribution, where the hyperparameters are specified in 
a vector of length two with elements corresponding to the lower and upper bounds of
the uniform prior.</p>
</td></tr>
<tr><td><code id="tPGOcc_+3A_tuning">tuning</code></td>
<td>
<p>a list with each tag corresponding to a parameter
name. Valid tags are <code>rho</code>. The value portion of each
tag defines the initial tuning variance of the Adaptive sampler. See
Roberts and Rosenthal (2009) for details.</p>
</td></tr>
<tr><td><code id="tPGOcc_+3A_n.batch">n.batch</code></td>
<td>
<p>the number of MCMC batches in each chain to run for the Adaptive MCMC 
sampler. See Roberts and Rosenthal (2009) for details.</p>
</td></tr>
<tr><td><code id="tPGOcc_+3A_batch.length">batch.length</code></td>
<td>
<p>the length of each MCMC batch in each chain to run for the Adaptive 
MCMC sampler. See Roberts and Rosenthal (2009) for details.</p>
</td></tr>
<tr><td><code id="tPGOcc_+3A_accept.rate">accept.rate</code></td>
<td>
<p>target acceptance rate for Adaptive MCMC. Default is 
0.43. See Roberts and Rosenthal (2009) for details.</p>
</td></tr>
<tr><td><code id="tPGOcc_+3A_n.omp.threads">n.omp.threads</code></td>
<td>
<p>a positive integer indicating the number of threads
to use for SMP parallel processing. The package must be compiled for 
OpenMP support. For most Intel-based machines, we recommend setting 
<code>n.omp.threads</code> up to the number of hyperthreaded cores. Note, 
<code>n.omp.threads</code> &gt; 1 might not work on some systems. Currently only 
relevant for spatial models.</p>
</td></tr>
<tr><td><code id="tPGOcc_+3A_verbose">verbose</code></td>
<td>
<p>if <code>TRUE</code>, messages about data preparation, 
model specification, and progress of the sampler are printed to the screen. 
Otherwise, no messages are printed.</p>
</td></tr>
<tr><td><code id="tPGOcc_+3A_ar1">ar1</code></td>
<td>
<p>logical value indicating whether to include an AR(1) zero-mean 
temporal random effect in the model. If <code>FALSE</code>, the model is
fit without an AR(1) temporal autocovariance structure. If <code>TRUE</code>,
an AR(1) random effect is included in the model to account for temporal 
autocorrelation across the primary time periods.</p>
</td></tr>
<tr><td><code id="tPGOcc_+3A_n.report">n.report</code></td>
<td>
<p>the interval to report MCMC progress. Note this is specified
in terms of batches, not MCMC samples.</p>
</td></tr>
<tr><td><code id="tPGOcc_+3A_n.burn">n.burn</code></td>
<td>
<p>the number of samples out of the total <code>n.samples</code> to 
discard as burn-in for each chain. By default, the first 10% of samples is discarded.</p>
</td></tr>
<tr><td><code id="tPGOcc_+3A_n.thin">n.thin</code></td>
<td>
<p>the thinning interval for collection of MCMC samples. The
thinning occurs after the <code>n.burn</code> samples are discarded. Default 
value is set to 1.</p>
</td></tr>
<tr><td><code id="tPGOcc_+3A_n.chains">n.chains</code></td>
<td>
<p>the number of chains to run in sequence.</p>
</td></tr>
<tr><td><code id="tPGOcc_+3A_k.fold">k.fold</code></td>
<td>
<p>specifies the number of <em>k</em> folds for cross-validation. 
If not specified as an argument, then cross-validation is not performed
and <code>k.fold.threads</code> and <code>k.fold.seed</code> are ignored. In <em>k</em>-fold
cross-validation, the data specified in <code>data</code> is randomly
partitioned into <em>k</em> equal sized subsamples. Of the <em>k</em> subsamples, 
<em>k</em> - 1 subsamples are used to fit the model and the remaining <em>k</em>
samples are used for prediction. The cross-validation process is repeated 
<em>k</em> times (the folds). As a scoring rule, we use the model deviance 
as described in Hooten and Hobbs (2015). For cross-validation in multi-season
models, the data are split along the site dimension, such that each hold-out
data set consists of <code>J / k.fold</code> sites sampled over all primary time
periods during which data are available at each given site. Cross-validation is performed
after the full model is fit using all the data. Cross-validation results
are reported in the <code>k.fold.deviance</code> object in the return list.</p>
</td></tr>
<tr><td><code id="tPGOcc_+3A_k.fold.threads">k.fold.threads</code></td>
<td>
<p>number of threads to use for cross-validation. If 
<code>k.fold.threads &gt; 1</code> parallel processing is accomplished using the 
<span class="pkg">foreach</span> and <span class="pkg">doParallel</span> packages. Ignored if <code>k.fold</code>
is not specified.</p>
</td></tr> 
<tr><td><code id="tPGOcc_+3A_k.fold.seed">k.fold.seed</code></td>
<td>
<p>seed used to split data set into <code>k.fold</code> parts
for k-fold cross-validation. Ignored if <code>k.fold</code> is not specified.</p>
</td></tr>
<tr><td><code id="tPGOcc_+3A_k.fold.only">k.fold.only</code></td>
<td>
<p>a logical value indicating whether to only perform 
cross-validation (<code>TRUE</code>) or perform cross-validation after fitting 
the full model (<code>FALSE</code>). Default value is <code>FALSE</code>.</p>
</td></tr> 
<tr><td><code id="tPGOcc_+3A_...">...</code></td>
<td>
<p>currently no additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>tPGOcc</code> that is a list comprised of: 
</p>
<table>
<tr><td><code>beta.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the occupancy regression coefficients.</p>
</td></tr>
<tr><td><code>alpha.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the detection regression coefficients.</p>
</td></tr>
<tr><td><code>z.samples</code></td>
<td>
<p>a three-dimensional array of posterior samples 
for the latent occupancy values, with dimensions corresponding to 
posterior sample, site, and primary time period. Note this object
will contain predicted occupancy values for sites/primary time periods
that were not sampled.</p>
</td></tr>
<tr><td><code>psi.samples</code></td>
<td>
<p>a three-dimensional array of posterior samples
for the latent occupancy probability values, with dimensions 
corresponding to posterior sample, site, and primary time period. Note
this object will contain predicted occupancy probabilities for
sites/primary time periods that were not sampled.</p>
</td></tr>
<tr><td><code>sigma.sq.psi.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for variances of random intercepts included in the occupancy portion
of the model. Only included if random intercepts are specified in 
<code>occ.formula</code>.</p>
</td></tr>
<tr><td><code>sigma.sq.p.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for variances of random intercpets included in the detection portion 
of the model. Only included if random intercepts are specified in 
<code>det.formula</code>.</p>
</td></tr>
<tr><td><code>beta.star.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the occurrence random effects. Only included if random intercepts
are specified in <code>occ.formula</code>.</p>
</td></tr>
<tr><td><code>alpha.star.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the detection random effects. Only included if random intercepts 
are specified in <code>det.formula</code>.</p>
</td></tr>
<tr><td><code>theta.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples for the 
AR(1) variance (<code>sigma.sq.t</code>) and correlation (<code>rho</code>) 
parameters. Only included if <code>ar1 = TRUE</code>.</p>
</td></tr>
<tr><td><code>eta.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples for the 
AR(1) random effects for each primary time period. Only included if 
<code>ar1 = TRUE</code>.</p>
</td></tr>
<tr><td><code>like.samples</code></td>
<td>
<p>a three-dimensional array of posterior samples
for the likelihood values associated with each site and primary
time period. Used for calculating WAIC.</p>
</td></tr>
<tr><td><code>rhat</code></td>
<td>
<p>a list of Gelman-Rubin diagnostic values for some of the model
parameters.</p>
</td></tr>
<tr><td><code>ESS</code></td>
<td>
<p>a list of effective sample sizes for some of the model parameters.</p>
</td></tr>
<tr><td><code>run.time</code></td>
<td>
<p>execution time reported using <code>proc.time()</code>.</p>
</td></tr>
<tr><td><code>k.fold.deviance</code></td>
<td>
<p>scoring rule (deviance) from k-fold cross-validation. 
Only included if <code>k.fold</code> is specified in function call.</p>
</td></tr>
</table>
<p>The return object will include additional objects used for 
subsequent prediction and/or model fit evaluation. Note that detection
probability estimated values are not included in the model object, but can be 
extracted using <code>fitted()</code>. Note that if <code>k.fold.only = TRUE</code>, the 
return list object will only contain <code>run.time</code> and <code>k.fold.deviance</code>. 
</p>


<h3>Note</h3>

<p>Some of the underlying code used for generating random numbers from the
Polya-Gamma distribution is taken from the <span class="pkg">pgdraw</span> package written
by Daniel F. Schmidt and Enes Makalic. Their code implements Algorithm
6 in PhD thesis of Jesse Bennett Windle (2013) <a href="https://repositories.lib.utexas.edu/handle/2152/21842">https://repositories.lib.utexas.edu/handle/2152/21842</a>.
</p>


<h3>Author(s)</h3>

<p>Jeffrey W. Doser <a href="mailto:doserjef@msu.edu">doserjef@msu.edu</a>, <br />
Andrew O. Finley <a href="mailto:finleya@msu.edu">finleya@msu.edu</a>
</p>


<h3>References</h3>

<p>Polson, N.G., J.G. Scott, and J. Windle. (2013) Bayesian Inference for
Logistic Models Using Polya-Gamma Latent Variables. 
<em>Journal of the American Statistical Association</em>, 108:1339-1349.
</p>
<p>Bates, Douglas, Martin Maechler, Ben Bolker, Steve Walker (2015).
Fitting Linear Mixed-Effects Models Using lme4. Journal of
Statistical Software, 67(1), 1-48. <a href="https://doi.org/10.18637/jss.v067.i01">doi:10.18637/jss.v067.i01</a>.
</p>
<p>Kery, M., &amp; Royle, J. A. (2021). Applied hierarchical modeling in ecology: 
Analysis of distribution, abundance and species richness in R and BUGS: 
Volume 2: Dynamic and advanced models. Academic Press. Section 4.6.
</p>
<p>Hooten, M. B., and Hobbs, N. T. (2015). A guide to Bayesian model 
selection for ecologists. Ecological monographs, 85(1), 3-28.
</p>
<p>MacKenzie, D. I., J. D. Nichols, G. B. Lachman, S. Droege, 
J. Andrew Royle, and C. A. Langtimm. 2002. Estimating Site Occupancy 
Rates When Detection Probabilities Are Less Than One. Ecology 83: 2248-2255.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(500)
# Sites
J.x &lt;- 10
J.y &lt;- 10
J &lt;- J.x * J.y
# Primary time periods
n.time &lt;- sample(5:10, J, replace = TRUE)
n.time.max &lt;- max(n.time)
# Replicates
n.rep &lt;- matrix(NA, J, max(n.time))
for (j in 1:J) {
  n.rep[j, 1:n.time[j]] &lt;- sample(1:4, n.time[j], replace = TRUE)
}
# Occurrence --------------------------
beta &lt;- c(0.4, 0.5, -0.9)
trend &lt;- TRUE 
sp.only &lt;- 0
psi.RE &lt;- list()
# Detection ---------------------------
alpha &lt;- c(-1, 0.7, -0.5)
p.RE &lt;- list()
# Temporal parameters -----------------
rho &lt;- 0.7
sigma.sq.t &lt;- 0.6

# Get all the data
dat &lt;- simTOcc(J.x = J.x, J.y = J.y, n.time = n.time, n.rep = n.rep, 
               beta = beta, alpha = alpha, sp.only = sp.only, trend = trend, 
               psi.RE = psi.RE, p.RE = p.RE, sp = FALSE, ar1 = TRUE, 
               sigma.sq.t = sigma.sq.t, rho = rho)

# Package all data into a list
# Occurrence
occ.covs &lt;- list(int = dat$X[, , 1], 
                 trend = dat$X[, , 2], 
                 occ.cov.1 = dat$X[, , 3]) 
# Detection
det.covs &lt;- list(det.cov.1 = dat$X.p[, , , 2], 
                 det.cov.2 = dat$X.p[, , , 3]) 
# Data list bundle
data.list &lt;- list(y = dat$y, 
                  occ.covs = occ.covs,
                  det.covs = det.covs) 
# Priors
prior.list &lt;- list(beta.normal = list(mean = 0, var = 2.72), 
                   alpha.normal = list(mean = 0, var = 2.72), 
                   rho.unif = c(-1, 1), 
                   sigma.sq.t.ig = c(2, 0.5))

# Starting values
z.init &lt;- apply(dat$y, c(1, 2), function(a) as.numeric(sum(a, na.rm = TRUE) &gt; 0))
inits.list &lt;- list(beta = 0, alpha = 0, z = z.init)

# Tuning
tuning.list &lt;- list(rho = 0.5)

n.batch &lt;- 20
batch.length &lt;- 25
n.samples &lt;- n.batch * batch.length
n.burn &lt;- 100
n.thin &lt;- 1

# Run the model
out &lt;- tPGOcc(occ.formula = ~ trend + occ.cov.1, 
              det.formula = ~ det.cov.1 + det.cov.2, 
              data = data.list,
              inits = inits.list,
              priors = prior.list, 
              tuning = tuning.list,
              n.batch = n.batch, 
              batch.length = batch.length,
              verbose = TRUE, 
              ar1 = TRUE,
              n.report = 25,
              n.burn = n.burn, 
              n.thin = n.thin,
              n.chains = 1) 

summary(out)
</code></pre>

<hr>
<h2 id='updateMCMC'>Update a spOccupancy or spAbundance model run with more MCMC iterations</h2><span id='topic+updateMCMC'></span>

<h3>Description</h3>

<p>Function for updating a previously run spOccupancy or spAbundance model with 
additional MCMC iterations. This function is useful for situations where a model
is run for a long time but convergence/adequate mixing of the MCMC chains is not 
reached. Instead of re-running the entire model again, this function allows you 
to pick up where you left off. This function is currently in development, and only currently works 
with the following spOccupancy and spAbundance model objects: msAbund and sfJSDM. Note that
cross-validation is not possible when updating the model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>updateMCMC(object, n.batch, n.samples, n.burn = 0, n.thin, 
           keep.orig = TRUE, verbose = TRUE, n.report = 100, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="updateMCMC_+3A_object">object</code></td>
<td>
<p>a <code>spOccupancy</code> or <code>spAbundance</code> model object. Currently 
supports objects of class <code>msAbund</code> and <code>sfJSDM</code>.</p>
</td></tr>
<tr><td><code id="updateMCMC_+3A_n.batch">n.batch</code></td>
<td>
<p>the number of additional MCMC batches in each chain 
to run for the adaptive MCMC sampler. Only valid for model types fit with 
an adaptive MCMC sampler</p>
</td></tr>
<tr><td><code id="updateMCMC_+3A_n.samples">n.samples</code></td>
<td>
<p>the number of posterior samples to collect in each chain. Only 
valid for model types that are run with a fully Gibbs sampler and have 
<code>n.samples</code> as an argument in the original model fitting function.</p>
</td></tr>
<tr><td><code id="updateMCMC_+3A_n.burn">n.burn</code></td>
<td>
<p>the number of samples out of the total <code>n.batch * batchlength</code> to 
discard as burn-in for each chain from the updated samples. Note this argument
does not discard samples from the previous model run, and rather only applies
to the samples in the updated run of the model. Defaults to 0</p>
</td></tr>
<tr><td><code id="updateMCMC_+3A_n.thin">n.thin</code></td>
<td>
<p>the thinning interval for collection of MCMC samples in 
the updated model run. The thinning occurs after the <code>n.burn</code> 
samples are discarded. Default value is set to 1.</p>
</td></tr>
<tr><td><code id="updateMCMC_+3A_keep.orig">keep.orig</code></td>
<td>
<p>A logical value indicating whether or not the samples from 
the original run of the model should be kept or discarded.</p>
</td></tr>
<tr><td><code id="updateMCMC_+3A_verbose">verbose</code></td>
<td>
<p>if <code>TRUE</code>, messages about data preparation, 
model specification, and progress of the sampler are printed to the screen. 
Otherwise, no messages are printed.</p>
</td></tr>
<tr><td><code id="updateMCMC_+3A_n.report">n.report</code></td>
<td>
<p>the interval to report Metropolis sampler acceptance and
MCMC progress.</p>
</td></tr>
<tr><td><code id="updateMCMC_+3A_...">...</code></td>
<td>
<p>currently no additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of the same class as the original model fit provided in the <code>argument</code> object. See the manual page for the original model type for complete details.
</p>


<h3>Author(s)</h3>

<p>Jeffrey W. Doser <a href="mailto:doserjef@msu.edu">doserjef@msu.edu</a>, <br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>J.x &lt;- 8
J.y &lt;- 8
J &lt;- J.x * J.y
n.rep&lt;- sample(2:4, size = J, replace = TRUE)
N &lt;- 6
# Community-level covariate effects
# Occurrence
beta.mean &lt;- c(0.2)
p.occ &lt;- length(beta.mean)
tau.sq.beta &lt;- c(0.6)
# Detection
alpha.mean &lt;- c(0)
tau.sq.alpha &lt;- c(1)
p.det &lt;- length(alpha.mean)
# Random effects
psi.RE &lt;- list()
p.RE &lt;- list()
# Draw species-level effects from community means.
beta &lt;- matrix(NA, nrow = N, ncol = p.occ)
alpha &lt;- matrix(NA, nrow = N, ncol = p.det)
for (i in 1:p.occ) {
  beta[, i] &lt;- rnorm(N, beta.mean[i], sqrt(tau.sq.beta[i]))
}
for (i in 1:p.det) {
  alpha[, i] &lt;- rnorm(N, alpha.mean[i], sqrt(tau.sq.alpha[i]))
}
alpha.true &lt;- alpha
n.factors &lt;- 3
phi &lt;- rep(3 / .7, n.factors)
sigma.sq &lt;- rep(2, n.factors)
nu &lt;- rep(2, n.factors)

dat &lt;- simMsOcc(J.x = J.x, J.y = J.y, n.rep = n.rep, N = N, beta = beta, alpha = alpha,
                psi.RE = psi.RE, p.RE = p.RE, sp = TRUE, sigma.sq = sigma.sq,
                phi = phi, nu = nu, cov.model = 'matern', factor.model = TRUE,
                n.factors = n.factors)

pred.indx &lt;- sample(1:J, round(J * .25), replace = FALSE)
y &lt;- dat$y[, -pred.indx, , drop = FALSE]
# Occupancy covariates
X &lt;- dat$X[-pred.indx, , drop = FALSE]
coords &lt;- as.matrix(dat$coords[-pred.indx, , drop = FALSE])
# Prediction covariates
X.0 &lt;- dat$X[pred.indx, , drop = FALSE]
coords.0 &lt;- as.matrix(dat$coords[pred.indx, , drop = FALSE])
# Detection covariates
X.p &lt;- dat$X.p[-pred.indx, , , drop = FALSE]

y &lt;- apply(y, c(1, 2), max, na.rm = TRUE)
data.list &lt;- list(y = y, coords = coords)
# Priors
prior.list &lt;- list(beta.comm.normal = list(mean = 0, var = 2.72),
                   tau.sq.beta.ig = list(a = 0.1, b = 0.1),
                   nu.unif = list(0.5, 2.5))
# Starting values
inits.list &lt;- list(beta.comm = 0,
                   beta = 0,
                   fix = TRUE,
                   tau.sq.beta = 1)
# Tuning
tuning.list &lt;- list(phi = 1, nu = 0.25)

batch.length &lt;- 25
n.batch &lt;- 2
n.report &lt;- 100
formula &lt;- ~ 1

out &lt;- sfJSDM(formula = formula,
              data = data.list,
              inits = inits.list,
              n.batch = n.batch,
              batch.length = batch.length,
              accept.rate = 0.43,
              priors = prior.list,
              cov.model = "matern",
              tuning = tuning.list,
              n.factors = 3,
              n.omp.threads = 1,
              verbose = TRUE,
              NNGP = TRUE,
              n.neighbors = 5,
              search.type = 'cb',
              n.report = 10,
              n.burn = 0,
              n.thin = 1,
              n.chains = 2)
summary(out)

# Update the initial model fit
out.new &lt;- updateMCMC(out, n.batch = 1, keep.orig = TRUE, 
		     verbose = TRUE, n.report = 1) 
summary(out.new)
</code></pre>

<hr>
<h2 id='waicOcc'>Compute Widely Applicable Information Criterion for spOccupancy Model Objects</h2><span id='topic+waicOcc'></span>

<h3>Description</h3>

<p>Function for computing the Widely Applicable Information Criterion 
(WAIC; Watanabe 2010) for <code>spOccupancy</code> model objects. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>waicOcc(object, by.sp = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="waicOcc_+3A_object">object</code></td>
<td>
<p>an object of class <code>PGOcc</code>, <code>spPGOcc</code>, <code>msPGOcc</code>, 
<code>spMsPGOcc</code>, <code>intPGOcc</code>, <code>spIntPGOcc</code>, <code>lfJSDM</code>, 
<code>sfJSDM</code>, <code>lfMsPGOcc</code>, <code>sfMsPGOcc</code>, <code>tPGOcc</code>, <code>stPGOcc</code>, 
<code>svcPGBinom</code>, <code>svcPGOcc</code>, <code>svcTPGBinom</code>, <code>svcTPGOcc</code>, or 
<code>intMsPGOcc</code>, <code>svcMsPGOcc</code>, <code>tMsPGOcc</code>, <code>stMsPGOcc</code>, 
<code>svcTMsPGOcc</code>.</p>
</td></tr>
<tr><td><code id="waicOcc_+3A_by.sp">by.sp</code></td>
<td>
<p>a logical value indicating whether to return a separate WAIC
value for each species in a multi-species occupancy model or 
a single value for all species.</p>
</td></tr>
<tr><td><code id="waicOcc_+3A_...">...</code></td>
<td>
<p>currently no additional arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The effective number of parameters is calculated following the recommendations
of Gelman et al. (2014). Note that when fitting multi-species occupancy models with the 
<code>range.ind</code> tag, it is not valid to use WAIC to compare a model that 
uses <code>range.ind</code> (i.e., restricts certain species to a subset of the locations)
with a model that does not use <code>range.ind</code> (i.e., assumes all species can occur at
all locations in the data set) or that uses different <code>range.ind</code> values.
</p>


<h3>Value</h3>

<p>When <code>object</code> is of class <code>PGOcc</code>, <code>spPGOcc</code>, <code>msPGOcc</code>, <code>spMsPGOcc</code>, <code>lfJSDM</code>, <code>sfJSDM</code>, <code>lfMsPGOcc</code>, <code>sfMsPGOcc</code>, <code>tPGOcc</code>, <code>stPGOcc</code>, <code>svcPGBinom</code>, <code>svcPGOcc</code>, <code>svcTPGOcc</code>, <code>svcTPGBinom</code>, <code>svcMsPGOcc</code>, <code>tMsPGOcc</code>, <code>stMsPGOcc</code>, <code>svcTMsPGOcc</code> 
returns a vector with three elements corresponding to 
estimates of the expected log pointwise predictive density (elpd), the 
effective number of parameters (pD), and the WAIC. When <code>by.sp = TRUE</code> for multi-species models, object is a data frame with each row corresponding to a different species. When <code>object</code> is 
of class <code>intPGOcc</code> or <code>spIntPGOcc</code>, returns a data frame with 
columns elpd, pD, and WAIC, with each row corresponding to the estimated 
values for each data source in the integrated model.
</p>


<h3>Author(s)</h3>

<p>Jeffrey W. Doser <a href="mailto:doserjef@msu.edu">doserjef@msu.edu</a>, <br />
Andrew O. Finley <a href="mailto:finleya@msu.edu">finleya@msu.edu</a>
</p>


<h3>References</h3>

<p>Watanabe, S. (2010). Asymptotic equivalence of Bayes cross
validation and widely applicable information criterion in 
singular learning theory. <em>Journal of Machine Learning Research</em>, 
11:3571-3594.
</p>
<p>Gelman, A., J. B. Carlin, H. S. Stern, D. B. Dunson, A. Vehtari, 
and D. B. Rubin. (2013). Bayesian Data Analysis. 3rd edition. 
CRC Press, Taylor and Francis Group
</p>
<p>Gelman, A., J. Hwang, and A. Vehtari (2014). Understanding predictive
information criteria for Bayesian models. <em>Statistics and Computing</em>, 
24:997-1016.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(400)
# Simulate Data -----------------------------------------------------------
J.x &lt;- 8
J.y &lt;- 8
J &lt;- J.x * J.y
n.rep &lt;- sample(2:4, J, replace = TRUE)
beta &lt;- c(0.5, -0.15)
p.occ &lt;- length(beta)
alpha &lt;- c(0.7, 0.4)
p.det &lt;- length(alpha)
dat &lt;- simOcc(J.x = J.x, J.y = J.y, n.rep = n.rep, beta = beta, alpha = alpha,
              sp = FALSE)
occ.covs &lt;- dat$X[, 2, drop = FALSE]
colnames(occ.covs) &lt;- c('occ.cov')
det.covs &lt;- list(det.cov = dat$X.p[, , 2])
# Data bundle
data.list &lt;- list(y = dat$y,
                  occ.covs = occ.covs,
                  det.covs = det.covs)

# Priors
prior.list &lt;- list(beta.normal = list(mean = rep(0, p.occ),
                                      var = rep(2.72, p.occ)),
                   alpha.normal = list(mean = rep(0, p.det),
                                       var = rep(2.72, p.det)))
# Initial values
inits.list &lt;- list(alpha = rep(0, p.det),
                   beta = rep(0, p.occ),
                   z = apply(data.list$y, 1, max, na.rm = TRUE))

n.samples &lt;- 5000
n.report &lt;- 1000

out &lt;- PGOcc(occ.formula = ~ occ.cov,
             det.formula = ~ det.cov,
             data = data.list,
             inits = inits.list,
             n.samples = n.samples,
             priors = prior.list,
             n.omp.threads = 1,
             verbose = TRUE,
             n.report = n.report, 
             n.burn = 4000, 
             n.thin = 1)

# Calculate WAIC
waicOcc(out)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
