<!DOCTYPE html><html><head><title>Help for package GeNetIt</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {GeNetIt}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#adj_matrix'><p>Binary adjacency matrix</p></a></li>
<li><a href='#area.graph.statistics'><p>Statistics for edges (lines) based on a defined scale (area).</p></a></li>
<li><a href='#build.node.data'><p>Build node data</p></a></li>
<li><a href='#compare.models'><p>Compare gravity models</p></a></li>
<li><a href='#covariates'><p>Subset of raster data for Columbia spotted frog (Rana luteiventris)</p></a></li>
<li><a href='#dmatrix.df'><p>Distance matrix to data.frame</p></a></li>
<li><a href='#dps'><p>dps genetic distance matrix for Columbia spotted frog (Rana luteiventris)</p></a></li>
<li><a href='#flow'><p>Convert distance to flow</p></a></li>
<li><a href='#graph.metrics'><p>Graph Metrics</p></a></li>
<li><a href='#graph.statistics'><p>Statistics for edges (lines)</p></a></li>
<li><a href='#gravity'><p>Gravity model</p></a></li>
<li><a href='#gravity.es'><p>Effect Size</p></a></li>
<li><a href='#knn.graph'><p>Saturated or K Nearest Neighbor Graph</p></a></li>
<li><a href='#node.statistics'><p>raster statistics for nodes</p></a></li>
<li><a href='#plot.gravity'><p>Plot gravity model</p></a></li>
<li><a href='#predict.gravity'><p>Predict gravity model</p></a></li>
<li><a href='#print.gravity'><p>Print gravity model</p></a></li>
<li><a href='#ralu.model'><p>Columbia spotted frog (Rana luteiventris) data for specifying gravity model. Note, the data.frame is already log transformed.</p></a></li>
<li><a href='#ralu.site'><p>Subset of site-level spatial point data for Columbia spotted frog (Rana luteiventris)</p></a></li>
<li><a href='#summary.gravity'><p>Summarizing Gravity Model Fits</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Spatial Graph-Theoretic Genetic Gravity Modelling</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1-6</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-06-04</td>
</tr>
<tr>
<td>Description:</td>
<td>Implementation of spatial graph-theoretic genetic gravity models.
    The model framework is applicable for other types of spatial flow questions.
    Includes functions for constructing spatial graphs, sampling and summarizing
    associated raster variables and building unconstrained and singly constrained
    gravity models.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.2.0), nlme</td>
</tr>
<tr>
<td>Imports:</td>
<td>exactextractr, terra, sf, sfnetworks, igraph, dplyr,
tidygraph, spdep</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Jeffrey S. Evans &lt;jeffrey_evans@tnc.org&gt;</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/jeffreyevans/GeNetIt">https://github.com/jeffreyevans/GeNetIt</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-06-14 16:33:13 UTC; jeffrey_evans</td>
</tr>
<tr>
<td>Author:</td>
<td>Jeffrey S. Evans [aut, cre],
  Melanie Murphy [aut]</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-06-15 00:02:12 UTC</td>
</tr>
</table>
<hr>
<h2 id='adj_matrix'>Binary adjacency matrix</h2><span id='topic+adj_matrix'></span>

<h3>Description</h3>

<p>Creates a binary matrix of adjacencies based on 
from-to graph relationships (joins)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>adj_matrix(i, j = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="adj_matrix_+3A_i">i</code></td>
<td>
<p>a vector or, if j = NULL a data.frame with two 
columns indicating from-to relationships (joins)</p>
</td></tr>
<tr><td><code id="adj_matrix_+3A_j">j</code></td>
<td>
<p>If specified, i must be a vector of same length and
the i,j vectors must represent joins</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A binary matrix
</p>


<h3>Author(s)</h3>

<p>Jeffrey S. Evans  &lt;jeffrey_evans@tnc.org&gt; and 
Melanie A. Murphy &lt;melanie.murphy@uwyo.edu&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'> library(sf)
   data(ralu.site, package="GeNetIt")
   
 p &lt;- as(ralu.site, "sf")
 g &lt;- knn.graph(p[c(1,5,8,10,20,31),])
   plot(st_geometry(g))

 ( ind &lt;- sf::st_drop_geometry(g[,1:2])[1:10,] ) 

 adj_matrix(ind)

 adj_matrix(g$i[1:10], g$j[1:10])

</code></pre>

<hr>
<h2 id='area.graph.statistics'>Statistics for edges (lines) based on a defined scale (area).</h2><span id='topic+area.graph.statistics'></span>

<h3>Description</h3>

<p>Samples rasters for each edge and calculates specified 
statistics for buffer distance
</p>


<h3>Usage</h3>

<pre><code class='language-R'>area.graph.statistics(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="area.graph.statistics_+3A_...">...</code></td>
<td>
<p>Parameters to be passed to the modern version of the function</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Please note that this function has been deprecated, please use graph.statistics 
with the buffer argument.
</p>

<hr>
<h2 id='build.node.data'>Build node data</h2><span id='topic+build.node.data'></span>

<h3>Description</h3>

<p>Helper function to build the origin/destination node data structure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>build.node.data(x, group.ids, from.parms, to.parms = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="build.node.data_+3A_x">x</code></td>
<td>
<p>A data.frame containing node (site) data</p>
</td></tr>
<tr><td><code id="build.node.data_+3A_group.ids">group.ids</code></td>
<td>
<p>Character vector of unique identifier that can be used to join 
to graph</p>
</td></tr>
<tr><td><code id="build.node.data_+3A_from.parms">from.parms</code></td>
<td>
<p>Character vector of independent &quot;from&quot; variables</p>
</td></tr>
<tr><td><code id="build.node.data_+3A_to.parms">to.parms</code></td>
<td>
<p>Character vector of independent &quot;to&quot; variables. If NULL is 
the same as from.parms</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.frame
</p>


<h3>Note</h3>

<p>Unless a different set of parameters will be used as the destination (to) there 
is no need to define the argument &quot;to.parms&quot; and the &quot;from.parm&quot; will be used to 
define both set of parameters.
</p>
<p>The resulting data.frame represents the origin (from) and destination (to) data 
structure for use in gravity model. This is node structure is also know in the 
gravity literature as producer (from) and attractor (to).
</p>


<h3>Author(s)</h3>

<p>Jeffrey S. Evans  &lt;jeffrey_evans@tnc.org&gt; and 
Melanie A. Murphy &lt;melanie.murphy@uwyo.edu&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ralu.site)

# Build from/to site (node) level data structure 
site.parms = c("AREA_m2", "PERI_m", "Depth_m", "TDS")
site &lt;- build.node.data(sf::st_drop_geometry(ralu.site), 
                        group.ids = c("SiteName"), 
                        from.parms = site.parms ) 
 
</code></pre>

<hr>
<h2 id='compare.models'>Compare gravity models</h2><span id='topic+compare.models'></span>

<h3>Description</h3>

<p>Prints diagnostic statistics for comparing gravity models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compare.models(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compare.models_+3A_...">...</code></td>
<td>
<p>gravity model objects</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Results include model name, AIX, BIC, log likelihood, RMSE and number of parameters
</p>


<h3>Value</h3>

<p>data.frame of competing model statistics
</p>


<h3>Author(s)</h3>

<p>Jeffrey S. Evans  &lt;jeffrey_evans@tnc.org&gt; and 
Melanie A. Murphy &lt;melanie.murphy@uwyo.edu&gt;
</p>


<h3>References</h3>

<p>Murphy M.A., R. Dezzani, D.S. Pilliod &amp; A.S. Storfer (2010) Landscape genetics of 
high mountain frog metapopulations. Molecular Ecology 19(17):3634-3649
</p>


<h3>Examples</h3>

<pre><code class='language-R'> 
library(nlme)
  data(ralu.model)

x = c("DEPTH_F", "HLI_F", "CTI_F", "cti", "ffp")
( null &lt;-  gravity(y = "DPS", x = c("DISTANCE"), d = "DISTANCE",  
                   group = "FROM_SITE", data = ralu.model, fit.method = "ML") )
( gm_h1 &lt;- gravity(y = "DPS", x = x, d = "DISTANCE", group = "FROM_SITE", 
                   data = ralu.model, ln = FALSE, fit.method="ML") ) 
( gm_h2 &lt;- gravity(y = "DPS", x = x[1:3], d = "DISTANCE", group = "FROM_SITE", 
                   data = ralu.model, ln = FALSE, fit.method="ML") ) 
( gm_h3 &lt;- gravity(y = "DPS", x = x[c(4:5)], d = "DISTANCE", group = "FROM_SITE", 
                   data = ralu.model, ln = FALSE, fit.method="ML") ) 
#( gm_h4 &lt;- gravity(y = "DPS", x = x[c(4:5)], d = "DISTANCE", group = "FROM_SITE", 
#                   data = ralu.model, ln = FALSE, fit.method="REML") ) 

compare.models(null, gm_h1, gm_h2, gm_h3)

</code></pre>

<hr>
<h2 id='covariates'>Subset of raster data for Columbia spotted frog (Rana luteiventris)</h2><span id='topic+covariates'></span>

<h3>Description</h3>

<p>Subset of data used in Murphy et al., (2010)
</p>


<h3>Format</h3>

<p>A 30m LZW compressed tiff:
</p>

<dl>
<dt>rows</dt><dd><p>426</p>
</dd>
<dt>columns</dt><dd><p>358</p>
</dd>
<dt>resoultion</dt><dd><p>30 meter</p>
</dd>
<dt>projection</dt><dd><p>&quot;+proj=utm +zone=11 +datum=NAD83 +units=m +no_defs +ellps=GRS80 +towgs84=0,0,0&quot;</p>
</dd>
<dt>cti</dt><dd><p>Compound Topographic Index (&quot;wetness&quot;)</p>
</dd>
<dt>err27</dt><dd><p>Elevation Relief Ratio</p>
</dd>
<dt>ffp</dt><dd><p>Frost Free Period</p>
</dd>
<dt>gsp</dt><dd><p>Growing Season Precipitation</p>
</dd>
<dt>hil</dt><dd><p>Heat Load Index</p>
</dd>
<dt>nlcd</dt><dd><p>USGS Landcover</p>
</dd>
</dl>



<h3>References</h3>

<p>Murphy M.A., R. Dezzani, D.S. Pilliod &amp; A.S. Storfer (2010) Landscape genetics of high mountain frog metapopulations. Molecular Ecology 19(17):3634-3649
</p>

<hr>
<h2 id='dmatrix.df'>Distance matrix to data.frame</h2><span id='topic+dmatrix.df'></span>

<h3>Description</h3>

<p>Coerces distance matrix to a data.frame object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dmatrix.df(x, rm.diag = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dmatrix.df_+3A_x">x</code></td>
<td>
<p>Symmetrical distance matrix</p>
</td></tr>
<tr><td><code id="dmatrix.df_+3A_rm.diag">rm.diag</code></td>
<td>
<p>(TRUE/FALSE) remove matrix diagonal, self values.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.frame object representing to and from values
</p>


<h3>Note</h3>

<p>Function results in data.frame object with &quot;X1&quot; (FROM), &quot;X2&quot; (TO) and 
&quot;distance&quot; columns. The FROM column represents to origin ID, TO represents 
destination ID and distance is the associated matrix distance. These 
results can be joined back to the graph object using either the origin or 
destination ID's.
</p>


<h3>Author(s)</h3>

<p>Jeffrey S. Evans  &lt;jeffrey_evans@tnc.org&gt; and 
Melanie A. Murphy &lt;melanie.murphy@uwyo.edu&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'> library(sf)
 pts &lt;- data.frame(ID=paste0("ob",1:15), x=runif(15, 480933, 504250), 
                   y=runif(15, 4479433, 4535122))
   pts &lt;- st_as_sf(pts, coords = c("x", "y"), 
                   crs = 32611, agr = "constant") 
 
 # Create distance matrix  
 dm &lt;- st_distance(pts)
   class(dm) &lt;- setdiff(class(dm), "units")  
     attr(dm, "units") &lt;- NULL
   colnames(dm) &lt;- pts$ID 
   rownames(dm) &lt;- pts$ID
 
 # Coerce to data.frame with TO and FROM ID's and associated distance
 dm.df &lt;- dmatrix.df(dm)
   head(dm.df)

</code></pre>

<hr>
<h2 id='dps'>dps genetic distance matrix for Columbia spotted frog (Rana luteiventris)</h2><span id='topic+dps'></span>

<h3>Description</h3>

<p>Subset of data used in Murphy et al., (2010)
</p>


<h3>Format</h3>

<p>A 29 x 29 genetic distance matrix:
</p>


<h3>References</h3>

<p>Murphy M.A., R. Dezzani, D.S. Pilliod &amp; A.S. Storfer (2010) Landscape genetics of high mountain frog metapopulations. Molecular Ecology 19(17):3634-3649
</p>

<hr>
<h2 id='flow'>Convert distance to flow</h2><span id='topic+flow'></span>

<h3>Description</h3>

<p>Converts distance to flow (1-d) with or without data standardization
</p>


<h3>Usage</h3>

<pre><code class='language-R'>flow(x, standardize = FALSE, rm.na = FALSE, diag.value = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="flow_+3A_x">x</code></td>
<td>
<p>A numeric vector or matrix object representing distances</p>
</td></tr>
<tr><td><code id="flow_+3A_standardize">standardize</code></td>
<td>
<p>(FALSE/TRUE) Row-standardize the data before calculating flow</p>
</td></tr>
<tr><td><code id="flow_+3A_rm.na">rm.na</code></td>
<td>
<p>(TRUE/FALSE) Should NA's be removed, if FALSE (default) the 
will be retained in the results</p>
</td></tr>
<tr><td><code id="flow_+3A_diag.value">diag.value</code></td>
<td>
<p>If x is a matrix, what diagonal matrix values should be 
used (default is NA)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector or matrix representing flow values
</p>


<h3>Author(s)</h3>

<p>Jeffrey S. Evans  &lt;jeffrey_evans@tnc.org&gt; and 
Melanie A. Murphy &lt;melanie.murphy@uwyo.edu&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#### On a distance vector
flow(runif(10,0,1))
flow(runif(10,0,500), standardize = TRUE)

# With NA's
d &lt;- runif(10, 0,1)
  d[2] &lt;- NA
flow(d)
flow(d, rm.na=TRUE)

#### On a distance matrix
dm &lt;- as.matrix(dist(runif(5,0,1), diag = TRUE, upper = TRUE))
flow(dm)

</code></pre>

<hr>
<h2 id='graph.metrics'>Graph Metrics</h2><span id='topic+graph.metrics'></span>

<h3>Description</h3>

<p>Metrics on structural properties of graph (at nodes)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>graph.metrics(
  x,
  node.pts,
  node.name = NULL,
  direct = FALSE,
  metric = c("betweenness", "degree", "closeness")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="graph.metrics_+3A_x">x</code></td>
<td>
<p>knn graph object from GeNetIt::knn.graph (sf LINESTRING)</p>
</td></tr>
<tr><td><code id="graph.metrics_+3A_node.pts">node.pts</code></td>
<td>
<p>sf POINT or sp SpatialPointsDataFrame object used as nodes to build x</p>
</td></tr>
<tr><td><code id="graph.metrics_+3A_node.name">node.name</code></td>
<td>
<p>Column name in node.pts object that acts as the provides the unique ID.
If not defined, defaults to row.names of node.pts</p>
</td></tr>
<tr><td><code id="graph.metrics_+3A_direct">direct</code></td>
<td>
<p>(FALSE/TRUE) Evaluate directed graph</p>
</td></tr>
<tr><td><code id="graph.metrics_+3A_metric">metric</code></td>
<td>
<p>...</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Please note; graph metrics are not valid for a saturated graph (all connections)
</p>


<h3>Author(s)</h3>

<p>Jeffrey S. Evans  &lt;jeffrey_evans@tnc.org&gt; and 
Melanie A. Murphy &lt;melanie.murphy@uwyo.edu&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'> library(sf)
 data(ralu.site, package="GeNetIt")

 graph &lt;- knn.graph(ralu.site, row.names=ralu.site$SiteName, 
                   max.dist = 2500)
     plot(st_geometry(graph))

 ( m &lt;- graph.metrics(graph, ralu.site, "SiteName") )
 
  ralu.site &lt;- merge(ralu.site, m, by="SiteName")
    # plot node betweenness
    plot(st_geometry(graph), col="grey")
   plot(ralu.site["betweenness"], pch=19, cex=1.25, add=TRUE)
# plot node degree
    plot(st_geometry(graph), col="grey")
   plot(ralu.site["degree"], pch=19, cex=1.25, add=TRUE)	   

</code></pre>

<hr>
<h2 id='graph.statistics'>Statistics for edges (lines)</h2><span id='topic+graph.statistics'></span>

<h3>Description</h3>

<p>Extracts raster values for each edge and calculates specified statistics
</p>


<h3>Usage</h3>

<pre><code class='language-R'>graph.statistics(x, r, stats = c("min", "mean", "max"), buffer = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="graph.statistics_+3A_x">x</code></td>
<td>
<p>sp SpatialLinesDataFrame or sf LINE object</p>
</td></tr>
<tr><td><code id="graph.statistics_+3A_r">r</code></td>
<td>
<p>A terra SpatRast or raster rasterLayer, rasterStack, rasterBrick object</p>
</td></tr>
<tr><td><code id="graph.statistics_+3A_stats">stats</code></td>
<td>
<p>Statistics to calculate. If vectorized, can pass a custom 
statistic function.</p>
</td></tr>
<tr><td><code id="graph.statistics_+3A_buffer">buffer</code></td>
<td>
<p>Buffer distance, radius in projection units. For statistics 
based on edge buffer distance</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.frame object of statistics
</p>


<h3>Note</h3>

<p>If the buffer argument is specified that, raster values within the specified 
buffer radius are extracted and included in the derived statistic(s). Else-wise,
the statistics are derived from raster values that directly intersect each edge.
</p>


<h3>Author(s)</h3>

<p>Jeffrey S. Evans  &lt;jeffrey_evans@tnc.org&gt; and 
Melanie A. Murphy &lt;melanie.murphy@uwyo.edu&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
 library(sf)
 library(terra)  

 data(ralu.site)	
 xvars &lt;- rast(system.file("extdata/covariates.tif", package="GeNetIt"))
 
  ( dist.graph &lt;- knn.graph(ralu.site, row.names = ralu.site$SiteName, 
                            max.dist = 1500) )
 
 skew &lt;- function(x, na.rm = TRUE) {  
           if (na.rm) x &lt;- x[!is.na(x)]
           sum( (x - mean(x)) ^ 3) / ( length(x) * sd(x) ^ 3 )  
 		}

# Moments on continuous raster data
 system.time( {		
  stats &lt;- graph.statistics(dist.graph, r = xvars[[-6]],  
              stats = c("min", "median", "max", "var", "skew")) 
 } ) 

# Proportional function on nominal raster data		
p &lt;- function(x) { length(x[x &lt; 52]) / length(x) }	
	
  system.time( {		
   nstats &lt;- graph.statistics(dist.graph, r = xvars[[6]],
               stats = "p") 
  } ) 	

# Based on 500m buffer distance around line(s)
 system.time( {		
  stats &lt;- graph.statistics(dist.graph, r = xvars[[-6]],  
              stats = c("min", "median", "max", "var", "skew"),
			      buffer = 500) 
 } )



</code></pre>

<hr>
<h2 id='gravity'>Gravity model</h2><span id='topic+gravity'></span>

<h3>Description</h3>

<p>Implements Murphy et al., (2010) gravity model via a 
linear mixed effects model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gravity(
  y,
  x,
  d,
  group,
  data,
  fit.method = c("REML", "ML"),
  ln = TRUE,
  constrained = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gravity_+3A_y">y</code></td>
<td>
<p>Name of dependent variable</p>
</td></tr>
<tr><td><code id="gravity_+3A_x">x</code></td>
<td>
<p>Character vector of independent variables</p>
</td></tr>
<tr><td><code id="gravity_+3A_d">d</code></td>
<td>
<p>Name of column containing distance</p>
</td></tr>
<tr><td><code id="gravity_+3A_group">group</code></td>
<td>
<p>Name of grouping column (from or to)</p>
</td></tr>
<tr><td><code id="gravity_+3A_data">data</code></td>
<td>
<p>data.frame object containing model data</p>
</td></tr>
<tr><td><code id="gravity_+3A_fit.method">fit.method</code></td>
<td>
<p>Method used to fit model c(&quot;REML&quot;, &quot;ML&quot;)</p>
</td></tr>
<tr><td><code id="gravity_+3A_ln">ln</code></td>
<td>
<p>Natural log transform data (TRUE/FALSE)</p>
</td></tr>
<tr><td><code id="gravity_+3A_constrained">constrained</code></td>
<td>
<p>Specify constrained model, if FALSE a linear model (lm) 
is run (TRUE/FALSE)</p>
</td></tr>
<tr><td><code id="gravity_+3A_...">...</code></td>
<td>
<p>Additional argument passed to nlme or lm</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The &quot;group&quot; factor defines the singly constrained direction (from or to) and the 
grouping structure for the origins. To specify a null (distance only or IBD) 
model just omit the x argument. 
</p>
<p>By default constrained models are fit by maximizing the restricted log-likelihood 
(REML), for maximum likelihood use the type=&quot;ML&quot; argument which is passed to the 
lme function. If ln=TRUE the input data will be log transformed
</p>


<h3>Value</h3>

<p>formula           Model formula call
</p>
<p>fixed.formula     Model formula for fixed effects
</p>
<p>random.formula    Model formula for random (group) effects 
(only for constrained models)
</p>
<p>gravity           Gravity model
</p>
<p>fit               Model Fitted Values
</p>
<p>AIC               AIC value for selected model
</p>
<p>RMSE              Root Mean Squared Error (based on bias corrected back transform)
</p>
<p>log.likelihood    Restricted log-likelihood at convergence
</p>
<p>group.names       Column name of grouping variable
</p>
<p>groups            Values of grouping variable
</p>
<p>x                 data.frame of x variables
</p>
<p>y                 Vector of y variable
</p>
<p>constrained       TRUE/FALSE indicating if model is constrained
</p>


<h3>Note</h3>

<p>Depends: nlme, lattice
</p>


<h3>Author(s)</h3>

<p>Jeffrey S. Evans  &lt;jeffrey_evans@tnc.org&gt; and 
Melanie A. Murphy &lt;melanie.murphy@uwyo.edu&gt;
</p>


<h3>References</h3>

<p>Murphy, M. A. &amp; J.S. Evans. (in prep). GenNetIt: graph theoretical gravity modeling 
for landscape genetics
</p>
<p>Murphy M.A., R. Dezzani, D.S. Pilliod &amp; A.S. Storfer (2010) Landscape genetics of 
high mountain frog metapopulations. Molecular Ecology 19(17):3634-3649
</p>


<h3>See Also</h3>

<p><code><a href="nlme.html#topic+groupedData">groupedData</a></code> for how grouping works in constrained model
</p>
<p><code><a href="nlme.html#topic+lme">lme</a></code> for constrained model ... options
</p>
<p><code><a href="stats.html#topic+lm">lm</a></code> for linear model ... options
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(nlme)
data(ralu.model)

# Gravity model	
x = c("DEPTH_F", "HLI_F", "CTI_F", "cti", "ffp")
( gm &lt;- gravity(y = "DPS", x = x, d = "DISTANCE", group = "FROM_SITE", 
                data = ralu.model, ln = FALSE) )

#' # Plot gravity results
 par(mfrow=c(2,3))
   for (i in 1:6) { plot(gm, type=i) } 

# log likelihood of competing models 
 x = c("DEPTH_F", "HLI_F", "CTI_F", "cti", "ffp")
 for(i in x[-1]) {
   x1 = c(x[1], x[-which(x %in% i)])  
   ll &lt;- gravity(y = "DPS", x = x1, d = "DISTANCE", group = "FROM_SITE", 
                 data = ralu.model, ln = FALSE)$log.likelihood
  cat("log likelihood for parameter set:", "(",x1,")", "=", ll, "\n") 
 }

# Distance only (IBD) model
gravity(y = "DPS", d = "DISTANCE", group = "FROM_SITE", 
        data = ralu.model, ln = FALSE)

</code></pre>

<hr>
<h2 id='gravity.es'>Effect Size</h2><span id='topic+gravity.es'></span>

<h3>Description</h3>

<p>Cohen's D effect size for gravity models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gravity.es(x, actual.n = FALSE, alpha = 0.95)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gravity.es_+3A_x">x</code></td>
<td>
<p>gravity model object</p>
</td></tr>
<tr><td><code id="gravity.es_+3A_actual.n">actual.n</code></td>
<td>
<p>(FALSE/TRUE) Use actual N or degrees of freedom 
in calculating Confidence Interval</p>
</td></tr>
<tr><td><code id="gravity.es_+3A_alpha">alpha</code></td>
<td>
<p>confidence interval</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Calculate Cohen's D statistic for each effect in a gravity model object
</p>


<h3>Value</h3>

<p>data.frame of parameter effect size
</p>


<h3>Author(s)</h3>

<p>Jeffrey S. Evans  &lt;jeffrey_evans@tnc.org&gt; and 
Melanie A. Murphy &lt;melanie.murphy@uwyo.edu&gt;
</p>


<h3>References</h3>

<p>Murphy M.A., R. Dezzani, D.S. Pilliod &amp; A.S. Storfer (2010) Landscape genetics of 
high mountain frog metapopulations. Molecular Ecology 19(17):3634-3649
</p>
<p>Cohen, J. (1988) Statistical power for the behavioral sciences (2nd ed.). 
Hillsdale, NJ: Erlbaum
</p>


<h3>Examples</h3>

<pre><code class='language-R'> 
library(nlme)
  data(ralu.model)

x = c("DEPTH_F", "HLI_F", "CTI_F", "cti", "ffp")
gm_h1 &lt;- gravity(y = "DPS", x = x, d = "DISTANCE", group = "FROM_SITE", 
                data = ralu.model, ln = FALSE, method="ML") 

gravity.es(gm_h1)

</code></pre>

<hr>
<h2 id='knn.graph'>Saturated or K Nearest Neighbor Graph</h2><span id='topic+knn.graph'></span>

<h3>Description</h3>

<p>Creates a kNN or saturated graph SpatialLinesDataFrame object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>knn.graph(
  x,
  row.names = NULL,
  k = NULL,
  max.dist = NULL,
  long.lat = FALSE,
  drop.lower = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="knn.graph_+3A_x">x</code></td>
<td>
<p>sf POINTS object</p>
</td></tr>
<tr><td><code id="knn.graph_+3A_row.names">row.names</code></td>
<td>
<p>Unique row.names assigned to results</p>
</td></tr>
<tr><td><code id="knn.graph_+3A_k">k</code></td>
<td>
<p>K nearest neighbors, defaults to saturated (n(x) - 1)</p>
</td></tr>
<tr><td><code id="knn.graph_+3A_max.dist">max.dist</code></td>
<td>
<p>Maximum length of an edge (used for distance constraint)</p>
</td></tr>
<tr><td><code id="knn.graph_+3A_long.lat">long.lat</code></td>
<td>
<p>(FALSE/TRUE) Coordinates are longitude-latitude decimal degrees,
in which case distances are measured in kilometers</p>
</td></tr>
<tr><td><code id="knn.graph_+3A_drop.lower">drop.lower</code></td>
<td>
<p>(FALSE/TRUE) Drop lower triangle of matrix representing
duplicate edges ie, from-to and to-from</p>
</td></tr>
</table>


<h3>Value</h3>

<p>SpatialLinesDataFrame object with:
</p>

<ul>
<li><p> i        Name of column in x with FROM (origin) index
</p>
</li>
<li><p> j        Name of column in x with TO (destination) index
</p>
</li>
<li><p> from_ID  Name of column in x with FROM (origin) region ID
</p>
</li>
<li><p> to_ID    Name of column in x with TO (destination) region ID
</p>
</li>
<li><p> length   Length of each edge (line) in projection units or kilometers if not projected
</p>
</li></ul>



<h3>Note</h3>

<p>...
</p>


<h3>Author(s)</h3>

<p>Jeffrey S. Evans  <a href="mailto:jeffrey_evans@tnc.org">jeffrey_evans@tnc.org</a> and
Melanie A. Murphy <a href="mailto:melanie.murphy@uwyo.edu">melanie.murphy@uwyo.edu</a>
</p>


<h3>References</h3>

<p>Murphy, M. A. &amp; J.S. Evans. (in prep). &quot;GenNetIt: gravity analysis in R for landscape
genetics&quot;
</p>
<p>Murphy M.A., R. Dezzani, D.S. Pilliod &amp; A.S. Storfer (2010) Landscape genetics of
high mountain frog metapopulations. Molecular Ecology 19(17):3634-3649
</p>


<h3>Examples</h3>

<pre><code class='language-R'> library(sf)
   data(ralu.site, package="GeNetIt")

 # Saturated spatial graph
 sat.graph &lt;- knn.graph(ralu.site, row.names=ralu.site$SiteName)
   head(sat.graph)
 
 # Distanced constrained spatial graph
 dist.graph &lt;- knn.graph(ralu.site, row.names=ralu.site$SiteName, 
                         max.dist = 5000)

opar &lt;- par(no.readonly=TRUE)
 par(mfrow=c(1,2))	
plot(st_geometry(sat.graph), col="grey")
  points(st_coordinates(ralu.site), col="red", pch=20, cex=1.5)
     box()
     title("Saturated graph")	
plot(st_geometry(dist.graph), col="grey")
  points(st_coordinates(ralu.site), col="red", pch=20, cex=1.5)
     box()
     title("Distance constrained graph")
par(opar)	  
	
</code></pre>

<hr>
<h2 id='node.statistics'>raster statistics for nodes</h2><span id='topic+node.statistics'></span>

<h3>Description</h3>

<p>returns raster value or statistics 
(based on specified radius) for node
</p>


<h3>Usage</h3>

<pre><code class='language-R'>node.statistics(x, r, buffer = NULL, stats = c("min", "median", "max"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="node.statistics_+3A_x">x</code></td>
<td>
<p>sp class SpatialPointsDataFrame object</p>
</td></tr>
<tr><td><code id="node.statistics_+3A_r">r</code></td>
<td>
<p>A rasterLayer, rasterStack or rasterBrick object</p>
</td></tr>
<tr><td><code id="node.statistics_+3A_buffer">buffer</code></td>
<td>
<p>Buffer distance, radius in projection units</p>
</td></tr>
<tr><td><code id="node.statistics_+3A_stats">stats</code></td>
<td>
<p>Statistics to calculate. If vectorized, can pass a 
custom statistic function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.frame object of at-node raster values or statistics
</p>


<h3>Note</h3>

<p>If no buffer is specified, at-node raster values are returned
</p>


<h3>Author(s)</h3>

<p>Jeffrey S. Evans  &lt;jeffrey_evans@tnc.org&gt; and 
Melanie A. Murphy &lt;melanie.murphy@uwyo.edu&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
 library(sf)
 library(terra)  

 data(ralu.site)
 xvars &lt;- rast(system.file("extdata/covariates.tif", package="GeNetIt"))
   
 skew &lt;- function(x, na.rm = TRUE) {  
           if (na.rm) x &lt;- x[!is.na(x)]
           sum( (x - mean(x)) ^ 3) / ( length(x) * sd(x) ^ 3 )  
 		}

 # without buffer (values at point)
 system.time( {		
  stats &lt;- node.statistics(ralu.site, r = xvars[[-6]]) 
 } )

 # with 1000m buffer (values around points)
 system.time( {		
  stats &lt;- node.statistics(ralu.site, r = xvars[[-6]], buffer = 1000, 
              stats = c("min", "median", "max", "var", "skew")) 
 } ) 
 

</code></pre>

<hr>
<h2 id='plot.gravity'>Plot gravity model</h2><span id='topic+plot.gravity'></span>

<h3>Description</h3>

<p>Diagnostic plots gravity model with 6 optional plots.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gravity'
plot(x, type = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.gravity_+3A_x">x</code></td>
<td>
<p>Object of class gravity</p>
</td></tr>
<tr><td><code id="plot.gravity_+3A_type">type</code></td>
<td>
<p>Type of plot (default 1, model structure I)</p>
</td></tr>
<tr><td><code id="plot.gravity_+3A_...">...</code></td>
<td>
<p>Ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>defined plot
</p>


<h3>Note</h3>

<p>Plot types available: 1 - Model structure I, 2 - Model structure II, 3 - Q-Q Normal - Origin random effects, 4 - Q-Q Normal - Residuals , 5 - Fitted values, 6 - Distribution of observed verses predicted
</p>
<p>Depends: nlme, lattice
</p>


<h3>Author(s)</h3>

<p>Jeffrey S. Evans  &lt;jeffrey_evans@tnc.org&gt; and 
Melanie A. Murphy &lt;melanie.murphy@uwyo.edu&gt;
</p>


<h3>References</h3>

<p>Murphy, M. A. &amp; J.S. Evans. (in prep). &quot;GenNetIt: gravity analysis in R for landscape genetics&quot;
</p>
<p>Murphy M.A., R. Dezzani, D.S. Pilliod &amp; A.S. Storfer (2010) Landscape genetics of high mountain frog metapopulations. Molecular Ecology 19(17):3634-3649
</p>

<hr>
<h2 id='predict.gravity'>Predict gravity model</h2><span id='topic+predict.gravity'></span>

<h3>Description</h3>

<p>predict method for class &quot;gravity&quot;
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gravity'
predict(
  object,
  newdata,
  groups = NULL,
  back.transform = c("none", "simple", "Miller", "Naihua"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.gravity_+3A_object">object</code></td>
<td>
<p>Object of class gravity</p>
</td></tr>
<tr><td><code id="predict.gravity_+3A_newdata">newdata</code></td>
<td>
<p>New data used for obtaining the predictions, can
be a data.frame or nffGroupedData</p>
</td></tr>
<tr><td><code id="predict.gravity_+3A_groups">groups</code></td>
<td>
<p>Grouping factor acting as random effect. If used,
must match levels used in model, otherwise leave it
null and do not convert to groupedData</p>
</td></tr>
<tr><td><code id="predict.gravity_+3A_back.transform">back.transform</code></td>
<td>
<p>Method to back transform data, default is none and 
log predictions will be returned.</p>
</td></tr>
<tr><td><code id="predict.gravity_+3A_...">...</code></td>
<td>
<p>Arguments passed to predict.lme or predict.lm</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Please note that the entire gravity equation is log transformed so, 
your parameter space is on a log scale, not just y. This means that for 
a meaningful prediction the &quot;newdata&quot; also needs to be on a log scale.
</p>
<p>For the back.transform argument, the simple back-transform method uses the 
form exp(y-hat)0.5*variance whereas Miller uses exp(sigma)*0.5 as the 
multiplicative bias factor. Naihua regresses y~exp(y-hat) with no intercept 
and uses the resulting coefficient as the multiplicative bias factor. The
Naihua method is intended for results with non-normal errors. You can check
the functional form by simply plotting y (non-transformed) against the fit.    
The default is to output the log scaled predictions.
</p>


<h3>Value</h3>

<p>Vector of model predictions
</p>


<h3>Author(s)</h3>

<p>Jeffrey S. Evans  &lt;jeffrey_evans@tnc.org&gt; and 
Melanie A. Murphy &lt;melanie.murphy@uwyo.edu&gt;
</p>


<h3>References</h3>

<p>Miller, D.M. (1984) Reducing Transformation Bias in Curve Fitting
The American Statistician. 38(2):124-126
</p>
<p>Naihua, D. (1983) Smearing Estimate: A Nonparametric Retransformation Method 
Journal of the American Statistical Association, 78(383):605–610.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(nlme)
  data(ralu.model)

back.transform &lt;- function(y) exp(y + 0.5 * stats::var(y, na.rm=TRUE))
rmse = function(p, o){ sqrt(mean((p - o)^2)) } 

x = c("DEPTH_F", "HLI_F", "CTI_F", "cti", "ffp")
 
sidx &lt;- sample(1:nrow(ralu.model), 100) 
  train &lt;- ralu.model[sidx,]
  test &lt;- ralu.model[-sidx,]
 
 # Specify constrained gravity model	
 ( gm &lt;- gravity(y = "DPS", x = x, d = "DISTANCE", group = "FROM_SITE", 
                 data = train, ln = FALSE) )
  
( p &lt;- predict(gm, test[,c(x, "DISTANCE")]) )
  rmse(back.transform(p), back.transform(ralu.model[,"DPS"][-sidx]))

# WIth model sigma-based back transformation
( p &lt;- predict(gm, test[,c(x, "DISTANCE")], back.transform = "simple") )
( p &lt;- predict(gm, test[,c(x, "DISTANCE")], back.transform = "Miller") )
( p &lt;- predict(gm, test[,c(x, "DISTANCE")], back.transform = "Naihua") )

# Using grouped data
test &lt;- nlme::groupedData(stats::as.formula(paste(paste("DPS", 1, sep = " ~ "), 
          "FROM_SITE", sep = " | ")), 
		  data = test[,c("DPS", "FROM_SITE", x, "DISTANCE")])

( p &lt;- predict(gm, test, groups = "FROM_SITE") )
( y.hat &lt;- back.transform(ralu.model[,"DPS"][-sidx]) )
    na.idx &lt;- which(is.na(p))
  rmse(back.transform(p)[-na.idx], y.hat[-na.idx])

# Specify unconstrained gravity model (generally, not recommended)	
( gm &lt;- gravity(y = "DPS", x = x, d = "DISTANCE", group = "FROM_SITE", 
                data = train, ln = FALSE, constrained=TRUE) )

( p &lt;- predict(gm, test[,c(x, "DISTANCE")]) )
  rmse(back.transform(p), back.transform(ralu.model[,"DPS"][-sidx])) 

</code></pre>

<hr>
<h2 id='print.gravity'>Print gravity model</h2><span id='topic+print.gravity'></span>

<h3>Description</h3>

<p>summary method for class &quot;gravity&quot;
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gravity'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.gravity_+3A_x">x</code></td>
<td>
<p>Object of class gravity</p>
</td></tr>
<tr><td><code id="print.gravity_+3A_...">...</code></td>
<td>
<p>Ignored</p>
</td></tr>
</table>

<hr>
<h2 id='ralu.model'>Columbia spotted frog (Rana luteiventris) data for specifying gravity model. Note, the data.frame is already log transformed.</h2><span id='topic+ralu.model'></span>

<h3>Description</h3>

<p>Subset of data used in Murphy et al., (2010)
</p>


<h3>Format</h3>

<p>A data.frame with 190 rows (sites) and 19 columns (covariates):
</p>

<dl>
<dt>ARMI_ID</dt><dd><p>Unique ID</p>
</dd>
<dt>FROM_SITE</dt><dd><p>Unique from site ID</p>
</dd>
<dt>TO_SITE</dt><dd><p>Unique to site ID</p>
</dd>
<dt>FST</dt><dd><p>FST genetic distance</p>
</dd>
<dt>DPS</dt><dd><p>DPS genetic distance</p>
</dd>
<dt>DISTANCE</dt><dd><p>Graph edge distance</p>
</dd>
<dt>DEPTH_F</dt><dd><p>At site water depth</p>
</dd>
<dt>HLI_F</dt><dd><p>Heat Load Index</p>
</dd>
<dt>CTI_F</dt><dd><p>Wetness Index</p>
</dd>
<dt>DEPTH_T</dt><dd><p>At site water depth</p>
</dd>
<dt>HLI_T</dt><dd><p>Heat Load Index</p>
</dd>
<dt>CTI_T</dt><dd><p>Wetness Index</p>
</dd>
<dt>hli</dt><dd><p>Heat Load Index</p>
</dd>
<dt>cti</dt><dd><p>Wetness Index</p>
</dd>
<dt>ffp</dt><dd><p>Frost Free Period</p>
</dd>
<dt>err27</dt><dd><p>Roughness at 27x27 scale</p>
</dd>
<dt>rsp</dt><dd><p>Relative Slope Position</p>
</dd>
<dt>ridge</dt><dd><p>Percent Ridge Line</p>
</dd>
<dt>hab_ratio</dt><dd><p>Ratio of suitable dispersal habitat</p>
</dd>
</dl>



<h3>References</h3>

<p>Murphy M.A., R. Dezzani, D.S. Pilliod &amp; A.S. Storfer (2010) Landscape genetics of high mountain frog metapopulations. Molecular Ecology 19(17):3634-3649
</p>

<hr>
<h2 id='ralu.site'>Subset of site-level spatial point data for Columbia spotted frog (Rana luteiventris)</h2><span id='topic+ralu.site'></span>

<h3>Description</h3>

<p>Subset of data used in Murphy et al., (2010)
</p>


<h3>Format</h3>

<p>An sf POINT object with 31 obs. of  17 variables:
</p>

<dl>
<dt>SiteName</dt><dd><p>Unique site name</p>
</dd>
<dt>Drainage</dt><dd><p>Source drainage</p>
</dd>
<dt>Basin</dt><dd><p>source basin</p>
</dd>
<dt>Substrate</dt><dd><p>Wetland substrate</p>
</dd>
<dt>NWI</dt><dd><p>USFWS NWI Wetland type</p>
</dd>
<dt>AREA_m2</dt><dd><p>Area of wetland</p>
</dd>
<dt>PERI_m</dt><dd><p>Perimeter of wetland</p>
</dd>
<dt>Depth_m</dt><dd><p>Depth of wetland</p>
</dd>
<dt>TDS</dt><dd><p>...</p>
</dd>
<dt>FISH</dt><dd><p>Fish present</p>
</dd>
<dt>ACB</dt><dd><p>...</p>
</dd>
<dt>AUC</dt><dd><p>...</p>
</dd>
<dt>AUCV</dt><dd><p>...</p>
</dd>
<dt>AUCC</dt><dd><p>...</p>
</dd>
<dt>AUF</dt><dd><p>...</p>
</dd>
<dt>AWOOD</dt><dd><p>...</p>
</dd>
<dt>AUFV</dt><dd><p>...</p>
</dd>
</dl>



<h3>References</h3>

<p>Murphy M.A., R. Dezzani, D.S. Pilliod &amp; A.S. Storfer (2010) Landscape genetics of high mountain frog metapopulations. Molecular Ecology 19(17):3634-3649
</p>

<hr>
<h2 id='summary.gravity'>Summarizing Gravity Model Fits</h2><span id='topic+summary.gravity'></span>

<h3>Description</h3>

<p>Summary method for class &quot;gravity&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gravity'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.gravity_+3A_object">object</code></td>
<td>
<p>Object of class gravity</p>
</td></tr>
<tr><td><code id="summary.gravity_+3A_...">...</code></td>
<td>
<p>Ignored</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Summary of lme or lm gravity model, AIC, log likelihood and Root Mean Square Error (RMSE) of observed verses predicted
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
