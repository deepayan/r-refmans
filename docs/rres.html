<!DOCTYPE html><html><head><title>Help for package rres</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {rres}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#check.pedinfo'><p>Check pedigree information.</p></a></li>
<li><a href='#fgl2ibd'><p>Score IBD state.</p></a></li>
<li><a href='#fgl2relatedness'><p>Score pairwise relatedness.</p></a></li>
<li><a href='#get.pedindex'><p>Get pedigree index.</p></a></li>
<li><a href='#grm.matrix'><p>GRM for multiple individuals</p></a></li>
<li><a href='#grm.pair'><p>GRM for a pair of individuals.</p></a></li>
<li><a href='#ibd.length'><p>Score IBD length.</p></a></li>
<li><a href='#ibd.marker'><p>Score IBD sharing at a list of marker positions.</p></a></li>
<li><a href='#ibd.proportion'><p>Score IBD proportion.</p></a></li>
<li><a href='#ibd.segment'><p>Score IBD sharing by segment.</p></a></li>
<li><a href='#ld.weights'><p>LD weights</p></a></li>
<li><a href='#populate.snp'><p>Populate SNPs.</p></a></li>
<li><a href='#read.plink.binary'><p>Read PLINK binary file.</p></a></li>
<li><a href='#read.plink.text'><p>Read PLINK text file.</p></a></li>
<li><a href='#recode.ibd'><p>Recode IBD sharing.</p></a></li>
<li><a href='#recode.snpdata'><p>Recode SNP marker data.</p></a></li>
<li><a href='#sim.haplotype'><p>Simulate artificial haplotypes.</p></a></li>
<li><a href='#sim.recomb'><p>Simulate inheritance on a given pedigree.</p></a></li>
<li><a href='#write.ibdhaplo'><p>Write IBDHAPLO</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Realized Relatedness Estimation and Simulation</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2018-03-27</td>
</tr>
<tr>
<td>Author:</td>
<td>Bowen Wang</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Bowen Wang &lt;bowenwang7@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Functions for studying realized genetic relatedness between people. Users will be able to simulate inheritance patterns given pedigree structures, generate SNP marker data given inheritance patterns, and estimate realized relatedness between pairs of individuals using SNP marker data. See Wang (2017) &lt;<a href="https://doi.org/10.1534%2Fgenetics.116.197004">doi:10.1534/genetics.116.197004</a>&gt;. This work was supported by National Institutes of Health grants R37 GM-046255.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 0.12.16), kernlab</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.0.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2018-06-04 19:32:09 UTC; bowenw54</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2018-06-04 21:54:23 UTC</td>
</tr>
</table>
<hr>
<h2 id='check.pedinfo'>Check pedigree information.</h2><span id='topic+check.pedinfo'></span>

<h3>Description</h3>

<p><code>check.pedinfo</code> checks that the pedigree information provided is consistent.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check.pedinfo(pedinfo)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check.pedinfo_+3A_pedinfo">pedinfo</code></td>
<td>
<p>dataframe.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Member ID must be unique. Parents must precede offsprings. Sex information must match parental status, and are coded 1 and 2 for male and female respectively. An error message will be produced only if inconsistencies are found.
</p>

<hr>
<h2 id='fgl2ibd'>Score IBD state.</h2><span id='topic+fgl2ibd'></span>

<h3>Description</h3>

<p><code>fgl2ibd</code> determines pairwise IBD state given the four founder genome labels of two individuals at a marker.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fgl2ibd(fgl1p, fgl1m, fgl2p, fgl2m)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fgl2ibd_+3A_fgl1p">fgl1p</code>, <code id="fgl2ibd_+3A_fgl1m">fgl1m</code>, <code id="fgl2ibd_+3A_fgl2p">fgl2p</code>, <code id="fgl2ibd_+3A_fgl2m">fgl2m</code></td>
<td>
<p>positive integer, represents founder genome label.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>IBD states take value from 1 to 15, which represent the indices of the underlying IBD states from 1111 to 1234 in lexicographical order. E.g., output 1 means IBD state 1111, output 2 means IBD state 1112 etc. Recoding in, e.g., Jacquard order, can be obtained using <code><a href="#topic+recode.ibd">recode.ibd</a></code>.
</p>


<h3>Value</h3>

<p>A value between 1 and 15 representing index of IBD state in lexicographical order.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fgl2ibd(1, 1, 1, 1)
fgl2ibd(1, 2, 1, 2)
fgl2ibd(3, 4, 5, 6)
fgl2ibd(4, 5, 4, 4)
</code></pre>

<hr>
<h2 id='fgl2relatedness'>Score pairwise relatedness.</h2><span id='topic+fgl2relatedness'></span>

<h3>Description</h3>

<p><code>fgl2relatedness</code> determines pairwise relatedness given the four founder genome labels of two individuals at a marker.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fgl2relatedness(fgl1p, fgl1m, fgl2p, fgl2m)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fgl2relatedness_+3A_fgl1p">fgl1p</code>, <code id="fgl2relatedness_+3A_fgl1m">fgl1m</code>, <code id="fgl2relatedness_+3A_fgl2p">fgl2p</code>, <code id="fgl2relatedness_+3A_fgl2m">fgl2m</code></td>
<td>
<p>positive integer, represents founder genome label.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A value in [0, 0.5, 1, 2] representing local relatedness coefficient.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fgl2relatedness(1, 1, 1, 1)
fgl2relatedness(1, 2, 1, 2)
fgl2relatedness(1, 2, 1, 3)
fgl2relatedness(3, 4, 5, 6)
fgl2relatedness(4, 5, 4, 4)
</code></pre>

<hr>
<h2 id='get.pedindex'>Get pedigree index.</h2><span id='topic+get.pedindex'></span>

<h3>Description</h3>

<p><code>get.pedindex</code> returns indices of individuals in the pedigree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.pedindex(pedinfo, member.set)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.pedindex_+3A_pedinfo">pedinfo</code></td>
<td>
<p>dataframe.</p>
</td></tr>
<tr><td><code id="get.pedindex_+3A_member.set">member.set</code></td>
<td>
<p>character vector.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>member.set</code> contains member IDs of individuals of interest.
</p>


<h3>Value</h3>

<p>An integer vector of indices for each individual of interest found in <code>pedinfo</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># a simple pedigree with sibling marriage
pedigree = as.character(rep(1, 5))
member = as.character(c(11, 12, 21, 22, 31))
sex = as.numeric(c(1, 2, 1, 2, 1))
father = as.character(c(NA, NA, 11, 11, 21))
mother = as.character(c(NA, NA, 12, 12, 22))
pedinfo = data.frame(pedigree, member, sex, father, mother, stringsAsFactors = FALSE)

get.pedindex(pedinfo, c("22", "31"))
</code></pre>

<hr>
<h2 id='grm.matrix'>GRM for multiple individuals</h2><span id='topic+grm.matrix'></span>

<h3>Description</h3>

<p><code>grm.matrix</code> computes relatedness estimates between every pairs of individuals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grm.matrix(genotype, freq, method = "twostep", weights = NULL,
  init.est = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="grm.matrix_+3A_genotype">genotype</code></td>
<td>
<p>numeric matrix.</p>
</td></tr>
<tr><td><code id="grm.matrix_+3A_freq">freq</code></td>
<td>
<p>numeric vector, values between 0 and 1.</p>
</td></tr>
<tr><td><code id="grm.matrix_+3A_method">method</code></td>
<td>
<p>string.</p>
</td></tr>
<tr><td><code id="grm.matrix_+3A_weights">weights</code></td>
<td>
<p>numeric vector, values between 0 and 1.</p>
</td></tr>
<tr><td><code id="grm.matrix_+3A_init.est">init.est</code></td>
<td>
<p>numeric.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>genotype</code> is the matrix of counts of reference alleles. Rows represents subjects and columns represents SNP markers. <code>freq</code> is the vector of reference allele frequencies.
</p>
<p>The default <code>method</code> is &quot;twostep&quot;, other options include &quot;classic&quot;, &quot;robust&quot; and &quot;general&quot;. When using the default &quot;twostep&quot; method, user can supply an initial estimate through <code>init.est</code> to bypass the first step. When &quot;general&quot; is selected, <code>weights</code> must also be specified. The difference between the two-step GRM, classic GRM and robust GRM is discussed in Wang et al.  (2017).
</p>


<h3>References</h3>

<p>Wang et al. (2017) Genetics 205:1063-1078, <a href="https://www.ncbi.nlm.nih.gov/pubmed/28100587">https://www.ncbi.nlm.nih.gov/pubmed/28100587</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+grm.pair">grm.pair</a></code>.
</p>

<hr>
<h2 id='grm.pair'>GRM for a pair of individuals.</h2><span id='topic+grm.pair'></span>

<h3>Description</h3>

<p><code>grm.pair</code> computes relatedness estimates between two individuals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grm.pair(geno1, geno2, freq, method = "twostep", weights = NULL,
  init.est = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="grm.pair_+3A_geno1">geno1</code>, <code id="grm.pair_+3A_geno2">geno2</code></td>
<td>
<p>numeric vector.</p>
</td></tr>
<tr><td><code id="grm.pair_+3A_freq">freq</code></td>
<td>
<p>numeric vector, values between 0 and 1.</p>
</td></tr>
<tr><td><code id="grm.pair_+3A_method">method</code></td>
<td>
<p>string.</p>
</td></tr>
<tr><td><code id="grm.pair_+3A_weights">weights</code></td>
<td>
<p>numeric vector, values between 0 and 1.</p>
</td></tr>
<tr><td><code id="grm.pair_+3A_init.est">init.est</code></td>
<td>
<p>numeric.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>geno1</code> and <code>geno2</code> are vectors of counts of reference alleles. <code>freq</code> is the vector of reference allele frequencies.
</p>
<p>The default <code>method</code> is &quot;twostep&quot;, other options include &quot;classic&quot;, &quot;robust&quot; and &quot;general&quot;. When using the default &quot;twostep&quot; method, user can supply an initial estimate through <code>init.est</code> to bypass the first step. When &quot;general&quot; is selected, <code>weights</code> must also be specified. The difference between the two-step GRM, classic GRM and robust GRM is discussed in Wang et al.  (2017).
</p>


<h3>Value</h3>

<p>An estimate of realized relatedness.
</p>


<h3>References</h3>

<p>Wang et al. (2017) Genetics 205:1063-1078, <a href="https://www.ncbi.nlm.nih.gov/pubmed/28100587">https://www.ncbi.nlm.nih.gov/pubmed/28100587</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+grm.matrix">grm.matrix</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># simulate genotypes for a full sib pair
pedigree = as.character(rep(1, 4))
member = as.character(c(11, 12, 21, 22))
sex = as.numeric(c(1, 2, 1, 2))
father = as.character(c(NA, NA, 11, 11))
mother = as.character(c(NA, NA, 12, 12))
pedinfo = data.frame(pedigree, member, sex, father, mother, stringsAsFactors = FALSE)
set.seed(1)
inher = sim.recomb(pedinfo, 3500) # on a hypothetical chromosome

nsnp = 100000
marker = seq(0,3500,length.out=nsnp)
freq = runif(nsnp, 0.05, 0.95)
haplo = sim.haplotype(freq, 4)
geno = populate.snp(inher, haplo, marker, output.allele = FALSE)

# simulation truth
ibd.proportion(inher,3,4)

# different GRM estimates
grm.pair(geno[3,], geno[4,], freq, method = "twostep")
grm.pair(geno[3,], geno[4,], freq, method = "classic")
grm.pair(geno[3,], geno[4,], freq, method = "robust")
grm.pair(geno[3,], geno[4,], freq, method = "general", weights = sample(freq, nsnp)/sum(freq))

# compute the relatedness matrix
grm.matrix(geno, freq)
grm.matrix(geno, freq, method = "robust")
</code></pre>

<hr>
<h2 id='ibd.length'>Score IBD length.</h2><span id='topic+ibd.length'></span>

<h3>Description</h3>

<p><code>ibd.length</code> returns the total length of IBD segemnt between two haplotypes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ibd.length(inher.hap1, inher.hap2, startpos = NULL, endpos = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ibd.length_+3A_inher.hap1">inher.hap1</code>, <code id="ibd.length_+3A_inher.hap2">inher.hap2</code></td>
<td>
<p>numeric matrix.</p>
</td></tr>
<tr><td><code id="ibd.length_+3A_startpos">startpos</code>, <code id="ibd.length_+3A_endpos">endpos</code></td>
<td>
<p>non-negative number.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function works with output from <code><a href="#topic+sim.recomb">sim.recomb</a></code>.
</p>


<h3>Value</h3>

<p>A non-negative number representing the length of IBD segment in Haldane centiMorgan.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># a simple pedigree with sibling marriage
pedigree = as.character(rep(1, 5))
member = as.character(c(11, 12, 21, 22, 31))
sex = as.numeric(c(1, 2, 1, 2, 1))
father = as.character(c(NA, NA, 11, 11, 21))
mother = as.character(c(NA, NA, 12, 12, 22))
pedinfo = data.frame(pedigree, member, sex, father, mother, stringsAsFactors = FALSE)
inheritance = sim.recomb(pedinfo, 100)

# IBD length between the two haplotypes of inbred individual 31
ibd.length(inheritance[[9]], inheritance[[10]])
</code></pre>

<hr>
<h2 id='ibd.marker'>Score IBD sharing at a list of marker positions.</h2><span id='topic+ibd.marker'></span>

<h3>Description</h3>

<p><code>ibd.marker</code> determines pairwise IBD sharing at marker positions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ibd.marker(inheritance, marker, ind1index, ind2index = NULL,
  relatedness = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ibd.marker_+3A_inheritance">inheritance</code></td>
<td>
<p>list of numeric matrices.</p>
</td></tr>
<tr><td><code id="ibd.marker_+3A_marker">marker</code></td>
<td>
<p>numeric vector.</p>
</td></tr>
<tr><td><code id="ibd.marker_+3A_ind1index">ind1index</code>, <code id="ibd.marker_+3A_ind2index">ind2index</code></td>
<td>
<p>positive integer, represents index of individual in pedigree.</p>
</td></tr>
<tr><td><code id="ibd.marker_+3A_relatedness">relatedness</code></td>
<td>
<p>logical, determines coding of IBD information.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When only index of one individual is supplied, IBD sharing status at each marker is coded as 0 (not IBD) or 1 (IBD) between the two haplotypes of the individual.
</p>
<p>When indices of two individuals are supplied, IBD sharing status at each marker is either in relatedness (default) or lexicographical order of IBD state, where recoding can be done using <code><a href="#topic+recode.ibd">recode.ibd</a></code>.
</p>


<h3>Value</h3>

<p>A numeric vector of IBD sharing status at the list of marker positions.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># a simple pedigree with sibling marriage
pedigree = as.character(rep(1, 5))
member = as.character(c(11, 12, 21, 22, 31))
sex = as.numeric(c(1, 2, 1, 2, 1))
father = as.character(c(NA, NA, 11, 11, 21))
mother = as.character(c(NA, NA, 12, 12, 22))
pedinfo = data.frame(pedigree, member, sex, father, mother, stringsAsFactors = FALSE)
inheritance = sim.recomb(pedinfo, 100)
nsnp = 10
marker = sort(runif(nsnp, 0, 100))

# IBD at markers between the two haplotypes of the inbred individual
ibd.marker(inheritance, marker, 5)

# IBD at markers between the two full sibs, with different IBD coding
ibd.marker(inheritance, marker, 3, 4) # relatedness
ibd.marker(inheritance, marker, 3, 4, relatedness = FALSE) # lexicographical order of IBD state
</code></pre>

<hr>
<h2 id='ibd.proportion'>Score IBD proportion.</h2><span id='topic+ibd.proportion'></span>

<h3>Description</h3>

<p><code>ibd.proportion</code> returns the proportion of IBD sharing between two haplotypes of the same individual or two individuals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ibd.proportion(inheritance, ind1index, ind2index = NULL, startpos = NULL,
  endpos = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ibd.proportion_+3A_inheritance">inheritance</code></td>
<td>
<p>list of matrices.</p>
</td></tr>
<tr><td><code id="ibd.proportion_+3A_ind1index">ind1index</code>, <code id="ibd.proportion_+3A_ind2index">ind2index</code></td>
<td>
<p>positive integer.</p>
</td></tr>
<tr><td><code id="ibd.proportion_+3A_startpos">startpos</code>, <code id="ibd.proportion_+3A_endpos">endpos</code></td>
<td>
<p>non-negative number.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When only one individual index is supplied, <code>ibd.proportion</code> returns the realized inbreeding coefficient of the individual. When two individual indices are supplied, <code>ibd.proportion</code> returns the realized relatedness of the two individuals.
</p>


<h3>Value</h3>

<p>A value between 0 and 1 representing the proportion of IBD segment.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># a simple pedigree with sibling marriage
pedigree = as.character(rep(1, 5))
member = as.character(c(11, 12, 21, 22, 31))
sex = as.numeric(c(1, 2, 1, 2, 1))
father = as.character(c(NA, NA, 11, 11, 21))
mother = as.character(c(NA, NA, 12, 12, 22))
pedinfo = data.frame(pedigree, member, sex, father, mother, stringsAsFactors = FALSE)
inheritance = sim.recomb(pedinfo, 100)

# realized inbreeding of inbred child
get.pedindex(pedinfo, "31")
ibd.proportion(inheritance, 5)

# realized relatedness between individual 21 and 22 (parents of inbred child)
get.pedindex(pedinfo, c("21", "22"))
ibd.proportion(inheritance, 3, 4)
</code></pre>

<hr>
<h2 id='ibd.segment'>Score IBD sharing by segment.</h2><span id='topic+ibd.segment'></span>

<h3>Description</h3>

<p><code>ibd.segment</code> determines the starting and endping genetic positions of segments with different amount of pairwise IBD sharing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ibd.segment(inheritance, ind1index, ind2index = NULL, relatedness = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ibd.segment_+3A_inheritance">inheritance</code></td>
<td>
<p>list of numeric matrices.</p>
</td></tr>
<tr><td><code id="ibd.segment_+3A_ind1index">ind1index</code>, <code id="ibd.segment_+3A_ind2index">ind2index</code></td>
<td>
<p>positive integer, represents index of individual in pedigree.</p>
</td></tr>
<tr><td><code id="ibd.segment_+3A_relatedness">relatedness</code></td>
<td>
<p>logical, determines coding of IBD information.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When only index of one individual is supplied, IBD sharing status for each segment is coded as 0 (not IBD) or 1 (IBD) between the two haplotypes of the individual.
</p>
<p>When indices of two individuals are supplied, IBD sharing status for each segment is either in relatedness (default) or lexicographical order of IBD state, where recoding can be done using <code><a href="#topic+recode.ibd">recode.ibd</a></code>.
</p>


<h3>Value</h3>

<p>A dataframe of three variables. <code>ibd</code> represents IBD sharing status of a segment, and <code>startpos</code>/<code>endpos</code> represents starting/ending genetic position of the segment.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># a simple pedigree with sibling marriage
pedigree = as.character(rep(1, 5))
member = as.character(c(11, 12, 21, 22, 31))
sex = as.numeric(c(1, 2, 1, 2, 1))
father = as.character(c(NA, NA, 11, 11, 21))
mother = as.character(c(NA, NA, 12, 12, 22))
pedinfo = data.frame(pedigree, member, sex, father, mother, stringsAsFactors = FALSE)
inheritance = sim.recomb(pedinfo, 100)

# IBD segments between the two haplotypes of the inbred individual
ibd.segment(inheritance, 5)

# IBD segments between the two full sibs
ibd.segment(inheritance, 3, 4) # relatedness
ibd.segment(inheritance, 3, 4, relatedness = FALSE) # lexicographical order of IBD state
</code></pre>

<hr>
<h2 id='ld.weights'>LD weights</h2><span id='topic+ld.weights'></span>

<h3>Description</h3>

<p><code>ld.weights</code> computes LD weights for all markers, which is subsequently used to compute LD weighted GRM.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ld.weights(data, input.genotype = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ld.weights_+3A_data">data</code></td>
<td>
<p>numeric matrix.</p>
</td></tr>
<tr><td><code id="ld.weights_+3A_input.genotype">input.genotype</code></td>
<td>
<p>logical.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>data</code> can either be the subject by marker numeric genotype matrix (with 0, 1 or 2 coding), or the matrix of marker genotypic correlations. The default option is to input genotype matrix.
</p>


<h3>Value</h3>

<p>A numeric vector of weights. Note that the sum of weights is not constrained to be 1. They should be scaled appropriately before computing the LD weighted GRM.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># simulate genotypes of 500 individuals at 100 markers
nsnp = 100 # number of SNPs
freq = runif(nsnp, 0.05, 0.95)
nhaplo = 1000 # number of founder haplotypes
haplo.mat = sim.haplotype(freq, nhaplo)
geno.mat = t(sapply(c(1:500), function(x) 4 - haplo.mat[2*x-1,] - haplo.mat[2*x,]))

# compute unconstrained LD weights
ld.weights(geno.mat)
</code></pre>

<hr>
<h2 id='populate.snp'>Populate SNPs.</h2><span id='topic+populate.snp'></span>

<h3>Description</h3>

<p><code>populate.snp</code> assigns alleles to markers, given inheritance information and founder haplotypes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>populate.snp(inheritance, haplotype, marker, member.index = NULL,
  output.allele = TRUE, output.haplotype = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="populate.snp_+3A_inheritance">inheritance</code></td>
<td>
<p>list of numeric matrices.</p>
</td></tr>
<tr><td><code id="populate.snp_+3A_haplotype">haplotype</code></td>
<td>
<p>numeric matrix.</p>
</td></tr>
<tr><td><code id="populate.snp_+3A_marker">marker</code></td>
<td>
<p>numeric vector.</p>
</td></tr>
<tr><td><code id="populate.snp_+3A_member.index">member.index</code></td>
<td>
<p>integer vector.</p>
</td></tr>
<tr><td><code id="populate.snp_+3A_output.allele">output.allele</code></td>
<td>
<p>logical.</p>
</td></tr>
<tr><td><code id="populate.snp_+3A_output.haplotype">output.haplotype</code></td>
<td>
<p>logical.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>inheritance</code> is a list of matrices produced by, e.g., <code><a href="#topic+sim.recomb">sim.recomb</a></code>. Each matrix contains a column of founder genome labels and a column of recombination breakpoints for the corresponding meiosis.
</p>
<p><code>haplotype</code> is a numeric matrix. The matrix is number of haplotypes by number of markers in dimension. Standard coding in this package is 1 for reference allele and 2 for alternate allele. This coding is required when <code>output.allele = FALSE</code>. Input data with different coding of alleles can be recoded using <code><a href="#topic+recode.snpdata">recode.snpdata</a></code>. Number of haplotypes cannot be fewer than the number of founder genome labels in <code>inheritance</code>. The haplotypes will be assigned to each founder genome label in given order.
</p>
<p><code>marker</code> is a vector of marker genetic positions in Haldane centiMorgan in ascending order. Range of marker positions cannot exceed range covered by <code>inheritance</code>.
</p>
<p><code>member.index</code> contains indices of members in the pedigree that we wish to output data. Default value is <code>FALSE</code>, in which case marker data on everyone will be produced. <code><a href="#topic+get.pedindex">get.pedindex</a></code> can help find indices given member ID.
</p>
<p><code>output.allele</code> determines if one or two numbers will be used to represent data at each marker. Default is <code>TRUE</code>, in which case marker data is represented by two ordered (paternal first) alleles. Otherwise marker data is represented by a single number (0, 1 or 2) of reference alleles.
</p>
<p><code>output.haplotype</code> determines if haplotype data are separate in output. It is only used when <code>output.allele = TRUE</code>. Default value is <code>FALSE</code>, in which case each row in the output matrix represents ordered genotypes from all markers of the same individual. Otherwise each row in the output matrix represents a parental haplotype.
</p>


<h3>Value</h3>

<p>A matrix of genotypic/haplotypic data. The matrix is in individual major, where marker data for each individual/meiosis are found on the same row. Exact format of the matrix depends on various input arguments.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># a simple pedigree with sibling marriage
pedigree = as.character(rep(1, 5))
member = as.character(c(11, 12, 21, 22, 31))
sex = as.numeric(c(1, 2, 1, 2, 1))
father = as.character(c(NA, NA, 11, 11, 21))
mother = as.character(c(NA, NA, 12, 12, 22))
pedinfo = data.frame(pedigree, member, sex, father, mother, stringsAsFactors = FALSE)

L = 100.0 # segment length
nsnp = 10 # number of SNPs
nhaplo = 4 # number of founder haplotypes
inher = sim.recomb(pedinfo, L)
haplo = matrix(c(3,4,4,4), nhaplo, nsnp)
marker = sort(runif(nsnp, 0, L))

# output genotype data for the 4th and 5th member
# of pedigree, genotype data displayed as two alleles
populate.snp(inher, haplo, marker, c(4, 5))

# output haplotype data for the 4th and 5th member of pedigree
populate.snp(inher, haplo, marker,c(4, 5), output.haplotype = TRUE)

# output genotype data for all members, genotype data
# displayed as counts of reference alleles
geno = recode.snpdata(haplo, input.haplotype = TRUE, output.haplotype = TRUE)[[1]]
populate.snp(inher, geno, marker, output.allele = FALSE)
</code></pre>

<hr>
<h2 id='read.plink.binary'>Read PLINK binary file.</h2><span id='topic+read.plink.binary'></span>

<h3>Description</h3>

<p><code>read.plink.binary</code> reads PLINK binary <code>.bed</code> file and the corresponding <code>.bim</code> and <code>.fam</code> file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.plink.binary(bed, bim = NULL, fam = NULL, na.strings = c("0", "-9"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read.plink.binary_+3A_bed">bed</code>, <code id="read.plink.binary_+3A_bim">bim</code>, <code id="read.plink.binary_+3A_fam">fam</code></td>
<td>
<p>PLINK files with appropriate extensions.</p>
</td></tr>
<tr><td><code id="read.plink.binary_+3A_na.strings">na.strings</code></td>
<td>
<p>string vector, text entries to be treated as NA's.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When the three files have the same name, only the <code>.bed</code> file needs to be specified.
</p>


<h3>Value</h3>

<p>A list of three elements: <code>genotype</code>, <code>fam</code> and <code>map</code>.
To be consistent with PLINK .bed file, <code>genotype</code> is a n_subject by n_marker matrix of counts of reference alleles. Missing values are -9.
<code>fam</code> is a dataframe that contains the first six columns of a PLINK <code>.ped</code> file.
<code>map</code> is a dataframe that contains the four columns of a PLINK <code>.map</code> file, with two additional columns: <code>allele_1</code> for the reference allele type, <code>allele_2</code> for the alternate allele type.
</p>

<hr>
<h2 id='read.plink.text'>Read PLINK text file.</h2><span id='topic+read.plink.text'></span>

<h3>Description</h3>

<p><code>read.plink.text</code> reads PLINK text files in either the original or transposed format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.plink.text(ped, map = NULL, output.allele = TRUE, na.strings = c("0",
  "-9"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read.plink.text_+3A_ped">ped</code>, <code id="read.plink.text_+3A_map">map</code></td>
<td>
<p>PLINK files with appropraite extensions.</p>
</td></tr>
<tr><td><code id="read.plink.text_+3A_output.allele">output.allele</code></td>
<td>
<p>logical, default is to output genotype as alleles.</p>
</td></tr>
<tr><td><code id="read.plink.text_+3A_na.strings">na.strings</code></td>
<td>
<p>Character vector, set of characters to be treated as missing values.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The PLINK pedigree file should be supplied with the appropriate extension. The corresponding map file can be omitted if it has the same file name as the pedigree file and has the appropriate extension.
</p>


<h3>Value</h3>

<p>A list of three elements: <code>genotype</code>, <code>fam</code> and <code>map</code>.
To be consistent with PLINK .ped file, <code>genotype</code> by default is a n_subject by (2 x n_marker) matrix of alleles, where 1 represents the reference allele and 2 the alternate allele. Alternatively, genotype can be outputted as 0, 1 or 2 copies of reference allele count by using <code>output.allele = FALSE</code>. Missing values are -9.
<code>fam</code> is a dataframe that contains the first six columns of a PLINK <code>.ped</code> file.
<code>map</code> is a dataframe that contains the four columns of a PLINK <code>.map</code> file, with two additional columns: <code>allele_1</code> for the reference allele type, <code>allele_2</code> for the alternate allele type.
</p>

<hr>
<h2 id='recode.ibd'>Recode IBD sharing.</h2><span id='topic+recode.ibd'></span>

<h3>Description</h3>

<p><code>recode.ibd</code> recodes pairwise IBD sharing information.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>recode.ibd(ibdvec, from, to)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="recode.ibd_+3A_ibdvec">ibdvec</code></td>
<td>
<p>numeric vector of input IBD sharing information.</p>
</td></tr>
<tr><td><code id="recode.ibd_+3A_from">from</code>, <code id="recode.ibd_+3A_to">to</code></td>
<td>
<p>string, IBD sharing information options include &quot;ibdstate&quot;, &quot;lexi&quot;, &quot;jac&quot;, &quot;jac.red&quot; and &quot;relatedness&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>At any marker, there are 15 possible IBD states between the four genes of two individuals. &quot;ibdstate&quot; represents the standard coding of the 15 states from 1111 to 1234. &quot;lexi&quot; and &quot;jac&quot; represent lexicographical and Jacquard ordering of &quot;ibdstate&quot; from 1 to 15 respectively. &quot;jac.red&quot; is a condensed Jacquard ordering from 1 to 9 for the genotypically distinct groups of IBD states when phasing is unknown. &quot;relatedness&quot; refers to local relatedness coefficient taking values in (0, 0.5, 1, 2).
</p>
<p>&quot;ibdstate&quot;, &quot;lexi&quot; and &quot;jac&quot; are of the highest level (complete information), &quot;jac.red&quot; is of mid level, whereas &quot;relatedness&quot; is of the lowest level. Conversion cannot go from lower level to higher level.
</p>


<h3>Value</h3>

<p>A numeric vector of recoded IBD states.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>test.state = c(1111, 1122, 1212, 1222, 1234)
recode.ibd(test.state, "ibdstate", "lexi")
recode.ibd(test.state, "ibdstate", "jac")
recode.ibd(test.state, "ibdstate", "jac.red")
recode.ibd(test.state, "ibdstate", "relatedness")
</code></pre>

<hr>
<h2 id='recode.snpdata'>Recode SNP marker data.</h2><span id='topic+recode.snpdata'></span>

<h3>Description</h3>

<p><code>recode.snpdata</code> recodes SNP marker data for use with other functions in this package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>recode.snpdata(data, snp.major = FALSE, ma.ref = FALSE,
  input.haplotype = FALSE, output.allele = TRUE, output.haplotype = FALSE,
  na.string = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="recode.snpdata_+3A_data">data</code></td>
<td>
<p>numeric matrix or dataframe.</p>
</td></tr>
<tr><td><code id="recode.snpdata_+3A_snp.major">snp.major</code></td>
<td>
<p>logical.</p>
</td></tr>
<tr><td><code id="recode.snpdata_+3A_ma.ref">ma.ref</code></td>
<td>
<p>logical.</p>
</td></tr>
<tr><td><code id="recode.snpdata_+3A_input.haplotype">input.haplotype</code></td>
<td>
<p>logical.</p>
</td></tr>
<tr><td><code id="recode.snpdata_+3A_output.allele">output.allele</code></td>
<td>
<p>logical.</p>
</td></tr>
<tr><td><code id="recode.snpdata_+3A_output.haplotype">output.haplotype</code></td>
<td>
<p>logical.</p>
</td></tr>
<tr><td><code id="recode.snpdata_+3A_na.string">na.string</code></td>
<td>
<p>numeric or character vector.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The standard marker data used by other functions of this package takes one of three forms: (a) subjects by row, counts of reference alleles by column; (b) subjects by row, allelic types (2 per marker) by column; (c) haplotypes (2 per subject) by row, allelic types by column. Reference alleles are coded 1, alternate alleles are coded 2.
</p>
<p>By default, <code>snp.major = FALSE</code>, set it to <code>TRUE</code> if input matrix has SNPs by row and allelic types (2 per subject) by column. <code>ma.ref = FALSE</code>, set it to <code>TRUE</code> if the minor allele is to be the reference allele. <code>input.haplotype = FALSE</code>, set it to <code>TRUE</code> if input matrix has haplotypes (2 per subject) by row and allelic types by column. <code>output.allele = TRUE</code>, set it to <code>FALSE</code> if counts of reference alleles is the desired output format. <code>output.haplotype = FALSE</code>, set it to <code>TRUE</code> if recoded marker data by haplotype is the desired output format. <code>input.haplotype</code> is only invoked when <code>snp.major = FALSE</code>. <code>output.haplotype</code> is only invoked when <code>output.allele = TRUE</code>.
</p>


<h3>Value</h3>

<p>A list of two elements. First element named <code>data</code> is a matrix of recoded marker data in specified format. Second element is a dataframe named <code>alleles</code> that specifies reference/alternate alleles at all markers.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>test.dat = matrix(c(3,4,4,3), 4, 10)

# treat test.dat as 4 input haplotypes of two subjects at 10 SNP markers,
# output recoded data as haplotypes
recode.snpdata(test.dat, input.haplotype = TRUE, output.haplotype = TRUE)

# treat test.dat as 4 input haplotypes of two subjects at 10 SNP markers,
# output recoded data as counts of reference alleles
recode.snpdata(test.dat, input.haplotype = TRUE, output.allele = FALSE)
#'
# treat test.dat as allelic types at 5 SNPs of 4 subjects,
# output recoded data as haplotypes
recode.snpdata(test.dat, output.haplotype = TRUE)
</code></pre>

<hr>
<h2 id='sim.haplotype'>Simulate artificial haplotypes.</h2><span id='topic+sim.haplotype'></span>

<h3>Description</h3>

<p><code>sim.haplotype</code> returns haplotypes of the specified number of SNPs simulated under linkage equilibrium.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim.haplotype(freq, nhaplo)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sim.haplotype_+3A_freq">freq</code></td>
<td>
<p>vector of values between 0 and 1.</p>
</td></tr>
<tr><td><code id="sim.haplotype_+3A_nhaplo">nhaplo</code></td>
<td>
<p>positive integer.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>freq</code> are reference allele frequencies. <code>nhaplo</code> haplotypes are simulated independently.
</p>


<h3>Value</h3>

<p>A matrix of <code>nhaplo</code> rows and <code>length(freq)</code> columns. Reference alleles are coded 1, alternate alleles are coded 2.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>nsnp = 7 # number of SNPs
freq = runif(nsnp, 0.05, 0.95)
nhaplo = 4 # number of founder haplotypes
sim.haplotype(freq, nhaplo)
</code></pre>

<hr>
<h2 id='sim.recomb'>Simulate inheritance on a given pedigree.</h2><span id='topic+sim.recomb'></span>

<h3>Description</h3>

<p><code>sim.recomb</code> returns inheritance information simulated on a given pedigree over the specified segment length.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim.recomb(pedinfo, seglength)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sim.recomb_+3A_pedinfo">pedinfo</code></td>
<td>
<p>dataframe.</p>
</td></tr>
<tr><td><code id="sim.recomb_+3A_seglength">seglength</code></td>
<td>
<p>positive real number.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>pedinfo</code> must contain at least the following components: unique individual ID named <code>member</code>, father and mother ID named <code>father</code> and <code>mother</code>, and sex (1 for male, 2 for female) named <code>sex</code>. Parents must precede offsprings. Pedigree founders are treated as unrelated.
</p>
<p><code>seglength</code> represents length of genomic segment in Haldane centiMorgan. Recombination breakpoints are simulated under a homogeneous Poisson process with rate <code>seglength</code>/100.
</p>


<h3>Value</h3>

<p>A list of matrices for each meiosis. Each matrix has two columns: founder genome labels (fgl) and recombination breakpoints (recomb). Paternal meiosis precedes maternal meiosis.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># a simple pedigree with sibling marriage
pedigree = as.character(rep(1, 5))
member = as.character(c(11, 12, 21, 22, 31))
sex = as.numeric(c(1, 2, 1, 2, 1))
father = as.character(c(NA, NA, 11, 11, 21))
mother = as.character(c(NA, NA, 12, 12, 22))
pedinfo = data.frame(pedigree, member, sex, father, mother, stringsAsFactors = FALSE)

# simulate inheritance over a segment of 100 centiMorgan
sim.recomb(pedinfo, 100)
</code></pre>

<hr>
<h2 id='write.ibdhaplo'>Write IBDHAPLO</h2><span id='topic+write.ibdhaplo'></span>

<h3>Description</h3>

<p><code>write.ibdhaplo</code> prepares the marker data file for running IBDHAPLO.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write.ibdhaplo(marker, freq, data, member, input.allele = TRUE,
  input.haplotype = FALSE, outfile = tempfile("ibdhaplo", fileext = ".txt"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="write.ibdhaplo_+3A_marker">marker</code></td>
<td>
<p>numeric vector, marker genetic positions in cM.</p>
</td></tr>
<tr><td><code id="write.ibdhaplo_+3A_freq">freq</code></td>
<td>
<p>numeric vector, marker reference allele frequencies.</p>
</td></tr>
<tr><td><code id="write.ibdhaplo_+3A_data">data</code></td>
<td>
<p>numeric matrix, genetic marker data.</p>
</td></tr>
<tr><td><code id="write.ibdhaplo_+3A_member">member</code></td>
<td>
<p>string vector, member ID.</p>
</td></tr>
<tr><td><code id="write.ibdhaplo_+3A_input.allele">input.allele</code></td>
<td>
<p>logical, default TRUE.</p>
</td></tr>
<tr><td><code id="write.ibdhaplo_+3A_input.haplotype">input.haplotype</code></td>
<td>
<p>logical, default FALSE.</p>
</td></tr>
<tr><td><code id="write.ibdhaplo_+3A_outfile">outfile</code></td>
<td>
<p>string, output file name.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The input marker data needs to be subject/haplotype by marker/allele. For example, suppose <code>data</code> is a 4x10 matrix, use <code>input.allele = FALSE</code> if <code>data</code> contains counts of reference alleles of 4 individuals at 10 markers; use <code>input.haplotype = TRUE</code> if <code>data</code> contains allelic types of 4 haplotypes at 10 markers; use default options if <code>data</code> contains allelic types of 4 individuals at 5 markers.
</p>


<h3>References</h3>

<p>MORGAN Tutorial, <a href="https://www.stat.washington.edu/thompson/Genepi/MORGAN/Morgan.shtml">https://www.stat.washington.edu/thompson/Genepi/MORGAN/Morgan.shtml</a>.
</p>
<p>Brown et al. (2012) Genetics 190:1447-1460, <a href="https://www.ncbi.nlm.nih.gov/pubmed/22298700">https://www.ncbi.nlm.nih.gov/pubmed/22298700</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
nsnp = 7 # number of SNPs
freq = runif(nsnp, 0.05, 0.95)
nhaplo = 4 # number of founder haplotypes
haplotype = sim.haplotype(freq, nhaplo)
marker = sort(runif(7,0,100))
write.ibdhaplo(marker, freq, haplotype, member = c("ind1", "ind2"), 
input.haplotype = TRUE)

## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
