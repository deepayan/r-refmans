<!DOCTYPE html><html><head><title>Help for package PCPS</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {PCPS}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#check.formula'><p>Internal function</p></a></li>
<li><a href='#define.clade'><p>Define clade</p></a></li>
<li><a href='#matrix.p.null'><p>Auxiliar function to generate sets of null P matrix or null PCPS</p></a></li>
<li><a href='#matrix.p.sig'><p>Association between phylogeny-weighted species composition and environmental predictors</p></a></li>
<li><a href='#mutate.names.matrix.p.null'><p>Internal function</p></a></li>
<li><a href='#organize.pcps'><p>Function for organize data for Package PCPS</p></a></li>
<li><a href='#pcoa.sig'><p>Significant dimensions in principal coordinate analysis</p></a></li>
<li><a href='#pcps'><p>Principal Coordinates of Phylogenetic Structure</p></a></li>
<li><a href='#pcps.curve'><p>Curve of phylogenetic signal at metacommunity level</p></a></li>
<li><a href='#select.pcpsmethod'><p>Internal function</p></a></li>
<li><a href='#self.belonging'><p>Degree of self belonging of species</p></a></li>
<li><a href='#wcmdscale.org'><p>Internal function for organize the results of wcmdscale function</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Principal Coordinates of Phylogenetic Structure</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.7</td>
</tr>
<tr>
<td>Date:</td>
<td>2020-01-15</td>
</tr>
<tr>
<td>Author:</td>
<td>Vanderlei Julio Debastiani</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Vanderlei Julio Debastiani &lt;vanderleidebastiani@yahoo.com.br&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>SYNCSA (&ge; 1.3.4)</td>
</tr>
<tr>
<td>Imports:</td>
<td>ape, picante, phylobase, vegan, RcppArmadillo, stats,
graphics, parallel, nlme</td>
</tr>
<tr>
<td>Description:</td>
<td>Set of functions for analysis of Principal Coordinates of Phylogenetic Structure (PCPS).</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.0.2</td>
</tr>
<tr>
<td>Collate:</td>
<td>'matrix.p.sig.R' 'pcps.R' 'pcps.sig.R' 'FUN.ADONIS.R'
'FUN.GLM.R' 'FUN.GLS.marginal.R' 'FUN.GLS.sequential.R'
'FUN.LME.marginal.R' 'FUN.LME.sequential.R' 'FUN.MANTEL.R'
'FUN.RDA.R' 'check.formula.R' 'define.clade.R'
'matrix.p.null.R' 'mutate.names.matrix.p.null.R'
'organize.pcps.R' 'pcoa.sig.R' 'pcps.curve.R'
'pcpc.curve.calc.R' 'plot.pcps.R' 'plot.pcpscurve.R'
'print.pcoasig.R' 'print.pcps.R' 'print.pcpscurve.R'
'print.pcpssig.R' 'print.summarypcoasig.R'
'print.summarypcps.R' 'scores.pcps.R' 'select.pcpsmethod.R'
'self.belonging.R' 'summary.pcoasig.R' 'summary.pcps.R'
'summary.pcpscurve.R' 'wcmdscale.org.R'</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2020-01-15 21:14:14 UTC; vanderleidebastiani</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2020-01-15 22:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='check.formula'>Internal function</h2><span id='topic+check.formula'></span>

<h3>Description</h3>

<p>Internal function to check the validity of left hand side in a formula object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check.formula(formula, vectornames)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check.formula_+3A_formula">formula</code></td>
<td>
<p>An object of class <code><a href="stats.html#topic+formula">formula</a></code>.</p>
</td></tr>
<tr><td><code id="check.formula_+3A_vectornames">vectornames</code></td>
<td>
<p>A vector with names to check the index.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The index of left side of the formula in vectornames.
</p>

<hr>
<h2 id='define.clade'>Define clade</h2><span id='topic+define.clade'></span>

<h3>Description</h3>

<p>Function to define groups (clades) in a phylogenetic tree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>define.clade(tree, threshold, time, method = c("threshold", "time"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="define.clade_+3A_tree">tree</code></td>
<td>
<p>Phylogenetic tree.</p>
</td></tr>
<tr><td><code id="define.clade_+3A_threshold">threshold</code></td>
<td>
<p>A threshold value to form the groups.</p>
</td></tr>
<tr><td><code id="define.clade_+3A_time">time</code></td>
<td>
<p>A cutting height (age) to form the groups.</p>
</td></tr>
<tr><td><code id="define.clade_+3A_method">method</code></td>
<td>
<p>Method to define the clades, &quot;threshold&quot; or &quot;time&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In the method threshold the total length of phylogenetic tree is used as cutting factor. 
If threshold is near to zero the cutting is near the root, if threshold near to one 
cutting is near the tips.
</p>
<p>The phylogenetic tree must contain the node labels for the function work. Use the 
<code><a href="ape.html#topic+makeNodeLabel">makeNodeLabel</a></code> for defining node labels in a flexible way.
</p>


<h3>Value</h3>

<table>
<tr><td><code>clades</code></td>
<td>
<p>Tips and their clades.</p>
</td></tr> <tr><td><code>height</code></td>
<td>
<p>The cutting height (age).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Vanderlei Julio Debastiani &lt;vanderleidebastiani@yahoo.com.br&gt;
</p>


<h3>See Also</h3>

<p><code><a href="ape.html#topic+makeNodeLabel">makeNodeLabel</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
require(ape)	
tree&lt;-makeNodeLabel(rcoal(10))
clades&lt;-define.clade(tree, threshold = 0.8, method = "threshold")
clades
plot.phylo(tree, show.node.label = TRUE)
abline(v = clades$height)
</code></pre>

<hr>
<h2 id='matrix.p.null'>Auxiliar function to generate sets of null P matrix or null PCPS</h2><span id='topic+matrix.p.null'></span>

<h3>Description</h3>

<p>Auxiliar function to generate sets of null P matrix or null PCPS used 
in <code><a href="#topic+matrix.p.sig">matrix.p.sig</a></code> or <code><a href="#topic+pcps.sig">pcps.sig</a></code>. The result are long lists with 
permuted matrices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>matrix.p.null(
  comm,
  phylodist,
  runs = NULL,
  calcpcps = FALSE,
  method = "bray",
  squareroot = TRUE,
  adjpcps = FALSE,
  choices = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="matrix.p.null_+3A_comm">comm</code></td>
<td>
<p>Community data, with species as columns and sampling units as rows. This matrix 
can contain either presence/absence or abundance data.</p>
</td></tr>
<tr><td><code id="matrix.p.null_+3A_phylodist">phylodist</code></td>
<td>
<p>Matrix containing phylogenetic distances between species.</p>
</td></tr>
<tr><td><code id="matrix.p.null_+3A_runs">runs</code></td>
<td>
<p>Number of matrix will be generated (Default runs = NULL).</p>
</td></tr>
<tr><td><code id="matrix.p.null_+3A_calcpcps">calcpcps</code></td>
<td>
<p>Logical argument (TRUE or FALSE) to specify if generate the PCPS (Default calcpcps = FALSE).</p>
</td></tr>
<tr><td><code id="matrix.p.null_+3A_method">method</code></td>
<td>
<p>Dissimilarity index, as accepted by <code><a href="vegan.html#topic+vegdist">vegdist</a></code> (Default dist = &quot;bray&quot;).</p>
</td></tr>
<tr><td><code id="matrix.p.null_+3A_squareroot">squareroot</code></td>
<td>
<p>Logical argument (TRUE or FALSE) to specify if use square root of 
dissimilarity index (Default squareroot = TRUE).</p>
</td></tr>
<tr><td><code id="matrix.p.null_+3A_adjpcps">adjpcps</code></td>
<td>
<p>Logical argument (TRUE or FALSE) to specify if return fitted PCPS (Default adjpcps = FALSE).</p>
</td></tr>
<tr><td><code id="matrix.p.null_+3A_choices">choices</code></td>
<td>
<p>Numeric vector to choose the PCPS to adjust (Default pcps.choices = NULL).</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>call</code></td>
<td>
<p>The arguments used.</p>
</td></tr>
<tr><td><code>P.obs</code></td>
<td>
<p>Observed phylogeny-weighted species composition matrix.</p>
</td></tr>
<tr><td><code>pcps.obs</code></td>
<td>
<p>Observed principal coordinates of phylogenetic structure (PCPS).</p>
</td></tr>
<tr><td><code>permutation.site</code></td>
<td>
<p>A matrix with sequence of permutation for site shuffle null model, each permutation in one row.</p>
</td></tr>
<tr><td><code>permutation.taxa</code></td>
<td>
<p>A matrix with sequence of permutation for taxa shuffle null model, each permutation in one row.</p>
</td></tr>
<tr><td><code>P.null.site</code></td>
<td>
<p>A list with each permuted P matrix according with site shuffle null model.</p>
</td></tr>
<tr><td><code>P.null.taxa</code></td>
<td>
<p>A list with each permuted P matrix according with taxa shuffle null model.</p>
</td></tr>
<tr><td><code>pcps.null.site</code></td>
<td>
<p>A list with each permuted PCPS according with site shuffle null model.</p>
</td></tr>
<tr><td><code>pcps.null.taxa</code></td>
<td>
<p>A list with each permuted PCPS according with taxa shuffle null model.</p>
</td></tr>
<tr><td><code>pcps.null.taxa.adj</code></td>
<td>
<p>A list with each permuted PCPS (adjusted) according with taxa shuffle null model.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Vanderlei Julio Debastiani &lt;vanderleidebastiani@yahoo.com.br&gt;
</p>


<h3>See Also</h3>

<p><code><a href="SYNCSA.html#topic+matrix.p">matrix.p</a></code>, <code><a href="#topic+pcps">pcps</a></code>, <code><a href="#topic+matrix.p.sig">matrix.p.sig</a></code>, <code><a href="#topic+pcps.sig">pcps.sig</a></code>
</p>

<hr>
<h2 id='matrix.p.sig'>Association between phylogeny-weighted species composition and environmental predictors</h2><span id='topic+matrix.p.sig'></span><span id='topic+pcps.sig'></span><span id='topic+print.pcpssig'></span><span id='topic+FUN.ADONIS'></span><span id='topic+FUN.ADONIS2.global'></span><span id='topic+FUN.ADONIS2.margin'></span><span id='topic+FUN.GLM'></span><span id='topic+FUN.MANTEL'></span><span id='topic+FUN.RDA'></span><span id='topic+FUN.GLS.marginal'></span><span id='topic+FUN.GLS.sequential'></span><span id='topic+FUN.LME.marginal'></span><span id='topic+FUN.LME.sequential'></span>

<h3>Description</h3>

<p>Analyses to relate an environmental gradient to the phylogenetic assembly of species 
across a metacommunity by means of phylogenetic fuzzy weighting.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>matrix.p.sig(
  comm,
  phylodist,
  envir,
  checkdata = TRUE,
  FUN,
  runs = 999,
  parallel = NULL,
  newname = "pcps",
  ...
)

pcps.sig(
  comm,
  phylodist,
  envir,
  checkdata = TRUE,
  method = "bray",
  squareroot = TRUE,
  FUN,
  choices,
  runs = 999,
  parallel = NULL,
  newname = "pcps",
  ...
)

FUN.ADONIS(x, envir, method.p, sqrt.p = TRUE, formula, return.model = FALSE)

FUN.GLM(x, envir, formula, ..., return.model = FALSE)

FUN.GLS.marginal(x, envir, formula, ..., return.model = FALSE)

FUN.GLS.sequential(x, envir, formula, ..., return.model = FALSE)

FUN.LME.marginal(x, envir, formula, ..., return.model = FALSE)

FUN.LME.sequential(x, envir, formula, ..., return.model = FALSE)

FUN.MANTEL(
  x,
  envir,
  method.p,
  method.envir,
  sqrt.p = TRUE,
  ...,
  return.model = FALSE
)

FUN.RDA(x, envir, return.model = FALSE)

## S3 method for class 'pcpssig'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="matrix.p.sig_+3A_comm">comm</code></td>
<td>
<p>Community data, with species as columns and sampling units as rows. This matrix 
can contain either presence/absence or abundance data.
Alternatively comm can be an object of class metacommunity.data, an alternative
way to set all data.frames/matrices. When you use the class metacommunity.data the arguments
phylodist and envir must not be specified. See details.</p>
</td></tr>
<tr><td><code id="matrix.p.sig_+3A_phylodist">phylodist</code></td>
<td>
<p>Matrix containing phylogenetic distances between species.</p>
</td></tr>
<tr><td><code id="matrix.p.sig_+3A_envir">envir</code></td>
<td>
<p>A matrix or data.frame with environmental variables for each community, with variables as columns and 
sampling units as rows. See Details and Examples.</p>
</td></tr>
<tr><td><code id="matrix.p.sig_+3A_checkdata">checkdata</code></td>
<td>
<p>Logical argument (TRUE or FALSE) to check if species
sequence in the community data follows the same order as the one in the phylodist matrix 
and if sampling units in the community data follows the same order as the one in the 
environmental data (Default checkdata = TRUE).</p>
</td></tr>
<tr><td><code id="matrix.p.sig_+3A_fun">FUN</code></td>
<td>
<p>An object of class function to perform the analysis. See Details and Examples.</p>
</td></tr>
<tr><td><code id="matrix.p.sig_+3A_runs">runs</code></td>
<td>
<p>Number of permutations for assessing significance.</p>
</td></tr>
<tr><td><code id="matrix.p.sig_+3A_parallel">parallel</code></td>
<td>
<p>Number of parallel processes or a predefined socket cluster done with parallel package. Tip: use detectCores() (Default parallel = NULL).</p>
</td></tr>
<tr><td><code id="matrix.p.sig_+3A_newname">newname</code></td>
<td>
<p>New name to be replaced in object returned by <code><a href="#topic+matrix.p.null">matrix.p.null</a></code> (Default newname = &quot;pcps&quot;).</p>
</td></tr>
<tr><td><code id="matrix.p.sig_+3A_...">...</code></td>
<td>
<p>Other arguments passed to FUN function. See Details and Examples.</p>
</td></tr>
<tr><td><code id="matrix.p.sig_+3A_method">method</code></td>
<td>
<p>Dissimilarity index, as accepted by <code><a href="vegan.html#topic+vegdist">vegdist</a></code> (Default dist = &quot;bray&quot;).</p>
</td></tr>
<tr><td><code id="matrix.p.sig_+3A_squareroot">squareroot</code></td>
<td>
<p>Logical argument (TRUE or FALSE) to specify if use square root of 
dissimilarity index (Default squareroot = TRUE).</p>
</td></tr>
<tr><td><code id="matrix.p.sig_+3A_choices">choices</code></td>
<td>
<p>Numeric vector to choose the PCPS used in analysis. See Details and Examples.</p>
</td></tr>
<tr><td><code id="matrix.p.sig_+3A_x">x</code></td>
<td>
<p>An object of class pcpssig or other object to apply the function passed by FUN. See Details.</p>
</td></tr>
<tr><td><code id="matrix.p.sig_+3A_method.p">method.p</code></td>
<td>
<p>Resemblance index between communities based on P matrix, as accepted by <code><a href="vegan.html#topic+vegdist">vegdist</a></code>. 
Used in FUN.MANTEL, FUN.ADONIS, FUN.ADONIS2.global and FUN.ADONIS2.margin analysis. See Details and Examples.</p>
</td></tr>
<tr><td><code id="matrix.p.sig_+3A_sqrt.p">sqrt.p</code></td>
<td>
<p>Logical argument (TRUE or FALSE) to specify if use square root of dissimilarity P matrix. Used in
FUN.MANTEL, FUN.ADONIS, FUN.ADONIS2.global and FUN.ADONIS2.margin analysis. See Details and Examples (Default sqrt.p = TRUE).</p>
</td></tr>
<tr><td><code id="matrix.p.sig_+3A_formula">formula</code></td>
<td>
<p>An object of class <code><a href="stats.html#topic+formula">formula</a></code>. Used in FUN.GLM, FUN.ADONIS, 
FUN.ADONIS2.global, FUN.ADONIS2.margin, FUN.GLS.marginal, FUN.GLS.sequential, FUN.LME.marginal and FUN.LME.sequential analysis. See Details and Examples.</p>
</td></tr>
<tr><td><code id="matrix.p.sig_+3A_return.model">return.model</code></td>
<td>
<p>Must not be specified. See Details.</p>
</td></tr>
<tr><td><code id="matrix.p.sig_+3A_method.envir">method.envir</code></td>
<td>
<p>Resemblance index between communities based on environmental variables, as accepted by <code><a href="vegan.html#topic+vegdist">vegdist</a></code>.
Used in FUN.MANTEL analysis. See Details and Examples.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Each metacommunity is submitted to phylogenetic fuzzy weighting, generating a matrix
that describing the phylogeny-weighted species composition of the communities
(<code><a href="SYNCSA.html#topic+matrix.p">matrix.p</a></code>). The function matrix.p.sig test directly the association 
this matrix with the environmental predictors. The pairwise dissimilarities are 
submitted to Mantel test (<code><a href="vegan.html#topic+mantel">mantel</a></code>) or ADONIS test (<code><a href="vegan.html#topic+adonis">adonis</a></code> or <code><a href="vegan.html#topic+adonis2">adonis2</a></code>)
to evaluate the influence of an environmental gradient on species dispersion across 
the communities. The function pcps.sig generates principal coordinates of phylogenetic
structure (<code><a href="#topic+pcps">pcps</a></code>) and use a single axis for run a generalized linear 
model (GLM, <code><a href="stats.html#topic+glm">glm</a></code>), linear model using generalized least squares (GLS, <code><a href="nlme.html#topic+gls">gls</a></code>),
linear mixed-effects models (LME, <code><a href="nlme.html#topic+lme">lme</a></code>) or use set of axis for run a distance-based redundancy
analysis (db-RDA, <code><a href="vegan.html#topic+rda">rda</a></code>).
</p>
<p>The sequence species show up in the community data matrix must be the 
same as they show up in the phylogenetic distance matrix and, similarly, 
the sequence of communities in the community data matrix must be the same as that in 
the environmental data. The function <code><a href="#topic+organize.pcps">organize.pcps</a></code> organizes the data, placing the matrices of 
community, phylogenetic distance and environmental data in the same order. The function use of function 
organize.pcps is not requered for run the functions, but is recommended. In this way 
the arguments comm and phylodist can be specified them as normal arguments or by passing
them with the object returned by the function <code><a href="#topic+organize.pcps">organize.pcps</a></code> using, in this
case only the argument comm. Using the object returned by organize.pcps, the comm argument 
is used as an alternative way of entering to set all data.frames/matrices, and therefore 
the arguments phylodist and envir must not be specified.
</p>
<p>The significance is obtained via two null models, one that shuffles sites across the
environmental gradient and another that shuffles terminal tips (taxa) across the phylogenetic
tree. The first null model (site shuffle) shuffles the site position across the environmental
gradient and rerun the same model, generating a null F value (or r value in Mantel test). The
second null model (taxa shuffle), shuffles terminal tips across the phylogenetic tree and 
generates a null matrix containing phylogeny-weighted species composition and rerun the same
model, generating another null F value. In the pcps.sig function are generate set of null PCPS
and each null PCPS (or set of PCPS in RDA) is submitted to a procrustean adjustment 
(see <code><a href="vegan.html#topic+procrustes">procrustes</a></code>), and the fitted values between observed PCPS and null PCPS is 
obtained. The adjusted null PCPS is used to rerun the model, generating another null F value. 
The observed F value (or r value) is compared independently with both null sets of F values 
(or r value) to generate a probability value of the original F value being generated merely by
chance according to each null model.
</p>
<p><strong>The argument FUN</strong>
</p>
<p>The type of analysis performed by this function is specified using the argument <em>FUN</em>. The current version 
of package includes ten predefined function, however additional small functions can be easy specify. All
this function uses the environmental variables to analyze the association between phylogeny-weighted species
composition and environmental predictors. For matrix P analysis, in <em>matrix.p.sig</em> function, the predefined 
functions available are <em>FUN.MANTEL</em>, <em>FUN.ADONIS</em>, <em>FUN.ADONIS2.global</em> and <em>FUN.ADONIS2.margin</em>. For PCPS 
analysis, in <em>pcps.sig</em> function, the predefined functions available are <em>FUN.GLM</em>, <em>FUN.RDA</em>, <em>FUN.GLS.marginal</em>, 
<em>FUN.GLS.sequential</em>, <em>FUN.LME.marginal</em> and <em>FUN.LME.sequential</em>. The significance 
for each null model is performed as described here, NOT using p value of basic functions.
</p>
<p><strong>FUN.MANTEL</strong>
</p>
<p>Mantel test that can be used in matrix P analysis. The arguments <em>method.p</em> and <em>sqrt.p</em> are specified for determine resemblance 
index between communities based on P matrix. The argument <em>method.envir</em> is specified to determine resemblance 
index between communities based on environmental variables. The significance is assess using r value, see more in <code><a href="vegan.html#topic+mantel">mantel</a></code>.
</p>
<p><strong>FUN.ADONIS</strong>
</p>
<p>Multivariate analysis of variance that can be used in matrix P analysis. The arguments <em>method.p</em> and <em>sqrt.p</em> are specified for determine resemblance 
index between communities based on P matrix. The argument <em>formula</em> is specified, where the left hand side gives 
the resemblance data, right hand side gives the variables. The resemblance data is internally named <em>p.dist</em>, 
thus formula is an expression of the form <em>p.dist ~ model</em> (see Examples). The significance is assess using overall F value, 
see more in <code><a href="vegan.html#topic+adonis">adonis</a></code>.
</p>
<p><strong>FUN.ADONIS2.global and FUN.ADONIS2.margin</strong>
</p>
<p>Multivariate analysis of variance that can be used in matrix P analysis. The arguments <em>method.p</em> and <em>sqrt.p</em> are specified for determine resemblance 
index between communities based on P matrix. The argument <em>formula</em> is specified, where the left hand side gives 
the resemblance data, right hand side gives the variables. The resemblance data is internally named <em>p.dist</em>, 
thus formula is an expression of the form <em>p.dist ~ model</em> (see Examples). The significance is assess using F value 
and the difference between function is due to the argument <em>by</em> in <code><a href="vegan.html#topic+adonis2">adonis2</a></code>. The function 
<em>FUN.ADONIS2.global</em> use as default <em>by = NULL</em> to assess the overall significance of all terms together
whereas the function <em>FUN.ADONIS2.margin</em> use as default <em>by = margin</em> to assess the marginal effects of 
the terms and return F and p value for each term. See more in <code><a href="vegan.html#topic+adonis2">adonis2</a></code>.
</p>
<p>The function <code><a href="vegan.html#topic+adonis2">adonis2</a></code> evaluate the formula argument in the global environment, however CRAN 
do not allow assignments to the global environment. As a temporary workaround, copy and run the lines below to make 
the functions FUN.ADONIS2.global and FUN.ADONIS2.margin available.
</p>
<pre>

FUN.ADONIS2.global &lt;- function(x, envir, method.p, formula, sqrt.p = TRUE, return.model = FALSE){
p.dist &lt;- vegan::vegdist(x, method = method.p)
if(sqrt.p){
  p.dist &lt;- sqrt(p.dist)
}
assign("p.dist", p.dist, envir = globalenv())
mod.obs &lt;- vegan::adonis2(formula, data = data.frame(envir), permutations = 0, by = NULL, parallel = NULL)
rm(p.dist, envir = globalenv())
statistic.obs &lt;- mod.obs$F[1]
if(return.model){
  res &lt;- list()
  res$mod.obs &lt;- mod.obs
  res$statistic.obs &lt;- statistic.obs
} else{
  res &lt;- statistic.obs
}
return(res)
}

FUN.ADONIS2.margin &lt;- function(x, envir, method.p, formula, sqrt.p = TRUE, return.model = FALSE){
p.dist &lt;- vegan::vegdist(x, method = method.p)
if(sqrt.p){
  p.dist &lt;- sqrt(p.dist)
}
assign("p.dist", p.dist, envir = globalenv())
mod.obs &lt;- vegan::adonis2(formula, data = data.frame(envir), permutations = 2, by = "margin", parallel = NULL)
rm(p.dist, envir = globalenv())
nf &lt;- length(mod.obs$F)-2
statistic.obs &lt;- mod.obs$F[seq_len(nf)]
if(return.model){
  res &lt;- list()
  res$mod.obs &lt;- mod.obs
  res$statistic.obs &lt;- statistic.obs
} else{
  res &lt;- statistic.obs
}
return(res)
}

</pre>
<p><strong>FUN.GLM</strong>
</p>
<p>Generalized linear models that can be used in PCPS analysis. The argument <em>formula</em> is specified, where the left hand side gives the PCPS used, 
right hand side gives the variables. The PCPS are internally named sequentially <em>pcps.1</em>, <em>pcps.2</em>, <em>pcps.3</em> and so 
on. Thus, formula is an expression of the form <em>pcps.1 ~ model</em> (see Examples). The type of environmental variables are 
extracted directly from <em>envir</em> argument, thus variables of class <code><a href="base.html#topic+factor">factor</a></code> can be already
specified in <em>envir</em> <code><a href="base.html#topic+data.frame">data.frame</a></code> or through <em>formula</em> argument. The significance is assess using overall 
F value, see more in <code><a href="stats.html#topic+glm">glm</a></code>.
</p>
<p><strong>FUN.RDA</strong>
</p>
<p>Redundancy analysis that can be used in PCPS analysis. The RDA analysis is performed using all PCPS specified with choices argument and 
all environmental variables specified by envir argument. The significance is assess using overall 
F value, see more in <code><a href="vegan.html#topic+rda">rda</a></code>.
</p>
<p><strong>FUN.GLS.marginal and FUN.GLS.sequential</strong>
</p>
<p>Linear model using generalized least squares that can be used in PCPS analysis. The argument <em>formula</em> is specified, where the left hand side gives the PCPS used, 
right hand side gives the variables. The PCPS are internally named sequentially <em>pcps.1</em>, <em>pcps.2</em>, <em>pcps.3</em> and so 
on. Thus, formula is an expression of the form <em>pcps.1 ~ model</em> (see Examples). The type of environmental variables are 
extracted directly from <em>envir</em> argument, thus variables of class <code><a href="base.html#topic+factor">factor</a></code> can be already
specified in <em>envir</em> <code><a href="base.html#topic+data.frame">data.frame</a></code> or through <em>formula</em> argument. The significance is assess using F value 
and the difference between function is due to the argument <em>type</em> in <code><a href="nlme.html#topic+anova.gls">anova.gls</a></code>. The function 
<em>FUN.GLS.marginal</em> use as default <em>type = marginal</em> to assess the marginal significance of all terms
whereas the function <em>FUN.GSL.sequential</em> use as default <em>type = sequential</em> to assess the sequential effects of 
the terms. Those funcitons return all F values calculed by <code><a href="nlme.html#topic+anova.gls">anova.gls</a></code>, including the intercept if it is in the model. 
Additional arguments as <em>correlation</em> can be passed by <em>...</em> argument. See more in <code><a href="nlme.html#topic+gls">gls</a></code> and <code><a href="nlme.html#topic+anova.gls">anova.gls</a></code>.
</p>
<p><strong>FUN.LME.marginal and FUN.LME.sequential</strong>
</p>
<p>Linear mixed-effects models that can be used in PCPS analysis. The argument <em>formula</em> is specified, where the left hand side gives the PCPS used, 
right hand side gives the variables. The PCPS are internally named sequentially <em>pcps.1</em>, <em>pcps.2</em>, <em>pcps.3</em> and so 
on. Thus, formula is an expression of the form <em>pcps.1 ~ model</em> (see Examples). The type of environmental variables are 
extracted directly from <em>envir</em> argument, thus variables of class <code><a href="base.html#topic+factor">factor</a></code> can be already
specified in <em>envir</em> <code><a href="base.html#topic+data.frame">data.frame</a></code> or through <em>formula</em> argument. The significance is assess using F value 
and the difference between function is due to the argument <em>type</em> in <code><a href="nlme.html#topic+anova.lme">anova.lme</a></code>. The function 
<em>FUN.LME.marginal</em> use as default <em>type = marginal</em> to assess the marginal significance of all terms
whereas the function <em>FUN.LME.sequential</em> use as default <em>type = sequential</em> to assess the sequential effects of 
the terms. Those funcitons return all F values calculed by <code><a href="nlme.html#topic+anova.lme">anova.lme</a></code>, including the intercept if it is in the model. 
Additional arguments as <em>correlation</em> and <em>random</em> can be passed by <em>...</em> argument. See more in <code><a href="nlme.html#topic+lme">lme</a></code> and <code><a href="nlme.html#topic+anova.lme">anova.lme</a></code>.
</p>
<p><strong>Additional function</strong>
</p>
<p>The functions <em>matrix.p.sig</em> and <em>pcps.sig</em> only perform permutation following null models and apply the functions in all 
permuted matrices. Additional functions can be easy specify and passed via <em>FUN</em> argument. A skeleton of this function is slowed 
below. In this function the argument <em>x</em> will be always the matrix P or one matrix with PCPS choose, when additional arguments
as <em>envir</em> will specify statistical analysis performed in matrix P ou PCPS. This function must return the observed statistical in addition the
<em>return.model</em> argument must not be specified because it specify the return options used for observed and null statistics.
</p>
<pre>FUN.X &lt;- function(x, envir, ..., return.model = FALSE){
  mod.obs &lt;- # Function to perform analysis using x, envir and any additional argument
  statistic.obs &lt;- # Extract only the numeric values of observed statistical
  # Next lines are mandatory
   if(return.model){
      res &lt;- list()
      res$mod.obs &lt;- mod.obs
      res$statistic.obs &lt;- statistic.obs
    } else{
      res &lt;- statistic.obs
    }
  return(res) 
}</pre>


<h3>Value</h3>

<table>
<tr><td><code>call</code></td>
<td>
<p>The arguments used.</p>
</td></tr>
<tr><td><code>P.obs</code></td>
<td>
<p>Phylogeny-weighted species composition matrix.</p>
</td></tr>
<tr><td><code>PCPS.obs</code></td>
<td>
<p>The principal coordinates of phylogenetic structure (PCPS)</p>
</td></tr>
<tr><td><code>model</code></td>
<td>
<p>The observed model returned by FUN, an object of class glm, gls, lme, rda, adonis, adonis2 or mantel to predefined function.</p>
</td></tr>
<tr><td><code>fun</code></td>
<td>
<p>The funtion used.</p>
</td></tr>
<tr><td><code>statistic.null.site</code></td>
<td>
<p>A matrix with null statistic for site shuffle null model.</p>
</td></tr>
<tr><td><code>statistic.null.taxa</code></td>
<td>
<p>A matrix with null statistic for taxa shuffle null model.</p>
</td></tr>
<tr><td><code>obs.statistic</code></td>
<td>
<p>Observed statistic, F value or r value to predefined function.</p>
</td></tr>
<tr><td><code>p.site.shuffle</code></td>
<td>
<p>The p value for the site shuffle null model.</p>
</td></tr>
<tr><td><code>p.taxa.shuffle</code></td>
<td>
<p>The p value for the taxa shuffle null model.</p>
</td></tr>
</table>


<h3>Note</h3>

<p><strong>IMPORTANT</strong>: The sequence of species in the community data matrix
MUST be the same as that in the phylogenetic distance matrix and, similarly, 
the sequence of communities in the community data matrix MUST be the same as that in 
the environmental data. See details and <code><a href="#topic+organize.pcps">organize.pcps</a></code>.
</p>


<h3>Author(s)</h3>

<p>Vanderlei Julio Debastiani &lt;vanderleidebastiani@yahoo.com.br&gt;
</p>


<h3>References</h3>

<p>Duarte, L.S. (2011). Phylogenetic habitat filtering influences forest 
nucleation in grasslands. Oikos, 120, 208:215.
</p>
<p>Duarte, L.S. (2016). Dissecting phylogenetic fuzzy weighting: theory and application 
in metacommunity phylogenetics. Methods in Ecology and Evolution, 7(8), 937:946.
</p>


<h3>See Also</h3>

<p><code><a href="SYNCSA.html#topic+matrix.p">matrix.p</a></code>, <code><a href="#topic+pcps">pcps</a></code>, <code><a href="vegan.html#topic+procrustes">procrustes</a></code>, 
<code><a href="stats.html#topic+glm">glm</a></code>, <code><a href="vegan.html#topic+rda">rda</a></code>, <code><a href="vegan.html#topic+adonis">adonis</a></code>, <code><a href="vegan.html#topic+adonis2">adonis2</a></code>, 
<code><a href="vegan.html#topic+mantel">mantel</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
data(flona)

# MANTEL
res &lt;- matrix.p.sig(flona$community,flona$phylo, FUN = FUN.MANTEL, method.p = "bray", 
             method.envir = "euclidean", envir = flona$environment[, 2, drop = FALSE], runs = 99)
res

# ADONIS
res &lt;- matrix.p.sig(flona$community,flona$phylo, FUN = FUN.ADONIS, method.p = "bray", 
             formula = p.dist~temp, envir = flona$environment[, 2, drop = FALSE], runs = 99)
res

# ADONIS2
res &lt;- matrix.p.sig(flona$community,flona$phylo, FUN = FUN.ADONIS2.global, 
             envir = flona$environment, formula = p.dist~temp+alt, 
             method.p = "bray", runs = 99)
res            
res &lt;- matrix.p.sig(flona$community,flona$phylo, FUN = FUN.ADONIS2.margin, 
              envir = flona$environment, formula = p.dist~temp+alt, 
              method.p = "bray", runs = 99)
res            

# GLM
res &lt;- pcps.sig(flona$community, flona$phylo, FUN = FUN.GLM, method = "bray", 
         formula = pcps.1~temp, envir = flona$environment, choices = 1, runs = 99)
res
summary.lm(res$model)

# RDA
res &lt;- pcps.sig(flona$community, flona$phylo, FUN = FUN.RDA, envir = flona$environment, 
         choices = 1:2, runs = 99)
res

# GLS
res &lt;- pcps.sig(flona$community, flona$phylo, FUN = FUN.GLS.marginal, 
         formula = pcps.1~temp, envir = flona$environment, choices = 1, runs = 99)
res
anova(res$model, type = "marginal")

res &lt;- pcps.sig(flona$community, flona$phylo, FUN = FUN.GLS.marginal, 
         formula = pcps.1~temp, envir = flona$environment, 
         correlation = nlme::corCAR1(form = ~1:39), choices = 1, runs = 99)
res
anova(res$model, type = "marginal")

# LME
res &lt;- pcps.sig(flona$community, flona$phylo, FUN = FUN.LME.marginal, formula = pcps.1~alt, 
         envir = flona$environment, random = ~1|temp, choices = 1, runs = 99)
res
anova(res$model, type = "marginal")

res &lt;- pcps.sig(flona$community, flona$phylo, FUN = FUN.LME.sequential, formula = pcps.1~alt,
         envir = flona$environment, random = ~1|temp, choices = 1, runs = 99)
res
anova(res$model, type = "sequential")

## End(Not run)

</code></pre>

<hr>
<h2 id='mutate.names.matrix.p.null'>Internal function</h2><span id='topic+mutate.names.matrix.p.null'></span>

<h3>Description</h3>

<p>Internal function to perform replacement names in object returned by <code><a href="#topic+matrix.p.null">matrix.p.null</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mutate.names.matrix.p.null(x, replacement, newname)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mutate.names.matrix.p.null_+3A_x">x</code></td>
<td>
<p>An object returned by <code><a href="#topic+matrix.p.null">matrix.p.null</a></code>.</p>
</td></tr>
<tr><td><code id="mutate.names.matrix.p.null_+3A_replacement">replacement</code></td>
<td>
<p>A replacement name to matched in object returned by <code><a href="#topic+matrix.p.null">matrix.p.null</a></code>.</p>
</td></tr>
<tr><td><code id="mutate.names.matrix.p.null_+3A_newname">newname</code></td>
<td>
<p>New name to be replaced in object returned by <code><a href="#topic+matrix.p.null">matrix.p.null</a></code>.</p>
</td></tr>
</table>

<hr>
<h2 id='organize.pcps'>Function for organize data for Package PCPS</h2><span id='topic+organize.pcps'></span>

<h3>Description</h3>

<p>Package <strong>PCPS</strong> requires that the species and community sequence in
the data.frame or matrix must be the same for all data.frame/matrices. 
This function use the function <code><a href="SYNCSA.html#topic+organize.syncsa">organize.syncsa</a></code> to organize the data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>organize.pcps(comm, phylodist = NULL, envir = NULL, check.comm = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="organize.pcps_+3A_comm">comm</code></td>
<td>
<p>Community data, with species as columns and sampling units as
rows.</p>
</td></tr>
<tr><td><code id="organize.pcps_+3A_phylodist">phylodist</code></td>
<td>
<p>Matrix containing phylogenetic distance between species.
Must be a complete matrix (not a half diagonal matrix).This matrix can be
larger than community data (more species) as long as it has at least all
species that are in community data (Default phylodist = NULL).</p>
</td></tr>
<tr><td><code id="organize.pcps_+3A_envir">envir</code></td>
<td>
<p>Environmental variables for each community, with variables as
columns and sampling units as rows (Default envir = NULL).</p>
</td></tr>
<tr><td><code id="organize.pcps_+3A_check.comm">check.comm</code></td>
<td>
<p>Logical argument (TRUE or FALSE) to remove sampling units and
species with total sums equal or less than zero (Default check.comm = TRUE).</p>
</td></tr>
<tr><td><code id="organize.pcps_+3A_...">...</code></td>
<td>
<p>Other parameters for the organize.syncsa function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function, as well as organize.syncsa, organizes the data for the functions of the package
PCPS, placing the matrices of community, phylogenetic distance and environmental varibles in the same order.
</p>
<p>Essentially this function is the same as function <code><a href="SYNCSA.html#topic+organize.syncsa">organize.syncsa</a></code>. This 
use as reference the community data for organize all data.frame or matrices
in the same order that the sampling units names and species names found in community
data set. For this all data sets entered must be correctly named, with rows and columns
named. The matrices phylodist and envir can be larger than community
data (more species and/or more sampling units) as long as it has at least
all species and/or sampling units that are in community data. The function
organizes the data despite the absence of one of the data.frames or matrices,
provided that the community data had been entered. Unspecified data will
appear as NULL. All arguments this funtion will be passed to organize.syncsa, 
see more details in <code><a href="SYNCSA.html#topic+organize.syncsa">organize.syncsa</a></code>.
</p>


<h3>Value</h3>

<p>A object of class metacommunity.data (also of the class list) with all result returned by organize.syncsa. Featured for:
</p>
<table>
<tr><td><code>call</code></td>
<td>
<p>The arguments used.</p>
</td></tr>
<tr><td><code>community</code></td>
<td>
<p>Community data.</p>
</td></tr>
<tr><td><code>phylodist</code></td>
<td>
<p>Phylogenetic distance.</p>
</td></tr>
<tr><td><code>environmental</code></td>
<td>
<p>Environmental variables.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Vanderlei Julio Debastiani &lt;vanderleidebastiani@yahoo.com.br&gt;
</p>


<h3>See Also</h3>

<p><code><a href="SYNCSA.html#topic+organize.syncsa">organize.syncsa</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ADRS)
organize.pcps(ADRS$community, phylodist = ADRS$phylo)
</code></pre>

<hr>
<h2 id='pcoa.sig'>Significant dimensions in principal coordinate analysis</h2><span id='topic+pcoa.sig'></span><span id='topic+print.pcoasig'></span><span id='topic+summary.pcoasig'></span><span id='topic+print.summarypcoasig'></span>

<h3>Description</h3>

<p>Function for determine the number of significant dimensions in principal coordinate analysis (PCoA).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pcoa.sig(
  data,
  method = "gower",
  squareroot = FALSE,
  axis = 6,
  n.start = NULL,
  by = 1,
  iterations = 1000,
  parallel = NULL
)

## S3 method for class 'pcoasig'
print(x, ...)

## S3 method for class 'summarypcoasig'
print(x, ...)

## S3 method for class 'pcoasig'
summary(object, choices = c(1, 2), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pcoa.sig_+3A_data">data</code></td>
<td>
<p>Community data matrix.</p>
</td></tr>
<tr><td><code id="pcoa.sig_+3A_method">method</code></td>
<td>
<p>Method for dissimilarity index, as accepted by <code><a href="vegan.html#topic+vegdist">vegdist</a></code> (Default method = &quot;gower&quot;).</p>
</td></tr>
<tr><td><code id="pcoa.sig_+3A_squareroot">squareroot</code></td>
<td>
<p>Logical argument (TRUE or FALSE) to specify if use square root of dissimilarity 
index (Default squareroot = FALSE).</p>
</td></tr>
<tr><td><code id="pcoa.sig_+3A_axis">axis</code></td>
<td>
<p>Maximum number of ordination principal axes to be monitored (Default axis = 6).</p>
</td></tr>
<tr><td><code id="pcoa.sig_+3A_n.start">n.start</code></td>
<td>
<p>Initial sample size. If n.start = NULL 
initial sample size is equal to total sample size (Default n.start = NULL).</p>
</td></tr>
<tr><td><code id="pcoa.sig_+3A_by">by</code></td>
<td>
<p>Sampling unit is added at each sampling step (Default by = 1).</p>
</td></tr>
<tr><td><code id="pcoa.sig_+3A_iterations">iterations</code></td>
<td>
<p>Number of permutations to assess significance (Default iterations = 1000).</p>
</td></tr>
<tr><td><code id="pcoa.sig_+3A_parallel">parallel</code></td>
<td>
<p>Number of parallel processes or a predefined socket cluster done with parallel package. Tip: use detectCores() (Default parallel = NULL).</p>
</td></tr>
<tr><td><code id="pcoa.sig_+3A_x">x</code></td>
<td>
<p>An object of class pcoasig.</p>
</td></tr>
<tr><td><code id="pcoa.sig_+3A_...">...</code></td>
<td>
<p>Other parameters for the respective functions.</p>
</td></tr>
<tr><td><code id="pcoa.sig_+3A_object">object</code></td>
<td>
<p>An object of class pcoasig.</p>
</td></tr>
<tr><td><code id="pcoa.sig_+3A_choices">choices</code></td>
<td>
<p>Axes for re-scaling. Choices must have length equal to two (Default choices = c(1, 2)).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>At each iteration step a bootstrap sample is subjected to PCoA ordination, the scores are submitted 
to a procrustean adjustment, and the correlation between observed and bootstrap ordination scores 
is computed. It compares such correlations to the same parameter generated in a parallel bootstrapped
ordination of randomly permuted data. The number of axes in bootstrap or null PCoA with eigenvectors 
corresponding to positive eigenvalues may be smaller than the number of axes monitored, in this case, 
axes with values equal to 0 are created. The number of iterations with original values for each axis 
is shown in n.permut.bootstrap and n.permut.null. 
</p>
<p>The function scores.pcoasig re-scales the correlation values for <code><a href="stats.html#topic+biplot">biplot</a></code> graphics.
</p>


<h3>Value</h3>

<table>
<tr><td><code>value</code></td>
<td>
<p>The eigenvalues, relative eigenvalues and cumulative relative eigenvalues..</p>
</td></tr> 
<tr><td><code>vectors</code></td>
<td>
<p>The principal coordinates.</p>
</td></tr> <tr><td><code>correlations</code></td>
<td>
<p>Correlations
between axis and original data.</p>
</td></tr> <tr><td><code>mean.cor.null</code></td>
<td>
<p>Mean correlations, for axis, between null and reference
scores.</p>
</td></tr> <tr><td><code>mean.cor.bootstrap</code></td>
<td>
<p>Mean correlations, for axis, between bootstrap and reference scores.</p>
</td></tr>
<tr><td><code>n.permut.bootstrap</code></td>
<td>
<p>Number of iterations for each axis in bootstrap step.</p>
</td></tr>
<tr><td><code>n.permut.null</code></td>
<td>
<p>Number of iterations for each axis in null step.</p>
</td></tr> <tr><td><code>probabilities</code></td>
<td>
<p>Probabilities for each axis.</p>
</td></tr>
</table>


<h3>Note</h3>

<p><strong>Principal Component Analysis (PCA)</strong>
</p>
<p>You can use the same function to determine the number of significant dimensions in principal component 
analysis (PCA). For this, standardize each variable for zero mean and uni variance (function decostand
and method standardize) and use euclidean distance as dissimilarity index.
</p>
<p><strong>Interpretation</strong>
</p>
<p>If the higher dimension is significant, then all lower dimensions will also be significant.
</p>


<h3>Author(s)</h3>

<p>Vanderlei Julio Debastiani &lt;vanderleidebastiani@yahoo.com.br&gt;
</p>


<h3>References</h3>

<p>Pillar, V.D. (1999). The bootstrapped ordination reexamined. Journal of Vegetation Science 10, 895-902.
</p>


<h3>See Also</h3>

<p><code><a href="ape.html#topic+pcoa">pcoa</a></code>, <code><a href="vegan.html#topic+procrustes">procrustes</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
data(flona)
res&lt;-pcoa.sig(flona$community, method = "bray", squareroot = TRUE, axis = 6, iterations = 100)
res
summary(res)$scores

## End(Not run)

</code></pre>

<hr>
<h2 id='pcps'>Principal Coordinates of Phylogenetic Structure</h2><span id='topic+pcps'></span><span id='topic+print.pcps'></span><span id='topic+summary.pcps'></span><span id='topic+print.summarypcps'></span><span id='topic+plot.pcps'></span><span id='topic+scores.pcps'></span>

<h3>Description</h3>

<p>Function to generate Principal Coordinates of Phylogenetic Structure (PCPS).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pcps(
  comm,
  phylodist,
  checkdata = TRUE,
  method = "bray",
  squareroot = TRUE,
  correlations = TRUE
)

## S3 method for class 'pcps'
plot(
  x,
  groups = NULL,
  choices = c(1, 2),
  display = "text",
  showlabel = TRUE,
  ...
)

## S3 method for class 'pcps'
print(x, ...)

## S3 method for class 'summarypcps'
print(x, ...)

scores.pcps(x, choices = c(1, 2), ...)

## S3 method for class 'pcps'
summary(object, choices = c(1, 2), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pcps_+3A_comm">comm</code></td>
<td>
<p>Community data, with species as columns and sampling units as rows. 
This matrix can contain either presence/absence or abundance data.
Alternatively comm can be an object of class metacommunity.data, an alternative
way to set all data.frames/matrices. When you use the class metacommunity.data the argument
phylodist must not be specified. See details.</p>
</td></tr>
<tr><td><code id="pcps_+3A_phylodist">phylodist</code></td>
<td>
<p>Matrix containing phylogenetic distances between species.</p>
</td></tr>
<tr><td><code id="pcps_+3A_checkdata">checkdata</code></td>
<td>
<p>Logical argument (TRUE or FALSE) to check if species
sequence in the community data follows the same order as the one in the phylodist 
matrix (Default checkdata = TRUE).</p>
</td></tr>
<tr><td><code id="pcps_+3A_method">method</code></td>
<td>
<p>Dissimilarity index, as accepted by <code><a href="vegan.html#topic+vegdist">vegdist</a></code> (Default dist=&quot;bray&quot;).</p>
</td></tr>
<tr><td><code id="pcps_+3A_squareroot">squareroot</code></td>
<td>
<p>Logical argument (TRUE or FALSE) to specify if use square root of 
dissimilarity index (Default squareroot = TRUE).</p>
</td></tr>
<tr><td><code id="pcps_+3A_correlations">correlations</code></td>
<td>
<p>Logical argument (TRUE or FALSE) to specify if are calculed the correlations
between each PCPS and each species in matrix P (Default correlations = TRUE).</p>
</td></tr>
<tr><td><code id="pcps_+3A_x">x</code></td>
<td>
<p>An object of class pcps.</p>
</td></tr>
<tr><td><code id="pcps_+3A_groups">groups</code></td>
<td>
<p>Factor giving the groups (Clades) for each species  (Default groups = NULL).</p>
</td></tr>
<tr><td><code id="pcps_+3A_choices">choices</code></td>
<td>
<p>Axes for re-scaling. Choices must have length equal to two (Default choices = c(1, 2)).</p>
</td></tr>
<tr><td><code id="pcps_+3A_display">display</code></td>
<td>
<p>Display text or points for the sampling units, partial match to &quot;text&quot; or &quot;points&quot; (Default display = &quot;text&quot;).</p>
</td></tr>
<tr><td><code id="pcps_+3A_showlabel">showlabel</code></td>
<td>
<p>Label the groups by their names in the centroid of the object.</p>
</td></tr>
<tr><td><code id="pcps_+3A_...">...</code></td>
<td>
<p>Other parameters for the respective functions.</p>
</td></tr>
<tr><td><code id="pcps_+3A_object">object</code></td>
<td>
<p>An object of class pcps.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function obtains a matrix containing phylogeny-weighted species composition 
(<code><a href="SYNCSA.html#topic+matrix.p">matrix.p</a></code>) and is submitted to principal coordinates analysis (PCoA). 
This method generates the principal coordinates of phylogenetic structure 
(PCPS) (Duarte, 2011).
</p>
<p>The sequence species show up in the community data matrix must be the 
same as they show up in the phylogenetic distance matrix. The 
function <code><a href="#topic+organize.pcps">organize.pcps</a></code> organizes the data, placing the matrices of 
community and phylogenetic distance in the same order. The use of  
organize.pcps is not requered for run this function, but is recommended. In this way 
the arguments comm and phylodist can be specified them as normal arguments or by passing
them with the object returned by the function <code><a href="#topic+organize.pcps">organize.pcps</a></code> using, in this
case only the argument comm. Using the object returned by organize.pcps, the comm argument 
is used as an alternative way of entering to set all data.frames/matrices, and therefore 
the phylodist argument must not be specified.
</p>
<p>The function summary or the function scores.pcps re-scales the correlation values 
for obtain the scores for <code><a href="stats.html#topic+biplot">biplot</a></code> graphics. The function plot draws a 
simple biplot and represent clades as &quot;spider&quot; graphs (see <code><a href="vegan.html#topic+ordispider">ordispider</a></code>).
</p>


<h3>Value</h3>

<table>
<tr><td><code>P</code></td>
<td>
<p>Phylogeny-weighted species composition matrix.</p>
</td></tr> <tr><td><code>values</code></td>
<td>
<p>The eigenvalues, 
relative eigenvalues and cumulative relative eigenvalues.</p>
</td></tr> <tr><td><code>vectors</code></td>
<td>
<p>The principal coordinates
of phylogenetic structure (PCPS).</p>
</td></tr> <tr><td><code>correlations</code></td>
<td>
<p>Correlations between a PCPS axis and 
phylogenetically weighted species abundances or frequencies.</p>
</td></tr> <tr><td><code>scores</code></td>
<td>
<p>Scores for biplot graphics.</p>
</td></tr>
</table>


<h3>Note</h3>

<p><strong>IMPORTANT</strong>: The sequence species show up in the community data matrix MUST be the 
same as they show up in the phylogenetic distance matrix. See details and <code><a href="#topic+organize.pcps">organize.pcps</a></code>.
</p>


<h3>Author(s)</h3>

<p>Vanderlei Julio Debastiani &lt;vanderleidebastiani@yahoo.com.br&gt;
</p>


<h3>References</h3>

<p>Duarte, L.S. (2011). Phylogenetic habitat filtering influences forest nucleation 
in grasslands. Oikos, 120, 208:215.
</p>


<h3>See Also</h3>

<p><code><a href="SYNCSA.html#topic+matrix.p">matrix.p</a></code>, <code><a href="vegan.html#topic+wcmdscale">wcmdscale</a></code>, <code><a href="vegan.html#topic+ordispider">ordispider</a></code>, <code><a href="vegan.html#topic+ordilabel">ordilabel</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(ADRS)
res&lt;-pcps(ADRS$community, ADRS$phylo)
res
summary(res)
summary(res, choices = c(1, 2))$scores
plot(res, display = "text", groups = c(rep("Clade-A", 2), rep("Clade-B", 4)))

</code></pre>

<hr>
<h2 id='pcps.curve'>Curve of phylogenetic signal at metacommunity level</h2><span id='topic+pcps.curve'></span><span id='topic+print.pcpscurve'></span><span id='topic+summary.pcpscurve'></span><span id='topic+plot.pcpscurve'></span><span id='topic+pcpc.curve.calc'></span>

<h3>Description</h3>

<p>The function estimate the phylogenetic signal at metacommunity level and draws
a representation curve.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pcps.curve(
  comm,
  phylodist,
  trait,
  checkdata = TRUE,
  method = "bray",
  squareroot = TRUE,
  ranks = TRUE,
  null.model.ts = FALSE,
  null.model.bm = FALSE,
  tree,
  runs = 99,
  progressbar = FALSE,
  parallel = NULL
)

pcpc.curve.calc(values, vectors, mt)

## S3 method for class 'pcpscurve'
plot(
  x,
  draw.model = c("none", "ts", "bm"),
  type = "b",
  probs = c(0.025, 0.975),
  col = "black",
  model.col = "black",
  ...
)

## S3 method for class 'pcpscurve'
print(x, ...)

## S3 method for class 'pcpscurve'
summary(object, probs = c(0.025, 0.975), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pcps.curve_+3A_comm">comm</code></td>
<td>
<p>Community data, with species as columns and sampling units as rows. This 
matrix can contain either presence/absence or abundance data.
Alternatively comm can be an object of class metacommunity.data, an alternative
way to set all data.frames/matrices. When you use the class metacommunity.data the arguments
trait and phylodist must not be specified. See details.</p>
</td></tr>
<tr><td><code id="pcps.curve_+3A_phylodist">phylodist</code></td>
<td>
<p>Matrix containing phylogenetic distances between species.</p>
</td></tr>
<tr><td><code id="pcps.curve_+3A_trait">trait</code></td>
<td>
<p>Matrix data of species described by traits, with traits as columns and species as rows.</p>
</td></tr>
<tr><td><code id="pcps.curve_+3A_checkdata">checkdata</code></td>
<td>
<p>Logical argument (TRUE or FALSE) to check if species
sequence in the community data follows the same order as the one in the
trait and in the phylodist matrices (Default checkdata = TRUE).</p>
</td></tr>
<tr><td><code id="pcps.curve_+3A_method">method</code></td>
<td>
<p>Dissimilarity index, as accepted by <code><a href="vegan.html#topic+vegdist">vegdist</a></code> (Default dist = &quot;bray&quot;).</p>
</td></tr>
<tr><td><code id="pcps.curve_+3A_squareroot">squareroot</code></td>
<td>
<p>Logical argument (TRUE or FALSE) to specify if use square root of dissimilarity
index (Default squareroot = TRUE).</p>
</td></tr>
<tr><td><code id="pcps.curve_+3A_ranks">ranks</code></td>
<td>
<p>Logical argument (TRUE or FALSE) to specify if ordinal variables are 
convert to ranks (Default ranks = TRUE).</p>
</td></tr>
<tr><td><code id="pcps.curve_+3A_null.model.ts">null.model.ts</code></td>
<td>
<p>Logical argument (TRUE or FALSE) to specify if use null model that shuffles
terminal tips across the phylogenetic tree to generate null curves. See details (Default null.model.ts = FALSE).</p>
</td></tr>
<tr><td><code id="pcps.curve_+3A_null.model.bm">null.model.bm</code></td>
<td>
<p>Logical argument (TRUE or FALSE) to specify if use null model that simulate 
trait evolving under Brownian motion to generate null curves. See details (Default null.model.bm = FALSE).</p>
</td></tr>
<tr><td><code id="pcps.curve_+3A_tree">tree</code></td>
<td>
<p>Phylogenetic tree, as phylo object.</p>
</td></tr>
<tr><td><code id="pcps.curve_+3A_runs">runs</code></td>
<td>
<p>Number of randomizations.</p>
</td></tr>
<tr><td><code id="pcps.curve_+3A_progressbar">progressbar</code></td>
<td>
<p>Logical argument (TRUE or FALSE) to specify if display a progress bar 
on the R console (Default progressbar = FALSE).</p>
</td></tr>
<tr><td><code id="pcps.curve_+3A_parallel">parallel</code></td>
<td>
<p>Number of parallel processes or a predefined socket cluster done with parallel package. Tip: use detectCores() (Default parallel = NULL).</p>
</td></tr>
<tr><td><code id="pcps.curve_+3A_values">values</code></td>
<td>
<p>The eigenvalues, relative eigenvalues and cumulative relative eigenvalues returned by <code><a href="#topic+pcps">pcps</a></code>.</p>
</td></tr>
<tr><td><code id="pcps.curve_+3A_vectors">vectors</code></td>
<td>
<p>The principal coordinates of phylogenetic structure returned by <code><a href="#topic+pcps">pcps</a></code>.</p>
</td></tr>
<tr><td><code id="pcps.curve_+3A_mt">mt</code></td>
<td>
<p>Matrix containing trait average at community level for one trait.</p>
</td></tr>
<tr><td><code id="pcps.curve_+3A_x">x</code></td>
<td>
<p>An object of class pcpscurve.</p>
</td></tr>
<tr><td><code id="pcps.curve_+3A_draw.model">draw.model</code></td>
<td>
<p>Type of null model to draw; none (none), taxa shuffle (ts), browian motion model (bm).</p>
</td></tr>
<tr><td><code id="pcps.curve_+3A_type">type</code></td>
<td>
<p>Type of the plot to be drawn (Default type = &quot;b&quot;).</p>
</td></tr>
<tr><td><code id="pcps.curve_+3A_probs">probs</code></td>
<td>
<p>Numeric vector of probabilities used by <code><a href="stats.html#topic+quantile">quantile</a></code>. (Default probs = c(0.025, 0.975)).</p>
</td></tr>
<tr><td><code id="pcps.curve_+3A_col">col</code></td>
<td>
<p>Plot color.</p>
</td></tr>
<tr><td><code id="pcps.curve_+3A_model.col">model.col</code></td>
<td>
<p>Color of lines of null models.</p>
</td></tr>
<tr><td><code id="pcps.curve_+3A_...">...</code></td>
<td>
<p>Further graphical parameters for points.</p>
</td></tr>
<tr><td><code id="pcps.curve_+3A_object">object</code></td>
<td>
<p>An object of class pcpscurve.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The sequence species show up in the community data matrix must be the 
same as they show up in the phylogenetic distance matrix and in traits
matrix. The function <code><a href="#topic+organize.pcps">organize.pcps</a></code> organizes the data, placing the matrices of 
community and phylogenetic distance and trait in the same order. The function use of function 
organize.pcps is not requered for run the functions, but is recommended. In this way 
the arguments comm and phylodist can be specified them as normal arguments or by passing
them with the object returned by the function <code><a href="#topic+organize.pcps">organize.pcps</a></code> using, in this
case only the argument comm. Using the object returned by organize.pcps, the comm argument 
is used as an alternative way of entering to set all data.frames/matrices, and therefore 
the arguments phylodist and trait must not be specified.
</p>
<p>The PCPS are used, in a sequential manner, as predictors in a linear regression
to model the trait averages across the metacommunity. The curve is drawn as the
percentage of cumulative eigenvalues in the abscissa and as the determination 
coefficient of regressions in the ordinate.
</p>
<p>Two null models are available. The first one (ts), the null curves are generated
shuffling terminal tips across the phylogenetic tree, generates a set of random PCPS
and recalculates the curves. The second (bm), the null curves are generated with 
simulate traits evolving under Brownian motion model.
</p>


<h3>Value</h3>

<table>
<tr><td><code>curve.obs</code></td>
<td>
<p>The cumulative PCPS eigenvalues and the coefficient of determination.</p>
</td></tr>
<tr><td><code>curve.null.ts</code></td>
<td>
<p>The cumulative PCPS eigenvalues and the coefficient of determination for 
each randomization using the taxa shuffle null model.</p>
</td></tr> <tr><td><code>curve.null.bm</code></td>
<td>
<p>The cumulative PCPS 
eigenvalues and the coefficient of determination for each randomization using the Brownian motion null model.</p>
</td></tr>
</table>


<h3>Note</h3>

<p><strong>IMPORTANT</strong>: The sequence of species in the community data matrix
MUST be the same as that in the phylogenetic distance matrix and in traits
matrix. See details and <code><a href="#topic+organize.pcps">organize.pcps</a></code>.
</p>


<h3>Author(s)</h3>

<p>Vanderlei Julio Debastiani &lt;vanderleidebastiani@yahoo.com.br&gt;
</p>


<h3>References</h3>

<p>Duarte, L.S. (2011). Phylogenetic habitat filtering influences forest nucleation
in grasslands. Oikos, 120, 208:215.
</p>


<h3>See Also</h3>

<p><code><a href="SYNCSA.html#topic+matrix.p">matrix.p</a></code>, <code><a href="#topic+pcps">pcps</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
data(flona)
res&lt;-pcps.curve(flona$community, flona$phylo, flona$trait[,1,drop = FALSE], 
       null.model.ts = TRUE, runs = 9)
res
summary(res)
plot(res, draw.model = "ts", type = "b", col = "red")

## End(Not run)

</code></pre>

<hr>
<h2 id='select.pcpsmethod'>Internal function</h2><span id='topic+select.pcpsmethod'></span>

<h3>Description</h3>

<p>Internal function to select a predefined method/function available in this package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>select.pcpsmethod(
  method = c("mantel", "adonis", "glm", "rda", "gls.marginal", "gls.sequential",
    "lme.marginal", "lme.sequential", "none")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="select.pcpsmethod_+3A_method">method</code></td>
<td>
<p>A predefined method/function available in PCPS package, partial match to &quot;mantel&quot;, &quot;adonis&quot;, &quot;glm&quot;, &quot;rda&quot;, &quot;gls.marginal&quot;, &quot;gls.sequential&quot;, &quot;lme.marginal&quot;, &quot;lme.sequential&quot; and &quot;none&quot;.</p>
</td></tr>
</table>

<hr>
<h2 id='self.belonging'>Degree of self belonging of species</h2><span id='topic+self.belonging'></span>

<h3>Description</h3>

<p>Define the degree of self belonging of species.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>self.belonging(dis, standardize = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="self.belonging_+3A_dis">dis</code></td>
<td>
<p>Matrix containing distance between species.</p>
</td></tr>
<tr><td><code id="self.belonging_+3A_standardize">standardize</code></td>
<td>
<p>Logical argument (TRUE or FALSE) to specify if dis must be standardize
in values into range 0 from 1 (Default standardize = TRUE).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For the calculation of self-belonging of a set of species the dissimilarities between
the species are transformed into similarities and used to define degrees of belonging 
to fuzzy sets (Pillar et al. 2009; Pillar &amp; Duarte 2010). Every species among all 
species specifies a fuzzy set in relation to all other species, with a certain degree
of belonging. The self-belonging of a given species i expresses its degree of 
belonging to the root node of the phylogenetic/functional tree, conditioned to the 
similarities between i and all other internal nodes connecting it to the root.
</p>


<h3>Value</h3>

<p>The self-belonging for each species.
</p>


<h3>Author(s)</h3>

<p>Vanderlei Julio Debastiani &lt;vanderleidebastiani@yahoo.com.br&gt;
</p>


<h3>References</h3>

<p>Pillar, V.D.; Duarte, L.d.S. (2010). A framework for
metacommunity analysis of phylogenetic structure. Ecology Letters, 13,
587:596.
</p>
<p>Pillar, V.D., Duarte, L.d.S., Sosinski, E.E. &amp; Joner, F. (2009).
Discriminating trait-convergence and trait-divergence assembly patterns in
ecological community gradients. Journal of Vegetation Science, 20, 334:348.
</p>


<h3>See Also</h3>

<p><code><a href="SYNCSA.html#topic+belonging">belonging</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(ADRS)
self.belonging(ADRS$phylo)

</code></pre>

<hr>
<h2 id='wcmdscale.org'>Internal function for organize the results of wcmdscale function</h2><span id='topic+wcmdscale.org'></span>

<h3>Description</h3>

<p>Internal function for organize the results of <code><a href="vegan.html#topic+wcmdscale">wcmdscale</a></code> function.
The function computes dissimilarity indices using the function <code><a href="vegan.html#topic+vegdist">vegdist</a></code>
and perform Principal Coordinates Analysis (PCoA) using the function 
<code><a href="vegan.html#topic+wcmdscale">wcmdscale</a></code>. If data is of class dist, the funcion do not computes
the dissimilarity indices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wcmdscale.org(data, method, squareroot, eig, correlations, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wcmdscale.org_+3A_data">data</code></td>
<td>
<p>Data matrix or dissimilarities of class dist.</p>
</td></tr>
<tr><td><code id="wcmdscale.org_+3A_method">method</code></td>
<td>
<p>Method for dissimilarity index, as accepted by <code><a href="vegan.html#topic+vegdist">vegdist</a></code>.</p>
</td></tr>
<tr><td><code id="wcmdscale.org_+3A_squareroot">squareroot</code></td>
<td>
<p>Logical argument (TRUE or FALSE) to specify if use square root
of dissimilarity index.</p>
</td></tr>
<tr><td><code id="wcmdscale.org_+3A_eig">eig</code></td>
<td>
<p>Logical argument (TRUE or FALSE) to indicates if eigenvalues are returned.</p>
</td></tr>
<tr><td><code id="wcmdscale.org_+3A_correlations">correlations</code></td>
<td>
<p>Logical argument (TRUE or FALSE) to indicates if correlations between axis 
and original data are returned.</p>
</td></tr>
<tr><td><code id="wcmdscale.org_+3A_...">...</code></td>
<td>
<p>Other arguments passed to wcmdscale function.</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>values</code></td>
<td>
<p>The eigenvalues, relative eigenvalues and cumulative relative
eigenvalues.</p>
</td></tr> <tr><td><code>vectors</code></td>
<td>
<p>The principal coordinates.</p>
</td></tr> <tr><td><code>correlations</code></td>
<td>
<p>Correlations
between axis and original data.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Vanderlei Julio Debastiani &lt;vanderleidebastiani@yahoo.com.br&gt;
</p>


<h3>See Also</h3>

<p><code><a href="vegan.html#topic+vegdist">vegdist</a></code>, <code><a href="vegan.html#topic+wcmdscale">wcmdscale</a></code>
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
