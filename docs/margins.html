<!DOCTYPE html><html><head><title>Help for package margins</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {margins}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#margins'><p>Marginal Effects Estimation</p></a></li>
<li><a href='#cplot'><p>Conditional predicted value and average marginal effect plots for models</p></a></li>
<li><a href='#dydx'><p>Marginal Effect of a Given Variable</p></a></li>
<li><a href='#image.lm'><p>Perspective and heatmap/contour plots for models</p></a></li>
<li><a href='#marginal_effects'><p>Differentiate a Model Object with Respect to All (or Specified) Variables</p></a></li>
<li><a href='#plot.margins'><p>Plot Marginal Effects Estimates</p></a></li>
<li><a href='#reexports'><p>Objects exported from other packages</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Marginal Effects for Model Objects</td>
</tr>
<tr>
<td>Description:</td>
<td>An R port of the margins command from 'Stata', which can be used to
    calculate marginal (or partial) effects from model objects.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Version:</td>
<td>0.3.27</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/bbolker/margins">https://github.com/bbolker/margins</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/bbolker/margins/issues">https://github.com/bbolker/margins/issues</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>utils, stats, prediction (&ge; 0.3.6), data.table, graphics,
grDevices, MASS</td>
</tr>
<tr>
<td>Suggests:</td>
<td>methods, knitr, rmarkdown, testthat, ggplot2, gapminder,
sandwich, stargazer, lme4</td>
</tr>
<tr>
<td>Enhances:</td>
<td>AER, betareg, nnet, ordinal, survey</td>
</tr>
<tr>
<td>ByteCompile:</td>
<td>true</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.0</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-06-12 14:10:43 UTC; bolker</td>
</tr>
<tr>
<td>Author:</td>
<td>Thomas J. Leeper <a href="https://orcid.org/0000-0003-4097-6326"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Jeffrey Arnold [ctb],
  Vincent Arel-Bundock [ctb],
  Jacob A. Long <a href="https://orcid.org/0000-0002-1582-6214"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb],
  Ben Bolker <a href="https://orcid.org/0000-0002-2127-0443"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [ctb,
    cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Ben Bolker &lt;bolker@mcmaster.ca&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-06-13 09:40:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='margins'>Marginal Effects Estimation</h2><span id='topic+margins'></span><span id='topic+margins-package'></span><span id='topic+margins.betareg'></span><span id='topic+margins.clm'></span><span id='topic+margins.default'></span><span id='topic+margins.glm'></span><span id='topic+margins.lm'></span><span id='topic+margins.loess'></span><span id='topic+margins.merMod'></span><span id='topic+margins.lmerMod'></span><span id='topic+margins.multinom'></span><span id='topic+margins.nnet'></span><span id='topic+margins.polr'></span><span id='topic+margins_summary'></span><span id='topic+margins.svyglm'></span>

<h3>Description</h3>

<p>This package is an R port of Stata's &lsquo;<span class="samp">&#8288;margins&#8288;</span>&rsquo; command, implemented as an S3 generic <code>margins()</code> for model objects, like those of class &ldquo;lm&rdquo; and &ldquo;glm&rdquo;. <code>margins()</code> is an S3 generic function for building a &ldquo;margins&rdquo; object from a model object. Methods are currently implemented for several model classes (see Details, below).
</p>
<p>margins provides &ldquo;marginal effects&rdquo; summaries of models. Marginal effects are partial derivatives of the regression equation with respect to each variable in the model for each unit in the data; average marginal effects are simply the mean of these unit-specific partial derivatives over some sample. In ordinary least squares regression with no interactions or higher-order term, the estimated slope coefficients are marginal effects. In other cases and for generalized linear models, the coefficients are not marginal effects at least not on the scale of the response variable. margins therefore provides ways of calculating the marginal effects of variables to make these models more interpretable.
</p>
<p>The package also provides a low-level function, <code><a href="#topic+marginal_effects">marginal_effects</a></code>, to estimate those quantities and return a data frame of unit-specific effects and another even lower-level function, <code><a href="#topic+dydx">dydx</a></code>, to provide variable-specific derivatives from models. Some of the underlying architecture for the package is provided by the low-level function <code><a href="prediction.html#topic+prediction">prediction</a></code>, which provides a consistent data frame interface to <code><a href="stats.html#topic+predict">predict</a></code> for a large number of model types. If a <code>prediction</code> method exists for a model class, <code>margin</code> should work for the model class but only those classes listed here have been tested and specifically supported.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>margins(model, ...)

## S3 method for class 'betareg'
margins(
  model,
  data = find_data(model, parent.frame()),
  variables = NULL,
  at = NULL,
  type = c("response", "link"),
  vcov = stats::vcov(model, phi = FALSE),
  vce = c("delta", "simulation", "bootstrap", "none"),
  iterations = 50L,
  unit_ses = FALSE,
  eps = 1e-07,
  ...
)

## S3 method for class 'clm'
margins(
  model,
  data = find_data(model, parent.frame()),
  variables = NULL,
  at = NULL,
  type = c("response", "link"),
  vce = "none",
  eps = 1e-07,
  ...
)

## Default S3 method:
margins(
  model,
  data = find_data(model, parent.frame()),
  variables = NULL,
  at = NULL,
  type = c("response", "link"),
  vcov = stats::vcov(model),
  vce = c("delta", "simulation", "bootstrap", "none"),
  iterations = 50L,
  unit_ses = FALSE,
  eps = 1e-07,
  ...
)

## S3 method for class 'glm'
margins(
  model,
  data = find_data(model, parent.frame()),
  variables = NULL,
  at = NULL,
  type = c("response", "link"),
  vcov = stats::vcov(model),
  vce = c("delta", "simulation", "bootstrap", "none"),
  iterations = 50L,
  unit_ses = FALSE,
  eps = 1e-07,
  ...
)

## S3 method for class 'lm'
margins(
  model,
  data = find_data(model, parent.frame()),
  variables = NULL,
  at = NULL,
  type = c("response", "link"),
  vcov = stats::vcov(model),
  vce = c("delta", "simulation", "bootstrap", "none"),
  iterations = 50L,
  unit_ses = FALSE,
  eps = 1e-07,
  ...
)

## S3 method for class 'loess'
margins(
  model,
  data,
  variables = NULL,
  at = NULL,
  vce = "none",
  eps = 1e-07,
  ...
)

## S3 method for class 'merMod'
margins(
  model,
  data = find_data(model),
  variables = NULL,
  at = NULL,
  type = c("response", "link"),
  vcov = stats::vcov(model),
  vce = c("delta", "simulation", "bootstrap", "none"),
  iterations = 50L,
  unit_ses = FALSE,
  eps = 1e-07,
  ...
)

## S3 method for class 'lmerMod'
margins(
  model,
  data = find_data(model),
  variables = NULL,
  at = NULL,
  type = c("response", "link"),
  vcov = stats::vcov(model),
  vce = c("delta", "simulation", "bootstrap", "none"),
  iterations = 50L,
  unit_ses = FALSE,
  eps = 1e-07,
  ...
)

## S3 method for class 'multinom'
margins(
  model,
  data = find_data(model, parent.frame()),
  variables = NULL,
  at = NULL,
  type = NULL,
  vcov = stats::vcov(model),
  vce = c("delta", "simulation", "bootstrap", "none"),
  iterations = 50L,
  unit_ses = FALSE,
  eps = 1e-07,
  ...
)

## S3 method for class 'nnet'
margins(
  model,
  data = find_data(model, parent.frame()),
  variables = NULL,
  at = NULL,
  vce = "none",
  eps = 1e-07,
  ...
)

## S3 method for class 'polr'
margins(
  model,
  data = find_data(model, parent.frame()),
  variables = NULL,
  at = NULL,
  type = NULL,
  vcov = stats::vcov(model),
  vce = c("delta", "simulation", "bootstrap", "none"),
  iterations = 50L,
  unit_ses = FALSE,
  eps = 1e-07,
  ...
)

margins_summary(model, ..., level = 0.95, by_factor = TRUE)

## S3 method for class 'svyglm'
margins(
  model,
  data = find_data(model, parent.frame()),
  design,
  variables = NULL,
  at = NULL,
  type = c("response", "link"),
  vcov = stats::vcov(model),
  vce = c("delta", "simulation", "bootstrap", "none"),
  iterations = 50L,
  unit_ses = FALSE,
  eps = 1e-07,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="margins_+3A_model">model</code></td>
<td>
<p>A model object. See Details for supported model classes.</p>
</td></tr>
<tr><td><code id="margins_+3A_...">...</code></td>
<td>
<p>Arguments passed to methods, and onward to <code><a href="#topic+dydx">dydx</a></code> methods and possibly further to <code><a href="prediction.html#topic+prediction">prediction</a></code> methods. This can be useful, for example, for setting <code>type</code> (predicted value type), <code>eps</code> (precision), or <code>category</code> (category for multi-category outcome models), etc.</p>
</td></tr>
<tr><td><code id="margins_+3A_data">data</code></td>
<td>
<p>A data frame containing the data at which to evaluate the marginal effects, as in <code><a href="stats.html#topic+predict">predict</a></code>. This is optional, but may be required when the underlying modelling function sets <code>model = FALSE</code>.</p>
</td></tr>
<tr><td><code id="margins_+3A_variables">variables</code></td>
<td>
<p>A character vector with the names of variables for which to compute the marginal effects. The default (<code>NULL</code>) returns marginal effects for all variables.</p>
</td></tr>
<tr><td><code id="margins_+3A_at">at</code></td>
<td>
<p>A list of one or more named vectors, specifically values at which to calculate the marginal effects. This is an analogue of Stata's <code>, at()</code> option. The specified values are fully combined (i.e., a cartesian product) to find AMEs for all combinations of specified variable values. Rather than a list, this can also be a data frame of combination levels if only a subset of combinations are desired. These are used to modify the value of <code>data</code> when calculating AMEs across specified values (see <code><a href="prediction.html#topic+build_datalist">build_datalist</a></code> for details on use). Note: This does not calculate AMEs for <em>subgroups</em> but rather for counterfactual datasets where all observaations take the specified values; to obtain subgroup effects, subset <code>data</code> directly.</p>
</td></tr>
<tr><td><code id="margins_+3A_type">type</code></td>
<td>
<p>A character string indicating the type of marginal effects to estimate. Mostly relevant for non-linear models, where the reasonable options are &ldquo;response&rdquo; (the default) or &ldquo;link&rdquo; (i.e., on the scale of the linear predictor in a GLM).</p>
</td></tr>
<tr><td><code id="margins_+3A_vcov">vcov</code></td>
<td>
<p>A matrix containing the variance-covariance matrix for estimated model coefficients, or a function to perform the estimation with <code>model</code> as its only argument.</p>
</td></tr>
<tr><td><code id="margins_+3A_vce">vce</code></td>
<td>
<p>A character string indicating the type of estimation procedure to use for estimating variances. The default (&ldquo;delta&rdquo;) uses the delta method. Alternatives are &ldquo;bootstrap&rdquo;, which uses bootstrap estimation, or &ldquo;simulation&rdquo;, which averages across simulations drawn from the joint sampling distribution of model coefficients. The latter two are extremely time intensive.</p>
</td></tr>
<tr><td><code id="margins_+3A_iterations">iterations</code></td>
<td>
<p>If <code>vce = "bootstrap"</code>, the number of bootstrap iterations. If <code>vce = "simulation"</code>, the number of simulated effects to draw. Ignored otherwise.</p>
</td></tr>
<tr><td><code id="margins_+3A_unit_ses">unit_ses</code></td>
<td>
<p>If <code>vce = "delta"</code>, a logical specifying whether to calculate and return unit-specific marginal effect variances. This calculation is time consuming and the information is often not needed, so this is set to <code>FALSE</code> by default.</p>
</td></tr>
<tr><td><code id="margins_+3A_eps">eps</code></td>
<td>
<p>A numeric value specifying the &ldquo;step&rdquo; to use when calculating numerical derivatives.</p>
</td></tr>
<tr><td><code id="margins_+3A_level">level</code></td>
<td>
<p>A numeric value specifying the confidence level for calculating p-values and confidence intervals.</p>
</td></tr>
<tr><td><code id="margins_+3A_by_factor">by_factor</code></td>
<td>
<p>A logical specifying whether to order the output by factor (the default, <code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="margins_+3A_design">design</code></td>
<td>
<p>Only for models estimated using <code><a href="survey.html#topic+svyglm">svyglm</a></code>, the &ldquo;survey.design&rdquo; object used to estimate the model. This is required.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Methods for this generic return a &ldquo;margins&rdquo; object, which is a data frame consisting of the original data, predicted values and standard errors thereof, estimated marginal effects from the model <code>model</code> (for all variables used in the model, or the subset specified by <code>variables</code>), along with attributes describing various features of the marginal effects estimates.
</p>
<p>The default print method is concise; a more useful <code>summary</code> method provides additional details.
</p>
<p><code>margins_summary</code> is sugar that provides a more convenient way of obtaining the nested call: <code>summary(margins(...))</code>.
</p>
<p>Methods are currently implemented for the following object classes:
</p>

<ul>
<li> <p>&ldquo;betareg&rdquo;, see <code><a href="betareg.html#topic+betareg">betareg</a></code>
</p>
</li>
<li> <p>&ldquo;glm&rdquo;, see <code><a href="stats.html#topic+glm">glm</a></code>, <code><a href="MASS.html#topic+glm.nb">glm.nb</a></code>
</p>
</li>
<li> <p>&ldquo;ivreg&rdquo;, see <code><a href="AER.html#topic+ivreg">ivreg</a></code>
</p>
</li>
<li> <p>&ldquo;lm&rdquo;, see <code><a href="stats.html#topic+lm">lm</a></code>
</p>
</li>
<li> <p>&ldquo;loess&rdquo;, see <code><a href="stats.html#topic+loess">loess</a></code>
</p>
</li>
<li> <p>&ldquo;merMod&rdquo;, see <code><a href="lme4.html#topic+lmer">lmer</a></code>, <code><a href="lme4.html#topic+glmer">glmer</a></code>
</p>
</li>
<li> <p>&ldquo;nnet&rdquo;, see <code><a href="nnet.html#topic+nnet">nnet</a></code>
</p>
</li>
<li> <p>&ldquo;polr&rdquo;, see <code><a href="MASS.html#topic+polr">polr</a></code>
</p>
</li>
<li> <p>&ldquo;svyglm&rdquo;, see <code><a href="survey.html#topic+svyglm">svyglm</a></code>
</p>
</li></ul>

<p>The <code>margins</code> methods simply construct a list of data frames based upon the values of <code>at</code> (using <code><a href="prediction.html#topic+build_datalist">build_datalist</a></code>), calculate marginal effects for each data frame (via <code><a href="#topic+marginal_effects">marginal_effects</a></code> and, in turn, <code><a href="#topic+dydx">dydx</a></code> and <code><a href="prediction.html#topic+prediction">prediction</a></code>), stacks the results together, and provides variance estimates. Alternatively, you can use <code><a href="#topic+marginal_effects">marginal_effects</a></code> directly to only retrieve a data frame of marginal effects without constructing a &ldquo;margins&rdquo; object or variance estimates. That can be efficient for plotting, etc., given the time-consuming nature of variance estimation.
</p>
<p>See <code><a href="#topic+dydx">dydx</a></code> for details on estimation of marginal effects.
</p>
<p>The choice of <code>vce</code> may be important. The default variance-covariance estimation procedure (<code>vce = "delta"</code>) uses the delta method to estimate marginal effect variances. This is the fastest method. When <code>vce = "simulation"</code>, coefficient estimates are repeatedly drawn from the asymptotic (multivariate normal) distribution of the model coefficients and each draw is used to estimate marginal effects, with the variance based upon the dispersion of those simulated effects. The number of iterations used is given by <code>iterations</code>. For <code>vce = "bootstrap"</code>, the bootstrap is used to repeatedly subsample <code>data</code> and the variance of marginal effects is estimated from the variance of the bootstrap distribution. This method is markedly slower than the other two procedures. Again, <code>iterations</code> regulates the number of bootstrap subsamples to draw. Some model classes (notably &ldquo;loess&rdquo;) fix <code>vce ="none"</code>.
</p>


<h3>Value</h3>

<p>A data frame of class &ldquo;margins&rdquo; containing the contents of <code>data</code>, predicted values from <code>model</code> for <code>data</code>, the standard errors of the predictions, and any estimated marginal effects. If <code>at = NULL</code> (the default), then the data frame will have a number of rows equal to <code>nrow(data)</code>. Otherwise, the number of rows will be a multiple thereof based upon the number of combinations of values specified in <code>at</code>. Columns containing marginal effects are distinguished by their name (prefixed by <code>dydx_</code>). These columns can be extracted from a &ldquo;margins&rdquo; object using, for example, <code>marginal_effects(margins(model))</code>. Columns prefixed by <code>Var_</code> specify the variances of the <em>average</em> marginal effects, whereas (optional) columns prefixed by <code>SE_</code> contain observation-specific standard errors. A special column, <code>_at_number</code>, specifies which <code>at</code> combination a given row corresponds to; the data frame carries an attribute &ldquo;at&rdquo; that specifies which combination of values this index represents. The <code>summary.margins()</code> method provides for pretty printing of the results, particularly in cases where <code>at</code> is specified. A variance-covariance matrix for the average marginal effects is returned as an attribute (though behavior when <code>at</code> is non-NULL is unspecified).
</p>


<h3>Author(s)</h3>

<p>Thomas J. Leeper
</p>


<h3>References</h3>

<p>Greene, W.H. 2012. Econometric Analysis, 7th Ed. Boston: Pearson.
</p>
<p>Stata manual: <code>margins</code>. Retrieved 2014-12-15 from <a href="https://www.stata.com/manuals13/rmargins.pdf">https://www.stata.com/manuals13/rmargins.pdf</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+marginal_effects">marginal_effects</a></code>, <code><a href="#topic+dydx">dydx</a></code>, <code><a href="prediction.html#topic+prediction">prediction</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># basic example using linear model
require("datasets")
x &lt;- lm(mpg ~ cyl * hp + wt, data = head(mtcars))
margins(x)

# obtain unit-specific standard errors
## Not run: 
  margins(x, unit_ses = TRUE)

## End(Not run)

# use of 'variables' argument to estimate only some MEs
summary(margins(x, variables = "hp"))

# use of 'at' argument
## modifying original data values
margins(x, at = list(hp = 150))
## AMEs at various data values
margins(x, at = list(hp = c(95, 150), cyl = c(4,6)))

# use of 'data' argument to obtain AMEs for a subset of data
margins(x, data = mtcars[mtcars[["cyl"]] == 4,])
margins(x, data = mtcars[mtcars[["cyl"]] == 6,])

# return discrete differences for continuous terms
## passes 'change' through '...' to dydx()
margins(x, change = "sd")

# summary() method
summary(margins(x, at = list(hp = c(95, 150))))
margins_summary(x, at = list(hp = c(95, 150)))
## control row order of summary() output
summary(margins(x, at = list(hp = c(95, 150))), by_factor = FALSE)

# alternative 'vce' estimation
## Not run: 
  # bootstrap
  margins(x, vce = "bootstrap", iterations = 100L)
  # simulation (ala Clarify/Zelig)
  margins(x, vce = "simulation", iterations = 100L)

## End(Not run)

# specifying a custom `vcov` argument
if (require("sandwich")) {
  x2 &lt;- lm(Sepal.Length ~ Sepal.Width, data = head(iris))
  summary(margins(x2))
  ## heteroskedasticity-consistent covariance matrix
  summary(margins(x2, vcov = vcovHC(x2)))
}

# generalized linear model
x &lt;- glm(am ~ hp, data = head(mtcars), family = binomial)
margins(x, type = "response")
margins(x, type = "link")

# multi-category outcome
if (requireNamespace("nnet")) {
  data("iris3", package = "datasets")
  ird &lt;- data.frame(rbind(iris3[,,1], iris3[,,2], iris3[,,3]),
                    species = factor(c(rep("s",50), rep("c", 50), rep("v", 50))))
  m &lt;- nnet::nnet(species ~ ., data = ird, size = 2, rang = 0.1,
                  decay = 5e-4, maxit = 200, trace = FALSE)
  margins(m) # default
  margins(m, category = "v") # explicit category
}

# using margins_summary() for concise grouped operations
list_data &lt;- split(mtcars, mtcars$gear)
list_mod &lt;- lapply(list_data, function(x) lm(mpg ~ cyl + wt, data = x))
mapply(margins_summary, model = list_mod, data = list_data, SIMPLIFY = FALSE)

</code></pre>

<hr>
<h2 id='cplot'>Conditional predicted value and average marginal effect plots for models</h2><span id='topic+cplot'></span><span id='topic+cplot.default'></span><span id='topic+cplot.clm'></span><span id='topic+cplot.glm'></span><span id='topic+cplot.lm'></span><span id='topic+cplot.loess'></span><span id='topic+cplot.polr'></span><span id='topic+cplot.multinom'></span>

<h3>Description</h3>

<p>Draw one or more conditional effects plots reflecting predictions or marginal effects from a model, conditional on a covariate. Currently methods exist for &ldquo;lm&rdquo;, &ldquo;glm&rdquo;, &ldquo;loess&rdquo; class models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cplot(object, ...)

## Default S3 method:
cplot(
  object,
  x = attributes(terms(object))[["term.labels"]][1L],
  dx = x,
  what = c("prediction", "effect"),
  data = prediction::find_data(object),
  type = c("response", "link"),
  vcov = stats::vcov(object),
  at,
  n = 25L,
  xvals = prediction::seq_range(data[[x]], n = n),
  level = 0.95,
  draw = TRUE,
  xlab = x,
  ylab = if (match.arg(what) == "prediction") paste0("Predicted value") else
    paste0("Marginal effect of ", dx),
  xlim = NULL,
  ylim = NULL,
  lwd = 1L,
  col = "black",
  lty = 1L,
  se.type = c("shade", "lines", "none"),
  se.col = "black",
  se.fill = grDevices::gray(0.5, 0.5),
  se.lwd = lwd,
  se.lty = if (match.arg(se.type) == "lines") 1L else 0L,
  factor.lty = 0L,
  factor.pch = 19L,
  factor.col = se.col,
  factor.fill = factor.col,
  factor.cex = 1L,
  xaxs = "i",
  yaxs = xaxs,
  las = 1L,
  scatter = FALSE,
  scatter.pch = 19L,
  scatter.col = se.col,
  scatter.bg = scatter.col,
  scatter.cex = 0.5,
  rug = TRUE,
  rug.col = col,
  rug.size = -0.02,
  ...
)

## S3 method for class 'clm'
cplot(
  object,
  x = attributes(terms(object))[["term.labels"]][1L],
  dx = x,
  what = c("prediction", "classprediction", "stackedprediction", "effect"),
  data = prediction::find_data(object),
  type = c("response", "link"),
  vcov = stats::vcov(object),
  at,
  n = 25L,
  xvals = seq_range(data[[x]], n = n),
  level = 0.95,
  draw = TRUE,
  xlab = x,
  ylab = if (match.arg(what) == "effect") paste0("Marginal effect of ", dx) else
    paste0("Predicted value"),
  xlim = NULL,
  ylim = if (match.arg(what) %in% c("prediction", "stackedprediction")) c(0, 1.04)
    else NULL,
  lwd = 1L,
  col = "black",
  lty = 1L,
  factor.lty = 1L,
  factor.pch = 19L,
  factor.col = col,
  factor.fill = factor.col,
  factor.cex = 1L,
  xaxs = "i",
  yaxs = xaxs,
  las = 1L,
  scatter = FALSE,
  scatter.pch = 19L,
  scatter.col = factor.col,
  scatter.bg = scatter.col,
  scatter.cex = 0.5,
  rug = TRUE,
  rug.col = col,
  rug.size = -0.02,
  ...
)

## S3 method for class 'glm'
cplot(
  object,
  x = attributes(terms(object))[["term.labels"]][1L],
  dx = x,
  what = c("prediction", "effect"),
  data = prediction::find_data(object),
  type = c("response", "link"),
  vcov = stats::vcov(object),
  at,
  n = 25L,
  xvals = prediction::seq_range(data[[x]], n = n),
  level = 0.95,
  draw = TRUE,
  xlab = x,
  ylab = if (match.arg(what) == "prediction") paste0("Predicted value") else
    paste0("Marginal effect of ", dx),
  xlim = NULL,
  ylim = NULL,
  lwd = 1L,
  col = "black",
  lty = 1L,
  se.type = c("shade", "lines", "none"),
  se.col = "black",
  se.fill = grDevices::gray(0.5, 0.5),
  se.lwd = lwd,
  se.lty = if (match.arg(se.type) == "lines") 1L else 0L,
  factor.lty = 0L,
  factor.pch = 19L,
  factor.col = se.col,
  factor.fill = factor.col,
  factor.cex = 1L,
  xaxs = "i",
  yaxs = xaxs,
  las = 1L,
  scatter = FALSE,
  scatter.pch = 19L,
  scatter.col = se.col,
  scatter.bg = scatter.col,
  scatter.cex = 0.5,
  rug = TRUE,
  rug.col = col,
  rug.size = -0.02,
  ...
)

## S3 method for class 'lm'
cplot(
  object,
  x = attributes(terms(object))[["term.labels"]][1L],
  dx = x,
  what = c("prediction", "effect"),
  data = prediction::find_data(object),
  type = c("response", "link"),
  vcov = stats::vcov(object),
  at,
  n = 25L,
  xvals = prediction::seq_range(data[[x]], n = n),
  level = 0.95,
  draw = TRUE,
  xlab = x,
  ylab = if (match.arg(what) == "prediction") paste0("Predicted value") else
    paste0("Marginal effect of ", dx),
  xlim = NULL,
  ylim = NULL,
  lwd = 1L,
  col = "black",
  lty = 1L,
  se.type = c("shade", "lines", "none"),
  se.col = "black",
  se.fill = grDevices::gray(0.5, 0.5),
  se.lwd = lwd,
  se.lty = if (match.arg(se.type) == "lines") 1L else 0L,
  factor.lty = 0L,
  factor.pch = 19L,
  factor.col = se.col,
  factor.fill = factor.col,
  factor.cex = 1L,
  xaxs = "i",
  yaxs = xaxs,
  las = 1L,
  scatter = FALSE,
  scatter.pch = 19L,
  scatter.col = se.col,
  scatter.bg = scatter.col,
  scatter.cex = 0.5,
  rug = TRUE,
  rug.col = col,
  rug.size = -0.02,
  ...
)

## S3 method for class 'loess'
cplot(
  object,
  x = attributes(terms(object))[["term.labels"]][1L],
  dx = x,
  what = c("prediction", "effect"),
  data = prediction::find_data(object),
  type = c("response", "link"),
  vcov = stats::vcov(object),
  at,
  n = 25L,
  xvals = prediction::seq_range(data[[x]], n = n),
  level = 0.95,
  draw = TRUE,
  xlab = x,
  ylab = if (match.arg(what) == "prediction") paste0("Predicted value") else
    paste0("Marginal effect of ", dx),
  xlim = NULL,
  ylim = NULL,
  lwd = 1L,
  col = "black",
  lty = 1L,
  se.type = c("shade", "lines", "none"),
  se.col = "black",
  se.fill = grDevices::gray(0.5, 0.5),
  se.lwd = lwd,
  se.lty = if (match.arg(se.type) == "lines") 1L else 0L,
  factor.lty = 0L,
  factor.pch = 19L,
  factor.col = se.col,
  factor.fill = factor.col,
  factor.cex = 1L,
  xaxs = "i",
  yaxs = xaxs,
  las = 1L,
  scatter = FALSE,
  scatter.pch = 19L,
  scatter.col = se.col,
  scatter.bg = scatter.col,
  scatter.cex = 0.5,
  rug = TRUE,
  rug.col = col,
  rug.size = -0.02,
  ...
)

## S3 method for class 'polr'
cplot(
  object,
  x = attributes(terms(object))[["term.labels"]][1L],
  dx = x,
  what = c("prediction", "classprediction", "stackedprediction", "effect"),
  data = prediction::find_data(object),
  type = c("response", "link"),
  vcov = stats::vcov(object),
  at,
  n = 25L,
  xvals = seq_range(data[[x]], n = n),
  level = 0.95,
  draw = TRUE,
  xlab = x,
  ylab = if (match.arg(what) == "effect") paste0("Marginal effect of ", dx) else
    paste0("Predicted value"),
  xlim = NULL,
  ylim = if (match.arg(what) %in% c("prediction", "stackedprediction")) c(0, 1.04)
    else NULL,
  lwd = 1L,
  col = "black",
  lty = 1L,
  factor.lty = 1L,
  factor.pch = 19L,
  factor.col = col,
  factor.fill = factor.col,
  factor.cex = 1L,
  xaxs = "i",
  yaxs = xaxs,
  las = 1L,
  scatter = FALSE,
  scatter.pch = 19L,
  scatter.col = factor.col,
  scatter.bg = scatter.col,
  scatter.cex = 0.5,
  rug = TRUE,
  rug.col = col,
  rug.size = -0.02,
  ...
)

## S3 method for class 'multinom'
cplot(
  object,
  x = attributes(terms(object))[["term.labels"]][1L],
  dx = x,
  what = c("prediction", "classprediction", "stackedprediction", "effect"),
  data = prediction::find_data(object),
  type = c("response", "link"),
  vcov = stats::vcov(object),
  at,
  n = 25L,
  xvals = seq_range(data[[x]], n = n),
  level = 0.95,
  draw = TRUE,
  xlab = x,
  ylab = if (match.arg(what) == "effect") paste0("Marginal effect of ", dx) else
    paste0("Predicted value"),
  xlim = NULL,
  ylim = if (match.arg(what) %in% c("prediction", "stackedprediction")) c(0, 1.04)
    else NULL,
  lwd = 1L,
  col = "black",
  lty = 1L,
  factor.lty = 1L,
  factor.pch = 19L,
  factor.col = col,
  factor.fill = factor.col,
  factor.cex = 1L,
  xaxs = "i",
  yaxs = xaxs,
  las = 1L,
  scatter = FALSE,
  scatter.pch = 19L,
  scatter.col = factor.col,
  scatter.bg = scatter.col,
  scatter.cex = 0.5,
  rug = TRUE,
  rug.col = col,
  rug.size = -0.02,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cplot_+3A_object">object</code></td>
<td>
<p>A model object.</p>
</td></tr>
<tr><td><code id="cplot_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code><a href="graphics.html#topic+plot">plot</a></code>.</p>
</td></tr>
<tr><td><code id="cplot_+3A_x">x</code></td>
<td>
<p>A character string specifying the name of variable to use as the x-axis dimension in the plot.</p>
</td></tr>
<tr><td><code id="cplot_+3A_dx">dx</code></td>
<td>
<p>If <code>what = "effect"</code>, the variable whose conditional marginal effect should be displayed. By default it is <code>x</code> (so the plot displays the marginal effect of <code>x</code> across values of <code>x</code>); ignored otherwise. If <code>dx</code> is a factor with more than 2 levels, an error will be issued.</p>
</td></tr>
<tr><td><code id="cplot_+3A_what">what</code></td>
<td>
<p>A character string specifying whether to draw a &ldquo;prediction&rdquo; (fitted values from the model, calculated using <code><a href="stats.html#topic+predict">predict</a></code>) or an &ldquo;effect&rdquo; (average marginal effect of <code>dx</code> conditional on <code>x</code>, using <code><a href="#topic+margins">margins</a></code>). Methods for classes other than &ldquo;lm&rdquo; or &ldquo;glm&rdquo; may provided additional options (e.g., <code>cplot.polr()</code> provides &ldquo;stackedprediction&rdquo; and &ldquo;class&rdquo; alternatives).</p>
</td></tr>
<tr><td><code id="cplot_+3A_data">data</code></td>
<td>
<p>A data frame to override the default value offered in <code>object[["model"]]</code>.</p>
</td></tr>
<tr><td><code id="cplot_+3A_type">type</code></td>
<td>
<p>A character string specifying whether to calculate predictions on the response scale (default) or link (only relevant for non-linear models).</p>
</td></tr>
<tr><td><code id="cplot_+3A_vcov">vcov</code></td>
<td>
<p>A matrix containing the variance-covariance matrix for estimated model coefficients, or a function to perform the estimation with <code>model</code> as its only argument.</p>
</td></tr>
<tr><td><code id="cplot_+3A_at">at</code></td>
<td>
<p>Currently ignored.</p>
</td></tr>
<tr><td><code id="cplot_+3A_n">n</code></td>
<td>
<p>An integer specifying the number of points across <code>x</code> at which to calculate the predicted value or marginal effect, when <code>x</code> is numeric. Ignored otherwise.</p>
</td></tr>
<tr><td><code id="cplot_+3A_xvals">xvals</code></td>
<td>
<p>A numeric vector of values at which to calculate predictions or marginal effects, if <code>x</code> is numeric. By default, it is calculated from the data using <code><a href="prediction.html#topic+seq_range">seq_range</a></code>. If <code>x</code> is a factor, this is ignored, as is <code>n</code>.</p>
</td></tr>
<tr><td><code id="cplot_+3A_level">level</code></td>
<td>
<p>The confidence level required (used to draw uncertainty bounds).</p>
</td></tr>
<tr><td><code id="cplot_+3A_draw">draw</code></td>
<td>
<p>A logical (default <code>TRUE</code>), specifying whether to draw the plot. If <code>FALSE</code>, the data used in drawing are returned as a list of data.frames. This might be useful if you want to plot using an alternative plotting package (e.g., ggplot2). Also, if set to value &ldquo;add&rdquo;, then the resulting data is added to the existing plot.</p>
</td></tr>
<tr><td><code id="cplot_+3A_xlab">xlab</code></td>
<td>
<p>A character string specifying the value of <code>xlab</code> in <code><a href="graphics.html#topic+plot">plot</a></code>.</p>
</td></tr>
<tr><td><code id="cplot_+3A_ylab">ylab</code></td>
<td>
<p>A character string specifying the value of <code>ylab</code> in <code><a href="graphics.html#topic+plot">plot</a></code>.</p>
</td></tr>
<tr><td><code id="cplot_+3A_xlim">xlim</code></td>
<td>
<p>A two-element numeric vector specifying the x-axis limits. Set automatically if missing.</p>
</td></tr>
<tr><td><code id="cplot_+3A_ylim">ylim</code></td>
<td>
<p>A two-element numeric vector specifying the y-axis limits. Set automatically if missing.</p>
</td></tr>
<tr><td><code id="cplot_+3A_lwd">lwd</code></td>
<td>
<p>An integer specifying the width of the prediction or marginal effect line. See <code><a href="graphics.html#topic+lines">lines</a></code>. If <code>x</code> is a factor variable in the model, this is used to set the line width of the error bars.</p>
</td></tr>
<tr><td><code id="cplot_+3A_col">col</code></td>
<td>
<p>A character string specifying the color of the prediction or marginal effect line. If <code>x</code> is a factor variable in the model, this is used to set the color of the error bars.</p>
</td></tr>
<tr><td><code id="cplot_+3A_lty">lty</code></td>
<td>
<p>An integer specifying the &ldquo;line type&rdquo; of the prediction or marginal effect line. See <code><a href="graphics.html#topic+par">par</a></code>. If <code>x</code> is a factor variable in the model, this is used to set the line type of the error bars.</p>
</td></tr>
<tr><td><code id="cplot_+3A_se.type">se.type</code></td>
<td>
<p>A character string specifying whether to draw the confidence interval as &ldquo;lines&rdquo; (the default, using <code><a href="graphics.html#topic+lines">lines</a></code>) or a &ldquo;shade&rdquo; (using <code><a href="graphics.html#topic+polygon">polygon</a></code>).</p>
</td></tr>
<tr><td><code id="cplot_+3A_se.col">se.col</code></td>
<td>
<p>If <code>se.type = "lines"</code>, a character string specifying the color of the confidence interval lines. If <code>se.type = "shade"</code>, the color of the shaded region border.</p>
</td></tr>
<tr><td><code id="cplot_+3A_se.fill">se.fill</code></td>
<td>
<p>If <code>se.type = "shade"</code>, the color of the shaded region. Ignored otherwise.</p>
</td></tr>
<tr><td><code id="cplot_+3A_se.lwd">se.lwd</code></td>
<td>
<p>If <code>se.type = "lines"</code>, the width of the confidence interval lines. See <code><a href="graphics.html#topic+lines">lines</a></code>.</p>
</td></tr>
<tr><td><code id="cplot_+3A_se.lty">se.lty</code></td>
<td>
<p>If <code>se.type = "lines"</code>, an integer specifying the &ldquo;line type&rdquo; of the confidence interval lines; if <code>se.type = "shade"</code>, the line type of the shaded polygon border. See <code><a href="graphics.html#topic+par">par</a></code>.</p>
</td></tr>
<tr><td><code id="cplot_+3A_factor.lty">factor.lty</code></td>
<td>
<p>If <code>x</code> is a factor variable in the model, this is used to set the line type of an optional line connecting predictions across factor levels. If <code>factor.lty = 0L</code> (the default), no line is drawn.. See <code><a href="graphics.html#topic+par">par</a></code>.</p>
</td></tr>
<tr><td><code id="cplot_+3A_factor.pch">factor.pch</code></td>
<td>
<p>If <code>x</code> is a factor variable in the model, the shape to use when drawing points. See <code><a href="graphics.html#topic+points">points</a></code>.</p>
</td></tr>
<tr><td><code id="cplot_+3A_factor.col">factor.col</code></td>
<td>
<p>If <code>x</code> is a factor variable in the model, the color to use for the border of the points. See <code><a href="graphics.html#topic+points">points</a></code>.</p>
</td></tr>
<tr><td><code id="cplot_+3A_factor.fill">factor.fill</code></td>
<td>
<p>If <code>x</code> is a factor variable in the model, the color to use for the fill of the points. See <code><a href="graphics.html#topic+points">points</a></code>.</p>
</td></tr>
<tr><td><code id="cplot_+3A_factor.cex">factor.cex</code></td>
<td>
<p>If <code>x</code> is a factor variable in the model, the &ldquo;expansion factor&rdquo; to use for the point size. See <code><a href="graphics.html#topic+points">points</a></code>.</p>
</td></tr>
<tr><td><code id="cplot_+3A_xaxs">xaxs</code></td>
<td>
<p>A character string specifying <code>xaxs</code>. See <code><a href="graphics.html#topic+par">par</a></code>.</p>
</td></tr>
<tr><td><code id="cplot_+3A_yaxs">yaxs</code></td>
<td>
<p>A character string specifying <code>xaxs</code>. See <code><a href="graphics.html#topic+par">par</a></code>.</p>
</td></tr>
<tr><td><code id="cplot_+3A_las">las</code></td>
<td>
<p>An integer string specifying <code>las</code>. See <code><a href="graphics.html#topic+par">par</a></code>.</p>
</td></tr>
<tr><td><code id="cplot_+3A_scatter">scatter</code></td>
<td>
<p>A logical indicating whether to plot the observed data in <code>data</code> as a scatterplot.</p>
</td></tr>
<tr><td><code id="cplot_+3A_scatter.pch">scatter.pch</code></td>
<td>
<p>If <code>scatter = TRUE</code>, an integer specifying a shape to use for plotting the data. See <code><a href="graphics.html#topic+points">points</a></code>.</p>
</td></tr>
<tr><td><code id="cplot_+3A_scatter.col">scatter.col</code></td>
<td>
<p>If <code>scatter = TRUE</code>, a character string specifying a color to use for plotting the data. See <code><a href="graphics.html#topic+points">points</a></code>.</p>
</td></tr>
<tr><td><code id="cplot_+3A_scatter.bg">scatter.bg</code></td>
<td>
<p>If <code>scatter = TRUE</code>, a character string specifying a color to use for plotting the data. See <code><a href="graphics.html#topic+points">points</a></code>.</p>
</td></tr>
<tr><td><code id="cplot_+3A_scatter.cex">scatter.cex</code></td>
<td>
<p>If <code>scatter = TRUE</code>, an integer specifying the size of the points. See <code><a href="graphics.html#topic+points">points</a></code>.</p>
</td></tr>
<tr><td><code id="cplot_+3A_rug">rug</code></td>
<td>
<p>A logical specifying whether to include an x-axis &ldquo;rug&rdquo; (see <code><a href="graphics.html#topic+rug">rug</a></code>).</p>
</td></tr>
<tr><td><code id="cplot_+3A_rug.col">rug.col</code></td>
<td>
<p>A character string specifying <code>col</code> to <code><a href="graphics.html#topic+rug">rug</a></code>.</p>
</td></tr>
<tr><td><code id="cplot_+3A_rug.size">rug.size</code></td>
<td>
<p>A numeric value specifying <code>ticksize</code> to <code><a href="graphics.html#topic+rug">rug</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that when <code>what = "prediction"</code>, the plots show predictions holding values of the data at their mean or mode, whereas when <code>what = "effect"</code> average marginal effects (i.e., at observed values) are shown.
</p>
<p>When examining generalized linear models (e.g., logistic regression models), confidence intervals for predictions can fall outside of the response scale (again, for logistic regression this means confidence intervals can exceed the (0,1) bounds). This is consistent with the behavior of <code><a href="stats.html#topic+predict">predict</a></code> but may not be desired. The examples (below) show ways of constraining confidence intervals to these bounds.
</p>
<p>The overall aesthetic is somewhat similar to to the output produced by the <code>marginalModelPlot()</code> function in the <b><a href="https://cran.r-project.org/package=car">car</a></b> package.
</p>


<h3>Value</h3>

<p>A tidy data frame containing the data used to draw the plot. Use <code>draw = FALSE</code> to simply generate the data structure for use elsewhere.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.margins">plot.margins</a></code>, <code><a href="#topic+persp.lm">persp.lm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
require('datasets')
# prediction from several angles
m &lt;- lm(Sepal.Length ~ Sepal.Width, data = iris)
cplot(m)

# more complex model
m &lt;- lm(Sepal.Length ~ Sepal.Width * Petal.Width * I(Petal.Width ^ 2), 
        data = head(iris, 50))
## marginal effect of 'Petal.Width' across 'Petal.Width'
cplot(m, x = "Petal.Width", what = "effect", n = 10)

# factor independent variables
mtcars[["am"]] &lt;- factor(mtcars[["am"]])
m &lt;- lm(mpg ~ am * wt, data = mtcars)
## predicted values for each factor level
cplot(m, x = "am")
## marginal effect of each factor level across numeric variable
cplot(m, x = "wt", dx = "am", what = "effect")

# marginal effect of 'Petal.Width' across 'Sepal.Width'
## without drawing the plot
## this might be useful for using, e.g., ggplot2 for plotting
tmp &lt;- cplot(m, x = "Sepal.Width", dx = "Petal.Width", 
             what = "effect", n = 10, draw = FALSE)
if (require("ggplot2")) {
  # use ggplot2 instead of base graphics
  ggplot(tmp, aes(x = Petal.Width, y = "effect")) + 
         geom_line(lwd = 2) + 
         geom_line(aes(y = effect + 1.96*se.effect)) + 
         geom_line(aes(y = effect - 1.96*se.effect))
}

# a non-linear model
m &lt;- glm(am ~ wt*drat, data = mtcars, family = binomial)
cplot(m, x = "wt") # prediction (response scale)
cplot(m, x = "wt") # prediction (link scale)
if (require("ggplot2")) {
  # prediction (response scale, constrained to [0,1])
  cplotdat &lt;- cplot(m, x = "wt", type = "link", draw = FALSE)
  ggplot(cplotdat, aes(x = xvals, y = plogis(yvals))) + 
         geom_line(lwd = 1.5) + 
         geom_line(aes(y = plogis(upper))) + 
         geom_line(aes(y = plotis(lower)))
}

# effects on linear predictor and outcome
cplot(m, x = "drat", dx = "wt", what = "effect", type = "link")
cplot(m, x = "drat", dx = "wt", what = "effect", type = "response")

# plot conditional predictions across a third factor
local({
  iris$long &lt;- rbinom(nrow(iris), 1, 0.6)
  x &lt;- glm(long ~ Sepal.Width*Species, data = iris)
  cplot(x, x = "Sepal.Width", data = iris[iris$Species == "setosa", ], 
        ylim = c(0,1), col = "red", se.fill = rgb(1,0,0,.5), xlim = c(2,4.5))
  cplot(x, x = "Sepal.Width", data = iris[iris$Species == "versicolor", ], 
        draw = "add", col = "blue", se.fill = rgb(0,1,0,.5))
  cplot(x, x = "Sepal.Width", data = iris[iris$Species == "virginica", ], 
        draw = "add", col = "green", se.fill = rgb(0,0,1,.5))
})

# ordinal outcome
if (require("MASS")) {
  # x is a factor variable
  house.plr &lt;- polr(Sat ~ Infl + Type + Cont, weights = Freq, 
                    data = housing)
  ## predicted probabilities
  cplot(house.plr)
  ## cumulative predicted probabilities
  cplot(house.plr, what = "stacked")
  ## ggplot2 example
  if (require("ggplot2")) {
    ggplot(cplot(house.plr), aes(x = xvals, y = yvals, group = level)) + 
      geom_line(aes(color = level))
  }

  # x is continuous
  cyl.plr &lt;- polr(factor(cyl) ~ wt, data = mtcars)
  cplot(cyl.plr, col = c("red", "purple", "blue"), what = "stacked")
  cplot(cyl.plr, what = "class")
}


## End(Not run)
</code></pre>

<hr>
<h2 id='dydx'>Marginal Effect of a Given Variable</h2><span id='topic+dydx'></span><span id='topic+dydx.default'></span><span id='topic+dydx.factor'></span><span id='topic+dydx.ordered'></span><span id='topic+dydx.logical'></span>

<h3>Description</h3>

<p>Differentiate an Estimated Model Function with Respect to One Variable, or calculate a discrete difference (&ldquo;first difference&rdquo;) as appropriate.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dydx(data, model, variable, ...)

## Default S3 method:
dydx(
  data,
  model,
  variable,
  type = c("response", "link"),
  change = c("dydx", "minmax", "iqr", "sd"),
  eps = 1e-07,
  as.data.frame = TRUE,
  ...
)

## S3 method for class 'factor'
dydx(
  data,
  model,
  variable,
  type = c("response", "link"),
  fwrap = FALSE,
  as.data.frame = TRUE,
  ...
)

## S3 method for class 'ordered'
dydx(
  data,
  model,
  variable,
  type = c("response", "link"),
  fwrap = FALSE,
  as.data.frame = TRUE,
  ...
)

## S3 method for class 'logical'
dydx(
  data,
  model,
  variable,
  type = c("response", "link"),
  as.data.frame = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dydx_+3A_data">data</code></td>
<td>
<p>The dataset on which to to calculate <code class="reqn">\hat{y}</code>.</p>
</td></tr>
<tr><td><code id="dydx_+3A_model">model</code></td>
<td>
<p>The model object to pass to <code><a href="prediction.html#topic+prediction">prediction</a></code>.</p>
</td></tr>
<tr><td><code id="dydx_+3A_variable">variable</code></td>
<td>
<p>A character string specifying the variable to calculate the derivative or discrete change for.</p>
</td></tr>
<tr><td><code id="dydx_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
<tr><td><code id="dydx_+3A_type">type</code></td>
<td>
<p>The type of prediction. Default is &ldquo;response&rdquo;.</p>
</td></tr>
<tr><td><code id="dydx_+3A_change">change</code></td>
<td>
<p>For numeric variables, a character string specifying the type of change to express. The default is the numerical approximation of the derivative. Alternative values are occasionally desired quantities: &ldquo;minmax&rdquo; (the discrete change moving from <code>min(x)</code> to <code>max(x)</code>), &ldquo;iqr&rdquo; (the move from the 1st quartile to 3rd quartile of <code>x</code>), or &ldquo;sd&rdquo; (the change from <code>mean(x) - sd(x)</code> to <code>mean(x) + sd(x)</code>), or a two-element numeric vector expressing values of the variable to calculate the prediction for (and difference the associated predictions).</p>
</td></tr>
<tr><td><code id="dydx_+3A_eps">eps</code></td>
<td>
<p>If <code>change == "dydx"</code> (the default), the value of the step <code class="reqn">\epsilon</code> to use in calculation of the numerical derivative for numeric variables.</p>
</td></tr>
<tr><td><code id="dydx_+3A_as.data.frame">as.data.frame</code></td>
<td>
<p>A logical indicating whether to return a data frame (the default) or a matrix.</p>
</td></tr>
<tr><td><code id="dydx_+3A_fwrap">fwrap</code></td>
<td>
<p>A logical specifying how to name factor columns in the response.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions provide a simple interface to the calculation of marginal effects for specific variables used in a model, and are the workhorse functions called internally by <code><a href="#topic+marginal_effects">marginal_effects</a></code>.
</p>
<p><code>dydx</code> is an S3 generic with classes implemented for specific variable types. S3 method dispatch, somewhat atypically, is based upon the class of <code>data[[variable]]</code>.
</p>
<p>For numeric (and integer) variables, the method calculates an instantaneous marginal effect using a simple &ldquo;central difference&rdquo; numerical differentiation:
</p>
<p style="text-align: center;"><code class="reqn">\frac{f(x + \frac{1}{2}h) - f(x - \frac{1}{2}h)}{dh}</code>
</p>
<p>, where (<code class="reqn">h = \max(|x|, 1) \sqrt{\epsilon}</code> and the value of <code class="reqn">\epsilon</code> is given by argument <code>eps</code>. This procedure is subject to change in the future.
</p>
<p>For factor variables (or character variables, which are implicitly coerced to factors by modelling functions), discrete first-differences in predicted outcomes are reported instead (i.e., change in predicted outcome when factor is set to a given level minus the predicted outcome when the factor is set to its baseline level). These are sometimes called &ldquo;partial effects&rdquo;. If you want to use numerical differentiation for factor variables (which you probably do not want to do), enter them into the original modelling function as numeric values rather than factors.
</p>
<p>For ordered factor variables, the same approach as factors is used. This may contradict the output of modelling function summaries, which rely on <code>options("contrasts")</code> to determine the contrasts to use (the default being <code><a href="stats.html#topic+contr.poly">contr.poly</a></code> rather than <code><a href="stats.html#topic+contr.treatment">contr.treatment</a></code>, the latter being used normally for unordered factors).
</p>
<p>For logical variables, the same approach as factors is used, but always moving from <code>FALSE</code> to <code>TRUE</code>.
</p>


<h3>Value</h3>

<p>A data frame, typically with one column unless the variable is a factor with more than two levels. The names of the marginal effect columns begin with &ldquo;dydx_&rdquo; to distinguish them from the substantive variables of the same names.
</p>


<h3>References</h3>

<p>Miranda, Mario J. and Paul L. Fackler. 2002. <em>Applied Computational Economics and Finance</em>. p. 103.
</p>
<p>Greene, William H. 2012. <em>Econometric Analysis</em>. 7th edition. pp. 733&ndash;741.
</p>
<p>Cameron, A. Colin and Pravin K. Trivedi. 2010. <em>Microeconometric Using Stata</em>. Revised edition. pp. 106&ndash;108, 343&ndash;356, 476&ndash;478.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+marginal_effects">marginal_effects</a></code>, <code><a href="#topic+margins">margins</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require("datasets")
x &lt;- lm(mpg ~ cyl * hp + wt, data = head(mtcars))
# marginal effect (numerical derivative)
dydx(head(mtcars), x, "hp")

# other discrete differences
## change from min(mtcars$hp) to max(mtcars$hp)
dydx(head(mtcars), x, "hp", change = "minmax")
## change from 1st quartile to 3rd quartile
dydx(head(mtcars), x, "hp", change = "iqr")
## change from mean(mtcars$hp) +/- sd(mtcars$hp)
dydx(head(mtcars), x, "hp", change = "sd")
## change between arbitrary values of mtcars$hp
dydx(head(mtcars), x, "hp", change = c(75,150))

# factor variables
mtcars[["cyl"]] &lt;- factor(mtcars$cyl)
x &lt;- lm(mpg ~ cyl, data = head(mtcars))
dydx(head(mtcars), x, "cyl")

</code></pre>

<hr>
<h2 id='image.lm'>Perspective and heatmap/contour plots for models</h2><span id='topic+image.lm'></span><span id='topic+image.glm'></span><span id='topic+image.loess'></span><span id='topic+persp.lm'></span><span id='topic+persp.glm'></span><span id='topic+persp.loess'></span>

<h3>Description</h3>

<p>Draw one or more perspectives plots reflecting predictions or marginal effects from a model, or the same using a flat heatmap or &ldquo;filled contour&rdquo; (<code><a href="graphics.html#topic+image">image</a></code>) representation. Currently methods exist for &ldquo;lm&rdquo;, &ldquo;glm&rdquo;, and &ldquo;loess&rdquo; models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lm'
image(
  x,
  xvar = attributes(terms(x))[["term.labels"]][1],
  yvar = attributes(terms(x))[["term.labels"]][2],
  dx = xvar,
  what = c("prediction", "effect"),
  type = c("response", "link"),
  vcov = stats::vcov(x),
  nx = 25L,
  ny = nx,
  nz = 20,
  xlab = xvar,
  ylab = yvar,
  xaxs = "i",
  yaxs = xaxs,
  bty = "o",
  col = gray(seq(0.05, 0.95, length.out = nz), alpha = 0.75),
  contour = TRUE,
  contour.labels = NULL,
  contour.drawlabels = TRUE,
  contour.cex = 0.6,
  contour.col = "black",
  contour.lty = 1,
  contour.lwd = 1,
  ...
)

## S3 method for class 'glm'
image(
  x,
  xvar = attributes(terms(x))[["term.labels"]][1],
  yvar = attributes(terms(x))[["term.labels"]][2],
  dx = xvar,
  what = c("prediction", "effect"),
  type = c("response", "link"),
  vcov = stats::vcov(x),
  nx = 25L,
  ny = nx,
  nz = 20,
  xlab = xvar,
  ylab = yvar,
  xaxs = "i",
  yaxs = xaxs,
  bty = "o",
  col = gray(seq(0.05, 0.95, length.out = nz), alpha = 0.75),
  contour = TRUE,
  contour.labels = NULL,
  contour.drawlabels = TRUE,
  contour.cex = 0.6,
  contour.col = "black",
  contour.lty = 1,
  contour.lwd = 1,
  ...
)

## S3 method for class 'loess'
image(
  x,
  xvar = attributes(terms(x))[["term.labels"]][1],
  yvar = attributes(terms(x))[["term.labels"]][2],
  dx = xvar,
  what = c("prediction", "effect"),
  type = c("response", "link"),
  vcov = stats::vcov(x),
  nx = 25L,
  ny = nx,
  nz = 20,
  xlab = xvar,
  ylab = yvar,
  xaxs = "i",
  yaxs = xaxs,
  bty = "o",
  col = gray(seq(0.05, 0.95, length.out = nz), alpha = 0.75),
  contour = TRUE,
  contour.labels = NULL,
  contour.drawlabels = TRUE,
  contour.cex = 0.6,
  contour.col = "black",
  contour.lty = 1,
  contour.lwd = 1,
  ...
)

## S3 method for class 'lm'
persp(
  x,
  xvar = attributes(terms(x))[["term.labels"]][1],
  yvar = attributes(terms(x))[["term.labels"]][2],
  dx = xvar,
  what = c("prediction", "effect"),
  type = c("response", "link"),
  vcov = stats::vcov(x),
  nx = 25L,
  ny = nx,
  theta = 45,
  phi = 10,
  shade = 0.75,
  xlab = xvar,
  ylab = yvar,
  zlab = if (match.arg(what) == "prediction") "Predicted value" else
    paste0("Marginal effect of ", dx),
  ticktype = c("detailed", "simple"),
  ...
)

## S3 method for class 'glm'
persp(
  x,
  xvar = attributes(terms(x))[["term.labels"]][1],
  yvar = attributes(terms(x))[["term.labels"]][2],
  dx = xvar,
  what = c("prediction", "effect"),
  type = c("response", "link"),
  vcov = stats::vcov(x),
  nx = 25L,
  ny = nx,
  theta = 45,
  phi = 10,
  shade = 0.75,
  xlab = xvar,
  ylab = yvar,
  zlab = if (match.arg(what) == "prediction") "Predicted value" else
    paste0("Marginal effect of ", dx),
  ticktype = c("detailed", "simple"),
  ...
)

## S3 method for class 'loess'
persp(
  x,
  xvar = attributes(terms(x))[["term.labels"]][1],
  yvar = attributes(terms(x))[["term.labels"]][2],
  dx = xvar,
  what = c("prediction", "effect"),
  type = c("response", "link"),
  vcov = stats::vcov(x),
  nx = 25L,
  ny = nx,
  theta = 45,
  phi = 10,
  shade = 0.75,
  xlab = xvar,
  ylab = yvar,
  zlab = if (match.arg(what) == "prediction") "Predicted value" else
    paste0("Marginal effect of ", dx),
  ticktype = c("detailed", "simple"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="image.lm_+3A_x">x</code></td>
<td>
<p>A model object.</p>
</td></tr>
<tr><td><code id="image.lm_+3A_xvar">xvar</code></td>
<td>
<p>A character string specifying the name of variable to use as the &lsquo;<span class="samp">&#8288;x&#8288;</span>&rsquo; dimension in the plot. See <code><a href="graphics.html#topic+persp">persp</a></code> for details.</p>
</td></tr>
<tr><td><code id="image.lm_+3A_yvar">yvar</code></td>
<td>
<p>A character string specifying the name of variable to use as the &lsquo;<span class="samp">&#8288;y&#8288;</span>&rsquo; dimension in the plot. See <code><a href="graphics.html#topic+persp">persp</a></code> for details.</p>
</td></tr>
<tr><td><code id="image.lm_+3A_dx">dx</code></td>
<td>
<p>A character string specifying the name of the variable for which the conditional average marginal effect is desired when <code>what = "effect"</code>. By default this is <code>xvar</code>.</p>
</td></tr>
<tr><td><code id="image.lm_+3A_what">what</code></td>
<td>
<p>A character string specifying whether to draw &ldquo;prediction&rdquo; (fitted values from the model, calculated using <code><a href="stats.html#topic+predict">predict</a></code>) or &ldquo;effect&rdquo; (marginal effect of <code>dx</code>, using <code><a href="#topic+margins">margins</a></code>).</p>
</td></tr>
<tr><td><code id="image.lm_+3A_type">type</code></td>
<td>
<p>A character string specifying whether to calculate predictions on the response scale (default) or link (only relevant for non-linear models).</p>
</td></tr>
<tr><td><code id="image.lm_+3A_vcov">vcov</code></td>
<td>
<p>A matrix containing the variance-covariance matrix for estimated model coefficients, or a function to perform the estimation with <code>model</code> as its only argument.</p>
</td></tr>
<tr><td><code id="image.lm_+3A_nx">nx</code></td>
<td>
<p>An integer specifying the number of points across <code>x</code> at which to calculate the predicted value or marginal effect.</p>
</td></tr>
<tr><td><code id="image.lm_+3A_ny">ny</code></td>
<td>
<p>An integer specifying the number of points across <code>y</code> at which to calculate the predicted value or marginal effect.</p>
</td></tr>
<tr><td><code id="image.lm_+3A_nz">nz</code></td>
<td>
<p>An integer specifying, for <code>image</code>, the number of breakpoints to use when coloring the plot.</p>
</td></tr>
<tr><td><code id="image.lm_+3A_xlab">xlab</code></td>
<td>
<p>A character string specifying the value of <code>xlab</code> in <code><a href="graphics.html#topic+persp">persp</a></code> or <code><a href="graphics.html#topic+image">image</a></code>.</p>
</td></tr>
<tr><td><code id="image.lm_+3A_ylab">ylab</code></td>
<td>
<p>A character string specifying the value of <code>ylab</code> in <code><a href="graphics.html#topic+persp">persp</a></code> or <code><a href="graphics.html#topic+image">image</a></code>.</p>
</td></tr>
<tr><td><code id="image.lm_+3A_xaxs">xaxs</code></td>
<td>
<p>A character string specifying the x-axis type (see <code><a href="graphics.html#topic+par">par</a></code>).</p>
</td></tr>
<tr><td><code id="image.lm_+3A_yaxs">yaxs</code></td>
<td>
<p>A character string specifying the y-axis type (see <code><a href="graphics.html#topic+par">par</a></code>).</p>
</td></tr>
<tr><td><code id="image.lm_+3A_bty">bty</code></td>
<td>
<p>A character string specifying the box type (see <code><a href="graphics.html#topic+par">par</a></code>).</p>
</td></tr>
<tr><td><code id="image.lm_+3A_col">col</code></td>
<td>
<p>A character vector specifying colors to use when coloring the contour plot.</p>
</td></tr>
<tr><td><code id="image.lm_+3A_contour">contour</code></td>
<td>
<p>For <code>image</code>, a logical specifying whether to overlay contour lines onto the heatmap using <code><a href="graphics.html#topic+contour">contour</a></code>.</p>
</td></tr>
<tr><td><code id="image.lm_+3A_contour.labels">contour.labels</code></td>
<td>
<p>For <code>image</code>, if <code>contour = TRUE</code> a logical specifying whether to overlay contour lines onto the heatmap.</p>
</td></tr>
<tr><td><code id="image.lm_+3A_contour.drawlabels">contour.drawlabels</code></td>
<td>
<p>For <code>image</code>, if <code>contour = TRUE</code> a logical specifying whether to overlay contour lines onto the heatmap.</p>
</td></tr>
<tr><td><code id="image.lm_+3A_contour.cex">contour.cex</code></td>
<td>
<p>For <code>image</code>, if <code>contour = TRUE</code> and <code>contour.drawlabels = TRUE</code> a numeric specifying the label size for contour line labels (see <code><a href="graphics.html#topic+par">par</a></code>).</p>
</td></tr>
<tr><td><code id="image.lm_+3A_contour.col">contour.col</code></td>
<td>
<p>For <code>image</code>, if <code>contour = TRUE</code> a character string specifying a color for contour lines.</p>
</td></tr>
<tr><td><code id="image.lm_+3A_contour.lty">contour.lty</code></td>
<td>
<p>For <code>image</code>, if <code>contour = TRUE</code> an integer specifying a line type for contour lines (see <code><a href="graphics.html#topic+par">par</a></code>).</p>
</td></tr>
<tr><td><code id="image.lm_+3A_contour.lwd">contour.lwd</code></td>
<td>
<p>For <code>image</code>, if <code>contour = TRUE</code> an integer specifying a line width for contour lines (see <code><a href="graphics.html#topic+par">par</a></code>).</p>
</td></tr>
<tr><td><code id="image.lm_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code><a href="graphics.html#topic+persp">persp</a></code> or <code><a href="graphics.html#topic+image">image</a></code>.</p>
</td></tr>
<tr><td><code id="image.lm_+3A_theta">theta</code></td>
<td>
<p>For <code>persp</code>, an integer vector specifying the value of <code>theta</code> in <code><a href="graphics.html#topic+persp">persp</a></code>. If length greater than 1, multiple subplots are drawn with different rotations.</p>
</td></tr>
<tr><td><code id="image.lm_+3A_phi">phi</code></td>
<td>
<p>For <code>persp</code>, an integer vector specifying the value of <code>phi</code> in <code><a href="graphics.html#topic+persp">persp</a></code>. If length greater than 1, multiple subplots are drawn with different rotations.</p>
</td></tr>
<tr><td><code id="image.lm_+3A_shade">shade</code></td>
<td>
<p>For <code>persp</code>, an integer vector specifying the value of <code>shade</code> in <code><a href="graphics.html#topic+persp">persp</a></code>.</p>
</td></tr>
<tr><td><code id="image.lm_+3A_zlab">zlab</code></td>
<td>
<p>A character string specifying the value of <code>zlab</code> (vertical axis label) in <code><a href="graphics.html#topic+persp">persp</a></code>.</p>
</td></tr>
<tr><td><code id="image.lm_+3A_ticktype">ticktype</code></td>
<td>
<p>A character string specifying one of: &ldquo;detailed&rdquo; (the default) or &ldquo;simple&rdquo;. See <code><a href="graphics.html#topic+persp">persp</a></code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+plot.margins">plot.margins</a></code>, <code><a href="#topic+cplot">cplot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
  require('datasets')
  # prediction from several angles
  m &lt;- lm(mpg ~ wt*drat, data = mtcars)
  persp(m, theta = c(45, 135, 225, 315))

  # flat/heatmap representation
  image(m)

  # marginal effect of 'drat' across drat and wt
  m &lt;- lm(mpg ~ wt*drat*I(drat^2), data = mtcars)
  persp(m, xvar = "drat", yvar = "wt", what = "effect", 
        nx = 10, ny = 10, ticktype = "detailed")

  # a non-linear model
  m &lt;- glm(am ~ wt*drat, data = mtcars, family = binomial)
  persp(m, theta = c(30, 60)) # prediction
  # flat/heatmap representation
  image(m)

  # effects on linear predictor and outcome
  persp(m, xvar = "drat", yvar = "wt", what = "effect", type = "link")
  persp(m, xvar = "drat", yvar = "wt", what = "effect", type = "response")

## End(Not run)

</code></pre>

<hr>
<h2 id='marginal_effects'>Differentiate a Model Object with Respect to All (or Specified) Variables</h2><span id='topic+marginal_effects'></span><span id='topic+marginal_effects.margins'></span><span id='topic+marginal_effects.clm'></span><span id='topic+marginal_effects.default'></span><span id='topic+marginal_effects.glm'></span><span id='topic+marginal_effects.lm'></span><span id='topic+marginal_effects.loess'></span><span id='topic+marginal_effects.merMod'></span><span id='topic+marginal_effects.lmerMod'></span><span id='topic+marginal_effects.multinom'></span><span id='topic+marginal_effects.nnet'></span><span id='topic+marginal_effects.polr'></span>

<h3>Description</h3>

<p>Extract marginal effects from a model object, conditional on data, using <code><a href="#topic+dydx">dydx</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>marginal_effects(model, data, variables = NULL, ...)

## S3 method for class 'margins'
marginal_effects(model, data, variables = NULL, ...)

## S3 method for class 'clm'
marginal_effects(
  model,
  data = find_data(model, parent.frame()),
  variables = NULL,
  type = NULL,
  eps = 1e-07,
  varslist = NULL,
  as.data.frame = TRUE,
  ...
)

## Default S3 method:
marginal_effects(
  model,
  data = find_data(model, parent.frame()),
  variables = NULL,
  type = c("response", "link"),
  eps = 1e-07,
  as.data.frame = TRUE,
  varslist = NULL,
  ...
)

## S3 method for class 'glm'
marginal_effects(
  model,
  data = find_data(model, parent.frame()),
  variables = NULL,
  type = c("response", "link"),
  eps = 1e-07,
  varslist = NULL,
  as.data.frame = TRUE,
  ...
)

## S3 method for class 'lm'
marginal_effects(
  model,
  data = find_data(model, parent.frame()),
  variables = NULL,
  type = c("response", "link"),
  eps = 1e-07,
  varslist = NULL,
  as.data.frame = TRUE,
  ...
)

## S3 method for class 'loess'
marginal_effects(
  model,
  data = find_data(model, parent.frame()),
  variables = NULL,
  type = c("response", "link"),
  eps = 1e-07,
  as.data.frame = TRUE,
  varslist = NULL,
  ...
)

## S3 method for class 'merMod'
marginal_effects(
  model,
  data = find_data(model),
  variables = NULL,
  type = c("response", "link"),
  eps = 1e-07,
  as.data.frame = TRUE,
  varslist = NULL,
  ...
)

## S3 method for class 'lmerMod'
marginal_effects(
  model,
  data = find_data(model),
  variables = NULL,
  type = c("response", "link"),
  eps = 1e-07,
  as.data.frame = TRUE,
  varslist = NULL,
  ...
)

## S3 method for class 'multinom'
marginal_effects(
  model,
  data = find_data(model, parent.frame()),
  variables = NULL,
  type = NULL,
  eps = 1e-07,
  varslist = NULL,
  as.data.frame = TRUE,
  ...
)

## S3 method for class 'nnet'
marginal_effects(
  model,
  data = find_data(model, parent.frame()),
  variables = NULL,
  type = NULL,
  eps = 1e-07,
  varslist = NULL,
  as.data.frame = TRUE,
  ...
)

## S3 method for class 'polr'
marginal_effects(
  model,
  data = find_data(model, parent.frame()),
  variables = NULL,
  type = NULL,
  eps = 1e-07,
  varslist = NULL,
  as.data.frame = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="marginal_effects_+3A_model">model</code></td>
<td>
<p>A model object, perhaps returned by <code><a href="stats.html#topic+lm">lm</a></code> or <code><a href="stats.html#topic+glm">glm</a></code></p>
</td></tr>
<tr><td><code id="marginal_effects_+3A_data">data</code></td>
<td>
<p>A data.frame over which to calculate marginal effects. This is optional, but may be required when the underlying modelling function sets <code>model = FALSE</code>.</p>
</td></tr>
<tr><td><code id="marginal_effects_+3A_variables">variables</code></td>
<td>
<p>A character vector with the names of variables for which to compute the marginal effects. The default (<code>NULL</code>) returns marginal effects for all variables.</p>
</td></tr>
<tr><td><code id="marginal_effects_+3A_...">...</code></td>
<td>
<p>Arguments passed to methods, and onward to <code><a href="#topic+dydx">dydx</a></code> methods and possibly further to <code><a href="prediction.html#topic+prediction">prediction</a></code> methods. This can be useful, for example, for setting <code>type</code> (predicted value type), <code>eps</code> (precision), or <code>category</code> (category for multi-category outcome models), etc.</p>
</td></tr>
<tr><td><code id="marginal_effects_+3A_type">type</code></td>
<td>
<p>A character string indicating the type of marginal effects to estimate. Mostly relevant for non-linear models, where the reasonable options are &ldquo;response&rdquo; (the default) or &ldquo;link&rdquo; (i.e., on the scale of the linear predictor in a GLM).</p>
</td></tr>
<tr><td><code id="marginal_effects_+3A_eps">eps</code></td>
<td>
<p>A numeric value specifying the &ldquo;step&rdquo; to use when calculating numerical derivatives. By default this is the smallest floating point value that can be represented on the present architecture.</p>
</td></tr>
<tr><td><code id="marginal_effects_+3A_varslist">varslist</code></td>
<td>
<p>A list structure used internally by <code><a href="#topic+margins">margins</a></code>. Users should not set this.</p>
</td></tr>
<tr><td><code id="marginal_effects_+3A_as.data.frame">as.data.frame</code></td>
<td>
<p>A logical indicating whether to return a data frame (the default) or a matrix.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Users likely want to use the fully featured <code><a href="#topic+margins">margins</a></code> function rather than <code>marginal_effects</code>, which merely performs estimation of the marginal effects but simply returns a data frame. <code><a href="#topic+margins">margins</a></code>, by contrast, does some convenient packaging around these results and supports additional functionality, like variance estimation and counterfactual estimation procedures. The methods for this function provide lower-level functionality that extracts unit-specific marginal effects from an estimated model with respect to <em>all</em> variables specified in <code>data</code> (or the subset specified in <code>variables</code>) and returns a data frame. See <code><a href="#topic+dydx">dydx</a></code> for computational details. Note that for factor and logical class variables, discrete changes in the outcome are reported rather than instantaneous marginal effects.
</p>
<p>Methods are currently implemented for the following object classes:
</p>

<ul>
<li> <p>&ldquo;betareg&rdquo;, see <code><a href="betareg.html#topic+betareg">betareg</a></code>
</p>
</li>
<li> <p>&ldquo;glm&rdquo;, see <code><a href="stats.html#topic+glm">glm</a></code>, <code><a href="MASS.html#topic+glm.nb">glm.nb</a></code>
</p>
</li>
<li> <p>&ldquo;ivreg&rdquo;, see <code><a href="AER.html#topic+ivreg">ivreg</a></code>
</p>
</li>
<li> <p>&ldquo;lm&rdquo;, see <code><a href="stats.html#topic+lm">lm</a></code>
</p>
</li>
<li> <p>&ldquo;loess&rdquo;, see <code><a href="stats.html#topic+loess">loess</a></code>
</p>
</li>
<li> <p>&ldquo;merMod&rdquo;, see <code><a href="lme4.html#topic+lmer">lmer</a></code>, <code><a href="lme4.html#topic+glmer">glmer</a></code>
</p>
</li>
<li> <p>&ldquo;multinom&rdquo;, see <code><a href="nnet.html#topic+multinom">multinom</a></code>
</p>
</li>
<li> <p>&ldquo;nnet&rdquo;, see <code><a href="nnet.html#topic+nnet">nnet</a></code>
</p>
</li>
<li> <p>&ldquo;polr&rdquo;, see <code><a href="MASS.html#topic+polr">polr</a></code>
</p>
</li>
<li> <p>&ldquo;svyglm&rdquo;, see <code><a href="survey.html#topic+svyglm">svyglm</a></code>
</p>
</li></ul>

<p>A method is also provided for the object classes &ldquo;margins&rdquo; to return a simplified data frame from complete &ldquo;margins&rdquo; objects.
</p>


<h3>Value</h3>

<p>An data frame with number of rows equal to <code>nrow(data)</code>, where each row is an observation and each column is the marginal effect of a variable used in the model formula.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dydx">dydx</a></code>, <code><a href="#topic+margins">margins</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require("datasets")
x &lt;- lm(mpg ~ cyl * hp + wt, data = mtcars)
marginal_effects(x)

# factor variables report discrete differences
x &lt;- lm(mpg ~ factor(cyl) * factor(am), data = mtcars)
marginal_effects(x)

# get just marginal effects from "margins" object
require('datasets')
m &lt;- margins(lm(mpg ~ hp, data = mtcars[1:10,]))
marginal_effects(m)
marginal_effects(m)

# multi-category outcome
if (requireNamespace("nnet")) {
  data("iris3", package = "datasets")
  ird &lt;- data.frame(rbind(iris3[,,1], iris3[,,2], iris3[,,3]),
                    species = factor(c(rep("s",50), rep("c", 50), rep("v", 50))))
  m &lt;- nnet::nnet(species ~ ., data = ird, size = 2, rang = 0.1,
                  decay = 5e-4, maxit = 200, trace = FALSE)
  marginal_effects(m) # default
  marginal_effects(m, category = "v") # explicit category
}

</code></pre>

<hr>
<h2 id='plot.margins'>Plot Marginal Effects Estimates</h2><span id='topic+plot.margins'></span>

<h3>Description</h3>

<p>An implementation of Stata's &lsquo;<span class="samp">&#8288;marginsplot&#8288;</span>&rsquo; as an S3 generic function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'margins'
plot(
  x,
  pos = seq_along(marginal_effects(x, with_at = FALSE)),
  which = colnames(marginal_effects(x, with_at = FALSE)),
  labels = gsub("^dydx_", "", which),
  horizontal = FALSE,
  xlab = "",
  ylab = "Average Marginal Effect",
  level = 0.95,
  pch = 21,
  points.col = "black",
  points.bg = "black",
  las = 1,
  cex = 1,
  lwd = 2,
  zeroline = TRUE,
  zero.col = "gray",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.margins_+3A_x">x</code></td>
<td>
<p>An object of class &ldquo;margins&rdquo;, as returned by <code><a href="#topic+margins">margins</a></code>.</p>
</td></tr>
<tr><td><code id="plot.margins_+3A_pos">pos</code></td>
<td>
<p>A numeric vector specifying the x-positions of the estimates (or y-positions, if <code>horizontal = TRUE</code>).</p>
</td></tr>
<tr><td><code id="plot.margins_+3A_which">which</code></td>
<td>
<p>A character vector specifying which marginal effect estimate to plot. Default is all.</p>
</td></tr>
<tr><td><code id="plot.margins_+3A_labels">labels</code></td>
<td>
<p>A character vector specifying the axis labels to use for the marginal effect estimates. Default is the variable names from <code>x</code>.</p>
</td></tr>
<tr><td><code id="plot.margins_+3A_horizontal">horizontal</code></td>
<td>
<p>A logical indicating whether to plot the estimates along the x-axis with vertical confidence intervals (the default), or along the y-axis with horizontal confidence intervals.</p>
</td></tr>
<tr><td><code id="plot.margins_+3A_xlab">xlab</code></td>
<td>
<p>A character string specifying the x-axis (or y-axis, if <code>horizontal = TRUE</code>) label.</p>
</td></tr>
<tr><td><code id="plot.margins_+3A_ylab">ylab</code></td>
<td>
<p>A character string specifying the y-axis (or x-axis, if <code>horizontal = TRUE</code>) label.</p>
</td></tr>
<tr><td><code id="plot.margins_+3A_level">level</code></td>
<td>
<p>A numeric value between 0 and 1 indicating the confidence level to use when drawing error bars.</p>
</td></tr>
<tr><td><code id="plot.margins_+3A_pch">pch</code></td>
<td>
<p>The point symbol to use for plotting marginal effect point estimates. See <code><a href="graphics.html#topic+points">points</a></code> for details.</p>
</td></tr>
<tr><td><code id="plot.margins_+3A_points.col">points.col</code></td>
<td>
<p>The point color to use for plotting marginal effect point estimates. See <code><a href="graphics.html#topic+points">points</a></code> for details.</p>
</td></tr>
<tr><td><code id="plot.margins_+3A_points.bg">points.bg</code></td>
<td>
<p>The point color to use for plotting marginal effect point estimates. See <code><a href="graphics.html#topic+points">points</a></code> for details.</p>
</td></tr>
<tr><td><code id="plot.margins_+3A_las">las</code></td>
<td>
<p>An integer value specifying the orientation of the axis labels. See <code><a href="graphics.html#topic+par">par</a></code> for details.</p>
</td></tr>
<tr><td><code id="plot.margins_+3A_cex">cex</code></td>
<td>
<p>A numerical value giving the amount by which plotting text and symbols should be magnified relative to the default. See <code><a href="graphics.html#topic+par">par</a></code> for details.</p>
</td></tr>
<tr><td><code id="plot.margins_+3A_lwd">lwd</code></td>
<td>
<p>A numerical value giving the width of error bars in points.</p>
</td></tr>
<tr><td><code id="plot.margins_+3A_zeroline">zeroline</code></td>
<td>
<p>A logical indicating whether to draw a line indicating zero. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="plot.margins_+3A_zero.col">zero.col</code></td>
<td>
<p>A character string indicating a color to use for the zero line if <code>zeroline = TRUE</code>.</p>
</td></tr>
<tr><td><code id="plot.margins_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code><a href="graphics.html#topic+plot.default">plot.default</a></code>, such as <code>title</code>, etc.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is invoked for its side effect: a basic dot plot with error bars displaying marginal effects as generated by <code><a href="#topic+margins">margins</a></code>, in the style of Stata's &lsquo;<span class="samp">&#8288;marginsplot&#8288;</span>&rsquo; command.
</p>


<h3>Value</h3>

<p>The original &ldquo;margins&rdquo; object <code>x</code>, invisibly.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+margins">margins</a></code>, <code><a href="#topic+persp.lm">persp.lm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
  require("datasets")
  x &lt;- lm(mpg ~ cyl * hp + wt, data = mtcars)
  mar &lt;- margins(x)
  plot(mar)

## End(Not run)

</code></pre>

<hr>
<h2 id='reexports'>Objects exported from other packages</h2><span id='topic+reexports'></span><span id='topic+prediction'></span><span id='topic+find_data'></span>

<h3>Description</h3>

<p>These objects are imported from other packages. Follow the links
below to see their documentation.
</p>

<dl>
<dt>prediction</dt><dd><p><code><a href="prediction.html#topic+find_data">find_data</a></code>, <code><a href="prediction.html#topic+prediction">prediction</a></code></p>
</dd>
</dl>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
