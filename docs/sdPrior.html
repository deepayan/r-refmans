<!DOCTYPE html><html lang="en"><head><title>Help for package sdPrior</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {sdPrior}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#dapprox_unif'><p>Compute Density Function of Approximated (Differentiably) Uniform Distribution.</p></a></li>
<li><a href='#DesignM'><p>Computing Designmatrix for Splines</p></a></li>
<li><a href='#get_theta'><p>Find Scale Parameter for (Scale Dependent) Hyperprior</p></a></li>
<li><a href='#get_theta_aunif'><p>Find Scale Parameter for Hyperprior for Variances Where the Standard Deviations have an</p>
Approximated (Differentiably) Uniform Distribution.</a></li>
<li><a href='#get_theta_ga'><p>Find Scale Parameter for Gamma (Half-Normal) Hyperprior</p></a></li>
<li><a href='#get_theta_gbp'><p>Find Scale Parameter for Generalised Beta Prime (Half-Cauchy) Hyperprior</p></a></li>
<li><a href='#get_theta_ig'><p>Find Scale Parameter for Inverse Gamma Hyperprior</p></a></li>
<li><a href='#get_theta_linear'><p>Find Scale Parameter for Inverse Gamma Hyperprior of Linear Effects with Spike and Slab Prior</p></a></li>
<li><a href='#hyperpar'><p>Find Scale Parameters for Inverse Gamma Hyperprior of Nonlinear Effects with Spike and Slab Prior (Simulation-based)</p></a></li>
<li><a href='#hyperpar_mod'><p>Find Scale Parameter for modular regression</p></a></li>
<li><a href='#hyperparlin'><p>Find Scale Parameter for Inverse Gamma Hyperprior of Linear Effects with Spike and Slab Prior</p></a></li>
<li><a href='#mdbeta'><p>Marginal Density of <code class="reqn">\beta</code></p></a></li>
<li><a href='#mdf_aunif'><p>Marginal Density for Given Scale Parameter and Approximated Uniform Prior for <code class="reqn">\tau</code></p></a></li>
<li><a href='#mdf_ga'><p>Marginal Density for Given Scale Parameter and Half-Normal Prior for <code class="reqn">\tau</code></p></a></li>
<li><a href='#mdf_gbp'><p>Marginal Density for Given Scale Parameter and Half-Cauchy Prior for <code class="reqn">\tau</code></p></a></li>
<li><a href='#mdf_ig'><p>Marginal Density for Given Scale Parameter and Inverse Gamma Prior for <code class="reqn">\tau^2</code></p></a></li>
<li><a href='#mdf_sd'><p>Marginal Density for Given Scale Parameter and Scale-Dependent Prior for <code class="reqn">\tau^2</code></p></a></li>
<li><a href='#papprox_unif'><p>Compute Cumulative Distribution Function of Approximated (Differentiably) Uniform Distribution.</p></a></li>
<li><a href='#rapprox_unif'><p>Draw Random Numbers from Approximated (Differentiably) Uniform Distribution.</p></a></li>
<li><a href='#zambia_graph'><p>Prior precision  matrix for spatial variable in Zambia data set</p></a></li>
<li><a href='#zambia_height92'><p>Malnutrition in Zambia</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Scale-Dependent Hyperpriors in Structured Additive
Distributional Regression</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0-0</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Nadja Klein &lt;nadja.klein@hu-berlin.de&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Utility functions for scale-dependent and alternative hyperpriors. The distribution parameters may capture location, scale, shape, etc. and every parameter may depend
  on complex additive terms (fixed, random, smooth, spatial, etc.) similar to a generalized additive model. Hyperpriors for all effects can be elicitated within the package. Including complex tensor product interaction terms and variable selection priors. The basic model is explained in in Klein and Kneib (2016) &lt;<a href="https://doi.org/10.1214%2F15-BA983">doi:10.1214/15-BA983</a>&gt;.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.1.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>splines, GB2, MASS, stats, pscl, mvtnorm, mgcv, graphics,
doParallel, parallel</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2018-10-06 11:34:16 UTC; nadja.klein</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.0.1</td>
</tr>
<tr>
<td>Author:</td>
<td>Nadja Klein [aut, cre]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2018-10-06 21:00:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='dapprox_unif'>Compute Density Function of Approximated (Differentiably) Uniform Distribution.</h2><span id='topic+dapprox_unif'></span>

<h3>Description</h3>

<p>Compute Density Function of Approximated (Differentiably) Uniform Distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dapprox_unif(x, scale, tildec = 13.86294)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dapprox_unif_+3A_x">x</code></td>
<td>
<p>denotes the argument of the density function.</p>
</td></tr>
<tr><td><code id="dapprox_unif_+3A_scale">scale</code></td>
<td>
<p>the scale parameter originally defining the upper bound of the uniform distribution.</p>
</td></tr>
<tr><td><code id="dapprox_unif_+3A_tildec">tildec</code></td>
<td>
<p>denotes the ratio between scale parameter <code class="reqn">\theta</code> and <code class="reqn">s</code>. The latter is responsible for the closeness of
the approximation to the uniform distribution. See also below for further details and the default value.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The density of the uniform distribution for <code class="reqn">\tau</code> is approximated by
</p>
<p style="text-align: center;"><code class="reqn">p(\tau)=(1/(1+exp(\tau\tilde{c}/\theta-\tilde{c})))/(\theta(1+log(1+exp(-\tilde{c}))))</code>
</p>
<p>.
This results in </p>
<p style="text-align: center;"><code class="reqn">p(\tau^2)=0.5*(\tau^2)^(-1/2)(1/(1+exp((\tau^2)^(1/2)\tilde{c}/\theta-\tilde{c})))/(\theta(1+log(1+exp(-\tilde{c}))))</code>
</p>
<p> for <code class="reqn">tau^2</code>.
<code class="reqn">\tilde{c}</code> is chosen such that <code class="reqn">P(\tau&lt;=\theta)&gt;=0.95</code>.
</p>


<h3>Value</h3>

<p>the density.
</p>


<h3>Author(s)</h3>

<p>Nadja Klein
</p>


<h3>References</h3>

<p>Nadja Klein and Thomas Kneib (2015). Scale-Dependent Priors for Variance Parameters in Structured Additive Distributional Regression. 
<em>Working Paper</em>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rapprox_unif">rapprox_unif</a></code>,<code><a href="#topic+papprox_unif">papprox_unif</a></code>
</p>

<hr>
<h2 id='DesignM'>Computing Designmatrix for Splines</h2><span id='topic+DesignM'></span>

<h3>Description</h3>

<p>This function computes the design matrix for Bayesian P-splines as it would be done in 
BayesX. The implementation currently on works properly for default values (knots=20, degree=3).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DesignM(x, degree = 3, m = 20, min_x = min(x), max_x = max(x))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="DesignM_+3A_x">x</code></td>
<td>
<p>the covariate vector.</p>
</td></tr>
<tr><td><code id="DesignM_+3A_degree">degree</code></td>
<td>
<p>of the B-splines, default is 3.</p>
</td></tr>
<tr><td><code id="DesignM_+3A_m">m</code></td>
<td>
<p>number of knots, default is 20.</p>
</td></tr>
<tr><td><code id="DesignM_+3A_min_x">min_x</code></td>
<td>
<p>the left interval boundary, default is min(x).</p>
</td></tr>
<tr><td><code id="DesignM_+3A_max_x">max_x</code></td>
<td>
<p>the right interval boundary, defalut is max(x).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with design matrix at distinct covariates, design matrix at all observations, 
index of sorted observations, the difference matrix, precision matrix and the knots used.
</p>


<h3>Author(s)</h3>

<p>Nadja Klein
</p>


<h3>References</h3>

<p>Stefan Lang and Andy Brezger (2004). Bayesian P-Splines.
<em>Journal of Computational and Graphical Statistics</em>, <b>13</b>, 183&ndash;212.
</p>
<p>Belitz, C., Brezger, A., Klein, N., Kneib, T., Lang, S., Umlauf, N. (2015): BayesX - Software for Bayesian inference in structured additive regression models.
Version 3.0.1. Available from http://www.bayesx.org.
</p>

<hr>
<h2 id='get_theta'>Find Scale Parameter for (Scale Dependent) Hyperprior</h2><span id='topic+get_theta'></span>

<h3>Description</h3>

<p>This function implements a optimisation routine that computes the scale parameter <code class="reqn">\theta</code>
of the scale dependent hyperprior for a given design matrix and prior precision matrix
such that approximately <code class="reqn">P(|f(x_{k}|\le c,k=1,\ldots,p)\ge 1-\alpha</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_theta(alpha = 0.01, method = "integrate", Z, c = 3,
  eps = .Machine$double.eps, Kinv)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_theta_+3A_alpha">alpha</code></td>
<td>
<p>denotes the 1-<code class="reqn">\alpha</code> level.</p>
</td></tr>
<tr><td><code id="get_theta_+3A_method">method</code></td>
<td>
<p>either <code>integrate</code> or <code>trapezoid</code> with <code>integrate</code> as default.
<code>trapezoid</code> is a self-implemented version of the trapezoid rule.</p>
</td></tr>
<tr><td><code id="get_theta_+3A_z">Z</code></td>
<td>
<p>the design matrix.</p>
</td></tr>
<tr><td><code id="get_theta_+3A_c">c</code></td>
<td>
<p>denotes the expected range of the function.</p>
</td></tr>
<tr><td><code id="get_theta_+3A_eps">eps</code></td>
<td>
<p>denotes the error tolerance of the result, default is <code>.Machine$double.eps</code>.</p>
</td></tr>
<tr><td><code id="get_theta_+3A_kinv">Kinv</code></td>
<td>
<p>the generalised inverse of K.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code>list</code> with values from <code><a href="stats.html#topic+uniroot">uniroot</a></code>.
</p>


<h3>Author(s)</h3>

<p>Nadja Klein
</p>


<h3>References</h3>

<p>Nadja Klein and Thomas Kneib (2015). Scale-Dependent Priors for Variance Parameters in Structured Additive Distributional Regression. 
<em>Working Paper</em>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

set.seed(91179)
library(BayesX)
library(MASS)
# prior precision matrix to zambia data set
K &lt;- read.gra(system.file("examples/zambia.gra", package="sdPrior"))
# generalised inverse of K
Kinv &lt;- ginv(K)

# read data
dat &lt;- read.table(system.file("examples/zambia_height92.raw", package="sdPrior"), header = TRUE)

# design matrix for spatial component
Z &lt;- t(sapply(dat$district, FUN=function(x){1*(x==rownames(K))}))

# get scale parameter
theta &lt;- get_theta(alpha = 0.01, method = "integrate", Z = Z, 
                            c = 3, eps = .Machine$double.eps, Kinv = Kinv)$root

## End(Not run) 

</code></pre>

<hr>
<h2 id='get_theta_aunif'>Find Scale Parameter for Hyperprior for Variances Where the Standard Deviations have an 
Approximated (Differentiably) Uniform Distribution.</h2><span id='topic+get_theta_aunif'></span>

<h3>Description</h3>

<p>This function implements a optimisation routine that computes the scale parameter <code class="reqn">\theta</code>
of the prior <code class="reqn">\tau^2</code> (corresponding to a differentiably approximated version of the uniform prior for <code class="reqn">\tau</code>) 
for a given design matrix and prior precision matrix
such that approximately <code class="reqn">P(|f(x_{k}|\le c,k=1,\ldots,p)\ge 1-\alpha</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_theta_aunif(alpha = 0.01, method = "integrate", Z, c = 3,
  eps = .Machine$double.eps, Kinv)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_theta_aunif_+3A_alpha">alpha</code></td>
<td>
<p>denotes the 1-<code class="reqn">\alpha</code> level.</p>
</td></tr>
<tr><td><code id="get_theta_aunif_+3A_method">method</code></td>
<td>
<p>with <code>integrate</code> as default.
Currently no further method implemented.</p>
</td></tr>
<tr><td><code id="get_theta_aunif_+3A_z">Z</code></td>
<td>
<p>the design matrix.</p>
</td></tr>
<tr><td><code id="get_theta_aunif_+3A_c">c</code></td>
<td>
<p>denotes the expected range of the function.</p>
</td></tr>
<tr><td><code id="get_theta_aunif_+3A_eps">eps</code></td>
<td>
<p>denotes the error tolerance of the result, default is <code>.Machine$double.eps</code>.</p>
</td></tr>
<tr><td><code id="get_theta_aunif_+3A_kinv">Kinv</code></td>
<td>
<p>the generalised inverse of K.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code>list</code> with values from <code><a href="stats.html#topic+uniroot">uniroot</a></code>.
</p>


<h3>Author(s)</h3>

<p>Nadja Klein
</p>


<h3>References</h3>

<p>Nadja Klein and Thomas Kneib (2015). Scale-Dependent Priors for Variance Parameters in Structured Additive Distributional Regression. 
<em>Working Paper</em>.
</p>
<p>Andrew Gelman (2006). Prior Distributions for Variance Parameters in Hierarchical Models. 
<em>Bayesian Analysis</em>, <b>1</b>(3), 515&ndash;533.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)
library(MASS)
# prior precision matrix (second order differences) 
# of a spline of degree l=3 and with m=20 inner knots
# yielding dim(K)=m+l-1=22
K &lt;- t(diff(diag(22), differences=2))%*%diff(diag(22), differences=2)
# generalised inverse of K
Kinv &lt;- ginv(K)
# covariate x
x &lt;- runif(1)
Z &lt;- matrix(DesignM(x)$Z_B,nrow=1)
theta &lt;- get_theta_aunif(alpha = 0.01, method = "integrate", Z = Z, 
                            c = 3, eps = .Machine$double.eps, Kinv = Kinv)$root

</code></pre>

<hr>
<h2 id='get_theta_ga'>Find Scale Parameter for Gamma (Half-Normal) Hyperprior</h2><span id='topic+get_theta_ga'></span>

<h3>Description</h3>

<p>This function implements a optimisation routine that computes the scale parameter <code class="reqn">\theta</code>
of the gamma prior for <code class="reqn">\tau^2</code> (corresponding to a half-normal prior for <code class="reqn">\tau</code>) 
for a given design matrix and prior precision matrix
such that approximately <code class="reqn">P(|f(x_{k}|\le c,k=1,\ldots,p)\ge 1-\alpha</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_theta_ga(alpha = 0.01, method = "integrate", Z, c = 3,
  eps = .Machine$double.eps, Kinv)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_theta_ga_+3A_alpha">alpha</code></td>
<td>
<p>denotes the 1-<code class="reqn">\alpha</code> level.</p>
</td></tr>
<tr><td><code id="get_theta_ga_+3A_method">method</code></td>
<td>
<p>with <code>integrate</code> as default.
Currently no further method implemented.</p>
</td></tr>
<tr><td><code id="get_theta_ga_+3A_z">Z</code></td>
<td>
<p>the design matrix.</p>
</td></tr>
<tr><td><code id="get_theta_ga_+3A_c">c</code></td>
<td>
<p>denotes the expected range of the function.</p>
</td></tr>
<tr><td><code id="get_theta_ga_+3A_eps">eps</code></td>
<td>
<p>denotes the error tolerance of the result, default is <code>.Machine$double.eps</code>.</p>
</td></tr>
<tr><td><code id="get_theta_ga_+3A_kinv">Kinv</code></td>
<td>
<p>the generalised inverse of K.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code>list</code> with values from <code><a href="stats.html#topic+uniroot">uniroot</a></code>.
</p>


<h3>Author(s)</h3>

<p>Nadja Klein
</p>


<h3>References</h3>

<p>Nadja Klein and Thomas Kneib (2015). Scale-Dependent Priors for Variance Parameters in Structured Additive Distributional Regression. 
<em>Working Paper</em>.
</p>
<p>Andrew Gelman (2006). Prior Distributions for Variance Parameters in Hierarchical Models. 
<em>Bayesian Analysis</em>, <b>1</b>(3), 515&ndash;533.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)
require(MASS)
# prior precision matrix (second order differences) 
# of a spline of degree l=3 and with m=20 inner knots
# yielding dim(K)=m+l-1=22
K &lt;- t(diff(diag(22), differences=2))%*%diff(diag(22), differences=2)
# generalised inverse of K
Kinv &lt;- ginv(K)
# covariate x
x &lt;- runif(1)
Z &lt;- matrix(DesignM(x)$Z_B,nrow=1)
theta &lt;- get_theta_ga(alpha = 0.01, method = "integrate", Z = Z, 
                            c = 3, eps = .Machine$double.eps, Kinv = Kinv)$root

## Not run: 

set.seed(91179)
library(BayesX)
library(MASS)
# prior precision matrix to zambia data set
K &lt;- read.gra(system.file("examples/zambia.gra", package="sdPrior"))
# generalised inverse of K
Kinv &lt;- ginv(K)

# read data
dat &lt;- read.table(system.file("examples/zambia_height92.raw", package="sdPrior"), header = TRUE)

# design matrix for spatial component
Z &lt;- t(sapply(dat$district, FUN=function(x){1*(x==rownames(K))}))

# get scale parameter
theta &lt;- get_theta_ga(alpha = 0.01, method = "integrate", Z = Z, 
                            c = 3, eps = .Machine$double.eps, Kinv = Kinv)$root

## End(Not run) 

</code></pre>

<hr>
<h2 id='get_theta_gbp'>Find Scale Parameter for Generalised Beta Prime (Half-Cauchy) Hyperprior</h2><span id='topic+get_theta_gbp'></span>

<h3>Description</h3>

<p>This function implements a optimisation routine that computes the scale parameter <code class="reqn">\theta</code>
of the gamma prior for <code class="reqn">\tau^2</code> (corresponding to a half cauchy for <code class="reqn">\tau</code>) 
for a given design matrix and prior precision matrix
such that approximately <code class="reqn">P(|f(x_{k}|\le c,k=1,\ldots,p)\ge 1-\alpha</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_theta_gbp(alpha = 0.01, method = "integrate", Z, c = 3,
  eps = .Machine$double.eps, Kinv)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_theta_gbp_+3A_alpha">alpha</code></td>
<td>
<p>denotes the 1-<code class="reqn">\alpha</code> level.</p>
</td></tr>
<tr><td><code id="get_theta_gbp_+3A_method">method</code></td>
<td>
<p>with <code>integrate</code> as default.
Currently no further method implemented.</p>
</td></tr>
<tr><td><code id="get_theta_gbp_+3A_z">Z</code></td>
<td>
<p>the design matrix.</p>
</td></tr>
<tr><td><code id="get_theta_gbp_+3A_c">c</code></td>
<td>
<p>denotes the expected range of the function.</p>
</td></tr>
<tr><td><code id="get_theta_gbp_+3A_eps">eps</code></td>
<td>
<p>denotes the error tolerance of the result, default is <code>.Machine$double.eps</code>.</p>
</td></tr>
<tr><td><code id="get_theta_gbp_+3A_kinv">Kinv</code></td>
<td>
<p>the generalised inverse of K.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code>list</code> with values from <code><a href="stats.html#topic+uniroot">uniroot</a></code>.
</p>


<h3>Author(s)</h3>

<p>Nadja Klein
</p>


<h3>References</h3>

<p>Nadja Klein and Thomas Kneib (2015). Scale-Dependent Priors for Variance Parameters in Structured Additive Distributional Regression. 
<em>Working Paper</em>.
</p>
<p>Andrew Gelman (2006). Prior Distributions for Variance Parameters in Hierarchical Models. 
<em>Bayesian Analysis</em>, <b>1</b>(3), 515&ndash;533.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)
require(MASS)
# prior precision matrix (second order differences) 
# of a spline of degree l=3 and with m=20 inner knots
# yielding dim(K)=m+l-1=22
K &lt;- t(diff(diag(22), differences=2))%*%diff(diag(22), differences=2)
# generalised inverse of K
Kinv &lt;- ginv(K)
# covariate x
x &lt;- runif(1)
Z &lt;- matrix(DesignM(x)$Z_B,nrow=1)
theta &lt;- get_theta_gbp(alpha = 0.01, method = "integrate", Z = Z, 
                            c = 3, eps = .Machine$double.eps, Kinv = Kinv)$root

## Not run: 

set.seed(91179)
library(BayesX)
library(MASS)
# prior precision matrix to zambia data set
K &lt;- read.gra(system.file("examples/zambia.gra", package="sdPrior"))
# generalised inverse of K
Kinv &lt;- ginv(K)

# read data
dat &lt;- read.table(system.file("examples/zambia_height92.raw", package="sdPrior"), header = TRUE)

# design matrix for spatial component
Z &lt;- t(sapply(dat$district, FUN=function(x){1*(x==rownames(K))}))

# get scale parameter
theta &lt;- get_theta_gbp(alpha = 0.01, method = "integrate", Z = Z, 
                            c = 3, eps = .Machine$double.eps, Kinv = Kinv)$root

## End(Not run) 

</code></pre>

<hr>
<h2 id='get_theta_ig'>Find Scale Parameter for Inverse Gamma Hyperprior</h2><span id='topic+get_theta_ig'></span>

<h3>Description</h3>

<p>This function implements a optimisation routine that computes the scale parameter <code>b</code>
of the inverse gamma prior for <code class="reqn">\tau^2</code> when <code class="reqn">a=b=\epsilon</code> with <code class="reqn">\epsilon</code> small
for a given design matrix and prior precision matrix
such that approximately <code class="reqn">P(|f(x_{k}|\le c,k=1,\ldots,p)\ge 1-\alpha</code>
When <code>a</code> unequal to <code>a</code> the shape parameter <code>a</code> has to be specified.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_theta_ig(alpha = 0.01, method = "integrate", Z, c = 3,
  eps = .Machine$double.eps, Kinv, equals = FALSE, a = 1,
  type = "marginalt")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_theta_ig_+3A_alpha">alpha</code></td>
<td>
<p>denotes the 1-<code class="reqn">\alpha</code> level.</p>
</td></tr>
<tr><td><code id="get_theta_ig_+3A_method">method</code></td>
<td>
<p>with <code>integrate</code> as default.
Currently no further method implemented.</p>
</td></tr>
<tr><td><code id="get_theta_ig_+3A_z">Z</code></td>
<td>
<p>the design matrix.</p>
</td></tr>
<tr><td><code id="get_theta_ig_+3A_c">c</code></td>
<td>
<p>denotes the expected range of the function.</p>
</td></tr>
<tr><td><code id="get_theta_ig_+3A_eps">eps</code></td>
<td>
<p>denotes the error tolerance of the result, default is <code>.Machine$double.eps</code>.</p>
</td></tr>
<tr><td><code id="get_theta_ig_+3A_kinv">Kinv</code></td>
<td>
<p>the generalised inverse of K.</p>
</td></tr>
<tr><td><code id="get_theta_ig_+3A_equals">equals</code></td>
<td>
<p>saying whether <code>a</code>=<code>b</code>. The default is FALSE due to the fact that a is a shape parameter.</p>
</td></tr>
<tr><td><code id="get_theta_ig_+3A_a">a</code></td>
<td>
<p>is the shape parameter of the inverse gamma distribution, default is 1.</p>
</td></tr>
<tr><td><code id="get_theta_ig_+3A_type">type</code></td>
<td>
<p>is either numerical integration (<code>integrate</code>) of to obtain the marginal distribution of <code class="reqn">z_p'\beta</code>
or the theoretical marginal t-distribution (<code>marginalt</code>). <code>marginalt</code> is the default value.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Currently, the implementation only works properly for the cases <code>a</code> unequal <code>b</code>.
</p>


<h3>Value</h3>

<p>an object of class <code>list</code> with values from <code><a href="stats.html#topic+uniroot">uniroot</a></code>.
</p>


<h3>Author(s)</h3>

<p>Nadja Klein
</p>


<h3>References</h3>

<p>Nadja Klein and Thomas Kneib (2015). Scale-Dependent Priors for Variance Parameters in Structured Additive Distributional Regression. 
<em>Working Paper</em>.
</p>
<p>Stefan Lang and Andreas Brezger (2004). Bayesian P-Splines. 
<em>Journal of Computational and Graphical Statistics</em>, <b>13</b>, 183-212.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)
library(MASS)
# prior precision matrix (second order differences) 
# of a spline of degree l=3 and with m=20 inner knots
# yielding dim(K)=m+l-1=22
K &lt;- t(diff(diag(22), differences=2))%*%diff(diag(22), differences=2)
# generalised inverse of K
Kinv &lt;- ginv(K)
# covariate x
x &lt;- runif(1)
Z &lt;- matrix(DesignM(x)$Z_B,nrow=1)
theta &lt;- get_theta_ig(alpha = 0.01, method = "integrate", Z = Z, 
                      c = 3, eps = .Machine$double.eps, Kinv = Kinv, 
					 equals = FALSE, a = 1, type="marginalt")$root

</code></pre>

<hr>
<h2 id='get_theta_linear'>Find Scale Parameter for Inverse Gamma Hyperprior of Linear Effects with Spike and Slab Prior</h2><span id='topic+get_theta_linear'></span>

<h3>Description</h3>

<p>This function implements a optimisation routine that computes the scale parameter <code class="reqn">v_2</code> and selection parameter
<code class="reqn">r</code> of the inverse gamma prior IG(<code class="reqn">v_1</code>,<code class="reqn">v_2</code>) for <code class="reqn">\tau^2</code> when <code class="reqn">\tau^2\sim N(0,r(\delta)\tau^2)</code> 
and given shape paramter 
such that approximately <code class="reqn">P(\beta\le c_2|spike)\ge 1-\alpha_2</code> and <code class="reqn">P(\beta\ge c_1|slab)\ge 1-\alpha1</code>.<br />
<code class="reqn">\alpha_1</code> and <code class="reqn">\alpha_2</code> should not be smaller than 0.1 due to numerical sensitivity and possible instability. Better change <code class="reqn">c_1</code>, <code class="reqn">c_2</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_theta_linear(alpha1 = 0.1, alpha2 = 0.1, c1 = 0.1, c2 = 0.1,
  eps = .Machine$double.eps, v1 = 5)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_theta_linear_+3A_alpha1">alpha1</code></td>
<td>
<p>denotes the 1-<code class="reqn">\alpha_1</code> level for <code class="reqn">v_2</code>.</p>
</td></tr>
<tr><td><code id="get_theta_linear_+3A_alpha2">alpha2</code></td>
<td>
<p>denotes the 1-<code class="reqn">\alpha_2</code> level for <code class="reqn">r</code>.</p>
</td></tr>
<tr><td><code id="get_theta_linear_+3A_c1">c1</code></td>
<td>
<p>denotes the expected range of the linear effect in the slab part.</p>
</td></tr>
<tr><td><code id="get_theta_linear_+3A_c2">c2</code></td>
<td>
<p>denotes the expected range of the linear effect in the spike part.</p>
</td></tr>
<tr><td><code id="get_theta_linear_+3A_eps">eps</code></td>
<td>
<p>denotes the error tolerance of the result, default is <code>.Machine$double.eps</code>.</p>
</td></tr>
<tr><td><code id="get_theta_linear_+3A_v1">v1</code></td>
<td>
<p>is the shape parameter of the inverse gamma distribution, default is 5.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code>list</code> with values from <code><a href="stats.html#topic+uniroot">uniroot</a></code>.
</p>


<h3>Warning</h3>

<p><code class="reqn">\alpha_1</code> and <code class="reqn">\alpha_2</code> should not be smaller than 0.1 due to numerical sensitivity and possible instability. Better change <code class="reqn">c_1</code>, <code class="reqn">c_2</code>.
</p>


<h3>Author(s)</h3>

<p>Nadja Klein
</p>


<h3>References</h3>

<p>Nadja Klein, Thomas Kneib, Stefan Lang and Helga Wagner (2016). Automatic Effect Selection in Distributional Regression via Spike and Slab Priors. 
<em>Working Paper</em>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)
result &lt;- get_theta_linear()
r &lt;- result$r
v2 &lt;- result$v2

get_theta_linear(alpha1=0.1,alpha2=0.1,c1=0.5,c2=0.1,v1=5) 

</code></pre>

<hr>
<h2 id='hyperpar'>Find Scale Parameters for Inverse Gamma Hyperprior of Nonlinear Effects with Spike and Slab Prior (Simulation-based)</h2><span id='topic+hyperpar'></span>

<h3>Description</h3>

<p>This function implements a optimisation routine that computes the scale parameter <code class="reqn">b</code> and selection parameter
<code class="reqn">r</code>. . Here, we assume an inverse gamma prior IG(<code class="reqn">a</code>,<code class="reqn">b</code>) for <code class="reqn">\psi^2</code> and <code class="reqn">\tau^2\sim N(0,r(\delta)\psi^2)</code> 
and given shape paramter <code class="reqn">a</code>,
such that approximately <code class="reqn">P(f(x)\le c|spike,\forall x\in D)\ge 1-\alpha1</code> and <code class="reqn">P(\exists x\in D s.t. f(x)\ge c|slab)\ge 1-\alpha2</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hyperpar(Z, Kinv, a = 5, c = 0.1, alpha1 = 0.1, alpha2 = 0.1,
  R = 10000, myseed = 123)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hyperpar_+3A_z">Z</code></td>
<td>
<p>the row of the design matrix (or the complete matrix of several observations) evaluated at.</p>
</td></tr>
<tr><td><code id="hyperpar_+3A_kinv">Kinv</code></td>
<td>
<p>the generalised inverse of <code class="reqn">K</code>.</p>
</td></tr>
<tr><td><code id="hyperpar_+3A_a">a</code></td>
<td>
<p>is the shape parameter of the inverse gamma distribution, default is 5.</p>
</td></tr>
<tr><td><code id="hyperpar_+3A_c">c</code></td>
<td>
<p>denotes the expected range of eqnf .</p>
</td></tr>
<tr><td><code id="hyperpar_+3A_alpha1">alpha1</code></td>
<td>
<p>denotes the 1-<code class="reqn">\alpha1</code> level for <code class="reqn">b</code>.</p>
</td></tr>
<tr><td><code id="hyperpar_+3A_alpha2">alpha2</code></td>
<td>
<p>denotes the 1-<code class="reqn">\alpha2</code> level for <code class="reqn">r</code>.</p>
</td></tr>
<tr><td><code id="hyperpar_+3A_r">R</code></td>
<td>
<p>denotes the number of replicates drawn during simulation.</p>
</td></tr>
<tr><td><code id="hyperpar_+3A_myseed">myseed</code></td>
<td>
<p>denotes the required seed for the simulation based method.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code>list</code> with root values <code class="reqn">r</code>, <code class="reqn">b</code> from <code><a href="stats.html#topic+uniroot">uniroot</a></code>.
</p>


<h3>Author(s)</h3>

<p>Nadja Klein
</p>


<h3>References</h3>

<p>Nadja Klein, Thomas Kneib, Stefan Lang and Helga Wagner (2016). Spike and Slab Priors for Effect Selection in Distributional Regression. 
<em>Working Paper</em>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)
library(MASS)
# prior precision matrix (second order differences) 
# of a spline of degree l=3 and with m=22 inner knots
# yielding dim(K)=m+l-1=22
K &lt;- t(diff(diag(22), differences=2))%*%diff(diag(22), differences=2)
# generalised inverse of K (same as if we used mixed model representation!)
Kinv &lt;- ginv(K)
# covariate x
x &lt;- runif(1)
Z &lt;- matrix(DesignM(x)$Z_B,nrow=1)
fgrid &lt;- seq(-3,3,length=1000)
mdf &lt;- hyperpar(Z,Kinv,a=5,c=0.1,alpha1=0.05,alpha2=0.05,R=10000,myseed=123)

</code></pre>

<hr>
<h2 id='hyperpar_mod'>Find Scale Parameter for modular regression</h2><span id='topic+hyperpar_mod'></span>

<h3>Description</h3>

<p>Find Scale Parameter for modular regression
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hyperpar_mod(Z, K1, K2, A, c = 0.1, alpha = 0.1, omegaseq, omegaprob,
  R = 10000, myseed = 123, thetaseq = NULL, type = "IG",
  lowrank = FALSE, k = 5, mc = FALSE, ncores = 1, truncate = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hyperpar_mod_+3A_z">Z</code></td>
<td>
<p>rows from the tensor product design matrix</p>
</td></tr>
<tr><td><code id="hyperpar_mod_+3A_k1">K1</code></td>
<td>
<p>precision matrix1</p>
</td></tr>
<tr><td><code id="hyperpar_mod_+3A_k2">K2</code></td>
<td>
<p>precision matrix2</p>
</td></tr>
<tr><td><code id="hyperpar_mod_+3A_a">A</code></td>
<td>
<p>constraint matrix</p>
</td></tr>
<tr><td><code id="hyperpar_mod_+3A_c">c</code></td>
<td>
<p>threshold from eq. (8) in Klein &amp; Kneib (2016)</p>
</td></tr>
<tr><td><code id="hyperpar_mod_+3A_alpha">alpha</code></td>
<td>
<p>probability parameter from eq. (8) in Klein &amp; Kneib (2016)</p>
</td></tr>
<tr><td><code id="hyperpar_mod_+3A_omegaseq">omegaseq</code></td>
<td>
<p>sequence of weights for the anisotropy</p>
</td></tr>
<tr><td><code id="hyperpar_mod_+3A_omegaprob">omegaprob</code></td>
<td>
<p>prior probabilities for the weights</p>
</td></tr>
<tr><td><code id="hyperpar_mod_+3A_r">R</code></td>
<td>
<p>number of simulations</p>
</td></tr>
<tr><td><code id="hyperpar_mod_+3A_myseed">myseed</code></td>
<td>
<p>seed in case of simulation. default is 123.</p>
</td></tr>
<tr><td><code id="hyperpar_mod_+3A_thetaseq">thetaseq</code></td>
<td>
<p>possible sequence of thetas. default is NULL.</p>
</td></tr>
<tr><td><code id="hyperpar_mod_+3A_type">type</code></td>
<td>
<p>type of hyperprior for tau/tau^2; options: IG =&gt; IG(1,theta) for tau^2, SD =&gt; WE(0.5,theta) for tau^2, HN =&gt; HN(0,theta) for tau, U =&gt; U(0,theta) for tau, HC =&gt; HC(0,theta) for tau</p>
</td></tr>
<tr><td><code id="hyperpar_mod_+3A_lowrank">lowrank</code></td>
<td>
<p>default is FALSE. If TRUE a low rank approximation is used for Z with k columns.</p>
</td></tr>
<tr><td><code id="hyperpar_mod_+3A_k">k</code></td>
<td>
<p>only used if lowrank=TRUE. specifies target rank of low rank approximation. Default is 5.</p>
</td></tr>
<tr><td><code id="hyperpar_mod_+3A_mc">mc</code></td>
<td>
<p>default is FALSE. only works im thetaseq is supplied. can parallel across thetaseq.</p>
</td></tr>
<tr><td><code id="hyperpar_mod_+3A_ncores">ncores</code></td>
<td>
<p>default is 1. number of cores is mc=TRUE</p>
</td></tr>
<tr><td><code id="hyperpar_mod_+3A_truncate">truncate</code></td>
<td>
<p>default is 1. If &lt; 1 the lowrank approximation is based on on cumsum(values)/sum(values).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the optimal value for theta
</p>


<h3>Author(s)</h3>

<p>Nadja Klein
</p>


<h3>References</h3>

<p>Kneib, T., Klein, N., Lang, S. and Umlauf, N. (2017) Modular Regression - A Lego System for Building Structured Additive Distributional Regression Models with Tensor Product Interactions 
<em>Working Paper</em>.
</p>

<hr>
<h2 id='hyperparlin'>Find Scale Parameter for Inverse Gamma Hyperprior of Linear Effects with Spike and Slab Prior</h2><span id='topic+hyperparlin'></span>

<h3>Description</h3>

<p>This function implements a optimisation routine that computes the scale parameter <code class="reqn">b</code> and selection parameter
<code class="reqn">r</code>. Here, we assume an inverse gamma prior IG(<code class="reqn">a</code>,<code class="reqn">b</code>) for <code class="reqn">\tau^2</code> and <code class="reqn">\beta|\delta,\tau^2\sim N(0,r(\delta)\tau^2)</code>. 
For given shape paramter <code class="reqn">a</code> the user gets <code class="reqn">b</code>, <code class="reqn">r</code>
such that approximately <code class="reqn">P(\beta\le c2|spike)\ge 1-\alpha2</code> and <code class="reqn">P(\beta\ge c1|slab)\ge 1-\alpha1</code> hold.<br />
Note that if you observe numerical instabilities try not to specify <code class="reqn">\alpha1</code> and <code class="reqn">\alpha2</code> smaller than 0.1.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hyperparlin(alpha1 = 0.1, alpha2 = 0.1, c1 = 0.1, c2 = 0.1,
  eps = .Machine$double.eps, a = 5)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hyperparlin_+3A_alpha1">alpha1</code></td>
<td>
<p>denotes the 1-<code class="reqn">\alpha1</code> level for <code class="reqn">b</code>.</p>
</td></tr>
<tr><td><code id="hyperparlin_+3A_alpha2">alpha2</code></td>
<td>
<p>denotes the 1-<code class="reqn">\alpha2</code> level for <code class="reqn">r</code>.</p>
</td></tr>
<tr><td><code id="hyperparlin_+3A_c1">c1</code></td>
<td>
<p>denotes the expected range of the linear effect in the slab part.</p>
</td></tr>
<tr><td><code id="hyperparlin_+3A_c2">c2</code></td>
<td>
<p>denotes the expected range of the linear effect in the spike part.</p>
</td></tr>
<tr><td><code id="hyperparlin_+3A_eps">eps</code></td>
<td>
<p>denotes the error tolerance of the result, default is <code>.Machine$double.eps</code>.</p>
</td></tr>
<tr><td><code id="hyperparlin_+3A_a">a</code></td>
<td>
<p>is the shape parameter of the inverse gamma distribution, default is 5.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code>list</code> with root values <code class="reqn">r</code>, <code class="reqn">b</code> from <code><a href="stats.html#topic+uniroot">uniroot</a></code>.
</p>


<h3>Warning</h3>

<p><code class="reqn">\alpha1</code> and <code class="reqn">\alpha2</code> should not be smaller than 0.1 due to numerical sensitivity and possible instability. Better change <code class="reqn">c1</code>, <code class="reqn">c2</code>.
</p>


<h3>Author(s)</h3>

<p>Nadja Klein
</p>


<h3>References</h3>

<p>Nadja Klein, Thomas Kneib, Stefan Lang and Helga Wagner (2016). Automatic Effect Selection in Distributional Regression via Spike and Slab Priors. 
<em>Working Paper</em>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)
result &lt;- hyperparlin()
r &lt;- result$r
b &lt;- result$b

hyperparlin(alpha1=0.1,alpha2=0.1,c1=0.5,c2=0.1,a=5) 

</code></pre>

<hr>
<h2 id='mdbeta'>Marginal Density of <code class="reqn">\beta</code></h2><span id='topic+mdbeta'></span>

<h3>Description</h3>

<p>This function computes the marginal density of <code class="reqn">\beta</code> and for <code class="reqn">\beta</code> on an equidistant grid specified by the user.
Currently only implemented for <code class="reqn">dim(\beta)=1,2</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mdbeta(D = 1, rangebeta, ngridbeta, a = 5, b = 25, r = 0.00025,
  a0 = 0.5, b0 = 0.5, plot = FALSE, log = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mdbeta_+3A_d">D</code></td>
<td>
<p>dimension of <code class="reqn">\beta</code>.</p>
</td></tr>
<tr><td><code id="mdbeta_+3A_rangebeta">rangebeta</code></td>
<td>
<p>a vector containing the start and ending point of <code class="reqn">\beta</code> to be computed for.</p>
</td></tr>
<tr><td><code id="mdbeta_+3A_ngridbeta">ngridbeta</code></td>
<td>
<p>the number of grid values.</p>
</td></tr>
<tr><td><code id="mdbeta_+3A_a">a</code></td>
<td>
<p>shape parameter of inverse gamma prior of <code class="reqn">\psi^2</code>.</p>
</td></tr>
<tr><td><code id="mdbeta_+3A_b">b</code></td>
<td>
<p>scale parameter of inverse gamma prior of <code class="reqn">\psi^2</code>.</p>
</td></tr>
<tr><td><code id="mdbeta_+3A_r">r</code></td>
<td>
<p>the scaling parameter <code class="reqn">r(\delta=1)</code> in the variance <code class="reqn">r(\delta)\psi^2</code> of prior of <code class="reqn">\tau^2</code>.</p>
</td></tr>
<tr><td><code id="mdbeta_+3A_a0">a0</code></td>
<td>
<p>shape parameter of beta prior of <code class="reqn">\omega</code>.</p>
</td></tr>
<tr><td><code id="mdbeta_+3A_b0">b0</code></td>
<td>
<p>scale parameter of beta prior of <code class="reqn">\omega</code>.</p>
</td></tr>
<tr><td><code id="mdbeta_+3A_plot">plot</code></td>
<td>
<p>logical value (default is <code>FALSE</code>). If <code>TRUE</code>, a plot is also returned as the function <code>pl()</code>.</p>
</td></tr>
<tr><td><code id="mdbeta_+3A_log">log</code></td>
<td>
<p>logical value (default is <code>FALSE</code>). If <code>TRUE</code>, <code class="reqn">log(p(\beta))</code> is also returned in <code>logval</code>.
as well as, if necessary, a plot function <code>logpl()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the marginal density, the sequence of <code class="reqn">\beta</code> and depending on specified <code>plot</code>, <code>log</code> arguments also the log-density and plot functions.
</p>


<h3>Author(s)</h3>

<p>Nadja Klein
</p>


<h3>References</h3>

<p>Nadja Klein, Thomas Kneib, Stefan Lang and Helga Wagner (2016). Spike and Slab Priors for Effect Selection in Distributional Regression. 
<em>Working Paper</em>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)
#1-dimensional example
D = 1
ngridbeta = 1000
rangebeta = c(0.000001,1)
a0 = b0 = 0.5
a = 5
b = 50
r = 0.005
mdf &lt;- mdbeta(D=1,rangebeta,ngridbeta,a=a,b=b,r=r,a0=a0,b0=b0) 

#2-dimensional example
D = 2
ngridbeta = 100
rangebeta = c(0.000001,8)
a0 = b0 = 0.5
a = 5
b = 50
r = 0.005
mdf &lt;- mdbeta(D=2,rangebeta,ngridbeta,a=a,b=b,r=r,a0=a0,b0=b0,plot=TRUE,log=TRUE) 
mdf$logpl()

</code></pre>

<hr>
<h2 id='mdf_aunif'>Marginal Density for Given Scale Parameter and Approximated Uniform Prior for <code class="reqn">\tau</code></h2><span id='topic+mdf_aunif'></span>

<h3>Description</h3>

<p>This function computes the marginal density of <code class="reqn">z_p'\beta</code> for approximated uniform hyperprior 
for <code class="reqn">\tau</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mdf_aunif(f, theta, Z, Kinv)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mdf_aunif_+3A_f">f</code></td>
<td>
<p>point the marginal density to be evaluated at.</p>
</td></tr>
<tr><td><code id="mdf_aunif_+3A_theta">theta</code></td>
<td>
<p>denotes the scale parameter of the approximated uniform hyperprior for <code class="reqn">\tau</code>.</p>
</td></tr>
<tr><td><code id="mdf_aunif_+3A_z">Z</code></td>
<td>
<p>the row of the design matrix evaluated.</p>
</td></tr>
<tr><td><code id="mdf_aunif_+3A_kinv">Kinv</code></td>
<td>
<p>the generalised inverse of K.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the marginal density evaluated at point x.
</p>


<h3>Author(s)</h3>

<p>Nadja Klein
</p>


<h3>References</h3>

<p>Nadja Klein and Thomas Kneib (2015). Scale-Dependent Priors for Variance Parameters in Structured Additive Distributional Regression. 
<em>Working Paper</em>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)
library(MASS)
# prior precision matrix (second order differences) 
# of a spline of degree l=3 and with m=20 inner knots
# yielding dim(K)=m+l-1=22
K &lt;- t(diff(diag(22), differences=2))%*%diff(diag(22), differences=2)
# generalised inverse of K
Kinv &lt;- ginv(K)
# covariate x
x &lt;- runif(1)
Z &lt;- matrix(DesignM(x)$Z_B,nrow=1)
fgrid &lt;- seq(-3,3,length=1000)
mdf &lt;- mdf_aunif(fgrid,theta=0.0028,Z=Z,Kinv=Kinv)

</code></pre>

<hr>
<h2 id='mdf_ga'>Marginal Density for Given Scale Parameter and Half-Normal Prior for <code class="reqn">\tau</code></h2><span id='topic+mdf_ga'></span>

<h3>Description</h3>

<p>This function computes the marginal density of <code class="reqn">z_p'\beta</code> for gamma priors for <code class="reqn">\tau^2</code>
(referring to a half-normal prior for <code class="reqn">\tau</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mdf_ga(f, theta, Z, Kinv)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mdf_ga_+3A_f">f</code></td>
<td>
<p>point the marginal density to be evaluated at.</p>
</td></tr>
<tr><td><code id="mdf_ga_+3A_theta">theta</code></td>
<td>
<p>denotes the scale parameter of the gamma hyperprior for <code class="reqn">\tau^2</code> (half-normal for <code class="reqn">\tau</code>).</p>
</td></tr>
<tr><td><code id="mdf_ga_+3A_z">Z</code></td>
<td>
<p>the row of the design matrix evaluated.</p>
</td></tr>
<tr><td><code id="mdf_ga_+3A_kinv">Kinv</code></td>
<td>
<p>the generalised inverse of K.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the marginal density evaluated at point x.
</p>


<h3>Author(s)</h3>

<p>Nadja Klein
</p>


<h3>References</h3>

<p>Nadja Klein and Thomas Kneib (2015). Scale-Dependent Priors for Variance Parameters in Structured Additive Distributional Regression. 
<em>Working Paper</em>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)
library(MASS)
# prior precision matrix (second order differences) 
# of a spline of degree l=3 and with m=20 inner knots
# yielding dim(K)=m+l-1=22
K &lt;- t(diff(diag(22), differences=2))%*%diff(diag(22), differences=2)
# generalised inverse of K
Kinv &lt;- ginv(K)
# covariate x
x &lt;- runif(1)
Z &lt;- matrix(DesignM(x)$Z_B,nrow=1)
fgrid &lt;- seq(-3,3,length=1000)
mdf &lt;- mdf_ga(fgrid,theta=0.0028,Z=Z,Kinv=Kinv)

</code></pre>

<hr>
<h2 id='mdf_gbp'>Marginal Density for Given Scale Parameter and Half-Cauchy Prior for <code class="reqn">\tau</code></h2><span id='topic+mdf_gbp'></span>

<h3>Description</h3>

<p>This function computes the marginal density of <code class="reqn">z_p'\beta</code> for generalised beta prior hyperprior 
for <code class="reqn">\tau^2</code> (half-Chauchy for <code class="reqn">\tau</code>)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mdf_gbp(f, theta, Z, Kinv)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mdf_gbp_+3A_f">f</code></td>
<td>
<p>point the marginal density to be evaluated at.</p>
</td></tr>
<tr><td><code id="mdf_gbp_+3A_theta">theta</code></td>
<td>
<p>denotes the scale parameter of the generalised beta prior hyperprior for <code class="reqn">\tau^2</code> (half-Chauchy for <code class="reqn">\tau</code>).</p>
</td></tr>
<tr><td><code id="mdf_gbp_+3A_z">Z</code></td>
<td>
<p>the row of the design matrix evaluated.</p>
</td></tr>
<tr><td><code id="mdf_gbp_+3A_kinv">Kinv</code></td>
<td>
<p>the generalised inverse of K.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the marginal density evaluated at point x.
</p>


<h3>Author(s)</h3>

<p>Nadja Klein
</p>


<h3>References</h3>

<p>Nadja Klein and Thomas Kneib (2015). Scale-Dependent Priors for Variance Parameters in Structured Additive Distributional Regression. 
<em>Working Paper</em>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)
library(MASS)
# prior precision matrix (second order differences) 
# of a spline of degree l=3 and with m=20 inner knots
# yielding dim(K)=m+l-1=22
K &lt;- t(diff(diag(22), differences=2))%*%diff(diag(22), differences=2)
# generalised inverse of K
Kinv &lt;- ginv(K)
# covariate x
x &lt;- runif(1)
Z &lt;- matrix(DesignM(x)$Z_B,nrow=1)
fgrid &lt;- seq(-3,3,length=1000)
mdf &lt;- mdf_gbp(fgrid,theta=0.0028,Z=Z,Kinv=Kinv)

</code></pre>

<hr>
<h2 id='mdf_ig'>Marginal Density for Given Scale Parameter and Inverse Gamma Prior for <code class="reqn">\tau^2</code></h2><span id='topic+mdf_ig'></span>

<h3>Description</h3>

<p>This function computes the marginal density of <code class="reqn">z_p'\beta</code> for inverse gamma
hyperpriors with shape parameter a=1.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mdf_ig(f, theta, Z, Kinv)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mdf_ig_+3A_f">f</code></td>
<td>
<p>point the marginal density to be evaluated at.</p>
</td></tr>
<tr><td><code id="mdf_ig_+3A_theta">theta</code></td>
<td>
<p>denotes the scale parameter of the inverse gamma hyperprior.</p>
</td></tr>
<tr><td><code id="mdf_ig_+3A_z">Z</code></td>
<td>
<p>the row of the design matrix evaluated.</p>
</td></tr>
<tr><td><code id="mdf_ig_+3A_kinv">Kinv</code></td>
<td>
<p>the generalised inverse of K.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the marginal density evaluated at point x.
</p>


<h3>Author(s)</h3>

<p>Nadja Klein
</p>


<h3>References</h3>

<p>Nadja Klein and Thomas Kneib (2015). Scale-Dependent Priors for Variance Parameters in Structured Additive Distributional Regression. 
<em>Working Paper</em>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)
library(MASS)
# prior precision matrix (second order differences) 
# of a spline of degree l=3 and with m=20 inner knots
# yielding dim(K)=m+l-1=22
K &lt;- t(diff(diag(22), differences=2))%*%diff(diag(22), differences=2)
# generalised inverse of K
Kinv &lt;- ginv(K)
# covariate x
x &lt;- runif(1)
Z &lt;- matrix(DesignM(x)$Z_B,nrow=1)
fgrid &lt;- seq(-3,3,length=1000)
mdf &lt;- mdf_ig(fgrid,theta=0.0028,Z=Z,Kinv=Kinv)

</code></pre>

<hr>
<h2 id='mdf_sd'>Marginal Density for Given Scale Parameter and Scale-Dependent Prior for <code class="reqn">\tau^2</code></h2><span id='topic+mdf_sd'></span>

<h3>Description</h3>

<p>This function computes the marginal density of <code class="reqn">z_p'\beta</code> for scale-dependent priors for <code class="reqn">\tau^2</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mdf_sd(f, theta, Z, Kinv)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mdf_sd_+3A_f">f</code></td>
<td>
<p>point the marginal density to be evaluated at.</p>
</td></tr>
<tr><td><code id="mdf_sd_+3A_theta">theta</code></td>
<td>
<p>denotes the scale parameter of the scale-dependent hyperprior for <code class="reqn">\tau^2</code>.</p>
</td></tr>
<tr><td><code id="mdf_sd_+3A_z">Z</code></td>
<td>
<p>the row of the design matrix evaluated.</p>
</td></tr>
<tr><td><code id="mdf_sd_+3A_kinv">Kinv</code></td>
<td>
<p>the generalised inverse of K.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the marginal density evaluated at point x.
</p>


<h3>Author(s)</h3>

<p>Nadja Klein
</p>


<h3>References</h3>

<p>Nadja Klein and Thomas Kneib (2015). Scale-Dependent Priors for Variance Parameters in Structured Additive Distributional Regression. 
<em>Working Paper</em>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)
library(MASS)
# prior precision matrix (second order differences) 
# of a spline of degree l=3 and with m=20 inner knots
# yielding dim(K)=m+l-1=22
K &lt;- t(diff(diag(22), differences=2))%*%diff(diag(22), differences=2)
# generalised inverse of K
Kinv &lt;- ginv(K)
# covariate x
x &lt;- runif(1)
Z &lt;- matrix(DesignM(x)$Z_B,nrow=1)
fgrid &lt;- seq(-3,3,length=1000)
mdf &lt;- mdf_sd(fgrid,theta=0.0028,Z=Z,Kinv=Kinv)

</code></pre>

<hr>
<h2 id='papprox_unif'>Compute Cumulative Distribution Function of Approximated (Differentiably) Uniform Distribution.</h2><span id='topic+papprox_unif'></span>

<h3>Description</h3>

<p>Compute Cumulative Distribution Function of Approximated (Differentiably) Uniform Distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>papprox_unif(x, scale, tildec = 13.86294)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="papprox_unif_+3A_x">x</code></td>
<td>
<p>denotes the argument of cumulative distribution function</p>
</td></tr>
<tr><td><code id="papprox_unif_+3A_scale">scale</code></td>
<td>
<p>the scale parameter originally defining the upper bound of the uniform distribution.</p>
</td></tr>
<tr><td><code id="papprox_unif_+3A_tildec">tildec</code></td>
<td>
<p>denotes the ratio between scale parameter <code class="reqn">\theta</code> and <code class="reqn">s</code>. The latter is responsible for the closeness of
the approximation to the uniform distribution. See also below for further details and the default value.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The cumulative distribution function of <code><a href="#topic+dapprox_unif">dapprox_unif</a></code> is given by
</p>
<p style="text-align: center;"><code class="reqn">(1/(log(1+exp(-\tilde{c}))+\tilde{c}))*(\tilde{c}*(\tau^2)^(1/2)/\theta-log(exp((\tau^2)^(1/2)*\tilde{c}/\theta)+exp(\tilde{c})))</code>
</p>

<p><code class="reqn">\tilde{c}</code> is chosen such that <code class="reqn">P(\tau^2&lt;=\theta)&gt;=0.95</code>.
</p>


<h3>Value</h3>

<p>the cumulative distribution function.
</p>


<h3>Author(s)</h3>

<p>Nadja Klein
</p>


<h3>References</h3>

<p>Nadja Klein and Thomas Kneib (2015). Scale-Dependent Priors for Variance Parameters in Structured Additive Distributional Regression. 
<em>Working Paper</em>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rapprox_unif">rapprox_unif</a></code>,<code><a href="#topic+dapprox_unif">dapprox_unif</a></code>
</p>

<hr>
<h2 id='rapprox_unif'>Draw Random Numbers from Approximated (Differentiably) Uniform Distribution.</h2><span id='topic+rapprox_unif'></span>

<h3>Description</h3>

<p>Draw Random Numbers from Approximated (Differentiably) Uniform Distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rapprox_unif(n = 100, scale, tildec = 13.86294, seed = 123)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rapprox_unif_+3A_n">n</code></td>
<td>
<p>number of draws.</p>
</td></tr>
<tr><td><code id="rapprox_unif_+3A_scale">scale</code></td>
<td>
<p>the scale parameter originally defining the upper bound of the uniform distribution.</p>
</td></tr>
<tr><td><code id="rapprox_unif_+3A_tildec">tildec</code></td>
<td>
<p>denotes the ratio between scale parameter <code class="reqn">\theta</code> and <code class="reqn">s</code>. The latter is responsible for the closeness of
the approximation to the uniform distribution. See also below for further details and the default value.</p>
</td></tr>
<tr><td><code id="rapprox_unif_+3A_seed">seed</code></td>
<td>
<p>denotes the seed</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The method is based on the inversion method and the quantile function is computed numerically using <code><a href="stats.html#topic+uniroot">uniroot</a></code>.
</p>


<h3>Value</h3>

<p>n draws with density <code><a href="#topic+papprox_unif">papprox_unif</a></code>.
</p>


<h3>Author(s)</h3>

<p>Nadja Klein
</p>


<h3>References</h3>

<p>Nadja Klein and Thomas Kneib (2015). Scale-Dependent Priors for Variance Parameters in Structured Additive Distributional Regression. 
<em>Working Paper</em>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rapprox_unif">rapprox_unif</a></code>,<code><a href="#topic+papprox_unif">papprox_unif</a></code>
</p>

<hr>
<h2 id='zambia_graph'>Prior precision  matrix for spatial variable in Zambia data set</h2><span id='topic+zambia_graph'></span>

<h3>Description</h3>

<p>This is a 57x57 matrix containing row- and columwise the regions of Zambia, and the entries
define the neighbourhoodstructure. The corresponding map sambia.bnd can be downloaded from <a href="http://www.stat.uni-muenchen.de/~kneib/regressionsbuch/daten_e.html">http://www.stat.uni-muenchen.de/~kneib/regressionsbuch/daten_e.html</a>.
from the bnd file the prior precision matrix is obtained by
library(BayesX)
map &lt;- read.bnd(&quot;zambia.bnd&quot;)
K &lt;- bnd2gra(map)
</p>

<hr>
<h2 id='zambia_height92'>Malnutrition in Zambia</h2><span id='topic+zambia_height92'></span>

<h3>Description</h3>

<p>The primary goal of a statistical analysis is to determine the effect of certain socioeconomic
variables of the child, the mother, and the household on the child's nutritional
condition
</p>

<ul>
<li><p> zscore child's Z-score
</p>
</li>
<li><p> c _breastf duration of breastfeeding in months
</p>
</li>
<li><p> c_age child's age in months
</p>
</li>
<li><p> m_agebirth mother's age at birth in years
</p>
</li>
<li><p> m_height mother's height in centimeter
</p>
</li>
<li><p> m_bmi mother's body mass index
</p>
</li>
<li><p> m_education mother's level of education
</p>
</li>
<li><p> m_work mother's work status
</p>
</li>
<li><p> region region of residence in Zambia
</p>
</li>
<li><p> district district of residence in Zambia
</p>
</li></ul>



<h3>Format</h3>

<p>A data frame with 4421 rows and 21 variables</p>


<h3>Source</h3>

<p><a href="http://www.stat.uni-muenchen.de/~kneib/regressionsbuch/daten_e.html">http://www.stat.uni-muenchen.de/~kneib/regressionsbuch/daten_e.html</a>
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
