<!DOCTYPE html><html lang="en"><head><title>Help for package nlreg</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {nlreg}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#nlreg-package'>
<p>Higher Order Inference for Nonlinear Heteroscedastic Models</p></a></li>
<li><a href='#allProfiles'>
<p>Support for function &lsquo;profile.nlreg&rsquo; &mdash; Generic Function</p></a></li>
<li><a href='#allProfiles.nlreg'>
<p>Support for function &lsquo;profile.nlreg&rsquo;</p></a></li>
<li><a href='#C1'><p>Six Herbicide Data Sets</p></a></li>
<li><a href='#chlorsulfuron'><p>Chlorsulfuron Data</p></a></li>
<li><a href='#coef.nlreg'>
<p>Use coef() on a &lsquo;nlreg&rsquo; object</p></a></li>
<li><a href='#contour.all.nlreg.profiles'>
<p>Contour Method for &lsquo;nlreg&rsquo; Objects</p></a></li>
<li><a href='#daphnia'><p>&lsquo;Daphnia Magna&rsquo; Data</p></a></li>
<li><a href='#Dmean'>
<p>Differentiate the Mean Function of a Nonlinear Model</p></a></li>
<li><a href='#Dvar'>
<p>Differentiate the Variance Function of a Nonlinear Model</p></a></li>
<li><a href='#expInfo'>
<p>Returns the Expected Information Matrix &mdash; Generic Function</p></a></li>
<li><a href='#expInfo.nlreg'>
<p>Expected Information Matrix for &lsquo;nlreg&rsquo; Objects</p></a></li>
<li><a href='#fitted.nlreg'>
<p>Use fitted() on a &lsquo;nlreg&rsquo; object</p></a></li>
<li><a href='#helicopter'><p>Helicopter Data</p></a></li>
<li><a href='#logLik.nlreg'>
<p>Compute the Log Likelihood for Nonlinear Heteroscedastic Models</p></a></li>
<li><a href='#metsulfuron'><p>Metsulfuron Methyl Data</p></a></li>
<li><a href='#mpl'>
<p>Maximum Adjusted Profile Likelihood Estimation &mdash; Generic Function</p></a></li>
<li><a href='#mpl.nlreg'>
<p>Maximum Adjusted Profile Likelihood Estimates for a &lsquo;nlreg&rsquo; Object</p></a></li>
<li><a href='#mpl.object'>
<p>Maximum Adjusted Profile Likelihood Object</p></a></li>
<li><a href='#nlreg'>
<p>Fit a Nonlinear Heteroscedastic Model via Maximum Likelihood</p></a></li>
<li><a href='#nlreg.contours.object'>
<p>Contour Object for Nonlinear Heteroscedastic Models</p></a></li>
<li><a href='#nlreg.diag'>
<p>Nonlinear Heteroscedastic Model Diagnostics</p></a></li>
<li><a href='#nlreg.object'>
<p>Nonlinear Heteroscedastic Model Object</p></a></li>
<li><a href='#nlreg.profile.objects'>
<p>Profile Objects for Nonlinear Heteroscedastic Models</p></a></li>
<li><a href='#obsInfo'>
<p>Returns the Observed Information Matrix &mdash; Generic Function</p></a></li>
<li><a href='#obsInfo.nlreg'>
<p>Observed Information Matrix for &lsquo;nlreg&rsquo; Objects</p></a></li>
<li><a href='#param'>
<p>Extract All Parameters from a Model &mdash; Generic Function</p></a></li>
<li><a href='#param.nlreg'>
<p>Use param() on a &lsquo;nlreg&rsquo; object</p></a></li>
<li><a href='#plot.nlreg.contours'>
<p>Use plot() on a &lsquo;nlreg.contours&rsquo; object</p></a></li>
<li><a href='#plot.nlreg.diag'>
<p>Diagnostic Plots for Nonlinear Heteroscedastic Models</p></a></li>
<li><a href='#plot.nlreg.profiles'>
<p>Use plot() on a &lsquo;profile.nlreg&rsquo; and &lsquo;all.profiles.nlreg&rsquo; object</p></a></li>
<li><a href='#print.mpl'>
<p>Use print() on a &lsquo;mpl&rsquo; object</p></a></li>
<li><a href='#print.nlreg'>
<p>Use print() on a &lsquo;nlreg&rsquo; object</p></a></li>
<li><a href='#print.nlreg.contours'>
<p>Use print() on a &lsquo;nlreg.contours&rsquo; object</p></a></li>
<li><a href='#print.nlreg.profiles'>
<p>Use print() on a &lsquo;nlreg.profile&rsquo; and &lsquo;all.nlreg.profiles&rsquo; object</p></a></li>
<li><a href='#print.summary.mpl'>
<p>Use print() on a &lsquo;summary.mpl&rsquo; object</p></a></li>
<li><a href='#print.summary.nlreg'>
<p>Use print() on a &lsquo;summary.nlreg&rsquo; object</p></a></li>
<li><a href='#print.summary.nlreg.profiles'>
<p>Use print() on a &lsquo;summary.nlreg.profile&rsquo; and</p>
&lsquo;summary.all.nlreg.profiles&rsquo; object</a></li>
<li><a href='#profile.nlreg'>
<p>Profile Method for &lsquo;nlreg&rsquo; Objects</p></a></li>
<li><a href='#qStheta'>
<p>Support for &lsquo;nlreg&rsquo; package of &lsquo;hoa&rsquo; bundle</p></a></li>
<li><a href='#residuals.nlreg'>
<p>Use residuals() on a &lsquo;nlreg&rsquo; object</p></a></li>
<li><a href='#ria'><p>Radioimmunoassay Data</p></a></li>
<li><a href='#summary.all.nlreg.profiles'>
<p>Summary Method for Objects of Class &lsquo;all.nlreg.profiles&rsquo;</p></a></li>
<li><a href='#summary.mpl'>
<p>Summary Method for &lsquo;mpl&rsquo; Objects</p></a></li>
<li><a href='#summary.nlreg'>
<p>Summary Method for Nonlinear Heteroscedastic Models</p></a></li>
<li><a href='#summary.nlreg.profile'>
<p>Summary Method for Objects of Class &lsquo;nlreg.profile&rsquo;</p></a></li>
<li><a href='#var2cor'>
<p>Convert Covariance Matrix to Correlation Matrix &mdash; Generic Function</p></a></li>
<li><a href='#var2cor.nlregmpl'>
<p>Use var2cor() on a &lsquo;nlreg&rsquo; and &lsquo;mpl&rsquo; object</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Version:</td>
<td>1.2-2.2</td>
</tr>
<tr>
<td>Date:</td>
<td>2019-01-30</td>
</tr>
<tr>
<td>Title:</td>
<td>Higher Order Inference for Nonlinear Heteroscedastic Models</td>
</tr>
<tr>
<td>Author:</td>
<td>S original by Alessandra R. Brazzale &lt;alessandra.brazzale@unipd.it&gt;
  and Ruggero Bellio &lt;ruggero.bellio@uniud.it&gt;.  R port by Alessandra R. 
  Brazzale &lt;alessandra.brazzale@unipd.it&gt;, following earlier work by 
  Douglas Bates.</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Alessandra R. Brazzale &lt;alessandra.brazzale@unipd.it&gt;</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://www.r-project.org">https://www.r-project.org</a>, <a href="http://statwww.epfl.ch/AA/">http://statwww.epfl.ch/AA/</a></td>
</tr>
<tr>
<td>Description:</td>
<td>Likelihood inference based on higher order approximations 
  for nonlinear models with possibly non constant variance.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0), statmod, survival</td>
</tr>
<tr>
<td>Suggests:</td>
<td>boot, cond, csampling, marg</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> | file LICENCE [expanded from: GPL (&ge; 2) | file LICENCE]</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>LazyData:</td>
<td>yes</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2019-01-30 13:55:21 UTC; brazzale</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2019-01-30 14:50:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='nlreg-package'>
Higher Order Inference for Nonlinear Heteroscedastic Models
</h2><span id='topic+nlreg-package'></span>

<h3>Description</h3>

<p>Likelihood inference based on higher order approximations 
for nonlinear models with possibly non constant variance.
</p>


<h3>Details</h3>

<p>The DESCRIPTION file:
</p>

<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> nlreg</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 1.2-2.2</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2019-01-30</td>
</tr>
<tr>
 <td style="text-align: left;">
Title: </td><td style="text-align: left;"> Higher Order Inference for Nonlinear Heteroscedastic Models</td>
</tr>
<tr>
 <td style="text-align: left;">
Author: </td><td style="text-align: left;"> S original by Alessandra R. Brazzale &lt;alessandra.brazzale@unipd.it&gt;
  and Ruggero Bellio &lt;ruggero.bellio@uniud.it&gt;.  R port by Alessandra R. 
  Brazzale &lt;alessandra.brazzale@unipd.it&gt;, following earlier work by 
  Douglas Bates.</td>
</tr>
<tr>
 <td style="text-align: left;">
Maintainer: </td><td style="text-align: left;"> Alessandra R. Brazzale &lt;alessandra.brazzale@unipd.it&gt;</td>
</tr>
<tr>
 <td style="text-align: left;">
URL: </td><td style="text-align: left;"> https://www.r-project.org, http://statwww.epfl.ch/AA/</td>
</tr>
<tr>
 <td style="text-align: left;">
Description: </td><td style="text-align: left;"> Likelihood inference based on higher order approximations 
  for nonlinear models with possibly non constant variance.</td>
</tr>
<tr>
 <td style="text-align: left;">
Depends: </td><td style="text-align: left;"> R (&gt;= 3.5.0), statmod, survival</td>
</tr>
<tr>
 <td style="text-align: left;">
Suggests: </td><td style="text-align: left;"> boot, cond, csampling, marg</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL (&gt;= 2) | file LICENCE</td>
</tr>
<tr>
 <td style="text-align: left;">
LazyLoad: </td><td style="text-align: left;"> yes</td>
</tr>
<tr>
 <td style="text-align: left;">
LazyData: </td><td style="text-align: left;"> yes</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>Index of help topics:
</p>
<pre>
C1                      Six Herbicide Data Sets
Dmean                   Differentiate the Mean Function of a Nonlinear
                        Model
Dvar                    Differentiate the Variance Function of a
                        Nonlinear Model
chlorsulfuron           Chlorsulfuron Data
contour.all.nlreg.profiles
                        Contour Method for 'nlreg' Objects
daphnia                 'Daphnia Magna' Data
expInfo                 Returns the Expected Information Matrix -
                        Generic Function
expInfo.nlreg           Expected Information Matrix for 'nlreg' Objects
helicopter              Helicopter Data
logLik.nlreg            Compute the Log Likelihood for Nonlinear
                        Heteroscedastic Models
metsulfuron             Metsulfuron Methyl Data
mpl                     Maximum Adjusted Profile Likelihood Estimation
                        - Generic Function
mpl.nlreg               Maximum Adjusted Profile Likelihood Estimates
                        for a 'nlreg' Object
mpl.object              Maximum Adjusted Profile Likelihood Object
nlreg                   Fit a Nonlinear Heteroscedastic Model via
                        Maximum Likelihood
nlreg-package           Higher Order Inference for Nonlinear
                        Heteroscedastic Models
nlreg.diag              Nonlinear Heteroscedastic Model Diagnostics
nlreg.object            Nonlinear Heteroscedastic Model Object
obsInfo                 Returns the Observed Information Matrix -
                        Generic Function
obsInfo.nlreg           Observed Information Matrix for 'nlreg' Objects
param                   Extract All Parameters from a Model - Generic
                        Function
plot.nlreg.contours     Use plot() on a 'nlreg.contours' object
plot.nlreg.diag         Diagnostic Plots for Nonlinear Heteroscedastic
                        Models
plot.nlreg.profile      Use plot() on a 'profile.nlreg' and
                        'all.profiles.nlreg' object
profile.nlreg           Profile Method for 'nlreg' Objects
ria                     Radioimmunoassay Data
summary.all.nlreg.profiles
                        Summary Method for Objects of Class
                        'all.nlreg.profiles'
summary.mpl             Summary Method for 'mpl' Objects
summary.nlreg           Summary Method for Nonlinear Heteroscedastic
                        Models
summary.nlreg.profile   Summary Method for Objects of Class
                        'nlreg.profile'
var2cor                 Convert Covariance Matrix to Correlation Matrix
                        - Generic Function
</pre>
<p>Likelihood inference based on higher order approximations
for nonlinear models with possibly non constant variance
</p>

<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> nlreg</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 1.2-0</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2009-10-03</td>
</tr>
<tr>
 <td style="text-align: left;">
URL: </td><td style="text-align: left;"> http://www.r-project.org, http://statwww.epfl.ch/AA/</td>
</tr>
<tr>
 <td style="text-align: left;">
Depends: </td><td style="text-align: left;"> R (&gt;= 2.6.0), statmod, survival</td>
</tr>
<tr>
 <td style="text-align: left;">
Suggests: </td><td style="text-align: left;"> boot, cond, csampling, marg</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL (&gt;= 2)</td>
</tr>
<tr>
 <td style="text-align: left;">
LazyLoad: </td><td style="text-align: left;"> yes</td>
</tr>
<tr>
 <td style="text-align: left;">
LazyData: </td><td style="text-align: left;"> yes</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>Index:
</p>
<pre>
Functions:
=========
Dmean                   Differentiate the Mean Function of a Nonlinear
                        Model
Dvar                    Differentiate the Variance Function of a
                        Nonlinear Model
contour.all.nlreg.profiles
                        Contour Method for 'nlreg' Objects
expInfo                 Returns the Expected Information Matrix --
                        Generic Function
expInfo.nlreg           Expected Information Matrix for 'nlreg'
                        Objects
logLik.nlreg            Compute the Log Likelihood for Nonlinear
                        Heteroscedastic Models
mpl                     Maximum Adjusted Profile Likelihood Estimation
                        -- Generic Function
mpl.nlreg               Maximum Adjusted Profile Likelihood Estimates
                        for a 'nlreg' Object
mpl.object              Maximum Adjusted Profile Likelihood Object
nlreg                   Fit a Nonlinear Heteroscedastic Model via
                        Maximum Likelihood
nlreg.diag              Nonlinear Heteroscedastic Model Diagnostics
nlreg.object            Nonlinear Heteroscedastic Model Object
obsInfo                 Returns the Observed Information Matrix --
                        Generic Function
obsInfo.nlreg           Observed Information Matrix for 'nlreg'
                        Objects
param                   Extract All Parameters from a Model -- Generic
                        Function
plot.nlreg.contours     Use plot() on a 'nlreg.contours' object
plot.nlreg.diag         Diagnostic Plots for Nonlinear Heteroscedastic
                        Models
plot.nlreg.profile      Use plot() on a 'profile.nlreg' and
                        'all.profiles.nlreg' object
profile.nlreg           Profile Method for 'nlreg' Objects
summary.all.nlreg.profiles
                        Summary Method for Objects of Class
                        'all.nlreg.profiles'
summary.mpl             Summary Method for 'mpl' Objects
summary.nlreg           Summary Method for Nonlinear Heteroscedastic
                        Models
summary.nlreg.profile   Summary Method for Objects of Class
                        'nlreg.profile'
var2cor                 Convert Covariance Matrix to Correlation
                        Matrix -- Generic Function


Datasets:
========
C1                      Herbicide Data (Chlorsulfuron)
C2                      Herbicide Data (Chlorsulfuron)
C3                      Herbicide Data (Chlorsulfuron)
C4                      Herbicide Data (Chlorsulfuron)
M2                      Herbicide Data (Metsulfuron Methyl)
M4                      Herbicide Data (Metsulfuron Methyl)
chlorsulfuron           Chlorsulfuron Data
daphnia                 'Daphnia Magna' Data
helicopter              Paper Helicopter Data
metsulfuron             Metsulfuron Methyl Data
ria                     Radioimmunoassay Data
</pre>
<p>Further information is available in the following vignettes:
</p>

<table>
<tr>
 <td style="text-align: left;">
<code>Rnews-paper</code> </td><td style="text-align: left;"> hoa: An R Package Bundle for Higher Order Likelihood Inference (source, pdf)</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Author(s)</h3>

<p>S original by Alessandra R. Brazzale &lt;alessandra.brazzale@unipd.it&gt;
and Ruggero Bellio &lt;ruggero.bellio@uniud.it&gt;.  R port by Alessandra R. 
Brazzale &lt;alessandra.brazzale@unipd.it&gt;, following earlier work by 
Douglas Bates.
</p>
<p>Maintainer: Alessandra R. Brazzale &lt;alessandra.brazzale@unipd.it&gt;
</p>


<h3>References</h3>

<p>Brazzale, A.R. (2005).  hoa: An R package bundle for higher order likelihood inference.  Rnews, 5/1, May 2005, 20-27.  ISSN 609-3631.  URL: https://www.r-project.org/doc/Rnews/Rnews_2005-1.pdf
</p>
<p>Examples of applications, and generally of the use of likelihood asymptotics, are given in:
Brazzale, A.R., Davison, A.C. and Reid, N. (2007).  Applied Asymptotics: Case Studies in Small-Sample Statistics.  Cambridge University Press, Cambridge.  
URL: http://statwww.epfl.ch/AA/
</p>


<h3>See Also</h3>

<p><code><a href="cond.html#topic+cond-package">cond</a></code> 
<code><a href="marg.html#topic+marg-package">marg</a></code> 
<code><a href="csampling.html#topic+csampling-package">csampling</a></code> 
</p>

<hr>
<h2 id='allProfiles'>
Support for function &lsquo;profile.nlreg&rsquo; &mdash; Generic Function   
</h2><span id='topic+allProfiles'></span>

<h3>Description</h3>

<p>This is support for the function <code><a href="#topic+profile.nlreg">profile.nlreg</a></code>. 
It is not intended to be called directly by users.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>allProfiles(fitted, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="allProfiles_+3A_fitted">fitted</code></td>
<td>

<p>a fitted <code>nlreg</code> object such as returned by a call to 
<code><a href="#topic+nlreg">nlreg</a></code>.
</p>
</td></tr>
<tr><td><code id="allProfiles_+3A_...">...</code></td>
<td>

<p>absorbs any additional argument.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>allProfiles.nlreg</code> function is called internally by the 
<code><a href="#topic+profile.nlreg">profile.nlreg</a></code> routine.  It is not intended to 
be called directly by users. 
</p>


<h3>Value</h3>

<p>a list of elements of class <code>all.nlreg.profiles</code> for profiling 
all parameters of a nonlinear heteroscedastic model.  
</p>


<h3>See Also</h3>

<p><code><a href="#topic+profile.nlreg">profile.nlreg</a></code>, 
<code><a href="#topic+nlreg.profile.objects">nlreg.profile.objects</a></code>, 
<code><a href="#topic+nlreg.object">nlreg.object</a></code>
</p>

<hr>
<h2 id='allProfiles.nlreg'>
Support for function &lsquo;profile.nlreg&rsquo; 
</h2><span id='topic+allProfiles.nlreg'></span>

<h3>Description</h3>

<p>This is support for the function <code><a href="#topic+profile.nlreg">profile.nlreg</a></code>. 
It is not intended to be called directly by users.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'nlreg'
allProfiles(fitted, hoa = TRUE, precision = 6, signif = 30, 
                   n = 50, omit = 0.5, trace = FALSE, call, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="allProfiles.nlreg_+3A_fitted">fitted</code></td>
<td>

<p>a fitted <code>nlreg</code> object such as returned by a call to 
<code><a href="#topic+nlreg">nlreg</a></code>.
</p>
</td></tr>
<tr><td><code id="allProfiles.nlreg_+3A_hoa">hoa</code></td>
<td>

<p>logical value indicating whether higher order statistics should be
calculated; default is <code>TRUE</code>.
</p>
</td></tr>
<tr><td><code id="allProfiles.nlreg_+3A_precision">precision</code></td>
<td>

<p>numerical value defining the maximum range of values, given by 
<abbr><span class="acronym">MLE</span></abbr> <code class="reqn">\pm</code> <code>precision</code>*<abbr><span class="acronym">s.e.</span></abbr>, that
are profiled.  The default is 6.
</p>
</td></tr>
<tr><td><code id="allProfiles.nlreg_+3A_signif">signif</code></td>
<td>

<p>the maximum number of output points that are calculated exactly; 
default is 30. 
</p>
</td></tr>
<tr><td><code id="allProfiles.nlreg_+3A_n">n</code></td>
<td>

<p>the approximate number of output points produced by the spline
interpolation; default is 50.
</p>
</td></tr>
<tr><td><code id="allProfiles.nlreg_+3A_omit">omit</code></td>
<td>

<p>numerical value defining the range of values, given by 
<abbr><span class="acronym">MLE</span></abbr> <code class="reqn">\pm</code> <code>omit</code>*<abbr><span class="acronym">s.e.</span></abbr>, which is 
omitted in the spline interpolation of the higher order statistics
considered.  The purpose is to avoid numerical instabilities 
around the maximum likelihood estimate.
</p>
</td></tr>
<tr><td><code id="allProfiles.nlreg_+3A_trace">trace</code></td>
<td>

<p>if <code>TRUE</code>, details of the iterations are printed.
</p>
</td></tr>
<tr><td><code id="allProfiles.nlreg_+3A_...">...</code></td>
<td>

<p>absorbs any additional argument.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>allProfiles.nlreg</code> function is called internally by the 
<code><a href="#topic+profile.nlreg">profile.nlreg</a></code> routine.  It is not intended to 
be called directly by users. 
</p>


<h3>Value</h3>

<p>a list of elements of class <code>all.nlreg.profiles</code> for profiling 
all parameters of a nonlinear heteroscedastic model.  
</p>


<h3>See Also</h3>

<p><code><a href="#topic+profile.nlreg">profile.nlreg</a></code>, 
<code><a href="#topic+nlreg.profile.objects">nlreg.profile.objects</a></code>, 
<code><a href="#topic+nlreg.object">nlreg.object</a></code>
</p>

<hr>
<h2 id='C1'>Six Herbicide Data Sets</h2><span id='topic+C1'></span><span id='topic+C2'></span><span id='topic+C3'></span><span id='topic+C4'></span><span id='topic+M2'></span><span id='topic+M4'></span>

<h3>Description</h3>

<p>The <code>C1</code>&ndash;<code>C4</code>, <code>M2</code> and <code>M4</code> data frames have
40 to 72 rows and three columns.
</p>
<p>Six bioassay on the action of the herbicides chlorsulfuron and metsulfuron
methyl on the callus area of colonies of <em>Brassica napus L</em>.  The 
experiments consist of measurements for different dose levels and can be
balanced (<code>C4</code>, <code>M2</code>) or unbalanced (<code>C1</code>, <code>C2</code>, <code>C3</code>,
<code>M4</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  data(C1)
  data(C2)
  data(C3)
  data(C4)
  data(M2)
  data(M4)
</code></pre>


<h3>Format</h3>

<p>These data frame contain the following columns:
</p>

<dl>
<dt><code>group</code></dt><dd>
<p>indicator variable for each tested dose;
</p>
</dd>    
<dt><code>dose</code></dt><dd>
<p>the tested dose (nmol/l);
</p>
</dd>
<dt><code>area</code></dt><dd>
<p>the callus area (<code class="reqn">mm^2</code>).
</p>
</dd>
</dl>



<h3>Note</h3>

<p>Data sets <code>C3</code> and <code><a href="#topic+chlorsulfuron">chlorsulfuron</a></code> are the same.
Data sets <code>M2</code> and <code><a href="#topic+metsulfuron">metsulfuron</a></code> are the same.
</p>


<h3>Source</h3>

<p>The data were obtained from
</p>
<p>Seiden, P., Kappel, D. and Streibig, J. C. (1998) Response of
<em>Brassica napus L.</em> tissue culture to metsulfuron methyl and
chlorsulfuron.  <em>Weed Research</em>, <b>38</b>, 221&ndash;228.  
</p>


<h3>References</h3>

<p>Bellio, R., Jensen, J.E. and Seiden, P. (2000).  Applications of 
likelihood asymptotics for nonlinear regression in herbicide bioassays.
<em>Biometrics</em>, <b>56</b>, 1204&ndash;1212.
</p>
<p>Brazzale, A. R. (2000) <em>Practical Small-Sample Parametric 
Inference</em>.  Ph.D. Thesis N. 2230, Department of Mathematics, Swiss 
Federal Institute of Technology Lausanne.  Section 5.3, Example 8.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+chlorsulfuron">chlorsulfuron</a></code>, <code><a href="#topic+metsulfuron">metsulfuron</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(C3)
attach(C3)
plot(dose, area, xlab = "tested dose (nmol/l)", 
     ylab = "log callus area (mm^2)", log = "y")
detach()
</code></pre>

<hr>
<h2 id='chlorsulfuron'>Chlorsulfuron Data</h2><span id='topic+chlorsulfuron'></span>

<h3>Description</h3>

<p>The <code>chlorsulfuron</code> data frame has 51 rows and 3 columns.
</p>
<p>Bioassay on the action of the herbicide chlorsulfuron on the callus 
area of colonies of <em>Brassica napus L</em>.  The experiment 
consists of 51 measurements for 10 different dose levels.  The 
design is unbalanced: the number of replicates per dose varies from
a minimum of 5 to a maximum of 8.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(chlorsulfuron)</code></pre>


<h3>Format</h3>

<p>This data frame contains the following columns:
</p>

<dl>
<dt><code>group</code></dt><dd>
<p>indicator variable for each tested dose;
</p>
</dd>    
<dt><code>dose</code></dt><dd>
<p>the tested dose (nmol/l);
</p>
</dd>
<dt><code>area </code></dt><dd>
<p>the callus area (<code class="reqn">mm^2</code>).
</p>
</dd>
</dl>



<h3>Source</h3>

<p>The data were obtained from
</p>
<p>Seiden, P., Kappel, D. and Streibig, J. C. (1998) Response of
<em>Brassica napus L.</em> tissue culture to metsulfuron methyl and
chlorsulfuron.  <em>Weed Research</em>, <b>38</b>, 221&ndash;228.  Dataset
C3. 
</p>


<h3>References</h3>

<p>Bellio, R., Jensen, J.E. and Seiden, P. (2000).  Applications of 
likelihood asymptotics for nonlinear regression in herbicide bioassays.
<em>Biometrics</em>, <b>56</b>, 1204&ndash;1212.
</p>
<p>Brazzale, A. R. (2000) <em>Practical Small-Sample Parametric 
Inference</em>.  Ph.D. Thesis N. 2230, Department of Mathematics, Swiss 
Federal Institute of Technology Lausanne.  Section 5.3, Example 8.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(chlorsulfuron)
attach(chlorsulfuron)
plot(dose, area, xlab = "tested dose (nmol/l)", 
     ylab = "log callus area (mm^2)", log = "y")
detach()
</code></pre>

<hr>
<h2 id='coef.nlreg'>
Use coef() on a &lsquo;nlreg&rsquo; object
</h2><span id='topic+coef.nlreg'></span>

<h3>Description</h3>

<p>This is a method for the function <code>coef()</code> for objects 
inheriting from class <code>nlreg</code>.  See <code><a href="stats.html#topic+coef">coef</a></code> for the 
general behavior of this function and for the interpretation of 
<code>object</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'nlreg'
coef(object, ...)
</code></pre>


<h3>See Also</h3>

<p><code><a href="#topic+nlreg.object">nlreg.object</a></code>, <code><a href="stats.html#topic+coef">coef</a></code>
</p>

<hr>
<h2 id='contour.all.nlreg.profiles'>
Contour Method for &lsquo;nlreg&rsquo; Objects
</h2><span id='topic+contour.all.nlreg.profiles'></span>

<h3>Description</h3>

<p>Draws the approximate bivariate contour plots for two or all  
parameters of a nonlinear heteroscedastic model and, on request,
returns the list of elements used.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'all.nlreg.profiles'
contour(x, offset1, offset2, alpha = c(0.1, 0.05),
        stats = c("sk", "fr"), ret = FALSE, plotit = TRUE, 
        drawlabels = FALSE, lwd1 = 1, lwd2 = 1, lty1 = "solid", 
        lty2 = "solid", cl1 = "blue", cl2 = "red", col = "black", 
        pch1 = 1, pch2 = 16, cex = 0.5, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="contour.all.nlreg.profiles_+3A_x">x</code></td>
<td>

<p>an <code>all.nlreg.profiles</code> object, that is, the result of a call to 
<code><a href="#topic+profile.nlreg">profile.nlreg</a></code> with <code>offset = "all"</code>. 
</p>
</td></tr>
<tr><td><code id="contour.all.nlreg.profiles_+3A_offset1">offset1</code>, <code id="contour.all.nlreg.profiles_+3A_offset2">offset2</code></td>
<td>

<p>the two parameters to consider in the approximate bivariate contour
plots. 
</p>
</td></tr>
<tr><td><code id="contour.all.nlreg.profiles_+3A_alpha">alpha</code></td>
<td>

<p>a numerical vector defining the levels of the contours; the default
is <code>c(0.1, 0.05)</code>, that is, <code class="reqn">1-\alpha=0.9</code>
and <code class="reqn">1-\alpha=0.95</code>. 
</p>
</td></tr>
<tr><td><code id="contour.all.nlreg.profiles_+3A_stats">stats</code></td>
<td>

<p>character value indicating which higher order statistics to plot.  
Admissible values are <code>"sk"</code> for <cite>Skovgaard's (1996)</cite> 
proposal and <code>"fr"</code> for <cite>Fraser, Reid and Wu's (1999)</cite>
approach.  The default is <code>"sk"</code>.
</p>
</td></tr>
<tr><td><code id="contour.all.nlreg.profiles_+3A_ret">ret</code></td>
<td>

<p>logical value; if <code>TRUE</code>, a list containing the elements 
needed to draw the approximate contour plots is 
returned.  Default is <code>FALSE</code>.
</p>
</td></tr>
<tr><td><code id="contour.all.nlreg.profiles_+3A_plotit">plotit</code></td>
<td>

<p>logical value indicating whether to draw the contours.  Default is 
<code>TRUE</code>.
</p>
</td></tr>
<tr><td><code id="contour.all.nlreg.profiles_+3A_drawlabels">drawlabels</code></td>
<td>

<p>logical value.  Contours are labelled if <code>TRUE</code>.
</p>
</td></tr>
<tr><td><code id="contour.all.nlreg.profiles_+3A_lwd1">lwd1</code>, <code id="contour.all.nlreg.profiles_+3A_lwd2">lwd2</code></td>
<td>

<p>the line widths used to compare different curves in the same 
plot; default is <code>lwd2 = 2</code> for higher order solutions and 
<code>lwd1 = 1</code> for first order solutions.
</p>
</td></tr>
<tr><td><code id="contour.all.nlreg.profiles_+3A_lty1">lty1</code>, <code id="contour.all.nlreg.profiles_+3A_lty2">lty2</code></td>
<td>

<p>line types used to compare different curves in the same plot; 
default is <code>"solid"</code> for all statistics. 
</p>
</td></tr>
<tr><td><code id="contour.all.nlreg.profiles_+3A_cl1">cl1</code>, <code id="contour.all.nlreg.profiles_+3A_cl2">cl2</code>, <code id="contour.all.nlreg.profiles_+3A_col">col</code></td>
<td>

<p>colors used to compare different curves in the same plot; default
is <code>cl2 = "red"</code> for higher order solutions, and 
<code>cl1 = "blue"</code> for the remaining first order statistics.  
The default color of the plot is <code>col = "black"</code>.
</p>
</td></tr>
<tr><td><code id="contour.all.nlreg.profiles_+3A_pch1">pch1</code>, <code id="contour.all.nlreg.profiles_+3A_pch2">pch2</code></td>
<td>

<p>character types used to compare different values in the same plot; 
default is <code>pch2 = 16</code> for higher order solutions, and 
<code>pch1 = 1</code> for the remaining first order statistics.  
</p>
</td></tr>
<tr><td><code id="contour.all.nlreg.profiles_+3A_cex">cex</code></td>
<td>

<p>the character expansions relative to the standard size of the 
device to be used for printing text.  The default is 
<code>cex = 0.5</code>.
</p>
</td></tr>
<tr><td><code id="contour.all.nlreg.profiles_+3A_...">...</code></td>
<td>

<p>absorbs additional arguments such as graphics parameters.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>contour.all.nlreg.profiles</code> calculates all 
elements needed to draw the profile and approximate bivariate contour
plots for respectively two parameters of interest and all parameters 
in the model, depending on whether the <code>offset1</code> and 
<code>offset2</code> arguments are used.
</p>
<p>Contour plots represent the bivariate extension of profile plots.
Given two parameters of interst, they plot the corresponding joint
confidence regions of levels <code class="reqn">1-\alpha</code> obtained 
from the 
likelihood ratio statistic and the Wald statistic (<cite>Bates and 
Watts, 1988, Section 6.1.2</cite>).  The closer the two curves are, the 
more the likelihood surface is quadratic.  Usually profile traces are
added, that is, the curves showing the constrained maximum likelihood 
estimates of one parameter as a function of the other, as they 
provide useful information on how the estimates affect each other.  
If the asymptotic correlation is zero, the angle between the traces 
is close to <code class="reqn">\pi/2</code>.  The calculation of exact contour 
plots is computationally very intesive, as the model has to be 
refitted several times to obtain the constrained estimates.  
<cite>Bates and Watts (1988, Appendix A.6)</cite> present an approximate 
solution, which only requires the computation of the parameter 
profiles and which gives rise to the so-called profile pair sketches.
</p>
<p>The function <code>contour.all.nlreg.profiles</code> extends the classical
profile plots and profile pair sketches by including the higher order
solutions <code class="reqn">r^*</code> (<cite>Barndorff-Nielsen, 1991</cite>) and
<code class="reqn">w^*</code> (<cite>Skovgaard, 2001</cite>).  The idea is to provide 
insight into the behaviour of first order methods such as detecting 
possible bias of the estimates or the influence of the model 
curvature.  More precisely, the sample space derivatives in 
<cite>Barndorff-Nielsens' (1991)</cite> <code class="reqn">r^*</code> statistic are 
replaced by respectively the approximations proposed in 
<cite>Skovgaard (1996)</cite> and <cite>Fraser, Reid and Wu (1999)</cite> 
depending on the value of the <code>stats</code> argument.  
The <code class="reqn">r^*</code> statistic is used to calculate an approximation 
to <cite>Skovgaard's (2001)</cite> <code class="reqn">w^*</code> statistic adopting the 
method by <cite>Bates and Watts (1988, Appendix A.6)</cite>.  This method 
can break down, if the two 
parameter estimates are strongly correlated.  The approximate 
contours of <code class="reqn">w^*</code> are then missing in the corresponding 
panels; four bullets indicate where they intersect the profile 
traces.
</p>
<p>All necessary quantities are retrieved from the 
<code>all.nlreg.profiles</code> object passed through the 
<code>x</code> argument.  The <code>offset1</code> and <code>offset2</code> arguments 
can be used to specifiy two parameters of interest, in which case 
only the profile pair sketches for these two parameters are returned,
one on the original scale and one on the normal scale.  On the normal
scale, the units do not express the parameter values themselves, but 
the associated likelihood root statistics.  (See <cite>Bates 
and Watts, 1988, Section 6.1.2</cite>, for explanation.)  If the 
<code>offset1</code> and <code>offset2</code> arguments are missing, profile 
plots and approximate contour plots are drawn for all model
parameters.  The plots are organized in form of a matrix.  The main 
diagonal contains the profile plots.  The approximate bivariate 
contour plots in the lower triangle are plotted on the original 
scale, whereas the ones in the upper triangle are on the <code class="reqn">r</code> 
scale.
</p>
<p>The theory and statistics used are summarized in <cite>Brazzale 
(2000, Chapters 2 and 3)</cite>.  More details of the implementation are 
given in <cite>Brazzale (2000, Section 6.3.2)</cite>.
</p>


<h3>Value</h3>

<p>If <code>ret = TRUE</code>, a list of class <code>nlreg.contours</code> is returned
which contains the elements needed to draw the profiles and approximate 
bivariate contours for two or all parameters in a nonlinear 
heteroscedastic model.  Otherwise, no value is returned.
</p>


<h3>Side Effects</h3>

<p>If <code>plotit = TRUE</code>, a plot is produced on the current graphics 
device.
</p>


<h3>Note</h3>

<p><code>contour.all.nlreg.profiles</code> is a method for the generic 
function <code><a href="graphics.html#topic+contour">contour</a></code> for class 
<code>all.nlreg.profiles</code>.  It can be invoked by calling 
<code>contour</code> for an object of the appropriate class, or directly 
by calling <code>contour.all.nlreg.profiles</code>.  
</p>


<h3>References</h3>

<p>Barndorff-Nielsen, O. E. (1991) Modified signed log likelihood ratio.
<em>Biometrika</em>, <b>78</b>, 557&ndash;564.
</p>
<p>Bates, D. M. and Watts, D. G. (1988) <em>Nonlinear Regression 
Analysis and Its Applications</em>.  New York: Wiley.
</p>
<p>Brazzale, A. R. (2000) <em>Practical Small-Sample Parametric 
Inference</em>.  Ph.D. Thesis N. 2230, Department of Mathematics, Swiss 
Federal Institute of Technology Lausanne.
</p>
<p>Fraser, D.A.S., Reid, N. and Wu, J. (1999).  A simple general formula 
for tail probabilities for frequentist and Bayesian inference. 
<em>Biometrika</em>, <b>86</b>, 249&ndash;264.
</p>
<p>Skovgaard, I. M (1996) An explicit large-deviation approximation to
one-parameter tests.  <em>Bernoulli</em>, <b>2</b>, 145&ndash;165.
</p>
<p>Skovgaard, I. M. (2001) Likelihood asymptotics.  <em>Scandinavian 
Journal of Statistics</em>, <b>28</b>, 3&ndash;32.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+nlreg.profile.objects">nlreg.profile.objects</a></code>, 
<code><a href="#topic+plot.nlreg.contours">plot.nlreg.contours</a></code>,
<code><a href="graphics.html#topic+contour">contour</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(metsulfuron)
metsulfuron.nl &lt;- 
    nlreg( formula = log(area) ~ log( b1+(b2-b1) / (1+(dose/b4)^b3) ), 
           weights = ~ ( 1+dose^exp(g) )^2, data = metsulfuron, 
           start = c(b1 = 138, b2 = 2470, b3 = 2, b4 = 0.07, g = log(0.3)),
           hoa = TRUE )
##
metsulfuron.prof &lt;- profile( metsulfuron.nl, trace = TRUE )
par( mai = rep(0.2, 4) )
contour( metsulfuron.prof )
## End(Not run)
</code></pre>

<hr>
<h2 id='daphnia'>&lsquo;Daphnia Magna&rsquo; Data</h2><span id='topic+daphnia'></span>

<h3>Description</h3>

<p>The <code>daphnia</code> data frame has 136 rows and 2 columns.
</p>
<p>Ecotoxicity study to assess the impact of the herbicide dinoseb on 
the survival of <em>Daphnia magna</em> Strauss, 1820, a 
micro-crustacean widely used as test organism in aquatic 
ecotoxicological assays.  The design of the experiment includes 35 
irregularly spaced concentrations ranging from 0.006 to 11.3 mg/l 
and a control group.  The upper endpoint of 11.3 mg/l is the highest
concentration at which the test substance is soluble in the test 
medium.  The number of replicates per concentration varies from 1 to
11 experimental units.  The survival time is measured in days.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(daphnia)</code></pre>


<h3>Format</h3>

<p>This data frame contains the following columns:
</p>

<dl>
<dt><code>conc</code></dt><dd>
<p>the tested concentration (mg/l);
</p>
</dd>    
<dt><code>time</code></dt><dd>
<p>the survival time in days.
</p>
</dd>
</dl>



<h3>Source</h3>

<p>The data were obtained from
</p>
<p>Ch\'evre, N. (2000) <em>Etude et mod\'elisation des effets 
\'ecotoxiques d'un micropolluant organique sur</em> Daphnia magna
<em>et</em> Pseudokirchneriella subcapitata (in French).  Ph.D. 
Thesis N. 2117, Department of Rural Engineering, Swiss Federal 
Institute of Technology Lausanne.
</p>


<h3>References</h3>

<p>Brazzale, A.R. (2000) <em>Practical Small-Sample Parametric 
Inference</em>.  Ph.D. Thesis N. 2230, Department of Mathematics, Swiss
Federal Institute of Technology Lausanne.  Section 5.3, Example 5.
</p>
<p>Ch\'evre, N., Becker-van Slooten, K., Tarradellas, J., Brazzale, 
A. R., Behra, R. and Guettinger, H. (2001) Effects of dinoseb on the
entire life-cycle of <em>Daphnia  magna</em>.  Part II: Modelling of 
survival and proposal of an alternative to 
No-Observed-Effect-Concentration (NOEC).  <em>Environmental 
Toxicology and Chemistry</em>, <b>21</b>, 828&ndash;833.  
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(daphnia)
attach(daphnia)
plot(conc, time, xlab = "test concentration (mg/l)", 
     ylab = "survival time (d)", log = "y")
detach()
</code></pre>

<hr>
<h2 id='Dmean'>
Differentiate the Mean Function of a Nonlinear Model
</h2><span id='topic+Dmean'></span>

<h3>Description</h3>

<p>Calculates the gradient and Hessian of the mean function of a 
nonlinear heteroscedastic model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Dmean(nlregObj, hessian = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Dmean_+3A_nlregobj">nlregObj</code></td>
<td>

<p>a nonlinear heteroscedastic model fit as obtained from a call to
<code><a href="#topic+nlreg">nlreg</a></code>.  
</p>
</td></tr>
<tr><td><code id="Dmean_+3A_hessian">hessian</code></td>
<td>

<p>logical value indicating whether the Hessian should be computed.  
The default is <code>TRUE</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The mean function is differentiated with respect to the regression 
coefficients as specified in the <code>coef</code> component of the 
<code>nlreg</code> object.  The returned function definition, however, 
includes all parameters &mdash; regression coefficients and variance 
parameters &mdash; as arguments.  When evaluated, it implicitly refers 
to the data to whom the model was fitted and which must be on the 
search list.  The gradient and Hessian are calculated for each data
point: the <code>gradient</code> attribute is a 
<code class="reqn">n\times p</code> matrix and the <code>hessian</code> 
attribute is a <code class="reqn">n\times p\times p</code> array, 
where <code class="reqn">n</code> and <code class="reqn">p</code> are respectively the 
number of data points and the number of regression coefficients.
</p>


<h3>Value</h3>

<p>a function whose arguments are named according to the parameters of
the nonlinear model <code>nlregObj</code>.  When evaluated, it returns the
value of the mean function along with attributes called 
<code>gradient</code> and <code>hessian</code>, the latter if requested.  These 
are the gradient and Hessian of the mean function with respect to the 
regression coefficients.
</p>


<h3>Note</h3>

<p><code>Dmean</code> and <code>Dvar</code> are the two workhorse functions of the
<code>nlreg</code> library.  The details are given in <cite>Brazzale 
(2000, Section 6.1.2)</cite>.
</p>
<p>The symbolic differentiation algorithm is based upon the
<code><a href="stats.html#topic+deriv">D</a></code> function.  As this algorithm is highly
recursive, the <code>hessian = TRUE</code> argument should only be used if
the Hessian matrix is needed.  Whenever possible, derivatives should
be stored so as to be re-used in further calculations.  This is, for
instance, achieved by the nonlinear heteroscedastic model fitting
routine <code><a href="#topic+nlreg">nlreg</a></code> through the argument 
<code>hoa = TRUE</code>.
</p>


<h3>References</h3>

<p>Becker, R. A., Chambers, J. M. and Wilks, A. R. (1988) <em>The New
S Language: A Programming Environment for Data Analysis and 
Graphics</em>.  London: Chapman \&amp; Hall.  Section 9.6.
</p>
<p>Brazzale, A. R. (2000) <em>Practical Small-Sample Parametric 
Inference</em>.  Ph.D. Thesis N. 2230, Department of Mathematics, Swiss
Federal Institute of Technology Lausanne.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Dvar">Dvar</a></code>, <code><a href="#topic+nlreg.object">nlreg.object</a></code>,
<code><a href="stats.html#topic+deriv">deriv3</a></code>, <code><a href="stats.html#topic+deriv">D</a></code> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(boot)
data(calcium)
calcium.nl &lt;- nlreg( cal ~ b0*(1-exp(-b1*time)), 
                     start = c(b0 = 4, b1 = 0.1),  data = calcium )
Dmean( calcium.nl )
##function (b0, b1, logs)
##{
##    .expr3 &lt;- exp(-b1 * time)
##    .expr4 &lt;- 1 - .expr3
##    .expr6 &lt;- .expr3 * time
##    .value &lt;- b0 * .expr4
##    .grad &lt;- array(0, c(length(.value), 2), list(NULL, c("b0",
##        "b1")))
##    .hessian &lt;- array(0, c(length(.value), 2, 2), list(NULL,
##        c("b0", "b1"), c("b0", "b1")))
##    .grad[, "b0"] &lt;- .expr4
##    .hessian[, "b0", "b0"] &lt;- 0
##    .hessian[, "b0", "b1"] &lt;- .hessian[, "b1", "b0"] &lt;- .expr6
##    .grad[, "b1"] &lt;- b0 * .expr6
##    .hessian[, "b1", "b1"] &lt;- -(b0 * (.expr6 * time))
##    attr(.value, "gradient") &lt;- .grad
##    attr(.value, "hessian") &lt;- .hessian
##    .value
##}
##
param( calcium.nl )
##        b0         b1       logs
## 4.3093653  0.2084780 -1.2856765
##
attach( calcium )
calcium.md &lt;- Dmean( calcium.nl )
attr( calcium.md( 4.31, 0.208, -1.29 ), "gradient" )
##              b0       b1
## [1,] 0.08935305 1.766200
## [2,] 0.08935305 1.766200
## [3,] 0.08935305 1.766200
## [4,] 0.23692580 4.275505
## \dots
detach()
</code></pre>

<hr>
<h2 id='Dvar'>
Differentiate the Variance Function of a Nonlinear Model
</h2><span id='topic+Dvar'></span>

<h3>Description</h3>

<p>Calculates the gradient and Hessian of the variance function of a
nonlinear heteroscedastic model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Dvar(nlregObj, hessian = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Dvar_+3A_nlregobj">nlregObj</code></td>
<td>

<p>a nonlinear heteroscedastic model fit as obtained from a call to
<code><a href="#topic+nlreg">nlreg</a></code>.  
</p>
</td></tr>
<tr><td><code id="Dvar_+3A_hessian">hessian</code></td>
<td>

<p>logical value indicating whether the Hessian should be computed.  
The default is <code>TRUE</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The variance function is differentiated with respect to the variance
parameters specified in the <code>varPar</code> component of the 
<code>nlregObj</code> object and, if the variance function depends on 
them, with respect to the regression coefficients specified in the
<code>coef</code> component.  The  returned function definition includes 
all parameters.  When evaluated, it implicitly refers to the data to
whom the <code>nlreg</code> object was fitted and which must be on the 
search list.  The gradient and Hessian are calculated for each data
point: the <code>gradient</code> attribute is a 
<code class="reqn">n\times p</code> matrix, and the <code>hessian</code> 
attribute is a <code class="reqn">n\times p\times p</code> array, 
where <code class="reqn">n</code> and <code class="reqn">p</code> are respectively the 
number of data points and the number of regression coefficients.
</p>


<h3>Value</h3>

<p>a function whose arguments are named according to the parameters of
the nonlinear model <code>nlregObj</code>.  When evaluated, it returns the
value of the variance function along with attributes called 
<code>gradient</code> and <code>hessian</code>, the latter if requested.  These 
are the gradient and Hessian of the variance function with respect 
to the model parameters.
</p>


<h3>Note</h3>

<p><code>Dmean</code> and <code>Dvar</code> are the two workhorse functions of the
<code>nlreg</code> library.  The details are given in <cite>Brazzale 
(2000, Section 6.1.2)</cite>.
</p>
<p>The symbolic differentiation algorithm is based upon the
<code><a href="stats.html#topic+deriv">D</a></code> function.  As this algorithm is highly 
recursive, the <code>hessian = TRUE</code> argument should only be used if
the Hessian matrix is needed.  Whenever possible, derivatives 
should be stored so as to be re-used in further calculations.  This
is, for instance, achieved for the nonlinear heteroscedastic model 
fitting routine <code><a href="#topic+nlreg">nlreg</a></code> through the argument 
<code>hoa = TRUE</code>.
</p>


<h3>References</h3>

<p>Becker, R. A., Chambers, J. M. and Wilks, A. R. (1988) <em>The New
S Language: A Programming Environment for Data Analysis and 
Graphics</em>.  London: Chapman \&amp; Hall.  Section 9.6.
</p>
<p>Brazzale, A. R. (2000) <em>Practical Small-Sample Parametric 
Inference</em>.  Ph.D. Thesis N. 2230, Department of Mathematics, Swiss
Federal Institute of Technology Lausanne.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Dmean">Dmean</a></code>, <code><a href="#topic+nlreg.object">nlreg.object</a></code>,
<code><a href="stats.html#topic+deriv">deriv3</a></code>, <code><a href="stats.html#topic+deriv">D</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(boot)
data(calcium)
calcium.nl &lt;- nlreg( cal ~ b0*(1-exp(-b1*time)), 
                     start = c(b0 = 4, b1 = 0.1), data = calcium )
Dvar( calcium.nl )
##function (b0, b1, logs)
##{
##    .expr1 &lt;- exp(logs)
##    .value &lt;- .expr1
##    .grad &lt;- array(0, c(length(.value), 1), list(NULL, c("logs")))
##    .hessian &lt;- array(0, c(length(.value), 1, 1), list(NULL,
##        c("logs"), c("logs")))
##    .grad[, "logs"] &lt;- .expr1
##    .hessian[, "logs", "logs"] &lt;- .expr1
##    attr(.value, "gradient") &lt;- .grad
##    attr(.value, "hessian") &lt;- .hessian
##    .value
##}
##
attach( calcium )
calcium.vd &lt;- Dvar( calcium.nl )
param( calcium.nl )
##        b0         b1       logs
## 4.3093653  0.2084780 -1.2856765
##
attr( calcium.vd( 4.31, 0.208, -1.29 ), "gradient" )
##          logs
##[1,] 0.2752708
##
calcium.nl &lt;- update( calcium.nl, weights = ~ ( 1+time^g )^2, 
                      start = c(b0 = 4, b1 = 0.1, g = 1))
Dvar( calcium.nl )
##function (b0, b1, g, logs) 
##{
##    .expr1 &lt;- time^g
##    .expr2 &lt;- 1 + .expr1
##    .expr4 &lt;- exp(logs)
##    .expr5 &lt;- .expr2^2 * .expr4
##    .expr6 &lt;- log(time)
##    .expr7 &lt;- .expr1 * .expr6
##    .expr10 &lt;- 2 * (.expr7 * .expr2) * .expr4
##    .value &lt;- .expr5
##    .grad &lt;- array(0, c(length(.value), 2), list(NULL, c("g",
##        "logs")))
##    .hessian &lt;- array(0, c(length(.value), 2, 2), list(NULL,
##        c("g", "logs"), c("g", "logs")))
##    .grad[, "g"] &lt;- .expr10
##    .hessian[, "g", "g"] &lt;- 2 * (.expr7 * .expr6 * .expr2 + .expr7 *
##        .expr7) * .expr4
##    .hessian[, "g", "logs"] &lt;- .hessian[, "logs", "g"] &lt;- .expr10
##    .grad[, "logs"] &lt;- .expr5
##    .hessian[, "logs", "logs"] &lt;- .expr5
##    attr(.value, "gradient") &lt;- .grad
##    attr(.value, "hessian") &lt;- .hessian
##    .value
##}
##
calcium.vd &lt;- Dvar( calcium.nl )
param( calcium.nl )
##        b0         b1          g       logs 
## 4.3160408  0.2075937  0.3300134 -3.3447585
##
attr( calcium.vd(4.32, 0.208, 0.600, -2.66 ), "gradient" )
##                g      logs
## [1,] -0.11203422 0.1834220
## [2,] -0.11203422 0.1834220
## [3,] -0.11203422 0.1834220
## [4,]  0.09324687 0.3295266
## \dots
##
detach()
</code></pre>

<hr>
<h2 id='expInfo'>
Returns the Expected Information Matrix &mdash; Generic Function
</h2><span id='topic+expInfo'></span>

<h3>Description</h3>

<p>Returns the expected information matrix from a fitted model object. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expInfo(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="expInfo_+3A_object">object</code></td>
<td>

<p>any fitted model object for which the observed information can be
calculated. 
</p>
</td></tr>
<tr><td><code id="expInfo_+3A_...">...</code></td>
<td>

<p>absorbs any additional argument.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is generic (see <code><a href="utils.html#topic+methods">methods</a></code>); method 
functions can be written to handle specific classes of data.  
Classes which already have methods for this function include: 
<code>nlreg</code>. 
</p>


<h3>Value</h3>

<p>the expected information matrix for a fitted regression model.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+expInfo.nlreg">expInfo.nlreg</a></code>, <code><a href="#topic+nlreg.object">nlreg.object</a></code>,
<code><a href="#topic+obsInfo">obsInfo</a></code> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(metsulfuron)
metsulfuron.nl &lt;- 
    nlreg( log(area) ~ log( b1+(b2-b1) / (1+(dose/b4)^b3) ),
           weights = ~ ( 1+dose^exp(g) )^2, data = metsulfuron, 
           start = c(b1 = 138, b2 = 2470, b3 = 2, b4 = 0.07, g = log(0.3)), 
           hoa = TRUE)
expInfo( metsulfuron.nl )
</code></pre>

<hr>
<h2 id='expInfo.nlreg'>
Expected Information Matrix for &lsquo;nlreg&rsquo; Objects
</h2><span id='topic+expInfo.nlreg'></span>

<h3>Description</h3>

<p>Returns the expected information matrix for a fitted <code>nlreg</code>
model. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'nlreg'
expInfo(object, par, mu, v, m1 = NULL, v1 = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="expInfo.nlreg_+3A_object">object</code></td>
<td>

<p>a fitted <code>nlreg</code> object such as returned by a call to 
<code><a href="#topic+nlreg">nlreg</a></code>.
</p>
</td></tr>
<tr><td><code id="expInfo.nlreg_+3A_par">par</code></td>
<td>

<p>a vector of parameter values where each element is named after the
parameter it represents.  If missing, the values in the 
<code>ws$allPar</code> component of <code>object</code> are used.
</p>
</td></tr>
<tr><td><code id="expInfo.nlreg_+3A_mu">mu</code></td>
<td>

<p>numerical vector containing the mean function evaluated at each 
data point.  If missing, the fitted values saved in 
<code>object</code> are used.
</p>
</td></tr>
<tr><td><code id="expInfo.nlreg_+3A_v">v</code></td>
<td>

<p>numerical vector containing the variance function evaluated at 
each data point.  If missing, the values of the <code>weights</code> 
component of <code>object</code> are used.
</p>
</td></tr>
<tr><td><code id="expInfo.nlreg_+3A_m1">m1</code></td>
<td>

<p>a matrix whose rows represent the gradients of the mean function
evaluated at each data point.  If <code>NULL</code>, the <code>gradient</code>
attribute of the object returned by a call to 
<code><a href="#topic+Dmean">Dmean</a></code> is used.   
</p>
</td></tr>
<tr><td><code id="expInfo.nlreg_+3A_v1">v1</code></td>
<td>

<p>a matrix whose rows represent the gradient of the variance 
function evaluated at each data point.  If <code>NULL</code>, the 
<code>gradient</code> attribute of the object returned  by a call to 
<code><a href="#topic+Dvar">Dvar</a></code> is used.   
</p>
</td></tr>
<tr><td><code id="expInfo.nlreg_+3A_...">...</code></td>
<td>

<p>absorbs any additional argument.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is a method for the generic function 
<code><a href="#topic+expInfo">expInfo</a></code> for objects inheriting from class 
<code>nlreg</code>.
</p>


<h3>Value</h3>

<p>the expected information matrix of the fitted nonlinear model passed
through the <code>object</code> argument.
</p>


<h3>Note</h3>

<p>This function is mostly intended for internal use.  It is called by
functions such as <code><a href="#topic+nlreg.diag">nlreg.diag</a></code>, 
<code><a href="#topic+summary.nlreg">summary.nlreg</a></code> and 
<code><a href="#topic+profile.nlreg">profile.nlreg</a></code>.  To extract the expected 
information matrix from a fitted <code>nlreg</code> object, the generic 
method <code><a href="#topic+expInfo">expInfo</a></code> should be used.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+expInfo">expInfo</a></code>, <code><a href="#topic+nlreg.object">nlreg.object</a></code>, 
<code><a href="#topic+obsInfo">obsInfo</a></code>
</p>

<hr>
<h2 id='fitted.nlreg'>
Use fitted() on a &lsquo;nlreg&rsquo; object
</h2><span id='topic+fitted.nlreg'></span>

<h3>Description</h3>

<p>This is a method for the function <code>fitted()</code> for objects 
inheriting from class <code>nlreg</code>.  See <code><a href="stats.html#topic+fitted">fitted</a></code> for the 
general behavior of this function and for the interpretation of 
<code>object</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'nlreg'
fitted(object, ...)
</code></pre>


<h3>See Also</h3>

<p><code><a href="#topic+nlreg.object">nlreg.object</a></code>, <code><a href="stats.html#topic+fitted">fitted</a></code>
</p>

<hr>
<h2 id='helicopter'>Helicopter Data</h2><span id='topic+helicopter'></span>

<h3>Description</h3>

<p>The <code>helicopter</code> data frame has 9 rows and 6 columns.
</p>
<p>Experimental design for studying the influences of the factors wing 
length and wing width on a paper helicopter's flight time.  The goal is 
to find the factor setting that maximizes flight time when the paper 
helicopter is dropped from a fixed height of 15.5 feet
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(helicopter)</code></pre>


<h3>Format</h3>

<p>A data frame with 9 observations on the following 6 variables:
</p>

<dl>
<dt><code>L</code></dt><dd>
<p>wing length in inches;
</p>
</dd> 
<dt><code>W</code></dt><dd>
<p>wing width in inches;
</p>
</dd>
<dt><code>B</code></dt><dd>
<p>base length (always set to 3in);
</p>
</dd>
<dt><code>H</code></dt><dd>
<p>base height (always set to 2in);
</p>
</dd>
<dt><code>Order</code></dt><dd>
<p>run order;
</p>
</dd>
<dt><code>Time</code></dt><dd>
<p>flight time in seconds.</p>
</dd>
</dl>



<h3>Source</h3>

<p>The data were obtained from
</p>
<p>Annis, D. H. (2006)  Rethinking the paper helicopter: Combining 
statistical and engineering knowledge.  <em>The American 
Statistician</em>, <b>59</b>, 320&ndash;326. 
</p>


<h3>References</h3>

<p>Box, G. E. P. (1992)  Teaching engineers experimental design with a
paper helicopter.  <em>Quality Engineering</em>, <b>4</b>, 453&ndash;459.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(helicopter)
##
## fit model (5) of Annis (2005)
## -----------------------------
heli &lt;- helicopter
##
heli$LW &lt;- heli$L * heli$W
heli$S &lt;- heli$B * heli$H + ( 2 * heli$L + 1 ) * heli$W
heli$logTime &lt;- log( heli$Time )
heli$Y &lt;- heli$logTime + log( heli$S ) / 2
#
heli.nlreg &lt;- nlreg( Y ~ b0 + b1 * log( b2^2 / LW + LW ), data = heli, 
                    start = c( b0 = 6, b1 = -1, b2 = 20 ) )
</code></pre>

<hr>
<h2 id='logLik.nlreg'>
Compute the Log Likelihood for Nonlinear Heteroscedastic Models
</h2><span id='topic+logLik.nlreg'></span>

<h3>Description</h3>

<p>Computes the log likelihood for a nonlinear model with possibly non
constant variance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'nlreg'
logLik(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="logLik.nlreg_+3A_object">object</code></td>
<td>

<p>an object inheriting from class <code>nlreg</code> representing a fitted
nonlinear heteroscedastic model.
</p>
</td></tr>
<tr><td><code id="logLik.nlreg_+3A_...">...</code></td>
<td>

<p>absorbs any additional argument.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a method for the function <code>logLik()</code> for objects
inheriting from class <code>nlreg</code>.  
</p>


<h3>Value</h3>

<p>Returns an object class <code>logLik</code> which is a number
with attributes <code>nobs</code>, <code>npar</code> and <code>df</code>  
giving respectively the number of observations, the number of 
parameters (regression coefficients plus variance parameters) and
the degrees of freedom in the model.  
</p>


<h3>Note</h3>

<p>The default 
<code>print</code> method for <code>logLik</code> objects is used.
</p>


<h3>See Also</h3>

<p><code><a href="marg.html#topic+rsm.object">rsm.object</a></code>, <code><a href="stats.html#topic+logLik">logLik</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(boot)
data(calcium)
calcium.nl &lt;- nlreg( cal ~ b0*(1-exp(-b1*time)), 
                     start = c(b0 = 4, b1 = 0.1), data = calcium )
logLik( calcium.nl )
##
data(metsulfuron)
metsulfuron.nl &lt;- 
    nlreg( log(area) ~ log( b1+(b2-b1) / (1+(dose/b4)^b3) ), 
           weights = ~ ( 1+dose^exp(g) )^2, data = metsulfuron, 
           start = c(b1 = 138, b2 = 2470, b3 = 2, b4 = 0.07, g = log(0.3)),
           hoa = TRUE )
logLik( metsulfuron.nl )
</code></pre>

<hr>
<h2 id='metsulfuron'>Metsulfuron Methyl Data</h2><span id='topic+metsulfuron'></span>

<h3>Description</h3>

<p>The <code>metsulfuron</code> data frame has 40 rows and 3 columns.
</p>
<p>Bioassay on the action of metsulfuron methyl, a sulfunylurea
herbicide, on a tissue culture of <em>Brassica napus L</em>.  The
experiment consists of 8 doses and 5 replications at each level. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(metsulfuron)</code></pre>


<h3>Format</h3>

<p>This data frame contains the following columns:
</p>
  
<dl>
<dt><code>group</code></dt><dd>
<p>indicator variable for each tested dose;
</p>
</dd>
<dt><code>dose</code></dt><dd>
<p>the tested dose (nmol/l);
</p>
</dd>
<dt><code>area</code></dt><dd>
<p>the callus area (<code class="reqn">mm^2</code>).
</p>
</dd>
</dl>



<h3>Source</h3>

<p>The data were obtained from
</p>
<p>Seiden, P., Kappel, D. and Streibig, J. C. (1998) Response of
<em>Brassica napus L.</em> tissue culture to metsulfuron methyl and
chlorsulfuron.  <em>Weed Research</em>, <b>38</b>, 221&ndash;228.  Dataset
M2.
</p>


<h3>References</h3>

<p>Bellio, R., Jensen, J.E. and Seiden, P. (2000).  Applications of 
likelihood asymptotics for nonlinear regression in herbicide bioassays.
<em>Biometrics</em>, <b>56</b>, 1204&ndash;1212.
</p>
<p>Brazzale, A. R. (2000) <em>Practical Small-Sample Parametric 
Inference</em>.  Ph.D. Thesis N. 2230, Department of Mathematics, Swiss
Federal Institute of Technology Lausanne.  Section 5.3, Example 7.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(metsulfuron)
attach(metsulfuron)
plot(dose, area, xlab = "tested dose (nmol/l)", 
     ylab = "log callus area (mm^2)", log = "y")
detach()
</code></pre>

<hr>
<h2 id='mpl'>
Maximum Adjusted Profile Likelihood Estimation &mdash; Generic Function   
</h2><span id='topic+mpl'></span>

<h3>Description</h3>

<p>Calculates the maximum adjusted profile likelihood estimates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mpl(fitted, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mpl_+3A_fitted">fitted</code></td>
<td>

<p>any fitted model object for which the maximum adjusted profile
likelihood estimates can be calculated.
</p>
</td></tr>
<tr><td><code id="mpl_+3A_...">...</code></td>
<td>

<p>absorbs any additional argument.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is generic (see <code><a href="utils.html#topic+methods">methods</a></code>); method 
functions can be written to handle specific classes of data.  Classes
which already have methods for this function include: <code>nlreg</code>. 
</p>


<h3>Value</h3>

<p>the maximum adjusted profile likelihood estimates for all parameters
of a regression model or for a subset of them.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mpl.nlreg">mpl.nlreg</a></code>, <code><a href="#topic+nlreg.object">nlreg.object</a></code>,
<code><a href="utils.html#topic+methods">methods</a></code> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(metsulfuron)
metsulfuron.nl &lt;- 
    nlreg( formula = log(area) ~ log( b1+(b2-b1) / (1+(dose/b4)^b3) ), 
           weights = ~ ( 1+dose^exp(g) )^2, data = metsulfuron, hoa = TRUE, 
           start = c(b1 = 138, b2 = 2470, b3 = 2, b4 = 0.07, g = log(0.3)) )
mpl( metsulfuron.nl, trace = TRUE )
##
options( object.size = 10000000 )
data(chlorsulfuron)
chlorsulfuron.nl &lt;- 
    nlreg( log(area) ~ log( b1+(b2-b1) / (1+(dose/b4)^b3) ), 
        weights = ~ ( 1+k*dose^g*(b2-b1)^2/(1+(dose/b4)^b3)^4*b3^2*dose^(2*b3-2)/
                    b4^(2*b3)/(b1+(b2-b1)/(1+(dose/b4)^b3))^2 ),
        start = c(b1 = 2.2, b2 = 1700, b3 = 2.8, b4 = 0.28, g = 2.7, k = 1), 
        data = chlorsulfuron, hoa = TRUE, trace = TRUE,  
        control = list(x.tol = 10^-12, rel.tol = 10^-12, step.min = 10^-12) )
mpl( chlorsulfuron.nl, trace = TRUE )
</code></pre>

<hr>
<h2 id='mpl.nlreg'>
Maximum Adjusted Profile Likelihood Estimates for a &lsquo;nlreg&rsquo; Object
</h2><span id='topic+mpl.nlreg'></span>

<h3>Description</h3>

<p>Calculates the maximum adjusted profile likelihood estimates of the
variance parameters for a nonlinear heteroscedastic model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'nlreg'
mpl(fitted, offset = NULL, stats = c("sk", "fr"), 
    control = list(x.tol = 1e-6, rel.tol = 1e-6, step.min = 1/2048,
    maxit = 100), trace = FALSE, ... )
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mpl.nlreg_+3A_fitted">fitted</code></td>
<td>

<p>a <code>nlreg</code> object, that is, the result of a call to 
<code><a href="#topic+nlreg">nlreg</a></code> with non-constant variance function.
</p>
</td></tr>
<tr><td><code id="mpl.nlreg_+3A_offset">offset</code></td>
<td>

<p>a numerical vector whose elements are named after the variance
parameters appearing in the nonlinear model.  These will be fixed 
to the values specified in <code>offset</code>.  The name <code>logs</code> is 
used to identify the constant term 
<code class="reqn">\log(\sigma^2)</code> which is included by default 
in the variance function (see the <code>weights</code> argument in 
<code><a href="#topic+nlreg">nlreg</a></code>).  The default is <code>NULL</code>.
</p>
</td></tr>
<tr><td><code id="mpl.nlreg_+3A_stats">stats</code></td>
<td>

<p>character value indicating which correction term to use.  
Admissible values are <code>"sk"</code> for <cite>Skovgaard's (1996)</cite> 
proposal and <code>"fr"</code> for <cite>Fraser, Reid and Wu's (1999)</cite>
approach.  The default is <code>"sk"</code>.
</p>
</td></tr>
<tr><td><code id="mpl.nlreg_+3A_control">control</code></td>
<td>

<p>a list of iteration and algorithmic constants.  See the 
<b>Details</b> section below for their definition.
</p>
</td></tr>
<tr><td><code id="mpl.nlreg_+3A_trace">trace</code></td>
<td>

<p>logical flag.  If <code>TRUE</code>, details of the iterations are 
printed. Default is <code>FALSE</code>.
</p>
</td></tr>
<tr><td><code id="mpl.nlreg_+3A_...">...</code></td>
<td>

<p>absorbs any additional argument.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>mpl.nlreg</code> routine returns nearly unbiased estimates of the
variance parameters of a nonlinear heteroscedastic regression model 
by maximizing the corresponding adjusted profile likelihood
(<cite>Barndorff-Nielsen, 1983</cite>).  More precisely, it implements two 
approximations derived from the theories developed respectively by 
<cite>Skovgaard (1996)</cite> and <cite>Fraser, Reid and Wu (1999)</cite>. The 
core algorithm alternates 
minimization of minus the adjusted profile log likelihood with 
respect to the variance parameters, and minimization of minus the 
profile log likelihood with respect to the regression coefficients.  
The first step is omitted if the <code>offset</code> argument is used in 
which case <code>mpl.nlreg</code> returns the constrained maximum 
likelihood estimates of the regression coefficients.  The 
quasi-Newton optimizer <code><a href="stats.html#topic+optim">optim</a></code> is used in both 
steps.  Starting values are retrieved from the <code>nlreg</code> object
passed through the <code>fitted</code> argument.
</p>
<p>The algorithm iterates until convergence or until the maximum number
of iterations is reached.  The stopping rule considers the relative
difference between successive estimates of the variance parameters 
and the relative increment of the adjusted profile log likelihood.  
These are governed by the parameters <code>x.tol</code> and 
<code>rel.tol</code>/<code>step.min</code>, respectively.
If the <code>offset</code> argument is used, the relative difference 
between successive estimates of the regression coefficients and the 
relative increment of the profile log likelihood are considered 
instead.  If convergence has been reached, the results are saved in 
an object of class <code>mpl</code>.  The output can be examined by 
<code><a href="base.html#topic+print">print</a></code> and <code><a href="base.html#topic+summary">summary</a></code>.
Components can be extracted using <code><a href="stats.html#topic+coef">coef</a></code> and 
<code><a href="#topic+param">param</a></code>.
</p>
<p>The theory is outlined in <cite>Brazzale (2000, Sections 3.1 and 
3.2.3)</cite>.  Details of the implementation are given in <cite>Brazzale 
(2000, Section 6.3.1)</cite>.
</p>


<h3>Value</h3>

<p>an object of class <code>mpl</code> which inherits from <code>nlreg</code>.  
See <code><a href="#topic+mpl.object">mpl.object</a></code> for details.
</p>


<h3>Side Effects</h3>

<p>If <code>trace = TRUE</code> and <code>offset = NULL</code>, the iteration number
and the corresponding adjusted profile log likelihood are printed. 
</p>


<h3>Note</h3>

<p>The argument <code>control</code> which controls the convergence criteria 
plays an important role.  Fine-tuning of this argument helps 
surrounding a well-known problem in nonlinear regression, that is,
convergence failure in cases where the likelihood and/or the adjusted 
profile likelihood are very flat.
</p>


<h3>References</h3>

<p>Barndorff-Nielsen, O. E. (1983) On a formula for the distribution of
the maximum likelihood estimator.  <em>Biometrika</em>, <b>70</b>, 
343&ndash;365.
</p>
<p>Brazzale, A. R. (2000) <em>Practical Small-Sample Parametric 
Inference</em>. Ph.D. Thesis N. 2230, Department of Mathematics, Swiss
Federal Institute of Technology Lausanne.  
</p>
<p>Fraser, D.A.S., Reid, N. and Wu, J. (1999).  A simple general formula 
for tail probabilities for frequentist and Bayesian inference. 
<em>Biometrika</em>, <b>86</b>, 249&ndash;264.
</p>
<p>Skovgaard, I.  (1996) An explicit large-deviation approximation to
one-parameter tests.  <em>Bernoulli</em>, <b>2</b>, 145&ndash;165.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mpl">mpl</a></code>, <code><a href="#topic+mpl.object">mpl.object</a></code>, 
<code><a href="#topic+nlreg.object">nlreg.object</a></code>, <code><a href="stats.html#topic+optim">optim</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(metsulfuron)
metsulfuron.nl &lt;- 
    nlreg( formula = log(area) ~ log( b1+(b2-b1) / (1+(dose/b4)^b3) ), 
           weights = ~ ( 1+dose^exp(g) )^2, data = metsulfuron, hoa = TRUE, 
          start = c(b1 = 138, b2 = 2470, b3 = 2, b4 = 0.07, g = log(0.3)) )
##
## MMPLE of the variance parameters
##
metsulfuron.mpl &lt;- mpl( metsulfuron.nl, trace = TRUE )
summary( metsulfuron.mpl, corr = FALSE )
##
## constrained MLEs of the regression coefficients  
##
metsulfuron.mpl &lt;- mpl( metsulfuron.nl, offset = metsulfuron.nl$varPar, 
                        trace = TRUE )
summary( metsulfuron.mpl, corr = FALSE )
</code></pre>

<hr>
<h2 id='mpl.object'>
Maximum Adjusted Profile Likelihood Object
</h2><span id='topic+mpl.object'></span>

<h3>Description</h3>

<p>Class of objects returned when calculating the maximum adjusted
profile likelihood estimates of the variance parameters of a 
nonlinear heteroscedastic model.
</p>


<h3>Arguments</h3>

<p>The following components must be included in a <code>mpl</code> object:
</p>
<table role = "presentation">
<tr><td><code id="mpl.object_+3A_varpar">varPar</code></td>
<td>

<p>the maximum adjusted profile likelihood estimates of the variance
parameters. 
</p>
</td></tr>
<tr><td><code id="mpl.object_+3A_coefficients">coefficients</code></td>
<td>

<p>the constrained <abbr><span class="acronym">MLE</span></abbr>s of the regression coefficients 
given the maximum adjusted profile likelihood estimates of the 
variance parameters. 
</p>
</td></tr>
<tr><td><code id="mpl.object_+3A_offset">offset</code></td>
<td>

<p>the values passed through the <code>offset</code> argument in the call 
to <code><a href="#topic+mpl.nlreg">mpl.nlreg</a></code> that generated the <code>mpl</code> 
object and to which the variance parameters were fixed.
</p>
</td></tr>
<tr><td><code id="mpl.object_+3A_varparmle">varParMLE</code></td>
<td>

<p>the <abbr><span class="acronym">MLE</span></abbr>s of the variance parameters.
</p>
</td></tr>
<tr><td><code id="mpl.object_+3A_coefmle">coefMLE</code></td>
<td>

<p>the <abbr><span class="acronym">MLE</span></abbr>s of the regression coefficients.
</p>
</td></tr>
<tr><td><code id="mpl.object_+3A_varparcov">varParCov</code></td>
<td>

<p>the (asymptotic) covariance matrix of the variance parameters, 
that is, the corresponding block in the inverse of the observed 
information matrix.
</p>
</td></tr>
<tr><td><code id="mpl.object_+3A_coefcov">coefCov</code></td>
<td>

<p>the (asymptotic) covariance matrix of the regression coefficients,
that is, the corresponding block in the inverse of the observed 
information matrix.
</p>
</td></tr>
<tr><td><code id="mpl.object_+3A_lmp">lmp</code></td>
<td>

<p>the adjusted profile log likelihood from the fit. 
</p>
</td></tr>
<tr><td><code id="mpl.object_+3A_lp">lp</code></td>
<td>

<p>the profile log likelihood from the fit. 
</p>
</td></tr>
<tr><td><code id="mpl.object_+3A_stats">stats</code></td>
<td>

<p>the indicator of which higher order solution was used.
</p>
</td></tr>
<tr><td><code id="mpl.object_+3A_formula">formula</code></td>
<td>

<p>the model formula.
</p>
</td></tr>
<tr><td><code id="mpl.object_+3A_meanfun">meanFun</code></td>
<td>

<p>the formula expression of the mean function.
</p>
</td></tr>
<tr><td><code id="mpl.object_+3A_varfun">varFun</code></td>
<td>

<p>the formula expression of the variance function.
</p>
</td></tr>
<tr><td><code id="mpl.object_+3A_data">data</code></td>
<td>

<p>a list representing a summary of the original data with the 
following components.
</p>

<dl>
<dt><code>'offset name'</code></dt><dd>
<p>the predictor variable with no duplicated value.
</p>
</dd>
<dt><code>repl</code></dt><dd>
<p>the number of replicates available for each value of the 
predictor.
</p>
</dd>
<dt><code>dupl</code></dt><dd>
<p>a vector of the same length than the predictor variable 
indicating the position of each data point in the 
<em>offset name</em> component.
</p>
</dd>
<dt><code>t1</code></dt><dd>
<p>the sum of the reponses for each design point in the
<em>offset name</em> component.
</p>
</dd> 
<dt><code>t2</code></dt><dd>
<p>the sum of the squared responses for each design point in 
the <em>offset name</em> component. 
</p>
</dd>
</dl>

</td></tr>
<tr><td><code id="mpl.object_+3A_nobs">nobs</code></td>
<td>

<p>the number of observations.
</p>
</td></tr>
<tr><td><code id="mpl.object_+3A_iter">iter</code></td>
<td>

<p>the number of interations needed for convergence; only if 
<code>offset</code> is not <code>NULL</code>.
</p>
</td></tr>
<tr><td><code id="mpl.object_+3A_call">call</code></td>
<td>

<p>an image of the call to <code>mpl.nlreg</code>, but with all the 
arguments explicitly named.
</p>
</td></tr>
<tr><td><code id="mpl.object_+3A_ws">ws</code></td>
<td>

<p>a list containing information that is used in subsequent 
calculations, that is:
</p>

<dl>
<dt><code>allPar</code></dt><dd>       
<p>the <abbr><span class="acronym">MLE</span></abbr>s of all parameters.
</p>
</dd>
<dt><code>homVar</code></dt><dd>
<p>a logical value indicating whether the variance function is 
constant.
</p>
</dd>
<dt><code>xVar</code></dt><dd>
<p>a logical value indicating whether the variance function 
depends on the predictor variable.
</p>
</dd>
<dt><code>hoa</code></dt><dd>
<p>the value of the <code>hoa</code> argument in the call that 
generated the <code>nlreg</code> object passed through the 
<code>fitted</code> argument.
</p>
</dd>
<dt><code>missingData</code></dt><dd>
<p>a logical value indicating whether the <code>data</code> 
argument was missing in the call that generated the 
<code>nlreg</code> object passed through the 
<code>fitted</code> argument.
</p>
</dd>
<dt><code>frame</code></dt><dd>
<p>the name of the data frame if specified in the call to 
<code>nlreg</code> that generated the <code>fitted</code> argument.
</p>
</dd>
<dt><code>iter</code></dt><dd>
<p>the number of iteration required until convergence (only 
for non constant variance function).
</p>
</dd> 
<dt><code>md</code></dt><dd>
<p>a function definition that returns the first two derivatives
of the mean function if <code>hoa = TRUE</code> in the function 
call that generated the <code>nlreg</code> object passed through 
the <code>fitted</code> argument.
</p>
</dd>
<dt><code>vd</code></dt><dd>
<p>a function definition that returns the first two derivatives
of the variance function if <code>hoa = TRUE</code> in the 
function call that generated the <code>nlreg</code> object passed 
through the <code>fitted</code> argument.
</p>
</dd>
</dl>

</td></tr>
</table>


<h3>Generation</h3>

<p>This class of objects is returned by the 
<code><a href="#topic+mpl.nlreg">mpl.nlreg</a></code> function.  Class <code>mpl</code> inherits
from class <code>nlreg</code>.
</p>


<h3>Methods</h3>

<p>Objects of this class have methods for the functions 
<code><a href="base.html#topic+print">print</a></code>, <code><a href="base.html#topic+summary">summary</a></code>, 
<code><a href="stats.html#topic+coef">coef</a></code> and <code><a href="#topic+param">param</a></code>.
</p>


<h3>Note</h3>

<p>The coefficients and variance parameters should be extracted by 
the generic functions of the same name, rather than by the <code>$</code> 
operator. 
</p>
<p>The <code>data</code> and <code>ws</code> components are not intended to be 
directly used by users, but rather contain information used by 
functions such as <code>summary</code>. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mpl.nlreg">mpl.nlreg</a></code>, <code><a href="#topic+mpl">mpl</a></code>, 
<code><a href="#topic+nlreg.object">nlreg.object</a></code> 
</p>

<hr>
<h2 id='nlreg'>
Fit a Nonlinear Heteroscedastic Model via Maximum Likelihood        
</h2><span id='topic+nlreg'></span>

<h3>Description</h3>

<p>Returns an object of class <code>nlreg</code> which represents a nonlinear
heteroscedastic model fit of the data obtained by maximizing the
corresponding likelihood function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nlreg(formula, weights = NULL, data = sys.frame(sys.parent()), start, 
      offset = NULL, subset = NULL, 
      control = list(x.tol = 1e-06, rel.tol = 1e-06, 
                     step.min = 1/2048, maxit = 100), trace = FALSE, 
      hoa = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nlreg_+3A_formula">formula</code></td>
<td>

<p>a formula expression as for other nonlinear regression models, of 
the form <code>response ~ f(predictor)</code> where <code>f</code> is a 
nonlinear function of the predictor involving a number of 
regression coefficients.  Only one predictor variable can be 
included in the model formula.  Missing values are not allowed.
</p>
</td></tr>
<tr><td><code id="nlreg_+3A_weights">weights</code></td>
<td>

<p>a formula expression of the form <code>~ V(predictor)</code> where 
<code>V</code> is a nonlinear variance function involving the predictor
or some transformation of it, variance parameters and/or 
regression coefficients.  The error variance <code>nlreg</code> works 
with is
</p>
<p><code>Var(error) = s^2 V(predictor)</code>
</p>
<p>where the constant term <code class="reqn">\sigma^2</code> is included by 
default and must
not be specified in the <code>weights</code> argument.  The <code>nlreg</code>
routine treats it on the logarithmic scale and assigns to it the 
parameter name <code>logs</code>.  By default, the error variance is 
assumed to be constant.
</p>
</td></tr>
<tr><td><code id="nlreg_+3A_data">data</code></td>
<td>

<p>an optional data frame in which to interpret the variables 
occurring in the model formula.  Missing values are not allowed.
</p>
</td></tr>
<tr><td><code id="nlreg_+3A_start">start</code></td>
<td>

<p>a numerical vector containing the starting values that initialize 
the iterative estimating procedure.  Each component of the vector 
must be named and represents one of the parameters included in
the mean and, if defined, variance function.  Starting values have
to be supplied for every model parameter, except for the constant
term in the variance function which is included by default in the
model.  See the <code>weights</code> argument above.
</p>
</td></tr>
<tr><td><code id="nlreg_+3A_offset">offset</code></td>
<td>

<p>a numerical vector with a single named element.  The name 
indicates the parameter of interest which will be fixed to the 
value specified.  <code>logs</code> is used to identify the constant 
term <code class="reqn">\sigma^2</code> which is included by default in the
variance function.
</p>
</td></tr>
<tr><td><code id="nlreg_+3A_subset">subset</code></td>
<td>

<p>expression saying which subset of the rows of the data should be 
used in the fit.  This can be a logical vector or a numeric vector
indicating which observation numbers are to be included.  All 
observations are included by default. 
</p>
</td></tr>
<tr><td><code id="nlreg_+3A_control">control</code></td>
<td>

<p>a list of iteration and algorithmic constants.  See the 
<b>Details</b> section below for their definition. 
</p>
</td></tr>
<tr><td><code id="nlreg_+3A_trace">trace</code></td>
<td>

<p>logical flag.  If <code>TRUE</code>, details of the iterations are 
printed.  
</p>
</td></tr>
<tr><td><code id="nlreg_+3A_hoa">hoa</code></td>
<td>

<p>logical flag.  If <code>TRUE</code>, the first and second derivatives of
the mean and, if defined, variance functions are stored in the 
fitted model object.  The default is <code>FALSE</code>. 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A nonlinear heteroscedastic model representing the relationship
between two scalar quantities is fitted.  The response is specified
on the left-hand side of the <code>formula</code> argument.  The predictor
appears in the right-hand side of the <code>formula</code> and, if 
specified, <code>weights</code> arguments.  Only one predictor variable 
can be included.  Missing values in the data are not allowed.
</p>
<p>The fitting criterion is maximum likelihood.  The core algorithm
implemented in <code>nlreg</code> alternates minimization of minus the
log likelihood with respect to the regression coefficients and the
variance parameters.  The quasi-Newton optimizer 
<code><a href="stats.html#topic+optim">optim</a></code> is used in both steps.  The constant 
term <code class="reqn">\sigma^2</code> in 
<code>Var(error) = s^2 V(predictor)</code> is included by default.  In 
order to work with a real value, 
<code class="reqn">\sigma^2</code> is estimated on the logarithmic scale, 
that is, the model is reparametrized into 
<code class="reqn">\log(\sigma^2)</code> which gives rise to the 
parameter name <code>logs</code>.  If the errors are homoscedastic, the 
second step is omitted and the algorithm switches automatically to
<code><a href="stats.html#topic+nls">nls</a></code>.  If the <code>weights</code> argument is 
omitted, homoscedasticity of the errors is assumed.
</p>
<p>Starting values for all parameters have to be passed through the
<code>start</code> argument except for <code class="reqn">\sigma^2</code> for which
the maximum likelihood estimate is available in closed form.  
Starting values should be chosen carefully in order to avoid 
convergence to a local maximum.  
</p>
<p>The algorithm iterates until convergence or until the maximum number
of iterations defined by <code>maxit</code> is reached.  The stopping rule
considers the relative difference between successive estimates and 
the relative increment of the log likelihood.  These are governed by
the parameters <code>x.tol</code> and <code>rel.tol</code>/<code>step.min</code>, 
respectively.
</p>
<p>If convergence has been reached, the results are saved in an object
of class <code>nlreg</code>.  The output can be examined by 
<code><a href="base.html#topic+print">print</a></code> and <code><a href="base.html#topic+summary">summary</a></code>.  
Components can be extracted using <code><a href="stats.html#topic+coef">coef</a></code>,
<code><a href="#topic+param">param</a></code>, <code><a href="stats.html#topic+fitted.values">fitted</a></code> 
and <code><a href="stats.html#topic+residuals">residuals</a></code>.  The model fit can be updated using
<code><a href="stats.html#topic+update">update</a></code>.  Profile plots and profile pair 
sketches are provided by <code><a href="stats.html#topic+profile">profile</a></code>, and 
<code><a href="graphics.html#topic+contour">contour</a></code>.  Diagnostic plots are obtained from
<code><a href="#topic+plot.nlreg.diag">nlreg.diag.plots</a></code> or simply 
<code><a href="graphics.html#topic+plot">plot</a></code>.
</p>
<p>The details are given in <cite>Brazzale (2000, Section 6.3.1)</cite>.
</p>


<h3>Value</h3>

<p>An object of class <code>nlreg</code> is returned which inherits from 
<code><a href="stats.html#topic+nls">nls</a></code>.  See <code><a href="#topic+nlreg.object">nlreg.object</a></code> for
details.
</p>


<h3>Side Effects</h3>

<p>If <code>trace = TRUE</code>, the iteration number and the corresponding
log likelihood are printed. 
</p>


<h3>Note</h3>

<p>The arguments <code>hoa</code> and <code>control</code> play an important role.
The first forces the algorithm to save the derivatives of the mean 
and variance functions in the fitted model object.  This is 
imperative if one wants to save execution time, especially for 
complex models.  Fine-tuning of the <code>control</code> argument which 
controls the convergence criteria helps surrounding a well-known
problem in nonlinear regression, that is, convergence failure in 
cases where the likelihood is very flat.
</p>
<p>If the errors are homoscedastic, the <code>nlreg</code> routine switches 
automatically to <code><a href="stats.html#topic+nls">nls</a></code> which, although rarely, 
dumps because of convergence problems.  To avoid this, either 
reparametrize the model (see <cite>Bates and Watts, 1988</cite>) or 
choose starting values that are more realistic.  This advice also
holds in case of convergence problems for models with non constant
variance function.  Use the 
<code>trace = TRUE</code> argument to gain insight into what goes on at 
the different iteration steps. 
</p>
<p>The <code>weights</code> argument has a different meaning than in other 
model fitting routines such as <code><a href="stats.html#topic+lm">lm</a></code> and 
<code><a href="stats.html#topic+glm">glm</a></code>.  It defines the variance function of the 
nonlinear model and not a vector of observation weights that are 
multiplied into the squared residuals. 	
</p>


<h3>References</h3>

<p>Bates, D. M. and Watts, D. G. (1988) <em>Nonlinear Regression 
Analysis and Its Applications</em>. New York: Wiley.
</p>
<p>Brazzale, A. R. (2000) <em>Practical Small-Sample Parametric 
Inference</em>.  Ph.D. Thesis N. 2230, Department of Mathematics, Swiss
Federal Institute of Technology Lausanne.  
</p>
<p>Seber, G. A. F. and Wild, C. J. (1989) <em>Nonlinear Regression</em>.
New York: Wiley.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+nlreg.object">nlreg.object</a></code>, <code><a href="stats.html#topic+nls">nls</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(boot)
data(calcium)
##
## Homoscedastic model fit
calcium.nl &lt;- nlreg( cal ~ b0*(1-exp(-b1*time)), start = c(b0 = 4, b1 = 0.1),
                     data = calcium )
##
## Heteroscedastic model fit 
calcium.nl &lt;- nlreg( cal ~ b0*(1-exp(-b1*time)), weights = ~ ( 1+time^g )^2,
                     start = c(b0 = 4, b1 = 0.1, g = 1), data = calcium, 
                     hoa = TRUE)
## or
calcium.nl &lt;- update(calcium.nl, weights = ~ (1+time^g)^2, 
                     start = c(b0 = 4, b1 = 0.1, g = 1), hoa = TRUE )
##
##
## Power-of-X (POX) variance function
##
data(metsulfuron)
metsulfuron.nl &lt;- 
    nlreg( log(area) ~ log( b1+(b2-b1) / (1+(dose/b4)^b3) ), 
           weights = ~ ( 1+dose^exp(g) )^2, data = metsulfuron, 
           start = c(b1 = 138, b2 = 2470, b3 = 2, b4 = 0.07, g = log(0.3)),
           hoa = TRUE )
##
##
## Power-of-mean (POM) variance function
##
data(ria)
ria.nl &lt;- nlreg( count ~ b1+(b2-b1) / (1+(conc/b4)^b3), 
                 weights = ~ ( b1+(b2-b1) / (1+(conc/b4)^b3) )^g, data = ria, 
                 start = c(b1 = 1.6, b2 = 20, b3 = 2, b4 = 300, g = 2),
                 hoa = TRUE, trace = TRUE )
##
##
## Error-in-variables (EIV) variance function
##
data(chlorsulfuron)
options( object.size = 10000000 )
chlorsulfuron.nl &lt;- 
    nlreg( log(area) ~ log( b1+(b2-b1) / (1+(dose/b4)^b3) ), 
        weights = ~ ( 1+k*dose^g*(b2-b1)^2/(1+(dose/b4)^b3)^4*b3^2*dose^(2*b3-2)/
                    b4^(2*b3)/(b1+(b2-b1)/(1+(dose/b4)^b3))^2 ),
        start = c(b1 = 2.2, b2 = 1700, b3 = 2.8, b4 = 0.28, g = 2.7, k = 1), 
        data = chlorsulfuron, hoa = TRUE, trace = TRUE,  
        control = list(x.tol = 10^-12, rel.tol = 10^-12, step.min = 10^-12) )
</code></pre>

<hr>
<h2 id='nlreg.contours.object'>
Contour Object for Nonlinear Heteroscedastic Models
</h2><span id='topic+nlreg.contours.object'></span>

<h3>Description</h3>

<p>Class of objects returned when creating the contour plots of a 
nonlinear heteroscedatic model.
</p>


<h3>Generation</h3>

<p>This class of objects is returned by the 
<code><a href="#topic+contour.all.nlreg.profiles">contour.all.nlreg.profiles</a></code> function.  It 
contains all elements  needed to trace the univariate and bivariate 
profile plots for a fitted nonlinear heteroscedastic model.
</p>


<h3>Methods</h3>

<p>Objects of this class must be plotted with the corresponding 
<code><a href="graphics.html#topic+plot">plot</a></code> methods.  No <code>print</code> or 
<code>summary</code> method is available.
</p>


<h3>Note</h3>

<p>The components of this object are not intended to be accessed 
directly by users.  They contain information used by the 
corresponding <code>plot</code> method.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+contour.all.nlreg.profiles">contour.all.nlreg.profiles</a></code>, 
<code><a href="#topic+plot.nlreg.contours">plot.nlreg.contours</a></code>,
<code><a href="#topic+nlreg.object">nlreg.object</a></code>
</p>

<hr>
<h2 id='nlreg.diag'>
Nonlinear Heteroscedastic Model Diagnostics
</h2><span id='topic+nlreg.diag'></span>

<h3>Description</h3>

<p>Calculates different types of residuals, influence measures and 
leverages for a nonlinear heteroscedastic model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  nlreg.diag(fitted, hoa = TRUE, infl = TRUE, trace = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nlreg.diag_+3A_fitted">fitted</code></td>
<td>

<p>a <code>nlreg</code> object, that is, the result of a call to 
<code><a href="#topic+nlreg">nlreg</a></code>.
</p>
</td></tr>
<tr><td><code id="nlreg.diag_+3A_hoa">hoa</code></td>
<td>

<p>logical value indicating whether higher order asymptotics should 
be used for calculating the regression diagnostics.  Default is 
<code>TRUE</code>.
</p>
</td></tr>
<tr><td><code id="nlreg.diag_+3A_infl">infl</code></td>
<td>

<p>logical value indicating whether influence measures should be
calculated on the basis of a leave-one-out analysis.  Default is 
<code>TRUE</code>.
</p>
</td></tr>
<tr><td><code id="nlreg.diag_+3A_trace">trace</code></td>
<td>

<p>logical value.  If <code>TRUE</code>, details of the iterations are 
printed.  Default is <code>FALSE</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The regression diagnostics implemented in the <code>nlreg.diag</code> 
routine follow two approaches.  The first exploits, where possible, 
the analogy with linear models, that is, it applies the classical 
definitions of residuals, leverages and Cook's distance after having
linearized the nonlinear model through Taylor series expansion 
(<cite>Carroll and Ruppert, 1988, Section 2.8</cite>).  The second 
approach uses the mean shift outlier model (<cite>Cook and Weisberg,
1982, Section 2.2.2</cite>), where a dummy variable is included for each 
observation at a time, the model refitted and the significance of 
the corresponding coefficient assessed.
</p>
<p>The leverages are defined in analogy to the linear case 
(<cite>Brazzale, 2000, Appendix A.2.2</cite>).  Two versions are available.
In the first case the sub-block of the inverse of the expected 
information matrix corresponding to the regression coefficients is 
used in the definition.  In the second case, this matrix is replaced 
by the inverse of <code class="reqn">M'WM</code>, where <code class="reqn">M</code> is the 
<code class="reqn">n\times p</code> matrix whose <code class="reqn">i</code>th row is the gradient 
of the mean function evaluated at the ith data point and <code class="reqn">W</code> 
is a diagonal matrix whose elements are the inverses of the variance
function evaluated at each data point.
</p>
<p>If the model is correctly specified, all residuals follow the standard
normal distribution.  The second kind of leverages described above 
are used to calculate the approximate studentized residuals, whereas 
the generalized Pearson residuals use the first kind.  The 
<code class="reqn">i</code>th generalized Pearson residual can also be obtained as the
score statistic for testing the significance of the dummy coefficient
in the mean shift outlier model for observation <code class="reqn">i</code>.  
Accordingly, the <code class="reqn">i</code>th deletion and <code class="reqn">r^*</code>-type 
residuals are defined as respectively the likelihood root and
modified likelihood root statistics (<code class="reqn">r</code> and 
<code class="reqn">r^*</code>) for the same situation (<cite>Bellio, 2000, Section 
2.6.1</cite>).
</p>
<p>Different influence measures were implemented in 
<code>nlreg.diag</code>.  If <code>infl = TRUE</code>, the global measure 
(<cite>Cook and Weisberg, 1982, Section 5.2</cite>) and two partial ones 
(<cite>Bellio, 2000, Section 2.6.2</cite>), the first measuring the 
influence of each observation on the regression coefficients and the 
second on the variance parameters, are returned.  They are calculated
through a leave-one-out analysis, where one observation at a time is 
deleted and the model refitted.  In order to avoid a further model 
fit, the constrained maximum likelihood estimates that would be 
needed are approximated by means of a Taylor series expansion 
centered at the <abbr><span class="acronym">MLE</span></abbr>s.  If <code>infl = FALSE</code>, only an 
approximation to Cook's distance, obtained from a first order Taylor 
series expansion of the partial influence measure for the regression
coefficients, is returned.
</p>
<p>A detailed account of regression diagnostics can be found in 
<cite>Davison and Snell (1991)</cite> and <cite>Davison and Tsai (1992)</cite>.  
The details and in particular the definitions of the above residuals 
and diagnostics are given in <cite>Brazzale (2000, Section 6.3.1 and 
Appendix A.2.2)</cite>.
</p>


<h3>Value</h3>

<p>Returns an object of class <code>nlreg.diag</code> with the following 
components:
</p>
<table role = "presentation">
<tr><td><code>fitted</code></td>
<td>

<p>the fitted values, that is, the mean function evaluated at each 
data point.
</p>
</td></tr>
<tr><td><code>resid</code></td>
<td>

<p>the response (or standardized) residuals from the fit.  
</p>
</td></tr>
<tr><td><code>rp</code></td>
<td>

<p>the generalized Pearson residuals from the fit.
</p>
</td></tr>
<tr><td><code>rs</code></td>
<td>

<p>the approximate studentized residuals from the fit.
</p>
</td></tr>
<tr><td><code>rj</code></td>
<td>

<p>the deletion residuals from the fit; only if <code>hoa = TRUE</code>.
</p>
</td></tr>
<tr><td><code>rsj</code></td>
<td>

<p>the <code class="reqn">r^*</code>-type residuals from the fit; only if 
<code>hoa = TRUE</code>.
</p>
</td></tr>
<tr><td><code>h</code></td>
<td>

<p>the leverages of the observations.
</p>
</td></tr>
<tr><td><code>ha</code></td>
<td>

<p>the approximate leverages of the observations.
</p>
</td></tr>
<tr><td><code>cook</code></td>
<td>

<p>an approximation to Cook's distance for the regression 
coefficients. 
</p>
</td></tr>
<tr><td><code>ld</code></td>
<td>

<p>the global influence of each observation; only for heteroscedastic
errors and if <code>infl = TRUE</code>.
</p>
</td></tr>
<tr><td><code>ld.rc</code></td>
<td>

<p>the partial influence of each observation on the estimates of the 
regression coefficients; only for heteroscedastic errors and if 
<code>infl = TRUE</code>.
</p>
</td></tr>
<tr><td><code>ld.vp</code></td>
<td>

<p>the partial influence of each observation on the estimates of the
variance parameters; only for heteroscedastic errors and if 
<code>infl = TRUE</code>.
</p>
</td></tr>
<tr><td><code>npar</code></td>
<td>

<p>the number of regression coefficients.
</p>
</td></tr>
</table>


<h3>Side Effects</h3>

<p>If <code>trace = TRUE</code>, the number of the observation currently 
considered in the mean shift outlier model or omitted in the 
leave-one-out analysis (see <b>Details</b> section above) is printed;
only if <code>hoa = TRUE</code> or <code>infl = TRUE</code>.
</p>


<h3>Acknowledgments</h3>

<p>This function is based on A. J. Canty's function 
<code><a href="boot.html#topic+glm.diag">glm.diag</a></code> contained in library <code>boot</code>.
</p>


<h3>Note</h3>

<p>The calculation of the deletion and <code class="reqn">r^*</code>-type residuals and 
of the influence measures can be time-consuming.  In the first case, 
the mean shift outlier model has to be refitted as many times as the 
total number of observations.  In the second case, the original model
is refitted the same amount of times, where one observation at a time
is deleted.  Furthermore, the definition of the <code class="reqn">r^*</code>-type 
residuals 
requires differentiation of the mean function of the mean shift 
outlier model.  These calculations can be avoided by changing the 
default setting of the arguments <code>hoa</code> and <code>infl</code> to 
<code>FALSE</code>.
</p>
<p>To obtain some of the regression diagnostics (typically those based 
on higher order statistics), the model is repeatedly refitted for 
different values of the mean shift outlier model parameter.  Although
rarely, convergence problems may occur as the starting values are 
chosen in an automatic way.  A <code><a href="base.html#topic+try">try</a></code> construct is 
used to prevent the <code>nlreg.diag</code> method from breaking down.  
Hence, the values of the diagnostics are not available where a 
convergence problem was encountered.  A warning is issued whenever 
this occurs.
</p>


<h3>References</h3>

<p>Bellio, R. (2000) <em>Likelihood Asymptotics: Applications in 
Biostatistics</em>.  Ph.D. Thesis, Department of Statistics, University 
of Padova.
</p>
<p>Brazzale, A. R. (2000) <em>Practical Small-Sample Parametric 
Inference</em>.  Ph.D. Thesis N. 2230, Department of Mathematics, Swiss 
Federal Institute of Technology Lausanne.
</p>
<p>Carroll, R. J. and Ruppert, D. (1988) <em>Transformation and 
Weighting in Regression</em>.  London: Chapman &amp; Hall.
</p>
<p>Cook, R. D. and Weisberg, S. (1982) <em>Residuals and Influence in 
Regression</em>.  New York: Chapman &amp; Hall.
</p>
<p>Davison, A. C. and Snell, E. J. (1991) Residuals and diagnostics.  
In <em>Statistical Theory and Modelling: In Honour of Sir David 
Cox</em> (eds. D. V. Hinkley, N. Reid, and E. J. Snell), 83&ndash;106.  
London: Chapman &amp; Hall.
</p>
<p>Davison, A. C. and Tsai, C.-L. (1992) Regression model diagnostics.  
<em>Int. Stat. Rev.</em>, <b>60</b>, 337&ndash;353.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.nlreg.diag">nlreg.diag.plots</a></code>, 
<code><a href="#topic+nlreg.object">nlreg.object</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(boot)
data(calcium)
calcium.nl &lt;- nlreg( cal ~ b0*(1-exp(-b1*time)), weights = ~ ( 1+time^g )^2, 
                     data=calcium, start = c(b0 = 4, b1 = 0.1, g = 1), 
                     hoa = TRUE )
##
calcium.diag &lt;- nlreg.diag( calcium.nl )
plot( calcium.diag, which = 9 )
##
calcium.diag &lt;- nlreg.diag( calcium.nl, hoa = FALSE, infl = FALSE)
plot(calcium.diag, which = 9)
## Not available
</code></pre>

<hr>
<h2 id='nlreg.object'>
Nonlinear Heteroscedastic Model Object
</h2><span id='topic+nlreg.object'></span>

<h3>Description</h3>

<p>Class of objects returned when fitting a nonlinear heteroscedastic
model.
</p>


<h3>Arguments</h3>

<p>The following components must be included in a <code>nlreg</code> object:
</p>
<table role = "presentation">
<tr><td><code id="nlreg.object_+3A_coef">coef</code></td>
<td>

<p>the <abbr><span class="acronym">MLE</span></abbr>s of the regression coefficients, that is, of 
the parameters appearing in the right-hand side of the 
<code>formula</code> argument in the call that generated the 
<code>nlreg</code> object.  
</p>
</td></tr>
<tr><td><code id="nlreg.object_+3A_varpar">varPar</code></td>
<td>

<p>the <abbr><span class="acronym">MLE</span></abbr>s of the variance parameters appearing in the 
<code>weights</code> argument of the call that generated the 
<code>nlreg</code> object.  If this argument was missing, the 
<abbr><span class="acronym">MLE</span></abbr> of <code class="reqn">\log(\sigma^2)</code>, the 
logarithm of the constant variance, is returned.
</p>
</td></tr>
<tr><td><code id="nlreg.object_+3A_offset">offset</code></td>
<td>

<p>a numerical vector with a single named element indicating the
parameter of interest and the value to which it was fixed while
fitting the nonlinear model.
</p>
</td></tr>
<tr><td><code id="nlreg.object_+3A_loglik">logLik</code></td>
<td>

<p>the log likelihood from the fit.
</p>
</td></tr>
<tr><td><code id="nlreg.object_+3A_meanfun">meanFun</code></td>
<td>

<p>the formula expression of the mean function.
</p>
</td></tr>
<tr><td><code id="nlreg.object_+3A_varfun">varFun</code></td>
<td>

<p>the formula expression of the variance function.
</p>
</td></tr>
<tr><td><code id="nlreg.object_+3A_data">data</code></td>
<td>

<p>a list representing a summary of the original data with the 
following components:
</p>

<dl>
<dt><code>'offset name'</code></dt><dd>
<p>the predictor variable with no duplicated value.
</p>
</dd>
<dt><code>repl</code></dt><dd>
<p>the number of replicates available for each value of the 
predictor.
</p>
</dd>
<dt><code>dupl</code></dt><dd>
<p>a vector of the same length than the predictor variable 
indicating the position of each data point in the 
<em>offset name</em> component.
</p>
</dd>
<dt><code>t1</code></dt><dd>
<p>the sum of the reponses for each design point in the
<em>offset name</em> component.
</p>
</dd> 
<dt><code>t2</code></dt><dd>
<p>the sum of the squared responses for each design point in 
the <em>offset name</em> component. 
</p>
</dd>
</dl>

</td></tr>
<tr><td><code id="nlreg.object_+3A_fitted">fitted</code></td>
<td>

<p>the fitted values, that is, the mean function evaluated at each 
data point.
</p>
</td></tr>
<tr><td><code id="nlreg.object_+3A_weights">weights</code></td>
<td>

<p>the variance function evaluated at each data point.
</p>
</td></tr>
<tr><td><code id="nlreg.object_+3A_residuals">residuals</code></td>
<td>

<p>the response/standardized residuals from the fit.  
</p>
</td></tr>
<tr><td><code id="nlreg.object_+3A_start">start</code></td>
<td>

<p>the starting values used to initialize the fitting routine.
</p>
</td></tr>
<tr><td><code id="nlreg.object_+3A_call">call</code></td>
<td>

<p>an image of the call to <code>nlreg</code>, but with all the arguments
explicitly named.
</p>
</td></tr>
<tr><td><code id="nlreg.object_+3A_ws">ws</code></td>
<td>

<p>a list containing information that is used in subsequent
calculations with the following components: 
</p>

<dl>
<dt><code>allPar</code></dt><dd>       
<p>the <abbr><span class="acronym">MLE</span></abbr>s of all parameters.
</p>
</dd>
<dt><code>homVar</code></dt><dd>
<p>a logical value indicating whether the variance function is 
constant.
</p>
</dd>
<dt><code>xVar</code></dt><dd>
<p>a logical value indicating whether the variance function 
depends on the predictor variable.
</p>
</dd>
<dt><code>hoa</code></dt><dd>
<p>the value of the <code>hoa</code> argument in the call that 
generated the <code>nlreg</code> object.
</p>
</dd>
<dt><code>missingData</code></dt><dd>
<p>a logical value indicating whether the <code>data</code> 
argument was missing in the call that generated the 
<code>nlreg</code> object.
</p>
</dd>
<dt><code>frame</code></dt><dd>
<p>the name of the data frame if specified in the call to 
<code>nlreg</code>.
</p>
</dd>
<dt><code>iter</code></dt><dd>
<p>the number of iteration required until convergence (only 
for non constant variance function).
</p>
</dd> 
<dt><code>md</code></dt><dd>
<p>a function definition that returns the first two derivatives
of the mean function if <code>hoa = TRUE</code> in the function 
call that generated the <code>nlreg</code> object.
</p>
</dd>
<dt><code>vd</code></dt><dd>
<p>a function definition that returns the first two derivatives
of the variance function if <code>hoa = TRUE</code> in the 
function call that generated the <code>nlreg</code> object.
</p>
</dd>
</dl>

</td></tr>
</table>


<h3>Generation</h3>

<p>This class of objects is returned by the <code><a href="#topic+nlreg">nlreg</a></code> 
function to 
represent a fitted nonlinear heteroscedastic model.  Class 
<code>nlreg</code> inherits from class <code>nls</code>, which represents a 
homoscedastic nonlinear model fit.
</p>


<h3>Methods</h3>

<p>Objects of this class have methods for the functions 
<code><a href="base.html#topic+print">print</a></code>, <code><a href="base.html#topic+summary">summary</a></code>, 
<code><a href="stats.html#topic+fitted">fitted</a></code> among others.
</p>


<h3>Note</h3>

<p>The residuals, fitted values and coefficients should be extracted by
the generic functions of the same name, rather than by the <code>$</code> 
operator. 
</p>
<p>The <code>data</code> and <code>ws</code> components are not intended to be 
directly accessed by users, but rather contain information invoked 
by functions such as <code><a href="stats.html#topic+profile">profile</a></code> and 
<code><a href="#topic+nlreg.diag">nlreg.diag</a></code>.  
</p>


<h3>See Also</h3>

<p><code><a href="#topic+nlreg">nlreg</a></code>, <code><a href="stats.html#topic+nls">nls</a></code>
</p>

<hr>
<h2 id='nlreg.profile.objects'>
Profile Objects for Nonlinear Heteroscedastic Models
</h2><span id='topic+nlreg.profile.object'></span><span id='topic+all.nlreg.profiles.object'></span>

<h3>Description</h3>

<p>Class of objects returned when profiling a nonlinear heteroscedatic 
model.
</p>


<h3>Generation</h3>

<p>These classes of objects are returned by the 
<code><a href="#topic+profile.nlreg">profile.nlreg</a></code> function.  They contain all 
elements needed to trace the profile plots and profile pair sketches
for a fitted nonlinear heteroscedastic model.
</p>


<h3>Methods</h3>

<p>Objects of these classes must be inspected or plotted with the
corresponding <code><a href="base.html#topic+summary">summary</a></code> or 
<code><a href="graphics.html#topic+plot">plot</a></code> methods.  No <code>print</code> method is 
available.
</p>


<h3>Note</h3>

<p>The components of these objects are not intended to be accessed 
directly by users.  They contain information used by the 
corresponding <code>summary</code> and <code>plot</code> methods.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+profile.nlreg">profile.nlreg</a></code>, 
<code><a href="#topic+summary.nlreg.profile">summary.nlreg.profile</a></code>, 
<code><a href="#topic+summary.all.nlreg.profiles">summary.all.nlreg.profiles</a></code>, 
<code><a href="#topic+plot.nlreg.profiles">plot.nlreg.profile</a></code>, 
<code><a href="#topic+plot.nlreg.profiles">plot.all.nlreg.profiles</a></code>, 
<code><a href="#topic+contour.all.nlreg.profiles">contour.all.nlreg.profiles</a></code>,  
<code><a href="#topic+nlreg.object">nlreg.object</a></code>
</p>

<hr>
<h2 id='obsInfo'>
Returns the Observed Information Matrix &mdash; Generic Function
</h2><span id='topic+obsInfo'></span>

<h3>Description</h3>

<p>Returns the observed information matrix from a fitted model object. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>obsInfo(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="obsInfo_+3A_object">object</code></td>
<td>

<p>any fitted model object for which the observed information matrix 
can be calculated. 
</p>
</td></tr>
<tr><td><code id="obsInfo_+3A_...">...</code></td>
<td>

<p>absorbs any additional argument.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is generic (see <code><a href="utils.html#topic+methods">methods</a></code>); method 
functions can be written to handle specific classes of data.  
Classes which already have methods for this function include: 
<code>nlreg</code>. 
</p>


<h3>Value</h3>

<p>the observed information matrix for a fitted regression model.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+obsInfo.nlreg">obsInfo.nlreg</a></code>, <code><a href="#topic+nlreg.object">nlreg.object</a></code>, 
<code><a href="#topic+expInfo">expInfo</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(metsulfuron)
metsulfuron.nl &lt;- 
    nlreg( log(area) ~ log( b1+(b2-b1) / (1+(dose/b4)^b3) ),
           weights = ~ ( 1+dose^exp(g) )^2, data = metsulfuron, 
           start = c(b1 = 138, b2 = 2470, b3 = 2, b4 = 0.07, g = log(0.3)), 
           hoa = TRUE)
obsInfo( metsulfuron.nl )
</code></pre>

<hr>
<h2 id='obsInfo.nlreg'>
Observed Information Matrix for &lsquo;nlreg&rsquo; Objects
</h2><span id='topic+obsInfo.nlreg'></span>

<h3>Description</h3>

<p>Returns the observed information matrix from a fitted <code>nlreg</code>
model. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'nlreg'
obsInfo(object, par, mu, v, m1 = NULL, m2 = NULL, v1 = NULL, 
        v2 = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="obsInfo.nlreg_+3A_object">object</code></td>
<td>

<p>a fitted <code>nlreg</code> object such as returned by a call to 
<code><a href="#topic+nlreg">nlreg</a></code>.
</p>
</td></tr>
<tr><td><code id="obsInfo.nlreg_+3A_par">par</code></td>
<td>

<p>a vector of parameter values where each element is named after the
parameter it represents.  If missing, the values in the 
<code>ws$allPar</code> component of <code>object</code> are used.
</p>
</td></tr>
<tr><td><code id="obsInfo.nlreg_+3A_mu">mu</code></td>
<td>

<p>numerical vector containing the mean function evaluated at each 
data point.  If missing, the fitted values saved in 
<code>object</code> are used.
</p>
</td></tr>
<tr><td><code id="obsInfo.nlreg_+3A_v">v</code></td>
<td>

<p>numerical vector containing the variance function evaluated at 
each data point.  If missing, the values of the <code>weights</code> 
component of <code>object</code> are used.
</p>
</td></tr>
<tr><td><code id="obsInfo.nlreg_+3A_m1">m1</code></td>
<td>

<p>a matrix whose rows represent the gradients of the mean function
evaluated at each data point.  If <code>NULL</code>, the <code>gradient</code>
attribute of the object returned by a call to 
<code><a href="#topic+Dmean">Dmean</a></code> is used.   
</p>
</td></tr>
<tr><td><code id="obsInfo.nlreg_+3A_m2">m2</code></td>
<td>

<p>a three-way array whose rows represent the Hessian of the mean 
function evaluated at each data point.  If <code>NULL</code>, the 
<code>hessian</code> attribute of the object returned by a call to 
<code><a href="#topic+Dmean">Dmean</a></code> is used.
</p>
</td></tr>
<tr><td><code id="obsInfo.nlreg_+3A_v1">v1</code></td>
<td>

<p>a matrix whose rows represent the gradient of the variance 
function evaluated at each data point.  If <code>NULL</code>, the 
<code>gradient</code> attribute of the object returned  by a call to 
<code><a href="#topic+Dvar">Dvar</a></code> is used.   
</p>
</td></tr>
<tr><td><code id="obsInfo.nlreg_+3A_v2">v2</code></td>
<td>

<p>a three-way array whose rows represent the Hessian of the variance
function evaluated at each data point.  If <code>NULL</code>, the 
<code>hessian</code> attribute of the object returned by a call to 
<code><a href="#topic+Dvar">Dvar</a></code> is used.
</p>
</td></tr>
<tr><td><code id="obsInfo.nlreg_+3A_...">...</code></td>
<td>

<p>absorbs any additional argument.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is a method for the generic function 
<code><a href="#topic+obsInfo">obsInfo</a></code> for objects inheriting from class 
<code>nlreg</code>.
</p>


<h3>Value</h3>

<p>the observed information matrix of the fitted nonlinear model passed
through the <code>object</code> argument.
</p>


<h3>Note</h3>

<p>This function is mostly intended for internal use.  It is called by
functions such as <code><a href="#topic+summary.nlreg">summary.nlreg</a></code> and
<code><a href="#topic+profile.nlreg">profile.nlreg</a></code>.  To extract the observed 
information matrix from a fitted <code>nlreg</code> object, the generic 
method <code><a href="#topic+obsInfo">obsInfo</a></code> should be used.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+obsInfo">obsInfo</a></code>, <code><a href="#topic+nlreg.object">nlreg.object</a></code>, 
<code><a href="#topic+expInfo">expInfo</a></code>
</p>

<hr>
<h2 id='param'>
Extract All Parameters from a Model &mdash; Generic Function
</h2><span id='topic+param'></span>

<h3>Description</h3>

<p>This function extracts all parameters (regression coefficients, 
variance parameters etc.) from a fitted model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>param(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="param_+3A_object">object</code></td>
<td>

<p>any fitted model object from which parameters may be extracted.
</p>
</td></tr>
<tr><td><code id="param_+3A_...">...</code></td>
<td>

<p>additional arguments like <code>digits</code> to control how many digits
should be printed.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is generic (see <code><a href="utils.html#topic+methods">methods</a></code>); method 
functions can be written to handle specific classes of data.  
Classes which already have methods for this function include: 
<code>nlreg</code>.
</p>


<h3>Value</h3>

<p>all parameters (regression coefficients, variance parameters etc.) 
of a fitted model.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+param.nlreg">param.nlreg</a></code>, <code><a href="utils.html#topic+methods">methods</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(metsulfuron)
metsulfuron.nl &lt;- 
    nlreg( log(area) ~ log( b1+(b2-b1) / (1+(dose/b4)^b3) ), 
           weights = ~( 1+dose^exp(g) )^2, data = metsulfuron, 
           start = c(b1 = 138, b2 = 2470, b3 = 2, b4 = 0.07, g = log(0.3)),
           hoa = TRUE )
param( metsulfuron.nl )
##          b1           b2           b3           b4            g         logs
## 139.0395322 2471.5097481    1.7091297    0.0772535   -1.2582597   -3.8198406
</code></pre>

<hr>
<h2 id='param.nlreg'>
Use param() on a &lsquo;nlreg&rsquo; object
</h2><span id='topic+param.nlreg'></span>

<h3>Description</h3>

<p>This is a method for the function <code>param()</code> for objects 
inheriting from class <code>nlreg</code>.  See <code><a href="#topic+param">param</a></code> 
for the general behavior of this function and for the interpretation
of <code>object</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'nlreg'
param(object, ...)
</code></pre>


<h3>See Also</h3>

<p><code><a href="#topic+nlreg.object">nlreg.object</a></code>, <code><a href="#topic+param">param</a></code>
</p>

<hr>
<h2 id='plot.nlreg.contours'>
Use plot() on a &lsquo;nlreg.contours&rsquo; object
</h2><span id='topic+plot.nlreg.contours'></span>

<h3>Description</h3>

<p>This is a method for the function <code><a href="graphics.html#topic+plot">plot</a></code> for 
objects inheriting from class <code>nlreg.contours</code>.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'nlreg.contours'
plot(x, alpha = c(0.1, 0.05), drawlabels = FALSE, lwd1 = 1, lwd2 = 1, 
     lty1 = "solid", lty2 = "solid", cl1 = "blue", cl2 = "red", 
     col = "black", pch1 = 1, pch2 = 16, cex = 0.5, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.nlreg.contours_+3A_x">x</code></td>
<td>

<p>a <code>nlreg.contours</code> object, that is, the result of a call to
<code><a href="#topic+contour.all.nlreg.profiles">contour.all.nlreg.profiles</a></code>. 
</p>
</td></tr>
<tr><td><code id="plot.nlreg.contours_+3A_alpha">alpha</code></td>
<td>

<p>a numerical vector defining the levels of the contours; the default
is <code>c(0.1, 0.05)</code>, that is, <code class="reqn">1-\alpha=0.9</code> 
and <code class="reqn">1-\alpha=0.95</code>.
</p>
</td></tr>
<tr><td><code id="plot.nlreg.contours_+3A_drawlabels">drawlabels</code></td>
<td>

<p>logical value.  Contours are labelled if <code>TRUE</code>.
</p>
</td></tr>
<tr><td><code id="plot.nlreg.contours_+3A_lwd1">lwd1</code>, <code id="plot.nlreg.contours_+3A_lwd2">lwd2</code></td>
<td>

<p>the line widths used to compare different curves in the same 
plot; default is <code>lwd2 = 2</code> for higher order solutions and 
<code>lwd1 = 1</code> for first order solutions.
</p>
</td></tr>
<tr><td><code id="plot.nlreg.contours_+3A_lty1">lty1</code>, <code id="plot.nlreg.contours_+3A_lty2">lty2</code></td>
<td>

<p>line types used to compare different curves in the same plot; 
default is <code>"solid"</code> for all statistics. 
</p>
</td></tr>
<tr><td><code id="plot.nlreg.contours_+3A_cl1">cl1</code>, <code id="plot.nlreg.contours_+3A_cl2">cl2</code>, <code id="plot.nlreg.contours_+3A_col">col</code></td>
<td>

<p>colors used to compare different curves in the same plot; default
is <code>cl2 = "red"</code> for higher order solutions, and 
<code>cl1 = "blue"</code> for the remaining first order statistics.  
The default color of the plot is <code>col = "black"</code>.
</p>
</td></tr>
<tr><td><code id="plot.nlreg.contours_+3A_pch1">pch1</code>, <code id="plot.nlreg.contours_+3A_pch2">pch2</code></td>
<td>

<p>character types used to compare different values in the same plot; 
default is <code>pch2 = 16</code> for higher order solutions, and 
<code>pch1 = 1</code> for the remaining first order statistics.  
</p>
</td></tr>
<tr><td><code id="plot.nlreg.contours_+3A_cex">cex</code></td>
<td>

<p>the character expansions relative to the standard size of the 
device to be used for printing text.  The default is 
<code>cex = 0.5</code>.
</p>
</td></tr>
<tr><td><code id="plot.nlreg.contours_+3A_...">...</code></td>
<td>

<p>additional graphics parameters.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No value is returned.
</p>


<h3>Side Effects</h3>

<p>A plot is produced on the current graphics device.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+nlreg.contours.object">nlreg.contours.object</a></code>, 
<code><a href="#topic+contour.all.nlreg.profiles">contour.all.nlreg.profiles</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(metsulfuron)
metsulfuron.nl &lt;- 
    nlreg( formula = log(area) ~ log( b1+(b2-b1) / (1+(dose/b4)^b3) ), 
           weights = ~ ( 1+dose^exp(g) )^2, data = metsulfuron, 
           start = c(b1 = 138, b2 = 2470, b3 = 2, b4 = 0.07, g = log(0.3)),
           hoa = TRUE )
##
metsulfuron.prof &lt;- profile( metsulfuron.nl, trace = TRUE )
metsulfuron.cont &lt;- contour( metsulfuron.prof, ret = TRUE, plotit = FALSE )
par( mai = rep(0.2, 4) )
plot( metsulfuron.cont )
## End(Not run)
</code></pre>

<hr>
<h2 id='plot.nlreg.diag'>
Diagnostic Plots for Nonlinear Heteroscedastic Models
</h2><span id='topic+plot.nlreg.diag'></span><span id='topic+nlreg.diag.plots'></span>

<h3>Description</h3>

<p>The <code>nlreg.diag.plots</code> routine generates diagnostic plots for a 
nonlinear heteroscedastic model using different types of residuals, 
influence measures and leverages.  This is equivalent to using the 
<code>plot.nlreg.diag</code> method for function 
<code><a href="graphics.html#topic+plot">plot</a></code> for objects inheriting from class 
<code>nlreg.diag</code>.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nlreg.diag.plots(fitted, which = "all", subset = NULL, iden = FALSE, 
                 labels = NULL, hoa = TRUE, infl = TRUE, 
                 trace = FALSE, ret = FALSE, ...)
## S3 method for class 'nlreg.diag'
plot(x, which = "all", subset = NULL, iden = FALSE, labels = NULL, 
     ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.nlreg.diag_+3A_fitted">fitted</code></td>
<td>

<p>either a <code>nlreg</code> object, that is, the result of a call to 
<code><a href="#topic+nlreg">nlreg</a></code>, or a <code>nlreg.diag</code> object obtained 
from a call to <code><a href="#topic+nlreg.diag">nlreg.diag</a></code>.
</p>
</td></tr>
<tr><td><code id="plot.nlreg.diag_+3A_x">x</code></td>
<td>

<p>a <code>nlreg.diag</code> object obtained from a call to 
<code><a href="#topic+nlreg.diag">nlreg.diag</a></code>.
</p>
</td></tr>
<tr><td><code id="plot.nlreg.diag_+3A_which">which</code></td>
<td>

<p>which plot to draw.  Admissible values are <code>2</code> to <code>9</code> 
which correspond to the choices below.  The default is 
<code>"all"</code>, which pops up a menu that lists all available plots.
</p>
</td></tr>
<tr><td><code id="plot.nlreg.diag_+3A_subset">subset</code></td>
<td>

<p>the subset of the data used in the original <code>nlreg</code> fit.  Must
be the same than the <code>subset</code> option used in the call to 
<code>nlreg</code> that generated the <code>nlreg</code> object for which the
diagnostic plots are to be drawn.  Needed only if the <code>subset</code>
option is used in the call to <code>nlreg</code>.
</p>
</td></tr>
<tr><td><code id="plot.nlreg.diag_+3A_iden">iden</code></td>
<td>

<p>logical argument.  If <code>TRUE</code>, the user will be prompted after 
the plots are drawn.  A positive integer will select a plot and 
invoke <code><a href="graphics.html#topic+identify">identify</a>()</code> on that plot.  After 
exiting <code>identify</code>, the user is again prompted, this loop 
continuing until the user responds to the prompt with <code>0</code>.  If
<code>iden</code> is <code>FALSE</code> (default) the user cannot interact with
the plots.
</p>
</td></tr>
<tr><td><code id="plot.nlreg.diag_+3A_labels">labels</code></td>
<td>

<p>a vector of labels for use with <code>identify</code> if <code>iden</code> is
<code>TRUE</code>.  If it is not supplied, the labels are derived 
from the <code>nlreg.diag</code> object argument <code>fitted</code> or 
<code>x</code>.
</p>
</td></tr>
<tr><td><code id="plot.nlreg.diag_+3A_hoa">hoa</code></td>
<td>

<p>logical value indicating whether higher order asymptotics should be
used for calculating the regression diagnostics.  Needed only if
<code>fitted</code> is a <code>nlreg</code> object.  Default is <code>TRUE</code>.
</p>
</td></tr>
<tr><td><code id="plot.nlreg.diag_+3A_infl">infl</code></td>
<td>

<p>logical value indicating whether influence measures should be
calculated on the basis of a leave-one-out analysis.  Needed only 
if <code>fitted</code> is a <code>nlreg</code> object.  Default is <code>TRUE</code>.
</p>
</td></tr>
<tr><td><code id="plot.nlreg.diag_+3A_trace">trace</code></td>
<td>

<p>logical value.  If <code>TRUE</code> details of the iterations are 
printed.  Needed only if <code>fitted</code> is a <code>nlreg</code> object.  
Default is <code>FALSE</code>.
</p>
</td></tr>
<tr><td><code id="plot.nlreg.diag_+3A_ret">ret</code></td>
<td>

<p>logical argument indicating whether the <code>nlreg.diag</code> object 
should be returned; the default is <code>FALSE</code>.
</p>
</td></tr>
<tr><td><code id="plot.nlreg.diag_+3A_...">...</code></td>
<td>

<p>additional graphics parameters.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The diagnostics required for the plots are calculated by 
<code><a href="#topic+nlreg.diag">nlreg.diag</a></code>, either by passing a 
<code>nlreg.diag</code> object or by applying <code>nlreg.diag</code> 
internally to the <code>nlreg</code> object specified through <code>fitted</code>.   
These are then used to produce the plots on the current graphics 
device.  A menu lists all possible choices.  They may be one or all 
of the following.
</p>
<pre>
 Make a plot selection (or 0 to exit)

1:plot: Summary
2:plot: Studentized residuals against fitted values
3:plot: r* residuals against fitted values
4:plot: Normal QQ-plot of studentized residuals
5:plot: Normal QQ-plot of r* residuals
6:plot: Cook statistic against h/(1-h)
7:plot: Global influence against h/(1-h)
8:plot: Cook statistic against observation number
9:plot: Influence measures against observation number

Selection:
</pre>
<p>In the normal scores plots, the dotted line represents the expected 
line if the residuals are normally distributed, that is, it is the line 
with intercept 0 and slope 1.
</p>
<p>In general, when plotting Cook's distance or the global influence
measure against the standardized leverages, there will be two dotted
lines on the plot.  The horizontal line is at 
<code class="reqn">8/(n-2p)</code>, where <code class="reqn">n</code> is the number of 
observations and <code class="reqn">p</code> is the number of regression coefficients 
estimated.  Points above this line may be points with high influence 
on the model.  The vertical line is at <code class="reqn">2p/(n-2p)</code> and
points to the right of this line have high leverage compared to the
variance of the raw residual at that point.  If all points are below
the  horizontal line or to the left of the vertical line then the 
line is not shown.
</p>
<p>Use of <code>iden = TRUE</code> is encouraged for proper exploration of 
these plots as a guide to how well the model fits the data and 
whether certain observations have an unduly large effect on parameter
estimates. 
</p>


<h3>Value</h3>

<p>If <code>ret = TRUE</code>, the <code>nlreg.diag</code> object is returned.  
Otherwise, there is no returned value.
</p>


<h3>Side Effects</h3>

<p>The current device is cleared.  If <code>iden = TRUE</code>, interactive 
identification of points is enabled.  All screens are closed, but not
cleared, on termination of the function.  
</p>


<h3>Acknowledgments</h3>

<p>This function is based on A. J. Canty's function 
<code><a href="boot.html#topic+glm.diag.plots">glm.diag.plots</a></code> contained in library <code>boot</code>.
</p>


<h3>Note</h3>

<p>Choices <code>3</code> and <code>5</code> are not available if <code>hoa = FALSE</code>
in the call to <code><a href="#topic+nlreg.diag">nlreg.diag</a></code> that generated the 
<code>x</code> argument.  
Choices <code>7</code> and <code>9</code> are not available if 
<code>infl = FALSE</code> in the same call.  Plot number <code>9</code> is 
furthermore not available if the variance function is constant.
</p>


<h3>References</h3>

<p>Brazzale, A. R. (2000) <em>Practical Small-Sample Parametric 
Inference</em>.  Ph.D. Thesis N. 2230, Department of Mathematics, Swiss 
Federal Institute of Technology Lausanne.  Section 6.3.1 and 
Appendix A.2.2.
</p>
<p>Davison, A. C. and Snell, E. J. (1991) Residuals and diagnostics.  In
<em>Statistical Theory and Modelling: In Honour of Sir David Cox</em>
(eds. D. V. Hinkley, N. Reid, and E. J. Snell), 83&ndash;106.  London:
Chapman &amp; Hall.
</p>
<p>Davison, A. C. and Tsai, C.-L. (1992) Regression model diagnostics.  
<em>Int. Stat. Rev.</em>, <b>60</b>, 337&ndash;353.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+nlreg.diag">nlreg.diag</a></code>, <code><a href="#topic+nlreg.object">nlreg.object</a></code>, 
<code><a href="graphics.html#topic+identify">identify</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(boot)
data(calcium)
calcium.nl &lt;- nlreg( cal ~ b0*(1-exp(-b1*time)), weights = ~ ( 1+time^g )^2, 
                     start = c(b0 = 4, b1 = 0.1, g = 1), data = calcium, 
                     hoa = TRUE )
##
calcium.diag &lt;- nlreg.diag( calcium.nl, trace = TRUE )
##
## menu-driven
## Not run: 
plot( calcium.diag )
##
##  Make a plot selection (or 0 to exit)
##
## 1:plot: Summary
## 2:plot: Studentized residuals against fitted values
## 3:plot: r* residuals against fitted values
## 4:plot: Normal QQ-plot of studentized residuals
## 5:plot: Normal QQ-plot of r* residuals
## 6:plot: Cook statistic against h/(1-h)
## 7:plot: Global influence against h/(1-h)
## 8:plot: Cook statistic against observation number
## 9:plot: Influence measures against observation number
##
## Selection:
## End(Not run)
##
## plot 5: Normal QQ-plot of r* residuals
plot( calcium.diag, which = 5, las = 1 )
##
nlreg.diag.plots( calcium.nl, which = 5, las = 1 )
</code></pre>

<hr>
<h2 id='plot.nlreg.profiles'>
Use plot() on a &lsquo;profile.nlreg&rsquo; and &lsquo;all.profiles.nlreg&rsquo; object
</h2><span id='topic+plot.nlreg.profile'></span><span id='topic+plot.all.nlreg.profiles'></span>

<h3>Description</h3>

<p>These are methods for the function <code>plot</code> for objects 
inheriting from class <code>"profile.nlreg"</code> or 
<code>"all.profiles.nlreg"</code> .  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'nlreg.profile'
plot(x, alpha = 0.05, add.leg = FALSE, stats = c("sk", "fr"), 
     cex = 0.7, cex.lab = 1, cex.axis = 1, cex.main = 1, lwd1 = 1, 
     lwd2 = 2, lty1 = "solid", lty2 = "solid", cl1 = "blue", 
     cl2 = "red", col = "black", ylim = c(-3,3), ...)
## S3 method for class 'all.nlreg.profiles'
plot(x, nframe, alpha = 0.05, stats = c("sk", "fr"), cex = 0.7, 
     cex.lab = 1, cex.axis = 1, cex.main = 1, lwd1 = 1, lwd2 = 2, 
     lty1 = "solid", lty2 = "solid", cl1 = "blue", cl2 = "red", 
     col = "black", ylim = c(-3,3), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.nlreg.profiles_+3A_x">x</code></td>
<td>

<p>an object of class <code>profile.nlreg</code> or 
<code>all.profiles.nlreg</code> such as generated by a call to 
<code><a href="#topic+profile.nlreg">profile.nlreg</a></code>.
</p>
</td></tr>
<tr><td><code id="plot.nlreg.profiles_+3A_nframe">nframe</code></td>
<td>

<p>the number of frames into which to split the graphics device; 
only if <code>x</code> is an <code>all.profiles.nlreg</code> object.
</p>
</td></tr>
<tr><td><code id="plot.nlreg.profiles_+3A_alpha">alpha</code></td>
<td>

<p>numeric vector with the levels used to read off confidence 
intervals; the default is 5% which corresponds to a confidence
level of <code class="reqn">1-\alpha=0.95</code>. 
</p>
</td></tr>
<tr><td><code id="plot.nlreg.profiles_+3A_stats">stats</code></td>
<td>

<p>character value indicating which higher order statistics to plot.  
Admissible values are <code>"sk"</code> for <cite>Skovgaard's (1996)</cite> 
proposal and <code>"fr"</code> for <cite>Fraser, Reid and Wu's (1999)</cite>
approach.  The default is <code>"sk"</code>.
</p>
</td></tr>
<tr><td><code id="plot.nlreg.profiles_+3A_add.leg">add.leg</code></td>
<td>

<p>logical value indicating whether a legend should be added to the 
plot; only if <code>x</code> is a <code>profile.nlreg</code> object.  The 
default is <code>FALSE</code>.
</p>
</td></tr>
<tr><td><code id="plot.nlreg.profiles_+3A_cex">cex</code>, <code id="plot.nlreg.profiles_+3A_cex.lab">cex.lab</code>, <code id="plot.nlreg.profiles_+3A_cex.axis">cex.axis</code>, <code id="plot.nlreg.profiles_+3A_cex.main">cex.main</code></td>
<td>

<p>the character expansions relative to the standard size of the 
device to be used for printing text, labels, axes and main title.
See <code><a href="graphics.html#topic+par">par</a></code> for details. 
</p>
</td></tr>
<tr><td><code id="plot.nlreg.profiles_+3A_lwd1">lwd1</code>, <code id="plot.nlreg.profiles_+3A_lwd2">lwd2</code></td>
<td>

<p>the line widths used to compare different curves in the same 
plot; default is <code>lwd2 = 2</code> for higher order solutions and 
<code>lwd1 = 1</code> for first order solutions.
</p>
</td></tr>
<tr><td><code id="plot.nlreg.profiles_+3A_lty1">lty1</code>, <code id="plot.nlreg.profiles_+3A_lty2">lty2</code></td>
<td>

<p>line types used to compare different curves in the same plot; 
default is <code>"solid"</code> for all statistics. 
</p>
</td></tr>
<tr><td><code id="plot.nlreg.profiles_+3A_cl1">cl1</code>, <code id="plot.nlreg.profiles_+3A_cl2">cl2</code>, <code id="plot.nlreg.profiles_+3A_col">col</code></td>
<td>

<p>colors used to compare different curves in the same plot; default
is <code>cl2 = "red"</code> for higher order solutions, and 
<code>cl1 = "blue"</code> for the remaining first order statistics.  
The default color of the plot is <code>col = "black"</code>.
</p>
</td></tr>
<tr><td><code id="plot.nlreg.profiles_+3A_ylim">ylim</code></td>
<td>

<p>a numerical vector with two elements defining the <code class="reqn">y</code>-axis
range; only if <code>x</code> is a <code>profile.nlreg</code> object.  
</p>
</td></tr>
<tr><td><code id="plot.nlreg.profiles_+3A_...">...</code></td>
<td>

<p>additional graphics parameters.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function defaults to:
</p>
<pre>plot.nlreg.profile(x = stop("nothing to plot"), alpha = 0.05, add.leg = FALSE, 
                   stats = c("sk", "fr"), cex = 0.7, cex.lab = 1, cex.axis = 1, 
                   cex.main = 1, lwd1 = 1, lwd2 = 2, lty1 = "solid", lty2 = "solid", 
                   cl1 = "blue", cl2 = "red", col = "black", ylim = c(-3,3), \dots)</pre>
<pre>plot.all.nlreg.profiles(x = stop("nothing to plot"), nframe, alpha = 0.05, 
                        stats = c("sk", "fr"), cex = 0.7, cex.lab = 1, cex.axis = 1, 
                        cex.main = 1, lwd1 = 1, lwd2 = 2, lty1 = "solid", lty2 = "solid", 
                        cl1 = "blue", cl2 = "red", col = "black", ylim = c(-3,3), \dots)</pre>


<h3>Value</h3>

<p>No value is returned.
</p>


<h3>Side Effects</h3>

<p>A plot is produced on the current graphics device.
</p>


<h3>References</h3>

<p>Fraser, D.A.S., Reid, N. and Wu, J. (1999).  A simple general formula 
for tail probabilities for frequentist and Bayesian inference. 
<em>Biometrika</em>, <b>86</b>, 249&ndash;264.
</p>
<p>Skovgaard, I.  (1996) An explicit large-deviation approximation to
one-parameter tests.  <em>Bernoulli</em>, <b>2</b>, 145&ndash;165.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+profile.nlreg">profile.nlreg</a></code>, 
<code><a href="#topic+nlreg.profile.objects">nlreg.profile.objects</a></code>, 
<code><a href="graphics.html#topic+plot">plot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(metsulfuron)
metsulfuron.nl &lt;- 
    nlreg( formula = log(area) ~ log( b1+(b2-b1) / (1+(dose/b4)^b3) ), 
           weights = ~ ( 1+dose^exp(g) )^2, data = metsulfuron, 
           start = c(b1 = 138, b2 = 2470, b3 = 2, b4 = 0.07, g = log(0.3)),
           hoa = TRUE)
##
metsulfuron.prof &lt;- profile( metsulfuron.nl, offset = g, trace = TRUE )
plot( metsulfuron.prof, lwd2 = 2 )
##
metsulfuron.prof &lt;- profile( metsulfuron.nl, trace = TRUE )
plot( metsulfuron.prof, lwd2 = 2, nframe = c(2,3) )
## End(Not run)
</code></pre>

<hr>
<h2 id='print.mpl'>
Use print() on a &lsquo;mpl&rsquo; object
</h2><span id='topic+print.mpl'></span>

<h3>Description</h3>

<p>This is a method for the function <code>print()</code> for objects 
inheriting from class <code>mpl</code>.  See <code><a href="base.html#topic+print">print</a></code> and
<code><a href="base.html#topic+print.default">print.default</a></code> for the general behaviour of this 
function and for the interpretation of <code>x</code> and <code>digits</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mpl'
print(x, digits, ...)
</code></pre>


<h3>Details</h3>

<p>The function defaults to:
</p>
<pre>print.mpl(x, digits = max(3, getOption("digits")-3), \dots)</pre>


<h3>See Also</h3>

<p><code><a href="#topic+mpl.object">mpl.object</a></code>, <code><a href="base.html#topic+print">print</a></code>,
<code><a href="base.html#topic+print.default">print.default</a></code> 
</p>

<hr>
<h2 id='print.nlreg'>
Use print() on a &lsquo;nlreg&rsquo; object
</h2><span id='topic+print.nlreg'></span>

<h3>Description</h3>

<p>This is a method for the function <code>print()</code> for objects inheriting from 
class <code>nlreg</code>.  See <code><a href="base.html#topic+print">print</a></code> and 
<code><a href="base.html#topic+print.default">print.default</a></code> for the general behaviour of this function 
and for the interpretation of <code>digits</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'nlreg'
print(x, digits = max(3, getOption("digits")-3), ...)
</code></pre>


<h3>Details</h3>

<p>The method defaults to:
</p>
<pre>plot.nlreg(x, digits = max(3, getOption("digits")-3), \dots)</pre>


<h3>See Also</h3>

<p><code><a href="#topic+nlreg.object">nlreg.object</a></code>, <code><a href="base.html#topic+print">print</a></code>,
<code><a href="base.html#topic+print.default">print.default</a></code>
</p>

<hr>
<h2 id='print.nlreg.contours'>
Use print() on a &lsquo;nlreg.contours&rsquo; object
</h2><span id='topic+print.nlreg.contours'></span>

<h3>Description</h3>

<p>Objects of class <code>nlreg.contours</code> have no proper 
<code><a href="base.html#topic+print">print</a></code> method.  They are plotted instead.
See <code><a href="#topic+plot.nlreg.contours">plot.nlreg.contours</a></code> for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'nlreg.contours'
print(x, alpha = c(0.1, 0.05), drawlabels = FALSE, lwd1 = 1, lwd2 = 1, 
     lty1 = "solid", lty2 = "solid", cl1 = "blue", cl2 = "red", col = "black", 
     pch1 = 1, pch2 = 16, cex = 0.5, ...)
</code></pre>


<h3>Details</h3>

<p>The function defaults to:
</p>
<pre>plot.nlreg.contours(x, alpha = c(0.1, 0.05), drawlabels = FALSE, lwd1 = 1, lwd2 = 1, 
                    lty1 = "solid", lty2 = "solid", cl1 = "blue", cl2 = "red", 
                    col = "black", pch1 = 1, pch2 = 16, cex = 0.5, \dots)</pre>


<h3>See Also</h3>

<p><code><a href="#topic+nlreg.contours.object">nlreg.contours.object</a></code>, 
<code><a href="#topic+plot.nlreg.contours">plot.nlreg.contours</a></code>
</p>

<hr>
<h2 id='print.nlreg.profiles'>
Use print() on a &lsquo;nlreg.profile&rsquo; and &lsquo;all.nlreg.profiles&rsquo; object
</h2><span id='topic+print.nlreg.profiles'></span><span id='topic+print.nlreg.profile'></span><span id='topic+print.all.nlreg.profiles'></span>

<h3>Description</h3>

<p>Objects of class <code>nlreg.profile</code> and 
<code>all.nlreg.profiles</code> have no proper <code>print</code> method.  
They are plotted instead.  See 
<code><a href="#topic+plot.nlreg.profiles">plot.nlreg.profile</a></code> and
<code><a href="#topic+plot.nlreg.profiles">plot.all.nlreg.profiles</a></code> 
for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'nlreg.profile'
print(x = stop("nothing to plot"), alpha = 0.05, add.leg = FALSE, stats = c("sk", "fr"),
     cex = 0.7, cex.lab = 1, cex.axis = 1, cex.main = 1, lwd1 = 1, lwd2 = 2, 
     lty1 = "solid", lty2 = "solid", cl1 = "blue", cl2 = "red", col = "black", 
     ylim = c(-3,3), ...)
## S3 method for class 'all.nlreg.profiles'
print(x = stop("nothing to plot"), nframe, alpha = 0.05, stats = c("sk", "fr"),
     cex = 0.7, cex.lab = 1, cex.axis = 1, cex.main = 1, lwd1 = 1, lwd2 = 2, 
     lty1 = "solid", lty2 = "solid", cl1 = "blue", cl2 = "red", col = "black", 
     ylim = c(-3,3), ...)
</code></pre>


<h3>Details</h3>

<p>The function defaults to:
</p>
<pre>plot.nlreg.profile(x = stop("nothing to plot"), alpha = 0.05, add.leg = FALSE, 
                   stats = c("sk", "fr"), cex = 0.7, cex.lab = 1, cex.axis = 1, 
                   cex.main = 1, lwd1 = 1, lwd2 = 2, lty1 = "solid", lty2 = "solid", 
                   cl1 = "blue", cl2 = "red", col = "black", ylim = c(-3,3), \dots)</pre>
<pre>plot.all.nlreg.profiles(x = stop("nothing to plot"), nframe, alpha = 0.05, 
                        stats = c("sk", "fr"), cex = 0.7, cex.lab = 1, cex.axis = 1, 
                        cex.main = 1, lwd1 = 1, lwd2 = 2, lty1 = "solid", lty2 = "solid", 
                        cl1 = "blue", cl2 = "red", col = "black", ylim = c(-3,3), \dots)</pre>


<h3>See Also</h3>

<p><code><a href="#topic+nlreg.profile.objects">nlreg.profile.objects</a></code>, 
<code><a href="#topic+plot.nlreg.profiles">plot.nlreg.profile</a></code>,
<code><a href="#topic+plot.nlreg.profiles">plot.all.nlreg.profiles</a></code>
</p>

<hr>
<h2 id='print.summary.mpl'>
Use print() on a &lsquo;summary.mpl&rsquo; object
</h2><span id='topic+print.summary.mpl'></span>

<h3>Description</h3>

<p>This is a method for the function <code>print()</code> for objects 
inheriting from class <code>summary.mpl</code>.  See 
<code><a href="base.html#topic+print">print</a></code> and <code><a href="base.html#topic+print.default">print.default</a></code> for 
the general behaviour of this function and for the interpretation of
<code>x</code> and <code>digits</code>.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'summary.mpl'
print(x, corr = FALSE, digits, ...)
</code></pre>


<h3>Details</h3>

<p>The function defaults to:
</p>
<pre>print.summary.mpl(x, corr = FALSE, 
                  digits = if(!is.null(x$digits)) x$digits 
                           else max(3, getOption("digits")-3), \dots)</pre>
<p>The <code>corr</code> argument is a logical value indicating whether the 
(asymptotic) correlation matrix of the <abbr><span class="acronym">MLE</span></abbr>s of the
regression coefficients should be printed.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+summary.mpl">summary.mpl</a></code>, <code><a href="base.html#topic+print">print</a></code>, 
<code><a href="base.html#topic+print.default">print.default</a></code>
</p>

<hr>
<h2 id='print.summary.nlreg'>
Use print() on a &lsquo;summary.nlreg&rsquo; object
</h2><span id='topic+print.summary.nlreg'></span>

<h3>Description</h3>

<p>This is a method for the function <code>print()</code> for objects 
inheriting from class <code>summary.nlreg</code>.  See 
<code><a href="base.html#topic+print">print</a></code> and <code><a href="base.html#topic+print.default">print.default</a></code> for 
the general behaviour of this function and for the interpretation of
<code>x</code>, <code>digits</code>, <code>signif.stars</code> and <code>quote</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'summary.nlreg'
print(x, digits, signif.stars, quote = TRUE, ...)
</code></pre>


<h3>Details</h3>

<p>The function defaults to:
</p>
<pre>print.summary.nlreg(x, digits = max(3, getOption("digits")-3), 
                     signif.stars = getOption("show.signif.stars"), 
                     quote = TRUE, \dots)</pre>


<h3>See Also</h3>

<p><code><a href="#topic+summary.nlreg">summary.nlreg</a></code>, <code><a href="base.html#topic+print">print</a></code>, 
<code><a href="base.html#topic+print.default">print.default</a></code>
</p>

<hr>
<h2 id='print.summary.nlreg.profiles'>
Use print() on a &lsquo;summary.nlreg.profile&rsquo; and 
&lsquo;summary.all.nlreg.profiles&rsquo; object
</h2><span id='topic+print.summary.nlreg.profiles'></span><span id='topic+print.summary.nlreg.profile'></span><span id='topic+print.summary.all.nlreg.profiles'></span>

<h3>Description</h3>

<p>This is a method for the function <code>print()</code> for objects 
inheriting from class <code>summary.nlreg.profile</code> and
<code>summary.all.nlreg.profiles</code>.  See <code><a href="base.html#topic+print">print</a></code> 
and <code><a href="base.html#topic+print.default">print.default</a></code> for the general behaviour of 
this function and for the interpretation of <code>x</code> and 
<code>digits</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'summary.nlreg.profile'
print(x, digits, ...)
## S3 method for class 'summary.all.nlreg.profiles'
print(x, digits, ...)
</code></pre>


<h3>Details</h3>

<p>The function defaults to:
</p>
<pre>print.summary.nlreg.profile(x, 
                            digits = if(!is.null(x$digits)) x$digits
                                     else max(3, getOption("digits")-3), \dots)</pre>
<pre>print.summary.all.nlreg.profiles(x, 
                                 digits = if(!is.null(x$digits)) x$digits
                                          else max(3, getOption("digits")-3), \dots)</pre>


<h3>See Also</h3>

<p><code><a href="#topic+summary.nlreg.profile">summary.nlreg.profile</a></code>,
<code><a href="#topic+summary.all.nlreg.profiles">summary.all.nlreg.profiles</a></code>,
<code><a href="base.html#topic+print">print</a></code>, <code><a href="base.html#topic+print.default">print.default</a></code>,
</p>

<hr>
<h2 id='profile.nlreg'>
Profile Method for &lsquo;nlreg&rsquo; Objects
</h2><span id='topic+profile.nlreg'></span>

<h3>Description</h3>

<p>Returns a list of elements for profiling a nonlinear heteroscedastic
model. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'nlreg'
profile(fitted, offset = "all", hoa = TRUE, precision = 6, 
        signif = 30, n = 50, omit = 0.5, trace = FALSE, md, vd, 
        all = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="profile.nlreg_+3A_fitted">fitted</code></td>
<td>

<p>a fitted <code>nlreg</code> object such as returned by a call to 
<code><a href="#topic+nlreg">nlreg</a></code>.
</p>
</td></tr>
<tr><td><code id="profile.nlreg_+3A_offset">offset</code></td>
<td>

<p>a single named element representing the parameter of interest (a
regression coefficient or a variance parameter), or <code>"all"</code> if
all parameters are to be profiled, provided that the model formula
contains more than one regression coefficient.  The constant term 
<code class="reqn">\log(\sigma^2)</code> which is included by default 
in the variance function is referred to by <code>logs</code> (see the 
<code>weights</code> argument in <code><a href="#topic+nlreg">nlreg</a></code>).  The 
default is <code>"all"</code>.
</p>
</td></tr>
<tr><td><code id="profile.nlreg_+3A_hoa">hoa</code></td>
<td>

<p>logical value indicating whether higher order statistics should be
included; the default is <code>TRUE</code>.
</p>
</td></tr>
<tr><td><code id="profile.nlreg_+3A_precision">precision</code></td>
<td>

<p>numerical value defining the maximum range of values, given by 
<abbr><span class="acronym">MLE</span></abbr> <code class="reqn">\pm</code> 
<code>precision</code><code class="reqn">*</code><abbr><span class="acronym">s.e.</span></abbr>, that are profiled.  The 
default is 6.
</p>
</td></tr>
<tr><td><code id="profile.nlreg_+3A_signif">signif</code></td>
<td>

<p>the maximum number of output points that are calculated exactly; 
the default is 30. 
</p>
</td></tr>
<tr><td><code id="profile.nlreg_+3A_n">n</code></td>
<td>

<p>the approximate number of output points produced by the spline
interpolation; the default is 50.
</p>
</td></tr>
<tr><td><code id="profile.nlreg_+3A_omit">omit</code></td>
<td>

<p>numerical value defining the range of values, given by 
<abbr><span class="acronym">MLE</span></abbr> <code class="reqn">\pm</code> <code>omit</code><code class="reqn">*</code><abbr><span class="acronym">s.e</span></abbr>, 
which is omitted in the spline interpolation of the higher order 
statistics.  The purpose is to avoid numerical instabilities around
the maximum likelihood estimate.
</p>
</td></tr>
<tr><td><code id="profile.nlreg_+3A_trace">trace</code></td>
<td>

<p>if <code>TRUE</code>, details of the iterations are printed.
</p>
</td></tr>
<tr><td><code id="profile.nlreg_+3A_md">md</code></td>
<td>

<p>a function definition that returns the first two derivatives of the
mean function; used by <code><a href="#topic+allProfiles.nlreg">allProfiles.nlreg</a></code>.  
</p>
</td></tr>
<tr><td><code id="profile.nlreg_+3A_vd">vd</code></td>
<td>

<p>a function definition that returns the first two derivatives of the
variance function; used by <code><a href="#topic+allProfiles.nlreg">allProfiles.nlreg</a></code>. 
</p>
</td></tr>
<tr><td><code id="profile.nlreg_+3A_all">all</code></td>
<td>

<p>logical switch used by <code><a href="#topic+allProfiles.nlreg">allProfiles.nlreg</a></code>.  
</p>
</td></tr>
<tr><td><code id="profile.nlreg_+3A_...">...</code></td>
<td>

<p>absorbs any additional argument.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>profile.nlreg</code> calculates all elements necessary 
for profiling a scalar parameter of interest or all model parameters.
The model formula must contain more than one regression coefficient.
</p>
<p>A classical profile plot (<cite>Bates and Watts, 1988, Section 
6.1.2</cite>) is a plot of the likelihood root statistic and of the
Wald statistic against a range of values for the interest parameter.
It provides a means to assess the accuracy of the normal 
approximation to the distribution of both statistics: the closer the 
corresponding curves are, the better the approximations.  Confidence 
intervals can easily be read off for any desired level: the 
confidence bounds identify with the values on the <code class="reqn">x</code>-axis at 
which the
curves intersect the horizontal lines representing the standard 
normal quantiles of the desired level.
</p>
<p>Profiling is performed by updating a fitted nonlinear heteroscedastic
model.  All statistics are calculated exactly for at maximum
<code>signif</code> equally spaced points distributed around the 
<abbr><span class="acronym">MLE</span></abbr>.  To save execution time, the iterations start with a 
value close to the <abbr><span class="acronym">MLE</span></abbr> and proceed in the two directions 
<abbr><span class="acronym">MLE</span></abbr> <code class="reqn">\pm</code> <code class="reqn">\delta</code>, until the 
absolute value of all statistics exceeds the threshold 2.4.  The 
step size <code class="reqn">\delta</code> is defined by the <code>signif</code> 
argument.  A spline interpolation is used to extend them over the 
whole interval of interest.  A range of values, defined by the 
<code>omit</code> argument is omitted to avoid numerical instabilities 
around the <abbr><span class="acronym">MLE</span></abbr>.  All results are stored in an  object of
class <code>nlreg.profile</code> or <code>all.nlreg.profiles</code> depending on 
the value assumed by the <code>offset</code> argument.  The 
<code><a href="base.html#topic+summary">summary</a></code> and <code><a href="graphics.html#topic+plot">plot</a></code> method 
functions must be used to examine the output or represent it 
graphically.  No <code>print</code> method is available.
</p>
<p>If <code>hoa = TRUE</code>, <code>profile.nlreg</code> produces an enhanced
version of the classical profile plots by including the third order
modified likelihood root statistic <code class="reqn">r^*</code>.  More
precisely, it implements two approximations to
<cite>Barndorff-Nielsens's (1991)</cite> original formulation where the
sample space derivatives are replaced by respectively the
approximations proposed in <cite>Skovgaard (1996)</cite> and <cite>Fraser, 
Reid and Wu (1999)</cite>.  The idea is to provide insight into the behaviour 
of first order methods, such as detecting possible bias of the estimates 
or the influence of the model curvature.
</p>
<p>The theory and statistics used are summarized in <cite>Brazzale 
(2000, Chapters 2 and 3)</cite>.  More details of the implementation are 
given in <cite>Brazzale (1999; 2000, Section 6.3.2)</cite>.
</p>


<h3>Value</h3>

<p>a list of elements of class <code>nlreg.profile</code> or, if 
<code>offset = "all"</code>, of class <code>all.nlreg.profiles</code> for 
profiling a nonlinear heteroscedastic model.  The 
<code>nlreg.profile</code> class considers a scalar parameter of interest,
while the <code>all.nlreg.profiles</code> class ontains the profiles of all
parameters &ndash; regression coefficients and variance parameters.
</p>


<h3>Side Effects</h3>

<p>If <code>trace = TRUE</code>, the parameter which is currently profiled and
the corresponding value are printed.
</p>


<h3>Note</h3>

<p><code>profile.nlreg</code> is a method for the generic function 
<code><a href="stats.html#topic+profile">profile</a></code> for class <code>nlreg</code>.  It can be 
invoked by calling <code>profile</code> for an object of the 
appropriate class, or directly by calling <code>profile.nlreg</code>.  
</p>
<p>To obtain the profiles of the different statistics considered, the 
model is refitted several times while keeping the value of the 
parameter of interest fixed.  Although rarely, convergence problems 
may occur as the starting values are chosen in an automatic way.  A 
<code><a href="base.html#topic+try">try</a></code> construct is used to prevent the 
<code>profile.nlreg</code> method from breaking down.  Hence, the values 
of the statistics are not available where a convergence problem was 
encountered.  A warning is issued whenever this occurs.  
</p>


<h3>References</h3>

<p>Barndorff-Nielsen, O. E. (1991) Modified signed log likelihood ratio.
<em>Biometrika</em>, <b>78</b>, 557&ndash;564.
</p>
<p>Bates, D. M. and Watts, D. G. (1988) <em>Nonlinear Regression 
Analysis and Its Applications</em>.  New York: Wiley.
</p>
<p>Brazzale, A. R. (2000) <em>Practical Small-Sample Parametric 
Inference</em>.  Ph.D. Thesis N. 2230, Department of Mathematics, Swiss 
Federal Institute of Technology Lausanne.
</p>
<p>Fraser, D.A.S., Reid, N. and Wu, J. (1999).  A simple general formula 
for tail probabilities for frequentist and Bayesian inference. 
<em>Biometrika</em>, <b>86</b>, 249&ndash;264.
</p>
<p>Skovgaard, I.  (1996) An explicit large-deviation approximation to
one-parameter tests.  <em>Bernoulli</em>, <b>2</b>, 145&ndash;165.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+nlreg.profile.object">nlreg.profile.object</a></code>, 
<code><a href="#topic+all.nlreg.profiles.object">all.nlreg.profiles.object</a></code>,
<code><a href="stats.html#topic+profile">profile</a></code> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(metsulfuron)
metsulfuron.nl &lt;- 
    nlreg( formula = log(area) ~ log( b1+(b2-b1) / (1+(dose/b4)^b3) ), 
           weights = ~ ( 1+dose^exp(g) )^2, data = metsulfuron, 
           start = c(b1 = 138, b2 = 2470, b3 = 2, b4 = 0.07, g = log(0.3)),
           hoa = TRUE )
##
metsulfuron.prof &lt;- profile( metsulfuron.nl, offset = g, trace = TRUE )
plot( metsulfuron.prof, lwd2 = 2 )
#
metsulfuron.prof &lt;- profile( metsulfuron.nl, trace = TRUE )
plot( metsulfuron.prof, nframe = c(2,3), lwd2 = 2 )
## End(Not run)
</code></pre>

<hr>
<h2 id='qStheta'>
Support for &lsquo;nlreg&rsquo; package of &lsquo;hoa&rsquo; bundle
</h2><span id='topic+qhat.nlreg'></span><span id='topic+Shat.nlreg'></span><span id='topic+theta.deriv'></span>

<h3>Description</h3>

<p>Support routines for various functions in <code>nlreg</code>
package
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qhat.nlreg(nlregObj1, nlregObj0, par.1, par.0, mu.1, mu.0, v.1, v.0, 
           m1.1 = NULL, v1.1 = NULL)
Shat.nlreg(nlregObj1, nlregObj0, par.1, par.0, mu.1, mu.0, v.1, v.0, 
           m1.1 = NULL, m1.0 = NULL, v1.1 = NULL, v1.0 = NULL)
theta.deriv(nlregObj, par, mu, v, m1 = NULL, v1 = NULL)
</code></pre>


<h3>Details</h3>

<p><code>qhat.nlreg</code> and <code>Shat.nlreg</code> are support routines for 
<code><a href="#topic+nlreg.diag">nlreg.diag</a></code>, <code><a href="#topic+profile.nlreg">profile.nlreg</a></code>
and, the latter, <code><a href="#topic+mpl.nlreg">mpl.nlreg</a></code>, and should not be
used on their own.  
</p>
<p><code>theta.deriv</code> is a support routine for 
<code><a href="#topic+expInfo.nlreg">expInfo.nlreg</a></code>, <code>qhat.nlreg</code> and 
<code>Shat.nlreg</code>, and should not be used on its own.
</p>

<hr>
<h2 id='residuals.nlreg'>
Use residuals() on a &lsquo;nlreg&rsquo; object
</h2><span id='topic+residuals.nlreg'></span><span id='topic+resid.nlreg'></span>

<h3>Description</h3>

<p>This is a method for the function <code>residuals()</code> for objects 
inheriting from class <code>nlreg</code>.  It extracts the standardized
residuals from a nonlinear model fit.  See <code><a href="stats.html#topic+residuals">residuals</a></code> for
the general behavior of this function and for the interpretation of
<code>object</code>.  A wider choice of residuals is available through the
<code><a href="#topic+nlreg.diag">nlreg.diag</a></code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'nlreg'
residuals(object, ...)
## S3 method for class 'nlreg'
resid(object, ...)
</code></pre>


<h3>See Also</h3>

<p><code><a href="#topic+nlreg.object">nlreg.object</a></code>, <code><a href="#topic+nlreg.diag">nlreg.diag</a></code>, 
<code><a href="stats.html#topic+residuals">residuals</a></code>
</p>

<hr>
<h2 id='ria'>Radioimmunoassay Data</h2><span id='topic+ria'></span>

<h3>Description</h3>

<p>The <code>ria</code> data frame has 16 rows and 2 columns.
</p>
<p>Run of a radioimmunoassay (<abbr><span class="acronym">RIA</span></abbr>) to estimate the 
concentrations of a drug in samples of porcine serum.  The 
experiment consists of 16 observations made at 8 different drug 
levels with two replications at each level.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(ria)</code></pre>


<h3>Format</h3>

<p>This data frame contains the following columns:
</p>

<dl>
<dt><code>conc</code></dt><dd>
<p>the drug concentration (ng/ml);
</p>
</dd>
<dt><code>count</code></dt><dd>
<p>the observed percentage of radioactive gamma counts.
</p>
</dd>
</dl>



<h3>Source</h3>

<p>The data were obtained from
</p>
<p>Belanger, B. A., Davidian, M. and Giltinan, D. M. (1996) The effect
of variance function estimation on nonlinear calibration inference 
in immunoassay data.  <em>Biometrics</em>, <b>52</b>, 158&ndash;175.  
Table 1, first two columns.
</p>


<h3>References</h3>

<p>Brazzale, A. R. (2000) <em>Practical Small-Sample Parametric 
Inference</em>.  Ph.D. Thesis N. 2230, Department of Mathematics, Swiss 
Federal Institute of Technology Lausanne.  Section 5.3, Example 6.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ria)
attach(ria)
plot(conc, count, xlab="drug concentration (ng/ml)", ylab="gamma counts (%)")
detach()
</code></pre>

<hr>
<h2 id='summary.all.nlreg.profiles'>
Summary Method for Objects of Class &lsquo;all.nlreg.profiles&rsquo;
</h2><span id='topic+summary.all.nlreg.profiles'></span>

<h3>Description</h3>

<p>Returns a summary list for objects of class 
<code>all.nlreg.profiles</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'all.nlreg.profiles'
summary(object, alpha = 0.05, twoside = TRUE, digits = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.all.nlreg.profiles_+3A_object">object</code></td>
<td>

<p>an <code>all.nlreg.profiles</code> object, that is, the result from a call 
to <code><a href="#topic+profile.nlreg">profile.nlreg</a></code> with <code>offset = "all"</code>.
</p>
</td></tr>
<tr><td><code id="summary.all.nlreg.profiles_+3A_alpha">alpha</code></td>
<td>

<p>a vector of levels for confidence intervals; the default is 95%, 
that is, <code class="reqn">1-\alpha = 0.95</code>.
</p>
</td></tr>
<tr><td><code id="summary.all.nlreg.profiles_+3A_twoside">twoside</code></td>
<td>

<p>a logical value.  If <code>TRUE</code>, two-sided confidence intervals 
are returned.  The default is <code>TRUE</code>.
</p>
</td></tr>
<tr><td><code id="summary.all.nlreg.profiles_+3A_digits">digits</code></td>
<td>

<p>the number of significant digits to be printed.
</p>
</td></tr>
<tr><td><code id="summary.all.nlreg.profiles_+3A_...">...</code></td>
<td>

<p>absorbs any additional argument.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is a method for the generic function 
<code><a href="base.html#topic+summary">summary</a></code> for objects of class 
<code>all.nlreg.profiles</code>.  It can be invoked by calling 
<code>summary</code> or directly <code>summary.all.nlreg.profiles</code> for an 
object of the appropriate class.
</p>


<h3>Value</h3>

<p>A list is returned where the first components are named after the
parameters of the nonlinear model that was profiled.  Each component
represents a matrix with 
<code class="reqn">k\dim(\code{alpha})</code> rows and 2 columns, 
where <code class="reqn">k</code> equals 2 or 4 depending on whether 
<code>hoa = TRUE</code> in the call that generated the 
<code>nlreg.profile</code> object. This matrix contains the upper and lower 
confidence bounds for the test statistics considered and for the
confidence levels defined through <code>alpha</code>.  The remaining 
components are the following:
</p>
<table role = "presentation">
<tr><td><code>mle</code></td>
<td>

<p>a <code class="reqn">2\times d</code> matrix containing the <abbr><span class="acronym">MLE</span></abbr>s and
<abbr><span class="acronym">s.e.</span></abbr>s of the <code class="reqn">d</code> parameters.
</p>
</td></tr>
<tr><td><code>offset</code></td>
<td>

<p>a vector of character strings returning the parameter names.
</p>
</td></tr>
<tr><td><code>twoside</code></td>
<td>

<p>a logical value indicating whether two-sided or one-sided 
confidence intervals were calculated.
</p>
</td></tr>
<tr><td><code>hoa</code></td>
<td>

<p>a logical value indicating whether higher order solutions were
calculated.
</p>
</td></tr>
<tr><td><code>digits</code></td>
<td>

<p>the number of significant digits to be printed.
</p>
</td></tr>
<tr><td><code>call</code></td>
<td>

<p>an image of the call that produced the object, but with all 
arguments named. 
</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+nlreg.profile.objects">nlreg.profile.objects</a></code>, 
<code><a href="#topic+profile.nlreg">profile.nlreg</a></code>, <code><a href="base.html#topic+summary">summary</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(metsulfuron)
metsulfuron.nl &lt;- 
    nlreg( formula = log(area) ~ log( b1+(b2-b1) / (1+(dose/b4)^b3) ), 
           weights = ~ ( 1+dose^exp(g) )^2, data = metsulfuron, 
           start = c(b1 = 138, b2 = 2470, b3 = 2, b4 = 0.07, g = log(0.3)),
           hoa = TRUE )
##
metsulfuron.prof &lt;- profile( metsulfuron.nl, trace = TRUE )
summary( metsulfuron.prof, alpha = c(0.1, 0.05) )
## End(Not run)
</code></pre>

<hr>
<h2 id='summary.mpl'>
Summary Method for &lsquo;mpl&rsquo; Objects
</h2><span id='topic+summary.mpl'></span>

<h3>Description</h3>

<p>Returns a summary list for objects of class <code>mpl</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mpl'
summary(object, correlation = FALSE, digits = NULL, ...)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.mpl_+3A_object">object</code></td>
<td>

<p>a fitted <code>mpl</code> object, that is, the result of a call to 
<code><a href="#topic+mpl.nlreg">mpl.nlreg</a></code>. 
</p>
</td></tr>
<tr><td><code id="summary.mpl_+3A_correlation">correlation</code></td>
<td>

<p>logical argument.  If <code>TRUE</code>, the (asymptotic) correlation 
matrix for the 
parameter estimates is computed; default is <code>FALSE</code>.
</p>
</td></tr>
<tr><td><code id="summary.mpl_+3A_digits">digits</code></td>
<td>

<p>the number of significant digits to be printed.  Defaults to 
<code>NULL</code>. 
</p>
</td></tr>
<tr><td><code id="summary.mpl_+3A_...">...</code></td>
<td>

<p>absorbs any additional argument.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is a method for the generic function 
<code><a href="base.html#topic+summary">summary</a></code> for
class <code>mpl</code>. It can be invoked by calling <code>summary</code> for an 
object of the appropriate class, or directly by calling 
<code>summary.mpl</code> regardless of the class of the object.
</p>


<h3>Value</h3>

<p>A list is returned with the following components:
</p>
<table role = "presentation">
<tr><td><code>varPar</code></td>
<td>

<p>the maximum adjusted profile likelihood estimates of the variance
parameters. 
</p>
</td></tr>
<tr><td><code>coefficients</code></td>
<td>

<p>the constrained <abbr><span class="acronym">MLE</span></abbr>s of the regression coefficients 
given the maximum adjusted profile likelihood estimates of the 
variance parameters. 
</p>
</td></tr>
<tr><td><code>offset</code></td>
<td>

<p>the values passed through the <code>offset</code> argument in the call 
to <code><a href="#topic+mpl.nlreg">mpl.nlreg</a></code> that generated the <code>mpl</code> 
object and to which the variance parameters were fixed.
</p>
</td></tr>
<tr><td><code>varParMLE</code></td>
<td>

<p>the <abbr><span class="acronym">MLE</span></abbr>s of the variance parameters.
</p>
</td></tr>
<tr><td><code>coefMLE</code></td>
<td>

<p>the <abbr><span class="acronym">MLE</span></abbr>s of the regression coefficients.
</p>
</td></tr>
<tr><td><code>varParCov</code></td>
<td>

<p>the (asymptotic) covariance matrix of the variance parameters, 
that is, the corresponding block in the inverse of the observed 
information matrix.
</p>
</td></tr>
<tr><td><code>coefCov</code></td>
<td>

<p>the (asymptotic) covariance matrix of the regression coefficients,
that is, the corresponding block in the inverse of the observed 
information matrix.
</p>
</td></tr>
<tr><td><code>lmp</code></td>
<td>

<p>the adjusted profile log likelihood from the fit. 
</p>
</td></tr>
<tr><td><code>lp</code></td>
<td>

<p>the profile log likelihood from the fit. 
</p>
</td></tr>
<tr><td><code>stats</code></td>
<td>

<p>the indicator of which higher order solution was used.
</p>
</td></tr>
<tr><td><code>formula</code></td>
<td>

<p>the model formula.
</p>
</td></tr>
<tr><td><code>meanFun</code></td>
<td>

<p>the formula expression of the mean function.
</p>
</td></tr>
<tr><td><code>varFun</code></td>
<td>

<p>the formula expression of the variance function.
</p>
</td></tr>
<tr><td><code>data</code></td>
<td>

<p>a list representing a summary of the original data with the 
following components.
</p>

<dl>
<dt><code>'offset name'</code></dt><dd>
<p>the predictor variable with no duplicated value.
</p>
</dd>
<dt><code>repl</code></dt><dd>
<p>the number of replicates available for each value of the 
predictor.
</p>
</dd>
<dt><code>dupl</code></dt><dd>
<p>a vector of the same length than the predictor variable 
indicating the position of each data point in the 
<em>offset name</em> component.
</p>
</dd>
<dt><code>t1</code></dt><dd>
<p>the sum of the reponses for each design point in the
<em>offset name</em> component.
</p>
</dd> 
<dt><code>t2</code></dt><dd>
<p>the sum of the squared responses for each design point in 
the <em>offset name</em> component. 
</p>
</dd>
</dl>

</td></tr>
<tr><td><code>nobs</code></td>
<td>

<p>the number of observations.
</p>
</td></tr>
<tr><td><code>iter</code></td>
<td>

<p>the number of interations needed for convergence; only if 
<code>offset</code> was not <code>NULL</code> in the call to 
<code><a href="#topic+mpl.nlreg">mpl.nlreg</a></code> which generated <code>object</code>.
</p>
</td></tr>
<tr><td><code>call</code></td>
<td>

<p>an image of the call to <code><a href="#topic+mpl.nlreg">mpl.nlreg</a></code>, but with 
all the arguments explicitly named.
</p>
</td></tr>
<tr><td><code>ws</code></td>
<td>

<p>the workspace component of the original 
<code><a href="#topic+nlreg.object">nlreg object</a></code> plus the following 
components:
</p>

<dl>
<dt><code>corr</code></dt><dd>
<p>a logical value indicating whether the correlation matrix
should be printed.
</p>
</dd>
<dt><code>digits</code></dt><dd>
<p>the number of significant digits to be printed.
</p>
</dd>
</dl>

</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+mpl.object">mpl.object</a></code>, <code><a href="#topic+nlreg.object">nlreg.object</a></code>,
<code><a href="base.html#topic+summary">summary</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(metsulfuron)
metsulfuron.nl &lt;- 
    nlreg( formula = log(area) ~ log( b1+(b2-b1) / (1+(dose/b4)^b3) ), 
           weights = ~ ( 1+dose^exp(g) )^2, data = metsulfuron, hoa = TRUE, 
           start = c(b1 = 138, b2 = 2470, b3 = 2, b4 = 0.07, g = log(0.3)) )
##
metsulfuron.mpl &lt;- mpl( metsulfuron.nl, trace = TRUE )
summary( metsulfuron.mpl, corr = FALSE )
</code></pre>

<hr>
<h2 id='summary.nlreg'>
Summary Method for Nonlinear Heteroscedastic Models
</h2><span id='topic+summary.nlreg'></span>

<h3>Description</h3>

<p>Returns a summary list for a fitted nonlinear heteroscedastic model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'nlreg'
summary(object, observed = TRUE, correlation = FALSE, 
        digits = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.nlreg_+3A_object">object</code></td>
<td>

<p>a fitted <code>nlreg</code> object.  This is assumed to be the result of
some fit that produces an object inheriting from the class 
<code>nlreg</code>, in the sense that the components returned by the 
<code><a href="#topic+nlreg">nlreg</a></code> function will be available.
</p>
</td></tr>
<tr><td><code id="summary.nlreg_+3A_observed">observed</code></td>
<td>

<p>logical argument.  If <code>TRUE</code>, the observed information is 
used to calculate the covariance matrix, the expected information
otherwise.  The default is <code>TRUE</code>.
</p>
</td></tr>
<tr><td><code id="summary.nlreg_+3A_correlation">correlation</code></td>
<td>

<p>logical argument.  If <code>TRUE</code>, the correlation matrix for the 
parameter estimates is computed; default is <code>TRUE</code>.
</p>
</td></tr>
<tr><td><code id="summary.nlreg_+3A_digits">digits</code></td>
<td>

<p>the number of significant digits to be printed.
</p>
</td></tr>
<tr><td><code id="summary.nlreg_+3A_...">...</code></td>
<td>

<p>absorbs any additional argument.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is a method for the generic function 
<code><a href="base.html#topic+summary">summary</a></code> for class <code>nlreg</code>. It can be 
invoked by calling <code>summary</code> for an object of the appropriate 
class, or directly by calling <code>summary.nlreg</code> regardless of
the class of the object.
</p>


<h3>Value</h3>

<p>A list is returned with the following components:
</p>
<table role = "presentation">
<tr><td><code>coefficients</code></td>
<td>

<p>a matrix with four columns, containing the <abbr><span class="acronym">MLE</span></abbr>s of the
regression coefficients, their standard errors, the 
<code class="reqn">z</code>-value (or Wald statistic) and the associated 
<code class="reqn">p</code>-value based on the standard normal approximation to 
the distribution of the <code class="reqn">z</code> statistic.
</p>
</td></tr>
<tr><td><code>varPar</code></td>
<td>

<p>a matrix with two columns, containing the <abbr><span class="acronym">MLE</span></abbr>s of the 
variance parameters and their standard errors.
</p>
</td></tr>
<tr><td><code>offset</code></td>
<td>

<p>a numerical vector with a single named element indicating the
parameter of interest and the value to which it was fixed while
fitting the nonlinear model.
</p>
</td></tr>
<tr><td><code>residuals</code></td>
<td>

<p>the response residuals from the fit.  
</p>
</td></tr>
<tr><td><code>covariance</code></td>
<td>

<p>the (asymptotic) covariance matrix for the parameter estimates.
</p>
</td></tr>
<tr><td><code>correlation</code></td>
<td>

<p>the (asymptotic) correlation matrix for the parameter estimates.
</p>
</td></tr>
<tr><td><code>logLik</code></td>
<td>

<p>the log likelihood from the fit.
</p>
</td></tr>
<tr><td><code>call</code></td>
<td>

<p>an image of the call that produced the <code>nlreg</code> object, but 
with the arguments all named.
</p>
</td></tr>
<tr><td><code>digits</code></td>
<td>

<p>then number of significant digits to be printed.
</p>
</td></tr>
<tr><td><code>ws</code></td>
<td>

<p>the <code>ws</code> component of the <code>nlreg</code> object.
</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+nlreg.object">nlreg.object</a></code>, <code><a href="base.html#topic+summary">summary</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(metsulfuron)
metsulfuron.nl &lt;- 
    nlreg( formula = log(area) ~ log( b1+(b2-b1) / (1+(dose/b4)^b3) ), 
           weights = ~ ( 1+dose^exp(g) )^2, data = metsulfuron, 
           start = c(b1 = 138, b2 = 2470, b3 = 2, b4 = 0.07, g = log(0.3)),
           hoa = TRUE )
##
summary( metsulfuron.nl, digits = 3 )
##
print( summary( metsulfuron.nl )$cov, digits = 3 )
print( summary( metsulfuron.nl, observed = FALSE )$cov, digits = 3 )
</code></pre>

<hr>
<h2 id='summary.nlreg.profile'>
Summary Method for Objects of Class &lsquo;nlreg.profile&rsquo;
</h2><span id='topic+summary.nlreg.profile'></span>

<h3>Description</h3>

<p>Returns a summary list for objects of class <code>nlreg.profile</code>. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'nlreg.profile'
summary(object, alpha = 0.05, twoside = TRUE, digits = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.nlreg.profile_+3A_object">object</code></td>
<td>

<p>a <code>nlreg.profile</code> object, that is, the result of a call to 
<code><a href="#topic+profile.nlreg">profile.nlreg</a></code>.
</p>
</td></tr>
<tr><td><code id="summary.nlreg.profile_+3A_alpha">alpha</code></td>
<td>

<p>a vector of levels for confidence intervals; the default is 
<code class="reqn">1-\alpha=0.95</code>.
</p>
</td></tr>
<tr><td><code id="summary.nlreg.profile_+3A_twoside">twoside</code></td>
<td>

<p>a logical value.  If <code>TRUE</code>, two-sided confidence intervals
are returned.  The default is <code>TRUE</code>.
</p>
</td></tr>
<tr><td><code id="summary.nlreg.profile_+3A_digits">digits</code></td>
<td>

<p>the number of significant digits to be printed.
</p>
</td></tr>
<tr><td><code id="summary.nlreg.profile_+3A_...">...</code></td>
<td>

<p>absorbs any additional argument.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is a method for the generic function 
<code><a href="base.html#topic+summary">summary</a></code> for objects of class 
<code>nlreg.profile</code>.  It can be invoked by calling <code>summary</code> 
or directly <code>summary.nlreg.profile</code> for an object of the
appropriate class.
</p>


<h3>Value</h3>

<p>A list is returned with the following components:
</p>
<table role = "presentation">
<tr><td><code>CI</code></td>
<td>

<p>a matrix with <code class="reqn">k\dim(\code{alpha})</code> rows 
and 2 columns, where <code class="reqn">k</code> equals 2 or 4 depending on whether
<code>hoa = TRUE</code> in the call that generated <code>object</code>.  This
matrix contains the upper and lower confidence bounds for the 
considered test statistics and for the confidence levels specified
through <code>alpha</code>.
</p>
</td></tr>
<tr><td><code>inf.sk</code>, <code>np.sk</code>, <code>inf.fr</code>, <code>np.fr</code></td>
<td>

<p>the information and nuisance parameters aspects, that is, the two 
terms into which the higher order adjustment leading to the 
<code class="reqn">r^*</code> statistic can be decomposed.  The two versions refer 
to respectively <cite>Skovgaard's (1996)</cite> proposal and <cite>Fraser, 
Reid and Wu's (1999)</cite> solution.  Only if 
<code>hoa = TRUE</code> in the function call that generated the 
<code>nlreg.profile</code> object argument <code>object</code>.
</p>
</td></tr>
<tr><td><code>mle</code></td>
<td>

<p>a numerical vector giving the <abbr><span class="acronym">MLE</span></abbr> of the parameter of 
interest and its standard error.
</p>
</td></tr>
<tr><td><code>offset</code></td>
<td>

<p>character string giving the name of the interest parameter.
</p>
</td></tr>
<tr><td><code>twoside</code></td>
<td>

<p>a logical value indicating whether two-sided or one-sided 
confidence intervals were calculated.
</p>
</td></tr>
<tr><td><code>points</code></td>
<td>

<p>the number of output points at which the considered statistics were
calculated exactly.
</p>
</td></tr>
<tr><td><code>n</code></td>
<td>

<p>the approximate number of points used in the spline interpolation 
of the considered statistics.
</p>
</td></tr>
<tr><td><code>hoa</code></td>
<td>

<p>a logical value indicating whether higher order solutions were
calculated.
</p>
</td></tr>
<tr><td><code>digits</code></td>
<td>

<p>the number of significant digits to be printed.
</p>
</td></tr>
<tr><td><code>call</code></td>
<td>

<p>an image of the call that produced the object, but with all 
arguments named.
</p>
</td></tr>
<tr><td><code>...</code></td>
<td>

<p>absorbs additional arguments.
</p>
</td></tr>
</table>


<h3>References</h3>

<p>Fraser, D.A.S., Reid, N. and Wu, J. (1999).  A simple general formula 
for tail probabilities for frequentist and Bayesian inference. 
<em>Biometrika</em>, <b>86</b>, 249&ndash;264.
</p>
<p>Skovgaard, I.  (1996) An explicit large-deviation approximation to
one-parameter tests.  <em>Bernoulli</em>, <b>2</b>, 145&ndash;165.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+nlreg.profile.objects">nlreg.profile.object</a></code>,
<code><a href="#topic+profile.nlreg">profile.nlreg</a></code>,
<code><a href="base.html#topic+summary">summary</a></code> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(metsulfuron)
metsulfuron.nl &lt;- 
    nlreg( formula = log(area) ~ log( b1+(b2-b1) / (1+(dose/b4)^b3) ), 
           weights = ~ ( 1+dose^exp(g) )^2, data = metsulfuron, 
           start = c(b1 = 138, b2 = 2470, b3 = 2, b4 = 0.07, g = log(0.3)),
           hoa = TRUE )
##
metsulfuron.prof &lt;- profile( metsulfuron.nl, offset = g, trace = TRUE )
summary( metsulfuron.prof, alpha = c(0.9, 0.95) )
</code></pre>

<hr>
<h2 id='var2cor'>
Convert Covariance Matrix to Correlation Matrix &mdash; Generic Function
</h2><span id='topic+var2cor'></span>

<h3>Description</h3>

<p>This function converts the covariance matrix from a fitted model into
the correlation matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>var2cor(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="var2cor_+3A_object">object</code></td>
<td>

<p>any fitted model object from which a covariance matrix may be extracted.
</p>
</td></tr>
<tr><td><code id="var2cor_+3A_...">...</code></td>
<td>

<p>absorbs any additional argument.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is generic (see <code><a href="utils.html#topic+methods">methods</a></code>); method 
functions can be written to handle specific classes of data.  
Classes which already have methods for this function include: 
<code>nlreg</code>, <code>summary.nlreg</code>, <code>mpl</code> and <code>summary.mpl</code>.
</p>


<h3>Value</h3>

<p>the correlation matrix of the estimates from a fitted model.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+var2cor.nlreg">var2cor.nlreg</a></code>, <code><a href="#topic+var2cor.mpl">var2cor.mpl</a></code>, 
<code><a href="utils.html#topic+methods">methods</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(metsulfuron)
metsulfuron.nl &lt;- 
    nlreg( log(area) ~ log( b1+(b2-b1) / (1+(dose/b4)^b3) ), 
           weights = ~( 1+dose^exp(g) )^2, data = metsulfuron, 
           start = c(b1 = 138, b2 = 2470, b3 = 2, b4 = 0.07, g = log(0.3)),
           hoa = TRUE )
var2cor( metsulfuron.nl )
##
metsulfuron.sum &lt;- summary( metsulfuron.nl, corr = FALSE )
var2cor( metsulfuron.sum )
</code></pre>

<hr>
<h2 id='var2cor.nlregmpl'>
Use var2cor() on a &lsquo;nlreg&rsquo; and &lsquo;mpl&rsquo; object
</h2><span id='topic+var2cor.mpl'></span><span id='topic+var2cor.nlreg'></span><span id='topic+var2cor.summary.mpl'></span><span id='topic+var2cor.summary.nlreg'></span>

<h3>Description</h3>

<p>This is a method for the function <code>var2cor()</code> for objects 
inheriting from class <code>nlreg</code> or <code>mpl</code>.  See 
<code><a href="#topic+var2cor">var2cor</a></code> for the general behavior of this function 
and for the interpretation of <code>object</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mpl'
var2cor(object, ...)
## S3 method for class 'nlreg'
var2cor(object, ...)
## S3 method for class 'summary.mpl'
var2cor(object, ...)
## S3 method for class 'summary.nlreg'
var2cor(object, ...)
</code></pre>


<h3>See Also</h3>

<p><code><a href="#topic+mpl.object">mpl.object</a></code>, <code><a href="#topic+nlreg.object">nlreg.object</a></code>, 
<code><a href="#topic+var2cor">var2cor</a></code>
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
