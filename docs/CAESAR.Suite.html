<!DOCTYPE html><html lang="en"><head><title>Help for package CAESAR.Suite</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {CAESAR.Suite}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#acc'><p>Calculate Accuracy of Predicted Cell Types</p></a></li>
<li><a href='#add.gene.embedding'><p>Add Gene Embedding to Seurat Object</p></a></li>
<li><a href='#annotation_mat'><p>Annotate Cells Using Distance Matrix and Marker Frequencies</p></a></li>
<li><a href='#auc'><p>Calculate Area Under the Curve (AUC) for Pathway Scores</p></a></li>
<li><a href='#CAESAR.annotation'><p>Perform Cell Annotation Using CAESAR with Confidence and Proportion Calculation</p></a></li>
<li><a href='#CAESAR.coembedding'><p>Compute Co-embedding Using CAESAR</p></a></li>
<li><a href='#CAESAR.coembedding.image'><p>Compute Co-embedding with Image Information Using CAESAR</p></a></li>
<li><a href='#CAESAR.CTDEP'><p>Test Cell Type Differentially Enriched Pathways</p></a></li>
<li><a href='#CAESAR.enrich.pathway'><p>Test whether pathways are enriched</p></a></li>
<li><a href='#CAESAR.enrich.score'><p>Calculate Spot Level Enrichment Scores for Pathways Using CAESAR</p></a></li>
<li><a href='#CAESAR.RUV'><p>Perform Batch Correction and Integration with CAESAR Using Housekeeping Genes</p></a></li>
<li><a href='#Cauchy.Combination'><p>Combine p-values Using the Cauchy Combination Method</p></a></li>
<li><a href='#cellembedding_image_matrix'><p>Compute Spatial-Aware Cell Embeddings with Image Information</p></a></li>
<li><a href='#cellembedding_image_seurat'><p>Compute Spatial-Aware Cell Embeddings with Image Information</p></a></li>
<li><a href='#cellembedding_matrix'><p>Compute Spatial-Aware Cell Embeddings</p></a></li>
<li><a href='#cellembedding_seurat'><p>Perform CAESAR embedding of Cells Using FAST with Spatial Weights</p></a></li>
<li><a href='#CoUMAP'><p>Co-embedding UMAP for Genes and Cells in a Seurat Object</p></a></li>
<li><a href='#CoUMAP.plot'><p>Plot Co-embedding UMAP for Genes and Cells</p></a></li>
<li><a href='#find.sig.genes'><p>Identify Signature Genes for Each Cell Type</p></a></li>
<li><a href='#getneighborhood_fastcpp'><p>getneighborhood_fast</p></a></li>
<li><a href='#Human_HK_genes'><p>Human housekeeping genes database</p></a></li>
<li><a href='#Intsg'><p>Integrate Signature Genes Across Datasets</p></a></li>
<li><a href='#marker.select'><p>Select Marker Genes from a signature gene list Based on Expression Proportion and Overlap Criteria</p></a></li>
<li><a href='#markerList2mat'><p>Convert Marker List to a Weighted Matrix</p></a></li>
<li><a href='#Mouse_HK_genes'><p>Mouse housekeeping genes database</p></a></li>
<li><a href='#SigScore'><p>Calculate Signature Score for Cell Clusters</p></a></li>
<li><a href='#toydata'><p>A toy dataset to run examples</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>CAESAR: a Cross-Technology and Cross-Resolution Framework for
Spatial Omics Annotation</td>
</tr>
<tr>
<td>Version:</td>
<td>0.2.0</td>
</tr>
<tr>
<td>Author:</td>
<td>Xiao Zhang [aut, cre],
  Wei Liu [aut],
  Jin Liu [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Xiao Zhang &lt;zhangxiao1994@cuhk.edu.cn&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>
    Biotechnology in spatial omics has advanced rapidly over the past few years, enhancing both throughput and resolution. However, existing annotation pipelines in spatial omics predominantly rely on clustering methods, lacking the flexibility to integrate extensive annotated information from single-cell RNA sequencing (scRNA-seq) due to discrepancies in spatial resolutions, species, or modalities. Here we introduce the CAESAR suite, an open-source software package that provides image-based spatial co-embedding of locations and genomic features. It uniquely transfers labels from scRNA-seq reference, enabling the annotation of spatial omics datasets across different technologies, resolutions, species, and modalities, based on the conserved relationship between signature genes and cells/locations at an appropriate level of granularity. Notably, CAESAR enriches location-level pathways, allowing for the detection of gradual biological pathway activation within spatially defined domain types. More details on the methods related to our paper currently under submission. A full reference to the paper will be provided in future versions once the paper is published.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 1.0.10), Matrix, Seurat, DescTools, ProFAST, furrr,
future, ggplot2, ggrepel, grDevices, irlba, pbapply, progress,
scater, stats, ade4, methods</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>LazyDataCompression:</td>
<td>xz</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr, rmarkdown</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, cowplot, scales, tibble, dplyr, msigdbr</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/XiaoZhangryy/CAESAR.Suite">https://github.com/XiaoZhangryy/CAESAR.Suite</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/XiaoZhangryy/CAESAR.Suite/issues">https://github.com/XiaoZhangryy/CAESAR.Suite/issues</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-03-01 16:55:27 UTC; ZXiao</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-03-03 10:10:01 UTC</td>
</tr>
</table>
<hr>
<h2 id='acc'>Calculate Accuracy of Predicted Cell Types</h2><span id='topic+acc'></span>

<h3>Description</h3>

<p>This function calculates the accuracy of predicted cell types by comparing the predicted labels to the true labels. It allows for the exclusion of certain cell types from the reference when calculating accuracy.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>acc(y.predict, y.truth, cts_notin_reference = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="acc_+3A_y.predict">y.predict</code></td>
<td>
<p>A character vector representing the predicted cell type labels.</p>
</td></tr>
<tr><td><code id="acc_+3A_y.truth">y.truth</code></td>
<td>
<p>A character vector representing the true cell type labels.</p>
</td></tr>
<tr><td><code id="acc_+3A_cts_notin_reference">cts_notin_reference</code></td>
<td>
<p>A character vector specifying the cell types that should be excluded from the accuracy calculation. If <code>NULL</code>, all cell types are included. Default is <code>NULL</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function compares the predicted labels ('y.predict') to the true labels ('y.truth') and calculates the proportion of correct predictions. If 'cts_notin_reference' is provided, cell types in this vector are excluded from the accuracy calculation.
</p>


<h3>Value</h3>

<p>A numeric value representing the accuracy, i.e., the proportion of correctly predicted labels among the considered cell types.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example usage:
y.predict &lt;- c("A", "B", "A", "C", "A", "B")
y.truth &lt;- c("A", "B", "C", "C", "A", "A")
acc_value &lt;- acc(y.predict, y.truth)
print(acc_value)

</code></pre>

<hr>
<h2 id='add.gene.embedding'>Add Gene Embedding to Seurat Object</h2><span id='topic+add.gene.embedding'></span>

<h3>Description</h3>

<p>This function computes and adds gene embeddings to a Seurat object based on a provided adjacency matrix of spatial information and an existing cell embedding. It allows for the integration of gene-level information into the dimensional reduction of the Seurat object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add.gene.embedding(seu, adjm, reduction.name = "caesar", assay = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="add.gene.embedding_+3A_seu">seu</code></td>
<td>
<p>A Seurat object. The Seurat object should contain pre-computed cell embeddings for dimensional reduction and expression data for genes.</p>
</td></tr>
<tr><td><code id="add.gene.embedding_+3A_adjm">adjm</code></td>
<td>
<p>A spatial adjacency matrix that represents relationships between cells or spots in the spatial transcriptomic data. This matrix is used to calculate the gene embeddings.</p>
</td></tr>
<tr><td><code id="add.gene.embedding_+3A_reduction.name">reduction.name</code></td>
<td>
<p>A character string specifying the name of the dimensional reduction method used for the cell embeddings (e.g., &quot;ncfm&quot;, &quot;caesar&quot;, etc.). The computed gene embeddings will be added to this slot. Default is &quot;caesar&quot;.</p>
</td></tr>
<tr><td><code id="add.gene.embedding_+3A_assay">assay</code></td>
<td>
<p>A character string specifying which assay to use from the Seurat object. If NULL, the function will use the default assay set in the Seurat object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The modified Seurat object with the computed gene embeddings added to the specified dimensional reduction ('reduction.name').
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(toydata)

seu &lt;- toydata$seu
pos &lt;- toydata$pos

adjm &lt;- ProFAST::AddAdj(as.matrix(pos), radius.upper = 200)
seu &lt;- add.gene.embedding(
    seu = seu,
    adjm = adjm,
    reduction.name = "caesar",
    assay = "RNA"
)
print(seu)

</code></pre>

<hr>
<h2 id='annotation_mat'>Annotate Cells Using Distance Matrix and Marker Frequencies</h2><span id='topic+annotation_mat'></span>

<h3>Description</h3>

<p>This function annotates cells based on a cell-gene distance matrix and marker gene frequencies. It computes the average distances, optionally calculates confidence levels for the predictions, and computes cell mixing proportions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>annotation_mat(
  distce,
  marker.freq,
  gene.use = NULL,
  cal.confidence = TRUE,
  cal.proportions = TRUE,
  parallel = TRUE,
  ncores = 10,
  n_fake = 1001,
  seed = 1,
  threshold = 0.95,
  unassign = "unassigned"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="annotation_mat_+3A_distce">distce</code></td>
<td>
<p>A matrix of distances between spots and genes. Rows represent genes, and columns represent cells. Generally, it is a list of the output of function <code>ProFAST::pdistance</code> with CAESAR co-embedding as input.</p>
</td></tr>
<tr><td><code id="annotation_mat_+3A_marker.freq">marker.freq</code></td>
<td>
<p>A matrix where rows represent cell types, and columns represent marker genes. The values in the matrix represent the frequency or weight of each marker gene for each cell type. Generally, it is a list of the output of function <code>markerList2mat</code>.</p>
</td></tr>
<tr><td><code id="annotation_mat_+3A_gene.use">gene.use</code></td>
<td>
<p>A character vector specifying which genes to use for the annotation. If 'NULL', all genes in 'distce' will be used. Default is 'NULL'.</p>
</td></tr>
<tr><td><code id="annotation_mat_+3A_cal.confidence">cal.confidence</code></td>
<td>
<p>Logical, indicating whether to calculate the confidence of the predictions. Default is 'TRUE'.</p>
</td></tr>
<tr><td><code id="annotation_mat_+3A_cal.proportions">cal.proportions</code></td>
<td>
<p>Logical, indicating whether to calculate the mixing proportions of cell types for each spot. Default is 'TRUE'.</p>
</td></tr>
<tr><td><code id="annotation_mat_+3A_parallel">parallel</code></td>
<td>
<p>Logical, indicating whether to run the confidence calculation in parallel. Default is 'TRUE'.</p>
</td></tr>
<tr><td><code id="annotation_mat_+3A_ncores">ncores</code></td>
<td>
<p>The number of cores to use for parallel computation. Default is 10.</p>
</td></tr>
<tr><td><code id="annotation_mat_+3A_n_fake">n_fake</code></td>
<td>
<p>The number of fake (randomized) distance matrices to simulate for confidence calculation. Default is 1001.</p>
</td></tr>
<tr><td><code id="annotation_mat_+3A_seed">seed</code></td>
<td>
<p>The random seed for reproducibility. Default is 1.</p>
</td></tr>
<tr><td><code id="annotation_mat_+3A_threshold">threshold</code></td>
<td>
<p>A numeric value specifying the confidence threshold below which a cell is labeled as 'unassigned'. Default is 0.95.</p>
</td></tr>
<tr><td><code id="annotation_mat_+3A_unassign">unassign</code></td>
<td>
<p>A character string representing the label to assign to cells below the confidence threshold. Default is '&quot;unassigned&quot;'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following components:
</p>
<table role = "presentation">
<tr><td><code>ave.dist</code></td>
<td>
<p>A matrix of average distances between each cell and each cell type.</p>
</td></tr>
<tr><td><code>confidence</code></td>
<td>
<p>A numeric vector of confidence values for each cell (if 'cal.confidence = TRUE').</p>
</td></tr>
<tr><td><code>pred</code></td>
<td>
<p>A character vector of predicted cell types for each cell.</p>
</td></tr>
<tr><td><code>pred_unassign</code></td>
<td>
<p>A character vector of predicted cell types with cells below the confidence threshold labeled as 'unassigned' (if 'cal.confidence = TRUE').</p>
</td></tr>
<tr><td><code>cell_mixing_proportions</code></td>
<td>
<p>A matrix of mixing proportions for each spot across the different cell types (if 'cal.proportions = TRUE').</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+marker.select">marker.select</a></code> for select markers.
<code><a href="#topic+find.sig.genes">find.sig.genes</a></code> for signature gene list.
<code><a href="#topic+markerList2mat">markerList2mat</a></code> for marker frequency matrix.
<code><a href="ProFAST.html#topic+pdistance">pdistance</a></code> for obtain cell-gene distance matrix using co-embedding.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(toydata)

seu &lt;- toydata$seu
markers &lt;- toydata$markers

seu &lt;- ProFAST::pdistance(seu, reduction = "caesar")
distce &lt;- Seurat::GetAssayData(object = seu, slot = "data", assay = "distce")

marker.freq &lt;- markerList2mat(list(markers))

anno_res &lt;- annotation_mat(distce, marker.freq, cal.confidence = FALSE, cal.proportions = FALSE)
str(anno_res)
</code></pre>

<hr>
<h2 id='auc'>Calculate Area Under the Curve (AUC) for Pathway Scores</h2><span id='topic+auc'></span>

<h3>Description</h3>

<p>This function calculates the area under the curve (AUC) for pathway scores with respect to a specific cell type. It uses the AUC to evaluate the performance of the pathway scores in distinguishing the target cell type from others.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>auc(celltype, pathway.scores, return.mean = TRUE, seed = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="auc_+3A_celltype">celltype</code></td>
<td>
<p>A factor or character vector representing the cell type labels for each cell.</p>
</td></tr>
<tr><td><code id="auc_+3A_pathway.scores">pathway.scores</code></td>
<td>
<p>A matrix of pathway scores where rows represent cells and columns represent different pathways.</p>
</td></tr>
<tr><td><code id="auc_+3A_return.mean">return.mean</code></td>
<td>
<p>Logical, indicating whether to return the weighted mean AUC across all cell types. If <code>FALSE</code>, returns the AUC for each pathway. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="auc_+3A_seed">seed</code></td>
<td>
<p>An integer specifying the random seed for reproducibility. Default is 1.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>return.mean = TRUE</code>, a numeric vector containing the weighted mean AUC. If <code>return.mean = FALSE</code>, a numeric matrix of AUCs where rows represent pathways and columns represent cell types.
</p>


<h3>See Also</h3>

<p><code><a href="DescTools.html#topic+AUC">AUC</a></code> for the AUC calculation.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example usage:
celltype &lt;- factor(rep(letters[1:5], each = 20))
pathway.scores &lt;- matrix(runif(1000), nrow = 100, ncol = 10)
colnames(pathway.scores) &lt;- letters[1:10]
auc_values &lt;- auc(celltype, pathway.scores, return.mean = TRUE)
print(auc_values)

</code></pre>

<hr>
<h2 id='CAESAR.annotation'>Perform Cell Annotation Using CAESAR with Confidence and Proportion Calculation</h2><span id='topic+CAESAR.annotation'></span>

<h3>Description</h3>

<p>This function annotates cells in a Seurat object using marker gene frequencies and a distance matrix. It calculates average distances between cells and cell types, confidence scores, and mixing proportions. Optionally, it can add the annotations and related metrics to the Seurat object metadata.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CAESAR.annotation(
  seu,
  marker.freq,
  reduction.name = "caesar",
  assay.dist = "distce",
  gene.use = NULL,
  cal.confidence = TRUE,
  cal.proportions = TRUE,
  parallel = TRUE,
  ncores = 10,
  n_fake = 1001,
  seed = 1,
  threshold = 0.95,
  unassign = "unassigned",
  add.to.meta = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CAESAR.annotation_+3A_seu">seu</code></td>
<td>
<p>A Seurat object containing cell expression data.</p>
</td></tr>
<tr><td><code id="CAESAR.annotation_+3A_marker.freq">marker.freq</code></td>
<td>
<p>A matrix where rows represent cell types and columns represent marker genes. The values in the matrix represent the frequency or weight of each marker gene for each cell type. Generally, it is a list of the output of function <code>markerList2mat</code>.</p>
</td></tr>
<tr><td><code id="CAESAR.annotation_+3A_reduction.name">reduction.name</code></td>
<td>
<p>A character string specifying the name of the dimensional reduction to use when calculating distances. Default is &quot;caesar&quot;.</p>
</td></tr>
<tr><td><code id="CAESAR.annotation_+3A_assay.dist">assay.dist</code></td>
<td>
<p>A character string specifying the name of the assay to store the distance matrix. If not present in the Seurat object, the function will calculate the distances using <code>ProFAST::pdistance</code>. Default is &quot;distce&quot;.</p>
</td></tr>
<tr><td><code id="CAESAR.annotation_+3A_gene.use">gene.use</code></td>
<td>
<p>A character vector specifying which genes to use for the annotation. If <code>NULL</code>, all genes in the distance matrix will be used. Default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="CAESAR.annotation_+3A_cal.confidence">cal.confidence</code></td>
<td>
<p>Logical, indicating whether to calculate the confidence of the predictions. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="CAESAR.annotation_+3A_cal.proportions">cal.proportions</code></td>
<td>
<p>Logical, indicating whether to calculate the mixing proportions of cell types for each cell. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="CAESAR.annotation_+3A_parallel">parallel</code></td>
<td>
<p>Logical, indicating whether to run the confidence calculation in parallel. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="CAESAR.annotation_+3A_ncores">ncores</code></td>
<td>
<p>The number of cores to use for parallel computation. Default is 10.</p>
</td></tr>
<tr><td><code id="CAESAR.annotation_+3A_n_fake">n_fake</code></td>
<td>
<p>The number of fake (randomized) distance matrices to simulate for confidence calculation. Default is 1001.</p>
</td></tr>
<tr><td><code id="CAESAR.annotation_+3A_seed">seed</code></td>
<td>
<p>The random seed for reproducibility. Default is 1.</p>
</td></tr>
<tr><td><code id="CAESAR.annotation_+3A_threshold">threshold</code></td>
<td>
<p>A numeric value specifying the confidence threshold below which a cell is labeled as <code>unassigned</code>. Default is 0.95.</p>
</td></tr>
<tr><td><code id="CAESAR.annotation_+3A_unassign">unassign</code></td>
<td>
<p>A character string representing the label to assign to cells below the confidence threshold. Default is &quot;unassigned&quot;.</p>
</td></tr>
<tr><td><code id="CAESAR.annotation_+3A_add.to.meta">add.to.meta</code></td>
<td>
<p>Logical, indicating whether to return the annotation results directly or add them to the Seurat object metadata. If <code>TRUE</code>, the function will return the results directly. Default is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>add.to.meta = FALSE</code>, the Seurat object with the added metadata for predicted cell types (<code>CAESAR</code>), predictions with unassigned (<code>CAESARunasg</code>), confidence scores (<code>CAESARconf</code>), average distances, and mixing proportions. If <code>add.to.meta = TRUE</code>, a list containing the above annotation results is returned.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+marker.select">marker.select</a></code> for select markers.
<code><a href="#topic+find.sig.genes">find.sig.genes</a></code> for signature gene list.
<code><a href="#topic+markerList2mat">markerList2mat</a></code> for marker frequency matrix.
<code><a href="ProFAST.html#topic+pdistance">pdistance</a></code> for obtain cell-gene distance matrix using co-embedding.
<code><a href="#topic+annotation_mat">annotation_mat</a></code> for annotation procedure.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(toydata)

seu &lt;- toydata$seu
markers &lt;- toydata$markers

marker.freq &lt;- markerList2mat(list(markers))
anno_res &lt;- CAESAR.annotation(seu, marker.freq, cal.confidence = FALSE, cal.proportions = FALSE)
str(anno_res)

</code></pre>

<hr>
<h2 id='CAESAR.coembedding'>Compute Co-embedding Using CAESAR</h2><span id='topic+CAESAR.coembedding'></span>

<h3>Description</h3>

<p>This function performs co-embedding of both cells and genes using the CAESAR method. It integrates spatial transcriptomics data from a Seurat object ('seu') with a spatial adjacency matrix to compute the low-dimensional co-embedding.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CAESAR.coembedding(
  seu,
  pos,
  reduction.name = "caesar",
  q = 50,
  radius.upper = 400,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CAESAR.coembedding_+3A_seu">seu</code></td>
<td>
<p>A Seurat object containing spatial transcriptomics data.</p>
</td></tr>
<tr><td><code id="CAESAR.coembedding_+3A_pos">pos</code></td>
<td>
<p>A matrix of spatial coordinates for the spots (e.g., spatial positions of cells or pixels in the image). The row names of 'pos' should match the column names of 'seu'.</p>
</td></tr>
<tr><td><code id="CAESAR.coembedding_+3A_reduction.name">reduction.name</code></td>
<td>
<p>A character string specifying the name of the dimensional reduction method to store in the Seurat object. Default is &quot;caesar&quot;.</p>
</td></tr>
<tr><td><code id="CAESAR.coembedding_+3A_q">q</code></td>
<td>
<p>An integer specifying the number of dimensions for the reduced co-embeddings. Default is 50.</p>
</td></tr>
<tr><td><code id="CAESAR.coembedding_+3A_radius.upper">radius.upper</code></td>
<td>
<p>A numeric value specifying the upper limit of the search radius for the spatial adjacency matrix. Default is 400.</p>
</td></tr>
<tr><td><code id="CAESAR.coembedding_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to 'cellembedding_image_seurat'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The modified Seurat object with the computed cell and gene embeddings stored in the specified reduction slot.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cellembedding_seurat">cellembedding_seurat</a></code> for computing cell embeddings.
<code><a href="#topic+add.gene.embedding">add.gene.embedding</a></code> for adding gene embeddings to a Seurat object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(toydata)

seu &lt;- toydata$seu
pos &lt;- toydata$pos

seu &lt;- CAESAR.coembedding(
    seu = seu,
    pos = pos
)
print(seu)
</code></pre>

<hr>
<h2 id='CAESAR.coembedding.image'>Compute Co-embedding with Image Information Using CAESAR</h2><span id='topic+CAESAR.coembedding.image'></span>

<h3>Description</h3>

<p>This function performs co-embedding of both cells and genes using the CAESAR method. It integrates spatial transcriptomics data from a Seurat object ('seu') with image features ('feature_img') and a spatial adjacency matrix to compute the low-dimensional co-embedding.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CAESAR.coembedding.image(
  seu,
  feature_img,
  pos,
  reduction.name = "caesar",
  q = 50,
  lower.med = 3.5,
  upper.med = 5.5,
  radius.upper = 400,
  q.image = 10,
  weighted = FALSE,
  approx_Phi = TRUE,
  seed = 1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CAESAR.coembedding.image_+3A_seu">seu</code></td>
<td>
<p>A Seurat object containing spatial transcriptomics data.</p>
</td></tr>
<tr><td><code id="CAESAR.coembedding.image_+3A_feature_img">feature_img</code></td>
<td>
<p>A matrix representing features extracted from a histology image using a Visual Transformer. Rows correspond to spots and columns represent image features. The row names of 'feature_img' should match the column names of 'seu'.</p>
</td></tr>
<tr><td><code id="CAESAR.coembedding.image_+3A_pos">pos</code></td>
<td>
<p>A matrix of spatial coordinates for the spots (e.g., spatial positions of cells or pixels in the image). The row names of 'pos' should match the column names of 'seu'.</p>
</td></tr>
<tr><td><code id="CAESAR.coembedding.image_+3A_reduction.name">reduction.name</code></td>
<td>
<p>A character string specifying the name of the dimensional reduction method to store in the Seurat object. Default is &quot;caesar&quot;.</p>
</td></tr>
<tr><td><code id="CAESAR.coembedding.image_+3A_q">q</code></td>
<td>
<p>An integer specifying the number of dimensions for the reduced co-embeddings. Default is 50.</p>
</td></tr>
<tr><td><code id="CAESAR.coembedding.image_+3A_lower.med">lower.med</code></td>
<td>
<p>A numeric value specifying the lower bound for the desired median number of neighbors in the spatial adjacency matrix. Default is 3.5.</p>
</td></tr>
<tr><td><code id="CAESAR.coembedding.image_+3A_upper.med">upper.med</code></td>
<td>
<p>A numeric value specifying the upper bound for the desired median number of neighbors in the spatial adjacency matrix. Default is 5.5.</p>
</td></tr>
<tr><td><code id="CAESAR.coembedding.image_+3A_radius.upper">radius.upper</code></td>
<td>
<p>A numeric value specifying the upper limit of the search radius for the spatial adjacency matrix. Default is 400.</p>
</td></tr>
<tr><td><code id="CAESAR.coembedding.image_+3A_q.image">q.image</code></td>
<td>
<p>An integer specifying the number of dimensions for the reduced image embeddings. Default is 10.</p>
</td></tr>
<tr><td><code id="CAESAR.coembedding.image_+3A_weighted">weighted</code></td>
<td>
<p>Logical, indicating whether to apply weighted PCA on the image features. Default is FALSE.</p>
</td></tr>
<tr><td><code id="CAESAR.coembedding.image_+3A_approx_phi">approx_Phi</code></td>
<td>
<p>Logical, indicating whether to use an approximate method for Phi matrix estimation. Default is TRUE.</p>
</td></tr>
<tr><td><code id="CAESAR.coembedding.image_+3A_seed">seed</code></td>
<td>
<p>An integer used to set the random seed for reproducibility. Default is 1.</p>
</td></tr>
<tr><td><code id="CAESAR.coembedding.image_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to 'cellembedding_image_seurat'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The modified Seurat object with the computed cell and gene embeddings stored in the specified reduction slot.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cellembedding_image_seurat">cellembedding_image_seurat</a></code> for computing cell embeddings.
<code><a href="#topic+add.gene.embedding">add.gene.embedding</a></code> for adding gene embeddings to a Seurat object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(toydata)

seu &lt;- toydata$seu
pos &lt;- toydata$pos
imgf &lt;- toydata$imgf

seu &lt;- CAESAR.coembedding.image(seu, imgf, pos)
print(seu)
</code></pre>

<hr>
<h2 id='CAESAR.CTDEP'>Test Cell Type Differentially Enriched Pathways</h2><span id='topic+CAESAR.CTDEP'></span>

<h3>Description</h3>

<p>This function tests whether specific pathways are differentially enriched in particular cell types with cell types stored in a Seurat object. The function applies the Wilcoxon rank-sum test to compare the pathway scores between cells of a given cell type and all other cells. It supports parallel computation to speed up the testing process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CAESAR.CTDEP(
  seu,
  pathway_scores,
  ident = NULL,
  cts = NULL,
  parallel = TRUE,
  ncores = 10,
  seed = 1
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CAESAR.CTDEP_+3A_seu">seu</code></td>
<td>
<p>A Seurat object containing the single-cell RNA-seq data.</p>
</td></tr>
<tr><td><code id="CAESAR.CTDEP_+3A_pathway_scores">pathway_scores</code></td>
<td>
<p>A matrix of pathway scores where rows represent cells and columns represent different pathways.</p>
</td></tr>
<tr><td><code id="CAESAR.CTDEP_+3A_ident">ident</code></td>
<td>
<p>A character string specifying the column name in the Seurat object's metadata to use as the cell type labels. If <code>NULL</code>, the default identities (<code>Idents(seu)</code>) will be used. Default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="CAESAR.CTDEP_+3A_cts">cts</code></td>
<td>
<p>A character vector specifying the cell types to test. If <code>NULL</code>, the function will test all unique cell types present in <code>ident</code> or <code>Idents(seu)</code>. Default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="CAESAR.CTDEP_+3A_parallel">parallel</code></td>
<td>
<p>Logical, indicating whether to run the computation in parallel. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="CAESAR.CTDEP_+3A_ncores">ncores</code></td>
<td>
<p>An integer specifying the number of cores to use for parallel computation. Default is 10.</p>
</td></tr>
<tr><td><code id="CAESAR.CTDEP_+3A_seed">seed</code></td>
<td>
<p>An integer specifying the random seed for reproducibility in parallel computation. Default is 1.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of p-values where rows represent the pathways and columns represent the tested cell types.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+wilcox.test">wilcox.test</a></code> for the Wilcoxon rank-sum test.
<code><a href="#topic+CAESAR.enrich.score">CAESAR.enrich.score</a></code> for spot level pathway enrich scores.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(toydata)

seu &lt;- toydata$seu
pathway_list &lt;- toydata$pathway_list
cts &lt;- levels(seu)[1:2]

enrich.score &lt;- CAESAR.enrich.score(seu, pathway_list)
dep.pvals &lt;- CAESAR.CTDEP(seu, enrich.score, cts = cts)
print(dep.pvals)

</code></pre>

<hr>
<h2 id='CAESAR.enrich.pathway'>Test whether pathways are enriched</h2><span id='topic+CAESAR.enrich.pathway'></span>

<h3>Description</h3>

<p>This function tests whether pathways are enriched. Specifically, for a pathway (gene set), the function will assess whether these genes are clustered in the embedding space. For more details, see Bai and Chu (2023).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CAESAR.enrich.pathway(
  seu,
  pathway.list,
  reduction = "caesar",
  pathway.cutoff = 3,
  test.type = list("ori", "gen", "wei", "max"),
  k = 5,
  wei.fun = c("weiMax", "weiGeo", "weiArith"),
  perm.num = 0,
  progress_bar = TRUE,
  ncores = 10,
  eta = 1e-04,
  genes.use = NULL,
  parallel = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CAESAR.enrich.pathway_+3A_seu">seu</code></td>
<td>
<p>A Seurat object containing co-embedding.</p>
</td></tr>
<tr><td><code id="CAESAR.enrich.pathway_+3A_pathway.list">pathway.list</code></td>
<td>
<p>A list of pathways, where each pathway is characterized as a vector of gene sets.</p>
</td></tr>
<tr><td><code id="CAESAR.enrich.pathway_+3A_reduction">reduction</code></td>
<td>
<p>The embedding used when a Seurat object is provided. Default is &quot;caesar&quot;.</p>
</td></tr>
<tr><td><code id="CAESAR.enrich.pathway_+3A_pathway.cutoff">pathway.cutoff</code></td>
<td>
<p>The minimal number of genes required in a pathway. Pathways with fewer genes than this threshold will not be considered in the enrichment test.</p>
</td></tr>
<tr><td><code id="CAESAR.enrich.pathway_+3A_test.type">test.type</code></td>
<td>
<p>Type of graph-based test. This must be a list containing elements chosen from &quot;ori&quot;, &quot;gen&quot;, &quot;wei&quot;, and &quot;max&quot;, with default 'list(&quot;ori&quot;, &quot;gen&quot;, &quot;wei&quot;, &quot;max&quot;)'. &quot;ori&quot; refers to robust original edge-count test, &quot;gen&quot; refers to robust generalized edge-count test, &quot;wei&quot; refers to robust weighted edge-count test, and &quot;max&quot; refers to robust max-type edge-count tests. For more details, see Bai and Chu (2023).</p>
</td></tr>
<tr><td><code id="CAESAR.enrich.pathway_+3A_k">k</code></td>
<td>
<p>The parameter for k-minimum spanning tree. Default is 5.</p>
</td></tr>
<tr><td><code id="CAESAR.enrich.pathway_+3A_wei.fun">wei.fun</code></td>
<td>
<p>The weighted function used in the enrichment test. Default is &quot;weiMax&quot;, which returns the inverse of the max node degree of an edge. &quot;weiGeo&quot; returns the inverse of the geometric average of the node degrees, and &quot;weiArith&quot; returns the inverse of the arithmetic average of the node degrees.</p>
</td></tr>
<tr><td><code id="CAESAR.enrich.pathway_+3A_perm.num">perm.num</code></td>
<td>
<p>The number of permutations used to calculate the p-value (default is 0). Use 0 for getting only the approximate p-value based on asymptotic theory. Setting perm.num (e.g., perm.num = 1000) allows permutation-based p-value calculation, though this may be time-consuming.</p>
</td></tr>
<tr><td><code id="CAESAR.enrich.pathway_+3A_progress_bar">progress_bar</code></td>
<td>
<p>Logical, TRUE or FALSE, indicating whether a progress bar should be printed during permutations. Default is TRUE.</p>
</td></tr>
<tr><td><code id="CAESAR.enrich.pathway_+3A_ncores">ncores</code></td>
<td>
<p>The number of cores to use for parallel computing. Default is 10.</p>
</td></tr>
<tr><td><code id="CAESAR.enrich.pathway_+3A_eta">eta</code></td>
<td>
<p>A small positive number to ensure matrix inversion stability. Default is 1e-4.</p>
</td></tr>
<tr><td><code id="CAESAR.enrich.pathway_+3A_genes.use">genes.use</code></td>
<td>
<p>A vector of genes representing a gene set. All pathways will be tested for enrichment after intersecting with this gene set.</p>
</td></tr>
<tr><td><code id="CAESAR.enrich.pathway_+3A_parallel">parallel</code></td>
<td>
<p>Logical, indicating whether to use parallel computing to speed up computation. Default is TRUE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame containing the results of the test with the following columns:
</p>

<ul>
<li><p> asy.ori.statistic - test statistic of robust original edge-count test.
</p>
</li>
<li><p> asy.ori.pval - asymptotic theory based p value of robust original edge-count test.
</p>
</li>
<li><p> asy.ori.pval.adj - the adjusted asymptotic theory based p value of robust original edge-count test.
</p>
</li>
<li><p> perm.ori.pval - permutation-based p value of robust original edge-count test, appear when permutation-based p-value is calculated.
</p>
</li>
<li><p> perm.ori.pval.adj - the adjusted permutation-based p value of robust original edge-count test, appear when permutation-based p-value is calculated.
</p>
</li>
<li><p> asy.gen.statistic - test statistic of robust generalized edge-count test.
</p>
</li>
<li><p> asy.gen.pval - asymptotic theory based p value of robust generalized edge-count test.
</p>
</li>
<li><p> asy.gen.pval.adj - the adjusted asymptotic theory based p value of robust generalized edge-count test.
</p>
</li>
<li><p> perm.gen.pval - permutation-based p value of robust generalized edge-count test, appear when permutation-based p-value is calculated.
</p>
</li>
<li><p> perm.gen.pval.adj - the adjusted permutation-based p value of robust generalized edge-count test, appear when permutation-based p-value is calculated.
</p>
</li>
<li><p> asy.wei.statistic - test statistic of robust weighted edge-count test.
</p>
</li>
<li><p> asy.wei.pval - asymptotic theory based p value of robust weighted edge-count test.
</p>
</li>
<li><p> asy.wei.pval.adj - the adjusted asymptotic theory based p value of robust weighted edge-count test.
</p>
</li>
<li><p> perm.wei.pval - permutation-based p value of robust weighted edge-count test, appear when permutation-based p-value is calculated.
</p>
</li>
<li><p> perm.wei.pval.adj - the adjusted permutation-based p value of robust weighted edge-count test, appear when permutation-based p-value is calculated.
</p>
</li>
<li><p> asy.max.statistic - test statistic of robust max-type edge-count tests.
</p>
</li>
<li><p> asy.max.pval - asymptotic theory based p value of robust max-type edge-count tests.
</p>
</li>
<li><p> asy.max.pval.adj - the adjusted asymptotic theory based p value of robust max-type edge-count tests.
</p>
</li>
<li><p> perm.max.pval - permutation-based p value of robust max-type edge-count tests, appear when permutation-based p-value is calculated.
</p>
</li>
<li><p> perm.max.pval.adj - the adjusted permutation-based p value of robust max-type edge-count tests, appear when permutation-based p-value is calculated.
</p>
</li></ul>



<h3>References</h3>

<p>Bai, Y., &amp; Chu, L. (2023). A Robust Framework for Graph-based Two-Sample Tests Using Weights. arXiv preprint arXiv:2307.12325.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(toydata)

seu &lt;- toydata$seu
pathway_list &lt;- toydata$pathway_list

CAESAR.enrich.pathway(seu, pathway_list)
</code></pre>

<hr>
<h2 id='CAESAR.enrich.score'>Calculate Spot Level Enrichment Scores for Pathways Using CAESAR</h2><span id='topic+CAESAR.enrich.score'></span>

<h3>Description</h3>

<p>This function calculates spot level enrichment scores for a list of pathways based on a cell-gene distance matrix in a Seurat object. The function uses a permutation-based approach to determine the significance of the enrichment scores.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CAESAR.enrich.score(
  seu,
  pathwaylist,
  assay.dist = "distce",
  reduction.name = "caesar",
  gene.use = NULL,
  n_fake = 1001,
  seed = 1
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CAESAR.enrich.score_+3A_seu">seu</code></td>
<td>
<p>A Seurat object containing the gene expression data.</p>
</td></tr>
<tr><td><code id="CAESAR.enrich.score_+3A_pathwaylist">pathwaylist</code></td>
<td>
<p>A list of pathways, where each pathway is represented by a vector of genes.</p>
</td></tr>
<tr><td><code id="CAESAR.enrich.score_+3A_assay.dist">assay.dist</code></td>
<td>
<p>A character string specifying the assay that contains the distance matrix. Default is &quot;distce&quot;.</p>
</td></tr>
<tr><td><code id="CAESAR.enrich.score_+3A_reduction.name">reduction.name</code></td>
<td>
<p>A character string specifying the reduction method to use if the distance matrix needs to be computed. Default is &quot;caesar&quot;.</p>
</td></tr>
<tr><td><code id="CAESAR.enrich.score_+3A_gene.use">gene.use</code></td>
<td>
<p>A character vector specifying which genes to use in the analysis. If <code>NULL</code>, all genes in the distance matrix will be used. Default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="CAESAR.enrich.score_+3A_n_fake">n_fake</code></td>
<td>
<p>An integer specifying the number of random permutations to generate for significance testing. Default is 1001.</p>
</td></tr>
<tr><td><code id="CAESAR.enrich.score_+3A_seed">seed</code></td>
<td>
<p>An integer specifying the random seed for reproducibility. Default is 1.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of enrichment scores with cells as rows and pathways as columns.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(toydata)

seu &lt;- toydata$seu
pathway_list &lt;- toydata$pathway_list

enrich.score &lt;- CAESAR.enrich.score(seu, pathway_list)
head(enrich.score)

</code></pre>

<hr>
<h2 id='CAESAR.RUV'>Perform Batch Correction and Integration with CAESAR Using Housekeeping Genes</h2><span id='topic+CAESAR.RUV'></span>

<h3>Description</h3>

<p>This function performs batch correction and integration of multiple Seurat objects using housekeeping genes and distance matrices. It supports human and mouse data, and can optionally use custom housekeeping genes provided by the user.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CAESAR.RUV(
  seuList,
  distList,
  verbose = FALSE,
  species = "human",
  custom_housekeep = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CAESAR.RUV_+3A_seulist">seuList</code></td>
<td>
<p>A list of Seurat objects to be integrated.</p>
</td></tr>
<tr><td><code id="CAESAR.RUV_+3A_distlist">distList</code></td>
<td>
<p>A list of distance matrices corresponding to each Seurat object in 'seuList'.</p>
</td></tr>
<tr><td><code id="CAESAR.RUV_+3A_verbose">verbose</code></td>
<td>
<p>Logical, indicating whether to display progress messages. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="CAESAR.RUV_+3A_species">species</code></td>
<td>
<p>A character string specifying the species, either &quot;human&quot; or &quot;mouse&quot;. Default is &quot;human&quot;.</p>
</td></tr>
<tr><td><code id="CAESAR.RUV_+3A_custom_housekeep">custom_housekeep</code></td>
<td>
<p>A character vector of custom housekeeping genes. If <code>NULL</code>, default housekeeping genes for the species are used. Default is <code>NULL</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A Seurat object that contains the integrated and batch-corrected data in a new assay called &quot;CAESAR&quot;.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(toydata)

seu &lt;- toydata$seu
markers &lt;- toydata$markers

seu &lt;- ProFAST::pdistance(seu, reduction = "caesar")

marker.freq &lt;- markerList2mat(list(markers))
anno_res &lt;- CAESAR.annotation(seu, marker.freq, cal.confidence = FALSE, cal.proportions = FALSE)

seuList &lt;- list(seu, seu)
distList &lt;- list(anno_res$ave.dist, anno_res$ave.dist)
seuInt &lt;- CAESAR.RUV(seuList, distList, species = "human", verbose = TRUE)

</code></pre>

<hr>
<h2 id='Cauchy.Combination'>Combine p-values Using the Cauchy Combination Method</h2><span id='topic+Cauchy.Combination'></span>

<h3>Description</h3>

<p>This function combines multiple p-values using the Cauchy combination method. The method is particularly useful for combining dependent p-values and is known for being robust and powerful, especially in the context of small p-values. For details, see Liu and Xie (2020).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Cauchy.Combination(pvals, weight = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Cauchy.Combination_+3A_pvals">pvals</code></td>
<td>
<p>A numeric vector of p-values to be combined. The p-values should be between 0 and 1.</p>
</td></tr>
<tr><td><code id="Cauchy.Combination_+3A_weight">weight</code></td>
<td>
<p>A numeric vector of weights corresponding to the p-values. If <code>NULL</code>, equal weights are assigned to all p-values. Default is <code>NULL</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A single combined p-value.
</p>


<h3>References</h3>

<p>Liu, Y., &amp; Xie, J. (2020). Cauchy combination test: a powerful test with analytic p-value calculation under arbitrary dependency structures. Journal of the American Statistical Association, 115(529), 393-402.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example usage:
pvals &lt;- c(0.01, 0.03, 0.05)
combined_pval &lt;- Cauchy.Combination(pvals)
print(combined_pval)

</code></pre>

<hr>
<h2 id='cellembedding_image_matrix'>Compute Spatial-Aware Cell Embeddings with Image Information</h2><span id='topic+cellembedding_image_matrix'></span>

<h3>Description</h3>

<p>This function computes low-dimensional cell embeddings from a gene-by-cell matrix. The method initializes cell embeddings using approximate PCA and refines them through a linear factor model nested a intrinsical conditional autoregressive model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cellembedding_image_matrix(
  X,
  adjm,
  q = 50,
  reduction.name = "caesar",
  maxIter = 30,
  epsELBO = 1e-06,
  approx_Phi = FALSE,
  verbose = TRUE,
  Phi_diag = TRUE,
  seed = 1
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cellembedding_image_matrix_+3A_x">X</code></td>
<td>
<p>A gene-by-cell matrix (e.g., the 'data' slot from a Seurat object) that serves as the input data for dimensional reduction.</p>
</td></tr>
<tr><td><code id="cellembedding_image_matrix_+3A_adjm">adjm</code></td>
<td>
<p>A spatial adjacency matrix representing relationships between cells or spots.</p>
</td></tr>
<tr><td><code id="cellembedding_image_matrix_+3A_q">q</code></td>
<td>
<p>An integer specifying the number of dimensions for the reduced embeddings. Default is 50.</p>
</td></tr>
<tr><td><code id="cellembedding_image_matrix_+3A_reduction.name">reduction.name</code></td>
<td>
<p>A character string specifying the name of the dimensional reduction method. Default is 'caesar'.</p>
</td></tr>
<tr><td><code id="cellembedding_image_matrix_+3A_maxiter">maxIter</code></td>
<td>
<p>Maximum number of iterations for the optimization algorithm. Default is 30.</p>
</td></tr>
<tr><td><code id="cellembedding_image_matrix_+3A_epselbo">epsELBO</code></td>
<td>
<p>A small number specifying the convergence threshold for the optimization algorithm. Default is 1e-6.</p>
</td></tr>
<tr><td><code id="cellembedding_image_matrix_+3A_approx_phi">approx_Phi</code></td>
<td>
<p>Logical, indicating whether to use the approximate method for Phi matrix estimation. Default is FALSE.</p>
</td></tr>
<tr><td><code id="cellembedding_image_matrix_+3A_verbose">verbose</code></td>
<td>
<p>Logical, indicating whether to print progress messages. Default is TRUE.</p>
</td></tr>
<tr><td><code id="cellembedding_image_matrix_+3A_phi_diag">Phi_diag</code></td>
<td>
<p>Logical, indicating whether to constrain the Phi matrix to be diagonal. Default is TRUE.</p>
</td></tr>
<tr><td><code id="cellembedding_image_matrix_+3A_seed">seed</code></td>
<td>
<p>An integer used to set the random seed for reproducibility. Default is 1.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix containing the computed cell embeddings. The number of rows corresponds to the number of cells, and the number of columns corresponds to the specified number of dimensions ('q').
</p>

<hr>
<h2 id='cellembedding_image_seurat'>Compute Spatial-Aware Cell Embeddings with Image Information</h2><span id='topic+cellembedding_image_seurat'></span>

<h3>Description</h3>

<p>This function computes low-dimensional cell embeddings from a seyrat object. The method initializes cell embeddings using approximate PCA and refines them through a linear factor model nested a intrinsical conditional autoregressive model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cellembedding_image_seurat(
  seu,
  adjm,
  assay = NULL,
  slot = "data",
  q = 10,
  approx_Phi = FALSE,
  reduction.name = "caesar",
  var.features = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cellembedding_image_seurat_+3A_seu">seu</code></td>
<td>
<p>A Seurat object containing gene expression data. The object should have variable features identified prior to running this function.</p>
</td></tr>
<tr><td><code id="cellembedding_image_seurat_+3A_adjm">adjm</code></td>
<td>
<p>A spatial adjacency matrix representing relationships between cells or spots.</p>
</td></tr>
<tr><td><code id="cellembedding_image_seurat_+3A_assay">assay</code></td>
<td>
<p>A character string specifying which assay to use from the Seurat object. If NULL, the function will use the default assay set in the Seurat object.</p>
</td></tr>
<tr><td><code id="cellembedding_image_seurat_+3A_slot">slot</code></td>
<td>
<p>The data slot to use for feature extraction (e.g., &quot;data&quot;, &quot;scale.data&quot;). Default is &quot;data&quot;.</p>
</td></tr>
<tr><td><code id="cellembedding_image_seurat_+3A_q">q</code></td>
<td>
<p>An integer specifying the number of dimensions for the reduced embeddings. Default is 10.</p>
</td></tr>
<tr><td><code id="cellembedding_image_seurat_+3A_approx_phi">approx_Phi</code></td>
<td>
<p>Logical, indicating whether to use an approximate method for estimating the Phi matrix. Default is FALSE.</p>
</td></tr>
<tr><td><code id="cellembedding_image_seurat_+3A_reduction.name">reduction.name</code></td>
<td>
<p>A character string specifying the name for the dimensional reduction result. Default is &quot;caesar&quot;.</p>
</td></tr>
<tr><td><code id="cellembedding_image_seurat_+3A_var.features">var.features</code></td>
<td>
<p>A vector of variable features (genes) to use for the analysis. If NULL, the function will automatically use the variable features stored in the Seurat object.</p>
</td></tr>
<tr><td><code id="cellembedding_image_seurat_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to 'cellembedding_image_matrix'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The modified Seurat object with the cell embedding results stored in the specified dimensional reduction slot.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cellembedding_image_matrix">cellembedding_image_matrix</a></code> for additional arguments used to compute cell embeddings.
</p>

<hr>
<h2 id='cellembedding_matrix'>Compute Spatial-Aware Cell Embeddings</h2><span id='topic+cellembedding_matrix'></span>

<h3>Description</h3>

<p>This function computes low-dimensional cell embeddings from a gene-by-cell matrix. The method initializes cell embeddings using approximate PCA and refines them through a linear factor model nested a intrinsical conditional autoregressive model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cellembedding_matrix(X, adjm, q = 50, reduction.name = "caesar", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cellembedding_matrix_+3A_x">X</code></td>
<td>
<p>A gene-by-cell matrix (e.g., the 'data' slot from a Seurat object) that serves as the input data for dimensional reduction.</p>
</td></tr>
<tr><td><code id="cellembedding_matrix_+3A_adjm">adjm</code></td>
<td>
<p>A spatial adjacency matrix representing the relationships between cells or spots in spatial transcriptomic data.</p>
</td></tr>
<tr><td><code id="cellembedding_matrix_+3A_q">q</code></td>
<td>
<p>An integer specifying the number of dimensions to reduce to. Default is 50.</p>
</td></tr>
<tr><td><code id="cellembedding_matrix_+3A_reduction.name">reduction.name</code></td>
<td>
<p>A character string specifying the name of the dimensional reduction method. Default is 'caesar'.</p>
</td></tr>
<tr><td><code id="cellembedding_matrix_+3A_...">...</code></td>
<td>
<p>Additional parameters passed to 'ProFAST::FAST_run'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix containing the computed cell embeddings. The number of rows corresponds to the number of cells, and the number of columns corresponds to the specified number of dimensions ('q').
</p>


<h3>See Also</h3>

<p><code><a href="ProFAST.html#topic+FAST_run">FAST_run</a></code> for the main FAST dimensionality reduction algorithm.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(toydata)

seu &lt;- toydata$seu
pos &lt;- toydata$pos

adjm &lt;- ProFAST::AddAdj(as.matrix(pos), radius.upper = 200)
X &lt;- Seurat::GetAssayData(object = seu, slot = "data", assay = "RNA")
cellembedding &lt;- cellembedding_matrix(
    X = X,
    adjm = adjm
)
print(cellembedding[1:3, 1:3])
</code></pre>

<hr>
<h2 id='cellembedding_seurat'>Perform CAESAR embedding of Cells Using FAST with Spatial Weights</h2><span id='topic+cellembedding_seurat'></span>

<h3>Description</h3>

<p>This function computes cell embedding using the CAESAR framework with FAST for dimensionality reduction and spatial adjacency weights. It integrates variable feature selection and spatial adjacency information to generate low-dimensional representations for cells.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cellembedding_seurat(
  seu,
  adjm,
  assay = NULL,
  slot = "data",
  nfeatures = 2000,
  q = 50,
  reduction.name = "caesar",
  var.features = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cellembedding_seurat_+3A_seu">seu</code></td>
<td>
<p>A Seurat object. The Seurat object should contain gene expression data and be preprocessed with variable features identified.</p>
</td></tr>
<tr><td><code id="cellembedding_seurat_+3A_adjm">adjm</code></td>
<td>
<p>A spatial adjacency matrix representing the relationships between cells or spots in spatial transcriptomic data.</p>
</td></tr>
<tr><td><code id="cellembedding_seurat_+3A_assay">assay</code></td>
<td>
<p>A character string specifying which assay to use from the Seurat object. If NULL, the function will use the default assay.</p>
</td></tr>
<tr><td><code id="cellembedding_seurat_+3A_slot">slot</code></td>
<td>
<p>The data slot to use for feature extraction (e.g., &quot;data&quot;, &quot;counts&quot;). Default is &quot;data&quot;.</p>
</td></tr>
<tr><td><code id="cellembedding_seurat_+3A_nfeatures">nfeatures</code></td>
<td>
<p>The number of features to select for analysis. Default is 2000.</p>
</td></tr>
<tr><td><code id="cellembedding_seurat_+3A_q">q</code></td>
<td>
<p>An integer specifying the number of dimensions for the reduced embeddings. Default is 50.</p>
</td></tr>
<tr><td><code id="cellembedding_seurat_+3A_reduction.name">reduction.name</code></td>
<td>
<p>A character string specifying the name for the dimensional reduction. Default is &quot;caesar&quot;.</p>
</td></tr>
<tr><td><code id="cellembedding_seurat_+3A_var.features">var.features</code></td>
<td>
<p>A vector of variable features (genes) to use for the embedding. If NULL, the function will use variable features stored in the Seurat object.</p>
</td></tr>
<tr><td><code id="cellembedding_seurat_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to 'FAST_run'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The modified Seurat object with the co-embedding results (cell and gene embeddings) stored in the specified dimensional reduction slot.
</p>


<h3>See Also</h3>

<p><code><a href="ProFAST.html#topic+FAST_run">FAST_run</a></code> for the main FAST dimensionality reduction algorithm.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(toydata)

seu &lt;- toydata$seu
pos &lt;- toydata$pos

adjm &lt;- ProFAST::AddAdj(as.matrix(pos), radius.upper = 200)
seu &lt;- cellembedding_seurat(
    seu = seu,
    adjm = adjm
)
print(seu)
</code></pre>

<hr>
<h2 id='CoUMAP'>Co-embedding UMAP for Genes and Cells in a Seurat Object</h2><span id='topic+CoUMAP'></span>

<h3>Description</h3>

<p>This function performs a co-embedding UMAP of both gene and cell embeddings from a Seurat object. It integrates the dimensionality reduction results for genes and cells into a shared UMAP space.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CoUMAP(
  seu,
  reduction = "caesar",
  reduction.name = "caesarUMAP",
  gene.set = NULL,
  slot = "data",
  assay = "RNA",
  seed = 1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CoUMAP_+3A_seu">seu</code></td>
<td>
<p>A Seurat object containing the single-cell RNA-seq data.</p>
</td></tr>
<tr><td><code id="CoUMAP_+3A_reduction">reduction</code></td>
<td>
<p>A character string specifying the name of the dimensional reduction to use (e.g., &quot;caesar&quot;). Default is &quot;caesar&quot;.</p>
</td></tr>
<tr><td><code id="CoUMAP_+3A_reduction.name">reduction.name</code></td>
<td>
<p>A character string specifying the name of the new dimensional reduction slot in the Seurat object where the co-embedding UMAP will be stored. Default is &quot;caesarUMAP&quot;.</p>
</td></tr>
<tr><td><code id="CoUMAP_+3A_gene.set">gene.set</code></td>
<td>
<p>A character vector specifying the set of genes to include in the co-embedding. If <code>NULL</code>, all genes are used. Default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="CoUMAP_+3A_slot">slot</code></td>
<td>
<p>A character string specifying the slot in the Seurat object to use for gene expression data. Default is &quot;data&quot;.</p>
</td></tr>
<tr><td><code id="CoUMAP_+3A_assay">assay</code></td>
<td>
<p>A character string specifying the assay to use. Default is &quot;RNA&quot;.</p>
</td></tr>
<tr><td><code id="CoUMAP_+3A_seed">seed</code></td>
<td>
<p>An integer specifying the random seed for reproducibility. Default is 1.</p>
</td></tr>
<tr><td><code id="CoUMAP_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code>scater::calculateUMAP</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function extracts the embeddings for both genes and cells from the specified dimensional reduction, combines them, and computes a UMAP embedding. The resulting co-embedding UMAP is stored in a new dimensional reduction slot in the Seurat object.
</p>


<h3>Value</h3>

<p>A modified Seurat object with the co-embedding UMAP stored in the specified <code>reduction.name</code> slot.
</p>


<h3>See Also</h3>

<p><code><a href="scater.html#topic+calculateUMAP">calculateUMAP</a></code> for UMAP calculation.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(toydata)

seu &lt;- toydata$seu

seu &lt;- CoUMAP(seu, gene.set = rownames(seu))
print(seu)
</code></pre>

<hr>
<h2 id='CoUMAP.plot'>Plot Co-embedding UMAP for Genes and Cells</h2><span id='topic+CoUMAP.plot'></span>

<h3>Description</h3>

<p>This function generates a UMAP plot for co-embedding genes and cells in a Seurat object. It allows for customization of point colors, shapes, and text labels, and can display both gene and cell embeddings in the same plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CoUMAP.plot(
  seu,
  reduction = "caesarUMAP",
  gene_txtdata = NULL,
  ident = NULL,
  xy_name = reduction,
  dims = c(1, 2),
  cols = NULL,
  shape_cg = c(1, 5),
  pt_size = 1,
  pt_text_size = 5,
  base_size = 16,
  base_family = "serif",
  legend.point.size = 5,
  legend.key.size = 1.5,
  alpha = 0.8
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CoUMAP.plot_+3A_seu">seu</code></td>
<td>
<p>A Seurat object containing the co-embedding data.</p>
</td></tr>
<tr><td><code id="CoUMAP.plot_+3A_reduction">reduction</code></td>
<td>
<p>A character string specifying the name of the dimensional reduction to use for the UMAP plot. Default is &quot;caesarUMAP&quot;.</p>
</td></tr>
<tr><td><code id="CoUMAP.plot_+3A_gene_txtdata">gene_txtdata</code></td>
<td>
<p>A data frame containing gene names and labels to display as text on the plot. If <code>NULL</code>, no text labels are shown. Default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="CoUMAP.plot_+3A_ident">ident</code></td>
<td>
<p>A character string specifying the column name in the Seurat object's metadata that contains cell type or cluster labels. If <code>NULL</code>, the default identities (<code>Idents(seu)</code>) are used. Default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="CoUMAP.plot_+3A_xy_name">xy_name</code></td>
<td>
<p>A character string specifying the prefix for the UMAP axes. Default is the value of <code>reduction</code>.</p>
</td></tr>
<tr><td><code id="CoUMAP.plot_+3A_dims">dims</code></td>
<td>
<p>A numeric vector of length 2 specifying which dimensions to plot. Default is <code>c(1, 2)</code>.</p>
</td></tr>
<tr><td><code id="CoUMAP.plot_+3A_cols">cols</code></td>
<td>
<p>A named vector of colors for clusters. If <code>NULL</code>, default colors are generated. Default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="CoUMAP.plot_+3A_shape_cg">shape_cg</code></td>
<td>
<p>A numeric vector of length 2 specifying the shapes for cells and genes. Default is <code>c(1, 5)</code>.</p>
</td></tr>
<tr><td><code id="CoUMAP.plot_+3A_pt_size">pt_size</code></td>
<td>
<p>Numeric, specifying the size of the points for cells and genes. Default is 1.</p>
</td></tr>
<tr><td><code id="CoUMAP.plot_+3A_pt_text_size">pt_text_size</code></td>
<td>
<p>Numeric, specifying the size of the text labels for genes. Default is 5.</p>
</td></tr>
<tr><td><code id="CoUMAP.plot_+3A_base_size">base_size</code></td>
<td>
<p>Numeric, specifying the base font size for the plot. Default is 16.</p>
</td></tr>
<tr><td><code id="CoUMAP.plot_+3A_base_family">base_family</code></td>
<td>
<p>Character string specifying the font family for the plot. Default is &quot;serif&quot;.</p>
</td></tr>
<tr><td><code id="CoUMAP.plot_+3A_legend.point.size">legend.point.size</code></td>
<td>
<p>Numeric, specifying the size of the points in the legend. Default is 5.</p>
</td></tr>
<tr><td><code id="CoUMAP.plot_+3A_legend.key.size">legend.key.size</code></td>
<td>
<p>Numeric, specifying the size of the legend keys. Default is 1.5.</p>
</td></tr>
<tr><td><code id="CoUMAP.plot_+3A_alpha">alpha</code></td>
<td>
<p>Numeric, specifying the transparency level for cell points. Default is 0.8.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function creates a UMAP plot that shows both gene and cell embeddings. Gene embeddings can be optionally labeled with text, and the plot can be customized with different colors, shapes, and sizes.
</p>


<h3>Value</h3>

<p>A ggplot object representing the UMAP plot.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+CoUMAP">CoUMAP</a></code> for obtain co-embedding UMAP.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(toydata)

seu &lt;- toydata$seu

seu &lt;- CoUMAP(seu, gene.set = rownames(seu))
CoUMAP.plot(seu)

</code></pre>

<hr>
<h2 id='find.sig.genes'>Identify Signature Genes for Each Cell Type</h2><span id='topic+find.sig.genes'></span>

<h3>Description</h3>

<p>This function identifies signature genes for each cell type or cell group in a Seurat object using a co-embedding distance-based approach. It computes the average expression and distance metrics for each gene across different groups, while also considering expression proportions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find.sig.genes(
  seu,
  distce.assay = "distce",
  ident = NULL,
  expr.prop.cutoff = 0.1,
  assay = NULL,
  genes.use = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="find.sig.genes_+3A_seu">seu</code></td>
<td>
<p>A Seurat object containing gene expression data.</p>
</td></tr>
<tr><td><code id="find.sig.genes_+3A_distce.assay">distce.assay</code></td>
<td>
<p>A character string specifying the assay that contains the distance matrix or distance-related data. Default is &quot;distce&quot;.</p>
</td></tr>
<tr><td><code id="find.sig.genes_+3A_ident">ident</code></td>
<td>
<p>A character string specifying the column name in the 'meta.data' slot of the Seurat object used to define the identities (clusters or cell groups). If 'NULL', the default identities ('Idents(seu)') will be used. Default is 'NULL'.</p>
</td></tr>
<tr><td><code id="find.sig.genes_+3A_expr.prop.cutoff">expr.prop.cutoff</code></td>
<td>
<p>A numeric value specifying the minimum proportion of cells that must express a gene for it to be considered. Default is 0.1.</p>
</td></tr>
<tr><td><code id="find.sig.genes_+3A_assay">assay</code></td>
<td>
<p>A character string specifying the assay to use for expression data. If 'NULL', the default assay of the Seurat object will be used. Default is 'NULL'.</p>
</td></tr>
<tr><td><code id="find.sig.genes_+3A_genes.use">genes.use</code></td>
<td>
<p>A character vector specifying the genes to use for the analysis. If 'NULL', all genes in the 'distce.assay' assay will be used. Default is 'NULL'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list where each element corresponds to a cell group and contains a data frame with the following columns:
</p>
<table role = "presentation">
<tr><td><code>distance</code></td>
<td>
<p>The mean distance of the gene across the cells in the group.</p>
</td></tr>
<tr><td><code>expr.prop</code></td>
<td>
<p>The proportion of cells in the group expressing the gene.</p>
</td></tr>
<tr><td><code>expr.prop.others</code></td>
<td>
<p>The proportion of cells in other groups expressing the gene.</p>
</td></tr>
<tr><td><code>label</code></td>
<td>
<p>The identity label of the cell group.</p>
</td></tr>
<tr><td><code>gene</code></td>
<td>
<p>The gene name.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>None
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(toydata)

seu &lt;- toydata$seu

seu &lt;- ProFAST::pdistance(seu, reduction = "caesar")
sglist &lt;- find.sig.genes(
    seu = seu
)
str(sglist)

</code></pre>

<hr>
<h2 id='getneighborhood_fastcpp'>getneighborhood_fast</h2><span id='topic+getneighborhood_fastcpp'></span>

<h3>Description</h3>

<p>an efficient function to find the neighborhood based on the matrix of position and a pre-defined cutoff
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getneighborhood_fastcpp(x, radius)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getneighborhood_fastcpp_+3A_x">x</code></td>
<td>
<p>is a n-by-2 matrix of position.</p>
</td></tr>
<tr><td><code id="getneighborhood_fastcpp_+3A_radius">radius</code></td>
<td>
<p>is a threashold of Euclidean distance to decide whether a spot is an neighborhood of another spot. For example, if the Euclidean distance between spot A and B is less than cutoff, then A is taken as the neighbourhood of B.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A sparse matrix containing the neighbourhood
</p>

<hr>
<h2 id='Human_HK_genes'>Human housekeeping genes database</h2><span id='topic+Human_HK_genes'></span>

<h3>Description</h3>

<p>Human housekeeping genes database.
</p>


<h3>Details</h3>

<p>This data is a <a href="base.html#topic+data.frame">data.frame</a> and include the Human housekeeping genes information in the columns named &quot;Gene&quot;  and  &quot;Ensembl&quot;.
</p>

<hr>
<h2 id='Intsg'>Integrate Signature Genes Across Datasets</h2><span id='topic+Intsg'></span>

<h3>Description</h3>

<p>This function integrates signature genes across different datasets by identifying common genes that meet specific criteria. It filters out mitochondrial and ribosomal genes, allows for the exclusion of genes based on expression proportion, and supports weighting gene selection by cell type ratios.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Intsg(
  sg_List,
  ntop,
  ct_ratio = NULL,
  expr.prop.cutoff = 0.1,
  species = "hm",
  rm_mito_ribo = TRUE,
  ratio_lower_bound = 0
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Intsg_+3A_sg_list">sg_List</code></td>
<td>
<p>A list of signature gene lists for different datasets. Each element in the list should be a named list where the names correspond to cell types, and each cell type contains a data frame with gene information.</p>
</td></tr>
<tr><td><code id="Intsg_+3A_ntop">ntop</code></td>
<td>
<p>An integer specifying the maximum number of top genes to retain for each cell type.</p>
</td></tr>
<tr><td><code id="Intsg_+3A_ct_ratio">ct_ratio</code></td>
<td>
<p>A list of numeric vectors specifying the ratio of cells for each cell type in the datasets. If <code>NULL</code>, no weighting is applied. Default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="Intsg_+3A_expr.prop.cutoff">expr.prop.cutoff</code></td>
<td>
<p>A numeric value specifying the minimum expression proportion required for a gene to be considered. Default is 0.1.</p>
</td></tr>
<tr><td><code id="Intsg_+3A_species">species</code></td>
<td>
<p>A character string specifying the species, either &quot;hm&quot; (human) or &quot;ms&quot; (mouse). Default is &quot;hm&quot;.</p>
</td></tr>
<tr><td><code id="Intsg_+3A_rm_mito_ribo">rm_mito_ribo</code></td>
<td>
<p>Logical, indicating whether to remove mitochondrial and ribosomal genes from the signature gene list. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="Intsg_+3A_ratio_lower_bound">ratio_lower_bound</code></td>
<td>
<p>A numeric value specifying the lower bound for the cell type ratio. Only cell types with a ratio above this bound are considered. Default is 0.0.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named list where each element corresponds to a cell type and contains the integrated list of top signature genes.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(toydata)

seu &lt;- toydata$seu

seu &lt;- ProFAST::pdistance(seu, reduction = "caesar")
sglist &lt;- find.sig.genes(seu = seu)
top2sgs &lt;- Intsg(list(sglist), ntop = 2)
print(top2sgs)

top2intsgs &lt;- Intsg(list(sglist, sglist), ntop = 2)

</code></pre>

<hr>
<h2 id='marker.select'>Select Marker Genes from a signature gene list Based on Expression Proportion and Overlap Criteria</h2><span id='topic+marker.select'></span>

<h3>Description</h3>

<p>This function selects marker genes for each cluster or cell type based on expression proportion, with options to remove mitochondrial and ribosomal genes, limit the maximum number of top marker genes, and control the overlap between markers across clusters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>marker.select(
  ref_sig_list,
  expr.prop.cutoff = 0.1,
  ntop.max = 200,
  overlap.max = 1,
  rm_mito_ribo = FALSE,
  species = "ms"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="marker.select_+3A_ref_sig_list">ref_sig_list</code></td>
<td>
<p>A list where each element corresponds to a cluster or cell type. Each element should be a data frame containing at least two columns: <code>gene</code> (the gene names) and <code>expr.prop</code> (the proportion of cells expressing each gene). Generally, it is the output of function <code>find.sig.genes</code>.</p>
</td></tr>
<tr><td><code id="marker.select_+3A_expr.prop.cutoff">expr.prop.cutoff</code></td>
<td>
<p>A numeric value specifying the minimum proportion of cells that must express a gene for it to be considered. Default is 0.1.</p>
</td></tr>
<tr><td><code id="marker.select_+3A_ntop.max">ntop.max</code></td>
<td>
<p>An integer specifying the maximum number of top marker genes to be selected. Default is 200.</p>
</td></tr>
<tr><td><code id="marker.select_+3A_overlap.max">overlap.max</code></td>
<td>
<p>An integer specifying the maximum allowable overlap of marker genes across clusters. If a gene appears in more than <code>overlap.max</code> clusters, it will be excluded. Default is 1.</p>
</td></tr>
<tr><td><code id="marker.select_+3A_rm_mito_ribo">rm_mito_ribo</code></td>
<td>
<p>Logical, indicating whether to remove mitochondrial and ribosomal genes from the marker gene list. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="marker.select_+3A_species">species</code></td>
<td>
<p>A character string specifying the species for mitochondrial and ribosomal gene detection. Options are &quot;ms&quot; for mouse or &quot;hs&quot; for human. Default is &quot;ms&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list where each element corresponds to a cluster and contains the selected marker genes. If no markers are found, a message is printed and <code>NULL</code> is returned.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+find.sig.genes">find.sig.genes</a></code> for signature gene list.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(toydata)

seu &lt;- toydata$seu

seu &lt;- ProFAST::pdistance(seu, reduction = "caesar")
sglist &lt;- find.sig.genes(seu = seu)

markers &lt;- marker.select(sglist, expr.prop.cutoff = 0.1, overlap.max = 1)
print(markers)

</code></pre>

<hr>
<h2 id='markerList2mat'>Convert Marker List to a Weighted Matrix</h2><span id='topic+markerList2mat'></span>

<h3>Description</h3>

<p>This function converts a list of marker genes for different cell types or clusters into a matrix, where rows represent cell types and columns represent marker genes. The matrix contains the frequency of each marker gene across the different cell types.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>markerList2mat(markerList)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="markerList2mat_+3A_markerlist">markerList</code></td>
<td>
<p>A list where each element contains marker genes for different cell types or clusters. Each element of the list is a named list, where the names are the cell types and the values are the marker genes for that cell type. Generally, it is a list of the output of function <code>marker.select</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with rows representing cell types and columns representing unique marker genes. The values in the matrix represent the frequency of each gene as a marker in the corresponding cell type.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+marker.select">marker.select</a></code> for select markers.
<code><a href="#topic+find.sig.genes">find.sig.genes</a></code> for signature gene list.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(toydata)

markers &lt;- toydata$markers

marker.freq &lt;- markerList2mat(list(markers))
print(marker.freq)

</code></pre>

<hr>
<h2 id='Mouse_HK_genes'>Mouse housekeeping genes database</h2><span id='topic+Mouse_HK_genes'></span>

<h3>Description</h3>

<p>Mouse housekeeping genes database.
</p>


<h3>Details</h3>

<p>This data is a <a href="base.html#topic+data.frame">data.frame</a> and include the mouse housekeeping genes information in the columns named &quot;Gene&quot;  and  &quot;Ensembl&quot;.
</p>

<hr>
<h2 id='SigScore'>Calculate Signature Score for Cell Clusters</h2><span id='topic+SigScore'></span>

<h3>Description</h3>

<p>This function calculates a signature score for cell clusters based on the embeddings of cells and genes in a Seurat object. The score measures how well the genes linked to specific clusters are separated in the embedding space. The function also supports returning a weighted mean score across all clusters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SigScore(seu, reduction, label, gclink, return.mean = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="SigScore_+3A_seu">seu</code></td>
<td>
<p>A Seurat object containing the single-cell RNA-seq data.</p>
</td></tr>
<tr><td><code id="SigScore_+3A_reduction">reduction</code></td>
<td>
<p>A character string specifying the name of the dimensional reduction to use (e.g., &quot;caesar&quot;).</p>
</td></tr>
<tr><td><code id="SigScore_+3A_label">label</code></td>
<td>
<p>A character string specifying the column name in the Seurat object's metadata that contains the cell type or cluster labels.</p>
</td></tr>
<tr><td><code id="SigScore_+3A_gclink">gclink</code></td>
<td>
<p>A data frame with two columns: 'gene' and 'cluster', where 'gene' corresponds to gene names and 'cluster' corresponds to the associated cell cluster.</p>
</td></tr>
<tr><td><code id="SigScore_+3A_return.mean">return.mean</code></td>
<td>
<p>Logical, indicating whether to return the weighted mean signature score across all clusters. If <code>FALSE</code>, returns the score for each gene-cluster pair. Default is <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function computes the distance between gene embeddings and cell embeddings using a custom distance metric. It then calculates a score for each gene-cluster pair by evaluating how well the genes associated with a specific cluster are ordered in proximity to the cells of that cluster. The score is normalized between 0 and 1, where 1 indicates perfect separation.
</p>


<h3>Value</h3>

<p>If <code>return.mean = TRUE</code>, a numeric value representing the weighted mean signature score across all clusters. If <code>return.mean = FALSE</code>, a numeric vector containing the signature score for each gene-cluster pair.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(Seurat)
data(toydata)

seu &lt;- toydata$seu

seu$cluster &lt;- Idents(seu)

gclink &lt;- data.frame(
    gene = c(
        "FBLN1", "CCDC80", "LYPD3", "MLPH", "HOXD9", "EGFL7",
        "HAVCR2", "IGSF6", "KRT5", "KRT6B", "CD79A", "DERL3",
        "CAV1", "AVPR1A", "CD3G", "CD3D"
    ),
    cluster = c(
        "CAFs", "CAFs", "Cancer Epithelial", "Cancer Epithelial",
        "Endothelial", "Endothelial", "Myeloid", "Myeloid",
        "Normal Epithelial", "Normal Epithelial", "Plasmablasts",
        "Plasmablasts", "PVL", "PVL", "T-cells", "T-cells"
    )
)

score &lt;- SigScore(
    seu, reduction = "caesar", label = "cluster", gclink = gclink,
    return.mean = TRUE
)
print(score)

score &lt;- SigScore(
    seu, reduction = "caesar", label = "cluster",
    gclink = gclink, return.mean = FALSE
)
print(score)

</code></pre>

<hr>
<h2 id='toydata'>A toy dataset to run examples</h2><span id='topic+toydata'></span>

<h3>Description</h3>

<p>A list containing the following components:
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(toydata)
</code></pre>


<h3>Format</h3>

<p>A list with five components.
</p>

<ul>
<li><p> seu: A Seurat object, which is a subset of Xenium breast cancer section.
</p>
</li>
<li><p> pos: A data frame containing the location information of spots. Each row corresponds to a spatial spot, with columns for x and y coordinates.
</p>
</li>
<li><p> pathway_list: A list containing two pathways of intersecting. This list provides information about gene sets or pathways that are relevant to the dataset. Each element in the list is a character vector of gene names.
</p>
</li>
<li><p> markers: A list of marker genes for each cell type. This list maps cell types to their respective marker genes, which can be used for cell type annotation.
</p>
</li>
<li><p> imgf: A matrix containing histology image features. Each row corresponds to a spatial spot, and each column represents a different feature extracted from the histology image.
</p>
</li></ul>


</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
