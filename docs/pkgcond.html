<!DOCTYPE html><html><head><title>Help for package pkgcond</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {pkgcond}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#assert_that'><p>Scoped Assertions</p></a></li>
<li><a href='#collapse'><p>Collapse character Vectors</p></a></li>
<li><a href='#comma_list'><p>Construct a comma separated list</p></a></li>
<li><a href='#condition'><p>Raise a mutable and classed condition.</p></a></li>
<li><a href='#dot-underscore'><p>Format and Translate Strings</p></a></li>
<li><a href='#find_scope'><p>Find the default scope of a call.</p></a></li>
<li><a href='#infix-concatenation'><p>Infix string concatenation.</p></a></li>
<li><a href='#not-in'><p>Not in infix operator</p></a></li>
<li><a href='#skip_scope'><p>Exclude a function from find_scope</p></a></li>
<li><a href='#suppress'><p>Selectively suppress warnings and messages</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Classed Error and Warning Conditions</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.1</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Andrew Redd &lt;Andrew.Redd@hsc.utah.edu&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>This provides utilities for creating classed error and warning
  conditions based on where the error originated.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Depends:</td>
<td>R(&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>assertthat, methods</td>
</tr>
<tr>
<td>Suggests:</td>
<td>covr, testthat</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>Collate:</td>
<td>'assert_that.R' 'conditions.R' 'comma_list.R' 'find_scope.R'
'infix.R' 'skip_scope.R' 'suppress.R' 'translate.R'</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/RDocTaskForce/pkgcond">https://github.com/RDocTaskForce/pkgcond</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/RDocTaskForce/pkgcond/issues">https://github.com/RDocTaskForce/pkgcond/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-04-27 22:08:14 UTC; u0092104</td>
</tr>
<tr>
<td>Author:</td>
<td>Andrew Redd [aut, cre],
  R Documentation Task Force [aut]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-04-28 05:30:06 UTC</td>
</tr>
</table>
<hr>
<h2 id='assert_that'>Scoped Assertions</h2><span id='topic+assert_that'></span>

<h3>Description</h3>

<p>The pkgcond package intentionally overrides the <code><a href="assertthat.html#topic+assert_that">assertthat::assert_that()</a></code>
function.  It provides the same utility but enhances the original version
by throwing scoped and typed errors.  The type is 'assertion failure' and
the scope can be set or inferred from the calling frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>assert_that(
  ...,
  env = parent.frame(),
  msg = NULL,
  scope = find_scope(env),
  type = "assertion failure"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="assert_that_+3A_...">...</code></td>
<td>
<p>unnamed expressions that describe the conditions to be tested.
Rather than combining expressions with <code>&amp;&amp;</code>, separate them by commas
so that better error messages can be generated.</p>
</td></tr>
<tr><td><code id="assert_that_+3A_env">env</code></td>
<td>
<p>(advanced use only) the environment in which to evaluate the
assertions.</p>
</td></tr>
<tr><td><code id="assert_that_+3A_msg">msg</code></td>
<td>
<p>a custom error message to be printed if one of the conditions is
false.</p>
</td></tr>
<tr><td><code id="assert_that_+3A_scope">scope</code></td>
<td>
<p>The scope of the error.</p>
</td></tr>
<tr><td><code id="assert_that_+3A_type">type</code></td>
<td>
<p>The error type.</p>
</td></tr>
</table>

<hr>
<h2 id='collapse'>Collapse character Vectors</h2><span id='topic+collapse'></span><span id='topic+collapse0'></span>

<h3>Description</h3>

<p>Collapse character Vectors
</p>


<h3>Usage</h3>

<pre><code class='language-R'>collapse(x, with = " ")

collapse0(x, with = "")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="collapse_+3A_x">x</code></td>
<td>
<p>a character vector</p>
</td></tr>
<tr><td><code id="collapse_+3A_with">with</code></td>
<td>
<p>character to place between elements of x.</p>
</td></tr>
</table>

<hr>
<h2 id='comma_list'>Construct a comma separated list</h2><span id='topic+comma_list'></span>

<h3>Description</h3>

<p>Use this utility to create nicely formatted lists for error messages and the like.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>comma_list(x, sep = ", ", sep2 = " and ", sep.last = ", and ", terminator = "")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="comma_list_+3A_x">x</code></td>
<td>
<p>a list that can be converted into a character.</p>
</td></tr>
<tr><td><code id="comma_list_+3A_sep">sep</code></td>
<td>
<p>the typical separator</p>
</td></tr>
<tr><td><code id="comma_list_+3A_sep2">sep2</code></td>
<td>
<p>the separator to use in the case of only two elements.</p>
</td></tr>
<tr><td><code id="comma_list_+3A_sep.last">sep.last</code></td>
<td>
<p>the separator to use between the last and next to last elements when
there are at least 3 element in the list.</p>
</td></tr>
<tr><td><code id="comma_list_+3A_terminator">terminator</code></td>
<td>
<p>concatenated to the end after the list is concluded.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>comma_list(c("you", "I"))
comma_list(c("you", "I"), sep2=" &amp; ")
comma_list(head(letters), sep.last=', ', term=', ...')

</code></pre>

<hr>
<h2 id='condition'>Raise a mutable and classed condition.</h2><span id='topic+condition'></span><span id='topic+pkg_error'></span><span id='topic+pkg_warning'></span><span id='topic+pkg_message'></span>

<h3>Description</h3>

<p>Raising Classed conditions helps with catching errors.
These allow for typing errors as they arise and adding scopes
to better catch errors from specific locations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>condition(
  msg,
  cond = .conditions,
  ...,
  scope = find_scope(),
  type = NULL,
  call = sys.call(1)
)

pkg_error(msg, ..., scope = find_scope(), call = sys.call(1))

pkg_warning(msg, ..., scope = find_scope(), call = sys.call(1))

pkg_message(msg, ..., scope = find_scope(), call = sys.call(1))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="condition_+3A_msg">msg</code></td>
<td>
<p>The message to convey</p>
</td></tr>
<tr><td><code id="condition_+3A_cond">cond</code></td>
<td>
<p>The severity of the condition, or what to do;
give a 'message' (default), a 'warning', an 'error'
or do 'none' and ignore.</p>
</td></tr>
<tr><td><code id="condition_+3A_...">...</code></td>
<td>
<p>Attributes to be added to condition object for <code>condition</code>,
arguments passed to condition for all others.</p>
</td></tr>
<tr><td><code id="condition_+3A_scope">scope</code></td>
<td>
<p>A character vector of the scope(s) of the signal.
Defaults to the package name but could be longer such as
package name, a class name, and a method call.
This should be used as a where the error occurred.</p>
</td></tr>
<tr><td><code id="condition_+3A_type">type</code></td>
<td>
<p>Used with <code>scope</code> and <code>cond</code> to set the class of the condition object to raise.
This should be a type of error; out of bounds, type mismatch, etcetera.</p>
</td></tr>
<tr><td><code id="condition_+3A_call">call</code></td>
<td>
<p>The call to use to include in the condition.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>condition()</code> function alone provides a flexible and dynamic way of
producing conditions in code. The functions <code>pkg_error</code>, <code>pkg_warning</code>,
and <code>pkg_message</code> do the same as condition except restricted to errors, warnings,
and messages respectively.
</p>

<hr>
<h2 id='dot-underscore'>Format and Translate Strings</h2><span id='topic+dot-underscore'></span><span id='topic+._'></span>

<h3>Description</h3>

<p>This shortcut provides simple translation and formatting functionality.
Essentially it is a wrapper for <code><a href="base.html#topic+gettext">base::gettext()</a></code> and <code><a href="base.html#topic+sprintf">base::gettextf()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>._(msg, ..., domain = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dot-underscore_+3A_msg">msg</code></td>
<td>
<p>The message to translate.</p>
</td></tr>
<tr><td><code id="dot-underscore_+3A_...">...</code></td>
<td>

<p>Arguments passed on to <code><a href="base.html#topic+sprintf">base::gettextf</a></code>
</p>

<dl>
<dt><code>fmt</code></dt><dd><p>a character vector of format strings, each of up to 8192 bytes.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="dot-underscore_+3A_domain">domain</code></td>
<td>
<p>see <code><a href="base.html#topic+gettext">base::gettext()</a></code></p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>loki &lt;- list()
class(loki) &lt;- "puny god"
._("I am a %s.", class(loki))

</code></pre>

<hr>
<h2 id='find_scope'>Find the default scope of a call.</h2><span id='topic+find_scope'></span>

<h3>Description</h3>

<p>This find the scope of the call.
It includes the package of the call,
the class if called from a method,
and the name of the function called.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find_scope(frame = NULL, global = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="find_scope_+3A_frame">frame</code></td>
<td>
<p>The frame to infer scope from.</p>
</td></tr>
<tr><td><code id="find_scope_+3A_global">global</code></td>
<td>
<p>Should the global frame be listed in the scope.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
my_function &lt;- function(){
    scope &lt;- find_scope()
    "You are in" %&lt;&lt;% collapse(scope, '::')
}
my_function()

my_sights &lt;- my_function
my_sights()

</code></pre>

<hr>
<h2 id='infix-concatenation'>Infix string concatenation.</h2><span id='topic+infix-concatenation'></span><span id='topic++25+3C+3C+25'></span><span id='topic++25+5C+25'></span><span id='topic++25+3C+3C+3C+25'></span>

<h3>Description</h3>

<p>The infix operators listed here are three versions of paste.
</p>

<ul>
<li> <p><code>%\%</code> is for preserving line breaks
</p>
</li>
<li> <p><code>%&lt;&lt;%</code> is an infix replacement for <code><a href="base.html#topic+paste">paste</a></code>
</p>
</li>
<li> <p><code>%&lt;&lt;&lt;%</code> is paste with no space and no break.&quot;
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>lhs %&lt;&lt;% rhs

lhs %&lt;&lt;&lt;% rhs
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="infix-concatenation_+3A_lhs">lhs</code></td>
<td>
<p>left string</p>
</td></tr>
<tr><td><code id="infix-concatenation_+3A_rhs">rhs</code></td>
<td>
<p>right string</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
who &lt;- "world"
'hello_' %&lt;&lt;&lt;% who

'Sing with me' %&lt;&lt;% head(letters) %&lt;&lt;% '...'
</code></pre>

<hr>
<h2 id='not-in'>Not in infix operator</h2><span id='topic+not-in'></span><span id='topic++25+21in+25'></span>

<h3>Description</h3>

<p>The same as <code><a href="base.html#topic++25in+25">%in%</a></code> but negated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>x %!in% table
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="not-in_+3A_x">x</code></td>
<td>
<p>vector or <code>NULL</code>: the values to be matched.
<a href="base.html#topic+Long+20vectors">Long vectors</a> are supported.</p>
</td></tr>
<tr><td><code id="not-in_+3A_table">table</code></td>
<td>
<p>vector or <code>NULL</code>: the values to be matched against.
<a href="base.html#topic+Long+20vectors">Long vectors</a> are not supported.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>'A' %!in% letters #TRUE letters are lower case.
'A' %!in% LETTERS #FALSE LETTERS are upper case.

</code></pre>

<hr>
<h2 id='skip_scope'>Exclude a function from find_scope</h2><span id='topic+skip_scope'></span>

<h3>Description</h3>

<p>In the course of work it will often be the case that
one would like to create a new condition function, such
such as for specific errors or warning.  These should
not be included in the scope when inferred.  The natural
solution would be to include the scope in every call to
condition or have it inferred in each function definition.
This however, gets very tedious.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>skip_scope(fun)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="skip_scope_+3A_fun">fun</code></td>
<td>
<p>a function to tag</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>skip_scope</code> function tags a function as one that should be
excluded from consideration when determining scope via
<code><a href="#topic+find_scope">find_scope()</a></code>.
</p>


<h3>Value</h3>

<p>The <code>fun</code> function with the <code>skipscope</code> attribute set to TRUE.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>new_msg &lt;- function(where=find_scope()){
    "Hello from" %&lt;&lt;% where
}
new_postcard &lt;- function(msg){
    greeting &lt;- new_msg()
    paste0(greeting, '\n\n', msg)
}

cat(new_postcard("Not all is well"), '\n')
new_msg &lt;- skip_scope(new_msg)

cat(new_postcard("Now all is well"))
</code></pre>

<hr>
<h2 id='suppress'>Selectively suppress warnings and messages</h2><span id='topic+suppress'></span><span id='topic+suppress_conditions'></span><span id='topic+suppress_warnings'></span><span id='topic+suppress_messages'></span>

<h3>Description</h3>

<p>This collection of functions allow the suppression of condition messages,
warnings and messages, through filtering the condition message, the condition
class or a combination of the two.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>suppress_conditions(expr, pattern = NULL, class = NULL, ...)

suppress_warnings(expr, pattern = NULL, class = "warning", ...)

suppress_messages(expr, pattern = NULL, class = "message", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="suppress_+3A_expr">expr</code></td>
<td>
<p>An expression to evaluate.</p>
</td></tr>
<tr><td><code id="suppress_+3A_pattern">pattern</code></td>
<td>
<p>A regular expression pattern to match on.</p>
</td></tr>
<tr><td><code id="suppress_+3A_class">class</code></td>
<td>
<p>The class or classes that you would like to filter.
When more that one is given the condition may match any
of the classes.</p>
</td></tr>
<tr><td><code id="suppress_+3A_...">...</code></td>
<td>

<p>Arguments passed on to <code><a href="base.html#topic+grep">base::grepl</a></code>
</p>

<dl>
<dt><code>x</code></dt><dd><p>a character vector where matches are sought, or an
object which can be coerced by <code>as.character</code> to a character
vector.  <a href="base.html#topic+Long+20vectors">Long vectors</a> are supported.</p>
</dd>
<dt><code>ignore.case</code></dt><dd><p>if <code>FALSE</code>, the pattern matching is <em>case
sensitive</em> and if <code>TRUE</code>, case is ignored during matching.</p>
</dd>
<dt><code>perl</code></dt><dd><p>logical.  Should Perl-compatible regexps be used?</p>
</dd>
<dt><code>fixed</code></dt><dd><p>logical.  If <code>TRUE</code>, <code>pattern</code> is a string to be
matched as is.  Overrides all conflicting arguments.</p>
</dd>
<dt><code>useBytes</code></dt><dd><p>logical.  If <code>TRUE</code> the matching is done
byte-by-byte rather than character-by-character.  See
&lsquo;Details&rsquo;.</p>
</dd>
</dl>
</td></tr>
</table>


<h3>Functions</h3>


<ul>
<li> <p><code>suppress_conditions</code>: The general case of suppressing both messages and warnings.
</p>
</li>
<li> <p><code>suppress_warnings</code>: A convenience wrapper that specifies warning class to suppress.
</p>
</li>
<li> <p><code>suppress_messages</code>: A convenience wrapper that specifies warning class to suppress.
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
testit &lt;- function(){
    warning("this function does nothing.")
    warning("it's pretty useless.")
}
suppress_warning(testit(), "useless")  # Will suppress only the second warning by pattern


# If my_pkg used pkgcond for conditions,
# This would suppress all messages and warnings originating
# in my_pkg functions.
suppress_conditions(my_function(), class='my_pkg-condition')

## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
