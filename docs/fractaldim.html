<!DOCTYPE html><html><head><title>Help for package fractaldim</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {fractaldim}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#fractaldim-package'>
<p>Estimating Fractal Dimensions</p></a></li>
<li><a href='#fd.estim.method'><p>Estimation of Fractal Dimension via Specific Methods</p></a></li>
<li><a href='#fd.estimate'><p>Estimating Fractal Dimensions of Time Series and Two-dimensional Data</p></a></li>
<li><a href='#fd.get'><p>Access Method for Objects of Class FractalDim</p></a></li>
<li><a href='#fd.get.available.methods'><p>Available Estimation Methods</p></a></li>
<li><a href='#fractaldim-internal'><p>Internal Functions</p></a></li>
<li><a href='#get.rawFD.from.regression'>
<p>Obtaining Regression Object</p></a></li>
<li><a href='#summary.FractalDim'><p>Summary for an Object of Class FractalDim</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>0.8-5</td>
</tr>
<tr>
<td>Date:</td>
<td>2021-10-05</td>
</tr>
<tr>
<td>Title:</td>
<td>Estimation of Fractal Dimensions</td>
</tr>
<tr>
<td>Author:</td>
<td>Hana Sevcikova &lt;hanas@uw.edu&gt;, 
	Don Percival &lt;dbp@apl.washington.edu&gt;,
        Tilmann Gneiting &lt;tilmann@stat.washington.edu&gt;</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Hana Sevcikova &lt;hanas@uw.edu&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.11.0), abind</td>
</tr>
<tr>
<td>Suggests:</td>
<td>wavelets, pcaPP, RandomFields, snowFT</td>
</tr>
<tr>
<td>Description:</td>
<td>Implements various methods for estimating fractal dimension of time series and 2-dimensional data &lt;<a href="https://doi.org/10.1214%2F11-STS370">doi:10.1214/11-STS370</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-10-05 19:04:18 UTC; hana</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-10-07 08:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='fractaldim-package'>
Estimating Fractal Dimensions</h2><span id='topic+fractaldim-package'></span><span id='topic+fractaldim'></span>

<h3>Description</h3>

<p>Implements various methods for estimating fractal dimension of time series and 2-dimensional data.</p>


<h3>Details</h3>

<p>The package provides tools for estimating fractal dimension of one- or two-dimensional data, using methods described in Gneiting et al. (2010). The user can take an advantage of the available sliding window technique in which a window of a given size is slided along the data and an estimate is obtained for each position.
</p>
<p>The main function is <code><a href="#topic+fd.estimate">fd.estimate</a></code> which can be used for one dimensional time series, as well as for two dimensional data. It computes one estimate for each method and each sliding window. 
It is a wrapper for lower level functions for computing just one estimate on the given data, see <code><a href="#topic+fd.estim.method">fd.estim.method</a></code> for details.  
</p>


<h3>Author(s)</h3>

<p>Hana Sevcikova &lt;hanas@uw.edu&gt;, Tilmann Gneiting &lt;tilmann@stat.washington.edu&gt;, 
Don Percival &lt;dbp@apl.washington.edu&gt;
</p>
<p>Maintainer: Hana Sevcikova &lt;hanas@uw.edu&gt;
</p>


<h3>References</h3>

<p>Gneiting, T., Sevcikova, H. and Percival, D. B. (2012). Estimators of fractal dimension: Assessing the smoothness of time series and spatial data. Statistical Science, 27(2), 247-277. &lt;doi:10.1214/11-STS370&gt; (Version as technical report available at <a href="https://stat.uw.edu/sites/default/files/files/reports/2010/tr577.pdf">https://stat.uw.edu/sites/default/files/files/reports/2010/tr577.pdf</a>)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fd.estimate">fd.estimate</a></code>, <code><a href="#topic+fd.estim.method">fd.estim.method</a></code>
</p>

<hr>
<h2 id='fd.estim.method'>Estimation of Fractal Dimension via Specific Methods</h2><span id='topic+fd.estim.method'></span><span id='topic+fd.estim.variation'></span><span id='topic+fd.estim.variogram'></span><span id='topic+fd.estim.madogram'></span><span id='topic+fd.estim.rodogram'></span><span id='topic+fd.estim.genton'></span><span id='topic+fd.estim.incr1'></span><span id='topic+fd.estim.hallwood'></span><span id='topic+fd.estim.boxcount'></span><span id='topic+fd.estim.periodogram'></span><span id='topic+fd.estim.dctII'></span><span id='topic+fd.estim.wavelet'></span><span id='topic+fd.estim.transect.var'></span><span id='topic+fd.estim.transect.incr1'></span><span id='topic+fd.estim.isotropic'></span><span id='topic+fd.estim.squareincr'></span><span id='topic+fd.estim.filter1'></span>

<h3>Description</h3>

<p>The functions estimate a fractal dimension of the given data. Each function uses a different method. Functions for boxcount, hallwood, variogram, madogram, rodogram, variation, incr1, genton, periodogram, wavelet and dctII methods are to be used on one-dimensional time series. The remaining functions (transect, isotropic, squareincr, and filter1) are to be used on two-dimensional data. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fd.estim.boxcount (data, plot.loglog = FALSE, nlags = "auto", 
    shift.up=TRUE, plot.allpoints = FALSE, legend.type = 's', 
    ..., debuglevel = 0)
fd.estim.hallwood (data, plot.loglog = FALSE, nlags = "auto", 
    plot.allpoints = FALSE, legend.type = 's', ..., debuglevel = 0)
fd.estim.variogram (data, ...)
fd.estim.madogram (data, ...)
fd.estim.rodogram (data, ...)
fd.estim.variation (data, p.index = 1, ...)
fd.estim.incr1(data, p.index=2, ...)
fd.estim.genton (data, ...)
fd.estim.periodogram (data, plot.loglog = FALSE, nlags = "auto", ...)
fd.estim.wavelet (data, plot.loglog=FALSE, plot.allpoints = FALSE, 
    filter = "haar", J1 = max(1,floor(log2(length(data))/3-1)), 
    J0 = floor(log2(length(data))), legend.type = 's', 
    ..., debuglevel = 0)
fd.estim.dctII (data, plot.loglog = FALSE, nlags = "auto", ...)
    
fd.estim.transect.var (data, p.index = 2, ...)
fd.estim.transect.incr1 (data, p.index = 2, ...)
fd.estim.isotropic (data, p.index = 2, direction = 'hvd+d-',
    plot.loglog = FALSE, nlags = "auto", plot.allpoints = FALSE, 
    legend.type = 's', ..., debuglevel=0)
fd.estim.squareincr (data, p.index = 2, 
    plot.loglog = FALSE, nlags = "auto", plot.allpoints = FALSE, 
    legend.type = 's', ..., debuglevel=0)
fd.estim.filter1 (data, p.index = 2, direction = 'hvd+d-',
    plot.loglog = FALSE, nlags = "auto", plot.allpoints = FALSE, 
    legend.type = 's', ..., debuglevel=0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fd.estim.method_+3A_data">data</code></td>
<td>
<p>For the first eleven functions <code>data</code> is a one-dimensional vector. For the last five functions <code>data</code> is a matrix.</p>
</td></tr>
<tr><td><code id="fd.estim.method_+3A_p.index">p.index</code></td>
<td>
<p>Parameter <code class="reqn">p</code> of the variation method (see below).</p>
</td></tr>
<tr><td><code id="fd.estim.method_+3A_direction">direction</code></td>
<td>
<p>For the 2d estimators, this argument specifies the direction of the estimation (see details below). It can be any combination of the characters &lsquo;h&rsquo; (horizontal), &lsquo;v&rsquo; (vertical), &lsquo;d+&rsquo; (diagonal with positive gradient), and &lsquo;d-&rsquo; (diagonal with negative gradient). These characters should be combined into one string.</p>
</td></tr>
<tr><td><code id="fd.estim.method_+3A_plot.loglog">plot.loglog</code></td>
<td>
<p>Logical value determining if the underlying log-log
plots should be plotted.</p>
</td></tr>
<tr><td><code id="fd.estim.method_+3A_nlags">nlags</code></td>
<td>
<p>Number of lags to be used in the
estimation. Possible values are <code>"auto"</code>, <code>"all"</code> or a
single number.  If <code>nlags = "auto"</code>, each method sets the number of lags
to the theoretically &quot;best&quot; value for that method.  <code>"all"</code> means
that all lags are included in the estimation.</p>
</td></tr>
<tr><td><code id="fd.estim.method_+3A_shift.up">shift.up</code></td>
<td>
<p>For each interval on the horizontal axis, it moves the boxes vertically up to the smallest data point of that interval. If it is <code>FALSE</code>, all boxes are on a regular grid.</p>
</td></tr>
<tr><td><code id="fd.estim.method_+3A_plot.allpoints">plot.allpoints</code></td>
<td>
<p>Logical. If <code>FALSE</code>, only points that were considered in 
the regression are shown. Otherwise, all points of the log-log 
plot are shown in the graph and those considered in the regression are marked by filled circles.
This argument is only used if 
<code>plot.loglog = TRUE</code>.  Note that setting this argument to <code>TRUE</code> might (depending on the method)
considerably increase the computation run-time.</p>
</td></tr>
<tr><td><code id="fd.estim.method_+3A_filter">filter</code></td>
<td>
<p>Argument passed to the <code>modwt</code> function of the <span class="pkg">wavelets</span> package.</p>
</td></tr>
<tr><td><code id="fd.estim.method_+3A_j0">J0</code>, <code id="fd.estim.method_+3A_j1">J1</code></td>
<td>
<p>Parameters of the wavelet method controlling the number of frequencies used in the estimation.</p>
</td></tr>
<tr><td><code id="fd.estim.method_+3A_legend.type">legend.type</code></td>
<td>
<p>One of the characters 'f', 's', or 'n'. It controlls the amount of information in the legend of the log-log plot. If it is 'f' (full), values of fd and scale, including the raw values of the corresponding slope and intercept are shown. If it is 's' (short), only fd is shown. Value of 'n' (None) causes no legend being plotted. The argument is only used if <code>plot.loglog = TRUE</code>.</p>
</td></tr>
<tr><td><code id="fd.estim.method_+3A_...">...</code></td>
<td>
<p>Arguments passed to the plotting function if <code>plot.loglog = TRUE</code>. For some functions, ... contain additional arguments, see Details.</p>
</td></tr>
<tr><td><code id="fd.estim.method_+3A_debuglevel">debuglevel</code></td>
<td>
<p>Controls the amount of debugging
messages. The functions produce messages on level 5.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The methodology of these functions is based on the theory
described in Gneiting et al (2010). Please refer to this paper for notation. Here we give only a few comments about the implementation.
</p>

<dl>
<dt><em>Box-count
estimator:</em></dt><dd>
<p>The function <code>fd.estim.boxcount</code> determines the smallest possible value of <code class="reqn">m</code> 
for which <code class="reqn">n\leq 2^m</code> is a power of 2.  Only data points <code class="reqn">x_1,\dots,x_{n_{eff}}</code> are considered for the estimation, 
where <code class="reqn">n_{eff} = 2^{m-1}+1</code>.  The value of <code class="reqn">K</code> can be given by the user through the argument <code>nlags</code>.  If <code>nlags = "auto"</code>, box sizes <code class="reqn">\epsilon_k</code> for <code class="reqn">k=j,j+1,\dots,m-2</code> are considered, 
where for all <code class="reqn">i&lt;j</code> is <code class="reqn">N(\epsilon_i) &gt; \frac{n_{eff}}{5}</code>, i.e. 
the two largest box sizes and very small boxes are eliminated (corresponds to the
Liebovitch and Toth modification).
</p>
<p>If <code>shift.up=TRUE</code>, the algorithm shifts each vertical column of boxes up to the smallest data value in that column. 
</p>
<p><code class="reqn">N(\epsilon_k)</code> for a particular box is increased if either a data point is contained in the box, 
or if a line connecting two neighboring data points crosses the box.
</p>
</dd>
<dt><em>Hall-Wood estimator</em></dt><dd>
<p>This estimator is a version of box-count that 
instead of number of boxes considers the area of boxes that cover 
the underlying curve.  
Hall and Wood (1993) recommend
the use of <code class="reqn">L = 2</code> which the function <code>fd.estim.hallwood</code> uses
if the arguments <code>nlags = "auto"</code>.
</p>
</dd>
<dt><em>Variation, Variogram, Madogram, Rodogram, and Incr1 estimators:</em></dt><dd>
<p>The <code>p.index</code> argument of <code>fd.estim.variation</code> and <code>fd.estim.incr1</code> is the power index <code class="reqn">p</code>. The madogram, variogram, and rodogram, respectively, correspond to the Variation estimator with <code class="reqn">p</code> equals 1, 2, and 1/2, respectively. The Incr1 estimator is like Variation but based on second order differences.
</p>
<p>Any argument that can be passed to <code>fd.estim.hallwood</code> can be passed here as well. In addition,
as in the Hall-Wood case, <code class="reqn">L</code> is set to 2 for these estimators, if <code>nlags = "auto"</code>.
</p>
</dd>
<dt><em>Genton robust estimator:</em></dt><dd>
<p>This is a highly robust variogram estimator as proposed by Genton (1998). Given <code class="reqn">U_i(d) = X_{i/n} - X_{(i-d)/n}</code>, define
</p>
<p style="text-align: center;"><code class="reqn">
\hat{V}(d) = \left[2.2191\{|U_i(d) - U_j(d)|; i&lt;j \}_{(k)}\right]^2 ,
\quad \mbox{where} \;\; k={\lfloor (n-d)/2\rfloor +1 \choose 2}\,.</code>
</p>

<p>Thus, the estimator is derived from the <code class="reqn">k</code>-th quantile of the <code class="reqn">U_i(d)</code> values. The <code class="reqn">\hat{D}_k</code> estimator is derived from the log-log plot of <code class="reqn">\log(d)</code> against <code class="reqn">\log(\hat{V}(d))</code>. The implementation uses the <code>qn</code> function of the <span class="pkg">pcaPP</span> package to compute <code class="reqn">\hat{V}(d)</code>.
</p>
<p>Here again, the number of lags is set to 2 if  <code>nlags = "auto"</code> and any arguments of the <code>fd.estim.hallwood</code> are accepted here as well.
</p>
</dd>
<dt><em>Periodogram estimator:</em></dt><dd>
<p>The method is implemented as proposed by Chan et al. (1995) with notation from Gneiting et al (2010).  
</p>
<p>As Chan et al. (1995) recommend, we use <code class="reqn">L=\lfloor \min(m/2, n^{2/3})\rfloor</code> if <code>nlags = "auto"</code>. Any arguments of the <code>fd.estim.hallwood</code> are also accepted here.
</p>
</dd>
<dt><em>Wavelet estimator:</em></dt><dd><p>This method uses <code class="reqn">J_0</code> vectors of wavelet coefficients  which are obtained using the function <code>modwt</code> of the <span class="pkg">wavelets</span> package. The choice of <code>J0</code> and <code>J1</code> determine the number of frequencies used in the estimation.
</p>
</dd>
<dt><em>DCT-II estimator:</em></dt><dd><p>If <code>nlags = "auto"</code>, we use <code class="reqn">L=\lfloor \min(2m, 4n^{2/3})\rfloor</code>. Any arguments of the <code>fd.estim.hallwood</code> are also accepted here.
</p>
</dd>
</dl>

<p>The two-dimensional estimators are all based on the Variation method with the power index <code class="reqn">p</code> (argument <code>p.index</code>) with the following alternatives:
</p>

<dl>
<dt><em>Transect</em></dt><dd><p>For every given direction, a variation estimate (or a variant that uses second differences) is found in each row (for horizontal direction) and/or column (for vertical direction). The resulting estimate is the median over the set of estimates. In the function <code>fd.estim.transect.var</code> the line transect estimates are based on first differences; In the function <code>fd.estim.transect.incr1</code> they are based on second differences.
</p>
<p>This method does not support the feature of creating a log-log plot, since there are many log-log regressions from which the results are derived. The methods also accept arguments <code>direction</code>, <code>nlags</code> and <code>debuglevel</code>. </p>
</dd>
<dt><em>Isotropic</em></dt><dd><p>Davies and Hall (1999) on page 12 define the isotropic empirical variogram. This is here implemented more generally using the variation estimator. If <code>nlags = "auto"</code>, the number of lags is set to either 3 if diagonal direction is used together with either horizontal or vertical direction or both. If only horizontal or/and vertical direction is used, the number of lags is set to 2.</p>
</dd>
<dt><em>Square-increment</em></dt><dd><p>We use the square-increment estimator proposed in eqs. (4.2) through (4.7) of Chan and Wood (2000). Note that this method is equivalent to the Filter 3 approach of Zhu and Stein (2002) which is the way it is implemented in the package. The automatic setting of number of lags is done as for the Isotropic method.</p>
</dd>
<dt><em>Filter 1</em></dt><dd><p>Here,  the Filter 1 approach of Zhu and Stein (2002) is implemented. Again, the automatic setting of number of lags is done as for the Isotropic method.</p>
</dd>
</dl>

<p>For all methods (but Transect), if the argument <code>plot.loglog</code> is <code>TRUE</code>, a graph with the log-log plot is shown,
including the fitted regression line.  Only points included in the regression are plotted, unless the argument <code>plot.allpoints</code> is set to <code>TRUE</code>. In such a case, points used for fitting the regression line are marked by filled circles.
</p>
<p>For using multiple estimation methods via one function see <code><a href="#topic+fd.estimate">fd.estimate</a></code>.
</p>


<h3>Value</h3>

<p>Each function returns an object of class <code><a href="#topic+FractalDim">FractalDim</a></code> with elements:
</p>
<table>
<tr><td><code>dim</code></td>
<td>
<p>Here it is always 1.</p>
</td></tr>
<tr><td><code>fd</code>, <code>scale</code></td>
<td>
<p>Single value, namely the estimated fractal dimension and scale, respectively.</p>
</td></tr> 
<tr><td><code>methods</code>, <code>methods.coding</code></td>
<td>
<p>Method name and code used for the estimation.</p>
</td></tr>
<tr><td><code>window.size</code>, <code>step.size</code></td>
<td>
<p>Size of the data.</p>
</td></tr>
<tr><td><code>data.dim</code></td>
<td>
<p>Dimension of the data used for the estimation. It is either one or two.</p>
</td></tr>
<tr><td><code>loglog</code></td>
<td>
<p>Object of class <code><a href="#topic+FDloglog">FDloglog</a></code> used for the estimation.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Function <code><a href="#topic+fd.estimate">fd.estimate</a></code> can be used as a wrapper for these functions.</p>


<h3>Author(s)</h3>

<p>Hana Sevcikova, Don Percival, Tilmann Gneiting</p>


<h3>References</h3>

<p>Chan, G., Hall, P., Poskitt, D. (1995) Periodogram-Based Estimators of Fractal
Properties. Annals of Statistics <b>23</b> (5), 1684&ndash;1711.
</p>
<p>Chan, G., Wood, A. (2000) Increment-based estimators of fractal dimension for two-dimensional surface data.
Statistica Sinica <b>10</b>, 343&ndash;376.
</p>
<p>Davies, S., Hall, P. (1999) Fractal analysis of surface roughness by using spatial data.
Journal of the Royal Statistical Society Series B <b>61</b>, 3&ndash;37.
</p>
<p>Genton, M. G. (1998) Highly robust variogram estimation. Mathematical Geology <b>30</b>, 213&ndash;221.
</p>
<p>Gneiting, T., Sevcikova, H. and Percival, D. B. (2012). Estimators of fractal dimension: Assessing the smoothness of time series and spatial data. Statistical Science, 27(2), 247-277. (Version as technical report available at <a href="https://stat.uw.edu/sites/default/files/files/reports/2010/tr577.pdf">https://stat.uw.edu/sites/default/files/files/reports/2010/tr577.pdf</a>)
</p>
<p>Hall, P., Wood, A. (1993) On the Performance of Box-Counting Estimators of
Fractal Dimension. Biometrika <b>80</b> (1), 246&ndash;252.
</p>
<p>Zhu, Z., Stein, M. (2002) Parameter estimation for fractional Brownian surfaces.
Statistica Sinica <b>12</b>, 863&ndash;883.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fd.estimate">fd.estimate</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>if (requireNamespace("RandomFields", quietly = TRUE)) withAutoprint({
library(RandomFields)
# 1d time series
n &lt;- 256
rf &lt;- GaussRF(x = c(0,1, 1/n), model = "stable", 
    grid = TRUE, gridtriple = TRUE,
    param = c(mean=0, variance=1, nugget=0, scale=1, kappa=1))
par(mfrow=c(4,2))
fd.estim.variogram (rf, nlags = 20, plot.loglog = TRUE)
fd.estim.variation (rf, nlags = 20, plot.loglog = TRUE)
fd.estim.variogram (rf,  nlags = 3, plot.loglog = TRUE, 
    plot.allpoints = TRUE)
fd.estim.variation (rf, plot.loglog = TRUE, plot.allpoints = TRUE)
fd.estim.hallwood (rf, nlags = 10, plot.loglog = TRUE)
fd.estim.boxcount (rf, nlags = "all", plot.loglog = TRUE, 
    plot.allpoints = TRUE)
fd.estim.periodogram (rf, plot.loglog = TRUE)
fd.estim.dctII (rf, plot.loglog = TRUE)

# 2d random fields
n &lt;- 128
rf2d &lt;- GaussRF(x = c(0,1, 1/n), y = c(0,1, 1/n), model = "stable", 
    grid = TRUE, gridtriple = TRUE,
    param = c(mean=0, variance=1, nugget=0, scale=1, kappa=1))
par(mfrow=c(1,3))
fd.estim.isotropic (rf2d, p.index = 1, direction='hv',
                       plot.loglog = TRUE, plot.allpoints = TRUE)
fd.estim.squareincr (rf2d, p.index = 1, plot.loglog = TRUE, plot.allpoints = TRUE)
fd.estim.filter1 (rf2d, p.index = 1, plot.loglog = TRUE, plot.allpoints = TRUE)
})
</code></pre>

<hr>
<h2 id='fd.estimate'>Estimating Fractal Dimensions of Time Series and Two-dimensional Data</h2><span id='topic+fd.estimate'></span><span id='topic+FractalDim'></span><span id='topic+fd.estimate.matrix'></span><span id='topic+fd.estimate.numeric'></span><span id='topic+fd.estimate.data.frame'></span>

<h3>Description</h3>

<p>The functions compute a set of fractal dimensions <code class="reqn">D</code>
for time series and two-dimensional data 
via various methods using a sliding window
technique.  There is one <code class="reqn">D</code> computed for each method and for
each sliding window of a given size that is moved along the data.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'numeric'
 fd.estimate(data, methods = "madogram", window.size = length(data), 
    step.size = window.size, trim = TRUE, keep.data = FALSE, 
    keep.loglog = FALSE, parallel = FALSE, nr.nodes = NULL, 
    debuglevel = 0, ...)
	
## S3 method for class 'matrix'
 fd.estimate(data, methods = "transect.var", window.size = ncol(data),
    step.size = window.size, trim = TRUE, keep.data = FALSE, 
    keep.loglog = FALSE, parallel = FALSE, nr.nodes = NULL, 
    debuglevel = 0, ...)
          </code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fd.estimate_+3A_data">data</code></td>
<td>
<p>Vector, matrix or data frame.</p>
</td></tr>
<tr><td><code id="fd.estimate_+3A_methods">methods</code></td>
<td>
<p>Vector of character strings specifying methods for which
<code class="reqn">D</code> is estimated. Possible values for one-dimensional data are &ldquo;<code>variogram</code>&rdquo;, &ldquo;<code>madogram</code>&rdquo;, &ldquo;<code>rodogram</code>&rdquo;, &ldquo;<code>variation</code>&rdquo;,  &ldquo;<code>incr1</code>&rdquo;, &ldquo;<code>boxcount</code>&rdquo;, &ldquo;<code>hallwood</code>&rdquo;,  
&ldquo;<code>periodogram</code>&rdquo;,
&ldquo;<code>wavelet</code>&rdquo;, &ldquo;<code>dctII</code>&rdquo;, and &ldquo;<code>genton</code>&rdquo;. For matrix or data frame the function accepts methods &ldquo;<code>transect.var</code>&rdquo;, &ldquo;<code>transect.incr1</code>&rdquo;,
&ldquo;<code>isotropic</code>&rdquo;, &ldquo;<code>squareincr</code>&rdquo;, and &ldquo;<code>filter1</code>&rdquo; (see <code><a href="#topic+fd.get.available.methods">fd.get.available.methods</a></code>). Alternatively, it can be a list of lists where each list item contains an entry &ldquo;name&rdquo; being the method name and entries corresponding to arguments passed to the specific methods (see Example and
<code><a href="#topic+fd.estim.method">fd.estim.method</a></code> for details.)</p>
</td></tr>
<tr><td><code id="fd.estimate_+3A_window.size">window.size</code></td>
<td>
<p>Size (in number of data points) of the
sliding window.  It should be between 2 and length of 
<code>data</code>.</p>
</td></tr>
<tr><td><code id="fd.estimate_+3A_step.size">step.size</code></td>
<td>
<p>Number of data points by which the sliding
window is moved.</p>
</td></tr>
<tr><td><code id="fd.estimate_+3A_trim">trim</code></td>
<td>
<p>Logical.  If <code>TRUE</code>, the estimates are trimmed into the theoretically permissible interval, i.e. between 1 and 2 in one-dimensional case and between 2 and 3 in two-dimensional case.</p>
</td></tr>
<tr><td><code id="fd.estimate_+3A_keep.data">keep.data</code></td>
<td>
<p>Logical.  If <code>TRUE</code>, the data are kept in the
resulting object.</p>
</td></tr>
<tr><td><code id="fd.estimate_+3A_keep.loglog">keep.loglog</code></td>
<td>
<p>Logical.  If <code>TRUE</code>, the resulting object contains a list with objects of class <code><a href="#topic+FDloglog">FDloglog</a></code> used for the estimation in each iteration and for each method.</p>
</td></tr>
<tr><td><code id="fd.estimate_+3A_parallel">parallel</code></td>
<td>
<p>Logical determining if the process should run in parallel. If <code>TRUE</code>, the
package <span class="pkg">snowFT</span> is required. In such a 
case, all local library paths must be included
in the environment variable <code>R_LIBS</code>. In the one-dimensional case, the granularity of the process is given by the number of sliding windows. In the two-dimensional case, the number of spawn processes is equal to the number of sliding windows in the vertical direction.</p>
</td></tr> 
<tr><td><code id="fd.estimate_+3A_nr.nodes">nr.nodes</code></td>
<td>
<p>Number of nodes on which the computation should be
processed if <code>parallel</code> is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="fd.estimate_+3A_debuglevel">debuglevel</code></td>
<td>
<p>Controls the amount of debugging
messages. The functions produce messages on levels 1 - 4.</p>
</td></tr>
<tr><td><code id="fd.estimate_+3A_...">...</code></td>
<td>
<p>Arguments passed to lower level functions (defined in
<code><a href="#topic+fd.estim.method">fd.estim.method</a></code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In case of one-dimensional time series, the function  initiates a sliding window
of the given size at the beginning of the time series.  The
window is moved along the data by the
given step size. If <code>parallel</code> is <code>TRUE</code>, computation on each window happens in parallel.
In the two-dimensional case, the window is initiated in the top left corner of the data matrix and moved horizontally by the given step size, as well as vertically by the same step size. If the process is running in parallel, processing each row is done in parallel. 
In both cases, in each iteration estimates of fractal dimension for
data within the sliding window are
computed using the given estimation methods. 
</p>
<p>Note that the estimation results are <code>NA</code> for any sliding window that
contains <code>NA</code> values.
</p>
<p>Arguments that are to be passed to specific methods can be given either directly, if they applies to all given methods. Or, they can be given as a list via the <code>methods</code> argument: There is one list per method that must  contain the entry &ldquo;name&rdquo; being the method name. Remaining entries in the list corespond to one argument each (see Example below). 
</p>


<h3>Value</h3>

<p>An object of class
<code>FractalDim</code> which consists of the following components:
</p>
<table>
<tr><td><code>dim</code></td>
<td>
<p>Dimension of the resulting arrays <code>fd</code> and
<code>scale</code> (see below). 
In the one-dimensional case, possible values are 1 and 2.  <code>dim = 1</code> means that there has been only one iteration and there is one element in the above arrays per each method used. If <code>dim = 2</code>, rows correspond to iterations and columns correspond to methods. Estimation on two-dimensional data can in addition result in <code>dim = 3</code>, in which case the first and second dimensions correspond to vertical and horizontal iterations, respectively, and the third dimension corresponds to methods.</p>
</td></tr>
<tr><td><code>fd</code></td>
<td>
<p>A <code>dim</code>-dimensional array of fractal dimensions. </p>
</td></tr>
<tr><td><code>scale</code></td>
<td>
<p>A <code>dim</code>-dimensional array of scales, 
derived from the intercept of the log-log plots on which <code>fd</code> 
were computed.  Values are transformed to the scale of the
original data.</p>
</td></tr>
<tr><td><code>methods</code></td>
<td>
<p>Vector of methods given in the <code>methods</code> argument.
The order of the elements corresponds to the order of
estimates in the &ldquo;method&rdquo;-dimension of the above <code>dim</code>-dimensional arrays.</p>
</td></tr>
<tr><td><code>methods.coding</code></td>
<td>
<p>Vector of internal coding of <code>methods</code>. 
The order of the elements corresponds to the order in <code>methods</code>.</p>
</td></tr>
<tr><td><code>data</code></td>
<td>
<p>Value of the argument <code>data</code>, if <code>keep.data = TRUE</code>,
otherwise <code>NULL</code>.</p>
</td></tr>
<tr><td><code>data.dim</code></td>
<td>
<p>Dimension of <code>data</code>.</p>
</td></tr>
<tr><td><code>window.size</code></td>
<td>
<p>Size of the actual sliding window used in the computation. </p>
</td></tr>
<tr><td><code>step.size</code></td>
<td>
<p>Step size by which the sliding window was moved in the computation.</p>
</td></tr>
<tr><td><code>loglog</code></td>
<td>
<p>If <code>keep.loglog=TRUE</code>, this is a list containing for each iteration a lists of <code><a href="#topic+FDloglog">FDloglog</a></code> objects used in the estimation, one per method. The numbering of the methods corresponds to the method order in <code>methods</code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+fd.estim.method">fd.estim.method</a></code>, <code><a href="#topic+fd.get.available.methods">fd.get.available.methods</a></code>, <code><a href="#topic+FDloglog">FDloglog</a></code>, <code><a href="#topic+fd.get">fd.get</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(RandomFields)
n &lt;- 10000
# generate a time series
rf &lt;- GaussRF(x = c(0, 1, 1/n), model = "stable", 
       grid = TRUE, gridtriple = TRUE,
       param = c(mean=0, variance=1, nugget=0, scale=100, kappa=1))

# Plots for two sliding windows of each of the four methods below.
# Argument nlags is common to all methods;
# the 'variation' method has in addition argument p.index
par(mfrow=c(2,4)) # one row per window
fd &lt;- fd.estimate(rf, 
       methods = list(list(name="variation", p.index=0.5), 
       					"variogram", "hallwood", "boxcount"),
       window.size = 5000, step.size = 5000, plot.loglog = TRUE, nlags = 10)
    
# 2d random fields
n &lt;- 200
rf2d &lt;- GaussRF(x = c(0,1, 1/n), y = c(0,1, 1/n), model = "stable", 
         grid = TRUE, gridtriple = TRUE,
         param = c(mean=0, variance=1, nugget=0, scale=1, kappa=1))
par(mfrow=c(2,2))
# plots for 4 sliding windows (2 horizontal, 2 vertical)
fd2d &lt;- fd.estimate(rf2d, methods="filter1",
         window.size = 100, step.size=100, plot.loglog = TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='fd.get'>Access Method for Objects of Class FractalDim</h2><span id='topic+fd.get'></span>

<h3>Description</h3>

<p>For given method it returns the corresponding estimates.</p>


<h3>Usage</h3>

<pre><code class='language-R'>fd.get(fractaldim, method)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fd.get_+3A_fractaldim">fractaldim</code></td>
<td>
<p>object of class <code>FractalDim</code> as defined in
<code><a href="#topic+fd.estimate">fd.estimate</a></code>.</p>
</td></tr>
<tr><td><code id="fd.get_+3A_method">method</code></td>
<td>
<p>character string specifying the method.
For 1-d estimators, possible values are  &ldquo;<code>variogram</code>&rdquo;, &ldquo;<code>madogram</code>&rdquo;, &ldquo;<code>rodogram</code>&rdquo;, &ldquo;<code>variation</code>&rdquo;, &ldquo;<code>incr1</code>&rdquo;, &ldquo;<code>boxcount</code>&rdquo;,
&ldquo;<code>hallwood</code>&rdquo;,  
&ldquo;<code>periodogram</code>&rdquo;,
&ldquo;<code>wavelet</code>&rdquo;, &ldquo;<code>dctII</code>&rdquo;, and &ldquo;<code>genton</code>&rdquo;. 
For 2-d estimators, possible values are  &ldquo;<code>transect.var</code>&rdquo;, &ldquo;<code>transect.incr1</code>&rdquo;,
&ldquo;<code>isotropic</code>&rdquo;, &ldquo;<code>squareincr</code>&rdquo;, and &ldquo;<code>filter1</code>&rdquo; 
(see <code><a href="#topic+fd.get.available.methods">fd.get.available.methods</a></code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="#topic+FractalDim">FractalDim</a></code> object.  The original <code>fractaldim</code> arrays <code>fd</code> and <code>scale</code> are reduced in the last dimension into only one method, namely the given <code>method</code>. </p>


<h3>See Also</h3>

<p><code><a href="#topic+fd.estimate">fd.estimate</a></code>, <code><a href="#topic+fd.get.available.methods">fd.get.available.methods</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(RandomFields)
x &lt;- seq(0, 10000)
# generate a random field
truealpha &lt;- 1.5
rf &lt;- GaussRF(x = x, model = "stable", grid = TRUE,
    param = c(mean=0, variance=1, nugget=0, scale=100, 
        alpha=truealpha))

#compute fractal dimension using various methods
methods &lt;- c("madogram", "variogram", "hallwood", "boxcount",
                       "periodogram","dctII", "wavelet")
fdts &lt;- fd.estimate (rf, methods = methods, window.size = 500, 
    step.size = 100, nlags = 10, trim = FALSE, debuglevel = 3)

# plot the variation
cols &lt;- rainbow(length(methods))
plot(ts(fd.get (fdts, methods[1])$fd),ylim=c(min(fdts$fd), max(fdts$fd)),
             ylab="fd", col=cols[1])
for (imeth in 2:length(methods)) 
    lines(ts(fd.get (fdts, methods[imeth])$fd), col=cols[imeth])
legend('topleft', legend=methods, col=cols, lwd=1)
abline(h=2-truealpha/2)

## End(Not run)

</code></pre>

<hr>
<h2 id='fd.get.available.methods'>Available Estimation Methods</h2><span id='topic+fd.get.available.methods'></span>

<h3>Description</h3>

<p>The function returns a list of estimation methods that can be used in <code><a href="#topic+fd.estimate">fd.estimate</a></code> and other functions of the package.</p>


<h3>Usage</h3>

<pre><code class='language-R'>fd.get.available.methods(dim = 1)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fd.get.available.methods_+3A_dim">dim</code></td>
<td>
<p>Dimension of data for which the estimation methods should be obtained.</p>
</td></tr>	
</table>


<h3>Value</h3>

<p>A list of the available methods. Their order number in the list corresponds to the internal codes of the methods.</p>


<h3>See Also</h3>

<p><code><a href="#topic+fd.estimate">fd.estimate</a></code>, <code><a href="#topic+fd.get">fd.get</a></code></p>

<hr>
<h2 id='fractaldim-internal'>Internal Functions</h2><span id='topic+createFractalDim'></span><span id='topic+CrossingBox'></span><span id='topic+ComputeDCT2FFT'></span><span id='topic+ComputePlotPoint.boxcount'></span><span id='topic+ComputePlotPoint.hallwood'></span><span id='topic+ComputePlotPoint.hybrid'></span><span id='topic+ComputeSemipgramFFT'></span><span id='topic+create.plot.label'></span><span id='topic+dim.FractalDim'></span><span id='topic+do.fd.estimate'></span><span id='topic+do.fd.estimate.for.parallel'></span><span id='topic+do.fd.estimate.1iteration'></span><span id='topic+do.fd.estimate1d.method'></span><span id='topic+do.fd.estimate1d.spectral'></span><span id='topic+do.fd.estimate2d'></span><span id='topic+do.fd.estimate2d.method'></span><span id='topic+do.fd.estimate2d.simple'></span><span id='topic+fd.Genton'></span><span id='topic+fd.get.method.coding'></span><span id='topic+fd.HallWood'></span><span id='topic+fd.Hybrid'></span><span id='topic+fd.Hybrid.filter1'></span><span id='topic+fd.Hybrid.isotropic'></span><span id='topic+fd.Hybrid.squareincr'></span><span id='topic+fd.HybridFiltered'></span><span id='topic+fd.Increment1'></span><span id='topic+fd.initfunction'></span><span id='topic+fd.plot.label'></span><span id='topic+fd.plot.loglog'></span><span id='topic+fd.regression'></span><span id='topic+fd.Variation'></span><span id='topic+fd.Variation.filter1'></span><span id='topic+fd.Variation.isotropic'></span><span id='topic+fd.Variation.squareincr'></span><span id='topic+fd.VariationFiltered'></span><span id='topic+get.methods.from.coding'></span><span id='topic+get.vector.method.coding'></span><span id='topic+has.direction'></span><span id='topic+IsInBox'></span><span id='topic+prepare.for.row.estimation'></span><span id='topic+WaveVarFD'></span>

<h3>Description</h3>

<p>Internal functions.
</p>


<h3>Details</h3>

<p>Functions for internal use only.
</p>

<hr>
<h2 id='get.rawFD.from.regression'>
Obtaining Regression Object
</h2><span id='topic+get.rawFD.from.regression'></span><span id='topic+FDloglog'></span><span id='topic+summary.FDloglog'></span>

<h3>Description</h3>

<p>Obtaining and summarizing result of a linear regression of the log-log plot, object of class <code>FDloglog</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.rawFD.from.regression(x, y, leaveout = 0)

## S3 method for class 'FDloglog'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.rawFD.from.regression_+3A_x">x</code></td>
<td>
<p>Values of the x-axis.</p>
</td></tr>
<tr><td><code id="get.rawFD.from.regression_+3A_y">y</code></td>
<td>
<p>Values of the y-axis.</p>
</td></tr>
<tr><td><code id="get.rawFD.from.regression_+3A_leaveout">leaveout</code></td>
<td>
<p>Number of points (from the beginning of the arrays) to leave out of the regression.</p>
</td></tr>
<tr><td><code id="get.rawFD.from.regression_+3A_object">object</code></td>
<td>
<p>Object of class <code>FDloglog</code>.</p>
</td></tr>
<tr><td><code id="get.rawFD.from.regression_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Function <code>get.rawFD.from.regression</code> returns an object of class <code>FDloglog</code> with the following components:
</p>
<table>
<tr><td><code>alpha</code>, <code>intercept</code></td>
<td>
<p>Slope and intercept of the regression.</p>
</td></tr>
<tr><td><code>x</code>, <code>y</code></td>
<td>
<p>x and y values, including the <code>leaveout</code>.</p>
</td></tr>
<tr><td><code>n</code></td>
<td>
<p>Length of <code>x</code>.</p>
</td></tr>
<tr><td><code>lsq</code></td>
<td>
<p>The least squared of the regression.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Hana Sevcikova
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fd.estimate">fd.estimate</a></code>, <code><a href="#topic+fd.estim.method">fd.estim.method</a></code>
</p>

<hr>
<h2 id='summary.FractalDim'>Summary for an Object of Class FractalDim</h2><span id='topic+summary.FractalDim'></span>

<h3>Description</h3>

<p>The function prints summary of estimates in a
<code>FractalDim</code> object.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'FractalDim'
 summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.FractalDim_+3A_object">object</code></td>
<td>
<p>An object of class <code>FractalDim</code>.</p>
</td></tr>
<tr><td><code id="summary.FractalDim_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function prints information about the grid on which the estimates
were obtained.  For each method it
shows the mean and standard deviation of data in each of the two
components (fd and scale).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fd.estimate">fd.estimate</a></code></p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
