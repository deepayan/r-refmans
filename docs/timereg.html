<!DOCTYPE html><html><head><title>Help for package timereg</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {timereg}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#aalen'><p>Fit additive hazards model</p></a></li>
<li><a href='#bmt'><p>The Bone Marrow Transplant Data</p></a></li>
<li><a href='#cd4'><p>The multicenter AIDS cohort study</p></a></li>
<li><a href='#comp.risk'><p>Competings Risks Regression</p></a></li>
<li><a href='#const'><p>Identifies parametric terms of model</p></a></li>
<li><a href='#cox'><p>Identifies proportional excess terms of model</p></a></li>
<li><a href='#cox.aalen'><p>Fit Cox-Aalen survival model</p></a></li>
<li><a href='#cox.ipw'><p>Missing data IPW Cox</p></a></li>
<li><a href='#csl'><p>CSL liver chirrosis data</p></a></li>
<li><a href='#cum.residuals'><p>Model validation based on cumulative residuals</p></a></li>
<li><a href='#diabetes'><p>The Diabetic Retinopathy Data</p></a></li>
<li><a href='#dynreg'><p>Fit time-varying regression model</p></a></li>
<li><a href='#Event'><p>Event history object</p></a></li>
<li><a href='#event.split'><p>EventSplit (SurvSplit).</p></a></li>
<li><a href='#Gprop.odds'><p>Fit Generalized Semiparametric Proportional 0dds Model</p></a></li>
<li><a href='#krylow.pls'><p>Fits Krylow based PLS for additive hazards model</p></a></li>
<li><a href='#mela.pop'><p>Melanoma data and Danish population mortality by age and sex</p></a></li>
<li><a href='#melanoma'><p>The Melanoma Survival Data</p></a></li>
<li><a href='#mypbc'><p>my version of the PBC data of the survival package</p></a></li>
<li><a href='#pava.pred'><p>Make predictions of predict functions in rows mononotone</p></a></li>
<li><a href='#pe.sasieni'><p>Fits Proportional excess hazards model with fixed offsets</p></a></li>
<li><a href='#plot.aalen'><p>Plots estimates and test-processes</p></a></li>
<li><a href='#plot.cum.residuals'><p>Plots cumulative residuals</p></a></li>
<li><a href='#plot.dynreg'><p>Plots estimates and test-processes</p></a></li>
<li><a href='#predict.timereg'><p>Predictions for Survival and Competings Risks Regression for timereg</p></a></li>
<li><a href='#prep.comp.risk'><p>Set up weights for delayed-entry competing risks data for comp.risk function</p></a></li>
<li><a href='#print.aalen'><p>Prints call</p></a></li>
<li><a href='#prop'><p>Identifies the multiplicative terms in Cox-Aalen model and proportional</p>
excess risk model</a></li>
<li><a href='#prop.excess'><p>Fits Proportional excess hazards model</p></a></li>
<li><a href='#prop.odds'><p>Fit Semiparametric Proportional 0dds Model</p></a></li>
<li><a href='#prop.odds.subdist'><p>Fit Semiparametric Proportional 0dds Model for the competing risks</p>
subdistribution</a></li>
<li><a href='#pval'><p>For internal use</p></a></li>
<li><a href='#qcut'><p>Cut a variable</p></a></li>
<li><a href='#recurrent.marginal.coxmean'><p>Estimates marginal mean of recurrent events  based on two cox models</p></a></li>
<li><a href='#recurrent.marginal.mean'><p>Estimates marginal mean of recurrent events</p></a></li>
<li><a href='#res.mean'><p>Residual mean life (restricted)</p></a></li>
<li><a href='#restricted.residual.mean'><p>Estimates restricted residual mean for Cox or Aalen model</p></a></li>
<li><a href='#summary.aalen'><p>Prints summary statistics</p></a></li>
<li><a href='#summary.cum.residuals'><p>Prints summary statistics for goodness-of-fit tests based on cumulative</p>
residuals</a></li>
<li><a href='#timecox'><p>Fit Cox model with partly timevarying effects.</p></a></li>
<li><a href='#TRACE'><p>The TRACE study group of myocardial infarction</p></a></li>
<li><a href='#two.stage'><p>Fit Clayton-Oakes-Glidden Two-Stage model</p></a></li>
<li><a href='#wald.test'><p>Makes wald test</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Flexible Regression Models for Survival Data</td>
</tr>
<tr>
<td>Version:</td>
<td>2.0.5</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-01-17</td>
</tr>
<tr>
<td>Author:</td>
<td>Thomas Scheike with contributions from Torben Martinussen, Jeremy
    Silver and Klaus Holst</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Thomas Scheike &lt;ts@biostat.ku.dk&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Programs for Martinussen and Scheike (2006), &lsquo;Dynamic Regression
    Models for Survival Data&rsquo;, Springer Verlag.  Plus more recent developments.
    Additive survival model, semiparametric proportional odds model, fast
    cumulative residuals, excess risk models and more. Flexible competing risks
    regression including GOF-tests. Two-stage frailty modelling. PLS for the
    additive risk model. Lasso in the 'ahaz' package.</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/scheike/timereg">https://github.com/scheike/timereg</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.15), survival</td>
</tr>
<tr>
<td>Imports:</td>
<td>lava, numDeriv, stats, graphics, grDevices, utils, methods</td>
</tr>
<tr>
<td>Suggests:</td>
<td>mets,</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-01-16 10:52:45 UTC; tom</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-01-17 10:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='aalen'>Fit additive hazards model</h2><span id='topic+aalen'></span>

<h3>Description</h3>

<p>Fits both the additive hazards model of Aalen and the semi-parametric
additive hazards model of McKeague and Sasieni.  Estimates are un-weighted.
Time dependent variables and counting process data (multiple events per
subject) are possible.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aalen(
  formula = formula(data),
  data = parent.frame(),
  start.time = 0,
  max.time = NULL,
  robust = 1,
  id = NULL,
  clusters = NULL,
  residuals = 0,
  n.sim = 1000,
  weighted.test = 0,
  covariance = 0,
  resample.iid = 0,
  deltaweight = 1,
  silent = 1,
  weights = NULL,
  max.clust = 1000,
  gamma = NULL,
  offsets = 0,
  caseweight = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="aalen_+3A_formula">formula</code></td>
<td>
<p>a formula object with the response on the left of a '~'
operator, and the independent terms on the right as regressors.The response
must be a survival object as returned by the &lsquo;Surv&rsquo; function. Time-
invariant regressors are specified by the wrapper const(), and cluster
variables (for computing robust variances) by the wrapper cluster().</p>
</td></tr>
<tr><td><code id="aalen_+3A_data">data</code></td>
<td>
<p>a data.frame with the variables.</p>
</td></tr>
<tr><td><code id="aalen_+3A_start.time">start.time</code></td>
<td>
<p>start of observation period where estimates are computed.</p>
</td></tr>
<tr><td><code id="aalen_+3A_max.time">max.time</code></td>
<td>
<p>end of observation period where estimates are computed.
Estimates thus computed from [start.time, max.time]. Default is max of data.</p>
</td></tr>
<tr><td><code id="aalen_+3A_robust">robust</code></td>
<td>
<p>to compute robust variances and construct processes for
resampling. May be set to 0 to save memory.</p>
</td></tr>
<tr><td><code id="aalen_+3A_id">id</code></td>
<td>
<p>For timevarying covariates the variable must associate each record
with the id of a subject.</p>
</td></tr>
<tr><td><code id="aalen_+3A_clusters">clusters</code></td>
<td>
<p>cluster variable for computation of robust variances.</p>
</td></tr>
<tr><td><code id="aalen_+3A_residuals">residuals</code></td>
<td>
<p>to returns residuals that can be used for model validation
in the function cum.residuals</p>
</td></tr>
<tr><td><code id="aalen_+3A_n.sim">n.sim</code></td>
<td>
<p>number of simulations in resampling.</p>
</td></tr>
<tr><td><code id="aalen_+3A_weighted.test">weighted.test</code></td>
<td>
<p>to compute a variance weighted version of the
test-processes used for testing time-varying effects.</p>
</td></tr>
<tr><td><code id="aalen_+3A_covariance">covariance</code></td>
<td>
<p>to compute covariance estimates for nonparametric terms
rather than just the variances.</p>
</td></tr>
<tr><td><code id="aalen_+3A_resample.iid">resample.iid</code></td>
<td>
<p>to return i.i.d. representation for nonparametric and
parametric terms.</p>
</td></tr>
<tr><td><code id="aalen_+3A_deltaweight">deltaweight</code></td>
<td>
<p>uses weights to estimate semiparametric model, under
construction, default=1 is standard least squares estimates</p>
</td></tr>
<tr><td><code id="aalen_+3A_silent">silent</code></td>
<td>
<p>set to 0 to print warnings for non-inverible design-matrices
for different timepoints, default is 1.</p>
</td></tr>
<tr><td><code id="aalen_+3A_weights">weights</code></td>
<td>
<p>weights for estimating equations.</p>
</td></tr>
<tr><td><code id="aalen_+3A_max.clust">max.clust</code></td>
<td>
<p>sets the total number of i.i.d. terms in i.i.d.
decompostition. This can limit the amount of memory used by coarsening the
clusters. When NULL then all clusters are used.  Default is 1000 to save
memory and time.</p>
</td></tr>
<tr><td><code id="aalen_+3A_gamma">gamma</code></td>
<td>
<p>fixes gamme at this value for estimation.</p>
</td></tr>
<tr><td><code id="aalen_+3A_offsets">offsets</code></td>
<td>
<p>offsets for the additive model, to make excess risk
modelling.</p>
</td></tr>
<tr><td><code id="aalen_+3A_caseweight">caseweight</code></td>
<td>
<p>caseweight: mutiplied onto dN for score equations.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Resampling is used for computing p-values for tests of time-varying effects.
</p>
<p>The modelling formula uses the standard survival modelling given in the
<b>survival</b> package.
</p>
<p>The data for a subject is presented as multiple rows or 'observations', each
of which applies to an interval of observation (start, stop].  For counting
process data with the )start,stop] notation is used, the 'id' variable is
needed to identify the records for each subject. The program assumes that
there are no ties, and if such are present random noise is added to break
the ties.
</p>


<h3>Value</h3>

<p>returns an object of type &quot;aalen&quot;. With the following arguments:
</p>
<table>
<tr><td><code>cum</code></td>
<td>
<p>cumulative timevarying regression coefficient estimates are
computed within the estimation interval. </p>
</td></tr> <tr><td><code>var.cum</code></td>
<td>
<p>the martingale
based pointwise variance estimates for cumulatives.</p>
</td></tr>
<tr><td><code>robvar.cum</code></td>
<td>
<p>robust pointwise variances estimates for cumulatives.</p>
</td></tr>
<tr><td><code>gamma</code></td>
<td>
<p>estimate of parametric components of model.  </p>
</td></tr>
<tr><td><code>var.gamma</code></td>
<td>
<p>variance for gamma.  </p>
</td></tr> <tr><td><code>robvar.gamma</code></td>
<td>
<p>robust variance
for gamma.  </p>
</td></tr> <tr><td><code>residuals</code></td>
<td>
<p>list with residuals. Estimated martingale
increments (dM) and corresponding time vector (time).</p>
</td></tr>
<tr><td><code>obs.testBeq0</code></td>
<td>
<p>observed absolute value of supremum of cumulative
components scaled with the variance.</p>
</td></tr> <tr><td><code>pval.testBeq0</code></td>
<td>
<p>p-value for
covariate effects based on supremum test.</p>
</td></tr> <tr><td><code>sim.testBeq0</code></td>
<td>
<p>resampled
supremum values.</p>
</td></tr> <tr><td><code>obs.testBeqC</code></td>
<td>
<p>observed absolute value of supremum of
difference between observed cumulative process and estimate under null of
constant effect.</p>
</td></tr> <tr><td><code>pval.testBeqC</code></td>
<td>
<p>p-value based on resampling.</p>
</td></tr>
<tr><td><code>sim.testBeqC</code></td>
<td>
<p>resampled supremum values.</p>
</td></tr>
<tr><td><code>obs.testBeqC.is</code></td>
<td>
<p>observed integrated squared differences between
observed cumulative and estimate under null of constant effect.</p>
</td></tr>
<tr><td><code>pval.testBeqC.is</code></td>
<td>
<p>p-value based on resampling.</p>
</td></tr>
<tr><td><code>sim.testBeqC.is</code></td>
<td>
<p>resampled supremum values.</p>
</td></tr>
<tr><td><code>conf.band</code></td>
<td>
<p>resampling based constant to construct robust 95% uniform
confidence bands. </p>
</td></tr> <tr><td><code>test.procBeqC</code></td>
<td>
<p>observed test-process of difference
between observed cumulative process and estimate under null of constant
effect over time.  </p>
</td></tr> <tr><td><code>sim.test.procBeqC</code></td>
<td>
<p>list of 50 random realizations
of test-processes under null based on resampling.</p>
</td></tr>
<tr><td><code>covariance</code></td>
<td>
<p>covariances for nonparametric terms of model.</p>
</td></tr>
<tr><td><code>B.iid</code></td>
<td>
<p>Resample processes for nonparametric terms of model.</p>
</td></tr>
<tr><td><code>gamma.iid</code></td>
<td>
<p>Resample processes for parametric terms of model.</p>
</td></tr>
<tr><td><code>deviance</code></td>
<td>
<p>Least squares of increments.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Thomas Scheike
</p>


<h3>References</h3>

<p>Martinussen and Scheike, Dynamic Regression Models for Survival
Data, Springer (2006).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(sTRACE)
# Fits Aalen model 
out&lt;-aalen(Surv(time,status==9)~age+sex+diabetes+chf+vf,
sTRACE,max.time=7,n.sim=100)

summary(out)
par(mfrow=c(2,3))
plot(out)

# Fits semi-parametric additive hazards model 
out&lt;-aalen(Surv(time,status==9)~const(age)+const(sex)+const(diabetes)+chf+vf,
sTRACE,max.time=7,n.sim=100)

summary(out)
par(mfrow=c(2,3))
plot(out)

## Excess risk additive modelling 
data(mela.pop)
dummy&lt;-rnorm(nrow(mela.pop));

# Fits Aalen model  with offsets 
out&lt;-aalen(Surv(start,stop,status==1)~age+sex+const(dummy),
mela.pop,max.time=7,n.sim=100,offsets=mela.pop$rate,id=mela.pop$id,
gamma=0)
summary(out)
par(mfrow=c(2,3))
plot(out,main="Additive excess riks model")

# Fits semi-parametric additive hazards model  with offsets 
out&lt;-aalen(Surv(start,stop,status==1)~age+const(sex),
mela.pop,max.time=7,n.sim=100,offsets=mela.pop$rate,id=mela.pop$id)
summary(out)
plot(out,main="Additive excess riks model")

</code></pre>

<hr>
<h2 id='bmt'>The Bone Marrow Transplant Data</h2><span id='topic+bmt'></span>

<h3>Description</h3>

<p>Bone marrow transplant data with 408 rows and 5 columns.
</p>


<h3>Format</h3>

<p>The data has 408 rows and 5 columns.
</p>

<dl>
<dt>cause</dt><dd><p>a numeric vector code. 
Survival status. 1: dead from treatment related causes, 
2: relapse , 0: censored.</p>
</dd>
<dt>time</dt><dd><p> a numeric vector. Survival time.  </p>
</dd>
<dt>platelet</dt><dd><p>a numeric vector code. Plalelet 
1: more than 100 x <code class="reqn">10^9</code> per L, 0: less.</p>
</dd>
<dt>tcell</dt><dd><p>a numeric vector. T-cell depleted BMT 1:yes,
0:no.</p>
</dd>
<dt>age</dt><dd><p>a numeric vector code. Age of patient, scaled and
centered ((age-35)/15).</p>
</dd>
</dl>



<h3>Source</h3>

<p>Simulated data  
</p>


<h3>References</h3>

<p>NN 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(bmt)
names(bmt)
</code></pre>

<hr>
<h2 id='cd4'>The multicenter AIDS cohort study
</h2><span id='topic+cd4'></span>

<h3>Description</h3>

<p>CD4 counts collected over time.</p>


<h3>Format</h3>

<p>This data frame contains the following columns:
</p>

<dl>
<dt>obs</dt><dd><p>a numeric vector. Number of observations.</p>
</dd>
<dt>id</dt><dd><p>a numeric vector. Id of subject.</p>
</dd>
<dt>visit</dt><dd>
<p>a numeric vector. Timings of the visits in years.</p>
</dd>
<dt>smoke</dt><dd><p>a numeric vector code. 0: non-smoker, 1: smoker.</p>
</dd>
<dt>age</dt><dd><p>a numeric vector. Age of the patient at the start of the trial.</p>
</dd>
<dt>cd4</dt><dd><p>a numeric vector. CD4 percentage at the current visit.</p>
</dd>
<dt>cd4.prev</dt><dd><p>a numeric vector. CD4 level at the preceding visit.</p>
</dd>
<dt>precd4</dt><dd><p>a numeric vector. Post-infection CD4 percentage.</p>
</dd>
<dt>lt</dt><dd><p>a numeric vector. Gives the starting time for the
time-intervals.</p>
</dd>
<dt>rt</dt><dd><p>a numeric vector. Gives the stopping time for the
time-interval.</p>
</dd>
</dl>



<h3>Source</h3>

<p>MACS Public Use Data Set Release PO4 (1984-1991). See reference.
</p>


<h3>References</h3>

<p>Kaslow et al. (1987), The multicenter AIDS cohort study: rational,
organisation and selected characteristics of the participants. 
Am. J. Epidemiology 126, 310&ndash;318. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(cd4)
names(cd4)
</code></pre>

<hr>
<h2 id='comp.risk'>Competings Risks Regression</h2><span id='topic+comp.risk'></span>

<h3>Description</h3>

<p>Fits a semiparametric model for the cause-specific quantities : </p>
<p style="text-align: center;"><code class="reqn"> P(T &lt;
t, cause=1 | x,z) = P_1(t,x,z) = h( g(t,x,z) ) </code>
</p>
<p> for a known link-function
<code class="reqn">h()</code> and known prediction-function <code class="reqn">g(t,x,z)</code> for the probability
of dying from cause 1 in a situation with competing causes of death.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>comp.risk(
  formula,
  data = parent.frame(),
  cause,
  times = NULL,
  Nit = 50,
  clusters = NULL,
  est = NULL,
  fix.gamma = 0,
  gamma = 0,
  n.sim = 0,
  weighted = 0,
  model = "fg",
  detail = 0,
  interval = 0.01,
  resample.iid = 1,
  cens.model = "KM",
  cens.formula = NULL,
  time.pow = NULL,
  time.pow.test = NULL,
  silent = 1,
  conv = 1e-06,
  weights = NULL,
  max.clust = 1000,
  n.times = 50,
  first.time.p = 0.05,
  estimator = 1,
  trunc.p = NULL,
  cens.weights = NULL,
  admin.cens = NULL,
  conservative = 1,
  monotone = 0,
  step = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="comp.risk_+3A_formula">formula</code></td>
<td>
<p>a formula object, with the response on the left of a '~'
operator, and the terms on the right. The response must be a survival object
as returned by the &lsquo;Event&rsquo; function. The status indicator is not important
here. Time-invariant regressors are specified by the wrapper const(), and
cluster variables (for computing robust variances) by the wrapper cluster().</p>
</td></tr>
<tr><td><code id="comp.risk_+3A_data">data</code></td>
<td>
<p>a data.frame with the variables.</p>
</td></tr>
<tr><td><code id="comp.risk_+3A_cause">cause</code></td>
<td>
<p>For competing risk models specificies which cause we consider.</p>
</td></tr>
<tr><td><code id="comp.risk_+3A_times">times</code></td>
<td>
<p>specifies the times at which the estimator is considered.
Defaults to all the times where an event of interest occurs, with the first
10 percent or max 20 jump points removed for numerical stability in
simulations.</p>
</td></tr>
<tr><td><code id="comp.risk_+3A_nit">Nit</code></td>
<td>
<p>number of iterations for Newton-Raphson algorithm.</p>
</td></tr>
<tr><td><code id="comp.risk_+3A_clusters">clusters</code></td>
<td>
<p>specifies cluster structure, for backwards compability.</p>
</td></tr>
<tr><td><code id="comp.risk_+3A_est">est</code></td>
<td>
<p>possible starting value for nonparametric component of model.</p>
</td></tr>
<tr><td><code id="comp.risk_+3A_fix.gamma">fix.gamma</code></td>
<td>
<p>to keep gamma fixed, possibly at 0.</p>
</td></tr>
<tr><td><code id="comp.risk_+3A_gamma">gamma</code></td>
<td>
<p>starting value for constant effects.</p>
</td></tr>
<tr><td><code id="comp.risk_+3A_n.sim">n.sim</code></td>
<td>
<p>number of simulations in resampling.</p>
</td></tr>
<tr><td><code id="comp.risk_+3A_weighted">weighted</code></td>
<td>
<p>Not implemented. To compute a variance weighted version of
the test-processes used for testing time-varying effects.</p>
</td></tr>
<tr><td><code id="comp.risk_+3A_model">model</code></td>
<td>
<p>&quot;additive&quot;, &quot;prop&quot;ortional, &quot;rcif&quot;, or &quot;logistic&quot;.</p>
</td></tr>
<tr><td><code id="comp.risk_+3A_detail">detail</code></td>
<td>
<p>if 0 no details are printed during iterations, if 1 details
are given.</p>
</td></tr>
<tr><td><code id="comp.risk_+3A_interval">interval</code></td>
<td>
<p>specifies that we only consider timepoints where the
Kaplan-Meier of the censoring distribution is larger than this value.</p>
</td></tr>
<tr><td><code id="comp.risk_+3A_resample.iid">resample.iid</code></td>
<td>
<p>to return the iid decomposition, that can be used to
construct confidence bands for predictions</p>
</td></tr>
<tr><td><code id="comp.risk_+3A_cens.model">cens.model</code></td>
<td>
<p>specified which model to use for the ICPW, KM is
Kaplan-Meier alternatively it may be &quot;cox&quot;</p>
</td></tr>
<tr><td><code id="comp.risk_+3A_cens.formula">cens.formula</code></td>
<td>
<p>specifies the regression terms used for the regression
model for chosen regression model. When cens.model is specified, the default
is to use the same design as specified for the competing risks model.</p>
</td></tr>
<tr><td><code id="comp.risk_+3A_time.pow">time.pow</code></td>
<td>
<p>specifies that the power at which the time-arguments is
transformed, for each of the arguments of the const() terms, default is 1
for the additive model and 0 for the proportional model.</p>
</td></tr>
<tr><td><code id="comp.risk_+3A_time.pow.test">time.pow.test</code></td>
<td>
<p>specifies that the power the time-arguments is
transformed for each of the arguments of the non-const() terms. This is
relevant for testing if a coefficient function is consistent with the
specified form A_l(t)=beta_l t^time.pow.test(l). Default is 1 for the
additive model and 0 for the proportional model.</p>
</td></tr>
<tr><td><code id="comp.risk_+3A_silent">silent</code></td>
<td>
<p>if 0 information on convergence problems due to non-invertible
derviates of scores are printed.</p>
</td></tr>
<tr><td><code id="comp.risk_+3A_conv">conv</code></td>
<td>
<p>gives convergence criterie in terms of sum of absolute change of
parameters of model</p>
</td></tr>
<tr><td><code id="comp.risk_+3A_weights">weights</code></td>
<td>
<p>weights for estimating equations.</p>
</td></tr>
<tr><td><code id="comp.risk_+3A_max.clust">max.clust</code></td>
<td>
<p>sets the total number of i.i.d. terms in i.i.d.
decompostition. This can limit the amount of memory used by coarsening the
clusters. When NULL then all clusters are used.  Default is 1000 to save
memory and time.</p>
</td></tr>
<tr><td><code id="comp.risk_+3A_n.times">n.times</code></td>
<td>
<p>only uses 50 points for estimation, if NULL then uses all
points, subject to p.start condition.</p>
</td></tr>
<tr><td><code id="comp.risk_+3A_first.time.p">first.time.p</code></td>
<td>
<p>first point for estimation is pth percentile of cause
jump times.</p>
</td></tr>
<tr><td><code id="comp.risk_+3A_estimator">estimator</code></td>
<td>
<p>default estimator is 1.</p>
</td></tr>
<tr><td><code id="comp.risk_+3A_trunc.p">trunc.p</code></td>
<td>
<p>truncation weight for delayed entry, P(T &gt; entry.time | Z_i),
typically Cox model.</p>
</td></tr>
<tr><td><code id="comp.risk_+3A_cens.weights">cens.weights</code></td>
<td>
<p>censoring weights can be given here rather than
calculated using the KM, cox or aalen models.</p>
</td></tr>
<tr><td><code id="comp.risk_+3A_admin.cens">admin.cens</code></td>
<td>
<p>censoring times for the administrative censoring</p>
</td></tr>
<tr><td><code id="comp.risk_+3A_conservative">conservative</code></td>
<td>
<p>set to 0 to compute correct variances based on censoring
weights, default is conservative estimates that are much quicker.</p>
</td></tr>
<tr><td><code id="comp.risk_+3A_monotone">monotone</code></td>
<td>
<p>monotone=0, uses estimating equations </p>
<p style="text-align: center;"><code class="reqn"> (D_\beta P_1) w(t) ( Y(t)/G_c(t) - P_1(t,X))</code>
</p>
<p> montone=1 uses </p>
<p style="text-align: center;"><code class="reqn"> w(t) X ( Y(t)/G_c(t) - P_1(t,X)) </code>
</p>
</td></tr>
<tr><td><code id="comp.risk_+3A_step">step</code></td>
<td>
<p>step size for Fisher-Scoring algorithm.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>We consider the following models : 1) the additive model where
<code class="reqn">h(x)=1-\exp(-x)</code> and </p>
<p style="text-align: center;"><code class="reqn"> g(t,x,z) = x^T A(t) + (diag(t^p) z)^T \beta
</code>
</p>
<p> 2) the proportional setting that includes the Fine &amp; Gray (FG) &quot;prop&quot;
model and some extensions where <code class="reqn">h(x)=1-\exp(-\exp(x))</code> and </p>
<p style="text-align: center;"><code class="reqn">
g(t,x,z) = (x^T A(t) + (diag(t^p) z)^T \beta) </code>
</p>
<p> The FG model is obtained
when <code class="reqn">x=1</code>, but the baseline is parametrized as <code class="reqn">\exp(A(t))</code>.
</p>
<p>The &quot;fg&quot; model is a different parametrization that contains the FG model,
where <code class="reqn">h(x)=1-\exp(-x)</code> and </p>
<p style="text-align: center;"><code class="reqn"> g(t,x,z) = (x^T A(t)) \exp((diag(t^p)
z)^T \beta) </code>
</p>
<p> The FG model is obtained when <code class="reqn">x=1</code>.
</p>
<p>3) a &quot;logistic&quot; model where <code class="reqn">h(x)=\exp(x)/( 1+\exp(x))</code> and </p>
<p style="text-align: center;"><code class="reqn">
g(t,x,z) = x^T A(t) + (diag(t^p) z)^T \beta</code>
</p>
 
<p>The &quot;logistic2&quot; is </p>
<p style="text-align: center;"><code class="reqn"> P_1(t,x,z) = x^T A(t) exp((diag(t^p) z)^T \beta)/
(1+ x^T A(t) exp((diag(t^p) z)^T \beta)) </code>
</p>
<p> The simple logistic model with
just a baseline can also be fitted by an alternative procedure that has
better small sample properties see prop.odds.subist().
</p>
<p>4) the relative cumulative incidence function &quot;rcif&quot; model where
<code class="reqn">h(x)=\exp(x)</code> and </p>
<p style="text-align: center;"><code class="reqn"> g(t,x,z) = x^T A(t) + (diag(t^p) z)^T \beta </code>
</p>

<p>The &quot;rcif2&quot; </p>
<p style="text-align: center;"><code class="reqn"> P_1(t,x,z) = (x^T A(t)) \exp((diag(t^p) z)^T \beta) </code>
</p>

<p>Where p by default is 1 for the additive model and 0 for the other models.
In general p may be powers of the same length as z.
</p>
<p>Since timereg version 1.8.4. the response must be specified with the
<code><a href="#topic+Event">Event</a></code> function instead of the <code><a href="survival.html#topic+Surv">Surv</a></code> function and
the arguments. For example, if the old code was
</p>
<p>comp.risk(Surv(time,cause&gt;0)~x1+x2,data=mydata,cause=mydata$cause,causeS=1)
</p>
<p>the new code is
</p>
<p>comp.risk(Event(time,cause)~x1+x2,data=mydata,cause=1)
</p>
<p>Also the argument cens.code is now obsolete since cens.code is an argument
of <code><a href="#topic+Event">Event</a></code>.
</p>


<h3>Value</h3>

<p>returns an object of type 'comprisk'. With the following arguments:
</p>
<table>
<tr><td><code>cum</code></td>
<td>
<p>cumulative timevarying regression coefficient estimates are
computed within the estimation interval.</p>
</td></tr> <tr><td><code>var.cum</code></td>
<td>
<p>pointwise variances
estimates.  </p>
</td></tr> <tr><td><code>gamma</code></td>
<td>
<p>estimate of proportional odds parameters of
model.</p>
</td></tr> <tr><td><code>var.gamma</code></td>
<td>
<p>variance for gamma.  </p>
</td></tr> <tr><td><code>score</code></td>
<td>
<p>sum of absolute
value of scores.</p>
</td></tr> <tr><td><code>gamma2</code></td>
<td>
<p>estimate of constant effects based on the
non-parametric estimate. Used for testing of constant effects.</p>
</td></tr>
<tr><td><code>obs.testBeq0</code></td>
<td>
<p>observed absolute value of supremum of cumulative
components scaled with the variance.</p>
</td></tr> <tr><td><code>pval.testBeq0</code></td>
<td>
<p>p-value for
covariate effects based on supremum test.</p>
</td></tr> <tr><td><code>obs.testBeqC</code></td>
<td>
<p>observed
absolute value of supremum of difference between observed cumulative process
and estimate under null of constant effect.</p>
</td></tr> <tr><td><code>pval.testBeqC</code></td>
<td>
<p>p-value
based on resampling.</p>
</td></tr> <tr><td><code>obs.testBeqC.is</code></td>
<td>
<p>observed integrated squared
differences between observed cumulative and estimate under null of constant
effect.</p>
</td></tr> <tr><td><code>pval.testBeqC.is</code></td>
<td>
<p>p-value based on resampling.</p>
</td></tr>
<tr><td><code>conf.band</code></td>
<td>
<p>resampling based constant to construct 95% uniform
confidence bands.</p>
</td></tr> <tr><td><code>B.iid</code></td>
<td>
<p>list of iid decomposition of non-parametric
effects.</p>
</td></tr> <tr><td><code>gamma.iid</code></td>
<td>
<p>matrix of iid decomposition of parametric
effects.</p>
</td></tr> <tr><td><code>test.procBeqC</code></td>
<td>
<p>observed test process for testing of
time-varying effects</p>
</td></tr> <tr><td><code>sim.test.procBeqC</code></td>
<td>
<p>50 resample processes for for
testing of time-varying effects</p>
</td></tr> <tr><td><code>conv</code></td>
<td>
<p>information on convergence for
time points used for estimation.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Thomas Scheike
</p>


<h3>References</h3>

<p>Scheike, Zhang and Gerds (2008), Predicting cumulative incidence
probability by direct binomial regression,Biometrika, 95, 205-220.
</p>
<p>Scheike and Zhang (2007), Flexible competing risks regression modelling and
goodness of fit, LIDA, 14, 464-483.
</p>
<p>Martinussen and Scheike (2006), Dynamic regression models for survival data,
Springer.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(bmt); 

clust &lt;- rep(1:204,each=2)
addclust&lt;-comp.risk(Event(time,cause)~platelet+age+tcell+cluster(clust),data=bmt,
cause=1,resample.iid=1,n.sim=100,model="additive")
###

addclust&lt;-comp.risk(Event(time,cause)~+1+cluster(clust),data=bmt,cause=1,
		    resample.iid=1,n.sim=100,model="additive")
pad &lt;- predict(addclust,X=1)
plot(pad)

add&lt;-comp.risk(Event(time,cause)~platelet+age+tcell,data=bmt,
cause=1,resample.iid=1,n.sim=100,model="additive")
summary(add)

par(mfrow=c(2,4))
plot(add); 
### plot(add,score=1) ### to plot score functions for test

ndata&lt;-data.frame(platelet=c(1,0,0),age=c(0,1,0),tcell=c(0,0,1))
par(mfrow=c(2,3))
out&lt;-predict(add,ndata,uniform=1,n.sim=100)
par(mfrow=c(2,2))
plot(out,multiple=0,uniform=1,col=1:3,lty=1,se=1)

## fits additive model with some constant effects 
add.sem&lt;-comp.risk(Event(time,cause)~
const(platelet)+const(age)+const(tcell),data=bmt,
cause=1,resample.iid=1,n.sim=100,model="additive")
summary(add.sem)

out&lt;-predict(add.sem,ndata,uniform=1,n.sim=100)
par(mfrow=c(2,2))
plot(out,multiple=0,uniform=1,col=1:3,lty=1,se=0)

## Fine &amp; Gray model 
fg&lt;-comp.risk(Event(time,cause)~
const(platelet)+const(age)+const(tcell),data=bmt,
cause=1,resample.iid=1,model="fg",n.sim=100)
summary(fg)

out&lt;-predict(fg,ndata,uniform=1,n.sim=100)

par(mfrow=c(2,2))
plot(out,multiple=1,uniform=0,col=1:3,lty=1,se=0)

## extended model with time-varying effects
fg.npar&lt;-comp.risk(Event(time,cause)~platelet+age+const(tcell),
data=bmt,cause=1,resample.iid=1,model="prop",n.sim=100)
summary(fg.npar); 

out&lt;-predict(fg.npar,ndata,uniform=1,n.sim=100)
head(out$P1[,1:5]); head(out$se.P1[,1:5])

par(mfrow=c(2,2))
plot(out,multiple=1,uniform=0,col=1:3,lty=1,se=0)

## Fine &amp; Gray model with alternative parametrization for baseline
fg2&lt;-comp.risk(Event(time,cause)~const(platelet)+const(age)+const(tcell),data=bmt,
cause=1,resample.iid=1,model="prop",n.sim=100)
summary(fg2)

#################################################################
## Delayed entry models, 
#################################################################
nn &lt;- nrow(bmt)
entrytime &lt;- rbinom(nn,1,0.5)*(bmt$time*runif(nn))
bmt$entrytime &lt;- entrytime
times &lt;- seq(5,70,by=1)

bmtw &lt;- prep.comp.risk(bmt,times=times,time="time",entrytime="entrytime",cause="cause")

## non-parametric model 
outnp &lt;- comp.risk(Event(time,cause)~tcell+platelet+const(age),
		   data=bmtw,cause=1,fix.gamma=1,gamma=0,
 cens.weights=bmtw$cw,weights=bmtw$weights,times=times,n.sim=0)
par(mfrow=c(2,2))
plot(outnp)

outnp &lt;- comp.risk(Event(time,cause)~tcell+platelet,
		   data=bmtw,cause=1,
 cens.weights=bmtw$cw,weights=bmtw$weights,times=times,n.sim=0)
par(mfrow=c(2,2))
plot(outnp)


## semiparametric model 
out &lt;- comp.risk(Event(time,cause)~const(tcell)+const(platelet),data=bmtw,cause=1,
 cens.weights=bmtw$cw,weights=bmtw$weights,times=times,n.sim=0)
summary(out)


</code></pre>

<hr>
<h2 id='const'>Identifies parametric terms of model</h2><span id='topic+const'></span>

<h3>Description</h3>

<p>Specifies which of the regressors that have constant effect.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>const(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="const_+3A_x">x</code></td>
<td>
<p>variable</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Thomas Scheike
</p>

<hr>
<h2 id='cox'>Identifies proportional excess terms of model</h2><span id='topic+cox'></span>

<h3>Description</h3>

<p>Specifies which of the regressors that lead to proportional excess hazard
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cox(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cox_+3A_x">x</code></td>
<td>
<p>variable</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Thomas Scheike
</p>

<hr>
<h2 id='cox.aalen'>Fit Cox-Aalen survival model</h2><span id='topic+cox.aalen'></span>

<h3>Description</h3>

<p>Fits an Cox-Aalen survival model.  Time dependent variables and counting
process data (multiple events per subject) are possible.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cox.aalen(
  formula = formula(data),
  data = parent.frame(),
  beta = NULL,
  Nit = 20,
  detail = 0,
  start.time = 0,
  max.time = NULL,
  id = NULL,
  clusters = NULL,
  n.sim = 500,
  residuals = 0,
  robust = 1,
  weighted.test = 0,
  covariance = 0,
  resample.iid = 1,
  weights = NULL,
  rate.sim = 1,
  beta.fixed = 0,
  max.clust = 1000,
  exact.deriv = 1,
  silent = 1,
  max.timepoint.sim = 100,
  basesim = 0,
  offsets = NULL,
  strata = NULL,
  propodds = 0,
  caseweight = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cox.aalen_+3A_formula">formula</code></td>
<td>
<p>a formula object with the response on the left of a '~'
operator, and the independent terms on the right as regressors. The response
must be a survival object as returned by the &lsquo;Surv&rsquo; function. Terms with a
proportional effect are specified by the wrapper prop(), and cluster
variables (for computing robust variances) by the wrapper cluster().</p>
</td></tr>
<tr><td><code id="cox.aalen_+3A_data">data</code></td>
<td>
<p>a data.frame with the variables.</p>
</td></tr>
<tr><td><code id="cox.aalen_+3A_beta">beta</code></td>
<td>
<p>starting value for relative risk estimates.</p>
</td></tr>
<tr><td><code id="cox.aalen_+3A_nit">Nit</code></td>
<td>
<p>number of iterations for Newton-Raphson algorithm.</p>
</td></tr>
<tr><td><code id="cox.aalen_+3A_detail">detail</code></td>
<td>
<p>if 0 no details is printed during iterations, if 1 details are
given.</p>
</td></tr>
<tr><td><code id="cox.aalen_+3A_start.time">start.time</code></td>
<td>
<p>start of observation period where estimates are computed.</p>
</td></tr>
<tr><td><code id="cox.aalen_+3A_max.time">max.time</code></td>
<td>
<p>end of observation period where estimates are computed.
Estimates thus computed from [start.time, max.time]. Default is max of data.</p>
</td></tr>
<tr><td><code id="cox.aalen_+3A_id">id</code></td>
<td>
<p>For timevarying covariates the variable must associate each record
with the id of a subject.</p>
</td></tr>
<tr><td><code id="cox.aalen_+3A_clusters">clusters</code></td>
<td>
<p>cluster variable for computation of robust variances.</p>
</td></tr>
<tr><td><code id="cox.aalen_+3A_n.sim">n.sim</code></td>
<td>
<p>number of simulations in resampling.</p>
</td></tr>
<tr><td><code id="cox.aalen_+3A_residuals">residuals</code></td>
<td>
<p>to returns residuals that can be used for model validation
in the function cum.residuals. Estimated martingale increments (dM) and
corresponding time vector (time). When rate.sim=1 returns estimated
martingales, dM_i(t) and if rate.sim=0, returns a matrix of dN_i(t).</p>
</td></tr>
<tr><td><code id="cox.aalen_+3A_robust">robust</code></td>
<td>
<p>to compute robust variances and construct processes for
resampling. May be set to 0 to save memory and time, in particular for
rate.sim=1.</p>
</td></tr>
<tr><td><code id="cox.aalen_+3A_weighted.test">weighted.test</code></td>
<td>
<p>to compute a variance weighted version of the
test-processes used for testing time-varying effects.</p>
</td></tr>
<tr><td><code id="cox.aalen_+3A_covariance">covariance</code></td>
<td>
<p>to compute covariance estimates for nonparametric terms
rather than just the variances.</p>
</td></tr>
<tr><td><code id="cox.aalen_+3A_resample.iid">resample.iid</code></td>
<td>
<p>to return i.i.d. representation for nonparametric and
parametric terms. based on counting process or martingale resduals
(rate.sim).</p>
</td></tr>
<tr><td><code id="cox.aalen_+3A_weights">weights</code></td>
<td>
<p>weights for weighted analysis.</p>
</td></tr>
<tr><td><code id="cox.aalen_+3A_rate.sim">rate.sim</code></td>
<td>
<p>rate.sim=1 such that resampling of residuals is based on
estimated martingales and thus valid in rate case, rate.sim=0 means that
resampling is based on counting processes and thus only valid in intensity
case.</p>
</td></tr>
<tr><td><code id="cox.aalen_+3A_beta.fixed">beta.fixed</code></td>
<td>
<p>option for computing score process for fixed relative risk
parameter</p>
</td></tr>
<tr><td><code id="cox.aalen_+3A_max.clust">max.clust</code></td>
<td>
<p>sets the total number of i.i.d. terms in i.i.d.
decompostition. This can limit the amount of memory used by coarsening the
clusters. When NULL then all clusters are used.  Default is 1000 to save
memory and time.</p>
</td></tr>
<tr><td><code id="cox.aalen_+3A_exact.deriv">exact.deriv</code></td>
<td>
<p>if 1 then uses exact derivative in last iteration, if 2
then uses exact derivate for all iterations, and if 0 then uses
approximation for all computations and there may be a small bias in the
variance estimates. For Cox model always exact and all options give same
results.</p>
</td></tr>
<tr><td><code id="cox.aalen_+3A_silent">silent</code></td>
<td>
<p>if 1 then opppresses some output.</p>
</td></tr>
<tr><td><code id="cox.aalen_+3A_max.timepoint.sim">max.timepoint.sim</code></td>
<td>
<p>considers only this resolution on the time scale
for simulations, see time.sim.resolution argument</p>
</td></tr>
<tr><td><code id="cox.aalen_+3A_basesim">basesim</code></td>
<td>
<p>1 to get simulations for cumulative baseline, including tests
for contant effects.</p>
</td></tr>
<tr><td><code id="cox.aalen_+3A_offsets">offsets</code></td>
<td>
<p>offsets for analysis on log-scale. RR=exp(offsets+ x beta).</p>
</td></tr>
<tr><td><code id="cox.aalen_+3A_strata">strata</code></td>
<td>
<p>future option for making strata in a different day than
through X design in cox-aalen model (~-1+factor(strata)).</p>
</td></tr>
<tr><td><code id="cox.aalen_+3A_propodds">propodds</code></td>
<td>
<p>if 1 will fit the proportional odds model. Slightly less
efficient than prop.odds() function but much quicker, for large data this
also works.</p>
</td></tr>
<tr><td><code id="cox.aalen_+3A_caseweight">caseweight</code></td>
<td>
<p>these weights have length equal to number of jump times,
and are multiplied all jump times dN.  Useful for getting the program to fit
for example the proportional odds model or frailty models.</p>
</td></tr>
</table>


<h3>Details</h3>

<p style="text-align: center;"><code class="reqn"> \lambda_{i}(t) = Y_i(t) ( X_{i}^T(t) \alpha(t) ) \exp(Z_{i}^T \beta ) </code>
</p>

<p>The model thus contains the Cox's regression model as special case.
</p>
<p>To fit a stratified Cox model it is important to parametrize the baseline
apppropriately (see example below).
</p>
<p>Resampling is used for computing p-values for tests of time-varying effects.
Test for proportionality is considered by considering the score processes
for the proportional effects of model.
</p>
<p>The modelling formula uses the standard survival modelling given in the
<b>survival</b> package.
</p>
<p>The data for a subject is presented as multiple rows or 'observations', each
of which applies to an interval of observation (start, stop].  For counting
process data with the )start,stop] notation is used, the 'id' variable is
needed to identify the records for each subject. The program assumes that
there are no ties, and if such are present random noise is added to break
the ties.
</p>


<h3>Value</h3>

<p>returns an object of type &quot;cox.aalen&quot;. With the following arguments:
</p>
<table>
<tr><td><code>cum</code></td>
<td>
<p>cumulative timevarying regression coefficient estimates are
computed within the estimation interval. </p>
</td></tr> <tr><td><code>var.cum</code></td>
<td>
<p>the martingale
based pointwise variance estimates.  </p>
</td></tr> <tr><td><code>robvar.cum</code></td>
<td>
<p>robust pointwise
variances estimates.  </p>
</td></tr> <tr><td><code>gamma</code></td>
<td>
<p>estimate of parametric components of
model.  </p>
</td></tr> <tr><td><code>var.gamma</code></td>
<td>
<p>variance for gamma sandwhich estimator based on
optional variation estimator of score and 2nd derivative.</p>
</td></tr>
<tr><td><code>robvar.gamma</code></td>
<td>
<p>robust variance for gamma.  </p>
</td></tr> <tr><td><code>residuals</code></td>
<td>
<p>list with
residuals.</p>
</td></tr> <tr><td><code>obs.testBeq0</code></td>
<td>
<p>observed absolute value of supremum of
cumulative components scaled with the variance.</p>
</td></tr>
<tr><td><code>pval.testBeq0</code></td>
<td>
<p>p-value for covariate effects based on supremum test.</p>
</td></tr>
<tr><td><code>sim.testBeq0</code></td>
<td>
<p>resampled supremum values.</p>
</td></tr> <tr><td><code>obs.testBeqC</code></td>
<td>
<p>observed
absolute value of supremum of difference between observed cumulative process
and estimate under null of constant effect.</p>
</td></tr> <tr><td><code>pval.testBeqC</code></td>
<td>
<p>p-value
based on resampling.</p>
</td></tr> <tr><td><code>sim.testBeqC</code></td>
<td>
<p>resampled supremum values.</p>
</td></tr>
<tr><td><code>obs.testBeqC.is</code></td>
<td>
<p>observed integrated squared differences between
observed cumulative and estimate under null of constant effect.</p>
</td></tr>
<tr><td><code>pval.testBeqC.is</code></td>
<td>
<p>p-value based on resampling.</p>
</td></tr>
<tr><td><code>sim.testBeqC.is</code></td>
<td>
<p>resampled supremum values.</p>
</td></tr>
<tr><td><code>conf.band</code></td>
<td>
<p>resampling based constant to construct robust 95% uniform
confidence bands. </p>
</td></tr> <tr><td><code>test.procBeqC</code></td>
<td>
<p>observed test-process of difference
between observed cumulative process and estimate under null of constant
effect over time.  </p>
</td></tr> <tr><td><code>sim.test.procBeqC</code></td>
<td>
<p>list of 50 random realizations
of test-processes under null based on resampling.</p>
</td></tr>
<tr><td><code>covariance</code></td>
<td>
<p>covariances for nonparametric terms of model.</p>
</td></tr>
<tr><td><code>B.iid</code></td>
<td>
<p>Resample processes for nonparametric terms of model.</p>
</td></tr>
<tr><td><code>gamma.iid</code></td>
<td>
<p>Resample processes for parametric terms of model.</p>
</td></tr>
<tr><td><code>loglike</code></td>
<td>
<p>approximate log-likelihood for model, similar to Cox's
partial likelihood. Only computed when robust=1.</p>
</td></tr> <tr><td><code>D2linv</code></td>
<td>
<p>inverse of
the derivative of the score function.</p>
</td></tr> <tr><td><code>score</code></td>
<td>
<p>value of score for final
estimates.</p>
</td></tr> <tr><td><code>test.procProp</code></td>
<td>
<p>observed score process for proportional
part of model.</p>
</td></tr> <tr><td><code>var.score</code></td>
<td>
<p>variance of score process (optional
variation estimator for beta.fixed=1 and robust estimator otherwise).</p>
</td></tr>
<tr><td><code>pval.Prop</code></td>
<td>
<p>p-value based on resampling.</p>
</td></tr> <tr><td><code>sim.supProp</code></td>
<td>
<p>re-sampled
absolute supremum values.</p>
</td></tr> <tr><td><code>sim.test.procProp</code></td>
<td>
<p>list of 50 random
realizations of test-processes for proportionality under the model based on
resampling.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Thomas Scheike
</p>


<h3>References</h3>

<p>Martinussen and Scheike, Dynamic Regression Models for Survival
Data, Springer (2006).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(timereg)
data(sTRACE)
# Fits Cox model 
out&lt;-cox.aalen(Surv(time,status==9)~prop(age)+prop(sex)+
prop(vf)+prop(chf)+prop(diabetes),data=sTRACE)

# makes Lin, Wei, Ying test for proportionality
summary(out)
par(mfrow=c(2,3))
plot(out,score=1) 

# Fits stratified Cox model 
out&lt;-cox.aalen(Surv(time,status==9)~-1+factor(vf)+ prop(age)+prop(sex)+
	       prop(chf)+prop(diabetes),data=sTRACE,max.time=7,n.sim=100)
summary(out)
par(mfrow=c(1,2)); plot(out); 
# Same model, but needs to invert the entire marix for the aalen part: X(t) 
out&lt;-cox.aalen(Surv(time,status==9)~factor(vf)+ prop(age)+prop(sex)+
	       prop(chf)+prop(diabetes),data=sTRACE,max.time=7,n.sim=100)
summary(out)
par(mfrow=c(1,2)); plot(out); 


# Fits Cox-Aalen model 
out&lt;-cox.aalen(Surv(time,status==9)~prop(age)+prop(sex)+
               vf+chf+prop(diabetes),data=sTRACE,max.time=7,n.sim=100)
summary(out)
par(mfrow=c(2,3))
plot(out)

</code></pre>

<hr>
<h2 id='cox.ipw'>Missing data IPW Cox</h2><span id='topic+cox.ipw'></span><span id='topic+summary.cox.ipw'></span><span id='topic+print.cox.ipw'></span><span id='topic+coef.cox.ipw'></span>

<h3>Description</h3>

<p>Fits an Cox-Aalen survival model with missing data, with glm specification
of probability of missingness.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cox.ipw(
  survformula,
  glmformula,
  d = parent.frame(),
  max.clust = NULL,
  ipw.se = FALSE,
  tie.seed = 100
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cox.ipw_+3A_survformula">survformula</code></td>
<td>
<p>a formula object with the response on the left of a '~'
operator, and the independent terms on the right as regressors. The response
must be a survival object as returned by the &lsquo;Surv&rsquo; function.
</p>
<p>Adds the prop() wrapper internally for using cox.aalen function for fitting
Cox model.</p>
</td></tr>
<tr><td><code id="cox.ipw_+3A_glmformula">glmformula</code></td>
<td>
<p>formula for &quot;being&quot; observed, that is not missing.</p>
</td></tr>
<tr><td><code id="cox.ipw_+3A_d">d</code></td>
<td>
<p>data frame.</p>
</td></tr>
<tr><td><code id="cox.ipw_+3A_max.clust">max.clust</code></td>
<td>
<p>number of clusters in iid approximation. Default is all.</p>
</td></tr>
<tr><td><code id="cox.ipw_+3A_ipw.se">ipw.se</code></td>
<td>
<p>if TRUE computes standard errors based on iid decompositon of
cox and glm model, thus should be asymptotically correct.</p>
</td></tr>
<tr><td><code id="cox.ipw_+3A_tie.seed">tie.seed</code></td>
<td>
<p>if there are ties these are broken, and to get same break
the seed must be the same. Recommend to break them prior to entering the
program.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Taylor expansion of Cox's partial likelihood in direction of glm parameters
using num-deriv and iid expansion of Cox and glm paramters (lava).
</p>


<h3>Value</h3>

<p>returns an object of type &quot;cox.aalen&quot;. With the following arguments:
</p>
<table>
<tr><td><code>iid</code></td>
<td>
<p>iid decomposition.</p>
</td></tr> <tr><td><code>coef</code></td>
<td>
<p>missing data estiamtes for
weighted cox. </p>
</td></tr> <tr><td><code>var</code></td>
<td>
<p>robust pointwise variances estimates.  </p>
</td></tr>
<tr><td><code>se</code></td>
<td>
<p>robust pointwise variances estimates.  </p>
</td></tr> <tr><td><code>se.naive</code></td>
<td>
<p>estimate
of parametric components of model.  </p>
</td></tr> <tr><td><code>ties</code></td>
<td>
<p>list of ties and times
with random noise to break ties.</p>
</td></tr> <tr><td><code>cox</code></td>
<td>
<p>output from weighted cox
model.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Thomas Scheike
</p>


<h3>References</h3>

<p>Paik et al.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

### fit &lt;- cox.ipw(Surv(time,status)~X+Z,obs~Z+X+time+status,data=d,ipw.se=TRUE)
### summary(fit)


</code></pre>

<hr>
<h2 id='csl'>CSL liver chirrosis data</h2><span id='topic+csl'></span>

<h3>Description</h3>

<p>Survival status for the liver chirrosis patients of Schlichting et al.
</p>


<h3>Format</h3>

<p>This data frame contains the following columns:
</p>

<dl>
<dt>id</dt><dd>
<p>a numeric vector. Id of subject.
</p>
</dd>
<dt>time</dt><dd>
<p>a numeric vector. Time of measurement.
</p>
</dd>
<dt>prot</dt><dd>
<p>a numeric vector. Prothrombin level at measurement time.
</p>
</dd>
<dt>dc</dt><dd>
<p>a numeric vector code. 0: censored observation, 1: died at
eventT.
</p>
</dd>
<dt>eventT</dt><dd>
<p>a numeric vector. Time of event (death).
</p>
</dd>
<dt>treat</dt><dd>
<p>a numeric vector code. 0:  active treatment
of prednisone, 1: placebo treatment.
</p>
</dd>
<dt>sex</dt><dd>
<p>a numeric vector code. 0: female, 1: male.
</p>
</dd>
<dt>age</dt><dd>
<p>a numeric vector. Age of subject at inclusion time subtracted 60.
</p>
</dd>
<dt>prot.base</dt><dd>
<p>a numeric vector. Prothrombin base level before
entering the study.
</p>
</dd>
<dt>prot.prev</dt><dd>
<p>a numeric vector. Level of prothrombin at previous measurement
time.
</p>
</dd>
<dt>lt</dt><dd>
<p>a numeric vector. Gives the starting time for the
time-intervals.
</p>
</dd>
<dt>rt</dt><dd>
<p>a numeric vector. Gives the stopping time for the
time-intervals.
</p>
</dd>
</dl>



<h3>Source</h3>

<p>P.K. Andersen</p>


<h3>References</h3>

<p>Schlichting, P., Christensen, E., Andersen, P., Fauerholds, L.,
Juhl, E., Poulsen, H. and  Tygstrup, N. (1983), The Copenhagen 
Study Group for Liver Diseases, Hepatology 3, 889&ndash;895
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(csl)
names(csl)
</code></pre>

<hr>
<h2 id='cum.residuals'>Model validation based on cumulative residuals</h2><span id='topic+cum.residuals'></span>

<h3>Description</h3>

<p>Computes cumulative residuals and approximative p-values based on resampling
techniques.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cum.residuals(
  object,
  data = parent.frame(),
  modelmatrix = 0,
  cum.resid = 1,
  n.sim = 500,
  weighted.test = 0,
  max.point.func = 50,
  weights = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cum.residuals_+3A_object">object</code></td>
<td>
<p>an object of class 'aalen', 'timecox', 'cox.aalen' where the
residuals are returned ('residuals=1')</p>
</td></tr>
<tr><td><code id="cum.residuals_+3A_data">data</code></td>
<td>
<p>data frame based on which residuals are computed.</p>
</td></tr>
<tr><td><code id="cum.residuals_+3A_modelmatrix">modelmatrix</code></td>
<td>
<p>specifies a grouping of the data that is used for
cumulating residuals. Must have same size as data and be ordered in the same
way.</p>
</td></tr>
<tr><td><code id="cum.residuals_+3A_cum.resid">cum.resid</code></td>
<td>
<p>to compute residuals versus each of the continuous
covariates in the model.</p>
</td></tr>
<tr><td><code id="cum.residuals_+3A_n.sim">n.sim</code></td>
<td>
<p>number of simulations in resampling.</p>
</td></tr>
<tr><td><code id="cum.residuals_+3A_weighted.test">weighted.test</code></td>
<td>
<p>to compute a variance weighted version of the
test-processes used for testing constant effects of covariates.</p>
</td></tr>
<tr><td><code id="cum.residuals_+3A_max.point.func">max.point.func</code></td>
<td>
<p>limits the amount of computations, only considers a
max of 50 points on the covariate scales.</p>
</td></tr>
<tr><td><code id="cum.residuals_+3A_weights">weights</code></td>
<td>
<p>weights for sum of martingale residuals, now for cum.resid=1.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns an object of type &quot;cum.residuals&quot; with the following
arguments: </p>
<table>
<tr><td><code>cum</code></td>
<td>
<p>cumulative residuals versus time for the groups
specified by modelmatrix. </p>
</td></tr> <tr><td><code>var.cum</code></td>
<td>
<p>the martingale based pointwise
variance estimates.</p>
</td></tr> <tr><td><code>robvar.cum</code></td>
<td>
<p>robust pointwise variances estimates
of cumulatives.</p>
</td></tr> <tr><td><code>obs.testBeq0</code></td>
<td>
<p>observed absolute value of supremum of
cumulative components scaled with the variance.</p>
</td></tr>
<tr><td><code>pval.testBeq0</code></td>
<td>
<p>p-value covariate effects based on supremum test.</p>
</td></tr>
<tr><td><code>sim.testBeq0</code></td>
<td>
<p>resampled supremum value.</p>
</td></tr> <tr><td><code>conf.band</code></td>
<td>
<p>resampling
based constant to construct robust 95% uniform confidence bands for
cumulative residuals.</p>
</td></tr> <tr><td><code>obs.test</code></td>
<td>
<p>absolute value of supremum of
observed test-process.</p>
</td></tr> <tr><td><code>pval.test</code></td>
<td>
<p>p-value for supremum test
statistic.</p>
</td></tr> <tr><td><code>sim.test</code></td>
<td>
<p>resampled absolute value of supremum cumulative
residuals.</p>
</td></tr> <tr><td><code>proc.cumz</code></td>
<td>
<p>observed cumulative residuals versus all
continuous covariates of model.</p>
</td></tr> <tr><td><code>sim.test.proccumz</code></td>
<td>
<p>list of 50 random
realizations of test-processes under model for all continuous covariates.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Thomas Scheike
</p>


<h3>References</h3>

<p>Martinussen and Scheike, Dynamic Regression Models for Survival
Data, Springer (2006).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(sTRACE)
# Fits Aalen model and returns residuals
fit&lt;-aalen(Surv(time,status==9)~age+sex+diabetes+chf+vf,
           data=sTRACE,max.time=7,n.sim=0,residuals=1)

# constructs and simulates cumulative residuals versus age groups
fit.mg&lt;-cum.residuals(fit,data=sTRACE,n.sim=100,
modelmatrix=model.matrix(~-1+factor(cut(age,4)),sTRACE))

par(mfrow=c(1,4))
# cumulative residuals with confidence intervals
plot(fit.mg);
# cumulative residuals versus processes under model
plot(fit.mg,score=1); 
summary(fit.mg)

# cumulative residuals vs. covariates Lin, Wei, Ying style 
fit.mg&lt;-cum.residuals(fit,data=sTRACE,cum.resid=1,n.sim=100)

par(mfrow=c(2,4))
plot(fit.mg,score=2)
summary(fit.mg)

</code></pre>

<hr>
<h2 id='diabetes'>The Diabetic Retinopathy Data</h2><span id='topic+diabetes'></span>

<h3>Description</h3>

<p>The data was colleceted to test a laser treatment for delaying
blindness in patients with dibetic retinopathy. The subset of 197
patiens given in Huster et al. (1989) is used. 
</p>


<h3>Format</h3>

<p>This data frame contains the following columns:
</p>

<dl>
<dt>id</dt><dd><p>a numeric vector. Patient code.</p>
</dd>
<dt>agedx</dt><dd><p>a numeric vector. Age of patient at diagnosis.</p>
</dd>
<dt>time</dt><dd><p>a numeric vector. Survival time: time to blindness or 
censoring.</p>
</dd>
<dt>status</dt><dd>
<p>a numeric vector code. Survival status. 1: blindness, 0: censored.</p>
</dd>
<dt>trteye</dt><dd><p>a numeric vector code. Random eye selected for
treatment. 1: left eye 2: right eye.</p>
</dd>
<dt>treat</dt><dd><p>a numeric vector. 1: treatment 0: untreated.</p>
</dd> 
<dt>adult</dt><dd><p>a numeric vector code. 1: younger than 20, 2: older than 20.</p>
</dd>
</dl>



<h3>Source</h3>

<p>Huster W.J. and Brookmeyer, R. and Self. S. (1989) 
MOdelling paired survival data with covariates, Biometrics 45,
145-56.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(diabetes)
names(diabetes)
</code></pre>

<hr>
<h2 id='dynreg'>Fit time-varying regression model</h2><span id='topic+dynreg'></span>

<h3>Description</h3>

<p>Fits time-varying regression model with partly parametric components.
Time-dependent variables for longitudinal data.  The model assumes that the
mean of the observed responses given covariates is a linear time-varying
regression model :
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dynreg(
  formula = formula(data),
  data = parent.frame(),
  aalenmod,
  bandwidth = 0.5,
  id = NULL,
  bhat = NULL,
  start.time = 0,
  max.time = NULL,
  n.sim = 500,
  meansub = 1,
  weighted.test = 0,
  resample = 0
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dynreg_+3A_formula">formula</code></td>
<td>
<p>a formula object with the response on the left of a '~'
operator, and the independent terms on the right as regressors.</p>
</td></tr>
<tr><td><code id="dynreg_+3A_data">data</code></td>
<td>
<p>a data.frame with the variables.</p>
</td></tr>
<tr><td><code id="dynreg_+3A_aalenmod">aalenmod</code></td>
<td>
<p>Aalen model for measurement times. Specified as a survival
model (see aalen function).</p>
</td></tr>
<tr><td><code id="dynreg_+3A_bandwidth">bandwidth</code></td>
<td>
<p>bandwidth for local iterations. Default is 50% of the
range of the considered observation period.</p>
</td></tr>
<tr><td><code id="dynreg_+3A_id">id</code></td>
<td>
<p>For timevarying covariates the variable must associate each record
with the id of a subject.</p>
</td></tr>
<tr><td><code id="dynreg_+3A_bhat">bhat</code></td>
<td>
<p>initial value for estimates. If NULL local linear estimate is
computed.</p>
</td></tr>
<tr><td><code id="dynreg_+3A_start.time">start.time</code></td>
<td>
<p>start of observation period where estimates are computed.</p>
</td></tr>
<tr><td><code id="dynreg_+3A_max.time">max.time</code></td>
<td>
<p>end of observation period where estimates are computed.
Estimates thus computed from [start.time, max.time]. Default is max of data.</p>
</td></tr>
<tr><td><code id="dynreg_+3A_n.sim">n.sim</code></td>
<td>
<p>number of simulations in resampling.</p>
</td></tr>
<tr><td><code id="dynreg_+3A_meansub">meansub</code></td>
<td>
<p>if '1' then the mean of the responses is subtracted before
the estimation is carried out.</p>
</td></tr>
<tr><td><code id="dynreg_+3A_weighted.test">weighted.test</code></td>
<td>
<p>to compute a variance weighted version of the
test-processes used for testing time-varying effects.</p>
</td></tr>
<tr><td><code id="dynreg_+3A_resample">resample</code></td>
<td>
<p>returns resample processes.</p>
</td></tr>
</table>


<h3>Details</h3>

<p style="text-align: center;"><code class="reqn"> E( Z_{ij} | X_{ij}(t) ) = \beta^T(t) X_{ij}^1(t) + \gamma^T X_{ij}^2(t) </code>
</p>
 
<p>where <code class="reqn">Z_{ij}</code> is the j'th measurement at time t for the
i'th subject with covariates <code class="reqn">X_{ij}^1</code> and <code class="reqn">X_{ij}^2</code>. Resampling
is used for computing p-values for tests of timevarying effects.
The data for a subject is presented as multiple rows or 'observations', each
of which applies to an interval of observation (start, stop].  For counting
process data with the )start,stop] notation is used the 'id' variable is
needed to identify the records for each subject. The program assumes that
there are no ties, and if such are present random noise is added to break
the ties.
</p>


<h3>Value</h3>

<p>returns an object of type &quot;dynreg&quot;. With the following arguments:
</p>
<table>
<tr><td><code>cum</code></td>
<td>
<p>the cumulative regression coefficients. This is the efficient
estimator based on an initial smoother obtained by local linear regression :
</p>
<p style="text-align: center;"><code class="reqn"> \hat B(t) = \int_0^t \tilde \beta(s) ds+ \hspace{4 cm}</code>
</p>
 
<p style="text-align: center;"><code class="reqn">\int_0^t X^{-} (Diag(z) -Diag( X^T(s) \tilde \beta(s)) ) dp(ds \times dz), </code>
</p>
 
<p>where <code class="reqn">\tilde \beta(t)</code> is an initial estimate either
provided or computed by local linear regression. To plot this estimate use
type=&quot;eff.smooth&quot; in the plot() command. </p>
</td></tr> 
<tr><td><code>var.cum</code></td>
<td>
<p>the martingale based pointwise variance estimates.</p>
</td></tr> 
<tr><td><code>robvar.cum</code></td>
<td>
<p>robust pointwise variances estimates.</p>
</td></tr> 
<tr><td><code>gamma</code></td>
<td>
<p>estimate of semi-parametric components of model.</p>
</td></tr> 
<tr><td><code>var.gamma</code></td>
<td>
<p>variance for gamma.</p>
</td></tr> 
<tr><td><code>robvar.gamma</code></td>
<td>
<p>robust variance for gamma.</p>
</td></tr> 
<tr><td><code>cum0</code></td>
<td>
<p>simple estimate of cumulative regression
coefficients that does not use use an initial smoothing based estimate
</p>
<p style="text-align: center;"><code class="reqn"> \hat B_0(t) = \int_0^t X^{-} Diag(z) dp(ds \times dz). </code>
</p>
<p> To plot this
estimate use type=&quot;0.mpp&quot; in the plot() command. </p>
</td></tr> 
<tr><td><code>var.cum0</code></td>
<td>
<p>the martingale based pointwise variance estimates of cum0.</p>
</td></tr>
<tr><td><code>cum.ms</code></td>
<td>
<p>estimate of cumulative regression coefficients based on
initial smoother (but robust to this estimator).  </p>
<p style="text-align: center;"><code class="reqn"> \hat B_{ms}(t) =
\int_0^t X^{-} (Diag(z)-f(s)) dp(ds \times dz), </code>
</p>
<p> where <code class="reqn">f</code> is chosen as
the matrix </p>
<p style="text-align: center;"><code class="reqn"> f(s) = Diag( X^T(s) \tilde \beta(s)) ( I - X_\alpha(s) X_\alpha^-(s) ), </code>
</p>

<p>where <code class="reqn">X_{\alpha}</code> is the design for the sampling
intensities.
This is also an efficient estimator when the initial estimator is consistent
for <code class="reqn">\beta(t)</code> and then asymptotically equivalent to cum, but small
sample properties appear inferior. Its variance is estimated by var.cum.
To plot this estimate use type=&quot;ms.mpp&quot; in the plot() command. </p>
</td></tr>
<tr><td><code>cum.ly</code></td>
<td>
<p>estimator where local averages are subtracted. Special case of
cum.ms. To plot this estimate use type=&quot;ly.mpp&quot; in plot.  </p>
</td></tr>
<tr><td><code>var.cum.ly</code></td>
<td>
<p>the martingale based pointwise variance estimates. </p>
</td></tr>
<tr><td><code>gamma0</code></td>
<td>
<p>estimate of parametric component of model.  </p>
</td></tr>
<tr><td><code>var.gamma0</code></td>
<td>
<p>estimate of variance of parametric component of model. </p>
</td></tr>
<tr><td><code>gamma.ly</code></td>
<td>
<p>estimate of parametric components of model. </p>
</td></tr>
<tr><td><code>var.gamma.ly</code></td>
<td>
<p>estimate of variance of parametric component of model. </p>
</td></tr>
<tr><td><code>gamma.ms</code></td>
<td>
<p>estimate of variance of parametric component of model. </p>
</td></tr>
<tr><td><code>var.gamma.ms</code></td>
<td>
<p>estimate of variance of parametric component of model.</p>
</td></tr>
<tr><td><code>obs.testBeq0</code></td>
<td>
<p>observed absolute value of supremum of cumulative
components scaled with the variance.</p>
</td></tr> <tr><td><code>pval.testBeq0</code></td>
<td>
<p>p-value for
covariate effects based on supremum test.</p>
</td></tr> <tr><td><code>sim.testBeq0</code></td>
<td>
<p>resampled
supremum values.</p>
</td></tr> <tr><td><code>obs.testBeqC</code></td>
<td>
<p>observed absolute value of supremum of
difference between observed cumulative process and estimate under null of
constant effect.</p>
</td></tr> <tr><td><code>pval.testBeqC</code></td>
<td>
<p>p-value based on resampling.</p>
</td></tr>
<tr><td><code>sim.testBeqC</code></td>
<td>
<p>resampled supremum values.</p>
</td></tr>
<tr><td><code>obs.testBeqC.is</code></td>
<td>
<p>observed integrated squared differences between
observed cumulative and estimate under null of constant effect.</p>
</td></tr>
<tr><td><code>pval.testBeqC.is</code></td>
<td>
<p>p-value based on resampling.</p>
</td></tr>
<tr><td><code>sim.testBeqC.is</code></td>
<td>
<p>resampled supremum values.</p>
</td></tr>
<tr><td><code>conf.band</code></td>
<td>
<p>resampling based constant to construct robust 95% uniform
confidence bands.</p>
</td></tr> 
<tr><td><code>test.procBeqC</code></td>
<td>
<p>observed test-process of difference
between observed cumulative process and estimate under null of constant effect.</p>
</td></tr> 
<tr><td><code>sim.test.procBeqC</code></td>
<td>
<p>list of 50 random realizations of
test-processes under null based on resampling.</p>
</td></tr>
<tr><td><code>covariance</code></td>
<td>
<p>covariances for nonparametric terms of model.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Thomas Scheike
</p>


<h3>References</h3>

<p>Martinussen and Scheike, Dynamic Regression Models for Survival
Data, Springer (2006).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
 
## this runs slowly and is therfore donttest
data(csl)
indi.m&lt;-rep(1,length(csl$lt)) 

# Fits time-varying regression model 
out&lt;-dynreg(prot~treat+prot.prev+sex+age,data=csl,
Surv(lt,rt,indi.m)~+1,start.time=0,max.time=2,id=csl$id,
n.sim=100,bandwidth=0.7,meansub=0)
summary(out)
par(mfrow=c(2,3))
plot(out)

# Fits time-varying semi-parametric regression model.
outS&lt;-dynreg(prot~treat+const(prot.prev)+const(sex)+const(age),data=csl,
Surv(lt,rt,indi.m)~+1,start.time=0,max.time=2,id=csl$id,
n.sim=100,bandwidth=0.7,meansub=0)
summary(outS)


</code></pre>

<hr>
<h2 id='Event'>Event history object</h2><span id='topic+Event'></span><span id='topic+as.character.Event'></span><span id='topic+as.matrix.Event'></span><span id='topic++5B.Event'></span><span id='topic+format.Event'></span><span id='topic+print.Event'></span><span id='topic+rbind.Event'></span><span id='topic+summary.Event'></span>

<h3>Description</h3>

<p>Constructur for Event History objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Event(time, time2 = TRUE, cause = NULL, cens.code = 0, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Event_+3A_time">time</code></td>
<td>
<p>Time</p>
</td></tr>
<tr><td><code id="Event_+3A_time2">time2</code></td>
<td>
<p>Time 2</p>
</td></tr>
<tr><td><code id="Event_+3A_cause">cause</code></td>
<td>
<p>Cause</p>
</td></tr>
<tr><td><code id="Event_+3A_cens.code">cens.code</code></td>
<td>
<p>Censoring code (default 0)</p>
</td></tr>
<tr><td><code id="Event_+3A_...">...</code></td>
<td>
<p>Additional arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>... content for details
</p>


<h3>Value</h3>

<p>Object of class Event (a matrix)
</p>


<h3>Author(s)</h3>

<p>Klaus K. Holst and Thomas Scheike
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
	t1 &lt;- 1:10
	t2 &lt;- t1+runif(10)
	ca &lt;- rbinom(10,2,0.4)
	(x &lt;- Event(t1,t2,ca))

</code></pre>

<hr>
<h2 id='event.split'>EventSplit (SurvSplit).</h2><span id='topic+event.split'></span>

<h3>Description</h3>

<p>contstructs start stop formulation of event time data after a variable in
the data.set. Similar to SurvSplit of the survival package but can also
split after random time given in data frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>event.split(
  data,
  time = "time",
  status = "status",
  cuts = "cuts",
  name.id = "id",
  name.start = "start",
  cens.code = 0,
  order.id = TRUE,
  time.group = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="event.split_+3A_data">data</code></td>
<td>
<p>data to be split</p>
</td></tr>
<tr><td><code id="event.split_+3A_time">time</code></td>
<td>
<p>time variable.</p>
</td></tr>
<tr><td><code id="event.split_+3A_status">status</code></td>
<td>
<p>status variable.</p>
</td></tr>
<tr><td><code id="event.split_+3A_cuts">cuts</code></td>
<td>
<p>cuts variable or numeric cut (only one value)</p>
</td></tr>
<tr><td><code id="event.split_+3A_name.id">name.id</code></td>
<td>
<p>name of id variable.</p>
</td></tr>
<tr><td><code id="event.split_+3A_name.start">name.start</code></td>
<td>
<p>name of start variable in data, start can also be numeric &quot;0&quot;</p>
</td></tr>
<tr><td><code id="event.split_+3A_cens.code">cens.code</code></td>
<td>
<p>code for the censoring.</p>
</td></tr>
<tr><td><code id="event.split_+3A_order.id">order.id</code></td>
<td>
<p>order data after id and start.</p>
</td></tr>
<tr><td><code id="event.split_+3A_time.group">time.group</code></td>
<td>
<p>make variable &quot;before&quot;.&quot;cut&quot; that keeps track of wether start,stop is before (1) or after cut (0).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Thomas Scheike
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(1)
d &lt;- data.frame(event=round(5*runif(5),2),start=1:5,time=2*1:5,
		status=rbinom(5,1,0.5),x=1:5)
d

d0 &lt;- event.split(d,cuts="event",name.start=0)
d0

dd &lt;- event.split(d,cuts="event")
dd
ddd &lt;- event.split(dd,cuts=3.5)
ddd
event.split(ddd,cuts=5.5)

### successive cutting for many values 
dd &lt;- d
for  (cuts in seq(2,3,by=0.3)) dd &lt;- event.split(dd,cuts=cuts)
dd

###########################################################################
### same but for situation with multiple events along the time-axis
###########################################################################
d &lt;- data.frame(event1=1:5+runif(5)*0.5,start=1:5,time=2*1:5,
		status=rbinom(5,1,0.5),x=1:5,start0=0)
d$event2 &lt;- d$event1+0.2
d$event2[4:5] &lt;- NA 
d

d0 &lt;- event.split(d,cuts="event1",name.start="start",time="time",status="status")
d0
###
d00 &lt;- event.split(d0,cuts="event2",name.start="start",time="time",status="status")
d00

</code></pre>

<hr>
<h2 id='Gprop.odds'>Fit Generalized Semiparametric Proportional 0dds Model</h2><span id='topic+Gprop.odds'></span>

<h3>Description</h3>

<p>Fits a semiparametric proportional odds model: </p>
<p style="text-align: center;"><code class="reqn"> logit(1-S_{X,Z}(t)) =
log(X^T A(t)) + \beta^T Z </code>
</p>
<p> where A(t) is increasing but otherwise
unspecified. Model is fitted by maximising the modified partial likelihood.
A goodness-of-fit test by considering the score functions is also computed
by resampling methods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Gprop.odds(
  formula = formula(data),
  data = parent.frame(),
  beta = 0,
  Nit = 50,
  detail = 0,
  start.time = 0,
  max.time = NULL,
  id = NULL,
  n.sim = 500,
  weighted.test = 0,
  sym = 0,
  mle.start = 0
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Gprop.odds_+3A_formula">formula</code></td>
<td>
<p>a formula object, with the response on the left of a '~'
operator, and the terms on the right.  The response must be a survival
object as returned by the &lsquo;Surv&rsquo; function.</p>
</td></tr>
<tr><td><code id="Gprop.odds_+3A_data">data</code></td>
<td>
<p>a data.frame with the variables.</p>
</td></tr>
<tr><td><code id="Gprop.odds_+3A_beta">beta</code></td>
<td>
<p>starting value for relative risk estimates</p>
</td></tr>
<tr><td><code id="Gprop.odds_+3A_nit">Nit</code></td>
<td>
<p>number of iterations for Newton-Raphson algorithm.</p>
</td></tr>
<tr><td><code id="Gprop.odds_+3A_detail">detail</code></td>
<td>
<p>if 0 no details is printed during iterations, if 1 details are
given.</p>
</td></tr>
<tr><td><code id="Gprop.odds_+3A_start.time">start.time</code></td>
<td>
<p>start of observation period where estimates are computed.</p>
</td></tr>
<tr><td><code id="Gprop.odds_+3A_max.time">max.time</code></td>
<td>
<p>end of observation period where estimates are computed.
Estimates thus computed from [start.time, max.time].  This is very useful to
obtain stable estimates, especially for the baseline. Default is max of
data.</p>
</td></tr>
<tr><td><code id="Gprop.odds_+3A_id">id</code></td>
<td>
<p>For timevarying covariates the variable must associate each record
with the id of a subject.</p>
</td></tr>
<tr><td><code id="Gprop.odds_+3A_n.sim">n.sim</code></td>
<td>
<p>number of simulations in resampling.</p>
</td></tr>
<tr><td><code id="Gprop.odds_+3A_weighted.test">weighted.test</code></td>
<td>
<p>to compute a variance weighted version of the
test-processes used for testing time-varying effects.</p>
</td></tr>
<tr><td><code id="Gprop.odds_+3A_sym">sym</code></td>
<td>
<p>to use symmetrized second derivative in the case of the
estimating equation approach (profile=0).  This may improve the numerical
performance.</p>
</td></tr>
<tr><td><code id="Gprop.odds_+3A_mle.start">mle.start</code></td>
<td>
<p>starting values for relative risk parameters.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An alternative way of writing the model : </p>
<p style="text-align: center;"><code class="reqn"> S_{X,Z}(t)) = \frac{ \exp(
- \beta^T Z )}{ (X^T A(t)) + \exp( - \beta^T Z) } </code>
</p>
<p> such that <code class="reqn">\beta</code> is
the log-odds-ratio of dying before time t, and <code class="reqn">A(t)</code> is the odds-ratio.
</p>
<p>The modelling formula uses the standard survival modelling given in the
<b>survival</b> package.
</p>
<p>The data for a subject is presented as multiple rows or &quot;observations&quot;, each
of which applies to an interval of observation (start, stop]. The program
essentially assumes no ties, and if such are present a little random noise
is added to break the ties.
</p>


<h3>Value</h3>

<p>returns an object of type 'cox.aalen'. With the following arguments:
</p>
<table>
<tr><td><code>cum</code></td>
<td>
<p>cumulative timevarying regression coefficient estimates are
computed within the estimation interval.</p>
</td></tr> <tr><td><code>var.cum</code></td>
<td>
<p>the martingale
based pointwise variance estimates.  </p>
</td></tr> <tr><td><code>robvar.cum</code></td>
<td>
<p>robust pointwise
variances estimates.  </p>
</td></tr> <tr><td><code>gamma</code></td>
<td>
<p>estimate of proportional odds
parameters of model.</p>
</td></tr> <tr><td><code>var.gamma</code></td>
<td>
<p>variance for gamma.  </p>
</td></tr>
<tr><td><code>robvar.gamma</code></td>
<td>
<p>robust variance for gamma.  </p>
</td></tr> <tr><td><code>residuals</code></td>
<td>
<p>list with
residuals. Estimated martingale increments (dM) and corresponding time
vector (time).</p>
</td></tr> <tr><td><code>obs.testBeq0</code></td>
<td>
<p>observed absolute value of supremum of
cumulative components scaled with the variance.</p>
</td></tr>
<tr><td><code>pval.testBeq0</code></td>
<td>
<p>p-value for covariate effects based on supremum test.</p>
</td></tr>
<tr><td><code>sim.testBeq0</code></td>
<td>
<p>resampled supremum values.</p>
</td></tr> <tr><td><code>obs.testBeqC</code></td>
<td>
<p>observed
absolute value of supremum of difference between observed cumulative process
and estimate under null of constant effect.</p>
</td></tr> <tr><td><code>pval.testBeqC</code></td>
<td>
<p>p-value
based on resampling.</p>
</td></tr> <tr><td><code>sim.testBeqC</code></td>
<td>
<p>resampled supremum values.</p>
</td></tr>
<tr><td><code>obs.testBeqC.is</code></td>
<td>
<p>observed integrated squared differences between
observed cumulative and estimate under null of constant effect.</p>
</td></tr>
<tr><td><code>pval.testBeqC.is</code></td>
<td>
<p>p-value based on resampling.</p>
</td></tr>
<tr><td><code>sim.testBeqC.is</code></td>
<td>
<p>resampled supremum values.</p>
</td></tr>
<tr><td><code>conf.band</code></td>
<td>
<p>resampling based constant to construct robust 95% uniform
confidence bands. </p>
</td></tr> <tr><td><code>test.procBeqC</code></td>
<td>
<p>observed test-process of difference
between observed cumulative process and estimate under null of constant
effect over time.</p>
</td></tr> <tr><td><code>loglike</code></td>
<td>
<p>modified partial likelihood, pseudo
profile likelihood for regression parameters.</p>
</td></tr> <tr><td><code>D2linv</code></td>
<td>
<p>inverse of the
derivative of the score function.</p>
</td></tr> <tr><td><code>score</code></td>
<td>
<p>value of score for final
estimates.</p>
</td></tr> <tr><td><code>test.procProp</code></td>
<td>
<p>observed score process for proportional
odds regression effects.</p>
</td></tr> <tr><td><code>pval.Prop</code></td>
<td>
<p>p-value based on resampling.</p>
</td></tr>
<tr><td><code>sim.supProp</code></td>
<td>
<p>re-sampled supremum values.</p>
</td></tr>
<tr><td><code>sim.test.procProp</code></td>
<td>
<p>list of 50 random realizations of test-processes
for constant proportional odds under the model based on resampling.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Thomas Scheike
</p>


<h3>References</h3>

<p>Scheike, A flexible semiparametric transformation model for
survival data, Lifetime Data Anal. (to appear).
</p>
<p>Martinussen and Scheike, Dynamic Regression Models for Survival Data,
Springer (2006).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(sTRACE)

### runs slowly and is therefore donttest 
data(sTRACE)
# Fits Proportional odds model with stratified baseline
age.c&lt;-scale(sTRACE$age,scale=FALSE); 
## out&lt;-Gprop.odds(Surv(time,status==9)~-1+factor(diabetes)+prop(age.c)+prop(chf)+
##                 prop(sex)+prop(vf),data=sTRACE,max.time=7,n.sim=50)
## summary(out) 
## par(mfrow=c(2,3))
## plot(out,sim.ci=2); plot(out,score=1) 



</code></pre>

<hr>
<h2 id='krylow.pls'>Fits Krylow based PLS for additive hazards model</h2><span id='topic+krylow.pls'></span>

<h3>Description</h3>

<p>Fits the PLS estimator for the additive risk model based on the least
squares fitting criterion
</p>


<h3>Usage</h3>

<pre><code class='language-R'>krylow.pls(D, d, dim = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="krylow.pls_+3A_d">D</code></td>
<td>
<p>defined above</p>
</td></tr>
<tr><td><code id="krylow.pls_+3A_d">d</code></td>
<td>
<p>defined above</p>
</td></tr>
<tr><td><code id="krylow.pls_+3A_dim">dim</code></td>
<td>
<p>number of pls dimensions</p>
</td></tr>
</table>


<h3>Details</h3>

<p style="text-align: center;"><code class="reqn"> L(\beta,D,d) = \beta^T D \beta - 2 \beta^T d </code>
</p>
<p> where <code class="reqn">D=\int Z H
Z dt</code> and <code class="reqn">d=\int Z H dN</code>.
</p>


<h3>Value</h3>

<p>returns a list with the following arguments: </p>
<table>
<tr><td><code>beta</code></td>
<td>
<p>PLS
regression coefficients</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Thomas Scheike
</p>


<h3>References</h3>

<p>Martinussen and Scheike, The Aalen additive hazards model with
high-dimensional regressors, submitted.
</p>
<p>Martinussen and Scheike, Dynamic Regression Models for Survival Data,
Springer (2006).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## makes data for pbc complete case
data(mypbc)
pbc&lt;-mypbc
pbc$time&lt;-pbc$time+runif(418)*0.1; pbc$time&lt;-pbc$time/365
pbc&lt;-subset(pbc,complete.cases(pbc));
covs&lt;-as.matrix(pbc[,-c(1:3,6)])
covs&lt;-cbind(covs[,c(1:6,16)],log(covs[,7:15]))

## computes the matrices needed for the least squares 
## criterion 
out&lt;-aalen(Surv(time,status&gt;=1)~const(covs),pbc,robust=0,n.sim=0)
S=out$intZHZ; s=out$intZHdN;

out&lt;-krylow.pls(S,s,dim=2)

</code></pre>

<hr>
<h2 id='mela.pop'>Melanoma data and Danish population mortality by age and sex
</h2><span id='topic+mela.pop'></span>

<h3>Description</h3>

<p>Melanoma data with background mortality of Danish population.
</p>


<h3>Format</h3>

<p>This data frame contains the following columns:
</p>

<dl>
<dt>id</dt><dd> 
<p>a numeric vector. Gives patient id.
</p>
</dd>
<dt>sex</dt><dd>
<p>a numeric vector. Gives sex of patient.
</p>
</dd>
<dt>start</dt><dd>
<p>a numeric vector. 
Gives the starting time for the
time-interval for which the covariate rate is representative.
</p>
</dd>
<dt>stop</dt><dd>
<p>a numeric vector. Gives the stopping time for the
time-interval for which the covariate rate is representative.
</p>
</dd>
<dt>status</dt><dd>
<p>a numeric vector code. Survival status. 1: dead from melanoma, 0: alive or
dead from other cause.
</p>
</dd>
<dt>age</dt><dd>
<p>a numeric vector. Gives the age of the patient at removal of tumor.
</p>
</dd>
<dt>rate</dt><dd>
<p>a numeric vector. Gives the population mortality for the 
given sex and age.  Based on Table A.2 in Andersen 
et al. (1993). 
</p>
</dd>
</dl>



<h3>Source</h3>

<p>Andersen, P.K., Borgan O, Gill R.D., Keiding N. (1993),
<em>Statistical Models Based on 
Counting Processes</em>, Springer-Verlag. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(mela.pop)
names(mela.pop)
</code></pre>

<hr>
<h2 id='melanoma'>The Melanoma Survival Data</h2><span id='topic+melanoma'></span>

<h3>Description</h3>

<p>The melanoma data frame has 205 rows and 7 columns.
It contains data relating to survival of patients after 
operation for malignant melanoma collected at 
Odense University Hospital by K.T.  Drzewiecki. 
</p>


<h3>Format</h3>

<p>This data frame contains the following columns:
</p>

<dl>
<dt>no</dt><dd>
<p>a numeric vector. Patient code.
</p>
</dd>
<dt>status</dt><dd>
<p>a numeric vector code. Survival status. 1: dead from melanoma, 2: alive,
3: dead from other cause.
</p>
</dd>
<dt>days</dt><dd>
<p>a numeric vector. Survival time.
</p>
</dd>
<dt>ulc</dt><dd>
<p>a numeric vector code. Ulceration, 1: present, 0: absent.
</p>
</dd>
<dt>thick</dt><dd>
<p>a numeric vector. Tumour thickness (1/100 mm).
</p>
</dd>
<dt>sex</dt><dd>
<p>a numeric vector code. 0: female, 1: male.
</p>
</dd>
</dl>



<h3>Source</h3>

<p>Andersen, P.K., Borgan O, Gill R.D., Keiding N. (1993),
<em>Statistical Models Based on 
Counting Processes</em>, Springer-Verlag. 
</p>
<p>Drzewiecki, K.T., Ladefoged, C., and Christensen, H.E. (1980),
Biopsy and prognosis for cutaneous malignant melanoma in clinical
stage I. Scand. J. Plast. Reconstru. Surg. 14, 141-144. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(melanoma)
names(melanoma)
</code></pre>

<hr>
<h2 id='mypbc'>my version of the PBC data of the survival package</h2><span id='topic+mypbc'></span>

<h3>Description</h3>

<p> my version of the PBC data of the survival package
</p>


<h3>Source</h3>

<p> survival package 
</p>

<hr>
<h2 id='pava.pred'>Make predictions of predict functions in rows mononotone</h2><span id='topic+pava.pred'></span>

<h3>Description</h3>

<p>Make predictions of predict functions in rows mononotone using the
pool-adjacent-violators-algorithm
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pava.pred(pred, increasing = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pava.pred_+3A_pred">pred</code></td>
<td>
<p>predictions, either vector or rows of predictions.</p>
</td></tr>
<tr><td><code id="pava.pred_+3A_increasing">increasing</code></td>
<td>
<p>increasing or decreasing.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>mononotone predictions.
</p>


<h3>Author(s)</h3>

<p>Thomas Scheike
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(bmt); 

## competing risks 
add&lt;-comp.risk(Event(time,cause)~platelet+age+tcell,data=bmt,cause=1)
ndata&lt;-data.frame(platelet=c(1,0,0),age=c(0,1,0),tcell=c(0,0,1))
out&lt;-predict(add,newdata=ndata,uniform=0)

par(mfrow=c(1,1))
head(out$P1)
matplot(out$time,t(out$P1),type="s")

###P1m &lt;- t(apply(out$P1,1,pava))
P1monotone &lt;- pava.pred(out$P1)
head(P1monotone)
matlines(out$time,t(P1monotone),type="s")

</code></pre>

<hr>
<h2 id='pe.sasieni'>Fits Proportional excess hazards model with fixed offsets</h2><span id='topic+pe.sasieni'></span><span id='topic+summary.pe-sasieni'></span>

<h3>Description</h3>

<p>Fits proportional excess hazards model. The Sasieni proportional excess risk
model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pe.sasieni(
  formula = formula(data),
  data = parent.frame(),
  id = NULL,
  start.time = 0,
  max.time = NULL,
  offsets = 0,
  Nit = 50,
  detail = 0,
  n.sim = 500
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pe.sasieni_+3A_formula">formula</code></td>
<td>
<p>a formula object, with the response on the left of a &lsquo;~&rsquo;
operator, and the terms on the right.  The response must be a survival
object as returned by the &lsquo;Surv&rsquo; function.</p>
</td></tr>
<tr><td><code id="pe.sasieni_+3A_data">data</code></td>
<td>
<p>a data.frame with the variables.</p>
</td></tr>
<tr><td><code id="pe.sasieni_+3A_id">id</code></td>
<td>
<p>gives the number of individuals.</p>
</td></tr>
<tr><td><code id="pe.sasieni_+3A_start.time">start.time</code></td>
<td>
<p>starting time for considered time-period.</p>
</td></tr>
<tr><td><code id="pe.sasieni_+3A_max.time">max.time</code></td>
<td>
<p>stopping considered time-period if different from 0.
Estimates thus computed from [0,max.time] if max.time&gt;0. Default is max of
data.</p>
</td></tr>
<tr><td><code id="pe.sasieni_+3A_offsets">offsets</code></td>
<td>
<p>fixed offsets giving the mortality.</p>
</td></tr>
<tr><td><code id="pe.sasieni_+3A_nit">Nit</code></td>
<td>
<p>number of itterations.</p>
</td></tr>
<tr><td><code id="pe.sasieni_+3A_detail">detail</code></td>
<td>
<p>if detail is one, prints iteration details.</p>
</td></tr>
<tr><td><code id="pe.sasieni_+3A_n.sim">n.sim</code></td>
<td>
<p>number of simulations, 0 for no simulations.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The models are written using the survival modelling given in the survival
package.
</p>
<p>The program assumes that there are no ties, and if such are present random
noise is added to break the ties.
</p>


<h3>Value</h3>

<p>Returns an object of type &quot;pe.sasieni&quot;.  With the following
arguments: </p>
<table>
<tr><td><code>cum</code></td>
<td>
<p>baseline of Cox model excess risk.</p>
</td></tr>
<tr><td><code>var.cum</code></td>
<td>
<p>pointwise variance estimates for estimated cumulatives.</p>
</td></tr>
<tr><td><code>gamma</code></td>
<td>
<p>estimate of relative risk terms of model.</p>
</td></tr>
<tr><td><code>var.gamma</code></td>
<td>
<p>variance estimates for gamma.</p>
</td></tr> <tr><td><code>Ut</code></td>
<td>
<p>score process for
Cox part of model.</p>
</td></tr> <tr><td><code>D2linv</code></td>
<td>
<p>The inverse of the second derivative.</p>
</td></tr>
<tr><td><code>score</code></td>
<td>
<p>final score</p>
</td></tr> <tr><td><code>test.Prop</code></td>
<td>
<p>re-sampled absolute supremum
values.</p>
</td></tr> <tr><td><code>pval.Prop</code></td>
<td>
<p>p-value based on resampling.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Thomas Scheike
</p>


<h3>References</h3>

<p>Martinussen and Scheike, Dynamic Regression Models for Survival
Data, Springer Verlag (2006).
</p>
<p>Sasieni, P.D., Proportional excess hazards, Biometrika (1996), 127&ndash;41.
</p>
<p>Cortese, G. and Scheike, T.H., Dynamic regression hazards models for
relative survival (2007), submitted.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(mela.pop)
out&lt;-pe.sasieni(Surv(start,stop,status==1)~age+sex,mela.pop,
id=1:205,Nit=10,max.time=7,offsets=mela.pop$rate,detail=0,n.sim=100)
summary(out)

ul&lt;-out$cum[,2]+1.96*out$var.cum[,2]^.5
ll&lt;-out$cum[,2]-1.96*out$var.cum[,2]^.5
plot(out$cum,type="s",ylim=range(ul,ll))
lines(out$cum[,1],ul,type="s"); lines(out$cum[,1],ll,type="s")
# see also prop.excess function

</code></pre>

<hr>
<h2 id='plot.aalen'>Plots estimates and test-processes</h2><span id='topic+plot.aalen'></span><span id='topic+plot.cox.aalen'></span><span id='topic+plot.timecox'></span><span id='topic+plot.prop.excess'></span>

<h3>Description</h3>

<p>This function plots the non-parametric cumulative estimates for the additive
risk model or the test-processes for the hypothesis of time-varying effects
with re-sampled processes under the null.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'aalen'
plot(
  x,
  pointwise.ci = 1,
  hw.ci = 0,
  sim.ci = 0,
  robust.ci = 0,
  col = NULL,
  specific.comps = FALSE,
  level = 0.05,
  start.time = 0,
  stop.time = 0,
  add.to.plot = FALSE,
  mains = TRUE,
  xlab = "Time",
  ylab = "Cumulative coefficients",
  score = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.aalen_+3A_x">x</code></td>
<td>
<p>the output from the &quot;aalen&quot; function.</p>
</td></tr>
<tr><td><code id="plot.aalen_+3A_pointwise.ci">pointwise.ci</code></td>
<td>
<p>if &gt;1 pointwise confidence intervals are plotted with
lty=pointwise.ci</p>
</td></tr>
<tr><td><code id="plot.aalen_+3A_hw.ci">hw.ci</code></td>
<td>
<p>if &gt;1 Hall-Wellner confidence bands are plotted with lty=hw.ci.
Only 0.95 % bands can be constructed.</p>
</td></tr>
<tr><td><code id="plot.aalen_+3A_sim.ci">sim.ci</code></td>
<td>
<p>if &gt;1 simulation based confidence bands are plotted with
lty=sim.ci. These confidence bands are robust to non-martingale behaviour.</p>
</td></tr>
<tr><td><code id="plot.aalen_+3A_robust.ci">robust.ci</code></td>
<td>
<p>robust standard errors are used to estimate standard error
of estimate, otherwise martingale based standard errors are used.</p>
</td></tr>
<tr><td><code id="plot.aalen_+3A_col">col</code></td>
<td>
<p>specifice colors of different components of plot, in order:
c(estimate,pointwise.ci,robust.ci,hw.ci,sim.ci) so for example, when we ask
to get pointwise.ci, hw.ci and sim.ci we would say c(1,2,3,4) to use colors
as specified.</p>
</td></tr>
<tr><td><code id="plot.aalen_+3A_specific.comps">specific.comps</code></td>
<td>
<p>all components of the model is plotted by default, but
a list of components may be specified, for example first and third &quot;c(1,3)&quot;.</p>
</td></tr>
<tr><td><code id="plot.aalen_+3A_level">level</code></td>
<td>
<p>gives the significance level.</p>
</td></tr>
<tr><td><code id="plot.aalen_+3A_start.time">start.time</code></td>
<td>
<p>start of observation period where estimates are plotted.</p>
</td></tr>
<tr><td><code id="plot.aalen_+3A_stop.time">stop.time</code></td>
<td>
<p>end of period where estimates are plotted. Estimates thus
plotted from [start.time, max.time].</p>
</td></tr>
<tr><td><code id="plot.aalen_+3A_add.to.plot">add.to.plot</code></td>
<td>
<p>to add to an already existing plot.</p>
</td></tr>
<tr><td><code id="plot.aalen_+3A_mains">mains</code></td>
<td>
<p>add names of covariates as titles to plots.</p>
</td></tr>
<tr><td><code id="plot.aalen_+3A_xlab">xlab</code></td>
<td>
<p>label for x-axis.</p>
</td></tr>
<tr><td><code id="plot.aalen_+3A_ylab">ylab</code></td>
<td>
<p>label for y-axis.</p>
</td></tr>
<tr><td><code id="plot.aalen_+3A_score">score</code></td>
<td>
<p>to plot test processes for test of time-varying effects along
with 50 random realization under the null-hypothesis.</p>
</td></tr>
<tr><td><code id="plot.aalen_+3A_...">...</code></td>
<td>
<p>unused arguments - for S3 compatibility</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Thomas Scheike
</p>


<h3>References</h3>

<p>Martinussen and Scheike, Dynamic Regression models for Survival
Data, Springer (2006).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# see help(aalen) 
data(sTRACE)
out&lt;-aalen(Surv(time,status==9)~chf+vf,sTRACE,max.time=7,n.sim=100)
par(mfrow=c(2,2))
plot(out,pointwise.ci=1,hw.ci=1,sim.ci=1,col=c(1,2,3,4))
par(mfrow=c(2,2))
plot(out,pointwise.ci=0,robust.ci=1,hw.ci=1,sim.ci=1,col=c(1,2,3,4))

</code></pre>

<hr>
<h2 id='plot.cum.residuals'>Plots cumulative residuals</h2><span id='topic+plot.cum.residuals'></span>

<h3>Description</h3>

<p>This function plots the output from the cumulative residuals function
&quot;cum.residuals&quot;.  The cumulative residuals are compared with the performance
of similar processes under the model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cum.residuals'
plot(
  x,
  pointwise.ci = 1,
  hw.ci = 0,
  sim.ci = 0,
  robust = 1,
  specific.comps = FALSE,
  level = 0.05,
  start.time = 0,
  stop.time = 0,
  add.to.plot = FALSE,
  mains = TRUE,
  main = NULL,
  xlab = NULL,
  ylab = "Cumulative MG-residuals",
  ylim = NULL,
  score = 0,
  conf.band = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.cum.residuals_+3A_x">x</code></td>
<td>
<p>the output from the &quot;cum.residuals&quot; function.</p>
</td></tr>
<tr><td><code id="plot.cum.residuals_+3A_pointwise.ci">pointwise.ci</code></td>
<td>
<p>if &gt;1 pointwise confidence intervals are plotted with
lty=pointwise.ci</p>
</td></tr>
<tr><td><code id="plot.cum.residuals_+3A_hw.ci">hw.ci</code></td>
<td>
<p>if &gt;1 Hall-Wellner confidence bands are plotted with lty=hw.ci.
Only 95% bands can be constructed.</p>
</td></tr>
<tr><td><code id="plot.cum.residuals_+3A_sim.ci">sim.ci</code></td>
<td>
<p>if &gt;1 simulation based confidence bands are plotted with
lty=sim.ci. These confidence bands are robust to non-martingale behaviour.</p>
</td></tr>
<tr><td><code id="plot.cum.residuals_+3A_robust">robust</code></td>
<td>
<p>if &quot;1&quot; robust standard errors are used to estimate standard
error of estimate, otherwise martingale based estimate are used.</p>
</td></tr>
<tr><td><code id="plot.cum.residuals_+3A_specific.comps">specific.comps</code></td>
<td>
<p>all components of the model is plotted by default, but
a list of components may be specified, for example first and third &quot;c(1,3)&quot;.</p>
</td></tr>
<tr><td><code id="plot.cum.residuals_+3A_level">level</code></td>
<td>
<p>gives the significance level. Default is 0.05.</p>
</td></tr>
<tr><td><code id="plot.cum.residuals_+3A_start.time">start.time</code></td>
<td>
<p>start of observation period where estimates are plotted.
Default is 0.</p>
</td></tr>
<tr><td><code id="plot.cum.residuals_+3A_stop.time">stop.time</code></td>
<td>
<p>end of period where estimates are plotted. Estimates thus
plotted from [start.time, max.time].</p>
</td></tr>
<tr><td><code id="plot.cum.residuals_+3A_add.to.plot">add.to.plot</code></td>
<td>
<p>to add to an already existing plot. Default is &quot;FALSE&quot;.</p>
</td></tr>
<tr><td><code id="plot.cum.residuals_+3A_mains">mains</code></td>
<td>
<p>add names of covariates as titles to plots.</p>
</td></tr>
<tr><td><code id="plot.cum.residuals_+3A_main">main</code></td>
<td>
<p>vector of names for titles in plots.</p>
</td></tr>
<tr><td><code id="plot.cum.residuals_+3A_xlab">xlab</code></td>
<td>
<p>label for x-axis. NULL is default which leads to &quot;Time&quot; or &quot;&quot;.
Can also give a character vector.</p>
</td></tr>
<tr><td><code id="plot.cum.residuals_+3A_ylab">ylab</code></td>
<td>
<p>label for y-axis. Default is &quot;Cumulative MG-residuals&quot;.</p>
</td></tr>
<tr><td><code id="plot.cum.residuals_+3A_ylim">ylim</code></td>
<td>
<p>limits for y-axis.</p>
</td></tr>
<tr><td><code id="plot.cum.residuals_+3A_score">score</code></td>
<td>
<p>if '0' plots related to modelmatrix are specified, thus
resulting in grouped residuals, if '1' plots for modelmatrix but with random
realizations under model, if '2' plots residuals versus continuous
covariates of model with random realizations under the model.</p>
</td></tr>
<tr><td><code id="plot.cum.residuals_+3A_conf.band">conf.band</code></td>
<td>
<p>makes simulation based confidence bands for the test
processes under the 0 based on variance of these processes limits for
y-axis. These will give additional information of whether the observed
cumulative residuals are extreme or not when based on a variance weighted
test.</p>
</td></tr>
<tr><td><code id="plot.cum.residuals_+3A_...">...</code></td>
<td>
<p>unused arguments - for S3 compatibility</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Thomas Scheike
</p>


<h3>References</h3>

<p>Martinussen and Scheike, Dynamic Regression Models for Survival
Data, Springer (2006).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# see cum.residuals for examples 

</code></pre>

<hr>
<h2 id='plot.dynreg'>Plots estimates and test-processes</h2><span id='topic+plot.dynreg'></span>

<h3>Description</h3>

<p>This function plots the non-parametric cumulative estimates for the additive
risk model or the test-processes for the hypothesis of constant effects with
re-sampled processes under the null.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dynreg'
plot(
  x,
  type = "eff.smooth",
  pointwise.ci = 1,
  hw.ci = 0,
  sim.ci = 0,
  robust = 0,
  specific.comps = FALSE,
  level = 0.05,
  start.time = 0,
  stop.time = 0,
  add.to.plot = FALSE,
  mains = TRUE,
  xlab = "Time",
  ylab = "Cumulative coefficients",
  score = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.dynreg_+3A_x">x</code></td>
<td>
<p>the output from the &quot;dynreg&quot; function.</p>
</td></tr>
<tr><td><code id="plot.dynreg_+3A_type">type</code></td>
<td>
<p>the estimator plotted. Choices &quot;eff.smooth&quot;, &quot;ms.mpp&quot;, &quot;0.mpp&quot;
and &quot;ly.mpp&quot;. See the dynreg function for more on this.</p>
</td></tr>
<tr><td><code id="plot.dynreg_+3A_pointwise.ci">pointwise.ci</code></td>
<td>
<p>if &gt;1 pointwise confidence intervals are plotted with
lty=pointwise.ci</p>
</td></tr>
<tr><td><code id="plot.dynreg_+3A_hw.ci">hw.ci</code></td>
<td>
<p>if &gt;1 Hall-Wellner confidence bands are plotted with lty=hw.ci.
Only 0.95 % bands can be constructed.</p>
</td></tr>
<tr><td><code id="plot.dynreg_+3A_sim.ci">sim.ci</code></td>
<td>
<p>if &gt;1 simulation based confidence bands are plotted with
lty=sim.ci. These confidence bands are robust to non-martingale behaviour.</p>
</td></tr>
<tr><td><code id="plot.dynreg_+3A_robust">robust</code></td>
<td>
<p>robust standard errors are used to estimate standard error of
estimate, otherwise martingale based estimate are used.</p>
</td></tr>
<tr><td><code id="plot.dynreg_+3A_specific.comps">specific.comps</code></td>
<td>
<p>all components of the model is plotted by default, but
a list of components may be specified, for example first and third &quot;c(1,3)&quot;.</p>
</td></tr>
<tr><td><code id="plot.dynreg_+3A_level">level</code></td>
<td>
<p>gives the significance level.</p>
</td></tr>
<tr><td><code id="plot.dynreg_+3A_start.time">start.time</code></td>
<td>
<p>start of observation period where estimates are plotted.</p>
</td></tr>
<tr><td><code id="plot.dynreg_+3A_stop.time">stop.time</code></td>
<td>
<p>end of period where estimates are plotted. Estimates thus
plotted from [start.time, max.time].</p>
</td></tr>
<tr><td><code id="plot.dynreg_+3A_add.to.plot">add.to.plot</code></td>
<td>
<p>to add to an already existing plot.</p>
</td></tr>
<tr><td><code id="plot.dynreg_+3A_mains">mains</code></td>
<td>
<p>add names of covariates as titles to plots.</p>
</td></tr>
<tr><td><code id="plot.dynreg_+3A_xlab">xlab</code></td>
<td>
<p>label for x-axis.</p>
</td></tr>
<tr><td><code id="plot.dynreg_+3A_ylab">ylab</code></td>
<td>
<p>label for y-axis.</p>
</td></tr>
<tr><td><code id="plot.dynreg_+3A_score">score</code></td>
<td>
<p>to plot test processes for test of time-varying effects along
with 50 random realization under the null-hypothesis.</p>
</td></tr>
<tr><td><code id="plot.dynreg_+3A_...">...</code></td>
<td>
<p>unused arguments - for S3 compatibility</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Thomas Scheike
</p>


<h3>References</h3>

<p>Martinussen and Scheike, Dynamic Regression Models for Survival
Data, Springer (2006).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

### runs slowly and therefore donttest 
data(csl)
indi.m&lt;-rep(1,length(csl$lt))

# Fits time-varying regression model
out&lt;-dynreg(prot~treat+prot.prev+sex+age,csl,
Surv(lt,rt,indi.m)~+1,start.time=0,max.time=3,id=csl$id,
n.sim=100,bandwidth=0.7,meansub=0)

par(mfrow=c(2,3))
# plots estimates 
plot(out)
# plots tests-processes for time-varying effects 
plot(out,score=TRUE)


</code></pre>

<hr>
<h2 id='predict.timereg'>Predictions for Survival and Competings Risks Regression for timereg</h2><span id='topic+predict.timereg'></span><span id='topic+predict.aalen'></span><span id='topic+predict.comprisk'></span><span id='topic+predict.cox.aalen'></span>

<h3>Description</h3>

<p>Make predictions based on the survival models (Aalen and Cox-Aalen) and the
competing risks models for the cumulative incidence function (comp.risk).
Computes confidence intervals and confidence bands based on resampling.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'timereg'
predict(
  object,
  newdata = NULL,
  X = NULL,
  times = NULL,
  Z = NULL,
  n.sim = 500,
  uniform = TRUE,
  se = TRUE,
  alpha = 0.05,
  resample.iid = 0,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.timereg_+3A_object">object</code></td>
<td>
<p>an object belonging to one of the following classes: comprisk,
aalen or cox.aalen</p>
</td></tr>
<tr><td><code id="predict.timereg_+3A_newdata">newdata</code></td>
<td>
<p>specifies the data at which the predictions are wanted.</p>
</td></tr>
<tr><td><code id="predict.timereg_+3A_x">X</code></td>
<td>
<p>alternative to newdata, specifies the nonparametric components for
predictions.</p>
</td></tr>
<tr><td><code id="predict.timereg_+3A_times">times</code></td>
<td>
<p>times in which predictions are computed, default is all
time-points for baseline</p>
</td></tr>
<tr><td><code id="predict.timereg_+3A_z">Z</code></td>
<td>
<p>alternative to newdata, specifies the parametric components of the
model for predictions.</p>
</td></tr>
<tr><td><code id="predict.timereg_+3A_n.sim">n.sim</code></td>
<td>
<p>number of simulations in resampling.</p>
</td></tr>
<tr><td><code id="predict.timereg_+3A_uniform">uniform</code></td>
<td>
<p>computes resampling based uniform confidence bands.</p>
</td></tr>
<tr><td><code id="predict.timereg_+3A_se">se</code></td>
<td>
<p>computes pointwise standard errors</p>
</td></tr>
<tr><td><code id="predict.timereg_+3A_alpha">alpha</code></td>
<td>
<p>specificies the significance levelwhich cause we consider.</p>
</td></tr>
<tr><td><code id="predict.timereg_+3A_resample.iid">resample.iid</code></td>
<td>
<p>set to 1 to return iid decomposition of estimates, 3-dim
matrix (predictions x times x subjects)</p>
</td></tr>
<tr><td><code id="predict.timereg_+3A_...">...</code></td>
<td>
<p>unused arguments - for S3 compatability</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>time</code></td>
<td>
<p>vector of time points where the predictions are
computed.</p>
</td></tr> <tr><td><code>unif.band</code></td>
<td>
<p>resampling based constant to construct 95%
uniform confidence bands.</p>
</td></tr> <tr><td><code>model</code></td>
<td>
<p>specifies what model that was
fitted.</p>
</td></tr> <tr><td><code>alpha</code></td>
<td>
<p>specifies the significance level for the confidence
intervals. This relates directly to the constant given in unif.band.</p>
</td></tr>
<tr><td><code>newdata</code></td>
<td>
<p>specifies the newdata given in the call.</p>
</td></tr> <tr><td><code>RR</code></td>
<td>
<p>gives
relative risk terms for Cox-type models.</p>
</td></tr> <tr><td><code>call</code></td>
<td>
<p>gives call for predict
funtion.</p>
</td></tr> <tr><td><code>initial.call</code></td>
<td>
<p>gives call for underlying object used for
predictions.</p>
</td></tr> <tr><td><code>P1</code></td>
<td>
<p>gives cumulative inicidence predictions for
competing risks models. Predictions given in matrix form with different
subjects in different rows.</p>
</td></tr> <tr><td><code>S0</code></td>
<td>
<p>gives survival predictions for
survival models.  Predictions given in matrix form with different subjects
in different rows.</p>
</td></tr> <tr><td><code>se.P1</code></td>
<td>
<p>pointwise standard errors for predictions
of P1.</p>
</td></tr> <tr><td><code>se.S0</code></td>
<td>
<p>pointwise standard errors for predictions of S0.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Thomas Scheike, Jeremy Silver
</p>


<h3>References</h3>

<p>Scheike, Zhang and Gerds (2008), Predicting cumulative incidence
probability by direct binomial regression, Biometrika, 95, 205-220.
</p>
<p>Scheike and Zhang (2007), Flexible competing risks regression modelling and
goodness of fit, LIDA, 14, 464-483 .
</p>
<p>Martinussen and Scheike (2006), Dynamic regression models for survival data,
Springer.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(bmt); 

## competing risks 
add&lt;-comp.risk(Event(time,cause)~platelet+age+tcell,data=bmt,cause=1)

ndata&lt;-data.frame(platelet=c(1,0,0),age=c(0,1,0),tcell=c(0,0,1))
out&lt;-predict(add,newdata=ndata,uniform=1,n.sim=1000)
par(mfrow=c(2,2))
plot(out,multiple=0,uniform=1,col=1:3,lty=1,se=1)
# see comp.risk for further examples. 

add&lt;-comp.risk(Event(time,cause)~factor(tcell),data=bmt,cause=1)
summary(add)
out&lt;-predict(add,newdata=ndata,uniform=1,n.sim=1000)
plot(out,multiple=1,uniform=1,col=1:3,lty=1,se=1)

add&lt;-prop.odds.subdist(Event(time,cause)~factor(tcell),
	       data=bmt,cause=1)
out &lt;- predict(add,X=1,Z=1)
plot(out,multiple=1,uniform=1,col=1:3,lty=1,se=1)


## SURVIVAL predictions aalen function
data(sTRACE)
out&lt;-aalen(Surv(time,status==9)~sex+ diabetes+chf+vf,
data=sTRACE,max.time=7,n.sim=0,resample.iid=1)

pout&lt;-predict(out,X=rbind(c(1,0,0,0,0),rep(1,5)))
head(pout$S0[,1:5]); head(pout$se.S0[,1:5])
par(mfrow=c(2,2))
plot(pout,multiple=1,se=0,uniform=0,col=1:2,lty=1:2)
plot(pout,multiple=0,se=1,uniform=1,col=1:2)

out&lt;-aalen(Surv(time,status==9)~const(age)+const(sex)+
const(diabetes)+chf+vf,
data=sTRACE,max.time=7,n.sim=0,resample.iid=1)

pout&lt;-predict(out,X=rbind(c(1,0,0),c(1,1,0)),
Z=rbind(c(55,0,1),c(60,1,1)))
head(pout$S0[,1:5]); head(pout$se.S0[,1:5])
par(mfrow=c(2,2))
plot(pout,multiple=1,se=0,uniform=0,col=1:2,lty=1:2)
plot(pout,multiple=0,se=1,uniform=1,col=1:2)

pout&lt;-predict(out,uniform=0,se=0,newdata=sTRACE[1:10,]) 
plot(pout,multiple=1,se=0,uniform=0)

#### cox.aalen
out&lt;-cox.aalen(Surv(time,status==9)~prop(age)+prop(sex)+
prop(diabetes)+chf+vf,
data=sTRACE,max.time=7,n.sim=0,resample.iid=1)

pout&lt;-predict(out,X=rbind(c(1,0,0),c(1,1,0)),Z=rbind(c(55,0,1),c(60,1,1)))
head(pout$S0[,1:5]); head(pout$se.S0[,1:5])
par(mfrow=c(2,2))
plot(pout,multiple=1,se=0,uniform=0,col=1:2,lty=1:2)
plot(pout,multiple=0,se=1,uniform=1,col=1:2)

pout&lt;-predict(out,uniform=0,se=0,newdata=sTRACE[1:10,]) 
plot(pout,multiple=1,se=0,uniform=0)

#### prop.odds model 
add&lt;-prop.odds(Event(time,cause!=0)~factor(tcell),data=bmt)
out &lt;- predict(add,X=1,Z=0)
plot(out,multiple=1,uniform=1,col=1:3,lty=1,se=1)

</code></pre>

<hr>
<h2 id='prep.comp.risk'>Set up weights for delayed-entry competing risks data for comp.risk function</h2><span id='topic+prep.comp.risk'></span>

<h3>Description</h3>

<p>Computes the weights of Geskus (2011) modified to the setting of the
comp.risk function. The returned weights are
<code class="reqn">1/(H(T_i)*G_c(min(T_i,tau)))</code> and tau is the max of the times argument,
here <code class="reqn">H</code> is the estimator of the truncation distribution and <code class="reqn">G_c</code>
is the right censoring distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prep.comp.risk(
  data,
  times = NULL,
  entrytime = NULL,
  time = "time",
  cause = "cause",
  cname = "cweight",
  tname = "tweight",
  strata = NULL,
  nocens.out = TRUE,
  cens.formula = NULL,
  cens.code = 0,
  prec.factor = 100,
  trunc.mintau = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prep.comp.risk_+3A_data">data</code></td>
<td>
<p>data frame for comp.risk.</p>
</td></tr>
<tr><td><code id="prep.comp.risk_+3A_times">times</code></td>
<td>
<p>times for estimating equations.</p>
</td></tr>
<tr><td><code id="prep.comp.risk_+3A_entrytime">entrytime</code></td>
<td>
<p>name of delayed entry variable, if not given computes
right-censoring case.</p>
</td></tr>
<tr><td><code id="prep.comp.risk_+3A_time">time</code></td>
<td>
<p>name of survival time variable.</p>
</td></tr>
<tr><td><code id="prep.comp.risk_+3A_cause">cause</code></td>
<td>
<p>name of cause indicator</p>
</td></tr>
<tr><td><code id="prep.comp.risk_+3A_cname">cname</code></td>
<td>
<p>name of censoring weight.</p>
</td></tr>
<tr><td><code id="prep.comp.risk_+3A_tname">tname</code></td>
<td>
<p>name of truncation weight.</p>
</td></tr>
<tr><td><code id="prep.comp.risk_+3A_strata">strata</code></td>
<td>
<p>strata variable to obtain stratified weights.</p>
</td></tr>
<tr><td><code id="prep.comp.risk_+3A_nocens.out">nocens.out</code></td>
<td>
<p>returns only uncensored part of data-frame</p>
</td></tr>
<tr><td><code id="prep.comp.risk_+3A_cens.formula">cens.formula</code></td>
<td>
<p>censoring model formula for Cox models for the
truncation and censoring model.</p>
</td></tr>
<tr><td><code id="prep.comp.risk_+3A_cens.code">cens.code</code></td>
<td>
<p>code for censoring among causes.</p>
</td></tr>
<tr><td><code id="prep.comp.risk_+3A_prec.factor">prec.factor</code></td>
<td>
<p>precision factor, for ties between censoring/even times,
truncation times/event times</p>
</td></tr>
<tr><td><code id="prep.comp.risk_+3A_trunc.mintau">trunc.mintau</code></td>
<td>
<p>specicies wether the truncation distribution is
evaluated in death times or death times minimum max(times), FALSE makes the
estimator equivalent to Kaplan-Meier (in the no covariate case).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an object. With the following arguments: </p>
<table>
<tr><td><code>dataw</code></td>
<td>
<p>a
data.frame with weights.</p>
</td></tr>
</table>
<p>The function wants to make two new variables &quot;weights&quot; and &quot;cw&quot; so if these
already are in the data frame it tries to add an &quot;_&quot; in the names.
</p>


<h3>Author(s)</h3>

<p>Thomas Scheike
</p>


<h3>References</h3>

<p>Geskus (2011), Cause-Specific Cumulative Incidence Estimation
and the Fine and Gray Model Under Both Left Truncation and Right Censoring,
Biometrics (2011), pp 39-49.
</p>
<p>Shen (2011), Proportional subdistribution hazards regression for
left-truncated competing risks data, Journal of Nonparametric Statistics
(2011), 23, 885-895
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(bmt)
nn &lt;- nrow(bmt)
entrytime &lt;- rbinom(nn,1,0.5)*(bmt$time*runif(nn))
bmt$entrytime &lt;- entrytime
times &lt;- seq(5,70,by=1)

### adds weights to uncensored observations
bmtw &lt;- prep.comp.risk(bmt,times=times,time="time",
		       entrytime="entrytime",cause="cause")

#########################################
### nonparametric estimates
#########################################
## {{{ 
### nonparametric estimates, right-censoring only 
out &lt;- comp.risk(Event(time,cause)~+1,data=bmt,
		 cause=1,model="rcif2",
		 times=c(5,30,70),n.sim=0)
out$cum
### same as 
###out &lt;- prodlim(Hist(time,cause)~+1,data=bmt)
###summary(out,cause="1",times=c(5,30,70))

### with truncation 
out &lt;- comp.risk(Event(time,cause)~+1,data=bmtw,cause=1,
  model="rcif2",
  cens.weight=bmtw$cw,weights=bmtw$weights,times=c(5,30,70),
  n.sim=0)
out$cum
### same as
###out &lt;- prodlim(Hist(entry=entrytime,time,cause)~+1,data=bmt)
###summary(out,cause="1",times=c(5,30,70))
## }}} 

#########################################
### Regression 
#########################################
## {{{ 
### with truncation correction
out &lt;- comp.risk(Event(time,cause)~const(tcell)+const(platelet),data=bmtw,
 cause=1,cens.weight=bmtw$cw,
 weights=bmtw$weights,times=times,n.sim=0)
summary(out)

### with only righ-censoring, standard call
outn &lt;- comp.risk(Event(time,cause)~const(tcell)+const(platelet),data=bmt,
	  cause=1,times=times,n.sim=0)
summary(outn)
## }}} 


</code></pre>

<hr>
<h2 id='print.aalen'>Prints call</h2><span id='topic+print.aalen'></span><span id='topic+print.cox.aalen'></span><span id='topic+print.comprisk'></span><span id='topic+print.prop.excess'></span><span id='topic+print.dynreg'></span><span id='topic+print.timecox'></span><span id='topic+print.cum.residuals'></span>

<h3>Description</h3>

<p>Prints call for object. Lists nonparametric and parametric terms of model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'aalen'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.aalen_+3A_x">x</code></td>
<td>
<p>an aalen object</p>
</td></tr>
<tr><td><code id="print.aalen_+3A_...">...</code></td>
<td>
<p>unused arguments - for S3 compatibility</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Thomas Scheike
</p>

<hr>
<h2 id='prop'>Identifies the multiplicative terms in Cox-Aalen model and proportional
excess risk model</h2><span id='topic+prop'></span>

<h3>Description</h3>

<p>Specifies which of the regressors that belong to the multiplicative part of
the Cox-Aalen model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prop(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prop_+3A_x">x</code></td>
<td>
<p>variable</p>
</td></tr>
</table>


<h3>Details</h3>

<p style="text-align: center;"><code class="reqn"> \lambda_{i}(t) = Y_i(t) ( X_{i}^T(t) \alpha(t) ) \exp(Z_{i}^T(t)
\beta ) </code>
</p>
<p> for this model prop specified the covariates to be included in
<code class="reqn">Z_{i}(t)</code>
</p>


<h3>Author(s)</h3>

<p>Thomas Scheike
</p>

<hr>
<h2 id='prop.excess'>Fits Proportional excess hazards model</h2><span id='topic+prop.excess'></span>

<h3>Description</h3>

<p>Fits proportional excess hazards model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prop.excess(
  formula = formula(data),
  data = parent.frame(),
  excess = 1,
  tol = 1e-04,
  max.time = NULL,
  n.sim = 1000,
  alpha = 1,
  frac = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prop.excess_+3A_formula">formula</code></td>
<td>
<p>a formula object, with the response on the left of a &lsquo;~&rsquo;
operator, and the terms on the right.  The response must be a survival
object as returned by the &lsquo;Surv&rsquo; function.</p>
</td></tr>
<tr><td><code id="prop.excess_+3A_data">data</code></td>
<td>
<p>a data.frame with the variables.</p>
</td></tr>
<tr><td><code id="prop.excess_+3A_excess">excess</code></td>
<td>
<p>specifies for which of the subjects the excess term is
present. Default is that the term is present for all subjects.</p>
</td></tr>
<tr><td><code id="prop.excess_+3A_tol">tol</code></td>
<td>
<p>tolerance for numerical procedure.</p>
</td></tr>
<tr><td><code id="prop.excess_+3A_max.time">max.time</code></td>
<td>
<p>stopping considered time-period if different from 0.
Estimates thus computed from [0,max.time] if max.time&gt;0. Default is max of
data.</p>
</td></tr>
<tr><td><code id="prop.excess_+3A_n.sim">n.sim</code></td>
<td>
<p>number of simulations in re-sampling.</p>
</td></tr>
<tr><td><code id="prop.excess_+3A_alpha">alpha</code></td>
<td>
<p>tuning paramter in Newton-Raphson procedure. Value smaller than
one may give more stable convergence.</p>
</td></tr>
<tr><td><code id="prop.excess_+3A_frac">frac</code></td>
<td>
<p>number between 0 and 1.  Is used in supremum test where observed
jump times t1, ..., tk is replaced by t1, ..., tl with l=round(frac*k).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The models are written using the survival modelling given in the survival
package.
</p>
<p>The program assumes that there are no ties, and if such are present random
noise is added to break the ties.
</p>


<h3>Value</h3>

<p>Returns an object of type &quot;prop.excess&quot;. With the following
arguments: </p>
<table>
<tr><td><code>cum</code></td>
<td>
<p>estimated cumulative regression functions. First
column contains the jump times, then follows the estimated components of
additive part of model and finally the excess cumulative baseline. </p>
</td></tr>
<tr><td><code>var.cum</code></td>
<td>
<p>robust pointwise variance estimates for estimated
cumulatives. </p>
</td></tr> <tr><td><code>gamma</code></td>
<td>
<p>estimate of parametric components of model. </p>
</td></tr>
<tr><td><code>var.gamma</code></td>
<td>
<p>robust variance estimate for gamma. </p>
</td></tr> <tr><td><code>pval</code></td>
<td>
<p>p-value
of Kolmogorov-Smirnov test (variance weighted) for excess baseline and Aalen
terms, H: B(t)=0. </p>
</td></tr> <tr><td><code>pval.HW</code></td>
<td>
<p>p-value of supremum test (corresponding
to Hall-Wellner band) for excess baseline and Aalen terms, H: B(t)=0.
Reported in summary. </p>
</td></tr> <tr><td><code>pval.CM</code></td>
<td>
<p>p-value of Cramer von Mises test for
excess baseline and Aalen terms, H: B(t)=0. </p>
</td></tr> <tr><td><code>quant</code></td>
<td>
<p>95 percent
quantile in distribution of resampled Kolmogorov-Smirnov test statistics for
excess baseline and Aalen terms. Used to construct 95 percent simulation
band.  </p>
</td></tr> <tr><td><code>quant95HW</code></td>
<td>
<p>95 percent quantile in distribution of resampled
supremum test statistics corresponding to Hall-Wellner band for excess
baseline and Aalen terms. Used to construct 95 percent Hall-Wellner band.  </p>
</td></tr>
<tr><td><code>simScoreProp</code></td>
<td>
<p>observed scoreprocess and 50 resampled scoreprocesses
(under model). List with 51 elements. </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Torben Martinussen
</p>


<h3>References</h3>

<p>Martinussen and Scheike, Dynamic Regression Models for Survival
Data, Springer Verlag (2006).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
###working on memory leak issue, 3/3-2015
###data(melanoma)
###lt&lt;-log(melanoma$thick)          # log-thickness 
###excess&lt;-(melanoma$thick&gt;=210)    # excess risk for thick tumors
###
#### Fits Proportional Excess hazards model 
###fit&lt;-prop.excess(Surv(days/365,status==1)~sex+ulc+cox(sex)+
###                 cox(ulc)+cox(lt),melanoma,excess=excess,n.sim=100)
###summary(fit)
###par(mfrow=c(2,3))
###plot(fit)

</code></pre>

<hr>
<h2 id='prop.odds'>Fit Semiparametric Proportional 0dds Model</h2><span id='topic+prop.odds'></span>

<h3>Description</h3>

<p>Fits a semiparametric proportional odds model: </p>
<p style="text-align: center;"><code class="reqn"> logit(1-S_Z(t)) =
log(G(t)) + \beta^T Z </code>
</p>
<p> where G(t) is increasing but otherwise unspecified.
Model is fitted by maximising the modified partial likelihood.  A
goodness-of-fit test by considering the score functions is also computed by
resampling methods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prop.odds(
  formula,
  data = parent.frame(),
  beta = NULL,
  Nit = 20,
  detail = 0,
  start.time = 0,
  max.time = NULL,
  id = NULL,
  n.sim = 500,
  weighted.test = 0,
  profile = 1,
  sym = 0,
  baselinevar = 1,
  clusters = NULL,
  max.clust = 1000,
  weights = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prop.odds_+3A_formula">formula</code></td>
<td>
<p>a formula object, with the response on the left of a '~'
operator, and the terms on the right.  The response must be a Event object
as returned by the &lsquo;Event&rsquo; function.</p>
</td></tr>
<tr><td><code id="prop.odds_+3A_data">data</code></td>
<td>
<p>a data.frame with the variables.</p>
</td></tr>
<tr><td><code id="prop.odds_+3A_beta">beta</code></td>
<td>
<p>starting value for relative risk estimates</p>
</td></tr>
<tr><td><code id="prop.odds_+3A_nit">Nit</code></td>
<td>
<p>number of iterations for Newton-Raphson algorithm.</p>
</td></tr>
<tr><td><code id="prop.odds_+3A_detail">detail</code></td>
<td>
<p>if 0 no details is printed during iterations, if 1 details are
given.</p>
</td></tr>
<tr><td><code id="prop.odds_+3A_start.time">start.time</code></td>
<td>
<p>start of observation period where estimates are computed.</p>
</td></tr>
<tr><td><code id="prop.odds_+3A_max.time">max.time</code></td>
<td>
<p>end of observation period where estimates are computed.
Estimates thus computed from [start.time, max.time].  This is very useful to
obtain stable estimates, especially for the baseline. Default is max of
data.</p>
</td></tr>
<tr><td><code id="prop.odds_+3A_id">id</code></td>
<td>
<p>For timevarying covariates the variable must associate each record
with the id of a subject.</p>
</td></tr>
<tr><td><code id="prop.odds_+3A_n.sim">n.sim</code></td>
<td>
<p>number of simulations in resampling.</p>
</td></tr>
<tr><td><code id="prop.odds_+3A_weighted.test">weighted.test</code></td>
<td>
<p>to compute a variance weighted version of the
test-processes used for testing time-varying effects.</p>
</td></tr>
<tr><td><code id="prop.odds_+3A_profile">profile</code></td>
<td>
<p>if profile is 1 then modified partial likelihood is used,
profile=0 fits by simple estimating equation. The modified partial
likelihood is recommended.</p>
</td></tr>
<tr><td><code id="prop.odds_+3A_sym">sym</code></td>
<td>
<p>to use symmetrized second derivative in the case of the
estimating equation approach (profile=0).  This may improve the numerical
performance.</p>
</td></tr>
<tr><td><code id="prop.odds_+3A_baselinevar">baselinevar</code></td>
<td>
<p>set to 0 to omit calculations of baseline variance.</p>
</td></tr>
<tr><td><code id="prop.odds_+3A_clusters">clusters</code></td>
<td>
<p>to compute cluster based standard errors.</p>
</td></tr>
<tr><td><code id="prop.odds_+3A_max.clust">max.clust</code></td>
<td>
<p>number of maximum clusters to be used, to save time in iid
decomposition.</p>
</td></tr>
<tr><td><code id="prop.odds_+3A_weights">weights</code></td>
<td>
<p>weights for score equations.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The modelling formula uses the standard survival modelling given in the
<b>survival</b> package.
</p>
<p>For large data sets use the divide.conquer.timereg of the mets package to
run the model on splits of the data, or the alternative estimator by the
cox.aalen function.
</p>
<p>The data for a subject is presented as multiple rows or &quot;observations&quot;, each
of which applies to an interval of observation (start, stop]. The program
essentially assumes no ties, and if such are present a little random noise
is added to break the ties.
</p>


<h3>Value</h3>

<p>returns an object of type 'cox.aalen'. With the following arguments:
</p>
<table>
<tr><td><code>cum</code></td>
<td>
<p>cumulative timevarying regression coefficient estimates are
computed within the estimation interval.</p>
</td></tr> <tr><td><code>var.cum</code></td>
<td>
<p>the martingale
based pointwise variance estimates.  </p>
</td></tr> <tr><td><code>robvar.cum</code></td>
<td>
<p>robust pointwise
variances estimates.  </p>
</td></tr> <tr><td><code>gamma</code></td>
<td>
<p>estimate of proportional odds
parameters of model.</p>
</td></tr> <tr><td><code>var.gamma</code></td>
<td>
<p>variance for gamma.  </p>
</td></tr>
<tr><td><code>robvar.gamma</code></td>
<td>
<p>robust variance for gamma.  </p>
</td></tr> <tr><td><code>residuals</code></td>
<td>
<p>list with
residuals. Estimated martingale increments (dM) and corresponding time
vector (time).</p>
</td></tr> <tr><td><code>obs.testBeq0</code></td>
<td>
<p>observed absolute value of supremum of
cumulative components scaled with the variance.</p>
</td></tr>
<tr><td><code>pval.testBeq0</code></td>
<td>
<p>p-value for covariate effects based on supremum test.</p>
</td></tr>
<tr><td><code>sim.testBeq0</code></td>
<td>
<p>resampled supremum values.</p>
</td></tr> <tr><td><code>obs.testBeqC</code></td>
<td>
<p>observed
absolute value of supremum of difference between observed cumulative process
and estimate under null of constant effect.</p>
</td></tr> <tr><td><code>pval.testBeqC</code></td>
<td>
<p>p-value
based on resampling.</p>
</td></tr> <tr><td><code>sim.testBeqC</code></td>
<td>
<p>resampled supremum values.</p>
</td></tr>
<tr><td><code>obs.testBeqC.is</code></td>
<td>
<p>observed integrated squared differences between
observed cumulative and estimate under null of constant effect.</p>
</td></tr>
<tr><td><code>pval.testBeqC.is</code></td>
<td>
<p>p-value based on resampling.</p>
</td></tr>
<tr><td><code>sim.testBeqC.is</code></td>
<td>
<p>resampled supremum values.</p>
</td></tr>
<tr><td><code>conf.band</code></td>
<td>
<p>resampling based constant to construct robust 95% uniform
confidence bands. </p>
</td></tr> <tr><td><code>test.procBeqC</code></td>
<td>
<p>observed test-process of difference
between observed cumulative process and estimate under null of constant
effect over time.</p>
</td></tr> <tr><td><code>loglike</code></td>
<td>
<p>modified partial likelihood, pseudo
profile likelihood for regression parameters.</p>
</td></tr> <tr><td><code>D2linv</code></td>
<td>
<p>inverse of the
derivative of the score function.</p>
</td></tr> <tr><td><code>score</code></td>
<td>
<p>value of score for final
estimates.</p>
</td></tr> <tr><td><code>test.procProp</code></td>
<td>
<p>observed score process for proportional
odds regression effects.</p>
</td></tr> <tr><td><code>pval.Prop</code></td>
<td>
<p>p-value based on resampling.</p>
</td></tr>
<tr><td><code>sim.supProp</code></td>
<td>
<p>re-sampled supremum values.</p>
</td></tr>
<tr><td><code>sim.test.procProp</code></td>
<td>
<p>list of 50 random realizations of test-processes
for constant proportional odds under the model based on resampling.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Thomas Scheike
</p>


<h3>References</h3>

<p>Martinussen and Scheike, Dynamic Regression Models for Survival
Data, Springer (2006).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(sTRACE)
# Fits Proportional odds model 
out&lt;-prop.odds(Event(time,status==9)~age+diabetes+chf+vf+sex,
sTRACE,max.time=7,n.sim=100)
summary(out)

par(mfrow=c(2,3))
plot(out,sim.ci=2)
plot(out,score=1) 

pout &lt;- predict(out,Z=c(70,0,0,0,0))
plot(pout)

### alternative estimator for large data sets 
form &lt;- Surv(time,status==9)~age+diabetes+chf+vf+sex
pform &lt;- timereg.formula(form)
out2&lt;-cox.aalen(pform,data=sTRACE,max.time=7,
	propodds=1,n.sim=0,robust=0,detail=0,Nit=40)
summary(out2)

</code></pre>

<hr>
<h2 id='prop.odds.subdist'>Fit Semiparametric Proportional 0dds Model for the competing risks
subdistribution</h2><span id='topic+prop.odds.subdist'></span>

<h3>Description</h3>

<p>Fits a semiparametric proportional odds model: </p>
<p style="text-align: center;"><code class="reqn"> logit(F_1(t;X,Z)) =
log( A(t)) + \beta^T Z </code>
</p>
<p> where A(t) is increasing but otherwise unspecified.
Model is fitted by maximising the modified partial likelihood.  A
goodness-of-fit test by considering the score functions is also computed by
resampling methods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prop.odds.subdist(
  formula,
  data = parent.frame(),
  cause = 1,
  beta = NULL,
  Nit = 10,
  detail = 0,
  start.time = 0,
  max.time = NULL,
  id = NULL,
  n.sim = 500,
  weighted.test = 0,
  profile = 1,
  sym = 0,
  cens.model = "KM",
  cens.formula = NULL,
  clusters = NULL,
  max.clust = 1000,
  baselinevar = 1,
  weights = NULL,
  cens.weights = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prop.odds.subdist_+3A_formula">formula</code></td>
<td>
<p>a formula object, with the response on the left of a '~'
operator, and the terms on the right.  The response must be an object as
returned by the &lsquo;Event&rsquo; function.</p>
</td></tr>
<tr><td><code id="prop.odds.subdist_+3A_data">data</code></td>
<td>
<p>a data.frame with the variables.</p>
</td></tr>
<tr><td><code id="prop.odds.subdist_+3A_cause">cause</code></td>
<td>
<p>cause indicator for competing risks.</p>
</td></tr>
<tr><td><code id="prop.odds.subdist_+3A_beta">beta</code></td>
<td>
<p>starting value for relative risk estimates</p>
</td></tr>
<tr><td><code id="prop.odds.subdist_+3A_nit">Nit</code></td>
<td>
<p>number of iterations for Newton-Raphson algorithm.</p>
</td></tr>
<tr><td><code id="prop.odds.subdist_+3A_detail">detail</code></td>
<td>
<p>if 0 no details is printed during iterations, if 1 details are
given.</p>
</td></tr>
<tr><td><code id="prop.odds.subdist_+3A_start.time">start.time</code></td>
<td>
<p>start of observation period where estimates are computed.</p>
</td></tr>
<tr><td><code id="prop.odds.subdist_+3A_max.time">max.time</code></td>
<td>
<p>end of observation period where estimates are computed.
Estimates thus computed from [start.time, max.time].  This is very useful to
obtain stable estimates, especially for the baseline. Default is max of
data.</p>
</td></tr>
<tr><td><code id="prop.odds.subdist_+3A_id">id</code></td>
<td>
<p>For timevarying covariates the variable must associate each record
with the id of a subject.</p>
</td></tr>
<tr><td><code id="prop.odds.subdist_+3A_n.sim">n.sim</code></td>
<td>
<p>number of simulations in resampling.</p>
</td></tr>
<tr><td><code id="prop.odds.subdist_+3A_weighted.test">weighted.test</code></td>
<td>
<p>to compute a variance weighted version of the
test-processes used for testing time-varying effects.</p>
</td></tr>
<tr><td><code id="prop.odds.subdist_+3A_profile">profile</code></td>
<td>
<p>use profile version of score equations.</p>
</td></tr>
<tr><td><code id="prop.odds.subdist_+3A_sym">sym</code></td>
<td>
<p>to use symmetrized second derivative in the case of the
estimating equation approach (profile=0).  This may improve the numerical
performance.</p>
</td></tr>
<tr><td><code id="prop.odds.subdist_+3A_cens.model">cens.model</code></td>
<td>
<p>specifies censoring model. So far only Kaplan-Meier &quot;KM&quot;.</p>
</td></tr>
<tr><td><code id="prop.odds.subdist_+3A_cens.formula">cens.formula</code></td>
<td>
<p>possible formula for censoring distribution covariates.
Default all !</p>
</td></tr>
<tr><td><code id="prop.odds.subdist_+3A_clusters">clusters</code></td>
<td>
<p>to compute cluster based standard errors.</p>
</td></tr>
<tr><td><code id="prop.odds.subdist_+3A_max.clust">max.clust</code></td>
<td>
<p>number of maximum clusters to be used, to save time in iid
decomposition.</p>
</td></tr>
<tr><td><code id="prop.odds.subdist_+3A_baselinevar">baselinevar</code></td>
<td>
<p>set to 0 to save time on computations.</p>
</td></tr>
<tr><td><code id="prop.odds.subdist_+3A_weights">weights</code></td>
<td>
<p>additional weights.</p>
</td></tr>
<tr><td><code id="prop.odds.subdist_+3A_cens.weights">cens.weights</code></td>
<td>
<p>specify censoring weights related to the observations.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An alternative way of writing the model : </p>
<p style="text-align: center;"><code class="reqn"> F_1(t;X,Z) = \frac{ \exp(
\beta^T Z )}{ (A(t)) + \exp( \beta^T Z) } </code>
</p>
<p> such that <code class="reqn">\beta</code> is the
log-odds-ratio of cause 1 before time t, and <code class="reqn">A(t)</code> is the odds-ratio.
</p>
<p>The modelling formula uses the standard survival modelling given in the
<b>survival</b> package.
</p>
<p>The data for a subject is presented as multiple rows or &quot;observations&quot;, each
of which applies to an interval of observation (start, stop]. The program
essentially assumes no ties, and if such are present a little random noise
is added to break the ties.
</p>


<h3>Value</h3>

<p>returns an object of type 'cox.aalen'. With the following arguments:
</p>
<table>
<tr><td><code>cum</code></td>
<td>
<p>cumulative timevarying regression coefficient estimates are
computed within the estimation interval.</p>
</td></tr> <tr><td><code>var.cum</code></td>
<td>
<p>the martingale
based pointwise variance estimates.  </p>
</td></tr> <tr><td><code>robvar.cum</code></td>
<td>
<p>robust pointwise
variances estimates.  </p>
</td></tr> <tr><td><code>gamma</code></td>
<td>
<p>estimate of proportional odds
parameters of model.</p>
</td></tr> <tr><td><code>var.gamma</code></td>
<td>
<p>variance for gamma.  </p>
</td></tr>
<tr><td><code>robvar.gamma</code></td>
<td>
<p>robust variance for gamma.  </p>
</td></tr> <tr><td><code>residuals</code></td>
<td>
<p>list with
residuals. Estimated martingale increments (dM) and corresponding time
vector (time).</p>
</td></tr> <tr><td><code>obs.testBeq0</code></td>
<td>
<p>observed absolute value of supremum of
cumulative components scaled with the variance.</p>
</td></tr>
<tr><td><code>pval.testBeq0</code></td>
<td>
<p>p-value for covariate effects based on supremum test.</p>
</td></tr>
<tr><td><code>sim.testBeq0</code></td>
<td>
<p>resampled supremum values.</p>
</td></tr> <tr><td><code>obs.testBeqC</code></td>
<td>
<p>observed
absolute value of supremum of difference between observed cumulative process
and estimate under null of constant effect.</p>
</td></tr> <tr><td><code>pval.testBeqC</code></td>
<td>
<p>p-value
based on resampling.</p>
</td></tr> <tr><td><code>sim.testBeqC</code></td>
<td>
<p>resampled supremum values.</p>
</td></tr>
<tr><td><code>obs.testBeqC.is</code></td>
<td>
<p>observed integrated squared differences between
observed cumulative and estimate under null of constant effect.</p>
</td></tr>
<tr><td><code>pval.testBeqC.is</code></td>
<td>
<p>p-value based on resampling.</p>
</td></tr>
<tr><td><code>sim.testBeqC.is</code></td>
<td>
<p>resampled supremum values.</p>
</td></tr>
<tr><td><code>conf.band</code></td>
<td>
<p>resampling based constant to construct robust 95% uniform
confidence bands. </p>
</td></tr> <tr><td><code>test.procBeqC</code></td>
<td>
<p>observed test-process of difference
between observed cumulative process and estimate under null of constant
effect over time.</p>
</td></tr> <tr><td><code>loglike</code></td>
<td>
<p>modified partial likelihood, pseudo
profile likelihood for regression parameters.</p>
</td></tr> <tr><td><code>D2linv</code></td>
<td>
<p>inverse of the
derivative of the score function.</p>
</td></tr> <tr><td><code>score</code></td>
<td>
<p>value of score for final
estimates.</p>
</td></tr> <tr><td><code>test.procProp</code></td>
<td>
<p>observed score process for proportional
odds regression effects.</p>
</td></tr> <tr><td><code>pval.Prop</code></td>
<td>
<p>p-value based on resampling.</p>
</td></tr>
<tr><td><code>sim.supProp</code></td>
<td>
<p>re-sampled supremum values.</p>
</td></tr>
<tr><td><code>sim.test.procProp</code></td>
<td>
<p>list of 50 random realizations of test-processes
for constant proportional odds under the model based on resampling.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Thomas Scheike
</p>


<h3>References</h3>

<p>Eriksson, Li, Zhang and Scheike (2014), The proportional odds
cumulative incidence model for competing risks, Biometrics, to appear.
</p>
<p>Scheike, A flexible semiparametric transformation model for survival data,
Lifetime Data Anal. (2007).
</p>
<p>Martinussen and Scheike, Dynamic Regression Models for Survival Data,
Springer (2006).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(timereg)
data(bmt)
# Fits Proportional odds model 
out &lt;- prop.odds.subdist(Event(time,cause)~platelet+age+tcell,data=bmt,
 cause=1,cens.model="KM",detail=0,n.sim=1000)
summary(out) 
par(mfrow=c(2,3))
plot(out,sim.ci=2); 
plot(out,score=1) 

# simple predict function without confidence calculations 
pout &lt;- predictpropodds(out,X=model.matrix(~platelet+age+tcell,data=bmt)[,-1])
matplot(pout$time,pout$pred,type="l")

# predict function with confidence intervals
pout2 &lt;- predict(out,Z=c(1,0,1))
plot(pout2,col=2)
pout1 &lt;- predictpropodds(out,X=c(1,0,1))
lines(pout1$time,pout1$pred,type="l")

# Fits Proportional odds model with stratified baseline, does not work yet!
###out &lt;- Gprop.odds.subdist(Surv(time,cause==1)~-1+factor(platelet)+
###prop(age)+prop(tcell),data=bmt,cause=bmt$cause,
###cens.code=0,cens.model="KM",causeS=1,detail=0,n.sim=1000)
###summary(out) 
###par(mfrow=c(2,3))
###plot(out,sim.ci=2); 
###plot(out,score=1) 

</code></pre>

<hr>
<h2 id='pval'>For internal use</h2><span id='topic+summary.restricted.residual.mean'></span><span id='topic+plot.restricted.residual.mean'></span><span id='topic+summary.resmean'></span><span id='topic+plot.resmean'></span><span id='topic+print.resmean'></span><span id='topic+coef.resmean'></span><span id='topic+coefcox'></span><span id='topic+kmplot'></span><span id='topic+pval'></span><span id='topic+additive.compSs'></span><span id='topic+CsmoothB'></span><span id='topic+Csmooth2B'></span><span id='topic+pval'></span><span id='topic+kernel'></span><span id='topic+percen'></span><span id='topic+localTimeReg'></span><span id='topic+nameestimate'></span><span id='topic+namematrix'></span><span id='topic+aalenBase'></span><span id='topic+aalenBaseC'></span><span id='topic+aalen.des'></span><span id='topic+aalen.des2'></span><span id='topic+cox.aalenBase'></span><span id='topic+read-design'></span><span id='topic+is.diag'></span><span id='topic+semiaalen'></span><span id='topic+semiregBase'></span><span id='topic+check.missing'></span><span id='topic+sindex.prodlim'></span><span id='topic+read.design'></span><span id='topic+read.surv'></span><span id='topic+risk.index'></span><span id='topic+faster.reshape'></span><span id='topic+rm.missing'></span><span id='topic+plot.two.stage'></span><span id='topic+summary.two.stage'></span><span id='topic+predict.two.stage'></span><span id='topic+predictpropodds'></span><span id='topic+plot.cums'></span><span id='topic+plot.comprisk'></span><span id='topic+plot.predict.comprisk'></span><span id='topic+plot.predict.timereg'></span><span id='topic+pava'></span><span id='topic+plotScore'></span><span id='topic+summary.comprisk'></span><span id='topic+pred.cum'></span><span id='topic+slaaop'></span><span id='topic+pred.des'></span><span id='topic+Cpred'></span><span id='topic+plot.cox.aalen2'></span><span id='topic+plot.predict'></span><span id='topic+coef.aalen'></span><span id='topic+cox.marg'></span><span id='topic+summary.cox.marg'></span><span id='topic+coef.cox.marg'></span><span id='topic+print.cox.marg'></span><span id='topic+comprisk.ipw'></span><span id='topic+coef.comprisk.ipw'></span><span id='topic+print.comprisk.ipw'></span><span id='topic+prop.odds.subdist.ipw'></span><span id='topic+summary.comprisk.ipw'></span><span id='topic+coef.cox.aalen'></span><span id='topic+coef.comprisk'></span><span id='topic+coef.two.stage'></span><span id='topic+cluster.index.timereg'></span><span id='topic+coefBase'></span><span id='topic+des.aalen'></span><span id='topic+timetest'></span><span id='topic+print.pe.sasieni'></span><span id='topic+pred.stratKM'></span><span id='topic+prep.glm.comprisk'></span><span id='topic+print.predict.timereg'></span><span id='topic+print.two.stage'></span><span id='topic+residualsTimereg'></span><span id='topic+summary.pe.sasieni'></span><span id='topic+summary.predict.timereg'></span><span id='topic+coef.dynreg'></span><span id='topic+coef.timecox'></span><span id='topic+dynregBase'></span><span id='topic+prop.excessBase'></span><span id='topic+prop.odds.gam'></span><span id='topic+plotConfregion'></span><span id='topic+semicox'></span><span id='topic+timecoxBase'></span><span id='topic+timereg.formula'></span><span id='topic+names2formula'></span><span id='topic+twin.clustertrunc'></span><span id='topic+vcov.aalen'></span><span id='topic+vcov.cox.aalen'></span><span id='topic+vcov.two.stage'></span><span id='topic+vcov.comp.risk'></span>

<h3>Description</h3>

<p>for internal use</p>


<h3>Author(s)</h3>

<p>Thomas Scheike</p>

<hr>
<h2 id='qcut'>Cut a variable</h2><span id='topic+qcut'></span>

<h3>Description</h3>

<p>Calls the cut function to cut variables on data frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qcut(x, cuts = 4, breaks = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="qcut_+3A_x">x</code></td>
<td>
<p>variable to cut</p>
</td></tr>
<tr><td><code id="qcut_+3A_cuts">cuts</code></td>
<td>
<p>number of groups, 4 gives quartiles</p>
</td></tr>
<tr><td><code id="qcut_+3A_breaks">breaks</code></td>
<td>
<p>can also give breaks</p>
</td></tr>
<tr><td><code id="qcut_+3A_...">...</code></td>
<td>
<p>other argument for cut function of R</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Thomas Scheike
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(sTRACE)
gx &lt;- qcut(sTRACE$age)
table(gx)

</code></pre>

<hr>
<h2 id='recurrent.marginal.coxmean'>Estimates marginal mean of recurrent events  based on two cox models</h2><span id='topic+recurrent.marginal.coxmean'></span>

<h3>Description</h3>

<p>Fitting two Cox models for death and recurent events these are
combined to prducte the estimator 
</p>
<p style="text-align: center;"><code class="reqn"> \int_0^t  S(u|x=0) dR(u|x=0) </code>
</p>
<p> the mean number of recurrent events, here
</p>
<p style="text-align: center;"><code class="reqn"> S(u|x=0) </code>
</p>
<p>  is the probability of survival, and 
</p>
<p style="text-align: center;"><code class="reqn"> dR(u|x=0) </code>
</p>
<p>  is the probability of an event among survivors. 
For now the estimator is based on the two-baselines so </p>
<p style="text-align: center;"><code class="reqn">x=0</code>
</p>
<p>, but covariates
can be rescaled to look at different x's and extensions possible.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>recurrent.marginal.coxmean(recurrent, death)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="recurrent.marginal.coxmean_+3A_recurrent">recurrent</code></td>
<td>
<p>aalen model for recurrent events</p>
</td></tr>
<tr><td><code id="recurrent.marginal.coxmean_+3A_death">death</code></td>
<td>
<p>cox.aalen (cox) model for death events</p>
</td></tr>
</table>


<h3>Details</h3>

<p>IID versions along the lines of Ghosh &amp; Lin (2000) variance. See also mets package for 
quick version of this for large data. 
IID versions used for Ghosh &amp; Lin (2000) variance. See also mets package for 
quick version of this for large data mets:::recurrent.marginal, these two 
version should give the same when there are now ties.
</p>


<h3>Author(s)</h3>

<p>Thomas Scheike
</p>


<h3>References</h3>

<p>Ghosh and Lin (2002) Nonparametric Analysis of Recurrent events and death, 
Biometrics, 554&ndash;562.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
### do not test because iid slow  and uses data from mets
library(mets)
data(base1cumhaz)
data(base4cumhaz)
data(drcumhaz)
dr &lt;- drcumhaz
base1 &lt;- base1cumhaz
base4 &lt;- base4cumhaz
rr &lt;- simRecurrent(100,base1,death.cumhaz=dr)
rr$x &lt;- rnorm(nrow(rr)) 
rr$strata &lt;- floor((rr$id-0.01)/50)
drename(rr) &lt;- start+stop~entry+time

ar &lt;- cox.aalen(Surv(start,stop,status)~+1+prop(x)+cluster(id),data=rr,
                   resample.iid=1,,max.clust=NULL,max.timepoint.sim=NULL)
ad &lt;- cox.aalen(Surv(start,stop,death)~+1+prop(x)+cluster(id),data=rr,
                   resample.iid=1,,max.clust=NULL,max.timepoint.sim=NULL)
mm &lt;- recurrent.marginal.coxmean(ar,ad)
with(mm,plot(times,mu,type="s"))
with(mm,lines(times,mu+1.96*se.mu,type="s",lty=2))
with(mm,lines(times,mu-1.96*se.mu,type="s",lty=2))

</code></pre>

<hr>
<h2 id='recurrent.marginal.mean'>Estimates marginal mean of recurrent events</h2><span id='topic+recurrent.marginal.mean'></span>

<h3>Description</h3>

<p>Fitting two aalen models for death and recurent events these are
combined to prducte the estimator 
</p>
<p style="text-align: center;"><code class="reqn"> \int_0^t  S(u) dR(u) </code>
</p>
<p> the mean number of recurrent events, here
</p>
<p style="text-align: center;"><code class="reqn"> S(u) </code>
</p>
<p>  is the probability of survival, and 
</p>
<p style="text-align: center;"><code class="reqn"> dR(u) </code>
</p>
<p>  is the probability of an event among survivors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>recurrent.marginal.mean(recurrent, death)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="recurrent.marginal.mean_+3A_recurrent">recurrent</code></td>
<td>
<p>aalen model for recurrent events</p>
</td></tr>
<tr><td><code id="recurrent.marginal.mean_+3A_death">death</code></td>
<td>
<p>aalen model for recurrent events</p>
</td></tr>
</table>


<h3>Details</h3>

<p>IID versions used for Ghosh &amp; Lin (2000) variance. See also mets package for 
quick version of this for large data mets:::recurrent.marginal, these two 
version should give the same when there are no ties.
</p>


<h3>Author(s)</h3>

<p>Thomas Scheike
</p>


<h3>References</h3>

<p>Ghosh and Lin (2002) Nonparametric Analysis of Recurrent events and death, 
Biometrics, 554&ndash;562.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
### get some data using mets simulaitons 
library(mets)
data(base1cumhaz)
data(base4cumhaz)
data(drcumhaz)
dr &lt;- drcumhaz
base1 &lt;- base1cumhaz
base4 &lt;- base4cumhaz
rr &lt;- simRecurrent(100,base1,death.cumhaz=dr)
rr$x &lt;- rnorm(nrow(rr)) 
rr$strata &lt;- floor((rr$id-0.01)/50)
drename(rr) &lt;- start+stop~entry+time

ar &lt;- aalen(Surv(start,stop,status)~+1+cluster(id),data=rr,resample.iid=1
                                                     ,max.clust=NULL)
ad &lt;- aalen(Surv(start,stop,death)~+1+cluster(id),data=rr,resample.iid=1,
                                                     ,max.clust=NULL)
mm &lt;- recurrent.marginal.mean(ar,ad)
with(mm,plot(times,mu,type="s"))
with(mm,lines(times,mu+1.96*se.mu,type="s",lty=2))
with(mm,lines(times,mu-1.96*se.mu,type="s",lty=2))

</code></pre>

<hr>
<h2 id='res.mean'>Residual mean life (restricted)</h2><span id='topic+res.mean'></span>

<h3>Description</h3>

<p>Fits a semiparametric model for the residual life (estimator=1): </p>
<p style="text-align: center;"><code class="reqn"> E(
\min(Y,\tau) -t | Y&gt;=t) = h_1( g(t,x,z) ) </code>
</p>
<p> or cause specific years lost of
Andersen (2012) (estimator=3) </p>
<p style="text-align: center;"><code class="reqn"> E( \tau- \min(Y_j,\tau) | Y&gt;=0) =
\int_0^t (1-F_j(s)) ds = h_2( g(t,x,z) ) </code>
</p>
<p> where <code class="reqn">Y_j = \sum_j Y
I(\epsilon=j) + \infty * I(\epsilon=0)</code> or (estimator=2) </p>
<p style="text-align: center;"><code class="reqn"> E( \tau-
\min(Y_j,\tau) | Y&lt;\tau, \epsilon=j) = h_3( g(t,x,z) ) = h_2(g(t,x,z))
F_j(\tau,x,z) </code>
</p>
<p> where <code class="reqn">F_j(s,x,z) = P(Y&lt;\tau, \epsilon=j | x,z )</code> for a
known link-function <code class="reqn">h()</code> and known prediction-function <code class="reqn">g(t,x,z)</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>res.mean(
  formula,
  data = parent.frame(),
  cause = 1,
  restricted = NULL,
  times = NULL,
  Nit = 50,
  clusters = NULL,
  gamma = 0,
  n.sim = 0,
  weighted = 0,
  model = "additive",
  detail = 0,
  interval = 0.01,
  resample.iid = 1,
  cens.model = "KM",
  cens.formula = NULL,
  time.pow = NULL,
  time.pow.test = NULL,
  silent = 1,
  conv = 1e-06,
  estimator = 1,
  cens.weights = NULL,
  conservative = 1,
  weights = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="res.mean_+3A_formula">formula</code></td>
<td>
<p>a formula object, with the response on the left of a '~'
operator, and the terms on the right. The response must be a survival object
as returned by the &lsquo;Event&rsquo; function. The status indicator is not important
here. Time-invariant regressors are specified by the wrapper const(), and
cluster variables (for computing robust variances) by the wrapper cluster().</p>
</td></tr>
<tr><td><code id="res.mean_+3A_data">data</code></td>
<td>
<p>a data.frame with the variables.</p>
</td></tr>
<tr><td><code id="res.mean_+3A_cause">cause</code></td>
<td>
<p>For competing risk models specificies which cause we consider.</p>
</td></tr>
<tr><td><code id="res.mean_+3A_restricted">restricted</code></td>
<td>
<p>gives a possible restriction times for means.</p>
</td></tr>
<tr><td><code id="res.mean_+3A_times">times</code></td>
<td>
<p>specifies the times at which the estimator is considered.
Defaults to all the times where an event of interest occurs, with the first
10 percent or max 20 jump points removed for numerical stability in
simulations.</p>
</td></tr>
<tr><td><code id="res.mean_+3A_nit">Nit</code></td>
<td>
<p>number of iterations for Newton-Raphson algorithm.</p>
</td></tr>
<tr><td><code id="res.mean_+3A_clusters">clusters</code></td>
<td>
<p>specifies cluster structure, for backwards compability.</p>
</td></tr>
<tr><td><code id="res.mean_+3A_gamma">gamma</code></td>
<td>
<p>starting value for constant effects.</p>
</td></tr>
<tr><td><code id="res.mean_+3A_n.sim">n.sim</code></td>
<td>
<p>number of simulations in resampling.</p>
</td></tr>
<tr><td><code id="res.mean_+3A_weighted">weighted</code></td>
<td>
<p>Not implemented. To compute a variance weighted version of
the test-processes used for testing time-varying effects.</p>
</td></tr>
<tr><td><code id="res.mean_+3A_model">model</code></td>
<td>
<p>&quot;additive&quot;, &quot;prop&quot;ortional.</p>
</td></tr>
<tr><td><code id="res.mean_+3A_detail">detail</code></td>
<td>
<p>if 0 no details are printed during iterations, if 1 details
are given.</p>
</td></tr>
<tr><td><code id="res.mean_+3A_interval">interval</code></td>
<td>
<p>specifies that we only consider timepoints where the
Kaplan-Meier of the censoring distribution is larger than this value.</p>
</td></tr>
<tr><td><code id="res.mean_+3A_resample.iid">resample.iid</code></td>
<td>
<p>to return the iid decomposition, that can be used to
construct confidence bands for predictions</p>
</td></tr>
<tr><td><code id="res.mean_+3A_cens.model">cens.model</code></td>
<td>
<p>specified which model to use for the ICPW, KM is
Kaplan-Meier alternatively it may be &quot;cox&quot; or &quot;aalen&quot; model for further
flexibility.</p>
</td></tr>
<tr><td><code id="res.mean_+3A_cens.formula">cens.formula</code></td>
<td>
<p>specifies the regression terms used for the regression
model for chosen regression model.  When cens.model is specified, the
default is to use the same design as specified for the competing risks
model. &quot;KM&quot;,&quot;cox&quot;,&quot;aalen&quot;,&quot;weights&quot;. &quot;weights&quot; are user specified weights
given is cens.weight argument.</p>
</td></tr>
<tr><td><code id="res.mean_+3A_time.pow">time.pow</code></td>
<td>
<p>specifies that the power at which the time-arguments is
transformed, for each of the arguments of the const() terms, default is 1
for the additive model and 0 for the proportional model.</p>
</td></tr>
<tr><td><code id="res.mean_+3A_time.pow.test">time.pow.test</code></td>
<td>
<p>specifies that the power the time-arguments is
transformed for each of the arguments of the non-const() terms. This is
relevant for testing if a coefficient function is consistent with the
specified form A_l(t)=beta_l t^time.pow.test(l). Default is 1 for the
additive model and 0 for the proportional model.</p>
</td></tr>
<tr><td><code id="res.mean_+3A_silent">silent</code></td>
<td>
<p>if 0 information on convergence problems due to non-invertible
derviates of scores are printed.</p>
</td></tr>
<tr><td><code id="res.mean_+3A_conv">conv</code></td>
<td>
<p>gives convergence criterie in terms of sum of absolute change of
parameters of model</p>
</td></tr>
<tr><td><code id="res.mean_+3A_estimator">estimator</code></td>
<td>
<p>specifies what that is estimated.</p>
</td></tr>
<tr><td><code id="res.mean_+3A_cens.weights">cens.weights</code></td>
<td>
<p>censoring weights for estimating equations.</p>
</td></tr>
<tr><td><code id="res.mean_+3A_conservative">conservative</code></td>
<td>
<p>for slightly conservative standard errors.</p>
</td></tr>
<tr><td><code id="res.mean_+3A_weights">weights</code></td>
<td>
<p>weights for estimating equations.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Uses the IPCW for the score equations based on </p>
<p style="text-align: center;"><code class="reqn"> w(t)
\Delta(\tau)/P(\Delta(\tau)=1| T,\epsilon,X,Z) ( Y(t) - h_1(t,X,Z)) </code>
</p>
<p> and
where <code class="reqn">\Delta(\tau)</code> is the at-risk indicator given data and requires a
IPCW model.
</p>
<p>Since timereg version 1.8.4. the response must be specified with the
<code><a href="#topic+Event">Event</a></code> function instead of the <code><a href="survival.html#topic+Surv">Surv</a></code> function and
the arguments.
</p>


<h3>Value</h3>

<p>returns an object of type 'comprisk'. With the following arguments:
</p>
<table>
<tr><td><code>cum</code></td>
<td>
<p>cumulative timevarying regression coefficient estimates are
computed within the estimation interval.</p>
</td></tr> <tr><td><code>var.cum</code></td>
<td>
<p>pointwise variances
estimates.  </p>
</td></tr> <tr><td><code>gamma</code></td>
<td>
<p>estimate of proportional odds parameters of
model.</p>
</td></tr> <tr><td><code>var.gamma</code></td>
<td>
<p>variance for gamma.  </p>
</td></tr> <tr><td><code>score</code></td>
<td>
<p>sum of absolute
value of scores.</p>
</td></tr> <tr><td><code>gamma2</code></td>
<td>
<p>estimate of constant effects based on the
non-parametric estimate. Used for testing of constant effects.</p>
</td></tr>
<tr><td><code>obs.testBeq0</code></td>
<td>
<p>observed absolute value of supremum of cumulative
components scaled with the variance.</p>
</td></tr> <tr><td><code>pval.testBeq0</code></td>
<td>
<p>p-value for
covariate effects based on supremum test.</p>
</td></tr> <tr><td><code>obs.testBeqC</code></td>
<td>
<p>observed
absolute value of supremum of difference between observed cumulative process
and estimate under null of constant effect.</p>
</td></tr> <tr><td><code>pval.testBeqC</code></td>
<td>
<p>p-value
based on resampling.</p>
</td></tr> <tr><td><code>obs.testBeqC.is</code></td>
<td>
<p>observed integrated squared
differences between observed cumulative and estimate under null of constant
effect.</p>
</td></tr> <tr><td><code>pval.testBeqC.is</code></td>
<td>
<p>p-value based on resampling.</p>
</td></tr>
<tr><td><code>conf.band</code></td>
<td>
<p>resampling based constant to construct 95% uniform
confidence bands.</p>
</td></tr> <tr><td><code>B.iid</code></td>
<td>
<p>list of iid decomposition of non-parametric
effects.</p>
</td></tr> <tr><td><code>gamma.iid</code></td>
<td>
<p>matrix of iid decomposition of parametric
effects.</p>
</td></tr> <tr><td><code>test.procBeqC</code></td>
<td>
<p>observed test process for testing of
time-varying effects</p>
</td></tr> <tr><td><code>sim.test.procBeqC</code></td>
<td>
<p>50 resample processes for for
testing of time-varying effects</p>
</td></tr> <tr><td><code>conv</code></td>
<td>
<p>information on convergence for
time points used for estimation.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Thomas Scheike
</p>


<h3>References</h3>

<p>Andersen (2013), Decomposition of number of years lost according
to causes of death, Statistics in Medicine, 5278-5285.
</p>
<p>Scheike, and Cortese (2015), Regression Modelling of Cause Specific Years Lost,
</p>
<p>Scheike, Cortese and Holmboe (2015), Regression Modelling of Restricted
Residual Mean with Delayed Entry,
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(bmt); 
tau &lt;- 100 

### residual restricted mean life
out&lt;-res.mean(Event(time,cause&gt;=1)~factor(tcell)+factor(platelet),data=bmt,cause=1,
	      times=0,restricted=tau,n.sim=0,model="additive",estimator=1); 
summary(out)

out&lt;-res.mean(Event(time,cause&gt;=1)~factor(tcell)+factor(platelet),data=bmt,cause=1,
	      times=seq(0,90,5),restricted=tau,n.sim=0,model="additive",estimator=1); 
par(mfrow=c(1,3))
plot(out)

### restricted years lost given death
out21&lt;-res.mean(Event(time,cause)~factor(tcell)+factor(platelet),data=bmt,cause=1,
	      times=0,restricted=tau,n.sim=0,model="additive",estimator=2); 
summary(out21)
out22&lt;-res.mean(Event(time,cause)~factor(tcell)+factor(platelet),data=bmt,cause=2,
	      times=0,restricted=tau,n.sim=0,model="additive",estimator=2); 
summary(out22)


### total restricted years lost 
out31&lt;-res.mean(Event(time,cause)~factor(tcell)+factor(platelet),data=bmt,cause=1,
	      times=0,restricted=tau,n.sim=0,model="additive",estimator=3); 
summary(out31)
out32&lt;-res.mean(Event(time,cause)~factor(tcell)+factor(platelet),data=bmt,cause=2,
	      times=0,restricted=tau,n.sim=0,model="additive",estimator=3); 
summary(out32)


### delayed entry 
nn &lt;- nrow(bmt)
entrytime &lt;- rbinom(nn,1,0.5)*(bmt$time*runif(nn))
bmt$entrytime &lt;- entrytime

bmtw &lt;- prep.comp.risk(bmt,times=tau,time="time",entrytime="entrytime",cause="cause")

out&lt;-res.mean(Event(time,cause&gt;=1)~factor(tcell)+factor(platelet),data=bmtw,cause=1,
	      times=0,restricted=tau,n.sim=0,model="additive",estimator=1,
              cens.model="weights",weights=bmtw$cw,cens.weights=1/bmtw$weights); 
summary(out)

</code></pre>

<hr>
<h2 id='restricted.residual.mean'>Estimates restricted residual mean for Cox or Aalen model</h2><span id='topic+restricted.residual.mean'></span>

<h3>Description</h3>

<p>The restricted means are the </p>
<p style="text-align: center;"><code class="reqn"> \int_0^\tau S(t) dt </code>
</p>
<p> the standard
errors are computed using the i.i.d. decompositions from the cox.aalen (that
must be called with the argument &quot;max.timpoint.sim=NULL&quot;) or aalen function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>restricted.residual.mean(out, x = 0, tau = 10, iid = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="restricted.residual.mean_+3A_out">out</code></td>
<td>
<p>an &quot;cox.aalen&quot; with a Cox model or an &quot;aalen&quot; model.</p>
</td></tr>
<tr><td><code id="restricted.residual.mean_+3A_x">x</code></td>
<td>
<p>matrix with covariates for Cox model or additive hazards model
(aalen).</p>
</td></tr>
<tr><td><code id="restricted.residual.mean_+3A_tau">tau</code></td>
<td>
<p>restricted residual mean.</p>
</td></tr>
<tr><td><code id="restricted.residual.mean_+3A_iid">iid</code></td>
<td>
<p>if iid=1 then uses iid decomposition for estimation of standard
errors.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>must have computed iid decomposition of survival models for standard errors
to be computed. Note that competing risks models can be fitted but then the
interpretation is not clear.
</p>


<h3>Value</h3>

<p>Returns an object. With the following arguments:
</p>
<table>
<tr><td><code>mean</code></td>
<td>
<p>restricted mean for different covariates.</p>
</td></tr>
<tr><td><code>var.mean</code></td>
<td>
<p>variance matrix.</p>
</td></tr> <tr><td><code>se</code></td>
<td>
<p>standard errors.</p>
</td></tr>
<tr><td><code>S0tau</code></td>
<td>
<p>estimated survival functions on time-range [0,tau].</p>
</td></tr>
<tr><td><code>timetau</code></td>
<td>
<p>vector of time arguments for S0tau.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Thomas Scheike
</p>


<h3>References</h3>

<p>D. M. Zucker, Restricted mean life with covariates: Modification
and extension of a useful survival analysis method, J. Amer. Statist. Assoc.
vol. 93 pp. 702-709, 1998.
</p>
<p>Martinussen and Scheike, Dynamic Regression Models for Survival Data,
Springer (2006).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

### this example runs slowly and is therefore donttest
data(sTRACE)
sTRACE$cage &lt;- scale(sTRACE$age)
# Fits Cox model  and aalen model 
out&lt;-cox.aalen(Surv(time,status&gt;=1)~prop(sex)+prop(diabetes)+prop(chf)+
	       prop(vf),data=sTRACE,max.timepoint.sim=NULL,resample.iid=1)
outa&lt;-aalen(Surv(time,status&gt;=1)~sex+diabetes+chf+vf,
data=sTRACE,resample.iid=1)

coxrm &lt;- restricted.residual.mean(out,tau=7,
   x=rbind(c(0,0,0,0),c(0,0,1,0),c(0,0,1,1),c(0,0,0,1)),iid=1)
plot(coxrm)
summary(coxrm)

### aalen model not optimal here 
aalenrm &lt;- restricted.residual.mean(outa,tau=7,
   x=rbind(c(1,0,0,0,0),c(1,0,0,1,0),c(1,0,0,1,1),c(1,0,0,0,1)),iid=1)
with(aalenrm,matlines(timetau,S0tau,type="s",ylim=c(0,1)))
legend("bottomleft",c("baseline","+chf","+chf+vf","+vf"),col=1:4,lty=1)
summary(aalenrm)

mm &lt;-cbind(coxrm$mean,coxrm$se,aalenrm$mean,aalenrm$se)
colnames(mm)&lt;-c("cox-res-mean","se","aalen-res-mean","se")
rownames(mm)&lt;-c("baseline","+chf","+chf+vf","+vf")
mm


</code></pre>

<hr>
<h2 id='summary.aalen'>Prints summary statistics</h2><span id='topic+summary.aalen'></span><span id='topic+summary.cox.aalen'></span><span id='topic+summary.prop.excess'></span><span id='topic+summary.timecox'></span><span id='topic+summary.dynreg'></span>

<h3>Description</h3>

<p>Computes p-values for test of significance for nonparametric terms of model,
p-values for test of constant effects based on both supremum and integrated
squared difference.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'aalen'
summary(object, digits = 3, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.aalen_+3A_object">object</code></td>
<td>
<p>an aalen object.</p>
</td></tr>
<tr><td><code id="summary.aalen_+3A_digits">digits</code></td>
<td>
<p>number of digits in printouts.</p>
</td></tr>
<tr><td><code id="summary.aalen_+3A_...">...</code></td>
<td>
<p>unused arguments - for S3 compatibility</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Returns parameter estimates and their standard errors.
</p>


<h3>Author(s)</h3>

<p>Thomas Scheike
</p>


<h3>References</h3>

<p>Martinussen and Scheike,
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
### see help(aalen)

</code></pre>

<hr>
<h2 id='summary.cum.residuals'>Prints summary statistics for goodness-of-fit tests based on cumulative
residuals</h2><span id='topic+summary.cum.residuals'></span>

<h3>Description</h3>

<p>Computes p-values for extreme behaviour relative to the model of various
cumulative residual processes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cum.residuals'
summary(object, digits = 3, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.cum.residuals_+3A_object">object</code></td>
<td>
<p>output from the cum.residuals() function.</p>
</td></tr>
<tr><td><code id="summary.cum.residuals_+3A_digits">digits</code></td>
<td>
<p>number of digits in printouts.</p>
</td></tr>
<tr><td><code id="summary.cum.residuals_+3A_...">...</code></td>
<td>
<p>unused arguments - for S3 compatibility</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Thomas Scheike
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# see cum.residuals for examples

</code></pre>

<hr>
<h2 id='timecox'>Fit Cox model with partly timevarying effects.</h2><span id='topic+timecox'></span>

<h3>Description</h3>

<p>Fits proportional hazards model with some effects time-varying and some
effects constant.  Time dependent variables and counting process data
(multiple events per subject) are possible.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>timecox(
  formula = formula(data),
  data,
  weights,
  subset,
  na.action,
  start.time = 0,
  max.time = NULL,
  id = NULL,
  clusters = NULL,
  n.sim = 1000,
  residuals = 0,
  robust = 1,
  Nit = 20,
  bandwidth = 0.5,
  method = "basic",
  weighted.test = 0,
  degree = 1,
  covariance = 0
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="timecox_+3A_formula">formula</code></td>
<td>
<p>a formula object with the response on the left of a '~'
operator, and the independent terms on the right as regressors. The response
must be a survival object as returned by the &lsquo;Surv&rsquo; function. Time-invariant
regressors are specified by the wrapper const(), and cluster variables (for
computing robust variances) by the wrapper cluster().</p>
</td></tr>
<tr><td><code id="timecox_+3A_data">data</code></td>
<td>
<p>a data.frame with the variables.</p>
</td></tr>
<tr><td><code id="timecox_+3A_weights">weights</code></td>
<td>
<p>for analysis</p>
</td></tr>
<tr><td><code id="timecox_+3A_subset">subset</code></td>
<td>
<p>to subset</p>
</td></tr>
<tr><td><code id="timecox_+3A_na.action">na.action</code></td>
<td>
<p>to have na.action</p>
</td></tr>
<tr><td><code id="timecox_+3A_start.time">start.time</code></td>
<td>
<p>start of observation period where estimates are computed.</p>
</td></tr>
<tr><td><code id="timecox_+3A_max.time">max.time</code></td>
<td>
<p>end of observation period where estimates are computed.
Estimates thus computed from [start.time, max.time]. Default is max of data.</p>
</td></tr>
<tr><td><code id="timecox_+3A_id">id</code></td>
<td>
<p>For timevarying covariates the variable must associate each record
with the id of a subject.</p>
</td></tr>
<tr><td><code id="timecox_+3A_clusters">clusters</code></td>
<td>
<p>cluster variable for computation of robust variances.</p>
</td></tr>
<tr><td><code id="timecox_+3A_n.sim">n.sim</code></td>
<td>
<p>number of simulations in resampling.</p>
</td></tr>
<tr><td><code id="timecox_+3A_residuals">residuals</code></td>
<td>
<p>to returns residuals that can be used for model validation
in the function cum.residuals</p>
</td></tr>
<tr><td><code id="timecox_+3A_robust">robust</code></td>
<td>
<p>to compute robust variances and construct processes for
resampling. May be set to 0 to save memory.</p>
</td></tr>
<tr><td><code id="timecox_+3A_nit">Nit</code></td>
<td>
<p>number of iterations for score equations.</p>
</td></tr>
<tr><td><code id="timecox_+3A_bandwidth">bandwidth</code></td>
<td>
<p>bandwidth for local iterations. Default is 50 % of the
range of the considered observation period.</p>
</td></tr>
<tr><td><code id="timecox_+3A_method">method</code></td>
<td>
<p>Method for estimation. This refers to different
parametrisations of the baseline of the model. Options are &quot;basic&quot; where the
baseline is written as <code class="reqn">\lambda_0(t) = \exp(\alpha_0(t))</code> or the
&quot;breslow&quot; version where the baseline is parametrised as <code class="reqn">\lambda_0(t)</code>.</p>
</td></tr>
<tr><td><code id="timecox_+3A_weighted.test">weighted.test</code></td>
<td>
<p>to compute a variance weighted version of the
test-processes used for testing time-varying effects.</p>
</td></tr>
<tr><td><code id="timecox_+3A_degree">degree</code></td>
<td>
<p>gives the degree of the local linear smoothing, that is local
smoothing. Possible values are 1 or 2.</p>
</td></tr>
<tr><td><code id="timecox_+3A_covariance">covariance</code></td>
<td>
<p>to compute covariance estimates for nonparametric terms
rather than just the variances.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Resampling is used for computing p-values for tests of timevarying effects.
</p>
<p>The modelling formula uses the standard survival modelling given in the
<b>survival</b> package.
</p>
<p>The data for a subject is presented as multiple rows or 'observations', each
of which applies to an interval of observation (start, stop].  When counting
process data with the )start,stop] notation is used, the 'id' variable is
needed to identify the records for each subject. The program assumes that
there are no ties, and if such are present random noise is added to break
the ties.
</p>


<h3>Value</h3>

<p>Returns an object of type &quot;timecox&quot;. With the following arguments:
</p>
<table>
<tr><td><code>cum</code></td>
<td>
<p>cumulative timevarying regression coefficient estimates are
computed within the estimation interval.</p>
</td></tr> <tr><td><code>var.cum</code></td>
<td>
<p>the martingale
based pointwise variance estimates.  </p>
</td></tr> <tr><td><code>robvar.cum</code></td>
<td>
<p>robust pointwise
variances estimates.  </p>
</td></tr> <tr><td><code>gamma</code></td>
<td>
<p>estimate of parametric components of
model.  </p>
</td></tr> <tr><td><code>var.gamma</code></td>
<td>
<p>variance for gamma.  </p>
</td></tr> <tr><td><code>robvar.gamma</code></td>
<td>
<p>robust
variance for gamma.  </p>
</td></tr> <tr><td><code>residuals</code></td>
<td>
<p>list with residuals. Estimated
martingale increments (dM) and corresponding time vector (time).</p>
</td></tr>
<tr><td><code>obs.testBeq0</code></td>
<td>
<p>observed absolute value of supremum of cumulative
components scaled with the variance.</p>
</td></tr> <tr><td><code>pval.testBeq0</code></td>
<td>
<p>p-value for
covariate effects based on supremum test.</p>
</td></tr> <tr><td><code>sim.testBeq0</code></td>
<td>
<p>resampled
supremum values.</p>
</td></tr> <tr><td><code>obs.testBeqC</code></td>
<td>
<p>observed absolute value of supremum of
difference between observed cumulative process and estimate under null of
constant effect.</p>
</td></tr> <tr><td><code>pval.testBeqC</code></td>
<td>
<p>p-value based on resampling.</p>
</td></tr>
<tr><td><code>sim.testBeqC</code></td>
<td>
<p>resampled supremum values.</p>
</td></tr>
<tr><td><code>obs.testBeqC.is</code></td>
<td>
<p>observed integrated squared differences between
observed cumulative and estimate under null of constant effect.</p>
</td></tr>
<tr><td><code>pval.testBeqC.is</code></td>
<td>
<p>p-value based on resampling.</p>
</td></tr>
<tr><td><code>sim.testBeqC.is</code></td>
<td>
<p>resampled supremum values.</p>
</td></tr>
<tr><td><code>conf.band</code></td>
<td>
<p>resampling based constant to construct robust 95% uniform
confidence bands. </p>
</td></tr> <tr><td><code>test.procBeqC</code></td>
<td>
<p>observed test-process of difference
between observed cumulative process and estimate under null of constant
effect over time.  </p>
</td></tr> <tr><td><code>sim.test.procBeqC</code></td>
<td>
<p>list of 50 random realizations
of test-processes under null based on resampling.</p>
</td></tr>
<tr><td><code>schoenfeld.residuals</code></td>
<td>
<p>Schoenfeld residuals are returned for &quot;breslow&quot;
parametrisation.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Thomas Scheike
</p>


<h3>References</h3>

<p>Martinussen and Scheike, Dynamic Regression Models for Survival
Data, Springer (2006).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(sTRACE)
# Fits time-varying Cox model 
out&lt;-timecox(Surv(time/365,status==9)~age+sex+diabetes+chf+vf,
data=sTRACE,max.time=7,n.sim=100)

summary(out)
par(mfrow=c(2,3))
plot(out)
par(mfrow=c(2,3))
plot(out,score=TRUE)

# Fits semi-parametric time-varying Cox model
out&lt;-timecox(Surv(time/365,status==9)~const(age)+const(sex)+
const(diabetes)+chf+vf,data=sTRACE,max.time=7,n.sim=100)

summary(out)
par(mfrow=c(2,3))
plot(out)

</code></pre>

<hr>
<h2 id='TRACE'>The TRACE study group of myocardial infarction</h2><span id='topic+TRACE'></span><span id='topic+sTRACE'></span><span id='topic+tTRACE'></span>

<h3>Description</h3>

<p>The TRACE data frame contains 1877 patients and is a subset of
a data set consisting of approximately 6000 patients. 
It contains data relating survival of patients after 
myocardial infarction to various risk factors.
</p>
<p>sTRACE is a subsample consisting of 300 patients.
</p>
<p>tTRACE is a subsample consisting of 1000 patients.
</p>


<h3>Format</h3>

<p>This data frame contains the following columns:
</p>

<dl>
<dt>id</dt><dd><p>a numeric vector. Patient code.
</p>
</dd>
<dt>status</dt><dd>
<p>a numeric vector code. Survival status. 9: dead from myocardial infarction, 0: alive, 7,8: dead from other causes. 
</p>
</dd>
<dt>time</dt><dd>
<p>a numeric vector. Survival time in years.
</p>
</dd>
<dt>chf</dt><dd>
<p>a numeric vector code. Clinical heart pump failure, 1: present, 0: absent.
</p>
</dd>
<dt>diabetes</dt><dd>
<p>a numeric vector code. Diabetes, 1: present, 0: absent.
</p>
</dd>
<dt>vf</dt><dd>
<p>a numeric vector code. Ventricular fibrillation, 1: present, 0: absent.
</p>
</dd>
<dt>wmi</dt><dd>
<p>a numeric vector.  Measure of heart pumping effect based on ultrasound
measurements where 2 is normal and 0 is worst.
</p>
</dd>
<dt>sex</dt><dd>
<p>a numeric vector code. 1: female, 0: male.
</p>
</dd>
<dt>age</dt><dd>
<p>a numeric vector code. Age of patient.
</p>
</dd>
</dl>



<h3>Source</h3>

<p>The TRACE study group. 
</p>
<p>Jensen, G.V., Torp-Pedersen, C., Hildebrandt, P., Kober, L.,
F. E. Nielsen, Melchior, T., Joen, T. and P. K. Andersen (1997),
Does in-hospital ventricular fibrillation
affect prognosis after myocardial  infarction?,
European Heart Journal 18, 919&ndash;924.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(TRACE)
names(TRACE)
</code></pre>

<hr>
<h2 id='two.stage'>Fit Clayton-Oakes-Glidden Two-Stage model</h2><span id='topic+two.stage'></span>

<h3>Description</h3>

<p>Fit Clayton-Oakes-Glidden Two-Stage model with Cox-Aalen marginals and
regression on the variance parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>two.stage(
  margsurv,
  data = parent.frame(),
  Nit = 60,
  detail = 0,
  start.time = 0,
  max.time = NULL,
  id = NULL,
  clusters = NULL,
  robust = 1,
  theta = NULL,
  theta.des = NULL,
  var.link = 0,
  step = 0.5,
  notaylor = 0,
  se.clusters = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="two.stage_+3A_margsurv">margsurv</code></td>
<td>
<p>fit of marginal survival cox.aalen model with residuals=2,
and resample.iid=1 to get fully correct standard errors. See notaylor below.</p>
</td></tr>
<tr><td><code id="two.stage_+3A_data">data</code></td>
<td>
<p>a data.frame with the variables.</p>
</td></tr>
<tr><td><code id="two.stage_+3A_nit">Nit</code></td>
<td>
<p>number of iterations for Newton-Raphson algorithm.</p>
</td></tr>
<tr><td><code id="two.stage_+3A_detail">detail</code></td>
<td>
<p>if 0 no details is printed during iterations, if 1 details are
given.</p>
</td></tr>
<tr><td><code id="two.stage_+3A_start.time">start.time</code></td>
<td>
<p>start of observation period where estimates are computed.</p>
</td></tr>
<tr><td><code id="two.stage_+3A_max.time">max.time</code></td>
<td>
<p>end of observation period where estimates are computed.
Estimates thus computed from [start.time, max.time]. Default is max of data.</p>
</td></tr>
<tr><td><code id="two.stage_+3A_id">id</code></td>
<td>
<p>For timevarying covariates the variable must associate each record
with the id of a subject.</p>
</td></tr>
<tr><td><code id="two.stage_+3A_clusters">clusters</code></td>
<td>
<p>cluster variable for computation of robust variances.</p>
</td></tr>
<tr><td><code id="two.stage_+3A_robust">robust</code></td>
<td>
<p>if 0 then totally omits computation of standard errors.</p>
</td></tr>
<tr><td><code id="two.stage_+3A_theta">theta</code></td>
<td>
<p>starting values for the frailty variance (default=0.1).</p>
</td></tr>
<tr><td><code id="two.stage_+3A_theta.des">theta.des</code></td>
<td>
<p>design for regression for variances. The defauls is NULL
that is equivalent to just one theta and the design with only a baseline.</p>
</td></tr>
<tr><td><code id="two.stage_+3A_var.link">var.link</code></td>
<td>
<p>default &quot;0&quot; is that the regression design on the variances
is without a link, and &quot;1&quot; uses the link function exp.</p>
</td></tr>
<tr><td><code id="two.stage_+3A_step">step</code></td>
<td>
<p>step size for Newton-Raphson.</p>
</td></tr>
<tr><td><code id="two.stage_+3A_notaylor">notaylor</code></td>
<td>
<p>if 1 then ignores variation due to survival model, this is
quicker and then resample.iid=0 and residuals=0 is ok for marginal survival
model that then is much quicker.</p>
</td></tr>
<tr><td><code id="two.stage_+3A_se.clusters">se.clusters</code></td>
<td>
<p>cluster variable for sandwich estimator of variance.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The model specifikatin allows a regression structure on the variance of the
random effects, such it is allowed to depend on covariates fixed within
clusters </p>
<p style="text-align: center;"><code class="reqn"> \theta_{k} = Q_{k}^T \nu </code>
</p>
<p>. This is particularly useful to
model jointly different groups and to compare their variances.
</p>
<p>Fits an Cox-Aalen survival model.  Time dependent variables and counting
process data (multiple events per subject) are not possible !
</p>
<p>The marginal baselines are on the Cox-Aalen form </p>
<p style="text-align: center;"><code class="reqn"> \lambda_{ki}(t) =
Y_{ki}(t) ( X_{ki}^T(t) \alpha(t) ) \exp(Z_{ki}^T \beta ) </code>
</p>

<p>The model thus contains the Cox's regression model and the additive hazards
model as special cases. (see cox.aalen function for more on this).
</p>
<p>The modelling formula uses the standard survival modelling given in the
<b>survival</b> package. Only for right censored survival data.
</p>
<p>The data for a subject is presented as multiple rows or 'observations', each
of which applies to an interval of observation (start, stop].  For counting
process data with the )start,stop] notation is used the 'id' variable is
needed to identify the records for each subject. Only one record per subject
is allowed in the current implementation for the estimation of theta.  The
program assumes that there are no ties, and if such are present random noise
is added to break the ties.
</p>
<p>Left truncation is dealt with. Here the key assumption is that the maginals
are correctly estimated and that we have a common truncation time within
each cluster.
</p>


<h3>Value</h3>

<p>returns an object of type &quot;two.stage&quot;. With the following arguments:
</p>
<table>
<tr><td><code>cum</code></td>
<td>
<p>cumulative timevarying regression coefficient estimates are
computed within the estimation interval.</p>
</td></tr> <tr><td><code>var.cum</code></td>
<td>
<p>the martingale
based pointwise variance estimates.</p>
</td></tr> <tr><td><code>robvar.cum</code></td>
<td>
<p>robust pointwise
variances estimates.</p>
</td></tr> <tr><td><code>gamma</code></td>
<td>
<p>estimate of parametric components of
model.</p>
</td></tr> <tr><td><code>var.gamma</code></td>
<td>
<p>variance for gamma.</p>
</td></tr> <tr><td><code>robvar.gamma</code></td>
<td>
<p>robust
variance for gamma.</p>
</td></tr> <tr><td><code>D2linv</code></td>
<td>
<p>inverse of the derivative of the score
function from marginal model.</p>
</td></tr> <tr><td><code>score</code></td>
<td>
<p>value of score for final
estimates.</p>
</td></tr> <tr><td><code>theta</code></td>
<td>
<p>estimate of Gamma variance for frailty.</p>
</td></tr>
<tr><td><code>var.theta</code></td>
<td>
<p>estimate of variance of theta.</p>
</td></tr> <tr><td><code>SthetaInv</code></td>
<td>
<p>inverse of
derivative of score of theta.</p>
</td></tr> <tr><td><code>theta.score</code></td>
<td>
<p>score for theta
parameters.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Thomas Scheike
</p>


<h3>References</h3>

<p>Glidden (2000), A Two-Stage estimator of the dependence
parameter for the Clayton Oakes model.
</p>
<p>Martinussen and Scheike, Dynamic Regression Models for Survival Data,
Springer (2006).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(timereg)
data(diabetes)
# Marginal Cox model  with treat as covariate
marg &lt;- cox.aalen(Surv(time,status)~prop(treat)+prop(adult)+
	  cluster(id),data=diabetes,resample.iid=1)
fit&lt;-two.stage(marg,data=diabetes,theta=1.0,Nit=40)
summary(fit)

# using coxph and giving clusters, but SE wittout cox uncetainty
margph &lt;- coxph(Surv(time,status)~treat,data=diabetes)
fit&lt;-two.stage(margph,data=diabetes,theta=1.0,Nit=40,clusters=diabetes$id)


# Stratification after adult 
theta.des&lt;-model.matrix(~-1+factor(adult),diabetes);
des.t&lt;-model.matrix(~-1+factor(treat),diabetes);
design.treat&lt;-cbind(des.t[,-1]*(diabetes$adult==1),
                    des.t[,-1]*(diabetes$adult==2))

# test for common baselines included here 
marg1&lt;-cox.aalen(Surv(time,status)~-1+factor(adult)+prop(design.treat)+cluster(id),
 data=diabetes,resample.iid=1,Nit=50)

fit.s&lt;-two.stage(marg1,data=diabetes,Nit=40,theta=1,theta.des=theta.des)
summary(fit.s)

# with common baselines  and common treatment effect (although test reject this)
fit.s2&lt;-two.stage(marg,data=diabetes,Nit=40,theta=1,theta.des=theta.des)
summary(fit.s2)

# test for same variance among the two strata
theta.des&lt;-model.matrix(~factor(adult),diabetes);
fit.s3&lt;-two.stage(marg,data=diabetes,Nit=40,theta=1,theta.des=theta.des)
summary(fit.s3)

# to fit model without covariates, use beta.fixed=1 and prop or aalen function
marg &lt;- aalen(Surv(time,status)~+1+cluster(id),
	 data=diabetes,resample.iid=1,n.sim=0)
fita&lt;-two.stage(marg,data=diabetes,theta=0.95,detail=0)
summary(fita)

# same model but se's without variation from marginal model to speed up computations
marg &lt;- aalen(Surv(time,status) ~+1+cluster(id),data=diabetes,
	      resample.iid=0,n.sim=0)
fit&lt;-two.stage(marg,data=diabetes,theta=0.95,detail=0)
summary(fit)

# same model but se's now with fewer time-points for approx of iid decomp of marginal 
# model to speed up computations
marg &lt;- cox.aalen(Surv(time,status) ~+prop(treat)+cluster(id),data=diabetes,
	      resample.iid=1,n.sim=0,max.timepoint.sim=5,beta.fixed=1,beta=0)
fit&lt;-two.stage(marg,data=diabetes,theta=0.95,detail=0)
summary(fit)

</code></pre>

<hr>
<h2 id='wald.test'>Makes wald test</h2><span id='topic+wald.test'></span>

<h3>Description</h3>

<p>Makes wald test, either by contrast matrix or testing components to 0. Can
also specify the regression coefficients and the variance matrix.  Also
makes confidence intervals of the defined contrasts.  Reads coefficientes
and variances from timereg and coxph objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wald.test(
  object = NULL,
  coef = NULL,
  Sigma = NULL,
  vcov = NULL,
  contrast,
  coef.null = NULL,
  null = NULL,
  print.coef = TRUE,
  alpha = 0.05
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wald.test_+3A_object">object</code></td>
<td>
<p>timereg object</p>
</td></tr>
<tr><td><code id="wald.test_+3A_coef">coef</code></td>
<td>
<p>estimates from some model</p>
</td></tr>
<tr><td><code id="wald.test_+3A_sigma">Sigma</code></td>
<td>
<p>variance of estimates</p>
</td></tr>
<tr><td><code id="wald.test_+3A_vcov">vcov</code></td>
<td>
<p>same as Sigma but more standard in other functions</p>
</td></tr>
<tr><td><code id="wald.test_+3A_contrast">contrast</code></td>
<td>
<p>contrast matrix for testing</p>
</td></tr>
<tr><td><code id="wald.test_+3A_coef.null">coef.null</code></td>
<td>
<p>which indeces to test to 0</p>
</td></tr>
<tr><td><code id="wald.test_+3A_null">null</code></td>
<td>
<p>mean of null, 0 by default</p>
</td></tr>
<tr><td><code id="wald.test_+3A_print.coef">print.coef</code></td>
<td>
<p>print the coefficients of the linear combinations.</p>
</td></tr>
<tr><td><code id="wald.test_+3A_alpha">alpha</code></td>
<td>
<p>significance level for CI for linear combinations of
coefficients.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Thomas Scheike
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(sTRACE)
# Fits Cox model 
out&lt;-cox.aalen(Surv(time,status==9)~prop(age)+prop(sex)+
prop(vf)+prop(chf)+prop(diabetes),data=sTRACE,n.sim=0)

wald.test(out,coef.null=c(1,2,3))
### test age=sex   vf=chf
wald.test(out,contrast=rbind(c(1,-1,0,0,0),c(0,0,1,-1,0)))

### now same with direct specifation of estimates and variance
wald.test(coef=out$gamma,Sigma=out$var.gamma,coef.null=c(1,2,3))
wald.test(coef=out$gamma,Sigma=out$robvar.gamma,coef.null=c(1,2,3))
### test age=sex   vf=chf
wald.test(coef=out$gamma,Sigma=out$var.gamma,
	  contrast=rbind(c(1,-1,0,0,0),c(0,0,1,-1,0)))

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
