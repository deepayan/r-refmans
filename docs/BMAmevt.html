<!DOCTYPE html><html><head><title>Help for package BMAmevt</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {BMAmevt}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#BMAmevt-package'><p>Bayesian Model Averaging for Multivariate Extremes</p></a></li>
<li><a href='#add.frame'><p>Adds graphical elements to a plot of the two dimensional simplex.</p></a></li>
<li><a href='#cons.angular.dat'><p>Angular data set generation from unit Frechet data.</p></a></li>
<li><a href='#ddirimix'><p>Angular density/likelihood function in the Dirichlet Mixture</p>
model.</a></li>
<li><a href='#ddirimix.grid'><p>Plots the Dirichlet mixture density on a discretization grid</p></a></li>
<li><a href='#ddirimix.grid1D'><p>Univariate projection or marginalization of a  Dirichlet mixture density on  on <code>[0,1]</code></p></a></li>
<li><a href='#dgridplot'><p>Image and/or Contour plots of  spectral densities in  trivariate  extreme value  models</p></a></li>
<li><a href='#diagnose'><p>Diagnostics for the MCMC output in the PB and NL models.</p></a></li>
<li><a href='#discretize'><p>Discretization grid builder.</p></a></li>
<li><a href='#dm.expar.D3k3'><p>Example of valid Dirichlet mixture parameter for tri-variate extremes.</p></a></li>
<li><a href='#dnestlog'><p>Pairwise Beta (PB) and Nested Asymmetric Logistic (NL) distributions</p></a></li>
<li><a href='#dnestlog.grid'><p>PB and NL spectral  densities on the two-dimensional simplex</p></a></li>
<li><a href='#excessProb.condit.dm'><p>Probability of joint threshold exceedance, in the Dirichlet Mixture model,  given a DM parameter.</p></a></li>
<li><a href='#excessProb.condit.nl'><p>Probability of joint threshold excess in the NL model</p></a></li>
<li><a href='#excessProb.condit.pb'><p>Estimates the probability of joint excess, given a PB parameter.</p></a></li>
<li><a href='#excessProb.nl'><p>Posterior distribution the probability of joint threshold excess, in the NL model.</p></a></li>
<li><a href='#excessProb.pb'><p>Estimates the probability of joint excess (Frechet margins)</p></a></li>
<li><a href='#expfunction.nl'><p>Exponent function in the NL  model.</p></a></li>
<li><a href='#frechetdat'><p>Multivariate data set with margins following unit Frechet</p>
distribution.</a></li>
<li><a href='#invlogit'><p>Inverse logit transformation</p></a></li>
<li><a href='#lAccept.ratio'><p>Acceptance probability in the MCMC algorithm.</p></a></li>
<li><a href='#laplace.evt'><p>Laplace approximation of  a model marginal likelihood by Laplace approximation.</p></a></li>
<li><a href='#Leeds'><p>Tri-variate &lsquo;angular&rsquo; data set approximately distributed according to a multivariate extremes angular distribution</p></a></li>
<li><a href='#Leeds.frechet'><p>Multivariate data set with margins following unit Frechet distribution.</p></a></li>
<li><a href='#logit'><p>Logit transformation</p></a></li>
<li><a href='#marginal.lkl'><p>Marginal model likelihood</p></a></li>
<li><a href='#marginal.lkl.nl'><p>Marginal likelihoods of the PB and NL models.</p></a></li>
<li><a href='#maxLikelihood'><p>Maximum likelihood optimization</p></a></li>
<li><a href='#MCpriorIntFun'><p>Generic Monte-Carlo integration of a function under the prior distribution</p></a></li>
<li><a href='#MCpriorIntFun.nl'><p>Generic Monte-Carlo integration  under the prior distribution in the PB and NL  models.</p></a></li>
<li><a href='#nl.Hpar'><p>Default hyper-parameters for the NL model.</p></a></li>
<li><a href='#nl.MCpar'><p>Default MCMC tuning parameter for the Nested Asymmetric logistic model.</p></a></li>
<li><a href='#pb.Hpar'><p>Default hyper-parameters for the Pairwise Beta model.</p></a></li>
<li><a href='#pb.MCpar'><p>Default MCMC tuning parameter for the Pairwise Beta model.</p></a></li>
<li><a href='#posterior.predictive.nl'><p>Posterior predictive densities in the three dimensional</p>
PB, NL and NL3  models</a></li>
<li><a href='#posterior.predictive3D'><p>Posterior predictive density on the simplex, for three-dimensional extreme value  models.</p></a></li>
<li><a href='#posteriorDistr.bma'><p>Posterior distribution in the average model</p></a></li>
<li><a href='#posteriorMCMC'><p>MCMC sampler for parametric spectral measures</p></a></li>
<li><a href='#posteriorMCMC.nl'><p>MCMC posterior samplers for the pairwise beta and the negative logistic models.</p></a></li>
<li><a href='#posteriorMean'><p>Posterior predictive density on the simplex, for three-dimensional extreme value  models.</p></a></li>
<li><a href='#posteriorWeights'><p>Posterior model weights</p></a></li>
<li><a href='#prior.nl'><p>Prior parameter distribution for the NL  model</p></a></li>
<li><a href='#prior.pb'><p>Prior parameter distribution for the Pairwise Beta model</p></a></li>
<li><a href='#proposal.nl'><p>NL3  model: proposal distribution.</p></a></li>
<li><a href='#proposal.pb'><p>PB model: proposal distribution</p></a></li>
<li><a href='#rdirichlet'><p>Dirichlet distribution: random generator</p></a></li>
<li><a href='#rect.integrate'><p>Density integration on the two-dimensional simplex</p></a></li>
<li><a href='#rstable.posit'><p>Positive alpha-stable distribution.</p></a></li>
<li><a href='#scores3D'><p>Logarithmic score and <code class="reqn">L^2</code> distance  between two densities on the simplex (trivariate case).</p></a></li>
<li><a href='#transf.to.equi'><p>Linear coordinate transformations</p></a></li>
<li><a href='#winterdat'><p>Five-dimensional air quality dataset recorded in Leeds(U.K.), during five winter seasons.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Multivariate Extremes: Bayesian Estimation of the Spectral
Measure</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.5</td>
</tr>
<tr>
<td>Depends:</td>
<td>stats, utils, coda</td>
</tr>
<tr>
<td>Description:</td>
<td>Toolkit for Bayesian estimation of the dependence structure in multivariate extreme value parametric models, following Sabourin and Naveau (2014) &lt;<a href="https://doi.org/10.1016%2Fj.csda.2013.04.021">doi:10.1016/j.csda.2013.04.021</a>&gt; and Sabourin, Naveau and Fougeres (2013) &lt;<a href="https://doi.org/10.1007%2Fs10687-012-0163-0">doi:10.1007/s10687-012-0163-0</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>LazyData:</td>
<td>no</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/lbelzile/BMAmevt/issues/">https://github.com/lbelzile/BMAmevt/issues/</a></td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Collate:</td>
<td>'BMAmevt-package.R' 'Laplace.evt.r' 'MCpriorIntFun.nl.r'
'MCpriorIntFun.pb.r' 'MCpriorIntFun.r' 'add.frame.r'
'transf.to.equi.r' 'cons.angular.dat.r' 'ddirimix.grid.r'
'ddirimix.grid1D.r' 'ddirimix.r' 'dgridplot.R' 'diagnose.r'
'discretize.R' 'dnestlog.grid.r' 'dnestlog.r'
'dpairbeta.grid.r' 'dpairbeta.r' 'emp_density.r'
'excessProb.condit.dm.r' 'excessProb.nl.r' 'excessProb.pb.r'
'lAccept.ratio.r' 'marginal.lkl.nl.r' 'marginal.lkl.pb.r'
'marginal.lkl.r' 'maxLikelihood.r' 'posterior.predictive.nl.r'
'posterior.predictive.pb.r' 'posterior.predictive3D.r'
'posteriorDistr.bma.r' 'posteriorMCMC.nl.r'
'posteriorMCMC.pb.r' 'posteriorMCMC.r' 'posteriorMean.r'
'posteriorWeights.r' 'prior.nl.r' 'prior.pb.r' 'proposal.nl.r'
'proposal.pb.r' 'rdirimix.r' 'rect.integrate.r' 'rnestlog.r'
'rpairbeta.r' 'rstable.posit.R' 'scores3D.r' 'transf.to.rect.r'
'wrapper.R' 'zzz.r'</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-04-21 00:48:53 UTC; lbelzile</td>
</tr>
<tr>
<td>Author:</td>
<td>Leo Belzile <a href="https://orcid.org/0000-0002-9135-014X"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [cre],
  Anne Sabourin <a href="https://orcid.org/0000-0002-5096-9157"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Leo Belzile &lt;belzilel@gmail.com&gt;</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-04-21 02:22:38 UTC</td>
</tr>
</table>
<hr>
<h2 id='BMAmevt-package'>Bayesian Model Averaging for Multivariate Extremes</h2><span id='topic+BMAmevt-package'></span><span id='topic+BMAmevt'></span>

<h3>Description</h3>

<p>Toolkit for Bayesian estimation of the dependence structure
in Multivariate Extreme Value parametric models, with possible use of Bayesian model Averaging techniques
Includes a Generic MCMC sampler. Estimation of the marginal
distributions is a prerequisite, <em>e.g.</em> using one of the
packages
<code>ismev</code>, <code>evd</code>, <code>evdbayes</code> or <code>POT</code>. This package handles data sets which are assumed
to be marginally unit-Frechet distributed.
</p>


<h3>Author(s)</h3>

<p>Anne Sabourin
</p>


<h3>See Also</h3>

<p><code>evdbayes</code>
</p>

<hr>
<h2 id='add.frame'>Adds graphical elements to a plot of the two dimensional simplex.</h2><span id='topic+add.frame'></span>

<h3>Description</h3>

<p>Adds graphical elements to the current plot (on the two-dimensional simplex).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add.frame(
  equi = FALSE,
  lab1 = "w1",
  lab2 = "w2",
  lab3 = "w3",
  npoints = 60,
  col.polygon = "black",
  axes = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add.frame_+3A_equi">equi</code></td>
<td>
<p>logical. Is the simplex represented as an equilateral triangle (if <code>TRUE</code>) or a right triangle (if <code>FALSE</code>) ?</p>
</td></tr>
<tr><td><code id="add.frame_+3A_lab1">lab1</code></td>
<td>
<p>Character string: label for first component.</p>
</td></tr>
<tr><td><code id="add.frame_+3A_lab2">lab2</code></td>
<td>
<p>Character string: label for second component.</p>
</td></tr>
<tr><td><code id="add.frame_+3A_lab3">lab3</code></td>
<td>
<p>Character string: label for third component.</p>
</td></tr>
<tr><td><code id="add.frame_+3A_npoints">npoints</code></td>
<td>
<p>The number of grid nodes on the squared grid containing the desired triangle.</p>
</td></tr>
<tr><td><code id="add.frame_+3A_col.polygon">col.polygon</code></td>
<td>
<p>The background color outside the simplex.</p>
</td></tr>
<tr><td><code id="add.frame_+3A_axes">axes</code></td>
<td>
<p>logical. Should axes be added ?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Generic graphical tool for obtaining nice plots of the two-dimensional simplex
</p>


<h3>Examples</h3>

<pre><code class='language-R'>plot.new()
add.frame()
plot.new()
mult.x=sqrt(2); mult.y=sqrt(3/2)
plot.window( xlim=c(0,mult.x),ylim=c(0,mult.y), asp=1,bty ="n")
add.frame(equi=TRUE)
</code></pre>

<hr>
<h2 id='cons.angular.dat'>Angular data set generation from unit Frechet data.</h2><span id='topic+cons.angular.dat'></span>

<h3>Description</h3>

<p>Builds an angular data set, retaining the points with largest radial component.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cons.angular.dat(
  coordinates = c(1, 2, 3),
  frechetDat = get("frechetdat"),
  n = 100,
  displ = TRUE,
  invisible = TRUE,
  add = FALSE,
  lab1 = "w1",
  lab2 = "w2",
  lab3 = "w3",
  npoints = 60,
  col.polygon = "white",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cons.angular.dat_+3A_coordinates">coordinates</code></td>
<td>
<p>Index vector of the columns in <code>frechetDat</code> to be retained to construct the angular data set.</p>
</td></tr>
<tr><td><code id="cons.angular.dat_+3A_frechetdat">frechetDat</code></td>
<td>
<p>The data set. A matrix: each row is a multivariate record. May contain <var>NA</var>'s.</p>
</td></tr>
<tr><td><code id="cons.angular.dat_+3A_n">n</code></td>
<td>
<p>The number of desired observations in the final angular data set. Should be less than <code>nrow(frechetDat)</code></p>
</td></tr>
<tr><td><code id="cons.angular.dat_+3A_displ">displ</code></td>
<td>
<p>logical. Should the angular data set be plotted ?</p>
</td></tr>
<tr><td><code id="cons.angular.dat_+3A_invisible">invisible</code></td>
<td>
<p>logical. Should the result be returned as invisible ?</p>
</td></tr>
<tr><td><code id="cons.angular.dat_+3A_add">add</code></td>
<td>
<p>logical. Only used when <code>displ==TRUE</code>. Should the points be added to the current plot ?</p>
</td></tr>
<tr><td><code id="cons.angular.dat_+3A_lab1">lab1</code></td>
<td>
<p>Character string: label for first component.</p>
</td></tr>
<tr><td><code id="cons.angular.dat_+3A_lab2">lab2</code></td>
<td>
<p>Character string: label for second component.</p>
</td></tr>
<tr><td><code id="cons.angular.dat_+3A_lab3">lab3</code></td>
<td>
<p>Character string: label for third component.</p>
</td></tr>
<tr><td><code id="cons.angular.dat_+3A_npoints">npoints</code></td>
<td>
<p>The number of grid nodes on the squared grid containing the desired triangle.</p>
</td></tr>
<tr><td><code id="cons.angular.dat_+3A_col.polygon">col.polygon</code></td>
<td>
<p>The background color outside the simplex.</p>
</td></tr>
<tr><td><code id="cons.angular.dat_+3A_...">...</code></td>
<td>
<p>Additional graphical parameters and  arguments to be passed to function <code><a href="graphics.html#topic+plot.window">plot.window</a></code> and <code><a href="graphics.html#topic+points">points</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The data set <code>frechetDat</code> is assumed to be marginally unit  Frechet distributed.
</p>


<h3>Value</h3>

<p>The angular data set: A <code>n*length(coordinates)</code> matrix, containing values between zero and one, which rows sum to one: Each row is thus a point on the unit simplex of dimension <code>length(coordinates)-1</code>. Returned as  invisible if <code>invisible==TRUE</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> ## Not run: cons.angular.dat()
</code></pre>

<hr>
<h2 id='ddirimix'>Angular density/likelihood function in the Dirichlet Mixture
model.</h2><span id='topic+ddirimix'></span><span id='topic+rdirimix'></span>

<h3>Description</h3>

<p>Likelihood function (spectral density on the simplex)
and angular data  sampler   in the  Dirichlet mixture model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ddirimix(
  x = c(0.1, 0.2, 0.7),
  par,
  wei = par$wei,
  Mu = par$Mu,
  lnu = par$lnu,
  log = FALSE,
  vectorial = FALSE
)

rdirimix(
  n = 10,
  par = get("dm.expar.D3k3"),
  wei = par$wei,
  Mu = par$Mu,
  lnu = par$lnu
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ddirimix_+3A_x">x</code></td>
<td>
<p>An angular data set which may be reduced to a single point: 
A <code class="reqn">n*p</code> matrix or a vector of length <code>p</code>, where
<code class="reqn">p</code> is the dimension of the sample space and <code class="reqn">n</code> is
the sample size.
Each row is a point on the simplex, so that  each row sum to one. 
The error tolerance is set to <code>1e-8</code>
in this package.</p>
</td></tr>
<tr><td><code id="ddirimix_+3A_par">par</code></td>
<td>
<p>The parameter list for the Dirichlet mixture model.</p>
</td></tr>
<tr><td><code id="ddirimix_+3A_wei">wei</code></td>
<td>
<p>Optional. If present, overrides the value of
<code>par$wei</code>.</p>
</td></tr>
<tr><td><code id="ddirimix_+3A_mu">Mu</code></td>
<td>
<p>Optional. If present, overrides the value of
<code>par$Mu</code>.</p>
</td></tr>
<tr><td><code id="ddirimix_+3A_lnu">lnu</code></td>
<td>
<p>Optional. If present, overrides the value of
<code>par$lnu</code>.</p>
</td></tr>
<tr><td><code id="ddirimix_+3A_log">log</code></td>
<td>
<p>Logical: should the density or the likelihood be returned on the log-scale ?</p>
</td></tr>
<tr><td><code id="ddirimix_+3A_vectorial">vectorial</code></td>
<td>
<p>Logical: Should a vector of size <code class="reqn">n</code> or a single value be returned ?</p>
</td></tr>
<tr><td><code id="ddirimix_+3A_n">n</code></td>
<td>
<p>The number of angular points to be generated</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The spectral probability measure  defined  on the simplex
characterizes the
dependence structure of multivariate extreme value models.
The parameter list for a mixture
with  <code class="reqn">k</code>  components, is made of
</p>

<dl>
<dt>Mu</dt><dd><p> The density kernel centers
<code class="reqn">\mu_{i,m}, 1\le i \le p, 1\le m \le k</code> :
A  <code class="reqn">p*k</code> matrix,
which columns sum to one, and such that <code>Mu %*% wei=1</code>,
for the moments constraint to be satisfied. 
Each column is a Dirichlet kernel center.
</p>
</dd>
<dt>wei</dt><dd><p> The weights vector for the kernel densities:
A vector of  <code class="reqn">k</code> positive numbers summing to one.</p>
</dd>
<dt>lnu</dt><dd><p>The logarithms of the shape parameters
<code class="reqn">nu_m, 1\le m \le k</code> for the density kernels:
a vector of size <code class="reqn">k</code>.</p>
</dd>
</dl>

<p>The moments constraint imposes  that the barycenter of the columns in
<code>Mu</code>, with weights <code>wei</code>, be the center of the simplex.
</p>


<h3>Value</h3>

<p><code>ddirimix</code> returns the likelihood  as a  single number if
<code>vectorial ==FALSE</code>, or as a vector of size
<code>nrow(x)</code> containing the likelihood of each angular data point.
If <code>log == TRUE</code>,  the log-likelihood is returned instead.
<code>rdirimix</code> returns a matrix with <code>n</code> points and
<code>p=nrow(Mu)</code> columns.
</p>

<hr>
<h2 id='ddirimix.grid'>Plots the Dirichlet mixture density on a discretization grid</h2><span id='topic+ddirimix.grid'></span>

<h3>Description</h3>

<p>Only valid in the tri-variate case
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ddirimix.grid(
  par = get("dm.expar.D3k3"),
  wei = par$wei,
  Mu = par$Mu,
  lnu = par$lnu,
  npoints = 30,
  eps = 10^(-3),
  equi = TRUE,
  marginal = TRUE,
  coord = c(1, 2, 3),
  invisible = TRUE,
  displ = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ddirimix.grid_+3A_par">par</code></td>
<td>
<p>The parameter list for the Dirichlet mixture model.</p>
</td></tr>
<tr><td><code id="ddirimix.grid_+3A_wei">wei</code></td>
<td>
<p>Optional. If present, overrides the value of
<code>par$wei</code>.</p>
</td></tr>
<tr><td><code id="ddirimix.grid_+3A_mu">Mu</code></td>
<td>
<p>Optional. If present, overrides the value of
<code>par$Mu</code>.</p>
</td></tr>
<tr><td><code id="ddirimix.grid_+3A_lnu">lnu</code></td>
<td>
<p>Optional. If present, overrides the value of
<code>par$lnu</code>.</p>
</td></tr>
<tr><td><code id="ddirimix.grid_+3A_npoints">npoints</code></td>
<td>
<p>The number of grid nodes on the squared grid containing the desired triangle.</p>
</td></tr>
<tr><td><code id="ddirimix.grid_+3A_eps">eps</code></td>
<td>
<p>Positive number:  minimum
distance from any node inside the simplex to  the simplex boundary</p>
</td></tr>
<tr><td><code id="ddirimix.grid_+3A_equi">equi</code></td>
<td>
<p>logical. Is the simplex represented as an equilateral triangle (if <code>TRUE</code>) or a right triangle (if <code>FALSE</code>) ?</p>
</td></tr>
<tr><td><code id="ddirimix.grid_+3A_marginal">marginal</code></td>
<td>
<p>logical. If <code>TRUE</code>, the angular density corresponds to the marginal intensity measure, over coordinates <code>coord</code>. Otherwise, it is only the projection of the full dimensional angular measure (hence the moments constraints is not satisfied anymore).</p>
</td></tr>
<tr><td><code id="ddirimix.grid_+3A_coord">coord</code></td>
<td>
<p>A vector of size 3: 
the indices of the coordinates upon which the marginalization is to be done.</p>
</td></tr>
<tr><td><code id="ddirimix.grid_+3A_invisible">invisible</code></td>
<td>
<p>Logical: should the result be returned as invisible ?</p>
</td></tr>
<tr><td><code id="ddirimix.grid_+3A_displ">displ</code></td>
<td>
<p>Logical: should a plot be issued ?</p>
</td></tr>
<tr><td><code id="ddirimix.grid_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to
<code><a href="#topic+dgridplot">dgridplot</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The discretized density
</p>

<hr>
<h2 id='ddirimix.grid1D'>Univariate projection or marginalization of a  Dirichlet mixture density on  on <code>[0,1]</code></h2><span id='topic+ddirimix.grid1D'></span>

<h3>Description</h3>

<p>Plots a univariate Dirichlet mixture (in other words, a Beta mixture) angular density for extreme bi-variate data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ddirimix.grid1D(
  par = get("dm.expar.D2k4"),
  wei = par$wei,
  Mu = par$Mu,
  lnu = par$lnu,
  npoints = 30,
  eps = 10^(-3),
  coord = c(1, 2),
  marginal = TRUE,
  invisible = TRUE,
  displ = TRUE,
  add = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ddirimix.grid1D_+3A_par">par</code></td>
<td>
<p>The parameter list for the Dirichlet mixture model.</p>
</td></tr>
<tr><td><code id="ddirimix.grid1D_+3A_wei">wei</code></td>
<td>
<p>Optional. If present, overrides the value of
<code>par$wei</code>.</p>
</td></tr>
<tr><td><code id="ddirimix.grid1D_+3A_mu">Mu</code></td>
<td>
<p>Optional. If present, overrides the value of
<code>par$Mu</code>.</p>
</td></tr>
<tr><td><code id="ddirimix.grid1D_+3A_lnu">lnu</code></td>
<td>
<p>Optional. If present, overrides the value of
<code>par$lnu</code>.</p>
</td></tr>
<tr><td><code id="ddirimix.grid1D_+3A_npoints">npoints</code></td>
<td>
<p>number of points on the 1D  discretization grid.</p>
</td></tr>
<tr><td><code id="ddirimix.grid1D_+3A_eps">eps</code></td>
<td>
<p>the minimum value ( = 1- the maximum value) of the grid points.</p>
</td></tr>
<tr><td><code id="ddirimix.grid1D_+3A_coord">coord</code></td>
<td>
<p>A vector of size 2:
the indices of the coordinates upon which the marginalization or projection is to be done if the dimension of the sample space is greater than two.</p>
</td></tr>
<tr><td><code id="ddirimix.grid1D_+3A_marginal">marginal</code></td>
<td>
<p>logical. If <code>TRUE</code>, the angular density corresponds to the marginal intensity measure of the extreme Poisson process, over coordinates <code>coord</code>. Otherwise, it is only the projection of the full dimensional angular measure (hence the moments constraints is not satisfied anymore).</p>
</td></tr>
<tr><td><code id="ddirimix.grid1D_+3A_invisible">invisible</code></td>
<td>
<p>Logical: should the result be returned as invisible ?</p>
</td></tr>
<tr><td><code id="ddirimix.grid1D_+3A_displ">displ</code></td>
<td>
<p>Logical: should a plot be issued ?</p>
</td></tr>
<tr><td><code id="ddirimix.grid1D_+3A_add">add</code></td>
<td>
<p>Logical: should the density be added to the currently active plot ?</p>
</td></tr>
<tr><td><code id="ddirimix.grid1D_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to <code>plot</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>The discretized density on <code>[eps, 1-eps]</code> (included in [0,1])
</p>

<hr>
<h2 id='dgridplot'>Image and/or Contour plots of  spectral densities in  trivariate  extreme value  models</h2><span id='topic+dgridplot'></span>

<h3>Description</h3>

<p>Plots contours or gray-scale level sets  of a spectral density on the two-dimensional simplex.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dgridplot(
  density = matrix(5 * sin(1/73 * (1:(40 * 40)))^2, ncol = 40, nrow = 40),
  eps = 10^(-3),
  equi = TRUE,
  add = FALSE,
  breaks = seq(-0.01, 5.1, length.out = 1000),
  levels = seq(0, 6, length.out = 13),
  col.lines = "black",
  labcex = 0.8,
  background = FALSE,
  col.polygon = gray(0.5),
  lab1 = "w1",
  lab2 = "w2",
  lab3 = "w3",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dgridplot_+3A_density">density</code></td>
<td>
<p>A <code>npoints*npoints</code> matrix containing the
density's values  scattered on the discretization grid defined by
<code>npoints, equi, eps</code> (see <code><a href="#topic+discretize">discretize</a></code>).</p>
</td></tr>
<tr><td><code id="dgridplot_+3A_eps">eps</code></td>
<td>
<p>Positive number:  minimum
distance from any node inside the simplex to  the simplex boundary</p>
</td></tr>
<tr><td><code id="dgridplot_+3A_equi">equi</code></td>
<td>
<p>logical. Is the simplex represented as an equilateral triangle (if <code>TRUE</code>) or a right triangle (if <code>FALSE</code>) ?</p>
</td></tr>
<tr><td><code id="dgridplot_+3A_add">add</code></td>
<td>
<p>Logical. Should the contours be added to a currently active plot ?</p>
</td></tr>
<tr><td><code id="dgridplot_+3A_breaks">breaks</code></td>
<td>
<p>Set of breakpoints for the gray scale colors.
See <code><a href="graphics.html#topic+image">image</a></code></p>
</td></tr>
<tr><td><code id="dgridplot_+3A_levels">levels</code></td>
<td>
<p>Levels to which plot the contour lines. See <code><a href="graphics.html#topic+contour">contour</a></code></p>
</td></tr>
<tr><td><code id="dgridplot_+3A_col.lines">col.lines</code></td>
<td>
<p>The color to be used for the contour lines.</p>
</td></tr>
<tr><td><code id="dgridplot_+3A_labcex">labcex</code></td>
<td>
<p><code>cex</code> for contour labeling.
See  <code><a href="graphics.html#topic+contour">contour</a></code>.</p>
</td></tr>
<tr><td><code id="dgridplot_+3A_background">background</code></td>
<td>
<p>Logical. Should a the background be filled
inside the simplex <em>via</em> a call to
<code><a href="graphics.html#topic+image">image</a></code> ?</p>
</td></tr>
<tr><td><code id="dgridplot_+3A_col.polygon">col.polygon</code></td>
<td>
<p>The background color outside the simplex.</p>
</td></tr>
<tr><td><code id="dgridplot_+3A_lab1">lab1</code></td>
<td>
<p>Character string: label for first component.</p>
</td></tr>
<tr><td><code id="dgridplot_+3A_lab2">lab2</code></td>
<td>
<p>Character string: label for second component.</p>
</td></tr>
<tr><td><code id="dgridplot_+3A_lab3">lab3</code></td>
<td>
<p>Character string: label for third component.</p>
</td></tr>
<tr><td><code id="dgridplot_+3A_...">...</code></td>
<td>
<p>Additional graphical parameters and arguments to be passed
to <code><a href="graphics.html#topic+contour">contour</a></code>  and <code><a href="graphics.html#topic+image">image</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function  interprets the <code>density</code> matrix as 
<code><a href="graphics.html#topic+contour">contour</a></code> does, <em>i.e.</em> as a table of
<code>f(X[i], Y[j])</code> values, with column 1 at the bottom,
where <code>X</code> and <code>Y</code> are
returned by <code><a href="#topic+discretize">discretize</a></code> and <code>f</code> is the
density function.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>wrapper &lt;- function(x, y, my.fun,...) 
      {
       sapply(seq_along(x), FUN = function(i) my.fun(x[i], y[i],...))
      }

grid &lt;- discretize(npoints=40,eps=1e-3,equi=FALSE)

Density &lt;- outer(grid$X,grid$Y,FUN=wrapper,
                my.fun=function(x,y){10*((x/2)^2+y^2)*((x+y)&lt;1)})

dgridplot(density= Density,npoints=40, equi=FALSE)
</code></pre>

<hr>
<h2 id='diagnose'>Diagnostics for the MCMC output in the PB and NL models.</h2><span id='topic+diagnose'></span><span id='topic+diagnose.PBNLpostsample'></span>

<h3>Description</h3>

<p>The method issues several convergence diagnostics, in the particular case when the PB or the NL model is used. The code may be easily modified for other angular models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>diagnose(obj, ...)

## S3 method for class 'PBNLpostsample'
diagnose(
  obj,
  true.par = NULL,
  from = NULL,
  to = NULL,
  autocor.max = 0.2,
  default.thin = 50,
  xlim.density = c(-4, 4),
  ylim.density = NULL,
  plot = TRUE,
  predictive = FALSE,
  save = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="diagnose_+3A_obj">obj</code></td>
<td>
<p>an object of class <code>postsample</code>:  posterior sample, as produced by
<code><a href="#topic+posteriorMCMC.pb">posteriorMCMC.pb</a></code> or <code><a href="#topic+posteriorMCMC.nl">posteriorMCMC.nl</a></code></p>
</td></tr>
<tr><td><code id="diagnose_+3A_...">...</code></td>
<td>
<p>Additional parameters to be passed to the functions
<code><a href="#topic+posterior.predictive.pb">posterior.predictive.pb</a></code> or <code><a href="#topic+posterior.predictive.nl">posterior.predictive.nl</a></code>.</p>
</td></tr>
<tr><td><code id="diagnose_+3A_true.par">true.par</code></td>
<td>
<p>The true parameter. If <code>NULL</code>, it is considered as unknown.</p>
</td></tr>
<tr><td><code id="diagnose_+3A_from">from</code></td>
<td>
<p>Integer or <code>NULL</code>. If <code>NULL</code>, the default value is used. Otherwise,  should be greater than <code>post.sample$Nbin</code>. Indicates the  index where the averaging process should start. Default to <code>post.sample$Nbin +1</code></p>
</td></tr>
<tr><td><code id="diagnose_+3A_to">to</code></td>
<td>
<p>Integer or <code>NULL</code>. If <code>NULL</code>, the default
value is used. Otherwise, must be lower than <code>Nsim+1</code>.
Indicates  where the averaging process should stop.
Default to <code>post.sample$Nsim</code>.</p>
</td></tr>
<tr><td><code id="diagnose_+3A_autocor.max">autocor.max</code></td>
<td>
<p>The maximum accepted auto-correlation  for two successive parameters in the thinned sample.</p>
</td></tr>
<tr><td><code id="diagnose_+3A_default.thin">default.thin</code></td>
<td>
<p>The default thinning interval if the above condition cannot be satisfied.</p>
</td></tr>
<tr><td><code id="diagnose_+3A_xlim.density">xlim.density</code></td>
<td>
<p>The <code>xlim</code> interval for the density plots,
on the transformed scale.</p>
</td></tr>
<tr><td><code id="diagnose_+3A_ylim.density">ylim.density</code></td>
<td>
<p>the <code>ylim</code> intervals for the density plots.</p>
</td></tr>
<tr><td><code id="diagnose_+3A_plot">plot</code></td>
<td>
<p>Logical. Should plots be issued ?</p>
</td></tr>
<tr><td><code id="diagnose_+3A_predictive">predictive</code></td>
<td>
<p>Logical. Should the predictive density be plotted ?</p>
</td></tr>
<tr><td><code id="diagnose_+3A_save">save</code></td>
<td>
<p>Logical: should the result be saved ? Only used if the posterior sample has been saved itself (<em>i.e.</em> if it contains <code>save=TRUE</code> in its arguments list)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list made of </p>

<dl>
<dt>predictive</dt><dd><p>The posterior predictive, or <code>0</code> if <code>predictive=FALSE</code> </p>
</dd>
<dt>effective.size</dt><dd><p>the effective sample size of each component</p>
</dd>
<dt>heidelTest</dt><dd><p>The first part of the Heidelberger and Welch test (stationarity test). The first row indicates &ldquo;success&rdquo; (1) or
rejection(0), the second line shows the number of iterations to be discarded, the third line is the p-value of the test statistic.</p>
</dd>
<dt>gewekeTest</dt><dd><p>The test statistics from the Geweke stationarity test.</p>
</dd>
<dt>gewekeScore</dt><dd><p>The p-values for the above test statistics</p>
</dd>
<dt>thin</dt><dd><p>The thinning interval retained</p>
</dd>
<dt>correl.max.thin</dt><dd><p>The maximum auto-correlation for a lag equal to <code>thin</code> </p>
</dd>
<dt>linked.est.mean</dt><dd><p>The posterior mean of the transformed parameter (on the real line)</p>
</dd>
<dt>linked.est.sd</dt><dd><p>The standard deviation of the transformed parameters</p>
</dd>
<dt>est.mean</dt><dd><p>The posterior mean of the original parameters, as they appears in the expression of the likelihood</p>
</dd>
<dt>sample.sd</dt><dd><p>the posterior standard deviation of the original parameters</p>
</dd>
</dl>


<hr>
<h2 id='discretize'>Discretization grid builder.</h2><span id='topic+discretize'></span>

<h3>Description</h3>

<p>Builds a discretization grid covering the two-dimensional unit simplex, with specified number of points and minimal distance from the boundary.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>discretize(npoints = 40, eps = 0.001, equi = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="discretize_+3A_npoints">npoints</code></td>
<td>
<p>The number of grid nodes on the squared grid containing the desired triangle.</p>
</td></tr>
<tr><td><code id="discretize_+3A_eps">eps</code></td>
<td>
<p>Positive number:  minimum
distance from any node inside the simplex to  the simplex boundary</p>
</td></tr>
<tr><td><code id="discretize_+3A_equi">equi</code></td>
<td>
<p>logical. Is the simplex represented as an equilateral triangle (if <code>TRUE</code>) or a right triangle (if <code>FALSE</code>) ?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>npoints*npoints</code> grid  covers either
the equilateral representation of
the simplex, or the  right angled one.
In any case, the grid is 
<em>rectangular</em>: some nodes lie outside the triangle.
Density computations on such a grid should handle the case when
the point passed as argument is outside the simplex (typically,
the function should return zero in such a case).
</p>


<h3>Value</h3>

<p>A list containing two elements: <code>X</code> and <code>Y</code>, vectors of size <code>npoints</code>, the Cartesian coordinates of the grid nodes.
</p>


<h3>Note</h3>

<p>In case <code>equi==TRUE</code>, <code>epsilon</code> is the  minimum
distance from any node inside the simplex to  the simplex boundary,
<em>after transformation</em> to the right-angled representation.
</p>

<hr>
<h2 id='dm.expar.D3k3'>Example of valid Dirichlet mixture parameter for tri-variate extremes.</h2><span id='topic+dm.expar.D3k3'></span>

<h3>Description</h3>

<p>The Dirichlet mixture density has three components, the center of mass of the three columns of <code>Mu</code>, with weights <code>wei</code> is <code class="reqn">(1/3,1/3,1/3)</code>: the centroid of the two dimensional unit simplex.
</p>


<h3>Format</h3>

<p>A list made of </p>

<dl>
<dt>Mu</dt><dd><p> A <code class="reqn">3*3</code> matrix, which rows sum to one, such that the
center of mass of the three column vectors (weighted with <code>wei</code>) is the centroid of the simplex: each column is the center of a Dirichlet mixture component. </p>
</dd>
<dt>wei</dt><dd><p>A vector of length three, summing to one: the mixture weights</p>
</dd>
<dt>lnu</dt><dd><p> A vector of length three: the logarithm of the concentration parameters. </p>
</dd>
</dl>


<hr>
<h2 id='dnestlog'>Pairwise Beta (PB) and Nested Asymmetric Logistic (NL) distributions</h2><span id='topic+dnestlog'></span><span id='topic+dpairbeta'></span><span id='topic+rnestlog'></span><span id='topic+rpairbeta'></span>

<h3>Description</h3>

<p>Likelihood function (spectral density) and random generator in the Pairwise Beta and NL models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dnestlog(
  x = rbind(c(0.1, 0.3, 0.6), c(0.3, 0.3, 0.4)),
  par = c(0.5, 0.5, 0.2, 0.3),
  log = FALSE,
  vectorial = TRUE
)

dpairbeta(
  x,
  par = c(1, rep(2, choose(4, 2) + 1)),
  log = FALSE,
  vectorial = TRUE
)

rnestlog(
  n = 5,
  par = c(0.2, 0.3, 0.4, 0.5),
  threshold = 1000,
  return.points = FALSE
)

rpairbeta(n = 1, dimData = 3, par = c(1, rep(1, 3)))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dnestlog_+3A_x">x</code></td>
<td>
<p>An angular data set (may be reduced to a single point).
A <code>npoints*dimData</code> matrix
(or a vector of length(<code>dimData</code>).
For the NL model, <code>dimData</code> is always <code class="reqn">3</code>. 
Each row is a point on the simplex, so that the sum of each rows
should equal <code class="reqn">1</code> (the error tolerance is set to <code>1e-8</code>
in this package).</p>
</td></tr>
<tr><td><code id="dnestlog_+3A_par">par</code></td>
<td>
<p>The parameter for the Pairwise Beta or the Nested Logistic  density.
</p>

<ul>
<li><p> In the Pairwise Beta model, <code>par</code> is of length
<code>choose(p,2)+1</code>. The first element is the global dependence
parameter, the subsequent ones are the pairwise dependence
parameters, in lexicographic order (<em>e.g.</em>
<code class="reqn">\beta_{12}, \beta_{13}, \beta_{23}</code>).
</p>
</li>
<li><p> In the NL model, <code>par</code> is  a vector of length four  with components between zero and one. The first one is the global dependence parameter, the three subsequent ones are the pairwise dependence parameters, again in lexicographic order. 
</p>
</li></ul>
</td></tr>
<tr><td><code id="dnestlog_+3A_log">log</code></td>
<td>
<p>Logical. Should the density be returned on the log scale ?</p>
</td></tr>
<tr><td><code id="dnestlog_+3A_vectorial">vectorial</code></td>
<td>
<p>Logical.
Should a vector or a single value be returned ?</p>
</td></tr>
<tr><td><code id="dnestlog_+3A_n">n</code></td>
<td>
<p>The number of points on the simplex to be generated.</p>
</td></tr>
<tr><td><code id="dnestlog_+3A_threshold">threshold</code></td>
<td>
<p>The radial threshold <code class="reqn">r</code> above which the simulated points should be kept to build the angular dataset. Should be set to a high value,  for the asymptotic approximation
</p>
<p style="text-align: center;"><code class="reqn">P(W \in B |\; ||X|| &gt;r)\simeq H(B)</code>
</p>
<p> to hold.</p>
</td></tr>
<tr><td><code id="dnestlog_+3A_return.points">return.points</code></td>
<td>
<p>logical: should the censored vectorial dataset corresponding to the angular one be returned ?</p>
</td></tr>
<tr><td><code id="dnestlog_+3A_dimdata">dimData</code></td>
<td>
<p>the dimension of the sample space, which is <code class="reqn">1 + </code> the dimension of the simplex.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Applies to angular data sets. The density is given with respect to the Lebesgue measure on <code class="reqn">R^{p-1}</code>, where <code>p</code> is the number of columns in <code>x</code> (or the length of <code>x</code>, if the latter is a single point).
</p>


<h3>Value</h3>

<p>The value returned by the likelihood function is imposed (see
<em>e.g.</em> <code><a href="#topic+posteriorMCMC">posteriorMCMC</a></code>.
In contrast, the random variable have unconstrained output format.
</p>

<ul>
<li> <p><code>dpairbeta</code> returns the likelihood  as a  single number if <code>vectorial ==FALSE</code>, or as a vector of size <code>nrow(x)</code> containing the likelihood of each angular data point.  If <code>log == TRUE</code>,  the log-likelihood is returned instead.
<code>rpairbeta</code> returns a matrix with <code>n</code>
rows and <code>dimData</code> columns.
</p>
</li>
<li> <p><code>dnestlog</code> returns the likelihood  as a  single number if <code>vectorial ==FALSE</code>, or as a vector of size <code>nrow(x)</code> containing the likelihood of each angular data point.  If <code>log == TRUE</code>,  the log-likelihood is returned instead.
<code>rnestlog</code> returns a matrix with <code>n</code> rows and <code>dimData</code> columns if <code>return.points==FALSE</code> (the default). Otherwise,
a list is returned, with two elements:
</p>

<ul>
<li>  <p><code>Angles</code>: The angular data set
</p>
</li>
<li>   <p><code>Points</code>: The full tri-variate data set above
<code>threshold</code> (<em>i.e.</em> <code>Angles</code>
multiplied by the radial components)
</p>
</li></ul>

</li></ul>


<hr>
<h2 id='dnestlog.grid'>PB and NL spectral  densities on the two-dimensional simplex</h2><span id='topic+dnestlog.grid'></span><span id='topic+dpairbeta.grid'></span>

<h3>Description</h3>

<p>The two functions compute respectively  the NL and PB spectral
densities,  in the three-dimensional case,  on a discretization grid.
A plot is issued (optional).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dnestlog.grid(
  par,
  npoints = 50,
  eps = 0.001,
  equi = TRUE,
  displ = TRUE,
  invisible = TRUE,
  ...
)

dpairbeta.grid(
  par,
  npoints = 50,
  eps = 0.001,
  equi = TRUE,
  displ = TRUE,
  invisible = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dnestlog.grid_+3A_par">par</code></td>
<td>
<p>The parameter for the Pairwise Beta or the Nested Logistic  density.
</p>

<ul>
<li><p> In the Pairwise Beta model, <code>par</code> is of length
<code>choose(p,2)+1</code>. The first element is the global dependence
parameter, the subsequent ones are the pairwise dependence
parameters, in lexicographic order (<em>e.g.</em>
<code class="reqn">\beta_{12}, \beta_{13}, \beta_{23}</code>).
</p>
</li>
<li><p> In the NL model, <code>par</code> is  a vector of length four  with components between zero and one. The first one is the global dependence parameter, the three subsequent ones are the pairwise dependence parameters, again in lexicographic order. 
</p>
</li></ul>
</td></tr>
<tr><td><code id="dnestlog.grid_+3A_npoints">npoints</code></td>
<td>
<p>The number of grid nodes on the squared grid containing the desired triangle.</p>
</td></tr>
<tr><td><code id="dnestlog.grid_+3A_eps">eps</code></td>
<td>
<p>Positive number:  minimum
distance from any node inside the simplex to  the simplex boundary</p>
</td></tr>
<tr><td><code id="dnestlog.grid_+3A_equi">equi</code></td>
<td>
<p>logical. Is the simplex represented as an equilateral triangle (if <code>TRUE</code>) or a right triangle (if <code>FALSE</code>) ?</p>
</td></tr>
<tr><td><code id="dnestlog.grid_+3A_displ">displ</code></td>
<td>
<p>logical. Should a plot be produced ?</p>
</td></tr>
<tr><td><code id="dnestlog.grid_+3A_invisible">invisible</code></td>
<td>
<p>logical. If <code>TRUE</code>, the result is returned as <code>invisible</code>.</p>
</td></tr>
<tr><td><code id="dnestlog.grid_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to <code><a href="#topic+dgridplot">dgridplot</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>npoints*npoints</code> matrix containing the
considered density's values on the grid.
The row (resp. column) indices increase
with  the first (resp. second) coordinate on the simplex.
</p>


<h3>Note</h3>

<p>If <code>equi==TRUE</code>, the density is relative to the Hausdorff
measure on the simplex itself: the values obtained with
<code>equi = FALSE</code> are thus divided by
<code class="reqn">\sqrt 3</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
dpairbeta.grid(par=c( 0.8, 8, 5, 2),
npoints=70, eps = 1e-3, equi = TRUE, displ = TRUE, invisible=TRUE)

##  or ...

Dens &lt;- dpairbeta.grid(par=c(0.8, 8, 5, 2),
npoints=70, eps = 1e-3, equi = TRUE, displ = FALSE)
Grid=discretize(npoints=70,eps=1e-3,equi=TRUE)
dev.new()
image(Grid$X, Grid$Y, Dens)
contour(Grid$X, Grid$Y, Dens, add=TRUE)
add.frame(equi=TRUE, npoints=70, axes=FALSE)


</code></pre>

<hr>
<h2 id='excessProb.condit.dm'>Probability of joint threshold exceedance, in the Dirichlet Mixture model,  given a DM parameter.</h2><span id='topic+excessProb.condit.dm'></span>

<h3>Description</h3>

<p>simple MC integration on the simplex.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>excessProb.condit.dm(
  N = 100,
  par = get("dm.expar.D3k3"),
  thres = rep(100, 3),
  plot = FALSE,
  add = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="excessProb.condit.dm_+3A_n">N</code></td>
<td>
<p>The number of MC iterations to be performed</p>
</td></tr>
<tr><td><code id="excessProb.condit.dm_+3A_par">par</code></td>
<td>
<p>the DM parameter, as a list</p>
</td></tr>
<tr><td><code id="excessProb.condit.dm_+3A_thres">thres</code></td>
<td>
<p>the multivariate threshold</p>
</td></tr>
<tr><td><code id="excessProb.condit.dm_+3A_plot">plot</code></td>
<td>
<p>logical: should convergence diagnostic plots be issued ?</p>
</td></tr>
<tr><td><code id="excessProb.condit.dm_+3A_add">add</code></td>
<td>
<p>logical: should the plot be added to a current one ?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list made of </p>

<dl>
<dt>mean</dt><dd><p>the mean estimate from the MC sample</p>
</dd>
<dt>esterr</dt><dd><p>the estimated standard deviation of the estimator</p>
</dd>
<dt>estsd</dt><dd><p>The estimated standard deviation of the MC sample</p>
</dd>
</dl>


<hr>
<h2 id='excessProb.condit.nl'>Probability of joint threshold excess in the NL model</h2><span id='topic+excessProb.condit.nl'></span>

<h3>Description</h3>

<p>Probability of joint threshold excess in the NL model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>excessProb.condit.nl(par = c(0.3, 0.4, 0.5, 0.6), thres = rep(100, 3))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="excessProb.condit.nl_+3A_par">par</code></td>
<td>
<p>The Nested logistic parameter: of length four.</p>
</td></tr>
<tr><td><code id="excessProb.condit.nl_+3A_thres">thres</code></td>
<td>
<p>a positive vector of size three.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The approximate probability of joint excess, valid when at least one coordinate of <code>thres</code> is large
</p>

<hr>
<h2 id='excessProb.condit.pb'>Estimates the probability of joint excess, given a PB parameter.</h2><span id='topic+excessProb.condit.pb'></span>

<h3>Description</h3>

<p>Simple MC integration on the simplex for joint excess probability,
in the PB model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>excessProb.condit.pb(
  par = c(0.8, 1, 2, 3),
  thres = rep(500, 5),
  precision = 0.1,
  Nmin = 200,
  displ = FALSE,
  add = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="excessProb.condit.pb_+3A_par">par</code></td>
<td>
<p>the DM parameter, as a list</p>
</td></tr>
<tr><td><code id="excessProb.condit.pb_+3A_thres">thres</code></td>
<td>
<p>the multivariate threshold</p>
</td></tr>
<tr><td><code id="excessProb.condit.pb_+3A_precision">precision</code></td>
<td>
<p>The desired relative precision of the estimate.</p>
</td></tr>
<tr><td><code id="excessProb.condit.pb_+3A_nmin">Nmin</code></td>
<td>
<p>The number of MC iterations to be performed</p>
</td></tr>
<tr><td><code id="excessProb.condit.pb_+3A_displ">displ</code></td>
<td>
<p>logical: should convergence diagnostic plots be issued ?</p>
</td></tr>
<tr><td><code id="excessProb.condit.pb_+3A_add">add</code></td>
<td>
<p>logical: should the plot be added to a current one ?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list made of </p>

<dl>
<dt>mean</dt><dd><p>The mean estimate from the MC sample</p>
</dd>
<dt>esterr</dt><dd><p>The estimated standard deviation of the estimator</p>
</dd>
<dt>estsd</dt><dd><p>The estimated standard deviation of the MC sample</p>
</dd>
</dl>


<hr>
<h2 id='excessProb.nl'>Posterior distribution the probability of joint threshold excess, in the NL model.</h2><span id='topic+excessProb.nl'></span>

<h3>Description</h3>

<p>Posterior distribution the probability of joint threshold excess, in the NL model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>excessProb.nl(
  post.sample,
  from = NULL,
  to = NULL,
  thin = 100,
  thres = rep(100, 3),
  known.par = FALSE,
  true.par,
  displ = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="excessProb.nl_+3A_post.sample">post.sample</code></td>
<td>
<p>The posterior sample, as returned by <code>posteriorMCMC</code></p>
</td></tr>
<tr><td><code id="excessProb.nl_+3A_from">from</code></td>
<td>
<p>Integer or <code>NULL</code>. If <code>NULL</code>, the default value is used. Otherwise,  should be greater than <code>post.sample$Nbin</code>. Indicates the  index where the averaging process should start. Default to <code>post.sample$Nbin +1</code></p>
</td></tr>
<tr><td><code id="excessProb.nl_+3A_to">to</code></td>
<td>
<p>Integer or <code>NULL</code>. If <code>NULL</code>, the default
value is used. Otherwise, must be lower than <code>Nsim+1</code>.
Indicates  where the averaging process should stop.
Default to <code>post.sample$Nsim</code>.</p>
</td></tr>
<tr><td><code id="excessProb.nl_+3A_thin">thin</code></td>
<td>
<p>Thinning interval.</p>
</td></tr>
<tr><td><code id="excessProb.nl_+3A_thres">thres</code></td>
<td>
<p>a positive vector of size three.</p>
</td></tr>
<tr><td><code id="excessProb.nl_+3A_known.par">known.par</code></td>
<td>
<p>logical. Is the true parameter known ?</p>
</td></tr>
<tr><td><code id="excessProb.nl_+3A_true.par">true.par</code></td>
<td>
<p>The true parameter, only used  if <code>known.par=TRUE</code></p>
</td></tr>
<tr><td><code id="excessProb.nl_+3A_displ">displ</code></td>
<td>
<p>logical. Should a plot be produced ?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list made of </p>

<dl>
<dt>whole</dt><dd><p>The output of <code>posteriorMean</code> called with <code>FUN=excessProb.condit.nl</code>.</p>
</dd>
<dt>mean</dt><dd><p>The posterior mean of the excess probability</p>
</dd>
<dt>esterr</dt><dd><p>The standard deviation of the mean estimator</p>
</dd>
<dt>estsd</dt><dd><p>The standard deviation of the excess probability,
in the posterior sample. </p>
</dd>
<dt>lowquant</dt><dd><p>The lower 0.1 quantile of the empirical posterior distribution of the excess probability </p>
</dd>
<dt>upquant</dt><dd><p>The upper 0.1 quantile of the empirical posterior distribution of the excess probability </p>
</dd>
<dt>true</dt><dd><p><code>NULL</code> if <code>known.par=FALSE</code>, otherwise the excess probability in the true model.</p>
</dd>
</dl>


<hr>
<h2 id='excessProb.pb'>Estimates the probability of joint excess (Frechet margins)</h2><span id='topic+excessProb.pb'></span>

<h3>Description</h3>

<p>Double Monte-Carlo integration.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>excessProb.pb(
  post.sample,
  Nmin.intern = 100,
  precision = 0.05,
  from = NULL,
  to = NULL,
  thin = 100,
  displ = FALSE,
  thres = rep(500, 5),
  known.par = FALSE,
  true.par
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="excessProb.pb_+3A_post.sample">post.sample</code></td>
<td>
<p>The  posterior sample.</p>
</td></tr>
<tr><td><code id="excessProb.pb_+3A_nmin.intern">Nmin.intern</code></td>
<td>
<p>The minimum number of MC iteration in the internal loop (excess probability, conditional to a parameter).</p>
</td></tr>
<tr><td><code id="excessProb.pb_+3A_precision">precision</code></td>
<td>
<p>The desired precision for the internal MC estimate</p>
</td></tr>
<tr><td><code id="excessProb.pb_+3A_from">from</code></td>
<td>
<p>Integer or <code>NULL</code>. If <code>NULL</code>, the default value is used. Otherwise,  should be greater than <code>post.sample$Nbin</code>. Indicates the  index where the averaging process should start. Default to <code>post.sample$Nbin +1</code></p>
</td></tr>
<tr><td><code id="excessProb.pb_+3A_to">to</code></td>
<td>
<p>Integer or <code>NULL</code>. If <code>NULL</code>, the default
value is used. Otherwise, must be lower than <code>Nsim+1</code>.
Indicates  where the averaging process should stop.
Default to <code>post.sample$Nsim</code>.</p>
</td></tr>
<tr><td><code id="excessProb.pb_+3A_thin">thin</code></td>
<td>
<p>Thinning interval.</p>
</td></tr>
<tr><td><code id="excessProb.pb_+3A_displ">displ</code></td>
<td>
<p>logical. Should a plot be produced ?</p>
</td></tr>
<tr><td><code id="excessProb.pb_+3A_thres">thres</code></td>
<td>
<p>A multivariate threshold</p>
</td></tr>
<tr><td><code id="excessProb.pb_+3A_known.par">known.par</code></td>
<td>
<p>Logical</p>
</td></tr>
<tr><td><code id="excessProb.pb_+3A_true.par">true.par</code></td>
<td>
<p>The true parameter from which the data are issued.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list made of </p>

<dl>
<dt>whole</dt><dd><p> A vector of estimated excess probabilities, one for each element of the thinned posterior sample.</p>
</dd>
<dt>mean</dt><dd><p>the estimated threshold excess probability: mean estimate.</p>
</dd>
<dt>esterr</dt><dd><p>The estimated standard deviation of the mean estimate
(where the Monte-Carlo error is neglected)</p>
</dd>
<dt>estsd</dt><dd><p>The estimated standard deviation of the posterior sample (where the Monte-Carlo error is neglected)</p>
</dd>
<dt>lowquants</dt><dd><p>The three lower <code class="reqn">0.1</code> quantiles of, respectively, the conditional mean estimates and of the upper and lower bounds of the Gaussian (centered) <code class="reqn">80</code> % confidence intervals around the conditional estimates. </p>
</dd>
<dt>upquants</dt><dd><p>The three upper <code class="reqn">0.9</code> quantiles</p>
</dd>
<dt>true.est</dt><dd><p>the mean estimate conditional to the true parameter:
a vector of size three: the mean estimate , and the latter +/- the standard deviation of the estimate</p>
</dd>
</dl>


<hr>
<h2 id='expfunction.nl'>Exponent function in the NL  model.</h2><span id='topic+expfunction.nl'></span>

<h3>Description</h3>

<p>The exponent function <code class="reqn">V</code> for a max-stable variable <code class="reqn">M</code> is such that <code class="reqn">P(M&lt;x) = exp(-V(x))</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expfunction.nl(par = c(0.3, 0.4, 0.5, 0.6), x = 10 * rep(1, 3))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="expfunction.nl_+3A_par">par</code></td>
<td>
<p>The parameter for the NL  distribution,
respectively of length two or four.</p>
</td></tr>
<tr><td><code id="expfunction.nl_+3A_x">x</code></td>
<td>
<p>A vector of three extended positive real numbers</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the value of <code class="reqn">V(x)</code> for <code class="reqn">x=thres</code>.
</p>

<hr>
<h2 id='frechetdat'>Multivariate data set with margins following unit Frechet
distribution.</h2><span id='topic+frechetdat'></span>

<h3>Description</h3>

<p>Five-variate dataset which margins follow unit-Frechet distributions,
obtained from <code><a href="#topic+winterdat">winterdat</a></code> by probability integral
transform.
Marginal estimation was performed by maximum likelihood estimation of a Generalized Pareto distribution over marginal thresholds corresponding to <code class="reqn">0.7</code> quantiles, following 
Cooley <em>et.al.</em> (see reference below). The &ldquo;non extreme&rdquo; part of the marginal distributions was approximated by the empirical distribution function.
</p>


<h3>Format</h3>

<p>A <code class="reqn">601*5</code> - matrix:
</p>


<h3>References</h3>

<p>COOLEY, D., DAVIS, R. and NAVEAU, P. (2010). The pairwise beta distribution: A flexible parametric multivariate model for extremes. <em>Journal of Multivariate Analysis 101, 2103-2117</em>.
</p>

<hr>
<h2 id='invlogit'>Inverse logit transformation</h2><span id='topic+invlogit'></span>

<h3>Description</h3>

<p>Inverse transformation of the <code>logit</code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>invlogit(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="invlogit_+3A_x">x</code></td>
<td>
<p>A real number</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A number between <code class="reqn">0</code> and <code class="reqn">1</code>.
</p>

<hr>
<h2 id='lAccept.ratio'>Acceptance probability in the MCMC algorithm.</h2><span id='topic+lAccept.ratio'></span>

<h3>Description</h3>

<p>Logarithm of the acceptance probability
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lAccept.ratio(
  cur.par,
  prop.par,
  llh.cur,
  lprior.cur,
  dat,
  likelihood,
  proposal,
  prior,
  Hpar,
  MCpar
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lAccept.ratio_+3A_cur.par">cur.par</code></td>
<td>
<p>The current parameter in the Markov chain</p>
</td></tr>
<tr><td><code id="lAccept.ratio_+3A_prop.par">prop.par</code></td>
<td>
<p>The candidate parameter</p>
</td></tr>
<tr><td><code id="lAccept.ratio_+3A_dat">dat</code></td>
<td>
<p>An angular data set, <em>e.g.</em>, constructed by
<code><a href="#topic+cons.angular.dat">cons.angular.dat</a></code>: A matrix which rows are the Cartesian coordinates of points on the unit simplex (summing to one).</p>
</td></tr>
<tr><td><code id="lAccept.ratio_+3A_likelihood">likelihood</code></td>
<td>
<p>The likelihood function.
Should be of type<br />
<code>function(x, par, log, vectorial)</code>, where <code>log</code> and
<code>vectorial</code> are logical flags indicating respectively if
the result is to be  returned on the log-scale, and if the
value is   a vector of length <code>nrow(x)</code> or a single number
(the likelihood, or the log-likelihood, for the data set <code>x</code>).
See <code><a href="#topic+dpairbeta">dpairbeta</a></code> or <code><a href="#topic+dnestlog">dnestlog</a></code>
for templates.</p>
</td></tr>
<tr><td><code id="lAccept.ratio_+3A_proposal">proposal</code></td>
<td>
<p>The proposal function: of type <br />
<code>function(type = c("r","d"),  
cur.par, prop.par, MCpar, log)
</code>.
Should
return the (logarithm of) the proposal density for the move
<code>cur.par --&gt; prop.par</code> if <code>type == "d"</code>. If
<code>type =="r"</code>, <code>proposal</code> must return a candidate
parameter, depending on <code>cur.par</code>, as a vector.
See <code><a href="#topic+proposal.pb">proposal.pb</a></code> or <code><a href="#topic+proposal.nl">proposal.nl</a></code>
for templates.</p>
</td></tr>
<tr><td><code id="lAccept.ratio_+3A_prior">prior</code></td>
<td>
<p>The prior distribution: of type <br />
<code>function(type=c("r","d"), 
n ,par, Hpar, log, dimData
)</code>,
where <code>dimData</code> is the dimension of the sample
space (<em>e.g.</em>, for
the two-dimensional simplex (triangle), <code>dimData=3</code>.
Should return either a matrix with <code>n</code> rows containing a
random parameter sample generated under the prior
(if <code>type == "d"</code>), or the density of the
parameter <code>par</code> (the logarithm of the density if
<code>log==TRUE</code>.
See <code><a href="#topic+prior.pb">prior.pb</a></code> and <code><a href="#topic+prior.nl">prior.nl</a></code> for templates.</p>
</td></tr>
<tr><td><code id="lAccept.ratio_+3A_hpar">Hpar</code></td>
<td>
<p>A list containing  Hyper-parameters to be passed to
<code>prior</code>.</p>
</td></tr>
<tr><td><code id="lAccept.ratio_+3A_mcpar">MCpar</code></td>
<td>
<p>A list containing  MCMC tuning parameters to be
passed to <code>proposal</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>lAccept.ratio</code> is a functional: <code>likelihood,proposal,prior</code> are user defined functions. Should not be called directly, but through the MCMC sampler <code><a href="#topic+posteriorMCMC">posteriorMCMC</a></code> generating the posterior.
</p>


<h3>Value</h3>

<p>The log-acceptance probability.
</p>

<hr>
<h2 id='laplace.evt'>Laplace approximation of  a model marginal likelihood by Laplace approximation.</h2><span id='topic+laplace.evt'></span>

<h3>Description</h3>

<p>Approximation of a model marginal likelihood by Laplace method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>laplace.evt(
  mode = NULL,
  npar = 4,
  likelihood,
  prior,
  Hpar,
  data,
  link,
  unlink,
  method = "L-BFGS-B"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="laplace.evt_+3A_mode">mode</code></td>
<td>
<p>The parameter vector (on the &ldquo;unlinked&rdquo; scale, <em>i.e.</em> before transformation to the real line)
which maximizes the posterior density, or <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="laplace.evt_+3A_npar">npar</code></td>
<td>
<p>The size of the parameter vector. Default to four.</p>
</td></tr>
<tr><td><code id="laplace.evt_+3A_likelihood">likelihood</code></td>
<td>
<p>The likelihood function, <em>e.g.</em> <code><a href="#topic+dpairbeta">dpairbeta</a></code> or <code><a href="#topic+dnestlog">dnestlog</a></code></p>
</td></tr>
<tr><td><code id="laplace.evt_+3A_prior">prior</code></td>
<td>
<p>The prior density (takes an &ldquo;unlinked&rdquo; parameter as argument and returns the density of the <code>linked</code> parameter)</p>
</td></tr>
<tr><td><code id="laplace.evt_+3A_hpar">Hpar</code></td>
<td>
<p>The prior hyper parameter list.</p>
</td></tr>
<tr><td><code id="laplace.evt_+3A_data">data</code></td>
<td>
<p>The angular dataset</p>
</td></tr>
<tr><td><code id="laplace.evt_+3A_link">link</code></td>
<td>
<p>The link function, from the &ldquo;classical&rdquo; or &ldquo;unlinked&rdquo; parametrization onto the real line. (<em>e.g.</em> <code>log</code> for the PB model, an <code>logit</code> for the NL model)</p>
</td></tr>
<tr><td><code id="laplace.evt_+3A_unlink">unlink</code></td>
<td>
<p>The inverse link function (<em>e.g.</em> <code>exp</code> for the PB model and <code>invlogit</code> for the NL model)</p>
</td></tr>
<tr><td><code id="laplace.evt_+3A_method">method</code></td>
<td>
<p>The optimization method to be used. Default to <code>"L-BFGS-B"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The posterior mode is either supplied, or approximated by numerical optimization. For an introduction about Laplace's method, see <em>e.g.</em>
Kass and Raftery, 1995 and the references therein.
</p>


<h3>Value</h3>

<p>A list made of </p>

<dl>
<dt>mode</dt><dd><p>the parameter (on the unlinked scale) deemed to maximize the posterior density. This is equal to the argument if the latter is not null.</p>
</dd>
<dt>value</dt><dd><p>The value of the posterior, evaluated at <code>mode</code>.</p>
</dd>
<dt>laplace.llh</dt><dd><p>The logarithm of the estimated marginal likelihood</p>
</dd>
<dt>invHess</dt><dd><p>The inverse of the estimated hessian matrix at <code>mode</code></p>
</dd>
</dl>



<h3>References</h3>

<p>KASS, R.E. and RAFTERY, A.E. (1995). Bayes Factors.
<em>Journal of the American Statistical Association,
Vol. 90, No.430</em>
</p>

<hr>
<h2 id='Leeds'>Tri-variate &lsquo;angular&rsquo; data set approximately distributed according to a multivariate extremes angular distribution</h2><span id='topic+Leeds'></span>

<h3>Description</h3>

<p>The data set is constructed from coordinates (columns) <code class="reqn">1,2,3</code> of <code><a href="#topic+frechetdat">frechetdat</a></code>.
It contains 100 angular points corresponding to the tri-variate vectors <code class="reqn">V=(X,Y,Z)</code> with largest <code class="reqn">L^1</code> norm (<code class="reqn">||V||=X+Y+Z</code>). The angular points are obtained by &lsquo;normalizing&rsquo;: <em>e.g.</em>,
<code class="reqn">x=X/||V||</code>. Thus, 
each row in <code>Leeds</code> is a point on the two-dimensional simplex : <code class="reqn">x+y+z=1</code>.
</p>


<h3>Format</h3>

<p>A <code class="reqn">100*3</code> - matrix.
</p>


<h3>References</h3>

<p>COOLEY, D., DAVIS, R. and NAVEAU, P. (2010). The pairwise beta distribution: A flexible parametric multivariate model for extremes. <em>Journal of Multivariate Analysis 101, 2103-2117</em>
</p>
<p>RESNICK, S. (1987). Extreme values, regular variation, and point processes, <em>Applied Probability. A, vol. 4, 
Series of the Applied Probability Trust. Springer-Verlag, New York</em>.
</p>

<hr>
<h2 id='Leeds.frechet'>Multivariate data set with margins following unit Frechet distribution.</h2><span id='topic+Leeds.frechet'></span>

<h3>Description</h3>

<p>The data set contains 590 (transformed) daily maxima of five air pollutants recorded in Leeds (U.K.)  during five winter seasons (1994-1998).  Contains NA's. Marginal   transformation to unit Frechet was performed by Cooley   <em>et.al.</em> (see reference below).##' <code class="reqn">x=X/||V||</code>. Thus,
</p>


<h3>Format</h3>

<p>A <code class="reqn">590*5</code> - matrix:
</p>


<h3>References</h3>

<p>COOLEY, D., DAVIS, R. and NAVEAU, P. (2010). The pairwise beta distribution: A flexible parametric multivariate model for extremes. <em>Journal of Multivariate Analysis 101, 2103-2117</em>
</p>

<hr>
<h2 id='logit'>Logit transformation</h2><span id='topic+logit'></span>

<h3>Description</h3>

<p>Bijective Transformation from  <code class="reqn">(0,1)</code> to the real line, defined
by
<code class="reqn">logit(p) = log( p / (1-p) )</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>logit(p)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logit_+3A_p">p</code></td>
<td>
<p>A real number in <code class="reqn">[0,1]</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A real number
</p>

<hr>
<h2 id='marginal.lkl'>Marginal model likelihood</h2><span id='topic+marginal.lkl'></span>

<h3>Description</h3>

<p>Estimates the marginal likelihood of a model, proceeding by simple Monte-Carlo integration under the prior distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>marginal.lkl(
  dat,
  likelihood,
  prior,
  Nsim = 300,
  displ = TRUE,
  Hpar,
  Nsim.min = Nsim,
  precision = 0,
  show.progress = floor(seq(1, Nsim, length.out = 20))
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="marginal.lkl_+3A_dat">dat</code></td>
<td>
<p>The angular data set relative to which the marginal model likelihood is to be computed</p>
</td></tr>
<tr><td><code id="marginal.lkl_+3A_likelihood">likelihood</code></td>
<td>
<p>The likelihood function of the model.
See <code><a href="#topic+posteriorMCMC">posteriorMCMC</a></code> for the required format.</p>
</td></tr>
<tr><td><code id="marginal.lkl_+3A_prior">prior</code></td>
<td>
<p>The prior distribution: of type <br />
<code>function(type=c("r","d"), 
n ,par, Hpar, log, dimData
)</code>,
where <code>dimData</code> is the dimension of the sample
space (<em>e.g.</em>, for
the two-dimensional simplex (triangle), <code>dimData=3</code>.
Should return either a matrix with <code>n</code> rows containing a
random parameter sample generated under the prior
(if <code>type == "d"</code>), or the density of the
parameter <code>par</code> (the logarithm of the density if
<code>log==TRUE</code>.
See <code><a href="#topic+prior.pb">prior.pb</a></code> and <code><a href="#topic+prior.nl">prior.nl</a></code> for templates.</p>
</td></tr>
<tr><td><code id="marginal.lkl_+3A_nsim">Nsim</code></td>
<td>
<p>Total number of iterations to perform.</p>
</td></tr>
<tr><td><code id="marginal.lkl_+3A_displ">displ</code></td>
<td>
<p>logical. If <code>TRUE</code>, a plot is produced, showing the temporal evolution of the cumulative mean, with  approximate confidence intervals of <code class="reqn">+/-2</code>  estimated standard errors.</p>
</td></tr>
<tr><td><code id="marginal.lkl_+3A_hpar">Hpar</code></td>
<td>
<p>A list containing  Hyper-parameters to be passed to
<code>prior</code>.</p>
</td></tr>
<tr><td><code id="marginal.lkl_+3A_nsim.min">Nsim.min</code></td>
<td>
<p>The minimum number of iterations to be performed.</p>
</td></tr>
<tr><td><code id="marginal.lkl_+3A_precision">precision</code></td>
<td>
<p>the desired relative precision. See
<code><a href="#topic+MCpriorIntFun">MCpriorIntFun</a></code>.</p>
</td></tr>
<tr><td><code id="marginal.lkl_+3A_show.progress">show.progress</code></td>
<td>
<p>An vector of integers containing the times
(iteration numbers) at  which a message showing progression
will be printed on the standard output.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function is a wrapper calling  <code><a href="#topic+MCpriorIntFun">MCpriorIntFun</a></code> with parameter <code>FUN</code> set to <code>likelihood</code>.
</p>


<h3>Value</h3>

<p>The list returned by <code><a href="#topic+MCpriorIntFun">MCpriorIntFun</a></code>. The estimate is the list's element  named <code>emp.mean</code>.
</p>


<h3>Note</h3>

<p>The estimated standard deviations of the estimates produced by this function should be handled with care:For &quot;larger&quot; models than the Pairwise Beta or the NL models,
the  likelihood may  have
infinite second moment under the prior distribution.  In such a case, 
it is recommended to resort to more sophisticated integration methods,
<em>e.g.</em> by sampling from a mixture of the prior and the
posterior distributions. See the reference below for more details.
</p>


<h3>References</h3>

<p>KASS, R. and  RAFTERY, A. (1995). Bayes factors. <em>Journal of the american statistical association , 773-795</em>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+marginal.lkl.pb">marginal.lkl.pb</a></code>, <code><a href="#topic+marginal.lkl.nl">marginal.lkl.nl</a></code> for direct  use with  the implemented models.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
  lklNL=  marginal.lkl(dat=Leeds,
                 likelihood=dnestlog,
                 prior=prior.nl,
                 Nsim=20e+3,
                 displ=TRUE,
                 Hpar=nl.Hpar,
                )

## End(Not run)

</code></pre>

<hr>
<h2 id='marginal.lkl.nl'>Marginal likelihoods of the PB and NL models.</h2><span id='topic+marginal.lkl.nl'></span><span id='topic+marginal.lkl.pb'></span>

<h3>Description</h3>

<p>Wrappers for <code><a href="#topic+marginal.lkl">marginal.lkl</a></code>, in the specific cases of the PB and NL models,
with parameter <code>likelihood</code> set to <code>dpairbeta</code> or
<code>dnestlog</code>, and <code>prior</code> set to <code>prior.pb</code> or
<code>prior.nl</code>. See  <code><a href="#topic+MCpriorIntFun">MCpriorIntFun</a></code> for more  details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>marginal.lkl.nl(
  dat,
  Nsim = 10000,
  displ = TRUE,
  Hpar = get("nl.Hpar"),
  Nsim.min = Nsim,
  precision = 0,
  show.progress = floor(seq(1, Nsim, length.out = 20))
)

marginal.lkl.pb(
  dat,
  Nsim = 10000,
  displ = TRUE,
  Hpar = get("pb.Hpar"),
  Nsim.min = Nsim,
  precision = 0,
  show.progress = floor(seq(1, Nsim, length.out = 20))
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="marginal.lkl.nl_+3A_dat">dat</code></td>
<td>
<p>The angular data set relative to which the marginal model likelihood is to be computed</p>
</td></tr>
<tr><td><code id="marginal.lkl.nl_+3A_nsim">Nsim</code></td>
<td>
<p>Total number of iterations to perform.</p>
</td></tr>
<tr><td><code id="marginal.lkl.nl_+3A_displ">displ</code></td>
<td>
<p>logical. If <code>TRUE</code>, a plot is produced, showing the temporal evolution of the cumulative mean, with  approximate confidence intervals of <code class="reqn">+/-2</code>  estimated standard errors.</p>
</td></tr>
<tr><td><code id="marginal.lkl.nl_+3A_hpar">Hpar</code></td>
<td>
<p>A list containing  Hyper-parameters to be passed to
<code>prior</code>.</p>
</td></tr>
<tr><td><code id="marginal.lkl.nl_+3A_nsim.min">Nsim.min</code></td>
<td>
<p>The minimum number of iterations to be performed.</p>
</td></tr>
<tr><td><code id="marginal.lkl.nl_+3A_precision">precision</code></td>
<td>
<p>the desired relative precision. See
<code><a href="#topic+MCpriorIntFun">MCpriorIntFun</a></code>.</p>
</td></tr>
<tr><td><code id="marginal.lkl.nl_+3A_show.progress">show.progress</code></td>
<td>
<p>An vector of integers containing the times
(iteration numbers) at  which a message showing progression
will be printed on the standard output.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The list returned by
<code><a href="#topic+marginal.lkl">marginal.lkl</a></code>, <em>i.e.</em>, the one returned by <code><a href="#topic+MCpriorIntFun">MCpriorIntFun</a></code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+marginal.lkl">marginal.lkl</a></code>, <code><a href="#topic+MCpriorIntFun">MCpriorIntFun</a></code> .
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

marginal.lkl.pb(dat=Leeds ,
         Nsim=20e+3 ,
         displ=TRUE, Hpar = get("pb.Hpar") ,
          )

marginal.lkl.nl(dat=Leeds ,
         Nsim=10e+3 ,
         displ=TRUE, Hpar = get("nl.Hpar") ,
          )

## End(Not run)
</code></pre>

<hr>
<h2 id='maxLikelihood'>Maximum likelihood optimization</h2><span id='topic+maxLikelihood'></span>

<h3>Description</h3>

<p>Maximum likelihood optimization
</p>


<h3>Usage</h3>

<pre><code class='language-R'>maxLikelihood(
  data,
  model,
  init = NULL,
  maxit = 500,
  method = "L-BFGS-B",
  hess = T,
  link,
  unlink
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="maxLikelihood_+3A_data">data</code></td>
<td>
<p>The angular data to be used for inference</p>
</td></tr>
<tr><td><code id="maxLikelihood_+3A_model">model</code></td>
<td>
<p>A list made of </p>

<dl>
<dt>likelihood</dt><dd><p>The likelihood function, see <code><a href="#topic+dpairbeta">dpairbeta</a></code>
for a template</p>
</dd></dl>
<p>.
</p>
<dl>
<dt>npar</dt><dd><p>The length of the parameter vector</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="maxLikelihood_+3A_init">init</code></td>
<td>
<p>NULL or a real vector of size <code>model$npar</code> giving the initial values for <code>link{par}</code>.</p>
</td></tr>
<tr><td><code id="maxLikelihood_+3A_maxit">maxit</code></td>
<td>
<p>maximum number of iterations to be performed by
function <code>optim</code></p>
</td></tr>
<tr><td><code id="maxLikelihood_+3A_method">method</code></td>
<td>
<p>The method to be used by <code>optim</code></p>
</td></tr>
<tr><td><code id="maxLikelihood_+3A_hess">hess</code></td>
<td>
<p>logical: should an approximation of the hessian be performed ?</p>
</td></tr>
<tr><td><code id="maxLikelihood_+3A_link">link</code></td>
<td>
<p>the link function from the natural marginal parameter spaces to the real line.</p>
</td></tr>
<tr><td><code id="maxLikelihood_+3A_unlink">unlink</code></td>
<td>
<p>the inverse link function. If <code>x</code> is any real number, then <code>unlink(x)</code> should be in the admissible range for the likelihood function and the prior function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The list returned by <code>optim</code> and the AIC and BIC criteria
</p>

<hr>
<h2 id='MCpriorIntFun'>Generic Monte-Carlo integration of a function under the prior distribution</h2><span id='topic+MCpriorIntFun'></span>

<h3>Description</h3>

<p>Simple Monte-Carlo sampler approximating the integral of <code>FUN</code> with respect to the prior distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MCpriorIntFun(
  Nsim = 200,
  prior,
  Hpar,
  dimData,
  FUN = function(par, ...) {
     as.vector(par)
 },
  store = TRUE,
  show.progress = floor(seq(1, Nsim, length.out = 20)),
  Nsim.min = Nsim,
  precision = 0,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MCpriorIntFun_+3A_nsim">Nsim</code></td>
<td>
<p>Maximum number of iterations</p>
</td></tr>
<tr><td><code id="MCpriorIntFun_+3A_prior">prior</code></td>
<td>
<p>The prior distribution: of type <br />
<code>function(type=c("r","d"), 
n ,par, Hpar, log, dimData
)</code>,
where <code>dimData</code> is the dimension of the sample
space (<em>e.g.</em>, for
the two-dimensional simplex (triangle), <code>dimData=3</code>.
Should return either a matrix with <code>n</code> rows containing a
random parameter sample generated under the prior
(if <code>type == "d"</code>), or the density of the
parameter <code>par</code> (the logarithm of the density if
<code>log==TRUE</code>.
See <code><a href="#topic+prior.pb">prior.pb</a></code> and <code><a href="#topic+prior.nl">prior.nl</a></code> for templates.</p>
</td></tr>
<tr><td><code id="MCpriorIntFun_+3A_hpar">Hpar</code></td>
<td>
<p>A list containing  Hyper-parameters to be passed to
<code>prior</code>.</p>
</td></tr>
<tr><td><code id="MCpriorIntFun_+3A_dimdata">dimData</code></td>
<td>
<p>The dimension of the model's <em>sample</em> space,
on which the parameter's dimension may depend.
Passed to <code>prior</code> inside <code>MCintegrateFun</code></p>
</td></tr>
<tr><td><code id="MCpriorIntFun_+3A_fun">FUN</code></td>
<td>
<p>A function to be integrated. It may return a vector or an array.</p>
</td></tr>
<tr><td><code id="MCpriorIntFun_+3A_store">store</code></td>
<td>
<p>Should the successive evaluations of <code>FUN</code> be stored ?</p>
</td></tr>
<tr><td><code id="MCpriorIntFun_+3A_show.progress">show.progress</code></td>
<td>
<p>same as in <code><a href="#topic+posteriorMCMC">posteriorMCMC</a></code></p>
</td></tr>
<tr><td><code id="MCpriorIntFun_+3A_nsim.min">Nsim.min</code></td>
<td>
<p>The minimum number of iterations to be performed.</p>
</td></tr>
<tr><td><code id="MCpriorIntFun_+3A_precision">precision</code></td>
<td>
<p>The desired relative precision <code class="reqn">\epsilon</code>.
See <b>Details</b> below.</p>
</td></tr>
<tr><td><code id="MCpriorIntFun_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to <code>FUN</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The algorithm exits after <code class="reqn">n</code> iterations,
based on the following stopping rule :
<code class="reqn">n</code> is the minimum number of iteration, greater than
<code>Nsim.min</code>,  such that the relative
error is less than the specified <code>precision</code>. 
</p>
<p style="text-align: center;"><code class="reqn"> max (est.esterr(n)/ |est.mean(n)| ) \le \epsilon ,</code>
</p>
<p> where
<code class="reqn">est.mean(n)</code> is the estimated mean of <code>FUN</code> at time 
<code class="reqn">n</code>, <code class="reqn">est.err(n)</code> is the estimated  standard
deviation of the estimate:
<code class="reqn">est.err(n) = \sqrt{est.var(n)/(nsim-1)} </code>.
The empirical variance is computed component-wise and the maximum
over the parameters' components is considered.
</p>
<p>The algorithm exits in any case after <code>Nsim</code> iterations, if the above condition is not fulfilled before this time.
</p>


<h3>Value</h3>

<p>A list made of
</p>

<ul>
<li> <p><code>stored.vals</code> : A matrix with <code>nsim</code> rows and
<code>length(FUN(par))</code> columns.
</p>
</li>
<li> <p><code>elapsed</code> : The time elapsed during the computation.
</p>
</li>
<li> <p><code>nsim</code> : The number of iterations performed
</p>
</li>
<li> <p><code>emp.mean</code> : The desired integral estimate: the empirical mean.
</p>
</li>
<li> <p><code>emp.stdev</code> : The empirical standard deviation of the sample.
</p>
</li>
<li> <p><code>est.error</code> : The estimated standard deviation of the estimate (<em>i.e.</em> <code class="reqn">emp.stdev/\sqrt(nsim)</code>).
</p>
</li>
<li> <p><code>not.finite</code> : The number of non-finite values obtained (and discarded) when evaluating <code>FUN(par,...)</code>
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Anne Sabourin
</p>

<hr>
<h2 id='MCpriorIntFun.nl'>Generic Monte-Carlo integration  under the prior distribution in the PB and NL  models.</h2><span id='topic+MCpriorIntFun.nl'></span><span id='topic+MCpriorIntFun.pb'></span>

<h3>Description</h3>

<p>Wrappers for  <code><a href="#topic+MCpriorIntFun">MCpriorIntFun</a></code> with argument
<code>prior=prior.pb</code> or <code>prior=prior.nl</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MCpriorIntFun.nl(
  Nsim = 200,
  FUN = function(par, ...) {
     par
 },
  store = TRUE,
  Hpar = get("nl.Hpar"),
  show.progress = floor(seq(1, Nsim, length.out = 20)),
  Nsim.min = Nsim,
  precision = 0,
  ...
)

MCpriorIntFun.pb(
  Nsim = 200,
  Hpar = get("pb.Hpar"),
  dimData = 3,
  FUN = function(par, ...) {
     as.vector(par)
 },
  store = TRUE,
  show.progress = floor(seq(1, Nsim, length.out = 20)),
  Nsim.min = Nsim,
  precision = 0,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MCpriorIntFun.nl_+3A_nsim">Nsim</code></td>
<td>
<p>Maximum number of iterations</p>
</td></tr>
<tr><td><code id="MCpriorIntFun.nl_+3A_fun">FUN</code></td>
<td>
<p>A function to be integrated. It may return a vector or an array.</p>
</td></tr>
<tr><td><code id="MCpriorIntFun.nl_+3A_store">store</code></td>
<td>
<p>Should the successive evaluations of <code>FUN</code> be stored ?</p>
</td></tr>
<tr><td><code id="MCpriorIntFun.nl_+3A_hpar">Hpar</code></td>
<td>
<p>Hyper-parameters for the PB prior (in <code>MCpriorIntFun.pb</code>) or the  NL prior (<code>MCpriorIntFun.nl</code>). See
<code><a href="#topic+pb.Hpar">pb.Hpar</a></code> and <code><a href="#topic+nl.Hpar">nl.Hpar</a></code> for the required
formats.</p>
</td></tr>
<tr><td><code id="MCpriorIntFun.nl_+3A_show.progress">show.progress</code></td>
<td>
<p>same as in <code><a href="#topic+posteriorMCMC">posteriorMCMC</a></code></p>
</td></tr>
<tr><td><code id="MCpriorIntFun.nl_+3A_nsim.min">Nsim.min</code></td>
<td>
<p>The minimum number of iterations to be performed.</p>
</td></tr>
<tr><td><code id="MCpriorIntFun.nl_+3A_precision">precision</code></td>
<td>
<p>The desired relative precision <code class="reqn">\epsilon</code>.
See <b>Details</b> below.</p>
</td></tr>
<tr><td><code id="MCpriorIntFun.nl_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to <code>FUN</code>.</p>
</td></tr>
<tr><td><code id="MCpriorIntFun.nl_+3A_dimdata">dimData</code></td>
<td>
<p>Only for the PB model: The dimension of model's <em>sample</em> space. The PB parameter  space is of dimension <code>choose(dimData,2)+1</code>. The NL model implemented here is restricted to three-dimensional sample spaces.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The list returned by function
<code><a href="#topic+MCpriorIntFun">MCpriorIntFun</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+MCpriorIntFun">MCpriorIntFun</a></code>
</p>

<hr>
<h2 id='nl.Hpar'>Default hyper-parameters for the NL model.</h2><span id='topic+nl.Hpar'></span>

<h3>Description</h3>

<p>The logit-transformed parameters for the NL model are <em>a priori</em>
Gaussian. The list has the same format as <code><a href="#topic+pb.Hpar">pb.Hpar</a></code>.
</p>


<h3>Format</h3>

<p>A list of four parameters: </p>

<dl>
<dt>mean.alpha, sd.alpha</dt><dd>
<p>Mean and standard deviation of the normal prior distribution for the logit-transformed global dependence parameter <code class="reqn">alpha</code> .
Default to <code class="reqn">0, 3</code>.
</p>
</dd>
<dt>mean.beta, sd.beta</dt><dd><p>Idem for the pairwise dependence parameters.
</p>
</dd>
</dl>


<hr>
<h2 id='nl.MCpar'>Default MCMC tuning parameter for the Nested Asymmetric logistic model.</h2><span id='topic+nl.MCpar'></span>

<h3>Description</h3>

<p>The proposals (on the logit-scale) are Gaussian, centered aroud the current value.
</p>


<h3>Format</h3>

<p>A list made of a single element: <code>sd</code>. The standard deviation of the normal proposition kernel centered at the (logit-transformed)
current state. Default to <code class="reqn">0.35</code>.
</p>

<hr>
<h2 id='pb.Hpar'>Default hyper-parameters for the Pairwise Beta model.</h2><span id='topic+pb.Hpar'></span>

<h3>Description</h3>

<p>The log-transformed dependence parameters are a priori independent, Gausian. This list contains the means and standard deviation for the prior distributions.
</p>


<h3>Format</h3>

<p>A list of four parameters: </p>

<dl>
<dt> mean.alpha</dt><dd>
<p>Mean of the log-transformed global dependence parameter. Default to <code class="reqn">0</code> )
</p>
</dd>
<dt>sd.alpha</dt><dd><p>Standard deviation of the log-transformed global dependence parameter. Default to <code class="reqn">3</code>.
</p>
</dd>
<dt>mean.beta</dt><dd>
<p>Mean of each of the log-transformed pairwise dependence parameters.
Default to <code class="reqn">0</code> )
</p>
</dd>
<dt>sd.beta</dt><dd><p>Standard deviation of each of the log-transformed
pairwise dependence parameters. Default to <code class="reqn">3</code>.
</p>
</dd>
</dl>


<hr>
<h2 id='pb.MCpar'>Default MCMC tuning parameter for the Pairwise Beta model.</h2><span id='topic+pb.MCpar'></span>

<h3>Description</h3>

<p>The proposal for the log-transformed parameters are Gaussian, centered at the current value.
</p>


<h3>Format</h3>

<p>A list made of a single element: <code>sd</code>,
the standard deviation of the normal proposition kernel (on the log-transformed parameter). Default to 
<code class="reqn">0.35</code>.
</p>

<hr>
<h2 id='posterior.predictive.nl'>Posterior predictive densities in the three dimensional
PB, NL and NL3  models</h2><span id='topic+posterior.predictive.nl'></span><span id='topic+posterior.predictive.pb'></span>

<h3>Description</h3>

<p>Wrappers for <code><a href="#topic+posterior.predictive3D">posterior.predictive3D</a></code> in the PB and NL models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>posterior.predictive.nl(
  post.sample,
  from = post.sample$Nbin + 1,
  to = post.sample$Nsim,
  thin = 50,
  npoints = 40,
  eps = 0.001,
  equi = T,
  displ = T,
  ...
)

posterior.predictive.pb(
  post.sample,
  from = post.sample$Nbin + 1,
  to = post.sample$Nsim,
  thin = 50,
  npoints = 40,
  eps = 10^(-3),
  equi = T,
  displ = T,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="posterior.predictive.nl_+3A_post.sample">post.sample</code></td>
<td>
<p>A posterior sample as returned by <code><a href="#topic+posteriorMCMC">posteriorMCMC</a></code></p>
</td></tr>
<tr><td><code id="posterior.predictive.nl_+3A_from">from</code></td>
<td>
<p>Integer or <code>NULL</code>. If <code>NULL</code>, the default value is used. Otherwise,  should be greater than <code>post.sample$Nbin</code>. Indicates the  index where the averaging process should start. Default to <code>post.sample$Nbin +1</code></p>
</td></tr>
<tr><td><code id="posterior.predictive.nl_+3A_to">to</code></td>
<td>
<p>Integer or <code>NULL</code>. If <code>NULL</code>, the default
value is used. Otherwise, must be lower than <code>Nsim+1</code>.
Indicates  where the averaging process should stop.
Default to <code>post.sample$Nsim</code>.</p>
</td></tr>
<tr><td><code id="posterior.predictive.nl_+3A_thin">thin</code></td>
<td>
<p>Thinning interval.</p>
</td></tr>
<tr><td><code id="posterior.predictive.nl_+3A_npoints">npoints</code></td>
<td>
<p>The number of grid nodes on the squared grid containing the desired triangle.</p>
</td></tr>
<tr><td><code id="posterior.predictive.nl_+3A_eps">eps</code></td>
<td>
<p>Positive number:  minimum
distance from any node inside the simplex to  the simplex boundary</p>
</td></tr>
<tr><td><code id="posterior.predictive.nl_+3A_equi">equi</code></td>
<td>
<p>logical. Is the simplex represented as an equilateral triangle (if <code>TRUE</code>) or a right triangle (if <code>FALSE</code>) ?</p>
</td></tr>
<tr><td><code id="posterior.predictive.nl_+3A_displ">displ</code></td>
<td>
<p>logical. Should a plot be produced ?</p>
</td></tr>
<tr><td><code id="posterior.predictive.nl_+3A_...">...</code></td>
<td>
<p>Additional graphical parameters and arguments to be passed
to <code><a href="graphics.html#topic+contour">contour</a></code>  and <code><a href="graphics.html#topic+image">image</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The posterior predictive density is approximated by averaging the densities corresponding to the parameters stored in <code>post.sample</code>. See
<code><a href="#topic+posterior.predictive3D">posterior.predictive3D</a></code> for details.
</p>


<h3>Value</h3>

<p>A <code>npoints*npoints</code> matrix: the posterior predictive density.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+posterior.predictive3D">posterior.predictive3D</a></code>,  <code><a href="#topic+posteriorMCMC.pb">posteriorMCMC.pb</a></code>.
</p>

<hr>
<h2 id='posterior.predictive3D'>Posterior predictive density on the simplex, for three-dimensional extreme value  models.</h2><span id='topic+posterior.predictive3D'></span>

<h3>Description</h3>

<p>Computes an approximation of the predictive density based on a  posterior parameters sample. Only allowed in the three-dimensional case.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>posterior.predictive3D(
  post.sample,
  densityGrid,
  from = post.sample$Nbin + 1,
  to = post.sample$Nsim,
  thin = 40,
  npoints = 40,
  eps = 10^(-3),
  equi = T,
  displ = T,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="posterior.predictive3D_+3A_post.sample">post.sample</code></td>
<td>
<p>A posterior sample as returned by <code><a href="#topic+posteriorMCMC">posteriorMCMC</a></code></p>
</td></tr>
<tr><td><code id="posterior.predictive3D_+3A_densitygrid">densityGrid</code></td>
<td>
<p>A function returning a <code>npoints*npoints</code>
matrix, representing a discretized version of the spectral density
on the two dimensional simplex.
The function should be compatible with <code><a href="#topic+dgridplot">dgridplot</a></code>.
In particular, it must  use <code><a href="#topic+discretize">discretize</a></code> to produce
the discretization grid. It must be of type  <br />
<code>function(par, npoints, eps, equi, displ,invisible,
... )</code>.
See <b>Details</b> below.</p>
</td></tr>
<tr><td><code id="posterior.predictive3D_+3A_from">from</code></td>
<td>
<p>Integer or <code>NULL</code>. If <code>NULL</code>, the default value is used. Otherwise,  should be greater than <code>post.sample$Nbin</code>. Indicates the  index where the averaging process should start. Default to <code>post.sample$Nbin +1</code></p>
</td></tr>
<tr><td><code id="posterior.predictive3D_+3A_to">to</code></td>
<td>
<p>Integer or <code>NULL</code>. If <code>NULL</code>, the default
value is used. Otherwise, must be lower than <code>Nsim+1</code>.
Indicates  where the averaging process should stop.
Default to <code>post.sample$Nsim</code>.</p>
</td></tr>
<tr><td><code id="posterior.predictive3D_+3A_thin">thin</code></td>
<td>
<p>Thinning interval.</p>
</td></tr>
<tr><td><code id="posterior.predictive3D_+3A_npoints">npoints</code></td>
<td>
<p>The number of grid nodes on the squared grid containing the desired triangle.</p>
</td></tr>
<tr><td><code id="posterior.predictive3D_+3A_eps">eps</code></td>
<td>
<p>Positive number:  minimum
distance from any node inside the simplex to  the simplex boundary</p>
</td></tr>
<tr><td><code id="posterior.predictive3D_+3A_equi">equi</code></td>
<td>
<p>logical. Is the simplex represented as an equilateral triangle (if <code>TRUE</code>) or a right triangle (if <code>FALSE</code>) ?</p>
</td></tr>
<tr><td><code id="posterior.predictive3D_+3A_displ">displ</code></td>
<td>
<p>logical. Should a plot be produced ?</p>
</td></tr>
<tr><td><code id="posterior.predictive3D_+3A_...">...</code></td>
<td>
<p>Additional graphical parameters and arguments to be passed
to <code><a href="graphics.html#topic+contour">contour</a></code>  and <code><a href="graphics.html#topic+image">image</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The posterior predictive density is approximated by averaging the
densities produced by the function
<code>densityGrid(par, npoints, eps, equi, displ,invisible, ...)</code> for
<code>par</code> in a  subset of  the parameters sample stored in
<code>post.sample</code>. The arguments of <code>densityGrid</code> must be
</p>

<ul>
<li> <p><code>par</code>:  A vector containing the parameters.
</p>
</li>
<li> <p><code>npoints, eps, equi</code>: Discretization parameters
to be passed to  <code><a href="#topic+dgridplot">dgridplot</a></code>.
</p>
</li>
<li> <p><code>displ</code>:  logical. Should a plot be produced ?
</p>
</li>
<li> <p><code>invisible</code>: logical. Should the result be returned as <code>invisible</code> ?
</p>
</li>
<li> <p><code>...</code> additional arguments to be passed to
<code><a href="#topic+dgridplot">dgridplot</a></code>
</p>
</li></ul>

<p>Only a sub-sample is used: one out of <code>thin</code> parameters is used
(thinning). Further, only the parameters produced between time
<code>from</code> and time <code>to</code> (included) are kept.
</p>


<h3>Value</h3>

<p>A <code>npoints*npoints</code> matrix: the posterior predictive density.
</p>


<h3>Note</h3>

<p>The computational burden may be high: it is proportional to
<code>npoints^2</code>. Therefore, the function assigned to
<code>densityGridplot</code> should be
optimized, typically by calling <code>.C</code> with an internal,
user defined <code>C</code> function.
</p>


<h3>Author(s)</h3>

<p>Anne Sabourin
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dgridplot">dgridplot</a></code>,  <code><a href="#topic+posteriorMCMC">posteriorMCMC</a></code>.
</p>

<hr>
<h2 id='posteriorDistr.bma'>Posterior distribution in the average model</h2><span id='topic+posteriorDistr.bma'></span>

<h3>Description</h3>

<p>Builds an empirical distribution defined as a sum of weighted Dirac masses from posterior samples in individual models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>posteriorDistr.bma(postweights = c(0.5, 0.5), post.distrs = list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="posteriorDistr.bma_+3A_postweights">postweights</code></td>
<td>
<p>a vector of positive real numbers, summing to one: the posterior weights (in the same order as the elements of <code>post.distrs</code>) of the  individual models.</p>
</td></tr>
<tr><td><code id="posteriorDistr.bma_+3A_post.distrs">post.distrs</code></td>
<td>
<p>A list of same length as <code>postweights</code>.
Each element must be a vector which will be used as a posterior sample.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with two rows and as many columns as the sum of the lengths of the elements of <code>post.distrs</code>. The second line contains the weighted  posterior sample in the BMA;  the first line contains the weights to be assigned to each corresponding value on the second one.
</p>

<hr>
<h2 id='posteriorMCMC'>MCMC sampler for parametric spectral measures</h2><span id='topic+posteriorMCMC'></span>

<h3>Description</h3>

<p>Generates a posterior parameters sample, and computes the posterior  mean and component-wise variance on-line.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>posteriorMCMC(
  prior = function(type = c("r", "d"), n, par, Hpar, log, dimData) {
     NULL
 },
  proposal = function(type = c("r", "d"), cur.par, prop.par, MCpar, log) {
     NULL
 },
  likelihood = function(x, par, log, vectorial) {
     NULL
 },
  Nsim,
  dat,
  Hpar,
  MCpar,
  Nbin = 0,
  par.start = NULL,
  show.progress = floor(seq(1, Nsim, length.out = 20)),
  seed = NULL,
  kind = "Mersenne-Twister",
  save = FALSE,
  class = NULL,
  name.save = NULL,
  save.directory = "~",
  name.dat = "",
  name.model = ""
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="posteriorMCMC_+3A_prior">prior</code></td>
<td>
<p>The prior distribution: of type <br />
<code>function(type=c("r","d"), 
n ,par, Hpar, log, dimData
)</code>,
where <code>dimData</code> is the dimension of the sample
space (<em>e.g.</em>, for
the two-dimensional simplex (triangle), <code>dimData=3</code>.
Should return either a matrix with <code>n</code> rows containing a
random parameter sample generated under the prior
(if <code>type == "d"</code>), or the density of the
parameter <code>par</code> (the logarithm of the density if
<code>log==TRUE</code>.
See <code><a href="#topic+prior.pb">prior.pb</a></code> and <code><a href="#topic+prior.nl">prior.nl</a></code> for templates.</p>
</td></tr>
<tr><td><code id="posteriorMCMC_+3A_proposal">proposal</code></td>
<td>
<p>The proposal function: of type <br />
<code>function(type = c("r","d"),  
cur.par, prop.par, MCpar, log)
</code>.
Should
return the (logarithm of) the proposal density for the move
<code>cur.par --&gt; prop.par</code> if <code>type == "d"</code>. If
<code>type =="r"</code>, <code>proposal</code> must return a candidate
parameter, depending on <code>cur.par</code>, as a vector.
See <code><a href="#topic+proposal.pb">proposal.pb</a></code> or <code><a href="#topic+proposal.nl">proposal.nl</a></code>
for templates.</p>
</td></tr>
<tr><td><code id="posteriorMCMC_+3A_likelihood">likelihood</code></td>
<td>
<p>The likelihood function.
Should be of type<br />
<code>function(x, par, log, vectorial)</code>, where <code>log</code> and
<code>vectorial</code> are logical flags indicating respectively if
the result is to be  returned on the log-scale, and if the
value is   a vector of length <code>nrow(x)</code> or a single number
(the likelihood, or the log-likelihood, for the data set <code>x</code>).
See <code><a href="#topic+dpairbeta">dpairbeta</a></code> or <code><a href="#topic+dnestlog">dnestlog</a></code>
for templates.</p>
</td></tr>
<tr><td><code id="posteriorMCMC_+3A_nsim">Nsim</code></td>
<td>
<p>Total number of iterations to perform.</p>
</td></tr>
<tr><td><code id="posteriorMCMC_+3A_dat">dat</code></td>
<td>
<p>An angular data set, <em>e.g.</em>, constructed by
<code><a href="#topic+cons.angular.dat">cons.angular.dat</a></code>: A matrix which rows are the Cartesian coordinates of points on the unit simplex (summing to one).</p>
</td></tr>
<tr><td><code id="posteriorMCMC_+3A_hpar">Hpar</code></td>
<td>
<p>A list containing  Hyper-parameters to be passed to
<code>prior</code>.</p>
</td></tr>
<tr><td><code id="posteriorMCMC_+3A_mcpar">MCpar</code></td>
<td>
<p>A list containing  MCMC tuning parameters to be
passed to <code>proposal</code>.</p>
</td></tr>
<tr><td><code id="posteriorMCMC_+3A_nbin">Nbin</code></td>
<td>
<p>Length of the burn-in period.</p>
</td></tr>
<tr><td><code id="posteriorMCMC_+3A_par.start">par.start</code></td>
<td>
<p>Starting point for the MCMC sampler.</p>
</td></tr>
<tr><td><code id="posteriorMCMC_+3A_show.progress">show.progress</code></td>
<td>
<p>An vector of integers containing the times
(iteration numbers) at  which a message showing progression
will be printed on the standard output.</p>
</td></tr>
<tr><td><code id="posteriorMCMC_+3A_seed">seed</code></td>
<td>
<p>The seed to be set <em>via</em>
<code><a href="base.html#topic+set.seed">set.seed</a></code>.</p>
</td></tr>
<tr><td><code id="posteriorMCMC_+3A_kind">kind</code></td>
<td>
<p>The kind of random numbers generator. Default to
&quot;Mersenne-Twister&quot;. See <code><a href="base.html#topic+set.seed">set.seed</a></code> for details.</p>
</td></tr>
<tr><td><code id="posteriorMCMC_+3A_save">save</code></td>
<td>
<p>Logical. Should the result be saved ?</p>
</td></tr>
<tr><td><code id="posteriorMCMC_+3A_class">class</code></td>
<td>
<p>Optional character string: additional class attribute to be assigned to the result. A predefined class <code>"PBNLpostsample"</code> exists, for which a method performing  convergence diagnostics is defined (see <code><a href="#topic+diagnose">diagnose</a></code> )</p>
</td></tr>
<tr><td><code id="posteriorMCMC_+3A_name.save">name.save</code></td>
<td>
<p>A character string giving the name under which
the result is to be saved. If <code>NULL</code> (default),
nothing is saved. Otherwise, the result is saved in file <br />
<code>paste(save.directory,"/",
name.save,".rda",sep="")</code>.
A &quot;log&quot; list  is also saved,  named <br />
<code>paste(name.save, ".log", sep="")</code>,  in file <br />
<code>paste(save.directory,"/", name.log,".rda",sep="")</code>.</p>
</td></tr>
<tr><td><code id="posteriorMCMC_+3A_save.directory">save.directory</code></td>
<td>
<p>A character string giving the directory where the result is to be saved (without trailing slash).</p>
</td></tr>
<tr><td><code id="posteriorMCMC_+3A_name.dat">name.dat</code></td>
<td>
<p>A character string naming  the data set used for inference. Default to <code>""</code>.</p>
</td></tr>
<tr><td><code id="posteriorMCMC_+3A_name.model">name.model</code></td>
<td>
<p>A character string naming the model. Default to <code>""</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list made of
</p>

<ul>
<li> <p><code>stored.vals</code>: A <code>(Nsim-Nbin)*d</code> matrix, where
<code>d</code>
is the dimension of the parameter space.
</p>
</li>
<li> <p><code>llh</code> A vector of size <code>(Nsim-Nbin)</code> containing the loglikelihoods evaluated at each parameter of the posterior sample.
</p>
</li>
<li> <p><code>lprior</code> A vector of size <code>(Nsim-Nbin)</code> containing the logarithm of the prior densities evaluated at each parameter of the posterior sample.
</p>
</li>
<li> <p><code>elapsed</code>: The time elapsed, as given by
<code>proc.time</code> between the start and the end of the run.
</p>
</li>
<li> <p><code>Nsim</code>: The same as the passed argument
</p>
</li>
<li> <p><code>Nbin</code>: idem.
</p>
</li>
<li><p><code>n.accept</code>: The total number of accepted proposals.
</p>
</li>
<li> <p><code>n.accept.kept</code>: The number of accepted proposals after the burn-in period.
</p>
</li>
<li> <p><code>emp.mean</code> The estimated posterior parameters mean
</p>
</li>
<li> <p><code>emp.sd</code> The empirical posterior sample  standard deviation.</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+posteriorMCMC.pb">posteriorMCMC.pb</a></code>,
<code><a href="#topic+posteriorMCMC.pb">posteriorMCMC.pb</a></code> for specific uses
in the PB and the NL models.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Leeds)
data(pb.Hpar)
data(pb.MCpar)
postsample1 &lt;- posteriorMCMC(Nsim=1e+3,Nbin=500,
         dat= Leeds,
         prior = prior.pb,
         proposal = proposal.pb,
         likelihood = dpairbeta,
         Hpar=pb.Hpar,
         MCpar=pb.MCpar)

dim(postsample1[[1]])
postsample1[-1]

## Not run: 
## a more realistic one:

postsample2 &lt;- posteriorMCMC(Nsim=50e+3,Nbin=15e+3,
         dat= Leeds,
         prior = prior.pb,
         proposal = proposal.pb,
         likelihood = dpairbeta,
         Hpar=pb.Hpar,
         MCpar=pb.MCpar)
dim(postsample2[[1]])
postsample2[-1]

## End(Not run)

</code></pre>

<hr>
<h2 id='posteriorMCMC.nl'>MCMC posterior samplers for the pairwise beta and the negative logistic models.</h2><span id='topic+posteriorMCMC.nl'></span><span id='topic+posteriorMCMC.pb'></span>

<h3>Description</h3>

<p>The functions generate  parameters samples approximating the posterior distribution in the PB model or the NL model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>posteriorMCMC.nl(Nsim, dat, Hpar, MCpar, ...)

posteriorMCMC.pb(Nsim, dat, Hpar, MCpar, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="posteriorMCMC.nl_+3A_nsim">Nsim</code></td>
<td>
<p>Total number of iterations to perform.</p>
</td></tr>
<tr><td><code id="posteriorMCMC.nl_+3A_dat">dat</code></td>
<td>
<p>An angular data set, <em>e.g.</em>, constructed by
<code><a href="#topic+cons.angular.dat">cons.angular.dat</a></code>: A matrix which rows are the Cartesian coordinates of points on the unit simplex (summing to one).</p>
</td></tr>
<tr><td><code id="posteriorMCMC.nl_+3A_hpar">Hpar</code></td>
<td>
<p>A list containing  Hyper-parameters to be passed to
<code>prior</code>.</p>
</td></tr>
<tr><td><code id="posteriorMCMC.nl_+3A_mcpar">MCpar</code></td>
<td>
<p>A list containing  MCMC tuning parameters to be
passed to <code>proposal</code>.</p>
</td></tr>
<tr><td><code id="posteriorMCMC.nl_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to
<code><a href="#topic+posteriorMCMC">posteriorMCMC</a></code> instead of their
default values (must not contain any of
<code>"prior",
"likelihood", "proposal",
"name.model"</code> or <code>"class"</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The two functions are wrappers simplifying the use of
<code><a href="#topic+posteriorMCMC">posteriorMCMC</a></code> for the two models implemented in this package.
</p>


<h3>Value</h3>

<p>an object with class attributes <code>"postsample"</code> and
<code>"PBNLpostsample"</code>: The posterior sample  and some statistics
as returned by function <code><a href="#topic+posteriorMCMC">posteriorMCMC</a></code>
</p>


<h3>Note</h3>

<p>For the Leeds data set, and for simulated data sets with
similar features, setting <code>Nsim=50e+3</code> and <code>Nbin=15e+3</code>
is enough (possibly too much),
with respect to the Heidelberger and Welch tests implemented in
<code><a href="coda.html#topic+heidel.diag">heidel.diag</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+posteriorMCMC">posteriorMCMC</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(Leeds)
data(pb.Hpar)
data(pb.MCpar)
data(nl.Hpar)
data(nl.MCpar)
pPB &lt;- posteriorMCMC.pb(Nsim=5e+3, dat=Leeds, Hpar=pb.Hpar,
MCpar=pb.MCpar)

dim(pPB[1])
pPB[-(1:3)]

pNL &lt;- posteriorMCMC.nl(Nsim=5e+3, dat=Leeds, Hpar=nl.Hpar,
MCpar=nl.MCpar)

dim(pNL[1])
pNL[-(1:3)]

## End(Not run)
</code></pre>

<hr>
<h2 id='posteriorMean'>Posterior predictive density on the simplex, for three-dimensional extreme value  models.</h2><span id='topic+posteriorMean'></span>

<h3>Description</h3>

<p>Computes an approximation of the posterior mean of a parameter functional, based on a  posterior parameters sample.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>posteriorMean(
  post.sample,
  FUN = function(par, ...) {
     par
 },
  from = NULL,
  to = NULL,
  thin = 50,
  displ = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="posteriorMean_+3A_post.sample">post.sample</code></td>
<td>
<p>A posterior sample as returned by <code><a href="#topic+posteriorMCMC">posteriorMCMC</a></code></p>
</td></tr>
<tr><td><code id="posteriorMean_+3A_fun">FUN</code></td>
<td>
<p>a parameter functional returning a vector.</p>
</td></tr>
<tr><td><code id="posteriorMean_+3A_from">from</code></td>
<td>
<p>Integer or <code>NULL</code>. If <code>NULL</code>, the default value is used. Otherwise,  should be greater than <code>post.sample$Nbin</code>. Indicates the  index where the averaging process should start. Default to <code>post.sample$Nbin +1</code></p>
</td></tr>
<tr><td><code id="posteriorMean_+3A_to">to</code></td>
<td>
<p>Integer or <code>NULL</code>. If <code>NULL</code>, the default
value is used. Otherwise, must be lower than <code>Nsim+1</code>.
Indicates  where the averaging process should stop.
Default to <code>post.sample$Nsim</code>.</p>
</td></tr>
<tr><td><code id="posteriorMean_+3A_thin">thin</code></td>
<td>
<p>Thinning interval.</p>
</td></tr>
<tr><td><code id="posteriorMean_+3A_displ">displ</code></td>
<td>
<p>logical. Should a plot be produced ?</p>
</td></tr>
<tr><td><code id="posteriorMean_+3A_...">...</code></td>
<td>
<p>Additional parameters to be passed to <code>FUN</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Only a sub-sample is used: one out of <code>thin</code> parameters is used
(thinning). Further, only the parameters produced between time
<code>from</code> and time <code>to</code> (included) are kept.
</p>


<h3>Value</h3>

<p>A list made of </p>

<dl>
<dt>values</dt><dd><p>A matrix : each column is the result of <code>FUN</code> applied to a parameter from the posterior sample.</p>
</dd>
<dt>est.mean</dt><dd><p>The posterior mean</p>
</dd>
<dt>est.sd</dt><dd><p>The posterior standard deviation </p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+posteriorMCMC">posteriorMCMC</a></code>.
</p>

<hr>
<h2 id='posteriorWeights'>Posterior model weights</h2><span id='topic+posteriorWeights'></span>

<h3>Description</h3>

<p>Approximates the models' posterior weights  by simple Monte Carlo integration
</p>


<h3>Usage</h3>

<pre><code class='language-R'>posteriorWeights(
  dat,
  HparList = list(get("pb.Hpar"), get("nl.Hpar")),
  lklList = list(get("dpairbeta"), get("dnestlog")),
  priorList = list(get("prior.pb"), get("prior.nl")),
  priorweights = c(0.5, 0.5),
  Nsim = 20000,
  Nsim.min = 10000,
  precision = 0.05,
  seed = 1,
  kind = "Mersenne-Twister",
  show.progress = floor(seq(1, Nsim, length.out = 10)),
  displ = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="posteriorWeights_+3A_dat">dat</code></td>
<td>
<p>The angular data set relative to which the marginal model likelihood is to be computed</p>
</td></tr>
<tr><td><code id="posteriorWeights_+3A_hparlist">HparList</code></td>
<td>
<p>A list containing the hyper Parameter for the priors in each model. (list of lists).</p>
</td></tr>
<tr><td><code id="posteriorWeights_+3A_lkllist">lklList</code></td>
<td>
<p>A list containing the likelihood functions of each model</p>
</td></tr>
<tr><td><code id="posteriorWeights_+3A_priorlist">priorList</code></td>
<td>
<p>A list containing the prior definitions of each model.</p>
</td></tr>
<tr><td><code id="posteriorWeights_+3A_priorweights">priorweights</code></td>
<td>
<p>A vector of positive weights, summing to one: the prior marginal weights of each model.</p>
</td></tr>
<tr><td><code id="posteriorWeights_+3A_nsim">Nsim</code></td>
<td>
<p>The maximum number of iterations to be performed.</p>
</td></tr>
<tr><td><code id="posteriorWeights_+3A_nsim.min">Nsim.min</code></td>
<td>
<p>The minimum number of iterations to be performed.</p>
</td></tr>
<tr><td><code id="posteriorWeights_+3A_precision">precision</code></td>
<td>
<p>the desired relative precision. See
<code><a href="#topic+MCpriorIntFun">MCpriorIntFun</a></code>.</p>
</td></tr>
<tr><td><code id="posteriorWeights_+3A_seed">seed</code></td>
<td>
<p>The seed to be set <em>via</em>
<code><a href="base.html#topic+set.seed">set.seed</a></code>.</p>
</td></tr>
<tr><td><code id="posteriorWeights_+3A_kind">kind</code></td>
<td>
<p>The kind of random numbers generator. Default to
&quot;Mersenne-Twister&quot;. See <code><a href="base.html#topic+set.seed">set.seed</a></code> for details.</p>
</td></tr>
<tr><td><code id="posteriorWeights_+3A_show.progress">show.progress</code></td>
<td>
<p>An vector of integers containing the times
(iteration numbers) at  which a message showing progression
will be printed on the standard output.</p>
</td></tr>
<tr><td><code id="posteriorWeights_+3A_displ">displ</code></td>
<td>
<p>Logical. Should convergence monitoring plots be issued ?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>if <code class="reqn">J</code> is the number of models, the posterior weights are given by
</p>
<p style="text-align: center;"><code class="reqn">postW(i) = priorW(i)*lkl(i)/
(\sum_{j=1,\dots,J} priorW(j)*lkl(j)),</code>
</p>

<p>where <code class="reqn">lkl(i)</code> stands for the Monte-Carlo estimate of the
marginal likelihood of model <code class="reqn">i</code> and <code class="reqn">priorW(i)</code> is
the prior weight
defined in <code>priorweights[i]</code>. For more explanations, see the reference below 
The confidence intervals are obtained by adding/subtracting two times the estimated standard errors of the marginal likelihood estimates.
The latter are only estimates, which interpretation may be misleading:
See the note in section <code><a href="#topic+marginal.lkl">marginal.lkl</a></code>
</p>


<h3>Value</h3>

<p>A matrix of <code class="reqn">6</code> columns and <code>length(priorweights)</code> rows. The columns contain respectively the posterior model weights (in the same order as in <code>priorweights</code>), the lower and the upper bound of the confidence interval (see <b>Details</b>), the marginal model weights, the estimated standard error of the marginal likelihood estimators, and the number of simulations performed.
</p>


<h3>References</h3>

<p>HOETING, J., MADIGAN, D., RAFTERY, A. and VOLINSKY, C. (1999). Bayesian model averaging: A tutorial. <em>Statistical science 14, 382-401</em>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(pb.Hpar)
data(nl.Hpar)
set.seed(5)
mixDat=rbind(rpairbeta(n=10,dimData=3, par=c(0.68,3.1,0.5,0.5)),
  rnestlog(n=10,par=c(0.68,0.78, 0.3,0.5)))
posteriorWeights (dat=mixDat,
                  HparList=list(get("pb.Hpar"),get("nl.Hpar")),
                  lklList=list(get("dpairbeta"), get("dnestlog")),
                  priorList=list(get("prior.pb"), get("prior.nl")),
                  priorweights=c(0.5,0.5),
                  Nsim=1e+3,
                  Nsim.min=5e+2, precision=0.1,
                  displ=FALSE)
## Not run: posteriorWeights (dat=mixDat,
                  HparList=list(get("pb.Hpar"),get("nl.Hpar")),
                  lklList=list(get("dpairbeta"), get("dnestlog")),
                  priorList=list(get("prior.pb"), get("prior.nl")),
                  priorweights=c(0.5,0.5),
                  Nsim=20e+3,
                  Nsim.min=10e+3, precision=0.05,
                  displ=TRUE)
## End(Not run)
</code></pre>

<hr>
<h2 id='prior.nl'>Prior parameter distribution for the NL  model</h2><span id='topic+prior.nl'></span>

<h3>Description</h3>

<p>Density and generating function of the prior distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prior.nl(type = c("r", "d"), n, par, Hpar, log, dimData = 3)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prior.nl_+3A_type">type</code></td>
<td>
<p>One of the character strings <code>"r"</code>, <code>"d"</code></p>
</td></tr>
<tr><td><code id="prior.nl_+3A_n">n</code></td>
<td>
<p>The number of parameters to be generated. Only used
if <code>type == "r"</code>.</p>
</td></tr>
<tr><td><code id="prior.nl_+3A_par">par</code></td>
<td>
<p>A vector of length four, with component comprised
between <code class="reqn">0</code> and <code class="reqn">1</code> (both end points excluded for the first
element and <code class="reqn">1</code> included for the others):
The parameter where
the density is to be taken.
Only used if <code>type=="d"</code>.
</p>
<p>In the NL model,
<code>par</code> is of length <code class="reqn">4</code>.
The first element is the global dependence
parameter, the others  are  partial dependence parameter between pairs (12), (13), (23) respectively.
</p>
<p>In the NL model,
<code>par</code> is of length <code class="reqn">4</code>.
The first element has the same interpretation as in the NL model, the subsequent ones are dependence parameters between</p>
</td></tr>
<tr><td><code id="prior.nl_+3A_hpar">Hpar</code></td>
<td>
<p>list of Hyper-parameters : see <code><a href="#topic+nl.Hpar">nl.Hpar</a></code> for a template.</p>
</td></tr>
<tr><td><code id="prior.nl_+3A_log">log</code></td>
<td>
<p>logical. Should the density be returned on the log scale ?
Only used if <code>type=="d"</code></p>
</td></tr>
<tr><td><code id="prior.nl_+3A_dimdata">dimData</code></td>
<td>
<p>The dimension of the sample space, equal to <code class="reqn">3</code>.
Only for compatibility with <em>e.g.</em> <code><a href="#topic+posteriorMCMC">posteriorMCMC</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The four  parameters are independent, the logit-transformed parameters follow a normal distribution.
</p>


<h3>Value</h3>

<p>Either a matrix with <code>n</code> rows containing a random parameter sample generated under the prior (if type == &quot;d&quot;), or the (log)-density of the parameter <code>par</code>.
</p>


<h3>Author(s)</h3>

<p>Anne Sabourin
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: prior.nl(type="r", n=5 ,Hpar=get("nl.Hpar")) 

## Not run: prior.trinl(type="r", n=5 ,Hpar=get("nl.Hpar")) 
## Not run: prior.pb(type="d", par=rep(0.5,2), Hpar=get("nl.Hpar")) 
</code></pre>

<hr>
<h2 id='prior.pb'>Prior parameter distribution for the Pairwise Beta model</h2><span id='topic+prior.pb'></span>

<h3>Description</h3>

<p>Density and generating function of the prior distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prior.pb(type = c("r", "d"), n, par, Hpar, log, dimData)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prior.pb_+3A_type">type</code></td>
<td>
<p>One of the character strings <code>"r"</code>, <code>"d"</code></p>
</td></tr>
<tr><td><code id="prior.pb_+3A_n">n</code></td>
<td>
<p>The number of parameters to be generated. Only used
if <code>type == "r"</code>.</p>
</td></tr>
<tr><td><code id="prior.pb_+3A_par">par</code></td>
<td>
<p>A vector with positive components:
The parameter where the density is to be taken.
Only used if <code>type=="d"</code>. In the Pairwise Beta model,
<code>par</code> is of length
<code>choose(p,2)+1</code>. The first element is the global dependence
parameter, the subsequent ones are the pairwise dependence
parameters, in lexicographic order (<em>e.g.</em>
<code class="reqn">\beta_{1,2}, \beta_{1,3}, \beta_{2,3}</code>.</p>
</td></tr>
<tr><td><code id="prior.pb_+3A_hpar">Hpar</code></td>
<td>
<p>list of Hyper-parameters : see <code><a href="#topic+pb.Hpar">pb.Hpar</a></code> for a template.</p>
</td></tr>
<tr><td><code id="prior.pb_+3A_log">log</code></td>
<td>
<p>logical. Should the density be returned on the log scale ?
Only used if <code>type=="d"</code></p>
</td></tr>
<tr><td><code id="prior.pb_+3A_dimdata">dimData</code></td>
<td>
<p>The dimension of the sample space. (one more than the dimension of the simplex)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The parameters components are independent, log-normal.
</p>


<h3>Value</h3>

<p>Either a matrix with <code>n</code> rows containing a random parameter sample generated under the prior (if type == &quot;d&quot;), or the (log)-density of the parameter <code>par</code>.
</p>


<h3>Author(s)</h3>

<p>Anne Sabourin
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: prior.pb(type="r", n=5 ,Hpar=get("pb.Hpar"), dimData=3 ) 
## Not run: prior.pb(type="d", par=rep(1,choose(4,2), Hpar=get("pb.Hpar"), dimData=4 ) 
</code></pre>

<hr>
<h2 id='proposal.nl'>NL3  model: proposal distribution.</h2><span id='topic+proposal.nl'></span>

<h3>Description</h3>

<p>Density of the proposal distribution <code>q(cur.par,prop.par)</code> and random generator for MCMC algorithm in the NL3 model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>proposal.nl(
  type = c("r", "d"),
  cur.par,
  prop.par,
  MCpar = get("nl.MCpar"),
  log = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="proposal.nl_+3A_type">type</code></td>
<td>
<p>One of the character strings <code>"r"</code> or <code>"d"</code>.</p>
</td></tr>
<tr><td><code id="proposal.nl_+3A_cur.par">cur.par</code></td>
<td>
<p>Current state of the chain.</p>
</td></tr>
<tr><td><code id="proposal.nl_+3A_prop.par">prop.par</code></td>
<td>
<p>Candidate parameter.</p>
</td></tr>
<tr><td><code id="proposal.nl_+3A_mcpar">MCpar</code></td>
<td>
<p>A list made of a single element: MCMC parameter. Re-centering parameter for the proposal distribution.</p>
</td></tr>
<tr><td><code id="proposal.nl_+3A_log">log</code></td>
<td>
<p>Logical. Only used when <code>type =="d"</code>. Should the result be returned on the log-scale ?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The two components of proposal parameter
<code>(alpha*, beta12*, beta13*, beta23*)</code>  are generated independently, under a beta distribution with mode at the current parameter's value. 
</p>
<p>Let  <code class="reqn">\epsilon =</code> <code>MCpar$eps.recentre</code>. To generate <code>alpha*</code>, given the current state <code>alpha(t)</code>,
let <code class="reqn">m(t) = \epsilon /2 + (1-\epsilon) * \alpha(t)</code> be the mean
of the Beta proposal distribution  and <code class="reqn">\lambda = 2/\epsilon</code>
(a scaling constant). Then
</p>
<p style="text-align: center;"><code class="reqn">
\alpha^* \sim  \textrm{Beta}(\lambda m(t), (1-\lambda) m(t))</code>
</p>

<p>The  <code>betaij*</code>'s are generated similarly.
</p>


<h3>Value</h3>

<p>Either the (log-)density of the proposal parameter <code>prop.par</code>, given <code>cur.par</code> (if <code>type == "d"</code>), or a proposal  parameter (a vector), if <code>type =="r"</code>.
</p>

<hr>
<h2 id='proposal.pb'>PB model: proposal distribution</h2><span id='topic+proposal.pb'></span>

<h3>Description</h3>

<p>Density of the proposal distribution <code>q(cur.par,prop.par)</code> and random generator for MCMC algorithm in the PB model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>proposal.pb(type = c("r", "d"), cur.par, prop.par, MCpar, log = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="proposal.pb_+3A_type">type</code></td>
<td>
<p>One of the character strings <code>"r"</code>, <code>"d"</code></p>
</td></tr>
<tr><td><code id="proposal.pb_+3A_cur.par">cur.par</code></td>
<td>
<p>Current state of the chain</p>
</td></tr>
<tr><td><code id="proposal.pb_+3A_prop.par">prop.par</code></td>
<td>
<p>Candidate parameter</p>
</td></tr>
<tr><td><code id="proposal.pb_+3A_mcpar">MCpar</code></td>
<td>
<p>A list made of a single element: MCMC parameter for the standard deviation of the log-normal proposition, on the log scale. See <code><a href="#topic+pb.MCpar">pb.MCpar</a></code> for the default value</p>
</td></tr>
<tr><td><code id="proposal.pb_+3A_log">log</code></td>
<td>
<p>Logical. Only used when <code>type =="d"</code>. Should the result be returned on the log-scale ?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The components <code>prop.par[i]</code> of the proposal parameter are generated independently, from the lognormal distribution:
</p>
<p><code>prop.par = rlnorm(length(cur.par), meanlog=log(cur.par),
sdlog=rep(MCpar$sdlog,length(cur.par)))</code>
</p>


<h3>Value</h3>

<p>Either the (log-)density of the proposal <code>prop.par</code>, given <code>cur.par</code> (if <code>type == "d"</code>), or a proposal  parameter (a vector), if <code>type =="r"</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run:  proposal.pb(type = "r",
cur.par = rep(1,4), MCpar=get("pb.MCpar"))

## End(Not run)
## Not run:  proposal.pb(type = "d", cur.par = rep(1,4),
prop.par=rep(1.5,4), MCpar=get("pb.MCpar"))

## End(Not run)
</code></pre>

<hr>
<h2 id='rdirichlet'>Dirichlet distribution: random generator</h2><span id='topic+rdirichlet'></span>

<h3>Description</h3>

<p>Dirichlet distribution: random generator
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rdirichlet(n = 1, alpha)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rdirichlet_+3A_n">n</code></td>
<td>
<p>Number of draws</p>
</td></tr>
<tr><td><code id="rdirichlet_+3A_alpha">alpha</code></td>
<td>
<p>Dirichlet parameter: a vector of positive number</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with <code>n</code> rows and <code>length(alpha)</code> columns
</p>

<hr>
<h2 id='rect.integrate'>Density integration on the two-dimensional simplex</h2><span id='topic+rect.integrate'></span>

<h3>Description</h3>

<p>The integral is approximated by a rectangular method, using the values stored in matrix <code>density</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rect.integrate(density, npoints, eps)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rect.integrate_+3A_density">density</code></td>
<td>
<p>A <code>npoints*npoints</code> matrix containing the
density's values  scattered on the discretization grid defined by
<code>npoints, equi, eps</code> (see <code><a href="#topic+discretize">discretize</a></code>).</p>
</td></tr>
<tr><td><code id="rect.integrate_+3A_npoints">npoints</code></td>
<td>
<p>The number of grid nodes on the squared grid containing the desired triangle.</p>
</td></tr>
<tr><td><code id="rect.integrate_+3A_eps">eps</code></td>
<td>
<p>Positive number:  minimum
distance from any node inside the simplex to  the simplex boundary</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Integration is made with respect to the Lebesgue measure on the projection of the simplex onto the plane <code class="reqn">(x,y): x &gt; 0, y &gt; 0, x+y &lt; 1</code>.
It is assumed that <code>density</code> has been constructed on a
grid obtained <em>via</em> function  <code><a href="#topic+discretize">discretize</a></code>,
with  argument <code>equi</code> set to <code>FALSE</code> and <code>npoints</code>
and <code>eps</code> equal to those passed to <code>rect.integrate</code>.
</p>


<h3>Value</h3>

<p>The value of the estimated integral of <code>density</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>wrapper &lt;- function(x, y, my.fun,...)
  {
    sapply(seq_along(x), FUN = function(i) my.fun(x[i], y[i],...))
  }

grid &lt;- discretize(npoints=40,eps=1e-3,equi=FALSE)

Density &lt;- outer(grid$X,grid$Y,FUN=wrapper,
                                 my.fun=function(x,y){10*((x/2)^2+y^2)})

rect.integrate(Density,npoints=40,eps=1e-3)

</code></pre>

<hr>
<h2 id='rstable.posit'>Positive alpha-stable distribution.</h2><span id='topic+rstable.posit'></span>

<h3>Description</h3>

<p>Random variable generator
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rstable.posit(alpha = 0.5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rstable.posit_+3A_alpha">alpha</code></td>
<td>
<p>The parameter of the alpha-stable random variable</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An alpha-stable random variable <code class="reqn">S</code> with index <code class="reqn">\alpha</code> is
defined by its  Laplace transform
<code class="reqn">E(exp(tS))) = exp(-t^\alpha)</code>. The algorithm used here is directly derived from Stephenson (2003).
</p>


<h3>Value</h3>

<p>A realization of the alpha-stable random variable.
</p>


<h3>References</h3>

<p>STEPHENSON, A. (2003). Simulating multivariate extreme value distributions of logistic type. <em>Extremes 6, 49-59</em>.
</p>

<hr>
<h2 id='scores3D'>Logarithmic score and <code class="reqn">L^2</code> distance  between two densities on the simplex (trivariate case).</h2><span id='topic+scores3D'></span>

<h3>Description</h3>

<p>Computes the Kullback-Leibler divergence and the <code class="reqn">L^2</code> distance between the &quot;true&quot; density (<code>true.dens</code>) and an estimated density (<code>est.dens</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scores3D(true.dens, est.dens, npoints, eps)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scores3D_+3A_true.dens">true.dens</code></td>
<td>
<p>A <code>npoints*npoints</code> matrix: The reference density, typically the distribution from which data was simulated. Must be a valid <code>density</code> argument to be passed to <code>dgridplot</code>, with <code>equi=FALSE</code>.</p>
</td></tr>
<tr><td><code id="scores3D_+3A_est.dens">est.dens</code></td>
<td>
<p>The estimated density: of the same type as <code>true.dens</code>.</p>
</td></tr>
<tr><td><code id="scores3D_+3A_npoints">npoints</code></td>
<td>
<p>Number of grid points  used to construct the density matrices (see <code><a href="#topic+discretize">discretize</a></code>).</p>
</td></tr>
<tr><td><code id="scores3D_+3A_eps">eps</code></td>
<td>
<p>Minimum distance from a grid point to the simplex boundary (see <code><a href="#topic+discretize">discretize</a></code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The integration is made <em>via</em> <code><a href="#topic+rect.integrate">rect.integrate</a></code>: The discretization grid corresponding to the two matrices must be constructed
with <code>discretize(npoints, eps, equi=FALSE)</code>.
</p>


<h3>Value</h3>

<p>A list made of
</p>

<ul>
<li> <p><code>check.true</code>: The result of the rectangular integration of
<code>true.dens</code>. It should be equal to one. If not, re size the grid.
</p>
</li>
<li> <p><code>check.true</code>:
Idem, replacing <code>true.dens</code> with <code>est.dens</code>.
</p>
</li>
<li> <p><code>L2score</code>: The estimated <code class="reqn">L^2</code> distance.
</p>
</li>
<li> <p><code>KLscore</code>: The estimated Kullback-Leibler divergence between the two re-normalized densities, using <code>check.true</code> and <code>check.est</code> as normalizing constants (this ensures that the divergence is always positive). 
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>dens1=dpairbeta.grid(par=c(0.8,2,5,8),npoints=150,eps=1e-3,
                     equi=FALSE)
dens2=dnestlog.grid(par=c(0.5,0.8,0.4,0.6),npoints=150,eps=1e-3, equi=FALSE)

scores3D(true.dens=dens1,
  est.dens=dens2,
  npoints=150, eps=1e-4)

</code></pre>

<hr>
<h2 id='transf.to.equi'>Linear coordinate transformations</h2><span id='topic+transf.to.equi'></span><span id='topic+transf.to.rect'></span>

<h3>Description</h3>

<p>Switching coordinates system  between equilateral and right-angled
representation of the two-dimensional simplex.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>transf.to.equi(vect)

transf.to.rect(vect)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="transf.to.equi_+3A_vect">vect</code></td>
<td>
<p>a bi-variate vector, giving the first two coordinates of the angular point to be transformed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If  <code>transf.to.rect</code>, is called, <code>vect</code> must belongs to  the triangle <code class="reqn">[(0,0), (\sqrt(2), 0), (\sqrt(2)/2,\sqrt(3/2) ) ]</code>
and the result lies in <code class="reqn">([(0,0), (1,0), (0,1)]</code>. <code>transf.to.equi</code> is the reciprocal.
</p>


<h3>Value</h3>

<p>The vector obtained by linear transformation.
</p>


<h3>Author(s)</h3>

<p>Anne Sabourin
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run:  transf.to.equi(c(sqrt(2)/2, sqrt(3/8) ) )
</code></pre>

<hr>
<h2 id='winterdat'>Five-dimensional air quality dataset recorded in Leeds(U.K.), during five winter seasons.</h2><span id='topic+winterdat'></span>

<h3>Description</h3>

<p>Contains 590 daily maxima of five air pollutants
(respectively PM10, N0, NO2, 03, S02) recorded in Leeds (U.K.)
during five winter seasons (1994-1998, November-February included). Contains NA's.
</p>


<h3>Format</h3>

<p>A <code class="reqn">590*5</code> matrix.
</p>


<h3>Source</h3>

<p><a href="https://uk-air.defra.gov.uk/">https://uk-air.defra.gov.uk/</a>
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
