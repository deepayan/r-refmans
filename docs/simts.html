<!DOCTYPE html><html><head><title>Help for package simts</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {simts}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#simts-package'><p>simts: Time Series Analysis Tools</p></a></li>
<li><a href='#.acf'><p>Auto-Covariance and Correlation Functions</p></a></li>
<li><a href='#[.imu'><p>Subset an IMU Object</p></a></li>
<li><a href='#*.ts.model'><p>Multiple a ts.model by constant</p></a></li>
<li><a href='#+.ts.model'><p>Add ts.model objects together</p></a></li>
<li><a href='#acf_sum'><p>Helper Function for ARMA to WV Approximation</p></a></li>
<li><a href='#AIC.fitsimts'><p>Akaike's Information Criterion</p></a></li>
<li><a href='#all_bootstrapper'><p>Bootstrap for Everything!</p></a></li>
<li><a href='#AR'><p>Create an Autoregressive P [AR(P)] Process</p></a></li>
<li><a href='#AR1'><p>Definition of an Autoregressive Process of Order 1</p></a></li>
<li><a href='#ar1_draw'><p>Randomly guess starting parameters for AR1</p></a></li>
<li><a href='#ar1_to_gm'><p>Transform AR1 to GM</p></a></li>
<li><a href='#ar1_to_wv'><p>AR(1) process to WV</p></a></li>
<li><a href='#ARIMA'><p>Create an Autoregressive Integrated Moving Average (ARIMA) Process</p></a></li>
<li><a href='#ARMA'><p>Create an Autoregressive Moving Average (ARMA) Process</p></a></li>
<li><a href='#arma_adapter'><p>ARMA Adapter to ARMA to WV Process function</p></a></li>
<li><a href='#arma_draws'><p>Randomly guess starting parameters for ARMA</p></a></li>
<li><a href='#arma_to_wv'><p>ARMA process to WV</p></a></li>
<li><a href='#arma_to_wv_app'><p>ARMA process to WV Approximation</p></a></li>
<li><a href='#ARMA11'><p>Definition of an ARMA(1,1)</p></a></li>
<li><a href='#arma11_to_wv'><p>ARMA(1,1) to WV</p></a></li>
<li><a href='#ARMAacf_cpp'><p>Compute Theoretical ACF for an ARMA Process</p></a></li>
<li><a href='#ARMAtoMA_cpp'><p>Converting an ARMA Process to an Infinite MA Process</p></a></li>
<li><a href='#australia'><p>Quarterly Increase in Stocks Non-Farm Total, Australia</p></a></li>
<li><a href='#auto_corr'><p>Empirical ACF and PACF</p></a></li>
<li><a href='#auto_imu_cpp'><p>Find the auto imu result</p></a></li>
<li><a href='#B_matrix'><p>B Matrix</p></a></li>
<li><a href='#batch_modwt_wvar_cpp'><p>Computes the MO/DWT wavelet variance for multiple processes</p></a></li>
<li><a href='#best_model'><p>Select the Best Model</p></a></li>
<li><a href='#bl14_filter'><p>bl14 filter construction</p></a></li>
<li><a href='#bl20_filter'><p>bl20 filter construction</p></a></li>
<li><a href='#boot_pval_gof'><p>Generate the Confidence Interval for GOF Bootstrapped</p></a></li>
<li><a href='#bootstrap_gof_test'><p>Compute the Bootstrapped GoF Test</p></a></li>
<li><a href='#brick_wall'><p>Removal of Boundary Wavelet Coefficients</p></a></li>
<li><a href='#build_model_set'><p>Build List of Unique Models</p></a></li>
<li><a href='#calculate_psi_matrix'><p>Calculate the Psi matrix</p></a></li>
<li><a href='#cfilter'><p>Time Series Convolution Filters</p></a></li>
<li><a href='#check'><p>Diagnostics on Fitted Time Series Model</p></a></li>
<li><a href='#ci_eta3'><p>Generate eta3 confidence interval</p></a></li>
<li><a href='#ci_eta3_robust'><p>Generate eta3 robust confidence interval</p></a></li>
<li><a href='#ci_wave_variance'><p>Generate a Confidence intervval for a Univariate Time Series</p></a></li>
<li><a href='#code_zero'><p>Optim loses NaN</p></a></li>
<li><a href='#comb'><p>Combine math expressions</p></a></li>
<li><a href='#compare_acf'><p>Comparison of Classical and Robust Correlation Analysis Functions</p></a></li>
<li><a href='#compute_cov_cpp'><p>Computes the (MODWT) wavelet covariance matrix</p></a></li>
<li><a href='#conv.ar1.to.gm'><p>GM Conversion</p></a></li>
<li><a href='#corr_analysis'><p>Correlation Analysis Functions</p></a></li>
<li><a href='#count_models'><p>Count Models</p></a></li>
<li><a href='#cov_bootstrapper'><p>Bootstrap for Matrix V</p></a></li>
<li><a href='#create_imu'><p>Internal IMU Object Construction</p></a></li>
<li><a href='#custom_legend'><p>Custom legend function</p></a></li>
<li><a href='#D_matrix'><p>Analytic D matrix of Processes</p></a></li>
<li><a href='#d16_filter'><p>d16 filter construction</p></a></li>
<li><a href='#d4_filter'><p>d4 filter construction</p></a></li>
<li><a href='#d6_filter'><p>d6 filter construction</p></a></li>
<li><a href='#d8_filter'><p>d8 filter construction</p></a></li>
<li><a href='#decomp_theoretical_wv'><p>Each Models Process Decomposed to WV</p></a></li>
<li><a href='#decomp_to_theo_wv'><p>Decomposed WV to Single WV</p></a></li>
<li><a href='#deriv_2nd_ar1'><p>Analytic second derivative matrix for AR(1) process</p></a></li>
<li><a href='#deriv_2nd_arma11'><p>Analytic D matrix for ARMA(1,1) process</p></a></li>
<li><a href='#deriv_2nd_dr'><p>Analytic second derivative matrix for drift process</p></a></li>
<li><a href='#deriv_2nd_ma1'><p>Analytic second derivative for MA(1) process</p></a></li>
<li><a href='#deriv_ar1'><p>Analytic D matrix for AR(1) process</p></a></li>
<li><a href='#deriv_arma11'><p>Analytic D matrix for ARMA(1,1) process</p></a></li>
<li><a href='#deriv_dr'><p>Analytic D matrix for Drift (DR) Process</p></a></li>
<li><a href='#deriv_ma1'><p>Analytic D matrix for MA(1) process</p></a></li>
<li><a href='#deriv_qn'><p>Analytic D matrix for Quantization Noise (QN) Process</p></a></li>
<li><a href='#deriv_rw'><p>Analytic D matrix Random Walk (RW) Process</p></a></li>
<li><a href='#deriv_wn'><p>Analytic D Matrix for a Gaussian White Noise (WN) Process</p></a></li>
<li><a href='#derivative_first_matrix'><p>Analytic D matrix of Processes</p></a></li>
<li><a href='#desc.to.ts.model'><p>Create a ts.model from desc string</p></a></li>
<li><a href='#dft_acf'><p>Discrete Fourier Transformation for Autocovariance Function</p></a></li>
<li><a href='#diag_boxpierce'><p>Box-Pierce</p></a></li>
<li><a href='#diag_ljungbox'><p>Ljung-Box</p></a></li>
<li><a href='#diag_plot'><p>Diagnostic Plot of Residuals</p></a></li>
<li><a href='#diag_portmanteau_'><p>Portmanteau Tests</p></a></li>
<li><a href='#diff_cpp'><p>Lagged Differences in Armadillo</p></a></li>
<li><a href='#do_polyroot_arma'><p>Root Finding C++</p></a></li>
<li><a href='#do_polyroot_cpp'><p>Root Finding C++</p></a></li>
<li><a href='#DR'><p>Create an Drift (DR) Process</p></a></li>
<li><a href='#dr_to_wv'><p>Drift to WV</p></a></li>
<li><a href='#dwt_cpp'><p>Discrete Wavelet Transform</p></a></li>
<li><a href='#e_drift'><p>Expected value DR</p></a></li>
<li><a href='#estimate'><p>Fit a Time Series Model to Data</p></a></li>
<li><a href='#evaluate'><p>Evalute a time series or a list of time series models</p></a></li>
<li><a href='#fast_cov_cpp'><p>Computes the (MODWT) wavelet covariance matrix using Chi-square confidence interval bounds</p></a></li>
<li><a href='#FGN'><p>Definition of a Fractional Gaussian Noise (FGN) Process</p></a></li>
<li><a href='#field_to_matrix'><p>Transform an Armadillo field&lt;vec&gt; to a matrix</p></a></li>
<li><a href='#find_full_model'><p>Find the Common Denominator of the Models</p></a></li>
<li><a href='#fk14_filter'><p>fk14 filter construction</p></a></li>
<li><a href='#fk22_filter'><p>fk22 filter construction</p></a></li>
<li><a href='#fk4_filter'><p>fk4 filter construction</p></a></li>
<li><a href='#fk6_filter'><p>fk6 filter construction</p></a></li>
<li><a href='#fk8_filter'><p>fk8 filter construction</p></a></li>
<li><a href='#format_ci'><p>Format the Confidence Interval for Estimates</p></a></li>
<li><a href='#gen_ar1'><p>Generate an Autoregressive Order 1 ( AR(1) ) sequence</p></a></li>
<li><a href='#gen_ar1blocks'><p>Generate AR(1) Block Process</p></a></li>
<li><a href='#gen_arima'><p>Generate Autoregressive Order p, Integrated d, Moving Average Order q (ARIMA(p,d,q)) Model</p></a></li>
<li><a href='#gen_arma'><p>Generate Autoregressive Order <code class="reqn">p</code> - Moving Average Order <code class="reqn">q</code> (ARMA(<code class="reqn">p</code>,<code class="reqn">q</code>)) Model</p></a></li>
<li><a href='#gen_arma11'><p>Generate an ARMA(1,1) sequence</p></a></li>
<li><a href='#gen_bi'><p>Generate Bias-Instability Process</p></a></li>
<li><a href='#gen_dr'><p>Generate a Drift Process</p></a></li>
<li><a href='#gen_fgn'><p>Generate a Fractional Gaussian noise given <code class="reqn">\sigma^2</code> and <code class="reqn">H</code>.</p></a></li>
<li><a href='#gen_generic_sarima'><p>Generate Generic Seasonal Autoregressive Order P - Moving Average Order Q (SARMA(p,q)x(P,Q)) Model</p></a></li>
<li><a href='#gen_gts'><p>Simulate a simts TS object using a theoretical model</p></a></li>
<li><a href='#gen_lts'><p>Generate a Latent Time Series Object Based on a Model</p></a></li>
<li><a href='#gen_lts_cpp'><p>Generate Latent Time Series based on Model (Internal)</p></a></li>
<li><a href='#gen_ma1'><p>Generate an Moving Average Order 1 (MA(1)) Process</p></a></li>
<li><a href='#gen_matern'><p>Generate a Matern Process given <code class="reqn">\sigma^2</code>, <code class="reqn">\lambda</code> and <code class="reqn">\alpha</code>.</p></a></li>
<li><a href='#gen_mean'><p>Generate a determinist vector returned by the matrix by vector product of matrix <code class="reqn">X</code> and vector <code class="reqn">\beta</code>.</p></a></li>
<li><a href='#gen_model'><p>Generate Time Series based on Model (Internal)</p></a></li>
<li><a href='#gen_nswn'><p>Generate Non-Stationary White Noise Process</p></a></li>
<li><a href='#gen_powerlaw'><p>Generate a Power Law Process given <code class="reqn">\sigma^2</code> and <code class="reqn">d</code>.</p></a></li>
<li><a href='#gen_qn'><p>Generate a Quantisation Noise (QN) or Rounding Error Sequence</p></a></li>
<li><a href='#gen_rw'><p>Generate a Random Walk without Drift</p></a></li>
<li><a href='#gen_sarima'><p>Generate Seasonal Autoregressive Order P - Moving Average Order Q (SARMA(p,q)x(P,Q)) Model</p></a></li>
<li><a href='#gen_sarma'><p>Generate Seasonal Autoregressive Order P - Moving Average Order Q (SARMA(p,q)x(P,Q)) Model</p></a></li>
<li><a href='#gen_sin'><p>Generate a Sinusoidal Process given <code class="reqn">\alpha^2</code> and <code class="reqn">\beta</code>.</p></a></li>
<li><a href='#gen_wn'><p>Generate a Gaussian White Noise Process (WN(<code class="reqn">\sigma ^2</code>))</p></a></li>
<li><a href='#get_summary'><p>Routing function for summary info</p></a></li>
<li><a href='#getObjFun'><p>Retrieve GMWM starting value from Yannick's objective function</p></a></li>
<li><a href='#getObjFunStarting'><p>Retrieve GMWM starting value from Yannick's objective function</p></a></li>
<li><a href='#GM'><p>Create a Gauss-Markov (GM) Process</p></a></li>
<li><a href='#gm_to_ar1'><p>Transform GM to AR1</p></a></li>
<li><a href='#gmwm'><p>Generalized Method of Wavelet Moments (GMWM)</p></a></li>
<li><a href='#gmwm_engine'><p>Engine for obtaining the GMWM Estimator</p></a></li>
<li><a href='#gmwm_imu'><p>GMWM for (Robust) Inertial Measurement Units (IMUs)</p></a></li>
<li><a href='#gmwm_master_cpp'><p>Master Wrapper for the GMWM Estimator</p></a></li>
<li><a href='#gmwm_param_bootstrapper'><p>Bootstrap for Estimating Both Theta and Theta SD</p></a></li>
<li><a href='#gmwm_sd_bootstrapper'><p>Bootstrap for Standard Deviations of Theta Estimates</p></a></li>
<li><a href='#gmwm_update_cpp'><p>Update Wrapper for the GMWM Estimator</p></a></li>
<li><a href='#gof_test'><p>Compute the GOF Test</p></a></li>
<li><a href='#gts'><p>Create a simts TS object using time series data</p></a></li>
<li><a href='#gts_time'><p>Time of a gts object</p></a></li>
<li><a href='#guess_initial'><p>Randomly guess a starting parameter</p></a></li>
<li><a href='#guess_initial_old'><p>Randomly guess a starting parameter</p></a></li>
<li><a href='#haar_filter'><p>Haar filter construction</p></a></li>
<li><a href='#has'><p>Obtain the value of an object's properties</p></a></li>
<li><a href='#hydro'><p>Mean Monthly Precipitation, from 1907 to 1972</p></a></li>
<li><a href='#idf_arma'><p>Indirect Inference for ARMA</p></a></li>
<li><a href='#idf_arma_total'><p>Indirect Inference for ARMA</p></a></li>
<li><a href='#imu'><p>Create an IMU Object</p></a></li>
<li><a href='#imu_time'><p>Pulls the IMU time from the IMU object</p></a></li>
<li><a href='#intgr_vec'><p>Discrete Intergral: Inverse Difference</p></a></li>
<li><a href='#invert_check'><p>Check Invertibility Conditions</p></a></li>
<li><a href='#is.gts'><p>Is simts Object</p></a></li>
<li><a href='#is.whole'><p>Integer Check</p></a></li>
<li><a href='#jacobian_arma'><p>Calculates the Jacobian for the ARMA process</p></a></li>
<li><a href='#la16_filter'><p>la16 filter construction</p></a></li>
<li><a href='#la20_filter'><p>la20 filter construction</p></a></li>
<li><a href='#la8_filter'><p>la8 filter construction</p></a></li>
<li><a href='#lm_arma'><p>MLR in Armadillo</p></a></li>
<li><a href='#lm_dr'><p>Linear Regression with Drift</p></a></li>
<li><a href='#logit'><p>Logit Function</p></a></li>
<li><a href='#logit_inv'><p>Logit Inverse Function</p></a></li>
<li><a href='#logit2'><p>Logit2 Function</p></a></li>
<li><a href='#logit2_inv'><p>Logit2 Inverse Function</p></a></li>
<li><a href='#lts'><p>Generate a Latent Time Series Object from Data</p></a></li>
<li><a href='#M'><p>Definition of a Mean deterministic vector returned by the matrix by vector product of matrix <code class="reqn">X</code> and vector <code class="reqn">\beta</code></p></a></li>
<li><a href='#m2_drift'><p>Second moment DR</p></a></li>
<li><a href='#MA'><p>Create an Moving Average Q [MA(Q)] Process</p></a></li>
<li><a href='#Ma_cpp'><p>Ma function.</p></a></li>
<li><a href='#Ma_cpp_vec'><p>Ma vectorized function.</p></a></li>
<li><a href='#MA1'><p>Definition of an Moving Average Process of Order 1</p></a></li>
<li><a href='#ma1_to_wv'><p>Moving Average Order 1 (MA(1)) to WV</p></a></li>
<li><a href='#make_frame'><p>Default utility function for various plots titles</p></a></li>
<li><a href='#MAPE'><p>Median Absolute Prediction Error</p></a></li>
<li><a href='#MAT'><p>Definition of a Matérn Process</p></a></li>
<li><a href='#mb16_filter'><p>mb16 filter construction</p></a></li>
<li><a href='#mb24_filter'><p>mb24 filter construction</p></a></li>
<li><a href='#mb4_filter'><p>mb4 filter construction</p></a></li>
<li><a href='#mb8_filter'><p>mb8 filter construction</p></a></li>
<li><a href='#mean_diff'><p>Mean of the First Difference of the Data</p></a></li>
<li><a href='#minroot'><p>Obtain the smallest polynomial root</p></a></li>
<li><a href='#Mod_cpp'><p>Absolute Value or Modulus of a Complex Number.</p></a></li>
<li><a href='#model_objdesc'><p>Generate the ts model object description</p></a></li>
<li><a href='#model_process_desc'><p>Generate the ts model object's process desc</p></a></li>
<li><a href='#model_score'><p>Model Score</p></a></li>
<li><a href='#model_theta'><p>Generate the ts model object's theta vector</p></a></li>
<li><a href='#modwt_cpp'><p>Maximum Overlap Discrete Wavelet Transform</p></a></li>
<li><a href='#modwt_wvar_cpp'><p>Computes the (MODWT) wavelet variance</p></a></li>
<li><a href='#np_boot_sd_med'><p>Bootstrap standard error for the median</p></a></li>
<li><a href='#num_rep'><p>Replicate a Vector of Elements <code class="reqn">n</code> times</p></a></li>
<li><a href='#obj_extract'><p>Extract Object</p></a></li>
<li><a href='#opt_n_gof_bootstrapper'><p>Bootstrap for Optimism and GoF</p></a></li>
<li><a href='#optimism_bootstrapper'><p>Bootstrap for Optimism</p></a></li>
<li><a href='#order_AR1s'><p>Order AR1s by size of phi.</p></a></li>
<li><a href='#orderModel'><p>Order the Model</p></a></li>
<li><a href='#plot_pred'><p>Plot Time Series Forecast Function</p></a></li>
<li><a href='#plot.gmwm'><p>Plot the GMWM with the Wavelet Variance</p></a></li>
<li><a href='#plot.gts'><p>Plot simts Time Series Data</p></a></li>
<li><a href='#plot.lts'><p>Plot Latent Time Series Object</p></a></li>
<li><a href='#plot.PACF'><p>Plot Partial Auto-Covariance and Correlation Functions</p></a></li>
<li><a href='#plot.simtsACF'><p>Plot Auto-Covariance and Correlation Functions</p></a></li>
<li><a href='#PLP'><p>Definition of a Power Law Process</p></a></li>
<li><a href='#predict.fitsimts'><p>Time Series Prediction</p></a></li>
<li><a href='#predict.gmwm'><p>Predict future points in the time series using the solution of the</p>
Generalized Method of Wavelet Moments</a></li>
<li><a href='#print.fitsimts'><p>Print fitsimts object</p></a></li>
<li><a href='#print.gmwm'><p>Print gmwm object</p></a></li>
<li><a href='#print.imu'><p>Print simts Objects</p></a></li>
<li><a href='#print.summary.gmwm'><p>Print summary.gmwm object</p></a></li>
<li><a href='#print.ts.model'><p>Multiply a ts.model by constant</p></a></li>
<li><a href='#pseudo_logit'><p>Pseudo Logit Function</p></a></li>
<li><a href='#pseudo_logit_inv'><p>Pseudo Logit Inverse Function</p></a></li>
<li><a href='#qmf'><p>Quadrature Mirror Filter</p></a></li>
<li><a href='#QN'><p>Create an Quantisation Noise (QN) Process</p></a></li>
<li><a href='#qn_to_wv'><p>Quantisation Noise (QN) to WV</p></a></li>
<li><a href='#quantile_cpp'><p>Find Quantiles</p></a></li>
<li><a href='#rank_models_cpp'><p>Find the Rank Models result</p></a></li>
<li><a href='#Rcpp_ARIMA'><p>Hook into R's ARIMA function</p></a></li>
<li><a href='#read_imu'><p>Read an IMU Binary File into R</p></a></li>
<li><a href='#read.imu'><p>Read an IMU Binary File into R</p></a></li>
<li><a href='#resid_plot'><p>Plot the Distribution of (Standardized) Residuals</p></a></li>
<li><a href='#rev_col_subset'><p>Reverse Subset Column</p></a></li>
<li><a href='#rev_row_subset'><p>Reverse Subset Row</p></a></li>
<li><a href='#reverse_vec'><p>Reverse Armadillo Vector</p></a></li>
<li><a href='#rfilter'><p>Time Series Recursive Filters</p></a></li>
<li><a href='#rgmwm'><p>GMWM for Robust/Classical Comparison</p></a></li>
<li><a href='#rtruncated_normal'><p>Truncated Normal Distribution Sampling Algorithm</p></a></li>
<li><a href='#RW'><p>Create an Random Walk (RW) Process</p></a></li>
<li><a href='#rw_to_wv'><p>Random Walk to WV</p></a></li>
<li><a href='#RW2dimension'><p>Function to Compute Direction Random Walk Moves</p></a></li>
<li><a href='#SARIMA'><p>Create a Seasonal Autoregressive Integrated Moving Average (SARIMA) Process</p></a></li>
<li><a href='#SARMA'><p>Create a Seasonal Autoregressive Moving Average (SARMA) Process</p></a></li>
<li><a href='#sarma_calculate_spadding'><p>Calculates Length of Seasonal Padding</p></a></li>
<li><a href='#sarma_components'><p>Determine parameter expansion based upon objdesc</p></a></li>
<li><a href='#sarma_expand'><p>Expand Parameters for an SARMA object</p></a></li>
<li><a href='#sarma_expand_unguided'><p>(Internal) Expand the SARMA Parameters</p></a></li>
<li><a href='#sarma_params_construct'><p>Efficient way to merge items together</p></a></li>
<li><a href='#savingrt'><p>Personal Saving Rate</p></a></li>
<li><a href='#scales_cpp'><p>Computes the MODWT scales</p></a></li>
<li><a href='#select'><p>Time Series Model Selection</p></a></li>
<li><a href='#select_arima'><p>Run Model Selection Criteria on ARIMA Models</p></a></li>
<li><a href='#select_filter'><p>Select the Wavelet Filter</p></a></li>
<li><a href='#seq_cpp'><p>Generate a sequence of values</p></a></li>
<li><a href='#seq_len_cpp'><p>Generate a sequence of values based on supplied number</p></a></li>
<li><a href='#set_seed'><p>Set the RNG Seed from within Rcpp</p></a></li>
<li><a href='#simple_diag_plot'><p>Basic Diagnostic Plot of Residuals</p></a></li>
<li><a href='#simplified_print_SARIMA'><p>Simplify and print SARIMA model</p></a></li>
<li><a href='#SIN'><p>Definition of a Sinusoidal (SIN) Process</p></a></li>
<li><a href='#sort_mat'><p>Sort Matrix by Column</p></a></li>
<li><a href='#sum_field_vec'><p>Accumulation of Armadillo field&lt;vec&gt;</p></a></li>
<li><a href='#summary.fitsimts'><p>Summary of fitsimts object</p></a></li>
<li><a href='#summary.gmwm'><p>Summary of GMWM object</p></a></li>
<li><a href='#theo_acf'><p>Theoretical Autocorrelation (ACF) of an ARMA process</p></a></li>
<li><a href='#theo_pacf'><p>Theoretical Partial Autocorrelation (PACF) of an ARMA process</p></a></li>
<li><a href='#theoretical_wv'><p>Model Process to WV</p></a></li>
<li><a href='#theta_ci'><p>Generate the Confidence Interval for Theta Estimates</p></a></li>
<li><a href='#transform_values'><p>Transform Values for Optimization</p></a></li>
<li><a href='#unitConversion'><p>Convert Unit of Time Series Data</p></a></li>
<li><a href='#untransform_values'><p>Revert Transform Values for Display</p></a></li>
<li><a href='#update_obj'><p>Update the Attributes of Objects</p></a></li>
<li><a href='#update.gmwm'><p>Update (Robust) GMWM object for IMU or SSM</p></a></li>
<li><a href='#update.lts'><p>Update Object Attribute</p></a></li>
<li><a href='#value'><p>Obtain the value of an object's properties</p></a></li>
<li><a href='#var_drift'><p>Variance DR</p></a></li>
<li><a href='#vector_to_set'><p>Conversion function of Vector to Set</p></a></li>
<li><a href='#w4_filter'><p>w4 filter construction</p></a></li>
<li><a href='#wave_variance'><p>Generate a Wave Variance for a Univariate Time Series</p></a></li>
<li><a href='#WN'><p>Create an White Noise (WN) Process</p></a></li>
<li><a href='#wn_to_wv'><p>Gaussian White Noise to WV</p></a></li>
<li><a href='#wvar_cpp'><p>Computes the (MODWT) wavelet variance</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Time Series Analysis Tools</td>
</tr>
<tr>
<td>Version:</td>
<td>0.2.2</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-09-29</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Stéphane Guerrier &lt;stef.guerrier@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>A system contains easy-to-use tools as a support for time series analysis courses. In particular, it incorporates a technique called Generalized Method of Wavelet Moments (GMWM) as well as its robust implementation for fast and robust parameter estimation of time series models which is described, for example, in Guerrier et al. (2013) &lt;<a href="https://doi.org/10.1080%2F01621459.2013.799920">doi:10.1080/01621459.2013.799920</a>&gt;. More details can also be found in the paper linked to via the URL below.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.6.0)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/AGPL-3">AGPL-3</a> | file LICENSE</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp, stats, utils, scales, grDevices, graphics, broom, dplyr,
magrittr, methods, purrr, tidyr, robcor</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/SMAC-Group/simts">https://github.com/SMAC-Group/simts</a>,
<a href="https://arxiv.org/pdf/1607.04543.pdf">https://arxiv.org/pdf/1607.04543.pdf</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/SMAC-Group/simts/issues">https://github.com/SMAC-Group/simts/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-08-31 11:13:12 UTC; lionel</td>
</tr>
<tr>
<td>Author:</td>
<td>Stéphane Guerrier [aut, cre, cph],
  James Balamuta [aut, cph],
  Roberto Molinari [aut, cph],
  Justin Lee [aut],
  Lionel Voirol [aut],
  Yuming Zhang [aut],
  Wenchao Yang [ctb],
  Nathanael Claussen [ctb],
  Yunxiang Zhang [ctb],
  Christian Gunning [cph],
  Romain Francois [cph],
  Ross Ihaka [cph],
  R Core Team [cph]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-08-31 12:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='simts-package'>simts: Time Series Analysis Tools</h2><span id='topic+simts'></span><span id='topic+simts-package'></span>

<h3>Description</h3>

<p><img src="../help/figures/logo.png" style='float: right' alt='logo' width='120' />
</p>
<p>A system contains easy-to-use tools as a support for time series analysis courses. In particular, it incorporates a technique called Generalized Method of Wavelet Moments (GMWM) as well as its robust implementation for fast and robust parameter estimation of time series models which is described, for example, in Guerrier et al. (2013) <a href="https://doi.org/%2010.1080/01621459.2013.799920">doi: 10.1080/01621459.2013.799920</a>. More details can also be found in the paper linked to via the URL below.
</p>
<p><img src="../help/figures/logo.png" style='float: right' alt='logo' width='120' />
</p>
<p>A system contains easy-to-use tools as a support for time series analysis courses. In particular, it incorporates a technique called Generalized Method of Wavelet Moments (GMWM) as well as its robust implementation for fast and robust parameter estimation of time series models which is described, for example, in Guerrier et al. (2013) <a href="https://doi.org/%2010.1080/01621459.2013.799920">doi: 10.1080/01621459.2013.799920</a>. More details can also be found in the paper linked to via the URL below.
</p>


<h3>Details</h3>

<p>The data sets in this package may change at a moments notice.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Stéphane Guerrier <a href="mailto:stef.guerrier@gmail.com">stef.guerrier@gmail.com</a> [copyright holder]
</p>
<p>Authors:
</p>

<ul>
<li><p> James Balamuta [copyright holder]
</p>
</li>
<li><p> Roberto Molinari [copyright holder]
</p>
</li>
<li><p> Justin Lee
</p>
</li>
<li><p> Lionel Voirol
</p>
</li>
<li><p> Yuming Zhang
</p>
</li></ul>

<p>Other contributors:
</p>

<ul>
<li><p> Wenchao Yang [contributor]
</p>
</li>
<li><p> Nathanael Claussen [contributor]
</p>
</li>
<li><p> Yunxiang Zhang [contributor]
</p>
</li>
<li><p> Christian Gunning [copyright holder]
</p>
</li>
<li><p> Romain Francois [copyright holder]
</p>
</li>
<li><p> Ross Ihaka [copyright holder]
</p>
</li>
<li><p> R Core Team [copyright holder]
</p>
</li></ul>

<p>James Balamuta <a href="mailto:balamut2@illinois.edu">balamut2@illinois.edu</a>,
Stephane Guerrier <a href="mailto:stef.guerrier@gmail.com">stef.guerrier@gmail.com</a>,
Roberto Molinari <a href="mailto:roberto.molinari@hotmail.it">roberto.molinari@hotmail.it</a>,
Wenchao Yang <a href="mailto:wyang40@illinois.edu">wyang40@illinois.edu</a>
Justin Lee <a href="mailto:munsheet93@gmail.com">munsheet93@gmail.com</a>
Yuming Zhang <a href="mailto:yuming.zhang@unige.ch">yuming.zhang@unige.ch</a>
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/SMAC-Group/simts">https://github.com/SMAC-Group/simts</a>
</p>
</li>
<li> <p><a href="https://arxiv.org/pdf/1607.04543.pdf">https://arxiv.org/pdf/1607.04543.pdf</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/SMAC-Group/simts/issues">https://github.com/SMAC-Group/simts/issues</a>
</p>
</li></ul>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/SMAC-Group/simts">https://github.com/SMAC-Group/simts</a>
</p>
</li>
<li> <p><a href="https://arxiv.org/pdf/1607.04543.pdf">https://arxiv.org/pdf/1607.04543.pdf</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/SMAC-Group/simts/issues">https://github.com/SMAC-Group/simts/issues</a>
</p>
</li></ul>


<hr>
<h2 id='.acf'>Auto-Covariance and Correlation Functions</h2><span id='topic+.acf'></span>

<h3>Description</h3>

<p>The acf function computes the estimated
autocovariance or autocorrelation for both univariate and multivariate cases.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.acf(x, lagmax = 0L, cor = TRUE, demean = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".acf_+3A_x">x</code></td>
<td>
<p>A <code>matrix</code> with dimensions <code class="reqn">N \times S</code> or N observations and S processes</p>
</td></tr>
<tr><td><code id=".acf_+3A_lagmax">lagmax</code></td>
<td>
<p>A <code>integer</code></p>
</td></tr>
<tr><td><code id=".acf_+3A_cor">cor</code></td>
<td>
<p>A <code>bool</code> indicating whether the correlation 
(<code>TRUE</code>) or covariance (<code>FALSE</code>) should be computed.</p>
</td></tr>
<tr><td><code id=".acf_+3A_demean">demean</code></td>
<td>
<p>A <code>bool</code> indicating whether the data should be detrended
(<code>TRUE</code>) or not (<code>FALSE</code>)</p>
</td></tr>
</table>

<hr>
<h2 id='+5B.imu'>Subset an IMU Object</h2><span id='topic++5B.imu'></span>

<h3>Description</h3>

<p>Enables the IMU object to be subsettable. That is, you can load all the data in and then select certain properties.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'imu'
x[i, j, drop = FALSE]
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B5B.imu_+3A_x">x</code></td>
<td>
<p>A <code>imu</code> object</p>
</td></tr>
<tr><td><code id="+2B5B.imu_+3A_i">i</code></td>
<td>
<p>A <code>integer vector</code> that specifies the rows to subset. If blank, all rows are selected.</p>
</td></tr>
<tr><td><code id="+2B5B.imu_+3A_j">j</code></td>
<td>
<p>A <code>integer vector</code> that specifies the columns to subset. Special rules apply see details.</p>
</td></tr>
<tr><td><code id="+2B5B.imu_+3A_drop">drop</code></td>
<td>
<p>A <code>boolean</code> indicating whether the structure should be preserved or simplified.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When using the subset operator, note that all the Gyroscopes are placed at the front of object 
and, then, the Accelerometers are placed.
</p>


<h3>Value</h3>

<p>An <code>imu</code> object class.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
if(!require("imudata")){
install_imudata()
library("imudata")
}

data(imu6)

# Create an IMU Object that is full. 
ex = imu(imu6, gyros = 1:3, accels = 4:6, axis = c('X', 'Y', 'Z', 'X', 'Y', 'Z'), freq = 100)

# Create an IMU object that has only gyros. 
ex.gyro = ex[,1:3]
ex.gyro2 = ex[,c("Gyro. X","Gyro. Y","Gyro. Z")]

# Create an IMU object that has only accels. 
ex.accel = ex[,4:6]
ex.accel2 = ex[,c("Accel. X","Accel. Y","Accel. Z")]

# Create an IMU object with both gyros and accels on axis X and Y
ex.b = ex[,c(1,2,4,5)]
ex.b2 = ex[,c("Gyro. X","Gyro. Y","Accel. X","Accel. Y")]


## End(Not run)

</code></pre>

<hr>
<h2 id='+2A.ts.model'>Multiple a ts.model by constant</h2><span id='topic++2A.ts.model'></span>

<h3>Description</h3>

<p>Sets up the necessary backend for creating multiple model objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ts.model'
x * y
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B2A.ts.model_+3A_x">x</code></td>
<td>
<p>A <code>numeric</code> value</p>
</td></tr>
<tr><td><code id="+2B2A.ts.model_+3A_y">y</code></td>
<td>
<p>A <code>ts.model</code> object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An S3 object with called ts.model with the following structure:
</p>

<dl>
<dt>process.desc</dt><dd><p>y desc replicated x times</p>
</dd>
<dt>theta</dt><dd><p>y theta replicated x times</p>
</dd>
<dt>plength</dt><dd><p>Number of Parameters</p>
</dd>
<dt>desc</dt><dd><p>y desc replicated x times</p>
</dd>
<dt>obj.desc</dt><dd><p>Depth of Parameters e.g. list(c(1,1),c(1,1))</p>
</dd>
<dt>starting</dt><dd><p>Guess Starting values? TRUE or FALSE (e.g. specified value)</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>James Balamuta and Stephane Guerrier
</p>


<h3>Examples</h3>

<pre><code class='language-R'>4*DR()+2*WN()
DR()*4 + WN()*2
AR1(phi=.3,sigma=.2)*3
</code></pre>

<hr>
<h2 id='+2B.ts.model'>Add ts.model objects together</h2><span id='topic++2B.ts.model'></span>

<h3>Description</h3>

<p>Sets up the necessary backend for combining ts.model objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ts.model'
x + y
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B2B.ts.model_+3A_x">x</code></td>
<td>
<p>A <code>ts.model</code> object</p>
</td></tr>
<tr><td><code id="+2B2B.ts.model_+3A_y">y</code></td>
<td>
<p>A <code>ts.model</code> object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An S3 object with called ts.model with the following structure:
</p>

<ul>
<li><p>process.desccombined x, y desc
</p>
</li>
<li><p>thetacombined x, y theta
</p>
</li>
<li><p>plengthNumber of Parameters
</p>
</li>
<li><p>descAdd process to queue e.g. c(&quot;AR1&quot;,&quot;WN&quot;)
</p>
</li>
<li><p>obj.descDepth of Parameters e.g. list(1, c(1,1), c(length(ar),length(ma),1) )
</p>
</li>
<li><p>startingGuess Starting values? TRUE or FALSE (e.g. specified value)
</p>
</li></ul>



<h3>Author(s)</h3>

<p>James Balamuta
</p>


<h3>Examples</h3>

<pre><code class='language-R'>DR()+WN()
AR1(phi=.3,sigma=.2)
</code></pre>

<hr>
<h2 id='acf_sum'>Helper Function for ARMA to WV Approximation</h2><span id='topic+acf_sum'></span>

<h3>Description</h3>

<p>Indicates where the minimum ARMAacf value is and returns that as an index.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>acf_sum(ar, ma, last_tau, alpha = 0.99)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="acf_sum_+3A_ar">ar</code></td>
<td>
<p>A <code>vec</code> containing the coefficients of the AR process</p>
</td></tr>
<tr><td><code id="acf_sum_+3A_ma">ma</code></td>
<td>
<p>A <code>vec</code> containing the coefficients of the MA process</p>
</td></tr>
<tr><td><code id="acf_sum_+3A_last_tau">last_tau</code></td>
<td>
<p>An <code>int</code> the Jth scale of 2^(1:J)</p>
</td></tr>
<tr><td><code id="acf_sum_+3A_alpha">alpha</code></td>
<td>
<p>A <code>double</code> indicating the cutoff.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>vec</code> containing the wavelet variance of the ARMA process.
</p>

<hr>
<h2 id='AIC.fitsimts'>Akaike's Information Criterion</h2><span id='topic+AIC.fitsimts'></span>

<h3>Description</h3>

<p>This function calculates AIC, BIC or HQ for a fitsimts object. This function currently
only supports models estimated by the MLE.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fitsimts'
AIC(object, k = 2, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="AIC.fitsimts_+3A_object">object</code></td>
<td>
<p>A fitsimts object.</p>
</td></tr>
<tr><td><code id="AIC.fitsimts_+3A_k">k</code></td>
<td>
<p>The penalty per parameter to be used; the default k = 2 is the classical AIC.</p>
</td></tr>
<tr><td><code id="AIC.fitsimts_+3A_...">...</code></td>
<td>
<p>Optionally more fitted model objects.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>AIC, BIC or HQ
</p>


<h3>Author(s)</h3>

<p>Stéphane Guerrier
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
n = 300
Xt = gen_gts(n, AR(phi = c(0, 0, 0.8), sigma2 = 1))
mod = estimate(AR(3), Xt)

# AIC
AIC(mod)

# BIC
AIC(mod, k = log(n))

# HQ
AIC(mod, k = 2*log(log(n)))
</code></pre>

<hr>
<h2 id='all_bootstrapper'>Bootstrap for Everything!</h2><span id='topic+all_bootstrapper'></span>

<h3>Description</h3>

<p>Using the bootstrap approach, we simulate a model based on user supplied parameters, obtain the wavelet variance, and then V.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>all_bootstrapper(
  theta,
  desc,
  objdesc,
  scales,
  model_type,
  N,
  robust,
  eff,
  alpha,
  H
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="all_bootstrapper_+3A_theta">theta</code></td>
<td>
<p>A <code>vector</code> with dimensions N x 1 that contains user-supplied initial values for parameters</p>
</td></tr>
<tr><td><code id="all_bootstrapper_+3A_desc">desc</code></td>
<td>
<p>A <code>vector&lt;string&gt;</code> indicating the models that should be considered.</p>
</td></tr>
<tr><td><code id="all_bootstrapper_+3A_objdesc">objdesc</code></td>
<td>
<p>A <code>field&lt;vec&gt;</code> that contains an object description (e.g. values) of the model.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Expand in detail...
</p>


<h3>Value</h3>

<p>A <code>vec</code> that contains the parameter estimates from GMWM estimator.
</p>


<h3>Author(s)</h3>

<p>JJB
</p>

<hr>
<h2 id='AR'>Create an Autoregressive P [AR(P)] Process</h2><span id='topic+AR'></span>

<h3>Description</h3>

<p>Sets up the necessary backend for the AR(P) process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AR(phi = NULL, sigma2 = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="AR_+3A_phi">phi</code></td>
<td>
<p>A <code>vector</code> with double values for the <code class="reqn">\phi</code> of an AR(P) process (see Note for details).</p>
</td></tr>
<tr><td><code id="AR_+3A_sigma2">sigma2</code></td>
<td>
<p>A <code>double</code> value for the variance, <code class="reqn">\sigma ^2</code>, of an AR(P) process. (see Note for details).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An S3 object with called ts.model with the following structure:
</p>

<dl>
<dt>process.desc</dt><dd><p>Used in summary: &quot;AR-1&quot;,&quot;AR-2&quot;, ..., &quot;AR-P&quot;, &quot;SIGMA2&quot;</p>
</dd>
<dt>theta</dt><dd><p><code class="reqn">\phi_1</code>, <code class="reqn">\phi_2</code>, ..., <code class="reqn">\phi_p</code>, <code class="reqn">\sigma^2</code></p>
</dd>
<dt>plength</dt><dd><p>Number of Parameters</p>
</dd>
<dt>desc</dt><dd><p>&quot;AR&quot;</p>
</dd>
<dt>print</dt><dd><p>String containing simplified model</p>
</dd>
<dt>obj.desc</dt><dd><p>Depth of Parameters e.g. list(p,1)</p>
</dd>
<dt>starting</dt><dd><p>Guess starting values? TRUE or FALSE (e.g. specified value)</p>
</dd>
</dl>



<h3>Note</h3>

<p>We consider the following model: </p>
<p style="text-align: center;"><code class="reqn">X_t = \sum_{j = 1}^p \phi_j X_{t-1} + \varepsilon_t</code>
</p>
<p> , where <code class="reqn">\varepsilon_t</code> is iid from a zero 
mean normal distribution with variance <code class="reqn">\sigma^2</code>.
</p>


<h3>Author(s)</h3>

<p>James Balamuta
</p>


<h3>Examples</h3>

<pre><code class='language-R'>AR(1) # Slower version of AR1()
AR(phi=.32, sigma=1.3) # Slower version of AR1()
AR(2) # Equivalent to ARMA(2,0).
</code></pre>

<hr>
<h2 id='AR1'>Definition of an Autoregressive Process of Order 1</h2><span id='topic+AR1'></span>

<h3>Description</h3>

<p>Definition of an Autoregressive Process of Order 1
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AR1(phi = NULL, sigma2 = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="AR1_+3A_phi">phi</code></td>
<td>
<p>A <code>double</code> value for the parameter <code class="reqn">\phi</code> (see Note for details).</p>
</td></tr>
<tr><td><code id="AR1_+3A_sigma2">sigma2</code></td>
<td>
<p>A <code>double</code> value for the variance parameter <code class="reqn">\sigma ^2</code> (see Note for details).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An S3 object containing the specified ts.model with the following structure:
</p>

<dl>
<dt>process.desc</dt><dd><p>Used in summary: &quot;AR1&quot;,&quot;SIGMA2&quot;</p>
</dd>
<dt>theta</dt><dd><p>Parameter vector including <code class="reqn">\phi</code>, <code class="reqn">\sigma^2</code></p>
</dd>
<dt>plength</dt><dd><p>Number of parameters</p>
</dd>
<dt>print</dt><dd><p>String containing simplified model</p>
</dd>
<dt>desc</dt><dd><p>&quot;AR1&quot;</p>
</dd>
<dt>obj.desc</dt><dd><p>Depth of Parameters e.g. list(1,1)</p>
</dd>
<dt>starting</dt><dd><p>Find starting values? TRUE or FALSE (e.g. specified value)</p>
</dd>
</dl>



<h3>Note</h3>

<p>We consider the following AR(1) model: </p>
<p style="text-align: center;"><code class="reqn">X_t = \phi X_{t-1} + \varepsilon_t</code>
</p>
<p>, where <code class="reqn">\varepsilon_t</code> is iid from a zero 
mean normal distribution with variance <code class="reqn">\sigma^2</code>.
</p>


<h3>Author(s)</h3>

<p>James Balamuta
</p>


<h3>Examples</h3>

<pre><code class='language-R'>AR1()
AR1(phi=.32, sigma2 = 1.3)
</code></pre>

<hr>
<h2 id='ar1_draw'>Randomly guess starting parameters for AR1</h2><span id='topic+ar1_draw'></span>

<h3>Description</h3>

<p>Sets starting parameters for each of the given parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ar1_draw(draw_id, last_phi, sigma2_total, model_type)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ar1_draw_+3A_draw_id">draw_id</code></td>
<td>
<p>An <code>unsigned int</code> that contains the draw principles.</p>
</td></tr>
<tr><td><code id="ar1_draw_+3A_last_phi">last_phi</code></td>
<td>
<p>A <code>double</code> containing the last guessed phi value.</p>
</td></tr>
<tr><td><code id="ar1_draw_+3A_sigma2_total">sigma2_total</code></td>
<td>
<p>A <code>double</code> that contains the sum of all WVs.</p>
</td></tr>
<tr><td><code id="ar1_draw_+3A_model_type">model_type</code></td>
<td>
<p>A <code>string</code> that describes the model transformation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>vec</code> containing smart parameter starting guesses to be iterated over.
</p>

<hr>
<h2 id='ar1_to_gm'>Transform AR1 to GM</h2><span id='topic+ar1_to_gm'></span>

<h3>Description</h3>

<p>Takes AR1 values and transforms them to GM
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ar1_to_gm(theta, freq)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ar1_to_gm_+3A_theta">theta</code></td>
<td>
<p>A <code>vec</code> that contains AR1 values.</p>
</td></tr>
<tr><td><code id="ar1_to_gm_+3A_freq">freq</code></td>
<td>
<p>A <code>double</code> indicating the frequency of the data.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function takes a vector of AR1 values <code class="reqn">\phi</code> and <code class="reqn">\sigma ^2</code>
and transforms them to GM values <code class="reqn">\beta</code> and <code class="reqn">\sigma ^2_{gm}</code>
using the formulas:
<code class="reqn">\beta  =  - \frac{{\ln \left( \phi  \right)}}{{\Delta t}}</code>
<code class="reqn">\sigma _{gm}^2 = \frac{{{\sigma ^2}}}{{1 - {\phi ^2}}} </code>
</p>


<h3>Value</h3>

<p>A <code>vec</code> containing GM values.
</p>


<h3>Author(s)</h3>

<p>James Balamuta
</p>

<hr>
<h2 id='ar1_to_wv'>AR(1) process to WV</h2><span id='topic+ar1_to_wv'></span>

<h3>Description</h3>

<p>This function computes the Haar WV of an AR(1) process
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ar1_to_wv(phi, sigma2, tau)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ar1_to_wv_+3A_phi">phi</code></td>
<td>
<p>A <code>double</code> that is the phi term of the AR(1) process</p>
</td></tr>
<tr><td><code id="ar1_to_wv_+3A_sigma2">sigma2</code></td>
<td>
<p>A <code>double</code> corresponding to variance of AR(1) process</p>
</td></tr>
<tr><td><code id="ar1_to_wv_+3A_tau">tau</code></td>
<td>
<p>A <code>vec</code> containing the scales e.g. <code class="reqn">2^{\tau}</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is significantly faster than its generalized counter part
<code><a href="#topic+arma_to_wv">arma_to_wv</a></code>.
</p>


<h3>Value</h3>

<p>A <code>vec</code> containing the wavelet variance of the AR(1) process.
</p>


<h3>Process Haar Wavelet Variance Formula</h3>

<p>The Autoregressive Order <code class="reqn">1</code> (AR(<code class="reqn">1</code>)) process has a Haar Wavelet Variance given by:
</p>
<p style="text-align: center;"><code class="reqn">\frac{{2{\sigma ^2}\left( {4{\phi ^{\frac{{{\tau _j}}}{2} + 1}} - {\phi ^{{\tau _j} + 1}} - \frac{1}{2}{\phi ^2}{\tau _j} + \frac{{{\tau _j}}}{2} - 3\phi } \right)}}{{{{\left( {1 - \phi } \right)}^2}\left( {1 - {\phi ^2}} \right)\tau _j^2}}</code>
</p>


<hr>
<h2 id='ARIMA'>Create an Autoregressive Integrated Moving Average (ARIMA) Process</h2><span id='topic+ARIMA'></span>

<h3>Description</h3>

<p>Sets up the necessary backend for the ARIMA process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ARIMA(ar = 1, i = 0, ma = 1, sigma2 = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ARIMA_+3A_ar">ar</code></td>
<td>
<p>A <code>vector</code> or <code>integer</code> containing either the coefficients for <code class="reqn">\phi</code>'s or the process number <code class="reqn">p</code> for the Autoregressive (AR) term.</p>
</td></tr>
<tr><td><code id="ARIMA_+3A_i">i</code></td>
<td>
<p>An <code>integer</code> containing the number of differences to be done.</p>
</td></tr>
<tr><td><code id="ARIMA_+3A_ma">ma</code></td>
<td>
<p>A <code>vector</code> or <code>integer</code> containing either the coefficients for <code class="reqn">\theta</code>'s or the process number <code class="reqn">q</code> for the Moving Average (MA) term.</p>
</td></tr>
<tr><td><code id="ARIMA_+3A_sigma2">sigma2</code></td>
<td>
<p>A <code>double</code> value for the standard deviation, <code class="reqn">\sigma</code>, of the ARIMA process.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A variance is required since the model generation statements utilize 
randomization functions expecting a variance instead of a standard deviation like R.
</p>


<h3>Value</h3>

<p>An S3 object with called ts.model with the following structure:
</p>

<dl>
<dt>process.desc</dt><dd><p><code class="reqn">AR*p</code>, <code class="reqn">MA*q</code></p>
</dd>
<dt>theta</dt><dd><p><code class="reqn">\sigma</code></p>
</dd>
<dt>plength</dt><dd><p>Number of parameters</p>
</dd>
<dt>print</dt><dd><p>String containing simplified model</p>
</dd>
<dt>obj.desc</dt><dd><p>y desc replicated x times</p>
</dd>
<dt>obj</dt><dd><p>Depth of parameters e.g. list(c(length(ar),length(ma),1) )</p>
</dd>
<dt>starting</dt><dd><p>Guess starting values? TRUE or FALSE (e.g. specified value)</p>
</dd>
</dl>



<h3>Note</h3>

<p>We consider the following model: </p>
<p style="text-align: center;"><code class="reqn">\Delta^i X_t = \sum_{j = 1}^p \phi_j \Delta^i X_{t-j} + \sum_{j = 1}^q \theta_j \varepsilon_{t-j} + \varepsilon_t</code>
</p>
<p>, where <code class="reqn">\varepsilon_t</code> is iid from a zero 
mean normal distribution with variance <code class="reqn">\sigma^2</code>.
</p>


<h3>Author(s)</h3>

<p>James Balamuta
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create an ARMA(1,2) process
ARIMA(ar=1,2)
# Creates an ARMA(3,2) process with predefined coefficients.
ARIMA(ar=c(0.23,.43, .59), ma=c(0.4,.3))

# Creates an ARMA(3,2) process with predefined coefficients and standard deviation
ARIMA(ar=c(0.23,.43, .59), ma=c(0.4,.3), sigma2 = 1.5)
</code></pre>

<hr>
<h2 id='ARMA'>Create an Autoregressive Moving Average (ARMA) Process</h2><span id='topic+ARMA'></span>

<h3>Description</h3>

<p>Sets up the necessary backend for the ARMA process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ARMA(ar = 1, ma = 1, sigma2 = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ARMA_+3A_ar">ar</code></td>
<td>
<p>A <code>vector</code> or <code>integer</code> containing either the coefficients for <code class="reqn">\phi</code>'s or the process number <code class="reqn">p</code> for the Autoregressive (AR) term.</p>
</td></tr>
<tr><td><code id="ARMA_+3A_ma">ma</code></td>
<td>
<p>A <code>vector</code> or <code>integer</code> containing either the coefficients for <code class="reqn">\theta</code>'s or the process number <code class="reqn">q</code> for the Moving Average (MA) term.</p>
</td></tr>
<tr><td><code id="ARMA_+3A_sigma2">sigma2</code></td>
<td>
<p>A <code>double</code> value for the standard deviation, <code class="reqn">\sigma</code>, of the ARMA process.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A variance is required since the model generation statements utilize 
randomization functions expecting a variance instead of a standard deviation like R.
</p>


<h3>Value</h3>

<p>An S3 object with called ts.model with the following structure:
</p>

<dl>
<dt>process.desc</dt><dd><p><code class="reqn">AR*p</code>, <code class="reqn">MA*q</code></p>
</dd>
<dt>theta</dt><dd><p><code class="reqn">\sigma</code></p>
</dd>
<dt>plength</dt><dd><p>Number of Parameters</p>
</dd>
<dt>print</dt><dd><p>String containing simplified model</p>
</dd>
<dt>obj.desc</dt><dd><p>y desc replicated x times</p>
</dd>
<dt>obj</dt><dd><p>Depth of Parameters e.g. list(c(length(ar),length(ma),1) )</p>
</dd>
<dt>starting</dt><dd><p>Guess Starting values? TRUE or FALSE (e.g. specified value)</p>
</dd>
</dl>



<h3>Note</h3>

<p>We consider the following model: </p>
<p style="text-align: center;"><code class="reqn">X_t = \sum_{j = 1}^p \phi_j X_{t-j} + \sum_{j = 1}^q \theta_j \varepsilon_{t-j} + \varepsilon_t</code>
</p>
<p>, where <code class="reqn">\varepsilon_t</code> is iid from a zero 
mean normal distribution with variance <code class="reqn">\sigma^2</code>.
</p>


<h3>Author(s)</h3>

<p>James Balamuta
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create an ARMA(1,2) process
ARMA(ar=1,2)
# Creates an ARMA(3,2) process with predefined coefficients.
ARMA(ar=c(0.23,.43, .59), ma=c(0.4,.3))

# Creates an ARMA(3,2) process with predefined coefficients and standard deviation
ARMA(ar=c(0.23,.43, .59), ma=c(0.4,.3), sigma2 = 1.5)
</code></pre>

<hr>
<h2 id='arma_adapter'>ARMA Adapter to ARMA to WV Process function</h2><span id='topic+arma_adapter'></span>

<h3>Description</h3>

<p>Molds the data so that it works with the arma_to_wv function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>arma_adapter(theta, p, q, tau)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="arma_adapter_+3A_theta">theta</code></td>
<td>
<p>A <code>vec</code> that contains all the parameter estimates.</p>
</td></tr>
<tr><td><code id="arma_adapter_+3A_p">p</code></td>
<td>
<p>A <code>int</code> that indicates the number of AR coefficients</p>
</td></tr>
<tr><td><code id="arma_adapter_+3A_q">q</code></td>
<td>
<p>A <code>int</code> that indicates the number of MA coefficients.</p>
</td></tr>
<tr><td><code id="arma_adapter_+3A_tau">tau</code></td>
<td>
<p>A <code>vec</code> containing the scales e.g. <code class="reqn">2^{\tau}</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The data conversion is more or less a rearrangement of values without using the obj desc.
</p>


<h3>Value</h3>

<p>A <code>vec</code> containing the ARMA to WV results
</p>


<h3>Author(s)</h3>

<p>James Joseph Balamuta (JJB)
</p>

<hr>
<h2 id='arma_draws'>Randomly guess starting parameters for ARMA</h2><span id='topic+arma_draws'></span>

<h3>Description</h3>

<p>Sets starting parameters for each of the given parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>arma_draws(p, q, sigma2_total)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="arma_draws_+3A_p">p</code></td>
<td>
<p>An <code>unsigned int</code> that contains the amount of AR parameters to generate.</p>
</td></tr>
<tr><td><code id="arma_draws_+3A_q">q</code></td>
<td>
<p>An <code>unsigned int</code> that contains the amount of MA parameters to generate.</p>
</td></tr>
<tr><td><code id="arma_draws_+3A_sigma2_total">sigma2_total</code></td>
<td>
<p>A <code>double</code> that contains the sum of all WVs.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>vec</code> containing smart parameter starting guesses to be iterated over.
</p>

<hr>
<h2 id='arma_to_wv'>ARMA process to WV</h2><span id='topic+arma_to_wv'></span>

<h3>Description</h3>

<p>This function computes the Haar Wavelet Variance of an ARMA process
</p>


<h3>Usage</h3>

<pre><code class='language-R'>arma_to_wv(ar, ma, sigma2, tau)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="arma_to_wv_+3A_ar">ar</code></td>
<td>
<p>A <code>vec</code> containing the coefficients of the AR process</p>
</td></tr>
<tr><td><code id="arma_to_wv_+3A_ma">ma</code></td>
<td>
<p>A <code>vec</code> containing the coefficients of the MA process</p>
</td></tr>
<tr><td><code id="arma_to_wv_+3A_sigma2">sigma2</code></td>
<td>
<p>A <code>double</code> containing the residual variance</p>
</td></tr>
<tr><td><code id="arma_to_wv_+3A_tau">tau</code></td>
<td>
<p>A <code>vec</code> containing the scales e.g. <code class="reqn">2^{\tau}</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function is a generic implementation that requires a stationary theoretical autocorrelation function (ACF)
and the ability to transform an ARMA(<code class="reqn">p</code>,<code class="reqn">q</code>) process into an MA(<code class="reqn">\infty</code>) (e.g. infinite MA process).
</p>


<h3>Value</h3>

<p>A <code>vec</code> containing the wavelet variance of the ARMA process.
</p>


<h3>Process Haar Wavelet Variance Formula</h3>

<p>The Autoregressive Order <code class="reqn">p</code> and Moving Average Order <code class="reqn">q</code> (ARMA(<code class="reqn">p</code>,<code class="reqn">q</code>)) process has a Haar Wavelet Variance given by:
</p>
<p style="text-align: center;"><code class="reqn">\frac{{{\tau _j}\left[ {1 - \rho \left( {\frac{{{\tau _j}}}{2}} \right)} \right] + 2\sum\limits_{i = 1}^{\frac{{{\tau _j}}}{2} - 1} {i\left[ {2\rho \left( {\frac{{{\tau _j}}}{2} - i} \right) - \rho \left( i \right) - \rho \left( {{\tau _j} - i} \right)} \right]} }}{{\tau _j^2}}\sigma _X^2</code>
</p>

<p>where <code class="reqn">\sigma _X^2</code> is given by the variance of the ARMA process. 
Furthermore, this assumes that stationarity has been achieved as it directly
</p>

<hr>
<h2 id='arma_to_wv_app'>ARMA process to WV Approximation</h2><span id='topic+arma_to_wv_app'></span>

<h3>Description</h3>

<p>This function computes the (haar) WV of an ARMA process
</p>


<h3>Usage</h3>

<pre><code class='language-R'>arma_to_wv_app(ar, ma, sigma2, tau, alpha = 0.9999)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="arma_to_wv_app_+3A_ar">ar</code></td>
<td>
<p>A <code>vec</code> containing the coefficients of the AR process</p>
</td></tr>
<tr><td><code id="arma_to_wv_app_+3A_ma">ma</code></td>
<td>
<p>A <code>vec</code> containing the coefficients of the MA process</p>
</td></tr>
<tr><td><code id="arma_to_wv_app_+3A_sigma2">sigma2</code></td>
<td>
<p>A <code>double</code> containing the residual variance</p>
</td></tr>
<tr><td><code id="arma_to_wv_app_+3A_tau">tau</code></td>
<td>
<p>A <code>vec</code> containing the scales e.g. <code class="reqn">2^{\tau}</code></p>
</td></tr>
<tr><td><code id="arma_to_wv_app_+3A_alpha">alpha</code></td>
<td>
<p>A <code>double</code> indicating the cutoff.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function provides an approximation to the <code><a href="#topic+arma_to_wv">arma_to_wv</a></code> as computation times
were previously a concern. However, this is no longer the case and, thus, this has been left
in for the curious soul to discover...
</p>


<h3>Value</h3>

<p>A <code>vec</code> containing the wavelet variance of the ARMA process.
</p>


<h3>Process Haar Wavelet Variance Formula</h3>

<p>The Autoregressive Order <code class="reqn">p</code> and Moving Average Order <code class="reqn">q</code> (ARMA(<code class="reqn">p</code>,<code class="reqn">q</code>)) process has a Haar Wavelet Variance given by:
</p>
<p style="text-align: center;"><code class="reqn">\frac{{{\tau _j}\left[ {1 - \rho \left( {\frac{{{\tau _j}}}{2}} \right)} \right] + 2\sum\limits_{i = 1}^{\frac{{{\tau _j}}}{2} - 1} {i\left[ {2\rho \left( {\frac{{{\tau _j}}}{2} - i} \right) - \rho \left( i \right) - \rho \left( {{\tau _j} - i} \right)} \right]} }}{{\tau _j^2}}\sigma _X^2</code>
</p>

<p>where <code class="reqn">\sigma _X^2</code> is given by the variance of the ARMA process. 
Furthermore, this assumes that stationarity has been achieved as it directly
</p>

<hr>
<h2 id='ARMA11'>Definition of an ARMA(1,1)</h2><span id='topic+ARMA11'></span>

<h3>Description</h3>

<p>Definition of an ARMA(1,1)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ARMA11(phi = NULL, theta = NULL, sigma2 = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ARMA11_+3A_phi">phi</code></td>
<td>
<p>A <code>double</code> containing the parameter <code class="reqn">\phi _1</code> (see Note for details).</p>
</td></tr>
<tr><td><code id="ARMA11_+3A_theta">theta</code></td>
<td>
<p>A <code>double</code> containing the parameter <code class="reqn">\theta _1</code> (see Note for details).</p>
</td></tr>
<tr><td><code id="ARMA11_+3A_sigma2">sigma2</code></td>
<td>
<p>A <code>double</code> value for the parameter <code class="reqn">\sigma^2</code> (see Note for details).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A variance is required since the model generation statements utilize 
randomization functions expecting a variance instead of a standard deviation like R.
</p>


<h3>Value</h3>

<p>An S3 object with called ts.model with the following structure:
</p>

<dl>
<dt>process.desc</dt><dd><p><code class="reqn">AR1</code>, <code class="reqn">MA1</code>, <code class="reqn">SIGMA2</code></p>
</dd>
<dt>theta</dt><dd><p><code class="reqn">\phi</code>, <code class="reqn">\theta</code>, <code class="reqn">\sigma^2</code></p>
</dd>
<dt>plength</dt><dd><p>Number of Parameters: 3</p>
</dd>
<dt>print</dt><dd><p>String containing simplified model</p>
</dd>
<dt>obj.desc</dt><dd><p>Depth of Parameters e.g. list(c(1,1,1))</p>
</dd>
<dt>starting</dt><dd><p>Guess Starting values? <code>TRUE</code> or <code>FALSE</code> (e.g. specified value)</p>
</dd>
</dl>



<h3>Note</h3>

<p>We consider the following model: </p>
<p style="text-align: center;"><code class="reqn">X_t = \phi X_{t-1} + \theta_1 \varepsilon_{t-1} + \varepsilon_t,</code>
</p>
<p> where <code class="reqn">\varepsilon_t</code> is iid from a zero 
mean normal distribution with variance <code class="reqn">\sigma^2</code>.
</p>


<h3>Author(s)</h3>

<p>James Balamuta
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Creates an ARMA(1,1) process with predefined coefficients.
ARMA11(phi = .23, theta = .1, sigma2 = 1)

# Creates an ARMA(1,1) process with values to be guessed on callibration.
ARMA11()
</code></pre>

<hr>
<h2 id='arma11_to_wv'>ARMA(1,1) to WV</h2><span id='topic+arma11_to_wv'></span>

<h3>Description</h3>

<p>This function computes the WV (haar) of an Autoregressive Order 1 - Moving Average Order 1 (ARMA(1,1)) process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>arma11_to_wv(phi, theta, sigma2, tau)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="arma11_to_wv_+3A_phi">phi</code></td>
<td>
<p>A <code>double</code> corresponding to the autoregressive term.</p>
</td></tr>
<tr><td><code id="arma11_to_wv_+3A_theta">theta</code></td>
<td>
<p>A <code>double</code> corresponding to the moving average term.</p>
</td></tr>
<tr><td><code id="arma11_to_wv_+3A_sigma2">sigma2</code></td>
<td>
<p>A <code>double</code> the variance of the process.</p>
</td></tr>
<tr><td><code id="arma11_to_wv_+3A_tau">tau</code></td>
<td>
<p>A <code>vec</code> containing the scales e.g. <code class="reqn">2^{\tau}</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is significantly faster than its generalized counter part
<code><a href="#topic+arma_to_wv">arma_to_wv</a></code>
</p>


<h3>Value</h3>

<p>A <code>vec</code> containing the wavelet variance of the ARMA(1,1) process.
</p>


<h3>Process Haar Wavelet Variance Formula</h3>

<p>The Autoregressive Order <code class="reqn">1</code> and Moving Average Order <code class="reqn">1</code> (ARMA(<code class="reqn">1</code>,<code class="reqn">1</code>)) process has a Haar Wavelet Variance given by:
</p>
<p style="text-align: center;"><code class="reqn">\nu _j^2\left( {\phi ,\theta ,{\sigma ^2}} \right) =  - \frac{{2{\sigma ^2}\left( { - \frac{1}{2}{{(\theta  + 1)}^2}\left( {{\phi ^2} - 1} \right){\tau _j} - (\theta  + \phi )(\theta \phi  + 1)\left( {{\phi ^{{\tau _j}}} - 4{\phi ^{\frac{{{\tau _j}}}{2}}} + 3} \right)} \right)}}{{{{(\phi  - 1)}^3}(\phi  + 1)\tau _j^2}}</code>
</p>


<hr>
<h2 id='ARMAacf_cpp'>Compute Theoretical ACF for an ARMA Process</h2><span id='topic+ARMAacf_cpp'></span>

<h3>Description</h3>

<p>Compute the theoretical autocorrelation function for an ARMA process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ARMAacf_cpp(ar,ma,lag_max)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ARMAacf_cpp_+3A_ar">ar</code></td>
<td>
<p>A <code>vector</code> of length p containing AR coefficients</p>
</td></tr>
<tr><td><code id="ARMAacf_cpp_+3A_ma">ma</code></td>
<td>
<p>A <code>vector</code> of length q containing MA coefficients</p>
</td></tr>
<tr><td><code id="ARMAacf_cpp_+3A_lag_max">lag_max</code></td>
<td>
<p>A <code>unsigned integer</code> indicating the maximum lag necessary</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is an implementaiton of the ARMAacf function in R. It is approximately 40x times faster. The benchmark was done on iMac Late 2013 using vecLib as the BLAS.
</p>


<h3>Value</h3>

<p>x A <code>matrix</code> listing values from 1...nx in one column and 1...1, 2...2,....,n...n, in the other
</p>


<h3>Author(s)</h3>

<p>JJB
</p>

<hr>
<h2 id='ARMAtoMA_cpp'>Converting an ARMA Process to an Infinite MA Process</h2><span id='topic+ARMAtoMA_cpp'></span>

<h3>Description</h3>

<p>Takes an ARMA function and converts it to an infinite MA process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ARMAtoMA_cpp(ar, ma, lag_max)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ARMAtoMA_cpp_+3A_ar">ar</code></td>
<td>
<p>A <code>column vector</code> of length p</p>
</td></tr>
<tr><td><code id="ARMAtoMA_cpp_+3A_ma">ma</code></td>
<td>
<p>A <code>column vector</code> of length q</p>
</td></tr>
<tr><td><code id="ARMAtoMA_cpp_+3A_lag_max">lag_max</code></td>
<td>
<p>A <code>int</code> of the largest MA(Inf) coefficient required.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is a port of the base stats package's ARMAtoMA. There is no significant speed difference between the two.
</p>


<h3>Value</h3>

<p>A <code>column vector</code> containing coefficients
</p>


<h3>Author(s)</h3>

<p>R Core Team and JJB
</p>

<hr>
<h2 id='australia'>Quarterly Increase in Stocks Non-Farm Total, Australia</h2><span id='topic+australia'></span>

<h3>Description</h3>

<p>A dataset containing the quarterly increase in stocks non-farm total in Australia, with frequency 4 
starting from September 1959 to March 1991 with a total of 127 observations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>australia
</code></pre>


<h3>Format</h3>

<p>A data frame with 127 rows and 2 variables:
</p>

<dl>
<dt>Quarter</dt><dd><p>year and quarter</p>
</dd>
<dt>Increase</dt><dd><p>quarterly increase in stocks non-farm total</p>
</dd>
</dl>



<h3>Source</h3>

<p>Time Series Data Library (citing: Australian Bureau of Statistics) datamarket
</p>

<hr>
<h2 id='auto_corr'>Empirical ACF and PACF</h2><span id='topic+auto_corr'></span>

<h3>Description</h3>

<p>This function can estimate either the autocovariance / autocorrelation for univariate time series,
or the partial autocovariance / autocorrelation for univariate time series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>auto_corr(
  x,
  lag.max = NULL,
  pacf = FALSE,
  type = "correlation",
  demean = TRUE,
  robust = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="auto_corr_+3A_x">x</code></td>
<td>
<p>A <code>vector</code> or <code>ts</code> object (of length <code class="reqn">N &gt; 1</code>).</p>
</td></tr>
<tr><td><code id="auto_corr_+3A_lag.max">lag.max</code></td>
<td>
<p>An <code>integer</code> indicating the maximum lag up to which to compute the empirical ACF / PACF.</p>
</td></tr>
<tr><td><code id="auto_corr_+3A_pacf">pacf</code></td>
<td>
<p>A <code>boolean</code> indicating whether to output the PACF. 
If it's <code>TRUE</code>, then the function will only estimate the empirical PACF. If it's <code>FALSE</code> (the default),
then the function will only estimate the empirical ACF.</p>
</td></tr>
<tr><td><code id="auto_corr_+3A_type">type</code></td>
<td>
<p>A <code>character</code> string giving the type of acf to be computed. Allowed values are &quot;correlation&quot; (the default) and &quot;covariance&quot;.</p>
</td></tr>
<tr><td><code id="auto_corr_+3A_demean">demean</code></td>
<td>
<p>A <code>boolean</code> indicating whether the data should be detrended (<code>TRUE</code>) or not (<code>FALSE</code>). Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="auto_corr_+3A_robust">robust</code></td>
<td>
<p>A <code>boolean</code> indicating whether a robust estimator should be used (<code>TRUE</code>) or not (<code>FALSE</code>). Defaults to <code>FALSE</code>.
This only works when the function is estimating ACF.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>lagmax</code> default is <code class="reqn">10*log10(N/m)</code> where <code class="reqn">N</code> is the number of
observations and <code class="reqn">m</code> is the number of time series being compared. If 
<code>lagmax</code> supplied is greater than the number of observations N, then one
less than the total will be taken (i.e. N - 1).
</p>


<h3>Value</h3>

<p>An <code>array</code> of dimensions <code class="reqn">N \times 1 \times 1</code>.
</p>


<h3>Author(s)</h3>

<p>Yuming Zhang
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m = auto_corr(datasets::AirPassengers)
m = auto_corr(datasets::AirPassengers, pacf = TRUE)
</code></pre>

<hr>
<h2 id='auto_imu_cpp'>Find the auto imu result</h2><span id='topic+auto_imu_cpp'></span>

<h3>Description</h3>

<p>Provides the core material to create an S3 object for auto.imu
</p>


<h3>Usage</h3>

<pre><code class='language-R'>auto_imu_cpp(
  data,
  combs,
  full_model,
  alpha,
  compute_v,
  model_type,
  K,
  H,
  G,
  robust,
  eff,
  bs_optimism,
  seed
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="auto_imu_cpp_+3A_data">data</code></td>
<td>
<p>A <code>mat</code> containing multiple columns of independent data with the same number of observations.</p>
</td></tr>
<tr><td><code id="auto_imu_cpp_+3A_full_model">full_model</code></td>
<td>
<p>A <code>vector&lt;string&gt;</code> that contains the largest / full model.</p>
</td></tr>
<tr><td><code id="auto_imu_cpp_+3A_alpha">alpha</code></td>
<td>
<p>A <code>double</code> that indicates the alpha level for CIs.</p>
</td></tr>
<tr><td><code id="auto_imu_cpp_+3A_compute_v">compute_v</code></td>
<td>
<p>A <code>string</code> indicating the type of V matrix to generate</p>
</td></tr>
<tr><td><code id="auto_imu_cpp_+3A_model_type">model_type</code></td>
<td>
<p>A <code>string</code> that describes the model generation / transformation: 'ssm' or 'imu'</p>
</td></tr>
<tr><td><code id="auto_imu_cpp_+3A_k">K</code></td>
<td>
<p>A <code>int</code> that controls how many times the GMWM is run.</p>
</td></tr>
<tr><td><code id="auto_imu_cpp_+3A_h">H</code></td>
<td>
<p>A <code>int</code> that controls how many bootstraps occur.</p>
</td></tr>
<tr><td><code id="auto_imu_cpp_+3A_g">G</code></td>
<td>
<p>A <code>int</code> that controls how many guesses occur.</p>
</td></tr>
<tr><td><code id="auto_imu_cpp_+3A_robust">robust</code></td>
<td>
<p>A <code>bool</code> that indicates whether to use classical or robust wavelet variance.</p>
</td></tr>
<tr><td><code id="auto_imu_cpp_+3A_eff">eff</code></td>
<td>
<p>A <code>double</code> that indicates the efficiency to use.</p>
</td></tr>
<tr><td><code id="auto_imu_cpp_+3A_bs_optimism">bs_optimism</code></td>
<td>
<p>A <code>bool</code> that indicates whether the model selection score should be calculated with bootstrap or asymptotics.</p>
</td></tr>
<tr><td><code id="auto_imu_cpp_+3A_seed">seed</code></td>
<td>
<p>A <code>unsigned int</code> that is the seed one wishes to use.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>field&lt;field&lt;field&lt;mat&gt;&gt;&gt;</code> that contains the model score matrix and the best GMWM model object.
</p>

<hr>
<h2 id='B_matrix'>B Matrix</h2><span id='topic+B_matrix'></span>

<h3>Description</h3>

<p>B Matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>B_matrix(A, at_omega)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="B_matrix_+3A_a">A</code></td>
<td>
<p>A <code>mat</code> containing the first derivatives of the process.</p>
</td></tr>
<tr><td><code id="B_matrix_+3A_at_omega">at_omega</code></td>
<td>
<p>A <code>mat</code> containing A^T * Omega</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>mat</code>
</p>

<hr>
<h2 id='batch_modwt_wvar_cpp'>Computes the MO/DWT wavelet variance for multiple processes</h2><span id='topic+batch_modwt_wvar_cpp'></span>

<h3>Description</h3>

<p>Calculates the MO/DWT wavelet variance
</p>


<h3>Usage</h3>

<pre><code class='language-R'>batch_modwt_wvar_cpp(
  signal,
  nlevels,
  robust,
  eff,
  alpha,
  ci_type,
  strWavelet,
  decomp
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="batch_modwt_wvar_cpp_+3A_signal">signal</code></td>
<td>
<p>A <code>matrix</code> that contains the same number of observations per dataset</p>
</td></tr>
<tr><td><code id="batch_modwt_wvar_cpp_+3A_robust">robust</code></td>
<td>
<p>A <code>boolean</code> that triggers the use of the robust estimate.</p>
</td></tr>
<tr><td><code id="batch_modwt_wvar_cpp_+3A_eff">eff</code></td>
<td>
<p>A <code>double</code> that indicates the efficiency as it relates to an MLE.</p>
</td></tr>
<tr><td><code id="batch_modwt_wvar_cpp_+3A_alpha">alpha</code></td>
<td>
<p>A <code>double</code> that indicates the <code class="reqn">\left(1-p\right)\times \alpha</code> confidence level</p>
</td></tr>
<tr><td><code id="batch_modwt_wvar_cpp_+3A_ci_type">ci_type</code></td>
<td>
<p>A <code>string</code> indicating the confidence interval being calculated. Valid value: &quot;eta3&quot;</p>
</td></tr>
<tr><td><code id="batch_modwt_wvar_cpp_+3A_strwavelet">strWavelet</code></td>
<td>
<p>A <code>string</code> indicating the type of wave filter to be applied. Must be &quot;haar&quot;</p>
</td></tr>
<tr><td><code id="batch_modwt_wvar_cpp_+3A_decomp">decomp</code></td>
<td>
<p>A <code>string</code> indicating whether to use &quot;modwt&quot; or &quot;dwt&quot; decomp</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function processes the decomposition of multiple signals quickly
</p>


<h3>Value</h3>

<p>A <code>field&lt;mat&gt;</code> with the structure:
</p>

<ul>
<li><p>&quot;variance&quot;Wavelet Variance
</p>
</li>
<li><p>&quot;low&quot;Lower CI
</p>
</li>
<li><p>&quot;high&quot;Upper CI
</p>
</li></ul>


<hr>
<h2 id='best_model'>Select the Best Model</h2><span id='topic+best_model'></span>

<h3>Description</h3>

<p>This function retrieves the best model from a selection procedure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>best_model(x, ic = "aic")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="best_model_+3A_x">x</code></td>
<td>
<p>An object of class
<code><a href="#topic+select_arma">select_arma</a></code>, <code><a href="#topic+select_ar">select_ar</a></code> or <code><a href="#topic+select_ma">select_ma</a></code>.</p>
</td></tr>
<tr><td><code id="best_model_+3A_ic">ic</code></td>
<td>
<p>A <code>string</code> indicating the type of criterion to use in selecting the best model. 
Supported criteria include &quot;aic&quot; (AIC), &quot;bic&quot; (BIC) and &quot;hq&quot; (HQ).</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'> 
set.seed(18)
xt = gen_arima(N=100, ar=0.3, d=1, ma=0.3)
x = select_arima(xt, d=1L)
best_model(x, ic = "aic")

set.seed(19)
xt = gen_ma1(100, 0.3, 1)
x = select_ma(xt, q.min=2L, q.max=5L)
best_model(x, ic = "bic")

set.seed(20)
xt = gen_arma(100, c(.3,.5), c(.1), 1, 0)  
x = select_arma(xt, p.min = 1L, p.max = 4L,
                q.min = 1L, q.max = 3L)
best_model(x, ic = "hq")

</code></pre>

<hr>
<h2 id='bl14_filter'>bl14 filter construction</h2><span id='topic+bl14_filter'></span>

<h3>Description</h3>

<p>Creates the bl14 filter
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bl14_filter()
</code></pre>


<h3>Details</h3>

<p>This template can be used to increase the amount of filters available for selection.
</p>


<h3>Value</h3>

<p>A <code>field&lt;vec&gt;</code> that contains:
</p>

<ul>
<li><p>&quot;L&quot;A <code>integer</code> specifying the length of the filter
</p>
</li>
<li><p>&quot;h&quot;A <code>vector</code> containing the coefficients for the wavelet filter
</p>
</li>
<li><p>&quot;g&quot;A <code>vector</code> containing the coefficients for the scaling filter
</p>
</li></ul>



<h3>Author(s)</h3>

<p>JJB
</p>

<hr>
<h2 id='bl20_filter'>bl20 filter construction</h2><span id='topic+bl20_filter'></span>

<h3>Description</h3>

<p>Creates the bl20 filter
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bl20_filter()
</code></pre>


<h3>Details</h3>

<p>This template can be used to increase the amount of filters available for selection.
</p>


<h3>Value</h3>

<p>A <code>field&lt;vec&gt;</code> that contains:
</p>

<ul>
<li><p>&quot;L&quot;A <code>integer</code> specifying the length of the filter
</p>
</li>
<li><p>&quot;h&quot;A <code>vector</code> containing the coefficients for the wavelet filter
</p>
</li>
<li><p>&quot;g&quot;A <code>vector</code> containing the coefficients for the scaling filter
</p>
</li></ul>



<h3>Author(s)</h3>

<p>JJB
</p>

<hr>
<h2 id='boot_pval_gof'>Generate the Confidence Interval for GOF Bootstrapped</h2><span id='topic+boot_pval_gof'></span>

<h3>Description</h3>

<p>yaya
</p>


<h3>Usage</h3>

<pre><code class='language-R'>boot_pval_gof(obj, obj_boot, B = 1000L, alpha = 0.05)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="boot_pval_gof_+3A_obj">obj</code></td>
<td>
<p>A <code>double</code> containing the objective value of the solution.</p>
</td></tr>
<tr><td><code id="boot_pval_gof_+3A_obj_boot">obj_boot</code></td>
<td>
<p>A <code>vec</code> containing the objective values obtained while bootstrapping under Theta_hat.</p>
</td></tr>
<tr><td><code id="boot_pval_gof_+3A_b">B</code></td>
<td>
<p>An <code>int</code> indicating how many times the bootstrapper should be run.</p>
</td></tr>
<tr><td><code id="boot_pval_gof_+3A_alpha">alpha</code></td>
<td>
<p>A <code>double</code> indicating the amount of confidence for CI</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>vec</code> that has the alpha/2.0 quantile and then the 1-alpha/2.0 quantile.
</p>

<hr>
<h2 id='bootstrap_gof_test'>Compute the Bootstrapped GoF Test</h2><span id='topic+bootstrap_gof_test'></span>

<h3>Description</h3>

<p>Handles the bootstrap computation and the bootstrapped p-value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bootstrap_gof_test(obj_value, bs_obj_values, alpha, bs_gof_p_ci)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bootstrap_gof_test_+3A_obj_value">obj_value</code></td>
<td>
<p>A <code>double</code> that contains the optimized objective function value.</p>
</td></tr>
<tr><td><code id="bootstrap_gof_test_+3A_bs_obj_values">bs_obj_values</code></td>
<td>
<p>A <code>vec</code> that contains the objective function values under bootstrap.</p>
</td></tr>
<tr><td><code id="bootstrap_gof_test_+3A_alpha">alpha</code></td>
<td>
<p>A <code>double</code> that indicates the confidence.</p>
</td></tr>
<tr><td><code id="bootstrap_gof_test_+3A_bs_gof_p_ci">bs_gof_p_ci</code></td>
<td>
<p>A <code>bool</code> that indicates whether CIs should be included or not.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>vec</code> that has
</p>

<ul>
<li><p> Test Statistic
</p>
</li>
<li><p> Low CI
</p>
</li>
<li><p> Upper CI - BS
</p>
</li></ul>


<hr>
<h2 id='brick_wall'>Removal of Boundary Wavelet Coefficients</h2><span id='topic+brick_wall'></span>

<h3>Description</h3>

<p>Removes the first n wavelet coefficients.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>brick_wall(x, wave_filter, method)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="brick_wall_+3A_x">x</code></td>
<td>
<p>A <code>field&lt;vec&gt;</code> that contains the nlevel decomposition using either modwt or dwt.</p>
</td></tr>
<tr><td><code id="brick_wall_+3A_wave_filter">wave_filter</code></td>
<td>
<p>A <code>field&lt;vec&gt;</code> containing filter information. Only &quot;haar&quot; is implemented.</p>
</td></tr>
<tr><td><code id="brick_wall_+3A_method">method</code></td>
<td>
<p>A <code>string</code> to describe the mode. Choose between &quot;modwt&quot; and &quot;dwt&quot;</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The vectors are truncated by removing the first n wavelet coefficients. 
These vectors are then stored into the field that is returned.
Note: As a result, there are no NA's introduced and hence the na.omit is not needed.
</p>


<h3>Value</h3>

<p>A <code>field&lt;vec&gt;</code> with boundary modwt or dwt taken care of.
</p>

<hr>
<h2 id='build_model_set'>Build List of Unique Models</h2><span id='topic+build_model_set'></span>

<h3>Description</h3>

<p>Creates a set containing unique strings.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>build_model_set(combs, x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="build_model_set_+3A_combs">combs</code></td>
<td>
<p>A <code>mat</code> that is a binary matrix (0,1) containing the combinations of different variables.</p>
</td></tr>
<tr><td><code id="build_model_set_+3A_x">x</code></td>
<td>
<p>A <code>vec&lt;string&gt;</code> that contains a list of model descriptors.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>set&lt;string&gt;</code> that contains the list of unique models.
</p>

<hr>
<h2 id='calculate_psi_matrix'>Calculate the Psi matrix</h2><span id='topic+calculate_psi_matrix'></span>

<h3>Description</h3>

<p>Computes the Psi matrix using supplied parameters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculate_psi_matrix(A, v_hat, omega)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calculate_psi_matrix_+3A_a">A</code></td>
<td>
<p>first derivative matrix</p>
</td></tr>
<tr><td><code id="calculate_psi_matrix_+3A_v_hat">v_hat</code></td>
<td>
<p>bootstrapped V</p>
</td></tr>
<tr><td><code id="calculate_psi_matrix_+3A_omega">omega</code></td>
<td>
<p>original omega matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>mat</code> that has the first column
</p>

<hr>
<h2 id='cfilter'>Time Series Convolution Filters</h2><span id='topic+cfilter'></span>

<h3>Description</h3>

<p>Applies a convolution filter to a univariate time series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cfilter(x, filter, sides, circular)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cfilter_+3A_x">x</code></td>
<td>
<p>A <code>column vector</code> of length T</p>
</td></tr>
<tr><td><code id="cfilter_+3A_filter">filter</code></td>
<td>
<p>A <code>column vector</code> of length f</p>
</td></tr>
<tr><td><code id="cfilter_+3A_sides">sides</code></td>
<td>
<p>An <code>int</code> that takes either 1:for using past values only or 2: filter coefficients are centered around lag 0.</p>
</td></tr>
<tr><td><code id="cfilter_+3A_circular">circular</code></td>
<td>
<p>A <code>bool</code> that indicates if the filter should be wrapped around the ends of the time series.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a port of the cfilter function harnessed by the filter function in stats. 
It is about 5-7 times faster than R's base function. The benchmark was done on iMac Late 2013 using vecLib as the BLAS.
</p>


<h3>Value</h3>

<p>A <code>column vec</code> that contains the results of the filtering process.
</p>


<h3>Author(s)</h3>

<p>R Core Team and JJB
</p>

<hr>
<h2 id='check'>Diagnostics on Fitted Time Series Model</h2><span id='topic+check'></span>

<h3>Description</h3>

<p>This function can perform (simple) diagnostics on the fitted time series model.
It can output 6 diagnostic plots to assess the model, including (1) residuals plot,
(2) histogram of distribution of standardized residuals, (3) Normal Q-Q plot of residuals,
(4) ACF plot, (5) PACF plot, (6) Box test results.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check(model = NULL, resids = NULL, simple = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_+3A_model">model</code></td>
<td>
<p>A <code>fitsimts</code>, <code>lm</code> or <code>gam</code> object.</p>
</td></tr>
<tr><td><code id="check_+3A_resids">resids</code></td>
<td>
<p>A <code>vector</code> of residuals for diagnostics.</p>
</td></tr>
<tr><td><code id="check_+3A_simple">simple</code></td>
<td>
<p>A <code>boolean</code> indicating whether to return simple diagnostic plots or not.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Stéphane Guerrier and Yuming Zhang
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Xt = gen_gts(300, AR(phi = c(0, 0, 0.8), sigma2 = 1))
model = estimate(AR(3), Xt)
check(model)

check(resids = rnorm(100))

Xt = gen_gts(1000, SARIMA(ar = c(0.5, -0.25), i = 0, ma = 0.5, sar = -0.8, 
si = 1, sma = 0.25, s = 24, sigma2 = 1))
model = estimate(SARIMA(ar = 2, i = 0, ma = 1, sar = 1, si = 1, sma = 1, s = 24), 
Xt, method = "rgmwm")
check(model)
check(model, simple=TRUE)

</code></pre>

<hr>
<h2 id='ci_eta3'>Generate eta3 confidence interval</h2><span id='topic+ci_eta3'></span>

<h3>Description</h3>

<p>Computes the eta3 CI
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ci_eta3(y, dims, alpha_ov_2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ci_eta3_+3A_y">y</code></td>
<td>
<p>A <code>vec</code> that computes the brickwalled modwt dot product of each wavelet coefficient divided by their length.</p>
</td></tr>
<tr><td><code id="ci_eta3_+3A_dims">dims</code></td>
<td>
<p>A <code>String</code> indicating the confidence interval being calculated.</p>
</td></tr>
<tr><td><code id="ci_eta3_+3A_alpha_ov_2">alpha_ov_2</code></td>
<td>
<p>A <code>double</code> that indicates the <code class="reqn">\left(1-p\right)*\alpha</code> confidence level</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>matrix</code> with the structure:
</p>

<ul>
<li><p>Column 1Wavelet Variance
</p>
</li>
<li><p>Column 2Chi-squared Lower Bounds
</p>
</li>
<li><p>Column 3Chi-squared Upper Bounds
</p>
</li></ul>


<hr>
<h2 id='ci_eta3_robust'>Generate eta3 robust confidence interval</h2><span id='topic+ci_eta3_robust'></span>

<h3>Description</h3>

<p>Computes the eta3 robust CI
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ci_eta3_robust(wv_robust, wv_ci_class, alpha_ov_2, eff)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ci_eta3_robust_+3A_wv_robust">wv_robust</code></td>
<td>
<p>A <code>vec</code> that computes the brickwalled modwt dot product of each wavelet coefficient divided by their length.</p>
</td></tr>
<tr><td><code id="ci_eta3_robust_+3A_wv_ci_class">wv_ci_class</code></td>
<td>
<p>A <code>mat</code> that contains the CI mean, CI Lower, and CI Upper</p>
</td></tr>
<tr><td><code id="ci_eta3_robust_+3A_alpha_ov_2">alpha_ov_2</code></td>
<td>
<p>A <code>double</code> that indicates the <code class="reqn">\left(1-p\right)*\alpha</code> confidence level</p>
</td></tr>
<tr><td><code id="ci_eta3_robust_+3A_eff">eff</code></td>
<td>
<p>A <code>double</code> that indicates the efficiency.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Within this function we are scaling the classical
</p>


<h3>Value</h3>

<p>A <code>matrix</code> with the structure:
</p>

<ul>
<li><p>Column 1Robust Wavelet Variance
</p>
</li>
<li><p>Column 2Chi-squared Lower Bounds
</p>
</li>
<li><p>Column 3Chi-squared Upper Bounds
</p>
</li></ul>


<hr>
<h2 id='ci_wave_variance'>Generate a Confidence intervval for a Univariate Time Series</h2><span id='topic+ci_wave_variance'></span>

<h3>Description</h3>

<p>Computes an estimate of the multiscale variance and a chi-squared confidence interval
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ci_wave_variance(
  signal_modwt_bw,
  wv,
  type = "eta3",
  alpha_ov_2 = 0.025,
  robust = FALSE,
  eff = 0.6
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ci_wave_variance_+3A_signal_modwt_bw">signal_modwt_bw</code></td>
<td>
<p>A <code>field&lt;vec&gt;</code> that contains the brick walled modwt or dwt decomposition</p>
</td></tr>
<tr><td><code id="ci_wave_variance_+3A_wv">wv</code></td>
<td>
<p>A <code>vec</code> that contains the wave variance.</p>
</td></tr>
<tr><td><code id="ci_wave_variance_+3A_type">type</code></td>
<td>
<p>A <code>String</code> indicating the confidence interval being calculated.</p>
</td></tr>
<tr><td><code id="ci_wave_variance_+3A_alpha_ov_2">alpha_ov_2</code></td>
<td>
<p>A <code>double</code> that indicates the <code class="reqn">\left(1-p\right)*\alpha</code> confidence level.</p>
</td></tr>
<tr><td><code id="ci_wave_variance_+3A_robust">robust</code></td>
<td>
<p>A <code>boolean</code> to determine the type of wave estimation.</p>
</td></tr>
<tr><td><code id="ci_wave_variance_+3A_eff">eff</code></td>
<td>
<p>A <code>double</code> that indicates the efficiency.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function can be expanded to allow for other confidence interval calculations.
</p>


<h3>Value</h3>

<p>A <code>matrix</code> with the structure:
</p>

<ul>
<li><p>Column 1Wavelet Variance
</p>
</li>
<li><p>Column 2Chi-squared Lower Bounds
</p>
</li>
<li><p>Column 3Chi-squared Upper Bounds
</p>
</li></ul>


<hr>
<h2 id='code_zero'>Optim loses NaN</h2><span id='topic+code_zero'></span>

<h3>Description</h3>

<p>This function takes numbers that are very small and sets them to the minimal tolerance for C++.
Doing this prevents NaN from entering the optim routine.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>code_zero(theta)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="code_zero_+3A_theta">theta</code></td>
<td>
<p>A <code>vec</code> that contains estimated GMWM theta values (untransformed).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>vec</code> that contains safe theta values.
</p>

<hr>
<h2 id='comb'>Combine math expressions</h2><span id='topic+comb'></span>

<h3>Description</h3>

<p>Combine math expressions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>comb(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="comb_+3A_...">...</code></td>
<td>
<p>Expressions to combine.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A combined expression.
</p>


<h3>Author(s)</h3>

<p>Stephane Guerrier
</p>

<hr>
<h2 id='compare_acf'>Comparison of Classical and Robust Correlation Analysis Functions</h2><span id='topic+compare_acf'></span>

<h3>Description</h3>

<p>Compare classical and robust ACF
of univariate time series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compare_acf(
  x,
  lag.max = NULL,
  demean = TRUE,
  show.ci = TRUE,
  alpha = 0.05,
  plot = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compare_acf_+3A_x">x</code></td>
<td>
<p>A <code>vector</code> or <code>"ts"</code> object (of length <code class="reqn">N &gt; 1</code>).</p>
</td></tr>
<tr><td><code id="compare_acf_+3A_lag.max">lag.max</code></td>
<td>
<p>A <code>integer</code> indicating the maximum lag up to which to compute the ACF and PACF functions.</p>
</td></tr>
<tr><td><code id="compare_acf_+3A_demean">demean</code></td>
<td>
<p>A <code>bool</code> indicating whether the data should be detrended (<code>TRUE</code>) or not (<code>FALSE</code>). Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="compare_acf_+3A_show.ci">show.ci</code></td>
<td>
<p>A <code>bool</code> indicating whether to compute and show the confidence region. Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="compare_acf_+3A_alpha">alpha</code></td>
<td>
<p>A <code>double</code> indicating the level of significance for the confidence interval. By default <code>alpha = 0.05</code> which gives a 1 - <code>alpha</code> = 0.95 confidence interval.</p>
</td></tr>
<tr><td><code id="compare_acf_+3A_plot">plot</code></td>
<td>
<p>A <code>bool</code> indicating whether a plot of the computed quantities should be produced. Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="compare_acf_+3A_...">...</code></td>
<td>
<p>Additional parameters.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Yunxiang Zhang
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Estimate both the ACF and PACF functions
compare_acf(datasets::AirPassengers)
</code></pre>

<hr>
<h2 id='compute_cov_cpp'>Computes the (MODWT) wavelet covariance matrix</h2><span id='topic+compute_cov_cpp'></span>

<h3>Description</h3>

<p>Calculates the (MODWT) wavelet covariance matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_cov_cpp(
  signal_modwt,
  nb_level,
  compute_v = "diag",
  robust = TRUE,
  eff = 0.6
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute_cov_cpp_+3A_signal_modwt">signal_modwt</code></td>
<td>
<p>A <code>field&lt;vec&gt;</code> that contains the modwt decomposition.</p>
</td></tr>
<tr><td><code id="compute_cov_cpp_+3A_nb_level">nb_level</code></td>
<td>
<p>A <code>integer</code> that contains the level of decomposition J.</p>
</td></tr>
<tr><td><code id="compute_cov_cpp_+3A_compute_v">compute_v</code></td>
<td>
<p>A <code>string</code> that indicates what kind of matrix should be created. Possible options: &quot;diag&quot; or &quot;none&quot;</p>
</td></tr>
<tr><td><code id="compute_cov_cpp_+3A_robust">robust</code></td>
<td>
<p>A <code>boolean</code> that triggers the use of the robust estimate.</p>
</td></tr>
<tr><td><code id="compute_cov_cpp_+3A_eff">eff</code></td>
<td>
<p>A <code>double</code> that indicates the efficiency as it relates to an MLE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>field&lt;mat&gt;</code> containing the covariance matrix.
</p>

<hr>
<h2 id='conv.ar1.to.gm'>GM Conversion</h2><span id='topic+conv.ar1.to.gm'></span><span id='topic+conv.gm.to.ar1'></span>

<h3>Description</h3>

<p>Convert from AR1 to GM and vice-versa
</p>


<h3>Usage</h3>

<pre><code class='language-R'>conv.ar1.to.gm(theta, process.desc, freq)

conv.gm.to.ar1(theta, process.desc, freq)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="conv.ar1.to.gm_+3A_theta">theta</code></td>
<td>
<p>A <code>numeric vector</code> containing the theta values</p>
</td></tr>
<tr><td><code id="conv.ar1.to.gm_+3A_process.desc">process.desc</code></td>
<td>
<p>A <code>character vector</code> containing the names of parameters.</p>
</td></tr>
<tr><td><code id="conv.ar1.to.gm_+3A_freq">freq</code></td>
<td>
<p>A <code>double</code> indicating the frequency of the data.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>James Balamuta
</p>

<hr>
<h2 id='corr_analysis'>Correlation Analysis Functions</h2><span id='topic+corr_analysis'></span>

<h3>Description</h3>

<p>Correlation Analysis function computes and plots both empirical ACF and PACF
of univariate time series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>corr_analysis(
  x,
  lag.max = NULL,
  type = "correlation",
  demean = TRUE,
  show.ci = TRUE,
  alpha = 0.05,
  plot = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="corr_analysis_+3A_x">x</code></td>
<td>
<p>A <code>vector</code> or <code>"ts"</code> object (of length <code class="reqn">N &gt; 1</code>).</p>
</td></tr>
<tr><td><code id="corr_analysis_+3A_lag.max">lag.max</code></td>
<td>
<p>A <code>integer</code> indicating the maximum lag up to which to compute the ACF and PACF functions.</p>
</td></tr>
<tr><td><code id="corr_analysis_+3A_type">type</code></td>
<td>
<p>A <code>character</code> string giving the type of acf to be computed. Allowed values are &quot;correlation&quot; (the default) and &quot;covariance&quot;.</p>
</td></tr>
<tr><td><code id="corr_analysis_+3A_demean">demean</code></td>
<td>
<p>A <code>bool</code> indicating whether the data should be detrended (<code>TRUE</code>) or not (<code>FALSE</code>). Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="corr_analysis_+3A_show.ci">show.ci</code></td>
<td>
<p>A <code>bool</code> indicating whether to compute and show the confidence region. Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="corr_analysis_+3A_alpha">alpha</code></td>
<td>
<p>A <code>double</code> indicating the level of significance for the confidence interval. By default <code>alpha = 0.05</code> which gives a 1 - <code>alpha</code> = 0.95 confidence interval.</p>
</td></tr>
<tr><td><code id="corr_analysis_+3A_plot">plot</code></td>
<td>
<p>A <code>bool</code> indicating whether a plot of the computed quantities should be produced. Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="corr_analysis_+3A_...">...</code></td>
<td>
<p>Additional parameters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Two <code>array</code> objects (ACF and PACF) of dimension <code class="reqn">N \times S \times S</code>.
</p>


<h3>Author(s)</h3>

<p>Yunxiang Zhang
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Estimate both the ACF and PACF functions
corr_analysis(datasets::AirPassengers)
</code></pre>

<hr>
<h2 id='count_models'>Count Models</h2><span id='topic+count_models'></span>

<h3>Description</h3>

<p>Count the amount of models that exist.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>count_models(desc)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="count_models_+3A_desc">desc</code></td>
<td>
<p>A <code>vector&lt;string&gt;</code> that contains the model's components.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>map&lt;string, int&gt;</code> containing how frequent the model component appears.
</p>

<hr>
<h2 id='cov_bootstrapper'>Bootstrap for Matrix V</h2><span id='topic+cov_bootstrapper'></span>

<h3>Description</h3>

<p>Using the bootstrap approach, we simulate a model based on user supplied parameters, obtain the wavelet variance, and then V.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cov_bootstrapper(theta, desc, objdesc, N, robust, eff, H, diagonal_matrix)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cov_bootstrapper_+3A_theta">theta</code></td>
<td>
<p>A <code>vector</code> with dimensions N x 1 that contains user-supplied initial values for parameters</p>
</td></tr>
<tr><td><code id="cov_bootstrapper_+3A_desc">desc</code></td>
<td>
<p>A <code>vector&lt;string&gt;</code> indicating the models that should be considered.</p>
</td></tr>
<tr><td><code id="cov_bootstrapper_+3A_objdesc">objdesc</code></td>
<td>
<p>A <code>field&lt;vec&gt;</code> that contains an object description (e.g. values) of the model.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Expand in detail...
</p>


<h3>Value</h3>

<p>A <code>vec</code> that contains the parameter estimates from GMWM estimator.
</p>


<h3>Author(s)</h3>

<p>JJB
</p>

<hr>
<h2 id='create_imu'>Internal IMU Object Construction</h2><span id='topic+create_imu'></span>

<h3>Description</h3>

<p>Internal quick build for imu object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_imu(
  data,
  ngyros,
  nacces,
  axis,
  freq,
  unit = NULL,
  name = NULL,
  stype = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create_imu_+3A_data">data</code></td>
<td>
<p>A <code>matrix</code> with dimensions N x length(index)</p>
</td></tr>
<tr><td><code id="create_imu_+3A_ngyros">ngyros</code></td>
<td>
<p>An <code>integer</code> containing the number of gyroscopes</p>
</td></tr>
<tr><td><code id="create_imu_+3A_nacces">nacces</code></td>
<td>
<p>An <code>integer</code> containing the number of accelerometers</p>
</td></tr>
<tr><td><code id="create_imu_+3A_axis">axis</code></td>
<td>
<p>A <code>vector</code> unique representation of elements e.g. x,y,z or x,y or x.</p>
</td></tr>
<tr><td><code id="create_imu_+3A_freq">freq</code></td>
<td>
<p>An <code>integer</code> that provides the frequency for the data.</p>
</td></tr>
<tr><td><code id="create_imu_+3A_unit">unit</code></td>
<td>
<p>A <code>string</code> that contains the unit expression of the frequency. Default value is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="create_imu_+3A_name">name</code></td>
<td>
<p>A <code>string</code> that provides an identifier to the data. Default value is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="create_imu_+3A_stype">stype</code></td>
<td>
<p>A <code>string</code> that describes the sensor type. Default value is <code>NULL</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code>imu</code> object class.
</p>


<h3>Author(s)</h3>

<p>James Balamuta
</p>

<hr>
<h2 id='custom_legend'>Custom legend function</h2><span id='topic+custom_legend'></span>

<h3>Description</h3>

<p>Legend placement function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>custom_legend(x, usr = par("usr"), ...)
</code></pre>

<hr>
<h2 id='D_matrix'>Analytic D matrix of Processes</h2><span id='topic+D_matrix'></span>

<h3>Description</h3>

<p>This function computes each process to WV (haar) in a given model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>D_matrix(theta, desc, objdesc, tau, omegadiff)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="D_matrix_+3A_theta">theta</code></td>
<td>
<p>A <code>vec</code> containing the list of estimated parameters.</p>
</td></tr>
<tr><td><code id="D_matrix_+3A_desc">desc</code></td>
<td>
<p>A <code>vector&lt;string&gt;</code> containing a list of descriptors.</p>
</td></tr>
<tr><td><code id="D_matrix_+3A_objdesc">objdesc</code></td>
<td>
<p>A <code>field&lt;vec&gt;</code> containing a list of object descriptors.</p>
</td></tr>
<tr><td><code id="D_matrix_+3A_tau">tau</code></td>
<td>
<p>A <code>vec</code> containing the scales e.g. <code class="reqn">2^{\tau}</code></p>
</td></tr>
<tr><td><code id="D_matrix_+3A_omegadiff">omegadiff</code></td>
<td>
<p>A <code>vec</code> that contains the result of Omega * (wv_empir - wv_theo)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function returns the matrix effectively known as &quot;D&quot;
</p>


<h3>Value</h3>

<p>A <code>matrix</code> with the process derivatives going down the column
</p>


<h3>Author(s)</h3>

<p>James Joseph Balamuta (JJB)
</p>

<hr>
<h2 id='d16_filter'>d16 filter construction</h2><span id='topic+d16_filter'></span>

<h3>Description</h3>

<p>Creates the d16 filter
</p>


<h3>Usage</h3>

<pre><code class='language-R'>d16_filter()
</code></pre>


<h3>Details</h3>

<p>This template can be used to increase the amount of filters available for selection.
</p>


<h3>Value</h3>

<p>A <code>field&lt;vec&gt;</code> that contains:
</p>

<ul>
<li><p>&quot;L&quot;A <code>integer</code> specifying the length of the filter
</p>
</li>
<li><p>&quot;h&quot;A <code>vector</code> containing the coefficients for the wavelet filter
</p>
</li>
<li><p>&quot;g&quot;A <code>vector</code> containing the coefficients for the scaling filter
</p>
</li></ul>



<h3>Author(s)</h3>

<p>JJB
</p>

<hr>
<h2 id='d4_filter'>d4 filter construction</h2><span id='topic+d4_filter'></span>

<h3>Description</h3>

<p>Creates the d4 filter
</p>


<h3>Usage</h3>

<pre><code class='language-R'>d4_filter()
</code></pre>


<h3>Details</h3>

<p>This template can be used to increase the amount of filters available for selection.
</p>


<h3>Value</h3>

<p>A <code>field&lt;vec&gt;</code> that contains:
</p>

<ul>
<li><p>&quot;L&quot;A <code>integer</code> specifying the length of the filter
</p>
</li>
<li><p>&quot;h&quot;A <code>vector</code> containing the coefficients for the wavelet filter
</p>
</li>
<li><p>&quot;g&quot;A <code>vector</code> containing the coefficients for the scaling filter
</p>
</li></ul>



<h3>Author(s)</h3>

<p>JJB
</p>

<hr>
<h2 id='d6_filter'>d6 filter construction</h2><span id='topic+d6_filter'></span>

<h3>Description</h3>

<p>Creates the d6 filter
</p>


<h3>Usage</h3>

<pre><code class='language-R'>d6_filter()
</code></pre>


<h3>Details</h3>

<p>This template can be used to increase the amount of filters available for selection.
</p>


<h3>Value</h3>

<p>A <code>field&lt;vec&gt;</code> that contains:
</p>

<ul>
<li><p>&quot;L&quot;A <code>integer</code> specifying the length of the filter
</p>
</li>
<li><p>&quot;h&quot;A <code>vector</code> containing the coefficients for the wavelet filter
</p>
</li>
<li><p>&quot;g&quot;A <code>vector</code> containing the coefficients for the scaling filter
</p>
</li></ul>



<h3>Author(s)</h3>

<p>JJB
</p>

<hr>
<h2 id='d8_filter'>d8 filter construction</h2><span id='topic+d8_filter'></span>

<h3>Description</h3>

<p>Creates the d8 filter
</p>


<h3>Usage</h3>

<pre><code class='language-R'>d8_filter()
</code></pre>


<h3>Details</h3>

<p>This template can be used to increase the amount of filters available for selection.
</p>


<h3>Value</h3>

<p>A <code>field&lt;vec&gt;</code> that contains:
</p>

<ul>
<li><p>&quot;L&quot;A <code>integer</code> specifying the length of the filter
</p>
</li>
<li><p>&quot;h&quot;A <code>vector</code> containing the coefficients for the wavelet filter
</p>
</li>
<li><p>&quot;g&quot;A <code>vector</code> containing the coefficients for the scaling filter
</p>
</li></ul>



<h3>Author(s)</h3>

<p>JJB
</p>

<hr>
<h2 id='decomp_theoretical_wv'>Each Models Process Decomposed to WV</h2><span id='topic+decomp_theoretical_wv'></span>

<h3>Description</h3>

<p>This function computes each process to WV (haar) in a given model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>decomp_theoretical_wv(theta, desc, objdesc, tau)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="decomp_theoretical_wv_+3A_theta">theta</code></td>
<td>
<p>A <code>vec</code> containing the list of estimated parameters.</p>
</td></tr>
<tr><td><code id="decomp_theoretical_wv_+3A_desc">desc</code></td>
<td>
<p>A <code>vector&lt;string&gt;</code> containing a list of descriptors.</p>
</td></tr>
<tr><td><code id="decomp_theoretical_wv_+3A_objdesc">objdesc</code></td>
<td>
<p>A <code>field&lt;vec&gt;</code> containing a list of object descriptors.</p>
</td></tr>
<tr><td><code id="decomp_theoretical_wv_+3A_tau">tau</code></td>
<td>
<p>A <code>vec</code> containing the scales e.g. <code class="reqn">2^{\tau}</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>mat</code> containing the wavelet variance of each process in the model
</p>

<hr>
<h2 id='decomp_to_theo_wv'>Decomposed WV to Single WV</h2><span id='topic+decomp_to_theo_wv'></span>

<h3>Description</h3>

<p>This function computes the combined processes to WV (haar) in a given model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>decomp_to_theo_wv(decomp)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="decomp_to_theo_wv_+3A_decomp">decomp</code></td>
<td>
<p>A <code>mat</code> with scales as rows and processes as columns</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>vec</code> containing the wavelet variance of the process for the overall model
</p>

<hr>
<h2 id='deriv_2nd_ar1'>Analytic second derivative matrix for AR(1) process</h2><span id='topic+deriv_2nd_ar1'></span>

<h3>Description</h3>

<p>Calculates the second derivative for the AR(1) process and places it into a matrix form.
The matrix form in this case is for convenience of the calculation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>deriv_2nd_ar1(phi, sigma2, tau)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="deriv_2nd_ar1_+3A_phi">phi</code></td>
<td>
<p>A <code>double</code> corresponding to the phi coefficient of an AR(1) process.</p>
</td></tr>
<tr><td><code id="deriv_2nd_ar1_+3A_sigma2">sigma2</code></td>
<td>
<p>A <code>double</code> corresponding to the error term of an AR(1) process.</p>
</td></tr>
<tr><td><code id="deriv_2nd_ar1_+3A_tau">tau</code></td>
<td>
<p>A <code>vec</code> containing the scales e.g. <code class="reqn">2^{\tau}</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>matrix</code> with the first column containing the
second partial derivative with respect to <code class="reqn">\phi</code> and
the second column contains the second partial derivative with 
respect to <code class="reqn">\sigma ^2</code>
</p>


<h3>Process Haar WV Second Derivative</h3>

<p>Taking the second derivative with respect to <code class="reqn">\phi</code> yields:
</p>
<p style="text-align: center;"><code class="reqn">\frac{{{\partial ^2}}}{{\partial {\phi ^2}}}\nu _j^2\left( \phi, \sigma ^2  \right) = \frac{2 \sigma ^2 \left(\left(\phi ^2-1\right) \tau _j \left(2 (\phi  (7 \phi +4)+1) \phi ^{\frac{\tau _j}{2}-1}-(\phi  (7 \phi +4)+1) \phi ^{\tau _j-1}+3 (\phi +1)^2\right)+\left(\phi ^2-1\right)^2 \tau _j^2 \left(\phi ^{\frac{\tau _j}{2}}-1\right) \phi ^{\frac{\tau _j}{2}-1}+4 (3 \phi +1) \left(\phi ^2+\phi +1\right) \left(\phi ^{\tau _j}-4 \phi ^{\frac{\tau _j}{2}}+3\right)\right)}{(\phi -1)^5 (\phi +1)^3 \tau _j^2} </code>
</p>

<p>Taking the second derivative with respect to <code class="reqn">\sigma^2</code> yields:
</p>
<p style="text-align: center;"><code class="reqn">\frac{{{\partial ^2}}}{{\partial {\sigma ^4}}}\nu _j^2\left( \sigma ^2  \right) = 0 </code>
</p>

<p>Taking the derivative with respect to <code class="reqn">\phi</code> and <code class="reqn">\sigma ^2</code> yields:
</p>
<p style="text-align: center;"><code class="reqn">\frac{{{\partial ^2}}}{{\partial {\phi } \partial {\sigma ^2}}}\nu _j^2\left( \phi, \sigma ^2  \right) = \frac{2 \left(\left(\phi ^2-1\right) \tau _j \left(\phi ^{\tau _j}-2 \phi ^{\frac{\tau _j}{2}}-\phi -1\right)-(\phi  (3 \phi +2)+1) \left(\phi ^{\tau _j}-4 \phi ^{\frac{\tau _j}{2}}+3\right)\right)}{(\phi -1)^4 (\phi +1)^2 \tau _j^2} </code>
</p>



<h3>Author(s)</h3>

<p>James Joseph Balamuta (JJB)
</p>

<hr>
<h2 id='deriv_2nd_arma11'>Analytic D matrix for ARMA(1,1) process</h2><span id='topic+deriv_2nd_arma11'></span>

<h3>Description</h3>

<p>Obtain the second derivative of the ARMA(1,1) process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>deriv_2nd_arma11(phi, theta, sigma2, tau)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="deriv_2nd_arma11_+3A_phi">phi</code></td>
<td>
<p>A <code>double</code> corresponding to the phi coefficient of an ARMA(1,1) process.</p>
</td></tr>
<tr><td><code id="deriv_2nd_arma11_+3A_theta">theta</code></td>
<td>
<p>A <code>double</code> corresponding to the theta coefficient of an ARMA(1,1) process.</p>
</td></tr>
<tr><td><code id="deriv_2nd_arma11_+3A_sigma2">sigma2</code></td>
<td>
<p>A <code>double</code> corresponding to the error term of an ARMA(1,1) process.</p>
</td></tr>
<tr><td><code id="deriv_2nd_arma11_+3A_tau">tau</code></td>
<td>
<p>A <code>vec</code> containing the scales e.g. <code class="reqn">2^{\tau}</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>matrix</code> with:
</p>

<ul>
<li><p> The <strong>first</strong> column containing the second partial derivative with respect to <code class="reqn">\phi</code>;
</p>
</li>
<li><p> The <strong>second</strong> column containing the second partial derivative with respect to <code class="reqn">\theta</code>;
</p>
</li>
<li><p> The <strong>third</strong> column contains the second partial derivative with respect to <code class="reqn">\sigma ^2</code>.
</p>
</li>
<li><p> The <strong>fourth</strong> column contains the partial derivative with respect to <code class="reqn">\phi</code> and <code class="reqn">\theta</code>.
</p>
</li>
<li><p> The <strong>fiveth</strong> column contains the partial derivative with respect to <code class="reqn">\sigma ^2</code> and <code class="reqn">\phi</code>.
</p>
</li>
<li><p> The <strong>sixth</strong> column contains the partial derivative with respect to <code class="reqn">\sigma ^2</code> and <code class="reqn">\theta</code>.
</p>
</li></ul>



<h3>Process Haar WV Second Derivative</h3>

<p>Taking the second derivative with respect to <code class="reqn">\phi</code> yields:
</p>
<p style="text-align: center;"><code class="reqn">\frac{{{\partial ^2}}}{{\partial {\phi ^2}}}\nu _j^2\left( {\phi ,\theta ,{\sigma ^2}} \right) = \frac{{2{\sigma ^2}}}{{{{(\phi  - 1)}^5}{{(\phi  + 1)}^3}\tau _j^2}}\left( \begin{array}{cc}
&amp;{(\phi  - 1)^2}\left( {{{(\phi  + 1)}^2}\left( {{\theta ^2}\phi  + \theta {\phi ^2} + \theta  + \phi } \right)\tau _j^2\left( {{\phi ^{\frac{{{\tau _j}}}{2}}} - 1} \right){\phi ^{\frac{{{\tau _j}}}{2} - 2}} + \left( {{\phi ^2} - 1} \right)\left( {{\theta ^2}( - \phi ) + \theta \left( {{\phi ^2} + 4\phi  + 1} \right) - \phi } \right){\tau _j}\left( {{\phi ^{\frac{{{\tau _j}}}{2}}} - 2} \right){\phi ^{\frac{{{\tau _j}}}{2} - 2}} - 2{{(\theta  - 1)}^2}\left( {{\phi ^{{\tau _j}}} - 4{\phi ^{\frac{{{\tau _j}}}{2}}} + 3} \right)} \right) \\
&amp;- 12{(\phi  + 1)^2}\left( { - \frac{1}{2}{{(\theta  + 1)}^2}\left( {{\phi ^2} - 1} \right){\tau _j} - (\theta  + \phi )(\theta \phi  + 1)\left( {{\phi ^{{\tau _j}}} - 4{\phi ^{\frac{{{\tau _j}}}{2}}} + 3} \right)} \right) \\
&amp;+ 6(\phi  + 1)(\phi  - 1)\left( {\frac{1}{2}{{(\theta  + 1)}^2}\left( {{\phi ^2} - 1} \right){\tau _j} + (\theta  + \phi )(\theta \phi  + 1)\left( {{\phi ^{{\tau _j}}} - 4{\phi ^{\frac{{{\tau _j}}}{2}}} + 3} \right) + (\phi  + 1)\left( { - (\theta  + \phi )(\theta \phi  + 1){\tau _j}\left( {{\phi ^{\frac{{{\tau _j}}}{2}}} - 2} \right){\phi ^{\frac{{{\tau _j}}}{2} - 1}} - \theta (\theta  + \phi )\left( {{\phi ^{{\tau _j}}} - 4{\phi ^{\frac{{{\tau _j}}}{2}}} + 3} \right) - (\theta \phi  + 1)\left( {{\phi ^{{\tau _j}}} - 4{\phi ^{\frac{{{\tau _j}}}{2}}} + 3} \right) - {{(\theta  + 1)}^2}\phi {\tau _j}} \right)} \right) \\ 
\end{array}  \right)</code>
</p>

<p>Taking the second derivative with respect to <code class="reqn">\theta</code> yields:
</p>
<p style="text-align: center;"><code class="reqn">\frac{{{\partial ^2}}}{{\partial {\theta ^2}}}\nu _j^2\left( {\phi ,\theta ,{\sigma ^2}} \right) = \frac{{2{\sigma ^2}\left( {\left( {{\phi ^2} - 1} \right){\tau _j} + 2\phi \left( {{\phi ^{{\tau _j}}} - 4{\phi ^{\frac{{{\tau _j}}}{2}}} + 3} \right)} \right)}}{{{{(\phi  - 1)}^3}(\phi  + 1)\tau _j^2}} </code>
</p>

<p>Taking the second derivative with respect to <code class="reqn">\sigma ^2</code> yields:
</p>
<p style="text-align: center;"><code class="reqn">\frac{{{\partial ^2}}}{{\partial {\sigma ^4}}}\nu _j^2\left( {\phi ,\theta ,{\sigma ^2}} \right) = 0 </code>
</p>

<p>Taking the derivative with respect to <code class="reqn">\sigma^2</code> and <code class="reqn">\theta</code> yields:
</p>
<p style="text-align: center;"><code class="reqn">\frac{\partial }{{\partial \theta }}\frac{\partial }{{\partial {\sigma ^2}}}\nu _j^2\left( {\phi ,\theta ,{\sigma ^2}} \right) = \frac{2}{{{{(\phi  - 1)}^3}(\phi  + 1)\tau _j^2}}\left( {(\theta  + 1)\left( {{\phi ^2} - 1} \right){\tau _j} + \left( {2\theta \phi  + {\phi ^2} + 1} \right)\left( {{\phi ^{{\tau _j}}} - 4{\phi ^{\frac{{{\tau _j}}}{2}}} + 3} \right)} \right)</code>
</p>

<p>Taking the derivative with respect to <code class="reqn">\sigma^2</code> and <code class="reqn">\phi</code> yields:
</p>
<p style="text-align: center;"><code class="reqn">\frac{\partial }{{\partial \phi }}\frac{\partial }{{\partial {\sigma ^2}}}\nu _j^2\left( {\phi ,\theta ,{\sigma ^2}} \right) = \frac{2}{{{{(\phi  - 1)}^4}{{(\phi  + 1)}^2}\tau _j^2}}\left( \begin{array}{ll}
&amp;- (\phi  - 1)(\phi  + 1)\left( \begin{array}{ll}
                               &amp;- (\theta  + \phi )(\theta \phi  + 1){\tau _j}\left( {{\phi ^{\frac{{{\tau _j}}}{2}}} - 2} \right){\phi ^{\frac{{{\tau _j}}}{2} - 1}} \\
                               &amp;- \theta (\theta  + \phi )\left( {{\phi ^{{\tau _j}}} - 4{\phi ^{\frac{{{\tau _j}}}{2}}} + 3} \right) \\
                               &amp;- (\theta \phi  + 1)\left( {{\phi ^{{\tau _j}}} - 4{\phi ^{\frac{{{\tau _j}}}{2}}} + 3} \right) \\
                               &amp;- {(\theta  + 1)^2}\phi {\tau _j} \\ 
                               \end{array}  \right) \\
&amp;+ (\phi  - 1)\left( { - \frac{1}{2}{{(\theta  + 1)}^2}\left( {{\phi ^2} - 1} \right){\tau _j} - (\theta  + \phi )(\theta \phi  + 1)\left( {{\phi ^{{\tau _j}}} - 4{\phi ^{\frac{{{\tau _j}}}{2}}} + 3} \right)} \right) \\
&amp;+ 3(\phi  + 1)\left( { - \frac{1}{2}{{(\theta  + 1)}^2}\left( {{\phi ^2} - 1} \right){\tau _j} - (\theta  + \phi )(\theta \phi  + 1)\left( {{\phi ^{{\tau _j}}} - 4{\phi ^{\frac{{{\tau _j}}}{2}}} + 3} \right)} \right) \\ 
\end{array}  \right)</code>
</p>

<p>Taking the derivative with respect to <code class="reqn">\phi</code> and <code class="reqn">\theta</code> yields:
</p>
<p style="text-align: center;"><code class="reqn">\frac{\partial }{{\partial \theta }}\frac{\partial }{{\partial \phi }}\nu _j^2\left( {\phi ,\theta ,{\sigma ^2}} \right) =  - \frac{{2{\sigma ^2}}}{{{{(\phi  - 1)}^4}{{(\phi  + 1)}^2}\tau _j^2}}\left( \begin{array}{cc}
&amp;{\tau _j}\left( \begin{array}{cc}
                &amp;2(\theta  + 1)(\phi  - 1){(\phi  + 1)^2} \\
                &amp;+ 2\left( {{\phi ^2} - 1} \right)\left( {2\theta \phi  + {\phi ^2} + 1} \right){\phi ^{\frac{{{\tau _j}}}{2} - 1}} \\
                &amp;- \left( {{\phi ^2} - 1} \right)\left( {2\theta \phi  + {\phi ^2} + 1} \right){\phi ^{{\tau _j} - 1}} \\ 
                \end{array}  \right) \\
&amp;+ 2\left( {\theta (\phi (3\phi  + 2) + 1) + \phi \left( {{\phi ^2} + \phi  + 3} \right) + 1} \right)\left( {{\phi ^{{\tau _j}}} - 4{\phi ^{\frac{{{\tau _j}}}{2}}} + 3} \right) \\ 
\end{array}  \right)</code>
</p>



<h3>Author(s)</h3>

<p>James Joseph Balamuta (JJB)
</p>

<hr>
<h2 id='deriv_2nd_dr'>Analytic second derivative matrix for drift process</h2><span id='topic+deriv_2nd_dr'></span>

<h3>Description</h3>

<p>To ease a later calculation, we place the result into a matrix structure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>deriv_2nd_dr(tau)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="deriv_2nd_dr_+3A_tau">tau</code></td>
<td>
<p>A <code>vec</code> containing the scales e.g. <code class="reqn">2^{\tau}</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>matrix</code> with the first column containing 
the second partial derivative with respect to <code class="reqn">\omega</code>.
</p>


<h3>Author(s)</h3>

<p>James Joseph Balamuta (JJB)
</p>

<hr>
<h2 id='deriv_2nd_ma1'>Analytic second derivative for MA(1) process</h2><span id='topic+deriv_2nd_ma1'></span>

<h3>Description</h3>

<p>To ease a later calculation, we place the result into a matrix structure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>deriv_2nd_ma1(theta, sigma2, tau)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="deriv_2nd_ma1_+3A_theta">theta</code></td>
<td>
<p>A <code>double</code> corresponding to the theta coefficient of an MA(1) process.</p>
</td></tr>
<tr><td><code id="deriv_2nd_ma1_+3A_sigma2">sigma2</code></td>
<td>
<p>A <code>double</code> corresponding to the error term of an MA(1) process.</p>
</td></tr>
<tr><td><code id="deriv_2nd_ma1_+3A_tau">tau</code></td>
<td>
<p>A <code>vec</code> containing the scales e.g. <code class="reqn">2^{\tau}</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>matrix</code> with the first column containing the second partial derivative with respect to <code class="reqn">\theta</code>,
the second column contains the partial derivative with respect to <code class="reqn">\theta</code> and <code class="reqn">\sigma ^2</code>,
and lastly we have the second partial derivative with respect to <code class="reqn">\sigma ^2</code>.
</p>


<h3>Process Haar WV Second Derivative</h3>

<p>Taking the second derivative with respect to <code class="reqn">\theta</code> yields:
</p>
<p style="text-align: center;"><code class="reqn">\frac{{{\partial ^2}}}{{\partial {\theta ^2}}}\nu _j^2\left( {\theta ,{\sigma ^2}} \right) = \frac{{2{\sigma ^2}}}{{{\tau _j}}}</code>
</p>

<p>Taking the second derivative with respect to <code class="reqn">\sigma^2</code> yields:
</p>
<p style="text-align: center;"><code class="reqn">\frac{{{\partial ^2}}}{{\partial {\sigma ^4}}}\nu _j^2\left( {\theta ,{\sigma ^2}} \right) = 0</code>
</p>

<p>Taking the first derivative with respect to <code class="reqn">\theta</code> and <code class="reqn">\sigma^2</code> yields:
</p>
<p style="text-align: center;"><code class="reqn">\frac{\partial }{{\partial \theta }}\frac{\partial }{{\partial {\sigma ^2}}}\nu _j^2\left( {\theta ,{\sigma ^2}} \right) = \frac{{2(\theta  + 1){\tau _j} - 6}}{{\tau _j^2}}</code>
</p>



<h3>Author(s)</h3>

<p>James Joseph Balamuta (JJB)
</p>

<hr>
<h2 id='deriv_ar1'>Analytic D matrix for AR(1) process</h2><span id='topic+deriv_ar1'></span>

<h3>Description</h3>

<p>Obtain the first derivative of the AR(1) process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>deriv_ar1(phi, sigma2, tau)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="deriv_ar1_+3A_phi">phi</code></td>
<td>
<p>A <code>double</code> corresponding to the phi coefficient of an AR(1) process.</p>
</td></tr>
<tr><td><code id="deriv_ar1_+3A_sigma2">sigma2</code></td>
<td>
<p>A <code>double</code> corresponding to the error term of an AR(1) process.</p>
</td></tr>
<tr><td><code id="deriv_ar1_+3A_tau">tau</code></td>
<td>
<p>A <code>vec</code> containing the scales e.g. <code class="reqn">2^{\tau}</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>matrix</code> with the first column containing the partial derivative with respect to <code class="reqn">\phi</code> 
and the second column contains the partial derivative with respect to <code class="reqn">\sigma ^2</code>
</p>


<h3>Process Haar WV First Derivative</h3>

<p>Taking the derivative with respect to <code class="reqn">\phi</code> yields:
</p>
<p style="text-align: center;"><code class="reqn">\frac{\partial }{{\partial \phi }}\nu _j^2\left( {\phi ,{\sigma ^2}} \right) = \frac{{2{\sigma ^2}\left( {\left( {{\phi ^2} - 1} \right){\tau _j}\left( { - 2{\phi ^{\frac{{{\tau _j}}}{2}}} + {\phi ^{{\tau _j}}} - \phi  - 1} \right) - \left( {\phi \left( {3\phi  + 2} \right) + 1} \right)\left( { - 4{\phi ^{\frac{{{\tau _j}}}{2}}} + {\phi ^{{\tau _j}}} + 3} \right)} \right)}}{{{{\left( {\phi  - 1} \right)}^4}{{\left( {\phi  + 1} \right)}^2}\tau _j^2}}</code>
</p>

<p>Taking the derivative with respect to <code class="reqn">\sigma ^2</code> yields:
</p>
<p style="text-align: center;"><code class="reqn">\frac{\partial }{{\partial {\sigma ^2}}}\nu _j^2\left( {\phi ,{\sigma ^2}} \right) = \frac{{\left( {{\phi ^2} - 1} \right){\tau _j} + 2\phi \left( { - 4{\phi ^{\frac{{{\tau _j}}}{2}}} + {\phi ^{{\tau _j}}} + 3} \right)}}{{{{\left( {\phi  - 1} \right)}^3}\left( {\phi  + 1} \right)\tau _j^2}}</code>
</p>



<h3>Author(s)</h3>

<p>James Joseph Balamuta (JJB)
</p>

<hr>
<h2 id='deriv_arma11'>Analytic D matrix for ARMA(1,1) process</h2><span id='topic+deriv_arma11'></span>

<h3>Description</h3>

<p>Obtain the first derivative of the ARMA(1,1) process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>deriv_arma11(phi, theta, sigma2, tau)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="deriv_arma11_+3A_phi">phi</code></td>
<td>
<p>A <code>double</code> corresponding to the phi coefficient of an ARMA(1,1) process.</p>
</td></tr>
<tr><td><code id="deriv_arma11_+3A_theta">theta</code></td>
<td>
<p>A <code>double</code> corresponding to the theta coefficient of an ARMA(1,1) process.</p>
</td></tr>
<tr><td><code id="deriv_arma11_+3A_sigma2">sigma2</code></td>
<td>
<p>A <code>double</code> corresponding to the error term of an ARMA(1,1) process.</p>
</td></tr>
<tr><td><code id="deriv_arma11_+3A_tau">tau</code></td>
<td>
<p>A <code>vec</code> containing the scales e.g. <code class="reqn">2^{\tau}</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>matrix</code> with:
</p>

<ul>
<li><p> The <strong>first</strong> column containing the partial derivative with respect to <code class="reqn">\phi</code>;
</p>
</li>
<li><p> The <strong>second</strong> column containing the partial derivative with respect to <code class="reqn">\theta</code>;
</p>
</li>
<li><p> The <strong>third</strong> column contains the partial derivative with respect to <code class="reqn">\sigma ^2</code>.
</p>
</li></ul>



<h3>Process Haar WV First Derivative</h3>

<p>Taking the derivative with respect to <code class="reqn">\phi</code> yields:
</p>
<p style="text-align: center;"><code class="reqn"> \frac{\partial }{{\partial \phi }}\nu _j^2\left( {\phi ,\theta ,{\sigma ^2}} \right) = \frac{{2{\sigma ^2}}}{{{{(\phi  - 1)}^4}{{(\phi  + 1)}^2}\tau _j^2}}\left( \begin{array}{cc}
&amp;{\tau _j}\left( { - {{(\theta  + 1)}^2}(\phi  - 1){{(\phi  + 1)}^2} - 2\left( {{\phi ^2} - 1} \right)(\theta  + \phi )(\theta \phi  + 1){\phi ^{\frac{{{\tau _j}}}{2} - 1}} + \left( {{\phi ^2} - 1} \right)(\theta \phi  + 1)(\theta  + \phi ){\phi ^{{\tau _j} - 1}}} \right) \\
&amp;- \left( {{\theta ^2}((3\phi  + 2)\phi  + 1) + 2\theta \left( {\left( {{\phi ^2} + \phi  + 3} \right)\phi  + 1} \right) + (3\phi  + 2)\phi  + 1} \right)\left( {{\phi ^{{\tau _j}}} - 4{\phi ^{\frac{{{\tau _j}}}{2}}} + 3} \right) \\ 
\end{array}  \right)</code>
</p>

<p>Taking the derivative with respect to <code class="reqn">\theta</code> yields:
</p>
<p style="text-align: center;"><code class="reqn">\frac{\partial }{{\partial \theta }}\nu _j^2\left( {\phi ,\theta ,{\sigma ^2}} \right) = \frac{{2{\sigma ^2}\left( {(\theta  + 1)\left( {{\phi ^2} - 1} \right){\tau _j} + \left( {2\theta \phi  + {\phi ^2} + 1} \right)\left( {{\phi ^{{\tau _j}}} - 4{\phi ^{\frac{{{\tau _j}}}{2}}} + 3} \right)} \right)}}{{{{(\phi  - 1)}^3}(\phi  + 1)\tau _j^2}}</code>
</p>

<p>Taking the derivative with respect to <code class="reqn">\sigma^2</code> yields:
</p>
<p style="text-align: center;"><code class="reqn">\frac{\partial }{{\partial \sigma ^2 }}\nu _j^2\left( {\phi ,\theta ,{\sigma ^2}} \right) = \frac{2 \sigma ^2 \left(\left(\phi ^2-1\right) \tau _j+2 \phi  \left(\phi ^{\tau _j}-4 \phi ^{\frac{\tau _j}{2}}+3\right)\right)}{(\phi -1)^3 (\phi +1) \tau _j^2}</code>
</p>



<h3>Author(s)</h3>

<p>James Joseph Balamuta (JJB)
</p>

<hr>
<h2 id='deriv_dr'>Analytic D matrix for Drift (DR) Process</h2><span id='topic+deriv_dr'></span>

<h3>Description</h3>

<p>Obtain the first derivative of the Drift (DR) process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>deriv_dr(omega, tau)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="deriv_dr_+3A_omega">omega</code></td>
<td>
<p>A <code>double</code> that is the slope of the drift.</p>
</td></tr>
<tr><td><code id="deriv_dr_+3A_tau">tau</code></td>
<td>
<p>A <code>vec</code> containing the scales e.g. <code class="reqn">2^{\tau}</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>matrix</code> with the first column containing the partial derivative 
with respect to <code class="reqn">\omega</code>.
</p>


<h3>Process Haar WV First Derivative</h3>

<p>Taking the derivative with respect to <code class="reqn">\omega</code> yields:
</p>
<p style="text-align: center;"><code class="reqn">\frac{\partial }{{\partial \omega }}\nu _j^2\left( \omega  \right) = \frac{{\tau _j^2\omega }}{8}</code>
</p>

<p><strong>Note:</strong> We are taking the derivative with respect to <code class="reqn">\omega</code> and not <code class="reqn">\omega^2</code> as the <code class="reqn">\omega</code>
relates to the slope of the process and not the processes variance like RW and WN. As a result, a second derivative exists and is not zero.
</p>


<h3>Author(s)</h3>

<p>James Joseph Balamuta (JJB)
</p>

<hr>
<h2 id='deriv_ma1'>Analytic D matrix for MA(1) process</h2><span id='topic+deriv_ma1'></span>

<h3>Description</h3>

<p>Obtain the first derivative of the MA(1) process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>deriv_ma1(theta, sigma2, tau)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="deriv_ma1_+3A_theta">theta</code></td>
<td>
<p>A <code>double</code> corresponding to the theta coefficient of an MA(1) process.</p>
</td></tr>
<tr><td><code id="deriv_ma1_+3A_sigma2">sigma2</code></td>
<td>
<p>A <code>double</code> corresponding to the error term of an MA(1) process.</p>
</td></tr>
<tr><td><code id="deriv_ma1_+3A_tau">tau</code></td>
<td>
<p>A <code>vec</code> containing the scales e.g. <code class="reqn">2^{\tau}</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>matrix</code> with the first column containing the partial derivative with respect to <code class="reqn">\theta</code>
and the second column contains the partial derivative with respect to <code class="reqn">\sigma ^2</code>
</p>


<h3>Process Haar WV First Derivative</h3>

<p>Taking the derivative with respect to <code class="reqn">\theta</code> yields:
</p>
<p style="text-align: center;"><code class="reqn">\frac{\partial }{{\partial \theta }}\nu _j^2\left( {\theta ,{\sigma ^2}} \right) = \frac{{{\sigma ^2}\left( {2\left( {\theta  + 1} \right){\tau _j} - 6} \right)}}{{\tau _j^2}}</code>
</p>

<p>Taking the derivative with respect to <code class="reqn">\sigma^2</code> yields:
</p>
<p style="text-align: center;"><code class="reqn">\frac{\partial }{{\partial {\sigma ^2}}}\nu _j^2\left( {\theta ,{\sigma ^2}} \right) = \frac{{{{\left( {\theta  + 1} \right)}^2}{\tau _j} - 6\theta }}{{\tau _j^2}}</code>
</p>



<h3>Author(s)</h3>

<p>James Joseph Balamuta (JJB)
</p>

<hr>
<h2 id='deriv_qn'>Analytic D matrix for Quantization Noise (QN) Process</h2><span id='topic+deriv_qn'></span>

<h3>Description</h3>

<p>Obtain the first derivative of the Quantization Noise (QN) process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>deriv_qn(tau)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="deriv_qn_+3A_tau">tau</code></td>
<td>
<p>A <code>vec</code> containing the scales e.g. <code class="reqn">2^{\tau}</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>matrix</code> with the first column containing 
the partial derivative with respect to <code class="reqn">Q^2</code>.
</p>


<h3>Process Haar WV First Derivative</h3>

<p>Taking the derivative with respect to <code class="reqn">Q^2</code> yields:
</p>
<p style="text-align: center;"><code class="reqn">\frac{\partial }{{\partial {Q^2}}}\nu _j^2\left( {{Q^2}} \right) = \frac{6}{{\tau _j^2}}</code>
</p>



<h3>Author(s)</h3>

<p>James Joseph Balamuta (JJB)
</p>

<hr>
<h2 id='deriv_rw'>Analytic D matrix Random Walk (RW) Process</h2><span id='topic+deriv_rw'></span>

<h3>Description</h3>

<p>Obtain the first derivative of the Random Walk (RW) process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>deriv_rw(tau)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="deriv_rw_+3A_tau">tau</code></td>
<td>
<p>A <code>vec</code> containing the scales e.g. <code class="reqn">2^{\tau}</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>matrix</code> with the first column containing
the partial derivative with respect to <code class="reqn">\gamma^2</code>.
</p>


<h3>Process Haar WV First Derivative</h3>

<p>Taking the derivative with respect to <code class="reqn">\gamma ^2</code> yields:
</p>
<p style="text-align: center;"><code class="reqn"> \frac{\partial }{{\partial {\gamma ^2}}}\nu _j^2\left( {{\gamma ^2}} \right) = \frac{{\tau _j^2 + 2}}{{12{\tau _j}}} </code>
</p>



<h3>Author(s)</h3>

<p>James Joseph Balamuta (JJB)
</p>

<hr>
<h2 id='deriv_wn'>Analytic D Matrix for a Gaussian White Noise (WN) Process</h2><span id='topic+deriv_wn'></span>

<h3>Description</h3>

<p>Obtain the first derivative of the Gaussian White Noise (WN) process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>deriv_wn(tau)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="deriv_wn_+3A_tau">tau</code></td>
<td>
<p>A <code>vec</code> containing the scales e.g. <code class="reqn">2^{\tau}</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>matrix</code> with the first column containing 
the partial derivative with respect to <code class="reqn">\sigma^2</code>.
</p>


<h3>Process Haar WV First Derivative</h3>

<p>Taking the derivative with respect to <code class="reqn">\sigma^2</code> yields:
</p>
<p style="text-align: center;"><code class="reqn">\frac{\partial }{{\partial {\sigma ^2}}}\nu _j^2\left( {{\sigma ^2}} \right) = \frac{1}{{{\tau _j}}}</code>
</p>



<h3>Author(s)</h3>

<p>James Joseph Balamuta (JJB)
</p>

<hr>
<h2 id='derivative_first_matrix'>Analytic D matrix of Processes</h2><span id='topic+derivative_first_matrix'></span>

<h3>Description</h3>

<p>This function computes each process to WV (haar) in a given model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>derivative_first_matrix(theta, desc, objdesc, tau)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="derivative_first_matrix_+3A_theta">theta</code></td>
<td>
<p>A <code>vec</code> containing the list of estimated parameters.</p>
</td></tr>
<tr><td><code id="derivative_first_matrix_+3A_desc">desc</code></td>
<td>
<p>A <code>vector&lt;string&gt;</code> containing a list of descriptors.</p>
</td></tr>
<tr><td><code id="derivative_first_matrix_+3A_objdesc">objdesc</code></td>
<td>
<p>A <code>field&lt;vec&gt;</code> containing a list of object descriptors.</p>
</td></tr>
<tr><td><code id="derivative_first_matrix_+3A_tau">tau</code></td>
<td>
<p>A <code>vec</code> containing the scales e.g. <code class="reqn">2^{\tau}</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function returns the matrix effectively known as &quot;D&quot;
</p>


<h3>Value</h3>

<p>A <code>matrix</code> with the process derivatives going down the column
</p>


<h3>Author(s)</h3>

<p>James Joseph Balamuta (JJB)
</p>

<hr>
<h2 id='desc.to.ts.model'>Create a ts.model from desc string</h2><span id='topic+desc.to.ts.model'></span>

<h3>Description</h3>

<p>Sets up the necessary backend for using Cpp functions to build R ts.model objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>desc.to.ts.model(desc)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="desc.to.ts.model_+3A_desc">desc</code></td>
<td>
<p>A <code>character</code> vector containing: <code>"AR1"</code>,<code>"DR"</code>,<code>"WN"</code>,<code>"RW"</code>,<code>"QN"</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>An S3 object with called ts.model with the following structure:
</p>

<ul>
<li><p>desc
</p>
</li>
<li><p>theta
</p>
</li></ul>



<h3>Author(s)</h3>

<p>James Balamuta
</p>


<h3>Examples</h3>

<pre><code class='language-R'>desc.to.ts.model(c("AR1","WN"))
</code></pre>

<hr>
<h2 id='dft_acf'>Discrete Fourier Transformation for Autocovariance Function</h2><span id='topic+dft_acf'></span>

<h3>Description</h3>

<p>Calculates the autovariance function (ACF) using Discrete Fourier Transformation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dft_acf(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dft_acf_+3A_x">x</code></td>
<td>
<p>A <code>cx_vec</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This implementation is 2x as slow as Rs. 
Two issues: 1. memory resize and 2. unoptimized fft algorithm in arma.
Consider piping back into R and rewrapping the object. (Decrease of about 10 microseconds.)
</p>


<h3>Value</h3>

<p>A <code>vec</code> containing the ACF.
</p>

<hr>
<h2 id='diag_boxpierce'>Box-Pierce</h2><span id='topic+diag_boxpierce'></span>

<h3>Description</h3>

<p>Performs the Box-Pierce test to assess the Null Hypothesis of Independence
in a Time Series
</p>


<h3>Usage</h3>

<pre><code class='language-R'>diag_boxpierce(x, order = NULL, stop_lag = 20, stdres = FALSE, plot = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="diag_boxpierce_+3A_x">x</code></td>
<td>
<p>An <code>arima</code> or data set.</p>
</td></tr>
<tr><td><code id="diag_boxpierce_+3A_order">order</code></td>
<td>
<p>An <code>integer</code> indicating the degrees of freedom. If 'x' is
not a series of residuals, then set equal to 0.</p>
</td></tr>
<tr><td><code id="diag_boxpierce_+3A_stop_lag">stop_lag</code></td>
<td>
<p>An <code>integer</code> indicating the length of lags that should
be calculated.</p>
</td></tr>
<tr><td><code id="diag_boxpierce_+3A_stdres">stdres</code></td>
<td>
<p>A <code>boolean</code> indicating whether to standardize the
residualizes (e.g. <code class="reqn">res/sd(res)</code>) or not.</p>
</td></tr>
<tr><td><code id="diag_boxpierce_+3A_plot">plot</code></td>
<td>
<p>A logical. If <code>TRUE</code> (the default) a plot should be produced.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>James Balamuta, Stéphane Guerrier, Yuming Zhang
</p>

<hr>
<h2 id='diag_ljungbox'>Ljung-Box</h2><span id='topic+diag_ljungbox'></span>

<h3>Description</h3>

<p>Performs the Ljung-Box test to assess the Null Hypothesis of Independence
in a Time Series
</p>


<h3>Usage</h3>

<pre><code class='language-R'>diag_ljungbox(x, order = NULL, stop_lag = 20, stdres = FALSE, plot = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="diag_ljungbox_+3A_x">x</code></td>
<td>
<p>An <code>arima</code> or data set.</p>
</td></tr>
<tr><td><code id="diag_ljungbox_+3A_order">order</code></td>
<td>
<p>An <code>integer</code> indicating the degrees of freedom. If 'x' is
not a series of residuals, then set equal to 0.</p>
</td></tr>
<tr><td><code id="diag_ljungbox_+3A_stop_lag">stop_lag</code></td>
<td>
<p>An <code>integer</code> indicating the length of lags that should
be calculated.</p>
</td></tr>
<tr><td><code id="diag_ljungbox_+3A_stdres">stdres</code></td>
<td>
<p>A <code>boolean</code> indicating whether to standardize the
residualizes (e.g. <code class="reqn">res/sd(res)</code>) or not.</p>
</td></tr>
<tr><td><code id="diag_ljungbox_+3A_plot">plot</code></td>
<td>
<p>A logical. If <code>TRUE</code> (the default) a plot should be produced.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>James Balamuta, Stéphane Guerrier, Yuming Zhang
</p>

<hr>
<h2 id='diag_plot'>Diagnostic Plot of Residuals</h2><span id='topic+diag_plot'></span>

<h3>Description</h3>

<p>This function will plot 8 diagnostic plots to assess the model used to 
fit the data. These include: (1) residuals plot, (2) residuals vs fitted values, 
(3) histogram of distribution of standardized residuals, (4) Normal Q-Q plot of 
residuals, (5) ACF plot, (6) PACF plot, (7) Haar Wavelet Variance Representation,
(8) Box test results.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>diag_plot(Xt = NULL, model = NULL, resids = NULL, std = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="diag_plot_+3A_xt">Xt</code></td>
<td>
<p>The data used to construct said model.</p>
</td></tr>
<tr><td><code id="diag_plot_+3A_model">model</code></td>
<td>
<p>A <code>fitsimts</code>, <code>lm</code> or <code>gam</code> object.</p>
</td></tr>
<tr><td><code id="diag_plot_+3A_resids">resids</code></td>
<td>
<p>A <code>vector</code> of residuals for diagnostics.</p>
</td></tr>
<tr><td><code id="diag_plot_+3A_std">std</code></td>
<td>
<p>A <code>boolean</code> indicating whether we use standardized residuals for 
(1) residuals plot and (8) Box test results.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Yuming Zhang
</p>

<hr>
<h2 id='diag_portmanteau_'>Portmanteau Tests</h2><span id='topic+diag_portmanteau_'></span>

<h3>Description</h3>

<p>Performs the Portmanteau test to assess the Null Hypothesis of Independence
in a Time Series
</p>


<h3>Usage</h3>

<pre><code class='language-R'>diag_portmanteau_(
  x,
  order = NULL,
  stop_lag = 20,
  stdres = FALSE,
  test = "Ljung-Box",
  plot = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="diag_portmanteau__+3A_x">x</code></td>
<td>
<p>An <code>arima</code> or data set.</p>
</td></tr>
<tr><td><code id="diag_portmanteau__+3A_order">order</code></td>
<td>
<p>An <code>integer</code> indicating the degrees of freedom. If 'x' is
not a series of residuals, then set equal to 0.</p>
</td></tr>
<tr><td><code id="diag_portmanteau__+3A_stop_lag">stop_lag</code></td>
<td>
<p>An <code>integer</code> indicating the length of lags that should
be calculated.</p>
</td></tr>
<tr><td><code id="diag_portmanteau__+3A_stdres">stdres</code></td>
<td>
<p>A <code>boolean</code> indicating whether to standardize the
residualizes (e.g. <code class="reqn">res/sd(res)</code>) or not.</p>
</td></tr>
<tr><td><code id="diag_portmanteau__+3A_test">test</code></td>
<td>
<p>A <code>string</code> indicating whether to perform Ljung-Box test or 
Box-Pierce test.</p>
</td></tr>
<tr><td><code id="diag_portmanteau__+3A_plot">plot</code></td>
<td>
<p>A logical. If <code>TRUE</code> (the default) a plot should be produced.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>James Balamuta, Stéphane Guerrier, Yuming Zhang
</p>

<hr>
<h2 id='diff_cpp'>Lagged Differences in Armadillo</h2><span id='topic+diff_cpp'></span>

<h3>Description</h3>

<p>Returns the ith difference of a time series of rth lag.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>diff_cpp(x, lag, differences)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="diff_cpp_+3A_x">x</code></td>
<td>
<p>A <code>vec</code> that is the time series</p>
</td></tr>
<tr><td><code id="diff_cpp_+3A_lag">lag</code></td>
<td>
<p>A <code>unsigned int</code> that indicates the lag</p>
</td></tr>
<tr><td><code id="diff_cpp_+3A_differences">differences</code></td>
<td>
<p>A <code>dif</code> that indicates how many differences should be taken</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>vector</code> containing the differenced time series.
</p>


<h3>Author(s)</h3>

<p>JJB
</p>

<hr>
<h2 id='do_polyroot_arma'>Root Finding C++</h2><span id='topic+do_polyroot_arma'></span>

<h3>Description</h3>

<p>Used to interface with Armadillo
</p>


<h3>Usage</h3>

<pre><code class='language-R'>do_polyroot_arma(z)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="do_polyroot_arma_+3A_z">z</code></td>
<td>
<p>A <code>cx_vec</code> (complex vector) that has 1 in the beginning (e.g. c(1,3i,-3i))</p>
</td></tr>
</table>

<hr>
<h2 id='do_polyroot_cpp'>Root Finding C++</h2><span id='topic+do_polyroot_cpp'></span>

<h3>Description</h3>

<p>Vroom Vroom
</p>


<h3>Usage</h3>

<pre><code class='language-R'>do_polyroot_cpp(z)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="do_polyroot_cpp_+3A_z">z</code></td>
<td>
<p>A <code>vec&lt;complex&lt;double&gt;</code> (complex vector) that has 1 in the beginning (e.g. c(1,3i,-3i))</p>
</td></tr>
</table>

<hr>
<h2 id='DR'>Create an Drift (DR) Process</h2><span id='topic+DR'></span>

<h3>Description</h3>

<p>Sets up the necessary backend for the DR process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DR(omega = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DR_+3A_omega">omega</code></td>
<td>
<p>A <code>double</code> value for the slope of a DR process (see Note for details).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An S3 object with called ts.model with the following structure:
</p>

<dl>
<dt>process.desc</dt><dd><p>Used in summary: &quot;DR&quot;</p>
</dd>
<dt>theta</dt><dd><p>slope</p>
</dd>
<dt>print</dt><dd><p>String containing simplified model</p>
</dd>
<dt>plength</dt><dd><p>Number of parameters</p>
</dd>
<dt>obj.desc</dt><dd><p>y desc replicated x times</p>
</dd>
<dt>obj</dt><dd><p>Depth of parameters e.g. list(1)</p>
</dd>
<dt>starting</dt><dd><p>Guess starting values? TRUE or FALSE (e.g. specified value)</p>
</dd>
</dl>



<h3>Note</h3>

<p>We consider the following model: </p>
<p style="text-align: center;"><code class="reqn">Y_t = \omega t</code>
</p>



<h3>Author(s)</h3>

<p>James Balamuta
</p>


<h3>Examples</h3>

<pre><code class='language-R'>DR()
DR(omega=3.4)
</code></pre>

<hr>
<h2 id='dr_to_wv'>Drift to WV</h2><span id='topic+dr_to_wv'></span>

<h3>Description</h3>

<p>This function compute the WV (haar) of a Drift process
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dr_to_wv(omega, tau)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dr_to_wv_+3A_omega">omega</code></td>
<td>
<p>A <code>double</code> corresponding to the slope of the drift</p>
</td></tr>
<tr><td><code id="dr_to_wv_+3A_tau">tau</code></td>
<td>
<p>A <code>vec</code> containing the scales e.g. <code class="reqn">2^{\tau}</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>vec</code> containing the wavelet variance of the drift.
</p>


<h3>Process Haar Wavelet Variance Formula</h3>

<p>The Drift (DR) process has a Haar Wavelet Variance given by:
</p>
<p style="text-align: center;"><code class="reqn"> \nu _j^2\left( {{\omega }} \right) = \frac{{\tau _j^2{\omega ^2}}}{{16}}  </code>
</p>


<hr>
<h2 id='dwt_cpp'>Discrete Wavelet Transform</h2><span id='topic+dwt_cpp'></span>

<h3>Description</h3>

<p>Calculation of the coefficients for the discrete wavelet transformation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dwt_cpp(x, filter_name, nlevels, boundary, brickwall)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dwt_cpp_+3A_x">x</code></td>
<td>
<p>A <code>vector</code> with dimensions <code class="reqn">N\times 1</code>.</p>
</td></tr>
<tr><td><code id="dwt_cpp_+3A_filter_name">filter_name</code></td>
<td>
<p>A <code>string</code> indicating the filter.</p>
</td></tr>
<tr><td><code id="dwt_cpp_+3A_nlevels">nlevels</code></td>
<td>
<p>An <code>integer</code>, <code class="reqn">J</code>, indicating the level of the decomposition.</p>
</td></tr>
<tr><td><code id="dwt_cpp_+3A_boundary">boundary</code></td>
<td>
<p>A <code>string</code> indicating the type of boundary method to use. Either <code>boundary="periodic"</code> or <code>"reflection"</code>.</p>
</td></tr>
<tr><td><code id="dwt_cpp_+3A_brickwall">brickwall</code></td>
<td>
<p>A <code>bool</code> indicating whether the a brick wall procedure should be applied to the coefficients.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Performs a level J decomposition of the time series using the pyramid algorithm
</p>


<h3>Value</h3>

<p>y A <code>field&lt;vec&gt;</code> that contains the wavelet coefficients for each decomposition level
</p>


<h3>Author(s)</h3>

<p>JJB
</p>

<hr>
<h2 id='e_drift'>Expected value DR</h2><span id='topic+e_drift'></span>

<h3>Description</h3>

<p>This function computes the expected value of a drift process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>e_drift(omega, n_ts)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="e_drift_+3A_omega">omega</code></td>
<td>
<p>A <code>double</code> corresponding to variance of drift.</p>
</td></tr>
<tr><td><code id="e_drift_+3A_n_ts">n_ts</code></td>
<td>
<p>An <code>int</code> indicating the length of the time series.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>vec</code> containing the expected value of the drift.
</p>

<hr>
<h2 id='estimate'>Fit a Time Series Model to Data</h2><span id='topic+estimate'></span>

<h3>Description</h3>

<p>This function can fit a time series model to data using different methods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimate(model, Xt, method = "mle", demean = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estimate_+3A_model">model</code></td>
<td>
<p>A time series model.</p>
</td></tr>
<tr><td><code id="estimate_+3A_xt">Xt</code></td>
<td>
<p>A <code>vector</code> of time series data.</p>
</td></tr>
<tr><td><code id="estimate_+3A_method">method</code></td>
<td>
<p>A <code>string</code> indicating the method used for model fitting. 
Supported methods include <code>mle</code>, <code>yule-walker</code>, <code>gmwm</code>  and <code>rgmwm</code>.</p>
</td></tr>
<tr><td><code id="estimate_+3A_demean">demean</code></td>
<td>
<p>A <code>boolean</code> indicating whether the model includes a mean / intercept term or not.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Stéphane Guerrier and Yuming Zhang
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Xt = gen_gts(300, AR(phi = c(0, 0, 0.8), sigma2 = 1))
plot(Xt)
estimate(AR(3), Xt)

Xt = gen_gts(300, MA(theta = 0.5, sigma2 = 1))
plot(Xt)
estimate(MA(1), Xt, method = "gmwm")

Xt = gen_gts(300, ARMA(ar = c(0.8, -0.5), ma = 0.5, sigma2 = 1))
plot(Xt)
estimate(ARMA(2,1), Xt, method = "rgmwm")

Xt = gen_gts(300, ARIMA(ar = c(0.8, -0.5), i = 1, ma = 0.5, sigma2 = 1))
plot(Xt)
estimate(ARIMA(2,1,1), Xt, method = "mle")

Xt = gen_gts(1000, SARIMA(ar = c(0.5, -0.25), i = 0, ma = 0.5, sar = -0.8, 
si = 1, sma = 0.25, s = 24, sigma2 = 1))
plot(Xt)
estimate(SARIMA(ar = 2, i = 0, ma = 1, sar = 1, si = 1, sma = 1, s = 24), Xt, 
method = "rgmwm")
</code></pre>

<hr>
<h2 id='evaluate'>Evalute a time series or a list of time series models</h2><span id='topic+evaluate'></span>

<h3>Description</h3>

<p>This function calculates AIC, BIC and HQ or the MAPE for a list of time series
models. This function currently only supports models estimated by the MLE.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>evaluate(
  models,
  Xt,
  criterion = "IC",
  start = 0.8,
  demean = TRUE,
  print = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="evaluate_+3A_models">models</code></td>
<td>
<p>A time series model or a list of time series models.</p>
</td></tr>
<tr><td><code id="evaluate_+3A_xt">Xt</code></td>
<td>
<p>A time series (i.e gts object).</p>
</td></tr>
<tr><td><code id="evaluate_+3A_criterion">criterion</code></td>
<td>
<p>Either &quot;IC&quot; for AIC, BIC and HQ or &quot;MAPE&quot; for MAPE.</p>
</td></tr>
<tr><td><code id="evaluate_+3A_start">start</code></td>
<td>
<p>A <code>numeric</code> indicating the starting proportion of the data that 
is used for prediction (assuming criterion = &quot;MAPE&quot;).</p>
</td></tr>
<tr><td><code id="evaluate_+3A_demean">demean</code></td>
<td>
<p>A <code>boolean</code> indicating whether the model includes a mean / intercept term or not.</p>
</td></tr>
<tr><td><code id="evaluate_+3A_print">print</code></td>
<td>
<p>logical. If <code>TRUE</code> (the default) results are printed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>AIC, BIC and HQ or MAPE
</p>


<h3>Author(s)</h3>

<p>Stéphane Guerrier
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(18)
n = 300
Xt = gen_gts(n, AR(phi = c(0, 0, 0.8), sigma2 = 1))
evaluate(AR(1), Xt)
evaluate(list(AR(1), AR(3), MA(3), ARMA(1,2), 
SARIMA(ar = 1, i = 0, ma = 1, sar = 1, si = 1, sma = 1, s = 12)), Xt)
evaluate(list(AR(1), AR(3)), Xt, criterion = "MAPE")
</code></pre>

<hr>
<h2 id='fast_cov_cpp'>Computes the (MODWT) wavelet covariance matrix using Chi-square confidence interval bounds</h2><span id='topic+fast_cov_cpp'></span>

<h3>Description</h3>

<p>Calculates the (MODWT) wavelet covariance matrix using Chi-square confidence interval bounds
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fast_cov_cpp(ci_hi, ci_lo)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fast_cov_cpp_+3A_ci_hi">ci_hi</code></td>
<td>
<p>A <code>vec</code> that contains the upper confidence interval points.</p>
</td></tr>
<tr><td><code id="fast_cov_cpp_+3A_ci_lo">ci_lo</code></td>
<td>
<p>A <code>vec</code> that contains the lower confidence interval points.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A diagonal matrix.
</p>

<hr>
<h2 id='FGN'>Definition of a Fractional Gaussian Noise (FGN) Process</h2><span id='topic+FGN'></span>

<h3>Description</h3>

<p>Definition of a Fractional Gaussian Noise (FGN) Process
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FGN(sigma2 = 1, H = 0.9999)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="FGN_+3A_sigma2">sigma2</code></td>
<td>
<p>A <code>double</code>.</p>
</td></tr>
<tr><td><code id="FGN_+3A_h">H</code></td>
<td>
<p>A <code>double</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An S3 object containing the specified ts.model with the following structure:
</p>

<dl>
<dt>process.desc</dt><dd><p>Used in summary: &quot;SIGMA2&quot;,&quot;H&quot;</p>
</dd>
<dt>theta</dt><dd><p>Parameter vector including <code class="reqn">\sigma^2</code>, <code class="reqn">H</code> </p>
</dd>
<dt>plength</dt><dd><p>Number of parameters</p>
</dd>
<dt>print</dt><dd><p>String containing simplified model</p>
</dd>
<dt>desc</dt><dd><p>&quot;FGN&quot;</p>
</dd>
<dt>obj.desc</dt><dd><p>Depth of Parameters e.g. list(1,1)</p>
</dd>
<dt>starting</dt><dd><p>Find starting values? TRUE or FALSE (e.g. specified value)</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Lionel Voirol,  Davide Cucci
</p>


<h3>Examples</h3>

<pre><code class='language-R'>FGN()
FGN(sigma2 = 1, H = 0.9999)
</code></pre>

<hr>
<h2 id='field_to_matrix'>Transform an Armadillo field&lt;vec&gt; to a matrix</h2><span id='topic+field_to_matrix'></span>

<h3>Description</h3>

<p>Unlists vectors in a field and places them into a matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>field_to_matrix(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="field_to_matrix_+3A_x">x</code></td>
<td>
<p>A <code>field&lt;vec&gt;</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>mat</code> containing the field elements within a column.
</p>


<h3>Author(s)</h3>

<p>JJB
</p>

<hr>
<h2 id='find_full_model'>Find the Common Denominator of the Models</h2><span id='topic+find_full_model'></span>

<h3>Description</h3>

<p>Determines the common denominator among models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find_full_model(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="find_full_model_+3A_x">x</code></td>
<td>
<p>A <code>vector&lt; vector&lt;string&gt; &gt;</code> that contains all possible models under consideration</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>vector&lt;string&gt;</code> that contains the terms of the common denominator of all models
</p>

<hr>
<h2 id='fk14_filter'>fk14 filter construction</h2><span id='topic+fk14_filter'></span>

<h3>Description</h3>

<p>Creates the fk14 filter
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fk14_filter()
</code></pre>


<h3>Details</h3>

<p>This template can be used to increase the amount of filters available for selection.
</p>


<h3>Value</h3>

<p>A <code>field&lt;vec&gt;</code> that contains:
</p>

<ul>
<li><p>&quot;L&quot;A <code>integer</code> specifying the length of the filter
</p>
</li>
<li><p>&quot;h&quot;A <code>vector</code> containing the coefficients for the wavelet filter
</p>
</li>
<li><p>&quot;g&quot;A <code>vector</code> containing the coefficients for the scaling filter
</p>
</li></ul>



<h3>Author(s)</h3>

<p>JJB
</p>

<hr>
<h2 id='fk22_filter'>fk22 filter construction</h2><span id='topic+fk22_filter'></span>

<h3>Description</h3>

<p>Creates the fk22 filter
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fk22_filter()
</code></pre>


<h3>Details</h3>

<p>This template can be used to increase the amount of filters available for selection.
</p>


<h3>Value</h3>

<p>A <code>field&lt;vec&gt;</code> that contains:
</p>

<ul>
<li><p>&quot;L&quot;A <code>integer</code> specifying the length of the filter
</p>
</li>
<li><p>&quot;h&quot;A <code>vector</code> containing the coefficients for the wavelet filter
</p>
</li>
<li><p>&quot;g&quot;A <code>vector</code> containing the coefficients for the scaling filter
</p>
</li></ul>



<h3>Author(s)</h3>

<p>JJB
</p>

<hr>
<h2 id='fk4_filter'>fk4 filter construction</h2><span id='topic+fk4_filter'></span>

<h3>Description</h3>

<p>Creates the fk4 filter
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fk4_filter()
</code></pre>


<h3>Details</h3>

<p>This template can be used to increase the amount of filters available for selection.
</p>


<h3>Value</h3>

<p>A <code>field&lt;vec&gt;</code> that contains:
</p>

<ul>
<li><p>&quot;L&quot;A <code>integer</code> specifying the length of the filter
</p>
</li>
<li><p>&quot;h&quot;A <code>vector</code> containing the coefficients for the wavelet filter
</p>
</li>
<li><p>&quot;g&quot;A <code>vector</code> containing the coefficients for the scaling filter
</p>
</li></ul>



<h3>Author(s)</h3>

<p>JJB
</p>

<hr>
<h2 id='fk6_filter'>fk6 filter construction</h2><span id='topic+fk6_filter'></span>

<h3>Description</h3>

<p>Creates the fk6 filter
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fk6_filter()
</code></pre>


<h3>Details</h3>

<p>This template can be used to increase the amount of filters available for selection.
</p>


<h3>Value</h3>

<p>A <code>field&lt;vec&gt;</code> that contains:
</p>

<ul>
<li><p>&quot;L&quot;A <code>integer</code> specifying the length of the filter
</p>
</li>
<li><p>&quot;h&quot;A <code>vector</code> containing the coefficients for the wavelet filter
</p>
</li>
<li><p>&quot;g&quot;A <code>vector</code> containing the coefficients for the scaling filter
</p>
</li></ul>



<h3>Author(s)</h3>

<p>JJB
</p>

<hr>
<h2 id='fk8_filter'>fk8 filter construction</h2><span id='topic+fk8_filter'></span>

<h3>Description</h3>

<p>Creates the fk8 filter
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fk8_filter()
</code></pre>


<h3>Details</h3>

<p>This template can be used to increase the amount of filters available for selection.
</p>


<h3>Value</h3>

<p>A <code>field&lt;vec&gt;</code> that contains:
</p>

<ul>
<li><p>&quot;L&quot;A <code>integer</code> specifying the length of the filter
</p>
</li>
<li><p>&quot;h&quot;A <code>vector</code> containing the coefficients for the wavelet filter
</p>
</li>
<li><p>&quot;g&quot;A <code>vector</code> containing the coefficients for the scaling filter
</p>
</li></ul>



<h3>Author(s)</h3>

<p>JJB
</p>

<hr>
<h2 id='format_ci'>Format the Confidence Interval for Estimates</h2><span id='topic+format_ci'></span>

<h3>Description</h3>

<p>Creates hi and lo confidence based on SE and alpha.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>format_ci(theta, se, alpha)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="format_ci_+3A_theta">theta</code></td>
<td>
<p>A <code>vec</code> containing the estimates</p>
</td></tr>
<tr><td><code id="format_ci_+3A_se">se</code></td>
<td>
<p>A <code>vec</code> containing the standard error</p>
</td></tr>
<tr><td><code id="format_ci_+3A_alpha">alpha</code></td>
<td>
<p>A <code>double</code> that contains the confidence level.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>mat</code> that has:
</p>

<ul>
<li><p> Column 1: Lo CI
</p>
</li>
<li><p> Column 2: Hi CI
</p>
</li>
<li><p> Column 3: SE
</p>
</li></ul>


<hr>
<h2 id='gen_ar1'>Generate an Autoregressive Order 1 ( AR(1) ) sequence</h2><span id='topic+gen_ar1'></span>

<h3>Description</h3>

<p>Generate an Autoregressive Order 1 sequence given <code class="reqn">\phi</code> and <code class="reqn">\sigma^2</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gen_ar1(N, phi = 0.3, sigma2 = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gen_ar1_+3A_n">N</code></td>
<td>
<p>An <code>unsigned integer</code> for signal length.</p>
</td></tr>
<tr><td><code id="gen_ar1_+3A_phi">phi</code></td>
<td>
<p>A <code>double</code> that contains autocorrection.</p>
</td></tr>
<tr><td><code id="gen_ar1_+3A_sigma2">sigma2</code></td>
<td>
<p>A <code>double</code> that contains process variance.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function implements a way to generate the AR(1)'s <code class="reqn">x_t</code> values <em>without</em> calling the general ARMA function.
Thus, the function is able to generate values much faster than <code><a href="#topic+gen_arma">gen_arma</a></code>.
</p>


<h3>Value</h3>

<p>A <code>vec</code> containing the AR(1) process.
</p>


<h3>Process Definition</h3>

<p>The Autoregressive order 1 (AR1) process with non-zero parameter <code class="reqn">\phi \in (-1,+1)</code> and <code class="reqn">\sigma^2 \in {\rm I\!R}^{2}</code>.
This process is defined as: 
</p>
<p style="text-align: center;"><code class="reqn">{X_t} = {\phi _1}{X_{t - 1}} + {\varepsilon_t} </code>
</p>
<p>,
where </p>
<p style="text-align: center;"><code class="reqn">{\varepsilon_t}\mathop  \sim \limits^{iid} N\left( {0,\sigma^2} \right)</code>
</p>

<p>AR(1) processes are sometimes used as an approximation for Bias Instability noises.
</p>


<h3>Generation Algorithm</h3>

<p>The function first generates a vector of White Noise with length <code class="reqn">N+1</code> using <code><a href="#topic+gen_wn">gen_wn</a></code> and then obtains the
autoregressive values under the above process definition.
</p>
<p>The <code class="reqn">X_0</code> (first value of <code class="reqn">X_t</code>) is discarded.
</p>

<hr>
<h2 id='gen_ar1blocks'>Generate AR(1) Block Process</h2><span id='topic+gen_ar1blocks'></span>

<h3>Description</h3>

<p>This function allows us to generate a non-stationary AR(1) block process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gen_ar1blocks(phi, sigma2, n_total, n_block, scale = 10, 
title = NULL, seed = 135, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gen_ar1blocks_+3A_phi">phi</code></td>
<td>
<p>A <code>double</code> value for the autocorrection parameter <code class="reqn">\phi</code>.</p>
</td></tr>
<tr><td><code id="gen_ar1blocks_+3A_sigma2">sigma2</code></td>
<td>
<p>A <code>double</code> value for the variance parameter <code class="reqn">\sigma ^2</code>.</p>
</td></tr>
<tr><td><code id="gen_ar1blocks_+3A_n_total">n_total</code></td>
<td>
<p>An <code>integer</code> indicating the length of the simulated AR(1) block process.</p>
</td></tr>
<tr><td><code id="gen_ar1blocks_+3A_n_block">n_block</code></td>
<td>
<p>An <code>integer</code> indicating the length of each block of the AR(1) block process.</p>
</td></tr>
<tr><td><code id="gen_ar1blocks_+3A_scale">scale</code></td>
<td>
<p>An <code>integer</code> indicating the number of levels of decomposition. The default value is 10.</p>
</td></tr>
<tr><td><code id="gen_ar1blocks_+3A_title">title</code></td>
<td>
<p>A <code>string</code> indicating the name of the time series data.</p>
</td></tr>
<tr><td><code id="gen_ar1blocks_+3A_seed">seed</code></td>
<td>
<p>An <code>integer</code> defined for simulation replication purposes.</p>
</td></tr>
<tr><td><code id="gen_ar1blocks_+3A_...">...</code></td>
<td>
<p>Additional parameters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>vector</code> containing the AR(1) block process.
</p>


<h3>Note</h3>

<p>This function generates a non-stationary AR(1) block process whose 
theoretical maximum overlapping allan variance (MOAV) is different 
from the theoretical MOAV of a stationary AR(1) process. This difference in the value of the allan variance 
between stationary and non-stationary processes has been shown through the 
calculation of the theoretical allan variance given in  &quot;A Study of the Allan Variance for 
Constant-Mean Non-Stationary Processes&quot; by Xu et al. (IEEE Signal Processing Letters, 2017), 
preprint available: <a href="https://arxiv.org/abs/1702.07795">https://arxiv.org/abs/1702.07795</a>.
</p>


<h3>Author(s)</h3>

<p>Yuming Zhang and Haotian Xu
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Xt = gen_ar1blocks(phi = 0.9, sigma2 = 1, 
n_total = 1000, n_block = 10, scale = 100)
plot(Xt)

Yt = gen_ar1blocks(phi = 0.5, sigma2 = 5, n_total = 800, 
n_block = 20, scale = 50)
plot(Yt)
</code></pre>

<hr>
<h2 id='gen_arima'>Generate Autoregressive Order p, Integrated d, Moving Average Order q (ARIMA(p,d,q)) Model</h2><span id='topic+gen_arima'></span>

<h3>Description</h3>

<p>Generate an ARIMA(p,d,q) process with supplied vector of Autoregressive Coefficients (<code class="reqn">\phi</code>), Integrated <code class="reqn">d</code>, Moving Average Coefficients (<code class="reqn">\theta</code>), and <code class="reqn">\sigma^2</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gen_arima(N, ar, d, ma, sigma2 = 1.5, n_start = 0L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gen_arima_+3A_n">N</code></td>
<td>
<p>An <code>integer</code> for signal length.</p>
</td></tr>
<tr><td><code id="gen_arima_+3A_ar">ar</code></td>
<td>
<p>A <code>vec</code> that contains the AR coefficients.</p>
</td></tr>
<tr><td><code id="gen_arima_+3A_d">d</code></td>
<td>
<p>An <code>integer</code> that indicates a difference.</p>
</td></tr>
<tr><td><code id="gen_arima_+3A_ma">ma</code></td>
<td>
<p>A <code>vec</code> that contains the MA coefficients.</p>
</td></tr>
<tr><td><code id="gen_arima_+3A_sigma2">sigma2</code></td>
<td>
<p>A <code>double</code> that contains process variance.</p>
</td></tr>
<tr><td><code id="gen_arima_+3A_n_start">n_start</code></td>
<td>
<p>An <code>unsigned int</code> that indicates the amount of observations to be used for the burn in period.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The innovations are generated from a normal distribution.
The <code class="reqn">\sigma^2</code> parameter is indeed a variance parameter. 
This differs from R's use of the standard deviation, <code class="reqn">\sigma</code>.
</p>


<h3>Value</h3>

<p>A <code>vec</code> that contains the generated observations.
</p>


<h3>Warning</h3>

<p>Please note, this function will generate a sum of <code class="reqn">N + d</code> number of observations,
where <code class="reqn">d</code> denotes the number of differences necessary.
</p>

<hr>
<h2 id='gen_arma'>Generate Autoregressive Order <code class="reqn">p</code> - Moving Average Order <code class="reqn">q</code> (ARMA(<code class="reqn">p</code>,<code class="reqn">q</code>)) Model</h2><span id='topic+gen_arma'></span>

<h3>Description</h3>

<p>Generate an ARMA(<code class="reqn">p</code>,<code class="reqn">q</code>) process with supplied vector of Autoregressive Coefficients (<code class="reqn">\phi</code>), Moving Average Coefficients (<code class="reqn">\theta</code>), and <code class="reqn">\sigma^2</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gen_arma(N, ar, ma, sigma2 = 1.5, n_start = 0L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gen_arma_+3A_n">N</code></td>
<td>
<p>An <code>integer</code> for signal length.</p>
</td></tr>
<tr><td><code id="gen_arma_+3A_ar">ar</code></td>
<td>
<p>A <code>vec</code> that contains the AR coefficients.</p>
</td></tr>
<tr><td><code id="gen_arma_+3A_ma">ma</code></td>
<td>
<p>A <code>vec</code> that contains the MA coefficients.</p>
</td></tr>
<tr><td><code id="gen_arma_+3A_sigma2">sigma2</code></td>
<td>
<p>A <code>double</code> that contains process variance.</p>
</td></tr>
<tr><td><code id="gen_arma_+3A_n_start">n_start</code></td>
<td>
<p>An <code>unsigned int</code> that indicates the amount of observations to be used for the burn in period.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For <code><a href="#topic+gen_ar1">AR(1)</a></code>, <code><a href="#topic+gen_ma1">MA(1)</a></code>, and <code><a href="#topic+gen_arma11">ARMA(1,1)</a></code> please use their functions if speed is important
as this function is designed to generate generic ARMA processes.
</p>


<h3>Value</h3>

<p>A <code>vec</code> that contains the generated observations.
</p>


<h3>Process Definition</h3>

<p>The Autoregressive order <code class="reqn">p</code> and Moving Average order <code class="reqn">q</code> (ARMA(<code class="reqn">p</code>,<code class="reqn">q</code>)) process with non-zero parameters <code class="reqn">\phi_i \in (-1,+1)</code> for the AR components,
<code class="reqn">\theta_j \in (-1,+1)</code> for the MA components, and <code class="reqn">\sigma^2 \in {\rm I\!R}^{+}</code>.
This process is defined as:
</p>
<p style="text-align: center;"><code class="reqn">{X_t} = \sum\limits_{i = 1}^p {{\phi _i}{X_{t - i}}}  + \sum\limits_{i = 1}^q {{\theta _i}{\varepsilon _{t - i}}}  + {\varepsilon _t}</code>
</p>
  
<p>where
</p>
<p style="text-align: center;"><code class="reqn">{\varepsilon_t}\mathop  \sim \limits^{iid} N\left( {0,\sigma^2} \right)</code>
</p>



<h3>Generation Algorithm</h3>

<p>The innovations are generated from a normal distribution.
The <code class="reqn">\sigma^2</code> parameter is indeed a variance parameter. 
This differs from R's use of the standard deviation, <code class="reqn">\sigma</code>.
</p>

<hr>
<h2 id='gen_arma11'>Generate an ARMA(1,1) sequence</h2><span id='topic+gen_arma11'></span>

<h3>Description</h3>

<p>Generate an ARMA(1,1) sequence given <code class="reqn">\phi</code>, <code class="reqn">\theta</code>, and <code class="reqn">\sigma^2</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gen_arma11(N, phi = 0.1, theta = 0.3, sigma2 = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gen_arma11_+3A_n">N</code></td>
<td>
<p>An <code>integer</code> for signal length.</p>
</td></tr>
<tr><td><code id="gen_arma11_+3A_phi">phi</code></td>
<td>
<p>A <code>double</code> that contains autoregressive.</p>
</td></tr>
<tr><td><code id="gen_arma11_+3A_theta">theta</code></td>
<td>
<p>A <code>double</code> that contains moving average.</p>
</td></tr>
<tr><td><code id="gen_arma11_+3A_sigma2">sigma2</code></td>
<td>
<p>A <code>double</code> that contains process variance.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function implements a way to generate the <code class="reqn">x_t</code> values without calling the general ARMA function.
</p>


<h3>Value</h3>

<p>A <code>vec</code> containing the MA(1) process.
</p>


<h3>Process Definition</h3>

<p>The Autoregressive order 1 and Moving Average order 1 (ARMA(1,1)) process with non-zero parameters <code class="reqn">\phi \in (-1,+1)</code> for the AR component,
<code class="reqn">\theta \in (-1,+1)</code> for the MA component, and <code class="reqn">\sigma^2 \in {\rm I\!R}^{+}</code>.
This process is defined as:
</p>
<p style="text-align: center;"><code class="reqn">{X_t} = {\phi _1}{X_{t - 1}} + {\theta _1}{\varepsilon_{t - 1}} + {\varepsilon_t}</code>
</p>
<p>,
where
</p>
<p style="text-align: center;"><code class="reqn">{\varepsilon_t}\mathop  \sim \limits^{iid} N\left( {0,\sigma^2} \right)</code>
</p>



<h3>Generation Algorithm</h3>

<p>The function first generates a vector of white noise using <code>gen_wn</code> and then obtains the
ARMA values under the above equation.
</p>
<p>The <code class="reqn">X_0</code> (first value of <code class="reqn">X_t</code>) is discarded.
</p>

<hr>
<h2 id='gen_bi'>Generate Bias-Instability Process</h2><span id='topic+gen_bi'></span>

<h3>Description</h3>

<p>This function allows to generate a non-stationary bias-instability process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gen_bi(sigma2, n_total, n_block, title = NULL, seed = 135, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gen_bi_+3A_sigma2">sigma2</code></td>
<td>
<p>A <code>double</code> value for the variance parameter <code class="reqn">\sigma ^2</code>.</p>
</td></tr>
<tr><td><code id="gen_bi_+3A_n_total">n_total</code></td>
<td>
<p>An <code>integer</code> indicating the length of the simulated bias-instability process.</p>
</td></tr>
<tr><td><code id="gen_bi_+3A_n_block">n_block</code></td>
<td>
<p>An <code>integer</code> indicating the length of each block of the bias-instability process.</p>
</td></tr>
<tr><td><code id="gen_bi_+3A_title">title</code></td>
<td>
<p>A <code>string</code> defining the name of the time series data.</p>
</td></tr>
<tr><td><code id="gen_bi_+3A_seed">seed</code></td>
<td>
<p>An <code>integer</code> defined for simulation replication purposes.</p>
</td></tr>
<tr><td><code id="gen_bi_+3A_...">...</code></td>
<td>
<p>Additional parameters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>vector</code> containing the bias-instability process.
</p>


<h3>Note</h3>

<p>This function generates a non-stationary bias-instability process
whose theoretical maximum overlapping allan variance (MOAV) is close to the theoretical
MOAV of the best approximation of this process through a stationary AR(1) process over some scales. However, this approximation 
is not good enough when considering the logarithmic representation of the allan variance.
Therefore, the exact form of the allan variance of this non-stationary process allows us 
to better interpret the signals characterized by bias-instability, as shown in &quot;A Study 
of the Allan Variance for Constant-Mean Non-Stationary Processes&quot; by Xu et al. (IEEE Signal 
Processing Letters, 2017), preprint available: <a href="https://arxiv.org/abs/1702.07795">https://arxiv.org/abs/1702.07795</a>.
</p>


<h3>Author(s)</h3>

<p>Yuming Zhang
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Xt = gen_bi(sigma2 = 1, n_total = 1000, n_block = 10)
plot(Xt)

Yt = gen_bi(sigma2 = 0.8, n_total = 800, n_block = 20,
title = "non-stationary bias-instability process")
plot(Yt)
</code></pre>

<hr>
<h2 id='gen_dr'>Generate a Drift Process</h2><span id='topic+gen_dr'></span>

<h3>Description</h3>

<p>Simulates a Drift Process with a given slope, <code class="reqn">\omega</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gen_dr(N, omega = 5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gen_dr_+3A_n">N</code></td>
<td>
<p>An <code>integer</code> for signal length.</p>
</td></tr>
<tr><td><code id="gen_dr_+3A_omega">omega</code></td>
<td>
<p>A <code>double</code> that contains drift slope</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>vec</code> containing the drift.
</p>


<h3>Process Definition</h3>

<p>Drift with parameter <code class="reqn">\omega \in \Omega</code> where <code class="reqn">\Omega</code> is in
<code class="reqn">{\rm I\!R}^{+}</code> or <code class="reqn">{\rm I\!R}^{-}</code>. This process is defined as:
<code class="reqn">X_t = \omega t</code> and is occasionally referred to as Rate Ramp.
</p>


<h3>Generation Algorithm</h3>

<p>To generate the Drift process, we first fill a <code>vector</code> with the <code class="reqn">\omega</code> parameter.
After, we take the cumulative sum along the vector.
</p>

<hr>
<h2 id='gen_fgn'>Generate a Fractional Gaussian noise given <code class="reqn">\sigma^2</code> and <code class="reqn">H</code>.</h2><span id='topic+gen_fgn'></span>

<h3>Description</h3>

<p>Simulates a Fractional Gaussian noise given <code class="reqn">\sigma^2</code> and <code class="reqn">H</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gen_fgn(N, sigma2 = 1, H = 0.9)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gen_fgn_+3A_n">N</code></td>
<td>
<p>An <code>integer</code> for signal length.</p>
</td></tr>
<tr><td><code id="gen_fgn_+3A_sigma2">sigma2</code></td>
<td>
<p>A <code>double</code>.</p>
</td></tr>
<tr><td><code id="gen_fgn_+3A_h">H</code></td>
<td>
<p>A <code>double</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>fgn A <code>vec</code> containing the Fractional Gaussian noise process.
</p>

<hr>
<h2 id='gen_generic_sarima'>Generate Generic Seasonal Autoregressive Order P - Moving Average Order Q (SARMA(p,q)x(P,Q)) Model</h2><span id='topic+gen_generic_sarima'></span>

<h3>Description</h3>

<p>Generate an ARMA(P,Q) process with supplied vector of Autoregressive Coefficients (<code class="reqn">\phi</code>), Moving Average Coefficients (<code class="reqn">\theta</code>), and <code class="reqn">\sigma^2</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gen_generic_sarima(N, theta_values, objdesc, sigma2 = 1.5, n_start = 0L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gen_generic_sarima_+3A_n">N</code></td>
<td>
<p>An <code>integer</code> for signal length.</p>
</td></tr>
<tr><td><code id="gen_generic_sarima_+3A_theta_values">theta_values</code></td>
<td>
<p>A <code>vec</code> containing the parameters for (S)AR and (S)MA.</p>
</td></tr>
<tr><td><code id="gen_generic_sarima_+3A_objdesc">objdesc</code></td>
<td>
<p>A <code>vec</code> that contains the <code><a href="#topic++2B.ts.model">+.ts.model</a></code>'s obj.desc field.</p>
</td></tr>
<tr><td><code id="gen_generic_sarima_+3A_sigma2">sigma2</code></td>
<td>
<p>A <code>double</code> that contains process variance.</p>
</td></tr>
<tr><td><code id="gen_generic_sarima_+3A_n_start">n_start</code></td>
<td>
<p>An <code>unsigned int</code> that indicates the amount of observations to be used for the burn in period.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The innovations are generated from a normal distribution.
The <code class="reqn">\sigma^2</code> parameter is indeed a variance parameter. 
This differs from R's use of the standard deviation, <code class="reqn">\sigma</code>.
</p>


<h3>Value</h3>

<p>A <code>vec</code> that contains the generated observations.
</p>

<hr>
<h2 id='gen_gts'>Simulate a simts TS object using a theoretical model</h2><span id='topic+gen_gts'></span>

<h3>Description</h3>

<p>Create a <code>gts</code> object based on a time series model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gen_gts(
  n,
  model,
  start = 0,
  end = NULL,
  freq = 1,
  unit_ts = NULL,
  unit_time = NULL,
  name_ts = NULL,
  name_time = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gen_gts_+3A_n">n</code></td>
<td>
<p>An <code>integer</code> containing the length of the time series.</p>
</td></tr>
<tr><td><code id="gen_gts_+3A_model">model</code></td>
<td>
<p>A <code>ts.model</code> or <code>simts</code> object containing the available models in the simts package.</p>
</td></tr>
<tr><td><code id="gen_gts_+3A_start">start</code></td>
<td>
<p>A <code>numeric</code> that provides the time of the first observation.</p>
</td></tr>
<tr><td><code id="gen_gts_+3A_end">end</code></td>
<td>
<p>A <code>numeric</code> that provides the time of the last observation.</p>
</td></tr>
<tr><td><code id="gen_gts_+3A_freq">freq</code></td>
<td>
<p>A <code>numeric</code> that provides the rate of samples. Default value is 1.</p>
</td></tr>
<tr><td><code id="gen_gts_+3A_unit_ts">unit_ts</code></td>
<td>
<p>A <code>string</code> that contains the unit expression of the time series. Default value is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="gen_gts_+3A_unit_time">unit_time</code></td>
<td>
<p>A <code>string</code> that contains the unit expression of the time. Default value is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="gen_gts_+3A_name_ts">name_ts</code></td>
<td>
<p>A <code>string</code> that provides an identifier for the time series data. Default value is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="gen_gts_+3A_name_time">name_time</code></td>
<td>
<p>A <code>string</code> that provides an identifier for the time. Default value is <code>NULL</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function accepts either a <code>ts.model</code> object (e.g. AR1(phi = .3, sigma2 =1) + WN(sigma2 = 1)) or a <code>simts</code> object.
</p>


<h3>Value</h3>

<p>A <code>gts</code> object
</p>


<h3>Author(s)</h3>

<p>James Balamuta and Wenchao Yang
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Set seed for reproducibility
set.seed(1336)
n = 1000

# AR1 + WN
model = AR1(phi = .5, sigma2 = .1) + WN(sigma2=1)
x = gen_gts(n, model)
plot(x)

# Reset seed
set.seed(1336)

# GM + WN
# Convert from AR1 to GM values
m = ar1_to_gm(c(.5,.1),10)

# Beta = 6.9314718, Sigma2_gm = 0.1333333
model = GM(beta = m[1], sigma2_gm = m[2]) + WN(sigma2=1)
x2 = gen_gts(n, model, freq = 10, unit_time = 'sec')
plot(x2)

# Same time series
all.equal(x, x2, check.attributes = FALSE)
</code></pre>

<hr>
<h2 id='gen_lts'>Generate a Latent Time Series Object Based on a Model</h2><span id='topic+gen_lts'></span>

<h3>Description</h3>

<p>Simulate a <code>lts</code> object based on a supplied time series model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gen_lts(
  n,
  model,
  start = 0,
  end = NULL,
  freq = 1,
  unit_ts = NULL,
  unit_time = NULL,
  name_ts = NULL,
  name_time = NULL,
  process = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gen_lts_+3A_n">n</code></td>
<td>
<p>An <code>interger</code> indicating the amount of observations generated in this function.</p>
</td></tr>
<tr><td><code id="gen_lts_+3A_model">model</code></td>
<td>
<p>A <code>ts.model</code> or <code>simts</code> object containing one of the allowed models.</p>
</td></tr>
<tr><td><code id="gen_lts_+3A_start">start</code></td>
<td>
<p>A <code>numeric</code> that provides the time of the first observation.</p>
</td></tr>
<tr><td><code id="gen_lts_+3A_end">end</code></td>
<td>
<p>A <code>numeric</code> that provides the time of the last observation.</p>
</td></tr>
<tr><td><code id="gen_lts_+3A_freq">freq</code></td>
<td>
<p>A <code>numeric</code> that provides the rate/frequency at which the time series is sampled. The default value is 1.</p>
</td></tr>
<tr><td><code id="gen_lts_+3A_unit_ts">unit_ts</code></td>
<td>
<p>A <code>string</code> that contains the unit of measure of the time series. The default value is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="gen_lts_+3A_unit_time">unit_time</code></td>
<td>
<p>A <code>string</code> that contains the unit of measure of the time. The default value is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="gen_lts_+3A_name_ts">name_ts</code></td>
<td>
<p>A <code>string</code> that provides an identifier for the time series data. Default value is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="gen_lts_+3A_name_time">name_time</code></td>
<td>
<p>A <code>string</code> that provides an identifier for the time. Default value is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="gen_lts_+3A_process">process</code></td>
<td>
<p>A <code>vector</code> that contains model names of each column in the <code>data</code> object where the last name is the sum of the previous names.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function accepts either a <code>ts.model</code> object (e.g. AR1(phi = .3, sigma2 =1) + WN(sigma2 = 1)) or a <code>simts</code> object.
</p>


<h3>Value</h3>

<p>A <code>lts</code> object with the following attributes:
</p>

<dl>
<dt>start</dt><dd><p>The time of the first observation.</p>
</dd>
<dt>end</dt><dd><p>The time of the last observation.</p>
</dd>
<dt>freq</dt><dd><p>Numeric representation of the sampling frequency/rate.</p>
</dd>
<dt>unit</dt><dd><p>A string reporting the unit of measurement.</p>
</dd>
<dt>name</dt><dd><p>Name of the generated dataset.</p>
</dd>
<dt>process</dt><dd><p>A <code>vector</code> that contains model names of decomposed and combined processes</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>James Balamuta, Wenchao Yang, and Justin Lee
</p>


<h3>Examples</h3>

<pre><code class='language-R'># AR
set.seed(1336)
model = AR1(phi = .99, sigma2 = 1) + WN(sigma2 = 1)
test = gen_lts(1000, model)
plot(test)
</code></pre>

<hr>
<h2 id='gen_lts_cpp'>Generate Latent Time Series based on Model (Internal)</h2><span id='topic+gen_lts_cpp'></span>

<h3>Description</h3>

<p>Create a latent time series based on a supplied time series model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gen_lts_cpp(N, theta, desc, objdesc)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gen_lts_cpp_+3A_n">N</code></td>
<td>
<p>An <code>interger</code> containing the amount of observations for the time series.</p>
</td></tr>
<tr><td><code id="gen_lts_cpp_+3A_theta">theta</code></td>
<td>
<p>A <code>vec</code> containing the parameters to use to generate the model.</p>
</td></tr>
<tr><td><code id="gen_lts_cpp_+3A_desc">desc</code></td>
<td>
<p>A <code>vector&lt;string&gt;</code> containing the different model types (AR1, WN, etc..).</p>
</td></tr>
<tr><td><code id="gen_lts_cpp_+3A_objdesc">objdesc</code></td>
<td>
<p>A <code>field&lt;vec&gt;</code> containing the different model objects e.g. AR1 = c(1,1)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>mat</code> containing data for each decomposed and combined time series.
</p>

<hr>
<h2 id='gen_ma1'>Generate an Moving Average Order 1 (MA(1)) Process</h2><span id='topic+gen_ma1'></span>

<h3>Description</h3>

<p>Generate an MA(1) Process given <code class="reqn">\theta</code> and <code class="reqn">\sigma^2</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gen_ma1(N, theta = 0.3, sigma2 = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gen_ma1_+3A_n">N</code></td>
<td>
<p>An <code>integer</code> for signal length.</p>
</td></tr>
<tr><td><code id="gen_ma1_+3A_theta">theta</code></td>
<td>
<p>A <code>double</code> that contains moving average.</p>
</td></tr>
<tr><td><code id="gen_ma1_+3A_sigma2">sigma2</code></td>
<td>
<p>A <code>double</code> that contains process variance.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function implements a way to generate the <code class="reqn">x_t</code> values without calling the general ARMA function.
</p>


<h3>Value</h3>

<p>A <code>vec</code> containing the MA(1) process.
</p>


<h3>Process Definition</h3>

<p>The Moving Average order 1 (MA(1)) process with non-zero parameter <code class="reqn">\theta \in (-1,+1)</code> 
and <code class="reqn">\sigma^2 \in {\rm I\!R}^{+}</code>. This process is defined as:
</p>
<p style="text-align: center;"><code class="reqn">{x_t} = {\varepsilon_t} + {\theta _1}{\varepsilon_{t - 1}}</code>
</p>
<p>,
where 
</p>
<p style="text-align: center;"><code class="reqn">{\varepsilon_t}\mathop  \sim \limits^{iid} N\left( {0,\sigma^2} \right)</code>
</p>



<h3>Generation Algorithm</h3>

<p>The function first generates a vector of white noise using <code><a href="#topic+gen_wn">gen_wn</a></code> and then obtains the
MA values under the above equation. 
</p>
<p>The <code class="reqn">X_0</code> (first value of <code class="reqn">X_t</code>) is discarded.
</p>

<hr>
<h2 id='gen_matern'>Generate a Matern Process given <code class="reqn">\sigma^2</code>, <code class="reqn">\lambda</code> and <code class="reqn">\alpha</code>.</h2><span id='topic+gen_matern'></span>

<h3>Description</h3>

<p>Simulates a Matern Process given <code class="reqn">\sigma^2</code>, <code class="reqn">\lambda</code> and <code class="reqn">\alpha</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gen_matern(N, sigma2 = 1, lambda = 0.35, alpha = 0.9)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gen_matern_+3A_n">N</code></td>
<td>
<p>An <code>integer</code> for signal length.</p>
</td></tr>
<tr><td><code id="gen_matern_+3A_sigma2">sigma2</code></td>
<td>
<p>A <code>double</code>.</p>
</td></tr>
<tr><td><code id="gen_matern_+3A_lambda">lambda</code></td>
<td>
<p>A <code>double</code>.</p>
</td></tr>
<tr><td><code id="gen_matern_+3A_alpha">alpha</code></td>
<td>
<p>A <code>double</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>mtp A <code>vec</code> containing the Matern Process.
</p>

<hr>
<h2 id='gen_mean'>Generate a determinist vector returned by the matrix by vector product of matrix <code class="reqn">X</code> and vector <code class="reqn">\beta</code>.</h2><span id='topic+gen_mean'></span>

<h3>Description</h3>

<p>Generate a determinist vector returned by the matrix by vector product of matrix <code class="reqn">X</code> and vector <code class="reqn">\beta</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gen_mean(X, beta)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gen_mean_+3A_x">X</code></td>
<td>
<p>A <code>Matrix</code>  with dimension n*p.</p>
</td></tr>
<tr><td><code id="gen_mean_+3A_beta">beta</code></td>
<td>
<p>A <code>vector</code> with dimension p*1</p>
</td></tr>
</table>


<h3>Value</h3>

<p>mean_vec A <code>vec</code> containing the determinist vector.
</p>

<hr>
<h2 id='gen_model'>Generate Time Series based on Model (Internal)</h2><span id='topic+gen_model'></span>

<h3>Description</h3>

<p>Create a time series process based on a supplied <code>ts.model</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gen_model(N, theta, desc, objdesc)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gen_model_+3A_n">N</code></td>
<td>
<p>An <code>interger</code> containing the amount of observations for the time series.</p>
</td></tr>
<tr><td><code id="gen_model_+3A_theta">theta</code></td>
<td>
<p>A <code>vec</code> containing the parameters to use to generate the model</p>
</td></tr>
<tr><td><code id="gen_model_+3A_desc">desc</code></td>
<td>
<p>A <code>vector&lt;string&gt;</code> containing the different model types (AR1, WN, etc..)</p>
</td></tr>
<tr><td><code id="gen_model_+3A_objdesc">objdesc</code></td>
<td>
<p>A <code>field&lt;vec&gt;</code> contains the different model objects e.g. AR1 = c(1,1)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>vec</code> that contains combined time series.
</p>

<hr>
<h2 id='gen_nswn'>Generate Non-Stationary White Noise Process</h2><span id='topic+gen_nswn'></span>

<h3>Description</h3>

<p>This function allows to generate a non-stationary white noise process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gen_nswn(n_total, title = NULL, seed = 135, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gen_nswn_+3A_n_total">n_total</code></td>
<td>
<p>An <code>integer</code> indicating the length of the simulated non-stationary white noise process.</p>
</td></tr>
<tr><td><code id="gen_nswn_+3A_title">title</code></td>
<td>
<p>A <code>string</code> defining the name of the time series data.</p>
</td></tr>
<tr><td><code id="gen_nswn_+3A_seed">seed</code></td>
<td>
<p>An <code>integer</code> defined for simulation replication purposes.</p>
</td></tr>
<tr><td><code id="gen_nswn_+3A_...">...</code></td>
<td>
<p>Additional parameters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>vector</code> containing the non-stationary white noise process.
</p>


<h3>Note</h3>

<p>This function generates a non-stationary white noise process whose theoretical maximum overlapping allan variance (MOAV) corresponds to the 
theoretical MOAV of the stationary white noise process. This example confirms that the allan 
variance is unable to distinguish between a stationary white noise process and a white noise 
process whose second-order behavior is non-stationary, as pointed out in the paper &quot;A Study of 
the Allan Variance for Constant-Mean Non-Stationary Processes&quot; by Xu et al. (IEEE Signal Processing 
Letters, 2017), preprint available: <a href="https://arxiv.org/abs/1702.07795">https://arxiv.org/abs/1702.07795</a>.
</p>


<h3>Author(s)</h3>

<p>Yuming Zhang
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Xt = gen_nswn(n_total = 1000)
plot(Xt)

Yt = gen_nswn(n_total = 2000, title = "non-stationary 
white noise process", seed = 1960)
plot(Yt)
</code></pre>

<hr>
<h2 id='gen_powerlaw'>Generate a Power Law Process given <code class="reqn">\sigma^2</code> and <code class="reqn">d</code>.</h2><span id='topic+gen_powerlaw'></span>

<h3>Description</h3>

<p>Simulates a a Power Law Process given <code class="reqn">\sigma^2</code> and <code class="reqn">d</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gen_powerlaw(N, sigma2 = 1, d = 0.9)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gen_powerlaw_+3A_n">N</code></td>
<td>
<p>An <code>integer</code> for signal length.</p>
</td></tr>
<tr><td><code id="gen_powerlaw_+3A_sigma2">sigma2</code></td>
<td>
<p>A <code>double</code>.</p>
</td></tr>
<tr><td><code id="gen_powerlaw_+3A_d">d</code></td>
<td>
<p>A <code>double</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>plp A <code>vec</code> containing the Power Law Process.
</p>

<hr>
<h2 id='gen_qn'>Generate a Quantisation Noise (QN) or Rounding Error Sequence</h2><span id='topic+gen_qn'></span>

<h3>Description</h3>

<p>Simulates a QN sequence given <code class="reqn">Q^2</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gen_qn(N, q2 = 0.1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gen_qn_+3A_n">N</code></td>
<td>
<p>An <code>integer</code> for signal length.</p>
</td></tr>
<tr><td><code id="gen_qn_+3A_q2">q2</code></td>
<td>
<p>A <code>double</code> that contains autocorrection.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>vec</code> containing the QN process.
</p>


<h3>Process Definition</h3>

<p>Quantization Noise (QN) with parameter <code class="reqn">Q^2 \in R^{+}</code>. 
With i.i.d <code class="reqn">Y_t \sim U(0,1)</code> (i.e. a standard uniform variable), this process is
defined as:
</p>
<p style="text-align: center;"><code class="reqn">X_t = \sqrt{12Q^2}(Y_{t}-Y_{t-1})</code>
</p>



<h3>Generation Algorithm</h3>

<p>To generate the quantisation noise, we follow this recipe:
First, we generate using a random uniform distribution:
</p>
<p style="text-align: center;"><code class="reqn">U_k^*\sim U\left[ {0,1} \right]</code>
</p>

<p>Then, we multiple the sequence by <code class="reqn">\sqrt{12}</code> so:
</p>
<p style="text-align: center;"><code class="reqn">{U_k} = \sqrt{12} U_k^*</code>
</p>

<p>Next, we find the derivative of <code class="reqn">{U_k}</code>
</p>
<p style="text-align: center;"><code class="reqn">{{\dot U}_k} = \frac{{{U_{k + \Delta t}} - {U_k}}}{{\Delta t}}</code>
</p>

<p>In this case, we modify the derivative such that:
<code class="reqn">{{\dot U}_k}\Delta t = {U_{k + \Delta t}} - {U_k}</code>
</p>
<p>Thus, we end up with:
</p>
<p style="text-align: center;"><code class="reqn">{x_k} = \sqrt Q {{\dot U}_k}\Delta t</code>
</p>

<p style="text-align: center;"><code class="reqn">{x_k} = \sqrt Q \left( {{U_{k + 1}} - {U_k}} \right)</code>
</p>


<hr>
<h2 id='gen_rw'>Generate a Random Walk without Drift</h2><span id='topic+gen_rw'></span>

<h3>Description</h3>

<p>Generates a random walk without drift.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gen_rw(N, sigma2 = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gen_rw_+3A_n">N</code></td>
<td>
<p>An <code>integer</code> for signal length.</p>
</td></tr>
<tr><td><code id="gen_rw_+3A_sigma2">sigma2</code></td>
<td>
<p>A <code>double</code> that contains process variance.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>grw A <code>vec</code> containing the random walk without drift.
</p>


<h3>Process Definition</h3>

<p>Random Walk (RW) with parameter <code class="reqn">\gamma^2 \in {\rm I\!R}^{+}</code>. This process is defined as:
</p>
<p style="text-align: center;"><code class="reqn">{X_t} = \sum\limits_{t = 1}^T {\gamma {Z_t}} </code>
</p>

<p>and is often called <em>Rate Random Walk</em> in the engineering literature.
</p>


<h3>Generation Algorithm</h3>

<p>To generate we first obtain the standard deviation from the variance by taking a square root. Then, we 
sample <code class="reqn">N</code> times from a <code class="reqn">N(0,\sigma^2)</code> distribution. Lastly, we take the
cumulative sum over the vector.
</p>

<hr>
<h2 id='gen_sarima'>Generate Seasonal Autoregressive Order P - Moving Average Order Q (SARMA(p,q)x(P,Q)) Model</h2><span id='topic+gen_sarima'></span>

<h3>Description</h3>

<p>Generate an ARMA(P,Q) process with supplied vector of Autoregressive Coefficients (<code class="reqn">\phi</code>), Moving Average Coefficients (<code class="reqn">\theta</code>), and <code class="reqn">\sigma^2</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gen_sarima(N, ar, d, ma, sar, sd, sma, sigma2 = 1.5, s = 12L, n_start = 0L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gen_sarima_+3A_n">N</code></td>
<td>
<p>An <code>integer</code> for signal length.</p>
</td></tr>
<tr><td><code id="gen_sarima_+3A_ar">ar</code></td>
<td>
<p>A <code>vec</code> that contains the AR coefficients.</p>
</td></tr>
<tr><td><code id="gen_sarima_+3A_d">d</code></td>
<td>
<p>An <code>integer</code> that indicates a non-seasonal difference.</p>
</td></tr>
<tr><td><code id="gen_sarima_+3A_ma">ma</code></td>
<td>
<p>A <code>vec</code> that contains the MA coefficients.</p>
</td></tr>
<tr><td><code id="gen_sarima_+3A_sar">sar</code></td>
<td>
<p>A <code>vec</code> that contains the SAR coefficients.</p>
</td></tr>
<tr><td><code id="gen_sarima_+3A_sd">sd</code></td>
<td>
<p>An <code>integer</code> that indicates a seasonal difference.</p>
</td></tr>
<tr><td><code id="gen_sarima_+3A_sma">sma</code></td>
<td>
<p>A <code>vec</code> that contains the SMA coefficients.</p>
</td></tr>
<tr><td><code id="gen_sarima_+3A_sigma2">sigma2</code></td>
<td>
<p>A <code>double</code> that contains process variance.</p>
</td></tr>
<tr><td><code id="gen_sarima_+3A_s">s</code></td>
<td>
<p>An <code>integer</code> that contains a seasonal id.</p>
</td></tr>
<tr><td><code id="gen_sarima_+3A_n_start">n_start</code></td>
<td>
<p>An <code>unsigned int</code> that indicates the amount of observations to be used for the burn in period.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The innovations are generated from a normal distribution.
The <code class="reqn">\sigma^2</code> parameter is indeed a variance parameter. 
This differs from R's use of the standard deviation, <code class="reqn">\sigma</code>.
</p>


<h3>Value</h3>

<p>A <code>vec</code> that contains the generated observations.
</p>

<hr>
<h2 id='gen_sarma'>Generate Seasonal Autoregressive Order P - Moving Average Order Q (SARMA(p,q)x(P,Q)) Model</h2><span id='topic+gen_sarma'></span>

<h3>Description</h3>

<p>Generate an ARMA(P,Q) process with supplied vector of Autoregressive Coefficients (<code class="reqn">\phi</code>), Moving Average Coefficients (<code class="reqn">\theta</code>), and <code class="reqn">\sigma^2</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gen_sarma(N, ar, ma, sar, sma, sigma2 = 1.5, s = 12L, n_start = 0L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gen_sarma_+3A_n">N</code></td>
<td>
<p>An <code>integer</code> for signal length.</p>
</td></tr>
<tr><td><code id="gen_sarma_+3A_ar">ar</code></td>
<td>
<p>A <code>vec</code> that contains the AR coefficients.</p>
</td></tr>
<tr><td><code id="gen_sarma_+3A_ma">ma</code></td>
<td>
<p>A <code>vec</code> that contains the MA coefficients.</p>
</td></tr>
<tr><td><code id="gen_sarma_+3A_sar">sar</code></td>
<td>
<p>A <code>vec</code> that contains the SAR coefficients.</p>
</td></tr>
<tr><td><code id="gen_sarma_+3A_sma">sma</code></td>
<td>
<p>A <code>vec</code> that contains the SMA coefficients.</p>
</td></tr>
<tr><td><code id="gen_sarma_+3A_sigma2">sigma2</code></td>
<td>
<p>A <code>double</code> that contains process variance.</p>
</td></tr>
<tr><td><code id="gen_sarma_+3A_s">s</code></td>
<td>
<p>An <code>integer</code> that contains a seasonal id.</p>
</td></tr>
<tr><td><code id="gen_sarma_+3A_n_start">n_start</code></td>
<td>
<p>An <code>unsigned int</code> that indicates the amount of observations to be used for the burn in period.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The innovations are generated from a normal distribution.
The <code class="reqn">\sigma^2</code> parameter is indeed a variance parameter. 
This differs from R's use of the standard deviation, <code class="reqn">\sigma</code>.
</p>


<h3>Value</h3>

<p>A <code>vec</code> that contains the generated observations.
</p>

<hr>
<h2 id='gen_sin'>Generate a Sinusoidal Process given <code class="reqn">\alpha^2</code> and <code class="reqn">\beta</code>.</h2><span id='topic+gen_sin'></span>

<h3>Description</h3>

<p>Simulates a Sinusoidal Process Process with parameter <code class="reqn">\alpha^2</code>  and <code class="reqn">\beta</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gen_sin(N, alpha2 = 9e-04, beta = 0.06, U = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gen_sin_+3A_n">N</code></td>
<td>
<p>An <code>integer</code> for signal length.</p>
</td></tr>
<tr><td><code id="gen_sin_+3A_alpha2">alpha2</code></td>
<td>
<p>A <code>double</code> that contains the squared amplitude parameter alpha2.</p>
</td></tr>
<tr><td><code id="gen_sin_+3A_beta">beta</code></td>
<td>
<p>A <code>double</code> that contains the angular frequency parameter beta.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>sn A <code>vec</code> containing the sinusoidal process.
</p>


<h3>Generation Algorithm</h3>

<p>The function first generates a initial cycle oscillation at t=0 from a Uniform law with parameter a = 0 and b = 2 * pi 
and then compute the signal from its definition </p>
<p style="text-align: center;"><code class="reqn">X_t = \alpha \sin(\beta t + U)</code>
</p>
<p>.
</p>

<hr>
<h2 id='gen_wn'>Generate a Gaussian White Noise Process (WN(<code class="reqn">\sigma ^2</code>))</h2><span id='topic+gen_wn'></span>

<h3>Description</h3>

<p>Simulates a Gaussian White Noise Process with variance parameter <code class="reqn">\sigma ^2</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gen_wn(N, sigma2 = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gen_wn_+3A_n">N</code></td>
<td>
<p>An <code>integer</code> for signal length.</p>
</td></tr>
<tr><td><code id="gen_wn_+3A_sigma2">sigma2</code></td>
<td>
<p>A <code>double</code> that contains process variance.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>wn A <code>vec</code> containing the white noise.
</p>


<h3>Process Definition</h3>

<p>Gaussian White Noise (WN) with parameter <code class="reqn">\sigma^2 \in {\rm I\!R}^{+}</code>.
This process is defined as <code class="reqn">X_t\sim N(0,\sigma^2)</code> and
is sometimes referred to as Angle (Velocity) Random Walk.
</p>


<h3>Generation Algorithm</h3>

<p>To generate the Gaussian White Noise (WN) process, we first obtain the 
standard deviation from the variance by taking a square root. Then, we 
sample <code class="reqn">N</code> times from a <code class="reqn">N(0,\sigma ^2)</code> distribution.
</p>

<hr>
<h2 id='get_summary'>Routing function for summary info</h2><span id='topic+get_summary'></span>

<h3>Description</h3>

<p>Gets all the data for the summary.gmwm function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_summary(
  theta,
  desc,
  objdesc,
  model_type,
  wv_empir,
  theo,
  scales,
  V,
  omega,
  obj_value,
  N,
  alpha,
  robust,
  eff,
  inference,
  fullV,
  bs_gof,
  bs_gof_p_ci,
  bs_theta_est,
  bs_ci,
  B
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_summary_+3A_theta">theta</code></td>
<td>
<p>A <code>vec</code> with dimensions N x 1 that contains user-supplied initial values for parameters</p>
</td></tr>
<tr><td><code id="get_summary_+3A_desc">desc</code></td>
<td>
<p>A <code>vector&lt;string&gt;</code> indicating the models that should be considered.</p>
</td></tr>
<tr><td><code id="get_summary_+3A_objdesc">objdesc</code></td>
<td>
<p>A <code>field&lt;vec&gt;</code> containing a list of parameters (e.g. AR(1) = c(1,1), ARMA(p,q) = c(p,q,1))</p>
</td></tr>
<tr><td><code id="get_summary_+3A_model_type">model_type</code></td>
<td>
<p>A <code>string</code> that represents the model transformation</p>
</td></tr>
<tr><td><code id="get_summary_+3A_wv_empir">wv_empir</code></td>
<td>
<p>A <code>vec</code> that</p>
</td></tr>
<tr><td><code id="get_summary_+3A_theo">theo</code></td>
<td>
<p>A <code>vec</code> that</p>
</td></tr>
<tr><td><code id="get_summary_+3A_scales">scales</code></td>
<td>
<p>A <code>vec</code> that</p>
</td></tr>
<tr><td><code id="get_summary_+3A_v">V</code></td>
<td>
<p>A <code>mat</code> that contains the V matrix used to obtain the GMWM.</p>
</td></tr>
<tr><td><code id="get_summary_+3A_omega">omega</code></td>
<td>
<p>A <code>mat</code> that</p>
</td></tr>
<tr><td><code id="get_summary_+3A_obj_value">obj_value</code></td>
<td>
<p>A <code>double</code> that contains the objective function value at the optimized solution.</p>
</td></tr>
<tr><td><code id="get_summary_+3A_n">N</code></td>
<td>
<p>A <code>int</code> that indicates how long the time series is.</p>
</td></tr>
<tr><td><code id="get_summary_+3A_alpha">alpha</code></td>
<td>
<p>A <code>double</code> that handles the alpha level of the confidence interval (1-alpha)*100</p>
</td></tr>
<tr><td><code id="get_summary_+3A_robust">robust</code></td>
<td>
<p>A <code>bool</code> that indicates whether the estimation should be robust or not.</p>
</td></tr>
<tr><td><code id="get_summary_+3A_eff">eff</code></td>
<td>
<p>A <code>double</code> that specifies the amount of efficiency required by the robust estimator.</p>
</td></tr>
<tr><td><code id="get_summary_+3A_inference">inference</code></td>
<td>
<p>A <code>bool</code> that indicates whether inference (e.g. GoF) should be run.</p>
</td></tr>
<tr><td><code id="get_summary_+3A_fullv">fullV</code></td>
<td>
<p>A <code>bool</code> that indicates whether the matrix has been fully bootstrapped.</p>
</td></tr>
<tr><td><code id="get_summary_+3A_bs_gof">bs_gof</code></td>
<td>
<p>A <code>bool</code> indicating whether the GoF should be bootstrapped or done asymptotically.</p>
</td></tr>
<tr><td><code id="get_summary_+3A_bs_gof_p_ci">bs_gof_p_ci</code></td>
<td>
<p>A <code>bool</code> indicating whether a bootstrapped p-value should be generated during the bootstrapped GoF</p>
</td></tr>
<tr><td><code id="get_summary_+3A_bs_ci">bs_ci</code></td>
<td>
<p>A <code>bool</code> that indicates whether a bootstrapped CI should be obtained or to use analytical derivatives.</p>
</td></tr>
<tr><td><code id="get_summary_+3A_b">B</code></td>
<td>
<p>A <code>int</code> that indicates how many iterations should take place.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>field&lt;mat&gt;</code> that contains bootstrapped / asymptotic GoF results as well as CIs.
</p>

<hr>
<h2 id='getObjFun'>Retrieve GMWM starting value from Yannick's objective function</h2><span id='topic+getObjFun'></span>

<h3>Description</h3>

<p>Obtains the GMWM starting value given by Yannick's objective function optimization
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getObjFun(theta, desc, objdesc, model_type, omega, wv_empir, tau)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getObjFun_+3A_theta">theta</code></td>
<td>
<p>A <code>vec</code> with dimensions N x 1 that contains user-supplied initial values for parameters</p>
</td></tr>
<tr><td><code id="getObjFun_+3A_desc">desc</code></td>
<td>
<p>A <code>vector&lt;string&gt;</code> indicating the models that should be considered.</p>
</td></tr>
<tr><td><code id="getObjFun_+3A_objdesc">objdesc</code></td>
<td>
<p>A <code>field&lt;vec&gt;</code> containing a list of parameters (e.g. AR(1) = c(1,1), ARMA(p,q) = c(p,q,1))</p>
</td></tr>
<tr><td><code id="getObjFun_+3A_model_type">model_type</code></td>
<td>
<p>A <code>string</code> containing the model type. Either 'imu' or 'ssm'</p>
</td></tr>
<tr><td><code id="getObjFun_+3A_omega">omega</code></td>
<td>
<p>A <code>mat</code> that is the inverse of the diagonal of the V matrix.</p>
</td></tr>
<tr><td><code id="getObjFun_+3A_wv_empir">wv_empir</code></td>
<td>
<p>A <code>vec</code> containing the empirical wavelet variance.</p>
</td></tr>
<tr><td><code id="getObjFun_+3A_tau">tau</code></td>
<td>
<p>A <code>vec</code> that contains the scales of 2^(1:J), where J is the number of scales created by the decomposition.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>double</code> that is the value of the Objective function under Yannick's starting algorithm
</p>

<hr>
<h2 id='getObjFunStarting'>Retrieve GMWM starting value from Yannick's objective function</h2><span id='topic+getObjFunStarting'></span>

<h3>Description</h3>

<p>Obtains the GMWM starting value given by Yannick's objective function optimization
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getObjFunStarting(theta, desc, objdesc, model_type, wv_empir, tau)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getObjFunStarting_+3A_theta">theta</code></td>
<td>
<p>A <code>vec</code> with dimensions N x 1 that contains user-supplied initial values for parameters</p>
</td></tr>
<tr><td><code id="getObjFunStarting_+3A_desc">desc</code></td>
<td>
<p>A <code>vector&lt;string&gt;</code> indicating the models that should be considered.</p>
</td></tr>
<tr><td><code id="getObjFunStarting_+3A_objdesc">objdesc</code></td>
<td>
<p>A <code>field&lt;vec&gt;</code> containing a list of parameters (e.g. AR(1) = c(1,1), ARMA(p,q) = c(p,q,1))</p>
</td></tr>
<tr><td><code id="getObjFunStarting_+3A_model_type">model_type</code></td>
<td>
<p>A <code>string</code> containing the model type. Either 'imu' or 'ssm'</p>
</td></tr>
<tr><td><code id="getObjFunStarting_+3A_wv_empir">wv_empir</code></td>
<td>
<p>A <code>vec</code> containing the empirical wavelet variance.</p>
</td></tr>
<tr><td><code id="getObjFunStarting_+3A_tau">tau</code></td>
<td>
<p>A <code>vec</code> that contains the scales of 2^(1:J), where J is the number of scales created by the decomposition.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>double</code> that is the value of the Objective function under Yannick's starting algorithm
</p>

<hr>
<h2 id='GM'>Create a Gauss-Markov (GM) Process</h2><span id='topic+GM'></span>

<h3>Description</h3>

<p>Sets up the necessary backend for the GM process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GM(beta = NULL, sigma2_gm = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GM_+3A_beta">beta</code></td>
<td>
<p>A <code>double</code> value for the <code class="reqn">\beta</code> of an GM process (see Note for details).</p>
</td></tr>
<tr><td><code id="GM_+3A_sigma2_gm">sigma2_gm</code></td>
<td>
<p>A <code>double</code> value for the variance, <code class="reqn">\sigma ^2_{gm}</code>, of a GM process (see Note for details).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When supplying values for <code class="reqn">\beta</code> and <code class="reqn">\sigma ^2_{gm}</code>,
these parameters should be of a GM process and NOT of an AR1. That is,
do not supply AR1 parameters such as <code class="reqn">\phi</code>, <code class="reqn">\sigma^2</code>.
</p>
<p>Internally, GM parameters are converted to AR1 using the 'freq' 
supplied when creating data objects (<a href="#topic+gts">gts</a>)
or specifying a 'freq' parameter in simts or simts.imu.
</p>
<p>The 'freq' of a data object takes precedence over the 'freq' set when modeling.
</p>


<h3>Value</h3>

<p>An S3 object with called ts.model with the following structure:
</p>

<dl>
<dt>process.desc</dt><dd><p>Used in summary: &quot;BETA&quot;,&quot;SIGMA2&quot;</p>
</dd>
<dt>theta</dt><dd><p><code class="reqn">\beta</code>, <code class="reqn">\sigma ^2_{gm}</code></p>
</dd>
<dt>plength</dt><dd><p>Number of parameters</p>
</dd>
<dt>print</dt><dd><p>String containing simplified model</p>
</dd>
<dt>desc</dt><dd><p>&quot;GM&quot;</p>
</dd>
<dt>obj.desc</dt><dd><p>Depth of parameters e.g. list(1,1)</p>
</dd>
<dt>starting</dt><dd><p>Guess starting values? TRUE or FALSE (e.g. specified value)</p>
</dd>
</dl>



<h3>Note</h3>

<p>We consider the following model: </p>
<p style="text-align: center;"><code class="reqn">X_t = e^{(-\beta)} X_{t-1} + \varepsilon_t</code>
</p>
<p>, where <code class="reqn">\varepsilon_t</code> is iid from a zero 
mean normal distribution with variance <code class="reqn">\sigma^2(1-e^{2\beta})</code>.
</p>


<h3>Author(s)</h3>

<p>James Balamuta
</p>


<h3>Examples</h3>

<pre><code class='language-R'>GM()
GM(beta=.32, sigma2_gm=1.3)
</code></pre>

<hr>
<h2 id='gm_to_ar1'>Transform GM to AR1</h2><span id='topic+gm_to_ar1'></span>

<h3>Description</h3>

<p>Takes GM values and transforms them to AR1
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gm_to_ar1(theta, freq)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gm_to_ar1_+3A_theta">theta</code></td>
<td>
<p>A <code>vec</code> that contains AR1 values.</p>
</td></tr>
<tr><td><code id="gm_to_ar1_+3A_freq">freq</code></td>
<td>
<p>A <code>double</code> indicating the frequency of the data.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>vec</code> containing GM values.
</p>


<h3>Author(s)</h3>

<p>James Balamuta
The function takes a vector of GM values <code class="reqn">\beta</code> and <code class="reqn">\sigma ^2_{gm}</code>
and transforms them to AR1 values <code class="reqn">\phi</code> and <code class="reqn">\sigma ^2</code>
using the formulas:
<code class="reqn">\phi  = \exp \left( { - \beta \Delta t} \right)</code>
<code class="reqn">{\sigma ^2} = \sigma _{gm}^2\left( {1 - \exp \left( { - 2\beta \Delta t} \right)} \right)</code>
</p>

<hr>
<h2 id='gmwm'>Generalized Method of Wavelet Moments (GMWM)</h2><span id='topic+gmwm'></span>

<h3>Description</h3>

<p>Performs estimation of time series models by using the GMWM estimator.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gmwm(
  model,
  data,
  model.type = "imu",
  compute.v = "auto",
  robust = FALSE,
  eff = 0.6,
  alpha = 0.05,
  seed = 1337,
  G = NULL,
  K = 1,
  H = 100,
  freq = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gmwm_+3A_model">model</code></td>
<td>
<p>A <code>ts.model</code> object containing one of the allowed models.</p>
</td></tr>
<tr><td><code id="gmwm_+3A_data">data</code></td>
<td>
<p>A <code>matrix</code> or <code>data.frame</code> object with only column
(e.g. <code class="reqn">N \times 1</code>), a <code>lts</code> object,
or a <code>gts</code> object.</p>
</td></tr>
<tr><td><code id="gmwm_+3A_model.type">model.type</code></td>
<td>
<p>A <code>string</code> containing the type of GMWM needed:
<code>"imu"</code> or <code>"ssm"</code>.</p>
</td></tr>
<tr><td><code id="gmwm_+3A_compute.v">compute.v</code></td>
<td>
<p>A <code>string</code> indicating the type of covariance matrix
solver. Valid values are:
<code>"fast"</code>, <code>"bootstrap"</code>,
<code>"diag"</code> (asymptotic diag),
<code>"full"</code> (asymptotic full). By default, the program
will fit a &quot;fast&quot; model.</p>
</td></tr>
<tr><td><code id="gmwm_+3A_robust">robust</code></td>
<td>
<p>A <code>boolean</code> indicating whether to use the robust
computation (<code>TRUE</code>) or not (<code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="gmwm_+3A_eff">eff</code></td>
<td>
<p>A <code>double</code> between 0 and 1 that indicates the
efficiency.</p>
</td></tr>
<tr><td><code id="gmwm_+3A_alpha">alpha</code></td>
<td>
<p>A <code>double</code> between 0 and 1 that correspondings to the
<code class="reqn">\frac{\alpha}{2}</code> value for the wavelet
confidence intervals.</p>
</td></tr>
<tr><td><code id="gmwm_+3A_seed">seed</code></td>
<td>
<p>An <code>integer</code> that controls the reproducibility of the
auto model selection phase.</p>
</td></tr>
<tr><td><code id="gmwm_+3A_g">G</code></td>
<td>
<p>An <code>integer</code> to sample the space for IMU and SSM
models to ensure optimal identitability.</p>
</td></tr>
<tr><td><code id="gmwm_+3A_k">K</code></td>
<td>
<p>An <code>integer</code> that controls how many times the
bootstrapping procedure will be initiated.</p>
</td></tr>
<tr><td><code id="gmwm_+3A_h">H</code></td>
<td>
<p>An <code>integer</code> that indicates how many different
samples the bootstrap will be collect.</p>
</td></tr>
<tr><td><code id="gmwm_+3A_freq">freq</code></td>
<td>
<p>A <code>double</code> that indicates the sampling frequency. By
default, this is set to 1 and only is important if <code>GM()</code>
is in the model</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is under work. Some of the features are active. Others... Not so much.
</p>
<p>The V matrix is calculated by:
<code class="reqn">diag\left[ {{{\left( {Hi - Lo} \right)}^2}} \right]</code>.
</p>
<p>The function is implemented in the following manner:
1. Calculate MODWT of data with levels = floor(log2(data))
2. Apply the brick.wall of the MODWT (e.g. remove boundary values)
3. Compute the empirical wavelet variance (WV Empirical).
4. Obtain the V matrix by squaring the difference of the WV Empirical's Chi-squared confidence interval (hi - lo)^2
5. Optimize the values to obtain <code class="reqn">\hat{\theta}</code>
6. If FAST = TRUE, return these results. Else, continue.
</p>
<p>Loop  k = 1 to K
Loop h = 1 to H
7. Simulate xt under <code class="reqn">F_{\hat{\theta}}</code>
8. Compute WV Empirical
END
9. Calculate the covariance matrix
10. Optimize the values to obtain <code class="reqn">\hat{\theta}</code>
END
11. Return optimized values.
</p>
<p>The function estimates a variety of time series models. If type = &quot;imu&quot; or &quot;ssm&quot;, then
parameter vector should indicate the characters of the models that compose the latent or state-space model. The model
options are:
</p>

<ul>
<li><p> &quot;AR1&quot;: a first order autoregressive process with parameters <code class="reqn">(\phi,\sigma^2)</code>
</p>
</li>
<li><p> &quot;GM&quot;: a guass-markov process <code class="reqn">(\beta,\sigma_{gm}^2)</code>
</p>
</li>
<li><p> &quot;ARMA&quot;: an autoregressive moving average process with parameters <code class="reqn">(\phi _p, \theta _q, \sigma^2)</code>
</p>
</li>
<li><p> &quot;DR&quot;: a drift with parameter <code class="reqn">\omega</code>
</p>
</li>
<li><p> &quot;QN&quot;: a quantization noise process with parameter <code class="reqn">Q</code>
</p>
</li>
<li><p> &quot;RW&quot;: a random walk process with parameter <code class="reqn">\sigma^2</code>
</p>
</li>
<li><p> &quot;WN&quot;: a white noise process with parameter <code class="reqn">\sigma^2</code>
</p>
</li></ul>

<p>If only an ARMA() term is supplied, then the function takes conditional least squares as starting values
If robust = TRUE the function takes the robust estimate of the wavelet variance to be used in the GMWM estimation procedure.
</p>


<h3>Value</h3>

<p>A <code>gmwm</code> object with the structure:
</p>

<ul>
<li><p> estimate: Estimated Parameters Values from the GMWM Procedure
</p>
</li>
<li><p> init.guess: Initial Starting Values given to the Optimization Algorithm
</p>
</li>
<li><p> wv.empir: The data's empirical wavelet variance
</p>
</li>
<li><p> ci_low: Lower Confidence Interval
</p>
</li>
<li><p> ci_high: Upper Confidence Interval
</p>
</li>
<li><p> orgV: Original V matrix
</p>
</li>
<li><p> V: Updated V matrix (if bootstrapped)
</p>
</li>
<li><p> omega: The V matrix inversed
</p>
</li>
<li><p> obj.fun: Value of the objective function at Estimated Parameter Values
</p>
</li>
<li><p> theo: Summed Theoretical Wavelet Variance
</p>
</li>
<li><p> decomp.theo: Decomposed Theoretical Wavelet Variance by Process
</p>
</li>
<li><p> scales: Scales of the GMWM Object
</p>
</li>
<li><p> robust: Indicates if parameter estimation was done under robust or classical
</p>
</li>
<li><p> eff: Level of efficiency of robust estimation
</p>
</li>
<li><p> model.type: Models being guessed
</p>
</li>
<li><p> compute.v: Type of V matrix computation
</p>
</li>
<li><p> augmented: Indicates moments have been augmented
</p>
</li>
<li><p> alpha: Alpha level used to generate confidence intervals
</p>
</li>
<li><p> expect.diff: Mean of the First Difference of the Signal
</p>
</li>
<li><p> N: Length of the Signal
</p>
</li>
<li><p> G: Number of Guesses Performed
</p>
</li>
<li><p> H: Number of Bootstrap replications
</p>
</li>
<li><p> K: Number of V matrix bootstraps
</p>
</li>
<li><p> model: <code>ts.model</code> supplied to gmwm
</p>
</li>
<li><p> model.hat: A new value of <code>ts.model</code> object supplied to gmwm
</p>
</li>
<li><p> starting: Indicates whether the procedure used the initial guessing approach
</p>
</li>
<li><p> seed: Randomization seed used to generate the guessing values
</p>
</li>
<li><p> freq: Frequency of data
</p>
</li></ul>


<hr>
<h2 id='gmwm_engine'>Engine for obtaining the GMWM Estimator</h2><span id='topic+gmwm_engine'></span>

<h3>Description</h3>

<p>This function uses the Generalized Method of Wavelet Moments (GMWM) to estimate the parameters of a time series model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gmwm_engine(
  theta,
  desc,
  objdesc,
  model_type,
  wv_empir,
  omega,
  scales,
  starting
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gmwm_engine_+3A_theta">theta</code></td>
<td>
<p>A <code>vec</code> with dimensions N x 1 that contains user-supplied initial values for parameters</p>
</td></tr>
<tr><td><code id="gmwm_engine_+3A_desc">desc</code></td>
<td>
<p>A <code>vector&lt;string&gt;</code> indicating the models that should be considered.</p>
</td></tr>
<tr><td><code id="gmwm_engine_+3A_objdesc">objdesc</code></td>
<td>
<p>A <code>field&lt;vec&gt;</code> containing a list of parameters (e.g. AR(1) = c(1,1), ARMA(p,q) = c(p,q,1))</p>
</td></tr>
<tr><td><code id="gmwm_engine_+3A_model_type">model_type</code></td>
<td>
<p>A <code>string</code> that represents the model transformation</p>
</td></tr>
<tr><td><code id="gmwm_engine_+3A_wv_empir">wv_empir</code></td>
<td>
<p>A <code>vec</code> that contains the empirical wavelet variance</p>
</td></tr>
<tr><td><code id="gmwm_engine_+3A_omega">omega</code></td>
<td>
<p>A <code>mat</code> that represents the covariance matrix.</p>
</td></tr>
<tr><td><code id="gmwm_engine_+3A_scales">scales</code></td>
<td>
<p>A <code>vec</code> that contains the scales or taus (2^(1:J))</p>
</td></tr>
<tr><td><code id="gmwm_engine_+3A_starting">starting</code></td>
<td>
<p>A <code>bool</code> that indicates whether we guessed starting (T) or the user supplied estimates (F).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If type = &quot;imu&quot; or &quot;ssm&quot;, then parameter vector should indicate the characters of the models that compose the latent or state-space model.
The model options are:
</p>

<ul>
<li><p>&quot;AR1&quot;a first order autoregressive process with parameters <code class="reqn">(\phi,\sigma^2)</code>
</p>
</li>
<li><p>&quot;ARMA&quot;an autoregressive moving average process with parameters <code class="reqn">(\phi _p, \theta _q, \sigma^2)</code>
</p>
</li>
<li><p>&quot;DR&quot;a drift with parameter <code class="reqn">\omega</code>
</p>
</li>
<li><p>&quot;QN&quot;a quantization noise process with parameter <code class="reqn">Q</code>
</p>
</li>
<li><p>&quot;RW&quot;a random walk process with parameter <code class="reqn">\sigma^2</code>
</p>
</li>
<li><p>&quot;WN&quot;a white noise process with parameter <code class="reqn">\sigma^2</code>
</p>
</li></ul>

<p>If model_type = &quot;imu&quot; or type = &quot;ssm&quot; then
starting values pass through an initial bootstrap and pseudo-optimization before being passed to the GMWM optimization.
If robust = TRUE the function takes the robust estimate of the wavelet variance to be used in the GMWM estimation procedure.
</p>


<h3>Value</h3>

<p>A <code>vec</code> that contains the parameter estimates from GMWM estimator.
</p>


<h3>Author(s)</h3>

<p>JJB
</p>


<h3>References</h3>

<p>Wavelet variance based estimation for composite stochastic processes, S. Guerrier and Robust Inference for Time Series Models: a Wavelet-Based Framework, S. Guerrier
</p>

<hr>
<h2 id='gmwm_imu'>GMWM for (Robust) Inertial Measurement Units (IMUs)</h2><span id='topic+gmwm_imu'></span>

<h3>Description</h3>

<p>Performs the GMWM estimation procedure using a parameter transform and sampling
scheme specific to IMUs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gmwm_imu(model, data, compute.v = "fast", robust = F, eff = 0.6, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gmwm_imu_+3A_model">model</code></td>
<td>
<p>A <code>ts.model</code> object containing one of the allowed models.</p>
</td></tr>
<tr><td><code id="gmwm_imu_+3A_data">data</code></td>
<td>
<p>A <code>matrix</code> or <code>data.frame</code> object with only column (e.g. <code class="reqn">N \times 1</code>), or a <code>lts</code> object, or a <code>gts</code> object.</p>
</td></tr>
<tr><td><code id="gmwm_imu_+3A_compute.v">compute.v</code></td>
<td>
<p>A <code>string</code> indicating the type of covariance matrix solver. &quot;fast&quot;, &quot;bootstrap&quot;, &quot;asymp.diag&quot;, &quot;asymp.comp&quot;, &quot;fft&quot;</p>
</td></tr>
<tr><td><code id="gmwm_imu_+3A_robust">robust</code></td>
<td>
<p>A <code>boolean</code> indicating whether to use the robust computation (TRUE) or not (FALSE).</p>
</td></tr>
<tr><td><code id="gmwm_imu_+3A_eff">eff</code></td>
<td>
<p>A <code>double</code> between 0 and 1 that indicates the efficiency.</p>
</td></tr>
<tr><td><code id="gmwm_imu_+3A_...">...</code></td>
<td>
<p>Other arguments passed to the main gmwm function</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This version of the gmwm function has customized settings
ideal for modeling with an IMU object. If you seek to model with an Gauss
Markov, <code>GM</code>, object. Please note results depend on the
<code>freq</code> specified in the data construction step within the
<code>imu</code>. If you wish for results to be stable but lose the
ability to interpret with respect to <code>freq</code>, then use
<code>AR1</code> terms.
</p>


<h3>Value</h3>

<p>A <code>gmwm</code> object with the structure:
</p>

<ul>
<li><p>estimateEstimated Parameters Values from the GMWM Procedure
</p>
</li>
<li><p>init.guessInitial Starting Values given to the Optimization Algorithm
</p>
</li>
<li><p>wv.empirThe data's empirical wavelet variance
</p>
</li>
<li><p>ci_lowLower Confidence Interval
</p>
</li>
<li><p>ci_highUpper Confidence Interval
</p>
</li>
<li><p>orgVOriginal V matrix
</p>
</li>
<li><p>VUpdated V matrix (if bootstrapped)
</p>
</li>
<li><p>omegaThe V matrix inversed
</p>
</li>
<li><p>obj.funValue of the objective function at Estimated Parameter Values
</p>
</li>
<li><p>theoSummed Theoretical Wavelet Variance
</p>
</li>
<li><p>decomp.theoDecomposed Theoretical Wavelet Variance by Process
</p>
</li>
<li><p>scalesScales of the GMWM Object
</p>
</li>
<li><p>robustIndicates if parameter estimation was done under robust or classical
</p>
</li>
<li><p>effLevel of efficiency of robust estimation
</p>
</li>
<li><p>model.typeModels being guessed
</p>
</li>
<li><p>compute.vType of V matrix computation
</p>
</li>
<li><p>augmentedIndicates moments have been augmented
</p>
</li>
<li><p>alphaAlpha level used to generate confidence intervals
</p>
</li>
<li><p>expect.diffMean of the First Difference of the Signal
</p>
</li>
<li><p>NLength of the Signal
</p>
</li>
<li><p>GNumber of Guesses Performed
</p>
</li>
<li><p>HNumber of Bootstrap replications
</p>
</li>
<li><p>KNumber of V matrix bootstraps
</p>
</li>
<li><p>model<code>ts.model</code> supplied to gmwm
</p>
</li>
<li><p>model.hatA new value of <code>ts.model</code> object supplied to gmwm
</p>
</li>
<li><p>startingIndicates whether the procedure used the initial guessing approach
</p>
</li>
<li><p>seedRandomization seed used to generate the guessing values
</p>
</li>
<li><p>freqFrequency of data
</p>
</li></ul>


<hr>
<h2 id='gmwm_master_cpp'>Master Wrapper for the GMWM Estimator</h2><span id='topic+gmwm_master_cpp'></span>

<h3>Description</h3>

<p>This function generates WV, GMWM Estimator, and an initial test estimate.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gmwm_master_cpp(
  data,
  theta,
  desc,
  objdesc,
  model_type,
  starting,
  alpha,
  compute_v,
  K,
  H,
  G,
  robust,
  eff
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gmwm_master_cpp_+3A_data">data</code></td>
<td>
<p>A <code>vec</code> containing the data.</p>
</td></tr>
<tr><td><code id="gmwm_master_cpp_+3A_theta">theta</code></td>
<td>
<p>A <code>vec</code> with dimensions N x 1 that contains user-supplied initial values for parameters</p>
</td></tr>
<tr><td><code id="gmwm_master_cpp_+3A_desc">desc</code></td>
<td>
<p>A <code>vector&lt;string&gt;</code> indicating the models that should be considered.</p>
</td></tr>
<tr><td><code id="gmwm_master_cpp_+3A_objdesc">objdesc</code></td>
<td>
<p>A <code>field&lt;vec&gt;</code> containing a list of parameters (e.g. AR(1) = c(1,1), ARMA(p,q) = c(p,q,1))</p>
</td></tr>
<tr><td><code id="gmwm_master_cpp_+3A_model_type">model_type</code></td>
<td>
<p>A <code>string</code> that represents the model transformation</p>
</td></tr>
<tr><td><code id="gmwm_master_cpp_+3A_starting">starting</code></td>
<td>
<p>A <code>bool</code> that indicates whether the supplied values are guessed (T) or are user-based (F).</p>
</td></tr>
<tr><td><code id="gmwm_master_cpp_+3A_alpha">alpha</code></td>
<td>
<p>A <code>double</code> that handles the alpha level of the confidence interval (1-alpha)*100</p>
</td></tr>
<tr><td><code id="gmwm_master_cpp_+3A_compute_v">compute_v</code></td>
<td>
<p>A <code>string</code> that describes what kind of covariance matrix should be computed.</p>
</td></tr>
<tr><td><code id="gmwm_master_cpp_+3A_k">K</code></td>
<td>
<p>An <code>int</code> that controls how many times theta is updated.</p>
</td></tr>
<tr><td><code id="gmwm_master_cpp_+3A_h">H</code></td>
<td>
<p>An <code>int</code> that controls how many bootstrap replications are done.</p>
</td></tr>
<tr><td><code id="gmwm_master_cpp_+3A_g">G</code></td>
<td>
<p>An <code>int</code> that controls how many guesses at different parameters are made.</p>
</td></tr>
<tr><td><code id="gmwm_master_cpp_+3A_robust">robust</code></td>
<td>
<p>A <code>bool</code> that indicates whether the estimation should be robust or not.</p>
</td></tr>
<tr><td><code id="gmwm_master_cpp_+3A_eff">eff</code></td>
<td>
<p>A <code>double</code> that specifies the amount of efficiency required by the robust estimator.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>field&lt;mat&gt;</code> that contains a list of ever-changing estimates...
</p>


<h3>Author(s)</h3>

<p>JJB
</p>


<h3>References</h3>

<p>Wavelet variance based estimation for composite stochastic processes, S. Guerrier and Robust Inference for Time Series Models: a Wavelet-Based Framework, S. Guerrier
</p>

<hr>
<h2 id='gmwm_param_bootstrapper'>Bootstrap for Estimating Both Theta and Theta SD</h2><span id='topic+gmwm_param_bootstrapper'></span>

<h3>Description</h3>

<p>Using the bootstrap approach, we simulate a model based on user supplied parameters, obtain the wavelet variance, and then V.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gmwm_param_bootstrapper(
  theta,
  desc,
  objdesc,
  scales,
  model_type,
  N,
  robust,
  eff,
  alpha,
  H
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gmwm_param_bootstrapper_+3A_theta">theta</code></td>
<td>
<p>A <code>vector</code> with dimensions N x 1 that contains user-supplied initial values for parameters</p>
</td></tr>
<tr><td><code id="gmwm_param_bootstrapper_+3A_desc">desc</code></td>
<td>
<p>A <code>vector&lt;string&gt;</code> indicating the models that should be considered.</p>
</td></tr>
<tr><td><code id="gmwm_param_bootstrapper_+3A_objdesc">objdesc</code></td>
<td>
<p>A <code>field&lt;vec&gt;</code> that contains an object description (e.g. values) of the model.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Expand in detail...
</p>


<h3>Value</h3>

<p>A <code>vec</code> that contains the parameter estimates from GMWM estimator.
</p>


<h3>Author(s)</h3>

<p>JJB
</p>

<hr>
<h2 id='gmwm_sd_bootstrapper'>Bootstrap for Standard Deviations of Theta Estimates</h2><span id='topic+gmwm_sd_bootstrapper'></span>

<h3>Description</h3>

<p>Using the bootstrap approach, we simulate a model based on user supplied parameters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gmwm_sd_bootstrapper(
  theta,
  desc,
  objdesc,
  scales,
  model_type,
  N,
  robust,
  eff,
  alpha,
  H
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gmwm_sd_bootstrapper_+3A_theta">theta</code></td>
<td>
<p>A <code>vector</code> with dimensions N x 1 that contains user-supplied initial values for parameters</p>
</td></tr>
<tr><td><code id="gmwm_sd_bootstrapper_+3A_desc">desc</code></td>
<td>
<p>A <code>vector&lt;string&gt;</code> indicating the models that should be considered.</p>
</td></tr>
<tr><td><code id="gmwm_sd_bootstrapper_+3A_objdesc">objdesc</code></td>
<td>
<p>A <code>field&lt;vec&gt;</code> that contains an object description (e.g. values) of the model.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Expand in detail...
</p>


<h3>Value</h3>

<p>A <code>vec</code> that contains the parameter estimates from GMWM estimator.
</p>


<h3>Author(s)</h3>

<p>JJB
</p>

<hr>
<h2 id='gmwm_update_cpp'>Update Wrapper for the GMWM Estimator</h2><span id='topic+gmwm_update_cpp'></span>

<h3>Description</h3>

<p>This function uses information obtained previously (e.g. WV covariance matrix) to re-estimate a different model parameterization
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gmwm_update_cpp(
  theta,
  desc,
  objdesc,
  model_type,
  N,
  expect_diff,
  ranged,
  orgV,
  scales,
  wv,
  starting,
  compute_v,
  K,
  H,
  G,
  robust,
  eff
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gmwm_update_cpp_+3A_theta">theta</code></td>
<td>
<p>A <code>vec</code> with dimensions N x 1 that contains user-supplied initial values for parameters</p>
</td></tr>
<tr><td><code id="gmwm_update_cpp_+3A_desc">desc</code></td>
<td>
<p>A <code>vector&lt;string&gt;</code> indicating the models that should be considered.</p>
</td></tr>
<tr><td><code id="gmwm_update_cpp_+3A_objdesc">objdesc</code></td>
<td>
<p>A <code>field&lt;vec&gt;</code> containing a list of parameters (e.g. AR(1) = c(1,1), ARMA(p,q) = c(p,q,1))</p>
</td></tr>
<tr><td><code id="gmwm_update_cpp_+3A_model_type">model_type</code></td>
<td>
<p>A <code>string</code> that represents the model transformation</p>
</td></tr>
<tr><td><code id="gmwm_update_cpp_+3A_scales">scales</code></td>
<td>
<p>A <code>vec</code> that contains the scales or taus (2^(1:J))</p>
</td></tr>
<tr><td><code id="gmwm_update_cpp_+3A_starting">starting</code></td>
<td>
<p>A <code>bool</code> that indicates whether we guessed starting (T) or the user supplied estimates (F).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>field&lt;mat&gt;</code> that contains the parameter estimates from GMWM estimator.
</p>


<h3>Author(s)</h3>

<p>JJB
</p>


<h3>References</h3>

<p>Wavelet variance based estimation for composite stochastic processes, S. Guerrier and Robust Inference for Time Series Models: a Wavelet-Based Framework, S. Guerrier
</p>

<hr>
<h2 id='gof_test'>Compute the GOF Test</h2><span id='topic+gof_test'></span>

<h3>Description</h3>

<p>yaya
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gof_test(theta, desc, objdesc, model_type, tau, v_hat, wv_empir)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gof_test_+3A_theta">theta</code></td>
<td>
<p>A <code>vec</code> with dimensions N x 1 that contains user-supplied initial values for parameters</p>
</td></tr>
<tr><td><code id="gof_test_+3A_desc">desc</code></td>
<td>
<p>A <code>vector&lt;string&gt;</code> indicating the models that should be considered.</p>
</td></tr>
<tr><td><code id="gof_test_+3A_objdesc">objdesc</code></td>
<td>
<p>A <code>field&lt;vec&gt;</code> containing a list of parameters (e.g. AR(1) = c(1,1), ARMA(p,q) = c(p,q,1))</p>
</td></tr>
<tr><td><code id="gof_test_+3A_model_type">model_type</code></td>
<td>
<p>A <code>string</code> that contains the model type: <code>"imu"</code> or <code>"ssm"</code></p>
</td></tr>
<tr><td><code id="gof_test_+3A_tau">tau</code></td>
<td>
<p>A <code>vec</code> containing the scales of a proccess.</p>
</td></tr>
<tr><td><code id="gof_test_+3A_v_hat">v_hat</code></td>
<td>
<p>A <code>mat</code> that contains the bootstrapped matrix.</p>
</td></tr>
<tr><td><code id="gof_test_+3A_wv_empir">wv_empir</code></td>
<td>
<p>A <code>vec</code> that contains the empirical wavelet variance.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>vec</code> that has
</p>

<ul>
<li><p> Test Statistic
</p>
</li>
<li><p> P-Value
</p>
</li>
<li><p> DF
</p>
</li></ul>


<hr>
<h2 id='gts'>Create a simts TS object using time series data</h2><span id='topic+gts'></span>

<h3>Description</h3>

<p>Takes a time series and turns it into a time series oriented object that can be used for summary and graphing functions in the <code>simts</code> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gts(
  data,
  start = 0,
  end = NULL,
  freq = 1,
  unit_ts = NULL,
  unit_time = NULL,
  name_ts = NULL,
  name_time = NULL,
  data_name = NULL,
  Time = NULL,
  time_format = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gts_+3A_data">data</code></td>
<td>
<p>A one-column <code>matrix</code>, <code>data.frame</code>, or a numeric <code>vector</code>.</p>
</td></tr>
<tr><td><code id="gts_+3A_start">start</code></td>
<td>
<p>A <code>numeric</code> that provides the time of the first observation.</p>
</td></tr>
<tr><td><code id="gts_+3A_end">end</code></td>
<td>
<p>A <code>numeric</code> that provides the time of the last observation.</p>
</td></tr>
<tr><td><code id="gts_+3A_freq">freq</code></td>
<td>
<p>A <code>numeric</code> that provides the rate/frequency at which the time series is sampled. The default value is 1.</p>
</td></tr>
<tr><td><code id="gts_+3A_unit_ts">unit_ts</code></td>
<td>
<p>A <code>string</code> that contains the unit of measure of the time series. The default value is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="gts_+3A_unit_time">unit_time</code></td>
<td>
<p>A <code>string</code> that contains the unit of measure of the time. The default value is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="gts_+3A_name_ts">name_ts</code></td>
<td>
<p>A <code>string</code> that provides an identifier for the time series data. Default value is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="gts_+3A_name_time">name_time</code></td>
<td>
<p>A <code>string</code> that provides an identifier for the time. Default value is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="gts_+3A_data_name">data_name</code></td>
<td>
<p>A <code>string</code> that contains the name of the time series data.</p>
</td></tr>
<tr><td><code id="gts_+3A_time">Time</code></td>
<td>
<p>A numeric or character <code>vector</code> containing the times of observations. Default value is <code>NULL</code>. See <code>x</code> object in <code>as.Date</code> function.</p>
</td></tr>
<tr><td><code id="gts_+3A_time_format">time_format</code></td>
<td>
<p>A <code>string</code> specifiying the format of 'Time'. If not provided, 'Time' is assumed to be all integers. Default value is <code>NULL</code>. See <code>format</code> argument in <code>as.Date</code> function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>gts</code> object
</p>


<h3>Author(s)</h3>

<p>James Balamuta and Wenchao Yang
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m = data.frame(rnorm(50))
x = gts(m, unit_time = 'sec', name_ts = 'example')
plot(x)

x = gen_gts(50, WN(sigma2 = 1))
x = gts(x, freq = 100, unit_time = 'sec')
plot(x)
</code></pre>

<hr>
<h2 id='gts_time'>Time of a gts object</h2><span id='topic+gts_time'></span>

<h3>Description</h3>

<p>Extracting the time of a gts object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gts_time(x)
</code></pre>


<h3>Value</h3>

<p>Time vector of a gts object.
</p>


<h3>Author(s)</h3>

<p>Stéphane Guerrier
</p>

<hr>
<h2 id='guess_initial'>Randomly guess a starting parameter</h2><span id='topic+guess_initial'></span>

<h3>Description</h3>

<p>Sets starting parameters for each of the given parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>guess_initial(
  desc,
  objdesc,
  model_type,
  num_param,
  expect_diff,
  N,
  wv,
  tau,
  ranged,
  G
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="guess_initial_+3A_desc">desc</code></td>
<td>
<p>A <code>vector&lt;string&gt;</code> that contains the model's components.</p>
</td></tr>
<tr><td><code id="guess_initial_+3A_objdesc">objdesc</code></td>
<td>
<p>A <code>field&lt;vec&gt;</code> that contains an object description (e.g. values) of the model.</p>
</td></tr>
<tr><td><code id="guess_initial_+3A_model_type">model_type</code></td>
<td>
<p>A <code>string</code> that indicates whether it is an SSM or sensor.</p>
</td></tr>
<tr><td><code id="guess_initial_+3A_num_param">num_param</code></td>
<td>
<p>An <code>unsigned int</code> number of parameters in the model (e.g. # of thetas).</p>
</td></tr>
<tr><td><code id="guess_initial_+3A_expect_diff">expect_diff</code></td>
<td>
<p>A <code>double</code> that contains the mean of the first difference of the data</p>
</td></tr>
<tr><td><code id="guess_initial_+3A_n">N</code></td>
<td>
<p>A <code>integer</code> that contains the number of observations in the data.</p>
</td></tr>
<tr><td><code id="guess_initial_+3A_tau">tau</code></td>
<td>
<p>A <code>vec</code> that contains the scales. (e.g. 2^(1:J))</p>
</td></tr>
<tr><td><code id="guess_initial_+3A_g">G</code></td>
<td>
<p>A <code>integer</code> that indicates how many random draws that should be performed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>vec</code> containing smart parameter starting guesses to be iterated over.
</p>

<hr>
<h2 id='guess_initial_old'>Randomly guess a starting parameter</h2><span id='topic+guess_initial_old'></span>

<h3>Description</h3>

<p>Sets starting parameters for each of the given parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>guess_initial_old(
  desc,
  objdesc,
  model_type,
  num_param,
  expect_diff,
  N,
  wv_empir,
  tau,
  B
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="guess_initial_old_+3A_desc">desc</code></td>
<td>
<p>A <code>vector&lt;string&gt;</code> that contains the model's components.</p>
</td></tr>
<tr><td><code id="guess_initial_old_+3A_objdesc">objdesc</code></td>
<td>
<p>A <code>field&lt;vec&gt;</code> that contains an object description (e.g. values) of the model.</p>
</td></tr>
<tr><td><code id="guess_initial_old_+3A_model_type">model_type</code></td>
<td>
<p>A <code>string</code> that indicates whether it is an SSM or sensor.</p>
</td></tr>
<tr><td><code id="guess_initial_old_+3A_num_param">num_param</code></td>
<td>
<p>An <code>unsigned int</code> number of parameters in the model (e.g. # of thetas).</p>
</td></tr>
<tr><td><code id="guess_initial_old_+3A_expect_diff">expect_diff</code></td>
<td>
<p>A <code>double</code> that contains the mean of the first difference of the data</p>
</td></tr>
<tr><td><code id="guess_initial_old_+3A_n">N</code></td>
<td>
<p>A <code>integer</code> that contains the number of observations in the data.</p>
</td></tr>
<tr><td><code id="guess_initial_old_+3A_wv_empir">wv_empir</code></td>
<td>
<p>A <code>vec</code> that contains the empirical wavelet variance.</p>
</td></tr>
<tr><td><code id="guess_initial_old_+3A_tau">tau</code></td>
<td>
<p>A <code>vec</code> that contains the scales. (e.g. 2^(1:J))</p>
</td></tr>
<tr><td><code id="guess_initial_old_+3A_b">B</code></td>
<td>
<p>A <code>integer</code> that indicates how many random draws that should be performed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>vec</code> containing smart parameter starting guesses to be iterated over.
</p>

<hr>
<h2 id='haar_filter'>Haar filter construction</h2><span id='topic+haar_filter'></span>

<h3>Description</h3>

<p>Creates the haar filter
</p>


<h3>Usage</h3>

<pre><code class='language-R'>haar_filter()
</code></pre>


<h3>Details</h3>

<p>This template can be used to increase the amount of filters available for selection.
</p>


<h3>Value</h3>

<p>A <code>field&lt;vec&gt;</code> that contains:
</p>

<ul>
<li><p>&quot;L&quot;A <code>integer</code> specifying the length of the filter
</p>
</li>
<li><p>&quot;h&quot;A <code>vector</code> containing the coefficients for the wavelet filter
</p>
</li>
<li><p>&quot;g&quot;A <code>vector</code> containing the coefficients for the scaling filter
</p>
</li></ul>



<h3>Author(s)</h3>

<p>JJB
</p>

<hr>
<h2 id='has'>Obtain the value of an object's properties</h2><span id='topic+has'></span><span id='topic+has.imu'></span>

<h3>Description</h3>

<p>Used to access different properties of the
<code>gts</code>, <code>imu</code>, or <code>lts</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>has(x, type)

## S3 method for class 'imu'
has(x, type)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="has_+3A_x">x</code></td>
<td>
<p>A <code>gts</code>, <code>imu</code>, or <code>lts</code> object.</p>
</td></tr>
<tr><td><code id="has_+3A_type">type</code></td>
<td>
<p>A <code>string</code> indicating the field to be retrieved.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>To access information about <code>imu</code> properties use:
</p>

<dl>
<dt><code>"accel"</code></dt><dd><p>Returns whether accelerometers have been specified</p>
</dd>
<dt><code>"gyro"</code></dt><dd><p>Returns whether accelerometers have been specified</p>
</dd>
<dt><code>"sensors"</code></dt><dd><p>Returns whether there exists both types of sensors</p>
</dd>
</dl>



<h3>Value</h3>

<p>The method will return a single TRUE or FALSE response
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>has(imu)</code>: Access <code>imu</code> object properties
</p>
</li></ul>


<h3>Author(s)</h3>

<p>James Balamuta
</p>

<hr>
<h2 id='hydro'>Mean Monthly Precipitation, from 1907 to 1972</h2><span id='topic+hydro'></span>

<h3>Description</h3>

<p>Hydrology data that indicates a robust approach may be preferred to a
classical approach when estimating time series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hydro
</code></pre>


<h3>Format</h3>

<p>A time series object with frequency 12 starting at 1907 and going to 1972
for a total of 781 observations.
</p>


<h3>Source</h3>

<p>datamarket, mean-monthly-precipitation-1907-1972
</p>

<hr>
<h2 id='idf_arma'>Indirect Inference for ARMA</h2><span id='topic+idf_arma'></span>

<h3>Description</h3>

<p>Option for indirect inference
</p>


<h3>Usage</h3>

<pre><code class='language-R'>idf_arma(ar, ma, sigma2, N, robust, eff, H)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="idf_arma_+3A_ar">ar</code></td>
<td>
<p>A <code>vec</code> that contains the coefficients of the AR process.</p>
</td></tr>
<tr><td><code id="idf_arma_+3A_ma">ma</code></td>
<td>
<p>A <code>vec</code> that contains the coefficients of the MA process.</p>
</td></tr>
<tr><td><code id="idf_arma_+3A_sigma2">sigma2</code></td>
<td>
<p>A <code>double</code> that indicates the sigma2 parameter of the ARMA process.</p>
</td></tr>
<tr><td><code id="idf_arma_+3A_n">N</code></td>
<td>
<p>A <code>int</code> that indicates how long the time series is.</p>
</td></tr>
<tr><td><code id="idf_arma_+3A_robust">robust</code></td>
<td>
<p>A <code>bool</code> that indicates whether the estimation should be robust or not.</p>
</td></tr>
<tr><td><code id="idf_arma_+3A_eff">eff</code></td>
<td>
<p>A <code>double</code> that specifies the amount of efficiency required by the robust estimator.</p>
</td></tr>
<tr><td><code id="idf_arma_+3A_h">H</code></td>
<td>
<p>A <code>int</code> that indicates how many iterations should take place.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>vec</code> with the indirect inference results.
</p>

<hr>
<h2 id='idf_arma_total'>Indirect Inference for ARMA</h2><span id='topic+idf_arma_total'></span>

<h3>Description</h3>

<p>Option for indirect inference
</p>


<h3>Usage</h3>

<pre><code class='language-R'>idf_arma_total(ar, ma, sigma2, N, robust, eff, H)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="idf_arma_total_+3A_ar">ar</code></td>
<td>
<p>A <code>vec</code> that contains the coefficients of the AR process.</p>
</td></tr>
<tr><td><code id="idf_arma_total_+3A_ma">ma</code></td>
<td>
<p>A <code>vec</code> that contains the coefficients of the MA process.</p>
</td></tr>
<tr><td><code id="idf_arma_total_+3A_sigma2">sigma2</code></td>
<td>
<p>A <code>double</code> that indicates the sigma2 parameter of the ARMA process.</p>
</td></tr>
<tr><td><code id="idf_arma_total_+3A_n">N</code></td>
<td>
<p>A <code>int</code> that indicates how long the time series is.</p>
</td></tr>
<tr><td><code id="idf_arma_total_+3A_robust">robust</code></td>
<td>
<p>A <code>bool</code> that indicates whether the estimation should be robust or not.</p>
</td></tr>
<tr><td><code id="idf_arma_total_+3A_eff">eff</code></td>
<td>
<p>A <code>double</code> that specifies the amount of efficiency required by the robust estimator.</p>
</td></tr>
<tr><td><code id="idf_arma_total_+3A_h">H</code></td>
<td>
<p>A <code>int</code> that indicates how many iterations should take place.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>vec</code> with the indirect inference results.
</p>

<hr>
<h2 id='imu'>Create an IMU Object</h2><span id='topic+imu'></span>

<h3>Description</h3>

<p>Builds an IMU object that provides the program with gyroscope, accelerometer, and axis information per column in the dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>imu(
  data,
  gyros = NULL,
  accels = NULL,
  axis = NULL,
  freq = NULL,
  unit = NULL,
  name = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="imu_+3A_data">data</code></td>
<td>
<p>A <code>vector</code> which contains data, or a <code>matrix</code> or <code>data.frame</code> which contains the data in each column.</p>
</td></tr>
<tr><td><code id="imu_+3A_gyros">gyros</code></td>
<td>
<p>A <code>vector</code> that contains the index of columns where gyroscope data (such as Gyro. X, Gyro. Y and Gyro. Z) is placed.</p>
</td></tr>
<tr><td><code id="imu_+3A_accels">accels</code></td>
<td>
<p>A <code>vector</code> that contains the index of columns where accelerometer data (such as Accel. X, Accel. Y and Accel. Z) is placed.</p>
</td></tr>
<tr><td><code id="imu_+3A_axis">axis</code></td>
<td>
<p>A <code>vector</code> that indicates the axises, such as 'X', 'Y', 'Z'. Please supply the axises for gyroscope data before that for accelerometer data, if gyroscope data exists.</p>
</td></tr>
<tr><td><code id="imu_+3A_freq">freq</code></td>
<td>
<p>An <code>integer</code> that provides the frequency for the data.</p>
</td></tr>
<tr><td><code id="imu_+3A_unit">unit</code></td>
<td>
<p>A <code>string</code> that contains the unit expression of the frequency. Default value is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="imu_+3A_name">name</code></td>
<td>
<p>A <code>string</code> that provides an identifier to the data. Default value is <code>NULL</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>data</code> can be a numeric vector, matrix or data frame.
</p>
<p><code>gyros</code> and <code>accels</code> cannot be <code>NULL</code> at the same time, but it will be fine if one of them is <code>NULL</code>.
In the new implementation, the length of <code>gyros</code> and <code>accels</code> do not need to be equal.
</p>
<p>In <code>axis</code>, duplicate elements are not alowed for each sensor. In the new implementation, please specify the axis for each column of data.
<code>axis</code> will be automatically generated if there are less than or equal to 3 axises for each sensor.
</p>


<h3>Value</h3>

<p>An <code>imu</code> object in the following attributes:
</p>

<dl>
<dt>sensor</dt><dd><p>A <code>vector</code> that indicates whether data contains gyroscope sensor, accelerometer sensor, or both.</p>
</dd>
<dt>num.sensor</dt><dd><p>A <code>vector</code> that indicates how many columns of data are for gyroscope sensor and accelerometer sensor.</p>
</dd>
<dt>axis</dt><dd><p>Axis value such as 'X', 'Y', 'Z'.</p>
</dd>
<dt>freq</dt><dd><p>Observations per second.</p>
</dd>
<dt>unit</dt><dd><p>String representation of the unit.</p>
</dd>
<dt>name</dt><dd><p>Name of the dataset.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>James Balamuta and Wenchao Yang
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
if(!require("imudata")){
   install_imudata()
   library("imudata")
}

data(imu6)

# Example 1 - Only gyros
test1 = imu(imu6, gyros = 1:3, axis = c('X', 'Y', 'Z'), freq = 100)
df1 = wvar.imu(test1)
plot(df1)

# Example 2 - One gyro and one accelerometer
test2 = imu(imu6, gyros = 1, accels = 4, freq = 100)
df2 = wvar.imu(test2)
plot(df2)

# Example 3 - 3 gyros and 3 accelerometers
test3 = imu(imu6, gyros = 1:3, accels = 4:6, axis = 
                       c('X', 'Y', 'Z', 'X', 'Y', 'Z'), freq = 100)
df3 = wvar.imu(test3)
plot(df3)

# Example 4 - Custom axis
test4 = imu(imu6, gyros = 1:2, accels = 4:6, axis = 
                       c('X', 'Y', 'X', 'Y', 'Z'), freq = 100)
df4 = wvar.imu(test4)
plot(df4)

## End(Not run)
</code></pre>

<hr>
<h2 id='imu_time'>Pulls the IMU time from the IMU object</h2><span id='topic+imu_time'></span>

<h3>Description</h3>

<p>Helper function for the IMU object to access <code>rownames()</code> with a numeric conversion.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>imu_time(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="imu_time_+3A_x">x</code></td>
<td>
<p>A <code>imu</code> object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>vector</code> with numeric information.
</p>

<hr>
<h2 id='intgr_vec'>Discrete Intergral: Inverse Difference</h2><span id='topic+intgr_vec'></span><span id='topic+diff_inv_values'></span><span id='topic+diff_inv'></span>

<h3>Description</h3>

<p>Takes the inverse difference (e.g. goes from diff() result back to previous vector)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>intgr_vec(x, xi, lag)

diff_inv_values(x, lag, d, xi)

diff_inv(x, lag, d)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="intgr_vec_+3A_x">x</code></td>
<td>
<p>A <code>vec</code> containing the data</p>
</td></tr>
<tr><td><code id="intgr_vec_+3A_xi">xi</code></td>
<td>
<p>A <code>vec</code> with length <code class="reqn">lag*d</code> that provides initial values for the integration.</p>
</td></tr>
<tr><td><code id="intgr_vec_+3A_lag">lag</code></td>
<td>
<p>An <code>unsigned int</code> indicating the lag between observations.</p>
</td></tr>
<tr><td><code id="intgr_vec_+3A_d">d</code></td>
<td>
<p>An <code>unsigned int</code> which gives the number of &quot;differences&quot; to invert.</p>
</td></tr>
</table>

<hr>
<h2 id='invert_check'>Check Invertibility Conditions</h2><span id='topic+invert_check'></span>

<h3>Description</h3>

<p>Checks the invertiveness of series of coefficients.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>invert_check(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="invert_check_+3A_x">x</code></td>
<td>
<p>A <code>cx_vec</code> that has a 1 appended before the coefficents. (e.g. c(1, x))</p>
</td></tr>
</table>


<h3>Value</h3>

<p>True (if outside unit circle) || False (if inside unit circle)
</p>

<hr>
<h2 id='is.gts'>Is simts Object</h2><span id='topic+is.gts'></span><span id='topic+is.imu'></span><span id='topic+is.lts'></span><span id='topic+is.ts.model'></span>

<h3>Description</h3>

<p>Is the object a
<code>gts</code>, <code>imu</code>, or <code>lts</code> object?
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.gts(x)

is.imu(x)

is.lts(x)

is.ts.model(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.gts_+3A_x">x</code></td>
<td>
<p>A <code>gts</code>, <code>imu</code>, <code>lts</code> object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Uses <code><a href="base.html#topic+inherits">inherits</a></code> over <code><a href="methods.html#topic+is">is</a></code> for speed.
</p>


<h3>Value</h3>

<p>A <code>logical</code> value that indicates whether the object is of that class (TRUE) or not (FALSE).
</p>


<h3>Author(s)</h3>

<p>James Balamuta
</p>

<hr>
<h2 id='is.whole'>Integer Check</h2><span id='topic+is.whole'></span>

<h3>Description</h3>

<p>Checks whether the submitted value is an integer
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.whole(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.whole_+3A_x">x</code></td>
<td>
<p>A <code>numeric</code> value.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>boolean</code> value indicating whether the value is an integer or not.
</p>


<h3>Author(s)</h3>

<p>James Balamuta
</p>


<h3>Examples</h3>

<pre><code class='language-R'>is.whole(2.3)
is.whole(4)
is.whole(c(1,2,3))
is.whole(c(.4,.5,.6))
is.whole(c(7,.8,9))
</code></pre>

<hr>
<h2 id='jacobian_arma'>Calculates the Jacobian for the ARMA process</h2><span id='topic+jacobian_arma'></span>

<h3>Description</h3>

<p>Take the numerical derivative for the first derivative of an ARMA using the 2 point rule.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>jacobian_arma(theta, p, q, tau)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="jacobian_arma_+3A_theta">theta</code></td>
<td>
<p>A <code>vec</code> that contains all the parameter estimates.</p>
</td></tr>
<tr><td><code id="jacobian_arma_+3A_p">p</code></td>
<td>
<p>A <code>int</code> that indicates the number of AR coefficients</p>
</td></tr>
<tr><td><code id="jacobian_arma_+3A_q">q</code></td>
<td>
<p>A <code>int</code> that indicates the number of MA coefficients.</p>
</td></tr>
<tr><td><code id="jacobian_arma_+3A_tau">tau</code></td>
<td>
<p>A <code>vec</code> containing the scales e.g. <code class="reqn">2^{\tau}</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>mat</code> that returns the first numerical derivative of the ARMA process.
</p>


<h3>Author(s)</h3>

<p>James Joseph Balamuta (JJB)
</p>

<hr>
<h2 id='la16_filter'>la16 filter construction</h2><span id='topic+la16_filter'></span>

<h3>Description</h3>

<p>Creates the la16 filter
</p>


<h3>Usage</h3>

<pre><code class='language-R'>la16_filter()
</code></pre>


<h3>Details</h3>

<p>This template can be used to increase the amount of filters available for selection.
</p>


<h3>Value</h3>

<p>A <code>field&lt;vec&gt;</code> that contains:
</p>

<ul>
<li><p>&quot;L&quot;A <code>integer</code> specifying the length of the filter
</p>
</li>
<li><p>&quot;h&quot;A <code>vector</code> containing the coefficients for the wavelet filter
</p>
</li>
<li><p>&quot;g&quot;A <code>vector</code> containing the coefficients for the scaling filter
</p>
</li></ul>



<h3>Author(s)</h3>

<p>JJB
</p>

<hr>
<h2 id='la20_filter'>la20 filter construction</h2><span id='topic+la20_filter'></span>

<h3>Description</h3>

<p>Creates the la20 filter
</p>


<h3>Usage</h3>

<pre><code class='language-R'>la20_filter()
</code></pre>


<h3>Details</h3>

<p>This template can be used to increase the amount of filters available for selection.
</p>


<h3>Value</h3>

<p>A <code>field&lt;vec&gt;</code> that contains:
</p>

<ul>
<li><p>&quot;L&quot;A <code>integer</code> specifying the length of the filter
</p>
</li>
<li><p>&quot;h&quot;A <code>vector</code> containing the coefficients for the wavelet filter
</p>
</li>
<li><p>&quot;g&quot;A <code>vector</code> containing the coefficients for the scaling filter
</p>
</li></ul>



<h3>Author(s)</h3>

<p>JJB
</p>

<hr>
<h2 id='la8_filter'>la8 filter construction</h2><span id='topic+la8_filter'></span>

<h3>Description</h3>

<p>Creates the la8 filter
</p>


<h3>Usage</h3>

<pre><code class='language-R'>la8_filter()
</code></pre>


<h3>Details</h3>

<p>This template can be used to increase the amount of filters available for selection.
</p>


<h3>Value</h3>

<p>A <code>field&lt;vec&gt;</code> that contains:
</p>

<ul>
<li><p>&quot;L&quot;A <code>integer</code> specifying the length of the filter
</p>
</li>
<li><p>&quot;h&quot;A <code>vector</code> containing the coefficients for the wavelet filter
</p>
</li>
<li><p>&quot;g&quot;A <code>vector</code> containing the coefficients for the scaling filter
</p>
</li></ul>



<h3>Author(s)</h3>

<p>JJB
</p>

<hr>
<h2 id='lm_arma'>MLR in Armadillo</h2><span id='topic+lm_arma'></span>

<h3>Description</h3>

<p>Perform Multiple Linear Regression using armadillo in C++
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lm_arma(y, X)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lm_arma_+3A_y">y</code></td>
<td>
<p>A <code>vec</code> of length <code class="reqn">N\times 1</code> containing the responses.</p>
</td></tr>
<tr><td><code id="lm_arma_+3A_x">X</code></td>
<td>
<p>A <code>mat</code> with dimensions <code class="reqn">N \times p</code>, which is the design matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>field&lt;vec&gt;</code> with:
</p>

<dl>
<dt>coef</dt><dd><p>Coefficients</p>
</dd>
<dt>resid</dt><dd><p>Residuals</p>
</dd>
<dt>sigma2</dt><dd><p>Sigma^2</p>
</dd>
</dl>


<hr>
<h2 id='lm_dr'>Linear Regression with Drift</h2><span id='topic+lm_dr'></span>

<h3>Description</h3>

<p>Perform a linear regression with drift.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lm_dr(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lm_dr_+3A_x">x</code></td>
<td>
<p>A <code>vec</code> of length <code class="reqn">N\times 1</code> containing the responses.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>field&lt;vec&gt;</code> with:
</p>

<dl>
<dt>coef</dt><dd><p>Coefficients</p>
</dd>
<dt>resid</dt><dd><p>Residuals</p>
</dd>
<dt>sigma2</dt><dd><p>Sigma^2</p>
</dd>
</dl>


<hr>
<h2 id='logit'>Logit Function</h2><span id='topic+logit'></span>

<h3>Description</h3>

<p>This function computes the logit link function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>logit(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logit_+3A_x">x</code></td>
<td>
<p>A <code>vec</code> containing probabilities (e.g. -1 &lt;= x &lt;= 1)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>vec</code> containing logit terms.
</p>


<h3>Author(s)</h3>

<p>James Joseph Balamuta (JJB)
</p>

<hr>
<h2 id='logit_inv'>Logit Inverse Function</h2><span id='topic+logit_inv'></span>

<h3>Description</h3>

<p>This function computes the inverse of a logit transformation of the parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>logit_inv(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logit_inv_+3A_x">x</code></td>
<td>
<p>A <code>vec</code> containing real numbers.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>vec</code> containing logit probabilities.
</p>


<h3>Author(s)</h3>

<p>James Joseph Balamuta (JJB)
</p>

<hr>
<h2 id='logit2'>Logit2 Function</h2><span id='topic+logit2'></span>

<h3>Description</h3>

<p>This function computes the logit2 link function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>logit2(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logit2_+3A_x">x</code></td>
<td>
<p>A <code>vec</code> containing probabilities (e.g. -2 &lt;= x &lt;= 2)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>vec</code> containing logit terms.
</p>


<h3>Author(s)</h3>

<p>James Joseph Balamuta (JJB)
</p>

<hr>
<h2 id='logit2_inv'>Logit2 Inverse Function</h2><span id='topic+logit2_inv'></span>

<h3>Description</h3>

<p>This function computes the inverse of a logit transformation of the parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>logit2_inv(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logit2_inv_+3A_x">x</code></td>
<td>
<p>A <code>vec</code> containing real numbers.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>vec</code> containing logit probabilities.
</p>


<h3>Author(s)</h3>

<p>James Joseph Balamuta (JJB)
</p>

<hr>
<h2 id='lts'>Generate a Latent Time Series Object from Data</h2><span id='topic+lts'></span>

<h3>Description</h3>

<p>Create a <code>lts</code> object based on a supplied matrix or data frame. The latent time series is obtained by the sum of underlying time series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lts(
  data,
  start = 0,
  end = NULL,
  freq = 1,
  unit_ts = NULL,
  unit_time = NULL,
  name_ts = NULL,
  name_time = NULL,
  process = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lts_+3A_data">data</code></td>
<td>
<p>A multiple-column <code>matrix</code> or <code>data.frame</code>. It must contain at least 3 columns of which the last represents the latent time series obtained through the sum of the previous columns.</p>
</td></tr>
<tr><td><code id="lts_+3A_start">start</code></td>
<td>
<p>A <code>numeric</code> that provides the time of the first observation.</p>
</td></tr>
<tr><td><code id="lts_+3A_end">end</code></td>
<td>
<p>A <code>numeric</code> that provides the time of the last observation.</p>
</td></tr>
<tr><td><code id="lts_+3A_freq">freq</code></td>
<td>
<p>A <code>numeric</code> that provides the rate/frequency at which the time series is sampled. The default value is 1.</p>
</td></tr>
<tr><td><code id="lts_+3A_unit_ts">unit_ts</code></td>
<td>
<p>A <code>string</code> that contains the unit of measure of the time series. The default value is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="lts_+3A_unit_time">unit_time</code></td>
<td>
<p>A <code>string</code> that contains the unit of measure of the time. The default value is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="lts_+3A_name_ts">name_ts</code></td>
<td>
<p>A <code>string</code> that provides an identifier for the time series data. Default value is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="lts_+3A_name_time">name_time</code></td>
<td>
<p>A <code>string</code> that provides an identifier for the time. Default value is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="lts_+3A_process">process</code></td>
<td>
<p>A <code>vector</code> that contains model names of each column in the <code>data</code> object where the last name is the sum of the previous names.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>lts</code> object
</p>


<h3>Author(s)</h3>

<p>Wenchao Yang and Justin Lee
</p>


<h3>Examples</h3>

<pre><code class='language-R'>model1 = AR1(phi = .99, sigma2 = 1) 
model2 = WN(sigma2 = 1)
col1 = gen_gts(1000, model1)
col2 = gen_gts(1000, model2)
testMat = cbind(col1, col2, col1+col2)
testLts = lts(testMat, unit_time = 'sec', process = c('AR1', 'WN', 'AR1+WN'))
plot(testLts)
</code></pre>

<hr>
<h2 id='M'>Definition of a Mean deterministic vector returned by the matrix by vector product of matrix <code class="reqn">X</code> and vector <code class="reqn">\beta</code></h2><span id='topic+M'></span>

<h3>Description</h3>

<p>Definition of a Mean deterministic vector returned by the matrix by vector product of matrix <code class="reqn">X</code> and vector <code class="reqn">\beta</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>M(X, beta)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="M_+3A_x">X</code></td>
<td>
<p>A <code>Matrix</code>  with dimension n*p.</p>
</td></tr>
<tr><td><code id="M_+3A_beta">beta</code></td>
<td>
<p>A <code>vector</code> with dimension p*1</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An S3 object containing the specified ts.model with the following structure:
</p>

<dl>
<dt>process.desc</dt><dd><p>Used in summary: &quot;X&quot;,&quot;BETA&quot;</p>
</dd>
<dt>theta</dt><dd><p>Matrix X, vector beta</p>
</dd>
<dt>plength</dt><dd><p>Number of parameters</p>
</dd>
<dt>print</dt><dd><p>String containing simplified model</p>
</dd>
<dt>desc</dt><dd><p>&quot;M&quot;</p>
</dd>
<dt>obj.desc</dt><dd><p>Depth of Parameters e.g. list(1,1)</p>
</dd>
<dt>starting</dt><dd><p>Find starting values? TRUE or FALSE (e.g. specified value)</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Lionel Voirol,  Davide Cucci
</p>


<h3>Examples</h3>

<pre><code class='language-R'>X = matrix(rnorm(15*5), nrow = 15, ncol = 5)
beta=seq(5)
M(X = X, beta = beta)
</code></pre>

<hr>
<h2 id='m2_drift'>Second moment DR</h2><span id='topic+m2_drift'></span>

<h3>Description</h3>

<p>This function computes the second moment of a drift process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>m2_drift(omega, n_ts)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="m2_drift_+3A_omega">omega</code></td>
<td>
<p>A <code>double</code> corresponding to variance of drift.</p>
</td></tr>
<tr><td><code id="m2_drift_+3A_n_ts">n_ts</code></td>
<td>
<p>An <code>int</code> indicating the length of the time series.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>vec</code> containing the second moment of the drift.
</p>

<hr>
<h2 id='MA'>Create an Moving Average Q [MA(Q)] Process</h2><span id='topic+MA'></span>

<h3>Description</h3>

<p>Sets up the necessary backend for the MA(Q) process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MA(theta = NULL, sigma2 = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MA_+3A_theta">theta</code></td>
<td>
<p>A <code>double</code> value for the parameter <code class="reqn">\theta</code> (see Note for details).</p>
</td></tr>
<tr><td><code id="MA_+3A_sigma2">sigma2</code></td>
<td>
<p>A <code>double</code> value for the variance parameter <code class="reqn">\sigma ^2</code> (see Note for details).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An S3 object with called ts.model with the following structure:
</p>

<dl>
<dt>process.desc</dt><dd><p>Used in summary: &quot;MA-1&quot;,&quot;MA-2&quot;, ..., &quot;MA-Q&quot;, &quot;SIGMA2&quot;</p>
</dd>
<dt>theta</dt><dd><p><code class="reqn">\theta_1</code>, <code class="reqn">\theta_2</code>, ..., <code class="reqn">\theta_q</code>, <code class="reqn">\sigma^2</code></p>
</dd>
<dt>plength</dt><dd><p>Number of parameters</p>
</dd>
<dt>desc</dt><dd><p>&quot;MA&quot;</p>
</dd>
<dt>print</dt><dd><p>String containing simplified model</p>
</dd>
<dt>obj.desc</dt><dd><p>Depth of parameters e.g. list(q,1)</p>
</dd>
<dt>starting</dt><dd><p>Guess starting values? TRUE or FALSE (e.g. specified value)</p>
</dd>
</dl>



<h3>Note</h3>

<p>We consider the following model: </p>
<p style="text-align: center;"><code class="reqn">X_t = \sum_{j = 1}^q \theta_j \varepsilon_{t-1} + \varepsilon_t</code>
</p>
<p>, where <code class="reqn">\varepsilon_t</code> is iid from a zero 
mean normal distribution with variance <code class="reqn">\sigma^2</code>.
</p>


<h3>Author(s)</h3>

<p>James Balamuta
</p>


<h3>Examples</h3>

<pre><code class='language-R'>MA(1) # One theta
MA(2) # Two thetas!

MA(theta=.32, sigma=1.3) # 1 theta with a specific value.
MA(theta=c(.3,.5), sigma=.3) # 2 thetas with specific values.
</code></pre>

<hr>
<h2 id='Ma_cpp'>Ma function.</h2><span id='topic+Ma_cpp'></span>

<h3>Description</h3>

<p>Ma function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Ma_cpp(x, alpha)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Ma_cpp_+3A_x">x</code></td>
<td>
<p>A <code>double</code>.</p>
</td></tr>
<tr><td><code id="Ma_cpp_+3A_alpha">alpha</code></td>
<td>
<p>A <code>double</code>.</p>
</td></tr>
</table>

<hr>
<h2 id='Ma_cpp_vec'>Ma vectorized function.</h2><span id='topic+Ma_cpp_vec'></span>

<h3>Description</h3>

<p>Ma vectorized function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Ma_cpp_vec(x, alpha)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Ma_cpp_vec_+3A_x">x</code></td>
<td>
<p>A <code>NumericVector</code>.</p>
</td></tr>
</table>

<hr>
<h2 id='MA1'>Definition of an Moving Average Process of Order 1</h2><span id='topic+MA1'></span>

<h3>Description</h3>

<p>Definition of an Moving Average Process of Order 1
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MA1(theta = NULL, sigma2 = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MA1_+3A_theta">theta</code></td>
<td>
<p>A <code>double</code> value for the parameter <code class="reqn">\theta</code> (see Note for details).</p>
</td></tr>
<tr><td><code id="MA1_+3A_sigma2">sigma2</code></td>
<td>
<p>A <code>double</code> value for the variance parameter <code class="reqn">\sigma ^2</code> (see Note for details).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An S3 object with called ts.model with the following structure:
</p>

<dl>
<dt>process.desc</dt><dd><p>Used in summary: &quot;MA1&quot;,&quot;SIGMA2&quot;</p>
</dd>
<dt>theta</dt><dd><p><code class="reqn">\theta</code>, <code class="reqn">\sigma^2</code></p>
</dd>
<dt>plength</dt><dd><p>Number of parameters</p>
</dd>
<dt>print</dt><dd><p>String containing simplified model</p>
</dd>
<dt>desc</dt><dd><p>&quot;MA1&quot;</p>
</dd>
<dt>obj.desc</dt><dd><p>Depth of parameters e.g. list(1,1)</p>
</dd>
<dt>starting</dt><dd><p>Guess starting values? TRUE or FALSE (e.g. specified value)</p>
</dd>
</dl>



<h3>Note</h3>

<p>We consider the following model: </p>
<p style="text-align: center;"><code class="reqn">X_t = \theta \varepsilon_{t-1} + \varepsilon_t</code>
</p>
<p>, where <code class="reqn">\varepsilon_t</code> is iid from a zero 
mean normal distribution with variance <code class="reqn">\sigma^2</code>.
</p>


<h3>Author(s)</h3>

<p>James Balamuta
</p>


<h3>Examples</h3>

<pre><code class='language-R'>MA1()
MA1(theta = .32, sigma2 = 1.3)
</code></pre>

<hr>
<h2 id='ma1_to_wv'>Moving Average Order 1 (MA(1)) to WV</h2><span id='topic+ma1_to_wv'></span>

<h3>Description</h3>

<p>This function computes the WV (haar) of a Moving Average order 1 (MA1) process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ma1_to_wv(theta, sigma2, tau)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ma1_to_wv_+3A_theta">theta</code></td>
<td>
<p>A <code>double</code> corresponding to the moving average term.</p>
</td></tr>
<tr><td><code id="ma1_to_wv_+3A_sigma2">sigma2</code></td>
<td>
<p>A <code>double</code> the variance of the process.</p>
</td></tr>
<tr><td><code id="ma1_to_wv_+3A_tau">tau</code></td>
<td>
<p>A <code>vec</code> containing the scales e.g. <code class="reqn">2^{\tau}</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is significantly faster than its generalized counter part
<code><a href="#topic+arma_to_wv">arma_to_wv</a></code>.
</p>


<h3>Value</h3>

<p>A <code>vec</code> containing the wavelet variance of the MA(1) process.
</p>


<h3>Process Haar Wavelet Variance Formula</h3>

<p>The Moving Average Order <code class="reqn">1</code> (MA(<code class="reqn">1</code>)) process has a Haar Wavelet Variance given by:
</p>
<p style="text-align: center;"><code class="reqn">\nu _j^2\left( {\theta ,{\sigma ^2}} \right) = \frac{{\left( {{{\left( {\theta  + 1} \right)}^2}{\tau _j} - 6\theta } \right){\sigma ^2}}}{{\tau _j^2}}</code>
</p>


<hr>
<h2 id='make_frame'>Default utility function for various plots titles</h2><span id='topic+make_frame'></span>

<h3>Description</h3>

<p>Adds title, grid, and required x- and y-axes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_frame(
  x_range,
  y_range,
  xlab,
  ylab,
  main = "",
  mar = c(5.1, 5.1, 1, 2.1),
  add_axis_x = TRUE,
  add_axis_y = TRUE,
  col_box = "black",
  col_grid = "grey95",
  col_band = "grey95",
  col_title = "black",
  add_band = TRUE,
  title_band_width = 0.09,
  grid_lty = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_frame_+3A_x_range">x_range</code></td>
<td>
<p>A <code>numeric</code> providing the range of values for the x-axis.</p>
</td></tr>
<tr><td><code id="make_frame_+3A_y_range">y_range</code></td>
<td>
<p>A <code>numeric</code> providing the range of values for the y-axis.</p>
</td></tr>
<tr><td><code id="make_frame_+3A_xlab">xlab</code></td>
<td>
<p>A <code>string</code> that gives a title for the x-axis.</p>
</td></tr>
<tr><td><code id="make_frame_+3A_ylab">ylab</code></td>
<td>
<p>A <code>string</code> that gives a title for the y-axis.</p>
</td></tr>
<tr><td><code id="make_frame_+3A_main">main</code></td>
<td>
<p>A <code>string</code> that gives an overall title for the plot. Default is an empty string.</p>
</td></tr>
<tr><td><code id="make_frame_+3A_mar">mar</code></td>
<td>
<p>A <code>vector</code> indicating overall margin values for the plot.</p>
</td></tr>
<tr><td><code id="make_frame_+3A_add_axis_x">add_axis_x</code></td>
<td>
<p>A <code>boolean</code> indicating whether a x-axis should be added.</p>
</td></tr>
<tr><td><code id="make_frame_+3A_add_axis_y">add_axis_y</code></td>
<td>
<p>A <code>boolean</code> indicating whether a y-axis should be added.</p>
</td></tr>
<tr><td><code id="make_frame_+3A_col_box">col_box</code></td>
<td>
<p>A <code>string</code> indicating the color for the title box.</p>
</td></tr>
<tr><td><code id="make_frame_+3A_col_grid">col_grid</code></td>
<td>
<p>A <code>string</code> indicating the color of the grid for the plot.</p>
</td></tr>
<tr><td><code id="make_frame_+3A_col_band">col_band</code></td>
<td>
<p>A <code>string</code> indicating the color of the band.</p>
</td></tr>
<tr><td><code id="make_frame_+3A_col_title">col_title</code></td>
<td>
<p>A <code>string</code> indicating the color of the plot title.</p>
</td></tr>
<tr><td><code id="make_frame_+3A_add_band">add_band</code></td>
<td>
<p>A <code>boolean</code> indicating whether there should be a band.</p>
</td></tr>
<tr><td><code id="make_frame_+3A_title_band_width">title_band_width</code></td>
<td>
<p>A <code>double</code> providing the value of the band width. Default is 0.09.</p>
</td></tr>
<tr><td><code id="make_frame_+3A_grid_lty">grid_lty</code></td>
<td>
<p>A <code>integer</code> indicating the line type of the grid lines.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Added title, grid, and axes.
</p>


<h3>Author(s)</h3>

<p>Stephane Guerrier and Justin Lee
</p>


<h3>Examples</h3>

<pre><code class='language-R'>make_frame(x_range = c(0, 1), y_range = c(0, 1), xlab = "my xlab", 
           ylab = "my ylab", main = "my title")
           
make_frame(x_range = c(0, 1), y_range = c(0, 1), xlab = "my xlab", 
           ylab = "my ylab", add_band = FALSE)
           
make_frame(x_range = c(0, 1), y_range = c(0, 1), xlab = "my xlab", 
           ylab = "my ylab", main = "my title", col_band = "blue3", 
           col_title = "white", col_grid = "lightblue", grid_lty = 3)

make_frame(x_range = c(0, 1), y_range = c(0, 1), xlab = "my xlab", 
           ylab = "my ylab", main = "my title", col_band = "blue3", 
           col_title = "white", col_grid = "lightblue", grid_lty = 3,
           title_band_width = 0.18)
</code></pre>

<hr>
<h2 id='MAPE'>Median Absolute Prediction Error</h2><span id='topic+MAPE'></span>

<h3>Description</h3>

<p>This function calculates Median Absolute Prediction Error (MAPE), which assesses 
the prediction performance with respect to point forecasts of a given model. 
It is calculated based on one-step ahead prediction and reforecasting.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MAPE(model, Xt, start = 0.8, plot = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MAPE_+3A_model">model</code></td>
<td>
<p>A time series model.</p>
</td></tr>
<tr><td><code id="MAPE_+3A_xt">Xt</code></td>
<td>
<p>A <code>vector</code> of time series data.</p>
</td></tr>
<tr><td><code id="MAPE_+3A_start">start</code></td>
<td>
<p>A <code>numeric</code> indicating the starting proportion of the data
that is used for prediction.</p>
</td></tr>
<tr><td><code id="MAPE_+3A_plot">plot</code></td>
<td>
<p>A <code>boolean</code> indicating whether a model accuracy plot based
on MAPE is returned or not.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The MAPE calculated based on one-step ahead prediction and reforecasting
is returned along with its standard deviation.
</p>


<h3>Author(s)</h3>

<p>Stéphane Guerrier and Yuming Zhang
</p>

<hr>
<h2 id='MAT'>Definition of a Matérn Process</h2><span id='topic+MAT'></span>

<h3>Description</h3>

<p>Definition of a Matérn Process
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MAT(sigma2 = 1, lambda = 0.35, alpha = 0.9)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MAT_+3A_sigma2">sigma2</code></td>
<td>
<p>A <code>double</code>.</p>
</td></tr>
<tr><td><code id="MAT_+3A_lambda">lambda</code></td>
<td>
<p>A <code>double</code>.</p>
</td></tr>
<tr><td><code id="MAT_+3A_alpha">alpha</code></td>
<td>
<p>A <code>double</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An S3 object containing the specified ts.model with the following structure:
</p>

<dl>
<dt>process.desc</dt><dd><p>Used in summary: &quot;SIGMA2&quot;,&quot;LAMBDA&quot;&quot;ALPHA&quot;</p>
</dd>
<dt>theta</dt><dd><p>Parameter vector including <code class="reqn">\sigma^2</code>,  <code class="reqn">\lambda</code>,<code class="reqn">\alpha</code></p>
</dd>
<dt>plength</dt><dd><p>Number of parameters</p>
</dd>
<dt>print</dt><dd><p>String containing simplified model</p>
</dd>
<dt>desc</dt><dd><p>&quot;MAT&quot;</p>
</dd>
<dt>obj.desc</dt><dd><p>Depth of Parameters e.g. list(1,1,1)</p>
</dd>
<dt>starting</dt><dd><p>Find starting values? TRUE or FALSE (e.g. specified value)</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Lionel Voirol,  Davide Cucci
</p>


<h3>Examples</h3>

<pre><code class='language-R'>MAT()
MAT(sigma2 = 1, lambda = 0.35, alpha = 0.9)
</code></pre>

<hr>
<h2 id='mb16_filter'>mb16 filter construction</h2><span id='topic+mb16_filter'></span>

<h3>Description</h3>

<p>Creates the mb16 filter
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mb16_filter()
</code></pre>


<h3>Details</h3>

<p>This template can be used to increase the amount of filters available for selection.
</p>


<h3>Value</h3>

<p>A <code>field&lt;vec&gt;</code> that contains:
</p>

<ul>
<li><p>&quot;L&quot;A <code>integer</code> specifying the length of the filter
</p>
</li>
<li><p>&quot;h&quot;A <code>vector</code> containing the coefficients for the wavelet filter
</p>
</li>
<li><p>&quot;g&quot;A <code>vector</code> containing the coefficients for the scaling filter
</p>
</li></ul>



<h3>Author(s)</h3>

<p>JJB
</p>

<hr>
<h2 id='mb24_filter'>mb24 filter construction</h2><span id='topic+mb24_filter'></span>

<h3>Description</h3>

<p>Creates the mb24 filter
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mb24_filter()
</code></pre>


<h3>Details</h3>

<p>This template can be used to increase the amount of filters available for selection.
</p>


<h3>Value</h3>

<p>A <code>field&lt;vec&gt;</code> that contains:
</p>

<ul>
<li><p>&quot;L&quot;A <code>integer</code> specifying the length of the filter
</p>
</li>
<li><p>&quot;h&quot;A <code>vector</code> containing the coefficients for the wavelet filter
</p>
</li>
<li><p>&quot;g&quot;A <code>vector</code> containing the coefficients for the scaling filter
</p>
</li></ul>



<h3>Author(s)</h3>

<p>JJB
</p>

<hr>
<h2 id='mb4_filter'>mb4 filter construction</h2><span id='topic+mb4_filter'></span>

<h3>Description</h3>

<p>Creates the mb4 filter
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mb4_filter()
</code></pre>


<h3>Details</h3>

<p>This template can be used to increase the amount of filters available for selection.
</p>


<h3>Value</h3>

<p>A <code>field&lt;vec&gt;</code> that contains:
</p>

<ul>
<li><p>&quot;L&quot;A <code>integer</code> specifying the length of the filter
</p>
</li>
<li><p>&quot;h&quot;A <code>vector</code> containing the coefficients for the wavelet filter
</p>
</li>
<li><p>&quot;g&quot;A <code>vector</code> containing the coefficients for the scaling filter
</p>
</li></ul>



<h3>Author(s)</h3>

<p>JJB
</p>

<hr>
<h2 id='mb8_filter'>mb8 filter construction</h2><span id='topic+mb8_filter'></span>

<h3>Description</h3>

<p>Creates the mb8 filter
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mb8_filter()
</code></pre>


<h3>Details</h3>

<p>This template can be used to increase the amount of filters available for selection.
</p>


<h3>Value</h3>

<p>A <code>field&lt;vec&gt;</code> that contains:
</p>

<ul>
<li><p>&quot;L&quot;A <code>integer</code> specifying the length of the filter
</p>
</li>
<li><p>&quot;h&quot;A <code>vector</code> containing the coefficients for the wavelet filter
</p>
</li>
<li><p>&quot;g&quot;A <code>vector</code> containing the coefficients for the scaling filter
</p>
</li></ul>



<h3>Author(s)</h3>

<p>JJB
</p>

<hr>
<h2 id='mean_diff'>Mean of the First Difference of the Data</h2><span id='topic+mean_diff'></span>

<h3>Description</h3>

<p>The mean of the first difference of the data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mean_diff(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mean_diff_+3A_x">x</code></td>
<td>
<p>A <code>vec</code> containing the data</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>double</code> that contains the mean of the first difference of the data.
</p>

<hr>
<h2 id='minroot'>Obtain the smallest polynomial root</h2><span id='topic+minroot'></span>

<h3>Description</h3>

<p>Calculates all the roots of a polynomial and returns the root that is the smallest.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>minroot(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="minroot_+3A_x">x</code></td>
<td>
<p>A <code>cx_vec</code> that has a 1 appended before the coefficents. (e.g. c(1, x))</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>double</code> with the minimum root value.
</p>

<hr>
<h2 id='Mod_cpp'>Absolute Value or Modulus of a Complex Number.</h2><span id='topic+Mod_cpp'></span>

<h3>Description</h3>

<p>Computes the value of the Modulus.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Mod_cpp(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Mod_cpp_+3A_x">x</code></td>
<td>
<p>A <code>cx_vec</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Consider a complex number defined as: <code class="reqn">z = x + i y</code> with real <code class="reqn">x</code> and <code class="reqn">y</code>,
The modulus is defined as: <code class="reqn">r = Mod(z) = \sqrt{(x^2 + y^2)}</code>
</p>


<h3>Value</h3>

<p>A <code>vec</code> containing the modulus for each element.
</p>

<hr>
<h2 id='model_objdesc'>Generate the ts model object description</h2><span id='topic+model_objdesc'></span>

<h3>Description</h3>

<p>Creates the ts.model's obj.desc value
</p>


<h3>Usage</h3>

<pre><code class='language-R'>model_objdesc(desc)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="model_objdesc_+3A_desc">desc</code></td>
<td>
<p>A <code>vector&lt;string&gt;</code> that contains a list of the strings of each process.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function currently does NOT support ARMA(P,Q) models. 
That is, there is no support for ARMA(P,Q), AR(P), or MA(Q).
There is support for ARMA11, AR1, MA1, GM, WN, DR, QN, and RW.
</p>


<h3>Value</h3>

<p>A <code>field&lt;vec&gt;</code> that contains the object description of each process.
</p>

<hr>
<h2 id='model_process_desc'>Generate the ts model object's process desc</h2><span id='topic+model_process_desc'></span>

<h3>Description</h3>

<p>Creates the ts.model's process desc
</p>


<h3>Usage</h3>

<pre><code class='language-R'>model_process_desc(desc)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="model_process_desc_+3A_desc">desc</code></td>
<td>
<p>A <code>vector&lt;string&gt;</code> that contains a list of the strings of each process.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function currently does NOT support ARMA(P,Q) models. 
That is, there is no support for ARMA(P,Q), AR(P), or MA(Q).
There is support for ARMA11, AR1, MA1, GM, WN, DR, QN, and RW.
</p>


<h3>Value</h3>

<p>A <code>vector&lt;string&gt;</code> with a list of descriptive values to label the estimate matrix with
</p>

<hr>
<h2 id='model_score'>Model Score</h2><span id='topic+model_score'></span>

<h3>Description</h3>

<p>Calculates the modeling score of a GMWM
</p>


<h3>Usage</h3>

<pre><code class='language-R'>model_score(A, D, omega, v_hat, obj_value)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="model_score_+3A_a">A</code></td>
<td>
<p>A <code>mat</code> that contains the first derivatives of the processes</p>
</td></tr>
<tr><td><code id="model_score_+3A_omega">omega</code></td>
<td>
<p>A <code>mat</code> that contains the omega used when calculating the GMWM</p>
</td></tr>
<tr><td><code id="model_score_+3A_v_hat">v_hat</code></td>
<td>
<p>A <code>mat</code> that contains the covariance matrix</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The equation is slightly different than that stated in the paper due to the bootstrap already incorporating in 
N.
</p>


<h3>Value</h3>

<p>A <code>vec</code>
</p>

<hr>
<h2 id='model_theta'>Generate the ts model object's theta vector</h2><span id='topic+model_theta'></span>

<h3>Description</h3>

<p>Creates the ts.model's theta vector
</p>


<h3>Usage</h3>

<pre><code class='language-R'>model_theta(desc)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="model_theta_+3A_desc">desc</code></td>
<td>
<p>A <code>vector&lt;string&gt;</code> that contains a list of the strings of each process.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function currently does NOT support ARMA(P,Q) models. 
That is, there is no support for ARMA(P,Q), AR(P), or MA(Q).
There is support for ARMA11, AR1, MA1, GM, WN, DR, QN, and RW.
</p>


<h3>Value</h3>

<p>A <code>vec</code> with values initialized at 0 that span the space of parameters to be estimated.
</p>

<hr>
<h2 id='modwt_cpp'>Maximum Overlap Discrete Wavelet Transform</h2><span id='topic+modwt_cpp'></span>

<h3>Description</h3>

<p>Calculation of the coefficients for the discrete wavelet transformation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>modwt_cpp(x, filter_name, nlevels, boundary, brickwall)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="modwt_cpp_+3A_x">x</code></td>
<td>
<p>A <code>vector</code> with dimensions <code class="reqn">N\times 1</code>.</p>
</td></tr>
<tr><td><code id="modwt_cpp_+3A_filter_name">filter_name</code></td>
<td>
<p>A <code>string</code> indicating the filter.</p>
</td></tr>
<tr><td><code id="modwt_cpp_+3A_nlevels">nlevels</code></td>
<td>
<p>An <code>integer</code>, <code class="reqn">J</code>, indicating the level of the decomposition.</p>
</td></tr>
<tr><td><code id="modwt_cpp_+3A_boundary">boundary</code></td>
<td>
<p>A <code>string</code> indicating the type of boundary method to use. Either <code>boundary="periodic"</code> or <code>"reflection"</code>.</p>
</td></tr>
<tr><td><code id="modwt_cpp_+3A_brickwall">brickwall</code></td>
<td>
<p>A <code>bool</code> indicating whether the a brick wall procedure should be applied to the coefficients.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Performs a level J decomposition of the time series using the pyramid algorithm.
Use this implementation to supply custom parameters instead of modwt(x),
which serves as a wrapper function.
</p>


<h3>Value</h3>

<p>y A <code>field&lt;vec&gt;</code> that contains the wavelet coefficients for each decomposition level
</p>


<h3>Author(s)</h3>

<p>JJB
</p>

<hr>
<h2 id='modwt_wvar_cpp'>Computes the (MODWT) wavelet variance</h2><span id='topic+modwt_wvar_cpp'></span>

<h3>Description</h3>

<p>Calculates the (MODWT) wavelet variance
</p>


<h3>Usage</h3>

<pre><code class='language-R'>modwt_wvar_cpp(
  signal,
  nlevels,
  robust,
  eff,
  alpha,
  ci_type,
  strWavelet,
  decomp
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="modwt_wvar_cpp_+3A_signal">signal</code></td>
<td>
<p>A <code>vec</code> that contains the data.</p>
</td></tr>
<tr><td><code id="modwt_wvar_cpp_+3A_robust">robust</code></td>
<td>
<p>A <code>boolean</code> that triggers the use of the robust estimate.</p>
</td></tr>
<tr><td><code id="modwt_wvar_cpp_+3A_eff">eff</code></td>
<td>
<p>A <code>double</code> that indicates the efficiency as it relates to an MLE.</p>
</td></tr>
<tr><td><code id="modwt_wvar_cpp_+3A_alpha">alpha</code></td>
<td>
<p>A <code>double</code> that indicates the <code class="reqn">\left(1-p\right)\times \alpha</code> confidence level</p>
</td></tr>
<tr><td><code id="modwt_wvar_cpp_+3A_ci_type">ci_type</code></td>
<td>
<p>A <code>string</code> indicating the confidence interval being calculated. Valid value: &quot;eta3&quot;</p>
</td></tr>
<tr><td><code id="modwt_wvar_cpp_+3A_strwavelet">strWavelet</code></td>
<td>
<p>A <code>string</code> indicating the type of wave filter to be applied. Must be &quot;haar&quot;</p>
</td></tr>
<tr><td><code id="modwt_wvar_cpp_+3A_decomp">decomp</code></td>
<td>
<p>A <code>string</code> indicating whether to use &quot;modwt&quot; or &quot;dwt&quot; decomp</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function powers the wvar object. It is also extendable...
</p>


<h3>Value</h3>

<p>A <code>mat</code> with the structure:
</p>

<ul>
<li><p>&quot;variance&quot;Wavelet Variance
</p>
</li>
<li><p>&quot;low&quot;Lower CI
</p>
</li>
<li><p>&quot;high&quot;Upper CI
</p>
</li></ul>


<hr>
<h2 id='np_boot_sd_med'>Bootstrap standard error for the median</h2><span id='topic+np_boot_sd_med'></span>

<h3>Description</h3>

<p>Non-parametric bootstrap to obtain the standard of the median of
iid data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>np_boot_sd_med(x, B = 5000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="np_boot_sd_med_+3A_x">x</code></td>
<td>
<p>A <code>vector</code> of data.</p>
</td></tr>
<tr><td><code id="np_boot_sd_med_+3A_b">B</code></td>
<td>
<p>A <code>numeric</code> indicating the number of simulations.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Bootstrap standard error for the median
</p>

<hr>
<h2 id='num_rep'>Replicate a Vector of Elements <code class="reqn">n</code> times</h2><span id='topic+num_rep'></span>

<h3>Description</h3>

<p>This function takes a vector and replicates all of the data <code class="reqn">n</code> times
</p>


<h3>Usage</h3>

<pre><code class='language-R'>num_rep(x, n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="num_rep_+3A_x">x</code></td>
<td>
<p>A <code>vec</code> containing the data</p>
</td></tr>
<tr><td><code id="num_rep_+3A_n">n</code></td>
<td>
<p>An <code>unsigned int</code> indicating the number of times the vector should be repeated.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>vec</code> with repeated elements of the initial supplied vector.
</p>

<hr>
<h2 id='obj_extract'>Extract Object</h2><span id='topic+obj_extract'></span>

<h3>Description</h3>

<p>Extracts the object information and returns it.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>obj_extract(theta, objdesc, cur_position)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="obj_extract_+3A_theta">theta</code></td>
<td>
<p>A <code>vec</code> containing the theta values.</p>
</td></tr>
<tr><td><code id="obj_extract_+3A_objdesc">objdesc</code></td>
<td>
<p>A <code>vec</code> at the desc point.</p>
</td></tr>
<tr><td><code id="obj_extract_+3A_cur_position">cur_position</code></td>
<td>
<p>An <code>integer</code> at the current position.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>field&lt;vec&gt;</code> containing the breakdown of the object.
</p>

<hr>
<h2 id='opt_n_gof_bootstrapper'>Bootstrap for Optimism and GoF</h2><span id='topic+opt_n_gof_bootstrapper'></span>

<h3>Description</h3>

<p>Using the bootstrap approach, we simulate a model based on user supplied parameters, obtain the wavelet variance, and then V.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>opt_n_gof_bootstrapper(
  theta,
  desc,
  objdesc,
  scales,
  model_type,
  N,
  robust,
  eff,
  alpha,
  H
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="opt_n_gof_bootstrapper_+3A_theta">theta</code></td>
<td>
<p>A <code>vector</code> with dimensions N x 1 that contains user-supplied initial values for parameters</p>
</td></tr>
<tr><td><code id="opt_n_gof_bootstrapper_+3A_desc">desc</code></td>
<td>
<p>A <code>vector&lt;string&gt;</code> indicating the models that should be considered.</p>
</td></tr>
<tr><td><code id="opt_n_gof_bootstrapper_+3A_objdesc">objdesc</code></td>
<td>
<p>A <code>field&lt;vec&gt;</code> that contains an object description (e.g. values) of the model.</p>
</td></tr>
<tr><td><code id="opt_n_gof_bootstrapper_+3A_scales">scales</code></td>
<td>
<p>A <code>vec</code> containing the scales of the process.</p>
</td></tr>
<tr><td><code id="opt_n_gof_bootstrapper_+3A_model_type">model_type</code></td>
<td>
<p>A <code>string</code> containing the model type either: SSM or IMU</p>
</td></tr>
<tr><td><code id="opt_n_gof_bootstrapper_+3A_n">N</code></td>
<td>
<p>A <code>int</code> indicating how long the integer is.</p>
</td></tr>
<tr><td><code id="opt_n_gof_bootstrapper_+3A_robust">robust</code></td>
<td>
<p>A <code>bool</code> indicating robust (T) or classical (F).</p>
</td></tr>
<tr><td><code id="opt_n_gof_bootstrapper_+3A_eff">eff</code></td>
<td>
<p>A <code>double</code> that handles efficiency.</p>
</td></tr>
<tr><td><code id="opt_n_gof_bootstrapper_+3A_h">H</code></td>
<td>
<p>A <code>int</code> that indicates how many bootstraps should be obtained.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Expand in detail...
</p>


<h3>Value</h3>

<p>A <code>vec</code> that contains the parameter estimates from GMWM estimator.
</p>


<h3>Author(s)</h3>

<p>JJB
</p>

<hr>
<h2 id='optimism_bootstrapper'>Bootstrap for Optimism</h2><span id='topic+optimism_bootstrapper'></span>

<h3>Description</h3>

<p>Using the bootstrap approach, we simulate a model based on user supplied parameters, obtain the wavelet variance, and then V.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>optimism_bootstrapper(
  theta,
  desc,
  objdesc,
  scales,
  model_type,
  N,
  robust,
  eff,
  alpha,
  H
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="optimism_bootstrapper_+3A_theta">theta</code></td>
<td>
<p>A <code>vector</code> with dimensions N x 1 that contains user-supplied initial values for parameters</p>
</td></tr>
<tr><td><code id="optimism_bootstrapper_+3A_desc">desc</code></td>
<td>
<p>A <code>vector&lt;string&gt;</code> indicating the models that should be considered.</p>
</td></tr>
<tr><td><code id="optimism_bootstrapper_+3A_objdesc">objdesc</code></td>
<td>
<p>A <code>field&lt;vec&gt;</code> that contains an object description (e.g. values) of the model.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Expand in detail...
</p>


<h3>Value</h3>

<p>A <code>vec</code> that contains the parameter estimates from GMWM estimator.
</p>


<h3>Author(s)</h3>

<p>JJB
</p>

<hr>
<h2 id='order_AR1s'>Order AR1s by size of phi.</h2><span id='topic+order_AR1s'></span>

<h3>Description</h3>

<p>Changes the order of AR1s in a string by size.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>order_AR1s(theta, desc, objdesc)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="order_AR1s_+3A_theta">theta</code></td>
<td>
<p>A <code>vec</code> with dimensions N x 1 that contains user-supplied initial values for parameters</p>
</td></tr>
<tr><td><code id="order_AR1s_+3A_desc">desc</code></td>
<td>
<p>A <code>vector&lt;string&gt;</code> indicating the models that should be considered.</p>
</td></tr>
<tr><td><code id="order_AR1s_+3A_objdesc">objdesc</code></td>
<td>
<p>A <code>field&lt;vec&gt;</code> containing a list of parameters (e.g. AR(1) = c(1,1), ARMA(p,q) = c(p,q,1))</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>vec</code> that has AR1s shown in descending parameter value.
</p>

<hr>
<h2 id='orderModel'>Order the Model</h2><span id='topic+orderModel'></span>

<h3>Description</h3>

<p>Orders the model and changes it to the correct format
</p>


<h3>Usage</h3>

<pre><code class='language-R'>orderModel(models)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="orderModel_+3A_models">models</code></td>
<td>
<p>A vector of <code>string</code> that specifies the models</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the <code>models</code> are c(&quot;AR1&quot;, &quot;WN&quot;, &quot;AR1&quot;, &quot;WN&quot;, &quot;AR1+WN+AR1+WN&quot;), it will be converted to 
c(&quot;AR1-1&quot;, &quot;WN-1&quot;, &quot;AR1-2&quot;, &quot;WN-2&quot;, &quot;AR1+WN+AR1+WN&quot;).
</p>
<p>This function is used in <code>gen.lts()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>models = c("AR1", "WN", "AR1", "WN", "AR1+WN+AR1+WN")
new.models = orderModel(models)
new.models

models = c('AR1', 'QN', 'WN', 'AR1+QN+WN')
new.models = orderModel(models)
new.models
</code></pre>

<hr>
<h2 id='plot_pred'>Plot Time Series Forecast Function</h2><span id='topic+plot_pred'></span>

<h3>Description</h3>

<p>This function plots the time series output from a forecast method with approximate 68
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_pred(
  x,
  model,
  n.ahead,
  level = NULL,
  xlab = NULL,
  ylab = NULL,
  main = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_pred_+3A_x">x</code></td>
<td>
<p>A <code>gts</code> object</p>
</td></tr>
<tr><td><code id="plot_pred_+3A_model">model</code></td>
<td>
<p>A <code>ts</code> model</p>
</td></tr>
<tr><td><code id="plot_pred_+3A_n.ahead">n.ahead</code></td>
<td>
<p>An <code>integer</code> indicating number of units of time ahead for which to make forecasts</p>
</td></tr>
<tr><td><code id="plot_pred_+3A_level">level</code></td>
<td>
<p>A <code>double</code> or <code>vector</code> indicating confidence level of prediction interval.
By default, it uses the levels of 0.50 and 0.95.</p>
</td></tr>
<tr><td><code id="plot_pred_+3A_xlab">xlab</code></td>
<td>
<p>A <code>string</code> for the title of x axis</p>
</td></tr>
<tr><td><code id="plot_pred_+3A_ylab">ylab</code></td>
<td>
<p>A <code>string</code> for the title of y axis</p>
</td></tr>
<tr><td><code id="plot_pred_+3A_main">main</code></td>
<td>
<p>A <code>string</code> for the over all title of the plot</p>
</td></tr>
<tr><td><code id="plot_pred_+3A_...">...</code></td>
<td>
<p>Additional parameters</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Yuming Zhang
</p>

<hr>
<h2 id='plot.gmwm'>Plot the GMWM with the Wavelet Variance</h2><span id='topic+plot.gmwm'></span>

<h3>Description</h3>

<p>Displays a plot of the Wavelet Variance (WV) with the CI values and the WV implied by the estimated parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gmwm'
plot(
  x,
  decomp = FALSE,
  units = NULL,
  xlab = NULL,
  ylab = NULL,
  main = NULL,
  col_wv = NULL,
  col_ci = NULL,
  nb_ticks_x = NULL,
  nb_ticks_y = NULL,
  legend_position = NULL,
  ci_wv = NULL,
  point_cex = NULL,
  point_pch = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.gmwm_+3A_x">x</code></td>
<td>
<p>A <code>gmwm</code> object.</p>
</td></tr>
<tr><td><code id="plot.gmwm_+3A_decomp">decomp</code></td>
<td>
<p>A <code>boolean</code> that determines whether the contributions of each individual model are plotted.</p>
</td></tr>
<tr><td><code id="plot.gmwm_+3A_units">units</code></td>
<td>
<p>A <code>string</code> that specifies the units of time plotted on the x axis.</p>
</td></tr>
<tr><td><code id="plot.gmwm_+3A_xlab">xlab</code></td>
<td>
<p>A <code>string</code> that gives a title for the x axis.</p>
</td></tr>
<tr><td><code id="plot.gmwm_+3A_ylab">ylab</code></td>
<td>
<p>A <code>string</code> that gives a title for the y axis.</p>
</td></tr>
<tr><td><code id="plot.gmwm_+3A_main">main</code></td>
<td>
<p>A <code>string</code> that gives an overall title for the plot.</p>
</td></tr>
<tr><td><code id="plot.gmwm_+3A_col_wv">col_wv</code></td>
<td>
<p>A <code>string</code> that specifies the color of the wavelet variance line.</p>
</td></tr>
<tr><td><code id="plot.gmwm_+3A_col_ci">col_ci</code></td>
<td>
<p>A <code>string</code> that specifies the color of the shaded area covered by the confidence intervals.</p>
</td></tr>
<tr><td><code id="plot.gmwm_+3A_nb_ticks_x">nb_ticks_x</code></td>
<td>
<p>An <code>integer</code> that specifies the maximum number of ticks for the x-axis.</p>
</td></tr>
<tr><td><code id="plot.gmwm_+3A_nb_ticks_y">nb_ticks_y</code></td>
<td>
<p>An <code>integer</code> that specifies the maximum number of ticks for the y-axis.</p>
</td></tr>
<tr><td><code id="plot.gmwm_+3A_legend_position">legend_position</code></td>
<td>
<p>A <code>string</code> that specifies the position of the legend (use <code>legend_position = NA</code> to remove legend).</p>
</td></tr>
<tr><td><code id="plot.gmwm_+3A_ci_wv">ci_wv</code></td>
<td>
<p>A <code>boolean</code> that determines whether to plot the confidence interval shaded area.</p>
</td></tr>
<tr><td><code id="plot.gmwm_+3A_point_cex">point_cex</code></td>
<td>
<p>A <code>double</code> that specifies the size of each symbol to be plotted.</p>
</td></tr>
<tr><td><code id="plot.gmwm_+3A_point_pch">point_pch</code></td>
<td>
<p>A <code>double</code> that specifies the symbol type to be plotted.</p>
</td></tr>
<tr><td><code id="plot.gmwm_+3A_...">...</code></td>
<td>
<p>Additional arguments affecting the plot.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Plot of WV and relative confidence intervals for each scale.
</p>


<h3>Author(s)</h3>

<p>Stephane Guerrier and Yuming Zhang
</p>

<hr>
<h2 id='plot.gts'>Plot simts Time Series Data</h2><span id='topic+plot.gts'></span>

<h3>Description</h3>

<p>Plot simts Time Series Data generated by gts or gen_gts.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gts'
plot(
  x,
  evenly = TRUE,
  xlab = NULL,
  ylab = NULL,
  main = NULL,
  couleur = "blue4",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.gts_+3A_x">x</code></td>
<td>
<p>A <code>gts</code> object</p>
</td></tr>
<tr><td><code id="plot.gts_+3A_evenly">evenly</code></td>
<td>
<p>A <code>boolean</code> indicating whether the time series is evenly spaced or not.</p>
</td></tr>
<tr><td><code id="plot.gts_+3A_xlab">xlab</code></td>
<td>
<p>A <code>string</code> that gives a title for the x axis.</p>
</td></tr>
<tr><td><code id="plot.gts_+3A_ylab">ylab</code></td>
<td>
<p>A <code>string</code> that gives a title for the y axis.</p>
</td></tr>
<tr><td><code id="plot.gts_+3A_main">main</code></td>
<td>
<p>A <code>string</code> that gives an overall title for the plot.</p>
</td></tr>
<tr><td><code id="plot.gts_+3A_couleur">couleur</code></td>
<td>
<p>A <code>string</code> that gives a couleuror for the line.</p>
</td></tr>
<tr><td><code id="plot.gts_+3A_...">...</code></td>
<td>
<p>additional arguments affecting the plot produced.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot containing the graph of the simts time series.
</p>


<h3>Author(s)</h3>

<p>Justin Lee and Stéphane Guerrier
</p>

<hr>
<h2 id='plot.lts'>Plot Latent Time Series Object</h2><span id='topic+plot.lts'></span>

<h3>Description</h3>

<p>Plot Latent Time Series Data included in an <code>lts</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lts'
plot(
  x,
  xlab = NULL,
  ylab = NULL,
  main = NULL,
  color = NULL,
  fixed_range = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.lts_+3A_x">x</code></td>
<td>
<p>A <code>lts</code> object</p>
</td></tr>
<tr><td><code id="plot.lts_+3A_xlab">xlab</code></td>
<td>
<p>A <code>string</code> that gives a title for the x axis.</p>
</td></tr>
<tr><td><code id="plot.lts_+3A_ylab">ylab</code></td>
<td>
<p>A <code>string</code> that gives a title for the y axis.</p>
</td></tr>
<tr><td><code id="plot.lts_+3A_main">main</code></td>
<td>
<p>A <code>string</code> that gives an overall title for the plot.</p>
</td></tr>
<tr><td><code id="plot.lts_+3A_color">color</code></td>
<td>
<p>A <code>string</code> that gives a color for the line.</p>
</td></tr>
<tr><td><code id="plot.lts_+3A_...">...</code></td>
<td>
<p>additional arguments affecting the plot produced.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot containing the graph of the latent time series.
</p>


<h3>Author(s)</h3>

<p>Stephane Gurrier and Justin Lee
</p>

<hr>
<h2 id='plot.PACF'>Plot Partial Auto-Covariance and Correlation Functions</h2><span id='topic+plot.PACF'></span>

<h3>Description</h3>

<p>The function plots the output of the <code><a href="#topic+theo_pacf">theo_pacf</a></code> and <code><a href="#topic+auto_corr">auto_corr</a></code> functions (partial autocovariance or autocorrelation functions).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'PACF'
plot(
  x,
  xlab = NULL,
  ylab = NULL,
  show.ci = TRUE,
  alpha = NULL,
  col_ci = NULL,
  transparency = NULL,
  main = NULL,
  parValue = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.PACF_+3A_x">x</code></td>
<td>
<p>A <code>"PACF"</code> object output from <code><a href="#topic+theo_pacf">theo_pacf</a></code> or <code><a href="#topic+auto_corr">auto_corr</a></code>.</p>
</td></tr>
<tr><td><code id="plot.PACF_+3A_xlab">xlab</code></td>
<td>
<p>A <code>string</code> indicating the label of the x axis: the default name is 'Lags'.</p>
</td></tr>
<tr><td><code id="plot.PACF_+3A_ylab">ylab</code></td>
<td>
<p>A <code>string</code> indicating the label of the y axis: the default name is 'PACF'.</p>
</td></tr>
<tr><td><code id="plot.PACF_+3A_show.ci">show.ci</code></td>
<td>
<p>A <code>bool</code> indicating whether to show the confidence region. Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="plot.PACF_+3A_alpha">alpha</code></td>
<td>
<p>A <code>double</code> indicating the level of significance for the confidence interval. By default <code>alpha = 0.05</code> which gives a 1 - <code>alpha</code> = 0.95 confidence interval.</p>
</td></tr>
<tr><td><code id="plot.PACF_+3A_col_ci">col_ci</code></td>
<td>
<p>A <code>string</code> that specifies the color of the region covered by the confidence intervals (confidence region).</p>
</td></tr>
<tr><td><code id="plot.PACF_+3A_transparency">transparency</code></td>
<td>
<p>A <code>double</code> between 0 and 1 indicating the transparency level of the color defined in <code>col_ci</code>.
Defaults to 0.25.</p>
</td></tr>
<tr><td><code id="plot.PACF_+3A_main">main</code></td>
<td>
<p>A <code>string</code> indicating the title of the plot. Default name is &quot;Variable name PACF plot'.</p>
</td></tr>
<tr><td><code id="plot.PACF_+3A_parvalue">parValue</code></td>
<td>
<p>A <code>vector</code> defining the margins for the plot.</p>
</td></tr>
<tr><td><code id="plot.PACF_+3A_...">...</code></td>
<td>
<p>Additional parameters</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Yunxiang Zhang and Yuming Zhang
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Plot the Partial Autocorrelation
m = auto_corr(datasets::AirPassengers, pacf = TRUE)
plot(m)

# More customized CI
plot(m, xlab = "my xlab", ylab = "my ylab", show.ci = TRUE, 
alpha = NULL, col_ci = "grey", transparency = 0.5, main = "my main")
</code></pre>

<hr>
<h2 id='plot.simtsACF'>Plot Auto-Covariance and Correlation Functions</h2><span id='topic+plot.simtsACF'></span>

<h3>Description</h3>

<p>The function plots the output of the <code>theo_acf</code> and <code>auto_corr</code> functions (autocovariance or autocorrelation functions).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'simtsACF'
plot(
  x,
  xlab = NULL,
  ylab = NULL,
  show.ci = TRUE,
  alpha = NULL,
  col_ci = NULL,
  transparency = NULL,
  main = NULL,
  parValue = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.simtsACF_+3A_x">x</code></td>
<td>
<p>An <code>"ACF"</code> object output from <code>theo_acf</code> and <code>auto_corr</code>.</p>
</td></tr>
<tr><td><code id="plot.simtsACF_+3A_xlab">xlab</code></td>
<td>
<p>A <code>string</code> indicating the label of the x axis: the default name is 'Lags'.</p>
</td></tr>
<tr><td><code id="plot.simtsACF_+3A_ylab">ylab</code></td>
<td>
<p>A <code>string</code> indicating the label of the y axis: the default name is 'ACF'.</p>
</td></tr>
<tr><td><code id="plot.simtsACF_+3A_show.ci">show.ci</code></td>
<td>
<p>A <code>bool</code> indicating whether to show the confidence region. Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="plot.simtsACF_+3A_alpha">alpha</code></td>
<td>
<p>A <code>double</code> indicating the level of significance for the confidence interval. By default <code>alpha = 0.05</code> which gives a 1 - <code>alpha</code> = 0.95 confidence interval.</p>
</td></tr>
<tr><td><code id="plot.simtsACF_+3A_col_ci">col_ci</code></td>
<td>
<p>A <code>string</code> that specifies the color of the region covered by the confidence intervals (confidence region).</p>
</td></tr>
<tr><td><code id="plot.simtsACF_+3A_transparency">transparency</code></td>
<td>
<p>A <code>double</code> between 0 and 1 indicating the transparency level of the color defined in <code>col_ci</code>.
Defaults to 0.25.</p>
</td></tr>
<tr><td><code id="plot.simtsACF_+3A_main">main</code></td>
<td>
<p>A <code>string</code> indicating the title of the plot. Default name is &quot;Variable name ACF plot'.</p>
</td></tr>
<tr><td><code id="plot.simtsACF_+3A_parvalue">parValue</code></td>
<td>
<p>A <code>vector</code> defining the margins for the plot.</p>
</td></tr>
<tr><td><code id="plot.simtsACF_+3A_...">...</code></td>
<td>
<p>Additional parameters</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Yunxiang Zhang, Stéphane Guerrier and Yuming Zhang
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Calculate the Autocorrelation
m = auto_corr(datasets::AirPassengers)

# Plot with 95% CI
plot(m) 

# Plot with 90% CI
plot(m, alpha = 0.1) 

# Plot without 95% CI
plot(m, show.ci = FALSE)

# More customized CI
plot(m, xlab = "my xlab", ylab = "my ylab", show.ci = TRUE,
alpha = NULL, col_ci = "grey", transparency = 0.5, main = "my main")
</code></pre>

<hr>
<h2 id='PLP'>Definition of a Power Law Process</h2><span id='topic+PLP'></span>

<h3>Description</h3>

<p>Definition of a Power Law Process
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PLP(sigma2 = 1, d = 0.4)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PLP_+3A_sigma2">sigma2</code></td>
<td>
<p>A <code>double</code>.</p>
</td></tr>
<tr><td><code id="PLP_+3A_d">d</code></td>
<td>
<p>A <code>double</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An S3 object containing the specified ts.model with the following structure:
</p>

<dl>
<dt>process.desc</dt><dd><p>Used in summary: &quot;SIGMA2&quot;,&quot;d&quot;</p>
</dd>
<dt>theta</dt><dd><p>Parameter vector including <code class="reqn">\sigma^2</code>, <code class="reqn">d</code></p>
</dd>
<dt>plength</dt><dd><p>Number of parameters</p>
</dd>
<dt>print</dt><dd><p>String containing simplified model</p>
</dd>
<dt>desc</dt><dd><p>&quot;PLP&quot;</p>
</dd>
<dt>obj.desc</dt><dd><p>Depth of Parameters e.g. list(1,1)</p>
</dd>
<dt>starting</dt><dd><p>Find starting values? TRUE or FALSE (e.g. specified value)</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Lionel Voirol,  Davide Cucci
</p>


<h3>Examples</h3>

<pre><code class='language-R'>PLP()
PLP(sigma2 = 1, d = 0.4)
</code></pre>

<hr>
<h2 id='predict.fitsimts'>Time Series Prediction</h2><span id='topic+predict.fitsimts'></span>

<h3>Description</h3>

<p>This function plots the time series forecast.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fitsimts'
predict(
  object,
  n.ahead = 10,
  show_last = 100,
  level = NULL,
  xlab = NULL,
  ylab = NULL,
  main = NULL,
  plot = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.fitsimts_+3A_object">object</code></td>
<td>
<p>A <code>fitsimts</code> object obtained from <code>estimate</code> function.</p>
</td></tr>
<tr><td><code id="predict.fitsimts_+3A_n.ahead">n.ahead</code></td>
<td>
<p>An <code>integer</code> indicating number of units of time ahead for which to make forecasts.</p>
</td></tr>
<tr><td><code id="predict.fitsimts_+3A_show_last">show_last</code></td>
<td>
<p>A <code>integer</code> indicating the number of last observations to show in the forecast plot.</p>
</td></tr>
<tr><td><code id="predict.fitsimts_+3A_level">level</code></td>
<td>
<p>A <code>double</code> or <code>vector</code> indicating confidence level of prediction interval.
By default, it uses the levels of 0.50 and 0.95.</p>
</td></tr>
<tr><td><code id="predict.fitsimts_+3A_xlab">xlab</code></td>
<td>
<p>A <code>string</code> for the title of x axis.</p>
</td></tr>
<tr><td><code id="predict.fitsimts_+3A_ylab">ylab</code></td>
<td>
<p>A <code>string</code> for the title of y axis.</p>
</td></tr>
<tr><td><code id="predict.fitsimts_+3A_main">main</code></td>
<td>
<p>A <code>string</code> for the over all title of the plot.</p>
</td></tr>
<tr><td><code id="predict.fitsimts_+3A_plot">plot</code></td>
<td>
<p>A <code>logical</code> value. logical. If <code>TRUE</code>(the default) the predictions are plotted.</p>
</td></tr>
<tr><td><code id="predict.fitsimts_+3A_...">...</code></td>
<td>
<p>Additional arguments.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Stéphane Guerrier and Yuming Zhang
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Xt = gen_gts(300, AR(phi = c(0, 0, 0.8), sigma2 = 1))
model = estimate(AR(3), Xt)
predict(model)
predict(model, level = 0.95)

x = gts(as.vector(lynx), start = 1821, end = 1934, freq = 1, 
unit_ts = bquote(paste(10^8," ",m^3)), name_ts = "Numbers", 
unit_time = "year", data_name = "Annual Numbers of Lynx Trappings")
model = estimate(AR(1), x)
predict(model, n.ahead = 20)
predict(model, n.ahead = 20, level = 0.95)
predict(model, n.ahead = 20, level = c(0.50, 0.80, 0.95))

</code></pre>

<hr>
<h2 id='predict.gmwm'>Predict future points in the time series using the solution of the
Generalized Method of Wavelet Moments</h2><span id='topic+predict.gmwm'></span>

<h3>Description</h3>

<p>Creates a prediction using the estimated values of GMWM through the
ARIMA function within R.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gmwm'
predict(object, data.in.gmwm, n.ahead = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.gmwm_+3A_object">object</code></td>
<td>
<p>A <code>gmwm</code> object</p>
</td></tr>
<tr><td><code id="predict.gmwm_+3A_data.in.gmwm">data.in.gmwm</code></td>
<td>
<p>The data SAME EXACT DATA used in the GMWM estimation</p>
</td></tr>
<tr><td><code id="predict.gmwm_+3A_n.ahead">n.ahead</code></td>
<td>
<p>Number of observations to forecast</p>
</td></tr>
<tr><td><code id="predict.gmwm_+3A_...">...</code></td>
<td>
<p>Additional parameters passed to ARIMA Predict</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>predict.gmwm</code> object with:
</p>

<ul>
<li><p>predPredictions
</p>
</li>
<li><p>seStandard Errors
</p>
</li>
<li><p>residResiduals from ARIMA ML Fit
</p>
</li></ul>


<hr>
<h2 id='print.fitsimts'>Print fitsimts object</h2><span id='topic+print.fitsimts'></span>

<h3>Description</h3>

<p>This function displays the information of a fitsimts object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fitsimts'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.fitsimts_+3A_x">x</code></td>
<td>
<p>A <code>fitsimts</code> object</p>
</td></tr>
<tr><td><code id="print.fitsimts_+3A_...">...</code></td>
<td>
<p>Other arguments passed to specific methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Text output via print
</p>


<h3>Author(s)</h3>

<p>Stéphane Guerrier and Yuming Zhang
</p>

<hr>
<h2 id='print.gmwm'>Print gmwm object</h2><span id='topic+print.gmwm'></span>

<h3>Description</h3>

<p>Displays information about GMWM object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gmwm'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.gmwm_+3A_x">x</code></td>
<td>
<p>A <code>GMWM</code> object</p>
</td></tr>
<tr><td><code id="print.gmwm_+3A_...">...</code></td>
<td>
<p>Other arguments passed to specific methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Text output via print
</p>


<h3>Author(s)</h3>

<p>JJB
</p>

<hr>
<h2 id='print.imu'>Print simts Objects</h2><span id='topic+print.imu'></span><span id='topic+print.lts'></span><span id='topic+print.gts'></span><span id='topic+outf'></span>

<h3>Description</h3>

<p>Pretty formatting for <code>gts</code>, <code>imu</code>, and <code>lts</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'imu'
print(x, obs = 10L, row.names = TRUE, ...)

## S3 method for class 'lts'
print(x, obs = 10L, row.names = TRUE, ...)

## S3 method for class 'gts'
print(x, obs = 10L, row.names = TRUE, ...)

outf(x, obs = 10L, row.names = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.imu_+3A_x">x</code></td>
<td>
<p>A <code>gts</code>, <code>imu</code>, <code>lts</code> object.</p>
</td></tr>
<tr><td><code id="print.imu_+3A_obs">obs</code></td>
<td>
<p>A <code>integer</code> the specifies how many from the beginning and end of the data set to show.</p>
</td></tr>
<tr><td><code id="print.imu_+3A_row.names">row.names</code></td>
<td>
<p>A <code>boolean</code> that indicates whether row names should be displayed or surpressed.</p>
</td></tr>
<tr><td><code id="print.imu_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>logical</code> value that indicates whether the object is of that class (TRUE) or not (FALSE).
</p>


<h3>Author(s)</h3>

<p>James Balamuta
</p>

<hr>
<h2 id='print.summary.gmwm'>Print summary.gmwm object</h2><span id='topic+print.summary.gmwm'></span>

<h3>Description</h3>

<p>Displays summary information about GMWM object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'summary.gmwm'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.summary.gmwm_+3A_x">x</code></td>
<td>
<p>A <code>GMWM</code> object</p>
</td></tr>
<tr><td><code id="print.summary.gmwm_+3A_...">...</code></td>
<td>
<p>Other arguments passed to specific methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Text output via print
</p>


<h3>Author(s)</h3>

<p>JJB
</p>

<hr>
<h2 id='print.ts.model'>Multiply a ts.model by constant</h2><span id='topic+print.ts.model'></span>

<h3>Description</h3>

<p>Sets up the necessary backend for creating multiple model objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ts.model'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.ts.model_+3A_x">x</code></td>
<td>
<p>A <code>numeric</code> value</p>
</td></tr>
<tr><td><code id="print.ts.model_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An S3 object with called ts.model with the following structure:
</p>

<ul>
<li><p>desc
</p>
</li>
<li><p>theta
</p>
</li></ul>



<h3>Author(s)</h3>

<p>James Balamuta
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Creates a parameter space for guessing
QN() + DR() + WN() + RW() + AR1() + ARMA(1,2)

# Creates a user-specified starting value model
AR1(phi = .9, sigma2 = .1) + WN(sigma2 = 1) 

# Similarly, with the addition of a generic ARMA
RW(gamma2 = .3) + DR(omega = .5) + QN(q2 = .9) + ARMA(ar = c(.3,.1), ma = c(.3,.2), sigma2 = .99)

# In a similar vein, this example highlights the lack of need for specifying parameters. 
AR1(.9,.1) + WN(1) + RW(.3) + DR(.5) + QN(.9) + ARMA(c(.3,.1), c(.3,.2), .99)
</code></pre>

<hr>
<h2 id='pseudo_logit'>Pseudo Logit Function</h2><span id='topic+pseudo_logit'></span>

<h3>Description</h3>

<p>This function compute the link function to constrain parameters to a positive domain.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pseudo_logit(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pseudo_logit_+3A_x">x</code></td>
<td>
<p>A <code>vec</code> containing probabilities (e.g. 0 &lt;= x &lt;= 1)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>vec</code> containing logit terms.
</p>


<h3>Author(s)</h3>

<p>James Joseph Balamuta (JJB)
</p>

<hr>
<h2 id='pseudo_logit_inv'>Pseudo Logit Inverse Function</h2><span id='topic+pseudo_logit_inv'></span>

<h3>Description</h3>

<p>This function computes the pseudo inverse of a logit transformation of the parameters in order to constrain them to a positive domain
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pseudo_logit_inv(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pseudo_logit_inv_+3A_x">x</code></td>
<td>
<p>A <code>vec</code> containing real numbers.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>vec</code> containing logit probabilities.
</p>


<h3>Author(s)</h3>

<p>James Joseph Balamuta (JJB)
</p>

<hr>
<h2 id='qmf'>Quadrature Mirror Filter</h2><span id='topic+qmf'></span>

<h3>Description</h3>

<p>Calculate the series quadrature mirror filter (QMF). Requires a series of an even length.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qmf(g, inverse)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="qmf_+3A_g">g</code></td>
<td>
<p>A <code>vector</code> that contains the filter constants.</p>
</td></tr>
<tr><td><code id="qmf_+3A_inverse">inverse</code></td>
<td>
<p>A <code>bool</code> that indicates whether the inverse quadrature mirror filter is computed. 
By default, the inverse quadrature mirror is computed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>vector</code> that contains either the forward QMF (evalute in order) or the inverse QMF (reverse order).
</p>


<h3>Author(s)</h3>

<p>JJB
</p>

<hr>
<h2 id='QN'>Create an Quantisation Noise (QN) Process</h2><span id='topic+QN'></span>

<h3>Description</h3>

<p>Sets up the necessary backend for the QN process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>QN(q2 = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="QN_+3A_q2">q2</code></td>
<td>
<p>A <code>double</code> value for the <code class="reqn">Q^2</code> of a QN process.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An S3 object with called ts.model with the following structure:
</p>

<dl>
<dt>process.desc</dt><dd><p>Used in summary: &quot;QN&quot;</p>
</dd>
<dt>theta</dt><dd><p><code class="reqn">Q^2</code></p>
</dd>
<dt>plength</dt><dd><p>Number of parameters</p>
</dd>
<dt>print</dt><dd><p>String containing simplified model</p>
</dd>
<dt>desc</dt><dd><p>y desc replicated x times</p>
</dd>
<dt>obj.desc</dt><dd><p>Depth of parameters e.g. list(1)</p>
</dd>
<dt>starting</dt><dd><p>Guess starting values? TRUE or FALSE (e.g. specified value)</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>James Balamuta
</p>


<h3>Examples</h3>

<pre><code class='language-R'>QN()
QN(q2=3.4)
</code></pre>

<hr>
<h2 id='qn_to_wv'>Quantisation Noise (QN) to WV</h2><span id='topic+qn_to_wv'></span>

<h3>Description</h3>

<p>This function compute the Haar WV of a Quantisation Noise (QN) process
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qn_to_wv(q2, tau)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="qn_to_wv_+3A_q2">q2</code></td>
<td>
<p>A <code>double</code> corresponding to variance of drift</p>
</td></tr>
<tr><td><code id="qn_to_wv_+3A_tau">tau</code></td>
<td>
<p>A <code>vec</code> containing the scales e.g. <code class="reqn">2^{\tau}</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>vec</code> containing the wavelet variance of the QN.
</p>


<h3>Process Haar Wavelet Variance Formula</h3>

<p>The Quantization Noise (QN) process has a Haar Wavelet Variance given by:
</p>
<p style="text-align: center;"><code class="reqn">\nu _j^2\left( {{Q^2}} \right) = \frac{{6{Q^2}}}{{\tau _j^2}}</code>
</p>


<hr>
<h2 id='quantile_cpp'>Find Quantiles</h2><span id='topic+quantile_cpp'></span>

<h3>Description</h3>

<p>Attempts to find quantiles
</p>


<h3>Usage</h3>

<pre><code class='language-R'>quantile_cpp(x, probs)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="quantile_cpp_+3A_x">x</code></td>
<td>
<p>A <code>vec</code> of data</p>
</td></tr>
<tr><td><code id="quantile_cpp_+3A_probs">probs</code></td>
<td>
<p>A <code>vec</code> of the quantiles to find.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>vector</code> containing the quantiles
</p>


<h3>Author(s)</h3>

<p>James J Balamuta
</p>

<hr>
<h2 id='rank_models_cpp'>Find the Rank Models result</h2><span id='topic+rank_models_cpp'></span>

<h3>Description</h3>

<p>Provides the core material to create an S3 object for rank.models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rank_models_cpp(
  data,
  model_str,
  full_model,
  alpha,
  compute_v,
  model_type,
  K,
  H,
  G,
  robust,
  eff,
  bs_optimism,
  seed
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rank_models_cpp_+3A_data">data</code></td>
<td>
<p>A <code>vec</code> of data.</p>
</td></tr>
<tr><td><code id="rank_models_cpp_+3A_model_str">model_str</code></td>
<td>
<p>A <code>vector&lt;vector&lt;string&gt;&gt;</code> that gives a list of models to test.</p>
</td></tr>
<tr><td><code id="rank_models_cpp_+3A_full_model">full_model</code></td>
<td>
<p>A <code>vector&lt;string&gt;</code> that contains the largest / full model.</p>
</td></tr>
<tr><td><code id="rank_models_cpp_+3A_alpha">alpha</code></td>
<td>
<p>A <code>double</code> that indicates the alpha level for CIs.</p>
</td></tr>
<tr><td><code id="rank_models_cpp_+3A_compute_v">compute_v</code></td>
<td>
<p>A <code>string</code> indicating the type of V matrix to generate</p>
</td></tr>
<tr><td><code id="rank_models_cpp_+3A_model_type">model_type</code></td>
<td>
<p>A <code>string</code> that describes the model generation / transformation: 'ssm' or 'imu'</p>
</td></tr>
<tr><td><code id="rank_models_cpp_+3A_k">K</code></td>
<td>
<p>A <code>int</code> that controls how many times the GMWM is run.</p>
</td></tr>
<tr><td><code id="rank_models_cpp_+3A_h">H</code></td>
<td>
<p>A <code>int</code> that controls how many bootstraps occur.</p>
</td></tr>
<tr><td><code id="rank_models_cpp_+3A_g">G</code></td>
<td>
<p>A <code>int</code> that controls how many guesses occur.</p>
</td></tr>
<tr><td><code id="rank_models_cpp_+3A_robust">robust</code></td>
<td>
<p>A <code>bool</code> that indicates whether to use classical or robust wavelet variance.</p>
</td></tr>
<tr><td><code id="rank_models_cpp_+3A_eff">eff</code></td>
<td>
<p>A <code>double</code> that indicates the efficiency to use.</p>
</td></tr>
<tr><td><code id="rank_models_cpp_+3A_bs_optimism">bs_optimism</code></td>
<td>
<p>A <code>bool</code> that indicates whether the model selection score should be calculated with bootstrap or asymptotics.</p>
</td></tr>
<tr><td><code id="rank_models_cpp_+3A_seed">seed</code></td>
<td>
<p>A <code>unsigned int</code> that is the seed one wishes to use.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>field&lt;field&lt;field&lt;mat&gt;&gt;&gt;</code> that contains the model score matrix and the best GMWM model object.
</p>

<hr>
<h2 id='Rcpp_ARIMA'>Hook into R's ARIMA function</h2><span id='topic+Rcpp_ARIMA'></span>

<h3>Description</h3>

<p>Uses R's ARIMA function to obtain CSS values for starting condition
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Rcpp_ARIMA(data, params)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Rcpp_ARIMA_+3A_data">data</code></td>
<td>
<p>A <code>vec</code> of data.</p>
</td></tr>
<tr><td><code id="Rcpp_ARIMA_+3A_params">params</code></td>
<td>
<p>A <code>vec</code> of the ARMA parameters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>vec</code> containing the CSS of the ARMA parameters.
</p>

<hr>
<h2 id='read_imu'>Read an IMU Binary File into R</h2><span id='topic+read_imu'></span>

<h3>Description</h3>

<p>The function will take a file location in addition to the type of sensor it
came from and read the data into R.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_imu(file_path, imu_type)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read_imu_+3A_file_path">file_path</code></td>
<td>
<p>A <code>string</code> that contains the full file path.</p>
</td></tr>
<tr><td><code id="read_imu_+3A_imu_type">imu_type</code></td>
<td>
<p>A <code>string</code> that contains a supported IMU type given below.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Currently supports the following IMUs:
</p>

<ul>
<li><p> IMAR
</p>
</li>
<li><p> LN200
</p>
</li>
<li><p> LN200IG
</p>
</li>
<li><p> IXSEA
</p>
</li>
<li><p> NAVCHIP_INT
</p>
</li>
<li><p> NAVCHIP_FLT
</p>
</li></ul>

<p>We hope to soon be able to support delimited files.
</p>


<h3>Value</h3>

<p>A matrix with dimensions N x 7, where the columns represent:
</p>

<dl>
<dt>Col 0</dt><dd><p>Time</p>
</dd>
<dt>Col 1</dt><dd><p>Gyro 1</p>
</dd>
<dt>Col 2</dt><dd><p>Gyro 2</p>
</dd>
<dt>Col 3</dt><dd><p>Gyro 3</p>
</dd>
<dt>Col 4</dt><dd><p>Accel 1</p>
</dd>
<dt>Col 5</dt><dd><p>Accel 2</p>
</dd>
<dt>Col 6</dt><dd><p>Accel 3</p>
</dd>
</dl>



<h3>References</h3>

<p>Thanks goes to Philipp Clausen of Labo TOPO, EPFL, Switzerland, topo.epfl.ch, Tel:+41(0)21 693 27 55
for providing a matlab function that reads in IMUs.
The function below is a heavily modified port of MATLAB code into Armadillo/C++.
</p>

<hr>
<h2 id='read.imu'>Read an IMU Binary File into R</h2><span id='topic+read.imu'></span>

<h3>Description</h3>

<p>Process binary files within the
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.imu(file, type, unit = NULL, name = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read.imu_+3A_file">file</code></td>
<td>
<p>A <code>string</code> containing file names or paths.</p>
</td></tr>
<tr><td><code id="read.imu_+3A_type">type</code></td>
<td>
<p>A <code>string</code> that contains a supported IMU type given below.</p>
</td></tr>
<tr><td><code id="read.imu_+3A_unit">unit</code></td>
<td>
<p>A <code>string</code> that contains the unit expression of the frequency. Default value is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="read.imu_+3A_name">name</code></td>
<td>
<p>A <code>string</code> that provides an identifier to the data. Default value is <code>NULL</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Currently supports the following IMUs:
</p>

<ul>
<li><p> IMAR
</p>
</li>
<li><p> LN200
</p>
</li>
<li><p> LN200IG
</p>
</li>
<li><p> IXSEA
</p>
</li>
<li><p> NAVCHIP_INT
</p>
</li>
<li><p> NAVCHIP_FLT
</p>
</li></ul>



<h3>Value</h3>

<p>An <code>imu</code> object that contains 3 gyroscopes and 3 accelerometers in that order.
</p>


<h3>Author(s)</h3>

<p>James Balamuta
We hope to soon be able to support delimited files.
</p>


<h3>References</h3>

<p>Thanks goes to Philipp Clausen of Labo TOPO, EPFL, Switzerland, topo.epfl.ch, Tel:+41(0)21 693 27 55
for providing a matlab function that reads in IMUs.
This function is a heavily modified port of MATLAB code into Armadillo/C++.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Relative
setwd("F:/")

a = read.imu(file = "Documents/James/short_test_data.imu", type = "IXSEA")

# Fixed path
b = read.imu(file = "F:/Desktop/short_test_data.imu", type = "IXSEA")

## End(Not run)
</code></pre>

<hr>
<h2 id='resid_plot'>Plot the Distribution of (Standardized) Residuals</h2><span id='topic+resid_plot'></span>

<h3>Description</h3>

<p>This function plots a histogram (with kernel density function and normal distribution) of the standardized
residuals or a basic plot the (standardized) residuals, or both.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>resid_plot(res, std = FALSE, type = "hist", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="resid_plot_+3A_res">res</code></td>
<td>
<p>A <code>vector</code> of residuals.</p>
</td></tr>
<tr><td><code id="resid_plot_+3A_std">std</code></td>
<td>
<p>A <code>boolean</code> indicating whether the residuals plot is for standardized
residuals or original residuals.</p>
</td></tr>
<tr><td><code id="resid_plot_+3A_type">type</code></td>
<td>
<p>A <code>string</code> indicating either:
<code>"hist"</code> (standardized residual histogram with superimposed kernel density estimator and normal distribution), <code>"resid"</code> (standard residual plot),
or <code>"both"</code></p>
</td></tr>
<tr><td><code id="resid_plot_+3A_...">...</code></td>
<td>
<p>Additional parameters</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Yuming Zhang
</p>

<hr>
<h2 id='rev_col_subset'>Reverse Subset Column</h2><span id='topic+rev_col_subset'></span>

<h3>Description</h3>

<p>Subsets the column by going from high indices to low (the reverse of the supported practice)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rev_col_subset(x, start, end)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rev_col_subset_+3A_x">x</code></td>
<td>
<p>A <code>matrix</code> of dimensions M x N</p>
</td></tr>
<tr><td><code id="rev_col_subset_+3A_start">start</code></td>
<td>
<p>A <code>unsigned int</code> that indicates the starting column.</p>
</td></tr>
<tr><td><code id="rev_col_subset_+3A_end">end</code></td>
<td>
<p>A <code>unsigned int</code> that indicates the ending column.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Consider a vector x=[[1,2],[3,4]].
By setting <code>start=1</code> and <code>end=0</code>, the function would output x=[[2,1],[4,1]].
Start and end must be valid C++ matrix locations. (e.g. matrix cols start at 0 and not 1)
</p>


<h3>Value</h3>

<p>x A <code>matrix</code> with matrix rows displayed in reverse order
</p>


<h3>Author(s)</h3>

<p>JJB
</p>

<hr>
<h2 id='rev_row_subset'>Reverse Subset Row</h2><span id='topic+rev_row_subset'></span>

<h3>Description</h3>

<p>Subsets the row by going from high indices to low (the reverse of the supported practice)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rev_row_subset(x, start, end)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rev_row_subset_+3A_x">x</code></td>
<td>
<p>A <code>matrix</code> of dimensions M x N</p>
</td></tr>
<tr><td><code id="rev_row_subset_+3A_start">start</code></td>
<td>
<p>A <code>unsigned int</code> that indicates the starting row.</p>
</td></tr>
<tr><td><code id="rev_row_subset_+3A_end">end</code></td>
<td>
<p>A <code>unsigned int</code> that indicates the ending row.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Consider a vector x=[[1,2],[3,4]], the function would output x=[[3,4],[1,2]].
Start and end must be valid C++ matrix locations. (e.g. matrix rows start at 0 and not 1)
</p>


<h3>Value</h3>

<p>x A <code>matrix</code> with matrix rows displayed in reversed order
</p>


<h3>Author(s)</h3>

<p>JJB
</p>

<hr>
<h2 id='reverse_vec'>Reverse Armadillo Vector</h2><span id='topic+reverse_vec'></span>

<h3>Description</h3>

<p>Reverses the order of an Armadillo Vector
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reverse_vec(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reverse_vec_+3A_x">x</code></td>
<td>
<p>A <code>column vector</code> of length N</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Consider a vector x=[1,2,3,4,5], the function would output x=[5,4,3,2,1].
</p>


<h3>Value</h3>

<p>x A <code>column vector</code> with its contents reversed.
</p>


<h3>Author(s)</h3>

<p>JJB
</p>

<hr>
<h2 id='rfilter'>Time Series Recursive Filters</h2><span id='topic+rfilter'></span>

<h3>Description</h3>

<p>Applies a recursive filter to a univariate time series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rfilter(x, filter, init)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rfilter_+3A_x">x</code></td>
<td>
<p>A <code>column vector</code> of length T</p>
</td></tr>
<tr><td><code id="rfilter_+3A_filter">filter</code></td>
<td>
<p>A <code>column vector</code> of length f</p>
</td></tr>
<tr><td><code id="rfilter_+3A_init">init</code></td>
<td>
<p>A <code>column vector</code> of length f that contains the initial values of the time series in reverse.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note: The length of 'init' must be equal to the length of 'filter'.
This is a port of the rfilter function harnessed by the filter function in stats. 
It is about 6-7 times faster than R's base function. The benchmark was done on iMac Late 2013 using vecLib as the BLAS.
</p>


<h3>Value</h3>

<p>x A <code>column vector</code> with its contents reversed.
</p>


<h3>Author(s)</h3>

<p>JJB
</p>

<hr>
<h2 id='rgmwm'>GMWM for Robust/Classical Comparison</h2><span id='topic+rgmwm'></span>

<h3>Description</h3>

<p>Creates a <code>rgmwm</code> object to compare the results generated by robust/classical method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rgmwm(model, data, eff = c(0.9, 0.8, 0.6), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rgmwm_+3A_model">model</code></td>
<td>
<p>A <code>ts.model</code> object containing one of the allowed models.</p>
</td></tr>
<tr><td><code id="rgmwm_+3A_data">data</code></td>
<td>
<p>A <code>matrix</code> or <code>data.frame</code> object with only one column (e.g. <code class="reqn">N \times 1</code>), or a <code>lts</code> object, or a <code>gts</code> object.</p>
</td></tr>
<tr><td><code id="rgmwm_+3A_eff">eff</code></td>
<td>
<p>A <code>double vector</code> between 0 and 1 that indicates the efficiency.</p>
</td></tr>
<tr><td><code id="rgmwm_+3A_...">...</code></td>
<td>
<p>Other arguments passed to the main <code>gmwm</code> function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>By default, the <code>rgmwm</code> function will fit a classical <code>gmwm</code>
object. From there, the user has the ability to specify any <code>eff</code> that is
less than or equal to 0.99.
</p>


<h3>Value</h3>

<p>A <code>rgmwm</code> object
</p>

<hr>
<h2 id='rtruncated_normal'>Truncated Normal Distribution Sampling Algorithm</h2><span id='topic+rtruncated_normal'></span>

<h3>Description</h3>

<p>Enables sampling from a truncated normal
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rtruncated_normal(n, mu, sigma, a, b)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rtruncated_normal_+3A_n">n</code></td>
<td>
<p>An <code>unsigned int</code> indicating the number of observations to generate.</p>
</td></tr>
<tr><td><code id="rtruncated_normal_+3A_mu">mu</code></td>
<td>
<p>A <code>double</code> indicating the mean of the normal.</p>
</td></tr>
<tr><td><code id="rtruncated_normal_+3A_sigma">sigma</code></td>
<td>
<p>A <code>double</code> indicating the standard deviation of the normal.</p>
</td></tr>
<tr><td><code id="rtruncated_normal_+3A_a">a</code></td>
<td>
<p>A <code>double</code> that is the lower bound of the truncated normal.</p>
</td></tr>
<tr><td><code id="rtruncated_normal_+3A_b">b</code></td>
<td>
<p>A <code>double</code> that is the upper bound of the truncated normal.</p>
</td></tr>
</table>

<hr>
<h2 id='RW'>Create an Random Walk (RW) Process</h2><span id='topic+RW'></span>

<h3>Description</h3>

<p>Sets up the necessary backend for the RW process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RW(gamma2 = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RW_+3A_gamma2">gamma2</code></td>
<td>
<p>A <code>double</code> value for the variance <code class="reqn">\gamma ^2</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>An S3 object with called ts.model with the following structure:
</p>

<dl>
<dt>process.desc</dt><dd><p>Used in summary: &quot;RW&quot;</p>
</dd>
<dt>theta</dt><dd><p><code class="reqn">\sigma</code></p>
</dd>
<dt>plength</dt><dd><p>Number of parameters</p>
</dd>
<dt>print</dt><dd><p>String containing simplified model</p>
</dd>
<dt>desc</dt><dd><p>y desc replicated x times</p>
</dd>
<dt>obj.desc</dt><dd><p>Depth of parameters e.g. list(1)</p>
</dd>
<dt>starting</dt><dd><p>Guess starting values? TRUE or FALSE (e.g. specified value)</p>
</dd>
</dl>



<h3>Note</h3>

<p>We consider the following model: </p>
<p style="text-align: center;"><code class="reqn">Y_t = \sum\nolimits_{t=0}^{T} \gamma_0*Z_t</code>
</p>
<p> where <code class="reqn">Z_t</code> is iid 
and follows a standard normal distribution.
</p>


<h3>Author(s)</h3>

<p>James Balamuta
</p>


<h3>Examples</h3>

<pre><code class='language-R'>RW()
RW(gamma2=3.4)
</code></pre>

<hr>
<h2 id='rw_to_wv'>Random Walk to WV</h2><span id='topic+rw_to_wv'></span>

<h3>Description</h3>

<p>This function compute the WV (haar) of a Random Walk process
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rw_to_wv(gamma2, tau)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rw_to_wv_+3A_gamma2">gamma2</code></td>
<td>
<p>A <code>double</code> corresponding to variance of RW</p>
</td></tr>
<tr><td><code id="rw_to_wv_+3A_tau">tau</code></td>
<td>
<p>A <code>vec</code> containing the scales e.g. <code class="reqn">2^{\tau}</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>vec</code> containing the wavelet variance of the random walk.
</p>


<h3>Process Haar Wavelet Variance Formula</h3>

<p>The Random Walk (RW) process has a Haar Wavelet Variance given by:
</p>
<p style="text-align: center;"><code class="reqn">\nu _j^2\left( {{\gamma ^2}} \right) = \frac{{\left( {\tau _j^2 + 2} \right){\gamma ^2}}}{{12{\tau _j}}} </code>
</p>


<hr>
<h2 id='RW2dimension'>Function to Compute Direction Random Walk Moves</h2><span id='topic+RW2dimension'></span>

<h3>Description</h3>

<p>The RW2dimension function computes direction random walk moves.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RW2dimension(steps = 100, probs = c(0.25, 0.5, 0.75))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RW2dimension_+3A_steps">steps</code></td>
<td>
<p>An <code>integer</code> that counts the number of steps of the random walk.</p>
</td></tr>
<tr><td><code id="RW2dimension_+3A_probs">probs</code></td>
<td>
<p>A <code>vector</code> of <code>double</code> that specifies the probabilities to choose each direction.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Stéphane Guerrier
</p>


<h3>Examples</h3>

<pre><code class='language-R'>RW2dimension(steps = 50, probs = c(0.2, 0.5, 0.6))
</code></pre>

<hr>
<h2 id='SARIMA'>Create a Seasonal Autoregressive Integrated Moving Average (SARIMA) Process</h2><span id='topic+SARIMA'></span>

<h3>Description</h3>

<p>Sets up the necessary backend for the SARIMA process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SARIMA(ar = 1, i = 0, ma = 1, sar = 1, si = 0, sma = 1, s = 12, sigma2 = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SARIMA_+3A_ar">ar</code></td>
<td>
<p>A <code>vector</code> or <code>integer</code> containing either the coefficients for <code class="reqn">\phi</code>'s or the process number <code class="reqn">p</code> for the Autoregressive (AR) term.</p>
</td></tr>
<tr><td><code id="SARIMA_+3A_i">i</code></td>
<td>
<p>An <code>integer</code> containing the number of differences to be done.</p>
</td></tr>
<tr><td><code id="SARIMA_+3A_ma">ma</code></td>
<td>
<p>A <code>vector</code> or <code>integer</code> containing either the coefficients for <code class="reqn">\theta</code>'s or the process number <code class="reqn">q</code> for the Moving Average (MA) term.</p>
</td></tr>
<tr><td><code id="SARIMA_+3A_sar">sar</code></td>
<td>
<p>A <code>vector</code> or <code>integer</code> containing either the coefficients for <code class="reqn">\Phi</code>'s or the process number <code class="reqn">P</code> for the Seasonal Autoregressive (SAR) term.</p>
</td></tr>
<tr><td><code id="SARIMA_+3A_si">si</code></td>
<td>
<p>An <code>integer</code> containing the number of seasonal differences to be done.</p>
</td></tr>
<tr><td><code id="SARIMA_+3A_sma">sma</code></td>
<td>
<p>A <code>vector</code> or <code>integer</code> containing either the coefficients for <code class="reqn">\Theta</code>'s or the process number <code class="reqn">Q</code> for the Seasonal Moving Average (SMA) term.</p>
</td></tr>
<tr><td><code id="SARIMA_+3A_s">s</code></td>
<td>
<p>An <code>integer</code> containing the seasonality.</p>
</td></tr>
<tr><td><code id="SARIMA_+3A_sigma2">sigma2</code></td>
<td>
<p>A <code>double</code> value for the standard deviation, <code class="reqn">\sigma</code>, of the SARMA process.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A variance is required since the model generation statements utilize 
randomization functions expecting a variance instead of a standard deviation unlike R.
</p>


<h3>Value</h3>

<p>An S3 object with called ts.model with the following structure:
</p>

<dl>
<dt>process.desc</dt><dd><p><code class="reqn">AR*p</code>, <code class="reqn">MA*q</code>, <code class="reqn">SAR*P</code>, <code class="reqn">SMA*Q</code></p>
</dd>
<dt>theta</dt><dd><p><code class="reqn">\sigma</code></p>
</dd>
<dt>plength</dt><dd><p>Number of parameters</p>
</dd>
<dt>desc</dt><dd><p>Type of model</p>
</dd>
<dt>desc.simple</dt><dd><p>Type of model (after simplification)</p>
</dd>
<dt>print</dt><dd><p>String containing simplified model</p>
</dd>
<dt>obj.desc</dt><dd><p>y desc replicated x times</p>
</dd>
<dt>obj</dt><dd><p>Depth of Parameters e.g. list(c(length(ar), length(ma), length(sar), length(sma), 1, i, si) )</p>
</dd>
<dt>starting</dt><dd><p>Guess Starting values? TRUE or FALSE (e.g. specified value)</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>James Balamuta
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create an SARIMA(1,1,2)x(1,0,1) process
SARIMA(ar = 1, i = 1, ma = 2, sar = 1, si = 0, sma =1)

# Creates an SARMA(1,0,1)x(1,1,1) process with predefined coefficients.
SARIMA(ar=0.23, i = 0, ma=0.4, sar = .3,  sma = .3)
</code></pre>

<hr>
<h2 id='SARMA'>Create a Seasonal Autoregressive Moving Average (SARMA) Process</h2><span id='topic+SARMA'></span>

<h3>Description</h3>

<p>Sets up the necessary backend for the SARMA process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SARMA(ar = 1, ma = 1, sar = 1, sma = 1, s = 12, sigma2 = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SARMA_+3A_ar">ar</code></td>
<td>
<p>A <code>vector</code> or <code>integer</code> containing either the coefficients for <code class="reqn">\phi</code>'s or the process number <code class="reqn">p</code> for the Autoregressive (AR) term.</p>
</td></tr>
<tr><td><code id="SARMA_+3A_ma">ma</code></td>
<td>
<p>A <code>vector</code> or <code>integer</code> containing either the coefficients for <code class="reqn">\theta</code>'s or the process number <code class="reqn">q</code> for the Moving Average (MA) term.</p>
</td></tr>
<tr><td><code id="SARMA_+3A_sar">sar</code></td>
<td>
<p>A <code>vector</code> or <code>integer</code> containing either the coefficients for <code class="reqn">\Phi</code>'s or the process number <code class="reqn">P</code> for the Seasonal Autoregressive (SAR) term.</p>
</td></tr>
<tr><td><code id="SARMA_+3A_sma">sma</code></td>
<td>
<p>A <code>vector</code> or <code>integer</code> containing either the coefficients for <code class="reqn">\Theta</code>'s or the process number <code class="reqn">Q</code> for the Seasonal Moving Average (SMA) term.</p>
</td></tr>
<tr><td><code id="SARMA_+3A_s">s</code></td>
<td>
<p>A <code>integer</code> indicating the seasonal value of the data.</p>
</td></tr>
<tr><td><code id="SARMA_+3A_sigma2">sigma2</code></td>
<td>
<p>A <code>double</code> value for the standard deviation, <code class="reqn">\sigma</code>, of the SARMA process.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A variance is required since the model generation statements utilize 
randomization functions expecting a variance instead of a standard deviation unlike R.
</p>


<h3>Value</h3>

<p>An S3 object with called ts.model with the following structure:
</p>

<dl>
<dt>process.desc</dt><dd><p><code class="reqn">AR*p</code>, <code class="reqn">MA*q</code>, <code class="reqn">SAR*P</code>, <code class="reqn">SMA*Q</code></p>
</dd>
<dt>theta</dt><dd><p><code class="reqn">\sigma</code></p>
</dd>
<dt>plength</dt><dd><p>Number of Parameters</p>
</dd>
<dt>print</dt><dd><p>String containing simplified model</p>
</dd>
<dt>obj.desc</dt><dd><p>y desc replicated x times</p>
</dd>
<dt>obj</dt><dd><p>Depth of Parameters e.g. list(c(length(ar), length(ma), length(sar), length(sma), 1) )</p>
</dd>
<dt>starting</dt><dd><p>Guess Starting values? TRUE or FALSE (e.g. specified value)</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>James Balamuta
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create an SARMA(1,2)x(1,1) process
SARMA(ar = 1, ma = 2,sar = 1, sma =1)

# Creates an SARMA(1,1)x(1,1) process with predefined coefficients.
SARMA(ar=0.23, ma=0.4, sar = .3, sma = .3)
</code></pre>

<hr>
<h2 id='sarma_calculate_spadding'>Calculates Length of Seasonal Padding</h2><span id='topic+sarma_calculate_spadding'></span>

<h3>Description</h3>

<p>Computes the total phi and total theta vector length.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sarma_calculate_spadding(np, nq, nsp, nsq, ns)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sarma_calculate_spadding_+3A_np">np</code></td>
<td>
<p>An <code>unsigned int</code> containing the number of non-seasonal phi parameters.</p>
</td></tr>
<tr><td><code id="sarma_calculate_spadding_+3A_nq">nq</code></td>
<td>
<p>An <code>unsigned int</code> containing the number of non-seasonal theta parameters.</p>
</td></tr>
<tr><td><code id="sarma_calculate_spadding_+3A_nsp">nsp</code></td>
<td>
<p>An <code>unsigned int</code> containing the number of seasonal phi parameters.</p>
</td></tr>
<tr><td><code id="sarma_calculate_spadding_+3A_nsq">nsq</code></td>
<td>
<p>An <code>unsigned int</code> containing the number of seasonal theta parameters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>vec</code> with rows:
</p>

<dl>
<dt>p</dt><dd><p>Number of phi parameters</p>
</dd>
<dt>q</dt><dd><p>Number of theta parameters</p>
</dd>
</dl>


<hr>
<h2 id='sarma_components'>Determine parameter expansion based upon objdesc</h2><span id='topic+sarma_components'></span>

<h3>Description</h3>

<p>Calculates the necessary vec space needed to pad the vectors
for seasonal terms.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sarma_components(objdesc)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sarma_components_+3A_objdesc">objdesc</code></td>
<td>
<p>A <code>vec</code> with the appropriate sarima object description</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>vec</code> with the structure:
</p>

<dl>
<dt>np</dt><dd><p>Number of Non-Seasonal AR Terms</p>
</dd>
<dt>nq</dt><dd><p>Number of Non-Seasonal MA Terms</p>
</dd>
<dt>nsp</dt><dd><p>Number of Seasonal AR Terms</p>
</dd>
<dt>nsq</dt><dd><p>Number of Seasonal MA Terms</p>
</dd>
<dt>ns</dt><dd><p>Number of Seasons (e.g. 12 is year)</p>
</dd>
<dt>p</dt><dd><p>Total number of phi terms</p>
</dd>
<dt>q</dt><dd><p>Total number of theta terms</p>
</dd>
</dl>


<hr>
<h2 id='sarma_expand'>Expand Parameters for an SARMA object</h2><span id='topic+sarma_expand'></span>

<h3>Description</h3>

<p>Creates an expanded PHI and THETA vector for use in other objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sarma_expand(params, objdesc)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sarma_expand_+3A_params">params</code></td>
<td>
<p>A <code>vec</code> containing the theta values of the parameters.</p>
</td></tr>
<tr><td><code id="sarma_expand_+3A_objdesc">objdesc</code></td>
<td>
<p>A <code>vec</code> containing the model term information.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>objdesc</code> is assumed to have the structure of:
</p>

<ul>
<li><p> AR(p)
</p>
</li>
<li><p> MA(q)
</p>
</li>
<li><p> SAR(P)
</p>
</li>
<li><p> SMA(Q)
</p>
</li>
<li><p> Seasons
</p>
</li></ul>



<h3>Value</h3>

<p>A <code>field&lt;vec&gt;</code> of size two as follows:
</p>

<ul>
<li><p> AR    values
</p>
</li>
<li><p> THETA values
</p>
</li></ul>


<hr>
<h2 id='sarma_expand_unguided'>(Internal) Expand the SARMA Parameters</h2><span id='topic+sarma_expand_unguided'></span>

<h3>Description</h3>

<p>(Internal) Expand the SARMA Parameters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sarma_expand_unguided(params, np, nq, nsp, nsq, ns, p, q)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sarma_expand_unguided_+3A_params">params</code></td>
<td>
<p>A <code>vec</code> containing the theta values of the parameters.</p>
</td></tr>
<tr><td><code id="sarma_expand_unguided_+3A_np">np</code></td>
<td>
<p>An <code>unsigned int</code> containing the number of non-seasonal phi parameters.</p>
</td></tr>
<tr><td><code id="sarma_expand_unguided_+3A_nq">nq</code></td>
<td>
<p>An <code>unsigned int</code> containing the number of non-seasonal theta parameters.</p>
</td></tr>
<tr><td><code id="sarma_expand_unguided_+3A_nsp">nsp</code></td>
<td>
<p>An <code>unsigned int</code> containing the number of seasonal phi parameters.</p>
</td></tr>
<tr><td><code id="sarma_expand_unguided_+3A_nsq">nsq</code></td>
<td>
<p>An <code>unsigned int</code> containing the number of seasonal theta parameters.</p>
</td></tr>
<tr><td><code id="sarma_expand_unguided_+3A_p">p</code></td>
<td>
<p>An <code>unsigned int</code> that is the total size of the phi vector.</p>
</td></tr>
<tr><td><code id="sarma_expand_unguided_+3A_q">q</code></td>
<td>
<p>An <code>unsigned int</code> that is the total size of the theta vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>field&lt;vec&gt;</code> that contains the expansion.
</p>

<hr>
<h2 id='sarma_params_construct'>Efficient way to merge items together</h2><span id='topic+sarma_params_construct'></span>

<h3>Description</h3>

<p>Efficient way to merge items together
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sarma_params_construct(ar, ma, sar, sma)
</code></pre>

<hr>
<h2 id='savingrt'>Personal Saving Rate</h2><span id='topic+savingrt'></span>

<h3>Description</h3>

<p>Personal saving as a percentage of disposable personal
income (DPI), frequently referred to as &quot;the personal saving rate,&quot;
is calculated as the ratio of personal saving to DPI.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>savingrt
</code></pre>


<h3>Format</h3>

<p>A gts time series object with frequency 12 starting at 1959 and going
to 2016 for a total of 691 observations.
</p>


<h3>Source</h3>

<p><a href="https://fred.stlouisfed.org/series/PSAVERT">https://fred.stlouisfed.org/series/PSAVERT</a>
</p>

<hr>
<h2 id='scales_cpp'>Computes the MODWT scales</h2><span id='topic+scales_cpp'></span>

<h3>Description</h3>

<p>Calculates the MODWT scales
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scales_cpp(nb_level)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scales_cpp_+3A_nb_level">nb_level</code></td>
<td>
<p>A <code>integer</code> that contains the level of decomposition J.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Used in wvar object.
</p>


<h3>Value</h3>

<p>A <code>vec</code> that contains 2^1, ... , 2^J
</p>

<hr>
<h2 id='select'>Time Series Model Selection</h2><span id='topic+select'></span>

<h3>Description</h3>

<p>This function performs model fitting and calculates the model selection criteria to be plotted.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>select(model, Xt, include.mean = TRUE, criterion = "aic", plot = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="select_+3A_model">model</code></td>
<td>
<p>A time series model (only ARIMA are currently supported).</p>
</td></tr>
<tr><td><code id="select_+3A_xt">Xt</code></td>
<td>
<p>A <code>vector</code> of time series data.</p>
</td></tr>
<tr><td><code id="select_+3A_include.mean">include.mean</code></td>
<td>
<p>A <code>boolean</code> indicating whether to fit ARIMA with the mean or not.</p>
</td></tr>
<tr><td><code id="select_+3A_criterion">criterion</code></td>
<td>
<p>A <code>string</code> indicating which model selection criterion should be used (possible values: <code>"aic"</code> (default), <code>"bic"</code>, <code>"hq"</code>).</p>
</td></tr>
<tr><td><code id="select_+3A_plot">plot</code></td>
<td>
<p>A <code>boolean</code> indicating whether a model selection plot is returned or not.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Stéphane Guerrier and Yuming Zhang
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(763)
Xt = gen_gts(100, AR(phi = c(0.2, -0.5, 0.4), sigma2 = 1))
select(AR(5), Xt, include.mean = FALSE)

Xt = gen_gts(100, MA(theta = c(0.2, -0.5, 0.4), sigma2 = 1))
select(MA(5), Xt, include.mean = FALSE)

Xt = gen_gts(500, ARMA(ar = 0.5, ma = c(0.5, -0.5, 0.4), sigma2 = 1))
select(ARMA(5,3), Xt, criterion = "hq", include.mean = FALSE)

</code></pre>

<hr>
<h2 id='select_arima'>Run Model Selection Criteria on ARIMA Models</h2><span id='topic+select_arima'></span><span id='topic+select_arma'></span><span id='topic+select_ar'></span><span id='topic+select_ma'></span>

<h3>Description</h3>

<p>This function performs model fitting and calculates the model selection criteria to be plotted or used in <code>best_model</code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>select_arima(
  xt,
  p.min = 0L,
  p.max = 3L,
  d = 0L,
  q.min = 0L,
  q.max = 3L,
  include.mean = TRUE,
  plot = TRUE
)

select_arma(
  xt,
  p.min = 0L,
  p.max = 3L,
  q.min = 0L,
  q.max = 3L,
  include.mean = TRUE,
  plot = TRUE
)

select_ar(xt, p.min = 0L, p.max = 3L, include.mean = TRUE, plot = TRUE)

select_ma(xt, q.min = 0L, q.max = 3L, include.mean = TRUE, plot = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="select_arima_+3A_xt">xt</code></td>
<td>
<p>A <code>vector</code> of univariate time series.</p>
</td></tr>
<tr><td><code id="select_arima_+3A_p.min">p.min</code></td>
<td>
<p>An <code>integer</code> indicating the lowest order of AR(p) process to search.</p>
</td></tr>
<tr><td><code id="select_arima_+3A_p.max">p.max</code></td>
<td>
<p>An <code>integer</code> indicating the highest order of AR(p) process to search.</p>
</td></tr>
<tr><td><code id="select_arima_+3A_d">d</code></td>
<td>
<p>An <code>integer</code> indicating the differencing order for the data.</p>
</td></tr>
<tr><td><code id="select_arima_+3A_q.min">q.min</code></td>
<td>
<p>An <code>integer</code> indicating the lowest order of MA(q) process to search.</p>
</td></tr>
<tr><td><code id="select_arima_+3A_q.max">q.max</code></td>
<td>
<p>An <code>integer</code> indicating the highest order of MA(q) process to search.</p>
</td></tr>
<tr><td><code id="select_arima_+3A_include.mean">include.mean</code></td>
<td>
<p>A <code>bool</code> indicating whether to fit ARIMA with the mean or not.</p>
</td></tr>
<tr><td><code id="select_arima_+3A_plot">plot</code></td>
<td>
<p>A <code>logical</code>. If <code>TRUE</code> (the default) a plot should be produced.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>xt = gen_arima(N=100, ar=0.3, d=1, ma=0.3)
x = select_arima(xt, d=1L)

xt = gen_ma1(100, 0.3, 1)
x = select_ma(xt, q.min=2L, q.max=5L)
best_model(x)

xt = gen_arma(10, c(.4,.5), c(.1), 1, 0)  
x = select_arma(xt, p.min = 1L, p.max = 4L,
                q.min = 1L, q.max = 3L)
</code></pre>

<hr>
<h2 id='select_filter'>Select the Wavelet Filter</h2><span id='topic+select_filter'></span>

<h3>Description</h3>

<p>Constructs the wavelet filter to be used.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>select_filter(filter_name)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="select_filter_+3A_filter_name">filter_name</code></td>
<td>
<p>A <code>String</code> that must receive: <code>"haar"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The package is oriented toward using only the haar filter. If the package extends at a later time, then the supporting infrastructure is there.
</p>


<h3>Value</h3>

<p>info A <code>field&lt;vec&gt;</code> that contains:
</p>

<ul>
<li><p>&quot;L&quot;A <code>integer</code> specifying the length of the filter
</p>
</li>
<li><p>&quot;h&quot;A <code>vector</code> containing the coefficients for the wavelet filter
</p>
</li>
<li><p>&quot;g&quot;A <code>vector</code> containing the coefficients for the scaling filter
</p>
</li></ul>



<h3>Author(s)</h3>

<p>JJB
</p>

<hr>
<h2 id='seq_cpp'>Generate a sequence of values</h2><span id='topic+seq_cpp'></span>

<h3>Description</h3>

<p>Creates a vector containing a sequence of values starting at the initial point and going to the terminal point.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seq_cpp(a, b)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seq_cpp_+3A_a">a</code></td>
<td>
<p>An <code>int</code>, that denotes the starting point.</p>
</td></tr>
<tr><td><code id="seq_cpp_+3A_b">b</code></td>
<td>
<p>An <code>int</code>, that denotes the ending point.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>vector</code> containing values moving from a to b. There are no restrictions on A's range.
</p>


<h3>Author(s)</h3>

<p>James J Balamuta
</p>

<hr>
<h2 id='seq_len_cpp'>Generate a sequence of values based on supplied number</h2><span id='topic+seq_len_cpp'></span>

<h3>Description</h3>

<p>Creates a vector containing a sequence of values starting at 1 and going to the terminal point.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seq_len_cpp(n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seq_len_cpp_+3A_n">n</code></td>
<td>
<p>An <code>int</code> that denotes the length of the vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>vector</code> containing values moving from 1 to n.
</p>


<h3>Author(s)</h3>

<p>James J Balamuta
</p>

<hr>
<h2 id='set_seed'>Set the RNG Seed from within Rcpp</h2><span id='topic+set_seed'></span>

<h3>Description</h3>

<p>Within Rcpp, one can set the R session seed without triggering
the CRAN rng modifier check.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_seed(seed)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set_seed_+3A_seed">seed</code></td>
<td>
<p>A <code>unsigned int</code> that is the seed one wishes to use.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A set RNG scope.
</p>

<hr>
<h2 id='simple_diag_plot'>Basic Diagnostic Plot of Residuals</h2><span id='topic+simple_diag_plot'></span>

<h3>Description</h3>

<p>This function will plot four diagnostic plots to assess how well the model fits 
the data. These plots are: (1) residuals plot, (2) histogram of 
(standardized) residuals, (3) normal Q-Q plot of residuals and (4) residuals vs fitted values plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simple_diag_plot(Xt, model, std = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simple_diag_plot_+3A_xt">Xt</code></td>
<td>
<p>The original time series data.</p>
</td></tr>
<tr><td><code id="simple_diag_plot_+3A_model">model</code></td>
<td>
<p>The <code>arima</code> model fit to the data.</p>
</td></tr>
<tr><td><code id="simple_diag_plot_+3A_std">std</code></td>
<td>
<p>A <code>boolean</code> indicating whether we use standardized residuals for the 
(1) residuals plot and the (2) histogram of (standardized) residuals.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Yuming Zhang
</p>

<hr>
<h2 id='simplified_print_SARIMA'>Simplify and print SARIMA model</h2><span id='topic+simplified_print_SARIMA'></span>

<h3>Description</h3>

<p>Simplify and print SARIMA model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simplified_print_SARIMA(p, i, q, P, si, Q, s)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simplified_print_SARIMA_+3A_p">p</code></td>
<td>
<p>An <code>integer</code> denoting the length of <code>ar</code>.</p>
</td></tr>
<tr><td><code id="simplified_print_SARIMA_+3A_i">i</code></td>
<td>
<p>An <code>integer</code> containing the number of differences to be done.</p>
</td></tr>
<tr><td><code id="simplified_print_SARIMA_+3A_q">q</code></td>
<td>
<p>An <code>integer</code> denoting the length of <code>ma</code>.</p>
</td></tr>
<tr><td><code id="simplified_print_SARIMA_+3A_p">P</code></td>
<td>
<p>An <code>integer</code> denoting the length of <code>sma</code>.</p>
</td></tr>
<tr><td><code id="simplified_print_SARIMA_+3A_si">si</code></td>
<td>
<p>An <code>integer</code> containing the number of seasonal differences to be done.</p>
</td></tr>
<tr><td><code id="simplified_print_SARIMA_+3A_q">Q</code></td>
<td>
<p>An <code>integer</code> denoting the length of <code>sar</code>.</p>
</td></tr>
<tr><td><code id="simplified_print_SARIMA_+3A_s">s</code></td>
<td>
<p>An <code>integer</code> indicating the seasonal value of the data.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An S3 object with the following structure:
</p>

<dl>
<dt>print</dt><dd><p>String containing simplified model</p>
</dd>
<dt>simplified</dt><dd><p>Type of model (after simplification)</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Stephane Guerrier
</p>

<hr>
<h2 id='SIN'>Definition of a Sinusoidal (SIN) Process</h2><span id='topic+SIN'></span>

<h3>Description</h3>

<p>Definition of a Sinusoidal (SIN) Process
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SIN(alpha2 = 9e-04, beta = 0.06, U = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SIN_+3A_alpha2">alpha2</code></td>
<td>
<p>A <code>double</code> value for the squared amplitude parameter <code class="reqn">\alpha^2</code> (see Note for details).</p>
</td></tr>
<tr><td><code id="SIN_+3A_beta">beta</code></td>
<td>
<p>A <code>double</code> value for the angular frequency parameter <code class="reqn">\beta</code> (see Note for details).</p>
</td></tr>
<tr><td><code id="SIN_+3A_u">U</code></td>
<td>
<p>A <code>double</code> value for the phase parameter <code class="reqn">U</code> (see Note for details).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An S3 object containing the specified ts.model with the following structure:
</p>

<dl>
<dt>process.desc</dt><dd><p>Used in summary: &quot;ALPHA2&quot;,&quot;BETA&quot;</p>
</dd>
<dt>theta</dt><dd><p>Parameter vector including <code class="reqn">\alpha^2</code>, <code class="reqn">\beta</code></p>
</dd>
<dt>plength</dt><dd><p>Number of parameters</p>
</dd>
<dt>print</dt><dd><p>String containing simplified model</p>
</dd>
<dt>desc</dt><dd><p>&quot;SIN&quot;</p>
</dd>
<dt>obj.desc</dt><dd><p>Depth of Parameters e.g. list(1,1)</p>
</dd>
<dt>starting</dt><dd><p>Find starting values? TRUE or FALSE (e.g. specified value)</p>
</dd>
</dl>



<h3>Note</h3>

<p>We consider the following sinusoidal process : </p>
<p style="text-align: center;"><code class="reqn">X_t = \alpha \sin(\beta t + U)</code>
</p>
<p>, where <code class="reqn">U \sim \mathcal{U}(0, 2\pi)</code>
and <code class="reqn">\beta \in (0, \frac{\pi}{2})</code>
</p>


<h3>Author(s)</h3>

<p>Lionel Voirol
</p>


<h3>Examples</h3>

<pre><code class='language-R'>SIN()
SIN(alpha2 = .5, beta = .05)
</code></pre>

<hr>
<h2 id='sort_mat'>Sort Matrix by Column</h2><span id='topic+sort_mat'></span>

<h3>Description</h3>

<p>Sorts a given matrix by a specific column while retain the elements in each row.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sort_mat(x, col)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sort_mat_+3A_x">x</code></td>
<td>
<p>A <code>matrix</code> to sort</p>
</td></tr>
<tr><td><code id="sort_mat_+3A_col">col</code></td>
<td>
<p>A <code>int</code> that indicates the column the matrix should sort by.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The functional difference between armadillo's sort() and sort_mat() is straight forward.
sort() will sort each column without respect to the rows. 
Using sort_matrix will sort only 1 column and retain the other elements to be in the same row.
</p>


<h3>Value</h3>

<p>The matrix sorted by values in the specified column.
</p>

<hr>
<h2 id='sum_field_vec'>Accumulation of Armadillo field&lt;vec&gt;</h2><span id='topic+sum_field_vec'></span>

<h3>Description</h3>

<p>Sums vectors in a field into a single variable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sum_field_vec(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sum_field_vec_+3A_x">x</code></td>
<td>
<p>A <code>field&lt;vec&gt;</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code>mat</code> containing the field elements within a column.
</p>


<h3>Author(s)</h3>

<p>JJB
</p>

<hr>
<h2 id='summary.fitsimts'>Summary of fitsimts object</h2><span id='topic+summary.fitsimts'></span>

<h3>Description</h3>

<p>Displays summary information about fitsimts object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fitsimts'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.fitsimts_+3A_object">object</code></td>
<td>
<p>A <code>fitsimts</code> object</p>
</td></tr>
<tr><td><code id="summary.fitsimts_+3A_...">...</code></td>
<td>
<p>Other arguments passed to specific methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Estimated parameters values with confidence intervals and standard errors.
</p>


<h3>Author(s)</h3>

<p>Stéphane Guerrier
</p>

<hr>
<h2 id='summary.gmwm'>Summary of GMWM object</h2><span id='topic+summary.gmwm'></span>

<h3>Description</h3>

<p>Displays summary information about GMWM object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gmwm'
summary(
  object,
  inference = NULL,
  bs.gof = NULL,
  bs.gof.p.ci = NULL,
  bs.theta.est = NULL,
  bs.ci = NULL,
  B = 100,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.gmwm_+3A_object">object</code></td>
<td>
<p>A <code>GMWM</code> object</p>
</td></tr>
<tr><td><code id="summary.gmwm_+3A_inference">inference</code></td>
<td>
<p>A value containing either: NULL (auto), TRUE, or FALSE</p>
</td></tr>
<tr><td><code id="summary.gmwm_+3A_bs.gof">bs.gof</code></td>
<td>
<p>A value containing either: NULL (auto), TRUE, FALSE</p>
</td></tr>
<tr><td><code id="summary.gmwm_+3A_bs.gof.p.ci">bs.gof.p.ci</code></td>
<td>
<p>A value containing either: NULL (auto), TRUE, FALSE</p>
</td></tr>
<tr><td><code id="summary.gmwm_+3A_bs.theta.est">bs.theta.est</code></td>
<td>
<p>A value containing either: NULL (auto), TRUE, FALSE</p>
</td></tr>
<tr><td><code id="summary.gmwm_+3A_bs.ci">bs.ci</code></td>
<td>
<p>A value containing either: NULL (auto), TRUE, FALSE</p>
</td></tr>
<tr><td><code id="summary.gmwm_+3A_b">B</code></td>
<td>
<p>An <code>int</code> that indicates how many bootstraps should be performed.</p>
</td></tr>
<tr><td><code id="summary.gmwm_+3A_...">...</code></td>
<td>
<p>Other arguments passed to specific methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>summary.gmwm</code> object with:
</p>

<ul>
<li><p>estimateEstimated Theta Values
</p>
</li>
<li><p>testinfoGoodness of Fit Information
</p>
</li>
<li><p>inferenceInference performed? T/F
</p>
</li>
<li><p>bs.gofBootstrap GOF? T/F
</p>
</li>
<li><p>bs.gof.p.ciBootstrap GOF P-Value CI? T/F
</p>
</li>
<li><p>bs.theta.estBootstrap Theta Estimates? T/F
</p>
</li>
<li><p>bs.ciBootstrap CI? T/F
</p>
</li>
<li><p>startingIndicates if program supplied initial starting values
</p>
</li>
<li><p>seedSeed used during guessing / bootstrapping
</p>
</li>
<li><p>obj.funValue of obj.fun at minimized theta
</p>
</li>
<li><p>NLength of Time Series
</p>
</li></ul>



<h3>Author(s)</h3>

<p>JJB
</p>

<hr>
<h2 id='theo_acf'>Theoretical Autocorrelation (ACF) of an ARMA process</h2><span id='topic+theo_acf'></span>

<h3>Description</h3>

<p>This function computes the theoretical Autocorrelation (ACF) of an ARMA process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>theo_acf(ar, ma = NULL, lagmax = 20)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="theo_acf_+3A_ar">ar</code></td>
<td>
<p>A <code>vector</code> containing the AR coefficients.</p>
</td></tr>
<tr><td><code id="theo_acf_+3A_ma">ma</code></td>
<td>
<p>A <code>vector</code> containing the MA coefficients.</p>
</td></tr>
<tr><td><code id="theo_acf_+3A_lagmax">lagmax</code></td>
<td>
<p>An <code>integer</code> indicating the maximum lag up to which to compute the theoretical ACF.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Yuming Zhang
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Compute the theoretical ACF for an ARMA(1,0) (i.e. a first-order autoregressive model: AR(1))
theo_acf(ar = -0.25, ma = NULL)
# Computes the theoretical ACF for an ARMA(2, 1)
theo_acf(ar = c(.50, -0.25), ma = 0.20, lagmax = 10)
</code></pre>

<hr>
<h2 id='theo_pacf'>Theoretical Partial Autocorrelation (PACF) of an ARMA process</h2><span id='topic+theo_pacf'></span>

<h3>Description</h3>

<p>This function computes the theoretical Partial Autocorrelation (PACF) of an ARMA process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>theo_pacf(ar, ma = NULL, lagmax = 20)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="theo_pacf_+3A_ar">ar</code></td>
<td>
<p>A <code>vector</code> containing the AR coefficients.</p>
</td></tr>
<tr><td><code id="theo_pacf_+3A_ma">ma</code></td>
<td>
<p>A <code>vector</code> containing the MA coefficients.</p>
</td></tr>
<tr><td><code id="theo_pacf_+3A_lagmax">lagmax</code></td>
<td>
<p>An <code>integer</code> indicating the maximum lag up to which to compute the theoretical PACF.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Yuming Zhang
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Computes the theoretical ACF for an ARMA(1,0) (i.e. a first-order autoregressive model: AR(1))
theo_pacf(ar = -0.25, ma = NULL, lagmax = 7)
# Computes the theoretical ACF for an ARMA(2, 1)
theo_pacf(ar = c(.50, -0.25), ma = .20, lagmax = 10)
</code></pre>

<hr>
<h2 id='theoretical_wv'>Model Process to WV</h2><span id='topic+theoretical_wv'></span>

<h3>Description</h3>

<p>This function computes the summation of all Processes to WV (haar) in a given model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>theoretical_wv(theta, desc, objdesc, tau)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="theoretical_wv_+3A_theta">theta</code></td>
<td>
<p>A <code>vec</code> containing the list of estimated parameters.</p>
</td></tr>
<tr><td><code id="theoretical_wv_+3A_desc">desc</code></td>
<td>
<p>A <code>vector&lt;string&gt;</code> containing a list of descriptors.</p>
</td></tr>
<tr><td><code id="theoretical_wv_+3A_objdesc">objdesc</code></td>
<td>
<p>A <code>field&lt;vec&gt;</code> containing a list of object descriptors.</p>
</td></tr>
<tr><td><code id="theoretical_wv_+3A_tau">tau</code></td>
<td>
<p>A <code>vec</code> containing the scales e.g. <code class="reqn">2^{\tau}</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>vec</code> containing the wavelet variance of the model.
</p>

<hr>
<h2 id='theta_ci'>Generate the Confidence Interval for Theta Estimates</h2><span id='topic+theta_ci'></span>

<h3>Description</h3>

<p>Create an Asymptotic CI for the Theta Estimates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>theta_ci(theta, A, v_hat, omega, alpha)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="theta_ci_+3A_theta">theta</code></td>
<td>
<p>A <code>vec</code> containing the estimates</p>
</td></tr>
<tr><td><code id="theta_ci_+3A_a">A</code></td>
<td>
<p>A <code>mat</code> that is the first derivative matrix.</p>
</td></tr>
<tr><td><code id="theta_ci_+3A_v_hat">v_hat</code></td>
<td>
<p>A <code>mat</code> that is the bootstrapped V matrix</p>
</td></tr>
<tr><td><code id="theta_ci_+3A_omega">omega</code></td>
<td>
<p>A <code>mat</code> that is the inverse of the diagonal V matrix.</p>
</td></tr>
<tr><td><code id="theta_ci_+3A_alpha">alpha</code></td>
<td>
<p>A <code>double</code> that contains the confidence level.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>mat</code> that has the first column
</p>

<hr>
<h2 id='transform_values'>Transform Values for Optimization</h2><span id='topic+transform_values'></span>

<h3>Description</h3>

<p>Transform parameter guesses prior to estimating with GMWM
</p>


<h3>Usage</h3>

<pre><code class='language-R'>transform_values(theta, desc, objdesc, model_type)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="transform_values_+3A_theta">theta</code></td>
<td>
<p>A <code>vec</code> with dimensions N x 1 that contains user-supplied initial values for parameters</p>
</td></tr>
<tr><td><code id="transform_values_+3A_desc">desc</code></td>
<td>
<p>A <code>vector&lt;string&gt;</code> indicating the models that should be considered.</p>
</td></tr>
<tr><td><code id="transform_values_+3A_objdesc">objdesc</code></td>
<td>
<p>A <code>field&lt;vec&gt;</code> containing a list of parameters (e.g. AR(1) = c(1,1), ARMA(p,q) = c(p,q,1))</p>
</td></tr>
<tr><td><code id="transform_values_+3A_model_type">model_type</code></td>
<td>
<p>A <code>string</code> that contains the model type: <code>"imu"</code> or <code>"ssm"</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>vec</code> containing the transformed guesses.
</p>


<h3>Author(s)</h3>

<p>James Joseph Balamuta (JJB)
</p>

<hr>
<h2 id='unitConversion'>Convert Unit of Time Series Data</h2><span id='topic+unitConversion'></span>

<h3>Description</h3>

<p>Manipulate the units of time to different ones
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unitConversion(x, from.unit, to.unit)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unitConversion_+3A_x">x</code></td>
<td>
<p>A <code>vector</code> containing the values on x-axis.</p>
</td></tr>
<tr><td><code id="unitConversion_+3A_from.unit">from.unit</code></td>
<td>
<p>A <code>string</code> indicating the unit which the data is converted from.</p>
</td></tr>
<tr><td><code id="unitConversion_+3A_to.unit">to.unit</code></td>
<td>
<p>A <code>string</code> indicating the unit which the data is converted to.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The supported units are &quot;ns&quot;(nanosecond), &quot;ms&quot;(millisecond), &quot;sec&quot;, &quot;min&quot;, &quot;hour&quot;, &quot;day&quot;, &quot;month&quot;, and &quot;year&quot;.
Make sure <code>from.unit</code> and <code>to.unit</code> are not <code>NULL</code> before it is passed to this function.
</p>


<h3>Value</h3>

<p>A <code>list</code> with the following structure:
</p>

<dl>
<dt>x</dt><dd><p>Data</p>
</dd>
<dt>converted</dt><dd><p>A <code>boolean</code> indicating whether conversion is made</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>x = seq(60, 3600, 60)
unitConversion(x, 'sec', 'min')
y = 1:10
unitConversion(y, 'hour', 'sec')
</code></pre>

<hr>
<h2 id='untransform_values'>Revert Transform Values for Display</h2><span id='topic+untransform_values'></span>

<h3>Description</h3>

<p>Undo the previous transform of parameter guesses to obtain the GMWM estimates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>untransform_values(theta, desc, objdesc, model_type)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="untransform_values_+3A_theta">theta</code></td>
<td>
<p>A <code>vec</code> with dimensions N x 1 that contains user-supplied initial values for parameters</p>
</td></tr>
<tr><td><code id="untransform_values_+3A_desc">desc</code></td>
<td>
<p>A <code>vector&lt;string&gt;</code> indicating the models that should be considered.</p>
</td></tr>
<tr><td><code id="untransform_values_+3A_objdesc">objdesc</code></td>
<td>
<p>A <code>field&lt;vec&gt;</code> containing a list of parameters (e.g. AR(1) = c(1,1), ARMA(p,q) = c(p,q,1))</p>
</td></tr>
<tr><td><code id="untransform_values_+3A_model_type">model_type</code></td>
<td>
<p>A <code>string</code> that contains the model type: <code>"imu"</code> or <code>"ssm"</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>vec</code> containing the undone transformation of parameters.
</p>


<h3>Author(s)</h3>

<p>James Joseph Balamuta (JJB)
</p>

<hr>
<h2 id='update_obj'>Update the Attributes of Objects</h2><span id='topic+update_obj'></span>

<h3>Description</h3>

<p>Internal Function to Update the Attributes of Objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>update_obj(object, type, new, keep.start = T)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="update_obj_+3A_object">object</code></td>
<td>
<p>A <code>lts</code>, <code>gts</code> or <code>imu</code> object</p>
</td></tr>
<tr><td><code id="update_obj_+3A_type">type</code></td>
<td>
<p>A <code>string</code> that contains the attribute to be updated</p>
</td></tr>
<tr><td><code id="update_obj_+3A_new">new</code></td>
<td>
<p>The updated value for the attribute</p>
</td></tr>
<tr><td><code id="update_obj_+3A_keep.start">keep.start</code></td>
<td>
<p>A <code>boolean</code> value that indicates whether 'start' or 'end' should remain the same when 'freq' is updated</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object with the updated attribute.
</p>

<hr>
<h2 id='update.gmwm'>Update (Robust) GMWM object for IMU or SSM</h2><span id='topic+update.gmwm'></span>

<h3>Description</h3>

<p>Provides a way to estimate different models over the previously estimated
wavelet variance values and covariance matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gmwm'
update(object, model, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="update.gmwm_+3A_object">object</code></td>
<td>
<p>A <code>gmwm</code> object.</p>
</td></tr>
<tr><td><code id="update.gmwm_+3A_model">model</code></td>
<td>
<p>A <code>ts.model</code> object containing one of the allowed models</p>
</td></tr>
<tr><td><code id="update.gmwm_+3A_...">...</code></td>
<td>
<p>Additional parameters (not used)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>gmwm</code> object with the structure:
</p>

<ul>
<li><p>estimateEstimated Parameters Values from the GMWM Procedure
</p>
</li>
<li><p>init.guessInitial Starting Values given to the Optimization Algorithm
</p>
</li>
<li><p>wv.empirThe data's empirical wavelet variance
</p>
</li>
<li><p>ci_lowLower Confidence Interval
</p>
</li>
<li><p>ci_highUpper Confidence Interval
</p>
</li>
<li><p>orgVOriginal V matrix
</p>
</li>
<li><p>VUpdated V matrix (if bootstrapped)
</p>
</li>
<li><p>omegaThe V matrix inversed
</p>
</li>
<li><p>obj.funValue of the objective function at Estimated Parameter Values
</p>
</li>
<li><p>theoSummed Theoretical Wavelet Variance
</p>
</li>
<li><p>decomp.theoDecomposed Theoretical Wavelet Variance by Process
</p>
</li>
<li><p>scalesScales of the GMWM Object
</p>
</li>
<li><p>robustIndicates if parameter estimation was done under robust or classical
</p>
</li>
<li><p>effLevel of efficiency of robust estimation
</p>
</li>
<li><p>model.typeModels being guessed
</p>
</li>
<li><p>compute.vType of V matrix computation
</p>
</li>
<li><p>augmentedIndicates moments have been augmented
</p>
</li>
<li><p>alphaAlpha level used to generate confidence intervals
</p>
</li>
<li><p>expect.diffMean of the First Difference of the Signal
</p>
</li>
<li><p>NLength of the Signal
</p>
</li>
<li><p>GNumber of Guesses Performed
</p>
</li>
<li><p>HNumber of Bootstrap replications
</p>
</li>
<li><p>KNumber of V matrix bootstraps
</p>
</li>
<li><p>model<code>ts.model</code> supplied to gmwm
</p>
</li>
<li><p>model.hatA new value of <code>ts.model</code> object supplied to gmwm
</p>
</li>
<li><p>startingIndicates whether the procedure used the initial guessing approach
</p>
</li>
<li><p>seedRandomization seed used to generate the guessing values
</p>
</li>
<li><p>freqFrequency of data
</p>
</li></ul>


<hr>
<h2 id='update.lts'>Update Object Attribute</h2><span id='topic+update.lts'></span><span id='topic+update.gts'></span><span id='topic+update.imu'></span>

<h3>Description</h3>

<p>Update the attributes of <code>lts</code>, <code>gts</code> and <code>imu</code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lts'
update(object, type, new, keep.start = T, ...)

## S3 method for class 'gts'
update(object, type, new, keep.start = T, ...)

## S3 method for class 'imu'
update(object, type, new, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="update.lts_+3A_object">object</code></td>
<td>
<p>A <code>lts</code>, <code>gts</code> or <code>imu</code> object</p>
</td></tr>
<tr><td><code id="update.lts_+3A_type">type</code></td>
<td>
<p>A <code>string</code> that contains the attribute to be updated</p>
</td></tr>
<tr><td><code id="update.lts_+3A_new">new</code></td>
<td>
<p>The updated value for the attribute</p>
</td></tr>
<tr><td><code id="update.lts_+3A_keep.start">keep.start</code></td>
<td>
<p>A <code>boolean</code> value that indicates whether 'start' or 'end' should remain the same when 'freq' is updated</p>
</td></tr>
<tr><td><code id="update.lts_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is able to update some attributes for <code>gts</code>, <code>lts</code> and <code>imu</code> objects. 
For <code>lts</code> object, the attributes that can be updated are 'start', 'end', 'freq', 'unit_time', 'name_ts' and 'process'.
For <code>gts</code> object, the attributes that can be updated are 'start', 'end', 'freq', 'unit_time' and 'name_ts'.
For <code>imu</code> object, the attributes that can be updated are 'axis', 'freq', 'unit_time' and 'name_ts'.
</p>
<p>If one between 'start' and 'end' is updated, the other one will also be updated, since <code>end-start == (N-1)/freq</code> must be TRUE, where <code>N</code>
is the number of observations in the object. 
</p>
<p>If 'freq' is updated, by default 'start' will remain the same, and 'end' will be updated at the same time,
unless you set 'keep.start = F'.
</p>
<p>If 'unit_time' is updated, the old unit_time will be replaced by the new one, and other attributes will remain the same.
It is different from the unit_time conversion feature.
</p>


<h3>Value</h3>

<p>An object with the updated attribute.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>gts1 = gts(rnorm(50), freq = 1, unit_time = 'sec', name_ts = 'test1')
gts2 = update(gts1, 'unit_time', 'min')
attr(gts2, 'unit_time')

gts3 = update(gts1, 'name_ts', 'test2')
attr(gts3, 'name_ts')
</code></pre>

<hr>
<h2 id='value'>Obtain the value of an object's properties</h2><span id='topic+value'></span><span id='topic+value.imu'></span>

<h3>Description</h3>

<p>Used to access different properties of the
<code>gts</code>, <code>imu</code>, or <code>lts</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>value(x, type)

## S3 method for class 'imu'
value(x, type)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="value_+3A_x">x</code></td>
<td>
<p>A <code>gts</code>, <code>imu</code>, or <code>lts</code> object.</p>
</td></tr>
<tr><td><code id="value_+3A_type">type</code></td>
<td>
<p>A <code>string</code> indicating the field to be retrieved.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>To access information about <code>imu</code> properties use:
</p>

<dl>
<dt><code>"accel"</code></dt><dd><p>Returns the number of accelerometers</p>
</dd>
<dt><code>"gyro"</code></dt><dd><p>Returns the number of gyroscopes</p>
</dd>
<dt><code>"sensors"</code></dt><dd><p>Returns total number of sensors</p>
</dd>
</dl>



<h3>Value</h3>

<p>The method will return a single numeric or string result depending on the
slot being accessed.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>value(imu)</code>: Access <code>imu</code> object properties
</p>
</li></ul>


<h3>Author(s)</h3>

<p>James Balamuta
</p>

<hr>
<h2 id='var_drift'>Variance DR</h2><span id='topic+var_drift'></span>

<h3>Description</h3>

<p>This function computes the variance of a drift process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>var_drift(omega, n_ts)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="var_drift_+3A_omega">omega</code></td>
<td>
<p>A <code>double</code> corresponding to variance of drift.</p>
</td></tr>
<tr><td><code id="var_drift_+3A_n_ts">n_ts</code></td>
<td>
<p>An <code>int</code> indicating the length of the time series.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>vec</code> containing the variance of the drift.
</p>

<hr>
<h2 id='vector_to_set'>Conversion function of Vector to Set</h2><span id='topic+vector_to_set'></span>

<h3>Description</h3>

<p>Converts a vector into a set
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vector_to_set(model_str)
</code></pre>


<h3>Value</h3>

<p>A <code>set&lt;vector&lt;string&gt;&gt;</code> that contains the list of unique models.
</p>

<hr>
<h2 id='w4_filter'>w4 filter construction</h2><span id='topic+w4_filter'></span>

<h3>Description</h3>

<p>Creates the w4 filter
</p>


<h3>Usage</h3>

<pre><code class='language-R'>w4_filter()
</code></pre>


<h3>Details</h3>

<p>This template can be used to increase the amount of filters available for selection.
</p>


<h3>Value</h3>

<p>A <code>field&lt;vec&gt;</code> that contains:
</p>

<ul>
<li><p>&quot;L&quot;A <code>integer</code> specifying the length of the filter
</p>
</li>
<li><p>&quot;h&quot;A <code>vector</code> containing the coefficients for the wavelet filter
</p>
</li>
<li><p>&quot;g&quot;A <code>vector</code> containing the coefficients for the scaling filter
</p>
</li></ul>



<h3>Author(s)</h3>

<p>JJB
</p>

<hr>
<h2 id='wave_variance'>Generate a Wave Variance for a Univariate Time Series</h2><span id='topic+wave_variance'></span>

<h3>Description</h3>

<p>Computes an estimate of the wave variance
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wave_variance(signal_modwt_bw, robust = FALSE, eff = 0.6)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wave_variance_+3A_signal_modwt_bw">signal_modwt_bw</code></td>
<td>
<p>A <code>field&lt;vec&gt;</code> that contains the brick walled modwt or dwt decomposition</p>
</td></tr>
<tr><td><code id="wave_variance_+3A_robust">robust</code></td>
<td>
<p>A <code>boolean</code> to determine the type of wave estimation.</p>
</td></tr>
<tr><td><code id="wave_variance_+3A_eff">eff</code></td>
<td>
<p>A <code>double</code> that indicates the efficiency.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>vec</code> that contains the wave variance.
</p>

<hr>
<h2 id='WN'>Create an White Noise (WN) Process</h2><span id='topic+WN'></span>

<h3>Description</h3>

<p>Sets up the necessary backend for the WN process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>WN(sigma2 = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="WN_+3A_sigma2">sigma2</code></td>
<td>
<p>A <code>double</code> value for the variance, <code class="reqn">\sigma ^2</code>, of a WN process.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An S3 object with called ts.model with the following structure:
</p>

<dl>
<dt>process.desc</dt><dd><p>Used in summary: &quot;WN&quot;</p>
</dd>
<dt>theta</dt><dd><p><code class="reqn">\sigma</code></p>
</dd>
<dt>plength</dt><dd><p>Number of Parameters</p>
</dd>
<dt>print</dt><dd><p>String containing simplified model</p>
</dd>
<dt>desc</dt><dd><p>y desc replicated x times</p>
</dd>
<dt>obj.desc</dt><dd><p>Depth of Parameters e.g. list(1)</p>
</dd>
<dt>starting</dt><dd><p>Guess Starting values? TRUE or FALSE (e.g. specified value)</p>
</dd>
</dl>



<h3>Note</h3>

<p>In this process, <code class="reqn">Y_t</code> is iid from a zero mean normal distribution with variance <code class="reqn">\sigma^2</code>
</p>


<h3>Author(s)</h3>

<p>James Balamuta
</p>


<h3>Examples</h3>

<pre><code class='language-R'>WN()
WN(sigma2=3.4)
</code></pre>

<hr>
<h2 id='wn_to_wv'>Gaussian White Noise to WV</h2><span id='topic+wn_to_wv'></span>

<h3>Description</h3>

<p>This function compute the Haar WV of a Gaussian White Noise process
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wn_to_wv(sigma2, tau)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wn_to_wv_+3A_sigma2">sigma2</code></td>
<td>
<p>A <code>double</code> corresponding to variance of WN</p>
</td></tr>
<tr><td><code id="wn_to_wv_+3A_tau">tau</code></td>
<td>
<p>A <code>vec</code> containing the scales e.g. <code class="reqn">2^{\tau}</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>vec</code> containing the wavelet variance of the white noise.
</p>


<h3>Process Haar Wavelet Variance Formula</h3>

<p>The Gaussian White Noise (WN) process has a Haar Wavelet Variance given by:
</p>
<p style="text-align: center;"><code class="reqn">\nu _j^2\left( {{\sigma ^2}} \right) = \frac{{{\sigma ^2}}}{{\tau _j^2}}</code>
</p>


<hr>
<h2 id='wvar_cpp'>Computes the (MODWT) wavelet variance</h2><span id='topic+wvar_cpp'></span>

<h3>Description</h3>

<p>Calculates the (MODWT) wavelet variance
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wvar_cpp(signal_modwt_bw, robust, eff, alpha, ci_type)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wvar_cpp_+3A_signal_modwt_bw">signal_modwt_bw</code></td>
<td>
<p>A <code>field&lt;vec&gt;</code> that contains the modwt decomposition after it has been brick walled.</p>
</td></tr>
<tr><td><code id="wvar_cpp_+3A_robust">robust</code></td>
<td>
<p>A <code>boolean</code> that triggers the use of the robust estimate.</p>
</td></tr>
<tr><td><code id="wvar_cpp_+3A_eff">eff</code></td>
<td>
<p>A <code>double</code> that indicates the efficiency as it relates to an MLE.</p>
</td></tr>
<tr><td><code id="wvar_cpp_+3A_alpha">alpha</code></td>
<td>
<p>A <code>double</code> that indicates the <code class="reqn">\left(1-p\right)*\alpha</code> confidence level</p>
</td></tr>
<tr><td><code id="wvar_cpp_+3A_ci_type">ci_type</code></td>
<td>
<p>A <code>String</code> indicating the confidence interval being calculated. Valid value: &quot;eta3&quot;</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function does the heavy lifting with the signal_modwt_bw
</p>


<h3>Value</h3>

<p>A <code>mat</code> with the structure:
</p>

<ul>
<li><p>&quot;variance&quot;Wavelet Variance
</p>
</li>
<li><p>&quot;low&quot;Lower CI
</p>
</li>
<li><p>&quot;high&quot;Upper CI
</p>
</li></ul>


</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
