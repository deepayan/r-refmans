<!DOCTYPE html><html><head><title>Help for package npcure</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {npcure}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#beran'><p>Compute Beran's Estimator of the Conditional Survival</p></a></li>
<li><a href='#berancv'><p>Compute the Cross-Validation Bandwidth for Beran's Estimator</p>
of the Conditional Survival</a></li>
<li><a href='#controlpars'><p>Control Values for the Bootstrap or Cross-validation</p></a></li>
<li><a href='#hpilot'><p>Compute the Pilot Bandwidth for the Nonparametric Estimators of</p>
Cure Probability and Latency</a></li>
<li><a href='#latency'><p>Compute Nonparametric Estimator of the Conditional Latency</p></a></li>
<li><a href='#latencyhboot'><p>Compute the Bootstrap Bandwidth for the Nonparametric Estimator</p>
of the Latency</a></li>
<li><a href='#npcure-package'><p>Nonparametric Estimation in Mixture Cure Models</p></a></li>
<li><a href='#print.npcure'><p>Print Method for Objects of Class 'npcure'</p></a></li>
<li><a href='#probcure'><p>Compute Nonparametric Estimator of the Conditional Probability of</p>
Cure</a></li>
<li><a href='#probcurehboot'><p>Compute the Bootstrap Bandwidth for the Nonparametric Estimator</p>
of the Cure Probability</a></li>
<li><a href='#summary.npcure'><p>Summary Method for Objects of Class 'npcure'</p></a></li>
<li><a href='#testcov'><p>Covariate Significance Test of the Cure Probability</p></a></li>
<li><a href='#testmz'><p>Test of Maller-Zhou</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>0.1-5</td>
</tr>
<tr>
<td>Date:</td>
<td>2020-02-28</td>
</tr>
<tr>
<td>Title:</td>
<td>Nonparametric Estimation in Mixture Cure Models</td>
</tr>
<tr>
<td>Author:</td>
<td>Ignacio López-de-Ullibarri [aut, cre],
  Ana López-Cheda [aut],
  Maria Amalia Jácome [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Ignacio López-de-Ullibarri &lt;ignacio.lopezdeullibarri@udc.es&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>KMsurv</td>
</tr>
<tr>
<td>Description:</td>
<td>Performs nonparametric estimation in mixture cure models, and significance tests for the cure probability. For details, see López-Cheda et al. (2017a) &lt;<a href="https://doi.org/10.1016%2Fj.csda.2016.08.002">doi:10.1016/j.csda.2016.08.002</a>&gt; and López-Cheda et al. (2017b) &lt;<a href="https://doi.org/10.1007%2Fs11749-016-0515-1">doi:10.1007/s11749-016-0515-1</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Imports:</td>
<td>permute, stats, utils, zoo</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2020-02-28 17:11:35 UTC; ilu</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2020-02-29 10:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='beran'>Compute Beran's Estimator of the Conditional Survival
</h2><span id='topic+beran'></span>

<h3>Description</h3>

<p>This function computes the Beran nonparametric estimator of
the conditional survival function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>beran(x, t, d, dataset, x0, h, local = TRUE, testimate = NULL,
conflevel = 0L, cvbootpars = if (conflevel == 0 &amp;&amp; !missing(h)) NULL
else controlpars())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="beran_+3A_x">x</code></td>
<td>
<p>If <code>dataset</code> is missing, a numeric object giving the
covariate values. If <code>dataset</code> is a data frame, it is
interpreted as the name of the variable corresponding to the
covariate in the data frame.
</p>
</td></tr>
<tr><td><code id="beran_+3A_t">t</code></td>
<td>
<p>If <code>dataset</code> is missing, a numeric object giving the
observed times. If <code>dataset</code> is a data frame, it is interpreted
as the name of the variable corresponding to the observed times in
the data frame.
</p>
</td></tr>
<tr><td><code id="beran_+3A_d">d</code></td>
<td>
<p>If <code>dataset</code> is missing, an integer object giving the
values of the uncensoring indicator. Censored observations must be
coded as 0, uncensored ones as 1. If <code>dataset</code> is a data frame,
it is interpreted as the name of the variable corresponding to the
uncensoring indicator. 
</p>
</td></tr>
<tr><td><code id="beran_+3A_dataset">dataset</code></td>
<td>
<p>An optional data frame in which the variables named in
<code>x</code>, <code>t</code> and <code>d</code> are interpreted. If it is missing,
<code>x</code>, <code>t</code> and <code>d</code> must be objects of the workspace.
</p>
</td></tr>
<tr><td><code id="beran_+3A_x0">x0</code></td>
<td>
<p>A numeric vector of covariate values where the survival
estimates will be computed.
</p>
</td></tr>
<tr><td><code id="beran_+3A_h">h</code></td>
<td>
<p>A numeric vector of bandwidths. If it is missing the default
is to use the cross-validation bandwidth computed by the
<code>berancv</code> function.
</p>
</td></tr>
<tr><td><code id="beran_+3A_local">local</code></td>
<td>
<p>A logical value, <code>TRUE</code> by default, specifying
whether local or global bandwidths are used.
</p>
</td></tr>
<tr><td><code id="beran_+3A_testimate">testimate</code></td>
<td>
<p>A numeric vector specifying the times at which the
survival is estimated. By default it is <code>NULL</code>, and then the
survival is estimated at the times given by <code>t</code>.
</p>
</td></tr>
<tr><td><code id="beran_+3A_conflevel">conflevel</code></td>
<td>
<p>A value controlling whether bootstrap confidence
intervals (CI) of the survival are to be computed. With the default
value, 0L, the CIs are not computed. If a numeric value 
between 0 and 1 is passed, it specifies the confidence level of the
CIs.
</p>
</td></tr>
<tr><td><code id="beran_+3A_cvbootpars">cvbootpars</code></td>
<td>
<p>A list of parameters controlling the bootstrap when
computing the CIs of the survival: <code>B</code>, the number of bootstrap
resamples, and <code>nnfrac</code>, the fraction of the sample size that
determines the order of the nearest neighbor used for choosing a
pilot bandwidth. If <code>h</code> is missing the list of parameters is
extended to be the same used for computing the cross-validation
bandwidth (see the help of <code>berancv</code> for details). The default
is the value returned by the <code>controlpars</code> function called
without arguments. In case the CIs are not computed and <code>h</code> is
not missing the default is <code>NULL</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function computes the kernel type product-limit estimator
of the conditional survival function <code class="reqn">S(t | x) = P(Y &gt; t | X = x)</code>
under censoring, using the Nadaraya-Watson weights. The kernel used is
the Epanechnikov. If the smoothing parameter <code class="reqn">h</code> is not provided,
then the cross-validation bandwidth selector in Geerdens et al. (2018)
is used. The function is available only for one continuous covariate
<code class="reqn">X</code>.</p>


<h3>Value</h3>

<p>An object of S3 class 'npcure'. Formally, a list of components:
</p>
<table>
<tr><td><code>type</code></td>
<td>
<p>The constant string &quot;survival&quot;.
</p>
</td></tr>
<tr><td><code>local</code></td>
<td>
<p>The value of the <code>local</code> argument.
</p>
</td></tr>
<tr><td><code>h</code></td>
<td>
<p>The value of the <code>h</code> argument, unless this is missing,
in which case its value is that of the cross-validation bandwidth.
</p>
</td></tr>
<tr><td><code>x0</code></td>
<td>
<p>The value of the <code>x0</code> argument.
</p>
</td></tr>
<tr><td><code>testim</code></td>
<td>
<p>The numeric vector of time values where the survival function
is estimated.
</p>
</td></tr>
<tr><td><code>S</code></td>
<td>
<p>A list whose components are the estimates of the survival function
for each one of the covariate values, i.e., those specified by the
<code>x0</code> argument. The survival estimates are given at the times
determined by the <code>testimate</code> argument.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Ignacio López-de-Ullibarri [aut, cre],
Ana López-Cheda [aut],
Maria Amalia Jácome [aut]
</p>


<h3>References</h3>

<p>Beran, R. (1981). Nonparametric regression with randomly
censored survival data. Technical report, University of California,
Berkeley.
</p>
<p>Geerdens, C., Acar, E. F., Janssen, P. (2018). Conditional copula
models for right-censored clustered event time data. Biostatistics,
19(2): 247-262. <a href="https://doi.org/10.1093/biostatistics/kxx034">https://doi.org/10.1093/biostatistics/kxx034</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+controlpars">controlpars</a></code>, <code><a href="#topic+berancv">berancv</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Some artificial data
set.seed(123)
n &lt;- 50
x &lt;- runif(n, -2, 2) ## Covariate values
y &lt;- rweibull(n, shape = .5*(x + 4)) ## True lifetimes
c &lt;- rexp(n) ## Censoring values
p &lt;- exp(2*x)/(1 + exp(2*x)) ## Probability of being susceptible
u &lt;- runif(n)
t &lt;- ifelse(u &lt; p, pmin(y, c), c) ## Observed times
d &lt;- ifelse(u &lt; p, ifelse(y &lt; c, 1, 0), 0) ## Uncensoring indicator
data &lt;- data.frame(x = x, t = t, d = d)

## Survival estimates for covariate values 0, 0.5 using...
## ... (a) global bandwidths 0.3, 0.5, 1.
## By default, the estimates are computed at the observed times
x0 &lt;- c(0, .5)
S1 &lt;- beran(x, t, d, data, x0 = x0, h = c(.3, .5, 1), local = FALSE) 

## Plot predicted survival curves for covariate value 0.5
plot(S1$testim, S1$S$h0.3$x0.5, type = "s", xlab = "Time", ylab =
"Survival", ylim = c(0, 1)) 
lines(S1$testim, S1$S$h0.5$x0.5, type = "s", lty = 2)
lines(S1$testim, S1$S$h1$x0.5, type = "s", lty = 3)
## The true survival curve is plotted for reference
p0 &lt;- exp(2*x0[2])/(1 + exp(2*x0[2]))
lines(S1$testim, 1 - p0 + p0*pweibull(S1$testim, shape = .5*(x0[2] + 4),
lower.tail = FALSE), col = 2)
legend("topright", c("Estimate, h = 0.3", "Estimate, h = 0.5",
"Estimate, h = 1", "True"), lty = c(1:3, 1), col = c(rep(1, 3), 2))

## As before, but with estimates computed at fixed times 0.1, 0.2,...,1
S2 &lt;- beran(x, t, d, data, x0 = x0, h = c(.3, .5, 1), local = FALSE,
testimate = .1*(1:10))

## ... (b) local bandwidths 0.3, 0.5.
## Note that the length of the covariate vector x0 and the bandwidth h
## must be the same.
S3 &lt;- beran(x, t, d, data, x0 = x0, h = c(.3, .5), local = TRUE)

## ... (c) the cross-validation (CV) bandwidth selector (the default
## when the bandwidth argument is not provided). 
## The CV bandwidth is searched in a grid of 150 bandwidths (hl = 150)
## between 0.2 and 2 times the standardized interquartile range
## of the covariate values (hbound = c(.2, 2)).
## 95% confidence intervals are also given.
S4 &lt;- beran(x, t, d, data, x0 = x0, conflevel = .95, cvbootpars =
controlpars(hl = 150, hbound = c(.2, 2))) 
     
## Plot of predicted survival curve and confidence intervals for
## covariate value 0.5 
plot(S4$testim, S4$S$x0.5, type = "s", xlab = "Time", ylab = "Survival",
ylim = c(0, 1))
lines(S4$testim, S4$conf$x0.5$lower, type = "s", lty = 2)
lines(S4$testim, S4$conf$x0.5$upper, type = "s", lty = 2)
lines(S4$testim, 1 - p0 + p0 * pweibull(S4$testim, shape = .5*(x0[2] +
4), lower.tail = FALSE), col = 2) 
legend("topright", c("Estimate with CV bandwidth", "95% CI limits",
"True"), lty = c(1, 2, 1), col = c(1, 1, 2))


## Example with the dataset 'bmt' in the 'KMsurv' package
## to study the survival of patients aged 25 and 40.
data("bmt", package = "KMsurv")
x0 &lt;- c(25, 40)
S &lt;- beran(z1, t2, d3, bmt, x0 = x0, conflevel = .95)
## Plot of predicted survival curves and confidence intervals
plot(S$testim, S$S$x25, type = "s", xlab = "Time", ylab = "Survival",
ylim = c(0, 1))
lines(S$testim, S$conf$x25$lower, type = "s", lty = 2)
lines(S$testim, S$conf$x25$upper, type = "s", lty = 2)
lines(S$testim, S$S$x40, type = "s", lty = 1, col = 2)
lines(S$testim, S$conf$x40$lower, type = "s", lty = 2, col = 2)
lines(S$testim, S$conf$x40$upper, type = "s", lty = 2, col = 2)
legend("topright", c("Age 25: Estimate", "Age 25: 95% CI limits",
"Age 40: Estimate", "Age 40: 95% CI limits"), lty = 1:2,
col = c(1, 1, 2, 2)) 

</code></pre>

<hr>
<h2 id='berancv'>Compute the Cross-Validation Bandwidth for Beran's Estimator
of the Conditional Survival
</h2><span id='topic+berancv'></span>

<h3>Description</h3>

<p>This function computes the cross-validation bandwidth
for Beran's estimator of the conditional survival function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>berancv(x, t, d, dataset, x0, cvpars = controlpars())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="berancv_+3A_x">x</code></td>
<td>
<p>If <code>dataset</code> is missing, a numeric object giving the
covariate values. If <code>dataset</code> is a data frame, it is
interpreted as the name of the variable corresponding to the
covariate in the data frame.
</p>
</td></tr>
<tr><td><code id="berancv_+3A_t">t</code></td>
<td>
<p>If <code>dataset</code> is missing, a numeric object giving the
observed times. If <code>dataset</code> is a data frame, it is interpreted
as the name of the variable corresponding to the observed times in
the data frame.
</p>
</td></tr>
<tr><td><code id="berancv_+3A_d">d</code></td>
<td>
<p>If <code>dataset</code> is missing, an integer object giving the
values of the uncensoring indicator. Censored observations must be
coded as 0, uncensored ones as 1. If <code>dataset</code> is a data frame,
it is interpreted as the name of the variable corresponding to the
uncensoring indicator in the data frame.
</p>
</td></tr>
<tr><td><code id="berancv_+3A_dataset">dataset</code></td>
<td>
<p>An optional data frame in which the variables named in
<code>x</code>, <code>t</code> and <code>indicator</code> are interpreted. If it is
missing, <code>x</code>, <code>t</code> and <code>indicator</code> must be objects
of the workspace.
</p>
</td></tr>
<tr><td><code id="berancv_+3A_x0">x0</code></td>
<td>
<p>A numeric vector of covariate values where the local
cross-validation bandwidth will be computed.
</p>
</td></tr>
<tr><td><code id="berancv_+3A_cvpars">cvpars</code></td>
<td>
<p>A list of parameters controlling the process of bandwidth
selection. The default is the value returned by the <code>controlpars</code>
function called without arguments. See the help for
<code>controlpars</code> for details.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The cross-validation (CV) bandwidth is taken as the largest
local minimizer of the leave-one-out cross-validated criterion in
Geerdens et al. (2018). Let <code class="reqn">F^{(-i)}(t | x_i)</code>, <code class="reqn">i = 1,
  \ldots, n</code> be the Beran estimator obtained using the
data points <code class="reqn">(x_j, t_j, d_j)</code>, <code class="reqn">j = 1, \ldots, i-1, i+1,
  \ldots, n</code>. For the CV criterion,
the differences <code class="reqn">I(t_i \leq t_j)-F^{(-i)}(t_j|x_i)</code> are computed only for the so-called 'useful
pairs' of observed times <code class="reqn">(t_i, t_j)</code>. A pair <code class="reqn">(T_i, T_j)</code> is
useful if the value of the indicator <code class="reqn">I(T_i \leq T_j)</code> gives an unambiguous correct value for the indicator <code class="reqn">I(Y_i
  \leq Y_j)</code> which contains the corresponding true
(possibly unknown) event times, see Geerdens et al. (2018) for
details. Gannoun et al. (2007) apply a similar criterion to perform
bandwidth selection for the Beran estimator, but they consider only
the pairs of true (uncensored) event times. Note that the inclusion of
useful pairs of observed times would be especially advantageous if the
censoring rate is high.
</p>


<h3>Value</h3>

<p>An object of S3 class 'npcure'. Formally, a list of components:
</p>
<table>
<tr><td><code>type</code></td>
<td>
<p>The constant character string
c(&quot;Cross-validation bandwidth&quot;, &quot;survival&quot;).
</p>
</td></tr>
<tr><td><code>x0</code></td>
<td>
<p>Grid of covariate values.
</p>
</td></tr>
<tr><td><code>h</code></td>
<td>
<p>Selected local cross-validation bandwidths.
</p>
</td></tr>
<tr><td><code>hgrid</code></td>
<td>
<p>Grid of bandwidths used (optional).
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Ignacio López-de-Ullibarri [aut, cre],
Ana López-Cheda [aut],
Maria Amalia Jácome [aut]
</p>


<h3>References</h3>

<p>Gannoun, A., Saracco, J., Yu, K. (2007). Comparison of
kernel estimators of conditional distribution function and quantile
regression under censoring. Statistical Modeling, 7:
329-344. <a href="https://doi.org/10.1177/1471082X0700700404">https://doi.org/10.1177/1471082X0700700404</a>.
</p>
<p>Geerdens, C., Acar, E. F., Janssen, P. (2018). Conditional copula
models for right-censored clustered event time data. Biostatistics,
19(2): 247-262. <a href="https://doi.org/10.1093/biostatistics/kxx034">https://doi.org/10.1093/biostatistics/kxx034</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+beran">beran</a></code>, <code><a href="#topic+controlpars">controlpars</a></code>,
<code><a href="#topic+hpilot">hpilot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Some artificial data
set.seed(123)
n &lt;- 50
x &lt;- runif(n, -2, 2) ## Covariate values
y &lt;- rweibull(n, shape = .5*(x + 4)) ## True lifetimes
c &lt;- rexp(n) ## Censoring values
p &lt;- exp(2*x)/(1 + exp(2*x)) ## Probability of being susceptible
u &lt;- runif(n)
t &lt;- ifelse(u &lt; p, pmin(y, c), c) ## Observed times
d &lt;- ifelse(u &lt; p, ifelse(y &lt; c, 1, 0), 0) ## Uncensoring indicator
data &lt;- data.frame(x = x, t = t, d = d)

## Computation of cross-validation (CV) local bandwidth for Beran's
## estimator of survival for covariate values 0, 1, ...
#### ... with the default control parameters (passed through 'cvpars')
x0 &lt;- c(0, 1)
hcv &lt;- berancv(x, t, d, data, x0 = x0)

#### ... changing the default 'cvpars' by calling the 'controlpars()'
#### function: 
#### (a) the CV local bandwidth is searched in a grid of 150 bandwidths
#### ('hl = 150') between 0.2 and 4 times the standardized interquartile
#### range of the covariate values of x ('hbound = c(.2, 4'))
#### (b) all the grid bandwidths are saved ('hsave = TRUE')
hcv &lt;- berancv(x, t, d, data, x0 = x0, cvpars = controlpars(hbound =
c(.2, 4), hl = 150, hsave = TRUE))

## Survival estimates for covariate values 0, 1, with CV local bandwidth
S1 &lt;- beran(x, t, d, data, x0 = x0,  h = hcv$h)
## Plot predicted survival curves for covariate values 0, 1
plot (S1$testim, S1$S$x0, type = "s", xlab = "Time", ylab = "Survival",
ylim = c(0, 1))
lines(S1$testim, S1$S$x1, type = "s", lty = 2)
## The survival curves are displayed for reference
p0 &lt;- exp(2*x0)/(1 + exp(2*x0))
lines(S1$testim, 1 - p0[1] + p0[1]*pweibull(S1$testim, shape = .5*(x0[1]
+ 4), lower.tail = FALSE), col = 2)
lines(S1$testim, 1 - p0[2] + p0[2]*pweibull(S1$testim, shape = .5*(x0[2]
+ 4), lower.tail = FALSE), lty = 2, col = 2)
legend("topright", c("Estimate, x = 0", "True, x = 0",
"Estimate, x = 1", "True, x = 1"), lty = c(1, 1, 2, 2), col = 1:2)


## Example with the dataset 'bmt' of the 'KMsurv' package to study the
## survival of patients aged 25 and 40.
data("bmt", package = "KMsurv")
x0 &lt;- c(25, 40)
hcv &lt;- berancv(z1, t2, d3, bmt, x0 = x0, cvpars = controlpars(hbound =
c(.2, 4), hl = 150, hsave = TRUE))
S &lt;- beran(z1, t2, d3, bmt, x0 = x0, h = hcv$h, conflevel = .95)
## Plot of predicted survival curves and confidence intervals
plot(S$testim, S$S$x25, type = "s", xlab = "Time", ylab = "Survival",
ylim = c(0, 1))
lines(S$testim, S$conf$x25$lower, type = "s", lty = 2)
lines(S$testim, S$conf$x25$upper, type = "s", lty = 2)
lines(S$testim, S$S$x40, type = "s", lty = 1, col = 2)
lines(S$testim, S$conf$x40$lower, type = "s", lty = 2, col = 2)
lines(S$testim, S$conf$x40$upper, type = "s", lty = 2, col = 2)
legend("topright", c("Age 25: Estimate", "Age 25: 95% CI limits",
"Age 40: Estimate", "Age 40: 95% CI limits"), lty = 1:2,
col = c(1, 1, 2, 2))

</code></pre>

<hr>
<h2 id='controlpars'>Control Values for the Bootstrap or Cross-validation
</h2><span id='topic+controlpars'></span>

<h3>Description</h3>

<p>This function returns a list of values for the control
parameters of the functions of the package that use the bootstrap or
cross-validation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>controlpars(B = 999L, hbound = c(0.1, 3), hl = 100L, hsave =
FALSE, nnfrac = 0.25, fpilot = NULL, qt = 0.75, hsmooth = 1L, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="controlpars_+3A_b">B</code></td>
<td>
<p>An integer giving the number of bootstrap resamples.
</p>
</td></tr>
<tr><td><code id="controlpars_+3A_hbound">hbound</code></td>
<td>
<p>A numeric vector of length 2 specifying the minimum
(default, 0.1) and maximum (default, 3), respectively, of the
initial grid of bandwidths as a multiple of the standardized
interquartile range of the covariate values.
</p>
</td></tr>
<tr><td><code id="controlpars_+3A_hl">hl</code></td>
<td>
<p>A numeric value giving the length of the initial grid of
bandwidths. The default is 100.
</p>
</td></tr>
<tr><td><code id="controlpars_+3A_hsave">hsave</code></td>
<td>
<p>A logical value specifying if the grids of bandwidths
must be saved as a component of the list returned by the
<code>berancv</code>, <code>latencyboot</code> and <code>probcurehboot</code>
functions. The default is <code>FALSE</code>.
</p>
</td></tr>
<tr><td><code id="controlpars_+3A_nnfrac">nnfrac</code></td>
<td>
<p>A numeric value giving the fraction of the sample size
that determines the order of the nearest neighbor used when choosing
the pilot bandwidth. The default is 0.25.
</p>
</td></tr>
<tr><td><code id="controlpars_+3A_fpilot">fpilot</code></td>
<td>
<p>A function name or <code>NULL</code>. If <code>NULL</code>, the
default, the <code>hpilot</code> function is used for computing a pilot
bandwidth in case that one is needed. If not <code>NULL</code>, it must be
the name of a user-defined function (given as a function name or as
a character string). This function must necessarily have an argument
<code>x0</code>, playing the same role than in <code>hpilot</code>, and must
return a value of the same length than <code>x0</code>. If <code>fpilot</code>
has more arguments, they are passed through the <code>...</code>
argument (see below).
</p>
</td></tr>
<tr><td><code id="controlpars_+3A_qt">qt</code></td>
<td>
<p>In bandwidth selection for the latency estimator (see
<code>latencyhboot</code>), a numeric value specifiying the order of a
quantile of the observed times. It determines the right boundary
of the integration interval in the computation of the ISE (the left
boundary is 0). The default is 0.75 (third quartile).
</p>
</td></tr>
<tr><td><code id="controlpars_+3A_hsmooth">hsmooth</code></td>
<td>
<p>An integer. Its value controls whether the bandwidths
selected by the <code>latencyhboot</code> and <code>probcurehboot</code> and
<code>berancv</code> function should be smoothed, and, if so, the degree
of smoothing. The smoothing consists in computing a centered moving
average of the unsmoothed vector of bandwidths returned by default
by <code>latencyhboot</code> and <code>probcurehboot</code>. The value of
<code>hsmooth</code> is the number of terms used to compute the
average. The default is 1L, which means that no smoothing is done.
</p>
</td></tr>
<tr><td><code id="controlpars_+3A_...">...</code></td>
<td>
<p>Arguments of <code>fpilot</code>, if <code>fpilot</code> is not
<code>NULL</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The output of <code>controlpars</code> is a list of control
parameters required by the package functions which use the bootstrap
or cross-validation. This is mainly the case of the <code>berancv</code>
function, which computes a cross-validation bandwidth for Beran's
estimator of survival, and of the <code>latencyhboot</code> and
<code>probcurehboot</code> functions, which compute the bootstrap bandwidth
selectors of the estimators of the latency and the probability of
cure, respectively. Since these functions are indirectly called by,
respectively, the <code>beran</code>, <code>latency</code> and <code>probcure</code>
functions when their <code>h</code> argument is missing, the output of
<code>controlpars</code> is also the expected (and default) way of passing
to them the parameters for bandwidth selection.
</p>
<p>Additionally, <code>controlpars</code> is used by <code>beran</code>,
<code>latency</code> and <code>probcure</code> to set the number of bootstrap
resamples and the value of <code>nnfrac</code> (see above) when confidence
intervals are computed. The <code>testcov</code> function also uses it for
setting the number of bootstrap resamples.
</p>


<h3>Value</h3>

<p>A list whose components are the arguments of the function, their
defaults being replaced with the values the function was called with.
</p>


<h3>Author(s)</h3>

<p>Ignacio López-de-Ullibarri [aut, cre],
Ana López-Cheda [aut],
Maria Amalia Jácome [aut]
</p>


<h3>See Also</h3>

<p><code><a href="#topic+beran">beran</a></code>,<code><a href="#topic+berancv">berancv</a></code>,
<code><a href="#topic+hpilot">hpilot</a></code>, <code><a href="#topic+latency">latency</a></code>,
<code><a href="#topic+latencyhboot">latencyhboot</a></code>, <code><a href="#topic+probcure">probcure</a></code>,
<code><a href="#topic+probcurehboot">probcurehboot</a></code>,<code><a href="#topic+testcov">testcov</a></code>
</p>

<hr>
<h2 id='hpilot'>Compute the Pilot Bandwidth for the Nonparametric Estimators of
Cure Probability and Latency
</h2><span id='topic+hpilot'></span>

<h3>Description</h3>

<p>This function computes local pilot bandwidths for the
nonparametric estimators of the probability of cure and the latency
function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hpilot(x, x0, nnfrac = 0.25)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hpilot_+3A_x">x</code></td>
<td>
<p>A numeric vector of observed covariate values.
</p>
</td></tr>
<tr><td><code id="hpilot_+3A_x0">x0</code></td>
<td>
<p>A numeric vector specifying a grid of covariate values.
</p>
</td></tr>
<tr><td><code id="hpilot_+3A_nnfrac">nnfrac</code></td>
<td>
<p>A numeric value giving the fraction of the sample size
that determines the order of the nearest neighbor. This is taken as
<code>floor(length(x)*nnfrac)</code>. The default is 0.25.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function computes a data-driven local pilot bandwidth,
required for the bootstrap bandwidth selector of the nonparametric
estimators of the cure rate and latency functions. Simulations
in López-Cheda et al. (2017) show that the choice of pilot bandwidth
has small effect on the bootstrap bandwidth. This pilot bandwidth only
depends on the sample size and the distribution of the covariate x
(see López-Cheda, 2018):
</p>
<p style="text-align: center;"><code class="reqn">g(x0) = 0.5(d_k^{+}(x0) + d_k^{-}(x0))(100/n)^{1/9}</code>
</p>

<p>where <code class="reqn">d_k^{+}(x0)</code> and <code class="reqn">d_k^{-}(x0)</code> are the distances from
<code class="reqn">x0</code> to the <code class="reqn">k</code>-th nearest neighbor on the right and the left,
respectively, and <code class="reqn">k</code> is a suitable integer depending on the
sample size <code class="reqn">n</code>. If there are not at least <code class="reqn">k</code> neighbors on
the right or on the left, we use <code class="reqn">d_k^{+}(x0) = d_k^{-}(x0)</code>. The
default value of <code class="reqn">k</code> is <code class="reqn">n/4</code>. The order
<code class="reqn">n^{-1/9}</code> satisfies the conditions in Theorem 1 of Li
and Datta (2001) and coincides with the order obtained by Cao and
González-Manteiga (1993) for the uncensored case.
</p>


<h3>Value</h3>

<p>A numeric vector of local pilot bandwidths corresponding to each
one of the values of the grid of covariate values given by <code>x0</code>.
</p>


<h3>Author(s)</h3>

<p>Ignacio López-de-Ullibarri [aut, cre],
Ana López-Cheda [aut],
Maria Amalia Jácome [aut]
</p>


<h3>References</h3>

<p>Cao R., González-Manteiga W. (1993). Bootstrap methods in
regression smoothing. Journal of Nonparametric Statistics, 2:
379-388. <a href="https://doi.org/10.1080/10485259308832566">https://doi.org/10.1080/10485259308832566</a>.
</p>
<p>Li, G., Datta, S. (2001). A bootstrap approach to nonparametric
regression for right censored data. Annals of the Institute of
Statistical Mathematics, 53(4):
708-729. <a href="https://doi.org/10.1023/A:1014644700806">https://doi.org/10.1023/A:1014644700806</a>.
</p>
<p>López-Cheda A. (2018). <em>Nonparametric Inference in Mixture Cure
Models</em>. PhD dissertation, Universidade da Coruña. Spain.
</p>
<p>López-Cheda, A., Cao, R., Jácome, M. A., Van Keilegom,
I. (2017). Nonparametric incidence estimation and bootstrap bandwidth
selection in mixture cure models. Computational Statistics &amp; Data
Analysis, 105:
144–165. <a href="https://doi.org/10.1016/j.csda.2016.08.002">https://doi.org/10.1016/j.csda.2016.08.002</a>.
</p>
<p>López-Cheda, A., Jácome, M. A., Cao, R. (2017). Nonparametric latency
estimation for mixture cure models. TEST, 26:
353–376. <a href="https://doi.org/10.1007/s11749-016-0515-1">https://doi.org/10.1007/s11749-016-0515-1</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+controlpars">controlpars</a></code>, <code><a href="#topic+latencyhboot">latencyhboot</a></code>,
<code><a href="#topic+probcurehboot">probcurehboot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Some artificial data
set.seed(123)
n &lt;- 50
x &lt;- runif(n, -2, 2) ## Covariate values
y &lt;- rweibull(n, shape = .5*(x + 4)) ## True lifetimes
c &lt;- rexp(n) ## Censoring values
p &lt;- exp(2*x)/(1 + exp(2*x)) ## Probability of being susceptible
u &lt;- runif(n)
t &lt;- ifelse(u &lt; p, pmin(y, c), c) ## Observed times
d &lt;- ifelse(u &lt; p, ifelse(y &lt; c, 1, 0), 0) ## Uncensoring indicator
data &lt;- data.frame(x = x, t = t, d = d)

## Computing pilot bandwidths for covariate values -1, -0.8, ..., 1
## by taking the 5-th nearest neighbor
hpilot(data$x, x0 = seq(-1, 1, by = .2), nnfrac = .05)
</code></pre>

<hr>
<h2 id='latency'>Compute Nonparametric Estimator of the Conditional Latency</h2><span id='topic+latency'></span>

<h3>Description</h3>

<p>This function computes the nonparametric estimator of the
conditional latency function proposed by López-Cheda et al. (2017).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>latency(x, t, d, dataset, x0, h, local = TRUE, testimate = NULL,
conflevel = 0L, bootpars = if (conflevel == 0 &amp;&amp; !missing(h)) NULL else
controlpars())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="latency_+3A_x">x</code></td>
<td>
<p>If <code>dataset</code> is missing, a numeric object giving the
covariate values. If <code>dataset</code> is a data frame, it is
interpreted as the name of the variable corresponding to the
covariate in the data frame.
</p>
</td></tr>
<tr><td><code id="latency_+3A_t">t</code></td>
<td>
<p>If <code>dataset</code> is missing, a numeric object giving the
observed times. If <code>dataset</code> is a data frame, it is interpreted
as the name of the variable corresponding to the observed times in
the data frame.
</p>
</td></tr>
<tr><td><code id="latency_+3A_d">d</code></td>
<td>
<p>If <code>dataset</code> is missing, an integer object giving the
values of the uncensoring indicator. Censored observations must be
coded as 0, uncensored ones as 1. If<code>dataset</code> is a data frame, it
is interpreted as the name of the variable corresponding to the
uncensoring indicator.
</p>
</td></tr>
<tr><td><code id="latency_+3A_dataset">dataset</code></td>
<td>
<p>An optional data frame in which the variables named in
<code>x</code>, <code>t</code> and <code>d</code> are interpreted. If it is missing,
<code>x</code>, <code>t</code> and <code>d</code> must be objects of the workspace.
</p>
</td></tr>
<tr><td><code id="latency_+3A_x0">x0</code></td>
<td>
<p>A numeric vector of covariate values where the latency
estimates will be computed.
</p>
</td></tr>
<tr><td><code id="latency_+3A_h">h</code></td>
<td>
<p>A numeric vector of bandwidths. If it is missing the default
is to use the local bootstrap bandwidth computed by the
<code>latencyhboot</code> function.
</p>
</td></tr>
<tr><td><code id="latency_+3A_local">local</code></td>
<td>
<p>A logical value, <code>TRUE</code> by default, specifying
whether local or global bandwidths are used.
</p>
</td></tr>
<tr><td><code id="latency_+3A_testimate">testimate</code></td>
<td>
<p>A numeric vector specifying the times at which the
latency is estimated. By default it is <code>NULL</code>, and then the
latency is estimated at the times given by <code>t</code>.
</p>
</td></tr>
<tr><td><code id="latency_+3A_conflevel">conflevel</code></td>
<td>
<p>A value controlling whether bootstrap confidence
intervals (CI) of the latency are to be computed. With the default
value, 0L, the CIs are not computed. If a numeric value 
between 0 and 1 is passed, it specifies the confidence level of the
CIs.
</p>
</td></tr>
<tr><td><code id="latency_+3A_bootpars">bootpars</code></td>
<td>
<p>A list of parameters controlling the bootstrap when
computing the CIs of the latency: <code>B</code>, the number of bootstrap
resamples, and <code>nnfrac</code>, the fraction of the sample size that
determines the order of the nearest neighbor used for choosing a
pilot bandwidth. If <code>h</code> is missing the list of parameters is
extended to be the same used for computing the bootstrap bandwidth
(see the help of <code>latencyhboot</code> for details). The default is
the value returned by the <code>controlpars</code> function called without
arguments. In case the CIs are not computed and <code>h</code> is not
missing the default is <code>NULL</code>. 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function computes the nonparametric estimator of the
conditional latency <code class="reqn">S_0(t | X = x_0) = P(Y&gt;t | Y&lt;\infty,
  X=x_0)</code>
proposed by López-Cheda et al. (2017). It is only available for a
continuous covariate <code class="reqn">X</code>.
</p>


<h3>Value</h3>

<p>An object of S3 class 'npcure'. Formally, a list of components:
</p>
<table>
<tr><td><code>type</code></td>
<td>
<p>The constant string &quot;latency&quot;.
</p>
</td></tr>
<tr><td><code>local</code></td>
<td>
<p>The value of the <code>local</code> argument.
</p>
</td></tr>
<tr><td><code>h</code></td>
<td>
<p>The value of the <code>h</code> argument, unless this is missing,
in which case its value is that of the cross-validation bandwidth.
</p>
</td></tr>
<tr><td><code>x0</code></td>
<td>
<p>The value of the <code>x0</code> argument.
</p>
</td></tr>
<tr><td><code>testim</code></td>
<td>
<p>The numeric vector of time values where the latency
function is estimated.
</p>
</td></tr>
<tr><td><code>S</code></td>
<td>
<p>A list whose components are the estimates of the latency
function for each one of the covariate values, i.e., those specified
by the <code>x0</code> argument. The latency estimates are given at the
times determined by the <code>testimate</code> argument.
</p>
</td></tr>
<tr><td><code>conf</code></td>
<td>
<p>A list of components <code>lower</code> and <code>upper</code> giving
the lower and the upper limits of the confidence intervals,
respectively.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Ignacio López-de-Ullibarri [aut, cre],
Ana López-Cheda [aut],
Maria Amalia Jácome [aut]
</p>


<h3>References</h3>

<p>López-Cheda, A., Jácome, M. A., Cao,
R. (2017). Nonparametric latency estimation for mixture cure
models. Test, 26:
353–376. <a href="https://doi.org/10.1007/s11749-016-0515-1">https://doi.org/10.1007/s11749-016-0515-1</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+controlpars">controlpars</a></code>, <code><a href="#topic+latencyhboot">latencyhboot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Some artificial data
set.seed(123)
n &lt;- 50
x &lt;- runif(n, -2, 2) ## Covariate values
y &lt;- rweibull(n, shape = .5*(x + 4)) ## True lifetimes
c &lt;- rexp(n) ## Censoring values
p &lt;- exp(2*x)/(1 + exp(2*x)) ## Probability of being susceptible
u &lt;- runif(n)
t &lt;- ifelse(u &lt; p, pmin(y, c), c) ## Observed times
d &lt;- ifelse(u &lt; p, ifelse(y &lt; c, 1, 0), 0) ## Uncensoring indicator
data &lt;- data.frame(x = x, t = t, d = d)

## Latency estimates for covariate value 0.5...
x0 &lt;- .5

## ... (a) with global bandwidths 0.5, 1, 2.
## By default, estimates are computed at the time values of 't'
S1 &lt;- latency(x, t, d, data, x0 = x0, h = c(.5, 1, 2), local = FALSE)
plot(S1$testim, S1$S$h0.5$x0.5, type = "s", xlab = "Time", ylab =
"Latency", ylim = c(0, 1))
lines(S1$testim, S1$S$h1$x0.5, type = "s", lty = 2)
lines(S1$testim, S1$S$h2$x0.5, type = "s", lty = 3)
## The true latency curve is plotted as reference
lines(S1$testim, pweibull(S1$testim, shape = .5*(x0 + 4), lower.tail =
FALSE), col = 2)
legend("topright", c(paste("Estimate, ", c("h = 0.5", "h = 1",
"h = 2")), "True"), lty = c(1:3, 1), col = c(rep(1, 3), 2))

## As before, but with estimates computed at times 0.1, 0.2,..., 1
S2 &lt;- latency(x, t, d, data, x0 = x0, h = c(.5, 1, 2), local = FALSE,
testimate = .1*(1:10))

## ... (b) with local bandwidth 2.
S3 &lt;- latency(x, t, d, data, x0 = x0, h = 2, local = TRUE)
#### Note that with only one covariate value the results with
#### 'local = FALSE' and 'local = TRUE' coincide, but the output formats
#### differ slightly. Compare with
S3 &lt;- latency(x, t, d, data, x0 = x0, h = 2, local = FALSE)

## ... (c) with local bootstrap bandwidth
b  &lt;- latencyhboot(x, t, d, data, x0 = x0)
S4 &lt;- latency(x, t, d, data, x0 = x0, h = b$h)

## ... (d) when the bandwidth is not specified, the bootstrap bandwidth
#### selector given by the 'latencyhboot' function is used by default.
#### The computation of 95% confidence intervals based on 1999 bootstrap
#### resamples is also illustrated
S5 &lt;- latency(x, t, d, data, x0 = x0, conflevel = .95, bootpars =
controlpars(B = 1999))
plot(S5$testim, S5$S$x0, type = "s", xlab = "Time", ylab = "Latency",
ylim = c(0, 1))
lines(S5$testim, S5$conf$x0$lower, type = "s", lty = 2)
lines(S5$testim, S5$conf$x0$upper, type = "s", lty = 2)
lines(S5$testim, pweibull(S5$testim, shape = .5*(x0 + 4), lower.tail =
FALSE), col = 2)
legend("topright", c("Estimate", "95% CI limits", "True"), lty = c(1,
2, 1), col = c(1, 1, 2))


## Example with the dataset 'bmt' of the 'KMsurv' package
## to study the survival of the uncured patients aged 25 and 40
data("bmt", package = "KMsurv")
x0 &lt;- c(25, 40)
S &lt;- latency(z1, t2, d3, bmt, x0 = x0, conflevel = .95)
## Plot of predicted latency curves and confidence intervals
plot(S$testim, S$S$x25, type = "s", xlab = "Time (days)",
ylab = "Latency", ylim = c(0,1))
lines(S$testim, S$conf$x25$lower, type = "s", lty = 2)
lines(S$testim, S$conf$x25$upper, type = "s", lty = 2)
lines(S$testim, S$S$x40, type = "s", lty = 1, col = 2)
lines(S$testim, S$conf$x40$lower, type = "s", lty = 2, col = 2)
lines(S$testim, S$conf$x40$upper, type = "s", lty = 2, col = 2)
legend("topright", c("Age 25: Estimate", "Age 25: 95% CI limits",
"Age 40: Estimate","Age 40: 95% CI limits"), lty = 1:2,
col = c(1, 1, 2, 2))

</code></pre>

<hr>
<h2 id='latencyhboot'>Compute the Bootstrap Bandwidth for the Nonparametric Estimator
of the Latency
</h2><span id='topic+latencyhboot'></span>

<h3>Description</h3>

<p>This function computes the bootstrap bandwidth for the
nonparametric estimator of the conditional latency function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>latencyhboot(x, t, d, dataset, x0, bootpars = controlpars())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="latencyhboot_+3A_x">x</code></td>
<td>
<p>If <code>dataset</code> is missing, a numeric object giving the
covariate values. If <code>dataset</code> is a data frame, it is
interpreted as the name of the variable corresponding to the
covariate in the data frame.
</p>
</td></tr>
<tr><td><code id="latencyhboot_+3A_t">t</code></td>
<td>
<p>If <code>dataset</code> is missing, a numeric object giving the
observed times. If <code>dataset</code> is a data frame, it is interpreted
as the name of the variable corresponding to the observed times in
the data frame.
</p>
</td></tr>
<tr><td><code id="latencyhboot_+3A_d">d</code></td>
<td>
<p>If <code>dataset</code> is missing, an integer object giving the
values of the uncensoring indicator. Censored observations must be
coded as 0, uncensored ones as 1. If <code>dataset</code> is a data frame,
it is interpreted as the name of the variable corresponding to the
uncensoring indicator in the data frame.
</p>
</td></tr>
<tr><td><code id="latencyhboot_+3A_dataset">dataset</code></td>
<td>
<p>An optional data frame in which the variables named in
<code>x</code>, <code>t</code> and <code>indicator</code> are interpreted. If it is
missing, <code>x</code>, <code>t</code> and <code>indicator</code> must be objects
of the workspace.
</p>
</td></tr>
<tr><td><code id="latencyhboot_+3A_x0">x0</code></td>
<td>
<p>A numeric vector of covariate values where the local
bootstrap bandwidth will be computed.
</p>
</td></tr>
<tr><td><code id="latencyhboot_+3A_bootpars">bootpars</code></td>
<td>
<p>A list of parameters controlling the process of
bandwidth selection. The default is the value returned by the
<code>controlpars</code> function called without arguments.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function computes the bootstrap bandwidth selector for the
nonparametric estimator of the conditional latency function at the
covariate values given by <code>x0</code>. The bootstrap bandwidth is the
minimizer of a bootstrap version of the Mean Integrated Squared Error
(MISE) of the latency estimator, which is approximated by Monte Carlo
by simulating a large number of bootstrap resamples, <code>B</code>. For
each value of <code>x0</code>, the bootstrap MISE is the bootstrap
expectation of the integrated difference between the value of the
latency estimator computed with the bootstrap sample in a grid of
bandwidths and its value computed with the original sample and a pilot
bandwidth. The bootstrap resamples are generated by using the simple
weighted bootstrap resampling method, fixing the covariate. This
method is equivalent to the simple weighted bootstrap of Li and Datta
(2001). All the parameters typically involved in the bootstrap
bandwidth selection process (number of bootstrap resamples, grid of
bandwidths, pilot bandwidth, and right boundary of the integration
interval for computing the MISE) are typically set through the
<code>controlpars</code> function, whose output is passed to the
<code>bootpars</code> argument. Also, the bootstrap bandwidths can be
smoothed, and, if so, the smoothed bandwidths are returned as a
separate component of the output. See the help of <code>controlpars</code>
for details.
</p>


<h3>Value</h3>

<p>An object of S3 class 'npcure'. Formally, a list of components:
</p>
<table>
<tr><td><code>type</code></td>
<td>
<p>The constant character string c(&quot;Bootstrap bandwidth&quot;,
&quot;latency&quot;).
</p>
</td></tr>
<tr><td><code>x0</code></td>
<td>
<p>Grid of covariate values.
</p>
</td></tr>
<tr><td><code>h</code></td>
<td>
<p>Selected local bootstrap bandwidths.
</p>
</td></tr>
<tr><td><code>hsmooth</code></td>
<td>
<p>Smoothed selected local bootstrap bandwidths (optional)
</p>
</td></tr>
<tr><td><code>hgrid</code></td>
<td>
<p>Grid of bandwidths used (optional).
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Ignacio López-de-Ullibarri [aut, cre],
Ana López-Cheda [aut],
Maria Amalia Jácome [aut]
</p>


<h3>References</h3>

<p>Li, G., Datta, S. (2001). A bootstrap approach to
nonparametric regression for right censored data. Annals of the
Institute of Statistical Mathematics, 53:
708–729. <a href="https://doi.org/10.1023/A:1014644700806">https://doi.org/10.1023/A:1014644700806</a>.
</p>
<p>López-Cheda, A., Jácome, M. A., Cao, R. (2017). Nonparametric latency
estimation for mixture cure models. TEST, 26:
353–376. <a href="https://doi.org/10.1007/s11749-016-0515-1">https://doi.org/10.1007/s11749-016-0515-1</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+controlpars">controlpars</a></code>, <code><a href="#topic+latency">latency</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Some artificial data
set.seed(123)
n &lt;- 50
x &lt;- runif(n, -2, 2) ## Covariate values
y &lt;- rweibull(n, shape = .5*(x + 4)) ## True lifetimes
c &lt;- rexp(n) ## Censoring values
p &lt;- exp(2*x)/(1 + exp(2*x)) ## Probability of being susceptible
u &lt;- runif(n)
t &lt;- ifelse(u &lt; p, pmin(y, c), c) ## Observed times
d &lt;- ifelse(u &lt; p, ifelse(y &lt; c, 1, 0), 0) ## Uncensoring indicator
data &lt;- data.frame(x = x, t = t, d = d)

## A vector of covariate values
vecx0 &lt;- seq(-1.5, 1.5, by = .1)

## Computation of bootstrap local bandwidths at the values of 'vecx0'...
#### ... with the default control parameters
hb1 &lt;- latencyhboot(x, t, d, data, x0 = vecx0)

#### ... changing the default 'bootpars' with 'controlpars()':
#### (a) 'B = 1999' (1999 bootstrap resamples are generated),
#### (b) 'hbound = c(.2, 4)' and 'hl = 50' (a grid of 50 bandwidths
#### between 0.2 and 4 times the standardized interquartile range of
#### the covariate values is built), and
#### (c) 'hsave = TRUE' (the grid bandwidths are saved), and

hb2 &lt;- latencyhboot(x, t, d, data, x0 = vecx0, bootpars =
controlpars(B = 1999, hbound = c(.2, 4), hl = 50, hsave = TRUE))

## Estimates of the conditional latency at the covariate value x0 = 0
## with the selected bootstrap bandwidths
S1 &lt;- latency(x, t, d, data, x0 = 0, h = hb1$h[hb1$x0 == 0])
S2 &lt;- latency(x, t, d, data, x0 = 0, h = hb2$h[hb2$x0 == 0])

## A plot comparing the estimates with bootstrap bandwidths obtained
## with default and non-default 'bootpars'
plot(S1$testim, S1$S$x0, type = "s", xlab = "Time", ylab = "Latency",
ylim = c(0, 1))
lines(S2$testim, S2$S$x0, type = "s", lty = 2)
lines(S1$testim, pweibull(S1$testim, shape = .5*(0 + 4), lower.tail =
FALSE), col = 2)
legend("topright", c("Estimate with 'hb1'", "Estimate with 'hb2'",
"True"), lty = c(1, 2, 1), col = c(1, 1, 2))

## Example with the dataset 'bmt' of the 'KMsurv' package
## to study the survival of the uncured patients aged 25 and 40
data("bmt", package = "KMsurv")
x0 &lt;- c(25, 40)
hb &lt;- latencyhboot(z1, t2, d3, bmt, x0 = x0, bootpars = controlpars(B =
1999, hbound = c(.2, 4), hl = 150, hsave = TRUE))
S0 &lt;- latency(z1, t2, d3, bmt, x0 = x0, hb$h, conflevel = .95)
## Plot of predicted latency curves and confidence bands
plot(S0$testim, S0$S$x25, type = "s", xlab = "Time (days)",
ylab = "Survival", ylim = c(0,1))
lines(S0$testim, S0$conf$x25$lower, type = "s", lty = 2)
lines(S0$testim, S0$conf$x25$upper, type = "s", lty = 2)
lines(S0$testim, S0$S$x40, type = "s", lty = 1, col = 2)
lines(S0$testim, S0$conf$x40$lower, type = "s", lty = 2, col = 2)
lines(S0$testim, S0$conf$x40$upper, type = "s", lty = 2, col = 2)
legend("topright", c("Age 25: Estimate", "Age 25: 95% CI limits",
"Age 40: Estimate", "Age 40: 95% CI limits"), lty = 1:2,
col = c(1, 1, 2, 2)) 

</code></pre>

<hr>
<h2 id='npcure-package'>Nonparametric Estimation in Mixture Cure Models</h2><span id='topic+npcure-package'></span><span id='topic+npcure'></span>

<h3>Description</h3>

<p>Performs nonparametric estimation in mixture cure models, and significance tests for the cure probability. For details, see López-Cheda et al. (2017a) &lt;doi:10.1016/j.csda.2016.08.002&gt; and López-Cheda et al. (2017b) &lt;doi:10.1007/s11749-016-0515-1&gt;.</p>


<h3>Details</h3>


<p>Index of help topics:
</p>
<pre>
beran                   Compute Beran's Estimator of the Conditional
                        Survival
berancv                 Compute the Cross-Validation Bandwidth for
                        Beran's Estimator of the Conditional Survival
controlpars             Control Values for the Bootstrap or
                        Cross-validation
hpilot                  Compute the Pilot Bandwidth for the
                        Nonparametric Estimators of Cure Probability
                        and Latency
latency                 Compute Nonparametric Estimator of the
                        Conditional Latency
latencyhboot            Compute the Bootstrap Bandwidth for the
                        Nonparametric Estimator of the Latency
npcure-package          Nonparametric Estimation in Mixture Cure Models
print.npcure            Print Method for Objects of Class 'npcure'
probcure                Compute Nonparametric Estimator of the
                        Conditional Probability of Cure
probcurehboot           Compute the Bootstrap Bandwidth for the
                        Nonparametric Estimator of the Cure Probability
summary.npcure          Summary Method for Objects of Class 'npcure'
testcov                 Covariate Significance Test of the Cure
                        Probability
testmz                  Test of Maller-Zhou
</pre>

<h3>Author(s)</h3>

<p>Ignacio López-de-Ullibarri [aut, cre],
Ana López-Cheda [aut],
Maria Amalia Jácome [aut]
</p>


<h3>References</h3>

<p>López-Cheda, A., Cao, R., Jácome, M. A., Van Keilegom,
I. (2017). Nonparametric incidence estimation and bootstrap bandwidth
selection in mixture cure models. Computational Statistics &amp; Data
Analysis 105: 144–165. <a href="https://doi.org/10.1016/j.csda.2016.08.002">https://doi.org/10.1016/j.csda.2016.08.002</a>.
</p>
<p>López-Cheda, A., Jácome, M. A., Cao, R. (2017). Nonparametric latency
estimation for mixture cure models. Test, 26:
353–376. <a href="https://doi.org/10.1007/s11749-016-0515-1">https://doi.org/10.1007/s11749-016-0515-1</a>.
</p>

<hr>
<h2 id='print.npcure'>Print Method for Objects of Class 'npcure'
</h2><span id='topic+print.npcure'></span>

<h3>Description</h3>

<p>This function implements a print method for 'npcure'
objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'npcure'
print(x, how, head = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.npcure_+3A_x">x</code></td>
<td>
<p>An object of class 'npcure'.
</p>
</td></tr>
<tr><td><code id="print.npcure_+3A_how">how</code></td>
<td>
<p>A character string with values &quot;wide&quot; or &quot;long&quot;. If
missing, the function itself chooses a convenient default.
</p>
</td></tr>
<tr><td><code id="print.npcure_+3A_head">head</code></td>
<td>
<p>A logical value that controls whether the function's
output must be abbreviated (<code>TRUE</code>) or not (<code>FALSE</code>,
the default). 
</p>
</td></tr>
<tr><td><code id="print.npcure_+3A_...">...</code></td>
<td>
<p>Further optional arguments. Excepting for <code>n</code>, which
controls how many lines are printed when <code>head = TRUE</code>, these are
the arguments for the default method (i.e., <code>print.default</code>) of
the <code>print</code> generic function.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A formatted output.</p>


<h3>Author(s)</h3>

<p>Ignacio López-de-Ullibarri [aut, cre],
Ana López-Cheda [aut],
Maria Amalia Jácome [aut]
</p>


<h3>See Also</h3>

<p><code><a href="#topic+summary.npcure">summary.npcure</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Some artificial data
set.seed(123)
n &lt;- 50
x &lt;- runif(n, -2, 2) ## Covariate values
y &lt;- rweibull(n, shape = .5*(x + 4)) ## True lifetimes
c &lt;- rexp(n) ## Censoring values
p &lt;- exp(2*x)/(1 + exp(2*x)) ## Probability of being susceptible
u &lt;- runif(n)
t &lt;- ifelse(u &lt; p, pmin(y, c), c) ## Observed times
d &lt;- ifelse(u &lt; p, ifelse(y &lt; c, 1, 0), 0) ## Uncensoring indicator
data &lt;- data.frame(x = x, t = t, d = d)

## Calling 'print()' with an object of class 'npcure' created by
## 'latency()' 
S1 &lt;- latency(x, t, d, data, x0 = c(0, .5), h = c(1, 1.5))

## In this case (latency estimation with local bandwidths and without
## confidence bands), the 'wide' format is used by default
S1
print(S1, how = "wide")
print(S1, how = "long")

## How to control the number of significant digits of the output, and
## how to abbreviate the output 
print(S1, digits = 5, head = TRUE, n = 4)

## Calling 'print()' with a 'npcure' object created by 'probcure()'
q1 &lt;- probcure(x, t, d, data, x0 = c(0, .5), h = c(.5, 1, 1.5), local =
FALSE, conflevel = .95)

## Only the 'long' format is available when confidence bands are
## computed
q1
print(q1, how = "long")
print(q1, how = "wide")
</code></pre>

<hr>
<h2 id='probcure'>Compute Nonparametric Estimator of the Conditional Probability of
Cure
</h2><span id='topic+probcure'></span>

<h3>Description</h3>

<p>This function computes the nonparametric estimator of the
conditional probability of cure proposed by Xu and Peng (2014).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>probcure(x, t, d, dataset, x0, h, local = TRUE, conflevel = 0L,
bootpars = if (conflevel == 0 &amp;&amp; !missing(h)) NULL else controlpars())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="probcure_+3A_x">x</code></td>
<td>
<p>If <code>dataset</code> is missing, a numeric object giving the
covariate values. If <code>dataset</code> is a data frame, it is
interpreted as the name of the variable corresponding to the
covariate in the data frame.
</p>
</td></tr>
<tr><td><code id="probcure_+3A_t">t</code></td>
<td>
<p>If <code>dataset</code> is missing, a numeric object giving the
observed times. If <code>dataset</code> is a data frame, it is interpreted 
as the name of the variable corresponding to the observed times in
the data frame.
</p>
</td></tr>
<tr><td><code id="probcure_+3A_d">d</code></td>
<td>
<p>If <code>dataset</code> is missing, an integer object giving the
values of the uncensoring indicator. Censored observations must be
coded as 0, uncensored ones as 1. If <code>dataset</code> is a data frame,
it is interpreted as the name of the variable corresponding to the
uncensoring indicator in the data frame.
</p>
</td></tr>
<tr><td><code id="probcure_+3A_dataset">dataset</code></td>
<td>
<p>An optional data frame in which the variables named in
<code>x</code>, <code>t</code> and <code>d</code> are interpreted. If it is missing,
<code>x</code>, <code>t</code> and <code>d</code> must be objects of the workspace.
</p>
</td></tr>
<tr><td><code id="probcure_+3A_x0">x0</code></td>
<td>
<p>A numeric vector of covariate values where the estimates
of cure probability will be computed.
</p>
</td></tr>
<tr><td><code id="probcure_+3A_h">h</code></td>
<td>
<p>A numeric vector of bandwidths. If it is missing the default
is to use the local bootstrap bandwidth computed by the
<code>probcurehboot</code> function.
</p>
</td></tr>
<tr><td><code id="probcure_+3A_local">local</code></td>
<td>
<p>A logical value, <code>TRUE</code> by default, specifying
whether local or global bandwidths are used.
</p>
</td></tr>
<tr><td><code id="probcure_+3A_conflevel">conflevel</code></td>
<td>
<p>A value controlling whether bootstrap confidence
intervals (CI) of the cure probability are to be computed. With the
default value, 0L, the CIs are not computed. If a numeric value
between 0 and 1 is passed, it specifies the confidence level of the
CIs.
</p>
</td></tr>
<tr><td><code id="probcure_+3A_bootpars">bootpars</code></td>
<td>
<p>A list of parameters controlling the bootstrap when
computing either the CIs of the cure probability or the bootstrap
bandwidth (if <code>h</code> is missing): <code>B</code>, the number of bootstrap
resamples, and <code>nnfrac</code>, the fraction of the sample size that
determines the order of the nearest neighbor used for choosing a pilot
bandwidth. The default is the value returned by the <code>controlpars</code>
function called without arguments. If the CIs are not computed and
<code>h</code> is not missing the default is <code>NULL</code>.
</p>
</td></tr> 
</table>


<h3>Details</h3>

<p>The function computes the nonparametric estimator of the
conditional cure probability <code class="reqn">q(X = x_0) \equiv 1 - p(X =
  x_0)= P(Y=\infty | X=x_0)</code> proposed by Xu and Peng (2014), and also studied
by López-Cheda et al (2017). It is only available for a continuous
covariate <code class="reqn">X</code>.
</p>


<h3>Value</h3>

<p>An object of S3 class 'npcure'. Formally, a list of components:
</p>
<table>
<tr><td><code>estimate</code></td>
<td>
<p>The constant string &quot;cure&quot;.
</p>
</td></tr>
<tr><td><code>local</code></td>
<td>
<p>The value of the <code>local</code> argument.
</p>
</td></tr>
<tr><td><code>h</code></td>
<td>
<p>The value of the <code>h</code> argument, unless this is missing,
in which case its value is that of the bootstrap bandwidth.
</p>
</td></tr>
<tr><td><code>x0</code></td>
<td>
<p>The value of the <code>x0</code> argument.
</p>
</td></tr>
<tr><td><code>q</code></td>
<td>
<p>A list with the estimates of the probability of cure.
</p>
</td></tr>
<tr><td><code>conf</code></td>
<td>
<p>A list of components <code>lower</code> and <code>upper</code> giving
the lower and the upper limits of the confidence intervals,
respectively.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Ignacio López-de-Ullibarri [aut, cre],
Ana López-Cheda [aut],
Maria Amalia Jácome [aut]
</p>


<h3>References</h3>

<p>López-Cheda, A., Cao, R., Jácome, M. A., Van Keilegom,
I. (2017). Nonparametric incidence estimation and bootstrap bandwidth
selection in mixture cure models. Computational Statistics &amp; Data
Analysis, 105:
144–165. <a href="https://doi.org/10.1016/j.csda.2016.08.002">https://doi.org/10.1016/j.csda.2016.08.002</a>.
</p>
<p>Xu, J., Peng, Y. (2014). Nonparametric cure rate estimation with
covariates. The Canadian Journal of Statistics 42:
1-17. <a href="https://doi.org/10.1002/cjs.11197">https://doi.org/10.1002/cjs.11197</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+controlpars">controlpars</a></code>, <code><a href="#topic+probcurehboot">probcurehboot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Some artificial data
set.seed(123)
n &lt;- 50
x &lt;- runif(n, -2, 2) ## Covariate values
y &lt;- rweibull(n, shape = 0.5 * (x + 4)) ## True lifetimes
c &lt;- rexp(n) ## Censoring values
p &lt;- exp(2*x)/(1 + exp(2*x)) ## Probability of being susceptible
u &lt;- runif(n)
t  &lt;- ifelse(u &lt; p, pmin(y, c), c) ## Observed times
d  &lt;- ifelse(u &lt; p, ifelse(y &lt; c, 1, 0), 0) ## Uncensoring indicator
data &lt;- data.frame(x = x, t = t, d = d)

## Covariate values where cure probability is estimated 
x0 &lt;- seq(-1.5, 1.5, by = 0.1) 

## Nonparametric estimates of cure probability at 'x0'...

## ... (a) with global bandwidths 1, 1.5, 2  
q1 &lt;- probcure(x, t, d, data, x0 = x0, h = c(1, 1.5, 2), local = FALSE)

#### Plot predicted cure probabilities at 'x0' for each bandwidth in 'h'
#### (the true cure probability is displayed for reference)
plot(q1$x0, q1$q$h1, type = "l", xlab = "Covariate", ylab =
"Cure probability", ylim = c(0, 1))
lines(q1$x0, q1$q$h1.5, lty = 2)
lines(q1$x0, q1$q$h2, lty = 3)
lines(q1$x0, 1 - exp(2*q1$x0)/(1 + exp(2*q1$x0)), col = 2)
legend("topright", c(paste("Estimate, ", c("h = 1", "h = 1.5",
"h = 2")), "True"), lty = c(1, 2, 3, 1), col = c(1, 1, 1, 2))

## ... (b) with local bandwidths (default)
#### (the vectors passed to 'x0' and 'h' must have the same length)
q2 &lt;- probcure(x, t, d, data, x0 = x0, h = seq(1, 2.5, along = x0)) 

## ... (c) with local bootstrap bandwidths (based on 1999 booostrap
#### resamples). Besides, 95% confidence intervals are computed  and
#### smoothed (with a 15-th order moving average)
set.seed(1) ## Not needed, just for reproducibility.
hb &lt;- probcurehboot(x, t, d, data, x0 = x0, bootpars = controlpars(B =
1999, hsmooth = 15))
q3 &lt;- probcure(x, t, d, data, x0 = x0, h = hb$hsmooth, conflevel = .95,
bootpars = controlpars(B = 1999))


## ... (d) If the bandwidth is not specified, the local bootstrap
#### bandwidth is used (same results as in (c))
set.seed(1) ## Not needed, just for reproducibility.
q4 &lt;- probcure(x, t, d, data, x0 = x0, conflevel = .95, bootpars =
controlpars(B = 1999, hsmooth = 15))

#### Plot of the estimated cure probabilities evaluated at 'x0'
#### (true cure rate displayed as reference)
plot (q4$x0, q4$q, type = "l", ylim = c(0, 1), xlab = "Covariate X",
ylab = "Cure probability")
lines(q4$x0, q4$conf$lower, lty = 2)
lines(q4$x0, q4$conf$upper, lty = 2)
lines(q4$x0, 1-exp(2 * q4$x0)/(1 + exp(2 * q4$x0)), col = 2)
legend("topright", c("Estimate", "95% CI limits", "True"),
lty = c(1, 2, 1), col = c(1, 1, 2))

## Example with the dataset 'bmt' in the 'KMsurv' package
## to study the probability of cure as a function of the age (z1).
data("bmt", package = "KMsurv")
x0 &lt;- seq(quantile(bmt$z1, .05), quantile(bmt$z1, .95), length.out = 100)
q.age &lt;- probcure(z1, t2, d3, bmt, x0 = x0, conflevel = .95, bootpars =
controlpars(B = 1999, hsmooth = 10)) 

## Plot of estimated cure probability and confidence intervals
par(mar = c(5, 4, 4, 5) + .1)
plot(q.age$x0, q.age$q, type = "l", ylim = c(0, 1), xlab =
"Patient age (years)", ylab = "Cure probability")
lines(q.age$x0, q.age$conf$lower, lty = 2)
lines(q.age$x0, q.age$conf$upper, lty = 2)
## The estimated density of age (z1) is added for reference
par(new = TRUE)
d.age &lt;- density(bmt$z1)
plot(d.age, xaxt = "n", yaxt = "n", xlab = "", ylab = "", col = 2,
main = "", zero.line = FALSE)
mtext("Density", side = 4, col = 2, line = 3) 
axis(4, ylim = c(0, max(d.age$y)), col = 2, col.axis = 2)
legend("topright", c("Estimate", "95% CI limits", "Covariate density"),
lty = c(1, 2, 1), col = c(1, 1, 2))

</code></pre>

<hr>
<h2 id='probcurehboot'>Compute the Bootstrap Bandwidth for the Nonparametric Estimator
of the Cure Probability
</h2><span id='topic+probcurehboot'></span>

<h3>Description</h3>

<p>This function computes the bootstrap bandwidth for the
nonparametric estimator of the conditional probability of cure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>probcurehboot(x, t, d, dataset, x0, bootpars = controlpars())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="probcurehboot_+3A_x">x</code></td>
<td>
<p>If <code>dataset</code> is missing, a numeric object giving the
covariate values. If <code>dataset</code> is a data frame, it is
interpreted as the name of the variable corresponding to the
covariate in the data frame.
</p>
</td></tr>
<tr><td><code id="probcurehboot_+3A_t">t</code></td>
<td>
<p>If <code>dataset</code> is missing, a numeric object giving the
observed times. If <code>dataset</code> is a data frame, it is interpreted
as the name of the variable corresponding to the observed times in
the data frame.
</p>
</td></tr>
<tr><td><code id="probcurehboot_+3A_d">d</code></td>
<td>
<p>If <code>dataset</code> is missing, an integer object giving the
values of the uncensoring indicator. Censored observations must be
coded as 0, uncensored ones as 1. If <code>dataset</code> is a data frame,
it is interpreted as the name of the variable corresponding to the
uncensoring indicator in the data frame.
</p>
</td></tr>
<tr><td><code id="probcurehboot_+3A_dataset">dataset</code></td>
<td>
<p>An optional data frame in which the variables named in
<code>x</code>, <code>t</code> and <code>indicator</code> are interpreted. If it is
missing, <code>x</code>, <code>t</code> and <code>indicator</code> must be objects
of the workspace.
</p>
</td></tr>
<tr><td><code id="probcurehboot_+3A_x0">x0</code></td>
<td>
<p>A numeric vector of covariate values where the local
bootstrap bandwidth will be computed.
</p>
</td></tr>
<tr><td><code id="probcurehboot_+3A_bootpars">bootpars</code></td>
<td>
<p>A list of parameters controlling the process of
bandwidth selection. The default is the value returned by the
<code>controlpars</code> function called without arguments.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function computes the bootstrap bandwidth selector for the
nonparametric estimator of the cure probability at the covariate
values given by <code>x0</code>. The bootstrap bandwidth is the minimizer of
a bootstrap version of the Mean Squared Error (MSE) of the cure rate
estimator, which is approximated by Monte Carlo by simulating a large
number, <code>B</code>, of bootstrap resamples. The bootstrap MSE is the
bootstrap expectation of the difference between the value of the cure
rate estimator computed with the bootstrap sample in a grid of
bandwidths and its value computed with the original sample and a pilot
bandwidth. The bootstrap resamples are generated by using the simple
weighted bootstrap resampling method, fixing the covariate. This
method is equivalent to the simple weighted bootstrap of Li and Datta
(2001). All the parameters involved in the bootstrap bandwidth
selection process (number of bootstrap resamples, grid of bandwidths,
and pilot bandwidth) are typically set through the <code>controlpars</code>
function, whose output is passed to the <code>bootpars</code>
argument. See the help of <code>controlpars</code> for details.
</p>
<p>Given the local nature of bootstrap bandwidth selection, estimates
obtained from sets of bootstrap bandwidths may sometimes look
wiggly. To counter this behavior, the selected vector of bootstrap
bandwidths can be smoothed by computing a moving average (its order
being set by <code>controlpars</code>). Then, the smoothed bandwidths are
contained in the <code>hsmooth</code> component of the returned value.
</p>


<h3>Value</h3>

<p>An object of S3 class 'npcure'. Formally, a list of components:
</p>
<table>
<tr><td><code>type</code></td>
<td>
<p>The constant character string c(&quot;Bootstrap bandwidth&quot;,
&quot;cure&quot;).
</p>
</td></tr>
<tr><td><code>x0</code></td>
<td>
<p>Grid of covariate values.
</p>
</td></tr>
<tr><td><code>h</code></td>
<td>
<p>Selected local bootstrap bandwidths.
</p>
</td></tr>
<tr><td><code>hsmooth</code></td>
<td>
<p>Smoothed selected local bootstrap bandwidths (optional)
</p>
</td></tr>
<tr><td><code>hgrid</code></td>
<td>
<p>Grid of bandwidths used (optional).
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Ignacio López-de-Ullibarri [aut, cre],
Ana López-Cheda [aut],
Maria Amalia Jácome [aut]
</p>


<h3>References</h3>

<p>Li, G., Datta, S. (2001). A bootstrap approach to
nonparametric regression for right censored data. Annals of the
Institute of Statistical Mathematics, 53:
708-729. <a href="https://doi.org/10.1023/A:1014644700806">https://doi.org/10.1023/A:1014644700806</a>.
</p>
<p>López-Cheda, A., Cao, R., Jácome, M. A., Van Keilegom,
I. (2017). Nonparametric incidence estimation and bootstrap bandwidth
selection in mixture cure models. Computational Statistics &amp; Data
Analysis, 105:
144–165. <a href="https://doi.org/10.1016/j.csda.2016.08.002">https://doi.org/10.1016/j.csda.2016.08.002</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+controlpars">controlpars</a></code>, <code><a href="#topic+probcure">probcure</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Some artificial data
set.seed(123)
n &lt;- 50
x &lt;- runif(n, -2, 2) ## Covariate values
y &lt;- rweibull(n, shape = .5*(x + 4)) ## True lifetimes
c &lt;- rexp(n) ## Censoring values
p &lt;- exp(2*x)/(1 + exp(2*x)) ## Probability of being susceptible
u &lt;- runif(n)
t &lt;- ifelse(u &lt; p, pmin(y, c), c) ## Observed times
d &lt;- ifelse(u &lt; p, ifelse(y &lt; c, 1, 0), 0) ## Uncensoring indicator
data &lt;- data.frame(x = x, t = t, d = d)

## A vector of covariate values 
vecx0 &lt;- seq(-1.5, 1.5, by = .1)

## Computation of bootstrap local bandwidth at the values of 'vecx0'...
#### ... with the default control parameters
set.seed(1) ## Not needed, just for reproducibility.
hb1 &lt;- probcurehboot(x, t, d, data, x0 = vecx0)

#### ... changing the default 'bootpars' through 'controlpars()', with
#### arguments:
#### (a) 'B = 1999' (1999 bootstrap resamples are generated),
#### (b) 'hbound = c(.2, 4)' and 'hl = 50' (a grid of 50 bandwidths
#### between 0.2 and 4 times the standardized interquartilic range of
#### the covariate values is built),
#### (c) 'hsave = TRUE' (the grid bandwidths are saved), and
#### (d) 'hsmooth = 7' (the bootstrap bandwidths are smoothed by a
#### moving average of 7-th order)
set.seed(1) ## Not needed, just for reproducibility.
hb2 &lt;- probcurehboot(x, t, d, data, x0 = vecx0, bootpars =
controlpars(B = 1999, hbound = c(.2, 4), hl = 50, hsave = TRUE, hsmooth
= 7)) 

## Estimates of the conditional probability of cure at the covariate
## values of 'vecx0' with the selected bootstrap bandwidths
q1 &lt;- probcure(x, t, d, data, x0 = vecx0, h = hb1$h)
q2 &lt;- probcure(x, t, d, data, x0 = vecx0, h = hb2$h)
q2sm &lt;- probcure(x, t, d, data, x0 = vecx0, h = hb2$hsmooth)

## A plot comparing the estimates obtained with the bootstrap bandwidths
plot(q1$x0, q1$q, type = "l", xlab = "Covariate", ylab =
"Cure probability", ylim = c(0,1))
lines(q2$x0, q2$q, type = "l", lty = 2)
lines(q2sm$x0, q2sm$q, type = "l", lty = 3)
lines(q1$x0, 1 - exp(2*q1$x0)/(1 + exp(2*q1$x0)), col = 2)
legend("topright", c("Estimate with 'hb1'", "Estimate with 'hb2'",
"Estimate with 'hb2' smoothed", "True"), lty = c(1, 2, 3, 1), col = c(1,
1, 1, 2)) 


## Example with the dataset 'bmt' of the 'KMsurv' package
## to study the probability of cure as a function of the age (z1).
data("bmt", package = "KMsurv")
x0 &lt;- seq(quantile(bmt$z1, .05), quantile(bmt$z1, .95), length.out =
100)
## This might take a while
hb &lt;- probcurehboot(z1, t2, d3, bmt, x0 = x0, bootpars =
controlpars(B = 1999, hbound = c(.2, 2), hl = 50, hsave = TRUE, hsmooth
= 10))
q.age &lt;- probcure(z1, t2, d3, bmt, x0 = x0, h = hb$h)
q.age.smooth &lt;- probcure(z1, t2, d3, bmt, x0 = x0, h = hb$hsmooth)

## Plot of estimated cure probability
plot(q.age$x0, q.age$q, type = "l", ylim = c(0, 1), xlab =
"Patient age (years)", ylab = "Cure probability")
lines(q.age.smooth$x0, q.age.smooth$q, col = 2)
legend("topright", c("Estimate with h bootstrap",
"Estimate with smoothed h bootstrap"), lty = 1, col = 1:2)

</code></pre>

<hr>
<h2 id='summary.npcure'>Summary Method for Objects of Class 'npcure'
</h2><span id='topic+summary.npcure'></span>

<h3>Description</h3>

<p>This function prints a summary of a 'npcure' object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'npcure'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.npcure_+3A_object">object</code></td>
<td>
<p>An object of class 'npcure'.
</p>
</td></tr>
<tr><td><code id="summary.npcure_+3A_...">...</code></td>
<td>
<p>Further optional arguments for the default method
(i.e., <code>summary.default</code>) of the <code>summary</code> generic
function. 
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A compact summary showing the components of the object.
</p>


<h3>Author(s)</h3>

<p>Ignacio López-de-Ullibarri [aut, cre],
Ana López-Cheda [aut],
Maria Amalia Jácome [aut]
</p>


<h3>See Also</h3>

<p><code><a href="#topic+print.npcure">print.npcure</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Some artificial data
set.seed(123)
n &lt;- 50
x &lt;- runif(n, -2, 2) ## Covariate values
y &lt;- rweibull(n, shape = .5*(x + 4)) ## True lifetimes
c &lt;- rexp(n) ## Censoring values
p &lt;- exp(2*x)/(1 + exp(2*x)) ## Probability of being susceptible
u &lt;- runif(n)
t &lt;- ifelse(u &lt; p, pmin(y, c), c) ## Observed times
d &lt;- ifelse(u &lt; p, ifelse(y &lt; c, 1, 0), 0) ## Uncensoring indicator
data &lt;- data.frame(x = x, t = t, d = d)

## Calling 'summary()' with an object of class 'npcure' created by
## 'latency()' 
S1 &lt;- latency(x, t, d, data, x0 = c(0, .5), h = c(1, 1.5))
summary(S1)

## If needed, the number of significant digits of the output can be set
summary(S1, digits = 5)

## Calling 'summary()' with an object created by 'probcure()'
q1 &lt;- probcure(x, t, d, data, x0 = c(0, .5), h = c(.5, 1, 1.5), local =
FALSE, conflevel = .95)
summary(q1)
</code></pre>

<hr>
<h2 id='testcov'>Covariate Significance Test of the Cure Probability</h2><span id='topic+testcov'></span>

<h3>Description</h3>

<p>This function carries out a significance test of covariate
effect on the probability of cure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>testcov(x, t, d, dataset, bootpars = controlpars())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="testcov_+3A_x">x</code></td>
<td>
<p>If <code>dataset</code> is missing, an object giving the covariate
values, whose type can be numeric, integer, factor or character.
If<code>dataset</code> is a data frame, it is interpreted as the name of
the variable corresponding to the covariate in the data frame.
</p>
</td></tr>
<tr><td><code id="testcov_+3A_t">t</code></td>
<td>
<p>If <code>dataset</code> is missing, a numeric object giving the
observed times. If <code>dataset</code> is a data frame, it is
interpreted as the name of the variable corresponding to the
observed times in the data frame.
</p>
</td></tr>
<tr><td><code id="testcov_+3A_d">d</code></td>
<td>
<p>If <code>dataset</code> is missing, an integer object giving the
values of the uncensoring indicator. Censored observations must be
coded as 0, uncensored ones as 1. If <code>dataset</code> is a data frame,
it is interpreted as the name of the variable corresponding to the
uncensoring indicator.
</p>
</td></tr>
<tr><td><code id="testcov_+3A_dataset">dataset</code></td>
<td>
<p>An optional data frame in which the variables named in
<code>x</code>, <code>t</code> and <code>d</code> are interpreted. If it is missing,
<code>x</code>, <code>t</code> and <code>d</code> must be objects of the workspace.
</p>
</td></tr>
<tr><td><code id="testcov_+3A_bootpars">bootpars</code></td>
<td>
<p>A list of parameters controlling the test. Currently,
the only accepted component is <code>B</code>, the number of bootstrap
resamples. The default is the value returned by the
<code>controlpars</code> function called without arguments.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function computes a statistic, based on the method by
Delgado and González-Manteiga (2004), to test whether a covariate X
has an effect on the cure probability (<code class="reqn">H_1</code>: cure probability =
q(x)) or not (<code class="reqn">H_0</code>: cure probability = q). Since the cure rate
can be written as the regression function <code class="reqn">E(\nu | X = x) =
  q(x)</code>, where <code class="reqn">\nu</code> is the cure
indicator, the procedure is carried out as a significance test in
nonparametric regression. The challenge of the test is that the cure
indicator <code class="reqn">\nu</code> is only partially observed due to censoring:
for the uncensored observations <code class="reqn">\nu = 0</code>, but it is
unknown if a censored individual will be eventually cured or not
(<code class="reqn">\nu</code> unknown). The approach consists in expressing the cure
rate as a regression function with another response, not observable
but estimable, say <code class="reqn">\eta</code>. The estimated values of
<code class="reqn">\eta</code> depend on suitable estimates of the conditional 
distribution of the censoring variable and <code class="reqn">\tau(x)</code>, an
unknown time beyond which a subject could be considered as cured; see
López-Cheda (2018). For the computation of the values of
<code class="reqn">\eta</code>, the censoring distribution is estimated
unconditionally using the Kaplan-Meier product-limit estimator. The
time <code class="reqn">\tau</code> is estimated by the largest uncensored time.
</p>
<p>The test statistic is a weighted mean of the difference between the
observations of <code class="reqn">\eta_i</code> and the values of the conditional
mean of <code class="reqn">\eta</code> under the null hypothesis:
</p>
<p style="text-align: center;"><code class="reqn">T_{n(x)} = 1/n \sum (\eta_i - \bar{\eta}) I(x_i \leq x)</code>
</p>
<p>.
</p>
<p>For a qualitative covariate there is no natural way to order the values
<code class="reqn">x_i</code>. In principle, this makes impossible to compute the indicator
function in the test statistic. The problem is solved by considering all
the possible combinations of the covariate values, and by computing the
test statistic for each 'ordered' combination. <code class="reqn">T_{n(x)}</code> is taken
as the largest value of these test statistics.
</p>
<p>The distribution of the test statistic under the null hypothesis is
approximated by bootstrap, using independent naive resampling.
</p>


<h3>Value</h3>

<p>An object of S3 class 'npcure'. Formally, a list of components:
</p>
<table>
<tr><td><code>type</code></td>
<td>
<p>The constant character string c(&quot;test&quot;, &quot;Covariate&quot;).
</p>
</td></tr>
<tr><td><code>x</code></td>
<td>
<p>The name of the covariate.
</p>
</td></tr>
<tr><td><code>CM</code></td>
<td>
<p>The result of the Cramer-von Mises test: a list with
components <code>statistic</code>, the test statistic, and <code>pvalue</code>,
the  p-value.
</p>
</td></tr>
<tr><td><code>KS</code></td>
<td>
<p>The result of the Kolmogorov-Smirnov test: a list with
components <code>statistic</code>, the test statistic, and <code>pvalue</code>,
the p-value.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Ignacio López-de-Ullibarri [aut, cre],
Ana López-Cheda [aut],
Maria Amalia Jácome [aut]
</p>


<h3>References</h3>

<p>Delgado M. A., González-Manteiga W. (2001). Significance
testing in nonparametric regression based on the bootstrap. Annals of
Statistics, 29: 1469-1507.
</p>
<p>López-Cheda A. (2018). <em>Nonparametric Inference in Mixture Cure
Models</em>. PhD dissertation, Universidade da Coruña. Spain.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+controlpars">controlpars</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Some artificial data
set.seed(123)
n &lt;- 50
x &lt;- runif(n, -2, 2) ## Covariate values
y &lt;- rweibull(n, shape = .5*(x + 4)) ## True lifetimes
c &lt;- rexp(n) ## Censoring values
p &lt;- exp(2*x)/(1 + exp(2*x)) ## Probability of being susceptible
u &lt;- runif(n)
t &lt;- ifelse(u &lt; p, pmin(y, c), c) ## Observed times
d &lt;- ifelse(u &lt; p, ifelse(y &lt; c, 1, 0), 0) ## Uncensoring indicator
data &lt;- data.frame(x = x, t = t, d = d)

## Test of the significance of the covariate 'x'
testcov(x, t, d, data)

## Test carried out with 1999 bootstrap resamples (the default is 999)
testcov(x, t, d, data, bootpars = controlpars(B = 1999))


## How to apply the test repeatedly when there is more than one
## covariate... 
## ... 'y' is another continuous covariate of the data frame 'data'
data$y &lt;- runif(n, -1, 1)
namecovar &lt;- c("x", "y")
## ... testcov is called from a 'for' loop
for (i in 1:length(namecovar)) {
   result &lt;- testcov(data[, namecovar[i]], data$t, data$d)
   print(result)
}

## In the previous example, testcov() was called without using the
## argument 'dataset'. To use it, the 'for' must be avoided
testcov(x, t, d, data)
testcov(y, t, d, data)

## Non-numeric covariates can also be tested...
## ... 'z' is a nominal covariate of the data frame 'data'
data$z &lt;- rep(factor(letters[1:5]), each = n/5)
testcov(z, t, d, data)

## Example with the dataset 'bmt' in the 'KMsurv' package
## to study the effect on the probability of cure of...
## ... (a) a continuous covariate (z1 = age of the patient)
data("bmt", package = "KMsurv")
set.seed(1) ## Not needed, just for reproducibility.
testcov(z1, t2, d3, bmt, bootpars = controlpars(B = 4999))

## ... (b) a qualitative covariate (z3 = patient gender)
set.seed(1) ## Not needed, just for reproducibility.
testcov(z3, t2, d3, bmt, bootpars = controlpars(B = 4999))

</code></pre>

<hr>
<h2 id='testmz'>Test of Maller-Zhou
</h2><span id='topic+testmz'></span>

<h3>Description</h3>

<p>This function carries out the nonparametric test of Maller and
Zhou (1992).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>testmz(t, d, dataset)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="testmz_+3A_t">t</code></td>
<td>
<p>If <code>dataset</code> is missing, a numeric object giving the
the observed times. If <code>dataset</code> is a data frame, it is
interpreted as the name of the variable corresponding to the
observed times in the data frame.
</p>
</td></tr>
<tr><td><code id="testmz_+3A_d">d</code></td>
<td>
<p>If <code>dataset</code> is missing, an integer object giving the
values of the uncensoring indicator. Censored observations must be
coded as 0, uncensored ones as 1. If <code>dataset</code> is a data frame,
it is interpreted as the name of the variable corresponding to the 
uncensoring indicator.
</p>
</td></tr>
<tr><td><code id="testmz_+3A_dataset">dataset</code></td>
<td>
<p>An optional data frame in which the variables named in
<code>x</code>, <code>t</code> and <code>d</code> are interpreted. If it is missing,
<code>x</code>, <code>t</code> and <code>d</code> must be objects of the workspace.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function implements Maller and Zhou's (1992) method to
test the null hypothesis <code class="reqn">H_{0} : \tau_{F_{0}} &gt; \tau_{G}</code> vs. <code class="reqn">H_{1} : \tau_{F_{0}} \leq \tau_{G}</code>, where <code class="reqn">\tau_{F_{0}}</code> and
<code class="reqn">\tau_{G}</code> are the supports of, respectively, the
distribution function of the survival time of the uncured and the
distribution function of the censoring time.
</p>


<h3>Value</h3>

<p>An object of S3 class 'npcure'. Formally, a list of components:
</p>
<table>
<tr><td><code>type</code></td>
<td>
<p>The constant character string c(&quot;test&quot;, &quot;Maller-Zhou&quot;).
</p>
</td></tr>
<tr><td><code>pvalue</code></td>
<td>
<p>The p-value of the test.
</p>
</td></tr>
<tr><td><code>aux</code></td>
<td>
<p>A list of components: <code>statistic</code>, the test
statistic, <code>n</code> the sample size, <code>delta</code>, the difference
between the largest observed time <code class="reqn">t_{n}</code> and the largest
uncensored time <code class="reqn">t_{n}^{\star}</code>, and <code>interval</code>, a
vector giving the range between
<code class="reqn">\max(0,t_{n}^{\star}-\texttt{delta})</code>
and <code class="reqn">t_{n}^{\star}</code>.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Ignacio López-de-Ullibarri [aut, cre],
Ana López-Cheda [aut],
Maria Amalia Jácome [aut]
</p>


<h3>References</h3>

<p>Maller R. A., Zhou S. (1992). Estimating the proportion of
immunes in a censored sample. Biometrika, 79:
731-739. <a href="https://doi.org/10.1093/biomet/79.4.731">https://doi.org/10.1093/biomet/79.4.731</a>. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+latency">latency</a></code>, <code><a href="#topic+probcure">probcure</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Some artificial data
set.seed(123)
n &lt;- 50
y &lt;- qweibull(runif(n)*pweibull(2, shape = 2), shape = 2) ## True lifetimes
c &lt;- qexp(runif(n)*pexp(2.5)) ## Censoring values
u &lt;- runif(n)
## Probability of being susceptible is constantly equal to .5
t &lt;- ifelse(u &lt; .5, pmin(y, c), c) ## Observed times
d &lt;- ifelse(u &lt; .5, ifelse(y &lt; c, 1, 0), 0) ## Uncensoring indicator
data &lt;- data.frame(t = t, d = d)

## Maller-Zhou test
testmz(t, d, data)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
