<!DOCTYPE html><html><head><title>Help for package DOBAD</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {DOBAD}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#add.generator'><p>Generating functions for birth-death processes with immigration</p></a></li>
<li><a href='#add.joint.mean.many'><p>Mean counts and particle time averages for birth-death processes</p>
with immigration</a></li>
<li><a href='#add.uncond.mean.one'>
<p>ENplus, ENminus, Eholdtime, unconditional on ending state.</p></a></li>
<li><a href='#ARsim'>
<p>Accept-Reject Simulation</p></a></li>
<li><a href='#BD.EMInference.prodExpecs'><p>Functions That Calculate Product Expectations Needed for</p>
Inference via EM Algorithm</a></li>
<li><a href='#BD.MCMC.SC'><p>MCMC on Linear Birth Death Process</p></a></li>
<li><a href='#bdARsimCondEnd'>
<p>Conditional Simulation of BD via Accept-Reject</p></a></li>
<li><a href='#BDloglikelihood.PO'>
<p>Calculate log likelihood of Partially Observed BD process</p></a></li>
<li><a href='#BDMC_many-class'><p>Class <code>"BDMC_many"</code></p></a></li>
<li><a href='#BDMC-class'><p>Class &quot;BDMC&quot;</p></a></li>
<li><a href='#BDPOloglikeGradSqr.CTMC_PO_many'>
<p>Gradient-Squared of PartialData likelihood</p></a></li>
<li><a href='#BDsummaryStats'><p>Get summary statistics for EM Algorithm on Linear Birth-Death Process</p></a></li>
<li><a href='#birth.death.simulant'><p>Simulation of birth-death processes with immigration</p></a></li>
<li><a href='#bracket-methods'><p>Methods for Function <code>[</code> in Package <span class="pkg">DOBAD</span></p></a></li>
<li><a href='#combineCTMC'>
<p>Combine several CTMCs into one CTMC</p></a></li>
<li><a href='#CTMC_PO_1-class'><p>Class &quot;CTMC_PO_1&quot;</p></a></li>
<li><a href='#CTMC_PO_many-class'><p>Class &quot;CTMC_PO_many&quot;</p></a></li>
<li><a href='#CTMC-class'><p>Class &quot;CTMC&quot;</p></a></li>
<li><a href='#CTMC.simulate'>
<p>Simulate from (&quot;regular&quot;) CTMC</p></a></li>
<li><a href='#CTMC.simulate.piecewise'>
<p>Simulate from piecewise constant/homogeneous CTMC</p></a></li>
<li><a href='#CTMC2list'>
<p>Convert Between two representations of a Continuous Time Markov Chain.</p></a></li>
<li><a href='#CTMCPO2indepIntervals'>
<p>Converts CTMC_PO (either CTMC_PO_1 or CTMC_PO_many) to independent intervals.</p></a></li>
<li><a href='#derivType'>
<p>Helper for getting means from generating functions</p></a></li>
<li><a href='#doublebracket-methods'><p>Methods for Function <code>[[</code> in Package <span class="pkg">DOBAD</span></p></a></li>
<li><a href='#EM.BD.SC'><p>Expectation-Maximization on Linear Birth Death (_S_pecial _C_ase</p>
with constrained immigration)</a></li>
<li><a href='#EM.BD.SC.cov.1sv'>
<p>Expectation-Maximization on Linear Birth Death (and constrained</p>
Immigration) with Covariates</a></li>
<li><a href='#EMutilities'><p>Functions related to implementing the EM algorithm on partially observed</p>
Birth-Death Chain</a></li>
<li><a href='#getBDinform'><p>Helpers for Getting Information Matrix for MLE estimates on</p>
Partially Observed Linear Birth Death (_S_pecial _C_ase
with constrained immigration)</a></li>
<li><a href='#getBDinform.PO'><p>Get Information Matrix for MLE estimates on</p>
Partially Observed Linear Birth Death (_S_pecial _C_ase
with constrained immigration)</a></li>
<li><a href='#getBDjTimes'>
<p>Get Jump times of a BD process.</p></a></li>
<li><a href='#getBDMCsPOlist-methods'><p> Methods for Function <code>getBDMCsPOlist</code> in Package <span class="pkg">DOBAD</span></p></a></li>
<li><a href='#getDataSummary.CTMC_PO_many'>
<p>Calculate Some Summarizing Information for the Given Data</p></a></li>
<li><a href='#getInitParams'>
<p>Get multiple starting parameters for EM</p></a></li>
<li><a href='#getIthJumpTime'>
<p>Get the jump times from a CTMC.</p></a></li>
<li><a href='#getMCstate'>
<p>Get the state of a CTMC at various times</p></a></li>
<li><a href='#getNewParams.SC'>
<p>Solve for new parameters in restricted model in EM algorithm.</p></a></li>
<li><a href='#getPartialData'>
<p>Get &quot;partially Observed &quot; Chain from a fully observed one.</p></a></li>
<li><a href='#getStates'>
<p>Get list of jump states.</p></a></li>
<li><a href='#getSubMC'>
<p>Extract a Sub Markov Chain</p></a></li>
<li><a href='#getT-methods'><p> ~~ Methods for Function getT in Package &lsquo;DOBAD&rsquo; ~~</p></a></li>
<li><a href='#getTimes'>
<p>Get list of jump times.</p></a></li>
<li><a href='#getTs-methods'><p> ~~ Methods for Function getTs in Package &lsquo;DOBAD&rsquo; ~~</p></a></li>
<li><a href='#graph.CTMC'>
<p>Plot  CTMCs (possibly Partially Observed)</p></a></li>
<li><a href='#list2CTMC'>
<p>Convert a list representation of a CTMC to the class version</p></a></li>
<li><a href='#Nij'>
<p>Count transitions in a fully observed CTMC.</p></a></li>
<li><a href='#Nplus'>
<p>Calculate summary statistics for BDMCs and CTMC_POs</p></a></li>
<li><a href='#num.deriv'>
<p>Numerical Differentiation</p></a></li>
<li><a href='#plot-methods'><p>Plot CTMCs</p></a></li>
<li><a href='#power.coef.one'>
<p>Gets coefficients of a power series..</p></a></li>
<li><a href='#process.prob.one'>
<p>Calculate transition probability for linear birth death process.</p></a></li>
<li><a href='#sampleJumpTime2'>
<p>Functions for Simulating Conditionally the first Jump of a chain.</p></a></li>
<li><a href='#sim.condBD'><p>Simulate birth-death process, Conditionally</p>
upon observing its state at  finite, discrete
time points</a></li>
<li><a href='#simplify'>
<p>Transform Lists to Vectors</p></a></li>
<li><a href='#sub-methods'><p>  Subscripting CTMCs</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Analysis of Discretely Observed Linear
Birth-and-Death(-and-Immigration) Markov Chains</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.6</td>
</tr>
<tr>
<td>Date:</td>
<td>2017-12-7</td>
</tr>
<tr>
<td>Author:</td>
<td>Charles Doss, Vladimir Minin, Marc Suchard</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Charles Doss &lt;cdoss@umn.edu&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides Frequentist (EM) and Bayesian  (MCMC) Methods for Inference of  Birth-Death-Immigration Markov Chains.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Depends:</td>
<td>numDeriv</td>
</tr>
<tr>
<td>Imports:</td>
<td>methods,lattice,Matrix</td>
</tr>
<tr>
<td>Suggests:</td>
<td>gtools,MCMCpack,functional</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2017-12-07 18:21:03 UTC; cdoss</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2017-12-07 18:32:19 UTC</td>
</tr>
</table>
<hr>
<h2 id='add.generator'>Generating functions for birth-death processes with immigration</h2><span id='topic+add.generator'></span><span id='topic+rem.generator'></span><span id='topic+timeave.laplace'></span><span id='topic+hold.generator'></span><span id='topic+process.generator'></span><span id='topic+addrem.generator'></span><span id='topic+addhold.generator'></span><span id='topic+remhold.generator'></span><span id='topic+addremhold.generator'></span>

<h3>Description</h3>

<p>A set of generating functions for sufficient
statistics for partially observed birth-death process with
immigration. The sufficient statistcs are the number of
births and immigrations, the mean number of deaths, and
the time average of the number of particles.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add.generator(r,s,t,lambda,mu,nu,X0)
rem.generator(r,s,t,lambda,mu,nu,X0)
timeave.laplace(r,s,t,lambda,mu,nu,X0)
hold.generator(w,s,t,lambda,mu,nu,X0)
process.generator(s,time,lambda,mu,nu,X0)
addrem.generator(u, v, s, t, X0, lambda, mu, nu)
remhold.generator( v, w, s, t, X0, lambda, mu, nu)
addhold.generator( u, w, s, t, X0, lambda, mu, nu)
addremhold.generator( u, v, w, s, t, X0, lambda, mu, nu)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add.generator_+3A_r">r</code>, <code id="add.generator_+3A_u">u</code>, <code id="add.generator_+3A_v">v</code>, <code id="add.generator_+3A_w">w</code></td>
<td>
<p>dummy variable attaining values between 0 and 1.
We use r for the single-argument generators and u,v,w for
births,deaths, and holdtime for the multi-variable generators syntax,
generally.</p>
</td></tr>
<tr><td><code id="add.generator_+3A_s">s</code></td>
<td>
<p>dummary variable attaining values between 0 and 1</p>
</td></tr>
<tr><td><code id="add.generator_+3A_t">t</code>, <code id="add.generator_+3A_time">time</code></td>
<td>
<p>length of the time interval</p>
</td></tr>
<tr><td><code id="add.generator_+3A_lambda">lambda</code></td>
<td>
<p>per particle birth rate</p>
</td></tr>
<tr><td><code id="add.generator_+3A_mu">mu</code></td>
<td>
<p>per particle death rate</p>
</td></tr>
<tr><td><code id="add.generator_+3A_nu">nu</code></td>
<td>
<p>immigration rate</p>
</td></tr>
<tr><td><code id="add.generator_+3A_x0">X0</code></td>
<td>
<p>starting state, a non-negative integer</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Birth-death process is denoted by <code class="reqn">X_t</code>
</p>
<p>Sufficient statistics are defined as
</p>
<p><code class="reqn">N_t^+</code> = number of additions (births and immigrations)
</p>
<p><code class="reqn">N_t^-</code> = number of deaths
</p>
<p><code class="reqn">R_t</code> = time average of the number of particles, </p>
<p style="text-align: center;"><code class="reqn">\int_0^t X_y dy</code>
</p>

<p>Function add.generator calculates
</p>
<p style="text-align: center;"><code class="reqn">H_i^+(r,s,t) = \sum_{n=0}^\infty \sum_{j=0}^\infty
    Pr(N_t^+=n,X_t=j | X_o=i) r^n s^j</code>
</p>

<p>Function rem.generator calculates
</p>
<p style="text-align: center;"><code class="reqn">H_i^-(r,s,t) = \sum_{n=0}^\infty \sum_{j=0}^\infty
    Pr(N_t^-=n,X_t=j | X_o=i) r^n s^j</code>
</p>

<p>Function timeave.laplace calculates
</p>
<p style="text-align: center;"><code class="reqn">H_i^*(r,s,t) = \sum_{j=0}^\infty \int_0^\infty e^{-rx}
    dPr(R_t \le x, X_t=j | X_o=i) s^j</code>
</p>

<p>Function processor.generator calculates
</p>
<p style="text-align: center;"><code class="reqn">G_i(s,t) = \sum_{j=0}^\infty
    Pr(X_t=j | X_o=i) r^n s^j</code>
</p>

<p>Function addrem.generator calculates
</p>
<p style="text-align: center;"><code class="reqn">H_i(u,v,s,t) = \sum_{j=0}^\infty \sum_{n_1=0}^\infty  \sum_{n_2=0}^\infty 
    Pr(X_t=j, N_t^+=n_1, N_t^-=n_2 | X_o=i) u^{n_1} v^{n_2} s^j</code>
</p>

<p>Function addhold.generator calculates
</p>
<p style="text-align: center;"><code class="reqn">H_i(u,,w,s,t) = \sum_{j=0}^\infty \sum_{n1 \ge 0}
    u^n_1 \int_0^\infty e^{-rx}
    dPr(R_t \le x, N_t^+=n_1, X_t=j | X_o=i) s^j</code>
</p>

<p>Function remhold.generator is the same as addhold.generator
but with N- instead of N+.
</p>


<h3>Value</h3>

<p>Numeric value of the corresponding generating function.
</p>


<h3>Author(s)</h3>

<p>Marc A. Suchard, Charles Doss</p>


<h3>See Also</h3>

<p><code><a href="#topic+add.joint.mean.many">add.joint.mean.many</a></code></p>

<hr>
<h2 id='add.joint.mean.many'>Mean counts and particle time averages for birth-death processes
with immigration</h2><span id='topic+add.joint.mean.many'></span><span id='topic+rem.joint.mean.many'></span><span id='topic+timeave.joint.mean.many'></span><span id='topic+add.joint.mean.one'></span><span id='topic+rem.joint.mean.one'></span><span id='topic+timeave.joint.mean.one'></span><span id='topic+add.cond.mean.many'></span><span id='topic+rem.cond.mean.many'></span><span id='topic+timeave.cond.mean.many'></span><span id='topic+add.cond.mean.one'></span><span id='topic+rem.cond.mean.one'></span><span id='topic+timeave.cond.mean.one'></span><span id='topic+hold.cond.mean.one'></span><span id='topic+add.joint.meanSq.one'></span><span id='topic+add.cond.meanSq.one'></span><span id='topic+addrem.joint.mean.one'></span><span id='topic+addrem.cond.mean.one'></span><span id='topic+addhold.joint.mean.one'></span><span id='topic+addhold.cond.mean.one'></span><span id='topic+remhold.joint.mean.one'></span><span id='topic+remhold.cond.mean.one'></span><span id='topic+add.joint.meanSq.one'></span><span id='topic+add.cond.meanSq.one'></span><span id='topic+rem.joint.meanSq.one'></span><span id='topic+rem.cond.meanSq.one'></span><span id='topic+hold.joint.meanSq.one'></span><span id='topic+hold.cond.meanSq.one'></span><span id='topic+all.cond.mean.PO'></span><span id='topic+all.cond.mean2.PO'></span>

<h3>Description</h3>

<p>A set of functions for calculating the joint and conditional mean sufficient
statistics for partially observed birth-death process with
immigration. The sufficient statistcs are the number of
births and immigrations, the mean number of deaths, and
the time average of the number of particles.
The conditional expectations
of these quantities are calculated for a finite time interval,
conditional on the number of particles at the beginning and the
end of the interval.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add.joint.mean.many(t,lambda,mu,nu=0,X0=1,delta=0.001,n=1024)
rem.joint.mean.many(t,lambda,mu,nu=0,X0=1,delta=0.001,n=1024)
timeave.joint.mean.many(t,lambda,mu,nu=0,X0=1,delta=0.001,n=1024)
add.cond.mean.many(t,lambda,mu,nu=0,X0=1,delta=0.001,n=1024,
 prec.tol=1e-12, prec.fail.stop=TRUE)
rem.cond.mean.many(t,lambda,mu,nu=0,X0=1,delta=0.001,n=1024,
prec.tol=1e-12, prec.fail.stop=TRUE)
timeave.cond.mean.many(t,lambda,mu,nu=0,X0=1,delta=0.001,n=1024,
prec.tol=1e-12, prec.fail.stop=TRUE)
add.joint.mean.one(t,lambda,mu,nu=0,X0=1,Xt,delta=0.001,n=1024,r=4)
rem.joint.mean.one(t,lambda,mu,nu=0,X0=1,Xt,delta=0.001,n=1024,r=4)
timeave.joint.mean.one(t,lambda,mu,nu=0,X0=1,Xt,delta=0.001,n=1024,r=4)
add.cond.mean.one(t,lambda,mu,nu=0,X0=1,Xt,trans.prob=NULL,
joint.mean=NULL,delta=1e-04,n=1024, r=4,
prec.tol=1e-12, prec.fail.stop=TRUE)
rem.cond.mean.one(t,lambda,mu,nu=0,X0=1,Xt,trans.prob=NULL,
joint.mean=NULL,delta=1e-04,n=1024, r=4,
prec.tol=1e-12, prec.fail.stop=TRUE)
timeave.cond.mean.one(t,lambda,mu,nu=0,X0=1,Xt,trans.prob=NULL,
joint.mean=NULL, delta=1e-04,n=1024,r=4,
prec.tol=1e-12, prec.fail.stop=TRUE)
hold.cond.mean.one(t,lambda,mu,nu=0,X0=1,Xt, trans.prob=NULL,joint.mean=NULL,
delta=1e-04,n=1024,r=4,prec.tol=1e-12, prec.fail.stop=TRUE)
add.joint.meanSq.one(t, lambda, mu, nu = 0, X0 = 1, Xt, joint.mean=NULL, delta = 0.001,
 n=1024,r=4)
add.cond.meanSq.one(t, lambda, mu, nu = 0, X0 = 1, Xt, trans.prob=NULL,
joint.mean=NULL, delta = 0.001, n
= 1024,r=4, prec.tol=1e-12, prec.fail.stop=TRUE)
addrem.joint.mean.one(t, lambda, mu, nu = 0, X0 = 1, Xt, delta = 0.001,
n = 1024,r=4)
addrem.cond.mean.one(t, lambda, mu, nu = 0, X0 = 1, Xt, trans.prob=NULL,
delta = 0.001,n = 1024, r=4,prec.tol=1e-12, prec.fail.stop=TRUE)
addhold.joint.mean.one(t, lambda, mu, nu = 0, X0 = 1, Xt, delta = 0.001,
n = 1024,r=4)
addhold.cond.mean.one(t, lambda, mu, nu = 0, X0 = 1, Xt, 
trans.prob=NULL, delta = 0.001, n = 1024, r=4, prec.tol=1e-12, prec.fail.stop=TRUE)
remhold.joint.mean.one(t, lambda, mu, nu = 0, X0 = 1, Xt, delta = 1e-04,
n = 1024,r=4)
remhold.cond.mean.one(t, lambda, mu, nu = 0, X0 = 1, Xt,
trans.prob=NULL, delta = 1e-04,
n = 1024,r=4, prec.tol=1e-12, prec.fail.stop=TRUE)
add.joint.meanSq.one(t, lambda, mu, nu = 0, X0 = 1, Xt, joint.mean=NULL,
delta = 0.001, n = 1024,r=4)
add.cond.meanSq.one(t, lambda, mu, nu = 0, X0 = 1, Xt,
trans.prob=NULL,joint.mean=NULL, delta = 0.001,
n= 1024, r=4, prec.tol=1e-12, prec.fail.stop=TRUE )
rem.joint.meanSq.one(t, lambda, mu, nu = 0, X0 = 1, Xt,
joint.mean=NULL, delta = 0.001, n = 1024,r=4)
rem.cond.meanSq.one(t, lambda, mu, nu = 0, X0 = 1, Xt, trans.prob=NULL,
joint.mean=NULL, delta = 0.001,n = 1024,r=4, prec.tol=1e-12, prec.fail.stop=TRUE)
hold.joint.meanSq.one(t, lambda, mu, nu = 0, X0 = 1, Xt, r=4,  n = 1024,
delta = 0.0001)
hold.cond.meanSq.one(t, lambda, mu, nu = 0, X0 = 1, Xt, trans.prob=NULL,
n= 1024,delta = 0.0001, r=4, prec.tol=1e-12, prec.fail.stop=TRUE)
all.cond.mean.PO(data,lambda,mu,nu=0,delta=0.001,n=1024, r=4,
prec.tol=1e-12, prec.fail.stop=TRUE)
all.cond.mean2.PO(data,lambda,mu,nu=0,delta=0.001,n=1024,r=4,
prec.tol=1e-12,  prec.fail.stop=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add.joint.mean.many_+3A_t">t</code></td>
<td>
<p>length of the time interval</p>
</td></tr>
<tr><td><code id="add.joint.mean.many_+3A_lambda">lambda</code></td>
<td>
<p>per particle birth rate</p>
</td></tr>
<tr><td><code id="add.joint.mean.many_+3A_mu">mu</code></td>
<td>
<p>per particle death rate</p>
</td></tr>
<tr><td><code id="add.joint.mean.many_+3A_nu">nu</code></td>
<td>
<p>immigration rate</p>
</td></tr>
<tr><td><code id="add.joint.mean.many_+3A_x0">X0</code></td>
<td>
<p>starting state, a non-negative integer</p>
</td></tr>
<tr><td><code id="add.joint.mean.many_+3A_xt">Xt</code></td>
<td>
<p>ending state, a non-negative integer</p>
</td></tr>
<tr><td><code id="add.joint.mean.many_+3A_data">data</code></td>
<td>
<p>CTMC_PO_1 or an analogous list. List isn't always
accepted (in all.cond.mean functions it isn't). all.cond.means
both accept CTMC_PO_1 or CTMC_PO_many.</p>
</td></tr>
<tr><td><code id="add.joint.mean.many_+3A_trans.prob">trans.prob</code></td>
<td>
<p>Either NULL or a precomputed transition
probability for a process with the parameters passed in.  This saves
the repeated computation of the same transition probability
for multiple conditional expectations over the same interval. If
NULL, the probability will just be computed in the function.</p>
</td></tr>
<tr><td><code id="add.joint.mean.many_+3A_joint.mean">joint.mean</code></td>
<td>
<p>This is a parameter in some of the computations for
some squared means. It is either NULL or the corresponding (first-order,
unsquared) mean.  If NULL the probability will just be
computed in the function. (It is needed to convert a factorial mean
to a squared mean.) Note that this is ALWAYS an unsquared mean,
regardless of whether the function is a *.meanSq.* or a *.mean.*
function.  In the latter case, if a non-NULL value is passed, the
called function doesn't do much
besides divide.</p>
</td></tr>
<tr><td><code id="add.joint.mean.many_+3A_delta">delta</code></td>
<td>
<p>increment length used in numerical differentiation</p>
</td></tr>
<tr><td><code id="add.joint.mean.many_+3A_n">n</code></td>
<td>
<p>number of coefficients to pull off via FFT, in *.one
functions this number determines the number of intervals in the
Rieman sum approximation of the integral</p>
</td></tr>
<tr><td><code id="add.joint.mean.many_+3A_prec.tol">prec.tol</code></td>
<td>
<p>&quot;Precision tolerance&quot;; to compute conditional means,
first the joint means are computed and then they are normalized by
transition probabilities.  The precision parameters govern the
conditions under which the function will quit if these values are
very small.  If the joint-mean is smaller than prec.tol then
the value of prec.fail.stop decides whether to stop or continue.</p>
</td></tr>
<tr><td><code id="add.joint.mean.many_+3A_prec.fail.stop">prec.fail.stop</code></td>
<td>
<p>If true, then when joint-mean values are
smaller than prec.tol the program stops; if false then it continues,
usually printing a warning.</p>
</td></tr>
<tr><td><code id="add.joint.mean.many_+3A_r">r</code></td>
<td>
<p>See numDeriv package; this is 'r' argument for
grad/genD/hessian
which determines how many richardson-method iterations are done.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Birth-death process is denoted by <code class="reqn">X_t</code>
</p>
<p>Sufficient statistics are defined as
</p>
<p><code class="reqn">N_t^+</code> = number of additions (births and immigrations)
</p>
<p><code class="reqn">N_t^-</code> = number of deaths
</p>
<p><code class="reqn">R_t</code> = time average of the number of particles, <code class="reqn">\int_0^t X_y dy</code>
</p>
<p>Function add.joint.mean.many returns a vector of length n, where the
j-th element of the vector is equal to
</p>
<p style="text-align: center;"><code class="reqn">E(N_t^+ 1_{X_t=j} | X_0=X0)</code>
</p>

<p>Function rem.joint.mean.many returns a vector of length n, where the
j-th element of the vector is equal to
</p>
<p style="text-align: center;"><code class="reqn">E(N_t^- 1_{X_t=j} | X_0=X0)</code>
</p>

<p>Function timeave.joint.mean.many returns a vector of length n, where the
j-th element of the vector is equal to
</p>
<p style="text-align: center;"><code class="reqn">E(R_t 1_{X_t=j} | X_0=X0)</code>
</p>

<p>Function add.cond.mean.many returns a vector of length n, where the
j-th element of the vector is equal to
</p>
<p style="text-align: center;"><code class="reqn">E(N_t^+ | X_0=X0, X_t = j)</code>
</p>

<p>Function rem.cond.mean.many returns a vector of length n, where the
j-th element of the vector is equal to
</p>
<p style="text-align: center;"><code class="reqn">E(N_t^- | X_0=X0, X_t=j)</code>
</p>

<p>Function timeave.cond.mean.many returns a vector of length n, where the
j-th element of the vector is equal to
</p>
<p style="text-align: center;"><code class="reqn">E(R_t | X_0=X0, X_t=j)</code>
</p>

<p>Function add.joint.mean.one returns
<code class="reqn">E(N_t^+ 1_{X_t=Xt} | X_0=X0)</code>
</p>
<p>Function rem.joint.mean.one returns
<code class="reqn">E(N_t^- 1_{X_t=Xt} | X_0=X0)</code>
</p>
<p>Function timeave.joint.mean.one returns
<code class="reqn">E(R_t 1_{X_t=Xt} | X_0=X0)</code>
</p>
<p>Function add.cond.mean.one returns
<code class="reqn">E(N_t^ | X_0=X0, X_t=Xt)</code>
</p>
<p>Function rem.cond.mean.one returns
<code class="reqn">E(N_t^- | X_0=X0, X_t=Xt)</code>
</p>
<p>Function timeave.cond.mean.one returns
<code class="reqn">E(R_t | X_0=X0, X_t=Xt)</code>
</p>
<p>Function add.joint.meanSq.one returns
<code class="reqn">E((N_t^-)^2, X_t=Xt | X_0=X0)</code>
</p>
<p>Function add.cond.meanSq.one returns
<code class="reqn">E((N_t^-)^2| X_0=X0, X_t=Xt )</code>
</p>
<p>Function addrem.joint.mean.one returns
<code class="reqn">E((N_t^- N_t^-) , X_t=Xt | X_0=X0)</code>
</p>
<p>Function addrem.cond.mean.one returns
<code class="reqn">E((N_t^- N_t^-)| X_0=X0, X_t=Xt )</code>
</p>
<p>all.cond.mean.PO and all.cond.mean2.PO compute the first
and second order means respectively for a partially observed process
(with possibly more than one observation point).  So they amalgamate
the above functions and also apply them to multiple observations.
The outcomes are labeled appropriately.
</p>
<p>Note that all.cond.mean.PO are not methods, they
can accept either CTMC_PO_many or CTMC_PO_1 (via their use of
CTMCPO2indepIntervals function).
</p>
<p>&quot;Hold&quot; and &quot;timeave&quot; are the same.
</p>
<p>The .many functions are less safe about differentiation right now.
This should be changed in the future.
</p>


<h3>Author(s)</h3>

<p>Marc A. Suchard, Vladimir N. Minin, Charles Doss</p>


<h3>See Also</h3>

<p><code><a href="#topic+add.generator">add.generator</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>library(DOBAD)
my.lambda = 2
my.mu = 3
my.nu =1
my.time = 0.5
my.start = 10
my.end = 2
my.n = 1024

#Calculate the mean number of additions (births and immigrations)
#conditional on "my.start" particles at time 0 and "my.end" particles at time "my.time"
add.cond.mean.one(t=my.time,lambda=my.lambda,mu=my.mu,nu=my.nu,X0=my.start,Xt=my.end)

#Calculate a vector mean number of deaths joint with "my.end" particles at
# time "my.time" and conditional on "my.start" particles at time 0
DOBAD:::rem.joint.mean.one(t=my.time,lambda=my.lambda,mu=my.mu,nu=my.nu,X0=my.start,Xt=my.end)

#Calculate a vector mean particle time averages conditional on
# "my.start" particles at time 0 and 1 to "my.n" particles at time "my.time" 
# WARNING: conditional expectations for large values of |X_0-X_t| may be
# unreliable
timeave.cond.mean.many(t=my.time,lambda=my.lambda,mu=my.mu,nu=my.nu,X0=my.start,n=my.n)[1:20]
</code></pre>

<hr>
<h2 id='add.uncond.mean.one'>
ENplus, ENminus, Eholdtime, unconditional on ending state.
</h2><span id='topic+add.uncond.mean.one'></span><span id='topic+rem.uncond.mean.one'></span><span id='topic+hold.uncond.mean.one'></span>

<h3>Description</h3>

<p>ENplus, ENminus, Eholdtime, unconditional on ending state.  i.e.
sum over j of Eij(Nplus), etc.  Expected number of total jumps
up/down/holdtime over the given interval, conditional on starting state.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add.uncond.mean.one(t, X0, lambda, mu, nu, delta = 0.001, r = 4)
rem.uncond.mean.one(t, X0, lambda, mu, nu, delta = 0.001, r = 4)
hold.uncond.mean.one(t, X0, lambda, mu, nu, delta = 0.001, r = 4)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add.uncond.mean.one_+3A_t">t</code></td>
<td>

<p>time
</p>
</td></tr>
<tr><td><code id="add.uncond.mean.one_+3A_x0">X0</code></td>
<td>

<p>starting state
</p>
</td></tr>
<tr><td><code id="add.uncond.mean.one_+3A_lambda">lambda</code></td>
<td>

<p>birth rate
</p>
</td></tr>
<tr><td><code id="add.uncond.mean.one_+3A_mu">mu</code></td>
<td>

<p>death rate
</p>
</td></tr>
<tr><td><code id="add.uncond.mean.one_+3A_nu">nu</code></td>
<td>

<p>immigration rate
</p>
</td></tr>
<tr><td><code id="add.uncond.mean.one_+3A_delta">delta</code></td>
<td>

<p>paramter for derivative.
</p>
</td></tr>
<tr><td><code id="add.uncond.mean.one_+3A_r">r</code></td>
<td>

<p>parameter for derivative.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Uses generating functions.
</p>


<h3>Value</h3>

<p>Each return a numeric.
</p>


<h3>Author(s)</h3>

<p>Charles Doss
</p>

<hr>
<h2 id='ARsim'>
Accept-Reject Simulation
</h2><span id='topic+ARsim'></span>

<h3>Description</h3>

<p>Generic Code for acceptance-rejection sampling.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ARsim(margSimFn, acceptFn, N, keepTestInfo = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ARsim_+3A_margsimfn">margSimFn</code></td>
<td>

<p>This is a simulation function.  It should take no arguments (or
have default values that will be used).  It should output one
simulation; we will refer to it as being &quot;type X&quot;.
</p>
</td></tr>
<tr><td><code id="ARsim_+3A_acceptfn">acceptFn</code></td>
<td>

<p>Should take &quot;type X&quot; as argument and output True or False.
It should actually output a list (T/F, extraInformation).
ExtraInformation is generally whatever is being used to do the
accept/reject part; it is technically only required if
&quot;keepTestInfo&quot; is passed a True.
</p>
</td></tr>
<tr><td><code id="ARsim_+3A_n">N</code></td>
<td>

<p>How many simulations total to run (regardless of eventual
acceptance ratio); There is not currently a parameter for
choosing to stop after a given number of acceptances.
</p>
</td></tr>
<tr><td><code id="ARsim_+3A_keeptestinfo">keepTestInfo</code></td>
<td>

<p>True or False; if True then the result will be two lists, the second
of which has the second output from acceptFn; generally the data
used to decide whether to accept or reject the simulations.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Does accept-reject simultion; margSimFn is run N times; acceptFn
decides which to keep and which to remove; 
</p>


<h3>Value</h3>

<p>Returns a list with one (if keepTestInfo==FALSE) or two (if
keepTestInfo==TRUE) components. The first is $acceptSims, and the second
is $testVals.  The component acceptSims are the simulated values that
were accepted.  To do further analysis, testVals is the corresponding
list of information used to evaluate.
</p>
<p>In future:
Will have option to pass all simulations as output, and to
accept simulations (but presumably with a different acceptFn) to allow
for more reuse.
</p>
<p>As an implementation note: want to do &quot;replicate&quot; inside this function
so as to regulate the types of output.
</p>


<h3>Author(s)</h3>

<p>Charles Doss
</p>

<hr>
<h2 id='BD.EMInference.prodExpecs'>Functions That Calculate Product Expectations Needed for
Inference via EM Algorithm</h2><span id='topic+getBDsummaryExpecs'></span><span id='topic+getBDsummaryProdExpecs'></span>

<h3>Description</h3>

<p>In order to calculate the information matrix for partial data, several
conditional expectations of products of sufficient statistics are
needed.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getBDsummaryExpecs(sims, fnc=function(x){x})
getBDsummaryProdExpecs(sims, getsd=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BD.EMInference.prodExpecs_+3A_sims">sims</code></td>
<td>
<p>A list of Birth-Death CTMCs.</p>
</td></tr>
<tr><td><code id="BD.EMInference.prodExpecs_+3A_fnc">fnc</code></td>
<td>
<p>A one argument function. It should be a function from Reals
to Reals, capable of accepting a vector as its argument</p>
</td></tr>
<tr><td><code id="BD.EMInference.prodExpecs_+3A_getsd">getsd</code></td>
<td>
<p> Also return estimate of standard deviations of the prods
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Assume we have a linear-birth-death
process <code class="reqn">X_t</code> with birth parameter <code class="reqn">\lambda</code>, death
parameter <code class="reqn">\mu</code>, and immigration parameter
<code class="reqn">\beta \lambda</code> (for some known, real
<code class="reqn">\beta</code>).  We observe the process 
at a finite  set of times over a time
interval  [0,T].
</p>
<p>In order to calculate the information matrix for partial data, several
conditional expectations of products of sufficient statistics are
needed.  
We have a method for  simulation conditional on the data,
sim.condBD, which we use to
estimate these.
</p>
<p>Generally for getting the information matrix after running the EM
algorithm,  sim.condBD is called to simulate with the given parameters
(estimates, usually), and the output sims are passed.  It is often
important that the same set of sims are used to get all the results if
the goal is to create an information matrix.
</p>


<h3>Value</h3>

<p>getBDsummaryExpecs simply returns (an estimate of) E(fnc(Nt+)),
E(fnc(Nt-)), and E(fnc(Rt)), where Nt+, Nt-, and Rt are the numbre of
jumps up, the number of jumps down, and the total holding time,
respectively.  They are returned in that order, also with labels
&quot;Nplus&quot;, &quot;Nminus&quot;, and &quot;Holdtime&quot;.
</p>
<p>getBDsummaryProdExpecs returns E(Nt+ * Nt-), E(Nt+ * Rt), and E(Nt- *
Rt), in that order, also with the labels &quot;NplusNminus&quot;,
&quot;NplusHoldtime&quot;, &quot;NminusHoldtime&quot;.
</p>
<p>Returns another row of with corresponding
standard deviations if getsd=TRUE.
</p>


<h3>Author(s)</h3>

<p>Charles Doss</p>


<h3>See Also</h3>

<p><code><a href="#topic+add.joint.mean.many">add.joint.mean.many</a></code>,
<code><a href="#topic+sim.condBD">sim.condBD</a></code></p>

<hr>
<h2 id='BD.MCMC.SC'>MCMC on Linear Birth Death Process</h2><span id='topic+BD.MCMC.SC'></span>

<h3>Description</h3>

<p>Bayesian parameter estimation via Gibbs sampler MCMC on
Linear Birth Death process, (_S_pecial _C_ase of constrained immigration)
in which the data is the state at discrete
time points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BD.MCMC.SC(Lguess, Mguess, beta.immig, alpha.L, beta.L, alpha.M, beta.M, 
    data, burnIn = 100, N = 1000, n.fft = 1024,
verbose=1, verbFile=NULL, simMethod=-1,...) 

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BD.MCMC.SC_+3A_lguess">Lguess</code></td>
<td>
<p>Starting point for <code class="reqn">\lambda</code></p>
</td></tr>
<tr><td><code id="BD.MCMC.SC_+3A_mguess">Mguess</code></td>
<td>
<p>Starting point for <code class="reqn">\mu</code></p>
</td></tr>
<tr><td><code id="BD.MCMC.SC_+3A_beta.immig">beta.immig</code></td>
<td>
<p>Immigration rate = beta.immig <code class="reqn">* \lambda</code>.</p>
</td></tr>
<tr><td><code id="BD.MCMC.SC_+3A_alpha.l">alpha.L</code></td>
<td>
<p>Shape parameter for prior for <code class="reqn">\lambda</code></p>
</td></tr>
<tr><td><code id="BD.MCMC.SC_+3A_beta.l">beta.L</code></td>
<td>
<p>Rate parameter for prior for <code class="reqn">\lambda</code></p>
</td></tr>
<tr><td><code id="BD.MCMC.SC_+3A_alpha.m">alpha.M</code></td>
<td>
<p>Shape parameter for prior for <code class="reqn">\mu</code></p>
</td></tr>
<tr><td><code id="BD.MCMC.SC_+3A_beta.m">beta.M</code></td>
<td>
<p>Rate parameter for prior for <code class="reqn">\mu</code></p>
</td></tr>
<tr><td><code id="BD.MCMC.SC_+3A_data">data</code></td>
<td>
<p>Partially observed chain. Has components $times and $states
where dat$states[i] is the state observed at time dat$times[i].</p>
</td></tr>
<tr><td><code id="BD.MCMC.SC_+3A_n">N</code></td>
<td>
<p>Number of iterations to run the MCMC for.</p>
</td></tr>
<tr><td><code id="BD.MCMC.SC_+3A_burnin">burnIn</code></td>
<td>
<p>Number of initial parameter estimates  to throw out.
(So need burnIn &lt;&lt; N.) Choose burnIn==0 throws nothing away.</p>
</td></tr>
<tr><td><code id="BD.MCMC.SC_+3A_n.fft">n.fft</code></td>
<td>
<p>Number of terms to use in the fast fourier transform or
the riemann integration     when
using the generating functions to compute probabilities or
joint expectations for the birth-death process.  See the
add.joint.mean.many, etc, functions.</p>
</td></tr>
<tr><td><code id="BD.MCMC.SC_+3A_verbose">verbose</code></td>
<td>
<p> Chooses level of printing.  Increasing from 0, which
is no printing.  
</p>
</td></tr>
<tr><td><code id="BD.MCMC.SC_+3A_verbfile">verbFile</code></td>
<td>
<p> Character signifying the file to print to.
If NULL just to standard output.
</p>
</td></tr>
<tr><td><code id="BD.MCMC.SC_+3A_simmethod">simMethod</code></td>
<td>
<p> Switch between using Accept-reject simulation and
using the exact simulation method.  If -1, the function attempts to
determine the best one of the two for the given parameters.
Value of 0 fixes it at AR, and 1 fixes it at the exact method.
</p>
</td></tr>
<tr><td><code id="BD.MCMC.SC_+3A_...">...</code></td>
<td>
<p> Unused at this point.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Assume we have a linear-birth-death
process <code class="reqn">X_t</code> with birth parameter <code class="reqn">\lambda</code>, death
parameter <code class="reqn">\mu</code>, and immigration parameter
<code class="reqn">\beta \lambda</code> (for some known, real
<code class="reqn">\beta</code>).  We observe the process 
at a finite  set of times over a time
interval  [0,T].
This runs MCMC to do parameter estimation.  The method is Gibbs
sampling, by augmenting the state space to include the  the
fully observed chain.  Then Gibbs sampling is performed
using the the conditional simulation of  sim.condBD and the fact that,
given the fully observed chain as data, independent gamma priors
are conjugate priors, with independent posteriors.
</p>


<h3>Value</h3>

<p>Returns a <code class="reqn">N-burnIn</code>x2 matrix, the nth row being the
estimators/samples at  the nth iteration.  The first
column is for lambda (birth), the second for mu (death).</p>


<h3>Author(s)</h3>

<p>Charles Doss</p>


<h3>See Also</h3>

<p><code><a href="#topic+add.joint.mean.many">add.joint.mean.many</a></code></p>

<hr>
<h2 id='bdARsimCondEnd'>
Conditional Simulation of BD via Accept-Reject
</h2><span id='topic+bdARsimCondEnd'></span><span id='topic+bdARsimCondEnd.1'></span>

<h3>Description</h3>

<p>Simulates linear birth-death processes conditional on observing the
end time (or a series of discrete observations), via simple accept
reject (ie marginal simulation and accepting if it has the right end state).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bdARsimCondEnd(Naccepted = NULL, Ntotal = NULL,Nmax=NULL,
 bd.PO = new("CTMC_PO_1", states = c(5, 7, 3),
 times = c(0, 0.4, 1)), L = 0.5, m = 0.7, nu = 0.4)
bdARsimCondEnd.1(Naccepted = NULL, Ntotal = NULL, Nmax=NULL,
T = 1.02, L = 0.3, m = 0.4, nu = 0.1, a = 8, b = 9)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bdARsimCondEnd_+3A_naccepted">Naccepted</code></td>
<td>

<p>Number of accepted sims to have at the end.
Naccepted overrides Ntotal.  If you want to use Ntotal, Naccepted
should be NULL.  Note that the number of sims will be &gt;= Naccepted,
probably not exactly equal to Naccepted.  
</p>
</td></tr>
<tr><td><code id="bdARsimCondEnd_+3A_ntotal">Ntotal</code></td>
<td>

<p>Number of marginal sims to do; no guarantee of how many sims you
will get out, but a better guarantee of how long it will take.
If it gets no sims, it returns list().
</p>
</td></tr>
<tr><td><code id="bdARsimCondEnd_+3A_nmax">Nmax</code></td>
<td>

<p>Different than Ntotal; it works with Naccepted.  The function
quits when either it has Naccepted sims or when it has
done Nmax attempts.  If it hits the max,returns whatever has been
simulated so far, possibly list() if nothing.
</p>
</td></tr>
<tr><td><code id="bdARsimCondEnd_+3A_t">T</code></td>
<td>

<p>Length of time of the chain.
</p>
</td></tr>
<tr><td><code id="bdARsimCondEnd_+3A_l">L</code></td>
<td>

<p>Linear Birth rate.
</p>
</td></tr>
<tr><td><code id="bdARsimCondEnd_+3A_m">m</code></td>
<td>

<p>Linear death rate.
</p>
</td></tr>
<tr><td><code id="bdARsimCondEnd_+3A_nu">nu</code></td>
<td>

<p>Immigration rate.
</p>
</td></tr>
<tr><td><code id="bdARsimCondEnd_+3A_bd.po">bd.PO</code></td>
<td>

<p>For bdARsimCondEnd, this is a list of observations essentially;
Either class &quot;CTMC_PO_1&quot; or the analogous list.
</p>
</td></tr>
<tr><td><code id="bdARsimCondEnd_+3A_a">a</code></td>
<td>

<p>Starting state.
</p>
</td></tr>
<tr><td><code id="bdARsimCondEnd_+3A_b">b</code></td>
<td>

<p>Ending state (when you have just one observation).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Outputs a list of BDMC objects.  If Naccepted is not NULL then the
list will be at least Naccepted long. 
</p>


<h3>Value</h3>

<p>List of BDMC objects.
</p>


<h3>Author(s)</h3>

<p>Charles Doss
</p>


<h3>Examples</h3>

<pre><code class='language-R'>bdARsimCondEnd.1(Naccepted=10);  #default parameters; simulates at least10.
bdARsimCondEnd.1(Ntotal=10);  #default parameters; maybe end with none.
</code></pre>

<hr>
<h2 id='BDloglikelihood.PO'>
Calculate log likelihood of Partially Observed BD process
</h2><span id='topic+BDloglikelihood.PO'></span><span id='topic+BDloglikelihood.PO.CTMC_PO_1'></span><span id='topic+BDloglikelihood.PO.CTMC_PO_many'></span><span id='topic+BDloglikelihood.PO.list'></span>

<h3>Description</h3>

<p>Calculates the  log likelihood of a &quot;partially observed
birth-death-immigration process.&quot;  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'CTMC_PO_1'
BDloglikelihood.PO(partialDat, L, m, nu,  n.fft = 1024)
## S3 method for class 'CTMC_PO_many'
BDloglikelihood.PO(partialDat, L, m, nu,  n.fft = 1024)
## S3 method for class 'list'
BDloglikelihood.PO(partialDat, L, m, nu,  n.fft = 1024)
BDloglikelihood.PO(partialDat, L, m, nu, n.fft = 1024)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BDloglikelihood.PO_+3A_l">L</code></td>
<td>

<p>lambda, birth rate.
</p>
</td></tr>
<tr><td><code id="BDloglikelihood.PO_+3A_m">m</code></td>
<td>

<p>mu, death rate.
</p>
</td></tr>
<tr><td><code id="BDloglikelihood.PO_+3A_nu">nu</code></td>
<td>

<p>nu, Immigration rate.
</p>
</td></tr>
<tr><td><code id="BDloglikelihood.PO_+3A_partialdat">partialDat</code></td>
<td>

<p>Either of class &quot;CTMC_PO_many&quot;, or of
class &quot;CTMC_PO_1&quot; or the latter's analog in list form, ie
a list with the two components &quot;states&quot; and &quot;times&quot; for
the &quot;list&quot; and default versions of this method.
</p>
</td></tr>
<tr><td><code id="BDloglikelihood.PO_+3A_n.fft">n.fft</code></td>
<td>

<p>precision for riemann integration / fast fourier transform.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Immigration can be arbitrary here.  Calculates likelihood of the
b-d-i proces when it is observed at discrete timepoints.
</p>


<h3>Value</h3>

<p>Real number.
</p>


<h3>Author(s)</h3>

<p>charles doss
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(DOBAD)
T=25;
L &lt;- .3
mu &lt;- .6
beta.immig &lt;- 1.2;
initstate &lt;- 17;

#generate process
dat &lt;- birth.death.simulant(t=T, lambda=L, m=mu, nu=L*beta.immig, X0=initstate);
#"observe" process
delta &lt;- 2
partialData &lt;- getPartialData( seq(0,T,delta), dat);
#calculate the likelihood
BDloglikelihood.PO(partialDat=partialData, L=L, m=mu, nu=beta.immig*L);
</code></pre>

<hr>
<h2 id='BDMC_many-class'>Class <code>"BDMC_many"</code></h2><span id='topic+BDMC_many-class'></span>

<h3>Description</h3>


<p>A vector of BDMCs. Changes in the state for each element list should
be by 1 only.
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("BDMC_many", ...)</code>
and supplying a &quot;CTMC_many&quot; object.
</p>


<h3>Slots</h3>


<dl>
<dt><code>CTMCs</code>:</dt><dd><p>Object of class <code>"list"</code>, a
&quot;CTMC_many&quot; object</p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class &quot;CTMC_many&quot;, directly.
</p>


<h3>Methods</h3>

<p>No methods defined with class &quot;BDMC_many&quot; in the signature.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>showClass("BDMC_many")
</code></pre>

<hr>
<h2 id='BDMC-class'>Class &quot;BDMC&quot;</h2><span id='topic+BDMC-class'></span>

<h3>Description</h3>

<p>	Birth-Death(-Immigration) CTMCs. Changes in state must
be by 1 only. </p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("BDMC", ...)</code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>states</code>:</dt><dd><p>Object of class <code>"numeric"</code> ~~ </p>
</dd>
<dt><code>times</code>:</dt><dd><p>Object of class <code>"numeric"</code> ~~ </p>
</dd>
<dt><code>T</code>:</dt><dd><p>Object of class <code>"numeric"</code> ~~ </p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"<a href="#topic+CTMC-class">CTMC</a>"</code>, directly.
</p>


<h3>Methods</h3>


<dl>
<dt>BDsummaryStats</dt><dd><p><code>signature(sim = "BDMC")</code>: ... </p>
</dd>
<dt>getStates</dt><dd><p><code>signature(object = "BDMC")</code>: ... </p>
</dd>
<dt>getTimes</dt><dd><p><code>signature(object = "BDMC")</code>: ... </p>
</dd>
</dl>



<h3>See Also</h3>

<p><a href="#topic+BDsummaryStats+2CBDMC-method">BDsummaryStats,BDMC-method</a>,
<a href="#topic+getT+2CBDMC-method">getT,BDMC-method</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>showClass("BDMC")
</code></pre>

<hr>
<h2 id='BDPOloglikeGradSqr.CTMC_PO_many'>
Gradient-Squared of PartialData likelihood
</h2><span id='topic+BDPOloglikeGradSqr.CTMC_PO_many'></span>

<h3>Description</h3>

<p>In Louis' 82 formula for the information of  partially observed data,
the last term is the gradient-squared of the partial data likelihood.
It doesn't have to be calculated because it's 0 at the MLE,
but it's coded here for debugging purposes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BDPOloglikeGradSqr.CTMC_PO_many(partialDat, L, m, beta, n.fft = 1024)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BDPOloglikeGradSqr.CTMC_PO_many_+3A_partialdat">partialDat</code></td>
<td>

<p>CTMC_PO_many.
</p>
</td></tr>
<tr><td><code id="BDPOloglikeGradSqr.CTMC_PO_many_+3A_l">L</code></td>
<td>

<p>lambda at which to calculate information; usually MLE.
</p>
</td></tr>
<tr><td><code id="BDPOloglikeGradSqr.CTMC_PO_many_+3A_m">m</code></td>
<td>

<p>mu at which to calculate information; usually MLE.
</p>
</td></tr>
<tr><td><code id="BDPOloglikeGradSqr.CTMC_PO_many_+3A_beta">beta</code></td>
<td>

<p>known constant defining nu via nu=beta*lambda.
</p>
</td></tr>
<tr><td><code id="BDPOloglikeGradSqr.CTMC_PO_many_+3A_n.fft">n.fft</code></td>
<td>

<p>deprecated unused.
</p>
</td></tr>
</table>

<hr>
<h2 id='BDsummaryStats'>Get summary statistics for EM Algorithm on Linear Birth-Death Process</h2><span id='topic+BDsummaryStats.PO'></span><span id='topic+BDsummaryStats.PO+2Clist-method'></span><span id='topic+BDsummaryStats.PO+2CCTMC_PO_many-method'></span><span id='topic+BDsummaryStats.PO+2CCTMC_PO_1-method'></span><span id='topic+NijBD'></span><span id='topic+NijBD.CTMC_many'></span><span id='topic+waitTimes'></span><span id='topic+BDsummaryStats+2CBDMC_many-method'></span><span id='topic+BDsummaryStats+2CBDMC-method'></span><span id='topic+BDsummaryStats+2Clist-method'></span><span id='topic+BDsummaryStats'></span>

<h3>Description</h3>

<p>When passed in a birth-death markov chain, this extracts the summary
statistics that are needed for computing the MLE (if immigration is a
fixed known constant multiple of birth).
</p>
<p>That is, BDsummaryStats returns the counts of the total number of
jumps up, the total number of jumps down, and the total holding/waiting time
(</p>
<p style="text-align: center;"><code class="reqn">\sum_i d(i)*i</code>
</p>
<p>, where d(i) is time spent in state i).
</p>
<p>BDsummaryStats.PO does something similar, but for a partially observed
process.
</p>
<p>NijBD takes a BD CTMC and calculates the number of jumps up and the
number of jumps down.
</p>
<p>waitTimes takes a CTMC and calculates the waiting time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BDsummaryStats(sim)
BDsummaryStats.PO(dat)
NijBD(BDhist)
NijBD.CTMC_many(BDhists)
waitTimes(stateHist, timeHist, T)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BDsummaryStats_+3A_sim">sim</code></td>
<td>
<p>A fully observed BDMC (or list with $states, $times, $T),
or a BDMC_many.    </p>
</td></tr>
<tr><td><code id="BDsummaryStats_+3A_dat">dat</code></td>
<td>
<p>Partially observed CTMC (list with $states, $times, $T), no
&quot;BD&quot; restrictions on the structure of the chain.</p>
</td></tr>
<tr><td><code id="BDsummaryStats_+3A_bdhist">BDhist</code></td>
<td>
<p>States of a BDMC; can be either a vector of states (each
differing from its predecessor by 1) or a BDMC in list or class form.</p>
</td></tr>
<tr><td><code id="BDsummaryStats_+3A_bdhists">BDhists</code></td>
<td>
<p>CTMC_many object</p>
</td></tr>
<tr><td><code id="BDsummaryStats_+3A_statehist">stateHist</code></td>
<td>
<p>Vector of states (integers). Corresponds to timeHist.</p>
</td></tr>
<tr><td><code id="BDsummaryStats_+3A_timehist">timeHist</code></td>
<td>
<p>Vector of times (reals).  Corresponds to stateHist, i.e.
stateHist[i] is the state at and after timeHist[i].</p>
</td></tr>
<tr><td><code id="BDsummaryStats_+3A_t">T</code></td>
<td>
<p>Total time the chain was observed for.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Assume we have a linear-birth-death
process <code class="reqn">X_t</code> with birth parameter <code class="reqn">\lambda</code>, death
parameter <code class="reqn">\mu</code>, and immigration parameter
<code class="reqn">\beta \lambda</code> (for some known, real
<code class="reqn">\beta</code>).  We observe the process 
at a finite  set of times over a time
interval  [0,T].
</p>
<p>If the process is fully observed then to calculate the MLEs, we need
the number of jumps up, down, and the total holding time.
BDsummaryStats takes a
BD CTMC and returns these three values, in a vector, with the names
&quot;Nplus&quot; and &quot;Nminus&quot; for the number of jumps up and number of jumps
down, respectively, and the name &quot;Holdtime&quot; for the total holding
time.
</p>
<p>If the process is not fully observed, then these statistics aren't
known.  (The EM algorithm is essentially trying to get a best-guess of
these statistics).  BDsummaryStats.PO returns, rather, a very naive
guess.  It pretends that the process is essentially fully observed and
computes the statistics from that.  Note it's not the same as calling
BDsummaryStats since a BD process has stipulations on its format that
a partially observed BD process doesn't. The values are returned with
the same naming convention as BDsummaryStats.  
</p>
<p>NijBD takes the list of states of a BD CTMC, and returns a 2x(n+1)
matrix,  where  n is the maximum state the chain visits.
NijBD(arg)[1,k] is the number of jumps down from state k-1, and
NijBD(arg)[2,k] is the number of jumps up from state k-1.
</p>
<p>waitTimes takes any fully observed CTMC and returns a numeric vector
of length n+1 where the maximum state passed in is n.  The ith entry
is the waiting time in the i-1st state.  So
seq(0, to=n, by=1) %*% waitTimes gives the total holding time.
</p>


<h3>Value</h3>

<p>See details</p>


<h3>Author(s)</h3>

<p>Charles Doss</p>


<h3>See Also</h3>

<p><a href="#topic+BDMC-class">BDMC-class</a></p>

<hr>
<h2 id='birth.death.simulant'>Simulation of birth-death processes with immigration</h2><span id='topic+birth.death.simulant'></span>

<h3>Description</h3>

<p>A set of functions for simulating and summarizing birth-death simulations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>birth.death.simulant(t,X0=1,lambda=1,mu=2,nu=1, condCounts=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="birth.death.simulant_+3A_t">t</code></td>
<td>
<p>length of the time interval</p>
</td></tr>
<tr><td><code id="birth.death.simulant_+3A_lambda">lambda</code></td>
<td>
<p>per particle birth rate</p>
</td></tr>
<tr><td><code id="birth.death.simulant_+3A_mu">mu</code></td>
<td>
<p>per particle death rate</p>
</td></tr>
<tr><td><code id="birth.death.simulant_+3A_nu">nu</code></td>
<td>
<p>immigration rate</p>
</td></tr>
<tr><td><code id="birth.death.simulant_+3A_x0">X0</code></td>
<td>
<p>starting state, a non-negative integer</p>
</td></tr>
<tr><td><code id="birth.death.simulant_+3A_condcounts">condCounts</code></td>
<td>
<p>is either null or a numeric vector with items named
&quot;Nplus&quot; and &quot;Nminus&quot; (possibly from BDsummaryStats).  
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Birth-death process is denoted by <code class="reqn">X_t</code>
</p>
<p>Function birth.death.simulant returns a BDMC object.    
</p>


<h3>Author(s)</h3>

<p>Marc A. Suchard</p>


<h3>See Also</h3>

<p><code><a href="#topic+add.joint.mean.many">add.joint.mean.many</a></code>,<code><a href="#topic+add.generator">add.generator</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>my.lambda = 2
my.mu = 3
my.nu =1
my.time = 0.5
my.start = 10
my.end = 2
my.n = 2000

# simulate a birth death trajectory
my.simulant=birth.death.simulant(t=my.time,X0=my.start,lambda=my.lambda,mu=my.mu,nu=my.nu)
print(my.simulant)

# summarize the simulated trajectory
BDsummaryStats(my.simulant)

</code></pre>

<hr>
<h2 id='bracket-methods'>Methods for Function <code>[</code> in Package <span class="pkg">DOBAD</span></h2><span id='topic++5B+2CCTMC_many+2CANY+2CANY+2CANY-method'></span><span id='topic++5B+2CCTMC_PO_many+2CANY+2CANY+2CANY-method'></span>

<h3>Description</h3>

<p>Methods for function <code>[</code> in package <span class="pkg">DOBAD</span>
</p>


<h3>Methods</h3>


<dl>
<dt><code>signature(x = "CTMC_many", i = "ANY", j = "ANY", drop = "ANY")</code></dt><dd>
<p>Returns a CTMC_many object from the list of CTMCs indicated by the subscripts.
</p>
</dd>
<dt><code>signature(x = "CTMC_PO_many", i = "ANY", j = "ANY", drop = "ANY")</code></dt><dd>
<p>Returns a CTMC_PO_many object from the list of CTMCs indicated by the subscripts.
</p>
</dd>
</dl>

<hr>
<h2 id='combineCTMC'>
Combine several CTMCs into one CTMC 
</h2><span id='topic+combineCTMC'></span>

<h3>Description</h3>

<p>Pastes together several CTMCs into one.  It doesn't check that the
rules of the CTMCs are held to.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>combineCTMC(sims)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="combineCTMC_+3A_sims">sims</code></td>
<td>

<p>a list each of whose element is a CTMC; so sims[[i]] is a CTMC. sims[[i]]
can be of class &quot;CTMC&quot; or a list.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that each CTMC should include &quot;0&quot; as its first time.  And the
last state of sims[[i]] and the first state of sims[[i+1]] should
&quot;match&quot; in that the user should check they follow the rules of
whatever the generating process is for the CTMC.
</p>


<h3>Value</h3>

<p>Returns a list (not a CTMC object!) with states, times, and T.
</p>

<hr>
<h2 id='CTMC_PO_1-class'>Class &quot;CTMC_PO_1&quot;</h2><span id='topic+CTMC_PO_1-class'></span>

<h3>Description</h3>

<p>Partially observed CTMC.</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("CTMC_PO_1", ...)</code>.
Like CTMCs butdon't have an ending time; the final observation time
serves that purpose.  
</p>


<h3>Slots</h3>


<dl>
<dt><code>states</code>:</dt><dd><p>Object of class <code>"numeric"</code> ~~ </p>
</dd>
<dt><code>times</code>:</dt><dd><p>Object of class <code>"numeric"</code> ~~ </p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>BDsummaryStats.PO</dt><dd><p><code>signature(dat = "CTMC_PO_1")</code>: ... </p>
</dd>
<dt>getStates</dt><dd><p><code>signature(object = "CTMC_PO_1")</code>: ... </p>
</dd>
<dt>getTimes</dt><dd><p><code>signature(object = "CTMC_PO_1")</code>: ... </p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Charles Doss</p>


<h3>Examples</h3>

<pre><code class='language-R'>showClass("CTMC_PO_1")
</code></pre>

<hr>
<h2 id='CTMC_PO_many-class'>Class &quot;CTMC_PO_many&quot; </h2><span id='topic+CTMC_PO_many-class'></span>

<h3>Description</h3>

<p>	 ~~ A concise (1-5 lines) description of what the class is.  ~~</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("CTMC_PO_many", ...)</code>.
This class is a grouping of data, essentially.  CTMC_PO_1 is a 
series
of observations from a single chain; this is several of those single
observations
together.
</p>


<h3>Slots</h3>


<dl>
<dt><code>BDMCsPO</code>:</dt><dd><p>Object of class <code>"list"</code> ~~ </p>
</dd>
</dl>



<h3>Methods</h3>

<p>No methods defined with class &quot;CTMC_PO_many&quot; in the signature.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>showClass("CTMC_PO_many")
</code></pre>

<hr>
<h2 id='CTMC-class'>Class &quot;CTMC&quot;</h2><span id='topic+CTMC-class'></span>

<h3>Description</h3>

<p>Continuous time Markov Chain class</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("CTMC", ...)</code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>states</code>:</dt><dd><p>numerics; usually integers. </p>
</dd>
<dt><code>times</code>:</dt><dd><p>numerics; an _increasing_ sequence. </p>
</dd>
<dt><code>T</code>:</dt><dd><p>final &quot;observation&quot; time of the chain, or time at
which it is posited to exist.  </p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>getStates</dt><dd><p><code>signature(object = "CTMC")</code>: ... </p>
</dd>
<dt>getT</dt><dd><p><code>signature(object = "CTMC")</code>: ... </p>
</dd>
<dt>getTimes</dt><dd><p><code>signature(object = "CTMC")</code>: ... </p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Charles Doss </p>


<h3>See Also</h3>

<p><a href="#topic+getT+2CCTMC-method">getT,CTMC-method</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>showClass("CTMC")
</code></pre>

<hr>
<h2 id='CTMC.simulate'>
Simulate from (&quot;regular&quot;) CTMC 
</h2><span id='topic+CTMC.simulate'></span>

<h3>Description</h3>

<p>Only CTMCs that have finite number of states to jump directly to
starting from all given starting states are allowed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CTMC.simulate(rate.fn, jumpLim.fn, T.time, init.state)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CTMC.simulate_+3A_rate.fn">rate.fn</code></td>
<td>

<p>Rate function from N^2 -&gt; R.  
</p>
</td></tr>
<tr><td><code id="CTMC.simulate_+3A_jumplim.fn">jumpLim.fn</code></td>
<td>

<p>Takes a state (integeR) as argument and
returns an integer-pair. The 1st entry is the minimum
possible state that can be jumped to from the argument
as starting point, and the second is the maximum.
These must be finite.
</p>
</td></tr>
<tr><td><code id="CTMC.simulate_+3A_t.time">T.time</code></td>
<td>

<p>length of time to simulate for.
</p>
</td></tr>
<tr><td><code id="CTMC.simulate_+3A_init.state">init.state</code></td>
<td>

<p>Starting state of sim.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Simulates from a CTMC whose states are the integers.
This version requires that each state can only jump
to finitely many other states.  This information is
encapsulated in jumpLim.fn.  This isn't fundamental
but makes things proceed faster.
</p>


<h3>Author(s)</h3>

<p>Charles Doss
</p>

<hr>
<h2 id='CTMC.simulate.piecewise'>
Simulate from piecewise constant/homogeneous CTMC
</h2><span id='topic+CTMC.simulate.piecewise'></span>

<h3>Description</h3>

<p>Via the CTMC.simulate function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CTMC.simulate.piecewise(rate.fns, jumpLim.fns, T.times, init.state)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CTMC.simulate.piecewise_+3A_rate.fns">rate.fns</code></td>
<td>

<p>a LIST of rate functions corresponding to jumpLim.fns and T.times.
Length is number of homogeneous pieces, we'll call it M.    
</p>
</td></tr>
<tr><td><code id="CTMC.simulate.piecewise_+3A_jumplim.fns">jumpLim.fns</code></td>
<td>

<p>a LIST of 'jumpLim' functions of length M like the list rate.fns.
See the documentation for CTMC.simulate for an explanation of what
each is.
</p>
</td></tr>
<tr><td><code id="CTMC.simulate.piecewise_+3A_t.times">T.times</code></td>
<td>

<p>Of length M+1 so that there are M intervals corresponding to rate.fns.
</p>
</td></tr>
<tr><td><code id="CTMC.simulate.piecewise_+3A_init.state">init.state</code></td>
<td>

<p>A starting state for the simulated chain.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of type CTMC.
</p>


<h3>Author(s)</h3>

<p>Charles Doss
</p>

<hr>
<h2 id='CTMC2list'>
Convert Between two representations of a Continuous Time Markov Chain.
</h2><span id='topic+CTMC2list'></span>

<h3>Description</h3>

<p>Convert Between two representations of a Continuous Time Markov Chain.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CTMC2list(aCTMC)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CTMC2list_+3A_actmc">aCTMC</code></td>
<td>

<p>CTMC obj
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Convert between two representations.
</p>


<h3>Value</h3>

<p>return  a list.
</p>

<hr>
<h2 id='CTMCPO2indepIntervals'>
Converts CTMC_PO (either CTMC_PO_1 or CTMC_PO_many) to independent intervals.
</h2><span id='topic+CTMCPO2indepIntervals.CTMC_PO_1'></span><span id='topic+CTMCPO2indepIntervals.CTMC_PO_many'></span><span id='topic+CTMCPO2indepIntervals'></span>

<h3>Description</h3>

<p>The markov property means that conditional on endpoints, each
interval of a markov chain is independent of the others.  
For this reason   computations are often done on intervals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'CTMC_PO_1'
CTMCPO2indepIntervals(partialDat)
## S3 method for class 'CTMC_PO_many'
CTMCPO2indepIntervals(partialDat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CTMCPO2indepIntervals_+3A_partialdat">partialDat</code></td>
<td>

<p>CTMC_PO_1 or CTMC_PO_many
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function converts data into a nx3 matrix where
the first column is the starting state, the second is the ending state
and the third is the length of time the interval spanned.  No
distinction is made between data from &quot;separate&quot; units or
separate intervals from the same markov chain.
</p>

<hr>
<h2 id='derivType'>
Helper for getting means from generating functions
</h2><span id='topic+derivType'></span>

<h3>Description</h3>

<p>Choose whether to do one-sided or two-sided differentiation.  The
latter is more effective/less unstable but not always defined.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>derivType(L, mu, eps = 1e-04)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="derivType_+3A_l">L</code></td>
<td>

</td></tr>
<tr><td><code id="derivType_+3A_mu">mu</code></td>
<td>

</td></tr>
<tr><td><code id="derivType_+3A_eps">eps</code></td>
<td>

</td></tr>
</table>


<h3>Details</h3>

<p>Getting the means of interest from generating functions involves
differentiation which is usually done numerically.  The functions
of interest are fully defined on one side of the point of interest but
have limited (if any) definition on the other side of the point.  For
instance, if lambda=mu then the generator for the process N+ is not
defined for r&gt;1.  If lambda and mu are close then the process is
defined for r&gt;1 but very close to 1.  The function derivType takes
lambda and mu and an epsilon and decides whether that epsilon is small
enough to do a two sided derivative with epsilon as &quot;h&quot; or if a one
sided derivative is needed.
</p>

<hr>
<h2 id='doublebracket-methods'>Methods for Function <code>[[</code> in Package <span class="pkg">DOBAD</span></h2><span id='topic++5B+5B+2CCTMC_many+2CANY+2CANY+2CANY-method'></span><span id='topic++5B+5B+2CCTMC_PO_many+2CANY+2CANY+2CANY-method'></span>

<h3>Description</h3>

<p>Methods for function <code>[[</code> in package <span class="pkg">DOBAD</span>
</p>


<h3>Methods</h3>


<dl>
<dt><code>signature(x = "CTMC_many", i = "ANY", j = "ANY", drop = "ANY")</code></dt><dd>
<p>Returns the indicated CTMC object.
</p>
</dd>
<dt><code>signature(x = "CTMC_PO_many", i = "ANY", j = "ANY", drop = "ANY")</code></dt><dd>
<p>Returns the indicated CTMC_PO_1 object.
</p>
</dd>
</dl>

<hr>
<h2 id='EM.BD.SC'>Expectation-Maximization on Linear Birth Death (_S_pecial _C_ase
with constrained immigration)</h2><span id='topic+EM.BD.SC'></span><span id='topic+EM.BD.SC.1'></span>

<h3>Description</h3>

<p>EM Algorithm for estimating rate parameters of a linear
Birth-Death process, in which the data is the state at discrete
time points
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EM.BD.SC(dat, initParamMat, tol = 1e-04, M = 30, beta.immig,  dr =
1e-07, n.fft = 1024, r=4, prec.tol=1e-12, prec.fail.stop=TRUE,
verbose=1, verbFile=NULL)
EM.BD.SC.1(dat,init.params, tol = 0.001, M = 30, beta.immig,  dr =
1e-07, n.fft = 1024, r=4, prec.tol=1e-12, prec.fail.stop=TRUE,
verbose=1, verbFile=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="EM.BD.SC_+3A_initparammat">initParamMat</code></td>
<td>
<p><code class="reqn">n</code>x2 matrix. Each row is an initial parameter
setting. <code class="reqn">n</code> is the number of times to run the full EM
algorithm. On the <code class="reqn">n</code>th time the initial &quot;guess&quot; of the
lambda is initParamMat[n,1] and of mu it's initParamMat[n,2]. Used
to automate starting at dispersed values to ensure global maximum.
Frequently <code class="reqn">n</code> is one.    
</p>
</td></tr>
<tr><td><code id="EM.BD.SC_+3A_init.params">init.params</code></td>
<td>
<p>Vector of length two, first number is the first
guess for lambda, second is the guess for mu.  This is like a single
row from initParamMat.</p>
</td></tr>
<tr><td><code id="EM.BD.SC_+3A_m">M</code></td>
<td>
<p>Maximum number of iterations for (each) EM algorithm to run
through. EM algorithm stops at Mth iteration.</p>
</td></tr>
<tr><td><code id="EM.BD.SC_+3A_tol">tol</code></td>
<td>
<p>Tolerance for EM algorithm; when two iterations are
within tol of each other the algorithm ends.  Algorithm also ends
after M iterations have been reached.
(note: One can debate whether 'tol' should refer to the estimates or
to the actual likelihood.  here it is the estimates, though).
</p>
</td></tr>
<tr><td><code id="EM.BD.SC_+3A_beta.immig">beta.immig</code></td>
<td>
<p>Immigration rate is constrained to be a multiple of
the birth rate.  immigrationrate = beta.immig * lambda where lambda
is birth rate.</p>
</td></tr>
<tr><td><code id="EM.BD.SC_+3A_n.fft">n.fft</code></td>
<td>
<p>Number of terms to use in the fast fourier transform or
the riemann integration 
when
using the generating functions to compute probabilities or
joint expectations for the birth-death process.  See the
add.cond.mean.many, etc, functions.</p>
</td></tr>
<tr><td><code id="EM.BD.SC_+3A_dat">dat</code></td>
<td>
<p>Partially observed chain. Either of class &quot;CTMC_PO_many&quot;
for several independent histories, of class &quot;CTMC_PO_1&quot; for one
history, or a list with components $times and $states
where dat$states[i] is the state observed at time dat$times[i]
(ie, if it is a list then it is analogous to &quot;CTMC_PO_1&quot;).</p>
</td></tr>
<tr><td><code id="EM.BD.SC_+3A_dr">dr</code></td>
<td>
<p>Parameter for numerical differentiation</p>
</td></tr>
<tr><td><code id="EM.BD.SC_+3A_r">r</code></td>
<td>
<p>Parameter for numerical differentiation; see numDeriv package
documentation.</p>
</td></tr> 
<tr><td><code id="EM.BD.SC_+3A_prec.tol">prec.tol</code></td>
<td>
<p>&quot;Precision tolerance&quot;; to compute conditional means,
first the joint means are computed and then they are normalized by
transition probabilities.  The precision parameters govern the
conditions under which the function will quit if these values are
very small.  If the joint-mean is smaller than prec.tol then
the value of prec.fail.stop decides whether to stop or continue.</p>
</td></tr>
<tr><td><code id="EM.BD.SC_+3A_prec.fail.stop">prec.fail.stop</code></td>
<td>
<p>If true, then when joint-mean values are
smaller than prec.tol the program stops; if false then it continues,
usually printing a warning.</p>
</td></tr>
<tr><td><code id="EM.BD.SC_+3A_verbose">verbose</code></td>
<td>
<p> Chooses level of printing.  Increasing from 0, which
is no printing.  
</p>
</td></tr>
<tr><td><code id="EM.BD.SC_+3A_verbfile">verbFile</code></td>
<td>
<p> Character signifying the file to print to.
If NULL just to standard output.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Assume we have a linear-birth-death
process <code class="reqn">X_t</code> with birth parameter <code class="reqn">\lambda</code>, death
parameter <code class="reqn">\mu</code>, and immigration parameter
<code class="reqn">\beta \lambda</code> (for some known, real
<code class="reqn">\beta</code>).  We observe the process 
at a finite  set of times over a time
interval  [0,T].  Runs EM algorithm to do maximum likelihood.
</p>
<p>EM.BD.SC will run the algorithm on multiple starting values and return
the history for the best starting value.
EM.BD.SC.1 only runs the algorithm for one starting value.  Otherwise
they are the same.  
</p>


<h3>Value</h3>

<p>Returns a <code class="reqn">M+1</code>x2 matrix, the nth row being the estimators at
the nth iteration.  The first
column is for lambda (birth), the second for mu (death).  If tol is
reached before M iterations then many of the rows will be empty, but
the M+1st always contains the estimators.</p>


<h3>Author(s)</h3>

<p>Charles Doss</p>


<h3>See Also</h3>

<p><code><a href="#topic+add.cond.mean.many">add.cond.mean.many</a></code></p>

<hr>
<h2 id='EM.BD.SC.cov.1sv'>
Expectation-Maximization on Linear Birth Death (and constrained
Immigration) with Covariates
</h2><span id='topic+EM.BD.SC.cov.1sv'></span>

<h3>Description</h3>

<p>EM algorithm for maximum likelihood estimation of rate parameters of
linear Birth-Death-Immigration processes in which data is the  state
at discrete time points, and one has covariates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EM.BD.SC.cov.1sv(BDMCs.PO, ZZ.LL, ZZ.MM, coefs.LL.init, coefs.MM.init,
tol = 1e-04, M = 30, beta.immig,
dr = 1e-07, n.fft = 1024, r = 4,
prec.tol = 1e-12, prec.fail.stop = TRUE,
nlmiterlim = 100, nlmgradtol = 1e-09, nlmstepmax = 0.5, verbose = 1, verbFile = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="EM.BD.SC.cov.1sv_+3A_bdmcs.po">BDMCs.PO</code></td>
<td>

<p>Data for doing estimation.  See dat argument to EM.BD.SC.  Of class
&quot;CTMC_PO_many&quot; (several independent histories) or &quot;CTMC_PO_1&quot; (one history).
</p>
</td></tr>
<tr><td><code id="EM.BD.SC.cov.1sv_+3A_zz.ll">ZZ.LL</code></td>
<td>

<p>Covariates (design matrix) for predicting lambda. (Could be
duplicates of ZZ.MM.) The model is:   log lambda = ZZ.LL %*%
gamma.LL, for some coefficients gamma.LL.
</p>
</td></tr>
<tr><td><code id="EM.BD.SC.cov.1sv_+3A_zz.mm">ZZ.MM</code></td>
<td>

<p>Covariates (design matrix) for  predicting mu.  (Could be duplicates
of ZZ.LL.)
The model is: log mu = ZZ.mu %*% gamma.mu, for some coefficients gamma.mu.
</p>
</td></tr>
<tr><td><code id="EM.BD.SC.cov.1sv_+3A_beta.immig">beta.immig</code></td>
<td>

<p>Immigration rate is constrained to be a multiple of
the birth rate.  immigrationrate = beta.immig * lambda where lambda
is birth rate.
</p>
</td></tr>
<tr><td><code id="EM.BD.SC.cov.1sv_+3A_coefs.ll.init">coefs.LL.init</code></td>
<td>

<p>Initial linear coefficients determining lambda, the birth rate.
</p>
</td></tr>
<tr><td><code id="EM.BD.SC.cov.1sv_+3A_coefs.mm.init">coefs.MM.init</code></td>
<td>

<p>Initial linear coefficients determining mu, the death rate.
</p>
</td></tr>
<tr><td><code id="EM.BD.SC.cov.1sv_+3A_tol">tol</code></td>
<td>
<p>Tolerance for EM algorithm; when two iterations are
within tol of each other the algorithm ends.  Algorithm also ends
after M iterations have been reached.
(note: One can debate whether 'tol' should refer to the estimates or
to the actual likelihood.  here it is the estimates, though).
</p>
</td></tr>
<tr><td><code id="EM.BD.SC.cov.1sv_+3A_m">M</code></td>
<td>

<p>Maximum number of iterations for (each) EM algorithm to run
through. EM algorithm stops at Mth iteration.
</p>
</td></tr>
<tr><td><code id="EM.BD.SC.cov.1sv_+3A_dr">dr</code></td>
<td>

<p>Parameter for numerical differentiation.
</p>
</td></tr>
<tr><td><code id="EM.BD.SC.cov.1sv_+3A_n.fft">n.fft</code></td>
<td>

<p>Number of terms to use in the fast fourier transform or
the riemann integration
when
using the generating functions to compute probabilities or
joint expectations for the birth-death process.  See the
add.cond.mean.many, etc, functions.
</p>
</td></tr>
<tr><td><code id="EM.BD.SC.cov.1sv_+3A_r">r</code></td>
<td>

<p>Parameter for numerical differentiation; see numDeriv package
documentation.
</p>
</td></tr>
<tr><td><code id="EM.BD.SC.cov.1sv_+3A_nlmiterlim">nlmiterlim</code></td>
<td>

<p>For optim() call in M.step.SC.cov.
</p>
</td></tr>
<tr><td><code id="EM.BD.SC.cov.1sv_+3A_nlmgradtol">nlmgradtol</code></td>
<td>

<p>For optim() call in M.step.SC.cov.
</p>
</td></tr>
<tr><td><code id="EM.BD.SC.cov.1sv_+3A_nlmstepmax">nlmstepmax</code></td>
<td>

<p>For optim() call in M.step.SC.cov.
</p>
</td></tr>
<tr><td><code id="EM.BD.SC.cov.1sv_+3A_prec.tol">prec.tol</code></td>
<td>

<p>&quot;Precision tolerance&quot;; to compute conditional means,
first the joint means are computed and then they are normalized by
transition probabilities.  The precision parameters govern the
conditions under which the function will quit if these values are
very small.  If the joint-mean is smaller than prec.tol then
the value of prec.fail.stop decides whether to stop or continue.
</p>
</td></tr>
<tr><td><code id="EM.BD.SC.cov.1sv_+3A_prec.fail.stop">prec.fail.stop</code></td>
<td>

<p>If true, then when joint-mean values are
smaller than prec.tol the program stops; if false then it continues,
usually printing a warning.
</p>
</td></tr>
<tr><td><code id="EM.BD.SC.cov.1sv_+3A_verbose">verbose</code></td>
<td>

<p>Chooses level of printing.  Increasing from 0, which
is no printing.
</p>
</td></tr>
<tr><td><code id="EM.BD.SC.cov.1sv_+3A_verbfile">verbFile</code></td>
<td>

<p>Character signifying the file to print to.
If NULL just to standard output.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Assume we have a linear-birth-death
process <code class="reqn">X_t</code> with birth parameter <code class="reqn">\lambda</code>, death
parameter <code class="reqn">\mu</code>, and immigration parameter
<code class="reqn">\beta \lambda</code> (for some known, real
<code class="reqn">\beta</code>).
We use a log linear model so that  log lambda = ZZ.LL %*%
gamma.LL, for some coefficients gamma.LL and similarly
log lambda = ZZ.MM %*%
gamma.MM for some coefficients gamma.MM.
</p>
<p>We observe the process
at a finite  set of times over a time
interval  [0,T].  Runs EM algorithm to do maximum likelihood.
</p>


<h3>Value</h3>

<p>Returns a list with elements coeffs.LL, an <code class="reqn">pp.LL</code>x<code class="reqn">M+1</code>
matrix, and coeffs.MM, an <code class="reqn">pp.MM</code>x<code class="reqn">M+1</code> matrix where <code class="reqn">M</code>
is the number of EM iterations and pp.LL and pp.MM are the number of
coefficients for Lambda and Mu respectively.  The M+1 columns gives the
final estimators.
</p>


<h3>Author(s)</h3>

<p>Charles R. Doss.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(Matrix)
library(functional)



set.seed(1234)
mm &lt;- 30; ## num individuals. arbitrary.
pp &lt;- 2; ## num covariates, = HALF the number parameters
ZZ &lt;- matrix(rnorm(mm*pp, -2, .5), nrow=mm, ncol=pp); ## arbitrary ...
ZZ.l1 &lt;- apply(ZZ, 1, Compose(sum,abs))
coefs0.LL &lt;- rnorm(pp, 0, 1)
ZZ &lt;- (1/ZZ.l1)*ZZ ## will need |coefs.LL_j-coefs0.MM.j|&lt; logKK / max( ||z_i||_1)
KK &lt;- 2
diffs0 &lt;- (rbeta(pp, 2,2)-1/2) * log(KK) ## want |lambda-mu| within a factor of KK
coefs0.MM &lt;- coefs0.LL+diffs0;
coefs0 &lt;- matrix(c(coefs0.LL, coefs0.MM), nrow=pp,ncol=2)
theta0 &lt;- exp(ZZ %*% coefs0);
initstates &lt;- rpois(mm, 3)+1
Ts &lt;- abs(rnorm(mm,1,1)) / (theta0[,1]*initstates)
bb &lt;- 1.1; ##beta
arg &lt;- cbind(Ts,theta0, bb*coefs0.LL, initstates);
colnames(arg) &lt;- NULL
BDMCs &lt;- apply(arg, 1,
function(aa){birth.death.simulant(aa[1],aa[5], aa[2],aa[3],aa[4])})
t.obs &lt;- apply(cbind(rpois(mm,2)+2, Ts), 1,
 function(aa){sort(runif(aa[1], 0, aa[2]))}) ##at least 2 observs
BDMCs.PO &lt;- apply(cbind(t.obs,BDMCs), 1,
function(aa){getPartialData(aa[[1]],aa[[2]])})
BDMCs.PO &lt;- new("CTMC_PO_many", BDMCsPO=BDMCs.PO);



#### Run the EM: (commented for speed for CRAN checks)
##emRes1 &lt;- EM.BD.SC.cov.1sv(BDMCs.PO,
##                           ZZ.LL=ZZ, ZZ.MM=ZZ,
##                           coefs.LL.init=coefs0.LL, ##initialize at truth (which are not MLEs)
##                           coefs.MM.init=coefs0.MM,
##                           tol=1e-4,
##                           M=2, ## for speed; increase.
##                           beta.immig=bb,
##                           dr=1e-7, n.fft=1024, r=4,
##                          prec.tol=1e-12, prec.fail.stop=TRUE,
##                           verbose=1, verbFile="BD_EM_covariates_tutorial.txt")


</code></pre>

<hr>
<h2 id='EMutilities'>Functions related to implementing the EM algorithm on partially observed
Birth-Death Chain</h2><span id='topic+M.step.SC'></span><span id='topic+E.step.SC'></span>

<h3>Description</h3>

<p>These are functions for the EM algorithm on a partially observed
linear birth-death process where the immigration rate is a constant scalar
times the birthrate.  The &quot;.SC&quot; suffix refers to this constraint (&quot;SC&quot;
stands for &quot;Special Case&quot;).
</p>
<p>E.step.SC performs the &quot;Expectation step&quot; and M.step.SC performs the
maximization step.
</p>
<p>BDloglikelihood.PO computes the log likelihood of a partially observed
birth-death process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>M.step.SC(EMsuffStats, T,beta.immig)
E.step.SC(theData, oldParams, beta.immig,  dr=0.001, n.fft=1024,
                      r=4, prec.tol, prec.fail.stop)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="EMutilities_+3A_emsuffstats">EMsuffStats</code></td>
<td>
<p>Vector with names &quot;Nplus&quot;, &quot;Nminus&quot;, and
&quot;Holdtime&quot;, which are the number of jumps up, number of jumps down,
and the total holding time, respectively.
These often come from the E.step.SC function.
</p>
</td></tr>
<tr><td><code id="EMutilities_+3A_t">T</code></td>
<td>
<p>total Time the chain was observed for (ie usually the last
observation time).</p>
</td></tr>
<tr><td><code id="EMutilities_+3A_beta.immig">beta.immig</code></td>
<td>
<p>Immigration rate is constrained to be a multiple of
the birth rate.  immigrationrate = beta.immig * lambda where lambda
is birth rate.
</p>
</td></tr>
<tr><td><code id="EMutilities_+3A_oldparams">oldParams</code></td>
<td>
<p>Parameters with which to compute the expectation</p>
</td></tr>
<tr><td><code id="EMutilities_+3A_n.fft">n.fft</code></td>
<td>
<p>Number of terms to use in the fast fourier transform or
the riemann integration  when
using the generating functions to compute probabilities or
joint expectations for the birth-death process.  See the
add.joint.mean.many, etc, functions.</p>
</td></tr>
<tr><td><code id="EMutilities_+3A_thedata">theData</code></td>
<td>
<p>Partially observed chain. Has components $times and $states
where dat$states[i] is the state observed at time dat$times[i]. (No
$T component needed).</p>
</td></tr>
<tr><td><code id="EMutilities_+3A_dr">dr</code></td>
<td>
<p>Parameter for numerical differentiation</p>
</td></tr>
<tr><td><code id="EMutilities_+3A_r">r</code></td>
<td>
<p>Parameter for differentiation; see numDeriv package
documentation.</p>
</td></tr> 
<tr><td><code id="EMutilities_+3A_prec.tol">prec.tol</code></td>
<td>
<p>&quot;Precision tolerance&quot;; to compute conditional means,
first the joint means are computed and then they are normalized by
transition probabilities.  The precision parameters govern the
conditions under which the function will quit if these values are
very small.  If the joint-mean is smaller than prec.tol then
the value of prec.fail.stop decides whether to stop or continue.</p>
</td></tr>
<tr><td><code id="EMutilities_+3A_prec.fail.stop">prec.fail.stop</code></td>
<td>
<p>If true, then when joint-mean values are
smaller than prec.tol the program stops; if false then it continues,
usually printing a warning.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Assume we have a linear-birth-death
process <code class="reqn">X_t</code> with birth parameter <code class="reqn">\lambda</code>, death
parameter <code class="reqn">\mu</code>, and immigration parameter
<code class="reqn">\beta \lambda</code> (for some known, real
<code class="reqn">\beta</code>).  We observe the process 
at a finite  set of times over a time
interval  [0,T].
</p>
<p>E.step.SC computes the needed expectations for the EM algorithm.
These are the expectations of the sufficient statistics, conditional
on the data.  These expectations are computed with respect to the
measure given by oldParams, i.e. the chain governed by oldParams.
</p>
<p>M.Step.SC maximizes the partial-data likelihood given the passed in
expecatations of the sufficient statistics, to get the parameter
iterates for the  next step of the EM algorithm.
(This is easy when we are in the &quot;Special Case&quot;
where immigration is constrained.)
</p>
<p>BDloglikelihood.PO computes the log likelihood of the passed in
birth-death process.
</p>


<h3>Value</h3>

<p> M.step.SC returns a length 2 vector with first element
lambda-hat and second element mu-hat, the respective maximizers of the
likelihood.
</p>
<p>E.step.SC returns a vector with names &quot;Nplus&quot;, &quot;Nminus&quot;, and
&quot;Holdtime.&quot;
</p>
<p>BDloglikelihood.PO returns a real number, the log-likelihood of the data.
</p>


<h3>Author(s)</h3>

<p>Charles Doss</p>


<h3>See Also</h3>

<p><code><a href="#topic+EM.BD.SC">EM.BD.SC</a></code></p>

<hr>
<h2 id='getBDinform'>Helpers for Getting Information Matrix for MLE estimates on
Partially Observed Linear Birth Death (_S_pecial _C_ase
with constrained immigration)</h2><span id='topic+getBDinform.lost.SC.manual'></span><span id='topic+getBDinform.PO.SC.manual'></span><span id='topic+getBDinform.full.SC.manual'></span>

<h3>Description</h3>

<p>Assume we have data that is the state at discrete
time points of a linear birth-death process, which has immigration
parameter constrained to be a known constant times the birth rate.  
After using EM Algorithm for estimating rate parameters of a linear
Birth-Death process, these functions compute matrices related to the
information matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getBDinform.full.SC.manual(ENplus, ENminus, L, m)
getBDinform.lost.SC.manual(ENplus, ENminus, EHoldtime,
                             ENplusSq, ENminusSq, EHoldtimeSq,
                             ENplusNminus, ENplusHoldtime, ENminusHoldtime,
                             L, m, beta.immig, T)
getBDinform.PO.SC.manual(ENplus, ENminus, EHoldtime,
                             ENplusSq, ENminusSq, EHoldtimeSq,
                             ENplusNminus, ENplusHoldtime, ENminusHoldtime,
                             L, m, beta.immig, T)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getBDinform_+3A_l">L</code></td>
<td>
<p>Lambda, birth rate</p>
</td></tr>
<tr><td><code id="getBDinform_+3A_m">m</code></td>
<td>
<p>Mu, death rate</p>
</td></tr>
<tr><td><code id="getBDinform_+3A_beta.immig">beta.immig</code></td>
<td>
<p>Immigration rate is constrained to be a multiple of
the birth rate.  immigrationrate = beta.immig * lambda where lambda
is birth rate.</p>
</td></tr>
<tr><td><code id="getBDinform_+3A_t">T</code></td>
<td>
<p>Amount of time process is observed for; corresponds to time
window over which all the expectations are computed.</p>
</td></tr>
<tr><td><code id="getBDinform_+3A_enplus">ENplus</code></td>
<td>
<p>Expectation of the <code class="reqn">N_T^+</code>, the
number of jumps up , conditional on    the data.</p>
</td></tr>
<tr><td><code id="getBDinform_+3A_enminus">ENminus</code></td>
<td>
<p>Expectation of <code class="reqn">N_T^-</code>,
the number of jumps down, conditional on    the data.</p>
</td></tr>
<tr><td><code id="getBDinform_+3A_eholdtime">EHoldtime</code></td>
<td>
<p>Expectation of <code class="reqn">R_T^+</code>, the total holdtime, conditional on
the data.</p>
</td></tr>
<tr><td><code id="getBDinform_+3A_enplussq">ENplusSq</code></td>
<td>
<p>Expectation of <code class="reqn">N_T^{+2}</code>,
the square of the number of jumps up, conditional on    the data.</p>
</td></tr>
<tr><td><code id="getBDinform_+3A_enminussq">ENminusSq</code></td>
<td>
<p>Expectation of <code class="reqn">N_T^{-2}</code>,
the square of the number of jumps down, conditional on the data.</p>
</td></tr>
<tr><td><code id="getBDinform_+3A_eholdtimesq">EHoldtimeSq</code></td>
<td>
<p>Expectation of <code class="reqn">R_T^{2}</code>,
the square of the total holdtime, conditional on the data.</p>
</td></tr>
<tr><td><code id="getBDinform_+3A_enplusnminus">ENplusNminus</code></td>
<td>
<p>Expectation of <code class="reqn">N_T^+ N_T^-</code>,
the product of the number of jumps up and the number of jumps down, conditional on the data.</p>
</td></tr>
<tr><td><code id="getBDinform_+3A_enplusholdtime">ENplusHoldtime</code></td>
<td>
<p>Expectation of <code class="reqn">N_T^+ R_T</code>,
the product of the number of jumps up and the total holdtime, conditional on the data.</p>
</td></tr>
<tr><td><code id="getBDinform_+3A_enminusholdtime">ENminusHoldtime</code></td>
<td>
<p>Expectation of <code class="reqn">N_T^- R_T</code>,
the product of the number of jumps down and the total holdtime, conditional on the data.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Assume we have a linear-birth-death
process <code class="reqn">X_t</code> with birth parameter <code class="reqn">\lambda</code>, death
parameter <code class="reqn">\mu</code>, and immigration parameter
<code class="reqn">\beta \lambda</code> (for some known, real
<code class="reqn">\beta</code>).  We observe the process 
at a finite  set of times over a time
interval  [0,T].  Can run the EM algorithm to do maximum likelihood.
These functions are used to then compute pieces related to the
information matrix.
</p>
<p>See equations 3.2 and 3.3 in the Louis paper for the notation.
</p>
<p>getBDinform.lost.SC.manual computes <code class="reqn">I_{X|Y}</code>.
</p>
<p>getBDinform.full.SC.manual computes <code class="reqn">I_{X}</code>.
</p>
<p>getBDinform.PO.SC.manual computes <code class="reqn">I_{Y}</code> (i.e. the difference
between the other two functions).
</p>
<p>They have the &quot;manual&quot; suffix because the user passes in the
expectations.  Some of them can be computed analytically by the
methods in this package, but others cannot, so those are usually done
by Monte Carlo (conditional on the data) simulation.
</p>
<p>NOTE: To make sure the answers are coherent, it is important to pass
in expectations that are consistent with each other.  For instance,
if the expectations ENplus, ENminus, and EHoldtime are computed
analytically but  simulations are used to estimate the rest, then
the results may be nonsense, because the values passed in were not
necessarily feasible expectations all from the same measure.
</p>


<h3>Value</h3>

<p>Symmetric 2x2 matrix; First row/column corresponds to lambda,
second corresponds to mu</p>


<h3>Author(s)</h3>

<p>Charles Doss</p>


<h3>Source</h3>

<p>Louis, T A. (1982). Finding the observed information matrix when using the EM
algorithm. <em>J. Roy. Statist. Soc. Ser. B</em>. 44 226-233.
</p>

<hr>
<h2 id='getBDinform.PO'>Get Information Matrix for MLE estimates on
Partially Observed Linear Birth Death (_S_pecial _C_ase
with constrained immigration)</h2><span id='topic+getBDinform.PO'></span><span id='topic+getBDinform.PO.SC'></span>

<h3>Description</h3>

<p>Assume we have data that is the state at discrete
time points of a linear birth-death process, which has immigration
parameter constrained to be a known constant times the birth rate.  
After using EM Algorithm for estimating rate parameters of a linear
Birth-Death process, this function gives the information matrix
associated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getBDinform.PO.SC(partialData,Lhat,Mhat, beta.immig,delta=.001,
            n=1024,r=4, prec.tol=1e-12,prec.fail.stop=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getBDinform.PO_+3A_lhat">Lhat</code></td>
<td>
<p>MLE for lambda, the birth rate.</p>
</td></tr>
<tr><td><code id="getBDinform.PO_+3A_mhat">Mhat</code></td>
<td>
<p>MLE for mu, the death rate.</p>
</td></tr>
<tr><td><code id="getBDinform.PO_+3A_beta.immig">beta.immig</code></td>
<td>
<p>Immigration rate is constrained to be a multiple of
the birth rate.  immigrationrate = beta.immig * lambda where lambda
is birth rate.</p>
</td></tr>
<tr><td><code id="getBDinform.PO_+3A_partialdata">partialData</code></td>
<td>
<p>Partially observed chain. CTMC_PO_1 or CTMC_PO_many</p>
</td></tr>
<tr><td><code id="getBDinform.PO_+3A_n">n</code></td>
<td>
<p>n for riemann integral approximatoin.</p>
</td></tr>
<tr><td><code id="getBDinform.PO_+3A_r">r</code>, <code id="getBDinform.PO_+3A_delta">delta</code>, <code id="getBDinform.PO_+3A_prec.tol">prec.tol</code>, <code id="getBDinform.PO_+3A_prec.fail.stop">prec.fail.stop</code></td>
<td>
<p>see help for, say, all.cond.mean.PO</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Assume we have a linear-birth-death
process <code class="reqn">X_t</code> with birth parameter <code class="reqn">\lambda</code>, death
parameter <code class="reqn">\mu</code>, and immigration parameter
<code class="reqn">\beta \lambda</code> (for some known, real
<code class="reqn">\beta</code>).  We observe the process 
at a finite  set of times over a time
interval  [0,T].  After running the EM algorithm to do estimation,
this function returns the information to get, for instance, asymptotic
CIs.
</p>
<p>See the Louis paper for the method.
</p>
<p>To calculate the information matrix, the expecatations of the
products of the sufficient statistics, conditional on the data, are
needed.  They are calculated by Monte Carlo, and N is the number of
simulations to run.
</p>


<h3>Value</h3>

<p>Symmetric 2x2 matrix; First row/column corresponds to lambda,
second corresponds to mu</p>


<h3>Author(s)</h3>

<p>Charles Doss</p>


<h3>Source</h3>

<p>Louis, T A. (1982). Finding the observed information matrix when using the EM
algorithm. <em>J. Roy. Statist. Soc. Ser. B</em>. 44 226-233.
</p>

<hr>
<h2 id='getBDjTimes'>
Get Jump times of a BD process.
</h2><span id='topic+getBDjTimes'></span>

<h3>Description</h3>

<p>get times of jumps, split into jumps up and jumps down.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getBDjTimes(bdMC, getTimes = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getBDjTimes_+3A_bdmc">bdMC</code></td>
<td>

<p>A BDMC
</p>
</td></tr>
<tr><td><code id="getBDjTimes_+3A_gettimes">getTimes</code></td>
<td>

<p>Bool. If true returns times, otherwise returns indices of times vector.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>List with 2 components of times/indices.  First is times of jumps up,
second is times of jumps down.
</p>


<h3>Value</h3>

<p>If getTimes is TRUE:
</p>
<table>
<tr><td><code>timesup</code></td>
<td>
<p>times of jumps up</p>
</td></tr>
<tr><td><code>timesdown</code></td>
<td>
<p>times of jumps down</p>
</td></tr>
</table>
<p>If getTImes is FALSE:
</p>
<table>
<tr><td><code>indsup</code></td>
<td>
<p>indices of times for jumps up</p>
</td></tr>
<tr><td><code>indsdown</code></td>
<td>
<p>indices of times for jumps down</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>charles doss
</p>

<hr>
<h2 id='getBDMCsPOlist-methods'> Methods for Function <code>getBDMCsPOlist</code> in Package <span class="pkg">DOBAD</span></h2><span id='topic+getBDMCsPOlist'></span><span id='topic+getBDMCsPOlist-methods'></span><span id='topic+getBDMCsPOlist+2CCTMC_PO_many-method'></span>

<h3>Description</h3>

<p>Methods for function <code>getBDMCsPOlist</code> in package <span class="pkg">DOBAD</span>
</p>


<h3>Methods</h3>


<dl>
<dt><code>signature(object = "CTMC_PO_many")</code></dt><dd>
<p>Return the list of CTMC_PO_1 objects corresponding to the CTMC_PO_many
argument.
</p>
</dd>
</dl>

<hr>
<h2 id='getDataSummary.CTMC_PO_many'>
Calculate Some Summarizing Information for the Given Data
</h2><span id='topic+getDataSummary.CTMC_PO_many'></span><span id='topic+getDataSummary'></span>

<h3>Description</h3>

<p>Computes some summarizing statistics for a CTMC_PO_many object
and returns them, possibly also saving them to a file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getDataSummary.CTMC_PO_many(dat, file = "dataSummary.rsav")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getDataSummary.CTMC_PO_many_+3A_dat">dat</code></td>
<td>

<p>Discretely Observed BDI process.
</p>
</td></tr>
<tr><td><code id="getDataSummary.CTMC_PO_many_+3A_file">file</code></td>
<td>

<p>Filename to save to. 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See the function definition for the variable names used.  Saving and
loading to/from a file seemed like the simplest approach.
</p>


<h3>Author(s)</h3>

<p>charles doss
</p>

<hr>
<h2 id='getInitParams'>
Get multiple starting parameters for EM
</h2><span id='topic+getInitParams'></span>

<h3>Description</h3>

<p>This is an ad-hoc function that has some hardwired rules for grabbing
a few starting parameter values given one passed in one.  You pass in
your summary data and it makes a basic guess at starting parameters
and then flips them and scales them in various ways depending on what
numInitParams is.  It returns
between 1 and 6 different values (pairs) of starting parameters.
Useful to get more than one parameter
for if you are automating the EM in some way.  Otherwise it
just gives you the smart starting guess.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getInitParams(numInitParams=1, summary.PO, T, beta.immig, diffScale)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getInitParams_+3A_numinitparams">numInitParams</code></td>
<td>

<p>How many parameters you want returned; between 1 and 6.
Note: the paramaters after the 1st are fairly arbitrary.
</p>
</td></tr>
<tr><td><code id="getInitParams_+3A_summary.po">summary.PO</code></td>
<td>

<p>Summary data from partially observed process.  &quot;Nplus&quot;, &quot;Nminus&quot;,
and &quot;Holdtime&quot; should be names in that order of number of observed
jumsp up, jumps down, and Holding time.
</p>
</td></tr>
<tr><td><code id="getInitParams_+3A_t">T</code></td>
<td>

<p>total time of chain.
</p>
</td></tr>
<tr><td><code id="getInitParams_+3A_beta.immig">beta.immig</code></td>
<td>

<p>Scalar multiple of lambda that gives you the immigration rate, ie
immigrate = beta.immig * birthrate.
</p>
</td></tr>
<tr><td><code id="getInitParams_+3A_diffscale">diffScale</code></td>
<td>

<p>Note that we don't have a solution in the case mu == lambda.  So
if the two are close then numerical differentiation requires smaller
values essentially.  So usually pass something like &quot;100*dr&quot; where
dr is the value that's passed through the add.joint.mean.*, etc
(called delta) for numeric differentiation.
</p>
</td></tr>
</table>

<hr>
<h2 id='getIthJumpTime'>
Get the jump times from a CTMC.
</h2><span id='topic+getIthJumpTime'></span><span id='topic+getIthState'></span><span id='topic+getIthJumpTimes'></span>

<h3>Description</h3>

<p>Get the time of the ith jump
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getIthJumpTime(CTMC, i)
getIthJumpTimes(timesList, i)
getIthState(CTMC,i)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getIthJumpTime_+3A_ctmc">CTMC</code></td>
<td>
<p> A CTMC.
</p>
</td></tr>
<tr><td><code id="getIthJumpTime_+3A_timeslist">timesList</code></td>
<td>
<p>List of positive numerics, each of which is the
list of times from a CTMC.
</p>
</td></tr>
<tr><td><code id="getIthJumpTime_+3A_i">i</code></td>
<td>
<p> Positive integer. Which jump to get the time of.
Need to know the CTMC(s) jumped at least i times!
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Need to know the CTMC(s) jumped at least i times.
</p>


<h3>Value</h3>

<p>getIthJumpTime returns a single positive numeric.
getIthJumpTimes returns a vector of positive numerics.
getIthState returns a nonnegative integer, the state.
</p>


<h3>Author(s)</h3>

<p>Charles Doss
</p>

<hr>
<h2 id='getMCstate'>
Get the state of a CTMC at various times
</h2><span id='topic+getMCstate'></span>

<h3>Description</h3>

<p>Returns the state of the CTMC at each of times in Ts.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getMCstate(CTMC, Ts)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getMCstate_+3A_ctmc">CTMC</code></td>
<td>

<p>a CTMC.
</p>
</td></tr>
<tr><td><code id="getMCstate_+3A_ts">Ts</code></td>
<td>

<p>vector of times &gt;0.
</p>
</td></tr>
</table>

<hr>
<h2 id='getNewParams.SC'>
Solve for new parameters in restricted model in EM algorithm.
</h2><span id='topic+getNewParams.SC'></span>

<h3>Description</h3>

<p>Basically one step of the EM algorithm.  Given old parameters
and the data, get the new parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getNewParams.SC(theData,oldParams, beta.immig,  dr = 0.001, r=4,n.fft =
1024, prec.tol, prec.fail.stop)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getNewParams.SC_+3A_oldparams">oldParams</code></td>
<td>

<p>Parameters from previous iteration
</p>
</td></tr>
<tr><td><code id="getNewParams.SC_+3A_beta.immig">beta.immig</code></td>
<td>

<p>immigrationrate = beta.immig * birthrate
</p>
</td></tr>
<tr><td><code id="getNewParams.SC_+3A_thedata">theData</code></td>
<td>

<p>The discretely observed BDI process.  Of class CTMC_PO_many, CTMC_PO_1, list.
</p>
</td></tr>
<tr><td><code id="getNewParams.SC_+3A_dr">dr</code></td>
<td>

<p>tuning parameter for differentiation
</p>
</td></tr>
<tr><td><code id="getNewParams.SC_+3A_r">r</code></td>
<td>
<p>Parameter for differentiation; see numDeriv package
documentation.</p>
</td></tr> 
<tr><td><code id="getNewParams.SC_+3A_n.fft">n.fft</code></td>
<td>

</td></tr>
<tr><td><code id="getNewParams.SC_+3A_prec.tol">prec.tol</code></td>
<td>
<p>&quot;Precision tolerance&quot;; to compute conditional means,
first the joint means are computed and then they are normalized by
transition probabilities.  The precision parameters govern the
conditions under which the function will quit if these values are
very small.  If the joint-mean is smaller than prec.tol then
the value of prec.fail.stop decides whether to stop or continue.</p>
</td></tr>
<tr><td><code id="getNewParams.SC_+3A_prec.fail.stop">prec.fail.stop</code></td>
<td>
<p>If true, then when joint-mean values are
smaller than prec.tol the program stops; if false then it continues,
usually printing a warning.</p>
</td></tr>
</table>

<hr>
<h2 id='getPartialData'>
Get &quot;partially Observed &quot; Chain from a fully observed one.
</h2><span id='topic+getPartialData'></span>

<h3>Description</h3>

<p>This effectively turns &quot;Truth&quot; into &quot;data,&quot; ie it is passed
a fully observed chain and returns only a partially observed one.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getPartialData(observeTimes, CTMC)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getPartialData_+3A_observetimes">observeTimes</code></td>
<td>

<p>Times at which CTMC is to &quot;be observed&quot; ie at which &quot;data&quot; is to be gathered.
</p>
</td></tr>
<tr><td><code id="getPartialData_+3A_ctmc">CTMC</code></td>
<td>

<p>A continuous time markov chain.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Returns a CTMC_PO_1, ie discretely observed CTMC,
from observing CTMC at observeTimes
</p>


<h3>Value</h3>

<p>Returns CTMC_PO_1.
</p>

<hr>
<h2 id='getStates'>
Get list of jump states.
</h2><span id='topic+getStates'></span><span id='topic+getStates+2CCTMC-method'></span><span id='topic+getStates+2CBDMC-method'></span><span id='topic+getStates+2CCTMC_PO_1-method'></span>

<h3>Description</h3>

<p>Object accessor. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getStates(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getStates_+3A_object">object</code></td>
<td>
<p> A CTMC or generalization.  has a list of jump states.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Gets list of states at each associated time.
</p>


<h3>Value</h3>

<p>numeric vector, integer valued.
</p>


<h3>Author(s)</h3>

<p>Charles Doss
</p>

<hr>
<h2 id='getSubMC'>
Extract a Sub Markov Chain
</h2><span id='topic+getSubMC'></span>

<h3>Description</h3>

<p>Create a new sub markov chain from a given one.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getSubMC(CTMC, T)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getSubMC_+3A_ctmc">CTMC</code></td>
<td>

<p>A CTMC object
</p>
</td></tr>
<tr><td><code id="getSubMC_+3A_t">T</code></td>
<td>

<p>Time to cut off  the given CTMC to form a new one.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Creates a new CTMC identical to the given CTMC from time 0 to T.
</p>


<h3>Value</h3>

<p>a CTMC.
</p>

<hr>
<h2 id='getT-methods'> ~~ Methods for Function getT in Package &lsquo;DOBAD&rsquo; ~~</h2><span id='topic+getT'></span><span id='topic+getT-methods'></span><span id='topic+getT+2CBDMC-method'></span><span id='topic+getT+2CBDMC_many-method'></span><span id='topic+getT+2CCTMC-method'></span><span id='topic+getT+2CCTMC_many-method'></span><span id='topic+getT+2CCTMC_PO_1-method'></span><span id='topic+getT+2CCTMC_PO_many-method'></span>

<h3>Description</h3>

<p>~~ Methods for function <code>getT</code> in Package &lsquo;DOBAD&rsquo; ~~
</p>


<h3>Methods</h3>


<dl>
<dt><code>signature(object = "BDMC")</code></dt><dd>
<p>Same as for CTMC.
</p>
</dd>
<dt><code>signature(object = "BDMC_many")</code></dt><dd>
<p>Sum of time for each of component BDMCs.
</p>
</dd>
<dt><code>signature(object = "CTMC")</code></dt><dd>
<p>time the chain is observed for.  Ie difference in first time we see
the state and the last time.
</p>
</dd>
<dt><code>signature(object = "CTMC_many")</code></dt><dd>
<p>Sum of time for components
</p>
</dd>
<dt><code>signature(object = "CTMC_PO_1")</code></dt><dd>
<p>Difference in time first observation and last.
</p>
</dd>
<dt><code>signature(object = "CTMC_PO_many")</code></dt><dd>
<p>Sum of time for components
</p>
</dd>
</dl>

<hr>
<h2 id='getTimes'>
Get list of jump times.
</h2><span id='topic+getTimes'></span><span id='topic+getTimes+2CCTMC-method'></span><span id='topic+getTimes+2CBDMC-method'></span><span id='topic+getTimes+2CCTMC_PO_1-method'></span>

<h3>Description</h3>

<p>Object accessor. First jump  time is 0.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getTimes(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getTimes_+3A_object">object</code></td>
<td>
<p> A CTMC.  has a list of jump times.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Gets list of jump times.
</p>


<h3>Value</h3>

<p>numeric vector, positive values.
</p>


<h3>Author(s)</h3>

<p>Charles Doss
</p>

<hr>
<h2 id='getTs-methods'> ~~ Methods for Function getTs in Package &lsquo;DOBAD&rsquo; ~~</h2><span id='topic+getTs'></span><span id='topic+getTs-methods'></span><span id='topic+getTs+2CBDMC_many-method'></span><span id='topic+getTs+2CCTMC_many-method'></span><span id='topic+getTs+2CCTMC_PO_many-method'></span>

<h3>Description</h3>

<p>Accessor for vector of total times for each individual markov chain in
a many-markov-chain object.
</p>


<h3>Methods</h3>


<dl>
<dt><code>signature(object = "BDMC_many")</code></dt><dd>
<p>Vector of total times for each individual markov chain in the object.
</p>
</dd>
<dt><code>signature(object = "CTMC_many")</code></dt><dd>
<p>Same as above.
</p>
</dd>
<dt><code>signature(object = "CTMC_PO_many")</code></dt><dd>
<p>Same as above.
</p>
</dd>
</dl>

<hr>
<h2 id='graph.CTMC'>
Plot  CTMCs (possibly Partially Observed)
</h2><span id='topic+graph.CTMC'></span><span id='topic+graph.CTMC.PO'></span>

<h3>Description</h3>

<p>Plot in piecewise fashion the CTMCs.  If it is partially observed, it
just plots it as if it were fully observed; i.e., the chain is
pretended to continue in the same state until we see a jump.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>graph.CTMC(CTMC, filename = NA, height = 6, width = 4.5, xlab="time",
ylab="State", ...)
graph.CTMC.PO(CTMC, filename = NA, height = 6, width = 4.5,
type="l", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="graph.CTMC_+3A_ctmc">CTMC</code></td>
<td>

<p>Either a fully observed CTMC or a partially observed one.
Partially observed ones don't have a &quot;T&quot; and fully observed do.
</p>
</td></tr>
<tr><td><code id="graph.CTMC_+3A_filename">filename</code></td>
<td>

<p>filename string, or NA.
</p>
</td></tr>
<tr><td><code id="graph.CTMC_+3A_height">height</code></td>
<td>

<p>Passed to trellis if filename isn't NA.
</p>
</td></tr>
<tr><td><code id="graph.CTMC_+3A_width">width</code></td>
<td>

<p>Passed to trellis if filename isn't NA.
</p>
</td></tr>
<tr><td><code id="graph.CTMC_+3A_xlab">xlab</code></td>
<td>

<p>X label.
</p>
</td></tr>
<tr><td><code id="graph.CTMC_+3A_ylab">ylab</code></td>
<td>

<p>Y label
</p>
</td></tr>
<tr><td><code id="graph.CTMC_+3A_type">type</code></td>
<td>

<p>As in the plot parameter.
</p>
</td></tr>
<tr><td><code id="graph.CTMC_+3A_...">...</code></td>
<td>

</td></tr>
</table>


<h3>Details</h3>

<p>If your data is S4 class, you can use the plot method.  
</p>


<h3>See Also</h3>


<p>See also the s4 methods written for the plot function <code><a href="#topic+plot-methods">plot-methods</a></code>.
</p>

<hr>
<h2 id='list2CTMC'>
Convert a list representation of a CTMC to the class version
</h2><span id='topic+list2CTMC'></span>

<h3>Description</h3>

<p>Convert a list representation of a CTMC to the class version
</p>


<h3>Usage</h3>

<pre><code class='language-R'>list2CTMC(aCTMC)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="list2CTMC_+3A_actmc">aCTMC</code></td>
<td>

<p>A CTMC represented as a list.  Should have a &quot;states&quot;, &quot;times&quot;
vectors and a T numeric.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the same data but as an object of class CTMC.
</p>

<hr>
<h2 id='Nij'>
Count transitions in a fully observed CTMC.
</h2><span id='topic+Nij'></span>

<h3>Description</h3>

<p>Returns a matrix with counts of transitions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Nij(CTMC)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Nij_+3A_ctmc">CTMC</code></td>
<td>

<p>(Fully observed) CTMC.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>the (i,j) element is the number of transitions from state (i-1) to
state (j-1) that were observed.
</p>


<h3>Value</h3>

<p>numeric matrix(ncol=max(CTMC)+1, nrow=max(CTMC)+1) where max(CTMC)
is the max state of the CTMC.
</p>

<hr>
<h2 id='Nplus'>
Calculate summary statistics for BDMCs and CTMC_POs
</h2><span id='topic+Nplus'></span><span id='topic+Nminus'></span><span id='topic+Nplus.CTMC_PO_many'></span><span id='topic+Nminus.CTMC_PO_many'></span><span id='topic+holdTime'></span>

<h3>Description</h3>

<p>Nplus (number jumps up), Nminus (number jumps down), and holdtime
(waiting time weighted by the waiting state) are fundamental summary
statistics for the Restricted Immigration BD model.  These functions
compute those for BDMC, or compute the observed numbers for CTMC_PO_1
or CTMC_PO_many.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Nplus(sim)
Nminus(sim)
Nplus.CTMC_PO_many(ctmcpomany)
 Nminus.CTMC_PO_many(ctmcpomany)
 </code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Nplus_+3A_sim">sim</code></td>
<td>

<p>Arg for Nplus, Nminus. BDMC generally.  Needs to have a getStates method.
</p>
</td></tr>
<tr><td><code id="Nplus_+3A_ctmcpomany">ctmcpomany</code></td>
<td>
<p>A CTMC_PO_many.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an integer, the number of jumps up.
</p>


<h3>Author(s)</h3>

<p>Charles Doss
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
Nplus(birth.death.simulant(1))
</code></pre>

<hr>
<h2 id='num.deriv'>
Numerical Differentiation
</h2><span id='topic+num.deriv'></span><span id='topic+genDoneSided'></span><span id='topic+hessianOneSided'></span>

<h3>Description</h3>

<p>Numerical derivative of one-d function defined on R.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>num.deriv(ftn, var, delta = 0.001, ...)
genDoneSided(func, x, sides, method = "Richardson",
method.args = list(eps = 1e-04,
    d = 1e-04, zero.tol = sqrt(.Machine$double.eps/7e-07), r = 4,
    v = 2), ...)
hessianOneSided(func, x, sides, method = "Richardson", method.args = list(eps = 1e-04, 
     d = 1e-04, zero.tol = sqrt(.Machine$double.eps/7e-07), r = 4,                
     v = 2), ...)                                                                 

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="num.deriv_+3A_ftn">ftn</code>, <code id="num.deriv_+3A_func">func</code></td>
<td>

<p>A (differentiable) function defined on R.
</p>
</td></tr>
<tr><td><code id="num.deriv_+3A_var">var</code>, <code id="num.deriv_+3A_x">x</code></td>
<td>

<p>Value(s) at which to differentiate. x can be vector.
</p>
</td></tr>
<tr><td><code id="num.deriv_+3A_sides">sides</code></td>
<td>
<p>of length equal to x; +1 is differentiate from above
-1 from below.</p>
</td></tr>
<tr><td><code id="num.deriv_+3A_method">method</code></td>
<td>
<p>see numDeriv package docs</p>
</td></tr>
<tr><td><code id="num.deriv_+3A_method.args">method.args</code></td>
<td>
<p>see numDeriv package docs</p>
</td></tr>
<tr><td><code id="num.deriv_+3A_delta">delta</code></td>
<td>

<p>Small number defining accuracy of numeric derivative.
</p>
</td></tr>
<tr><td><code id="num.deriv_+3A_...">...</code></td>
<td>

</td></tr>
</table>


<h3>Details</h3>

<p>See the 'numDeriv' package from whence the genD function and hessian
function come.  The versions here are one-sided adapatations of the
originals from that package.  
</p>


<h3>Value</h3>

<p>Real number.
</p>

<hr>
<h2 id='plot-methods'>Plot CTMCs</h2><span id='topic+plot-methods'></span><span id='topic+plot+2CCTMC+2Cmissing-method'></span><span id='topic+plot+2CCTMC_PO_1+2Cmissing-method'></span>

<h3>Description</h3>

<p>Plotting for fully observed and partially observed Continuous Time
Markov Chains.
</p>


<h3>Methods</h3>


<dl>
<dt>x = &quot;CTMC&quot;, y = &quot;missing&quot;</dt><dd><p>x is a fully observed CTMC.</p>
</dd>
<dt>x = &quot;CTMC_PO_1&quot;, y = &quot;missing&quot;</dt><dd><p> x is discrete observations from a
CTMC. </p>
</dd>
</dl>

<hr>
<h2 id='power.coef.one'>
Gets coefficients of a power series..  
</h2><span id='topic+power.coef.one'></span><span id='topic+power.coef.many'></span>

<h3>Description</h3>

<p>Reads off coefficients of a power series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>power.coef.one(power.series, n = 1000, k, ...)
power.coef.many(power.series, n = 1024, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="power.coef.one_+3A_power.series">power.series</code></td>
<td>

<p>A function from C to C.  Note that its single argument must be named
&quot;s&quot;.  Should be a power series.
</p>
</td></tr>
<tr><td><code id="power.coef.one_+3A_n">n</code></td>
<td>

<p>Parameter for numerical riemann integration or for FFT.
</p>
</td></tr>
<tr><td><code id="power.coef.one_+3A_k">k</code></td>
<td>

<p>The coefficient to get.
</p>
</td></tr>
<tr><td><code id="power.coef.one_+3A_...">...</code></td>
<td>

</td></tr>
</table>


<h3>Value</h3>

<p>A Real number, the kth coefficient, for .one,
or a vector of coefficients for .many.
</p>

<hr>
<h2 id='process.prob.one'>
Calculate transition probability for linear birth death process.
</h2><span id='topic+process.prob.one'></span><span id='topic+process.prob.many'></span>

<h3>Description</h3>

<p>Calculate transition probability for linear birth death process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>process.prob.one(t, lambda, mu, nu = 0, X0 = 1, Xt,eps.t=1e-10,
eps.params=1e-10, n = -111)
process.prob.many(t, lambda, mu, nu = 0, X0 = 1, n = 1024)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="process.prob.one_+3A_t">t</code></td>
<td>

<p>Time for transition.
</p>
</td></tr>
<tr><td><code id="process.prob.one_+3A_lambda">lambda</code></td>
<td>

<p>Linear birth rate 
</p>
</td></tr>
<tr><td><code id="process.prob.one_+3A_mu">mu</code></td>
<td>

<p>linear death rate
</p>
</td></tr>
<tr><td><code id="process.prob.one_+3A_nu">nu</code></td>
<td>

<p>immigration rate.
</p>
</td></tr>
<tr><td><code id="process.prob.one_+3A_x0">X0</code></td>
<td>

<p>starting state.
</p>
</td></tr>
<tr><td><code id="process.prob.one_+3A_xt">Xt</code></td>
<td>

<p>ending state.
</p>
</td></tr>
<tr><td><code id="process.prob.one_+3A_n">n</code></td>
<td>

<p>Deprecated; for backwards compatibility.
</p>
</td></tr>
<tr><td><code id="process.prob.one_+3A_eps.t">eps.t</code></td>
<td>
<p> One precision level below which the function
switches to using the generating function
instead of the Orthogonal Polynomial Solution to calculate
transition probability.  Needed when the parameters or time
are close to a boundary for which the OPS isn't defined.
</p>
</td></tr>
<tr><td><code id="process.prob.one_+3A_eps.params">eps.params</code></td>
<td>
<p> Another precision level like eps.t.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Calculates P(X_t=Xt |X_0=X0).
</p>

<hr>
<h2 id='sampleJumpTime2'>
Functions for Simulating Conditionally the first Jump of a chain.
</h2><span id='topic+sampleJumpTime2'></span><span id='topic+p.i'></span><span id='topic+f.i'></span>

<h3>Description</h3>

<p>Simulates the time of the first jump given that we know whether it's
up or down and have observed the chain at some point.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sampleJumpTime2(T, a, b, up = TRUE, L, m, nu)
p.i(T, a, b, up, L, m, nu, n.fft = 1024, subdivisions = 100)
f.i(t, T, a, b, up, L, m, nu, n.fft = 1024)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sampleJumpTime2_+3A_t">T</code></td>
<td>

<p>Time of (First) observation; i.e. time at which we know the state of
the chain.
</p>
</td></tr>
<tr><td><code id="sampleJumpTime2_+3A_t">t</code></td>
<td>
<p> time between 0 and T at which to get the density of tau for
f.i.
</p>
</td></tr>
<tr><td><code id="sampleJumpTime2_+3A_a">a</code></td>
<td>

<p>Starting state of the chain at time 0 (X_0=a).  a&gt;=0.
</p>
</td></tr>
<tr><td><code id="sampleJumpTime2_+3A_b">b</code></td>
<td>

<p>Given State of the chain at time T. (X_T=a).  b&gt;=0.
</p>
</td></tr>
<tr><td><code id="sampleJumpTime2_+3A_up">up</code></td>
<td>

<p>Boolean, telling whether the first jump is up (TRUE) or down (FALSE).
</p>
</td></tr>
<tr><td><code id="sampleJumpTime2_+3A_l">L</code></td>
<td>

<p>Linear birth rate.
</p>
</td></tr>
<tr><td><code id="sampleJumpTime2_+3A_m">m</code></td>
<td>

<p>Linear   death rate.
</p>
</td></tr>
<tr><td><code id="sampleJumpTime2_+3A_nu">nu</code></td>
<td>

<p>Immigration rate.
</p>
</td></tr>
<tr><td><code id="sampleJumpTime2_+3A_subdivisions">subdivisions</code></td>
<td>

<p>Parameter for numerical integration (&quot;integrate&quot; R function).
</p>
</td></tr>
<tr><td><code id="sampleJumpTime2_+3A_n.fft">n.fft</code></td>
<td>

<p>Parameter for numerical riemann integration (&quot;by hand&quot;).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Let tau be the time of the first jump (after time 0) and X_t is the
chain at time t.
</p>
<p>Function sampleJumpTime2
simulates the value of the first jump of a BDMC, conditional on
some data.    
What is given is the state of the BDMC at the beginning and end,
where the end is time T, as well as whether
the first jump is up or down.
(To simulate the chain over the time from 0 to T, repeatedly
call this function  alternatively with p.i)
</p>
<p>The Function p.i
simulates whether the first jump is up or down, given the data.
i.e. if up==true then this returns the probability
[tau &lt; T AND X_tau = a+1]
and if up==false then it's
[tau &lt; T AND X_tau = a-1].
</p>
<p>The function f.i returns the &quot;density&quot; at t of tau, ie
&quot;P([tau ==t AND X_tau = a+1] | X0=a, Xt=b)&quot;
and if up==false then it's
&quot;P([tau ==t AND X_tau = a-1] | X0=a, Xt=b)&quot;.
Note that it doesn't actually integrate to 1.  p.i(T) is the integral
of f.i to time T.  f.i(.)/p.i(T) is actually a density on [0,T].
If X_T != X_0 then we know the first jump is before time T.
However, keep in mind the event of interest is that the first jump is
up (down) and at time t; even if we know there will be a first jump
down, that doesn't prove the first jump won't be up.
In general, we have
<code class="reqn">\int^T_0 f.i(up) + \int^T_0 f.i(down) + P(first jump is after
    time T) = 1</code>.
That is, <code class="reqn">\int_0^t f.i(up)(s) ds</code> is the probability the first
jump is before time t _and_ it is up (given that the chain starts at a
and ends at b).
</p>


<h3>Value</h3>

<p>A time (real number) between 0 and T.
</p>


<h3>Author(s)</h3>

<p>Charles Doss
</p>


<h3>See Also</h3>

<p><code><a href="#topic+p.i">p.i</a></code>
</p>

<hr>
<h2 id='sim.condBD'>Simulate birth-death process, Conditionally
upon observing its state at  finite, discrete
time points</h2><span id='topic+sim.condBD'></span><span id='topic+sim.condBD.1'></span><span id='topic+sim.condBD.main'></span><span id='topic+sim.condBD.main.CTMC_PO_1'></span><span id='topic+sim.condBD.main.list'></span><span id='topic+sim.condBD.main.default'></span>

<h3>Description</h3>

<p>Functions for simulating a linear-birth-death
process with birth parameter lambda, death
parameter mu, and immigration parameter
modelParams[&quot;n&quot;]*lambda, conditional upon
observing it at a finite discrete set of times over a finite time
interval,
[0,T].
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim.condBD(bd.PO = list(states = c(5, 7, 3),times = c(0, 0.4, 1)), N = 1,
           L = 0.5, m = 0.7, nu = 0.4, n.fft = 1024, prevSims=NULL)
## S3 method for class 'CTMC_PO_1'
sim.condBD.main(bd.PO=
      new("CTMC_PO_1", states=c(5,7,3), times=c(0,.4,1)),
      L=.5, m=.7, nu=.4,  n.fft=1024)
## S3 method for class 'list'
sim.condBD.main(bd.PO=
      list(states=c(5,7,3), times=c(0,.4,1)),
      L=.5, m=.7, nu=.4,  n.fft=1024)
## Default S3 method:
sim.condBD.main(bd.PO=
      list(states=c(5,7,3), times=c(0,.4,1)),
      L=.5, m=.7, nu=.4,  n.fft=1024)
sim.condBD.1(T=1, a=5, b=7, L=.5, m=.7, nu=.4, n.fft=1024)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sim.condBD_+3A_n">N</code></td>
<td>
<p>Number of simulations/replications to do</p>
</td></tr>
<tr><td><code id="sim.condBD_+3A_bd.po">bd.PO</code></td>
<td>
<p>_P_artially _O_bserved process, i.e., the data.  Needs
to have &quot;components&quot; 'states', 'times', and 'T'.  Can be CTMC_PO_1 or a
list.</p>
</td></tr>
<tr><td><code id="sim.condBD_+3A_a">a</code></td>
<td>
<p>Starting state of chain</p>
</td></tr>
<tr><td><code id="sim.condBD_+3A_b">b</code></td>
<td>
<p>Ending state of chain</p>
</td></tr>
<tr><td><code id="sim.condBD_+3A_t">T</code></td>
<td>
<p>Duration of chain</p>
</td></tr>
<tr><td><code id="sim.condBD_+3A_l">L</code></td>
<td>
<p>Lambda, linear birth rate parameter</p>
</td></tr>
<tr><td><code id="sim.condBD_+3A_m">m</code></td>
<td>
<p>mu, linear death rate parameter</p>
</td></tr>
<tr><td><code id="sim.condBD_+3A_nu">nu</code></td>
<td>
<p>nu, immigration rate parameter.</p>
</td></tr>
<tr><td><code id="sim.condBD_+3A_n.fft">n.fft</code></td>
<td>
<p>Number of terms to use in the fast fourier transform when
using the generating functions to compute probabilities or
joint expectations for the birth-death process.  See the
add.joint.mean.many, etc, functions.</p>
</td></tr>
<tr><td><code id="sim.condBD_+3A_prevsims">prevSims</code></td>
<td>
<p>A possibly-NULL list of previous simulation results
which will be prepended to the current simulations. 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>sim.condBD, given discretely observed data from a chain,
simulates N birthdeath chains conditionally on the data.
</p>
<p>sim.condBD.1 is the helper; it simulates one piece of the chain, given
a starting and ending state.  That process is repeated (via markov prop)
to simulate across many data points.  So it only takes arguments a,b,and
T rather than a &quot;CTMC_PO_1&quot; as its data.
</p>
<p>The method of simulating exactly is essentially that of Hobolth and
Stone (2008).  Briefly: we can write out the density of the time of
the first jump up or of the first jump down.  We can integrate it from 0
to T  to
compute the probability there is a jump up (down, respectively) in
that time interval. Thus we can simulate whether or not there is a
jump, and whether it is up or down.  Then using the above mentioned
density, we can simulate the time at which it occurs.  For more details
see Hobolth and Stone (2008).
</p>


<h3>Value</h3>

<p>An object of class BDMC, ie a (linear) Birth-Death Markov Chain,
except for sim.condBD which returns a list of objects of class BDMC.</p>


<h3>Author(s)</h3>

<p>Charles Doss</p>


<h3>Source</h3>

<p>Hobolth and Stone. (2008)
Efficient Simulation from Finite-state, Continuous-Time Markov Chains
with Incomplete Observations, submitted Annals of Applied Statistics.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+add.joint.mean.many">add.joint.mean.many</a></code></p>

<hr>
<h2 id='simplify'>
Transform Lists to Vectors
</h2><span id='topic+simplify'></span>

<h3>Description</h3>

<p>Takes objects which are lists but are conceptually vectors, and
transforms
them into vector objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simplify(simpleList)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simplify_+3A_simplelist">simpleList</code></td>
<td>

<p>A list each of whose components is a (numeric) vector of length 1.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>simpleList is a list each of whose components is a (numeric) vector of
length1; simplify returns a vectorized form of this list.
</p>


<h3>Value</h3>

<p>numeric vector whose length is the number of components of simpleList.
</p>


<h3>Note</h3>

<p>The base R unlist function probably makes this redundant.
</p>


<h3>See Also</h3>

<p>unlist
</p>

<hr>
<h2 id='sub-methods'>  Subscripting CTMCs</h2><span id='topic++5B+2CCTMC_many-method'></span><span id='topic++5B+2CCTMC_PO_many-method'></span><span id='topic++5B+5B+2CCTMC_many-method'></span><span id='topic++5B+5B+2CCTMC_PO_many-method'></span>

<h3>Description</h3>

<p>Subscripting methods for CTMCs.
</p>


<h3>Methods</h3>


<dl>
<dt><code>signature(x = "CTMC_many")</code></dt><dd>
<p>Gets x@CTMC[i]
</p>
</dd>
<dt><code>signature(x = "CTMC_PO_many")</code></dt><dd>
<p>Gets x@BDMCsPO[i]
</p>
</dd>
<dt><code>signature(x = "CTMC_many")</code></dt><dd>
<p>Gets x@CTMC[[i]]
</p>
</dd>
<dt><code>signature(x = "CTMC_PO_many")</code></dt><dd>
<p>Gets x@BDMCsPO[[i]]
</p>
</dd>
</dl>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
