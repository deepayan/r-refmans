<!DOCTYPE html><html><head><title>Help for package NMF</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {NMF}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#NMF-package'><p>Algorithms and framework for Nonnegative Matrix Factorization (NMF).</p></a></li>
<li><a href='#.atrack'><p>Annotation Tracks</p></a></li>
<li><a href='#.fcnnls'><p>Internal Routine for Fast Combinatorial Nonnegative Least-Squares</p></a></li>
<li><a href='#[,NMF-method'><p>Sub-setting NMF Objects</p></a></li>
<li><a href='#advanced-NMF'><p>Advanced Usage of the Package NMF</p></a></li>
<li><a href='#aggregate.measure'><p>Utility function to aggregate numerical quality measures from <code>NMFfitXn</code> objects.</p></a></li>
<li><a href='#aheatmap'><p>Annotated Heatmaps</p></a></li>
<li><a href='#algorithm,NMFList-method'><p>Returns the method names used to compute the NMF fits in the list.</p>
It returns <code>NULL</code> if the list is empty.</a></li>
<li><a href='#algorithmic-NMF'><p>Generic Interface for Algorithms</p></a></li>
<li><a href='#basis'><p>Accessing NMF Factors</p></a></li>
<li><a href='#basiscor'><p>Correlations in NMF Models</p></a></li>
<li><a href='#basisnames'><p>Dimension names for NMF objects</p></a></li>
<li><a href='#bioc-NMF'><p>Specific NMF Layer for Bioconductor</p></a></li>
<li><a href='#bterms&lt;-'><p>Fixed Terms in NMF Models</p></a></li>
<li><a href='#c,NMF-method'><p>Concatenating NMF Models</p></a></li>
<li><a href='#canFit'><p>Testing Compatibility of Algorithm and Models</p></a></li>
<li><a href='#ccBreaks'><p>Generate Break Intervals from Numeric Variables</p></a></li>
<li><a href='#ccPalette'><p>Builds a Color Palette from Compact Color Specification</p></a></li>
<li><a href='#ccRamp'><p>Builds a Color Ramp from Compact Color Specification</p></a></li>
<li><a href='#ccSpec'><p>Extract Colour Palette Specification</p></a></li>
<li><a href='#checkErrors'><p>Error Checks in NMF Runs</p></a></li>
<li><a href='#cluster_mat'><p>Cluster Matrix Rows in Annotated Heatmaps</p></a></li>
<li><a href='#compare-NMF'><p>Comparing Results from Different NMF Runs</p></a></li>
<li><a href='#connectivity'><p>Clustering Connectivity and Consensus Matrices</p></a></li>
<li><a href='#consensus,NMFfitX1-method'><p>Returns the consensus matrix computed while performing all NMF runs,</p>
amongst which <code>object</code> was selected as the best fit.</a></li>
<li><a href='#consensus,NMFfitXn-method'><p>Computes the consensus matrix of the set of fits stored in <code>object</code>, as</p>
the mean connectivity matrix across runs.</a></li>
<li><a href='#consensushc'><p>Hierarchical Clustering of a Consensus Matrix</p></a></li>
<li><a href='#cophcor'><p>Cophenetic Correlation Coefficient</p></a></li>
<li><a href='#cutdendro'><p>Fade Out the Upper Branches from a Dendrogram</p></a></li>
<li><a href='#deviance'><p>Distances and Objective Functions</p></a></li>
<li><a href='#dispersion'><p>Dispersion of a Matrix</p></a></li>
<li><a href='#esGolub'><p>Golub ExpressionSet</p></a></li>
<li><a href='#fcnnls'><p>Fast Combinatorial Nonnegative Least-Square</p></a></li>
<li><a href='#featureScore'><p>Feature Selection in NMF Models</p></a></li>
<li><a href='#fit'><p>Extracting Fitted Models</p></a></li>
<li><a href='#fitted'><p>Fitted Matrix in NMF Models</p></a></li>
<li><a href='#getRNG1'><p>Extracting RNG Data from NMF Objects</p></a></li>
<li><a href='#gfile'><p>Open a File Graphic Device</p></a></li>
<li><a href='#heatmap-NMF'><p>Heatmaps of NMF Factors</p></a></li>
<li><a href='#ibterms'><p>Fixed Terms in NMF Models</p></a></li>
<li><a href='#is.nmf'><p>Testing NMF Objects</p></a></li>
<li><a href='#isCRANcheck'><p>Package Check Utils</p></a></li>
<li><a href='#latex_preamble'><p>LaTeX Utilities for Vignettes</p></a></li>
<li><a href='#lverbose'><p>Internal verbosity option</p></a></li>
<li><a href='#match_atrack'><p>Extending Annotation Vectors</p></a></li>
<li><a href='#methods-NMF'><p>Registry for NMF Algorithms</p></a></li>
<li><a href='#nbasis'><p>Dimension of NMF Objects</p></a></li>
<li><a href='#nmf'><p>Running NMF algorithms</p></a></li>
<li><a href='#nmf_update.brunet_R'><p>NMF Algorithm/Updates for Kullback-Leibler Divergence</p></a></li>
<li><a href='#nmf_update.euclidean_offset.h'><p>NMF Multiplicative Update for NMF with Offset Models</p></a></li>
<li><a href='#nmf_update.euclidean.h'><p>NMF Multiplicative Updates for Euclidean Distance</p></a></li>
<li><a href='#nmf_update.KL.h'><p>NMF Multiplicative Updates for Kullback-Leibler Divergence</p></a></li>
<li><a href='#nmf_update.lee_R'><p>NMF Algorithm/Updates for Frobenius Norm</p></a></li>
<li><a href='#nmf_update.lsnmf'><p>Multiplicative Updates for LS-NMF</p></a></li>
<li><a href='#nmf_update.ns'><p>NMF Multiplicative Update for Nonsmooth Nonnegative Matrix Factorization (nsNMF).</p></a></li>
<li><a href='#NMF-class'><p>Generic Interface for Nonnegative Matrix Factorisation Models</p></a></li>
<li><a href='#NMF-defunct'><p>Defunct Functions and Classes in the NMF Package</p></a></li>
<li><a href='#NMF-deprecated'><p>Deprecated Functions in the Package NMF</p></a></li>
<li><a href='#nmf.equal'><p>Testing Equality of NMF Models</p></a></li>
<li><a href='#nmfAlgorithm'><p>Listing and Retrieving NMF Algorithms</p></a></li>
<li><a href='#nmfAlgorithm.SNMF_R'><p>NMF Algorithm - Sparse NMF via Alternating NNLS</p></a></li>
<li><a href='#nmfApply'><p>Apply Function for NMF Objects</p></a></li>
<li><a href='#nmfCheck'><p>Checking NMF Algorithm</p></a></li>
<li><a href='#nmfEstimateRank'><p>Estimate Rank for NMF Models</p></a></li>
<li><a href='#NMFfit-class'><p>Base Class for to store Nonnegative Matrix Factorisation results</p></a></li>
<li><a href='#NMFfitX'><p>Factory Method for Multiple NMF Run Objects</p></a></li>
<li><a href='#NMFfitX-class'><p>Virtual Class to Handle Results from Multiple Runs of NMF Algorithms</p></a></li>
<li><a href='#NMFfitX1-class'><p>Structure for Storing the Best Fit Amongst Multiple NMF Runs</p></a></li>
<li><a href='#NMFfitXn-class'><p>Structure for Storing All Fits from Multiple NMF Runs</p></a></li>
<li><a href='#nmfFormals'><p>Showing Arguments of NMF Algorithms</p></a></li>
<li><a href='#NMFList-class'><p>Class for Storing Heterogeneous NMF fits</p></a></li>
<li><a href='#nmfModel'><p>Factory Methods NMF Models</p></a></li>
<li><a href='#NMFns-class'><p>NMF Model - Nonsmooth Nonnegative Matrix Factorization</p></a></li>
<li><a href='#nmfObject'><p>Updating NMF Objects</p></a></li>
<li><a href='#NMFOffset-class'><p>NMF Model - Nonnegative Matrix Factorization with Offset</p></a></li>
<li><a href='#nmfReport'><p>Run NMF Methods and Generate a Report</p></a></li>
<li><a href='#nmfSeed'><p>Seeding Strategies for NMF Algorithms</p></a></li>
<li><a href='#NMFSeed'><p><code>NMFSeed</code> is a constructor method that instantiate</p>
<code>NMFSeed</code> objects.</a></li>
<li><a href='#NMFSeed-class'><p>Base class that defines the interface for NMF seeding methods.</p></a></li>
<li><a href='#NMFstd-class'><p>NMF Model - Standard model</p></a></li>
<li><a href='#NMFStop'><p>Stopping Criteria for NMF Iterative Strategies</p></a></li>
<li><a href='#NMFStrategy'><p>Factory Method for NMFStrategy Objects</p></a></li>
<li><a href='#NMFStrategy-class'><p>Virtual Interface for NMF Algorithms</p></a></li>
<li><a href='#NMFStrategyFunction-class'><p>Interface for Single Function NMF Strategies</p></a></li>
<li><a href='#NMFStrategyIterative-class'><p>Interface for Algorithms: Implementation for Iterative NMF Algorithms</p></a></li>
<li><a href='#nmfWrapper'><p>Wrapping NMF Algorithms</p></a></li>
<li><a href='#nneg'><p>Transforming from Mixed-sign to Nonnegative Data</p></a></li>
<li><a href='#objective,NMFfit-method'><p>Returns the objective function associated with the algorithm that computed the</p>
fitted NMF model <code>object</code>, or the objective value with respect to a given
target matrix <code>y</code> if it is supplied.</a></li>
<li><a href='#offset,NMFfit-method'><p>Returns the offset from the fitted model.</p></a></li>
<li><a href='#offset,NMFOffset-method'><p>Offsets in NMF Models with Offset</p></a></li>
<li><a href='#options-NMF'><p>NMF Package Specific Options</p></a></li>
<li><a href='#parallel-NMF'><p>Utilities for Parallel Computations</p></a></li>
<li><a href='#parse_formula'><p>Simple Parsing of Formula</p></a></li>
<li><a href='#plot,NMFfit,missing-method'><p>Plots the residual track computed at regular interval during the fit of</p>
the NMF model <code>x</code>.</a></li>
<li><a href='#pmax.inplace'><p>Updating Objects In Place</p></a></li>
<li><a href='#predict'><p>Clustering and Prediction</p></a></li>
<li><a href='#profplot'><p>Plotting Expression Profiles</p></a></li>
<li><a href='#purity'><p>Purity and Entropy of a Clustering</p></a></li>
<li><a href='#randomize'><p>Randomizing Data</p></a></li>
<li><a href='#registerDoBackend'><p>Utilities and Extensions for Foreach Loops</p></a></li>
<li><a href='#residuals'><p>Residuals in NMF Models</p></a></li>
<li><a href='#revPalette'><p>Flags a Color Palette Specification for Reversion</p></a></li>
<li><a href='#rmatrix'><p>Generating Random Matrices</p></a></li>
<li><a href='#rnmf'><p>Generating Random NMF Models</p></a></li>
<li><a href='#rss'><p>Residual Sum of Squares and Explained Variance</p></a></li>
<li><a href='#runtime,NMFList-method'><p>Returns the CPU time required to compute all NMF fits in the list.</p>
It returns <code>NULL</code> if the list is empty.
If no timing data are available, the sequential time is returned.</a></li>
<li><a href='#runtime.all,NMFfitXn-method'><p>Returns the CPU time used to perform all the NMF fits stored in <code>object</code>.</p></a></li>
<li><a href='#scale.NMF'><p>Rescaling NMF Models</p></a></li>
<li><a href='#seed'><p>Interface for NMF Seeding Methods</p></a></li>
<li><a href='#setNMFMethod'><p>Registering NMF Algorithms</p></a></li>
<li><a href='#setupBackend'><p>Computational Setup Functions</p></a></li>
<li><a href='#show,NMF-method'><p>Show method for objects of class <code>NMF</code></p></a></li>
<li><a href='#show,NMFfit-method'><p>Show method for objects of class <code>NMFfit</code></p></a></li>
<li><a href='#show,NMFfitX-method'><p>Show method for objects of class <code>NMFfitX</code></p></a></li>
<li><a href='#show,NMFfitX1-method'><p>Show method for objects of class <code>NMFfitX1</code></p></a></li>
<li><a href='#show,NMFfitXn-method'><p>Show method for objects of class <code>NMFfitXn</code></p></a></li>
<li><a href='#show,NMFList-method'><p>Show method for objects of class <code>NMFList</code></p></a></li>
<li><a href='#show,NMFns-method'><p>Show method for objects of class <code>NMFns</code></p></a></li>
<li><a href='#show,NMFOffset-method'><p>Show method for objects of class <code>NMFOffset</code></p></a></li>
<li><a href='#show,NMFSeed-method'><p>Show method for objects of class <code>NMFSeed</code></p></a></li>
<li><a href='#show,NMFStrategyIterative-method'><p>Show method for objects of class <code>NMFStrategyIterative</code></p></a></li>
<li><a href='#silhouette.NMF'><p>Silhouette of NMF Clustering</p></a></li>
<li><a href='#smoothing'><p>Smoothing Matrix in Nonsmooth NMF Models</p></a></li>
<li><a href='#sparseness'><p>Sparseness</p></a></li>
<li><a href='#staticVar'><p>Get/Set a Static Variable in NMF Algorithms</p></a></li>
<li><a href='#Strategy-class'><p>Generic Strategy Class</p></a></li>
<li><a href='#summary'><p>Assessing and Comparing NMF Models</p></a></li>
<li><a href='#syntheticNMF'><p>Simulating Datasets</p></a></li>
<li><a href='#t.NMF'><p>Transformation NMF Model Objects</p></a></li>
<li><a href='#tryViewport'><p>Internal Grid Extension</p></a></li>
<li><a href='#txtProgressBar'><p>Simple Progress Bar</p></a></li>
<li><a href='#utils-NMF'><p>Utility Function in the NMF Package</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Algorithms and Framework for Nonnegative Matrix Factorization
(NMF)</td>
</tr>
<tr>
<td>Version:</td>
<td>0.27</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-02-05</td>
</tr>
<tr>
<td>Author:</td>
<td>Renaud Gaujoux, Cathal Seoighe</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Nicolas Sauwen &lt;nicolas.sauwen@openanalytics.eu&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides a framework to perform Non-negative Matrix
    Factorization (NMF). The package implements a set of already published algorithms
    and seeding methods, and provides a framework to test, develop and plug
    new/custom algorithms. Most of the built-in algorithms have been optimized
    in C++, and the main interface function provides an easy way of performing
    parallel computations on multicore machines.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="http://renozao.github.io/NMF/">http://renozao.github.io/NMF/</a></td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0.0), methods, utils, registry, rngtools (&ge; 1.2.3),
cluster</td>
</tr>
<tr>
<td>Imports:</td>
<td>graphics, stats, stringr (&ge; 1.0.0), digest, grid, grDevices,
gridBase, colorspace, RColorBrewer, foreach, doParallel,
ggplot2, reshape2, Biobase, codetools, BiocManager</td>
</tr>
<tr>
<td>Suggests:</td>
<td>fastICA, doMPI, bigmemory (&ge; 4.2), synchronicity(&ge; 1.3.2),
corpcor, xtable, devtools, knitr, RUnit</td>
</tr>
<tr>
<td>Collate:</td>
<td>'colorcode.R' 'options.R' 'grid.R' 'atracks.R' 'aheatmap.R'
'algorithmic.R' 'nmf-package.R' 'rmatrix.R' 'utils.R'
'versions.R' 'NMF-class.R' 'transforms.R' 'Bioc-layer.R'
'NMFstd-class.R' 'NMFOffset-class.R' 'heatmaps.R'
'NMFns-class.R' 'nmfModel.R' 'fixed-terms.R' 'NMFfit-class.R'
'NMFSet-class.R' 'NMFStrategy-class.R' 'registry.R'
'NMFSeed-class.R' 'NMFStrategyFunction-class.R'
'NMFStrategyIterative-class.R' 'NMFplots.R'
'registry-algorithms.R' 'algorithms-base.R' 'algorithms-lnmf.R'
'algorithms-lsnmf.R' 'algorithms-pe-nmf.R' 'algorithms-siNMF.R'
'algorithms-snmf.R' 'data.R' 'extractFeatures.R' 'parallel.R'
'registry-seed.R' 'nmf.R' 'rnmf.R' 'run.R' 'seed-base.R'
'seed-ica.R' 'seed-nndsvd.R' 'setNMFClass.R' 'simulation.R'
'tests.R' 'vignetteFunctions.R'</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-02-08 07:53:20 UTC; nsauwen</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-02-08 17:50:02 UTC</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
</table>
<hr>
<h2 id='NMF-package'>Algorithms and framework for Nonnegative Matrix Factorization (NMF).</h2><span id='topic+NMF'></span><span id='topic+NMF-package'></span>

<h3>Description</h3>

<p>This package provides a framework to perform Non-negative
Matrix Factorization (NMF). It implements a set of
already published algorithms and seeding methods, and
provides a framework to test, develop and plug new/custom
algorithms. Most of the built-in algorithms have been
optimized in C++, and the main interface function
provides an easy way of performing parallel computations
on multicore machines.
</p>


<h3>Details</h3>

<p><code><a href="#topic+nmf">nmf</a></code> Run a given NMF algorithm
</p>


<h3>Author(s)</h3>

<p>Renaud Gaujoux <a href="mailto:renaud@cbio.uct.ac.za">renaud@cbio.uct.ac.za</a>
</p>


<h3>References</h3>

<p><a href="https://cran.r-project.org/">https://cran.r-project.org/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+nmf">nmf</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# generate a synthetic dataset with known classes
n &lt;- 50; counts &lt;- c(5, 5, 8);
V &lt;- syntheticNMF(n, counts)

# perform a 3-rank NMF using the default algorithm
res &lt;- nmf(V, 3)

basismap(res)
coefmap(res)
</code></pre>

<hr>
<h2 id='.atrack'>Annotation Tracks</h2><span id='topic+adata'></span><span id='topic+alength'></span><span id='topic+amargin'></span><span id='topic+anames'></span><span id='topic+annotationTrack'></span><span id='topic+atrack'></span><span id='topic+.atrack'></span><span id='topic+.atrack+2CANY-method'></span><span id='topic+.atrack+2Ccharacter-method'></span><span id='topic+.atrack+2Cdata.frame-method'></span><span id='topic+.atrack+2Cmatrix-method'></span><span id='topic+.atrack-methods'></span><span id='topic+is.atrack'></span>

<h3>Description</h3>

<p><code>.atrack</code> is an S4 generic method that converts an
object into an annotation track object. It provides a
general and flexible annotation framework that is used by
<code><a href="#topic+aheatmap">aheatmap</a></code> to annotates heatmap rows and
columns.
</p>
<p><code>is.atrack</code> tests if an object is an
<code>annotationTrack</code> object.
</p>
<p><code>adata</code> get/sets the annotation parameters on an
object
</p>
<p><code>amargin</code> get/sets the annotation margin, i.e. along
which dimension of the data the annotations are to be
considered.
</p>
<p><code>anames</code> returns the reference margin names for
annotation tracks, from their embedded annotation data
object.
</p>
<p><code>alength</code> returns the reference length for
annotation tracks, from their embedded annotation data
object
</p>
<p><code>atrack</code> creates/concatenates <code>annotationTrack</code>
objects
</p>
<p><code>annotationTrack</code> is constructor function for
<code>annotationTrack</code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  .atrack(object, ...)

  is.atrack(x)

  adata(x, value, ...)

  amargin(x, value)

  anames(x, default.margin)

  alength(x, default.margin)

  ## S4 method for signature 'ANY'
.atrack(object, data = NULL, ...)

  atrack(..., order = NULL, enforceNames = FALSE,
    .SPECIAL = NA, .DATA = NULL, .CACHE = NULL)

  annotationTrack(x = list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".atrack_+3A_object">object</code></td>
<td>
<p>an object from which is extracted
annotation tracks</p>
</td></tr>
<tr><td><code id=".atrack_+3A_...">...</code></td>
<td>
<p>extra arguments to allow extensions and passed
to the next method call. For <code>atrack</code>, arguments in
<code>...</code> are concatenated into a single
<code>annotationTrack</code> object.</p>
</td></tr>
<tr><td><code id=".atrack_+3A_x">x</code></td>
<td>
<p>an R object</p>
</td></tr>
<tr><td><code id=".atrack_+3A_value">value</code></td>
<td>
<p>replacement value for the complete
annotation data list</p>
</td></tr>
<tr><td><code id=".atrack_+3A_default.margin">default.margin</code></td>
<td>
<p>margin to use if no margin data is
stored in the <code>x</code>.</p>
</td></tr>
<tr><td><code id=".atrack_+3A_data">data</code></td>
<td>
<p>object used to extend the annotation track
within a given data context. It is typically a
matrix-like object, against which annotation
specifications are matched using
<code><a href="#topic+match_atrack">match_atrack</a></code>.</p>
</td></tr>
<tr><td><code id=".atrack_+3A_order">order</code></td>
<td>
<p>an integer vector that indicates the order
of the annotation tracks in the result list</p>
</td></tr>
<tr><td><code id=".atrack_+3A_enforcenames">enforceNames</code></td>
<td>
<p>logical that indicates if missing
track names should be generated as <code>X&lt;i&gt;</code></p>
</td></tr>
<tr><td><code id=".atrack_+3A_.special">.SPECIAL</code></td>
<td>
<p>an optional list of functions (with no
arguments) that are called to generate special annotation
tracks defined by codes of the form <code>':NAME'</code>. e.g.,
the function <code>link{consensusmap}</code> defines special
tracks <code>':basis'</code> and <code>':consensus'</code>.
</p>
<p>If <code>.SPECIAL=FALSE</code>, then any special tracks is
discarded and a warning is thrown.</p>
</td></tr>
<tr><td><code id=".atrack_+3A_.data">.DATA</code></td>
<td>
<p>data used to match and extend annotation
specifications. It is passed to argument <code>data</code> of
the <code>.atrack</code> methods, which in turn use pass it to
<code><a href="#topic+match_atrack">match_atrack</a></code>.</p>
</td></tr>
<tr><td><code id=".atrack_+3A_.cache">.CACHE</code></td>
<td>
<p>an <code>annotationTrack</code> object with which
the generated annotation track should be consistent. This
argument is more for internal/advanced usage and should
not be used by the end-user.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Methods for <code>.atrack</code> exist for common type of
objects, which should provide enough options for new
methods to define how annotation track are extracted from
more complex objects, by coercing/filtering them into a
supported type.
</p>


<h3>Value</h3>

<p><code>atrack</code> returns a list, decorated with class
<code>'annotationTrack'</code>, where each element contains the
description of an annotation track.
</p>


<h3>Methods</h3>


<dl>
<dt>.atrack</dt><dd><p><code>signature(object = "ANY")</code>: The
default method converts character or integer vectors into
factors. Numeric vectors, factors, a single NA or
<code>annotationTrack</code> objects are returned unchanged
(except from reordering by argument <code>order</code>). Data
frames are not changed either, but class
'annotationTrack' is appended to their original class
set. </p>
</dd>
</dl>


<hr>
<h2 id='.fcnnls'>Internal Routine for Fast Combinatorial Nonnegative Least-Squares</h2><span id='topic+.fcnnls'></span>

<h3>Description</h3>

<p>This is the workhorse function for the higher-level
function <code><a href="#topic+fcnnls">fcnnls</a></code>, which implements the fast
nonnegative least-square algorithm for multiple
right-hand-sides from <cite>Van Benthem et al. (2004)</cite> to
solve the following problem:
</p>
<p style="text-align: center;"><code class="reqn"> \begin{array}{l} \min \|Y - X K\|_F\\ \mbox{s.t. }
  K&gt;=0 \end{array} </code>
</p>

<p>where <code class="reqn">Y</code> and <code class="reqn">X</code> are two real matrices of
dimension <code class="reqn">n \times p</code> and <code class="reqn">n \times r</code> respectively, and <code class="reqn">\|.\|_F</code> is the
Frobenius norm.
</p>
<p>The algorithm is very fast compared to other approaches,
as it is optimised for handling multiple right-hand
sides.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  .fcnnls(x, y, verbose = FALSE, pseudo = FALSE, eps = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".fcnnls_+3A_x">x</code></td>
<td>
<p>the coefficient matrix</p>
</td></tr>
<tr><td><code id=".fcnnls_+3A_y">y</code></td>
<td>
<p>the target matrix to be approximated by <code class="reqn">X
  K</code>.</p>
</td></tr>
<tr><td><code id=".fcnnls_+3A_verbose">verbose</code></td>
<td>
<p>logical that indicates if log messages
should be shown.</p>
</td></tr>
<tr><td><code id=".fcnnls_+3A_pseudo">pseudo</code></td>
<td>
<p>By default (<code>pseudo=FALSE</code>) the
algorithm uses Gaussian elimination to solve the
successive internal linear problems, using the
<code><a href="Matrix.html#topic+solve">solve</a></code> function.  If <code>pseudo=TRUE</code> the
algorithm uses Moore-Penrose generalized
<code><a href="corpcor.html#topic+pseudoinverse">pseudoinverse</a></code> from the
<code>corpcor</code> package instead of <a href="Matrix.html#topic+solve">solve</a>.</p>
</td></tr>
<tr><td><code id=".fcnnls_+3A_eps">eps</code></td>
<td>
<p>threshold for considering entries as
nonnegative. This is an experimental parameter, and it is
recommended to leave it at 0.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following elements:
</p>
<table>
<tr><td><code>coef</code></td>
<td>
<p>the fitted coefficient matrix.</p>
</td></tr>
<tr><td><code>Pset</code></td>
<td>
<p>the set of passive constraints, as a logical
matrix of the same size as <code>K</code> that indicates which
element is positive.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Van Benthem M and Keenan MR (2004). &quot;Fast algorithm for
the solution of large-scale non-negativity-constrained
least squares problems.&quot; _Journal of Chemometrics_,
*18*(10), pp. 441-450. ISSN 0886-9383, &lt;URL:
http://dx.doi.org/10.1002/cem.889&gt;, &lt;URL:
http://doi.wiley.com/10.1002/cem.889&gt;.
</p>

<hr>
<h2 id='+5B+2CNMF-method'>Sub-setting NMF Objects</h2><span id='topic++5B+2CNMF-method'></span>

<h3>Description</h3>

<p>This method provides a convenient way of sub-setting
objects of class <code>NMF</code>, using a matrix-like syntax.
</p>
<p>It allows to consistently subset one or both matrix
factors in the NMF model, as well as retrieving part of
the basis components or part of the mixture coefficients
with a reduced amount of code.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S4 method for signature 'NMF'
x[i, j, ..., drop = FALSE]
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B5B+2B2CNMF-method_+3A_i">i</code></td>
<td>
<p>index used to subset on the <strong>rows</strong> of the
basis matrix (i.e. the features). It can be a
<code>numeric</code>, <code>logical</code>, or <code>character</code>
vector (whose elements must match the row names of
<code>x</code>). In the case of a <code>logical</code> vector the
entries are recycled if necessary.</p>
</td></tr>
<tr><td><code id="+2B5B+2B2CNMF-method_+3A_j">j</code></td>
<td>
<p>index used to subset on the <strong>columns</strong> of
the mixture coefficient matrix (i.e. the samples). It can
be a <code>numeric</code>, <code>logical</code>, or <code>character</code>
vector (whose elements must match the column names of
<code>x</code>). In the case of a <code>logical</code> vector the
entries are recycled if necessary.</p>
</td></tr>
<tr><td><code id="+2B5B+2B2CNMF-method_+3A_...">...</code></td>
<td>
<p>used to specify a third index to subset on the
basis components, i.e. on both the columns and rows of
the basis matrix and mixture coefficient respectively. It
can be a <code>numeric</code>, <code>logical</code>, or
<code>character</code> vector (whose elements must match the
basis names of <code>x</code>). In the case of a <code>logical</code>
vector the entries are recycled if necessary.
</p>
<p>Note that only the first extra subset index is used. A
warning is thrown if more than one extra argument is
passed in <code>...</code>.</p>
</td></tr>
<tr><td><code id="+2B5B+2B2CNMF-method_+3A_drop">drop</code></td>
<td>
<p>single <code>logical</code> value used to drop the
<code>NMF-class</code> wrapping and only return subsets of one
of the factor matrices (see <em>Details</em>)</p>
</td></tr>
<tr><td><code id="+2B5B+2B2CNMF-method_+3A_x">x</code></td>
<td>
<p> object from which to extract element(s) or in
which to replace element(s).  </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The returned value depends on the number of subset index
passed and the value of argument <code>drop</code>:
</p>
 <ul>
<li><p> No index as in <code>x[]</code> or <code>x[,]</code>:
the value is the object <code>x</code> unchanged.
</p>
</li>
<li><p> One single index as in <code>x[i]</code>: the value is
the complete NMF model composed of the selected basis
components, subset by <code>i</code>, except if argument
<code>drop=TRUE</code>, or if it is missing and <code>i</code> is of
length 1. Then only the basis matrix is returned with
dropped dimensions: <code>x[i, drop=TRUE]</code> &lt;=&gt;
<code>drop(basis(x)[, i])</code>.
</p>
<p>This means for example that <code>x[1L]</code> is the first
basis vector, and <code>x[1:3, drop = TRUE]</code> is the
matrix composed of the 3 first basis vectors &ndash; in
columns.
</p>
<p>Note that in version &lt;= 0.18.3, the call <code>x[i, drop
  = TRUE.or.FALSE]</code> was equivalent to <code>basis(x)[, i,
  drop=TRUE.or.FALSE]</code>.
</p>
</li>
<li><p> More than one index with <code>drop=FALSE</code>
(default) as in <code>x[i,j]</code>, <code>x[i,]</code>,
<code>x[,j]</code>, <code>x[i,j,k]</code>, <code>x[i,,k]</code>, etc...:
the value is a <code>NMF</code> object whose basis and/or
mixture coefficient matrices have been subset
accordingly. The third index <code>k</code> affects
simultaneously the columns of the basis matrix AND the
rows of the mixture coefficient matrix. In this case
argument <code>drop</code> is not used.
</p>
</li>
<li><p> More than one index with <code>drop=TRUE</code> and
<code>i</code> xor <code>j</code> missing: the value returned is the
matrix that is the more affected by the subset index.
That is that <code>x[i, , drop=TRUE]</code> and <code>x[i, , k,
  drop=TRUE]</code> return the basis matrix subset by <code>[i,]</code>
and <code>[i,k]</code> respectively, while <code>x[, j,
  drop=TRUE]</code> and <code>x[, j, k, drop=TRUE]</code> return the
mixture coefficient matrix subset by <code>[,j]</code> and
<code>[k,j]</code> respectively.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>

# create a dummy NMF object that highlight the different way of subsetting
a &lt;- nmfModel(W=outer(seq(1,5),10^(0:2)), H=outer(10^(0:2),seq(-1,-10)))
basisnames(a) &lt;- paste('b', 1:nbasis(a), sep='')
rownames(a) &lt;- paste('f', 1:nrow(a), sep='')
colnames(a) &lt;- paste('s', 1:ncol(a), sep='')

# or alternatively:
# dimnames(a) &lt;- list( features=paste('f', 1:nrow(a), sep='')
#					, samples=paste('s', 1:ncol(a), sep='')
#					, basis=paste('b', 1:nbasis(a)) )

# look at the resulting NMF object
a
basis(a)
coef(a)

# extract basis components
a[1]
a[1, drop=FALSE] # not dropping matrix dimension
a[2:3]

# subset on the features
a[1,]
a[2:4,]
# dropping the NMF-class wrapping =&gt; return subset basis matrix
a[2:4,, drop=TRUE]

# subset on the samples
a[,1]
a[,2:4]
# dropping the NMF-class wrapping =&gt; return subset coef matrix
a[,2:4, drop=TRUE]

# subset on the basis =&gt; subsets simultaneously basis and coef matrix
a[,,1]
a[,,2:3]
a[4:5,,2:3]
a[4:5,,2:3, drop=TRUE] # return subset basis matrix
a[,4:5,2:3, drop=TRUE] # return subset coef matrix

# 'drop' has no effect here
a[,,2:3, drop=TRUE]
</code></pre>

<hr>
<h2 id='advanced-NMF'>Advanced Usage of the Package NMF</h2><span id='topic+advanced-NMF'></span><span id='topic+which.best'></span>

<h3>Description</h3>

<p>The functions documented here provide advanced
functionalities useful when developing within the
framework implemented in the NMF package.
</p>
<p><code>which.best</code> returns the index of the best fit in a
list of NMF fit, according to some quantitative measure.
The index of the fit with the lowest measure is returned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  which.best(object, FUN = deviance, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="advanced-NMF_+3A_object">object</code></td>
<td>
<p>an NMF model fitted by multiple runs.</p>
</td></tr>
<tr><td><code id="advanced-NMF_+3A_fun">FUN</code></td>
<td>
<p>the function that computes the quantitative
measure.</p>
</td></tr>
<tr><td><code id="advanced-NMF_+3A_...">...</code></td>
<td>
<p>extra arguments passed to <code>FUN</code>.</p>
</td></tr>
</table>

<hr>
<h2 id='aggregate.measure'>Utility function to aggregate numerical quality measures from <code>NMFfitXn</code> objects.</h2><span id='topic+aggregate.measure'></span>

<h3>Description</h3>

<p>Given a numerical vector, this function computes an aggregated value using one of the following methods:
best or mean
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'measure'
aggregate(x, method = c("best", "mean"), decreasing = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="aggregate.measure_+3A_x">x</code></td>
<td>
<p>a numerical vector</p>
</td></tr>
<tr><td><code id="aggregate.measure_+3A_method">method</code></td>
<td>
<p>the method to aggregate values. This argument can take two values :
- mean: the mean of the measures
- best: the best measure according to the specified sorting order (decreasing or not)</p>
</td></tr>
<tr><td><code id="aggregate.measure_+3A_decreasing">decreasing</code></td>
<td>
<p>logical that specified the sorting order</p>
</td></tr>
<tr><td><code id="aggregate.measure_+3A_...">...</code></td>
<td>
<p>extra arguments to allow extension</p>
</td></tr>
</table>

<hr>
<h2 id='aheatmap'>Annotated Heatmaps</h2><span id='topic+aheatmap'></span>

<h3>Description</h3>

<p>The function <code>aheatmap</code> plots high-quality heatmaps,
with a detailed legend and unlimited annotation tracks
for both columns and rows. The annotations are coloured
differently according to their type (factor or numeric
covariate). Although it uses grid graphics, the generated
plot is compatible with base layouts such as the ones
defined with <code>'mfrow'</code> or <code><a href="graphics.html#topic+layout">layout</a></code>,
enabling the easy drawing of multiple heatmaps on a
single a plot &ndash; at last!.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  aheatmap(x, color = "-RdYlBu2:100", breaks = NA,
    border_color = NA, cellwidth = NA, cellheight = NA,
    scale = "none", Rowv = TRUE, Colv = TRUE,
    revC = identical(Colv, "Rowv") || is_NA(Rowv) || (is.integer(Rowv) &amp;&amp; 
        length(Rowv) &gt; 1) || is(Rowv, "silhouette"),
    distfun = "euclidean", hclustfun = "complete",
    reorderfun = function(d, w) reorder(d, w),
    treeheight = 50, legend = TRUE, annCol = NA,
    annRow = NA, annColors = NA, annLegend = TRUE,
    labRow = NULL, labCol = NULL, subsetRow = NULL,
    subsetCol = NULL, txt = NULL, fontsize = 10,
    cexRow = min(0.2 + 1/log10(nr), 1.2),
    cexCol = min(0.2 + 1/log10(nc), 1.2), filename = NA,
    width = NA, height = NA, main = NULL, sub = NULL,
    info = NULL, verbose = getOption("verbose"),
    gp = gpar())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="aheatmap_+3A_x">x</code></td>
<td>
<p>numeric matrix of the values to be plotted. An
<em>ExpressionSet</em> object can also be passed, in which case the expression
values are plotted (<code>exprs(x)</code>).</p>
</td></tr>
<tr><td><code id="aheatmap_+3A_color">color</code></td>
<td>
<p>colour specification for the heatmap.
Default to palette '-RdYlBu2:100', i.e. reversed palette
'RdYlBu2' (a slight modification of RColorBrewer's
palette 'RdYlBu') with 100 colors. Possible values are:
</p>
 <ul>
<li><p> a character/integer vector of length
greater than 1 that is directly used and assumed to
contain valid R color specifications. </p>
</li>
<li><p> a single
color/integer (between 0 and 8)/other numeric value that
gives the dominant colors. Numeric values are converted
into a pallete by <code>rev(sequential_hcl(2, h = x, l =
  c(50, 95)))</code>. Other values are concatenated with the grey
colour '#F1F1F1'. </p>
</li>
<li><p> one of RColorBrewer's palette
name (see <code><a href="RColorBrewer.html#topic+display.brewer.all">display.brewer.all</a></code>)
, or one of 'RdYlBu2', 'rainbow', 'heat', 'topo',
'terrain', 'cm'. </p>
</li></ul>
<p> When the coluor palette is specified
with a single value, and is negative or preceded a minus
('-'), the reversed palette is used. The number of breaks
can also be specified after a colon (':'). For example,
the default colour palette is specified as
'-RdYlBu2:100'.</p>
</td></tr>
<tr><td><code id="aheatmap_+3A_breaks">breaks</code></td>
<td>
<p>a sequence of numbers that covers the range
of values in <code>x</code> and is one element longer than
color vector. Used for mapping values to colors. Useful,
if needed to map certain values to certain colors. If
value is NA then the breaks are calculated automatically.
If <code>breaks</code> is a single value, then the colour
palette is centered on this value.</p>
</td></tr>
<tr><td><code id="aheatmap_+3A_border_color">border_color</code></td>
<td>
<p>color of cell borders on heatmap, use
NA if no border should be drawn.</p>
</td></tr>
<tr><td><code id="aheatmap_+3A_cellwidth">cellwidth</code></td>
<td>
<p>individual cell width in points. If left
as NA, then the values depend on the size of plotting
window.</p>
</td></tr>
<tr><td><code id="aheatmap_+3A_cellheight">cellheight</code></td>
<td>
<p>individual cell height in points. If
left as NA, then the values depend on the size of
plotting window.</p>
</td></tr>
<tr><td><code id="aheatmap_+3A_scale">scale</code></td>
<td>
<p>character indicating how the values should
scaled in either the row direction or the column
direction. Note that the scaling is performed after
row/column clustering, so that it has no effect on the
row/column ordering. Possible values are: </p>
 <ul>
<li>
<p><code>"row"</code>: center and standardize each row separately
to row Z-scores </p>
</li>
<li> <p><code>"column"</code>: center and
standardize each column separately to column Z-scores
</p>
</li>
<li> <p><code>"r1"</code>: scale each row to sum up to one </p>
</li>
<li>
<p><code>"c1"</code>: scale each column to sum up to one </p>
</li>
<li>
<p><code>"none"</code>: no scaling </p>
</li></ul>
</td></tr>
<tr><td><code id="aheatmap_+3A_rowv">Rowv</code></td>
<td>
<p>clustering specification(s) for the rows. It
allows to specify the
distance/clustering/ordering/display parameters to be
used for the <em>rows only</em>. Possible values are:
</p>
 <ul>
<li> <p><code>TRUE</code> or <code>NULL</code> (to be
consistent with <code><a href="stats.html#topic+heatmap">heatmap</a></code>): compute a
dendrogram from hierarchical clustering using the
distance and clustering methods <code>distfun</code> and
<code>hclustfun</code>.
</p>
</li>
<li> <p><code>NA</code>: disable any ordering. In this case, and
if not otherwise specified with argument
<code>revC=FALSE</code>, the heatmap shows the input matrix
with the rows in their original order, with the first row
on top to the last row at the bottom. Note that this
differ from the behaviour or <code><a href="stats.html#topic+heatmap">heatmap</a></code>, but
seemed to be a more sensible choice when vizualizing a
matrix without reordering.
</p>
</li>
<li><p> an integer vector of length the number of rows of
the input matrix (<code>nrow(x)</code>), that specifies the row
order. As in the case <code>Rowv=NA</code>, the ordered matrix
is shown first row on top, last row at the bottom.
</p>
</li>
<li><p> a character vector or a list specifying values to
use instead of arguments <code>distfun</code>, <code>hclustfun</code>
and <code>reorderfun</code> when clustering the rows (see the
respective argument descriptions for a list of accepted
values). If <code>Rowv</code> has no names, then the first
element is used for <code>distfun</code>, the second (if
present) is used for <code>hclustfun</code>, and the third (if
present) is used for <code>reorderfun</code>.
</p>
</li>
<li><p> a numeric vector of weights, of length the number
of rows of the input matrix, used to reorder the
internally computed dendrogram <code>d</code> by
<code>reorderfun(d, Rowv)</code>.
</p>
</li>
<li> <p><code>FALSE</code>: the dendrogram <em>is</em> computed
using methods <code>distfun</code>, <code>hclustfun</code>, and
<code>reorderfun</code> but is not shown.
</p>
</li>
<li><p> a single integer that specifies how many subtrees
(i.e. clusters) from the computed dendrogram should have
their root faded out. This can be used to better
highlight the different clusters.
</p>
</li>
<li><p> a single double that specifies how much space is
used by the computed dendrogram. That is that this value
is used in place of <code>treeheight</code>. </p>
</li></ul>
</td></tr>
<tr><td><code id="aheatmap_+3A_colv">Colv</code></td>
<td>
<p>clustering specification(s) for the columns.
It accepts the same values as argument <code>Rowv</code>
(modulo the expected length for vector specifications),
and allow specifying the
distance/clustering/ordering/display parameters to be
used for the <em>columns only</em>. <code>Colv</code> may also be
set to <code>"Rowv"</code>, in which case the dendrogram or
ordering specifications applied to the rows are also
applied to the columns. Note that this is allowed only
for square input matrices, and that the row ordering is
in this case by default reversed (<code>revC=TRUE</code>) to
obtain the diagonal in the standard way (from top-left to
bottom-right). See argument <code>Rowv</code> for other
possible values.</p>
</td></tr>
<tr><td><code id="aheatmap_+3A_revc">revC</code></td>
<td>
<p>a logical that specify if the <em>row
order</em> defined by <code>Rowv</code> should be reversed. This is
mainly used to get the rows displayed from top to bottom,
which is not the case by default. Its default value is
computed at runtime, to suit common situations where
natural ordering is a more sensible choice: no or fix
ordering of the rows (<code>Rowv=NA</code> or an integer vector
of indexes &ndash; of length &gt; 1), and when a symmetric
ordering is requested &ndash; so that the diagonal is shown as
expected. An argument in favor of the &quot;odd&quot; default
display (bottom to top) is that the row dendrogram is
plotted from bottom to top, and reversing its reorder may
take a not too long but non negligeable time.</p>
</td></tr>
<tr><td><code id="aheatmap_+3A_distfun">distfun</code></td>
<td>
<p>default distance measure used in
clustering rows and columns. Possible values are:
</p>
 <ul>
<li><p> all the distance methods supported by
<code><a href="stats.html#topic+dist">dist</a></code> (e.g. &quot;euclidean&quot; or &quot;maximum&quot;).
</p>
</li>
<li><p> all correlation methods supported by
<code><a href="stats.html#topic+cor">cor</a></code>, such as <code>"pearson"</code> or
<code>"spearman"</code>. The pairwise distances between
rows/columns are then computed as <code>d &lt;- dist(1 -
  cor(..., method = distfun))</code>.
</p>
<p>One may as well use the string &quot;correlation&quot; which is an
alias for &quot;pearson&quot;.
</p>
</li>
<li><p> an object of class <code>dist</code> such as returned by
<code><a href="stats.html#topic+dist">dist</a></code> or <code><a href="stats.html#topic+as.dist">as.dist</a></code>. </p>
</li></ul>
</td></tr>
<tr><td><code id="aheatmap_+3A_hclustfun">hclustfun</code></td>
<td>
<p>default clustering method used to
cluster rows and columns. Possible values are: </p>

<ul>
<li><p> a method name (a character string) supported by
<code><a href="stats.html#topic+hclust">hclust</a></code> (e.g. <code>'average'</code>). </p>
</li>
<li><p> an
object of class <code>hclust</code> such as returned by
<code><a href="stats.html#topic+hclust">hclust</a></code> </p>
</li>
<li><p> a dendrogram </p>
</li></ul>
</td></tr>
<tr><td><code id="aheatmap_+3A_reorderfun">reorderfun</code></td>
<td>
<p>default dendrogram reordering function,
used to reorder the dendrogram, when either <code>Rowv</code>
or <code>Colv</code> is a numeric weight vector, or provides or
computes a dendrogram. It must take 2 parameters: a
dendrogram, and a weight vector.</p>
</td></tr>
<tr><td><code id="aheatmap_+3A_subsetrow">subsetRow</code></td>
<td>
<p>Specification of subsetting the rows
before drawing the heatmap. Possible values are:
</p>
 <ul>
<li><p> an integer vector of length &gt; 1
specifying the indexes of the rows to keep; </p>
</li>
<li><p> a
character vector of length &gt; 1 specyfing the names of the
rows to keep. These are the original rownames, not the
names specified in <code>labRow</code>. </p>
</li>
<li><p> a logical vector
of length &gt; 1, whose elements are recycled if the vector
has not as many elements as rows in <code>x</code>. </p>
</li></ul>
<p> Note that
in the case <code>Rowv</code> is a dendrogram or hclust object,
it is first converted into an ordering vector, and cannot
be displayed &ndash; and a warning is thrown.</p>
</td></tr>
<tr><td><code id="aheatmap_+3A_subsetcol">subsetCol</code></td>
<td>
<p>Specification of subsetting the columns
before drawing the heatmap. It accepts the similar values
as <code>subsetRow</code>. See details above.</p>
</td></tr>
<tr><td><code id="aheatmap_+3A_txt">txt</code></td>
<td>
<p>character matrix of the same size as <code>x</code>,
that contains text to display in each cell. <code>NA</code>
values are allowed and are not displayed. See demo for an
example.</p>
</td></tr>
<tr><td><code id="aheatmap_+3A_treeheight">treeheight</code></td>
<td>
<p>how much space (in points) should be
used to display dendrograms. If specified as a single
value, it is used for both dendrograms. A length-2 vector
specifies separate values for the row and column
dendrogram respectively. Default value: 50 points.</p>
</td></tr>
<tr><td><code id="aheatmap_+3A_legend">legend</code></td>
<td>
<p>boolean value that determines if a colour
ramp for the heatmap's colour palette should be drawn or
not. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="aheatmap_+3A_anncol">annCol</code></td>
<td>
<p>specifications of column annotation tracks
displayed as coloured rows on top of the heatmaps. The
annotation tracks are drawn from bottom to top. A single
annotation track can be specified as a single vector;
multiple tracks are specified as a list, a data frame, or
an  <em>ExpressionSet</em> object, in which case the 
phenotypic data is used (<code>pData(eset)</code>). Character or 
integer vectors are converted and displayed as factors.
Unnamed tracks are internally renamed into <code>Xi</code>, with
i being incremented for each unamed track, across both
column and row annotation tracks. For each track, if no
corresponding colour is specified in argument
<code>annColors</code>, a palette or a ramp is automatically
computed and named after the track's name.</p>
</td></tr>
<tr><td><code id="aheatmap_+3A_annrow">annRow</code></td>
<td>
<p>specifications of row annotation tracks
displayed as coloured columns on the left of the
heatmaps. The annotation tracks are drawn from left to
right. The same conversion, renaming and colouring rules
as for argument <code>annCol</code> apply.</p>
</td></tr>
<tr><td><code id="aheatmap_+3A_anncolors">annColors</code></td>
<td>
<p>list for specifying annotation track
colors manually. It is possible to define the colors for
only some of the annotations. Check examples for
details.</p>
</td></tr>
<tr><td><code id="aheatmap_+3A_annlegend">annLegend</code></td>
<td>
<p>boolean value specifying if the legend
for the annotation tracks should be drawn or not. Default
is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="aheatmap_+3A_labrow">labRow</code></td>
<td>
<p>labels for the rows.</p>
</td></tr>
<tr><td><code id="aheatmap_+3A_labcol">labCol</code></td>
<td>
<p>labels for the columns. See description for
argument <code>labRow</code> for a list of the possible
values.</p>
</td></tr>
<tr><td><code id="aheatmap_+3A_fontsize">fontsize</code></td>
<td>
<p>base fontsize for the plot</p>
</td></tr>
<tr><td><code id="aheatmap_+3A_cexrow">cexRow</code></td>
<td>
<p>fontsize for the rownames, specified as a
fraction of argument <code>fontsize</code>.</p>
</td></tr>
<tr><td><code id="aheatmap_+3A_cexcol">cexCol</code></td>
<td>
<p>fontsize for the colnames, specified as a
fraction of argument <code>fontsize</code>.</p>
</td></tr>
<tr><td><code id="aheatmap_+3A_main">main</code></td>
<td>
<p>Main title as a character string or a grob.</p>
</td></tr>
<tr><td><code id="aheatmap_+3A_sub">sub</code></td>
<td>
<p>Subtitle as a character string or a grob.</p>
</td></tr>
<tr><td><code id="aheatmap_+3A_info">info</code></td>
<td>
<p>(experimental) Extra information as a
character vector or a grob.  If <code>info=TRUE</code>,
information about the clustering methods is displayed at
the bottom of the plot.</p>
</td></tr>
<tr><td><code id="aheatmap_+3A_filename">filename</code></td>
<td>
<p>file path ending where to save the
picture. Currently following formats are supported: png,
pdf, tiff, bmp, jpeg. Even if the plot does not fit into
the plotting window, the file size is calculated so that
the plot would fit there, unless specified otherwise.</p>
</td></tr>
<tr><td><code id="aheatmap_+3A_width">width</code></td>
<td>
<p>manual option for determining the output
file width in</p>
</td></tr>
<tr><td><code id="aheatmap_+3A_height">height</code></td>
<td>
<p>manual option for determining the output
file height in inches.</p>
</td></tr>
<tr><td><code id="aheatmap_+3A_verbose">verbose</code></td>
<td>
<p>if <code>TRUE</code> then verbose messages are
displayed and the borders of some viewports are
highlighted. It is entended for debugging purposes.</p>
</td></tr>
<tr><td><code id="aheatmap_+3A_gp">gp</code></td>
<td>
<p>graphical parameters for the text used in plot.
Parameters passed to <code><a href="grid.html#topic+grid.text">grid.text</a></code>, see
<code><a href="grid.html#topic+gpar">gpar</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The development of this function started as a fork of the
function <code>pheatmap</code> from the <span class="pkg">pheatmap</span> package,
and provides several enhancements such as: </p>

<ul>
<li><p> argument names match those used in the base
function <code><a href="stats.html#topic+heatmap">heatmap</a></code>; </p>
</li>
<li><p> unlimited number of
annotation for <strong>both</strong> columns and rows, with
simplified and more flexible interface; </p>
</li>
<li><p> easy
specification of clustering methods and colors; </p>
</li>
<li>
<p>return clustering data, as well as grid grob object. </p>
</li></ul>

<p>Please read the associated vignette for more information
and sample code.
</p>


<h3>PDF graphic devices</h3>

<p>if plotting on a PDF graphic device &ndash; started with
<code><a href="grDevices.html#topic+pdf">pdf</a></code>, one may get generate a first blank
page, due to internals of standard functions from the
<span class="pkg">grid</span> package that are called by <code>aheatmap</code>.
The <span class="pkg">NMF</span> package ships a custom patch that fixes
this issue. However, in order to comply with CRAN
policies, the patch is <strong>not</strong> applied by default
and the user must explicitly be enabled it. This can be
achieved on runtime by either setting the NMF specific
option 'grid.patch' via
<code>nmf.options(grid.patch=TRUE)</code>, or on load time if
the environment variable 'R_PACKAGE_NMF_GRID_PATCH' is
defined and its value is something that is not equivalent
to <code>FALSE</code> (i.e. not &rdquo;, 'false' nor 0).
</p>


<h3>Author(s)</h3>

<p>Original version of <code>pheatmap</code>: Raivo Kolde
</p>
<p>Enhancement into <code>aheatmap</code>: Renaud Gaujoux
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

## See the demo 'aheatmap' for more examples:
## Not run: 
demo('aheatmap')

## End(Not run)

# Generate random data
n &lt;- 50; p &lt;- 20
x &lt;- abs(rmatrix(n, p, rnorm, mean=4, sd=1))
x[1:10, seq(1, 10, 2)] &lt;- x[1:10, seq(1, 10, 2)] + 3
x[11:20, seq(2, 10, 2)] &lt;- x[11:20, seq(2, 10, 2)] + 2
rownames(x) &lt;- paste("ROW", 1:n)
colnames(x) &lt;- paste("COL", 1:p)

## Default heatmap
aheatmap(x)

## Distance methods
aheatmap(x, Rowv = "correlation")
aheatmap(x, Rowv = "man") # partially matched to 'manhattan'
aheatmap(x, Rowv = "man", Colv="binary")

# Generate column annotations
annotation = data.frame(Var1 = factor(1:p %% 2 == 0, labels = c("Class1", "Class2")), Var2 = 1:10)
aheatmap(x, annCol = annotation)
</code></pre>

<hr>
<h2 id='algorithm+2CNMFList-method'>Returns the method names used to compute the NMF fits in the list.
It returns <code>NULL</code> if the list is empty.</h2><span id='topic+algorithm+2CNMFList-method'></span>

<h3>Description</h3>

<p>Returns the method names used to compute the NMF fits in
the list. It returns <code>NULL</code> if the list is empty.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S4 method for signature 'NMFList'
algorithm(object, string = FALSE,
    unique = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="algorithm+2B2CNMFList-method_+3A_string">string</code></td>
<td>
<p>a logical that indicate whether the names
should be collapsed into a comma-separated string.</p>
</td></tr>
<tr><td><code id="algorithm+2B2CNMFList-method_+3A_unique">unique</code></td>
<td>
<p>a logical that indicates whether the result
should contain the set of method names, removing
duplicated names. This argument is forced to <code>TRUE</code>
when <code>string=TRUE</code>.</p>
</td></tr>
<tr><td><code id="algorithm+2B2CNMFList-method_+3A_object">object</code></td>
<td>
<p>an object computed using some algorithm, or
that describes an algorithm itself.</p>
</td></tr>
</table>

<hr>
<h2 id='algorithmic-NMF'>Generic Interface for Algorithms</h2><span id='topic+algorithm'></span><span id='topic+algorithm+3C-'></span><span id='topic+algorithmic-NMF'></span><span id='topic+algorithm+3C--methods'></span><span id='topic+algorithm-methods'></span><span id='topic+algorithm+3C-+2CNMFfit+2CANY-method'></span><span id='topic+algorithm+2CNMFfit-method'></span><span id='topic+algorithm+2CNMFfitXn-method'></span><span id='topic+algorithm+3C-+2CNMFSeed+2Cfunction-method'></span><span id='topic+algorithm+2CNMFSeed-method'></span><span id='topic+algorithm+3C-+2CNMFStrategyFunction+2Cfunction-method'></span><span id='topic+algorithm+2CNMFStrategyFunction-method'></span><span id='topic+compare'></span><span id='topic+compare-methods'></span><span id='topic+compare+2CNMFfitXn-method'></span><span id='topic+logs'></span><span id='topic+logs+2CANY-method'></span><span id='topic+logs-methods'></span><span id='topic+modelname'></span><span id='topic+modelname+2CANY-method'></span><span id='topic+modelname-methods'></span><span id='topic+modelname+2CNMFfit-method'></span><span id='topic+modelname+2CNMFfitXn-method'></span><span id='topic+modelname+2CNMFStrategy-method'></span><span id='topic+niter'></span><span id='topic+niter+3C-'></span><span id='topic+niter+3C--methods'></span><span id='topic+niter-methods'></span><span id='topic+niter+2CNMFfit-method'></span><span id='topic+niter+3C-+2CNMFfit+2Cnumeric-method'></span><span id='topic+nrun'></span><span id='topic+nrun+2CANY-method'></span><span id='topic+nrun-methods'></span><span id='topic+nrun+2CNMFfit-method'></span><span id='topic+nrun+2CNMFfitX1-method'></span><span id='topic+nrun+2CNMFfitX-method'></span><span id='topic+nrun+2CNMFfitXn-method'></span><span id='topic+objective'></span><span id='topic+objective+3C-'></span><span id='topic+objective+3C--methods'></span><span id='topic+objective-methods'></span><span id='topic+objective+3C-+2CNMFfit+2CANY-method'></span><span id='topic+run'></span><span id='topic+run-methods'></span><span id='topic+runtime'></span><span id='topic+runtime.all'></span><span id='topic+runtime.all-methods'></span><span id='topic+runtime.all+2CNMFfit-method'></span><span id='topic+runtime.all+2CNMFfitX-method'></span><span id='topic+runtime-methods'></span><span id='topic+runtime+2CNMFfit-method'></span><span id='topic+seeding'></span><span id='topic+seeding+3C-'></span><span id='topic+seeding+3C--methods'></span><span id='topic+seeding-methods'></span><span id='topic+seeding+3C-+2CNMFfit-method'></span><span id='topic+seeding+2CNMFfit-method'></span><span id='topic+seeding+2CNMFfitXn-method'></span><span id='topic+seqtime'></span><span id='topic+seqtime-methods'></span><span id='topic+seqtime+2CNMFfitXn-method'></span><span id='topic+seqtime+2CNMFList-method'></span>

<h3>Description</h3>

<p>The functions documented here are S4 generics that define
an general interface for &ndash; optimisation &ndash; algorithms.
</p>
<p>This interface builds upon the broad definition of an
algorithm as a workhorse function to which is associated
auxiliary objects such as an underlying model or an
objective function that measures the adequation of the
model with observed data. It aims at complementing the
interface provided by the <code><a href="stats.html#topic+stats">stats</a></code> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  algorithm(object, ...)

  algorithm(object, ...)&lt;-value

  seeding(object, ...)

  seeding(object, ...)&lt;-value

  niter(object, ...)

  niter(object, ...)&lt;-value

  nrun(object, ...)

  objective(object, ...)

  objective(object, ...)&lt;-value

  runtime(object, ...)

  runtime.all(object, ...)

  seqtime(object, ...)

  modelname(object, ...)

  run(object, y, x, ...)

  logs(object, ...)

  compare(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="algorithmic-NMF_+3A_object">object</code></td>
<td>
<p>an object computed using some algorithm, or
that describes an algorithm itself.</p>
</td></tr>
<tr><td><code id="algorithmic-NMF_+3A_value">value</code></td>
<td>
<p>replacement value</p>
</td></tr>
<tr><td><code id="algorithmic-NMF_+3A_...">...</code></td>
<td>
<p>extra arguments to allow extension</p>
</td></tr>
<tr><td><code id="algorithmic-NMF_+3A_y">y</code></td>
<td>
<p>data object, e.g. a target matrix</p>
</td></tr>
<tr><td><code id="algorithmic-NMF_+3A_x">x</code></td>
<td>
<p>a model object used as a starting point by the
algorithm, e.g. a non-empty NMF model.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>algorithm</code> and <code>algorithm&lt;-</code> get/set an object
that describes the algorithm used to compute another
object, or with which it is associated. It may be a
simple character string that gives the algorithm's names,
or an object that includes the algorithm's definition
itself (e.g. an <code><a href="#topic+NMFStrategy">NMFStrategy</a></code> object).
</p>
<p><code>seeding</code> get/set the seeding method used to
initialise the computation of an object, i.e. usually the
function that sets the starting point of an algorithm.
</p>
<p><code>niter</code> and <code>niter&lt;-</code> get/set the number of
iterations performed to compute an object. The function
<code>niter&lt;-</code> would usually be called just before
returning the result of an algorithm, when putting
together data about the fit.
</p>
<p><code>nrun</code> returns the number of times the algorithm has
been run to compute an object. Usually this will be 1,
but may be be more if the algorithm involves multiple
starting points.
</p>
<p><code>objective</code> and <code>objective&lt;-</code> get/set the
objective function associated with an object. Some
methods for <code>objective</code> may also compute the
objective value with respect to some target/observed
data.
</p>
<p><code>runtime</code> returns the CPU time required to compute
an object. This would generally be an object of class
<code><a href="base.html#topic+proc.time">proc_time</a></code>.
</p>
<p><code>runtime.all</code> returns the CPU time required to
compute a collection of objects, e.g. a sequence of
independent fits.
</p>
<p><code>seqtime</code> returns the sequential CPU time &ndash; that
would be &ndash; required to compute a collection of objects.
It would differ from <code>runtime.all</code> if the
computations were performed in parallel.
</p>
<p><code>modelname</code> returns a the type of model associated
with an object.
</p>
<p><code>run</code> calls the workhorse function that actually
implements a strategy/algorithm, and run it on some data
object.
</p>
<p><code>logs</code> returns the log messages output during the
computation of an object.
</p>
<p><code>compare</code> compares objects obtained from running
separate algorithms.
</p>


<h3>Methods</h3>


<dl>
<dt>algorithm</dt><dd><p><code>signature(object = "NMFfit")</code>:
Returns the name of the algorithm that fitted the NMF
model <code>object</code>. </p>
</dd>
<dt>algorithm</dt><dd><p><code>signature(object = "NMFList")</code>:
Returns the method names used to compute the NMF fits in
the list. It returns <code>NULL</code> if the list is empty.
</p>
<p>See <code><a href="#topic+algorithm+2CNMFList-method">algorithm,NMFList-method</a></code> for more
details. </p>
</dd>
<dt>algorithm</dt><dd><p><code>signature(object = "NMFfitXn")</code>:
Returns the name of the common NMF algorithm used to
compute all fits stored in <code>object</code>
</p>
<p>Since all fits are computed with the same algorithm, this
method returns the name of algorithm that computed the
first fit. It returns <code>NULL</code> if the object is empty.
</p>
</dd>
<dt>algorithm</dt><dd><p><code>signature(object = "NMFSeed")</code>:
Returns the workhorse function of the seeding method
described by <code>object</code>. </p>
</dd>
<dt>algorithm</dt><dd><p><code>signature(object =
  "NMFStrategyFunction")</code>: Returns the single R function
that implements the NMF algorithm &ndash; as stored in slot
<code>algorithm</code>. </p>
</dd>
<dt>algorithm&lt;-</dt><dd><p><code>signature(object = "NMFSeed",
  value = "function")</code>: Sets the workhorse function of the
seeding method described by <code>object</code>. </p>
</dd>
<dt>algorithm&lt;-</dt><dd><p><code>signature(object =
  "NMFStrategyFunction", value = "function")</code>: Sets the
function that implements the NMF algorithm, stored in
slot <code>algorithm</code>. </p>
</dd>
<dt>compare</dt><dd><p><code>signature(object = "NMFfitXn")</code>:
Compares the fits obtained by separate runs of NMF, in a
single call to <code><a href="#topic+nmf">nmf</a></code>. </p>
</dd>
<dt>logs</dt><dd><p><code>signature(object = "ANY")</code>: Default
method that returns the value of attribute/slot
<code>'logs'</code> or, if this latter does not exists, the
value of element <code>'logs'</code> if <code>object</code> is a
<code>list</code>. It returns <code>NULL</code> if no logging data
was found. </p>
</dd>
<dt>modelname</dt><dd><p><code>signature(object = "ANY")</code>:
Default method which returns the class name(s) of
<code>object</code>. This should work for objects representing
models on their own.
</p>
<p>For NMF objects, this is the type of NMF model, that
corresponds to the name of the S4 sub-class of
<code><a href="#topic+NMF-class">NMF</a></code>, inherited by <code>object</code>. </p>
</dd>
<dt>modelname</dt><dd><p><code>signature(object = "NMFfit")</code>:
Returns the type of a fitted NMF model. It is a shortcut
for <code>modelname(fit(object)</code>. </p>
</dd>
<dt>modelname</dt><dd><p><code>signature(object = "NMFfitXn")</code>:
Returns the common type NMF model of all fits stored in
<code>object</code>
</p>
<p>Since all fits are from the same NMF model, this method
returns the model type of the first fit. It returns
<code>NULL</code> if the object is empty. </p>
</dd>
<dt>modelname</dt><dd><p><code>signature(object =
  "NMFStrategy")</code>: Returns the model(s) that an NMF
algorithm can fit. </p>
</dd>
<dt>niter</dt><dd><p><code>signature(object = "NMFfit")</code>: Returns
the number of iteration performed to fit an NMF model,
typically with function <code><a href="#topic+nmf">nmf</a></code>.
</p>
<p>Currently this data is stored in slot <code>'extra'</code>, but
this might change in the future. </p>
</dd>
<dt>niter&lt;-</dt><dd><p><code>signature(object = "NMFfit", value =
  "numeric")</code>: Sets the number of iteration performed to
fit an NMF model.
</p>
<p>This function is used internally by the function
<code><a href="#topic+nmf">nmf</a></code>. It is not meant to be called by the
user, except when developing new NMF algorithms
implemented as single function, to set the number of
iterations performed by the algorithm on the seed, before
returning it (see
<code><a href="#topic+NMFStrategyFunction-class">NMFStrategyFunction</a></code>). </p>
</dd>
<dt>nrun</dt><dd><p><code>signature(object = "ANY")</code>: Default
method that returns the value of attribute &lsquo;nrun&rsquo;.
</p>
<p>Such an attribute my be attached to objects to keep track
of data about the parent fit object (e.g. by method
<code><a href="#topic+consensus">consensus</a></code>), which can be used by subsequent
function calls such as plot functions (e.g. see
<code><a href="#topic+consensusmap">consensusmap</a></code>). This method returns
<code>NULL</code> if no suitable data was found. </p>
</dd>
<dt>nrun</dt><dd><p><code>signature(object = "NMFfitX")</code>: Returns
the number of NMF runs performed to create <code>object</code>.
</p>
<p>It is a pure virtual method defined to ensure <code>nrun</code>
is defined for sub-classes of <code>NMFfitX</code>, which
throws an error if called.
</p>
<p>Note that because the <code><a href="#topic+nmf">nmf</a></code> function allows
to run the NMF computation keeping only the best fit,
<code>nrun</code> may return a value greater than one, while
only the result of the best run is stored in the object
(cf. option <code>'k'</code> in method <code><a href="#topic+nmf">nmf</a></code>). </p>
</dd>
<dt>nrun</dt><dd><p><code>signature(object = "NMFfit")</code>: This
method always returns 1, since an <code>NMFfit</code> object is
obtained from a single NMF run. </p>
</dd>
<dt>nrun</dt><dd><p><code>signature(object = "NMFfitX1")</code>:
Returns the number of NMF runs performed, amongst which
<code>object</code> was selected as the best fit. </p>
</dd>
<dt>nrun</dt><dd><p><code>signature(object = "NMFfitXn")</code>:
Returns the number of runs performed to compute the fits
stored in the list (i.e. the length of the list itself).
</p>
</dd>
<dt>objective</dt><dd><p><code>signature(object = "NMFfit")</code>:
Returns the objective function associated with the
algorithm that computed the fitted NMF model
<code>object</code>, or the objective value with respect to a
given target matrix <code>y</code> if it is supplied.
</p>
<p>See <code><a href="#topic+objective+2CNMFfit-method">objective,NMFfit-method</a></code> for more
details. </p>
</dd>
<dt>runtime</dt><dd><p><code>signature(object = "NMFfit")</code>:
Returns the CPU time required to compute a single NMF
fit. </p>
</dd>
<dt>runtime</dt><dd><p><code>signature(object = "NMFList")</code>:
Returns the CPU time required to compute all NMF fits in
the list. It returns <code>NULL</code> if the list is empty. If
no timing data are available, the sequential time is
returned.
</p>
<p>See <code><a href="#topic+runtime+2CNMFList-method">runtime,NMFList-method</a></code> for more
details. </p>
</dd>
<dt>runtime.all</dt><dd><p><code>signature(object = "NMFfit")</code>:
Identical to <code>runtime</code>, since their is a single fit.
</p>
</dd>
<dt>runtime.all</dt><dd><p><code>signature(object = "NMFfitX")</code>:
Returns the CPU time required to compute all the NMF
runs. It returns <code>NULL</code> if no CPU data is available.
</p>
</dd>
<dt>runtime.all</dt><dd><p><code>signature(object = "NMFfitXn")</code>:
If no time data is available from in slot
&lsquo;runtime.all&rsquo; and argument <code>null=TRUE</code>, then
the sequential time as computed by <code><a href="#topic+seqtime">seqtime</a></code>
is returned, and a warning is thrown unless
<code>warning=FALSE</code>.
</p>
<p>See <code><a href="#topic+runtime.all+2CNMFfitXn-method">runtime.all,NMFfitXn-method</a></code> for more
details. </p>
</dd>
<dt>seeding</dt><dd><p><code>signature(object = "NMFfit")</code>:
Returns the name of the seeding method that generated the
starting point for the NMF algorithm that fitted the NMF
model <code>object</code>. </p>
</dd>
<dt>seeding</dt><dd><p><code>signature(object = "NMFfitXn")</code>:
Returns the name of the common seeding method used the
computation of all fits stored in <code>object</code>
</p>
<p>Since all fits are seeded using the same method, this
method returns the name of the seeding method used for
the first fit. It returns <code>NULL</code> if the object is
empty. </p>
</dd>
<dt>seqtime</dt><dd><p><code>signature(object = "NMFList")</code>:
Returns the CPU time that would be required to
sequentially compute all NMF fits stored in
<code>object</code>.
</p>
<p>This method calls the function <code>runtime</code> on each fit
and sum up the results. It returns <code>NULL</code> on an
empty object. </p>
</dd>
<dt>seqtime</dt><dd><p><code>signature(object = "NMFfitXn")</code>:
Returns the CPU time that would be required to
sequentially compute all NMF fits stored in
<code>object</code>.
</p>
<p>This method calls the function <code>runtime</code> on each fit
and sum up the results. It returns <code>NULL</code> on an
empty object. </p>
</dd>
</dl>



<h3>Interface fo NMF algorithms</h3>

<p>This interface is implemented for NMF algorithms by the
classes <code><a href="#topic+NMFfit">NMFfit</a></code>, <code><a href="#topic+NMFfitX">NMFfitX</a></code> and
<code><a href="#topic+NMFStrategy">NMFStrategy</a></code>, and their respective
sub-classes. The examples given in this documentation
page are mainly based on this implementation.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

#----------
# modelname,ANY-method
#----------
# get the type of an NMF model
modelname(nmfModel(3))
modelname(nmfModel(3, model='NMFns'))
modelname(nmfModel(3, model='NMFOffset'))

#----------
# modelname,NMFStrategy-method
#----------
# get the type of model(s) associated with an NMF algorithm
modelname( nmfAlgorithm('brunet') )
modelname( nmfAlgorithm('nsNMF') )
modelname( nmfAlgorithm('offset') )
</code></pre>

<hr>
<h2 id='basis'>Accessing NMF Factors</h2><span id='topic+basis'></span><span id='topic+.basis'></span><span id='topic+.basis+3C-'></span><span id='topic+basis+3C-'></span><span id='topic+basis+2CANY-method'></span><span id='topic+.basis+3C--methods'></span><span id='topic+.basis-methods'></span><span id='topic+basis+3C--methods'></span><span id='topic+basis-methods'></span><span id='topic+.basis+3C-+2CNMFfit+2Cmatrix-method'></span><span id='topic+.basis+2CNMFfit-method'></span><span id='topic+basis+2CNMFfitXn-method'></span><span id='topic+.basis+3C-+2CNMF+2Cmatrix-method'></span><span id='topic+.basis+2CNMF-method'></span><span id='topic+basis+3C-+2CNMF-method'></span><span id='topic+basis+2CNMF-method'></span><span id='topic+.basis+3C-+2CNMFstd+2Cmatrix-method'></span><span id='topic+.basis+2CNMFstd-method'></span><span id='topic+coef'></span><span id='topic+.coef'></span><span id='topic+.coef+3C-'></span><span id='topic+coef+3C-'></span><span id='topic+coefficients'></span><span id='topic+coefficients-methods'></span><span id='topic+coefficients+2CNMF-method'></span><span id='topic+.coef+3C--methods'></span><span id='topic+.coef-methods'></span><span id='topic+coef+3C--methods'></span><span id='topic+coef-methods'></span><span id='topic+.coef+3C-+2CNMFfit+2Cmatrix-method'></span><span id='topic+.coef+2CNMFfit-method'></span><span id='topic+coef+2CNMFfitXn-method'></span><span id='topic+.coef+3C-+2CNMF+2Cmatrix-method'></span><span id='topic+.coef+2CNMF-method'></span><span id='topic+coef+3C-+2CNMF-method'></span><span id='topic+coef+2CNMF-method'></span><span id='topic+.coef+3C-+2CNMFstd+2Cmatrix-method'></span><span id='topic+.coef+2CNMFstd-method'></span><span id='topic+loadings+2CNMF-method'></span><span id='topic+scoef'></span><span id='topic+scoef+2Cmatrix-method'></span><span id='topic+scoef-methods'></span><span id='topic+scoef+2CNMF-method'></span>

<h3>Description</h3>

<p><code>basis</code> and <code>basis&lt;-</code> are S4 generic functions
which respectively extract and set the matrix of basis
components of an NMF model (i.e. the first matrix
factor).
</p>
<p>The methods <code>.basis</code>, <code>.coef</code> and their
replacement versions are implemented as pure virtual
methods for the interface class <code>NMF</code>, meaning that
concrete NMF models must provide a definition for their
corresponding class (i.e. sub-classes of class
<code>NMF</code>). See <code><a href="#topic+NMF-class">NMF</a></code> for more
details.
</p>
<p><code>coef</code> and <code>coef&lt;-</code> respectively extract and
set the coefficient matrix of an NMF model (i.e. the
second matrix factor). For example, in the case of the
standard NMF model <code class="reqn">V \equiv WH</code>, the method
<code>coef</code> will return the matrix <code class="reqn">H</code>.
</p>
<p><code>.coef</code> and <code>.coef&lt;-</code> are low-level S4 generics
that simply return/set coefficient data in an object,
leaving some common processing to be performed in
<code>coef</code> and <code>coef&lt;-</code>.
</p>
<p>Methods <code>coefficients</code> and <code>coefficients&lt;-</code> are
simple aliases for methods <code>coef</code> and <code>coef&lt;-</code>
respectively.
</p>
<p><code>scoef</code> is similar to <code>coef</code>, but returns the
mixture coefficient matrix of an NMF model, with the
columns scaled so that they sum up to a given value (1 by
default).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  basis(object, ...)

  ## S4 method for signature 'NMF'
basis(object, all = TRUE, ...)

  .basis(object, ...)

  basis(object, ...)&lt;-value

  ## S4 replacement method for signature 'NMF'
basis(object, use.dimnames = TRUE,
    ...)&lt;-value

  .basis(object)&lt;-value

  ## S4 method for signature 'NMF'
loadings(x)

  coef(object, ...)

  ## S4 method for signature 'NMF'
coef(object, all = TRUE, ...)

  .coef(object, ...)

  coef(object, ...)&lt;-value

  ## S4 replacement method for signature 'NMF'
coef(object, use.dimnames = TRUE,
    ...)&lt;-value

  .coef(object)&lt;-value

  coefficients(object, ...)

  ## S4 method for signature 'NMF'
coefficients(object, all = TRUE, ...)

  scoef(object, ...)

  ## S4 method for signature 'NMF'
scoef(object, scale = 1)

  ## S4 method for signature 'matrix'
scoef(object, scale = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="basis_+3A_object">object</code></td>
<td>
<p>an object from which to extract the factor
matrices, typically an object of class
<code><a href="#topic+NMF-class">NMF</a></code>.</p>
</td></tr>
<tr><td><code id="basis_+3A_...">...</code></td>
<td>
<p>extra arguments to allow extension and passed
to the low-level access functions <code>.coef</code> and
<code>.basis</code>.
</p>
<p>Note that these throw an error if used in replacement
functions .</p>
</td></tr>
<tr><td><code id="basis_+3A_all">all</code></td>
<td>
<p>a logical that indicates whether the complete
matrix factor should be returned (<code>TRUE</code>) or only
the non-fixed part. This is relevant only for
formula-based NMF models that include fixed basis or
coefficient terms.</p>
</td></tr>
<tr><td><code id="basis_+3A_use.dimnames">use.dimnames</code></td>
<td>
<p>logical that indicates if the
object's dim names should be set using those from the new
value, or left unchanged &ndash; after truncating them to fit
new dimensions if necessary. This is useful to only set
the entries of a factor.</p>
</td></tr>
<tr><td><code id="basis_+3A_value">value</code></td>
<td>
<p>replacement value</p>
</td></tr>
<tr><td><code id="basis_+3A_scale">scale</code></td>
<td>
<p>scaling factor, which indicates to the value
the columns of the coefficient matrix should sum up to.</p>
</td></tr>
<tr><td><code id="basis_+3A_x">x</code></td>
<td>
<p>an object of class <code>"<a href="stats.html#topic+factanal">factanal</a>"</code> or
<code>"<a href="stats.html#topic+princomp">princomp</a>"</code> or the <code>loadings</code> component
of such an object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For example, in the case of the standard NMF model <code class="reqn">V
  \equiv W H</code>, the method <code>basis</code> will return
the matrix <code class="reqn">W</code>.
</p>
<p><code>basis</code> and <code>basis&lt;-</code> are defined for the top
virtual class <code><a href="#topic+NMF-class">NMF</a></code> only, and rely
internally on the low-level S4 generics <code>.basis</code> and
<code>.basis&lt;-</code> respectively that effectively extract/set
the coefficient data. These data are post/pre-processed,
e.g., to extract/set only their non-fixed terms or check
dimension compatibility.
</p>
<p><code>coef</code> and <code>coef&lt;-</code> are S4 methods defined for
the corresponding generic functions from package
<code>stats</code> (See <a href="stats.html#topic+coef">coef</a>). Similarly to
<code>basis</code> and <code>basis&lt;-</code>, they are defined for the
top virtual class <code><a href="#topic+NMF-class">NMF</a></code> only, and rely
internally on the S4 generics <code>.coef</code> and
<code>.coef&lt;-</code> respectively that effectively extract/set
the coefficient data. These data are post/pre-processed,
e.g., to extract/set only their non-fixed terms or check
dimension compatibility.
</p>


<h3>Methods</h3>


<dl>
<dt>basis</dt><dd><p><code>signature(object = "ANY")</code>: Default
method returns the value of S3 slot or attribute
<code>'basis'</code>. It returns <code>NULL</code> if none of these
are set.
</p>
<p>Arguments <code>...</code> are not used by this method. </p>
</dd>
<dt>basis</dt><dd><p><code>signature(object = "NMFfitXn")</code>:
Returns the basis matrix of the best fit amongst all the
fits stored in <code>object</code>. It is a shortcut for
<code>basis(fit(object))</code>. </p>
</dd>
<dt>.basis</dt><dd><p><code>signature(object = "NMF")</code>: Pure
virtual method for objects of class
<code><a href="#topic+NMF-class">NMF</a></code>, that should be overloaded by
sub-classes, and throws an error if called. </p>
</dd>
<dt>.basis</dt><dd><p><code>signature(object = "NMFstd")</code>: Get
the basis matrix in standard NMF models
</p>
<p>This function returns slot <code>W</code> of <code>object</code>. </p>
</dd>
<dt>.basis</dt><dd><p><code>signature(object = "NMFfit")</code>:
Returns the basis matrix from an NMF model fitted with
function <code><a href="#topic+nmf">nmf</a></code>.
</p>
<p>It is a shortcut for <code>.basis(fit(object), ...)</code>,
dispatching the call to the <code>.basis</code> method of the
actual NMF model. </p>
</dd>
<dt>.basis&lt;-</dt><dd><p><code>signature(object = "NMF", value =
  "matrix")</code>: Pure virtual method for objects of class
<code><a href="#topic+NMF-class">NMF</a></code>, that should be overloaded by
sub-classes, and throws an error if called. </p>
</dd>
<dt>.basis&lt;-</dt><dd><p><code>signature(object = "NMFstd", value
  = "matrix")</code>: Set the basis matrix in standard NMF models
</p>
<p>This function sets slot <code>W</code> of <code>object</code>. </p>
</dd>
<dt>.basis&lt;-</dt><dd><p><code>signature(object = "NMFfit", value
  = "matrix")</code>: Sets the the basis matrix of an NMF model
fitted with function <code><a href="#topic+nmf">nmf</a></code>.
</p>
<p>It is a shortcut for <code>.basis(fit(object)) &lt;- value</code>,
dispatching the call to the <code>.basis&lt;-</code> method of the
actual NMF model. It is not meant to be used by the user,
except when developing NMF algorithms, to update the
basis matrix of the seed object before returning it. </p>
</dd>
<dt>basis&lt;-</dt><dd><p><code>signature(object = "NMF")</code>: Default
methods that calls <code>.basis&lt;-</code> and check the validity
of the updated object. </p>
</dd>
<dt>coef</dt><dd><p><code>signature(object = "NMFfitXn")</code>:
Returns the coefficient matrix of the best fit amongst
all the fits stored in <code>object</code>. It is a shortcut
for <code>coef(fit(object))</code>. </p>
</dd>
<dt>.coef</dt><dd><p><code>signature(object = "NMF")</code>: Pure
virtual method for objects of class
<code><a href="#topic+NMF-class">NMF</a></code>, that should be overloaded by
sub-classes, and throws an error if called. </p>
</dd>
<dt>.coef</dt><dd><p><code>signature(object = "NMFstd")</code>: Get the
mixture coefficient matrix in standard NMF models
</p>
<p>This function returns slot <code>H</code> of <code>object</code>. </p>
</dd>
<dt>.coef</dt><dd><p><code>signature(object = "NMFfit")</code>: Returns
the the coefficient matrix from an NMF model fitted with
function <code><a href="#topic+nmf">nmf</a></code>.
</p>
<p>It is a shortcut for <code>.coef(fit(object), ...)</code>,
dispatching the call to the <code>.coef</code> method of the
actual NMF model. </p>
</dd>
<dt>.coef&lt;-</dt><dd><p><code>signature(object = "NMF", value =
  "matrix")</code>: Pure virtual method for objects of class
<code><a href="#topic+NMF-class">NMF</a></code>, that should be overloaded by
sub-classes, and throws an error if called. </p>
</dd>
<dt>.coef&lt;-</dt><dd><p><code>signature(object = "NMFstd", value =
  "matrix")</code>: Set the mixture coefficient matrix in
standard NMF models
</p>
<p>This function sets slot <code>H</code> of <code>object</code>. </p>
</dd>
<dt>.coef&lt;-</dt><dd><p><code>signature(object = "NMFfit", value =
  "matrix")</code>: Sets the the coefficient matrix of an NMF
model fitted with function <code><a href="#topic+nmf">nmf</a></code>.
</p>
<p>It is a shortcut for <code>.coef(fit(object)) &lt;- value</code>,
dispatching the call to the <code>.coef&lt;-</code> method of the
actual NMF model. It is not meant to be used by the user,
except when developing NMF algorithms, to update the
coefficient matrix in the seed object before returning
it. </p>
</dd>
<dt>coef&lt;-</dt><dd><p><code>signature(object = "NMF")</code>: Default
methods that calls <code>.coef&lt;-</code> and check the validity
of the updated object. </p>
</dd>
<dt>coefficients</dt><dd><p><code>signature(object = "NMF")</code>:
Alias to <code>coef,NMF</code>, therefore also pure virtual. </p>
</dd>
<dt>loadings</dt><dd><p><code>signature(x = "NMF")</code>: Method
loadings for NMF Models
</p>
<p>The method <code>loadings</code> is identical to <code>basis</code>,
but do not accept any extra argument.
</p>
<p>The method <code>loadings</code> is provided to standardise the
NMF interface against the one defined in the
<code><a href="stats.html#topic+stats">stats</a></code> package, and emphasises the
similarities between NMF and PCA or factorial analysis
(see <code><a href="stats.html#topic+loadings">loadings</a></code>). </p>
</dd>
</dl>



<h3>See Also</h3>

<p>Other NMF-interface:
<code><a href="#topic+.DollarNames+2CNMF-method">.DollarNames,NMF-method</a></code>,
<code><a href="#topic+misc">misc</a></code>, <code><a href="#topic+NMF-class">NMF-class</a></code>,
<code><a href="#topic++24+3C-+2CNMF-method">$&lt;-,NMF-method</a></code>, <code><a href="#topic++24+2CNMF-method">$,NMF-method</a></code>,
<code><a href="#topic+nmfModel">nmfModel</a></code>, <code><a href="#topic+nmfModels">nmfModels</a></code>,
<code><a href="#topic+rnmf">rnmf</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

#----------
# scoef
#----------
# Scaled coefficient matrix
x &lt;- rnmf(3, 10, 5)
scoef(x)
scoef(x, 100)

#----------
# .basis,NMFstd-method
#----------
# random standard NMF model
x &lt;- rnmf(3, 10, 5)
basis(x)
coef(x)

# set matrix factors
basis(x) &lt;- matrix(1, nrow(x), nbasis(x))
coef(x) &lt;- matrix(1, nbasis(x), ncol(x))
# set random factors
basis(x) &lt;- rmatrix(basis(x))
coef(x) &lt;- rmatrix(coef(x))

# incompatible matrices generate an error:
try( coef(x) &lt;- matrix(1, nbasis(x)-1, nrow(x)) )
# but the low-level method allow it
.coef(x) &lt;- matrix(1, nbasis(x)-1, nrow(x))
try( validObject(x) )
</code></pre>

<hr>
<h2 id='basiscor'>Correlations in NMF Models</h2><span id='topic+basiscor'></span><span id='topic+basiscor+2Cmatrix+2CNMF-method'></span><span id='topic+basiscor-methods'></span><span id='topic+basiscor+2CNMF+2Cmatrix-method'></span><span id='topic+basiscor+2CNMF+2Cmissing-method'></span><span id='topic+basiscor+2CNMF+2CNMF-method'></span><span id='topic+profcor'></span><span id='topic+profcor+2Cmatrix+2CNMF-method'></span><span id='topic+profcor-methods'></span><span id='topic+profcor+2CNMF+2Cmatrix-method'></span><span id='topic+profcor+2CNMF+2Cmissing-method'></span><span id='topic+profcor+2CNMF+2CNMF-method'></span>

<h3>Description</h3>

<p><code>basiscor</code> computes the correlation matrix between
basis vectors, i.e. the <em>columns</em> of its basis
matrix &ndash; which is the model's first matrix factor.
</p>
<p><code>profcor</code> computes the correlation matrix between
basis profiles, i.e. the <em>rows</em> of the coefficient
matrix &ndash; which is the model's second matrix factor.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  basiscor(x, y, ...)

  profcor(x, y, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="basiscor_+3A_x">x</code></td>
<td>
<p>a matrix or an object with suitable methods
<code><a href="#topic+basis">basis</a></code> or <code><a href="#topic+coef">coef</a></code>.</p>
</td></tr>
<tr><td><code id="basiscor_+3A_y">y</code></td>
<td>
<p>a matrix or an object with suitable methods
<code><a href="#topic+basis">basis</a></code> or <code><a href="#topic+coef">coef</a></code>, and dimensions
compatible with <code>x</code>. If missing the correlations are
computed between <code>x</code> and <code>y=x</code>.</p>
</td></tr>
<tr><td><code id="basiscor_+3A_...">...</code></td>
<td>
<p>extra arguments passed to <code><a href="stats.html#topic+cor">cor</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Each generic has methods defined for computing
correlations between NMF models and/or compatible
matrices. The computation is performed by the base
function <code><a href="stats.html#topic+cor">cor</a></code>.
</p>


<h3>Methods</h3>


<dl>
<dt>basiscor</dt><dd><p><code>signature(x = "NMF", y =
  "matrix")</code>: Computes the correlations between the basis
vectors of <code>x</code> and the columns of <code>y</code>. </p>
</dd>
<dt>basiscor</dt><dd><p><code>signature(x = "matrix", y =
  "NMF")</code>: Computes the correlations between the columns of
<code>x</code> and the the basis vectors of <code>y</code>. </p>
</dd>
<dt>basiscor</dt><dd><p><code>signature(x = "NMF", y = "NMF")</code>:
Computes the correlations between the basis vectors of
<code>x</code> and <code>y</code>. </p>
</dd>
<dt>basiscor</dt><dd><p><code>signature(x = "NMF", y =
  "missing")</code>: Computes the correlations between the basis
vectors of <code>x</code>. </p>
</dd>
<dt>profcor</dt><dd><p><code>signature(x = "NMF", y = "matrix")</code>:
Computes the correlations between the basis profiles of
<code>x</code> and the rows of <code>y</code>. </p>
</dd>
<dt>profcor</dt><dd><p><code>signature(x = "matrix", y = "NMF")</code>:
Computes the correlations between the rows of <code>x</code>
and the basis profiles of <code>y</code>. </p>
</dd>
<dt>profcor</dt><dd><p><code>signature(x = "NMF", y = "NMF")</code>:
Computes the correlations between the basis profiles of
<code>x</code> and <code>y</code>. </p>
</dd>
<dt>profcor</dt><dd><p><code>signature(x = "NMF", y =
  "missing")</code>: Computes the correlations between the basis
profiles of <code>x</code>. </p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>

# generate two random NMF models
a &lt;- rnmf(3, 100, 20)
b &lt;- rnmf(3, 100, 20)

# Compute auto-correlations
basiscor(a)
profcor(a)
# Compute correlations with b
basiscor(a, b)
profcor(a, b)

# try to recover the underlying NMF model 'a' from noisy data
res &lt;- nmf(fitted(a) + rmatrix(a), 3)

# Compute correlations with the true model
basiscor(a, res)
profcor(a, res)

# Compute correlations with a random compatible matrix
W &lt;- rmatrix(basis(a))
basiscor(a, W)
identical(basiscor(a, W), basiscor(W, a))

H &lt;- rmatrix(coef(a))
profcor(a, H)
identical(profcor(a, H), profcor(H, a))
</code></pre>

<hr>
<h2 id='basisnames'>Dimension names for NMF objects</h2><span id='topic+basisnames'></span><span id='topic+basisnames+3C-'></span><span id='topic+basisnames+3C-+2CANY-method'></span><span id='topic+basisnames+2CANY-method'></span><span id='topic+basisnames+3C--methods'></span><span id='topic+basisnames-methods'></span><span id='topic+dimnames-NMF'></span><span id='topic+dimnames+3C-+2CNMF-method'></span><span id='topic+dimnames+2CNMF-method'></span>

<h3>Description</h3>

<p>The methods <code>dimnames</code>, <code>rownames</code>,
<code>colnames</code> and <code>basisnames</code> and their
respective replacement form allow to get and set the
dimension names of the matrix factors in a NMF model.
</p>
<p><code>dimnames</code> returns all the dimension names in a
single list. Its replacement form <code>dimnames&lt;-</code>
allows to set all dimension names at once.
</p>
<p><code>rownames</code>, <code>colnames</code> and <code>basisnames</code>
provide separate access to each of these dimension names
respectively. Their respective replacement form allow to
set each dimension names separately.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  basisnames(x, ...)

  basisnames(x, ...)&lt;-value

  ## S4 method for signature 'NMF'
dimnames(x)

  ## S4 replacement method for signature 'NMF'
dimnames(x)&lt;-value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="basisnames_+3A_x">x</code></td>
<td>
<p>an object with suitable <code>basis</code> and
<code>coef</code> methods, such as an object that inherit from
<code><a href="#topic+NMF-class">NMF</a></code>.</p>
</td></tr>
<tr><td><code id="basisnames_+3A_...">...</code></td>
<td>
<p>extra argument to allow extension.</p>
</td></tr>
<tr><td><code id="basisnames_+3A_value">value</code></td>
<td>
<p>a character vector, or <code>NULL</code> or, in
the case of <code>dimnames&lt;-</code>, a list 2 or 3-length list
of character vectors.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>basisnames</code> is a new S4 generic
defined in the package NMF, that returns the names of the
basis components of an object. Its default method should
work for any object, that has a suitable <code>basis</code>
method defined for its class.
</p>
<p>The method <code>dimnames</code> is implemented for the base
generic <code><a href="base.html#topic+dimnames">dimnames</a></code>, which make the base
function <code><a href="base.html#topic+rownames">rownames</a></code> and
<code><a href="base.html#topic+colnames">colnames</a></code> work directly.
</p>
<p>Overall, these methods behave as their equivalent on
<code>matrix</code> objects. The function <code>basisnames&lt;-</code>
ensures that the dimension names are handled in a
consistent way on both factors, enforcing the names on
both matrix factors simultaneously.
</p>
<p>The function <code>basisnames&lt;-</code> is a new S4 generic
defined in the package NMF, that sets the names of the
basis components of an object. Its default method should
work for any object, that has suitable <code>basis&lt;-</code> and
<code>coef&lt;-</code> methods method defined for its class.
</p>


<h3>Methods</h3>


<dl>
<dt>basisnames</dt><dd><p><code>signature(x = "ANY")</code>: Default
method which returns the column names of the basis matrix
extracted from <code>x</code>, using the <code>basis</code> method.
</p>
<p>For NMF objects these also correspond to the row names of
the coefficient matrix. </p>
</dd>
<dt>basisnames&lt;-</dt><dd><p><code>signature(x = "ANY")</code>: Default
method which sets, respectively, the row and the column
names of the basis matrix and coefficient matrix of
<code>x</code> to <code>value</code>. </p>
</dd>
<dt>dimnames</dt><dd><p><code>signature(x = "NMF")</code>: Returns the
dimension names of the NMF model <code>x</code>.
</p>
<p>It returns either NULL if no dimnames are set on the
object, or a 3-length list containing the row names of
the basis matrix, the column names of the mixture
coefficient matrix, and the column names of the basis
matrix (i.e. the names of the basis components). </p>
</dd>
<dt>dimnames&lt;-</dt><dd><p><code>signature(x = "NMF")</code>: sets the
dimension names of the NMF model <code>x</code>.
</p>
<p><code>value</code> can be <code>NULL</code> which resets all
dimension names, or a 1, 2 or 3-length list providing
names at least for the rows of the basis matrix.
</p>
<p>The optional second element of <code>value</code> (NULL if
absent) is used to set the column names of the
coefficient matrix. The optional third element of
<code>value</code> (NULL if absent) is used to set both the
column names of the basis matrix and the row names of the
coefficient matrix. </p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>

# create a random NMF object
a &lt;- rnmf(2, 5, 3)

# set dimensions
dims &lt;- list( features=paste('f', 1:nrow(a), sep='')
				, samples=paste('s', 1:ncol(a), sep='')
				, basis=paste('b', 1:nbasis(a), sep='') )
dimnames(a) &lt;- dims
dimnames(a)
basis(a)
coef(a)

# access the dimensions separately
rownames(a)
colnames(a)
basisnames(a)

# set only the first dimension (rows of basis): the other two dimnames are set to NULL
dimnames(a) &lt;- dims[1]
dimnames(a)
basis(a)
coef(a)

# set only the two first dimensions (rows and columns of basis and coef respectively):
# the basisnames are set to NULL
dimnames(a) &lt;- dims[1:2]
dimnames(a)
basis(a)

# reset the dimensions
dimnames(a) &lt;- NULL
dimnames(a)
basis(a)
coef(a)

# set each dimensions separately
rownames(a) &lt;- paste('X', 1:nrow(a), sep='') # only affect rows of basis
basis(a)

colnames(a) &lt;- paste('Y', 1:ncol(a), sep='') # only affect columns of coef
coef(a)

basisnames(a) &lt;- paste('Z', 1:nbasis(a), sep='') # affect both basis and coef matrices
basis(a)
coef(a)
</code></pre>

<hr>
<h2 id='bioc-NMF'>Specific NMF Layer for Bioconductor</h2><span id='topic+.atrack+2CExpressionSet-method'></span><span id='topic+bioc-NMF'></span><span id='topic+featureNames+2CNMFfitX-method'></span><span id='topic+featureNames+3C-+2CNMF-method'></span><span id='topic+featureNames+2CNMF-method'></span><span id='topic+metagenes'></span><span id='topic+metagenes+3C-'></span><span id='topic+metaprofiles'></span><span id='topic+metaprofiles+3C-'></span><span id='topic+nmeta'></span><span id='topic+nmf+2CExpressionSet+2CANY+2CANY-method'></span><span id='topic+nmf+2Cmatrix+2CExpressionSet+2CANY-method'></span><span id='topic+nmfModel+2CANY+2CExpressionSet-method'></span><span id='topic+nmfModel+2CExpressionSet+2CANY-method'></span><span id='topic+nneg+2CExpressionSet-method'></span><span id='topic+rnmf+2CANY+2CExpressionSet-method'></span><span id='topic+rposneg+2CExpressionSet-method'></span><span id='topic+run+2CNMFStrategy+2CExpressionSet+2CANY-method'></span><span id='topic+sampleNames+3C-+2CNMF+2CANY-method'></span><span id='topic+sampleNames+2CNMFfitX-method'></span><span id='topic+sampleNames+2CNMF-method'></span><span id='topic+seed+2CExpressionSet+2CANY+2CANY-method'></span>

<h3>Description</h3>

<p>The package NMF provides an optional layer for working
with common objects and functions defined in the
Bioconductor platform.
</p>


<h3>Details</h3>

<p>It provides: </p>
 <ul>
<li><p> computation functions that
support <code>ExpressionSet</code> objects as inputs. </p>
</li>
<li>
<p>aliases and methods for generic functions defined and
widely used by Bioconductor base packages. </p>
</li>
<li>
<p>specialised visualisation methods that adapt the titles
and legend using bioinformatics terminology. </p>
</li>
<li>
<p>functions to link the results with annotations, etc... </p>
</li></ul>


<hr>
<h2 id='bterms+26lt+3B-'>Fixed Terms in NMF Models</h2><span id='topic+bterms+3C-'></span><span id='topic+bterms+3C--methods'></span><span id='topic+bterms+3C-+2CNMFstd-method'></span><span id='topic+cterms+3C-'></span><span id='topic+cterms+3C--methods'></span><span id='topic+cterms+3C-+2CNMFstd-method'></span>

<h3>Description</h3>

<p>These functions are for internal use and should not be
called by the end-user.
</p>
<p><code>cterms&lt;-</code> sets fixed coefficient terms or indexes
and should only be called on a newly created NMF object,
i.e. in the constructor/factory generic
<code><a href="#topic+nmfModel">nmfModel</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  bterms(object)&lt;-value

  cterms(object)&lt;-value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bterms+2B26lt+2B3B-_+3A_object">object</code></td>
<td>
<p>NMF object to be updated.</p>
</td></tr>
<tr><td><code id="bterms+2B26lt+2B3B-_+3A_value">value</code></td>
<td>
<p>specification of the replacement value for
fixed-terms.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>They use <code><a href="stats.html#topic+model.matrix">model.matrix</a>(~ -1 + ., data=value)</code>
to generate suitable term matrices.
</p>


<h3>Methods</h3>


<dl>
<dt>bterms&lt;-</dt><dd><p><code>signature(object = "NMFstd")</code>:
Default method tries to coerce <code>value</code> into a
<code>data.frame</code> with <code><a href="base.html#topic+as.data.frame">as.data.frame</a></code>. </p>
</dd>
<dt>cterms&lt;-</dt><dd><p><code>signature(object = "NMFstd")</code>:
Default method tries to coerce <code>value</code> into a
<code>data.frame</code> with <code><a href="base.html#topic+as.data.frame">as.data.frame</a></code>. </p>
</dd>
</dl>


<hr>
<h2 id='c+2CNMF-method'>Concatenating NMF Models</h2><span id='topic+c+2CNMF-method'></span>

<h3>Description</h3>

<p>Binds compatible matrices and NMF models together.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S4 method for signature 'NMF'
c(x, ..., margin = 3, recursive = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="c+2B2CNMF-method_+3A_x">x</code></td>
<td>
<p>an NMF model</p>
</td></tr>
<tr><td><code id="c+2B2CNMF-method_+3A_...">...</code></td>
<td>
<p>other objects to concatenate. Currently only
two objects at a time can be concatenated (i.e. <code>x</code>
and <code>..1</code>).</p>
</td></tr>
<tr><td><code id="c+2B2CNMF-method_+3A_margin">margin</code></td>
<td>
<p>integer that indicates the margin along
which to concatenate (only used when <code>..1</code> is a
matrix): </p>
 <dl>
<dt>1L</dt><dd></dd> <dt>2L</dt><dd></dd> <dt>3L</dt><dd></dd>
<dt>4L</dt><dd></dd> </dl>
<p> If missing the margin is heuristically
determined by looking at common dimensions between the
objects.</p>
</td></tr>
<tr><td><code id="c+2B2CNMF-method_+3A_recursive">recursive</code></td>
<td>
<p>logical.  If <code>recursive = TRUE</code>,
the function recursively descends through lists (and
pairlists) combining all their elements into a vector.</p>
</td></tr>
</table>

<hr>
<h2 id='canFit'>Testing Compatibility of Algorithm and Models</h2><span id='topic+canFit'></span><span id='topic+canFit+2Ccharacter+2CANY-method'></span><span id='topic+canFit-methods'></span><span id='topic+canFit+2CNMFStrategy+2Ccharacter-method'></span><span id='topic+canFit+2CNMFStrategy+2CNMF-method'></span>

<h3>Description</h3>

<p><code>canFit</code> is an S4 generic that tests if an algorithm
can fit a particular model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  canFit(x, y, ...)

  ## S4 method for signature 'NMFStrategy,character'
canFit(x, y,
    exact = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="canFit_+3A_x">x</code></td>
<td>
<p>an object that describes an algorithm</p>
</td></tr>
<tr><td><code id="canFit_+3A_y">y</code></td>
<td>
<p>an object that describes a model</p>
</td></tr>
<tr><td><code id="canFit_+3A_...">...</code></td>
<td>
<p>extra arguments to allow extension</p>
</td></tr>
<tr><td><code id="canFit_+3A_exact">exact</code></td>
<td>
<p>for logical that indicates if an algorithm
is considered able to fit only the models that it
explicitly declares (<code>TRUE</code>), or if it should be
considered able to also fit models that extend models
that it explicitly fits.</p>
</td></tr>
</table>


<h3>Methods</h3>


<dl>
<dt>canFit</dt><dd><p><code>signature(x = "NMFStrategy", y =
  "character")</code>: Tells if an NMF algorithm can fit a given
class of NMF models </p>
</dd>
<dt>canFit</dt><dd><p><code>signature(x = "NMFStrategy", y =
  "NMF")</code>: Tells if an NMF algorithm can fit the same class
of models as <code>y</code> </p>
</dd>
<dt>canFit</dt><dd><p><code>signature(x = "character", y =
  "ANY")</code>: Tells if a registered NMF algorithm can fit a
given NMF model </p>
</dd>
</dl>



<h3>See Also</h3>

<p>Other regalgo: <code><a href="#topic+nmfAlgorithm">nmfAlgorithm</a></code>
</p>

<hr>
<h2 id='ccBreaks'>Generate Break Intervals from Numeric Variables</h2><span id='topic+ccBreaks'></span>

<h3>Description</h3>

<p>Implementation is borrowed from the R core function
<code><a href="base.html#topic+cut.default">cut.default</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ccBreaks(x, breaks)
</code></pre>

<hr>
<h2 id='ccPalette'>Builds a Color Palette from Compact Color Specification</h2><span id='topic+ccPalette'></span>

<h3>Description</h3>

<p>Builds a Color Palette from Compact Color Specification
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ccPalette(x, n = NA, verbose = FALSE)
</code></pre>

<hr>
<h2 id='ccRamp'>Builds a Color Ramp from Compact Color Specification</h2><span id='topic+ccRamp'></span>

<h3>Description</h3>

<p>Builds a Color Ramp from Compact Color Specification
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ccRamp(x, n = NA, ...)
</code></pre>

<hr>
<h2 id='ccSpec'>Extract Colour Palette Specification</h2><span id='topic+ccSpec'></span>

<h3>Description</h3>

<p>Extract Colour Palette Specification
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ccSpec(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ccSpec_+3A_x">x</code></td>
<td>
<p>character string that specify a colour palette.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with elements: palette, n and rev
</p>

<hr>
<h2 id='checkErrors'>Error Checks in NMF Runs</h2><span id='topic+checkErrors'></span>

<h3>Description</h3>

<p>Auxiliary function for internal error checks in nmf
results.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  checkErrors(object, element = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="checkErrors_+3A_object">object</code></td>
<td>
<p>a list of lists</p>
</td></tr>
<tr><td><code id="checkErrors_+3A_element">element</code></td>
<td>
<p>name of an element of the inner lists</p>
</td></tr>
</table>

<hr>
<h2 id='cluster_mat'>Cluster Matrix Rows in Annotated Heatmaps</h2><span id='topic+cluster_mat'></span>

<h3>Description</h3>

<p>Cluster Matrix Rows in Annotated Heatmaps
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  cluster_mat(mat, param, distfun, hclustfun, reorderfun,
    na.rm = TRUE, subset = NULL, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cluster_mat_+3A_mat">mat</code></td>
<td>
<p>original input matrix that has already been
appropriately subset in the caller function
(<code>aheatmap</code>)</p>
</td></tr>
<tr><td><code id="cluster_mat_+3A_param">param</code></td>
<td>
<p>clustering specifications</p>
</td></tr>
<tr><td><code id="cluster_mat_+3A_distfun">distfun</code></td>
<td>
<p>Default distance method/function</p>
</td></tr>
<tr><td><code id="cluster_mat_+3A_hclustfun">hclustfun</code></td>
<td>
<p>Default clustering (linkage)
method/function</p>
</td></tr>
<tr><td><code id="cluster_mat_+3A_reorderfun">reorderfun</code></td>
<td>
<p>Default reordering function</p>
</td></tr>
<tr><td><code id="cluster_mat_+3A_na.rm">na.rm</code></td>
<td>
<p>Logical that specifies if NA values should
be removed</p>
</td></tr>
<tr><td><code id="cluster_mat_+3A_subset">subset</code></td>
<td>
<p>index (integer) vector specifying the
subset indexes used to subset mat. This is required to be
able to return the original indexes.</p>
</td></tr>
</table>

<hr>
<h2 id='compare-NMF'>Comparing Results from Different NMF Runs</h2><span id='topic+compare+2Clist-method'></span><span id='topic+compare-NMF'></span><span id='topic+compare+2CNMFfit-method'></span><span id='topic+consensusmap+2Clist-method'></span><span id='topic+consensusmap+2CNMF.rank-method'></span><span id='topic+plot+2CNMFList+2Cmissing-method'></span><span id='topic+summary+2CNMFList-method'></span>

<h3>Description</h3>

<p>The functions documented here allow to compare the fits
computed in different NMF runs. The fits do not need to
be from the same algorithm, nor have the same dimension.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S4 method for signature 'NMFfit'
compare(object, ...)

  ## S4 method for signature 'list'
compare(object, ...)

  ## S4 method for signature 'NMFList'
summary(object, sort.by = NULL,
    select = NULL, ...)

  ## S4 method for signature 'NMFList,missing'
plot(x, y, skip = -1, ...)

  ## S4 method for signature 'NMF.rank'
consensusmap(object, ...)

  ## S4 method for signature 'list'
consensusmap(object, layout,
    Rowv = FALSE, main = names(object), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compare-NMF_+3A_...">...</code></td>
<td>
<p>extra arguments passed by <code>compare</code> to
<code>summary,NMFList</code> or to the <code>summary</code> method of
each fit.</p>
</td></tr>
<tr><td><code id="compare-NMF_+3A_select">select</code></td>
<td>
<p>the columns to be output in the result
<code>data.frame</code>.  The column are given by their names
(partially matched).  The column names are the names of
the summary measures returned by the <code>summary</code>
methods of the corresponding NMF results.</p>
</td></tr>
<tr><td><code id="compare-NMF_+3A_sort.by">sort.by</code></td>
<td>
<p>the sorting criteria, i.e. a partial match
of a column name, by which the result <code>data.frame</code>
is sorted.  The sorting direction (increasing or
decreasing) is computed internally depending on the
chosen criteria (e.g. decreasing for the cophenetic
coefficient, increasing for the residuals).</p>
</td></tr>
<tr><td><code id="compare-NMF_+3A_x">x</code></td>
<td>
<p>an <code>NMFList</code> object that contains fits from
separate NMF runs.</p>
</td></tr>
<tr><td><code id="compare-NMF_+3A_y">y</code></td>
<td>
<p>missing</p>
</td></tr>
<tr><td><code id="compare-NMF_+3A_layout">layout</code></td>
<td>
<p>specification of the layout. It may be a
single numeric or a numeric couple, to indicate a square
or rectangular layout respectively, that is filled row by
row. It may also be a matrix that is directly passed to
the function <code><a href="graphics.html#topic+layout">layout</a></code> from the
package <code>graphics</code>.</p>
</td></tr>
<tr><td><code id="compare-NMF_+3A_object">object</code></td>
<td>
<p>an object computed using some algorithm, or
that describes an algorithm itself.</p>
</td></tr>
<tr><td><code id="compare-NMF_+3A_skip">skip</code></td>
<td>
<p>an integer that indicates the number of
points to skip/remove from the beginning of the curve. If
<code>skip=1L</code> (default) only the initial residual &ndash;
that is computed before any iteration, is skipped, if
present in the track (it associated with iteration 0).</p>
</td></tr>
<tr><td><code id="compare-NMF_+3A_rowv">Rowv</code></td>
<td>
<p>clustering specification(s) for the rows. It
allows to specify the
distance/clustering/ordering/display parameters to be
used for the <em>rows only</em>. Possible values are:
</p>
 <ul>
<li> <p><code>TRUE</code> or <code>NULL</code> (to be
consistent with <code><a href="stats.html#topic+heatmap">heatmap</a></code>): compute a
dendrogram from hierarchical clustering using the
distance and clustering methods <code>distfun</code> and
<code>hclustfun</code>.
</p>
</li>
<li> <p><code>NA</code>: disable any ordering. In this case, and
if not otherwise specified with argument
<code>revC=FALSE</code>, the heatmap shows the input matrix
with the rows in their original order, with the first row
on top to the last row at the bottom. Note that this
differ from the behaviour or <code><a href="stats.html#topic+heatmap">heatmap</a></code>, but
seemed to be a more sensible choice when vizualizing a
matrix without reordering.
</p>
</li>
<li><p> an integer vector of length the number of rows of
the input matrix (<code>nrow(x)</code>), that specifies the row
order. As in the case <code>Rowv=NA</code>, the ordered matrix
is shown first row on top, last row at the bottom.
</p>
</li>
<li><p> a character vector or a list specifying values to
use instead of arguments <code>distfun</code>, <code>hclustfun</code>
and <code>reorderfun</code> when clustering the rows (see the
respective argument descriptions for a list of accepted
values). If <code>Rowv</code> has no names, then the first
element is used for <code>distfun</code>, the second (if
present) is used for <code>hclustfun</code>, and the third (if
present) is used for <code>reorderfun</code>.
</p>
</li>
<li><p> a numeric vector of weights, of length the number
of rows of the input matrix, used to reorder the
internally computed dendrogram <code>d</code> by
<code>reorderfun(d, Rowv)</code>.
</p>
</li>
<li> <p><code>FALSE</code>: the dendrogram <em>is</em> computed
using methods <code>distfun</code>, <code>hclustfun</code>, and
<code>reorderfun</code> but is not shown.
</p>
</li>
<li><p> a single integer that specifies how many subtrees
(i.e. clusters) from the computed dendrogram should have
their root faded out. This can be used to better
highlight the different clusters.
</p>
</li>
<li><p> a single double that specifies how much space is
used by the computed dendrogram. That is that this value
is used in place of <code>treeheight</code>. </p>
</li></ul>
</td></tr>
<tr><td><code id="compare-NMF_+3A_main">main</code></td>
<td>
<p>Main title as a character string or a grob.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The methods <code>compare</code> enables to compare multiple
NMF fits either passed as arguments or as a list of fits.
These methods eventually call the method
<code>summary,NMFList</code>, so that all its arguments can be
passed <strong>named</strong> in <code>...</code>.
</p>


<h3>Methods</h3>


<dl>
<dt>compare</dt><dd><p><code>signature(object = "NMFfit")</code>:
Compare multiple NMF fits passed as arguments. </p>
</dd>
<dt>compare</dt><dd><p><code>signature(object = "list")</code>:
Compares multiple NMF fits passed as a standard list. </p>
</dd>
<dt>consensusmap</dt><dd><p><code>signature(object =
  "NMF.rank")</code>: Draw a single plot with a heatmap of the
consensus matrix obtained for each value of the rank, in
the range tested with <code><a href="#topic+nmfEstimateRank">nmfEstimateRank</a></code>. </p>
</dd>
<dt>consensusmap</dt><dd><p><code>signature(object = "list")</code>:
Draw a single plot with a heatmap of the consensus matrix
of each element in the list <code>object</code>. </p>
</dd>
<dt>plot</dt><dd><p><code>signature(x = "NMFList", y =
  "missing")</code>: <code>plot</code> plot on a single graph the
residuals tracks for each fit in <code>x</code>. See function
<code><a href="#topic+nmf">nmf</a></code> for details on how to enable the
tracking of residuals. </p>
</dd>
<dt>summary</dt><dd><p><code>signature(object = "NMFList")</code>:
<code>summary,NMFList</code> computes summary measures for each
NMF result in the list and return them in rows in a
<code>data.frame</code>. By default all the measures are
included in the result, and <code>NA</code> values are used
where no data is available or the measure does not apply
to the result object (e.g. the dispersion for single' NMF
runs is not meaningful). This method is very useful to
compare and evaluate the performance of different
algorithms. </p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>

#----------
# compare,NMFfit-method
#----------
x &lt;- rmatrix(20,10)
res &lt;- nmf(x, 3)
res2 &lt;- nmf(x, 2, 'lee')

# compare arguments
compare(res, res2, target=x)

#----------
# compare,list-method
#----------
# compare elements of a list
compare(list(res, res2), target=x)
</code></pre>

<hr>
<h2 id='connectivity'>Clustering Connectivity and Consensus Matrices</h2><span id='topic+connectivity'></span><span id='topic+connectivity+2CANY-method'></span><span id='topic+connectivity+2Cfactor-method'></span><span id='topic+connectivity-methods'></span><span id='topic+connectivity+2CNMF-method'></span><span id='topic+connectivity+2Cnumeric-method'></span><span id='topic+consensus'></span><span id='topic+consensus-methods'></span><span id='topic+consensus+2CNMFfitX-method'></span><span id='topic+consensus+2CNMF-method'></span>

<h3>Description</h3>

<p><code>connectivity</code> is an S4 generic that computes the
connectivity matrix based on the clustering of samples
obtained from a model's <code><a href="#topic+predict">predict</a></code> method.
</p>
<p>The consensus matrix has been proposed by <cite>Brunet et
al. (2004)</cite> to help visualising and measuring the
stability of the clusters obtained by NMF approaches. For
objects of class <code>NMF</code> (e.g. results of a single NMF
run, or NMF models), the consensus matrix reduces to the
connectivity matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  connectivity(object, ...)

  ## S4 method for signature 'NMF'
connectivity(object, no.attrib = FALSE)

  consensus(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="connectivity_+3A_object">object</code></td>
<td>
<p>an object with a suitable
<code><a href="#topic+predict">predict</a></code> method.</p>
</td></tr>
<tr><td><code id="connectivity_+3A_...">...</code></td>
<td>
<p>extra arguments to allow extension. They are
passed to <code><a href="#topic+predict">predict</a></code>, except for the
<code>vector</code> and <code>factor</code> methods.</p>
</td></tr>
<tr><td><code id="connectivity_+3A_no.attrib">no.attrib</code></td>
<td>
<p>a logical that indicates if attributes
containing information about the NMF model should be
attached to the result (<code>TRUE</code>) or not
(<code>FALSE</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The connectivity matrix of a given partition of a set of
samples (e.g. given as a cluster membership index) is the
matrix <code class="reqn">C</code> containing only 0 or 1 entries such that:
</p>
<p style="text-align: center;"><code class="reqn">C_{ij} = \left\{\begin{array}{l} 1\mbox{ if sample
  }i\mbox{ belongs to the same cluster as sample }j\\
  0\mbox{ otherwise} \end{array}\right..</code>
</p>



<h3>Value</h3>

<p>a square matrix of dimension the number of samples in the
model, full of 0s or 1s.
</p>


<h3>Methods</h3>


<dl>
<dt>connectivity</dt><dd><p><code>signature(object = "ANY")</code>:
Default method which computes the connectivity matrix
using the result of <code>predict(x, ...)</code> as cluster
membership index. </p>
</dd>
<dt>connectivity</dt><dd><p><code>signature(object = "factor")</code>:
Computes the connectivity matrix using <code>x</code> as
cluster membership index. </p>
</dd>
<dt>connectivity</dt><dd><p><code>signature(object = "numeric")</code>:
Equivalent to <code>connectivity(as.factor(x))</code>. </p>
</dd>
<dt>connectivity</dt><dd><p><code>signature(object = "NMF")</code>:
Computes the connectivity matrix for an NMF model, for
which cluster membership is given by the most
contributing basis component in each sample. See
<code><a href="#topic+predict+2CNMF-method">predict,NMF-method</a></code>. </p>
</dd>
<dt>consensus</dt><dd><p><code>signature(object = "NMFfitX")</code>:
Pure virtual method defined to ensure <code>consensus</code> is
defined for sub-classes of <code>NMFfitX</code>. It throws an
error if called. </p>
</dd>
<dt>consensus</dt><dd><p><code>signature(object = "NMF")</code>: This
method is provided for completeness and is identical to
<code><a href="#topic+connectivity">connectivity</a></code>, and returns the connectivity
matrix, which, in the case of a single NMF model, is also
the consensus matrix. </p>
</dd>
<dt>consensus</dt><dd><p><code>signature(object = "NMFfitX1")</code>:
The result is the matrix stored in slot
&lsquo;consensus&rsquo;. This method returns <code>NULL</code> if
the consensus matrix is empty.
</p>
<p>See <code><a href="#topic+consensus+2CNMFfitX1-method">consensus,NMFfitX1-method</a></code> for more
details. </p>
</dd>
<dt>consensus</dt><dd><p><code>signature(object = "NMFfitXn")</code>:
This method returns <code>NULL</code> on an empty object. The
result is a matrix with several attributes attached, that
are used by plotting functions such as
<code><a href="#topic+consensusmap">consensusmap</a></code> to annotate the plots.
</p>
<p>See <code><a href="#topic+consensus+2CNMFfitXn-method">consensus,NMFfitXn-method</a></code> for more
details. </p>
</dd>
</dl>



<h3>References</h3>

<p>Brunet J, Tamayo P, Golub TR and Mesirov JP (2004).
&quot;Metagenes and molecular pattern discovery using matrix
factorization.&quot; _Proceedings of the National Academy of
Sciences of the United States of America_, *101*(12), pp.
4164-9. ISSN 0027-8424, &lt;URL:
http://dx.doi.org/10.1073/pnas.0308531101&gt;, &lt;URL:
http://www.ncbi.nlm.nih.gov/pubmed/15016911&gt;.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+predict">predict</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

#----------
# connectivity,ANY-method
#----------
# clustering of random data
h &lt;- hclust(dist(rmatrix(10,20)))
connectivity(cutree(h, 2))

#----------
# connectivity,factor-method
#----------
connectivity(gl(2, 4))
</code></pre>

<hr>
<h2 id='consensus+2CNMFfitX1-method'>Returns the consensus matrix computed while performing all NMF runs,
amongst which <code>object</code> was selected as the best fit.</h2><span id='topic+consensus+2CNMFfitX1-method'></span>

<h3>Description</h3>

<p>The result is the matrix stored in slot
&lsquo;consensus&rsquo;. This method returns <code>NULL</code> if
the consensus matrix is empty.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S4 method for signature 'NMFfitX1'
consensus(object, no.attrib = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="consensus+2B2CNMFfitX1-method_+3A_object">object</code></td>
<td>
<p>an object with a suitable
<code><a href="#topic+predict">predict</a></code> method.</p>
</td></tr>
<tr><td><code id="consensus+2B2CNMFfitX1-method_+3A_no.attrib">no.attrib</code></td>
<td>
<p>a logical that indicates if attributes
containing information about the NMF model should be
attached to the result (<code>TRUE</code>) or not
(<code>FALSE</code>).</p>
</td></tr>
</table>

<hr>
<h2 id='consensus+2CNMFfitXn-method'>Computes the consensus matrix of the set of fits stored in <code>object</code>, as
the mean connectivity matrix across runs.</h2><span id='topic+consensus+2CNMFfitXn-method'></span><span id='topic+plot.NMF.consensus'></span>

<h3>Description</h3>

<p>This method returns <code>NULL</code> on an empty object. The
result is a matrix with several attributes attached, that
are used by plotting functions such as
<code><a href="#topic+consensusmap">consensusmap</a></code> to annotate the plots.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S4 method for signature 'NMFfitXn'
consensus(object, ...,
    no.attrib = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="consensus+2B2CNMFfitXn-method_+3A_object">object</code></td>
<td>
<p>an object with a suitable
<code><a href="#topic+predict">predict</a></code> method.</p>
</td></tr>
<tr><td><code id="consensus+2B2CNMFfitXn-method_+3A_...">...</code></td>
<td>
<p>extra arguments to allow extension. They are
passed to <code><a href="#topic+predict">predict</a></code>, except for the
<code>vector</code> and <code>factor</code> methods.</p>
</td></tr>
<tr><td><code id="consensus+2B2CNMFfitXn-method_+3A_no.attrib">no.attrib</code></td>
<td>
<p>a logical that indicates if attributes
containing information about the NMF model should be
attached to the result (<code>TRUE</code>) or not
(<code>FALSE</code>).</p>
</td></tr>
</table>

<hr>
<h2 id='consensushc'>Hierarchical Clustering of a Consensus Matrix</h2><span id='topic+consensushc'></span><span id='topic+consensushc+2Cmatrix-method'></span><span id='topic+consensushc-methods'></span><span id='topic+consensushc+2CNMFfitX-method'></span><span id='topic+consensushc+2CNMF-method'></span>

<h3>Description</h3>

<p>The function <code>consensushc</code> computes the hierarchical
clustering of a consensus matrix, using the matrix itself
as a similarity matrix and average linkage. It is
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  consensushc(object, ...)

  ## S4 method for signature 'matrix'
consensushc(object,
    method = "average", dendrogram = TRUE)

  ## S4 method for signature 'NMFfitX'
consensushc(object,
    what = c("consensus", "fit"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="consensushc_+3A_object">object</code></td>
<td>
<p>a matrix or an <code>NMFfitX</code> object, as
returned by multiple NMF runs.</p>
</td></tr>
<tr><td><code id="consensushc_+3A_...">...</code></td>
<td>
<p>extra arguments passed to next method calls</p>
</td></tr>
<tr><td><code id="consensushc_+3A_method">method</code></td>
<td>
<p>linkage method passed to
<code><a href="stats.html#topic+hclust">hclust</a></code>.</p>
</td></tr>
<tr><td><code id="consensushc_+3A_dendrogram">dendrogram</code></td>
<td>
<p>a logical that specifies if the result
of the hierarchical clustering (en <code>hclust</code> object)
should be converted into a dendrogram. Default value is
<code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="consensushc_+3A_what">what</code></td>
<td>
<p>character string that indicates which matrix
to use in the computation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code>dendrogram</code> or <code>hclust</code>
depending on the value of argument <code>dendrogram</code>.
</p>


<h3>Methods</h3>


<dl>
<dt>consensushc</dt><dd><p><code>signature(object = "matrix")</code>:
Workhorse method for matrices. </p>
</dd>
<dt>consensushc</dt><dd><p><code>signature(object = "NMF")</code>:
Compute the hierarchical clustering on the connectivity
matrix of <code>object</code>. </p>
</dd>
<dt>consensushc</dt><dd><p><code>signature(object = "NMFfitX")</code>:
Compute the hierarchical clustering on the consensus
matrix of <code>object</code>, or on the connectivity matrix of
the best fit in <code>object</code>. </p>
</dd>
</dl>


<hr>
<h2 id='cophcor'>Cophenetic Correlation Coefficient</h2><span id='topic+cophcor'></span><span id='topic+cophcor+2Cmatrix-method'></span><span id='topic+cophcor-methods'></span><span id='topic+cophcor+2CNMFfitX-method'></span>

<h3>Description</h3>

<p>The function <code>cophcor</code> computes the cophenetic
correlation coefficient from consensus matrix
<code>object</code>, e.g. as obtained from multiple NMF runs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  cophcor(object, ...)

  ## S4 method for signature 'matrix'
cophcor(object, linkage = "average")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cophcor_+3A_object">object</code></td>
<td>
<p>an object from which is extracted a
consensus matrix.</p>
</td></tr>
<tr><td><code id="cophcor_+3A_...">...</code></td>
<td>
<p>extra arguments to allow extension and passed
to subsequent calls.</p>
</td></tr>
<tr><td><code id="cophcor_+3A_linkage">linkage</code></td>
<td>
<p>linkage method used in the hierarchical
clustering. It is passed to <code><a href="stats.html#topic+hclust">hclust</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The cophenetic correlation coeffificient is based on the
consensus matrix (i.e. the average of connectivity
matrices) and was proposed by <cite>Brunet et al. (2004)</cite>
to measure the stability of the clusters obtained from
NMF.
</p>
<p>It is defined as the Pearson correlation between the
samples' distances induced by the consensus matrix (seen
as a similarity matrix) and their cophenetic distances
from a hierachical clustering based on these very
distances (by default an average linkage is used). See
<cite>Brunet et al. (2004)</cite>.
</p>


<h3>Methods</h3>


<dl>
<dt>cophcor</dt><dd><p><code>signature(object = "matrix")</code>:
Workhorse method for matrices. </p>
</dd>
<dt>cophcor</dt><dd><p><code>signature(object = "NMFfitX")</code>:
Computes the cophenetic correlation coefficient on the
consensus matrix of <code>object</code>. All arguments in
<code>...</code> are passed to the method
<code>cophcor,matrix</code>. </p>
</dd>
</dl>



<h3>References</h3>

<p>Brunet J, Tamayo P, Golub TR and Mesirov JP (2004).
&quot;Metagenes and molecular pattern discovery using matrix
factorization.&quot; _Proceedings of the National Academy of
Sciences of the United States of America_, *101*(12), pp.
4164-9. ISSN 0027-8424, &lt;URL:
http://dx.doi.org/10.1073/pnas.0308531101&gt;, &lt;URL:
http://www.ncbi.nlm.nih.gov/pubmed/15016911&gt;.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+cophenetic">cophenetic</a></code>
</p>

<hr>
<h2 id='cutdendro'>Fade Out the Upper Branches from a Dendrogram</h2><span id='topic+cutdendro'></span>

<h3>Description</h3>

<p>Fade Out the Upper Branches from a Dendrogram
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  cutdendro(x, n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cutdendro_+3A_x">x</code></td>
<td>
<p>a dendrogram</p>
</td></tr>
<tr><td><code id="cutdendro_+3A_n">n</code></td>
<td>
<p>the number of groups</p>
</td></tr>
</table>

<hr>
<h2 id='deviance'>Distances and Objective Functions</h2><span id='topic+deviance'></span><span id='topic+deviance-methods'></span><span id='topic+deviance+2CNMFfit-method'></span><span id='topic+deviance+2CNMFfitX-method'></span><span id='topic+deviance+2CNMF-method'></span><span id='topic+deviance+2CNMFStrategy-method'></span><span id='topic+nmfDistance'></span>

<h3>Description</h3>

<p>The NMF package defines methods for the generic
<code>deviance</code> from the package <code>stats</code>, to compute
approximation errors between NMF models and matrices,
using a variety of objective functions.
</p>
<p><code>nmfDistance</code> returns a function that computes the
distance between an NMF model and a compatible matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  deviance(object, ...)

  ## S4 method for signature 'NMF'
deviance(object, y,
    method = c("", "KL", "euclidean"), ...)

  nmfDistance(method = c("", "KL", "euclidean"))

  ## S4 method for signature 'NMFfit'
deviance(object, y, method, ...)

  ## S4 method for signature 'NMFStrategy'
deviance(object, x, y, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="deviance_+3A_y">y</code></td>
<td>
<p>a matrix compatible with the NMF model
<code>object</code>, i.e. <code>y</code> must have the same dimension
as <code>fitted(object)</code>.</p>
</td></tr>
<tr><td><code id="deviance_+3A_method">method</code></td>
<td>
<p>a character string or a function with
signature <code>(x="NMF", y="matrix", ...)</code> that
implements a distance measure between an NMF model
<code>x</code> and a target matrix <code>y</code>, i.e. an objective
function to use to compute the deviance. In
<code>deviance</code>, it is passed to <code>nmfDistance</code> to
get the function that effectively computes the deviance.</p>
</td></tr>
<tr><td><code id="deviance_+3A_...">...</code></td>
<td>
<p>extra parameters passed to the objective
function.</p>
</td></tr>
<tr><td><code id="deviance_+3A_x">x</code></td>
<td>
<p>an NMF model that estimates <code>y</code>.</p>
</td></tr>
<tr><td><code id="deviance_+3A_object">object</code></td>
<td>
<p>an object for which the deviance is
desired.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>deviance</code> returns a nonnegative numerical value
</p>
<p><code>nmfDistance</code> returns a function with least two
arguments: an NMF model and a matrix.
</p>


<h3>Methods</h3>


<dl>
<dt>deviance</dt><dd><p><code>signature(object = "NMF")</code>:
Computes the distance between a matrix and the estimate
of an <code>NMF</code> model. </p>
</dd>
<dt>deviance</dt><dd><p><code>signature(object = "NMFfit")</code>:
Returns the deviance of a fitted NMF model.
</p>
<p>This method returns the final residual value if the
target matrix <code>y</code> is not supplied, or the
approximation error between the fitted NMF model stored
in <code>object</code> and <code>y</code>. In this case, the
computation is performed using the objective function
<code>method</code> if not missing, or the objective of the
algorithm that fitted the model (stored in slot
<code>'distance'</code>).
</p>
<p>If not computed by the NMF algorithm itself, the value is
automatically computed at the end of the fitting process
by the function <code><a href="#topic+nmf">nmf</a></code>, using the objective
function associated with the NMF algorithm, so that it
should always be available. </p>
</dd>
<dt>deviance</dt><dd><p><code>signature(object = "NMFfitX")</code>:
Returns the deviance achieved by the best fit object,
i.e. the lowest deviance achieved across all NMF runs. </p>
</dd>
<dt>deviance</dt><dd><p><code>signature(object = "NMFStrategy")</code>:
Computes the value of the objective function between the
estimate <code>x</code> and the target <code>y</code>. </p>
</dd>
</dl>



<h3>See Also</h3>

<p>Other stats: <code><a href="#topic+deviance+2CNMF-method">deviance,NMF-method</a></code>,
<code><a href="#topic+hasTrack">hasTrack</a></code>, <code><a href="#topic+residuals">residuals</a></code>,
<code><a href="#topic+residuals+3C-">residuals&lt;-</a></code>, <code><a href="#topic+trackError">trackError</a></code>
</p>

<hr>
<h2 id='dispersion'>Dispersion of a Matrix</h2><span id='topic+dispersion'></span><span id='topic+dispersion+2Cmatrix-method'></span><span id='topic+dispersion-methods'></span><span id='topic+dispersion+2CNMFfitX-method'></span>

<h3>Description</h3>

<p>Computes the dispersion coefficient of a &ndash; consensus &ndash;
matrix <code>object</code>, generally obtained from multiple
NMF runs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  dispersion(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dispersion_+3A_object">object</code></td>
<td>
<p>an object from which the dispersion is
computed</p>
</td></tr>
<tr><td><code id="dispersion_+3A_...">...</code></td>
<td>
<p>extra arguments to allow extension</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The dispersion coefficient is based on the consensus
matrix (i.e. the average of connectivity matrices) and
was proposed by <cite>Kim et al. (2007)</cite> to measure the
reproducibility of the clusters obtained from NMF.
</p>
<p>It is defined as: </p>
<p style="text-align: center;"><code class="reqn">\rho = \sum_{i,j=1}^n 4 (C_{ij} -
  \frac{1}{2})^2 , </code>
</p>
<p> where <code class="reqn">n</code> is the total number of
samples.
</p>
<p>By construction, <code class="reqn">0 \leq \rho \leq 1</code> and <code class="reqn">\rho =
  1</code> only for a perfect consensus matrix, where all entries
0 or 1. A perfect consensus matrix is obtained only when
all the connectivity matrices are the same, meaning that
the algorithm gave the same clusters at each run. See
<cite>Kim et al. (2007)</cite>.
</p>


<h3>Methods</h3>


<dl>
<dt>dispersion</dt><dd><p><code>signature(object = "matrix")</code>:
Workhorse method that computes the dispersion on a given
matrix. </p>
</dd>
<dt>dispersion</dt><dd><p><code>signature(object = "NMFfitX")</code>:
Computes the dispersion on the consensus matrix obtained
from multiple NMF runs. </p>
</dd>
</dl>



<h3>References</h3>

<p>Kim H and Park H (2007). &quot;Sparse non-negative matrix
factorizations via alternating non-negativity-constrained
least squares for microarray data analysis.&quot;
_Bioinformatics (Oxford, England)_, *23*(12), pp.
1495-502. ISSN 1460-2059, &lt;URL:
http://dx.doi.org/10.1093/bioinformatics/btm134&gt;, &lt;URL:
http://www.ncbi.nlm.nih.gov/pubmed/17483501&gt;.
</p>

<hr>
<h2 id='esGolub'>Golub ExpressionSet</h2><span id='topic+esGolub'></span>

<h3>Description</h3>

<p>This data comes originally from the gene expression data
from <cite>Golub et al. (1999)</cite>. The version included in
the package is the one used and referenced in
<cite>Brunet et al. (2004)</cite>. The samples are from 27
patients with acute lymphoblastic leukemia (ALL) and 11
patients with acute myeloid leukemia (AML).
</p>


<h3>Format</h3>

<p>There are 3 covariates listed.
</p>

<ul>
<li><p> Samples: The original sample labels.  </p>
</li>
<li><p> ALL.AML: Whether the
patient had AML or ALL. It is a <code><a href="base.html#topic+factor">factor</a></code> with levels
<code>c('ALL', 'AML')</code>.  </p>
</li>
<li><p> Cell: ALL arises from two different types of
lymphocytes (T-cell and B-cell).  This specifies which for the ALL patients;
There is no such information for the AML samples. It is a
<code><a href="base.html#topic+factor">factor</a></code> with levels <code>c('T-cell', 'B-cell', NA)</code>.
</p>
</li></ul>


<h3>Details</h3>

<p>The samples were assayed using Affymetrix Hgu6800 chips
and the original data on the expression of 7129 genes
(Affymetrix probes) are available on the Broad Institute
web site (see references below).
</p>
<p>The data in <code>esGolub</code> were obtained from the web
page related to the paper from <cite>Brunet et al.
(2004)</cite>, which describes an application of Nonnegative
Matrix Factorization to gene expression clustering. (see
link in section <em>Source</em>).
</p>
<p>They contain the 5,000 most highly varying genes
according to their coefficient of variation, and were
installed in an object of class  <em>ExpressionSet</em>.
</p>


<h3>Source</h3>

<p>Original data from Golub et al.:<br />
<code>http://www-genome.wi.mit.edu/mpr/data_set_ALL_AML.html</code>
</p>


<h3>References</h3>

<p>Golub TR, Slonim DK, Tamayo P, Huard C, Gaasenbeek M,
Mesirov JP, Coller H, Loh ML, Downing JR, Caligiuri Ma,
Bloomfield CD and Lander ES (1999). &quot;Molecular
classification of cancer: class discovery and class
prediction by gene expression monitoring.&quot; _Science (New
York, N.Y.)_, *286*(5439), pp. 531-7. ISSN 0036-8075,
&lt;URL: http://www.ncbi.nlm.nih.gov/pubmed/10521349&gt;.
</p>
<p>Brunet J, Tamayo P, Golub TR and Mesirov JP (2004).
&quot;Metagenes and molecular pattern discovery using matrix
factorization.&quot; _Proceedings of the National Academy of
Sciences of the United States of America_, *101*(12), pp.
4164-9. ISSN 0027-8424, &lt;URL:
http://dx.doi.org/10.1073/pnas.0308531101&gt;, &lt;URL:
http://www.ncbi.nlm.nih.gov/pubmed/15016911&gt;.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# requires package Biobase to be installed
if(requireNamespace("Biobase", quietly=TRUE)){

	data(esGolub)
	esGolub
	## Not run: pData(esGolub)

}
</code></pre>

<hr>
<h2 id='fcnnls'>Fast Combinatorial Nonnegative Least-Square</h2><span id='topic+fcnnls'></span><span id='topic+fcnnls+2CANY+2Cnumeric-method'></span><span id='topic+fcnnls+2Cmatrix+2Cmatrix-method'></span><span id='topic+fcnnls-methods'></span><span id='topic+fcnnls+2Cnumeric+2Cmatrix-method'></span>

<h3>Description</h3>

<p>This function solves the following nonnegative least
square linear problem using normal equations and the fast
combinatorial strategy from <cite>Van Benthem et al.
(2004)</cite>:
</p>
<p style="text-align: center;"><code class="reqn"> \begin{array}{l} \min \|Y - X K\|_F\\ \mbox{s.t. }
  K&gt;=0 \end{array} </code>
</p>

<p>where <code class="reqn">Y</code> and <code class="reqn">X</code> are two real matrices of
dimension <code class="reqn">n \times p</code> and <code class="reqn">n \times r</code> respectively, and <code class="reqn">\|.\|_F</code> is the
Frobenius norm.
</p>
<p>The algorithm is very fast compared to other approaches,
as it is optimised for handling multiple right-hand
sides.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  fcnnls(x, y, ...)

  ## S4 method for signature 'matrix,matrix'
fcnnls(x, y, verbose = FALSE,
    pseudo = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fcnnls_+3A_...">...</code></td>
<td>
<p>extra arguments passed to the internal
function <code>.fcnnls</code>. Currently not used.</p>
</td></tr>
<tr><td><code id="fcnnls_+3A_verbose">verbose</code></td>
<td>
<p>toggle verbosity (default is
<code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="fcnnls_+3A_x">x</code></td>
<td>
<p>the coefficient matrix</p>
</td></tr>
<tr><td><code id="fcnnls_+3A_y">y</code></td>
<td>
<p>the target matrix to be approximated by <code class="reqn">X
  K</code>.</p>
</td></tr>
<tr><td><code id="fcnnls_+3A_pseudo">pseudo</code></td>
<td>
<p>By default (<code>pseudo=FALSE</code>) the
algorithm uses Gaussian elimination to solve the
successive internal linear problems, using the
<code><a href="Matrix.html#topic+solve">solve</a></code> function.  If <code>pseudo=TRUE</code> the
algorithm uses Moore-Penrose generalized
<code><a href="corpcor.html#topic+pseudoinverse">pseudoinverse</a></code> from the
<code>corpcor</code> package instead of <a href="Matrix.html#topic+solve">solve</a>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Within the <code>NMF</code> package, this algorithm is used
internally by the SNMF/R(L) algorithm from <cite>Kim et
al. (2007)</cite> to solve general Nonnegative Matrix
Factorization (NMF) problems, using alternating
nonnegative constrained least-squares. That is by
iteratively and alternatively estimate each matrix
factor.
</p>
<p>The algorithm is an active/passive set method, which
rearrange the right-hand side to reduce the number of
pseudo-inverse calculations. It uses the unconstrained
solution <code class="reqn">K_u</code> obtained from the unconstrained least
squares problem, i.e. <code class="reqn">\min \|Y - X K\|_F^2</code> , so as to determine the initial passive
sets.
</p>
<p>The function <code>fcnnls</code> is provided separately so that
it can be used to solve other types of nonnegative least
squares problem. For faster computation, when multiple
nonnegative least square fits are needed, it is
recommended to directly use the function
<code><a href="#topic+.fcnnls">.fcnnls</a></code>.
</p>
<p>The code of this function is a port from the original
MATLAB code provided by <cite>Kim et al. (2007)</cite>.
</p>


<h3>Value</h3>

<p>A list containing the following components:
</p>
<table>
<tr><td><code>x</code></td>
<td>
<p> the estimated optimal matrix <code class="reqn">K</code>.</p>
</td></tr>
<tr><td><code>fitted</code></td>
<td>
<p> the fitted matrix <code class="reqn">X K</code>.</p>
</td></tr>
<tr><td><code>residuals</code></td>
<td>
<p> the residual matrix <code class="reqn">Y - X K</code>.</p>
</td></tr>
<tr><td><code>deviance</code></td>
<td>
<p> the residual sum of squares between the
fitted matrix <code class="reqn">X K</code> and the target matrix <code class="reqn">Y</code>.
That is the sum of the square residuals.</p>
</td></tr> <tr><td><code>passive</code></td>
<td>

<p>a <code class="reqn">r x p</code> logical matrix containing the passive set,
that is the set of entries in <code class="reqn">K</code> that are not null
(i.e. strictly positive).</p>
</td></tr> <tr><td><code>pseudo</code></td>
<td>
<p> a logical that
is <code>TRUE</code> if the computation was performed using the
pseudoinverse. See argument <code>pseudo</code>.</p>
</td></tr>
</table>


<h3>Methods</h3>


<dl>
<dt>fcnnls</dt><dd><p><code>signature(x = "matrix", y =
  "matrix")</code>: This method wraps a call to the internal
function <code>.fcnnls</code>, and formats the results in a
similar way as other lest-squares methods such as
<code><a href="stats.html#topic+lm">lm</a></code>. </p>
</dd>
<dt>fcnnls</dt><dd><p><code>signature(x = "numeric", y =
  "matrix")</code>: Shortcut for <code>fcnnls(as.matrix(x), y,
  ...)</code>. </p>
</dd>
<dt>fcnnls</dt><dd><p><code>signature(x = "ANY", y = "numeric")</code>:
Shortcut for <code>fcnnls(x, as.matrix(y), ...)</code>. </p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Original MATLAB code : Van Benthem and Keenan
</p>
<p>Adaption of MATLAB code for SNMF/R(L): H. Kim
</p>
<p>Adaptation to the NMF package framework: Renaud Gaujoux
</p>


<h3>References</h3>

<p>Original MATLAB code from Van Benthem and Keenan,
slightly modified by H. Kim:(http://www.cc.gatech.edu/~hpark/software/fcnnls.m)
</p>
<p>Van Benthem M and Keenan MR (2004). &quot;Fast algorithm for
the solution of large-scale non-negativity-constrained
least squares problems.&quot; _Journal of Chemometrics_,
*18*(10), pp. 441-450. ISSN 0886-9383, &lt;URL:
http://dx.doi.org/10.1002/cem.889&gt;, &lt;URL:
http://doi.wiley.com/10.1002/cem.889&gt;.
</p>
<p>Kim H and Park H (2007). &quot;Sparse non-negative matrix
factorizations via alternating non-negativity-constrained
least squares for microarray data analysis.&quot;
_Bioinformatics (Oxford, England)_, *23*(12), pp.
1495-502. ISSN 1460-2059, &lt;URL:
http://dx.doi.org/10.1093/bioinformatics/btm134&gt;, &lt;URL:
http://www.ncbi.nlm.nih.gov/pubmed/17483501&gt;.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+nmf">nmf</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

## Define a random nonnegative matrix matrix
n &lt;- 200; p &lt;- 20; r &lt;- 3
V &lt;- rmatrix(n, p)

## Compute the optimal matrix K for a given X matrix
X &lt;- rmatrix(n, r)
res &lt;- fcnnls(X, V)

## Compute the same thing using the Moore-Penrose generalized pseudoinverse
res &lt;- fcnnls(X, V, pseudo=TRUE)

## It also works in the case of single vectors
y &lt;- runif(n)
res &lt;- fcnnls(X, y)
# or
res &lt;- fcnnls(X[,1], y)
</code></pre>

<hr>
<h2 id='featureScore'>Feature Selection in NMF Models</h2><span id='topic+extractFeatures'></span><span id='topic+extractFeatures+2Cmatrix-method'></span><span id='topic+extractFeatures-methods'></span><span id='topic+extractFeatures+2CNMF-method'></span><span id='topic+featureScore'></span><span id='topic+featureScore+2Cmatrix-method'></span><span id='topic+featureScore-methods'></span><span id='topic+featureScore+2CNMF-method'></span>

<h3>Description</h3>

<p>The function <code>featureScore</code> implements different
methods to computes basis-specificity scores for each
feature in the data.
</p>
<p>The function <code>extractFeatures</code> implements different
methods to select the most basis-specific features of
each basis component.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  featureScore(object, ...)

  ## S4 method for signature 'matrix'
featureScore(object,
    method = c("kim", "max"))

  extractFeatures(object, ...)

  ## S4 method for signature 'matrix'
extractFeatures(object,
    method = c("kim", "max"),
    format = c("list", "combine", "subset"), nodups = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="featureScore_+3A_object">object</code></td>
<td>
<p>an object from which scores/features are
computed/extracted</p>
</td></tr>
<tr><td><code id="featureScore_+3A_...">...</code></td>
<td>
<p>extra arguments to allow extension</p>
</td></tr>
<tr><td><code id="featureScore_+3A_method">method</code></td>
<td>
<p>scoring or selection method. It specifies
the name of one of the method described in sections
<em>Feature scores</em> and <em>Feature selection</em>.
</p>
<p>Additionally for <code>extractFeatures</code>, it may be an
integer vector that indicates the number of top most
contributing features to extract from each column of
<code>object</code>, when ordered in decreasing order, or a
numeric value between 0 and 1 that indicates the minimum
relative basis contribution above which a feature is
selected (i.e. basis contribution threshold). In the case
of a single numeric value (integer or percentage), it is
used for all columns.
</p>
<p>Note that <code>extractFeatures(x, 1)</code> means relative
contribution threshold of 100%, to select the top
contributing features one must explicitly specify an
integer value as in <code>extractFeatures(x, 1L)</code>.
However, if all elements in methods are &gt; 1, they are
automatically treated as if they were integers:
<code>extractFeatures(x, 2)</code> means the top-2 most
contributing features in each component.</p>
</td></tr>
<tr><td><code id="featureScore_+3A_format">format</code></td>
<td>
<p>output format. The following values are
accepted: </p>
 <dl>
<dt>&lsquo;list&rsquo;</dt><dd><p>(default)
returns a list with one element per column in
<code>object</code>, each containing the indexes of the
selected features, as an integer vector. If <code>object</code>
has row names, these are used to name each index vector.
Components for which no feature were selected are
assigned a <code>NA</code> value.</p>
</dd>
<dt>&lsquo;combine&rsquo;</dt><dd><p> returns all indexes in a single
vector. Duplicated indexes are made unique if
<code>nodups=TRUE</code> (default).</p>
</dd>
<dt>&lsquo;subset&rsquo;</dt><dd><p> returns an object of the same
class as <code>object</code>, but subset with the selected
indexes, so that it contains data only from
basis-specific features.</p>
</dd> </dl>
</td></tr>
<tr><td><code id="featureScore_+3A_nodups">nodups</code></td>
<td>
<p>logical that indicates if duplicated
indexes, i.e. features selected on multiple basis
components (which should in theory not happen), should be
only appear once in the result. Only used when
<code>format='combine'</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>One of the properties of Nonnegative Matrix Factorization
is that is tend to produce sparse representation of the
observed data, leading to a natural application to
bi-clustering, that characterises groups of samples by a
small number of features.
</p>
<p>In NMF models, samples are grouped according to the basis
components that contributes the most to each sample, i.e.
the basis components that have the greatest coefficient
in each column of the coefficient matrix (see
<code><a href="#topic+predict+2CNMF-method">predict,NMF-method</a></code>). Each group of samples
is then characterised by a set of features selected based
on basis-specifity scores that are computed on the basis
matrix.
</p>


<h3>Value</h3>

<p><code>featureScore</code> returns a numeric vector of the
length the number of rows in <code>object</code> (i.e. one
score per feature).
</p>
<p><code>extractFeatures</code> returns the selected features as a
list of indexes, a single integer vector or an object of
the same class as <code>object</code> that only contains the
selected features.
</p>


<h3>Methods</h3>


<dl>
<dt>extractFeatures</dt><dd><p><code>signature(object =
  "matrix")</code>: Select features on a given matrix, that
contains the basis component in columns. </p>
</dd>
<dt>extractFeatures</dt><dd><p><code>signature(object = "NMF")</code>:
Select basis-specific features from an NMF model, by
applying the method <code>extractFeatures,matrix</code> to its
basis matrix. </p>
</dd>
<dt>featureScore</dt><dd><p><code>signature(object = "matrix")</code>:
Computes feature scores on a given matrix, that contains
the basis component in columns. </p>
</dd>
<dt>featureScore</dt><dd><p><code>signature(object = "NMF")</code>:
Computes feature scores on the basis matrix of an NMF
model. </p>
</dd>
</dl>



<h3>Feature scores</h3>

<p>The function <code>featureScore</code> can compute
basis-specificity scores using the following methods:
</p>

<dl>
<dt>&lsquo;kim&rsquo;</dt><dd><p> Method defined by <cite>Kim et al. (2007)</cite>.
</p>
<p>The score for feature <code class="reqn">i</code> is defined as: </p>
<p style="text-align: center;"><code class="reqn">S_i =
  1 + \frac{1}{\log_2 k} \sum_{q=1}^k p(i,q) \log_2
  p(i,q)</code>
</p>
<p>,
</p>
<p>where <code class="reqn">p(i,q)</code> is the probability that the <code class="reqn">i</code>-th
feature contributes to basis <code class="reqn">q</code>: </p>
<p style="text-align: center;"><code class="reqn">p(i,q) =
  \frac{W(i,q)}{\sum_{r=1}^k W(i,r)} </code>
</p>

<p>The feature scores are real values within the range
[0,1]. The higher the feature score the more
basis-specific the corresponding feature. </p>
</dd>
<dt>&lsquo;max&rsquo;</dt><dd><p>Method defined by
<cite>Carmona-Saez et al. (2006)</cite>.
</p>
<p>The feature scores are defined as the row maximums. </p>
</dd>
</dl>



<h3>Feature selection</h3>

<p>The function <code>extractFeatures</code> can select features
using the following methods: </p>

<dl>
<dt>&lsquo;kim&rsquo;</dt><dd><p> uses <cite>Kim et al. (2007)</cite> scoring schema
and feature selection method.
</p>
<p>The features are first scored using the function
<code>featureScore</code> with method &lsquo;kim&rsquo;. Then only
the features that fulfil both following criteria are
retained:
</p>
 <ul>
<li><p> score greater than <code class="reqn">\hat{\mu} + 3
  \hat{\sigma}</code>, where <code class="reqn">\hat{\mu}</code> and
<code class="reqn">\hat{\sigma}</code> are the median and the median absolute
deviation (MAD) of the scores respectively;
</p>
</li>
<li><p> the maximum contribution to a basis component is
greater than the median of all contributions (i.e. of all
elements of W). </p>
</li></ul>

</dd>
<dt>&lsquo;max&rsquo;</dt><dd><p> uses the selection method used in
the <code>bioNMF</code> software package and described in
<cite>Carmona-Saez et al. (2006)</cite>.
</p>
<p>For each basis component, the features are first sorted
by decreasing contribution. Then, one selects only the
first consecutive features whose highest contribution in
the basis matrix is effectively on the considered basis.
</p>
</dd>
</dl>



<h3>References</h3>

<p>Kim H and Park H (2007). &quot;Sparse non-negative matrix
factorizations via alternating non-negativity-constrained
least squares for microarray data analysis.&quot;
_Bioinformatics (Oxford, England)_, *23*(12), pp.
1495-502. ISSN 1460-2059, &lt;URL:
http://dx.doi.org/10.1093/bioinformatics/btm134&gt;, &lt;URL:
http://www.ncbi.nlm.nih.gov/pubmed/17483501&gt;.
</p>
<p>Carmona-Saez P, Pascual-Marqui RD, Tirado F, Carazo JM
and Pascual-Montano A (2006). &quot;Biclustering of gene
expression data by Non-smooth Non-negative Matrix
Factorization.&quot; _BMC bioinformatics_, *7*, pp. 78. ISSN
1471-2105, &lt;URL:
http://dx.doi.org/10.1186/1471-2105-7-78&gt;, &lt;URL:
http://www.ncbi.nlm.nih.gov/pubmed/16503973&gt;.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# random NMF model
x &lt;- rnmf(3, 50,20)

# probably no feature is selected
extractFeatures(x)
# extract top 5 for each basis
extractFeatures(x, 5L)
# extract features that have a relative basis contribution above a threshold
extractFeatures(x, 0.5)
# ambiguity?
extractFeatures(x, 1) # means relative contribution above 100%
extractFeatures(x, 1L) # means top contributing feature in each component
</code></pre>

<hr>
<h2 id='fit'>Extracting Fitted Models</h2><span id='topic+fit'></span><span id='topic+fit+3C-'></span><span id='topic+fit+3C--methods'></span><span id='topic+fit-methods'></span><span id='topic+fit+2CNMFfit-method'></span><span id='topic+fit+3C-+2CNMFfit+2CNMF-method'></span><span id='topic+fit+2CNMFfitX1-method'></span><span id='topic+fit+2CNMFfitX-method'></span><span id='topic+fit+2CNMFfitXn-method'></span><span id='topic+minfit'></span><span id='topic+minfit-methods'></span><span id='topic+minfit+2CNMFfit-method'></span><span id='topic+minfit+2CNMFfitX1-method'></span><span id='topic+minfit+2CNMFfitX-method'></span><span id='topic+minfit+2CNMFfitXn-method'></span>

<h3>Description</h3>

<p>The functions <code>fit</code> and <code>minfit</code> are S4
genetics that extract the best model object and the best
fit object respectively, from a collection of models or
from a wrapper object.
</p>
<p><code>fit&lt;-</code> sets the fitted model in a fit object. It is
meant to be called only when developing new NMF
algorithms, e.g. to update the value of the model stored
in the starting point.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  fit(object, ...)

  fit(object)&lt;-value

  minfit(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fit_+3A_object">object</code></td>
<td>
<p>an object fitted by some algorithm, e.g. as
returned by the function <code><a href="#topic+nmf">nmf</a></code>.</p>
</td></tr>
<tr><td><code id="fit_+3A_value">value</code></td>
<td>
<p>replacement value</p>
</td></tr>
<tr><td><code id="fit_+3A_...">...</code></td>
<td>
<p>extra arguments to allow extension</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A fit object differs from a model object in that it
contains data about the fit, such as the initial RNG
settings, the CPU time used, etc..., while a model
object only contains the actual modelling data such as
regression coefficients, loadings, etc...
</p>
<p>That best model is generally defined as the one that
achieves the maximum/minimum some quantitative measure,
amongst all models in a collection.
</p>
<p>In the case of NMF models, the best model is the one that
achieves the best approximation error, according to the
objective function associated with the algorithm that
performed the fit(s).
</p>


<h3>Methods</h3>


<dl>
<dt>fit</dt><dd><p><code>signature(object = "NMFfit")</code>: Returns
the NMF model object stored in slot <code>'fit'</code>. </p>
</dd>
<dt>fit</dt><dd><p><code>signature(object = "NMFfitX")</code>: Returns
the model object that achieves the lowest residual
approximation error across all the runs.
</p>
<p>It is a pure virtual method defined to ensure <code>fit</code>
is defined for sub-classes of <code>NMFfitX</code>, which
throws an error if called. </p>
</dd>
<dt>fit</dt><dd><p><code>signature(object = "NMFfitX1")</code>: Returns
the model object associated with the best fit, amongst
all the runs performed when fitting <code>object</code>.
</p>
<p>Since <code>NMFfitX1</code> objects only hold the best fit,
this method simply returns the NMF model fitted by
<code>object</code> &ndash; that is stored in slot &lsquo;fit&rsquo;. </p>
</dd>
<dt>fit</dt><dd><p><code>signature(object = "NMFfitXn")</code>: Returns
the best NMF fit object amongst all the fits stored in
<code>object</code>, i.e. the fit that achieves the lowest
estimation residuals. </p>
</dd>
<dt>fit&lt;-</dt><dd><p><code>signature(object = "NMFfit", value =
  "NMF")</code>: Updates the NMF model object stored in slot
<code>'fit'</code> with a new value. </p>
</dd>
<dt>minfit</dt><dd><p><code>signature(object = "NMFfit")</code>:
Returns the object its self, since there it is the result
of a single NMF run. </p>
</dd>
<dt>minfit</dt><dd><p><code>signature(object = "NMFfitX")</code>:
Returns the fit object that achieves the lowest residual
approximation error across all the runs.
</p>
<p>It is a pure virtual method defined to ensure
<code>minfit</code> is defined for sub-classes of
<code>NMFfitX</code>, which throws an error if called. </p>
</dd>
<dt>minfit</dt><dd><p><code>signature(object = "NMFfitX1")</code>:
Returns the fit object associated with the best fit,
amongst all the runs performed when fitting
<code>object</code>.
</p>
<p>Since <code>NMFfitX1</code> objects only hold the best fit,
this method simply returns <code>object</code> coerced into an
<code>NMFfit</code> object. </p>
</dd>
<dt>minfit</dt><dd><p><code>signature(object = "NMFfitXn")</code>:
Returns the best NMF model in the list, i.e. the run that
achieved the lower estimation residuals.
</p>
<p>The model is selected based on its <code>deviance</code> value.
</p>
</dd>
</dl>


<hr>
<h2 id='fitted'>Fitted Matrix in NMF Models</h2><span id='topic+fitted'></span><span id='topic+fitted-methods'></span><span id='topic+fitted+2CNMFfit-method'></span><span id='topic+fitted+2CNMF-method'></span><span id='topic+fitted+2CNMFns-method'></span><span id='topic+fitted+2CNMFOffset-method'></span><span id='topic+fitted+2CNMFstd-method'></span>

<h3>Description</h3>

<p>Computes the estimated target matrix based on a given
<em>NMF</em> model. The estimation depends on the
underlying NMF model. For example in the standard model
<code class="reqn">V \equiv W H</code>, the target matrix is
estimated by the matrix product <code class="reqn">W H</code>. In other
models, the estimate may depend on extra
parameters/matrix (cf. Non-smooth NMF in
<code><a href="#topic+NMFns-class">NMFns-class</a></code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  fitted(object, ...)

  ## S4 method for signature 'NMFstd'
fitted(object, W, H, ...)

  ## S4 method for signature 'NMFOffset'
fitted(object, W, H,
    offset = object@offset)

  ## S4 method for signature 'NMFns'
fitted(object, W, H, S, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitted_+3A_object">object</code></td>
<td>
<p>an object that inherit from class
<code>NMF</code></p>
</td></tr>
<tr><td><code id="fitted_+3A_...">...</code></td>
<td>
<p>extra arguments to allow extension</p>
</td></tr>
<tr><td><code id="fitted_+3A_w">W</code></td>
<td>
<p>a matrix to use in the computation as the basis
matrix in place of <code>basis(object)</code>. It must be
compatible with the coefficient matrix used in the
computation (i.e. number of columns in <code>W</code> = number
of rows in <code>H</code>).</p>
</td></tr>
<tr><td><code id="fitted_+3A_h">H</code></td>
<td>
<p>a matrix to use in the computation as the
coefficient matrix in place of <code>coef(object)</code>. It
must be compatible with the basis matrix used in the
computation (i.e. number of rows in <code>H</code> = number of
columns in <code>W</code>).</p>
</td></tr>
<tr><td><code id="fitted_+3A_offset">offset</code></td>
<td>
<p>offset vector</p>
</td></tr>
<tr><td><code id="fitted_+3A_s">S</code></td>
<td>
<p>smoothing matrix to use instead of
<code>smoothing(object)</code> It must be a square matrix
compatible with the basis and coefficient matrices used
in the computation.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is a S4 generic function imported from
<a href="stats.html#topic+fitted">fitted</a> in the package <em>stats</em>. It is
implemented as a pure virtual method for objects of class
<code>NMF</code>, meaning that concrete NMF models must provide
a definition for their corresponding class (i.e.
sub-classes of class <code>NMF</code>). See
<code><a href="#topic+NMF-class">NMF</a></code> for more details.
</p>


<h3>Value</h3>

<p>the target matrix estimate as fitted by the model
<code>object</code>
</p>


<h3>Methods</h3>


<dl>
<dt>fitted</dt><dd><p><code>signature(object = "NMF")</code>: Pure
virtual method for objects of class
<code><a href="#topic+NMF-class">NMF</a></code>, that should be overloaded by
sub-classes, and throws an error if called. </p>
</dd>
<dt>fitted</dt><dd><p><code>signature(object = "NMFstd")</code>:
Compute the target matrix estimate in <em>standard NMF
models</em>.
</p>
<p>The estimate matrix is computed as the product of the two
matrix slots <code>W</code> and <code>H</code>: </p>
<p style="text-align: center;"><code class="reqn">\hat{V} = W
  H</code>
</p>
 </dd>
<dt>fitted</dt><dd><p><code>signature(object = "NMFOffset")</code>:
Computes the target matrix estimate for an NMFOffset
object.
</p>
<p>The estimate is computed as: </p>
<p style="text-align: center;"><code class="reqn"> W H + offset </code>
</p>
 </dd>
<dt>fitted</dt><dd><p><code>signature(object = "NMFns")</code>: Compute
estimate for an NMFns object, according to the Nonsmooth
NMF model (cf. <code><a href="#topic+NMFns-class">NMFns-class</a></code>).
</p>
<p>Extra arguments in <code>...</code> are passed to method
<code>smoothing</code>, and are typically used to pass a value
for <code>theta</code>, which is used to compute the smoothing
matrix instead of the one stored in <code>object</code>. </p>
</dd>
<dt>fitted</dt><dd><p><code>signature(object = "NMFfit")</code>:
Computes and return the estimated target matrix from an
NMF model fitted with function <code><a href="#topic+nmf">nmf</a></code>.
</p>
<p>It is a shortcut for <code>fitted(fit(object), ...)</code>,
dispatching the call to the <code>fitted</code> method of the
actual NMF model. </p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>

# random standard NMF model
x &lt;- rnmf(3, 10, 5)
all.equal(fitted(x), basis(x) %*% coef(x))
</code></pre>

<hr>
<h2 id='getRNG1'>Extracting RNG Data from NMF Objects</h2><span id='topic+.getRNG'></span><span id='topic+getRNG1'></span><span id='topic+getRNG1-methods'></span><span id='topic+getRNG1+2CNMFfitX1-method'></span><span id='topic+getRNG1+2CNMFfitX-method'></span><span id='topic+getRNG1+2CNMFfitXn-method'></span><span id='topic+.getRNG-methods'></span><span id='topic+.getRNG+2CNMFfitXn-method'></span>

<h3>Description</h3>

<p>The <code><a href="#topic+nmf">nmf</a></code> function returns objects that
contain embedded RNG data, that can be used to exactly
reproduce any computation. These data can be extracted
using dedicated methods for the S4 generics
<code><a href="rngtools.html#topic+getRNG">getRNG</a></code> and
<code><a href="rngtools.html#topic+getRNG1">getRNG1</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  getRNG1(object, ...)

  .getRNG(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getRNG1_+3A_object">object</code></td>
<td>
<p>an R object from which RNG settings can be
extracted, e.g. an integer vector containing a suitable
value for <code>.Random.seed</code> or embedded RNG data, e.g.,
in S3/S4 slot <code>rng</code> or <code>rng$noise</code>.</p>
</td></tr>
<tr><td><code id="getRNG1_+3A_...">...</code></td>
<td>
<p>extra arguments to allow extension and passed
to a suitable S4 method <code>.getRNG</code> or
<code>.setRNG</code>.</p>
</td></tr>
</table>


<h3>Methods</h3>


<dl>
<dt>.getRNG</dt><dd><p><code>signature(object = "NMFfitXn")</code>:
Returns the RNG settings used for the best fit.
</p>
<p>This method throws an error if the object is empty. </p>
</dd>
<dt>getRNG1</dt><dd><p><code>signature(object = "NMFfitX")</code>:
Returns the RNG settings used for the first NMF run of
multiple NMF runs. </p>
</dd>
<dt>getRNG1</dt><dd><p><code>signature(object = "NMFfitX1")</code>:
Returns the RNG settings used to compute the first of all
NMF runs, amongst which <code>object</code> was selected as the
best fit. </p>
</dd>
<dt>getRNG1</dt><dd><p><code>signature(object = "NMFfitXn")</code>:
Returns the RNG settings used for the first run.
</p>
<p>This method throws an error if the object is empty. </p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>

# For multiple NMF runs, the RNG settings used for the first run is also stored
V &lt;- rmatrix(20,10)
res &lt;- nmf(V, 3, nrun=3)
# RNG used for the best fit
getRNG(res)
# RNG used for the first of all fits
getRNG1(res)
# they may differ if the best fit is not the first one
rng.equal(res, getRNG1(res))
</code></pre>

<hr>
<h2 id='gfile'>Open a File Graphic Device</h2><span id='topic+gfile'></span>

<h3>Description</h3>

<p>Opens a graphic device depending on the file extension
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  gfile(filename, width, height, ...)
</code></pre>

<hr>
<h2 id='heatmap-NMF'>Heatmaps of NMF Factors</h2><span id='topic+basismap'></span><span id='topic+basismap-methods'></span><span id='topic+basismap+2CNMFfitX-method'></span><span id='topic+basismap+2CNMF-method'></span><span id='topic+coefmap'></span><span id='topic+coefmap-methods'></span><span id='topic+coefmap+2CNMFfitX-method'></span><span id='topic+coefmap+2CNMF-method'></span><span id='topic+consensusmap'></span><span id='topic+consensusmap+2Cmatrix-method'></span><span id='topic+consensusmap-methods'></span><span id='topic+consensusmap+2CNMFfitX-method'></span><span id='topic+consensusmap+2CNMF-method'></span><span id='topic+heatmap-NMF'></span>

<h3>Description</h3>

<p>The NMF package ships an advanced heatmap engine
implemented by the function <code><a href="#topic+aheatmap">aheatmap</a></code>. Some
convenience heatmap functions have been implemented for
NMF models, which redefine default values for some of the
arguments of <code><a href="#topic+aheatmap">aheatmap</a></code>, hence tuning the
output specifically for NMF models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  basismap(object, ...)

  ## S4 method for signature 'NMF'
basismap(object, color = "YlOrRd:50",
    scale = "r1", Rowv = TRUE, Colv = NA,
    subsetRow = FALSE, annRow = NA, annCol = NA,
    tracks = "basis", main = "Basis components",
    info = FALSE, ...)

  coefmap(object, ...)

  ## S4 method for signature 'NMF'
coefmap(object, color = "YlOrRd:50",
    scale = "c1", Rowv = NA, Colv = TRUE, annRow = NA,
    annCol = NA, tracks = "basis",
    main = "Mixture coefficients", info = FALSE, ...)

  consensusmap(object, ...)

  ## S4 method for signature 'NMFfitX'
consensusmap(object, annRow = NA,
    annCol = NA,
    tracks = c("basis:", "consensus:", "silhouette:"),
    main = "Consensus matrix", info = FALSE, ...)

  ## S4 method for signature 'matrix'
consensusmap(object,
    color = "-RdYlBu",
    distfun = function(x) as.dist(1 - x),
    hclustfun = "average", Rowv = TRUE, Colv = "Rowv",
    main = if (is.null(nr) || nr &gt; 1) "Consensus matrix" else "Connectiviy matrix",
    info = FALSE, ...)

  ## S4 method for signature 'NMFfitX'
coefmap(object, Colv = TRUE,
    annRow = NA, annCol = NA,
    tracks = c("basis", "consensus:"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="heatmap-NMF_+3A_object">object</code></td>
<td>
<p>an object from which is extracted NMF
factors or a consensus matrix</p>
</td></tr>
<tr><td><code id="heatmap-NMF_+3A_...">...</code></td>
<td>
<p>extra arguments passed to
<code><a href="#topic+aheatmap">aheatmap</a></code>.</p>
</td></tr>
<tr><td><code id="heatmap-NMF_+3A_subsetrow">subsetRow</code></td>
<td>
<p>Argument that specifies how to filter
the rows that will appear in the heatmap. When
<code>FALSE</code> (default), all rows are used. Besides the
values supported by argument <code>subsetRow</code> of
<code><a href="#topic+aheatmap">aheatmap</a></code>, other possible values are:
</p>
 <ul>
<li> <p><code>TRUE</code>: only the rows that are
basis-specific are used. The default selection method is
from <cite>KimH2007</cite>. This is equivalent to
<code>subsetRow='kim'</code>.
</p>
</li>
<li><p> a single <code>character</code> string or numeric value
that specifies the method to use to select the
basis-specific rows, that should appear in the heatmap
(cf. argument <code>method</code> for function
<code><a href="#topic+extractFeatures">extractFeatures</a></code>).
</p>
<p>Note <code><a href="#topic+extractFeatures">extractFeatures</a></code> is called with
argument <code>nodups=TRUE</code>, so that features that are
selected for multiple components only appear once. </p>
</li></ul>
</td></tr>
<tr><td><code id="heatmap-NMF_+3A_tracks">tracks</code></td>
<td>
<p>Special additional annotation tracks to
highlight associations between basis components and
sample clusters: </p>
 <dl>
<dt>basis</dt><dd><p>matches each row
(resp. column) to the most contributing basis component
in <code>basismap</code> (resp. <code>coefmap</code>). In
<code>basismap</code> (resp. <code>coefmap</code>), adding a track
<code>':basis'</code> to <code>annCol</code> (resp. <code>annRow</code>)
makes the column (resp. row) corresponding to the
component being also highlited using the mathcing
colours.</p>
</dd> </dl>
</td></tr>
<tr><td><code id="heatmap-NMF_+3A_info">info</code></td>
<td>
<p>if <code>TRUE</code> then the name of the algorithm
that fitted the NMF model is displayed at the bottom of
the plot, if available. Other wise it is passed as is to
<code>aheatmap</code>.</p>
</td></tr>
<tr><td><code id="heatmap-NMF_+3A_color">color</code></td>
<td>
<p>colour specification for the heatmap.
Default to palette '-RdYlBu2:100', i.e. reversed palette
'RdYlBu2' (a slight modification of RColorBrewer's
palette 'RdYlBu') with 100 colors. Possible values are:
</p>
 <ul>
<li><p> a character/integer vector of length
greater than 1 that is directly used and assumed to
contain valid R color specifications. </p>
</li>
<li><p> a single
color/integer (between 0 and 8)/other numeric value that
gives the dominant colors. Numeric values are converted
into a pallete by <code>rev(sequential_hcl(2, h = x, l =
  c(50, 95)))</code>. Other values are concatenated with the grey
colour '#F1F1F1'. </p>
</li>
<li><p> one of RColorBrewer's palette
name (see <code><a href="RColorBrewer.html#topic+display.brewer.all">display.brewer.all</a></code>)
, or one of 'RdYlBu2', 'rainbow', 'heat', 'topo',
'terrain', 'cm'. </p>
</li></ul>
<p> When the coluor palette is specified
with a single value, and is negative or preceded a minus
('-'), the reversed palette is used. The number of breaks
can also be specified after a colon (':'). For example,
the default colour palette is specified as
'-RdYlBu2:100'.</p>
</td></tr>
<tr><td><code id="heatmap-NMF_+3A_scale">scale</code></td>
<td>
<p>character indicating how the values should
scaled in either the row direction or the column
direction. Note that the scaling is performed after
row/column clustering, so that it has no effect on the
row/column ordering. Possible values are: </p>
 <ul>
<li>
<p><code>"row"</code>: center and standardize each row separately
to row Z-scores </p>
</li>
<li> <p><code>"column"</code>: center and
standardize each column separately to column Z-scores
</p>
</li>
<li> <p><code>"r1"</code>: scale each row to sum up to one </p>
</li>
<li>
<p><code>"c1"</code>: scale each column to sum up to one </p>
</li>
<li>
<p><code>"none"</code>: no scaling </p>
</li></ul>
</td></tr>
<tr><td><code id="heatmap-NMF_+3A_rowv">Rowv</code></td>
<td>
<p>clustering specification(s) for the rows. It
allows to specify the
distance/clustering/ordering/display parameters to be
used for the <em>rows only</em>. Possible values are:
</p>
 <ul>
<li> <p><code>TRUE</code> or <code>NULL</code> (to be
consistent with <code><a href="stats.html#topic+heatmap">heatmap</a></code>): compute a
dendrogram from hierarchical clustering using the
distance and clustering methods <code>distfun</code> and
<code>hclustfun</code>.
</p>
</li>
<li> <p><code>NA</code>: disable any ordering. In this case, and
if not otherwise specified with argument
<code>revC=FALSE</code>, the heatmap shows the input matrix
with the rows in their original order, with the first row
on top to the last row at the bottom. Note that this
differ from the behaviour or <code><a href="stats.html#topic+heatmap">heatmap</a></code>, but
seemed to be a more sensible choice when vizualizing a
matrix without reordering.
</p>
</li>
<li><p> an integer vector of length the number of rows of
the input matrix (<code>nrow(x)</code>), that specifies the row
order. As in the case <code>Rowv=NA</code>, the ordered matrix
is shown first row on top, last row at the bottom.
</p>
</li>
<li><p> a character vector or a list specifying values to
use instead of arguments <code>distfun</code>, <code>hclustfun</code>
and <code>reorderfun</code> when clustering the rows (see the
respective argument descriptions for a list of accepted
values). If <code>Rowv</code> has no names, then the first
element is used for <code>distfun</code>, the second (if
present) is used for <code>hclustfun</code>, and the third (if
present) is used for <code>reorderfun</code>.
</p>
</li>
<li><p> a numeric vector of weights, of length the number
of rows of the input matrix, used to reorder the
internally computed dendrogram <code>d</code> by
<code>reorderfun(d, Rowv)</code>.
</p>
</li>
<li> <p><code>FALSE</code>: the dendrogram <em>is</em> computed
using methods <code>distfun</code>, <code>hclustfun</code>, and
<code>reorderfun</code> but is not shown.
</p>
</li>
<li><p> a single integer that specifies how many subtrees
(i.e. clusters) from the computed dendrogram should have
their root faded out. This can be used to better
highlight the different clusters.
</p>
</li>
<li><p> a single double that specifies how much space is
used by the computed dendrogram. That is that this value
is used in place of <code>treeheight</code>. </p>
</li></ul>
</td></tr>
<tr><td><code id="heatmap-NMF_+3A_colv">Colv</code></td>
<td>
<p>clustering specification(s) for the columns.
It accepts the same values as argument <code>Rowv</code>
(modulo the expected length for vector specifications),
and allow specifying the
distance/clustering/ordering/display parameters to be
used for the <em>columns only</em>. <code>Colv</code> may also be
set to <code>"Rowv"</code>, in which case the dendrogram or
ordering specifications applied to the rows are also
applied to the columns. Note that this is allowed only
for square input matrices, and that the row ordering is
in this case by default reversed (<code>revC=TRUE</code>) to
obtain the diagonal in the standard way (from top-left to
bottom-right). See argument <code>Rowv</code> for other
possible values.</p>
</td></tr>
<tr><td><code id="heatmap-NMF_+3A_annrow">annRow</code></td>
<td>
<p>specifications of row annotation tracks
displayed as coloured columns on the left of the
heatmaps. The annotation tracks are drawn from left to
right. The same conversion, renaming and colouring rules
as for argument <code>annCol</code> apply.</p>
</td></tr>
<tr><td><code id="heatmap-NMF_+3A_anncol">annCol</code></td>
<td>
<p>specifications of column annotation tracks
displayed as coloured rows on top of the heatmaps. The
annotation tracks are drawn from bottom to top. A single
annotation track can be specified as a single vector;
multiple tracks are specified as a list, a data frame, or
an  <em>ExpressionSet</em> object, in which case the
phenotypic data is used (<code>pData(eset)</code>). Character
or integer vectors are converted and displayed as factors.
Unnamed tracks are internally renamed into <code>Xi</code>,
with i being incremented for each unamed track, across 
both column and row annotation tracks. For each track, if 
no corresponding colour is specified in argument
<code>annColors</code>, a palette or a ramp is automatically
computed and named after the track's name.</p>
</td></tr>
<tr><td><code id="heatmap-NMF_+3A_main">main</code></td>
<td>
<p>Main title as a character string or a grob.</p>
</td></tr>
<tr><td><code id="heatmap-NMF_+3A_distfun">distfun</code></td>
<td>
<p>default distance measure used in
clustering rows and columns. Possible values are:
</p>
 <ul>
<li><p> all the distance methods supported by
<code><a href="stats.html#topic+dist">dist</a></code> (e.g. &quot;euclidean&quot; or &quot;maximum&quot;).
</p>
</li>
<li><p> all correlation methods supported by
<code><a href="stats.html#topic+cor">cor</a></code>, such as <code>"pearson"</code> or
<code>"spearman"</code>. The pairwise distances between
rows/columns are then computed as <code>d &lt;- dist(1 -
  cor(..., method = distfun))</code>.
</p>
<p>One may as well use the string &quot;correlation&quot; which is an
alias for &quot;pearson&quot;.
</p>
</li>
<li><p> an object of class <code>dist</code> such as returned by
<code><a href="stats.html#topic+dist">dist</a></code> or <code><a href="stats.html#topic+as.dist">as.dist</a></code>. </p>
</li></ul>
</td></tr>
<tr><td><code id="heatmap-NMF_+3A_hclustfun">hclustfun</code></td>
<td>
<p>default clustering method used to
cluster rows and columns. Possible values are: </p>

<ul>
<li><p> a method name (a character string) supported by
<code><a href="stats.html#topic+hclust">hclust</a></code> (e.g. <code>'average'</code>). </p>
</li>
<li><p> an
object of class <code>hclust</code> such as returned by
<code><a href="stats.html#topic+hclust">hclust</a></code> </p>
</li>
<li><p> a dendrogram </p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p><strong>IMPORTANT:</strong> although they essentially have the
same set of arguments, their order sometimes differ
between them, as well as from <code><a href="#topic+aheatmap">aheatmap</a></code>. We
therefore strongly recommend to use fully named arguments
when calling these functions.
</p>
<p><code>basimap</code> default values for the following arguments
of <code><a href="#topic+aheatmap">aheatmap</a></code>: </p>
 <ul>
<li><p> the color
palette; </p>
</li>
<li><p> the scaling specification, which by
default scales each row separately so that they sum up to
one (<code>scale='r1'</code>); </p>
</li>
<li><p> the column ordering which
is disabled; </p>
</li>
<li><p> allowing for passing feature
extraction methods in argument <code>subsetRow</code>, that are
passed to <code><a href="#topic+extractFeatures">extractFeatures</a></code>. See argument
description here and therein. </p>
</li>
<li><p> the addition of a
default named annotation track, that shows the dominant
basis component for each row (i.e. each feature).
</p>
<p>This track is specified in argument <code>tracks</code> (see
its argument description). By default, a matching column
annotation track is also displayed, but may be disabled
using <code>tracks=':basis'</code>.
</p>
</li>
<li><p> a suitable title and extra information like the
fitting algorithm, when <code>object</code> is a fitted NMF
model. </p>
</li></ul>

<p><code>coefmap</code> redefines default values for the following
arguments of <code><a href="#topic+aheatmap">aheatmap</a></code>: </p>
 <ul>
<li><p> the
color palette; </p>
</li>
<li><p> the scaling specification, which by
default scales each column separately so that they sum up
to one (<code>scale='c1'</code>); </p>
</li>
<li><p> the row ordering which
is disabled; </p>
</li>
<li><p> the addition of a default annotation
track, that shows the most contributing basis component
for each column (i.e. each sample).
</p>
<p>This track is specified in argument <code>tracks</code> (see
its argument description). By default, a matching row
annotation track is also displayed, but can be disabled
using <code>tracks='basis:'</code>. </p>
</li>
<li><p> a suitable title and
extra information like the fitting algorithm, when
<code>object</code> is a fitted NMF model. </p>
</li></ul>

<p><code>consensusmap</code> redefines default values for the
following arguments of <code><a href="#topic+aheatmap">aheatmap</a></code>: </p>

<ul>
<li><p> the colour palette; </p>
</li>
<li><p> the column ordering which
is set equal to the row ordering, since a consensus
matrix is symmetric; </p>
</li>
<li><p> the distance and linkage
methods used to order the rows (and columns). The default
is to use 1 minus the consensus matrix itself as
distance, and average linkage. </p>
</li>
<li><p> the addition of two
special named annotation tracks, <code>'basis:'</code> and
<code>'consensus:'</code>, that show, for each column (i.e.
each sample), the dominant basis component in the best
fit and the hierarchical clustering of the consensus
matrix respectively (using 1-consensus as distance and
average linkage).
</p>
<p>These tracks are specified in argument <code>tracks</code>,
which behaves as in <code><a href="#topic+basismap">basismap</a></code>.
</p>
</li>
<li><p> a suitable title and extra information like the
type of NMF model or the fitting algorithm, when
<code>object</code> is a fitted NMF model. </p>
</li></ul>



<h3>Methods</h3>


<dl>
<dt>basismap</dt><dd><p><code>signature(object = "NMF")</code>: Plots a
heatmap of the basis matrix of the NMF model
<code>object</code>. This method also works for fitted NMF
models (i.e. <code>NMFfit</code> objects). </p>
</dd>
<dt>basismap</dt><dd><p><code>signature(object = "NMFfitX")</code>:
Plots a heatmap of the basis matrix of the best fit in
<code>object</code>. </p>
</dd>
<dt>coefmap</dt><dd><p><code>signature(object = "NMF")</code>: The
default method for NMF objects has special default values
for some arguments of <code><a href="#topic+aheatmap">aheatmap</a></code> (see
argument description). </p>
</dd>
<dt>coefmap</dt><dd><p><code>signature(object = "NMFfitX")</code>:
Plots a heatmap of the coefficient matrix of the best fit
in <code>object</code>.
</p>
<p>This method adds: </p>
 <ul>
<li><p> an extra special column
annotation track for multi-run NMF fits,
<code>'consensus:'</code>, that shows the consensus cluster
associated to each sample. </p>
</li>
<li><p> a column sorting schema
<code>'consensus'</code> that can be passed to argument
<code>Colv</code> and orders the columns using the hierarchical
clustering of the consensus matrix with average linkage,
as returned by <code><a href="#topic+consensushc">consensushc</a>(object)</code>. This is
also the ordering that is used by default for the heatmap
of the consensus matrix as ploted by
<code><a href="#topic+consensusmap">consensusmap</a></code>. </p>
</li></ul>
 </dd>
<dt>consensusmap</dt><dd><p><code>signature(object = "NMFfitX")</code>:
Plots a heatmap of the consensus matrix obtained when
fitting an NMF model with multiple runs. </p>
</dd>
<dt>consensusmap</dt><dd><p><code>signature(object = "NMF")</code>:
Plots a heatmap of the connectivity matrix of an NMF
model. </p>
</dd>
<dt>consensusmap</dt><dd><p><code>signature(object = "matrix")</code>:
Main method that redefines default values for arguments
of <code><a href="#topic+aheatmap">aheatmap</a></code>. </p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>

#----------
# heatmap-NMF
#----------
## More examples are provided in demo `heatmaps`
## Not run: 
demo(heatmaps)

## End(Not run)
##

# random data with underlying NMF model
v &lt;- syntheticNMF(20, 3, 10)
# estimate a model
x &lt;- nmf(v, 3)

#----------
# basismap
#----------
# show basis matrix
basismap(x)
## Not run: 
# without the default annotation tracks
basismap(x, tracks=NA)

## End(Not run)

#----------
# coefmap
#----------
# coefficient matrix
coefmap(x)
## Not run: 
# without the default annotation tracks
coefmap(x, tracks=NA)

## End(Not run)

#----------
# consensusmap
#----------
## Not run: 
res &lt;- nmf(x, 3, nrun=3)
consensusmap(res)

## End(Not run)
</code></pre>

<hr>
<h2 id='ibterms'>Fixed Terms in NMF Models</h2><span id='topic+bterms'></span><span id='topic+cterms'></span><span id='topic+ibasis'></span><span id='topic+ibterms'></span><span id='topic+ibterms-methods'></span><span id='topic+ibterms+2CNMFfit-method'></span><span id='topic+ibterms+2CNMFfitX-method'></span><span id='topic+ibterms+2CNMF-method'></span><span id='topic+ibterms+2CNMFstd-method'></span><span id='topic+icoef'></span><span id='topic+icterms'></span><span id='topic+icterms-methods'></span><span id='topic+icterms+2CNMFfit-method'></span><span id='topic+icterms+2CNMF-method'></span><span id='topic+icterms+2CNMFstd-method'></span><span id='topic+iterms'></span><span id='topic+nbterms'></span><span id='topic+ncterms'></span><span id='topic+nterms'></span>

<h3>Description</h3>

<p>Formula-based NMF models may contain fixed basis and/or
coefficient terms. The functions documented here provide
access to these data, which are read-only and defined
when the model object is instantiated (e.g., see
<code><a href="#topic+nmfModel+2Cformula+2CANY-method">nmfModel,formula-method</a></code>).
</p>
<p><code>ibterms</code>, <code>icterms</code> and <code>iterms</code>
respectively return the indexes of the fixed basis terms,
the fixed coefficient terms and all fixed terms, within
the basis and/or coefficient matrix of an NMF model.
</p>
<p><code>nterms</code>, <code>nbterms</code>, and <code>ncterms</code> return,
respectively, the number of all fixed terms, fixed basis
terms and fixed coefficient terms in an NMF model. In
particular: i.e. <code>nterms(object) = nbterms(object) +
  ncterms(object)</code>.
</p>
<p><code>bterms</code> and <code>cterms</code> return, respectively, the
primary data for fixed basis and coefficient terms in an
NMF model &ndash; as stored in slots <code>bterms</code> and
<code>cterms</code> . These are factors or numeric vectors
which define fixed basis components, e.g., used for
defining separate offsets for different <em>a priori</em>
groups of samples, or to incorporate/correct for some
known covariate.
</p>
<p><code>ibasis</code> and <code>icoef</code> return, respectively, the
indexes of all latent basis vectors and estimated
coefficients within the basis or coefficient matrix of an
NMF model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ibterms(object, ...)

  icterms(object, ...)

  iterms(object, ...)

  nterms(object)

  nbterms(object)

  ncterms(object)

  bterms(object)

  cterms(object)

  ibasis(object, ...)

  icoef(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ibterms_+3A_object">object</code></td>
<td>
<p>NMF object</p>
</td></tr>
<tr><td><code id="ibterms_+3A_...">...</code></td>
<td>
<p>extra parameters to allow extension (currently
not used)</p>
</td></tr>
</table>


<h3>Methods</h3>


<dl>
<dt>ibterms</dt><dd><p><code>signature(object = "NMF")</code>: Default
pure virtual method that ensure a method is defined for
concrete NMF model classes. </p>
</dd>
<dt>ibterms</dt><dd><p><code>signature(object = "NMFstd")</code>:
Method for standard NMF models, which returns the integer
vector that is stored in slot <code>ibterms</code> when a
formula-based NMF model is instantiated. </p>
</dd>
<dt>ibterms</dt><dd><p><code>signature(object = "NMFfit")</code>:
Method for single NMF fit objects, which returns the
indexes of fixed basis terms from the fitted model. </p>
</dd>
<dt>ibterms</dt><dd><p><code>signature(object = "NMFfitX")</code>:
Method for multiple NMF fit objects, which returns the
indexes of fixed basis terms from the best fitted model.
</p>
</dd>
<dt>icterms</dt><dd><p><code>signature(object = "NMF")</code>: Default
pure virtual method that ensure a method is defined for
concrete NMF model classes. </p>
</dd>
<dt>icterms</dt><dd><p><code>signature(object = "NMFstd")</code>:
Method for standard NMF models, which returns the integer
vector that is stored in slot <code>icterms</code> when a
formula-based NMF model is instantiated. </p>
</dd>
<dt>icterms</dt><dd><p><code>signature(object = "NMFfit")</code>:
Method for single NMF fit objects, which returns the
indexes of fixed coefficient terms from the fitted model.
</p>
</dd>
</dl>


<hr>
<h2 id='is.nmf'>Testing NMF Objects</h2><span id='topic+hasBasis'></span><span id='topic+hasCoef'></span><span id='topic+is.empty.nmf'></span><span id='topic+is.nmf'></span><span id='topic+isNMFfit'></span><span id='topic+is.partial.nmf'></span>

<h3>Description</h3>

<p>The functions documented here tests different
characteristics of NMF objects.
</p>
<p><code>is.nmf</code> tests if an object is an NMF model or a
class that extends the class NMF.
</p>
<p><code>hasBasis</code> tests whether an objects contains a basis
matrix &ndash; returned by a suitable method <code>basis</code> &ndash;
with at least one row.
</p>
<p><code>hasBasis</code> tests whether an objects contains a
coefficient matrix &ndash; returned by a suitable method
<code>coef</code> &ndash; with at least one column.
</p>
<p><code>is.partial.nmf</code> tests whether an NMF model object
contains either an empty basis or coefficient matrix. It
is a shorcut for <code>!hasCoef(x) || !hasBasis(x)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  is.nmf(x)

  is.empty.nmf(x, ...)

  hasBasis(x)

  hasCoef(x)

  is.partial.nmf(x)

  isNMFfit(object, recursive = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.nmf_+3A_x">x</code></td>
<td>
<p>an R object. See section <em>Details</em>, for how
each function uses this argument.</p>
</td></tr>
<tr><td><code id="is.nmf_+3A_...">...</code></td>
<td>
<p>extra parameters to allow extension or passed
to subsequent calls</p>
</td></tr>
<tr><td><code id="is.nmf_+3A_object">object</code></td>
<td>
<p>any R object.</p>
</td></tr>
<tr><td><code id="is.nmf_+3A_recursive">recursive</code></td>
<td>
<p>if <code>TRUE</code> and <code>object</code> is a
plain list then <code>isNMFfit</code> tests each element of the
list. Note that the recursive test only applies in the
case of lists that are not themselves NMFfit objects,
like <code>NMFfitXn</code> objects for which the result of
<code>isNMFfit</code> will always be <code>TRUE</code>, although they
are list objects (a single logical value).</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>is.nmf</code> tests if <code>object</code> is the name of a
class (if a <code>character</code> string), or inherits from a
class, that extends <code><a href="#topic+NMF-class">NMF</a></code>.
</p>
<p><code>is.empty.nmf</code> returns <code>TRUE</code> if the basis and
coefficient matrices of <code>x</code> have respectively zero
rows and zero columns. It returns <code>FALSE</code> otherwise.
</p>
<p>In particular, this means that an empty model can still
have a non-zero number of basis components, i.e. a
factorization rank that is not null. This happens, for
example, in the case of NMF models created calling the
factory method <code><a href="#topic+nmfModel">nmfModel</a></code> with a value only
for the factorization rank.
</p>
<p><em>isNMFfit</em> checks if <code>object</code> inherits from
class <code><a href="#topic+NMFfit-class">NMFfit</a></code> or
<code><a href="#topic+NMFfitX-class">NMFfitX</a></code>, which are the two types of
objects returned by the function <code><a href="#topic+nmf">nmf</a></code>. If
<code>object</code> is a plain <code>list</code> and
<code>recursive=TRUE</code>, then the test is performed on each
element of the list, and the return value is a logical
vector (or a list if <code>object</code> is a list of list) of
the same length as <code>object</code>.
</p>


<h3>Value</h3>

<p><code>isNMFfit</code> returns a <code>logical</code> vector (or a
list if <code>object</code> is a list of list) of the same
length as <code>object</code>.
</p>


<h3>Note</h3>

<p>The function <code>is.nmf</code> does some extra work with the
namespace as this function needs to return correct
results even when called in <code>.onLoad</code>. See
discussion on r-devel:
<a href="https://stat.ethz.ch/pipermail/r-devel/2011-June/061357.html">https://stat.ethz.ch/pipermail/r-devel/2011-June/061357.html</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+NMFfit-class">NMFfit</a></code>,
<code><a href="#topic+NMFfitX-class">NMFfitX</a></code>,
<code><a href="#topic+NMFfitXn-class">NMFfitXn</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

#----------
# is.nmf
#----------
# test if an object is an NMF model, i.e. that it implements the NMF interface
is.nmf(1:4)
is.nmf( nmfModel(3) )
is.nmf( nmf(rmatrix(10, 5), 2) )

#----------
# is.empty.nmf
#----------
# empty model
is.empty.nmf( nmfModel(3) )
# non empty models
is.empty.nmf( nmfModel(3, 10, 0) )
is.empty.nmf( rnmf(3, 10, 5) )

#----------
# isNMFfit
#----------
## Testing results of fits
# generate a random
V &lt;- rmatrix(20, 10)

# single run -- using very low value for maxIter to speed up the example
res &lt;- nmf(V, 3, maxIter=3L)
isNMFfit(res)

# multiple runs - keeping single fit
resm &lt;- nmf(V, 3, nrun=2, maxIter=3L)
isNMFfit(resm)

# with a list of results
isNMFfit(list(res, resm, 'not a result'))
isNMFfit(list(res, resm, 'not a result'), recursive=FALSE)
</code></pre>

<hr>
<h2 id='isCRANcheck'>Package Check Utils</h2><span id='topic+isCRANcheck'></span><span id='topic+isCHECK'></span>

<h3>Description</h3>

<p><code>isCRANcheck</code> <strong>tries</strong> to identify if one is running CRAN-like checks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>isCRANcheck(...)

isCHECK()
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="isCRANcheck_+3A_...">...</code></td>
<td>
<p>each argument specifies a set of tests to do using an AND operator.
The final result tests if any of the test set is true.
Possible values are:
</p>

<dl>
<dt><code>'timing'</code></dt><dd><p>Check if the environment variable <code>_R_CHECK_TIMINGS_</code> is set,
as with the flag <code>'--timing'</code> was set.</p>
</dd>
<dt><code>'cran'</code></dt><dd><p>Check if the environment variable <code>_R_CHECK_CRAN_INCOMING_</code> is set,
as with the flag <code>'--as-cran'</code> was set.</p>
</dd>
</dl>
</td></tr>
</table>


<h3>Details</h3>

<p>Currently <code>isCRANcheck</code> returns <code>TRUE</code> if the check is run with
either environment variable <code>_R_CHECK_TIMINGS_</code> (as set by flag <code>'--timings'</code>)
or <code>_R_CHECK_CRAN_INCOMINGS_</code> (as set by flag <code>'--as-cran'</code>).
</p>
<p><strong>Warning:</strong> the checks performed on CRAN check machines are on purpose not always
run with such flags, so that users cannot effectively &quot;trick&quot; the checks.
As a result, there is no guarantee this function effectively identifies such checks.
If really needed for honest reasons, CRAN recommends users rely on custom dedicated environment
variables to enable specific tests or examples.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>isCHECK</code>: tries harder to test if running under <code>R CMD check</code>.
It will definitely identifies check runs for:
</p>

<ul>
<li><p> unit tests that use the unified unit test framework defined by <span class="pkg">pkgmaker</span> (see <code>utest</code>);
</p>
</li>
<li><p> examples that are run with option <code>R_CHECK_RUNNING_EXAMPLES_ = TRUE</code>,
which is automatically set for man pages generated with a fork of <span class="pkg">roxygen2</span> (see <em>References</em>).
</p>
</li></ul>

<p>Currently, <code>isCHECK</code> checks both CRAN expected flags, the value of environment variable
<code>_R_CHECK_RUNNING_UTESTS_</code>, and the value of option <code>R_CHECK_RUNNING_EXAMPLES_</code>.
It will return <code>TRUE</code> if any of these environment variables is set to
anything not equivalent to <code>FALSE</code>, or if the option is <code>TRUE</code>.
For example, the function <code>utest</code> sets it to the name of the package
being checked (<code>_R_CHECK_RUNNING_UTESTS_=&lt;pkgname&gt;</code>),
but unit tests run as part of unit tests vignettes are run with
<code>_R_CHECK_RUNNING_UTESTS_=FALSE</code>, so that all tests are run and reported when
generating them.
</p>
</li></ul>


<h3>References</h3>

<p>Adapted from the function <code>CRAN</code>
in the <span class="pkg">fda</span> package.
</p>
<p><a href="https://github.com/renozao/roxygen">https://github.com/renozao/roxygen</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
isCHECK()

</code></pre>

<hr>
<h2 id='latex_preamble'>LaTeX Utilities for Vignettes</h2><span id='topic+latex_preamble'></span><span id='topic+latex_bibliography'></span>

<h3>Description</h3>

<p><code>latex_preamble</code> outputs/returns command definition LaTeX commands to
be put in the preamble of vignettes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>latex_preamble(
  PACKAGE,
  R = TRUE,
  CRAN = TRUE,
  Bioconductor = TRUE,
  GEO = TRUE,
  ArrayExpress = TRUE,
  biblatex = FALSE,
  only = FALSE,
  file = ""
)

latex_bibliography(PACKAGE, file = "")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="latex_preamble_+3A_package">PACKAGE</code></td>
<td>
<p>package name</p>
</td></tr>
<tr><td><code id="latex_preamble_+3A_r">R</code></td>
<td>
<p>logical that indicate if general R commands should be added
(e.g. package names, inline R code format commands)</p>
</td></tr>
<tr><td><code id="latex_preamble_+3A_cran">CRAN</code></td>
<td>
<p>logical that indicate if general CRAN commands should be added
(e.g. CRAN package citations)</p>
</td></tr>
<tr><td><code id="latex_preamble_+3A_bioconductor">Bioconductor</code></td>
<td>
<p>logical that indicate if general Bioconductor commands
should be added (e.g. Bioc package citations)</p>
</td></tr>
<tr><td><code id="latex_preamble_+3A_geo">GEO</code></td>
<td>
<p>logical that indicate if general GEOmnibus commands should be added
(e.g. urls to GEO datasets)</p>
</td></tr>
<tr><td><code id="latex_preamble_+3A_arrayexpress">ArrayExpress</code></td>
<td>
<p>logical that indicate if general ArrayExpress commands
should be added (e.g. urls to ArrayExpress datasets)</p>
</td></tr>
<tr><td><code id="latex_preamble_+3A_biblatex">biblatex</code></td>
<td>
<p>logical that indicates if a <code>\bibliography</code> command
should be added to include references from the package's REFERENCES.bib file.</p>
</td></tr>
<tr><td><code id="latex_preamble_+3A_only">only</code></td>
<td>
<p>a logical that indicates if the only the commands whose
dedicated argument is not missing should be considered.</p>
</td></tr>
<tr><td><code id="latex_preamble_+3A_file">file</code></td>
<td>
<p>connection where to print. If <code>NULL</code> the result is returned
silently.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Argument <code>PACKAGE</code> is not required for <code>latex_preamble</code>, but must
be correctly specified to ensure <code>biblatex=TRUE</code> generates the correct
bibliography command.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>latex_bibliography</code>: <code>latex_bibliography</code> prints or return a LaTeX command that includes a
package bibliography file if it exists.
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>
latex_preamble()
latex_preamble(R=TRUE, only=TRUE)
latex_preamble(R=FALSE, CRAN=FALSE, GEO=FALSE)
latex_preamble(GEO=TRUE, only=TRUE)

</code></pre>

<hr>
<h2 id='lverbose'>Internal verbosity option</h2><span id='topic+lverbose'></span>

<h3>Description</h3>

<p>Internal verbosity option
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  lverbose(val)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lverbose_+3A_val">val</code></td>
<td>
<p>logical that sets the verbosity level.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the old verbose level
</p>

<hr>
<h2 id='match_atrack'>Extending Annotation Vectors</h2><span id='topic+match_atrack'></span>

<h3>Description</h3>

<p>Extends a vector used as an annotation track to match the
number of rows and the row names of a given data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  match_atrack(x, data = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="match_atrack_+3A_x">x</code></td>
<td>
<p>annotation vector</p>
</td></tr>
<tr><td><code id="match_atrack_+3A_data">data</code></td>
<td>
<p>reference data</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of the same type as <code>x</code>
</p>

<hr>
<h2 id='methods-NMF'>Registry for NMF Algorithms</h2><span id='topic+existsNMFMethod'></span><span id='topic+getNMFMethod'></span><span id='topic+methods-NMF'></span><span id='topic+removeNMFMethod'></span><span id='topic+selectNMFMethod'></span>

<h3>Description</h3>

<p>Registry for NMF Algorithms
</p>
<p><code>selectNMFMethod</code> tries to select an appropriate NMF
algorithm that is able to fit a given the NMF model.
</p>
<p><code>getNMFMethod</code> retrieves NMF algorithm objects from
the registry.
</p>
<p><code>existsNMFMethod</code> tells if an NMF algorithm is
registered under the
</p>
<p><code>removeNMFMethod</code> removes an NMF algorithm from the
registry.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  selectNMFMethod(name, model, load = FALSE, exact = FALSE,
    all = FALSE, quiet = FALSE)

  getNMFMethod(...)

  existsNMFMethod(name, exact = TRUE)

  removeNMFMethod(name, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="methods-NMF_+3A_name">name</code></td>
<td>
<p>name of a registered NMF algorithm</p>
</td></tr>
<tr><td><code id="methods-NMF_+3A_model">model</code></td>
<td>
<p>class name of an NMF model, i.e. a class
that inherits from class <code><a href="#topic+NMF-class">NMF</a></code>.</p>
</td></tr>
<tr><td><code id="methods-NMF_+3A_load">load</code></td>
<td>
<p>a logical that indicates if the selected
algorithms should be loaded into <code>NMFStrategy</code>
objects</p>
</td></tr>
<tr><td><code id="methods-NMF_+3A_all">all</code></td>
<td>
<p>a logical that indicates if all algorithms
that can fit <code>model</code> should be returned or only the
default or first found.</p>
</td></tr>
<tr><td><code id="methods-NMF_+3A_quiet">quiet</code></td>
<td>
<p>a logical that indicates if the operation
should be performed quietly, without throwing errors or
warnings.</p>
</td></tr>
<tr><td><code id="methods-NMF_+3A_...">...</code></td>
<td>
<p>extra arguments passed to
<code>pkgreg_fetch</code> or
<code>pkgreg_remove</code>.</p>
</td></tr>
<tr><td><code id="methods-NMF_+3A_exact">exact</code></td>
<td>
<p>a logical that indicates if the access key
should be matched exactly (<code>TRUE</code>) or partially
(<code>FALSE</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>selectNMFMethod</code> returns a character vector or
<code>NMFStrategy</code> objects, or NULL if no suitable
algorithm was found.
</p>

<hr>
<h2 id='nbasis'>Dimension of NMF Objects</h2><span id='topic+dim-NMF'></span><span id='topic+dim+2CNMFfitXn-method'></span><span id='topic+dim+2CNMF-method'></span><span id='topic+nbasis'></span><span id='topic+nbasis+2CANY-method'></span><span id='topic+nbasis-methods'></span><span id='topic+nbasis+2CNMFfitXn-method'></span>

<h3>Description</h3>

<p>The methods <code>dim</code>, <code>nrow</code>, <code>ncol</code> and
<code>nbasis</code> return the different dimensions associated
with an NMF model.
</p>
<p><code>dim</code> returns all dimensions in a length-3 integer
vector: the number of row and columns of the estimated
target matrix, as well as the factorization rank (i.e.
the number of basis components).
</p>
<p><code>nrow</code>, <code>ncol</code> and <code>nbasis</code> provide
separate access to each of these dimensions respectively.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  nbasis(x, ...)

  ## S4 method for signature 'NMF'
dim(x)

  ## S4 method for signature 'NMFfitXn'
dim(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nbasis_+3A_x">x</code></td>
<td>
<p>an object with suitable <code>basis</code> and
<code>coef</code> methods, such as an object that inherit from
<code><a href="#topic+NMF-class">NMF</a></code>.</p>
</td></tr>
<tr><td><code id="nbasis_+3A_...">...</code></td>
<td>
<p>extra arguments to allow extension.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The NMF package does not implement specific functions
<code>nrow</code> and <code>ncol</code>, but rather the S4 method
<code>dim</code> for objects of class <code><a href="#topic+NMF-class">NMF</a></code>.
This allows the base methods <code><a href="base.html#topic+nrow">nrow</a></code> and
<code><a href="base.html#topic+ncol">ncol</a></code> to directly work with such objects, to
get the number of rows and columns of the target matrix
estimated by an NMF model.
</p>
<p>The function <code>nbasis</code> is a new S4 generic defined in
the package NMF, that returns the number of basis
components of an object. Its default method should work
for any object, that has a suitable <code>basis</code> method
defined for its class.
</p>


<h3>Value</h3>

<p>a single integer value or, for <code>dim</code>, a length-3
integer vector, e.g. <code>c(2000, 30, 3)</code> for an
<code>NMF</code> model that fits a 2000 x 30 matrix using 3
basis components.
</p>


<h3>Methods</h3>


<dl>
<dt>dim</dt><dd><p><code>signature(x = "NMF")</code>: method for NMF
objects for the base generic <code><a href="base.html#topic+dim">dim</a></code>. It
returns all dimensions in a length-3 integer vector: the
number of row and columns of the estimated target matrix,
as well as the factorization rank (i.e. the number of
basis components). </p>
</dd>
<dt>dim</dt><dd><p><code>signature(x = "NMFfitXn")</code>: Returns the
dimension common to all fits.
</p>
<p>Since all fits have the same dimensions, it returns the
dimension of the first fit. This method returns
<code>NULL</code> if the object is empty. </p>
</dd>
<dt>nbasis</dt><dd><p><code>signature(x = "ANY")</code>: Default method
which returns the number of columns of the basis matrix
extracted from <code>x</code> using a suitable method
<code>basis</code>, or, if the latter is <code>NULL</code>, the value
of attributes <code>'nbasis'</code>.
</p>
<p>For NMF models, this also corresponds to the number of
rows in the coefficient matrix. </p>
</dd>
<dt>nbasis</dt><dd><p><code>signature(x = "NMFfitXn")</code>: Returns
the number of basis components common to all fits.
</p>
<p>Since all fits have been computed using the same rank, it
returns the factorization rank of the first fit. This
method returns <code>NULL</code> if the object is empty. </p>
</dd>
</dl>


<hr>
<h2 id='nmf'>Running NMF algorithms</h2><span id='topic+nmf'></span><span id='topic+nmf+2Cdata.frame+2CANY+2CANY-method'></span><span id='topic+nmf+2Cformula+2CANY+2CANY-method'></span><span id='topic+nmf+2Cmatrix+2Cdata.frame+2CANY-method'></span><span id='topic+nmf+2Cmatrix+2Cmatrix+2CANY-method'></span><span id='topic+nmf+2Cmatrix+2Cmissing+2CANY-method'></span><span id='topic+nmf+2Cmatrix+2CNMF+2CANY-method'></span><span id='topic+nmf+2Cmatrix+2CNULL+2CANY-method'></span><span id='topic+nmf+2Cmatrix+2Cnumeric+2Ccharacter-method'></span><span id='topic+nmf+2Cmatrix+2Cnumeric+2Cfunction-method'></span><span id='topic+nmf+2Cmatrix+2Cnumeric+2Clist-method'></span><span id='topic+nmf+2Cmatrix+2Cnumeric+2Cmissing-method'></span><span id='topic+nmf+2Cmatrix+2Cnumeric+2CNMFStrategy-method'></span><span id='topic+nmf+2Cmatrix+2Cnumeric+2CNULL-method'></span><span id='topic+nmf-methods'></span>

<h3>Description</h3>

<p>The function <code>nmf</code> is a S4 generic defines the main
interface to run NMF algorithms within the framework
defined in package <code>NMF</code>. It has many methods that
facilitates applying, developing and testing NMF
algorithms.
</p>
<p>The package vignette <code>vignette('NMF')</code> contains an
introduction to the interface, through a sample data
analysis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  nmf(x, rank, method, ...)

  ## S4 method for signature 'matrix,numeric,NULL'
nmf(x, rank, method,
    seed = NULL, model = NULL, ...)

  ## S4 method for signature 'matrix,numeric,list'
nmf(x, rank, method, ...,
    .parameters = list())

  ## S4 method for signature 'matrix,numeric,function'
nmf(x, rank, method,
    seed, model = "NMFstd", ..., name,
    objective = "euclidean", mixed = FALSE)

  ## S4 method for signature 'matrix,NMF,ANY'
nmf(x, rank, method, seed,
    ...)

  ## S4 method for signature 'matrix,NULL,ANY'
nmf(x, rank, method, seed,
    ...)

  ## S4 method for signature 'matrix,matrix,ANY'
nmf(x, rank, method, seed,
    model = list(), ...)

  ## S4 method for signature 'formula,ANY,ANY'
nmf(x, rank, method, ...,
    model = NULL)

  ## S4 method for signature 'matrix,numeric,NMFStrategy'
nmf(x, rank,
    method, seed = nmf.getOption("default.seed"),
    rng = NULL, nrun = if (length(rank) &gt; 1) 30 else 1,
    model = NULL, .options = list(),
    .pbackend = nmf.getOption("pbackend"),
    .callback = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nmf_+3A_x">x</code></td>
<td>
<p>target data to fit, i.e. a matrix-like object</p>
</td></tr>
<tr><td><code id="nmf_+3A_rank">rank</code></td>
<td>
<p>specification of the factorization rank. It
is usually a single numeric value, but other type of
values are possible (e.g. matrix), for which specific
methods are implemented. See for example methods
<code>nmf,matrix,matrix,ANY</code>.
</p>
<p>If <code>rank</code> is a numeric vector with more than one
element, e.g. a range of ranks, then <code><a href="#topic+nmf">nmf</a></code>
performs the estimation procedure described in
<code><a href="#topic+nmfEstimateRank">nmfEstimateRank</a></code>.</p>
</td></tr>
<tr><td><code id="nmf_+3A_method">method</code></td>
<td>
<p>specification of the NMF algorithm. The
most common way of specifying the algorithm is to pass
the access key (i.e. a character string) of an algorithm
stored in the package's dedicated registry, but methods
exists that handle other types of values, such as
<code>function</code> or <code>list</code> object. See their
descriptions in section <em>Methods</em>.
</p>
<p>If <code>method</code> is missing the algorithm to use is
obtained from the option
<code>nmf.getOption('default.algorithm')</code>, unless it can
be infer from the type of NMF model to fit, if this later
is available from other arguments. Factory fresh default
value is &lsquo;brunet&rsquo;, which corresponds to the
standard NMF algorithm from <cite>Brunet2004</cite> (see
section <em>Algorithms</em>).
</p>
<p>Cases where the algorithm is inferred from the call are
when an NMF model is passed in arguments <code>rank</code> or
<code>seed</code> (see description for
<code>nmf,matrix,numeric,NULL</code> in section
<em>Methods</em>).</p>
</td></tr>
<tr><td><code id="nmf_+3A_...">...</code></td>
<td>
<p>extra arguments to allow extension of the
generic. Arguments that are not used in the chain of
internal calls to <code>nmf</code> methods are passed to the
function that effectively implements the algorithm that
fits an NMF model on <code>x</code>.</p>
</td></tr>
<tr><td><code id="nmf_+3A_.parameters">.parameters</code></td>
<td>
<p>list of method-specific parameters.
Its elements must have names matching a single method
listed in <code>method</code>, and be lists of named values
that are passed to the corresponding method.</p>
</td></tr>
<tr><td><code id="nmf_+3A_name">name</code></td>
<td>
<p>name associated with the NMF algorithm
implemented by the function <code>method</code> [only used when
<code>method</code> is a function].</p>
</td></tr>
<tr><td><code id="nmf_+3A_objective">objective</code></td>
<td>
<p>specification of the objective function
associated with the algorithm implemented by the function
<code>method</code> [only used when <code>method</code> is a
function].
</p>
<p>It may be either <code>'euclidean'</code> or <code>'KL'</code> for
specifying the euclidean distance (Frobenius norm) or the
Kullback-Leibler divergence respectively, or a function
with signature <code>(x="NMF", y="matrix", ...)</code> that
computes the objective value for an NMF model <code>x</code> on
a target matrix <code>y</code>, i.e. the residuals between the
target matrix and its NMF estimate. Any extra argument
may be specified, e.g. <code>function(x, y, alpha,
  beta=2, ...)</code>.</p>
</td></tr>
<tr><td><code id="nmf_+3A_mixed">mixed</code></td>
<td>
<p>a logical that indicates if the algorithm
implemented by the function <code>method</code> support
mixed-sign target matrices, i.e. that may contain
negative values [only used when <code>method</code> is a
function].</p>
</td></tr>
<tr><td><code id="nmf_+3A_seed">seed</code></td>
<td>
<p>specification of the starting point or
seeding method, which will compute a starting point,
usually using data from the target matrix in order to
provide a good guess.
</p>
<p>The seeding method may be specified in the following way:
</p>

<dl>
<dt>a <code>character</code> string:</dt><dd><p> giving the name of a
<em>registered</em> seeding method. The corresponding
method will be called to compute the starting point.
</p>
<p>Available methods can be listed via <code>nmfSeed()</code>. See
its dedicated documentation for details on each available
registered methods (<code><a href="#topic+nmfSeed">nmfSeed</a></code>). </p>
</dd>
<dt>a <code>list</code>:</dt><dd><p> giving the name of a
<em>registered</em> seeding method and, optionally, extra
parameters to pass to it.</p>
</dd>
<dt>a single <code>numeric</code>:</dt><dd><p> that is used to seed the
random number generator, before generating a random
starting point.
</p>
<p>Note that when performing multiple runs, the L'Ecuyer's
RNG is used in order to produce a sequence of random
streams, that is used in way that ensures that parallel
computation are fully reproducible. </p>
</dd>
<dt>an object that inherits from
<code><a href="#topic+NMF-class">NMF</a></code>:</dt><dd><p> it should contain the data of
an initialised NMF model, i.e. it must contain valid
basis and mixture coefficient matrices, directly usable
by the algorithm's workhorse function.</p>
</dd>
<dt>a <code>function</code>:</dt><dd><p> that computes the starting
point. It must have signature <code>(object="NMF",
  target="matrix", ...)</code> and return an object that inherits
from class <code>NMF</code>. It is recommended to use argument
<code>object</code> as a template for the returned object, by
only updating the basis and coefficient matrices, using
<code><a href="#topic+basis+3C-">basis&lt;-</a></code> and <code><a href="#topic+coef+3C-">coef&lt;-</a></code>
respectively. </p>
</dd>
</dl>
</td></tr>
<tr><td><code id="nmf_+3A_rng">rng</code></td>
<td>
<p>rng specification for the run(s). This
argument should be used to set the the RNG seed, while
still specifying the seeding method argument <var>seed</var>.</p>
</td></tr>
<tr><td><code id="nmf_+3A_model">model</code></td>
<td>
<p>specification of the type of NMF model to
use.
</p>
<p>It is used to instantiate the object that inherits from
class <code><a href="#topic+NMF-class">NMF</a></code>, that will be passed to
the seeding method. The following values are supported:
</p>

<ul>
<li> <p><code>NULL</code>, the default model associated to the
NMF algorithm is instantiated and <code>...</code> is looked-up
for arguments with names that correspond to slots in the
model class, which are passed to the function
<code><a href="#topic+nmfModel">nmfModel</a></code> to instantiate the model.
Arguments in <code>...</code> that do not correspond to slots
are passed to the algorithm.
</p>
</li>
<li><p> a single <code>character</code> string, that is the name
of the NMF model class to be instantiate.  In this case,
arguments in <code>...</code> are handled in the same way as
when <code>model</code> is <code>NULL</code>.
</p>
</li>
<li><p> a <code>list</code> that contains named values that are
passed to the function <code><a href="#topic+nmfModel">nmfModel</a></code> to
instantiate the model.  In this case, <code>...</code> is not
looked-up at all, and passed entirely to the algorithm.
This means that all necessary model parameters must be
specified in <code>model</code>.
</p>
</li></ul>

<p><strong>Argument/slot conflicts:</strong> In the case a parameter
of the algorithm has the same name as a model slot, then
<code>model</code> MUST be a list &ndash; possibly empty &ndash;, if one
wants this parameter to be effectively passed to the
algorithm.
</p>
<p>If a variable appears in both arguments <code>model</code> and
<code>...</code>, the former will be used to initialise the
NMF model, the latter will be passed to the NMF
algorithm.  See code examples for an illustration of this
situation.</p>
</td></tr>
<tr><td><code id="nmf_+3A_nrun">nrun</code></td>
<td>
<p>number of runs to perform. It specifies the
number of runs to perform. By default only one run is
performed, except if <code>rank</code> is a numeric vector with
more than one element, in which case a default of 30 runs
per value of the rank are performed, allowing the
computation of a consensus matrix that is used in
selecting the appropriate rank (see
<code><a href="#topic+consensus">consensus</a></code>).
</p>
<p>When using a random seeding method, multiple runs are
generally required to achieve stability and avoid
<em>bad</em> local minima.</p>
</td></tr>
<tr><td><code id="nmf_+3A_.options">.options</code></td>
<td>
<p>this argument is used to set runtime
options.
</p>
<p>It can be a <code>list</code> containing named options with
their values, or, in the case only boolean/integer
options need to be set, a character string that specifies
which options are turned on/off or their value, in a
unix-like command line argument way.
</p>
<p>The string must be composed of characters that correspond
to a given option (see mapping below), and modifiers '+'
and '-' that toggle options on and off respectively. E.g.
<code>.options='tv'</code> will toggle on options <code>track</code>
and <code>verbose</code>, while <code>.options='t-v'</code> will
toggle on option <code>track</code> and toggle off option
<code>verbose</code>.
</p>
<p>Modifiers '+' and '-' apply to all option character found
after them: <code>t-vp+k</code> means <code>track=TRUE</code>,
<code>verbose=parallel=FALSE</code>, and <code>keep.all=TRUE</code>.
The default behaviour is to assume that <code>.options</code>
starts with a '+'.
</p>
<p>for options that accept integer values, the value may be
appended to the option's character e.g. <code>'p4'</code> for
asking for 4 processors or <code>'v3'</code> for showing
verbosity message up to level 3.
</p>
<p>The following options are available (the characters after
&ldquo;-&rdquo; are those to use to encode <code>.options</code> as
a string): </p>

<dl>
<dt>debug - d</dt><dd><p> Toggle debug mode (default:
<code>FALSE</code>). Like option <code>verbose</code> but with more
information displayed.</p>
</dd>
<dt>keep.all - k</dt><dd><p> used when performing multiple runs
(<code>nrun</code>&gt;1): if <code>TRUE</code>, all factorizations are
saved and returned (default: <code>FALSE</code>). Otherwise
only the factorization achieving the minimum residuals is
returned.</p>
</dd>
<dt>parallel - p</dt><dd><p> this option is useful on multicore
*nix or Mac machine only, when performing multiple runs
(<code>nrun</code> &gt; 1) (default: <code>TRUE</code>). If <code>TRUE</code>,
the runs are performed using the parallel foreach backend
defined in argument <code>.pbackend</code>. If this is set to
<code>'mc'</code> or <code>'par'</code> then <code>nmf</code> tries to
perform the runs using multiple cores with package
<code>link[doParallel]{doParallel}</code> &ndash; which therefore
needs to be installed.
</p>
<p>If equal to an integer, then <code>nmf</code> tries to perform
the computation on the specified number of processors.
When passing options as a string the number is appended
to the option's character e.g. <code>'p4'</code> for asking for
4 processors.
</p>
<p>If <code>FALSE</code>, then the computation is performed
sequentially using the base function
<code><a href="base.html#topic+sapply">sapply</a></code>.
</p>
<p>Unlike option 'P' (capital 'P'), if the computation
cannot be performed in parallel, then it will still be
carried on sequentially.
</p>
<p><strong>IMPORTANT NOTE FOR MAC OS X USERS:</strong> The parallel
computation is based on the <code>doMC</code> and
<code>multicore</code> packages, so the same care should be
taken as stated in the vignette of <code>doMC</code>:
<em>&ldquo;it is not safe to use doMC from R.app on
Mac OS X. Instead, you should use doMC from a terminal
session, starting R from the command line.&rdquo;</em> </p>
</dd>
<dt>parallel.required - P</dt><dd><p> Same as <code>p</code>, but an
error is thrown if the computation cannot be performed in
parallel or with the specified number of processors.</p>
</dd>
<dt>shared.memory - m</dt><dd><p> toggle usage of shared memory
(requires the package <em>synchronicity</em>). Default is as
defined by <code>nmf.getOption('shared.memory')</code>.</p>
</dd>
<dt>restore.seed - r</dt><dd><p> deprecated option since version
0.5.99. Will throw a warning if used.</p>
</dd>
<dt>simplifyCB - S</dt><dd><p> toggle simplification of the
callback results. Default is <code>TRUE</code></p>
</dd>
<dt>track - t</dt><dd><p> enables error tracking (default:
FALSE). If <code>TRUE</code>, the returned object's slot
<code>residuals</code> contains the trajectory of the objective
values, which can be retrieved via <code>residuals(res,
  track=TRUE)</code> This tracking functionality is available for
all built-in algorithms. </p>
</dd>
<dt>verbose - v</dt><dd><p> Toggle verbosity (default:
<code>FALSE</code>). If <code>TRUE</code>, messages about the
configuration and the state of the current run(s) are
displayed. The level of verbosity may be specified with
an integer value, the greater the level the more messages
are displayed. Value <code>FALSE</code> means no messages are
displayed, while value <code>TRUE</code> is equivalent to
verbosity level 1. </p>
</dd>
</dl>
</td></tr>
<tr><td><code id="nmf_+3A_.pbackend">.pbackend</code></td>
<td>
<p>specification of the
<code><a href="foreach.html#topic+foreach">foreach</a></code> parallel backend to register and/or
use when running in parallel mode. See options <code>p</code>
and <code>P</code> in argument <code>.options</code> for how to
enable this mode. Note that any backend that is
internally registered is cleaned-up on exit, so that the
calling foreach environment should not be affected by a
call to <code>nmf</code> &ndash; except when <code>.pbackend=NULL</code>.
</p>
<p>Currently it accepts the following values: </p>

<dl>
<dt>&lsquo;par&rsquo;</dt><dd><p> use the backend(s) defined by the
package <code><a href="doParallel.html#topic+doParallel">doParallel</a></code>;</p>
</dd> <dt>a numeric
value</dt><dd><p> use the specified number of cores with
<code>doParallel</code> backend;</p>
</dd> <dt>&lsquo;seq&rsquo;</dt><dd><p> use the
foreach sequential backend <code>doSEQ</code>;</p>
</dd>
<dt><code>NULL</code></dt><dd><p> use currently registered backend;</p>
</dd>
<dt><code>NA</code></dt><dd><p> do not compute using a foreach loop &ndash;
and therefore not in parallel &ndash; but rather use a call to
standard <code><a href="base.html#topic+sapply">sapply</a></code>. This is useful for when
developing/debugging NMF algorithms, as foreach loop
handling may sometime get in the way.
</p>
<p>Note that this is equivalent to using
<code>.options='-p'</code> or <code>.options='p0'</code>, but takes
precedence over any option specified in <code>.options</code>:
e.g. <code>nmf(..., .options='P10', .pbackend=NA)</code>
performs all runs sequentially using <code>sapply</code>. Use
<code>nmf.options(pbackend=NA)</code> to completely disable
foreach/parallel computations for all subsequent
<code>nmf</code> calls.</p>
</dd>
<dt>&lsquo;mc&rsquo;</dt><dd><p> identical to &lsquo;par&rsquo; and defined
to ensure backward compatibility.</p>
</dd> </dl>
</td></tr>
<tr><td><code id="nmf_+3A_.callback">.callback</code></td>
<td>
<p>Used when option <code>keep.all=FALSE</code>
(default).  It allows to pass a callback function that is
called after each run when performing multiple runs (i.e.
with <code>nrun&gt;1</code>). This is useful for example if one is
also interested in saving summary measures or process the
result of each NMF fit before it gets discarded. After
each run, the callback function is called with two
arguments, the <code><a href="#topic+NMFfit-class">NMFfit</a></code> object that as
just been fitted and the run number: <code>.callback(res,
  i)</code>. For convenience, a function that takes only one
argument or has signature <code>(x, ...)</code> can still be
passed in <code>.callback</code>. It is wrapped internally into
a dummy function with two arguments, only the first of
which is passed to the actual callback function (see
example with <code>summary</code>).
</p>
<p>The call is wrapped into a tryCatch so that callback
errors do not stop the whole computation (see below).
</p>
<p>The results of the different calls to the callback
function are stored in a miscellaneous slot accessible
using the method <code>$</code> for <code>NMFfit</code> objects:
<code>res$.callback</code>. By default <code>nmf</code> tries to
simplify the list of callback result using <code>sapply</code>,
unless option <code>'simplifyCB'</code> is <code>FASE</code>.
</p>
<p>If no error occurs <code>res$.callback</code> contains the list
of values that resulted from the calling the callback
function &ndash;, ordered as the fits. If any error occurs in
one of the callback calls, then the whole computation is
<strong>not</strong> stopped, but the error message is stored in
<code>res$.callback</code>, in place of the result.
</p>
<p>See the examples for sample code.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>nmf</code> function has multiple methods that compose
a very flexible interface allowing to: </p>
 <ul>
<li>
<p>combine NMF algorithms with seeding methods and/or
stopping/convergence criterion at runtime;
</p>
</li>
<li><p> perform multiple NMF runs, which are computed in
parallel whenever the host machine allows it;
</p>
</li>
<li><p> run multiple algorithms with a common set of
parameters, ensuring a consistent environment (notably
the RNG settings). </p>
</li></ul>

<p>The workhorse method is
<code>nmf,matrix,numeric,NMFStrategy</code>, which is
eventually called by all other methods. The other methods
provides convenient ways of specifying the NMF
algorithm(s), the factorization rank, or the seed to be
used. Some allow to directly run NMF algorithms on
different types of objects, such as <code>data.frame</code> or
<em>ExpressionSet</em> objects.
</p>


<h3>Value</h3>

<p>The returned value depends on the run mode:
</p>
<table>
<tr><td><code>Single run:</code></td>
<td>
<p>An object of class
<code><a href="#topic+NMFfit-class">NMFfit</a></code>.</p>
</td></tr>
<tr><td><code>Multiple runs</code>, <code>single method:</code></td>
<td>
<p>When <code>nrun &gt; 1</code>
and <code>method</code> is not <code>list</code>, this method returns
an object of class <code><a href="#topic+NMFfitX-class">NMFfitX</a></code>.</p>
</td></tr>
<tr><td><code>Multiple runs</code>, <code>multiple methods:</code></td>
<td>
<p>When <code>nrun &gt;
  1</code> and <code>method</code> is a <code>list</code>, this method
returns an object of class <code><a href="#topic+NMFList-class">NMFList</a></code>.</p>
</td></tr>
</table>


<h3>Methods</h3>


<dl>
<dt>nmf</dt><dd><p><code>signature(x = "data.frame", rank =
  "ANY", method = "ANY")</code>: Fits an NMF model on a
<code>data.frame</code>.
</p>
<p>The target <code>data.frame</code> is coerced into a matrix
with <code><a href="base.html#topic+as.matrix">as.matrix</a></code>. </p>
</dd>
<dt>nmf</dt><dd><p><code>signature(x = "matrix", rank =
  "numeric", method = "NULL")</code>: Fits an NMF model using an
appropriate algorithm when <code>method</code> is not supplied.
</p>
<p>This method tries to select an appropriate algorithm
amongst the NMF algorithms stored in the internal
algorithm registry, which contains the type of NMF models
each algorithm can fit. This is possible when the type of
NMF model to fit is available from argument <code>seed</code>,
i.e. if it is an NMF model itself. Otherwise the
algorithm to use is obtained from
<code>nmf.getOption('default.algorithm')</code>.
</p>
<p>This method is provided for internal usage, when called
from other <code>nmf</code> methods with argument <code>method</code>
missing in the top call (e.g.
<code>nmf,matrix,numeric,missing</code>). </p>
</dd>
<dt>nmf</dt><dd><p><code>signature(x = "matrix", rank =
  "numeric", method = "list")</code>: Fits multiple NMF models on
a common matrix using a list of algorithms.
</p>
<p>The models are fitted sequentially with <code>nmf</code> using
the same options and parameters for all algorithms. In
particular, irrespective of the way the computation is
seeded, this method ensures that all fits are performed
using the same initial RNG settings.
</p>
<p>This method returns an object of class
<code><a href="#topic+NMFList-class">NMFList</a></code>, that is essentially a list
containing each fit. </p>
</dd>
<dt>nmf</dt><dd><p><code>signature(x = "matrix", rank =
  "numeric", method = "character")</code>: Fits an NMF model on
<code>x</code> using an algorithm registered with access key
<code>method</code>.
</p>
<p>Argument <code>method</code> is partially match against the
access keys of all registered algorithms (case
insensitive). Available algorithms are listed in section
<em>Algorithms</em> below or the introduction vignette. A
vector of their names may be retrieved via
<code>nmfAlgorithm()</code>. </p>
</dd>
<dt>nmf</dt><dd><p><code>signature(x = "matrix", rank =
  "numeric", method = "function")</code>: Fits an NMF model on
<code>x</code> using a custom algorithm defined the function
<code>method</code>.
</p>
<p>The supplied function must have signature
<code>(x=matrix, start=NMF, ...)</code> and return an object
that inherits from class <code><a href="#topic+NMF-class">NMF</a></code>. It
will be called internally by the workhorse <code>nmf</code>
method, with an NMF model to be used as a starting point
passed in its argument <code>start</code>.
</p>
<p>Extra arguments in <code>...</code> are passed to <code>method</code>
from the top <code>nmf</code> call. Extra arguments that have
no default value in the definition of the function
<code>method</code> are required to run the algorithm (e.g. see
argument <code>alpha</code> of <code>myfun</code> in the examples).
</p>
<p>If the algorithm requires a specific type of NMF model,
this can be specified in argument <code>model</code> that is
handled as in the workhorse <code>nmf</code> method (see
description for this argument). </p>
</dd>
<dt>nmf</dt><dd><p><code>signature(x = "matrix", rank = "NMF",
  method = "ANY")</code>: Fits an NMF model using the NMF model
<code>rank</code> to seed the computation, i.e. as a starting
point.
</p>
<p>This method is provided for convenience as a shortcut for
<code>nmf(x, nbasis(object), method, seed=object, ...)</code>
It discards any value passed in argument <code>seed</code> and
uses the NMF model passed in <code>rank</code> instead. It
throws a warning if argument <code>seed</code> not missing.
</p>
<p>If <code>method</code> is missing, this method will call the
method <code>nmf,matrix,numeric,NULL</code>, which will infer
an algorithm suitable for fitting an NMF model of the
class of <code>rank</code>. </p>
</dd>
<dt>nmf</dt><dd><p><code>signature(x = "matrix", rank = "NULL",
  method = "ANY")</code>: Fits an NMF model using the NMF model
supplied in <code>seed</code>, to seed the computation, i.e. as
a starting point.
</p>
<p>This method is provided for completeness and is
equivalent to <code>nmf(x, seed, method, ...)</code>. </p>
</dd>
<dt>nmf</dt><dd><p><code>signature(x = "matrix", rank =
  "missing", method = "ANY")</code>: Method defined to ensure the
correct dispatch to workhorse methods in case of argument
<code>rank</code> is missing. </p>
</dd>
<dt>nmf</dt><dd><p><code>signature(x = "matrix", rank =
  "numeric", method = "missing")</code>: Method defined to ensure
the correct dispatch to workhorse methods in case of
argument <code>method</code> is missing. </p>
</dd>
<dt>nmf</dt><dd><p><code>signature(x = "matrix", rank = "matrix",
  method = "ANY")</code>: Fits an NMF model partially seeding the
computation with a given matrix passed in <code>rank</code>.
</p>
<p>The matrix <code>rank</code> is used either as initial value
for the basis or mixture coefficient matrix, depending on
its dimension.
</p>
<p>Currently, such partial NMF model is directly used as a
seed, meaning that the remaining part is left
uninitialised, which is not accepted by all NMF
algorithm. This should change in the future, where the
missing part of the model will be drawn from some random
distribution.
</p>
<p>Amongst built-in algorithms, only &lsquo;snmf/l&rsquo; and
&lsquo;snmf/r&rsquo; support partial seeds, with only the
coefficient or basis matrix initialised respectively. </p>
</dd>
<dt>nmf</dt><dd><p><code>signature(x = "matrix", rank =
  "data.frame", method = "ANY")</code>: Shortcut for <code>nmf(x,
  as.matrix(rank), method, ...)</code>. </p>
</dd>
<dt>nmf</dt><dd><p><code>signature(x = "formula", rank = "ANY",
  method = "ANY")</code>: This method implements the interface
for fitting formula-based NMF models. See
<code><a href="#topic+nmfModel">nmfModel</a></code>.
</p>
<p>Argument <code>rank</code> target matrix or formula
environment. If not missing, <code>model</code> must be a
<code>list</code>, a <code>data.frame</code> or an <code>environment</code>
in which formula variables are searched for. </p>
</dd>
</dl>



<h3>Optimized C++ vs. plain R</h3>

<p>Lee and Seung's multiplicative updates are used by
several NMF algorithms. To improve speed and memory
usage, a C++ implementation of the specific matrix
products is used whenever possible. It directly computes
the updates for each entry in the updated matrix, instead
of using multiple standard matrix multiplication.
</p>
<p>The algorithms that benefit from this optimization are:
'brunet', 'lee', 'nsNMF' and 'offset'. 
However there still exists plain R versions for these
methods, which implement the updates as standard matrix
products. These are accessible by adding the prefix '.R#'
to their name: '.R#brunet', '.R#lee', '.R#nsNMF' and
'.R#offset'.
</p>


<h3>Algorithms</h3>

<p>All algorithms are accessible by their respective access
key as listed below. The following algorithms are
available: </p>

<dl>
<dt>&lsquo;brunet&rsquo;</dt><dd><p> Standard NMF, based on the
Kullback-Leibler divergence, from <cite>Brunet et al. (2004)</cite>. It
uses simple multiplicative updates from <cite>Lee et al. (2001)</cite>,
enhanced to avoid numerical underflow.
</p>
<p>Default stopping criterion: invariance of the
connectivity matrix (see
<code><a href="#topic+nmf.stop.connectivity">nmf.stop.connectivity</a></code>). </p>
</dd>
<dt>&lsquo;lee&rsquo;</dt><dd><p> Standard NMF based on the Euclidean
distance from <cite>Lee et al. (2001)</cite>. It uses simple
multiplicative updates.
</p>
<p>Default stopping criterion: invariance of the
connectivity matrix (see
<code><a href="#topic+nmf.stop.connectivity">nmf.stop.connectivity</a></code>). </p>
</dd>
<dt>ls-nmf</dt><dd><p> Least-Square NMF from <cite>Wang et al. (2006)</cite>. It
uses modified versions of Lee and Seung's multiplicative
updates for the Euclidean distance, which incorporates
weights on each entry of the target matrix, e.g. to
reflect measurement uncertainty.
</p>
<p>Default stopping criterion: stationarity of the objective
function (see <code><a href="#topic+nmf.stop.stationary">nmf.stop.stationary</a></code>). </p>
</dd>
<dt>&lsquo;nsNMF&rsquo;</dt><dd><p> Nonsmooth NMF from
<cite>Pascual-Montano et al. (2006)</cite>. It uses a modified version of
Lee and Seung's multiplicative updates for the
Kullback-Leibler divergence <cite>Lee et al. (2001)</cite>, to fit a
extension of the standard NMF model, that includes an
intermediate smoothing matrix, meant meant to produce
sparser factors.
</p>
<p>Default stopping criterion: invariance of the
connectivity matrix (see
<code><a href="#topic+nmf.stop.connectivity">nmf.stop.connectivity</a></code>). </p>
</dd>
<dt>&lsquo;offset&rsquo;</dt><dd><p> NMF with offset from
<cite>Badea (2008)</cite>. It uses a modified version of Lee and
Seung's multiplicative updates for Euclidean distance
<cite>Lee et al. (2001)</cite>, to fit an NMF model that includes an
intercept, meant to capture a common baseline and shared
patterns, in order to produce cleaner basis components.
</p>
<p>Default stopping criterion: invariance of the
connectivity matrix (see
<code><a href="#topic+nmf.stop.connectivity">nmf.stop.connectivity</a></code>). </p>
</dd>
<dt>&lsquo;pe-nmf&rsquo;</dt><dd><p> Pattern-Expression NMF from
<em>Zhang2008</em>. It uses multiplicative updates to
minimize an objective function based on the Euclidean
distance, that is regularized for effective expression of
patterns with basis vectors.
</p>
<p>Default stopping criterion: stationarity of the objective
function (see <code><a href="#topic+nmf.stop.stationary">nmf.stop.stationary</a></code>). </p>
</dd>
<dt>&lsquo;snmf/r&rsquo;, &lsquo;snmf/l&rsquo;</dt><dd><p> Alternating
Least Square (ALS) approach from <cite>Kim et al. (2007)</cite>. It
applies the nonnegative least-squares algorithm from
<cite>Van Benthem et al. (2004)</cite> (i.e. fast combinatorial
nonnegative least-squares for multiple right-hand), to
estimate the basis and coefficient matrices alternatively
(see <code><a href="#topic+fcnnls">fcnnls</a></code>). It minimises an
Euclidean-based objective function, that is regularized
to favour sparse basis matrices (for &lsquo;snmf/l&rsquo;) or
sparse coefficient matrices (for &lsquo;snmf/r&rsquo;).
</p>
<p>Stopping criterion: built-in within the internal
workhorse function <code>nmf_snmf</code>, based on the KKT
optimality conditions. </p>
</dd>
</dl>



<h3>Seeding methods</h3>

<p>The purpose of seeding methods is to compute initial
values for the factor matrices in a given NMF model. This
initial guess will be used as a starting point by the
chosen NMF algorithm.
</p>
<p>The seeding method to use in combination with the
algorithm can be passed to interface <code>nmf</code> through
argument <code>seed</code>. The seeding seeding methods
available in registry are listed by the function
<code><a href="#topic+nmfSeed">nmfSeed</a></code> (see list therein).
</p>
<p>Detailed examples of how to specify the seeding method
and its parameters can be found in the <em>Examples</em>
section of this man page and in the package's vignette.
</p>


<h3>References</h3>

<p>Brunet J, Tamayo P, Golub TR and Mesirov JP (2004).
&quot;Metagenes and molecular pattern discovery using matrix
factorization.&quot; _Proceedings of the National Academy of
Sciences of the United States of America_, *101*(12), pp.
4164-9. ISSN 0027-8424, &lt;URL:
http://dx.doi.org/10.1073/pnas.0308531101&gt;, &lt;URL:
http://www.ncbi.nlm.nih.gov/pubmed/15016911&gt;.
</p>
<p>Lee DD and Seung H (2001). &quot;Algorithms for non-negative
matrix factorization.&quot; _Advances in neural information
processing systems_. &lt;URL:
http://scholar.google.com/scholar?q=intitle:Algorithms+for+non-negative+matrix+factorization&gt;.
</p>
<p>Wang G, Kossenkov AV and Ochs MF (2006). &quot;LS-NMF: a
modified non-negative matrix factorization algorithm
utilizing uncertainty estimates.&quot; _BMC bioinformatics_,
*7*, pp. 175. ISSN 1471-2105, &lt;URL:
http://dx.doi.org/10.1186/1471-2105-7-175&gt;, &lt;URL:
http://www.ncbi.nlm.nih.gov/pubmed/16569230&gt;.
</p>
<p>Pascual-Montano A, Carazo JM, Kochi K, Lehmann D and
Pascual-marqui RD (2006). &quot;Nonsmooth nonnegative matrix
factorization (nsNMF).&quot; _IEEE Trans. Pattern Anal. Mach.
Intell_, *28*, pp. 403-415.
</p>
<p>Badea L (2008). &quot;Extracting gene expression profiles
common to colon and pancreatic adenocarcinoma using
simultaneous nonnegative matrix factorization.&quot; _Pacific
Symposium on Biocomputing. Pacific Symposium on
Biocomputing_, *290*, pp. 267-78. ISSN 1793-5091, &lt;URL:
http://www.ncbi.nlm.nih.gov/pubmed/18229692&gt;.
</p>
<p>Kim H and Park H (2007). &quot;Sparse non-negative matrix
factorizations via alternating non-negativity-constrained
least squares for microarray data analysis.&quot;
_Bioinformatics (Oxford, England)_, *23*(12), pp.
1495-502. ISSN 1460-2059, &lt;URL:
http://dx.doi.org/10.1093/bioinformatics/btm134&gt;, &lt;URL:
http://www.ncbi.nlm.nih.gov/pubmed/17483501&gt;.
</p>
<p>Van Benthem M and Keenan MR (2004). &quot;Fast algorithm for
the solution of large-scale non-negativity-constrained
least squares problems.&quot; _Journal of Chemometrics_,
*18*(10), pp. 441-450. ISSN 0886-9383, &lt;URL:
http://dx.doi.org/10.1002/cem.889&gt;, &lt;URL:
http://doi.wiley.com/10.1002/cem.889&gt;.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+nmfAlgorithm">nmfAlgorithm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# Only basic calls are presented in this manpage.
# Many more examples are provided in the demo file nmf.R
## Not run: 
demo('nmf')

## End(Not run)

# random data
x &lt;- rmatrix(20,10)

# run default algorithm with rank 2
res &lt;- nmf(x, 2)

# specify the algorithm
res &lt;- nmf(x, 2, 'lee')

# get verbose message on what is going on
res &lt;- nmf(x, 2, .options='v')
## Not run: 
# more messages
res &lt;- nmf(x, 2, .options='v2')
# even more
res &lt;- nmf(x, 2, .options='v3')
# and so on ...

## End(Not run)
</code></pre>

<hr>
<h2 id='nmf_update.brunet_R'>NMF Algorithm/Updates for Kullback-Leibler Divergence</h2><span id='topic+brunet-nmf'></span><span id='topic+brunet_R-nmf'></span><span id='topic+KL-nmf'></span><span id='topic+nmfAlgorithm.brunet'></span><span id='topic+nmfAlgorithm.brunet_R'></span><span id='topic+nmfAlgorithm.KL'></span><span id='topic+nmf_update.brunet'></span><span id='topic+nmf_update.brunet_R'></span>

<h3>Description</h3>

<p>The built-in NMF algorithms described here minimise the
Kullback-Leibler divergence (KL) between an NMF model and
a target matrix. They use the updates for the basis and
coefficient matrices (<code class="reqn">W</code> and <code class="reqn">H</code>) defined by
<cite>Brunet et al. (2004)</cite>, which are essentially those
from <cite>Lee et al. (2001)</cite>, with an stabilisation step
that shift up all entries from zero every 10 iterations,
to a very small positive value.
</p>
<p><code>nmf_update.brunet</code> implements in C++ an optimised
version of the single update step.
</p>
<p>Algorithms &lsquo;brunet&rsquo; and &lsquo;.R#brunet&rsquo; provide
the complete NMF algorithm from <cite>Brunet et al.
(2004)</cite>, using the C++-optimised and pure R updates
<code><a href="#topic+nmf_update.brunet">nmf_update.brunet</a></code> and
<code><a href="#topic+nmf_update.brunet_R">nmf_update.brunet_R</a></code> respectively.
</p>
<p>Algorithm &lsquo;KL&rsquo; provides an NMF algorithm based on
the C++-optimised version of the updates from
<cite>Brunet et al. (2004)</cite>, which uses the stationarity
of the objective value as a stopping criterion
<code><a href="#topic+nmf.stop.stationary">nmf.stop.stationary</a></code>, instead of the
stationarity of the connectivity matrix
<code><a href="#topic+nmf.stop.connectivity">nmf.stop.connectivity</a></code> as used by
&lsquo;brunet&rsquo;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  nmf_update.brunet_R(i, v, x, eps = .Machine$double.eps,
    ...)

  nmf_update.brunet(i, v, x, copy = FALSE,
    eps = .Machine$double.eps, ...)

  nmfAlgorithm.brunet_R(..., .stop = NULL,
    maxIter = nmf.getOption("maxIter") %||% 2000,
    eps = .Machine$double.eps, stopconv = 40,
    check.interval = 10)

  nmfAlgorithm.brunet(..., .stop = NULL,
    maxIter = nmf.getOption("maxIter") %||% 2000,
    copy = FALSE, eps = .Machine$double.eps, stopconv = 40,
    check.interval = 10)

  nmfAlgorithm.KL(..., .stop = NULL,
    maxIter = nmf.getOption("maxIter") %||% 2000,
    copy = FALSE, eps = .Machine$double.eps,
    stationary.th = .Machine$double.eps,
    check.interval = 5 * check.niter, check.niter = 10L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nmf_update.brunet_R_+3A_i">i</code></td>
<td>
<p>current iteration number.</p>
</td></tr>
<tr><td><code id="nmf_update.brunet_R_+3A_v">v</code></td>
<td>
<p>target matrix.</p>
</td></tr>
<tr><td><code id="nmf_update.brunet_R_+3A_x">x</code></td>
<td>
<p>current NMF model, as an
<code><a href="#topic+NMF-class">NMF</a></code> object.</p>
</td></tr>
<tr><td><code id="nmf_update.brunet_R_+3A_eps">eps</code></td>
<td>
<p>small numeric value used to ensure numeric
stability, by shifting up entries from zero to this fixed
value.</p>
</td></tr>
<tr><td><code id="nmf_update.brunet_R_+3A_...">...</code></td>
<td>
<p>extra arguments. These are generally not used
and present only to allow other arguments from the main
call to be passed to the initialisation and stopping
criterion functions (slots <code>onInit</code> and <code>Stop</code>
respectively).</p>
</td></tr>
<tr><td><code id="nmf_update.brunet_R_+3A_copy">copy</code></td>
<td>
<p>logical that indicates if the update should
be made on the original matrix directly (<code>FALSE</code>) or
on a copy (<code>TRUE</code> - default). With <code>copy=FALSE</code>
the memory footprint is very small, and some speed-up may
be achieved in the case of big matrices. However, greater
care should be taken due the side effect. We recommend
that only experienced users use <code>copy=TRUE</code>.</p>
</td></tr>
<tr><td><code id="nmf_update.brunet_R_+3A_.stop">.stop</code></td>
<td>
<p>specification of a stopping criterion, that
is used instead of the one associated to the NMF
algorithm. It may be specified as: </p>
 <ul>
<li><p> the
access key of a registered stopping criterion; </p>
</li>
<li><p> a
single integer that specifies the exact number of
iterations to perform, which will be honoured unless a
lower value is explicitly passed in argument
<code>maxIter</code>. </p>
</li>
<li><p> a single numeric value that
specifies the stationnarity threshold for the objective
function, used in with <code><a href="#topic+nmf.stop.stationary">nmf.stop.stationary</a></code>;
</p>
</li>
<li><p> a function with signature
<code>(object="NMFStrategy", i="integer", y="matrix",
  x="NMF", ...)</code>, where <code>object</code> is the
<code>NMFStrategy</code> object that describes the algorithm
being run, <code>i</code> is the current iteration, <code>y</code> is
the target matrix and <code>x</code> is the current value of
the NMF model. </p>
</li></ul>
</td></tr>
<tr><td><code id="nmf_update.brunet_R_+3A_maxiter">maxIter</code></td>
<td>
<p>maximum number of iterations to perform.</p>
</td></tr>
<tr><td><code id="nmf_update.brunet_R_+3A_stopconv">stopconv</code></td>
<td>
<p>number of iterations intervals over which
the connectivity matrix must not change for stationarity
to be achieved.</p>
</td></tr>
<tr><td><code id="nmf_update.brunet_R_+3A_check.interval">check.interval</code></td>
<td>
<p>interval (in number of iterations)
on which the stopping criterion is computed.</p>
</td></tr>
<tr><td><code id="nmf_update.brunet_R_+3A_stationary.th">stationary.th</code></td>
<td>
<p>maximum absolute value of the
gradient, for the objective function to be considered
stationary.</p>
</td></tr>
<tr><td><code id="nmf_update.brunet_R_+3A_check.niter">check.niter</code></td>
<td>
<p>number of successive iteration used to
compute the stationnary criterion.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>nmf_update.brunet_R</code> implements in pure R a single
update step, i.e. it updates both matrices.
</p>


<h3>Author(s)</h3>

<p>Original implementation in MATLAB: Jean-Philippe Brunet
<a href="mailto:brunet@broad.mit.edu">brunet@broad.mit.edu</a>
</p>
<p>Port to R and optimisation in C++: Renaud Gaujoux
</p>


<h3>Source</h3>

<p>Original license terms:
</p>
<p>This software and its documentation are copyright 2004 by
the Broad Institute/Massachusetts Institute of
Technology. All rights are reserved. This software is
supplied without any warranty or guaranteed support
whatsoever. Neither the Broad Institute nor MIT can not
be responsible for its use, misuse, or functionality.
</p>


<h3>References</h3>

<p>Brunet J, Tamayo P, Golub TR and Mesirov JP (2004).
&quot;Metagenes and molecular pattern discovery using matrix
factorization.&quot; _Proceedings of the National Academy of
Sciences of the United States of America_, *101*(12), pp.
4164-9. ISSN 0027-8424, &lt;URL:
http://dx.doi.org/10.1073/pnas.0308531101&gt;, &lt;URL:
http://www.ncbi.nlm.nih.gov/pubmed/15016911&gt;.
</p>
<p>Lee DD and Seung H (2001). &quot;Algorithms for non-negative
matrix factorization.&quot; _Advances in neural information
processing systems_. &lt;URL:
http://scholar.google.com/scholar?q=intitle:Algorithms+for+non-negative+matrix+factorization&gt;.
</p>

<hr>
<h2 id='nmf_update.euclidean_offset.h'>NMF Multiplicative Update for NMF with Offset Models</h2><span id='topic+nmfAlgorithm.offset'></span><span id='topic+nmfAlgorithm.offset_R'></span><span id='topic+nmf_update.euclidean_offset.h'></span><span id='topic+nmf_update.euclidean_offset.w'></span><span id='topic+nmf_update.offset'></span><span id='topic+nmf_update.offset_R'></span><span id='topic+offset_R-nmf'></span>

<h3>Description</h3>

<p>These update rules proposed by <cite>Badea (2008)</cite> are
modified version of the updates from <cite>Lee et al.
(2001)</cite>, that include an offset/intercept vector, which
models a common baseline for each feature accross all
samples: </p>
<p style="text-align: center;"><code class="reqn">V \approx W H + I</code>
</p>

<p><code>nmf_update.euclidean_offset.h</code> and
<code>nmf_update.euclidean_offset.w</code> compute the updated
NMFOffset model, using the optimized <em>C++</em>
implementations.
</p>
<p><code>nmf_update.offset_R</code> implements a complete single
update step, using plain R updates.
</p>
<p><code>nmf_update.offset</code> implements a complete single
update step, using C++-optimised updates.
</p>
<p>Algorithms &lsquo;offset&rsquo; and &lsquo;.R#offset&rsquo; provide
the complete NMF-with-offset algorithm from <cite>Badea
(2008)</cite>, using the C++-optimised and pure R updates
<code><a href="#topic+nmf_update.offset">nmf_update.offset</a></code> and
<code><a href="#topic+nmf_update.offset_R">nmf_update.offset_R</a></code> respectively.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  nmf_update.euclidean_offset.h(v, w, h, offset,
    eps = 10^-9, copy = TRUE)

  nmf_update.euclidean_offset.w(v, w, h, offset,
    eps = 10^-9, copy = TRUE)

  nmf_update.offset_R(i, v, x, eps = 10^-9, ...)

  nmf_update.offset(i, v, x, copy = FALSE, eps = 10^-9,
    ...)

  nmfAlgorithm.offset_R(..., .stop = NULL,
    maxIter = nmf.getOption("maxIter") %||% 2000,
    eps = 10^-9, stopconv = 40, check.interval = 10)

  nmfAlgorithm.offset(..., .stop = NULL,
    maxIter = nmf.getOption("maxIter") %||% 2000,
    copy = FALSE, eps = 10^-9, stopconv = 40,
    check.interval = 10)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nmf_update.euclidean_offset.h_+3A_offset">offset</code></td>
<td>
<p>current value of the offset/intercept
vector. It must be of length equal to the number of rows
in the target matrix.</p>
</td></tr>
<tr><td><code id="nmf_update.euclidean_offset.h_+3A_v">v</code></td>
<td>
<p>target matrix.</p>
</td></tr>
<tr><td><code id="nmf_update.euclidean_offset.h_+3A_eps">eps</code></td>
<td>
<p>small numeric value used to ensure numeric
stability, by shifting up entries from zero to this fixed
value.</p>
</td></tr>
<tr><td><code id="nmf_update.euclidean_offset.h_+3A_copy">copy</code></td>
<td>
<p>logical that indicates if the update should
be made on the original matrix directly (<code>FALSE</code>) or
on a copy (<code>TRUE</code> - default). With <code>copy=FALSE</code>
the memory footprint is very small, and some speed-up may
be achieved in the case of big matrices. However, greater
care should be taken due the side effect. We recommend
that only experienced users use <code>copy=TRUE</code>.</p>
</td></tr>
<tr><td><code id="nmf_update.euclidean_offset.h_+3A_i">i</code></td>
<td>
<p>current iteration number.</p>
</td></tr>
<tr><td><code id="nmf_update.euclidean_offset.h_+3A_x">x</code></td>
<td>
<p>current NMF model, as an
<code><a href="#topic+NMF-class">NMF</a></code> object.</p>
</td></tr>
<tr><td><code id="nmf_update.euclidean_offset.h_+3A_...">...</code></td>
<td>
<p>extra arguments. These are generally not used
and present only to allow other arguments from the main
call to be passed to the initialisation and stopping
criterion functions (slots <code>onInit</code> and <code>Stop</code>
respectively).</p>
</td></tr>
<tr><td><code id="nmf_update.euclidean_offset.h_+3A_.stop">.stop</code></td>
<td>
<p>specification of a stopping criterion, that
is used instead of the one associated to the NMF
algorithm. It may be specified as: </p>
 <ul>
<li><p> the
access key of a registered stopping criterion; </p>
</li>
<li><p> a
single integer that specifies the exact number of
iterations to perform, which will be honoured unless a
lower value is explicitly passed in argument
<code>maxIter</code>. </p>
</li>
<li><p> a single numeric value that
specifies the stationnarity threshold for the objective
function, used in with <code><a href="#topic+nmf.stop.stationary">nmf.stop.stationary</a></code>;
</p>
</li>
<li><p> a function with signature
<code>(object="NMFStrategy", i="integer", y="matrix",
  x="NMF", ...)</code>, where <code>object</code> is the
<code>NMFStrategy</code> object that describes the algorithm
being run, <code>i</code> is the current iteration, <code>y</code> is
the target matrix and <code>x</code> is the current value of
the NMF model. </p>
</li></ul>
</td></tr>
<tr><td><code id="nmf_update.euclidean_offset.h_+3A_maxiter">maxIter</code></td>
<td>
<p>maximum number of iterations to perform.</p>
</td></tr>
<tr><td><code id="nmf_update.euclidean_offset.h_+3A_stopconv">stopconv</code></td>
<td>
<p>number of iterations intervals over which
the connectivity matrix must not change for stationarity
to be achieved.</p>
</td></tr>
<tr><td><code id="nmf_update.euclidean_offset.h_+3A_check.interval">check.interval</code></td>
<td>
<p>interval (in number of iterations)
on which the stopping criterion is computed.</p>
</td></tr>
<tr><td><code id="nmf_update.euclidean_offset.h_+3A_w">w</code></td>
<td>
<p>current basis matrix</p>
</td></tr>
<tr><td><code id="nmf_update.euclidean_offset.h_+3A_h">h</code></td>
<td>
<p>current coefficient matrix</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The associated model is defined as an
<code><a href="#topic+NMFOffset-class">NMFOffset</a></code> object. The details of the
multiplicative updates can be found in <cite>Badea
(2008)</cite>. Note that the updates are the ones defined for a
single datasets, not the simultaneous NMF model, which is
fit by algorithm &lsquo;siNMF&rsquo; from formula-based NMF
models.
</p>


<h3>Value</h3>

<p>an <code><a href="#topic+NMFOffset-class">NMFOffset</a></code> model object.
</p>


<h3>Author(s)</h3>

<p>Original update definition: Liviu Badea
</p>
<p>Port to R and optimisation in C++: Renaud Gaujoux
</p>


<h3>References</h3>

<p>Badea L (2008). &quot;Extracting gene expression profiles
common to colon and pancreatic adenocarcinoma using
simultaneous nonnegative matrix factorization.&quot; _Pacific
Symposium on Biocomputing. Pacific Symposium on
Biocomputing_, *290*, pp. 267-78. ISSN 1793-5091, &lt;URL:
http://www.ncbi.nlm.nih.gov/pubmed/18229692&gt;.
</p>
<p>Lee DD and Seung H (2001). &quot;Algorithms for non-negative
matrix factorization.&quot; _Advances in neural information
processing systems_. &lt;URL:
http://scholar.google.com/scholar?q=intitle:Algorithms+for+non-negative+matrix+factorization&gt;.
</p>

<hr>
<h2 id='nmf_update.euclidean.h'>NMF Multiplicative Updates for Euclidean Distance</h2><span id='topic+nmf_update.euclidean'></span><span id='topic+nmf_update.euclidean.h'></span><span id='topic+nmf_update.euclidean.h_R'></span><span id='topic+nmf_update.euclidean.w'></span><span id='topic+nmf_update.euclidean.w_R'></span>

<h3>Description</h3>

<p>Multiplicative updates from <cite>Lee et al. (2001)</cite> for
standard Nonnegative Matrix Factorization models <code class="reqn">V
  \approx W H</code>, where the distance between the target
matrix and its NMF estimate is measured by the &ndash;
euclidean &ndash; Frobenius norm.
</p>
<p><code>nmf_update.euclidean.w</code> and
<code>nmf_update.euclidean.h</code> compute the updated basis
and coefficient matrices respectively. They use a
<em>C++</em> implementation which is optimised for speed
and memory usage.
</p>
<p><code>nmf_update.euclidean.w_R</code> and
<code>nmf_update.euclidean.h_R</code> implement the same
updates in <em>plain R</em>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  nmf_update.euclidean.h(v, w, h, eps = 10^-9,
    nbterms = 0L, ncterms = 0L, copy = TRUE)

  nmf_update.euclidean.h_R(v, w, h, wh = NULL, eps = 10^-9)

  nmf_update.euclidean.w(v, w, h, eps = 10^-9,
    nbterms = 0L, ncterms = 0L, weight = NULL, copy = TRUE)

  nmf_update.euclidean.w_R(v, w, h, wh = NULL, eps = 10^-9)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nmf_update.euclidean.h_+3A_eps">eps</code></td>
<td>
<p>small numeric value used to ensure numeric
stability, by shifting up entries from zero to this fixed
value.</p>
</td></tr>
<tr><td><code id="nmf_update.euclidean.h_+3A_wh">wh</code></td>
<td>
<p>already computed NMF estimate used to compute
the denominator term.</p>
</td></tr>
<tr><td><code id="nmf_update.euclidean.h_+3A_weight">weight</code></td>
<td>
<p>numeric vector of sample weights, e.g.,
used to normalise samples coming from multiple datasets.
It must be of the same length as the number of
samples/columns in <code>v</code> &ndash; and <code>h</code>.</p>
</td></tr>
<tr><td><code id="nmf_update.euclidean.h_+3A_v">v</code></td>
<td>
<p>target matrix</p>
</td></tr>
<tr><td><code id="nmf_update.euclidean.h_+3A_w">w</code></td>
<td>
<p>current basis matrix</p>
</td></tr>
<tr><td><code id="nmf_update.euclidean.h_+3A_h">h</code></td>
<td>
<p>current coefficient matrix</p>
</td></tr>
<tr><td><code id="nmf_update.euclidean.h_+3A_nbterms">nbterms</code></td>
<td>
<p>number of fixed basis terms</p>
</td></tr>
<tr><td><code id="nmf_update.euclidean.h_+3A_ncterms">ncterms</code></td>
<td>
<p>number of fixed coefficient terms</p>
</td></tr>
<tr><td><code id="nmf_update.euclidean.h_+3A_copy">copy</code></td>
<td>
<p>logical that indicates if the update should
be made on the original matrix directly (<code>FALSE</code>) or
on a copy (<code>TRUE</code> - default). With <code>copy=FALSE</code>
the memory footprint is very small, and some speed-up may
be achieved in the case of big matrices. However, greater
care should be taken due the side effect. We recommend
that only experienced users use <code>copy=TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The coefficient matrix (<code>H</code>) is updated as follows:
</p>
<p style="text-align: center;"><code class="reqn"> H_{kj} \leftarrow \frac{\max(H_{kj} W^T V)_{kj},
  \varepsilon) }{(W^T W H)_{kj} + \varepsilon} </code>
</p>

<p>These updates are used by the built-in NMF algorithms
<code><a href="#topic+Frobenius-nmf">Frobenius</a></code> and
<code><a href="#topic+lee-nmf">lee</a></code>.
</p>
<p>The basis matrix (<code>W</code>) is updated as follows: </p>
<p style="text-align: center;"><code class="reqn">
  W_ik \leftarrow \frac{\max(W_ik (V H^T)_ik, \varepsilon)
  }{ (W H H^T)_ik + \varepsilon} </code>
</p>



<h3>Value</h3>

<p>a matrix of the same dimension as the input matrix to
update (i.e. <code>w</code> or <code>h</code>). If <code>copy=FALSE</code>,
the returned matrix uses the same memory as the input
object.
</p>


<h3>Author(s)</h3>

<p>Update definitions by <cite>Lee2001</cite>.
</p>
<p>C++ optimised implementation by Renaud Gaujoux.
</p>


<h3>References</h3>

<p>Lee DD and Seung H (2001). &quot;Algorithms for non-negative
matrix factorization.&quot; _Advances in neural information
processing systems_. &lt;URL:
http://scholar.google.com/scholar?q=intitle:Algorithms+for+non-negative+matrix+factorization&gt;.
</p>

<hr>
<h2 id='nmf_update.KL.h'>NMF Multiplicative Updates for Kullback-Leibler Divergence</h2><span id='topic+nmf_update.KL'></span><span id='topic+nmf_update.KL.h'></span><span id='topic+nmf_update.KL.h_R'></span><span id='topic+nmf_update.KL.w'></span><span id='topic+nmf_update.KL.w_R'></span>

<h3>Description</h3>

<p>Multiplicative updates from <cite>Lee et al. (2001)</cite> for
standard Nonnegative Matrix Factorization models <code class="reqn">V
  \approx W H</code>, where the distance between the target
matrix and its NMF estimate is measured by the
Kullback-Leibler divergence.
</p>
<p><code>nmf_update.KL.w</code> and <code>nmf_update.KL.h</code> compute
the updated basis and coefficient matrices respectively.
They use a <em>C++</em> implementation which is optimised
for speed and memory usage.
</p>
<p><code>nmf_update.KL.w_R</code> and <code>nmf_update.KL.h_R</code>
implement the same updates in <em>plain R</em>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  nmf_update.KL.h(v, w, h, nbterms = 0L, ncterms = 0L,
    copy = TRUE)

  nmf_update.KL.h_R(v, w, h, wh = NULL)

  nmf_update.KL.w(v, w, h, nbterms = 0L, ncterms = 0L,
    copy = TRUE)

  nmf_update.KL.w_R(v, w, h, wh = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nmf_update.KL.h_+3A_v">v</code></td>
<td>
<p>target matrix</p>
</td></tr>
<tr><td><code id="nmf_update.KL.h_+3A_w">w</code></td>
<td>
<p>current basis matrix</p>
</td></tr>
<tr><td><code id="nmf_update.KL.h_+3A_h">h</code></td>
<td>
<p>current coefficient matrix</p>
</td></tr>
<tr><td><code id="nmf_update.KL.h_+3A_nbterms">nbterms</code></td>
<td>
<p>number of fixed basis terms</p>
</td></tr>
<tr><td><code id="nmf_update.KL.h_+3A_ncterms">ncterms</code></td>
<td>
<p>number of fixed coefficient terms</p>
</td></tr>
<tr><td><code id="nmf_update.KL.h_+3A_copy">copy</code></td>
<td>
<p>logical that indicates if the update should
be made on the original matrix directly (<code>FALSE</code>) or
on a copy (<code>TRUE</code> - default). With <code>copy=FALSE</code>
the memory footprint is very small, and some speed-up may
be achieved in the case of big matrices. However, greater
care should be taken due the side effect. We recommend
that only experienced users use <code>copy=TRUE</code>.</p>
</td></tr>
<tr><td><code id="nmf_update.KL.h_+3A_wh">wh</code></td>
<td>
<p>already computed NMF estimate used to compute
the denominator term.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The coefficient matrix (<code>H</code>) is updated as follows:
</p>
<p style="text-align: center;"><code class="reqn"> H_{kj} \leftarrow H_{kj} \frac{\left( sum_i
  \frac{W_{ik} V_{ij}}{(WH)_{ij}} \right)}{ sum_i W_{ik} }.
  </code>
</p>

<p>These updates are used in built-in NMF algorithms
<code><a href="#topic+KL-nmf">KL</a></code> and
<code><a href="#topic+brunet-nmf">brunet</a></code>.
</p>
<p>The basis matrix (<code>W</code>) is updated as follows: </p>
<p style="text-align: center;"><code class="reqn">
  W_{ik} \leftarrow W_{ik} \frac{ sum_j [\frac{H_{kj}
  A_{ij}}{(WH)_{ij}} ] }{sum_j H_{kj} } </code>
</p>



<h3>Value</h3>

<p>a matrix of the same dimension as the input matrix to
update (i.e. <code>w</code> or <code>h</code>). If <code>copy=FALSE</code>,
the returned matrix uses the same memory as the input
object.
</p>


<h3>Author(s)</h3>

<p>Update definitions by <cite>Lee2001</cite>.
</p>
<p>C++ optimised implementation by Renaud Gaujoux.
</p>


<h3>References</h3>

<p>Lee DD and Seung H (2001). &quot;Algorithms for non-negative
matrix factorization.&quot; _Advances in neural information
processing systems_. &lt;URL:
http://scholar.google.com/scholar?q=intitle:Algorithms+for+non-negative+matrix+factorization&gt;.
</p>

<hr>
<h2 id='nmf_update.lee_R'>NMF Algorithm/Updates for Frobenius Norm</h2><span id='topic+Frobenius-nmf'></span><span id='topic+lee-nmf'></span><span id='topic+lee_R-nmf'></span><span id='topic+nmfAlgorithm.Frobenius'></span><span id='topic+nmfAlgorithm.lee'></span><span id='topic+nmfAlgorithm.lee_R'></span><span id='topic+nmf_update.lee'></span><span id='topic+nmf_update.lee_R'></span>

<h3>Description</h3>

<p>The built-in NMF algorithms described here minimise the
Frobenius norm (Euclidean distance) between an NMF model
and a target matrix. They use the updates for the basis
and coefficient matrices (<code class="reqn">W</code> and <code class="reqn">H</code>) defined by
<cite>Lee et al. (2001)</cite>.
</p>
<p><code>nmf_update.lee</code> implements in C++ an optimised
version of the single update step.
</p>
<p>Algorithms &lsquo;lee&rsquo; and &lsquo;.R#lee&rsquo; provide the
complete NMF algorithm from <cite>Lee et al. (2001)</cite>,
using the C++-optimised and pure R updates
<code><a href="#topic+nmf_update.lee">nmf_update.lee</a></code> and
<code><a href="#topic+nmf_update.lee_R">nmf_update.lee_R</a></code> respectively.
</p>
<p>Algorithm &lsquo;Frobenius&rsquo; provides an NMF algorithm
based on the C++-optimised version of the updates from
<cite>Lee et al. (2001)</cite>, which uses the stationarity of
the objective value as a stopping criterion
<code><a href="#topic+nmf.stop.stationary">nmf.stop.stationary</a></code>, instead of the
stationarity of the connectivity matrix
<code><a href="#topic+nmf.stop.connectivity">nmf.stop.connectivity</a></code> as used by
&lsquo;lee&rsquo;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  nmf_update.lee_R(i, v, x, rescale = TRUE, eps = 10^-9,
    ...)

  nmf_update.lee(i, v, x, rescale = TRUE, copy = FALSE,
    eps = 10^-9, weight = NULL, ...)

  nmfAlgorithm.lee_R(..., .stop = NULL,
    maxIter = nmf.getOption("maxIter") %||% 2000,
    rescale = TRUE, eps = 10^-9, stopconv = 40,
    check.interval = 10)

  nmfAlgorithm.lee(..., .stop = NULL,
    maxIter = nmf.getOption("maxIter") %||% 2000,
    rescale = TRUE, copy = FALSE, eps = 10^-9,
    weight = NULL, stopconv = 40, check.interval = 10)

  nmfAlgorithm.Frobenius(..., .stop = NULL,
    maxIter = nmf.getOption("maxIter") %||% 2000,
    rescale = TRUE, copy = FALSE, eps = 10^-9,
    weight = NULL, stationary.th = .Machine$double.eps,
    check.interval = 5 * check.niter, check.niter = 10L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nmf_update.lee_R_+3A_rescale">rescale</code></td>
<td>
<p>logical that indicates if the basis matrix
<code class="reqn">W</code> should be rescaled so that its columns sum up to
one.</p>
</td></tr>
<tr><td><code id="nmf_update.lee_R_+3A_i">i</code></td>
<td>
<p>current iteration number.</p>
</td></tr>
<tr><td><code id="nmf_update.lee_R_+3A_v">v</code></td>
<td>
<p>target matrix.</p>
</td></tr>
<tr><td><code id="nmf_update.lee_R_+3A_x">x</code></td>
<td>
<p>current NMF model, as an
<code><a href="#topic+NMF-class">NMF</a></code> object.</p>
</td></tr>
<tr><td><code id="nmf_update.lee_R_+3A_eps">eps</code></td>
<td>
<p>small numeric value used to ensure numeric
stability, by shifting up entries from zero to this fixed
value.</p>
</td></tr>
<tr><td><code id="nmf_update.lee_R_+3A_...">...</code></td>
<td>
<p>extra arguments. These are generally not used
and present only to allow other arguments from the main
call to be passed to the initialisation and stopping
criterion functions (slots <code>onInit</code> and <code>Stop</code>
respectively).</p>
</td></tr>
<tr><td><code id="nmf_update.lee_R_+3A_copy">copy</code></td>
<td>
<p>logical that indicates if the update should
be made on the original matrix directly (<code>FALSE</code>) or
on a copy (<code>TRUE</code> - default). With <code>copy=FALSE</code>
the memory footprint is very small, and some speed-up may
be achieved in the case of big matrices. However, greater
care should be taken due the side effect. We recommend
that only experienced users use <code>copy=TRUE</code>.</p>
</td></tr>
<tr><td><code id="nmf_update.lee_R_+3A_.stop">.stop</code></td>
<td>
<p>specification of a stopping criterion, that
is used instead of the one associated to the NMF
algorithm. It may be specified as: </p>
 <ul>
<li><p> the
access key of a registered stopping criterion; </p>
</li>
<li><p> a
single integer that specifies the exact number of
iterations to perform, which will be honoured unless a
lower value is explicitly passed in argument
<code>maxIter</code>. </p>
</li>
<li><p> a single numeric value that
specifies the stationnarity threshold for the objective
function, used in with <code><a href="#topic+nmf.stop.stationary">nmf.stop.stationary</a></code>;
</p>
</li>
<li><p> a function with signature
<code>(object="NMFStrategy", i="integer", y="matrix",
  x="NMF", ...)</code>, where <code>object</code> is the
<code>NMFStrategy</code> object that describes the algorithm
being run, <code>i</code> is the current iteration, <code>y</code> is
the target matrix and <code>x</code> is the current value of
the NMF model. </p>
</li></ul>
</td></tr>
<tr><td><code id="nmf_update.lee_R_+3A_maxiter">maxIter</code></td>
<td>
<p>maximum number of iterations to perform.</p>
</td></tr>
<tr><td><code id="nmf_update.lee_R_+3A_stopconv">stopconv</code></td>
<td>
<p>number of iterations intervals over which
the connectivity matrix must not change for stationarity
to be achieved.</p>
</td></tr>
<tr><td><code id="nmf_update.lee_R_+3A_check.interval">check.interval</code></td>
<td>
<p>interval (in number of iterations)
on which the stopping criterion is computed.</p>
</td></tr>
<tr><td><code id="nmf_update.lee_R_+3A_stationary.th">stationary.th</code></td>
<td>
<p>maximum absolute value of the
gradient, for the objective function to be considered
stationary.</p>
</td></tr>
<tr><td><code id="nmf_update.lee_R_+3A_check.niter">check.niter</code></td>
<td>
<p>number of successive iteration used to
compute the stationnary criterion.</p>
</td></tr>
<tr><td><code id="nmf_update.lee_R_+3A_weight">weight</code></td>
<td>
<p>numeric vector of sample weights, e.g.,
used to normalise samples coming from multiple datasets.
It must be of the same length as the number of
samples/columns in <code>v</code> &ndash; and <code>h</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>nmf_update.lee_R</code> implements in pure R a single
update step, i.e. it updates both matrices.
</p>


<h3>Author(s)</h3>

<p>Original update definition: D D Lee and HS Seung
</p>
<p>Port to R and optimisation in C++: Renaud Gaujoux
</p>


<h3>References</h3>

<p>Lee DD and Seung H (2001). &quot;Algorithms for non-negative
matrix factorization.&quot; _Advances in neural information
processing systems_. &lt;URL:
http://scholar.google.com/scholar?q=intitle:Algorithms+for+non-negative+matrix+factorization&gt;.
</p>

<hr>
<h2 id='nmf_update.lsnmf'>Multiplicative Updates for LS-NMF</h2><span id='topic+lsNMF-nmf'></span><span id='topic+nmfAlgorithm.lsNMF'></span><span id='topic+nmf_update.lsnmf'></span><span id='topic+wrss'></span>

<h3>Description</h3>

<p>Implementation of the updates for the LS-NMF algorithm
from <cite>Wang et al. (2006)</cite>.
</p>
<p><code>wrss</code> implements the objective function used by the
LS-NMF algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  nmf_update.lsnmf(i, X, object, weight, eps = 10^-9, ...)

  wrss(object, X, weight)

  nmfAlgorithm.lsNMF(..., .stop = NULL,
    maxIter = nmf.getOption("maxIter") %||% 2000, weight,
    eps = 10^-9, stationary.th = .Machine$double.eps,
    check.interval = 5 * check.niter, check.niter = 10L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nmf_update.lsnmf_+3A_i">i</code></td>
<td>
<p>current iteration</p>
</td></tr>
<tr><td><code id="nmf_update.lsnmf_+3A_x">X</code></td>
<td>
<p>target matrix</p>
</td></tr>
<tr><td><code id="nmf_update.lsnmf_+3A_object">object</code></td>
<td>
<p>current NMF model</p>
</td></tr>
<tr><td><code id="nmf_update.lsnmf_+3A_weight">weight</code></td>
<td>
<p>value for <code class="reqn">\Sigma</code>, i.e. the weights
that are applied to each entry in <code>X</code> by <code>X *
  weight</code> (= entry wise product). Weights are usually
specified as a matrix of the same dimension as <code>X</code>
(e.g. uncertainty estimates for each measurement), but
may also be passed as a vector, in which case the
standard rules for entry wise product between matrices
and vectors apply (e.g. recylcing elements).</p>
</td></tr>
<tr><td><code id="nmf_update.lsnmf_+3A_eps">eps</code></td>
<td>
<p>small number passed to the standard
euclidean-based NMF updates (see
<code><a href="#topic+nmf_update.euclidean">nmf_update.euclidean</a></code>).</p>
</td></tr>
<tr><td><code id="nmf_update.lsnmf_+3A_...">...</code></td>
<td>
<p>extra arguments (not used)</p>
</td></tr>
<tr><td><code id="nmf_update.lsnmf_+3A_.stop">.stop</code></td>
<td>
<p>specification of a stopping criterion, that
is used instead of the one associated to the NMF
algorithm. It may be specified as: </p>
 <ul>
<li><p> the
access key of a registered stopping criterion; </p>
</li>
<li><p> a
single integer that specifies the exact number of
iterations to perform, which will be honoured unless a
lower value is explicitly passed in argument
<code>maxIter</code>. </p>
</li>
<li><p> a single numeric value that
specifies the stationnarity threshold for the objective
function, used in with <code><a href="#topic+nmf.stop.stationary">nmf.stop.stationary</a></code>;
</p>
</li>
<li><p> a function with signature
<code>(object="NMFStrategy", i="integer", y="matrix",
  x="NMF", ...)</code>, where <code>object</code> is the
<code>NMFStrategy</code> object that describes the algorithm
being run, <code>i</code> is the current iteration, <code>y</code> is
the target matrix and <code>x</code> is the current value of
the NMF model. </p>
</li></ul>
</td></tr>
<tr><td><code id="nmf_update.lsnmf_+3A_maxiter">maxIter</code></td>
<td>
<p>maximum number of iterations to perform.</p>
</td></tr>
<tr><td><code id="nmf_update.lsnmf_+3A_stationary.th">stationary.th</code></td>
<td>
<p>maximum absolute value of the
gradient, for the objective function to be considered
stationary.</p>
</td></tr>
<tr><td><code id="nmf_update.lsnmf_+3A_check.interval">check.interval</code></td>
<td>
<p>interval (in number of iterations)
on which the stopping criterion is computed.</p>
</td></tr>
<tr><td><code id="nmf_update.lsnmf_+3A_check.niter">check.niter</code></td>
<td>
<p>number of successive iteration used to
compute the stationnary criterion.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>updated object <code>object</code>
</p>


<h3>References</h3>

<p>Wang G, Kossenkov AV and Ochs MF (2006). &quot;LS-NMF: a
modified non-negative matrix factorization algorithm
utilizing uncertainty estimates.&quot; _BMC bioinformatics_,
*7*, pp. 175. ISSN 1471-2105, &lt;URL:
http://dx.doi.org/10.1186/1471-2105-7-175&gt;, &lt;URL:
http://www.ncbi.nlm.nih.gov/pubmed/16569230&gt;.
</p>

<hr>
<h2 id='nmf_update.ns'>NMF Multiplicative Update for Nonsmooth Nonnegative Matrix Factorization (nsNMF).</h2><span id='topic+nmfAlgorithm.nsNMF'></span><span id='topic+nmfAlgorithm.nsNMF_R'></span><span id='topic+nmf_update.ns'></span><span id='topic+nmf_update.ns_R'></span><span id='topic+nsNMF_R-nmf'></span>

<h3>Description</h3>

<p>These update rules, defined for the
<code><a href="#topic+NMFns-class">NMFns</a></code> model <code class="reqn">V \approx W S H</code>
from <cite>Pascual-Montano et al. (2006)</cite>, that
introduces an intermediate smoothing matrix to enhance
sparsity of the factors.
</p>
<p><code>nmf_update.ns</code> computes the updated nsNMF model. It
uses the optimized <em>C++</em> implementations
<code><a href="#topic+nmf_update.KL.w">nmf_update.KL.w</a></code> and
<code><a href="#topic+nmf_update.KL.h">nmf_update.KL.h</a></code> to update <code class="reqn">W</code> and
<code class="reqn">H</code> respectively.
</p>
<p><code>nmf_update.ns_R</code> implements the same updates in
<em>plain R</em>.
</p>
<p>Algorithms &lsquo;nsNMF&rsquo; and &lsquo;.R#nsNMF&rsquo; provide
the complete NMF algorithm from <cite>Pascual-Montano et
al. (2006)</cite>, using the C++-optimised and plain R updates
<code><a href="#topic+nmf_update.brunet">nmf_update.brunet</a></code> and
<code><a href="#topic+nmf_update.brunet_R">nmf_update.brunet_R</a></code> respectively. The
stopping criterion is based on the stationarity of the
connectivity matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  nmf_update.ns(i, v, x, copy = FALSE, ...)

  nmf_update.ns_R(i, v, x, ...)

  nmfAlgorithm.nsNMF_R(..., .stop = NULL,
    maxIter = nmf.getOption("maxIter") %||% 2000,
    stopconv = 40, check.interval = 10)

  nmfAlgorithm.nsNMF(..., .stop = NULL,
    maxIter = nmf.getOption("maxIter") %||% 2000,
    copy = FALSE, stopconv = 40, check.interval = 10)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nmf_update.ns_+3A_i">i</code></td>
<td>
<p>current iteration number.</p>
</td></tr>
<tr><td><code id="nmf_update.ns_+3A_v">v</code></td>
<td>
<p>target matrix.</p>
</td></tr>
<tr><td><code id="nmf_update.ns_+3A_x">x</code></td>
<td>
<p>current NMF model, as an
<code><a href="#topic+NMF-class">NMF</a></code> object.</p>
</td></tr>
<tr><td><code id="nmf_update.ns_+3A_copy">copy</code></td>
<td>
<p>logical that indicates if the update should
be made on the original matrix directly (<code>FALSE</code>) or
on a copy (<code>TRUE</code> - default). With <code>copy=FALSE</code>
the memory footprint is very small, and some speed-up may
be achieved in the case of big matrices. However, greater
care should be taken due the side effect. We recommend
that only experienced users use <code>copy=TRUE</code>.</p>
</td></tr>
<tr><td><code id="nmf_update.ns_+3A_...">...</code></td>
<td>
<p>extra arguments. These are generally not used
and present only to allow other arguments from the main
call to be passed to the initialisation and stopping
criterion functions (slots <code>onInit</code> and <code>Stop</code>
respectively).</p>
</td></tr>
<tr><td><code id="nmf_update.ns_+3A_.stop">.stop</code></td>
<td>
<p>specification of a stopping criterion, that
is used instead of the one associated to the NMF
algorithm. It may be specified as: </p>
 <ul>
<li><p> the
access key of a registered stopping criterion; </p>
</li>
<li><p> a
single integer that specifies the exact number of
iterations to perform, which will be honoured unless a
lower value is explicitly passed in argument
<code>maxIter</code>. </p>
</li>
<li><p> a single numeric value that
specifies the stationnarity threshold for the objective
function, used in with <code><a href="#topic+nmf.stop.stationary">nmf.stop.stationary</a></code>;
</p>
</li>
<li><p> a function with signature
<code>(object="NMFStrategy", i="integer", y="matrix",
  x="NMF", ...)</code>, where <code>object</code> is the
<code>NMFStrategy</code> object that describes the algorithm
being run, <code>i</code> is the current iteration, <code>y</code> is
the target matrix and <code>x</code> is the current value of
the NMF model. </p>
</li></ul>
</td></tr>
<tr><td><code id="nmf_update.ns_+3A_maxiter">maxIter</code></td>
<td>
<p>maximum number of iterations to perform.</p>
</td></tr>
<tr><td><code id="nmf_update.ns_+3A_stopconv">stopconv</code></td>
<td>
<p>number of iterations intervals over which
the connectivity matrix must not change for stationarity
to be achieved.</p>
</td></tr>
<tr><td><code id="nmf_update.ns_+3A_check.interval">check.interval</code></td>
<td>
<p>interval (in number of iterations)
on which the stopping criterion is computed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The multiplicative updates are based on the updates
proposed by <cite>Brunet et al. (2004)</cite>, except that the
NMF estimate <code class="reqn">W H</code> is replaced by <code class="reqn">W S H</code> and
<code class="reqn">W</code> (resp. <code class="reqn">H</code>) is replaced by <code class="reqn">W S</code> (resp.
<code class="reqn">S H</code>) in the update of <code class="reqn">H</code> (resp. <code class="reqn">W</code>).
</p>
<p>See <code><a href="#topic+nmf_update.KL">nmf_update.KL</a></code> for more details on the
update formula.
</p>


<h3>Value</h3>

<p>an <code><a href="#topic+NMFns-class">NMFns</a></code> model object.
</p>


<h3>References</h3>

<p>Pascual-Montano A, Carazo JM, Kochi K, Lehmann D and
Pascual-marqui RD (2006). &quot;Nonsmooth nonnegative matrix
factorization (nsNMF).&quot; _IEEE Trans. Pattern Anal. Mach.
Intell_, *28*, pp. 403-415.
</p>
<p>Brunet J, Tamayo P, Golub TR and Mesirov JP (2004).
&quot;Metagenes and molecular pattern discovery using matrix
factorization.&quot; _Proceedings of the National Academy of
Sciences of the United States of America_, *101*(12), pp.
4164-9. ISSN 0027-8424, &lt;URL:
http://dx.doi.org/10.1073/pnas.0308531101&gt;, &lt;URL:
http://www.ncbi.nlm.nih.gov/pubmed/15016911&gt;.
</p>

<hr>
<h2 id='NMF-class'>Generic Interface for Nonnegative Matrix Factorisation Models</h2><span id='topic+.DollarNames+2CNMF-method'></span><span id='topic+misc'></span><span id='topic+NMF-class'></span><span id='topic++24+3C-+2CNMF-method'></span><span id='topic++24+2CNMF-method'></span>

<h3>Description</h3>

<p>The class <code>NMF</code> is a <em>virtual class</em> that
defines a common interface to handle Nonnegative Matrix
Factorization models (NMF models) in a generic way.
Provided a minimum set of generic methods is implemented
by concrete model classes, these benefit from a whole set
of functions and utilities to perform common computations
and tasks in the context of Nonnegative Matrix
Factorization.
</p>
<p>The function <code>misc</code> provides access to miscellaneous
data members stored in slot <code>misc</code> (as a
<code>list</code>), which allow extensions of NMF models to be
implemented, without defining a new S4 class.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  misc(object, ...)

  ## S4 method for signature 'NMF'
x$name

  ## S4 replacement method for signature 'NMF'
x$name&lt;-value

  ## S4 method for signature 'NMF'
.DollarNames(x, pattern = "")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NMF-class_+3A_object">object</code></td>
<td>
<p>an object that inherit from class
<code>NMF</code></p>
</td></tr>
<tr><td><code id="NMF-class_+3A_...">...</code></td>
<td>
<p>extra arguments (not used)</p>
</td></tr>
<tr><td><code id="NMF-class_+3A_x">x</code></td>
<td>
<p> object from which to extract element(s) or in
which to replace element(s).  </p>
</td></tr>
<tr><td><code id="NMF-class_+3A_name">name</code></td>
<td>
<p> A literal character string or a <a href="#topic+name">name</a>
(possibly <a href="base.html#topic+backtick">backtick</a> quoted).  For extraction, this
is normally (see under &lsquo;Environments&rsquo;) partially
matched to the <code><a href="base.html#topic+names">names</a></code> of the object.  </p>
</td></tr>
<tr><td><code id="NMF-class_+3A_value">value</code></td>
<td>
<p>typically an array-like <span class="rlang"><b>R</b></span> object of a
similar class as <code>x</code>.</p>
</td></tr>
<tr><td><code id="NMF-class_+3A_pattern">pattern</code></td>
<td>
<p> A regular expression.  Only matching
names are returned.  </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Class <code>NMF</code> makes it easy to develop new models that
integrate well into the general framework implemented by
the <em>NMF</em> package.
</p>
<p>Following a few simple guidelines, new types of NMF
models benefit from all the functionalities available for
the built-in NMF models &ndash; that derive themselves from
class <code>NMF</code>. See section <em>Implementing NMF
models</em> below.
</p>
<p>See <code><a href="#topic+NMFstd-class">NMFstd</a></code>, and references and links
therein for details on the built-in implementations of
the standard NMF model and its extensions.
</p>


<h3>Slots</h3>


<dl>
<dt>misc</dt><dd><p>A list that is used internally to temporarily
store algorithm parameters during the computation.</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>[</dt><dd><p><code>signature(x = "NMF")</code>: This method
provides a convenient way of sub-setting objects of class
<code>NMF</code>, using a matrix-like syntax.
</p>
<p>It allows to consistently subset one or both matrix
factors in the NMF model, as well as retrieving part of
the basis components or part of the mixture coefficients
with a reduced amount of code.
</p>
<p>See <code><a href="#topic++5B+2CNMF-method">[,NMF-method</a></code> for more details. </p>
</dd>
<dt>$</dt><dd><p><code>signature(x = "NMF")</code>: shortcut for
<code>x@misc[[name, exact=TRUE]]</code> respectively. </p>
</dd>
<dt>$</dt><dd><p><code>signature(x = "NMF")</code>: shortcut for
<code>x@misc[[name, exact=TRUE]]</code> respectively. </p>
</dd>
<dt>$&lt;-</dt><dd><p><code>signature(x = "NMF")</code>: shortcut for
<code>x@misc[[name]] &lt;- value</code> </p>
</dd>
<dt>$&lt;-</dt><dd><p><code>signature(x = "NMF")</code>: shortcut for
<code>x@misc[[name]] &lt;- value</code> </p>
</dd>
<dt>.basis</dt><dd><p><code>signature(object = "NMF")</code>: Pure
virtual method for objects of class
<code><a href="#topic+NMF-class">NMF</a></code>, that should be overloaded by
sub-classes, and throws an error if called. </p>
</dd>
<dt>.basis&lt;-</dt><dd><p><code>signature(object = "NMF", value =
  "matrix")</code>: Pure virtual method for objects of class
<code><a href="#topic+NMF-class">NMF</a></code>, that should be overloaded by
sub-classes, and throws an error if called. </p>
</dd>
<dt>basis&lt;-</dt><dd><p><code>signature(object = "NMF")</code>: Default
methods that calls <code>.basis&lt;-</code> and check the validity
of the updated object. </p>
</dd>
<dt>basiscor</dt><dd><p><code>signature(x = "NMF", y =
  "matrix")</code>: Computes the correlations between the basis
vectors of <code>x</code> and the columns of <code>y</code>. </p>
</dd>
<dt>basiscor</dt><dd><p><code>signature(x = "NMF", y = "NMF")</code>:
Computes the correlations between the basis vectors of
<code>x</code> and <code>y</code>. </p>
</dd>
<dt>basiscor</dt><dd><p><code>signature(x = "NMF", y =
  "missing")</code>: Computes the correlations between the basis
vectors of <code>x</code>. </p>
</dd>
<dt>basismap</dt><dd><p><code>signature(object = "NMF")</code>: Plots a
heatmap of the basis matrix of the NMF model
<code>object</code>. This method also works for fitted NMF
models (i.e. <code>NMFfit</code> objects). </p>
</dd>
<dt>c</dt><dd><p><code>signature(x = "NMF")</code>: Binds compatible
matrices and NMF models together. </p>
</dd>
<dt>.coef</dt><dd><p><code>signature(object = "NMF")</code>: Pure
virtual method for objects of class
<code><a href="#topic+NMF-class">NMF</a></code>, that should be overloaded by
sub-classes, and throws an error if called. </p>
</dd>
<dt>.coef&lt;-</dt><dd><p><code>signature(object = "NMF", value =
  "matrix")</code>: Pure virtual method for objects of class
<code><a href="#topic+NMF-class">NMF</a></code>, that should be overloaded by
sub-classes, and throws an error if called. </p>
</dd>
<dt>coef&lt;-</dt><dd><p><code>signature(object = "NMF")</code>: Default
methods that calls <code>.coef&lt;-</code> and check the validity
of the updated object. </p>
</dd>
<dt>coefficients</dt><dd><p><code>signature(object = "NMF")</code>:
Alias to <code>coef,NMF</code>, therefore also pure virtual. </p>
</dd>
<dt>coefmap</dt><dd><p><code>signature(object = "NMF")</code>: The
default method for NMF objects has special default values
for some arguments of <code><a href="#topic+aheatmap">aheatmap</a></code> (see
argument description). </p>
</dd>
<dt>connectivity</dt><dd><p><code>signature(object = "NMF")</code>:
Computes the connectivity matrix for an NMF model, for
which cluster membership is given by the most
contributing basis component in each sample. See
<code><a href="#topic+predict+2CNMF-method">predict,NMF-method</a></code>. </p>
</dd>
<dt>consensus</dt><dd><p><code>signature(object = "NMF")</code>: This
method is provided for completeness and is identical to
<code><a href="#topic+connectivity">connectivity</a></code>, and returns the connectivity
matrix, which, in the case of a single NMF model, is also
the consensus matrix. </p>
</dd>
<dt>consensushc</dt><dd><p><code>signature(object = "NMF")</code>:
Compute the hierarchical clustering on the connectivity
matrix of <code>object</code>. </p>
</dd>
<dt>consensusmap</dt><dd><p><code>signature(object = "NMF")</code>:
Plots a heatmap of the connectivity matrix of an NMF
model. </p>
</dd>
<dt>deviance</dt><dd><p><code>signature(object = "NMF")</code>:
Computes the distance between a matrix and the estimate
of an <code>NMF</code> model. </p>
</dd>
<dt>dim</dt><dd><p><code>signature(x = "NMF")</code>: method for NMF
objects for the base generic <code><a href="base.html#topic+dim">dim</a></code>. It
returns all dimensions in a length-3 integer vector: the
number of row and columns of the estimated target matrix,
as well as the factorization rank (i.e. the number of
basis components). </p>
</dd>
<dt>dimnames</dt><dd><p><code>signature(x = "NMF")</code>: Returns the
dimension names of the NMF model <code>x</code>.
</p>
<p>It returns either NULL if no dimnames are set on the
object, or a 3-length list containing the row names of
the basis matrix, the column names of the mixture
coefficient matrix, and the column names of the basis
matrix (i.e. the names of the basis components). </p>
</dd>
<dt>dimnames&lt;-</dt><dd><p><code>signature(x = "NMF")</code>: sets the
dimension names of the NMF model <code>x</code>.
</p>
<p><code>value</code> can be <code>NULL</code> which resets all
dimension names, or a 1, 2 or 3-length list providing
names at least for the rows of the basis matrix.
</p>
<p>See <code><a href="base.html#topic+dimnames">dimnames</a></code> for more details.
</p>
</dd>
<dt>.DollarNames</dt><dd><p><code>signature(x = "NMF")</code>:
Auto-completion for <code><a href="#topic+NMF-class">NMF</a></code> objects </p>
</dd>
<dt>.DollarNames</dt><dd><p><code>signature(x = "NMF")</code>:
Auto-completion for <code><a href="#topic+NMF-class">NMF</a></code> objects </p>
</dd>
<dt>extractFeatures</dt><dd><p><code>signature(object = "NMF")</code>:
Select basis-specific features from an NMF model, by
applying the method <code>extractFeatures,matrix</code> to its
basis matrix. </p>
</dd>
<dt>featureScore</dt><dd><p><code>signature(object = "NMF")</code>:
Computes feature scores on the basis matrix of an NMF
model. </p>
</dd>
<dt>fitted</dt><dd><p><code>signature(object = "NMF")</code>: Pure
virtual method for objects of class
<code><a href="#topic+NMF-class">NMF</a></code>, that should be overloaded by
sub-classes, and throws an error if called. </p>
</dd>
<dt>ibterms</dt><dd><p><code>signature(object = "NMF")</code>: Default
pure virtual method that ensure a method is defined for
concrete NMF model classes. </p>
</dd>
<dt>icterms</dt><dd><p><code>signature(object = "NMF")</code>: Default
pure virtual method that ensure a method is defined for
concrete NMF model classes. </p>
</dd>
<dt>loadings</dt><dd><p><code>signature(x = "NMF")</code>: Method
loadings for NMF Models
</p>
<p>The method <code>loadings</code> is identical to <code>basis</code>,
but do not accept any extra argument.
</p>
<p>See <code><a href="#topic+loadings+2CNMF-method">loadings,NMF-method</a></code> for more details. </p>
</dd>
<dt>metaHeatmap</dt><dd><p><code>signature(object = "NMF")</code>:
Deprecated method that is substituted by
<code><a href="#topic+coefmap">coefmap</a></code> and <code><a href="#topic+basismap">basismap</a></code>. </p>
</dd>
<dt>nmf.equal</dt><dd><p><code>signature(x = "NMF", y = "NMF")</code>:
Compares two NMF models.
</p>
<p>Arguments in <code>...</code> are used only when
<code>identical=FALSE</code> and are passed to
<code>all.equal</code>. </p>
</dd>
<dt>nmf.equal</dt><dd><p><code>signature(x = "NMF", y =
  "NMFfit")</code>: Compares two NMF models when at least one
comes from a NMFfit object, i.e. an object returned by a
single run of <code><a href="#topic+nmf">nmf</a></code>. </p>
</dd>
<dt>nmf.equal</dt><dd><p><code>signature(x = "NMF", y =
  "NMFfitX")</code>: Compares two NMF models when at least one
comes from multiple NMF runs. </p>
</dd>
<dt>nneg</dt><dd><p><code>signature(object = "NMF")</code>: Apply
<code>nneg</code> to the basis matrix of an <code><a href="#topic+NMF">NMF</a></code>
object (i.e. <code>basis(object)</code>). All extra arguments
in <code>...</code> are passed to the method
<code>nneg,matrix</code>. </p>
</dd>
<dt>predict</dt><dd><p><code>signature(object = "NMF")</code>: Default
method for NMF models </p>
</dd>
<dt>profcor</dt><dd><p><code>signature(x = "NMF", y = "matrix")</code>:
Computes the correlations between the basis profiles of
<code>x</code> and the rows of <code>y</code>. </p>
</dd>
<dt>profcor</dt><dd><p><code>signature(x = "NMF", y = "NMF")</code>:
Computes the correlations between the basis profiles of
<code>x</code> and <code>y</code>. </p>
</dd>
<dt>profcor</dt><dd><p><code>signature(x = "NMF", y =
  "missing")</code>: Computes the correlations between the basis
profiles of <code>x</code>. </p>
</dd>
<dt>rmatrix</dt><dd><p><code>signature(x = "NMF")</code>: Returns the
target matrix estimate of the NMF model <code>x</code>,
perturbated by adding a random matrix generated using the
default method of <code>rmatrix</code>: it is a equivalent to
<code>fitted(x) + rmatrix(fitted(x), ...)</code>.
</p>
<p>This method can be used to generate random target
matrices that depart from a known NMF model to a
controlled extend. This is useful to test the robustness
of NMF algorithms to the presence of certain types of
noise in the data. </p>
</dd>
<dt>rnmf</dt><dd><p><code>signature(x = "NMF", target =
  "numeric")</code>: Generates a random NMF model of the same
class and rank as another NMF model.
</p>
<p>This is the workhorse method that is eventually called by
all other methods. It generates an NMF model of the same
class and rank as <code>x</code>, compatible with the
dimensions specified in <code>target</code>, that can be a
single or 2-length numeric vector, to specify a square or
rectangular target matrix respectively.
</p>
<p>See <code><a href="#topic+rnmf+2CNMF+2Cnumeric-method">rnmf,NMF,numeric-method</a></code> for more
details. </p>
</dd>
<dt>rnmf</dt><dd><p><code>signature(x = "NMF", target =
  "missing")</code>: Generates a random NMF model of the same
dimension as another NMF model.
</p>
<p>It is a shortcut for <code>rnmf(x, nrow(x), ncol(x),
  ...)</code>, which returns a random NMF model of the same class
and dimensions as <code>x</code>. </p>
</dd>
<dt>rposneg</dt><dd><p><code>signature(object = "NMF")</code>: Apply
<code>rposneg</code> to the basis matrix of an
<code><a href="#topic+NMF">NMF</a></code> object. </p>
</dd>
<dt>show</dt><dd><p><code>signature(object = "NMF")</code>: Show method
for objects of class <code>NMF</code> </p>
</dd>
<dt>sparseness</dt><dd><p><code>signature(x = "NMF")</code>: Compute
the sparseness of an object of class <code>NMF</code>, as the
sparseness of the basis and coefficient matrices computed
separately.
</p>
<p>It returns the two values in a numeric vector with names
&lsquo;basis&rsquo; and &lsquo;coef&rsquo;. </p>
</dd>
<dt>summary</dt><dd><p><code>signature(object = "NMF")</code>: Computes
summary measures for a single NMF model.
</p>
<p>The following measures are computed:
</p>
<p>See <code><a href="#topic+summary+2CNMF-method">summary,NMF-method</a></code> for more details. </p>
</dd>
</dl>



<h3>Implementing NMF models</h3>

<p>The class <code>NMF</code> only defines a basic data/low-level
interface for NMF models, as a collection of generic
methods, responsible with data handling, upon which
relies a comprehensive set of functions, composing a rich
higher-level interface.
</p>
<p>Actual NMF models are defined as sub-classes that
inherits from class <code>NMF</code>, and implement the
management of data storage, providing definitions for the
interface's pure virtual methods.
</p>
<p>The minimum requirement to define a new NMF model that
integrates into the framework of the <em>NMF</em> package
are the followings:
</p>

<ul>
<li><p> Define a class that inherits from class <code>NMF</code>
and implements the new model, say class <code>myNMF</code>.
</p>
</li>
<li><p> Implement the following S4 methods for the new
class <code>myNMF</code>: </p>

<dl>
<dt>fitted</dt><dd><p><code>signature(object = "myNMF", value =
  "matrix")</code>: Must return the estimated target matrix as
fitted by the NMF model <code>object</code>.  </p>
</dd>
<dt>basis</dt><dd><p><code>signature(object = "myNMF")</code>: Must
return the basis matrix(e.g. the first matrix factor in
the standard NMF model).  </p>
</dd>
<dt>basis&lt;-</dt><dd><p><code>signature(object = "myNMF", value =
  "matrix")</code>: Must return <code>object</code> with the basis
matrix set to <code>value</code>.  </p>
</dd>
<dt>coef</dt><dd><p><code>signature(object = "myNMF")</code>: Must
return the matrix of mixture coefficients (e.g. the
second matrix factor in the standard NMF model).  </p>
</dd>
<dt>coef&lt;-</dt><dd><p><code>signature(object = "myNMF", value =
  "matrix")</code>: Must return <code>object</code> with the matrix of
mixture coefficients set to <code>value</code>.  </p>
</dd> </dl>

<p>The <em>NMF</em> package provides &quot;pure virtual&quot;
definitions of these methods for class <code>NMF</code> (i.e.
with signatures <code>(object='NMF', ...)</code> and
<code>(object='NMF', value='matrix')</code>) that throw an
error if called, so as to force their definition for
model classes.
</p>
</li>
<li><p> Optionally, implement method
<code>rnmf</code>(signature(x=&quot;myNMF&quot;, target=&quot;ANY&quot;)). This
method should call <code>callNextMethod(x=x,
  target=target, ...)</code> and fill the returned NMF model with
its specific data suitable random values. </p>
</li></ul>

<p>For concrete examples of NMF models implementations, see
class <code><a href="#topic+NMFstd-class">NMFstd</a></code> and its extensions
(e.g. classes <code><a href="#topic+NMFOffset-class">NMFOffset</a></code> or
<code><a href="#topic+NMFns-class">NMFns</a></code>).
</p>


<h3>Creating NMF objects</h3>

<p>Strictly speaking, because class <code>NMF</code> is virtual,
no object of class <code>NMF</code> can be instantiated, only
objects from its sub-classes. However, those objects are
sometimes shortly referred in the documentation and
vignettes as &quot;<code>NMF</code> objects&quot; instead of &quot;objects
that inherits from class <code>NMF</code>&quot;.
</p>
<p>For built-in models or for models that inherit from the
standard model class <code><a href="#topic+NMFstd-class">NMFstd</a></code>, the
factory method <code>nmfModel</code> enables to easily create
valid <code>NMF</code> objects in a variety of common
situations. See documentation for the the factory method
<code><a href="#topic+nmfModel">nmfModel</a></code> for more details.
</p>


<h3>References</h3>

<p>Definition of Nonnegative Matrix Factorization in its
modern formulation: <cite>Lee et al. (1999)</cite>
</p>
<p>Historical first definition and algorithms: <cite>Paatero
et al. (1994)</cite>
</p>
<p>Lee DD and Seung HS (1999). &quot;Learning the parts of
objects by non-negative matrix factorization.&quot; _Nature_,
*401*(6755), pp. 788-91. ISSN 0028-0836, &lt;URL:
http://dx.doi.org/10.1038/44565&gt;, &lt;URL:
http://www.ncbi.nlm.nih.gov/pubmed/10548103&gt;.
</p>
<p>Paatero P and Tapper U (1994). &quot;Positive matrix
factorization: A non-negative factor model with optimal
utilization of error estimates of data values.&quot;
_Environmetrics_, *5*(2), pp. 111-126. &lt;URL:
http://dx.doi.org/10.1002/env.3170050203&gt;, &lt;URL:
http://www3.interscience.wiley.com/cgi-bin/abstract/113468839/ABSTRACT&gt;.
</p>


<h3>See Also</h3>

<p>Main interface to perform NMF in
<code><a href="#topic+nmf-methods">nmf-methods</a></code>.
</p>
<p>Built-in NMF models and factory method in
<code><a href="#topic+nmfModel">nmfModel</a></code>.
</p>
<p>Method <code><a href="#topic+seed">seed</a></code> to set NMF objects with values
suitable to start algorithms with.
</p>
<p>Other NMF-interface: <code><a href="#topic+basis">basis</a></code>,
<code><a href="#topic+.basis">.basis</a></code>, <code><a href="#topic+.basis+3C-">.basis&lt;-</a></code>,
<code><a href="#topic+basis+3C-">basis&lt;-</a></code>, <code><a href="#topic+coef">coef</a></code>,
<code><a href="#topic+.coef">.coef</a></code>, <code><a href="#topic+.coef+3C-">.coef&lt;-</a></code>,
<code><a href="#topic+coef+3C-">coef&lt;-</a></code>, <code><a href="#topic+coefficients">coefficients</a></code>,
<code><a href="#topic+loadings+2CNMF-method">loadings,NMF-method</a></code>,
<code><a href="#topic+nmfModel">nmfModel</a></code>, <code><a href="#topic+nmfModels">nmfModels</a></code>,
<code><a href="#topic+rnmf">rnmf</a></code>, <code><a href="#topic+scoef">scoef</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# show all the NMF models available (i.e. the classes that inherit from class NMF)
nmfModels()
# show all the built-in NMF models available
nmfModels(builtin.only=TRUE)

# class NMF is a virtual class so cannot be instantiated:
try( new('NMF') )

# To instantiate an NMF model, use the factory method nmfModel. see ?nmfModel
nmfModel()
nmfModel(3)
nmfModel(3, model='NMFns')
</code></pre>

<hr>
<h2 id='NMF-defunct'>Defunct Functions and Classes in the NMF Package</h2><span id='topic+metaHeatmap'></span><span id='topic+metaHeatmap+2Cmatrix-method'></span><span id='topic+metaHeatmap-methods'></span><span id='topic+metaHeatmap+2CNMFfitX-method'></span><span id='topic+metaHeatmap+2CNMF-method'></span><span id='topic+NMF-defunct'></span>

<h3>Description</h3>

<p>Defunct Functions and Classes in the NMF Package
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  metaHeatmap(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NMF-defunct_+3A_object">object</code></td>
<td>
<p>an R object</p>
</td></tr>
<tr><td><code id="NMF-defunct_+3A_...">...</code></td>
<td>
<p>other arguments</p>
</td></tr>
</table>


<h3>Methods</h3>


<dl>
<dt>metaHeatmap</dt><dd><p><code>signature(object = "matrix")</code>:
Defunct method substituted by <code><a href="#topic+aheatmap">aheatmap</a></code>. </p>
</dd>
<dt>metaHeatmap</dt><dd><p><code>signature(object = "NMF")</code>:
Deprecated method that is substituted by
<code><a href="#topic+coefmap">coefmap</a></code> and <code><a href="#topic+basismap">basismap</a></code>. </p>
</dd>
<dt>metaHeatmap</dt><dd><p><code>signature(object = "NMFfitX")</code>:
Deprecated method subsituted by
<code><a href="#topic+consensusmap">consensusmap</a></code>. </p>
</dd>
</dl>


<hr>
<h2 id='NMF-deprecated'>Deprecated Functions in the Package NMF</h2><span id='topic+NMF-deprecated'></span>

<h3>Description</h3>

<p>Deprecated Functions in the Package NMF
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="NMF-deprecated_+3A_object">object</code></td>
<td>
<p>an R object</p>
</td></tr>
<tr><td><code id="NMF-deprecated_+3A_...">...</code></td>
<td>
<p>extra arguments</p>
</td></tr>
</table>

<hr>
<h2 id='nmf.equal'>Testing Equality of NMF Models</h2><span id='topic+nmf.equal'></span><span id='topic+nmf.equal+2Clist+2Clist-method'></span><span id='topic+nmf.equal+2Clist+2Cmissing-method'></span><span id='topic+nmf.equal-methods'></span><span id='topic+nmf.equal+2CNMFfit+2CNMFfit-method'></span><span id='topic+nmf.equal+2CNMFfit+2CNMF-method'></span><span id='topic+nmf.equal+2CNMFfitX1+2CNMFfitX1-method'></span><span id='topic+nmf.equal+2CNMFfitX+2CNMF-method'></span><span id='topic+nmf.equal+2CNMF+2CNMFfit-method'></span><span id='topic+nmf.equal+2CNMF+2CNMFfitX-method'></span><span id='topic+nmf.equal+2CNMF+2CNMF-method'></span>

<h3>Description</h3>

<p>The function <code>nmf.equal</code> tests if two NMF models are
the same, i.e. they contain &ndash; almost &ndash; identical data:
same basis and coefficient matrices, as well as same
extra parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  nmf.equal(x, y, ...)

  ## S4 method for signature 'NMF,NMF'
nmf.equal(x, y, identical = TRUE,
    ...)

  ## S4 method for signature 'list,list'
nmf.equal(x, y, ..., all = FALSE,
    vector = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nmf.equal_+3A_x">x</code></td>
<td>
<p>an NMF model or an object that is associated
with an NMF model, e.g. the result from a fit with
<code><a href="#topic+nmf">nmf</a></code>.</p>
</td></tr>
<tr><td><code id="nmf.equal_+3A_y">y</code></td>
<td>
<p>an NMF model or an object that is associated
with an NMF model, e.g. the result from a fit with
<code><a href="#topic+nmf">nmf</a></code>.</p>
</td></tr>
<tr><td><code id="nmf.equal_+3A_identical">identical</code></td>
<td>
<p>a logical that indicates if the
comparison should be made using the function
<code><a href="base.html#topic+identical">identical</a></code> (<code>TRUE</code>) or
<code><a href="Matrix.html#topic+all.equal">all.equal</a></code> (<code>FALSE</code>). See description
for method <code>nmf.equal,NMF,NMF</code>.</p>
</td></tr>
<tr><td><code id="nmf.equal_+3A_...">...</code></td>
<td>
<p>extra arguments to allow extension, and passed
to subsequent calls</p>
</td></tr>
<tr><td><code id="nmf.equal_+3A_all">all</code></td>
<td>
<p>a logical that indicates if all fits should be
compared separately or only the best fits</p>
</td></tr>
<tr><td><code id="nmf.equal_+3A_vector">vector</code></td>
<td>
<p>a logical, only used when <code>all=TRUE</code>,
that indicates if all fits must be equal for <code>x</code> and
<code>y</code> to be declared equal, or if one wants to return
the result of each comparison in a vector.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>nmf.equal</code> compares two NMF models, and return
<code>TRUE</code> iff they are identical acording to the
function <code><a href="base.html#topic+identical">identical</a></code> when
<code>identical=TRUE</code>, or equal up to some tolerance
acording to the function <code><a href="Matrix.html#topic+all.equal">all.equal</a></code>. This
means that all data contained in the objects are
compared, which includes at least the basis and
coefficient matrices, as well as the extra parameters
stored in slot &lsquo;misc&rsquo;.
</p>
<p>If extra arguments are specified in <code>...</code>, then the
comparison is performed using <code><a href="Matrix.html#topic+all.equal">all.equal</a></code>,
irrespective of the value of argument <code>identical</code>.
</p>


<h3>Methods</h3>


<dl>
<dt>nmf.equal</dt><dd><p><code>signature(x = "NMF", y = "NMF")</code>:
Compares two NMF models.
</p>
<p>Arguments in <code>...</code> are used only when
<code>identical=FALSE</code> and are passed to
<code>all.equal</code>. </p>
</dd>
<dt>nmf.equal</dt><dd><p><code>signature(x = "NMFfit", y =
  "NMF")</code>: Compares two NMF models when at least one comes
from a NMFfit object, i.e. an object returned by a single
run of <code><a href="#topic+nmf">nmf</a></code>. </p>
</dd>
<dt>nmf.equal</dt><dd><p><code>signature(x = "NMF", y =
  "NMFfit")</code>: Compares two NMF models when at least one
comes from a NMFfit object, i.e. an object returned by a
single run of <code><a href="#topic+nmf">nmf</a></code>. </p>
</dd>
<dt>nmf.equal</dt><dd><p><code>signature(x = "NMFfit", y =
  "NMFfit")</code>: Compares two fitted NMF models, i.e. objects
returned by single runs of <code><a href="#topic+nmf">nmf</a></code>. </p>
</dd>
<dt>nmf.equal</dt><dd><p><code>signature(x = "NMFfitX", y =
  "NMF")</code>: Compares two NMF models when at least one comes
from multiple NMF runs. </p>
</dd>
<dt>nmf.equal</dt><dd><p><code>signature(x = "NMF", y =
  "NMFfitX")</code>: Compares two NMF models when at least one
comes from multiple NMF runs. </p>
</dd>
<dt>nmf.equal</dt><dd><p><code>signature(x = "NMFfitX1", y =
  "NMFfitX1")</code>: Compares the NMF models fitted by multiple
runs, that only kept the best fits. </p>
</dd>
<dt>nmf.equal</dt><dd><p><code>signature(x = "list", y =
  "list")</code>: Compares the results of multiple NMF runs.
</p>
<p>This method either compare the two best fit, or all fits
separately. All extra arguments in <code>...</code> are passed
to each internal call to <code>nmf.equal</code>. </p>
</dd>
<dt>nmf.equal</dt><dd><p><code>signature(x = "list", y =
  "missing")</code>: Compare all elements in <code>x</code> to
<code>x[[1]]</code>. </p>
</dd>
</dl>


<hr>
<h2 id='nmfAlgorithm'>Listing and Retrieving NMF Algorithms</h2><span id='topic+nmfAlgorithm'></span>

<h3>Description</h3>

<p><code>nmfAlgorithm</code> lists access keys or retrieves NMF
algorithms that are stored in registry. It allows to list
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  nmfAlgorithm(name = NULL, version = NULL, all = FALSE,
    ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nmfAlgorithm_+3A_name">name</code></td>
<td>
<p>Access key. If not missing, it must be a
single character string that is partially matched against
the available algorithms in the registry. In this case,
if <code>all=FALSE</code> (default), then the algorithm is
returned as an <code>NMFStrategy</code> object that can be
directly passed to <code><a href="#topic+nmf">nmf</a></code>. An error is thrown
if no matching algorithm is found.
</p>
<p>If missing or <code>NULL</code>, then access keys of algorithms
&ndash; that match the criteria <code>version</code>, are returned.
This argument is assumed to be regular expression if
<code>all=TRUE</code> or <code>version</code> is not <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="nmfAlgorithm_+3A_version">version</code></td>
<td>
<p>version of the algorithm(s) to retrieve.
Currently only value <code>'R'</code> is supported, which
searched for plain R implementations.</p>
</td></tr>
<tr><td><code id="nmfAlgorithm_+3A_all">all</code></td>
<td>
<p>a logical that indicates if all algorithm keys
should be returned, including the ones from alternative
algorithm versions (e.g. plain R implementations of
algorithms, for which a version based on optimised C
updates is used by default).</p>
</td></tr>
<tr><td><code id="nmfAlgorithm_+3A_...">...</code></td>
<td>
<p>extra arguments passed to
<code><a href="#topic+getNMFMethod">getNMFMethod</a></code> when <code>name</code> is not
<code>NULL</code> and <code>all=FALSE</code>. It is not used
otherwise.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an <code><a href="#topic+NMFStrategy-class">NMFStrategy</a></code> object if <code>name</code>
is not <code>NULL</code> and <code>all=FALSE</code>, or a named
character vector that contains the access keys of the
matching algorithms. The names correspond to the access
key of the primary algorithm: e.g. algorithm &lsquo;lee&rsquo;
has two registered versions, one plain R
(&lsquo;.R#lee&rsquo;) and the other uses optimised C updates
(&lsquo;lee&rsquo;), which will all get named &lsquo;lee&rsquo;.
</p>


<h3>See Also</h3>

<p>Other regalgo: <code><a href="#topic+canFit">canFit</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# list all main algorithms
nmfAlgorithm()
# list all versions of algorithms
nmfAlgorithm(all=TRUE)
# list all plain R versions
nmfAlgorithm(version='R')
</code></pre>

<hr>
<h2 id='nmfAlgorithm.SNMF_R'>NMF Algorithm - Sparse NMF via Alternating NNLS</h2><span id='topic+nmfAlgorithm.SNMF_L'></span><span id='topic+nmfAlgorithm.SNMF_R'></span><span id='topic+SNMF+2FL-nmf'></span><span id='topic+SNMF+2FR-nmf'></span>

<h3>Description</h3>

<p>NMF algorithms proposed by <cite>Kim et al. (2007)</cite> that
enforces sparsity constraint on the basis matrix
(algorithm &lsquo;SNMF/L&rsquo;) or the mixture coefficient
matrix (algorithm &lsquo;SNMF/R&rsquo;).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  nmfAlgorithm.SNMF_R(..., maxIter = 20000L, eta = -1,
    beta = 0.01, bi_conv = c(0, 10), eps_conv = 1e-04)

  nmfAlgorithm.SNMF_L(..., maxIter = 20000L, eta = -1,
    beta = 0.01, bi_conv = c(0, 10), eps_conv = 1e-04)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nmfAlgorithm.SNMF_R_+3A_maxiter">maxIter</code></td>
<td>
<p>maximum number of iterations.</p>
</td></tr>
<tr><td><code id="nmfAlgorithm.SNMF_R_+3A_eta">eta</code></td>
<td>
<p>parameter to suppress/bound the L2-norm of
<code>W</code> and in <code>H</code> in &lsquo;SNMF/R&rsquo; and
&lsquo;SNMF/L&rsquo; respectively.
</p>
<p>If <code>eta &lt; 0</code>, then it is set to the maximum value in
the target matrix is used.</p>
</td></tr>
<tr><td><code id="nmfAlgorithm.SNMF_R_+3A_beta">beta</code></td>
<td>
<p>regularisation parameter for sparsity
control, which balances the trade-off between the
accuracy of the approximation and the sparseness of
<code>H</code> and <code>W</code> in &lsquo;SNMF/R&rsquo; and
&lsquo;SNMF/L&rsquo; respectively.
</p>
<p>Larger beta generates higher sparseness on <code>H</code>
(resp. <code>W</code>). Too large beta is not recommended.</p>
</td></tr>
<tr><td><code id="nmfAlgorithm.SNMF_R_+3A_bi_conv">bi_conv</code></td>
<td>
<p>parameter of the biclustering convergence
test. It must be a size 2 numeric vector
<code>bi_conv=c(wminchange, iconv)</code>, with: </p>

<dl>
<dt><code>wminchange</code>:</dt><dd><p>the minimal allowance of change
in row-clusters.</p>
</dd> <dt><code>iconv</code>:</dt><dd><p> decide
convergence if row-clusters (within the allowance of
<code>wminchange</code>) and column-clusters have not changed
for <code>iconv</code> convergence checks.</p>
</dd> </dl>

<p>Convergence checks are performed every 5 iterations.</p>
</td></tr>
<tr><td><code id="nmfAlgorithm.SNMF_R_+3A_eps_conv">eps_conv</code></td>
<td>
<p>threshold for the KKT convergence test.</p>
</td></tr>
<tr><td><code id="nmfAlgorithm.SNMF_R_+3A_...">...</code></td>
<td>
<p>extra argument not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The algorithm &lsquo;SNMF/R&rsquo; solves the following NMF
optimization problem on a given target matrix <code class="reqn">A</code> of
dimension <code class="reqn">n \times p</code>: </p>
<p style="text-align: center;"><code class="reqn">
  \begin{array}{ll} &amp; \min_{W,H} \frac{1}{2} \left(|| A -
  WH ||_F^2 + \eta ||W||_F^2 + \beta (\sum_{j=1}^p
  ||H_{.j}||_1^2)\right)\\ s.t. &amp; W\geq 0, H\geq 0
  \end{array} </code>
</p>

<p>The algorithm &lsquo;SNMF/L&rsquo; solves a similar problem on
the transposed target matrix <code class="reqn">A</code>, where <code class="reqn">H</code> and
<code class="reqn">W</code> swap roles, i.e. with sparsity constraints
applied to <code>W</code>.
</p>


<h3>References</h3>

<p>Kim H and Park H (2007). &quot;Sparse non-negative matrix
factorizations via alternating non-negativity-constrained
least squares for microarray data analysis.&quot;
_Bioinformatics (Oxford, England)_, *23*(12), pp.
1495-502. ISSN 1460-2059, &lt;URL:
http://dx.doi.org/10.1093/bioinformatics/btm134&gt;, &lt;URL:
http://www.ncbi.nlm.nih.gov/pubmed/17483501&gt;.
</p>

<hr>
<h2 id='nmfApply'>Apply Function for NMF Objects</h2><span id='topic+nmfApply'></span>

<h3>Description</h3>

<p>The function <code>nmfApply</code> provides exteneded
<code>apply</code>-like functionality for objects of class
<code>NMF</code>. It enables to easily apply a function over
different margins of NMF models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  nmfApply(X, MARGIN, FUN, ..., simplify = TRUE,
    USE.NAMES = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nmfApply_+3A_x">X</code></td>
<td>
<p>an object that has suitable <code><a href="#topic+basis">basis</a></code>
and <code>coef</code> methods, e.g. an NMF model.</p>
</td></tr>
<tr><td><code id="nmfApply_+3A_margin">MARGIN</code></td>
<td>
<p>a single numeric (integer) value that
specifies over which margin(s) the function <code>FUN</code> is
applied. See section <em>Details</em> for a list of
possible values.</p>
</td></tr>
<tr><td><code id="nmfApply_+3A_fun">FUN</code></td>
<td>
<p>a function to apply over the specified
margins.</p>
</td></tr>
<tr><td><code id="nmfApply_+3A_...">...</code></td>
<td>
<p>extra arguments passed to <code>FUN</code></p>
</td></tr>
<tr><td><code id="nmfApply_+3A_simplify">simplify</code></td>
<td>
<p>a logical only used when <code>MARGIN=3</code>,
that indicates if <code>sapply</code> should try to simplify
result if possible. Since this argument follows
&lsquo;...&rsquo; its name cannot be abbreviated.</p>
</td></tr>
<tr><td><code id="nmfApply_+3A_use.names">USE.NAMES</code></td>
<td>
<p>a logical only used when
<code>MARGIN=3</code>, that indicates if <code>sapply</code> should
use the names of the basis components to name the results
if present. Since this argument follows &lsquo;...&rsquo; its
name cannot be abbreviated.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>FUN</code> is applied via a call to
<code><a href="base.html#topic+apply">apply</a></code> or <code><a href="base.html#topic+sapply">sapply</a></code> according to
the value of argument <code>MARGIN</code> as follows:
</p>
 <dl>
<dt>MARGIN=1</dt><dd><p> apply <code>FUN</code> to each
<em>row</em> of the basis matrix: <code>apply(basis(X), 1L,
  FUN, ...)</code>.</p>
</dd>
<dt>MARGIN=2</dt><dd><p> apply <code>FUN</code> to each <em>column</em>
of the coefficient matrix: <code>apply(coef(X), 2L, FUN,
  ...)</code>.</p>
</dd>
<dt>MARGIN=3</dt><dd><p> apply <code>FUN</code> to each <em>pair</em> of
associated basis component and basis profile: more or
less <code>sapply(seq(nbasis(X)), function(i, ...)
  FUN(basis(X)[,i], coef(X)[i, ], ...), ...)</code>.
</p>
<p>In this case <code>FUN</code> must be have at least two
arguments, to which are passed each basis components and
basis profiles respectively &ndash; as numeric vectors.</p>
</dd>
<dt>MARGIN=4</dt><dd><p> apply <code>FUN</code> to each <em>column</em>
of the basis matrix, i.e. to each basis component:
<code>apply(basis(X), 2L, FUN, ...)</code>.</p>
</dd>
<dt>MARGIN=5</dt><dd><p> apply <code>FUN</code> to each <em>row</em> of
the coefficient matrix: <code>apply(coef(X), 1L, FUN,
  ...)</code>.</p>
</dd>
</dl>



<h3>Value</h3>

<p>a vector or a list. See <code><a href="base.html#topic+apply">apply</a></code> and
<code><a href="base.html#topic+sapply">sapply</a></code> for more details on the output
format.
</p>

<hr>
<h2 id='nmfCheck'>Checking NMF Algorithm</h2><span id='topic+nmfCheck'></span>

<h3>Description</h3>

<p><code>nmfCheck</code> enables to quickly check that a given NMF
algorithm runs properly, by applying it to some small
random data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  nmfCheck(method = NULL, rank = max(ncol(x)/5, 3),
    x = NULL, seed = 1234, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nmfCheck_+3A_method">method</code></td>
<td>
<p>name of the NMF algorithm to be tested.</p>
</td></tr>
<tr><td><code id="nmfCheck_+3A_rank">rank</code></td>
<td>
<p>rank of the factorization</p>
</td></tr>
<tr><td><code id="nmfCheck_+3A_x">x</code></td>
<td>
<p>target data. If <code>NULL</code>, a random 20 x 10
matrix is generated</p>
</td></tr>
<tr><td><code id="nmfCheck_+3A_seed">seed</code></td>
<td>
<p>specifies a seed or seeding method for the
computation.</p>
</td></tr>
<tr><td><code id="nmfCheck_+3A_...">...</code></td>
<td>
<p>other arguments passed to the call to
<code><a href="#topic+nmf">nmf</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the result of the NMF fit invisibly.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# test default algorithm
nmfCheck()

# test 'lee' algorithm
nmfCheck('lee')
</code></pre>

<hr>
<h2 id='nmfEstimateRank'>Estimate Rank for NMF Models</h2><span id='topic+nmfEstimateRank'></span><span id='topic+plot.NMF.rank'></span>

<h3>Description</h3>

<p>A critical parameter in NMF algorithms is the
factorization rank <code class="reqn">r</code>. It defines the number of
basis effects used to approximate the target matrix.
Function <code>nmfEstimateRank</code> helps in choosing an
optimal rank by implementing simple approaches proposed
in the literature.
</p>
<p>Note that from version <em>0.7</em>, one can equivalently
call the function <code><a href="#topic+nmf">nmf</a></code> with a range of
ranks.
</p>
<p>In the plot generated by <code>plot.NMF.rank</code>, each curve
represents a summary measure over the range of ranks in
the survey. The colours correspond to the type of data to
which the measure is related: coefficient matrix, basis
component matrix, best fit, or consensus matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  nmfEstimateRank(x, range,
    method = nmf.getOption("default.algorithm"), nrun = 30,
    model = NULL, ..., verbose = FALSE, stop = FALSE)

  ## S3 method for class 'NMF.rank'
 plot(x, y = NULL,
    what = c("all", "cophenetic", "rss", "residuals", "dispersion", "evar", 
        "sparseness", "sparseness.basis", "sparseness.coef", "silhouette", 
        "silhouette.coef", "silhouette.basis", "silhouette.consensus"),
    na.rm = FALSE, xname = "x", yname = "y",
    xlab = "Factorization rank", ylab = "",
    main = "NMF rank survey", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nmfEstimateRank_+3A_x">x</code></td>
<td>
<p>For <code>nmfEstimateRank</code> a target object to be
estimated, in one of the format accepted by interface
<code><a href="#topic+nmf">nmf</a></code>.
</p>
<p>For <code>plot.NMF.rank</code> an object of class
<code>NMF.rank</code> as returned by function
<code>nmfEstimateRank</code>.</p>
</td></tr>
<tr><td><code id="nmfEstimateRank_+3A_range">range</code></td>
<td>
<p>a <code>numeric</code> vector containing the ranks
of factorization to try. Note that duplicates are removed
and values are sorted in increasing order. The results
are notably returned in this order.</p>
</td></tr>
<tr><td><code id="nmfEstimateRank_+3A_method">method</code></td>
<td>
<p>A single NMF algorithm, in one of the
format accepted by the function <code><a href="#topic+nmf">nmf</a></code>.</p>
</td></tr>
<tr><td><code id="nmfEstimateRank_+3A_nrun">nrun</code></td>
<td>
<p>a <code>numeric</code> giving the number of run to
perform for each value in <code>range</code>.</p>
</td></tr>
<tr><td><code id="nmfEstimateRank_+3A_model">model</code></td>
<td>
<p>model specification passed to each
<code>nmf</code> call. In particular, when <code>x</code> is a
formula, it is passed to argument <code>data</code> of
<code><a href="#topic+nmfModel">nmfModel</a></code> to determine the target matrix &ndash;
and fixed terms.</p>
</td></tr>
<tr><td><code id="nmfEstimateRank_+3A_verbose">verbose</code></td>
<td>
<p>toggle verbosity.  This parameter only
affects the verbosity of the outer loop over the values
in <code>range</code>. To print verbose (resp. debug) messages
from each NMF run, one can use <code>.options='v'</code> (resp.
<code>.options='d'</code>) that will be passed to the function
<code><a href="#topic+nmf">nmf</a></code>.</p>
</td></tr>
<tr><td><code id="nmfEstimateRank_+3A_stop">stop</code></td>
<td>
<p>logical flag for running the estimation
process with fault tolerance.  When <code>TRUE</code>, the
whole execution will stop if any error is raised.  When
<code>FALSE</code> (default), the runs that raise an error will
be skipped, and the execution will carry on. The summary
measures for the runs with errors are set to NA values,
and a warning is thrown.</p>
</td></tr>
<tr><td><code id="nmfEstimateRank_+3A_...">...</code></td>
<td>
<p>For <code>nmfEstimateRank</code>, these are extra
parameters passed to interface <code>nmf</code>. Note that the
same parameters are used for each value of the rank.  See
<code><a href="#topic+nmf">nmf</a></code>.
</p>
<p>For <code>plot.NMF.rank</code>, these are extra graphical
parameter passed to the standard function <code>plot</code>.
See <code><a href="graphics.html#topic+plot">plot</a></code>.</p>
</td></tr>
<tr><td><code id="nmfEstimateRank_+3A_y">y</code></td>
<td>
<p>reference object of class <code>NMF.rank</code>, as
returned by function <code>nmfEstimateRank</code>. The measures
contained in <code>y</code> are used and plotted as a
reference. It is typically used to plot results obtained
from randomized data. The associated curves are drawn in
<em>red</em> (and <em>pink</em>), while those from <code>x</code>
are drawn in <em>blue</em> (and <em>green</em>).</p>
</td></tr>
<tr><td><code id="nmfEstimateRank_+3A_what">what</code></td>
<td>
<p>a <code>character</code> vector whose elements
partially match one of the following item, which
correspond to the measures computed by
<code><a href="#topic+summary">summary</a></code> on each &ndash; multi-run &ndash; NMF result:
&lsquo;all&rsquo;, &lsquo;cophenetic&rsquo;, &lsquo;rss&rsquo;,
&lsquo;residuals&rsquo;, &lsquo;dispersion&rsquo;, &lsquo;evar&rsquo;,
&lsquo;silhouette&rsquo; (and more specific *.coef, *.basis,
*.consensus), &lsquo;sparseness&rsquo; (and more specific
*.coef, *.basis). It specifies which measure must be
plotted (<code>what='all'</code> plots all the measures).</p>
</td></tr>
<tr><td><code id="nmfEstimateRank_+3A_na.rm">na.rm</code></td>
<td>
<p>single logical that specifies if the rank
for which the measures are NA values should be removed
from the graph or not (default to <code>FALSE</code>).  This is
useful when plotting results which include NAs due to
error during the estimation process. See argument
<code>stop</code> for <code>nmfEstimateRank</code>.</p>
</td></tr>
<tr><td><code id="nmfEstimateRank_+3A_xname">xname</code>, <code id="nmfEstimateRank_+3A_yname">yname</code></td>
<td>
<p>legend labels for the curves
corresponding to measures from <code>x</code> and <code>y</code>
respectively</p>
</td></tr>
<tr><td><code id="nmfEstimateRank_+3A_xlab">xlab</code></td>
<td>
<p>x-axis label</p>
</td></tr>
<tr><td><code id="nmfEstimateRank_+3A_ylab">ylab</code></td>
<td>
<p>y-axis label</p>
</td></tr>
<tr><td><code id="nmfEstimateRank_+3A_main">main</code></td>
<td>
<p>main title</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given a NMF algorithm and the target matrix, a common way
of estimating <code class="reqn">r</code> is to try different values, compute
some quality measures of the results, and choose the best
value according to this quality criteria. See
<cite>Brunet et al. (2004)</cite> and <cite>Hutchins et al.
(2008)</cite>.
</p>
<p>The function <code>nmfEstimateRank</code> allows to perform
this estimation procedure. It performs multiple NMF runs
for a range of rank of factorization and, for each,
returns a set of quality measures together with the
associated consensus matrix.
</p>
<p>In order to avoid overfitting, it is recommended to run
the same procedure on randomized data. The results on the
original and the randomised data may be plotted on the
same plots, using argument <code>y</code>.
</p>


<h3>Value</h3>

<p><code>nmfEstimateRank</code> returns a S3 object (i.e. a list)
of class <code>NMF.rank</code> with the following elements:
</p>
<table>
<tr><td><code>measures</code></td>
<td>
<p>a <code>data.frame</code> containing the
quality measures for each rank of factorizations in
<code>range</code>. Each row corresponds to a measure, each
column to a rank. </p>
</td></tr> <tr><td><code>consensus</code></td>
<td>
<p> a <code>list</code> of
consensus matrices, indexed by the rank of factorization
(as a character string).</p>
</td></tr> <tr><td><code>fit</code></td>
<td>
<p> a <code>list</code> of
the fits, indexed by the rank of factorization (as a
character string).</p>
</td></tr>
</table>


<h3>References</h3>

<p>Brunet J, Tamayo P, Golub TR and Mesirov JP (2004).
&quot;Metagenes and molecular pattern discovery using matrix
factorization.&quot; _Proceedings of the National Academy of
Sciences of the United States of America_, *101*(12), pp.
4164-9. ISSN 0027-8424, &lt;URL:
http://dx.doi.org/10.1073/pnas.0308531101&gt;, &lt;URL:
http://www.ncbi.nlm.nih.gov/pubmed/15016911&gt;.
</p>
<p>Hutchins LN, Murphy SM, Singh P and Graber JH (2008).
&quot;Position-dependent motif characterization using
non-negative matrix factorization.&quot; _Bioinformatics
(Oxford, England)_, *24*(23), pp. 2684-90. ISSN
1367-4811, &lt;URL:
http://dx.doi.org/10.1093/bioinformatics/btn526&gt;, &lt;URL:
http://www.ncbi.nlm.nih.gov/pubmed/18852176&gt;.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

if( !isCHECK() ){

set.seed(123456)
n &lt;- 50; r &lt;- 3; m &lt;- 20
V &lt;- syntheticNMF(n, r, m)

# Use a seed that will be set before each first run
res &lt;- nmfEstimateRank(V, seq(2,5), method='brunet', nrun=10, seed=123456)
# or equivalently
res &lt;- nmf(V, seq(2,5), method='brunet', nrun=10, seed=123456)

# plot all the measures
plot(res)
# or only one: e.g. the cophenetic correlation coefficient
plot(res, 'cophenetic')

# run same estimation on randomized data
rV &lt;- randomize(V)
rand &lt;- nmfEstimateRank(rV, seq(2,5), method='brunet', nrun=10, seed=123456)
plot(res, rand)
}
</code></pre>

<hr>
<h2 id='NMFfit-class'>Base Class for to store Nonnegative Matrix Factorisation results</h2><span id='topic+NMFfit'></span><span id='topic+NMFfit-class'></span>

<h3>Description</h3>

<p>Base class to handle the results of general
<strong>Nonnegative Matrix Factorisation</strong> algorithms
(NMF).
</p>
<p>The function <code>NMFfit</code> is a factory method for NMFfit
objects, that should not need to be called by the user.
It is used internally by the functions <code><a href="#topic+nmf">nmf</a></code>
and <code>seed</code> to instantiate the starting point of NMF
algorithms.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  NMFfit(fit = nmfModel(), ..., rng = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NMFfit-class_+3A_fit">fit</code></td>
<td>
<p>an NMF model</p>
</td></tr>
<tr><td><code id="NMFfit-class_+3A_...">...</code></td>
<td>
<p>extra argument used to initialise slots in the
instantiating <code>NMFfit</code> object.</p>
</td></tr>
<tr><td><code id="NMFfit-class_+3A_rng">rng</code></td>
<td>
<p>RNG settings specification (typically a
suitable value for <code><a href="base.html#topic+.Random.seed">.Random.seed</a></code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It provides a general structure and generic functions to
manage the results of NMF algorithms.  It contains a slot
with the fitted NMF model (see slot <code>fit</code>) as well
as data about the methods and parameters used to compute
the factorization.
</p>
<p>The purpose of this class is to handle in a generic way
the results of NMF algorithms. Its slot <code>fit</code>
contains the fitted NMF model as an object of class
<code><a href="#topic+NMF-class">NMF</a></code>.
</p>
<p>Other slots contains data about how the factorization has
been computed, such as the algorithm and seeding method,
the computation time, the final residuals, etc...
</p>
<p>Class <code>NMFfit</code> acts as a wrapper class for its slot
<code>fit</code>.  It inherits from interface class
<code><a href="#topic+NMF-class">NMF</a></code> defined for generic NMF models.
Therefore, all the methods defined by this interface can
be called directly on objects of class <code>NMFfit</code>. The
calls are simply dispatched on slot <code>fit</code>, i.e.  the
results are the same as if calling the methods directly
on slot <code>fit</code>.
</p>


<h3>Slots</h3>


<dl>
<dt>fit</dt><dd><p>An object that inherits from class
<code><a href="#topic+NMF-class">NMF</a></code>, and contains the fitted NMF
model.
</p>
<p>NB: class <code>NMF</code> is a virtual class. The default
class for this slot is <code>NMFstd</code>, that implements the
standard NMF model.</p>
</dd>
<dt>residuals</dt><dd><p>A <code>numeric</code> vector that contains
the final residuals or the residuals track between the
target matrix and its NMF estimate(s).  Default value is
<code>numeric()</code>.
</p>
<p>See method <code><a href="#topic+residuals">residuals</a></code> for details on
accessor methods and main interface <code><a href="#topic+nmf">nmf</a></code> for
details on how to compute NMF with residuals tracking.</p>
</dd>
<dt>method</dt><dd><p>a single <code>character</code> string that
contains the name of the algorithm used to fit the model.
Default value is <code>''</code>.</p>
</dd>
<dt>seed</dt><dd><p>a single <code>character</code> string that
contains the name of the seeding method used to seed the
algorithm that fitted the NMF model. Default value is
<code>''</code>.  See <code><a href="#topic+nmf">nmf</a></code> for more details.</p>
</dd>
<dt>rng</dt><dd><p>an object that contains the RNG settings used
for the fit. Currently the settings are stored as an
integer vector, the value of <code><a href="base.html#topic+.Random.seed">.Random.seed</a></code>
at the time the object is created. It is initialized by
the <code>initialized</code> method. See <code><a href="rngtools.html#topic+getRNG">getRNG</a></code>
for more details.</p>
</dd>
<dt>distance</dt><dd><p>either a single <code>"character"</code> string
that contains the name of the built-in objective
function, or a <code>function</code> that measures the
residuals between the target matrix and its NMF estimate.
See <code><a href="#topic+objective">objective</a></code> and
<code><a href="#topic+deviance+2CNMF-method">deviance,NMF-method</a></code>.</p>
</dd>
<dt>parameters</dt><dd><p>a <code>list</code> that contains the extra
parameters &ndash; usually specific to the algorithm &ndash; that
were used to fit the model.</p>
</dd>
<dt>runtime</dt><dd><p>object of class <code>"proc_time"</code> that
contains various measures of the time spent to fit the
model. See <code><a href="base.html#topic+system.time">system.time</a></code></p>
</dd>
<dt>options</dt><dd><p>a <code>list</code> that contains the options
used to compute the object.</p>
</dd>
<dt>extra</dt><dd><p>a <code>list</code> that contains extra
miscellaneous data for internal usage only. For example
it can be used to store extra parameters or temporary
data, without the need to explicitly extend the
<code>NMFfit</code> class. Currently built-in algorithms only
use this slot to store the number of iterations performed
to fit the object.
</p>
<p>Data that need to be easily accessible by the end-user
should rather be set using the methods <code>$&lt;-</code> that
sets elements in the <code>list</code> slot <code>misc</code> &ndash; that
is inherited from class <code><a href="#topic+NMF-class">NMF</a></code>.</p>
</dd>
<dt>call</dt><dd><p>stored call to the last <code>nmf</code> method
that generated the object.</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>algorithm</dt><dd><p><code>signature(object = "NMFfit")</code>:
Returns the name of the algorithm that fitted the NMF
model <code>object</code>. </p>
</dd>
<dt>.basis</dt><dd><p><code>signature(object = "NMFfit")</code>:
Returns the basis matrix from an NMF model fitted with
function <code><a href="#topic+nmf">nmf</a></code>.
</p>
<p>It is a shortcut for <code>.basis(fit(object), ...)</code>,
dispatching the call to the <code>.basis</code> method of the
actual NMF model. </p>
</dd>
<dt>.basis&lt;-</dt><dd><p><code>signature(object = "NMFfit", value
  = "matrix")</code>: Sets the the basis matrix of an NMF model
fitted with function <code><a href="#topic+nmf">nmf</a></code>.
</p>
<p>It is a shortcut for <code>.basis(fit(object)) &lt;- value</code>,
dispatching the call to the <code>.basis&lt;-</code> method of the
actual NMF model. It is not meant to be used by the user,
except when developing NMF algorithms, to update the
basis matrix of the seed object before returning it. </p>
</dd>
<dt>.coef</dt><dd><p><code>signature(object = "NMFfit")</code>: Returns
the the coefficient matrix from an NMF model fitted with
function <code><a href="#topic+nmf">nmf</a></code>.
</p>
<p>It is a shortcut for <code>.coef(fit(object), ...)</code>,
dispatching the call to the <code>.coef</code> method of the
actual NMF model. </p>
</dd>
<dt>.coef&lt;-</dt><dd><p><code>signature(object = "NMFfit", value =
  "matrix")</code>: Sets the the coefficient matrix of an NMF
model fitted with function <code><a href="#topic+nmf">nmf</a></code>.
</p>
<p>It is a shortcut for <code>.coef(fit(object)) &lt;- value</code>,
dispatching the call to the <code>.coef&lt;-</code> method of the
actual NMF model. It is not meant to be used by the user,
except when developing NMF algorithms, to update the
coefficient matrix in the seed object before returning
it. </p>
</dd>
<dt>compare</dt><dd><p><code>signature(object = "NMFfit")</code>:
Compare multiple NMF fits passed as arguments. </p>
</dd>
<dt>deviance</dt><dd><p><code>signature(object = "NMFfit")</code>:
Returns the deviance of a fitted NMF model.
</p>
<p>This method returns the final residual value if the
target matrix <code>y</code> is not supplied, or the
approximation error between the fitted NMF model stored
in <code>object</code> and <code>y</code>. In this case, the
computation is performed using the objective function
<code>method</code> if not missing, or the objective of the
algorithm that fitted the model (stored in slot
<code>'distance'</code>).
</p>
<p>See <code><a href="#topic+deviance+2CNMFfit-method">deviance,NMFfit-method</a></code> for more
details. </p>
</dd>
<dt>fit</dt><dd><p><code>signature(object = "NMFfit")</code>: Returns
the NMF model object stored in slot <code>'fit'</code>. </p>
</dd>
<dt>fit&lt;-</dt><dd><p><code>signature(object = "NMFfit", value =
  "NMF")</code>: Updates the NMF model object stored in slot
<code>'fit'</code> with a new value. </p>
</dd>
<dt>fitted</dt><dd><p><code>signature(object = "NMFfit")</code>:
Computes and return the estimated target matrix from an
NMF model fitted with function <code><a href="#topic+nmf">nmf</a></code>.
</p>
<p>It is a shortcut for <code>fitted(fit(object), ...)</code>,
dispatching the call to the <code>fitted</code> method of the
actual NMF model. </p>
</dd>
<dt>ibterms</dt><dd><p><code>signature(object = "NMFfit")</code>:
Method for single NMF fit objects, which returns the
indexes of fixed basis terms from the fitted model. </p>
</dd>
<dt>icterms</dt><dd><p><code>signature(object = "NMFfit")</code>:
Method for single NMF fit objects, which returns the
indexes of fixed coefficient terms from the fitted model.
</p>
</dd>
<dt>icterms</dt><dd><p><code>signature(object = "NMFfit")</code>:
Method for multiple NMF fit objects, which returns the
indexes of fixed coefficient terms from the best fitted
model. </p>
</dd>
<dt>minfit</dt><dd><p><code>signature(object = "NMFfit")</code>:
Returns the object its self, since there it is the result
of a single NMF run. </p>
</dd>
<dt>modelname</dt><dd><p><code>signature(object = "NMFfit")</code>:
Returns the type of a fitted NMF model. It is a shortcut
for <code>modelname(fit(object)</code>. </p>
</dd>
<dt>niter</dt><dd><p><code>signature(object = "NMFfit")</code>: Returns
the number of iteration performed to fit an NMF model,
typically with function <code><a href="#topic+nmf">nmf</a></code>.
</p>
<p>Currently this data is stored in slot <code>'extra'</code>, but
this might change in the future. </p>
</dd>
<dt>niter&lt;-</dt><dd><p><code>signature(object = "NMFfit", value =
  "numeric")</code>: Sets the number of iteration performed to
fit an NMF model.
</p>
<p>This function is used internally by the function
<code><a href="#topic+nmf">nmf</a></code>. It is not meant to be called by the
user, except when developing new NMF algorithms
implemented as single function, to set the number of
iterations performed by the algorithm on the seed, before
returning it (see
<code><a href="#topic+NMFStrategyFunction-class">NMFStrategyFunction</a></code>). </p>
</dd>
<dt>nmf.equal</dt><dd><p><code>signature(x = "NMFfit", y =
  "NMF")</code>: Compares two NMF models when at least one comes
from a NMFfit object, i.e. an object returned by a single
run of <code><a href="#topic+nmf">nmf</a></code>. </p>
</dd>
<dt>nmf.equal</dt><dd><p><code>signature(x = "NMFfit", y =
  "NMFfit")</code>: Compares two fitted NMF models, i.e. objects
returned by single runs of <code><a href="#topic+nmf">nmf</a></code>. </p>
</dd>
<dt>NMFfitX</dt><dd><p><code>signature(object = "NMFfit")</code>:
Creates an <code>NMFfitX1</code> object from a single fit. This
is used in <code><a href="#topic+nmf">nmf</a></code> when only the best fit is
kept in memory or on disk. </p>
</dd>
<dt>nrun</dt><dd><p><code>signature(object = "NMFfit")</code>: This
method always returns 1, since an <code>NMFfit</code> object is
obtained from a single NMF run. </p>
</dd>
<dt>objective</dt><dd><p><code>signature(object = "NMFfit")</code>:
Returns the objective function associated with the
algorithm that computed the fitted NMF model
<code>object</code>, or the objective value with respect to a
given target matrix <code>y</code> if it is supplied. </p>
</dd>
<dt>offset</dt><dd><p><code>signature(object = "NMFfit")</code>:
Returns the offset from the fitted model. </p>
</dd>
<dt>plot</dt><dd><p><code>signature(x = "NMFfit", y =
  "missing")</code>: Plots the residual track computed at regular
interval during the fit of the NMF model <code>x</code>. </p>
</dd>
<dt>residuals</dt><dd><p><code>signature(object = "NMFfit")</code>:
Returns the residuals &ndash; track &ndash; between the target
matrix and the NMF fit <code>object</code>. </p>
</dd>
<dt>runtime</dt><dd><p><code>signature(object = "NMFfit")</code>:
Returns the CPU time required to compute a single NMF
fit. </p>
</dd>
<dt>runtime.all</dt><dd><p><code>signature(object = "NMFfit")</code>:
Identical to <code>runtime</code>, since their is a single fit.
</p>
</dd>
<dt>seeding</dt><dd><p><code>signature(object = "NMFfit")</code>:
Returns the name of the seeding method that generated the
starting point for the NMF algorithm that fitted the NMF
model <code>object</code>. </p>
</dd>
<dt>show</dt><dd><p><code>signature(object = "NMFfit")</code>: Show
method for objects of class <code>NMFfit</code> </p>
</dd>
<dt>summary</dt><dd><p><code>signature(object = "NMFfit")</code>:
Computes summary measures for a single fit from
<code><a href="#topic+nmf">nmf</a></code>.
</p>
<p>This method adds the following measures to the measures
computed by the method <code>summary,NMF</code>:
</p>
<p>See <code><a href="#topic+summary+2CNMFfit-method">summary,NMFfit-method</a></code> for more details.
</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>

# run default NMF algorithm on a random matrix
n &lt;- 50; r &lt;- 3; p &lt;- 20
V &lt;- rmatrix(n, p)
res &lt;- nmf(V, r)

# result class is NMFfit
class(res)
isNMFfit(res)

# show result
res

# compute summary measures
summary(res, target=V)
</code></pre>

<hr>
<h2 id='NMFfitX'>Factory Method for Multiple NMF Run Objects</h2><span id='topic+NMFfitX'></span><span id='topic+NMFfitX+2Clist-method'></span><span id='topic+NMFfitX-methods'></span><span id='topic+NMFfitX+2CNMFfit-method'></span><span id='topic+NMFfitX+2CNMFfitX-method'></span>

<h3>Description</h3>

<p>Factory Method for Multiple NMF Run Objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  NMFfitX(object, ...)

  ## S4 method for signature 'list'
NMFfitX(object, ..., .merge = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NMFfitX_+3A_object">object</code></td>
<td>
<p>an object from which is created an
<code>NMFfitX</code> object</p>
</td></tr>
<tr><td><code id="NMFfitX_+3A_...">...</code></td>
<td>
<p>extra arguments used to pass values for slots</p>
</td></tr>
<tr><td><code id="NMFfitX_+3A_.merge">.merge</code></td>
<td>
<p>a logical that indicates if the fits should
be aggregated, only keeping the best fit, and return an
<code>NMFfitX1</code> object. If <code>FALSE</code>, an
<code>NMFfitXn</code> object containing the data of all the
fits is returned.</p>
</td></tr>
</table>


<h3>Methods</h3>


<dl>
<dt>NMFfitX</dt><dd><p><code>signature(object = "list")</code>: Create
an <code>NMFfitX</code> object from a list of fits. </p>
</dd>
<dt>NMFfitX</dt><dd><p><code>signature(object = "NMFfit")</code>:
Creates an <code>NMFfitX1</code> object from a single fit. This
is used in <code><a href="#topic+nmf">nmf</a></code> when only the best fit is
kept in memory or on disk. </p>
</dd>
<dt>NMFfitX</dt><dd><p><code>signature(object = "NMFfitX")</code>:
Provides a way to aggregate <code>NMFfitXn</code> objects into
an <code>NMFfitX1</code> object. </p>
</dd>
</dl>


<hr>
<h2 id='NMFfitX-class'>Virtual Class to Handle Results from Multiple Runs of NMF Algorithms</h2><span id='topic+NMFfitX-class'></span>

<h3>Description</h3>

<p>This class defines a common interface to handle the
results from multiple runs of a single NMF algorithm,
performed with the <code><a href="#topic+nmf">nmf</a></code> method.
</p>


<h3>Details</h3>

<p>Currently, this interface is implemented by two classes,
<code><a href="#topic+NMFfitX1-class">NMFfitX1</a></code> and
<code><a href="#topic+NMFfitXn-class">NMFfitXn</a></code>, which respectively handle
the case where only the best fit is kept, and the case
where the list of all the fits is returned.
</p>
<p>See <code><a href="#topic+nmf">nmf</a></code> for more details on the method
arguments.
</p>


<h3>Slots</h3>


<dl>
<dt>runtime.all</dt><dd><p>Object of class
<code><a href="base.html#topic+proc.time">proc_time</a></code> that contains CPU
times required to perform all the runs.</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>basismap</dt><dd><p><code>signature(object = "NMFfitX")</code>:
Plots a heatmap of the basis matrix of the best fit in
<code>object</code>. </p>
</dd>
<dt>coefmap</dt><dd><p><code>signature(object = "NMFfitX")</code>:
Plots a heatmap of the coefficient matrix of the best fit
in <code>object</code>.
</p>
<p>This method adds: </p>
 <ul>
<li><p> an extra special column
annotation track for multi-run NMF fits,
<code>'consensus:'</code>, that shows the consensus cluster
associated to each sample. </p>
</li>
<li><p> a column sorting schema
<code>'consensus'</code> that can be passed to argument
<code>Colv</code> and orders the columns using the hierarchical
clustering of the consensus matrix with average linkage,
as returned by <code><a href="#topic+consensushc">consensushc</a>(object)</code>. This is
also the ordering that is used by default for the heatmap
of the consensus matrix as ploted by
<code><a href="#topic+consensusmap">consensusmap</a></code>. </p>
</li></ul>
 </dd>
<dt>consensus</dt><dd><p><code>signature(object = "NMFfitX")</code>:
Pure virtual method defined to ensure <code>consensus</code> is
defined for sub-classes of <code>NMFfitX</code>. It throws an
error if called. </p>
</dd>
<dt>consensushc</dt><dd><p><code>signature(object = "NMFfitX")</code>:
Compute the hierarchical clustering on the consensus
matrix of <code>object</code>, or on the connectivity matrix of
the best fit in <code>object</code>. </p>
</dd>
<dt>consensusmap</dt><dd><p><code>signature(object = "NMFfitX")</code>:
Plots a heatmap of the consensus matrix obtained when
fitting an NMF model with multiple runs. </p>
</dd>
<dt>cophcor</dt><dd><p><code>signature(object = "NMFfitX")</code>:
Computes the cophenetic correlation coefficient on the
consensus matrix of <code>object</code>. All arguments in
<code>...</code> are passed to the method
<code>cophcor,matrix</code>. </p>
</dd>
<dt>deviance</dt><dd><p><code>signature(object = "NMFfitX")</code>:
Returns the deviance achieved by the best fit object,
i.e. the lowest deviance achieved across all NMF runs. </p>
</dd>
<dt>dispersion</dt><dd><p><code>signature(object = "NMFfitX")</code>:
Computes the dispersion on the consensus matrix obtained
from multiple NMF runs. </p>
</dd>
<dt>fit</dt><dd><p><code>signature(object = "NMFfitX")</code>: Returns
the model object that achieves the lowest residual
approximation error across all the runs.
</p>
<p>It is a pure virtual method defined to ensure <code>fit</code>
is defined for sub-classes of <code>NMFfitX</code>, which
throws an error if called. </p>
</dd>
<dt>getRNG1</dt><dd><p><code>signature(object = "NMFfitX")</code>:
Returns the RNG settings used for the first NMF run of
multiple NMF runs. </p>
</dd>
<dt>ibterms</dt><dd><p><code>signature(object = "NMFfitX")</code>:
Method for multiple NMF fit objects, which returns the
indexes of fixed basis terms from the best fitted model.
</p>
</dd>
<dt>metaHeatmap</dt><dd><p><code>signature(object = "NMFfitX")</code>:
Deprecated method subsituted by
<code><a href="#topic+consensusmap">consensusmap</a></code>. </p>
</dd>
<dt>minfit</dt><dd><p><code>signature(object = "NMFfitX")</code>:
Returns the fit object that achieves the lowest residual
approximation error across all the runs.
</p>
<p>It is a pure virtual method defined to ensure
<code>minfit</code> is defined for sub-classes of
<code>NMFfitX</code>, which throws an error if called. </p>
</dd>
<dt>nmf.equal</dt><dd><p><code>signature(x = "NMFfitX", y =
  "NMF")</code>: Compares two NMF models when at least one comes
from multiple NMF runs. </p>
</dd>
<dt>NMFfitX</dt><dd><p><code>signature(object = "NMFfitX")</code>:
Provides a way to aggregate <code>NMFfitXn</code> objects into
an <code>NMFfitX1</code> object. </p>
</dd>
<dt>nrun</dt><dd><p><code>signature(object = "NMFfitX")</code>: Returns
the number of NMF runs performed to create <code>object</code>.
</p>
<p>It is a pure virtual method defined to ensure <code>nrun</code>
is defined for sub-classes of <code>NMFfitX</code>, which
throws an error if called.
</p>
<p>See <code><a href="#topic+nrun+2CNMFfitX-method">nrun,NMFfitX-method</a></code> for more details. </p>
</dd>
<dt>predict</dt><dd><p><code>signature(object = "NMFfitX")</code>:
Returns the cluster membership index from an NMF model
fitted with multiple runs.
</p>
<p>Besides the type of clustering available for any NMF
models (<code>'columns', 'rows', 'samples', 'features'</code>),
this method can return the cluster membership index based
on the consensus matrix, computed from the multiple NMF
runs.
</p>
<p>See <code><a href="#topic+predict+2CNMFfitX-method">predict,NMFfitX-method</a></code> for more
details. </p>
</dd>
<dt>residuals</dt><dd><p><code>signature(object = "NMFfitX")</code>:
Returns the residuals achieved by the best fit object,
i.e. the lowest residual approximation error achieved
across all NMF runs. </p>
</dd>
<dt>runtime.all</dt><dd><p><code>signature(object = "NMFfitX")</code>:
Returns the CPU time required to compute all the NMF
runs. It returns <code>NULL</code> if no CPU data is available.
</p>
</dd>
<dt>show</dt><dd><p><code>signature(object = "NMFfitX")</code>: Show
method for objects of class <code>NMFfitX</code> </p>
</dd>
<dt>summary</dt><dd><p><code>signature(object = "NMFfitX")</code>:
Computes a set of measures to help evaluate the quality
of the <em>best fit</em> of the set. The result is similar
to the result from the <code>summary</code> method of
<code>NMFfit</code> objects. See <code><a href="#topic+NMF-class">NMF</a></code> for
details on the computed measures. In addition, the
cophenetic correlation (<code><a href="#topic+cophcor">cophcor</a></code>) and
<code><a href="#topic+dispersion">dispersion</a></code> coefficients of the consensus
matrix are returned, as well as the total CPU time
(<code><a href="#topic+runtime.all">runtime.all</a></code>). </p>
</dd>
</dl>



<h3>See Also</h3>

<p>Other multipleNMF: <code><a href="#topic+NMFfitX1-class">NMFfitX1-class</a></code>,
<code><a href="#topic+NMFfitXn-class">NMFfitXn-class</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# generate a synthetic dataset with known classes
n &lt;- 20; counts &lt;- c(5, 2, 3);
V &lt;- syntheticNMF(n, counts)

# perform multiple runs of one algorithm (default is to keep only best fit)
res &lt;- nmf(V, 3, nrun=3)
res

# plot a heatmap of the consensus matrix
## Not run:  consensusmap(res) 
</code></pre>

<hr>
<h2 id='NMFfitX1-class'>Structure for Storing the Best Fit Amongst Multiple NMF Runs</h2><span id='topic+NMFfitX1-class'></span>

<h3>Description</h3>

<p>This class is used to return the result from a multiple
run of a single NMF algorithm performed with function
<code>nmf</code> with the &ndash; default &ndash; option
<code>keep.all=FALSE</code> (cf. <code><a href="#topic+nmf">nmf</a></code>).
</p>


<h3>Details</h3>

<p>It extends both classes <code><a href="#topic+NMFfitX-class">NMFfitX</a></code> and
<code><a href="#topic+NMFfit-class">NMFfit</a></code>, and stores a the result of
the best fit in its <code>NMFfit</code> structure.
</p>
<p>Beside the best fit, this class allows to hold data about
the computation of the multiple runs, such as the number
of runs, the CPU time used to perform all the runs, as
well as the consensus matrix.
</p>
<p>Due to the inheritance from class <code>NMFfit</code>, objects
of class <code>NMFfitX1</code> can be handled exactly as the
results of single NMF run &ndash; as if only the best run had
been performed.
</p>


<h3>Slots</h3>


<dl>
<dt>consensus</dt><dd><p>object of class <code>matrix</code> used to
store the consensus matrix based on all the runs.</p>
</dd>
<dt>nrun</dt><dd><p>an <code>integer</code> that contains the number of
runs performed to compute the object.</p>
</dd>
<dt>rng1</dt><dd><p>an object that contains RNG settings used for
the first run. See <code><a href="#topic+getRNG1">getRNG1</a></code>.</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>consensus</dt><dd><p><code>signature(object = "NMFfitX1")</code>:
The result is the matrix stored in slot
&lsquo;consensus&rsquo;. This method returns <code>NULL</code> if
the consensus matrix is empty. </p>
</dd>
<dt>fit</dt><dd><p><code>signature(object = "NMFfitX1")</code>: Returns
the model object associated with the best fit, amongst
all the runs performed when fitting <code>object</code>.
</p>
<p>Since <code>NMFfitX1</code> objects only hold the best fit,
this method simply returns the NMF model fitted by
<code>object</code> &ndash; that is stored in slot &lsquo;fit&rsquo;. </p>
</dd>
<dt>getRNG1</dt><dd><p><code>signature(object = "NMFfitX1")</code>:
Returns the RNG settings used to compute the first of all
NMF runs, amongst which <code>object</code> was selected as the
best fit. </p>
</dd>
<dt>minfit</dt><dd><p><code>signature(object = "NMFfitX1")</code>:
Returns the fit object associated with the best fit,
amongst all the runs performed when fitting
<code>object</code>.
</p>
<p>Since <code>NMFfitX1</code> objects only hold the best fit,
this method simply returns <code>object</code> coerced into an
<code>NMFfit</code> object. </p>
</dd>
<dt>nmf.equal</dt><dd><p><code>signature(x = "NMFfitX1", y =
  "NMFfitX1")</code>: Compares the NMF models fitted by multiple
runs, that only kept the best fits. </p>
</dd>
<dt>nrun</dt><dd><p><code>signature(object = "NMFfitX1")</code>:
Returns the number of NMF runs performed, amongst which
<code>object</code> was selected as the best fit. </p>
</dd>
<dt>show</dt><dd><p><code>signature(object = "NMFfitX1")</code>: Show
method for objects of class <code>NMFfitX1</code> </p>
</dd>
</dl>



<h3>See Also</h3>

<p>Other multipleNMF: <code><a href="#topic+NMFfitX-class">NMFfitX-class</a></code>,
<code><a href="#topic+NMFfitXn-class">NMFfitXn-class</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# generate a synthetic dataset with known classes
n &lt;- 15; counts &lt;- c(5, 2, 3);
V &lt;- syntheticNMF(n, counts, factors = TRUE)

# get the class factor
groups &lt;- V$pData$Group

# perform multiple runs of one algorithm, keeping only the best fit (default)
#i.e.: the implicit nmf options are .options=list(keep.all=FALSE) or .options='-k'
res &lt;- nmf(V[[1]], 3, nrun=2)
res

# compute summary measures
summary(res)
# get more info
summary(res, target=V[[1]], class=groups)

# show computational time
runtime.all(res)

# plot the consensus matrix, as stored (pre-computed) in the object
## Not run:  consensusmap(res, annCol=groups) 
</code></pre>

<hr>
<h2 id='NMFfitXn-class'>Structure for Storing All Fits from Multiple NMF Runs</h2><span id='topic+NMFfitXn-class'></span>

<h3>Description</h3>

<p>This class is used to return the result from a multiple
run of a single NMF algorithm performed with function
<code>nmf</code> with option <code>keep.all=TRUE</code> (cf.
<code><a href="#topic+nmf">nmf</a></code>).
</p>


<h3>Details</h3>

<p>It extends both classes <code><a href="#topic+NMFfitX-class">NMFfitX</a></code> and
<code>list</code>, and stores the result of each run (i.e. a
<code>NMFfit</code> object) in its <code>list</code> structure.
</p>
<p>IMPORTANT NOTE: This class is designed to be
<strong>read-only</strong>, even though all the
<code>list</code>-methods can be used on its instances. Adding
or removing elements would most probably lead to
incorrect results in subsequent calls. Capability for
concatenating and merging NMF results is for the moment
only used internally, and should be included and
supported in the next release of the package.
</p>


<h3>Slots</h3>


<dl>
<dt>.Data</dt><dd><p>standard slot that contains the S3
<code>list</code> object data. See R documentation on S3/S4
classes for more details (e.g.,
<code><a href="methods.html#topic+setOldClass">setOldClass</a></code>).</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>algorithm</dt><dd><p><code>signature(object = "NMFfitXn")</code>:
Returns the name of the common NMF algorithm used to
compute all fits stored in <code>object</code>
</p>
<p>Since all fits are computed with the same algorithm, this
method returns the name of algorithm that computed the
first fit. It returns <code>NULL</code> if the object is empty.
</p>
</dd>
<dt>basis</dt><dd><p><code>signature(object = "NMFfitXn")</code>:
Returns the basis matrix of the best fit amongst all the
fits stored in <code>object</code>. It is a shortcut for
<code>basis(fit(object))</code>. </p>
</dd>
<dt>coef</dt><dd><p><code>signature(object = "NMFfitXn")</code>:
Returns the coefficient matrix of the best fit amongst
all the fits stored in <code>object</code>. It is a shortcut
for <code>coef(fit(object))</code>. </p>
</dd>
<dt>compare</dt><dd><p><code>signature(object = "NMFfitXn")</code>:
Compares the fits obtained by separate runs of NMF, in a
single call to <code><a href="#topic+nmf">nmf</a></code>. </p>
</dd>
<dt>consensus</dt><dd><p><code>signature(object = "NMFfitXn")</code>:
This method returns <code>NULL</code> on an empty object. The
result is a matrix with several attributes attached, that
are used by plotting functions such as
<code><a href="#topic+consensusmap">consensusmap</a></code> to annotate the plots. </p>
</dd>
<dt>dim</dt><dd><p><code>signature(x = "NMFfitXn")</code>: Returns the
dimension common to all fits.
</p>
<p>Since all fits have the same dimensions, it returns the
dimension of the first fit. This method returns
<code>NULL</code> if the object is empty. </p>
</dd>
<dt>entropy</dt><dd><p><code>signature(x = "NMFfitXn", y =
  "ANY")</code>: Computes the best or mean entropy across all NMF
fits stored in <code>x</code>. </p>
</dd>
<dt>fit</dt><dd><p><code>signature(object = "NMFfitXn")</code>: Returns
the best NMF fit object amongst all the fits stored in
<code>object</code>, i.e. the fit that achieves the lowest
estimation residuals. </p>
</dd>
<dt>.getRNG</dt><dd><p><code>signature(object = "NMFfitXn")</code>:
Returns the RNG settings used for the best fit.
</p>
<p>This method throws an error if the object is empty. </p>
</dd>
<dt>getRNG1</dt><dd><p><code>signature(object = "NMFfitXn")</code>:
Returns the RNG settings used for the first run.
</p>
<p>This method throws an error if the object is empty. </p>
</dd>
<dt>minfit</dt><dd><p><code>signature(object = "NMFfitXn")</code>:
Returns the best NMF model in the list, i.e. the run that
achieved the lower estimation residuals.
</p>
<p>The model is selected based on its <code>deviance</code> value.
</p>
</dd>
<dt>modelname</dt><dd><p><code>signature(object = "NMFfitXn")</code>:
Returns the common type NMF model of all fits stored in
<code>object</code>
</p>
<p>Since all fits are from the same NMF model, this method
returns the model type of the first fit. It returns
<code>NULL</code> if the object is empty. </p>
</dd>
<dt>nbasis</dt><dd><p><code>signature(x = "NMFfitXn")</code>: Returns
the number of basis components common to all fits.
</p>
<p>Since all fits have been computed using the same rank, it
returns the factorization rank of the first fit. This
method returns <code>NULL</code> if the object is empty. </p>
</dd>
<dt>nrun</dt><dd><p><code>signature(object = "NMFfitXn")</code>:
Returns the number of runs performed to compute the fits
stored in the list (i.e. the length of the list itself).
</p>
</dd>
<dt>purity</dt><dd><p><code>signature(x = "NMFfitXn", y =
  "ANY")</code>: Computes the best or mean purity across all NMF
fits stored in <code>x</code>. </p>
</dd>
<dt>runtime.all</dt><dd><p><code>signature(object = "NMFfitXn")</code>:
If no time data is available from in slot
&lsquo;runtime.all&rsquo; and argument <code>null=TRUE</code>, then
the sequential time as computed by <code><a href="#topic+seqtime">seqtime</a></code>
is returned, and a warning is thrown unless
<code>warning=FALSE</code>. </p>
</dd>
<dt>seeding</dt><dd><p><code>signature(object = "NMFfitXn")</code>:
Returns the name of the common seeding method used the
computation of all fits stored in <code>object</code>
</p>
<p>Since all fits are seeded using the same method, this
method returns the name of the seeding method used for
the first fit. It returns <code>NULL</code> if the object is
empty. </p>
</dd>
<dt>seqtime</dt><dd><p><code>signature(object = "NMFfitXn")</code>:
Returns the CPU time that would be required to
sequentially compute all NMF fits stored in
<code>object</code>.
</p>
<p>This method calls the function <code>runtime</code> on each fit
and sum up the results. It returns <code>NULL</code> on an
empty object. </p>
</dd>
<dt>show</dt><dd><p><code>signature(object = "NMFfitXn")</code>: Show
method for objects of class <code>NMFfitXn</code> </p>
</dd>
</dl>



<h3>See Also</h3>

<p>Other multipleNMF: <code><a href="#topic+NMFfitX1-class">NMFfitX1-class</a></code>,
<code><a href="#topic+NMFfitX-class">NMFfitX-class</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# generate a synthetic dataset with known classes
n &lt;- 15; counts &lt;- c(5, 2, 3);
V &lt;- syntheticNMF(n, counts, factors = TRUE)

# get the class factor
groups &lt;- V$pData$Group

# perform multiple runs of one algorithm, keeping all the fits
res &lt;- nmf(V[[1]], 3, nrun=2, .options='k') # .options=list(keep.all=TRUE) also works
res

summary(res)
# get more info
summary(res, target=V[[1]], class=groups)

# compute/show computational times
runtime.all(res)
seqtime(res)

# plot the consensus matrix, computed on the fly
## Not run:  consensusmap(res, annCol=groups) 
</code></pre>

<hr>
<h2 id='nmfFormals'>Showing Arguments of NMF Algorithms</h2><span id='topic+nmfArgs'></span><span id='topic+nmfFormals'></span>

<h3>Description</h3>

<p>This function returns the extra arguments that can be
passed to a given NMF algorithm in call to
<code><a href="#topic+nmf">nmf</a></code>.
</p>
<p><code>nmfArgs</code> is a shortcut for
<code>args(nmfWrapper(x))</code>, to display the arguments of a
given NMF algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  nmfFormals(x, ...)

  nmfArgs(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nmfFormals_+3A_x">x</code></td>
<td>
<p>algorithm specification</p>
</td></tr>
<tr><td><code id="nmfFormals_+3A_...">...</code></td>
<td>
<p>extra argument to allow extension</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>

# show arguments of an NMF algorithm
nmfArgs('brunet')
nmfArgs('snmf/r')
</code></pre>

<hr>
<h2 id='NMFList-class'>Class for Storing Heterogeneous NMF fits</h2><span id='topic+NMFList-class'></span>

<h3>Description</h3>

<p>This class wraps a list of NMF fit objects, which may
come from different runs of the function
<code><a href="#topic+nmf">nmf</a></code>, using different parameters, methods,
etc.. These can be either from a single run (NMFfit) or
multiple runs (NMFfitX).
</p>
<p>Note that its definition/interface is very likely to
change in the future.
</p>


<h3>Methods</h3>


<dl>
<dt>algorithm</dt><dd><p><code>signature(object = "NMFList")</code>:
Returns the method names used to compute the NMF fits in
the list. It returns <code>NULL</code> if the list is empty. </p>
</dd>
<dt>runtime</dt><dd><p><code>signature(object = "NMFList")</code>:
Returns the CPU time required to compute all NMF fits in
the list. It returns <code>NULL</code> if the list is empty. If
no timing data are available, the sequential time is
returned. </p>
</dd>
<dt>seqtime</dt><dd><p><code>signature(object = "NMFList")</code>:
Returns the CPU time that would be required to
sequentially compute all NMF fits stored in
<code>object</code>.
</p>
<p>This method calls the function <code>runtime</code> on each fit
and sum up the results. It returns <code>NULL</code> on an
empty object. </p>
</dd>
<dt>show</dt><dd><p><code>signature(object = "NMFList")</code>: Show
method for objects of class <code>NMFList</code> </p>
</dd>
</dl>


<hr>
<h2 id='nmfModel'>Factory Methods NMF Models</h2><span id='topic+nmfModel'></span><span id='topic+nmfModel+2Cdata.frame+2Cdata.frame-method'></span><span id='topic+nmfModel+2Cformula+2CANY-method'></span><span id='topic+nmfModel+2Cmatrix+2CANY-method'></span><span id='topic+nmfModel+2Cmatrix+2Cmatrix-method'></span><span id='topic+nmfModel-methods'></span><span id='topic+nmfModel+2Cmissing+2CANY-method'></span><span id='topic+nmfModel+2Cmissing+2Cmissing-method'></span><span id='topic+nmfModel+2CNULL+2CANY-method'></span><span id='topic+nmfModel+2Cnumeric+2Cmatrix-method'></span><span id='topic+nmfModel+2Cnumeric+2Cmissing-method'></span><span id='topic+nmfModel+2Cnumeric+2Cnumeric-method'></span><span id='topic+nmfModels'></span>

<h3>Description</h3>

<p><code>nmfModel</code> is a S4 generic function which provides a
convenient way to build NMF models. It implements a
unified interface for creating <code>NMF</code> objects from
any NMF models, which is designed to resolve potential
dimensions inconsistencies.
</p>
<p><code>nmfModels</code> lists all available NMF models currently
defined that can be used to create NMF objects, i.e. &ndash;
more or less &ndash; all S4 classes that inherit from class
<code><a href="#topic+NMF-class">NMF</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  nmfModel(rank, target = 0L, ...)

  ## S4 method for signature 'numeric,numeric'
nmfModel(rank, target,
    ncol = NULL, model = "NMFstd", W, H, ...,
    force.dim = TRUE, order.basis = TRUE)

  ## S4 method for signature 'numeric,matrix'
nmfModel(rank, target, ...,
    use.names = TRUE)

  ## S4 method for signature 'formula,ANY'
nmfModel(rank, target, ...,
    data = NULL, no.attrib = FALSE)

  nmfModels(builtin.only = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nmfModel_+3A_rank">rank</code></td>
<td>
<p>specification of the target factorization
rank (i.e. the number of components).</p>
</td></tr>
<tr><td><code id="nmfModel_+3A_target">target</code></td>
<td>
<p>an object that specifies the dimension of
the estimated target matrix.</p>
</td></tr>
<tr><td><code id="nmfModel_+3A_...">...</code></td>
<td>
<p>extra arguments to allow extension, that are
passed down to the workhorse method
<code>nmfModel,numeric.numeric</code>, where they are used to
initialise slots specific to the instantiating NMF model
class.</p>
</td></tr>
<tr><td><code id="nmfModel_+3A_ncol">ncol</code></td>
<td>
<p>a numeric value that specifies the number of
columns of the target matrix, fitted the NMF model. It is
used only if not missing and when argument <code>target</code>
is a single numeric value.</p>
</td></tr>
<tr><td><code id="nmfModel_+3A_model">model</code></td>
<td>
<p>the class of the object to be created. It
must be a valid class name that inherits from class
<code>NMF</code>. Default is the standard NMF model
<code><a href="#topic+NMFstd-class">NMFstd</a></code>.</p>
</td></tr>
<tr><td><code id="nmfModel_+3A_w">W</code></td>
<td>
<p>value for the basis matrix. <code>data.frame</code>
objects are converted into matrices with
<code><a href="base.html#topic+as.matrix">as.matrix</a></code>.</p>
</td></tr>
<tr><td><code id="nmfModel_+3A_h">H</code></td>
<td>
<p>value for the mixture coefficient matrix
<code>data.frame</code> objects are converted into matrices
with <code><a href="base.html#topic+as.matrix">as.matrix</a></code>.</p>
</td></tr>
<tr><td><code id="nmfModel_+3A_force.dim">force.dim</code></td>
<td>
<p>logical that indicates whether the
method should try lowering the rank or shrinking
dimensions of the input matrices to make them compatible</p>
</td></tr>
<tr><td><code id="nmfModel_+3A_order.basis">order.basis</code></td>
<td>
<p>logical that indicates whether the
basis components should reorder the rows of the mixture
coefficient matrix to match the order of the basis
components, based on their respective names. It is only
used if the basis and coefficient matrices have common
unique column and row names respectively.</p>
</td></tr>
<tr><td><code id="nmfModel_+3A_use.names">use.names</code></td>
<td>
<p>a logical that indicates whether the
dimension names of the target matrix should be set on the
returned NMF model.</p>
</td></tr>
<tr><td><code id="nmfModel_+3A_data">data</code></td>
<td>
<p>Optional argument where to look for the
variables used in the formula.</p>
</td></tr>
<tr><td><code id="nmfModel_+3A_no.attrib">no.attrib</code></td>
<td>
<p>logical that indicate if attributes
containing data related to the formula should be attached
as attributes. If <code>FALSE</code> attributes <code>'target'</code>
and <code>'formula'</code> contain the target matrix, and a
list describing each formula part (response, regressors,
etc.).</p>
</td></tr>
<tr><td><code id="nmfModel_+3A_builtin.only">builtin.only</code></td>
<td>
<p>logical that indicates whether only
built-in NMF models, i.e. defined within the NMF package,
should be listed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>All <code>nmfModel</code> methods return an object that
inherits from class <code>NMF</code>, that is suitable for
seeding NMF algorithms via arguments <code>rank</code> or
<code>seed</code> of the <code><a href="#topic+nmf">nmf</a></code> method, in which
case the factorisation rank is implicitly set by the
number of basis components in the seeding model (see
<code><a href="#topic+nmf">nmf</a></code>).
</p>
<p>For convenience, shortcut methods and internal
conversions for working on <code>data.frame</code> objects
directly are implemented. However, note that conversion
of a <code>data.frame</code> into a <code>matrix</code> object may
take some non-negligible time, for large datasets. If
using this method or other NMF-related methods several
times, consider converting your data <code>data.frame</code>
object into a matrix once for good, when first loaded.
</p>


<h3>Value</h3>

<p>an object that inherits from class
<code><a href="#topic+NMF-class">NMF</a></code>.
</p>
<p>a list
</p>


<h3>Methods</h3>


<dl>
<dt>nmfModel</dt><dd><p><code>signature(rank = "numeric", target
  = "numeric")</code>: Main factory method for NMF models
</p>
<p>This method is the workhorse method that is eventually
called by all other methods. See section <em>Main
factory method</em> for more details. </p>
</dd>
<dt>nmfModel</dt><dd><p><code>signature(rank = "numeric", target
  = "missing")</code>: Creates an empty NMF model of a given
rank.
</p>
<p>This call is equivalent to <code>nmfModel(rank, 0L,
  ...)</code>, which creates <em>empty</em> <code>NMF</code> object with
a basis and mixture coefficient matrix of dimension 0 x
<code>rank</code> and <code>rank</code> x 0 respectively. </p>
</dd>
<dt>nmfModel</dt><dd><p><code>signature(rank = "missing", target
  = "ANY")</code>: Creates an empty NMF model of null rank and a
given dimension.
</p>
<p>This call is equivalent to <code>nmfModel(0, target,
  ...)</code>. </p>
</dd>
<dt>nmfModel</dt><dd><p><code>signature(rank = "NULL", target =
  "ANY")</code>: Creates an empty NMF model of null rank and
given dimension.
</p>
<p>This call is equivalent to <code>nmfModel(0, target,
  ...)</code>, and is meant for internal usage only. </p>
</dd>
<dt>nmfModel</dt><dd><p><code>signature(rank = "missing", target
  = "missing")</code>: Creates an empty NMF model or from
existing factors
</p>
<p>This method is equivalent to <code>nmfModel(0, 0, ...,
  force.dim=FALSE)</code>. This means that the dimensions of the
NMF model will be taken from the optional basis and
mixture coefficient arguments <code>W</code> and <code>H</code>. An
error is thrown if their dimensions are not compatible.
</p>
<p>Hence, this method may be used to generate an NMF model
from existing factor matrices, by providing the named
arguments <code>W</code> and/or <code>H</code>:
</p>
<p><code>nmfModel(W=w)</code> or <code>nmfModel(H=h)</code> or
<code>nmfModel(W=w, H=h)</code>
</p>
<p>Note that this may be achieved using the more convenient
interface is provided by the method
<code>nmfModel,matrix,matrix</code> (see its dedicated
description).
</p>
<p>See the description of the appropriate method below. </p>
</dd>
<dt>nmfModel</dt><dd><p><code>signature(rank = "numeric", target
  = "matrix")</code>: Creates an NMF model compatible with a
target matrix.
</p>
<p>This call is equivalent to <code>nmfModel(rank,
  dim(target), ...)</code>. That is that the returned NMF object
fits a target matrix of the same dimension as
<code>target</code>.
</p>
<p>Only the dimensions of <code>target</code> are used to
construct the <code>NMF</code> object. The matrix slots are
filled with <code>NA</code> values if these are not specified
in arguments <code>W</code> and/or <code>H</code>. However, dimension
names are set on the return NMF model if present in
<code>target</code> and argument <code>use.names=TRUE</code>. </p>
</dd>
<dt>nmfModel</dt><dd><p><code>signature(rank = "matrix", target =
  "matrix")</code>: Creates an NMF model based on two existing
factors.
</p>
<p>This method is equivalent to <code>nmfModel(0, 0, W=rank,
  H=target..., force.dim=FALSE)</code>. This allows for a natural
shortcut for wrapping existing <strong>compatible</strong>
matrices into NMF models: &lsquo;<span class="samp">&#8288;nmfModel(w, h)&#8288;</span>&rsquo;
</p>
<p>Note that an error is thrown if their dimensions are not
compatible. </p>
</dd>
<dt>nmfModel</dt><dd><p><code>signature(rank = "data.frame",
  target = "data.frame")</code>: Same as <code>nmfModel('matrix',
  'matrix')</code> but for <code>data.frame</code> objects, which are
generally produced by <code><a href="utils.html#topic+read.delim">read.delim</a></code>-like
functions.
</p>
<p>The input <code>data.frame</code> objects are converted into
matrices with <code><a href="base.html#topic+as.matrix">as.matrix</a></code>. </p>
</dd>
<dt>nmfModel</dt><dd><p><code>signature(rank = "matrix", target =
  "ANY")</code>: Creates an NMF model with arguments <code>rank</code>
and <code>target</code> swapped.
</p>
<p>This call is equivalent to <code>nmfModel(rank=target,
  target=rank, ...)</code>. This allows to call the
<code>nmfModel</code> function with arguments <code>rank</code> and
<code>target</code> swapped. It exists for convenience:
</p>
 <ul>
<li><p> allows typing <code>nmfModel(V)</code> instead
of <code>nmfModel(target=V)</code> to create a model compatible
with a given matrix <code>V</code> (i.e. of dimension
<code>nrow(V), 0, ncol(V)</code>) </p>
</li>
<li><p> one can pass the
arguments in any order (the one that comes to the user's
mind first) and it still works as expected. </p>
</li></ul>
 </dd>
<dt>nmfModel</dt><dd><p><code>signature(rank = "formula", target
  = "ANY")</code>: Build a formula-based NMF model, that can
incorporate fixed basis or coefficient terms. </p>
</dd>
</dl>



<h3>Main factory method</h3>

<p>The main factory engine of NMF models is implemented by
the method with signature <code>numeric, numeric</code>. Other
factory methods provide convenient ways of creating NMF
models from e.g. a given target matrix or known
basis/coef matrices (see section <em>Other Factory
Methods</em>).
</p>
<p>This method creates an object of class <code>model</code>,
using the extra arguments in <code>...</code> to initialise
slots that are specific to the given model.
</p>
<p>All NMF models implement get/set methods to access the
matrix factors (see <code><a href="#topic+basis">basis</a></code>), which are
called to initialise them from arguments <code>W</code> and
<code>H</code>. These argument names derive from the definition
of all built-in models that inherit derive from class
<code><a href="#topic+NMFstd-class">NMFstd</a></code>, which has two slots, <var>W</var>
and <var>H</var>, to hold the two factors &ndash; following the
notations used in <cite>Lee et al. (1999)</cite>.
</p>
<p>If argument <code>target</code> is missing, the method creates
a standard NMF model of dimension 0x<code>rank</code>x0. That
is that the basis and mixture coefficient matrices,
<var>W</var> and <var>H</var>, have dimension 0x<code>rank</code> and
<code>rank</code>x0 respectively.
</p>
<p>If target dimensions are also provided in argument
<code>target</code> as a 2-length vector, then the method
creates an <code>NMF</code> object compatible to fit a target
matrix of dimension <code>target[1]</code>x<code>target[2]</code>.
That is that the basis and mixture coefficient matrices,
<var>W</var> and <var>H</var>, have dimension
<code>target[1]</code>x<code>rank</code> and
<code>rank</code>x<code>target[2]</code> respectively. The target
dimensions can also be specified using both arguments
<code>target</code> and <code>ncol</code> to define the number of
rows and the number of columns of the target matrix
respectively. If no other argument is provided, these
matrices are filled with NAs.
</p>
<p>If arguments <code>W</code> and/or <code>H</code> are provided, the
method creates a NMF model where the basis and mixture
coefficient matrices, <var>W</var> and <var>H</var>, are
initialised using the values of <code>W</code> and/or <code>H</code>.
</p>
<p>The dimensions given by <code>target</code>, <code>W</code> and
<code>H</code>, must be compatible. However if
<code>force.dim=TRUE</code>, the method will reduce the
dimensions to the achieve dimension compatibility
whenever possible.
</p>
<p>When <code>W</code> and <code>H</code> are both provided, the
<code>NMF</code> object created is suitable to seed a NMF
algorithm in a call to the <code><a href="#topic+nmf">nmf</a></code> method. Note
that in this case the factorisation rank is implicitly
set by the number of basis components in the seed.
</p>


<h3>References</h3>

<p>Lee DD and Seung HS (1999). &quot;Learning the parts of
objects by non-negative matrix factorization.&quot; _Nature_,
*401*(6755), pp. 788-91. ISSN 0028-0836, &lt;URL:
http://dx.doi.org/10.1038/44565&gt;, &lt;URL:
http://www.ncbi.nlm.nih.gov/pubmed/10548103&gt;.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+is.empty.nmf">is.empty.nmf</a></code>
</p>
<p>Other NMF-interface: <code><a href="#topic+basis">basis</a></code>,
<code><a href="#topic+.basis">.basis</a></code>, <code><a href="#topic+.basis+3C-">.basis&lt;-</a></code>,
<code><a href="#topic+basis+3C-">basis&lt;-</a></code>, <code><a href="#topic+coef">coef</a></code>,
<code><a href="#topic+.coef">.coef</a></code>, <code><a href="#topic+.coef+3C-">.coef&lt;-</a></code>,
<code><a href="#topic+coef+3C-">coef&lt;-</a></code>, <code><a href="#topic+coefficients">coefficients</a></code>,
<code><a href="#topic+.DollarNames+2CNMF-method">.DollarNames,NMF-method</a></code>,
<code><a href="#topic+loadings+2CNMF-method">loadings,NMF-method</a></code>, <code><a href="#topic+misc">misc</a></code>,
<code><a href="#topic+NMF-class">NMF-class</a></code>, <code><a href="#topic++24+3C-+2CNMF-method">$&lt;-,NMF-method</a></code>,
<code><a href="#topic++24+2CNMF-method">$,NMF-method</a></code>, <code><a href="#topic+rnmf">rnmf</a></code>,
<code><a href="#topic+scoef">scoef</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

#----------
# nmfModel,numeric,numeric-method
#----------
# data
n &lt;- 20; r &lt;- 3; p &lt;- 10
V &lt;- rmatrix(n, p) # some target matrix

# create a r-ranked NMF model with a given target dimensions n x p as a 2-length vector
nmfModel(r, c(n,p)) # directly
nmfModel(r, dim(V)) # or from an existing matrix &lt;=&gt; nmfModel(r, V)
# or alternatively passing each dimension separately
nmfModel(r, n, p)

# trying to create a NMF object based on incompatible matrices generates an error
w &lt;- rmatrix(n, r)
h &lt;- rmatrix(r+1, p)
try( new('NMFstd', W=w, H=h) )
try( nmfModel(w, h) )
try( nmfModel(r+1, W=w, H=h) )
# The factory method can be force the model to match some target dimensions
# but warnings are thrown
nmfModel(r, W=w, H=h)
nmfModel(r, n-1, W=w, H=h)

#----------
# nmfModel,numeric,missing-method
#----------
## Empty model of given rank
nmfModel(3)

#----------
# nmfModel,missing,ANY-method
#----------
nmfModel(target=10) #square
nmfModel(target=c(10, 5))

#----------
# nmfModel,missing,missing-method
#----------
# Build an empty NMF model
nmfModel()

# create a NMF object based on one random matrix: the missing matrix is deduced
# Note this only works when using factory method NMF
n &lt;- 50; r &lt;- 3;
w &lt;- rmatrix(n, r)
nmfModel(W=w)

# create a NMF object based on random (compatible) matrices
p &lt;- 20
h &lt;- rmatrix(r, p)
nmfModel(H=h)

# specifies two compatible matrices
nmfModel(W=w, H=h)
# error if not compatible
try( nmfModel(W=w, H=h[-1,]) )

#----------
# nmfModel,numeric,matrix-method
#----------
# create a r-ranked NMF model compatible with a given target matrix
obj &lt;- nmfModel(r, V)
all(is.na(basis(obj)))

#----------
# nmfModel,matrix,matrix-method
#----------
## From two existing factors

# allows a convenient call without argument names
w &lt;- rmatrix(n, 3); h &lt;- rmatrix(3, p)
nmfModel(w, h)

# Specify the type of NMF model (e.g. 'NMFns' for non-smooth NMF)
mod &lt;- nmfModel(w, h, model='NMFns')
mod

# One can use such an NMF model as a seed when fitting a target matrix with nmf()
V &lt;- rmatrix(mod)
res &lt;- nmf(V, mod)
nmf.equal(res, nmf(V, mod))

# NB: when called only with such a seed, the rank and the NMF algorithm
# are selected based on the input NMF model.
# e.g. here rank was 3 and the algorithm "nsNMF" is used, because it is the default
# algorithm to fit "NMFns" models (See ?nmf).

#----------
# nmfModel,matrix,ANY-method
#----------
## swapped arguments `rank` and `target`
V &lt;- rmatrix(20, 10)
nmfModel(V) # equivalent to nmfModel(target=V)
nmfModel(V, 3) # equivalent to nmfModel(3, V)

#----------
# nmfModel,formula,ANY-method
#----------
# empty 3-rank model
nmfModel(~ 3)

# 3-rank model that fits a given data matrix
x &lt;- rmatrix(20,10)
nmfModel(x ~ 3)

# add fixed coefficient term defined by a factor
gr &lt;- gl(2, 5)
nmfModel(x ~ 3 + gr)

# add fixed coefficient term defined by a numeric covariate
nmfModel(x ~ 3 + gr + b, data=list(b=runif(10)))

# 3-rank model that fits a given ExpressionSet (with fixed coef terms)
if(requireNamespace("Biobase", quietly=TRUE)){
e &lt;- Biobase::ExpressionSet(x)
pData(e) &lt;- data.frame(a=runif(10))
nmfModel(e ~ 3 + gr + a) # `a` is looked up in the phenotypic data of x pData(x)
}

#----------
# nmfModels
#----------
# show all the NMF models available (i.e. the classes that inherit from class NMF)
nmfModels()
# show all the built-in NMF models available
nmfModels(builtin.only=TRUE)
</code></pre>

<hr>
<h2 id='NMFns-class'>NMF Model - Nonsmooth Nonnegative Matrix Factorization</h2><span id='topic+NMFns-class'></span>

<h3>Description</h3>

<p>This class implements the <em>Nonsmooth Nonnegative
Matrix Factorization</em> (nsNMF) model, required by the
Nonsmooth NMF algorithm.
</p>
<p>The Nonsmooth NMF algorithm is defined by
<cite>Pascual-Montano et al. (2006)</cite> as a modification of
the standard divergence based NMF algorithm (see section
Details and references below).  It aims at obtaining
sparser factor matrices, by the introduction of a
smoothing matrix.
</p>


<h3>Details</h3>

<p>The Nonsmooth NMF algorithm is a modification of the
standard divergence based NMF algorithm (see
<code><a href="#topic+NMF-class">NMF</a></code>). Given a non-negative <code class="reqn">n
  \times p</code> matrix <code class="reqn">V</code> and a factorization rank
<code class="reqn">r</code>, it fits the following model:
</p>
<p style="text-align: center;"><code class="reqn">V \equiv W S(\theta) H,</code>
</p>

<p>where: </p>

<ul>
<li> <p><code class="reqn">W</code> and <code class="reqn">H</code> are such as in the standard
model, i.e. non-negative matrices of dimension <code class="reqn">n
  \times r</code> and <code class="reqn">r \times p</code>
respectively;
</p>
</li>
<li> <p><code class="reqn">S</code> is a <code class="reqn">r \times r</code> square matrix whose
entries depends on an extra parameter <code class="reqn">0\leq \theta
  \leq 1</code> in the following way: </p>
<p style="text-align: center;"><code class="reqn">S = (1-\theta)I +
  \frac{\theta}{r} 11^T ,</code>
</p>
<p> where <code class="reqn">I</code> is the identity
matrix and <code class="reqn">1</code> is a vector of ones.
</p>
</li></ul>

<p>The interpretation of S as a smoothing matrix can be
explained as follows: Let <code class="reqn">X</code> be a positive, nonzero,
vector. Consider the transformed vector <code class="reqn">Y = S X</code>. If
<code class="reqn">\theta = 0</code>, then <code class="reqn">Y = X</code> and no smoothing on
<code class="reqn">X</code> has occurred.  However, as <code class="reqn">\theta \to
  1</code>, the vector <code class="reqn">Y</code> tends to the
constant vector with all elements almost equal to the
average of the elements of <code class="reqn">X</code>. This is the smoothest
possible vector in the sense of non-sparseness because
all entries are equal to the same nonzero value, instead
of having some values close to zero and others clearly
nonzero.
</p>


<h3>Methods</h3>


<dl>
<dt>fitted</dt><dd><p><code>signature(object = "NMFns")</code>: Compute
estimate for an NMFns object, according to the Nonsmooth
NMF model (cf. <code><a href="#topic+NMFns-class">NMFns-class</a></code>).
</p>
<p>Extra arguments in <code>...</code> are passed to method
<code>smoothing</code>, and are typically used to pass a value
for <code>theta</code>, which is used to compute the smoothing
matrix instead of the one stored in <code>object</code>. </p>
</dd>
<dt>show</dt><dd><p><code>signature(object = "NMFns")</code>: Show
method for objects of class <code>NMFns</code> </p>
</dd>
</dl>



<h3>Creating objects from the Class</h3>

<p>Object of class <code>NMFns</code> can be created using the
standard way with operator <code><a href="methods.html#topic+new">new</a></code>
</p>
<p>However, as for all NMF model classes &ndash; that extend
class <code><a href="#topic+NMF-class">NMF</a></code>, objects of class
<code>NMFns</code> should be created using factory method
<code><a href="#topic+nmfModel">nmfModel</a></code> :
</p>
<p><code>new('NMFns')</code>
</p>
<p><code>nmfModel(model='NMFns')</code>
</p>
<p><code>nmfModel(model='NMFns', W=w, theta=0.3</code>
</p>
<p>See <code><a href="#topic+nmfModel">nmfModel</a></code> for more details on how to use
the factory method.
</p>


<h3>Algorithm</h3>

<p>The Nonsmooth NMF algorithm uses a modified version of
the multiplicative update equations in Lee &amp; Seung's
method for Kullback-Leibler divergence minimization. The
update equations are modified to take into account the &ndash;
constant &ndash; smoothing matrix. The modification reduces to
using matrix <code class="reqn">W S</code> instead of matrix <code class="reqn">W</code> in the
update of matrix <code class="reqn">H</code>, and similarly using matrix
<code class="reqn">S H</code> instead of matrix <code class="reqn">H</code> in the update of
matrix <code class="reqn">W</code>.
</p>
<p>After the matrix <code class="reqn">W</code> has been updated, each of its
columns is scaled so that it sums up to 1.
</p>


<h3>References</h3>

<p>Pascual-Montano A, Carazo JM, Kochi K, Lehmann D and
Pascual-marqui RD (2006). &quot;Nonsmooth nonnegative matrix
factorization (nsNMF).&quot; _IEEE Trans. Pattern Anal. Mach.
Intell_, *28*, pp. 403-415.
</p>


<h3>See Also</h3>

<p>Other NMF-model:
<code><a href="#topic+initialize+2CNMFOffset-method">initialize,NMFOffset-method</a></code>,
<code><a href="#topic+NMFOffset-class">NMFOffset-class</a></code>, <code><a href="#topic+NMFstd-class">NMFstd-class</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# create a completely empty NMFns object
new('NMFns')

# create a NMF object based on random (compatible) matrices
n &lt;- 50; r &lt;- 3; p &lt;- 20
w &lt;- rmatrix(n, r)
h &lt;- rmatrix(r, p)
nmfModel(model='NMFns', W=w, H=h)

# apply Nonsmooth NMF algorithm to a random target matrix
V &lt;- rmatrix(n, p)
## Not run: nmf(V, r, 'ns')

# random nonsmooth NMF model
rnmf(3, 10, 5, model='NMFns', theta=0.3)
</code></pre>

<hr>
<h2 id='nmfObject'>Updating NMF Objects</h2><span id='topic+nmfObject'></span>

<h3>Description</h3>

<p>This function serves to update an objects created with
previous versions of the NMF package, which would
otherwise be incompatible with the current version, due
to changes in their S4 class definition.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  nmfObject(object, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nmfObject_+3A_object">object</code></td>
<td>
<p>an R object created by the NMF package,
e.g., an object of class <code><a href="#topic+NMF-class">NMF</a></code> or
<code><a href="#topic+NMFfit-class">NMFfit</a></code>.</p>
</td></tr>
<tr><td><code id="nmfObject_+3A_verbose">verbose</code></td>
<td>
<p>logical to toggle verbose messages.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function makes use of heuristics to automatically
update object slots, which have been borrowed from the
BiocGenerics package, the function
<code>updateObjectFromSlots</code> in particular.
</p>

<hr>
<h2 id='NMFOffset-class'>NMF Model - Nonnegative Matrix Factorization with Offset</h2><span id='topic+initialize+2CNMFOffset-method'></span><span id='topic+NMFOffset-class'></span>

<h3>Description</h3>

<p>This class implements the <em>Nonnegative Matrix
Factorization with Offset</em> model, required by the NMF
with Offset algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S4 method for signature 'NMFOffset'
initialize(.Object, ..., offset)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NMFOffset-class_+3A_offset">offset</code></td>
<td>
<p>optional numeric vector used to initialise
slot &lsquo;offset&rsquo;.</p>
</td></tr>
<tr><td><code id="NMFOffset-class_+3A_.object">.Object</code></td>
<td>
<p> An object: see the Details section.</p>
</td></tr>
<tr><td><code id="NMFOffset-class_+3A_...">...</code></td>
<td>
<p>data to include in the new object.  Named
arguments correspond to slots in the class definition.
Unnamed arguments must be objects from classes that this
class extends.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The NMF with Offset algorithm is defined by <cite>Badea
(2008)</cite> as a modification of the euclidean based NMF
algorithm from <code>Lee2001</code> (see section Details and
references below). It aims at obtaining 'cleaner' factor
matrices, by the introduction of an offset matrix,
explicitly modelling a feature specific baseline &ndash;
constant across samples.
</p>


<h3>Methods</h3>


<dl>
<dt>fitted</dt><dd><p><code>signature(object = "NMFOffset")</code>:
Computes the target matrix estimate for an NMFOffset
object.
</p>
<p>The estimate is computed as: </p>
<p style="text-align: center;"><code class="reqn"> W H + offset </code>
</p>
 </dd>
<dt>offset</dt><dd><p><code>signature(object = "NMFOffset")</code>: The
function <code>offset</code> returns the offset vector from an
NMF model that has an offset, e.g. an <code>NMFOffset</code>
model. </p>
</dd>
<dt>rnmf</dt><dd><p><code>signature(x = "NMFOffset", target =
  "numeric")</code>: Generates a random NMF model with offset,
from class <code>NMFOffset</code>.
</p>
<p>The offset values are drawn from a uniform distribution
between 0 and the maximum entry of the basis and
coefficient matrices, which are drawn by the next
suitable <code><a href="#topic+rnmf">rnmf</a></code> method, which is the
workhorse method <code>rnmf,NMF,numeric</code>. </p>
</dd>
<dt>show</dt><dd><p><code>signature(object = "NMFOffset")</code>: Show
method for objects of class <code>NMFOffset</code> </p>
</dd>
</dl>



<h3>Creating objects from the Class</h3>

<p>Object of class <code>NMFOffset</code> can be created using the
standard way with operator <code><a href="methods.html#topic+new">new</a></code>
</p>
<p>However, as for all NMF model classes &ndash; that extend
class <code><a href="#topic+NMF-class">NMF</a></code>, objects of class
<code>NMFOffset</code> should be created using factory method
<code><a href="#topic+nmfModel">nmfModel</a></code> :
</p>
<p><code>new('NMFOffset')</code>
</p>
<p><code>nmfModel(model='NMFOffset')</code>
</p>
<p><code>nmfModel(model='NMFOffset', W=w, offset=rep(1,
  nrow(w)))</code>
</p>
<p>See <code><a href="#topic+nmfModel">nmfModel</a></code> for more details on how to use
the factory method.
</p>


<h3>Initialize method</h3>

<p>The initialize method for <code>NMFOffset</code> objects tries
to correct the initial value passed for slot
<code>offset</code>, so that it is consistent with the
dimensions of the <code>NMF</code> model: it will pad the
offset vector with NA values to get the length equal to
the number of rows in the basis matrix.
</p>


<h3>References</h3>

<p>Badea L (2008). &quot;Extracting gene expression profiles
common to colon and pancreatic adenocarcinoma using
simultaneous nonnegative matrix factorization.&quot; _Pacific
Symposium on Biocomputing. Pacific Symposium on
Biocomputing_, *290*, pp. 267-78. ISSN 1793-5091, &lt;URL:
http://www.ncbi.nlm.nih.gov/pubmed/18229692&gt;.
</p>


<h3>See Also</h3>

<p>Other NMF-model: <code><a href="#topic+NMFns-class">NMFns-class</a></code>,
<code><a href="#topic+NMFstd-class">NMFstd-class</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# create a completely empty NMF object
new('NMFOffset')

# create a NMF object based on random (compatible) matrices
n &lt;- 50; r &lt;- 3; p &lt;- 20
w &lt;- rmatrix(n, r)
h &lt;- rmatrix(r, p)
nmfModel(model='NMFOffset', W=w, H=h, offset=rep(0.5, nrow(w)))

# apply Nonsmooth NMF algorithm to a random target matrix
V &lt;- rmatrix(n, p)
## Not run: nmf(V, r, 'offset')

# random NMF model with offset
rnmf(3, 10, 5, model='NMFOffset')
</code></pre>

<hr>
<h2 id='nmfReport'>Run NMF Methods and Generate a Report</h2><span id='topic+nmfReport'></span>

<h3>Description</h3>

<p>Generates an HTML report from running a set of method on
a given target matrix, for a set of factorization ranks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  nmfReport(x, rank, method, colClass = NULL, ...,
    output = NULL, template = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nmfReport_+3A_x">x</code></td>
<td>
<p>target matrix</p>
</td></tr>
<tr><td><code id="nmfReport_+3A_rank">rank</code></td>
<td>
<p>factorization rank</p>
</td></tr>
<tr><td><code id="nmfReport_+3A_method">method</code></td>
<td>
<p>list of methods to apply</p>
</td></tr>
<tr><td><code id="nmfReport_+3A_colclass">colClass</code></td>
<td>
<p>reference class to assess accuracy</p>
</td></tr>
<tr><td><code id="nmfReport_+3A_...">...</code></td>
<td>
<p>extra paramters passed to <code><a href="#topic+nmf">nmf</a></code></p>
</td></tr>
<tr><td><code id="nmfReport_+3A_output">output</code></td>
<td>
<p>output HTML file</p>
</td></tr>
<tr><td><code id="nmfReport_+3A_template">template</code></td>
<td>
<p>template Rmd file</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The report is based on an .Rmd document
<code>'report.Rmd'</code> stored in the package installation
sub-directory <code>scripts/</code>, and is compiled using
<span class="pkg">knitr</span>.
</p>
<p>At the beginning of the document, a file named
<code>'functions.R'</code> is looked for in the current
directory, and sourced if present. This enables the
definition of custom NMF methods (see
<code><a href="#topic+setNMFMethod">setNMFMethod</a></code>) or setting global options.
</p>


<h3>Value</h3>

<p>a list with the following elements: </p>
<table>
<tr><td><code>fits</code></td>
<td>
<p>the
fit(s) for each method and each value of the rank.</p>
</td></tr>
<tr><td><code>accuracy</code></td>
<td>
<p>a data.frame that contains the summary
assessment measures, for each fit.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>

## Not run: 

x &lt;- rmatrix(20, 10)
gr &lt;- gl(2, 5)
nmfReport(x, 2:4, method = list('br', 'lee'), colClass = gr, nrun = 5)


## End(Not run)
</code></pre>

<hr>
<h2 id='nmfSeed'>Seeding Strategies for NMF Algorithms</h2><span id='topic+existsNMFSeed'></span><span id='topic+getNMFSeed'></span><span id='topic+nmfSeed'></span>

<h3>Description</h3>

<p><code>nmfSeed</code> lists and retrieves NMF seeding methods.
</p>
<p><code>getNMFSeed</code> is an alias for <code>nmfSeed</code>.
</p>
<p><code>existsNMFSeed</code> tells if a given seeding method
exists in the registry.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  nmfSeed(name = NULL, ...)

  getNMFSeed(name = NULL, ...)

  existsNMFSeed(name, exact = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nmfSeed_+3A_name">name</code></td>
<td>
<p>access key of a seeding method stored in
registry. If missing, <code>nmfSeed</code> returns the list of
all available seeding methods.</p>
</td></tr>
<tr><td><code id="nmfSeed_+3A_...">...</code></td>
<td>
<p>extra arguments used for internal calls</p>
</td></tr>
<tr><td><code id="nmfSeed_+3A_exact">exact</code></td>
<td>
<p>a logical that indicates if the access key
should be matched exactly or partially.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Currently the internal registry contains the following
seeding methods, which may be specified to the function
<code><a href="#topic+nmf">nmf</a></code> via its argument <code>seed</code> using
their access keys:
</p>
 <dl>
<dt>random</dt><dd><p> The entries of each factors are
drawn from a uniform distribution over <code class="reqn">[0, max(x)]</code>,
where $x$ is the target matrix.</p>
</dd> <dt>nndsvd</dt><dd>
<p>Nonnegative Double Singular Value Decomposition.
</p>
<p>The basic algorithm contains no randomization and is
based on two SVD processes, one approximating the data
matrix, the other approximating positive sections of the
resulting partial SVD factors utilising an algebraic
property of unit rank matrices.
</p>
<p>It is well suited to initialise NMF algorithms with
sparse factors. Simple practical variants of the
algorithm allows to generate dense factors.
</p>
<p><strong>Reference:</strong> <cite>Boutsidis et al. (2008)</cite></p>
</dd>
<dt>ica</dt><dd><p> Uses the result of an Independent Component
Analysis (ICA) (from the <code>fastICA</code> package). Only
the positive part of the result are used to initialise
the factors.</p>
</dd> <dt>none</dt><dd><p> Fixed seed.
</p>
<p>This method allows the user to manually provide initial
values for both matrix factors.</p>
</dd> </dl>



<h3>References</h3>

<p>Boutsidis C and Gallopoulos E (2008). &quot;SVD based
initialization: A head start for nonnegative matrix
factorization.&quot; _Pattern Recognition_, *41*(4), pp.
1350-1362. ISSN 00313203, &lt;URL:
http://dx.doi.org/10.1016/j.patcog.2007.09.010&gt;, &lt;URL:
http://linkinghub.elsevier.com/retrieve/pii/S0031320307004359&gt;.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# list all registered seeding methods
nmfSeed()
# retrieve one of the methods
nmfSeed('ica')
</code></pre>

<hr>
<h2 id='NMFSeed'><code>NMFSeed</code> is a constructor method that instantiate
<code><a href="#topic+NMFSeed-class">NMFSeed</a></code> objects.</h2><span id='topic+NMFSeed'></span><span id='topic+NMFSeed+2Ccharacter-method'></span><span id='topic+NMFSeed-methods'></span><span id='topic+NMFSeed+2CNMFSeed-method'></span><span id='topic+removeNMFSeed'></span><span id='topic+setNMFSeed'></span>

<h3>Description</h3>

<p><code>NMFSeed</code> is a constructor method that instantiate
<code><a href="#topic+NMFSeed-class">NMFSeed</a></code> objects.
</p>
<p>NMF seeding methods are registered via the function
<code>setNMFSeed</code>, which stores them as
<code><a href="#topic+NMFSeed-class">NMFSeed</a></code> objects in a dedicated
registry.
</p>
<p><code>removeNMFSeed</code> removes an NMF seeding method from
the registry.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  NMFSeed(key, method, ...)

  setNMFSeed(..., overwrite = isLoadingNamespace(),
    verbose = TRUE)

  removeNMFSeed(name, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NMFSeed_+3A_key">key</code></td>
<td>
<p>access key as a single character string</p>
</td></tr>
<tr><td><code id="NMFSeed_+3A_method">method</code></td>
<td>
<p>specification of the seeding method, as a
function that takes at least the following arguments:
</p>
 <dl>
<dt>object</dt><dd><p>uninitialised/empty NMF model,
i.e. that it has 0 rows and columns, but has already the
rank requested in the call to <code><a href="#topic+nmf">nmf</a></code> or
<code><a href="#topic+seed">seed</a></code>.</p>
</dd> <dt>x</dt><dd><p>target matrix</p>
</dd>
<dt>...</dt><dd><p>extra arguments</p>
</dd> </dl>
</td></tr>
<tr><td><code id="NMFSeed_+3A_...">...</code></td>
<td>
<p>arguments passed to <code>NMFSeed</code> and used to
initialise slots in the <code><a href="#topic+NMFSeed-class">NMFSeed</a></code>
object, or to <code>pkgreg_remove</code>.</p>
</td></tr>
<tr><td><code id="NMFSeed_+3A_name">name</code></td>
<td>
<p>name of the seeding method.</p>
</td></tr>
<tr><td><code id="NMFSeed_+3A_overwrite">overwrite</code></td>
<td>
<p>logical that indicates if any existing
NMF method with the same name should be overwritten
(<code>TRUE</code>) or not (<code>FALSE</code>), in which case an
error is thrown.</p>
</td></tr>
<tr><td><code id="NMFSeed_+3A_verbose">verbose</code></td>
<td>
<p>a logical that indicates if information
about the registration should be printed (<code>TRUE</code>) or
not (<code>FALSE</code>).</p>
</td></tr>
</table>


<h3>Methods</h3>


<dl>
<dt>NMFSeed</dt><dd><p><code>signature(key = "character")</code>:
Default method simply calls <code><a href="methods.html#topic+new">new</a></code> with the
same arguments. </p>
</dd>
<dt>NMFSeed</dt><dd><p><code>signature(key = "NMFSeed")</code>: Creates
an <code>NMFSeed</code> based on a template object
(Constructor-Copy), in particular it uses the
<strong>same</strong> name. </p>
</dd>
</dl>


<hr>
<h2 id='NMFSeed-class'>Base class that defines the interface for NMF seeding methods.</h2><span id='topic+NMFSeed-class'></span>

<h3>Description</h3>

<p>This class implements a simple wrapper strategy object
that defines a unified interface to seeding methods, that
are used to initialise NMF models before fitting them
with any NMF algorithm.
</p>


<h3>Slots</h3>


<dl>
<dt>name</dt><dd><p>character string giving the name of the
seeding strategy</p>
</dd>
<dt>method</dt><dd><p>workhorse function that implements the
seeding strategy. It must have signature
<code>(object="NMF", x="matrix", ...)</code> and initialise the
NMF model <code>object</code> with suitable values for fitting
the target matrix <code>x</code>.</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>algorithm</dt><dd><p><code>signature(object = "NMFSeed")</code>:
Returns the workhorse function of the seeding method
described by <code>object</code>. </p>
</dd>
<dt>algorithm&lt;-</dt><dd><p><code>signature(object = "NMFSeed",
  value = "function")</code>: Sets the workhorse function of the
seeding method described by <code>object</code>. </p>
</dd>
<dt>NMFSeed</dt><dd><p><code>signature(key = "NMFSeed")</code>: Creates
an <code>NMFSeed</code> based on a template object
(Constructor-Copy), in particular it uses the
<strong>same</strong> name. </p>
</dd>
<dt>show</dt><dd><p><code>signature(object = "NMFSeed")</code>: Show
method for objects of class <code>NMFSeed</code> </p>
</dd>
</dl>


<hr>
<h2 id='NMFstd-class'>NMF Model - Standard model</h2><span id='topic+NMFstd-class'></span>

<h3>Description</h3>

<p>This class implements the standard model of Nonnegative
Matrix Factorization. It provides a general structure and
generic functions to manage factorizations that follow
the standard NMF model, as defined by <cite>Lee et al.
(2001)</cite>.
</p>


<h3>Details</h3>

<p>Let <code class="reqn">V</code> be a <code class="reqn">n \times m</code> non-negative matrix and
<code class="reqn">r</code> a positive integer.  In its standard form (see
references below), a NMF of <code class="reqn">V</code> is commonly defined
as a pair of matrices <code class="reqn">(W, H)</code> such that:
</p>
<p style="text-align: center;"><code class="reqn">V \equiv W H,</code>
</p>

<p>where: </p>
 <ul>
<li> <p><code class="reqn">W</code> and <code class="reqn">H</code> are <code class="reqn">n
  \times r</code> and <code class="reqn">r \times m</code> matrices respectively with
non-negative entries; </p>
</li>
<li> <p><code class="reqn">\equiv</code> is to be
understood with respect to some loss function. Common
choices of loss functions are based on Frobenius norm or
Kullback-Leibler divergence. </p>
</li></ul>

<p>Integer <code class="reqn">r</code> is called the <em>factorization rank</em>.
Depending on the context of application of NMF, the
columns of <code class="reqn">W</code> and <code class="reqn">H</code> are given different names:
</p>
 <dl>
<dt>columns of <code>W</code></dt><dd><p>basis vector,
metagenes, factors, source, image basis</p>
</dd> <dt>columns of
<code>H</code></dt><dd><p>mixture coefficients, metagene sample
expression profiles, weights</p>
</dd> <dt>rows of
<code>H</code></dt><dd><p>basis profiles, metagene expression profiles</p>
</dd> </dl>

<p>NMF approaches have been successfully applied to several
fields. The package NMF was implemented trying to use
names as generic as possible for objects and methods.
</p>
<p>The following terminology is used: </p>

<dl>
<dt>samples</dt><dd><p>the columns of the target matrix <code class="reqn">V</code></p>
</dd>
<dt>features</dt><dd><p>the rows of the target matrix <code class="reqn">V</code></p>
</dd>
<dt>basis matrix</dt><dd><p>the first matrix factor <code class="reqn">W</code></p>
</dd>
<dt>basis vectors</dt><dd><p>the columns of first matrix factor
<code class="reqn">W</code></p>
</dd> <dt>mixture matrix</dt><dd><p>the second matrix factor
<code class="reqn">H</code></p>
</dd> <dt>mixtures coefficients</dt><dd><p>the columns of
second matrix factor <code class="reqn">H</code></p>
</dd> </dl>

<p>However, because the package NMF was primarily
implemented to work with gene expression microarray data,
it also provides a layer to easily and intuitively work
with objects from the Bioconductor base framework. See
<a href="#topic+bioc-NMF">bioc-NMF</a> for more details.
</p>


<h3>Slots</h3>


<dl>
<dt>W</dt><dd><p>A <code>matrix</code> that contains the basis matrix,
i.e. the <em>first</em> matrix factor of the factorisation</p>
</dd>
<dt>H</dt><dd><p>A <code>matrix</code> that contains the coefficient
matrix, i.e. the <em>second</em> matrix factor of the
factorisation</p>
</dd>
<dt>bterms</dt><dd><p>a <code>data.frame</code> that contains the
primary data that define fixed basis terms. See
<code><a href="#topic+bterms">bterms</a></code>.</p>
</dd>
<dt>ibterms</dt><dd><p>integer vector that contains the indexes
of the basis components that are fixed, i.e. for which
only the coefficient are estimated.
</p>
<p>IMPORTANT: This slot is set on construction of an NMF
model via
<code><a href="#topic+nmfModel+2Cformula+2CANY-method">nmfModel</a></code> and
is not recommended to not be subsequently changed by the
end-user.</p>
</dd>
<dt>cterms</dt><dd><p>a <code>data.frame</code> that contains the
primary data that define fixed coefficient terms. See
<code><a href="#topic+cterms">cterms</a></code>.</p>
</dd>
<dt>icterms</dt><dd><p>integer vector that contains the indexes
of the basis components that have fixed coefficients,
i.e. for which only the basis vectors are estimated.
</p>
<p>IMPORTANT: This slot is set on construction of an NMF
model via
<code><a href="#topic+nmfModel+2Cformula+2CANY-method">nmfModel</a></code> and
is not recommended to not be subsequently changed by the
end-user.</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>.basis</dt><dd><p><code>signature(object = "NMFstd")</code>: Get
the basis matrix in standard NMF models
</p>
<p>This function returns slot <code>W</code> of <code>object</code>. </p>
</dd>
<dt>.basis&lt;-</dt><dd><p><code>signature(object = "NMFstd", value
  = "matrix")</code>: Set the basis matrix in standard NMF models
</p>
<p>This function sets slot <code>W</code> of <code>object</code>. </p>
</dd>
<dt>bterms&lt;-</dt><dd><p><code>signature(object = "NMFstd")</code>:
Default method tries to coerce <code>value</code> into a
<code>data.frame</code> with <code><a href="base.html#topic+as.data.frame">as.data.frame</a></code>. </p>
</dd>
<dt>.coef</dt><dd><p><code>signature(object = "NMFstd")</code>: Get the
mixture coefficient matrix in standard NMF models
</p>
<p>This function returns slot <code>H</code> of <code>object</code>. </p>
</dd>
<dt>.coef&lt;-</dt><dd><p><code>signature(object = "NMFstd", value =
  "matrix")</code>: Set the mixture coefficient matrix in
standard NMF models
</p>
<p>This function sets slot <code>H</code> of <code>object</code>. </p>
</dd>
<dt>cterms&lt;-</dt><dd><p><code>signature(object = "NMFstd")</code>:
Default method tries to coerce <code>value</code> into a
<code>data.frame</code> with <code><a href="base.html#topic+as.data.frame">as.data.frame</a></code>. </p>
</dd>
<dt>fitted</dt><dd><p><code>signature(object = "NMFstd")</code>:
Compute the target matrix estimate in <em>standard NMF
models</em>.
</p>
<p>The estimate matrix is computed as the product of the two
matrix slots <code>W</code> and <code>H</code>: </p>
<p style="text-align: center;"><code class="reqn">\hat{V} = W
  H</code>
</p>
 </dd>
<dt>ibterms</dt><dd><p><code>signature(object = "NMFstd")</code>:
Method for standard NMF models, which returns the integer
vector that is stored in slot <code>ibterms</code> when a
formula-based NMF model is instantiated. </p>
</dd>
<dt>icterms</dt><dd><p><code>signature(object = "NMFstd")</code>:
Method for standard NMF models, which returns the integer
vector that is stored in slot <code>icterms</code> when a
formula-based NMF model is instantiated. </p>
</dd>
</dl>



<h3>References</h3>

<p>Lee DD and Seung H (2001). &quot;Algorithms for non-negative
matrix factorization.&quot; _Advances in neural information
processing systems_. &lt;URL:
http://scholar.google.com/scholar?q=intitle:Algorithms+for+non-negative+matrix+factorization&gt;.
</p>


<h3>See Also</h3>

<p>Other NMF-model:
<code><a href="#topic+initialize+2CNMFOffset-method">initialize,NMFOffset-method</a></code>,
<code><a href="#topic+NMFns-class">NMFns-class</a></code>, <code><a href="#topic+NMFOffset-class">NMFOffset-class</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# create a completely empty NMFstd object
new('NMFstd')

# create a NMF object based on one random matrix: the missing matrix is deduced
# Note this only works when using factory method NMF
n &lt;- 50; r &lt;- 3;
w &lt;- rmatrix(n, r)
nmfModel(W=w)

# create a NMF object based on random (compatible) matrices
p &lt;- 20
h &lt;- rmatrix(r, p)
nmfModel(W=w, H=h)

# create a NMF object based on incompatible matrices: generate an error
h &lt;- rmatrix(r+1, p)
try( new('NMFstd', W=w, H=h) )
try( nmfModel(w, h) )

# Giving target dimensions to the factory method allow for coping with dimension
# incompatibilty (a warning is thrown in such case)
nmfModel(r, W=w, H=h)
</code></pre>

<hr>
<h2 id='NMFStop'>Stopping Criteria for NMF Iterative Strategies</h2><span id='topic+NMFStop'></span><span id='topic+nmf.stop.connectivity'></span><span id='topic+nmf.stop.iteration'></span><span id='topic+nmf.stop.stationary'></span><span id='topic+nmf.stop.threshold'></span><span id='topic+stop-NMF'></span>

<h3>Description</h3>

<p>The function documented here implement
stopping/convergence criteria commonly used in NMF
algorithms.
</p>
<p><code>NMFStop</code> acts as a factory method that creates
stopping criterion functions from different types of
values, which are subsequently used by
<code><a href="#topic+NMFStrategyIterative-class">NMFStrategyIterative</a></code> objects to
determine when to stop their iterative process.
</p>
<p><code>nmf.stop.iteration</code> generates a function that
implements the stopping criterion that limits the number
of iterations to a maximum of <code>n</code>), i.e. that
returns <code>TRUE</code> if <code>i&gt;=n</code>, <code>FALSE</code>
otherwise.
</p>
<p><code>nmf.stop.threshold</code> generates a function that
implements the stopping criterion that stops when a given
stationarity threshold is achieved by successive
iterations. The returned function is identical to
<code>nmf.stop.stationary</code>, but with the default
threshold set to <code>threshold</code>.
</p>
<p>More precisely, the objective function is computed over
<code class="reqn">n</code> successive iterations (specified in argument
<code>check.niter</code>), every <code>check.interval</code>
iterations. The criterion stops when the absolute
difference between the maximum and the minimum objective
values over these iterations is lower than a given
threshold <code class="reqn">\alpha</code> (specified in
<code>stationary.th</code>):
</p>
<p><code>nmf.stop.connectivity</code> implements the stopping
criterion that is based on the stationarity of the
connectivity matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  NMFStop(s, check = TRUE)

  nmf.stop.iteration(n)

  nmf.stop.threshold(threshold)

  nmf.stop.stationary(object, i, y, x,
    stationary.th = .Machine$double.eps,
    check.interval = 5 * check.niter, check.niter = 10L,
    ...)

  nmf.stop.connectivity(object, i, y, x, stopconv = 40,
    check.interval = 10, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NMFStop_+3A_s">s</code></td>
<td>
<p>specification of the stopping criterion. See
section <em>Details</em> for the supported formats and how
they are processed.</p>
</td></tr>
<tr><td><code id="NMFStop_+3A_check">check</code></td>
<td>
<p>logical that indicates if the validity of
the stopping criterion function should be checked before
returning it.</p>
</td></tr>
<tr><td><code id="NMFStop_+3A_n">n</code></td>
<td>
<p>maximum number of iteration to perform.</p>
</td></tr>
<tr><td><code id="NMFStop_+3A_threshold">threshold</code></td>
<td>
<p>default stationarity threshold</p>
</td></tr>
<tr><td><code id="NMFStop_+3A_object">object</code></td>
<td>
<p>an NMF strategy object</p>
</td></tr>
<tr><td><code id="NMFStop_+3A_i">i</code></td>
<td>
<p>the current iteration</p>
</td></tr>
<tr><td><code id="NMFStop_+3A_y">y</code></td>
<td>
<p>the target matrix</p>
</td></tr>
<tr><td><code id="NMFStop_+3A_x">x</code></td>
<td>
<p>the current NMF model</p>
</td></tr>
<tr><td><code id="NMFStop_+3A_stationary.th">stationary.th</code></td>
<td>
<p>maximum absolute value of the
gradient, for the objective function to be considered
stationary.</p>
</td></tr>
<tr><td><code id="NMFStop_+3A_check.interval">check.interval</code></td>
<td>
<p>interval (in number of iterations)
on which the stopping criterion is computed.</p>
</td></tr>
<tr><td><code id="NMFStop_+3A_check.niter">check.niter</code></td>
<td>
<p>number of successive iteration used to
compute the stationnary criterion.</p>
</td></tr>
<tr><td><code id="NMFStop_+3A_...">...</code></td>
<td>
<p>extra arguments passed to the function
<code><a href="#topic+objective">objective</a></code>, which computes the objective
value between <code>x</code> and <code>y</code>.</p>
</td></tr>
<tr><td><code id="NMFStop_+3A_stopconv">stopconv</code></td>
<td>
<p>number of iterations intervals over which
the connectivity matrix must not change for stationarity
to be achieved.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>NMFStop</code> can take the following values: </p>

<dl>
<dt>function</dt><dd><p> is returned unchanged, except when it
has no arguments, in which case it assumed to be a
generator, which is immediately called and should return
a function that implements the actual stopping
criterion;</p>
</dd> <dt>integer</dt><dd><p> the value is used to create a
stopping criterion that stops at that exact number of
iterations via <code>nmf.stop.iteration</code>;</p>
</dd>
<dt>numeric</dt><dd><p> the value is used to create a stopping
criterion that stops when at that stationary threshold
via <code>nmf.stop.threshold</code>;</p>
</dd> <dt>character</dt><dd><p> must be
a single string which must be an access key for
registered criteria (currently available:
&ldquo;connectivity&rdquo; and &ldquo;stationary&rdquo;), or the
name of a function in the global environment or the
namespace of the loading package.</p>
</dd> </dl>

<p style="text-align: center;"><code class="reqn"> \left| \frac{\max_{i- N_s + 1 \leq k \leq i} D_k -
  \min_{i - N_s +1 \leq k \leq i} D_k}{n} \right| \leq
  \alpha, </code>
</p>



<h3>Value</h3>

<p>a function that can be passed to argument <code>.stop</code> of
function <code><a href="#topic+nmf">nmf</a></code>, which is typically used when
the algorith is implemented as an iterative strategy.
</p>
<p>a function that can be used as a stopping criterion for
NMF algorithms defined as
<code><a href="#topic+NMFStrategyIterative-class">NMFStrategyIterative</a></code> objects. That
is a function with arguments <code>(strategy, i, target,
  data, ...)</code> that returns <code>TRUE</code> if the stopping
criterion is satisfied &ndash; which in turn stops the
iterative process, and <code>FALSE</code> otherwise.
</p>

<hr>
<h2 id='NMFStrategy'>Factory Method for NMFStrategy Objects</h2><span id='topic+NMFStrategy'></span><span id='topic+NMFStrategy+2Ccharacter+2Ccharacter-method'></span><span id='topic+NMFStrategy+2Ccharacter+2Cfunction-method'></span><span id='topic+NMFStrategy+2Ccharacter+2Cmissing-method'></span><span id='topic+NMFStrategy+2Ccharacter+2CNMFStrategy-method'></span><span id='topic+NMFStrategy-methods'></span><span id='topic+NMFStrategy+2Cmissing+2Ccharacter-method'></span><span id='topic+NMFStrategy+2CNMFStrategy+2Cmissing-method'></span><span id='topic+NMFStrategy+2CNULL+2Ccharacter-method'></span><span id='topic+NMFStrategy+2CNULL+2CNMFStrategy-method'></span><span id='topic+run+2CNMFStrategyFunction+2Cmatrix+2CNMFfit-method'></span><span id='topic+run+2CNMFStrategyIterative+2Cmatrix+2CNMFfit-method'></span><span id='topic+run+2CNMFStrategyIterativeX+2Cmatrix+2CNMFfit-method'></span><span id='topic+run+2CNMFStrategy+2Cmatrix+2CNMFfit-method'></span><span id='topic+run+2CNMFStrategy+2Cmatrix+2CNMF-method'></span><span id='topic+run+2CNMFStrategyOctave+2Cmatrix+2CNMFfit-method'></span>

<h3>Description</h3>

<p>Creates NMFStrategy objects that wraps implementation of
NMF algorithms into a unified interface.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  NMFStrategy(name, method, ...)

  ## S4 method for signature 'NMFStrategy,matrix,NMFfit'
run(object, y, x,
    ...)

  ## S4 method for signature 'NMFStrategy,matrix,NMF'
run(object, y, x, ...)

  ## S4 method for signature 'NMFStrategyFunction,matrix,NMFfit'
run(object,
    y, x, ...)

  ## S4 method for signature 'NMFStrategyIterative,matrix,NMFfit'
run(object,
    y, x, .stop = NULL,
    maxIter = nmf.getOption("maxIter") %||% 2000, ...)

  ## S4 method for signature 'NMFStrategyIterativeX,matrix,NMFfit'
run(object,
    y, x, maxIter, ...)

  ## S4 method for signature 'NMFStrategyOctave,matrix,NMFfit'
run(object,
    y, x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NMFStrategy_+3A_name">name</code></td>
<td>
<p>name/key of an NMF algorithm.</p>
</td></tr>
<tr><td><code id="NMFStrategy_+3A_method">method</code></td>
<td>
<p>definition of the algorithm</p>
</td></tr>
<tr><td><code id="NMFStrategy_+3A_...">...</code></td>
<td>
<p>extra arguments passed to <code><a href="methods.html#topic+new">new</a></code>.</p>
</td></tr>
<tr><td><code id="NMFStrategy_+3A_.stop">.stop</code></td>
<td>
<p>specification of a stopping criterion, that
is used instead of the one associated to the NMF
algorithm. It may be specified as: </p>
 <ul>
<li><p> the
access key of a registered stopping criterion; </p>
</li>
<li><p> a
single integer that specifies the exact number of
iterations to perform, which will be honoured unless a
lower value is explicitly passed in argument
<code>maxIter</code>. </p>
</li>
<li><p> a single numeric value that
specifies the stationnarity threshold for the objective
function, used in with <code><a href="#topic+nmf.stop.stationary">nmf.stop.stationary</a></code>;
</p>
</li>
<li><p> a function with signature
<code>(object="NMFStrategy", i="integer", y="matrix",
  x="NMF", ...)</code>, where <code>object</code> is the
<code>NMFStrategy</code> object that describes the algorithm
being run, <code>i</code> is the current iteration, <code>y</code> is
the target matrix and <code>x</code> is the current value of
the NMF model. </p>
</li></ul>
</td></tr>
<tr><td><code id="NMFStrategy_+3A_maxiter">maxIter</code></td>
<td>
<p>maximum number of iterations to perform.</p>
</td></tr>
<tr><td><code id="NMFStrategy_+3A_object">object</code></td>
<td>
<p>an object computed using some algorithm, or
that describes an algorithm itself.</p>
</td></tr>
<tr><td><code id="NMFStrategy_+3A_y">y</code></td>
<td>
<p>data object, e.g. a target matrix</p>
</td></tr>
<tr><td><code id="NMFStrategy_+3A_x">x</code></td>
<td>
<p>a model object used as a starting point by the
algorithm, e.g. a non-empty NMF model.</p>
</td></tr>
</table>


<h3>Methods</h3>


<dl>
<dt>NMFStrategy</dt><dd><p><code>signature(name = "character",
  method = "function")</code>: Creates an
<code>NMFStrategyFunction</code> object that wraps the function
<code>method</code> into a unified interface.
</p>
<p><code>method</code> must be a function with signature
<code>(y="matrix", x="NMFfit", ...)</code>, and return an
object of class <code><a href="#topic+NMFfit-class">NMFfit</a></code>. </p>
</dd>
<dt>NMFStrategy</dt><dd><p><code>signature(name = "character",
  method = "NMFStrategy")</code>: Creates an <code>NMFStrategy</code>
object based on a template object (Constructor-Copy). </p>
</dd>
<dt>NMFStrategy</dt><dd><p><code>signature(name = "NMFStrategy",
  method = "missing")</code>: Creates an <code>NMFStrategy</code> based
on a template object (Constructor-Copy), in particular it
uses the <strong>same</strong> name. </p>
</dd>
<dt>NMFStrategy</dt><dd><p><code>signature(name = "missing",
  method = "character")</code>: Creates an <code>NMFStrategy</code>
based on a registered NMF algorithm that is used as a
template (Constructor-Copy), in particular it uses the
<strong>same</strong> name.
</p>
<p>It is a shortcut for
<code>NMFStrategy(nmfAlgorithm(method, exact=TRUE),
  ...)</code>. </p>
</dd>
<dt>NMFStrategy</dt><dd><p><code>signature(name = "NULL", method
  = "NMFStrategy")</code>: Creates an <code>NMFStrategy</code> based on
a template object (Constructor-Copy) but using a randomly
generated name. </p>
</dd>
<dt>NMFStrategy</dt><dd><p><code>signature(name = "character",
  method = "character")</code>: Creates an <code>NMFStrategy</code>
based on a registered NMF algorithm that is used as a
template. </p>
</dd>
<dt>NMFStrategy</dt><dd><p><code>signature(name = "NULL", method
  = "character")</code>: Creates an <code>NMFStrategy</code> based on a
registered NMF algorithm (Constructor-Copy) using a
randomly generated name.
</p>
<p>It is a shortcut for <code>NMFStrategy(NULL,
  nmfAlgorithm(method), ...)</code>. </p>
</dd>
<dt>NMFStrategy</dt><dd><p><code>signature(name = "character",
  method = "missing")</code>: Creates an NMFStrategy, determining
its type from the extra arguments passed in <code>...</code>:
if there is an argument named <code>Update</code> then an
<code>NMFStrategyIterative</code> is created, or if there is an
argument named <code>algorithm</code> then an
<code>NMFStrategyFunction</code> is created. Calls other than
these generates an error. </p>
</dd>
<dt>run</dt><dd><p><code>signature(object = "NMFStrategy", y =
  "matrix", x = "NMFfit")</code>: Pure virtual method defined for
all NMF algorithms to ensure that a method <code>run</code> is
defined by sub-classes of <code>NMFStrategy</code>.
</p>
<p>It throws an error if called directly. </p>
</dd>
<dt>run</dt><dd><p><code>signature(object = "NMFStrategy", y =
  "matrix", x = "NMF")</code>: Method to run an NMF algorithm
directly starting from a given NMF model. </p>
</dd>
<dt>run</dt><dd><p><code>signature(object =
  "NMFStrategyFunction", y = "matrix", x = "NMFfit")</code>: Runs
the NMF algorithms implemented by the single R function
&ndash; and stored in slot <code>'algorithm'</code> of
<code>object</code>, on the data object <code>y</code>, using
<code>x</code> as starting point. It is equivalent to calling
<code>object@algorithm(y, x, ...)</code>.
</p>
<p>This method is usually not called directly, but only via
the function <code><a href="#topic+nmf">nmf</a></code>, which takes care of many
other details such as seeding the computation, handling
RNG settings, or setting up parallelisation. </p>
</dd>
<dt>run</dt><dd><p><code>signature(object =
  "NMFStrategyIterative", y = "matrix", x = "NMFfit")</code>:
Runs an NMF iterative algorithm on a target matrix
<code>y</code>. </p>
</dd>
<dt>run</dt><dd><p><code>signature(object = "NMFStrategyOctave",
  y = "matrix", x = "NMFfit")</code>: Runs the NMF algorithms
implemented by the Octave/Matlab function associated with
the strategy &ndash; and stored in slot <code>'algorithm'</code> of
<code>object</code>.
</p>
<p>This method is usually not called directly, but only via
the function <code><a href="#topic+nmf">nmf</a></code>, which takes care of many
other details such as seeding the computation, handling
RNG settings, or setting up parallel computations. </p>
</dd>
</dl>


<hr>
<h2 id='NMFStrategy-class'>Virtual Interface for NMF Algorithms</h2><span id='topic+is.mixed'></span><span id='topic+NMFStrategy-class'></span><span id='topic+objective+3C-+2CNMFStrategy+2Ccharacter-method'></span><span id='topic+objective+3C-+2CNMFStrategy+2Cfunction-method'></span><span id='topic+objective+2CNMFStrategy-method'></span><span id='topic+show+2CNMFStrategy-method'></span>

<h3>Description</h3>

<p>This class partially implements the generic interface
defined for general algorithms defined in the <span class="pkg">NMF</span>
package (see <code><a href="#topic+algorithmic-NMF">algorithmic-NMF</a></code>).
</p>
<p><code>is.mixed</code> tells if an NMF algorithm works on
mixed-sign data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S4 method for signature 'NMFStrategy'
show(object)

  ## S4 method for signature 'NMFStrategy'
objective(object)

  ## S4 replacement method for signature 'NMFStrategy,character'
objective(object)&lt;-value

  ## S4 replacement method for signature 'NMFStrategy,function'
objective(object)&lt;-value

  is.mixed(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NMFStrategy-class_+3A_object">object</code></td>
<td>
<p>Any R object</p>
</td></tr>
<tr><td><code id="NMFStrategy-class_+3A_value">value</code></td>
<td>
<p>replacement value</p>
</td></tr>
</table>


<h3>Slots</h3>


<dl>
<dt>objective</dt><dd><p>the objective function associated with
the algorithm (Frobenius, Kullback-Leibler, etc...).  It
is either an access key of a registered objective
function or a function definition.  In the latter case,
the given function must have the following signature
<code>(x="NMF", y="matrix")</code> and return a nonnegative
real value.</p>
</dd>
<dt>model</dt><dd><p>a character string giving either the
(sub)class name of the NMF-class instance used and
returned by the strategy, or a function name.</p>
</dd>
<dt>mixed</dt><dd><p>a logical that indicates if the algorithm
works on mixed-sign data.</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>canFit</dt><dd><p><code>signature(x = "NMFStrategy", y =
  "character")</code>: Tells if an NMF algorithm can fit a given
class of NMF models </p>
</dd>
<dt>canFit</dt><dd><p><code>signature(x = "NMFStrategy", y =
  "NMF")</code>: Tells if an NMF algorithm can fit the same class
of models as <code>y</code> </p>
</dd>
<dt>deviance</dt><dd><p><code>signature(object = "NMFStrategy")</code>:
Computes the value of the objective function between the
estimate <code>x</code> and the target <code>y</code>. </p>
</dd>
<dt>modelname</dt><dd><p><code>signature(object =
  "NMFStrategy")</code>: Returns the model(s) that an NMF
algorithm can fit. </p>
</dd>
<dt>NMFStrategy</dt><dd><p><code>signature(name = "NMFStrategy",
  method = "missing")</code>: Creates an <code>NMFStrategy</code> based
on a template object (Constructor-Copy), in particular it
uses the <strong>same</strong> name. </p>
</dd>
<dt>objective</dt><dd><p><code>signature(object =
  "NMFStrategy")</code>: Gets the objective function associated
with an NMF algorithm.
</p>
<p>It is used in
<code><a href="#topic+deviance+2CNMFStrategy-method">deviance</a></code> to
compute the objective value for an NMF model with respect
to a given target matrix. </p>
</dd>
<dt>objective</dt><dd><p><code>signature(object =
  "NMFStrategy")</code>: Gets the objective function associated
with an NMF algorithm.
</p>
<p>It is used in
<code><a href="#topic+deviance+2CNMFStrategy-method">deviance</a></code> to
compute the objective value for an NMF model with respect
to a given target matrix. </p>
</dd>
<dt>objective&lt;-</dt><dd><p><code>signature(object =
  "NMFStrategy", value = "character")</code>: Sets the objective
function associated with an NMF algorithm, with a
character string that must be a registered objective
function. </p>
</dd>
<dt>objective&lt;-</dt><dd><p><code>signature(object =
  "NMFStrategy", value = "character")</code>: Sets the objective
function associated with an NMF algorithm, with a
character string that must be a registered objective
function. </p>
</dd>
<dt>objective&lt;-</dt><dd><p><code>signature(object =
  "NMFStrategy", value = "function")</code>: Sets the objective
function associated with an NMF algorithm, with a
function that computes the approximation error between an
NMF model and a target matrix. </p>
</dd>
<dt>objective&lt;-</dt><dd><p><code>signature(object =
  "NMFStrategy", value = "function")</code>: Sets the objective
function associated with an NMF algorithm, with a
function that computes the approximation error between an
NMF model and a target matrix. </p>
</dd>
<dt>run</dt><dd><p><code>signature(object = "NMFStrategy", y =
  "matrix", x = "NMFfit")</code>: Pure virtual method defined for
all NMF algorithms to ensure that a method <code>run</code> is
defined by sub-classes of <code>NMFStrategy</code>.
</p>
<p>It throws an error if called directly. </p>
</dd>
<dt>run</dt><dd><p><code>signature(object = "NMFStrategy", y =
  "matrix", x = "NMF")</code>: Method to run an NMF algorithm
directly starting from a given NMF model. </p>
</dd>
</dl>


<hr>
<h2 id='NMFStrategyFunction-class'>Interface for Single Function NMF Strategies</h2><span id='topic+NMFStrategyFunction-class'></span>

<h3>Description</h3>

<p>This class implements the virtual interface
<code><a href="#topic+NMFStrategy">NMFStrategy</a></code> for NMF algorithms that are
implemented by a single workhorse R function.
</p>


<h3>Slots</h3>


<dl>
<dt>algorithm</dt><dd><p>a function that implements an NMF
algorithm. It must have signature <code>(y='matrix',
  x='NMFfit')</code>, where <code>y</code> is the target matrix to
approximate and <code>x</code> is the NMF model assumed to be
seeded with an appropriate initial value &ndash; as it is done
internally by function <code><a href="#topic+nmf">nmf</a></code>.
</p>
<p>Note that argument names currently do not matter, but it
is recommended to name them as specified above.</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>algorithm</dt><dd><p><code>signature(object =
  "NMFStrategyFunction")</code>: Returns the single R function
that implements the NMF algorithm &ndash; as stored in slot
<code>algorithm</code>. </p>
</dd>
<dt>algorithm&lt;-</dt><dd><p><code>signature(object =
  "NMFStrategyFunction", value = "function")</code>: Sets the
function that implements the NMF algorithm, stored in
slot <code>algorithm</code>. </p>
</dd>
<dt>run</dt><dd><p><code>signature(object =
  "NMFStrategyFunction", y = "matrix", x = "NMFfit")</code>: Runs
the NMF algorithms implemented by the single R function
&ndash; and stored in slot <code>'algorithm'</code> of
<code>object</code>, on the data object <code>y</code>, using
<code>x</code> as starting point. It is equivalent to calling
<code>object@algorithm(y, x, ...)</code>.
</p>
<p>This method is usually not called directly, but only via
the function <code><a href="#topic+nmf">nmf</a></code>, which takes care of many
other details such as seeding the computation, handling
RNG settings, or setting up parallelisation. </p>
</dd>
</dl>


<hr>
<h2 id='NMFStrategyIterative-class'>Interface for Algorithms: Implementation for Iterative NMF Algorithms</h2><span id='topic+NMFStrategyIterative-class'></span>

<h3>Description</h3>

<p>This class provides a specific implementation for the
generic function <code>run</code> &ndash; concretising the virtual
interface class <code><a href="#topic+NMFStrategy-class">NMFStrategy</a></code>, for NMF
algorithms that conform to the following iterative schema
(starred numbers indicate mandatory steps):
</p>
 <ul>
<li><p> 1. Initialisation </p>
</li>
<li><p> 2*. Update the
model at each iteration </p>
</li>
<li><p> 3. Stop if some criterion
is satisfied </p>
</li>
<li><p> 4. Wrap up </p>
</li></ul>

<p>This schema could possibly apply to all NMF algorithms,
since these are essentially optimisation algorithms,
almost all of which use iterative methods to approximate
a solution of the optimisation problem. The main
advantage is that it allows to implement updates and
stopping criterion separately, and combine them in
different ways. In particular, many NMF algorithms are
based on multiplicative updates, following the approach
from <cite>Lee et al. (2001)</cite>, which are specially
suitable to be cast into this simple schema.
</p>


<h3>Slots</h3>


<dl>
<dt>onInit</dt><dd><p>optional function that performs some
initialisation or pre-processing on the model, before
starting the iteration loop.</p>
</dd>
<dt>Update</dt><dd><p>mandatory function that implement the
update step, which computes new values for the model,
based on its previous value. It is called at each
iteration, until the stopping criterion is met or the
maximum number of iteration is achieved.</p>
</dd>
<dt>Stop</dt><dd><p>optional function that implements the
stopping criterion. It is called <strong>before</strong> each
Update step. If not provided, the iterations are stopped
after a fixed number of updates.</p>
</dd>
<dt>onReturn</dt><dd><p>optional function that wraps up the
result into an NMF object. It is called just before
returning the</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>run</dt><dd><p><code>signature(object =
  "NMFStrategyIterative", y = "matrix", x = "NMFfit")</code>:
Runs an NMF iterative algorithm on a target matrix
<code>y</code>. </p>
</dd>
<dt>show</dt><dd><p><code>signature(object =
  "NMFStrategyIterative")</code>: Show method for objects of
class <code>NMFStrategyIterative</code> </p>
</dd>
</dl>



<h3>References</h3>

<p>Lee DD and Seung H (2001). &quot;Algorithms for non-negative
matrix factorization.&quot; _Advances in neural information
processing systems_. &lt;URL:
http://scholar.google.com/scholar?q=intitle:Algorithms+for+non-negative+matrix+factorization&gt;.
</p>

<hr>
<h2 id='nmfWrapper'>Wrapping NMF Algorithms</h2><span id='topic+nmfWrapper'></span>

<h3>Description</h3>

<p>This function creates a wrapper function for calling the
function <code><a href="#topic+nmf">nmf</a></code> with a given NMF algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  nmfWrapper(method, ..., .FIXED = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nmfWrapper_+3A_method">method</code></td>
<td>
<p>Name of the NMF algorithm to be wrapped. It
should be the name of a registered algorithm as returned
by <code><a href="#topic+nmfAlgorithm">nmfAlgorithm</a></code>, or an NMF algorithm object
(i.e. an instance of <code><a href="#topic+NMFStrategy-class">NMFStrategy</a></code>).</p>
</td></tr>
<tr><td><code id="nmfWrapper_+3A_...">...</code></td>
<td>
<p>extra named arguments that define default
values for any arguments of <code><a href="#topic+nmf">nmf</a></code> or the
algorithm itself.</p>
</td></tr>
<tr><td><code id="nmfWrapper_+3A_.fixed">.FIXED</code></td>
<td>
<p>a logical that indicates if the default
arguments defined in <code>...</code> must be considered as
fixed, i.e. that they are forced to have the defined
values and cannot be used in a call to the wrapper
function, in which case, a warning about discarding them
is thrown if they are used. Non fixed arguments may have
their value changed at call time, in which case it is
honoured and passed to the <code>nmf</code> call.
</p>
<p><code>.FIXED</code> may also be a character vector that
specifies which argument amongst <code>...</code> should be
considered as fixed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a function with argument <code>...</code> and a set of default
arguments defined in <code>...</code> in the call to
<code>nmfWrapper</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+nmfAlgorithm">nmfAlgorithm</a></code>, <code><a href="#topic+nmf">nmf</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# wrap Lee &amp; Seung algorithm into a function
lee &lt;- nmfWrapper('lee', seed=12345)
args(lee)

# test on random data
x &lt;- rmatrix(100,20)
res &lt;- nmf(x, 3, 'lee', seed=12345)
res2 &lt;- lee(x, 3)
nmf.equal(res, res2)
res3 &lt;- lee(x, 3, seed=123)
nmf.equal(res, res3)



# argument 'method' has no effect
res4 &lt;- lee(x, 3, method='brunet')
nmf.equal(res, res4)


</code></pre>

<hr>
<h2 id='nneg'>Transforming from Mixed-sign to Nonnegative Data</h2><span id='topic+nneg'></span><span id='topic+nneg+2Cmatrix-method'></span><span id='topic+nneg-methods'></span><span id='topic+nneg+2CNMF-method'></span><span id='topic+posneg'></span><span id='topic+rposneg'></span><span id='topic+rposneg+2Cmatrix-method'></span><span id='topic+rposneg-methods'></span><span id='topic+rposneg+2CNMF-method'></span>

<h3>Description</h3>

<p><code>nneg</code> is a generic function to transform a data
objects that contains negative values into a similar
object that only contains values that are nonnegative or
greater than a given threshold.
</p>
<p><code>posneg</code> is a shortcut for <code>nneg(...,
  method='posneg')</code>, to split mixed-sign data into its
positive and negative part. See description for method
<code>"posneg"</code>, in <code><a href="#topic+nneg">nneg</a></code>.
</p>
<p><code>rposneg</code> performs the &quot;reverse&quot; transformation of
the <code><a href="#topic+posneg">posneg</a></code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  nneg(object, ...)

  ## S4 method for signature 'matrix'
nneg(object,
    method = c("pmax", "posneg", "absolute", "min"),
    threshold = 0, shift = TRUE)

  posneg(...)

  rposneg(object, ...)

  ## S4 method for signature 'matrix'
rposneg(object, unstack = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nneg_+3A_object">object</code></td>
<td>
<p>The data object to transform</p>
</td></tr>
<tr><td><code id="nneg_+3A_...">...</code></td>
<td>
<p>extra arguments to allow extension or passed
down to <code>nneg,matrix</code> or <code>rposneg,matrix</code> in
subsequent calls.</p>
</td></tr>
<tr><td><code id="nneg_+3A_method">method</code></td>
<td>
<p>Name of the transformation method to use,
that is partially matched against the following possible
methods: </p>
 <dl>
<dt>pmax</dt><dd><p>Each entry is constrained
to be above threshold <code>threshold</code>.</p>
</dd>
<dt>posneg</dt><dd><p>The matrix is split into its &quot;positive&quot; and
&quot;negative&quot; parts, with the entries of each part
constrained to be above threshold <code>threshold</code>. The
result consists in these two parts stacked in rows (i.e.
<code><a href="base.html#topic+rbind">rbind</a></code>-ed) into a single matrix, which has
double the number of rows of the input matrix
<code>object</code>.</p>
</dd>
<dt>absolute</dt><dd><p>The absolute value of each entry is
constrained to be above threshold <code>threshold</code>.</p>
</dd>
<dt>min</dt><dd><p>Global shift by adding the minimum entry to
each entry, only if it is negative, and then apply
threshold. </p>
</dd>
</dl>
</td></tr>
<tr><td><code id="nneg_+3A_threshold">threshold</code></td>
<td>
<p>Nonnegative lower threshold value
(single numeric). See argument <code>shit</code> for details on
how the threshold is used and affects the result.</p>
</td></tr>
<tr><td><code id="nneg_+3A_shift">shift</code></td>
<td>
<p>a logical indicating whether the entries
below the threshold value <code>threshold</code> should be
forced (shifted) to 0 (default) or to the threshold value
itself. In other words, if <code>shift=TRUE</code> (default)
all entries in the result matrix are either 0 or strictly
greater than <code>threshold</code>. They are all greater or
equal than <code>threshold</code> otherwise.</p>
</td></tr>
<tr><td><code id="nneg_+3A_unstack">unstack</code></td>
<td>
<p>Logical indicating whether the positive
and negative parts should be unstacked and combined into
a matrix as <code>pos - neg</code>, which contains half the
number of rows of <code>object</code> (default), or left
stacked as <code>[pos; -neg]</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of the same class as argument <code>object</code>.
</p>
<p>an object of the same type of <code>object</code>
</p>


<h3>Methods</h3>


<dl>
<dt>nneg</dt><dd><p><code>signature(object = "matrix")</code>:
Transforms a mixed-sign matrix into a nonnegative matrix,
optionally apply a lower threshold. This is the workhorse
method, that is eventually called by all other methods
defined in the <code><a href="#topic+NMF">NMF</a></code> package. </p>
</dd>
<dt>nneg</dt><dd><p><code>signature(object = "NMF")</code>: Apply
<code>nneg</code> to the basis matrix of an <code><a href="#topic+NMF">NMF</a></code>
object (i.e. <code>basis(object)</code>). All extra arguments
in <code>...</code> are passed to the method
<code>nneg,matrix</code>. </p>
</dd>
<dt>rposneg</dt><dd><p><code>signature(object = "NMF")</code>: Apply
<code>rposneg</code> to the basis matrix of an
<code><a href="#topic+NMF">NMF</a></code> object. </p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="base.html#topic+pmax">pmax</a></code>
</p>
<p>Other transforms: <code><a href="#topic+t.NMF">t.NMF</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

#----------
# nneg,matrix-method
#----------
# random mixed sign data (normal distribution)
set.seed(1)
x &lt;- rmatrix(5,5, rnorm, mean=0, sd=5)
x

# pmax (default)
nneg(x)
# using a threshold
nneg(x, threshold=2)
# without shifting the entries lower than threshold
nneg(x, threshold=2, shift=FALSE)

# posneg: split positive and negative part
nneg(x, method='posneg')
nneg(x, method='pos', threshold=2)

# absolute
nneg(x, method='absolute')
nneg(x, method='abs', threshold=2)

# min
nneg(x, method='min')
nneg(x, method='min', threshold=2)

#----------
# nneg,NMF-method
#----------
# random
M &lt;- nmfModel(x, rmatrix(ncol(x), 3))
nnM &lt;- nneg(M)
basis(nnM)
# mixture coefficients are not affected
identical( coef(M), coef(nnM) )

#----------
# posneg
#----------
# shortcut for the "posneg" transformation
posneg(x)
posneg(x, 2)

#----------
# rposneg,matrix-method
#----------
# random mixed sign data (normal distribution)
set.seed(1)
x &lt;- rmatrix(5,5, rnorm, mean=0, sd=5)
x

# posneg-transform: split positive and negative part
y &lt;- posneg(x)
dim(y)
# posneg-reverse
z &lt;- rposneg(y)
identical(x, z)
rposneg(y, unstack=FALSE)

# But posneg-transformation with a non zero threshold is not reversible
y1 &lt;- posneg(x, 1)
identical(rposneg(y1), x)

#----------
# rposneg,NMF-method
#----------
# random mixed signed NMF model
M &lt;- nmfModel(rmatrix(10, 3, rnorm), rmatrix(3, 4))
# split positive and negative part
nnM &lt;- posneg(M)
M2 &lt;- rposneg(nnM)
identical(M, M2)
</code></pre>

<hr>
<h2 id='objective+2CNMFfit-method'>Returns the objective function associated with the algorithm that computed the
fitted NMF model <code>object</code>, or the objective value with respect to a given
target matrix <code>y</code> if it is supplied.</h2><span id='topic+objective+2CNMFfit-method'></span>

<h3>Description</h3>

<p>Returns the objective function associated with the
algorithm that computed the fitted NMF model
<code>object</code>, or the objective value with respect to a
given target matrix <code>y</code> if it is supplied.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S4 method for signature 'NMFfit'
objective(object, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="objective+2B2CNMFfit-method_+3A_y">y</code></td>
<td>
<p>optional target matrix used to compute the
objective value.</p>
</td></tr>
<tr><td><code id="objective+2B2CNMFfit-method_+3A_object">object</code></td>
<td>
<p>an object computed using some algorithm, or
that describes an algorithm itself.</p>
</td></tr>
</table>

<hr>
<h2 id='offset+2CNMFfit-method'>Returns the offset from the fitted model.</h2><span id='topic+offset+2CNMFfit-method'></span>

<h3>Description</h3>

<p>Returns the offset from the fitted model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S4 method for signature 'NMFfit'
offset(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="offset+2B2CNMFfit-method_+3A_object">object</code></td>
<td>
<p>An offset to be included in a model frame</p>
</td></tr>
</table>

<hr>
<h2 id='offset+2CNMFOffset-method'>Offsets in NMF Models with Offset</h2><span id='topic+offset+2CNMFOffset-method'></span>

<h3>Description</h3>

<p>The function <code>offset</code> returns the offset vector from
an NMF model that has an offset, e.g. an <code>NMFOffset</code>
model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S4 method for signature 'NMFOffset'
offset(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="offset+2B2CNMFOffset-method_+3A_object">object</code></td>
<td>
<p>an instance of class <code>NMFOffset</code>.</p>
</td></tr>
</table>

<hr>
<h2 id='options-NMF'>NMF Package Specific Options</h2><span id='topic+nmf.getOption'></span><span id='topic+nmf.options'></span><span id='topic+nmf.printOptions'></span><span id='topic+nmf.resetOptions'></span><span id='topic+options-NMF'></span>

<h3>Description</h3>

<p>NMF Package Specific Options
</p>
<p><code>nmf.options</code> sets/get single or multiple options,
that are specific to the NMF package. It behaves in the
same way as <code><a href="base.html#topic+options">options</a></code>.
</p>
<p><code>nmf.getOption</code> returns the value of a single
option, that is specific to the NMF package. It behaves
in the same way as <code><a href="base.html#topic+getOption">getOption</a></code>.
</p>
<p><code>nmf.resetOptions</code> reset all NMF specific options to
their default values.
</p>
<p><code>nmf.printOptions</code> prints all NMF specific options
along with their default values, in a relatively compact
way.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  nmf.options(...)

  nmf.getOption(x, default = NULL)

  nmf.resetOptions(..., ALL = FALSE)

  nmf.printOptions()
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="options-NMF_+3A_...">...</code></td>
<td>
<p>option specifications. For <code>nmf.options</code>
this can be named arguments or a single unnamed argument
that is a named list (see <code><a href="base.html#topic+options">options</a></code>.
</p>
<p>For <code>nmf.resetOptions</code>, this must be the names of
the options to reset.</p>
</td></tr>
<tr><td><code id="options-NMF_+3A_all">ALL</code></td>
<td>
<p>logical that indicates if options that are not
part of the default set of options should be removed.</p>
</td></tr>
<tr><td><code id="options-NMF_+3A_x">x</code></td>
<td>
<p>a character string holding an option name.</p>
</td></tr>
<tr><td><code id="options-NMF_+3A_default">default</code></td>
<td>
<p>if the specified option is not set in the
options list, this value is returned.  This facilitates
retrieving an option and checking whether it is set and
setting it separately if not.</p>
</td></tr>
</table>


<h3>Available options</h3>


<dl>
<dt>cores</dt><dd><p>Default number of cores to use to perform
parallel NMF computations. Note that this option is
effectively used only if the global option <code>'cores'</code>
is not set. Moreover, the number of cores can also be set
at runtime, in the call to <code><a href="#topic+nmf">nmf</a></code>, via
arguments <code>.pbackend</code> or <code>.options</code> (see
<code><a href="#topic+nmf">nmf</a></code> for more details).</p>
</dd>
<dt>default.algorithm</dt><dd><p>Default NMF algorithm used by
the <code>nmf</code> function when argument <code>method</code> is
missing. The value should the key of one of the
registered NMF algorithms or a valid specification of an
NMF algorithm. See <code>?nmfAlgorithm</code>.</p>
</dd>
<dt>default.seed</dt><dd><p>Default seeding method used by the
<code>nmf</code> function when argument <code>seed</code> is missing.
The value should the key of one of the registered seeding
methods or a vallid specification of a seeding method.
See <code>?nmfSeed</code>.</p>
</dd>
<dt>track</dt><dd><p>Toggle default residual tracking. When
<code>TRUE</code>, the <code>nmf</code> function compute and store
the residual track in the result &ndash; if not otherwise
specified in argument <code>.options</code>. Note that tracking
may significantly slow down the computations.</p>
</dd>
<dt>track.interval</dt><dd><p>Number of iterations between two
points in the residual track. This option is relevant
only when residual tracking is enabled. See <code>?nmf</code>.</p>
</dd>
<dt>error.track</dt><dd><p>this is a symbolic link to option
<code>track</code> for backward compatibility.</p>
</dd>
<dt>pbackend</dt><dd><p>Default loop/parallel foreach backend
used by the <code>nmf</code> function when argument
<code>.pbackend</code> is missing. Currently the following
values are supported: <code>'par'</code> for multicore,
<code>'seq'</code> for sequential, <code>NA</code> for standard
<code>sapply</code> (i.e. do not use a foreach loop),
<code>NULL</code> for using the currently registered foreach
backend.</p>
</dd>
<dt>parallel.backend</dt><dd><p>this is a symbolic link to option
<code>pbackend</code> for backward compatibility.</p>
</dd>
<dt>gc</dt><dd><p>Interval/frequency (in number of runs) at which
garbage collection is performed.</p>
</dd>
<dt>verbose</dt><dd><p>Default level of verbosity.</p>
</dd>
<dt>debug</dt><dd><p>Toogles debug mode. In this mode the console
output may be very &ndash; very &ndash; messy, and is aimed at
debugging only.</p>
</dd>
<dt>maxIter</dt><dd><p> Default maximum number of iteration to
use (default NULL). This option is for internal/technical
usage only, to globally speed up examples or tests of NMF
algorithms. To be used with care at one's own risk... It
is documented here so that advanced users are aware of
its existence, and can avoid possible conflict with their
own custom options. </p>
</dd> </dl>
 


<h3>Examples</h3>

<pre><code class='language-R'>

# show all NMF specific options
nmf.printOptions()

# get some options
nmf.getOption('verbose')
nmf.getOption('pbackend')
# set new values
nmf.options(verbose=TRUE)
nmf.options(pbackend='mc', default.algorithm='lee')
nmf.printOptions()

# reset to default
nmf.resetOptions()
nmf.printOptions()
</code></pre>

<hr>
<h2 id='parallel-NMF'>Utilities for Parallel Computations</h2><span id='topic+gVariable'></span><span id='topic+hostfile'></span><span id='topic+parallel-NMF'></span><span id='topic+ts_eval'></span><span id='topic+ts_tempfile'></span>

<h3>Description</h3>

<p>Utilities for Parallel Computations
</p>
<p><code>ts_eval</code> generates a thread safe version of
<code><a href="base.html#topic+eval">eval</a></code>. It uses boost mutexes provided by the
<em>synchronicity</em> package. The generated function has 
arguments <code>expr</code> and <code>envir</code>, which are passed 
to <code><a href="base.html#topic+eval">eval</a></code>.
</p>
<p><code>ts_tempfile</code> generates a <em>unique</em> temporary
filename that includes the name of the host machine
and/or the caller's process id, so that it is thread
safe.
</p>
<p><code>hostfile</code> generates a temporary filename composed
with the name of the host machine and/or the current
process id.
</p>
<p><code>gVariable</code> generates a function that access a
global static variable, possibly in shared memory (only
for numeric matrix-coercible data in this case). It is
used primarily in parallel computations, to preserve data
accross computations that are performed by the same
process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ts_eval(mutex = synchronicity::boost.mutex(),
    verbose = FALSE)

  ts_tempfile(pattern = "file", ..., host = TRUE,
    pid = TRUE)

  hostfile(pattern = "file", tmpdir = tempdir(),
    fileext = "", host = TRUE, pid = TRUE)

  gVariable(init, shared = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="parallel-NMF_+3A_mutex">mutex</code></td>
<td>
<p>a mutex or a mutex descriptor. If missing, a
new mutex is created via the function <em>boost.mutex</em> from 
the <em>synchronicity</em> package.</p>
</td></tr>
<tr><td><code id="parallel-NMF_+3A_verbose">verbose</code></td>
<td>
<p>a logical that indicates if messages
should be printed when locking and unlocking the mutex.</p>
</td></tr>
<tr><td><code id="parallel-NMF_+3A_...">...</code></td>
<td>
<p>extra arguments passed to
<code><a href="base.html#topic+tempfile">tempfile</a></code>.</p>
</td></tr>
<tr><td><code id="parallel-NMF_+3A_host">host</code></td>
<td>
<p>logical that indicates if the host machine
name should be appear in the filename.</p>
</td></tr>
<tr><td><code id="parallel-NMF_+3A_pid">pid</code></td>
<td>
<p>logical that indicates if the current process
id be appear in the filename.</p>
</td></tr>
<tr><td><code id="parallel-NMF_+3A_init">init</code></td>
<td>
<p>initial value</p>
</td></tr>
<tr><td><code id="parallel-NMF_+3A_shared">shared</code></td>
<td>
<p>a logical that indicates if the variable
should be stored in shared memory or in a local
environment.</p>
</td></tr>
<tr><td><code id="parallel-NMF_+3A_pattern">pattern</code></td>
<td>
<p>a non-empty character vector giving the
initial part of the name.</p>
</td></tr>
<tr><td><code id="parallel-NMF_+3A_tmpdir">tmpdir</code></td>
<td>
<p>a non-empty character vector giving the
directory name</p>
</td></tr>
<tr><td><code id="parallel-NMF_+3A_fileext">fileext</code></td>
<td>
<p>a non-empty character vector giving the
file extension</p>
</td></tr>
</table>

<hr>
<h2 id='parse_formula'>Simple Parsing of Formula</h2><span id='topic+parse_formula'></span>

<h3>Description</h3>

<p>Formula parser for formula-based NMF models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  parse_formula(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="parse_formula_+3A_x">x</code></td>
<td>
<p>formula to parse</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with the following elements: </p>
<table>
<tr><td><code>response</code></td>
<td>

<p>logical that indicates if the formula has a response
term.</p>
</td></tr> <tr><td><code>y</code></td>
<td>
<p> name of the response variable.</p>
</td></tr>
<tr><td><code>x</code></td>
<td>
<p> list of regressor variable names.</p>
</td></tr> <tr><td><code>n</code></td>
<td>

<p>number of regressor variables.</p>
</td></tr>
</table>

<hr>
<h2 id='plot+2CNMFfit+2Cmissing-method'>Plots the residual track computed at regular interval during the fit of
the NMF model <code>x</code>.</h2><span id='topic+plot+2CNMFfit+2Cmissing-method'></span>

<h3>Description</h3>

<p>Plots the residual track computed at regular interval
during the fit of the NMF model <code>x</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S4 method for signature 'NMFfit,missing'
plot(x, y, skip = -1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot+2B2CNMFfit+2B2Cmissing-method_+3A_skip">skip</code></td>
<td>
<p>an integer that indicates the number of
points to skip/remove from the beginning of the curve. If
<code>skip=1L</code> (default) only the initial residual &ndash;
that is computed before any iteration, is skipped, if
present in the track (it associated with iteration 0).</p>
</td></tr>
<tr><td><code id="plot+2B2CNMFfit+2B2Cmissing-method_+3A_x">x</code></td>
<td>
<p>the coordinates of points in the plot.
Alternatively, a single plotting structure, function or
<em>any <span class="rlang"><b>R</b></span> object with a <code>plot</code> method</em> can be
provided.</p>
</td></tr>
<tr><td><code id="plot+2B2CNMFfit+2B2Cmissing-method_+3A_y">y</code></td>
<td>
<p>the y coordinates of points in the plot,
<em>optional</em> if <code>x</code> is an appropriate structure.</p>
</td></tr>
<tr><td><code id="plot+2B2CNMFfit+2B2Cmissing-method_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to methods, such as
<a href="graphics.html#topic+graphical+20parameters">graphical parameters</a> (see <code><a href="graphics.html#topic+par">par</a></code>).
Many methods will accept the following arguments:
</p>
 <dl>
<dt><code>type</code></dt><dd><p>what type of plot should be
drawn.  Possible types are </p>
 <ul>
<li> <p><code>"p"</code> for
<b>p</b>oints, </p>
</li>
<li> <p><code>"l"</code> for <b>l</b>ines, </p>
</li>
<li>
<p><code>"b"</code> for <b>b</b>oth, </p>
</li>
<li> <p><code>"c"</code> for the
lines part alone of <code>"b"</code>, </p>
</li>
<li> <p><code>"o"</code> for both
&lsquo;<b>o</b>verplotted&rsquo;, </p>
</li>
<li> <p><code>"h"</code> for
&lsquo;<b>h</b>istogram&rsquo; like (or &lsquo;high-density&rsquo;)
vertical lines, </p>
</li>
<li> <p><code>"s"</code> for stair <b>s</b>teps,
</p>
</li>
<li> <p><code>"S"</code> for other <b>s</b>teps, see
&lsquo;Details&rsquo; below, </p>
</li>
<li> <p><code>"n"</code> for no plotting.
</p>
</li></ul>
<p> All other <code>type</code>s give a warning or an error;
using, e.g., <code>type = "punkte"</code> being equivalent to
<code>type = "p"</code> for S compatibility.  Note that some
methods, e.g. <code><a href="graphics.html#topic+plot.factor">plot.factor</a></code>, do not accept
this.  </p>
</dd> <dt><code>main</code></dt><dd><p>an overall title for the
plot: see <code><a href="graphics.html#topic+title">title</a></code>.</p>
</dd> <dt><code>sub</code></dt><dd><p>a sub
title for the plot: see <code><a href="graphics.html#topic+title">title</a></code>.</p>
</dd>
<dt><code>xlab</code></dt><dd><p>a title for the x axis: see
<code><a href="graphics.html#topic+title">title</a></code>.</p>
</dd> <dt><code>ylab</code></dt><dd><p>a title for the
y axis: see <code><a href="graphics.html#topic+title">title</a></code>.</p>
</dd> <dt><code>asp</code></dt><dd><p>the
<code class="reqn">y/x</code> aspect ratio, see <code><a href="graphics.html#topic+plot.window">plot.window</a></code>.</p>
</dd> </dl>

</td></tr>
</table>

<hr>
<h2 id='pmax.inplace'>Updating Objects In Place</h2><span id='topic+neq.constraints.inplace'></span><span id='topic+pmax.inplace'></span>

<h3>Description</h3>

<p>These functions modify objects (mainly matrix objects) in
place, i.e. they act directly on the C pointer. Due to
their side-effect, they are not meant to be called by the
end-user.
</p>
<p><code>neq.constraints.inplace</code> apply unequality
constraints in place.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  pmax.inplace(x, lim, skip = NULL)

  neq.constraints.inplace(x, constraints, ratio = NULL,
    value = NULL, copy = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pmax.inplace_+3A_x">x</code></td>
<td>
<p>an object to update in place.</p>
</td></tr>
<tr><td><code id="pmax.inplace_+3A_lim">lim</code></td>
<td>
<p>lower threshold value</p>
</td></tr>
<tr><td><code id="pmax.inplace_+3A_skip">skip</code></td>
<td>
<p>indexes to skip</p>
</td></tr>
<tr><td><code id="pmax.inplace_+3A_constraints">constraints</code></td>
<td>
<p>constraint specification.</p>
</td></tr>
<tr><td><code id="pmax.inplace_+3A_ratio">ratio</code></td>
<td>
<p>fixed ratio on which the constraint
applies.</p>
</td></tr>
<tr><td><code id="pmax.inplace_+3A_value">value</code></td>
<td>
<p>fixed value to enforce.</p>
</td></tr>
<tr><td><code id="pmax.inplace_+3A_copy">copy</code></td>
<td>
<p>a logical that indicates if <code>x</code> should
be updated in place or not.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>pmax.inplace</code> is a version of <code><a href="base.html#topic+pmax">pmax</a></code>
that updates its first argument.
</p>

<hr>
<h2 id='predict'>Clustering and Prediction</h2><span id='topic+predict'></span><span id='topic+predict-methods'></span><span id='topic+predict+2CNMFfitX-method'></span><span id='topic+predict+2CNMF-method'></span>

<h3>Description</h3>

<p>The methods <code>predict</code> for NMF models return the
cluster membership of each sample or each feature.
Currently the classification/prediction of new data is
not implemented.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  predict(object, ...)

  ## S4 method for signature 'NMF'
predict(object,
    what = c("columns", "rows", "samples", "features"),
    prob = FALSE, dmatrix = FALSE)

  ## S4 method for signature 'NMFfitX'
predict(object,
    what = c("columns", "rows", "samples", "features", "consensus", "chc"),
    dmatrix = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict_+3A_object">object</code></td>
<td>
<p>an NMF model</p>
</td></tr>
<tr><td><code id="predict_+3A_what">what</code></td>
<td>
<p>a character string that indicates the type of
cluster membership should be returned: &lsquo;columns&rsquo;
or &lsquo;rows&rsquo; for clustering the colmuns or the rows
of the target matrix respectively. The values
&lsquo;samples&rsquo; and &lsquo;features&rsquo; are aliases for
&lsquo;colmuns&rsquo; and &lsquo;rows&rsquo; respectively.</p>
</td></tr>
<tr><td><code id="predict_+3A_prob">prob</code></td>
<td>
<p>logical that indicates if the relative
contributions of/to the dominant basis component should
be computed and returned. See <em>Details</em>.</p>
</td></tr>
<tr><td><code id="predict_+3A_dmatrix">dmatrix</code></td>
<td>
<p>logical that indicates if a dissimiliarity
matrix should be attached to the result. This is notably
used internally when computing NMF clustering
silhouettes.</p>
</td></tr>
<tr><td><code id="predict_+3A_...">...</code></td>
<td>
<p>additional arguments affecting the predictions
produced.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The cluster membership is computed as the index of the
dominant basis component for each sample
(<code>what='samples' or 'columns'</code>) or each feature
(<code>what='features' or 'rows'</code>), based on their
corresponding entries in the coefficient matrix or basis
matrix respectively.
</p>
<p>For example, if <code>what='samples'</code>, then the dominant
basis component is computed for each column of the
coefficient matrix as the row index of the maximum within
the column.
</p>
<p>If argument <code>prob=FALSE</code> (default), the result is a
<code>factor</code>. Otherwise a list with two elements is
returned: element <code>predict</code> contains the cluster
membership index (as a <code>factor</code>) and element
<code>prob</code> contains the relative contribution of the
dominant component to each sample (resp. the relative
contribution of each feature to the dominant basis
component):
</p>
 <ul>
<li><p> Samples: </p>
<p style="text-align: center;"><code class="reqn">p_j = x_{k_0} / \sum_k
  x_k</code>
</p>
<p>, for each sample
<code class="reqn">1\leq j \leq p</code>, where <code class="reqn">x_k</code> is the
contribution of the <code class="reqn">k</code>-th basis component to
<code class="reqn">j</code>-th sample (i.e. <code>H[k ,j]</code>), and
<code class="reqn">x_{k_0}</code> is the maximum of these
contributions.
</p>
</li>
<li><p> Features: </p>
<p style="text-align: center;"><code class="reqn">p_i = y_{k_0} / \sum_k y_k</code>
</p>
<p>, for each feature <code class="reqn">1\leq i \leq
  p</code>, where <code class="reqn">y_k</code> is the contribution of the
<code class="reqn">k</code>-th basis component to <code class="reqn">i</code>-th feature (i.e.
<code>W[i, k]</code>), and <code class="reqn">y_{k_0}</code> is the maximum
of these contributions.
</p>
</li></ul>



<h3>Methods</h3>


<dl>
<dt>predict</dt><dd><p><code>signature(object = "NMF")</code>: Default
method for NMF models </p>
</dd>
<dt>predict</dt><dd><p><code>signature(object = "NMFfitX")</code>:
Returns the cluster membership index from an NMF model
fitted with multiple runs.
</p>
<p>Besides the type of clustering available for any NMF
models (<code>'columns', 'rows', 'samples', 'features'</code>),
this method can return the cluster membership index based
on the consensus matrix, computed from the multiple NMF
runs.
</p>
<p>Argument <code>what</code> accepts the following extra types:
</p>
 <dl>
<dt><code>'chc'</code></dt><dd><p> returns the cluster
membership based on the hierarchical clustering of the
consensus matrix, as performed by
<code><a href="#topic+consensushc">consensushc</a></code>.</p>
</dd> <dt><code>'consensus'</code></dt><dd>
<p>same as <code>'chc'</code> but the levels of the membership
index are re-labeled to match the order of the clusters
as they would be displayed on the associated dendrogram,
as re-ordered on the default annotation track in
consensus heatmap produced by
<code><a href="#topic+consensusmap">consensusmap</a></code>.</p>
</dd> </dl>
 </dd>
</dl>



<h3>References</h3>

<p>Brunet J, Tamayo P, Golub TR and Mesirov JP (2004).
&quot;Metagenes and molecular pattern discovery using matrix
factorization.&quot; _Proceedings of the National Academy of
Sciences of the United States of America_, *101*(12), pp.
4164-9. ISSN 0027-8424, &lt;URL:
http://dx.doi.org/10.1073/pnas.0308531101&gt;, &lt;URL:
http://www.ncbi.nlm.nih.gov/pubmed/15016911&gt;.
</p>
<p>Pascual-Montano A, Carazo JM, Kochi K, Lehmann D and
Pascual-marqui RD (2006). &quot;Nonsmooth nonnegative matrix
factorization (nsNMF).&quot; _IEEE Trans. Pattern Anal. Mach.
Intell_, *28*, pp. 403-415.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# random target matrix
v &lt;- rmatrix(20, 10)
# fit an NMF model
x &lt;- nmf(v, 5)

# predicted column and row clusters
predict(x)
predict(x, 'rows')

# with relative contributions of each basis component
predict(x, prob=TRUE)
predict(x, 'rows', prob=TRUE)
</code></pre>

<hr>
<h2 id='profplot'>Plotting Expression Profiles</h2><span id='topic+profplot'></span><span id='topic+profplot.default'></span>

<h3>Description</h3>

<p>Plotting Expression Profiles
</p>
<p>When using NMF for clustering in particular, one looks
for strong associations between the basis and a priori
known groups of samples. Plotting the profiles may
highlight such patterns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  profplot(x, ...)

  ## Default S3 method:
 profplot(x, y,
    scale = c("none", "max", "c1"), match.names = TRUE,
    legend = TRUE, confint = TRUE, Colv, labels,
    annotation, ..., add = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="profplot_+3A_x">x</code></td>
<td>
<p>a matrix or an NMF object from which is
extracted the mixture coefficient matrix. It is extracted
from the best fit if <code>x</code> is the results from
multiple NMF runs.</p>
</td></tr>
<tr><td><code id="profplot_+3A_y">y</code></td>
<td>
<p>a matrix or an NMF object from which is
extracted the mixture coefficient matrix. It is extracted
from the best fit if <code>y</code> is the results from
multiple NMF runs.</p>
</td></tr>
<tr><td><code id="profplot_+3A_scale">scale</code></td>
<td>
<p>specifies how the data should be scaled
before plotting. If <code>'none'</code> or <code>NA</code>, then no
scaling is applied and the &quot;raw&quot; data is plotted. If
<code>TRUE</code> or <code>'max'</code> then each row of both
matrices are normalised with their respective maximum
values. If <code>'c1'</code>, then each column of both matrix
is scaled into proportions (i.e. to sum up to one).
Default is <code>'none'</code>.</p>
</td></tr>
<tr><td><code id="profplot_+3A_match.names">match.names</code></td>
<td>
<p>a logical that indicates if the
profiles in <code>y</code> should be subset and/or re-ordered
to match the profile names in <code>x</code> (i.e. the
rownames). This is attempted only when both <code>x</code> and
<code>y</code> have names.</p>
</td></tr>
<tr><td><code id="profplot_+3A_legend">legend</code></td>
<td>
<p>a logical that specifies whether drawing
the legend or not, or coordinates specifications passed
to argument <code>x</code> of <code><a href="graphics.html#topic+legend">legend</a></code>, that
specifies the position of the legend.</p>
</td></tr>
<tr><td><code id="profplot_+3A_confint">confint</code></td>
<td>
<p>logical that indicates if confidence
intervals for the R-squared should be shown in legend.</p>
</td></tr>
<tr><td><code id="profplot_+3A_colv">Colv</code></td>
<td>
<p>specifies the way the columns of <code>x</code> are
ordered before plotting. It is used only when <code>y</code> is
missing.  It can be: </p>
 <ul>
<li><p> a single numeric
value, specifying the index of a row of <code>x</code>, that is
used to order the columns by <code>x[,
  order(x[abs(Colv),])]</code>. Decreasing order is specified
with a negative index.  </p>
</li>
<li><p> an integer vector directly
specifying the order itself, in which case the columns
are ordered by <code>x[, Colv]</code> </p>
</li>
<li><p> a factor used to
order the columns by <code>x[, order(Colv)]</code> and as
argument <code>annotation</code> if this latter is missing or
not <code>NA</code>.  </p>
</li>
<li><p> any other object with a suitable
<code>order</code> method. The columns are by <code>x[,
  order(Colv)]</code> </p>
</li></ul>
</td></tr>
<tr><td><code id="profplot_+3A_labels">labels</code></td>
<td>
<p>a character vector containing labels for
each sample (i.e. each column of <code>x</code>). These are
used for labelling the x-axis.</p>
</td></tr>
<tr><td><code id="profplot_+3A_annotation">annotation</code></td>
<td>
<p>a factor annotating each sample (i.e.
each column of <code>x</code>). If not missing, a coloured raw
is plotted under the x-axis and annotates each sample
accordingly. If argument <code>Colv</code> is a factor, then it
is used to annotate the plot, unless
<code>annotation=NA</code>.</p>
</td></tr>
<tr><td><code id="profplot_+3A_...">...</code></td>
<td>
<p>graphical parameters passed to
<code><a href="graphics.html#topic+matplot">matplot</a></code> or <code><a href="graphics.html#topic+matpoints">matpoints</a></code>.</p>
</td></tr>
<tr><td><code id="profplot_+3A_add">add</code></td>
<td>
<p>logical that indicates if the plot should be
added as points to a previous plot</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function can also be used to compare the profiles
from two NMF models or mixture coefficient matrices. In
this case, it draws a scatter plot of the paired
profiles.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+profcor">profcor</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# create a random target matrix
v &lt;- rmatrix(30, 10)

# fit a single NMF model
res &lt;- nmf(v, 3)
profplot(res)

# fit a multi-run NMF model
res2 &lt;- nmf(v, 3, nrun=2)
# ordering according to first profile
profplot(res2, Colv=1) # increasing

# draw a profile correlation plot: this show how the basis components are
# returned in an unpredictable order
profplot(res, res2)

# looking at all the correlations allow to order the components in a "common" order
profcor(res, res2)
</code></pre>

<hr>
<h2 id='purity'>Purity and Entropy of a Clustering</h2><span id='topic+entropy'></span><span id='topic+entropy+2CANY+2CANY-method'></span><span id='topic+entropy+2Cfactor+2CANY-method'></span><span id='topic+entropy-methods'></span><span id='topic+entropy+2CNMFfitXn+2CANY-method'></span><span id='topic+entropy+2Ctable+2Cmissing-method'></span><span id='topic+purity'></span><span id='topic+purity+2CANY+2CANY-method'></span><span id='topic+purity+2Cfactor+2CANY-method'></span><span id='topic+purity-methods'></span><span id='topic+purity+2CNMFfitXn+2CANY-method'></span><span id='topic+purity+2Ctable+2Cmissing-method'></span>

<h3>Description</h3>

<p>The functions <code>purity</code> and <code>entropy</code>
respectively compute the purity and the entropy of a
clustering given <em>a priori</em> known classes.
</p>
<p>The purity and entropy measure the ability of a
clustering method, to recover known classes (e.g. one
knows the true class labels of each sample), that are
applicable even when the number of cluster is different
from the number of known classes. <cite>Kim et al.
(2007)</cite> used these measures to evaluate the performance
of their alternate least-squares NMF algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  purity(x, y, ...)

  entropy(x, y, ...)

  ## S4 method for signature 'NMFfitXn,ANY'
purity(x, y, method = "best",
    ...)

  ## S4 method for signature 'NMFfitXn,ANY'
entropy(x, y, method = "best",
    ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="purity_+3A_x">x</code></td>
<td>
<p>an object that can be interpreted as a factor or
can generate such an object, e.g. via a suitable method
<code><a href="#topic+predict">predict</a></code>, which gives the cluster membership
for each sample.</p>
</td></tr>
<tr><td><code id="purity_+3A_y">y</code></td>
<td>
<p>a factor or an object coerced into a factor that
gives the true class labels for each sample. It may be
missing if <code>x</code> is a contingency table.</p>
</td></tr>
<tr><td><code id="purity_+3A_...">...</code></td>
<td>
<p>extra arguments to allow extension, and
usually passed to the next method.</p>
</td></tr>
<tr><td><code id="purity_+3A_method">method</code></td>
<td>
<p>a character string that specifies how the
value is computed. It may be either <code>'best'</code> or
<code>'mean'</code> to compute the best or mean purity
respectively.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Suppose we are given <code class="reqn">l</code> categories, while the
clustering method generates <code class="reqn">k</code> clusters.
</p>
<p>The purity of the clustering with respect to the known
categories is given by: </p>
<p style="text-align: center;"><code class="reqn">Purity = \frac{1}{n}
  \sum_{q=1}^k \max_{1 \leq j \leq l} n_q^j</code>
</p>
<p> ,
</p>
<p>where: </p>
 <ul>
<li> <p><code class="reqn">n</code> is the total number of
samples; </p>
</li>
<li> <p><code class="reqn">n_q^j</code> is the number of samples in
cluster <code class="reqn">q</code> that belongs to original class <code class="reqn">j</code>
(<code class="reqn">1 \leq j \leq l</code>). </p>
</li></ul>

<p>The purity is therefore a real number in <code class="reqn">[0,1]</code>. The
larger the purity, the better the clustering performance.
</p>
<p>The entropy of the clustering with respect to the known
categories is given by: </p>
<p style="text-align: center;"><code class="reqn">Entropy = - \frac{1}{n
  \log_2 l} \sum_{q=1}^k \sum_{j=1}^l n_q^j \log_2
  \frac{n_q^j}{n_q}</code>
</p>
<p>,
</p>
<p>where: </p>
 <ul>
<li> <p><code class="reqn">n</code> is the total number of
samples; </p>
</li>
<li> <p><code class="reqn">n</code> is the total number of
samples in cluster <code class="reqn">q</code> (<code class="reqn">1 \leq q \leq k</code>); </p>
</li>
<li>
<p><code class="reqn">n_q^j</code> is the number of samples in cluster
<code class="reqn">q</code> that belongs to original class <code class="reqn">j</code> (<code class="reqn">1
  \leq j \leq l</code>). </p>
</li></ul>

<p>The smaller the entropy, the better the clustering
performance.
</p>


<h3>Value</h3>

<p>a single numeric value
</p>
<p>the entropy (i.e. a single numeric value)
</p>


<h3>Methods</h3>


<dl>
<dt>entropy</dt><dd><p><code>signature(x = "table", y =
  "missing")</code>: Computes the purity directly from the
contingency table <code>x</code>.
</p>
<p>This is the workhorse method that is eventually called by
all other methods. </p>
</dd>
<dt>entropy</dt><dd><p><code>signature(x = "factor", y = "ANY")</code>:
Computes the purity on the contingency table of <code>x</code>
and <code>y</code>, that is coerced into a factor if necessary.
</p>
</dd>
<dt>entropy</dt><dd><p><code>signature(x = "ANY", y = "ANY")</code>:
Default method that should work for results of clustering
algorithms, that have a suitable <code>predict</code> method
that returns the cluster membership vector: the purity is
computed between <code>x</code> and <code>predict{y}</code> </p>
</dd>
<dt>entropy</dt><dd><p><code>signature(x = "NMFfitXn", y =
  "ANY")</code>: Computes the best or mean entropy across all NMF
fits stored in <code>x</code>. </p>
</dd>
<dt>purity</dt><dd><p><code>signature(x = "table", y =
  "missing")</code>: Computes the purity directly from the
contingency table <code>x</code> </p>
</dd>
<dt>purity</dt><dd><p><code>signature(x = "factor", y = "ANY")</code>:
Computes the purity on the contingency table of <code>x</code>
and <code>y</code>, that is coerced into a factor if necessary.
</p>
</dd>
<dt>purity</dt><dd><p><code>signature(x = "ANY", y = "ANY")</code>:
Default method that should work for results of clustering
algorithms, that have a suitable <code>predict</code> method
that returns the cluster membership vector: the purity is
computed between <code>x</code> and <code>predict{y}</code> </p>
</dd>
<dt>purity</dt><dd><p><code>signature(x = "NMFfitXn", y =
  "ANY")</code>: Computes the best or mean purity across all NMF
fits stored in <code>x</code>. </p>
</dd>
</dl>



<h3>References</h3>

<p>Kim H and Park H (2007). &quot;Sparse non-negative matrix
factorizations via alternating non-negativity-constrained
least squares for microarray data analysis.&quot;
_Bioinformatics (Oxford, England)_, *23*(12), pp.
1495-502. ISSN 1460-2059, &lt;URL:
http://dx.doi.org/10.1093/bioinformatics/btm134&gt;, &lt;URL:
http://www.ncbi.nlm.nih.gov/pubmed/17483501&gt;.
</p>


<h3>See Also</h3>

<p>Other assess: <code><a href="#topic+sparseness">sparseness</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# generate a synthetic dataset with known classes: 50 features, 18 samples (5+5+8)
n &lt;- 50; counts &lt;- c(5, 5, 8);
V &lt;- syntheticNMF(n, counts)
cl &lt;- unlist(mapply(rep, 1:3, counts))

# perform default NMF with rank=2
x2 &lt;- nmf(V, 2)
purity(x2, cl)
entropy(x2, cl)
# perform default NMF with rank=2
x3 &lt;- nmf(V, 3)
purity(x3, cl)
entropy(x3, cl)
</code></pre>

<hr>
<h2 id='randomize'>Randomizing Data</h2><span id='topic+randomize'></span>

<h3>Description</h3>

<p><code>randomize</code> permutates independently the entries in
each column of a matrix-like object, to produce random
data that can be used in permutation tests or bootstrap
analysis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  randomize(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="randomize_+3A_x">x</code></td>
<td>
<p>data to be permutated. It must be an object
suitable to be passed to the function
<code><a href="base.html#topic+apply">apply</a></code>.</p>
</td></tr>
<tr><td><code id="randomize_+3A_...">...</code></td>
<td>
<p>extra arguments passed to the function
<code><a href="base.html#topic+sample">sample</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In the context of NMF, it may be used to generate random
data, whose factorization serves as a reference for
selecting a factorization rank, that does not overfit the
data.
</p>


<h3>Value</h3>

<p>a matrix
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

x &lt;- matrix(1:32, 4, 8)
randomize(x)
randomize(x)
</code></pre>

<hr>
<h2 id='registerDoBackend'>Utilities and Extensions for Foreach Loops</h2><span id='topic+ForeachBackend'></span><span id='topic+ForeachBackend+2CANY-method'></span><span id='topic+ForeachBackend+2Ccharacter-method'></span><span id='topic+ForeachBackend+2Ccluster-method'></span><span id='topic+ForeachBackend+2CdoMPI_backend-method'></span><span id='topic+ForeachBackend+2CdoParallel_backend-method'></span><span id='topic+ForeachBackend+2CdoParallelMC_backend-method'></span><span id='topic+ForeachBackend+2CdoParallelSNOW_backend-method'></span><span id='topic+ForeachBackend+2CdoPSOCK_backend-method'></span><span id='topic+ForeachBackend-methods'></span><span id='topic+ForeachBackend+2Cmissing-method'></span><span id='topic+ForeachBackend+2Cmpicluster-method'></span><span id='topic+ForeachBackend+2CNULL-method'></span><span id='topic+ForeachBackend+2Cnumeric-method'></span><span id='topic+getDoBackend'></span><span id='topic+getDoParHosts'></span><span id='topic+getDoParHosts+2CANY-method'></span><span id='topic+getDoParHosts-methods'></span><span id='topic+getDoParNHosts'></span><span id='topic+register'></span><span id='topic+registerDoBackend'></span><span id='topic+setDoBackend'></span>

<h3>Description</h3>

<p><code>registerDoBackend</code> is a unified register function
for foreach backends.
</p>
<p><code>getDoBackend</code> returns the internal data of the
currently registered foreach %dopar% backend.
</p>
<p><code>setDoBackend</code> is identical to
<code><a href="foreach.html#topic+setDoPar">setDoPar</a></code>, but returns the internal
of the previously registered backend.
</p>
<p><code>register</code> is a generic function that register
objects. It is used to as a unified interface to register
foreach backends.
</p>
<p><code>ForeachBackend</code> is a factory method for foreach
backend objects.
</p>
<p><code>getDoParHosts</code> is a generic function that returns
the hostname of the worker nodes used by a backend.
</p>
<p><code>getDoParNHosts</code> returns the number of hosts used by
a backend.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  registerDoBackend(object, ...)

  getDoBackend()

  setDoBackend(data, cleanup = FALSE)

  register(x, ...)

  ForeachBackend(object, ...)

  ## S4 method for signature 'doParallel_backend'
ForeachBackend(object, cl,
    type = NULL)

  ## S4 method for signature 'doPSOCK_backend'
ForeachBackend(object, cl)

  ## S4 method for signature 'doMPI_backend'
ForeachBackend(object, cl)

  getDoParHosts(object, ...)

  getDoParNHosts(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="registerDoBackend_+3A_object">object</code></td>
<td>
<p>specification of a foreach backend, e.g.
&lsquo;SEQ&rsquo;, &lsquo;PAR&rsquo; (for doParallel),
&lsquo;MPI&rsquo;, etc...</p>
</td></tr>
<tr><td><code id="registerDoBackend_+3A_...">...</code></td>
<td>
<p>extra arguments passed to the backend own
registration function.</p>
</td></tr>
<tr><td><code id="registerDoBackend_+3A_data">data</code></td>
<td>
<p>internal data of a foreach %dopar%
backend.</p>
</td></tr>
<tr><td><code id="registerDoBackend_+3A_cleanup">cleanup</code></td>
<td>
<p>logical that indicates if the previous
backend's cleanup procedure should be run,
<strong>before</strong> setting the new backend.</p>
</td></tr>
<tr><td><code id="registerDoBackend_+3A_x">x</code></td>
<td>
<p>specification of a foreach backend</p>
</td></tr>
<tr><td><code id="registerDoBackend_+3A_cl">cl</code></td>
<td>
<p>cluster specification: a cluster object or a
numeric that indicates the number of nodes to use.</p>
</td></tr>
<tr><td><code id="registerDoBackend_+3A_type">type</code></td>
<td>
<p>type of cluster, See
<code><a href="parallel.html#topic+makeCluster">makeCluster</a></code>.</p>
</td></tr>
</table>


<h3>Methods</h3>


<dl>
<dt>ForeachBackend</dt><dd><p><code>signature(object = "ANY")</code>:
Default method defined to throw an informative error
message, when no other method was found. </p>
</dd>
<dt>ForeachBackend</dt><dd><p><code>signature(object =
  "character")</code>: Creates a foreach backend object based on
its name. </p>
</dd>
<dt>ForeachBackend</dt><dd><p><code>signature(object =
  "missing")</code>: Creates a foreach backend object for the
currently registered backend. </p>
</dd>
<dt>ForeachBackend</dt><dd><p><code>signature(object = "NULL")</code>:
Dummy method that returns <code>NULL</code>, defined for
correct dispatch. </p>
</dd>
<dt>ForeachBackend</dt><dd><p><code>signature(object =
  "cluster")</code>: Creates a doParallel foreach backend that
uses the cluster described in <code>object</code>. </p>
</dd>
<dt>ForeachBackend</dt><dd><p><code>signature(object =
  "numeric")</code>: Creates a doParallel foreach backend with
<code>object</code> processes. </p>
</dd>
<dt>ForeachBackend</dt><dd><p><code>signature(object =
  "doParallel_backend")</code>: doParallel-specific backend
factory </p>
</dd>
<dt>ForeachBackend</dt><dd><p><code>signature(object =
  "doParallelMC_backend")</code>: doParallel-specific backend
factory for multicore (fork) clusters
</p>
<p>This method is needed since version 1.0.7 of
<span class="pkg">doParallel</span>, which removed internal function
<code>info</code> and defined separate backend names for mc and
snow clusters. </p>
</dd>
<dt>ForeachBackend</dt><dd><p><code>signature(object =
  "doParallelSNOW_backend")</code>: doParallel-specific backend
factory for SNOW clusters.
</p>
<p>This method is needed since version 1.0.7 of
<span class="pkg">doParallel</span>, which removed internal function
<code>info</code> and defined separate backend names for mc and
snow clusters. </p>
</dd>
<dt>ForeachBackend</dt><dd><p><code>signature(object =
  "doPSOCK_backend")</code>: doSNOW-specific backend factory </p>
</dd>
<dt>ForeachBackend</dt><dd><p><code>signature(object =
  "mpicluster")</code>: Creates a doMPI foreach backend that uses
the MPI cluster described in <code>object</code>. </p>
</dd>
<dt>ForeachBackend</dt><dd><p><code>signature(object =
  "doMPI_backend")</code>: doMPI-specific backend factory </p>
</dd>
<dt>getDoParHosts</dt><dd><p><code>signature(object = "ANY")</code>:
Default method that tries to heuristaically infer the
number of hosts and in last resort temporarly register
the backend and performs a foreach loop, to retrieve the
nodename from each worker. </p>
</dd>
</dl>


<hr>
<h2 id='residuals'>Residuals in NMF Models</h2><span id='topic+hasTrack'></span><span id='topic+residuals'></span><span id='topic+residuals+3C-'></span><span id='topic+residuals+3C--methods'></span><span id='topic+residuals-methods'></span><span id='topic+residuals+3C-+2CNMFfit-method'></span><span id='topic+residuals+2CNMFfit-method'></span><span id='topic+residuals+2CNMFfitX-method'></span><span id='topic+trackError'></span>

<h3>Description</h3>

<p>The package NMF defines methods for the function
<code><a href="stats.html#topic+residuals">residuals</a></code> that returns the final
residuals of an NMF fit or the track of the residuals
along the fit process, computed according to the
objective function associated with the algorithm that
fitted the model.
</p>
<p><code>residuals&lt;-</code> sets the value of the last residuals,
or, optionally, of the complete residual track.
</p>
<p>Tells if an <code>NMFfit</code> object contains a recorded
residual track.
</p>
<p><code>trackError</code> adds a residual value to the track of
residuals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  residuals(object, ...)

  ## S4 method for signature 'NMFfit'
residuals(object, track = FALSE,
    niter = NULL, ...)

  residuals(object, ...)&lt;-value

  ## S4 replacement method for signature 'NMFfit'
residuals(object, ..., niter = NULL,
    track = FALSE)&lt;-value

  hasTrack(object, niter = NULL)

  trackError(object, value, niter, force = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="residuals_+3A_object">object</code></td>
<td>
<p>an <code>NMFfit</code> object as fitted by
function <code><a href="#topic+nmf">nmf</a></code>, in single run mode.</p>
</td></tr>
<tr><td><code id="residuals_+3A_...">...</code></td>
<td>
<p>extra parameters (not used)</p>
</td></tr>
<tr><td><code id="residuals_+3A_track">track</code></td>
<td>
<p>a logical that indicates if the complete
track of residuals should be returned (if it has been
computed during the fit), or only the last value.</p>
</td></tr>
<tr><td><code id="residuals_+3A_niter">niter</code></td>
<td>
<p>specifies the iteration number for which one
wants to get/set/test a residual value. This argument is
used only if not <code>NULL</code></p>
</td></tr>
<tr><td><code id="residuals_+3A_value">value</code></td>
<td>
<p>residual value</p>
</td></tr>
<tr><td><code id="residuals_+3A_force">force</code></td>
<td>
<p>logical that indicates if the value should
be added to the track even if there already is a value
for this iteration number or if the iteration does not
conform to the tracking interval
<code>nmf.getOption('track.interval')</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When called with <code>track=TRUE</code>, the whole residuals
track is returned, if available. Note that method
<code><a href="#topic+nmf">nmf</a></code> does not compute the residuals track,
unless explicitly required.
</p>
<p>It is a S4 methods defined for the associated generic
functions from package <code>stats</code> (See
<a href="stats.html#topic+residuals">residuals</a>).
</p>


<h3>Value</h3>

<p><code>residuals</code> returns a single numeric value if
<code>track=FALSE</code> or a numeric vector containing the
residual values at some iterations. The names correspond
to the iterations at which the residuals were computed.
</p>


<h3>Methods</h3>


<dl>
<dt>residuals</dt><dd><p><code>signature(object = "NMFfit")</code>:
Returns the residuals &ndash; track &ndash; between the target
matrix and the NMF fit <code>object</code>. </p>
</dd>
<dt>residuals</dt><dd><p><code>signature(object = "NMFfitX")</code>:
Returns the residuals achieved by the best fit object,
i.e. the lowest residual approximation error achieved
across all NMF runs. </p>
</dd>
</dl>



<h3>Note</h3>

<p>Stricly speaking, the method <code>residuals,NMFfit</code> does
not fulfill its contract as defined by the package
<code>stats</code>, but rather acts as function
<code>deviance</code>. The might be changed in a later release
to make it behave as it should.
</p>


<h3>See Also</h3>

<p>Other stats: <code><a href="#topic+deviance">deviance</a></code>,
<code><a href="#topic+deviance+2CNMF-method">deviance,NMF-method</a></code>,
<code><a href="#topic+nmfDistance">nmfDistance</a></code>
</p>

<hr>
<h2 id='revPalette'>Flags a Color Palette Specification for Reversion</h2><span id='topic+revPalette'></span>

<h3>Description</h3>

<p>Flags a Color Palette Specification for Reversion
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  revPalette(x)
</code></pre>

<hr>
<h2 id='rmatrix'>Generating Random Matrices</h2><span id='topic+rmatrix'></span><span id='topic+rmatrix+2CANY-method'></span><span id='topic+rmatrix-methods'></span><span id='topic+rmatrix+2CNMF-method'></span><span id='topic+rmatrix+2Cnumeric-method'></span>

<h3>Description</h3>

<p>The S4 generic <code>rmatrix</code> generates a random matrix
from a given object. Methods are provided to generate
matrices with entries drawn from any given random
distribution function, e.g. <code><a href="stats.html#topic+runif">runif</a></code> or
<code><a href="stats.html#topic+rnorm">rnorm</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  rmatrix(x, ...)

  ## S4 method for signature 'numeric'
rmatrix(x, y = NULL, dist = runif,
    byrow = FALSE, dimnames = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rmatrix_+3A_x">x</code></td>
<td>
<p>object from which to generate a random matrix</p>
</td></tr>
<tr><td><code id="rmatrix_+3A_y">y</code></td>
<td>
<p>optional specification of number of columns</p>
</td></tr>
<tr><td><code id="rmatrix_+3A_dist">dist</code></td>
<td>
<p>a random distribution function or a numeric
seed (see details of method <code>rmatrix,numeric</code>)</p>
</td></tr>
<tr><td><code id="rmatrix_+3A_byrow">byrow</code></td>
<td>
<p>a logical passed in the internal call to the
function <code><a href="base.html#topic+matrix">matrix</a></code></p>
</td></tr>
<tr><td><code id="rmatrix_+3A_dimnames">dimnames</code></td>
<td>
<p><code>NULL</code> or a <code>list</code> passed in
the internal call to the function <code><a href="base.html#topic+matrix">matrix</a></code></p>
</td></tr>
<tr><td><code id="rmatrix_+3A_...">...</code></td>
<td>
<p>extra arguments passed to the distribution
function <code>dist</code>.</p>
</td></tr>
</table>


<h3>Methods</h3>


<dl>
<dt>rmatrix</dt><dd><p><code>signature(x = "numeric")</code>: Generates
a random matrix of given dimensions, whose entries are
drawn using the distribution function <code>dist</code>.
</p>
<p>This is the workhorse method that is eventually called by
all other methods. It returns a matrix with: </p>

<ul>
<li> <p><code>x</code> rows and <code>y</code> columns if <code>y</code> is
not missing and not <code>NULL</code>; </p>
</li>
<li><p> dimension
<code>x[1]</code> x <code>x[2]</code> if <code>x</code> has at least two
elements; </p>
</li>
<li><p> dimension <code>x</code> (i.e. a square matrix)
otherwise. </p>
</li></ul>

<p>The default is to draw its entries from the standard
uniform distribution using the base function
<code><a href="stats.html#topic+runif">runif</a></code>, but any other function that
generates random numeric vectors of a given length may be
specified in argument <code>dist</code>. All arguments in
<code>...</code> are passed to the function specified in
<code>dist</code>.
</p>
<p>The only requirement is that the function in <code>dist</code>
is of the following form:
</p>
<p>&lsquo;<span class="samp">&#8288; function(n, ...){ # return vector of length n ...
  }&#8288;</span>&rsquo;
</p>
<p>This is the case of all base random draw function such as
<code><a href="stats.html#topic+rnorm">rnorm</a></code>, <code><a href="stats.html#topic+rgamma">rgamma</a></code>, etc... </p>
</dd>
<dt>rmatrix</dt><dd><p><code>signature(x = "ANY")</code>: Default
method which calls <code>rmatrix,vector</code> on the
dimensions of <code>x</code> that is assumed to be returned by
a suitable <code>dim</code> method: it is equivalent to
<code>rmatrix(dim(x), y=NULL, ...)</code>. </p>
</dd>
<dt>rmatrix</dt><dd><p><code>signature(x = "NMF")</code>: Returns the
target matrix estimate of the NMF model <code>x</code>,
perturbated by adding a random matrix generated using the
default method of <code>rmatrix</code>: it is a equivalent to
<code>fitted(x) + rmatrix(fitted(x), ...)</code>.
</p>
<p>This method can be used to generate random target
matrices that depart from a known NMF model to a
controlled extend. This is useful to test the robustness
of NMF algorithms to the presence of certain types of
noise in the data. </p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>

#----------
# rmatrix,numeric-method
#----------
## Generate a random matrix of a given size
rmatrix(5, 3)


## Generate a random matrix of the same dimension of a template matrix
a &lt;- matrix(1, 3, 4)
rmatrix(a)


## Specificy the distribution to use

# the default is uniform
a &lt;- rmatrix(1000, 50)
## Not run:  hist(a) 

# use normal ditribution
a &lt;- rmatrix(1000, 50, rnorm)
## Not run:  hist(a) 

# extra arguments can be passed to the random variate generation function
a &lt;- rmatrix(1000, 50, rnorm, mean=2, sd=0.5)
## Not run:  hist(a) 

#----------
# rmatrix,ANY-method
#----------
# random matrix of the same dimension as another matrix
x &lt;- matrix(3,4)
dim(rmatrix(x))

#----------
# rmatrix,NMF-method
#----------
# generate noisy fitted target from an NMF model (the true model)
gr &lt;- as.numeric(mapply(rep, 1:3, 3))
h &lt;- outer(1:3, gr, '==') + 0
x &lt;- rnmf(10, H=h)
y &lt;- rmatrix(x)
## Not run: 
# show heatmap of the noisy target matrix: block patterns should be clear
aheatmap(y)

## End(Not run)


# test NMF algorithm on noisy data
# add some noise to the true model (drawn from uniform [0,1])
res &lt;- nmf(rmatrix(x), 3)
summary(res)

# add more noise to the true model (drawn from uniform [0,10])
res &lt;- nmf(rmatrix(x, max=10), 3)
summary(res)
</code></pre>

<hr>
<h2 id='rnmf'>Generating Random NMF Models</h2><span id='topic+rnmf'></span><span id='topic+rnmf+2CANY+2Cdata.frame-method'></span><span id='topic+rnmf+2CANY+2Cmatrix-method'></span><span id='topic+rnmf+2Cformula+2CANY-method'></span><span id='topic+rnmf-methods'></span><span id='topic+rnmf+2Cmissing+2Cmissing-method'></span><span id='topic+rnmf+2CNMF+2Cmissing-method'></span><span id='topic+rnmf+2CNMF+2Cnumeric-method'></span><span id='topic+rnmf+2CNMFOffset+2Cnumeric-method'></span><span id='topic+rnmf+2Cnumeric+2Cmissing-method'></span><span id='topic+rnmf+2Cnumeric+2Cnumeric-method'></span>

<h3>Description</h3>

<p>Generates NMF models with random values drawn from a
uniform distribution. It returns an NMF model with basis
and mixture coefficient matrices filled with random
values. The main purpose of the function <code>rnmf</code> is
to provide a common interface to generate random seeds
used by the <code><a href="#topic+nmf">nmf</a></code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  rnmf(x, target, ...)

  ## S4 method for signature 'NMF,numeric'
rnmf(x, target, ncol = NULL,
    keep.names = TRUE, dist = runif)

  ## S4 method for signature 'ANY,matrix'
rnmf(x, target, ...,
    dist = list(max = max(max(target, na.rm = TRUE), 1)),
    use.dimnames = TRUE)

  ## S4 method for signature 'numeric,missing'
rnmf(x, target, ..., W, H,
    dist = runif)

  ## S4 method for signature 'missing,missing'
rnmf(x, target, ..., W, H)

  ## S4 method for signature 'numeric,numeric'
rnmf(x, target, ncol = NULL,
    ..., dist = runif)

  ## S4 method for signature 'formula,ANY'
rnmf(x, target, ...,
    dist = runif)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rnmf_+3A_x">x</code></td>
<td>
<p>an object that determines the rank, dimension
and/or class of the generated NMF model, e.g. a numeric
value or an object that inherits from class
<code><a href="#topic+NMF-class">NMF</a></code>. See the description of the
specific methods for more details on the supported
types.</p>
</td></tr>
<tr><td><code id="rnmf_+3A_target">target</code></td>
<td>
<p>optional specification of target
dimensions. See section <em>Methods</em> for how this
parameter is used by the different methods.</p>
</td></tr>
<tr><td><code id="rnmf_+3A_...">...</code></td>
<td>
<p>extra arguments to allow extensions and passed
to the next method eventually down to
<code><a href="#topic+nmfModel">nmfModel</a></code>, where they are used to initialise
slots that are specific to the instantiating NMF model.</p>
</td></tr>
<tr><td><code id="rnmf_+3A_ncol">ncol</code></td>
<td>
<p>single numeric value that specifies the
number of columns of the coefficient matrix. Only used
when <code>target</code> is a single numeric value.</p>
</td></tr>
<tr><td><code id="rnmf_+3A_keep.names">keep.names</code></td>
<td>
<p>a logical that indicates if the
dimension names of the original NMF object <code>x</code>
should be conserved (<code>TRUE</code>) or discarded
(<code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="rnmf_+3A_dist">dist</code></td>
<td>
<p>specification of the random distribution to
use to draw the entries of the basis and coefficient
matrices. It may be specified as: </p>

<ul>
<li><p> a <code>function</code> which must be a distribution
function such as e.g. <code><a href="stats.html#topic+runif">runif</a></code> that is used to
draw the entries of both the basis and coefficient
matrices. It is passed in the <code>dist</code> argument of
<code><a href="#topic+rmatrix">rmatrix</a></code>.
</p>
</li>
<li><p> a <code>list</code> of arguments that are passed
internally to <code><a href="#topic+rmatrix">rmatrix</a></code>, via
<code>do.call('rmatrix', dist)</code>.
</p>
</li>
<li><p> a <code>character</code> string that is partially matched
to &lsquo;basis&rsquo; or &lsquo;coef&rsquo;, that specifies which
matrix in should be drawn randomly, the other remaining
as in <code>x</code> &ndash; unchanged.
</p>
</li>
<li><p> a <code>list</code> with elements &lsquo;basis&rsquo; and/or
&lsquo;coef&rsquo;, which specify the <code>dist</code> argument
separately for the basis and coefficient matrix
respectively.
</p>
<p>These elements may be either a distribution function, or
a list of arguments that are passed internally to
<code><a href="#topic+rmatrix">rmatrix</a></code>, via <code>do.call('rmatrix',
  dist$basis)</code> or <code>do.call('rmatrix', dist$coef)</code>. </p>
</li></ul>
</td></tr>
<tr><td><code id="rnmf_+3A_use.dimnames">use.dimnames</code></td>
<td>
<p>a logical that indicates whether the
dimnames of the target matrix should be set on the
returned NMF model.</p>
</td></tr>
<tr><td><code id="rnmf_+3A_w">W</code></td>
<td>
<p>value for the basis matrix. <code>data.frame</code>
objects are converted into matrices with
<code><a href="base.html#topic+as.matrix">as.matrix</a></code>.</p>
</td></tr>
<tr><td><code id="rnmf_+3A_h">H</code></td>
<td>
<p>value for the mixture coefficient matrix
<code>data.frame</code> objects are converted into matrices
with <code><a href="base.html#topic+as.matrix">as.matrix</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If necessary, extensions of the standard NMF model or
custom models must define a method
&quot;rnmf,&lt;NMF.MODEL.CLASS&gt;,numeric&quot; for initialising their
specific slots other than the basis and mixture
coefficient matrices. In order to benefit from the
complete built-in interface, the overloading methods
should call the generic version using function
<code><a href="methods.html#topic+callNextMethod">callNextMethod</a></code>, prior to set the values of
the specific slots. See for example the method
<code><a href="#topic+rnmf+2CNMFOffset+2Cnumeric-method">rnmf</a></code>
defined for <code><a href="#topic+NMFOffset-class">NMFOffset</a></code> models:
<code>showMethods(rnmf, class='NMFOffset',
  include=TRUE))</code>.
</p>
<p>For convenience, shortcut methods for working on
<code>data.frame</code> objects directly are implemented.
However, note that conversion of a <code>data.frame</code> into
a <code>matrix</code> object may take some non-negligible time,
for large datasets. If using this method or other
NMF-related methods several times, consider converting
your data <code>data.frame</code> object into a matrix once for
good, when first loaded.
</p>


<h3>Value</h3>

<p>An NMF model, i.e. an object that inherits from class
<code><a href="#topic+NMF-class">NMF</a></code>.
</p>


<h3>Methods</h3>


<dl>
<dt>rnmf</dt><dd><p><code>signature(x = "NMFOffset", target =
  "numeric")</code>: Generates a random NMF model with offset,
from class <code>NMFOffset</code>.
</p>
<p>The offset values are drawn from a uniform distribution
between 0 and the maximum entry of the basis and
coefficient matrices, which are drawn by the next
suitable <code><a href="#topic+rnmf">rnmf</a></code> method, which is the
workhorse method <code>rnmf,NMF,numeric</code>. </p>
</dd>
<dt>rnmf</dt><dd><p><code>signature(x = "NMF", target =
  "numeric")</code>: Generates a random NMF model of the same
class and rank as another NMF model.
</p>
<p>This is the workhorse method that is eventually called by
all other methods. It generates an NMF model of the same
class and rank as <code>x</code>, compatible with the
dimensions specified in <code>target</code>, that can be a
single or 2-length numeric vector, to specify a square or
rectangular target matrix respectively.
</p>
<p>The second dimension can also be passed via argument
<code>ncol</code>, so that calling <code>rnmf(x, 20, 10, ...)</code>
is equivalent to <code>rnmf(x, c(20, 10), ...)</code>, but
easier to write.
</p>
<p>The entries are uniformly drawn between <code>0</code> and
<code>max</code> (optionally specified in <code>...</code>) that
defaults to 1.
</p>
<p>By default the dimnames of <code>x</code> are set on the
returned NMF model. This behaviour is disabled with
argument <code>keep.names=FALSE</code>. See
<code><a href="#topic+nmfModel">nmfModel</a></code>. </p>
</dd>
<dt>rnmf</dt><dd><p><code>signature(x = "ANY", target =
  "matrix")</code>: Generates a random NMF model compatible and
consistent with a target matrix.
</p>
<p>The entries are uniformly drawn between <code>0</code> and
<code>max(target)</code>. It is more or less a shortcut for:
&lsquo;<span class="samp">&#8288; rnmf(x, dim(target), max=max(target), ...)&#8288;</span>&rsquo;
</p>
<p>It returns an NMF model of the same class as <code>x</code>. </p>
</dd>
<dt>rnmf</dt><dd><p><code>signature(x = "ANY", target =
  "data.frame")</code>: Shortcut for <code>rnmf(x,
  as.matrix(target))</code>. </p>
</dd>
<dt>rnmf</dt><dd><p><code>signature(x = "NMF", target =
  "missing")</code>: Generates a random NMF model of the same
dimension as another NMF model.
</p>
<p>It is a shortcut for <code>rnmf(x, nrow(x), ncol(x),
  ...)</code>, which returns a random NMF model of the same class
and dimensions as <code>x</code>. </p>
</dd>
<dt>rnmf</dt><dd><p><code>signature(x = "numeric", target =
  "missing")</code>: Generates a random NMF model of a given
rank, with known basis and/or coefficient matrices.
</p>
<p>This methods allow to easily generate partially random
NMF model, where one or both factors are known. Although
the later case might seems strange, it makes sense for
NMF models that have fit extra data, other than the basis
and coefficient matrices, that are drawn by an
<code>rnmf</code> method defined for their own class, which
should internally call <code>rnmf,NMF,numeric</code> and let it
draw the basis and coefficient matrices. (e.g. see
<code><a href="#topic+NMFOffset-class">NMFOffset</a></code> and
<code><a href="#topic+rnmf+2CNMFOffset+2Cnumeric-method">rnmf,NMFOffset,numeric-method</a></code>).
</p>
<p>Depending on whether arguments <code>W</code> and/or <code>H</code>
are missing, this method interprets <code>x</code> differently:
</p>

<ul>
<li> <p><code>W</code> provided, <code>H</code> missing: <code>x</code> is
taken as the number of columns that must be drawn to
build a random coefficient matrix (i.e. the number of
columns in the target matrix).
</p>
</li>
<li> <p><code>W</code> is missing, <code>H</code> is provided: <code>x</code>
is taken as the number of rows that must be drawn to
build a random basis matrix (i.e. the number of rows in
the target matrix).
</p>
</li>
<li><p> both <code>W</code> and <code>H</code> are provided: <code>x</code>
is taken as the target rank of the model to generate.
</p>
</li>
<li><p> Having both <code>W</code> and <code>H</code> missing produces
an error, as the dimension of the model cannot be
determined in this case. </p>
</li></ul>

<p>The matrices <code>W</code> and <code>H</code> are reduced if
necessary and possible to be consistent with this value
of the rank, by the internal call to
<code><a href="#topic+nmfModel">nmfModel</a></code>.
</p>
<p>All arguments in <code>...</code> are passed to the function
<code><a href="#topic+nmfModel">nmfModel</a></code> which is used to build an initial
NMF model, that is in turn passed to
<code>rnmf,NMF,numeric</code> with <code>dist=list(coef=dist)</code>
or <code>dist=list(basis=dist)</code> when suitable. The type
of NMF model to generate can therefore be specified in
argument <code>model</code> (see <code><a href="#topic+nmfModel">nmfModel</a></code> for
other possible arguments).
</p>
<p>The returned NMF model, has a basis matrix equal to
<code>W</code> (if not missing) and a coefficient matrix equal
to <code>H</code> (if not missing), or drawn according to the
specification provided in argument <code>dist</code> (see
method <code>rnmf,NMF,numeric</code> for details on the
supported values for <code>dist</code>). </p>
</dd>
<dt>rnmf</dt><dd><p><code>signature(x = "missing", target =
  "missing")</code>: Generates a random NMF model with known
basis and coefficient matrices.
</p>
<p>This method is a shortcut for calling
<code>rnmf,numeric,missing</code> with a suitable value for
<code>x</code> (the rank), when both factors are known:
<code>rnmf(min(ncol(W), nrow(H)), ..., W=W, H=H)</code>.
</p>
<p>Arguments <code>W</code> and <code>H</code> are required. Note that
calling this method only makes sense for NMF models that
contains data to fit other than the basis and coefficient
matrices, e.g. <code><a href="#topic+NMFOffset-class">NMFOffset</a></code>. </p>
</dd>
<dt>rnmf</dt><dd><p><code>signature(x = "numeric", target =
  "numeric")</code>: Generates a random standard NMF model of
given dimensions.
</p>
<p>This is a shortcut for <code>rnmf(nmfModel(x, target,
  ncol, ...)), dist=dist)</code>. It generates a standard NMF
model compatible with the dimensions passed in
<code>target</code>, that can be a single or 2-length numeric
vector, to specify a square or rectangular target matrix
respectively. See <code><a href="#topic+nmfModel">nmfModel</a></code>. </p>
</dd>
<dt>rnmf</dt><dd><p><code>signature(x = "formula", target =
  "ANY")</code>: Generate a random formula-based NMF model, using
the method <code><a href="#topic+nmfModel+2Cformula+2CANY-method">nmfModel,formula,ANY-method</a></code>. </p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+rmatrix">rmatrix</a></code>
</p>
<p>Other NMF-interface: <code><a href="#topic+basis">basis</a></code>,
<code><a href="#topic+.basis">.basis</a></code>, <code><a href="#topic+.basis+3C-">.basis&lt;-</a></code>,
<code><a href="#topic+basis+3C-">basis&lt;-</a></code>, <code><a href="#topic+coef">coef</a></code>,
<code><a href="#topic+.coef">.coef</a></code>, <code><a href="#topic+.coef+3C-">.coef&lt;-</a></code>,
<code><a href="#topic+coef+3C-">coef&lt;-</a></code>, <code><a href="#topic+coefficients">coefficients</a></code>,
<code><a href="#topic+.DollarNames+2CNMF-method">.DollarNames,NMF-method</a></code>,
<code><a href="#topic+loadings+2CNMF-method">loadings,NMF-method</a></code>, <code><a href="#topic+misc">misc</a></code>,
<code><a href="#topic+NMF-class">NMF-class</a></code>, <code><a href="#topic++24+3C-+2CNMF-method">$&lt;-,NMF-method</a></code>,
<code><a href="#topic++24+2CNMF-method">$,NMF-method</a></code>, <code><a href="#topic+nmfModel">nmfModel</a></code>,
<code><a href="#topic+nmfModels">nmfModels</a></code>, <code><a href="#topic+scoef">scoef</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

#----------
# rnmf,NMFOffset,numeric-method
#----------
# random NMF model with offset
x &lt;- rnmf(2, 3, model='NMFOffset')
x
offset(x)
# from a matrix
x &lt;- rnmf(2, rmatrix(5,3, max=10), model='NMFOffset')
offset(x)

#----------
# rnmf,NMF,numeric-method
#----------
## random NMF of same class and rank as another model

x &lt;- nmfModel(3, 10, 5)
x
rnmf(x, 20) # square
rnmf(x, 20, 13)
rnmf(x, c(20, 13))

# using another distribution
rnmf(x, 20, dist=rnorm)

# other than standard model
y &lt;- rnmf(3, 50, 10, model='NMFns')
y



#----------
# rnmf,ANY,matrix-method
#----------
# random NMF compatible with a target matrix
x &lt;- nmfModel(3, 10, 5)
y &lt;- rmatrix(20, 13)
rnmf(x, y) # rank of x
rnmf(2, y) # rank 2

#----------
# rnmf,NMF,missing-method
#----------
## random NMF from another model

a &lt;- nmfModel(3, 100, 20)
b &lt;- rnmf(a)


#----------
# rnmf,numeric,missing-method
#----------
# random NMF model with known basis matrix
x &lt;- rnmf(5, W=matrix(1:18, 6)) # 6 x 5 model with rank=3
basis(x) # fixed
coef(x) # random

# random NMF model with known coefficient matrix
x &lt;- rnmf(5, H=matrix(1:18, 3)) # 5 x 6 model with rank=3
basis(x) # random
coef(x) # fixed

# random model other than standard NMF
x &lt;- rnmf(5, H=matrix(1:18, 3), model='NMFOffset')
basis(x) # random
coef(x) # fixed
offset(x) # random

#----------
# rnmf,missing,missing-method
#----------
# random model other than standard NMF
x &lt;- rnmf(W=matrix(1:18, 6), H=matrix(21:38, 3), model='NMFOffset')
basis(x) # fixed
coef(x) # fixed
offset(x) # random

#----------
# rnmf,numeric,numeric-method
#----------
## random standard NMF of given dimensions

# generate a random NMF model with rank 3 that fits a 100x20 matrix
rnmf(3, 100, 20)

# generate a random NMF model with rank 3 that fits a 100x100 matrix
rnmf(3, 100)

</code></pre>

<hr>
<h2 id='rss'>Residual Sum of Squares and Explained Variance</h2><span id='topic+evar'></span><span id='topic+evar+2CANY-method'></span><span id='topic+evar-methods'></span><span id='topic+rss'></span><span id='topic+rss+2CANY-method'></span><span id='topic+rss+2Cmatrix-method'></span><span id='topic+rss-methods'></span>

<h3>Description</h3>

<p><code>rss</code> and <code>evar</code> are S4 generic functions that
respectively computes the Residual Sum of Squares (RSS)
and explained variance achieved by a model.
</p>
<p>The explained variance for a target <code class="reqn">V</code> is computed
as: </p>
<p style="text-align: center;"><code class="reqn">evar = 1 - \frac{RSS}{\sum_{i,j} v_{ij}^2}
  </code>
</p>
<p>,
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  rss(object, ...)

  ## S4 method for signature 'matrix'
rss(object, target)

  evar(object, ...)

  ## S4 method for signature 'ANY'
evar(object, target, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rss_+3A_object">object</code></td>
<td>
<p>an R object with a suitable
<code><a href="#topic+fitted">fitted</a></code>, <code>rss</code> or <code>evar</code> method.</p>
</td></tr>
<tr><td><code id="rss_+3A_...">...</code></td>
<td>
<p>extra arguments to allow extension, e.g.
passed to <code>rss</code> in <code>evar</code> calls.</p>
</td></tr>
<tr><td><code id="rss_+3A_target">target</code></td>
<td>
<p>target matrix</p>
</td></tr>
</table>


<h3>Details</h3>

<p>where RSS is the residual sum of squares.
</p>
<p>The explained variance is usefull to compare the
performance of different models and their ability to
accurately reproduce the original target matrix. Note,
however, that a possible caveat is that some models
explicitly aim at minimizing the RSS (i.e. maximizing the
explained variance), while others do not.
</p>


<h3>Value</h3>

<p>a single numeric value
</p>


<h3>Methods</h3>


<dl>
<dt>evar</dt><dd><p><code>signature(object = "ANY")</code>: Default
method for <code>evar</code>.
</p>
<p>It requires a suitable <code>rss</code> method to be defined
for <code>object</code>, as it internally calls
<code>rss(object, target, ...)</code>. </p>
</dd>
<dt>rss</dt><dd><p><code>signature(object = "matrix")</code>: Computes
the RSS between a target matrix and its estimate
<code>object</code>, which must be a matrix of the same
dimensions as <code>target</code>.
</p>
<p>The RSS between a target matrix <code class="reqn">V</code> and its estimate
<code class="reqn">v</code> is computed as: </p>
<p style="text-align: center;"><code class="reqn">RSS = \sum_{i,j} (v_{ij} -
  V_{ij})^2</code>
</p>

<p>Internally, the computation is performed using an
optimised C++ implementation, that is light in memory
usage. </p>
</dd>
<dt>rss</dt><dd><p><code>signature(object = "ANY")</code>: Residual sum
of square between a given target matrix and a model that
has a suitable <code><a href="#topic+fitted">fitted</a></code> method. It is
equivalent to <code>rss(fitted(object), ...)</code>
</p>
<p>In the context of NMF, <cite>Hutchins et al. (2008)</cite> used the
variation of the RSS in combination with the algorithm
from <cite>Lee et al. (1999)</cite> to estimate the correct number of
basis vectors. The optimal rank is chosen where the graph
of the RSS first shows an inflexion point, i.e. using a
screeplot-type criterium. See section <em>Rank
estimation</em> in <code><a href="#topic+nmf">nmf</a></code>.
</p>
<p>Note that this way of estimation may not be suitable for
all models. Indeed, if the NMF optimisation problem is
not based on the Frobenius norm, the RSS is not directly
linked to the quality of approximation of the NMF model.
However, it is often the case that it still decreases
with the rank. </p>
</dd>
</dl>



<h3>References</h3>

<p>Hutchins LN, Murphy SM, Singh P and Graber JH (2008).
&quot;Position-dependent motif characterization using
non-negative matrix factorization.&quot; _Bioinformatics
(Oxford, England)_, *24*(23), pp. 2684-90. ISSN
1367-4811, &lt;URL:
http://dx.doi.org/10.1093/bioinformatics/btn526&gt;, &lt;URL:
http://www.ncbi.nlm.nih.gov/pubmed/18852176&gt;.
</p>
<p>Lee DD and Seung HS (1999). &quot;Learning the parts of
objects by non-negative matrix factorization.&quot; _Nature_,
*401*(6755), pp. 788-91. ISSN 0028-0836, &lt;URL:
http://dx.doi.org/10.1038/44565&gt;, &lt;URL:
http://www.ncbi.nlm.nih.gov/pubmed/10548103&gt;.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

#----------
# rss,matrix-method
#----------
# RSS bewteeen random matrices
x &lt;- rmatrix(20,10, max=50)
y &lt;- rmatrix(20,10, max=50)
rss(x, y)
rss(x, x + rmatrix(x, max=0.1))

#----------
# rss,ANY-method
#----------
# RSS between an NMF model and a target matrix
x &lt;- rmatrix(20, 10)
y &lt;- rnmf(3, x) # random compatible model
rss(y, x)

# fit a model with nmf(): one should do better
y2 &lt;- nmf(x, 3) # default minimizes the KL-divergence
rss(y2, x)
y2 &lt;- nmf(x, 3, 'lee') # 'lee' minimizes the RSS
rss(y2, x)
</code></pre>

<hr>
<h2 id='runtime+2CNMFList-method'>Returns the CPU time required to compute all NMF fits in the list.
It returns <code>NULL</code> if the list is empty.
If no timing data are available, the sequential time is returned.</h2><span id='topic+runtime+2CNMFList-method'></span>

<h3>Description</h3>

<p>Returns the CPU time required to compute all NMF fits in
the list. It returns <code>NULL</code> if the list is empty. If
no timing data are available, the sequential time is
returned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S4 method for signature 'NMFList'
runtime(object, all = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="runtime+2B2CNMFList-method_+3A_all">all</code></td>
<td>
<p>logical that indicates if the CPU time of each
fit should be returned (<code>TRUE</code>) or only the total
CPU time used to compute all the fits in <code>object</code>.</p>
</td></tr>
<tr><td><code id="runtime+2B2CNMFList-method_+3A_object">object</code></td>
<td>
<p>an object computed using some algorithm, or
that describes an algorithm itself.</p>
</td></tr>
</table>

<hr>
<h2 id='runtime.all+2CNMFfitXn-method'>Returns the CPU time used to perform all the NMF fits stored in <code>object</code>.</h2><span id='topic+runtime.all+2CNMFfitXn-method'></span>

<h3>Description</h3>

<p>If no time data is available from in slot
&lsquo;runtime.all&rsquo; and argument <code>null=TRUE</code>, then
the sequential time as computed by <code><a href="#topic+seqtime">seqtime</a></code>
is returned, and a warning is thrown unless
<code>warning=FALSE</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S4 method for signature 'NMFfitXn'
runtime.all(object, null = FALSE,
    warning = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="runtime.all+2B2CNMFfitXn-method_+3A_null">null</code></td>
<td>
<p>a logical that indicates if the sequential
time should be returned if no time data is available in
slot &lsquo;runtime.all&rsquo;.</p>
</td></tr>
<tr><td><code id="runtime.all+2B2CNMFfitXn-method_+3A_warning">warning</code></td>
<td>
<p>a logical that indicates if a warning
should be thrown if the sequential time is returned
instead of the real CPU time.</p>
</td></tr>
<tr><td><code id="runtime.all+2B2CNMFfitXn-method_+3A_object">object</code></td>
<td>
<p>an object computed using some algorithm, or
that describes an algorithm itself.</p>
</td></tr>
</table>

<hr>
<h2 id='scale.NMF'>Rescaling NMF Models</h2><span id='topic+scale.NMF'></span>

<h3>Description</h3>

<p>Rescales an NMF model keeping the fitted target matrix
identical.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'NMF'
 scale(x, center = c("basis", "coef"),
    scale = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scale.NMF_+3A_x">x</code></td>
<td>
<p>an NMF object</p>
</td></tr>
<tr><td><code id="scale.NMF_+3A_center">center</code></td>
<td>
<p>either a numeric normalising vector
<code class="reqn">\delta</code>, or either <code>'basis'</code> or
<code>'coef'</code>, which respectively correspond to using the
column sums of the basis matrix or the inverse of the row
sums of the coefficient matrix as a normalising vector.
If numeric, <code>center</code> should be a single value or a
vector of length the rank of the NMF model, i.e. the
number of columns in the basis matrix.</p>
</td></tr>
<tr><td><code id="scale.NMF_+3A_scale">scale</code></td>
<td>
<p>scaling coefficient applied to <code class="reqn">D</code>, i.e.
the value of <code class="reqn">\alpha</code>, or, if
<code>center='coef'</code>, the value of
<code class="reqn">1/\alpha</code> (see section <em>Details</em>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Standard NMF models are identifiable modulo a scaling
factor, meaning that the basis components and basis
profiles can be rescaled without changing the fitted
values:
</p>
<p style="text-align: center;"><code class="reqn">X = W_1 H_1 = (W_1 D) (D^{-1} H_1) = W_2 H_2</code>
</p>
<p> with <code class="reqn">D= \alpha diag(1/\delta_1,
  \ldots, 1\delta_r)</code>
</p>
<p>The default call <code>scale(object)</code> rescales the basis
NMF object so that each column of the basis matrix sums
up to one.
</p>


<h3>Value</h3>

<p>an NMF object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# random 3-rank 10x5 NMF model
x &lt;- rnmf(3, 10, 5)

# rescale based on basis
colSums(basis(x))
colSums(basis(scale(x)))

rx &lt;- scale(x, 'basis', 10)
colSums(basis(rx))
rowSums(coef(rx))

# rescale based on coef
rowSums(coef(x))
rowSums(coef(scale(x, 'coef')))
rx &lt;- scale(x, 'coef', 10)
rowSums(coef(rx))
colSums(basis(rx))

# fitted target matrix is identical but the factors have been rescaled
rx &lt;- scale(x, 'basis')
all.equal(fitted(x), fitted(rx))
all.equal(basis(x), basis(rx))
</code></pre>

<hr>
<h2 id='seed'>Interface for NMF Seeding Methods</h2><span id='topic+seed'></span><span id='topic+seed+2CANY+2CANY+2Ccharacter-method'></span><span id='topic+seed+2CANY+2CANY+2Cfunction-method'></span><span id='topic+seed+2CANY+2CANY+2Cmissing-method'></span><span id='topic+seed+2CANY+2CANY+2CNULL-method'></span><span id='topic+seed+2CANY+2CANY+2Cnumeric-method'></span><span id='topic+seed+2CANY+2Clist+2CNMFSeed-method'></span><span id='topic+seed+2CANY+2Cnumeric+2CNMFSeed-method'></span><span id='topic+seed+2Cmatrix+2CNMF+2CNMFSeed-method'></span><span id='topic+seed-methods'></span>

<h3>Description</h3>

<p>The function <code>seed</code> provides a single interface for
calling all seeding methods used to initialise NMF
computations. These methods at least set the basis and
coefficient matrices of the initial <code>object</code> to
valid nonnegative matrices. They will be used as a
starting point by any NMF algorithm that accept
initialisation.
</p>
<p>IMPORTANT: this interface is still considered
experimental and is subject to changes in future release.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  seed(x, model, method, ...)

  ## S4 method for signature 'matrix,NMF,NMFSeed'
seed(x, model, method,
    rng, ...)

  ## S4 method for signature 'ANY,ANY,function'
seed(x, model, method, name,
    ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seed_+3A_x">x</code></td>
<td>
<p>target matrix one wants to approximate with NMF</p>
</td></tr>
<tr><td><code id="seed_+3A_model">model</code></td>
<td>
<p>specification of the NMF model, e.g., the
factorization rank.</p>
</td></tr>
<tr><td><code id="seed_+3A_method">method</code></td>
<td>
<p>specification of a seeding method. See each
method for details on the supported formats.</p>
</td></tr>
<tr><td><code id="seed_+3A_...">...</code></td>
<td>
<p>extra to allow extensions and passed down to
the actual seeding method.</p>
</td></tr>
<tr><td><code id="seed_+3A_rng">rng</code></td>
<td>
<p>rng setting to use. If not missing the RNG
settings are set and restored on exit using
<code><a href="rngtools.html#topic+setRNG">setRNG</a></code>.
</p>
<p>All arguments in <code>...</code> are passed to teh seeding
strategy.</p>
</td></tr>
<tr><td><code id="seed_+3A_name">name</code></td>
<td>
<p>optional name of the seeding method for
custom seeding strategies.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an <code><a href="#topic+NMFfit-class">NMFfit</a></code> object.
</p>


<h3>Methods</h3>


<dl>
<dt>seed</dt><dd><p><code>signature(x = "matrix", model = "NMF",
  method = "NMFSeed")</code>: This is the workhorse method that
seeds an NMF model object using a given seeding strategy
defined by an <code>NMFSeed</code> object, to fit a given
target matrix. </p>
</dd>
<dt>seed</dt><dd><p><code>signature(x = "ANY", model = "ANY",
  method = "function")</code>: Seeds an NMF model using a custom
seeding strategy, defined by a function.
</p>
<p><code>method</code> must have signature <code>(x='NMFfit',
  y='matrix', ...)</code>, where <code>x</code> is the unseeded NMF
model and <code>y</code> is the target matrix to fit. It must
return an <code><a href="#topic+NMF-class">NMF</a></code> object, that contains
the seeded NMF model. </p>
</dd>
<dt>seed</dt><dd><p><code>signature(x = "ANY", model = "ANY",
  method = "missing")</code>: Seeds the model with the default
seeding method given by
<code>nmf.getOption('default.seed')</code> </p>
</dd>
<dt>seed</dt><dd><p><code>signature(x = "ANY", model = "ANY",
  method = "NULL")</code>: Use NMF method <code>'none'</code>. </p>
</dd>
<dt>seed</dt><dd><p><code>signature(x = "ANY", model = "ANY",
  method = "numeric")</code>: Use <code>method</code> to set the RNG
with <code><a href="rngtools.html#topic+setRNG">setRNG</a></code> and use method &ldquo;random&rdquo;
to seed the NMF model.
</p>
<p>Note that in this case the RNG settings are not restored.
This is due to some internal technical reasons, and might
change in future releases. </p>
</dd>
<dt>seed</dt><dd><p><code>signature(x = "ANY", model = "ANY",
  method = "character")</code>: Use the registered seeding method
whose access key is <code>method</code>. </p>
</dd>
<dt>seed</dt><dd><p><code>signature(x = "ANY", model = "list",
  method = "NMFSeed")</code>: Seed a model using the elements in
<code>model</code> to instantiate it with
<code><a href="#topic+nmfModel">nmfModel</a></code>. </p>
</dd>
<dt>seed</dt><dd><p><code>signature(x = "ANY", model = "numeric",
  method = "NMFSeed")</code>: Seeds a standard NMF model (i.e. of
class <code><a href="#topic+NMFstd-class">NMFstd</a></code>) of rank <code>model</code>.
</p>
</dd>
</dl>


<hr>
<h2 id='setNMFMethod'>Registering NMF Algorithms</h2><span id='topic+nmfRegisterAlgorithm'></span><span id='topic+setNMFMethod'></span>

<h3>Description</h3>

<p>Adds a new algorithm to the registry of algorithms that
perform Nonnegative Matrix Factorization.
</p>
<p><code>nmfRegisterAlgorithm</code> is an alias to
<code>setNMFMethod</code> for backward compatibility.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  setNMFMethod(name, method, ...,
    overwrite = isLoadingNamespace(), verbose = TRUE)

  nmfRegisterAlgorithm(name, method, ...,
    overwrite = isLoadingNamespace(), verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setNMFMethod_+3A_...">...</code></td>
<td>
<p>arguments passed to the factory function
<code><a href="#topic+NMFStrategy">NMFStrategy</a></code>, which instantiate the
<code><a href="#topic+NMFStrategy-class">NMFStrategy</a></code> object that is stored in
registry.</p>
</td></tr>
<tr><td><code id="setNMFMethod_+3A_overwrite">overwrite</code></td>
<td>
<p>logical that indicates if any existing
NMF method with the same name should be overwritten
(<code>TRUE</code>) or not (<code>FALSE</code>), in which case an
error is thrown.</p>
</td></tr>
<tr><td><code id="setNMFMethod_+3A_verbose">verbose</code></td>
<td>
<p>a logical that indicates if information
about the registration should be printed (<code>TRUE</code>) or
not (<code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="setNMFMethod_+3A_name">name</code></td>
<td>
<p>name/key of an NMF algorithm.</p>
</td></tr>
<tr><td><code id="setNMFMethod_+3A_method">method</code></td>
<td>
<p>definition of the algorithm</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>

# define/regsiter a new -- dummy -- NMF algorithm with the minimum arguments
# y: target matrix
# x: initial NMF model (i.e. the seed)
# NB: this algorithm simply return the seed unchanged
setNMFMethod('mynmf', function(y, x, ...){ x })

# check algorithm on toy data
res &lt;- nmfCheck('mynmf')
# the NMF seed is not changed
stopifnot( nmf.equal(res, nmfCheck('mynmf', seed=res)) )
</code></pre>

<hr>
<h2 id='setupBackend'>Computational Setup Functions</h2><span id='topic+setupBackend'></span><span id='topic+setupLibPaths'></span><span id='topic+setupRNG'></span><span id='topic+setupSharedMemory'></span><span id='topic+setupTempDirectory'></span>

<h3>Description</h3>

<p>Functions used internally to setup the computational
environment.
</p>
<p><code>setupBackend</code> sets up a foreach backend given some
specifications.
</p>
<p><code>setupSharedMemory</code> checks if one can use the
packages <em>bigmemory</em> and <em>sychronicity</em> to
speed-up parallel computations when not keeping all the
fits. When both these packages are available, only one
result per host is written on disk, with its achieved
deviance stored in shared memory, that is accessible to
all cores on a same host. It returns <code>TRUE</code> if both
packages are available and NMF option <code>'shared'</code> is
toggled on.
</p>
<p><code>setupTempDirectory</code> creates a temporary directory
to store the best fits computed on each host. It ensures
each worker process has access to it.
</p>
<p><code>setupLibPaths</code> add the path to the NMF package to
each workers' libPaths.
</p>
<p><code>setupRNG</code> sets the RNG for use by the function nmf.
It returns the old RNG as an rstream object or the result
of set.seed if the RNG is not changed due to one of the
following reason: - the settings are not compatible with
rstream
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  setupBackend(spec, backend, optional = FALSE,
    verbose = FALSE)

  setupSharedMemory(verbose)

  setupTempDirectory(verbose)

  setupLibPaths(pkg = "NMF", verbose = FALSE)

  setupRNG(seed, n, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setupBackend_+3A_spec">spec</code></td>
<td>
<p>target parallel specification: either
<code>TRUE</code> or <code>FALSE</code>, or a single numeric value
that specifies the number of cores to setup.</p>
</td></tr>
<tr><td><code id="setupBackend_+3A_backend">backend</code></td>
<td>
<p>value from argument <code>.pbackend</code> of
<code>nmf</code>.</p>
</td></tr>
<tr><td><code id="setupBackend_+3A_optional">optional</code></td>
<td>
<p>a logical that indicates if the
specification must be fully satisfied, throwing an error
if it is not, or if one can switch back to sequential,
only outputting a verbose message.</p>
</td></tr>
<tr><td><code id="setupBackend_+3A_verbose">verbose</code></td>
<td>
<p>logical or integer level of verbosity for
message outputs.</p>
</td></tr>
<tr><td><code id="setupBackend_+3A_pkg">pkg</code></td>
<td>
<p>package name whose path should be exported the
workers.</p>
</td></tr>
<tr><td><code id="setupBackend_+3A_seed">seed</code></td>
<td>
<p>initial RNG seed specification</p>
</td></tr>
<tr><td><code id="setupBackend_+3A_n">n</code></td>
<td>
<p>number of RNG seeds to generate</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns <code>FALSE</code> if no foreach backend is to be used,
<code>NA</code> if the currently registered backend is to be
used, or, if this function call registered a new backend,
the previously registered backend as a <code>foreach</code>
object, so that it can be restored after the computation
is over.
</p>

<hr>
<h2 id='show+2CNMF-method'>Show method for objects of class <code>NMF</code></h2><span id='topic+show+2CNMF-method'></span>

<h3>Description</h3>

<p>Show method for objects of class <code>NMF</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S4 method for signature 'NMF'
show(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="show+2B2CNMF-method_+3A_object">object</code></td>
<td>
<p>Any R object</p>
</td></tr>
</table>

<hr>
<h2 id='show+2CNMFfit-method'>Show method for objects of class <code>NMFfit</code></h2><span id='topic+show+2CNMFfit-method'></span>

<h3>Description</h3>

<p>Show method for objects of class <code>NMFfit</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S4 method for signature 'NMFfit'
show(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="show+2B2CNMFfit-method_+3A_object">object</code></td>
<td>
<p>Any R object</p>
</td></tr>
</table>

<hr>
<h2 id='show+2CNMFfitX-method'>Show method for objects of class <code>NMFfitX</code></h2><span id='topic+show+2CNMFfitX-method'></span>

<h3>Description</h3>

<p>Show method for objects of class <code>NMFfitX</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S4 method for signature 'NMFfitX'
show(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="show+2B2CNMFfitX-method_+3A_object">object</code></td>
<td>
<p>Any R object</p>
</td></tr>
</table>

<hr>
<h2 id='show+2CNMFfitX1-method'>Show method for objects of class <code>NMFfitX1</code></h2><span id='topic+show+2CNMFfitX1-method'></span>

<h3>Description</h3>

<p>Show method for objects of class <code>NMFfitX1</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S4 method for signature 'NMFfitX1'
show(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="show+2B2CNMFfitX1-method_+3A_object">object</code></td>
<td>
<p>Any R object</p>
</td></tr>
</table>

<hr>
<h2 id='show+2CNMFfitXn-method'>Show method for objects of class <code>NMFfitXn</code></h2><span id='topic+show+2CNMFfitXn-method'></span>

<h3>Description</h3>

<p>Show method for objects of class <code>NMFfitXn</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S4 method for signature 'NMFfitXn'
show(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="show+2B2CNMFfitXn-method_+3A_object">object</code></td>
<td>
<p>Any R object</p>
</td></tr>
</table>

<hr>
<h2 id='show+2CNMFList-method'>Show method for objects of class <code>NMFList</code></h2><span id='topic+show+2CNMFList-method'></span>

<h3>Description</h3>

<p>Show method for objects of class <code>NMFList</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S4 method for signature 'NMFList'
show(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="show+2B2CNMFList-method_+3A_object">object</code></td>
<td>
<p>Any R object</p>
</td></tr>
</table>

<hr>
<h2 id='show+2CNMFns-method'>Show method for objects of class <code>NMFns</code></h2><span id='topic+show+2CNMFns-method'></span>

<h3>Description</h3>

<p>Show method for objects of class <code>NMFns</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S4 method for signature 'NMFns'
show(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="show+2B2CNMFns-method_+3A_object">object</code></td>
<td>
<p>Any R object</p>
</td></tr>
</table>

<hr>
<h2 id='show+2CNMFOffset-method'>Show method for objects of class <code>NMFOffset</code></h2><span id='topic+show+2CNMFOffset-method'></span>

<h3>Description</h3>

<p>Show method for objects of class <code>NMFOffset</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S4 method for signature 'NMFOffset'
show(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="show+2B2CNMFOffset-method_+3A_object">object</code></td>
<td>
<p>Any R object</p>
</td></tr>
</table>

<hr>
<h2 id='show+2CNMFSeed-method'>Show method for objects of class <code>NMFSeed</code></h2><span id='topic+show+2CNMFSeed-method'></span>

<h3>Description</h3>

<p>Show method for objects of class <code>NMFSeed</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S4 method for signature 'NMFSeed'
show(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="show+2B2CNMFSeed-method_+3A_object">object</code></td>
<td>
<p>Any R object</p>
</td></tr>
</table>

<hr>
<h2 id='show+2CNMFStrategyIterative-method'>Show method for objects of class <code>NMFStrategyIterative</code></h2><span id='topic+show+2CNMFStrategyIterative-method'></span>

<h3>Description</h3>

<p>Show method for objects of class
<code>NMFStrategyIterative</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S4 method for signature 'NMFStrategyIterative'
show(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="show+2B2CNMFStrategyIterative-method_+3A_object">object</code></td>
<td>
<p>Any R object</p>
</td></tr>
</table>

<hr>
<h2 id='silhouette.NMF'>Silhouette of NMF Clustering</h2><span id='topic+silhouette.NMF'></span>

<h3>Description</h3>

<p>Silhouette of NMF Clustering
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'NMF'
 silhouette(x, what = NULL, order = NULL,
    ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="silhouette.NMF_+3A_x">x</code></td>
<td>
<p>an NMF object, as returned by
<code><a href="#topic+nmf">nmf</a></code>.</p>
</td></tr>
<tr><td><code id="silhouette.NMF_+3A_what">what</code></td>
<td>
<p>defines the type of clustering the computed
silhouettes are meant to assess: <code>'samples'</code> for the
clustering of samples (i.e. the columns of the target
matrix), <code>'features'</code> for the clustering of features
(i.e. the rows of the target matrix), and <code>'chc'</code>
for the consensus clustering of samples as defined by
hierarchical clustering dendrogram, <code>'consensus'</code>
for the consensus clustering of samples, with clustered
ordered as in the <strong>default</strong> hierarchical
clustering used by <code><a href="#topic+consensusmap">consensusmap</a></code> when
plotting the heatmap of the consensus matrix (for
multi-run NMF fits). That is <code>dist = 1 -
  consensus(x)</code>, average linkage and reordering based on
row means.</p>
</td></tr>
<tr><td><code id="silhouette.NMF_+3A_order">order</code></td>
<td>
<p>integer indexing vector that can be used to
force the silhouette order.</p>
</td></tr>
<tr><td><code id="silhouette.NMF_+3A_...">...</code></td>
<td>
<p>extra arguments not used.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+predict">predict</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

x &lt;- rmatrix(75, 15, dimnames = list(paste0('a', 1:75), letters[1:15]))
# NB: using low value for maxIter for the example purpose only
res &lt;- nmf(x, 4, nrun = 3, maxIter = 20)

# sample clustering from best fit
plot(silhouette(res))

# average silhouette are computed in summary measures
summary(res)

# consensus silhouettes are ordered as on default consensusmap heatmap
## Not run:  op &lt;- par(mfrow = c(1,2)) 
consensusmap(res)
si &lt;- silhouette(res, what = 'consensus')
plot(si)
## Not run:  par(op) 

# if the order is based on some custom numeric weights
## Not run:  op &lt;- par(mfrow = c(1,2)) 
cm &lt;- consensusmap(res, Rowv = runif(ncol(res)))
# NB: use reverse order because silhouettes are plotted top-down
si &lt;- silhouette(res, what = 'consensus', order = rev(cm$rowInd))
plot(si)
## Not run:  par(op) 

# do the reverse: order the heatmap as a set of silhouettes
si &lt;- silhouette(res, what = 'features')
## Not run:  op &lt;- par(mfrow = c(1,2)) 
basismap(res, Rowv = si)
plot(si)
## Not run:  par(op) 
</code></pre>

<hr>
<h2 id='smoothing'>Smoothing Matrix in Nonsmooth NMF Models</h2><span id='topic+smoothing'></span>

<h3>Description</h3>

<p>The function <code>smoothing</code> builds a smoothing matrix
for using in Nonsmooth NMF models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  smoothing(x, theta = x@theta, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="smoothing_+3A_x">x</code></td>
<td>
<p>a object of class <code>NMFns</code>.</p>
</td></tr>
<tr><td><code id="smoothing_+3A_theta">theta</code></td>
<td>
<p>the smoothing parameter (numeric) between 0
and 1.</p>
</td></tr>
<tr><td><code id="smoothing_+3A_...">...</code></td>
<td>
<p>extra arguments to allow extension (not used)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For a <code class="reqn">r</code>-rank NMF, the smoothing matrix of parameter
<code class="reqn">\theta</code> is built as follows: </p>
<p style="text-align: center;"><code class="reqn">S = (1-\theta)I +
  \frac{\theta}{r} 11^T ,</code>
</p>
<p> where <code class="reqn">I</code> is the identity
matrix and <code class="reqn">1</code> is a vector of ones (cf.
<code><a href="#topic+NMFns-class">NMFns-class</a></code> for more details).
</p>


<h3>Value</h3>

<p>if <code>x</code> estimates a <code class="reqn">r</code>-rank NMF, then the result
is a <code class="reqn">r \times r</code> square matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

x &lt;- nmfModel(3, model='NMFns')
smoothing(x)
smoothing(x, 0.1)
</code></pre>

<hr>
<h2 id='sparseness'>Sparseness</h2><span id='topic+sparseness'></span><span id='topic+sparseness+2Cmatrix-method'></span><span id='topic+sparseness-methods'></span><span id='topic+sparseness+2CNMF-method'></span><span id='topic+sparseness+2Cnumeric-method'></span>

<h3>Description</h3>

<p>Generic function that computes the <em>sparseness</em> of
an object, as defined by <cite>Hoyer (2004)</cite>. The
sparseness quantifies how much energy of a vector is
packed into only few components.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  sparseness(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sparseness_+3A_x">x</code></td>
<td>
<p>an object whose sparseness is computed.</p>
</td></tr>
<tr><td><code id="sparseness_+3A_...">...</code></td>
<td>
<p>extra arguments to allow extension</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In <cite>Hoyer (2004)</cite>, the sparseness is defined for a
real vector <code class="reqn">x</code> as: </p>
<p style="text-align: center;"><code class="reqn">Sparseness(x) =
  \frac{\sqrt{n} - \frac{\sum |x_i|}{\sqrt{\sum
  x_i^2}}}{\sqrt{n}-1}</code>
</p>

<p>, where <code class="reqn">n</code> is the length of <code class="reqn">x</code>.
</p>
<p>The sparseness is a real number in <code class="reqn">[0,1]</code>. It is
equal to 1 if and only if <code>x</code> contains a single
nonzero component, and is equal to 0 if and only if all
components of <code>x</code> are equal. It interpolates
smoothly between these two extreme values. The closer to
1 is the sparseness the sparser is the vector.
</p>
<p>The basic definition is for a <code>numeric</code> vector, and
is extended for matrices as the mean sparseness of its
column vectors.
</p>


<h3>Value</h3>

<p>usually a single numeric value &ndash; in [0,1], or a numeric
vector. See each method for more details.
</p>


<h3>Methods</h3>


<dl>
<dt>sparseness</dt><dd><p><code>signature(x = "numeric")</code>: Base
method that computes the sparseness of a numeric vector.
</p>
<p>It returns a single numeric value, computed following the
definition given in section <em>Description</em>. </p>
</dd>
<dt>sparseness</dt><dd><p><code>signature(x = "matrix")</code>:
Computes the sparseness of a matrix as the mean
sparseness of its column vectors. It returns a single
numeric value. </p>
</dd>
<dt>sparseness</dt><dd><p><code>signature(x = "NMF")</code>: Compute
the sparseness of an object of class <code>NMF</code>, as the
sparseness of the basis and coefficient matrices computed
separately.
</p>
<p>It returns the two values in a numeric vector with names
&lsquo;basis&rsquo; and &lsquo;coef&rsquo;. </p>
</dd>
</dl>



<h3>References</h3>

<p>Hoyer P (2004). &quot;Non-negative matrix factorization with
sparseness constraints.&quot; _The Journal of Machine Learning
Research_, *5*, pp. 1457-1469. &lt;URL:
http://portal.acm.org/citation.cfm?id=1044709&gt;.
</p>


<h3>See Also</h3>

<p>Other assess: <code><a href="#topic+entropy">entropy</a></code>, <code><a href="#topic+purity">purity</a></code>
</p>

<hr>
<h2 id='staticVar'>Get/Set a Static Variable in NMF Algorithms</h2><span id='topic+staticVar'></span>

<h3>Description</h3>

<p>This function is used in iterative NMF algorithms to
manage variables stored in a local workspace, that are
accessible to all functions that define the iterative
schema described in
<code><a href="#topic+NMFStrategyIterative-class">NMFStrategyIterative</a></code>.
</p>
<p>It is specially useful for computing stopping criteria,
which often require model data from different iterations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  staticVar(name, value, init = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="staticVar_+3A_name">name</code></td>
<td>
<p>Name of the static variable (as a single
character string)</p>
</td></tr>
<tr><td><code id="staticVar_+3A_value">value</code></td>
<td>
<p>New value of the static variable</p>
</td></tr>
<tr><td><code id="staticVar_+3A_init">init</code></td>
<td>
<p>a logical used when a <code>value</code> is
provided, that specifies if the variable should be set to
the new value only if it does not exist yet
(<code>init=TRUE</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The value of the static variable
</p>

<hr>
<h2 id='Strategy-class'>Generic Strategy Class</h2><span id='topic+name'></span><span id='topic+name+3C-'></span><span id='topic+name+3C--methods'></span><span id='topic+name-methods'></span><span id='topic+name+3C-+2CStrategy+2Ccharacter-method'></span><span id='topic+name+2CStrategy-method'></span><span id='topic+Strategy-class'></span>

<h3>Description</h3>

<p>This class defines a common interface for generic
algorithm strategies (e.g.,
<code><a href="#topic+NMFStrategy-class">NMFStrategy</a></code>).
</p>
<p><code>name</code> and <code>name&lt;-</code> gets and sets the name
associated with an object. In the case of <code>Strategy</code>
objects it is the the name of the algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  name(object, ...)

  ## S4 method for signature 'Strategy'
name(object, all = FALSE)

  name(object, ...)&lt;-value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Strategy-class_+3A_object">object</code></td>
<td>
<p>an R object with a defined <code>name</code>
method</p>
</td></tr>
<tr><td><code id="Strategy-class_+3A_...">...</code></td>
<td>
<p>extra arguments to allow extension</p>
</td></tr>
<tr><td><code id="Strategy-class_+3A_value">value</code></td>
<td>
<p>replacement value</p>
</td></tr>
<tr><td><code id="Strategy-class_+3A_all">all</code></td>
<td>
<p>a logical that indicates if all the names
associated with a strategy should be returned
(<code>TRUE</code>), or only the first (primary) one
(<code>FALSE</code>).</p>
</td></tr>
</table>


<h3>Slots</h3>


<dl>
<dt>name</dt><dd><p>character string giving the name of the
algorithm</p>
</dd>
<dt>package</dt><dd><p>name of the package that defined the
strategy.</p>
</dd>
<dt>defaults</dt><dd><p>default values for some of the
algorithm's arguments.</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>name</dt><dd><p><code>signature(object = "Strategy")</code>:
Returns the name of an algorithm </p>
</dd>
<dt>name</dt><dd><p><code>signature(object = "Strategy")</code>:
Returns the name of an algorithm </p>
</dd>
<dt>name&lt;-</dt><dd><p><code>signature(object = "Strategy", value
  = "character")</code>: Sets the name(s) of an NMF algorithm </p>
</dd>
<dt>name&lt;-</dt><dd><p><code>signature(object = "Strategy", value
  = "character")</code>: Sets the name(s) of an NMF algorithm </p>
</dd>
</dl>


<hr>
<h2 id='summary'>Assessing and Comparing NMF Models</h2><span id='topic+summary'></span><span id='topic+summary-methods'></span><span id='topic+summary-NMF'></span><span id='topic+summary+2CNMFfit-method'></span><span id='topic+summary+2CNMFfitX-method'></span><span id='topic+summary+2CNMF-method'></span>

<h3>Description</h3>

<p>The NMF package defines <code>summary</code> methods for
different classes of objects, which helps assessing and
comparing the quality of NMF models by computing a set of
quantitative measures, e.g. with respect to their ability
to recover known classes and/or the original target
matrix.
</p>
<p>The most useful methods are for classes
<code><a href="#topic+NMF-class">NMF</a></code>, <code><a href="#topic+NMFfit-class">NMFfit</a></code>,
<code><a href="#topic+NMFfitX-class">NMFfitX</a></code> and
<code><a href="#topic+NMFList-class">NMFList</a></code>, which compute summary
measures for, respectively, a single NMF model, a single
fit, a multiple-run fit and a list of heterogenous fits
performed with the function <code><a href="#topic+nmf">nmf</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  summary(object, ...)

  ## S4 method for signature 'NMF'
summary(object, class, target)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary_+3A_object">object</code></td>
<td>
<p>an NMF object. See available methods in
section <em>Methods</em>.</p>
</td></tr>
<tr><td><code id="summary_+3A_...">...</code></td>
<td>
<p>extra arguments passed to the next
<code>summary</code> method.</p>
</td></tr>
<tr><td><code id="summary_+3A_class">class</code></td>
<td>
<p>known classes/cluster of samples specified
in one of the formats that is supported by the functions
<code><a href="#topic+entropy">entropy</a></code> and <code><a href="#topic+purity">purity</a></code>.</p>
</td></tr>
<tr><td><code id="summary_+3A_target">target</code></td>
<td>
<p>target matrix specified in one of the
formats supported by the functions <code><a href="#topic+rss">rss</a></code> and
<code><a href="#topic+evar">evar</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Due to the somehow hierarchical structure of the classes
mentionned in <em>Description</em>, their respective
<code>summary</code> methods call each other in chain, each
super-class adding some extra measures, only relevant for
objects of a specific class.
</p>


<h3>Methods</h3>


<dl>
<dt>summary</dt><dd><p><code>signature(object = "NMF")</code>: Computes
summary measures for a single NMF model.
</p>
<p>The following measures are computed:
</p>
 <dl>
<dt>sparseness</dt><dd><p>Sparseness of the
factorization computed by the function
<code><a href="#topic+sparseness">sparseness</a></code>.</p>
</dd> <dt>entropy</dt><dd><p>Purity of the
clustering, with respect to known classes, computed by
the function <code><a href="#topic+purity">purity</a></code>.</p>
</dd>
<dt>entropy</dt><dd><p>Entropy of the clustering, with respect to
known classes, computed by the function
<code><a href="#topic+entropy">entropy</a></code>.</p>
</dd> <dt>RSS</dt><dd><p>Residual Sum of
Squares computed by the function <code><a href="#topic+rss">rss</a></code>.</p>
</dd>
<dt>evar</dt><dd><p>Explained variance computed by the function
<code><a href="#topic+evar">evar</a></code>.</p>
</dd> </dl>
 </dd>
<dt>summary</dt><dd><p><code>signature(object = "NMFfit")</code>:
Computes summary measures for a single fit from
<code><a href="#topic+nmf">nmf</a></code>.
</p>
<p>This method adds the following measures to the measures
computed by the method <code>summary,NMF</code>:
</p>
 <dl>
<dt>residuals</dt><dd><p>Residual error as measured by
the objective function associated to the algorithm used
to fit the model.</p>
</dd> <dt>niter</dt><dd><p>Number of iterations
performed to achieve convergence of the algorithm.</p>
</dd>
<dt>cpu</dt><dd><p>Total CPU time required for the fit.</p>
</dd>
<dt>cpu.all</dt><dd><p>Total CPU time required for the fit. For
<code>NMFfit</code> objects, this element is always equal to
the value in &ldquo;cpu&rdquo;, but will be different for
multiple-run fits.</p>
</dd> <dt>nrun</dt><dd><p>Number of runs performed
to fit the model. This is always equal to 1 for
<code>NMFfit</code> objects, but will vary for multiple-run
fits.</p>
</dd> </dl>
 </dd>
<dt>summary</dt><dd><p><code>signature(object = "NMFfitX")</code>:
Computes a set of measures to help evaluate the quality
of the <em>best fit</em> of the set. The result is similar
to the result from the <code>summary</code> method of
<code>NMFfit</code> objects. See <code><a href="#topic+NMF-class">NMF</a></code> for
details on the computed measures. In addition, the
cophenetic correlation (<code><a href="#topic+cophcor">cophcor</a></code>) and
<code><a href="#topic+dispersion">dispersion</a></code> coefficients of the consensus
matrix are returned, as well as the total CPU time
(<code><a href="#topic+runtime.all">runtime.all</a></code>). </p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>

#----------
# summary,NMF-method
#----------
# random NMF model
x &lt;- rnmf(3, 20, 12)
summary(x)
summary(x, gl(3, 4))
summary(x, target=rmatrix(x))
summary(x, gl(3,4), target=rmatrix(x))

#----------
# summary,NMFfit-method
#----------
# generate a synthetic dataset with known classes: 50 features, 18 samples (5+5+8)
n &lt;- 50; counts &lt;- c(5, 5, 8);
V &lt;- syntheticNMF(n, counts)
cl &lt;- unlist(mapply(rep, 1:3, counts))

# perform default NMF with rank=2
x2 &lt;- nmf(V, 2)
summary(x2, cl, V)
# perform default NMF with rank=2
x3 &lt;- nmf(V, 3)
summary(x2, cl, V)
</code></pre>

<hr>
<h2 id='syntheticNMF'>Simulating Datasets</h2><span id='topic+syntheticNMF'></span>

<h3>Description</h3>

<p>The function <code>syntheticNMF</code> generates random target
matrices that follow some defined NMF model, and may be
used to test NMF algorithms. It is designed to designed
to produce data with known or clear classes of samples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  syntheticNMF(n, r, p, offset = NULL, noise = TRUE,
    factors = FALSE, seed = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="syntheticNMF_+3A_n">n</code></td>
<td>
<p>number of rows of the target matrix.</p>
</td></tr>
<tr><td><code id="syntheticNMF_+3A_r">r</code></td>
<td>
<p>specification of the factorization rank. It may
be a single <code>numeric</code>, in which case argument
<code>p</code> is required and <code>r</code> groups of samples are
generated from a draw from a multinomial distribution
with equal probabilities, that provides their sizes.
</p>
<p>It may also be a numerical vector, which contains the
number of samples in each class (i.e integers). In this
case argument <code>p</code> is discarded and forced to be the
sum of <code>r</code>.</p>
</td></tr>
<tr><td><code id="syntheticNMF_+3A_p">p</code></td>
<td>
<p>number of columns of the synthetic target
matrix. Not used if parameter <code>r</code> is a vector (see
description of argument <code>r</code>).</p>
</td></tr>
<tr><td><code id="syntheticNMF_+3A_offset">offset</code></td>
<td>
<p>specification of a common offset to be
added to the synthetic target matrix, before
noisification. Its may be a numeric vector of length
<code>n</code>, or a single numeric value that is used as the
standard deviation of a centred normal distribution from
which the actual offset values are drawn.</p>
</td></tr>
<tr><td><code id="syntheticNMF_+3A_noise">noise</code></td>
<td>
<p>a logical that indicate if noise should be
added to the matrix.</p>
</td></tr>
<tr><td><code id="syntheticNMF_+3A_factors">factors</code></td>
<td>
<p>a logical that indicates if the NMF
factors should be return together with the matrix.</p>
</td></tr>
<tr><td><code id="syntheticNMF_+3A_seed">seed</code></td>
<td>
<p>a single numeric value used to seed the
random number generator before generating the matrix. The
state of the RNG is restored on exit.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix, or a list if argument <code>factors=TRUE</code>.
</p>
<p>When <code>factors=FALSE</code>, the result is a matrix object,
with the following attributes set: </p>

<dl>
<dt>coefficients</dt><dd><p>the true underlying coefficient
matrix (i.e. <code>H</code>);</p>
</dd> <dt>basis</dt><dd><p>the true underlying
coefficient matrix (i.e. <code>H</code>);</p>
</dd> <dt>offset</dt><dd><p>the
offset if any;</p>
</dd> <dt>pData</dt><dd><p>a <code>list</code> with one
element <code>'Group'</code> that contains a factor that
indicates the true groups of samples, i.e. the most
contributing basis component for each sample;</p>
</dd>
<dt>fData</dt><dd><p>a <code>list</code> with one element
<code>'Group'</code> that contains a factor that indicates the
true groups of features, i.e. the basis component to
which each feature contributes the most.</p>
</dd> </dl>

<p>Moreover, the result object is an
<code>ExposeAttribute</code> object, which means that
relevant attributes are accessible via <code>$</code>, e.g.,
<code>res$coefficients</code>. In particular, methods
<code><a href="#topic+coef">coef</a></code> and <code><a href="#topic+basis">basis</a></code> will work as
expected and return the true underlying coefficient and
basis matrices respectively.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# generate a synthetic dataset with known classes: 50 features, 18 samples (5+5+8)
n &lt;- 50
counts &lt;- c(5, 5, 8)

# no noise
V &lt;- syntheticNMF(n, counts, noise=FALSE)
## Not run: aheatmap(V)

# with noise
V &lt;- syntheticNMF(n, counts)
## Not run: aheatmap(V)
</code></pre>

<hr>
<h2 id='t.NMF'>Transformation NMF Model Objects</h2><span id='topic+t.NMF'></span>

<h3>Description</h3>

<p><code>t</code> transpose an NMF model, by transposing and
swapping its basis and coefficient matrices:
<code class="reqn">t([W,H]) = [t(H), t(W)]</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'NMF'
 t(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="t.NMF_+3A_x">x</code></td>
<td>
<p>NMF model object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>t</code> is a generic defined in the
<span class="pkg">base</span> package. The method <code>t.NMF</code> defines the
trasnformation for the general NMF interface. This method
may need to be overloaded for NMF models, whose structure
requires specific handling.
</p>


<h3>See Also</h3>

<p>Other transforms: <code><a href="#topic+nneg">nneg</a></code>,
<code><a href="#topic+posneg">posneg</a></code>, <code><a href="#topic+rposneg">rposneg</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

x &lt;- rnmf(3, 100, 20)
x
# transpose
y &lt;- t(x)
y

# factors are swapped-transposed
stopifnot( identical(basis(y), t(coef(x))) )
stopifnot( identical(coef(y), t(basis(x))) )
</code></pre>

<hr>
<h2 id='tryViewport'>Internal Grid Extension</h2><span id='topic+current.vpPath_patched'></span><span id='topic+tryViewport'></span><span id='topic+.use.grid.patch'></span>

<h3>Description</h3>

<p>These functions enable mixing base and grid graphics in
<code><a href="#topic+aheatmap">aheatmap</a></code>, by avoiding calls to the grid
internal function <code>'L_gridDirty'</code>. They are not
exported (i.e. not tampering core functions) and are only
meant for internal use within the <span class="pkg">NMF</span> package.
</p>
<p><code>tryViewport</code> tries to go down to a viewport in the
current tree, given its name.
</p>
<p><code>current.vpPath_patched</code> aims at substituting
<code><a href="grid.html#topic+current.vpPath">current.vpPath</a></code>, so that the graphic
engine is not reset. This is essentially to prevent
outputting a blank page at the beginning of PDF graphic
engines.
</p>
<p><code>.use.grid.patch</code> tells if the user enabled patching
grid.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  tryViewport(name, verbose = FALSE)

  current.vpPath_patched()

  .use.grid.patch()
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tryViewport_+3A_name">name</code></td>
<td>
<p>viewport name</p>
</td></tr>
<tr><td><code id="tryViewport_+3A_verbose">verbose</code></td>
<td>
<p>toggle verbosity</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>tryViewport</code> uses <code><a href="grid.html#topic+grid.ls">grid.ls</a></code> and
not <code><a href="grid.html#topic+seekViewport">seekViewport</a></code> as the latter would reset
the graphic device and break the mix grid/base graphic
capability.
</p>

<hr>
<h2 id='txtProgressBar'>Simple Progress Bar</h2><span id='topic+txtProgressBar'></span>

<h3>Description</h3>

<p>Creates a simple progress bar with title. This function
is identical to <code>utils::txtProgressBar</code> but allow
adding a title to the progress bar, and can be shared by
multiple processes, e.g., in multicore or multi-hosts
computations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  txtProgressBar(min = 0, max = 1, initial = 0, char = "=",
    width = NA, title = if (style == 3) " ", label,
    style = 1, file = "", shared = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="txtProgressBar_+3A_shared">shared</code></td>
<td>
<p>specification of a shared directory to use
when the progress bar is to be used by multiple
processes.</p>
</td></tr>
<tr><td><code id="txtProgressBar_+3A_min">min</code></td>
<td>
<p>(finite) numeric values for the extremes of
the progress bar. Must have <code>min &lt; max</code>.</p>
</td></tr>
<tr><td><code id="txtProgressBar_+3A_max">max</code></td>
<td>
<p>(finite) numeric values for the extremes of
the progress bar. Must have <code>min &lt; max</code>.</p>
</td></tr>
<tr><td><code id="txtProgressBar_+3A_initial">initial</code></td>
<td>
<p>initial or new value for the progress bar.
See &lsquo;Details&rsquo; for what happens with invalid
values.</p>
</td></tr>
<tr><td><code id="txtProgressBar_+3A_char">char</code></td>
<td>
<p>the character (or character string) to form
the progress bar.</p>
</td></tr>
<tr><td><code id="txtProgressBar_+3A_width">width</code></td>
<td>
<p>the width of the progress bar, as a multiple
of the width of <code>char</code>.  If <code>NA</code>, the default,
the number of characters is that which fits into
<code>getOption("width")</code>.</p>
</td></tr>
<tr><td><code id="txtProgressBar_+3A_title">title</code></td>
<td>
<p>ignored, for compatibility with other
progress bars.</p>
</td></tr>
<tr><td><code id="txtProgressBar_+3A_label">label</code></td>
<td>
<p>ignored, for compatibility with other
progress bars.</p>
</td></tr>
<tr><td><code id="txtProgressBar_+3A_style">style</code></td>
<td>
<p>the &lsquo;style&rsquo; of the bar &ndash; see
&lsquo;Details&rsquo;.</p>
</td></tr>
<tr><td><code id="txtProgressBar_+3A_file">file</code></td>
<td>
<p>an open connection object or <code>""</code> which
indicates the console: <code><a href="base.html#topic+stderr">stderr</a>()</code> might be
useful here.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>R Core Team
</p>

<hr>
<h2 id='utils-NMF'>Utility Function in the NMF Package</h2><span id='topic+str_args'></span><span id='topic+utils-NMF'></span>

<h3>Description</h3>

<p>Utility Function in the NMF Package
</p>
<p><code>str_args</code> formats the arguments of a function using
<code><a href="base.html#topic+args">args</a></code>, but returns the output as a string.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  str_args(x, exdent = 10L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="utils-NMF_+3A_x">x</code></td>
<td>
<p>a function</p>
</td></tr>
<tr><td><code id="utils-NMF_+3A_exdent">exdent</code></td>
<td>
<p>indentation for extra lines if the output
takes more than one line.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>

args(library)
str_args(library)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
