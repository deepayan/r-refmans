<!DOCTYPE html><html><head><title>Help for package FKF.SP</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {FKF.SP}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#fkf.SP'><p>Fast Kalman Filtering using Sequential Processing.</p></a></li>
<li><a href='#fks.SP'><p>Fast Kalman Smoother through Sequential Processing</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Fast Kalman Filtering Through Sequential Processing</td>
</tr>
<tr>
<td>Version:</td>
<td>0.3.1</td>
</tr>
<tr>
<td>Description:</td>
<td>Fast and flexible Kalman filtering and smoothing implementation utilizing sequential processing, designed for efficient parameter estimation through maximum likelihood estimation. Sequential processing is a univariate treatment of a multivariate series of observations and can benefit from computational efficiency over traditional Kalman filtering when independence is assumed in the variance of the disturbances of the measurement equation. Sequential processing is described in the textbook of Durbin and Koopman (2001, ISBN:978-0-19-964117-8). 'FKF.SP' was built upon the existing 'FKF' package and is, in general, a faster Kalman filter/smoother.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.1</td>
</tr>
<tr>
<td>RdMacros:</td>
<td>mathjaxr</td>
</tr>
<tr>
<td>Imports:</td>
<td>mathjaxr,</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, stats, FKF, NFCP</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/TomAspinall/FKF.SP">https://github.com/TomAspinall/FKF.SP</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/TomAspinall/FKF.SP/issues">https://github.com/TomAspinall/FKF.SP/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-10-09 08:01:10 UTC; Thomas Aspinall</td>
</tr>
<tr>
<td>Author:</td>
<td>Thomas Aspinall <a href="https://orcid.org/0000-0002-6968-1989"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Adrian Gepp <a href="https://orcid.org/0000-0003-1666-5501"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  Geoff Harris <a href="https://orcid.org/0000-0003-4284-8619"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Simone Kelly <a href="https://orcid.org/0000-0002-6528-8557"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Colette Southam <a href="https://orcid.org/0000-0001-7263-2347"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Bruce Vanstone <a href="https://orcid.org/0000-0002-3977-2468"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  David Luethi [ctb],
  Philipp Erb [ctb],
  Simon Otziger [ctb],
  Paul Smith <a href="https://orcid.org/0000-0002-0034-3412"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Thomas Aspinall &lt;tomaspinall2512@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-10-10 08:10:06 UTC</td>
</tr>
</table>
<hr>
<h2 id='fkf.SP'>Fast Kalman Filtering using Sequential Processing.</h2><span id='topic+fkf.SP'></span>

<h3>Description</h3>

\loadmathjax
<p>The <code>fkf.SP</code> function performs fast and flexible Kalman filtering using sequential processing. It is designed for efficient parameter
estimation through maximum likelihood estimation. Sequential processing (SP) is a univariate treatment of a multivariate series of observations
that increases computational efficiency over traditional Kalman filtering in the general case. SP takes the additional assumption that the
variance of disturbances in the measurement equation are independent. <code>fkf.SP</code> is based from the <code>fkf</code> function of
the <code>FKF</code> package but is, in general, a faster Kalman filtering method.
<code>fkf</code> and <code>fkf.SP</code> share identical arguments (except for the <code>GGt</code> argument, see <b>Arguments</b>). <code>fkf.SP</code> is compatible with missing observations (i.e. NA's in argument <code>yt</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fkf.SP(
  a0,
  P0,
  dt,
  ct,
  Tt,
  Zt,
  HHt,
  GGt,
  yt,
  verbose = FALSE,
  smoothing = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fkf.SP_+3A_a0">a0</code></td>
<td>
<p>A <code>vector</code> giving the initial value/estimation of the state variable</p>
</td></tr>
<tr><td><code id="fkf.SP_+3A_p0">P0</code></td>
<td>
<p>A <code>matrix</code> giving the variance of a0</p>
</td></tr>
<tr><td><code id="fkf.SP_+3A_dt">dt</code></td>
<td>
<p>A <code>matrix</code> giving the intercept of the transition equation</p>
</td></tr>
<tr><td><code id="fkf.SP_+3A_ct">ct</code></td>
<td>
<p>A <code>matrix</code> giving the intercept of the measurement equation</p>
</td></tr>
<tr><td><code id="fkf.SP_+3A_tt">Tt</code></td>
<td>
<p>An <code>array</code> giving factor of the transition equation</p>
</td></tr>
<tr><td><code id="fkf.SP_+3A_zt">Zt</code></td>
<td>
<p>An <code>array</code> giving the factor of the measurement equation</p>
</td></tr>
<tr><td><code id="fkf.SP_+3A_hht">HHt</code></td>
<td>
<p>An <code>array</code> giving the variance of the innovations of the transition equation</p>
</td></tr>
<tr><td><code id="fkf.SP_+3A_ggt">GGt</code></td>
<td>
<p>A <code>vector</code> giving the diagonal elements of the <code>matrix</code> for the variance of disturbances of the measurement equation. Covariance between disturbances
is not supported under the sequential processing method.</p>
</td></tr>
<tr><td><code id="fkf.SP_+3A_yt">yt</code></td>
<td>
<p>A <code>matrix</code> containing the observations. &quot;NA&quot;- values are allowed</p>
</td></tr>
<tr><td><code id="fkf.SP_+3A_verbose">verbose</code></td>
<td>
<p>A <code>logical</code>. When <code>verbose = TRUE</code>, A <code>list</code> object is output, which provides filtered values of the Kalman filter (see <b>Value</b>).</p>
</td></tr>
<tr><td><code id="fkf.SP_+3A_smoothing">smoothing</code></td>
<td>
<p>A <code>logical</code>. When <code>smoothing = TRUE</code>, Kalman smoothing is additionally performed and smoothed values returned (see <b>Value</b>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p><b>Parameters</b>:
</p>
<p>The <code>fkf.SP</code> function builds upon the <code>fkf</code> function of the <code>FKF</code> package by adjusting the Kalman filtering algorithm to
utilize sequential processing. Sequential processing can result in significant decreases in processing time over the traditional Kalman filter algorithm. Sequential processing has been
empirically shown to grow linearly with respect to the dimensions of \mjeqny_ty[t], rather than exponentially as is the case with the traditional Kalman filter algorithm (Aspinall et al., 2022, P104).
</p>
<p>The <code>fkf.SP</code> and <code>fkf</code> functions feature highly similar
arguments for compatibility purposes; only argument <code>GGt</code> has changed from an <code>array</code> type object to a <code>vector</code> or <code>matrix</code> type object.
The <code>fkf.SP</code> function takes the additional assumption over the <code>fkf</code> function that the variance of the disturbances of the measurement
equation are independent; a requirement of SP (see below).
</p>
<p>Parameters can either be constant or deterministic
time-varying. Assume the number of discrete time observations is \mjeqnnn
i.e. \mjeqny = y_ty = y_t where \mjeqnt = 1, \cdots, nt = 1, ..., n. Let \mjeqnmm be the
dimension of the state variable and \mjeqndd the dimension of the observations. Then, the parameters admit the following
classes and dimensions:
</p>

<table>
<tr>
 <td style="text-align: left;">
<code>dt</code> </td><td style="text-align: left;"> either a \mjeqnm \times nm * n (time-varying) or a \mjeqnm \times 1m * 1 (constant) matrix. </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>Tt</code> </td><td style="text-align: left;"> either a \mjeqnm \times m \times nm * m * n or a \mjeqnm \times m \times 1m * m * 1 array. </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>HHt</code> </td><td style="text-align: left;"> either a \mjeqnm \times m \times nm * m * n or a \mjeqnm \times m \times 1m * m * 1 array. </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>ct</code> </td><td style="text-align: left;"> either a \mjeqnd \times nd * n or a \mjeqnd \times 1d * 1 matrix. </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>Zt</code> </td><td style="text-align: left;"> either a \mjeqnd \times m \times nd * m * n or a \mjeqnd \times m \times 1d * m * 1 array. </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>GGt</code> </td><td style="text-align: left;"> either a \mjeqnd \times nd * n (time-varying) or a \mjeqnd \times 1d * 1 matrix. </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>yt</code> </td><td style="text-align: left;"> a \mjeqnd \times nd * n matrix.
</td>
</tr>

</table>

<p><b>State Space Form</b>
</p>
<p>The following notation follows that of Koopman <em>et al.</em> (1999). The Kalman filter is characterized by the transition and measurement equations:
</p>
\mjdeqn\alpha<p>_t + 1 = d_t + T_t \cdot \alpha_t + H_t \cdot \eta_talpha(t + 1) = d(t) + T(t) alpha(t) + H(t) * eta(t)
\mjdeqny_t = c_t + Z_t \cdot \alpha_t + G_t \cdot \epsilon_ty(t) = c(t) + Z(t) alpha(t) + G(t) * epsilon(t)
</p>
<p>where \mjeqn\eta_teta(t) and \mjeqn\epsilon_tepsilon(t) are i.i.d.
\mjeqnN(0, I_m)N(0, I(m)) and i.i.d. \mjeqnN(0, I_d)N(0, I(d)),
respectively, and \mjeqn\alpha_talpha(t) denotes the state
vector. The parameters admit the following dimensions:
</p>

<table>
<tr>
 <td style="text-align: left;">
\mjeqna_t \in R^ma(t) \in R^m </td><td style="text-align: left;"> \mjeqnd_t \in R^md[t] \in R^m </td><td style="text-align: left;"> \mjeqn\eta_t \in R^meta(t) \in R^m </td>
</tr>
<tr>
 <td style="text-align: left;">
\mjeqnT_t \in R^m \times mT[t] \in R^(m * m ) </td><td style="text-align: left;"> \mjeqnH_t \in R^m \times mH[t] \in R^(m * m) </td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">
\mjeqny_t \in R^dy(t) \in R^d </td><td style="text-align: left;"> \mjeqnc_t \in R^dc(t) \in R^d </td><td style="text-align: left;"> \mjeqn\epsilon_t \in R^depsilon(t) \in R^d </td>
</tr>
<tr>
 <td style="text-align: left;">
\mjeqnZ_t \in R^d \times mZ(t) \in R^(d * m) </td><td style="text-align: left;"> \mjeqnG_t \in R^d \times dG(t)
\in R^(d * d) </td><td style="text-align: left;">
</td>
</tr>

</table>

<p>Note that <code>fkf.SP</code> takes as input <code>HHt</code> and <code>GGt</code> which corresponds to \mjeqnH_t H_t'H(t) * t(H(t) and
\mjeqndiag(G_t)^2diag(G(t))^2 respectively.
</p>
<p><b>Sequential Processing Iteration</b>:
</p>
<p>Traditional Kalman filtering takes the entire observational vector \mjeqny_ty(t) as the items for analysis. SP
is an alternate approach that filters the elements of \mjeqny_ty(t) one at a time. Sequential processing is described in the textbook of Durbin and Koopman (2001) and is described below.
</p>
<p>Let \mjeqnpp equal the number of observations at time \mjeqntt (i.e. when considering possible missing observations \mjeqnp \leq dp &lt;= d).
The SP iteration involves treating the vector series: \mjeqny_1,\cdots,y_ny_1,...,y_n instead as the scalar series
\mjeqny_1,1,\cdots,y_(1,p),y_2,1,\cdots,y_(n,p_n)y_1,1,...,y_(1,p),y_2,1,...,y_(n,p_n ). This univariate treatment of the multivariate series
has the advantage that the function of the covariance matrix, \mjeqnF_tF(t), becomes \mjeqn1 \times 11 * 1, avoiding the calculation of both the inverse and determinant of
a \mjeqnp \times pp * p matrix. This can increase computational efficiency (especially under the case of many observations, i.e. \mjeqnpp is large)
</p>
<p>For any time point, the observation vector is given by:
</p>
\mjdeqn<p>y_t'=(y_(t,1),\cdots,y_(t,p) )y_t'=(y_(t,1),...,y_(t,p) )
</p>
<p>The filtering equations are written as:
</p>
\mjdeqn<p>a_t,i+1 = a_t,i + K_t,i v_t,ia(t,i+1) = a(t,i) + K(t,i) v(t,i)
\mjdeqnP_t,i+1 = P_t,i - K_t,i F_t,i K_t,i'P(t,i+1) = P(t,i) - K(t,i) F(t,i) K(t,i)'
Where:
\mjdeqn\hat y_t,i = c_t + Z_t \cdot a_t,i^y(t) = c(t) + Z(t) * a(t,i)
\mjdeqnv_t,i=y_t,i-\hat y_t,iv(t,i)=y(t,i)- y_hat(t,i)
\mjdeqnF_t,i = Z_t,i P_t,i Z_t,i'+ GGt_t,iF(t,i) = Z(t,i) P(t,i) Z(t,i)' + Gt(t,i)
\mjdeqnK_t,i = P_t,i Z_t,i' F_t,i^-1K(t,i) = P(t,i) Z(t,i)' F(t,i)^-1
\mjdeqni = 1, \cdots, pi = 1, ..., p
</p>
<p>Transition from time \mjeqntt to \mjeqnt+1t+1 occurs through the standard transition equations.
</p>
\mjdeqn\alpha<p>_t + 1,1 = d_t + T_t \cdot \alpha_t,palpha(t + 1,1) = d(t) + T(t) alpha(t,p)
</p>
\mjdeqn<p>P_t + 1,1 = T_t \cdot P_t,p \cdot T_t' + HHtP(t + 1,1) = T(t) P(t,p) T(t)' + H(t)
</p>
<p>The log-likelihood at time \mjeqntt is given by:
</p>
\mjdeqn<p>log L_t = -\fracp2log(2\pi) - \frac12\sum_i=1^p(log F_i + \fracv_i^2F_i)log L_t = -p/2 * log(2 * pi) - 1/2 * sum_(i=1)^p (log F_i + (v_i^2)/F_i)
</p>
<p>Where the log-likelihood of observations is:
</p>
\mjdeqn<p>log L = \sum_t^nlog L_tlog L = \sum_t^n(log L(t))
</p>
<p><b>Compiled Code</b>:
</p>
<p><code>fkf.SP</code> wraps the C-functions <code>fkf_SP</code>,  <code>fkf_SP_verbose</code> and  <code>fkfs_SP</code>,  which each rely upon the linear algebra subroutines of BLAS (Basic Linear Algebra Subprograms).
These C-functions are called when <code>verbose = FALSE</code>, <code>verbose = TRUE</code> and <code>smoothing = TRUE</code>, respectively.
</p>
<p>The difference in these compiled functions are in the values returned from them. The <code>fkfs_SP</code> also performs Kalman filtering and subsequently smoothing
within the singular compiled C-code function.
</p>


<h3>Value</h3>

<p>A <code>numeric</code> value corresponding to the log-likelihood calculated by the Kalman filter. Ideal for maximum likelihood estimation through optimization routines such as <code>optim</code>.
</p>
<p>When <code>verbose = TRUE</code>, an S3 class of type 'fkf.SP' with the following elements is also returned, corresponding to the filtered state variables and covariances of the Kalman filter algorithm:
</p>

<table>
<tr>
 <td style="text-align: right;">
<code>att</code> </td><td style="text-align: left;"> A <code class="reqn">m \times n</code>-matrix containing the filtered state variables, i.e. <code>att[,t]</code> = <code class="reqn">a_{t|t}</code>.</td>
</tr>
<tr>
 <td style="text-align: right;">
<code>at</code> </td><td style="text-align: left;"> A <code class="reqn">m \times (n + 1)</code>-matrix containing the predicted state variables, i.e. <code>at[,t]</code> = <code class="reqn">a_t</code>.</td>
</tr>
<tr>
 <td style="text-align: right;">
<code>Ptt</code> </td><td style="text-align: left;"> A <code class="reqn">m \times m \times n</code>-array containing the variance of att, i.e. <code>Ptt[,,t]</code> = <code class="reqn">P_{t|t}</code>.</td>
</tr>
<tr>
 <td style="text-align: right;">
<code>Pt</code> </td><td style="text-align: left;"> A <code class="reqn">m \times m \times (n+1)</code>-array containing the variance of at, i.e. <code>Pt[,,t]</code> = <code class="reqn">P_{t}</code>.</td>
</tr>
<tr>
 <td style="text-align: right;">
<code>yt</code> </td><td style="text-align: left;"> A <code class="reqn">d \times n</code>-matrix containing the input observations.</td>
</tr>
<tr>
 <td style="text-align: right;">
<code>Tt</code> </td><td style="text-align: left;"> either a <code class="reqn">m \times m \times n</code> or a <code class="reqn">m \times m \times 1</code>-array, depending on the argument provided. </td>
</tr>
<tr>
 <td style="text-align: right;">
<code>Zt</code> </td><td style="text-align: left;"> either a <code class="reqn">d \times m \times n</code> or a <code class="reqn">d \times m \times 1</code>-array, depending on the argument provided. </td>
</tr>
<tr>
 <td style="text-align: right;">
<code>Ftinv</code> </td><td style="text-align: left;"> A <code class="reqn">d \times n</code>-matrix containing the scalar inverse of the prediction error variances. </td>
</tr>
<tr>
 <td style="text-align: right;">
<code>vt</code> </td><td style="text-align: left;"> A <code class="reqn">d \times n</code>-matrix containing the observation error.</td>
</tr>
<tr>
 <td style="text-align: right;">
<code>Kt</code> </td><td style="text-align: left;"> A <code class="reqn">m \times d \times n</code>-array containing the Kalman gain of state variables at each observation.</td>
</tr>
<tr>
 <td style="text-align: right;">
<code>logLik</code> </td><td style="text-align: left;"> The log-likelihood.
</td>
</tr>

</table>

<p>In addition to the elements above, the following elements corresponding to the smoothed values output from Kalman smoothing are also returned when <code>smoothing = TRUE</code>.
The <code>fks.SP</code> provides more detail regarding Kalman smoothing.
</p>

<table>
<tr>
 <td style="text-align: right;">
<code>ahatt</code> </td><td style="text-align: left;">  A <code class="reqn">m \times n</code>-matrix containing the
smoothed state variables, i.e. <code>ahatt[,t]</code> = \mjeqna_t|na(t|n)</td>
</tr>
<tr>
 <td style="text-align: right;">
<code>Vt</code> </td><td style="text-align: left;">  A <code class="reqn">m \times m \times n</code>-array
containing the variances of <code>ahatt</code>, i.e. <code>Vt[,,t]</code> = \mjeqnP_t|nP(t|n)
</td>
</tr>

</table>

<p><b>Log-Likelihood Values:</b>
</p>
<p>When there are no missing observations (i.e. &quot;NA&quot; values) in argument <code>yt</code>, the return of function <code>fkf.SP</code> and the <code>logLik</code>
object returned within the list of function <code>fkf</code> are identical. When NA's are present, however, log-likelihood values returned
by <code>fkf.SP</code> are always higher. This is due to low bias in the log-likelihood values output by <code>fkf</code>, but does not influence parameter
estimation. Further details are available within this package's vignette.
</p>


<h3>References</h3>

<p>Aspinall, T. W., Harris, G., Gepp, A., Kelly, S., Southam, C., and Vanstone, B. (2022). <em>The Estimation of Commodity Pricing Models with Applications in Capital Investments</em>. <a href="https://research.bond.edu.au/en/studentTheses/the-estimation-of-commodity-pricing-models-with-applications-in-c">Available Online</a>.
</p>
<p>Anderson, B. D. O. and Moore. J. B. (1979). <em>Optimal Filtering</em> Englewood Cliffs: Prentice-Hall.
</p>
<p>Fahrmeir, L. and tutz, G. (1994) <em>Multivariate Statistical Modelling Based on Generalized Linear Models.</em> Berlin: Springer.
</p>
<p>Koopman, S. J., Shephard, N., Doornik, J. A. (1999). Statistical algorithms for models in state space using SsfPack 2.2. <em>Econometrics Journal</em>, Royal Economic Society, vol. 2(1), pages 107-160.
</p>
<p>Durbin, James, and Siem Jan Koopman (2001). <em>Time series analysis by state space methods.</em> Oxford university press.
</p>
<p>David Luethi, Philipp Erb and Simon Otziger (2018). FKF: Fast Kalman Filter. R package version 0.2.3.
'https://CRAN.R-project.org/package=FKF
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## &lt;-------------------------------------------------------------------------------
##Example 1 - Filter a state space model - Nile data
## &lt;-------------------------------------------------------------------------------

# Observations must be a matrix:
yt &lt;- rbind(datasets::Nile)

## Set constant parameters:
dt &lt;- ct &lt;- matrix(0)
Zt &lt;- Tt &lt;- matrix(1)
a0 &lt;- yt[1]   # Estimation of the first year flow
P0 &lt;- matrix(100)       # Variance of 'a0'
## These can be estimated through MLE:
GGt &lt;- matrix(15000)
HHt &lt;- matrix(1300)

# 'verbose' returns the filtered values:
output &lt;- fkf.SP(a0 = a0, P0 = P0, dt = dt, ct = ct,
               Tt = Tt, Zt = Zt, HHt = HHt, GGt = GGt,
               yt = yt, verbose = TRUE)


## &lt;-------------------------------------------------------------------------------
##Example 2 - ARMA(2,1) model estimation.
## &lt;-------------------------------------------------------------------------------

#Length of series
n &lt;- 1000

#AR parameters
AR &lt;- c(ar1 = 0.6, ar2 = 0.2, ma1 = -0.2, sigma = sqrt(0.2))

## Sample from an ARMA(2, 1) process
a &lt;- stats::arima.sim(model = list(ar = AR[c("ar1", "ar2")], ma = AR["ma1"]), n = n,
innov = rnorm(n) * AR["sigma"])

##State space representation of the four ARMA parameters
arma21ss &lt;- function(ar1, ar2, ma1, sigma) {
Tt &lt;- matrix(c(ar1, ar2, 1, 0), ncol = 2)
Zt &lt;- matrix(c(1, 0), ncol = 2)
ct &lt;- matrix(0)
dt &lt;- matrix(0, nrow = 2)
GGt &lt;- matrix(0)
H &lt;- matrix(c(1, ma1), nrow = 2) * sigma
HHt &lt;- H %*% t(H)
a0 &lt;- c(0, 0)
P0 &lt;- matrix(1e6, nrow = 2, ncol = 2)
return(list(a0 = a0, P0 = P0, ct = ct, dt = dt, Zt = Zt, Tt = Tt, GGt = GGt,
            HHt = HHt))
            }

## The objective function passed to 'optim'
objective &lt;- function(theta, yt) {
sp &lt;- arma21ss(theta["ar1"], theta["ar2"], theta["ma1"], theta["sigma"])
 ans &lt;- fkf.SP(a0 = sp$a0, P0 = sp$P0, dt = sp$dt, ct = sp$ct, Tt = sp$Tt,
               Zt = sp$Zt, HHt = sp$HHt, GGt = sp$GGt, yt = yt)
 return(-ans)
}

## Parameter estimation - maximum likelihood estimation:
theta &lt;- c(ar = c(0, 0), ma1 = 0, sigma = 1)
ARMA_MLE &lt;- optim(theta, objective, yt = rbind(a), hessian = TRUE)


## &lt;-------------------------------------------------------------------------------
#Example 3 - Nile Model Estimation:
## &lt;-------------------------------------------------------------------------------

#Nile's annual flow:
yt &lt;- rbind(Nile)

##Incomplete Nile Data - two NA's are present:
yt[c(3, 10)] &lt;- NA

## Set constant parameters:
dt &lt;- ct &lt;- matrix(0)
Zt &lt;- Tt &lt;- matrix(1)
a0 &lt;- yt[1]   # Estimation of the first year flow
P0 &lt;- matrix(100)       # Variance of 'a0'

## Parameter estimation - maximum likelihood estimation:
##Unknown parameters initial estimates:
GGt &lt;- HHt &lt;- var(c(yt), na.rm = TRUE) * .5
#Perform maximum likelihood estimation
Nile_MLE &lt;- optim(c(HHt = HHt, GGt = GGt),
                fn = function(par, ...)
                -fkf.SP(HHt = matrix(par[1]), GGt = matrix(par[2]), ...),
                yt = yt, a0 = a0, P0 = P0, dt = dt, ct = ct,
                Zt = Zt, Tt = Tt)
## &lt;-------------------------------------------------------------------------------
#Example 4 - Dimensionless Treering Example:
## &lt;-------------------------------------------------------------------------------


## tree-ring widths in dimensionless units
y &lt;- treering

## Set constant parameters:
dt &lt;- ct &lt;- matrix(0)
Zt &lt;- Tt &lt;- matrix(1)
a0 &lt;- y[1]            # Estimation of the first width
P0 &lt;- matrix(100)     # Variance of 'a0'

## Parameter estimation - maximum likelihood estimation:
Treering_MLE &lt;- optim(c(HHt = var(y, na.rm = TRUE) * .5,
                 GGt = var(y, na.rm = TRUE) * .5),
                 fn = function(par, ...)
                -fkf.SP(HHt = array(par[1],c(1,1,1)), GGt = matrix(par[2]), ...),
                 yt = rbind(y), a0 = a0, P0 = P0, dt = dt, ct = ct,
                 Zt = Zt, Tt = Tt)

</code></pre>

<hr>
<h2 id='fks.SP'>Fast Kalman Smoother through Sequential Processing</h2><span id='topic+fks.SP'></span>

<h3>Description</h3>

\loadmathjax
<p>The Kalman smoother is a backwards algorithm that is run after the Kalman filter
that allows the user to refine estimates of previous states to produce &quot;smoothed&quot; estimates of state variables.
This function performs the &quot;Kalman smoother&quot; algorithm using sequential processing, an approach that can substantially improve
processing time over the traditional Kalman filtering/smoothing algorithms. The primary application of Kalman smoothing is in
conjunction with expectation-maximization to estimate the parameters of a state space model. This function is called after running <code><a href="#topic+fkf.SP">fkf.SP</a></code>.
<code>fks.SP</code> wraps the C-function <code>fks_SP</code> which relies upon the linear algebra subroutines of BLAS (Basic Linear Algebra Subprograms).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fks.SP(FKF.SP_obj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fks.SP_+3A_fkf.sp_obj">FKF.SP_obj</code></td>
<td>
<p>An S3-object of class &quot;fkf.SP&quot;, returned by <code><a href="#topic+fkf.SP">fkf.SP</a></code> when using the argument <code>verbose = TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>fks.SP</code> is typically called after the <code><a href="#topic+fkf.SP">fkf.SP</a></code> function to calculate &quot;smoothed&quot; estimates of state variables and their corresponding variances. Smoothed estimates are used
when utilizing expectation-maximization (EM) to efficiently estimate the parameters of a state space model.
</p>
<p><b>Sequential Processing Kalman smoother solution</b>:
</p>
<p>The <code>fks.SP</code> function uses the solution to the Kalman smoother through sequential processing provided in the textbook of Durbin and Koopman (2001).
</p>
<p>Given a state space model has been filtered through the sequential processing Kalman filter algorithm described in <code>fkf.SP</code>, the smoother can be reformulated for the univariate series:
</p>
\mjdeqn<p>y_t'=(y_(1,1),y_(1,2),\cdots,y_(1,p_1),y_(2,1),\cdots,y_(t,p_t))y_t'=(y_(1,1),y_(1,2),...y_(1,p_1),y_(2,1),...,y_(t,p_t))
</p>
<p>The sequential processing Kalman smoother approach iterates backwards through both observations and time, i.e.: \mjeqni=p_t, \cdots, 1i=p[t], ... ,1 and \mjeqnt=n,\cdots,1t=n, ... ,1,
where \mjeqnp_tp_t is the number of observations at time \mjeqntt and \mjeqnnn is the total number of observations.
</p>
<p>The initialisations are:
</p>
\mjdeqn<p>r_(n,p_n) = 0r(n,p_n)=0
\mjdeqnN_(n,p_n)=0N(n,p_n)=0
</p>
<p>Then, \mjeqnrr and \mjeqnNN are recursively calculated through:
</p>
\mjdeqn<p>L_t,i = I_m - K_t,i Z_t,iL(t,i) = I_m - K(t,i) Z(t,i)
</p>
\mjdeqn<p>r_(t,i-1) = Z_t,i' F_t,i^-1 v_t,i + L_t,i' r_t,ir(t,i-1) = Z(t,i)' F(t,i)^-1 v(t,i) + L(t,i)' r(t,i)
</p>
\mjdeqn<p>N_t,i-1 = Z_t,i' F_t,i^-1 Z_t,i + L_t,i' N_t,i L_t,iN(t,i-1) = Z(t,i)' F(t,i)^-1 Z(t,i) + L(t,i)' N(t,i) L(t,i)
</p>
\mjdeqn<p>r_t-1,p_t = T_t-1' r_t,0r(t-1,p_t) = T(t-1)' r(t,0)
</p>
\mjdeqn<p>N_t-1,p_t = T_t-1' N_t,0 T_t-1N(t-1,p_t) = T(t-1)' N(t,0) T(t-1)
</p>
<p>for \mjeqni=p_t,\cdots,1i=p_t, ..., 1 and \mjeqnt=n,\cdots,1t=n, ..., 1
</p>
<p>The equations for \mjeqnr_t-1,p_tr(t-1,p_t) and \mjeqnN_t-1,p_tN(t-1,p_t) do not apply for \mjeqnt=1t=1
</p>
<p>Under this formulation, the values for \mjeqnr_t,0r(t,0) and \mjeqnN_t,0N(t,0) are the same as the values for the smoothing quantities of \mjeqnr_t-1r(t-1) and
\mjeqnN_t-1N(t-1) of the standard smoothing equations, respectively.
</p>
<p>The standard smoothing equations for \mjeqn\hata_tahat(t) and \mjeqnV_tV(t) are used:
</p>
\mjdeqn\hat<p>a_t = a_t + P_t r_t-1ahat(t) = a(t) + P(t) r(t-1)
</p>
\mjdeqn<p>V_t = P_t - P_t N_t-1 P_tV(t) = P(t) - P(t) N(t-1) P(t)
</p>
<p>Where:
</p>
\mjdeqn<p>a_t=a_t,1a(t) = a(t,1)
</p>
\mjdeqn<p>P_t = P_t,1P(t) = P(t,1)
</p>
<p>In the equations above, \mjeqnr_t,ir(t,i) is an \mjeqnm \times 1m X 1 vector, \mjeqnI_mI_m is an \mjeqnm \times mm X m identity matrix,
\mjeqnK_t,iK(t,i) is an \mjeqnm \times 1m X 1 column vector, \mjeqnZ_t,iZ(t,i) is a \mjeqn1 \times m1 X m row vector, and both \mjeqnF_t,i^-1F(t,i)^-1 and
\mjeqnv_t,iv(t,i) are scalars. The reduced dimensionality of many of the variables in this formulation compared to traditional Kalman smoothing can result in increased computational efficiency.
</p>
<p>Finally, in the formulation described above, \mjeqna_ta(t) and \mjeqnP_tP(t) correspond to the values of <code>att</code> and <code>ptt</code> returned from the <code>fkf.SP</code> function, respectively.
</p>


<h3>Value</h3>

<p>An S3-object of class <code>fks.SP</code>, which is a list with the following elements:
</p>

<table>
<tr>
 <td style="text-align: right;">
<code>ahatt</code> </td><td style="text-align: left;">  A <code class="reqn">m \times n</code>-matrix containing the
smoothed state variables, i.e. <code>ahatt[,t]</code> = \mjeqna_t|na(t|n)</td>
</tr>
<tr>
 <td style="text-align: right;">
<code>Vt</code> </td><td style="text-align: left;">  A <code class="reqn">m \times m \times n</code>-array
containing the variances of <code>ahatt</code>, i.e. <code>Vt[,,t]</code> = \mjeqnP_t|nP(t|n)
</td>
</tr>

</table>



<h3>References</h3>

<p>Aspinall, T. W., Harris, G., Gepp, A., Kelly, S., Southam, C., and Vanstone, B. (2022). <em>The Estimation of Commodity Pricing Models with Applications in Capital Investments</em>. <a href="https://research.bond.edu.au/en/studentTheses/the-estimation-of-commodity-pricing-models-with-applications-in-c">Available Online</a>.
</p>
<p>Durbin, James, and Siem Jan Koopman (2001). <em>Time series analysis by state space methods.</em> Oxford university press.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### Perform Kalman Filtering and Smoothing through sequential processing:
#Nile's annual flow:
yt &lt;- Nile

# Incomplete Nile Data - two NA's are present:
yt[c(3, 10)] &lt;- NA

dt &lt;- ct &lt;- matrix(0)
Zt &lt;- Tt &lt;- matrix(1)
a0 &lt;- yt[1]   # Estimation of the first year flow
P0 &lt;- matrix(100)       # Variance of 'a0'

# Parameter estimation - maximum likelihood estimation:
# Unknown parameters initial estimates:
GGt &lt;- HHt &lt;- var(yt, na.rm = TRUE) * .5
HHt = matrix(HHt)
GGt = matrix(GGt)
yt = rbind(yt)
# Filter through the Kalman filter - sequential processing:
Nile_filtered &lt;- fkf.SP(HHt = matrix(HHt), GGt = matrix(GGt), a0 = a0, P0 = P0, dt = dt, ct = ct,
                  Zt = Zt, Tt = Tt, yt = rbind(yt), verbose = TRUE)
# Smooth filtered values through the Kalman smoother - sequential processing:
Smoothed_Estimates &lt;- fks.SP(Nile_filtered)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
