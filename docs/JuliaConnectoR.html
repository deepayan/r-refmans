<!DOCTYPE html><html lang="en"><head><title>Help for package JuliaConnectoR</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {JuliaConnectoR}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#JuliaConnectoR-package'><p>A Functionally Oriented Interface for Integrating Julia with R</p></a></li>
<li><a href='#AccessMutate.JuliaProxy'><p>Access or mutate Julia objects via proxy objects</p></a></li>
<li><a href='#as.data.frame.JuliaProxy'><p>Coerce a Julia Table to a Data Frame</p></a></li>
<li><a href='#EnvVars-JuliaConnectoR'><p>Environment variables used by the <span class="pkg">JuliaConnectoR</span></p></a></li>
<li><a href='#Julia-Setup'><p>Julia setup</p></a></li>
<li><a href='#juliaCall'><p>Call a Julia function by name</p></a></li>
<li><a href='#juliaEval'><p>Evaluate a Julia expression</p></a></li>
<li><a href='#juliaExpr'><p>Mark a string as Julia expression</p></a></li>
<li><a href='#juliaFun'><p>Wrap a Julia function in an R function</p></a></li>
<li><a href='#juliaGet'><p>Translate a Julia proxy object to an R object</p></a></li>
<li><a href='#juliaImport'><p>Load and import a Julia package via <code>import</code> statement</p></a></li>
<li><a href='#juliaLet'><p>Evaluate Julia code in a <code>let</code> block using values of R variables</p></a></li>
<li><a href='#juliaPut'><p>Create a Julia proxy object from an R object</p></a></li>
<li><a href='#juliaSetupOk'><p>Check Julia setup</p></a></li>
<li><a href='#startJuliaServer'><p>Start a Julia server that may serve multiple clients (R processes)</p></a></li>
<li><a href='#stopJulia'><p>Stop the connection to Julia</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>A Functionally Oriented Interface for Integrating 'Julia' with R</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1.4</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Stefan Lenz &lt;stefan-m-lenz@web.de&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Allows to import functions and whole packages from 'Julia' in R.
    Imported 'Julia' functions can directly be called as R functions.
    Data structures can be translated between 'Julia' and R.
    More details can also be found in the corresponding article
    &lt;<a href="https://doi.org/10.18637%2Fjss.v101.i06">doi:10.18637/jss.v101.i06</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENCE</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>Julia &gt;= 1.0</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 2.1.0), future, parallel</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-10-08 13:05:09 UTC; Stefan Lenz</td>
</tr>
<tr>
<td>Author:</td>
<td>Stefan Lenz <a href="https://orcid.org/0000-0001-9135-1743"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cre],
  Harald Binder <a href="https://orcid.org/0000-0002-5666-8662"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, ths],
  Angelo D'Ambrosio <a href="https://orcid.org/0000-0002-2045-5155"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb],
  June Choe <a href="https://orcid.org/0000-0002-0701-921X"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [ctb]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-10-08 18:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='JuliaConnectoR-package'>A Functionally Oriented Interface for Integrating Julia with R</h2><span id='topic+JuliaConnectoR'></span><span id='topic+JuliaConnectoR-package'></span>

<h3>Description</h3>

<p>This package provides a functionally oriented interface between R and Julia.
The goal is to call functions from Julia packages directly as R functions.
</p>


<h3>Details</h3>

<p>This R-package provides a functionally oriented interface between R and Julia.
The goal is to call functions from Julia packages directly as R functions.
Julia functions imported via the <span class="pkg">JuliaConnectoR</span> can accept and return R variables.
It is also possible to pass R functions as arguments in place of Julia functions,
which allows <em>callbacks</em> from Julia to R.
</p>
<p>From a technical perspective, R data structures are serialized with an optimized custom streaming format,
sent to a (local) Julia TCP server, and translated to Julia data structures by Julia.
The results are returned back to R.
Simple objects, which correspond to vectors in R, are directly translated.
Complex Julia structures are by default transferred to R by reference via proxy objects.
This enables an effective and intuitive handling of the Julia objects via R.
It is also possible to fully translate Julia objects to R objects.
These translated objects are annotated with information
about the original Julia objects, such that they can be translated back to Julia.
This makes it also possible to serialize them as R objects.
</p>


<h3>Setup</h3>

<p>The package requires that
<a href="https://julialang.org/downloads/">Julia (Version <code class="reqn">\geq</code> 1.0) is installed</a>
separately from the package.
The Julia installation is discovered via the system search <span class="env">PATH</span> or the
<span class="env">JULIA_BINDIR</span> environment variable, which can be set to the <code>bin</code> directory of
the Julia installation.
If Julia is installed via the Julia installation manager <code>juliaup</code>,
it should be discovered without requiring more configuration.
For more details about the setup,
see <code><a href="#topic+Julia-Setup">Julia-Setup</a></code>.
</p>


<h3>Function overview</h3>

<p>The function <code><a href="#topic+juliaImport">juliaImport</a></code> makes
functions and data types from Julia packages or modules available as R functions.
</p>
<p>If only a single Julia function needs to be imported in R, <code><a href="#topic+juliaFun">juliaFun</a></code>
can do this. The simplest way to call a Julia function without any importing
is to use <code><a href="#topic+juliaCall">juliaCall</a></code> with the function name given
as character string.
</p>
<p>For evaluating expressions in Julia, <code><a href="#topic+juliaEval">juliaEval</a></code> and
<code><a href="#topic+juliaLet">juliaLet</a></code> can be used. With <code><a href="#topic+juliaLet">juliaLet</a></code> one can use
R variables in a expression.
</p>
<p><code><a href="#topic+juliaExpr">juliaExpr</a></code> makes it possible use complex Julia syntax in R via R strings
that contain Julia expressions.
</p>
<p>With <code><a href="#topic+juliaGet">juliaGet</a></code>, a full translation of a Julia proxy object into an R object
is performed.
</p>
<p><code>as.data.frame</code> is overloaded (<code><a href="#topic+as.data.frame.JuliaProxy">as.data.frame.JuliaProxy</a></code>)
for translating Julia objects that implement the
<a href="https://github.com/JuliaData/Tables.jl"><code>Tables</code></a> interface
to R data frames.
</p>


<h3>Translation</h3>

<p>Since Julia is more type-sensitive than R, and many Julia functions expect to be called
using specific types, it is important to know the translations of the R data structures
to Julia.
</p>


<h4>Translation from R to Julia</h4>

<p>The type correspondences of the basic R data types in Julia are the following:
</p>

<table>
<tr>
 <td style="text-align: left;">
<strong>R</strong> </td><td style="text-align: center;">  </td><td style="text-align: left;"> <strong>Julia</strong></td>
</tr>
<tr>
 <td style="text-align: left;">
<code>integer</code> </td><td style="text-align: center;"> <code class="reqn">\rightarrow</code> </td><td style="text-align: left;"> <code>Int</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>double</code>  </td><td style="text-align: center;"> <code class="reqn">\rightarrow</code> </td><td style="text-align: left;"> <code>Float64</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>logical</code>   </td><td style="text-align: center;"> <code class="reqn">\rightarrow</code> </td><td style="text-align: left;"> <code>Bool</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>character</code> </td><td style="text-align: center;"> <code class="reqn">\rightarrow</code> </td><td style="text-align: left;"> <code>String</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>complex</code> </td><td style="text-align: center;"> <code class="reqn">\rightarrow</code> </td><td style="text-align: left;"> <code>Complex{Float64}</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>raw</code>  </td><td style="text-align: center;"> <code class="reqn">\rightarrow</code> </td><td style="text-align: left;"> <code>UInt8</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>symbol</code> </td><td style="text-align: center;"> <code class="reqn">\rightarrow</code> </td><td style="text-align: left;"> <code>Symbol</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>R vectors of length 1 of the types in the table above will be translated to the types shown.
</p>
<p>R vectors or arrays with more than one element will be translated to Julia <code>Array</code>s
of the corresponding types. The dimensions of an R array, as returned by <code>dim()</code>,
will also be respected.
For example, the R integer vector <code>c(1L, 2L)</code> will be of type <code>Vector{Int}</code>,
or <code>Array{Int,1}</code>, in Julia.
A double matrix such as <code>matrix(c(1,2,3,4), nrow = 2)</code>
will be of type <code>Array{Float64,2}</code>.
</p>
<p>Missing values (<code>NA</code>) in R are translated to <code>missing</code> values in Julia.
R vectors and arrays with missing values are converted to Julia arrays
of type <code>Array{Union{Missing, T}}</code>, where <code>T</code> stands for the translated
type in the table above.
</p>
<p>R lists are translated as <code>Vector{T}</code> in Julia, with <code>T</code> being
the most specific supertype of the list elements after translation to Julia.
</p>
<p>An R function that is handed to Julia as argument in a function
call is translated to a Julia callback function that will call the given R function.
</p>
<p>Strings with attribute <code>"JLEXPR"</code>
will be evaluated as Julia expressions,
and the value is used in their place (see <code><a href="#topic+juliaExpr">juliaExpr</a></code>).
</p>
<p>R data frames are translated to objects that implement the Julia
<a href="https://github.com/JuliaData/Tables.jl"><code>Tables</code></a> interface.
Such objects can be used by functions of many different
Julia packages that deal with table-like data structures.
</p>



<h4>Translation from Julia to R</h4>

<p>The type system of Julia is richer than that of R. Therefore, to be able to turn
the Julia data structures that have been translated to R back to the original Julia
data structures, the original Julia types are added to the translated Julia objects
in R via the attribute <code>"JLTYPE"</code>.
When passed to Julia, R variables with this
attribute will be coerced to the respective type.
This allows the reconstruction of the objects
with their original type.
</p>
<p>It should not be necessary to worry too much
about the translations from Julia to R because the resulting R objects should be
intuitive to handle.
</p>
<p>The following table shows how basic R-compatible types of Julia are translated to R:
</p>

<table>
<tr>
 <td style="text-align: left;">
<strong>Julia</strong> </td><td style="text-align: center;">  </td><td style="text-align: left;"> <strong>R</strong> </td>
</tr>
<tr>
 <td style="text-align: left;">
 <code>Float64</code></td><td style="text-align: center;"> <code class="reqn">\rightarrow</code> </td><td style="text-align: left;"><code>double</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
 <code>Float16</code>, <code>Float32</code>, <code>UInt32</code> </td><td style="text-align: center;"> <code class="reqn">\rightarrow</code> </td><td style="text-align: left;"><code>double</code> with type attribute </td>
</tr>
<tr>
 <td style="text-align: left;">
 <code>Int64</code> that fits in 32 bits </td><td style="text-align: center;"> <code class="reqn">\rightarrow</code> </td><td style="text-align: left;"> <code>integer</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
 <code>Int64</code> not fitting in 32 bits </td><td style="text-align: center;"> <code class="reqn">\rightarrow</code> </td><td style="text-align: left;"> <code>double</code> with type attribute </td>
</tr>
<tr>
 <td style="text-align: left;">
 <code>Int8</code>, <code>Int16</code>, <code>UInt16</code>, <code>Int32</code>, <code>Char</code> </td><td style="text-align: center;"> <code class="reqn">\rightarrow</code> </td><td style="text-align: left;"><code>integer</code> with type attribute </td>
</tr>
<tr>
 <td style="text-align: left;">
 <code>UInt8</code></td><td style="text-align: center;"> <code class="reqn">\rightarrow</code> </td><td style="text-align: left;"><code>raw</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
 <code>UInt64</code>, <code>Int128</code>, <code>UInt128</code>, <code>Ptr</code> </td><td style="text-align: center;"> <code class="reqn">\rightarrow</code> </td><td style="text-align: left;"><code>raw</code> with type attribute </td>
</tr>
<tr>
 <td style="text-align: left;">
 <code>Complex{Float64}</code></td><td style="text-align: center;"> <code class="reqn">\rightarrow</code> </td><td style="text-align: left;"><code>complex</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
 <code>Complex{Int<var>X</var>}</code> with <var>X</var> <code class="reqn">\leq</code> 64 </td><td style="text-align: center;"> <code class="reqn">\rightarrow</code> </td><td style="text-align: left;"><code>complex</code> with type attribute </td>
</tr>
<tr>
 <td style="text-align: left;">
 <code>Complex{Float<var>X</var>}</code> with <var>X</var> <code class="reqn">\leq</code> 32 </td><td style="text-align: center;"> <code class="reqn">\rightarrow</code> </td><td style="text-align: left;"><code>complex</code> with type attribute </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>Julia <code>Array</code>s of these types are translated to <code>vector</code>s or <code>array</code>s of the corresponding types in R.
</p>
<p>Julia functions are translated to R functions that call the Julia function.
These functions can also be translated back to the
corresponding Julia functions when used as argument of another function
(see <code><a href="#topic+juliaFun">juliaFun</a></code>).
</p>
<p>Julia object of other types, in particular <code>struct</code>s, <code>Tuple</code>s, <code>NamedTuple</code>s,
and <code>AbstractArray</code>s of other types are transferred by reference in the form of proxy objects.
Elements and properties of these proxy objects can be accessed and mutated via the operators <code>`[[`</code>,
<code>`[`</code>, and <code>`$`</code> (see <a href="#topic+AccessMutate.JuliaProxy">AccessMutate.JuliaProxy</a>).
</p>
<p>A full translation of the proxy objects into R objects, which also allows saving these objects in R,
is possible via <code><a href="#topic+juliaGet">juliaGet</a></code>.
</p>



<h3>Limitations</h3>



<h4>Possible inexactness when dealing with large 64 bit integers</h4>

<p>Numbers of type <code>Int64</code> that are too big to be expressed as 32-bit
<code>integer</code> values in R will be translated to <code>double</code> numbers.
This may lead to a inaccurate results for very large numbers,
when they are translated back to Julia, since, e. g.,
<code>(2^53 + 1) - 2^53 == 0</code> holds for double-precision
floating point numbers.
</p>



<h4>Non-ASCII characters in variable names</h4>

<p>Julia uses UTF-8 as default string encoding everywhere.
In particular, Julia permits characters that are not
expressible in encodings such as &quot;Latin-1&quot; in variable and function names.
In R, the encoding of names in lists of environments depends on the platform.
On locales without UTF-8 as native encoding, (i.e., mostly Windows),
unexpected translations may happen when using UTF-8 characters in strings.
</p>
<p>When using <code><a href="#topic+juliaImport">juliaImport</a></code> for importing packages/modules,
alternative names for variables using non-ASCII characters are added,
which are compatible across different encodings.
(For more information, see <code><a href="#topic+juliaImport">juliaImport</a></code>.)
</p>
<p>In other places, such as when evaluating code via <code><a href="#topic+juliaEval">juliaEval</a></code> and
<code><a href="#topic+juliaLet">juliaLet</a></code>, the problem cannot be addressed.
It should therefore be avoided to use non-ASCII characters
if code should be portable across different platforms.
</p>



<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Stefan Lenz <a href="mailto:stefan-m-lenz@web.de">stefan-m-lenz@web.de</a> (<a href="https://orcid.org/0000-0001-9135-1743">ORCID</a>)
</p>
<p>Authors:
</p>

<ul>
<li><p> Harald Binder (<a href="https://orcid.org/0000-0002-5666-8662">ORCID</a>) [thesis advisor]
</p>
</li></ul>

<p>Other contributors:
</p>

<ul>
<li><p> Angelo D'Ambrosio (<a href="https://orcid.org/0000-0002-2045-5155">ORCID</a>) [contributor]
</p>
</li>
<li><p> June Choe (<a href="https://orcid.org/0000-0002-0701-921X">ORCID</a>) [contributor]
</p>
</li></ul>


<hr>
<h2 id='AccessMutate.JuliaProxy'>Access or mutate Julia objects via proxy objects</h2><span id='topic+AccessMutate.JuliaProxy'></span><span id='topic++24.JuliaStructProxy'></span><span id='topic++24+3C-.JuliaStructProxy'></span><span id='topic++5B.JuliaProxy'></span><span id='topic++5B+3C-.JuliaProxy'></span><span id='topic++5B.JuliaSimpleArrayProxy'></span><span id='topic++5B+5B.JuliaArrayProxy'></span><span id='topic++5B+5B+3C-.JuliaArrayProxy'></span><span id='topic++5B+5B.JuliaStructProxy'></span><span id='topic++5B+5B+3C-.JuliaStructProxy'></span><span id='topic+length.JuliaArrayProxy'></span><span id='topic+dim.JuliaArrayProxy'></span>

<h3>Description</h3>

<p>Apply the R operators <code>$</code> and <code>$&lt;-</code>, <code>[</code> and <code>[&lt;-</code>, <code>[[</code>
and <code>[[&lt;-</code> to access or modify parts of Julia objects via their proxy objects.
For an intuitive understanding, best see the examples below.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'JuliaStructProxy'
x$name

## S3 replacement method for class 'JuliaStructProxy'
x$name &lt;- value

## S3 method for class 'JuliaProxy'
x[...]

## S3 replacement method for class 'JuliaProxy'
x[i, j, k] &lt;- value

## S3 method for class 'JuliaSimpleArrayProxy'
x[...]

## S3 method for class 'JuliaArrayProxy'
x[[...]]

## S3 replacement method for class 'JuliaArrayProxy'
x[[i, j, k]] &lt;- value

## S3 method for class 'JuliaStructProxy'
x[[name]]

## S3 replacement method for class 'JuliaStructProxy'
x[[name]] &lt;- value

## S3 method for class 'JuliaArrayProxy'
length(x)

## S3 method for class 'JuliaArrayProxy'
dim(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="AccessMutate.JuliaProxy_+3A_x">x</code></td>
<td>
<p>a Julia proxy object</p>
</td></tr>
<tr><td><code id="AccessMutate.JuliaProxy_+3A_name">name</code></td>
<td>
<p>the field of a struct type, the name of a member in a <code>NamedTuple</code>,
or a key in a Julia dictionary (type <code>AbstractDict</code>)</p>
</td></tr>
<tr><td><code id="AccessMutate.JuliaProxy_+3A_value">value</code></td>
<td>
<p>a suitable replacement value.
When replacing a range of elements in an array type, it is possible to
replace multiple elements with single elements. In all other cases,
the length of the replacement must match the number of elements to replace.</p>
</td></tr>
<tr><td><code id="AccessMutate.JuliaProxy_+3A_i">i</code>, <code id="AccessMutate.JuliaProxy_+3A_j">j</code>, <code id="AccessMutate.JuliaProxy_+3A_k">k</code>, <code id="AccessMutate.JuliaProxy_+3A_...">...</code></td>
<td>
<p>index(es) for specifying the elements to extract or replace</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The operators <code>$</code> and <code>[[</code> allow to access properties of Julia <code>struct</code>s
and <code>NamedTuple</code>s via their proxy objects.
For dictionaries (Julia type <code>AbstractDict</code>), <code>$</code> and <code>[[</code>
can also be used to look up string keys.
Fields of <code>mutable struct</code>s and dictionary elements with string keys
can be set via <code>$&lt;-</code> and <code>[[&lt;-</code>.
</p>
<p>For <code>AbstractArray</code>s, the <code>[</code>, <code>[&lt;-</code>, <code>[[</code>, and <code>[[&lt;-</code>
operators relay to the <code>getindex</code> and <code>setindex!</code> Julia functions.
The <code>[[</code> and <code>[[&lt;-</code> operators are used to access or mutate a single element.
With <code>[</code> and <code>[&lt;-</code>, a range of objects is accessed or mutated.
The elements of <code>Tuple</code>s can also be accessed via <code>[</code> and <code>[[</code>.
</p>
<p>The dimensions of proxy objects for Julia <code>AbstractArray</code>s and <code>Tuple</code>s
can be queried via <code>length</code> and <code>dim</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: #'
# (Mutable) struct
juliaEval("mutable struct MyStruct
              x::Int
           end")

MyStruct &lt;- juliaFun("MyStruct")
s &lt;- MyStruct(1L)
s$x
s$x &lt;- 2
s[["x"]]

# Array
x &lt;- juliaCall("map", MyStruct, c(1L, 2L, 3L))
x
length(x)
x[[1]]
x[[1]]$x
x[[1]] &lt;- MyStruct(2L)
x[2:3]
x[2:3] &lt;- MyStruct(2L)
x

# Tuple
x &lt;- juliaEval("(1, 2, 3)")
x[[1]]
x[1:2]
length(x)

# NamedTuple
x &lt;- juliaEval("(a=1, b=2)")
x$a

# Dictionary
strDict &lt;- juliaEval('Dict("hi" =&gt; 1, "hello" =&gt; 2)')
strDict
strDict$hi
strDict$hi &lt;- 0
strDict[["hi"]] &lt;- 2
strDict["howdy", "greetings"] &lt;- c(2, 3)
strDict["hi", "howdy"]


## End(Not run)
</code></pre>

<hr>
<h2 id='as.data.frame.JuliaProxy'>Coerce a Julia Table to a Data Frame</h2><span id='topic+as.data.frame.JuliaProxy'></span>

<h3>Description</h3>

<p>Get the data from a Julia proxy object that implements the Julia
<a href="https://github.com/JuliaData/Tables.jl"><code>Tables</code></a> interface,
and create an R data frame from it.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'JuliaProxy'
as.data.frame(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as.data.frame.JuliaProxy_+3A_x">x</code></td>
<td>
<p>a proxy object pointing to a Julia object that implements the interface
of the package Julia package <code>Tables</code></p>
</td></tr>
<tr><td><code id="as.data.frame.JuliaProxy_+3A_...">...</code></td>
<td>
<p>(not used)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Strings are not converted to factors.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (juliaSetupOk() &amp;&amp; Sys.getenv("NOT_CRAN") == "true") {
   # (This example is not run on CRAN as it takes a little too long.)

   # Demonstrate the usage with the Julia package "IndexedTables" (v1.0)

   # Install the package first if it is not installed:
   # juliaEval('import Pkg; Pkg.add("IndexedTables")')

   # Import "IndexedTables" package
   IndexedTables &lt;- juliaImport("IndexedTables")

   mydf &lt;- data.frame(x = c(1, 2, 3),
                      y = c("a", "b", "c"),
                      z = c(TRUE, FALSE, NA),
                      stringsAsFactors = FALSE)

   # Create a table in Julia, e. g. via IndexedTables
   mytbl &lt;- IndexedTables$table(mydf)

   # This table can, e g. be queried and
   # the result can be translated to an R data frame.
   seltbl &lt;- IndexedTables$select(mytbl, juliaExpr("(:x, :y)"))[1:2]

   # Translate selection of Julia table into R data frame
   as.data.frame(seltbl)

}


</code></pre>

<hr>
<h2 id='EnvVars-JuliaConnectoR'>Environment variables used by the <span class="pkg">JuliaConnectoR</span></h2><span id='topic+EnvVars-JuliaConnectoR'></span><span id='topic+JULIA_BINDIR'></span><span id='topic+JULIACONNECTOR_JULIAENV'></span><span id='topic+JULIACONNECTOR_SERVER'></span>

<h3>Description</h3>

<p>There are some environment variables which can be used to deviate from the
default behavior of the package.
To have an effect, these environment variables must be set before a Julia
connection is established, i.e., before the first call to Julia or before a
call to  <code><a href="#topic+startJuliaServer">startJuliaServer</a></code>.
All the variables are optional.
</p>


<h3>Details</h3>

<p>The environment variables that are used in the package are listed below:
</p>

<dl>
<dt><span class="env">JULIA_BINDIR</span>:</dt><dd><p>If this variable is set to the path of the Julia <code>bin</code> directory
before connecting to Julia, the corresponding Julia installation will be used.
By using this variable, it is possible to use a different Julia version
than the one in the system <span class="env">PATH</span>.
(You can find the correct path to the <code>bin</code> directory
of Julia by evaluating the expression <code>Sys.BINDIR</code> within Julia.)</p>
</dd>
<dt><span class="env">JULIACONNECTOR_JULIAENV</span>:</dt><dd><p>Specify environment variables only for
Julia.
(This does not work on Windows and the variable is ignored there.)
This allows, e.g., to set
the LD_LIBRARY_PATH variable to a different value for Julia than for R.
The value can be any R code that defines variables, e.g.,
<code>"LD_LIBRARY_PATH=''"</code> is a valid value.
On Linux, Julia is started with an empty <code>LD_LIBRARY_PATH</code>
by default as the <code>LD_LIBRARY_PATH</code> required by R may be incompatible
with Julia. If the <code>LD_LIBRARY_PATH</code> needs to be set to a different
value, this can be done via the <code>JULIACONNECTOR_JULIAENV</code> variable.</p>
</dd>
<dt><span class="env">JULIACONNECTOR_JULIAOPTS</span>:</dt><dd><p>Set start-up options for Julia.
As an example, consider specifying the project environment and enabling
code coverage when starting Julia. This can be achieved by setting
the environment variable to
<code>"--project=/path/to/project --code-coverage"</code>.</p>
</dd>
<dt><span class="env">JULIACONNECTOR_SERVER</span>:</dt><dd><p>Specifies the server address of a
(running) Julia server that the R process can connect to.
A possible example value is &quot;localhost:11980&quot;, specifying host and port.
The function <code><a href="#topic+startJuliaServer">startJuliaServer</a></code> sets this variable and
communicates the location of the server to child processes with it.
Due to security concerns, the Julia server accepts only connections from
the same machine and connecting to remote machines is currently not
possible.</p>
</dd>
</dl>


<hr>
<h2 id='Julia-Setup'>Julia setup</h2><span id='topic+Julia-Setup'></span>

<h3>Description</h3>

<p>Julia must be installed separately in order for the <span class="pkg">JuliaConnectoR</span> package to work.
You can download and install Julia from <a href="https://julialang.org/downloads/">https://julialang.org/downloads/</a>.
</p>


<h3>Details</h3>



<h4>Setup via the Juliaup installation manager</h4>

<p>If you have installed Julia via Juliaup,
the Julia installation should be discovered by the <span class="pkg">JuliaConnectoR</span>.
</p>



<h4>Juliaup on Windows</h4>

<p>If you have freshly installed Juliaup, start Julia once on the command line.
This will do the actual installation of the current Julia version.
Juliaup puts the Julia executable on the system <span class="env">PATH</span>.
This way, the Julia installation can be detected by the <span class="pkg">JuliaConnectoR</span>.
</p>



<h4>Juliaup on Mac</h4>

<p>After the installation of Juliaup, Julia might not be on the system <span class="env">PATH</span>
but it should be discovered automatically
if it is installed in the default location, i.e., the <code>.juliaup</code>
folder in your home directory.
</p>



<h4>Setup via Julia binaries</h4>

<p>If you have installed Julia via a binary package or any other method,
the simplest way to make Julia discoverable is by adding the directory
containing the Julia executable to the <span class="env">PATH</span> environment variable.
</p>
<p>Alternatively, you can set the <span class="env">JULIA_BINDIR</span> environment variable
to specify the exact directory containing the Julia binary.
(You can find the correct path to this directory by evaluating the expression
<code>Sys.BINDIR</code> within Julia.)
</p>
<p>If the <span class="env">JULIA_BINDIR</span> variable is set, it takes precedence over
looking up the system <span class="env">PATH</span>.
This makes it easy to use a different Julia version
than the one in your system <span class="env">PATH</span>.
</p>


<hr>
<h2 id='juliaCall'>Call a Julia function by name</h2><span id='topic+juliaCall'></span>

<h3>Description</h3>

<p>Call a Julia function via specifying the name as string and get the translated result.
It is also possible to use a dot at the end of the function name
for applying the function in a vectorized manner via &quot;broadcasting&quot; in Julia.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>juliaCall(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="juliaCall_+3A_...">...</code></td>
<td>
<p>the name of the Julia function as first argument, followed by the
parameters handed to the function.
All arguments to the Julia function are translated to Julia data structures.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The value returned from Julia, translated to an R data structure.
If Julia returns <code>nothing</code>, an invisible <code>NULL</code> is returned.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (juliaSetupOk()) {

   juliaCall("/", 4, 2)
   juliaCall("Base.div", 4, 2)
   juliaCall("sin.", c(1,2,3))
   juliaCall("Base.cos.", c(1,2,3))

}


</code></pre>

<hr>
<h2 id='juliaEval'>Evaluate a Julia expression</h2><span id='topic+juliaEval'></span>

<h3>Description</h3>

<p>This function evaluates Julia code, given as a string, in Julia,
and translates the result back to R.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>juliaEval(expr)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="juliaEval_+3A_expr">expr</code></td>
<td>
<p>Julia code, given as a one-element character vector</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the code needs to use R variables, consider using <code>juliaLet</code>
instead.
</p>


<h3>Value</h3>

<p>The value returned from Julia, translated to an R data structure.
If Julia returns <code>nothing</code>, an invisible <code>NULL</code> is returned.
This is also the case if the last non-whitespace character of <code>expr</code>
is a semicolon.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (juliaSetupOk()) {
   juliaEval("1 + 2")
   juliaEval('using Random; Random.seed!(5);')

## Not run: 
   juliaEval('using Pkg; Pkg.add("BoltzmannMachines")')

## End(Not run)
}

</code></pre>

<hr>
<h2 id='juliaExpr'>Mark a string as Julia expression</h2><span id='topic+juliaExpr'></span>

<h3>Description</h3>

<p>A given R character vector is marked as a Julia expression.
It will be executed and evaluated when passed to Julia.
This allows to pass a Julia object that is defined by complex Julia syntax
as an argument without needing the round-trip to R via <code><a href="#topic+juliaEval">juliaEval</a></code>
or <code><a href="#topic+juliaLet">juliaLet</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>juliaExpr(expr)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="juliaExpr_+3A_expr">expr</code></td>
<td>
<p>a character vector which should contain one string</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>if (juliaSetupOk()) {

   # Create complicated objects like version strings in Julia, and compare them
   v1 &lt;- juliaExpr('v"1.0.1"')
   v2 &lt;- juliaExpr('v"1.2.0"')
   juliaCall("&lt;", v1, v2)

}


</code></pre>

<hr>
<h2 id='juliaFun'>Wrap a Julia function in an R function</h2><span id='topic+juliaFun'></span>

<h3>Description</h3>

<p>Creates an R function that will call the Julia function with the given name
when it is called. Like any R function, the returned function can
also be passed as a function argument to Julia functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>juliaFun(name, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="juliaFun_+3A_name">name</code></td>
<td>
<p>the name of the Julia function</p>
</td></tr>
<tr><td><code id="juliaFun_+3A_...">...</code></td>
<td>
<p>optional arguments for currying:
The resulting function will be called using these arguments.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>if (juliaSetupOk()) {

   # Wrap a Julia function and use it
   juliaSqrt &lt;- juliaFun("sqrt")
   juliaSqrt(2)
   # In the following call, the sqrt function is called without
   # a callback to R because the linked function object is used.
   juliaCall("map", juliaSqrt, c(1,4,9))

   # may also be used with arguments
   plus1 &lt;- juliaFun("+", 1)
   plus1(2)
   # Results in an R callback (calling Julia again)
   # because there is no linked function object in Julia.
   juliaCall("map", plus1, c(1,2,3))

}


</code></pre>

<hr>
<h2 id='juliaGet'>Translate a Julia proxy object to an R object</h2><span id='topic+juliaGet'></span>

<h3>Description</h3>

<p>R objects of class <code>JuliaProxy</code> are references to Julia objects in the Julia session.
These R objects are also called &quot;proxy objects&quot;.
With this function it is possible to translate these objects into R objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>juliaGet(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="juliaGet_+3A_x">x</code></td>
<td>
<p>a reference to a Julia object</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the corresponding Julia objects do not contain external references,
translated objects can also saved in R and safely be restored in Julia.
</p>
<p>Modifying objects is possible and changes in R will be translated back to Julia.
</p>
<p>The following table shows the translation of Julia objects into R objects.
</p>

<table>
<tr>
 <td style="text-align: left;">
<strong>Julia</strong> </td><td style="text-align: center;">  </td><td style="text-align: left;"> <strong>R</strong> </td>
</tr>
<tr>
 <td style="text-align: left;">
 <code>struct</code> </td><td style="text-align: center;"> <code class="reqn">\rightarrow</code> </td><td style="text-align: left;"> <code>list</code> with the named struct elements </td>
</tr>
<tr>
 <td style="text-align: left;">
 <code>Array</code> of <code>struct</code> type </td><td style="text-align: center;"> <code class="reqn">\rightarrow</code> </td><td style="text-align: left;"> <code>list</code> (of <code>list</code>s) </td>
</tr>
<tr>
 <td style="text-align: left;">
 <code>Tuple</code> </td><td style="text-align: center;"> <code class="reqn">\rightarrow</code> </td><td style="text-align: left;"> <code>list</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
 <code>NamedTuple</code> </td><td style="text-align: center;"> <code class="reqn">\rightarrow</code> </td><td style="text-align: left;"> <code>list</code> with the named elements </td>
</tr>
<tr>
 <td style="text-align: left;">
 <code>AbstractDict</code> </td><td style="text-align: center;"> <code class="reqn">\rightarrow</code> </td><td style="text-align: left;"> <code>list</code> with two sub-lists: "<code>keys</code>" and "<code>values</code>" </td>
</tr>
<tr>
 <td style="text-align: left;">
 <code>AbstractSet</code> </td><td style="text-align: center;"> <code class="reqn">\rightarrow</code> </td><td style="text-align: left;"> <code>list</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Note</h3>

<p>Objects containing circular references cannot be translated back to Julia.
</p>
<p>It is safe to translate objects that contain external references from Julia to R.
The pointers will be copied as values and the finalization of the translated
Julia objects is prevented.
The original objects are garbage collected after all direct or
indirect copies are garbage collected.
Note, however, that these translated objects cannot be translated back to Julia
after the Julia process has been stopped and restarted.
</p>

<hr>
<h2 id='juliaImport'>Load and import a Julia package via <code>import</code> statement</h2><span id='topic+juliaImport'></span>

<h3>Description</h3>

<p>The specified package/module is loaded via <code>import</code> in Julia.
Its functions and type constructors are wrapped into R functions.
The return value is an environment containing all these R functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>juliaImport(modulePath, all = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="juliaImport_+3A_modulepath">modulePath</code></td>
<td>
<p>a module path or a module object.
A module path may simply be the name of a package but it may also
be a relative module path.
Specifying a relative Julia module path like <code>.MyModule</code>
allows importing a module that does not correspond to a package,
but has been loaded in the <code>Main</code> module, e. g. by
<code>juliaCall("include", "path/to/MyModule.jl")</code>.
Additionally, via a path such as <code>SomePkg.SubModule</code>,
a submodule of a package can be imported.</p>
</td></tr>
<tr><td><code id="juliaImport_+3A_all">all</code></td>
<td>
<p><code>logical</code> value, default <code>TRUE</code>.
Specifies whether all functions and types shall be imported
or only those exported explicitly.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an environment containing all functions and type constructors
from the specified module as R functions
</p>


<h3>Note</h3>

<p>If a package or module contains functions or types with names that contain
non-ASCII characters, (additional) alternatives names are provided
if there are LaTeX-like names for the characters available in Julia.
In the alternative names of the variables, the LaTeX-like names of the
characters surrounded by <code>&lt;...&gt;</code> replace the original characters.
(See example below.)
For writing platform independent code, it is recommended to use those
alternative names.
(See also <a href="#topic+JuliaConnectoR-package">JuliaConnectoR-package</a> under &quot;Limitations&quot;.)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (juliaSetupOk()) {

   # Importing a package and using one of its exported functions
   UUIDs &lt;- juliaImport("UUIDs")
   juliaCall("string", UUIDs$uuid4())


   # Importing a module without a package
   testModule &lt;- system.file("examples", "TestModule1.jl",
                             package = "JuliaConnectoR")
   # take a look at the file
   writeLines(readLines(testModule))
   # load in Julia
   juliaCall("include", testModule)
   # import in R via relative module path
   TestModule1 &lt;- juliaImport(".TestModule1")
   TestModule1$test1()

   # Importing a local module is also possible in one line,
   # by directly using the module object returned by "include".
   TestModule1 &lt;- juliaImport(juliaCall("include", testModule))
   TestModule1$test1()


   # Importing a submodule
   testModule &lt;- system.file("examples", "TestModule1.jl",
                             package = "JuliaConnectoR")
   juliaCall("include", testModule)
   # load sub-module via module path
   SubModule1 &lt;- juliaImport(".TestModule1.SubModule1")
   # call function of submodule
   SubModule1$test2()


   # Functions using non-ASCII characters
   greekModule &lt;- system.file("examples", "GreekModule.jl",
                             package = "JuliaConnectoR")
   suppressWarnings({ # importing gives a warning on non-UTF-8 locales
      GreekModule &lt;- juliaImport(juliaCall("include", greekModule))
   })
   # take a look at the file
   cat(readLines(greekModule, encoding = "UTF-8"), sep = "\n")
   # use alternative names
   GreekModule$`&lt;sigma&gt;`(1)
   GreekModule$`log&lt;sigma&gt;`(1)
}


</code></pre>

<hr>
<h2 id='juliaLet'>Evaluate Julia code in a <code>let</code> block using values of R variables</h2><span id='topic+juliaLet'></span>

<h3>Description</h3>

<p>R variables can be passed as named arguments, which are inserted
for those variables in the Julia expression that have the same name
as the named arguments. The given Julia code is executed in Julia
inside a <code>let</code> block and the result is translated back to R.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>juliaLet(expr, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="juliaLet_+3A_expr">expr</code></td>
<td>
<p>Julia code, given as one-element character vector</p>
</td></tr>
<tr><td><code id="juliaLet_+3A_...">...</code></td>
<td>
<p>arguments that will be introduced as variables in the
<code>let</code> block. The values are transferred to Julia and
assigned to the variables introduced in the <code>let</code> block.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A simple, nonsensical example for explaining the principle:
</p>
<p><code>juliaLet('println(x)', x = 1)</code>
</p>
<p>This is the same as
</p>
<p><code>juliaEval('let x = 1.0; println(x) end')</code>
</p>
<p>More complex objects cannot be simply represented in a string like in
this simple example any more.
That is the problem that <code>juliaLet</code> solves.
</p>
<p>Note that the evaluation is done in a <code>let</code> block. Therefore,
changes to global variables in the Julia session are only possible by
using the keyword <code>global</code> in front of the Julia variables
(see examples).
</p>


<h3>Value</h3>

<p>The value returned from Julia, translated to an R data structure.
If Julia returns <code>nothing</code>, an invisible <code>NULL</code> is returned.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (juliaSetupOk()) {

   # Intended use: Create a complex Julia object
   # using Julia syntax and data from the R workspace
   juliaLet('[1 =&gt; x, 17 =&gt; y]', x = rnorm(1), y = rnorm(2))

   # Assign a global variable
   # (although not recommended for a functional style)
   juliaLet("global x = xval", xval = rnorm(10))
   juliaEval("x")

}


</code></pre>

<hr>
<h2 id='juliaPut'>Create a Julia proxy object from an R object</h2><span id='topic+juliaPut'></span>

<h3>Description</h3>

<p>This function can be used to copy R vectors and matrices to Julia and keep
them there.
The returned proxy object can be used in place of the original vector or
matrix.
This is useful to prevent that large R vectors / matrices
are repeatedly translated when using an object in multiple calls to Julia.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>juliaPut(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="juliaPut_+3A_x">x</code></td>
<td>
<p>an R object (can also be a translated Julia object)</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>if (juliaSetupOk()) {

   # Transfer a large vector to Julia and use it in multiple calls
   x &lt;- juliaPut(rnorm(100))
   # x is just a reference to a Julia vector now
   juliaEval("using Statistics")
   juliaCall("mean", x)
   juliaCall("var", x)

}


</code></pre>

<hr>
<h2 id='juliaSetupOk'>Check Julia setup</h2><span id='topic+juliaSetupOk'></span>

<h3>Description</h3>

<p>Checks that Julia can be started and that the Julia version is at least 1.0.
For more information about the setup and discovery of Julia,
see <a href="#topic+JuliaConnectoR-package">JuliaConnectoR-package</a>, section &quot;Setup&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>juliaSetupOk()
</code></pre>


<h3>Value</h3>

<p><code>TRUE</code> if the Julia setup is OK; otherwise <code>FALSE</code>
</p>

<hr>
<h2 id='startJuliaServer'>Start a Julia server that may serve multiple clients (R processes)</h2><span id='topic+startJuliaServer'></span>

<h3>Description</h3>

<p>Starting a Julia server allows that different R processes may connect to the
the same Julia server and share a single session.
This can be useful for saving start-up/precompilation time when starting
additional processes or when sharing global variables between processes.
<em>For the standard way of starting Julia, this function is not needed.
It is also not needed if child processes should use separate Julia sessions.</em>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>startJuliaServer(port = 11980)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="startJuliaServer_+3A_port">port</code></td>
<td>
<p>a hint for the port that is used by the server.
If it is not available, a different port is used.
The final port is returned (invisibly).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The functions communicates the server address via setting the
<span class="env">JULIACONNECTOR_SERVER</span> environment variable.
A possible value for the variable is &quot;localhost:11980&quot;.
The <span class="env">JULIACONNECTOR_SERVER</span> variable is communicated automatically via
the system environment to child processes that are started after this
function has been called.
The child processes will then connect to the same Julia server if the
variable is set.
The variable can also be set explicitly in child processes before connecting
to Julia to connect to a running server.
Unsetting the variable will result in a normal Julia start-up in the first
call to Julia, using a single-client Julia session.
</p>
<p>For security reasons, the Julia server accepts only connections
from localhost.
</p>
<p>For using Julia with multiple clients, it can be good to advise Julia to
use multiple threads via setting the <span class="env">JULIA_NUM_THREADS</span> environment
variable before starting Julia.
</p>


<h3>Value</h3>

<p>the port number (invisibly)
</p>


<h3>Note</h3>

<p>The standard (error) output from Julia (printing and warnings)
can currently only be forwarded to one client.
This is currently the last client that has connected but this may be subject
to change.
</p>


<h3>See Also</h3>

<p><a href="#topic+JULIACONNECTOR_SERVER">JULIACONNECTOR_SERVER</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (juliaSetupOk()) {

   Sys.setenv("JULIA_NUM_THREADS" = parallel::detectCores())
   startJuliaServer()

   library(future)
   plan(multisession) # use background R processes on the same machine

   juliaEval("global x = 1")

   # Child processes now use the same Julia session:
   f1 &lt;- future({juliaEval("x")})
   value(f1)

   plan(sequential) # close background workers

}

</code></pre>

<hr>
<h2 id='stopJulia'>Stop the connection to Julia</h2><span id='topic+stopJulia'></span>

<h3>Description</h3>

<p>This ends the connection to Julia. Julia terminates if no R process is
connected any more.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stopJulia()
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
