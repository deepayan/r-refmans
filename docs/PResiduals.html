<!DOCTYPE html><html><head><title>Help for package PResiduals</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {PResiduals}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#cobot'><p>Conditional ordinal by ordinal tests for association.</p></a></li>
<li><a href='#cocobot'><p>Conditional continuous by ordinal tests for association.</p></a></li>
<li><a href='#conditional_Spearman'><p>Conditional Partial Spearman's Rank Correlation</p></a></li>
<li><a href='#corr'><p>Calculates the weighted correlation given a data set and a set of weights.</p></a></li>
<li><a href='#countbot'><p>Conditional count by ordinal tests for association.</p></a></li>
<li><a href='#diagn'><p>Extract or construct a diagonal matrix.</p></a></li>
<li><a href='#GKGamma'><p>Goodman-Kruskal's <code class="reqn">\gamma</code></p></a></li>
<li><a href='#kernel.function'><p>kernel.function</p></a></li>
<li><a href='#megabot'><p>Conditional tests for association.</p></a></li>
<li><a href='#newpolr'><p>slightly modified version of polr from MASS</p></a></li>
<li><a href='#partial_Spearman'><p>Partial Spearman's Rank Correlation</p></a></li>
<li><a href='#plot.conditional_Spearman'><p>conditional_Spearman class plot method</p></a></li>
<li><a href='#presid'><p>Probability-scale residual</p></a></li>
<li><a href='#PResidData'><p>Example Dataset for PResiduals Package</p></a></li>
<li><a href='#PResiduals-package'><p>Computes probability-scale residuals and residual correlations.</p></a></li>
<li><a href='#print.cobot'><p>cobot class print method</p></a></li>
<li><a href='#print.cocobot'><p>cocobot class print method</p></a></li>
<li><a href='#print.conditional_Spearman'><p>conditional_Spearman class print method</p></a></li>
<li><a href='#print.partial_Spearman'><p>partial_Spearman class print method</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Probability-Scale Residuals and Residual Correlations</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0-1</td>
</tr>
<tr>
<td>Author:</td>
<td>Charles Dupont, Jeffrey Horner, Chun Li, Qi Liu, Bryan Shepherd</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Chun Li &lt;cli77199@usc.edu&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Computes probability-scale residuals and residual correlations
    for continuous, ordinal, binary, count, and time-to-event data &lt;<a href="https://doi.org/10.18637%2Fjss.v094.i12">doi:10.18637/jss.v094.i12</a>&gt;.</td>
</tr>
<tr>
<td>Imports:</td>
<td>MASS, Formula, rms, SparseM,</td>
</tr>
<tr>
<td>Suggests:</td>
<td>survival, testthat</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Collate:</td>
<td>'GKGamma.R' 'PResidData.R' 'PResiduals-package.R' 'pgumbel.R'
'diagn.R' 'newPolr.R' 'cobot.R' 'cocobot.R' 'condis.R'
'conditional_Spearman.R' 'corTS.R' 'corr.R' 'countbot.R'
'getCI.R' 'kernel.function.R' 'lm.scores.R' 'megabot.R'
'nb.scores.R' 'orm.scores.R' 'partial_Spearman.R'
'plot.conditional_Spearman.R' 'poisson.scores.R' 'presid.R'
'print.cobot.R' 'print.cocobot.R'
'print.conditional_Spearman.R' 'print.partial_Spearman.R'</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-06-24 02:59:20 UTC; lic3</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-06-24 06:40:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='cobot'>Conditional ordinal by ordinal tests for association.</h2><span id='topic+cobot'></span>

<h3>Description</h3>

<p><code>cobot</code> tests for independence between two ordered categorical
variables, <var>X</var> and <var>Y</var> conditional on other variables,
<var>Z</var>.  The basic approach involves fitting models of <var>X</var> on
<var>Z</var> and <var>Y</var> on <var>Z</var> and determining whether there is any
remaining information between <var>X</var> and <var>Y</var>.  This is done by
computing one of 3 test statistics.  <code>T1</code> compares empirical
distribution of <var>X</var> and <var>Y</var> with the joint fitted
distribution of <var>X</var> and <var>Y</var> under independence conditional
on <var>Z</var>. <code>T2</code> computes the correlation between ordinal
(probability-scale) residuals from both models and tests the null
of no residual correlation.  <code>T3</code> evaluates the
concordance&ndash;disconcordance of data drawn from the joint fitted
distribution of <var>X</var> and <var>Y</var> under conditional independence
with the empirical distribution. Details are given in <cite>Li C and
Shepherd BE, Test of association between two ordinal variables
while adjusting for covariates. Journal of the American Statistical
Association 2010, 105:612-620</cite>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cobot(
  formula,
  link = c("logit", "probit", "cloglog", "loglog", "cauchit"),
  link.x = link,
  link.y = link,
  data,
  subset,
  na.action = na.fail,
  fisher = TRUE,
  conf.int = 0.95
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cobot_+3A_formula">formula</code></td>
<td>
<p>an object of class <code><a href="Formula.html#topic+Formula">Formula</a></code> (or one
that can be coerced to that class): a symbolic description of the
model to be fitted.  The details of model specification are given
under &lsquo;Details&rsquo;.</p>
</td></tr>
<tr><td><code id="cobot_+3A_link">link</code></td>
<td>
<p>The link family to be used for ordinal models of both
<var>X</var> and <var>Y</var>.  Defaults to &lsquo;<span class="samp">&#8288;logit&#8288;</span>&rsquo;. Other options are
&lsquo;<span class="samp">&#8288;probit&#8288;</span>&rsquo;, &lsquo;<span class="samp">&#8288;cloglog&#8288;</span>&rsquo;,&lsquo;<span class="samp">&#8288;loglog&#8288;</span>&rsquo;, and &lsquo;<span class="samp">&#8288;cauchit&#8288;</span>&rsquo;.</p>
</td></tr>
<tr><td><code id="cobot_+3A_link.x">link.x</code></td>
<td>
<p>The link function to be used for a model of the first
ordered variable. Defaults to value of <code>link</code>.</p>
</td></tr>
<tr><td><code id="cobot_+3A_link.y">link.y</code></td>
<td>
<p>The link function to be used for a model of the
second variable. Defaults to value of <code>link</code>.</p>
</td></tr>
<tr><td><code id="cobot_+3A_data">data</code></td>
<td>
<p>an optional data frame, list or environment (or object
coercible by <code><a href="base.html#topic+as.data.frame">as.data.frame</a></code> to a data frame)
containing the variables in the model.  If not found in
<code>data</code>, the variables are taken from
<code>environment(formula)</code>, typically the environment from which
<code>cobot</code> is called.</p>
</td></tr>
<tr><td><code id="cobot_+3A_subset">subset</code></td>
<td>
<p>an optional vector specifying a subset of
observations to be used in the fitting process.</p>
</td></tr>
<tr><td><code id="cobot_+3A_na.action">na.action</code></td>
<td>
<p>how <code>NA</code>s are treated.</p>
</td></tr>
<tr><td><code id="cobot_+3A_fisher">fisher</code></td>
<td>
<p>logical; if <code>TRUE</code>, Fisher transformation and delta method a
used to compute p value for the test statistic based on correlation of
residuals.</p>
</td></tr>
<tr><td><code id="cobot_+3A_conf.int">conf.int</code></td>
<td>
<p>numeric specifying confidence interval coverage.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>formula is specified as <code><var>X</var> | <var>Y</var> ~ <var>Z</var></code>.
This indicates that models of <code><var>X</var> ~ <var>Z</var></code> and
<code><var>Y</var> ~ <var>Z</var></code> will be fit.  The null hypothsis to be
tested is <code class="reqn">H_0 : X</code> independant of <var>Y</var> conditional
on <var>Z</var>.
</p>
<p>Note that <code>T2</code> can be thought of as an adjusted rank
correlation.(<cite>Li C and Shepherd BE, A new residual for ordinal
outcomes. Biometrika 2012; 99:473-480</cite>)
</p>


<h3>Value</h3>

<p>object of &lsquo;<span class="samp">&#8288;cobot&#8288;</span>&rsquo; class.
</p>


<h3>References</h3>

<p>Li C and Shepherd BE, Test of association between two
ordinal variables while adjusting for covariates. Journal of the
American Statistical Association 2010, 105:612-620.
</p>
<p>Li C and Shepherd BE, A new residual for ordinal
outcomes. Biometrika 2012; 99:473-480
</p>


<h3>See Also</h3>

<p><code><a href="Formula.html#topic+Formula">Formula</a></code>, <code><a href="base.html#topic+as.data.frame">as.data.frame</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(PResidData)
cobot(x|y~z, data=PResidData)
</code></pre>

<hr>
<h2 id='cocobot'>Conditional continuous by ordinal tests for association.</h2><span id='topic+cocobot'></span>

<h3>Description</h3>

<p><code>cocobot</code> tests for independence between an ordered categorical
variable, <var>X</var>, and a continuous variable, <var>Y</var>, conditional on other variables,
<var>Z</var>.  The basic approach involves fitting an ordinal model of <var>X</var> on
<var>Z</var>, a linear model of <var>Y</var> on <var>Z</var>, and then determining whether there is any
residual information between <var>X</var> and <var>Y</var>.  This is done by
computing residuals for both models, calculating their correlation, and 
testing the null of no residual correlation.  This procedure is analogous to test statistic 
<code>T2</code> in <code>cobot</code>.  Two test statistics (correlations) are currently output.  The first
is the correlation between probability-scale residuals. The second is the correlation between 
the observed-minus-expected residual for the continuous outcome model and a latent variable residual
for the ordinal model (Li C and Shepherd BE, 2012).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cocobot(
  formula,
  data,
  link = c("logit", "probit", "cloglog", "loglog", "cauchit"),
  subset,
  na.action = getOption("na.action"),
  emp = TRUE,
  fisher = TRUE,
  conf.int = 0.95
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cocobot_+3A_formula">formula</code></td>
<td>
<p>an object of class <code><a href="Formula.html#topic+Formula">Formula</a></code> (or one
that can be coerced to that class): a symbolic description of the
model to be fitted.  The details of model specification are given
under &lsquo;Details&rsquo;.</p>
</td></tr>
<tr><td><code id="cocobot_+3A_data">data</code></td>
<td>
<p>an optional data frame, list or environment (or object
coercible by <code><a href="base.html#topic+as.data.frame">as.data.frame</a></code> to a data frame)
containing the variables in the model.  If not found in
<code>data</code>, the variables are taken from
<code>environment(formula)</code>, typically the environment from which
<code>cocobot</code> is called.</p>
</td></tr>
<tr><td><code id="cocobot_+3A_link">link</code></td>
<td>
<p>The link family to be used for the ordinal model of 
<var>X</var> on <var>Z</var>.  Defaults to &lsquo;<span class="samp">&#8288;logit&#8288;</span>&rsquo;. Other options are
&lsquo;<span class="samp">&#8288;probit&#8288;</span>&rsquo;, &lsquo;<span class="samp">&#8288;cloglog&#8288;</span>&rsquo;, &lsquo;<span class="samp">&#8288;loglog&#8288;</span>&rsquo;, and &lsquo;<span class="samp">&#8288;cauchit&#8288;</span>&rsquo;.</p>
</td></tr>
<tr><td><code id="cocobot_+3A_subset">subset</code></td>
<td>
<p>an optional vector specifying a subset of
observations to be used in the fitting process.</p>
</td></tr>
<tr><td><code id="cocobot_+3A_na.action">na.action</code></td>
<td>
<p>action to take when <code>NA</code> present in data.</p>
</td></tr>
<tr><td><code id="cocobot_+3A_emp">emp</code></td>
<td>
<p>logical indicating whether the residuals from the model of
<var>Y</var> on <var>Z</var> are computed based on the assumption of normality (<code>FALSE</code>) 
or empirically (<code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="cocobot_+3A_fisher">fisher</code></td>
<td>
<p>logical indicating whether to apply fisher transformation to compute confidence intervals and p-values for the correlation.</p>
</td></tr>
<tr><td><code id="cocobot_+3A_conf.int">conf.int</code></td>
<td>
<p>numeric specifying confidence interval coverage.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Formula is specified as <code><var>X</var> | <var>Y</var> ~ <var>Z</var></code>.
This indicates that models of <code><var>X</var> ~ <var>Z</var></code> and
<code><var>Y</var> ~ <var>Z</var></code> will be fit.  The null hypothsis to be
tested is <code class="reqn">H_0 : X</code> independant of <var>Y</var> conditional
on <var>Z</var>.  The ordinal variable, <code><var>X</var></code>, must precede the <code>|</code> and be a factor variable, and <code><var>Y</var></code> must be continuous.
</p>


<h3>Value</h3>

<p>object of &lsquo;<span class="samp">&#8288;cocobot&#8288;</span>&rsquo; class.
</p>


<h3>References</h3>

<p>Li C and Shepherd BE (2012) 
A new residual for ordinal outcomes.
<em>Biometrika</em>. <b>99</b>: 473&ndash;480.
</p>
<p>Shepherd BE, Li C, Liu Q (2016)
Probability-scale residuals for continuous, discrete, and censored data.
<em>The Canadian Journal of Statistics</em>. <b>44</b>: 463&ndash;479.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(PResidData)
cocobot(y|w ~ z, data=PResidData)
</code></pre>

<hr>
<h2 id='conditional_Spearman'>Conditional Partial Spearman's Rank Correlation</h2><span id='topic+conditional_Spearman'></span>

<h3>Description</h3>

<p><code>conditional_Spearman</code> computes the partial Spearman's rank correlation between variable <var>X</var> and variable <var>Y</var> adjusting for variable <var>Z</var> conditional on <var>Zc</var>.
<var>X</var> and <var>Y</var> can be any orderable variables, including continuous and discrete variables. Covariate <var>Z</var> can be multidimensional. <var>X</var>, <var>Y</var>, and <var>Z</var> are specified by the argument &lsquo;<span class="samp">&#8288;formula&#8288;</span>&rsquo;.
<var>Zc</var> is a one-dimensional covariate, specified by the argument &lsquo;<span class="samp">&#8288;conditional.by&#8288;</span>&rsquo;.
The basic approach involves fitting a specified model of <var>X</var> on <var>Z</var>, a specified model of <var>Y</var> on <var>Z</var>, obtaining the probability-scale residuals, <var>Xres</var> and <var>Yres</var>, from both models, and then modeling their Pearson's correlation conditional on <var>Zc</var>.
Different methods are provided to model the Pearson's correlation between the two sets of probability-scale residuals. See details in &lsquo;<span class="samp">&#8288;conditional.method&#8288;</span>&rsquo;.
As in &lsquo;<span class="samp">&#8288;partial.Spearman&#8288;</span>&rsquo;, by default <code>conditional_Spearman</code> uses cumulative link models for both continous and discrete ordinal variables <var>X</var> and <var>Y</var> to preserve the rank-based nature of Spearman's correlation. For some specific types of variables, options of fitting parametric models are also available. See details in &lsquo;<span class="samp">&#8288;fit.x&#8288;</span>&rsquo; and &lsquo;<span class="samp">&#8288;fit.y&#8288;</span>&rsquo;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>conditional_Spearman(
  formula,
  conditional.by,
  data,
  conditional.method = c("lm", "kernel", "stratification"),
  conditional.formula = paste("~", conditional.by, sep = ""),
  kernel.function = c("normal", "gaussian", "triweight", "quartic", "biweight",
    "epanechnikov", "uniform", "triangle"),
  kernel.bandwidth = "silverman",
  fit.x = "orm",
  fit.y = "orm",
  link.x = c("logit", "probit", "cloglog", "loglog", "cauchit", "logistic"),
  link.y = c("logit", "probit", "cloglog", "loglog", "cauchit", "logistic"),
  subset,
  na.action = getOption("na.action"),
  fisher = TRUE,
  conf.int = 0.95
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="conditional_Spearman_+3A_formula">formula</code></td>
<td>
<p>an object of class <code><a href="Formula.html#topic+Formula">Formula</a></code> (or one
that can be coerced to that class): a symbolic description of the
model to be fitted.  The details of model specification are given
under &lsquo;Details&rsquo;.</p>
</td></tr>
<tr><td><code id="conditional_Spearman_+3A_conditional.by">conditional.by</code></td>
<td>
<p>the name of the variable on which the partial Spearman's correlation is conditional. See &lsquo;Details&rsquo;.</p>
</td></tr>
<tr><td><code id="conditional_Spearman_+3A_data">data</code></td>
<td>
<p>an optional data frame, list or environment (or object
coercible by <code><a href="base.html#topic+as.data.frame">as.data.frame</a></code> to a data frame)
containing the variables in the model.  If not found in
<code>data</code>, the variables are taken from
<code>environment(formula)</code>, typically the environment from which
<code>conditional_Spearman</code> is called.</p>
</td></tr>
<tr><td><code id="conditional_Spearman_+3A_conditional.method">conditional.method</code></td>
<td>
<p>the method to be used for modeling conditional correlation between probability-scale residuals. The default option is &lsquo;<span class="samp">&#8288;lm&#8288;</span>&rsquo;, which fits linear regression models for <var>Xres</var><var>Yres</var> on <var>Zc</var>, <var>Xres^2</var> on <var>Zc</var>, and <var>Yres^2</var> on <var>Zc</var>, and then uses the fitted values to compute the Pearson's correlation between <var>Xres</var> and <var>Yres</var> conditional on <var>Zc</var>.
Other options include &lsquo;<span class="samp">&#8288;kernel&#8288;</span>&rsquo;, which computes correlation between <var>Xres</var> and <var>Yres</var> conditional on <var>Zc</var> using a kernel weighted method, and &lsquo;<span class="samp">&#8288;stratification&#8288;</span>&rsquo;, which computes the correlation between <var>Xres</var> and <var>Yres</var> seperately for each value of <var>Zc</var>.</p>
</td></tr>
<tr><td><code id="conditional_Spearman_+3A_conditional.formula">conditional.formula</code></td>
<td>
<p>the formula to be used when &lsquo;<span class="samp">&#8288;conditional.method&#8288;</span>&rsquo; is specified as &lsquo;<span class="samp">&#8288;lm&#8288;</span>&rsquo;.</p>
</td></tr>
<tr><td><code id="conditional_Spearman_+3A_kernel.function">kernel.function</code></td>
<td>
<p>the kernel function to be used when &lsquo;<span class="samp">&#8288;conditional.method&#8288;</span>&rsquo; is specified as &lsquo;<span class="samp">&#8288;kernel&#8288;</span>&rsquo;. Defaults to &lsquo;<span class="samp">&#8288;normal&#8288;</span>&rsquo;. Other options are &lsquo;<span class="samp">&#8288;triweight&#8288;</span>&rsquo;, &lsquo;<span class="samp">&#8288;quartic&#8288;</span>&rsquo;, &lsquo;<span class="samp">&#8288;biweight&#8288;</span>&rsquo;, &lsquo;<span class="samp">&#8288;epanechnikov&#8288;</span>&rsquo;, &lsquo;<span class="samp">&#8288;uniform&#8288;</span>&rsquo;, and &lsquo;<span class="samp">&#8288;triangle&#8288;</span>&rsquo;.</p>
</td></tr>
<tr><td><code id="conditional_Spearman_+3A_kernel.bandwidth">kernel.bandwidth</code></td>
<td>
<p>the kernel bandwidth to be used when &lsquo;<span class="samp">&#8288;conditional.method&#8288;</span>&rsquo; is specified as &lsquo;<span class="samp">&#8288;kernel&#8288;</span>&rsquo;. The default value is calculated using Silverman' rule. Users can also specify a positive numeric value.</p>
</td></tr>
<tr><td><code id="conditional_Spearman_+3A_fit.x">fit.x</code>, <code id="conditional_Spearman_+3A_fit.y">fit.y</code></td>
<td>
<p>the fitting functions used for the model of <var>X</var> or <var>Y</var> on
<var>Z</var>.  The default function is &lsquo;<span class="samp">&#8288;orm&#8288;</span>&rsquo;, which fits cumulative link models for continuous or discrete ordinal variables. Other options include &lsquo;<span class="samp">&#8288;lm&#8288;</span>&rsquo; (fit linear regression models and obtain the probability-scale residuals by assuming normality),
&lsquo;<span class="samp">&#8288;lm.emp&#8288;</span>&rsquo; (fit linear regression and obtain the probability-scale residuals by empirical ranking),
&lsquo;<span class="samp">&#8288;poisson&#8288;</span>&rsquo; (fit Poisson models for count variables), &lsquo;<span class="samp">&#8288;nb&#8288;</span>&rsquo; (fit negative binomial models for count variables), and &lsquo;<span class="samp">&#8288;logistic&#8288;</span>&rsquo; (fit logistic regression models for binary variables).</p>
</td></tr>
<tr><td><code id="conditional_Spearman_+3A_link.x">link.x</code>, <code id="conditional_Spearman_+3A_link.y">link.y</code></td>
<td>
<p>the link family to be used for the ordinal model of
<var>X</var> on <var>Z</var>.  Defaults to &lsquo;<span class="samp">&#8288;logit&#8288;</span>&rsquo;. Other options are
&lsquo;<span class="samp">&#8288;probit&#8288;</span>&rsquo;, &lsquo;<span class="samp">&#8288;cloglog&#8288;</span>&rsquo;, &lsquo;<span class="samp">&#8288;cauchit&#8288;</span>&rsquo;, and &lsquo;<span class="samp">&#8288;logistic&#8288;</span>&rsquo; (equivalent with &lsquo;<span class="samp">&#8288;logit&#8288;</span>&rsquo;). Used only when
&lsquo;<span class="samp">&#8288;fit.x&#8288;</span>&rsquo; is &lsquo;<span class="samp">&#8288;orm&#8288;</span>&rsquo;.</p>
</td></tr>
<tr><td><code id="conditional_Spearman_+3A_subset">subset</code></td>
<td>
<p>an optional vector specifying a subset of
observations to be used in the fitting process.</p>
</td></tr>
<tr><td><code id="conditional_Spearman_+3A_na.action">na.action</code></td>
<td>
<p>action to take when <code>NA</code> present in data.</p>
</td></tr>
<tr><td><code id="conditional_Spearman_+3A_fisher">fisher</code></td>
<td>
<p>logical indicating whether to apply fisher transformation to compute confidence intervals and p-values for the correlation.</p>
</td></tr>
<tr><td><code id="conditional_Spearman_+3A_conf.int">conf.int</code></td>
<td>
<p>numeric specifying confidence interval coverage.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>To compute the partial Spearman's rank correlation between <var>X</var> and <var>Y</var> adjusting for <var>Z</var> conditional on <var>Zc</var>, &lsquo;<span class="samp">&#8288;formula&#8288;</span>&rsquo; is specified as <code><var>X</var> | <var>Y</var> ~ <var>Z</var></code> and &lsquo;<span class="samp">&#8288;conditional.by&#8288;</span>&rsquo; is specified as <var>Zc</var>.
This indicates that models of <code><var>X</var> ~ <var>Z</var></code> and <code><var>Y</var> ~ <var>Z</var></code> will be fit, and the correlation between the probability-scale residuals from these two models will be modeled conditional on <var>Zc</var>.
</p>


<h3>Value</h3>

<p>object of &lsquo;<span class="samp">&#8288;conditional_Spearman&#8288;</span>&rsquo; class.
</p>


<h3>References</h3>

<p>Li C and Shepherd BE (2012)
A new residual for ordinal outcomes.
<em>Biometrika</em>. <b>99</b>: 473&ndash;480.
</p>
<p>Shepherd BE, Li C, Liu Q (2016)
Probability-scale residuals for continuous, discrete, and censored data.
<em>The Canadian Jouranl of Statistics</em>. <b>44</b>:463&ndash;476.
</p>
<p>Liu Q, Shepherd BE, Wanga V, Li C (2018)
Covariate-Adjusted Spearman's Rank Correlation with Probability-Scale Residuals.
<em>Biometrics</em>. <b>74</b>:595&ndash;605.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+print.conditional_Spearman">print.conditional_Spearman</a></code>,<code><a href="#topic+print.conditional_Spearman">print.conditional_Spearman</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(PResidData)
library(rms)
#### fitting cumulative link models for both Y and W
result &lt;- conditional_Spearman(c|y~ x + w, conditional.by="w",
                                       conditional.method="lm", conditional.formula="~rcs(w)",
                                       fit.x="poisson",fit.y="orm",
                                       data=PResidData, fisher=TRUE)
plot(result)
</code></pre>

<hr>
<h2 id='corr'>Calculates the weighted correlation given a data set and a set of weights.</h2><span id='topic+corr'></span>

<h3>Description</h3>

<p>This is a copy of corr function from the boot package. It calculates the correlation coefficient in weighted form.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>corr(d, w = rep(1, nrow(d))/nrow(d))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="corr_+3A_d">d</code></td>
<td>
<p>a matrix with two columns corresponding to the two variables whose correlation we wish to calculate.</p>
</td></tr>
<tr><td><code id="corr_+3A_w">w</code></td>
<td>
<p>a vector of weights to be applied to each pair of observations. The default is equal weights for each pair. Normalization takes place within the function so sum(w) need not equal 1.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the correlation coefficient between d[,1] and d[,2].
</p>

<hr>
<h2 id='countbot'>Conditional count by ordinal tests for association.</h2><span id='topic+countbot'></span>

<h3>Description</h3>

<p><code>countbot</code> tests for independence between an ordered categorical
variable, <var>X</var>, and a count variable, <var>Y</var>, conditional on other variables,
<var>Z</var>.  The basic approach involves fitting an ordinal model of <var>X</var> on
<var>Z</var>, a Poisson or Negative Binomial model of <var>Y</var> on <var>Z</var>, and then determining whether there is any
residual information between <var>X</var> and <var>Y</var>.  This is done by
computing residuals for both models, calculating their correlation, and 
testing the null of no residual correlation.  This procedure is analogous to test statistic 
<code>T2</code> in <code>cobot</code>.  Two test statistics (correlations) are currently output.  The first
is the correlation between probability-scale residuals. The second is the correlation between 
the Pearson residual for the count outcome model and a latent variable residual
for the ordinal model (Li C and Shepherd BE, 2012).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>countbot(
  formula,
  data,
  link.x = c("logit", "probit", "loglog", "cloglog", "cauchit"),
  fit.y = c("poisson", "negative binomial"),
  subset,
  na.action = getOption("na.action"),
  fisher = TRUE,
  conf.int = 0.95
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="countbot_+3A_formula">formula</code></td>
<td>
<p>an object of class <code><a href="Formula.html#topic+Formula">Formula</a></code> (or one
that can be coerced to that class): a symbolic description of the
model to be fitted.  The details of model specification are given
under &lsquo;Details&rsquo;.</p>
</td></tr>
<tr><td><code id="countbot_+3A_data">data</code></td>
<td>
<p>an optional data frame, list or environment (or object
coercible by <code><a href="base.html#topic+as.data.frame">as.data.frame</a></code> to a data frame)
containing the variables in the model.  If not found in
<code>data</code>, the variables are taken from
<code>environment(formula)</code>, typically the environment from which
<code>countbot</code> is called.</p>
</td></tr>
<tr><td><code id="countbot_+3A_link.x">link.x</code></td>
<td>
<p>The link family to be used for the ordinal model of 
<var>X</var> on <var>Z</var>.  Defaults to &lsquo;<span class="samp">&#8288;logit&#8288;</span>&rsquo;. Other options are
&lsquo;<span class="samp">&#8288;probit&#8288;</span>&rsquo;, &lsquo;<span class="samp">&#8288;cloglog&#8288;</span>&rsquo;,&lsquo;<span class="samp">&#8288;loglog&#8288;</span>&rsquo;, and &lsquo;<span class="samp">&#8288;cauchit&#8288;</span>&rsquo;.</p>
</td></tr>
<tr><td><code id="countbot_+3A_fit.y">fit.y</code></td>
<td>
<p>The error distribution for the count model of <var>Y</var> on <var>Z</var>.
Defaults to &lsquo;<span class="samp">&#8288;poisson&#8288;</span>&rsquo;. The other option is &lsquo;<span class="samp">&#8288;negative binomial&#8288;</span>&rsquo;. 
If &lsquo;<span class="samp">&#8288;negative binomial&#8288;</span>&rsquo; is specified, <code><a href="MASS.html#topic+glm.nb">glm.nb</a></code> is called to fit the count model.</p>
</td></tr>
<tr><td><code id="countbot_+3A_subset">subset</code></td>
<td>
<p>an optional vector specifying a subset of
observations to be used in the fitting process.</p>
</td></tr>
<tr><td><code id="countbot_+3A_na.action">na.action</code></td>
<td>
<p>action to take when <code>NA</code> present in data.</p>
</td></tr>
<tr><td><code id="countbot_+3A_fisher">fisher</code></td>
<td>
<p>logical indicating whether to apply fisher transformation to compute confidence intervals and p-values for the correlation.</p>
</td></tr>
<tr><td><code id="countbot_+3A_conf.int">conf.int</code></td>
<td>
<p>numeric specifying confidence interval coverage.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Formula is specified as <code><var>X</var> | <var>Y</var> ~ <var>Z</var></code>.
This indicates that models of <code><var>X</var> ~ <var>Z</var></code> and
<code><var>Y</var> ~ <var>Z</var></code> will be fit.  The null hypothesis to be
tested is <code class="reqn">H_0 : X</code> independent of <var>Y</var> conditional
on <var>Z</var>.  The ordinal variable, <code><var>X</var></code>, must precede the <code>|</code> and be a factor variable, and <code><var>Y</var></code> must be an integer.
</p>


<h3>Value</h3>

<p>object of &lsquo;<span class="samp">&#8288;cocobot&#8288;</span>&rsquo; class.
</p>


<h3>References</h3>

<p>Li C and Shepherd BE (2012) 
A new residual for ordinal outcomes.
<em>Biometrika</em>. <b>99</b>: 473&ndash;480.
</p>
<p>Shepherd BE, Li C, Liu Q (2016)
Probability-scale residuals for continuous, discrete, and censored data.
<em>The Canadian Journal of Statistics</em>. <b>44</b>: 463&ndash;479.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(PResidData)
countbot(x|c ~z, fit.y="poisson",data=PResidData)
countbot(x|c ~z, fit.y="negative binomial",data=PResidData)
</code></pre>

<hr>
<h2 id='diagn'>Extract or construct a diagonal matrix.</h2><span id='topic+diagn'></span>

<h3>Description</h3>

<p>This works like <code><a href="base.html#topic+diag">diag</a></code> except when <code>x</code> is a single
integer value.  If <code>x</code> is a single integer value then it
assumes that you want a 1 by 1 matrix with the value set to <code>x</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>diagn(x = 1, nrow = length(x), ncol = nrow)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="diagn_+3A_x">x</code></td>
<td>
<p>a matrix, vector or 1D array, or missing.</p>
</td></tr>
<tr><td><code id="diagn_+3A_nrow">nrow</code>, <code id="diagn_+3A_ncol">ncol</code></td>
<td>
<p>optional dimensions for the result when <code>x</code> is not a matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix with diagonal elements set to <code>x</code>
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+diag">diag</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>diag(5)
diagn(5)
</code></pre>

<hr>
<h2 id='GKGamma'>Goodman-Kruskal's <code class="reqn">\gamma</code></h2><span id='topic+GKGamma'></span>

<h3>Description</h3>

<p>Computes Goodman-Kruskal's <code class="reqn">\gamma</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GKGamma(M)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GKGamma_+3A_m">M</code></td>
<td>
<p>a matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>scon</code></td>
<td>
<p>concordance</p>
</td></tr>
<tr><td><code>sdis</code></td>
<td>
<p>disconcordance</p>
</td></tr>
<tr><td><code>gamma</code></td>
<td>
<p>a real number between -1 and 1. calculated as
<code class="reqn">\code{gamma} = \frac{\code{scon}-\code{sdis}}{\code{scon}+\code{sdis}}</code></p>
</td></tr>
</table>


<h3>References</h3>

<p>Goodman LA, Kruskal WH (1954) Measures of association
for cross classifications, Journal of the American Statistical
Association, 49, 732-764.
</p>

<hr>
<h2 id='kernel.function'>kernel.function</h2><span id='topic+kernel.function'></span>

<h3>Description</h3>

<p><code>kernel.function</code> calculates several kernel functions (uniform, triangle, epanechnikov, biweight, triweight, gaussian).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kernel.function(u, kernel = "normal", product = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kernel.function_+3A_u">u</code></td>
<td>
<p>n x d matrix</p>
</td></tr>
<tr><td><code id="kernel.function_+3A_kernel">kernel</code></td>
<td>
<p>text string</p>
</td></tr>
<tr><td><code id="kernel.function_+3A_product">product</code></td>
<td>
<p>or spherical kernel if d&gt;1</p>
</td></tr>
</table>


<h3>Details</h3>

<p>slightly modified version of the kernel.function from the gplm package. The kernel parameter is a text string specifying the univariate kernel function which is either the gaussian pdf or proportional to (1-|u|^p)^q. Possible text strings are &quot;triangle&quot; (p=q=1), &quot;uniform&quot; (p=1, q=0), &quot;epanechnikov&quot; (p=2, q=1), &quot;biweight&quot; or &quot;quartic&quot; (p=q=2), &quot;triweight&quot; (p=2, q=3), &quot;gaussian&quot; or &quot;normal&quot; (gaussian pdf).
The multivariate kernels are obtained by a product of unvariate kernels K(u_1)...K(u_d) or by a spherical (radially symmetric) kernel proportional to K(||u||). (The resulting kernel is a density, i.e. integrates to 1.)
</p>


<h3>Value</h3>

<p>matrix with diagonal elements set to <code>x</code>
</p>

<hr>
<h2 id='megabot'>Conditional tests for association.</h2><span id='topic+megabot'></span>

<h3>Description</h3>

<p><code>megabot</code> tests for correlation between a variable, <var>X</var>, and another variable, <var>Y</var>,
conditional on other variables, <var>Z</var>.  The basic approach involves fitting an specified model of <var>X</var> on
<var>Z</var>, a specified model of <var>Y</var> on <var>Z</var>, and then determining whether there is any
remaining information between <var>X</var> and <var>Y</var>.  This is done by
computing residuals for both models, calculating their correlation, and 
testing the null of no residual correlation.  The test statistic output 
is the correlation between probability-scale residuals.  <var>X</var> and <var>Y</var> can
be continous or ordered discrete variables.  <code>megabot</code> replicates the functionality
of <code><a href="#topic+cobot">cobot</a></code>, <code><a href="#topic+cocobot">cocobot</a></code>, and <code><a href="#topic+countbot">countbot</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>megabot(
  formula,
  data,
  fit.x,
  fit.y,
  link.x = c("logit", "probit", "cloglog", "loglog", "cauchit", "logistic"),
  link.y = c("logit", "probit", "cloglog", "loglog", "cauchit", "logistic"),
  subset,
  na.action = getOption("na.action"),
  fisher = TRUE,
  conf.int = 0.95
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="megabot_+3A_formula">formula</code></td>
<td>
<p>an object of class <code><a href="Formula.html#topic+Formula">Formula</a></code> (or one
that can be coerced to that class): a symbolic description of the
model to be fitted.  The details of model specification are given
under &lsquo;Details&rsquo;.</p>
</td></tr>
<tr><td><code id="megabot_+3A_data">data</code></td>
<td>
<p>an optional data frame, list or environment (or object
coercible by <code><a href="base.html#topic+as.data.frame">as.data.frame</a></code> to a data frame)
containing the variables in the model.  If not found in
<code>data</code>, the variables are taken from
<code>environment(formula)</code>, typically the environment from which
<code>megabot</code> is called.</p>
</td></tr>
<tr><td><code id="megabot_+3A_fit.x">fit.x</code>, <code id="megabot_+3A_fit.y">fit.y</code></td>
<td>
<p>The fitting function used for the model of <var>X</var> or <var>Y</var> on
<var>Z</var>.  Options are &lsquo;<span class="samp">&#8288;ordinal&#8288;</span>&rsquo;, &lsquo;<span class="samp">&#8288;lm&#8288;</span>&rsquo;, &lsquo;<span class="samp">&#8288;lm.emp&#8288;</span>&rsquo;,
&lsquo;<span class="samp">&#8288;poisson&#8288;</span>&rsquo;, &lsquo;<span class="samp">&#8288;nb&#8288;</span>&rsquo;, and &lsquo;<span class="samp">&#8288;orm&#8288;</span>&rsquo;.</p>
</td></tr>
<tr><td><code id="megabot_+3A_link.x">link.x</code>, <code id="megabot_+3A_link.y">link.y</code></td>
<td>
<p>The link family to be used for the ordinal model of 
<var>X</var> on <var>Z</var>.  Defaults to &lsquo;<span class="samp">&#8288;logit&#8288;</span>&rsquo;. Other options are
&lsquo;<span class="samp">&#8288;probit&#8288;</span>&rsquo;, &lsquo;<span class="samp">&#8288;cloglog&#8288;</span>&rsquo;,&lsquo;<span class="samp">&#8288;loglog&#8288;</span>&rsquo;, &lsquo;<span class="samp">&#8288;cauchit&#8288;</span>&rsquo;, and &lsquo;<span class="samp">&#8288;logistic&#8288;</span>&rsquo;(equivalent with &lsquo;<span class="samp">&#8288;logit&#8288;</span>&rsquo;). Used only when
&lsquo;<span class="samp">&#8288;fit.x&#8288;</span>&rsquo; is either &lsquo;<span class="samp">&#8288;ordinal&#8288;</span>&rsquo; or &lsquo;<span class="samp">&#8288;orm&#8288;</span>&rsquo;.</p>
</td></tr>
<tr><td><code id="megabot_+3A_subset">subset</code></td>
<td>
<p>an optional vector specifying a subset of
observations to be used in the fitting process.</p>
</td></tr>
<tr><td><code id="megabot_+3A_na.action">na.action</code></td>
<td>
<p>action to take when <code>NA</code> present in data.</p>
</td></tr>
<tr><td><code id="megabot_+3A_fisher">fisher</code></td>
<td>
<p>logical indicating whether to apply fisher transformation to compute confidence intervals and p-values for the correlation.</p>
</td></tr>
<tr><td><code id="megabot_+3A_conf.int">conf.int</code></td>
<td>
<p>numeric specifying confidence interval coverage.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Formula is specified as <code><var>X</var> | <var>Y</var> ~ <var>Z</var></code>.
This indicates that models of <code><var>X</var> ~ <var>Z</var></code> and
<code><var>Y</var> ~ <var>Z</var></code> will be fit.  The null hypothesis to be
tested is <code class="reqn">H_0 : X</code> independent of <var>Y</var> conditional
on <var>Z</var>.
</p>


<h3>Value</h3>

<p>object of &lsquo;<span class="samp">&#8288;cocobot&#8288;</span>&rsquo; class.
</p>


<h3>References</h3>

<p>Li C and Shepherd BE (2012) 
A new residual for ordinal outcomes.
<em>Biometrika</em>. <b>99</b>: 473&ndash;480.
</p>
<p>Shepherd BE, Li C, Liu Q (2016)
Probability-scale residuals for continuous, discrete, and censored data.
<em>The Canadian Journal of Statistics</em>. <b>44</b>: 463&ndash;479.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(PResidData)
megabot(y|w ~ z, fit.x="ordinal", fit.y="lm.emp", data=PResidData)
</code></pre>

<hr>
<h2 id='newpolr'>slightly modified version of polr from MASS</h2><span id='topic+newpolr'></span>

<h3>Description</h3>

<p>slightly modified version of polr from MASS
</p>


<h3>Usage</h3>

<pre><code class='language-R'>newpolr(
  formula,
  data,
  weights,
  start,
  ...,
  subset,
  na.action,
  contrasts = NULL,
  Hess = FALSE,
  model = TRUE,
  method = c("logit", "probit", "cloglog", "loglog", "cauchit")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="newpolr_+3A_formula">formula</code></td>
<td>
<p>a formula</p>
</td></tr>
<tr><td><code id="newpolr_+3A_data">data</code></td>
<td>
<p>an optional data frame, list or environment (or object coercible
by <code><a href="base.html#topic+as.data.frame">as.data.frame</a></code> to a data frame) containing the variables in
the model.  If not found in <code>data</code>, the variables are taken from
<code>environment(formula)</code>, typically the environment from which
<code>cobot</code> is called.</p>
</td></tr>
<tr><td><code id="newpolr_+3A_weights">weights</code></td>
<td>
<p>optional case weights in fitting.  Default to 1.</p>
</td></tr>
<tr><td><code id="newpolr_+3A_start">start</code></td>
<td>
<p>initial values for the parameters.</p>
</td></tr>
<tr><td><code id="newpolr_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to <code><a href="stats.html#topic+optim">optim</a></code>, most
often a <code>control</code> argument.</p>
</td></tr>
<tr><td><code id="newpolr_+3A_subset">subset</code></td>
<td>
<p>an optional vector specifying a subset of observations to be
used in the fitting process.</p>
</td></tr>
<tr><td><code id="newpolr_+3A_na.action">na.action</code></td>
<td>
<p>a function which indicates what should happen when the data
contain <code>NA</code>s.  The default is is <code><a href="stats.html#topic+na.fail">na.fail</a></code>.  Another
possible value is <code>NULL</code>, no action.  Value <code><a href="stats.html#topic+na.exclude">na.exclude</a></code> can
be useful.</p>
</td></tr>
<tr><td><code id="newpolr_+3A_contrasts">contrasts</code></td>
<td>
<p>a list of contrasts to be used for some or all of the
factors appearing as variables in the model formula.</p>
</td></tr>
<tr><td><code id="newpolr_+3A_hess">Hess</code></td>
<td>
<p>logical for whether the Hessian (the observed information matrix)
should be returned.  Use this if you intend to call <code><a href="base.html#topic+summary">summary</a></code> or
<code><a href="stats.html#topic+vcov">vcov</a></code> on the fit.</p>
</td></tr>
<tr><td><code id="newpolr_+3A_model">model</code></td>
<td>
<p>logical for whether the model matrix should be returned.</p>
</td></tr>
<tr><td><code id="newpolr_+3A_method">method</code></td>
<td>
<p>logistic or probit or complementary log-log, loglog,  or cauchit
(corresponding to a Cauchy latent variable).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A object of class <code>"polr"</code>.  This has components
</p>
<table>
<tr><td><code>coefficients</code></td>
<td>
<p>the coefficients of the linear predictor, which has no
intercept.</p>
</td></tr>
<tr><td><code>zeta</code></td>
<td>
<p>the intercepts for the class boundaries.</p>
</td></tr>
<tr><td><code>deviance</code></td>
<td>
<p>the residual deviance.</p>
</td></tr>
<tr><td><code>fitted.values</code></td>
<td>
<p>a matrix, with a column for each level of the response.</p>
</td></tr>
<tr><td><code>lev</code></td>
<td>
<p>the names of the response levels.</p>
</td></tr>
<tr><td><code>terms</code></td>
<td>
<p>the <code>terms</code> structure describing the model.</p>
</td></tr>
<tr><td><code>df.residual</code></td>
<td>
<p>the number of residual degrees of freedoms, calculated
using the weights.</p>
</td></tr>
<tr><td><code>edf</code></td>
<td>
<p>the (effective) number of degrees of freedom used by the model</p>
</td></tr>
<tr><td><code>n</code>, <code>nobs</code></td>
<td>
<p>the (effective) number of observations, calculated using the
weights. (<code>nobs</code> is for use by <code><a href="MASS.html#topic+stepAIC">stepAIC</a></code>).</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>the matched call.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>the matched method used.</p>
</td></tr>
<tr><td><code>convergence</code></td>
<td>
<p>the convergence code returned by <code>optim</code>.</p>
</td></tr>
<tr><td><code>niter</code></td>
<td>
<p>the number of function and gradient evaluations used by
<code><a href="stats.html#topic+optim">optim</a></code>.</p>
</td></tr>
<tr><td><code>lp</code></td>
<td>
<p>the linear predictor (including any offset).</p>
</td></tr>
<tr><td><code>Hessian</code></td>
<td>
<p>(if <code>Hess</code> is true).  Note that this is a numerical
approximation derived from the optimization proces.</p>
</td></tr>
<tr><td><code>model</code></td>
<td>
<p>(if <code>model</code> is true).</p>
</td></tr>
</table>


<h3>References</h3>

<p>polr from MASS
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+optim">optim</a></code>, <code><a href="stats.html#topic+glm">glm</a></code>, <code><a href="nnet.html#topic+multinom">multinom</a></code>
</p>

<hr>
<h2 id='partial_Spearman'>Partial Spearman's Rank Correlation</h2><span id='topic+partial_Spearman'></span>

<h3>Description</h3>

<p><code>partial_Spearman</code> computes the partial Spearman's rank correlation between variable <var>X</var> and variable <var>Y</var> adjusting for other variables, <var>Z</var>.
The basic approach involves fitting a specified model of <var>X</var> on <var>Z</var>, a specified model of <var>Y</var> on <var>Z</var>, obtaining the probability-scale residuals from both models, and then calculating their Pearson's correlation.
<var>X</var> and <var>Y</var> can be any orderable variables, including continuous or discrete variables.
By default, <code>partial_Spearman</code> uses cumulative probability models (also referred as cumulative link models in literature) for both <var>X</var> on <var>Z</var> and <var>Y</var> on <var>Z</var> to preserve the rank-based nature of Spearman's correlation, since the model fit of cumulative probability models only depends on the order information of variables. However, for some specific types of variables, options of fitting parametric models are also available. See details in fit.x and fit.y
</p>


<h3>Usage</h3>

<pre><code class='language-R'>partial_Spearman(
  formula,
  data,
  fit.x = "orm",
  fit.y = "orm",
  link.x = c("logit", "probit", "cloglog", "loglog", "cauchit", "logistic"),
  link.y = c("logit", "probit", "cloglog", "loglog", "cauchit", "logistic"),
  subset,
  na.action = getOption("na.action"),
  fisher = TRUE,
  conf.int = 0.95
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="partial_Spearman_+3A_formula">formula</code></td>
<td>
<p>an object of class <code><a href="Formula.html#topic+Formula">Formula</a></code> (or one
that can be coerced to that class): a symbolic description of the
model to be fitted.  The details of model specification are given
under &lsquo;Details&rsquo;.</p>
</td></tr>
<tr><td><code id="partial_Spearman_+3A_data">data</code></td>
<td>
<p>an optional data frame, list or environment (or object
coercible by <code><a href="base.html#topic+as.data.frame">as.data.frame</a></code> to a data frame)
containing the variables in the model.  If not found in
<code>data</code>, the variables are taken from
<code>environment(formula)</code>, typically the environment from which
<code>partial_Spearman</code> is called.</p>
</td></tr>
<tr><td><code id="partial_Spearman_+3A_fit.x">fit.x</code>, <code id="partial_Spearman_+3A_fit.y">fit.y</code></td>
<td>
<p>the fitting functions used for the models of X or Y on Z.
The default function is &lsquo;<span class="samp">&#8288;orm&#8288;</span>&rsquo;, which fits cumulative probability models for continuous or discrete ordinal variables. Other options include &lsquo;<span class="samp">&#8288;lm&#8288;</span>&rsquo;, which fits linear regression models and obtains the probability-scale residuals by assuming normality;
&lsquo;<span class="samp">&#8288;lm.emp&#8288;</span>&rsquo;, which fits linear regression models and obtains the probability-scale residuals by empirical ranking;
&lsquo;<span class="samp">&#8288;poisson&#8288;</span>&rsquo;, which fits Poisson models for count variables; &lsquo;<span class="samp">&#8288;nb&#8288;</span>&rsquo;, which fits negative binomial models for count variables; and &lsquo;<span class="samp">&#8288;logistic&#8288;</span>&rsquo;, which fits logistic regression models for binary variables.</p>
</td></tr>
<tr><td><code id="partial_Spearman_+3A_link.x">link.x</code>, <code id="partial_Spearman_+3A_link.y">link.y</code></td>
<td>
<p>the link family to be used for the ordinal model of
<var>X</var> on <var>Z</var>.  Defaults to &lsquo;<span class="samp">&#8288;logit&#8288;</span>&rsquo;. Other options are
&lsquo;<span class="samp">&#8288;probit&#8288;</span>&rsquo;, &lsquo;<span class="samp">&#8288;cloglog&#8288;</span>&rsquo;, &lsquo;<span class="samp">&#8288;loglog&#8288;</span>&rsquo;, &lsquo;<span class="samp">&#8288;cauchit&#8288;</span>&rsquo; and &lsquo;<span class="samp">&#8288;logistic&#8288;</span>&rsquo; (equivalent with &lsquo;<span class="samp">&#8288;logit&#8288;</span>&rsquo;). Used only when
&lsquo;<span class="samp">&#8288;fit.x&#8288;</span>&rsquo; is &lsquo;<span class="samp">&#8288;orm&#8288;</span>&rsquo;.</p>
</td></tr>
<tr><td><code id="partial_Spearman_+3A_subset">subset</code></td>
<td>
<p>an optional vector specifying a subset of
observations to be used in the fitting process.</p>
</td></tr>
<tr><td><code id="partial_Spearman_+3A_na.action">na.action</code></td>
<td>
<p>action to take when <code>NA</code> present in data.</p>
</td></tr>
<tr><td><code id="partial_Spearman_+3A_fisher">fisher</code></td>
<td>
<p>logical indicating whether to apply fisher transformation to compute confidence intervals and p-values for the correlation.</p>
</td></tr>
<tr><td><code id="partial_Spearman_+3A_conf.int">conf.int</code></td>
<td>
<p>numeric specifying confidence interval coverage.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>To compute the partial Spearman's rank correlation between <var>X</var> and <var>Y</var> adjusting for <var>Z</var>, &lsquo;<span class="samp">&#8288;formula&#8288;</span>&rsquo; is specified as <code><var>X</var> | <var>Y</var> ~ <var>Z</var></code>.
This indicates that models of <code><var>X</var> ~ <var>Z</var></code> and
<code><var>Y</var> ~ <var>Z</var></code> will be fit.
</p>


<h3>Value</h3>

<p>object of &lsquo;<span class="samp">&#8288;partial_Spearman&#8288;</span>&rsquo; class.
</p>


<h3>References</h3>

<p>Li C and Shepherd BE (2012)
A new residual for ordinal outcomes.
<em>Biometrika</em>. <b>99</b>: 473&ndash;480.
</p>
<p>Shepherd BE, Li C, Liu Q (2016)
Probability-scale residuals for continuous, discrete, and censored data.
<em>The Canadian Jouranl of Statistics</em>. <b>44</b>:463&ndash;476.
</p>
<p>Liu Q, Shepherd BE, Wanga V, Li C (2018)
Covariate-Adjusted Spearman's Rank Correlation with Probability-Scale Residuals.
<em>Biometrics</em>. <b>74</b>:595&ndash;605.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+print.partial_Spearman">print.partial_Spearman</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(PResidData)
#### fitting cumulative probability models for both Y and W
partial_Spearman(c|w ~ z,data=PResidData)
#### fitting a cumulative probability model for W and a poisson model for c
partial_Spearman(c|w~z, fit.x="poisson",data=PResidData)
partial_Spearman(c|w~z, fit.x="poisson", fit.y="lm.emp", data=PResidData )
</code></pre>

<hr>
<h2 id='plot.conditional_Spearman'>conditional_Spearman class plot method</h2><span id='topic+plot.conditional_Spearman'></span>

<h3>Description</h3>

<p>conditional_Spearman class plot method
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'conditional_Spearman'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.conditional_Spearman_+3A_x">x</code></td>
<td>
<p>conditional_Spearman object</p>
</td></tr>
<tr><td><code id="plot.conditional_Spearman_+3A_...">...</code></td>
<td>
<p>arguments passed to plot.default</p>
</td></tr>
</table>

<hr>
<h2 id='presid'>Probability-scale residual</h2><span id='topic+presid'></span>

<h3>Description</h3>

<p><code>presid</code> calculates the probability-scale residual for various model
function objects. Currently supported models include <code><a href="stats.html#topic+glm">glm</a></code>
(Poisson, binomial, and gaussian families), <code><a href="stats.html#topic+lm">lm</a></code> in the
<span class="pkg">stats</span> library; <code><a href="survival.html#topic+survreg">survreg</a></code> (Weibull, exponential, gaussian,
logistic, and lognormal distributions) and <code><a href="survival.html#topic+coxph">coxph</a></code> in the
<span class="pkg">survival</span> library; <code><a href="MASS.html#topic+polr">polr</a></code> and <code><a href="MASS.html#topic+glm.nb">glm.nb</a></code> in
the <span class="pkg">MASS</span> library; and <code><a href="rms.html#topic+ols">ols</a></code>, <code><a href="rms.html#topic+cph">cph</a></code>,
<code><a href="rms.html#topic+lrm">lrm</a></code>, <code><a href="rms.html#topic+orm">orm</a></code>, <code><a href="rms.html#topic+psm">psm</a></code>, and <code><a href="rms.html#topic+Glm">Glm</a></code>
in the <span class="pkg">rms</span> library.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>presid(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="presid_+3A_object">object</code></td>
<td>
<p>The model object for which the probability-scale residual is calculated</p>
</td></tr>
<tr><td><code id="presid_+3A_...">...</code></td>
<td>
<p>Additional arguements passed to methods</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Probability-scale residual is <code class="reqn">P(Y &lt; y) - P(Y &gt; y)</code> where <code class="reqn">y</code> is the observed
outcome and <code class="reqn">Y</code> is a random variable from the fitted distribution.
</p>


<h3>Value</h3>

<p>The probability-scale residual for the model
</p>


<h3>References</h3>

<p>Shepherd BE, Li C, Liu Q (2016)
Probability-scale residuals for continuous, discrete, and censored data.
<em>The Canadian Jouranl of Statistics</em>. <b>44</b>:463&ndash;476.
</p>
<p>Li C and Shepherd BE (2012)
A new residual for ordinal outcomes.
<em>Biometrika</em>. <b>99</b>: 473&ndash;480.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(survival)
library(stats)

set.seed(100)
n &lt;- 1000
x &lt;- rnorm(n)
t &lt;- rweibull(n, shape=1/3, scale=exp(x))
c &lt;- rexp(n, 1/3)
y &lt;- pmin(t, c)
d &lt;- ifelse(t&lt;=c, 1, 0)

mod.survreg &lt;- survreg(Surv(y, d) ~ x, dist="weibull")
summary(presid(mod.survreg))
plot(x, presid(mod.survreg))

##### example for proprotional hazards model
n &lt;- 1000
x &lt;- rnorm(n)
beta0 &lt;- 1
beta1 &lt;- 0.5
t &lt;- rexp(n, rate = exp(beta0 + beta1*x))
c &lt;- rexp(n, rate=1)
y &lt;- ifelse(t&lt;c, t, c)
delta &lt;- as.integer(t&lt;c)

mod.coxph &lt;- coxph(Surv(y, delta) ~ x)
presid &lt;- presid(mod.coxph)
plot(x, presid, cex=0.4, col=delta+2)

#### example for Negative Binomial regression
library(MASS)

n &lt;- 1000
beta0 &lt;- 1
beta1 &lt;- 0.5
x &lt;- runif(n, min=-3, max=3)
y &lt;- rnbinom(n, mu=exp(beta0 + beta1*x), size=3)

mod.glm.nb &lt;- glm.nb(y~x)
presid &lt;- presid(mod.glm.nb)
summary(presid)
plot(x, presid, cex=0.4)

##### example for proportional odds model
library(MASS)

n &lt;- 1000
x  &lt;- rnorm(n)
y  &lt;- numeric(n)
alpha = c(-1, 0, 1, 2)
beta &lt;- 1
py  &lt;-  (1 + exp(- outer(alpha, beta*x, "+"))) ^ (-1)
aa = runif(n)
for(i in 1:n)
  y[i] = sum(aa[i] &gt; py[,i])
y &lt;-  as.factor(y)


mod.polr &lt;- polr(y~x, method="logistic")
summary(mod.polr)
presid &lt;- presid(mod.polr)
summary(presid)
plot(x, presid, cex=0.4)
</code></pre>

<hr>
<h2 id='PResidData'>Example Dataset for PResiduals Package</h2><span id='topic+PResidData'></span>

<h3>Description</h3>

<p>This is a dataset used in Examples Section of PResiduals package help files.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PResidData
</code></pre>


<h3>Format</h3>

<p>A data frame with 200 rows and 5 variables:
</p>

<dl>
<dt>x</dt><dd><p>an ordered categorical variable with 5 levels</p>
</dd>
<dt>y</dt><dd><p>an ordered categorical variable with 4 levels</p>
</dd>
<dt>z</dt><dd><p>a continuous variable</p>
</dd>
<dt>w</dt><dd><p>a continuous variable</p>
</dd>
<dt>c</dt><dd><p>a count variable</p>
</dd>
</dl>



<h3>Source</h3>

<p>Simulated
</p>

<hr>
<h2 id='PResiduals-package'>Computes probability-scale residuals and residual correlations.</h2><span id='topic+PResiduals-package'></span><span id='topic+PResiduals'></span>

<h3>Description</h3>

<p>This package outputs probability-scale residuals from multiple
models and computes residual correlation.  Probability-scale
residual can be computed for continuous, ordinal, binary, count,
and time-to-event data (although the current implementation is only
for ordinal variables). Plots of probability-scale residuals can be
useful for model diagnostics.  Residual correlation can be used to
test for conditional independence between multiple types of
variables.
</p>


<h3>Author(s)</h3>

<p>Bryan Shepherd <a href="mailto:bryan.shepherd@vanderbilt.edu">bryan.shepherd@vanderbilt.edu</a>
</p>
<p>Chun Li <a href="mailto:cxl791@case.edu">cxl791@case.edu</a>
</p>
<p>Qi Liu <a href="mailto:qi.liu4@merck.com">qi.liu4@merck.com</a>
</p>
<p>Charles Dupont <a href="mailto:charles.dupont@vanderbilt.edu">charles.dupont@vanderbilt.edu</a>
</p>
<p>Jeffrey Horner <a href="mailto:jeffrey.horner@vanderbilt.edu">jeffrey.horner@vanderbilt.edu</a>
</p>

<hr>
<h2 id='print.cobot'>cobot class print method</h2><span id='topic+print.cobot'></span>

<h3>Description</h3>

<p>cobot class print method
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cobot'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.cobot_+3A_x">x</code></td>
<td>
<p>cobot object</p>
</td></tr>
<tr><td><code id="print.cobot_+3A_...">...</code></td>
<td>
<p>arguments passed to print.default</p>
</td></tr>
</table>

<hr>
<h2 id='print.cocobot'>cocobot class print method</h2><span id='topic+print.cocobot'></span>

<h3>Description</h3>

<p>cocobot class print method
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cocobot'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.cocobot_+3A_x">x</code></td>
<td>
<p>cocobot object</p>
</td></tr>
<tr><td><code id="print.cocobot_+3A_...">...</code></td>
<td>
<p>arguments passed to print.default</p>
</td></tr>
</table>

<hr>
<h2 id='print.conditional_Spearman'>conditional_Spearman class print method</h2><span id='topic+print.conditional_Spearman'></span>

<h3>Description</h3>

<p>conditional_Spearman class print method
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'conditional_Spearman'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.conditional_Spearman_+3A_x">x</code></td>
<td>
<p>conditional_Spearman object</p>
</td></tr>
<tr><td><code id="print.conditional_Spearman_+3A_...">...</code></td>
<td>
<p>arguments passed to print.default</p>
</td></tr>
</table>

<hr>
<h2 id='print.partial_Spearman'>partial_Spearman class print method</h2><span id='topic+print.partial_Spearman'></span>

<h3>Description</h3>

<p>partial_Spearman class print method
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'partial_Spearman'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.partial_Spearman_+3A_x">x</code></td>
<td>
<p>partial_Spearman object</p>
</td></tr>
<tr><td><code id="print.partial_Spearman_+3A_...">...</code></td>
<td>
<p>arguments passed to print.default</p>
</td></tr>
</table>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
