<!DOCTYPE html><html lang="en"><head><title>Help for package mpath</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {mpath}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#be.zeroinfl'><p>conduct backward stepwise variable elimination for zero inflated count regression</p></a></li>
<li><a href='#breadReg'><p>Bread for Sandwiches in Regularized Estimators</p></a></li>
<li><a href='#breastfeed'><p> Breast feeding decision</p></a></li>
<li><a href='#compute_g'><p>Compute concave function values</p></a></li>
<li><a href='#compute_wt'><p>Weight value from concave function</p></a></li>
<li><a href='#conv2glmreg'><p>convert glm object to class glmreg</p></a></li>
<li><a href='#conv2zipath'><p>convert zeroinfl object to class zipath</p></a></li>
<li><a href='#cv.glmreg'><p>Cross-validation for glmreg</p></a></li>
<li><a href='#cv.glmreg_fit'><p>Internal function of cross-validation for glmreg</p></a></li>
<li><a href='#cv.glmregNB'><p>Cross-validation for glmregNB</p></a></li>
<li><a href='#cv.irglmreg'><p>Cross-validation for irglmreg</p></a></li>
<li><a href='#cv.irglmreg_fit'><p>Internal function of cross-validation for irglmreg</p></a></li>
<li><a href='#cv.irsvm'><p>Cross-validation for irsvm</p></a></li>
<li><a href='#cv.irsvm_fit'><p>Internal function of cross-validation for irsvm</p></a></li>
<li><a href='#cv.nclreg'><p>Cross-validation for nclreg</p></a></li>
<li><a href='#cv.nclreg_fit'><p>Internal function of cross-validation for nclreg</p></a></li>
<li><a href='#cv.zipath'><p>Cross-validation for zipath</p></a></li>
<li><a href='#cv.zipath_fit'><p>Cross-validation for zipath</p></a></li>
<li><a href='#docvisits'><p> Doctor visits</p></a></li>
<li><a href='#estfunReg'><p>Extract Empirical First Derivative of Log-likelihood Function</p></a></li>
<li><a href='#gfunc'><p>Convert response value to raw prediction in GLM</p></a></li>
<li><a href='#glmreg'><p>fit a GLM with lasso (or elastic net), snet or mnet regularization</p></a></li>
<li><a href='#glmreg_fit'><p>Internal function to fit a GLM with lasso (or elastic net), snet and mnet regularization</p></a></li>
<li><a href='#glmregNB'><p>fit a negative binomial model with lasso (or elastic net), snet and mnet regularization</p></a></li>
<li><a href='#hessianReg'><p>Hessian Matrix of Regularized Estimators</p></a></li>
<li><a href='#irglm'><p>fit a robust generalized linear models</p></a></li>
<li><a href='#irglmreg'><p>Fit a robust penalized generalized linear models</p></a></li>
<li><a href='#irglmreg_fit'><p>Internal function for robust penalized generalized linear models</p></a></li>
<li><a href='#irsvm'><p>fit case weighted support vector machines with robust loss functions</p></a></li>
<li><a href='#irsvm_fit'><p>Fit iteratively reweighted support vector machines for robust loss functions</p></a></li>
<li><a href='#loss2'><p>Composite Loss Value</p></a></li>
<li><a href='#loss2_irsvm'><p>Composite Loss Value for epsilon-insensitive Type</p></a></li>
<li><a href='#loss3'><p>Composite Loss Value for GLM</p></a></li>
<li><a href='#meatReg'><p>Meat Matrix Estimator</p></a></li>
<li><a href='#methods'><p> Methods for mpath Objects</p></a></li>
<li><a href='#mpath-internal'><p>Internal mpath functions</p></a></li>
<li><a href='#ncl'><p>fit a nonconvex loss based robust linear model</p></a></li>
<li><a href='#ncl_fit'><p>Internal function to fit a nonconvex loss based robust linear model</p></a></li>
<li><a href='#nclreg'><p>Optimize a nonconvex loss with regularization</p></a></li>
<li><a href='#nclreg_fit'><p>Internal function to fitting a nonconvex loss based robust linear model with regularization</p></a></li>
<li><a href='#plot.glmreg'><p>plot coefficients from a &quot;glmreg&quot; object</p></a></li>
<li><a href='#predict.glmreg'><p>Model predictions based on a fitted &quot;glmreg&quot; object.</p></a></li>
<li><a href='#predict.zipath'><p>Methods for zipath Objects</p></a></li>
<li><a href='#pval.zipath'><p>compute p-values from penalized zero-inflated model with multi-split data</p></a></li>
<li><a href='#rzi'><p>random number generation of zero-inflated count response</p></a></li>
<li><a href='#sandwichReg'><p>Making Sandwiches with Bread and Meat for Regularized Estimators</p></a></li>
<li><a href='#se'><p>Standard Error of Regularized Estimators</p></a></li>
<li><a href='#stan'><p>standardize variables</p></a></li>
<li><a href='#summary.glmregNB'>
<p>Summary Method Function for Objects of Class 'glmregNB'</p></a></li>
<li><a href='#tuning.zipath'><p>find optimal path for penalized zero-inflated model</p></a></li>
<li><a href='#update_wt'><p>Compute weight value</p></a></li>
<li><a href='#zipath'><p>Fit zero-inflated count data linear model with lasso (or elastic net), snet or mnet regularization</p></a></li>
<li><a href='#zipath_fit'><p>Internal function to fit zero-inflated count data linear model with lasso (or elastic net), snet or mnet regularization</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Regularized Linear Models</td>
</tr>
<tr>
<td>Version:</td>
<td>0.4-2.26</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-06-27</td>
</tr>
<tr>
<td>Author:</td>
<td>Zhu Wang, with contributions from Achim Zeileis, Simon Jackman, Brian Ripley, and Patrick Breheny</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Zhu Wang &lt;zwang145@uthsc.edu&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Algorithms compute robust estimators for loss functions in the concave convex (CC) family by the iteratively reweighted convex optimization (IRCO), an extension of the iteratively reweighted least squares (IRLS). The IRCO reduces the weight of the observation that leads to a large loss; it also provides weights to help identify outliers. Applications include robust (penalized) generalized linear models and robust support vector machines. The package also contains penalized Poisson, negative binomial, zero-inflated Poisson, zero-inflated negative binomial regression models and robust models with non-convex loss functions. Wang et al. (2014) &lt;<a href="https://doi.org/10.1002%2Fsim.6314">doi:10.1002/sim.6314</a>&gt;,
      Wang et al. (2015) &lt;<a href="https://doi.org/10.1002%2Fbimj.201400143">doi:10.1002/bimj.201400143</a>&gt;,
      Wang et al. (2016) &lt;<a href="https://doi.org/10.1177%2F0962280214530608">doi:10.1177/0962280214530608</a>&gt;,
      Wang (2021) &lt;<a href="https://doi.org/10.1007%2Fs11749-021-00770-2">doi:10.1007/s11749-021-00770-2</a>&gt;,
      Wang (2024) &lt;<a href="https://doi.org/10.1111%2Fanzs.12409">doi:10.1111/anzs.12409</a>&gt;.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0), methods, glmnet</td>
</tr>
<tr>
<td>Imports:</td>
<td>MASS, pscl, numDeriv, foreach, doParallel, bst, WeightSVM</td>
</tr>
<tr>
<td>Suggests:</td>
<td>zic, R.rsp, knitr, rmarkdown, openxlsx, e1071, SparseM, slam</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>R.rsp, knitr</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/zhuwang46/mpath">https://github.com/zhuwang46/mpath</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/zhuwang46/mpath">https://github.com/zhuwang46/mpath</a></td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-06-27 20:57:41 UTC; zhu</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-06-27 22:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='be.zeroinfl'>conduct backward stepwise variable elimination for zero inflated count regression</h2><span id='topic+be.zeroinfl'></span>

<h3>Description</h3>

<p>conduct backward stepwise variable elimination for zero inflated count regression from zeroinfl function</p>


<h3>Usage</h3>

<pre><code class='language-R'>be.zeroinfl(object, data, dist=c("poisson", "negbin", "geometric"), alpha=0.05, 
            trace=FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="be.zeroinfl_+3A_object">object</code></td>
<td>
<p>an object from function zeroinfl</p>
</td></tr>
<tr><td><code id="be.zeroinfl_+3A_data">data</code></td>
<td>
<p>argument controlling formula processing
via <code><a href="stats.html#topic+model.frame">model.frame</a></code>.</p>
</td></tr>
<tr><td><code id="be.zeroinfl_+3A_dist">dist</code></td>
<td>
<p>one of the distributions in zeroinfl function</p>
</td></tr>
<tr><td><code id="be.zeroinfl_+3A_alpha">alpha</code></td>
<td>
<p>significance level of variable elimination</p>
</td></tr>
<tr><td><code id="be.zeroinfl_+3A_trace">trace</code></td>
<td>
<p>logical value, if TRUE, print detailed calculation results</p>
</td></tr>
</table>


<h3>Details</h3>

<p>conduct backward stepwise variable elimination for zero inflated count regression from zeroinfl function</p>


<h3>Value</h3>

<p>an object of zeroinfl with all variables having p-values less than the significance level <code>alpha</code></p>


<h3>Author(s)</h3>

<p>Zhu Wang &lt;zwang145@uthsc.edu&gt;</p>


<h3>References</h3>

<p>Zhu Wang, Shuangge Ma, Ching-Yun Wang, Michael Zappitelli, Prasad Devarajan and Chirag R. Parikh (2014)
<em>EM for Regularized Zero Inflated Regression Models with Applications to Postoperative Morbidity after Cardiac Surgery in Children</em>, <em>Statistics in Medicine</em>. 33(29):5192-208.
</p>
<p>Zhu Wang, Shuangge Ma and Ching-Yun Wang (2015) <em>Variable selection for zero-inflated and overdispersed data with application to health care demand in Germany</em>, <em>Biometrical Journal</em>. 57(5):867-84.
</p>

<hr>
<h2 id='breadReg'>Bread for Sandwiches in Regularized Estimators</h2><span id='topic+breadReg'></span><span id='topic+breadReg.zipath'></span>

<h3>Description</h3>

<p>Generic function for extracting an estimator for the bread of
sandwiches.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>breadReg(x, which, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="breadReg_+3A_x">x</code></td>
<td>
<p>a fitted model object.</p>
</td></tr>
<tr><td><code id="breadReg_+3A_which">which</code></td>
<td>
<p>which penalty parameter(s)?</p>
</td></tr>
<tr><td><code id="breadReg_+3A_...">...</code></td>
<td>
<p>arguments passed to methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix containing an estimator for the penalized second derivative of log-likelihood function.
Typically, this should be an <code class="reqn">k \times k</code> matrix corresponding
to <code class="reqn">k</code> parameters. The rows and columns should be named
as in <code><a href="stats.html#topic+coef">coef</a></code> or <code><a href="stats.html#topic+terms">terms</a></code>, respectively.</p>


<h3>Author(s)</h3>

<p>Zhu Wang &lt;zwang145@uthsc.edu&gt;</p>


<h3>References</h3>

<p>Zhu Wang, Shuangge Ma and Ching-Yun Wang (2015) <em>Variable selection for zero-inflated and overdispersed data with application to health care demand in Germany</em>, <em>Biometrical Journal</em>. 57(5):867-84.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+meatReg">meatReg</a></code>, <code><a href="#topic+sandwichReg">sandwichReg</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data("bioChemists", package = "pscl")
fm_zinb &lt;- zipath(art ~ . | ., data = bioChemists, family = "negbin", nlambda=10, maxit.em=1)
breadReg(fm_zinb, which=which.min(fm_zinb$bic))
</code></pre>

<hr>
<h2 id='breastfeed'> Breast feeding decision</h2><span id='topic+breastfeed'></span>

<h3>Description</h3>

<p>In a UK hospital, 135 expectant mothers were surveyed on the decision of breastfeeding their
babies or not, along with two-level predictive factors 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(breastfeed)</code></pre>


<h3>Source</h3>

<p>Stephane Heritier, Eva Cantoni, Samuel Copt and Maria-Pia Victoria-Fese (2009). <em>Robust Methods in Biostatistics</em>, John Wiley &amp; Sons</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(breastfeed)
str(breastfeed)
</code></pre>

<hr>
<h2 id='compute_g'>Compute concave function values</h2><span id='topic+compute_g'></span>

<h3>Description</h3>

<p>Compute concave function values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_g(z, cfun, s, delta=0.0001)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="compute_g_+3A_z">z</code></td>
<td>
<p>vector nonnegative values from <code>dfun</code>, e.g., u^2/2</p>
</td></tr>
<tr><td><code id="compute_g_+3A_cfun">cfun</code></td>
<td>
<p>integer from 1-8, concave function as in <code>irglm_fit</code></p>
</td></tr>
<tr><td><code id="compute_g_+3A_s">s</code></td>
<td>
<p>a numeric value, see details in <code>irglmreg_fit</code></p>
</td></tr>
<tr><td><code id="compute_g_+3A_delta">delta</code></td>
<td>
<p>a positive small value, see details in <code>irglmreg_fit</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Concave function values</p>


<h3>Author(s)</h3>

<p>Zhu Wang &lt;zwang145@uthsc.edu&gt;</p>


<h3>References</h3>

<p>Zhu Wang (2024)
<em>Unified Robust Estimation</em>, <em>Australian &amp; New Zealand           Journal         of      Statistics</em>. 66(1):77-102.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+irglmreg">irglmreg</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>u &lt;- seq(0, 4, by=0.01)
z &lt;- u^2/2 ### this is dfun
res &lt;- compute_g(z, cfun=1, s=1)
plot(z, res, ylab="Weight", type="l", lwd=2, 
     main=expression(paste("hcave", "   (", sigma, "=1)", )))
</code></pre>

<hr>
<h2 id='compute_wt'>Weight value from concave function</h2><span id='topic+compute_wt'></span>

<h3>Description</h3>

<p>Weight value from concave function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_wt(z, weights, cfun, s, delta=0.0001)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="compute_wt_+3A_z">z</code></td>
<td>
<p>vector nonnegative values from <code>dfun</code>, e.g., u^2/2</p>
</td></tr>
<tr><td><code id="compute_wt_+3A_weights">weights</code></td>
<td>
<p>optional numeric vector of weights.</p>
</td></tr>
<tr><td><code id="compute_wt_+3A_cfun">cfun</code></td>
<td>
<p>integer from 1-8, concave function as in <code>irglm_fit</code></p>
</td></tr>
<tr><td><code id="compute_wt_+3A_s">s</code></td>
<td>
<p>a numeric value, see details in <code>irglm_fit</code></p>
</td></tr>
<tr><td><code id="compute_wt_+3A_delta">delta</code></td>
<td>
<p>a positive small value, see details in <code>irglm_fit</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Weight value from concave function</p>


<h3>Author(s)</h3>

<p>Zhu Wang &lt;zwang145@uthsc.edu&gt;</p>


<h3>References</h3>

<p>Zhu Wang (2024)
<em>Unified Robust Estimation</em>, <em>Australian &amp; New Zealand           Journal         of      Statistics</em>. 66(1):77-102.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+irglmreg">irglmreg</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>u &lt;- seq(0, 4, by=0.01)
z &lt;- u^2/2 ### this is dfun
res &lt;- compute_wt(z, cfun=1, s=1)
plot(z, res, ylab="Weight", type="l", lwd=2, 
     main=expression(paste("hcave", "   (", sigma, "=1)", )))
</code></pre>

<hr>
<h2 id='conv2glmreg'>convert glm object to class glmreg</h2><span id='topic+conv2glmreg'></span>

<h3>Description</h3>

<p>convert glm object to class glmreg, which then can be used for other purposes</p>


<h3>Usage</h3>

<pre><code class='language-R'>conv2glmreg(object, family=c("poisson", "negbin"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="conv2glmreg_+3A_object">object</code></td>
<td>
<p>an object of class glm</p>
</td></tr>
<tr><td><code id="conv2glmreg_+3A_family">family</code></td>
<td>
<p>one of families in glm class</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class glmreg</p>


<h3>Author(s)</h3>

<p>Zhu Wang &lt;zwang145@uthsc.edu&gt;</p>

<hr>
<h2 id='conv2zipath'>convert zeroinfl object to class zipath</h2><span id='topic+conv2zipath'></span>

<h3>Description</h3>

<p>convert zeroinfl object to class zipath, which then can be used to predict new data</p>


<h3>Usage</h3>

<pre><code class='language-R'>conv2zipath(object, family=c("poisson", "negbin", "geometric"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="conv2zipath_+3A_object">object</code></td>
<td>
<p>an object of class zeroinfl</p>
</td></tr>
<tr><td><code id="conv2zipath_+3A_family">family</code></td>
<td>
<p>one of families in zeroinfl class</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class zipath</p>


<h3>Author(s)</h3>

<p>Zhu Wang &lt;zwang145@uthsc.edu&gt;</p>

<hr>
<h2 id='cv.glmreg'>Cross-validation for glmreg</h2><span id='topic+cv.glmreg'></span><span id='topic+cv.glmreg.formula'></span><span id='topic+cv.glmreg.matrix'></span><span id='topic+cv.glmreg.default'></span><span id='topic+plot.cv.glmreg'></span><span id='topic+predict.cv.glmreg'></span><span id='topic+coef.cv.glmreg'></span>

<h3>Description</h3>

<p>Does k-fold cross-validation for glmreg, produces a plot,
and returns cross-validated log-likelihood values for <code>lambda</code></p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'formula'
cv.glmreg(formula, data, weights, offset=NULL, contrasts=NULL, ...)
## S3 method for class 'matrix'
cv.glmreg(x, y, weights, offset=NULL, ...)
## Default S3 method:
cv.glmreg(x,  ...)
## S3 method for class 'cv.glmreg'
plot(x,se=TRUE,ylab=NULL, main=NULL, width=0.02, col="darkgrey", ...)
## S3 method for class 'cv.glmreg'
predict(object, newx, ...)
## S3 method for class 'cv.glmreg'
coef(object,which=object$lambda.which, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cv.glmreg_+3A_formula">formula</code></td>
<td>
<p>symbolic description of the model, see details.</p>
</td></tr>
<tr><td><code id="cv.glmreg_+3A_data">data</code></td>
<td>
<p>argument controlling formula processing
via <code><a href="stats.html#topic+model.frame">model.frame</a></code>.</p>
</td></tr>
<tr><td><code id="cv.glmreg_+3A_x">x</code></td>
<td>
<p><code>x</code> matrix as in <code>glmreg</code>. It could be object of <code>cv.glmreg</code>.</p>
</td></tr>
<tr><td><code id="cv.glmreg_+3A_y">y</code></td>
<td>
<p>response <code>y</code> as in <code>glmreg</code>.</p>
</td></tr>
<tr><td><code id="cv.glmreg_+3A_weights">weights</code></td>
<td>
<p>Observation weights; defaults to 1 per observation</p>
</td></tr>
<tr><td><code id="cv.glmreg_+3A_offset">offset</code></td>
<td>
<p>this can be used to specify an a priori known component to be included in the linear predictor during fitting. This should be NULL or a numeric vector of length equal to the number of cases. Currently only one offset term can be included in the formula.</p>
</td></tr>
<tr><td><code id="cv.glmreg_+3A_contrasts">contrasts</code></td>
<td>
<p>the contrasts corresponding to <code>levels</code> from the
respective models</p>
</td></tr>
<tr><td><code id="cv.glmreg_+3A_object">object</code></td>
<td>
<p>object of <code>cv.glmreg</code></p>
</td></tr>
<tr><td><code id="cv.glmreg_+3A_newx">newx</code></td>
<td>
<p>Matrix of values at which predictions are to be made.  Not
used for <code>type="coefficients"</code></p>
</td></tr>
<tr><td><code id="cv.glmreg_+3A_which">which</code></td>
<td>
<p>Indices of the penalty parameter <code>lambda</code> at which
estimates are extracted. By default, the one which generates the optimal cross-validation value.</p>
</td></tr>
<tr><td><code id="cv.glmreg_+3A_se">se</code></td>
<td>
<p>logical value, if <code>TRUE</code>, standard error curve is also plotted</p>
</td></tr> 
<tr><td><code id="cv.glmreg_+3A_ylab">ylab</code></td>
<td>
<p>ylab on y-axis</p>
</td></tr>
<tr><td><code id="cv.glmreg_+3A_main">main</code></td>
<td>
<p>title of plot</p>
</td></tr>
<tr><td><code id="cv.glmreg_+3A_width">width</code></td>
<td>
<p>width of lines</p>
</td></tr>
<tr><td><code id="cv.glmreg_+3A_col">col</code></td>
<td>
<p>color of standard error curve</p>
</td></tr>
<tr><td><code id="cv.glmreg_+3A_...">...</code></td>
<td>
<p>Other arguments that can be passed to <code>glmreg</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function runs <code>glmreg</code> <code>nfolds</code>+1 times; the
first to compute the <code>lambda</code> sequence, and then to
compute the fit with each of the folds omitted. The error or the log-likelihood value is
accumulated, and the average value and standard deviation over the
folds is computed. Note that <code>cv.glmreg</code> can be used to search for
values for <code>alpha</code>: it is required to call <code>cv.glmreg</code> with a fixed vector <code>foldid</code> for different values of <code>alpha</code>. 
</p>


<h3>Value</h3>

<p>an object of class <code>"cv.glmreg"</code> is returned, which is a
list with the ingredients of the cross-validation fit.
</p>
<table role = "presentation">
<tr><td><code>fit</code></td>
<td>
<p>a fitted glmreg object for the full data.</p>
</td></tr>
<tr><td><code>residmat</code></td>
<td>
<p>matrix of log-likelihood values with row values for <code>lambda</code> and column values for <code>k</code>th cross-validation</p>
</td></tr>
<tr><td><code>bic</code></td>
<td>
<p>matrix of BIC values with row values for <code>lambda</code> and column values for <code>k</code>th cross-validation</p>
</td></tr>
<tr><td><code>cv</code></td>
<td>
<p>The mean cross-validated log-likelihood values - a vector of length
<code>length(lambda)</code>.</p>
</td></tr>
<tr><td><code>cv.error</code></td>
<td>
<p>estimate of standard error of <code>cv</code>.</p>
</td></tr>
<tr><td><code>foldid</code></td>
<td>
<p>an optional vector of values between 1 and <code>nfold</code>
identifying what fold each observation is in.</p>
</td></tr>
<tr><td><code>lambda</code></td>
<td>
<p>a vector of <code>lambda</code> values</p>
</td></tr> 
<tr><td><code>lambda.which</code></td>
<td>
<p>index of <code>lambda</code> that gives maximum <code>cv</code> value.</p>
</td></tr>
<tr><td><code>lambda.optim</code></td>
<td>
<p>value of <code>lambda</code> that gives maximum <code>cv</code> value.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Zhu Wang &lt;zwang145@uthsc.edu&gt;</p>


<h3>References</h3>

<p>Zhu Wang, Shuangge Ma, Michael Zappitelli, Chirag Parikh, Ching-Yun Wang and Prasad Devarajan (2014)      <em>Penalized Count Data Regression with Application to Hospital Stay after Pediatric Cardiac Surgery</em>, <em>Statistical Methods in Medical Research</em>. 2014 Apr 17. [Epub ahead of print]
</p>


<h3>See Also</h3>

<p><code><a href="#topic+glmreg">glmreg</a></code> and <code><a href="base.html#topic+plot">plot</a></code>, <code><a href="stats.html#topic+predict">predict</a></code>, and <code><a href="stats.html#topic+coef">coef</a></code> methods for <code>"cv.glmreg"</code> object.</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("bioChemists", package = "pscl")
fm_pois &lt;- cv.glmreg(art ~ ., data = bioChemists, family = "poisson")
title("Poisson Family",line=2.5)
predict(fm_pois, newx=bioChemists[,-1])[1:4]
coef(fm_pois)
</code></pre>

<hr>
<h2 id='cv.glmreg_fit'>Internal function of cross-validation for glmreg</h2><span id='topic+cv.glmreg_fit'></span>

<h3>Description</h3>

<p>Internal function to conduct k-fold cross-validation for glmreg, produces a plot,
and returns cross-validated log-likelihood values for <code>lambda</code></p>


<h3>Usage</h3>

<pre><code class='language-R'>cv.glmreg_fit(x, y, weights, offset, lambda=NULL, balance=TRUE, 
              family=c("gaussian", "binomial", "poisson", "negbin"), 
              type=c("loss", "error"), nfolds=10, foldid, plot.it=TRUE,
              se=TRUE, n.cores=2, trace=FALSE, parallel=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cv.glmreg_fit_+3A_x">x</code></td>
<td>
<p><code>x</code> matrix as in <code>glmreg</code>.</p>
</td></tr>
<tr><td><code id="cv.glmreg_fit_+3A_y">y</code></td>
<td>
<p>response <code>y</code> as in <code>glmreg</code>.</p>
</td></tr>
<tr><td><code id="cv.glmreg_fit_+3A_weights">weights</code></td>
<td>
<p>Observation weights; defaults to 1 per observation</p>
</td></tr>
<tr><td><code id="cv.glmreg_fit_+3A_offset">offset</code></td>
<td>
<p>this can be used to specify an a priori known component to be included in the linear predictor during fitting. This should be NULL or a numeric vector of length equal to the number of cases. Currently only one offset term can be included in the formula.</p>
</td></tr>
<tr><td><code id="cv.glmreg_fit_+3A_lambda">lambda</code></td>
<td>
<p>Optional user-supplied lambda sequence; default is
<code>NULL</code>, and <code>glmreg</code> chooses its own sequence</p>
</td></tr>
<tr><td><code id="cv.glmreg_fit_+3A_balance">balance</code></td>
<td>
<p>for <code>family="binomial"</code> only</p>
</td></tr>
<tr><td><code id="cv.glmreg_fit_+3A_family">family</code></td>
<td>
<p>response variable distribution</p>
</td></tr>
<tr><td><code id="cv.glmreg_fit_+3A_type">type</code></td>
<td>
<p> cross-validation criteria. For <code>type="loss"</code>, loss function (log-negative-likelihood) values and <code>type="error"</code> is misclassification error if <code>family="binomial"</code>. </p>
</td></tr> 
<tr><td><code id="cv.glmreg_fit_+3A_nfolds">nfolds</code></td>
<td>
<p>number of folds &gt;=3, default is 10</p>
</td></tr>
<tr><td><code id="cv.glmreg_fit_+3A_foldid">foldid</code></td>
<td>
<p>an optional vector of values between 1 and <code>nfold</code>
identifying what fold each observation is in. If supplied,
<code>nfold</code> can be missing and will be ignored.</p>
</td></tr>
<tr><td><code id="cv.glmreg_fit_+3A_plot.it">plot.it</code></td>
<td>
<p> a logical value, to plot the estimated log-likelihood values if <code>TRUE</code>. </p>
</td></tr>
<tr><td><code id="cv.glmreg_fit_+3A_se">se</code></td>
<td>
<p> a logical value, to plot with standard errors. </p>
</td></tr>
<tr><td><code id="cv.glmreg_fit_+3A_parallel">parallel</code>, <code id="cv.glmreg_fit_+3A_n.cores">n.cores</code></td>
<td>
<p>a logical value, parallel computing or not with the number of CPU cores to use. The cross-validation loop will attempt to send different CV folds off to different cores.</p>
</td></tr>
<tr><td><code id="cv.glmreg_fit_+3A_trace">trace</code></td>
<td>
<p> a logical value, print progress of cross validation or not</p>
</td></tr> 
<tr><td><code id="cv.glmreg_fit_+3A_...">...</code></td>
<td>
<p>Other arguments that can be passed to <code>glmreg</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function runs <code>glmreg</code> <code>nfolds</code>+1 times; the
first to compute the <code>lambda</code> sequence, and then to
compute the fit with each of the folds omitted. The error or the log-likelihood value is
accumulated, and the average value and standard deviation over the
folds is computed. Note that <code>cv.glmreg</code> can be used to search for
values for <code>alpha</code>: it is required to call <code>cv.glmreg</code> with a fixed vector <code>foldid</code> for different values of <code>alpha</code>.
</p>


<h3>Value</h3>

<p>an object of class <code>"cv.glmreg"</code> is returned, which is a
list with the ingredients of the cross-validation fit.
</p>
<table role = "presentation">
<tr><td><code>fit</code></td>
<td>
<p>a fitted glmreg object for the full data.</p>
</td></tr>
<tr><td><code>residmat</code></td>
<td>
<p>matrix of log-likelihood values with row values for <code>lambda</code> and column values for <code>k</code>th cross-validation</p>
</td></tr>
<tr><td><code>cv</code></td>
<td>
<p>The mean cross-validated log-likelihood values - a vector of
<code>length(lambda)</code>.</p>
</td></tr>
<tr><td><code>cv.error</code></td>
<td>
<p>estimate of standard error of <code>cv</code>.</p>
</td></tr>
<tr><td><code>foldid</code></td>
<td>
<p>an optional vector of values between 1 and <code>nfold</code>
identifying what fold each observation is in.</p>
</td></tr>
<tr><td><code>lambda</code></td>
<td>
<p>a vector of <code>lambda</code> values</p>
</td></tr>
<tr><td><code>lambda.which</code></td>
<td>
<p>index of <code>lambda</code> that gives maximum <code>cv</code> value.</p>
</td></tr>
<tr><td><code>lambda.optim</code></td>
<td>
<p>value of <code>lambda</code> that gives maximum <code>cv</code> value.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Zhu Wang &lt;zwang145@uthsc.edu&gt;</p>


<h3>References</h3>

<p>Zhu Wang, Shuangge Ma, Michael Zappitelli, Chirag Parikh, Ching-Yun Wang and Prasad Devarajan (2014)
<em>Penalized Count Data Regression with Application to Hospital Stay after Pediatric Cardiac Surgery</em>, <em>Statistical Methods in Medical Research</em>. 2014 Apr 17. [Epub ahead of print]
</p>


<h3>See Also</h3>

<p><code><a href="#topic+glmreg">glmreg</a></code> and <code><a href="base.html#topic+plot">plot</a></code>, <code><a href="stats.html#topic+predict">predict</a></code>, and <code><a href="stats.html#topic+coef">coef</a></code> methods for <code>"cv.glmreg"</code> object.</p>

<hr>
<h2 id='cv.glmregNB'>Cross-validation for glmregNB</h2><span id='topic+cv.glmregNB'></span>

<h3>Description</h3>

<p>Does k-fold cross-validation for glmregNB, produces a plot,
and returns cross-validated log-likelihood values for <code>lambda</code></p>


<h3>Usage</h3>

<pre><code class='language-R'>cv.glmregNB(formula, data, weights, offset=NULL, lambda=NULL, nfolds=10, 
            foldid, plot.it=TRUE, se=TRUE, n.cores=2, trace=FALSE, 
            parallel=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cv.glmregNB_+3A_formula">formula</code></td>
<td>
<p>symbolic description of the model</p>
</td></tr>
<tr><td><code id="cv.glmregNB_+3A_data">data</code></td>
<td>
<p>arguments controlling formula processing
via <code><a href="stats.html#topic+model.frame">model.frame</a></code>.</p>
</td></tr>
<tr><td><code id="cv.glmregNB_+3A_weights">weights</code></td>
<td>
<p>Observation weights; defaults to 1 per observation</p>
</td></tr>
<tr><td><code id="cv.glmregNB_+3A_offset">offset</code></td>
<td>
<p>this can be used to specify an a priori known component to be included in the linear predictor during fitting. This should be NULL or a numeric vector of length equal to the number of cases. Currently only one offset term can be included in the formula.</p>
</td></tr>
<tr><td><code id="cv.glmregNB_+3A_lambda">lambda</code></td>
<td>
<p>Optional user-supplied lambda sequence; default is
<code>NULL</code>, and <code>glmregNB</code> chooses its own sequence</p>
</td></tr>
<tr><td><code id="cv.glmregNB_+3A_nfolds">nfolds</code></td>
<td>
<p>number of folds - default is 10. Although <code>nfolds</code>
can be as large as the sample size (leave-one-out CV), it is not
recommended for large datasets. Smallest value allowable is <code>nfolds=3</code></p>
</td></tr>
<tr><td><code id="cv.glmregNB_+3A_foldid">foldid</code></td>
<td>
<p>an optional vector of values between 1 and <code>nfold</code>
identifying what fold each observation is in. If supplied,
<code>nfold</code> can be missing.</p>
</td></tr>
<tr><td><code id="cv.glmregNB_+3A_plot.it">plot.it</code></td>
<td>
<p> a logical value, to plot the estimated log-likelihood values if <code>TRUE</code>. </p>
</td></tr>
<tr><td><code id="cv.glmregNB_+3A_se">se</code></td>
<td>
<p> a logical value, to plot with standard errors. </p>
</td></tr>
<tr><td><code id="cv.glmregNB_+3A_n.cores">n.cores</code></td>
<td>
<p>The number of CPU cores to use. The cross-validation loop
will attempt to send different CV folds off to different cores.</p>
</td></tr>
<tr><td><code id="cv.glmregNB_+3A_trace">trace</code></td>
<td>
<p>a logical value, print progress of cross-validation or not</p>
</td></tr>
<tr><td><code id="cv.glmregNB_+3A_parallel">parallel</code></td>
<td>
<p>a logical value, parallel computing or not</p>
</td></tr>
<tr><td><code id="cv.glmregNB_+3A_...">...</code></td>
<td>
<p>Other arguments that can be passed to <code>glmregNB</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function runs <code>glmregNB</code> <code>nfolds</code>+1 times; the
first to get the <code>lambda</code> sequence, and then the remainder to
compute the fit with each of the folds omitted. The error is
accumulated, and the average error and standard deviation over the
folds is computed. 
Note that <code>cv.glmregNB</code> does NOT search for
values for <code>alpha</code>. A specific value should be supplied, else
<code>alpha=1</code> is assumed by default. If users would like to
cross-validate <code>alpha</code> as well, they should call <code>cv.glmregNB</code>
with a pre-computed vector <code>foldid</code>, and then use this same fold vector
in separate calls to <code>cv.glmregNB</code> with different values of
<code>alpha</code>. 
</p>


<h3>Value</h3>

<p>an object of class <code>"cv.glmregNB"</code> is returned, which is a
list with the ingredients of the cross-validation fit.
</p>
<table role = "presentation">
<tr><td><code>fit</code></td>
<td>
<p>a fitted glmregNB object for the full data.</p>
</td></tr>
<tr><td><code>residmat</code></td>
<td>
<p>matrix of log-likelihood values with row values for <code>lambda</code> and column values for <code>k</code>th cross-validation</p>
</td></tr>
<tr><td><code>cv</code></td>
<td>
<p>The mean cross-validated log-likelihood values - a vector of length
<code>length(lambda)</code>.</p>
</td></tr>
<tr><td><code>cv.error</code></td>
<td>
<p>The standard error of cross-validated log-likelihood values - a vector of length
<code>length(lambda)</code>.</p>
</td></tr>
<tr><td><code>lambda</code></td>
<td>
<p>a vector of <code>lambda</code> values</p>
</td></tr> 
<tr><td><code>foldid</code></td>
<td>
<p>indicators of data used in each cross-validation, for reproductive purposes</p>
</td></tr>
<tr><td><code>lambda.which</code></td>
<td>
<p>index of <code>lambda</code> that gives maximum <code>cv</code> value.</p>
</td></tr>
<tr><td><code>lambda.optim</code></td>
<td>
<p>value of <code>lambda</code> that gives maximum <code>cv</code> value.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Zhu Wang &lt;zwang145@uthsc.edu&gt;</p>


<h3>References</h3>

<p>Zhu Wang, Shuangge Ma, Michael Zappitelli, Chirag Parikh, Ching-Yun Wang and Prasad Devarajan (2014)
<em>Penalized Count Data Regression with Application to Hospital Stay after Pediatric Cardiac Surgery</em>, <em>Statistical Methods in Medical Research</em>. 2014 Apr 17. [Epub ahead of print] 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+glmregNB">glmregNB</a></code> and <code><a href="base.html#topic+plot">plot</a></code>, <code><a href="stats.html#topic+predict">predict</a></code>, and <code><a href="stats.html#topic+coef">coef</a></code> methods for <code>"cv.glmregNB"</code> object.</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data("bioChemists", package = "pscl")
fm_nb &lt;- cv.glmregNB(art ~ ., data = bioChemists)
plot(fm_nb)

## End(Not run)
</code></pre>

<hr>
<h2 id='cv.irglmreg'>Cross-validation for irglmreg</h2><span id='topic+cv.irglmreg'></span><span id='topic+cv.irglmreg.formula'></span><span id='topic+cv.irglmreg.matrix'></span><span id='topic+cv.irglmreg.default'></span><span id='topic+plot.cv.irglmreg'></span><span id='topic+coef.cv.irglmreg'></span>

<h3>Description</h3>

<p>Does k-fold cross-validation for irglmreg, produces a plot,
and returns cross-validated log-likelihood values for <code>lambda</code></p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'formula'
cv.irglmreg(formula, data, weights, offset=NULL, ...)
## S3 method for class 'matrix'
cv.irglmreg(x, y, weights, offset=NULL, ...)
## Default S3 method:
cv.irglmreg(x,  ...)
## S3 method for class 'cv.irglmreg'
plot(x,se=TRUE,ylab=NULL, main=NULL, width=0.02, col="darkgrey", ...)
## S3 method for class 'cv.irglmreg'
coef(object,which=object$lambda.which, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cv.irglmreg_+3A_formula">formula</code></td>
<td>
<p>symbolic description of the model, see details.</p>
</td></tr>
<tr><td><code id="cv.irglmreg_+3A_data">data</code></td>
<td>
<p>argument controlling formula processing
via <code><a href="stats.html#topic+model.frame">model.frame</a></code>.</p>
</td></tr>
<tr><td><code id="cv.irglmreg_+3A_x">x</code></td>
<td>
<p><code>x</code> matrix as in <code>irglmreg</code>. It could be object of <code>cv.irglmreg</code>.</p>
</td></tr>
<tr><td><code id="cv.irglmreg_+3A_y">y</code></td>
<td>
<p>response <code>y</code> as in <code>irglmreg</code>.</p>
</td></tr>
<tr><td><code id="cv.irglmreg_+3A_weights">weights</code></td>
<td>
<p>Observation weights; defaults to 1 per observation</p>
</td></tr>
<tr><td><code id="cv.irglmreg_+3A_offset">offset</code></td>
<td>
<p>Not implemented yet</p>
</td></tr>
<tr><td><code id="cv.irglmreg_+3A_object">object</code></td>
<td>
<p>object of <code>cv.irglmreg</code></p>
</td></tr>
<tr><td><code id="cv.irglmreg_+3A_which">which</code></td>
<td>
<p>Indices of the penalty parameter <code>lambda</code> at which
estimates are extracted. By default, the one which generates the optimal cross-validation value.</p>
</td></tr>
<tr><td><code id="cv.irglmreg_+3A_se">se</code></td>
<td>
<p>logical value, if <code>TRUE</code>, standard error curve is also plotted</p>
</td></tr> 
<tr><td><code id="cv.irglmreg_+3A_ylab">ylab</code></td>
<td>
<p>ylab on y-axis</p>
</td></tr>
<tr><td><code id="cv.irglmreg_+3A_main">main</code></td>
<td>
<p>title of plot</p>
</td></tr>
<tr><td><code id="cv.irglmreg_+3A_width">width</code></td>
<td>
<p>width of lines</p>
</td></tr>
<tr><td><code id="cv.irglmreg_+3A_col">col</code></td>
<td>
<p>color of standard error curve</p>
</td></tr>
<tr><td><code id="cv.irglmreg_+3A_...">...</code></td>
<td>
<p>Other arguments that can be passed to <code>irglmreg</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function runs <code>irglmreg</code> <code>nfolds</code>+1 times; the
first to compute the <code>lambda</code> sequence, and then to
compute the fit with each of the folds omitted. The error or the loss value is
accumulated, and the average value and standard deviation over the
folds is computed. Note that <code>cv.irglmreg</code> can be used to search for
values for <code>alpha</code>: it is required to call <code>cv.irglmreg</code> with a fixed vector <code>foldid</code> for different values of <code>alpha</code>. 
</p>


<h3>Value</h3>

<p>an object of class <code>"cv.irglmreg"</code> is returned, which is a
list with the ingredients of the cross-validation fit.
</p>
<table role = "presentation">
<tr><td><code>fit</code></td>
<td>
<p>a fitted irglmreg object for the full data.</p>
</td></tr>
<tr><td><code>residmat</code></td>
<td>
<p>matrix of log-likelihood values with row values for <code>lambda</code> and column values for <code>k</code>th cross-validation</p>
</td></tr>
<tr><td><code>bic</code></td>
<td>
<p>matrix of BIC values with row values for <code>lambda</code> and column values for <code>k</code>th cross-validation</p>
</td></tr>
<tr><td><code>cv</code></td>
<td>
<p>The mean cross-validated log-likelihood values - a vector of length
<code>length(lambda)</code>.</p>
</td></tr>
<tr><td><code>cv.error</code></td>
<td>
<p>estimate of standard error of <code>cv</code>.</p>
</td></tr>
<tr><td><code>foldid</code></td>
<td>
<p>an optional vector of values between 1 and <code>nfold</code>
identifying what fold each observation is in.</p>
</td></tr>
<tr><td><code>lambda</code></td>
<td>
<p>a vector of <code>lambda</code> values</p>
</td></tr> 
<tr><td><code>lambda.which</code></td>
<td>
<p>index of <code>lambda</code> that gives minimum <code>cv</code> value.</p>
</td></tr>
<tr><td><code>lambda.optim</code></td>
<td>
<p>value of <code>lambda</code> that gives minimum <code>cv</code> value.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Zhu Wang &lt;zwang145@uthsc.edu&gt;</p>


<h3>References</h3>

<p>Zhu Wang (2024)
<em>Unified Robust Estimation</em>, <em>Australian &amp; New Zealand Journal         of      Statistics</em>. 66(1):77-102.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+irglmreg">irglmreg</a></code> and <code><a href="base.html#topic+plot">plot</a></code>, <code><a href="stats.html#topic+predict">predict</a></code>, and <code><a href="stats.html#topic+coef">coef</a></code> methods for <code>"cv.irglmreg"</code> object.</p>

<hr>
<h2 id='cv.irglmreg_fit'>Internal function of cross-validation for irglmreg</h2><span id='topic+cv.irglmreg_fit'></span>

<h3>Description</h3>

<p>Internal function to conduct k-fold cross-validation for irglmreg, produces a plot,
and returns cross-validated loss values for <code>lambda</code></p>


<h3>Usage</h3>

<pre><code class='language-R'>cv.irglmreg_fit(x, y, weights, offset, lambda=NULL, balance=TRUE, cfun=4, dfun=1, 
                s=1.5, nfolds=10, foldid, type = c("loss", "error"), plot.it=TRUE,
                se=TRUE, n.cores=2, trace=FALSE, parallel=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cv.irglmreg_fit_+3A_x">x</code></td>
<td>
<p><code>x</code> matrix as in <code>irglmreg</code>.</p>
</td></tr>
<tr><td><code id="cv.irglmreg_fit_+3A_y">y</code></td>
<td>
<p>response <code>y</code> as in <code>irglmreg</code>.</p>
</td></tr>
<tr><td><code id="cv.irglmreg_fit_+3A_weights">weights</code></td>
<td>
<p>Observation weights; defaults to 1 per observation</p>
</td></tr>
<tr><td><code id="cv.irglmreg_fit_+3A_offset">offset</code></td>
<td>
<p>this can be used to specify an a priori known component to be included in the linear predictor during fitting. This should be NULL or a numeric vector of length equal to the number of cases. Currently only one offset term can be included in the formula.</p>
</td></tr>
<tr><td><code id="cv.irglmreg_fit_+3A_lambda">lambda</code></td>
<td>
<p>Optional user-supplied lambda sequence; default is
<code>NULL</code>, and <code>irglmreg</code> chooses its own sequence</p>
</td></tr>
<tr><td><code id="cv.irglmreg_fit_+3A_balance">balance</code></td>
<td>
<p>for <code>dfun=4, 5, 6</code> only</p>
</td></tr>
<tr><td><code id="cv.irglmreg_fit_+3A_cfun">cfun</code></td>
<td>
<p> a number from 1 to 7, type of convex cap (concave) function </p>
</td></tr>
<tr><td><code id="cv.irglmreg_fit_+3A_dfun">dfun</code></td>
<td>
<p> a number from 1, 4-7, type of convex downward function</p>
</td></tr>
<tr><td><code id="cv.irglmreg_fit_+3A_s">s</code></td>
<td>
<p> nonconvex loss tuning parameter for robust regression and classification. </p>
</td></tr>
<tr><td><code id="cv.irglmreg_fit_+3A_nfolds">nfolds</code></td>
<td>
<p>number of folds &gt;=3, default is 10</p>
</td></tr>
<tr><td><code id="cv.irglmreg_fit_+3A_foldid">foldid</code></td>
<td>
<p>an optional vector of values between 1 and <code>nfold</code>
identifying what fold each observation is in. If supplied,
<code>nfold</code> can be missing and will be ignored.</p>
</td></tr>
<tr><td><code id="cv.irglmreg_fit_+3A_type">type</code></td>
<td>
<p> cross-validation criteria. For <code>type="loss"</code>, loss function values and <code>type="error"</code> is misclassification error. </p>
</td></tr>
<tr><td><code id="cv.irglmreg_fit_+3A_plot.it">plot.it</code></td>
<td>
<p> a logical value, to plot the estimated log-likelihood values if <code>TRUE</code>. </p>
</td></tr>
<tr><td><code id="cv.irglmreg_fit_+3A_se">se</code></td>
<td>
<p> a logical value, to plot with standard errors. </p>
</td></tr>
<tr><td><code id="cv.irglmreg_fit_+3A_n.cores">n.cores</code></td>
<td>
<p>The number of CPU cores to use. The cross-validation loop
will attempt to send different CV folds off to different cores.</p>
</td></tr>
<tr><td><code id="cv.irglmreg_fit_+3A_trace">trace</code></td>
<td>
<p> a logical value, print progress of cross validation or not</p>
</td></tr>
<tr><td><code id="cv.irglmreg_fit_+3A_parallel">parallel</code></td>
<td>
<p> a logical value, parallel computing or not</p>
</td></tr>
<tr><td><code id="cv.irglmreg_fit_+3A_...">...</code></td>
<td>
<p>Other arguments that can be passed to <code>irglmreg</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function runs <code>irglmreg</code> <code>nfolds</code>+1 times; the
first to compute the <code>lambda</code> sequence, and then to
compute the fit with each of the folds omitted. The error or the log-likelihood value is
accumulated, and the average value and standard deviation over the
folds is computed. Note that <code>cv.irglmreg</code> can be used to search for
values for <code>alpha</code>: it is required to call <code>cv.irglmreg</code> with a fixed vector <code>foldid</code> for different values of <code>alpha</code>.
</p>


<h3>Value</h3>

<p>an object of class <code>"cv.irglmreg"</code> is returned, which is a
list with the ingredients of the cross-validation fit.
</p>
<table role = "presentation">
<tr><td><code>fit</code></td>
<td>
<p>a fitted irglmreg object for the full data.</p>
</td></tr>
<tr><td><code>residmat</code></td>
<td>
<p>matrix of loss values or errors with row values for <code>lambda</code> and column values for <code>k</code>th cross-validation</p>
</td></tr>
<tr><td><code>cv</code></td>
<td>
<p>The mean cross-validated loss values or errors - a vector of length
<code>length(lambda)</code>.</p>
</td></tr>
<tr><td><code>cv.error</code></td>
<td>
<p>estimate of standard error of <code>cv</code>.</p>
</td></tr>
<tr><td><code>foldid</code></td>
<td>
<p>an optional vector of values between 1 and <code>nfold</code>
identifying what fold each observation is in.</p>
</td></tr>
<tr><td><code>lambda</code></td>
<td>
<p>a vector of <code>lambda</code> values</p>
</td></tr> 
<tr><td><code>lambda.which</code></td>
<td>
<p>index of <code>lambda</code> that gives minimum <code>cv</code> value.</p>
</td></tr>
<tr><td><code>lambda.optim</code></td>
<td>
<p>value of <code>lambda</code> that gives minimum <code>cv</code> value.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Zhu Wang &lt;zwang145@uthsc.edu&gt;</p>


<h3>References</h3>

<p>Zhu Wang (2024)
<em>Unified Robust Estimation</em>, <em>Australian &amp; New Zealand Journal         of      Statistics</em>. 66(1):77-102.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+irglmreg">irglmreg</a></code> and <code><a href="base.html#topic+plot">plot</a></code>, <code><a href="stats.html#topic+predict">predict</a></code>, and <code><a href="stats.html#topic+coef">coef</a></code> methods for <code>"cv.irglmreg"</code> object.</p>

<hr>
<h2 id='cv.irsvm'>Cross-validation for irsvm</h2><span id='topic+cv.irsvm'></span><span id='topic+cv.irsvm.formula'></span><span id='topic+cv.irsvm.matrix'></span><span id='topic+cv.irsvm.default'></span>

<h3>Description</h3>

<p>Does k-fold cross-validation for irsvm</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'formula'
cv.irsvm(formula, data, weights, contrasts=NULL, ...)
## S3 method for class 'matrix'
cv.irsvm(x, y, weights, ...)
## Default S3 method:
cv.irsvm(x,  ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cv.irsvm_+3A_formula">formula</code></td>
<td>
<p>symbolic description of the model, see details.</p>
</td></tr>
<tr><td><code id="cv.irsvm_+3A_data">data</code></td>
<td>
<p>argument controlling formula processing
via <code><a href="stats.html#topic+model.frame">model.frame</a></code>.</p>
</td></tr>
<tr><td><code id="cv.irsvm_+3A_x">x</code></td>
<td>
<p><code>x</code> matrix as in <code>irsvm</code>.</p>
</td></tr>
<tr><td><code id="cv.irsvm_+3A_y">y</code></td>
<td>
<p>response <code>y</code> as in <code>irsvm</code>.</p>
</td></tr>
<tr><td><code id="cv.irsvm_+3A_weights">weights</code></td>
<td>
<p>Observation weights; defaults to 1 per observation</p>
</td></tr>
<tr><td><code id="cv.irsvm_+3A_contrasts">contrasts</code></td>
<td>
<p>the contrasts corresponding to <code>levels</code> from the respective models.</p>
</td></tr>
<tr><td><code id="cv.irsvm_+3A_...">...</code></td>
<td>
<p>Other arguments that can be passed to <code>irsvm</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Does a K-fold cross-validation to determine optimal tuning parameters in SVM: <code>cost</code> and <code>gamma</code> if <code>kernel</code> is nonlinear. It can also choose <code>s</code> used in <code>cfun</code>. 
</p>


<h3>Value</h3>

<p>An object contains a list of ingredients of cross-validation including optimal tuning parameters.
</p>
<table role = "presentation">
<tr><td><code>residmat</code></td>
<td>
<p>matrix with row values for <code>kernel="linear"</code> are <code>s, cost, error, k</code>, where <code>k</code> is the number of cross-validation fold. For nonlinear kernels, row values are <code>s, gamma, cost, error, k</code>.</p>
</td></tr>
<tr><td><code>cost</code></td>
<td>
<p>a value of <code>cost</code> that gives minimum cross-validated value in <code>irsvm</code>.</p>
</td></tr> 
<tr><td><code>gamma</code></td>
<td>
<p>a value of <code>gamma</code> that gives minimum cross-validated value in <code>irsvm</code></p>
</td></tr>
<tr><td><code>s</code></td>
<td>
<p>value of <code>s</code> for <code>cfun</code> that gives minimum cross-validated value in <code>irsvm</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Zhu Wang &lt;zwang145@uthsc.edu&gt;</p>


<h3>References</h3>

<p>Zhu Wang (2024)
<em>Unified Robust Estimation</em>, <em>Australian &amp; New Zealand Journal         of      Statistics</em>. 66(1):77-102.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+irsvm">irsvm</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
x &lt;- matrix(rnorm(40*2), ncol=2)
y &lt;- c(rep(-1, 20), rep(1, 20))
x[y==1,] &lt;- x[y==1, ] + 1
irsvm.opt &lt;- cv.irsvm(x, y, type="C-classification", s=1, kernel="linear", cfun="acave")
irsvm.opt$cost
irsvm.opt$gamma
irsvm.opt$s

## End(Not run)
</code></pre>

<hr>
<h2 id='cv.irsvm_fit'>Internal function of cross-validation for irsvm</h2><span id='topic+cv.irsvm_fit'></span>

<h3>Description</h3>

<p>Internal function to conduct k-fold cross-validation for irsvm</p>


<h3>Usage</h3>

<pre><code class='language-R'>cv.irsvm_fit(x, y, weights, cfun="ccave", s=c(1, 5), type=NULL, 
             kernel="radial", gamma=2^(-4:10), cost=2^(-4:4), 
             epsilon=0.1, balance=TRUE, nfolds=10, foldid, 
             trim_ratio=0.9, n.cores=2, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cv.irsvm_fit_+3A_x">x</code></td>
<td>
<p>a data matrix, a vector, or a sparse '<em>design</em> matrix' (object  of class
<code><a href="Matrix.html#topic+Matrix">Matrix</a></code> provided by the <span class="pkg">Matrix</span> package,
or of class <code><a href="SparseM.html#topic+matrix.csr">matrix.csr</a></code>
provided by the <span class="pkg">SparseM</span> package, or of class
<code><a href="slam.html#topic+simple_triplet_matrix">simple_triplet_matrix</a></code> provided by the <span class="pkg">slam</span>
package).</p>
</td></tr>
<tr><td><code id="cv.irsvm_fit_+3A_y">y</code></td>
<td>
<p>a response vector with one label for each row/component of
<code>x</code>. Can be either a factor (for classification tasks)
or a numeric vector (for regression).</p>
</td></tr>
<tr><td><code id="cv.irsvm_fit_+3A_weights">weights</code></td>
<td>
<p>the weight of each subject. It should be in the same length    of <code>y</code>.</p>
</td></tr>
<tr><td><code id="cv.irsvm_fit_+3A_cfun">cfun</code></td>
<td>
<p> character, type of convex cap (concave) function.<br />
Valid options are:
</p>

<ul>
<li> <p><code>"hcave"</code>
</p>
</li>
<li> <p><code>"acave"</code>
</p>
</li>
<li> <p><code>"bcave"</code>
</p>
</li>
<li> <p><code>"ccave"</code>
</p>
</li>
<li> <p><code>"dcave"</code>
</p>
</li>
<li> <p><code>"ecave"</code>
</p>
</li>
<li> <p><code>"gcave"</code>
</p>
</li>
<li> <p><code>"tcave"</code>
</p>
</li></ul>

</td></tr>
<tr><td><code id="cv.irsvm_fit_+3A_s">s</code></td>
<td>
<p> tuning parameter of <code>cfun</code>. <code>s &gt; 0</code> and can be equal       to  0 for <code>cfun="tcave"</code>. If <code>s</code> is too close to 0 for                <code>cfun="acave", "bcave", "ccave"</code>, the calculated weights can become 0 for  all observations, thus crash the program.</p>
</td></tr>
<tr><td><code id="cv.irsvm_fit_+3A_type">type</code></td>
<td>
<p><code>irsvm</code> can be used as a classification
machine, or as a regression machine.
Depending of whether <code>y</code> is
a factor or not, the default setting for <code>type</code> is <code>C-classification</code> or <code>eps-regression</code>, respectively, but may be overwritten  by setting an explicit value.<br />
Valid options are:
</p>

<ul>
<li> <p><code>C-classification</code>
</p>
</li>
<li> <p><code>nu-classification</code>
</p>
</li>
<li> <p><code>eps-regression</code>
</p>
</li>
<li> <p><code>nu-regression</code>
</p>
</li></ul>

</td></tr>
<tr><td><code id="cv.irsvm_fit_+3A_kernel">kernel</code>, <code id="cv.irsvm_fit_+3A_gamma">gamma</code></td>
<td>
<p>the kernel used in training and predicting. You
might consider changing some of the following parameters, depending
on the kernel type.<br />
</p>

<dl>
<dt>linear:</dt><dd><p><code class="reqn">u'v</code></p>
</dd>
<dt>polynomial:</dt><dd><p><code class="reqn">(\gamma u'v + coef0)^{degree}</code></p>
</dd>
<dt>radial basis:</dt><dd><p><code class="reqn">e^(-\gamma |u-v|^2)</code></p>
</dd>
<dt>sigmoid:</dt><dd><p><code class="reqn">tanh(\gamma u'v + coef0)</code></p>
</dd>
</dl>

</td></tr>
<tr><td><code id="cv.irsvm_fit_+3A_cost">cost</code></td>
<td>
<p>cost of constraints violation (default: 1)&mdash;it is the
&lsquo;C&rsquo;-constant of the regularization term in the Lagrange formulation. This is proportional to the inverse of <code>lambda</code> in <code>irglmreg</code>.</p>
</td></tr>
<tr><td><code id="cv.irsvm_fit_+3A_epsilon">epsilon</code></td>
<td>
<p>epsilon in the insensitive-loss function (default: 0.1)</p>
</td></tr>
<tr><td><code id="cv.irsvm_fit_+3A_balance">balance</code></td>
<td>
<p>for <code>type="C-classification", "nu-classification"</code> only</p>
</td></tr>
<tr><td><code id="cv.irsvm_fit_+3A_nfolds">nfolds</code></td>
<td>
<p>number of folds &gt;=3, default is 10</p>
</td></tr>
<tr><td><code id="cv.irsvm_fit_+3A_foldid">foldid</code></td>
<td>
<p>an optional vector of values between 1 and <code>nfold</code>
identifying what fold each observation is in. If supplied,
<code>nfold</code> can be missing and will be ignored.</p>
</td></tr>
<tr><td><code id="cv.irsvm_fit_+3A_trim_ratio">trim_ratio</code></td>
<td>
<p>a number between 0 and 1 for trimmed least squares, useful if <code>type="eps-regression"</code> or <code>"nu-regression"</code>.</p>
</td></tr> 
<tr><td><code id="cv.irsvm_fit_+3A_n.cores">n.cores</code></td>
<td>
<p>The number of CPU cores to use. The cross-validation loop
will attempt to send different CV folds off to different cores.</p>
</td></tr>
<tr><td><code id="cv.irsvm_fit_+3A_...">...</code></td>
<td>
<p>Other arguments that can be passed to <code>irsvm</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is the driving force behind <code>cv.irsvm</code>. Does a K-fold cross-validation to determine optimal tuning parameters  in SVM: <code>cost</code> and <code>gamma</code> if <code>kernel</code> is nonlinear. It can also choose <code>s</code> used in <code>cfun</code>.    
</p>


<h3>Value</h3>

<p>an object of class <code>"cv.irsvm"</code> is returned, which is a
list with the ingredients of the cross-validation fit.
</p>
<table role = "presentation">
<tr><td><code>residmat</code></td>
<td>
<p>matrix with row values for <code>kernel="linear"</code> are       <code>s, cost, error, k</code>, where <code>k</code> is the number of cross-validation fold. For nonlinear kernels, row values are <code>s, gamma, cost, error, k</code>. </p>
</td></tr>
<tr><td><code>cost</code></td>
<td>
<p>a value of <code>cost</code> that gives minimum cross-validated value in <code>irsvm</code>.</p>
</td></tr>
<tr><td><code>gamma</code></td>
<td>
<p>a value of <code>gamma</code> that gives minimum cross-validated value in <code>irsvm</code></p>
</td></tr>
<tr><td><code>s</code></td>
<td>
<p>value of <code>s</code> for <code>cfun</code> that gives minimum cross-validated value in <code>irsvm</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Zhu Wang &lt;zwang145@uthsc.edu&gt;</p>


<h3>References</h3>

<p>Zhu Wang (2024)
<em>Unified Robust Estimation</em>, <em>Australian &amp; New Zealand Journal         of      Statistics</em>. 66(1):77-102.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cv.irsvm">cv.irsvm</a></code> and <code><a href="#topic+irsvm">irsvm</a></code></p>

<hr>
<h2 id='cv.nclreg'>Cross-validation for nclreg</h2><span id='topic+cv.nclreg'></span><span id='topic+cv.nclreg.formula'></span><span id='topic+cv.nclreg.matrix'></span><span id='topic+cv.nclreg.default'></span><span id='topic+plot.cv.nclreg'></span><span id='topic+coef.cv.nclreg'></span>

<h3>Description</h3>

<p>Does k-fold cross-validation for nclreg, produces a plot,
and returns cross-validated loss values for <code>lambda</code></p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'formula'
cv.nclreg(formula, data, weights, offset=NULL, ...)
## S3 method for class 'matrix'
cv.nclreg(x, y, weights, offset=NULL, ...)
## Default S3 method:
cv.nclreg(x,  ...)
## S3 method for class 'cv.nclreg'
plot(x,se=TRUE,ylab=NULL, main=NULL, width=0.02, col="darkgrey", ...)
## S3 method for class 'cv.nclreg'
coef(object,which=object$lambda.which, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cv.nclreg_+3A_formula">formula</code></td>
<td>
<p>symbolic description of the model, see details.</p>
</td></tr>
<tr><td><code id="cv.nclreg_+3A_data">data</code></td>
<td>
<p>argument controlling formula processing
via <code><a href="stats.html#topic+model.frame">model.frame</a></code>.</p>
</td></tr>
<tr><td><code id="cv.nclreg_+3A_x">x</code></td>
<td>
<p><code>x</code> matrix as in <code>nclreg</code>. It could be object of <code>cv.nclreg</code>.</p>
</td></tr>
<tr><td><code id="cv.nclreg_+3A_y">y</code></td>
<td>
<p>response <code>y</code> as in <code>nclreg</code>.</p>
</td></tr>
<tr><td><code id="cv.nclreg_+3A_weights">weights</code></td>
<td>
<p>Observation weights; defaults to 1 per observation</p>
</td></tr>
<tr><td><code id="cv.nclreg_+3A_offset">offset</code></td>
<td>
<p>Not implemented yet</p>
</td></tr>
<tr><td><code id="cv.nclreg_+3A_object">object</code></td>
<td>
<p>object of <code>cv.nclreg</code></p>
</td></tr>
<tr><td><code id="cv.nclreg_+3A_which">which</code></td>
<td>
<p>Indices of the penalty parameter <code>lambda</code> at which
estimates are extracted. By default, the one which generates the optimal cross-validation value.</p>
</td></tr>
<tr><td><code id="cv.nclreg_+3A_se">se</code></td>
<td>
<p>logical value, if <code>TRUE</code>, standard error curve is also plotted</p>
</td></tr> 
<tr><td><code id="cv.nclreg_+3A_ylab">ylab</code></td>
<td>
<p>ylab on y-axis</p>
</td></tr>
<tr><td><code id="cv.nclreg_+3A_main">main</code></td>
<td>
<p>title of plot</p>
</td></tr>
<tr><td><code id="cv.nclreg_+3A_width">width</code></td>
<td>
<p>width of lines</p>
</td></tr>
<tr><td><code id="cv.nclreg_+3A_col">col</code></td>
<td>
<p>color of standard error curve</p>
</td></tr>
<tr><td><code id="cv.nclreg_+3A_...">...</code></td>
<td>
<p>Other arguments that can be passed to <code>nclreg</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function runs <code>nclreg</code> <code>nfolds</code>+1 times; the
first to compute the <code>lambda</code> sequence, and then to
compute the fit with each of the folds omitted. The error or the loss value is
accumulated, and the average value and standard deviation over the
folds is computed. Note that <code>cv.nclreg</code> can be used to search for
values for <code>alpha</code>: it is required to call <code>cv.nclreg</code> with a fixed vector <code>foldid</code> for different values of <code>alpha</code>. 
</p>


<h3>Value</h3>

<p>an object of class <code>"cv.nclreg"</code> is returned, which is a
list with the ingredients of the cross-validation fit.
</p>
<table role = "presentation">
<tr><td><code>fit</code></td>
<td>
<p>a fitted nclreg object for the full data.</p>
</td></tr>
<tr><td><code>residmat</code></td>
<td>
<p>matrix of loss values with row values for <code>lambda</code> and column values for <code>k</code>th cross-validation</p>
</td></tr>
<tr><td><code>bic</code></td>
<td>
<p>matrix of BIC values with row values for <code>lambda</code> and column values for <code>k</code>th cross-validation</p>
</td></tr>
<tr><td><code>cv</code></td>
<td>
<p>The mean cross-validated loss values - a vector of length
<code>length(lambda)</code>.</p>
</td></tr>
<tr><td><code>cv.error</code></td>
<td>
<p>estimate of standard error of <code>cv</code>.</p>
</td></tr>
<tr><td><code>foldid</code></td>
<td>
<p>an optional vector of values between 1 and <code>nfold</code>
identifying what fold each observation is in.</p>
</td></tr>
<tr><td><code>lambda</code></td>
<td>
<p>a vector of <code>lambda</code> values</p>
</td></tr> 
<tr><td><code>lambda.which</code></td>
<td>
<p>index of <code>lambda</code> that gives minimum <code>cv</code> value.</p>
</td></tr>
<tr><td><code>lambda.optim</code></td>
<td>
<p>value of <code>lambda</code> that gives minimum <code>cv</code> value.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Zhu Wang &lt;zwang145@uthsc.edu&gt;</p>


<h3>References</h3>

<p>Zhu Wang (2021),
<em>MM for Penalized Estimation</em>,
<em>TEST</em>,
doi: <a href="https://doi.org/10.1007/s11749-021-00770-2">10.1007/s11749-021-00770-2</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+nclreg">nclreg</a></code> and <code><a href="base.html#topic+plot">plot</a></code>, <code><a href="stats.html#topic+predict">predict</a></code>, and <code><a href="stats.html#topic+coef">coef</a></code> methods for <code>"cv.nclreg"</code> object.</p>

<hr>
<h2 id='cv.nclreg_fit'>Internal function of cross-validation for nclreg</h2><span id='topic+cv.nclreg_fit'></span>

<h3>Description</h3>

<p>Internal function to conduct k-fold cross-validation for nclreg, produces a plot,
and returns cross-validated loss values for <code>lambda</code></p>


<h3>Usage</h3>

<pre><code class='language-R'>cv.nclreg_fit(x, y, weights, offset, lambda=NULL, balance=TRUE, 
              rfamily=c("clossR", "closs", "gloss", "qloss"), s=1.5, 
              nfolds=10, foldid, type = c("loss", "error"), 
              plot.it=TRUE, se=TRUE, n.cores=2, trace=FALSE, 
              parallel=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cv.nclreg_fit_+3A_x">x</code></td>
<td>
<p><code>x</code> matrix as in <code>nclreg</code>.</p>
</td></tr>
<tr><td><code id="cv.nclreg_fit_+3A_y">y</code></td>
<td>
<p>response <code>y</code> as in <code>nclreg</code>.</p>
</td></tr>
<tr><td><code id="cv.nclreg_fit_+3A_weights">weights</code></td>
<td>
<p>Observation weights; defaults to 1 per observation</p>
</td></tr>
<tr><td><code id="cv.nclreg_fit_+3A_offset">offset</code></td>
<td>
<p>this can be used to specify an a priori known component to be   included in the linear predictor during fitting. This should be NULL or a numeric vector of length equal to the number of cases. Currently only one offset term can be included in the formula.</p>
</td></tr>
<tr><td><code id="cv.nclreg_fit_+3A_lambda">lambda</code></td>
<td>
<p>Optional user-supplied lambda sequence; default is
<code>NULL</code>, and <code>nclreg</code> chooses its own sequence</p>
</td></tr>
<tr><td><code id="cv.nclreg_fit_+3A_balance">balance</code></td>
<td>
<p>for <code>rfamily="closs", "gloss", "qloss"</code> only</p>
</td></tr>
<tr><td><code id="cv.nclreg_fit_+3A_rfamily">rfamily</code></td>
<td>
<p>response variable distribution and nonconvex loss function</p>
</td></tr>
<tr><td><code id="cv.nclreg_fit_+3A_s">s</code></td>
<td>
<p> nonconvex loss tuning parameter for robust regression and classification. </p>
</td></tr>
<tr><td><code id="cv.nclreg_fit_+3A_nfolds">nfolds</code></td>
<td>
<p>number of folds &gt;=3, default is 10</p>
</td></tr>
<tr><td><code id="cv.nclreg_fit_+3A_foldid">foldid</code></td>
<td>
<p>an optional vector of values between 1 and <code>nfold</code>
identifying what fold each observation is in. If supplied,
<code>nfold</code> can be missing and will be ignored.</p>
</td></tr>
<tr><td><code id="cv.nclreg_fit_+3A_type">type</code></td>
<td>
<p> cross-validation criteria. For <code>type="loss"</code>, loss function values and <code>type="error"</code> is misclassification error. </p>
</td></tr>
<tr><td><code id="cv.nclreg_fit_+3A_plot.it">plot.it</code></td>
<td>
<p> a logical value, to plot the estimated loss values if <code>TRUE</code>. </p>
</td></tr>
<tr><td><code id="cv.nclreg_fit_+3A_se">se</code></td>
<td>
<p> a logical value, to plot with standard errors. </p>
</td></tr>
<tr><td><code id="cv.nclreg_fit_+3A_n.cores">n.cores</code></td>
<td>
<p>The number of CPU cores to use. The cross-validation loop
will attempt to send different CV folds off to different cores.</p>
</td></tr>
<tr><td><code id="cv.nclreg_fit_+3A_trace">trace</code></td>
<td>
<p> a logical value, print progress of cross validation or not</p>
</td></tr>
<tr><td><code id="cv.nclreg_fit_+3A_parallel">parallel</code></td>
<td>
<p> a logical value, parallel computing or not</p>
</td></tr>
<tr><td><code id="cv.nclreg_fit_+3A_...">...</code></td>
<td>
<p>Other arguments that can be passed to <code>nclreg</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function runs <code>nclreg</code> <code>nfolds</code>+1 times; the
first to compute the <code>lambda</code> sequence, and then to
compute the fit with each of the folds omitted. The error or the loss value is
accumulated, and the average value and standard deviation over the
folds is computed. Note that <code>cv.nclreg</code> can be used to search for
values for <code>alpha</code>: it is required to call <code>cv.nclreg</code> with a fixed vector <code>foldid</code> for different values of <code>alpha</code>.
</p>


<h3>Value</h3>

<p>an object of class <code>"cv.nclreg"</code> is returned, which is a
list with the ingredients of the cross-validation fit.
</p>
<table role = "presentation">
<tr><td><code>fit</code></td>
<td>
<p>a fitted nclreg object for the full data.</p>
</td></tr>
<tr><td><code>residmat</code></td>
<td>
<p>matrix of loss values or errors with row values for <code>lambda</code> and column values for <code>k</code>th cross-validation</p>
</td></tr>
<tr><td><code>cv</code></td>
<td>
<p>The mean cross-validated loss values or errors - a vector of length
<code>length(lambda)</code>.</p>
</td></tr>
<tr><td><code>cv.error</code></td>
<td>
<p>estimate of standard error of <code>cv</code>.</p>
</td></tr>
<tr><td><code>foldid</code></td>
<td>
<p>an optional vector of values between 1 and <code>nfold</code>
identifying what fold each observation is in.</p>
</td></tr>
<tr><td><code>lambda</code></td>
<td>
<p>a vector of <code>lambda</code> values</p>
</td></tr> 
<tr><td><code>lambda.which</code></td>
<td>
<p>index of <code>lambda</code> that gives minimum <code>cv</code> value.</p>
</td></tr>
<tr><td><code>lambda.optim</code></td>
<td>
<p>value of <code>lambda</code> that gives minimum <code>cv</code> value.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Zhu Wang &lt;zwang145@uthsc.edu&gt;</p>


<h3>References</h3>

<p>Zhu Wang (2021), 
<em>MM for Penalized Estimation</em>, 
<em>TEST</em>,
doi: <a href="https://doi.org/10.1007/s11749-021-00770-2">10.1007/s11749-021-00770-2</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+nclreg">nclreg</a></code> and <code><a href="base.html#topic+plot">plot</a></code>, <code><a href="stats.html#topic+predict">predict</a></code>, and <code><a href="stats.html#topic+coef">coef</a></code> methods for <code>"cv.nclreg"</code> object.</p>

<hr>
<h2 id='cv.zipath'>Cross-validation for zipath</h2><span id='topic+cv.zipath'></span><span id='topic+cv.zipath.matrix'></span><span id='topic+cv.zipath.formula'></span><span id='topic+cv.zipath.default'></span><span id='topic+predict.cv.zipath'></span><span id='topic+coef.cv.zipath'></span>

<h3>Description</h3>

<p>Does k-fold cross-validation for zipath, produces a plot,
and returns cross-validated log-likelihood values for <code>lambda</code></p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'formula'
cv.zipath(formula, data, weights, offset=NULL, contrasts=NULL, ...)
## S3 method for class 'matrix'
cv.zipath(X, Z, Y, weights, offsetx=NULL, offsetz=NULL, ...)
## Default S3 method:
cv.zipath(X, ...)
## S3 method for class 'cv.zipath'
predict(object, newdata, ...)
## S3 method for class 'cv.zipath'
coef(object, which=object$lambda.which, model = c("full", "count", "zero"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cv.zipath_+3A_formula">formula</code></td>
<td>
<p>symbolic description of the model with an optional numeric vector <code>offset</code> with an a priori known component to be included in the linear predictor of the count model or zero model. Offset must be a variable in <code>data</code> if used, while this is optional in <code>zipath</code>. See an example below.</p>
</td></tr>
<tr><td><code id="cv.zipath_+3A_data">data</code></td>
<td>
<p>arguments controlling formula processing
via <code><a href="stats.html#topic+model.frame">model.frame</a></code>.</p>
</td></tr>
<tr><td><code id="cv.zipath_+3A_weights">weights</code></td>
<td>
<p>Observation weights; defaults to 1 per observation</p>
</td></tr>
<tr><td><code id="cv.zipath_+3A_offset">offset</code></td>
<td>
<p>optional numeric vector with an a priori known component to be
included in the linear predictor of the count model or zero model. See below   for an example.</p>
</td></tr>
<tr><td><code id="cv.zipath_+3A_x">X</code></td>
<td>
<p>predictor matrix of the count model</p>
</td></tr>
<tr><td><code id="cv.zipath_+3A_z">Z</code></td>
<td>
<p>predictor matrix of the zero model</p>
</td></tr>
<tr><td><code id="cv.zipath_+3A_y">Y</code></td>
<td>
<p>response variable</p>
</td></tr>
<tr><td><code id="cv.zipath_+3A_offsetx">offsetx</code>, <code id="cv.zipath_+3A_offsetz">offsetz</code></td>
<td>
<p>optional numeric vector with an a priori known component to be
included in the linear predictor of the count model (offsetx)or zero model (offsetz).</p>
</td></tr>
<tr><td><code id="cv.zipath_+3A_contrasts">contrasts</code></td>
<td>
<p>a list with elements <code>"count"</code> and <code>"zero"</code>
containing the contrasts corresponding to <code>levels</code> from the
respective models</p>
</td></tr> 
<tr><td><code id="cv.zipath_+3A_object">object</code></td>
<td>
<p>object of class <code>cv.zipath</code>.</p>
</td></tr>
<tr><td><code id="cv.zipath_+3A_newdata">newdata</code></td>
<td>
<p>optionally, a data frame in which to look for variables with
which to predict. If omitted, the original observations are used.</p>
</td></tr>
<tr><td><code id="cv.zipath_+3A_which">which</code></td>
<td>
<p>Indices of the pair of penalty parameters <code>lambda.count</code> and <code>lambda.zero</code> at which
estimates are extracted.  By default, the one which generates the optimal cross-validation value.</p>
</td></tr>
<tr><td><code id="cv.zipath_+3A_model">model</code></td>
<td>
<p>character specifying for which component of the model the
estimated coefficients should be extracted.</p>
</td></tr>
<tr><td><code id="cv.zipath_+3A_...">...</code></td>
<td>
<p>Other arguments that can be passed to <code>zipath</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function runs <code>zipath</code> <code>nfolds</code>+1 times; the
first to compute the <code>(lambda.count, lambda.zero)</code> sequence, and then to
compute the fit with each of the folds omitted. 
The model is fitted to the training data and then given the fitted model the log-likelihood is evaluated at the observations left out, i.e., the test data.
The average value of log-likelihood and standard deviation over the
folds is computed. Note that <code>cv.zipath</code> can be used to search for
values for <code>count.alpha</code> or <code>zero.alpha</code>: it is required to call <code>cv.zipath</code> with a fixed vector <code>foldid</code> for different values of <code>count.alpha</code> or <code>zero.alpha</code>.
</p>
<p>The methods for <code><a href="stats.html#topic+coef">coef</a></code> and <code><a href="stats.html#topic+predict">predict</a></code> were deprecated since version 0.3-25. In fact, the <code>fit</code> object was removed in the output of cv.zipath so that predict an object of cv.zipath is not feasible, and should be via zipath. See examples below. The reason for such a change is that cv.zipath can take both formula and matrix, hence <code>predict</code> on cv. zipath object can easily lead to problems in codes.
</p>
<p>When <code>family="negbin"</code>, it can be slow because there is a repeated search for the <code>theta</code> values by default. One may change the default values from <code>init.theta=NULL, theta.fixed=FALSE</code> to <code>init.theta=MLE, theta.fixed=TRUE</code>, where MLE is a number from glm.nb in the R package MASS or something desired. 
</p>


<h3>Value</h3>

<p>an object of class <code>"cv.zipath"</code> is returned, which is a
list with the components of the cross-validation fit.
</p>
<table role = "presentation">
<tr><td><code>fit</code></td>
<td>
<p>a fitted zipath object for the full data.</p>
</td></tr>
<tr><td><code>residmat</code></td>
<td>
<p>matrix for cross-validated log-likelihood at each <code>(count.lambda, zero.lambda)</code> sequence</p>
</td></tr>
<tr><td><code>bic</code></td>
<td>
<p>matrix of BIC values with row values for <code>lambda</code> and column values for <code>k</code>th cross-validation</p>
</td></tr>
<tr><td><code>cv</code></td>
<td>
<p>The mean cross-validated log-likelihood - a vector of length
<code>length(count.lambda)</code>.</p>
</td></tr>
<tr><td><code>cv.error</code></td>
<td>
<p>estimate of standard error of <code>cv</code>.</p>
</td></tr>
<tr><td><code>foldid</code></td>
<td>
<p>an optional vector of values between 1 and <code>nfold</code>
identifying what fold each observation is in.</p>
</td></tr> 
<tr><td><code>lambda.which</code></td>
<td>
<p>index of <code>(count.lambda, zero.lambda)</code> that gives maximum <code>cv</code>.</p>
</td></tr>
<tr><td><code>lambda.optim</code></td>
<td>
<p>value of <code>(count.lambda, zero.lambda)</code> that gives maximum <code>cv</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Zhu Wang &lt;zwang145@uthsc.edu&gt;</p>


<h3>References</h3>

<p>Zhu Wang, Shuangge Ma, Michael Zappitelli, Chirag Parikh, Ching-Yun Wang and Prasad Devarajan (2014)      <em>Penalized Count Data Regression with Application to Hospital Stay after Pediatric Cardiac Surgery</em>, <em>Statistical Methods in Medical Research</em>. 2014 Apr 17. [Epub ahead of print]
</p>
<p>Zhu Wang, Shuangge Ma, Ching-Yun Wang, Michael Zappitelli, Prasad Devarajan and Chirag R. Parikh (2014)
<em>EM for Regularized Zero Inflated Regression Models with Applications to Postoperative Morbidity after Cardiac Surgery in Children</em>, <em>Statistics in Medicine</em>. 33(29):5192-208.
</p>
<p>Zhu Wang, Shuangge Ma and Ching-Yun Wang (2015) <em>Variable selection for zero-inflated and overdispersed data with application to health care demand in Germany</em>, <em>Biometrical Journal</em>. 57(5):867-84.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+zipath">zipath</a></code> and <code><a href="base.html#topic+plot">plot</a></code>, <code><a href="stats.html#topic+predict">predict</a></code>, methods for <code>"cv.zipath"</code> object.</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data("bioChemists", package = "pscl")
fm_zip &lt;- zipath(art ~ . | ., data = bioChemists, family = "poisson", nlambda=10)
fm_cvzip &lt;- cv.zipath(art ~ . | ., data = bioChemists, family = "poisson", nlambda=10)
### prediction from the best model
pred &lt;- predict(fm_zip, newdata=bioChemists, which=fm_cvzip$lambda.which)
coef(fm_zip, which=fm_cvzip$lambda.which)
fm_znb &lt;- zipath(art ~ . | ., data = bioChemists, family = "negbin", nlambda=10)
fm_cvznb &lt;- cv.zipath(art ~ . | ., data = bioChemists, family = "negbin", nlambda=10)
pred &lt;- predict(fm_znb, which=fm_cvznb$lambda.which)
coef(fm_znb, which=fm_cvznb$lambda.which)
fm_zinb2 &lt;- zipath(art ~ . +offset(log(phd))| ., data = bioChemists, 
		      family = "poisson", nlambda=10)
fm_cvzinb2 &lt;- cv.zipath(art ~ . +offset(log(phd))| ., data = bioChemists, 
		      family = "poisson", nlambda=10)
pred &lt;- predict(fm_zinb2, which=fm_cvzinb2$lambda.which)
coef(fm_zinb2, which=fm_cvzinb2$lambda.which)

## End(Not run)
</code></pre>

<hr>
<h2 id='cv.zipath_fit'>Cross-validation for zipath</h2><span id='topic+cv.zipath_fit'></span>

<h3>Description</h3>

<p>Internal function k-fold cross-validation for zipath, produces a plot, and returns cross-validated log-likelihood values for <code>lambda</code></p>


<h3>Usage</h3>

<pre><code class='language-R'>cv.zipath_fit(X, Z, Y, weights, offsetx, offsetz, nlambda=100, lambda.count=NULL,
              lambda.zero=NULL, nfolds=10, foldid, plot.it=TRUE, se=TRUE, 
              n.cores=2, trace=FALSE, parallel=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cv.zipath_fit_+3A_x">X</code></td>
<td>
<p>predictor matrix of the count model</p>
</td></tr>
<tr><td><code id="cv.zipath_fit_+3A_z">Z</code></td>
<td>
<p>predictor matrix of the zero model</p>
</td></tr>
<tr><td><code id="cv.zipath_fit_+3A_y">Y</code></td>
<td>
<p>response variable</p>
</td></tr>
<tr><td><code id="cv.zipath_fit_+3A_weights">weights</code></td>
<td>
<p>optional numeric vector of weights.</p>
</td></tr>
<tr><td><code id="cv.zipath_fit_+3A_offsetx">offsetx</code></td>
<td>
<p>optional numeric vector with an a priori known component to be included in the linear predictor of the count model.</p>
</td></tr>
<tr><td><code id="cv.zipath_fit_+3A_offsetz">offsetz</code></td>
<td>
<p>optional numeric vector with an a priori known component to be included in the linear predictor of the zero model.</p>
</td></tr>
<tr><td><code id="cv.zipath_fit_+3A_nlambda">nlambda</code></td>
<td>
<p>number of <code>lambda</code> value, default value is 10.</p>
</td></tr>
<tr><td><code id="cv.zipath_fit_+3A_lambda.count">lambda.count</code></td>
<td>
<p>Optional user-supplied lambda.count sequence; default is
<code>NULL</code></p>
</td></tr>
<tr><td><code id="cv.zipath_fit_+3A_lambda.zero">lambda.zero</code></td>
<td>
<p>Optional user-supplied lambda.zero sequence; default is
<code>NULL</code></p>
</td></tr>
<tr><td><code id="cv.zipath_fit_+3A_nfolds">nfolds</code></td>
<td>
<p>number of folds &gt;=3, default is 10</p>
</td></tr>
<tr><td><code id="cv.zipath_fit_+3A_foldid">foldid</code></td>
<td>
<p>an optional vector of values between 1 and <code>nfold</code>
identifying what fold each observation is in. If supplied,
<code>nfold</code> can be missing and will be ignored.</p>
</td></tr>
<tr><td><code id="cv.zipath_fit_+3A_plot.it">plot.it</code></td>
<td>
<p> a logical value, to plot the estimated log-likelihood values if <code>TRUE</code>. </p>
</td></tr>
<tr><td><code id="cv.zipath_fit_+3A_se">se</code></td>
<td>
<p> a logical value, to plot with standard errors. </p>
</td></tr>
<tr><td><code id="cv.zipath_fit_+3A_n.cores">n.cores</code></td>
<td>
<p>The number of CPU cores to use. The cross-validation loop
will attempt to send different CV folds off to different cores.</p>
</td></tr>
<tr><td><code id="cv.zipath_fit_+3A_trace">trace</code></td>
<td>
<p> a logical value, print progress of cross-validation or not </p>
</td></tr>
<tr><td><code id="cv.zipath_fit_+3A_parallel">parallel</code></td>
<td>
<p> a logical value, parallel computing or not</p>
</td></tr>
<tr><td><code id="cv.zipath_fit_+3A_...">...</code></td>
<td>
<p>Other arguments that can be passed to <code>zipath</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function runs <code>zipath</code> <code>nfolds</code>+1 times; the
first to compute the <code>(lambda.count, lambda.zero)</code> sequence, and then to
compute the fit with each of the folds omitted. The log-likelihood value is
accumulated, and the average value and standard deviation over the
folds is computed. Note that <code>cv.zipath</code> can be used to search for
values for <code>count.alpha</code> or <code>zero.alpha</code>: it is required to call <code>cv.zipath</code> with a fixed vector <code>foldid</code> for different values of <code>count.alpha</code> or <code>zero.alpha</code>.
</p>
<p>The method for <code><a href="stats.html#topic+coef">coef</a></code> by default
return a single vector of coefficients, i.e., all coefficients are concatenated. By setting the <code>model</code>
argument, the estimates for the corresponding model components can be extracted.
</p>


<h3>Value</h3>

<p>an object of class <code>"cv.zipath"</code> is returned, which is a
list with the components of the cross-validation fit.
</p>
<table role = "presentation">
<tr><td><code>fit</code></td>
<td>
<p>a fitted zipath object for the full data.</p>
</td></tr>
<tr><td><code>residmat</code></td>
<td>
<p>matrix for cross-validated log-likelihood at each <code>(count.lambda, zero.lambda)</code> sequence</p>
</td></tr>
<tr><td><code>bic</code></td>
<td>
<p>matrix of BIC values with row values for <code>lambda</code> and column values for <code>k</code>th cross-validation</p>
</td></tr>
<tr><td><code>cv</code></td>
<td>
<p>The mean cross-validated log-likelihood - a vector of length
<code>length(count.lambda)</code>.</p>
</td></tr>
<tr><td><code>cv.error</code></td>
<td>
<p>estimate of standard error of <code>cv</code>.</p>
</td></tr>
<tr><td><code>foldid</code></td>
<td>
<p>an optional vector of values between 1 and <code>nfold</code>
identifying what fold each observation is in.</p>
</td></tr> 
<tr><td><code>lambda.which</code></td>
<td>
<p>index of <code>(count.lambda, zero.lambda)</code> that gives maximum <code>cv</code>.</p>
</td></tr>
<tr><td><code>lambda.optim</code></td>
<td>
<p>value of <code>(count.lambda, zero.lambda)</code> that gives maximum <code>cv</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Zhu Wang &lt;zwang145@uthsc.edu&gt;</p>


<h3>References</h3>

<p>Zhu Wang, Shuangge Ma, Michael Zappitelli, Chirag Parikh, Ching-Yun Wang and Prasad Devarajan (2014)      <em>Penalized Count Data Regression with Application to Hospital Stay after Pediatric Cardiac Surgery</em>, <em>Statistical Methods in Medical Research</em>. 2014 Apr 17. [Epub ahead of print]
</p>
<p>Zhu Wang, Shuangge Ma, Ching-Yun Wang, Michael Zappitelli, Prasad Devarajan and Chirag R. Parikh (2014)
<em>EM for Regularized Zero Inflated Regression Models with Applications to Postoperative Morbidity after Cardiac Surgery in Children</em>, <em>Statistics in Medicine</em>. 33(29):5192-208.
</p>
<p>Zhu Wang, Shuangge Ma and Ching-Yun Wang (2015) <em>Variable selection for zero-inflated and overdispersed data with application to health care demand in Germany</em>, <em>Biometrical Journal</em>. 57(5):867-84.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+zipath">zipath</a></code> and <code><a href="base.html#topic+plot">plot</a></code>, <code><a href="stats.html#topic+predict">predict</a></code>, and <code><a href="stats.html#topic+coef">coef</a></code> methods for <code>"cv.zipath"</code> object.</p>

<hr>
<h2 id='docvisits'> Doctor visits</h2><span id='topic+docvisits'></span>

<h3>Description</h3>

<p>A cohort of 3066 Americans over the age of 50 were studied on health care utilization, doctor
office visits.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(docvisits)</code></pre>


<h3>Source</h3>

<p>Stephane Heritier, Eva Cantoni, Samuel Copt and Maria-Pia Victoria-Fese (2009). <em>Robust Methods in Biostatistics</em>, John Wiley &amp; Sons</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(docvisits)
str(docvisits)
</code></pre>

<hr>
<h2 id='estfunReg'>Extract Empirical First Derivative of Log-likelihood Function</h2><span id='topic+estfunReg'></span><span id='topic+estfunReg.zipath'></span>

<h3>Description</h3>

<p>Generic function for extracting the empirical first derivative of log-likelihood function of a fitted regularized model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estfunReg(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="estfunReg_+3A_x">x</code></td>
<td>
<p>a fitted model object.</p>
</td></tr>
<tr><td><code id="estfunReg_+3A_...">...</code></td>
<td>
<p>arguments passed to methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix containing the empirical first derivative of log-likelihood functions.
Typically, this should be an <code class="reqn">n \times k</code> matrix corresponding
to <code class="reqn">n</code> observations and <code class="reqn">k</code> parameters. The columns should be named
as in <code><a href="stats.html#topic+coef">coef</a></code> or <code><a href="stats.html#topic+terms">terms</a></code>, respectively.
</p>


<h3>Author(s)</h3>

<p>Zhu Wang &lt;zwang145@uthsc.edu&gt;</p>


<h3>References</h3>

<p>Zhu Wang, Shuangge Ma and Ching-Yun Wang (2015) <em>Variable selection for zero-inflated and overdispersed data with application to health care demand in Germany</em>, <em>Biometrical Journal</em>. 57(5):867-84.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+zipath">zipath</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data("bioChemists", package = "pscl")
fm_zinb &lt;- zipath(art ~ . | ., data = bioChemists, family = "negbin", nlambda=10, maxit.em=1)
res &lt;- estfunReg(fm_zinb, which=which.min(fm_zinb$bic))
</code></pre>

<hr>
<h2 id='gfunc'>Convert response value to raw prediction in GLM</h2><span id='topic+gfunc'></span>

<h3>Description</h3>

<p>Compute response value to raw prediction such as linear predictor in GLM
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gfunc(mu, family, epsbino)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gfunc_+3A_mu">mu</code></td>
<td>
<p>vector of numbers as response value in GLM, for instance, probability estimation if <code>family=2</code></p>
</td></tr>
<tr><td><code id="gfunc_+3A_family">family</code></td>
<td>
<p>integer from 1-4, corresponding to &quot;gaussian&quot;, &quot;binomial&quot;, &quot;poisson&quot;, &quot;negbin&quot;, respectively</p>
</td></tr>
<tr><td><code id="gfunc_+3A_epsbino">epsbino</code></td>
<td>
<p>a small positive value for <code>family=2</code> to avoid numeric unstability</p>
</td></tr>
</table>


<h3>Value</h3>

<p>linear predictor f=x'b for predictor x and coefficient b if the model is linear</p>

<hr>
<h2 id='glmreg'>fit a GLM with lasso (or elastic net), snet or mnet regularization</h2><span id='topic+glmreg'></span><span id='topic+glmreg.formula'></span><span id='topic+glmreg.matrix'></span><span id='topic+glmreg.default'></span><span id='topic+logLik.glmreg'></span><span id='topic+deviance.glmreg'></span>

<h3>Description</h3>

<p>Fit a generalized linear model via penalized maximum likelihood.  The
regularization path is computed for the lasso (or elastic net penalty), scad (or snet) and mcp (or mnet penalty), at a grid
of values for the regularization parameter lambda. Fits
linear, logistic, Poisson and negative binomial (fixed scale parameter) regression models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'formula'
glmreg(formula, data, weights, offset=NULL, contrasts=NULL, 
x.keep=FALSE, y.keep=TRUE, ...)
## S3 method for class 'matrix'
glmreg(x, y, weights, offset=NULL, ...)
## Default S3 method:
glmreg(x,  ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="glmreg_+3A_formula">formula</code></td>
<td>
<p>symbolic description of the model, see details.</p>
</td></tr>
<tr><td><code id="glmreg_+3A_data">data</code></td>
<td>
<p>argument controlling formula processing
via <code><a href="stats.html#topic+model.frame">model.frame</a></code>.</p>
</td></tr>
<tr><td><code id="glmreg_+3A_weights">weights</code></td>
<td>
<p>optional numeric vector of weights. If <code>standardize=TRUE</code>, weights are renormalized to weights/sum(weights). If <code>standardize=FALSE</code>, weights are kept as original input</p>
</td></tr>
<tr><td><code id="glmreg_+3A_offset">offset</code></td>
<td>
<p>this can be used to specify an a priori known component to be included in the linear predictor during fitting. This should be NULL or a numeric vector of length equal to the number of cases. Currently only one offset term can be included in the formula.</p>
</td></tr>
<tr><td><code id="glmreg_+3A_x">x</code></td>
<td>
<p>input matrix, of dimension nobs x nvars; each row is an
observation vector</p>
</td></tr>
<tr><td><code id="glmreg_+3A_y">y</code></td>
<td>
<p>response variable. Quantitative for <code>family="gaussian"</code>.
Non-negative counts for <code>family="poisson"</code> or <code>family="negbin"</code>. For
<code>family="binomial"</code> should be either a factor with two levels or
a vector of proportions.</p>
</td></tr>
<tr><td><code id="glmreg_+3A_x.keep">x.keep</code>, <code id="glmreg_+3A_y.keep">y.keep</code></td>
<td>
<p>logical values: keep response variables or keep response variable?</p>
</td></tr> 
<tr><td><code id="glmreg_+3A_contrasts">contrasts</code></td>
<td>
<p>the contrasts corresponding to <code>levels</code> from the
respective models</p>
</td></tr>
<tr><td><code id="glmreg_+3A_...">...</code></td>
<td>
<p>Other arguments passing to <code>glmreg_fit</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The sequence of models implied by <code>lambda</code> is fit by coordinate
descent. For <code>family="gaussian"</code> this is the lasso, mcp or scad sequence if
<code>alpha=1</code>, else it is the enet, mnet or snet sequence.
For the other families, this is a lasso (mcp, scad) or elastic net (mnet, snet) regularization path
for fitting the generalized linear regression
paths, by maximizing the appropriate penalized log-likelihood.
Note that the objective function for <code>"gaussian"</code> is </p>
<p style="text-align: center;"><code class="reqn">1/2*
  weights*RSS + \lambda*penalty,</code>
</p>
<p> if <code>standardize=FALSE</code> and </p>
<p style="text-align: center;"><code class="reqn">1/2*
  \frac{weights}{\sum(weights)}*RSS + \lambda*penalty,</code>
</p>
<p> if <code>standardize=TRUE</code>. For the other models it is
</p>
<p style="text-align: center;"><code class="reqn">-\sum (weights * loglik) + \lambda*penalty</code>
</p>
<p> if <code>standardize=FALSE</code> and </p>
<p style="text-align: center;"><code class="reqn">-\frac{weights}{\sum(weights)} * loglik + \lambda*penalty</code>
</p>
<p> if <code>standardize=TRUE</code>.
</p>


<h3>Value</h3>

<p>An object with S3 class <code>"glmreg"</code> for the various types of models.
</p>
<table role = "presentation">
<tr><td><code>call</code></td>
<td>
<p>the call that produced this object</p>
</td></tr>
<tr><td><code>b0</code></td>
<td>
<p>Intercept sequence of length <code>length(lambda)</code></p>
</td></tr>
<tr><td><code>beta</code></td>
<td>
<p>A <code>nvars x
      length(lambda)</code> matrix of coefficients.</p>
</td></tr>
<tr><td><code>lambda</code></td>
<td>
<p>The actual sequence of <code>lambda</code> values used</p>
</td></tr>
<tr><td><code>offset</code></td>
<td>
<p>the offset vector used.</p>
</td></tr>
<tr><td><code>resdev</code></td>
<td>
<p>The computed deviance (for <code>"gaussian"</code>, this
is the R-square). The deviance calculations incorporate weights if
present in the model. The deviance is defined to be 2*(loglike_sat -
loglike), where loglike_sat is the log-likelihood for the saturated
model (a model with a free parameter per observation). </p>
</td></tr>
<tr><td><code>nulldev</code></td>
<td>
<p>Null deviance (per observation). This is defined to
be  2*(loglike_sat -loglike(Null)); The NULL model refers to the
intercept model.</p>
</td></tr>
<tr><td><code>nobs</code></td>
<td>
<p>number of observations</p>
</td></tr>
<tr><td><code>pll</code></td>
<td>
<p>penalized log-likelihood values for standardized coefficients in the IRLS iterations. For <code>family="gaussian"</code>, not implemented yet.</p>
</td></tr>
<tr><td><code>pllres</code></td>
<td>
<p>penalized log-likelihood value for the estimated model on the original scale of coefficients</p>
</td></tr>
<tr><td><code>fitted.values</code></td>
<td>
<p>the fitted mean values, obtained by transforming the linear predictors by the inverse of the link function. </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Zhu Wang &lt;zwang145@uthsc.edu&gt;</p>


<h3>References</h3>

<p>Breheny, P. and Huang, J. (2011) <em>Coordinate descent
algorithms for nonconvex penalized regression, with applications to
biological feature selection</em>. <em>Ann. Appl. Statist.</em>, <b>5</b>: 232-253.
</p>
<p>Zhu Wang, Shuangge Ma, Michael Zappitelli, Chirag Parikh, Ching-Yun Wang and Prasad Devarajan (2014) 
<em>Penalized Count Data Regression with Application to Hospital Stay after Pediatric Cardiac Surgery</em>, <em>Statistical Methods in Medical Research</em>.
2014 Apr 17. [Epub ahead of print]
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+print">print</a></code>, <code><a href="stats.html#topic+predict">predict</a></code>, <code><a href="stats.html#topic+coef">coef</a></code> and <code><a href="base.html#topic+plot">plot</a></code> methods, and the <code><a href="#topic+cv.glmreg">cv.glmreg</a></code> function.</p>


<h3>Examples</h3>

<pre><code class='language-R'>#binomial
x=matrix(rnorm(100*20),100,20)
g2=sample(0:1,100,replace=TRUE)
fit2=glmreg(x,g2,family="binomial")
#poisson and negative binomial
data("bioChemists", package = "pscl")
fm_pois &lt;- glmreg(art ~ ., data = bioChemists, family = "poisson")
coef(fm_pois)
fm_nb1 &lt;- glmreg(art ~ ., data = bioChemists, family = "negbin", theta=1)
coef(fm_nb1)
#offset
x &lt;- matrix(rnorm(100*20),100,20)
y &lt;- rpois(100, lambda=1)
exposure &lt;- rep(0.5, length(y))
fit2 &lt;- glmreg(x,y, lambda=NULL, nlambda=10, lambda.min.ratio=1e-4, 
	       offset=log(exposure), family="poisson")
predict(fit2, newx=x, newoffset=log(exposure))
## Not run: 
fm_nb2 &lt;- glmregNB(art ~ ., data = bioChemists)
coef(fm_nb2)

## End(Not run)
</code></pre>

<hr>
<h2 id='glmreg_fit'>Internal function to fit a GLM with lasso (or elastic net), snet and mnet regularization</h2><span id='topic+glmreg_fit'></span>

<h3>Description</h3>

<p>Fit a generalized linear model via penalized maximum likelihood.  The
regularization path is computed for the lasso (or elastic net penalty), snet and mnet penalty, at a grid
of values for the regularization parameter lambda. Fits
linear, logistic, Poisson and negative binomial (fixed scale parameter) regression models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>glmreg_fit(x, y, weights, start=NULL, etastart=NULL, mustart=NULL, offset = NULL, 
           nlambda=100, lambda=NULL, lambda.min.ratio=ifelse(nobs&lt;nvars,.05, .001), 
           alpha=1, gamma=3, rescale=TRUE, standardize=TRUE, intercept=TRUE, 
           penalty.factor = rep(1, nvars), thresh=1e-6, eps.bino=1e-5, maxit=1000, 
           eps=.Machine$double.eps, theta, 
           family=c("gaussian", "binomial", "poisson", "negbin"),
           penalty=c("enet","mnet","snet"), convex=FALSE, x.keep=FALSE, y.keep=TRUE,
           trace=FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="glmreg_fit_+3A_x">x</code></td>
<td>
<p>input matrix, of dimension nobs x nvars; each row is an
observation vector.</p>
</td></tr> 
<tr><td><code id="glmreg_fit_+3A_y">y</code></td>
<td>
<p>response variable. Quantitative for <code>family="gaussian"</code>.
Non-negative counts for <code>family="poisson"</code> or <code>family="negbin"</code>. For
<code>family="binomial"</code> should be either a factor with two levels or
a vector of proportions.</p>
</td></tr> 
<tr><td><code id="glmreg_fit_+3A_weights">weights</code></td>
<td>
<p>observation weights. Can be total counts if responses are proportion matrices. Default is 1 for each observation</p>
</td></tr>
<tr><td><code id="glmreg_fit_+3A_start">start</code></td>
<td>
<p>starting values for the parameters in the linear predictor.</p>
</td></tr>
<tr><td><code id="glmreg_fit_+3A_etastart">etastart</code></td>
<td>
<p>starting values for the linear predictor.</p>
</td></tr>
<tr><td><code id="glmreg_fit_+3A_mustart">mustart</code></td>
<td>
<p>starting values for the vector of means.</p>
</td></tr>
<tr><td><code id="glmreg_fit_+3A_offset">offset</code></td>
<td>
<p>this can be used to specify an a priori known component to be included in the linear predictor during fitting. This should be NULL or a numeric vector of length equal to the number of cases. Currently only one offset term can be included in the formula.</p>
</td></tr>
<tr><td><code id="glmreg_fit_+3A_nlambda">nlambda</code></td>
<td>
<p>The number of <code>lambda</code> values - default is 100. The sequence may be truncated before <code>nlambda</code> is reached if a close to saturated model is fitted. See also <code>satu</code>.</p>
</td></tr>
<tr><td><code id="glmreg_fit_+3A_lambda">lambda</code></td>
<td>
<p> by default, the algorithm provides a sequence of regularization values, or a user supplied <code>lambda</code> sequence. When <code>alpha=0</code>, the largest lambda value is not defined (infinity). Thus, the largest <code>lambda</code> for <code>alpha=0.001</code> is computed, and the sequence of <code>lambda</code> values is calculated afterwards. </p>
</td></tr>
<tr><td><code id="glmreg_fit_+3A_lambda.min.ratio">lambda.min.ratio</code></td>
<td>
<p>Smallest value for <code>lambda</code>, as a fraction of
<code>lambda.max</code>, the (data derived) entry value (i.e. the smallest
value for which all coefficients are zero except the intercept). Note, there is no closed formula for <code>lambda.max</code> in general. If <code>rescale=TRUE</code>, <code>lambda.max</code> is the same for <code>penalty="mnet" or "snet"</code>. Otherwise, some modifications are required. For instance, for small <code>gamma</code> value, half of the square root (if <code>lambda.max</code> is too small) of the computed <code>lambda.max</code> can be used when <code>penalty="mnet" or "snet"</code>. The default of <code>lambda.min.ratio</code> depends on the
sample size <code>nobs</code> relative to the number of variables
<code>nvars</code>. If <code>nobs &gt; nvars</code>, the default is <code>0.001</code>,
close to zero.  If <code>nobs &lt; nvars</code>, the default is <code>0.05</code>.</p>
</td></tr>
<tr><td><code id="glmreg_fit_+3A_alpha">alpha</code></td>
<td>
<p>The <code class="reqn">L_2</code> penalty mixing parameter, with
<code class="reqn">0 \le alpha\le 1</code>. <code>alpha=1</code> is lasso (mcp, scad) penalty; and <code>alpha=0</code> the ridge penalty. However, if <code>alpha=0</code>, one must provide <code>lambda</code> values.</p>
</td></tr>
<tr><td><code id="glmreg_fit_+3A_gamma">gamma</code></td>
<td>
<p>The tuning parameter of the <code>snet</code> or <code>mnet</code> penalty.</p>
</td></tr>
<tr><td><code id="glmreg_fit_+3A_rescale">rescale</code></td>
<td>
<p>logical value, if TRUE, adaptive rescaling of the penalty parameter for <code>penalty="mnet"</code> or <code>penalty="snet"</code> with <code>family</code> other than &quot;gaussian&quot;. See reference</p>
</td></tr>
<tr><td><code id="glmreg_fit_+3A_standardize">standardize</code></td>
<td>
<p>logical value for x variable standardization, prior to
fitting the model sequence. The coefficients are always returned on
the original scale. Default is <code>standardize=TRUE</code>.</p>
</td></tr>
<tr><td><code id="glmreg_fit_+3A_intercept">intercept</code></td>
<td>
<p>logical value: if TRUE (default), intercept(s) are fitted; otherwise, intercept(s) are set to zero</p>
</td></tr>
<tr><td><code id="glmreg_fit_+3A_penalty.factor">penalty.factor</code></td>
<td>
<p>This is a number that multiplies <code>lambda</code> to allow
differential shrinkage of coefficients. Can be 0 for some variables, which implies
no shrinkage, and that variable is always included in the
model. Default is same shrinkage for all variables.</p>
</td></tr>
<tr><td><code id="glmreg_fit_+3A_thresh">thresh</code></td>
<td>
<p>Convergence threshold for coordinate descent. Defaults value is <code>1e-6</code>.</p>
</td></tr>
<tr><td><code id="glmreg_fit_+3A_eps.bino">eps.bino</code></td>
<td>
<p>a lower bound of probabilities to be truncated, for computing weights and related values when <code>family="binomial"</code>. It is also used when <code>family="negbin"</code>.</p>
</td></tr>
<tr><td><code id="glmreg_fit_+3A_maxit">maxit</code></td>
<td>
<p>Maximum number of coordinate descent iterations for each <code>lambda</code> value; default is 1000.</p>
</td></tr>
<tr><td><code id="glmreg_fit_+3A_eps">eps</code></td>
<td>
<p>If a coefficient is less than <code>eps</code> in magnitude, then it is reported to be 0</p>
</td></tr>
<tr><td><code id="glmreg_fit_+3A_convex">convex</code></td>
<td>
<p>Calculate index for which objective function ceases to
be locally convex? Default is FALSE and only useful if <code>penalty="mnet" or "snet"</code>.</p>
</td></tr>
<tr><td><code id="glmreg_fit_+3A_theta">theta</code></td>
<td>
<p> an overdispersion scaling parameter for <code>family="negbin"</code></p>
</td></tr>
<tr><td><code id="glmreg_fit_+3A_family">family</code></td>
<td>
<p>Response type (see above)</p>
</td></tr>
<tr><td><code id="glmreg_fit_+3A_penalty">penalty</code></td>
<td>
<p>Type of regularization</p>
</td></tr>
<tr><td><code id="glmreg_fit_+3A_x.keep">x.keep</code>, <code id="glmreg_fit_+3A_y.keep">y.keep</code></td>
<td>
<p> For glmreg: logical values indicating whether the response
vector and model matrix used in the fitting process should be
returned as components of the returned value.
For glmreg_fit: x is a design matrix of dimension n * p,
and x is a vector of observations of length n.</p>
</td></tr>
<tr><td><code id="glmreg_fit_+3A_trace">trace</code></td>
<td>
<p>If <code>TRUE</code>, fitting progress is reported</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The sequence of models implied by <code>lambda</code> is fit by coordinate
descent. For <code>family="gaussian"</code> this is the lasso, mcp or scad sequence if
<code>alpha=1</code>, else it is the enet, mnet or snet sequence.
For the other families, this is a lasso (mcp, scad) or elastic net (mnet, snet) regularization path
for fitting the generalized linear regression
paths, by maximizing the appropriate penalized log-likelihood.
Note that the objective function for <code>"gaussian"</code> is </p>
<p style="text-align: center;"><code class="reqn">1/2*
  weights*RSS + \lambda*penalty,</code>
</p>
<p> if <code>standardize=FALSE</code> and </p>
<p style="text-align: center;"><code class="reqn">1/2*
  \frac{weights}{\sum(weights)}*RSS + \lambda*penalty,</code>
</p>
<p> if <code>standardize=TRUE</code>. For the other models it is
</p>
<p style="text-align: center;"><code class="reqn">-\sum (weights * loglik) + \lambda*penalty</code>
</p>
<p> if <code>standardize=FALSE</code> and </p>
<p style="text-align: center;"><code class="reqn">-\frac{weights}{\sum(weights)} * loglik + \lambda*penalty</code>
</p>
<p> if <code>standardize=TRUE</code>. 
</p>


<h3>Value</h3>

<p>An object with S3 class <code>"glmreg"</code> for the various types of models.
</p>
<table role = "presentation">
<tr><td><code>call</code></td>
<td>
<p>the call that produced the model fit</p>
</td></tr>
<tr><td><code>b0</code></td>
<td>
<p>Intercept sequence of length <code>length(lambda)</code></p>
</td></tr>
<tr><td><code>beta</code></td>
<td>
<p>A <code>nvars x length(lambda)</code> matrix of coefficients.</p>
</td></tr>
<tr><td><code>lambda</code></td>
<td>
<p>The actual sequence of <code>lambda</code> values used</p>
</td></tr>
<tr><td><code>satu</code></td>
<td>
<p>satu=1 if a saturated model (deviance/null deviance &lt; 0.05) is fit. Otherwise satu=0. The number of <code>nlambda</code> sequence may be truncated before <code>nlambda</code> is reached if <code>satu=1</code>.</p>
</td></tr>
<tr><td><code>dev</code></td>
<td>
<p>The computed deviance (for <code>"gaussian"</code>, this
is the R-square). The deviance calculations incorporate weights if
present in the model. The deviance is defined to be 2*(loglike_sat -
loglike), where loglike_sat is the log-likelihood for the saturated
model (a model with a free parameter per observation). </p>
</td></tr>
<tr><td><code>nulldev</code></td>
<td>
<p>Null deviance (per observation). This is defined to
be  2*(loglike_sat -loglike(Null)); The NULL model refers to the
intercept model.</p>
</td></tr>
<tr><td><code>nobs</code></td>
<td>
<p>number of observations</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Zhu Wang &lt;zwang145@uthsc.edu&gt;</p>


<h3>References</h3>

<p>Breheny, P. and Huang, J. (2011) <em>Coordinate descent
algorithms for nonconvex penalized regression, with applications to
biological feature selection</em>. <em>Ann. Appl. Statist.</em>, <b>5</b>: 232-253.
</p>
<p>Zhu Wang, Shuangge Ma, Michael Zappitelli, Chirag Parikh, Ching-Yun Wang and Prasad Devarajan (2014)
<em>Penalized Count Data Regression with Application to Hospital Stay after Pediatric Cardiac Surgery</em>, <em>Statistical Methods in Medical Research</em>. 2014 Apr 17. [Epub ahead of print]
</p>


<h3>See Also</h3>

<p><code><a href="#topic+glmreg">glmreg</a></code></p>

<hr>
<h2 id='glmregNB'>fit a negative binomial model with lasso (or elastic net), snet and mnet regularization</h2><span id='topic+glmregNB'></span><span id='topic+glmregNegbin'></span>

<h3>Description</h3>

<p>Fit a negative binomial linear model via penalized maximum likelihood. The regularization path is computed for the lasso (or elastic net penalty), snet and mnet penalty, at a grid of values for the regularization parameter lambda. </p>


<h3>Usage</h3>

<pre><code class='language-R'>glmregNB(formula, data, weights, offset=NULL, nlambda = 100, lambda=NULL, 
         lambda.min.ratio = ifelse(nobs&lt;nvars,0.05,0.001), alpha=1, gamma=3, 
         rescale=TRUE, standardize = TRUE, penalty.factor = rep(1, nvars), 
         thresh = 0.001, maxit.theta = 10, maxit=1000, eps=.Machine$double.eps,
         trace=FALSE, start = NULL, etastart = NULL, mustart = NULL, 
         theta.fixed=FALSE, theta0=NULL, init.theta=NULL, link=log, 
         penalty=c("enet","mnet","snet"), method="glmreg_fit", model=TRUE, 
         x.keep=FALSE, y.keep=TRUE, contrasts=NULL, convex=FALSE, 
         parallel=TRUE, n.cores=2, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="glmregNB_+3A_formula">formula</code></td>
<td>
<p>formula used to describe a model.</p>
</td></tr>
<tr><td><code id="glmregNB_+3A_data">data</code></td>
<td>
<p>argument controlling formula processing
via <code><a href="stats.html#topic+model.frame">model.frame</a></code>.</p>
</td></tr> 
<tr><td><code id="glmregNB_+3A_weights">weights</code></td>
<td>
<p>an optional vector of &lsquo;prior weights&rsquo; to be used in the fitting process. Should be <code>NULL</code> or a numeric vector. Default is a vector of 1s with equal weight for each observation.</p>
</td></tr>
<tr><td><code id="glmregNB_+3A_offset">offset</code></td>
<td>
<p>optional numeric vector with an a priori known component to be
included in the linear predictor of the model.</p>
</td></tr>
<tr><td><code id="glmregNB_+3A_nlambda">nlambda</code></td>
<td>
<p>The number of <code>lambda</code> values - default is 100.</p>
</td></tr>
<tr><td><code id="glmregNB_+3A_lambda">lambda</code></td>
<td>
<p>A user supplied <code>lambda</code> sequence</p>
</td></tr>
<tr><td><code id="glmregNB_+3A_lambda.min.ratio">lambda.min.ratio</code></td>
<td>
<p>Smallest value for <code>lambda</code>, as a fraction of
<code>lambda.max</code>, the (data derived) entry value (i.e. the smallest
value for which all coefficients are zero). The default depends on the
sample size <code>nobs</code> relative to the number of variables
<code>nvars</code>. If <code>nobs &gt; nvars</code>, the default is <code>0.001</code>,
close to zero.  If <code>nobs &lt; nvars</code>, the default is <code>0.05</code>.
</p>
</td></tr>
<tr><td><code id="glmregNB_+3A_alpha">alpha</code></td>
<td>
<p>The L2 penalty mixing parameter, with
<code class="reqn">0\le\alpha\le 1</code>. <code>alpha=1</code> is lasso (mcp, scad) penalty; and <code>alpha=0</code> the ridge penalty.</p>
</td></tr>
<tr><td><code id="glmregNB_+3A_gamma">gamma</code></td>
<td>
<p>The tuning parameter of the <code>snet</code> or <code>mnet</code> penalty.</p>
</td></tr>
<tr><td><code id="glmregNB_+3A_rescale">rescale</code></td>
<td>
<p>logical value, if TRUE, adaptive rescaling of the penalty parameter for <code>penalty="mnet"</code> or <code>penalty="snet"</code> with <code>family</code> other than &quot;gaussian&quot;. See reference</p>
</td></tr>
<tr><td><code id="glmregNB_+3A_standardize">standardize</code></td>
<td>
<p>Logical flag for x variable standardization, prior to
fitting the model sequence. The coefficients are always returned on
the original scale. Default is <code>standardize=TRUE</code>.
If variables are in the same units already, you might not wish to
standardize.</p>
</td></tr>
<tr><td><code id="glmregNB_+3A_penalty.factor">penalty.factor</code></td>
<td>
<p>This is a number that multiplies <code>lambda</code> to allow
differential shrinkage of coefficients. Can be 0 for some variables, which implies
no shrinkage, and that variable is always included in the
model. Default is same shrinkage for all variables.</p>
</td></tr>
<tr><td><code id="glmregNB_+3A_thresh">thresh</code></td>
<td>
<p>Convergence threshold for coordinate descent. Defaults value is <code>1e-6</code>.</p>
</td></tr>
<tr><td><code id="glmregNB_+3A_maxit.theta">maxit.theta</code></td>
<td>
<p>Maximum number of iterations for estimating <code>theta</code> scaling parameter</p>
</td></tr>
<tr><td><code id="glmregNB_+3A_maxit">maxit</code></td>
<td>
<p>Maximum number of coordinate descent iterations for each <code>lambda</code> value; default is 1000.</p>
</td></tr>
<tr><td><code id="glmregNB_+3A_eps">eps</code></td>
<td>
<p>If a number is less than <code>eps</code> in magnitude, then this number is considered as 0</p>
</td></tr>
<tr><td><code id="glmregNB_+3A_trace">trace</code></td>
<td>
<p>If <code>TRUE</code>, fitting progress is reported</p>
</td></tr>
<tr><td><code id="glmregNB_+3A_start">start</code>, <code id="glmregNB_+3A_etastart">etastart</code>, <code id="glmregNB_+3A_mustart">mustart</code>, <code id="glmregNB_+3A_...">...</code></td>
<td>
<p> arguments for the <code>link{glmreg}</code> function</p>
</td></tr>
<tr><td><code id="glmregNB_+3A_init.theta">init.theta</code></td>
<td>
<p> initial scaling parameter <code>theta</code></p>
</td></tr>
<tr><td><code id="glmregNB_+3A_theta.fixed">theta.fixed</code></td>
<td>
<p>Estimate scale parameter theta? Default is FALSE. Note, the algorithm may become slow. In this case, one may use <code>glmreg</code> function with <code>family="negbin"</code>, and a fixed <code>theta</code></p>
</td></tr></table>
<p>.
</p>
<table role = "presentation">
<tr><td><code id="glmregNB_+3A_theta0">theta0</code></td>
<td>
<p>initial scale parameter vector theta, with length <code>nlambda</code> if <code>theta.fixed=TRUE</code>. Default is NULL</p>
</td></tr>
<tr><td><code id="glmregNB_+3A_convex">convex</code></td>
<td>
<p>Calculate index for which objective function ceases to
be locally convex? Default is FALSE and only useful if <code>penalty="mnet" or "snet"</code>.</p>
</td></tr>
<tr><td><code id="glmregNB_+3A_link">link</code></td>
<td>
<p>link function, default is <code>log</code></p>
</td></tr>
<tr><td><code id="glmregNB_+3A_penalty">penalty</code></td>
<td>
<p>Type of regularization</p>
</td></tr>
<tr><td><code id="glmregNB_+3A_method">method</code></td>
<td>
<p>estimation method</p>
</td></tr>
<tr><td><code id="glmregNB_+3A_model">model</code>, <code id="glmregNB_+3A_x.keep">x.keep</code>, <code id="glmregNB_+3A_y.keep">y.keep</code></td>
<td>
<p>logicals. If <code>TRUE</code> the corresponding components
of the fit (model frame, response, model matrix) are returned.</p>
</td></tr>
<tr><td><code id="glmregNB_+3A_contrasts">contrasts</code></td>
<td>
<p>the contrasts corresponding to <code>levels</code> from the
respective models</p>
</td></tr>
<tr><td><code id="glmregNB_+3A_parallel">parallel</code>, <code id="glmregNB_+3A_n.cores">n.cores</code></td>
<td>
<p>a logical value, parallel computing or not for sequence of <code>lambda</code> with the number of CPU cores to use. The <code>lambda</code> loop will attempt to send different <code>lambda</code> off to different cores.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The sequence of models implied by <code>lambda</code> is fit by coordinate
descent. This is a lasso (mcp, scad) or elastic net (mnet, snet) regularization path
for fitting the negative binomial linear regression
paths, by maximizing the penalized log-likelihood.
Note that the objective function is 
</p>
<p style="text-align: center;"><code class="reqn">-\sum (weights * loglik) + \lambda*penalty</code>
</p>
<p> if <code>standardize=FALSE</code> and </p>
<p style="text-align: center;"><code class="reqn">-\frac{weights}{\sum(weights)} * loglik + \lambda*penalty</code>
</p>
<p> if <code>standardize=TRUE</code>.
</p>


<h3>Value</h3>

<p>An object with S3 class <code>"glmreg", "glmregNB"</code> for the various types of models.
</p>
<table role = "presentation">
<tr><td><code>call</code></td>
<td>
<p>the call that produced the model fit</p>
</td></tr>
<tr><td><code>b0</code></td>
<td>
<p>Intercept sequence of length <code>length(lambda)</code></p>
</td></tr>
<tr><td><code>beta</code></td>
<td>
<p>A <code>nvars x
      length(lambda)</code> matrix of coefficients.</p>
</td></tr>
<tr><td><code>lambda</code></td>
<td>
<p>The actual sequence of <code>lambda</code> values used</p>
</td></tr>
<tr><td><code>resdev</code></td>
<td>
<p>The computed deviance. The deviance calculations incorporate weights if
present in the model. The deviance is defined to be 2*(loglike_sat -
loglike), where loglike_sat is the log-likelihood for the saturated
model (a model with a free parameter per observation). </p>
</td></tr>
<tr><td><code>nulldev</code></td>
<td>
<p>Null deviance (per observation). This is defined to
be  2*(loglike_sat -loglike(Null)); The NULL model refers to the
intercept model.</p>
</td></tr>
<tr><td><code>nobs</code></td>
<td>
<p>number of observations</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Zhu Wang &lt;zwang145@uthsc.edu&gt;</p>


<h3>References</h3>

<p>                                                                          Zhu Wang, Shuangge Ma, Michael Zappitelli, Chirag Parikh, Ching-Yun Wang and Prasad Devarajan (2014)      <em>Penalized Count Data Regression with Application to Hospital Stay after Pediatric Cardiac Surgery</em>, <em>Statistical Methods in Medical Research</em>. 2014 Apr 17. [Epub ahead of print]
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+print">print</a></code>, <code><a href="stats.html#topic+predict">predict</a></code>, <code><a href="stats.html#topic+coef">coef</a></code> and <code><a href="base.html#topic+plot">plot</a></code> methods, and the <code><a href="#topic+cv.glmregNB">cv.glmregNB</a></code> function.</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data("bioChemists", package = "pscl")
system.time(fm_nb1 &lt;- glmregNB(art ~ ., data = bioChemists, parallel=FALSE))
system.time(fm_nb2 &lt;- glmregNB(art ~ ., data = bioChemists, parallel=TRUE, n.cores=2))
coef(fm_nb1)
### ridge regression
fm &lt;- glmregNB(art ~ ., alpha=0, data = bioChemists, lambda=seq(0.001, 1, by=0.01))
fm &lt;- cv.glmregNB(art ~ ., alpha=0, data = bioChemists, lambda=seq(0.001, 1, by=0.01))

## End(Not run)
</code></pre>

<hr>
<h2 id='hessianReg'>Hessian Matrix of Regularized Estimators</h2><span id='topic+hessianReg'></span>

<h3>Description</h3>

<p>Constructing Hessian matrix for regularized regression parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hessianReg(x, which, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hessianReg_+3A_x">x</code></td>
<td>
<p>a fitted model object.</p>
</td></tr>
<tr><td><code id="hessianReg_+3A_which">which</code></td>
<td>
<p>which penalty parameter(s)?</p>
</td></tr>
<tr><td><code id="hessianReg_+3A_...">...</code></td>
<td>
<p>arguments passed to the <code>meatReg</code> function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>hessianReg</code> is a function to compute the Hessian matrix estimate of non-zero regularized estimators. Implemented only for <code>zipath</code> object with <code>family="negbin"</code> in the current version. 
</p>


<h3>Value</h3>

<p>A matrix containing the Hessian matrix estimate for the non-zero parameters.</p>


<h3>Author(s)</h3>

<p>Zhu Wang &lt;zwang145@uthsc.edu&gt;</p>


<h3>References</h3>

<p>Zhu Wang, Shuangge Ma and Ching-Yun Wang (2015) <em>Variable selection for zero-inflated and overdispersed data with application to health care demand in Germany</em>, <em>Biometrical Journal</em>. 57(5):867-84.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+breadReg">breadReg</a></code>, <code><a href="#topic+meatReg">meatReg</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data("bioChemists", package = "pscl")
fm_zinb &lt;- zipath(art ~ . | ., data = bioChemists, family = "negbin", nlambda=10, maxit.em=1)
hessianReg(fm_zinb, which=which.min(fm_zinb$bic))
</code></pre>

<hr>
<h2 id='irglm'>fit a robust generalized linear models</h2><span id='topic+irglm'></span><span id='topic+irglm.formula'></span>

<h3>Description</h3>

<p>Fit a robust GLM where the loss function is a composite function <code>cfun</code>o<code>dfun</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'formula'
irglm(formula, data, weights, offset=NULL, contrasts=NULL,
 cfun="ccave", dfun=gaussian(), s=NULL, delta=0.1, fk=NULL, init.family=NULL,
 iter=10, reltol=1e-5, theta, x.keep=FALSE, y.keep=TRUE, trace=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="irglm_+3A_formula">formula</code></td>
<td>
<p>symbolic description of the model, see details.</p>
</td></tr>
<tr><td><code id="irglm_+3A_data">data</code></td>
<td>
<p>argument controlling formula processing
via <code><a href="stats.html#topic+model.frame">model.frame</a></code>.</p>
</td></tr>
<tr><td><code id="irglm_+3A_weights">weights</code></td>
<td>
<p>optional numeric vector of weights.</p>
</td></tr>
<tr><td><code id="irglm_+3A_x">x</code></td>
<td>
<p>input matrix, of dimension nobs x nvars; each row is an
observation vector</p>
</td></tr>
<tr><td><code id="irglm_+3A_y">y</code></td>
<td>
<p>response variable. Quantitative for <code>dfun=1</code> and -1/1 for classification. </p>
</td></tr>
<tr><td><code id="irglm_+3A_contrasts">contrasts</code></td>
<td>
<p>the contrasts corresponding to <code>levels</code> from the
respective models</p>
</td></tr>
<tr><td><code id="irglm_+3A_offset">offset</code></td>
<td>
<p>this can be used to specify an a priori known component to be included in the linear predictor during fitting. This should be NULL or a numeric vector of length equal to the number of cases. Currently only one offset term can be included in the formula.</p>
</td></tr>
<tr><td><code id="irglm_+3A_cfun">cfun</code></td>
<td>
<p> character, type of convex cap (concave) function.<br />
Valid options are:
</p>

<ul>
<li> <p><code>"hcave"</code>
</p>
</li>
<li> <p><code>"acave"</code>
</p>
</li>
<li> <p><code>"bcave"</code>
</p>
</li>
<li> <p><code>"ccave"</code>
</p>
</li>
<li> <p><code>"dcave"</code>
</p>
</li>
<li> <p><code>"ecave"</code>
</p>
</li>
<li> <p><code>"gcave"</code>
</p>
</li>
<li> <p><code>"tcave"</code>
</p>
</li></ul>

</td></tr>
<tr><td><code id="irglm_+3A_dfun">dfun</code></td>
<td>
<p> character, type of convex component. <br />
Valid options are:
</p>

<ul>
<li> <p><code>gaussian()</code>
</p>
</li>
<li> <p><code>binomial()</code>
</p>
</li>
<li> <p><code>poisson()</code>
</p>
</li></ul>

</td></tr>
<tr><td><code id="irglm_+3A_init.family">init.family</code></td>
<td>
<p> character value for initial family, one of &quot;clossR&quot;,&quot;closs&quot;,&quot;gloss&quot;,&quot;qloss&quot;, which can be used to derive an initial estimator, if the selection is different from the default value </p>
</td></tr>
<tr><td><code id="irglm_+3A_s">s</code></td>
<td>
<p> tuning parameter of <code>cfun</code>. <code>s &gt; 0</code> and can be equal to 0 for <code>cfun="tcave"</code>. If <code>s</code> is too close to 0 for  <code>cfun="acave", "bcave", "ccave"</code>, the calculated weights can become 0 for all observations, thus crash the program.</p>
</td></tr> 
<tr><td><code id="irglm_+3A_delta">delta</code></td>
<td>
<p>a small positive number provided by user only if <code>cfun="gcave"</code> and <code>0 &lt; s &lt;1</code></p>
</td></tr>
<tr><td><code id="irglm_+3A_fk">fk</code></td>
<td>
<p> predicted values at an iteration in the IRGLM algorithm </p>
</td></tr>
<tr><td><code id="irglm_+3A_iter">iter</code></td>
<td>
<p>number of iteration in the IRGLM algorithm</p>
</td></tr>
<tr><td><code id="irglm_+3A_reltol">reltol</code></td>
<td>
<p>convergency criteria in the IRGLM algorithm</p>
</td></tr>
<tr><td><code id="irglm_+3A_theta">theta</code></td>
<td>
<p> an overdispersion scaling parameter for <code>family=negbin()</code></p>
</td></tr> 
<tr><td><code id="irglm_+3A_x.keep">x.keep</code>, <code id="irglm_+3A_y.keep">y.keep</code></td>
<td>
<p> logical values indicating whether the response
vector and model matrix used in the fitting process should be
returned as components of the returned value, x is a design matrix of dimension n * p,
and x is a vector of observations of length n.</p>
</td></tr>
<tr><td><code id="irglm_+3A_trace">trace</code></td>
<td>
<p>if <code>TRUE</code>, fitting progress is reported</p>
</td></tr>
<tr><td><code id="irglm_+3A_...">...</code></td>
<td>
<p>other arguments passing to <code>irglm</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>A robust linear, logistic or Poisson regression model is fit by the iteratively reweighted GLM (IRGLM). The output <code>weights_update</code> is a useful diagnostic to the outlier status of the observations.
</p>


<h3>Value</h3>

<p>An object with S3 class <code>"irglm", "glm"</code> for various types of models.
</p>
<table role = "presentation">
<tr><td><code>call</code></td>
<td>
<p>the call that produced the model fit</p>
</td></tr>
<tr><td><code>weights</code></td>
<td>
<p>original weights used in the model</p>
</td></tr>
<tr><td><code>weights_update</code></td>
<td>
<p>weights in the final iteration of the IRGLM algorithm</p>
</td></tr>
<tr><td><code>cfun</code>, <code>s</code>, <code>dfun</code></td>
<td>
<p>original input arguments</p>
</td></tr>
<tr><td><code>is.offset</code></td>
<td>
<p>is offset used?</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Zhu Wang &lt;zwang145@uthsc.edu&gt;</p>


<h3>References</h3>

<p>Zhu Wang (2024)
<em>Unified Robust Estimation</em>, <em>Australian &amp; New Zealand Journal         of      Statistics</em>. 66(1):77-102.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+print">print</a></code>, <code><a href="stats.html#topic+predict">predict</a></code>, <code><a href="stats.html#topic+coef">coef</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>x=matrix(rnorm(100*20),100,20)
g2=sample(c(-1,1),100,replace=TRUE)
fit=irglm(g2~x,data=data.frame(cbind(x, g2)), s=1, cfun="ccave", dfun=gaussian())
fit$weights_update
</code></pre>

<hr>
<h2 id='irglmreg'>Fit a robust penalized generalized linear models</h2><span id='topic+irglmreg'></span><span id='topic+irglmreg.formula'></span><span id='topic+irglmreg.matrix'></span><span id='topic+irglmreg.default'></span>

<h3>Description</h3>

<p>Fit a robust penalized GLM where the loss function is a composite function <code>cfun</code>o<code>dfun</code> + penalty. This is the wrapper function of <code>irglmreg_fit</code> 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'formula'
irglmreg(formula, data, weights, offset=NULL, contrasts=NULL, ...)
## S3 method for class 'matrix'
irglmreg(x, y, weights, offset=NULL, ...)
## Default S3 method:
irglmreg(x,  ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="irglmreg_+3A_formula">formula</code></td>
<td>
<p>symbolic description of the model, see details.</p>
</td></tr>
<tr><td><code id="irglmreg_+3A_data">data</code></td>
<td>
<p>argument controlling formula processing
via <code><a href="stats.html#topic+model.frame">model.frame</a></code>.</p>
</td></tr>
<tr><td><code id="irglmreg_+3A_weights">weights</code></td>
<td>
<p>optional numeric vector of weights. If <code>standardize=TRUE</code>, weights are renormalized to weights/sum(weights). If <code>standardize=FALSE</code>, weights are kept as original input</p>
</td></tr>
<tr><td><code id="irglmreg_+3A_x">x</code></td>
<td>
<p>input matrix, of dimension nobs x nvars; each row is an
observation vector</p>
</td></tr>
<tr><td><code id="irglmreg_+3A_y">y</code></td>
<td>
<p>response variable. Quantitative for <code>rfamily="clossR"</code> and -1/1 for classification. </p>
</td></tr>
<tr><td><code id="irglmreg_+3A_offset">offset</code></td>
<td>
<p>Not implemented yet</p>
</td></tr>
<tr><td><code id="irglmreg_+3A_contrasts">contrasts</code></td>
<td>
<p>the contrasts corresponding to <code>levels</code> from the
respective models</p>
</td></tr>
<tr><td><code id="irglmreg_+3A_...">...</code></td>
<td>
<p>Other arguments passing to <code>irglmreg_fit</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The computing is done by the iteratively reweighted penalized GLM, an application of the iteratively reweighted convex optimization (IRCO). Here convex is the loss function induced by <code>dfun</code>, not the penalty function. The output <code>weights_update</code> is a useful diagnostic to the outlier status of     the observations.
The regularization path is computed for the lasso (or elastic net penalty), scad (or snet) and mcp (or mnet penalty), at a grid of values for the regularization parameter lambda. 
The sequence of robust models implied by <code>lambda</code> is fit by the IRCO along with coordinate
descent. Note that the objective function is </p>
<p style="text-align: center;"><code class="reqn">weights*loss + \lambda*penalty,</code>
</p>
<p> if <code>standardize=FALSE</code> and </p>
<p style="text-align: center;"><code class="reqn">
  \frac{weights}{\sum(weights)}*loss + \lambda*penalty,</code>
</p>
<p> if <code>standardize=TRUE</code>. 
</p>


<h3>Value</h3>

<p>An object with S3 class <code>"irglmreg"</code> for the various types of models.
</p>
<table role = "presentation">
<tr><td><code>call</code></td>
<td>
<p>the call that produced this object</p>
</td></tr>
<tr><td><code>b0</code></td>
<td>
<p>Intercept sequence of length <code>length(lambda)</code></p>
</td></tr>
<tr><td><code>beta</code></td>
<td>
<p>A <code>nvars x
      length(lambda)</code> matrix of coefficients.</p>
</td></tr>
<tr><td><code>lambda</code></td>
<td>
<p>The actual sequence of <code>lambda</code> values used</p>
</td></tr>
<tr><td><code>nobs</code></td>
<td>
<p>number of observations</p>
</td></tr>
<tr><td><code>risk</code></td>
<td>
<p>if <code>type.path="nonactive"</code>, a matrix with number of rows <code>iter</code> and number of columns <code>nlambda</code>, loss values along the regularization path. If <code>type.path="fast"</code>, a vector of length <code>nlambda</code>, loss values along the regularization path</p>
</td></tr>
<tr><td><code>pll</code></td>
<td>
<p>if <code>type.path="nonactive"</code>, a matrix with number of rows <code>iter</code> and number of columns <code>nlambda</code>, penalized loss values along the regularization path. If <code>type.path="fast"</code>, a vector of length <code>nlambda</code>, penalized loss values along the regularization path</p>
</td></tr>
<tr><td><code>fitted.values</code></td>
<td>
<p>predicted values depending on <code>standardize</code>, internal use only</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Zhu Wang &lt;zwang145@uthsc.edu&gt;</p>


<h3>References</h3>

<p>Zhu Wang (2024)
<em>Unified Robust Estimation</em>, <em>Australian &amp; New Zealand Journal of      Statistics</em>. 66(1):77-102.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+print">print</a></code>, <code><a href="stats.html#topic+predict">predict</a></code>, <code><a href="stats.html#topic+coef">coef</a></code> and <code><a href="base.html#topic+plot">plot</a></code> methods, and the <code><a href="#topic+cv.irglmreg">cv.irglmreg</a></code> function.</p>


<h3>Examples</h3>

<pre><code class='language-R'>#binomial
x=matrix(rnorm(100*20),100,20)
g2=sample(c(-1,1),100,replace=TRUE)
fit1=irglmreg(x,g2,s=1,cfun="ccave",dfun="gaussian",type.path="active",
              decreasing=TRUE,type.init="bst")
#fit1$risk
## Not run: 
### different solution paths via a combination of type.path, decreasing and type.init
fit1=irglmreg(x,g2,s=1,cfun="ccave",dfun="gaussian",type.path="active",
           decreasing=TRUE,type.init="bst")
fit2=irglmreg(x,g2,s=1,cfun="ccave",dfun="gaussian",type.path="active",
           decreasing=FALSE,type.init="bst")
fit3=irglmreg(x,g2,s=1,cfun="ccave",dfun="gaussian",type.path="nonactive",
           decreasing=TRUE,type.init="bst")
fit4=irglmreg(x,g2,s=1,cfun="ccave",dfun="gaussian",type.path="nonactive",
           decreasing=FALSE,type.init="bst")
fit5=irglmreg(x,g2,s=1,cfun="ccave",dfun="gaussian",type.path="active",
           decreasing=TRUE,type.init="co")
fit6=irglmreg(x,g2,s=1,cfun="ccave",dfun="gaussian",type.path="active",
           decreasing=FALSE,type.init="co")
fit7=irglmreg(x,g2,s=1,cfun="ccave",dfun="gaussian",type.path="nonactive",
           decreasing=TRUE,type.init="co")
fit8=irglmreg(x,g2,s=1,cfun="ccave",dfun="gaussian",type.path="nonactive",
           decreasing=FALSE,type.init="co")

## End(Not run)
</code></pre>

<hr>
<h2 id='irglmreg_fit'>Internal function for robust penalized generalized linear models</h2><span id='topic+irglmreg_fit'></span>

<h3>Description</h3>

<p>Fit a robust penalized GLM where the loss function is a composite function <code>cfun</code>o<code>dfun</code> + penalty. This does computing for <code>irglmreg</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>irglmreg_fit(x, y, weights, offset, cfun="ccave", dfun="gaussian", s=NULL, 
             delta=0.1, fk=NULL, iter=10, reltol=1e-5, 
             penalty=c("enet","mnet","snet"), nlambda=100, lambda=NULL, 
             type.path=c("active", "nonactive"), decreasing=TRUE, 
             lambda.min.ratio=ifelse(nobs&lt;nvars,.05, .001), alpha=1, gamma=3,
             rescale=TRUE, standardize=TRUE, intercept=TRUE, 
             penalty.factor= NULL, maxit=1000, type.init=c("bst", "co", "heu"), 
             init.family=NULL, mstop.init=10, nu.init=0.1, 
             eps=.Machine$double.eps, epscycle=10, thresh=1e-6, parallel=FALSE,
             n.cores=2, theta, trace=FALSE, tracelevel=1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="irglmreg_fit_+3A_x">x</code></td>
<td>
<p>input matrix, of dimension nobs x nvars; each row is an
observation vector.</p>
</td></tr> 
<tr><td><code id="irglmreg_fit_+3A_y">y</code></td>
<td>
<p>response variable. Quantitative for <code>dfun=1</code> and -1/1 otherwise for classifications.</p>
</td></tr>
<tr><td><code id="irglmreg_fit_+3A_weights">weights</code></td>
<td>
<p>observation weights. Can be total counts if responses are proportion matrices. Default is 1 for each observation</p>
</td></tr>
<tr><td><code id="irglmreg_fit_+3A_offset">offset</code></td>
<td>
<p>this can be used to specify an a priori known component to be included in the linear predictor during fitting. This should be NULL or a numeric vector of length equal to the number of cases. Currently only one offset term can be included in the formula.</p>
</td></tr>
<tr><td><code id="irglmreg_fit_+3A_cfun">cfun</code></td>
<td>
<p> character, type of convex cap (concave) function.<br />
Valid options are:
</p>

<ul>
<li> <p><code>"hcave"</code>
</p>
</li>
<li> <p><code>"acave"</code>
</p>
</li>
<li> <p><code>"bcave"</code>
</p>
</li>
<li> <p><code>"ccave"</code>
</p>
</li>
<li> <p><code>"dcave"</code>
</p>
</li>
<li> <p><code>"ecave"</code>
</p>
</li>
<li> <p><code>"gcave"</code>
</p>
</li>
<li> <p><code>"tcave"</code>
</p>
</li></ul>

</td></tr>
<tr><td><code id="irglmreg_fit_+3A_dfun">dfun</code></td>
<td>
<p> character, type of convex downward function. <br />
Valid options are:
</p>

<ul>
<li> <p><code>"gaussian"</code>
</p>
</li>
<li> <p><code>"gaussianC"</code>
</p>
</li>
<li> <p><code>"binomial"</code>
</p>
</li></ul>

</td></tr>
<tr><td><code id="irglmreg_fit_+3A_s">s</code></td>
<td>
<p> tuning parameter of <code>cfun</code>. <code>s &gt; 0</code> and can be equal    to 0 for <code>cfun="tcave"</code>. If <code>s</code> is too close to 0 for               <code>cfun="acave", "bcave", "ccave"</code>, the calculated weights can become 0    for all observations, thus crash the program.</p>
</td></tr>
<tr><td><code id="irglmreg_fit_+3A_delta">delta</code></td>
<td>
<p>a small positive number provided by user only if                <code>cfun="gcave"</code> and <code>0 &lt; s &lt;1</code></p>
</td></tr>
<tr><td><code id="irglmreg_fit_+3A_fk">fk</code></td>
<td>
<p> predicted values at an iteration in the IRCO algorithm </p>
</td></tr>
<tr><td><code id="irglmreg_fit_+3A_nlambda">nlambda</code></td>
<td>
<p>The number of <code>lambda</code> values - default is 100. The sequence may be truncated before <code>nlambda</code> is reached if a close to saturated model is fitted. See also <code>satu</code>.</p>
</td></tr>
<tr><td><code id="irglmreg_fit_+3A_lambda">lambda</code></td>
<td>
<p> by default, the algorithm provides a sequence of regularization values, or a user supplied <code>lambda</code> sequence </p>
</td></tr>
<tr><td><code id="irglmreg_fit_+3A_type.path">type.path</code></td>
<td>
<p>solution path for <code>parallel=FALSE</code>. If <code>type.path="active"</code>, then cycle through only the active set in the next increasing <code>lambda</code> sequence. If <code>type.path="nonactive"</code>, no active set for each element of the lambda sequence and cycle through all the predictor variables.</p>
</td></tr> 
<tr><td><code id="irglmreg_fit_+3A_lambda.min.ratio">lambda.min.ratio</code></td>
<td>
<p>Smallest value for <code>lambda</code>, as a fraction of
<code>lambda.max</code>, the (data derived) entry value (i.e. the smallest
value for which all coefficients are zero except the intercept). Note, there is no closed formula for <code>lambda.max</code>. The default of <code>lambda.min.ratio</code> depends on the
sample size <code>nobs</code> relative to the number of variables
<code>nvars</code>. If <code>nobs &gt; nvars</code>, the default is <code>0.001</code>,
close to zero.  If <code>nobs &lt; nvars</code>, the default is <code>0.05</code>.</p>
</td></tr>
<tr><td><code id="irglmreg_fit_+3A_alpha">alpha</code></td>
<td>
<p>The <code class="reqn">L_2</code> penalty mixing parameter, with
<code class="reqn">0 \le alpha\le 1</code>. <code>alpha=1</code> is lasso (mcp, scad) penalty; and <code>alpha=0</code> the ridge penalty. However, if <code>alpha=0</code>, one must provide <code>lambda</code> values.</p>
</td></tr>
<tr><td><code id="irglmreg_fit_+3A_gamma">gamma</code></td>
<td>
<p>The tuning parameter of the <code>snet</code> or <code>mnet</code> penalty.</p>
</td></tr>
<tr><td><code id="irglmreg_fit_+3A_rescale">rescale</code></td>
<td>
<p>logical value, if TRUE, adaptive rescaling of the penalty       parameter for <code>penalty="mnet"</code> or <code>penalty="snet"</code> with               <code>dfun="binomial"</code>. See <code>glmreg_fit</code></p>
</td></tr>
<tr><td><code id="irglmreg_fit_+3A_standardize">standardize</code></td>
<td>
<p>logical value for x variable standardization, prior to
fitting the model sequence. The coefficients are always returned on
the original scale. Default is <code>standardize=TRUE</code>.</p>
</td></tr>
<tr><td><code id="irglmreg_fit_+3A_intercept">intercept</code></td>
<td>
<p>logical value: if TRUE (default), intercept(s) are fitted; otherwise, intercept(s)  are set to zero</p>
</td></tr>
<tr><td><code id="irglmreg_fit_+3A_penalty.factor">penalty.factor</code></td>
<td>
<p>This is a number that multiplies <code>lambda</code> to allow
differential shrinkage of coefficients. Can be 0 for some variables, which implies
no shrinkage, and that variable is always included in the
model. Default is same shrinkage for all variables.</p>
</td></tr>
<tr><td><code id="irglmreg_fit_+3A_type.init">type.init</code></td>
<td>
<p>a method to determine the initial values. If <code>type.init="ncl"</code>, an intercept-only model as initial parameter and run <code>irglmreg</code> regularization path forward from lambda_max to lambda_min. If <code>type.init="heu"</code>, heuristic initial parameters and run <code>irglmreg</code> path backward or forward depending on <code>decreasing</code>, between lambda_min and lambda_max. If <code>type.init="bst"</code>, run a boosting model with <code>bst</code> in package bst, depending on <code>mstop.init, nu.init</code> and run <code>irglmreg</code> backward or forward depending on <code>decreasing</code>.</p>
</td></tr>
<tr><td><code id="irglmreg_fit_+3A_init.family">init.family</code></td>
<td>
<p> character value for initial family, one of &quot;clossR&quot;,     &quot;closs&quot;,&quot;gloss&quot;,&quot;qloss&quot;, which can be used to derive an initial estimator, if   the selection is different from the default value </p>
</td></tr>
<tr><td><code id="irglmreg_fit_+3A_mstop.init">mstop.init</code></td>
<td>
<p> an integer giving the number of boosting iterations when <code>type.init="bst"</code> </p>
</td></tr>
<tr><td><code id="irglmreg_fit_+3A_nu.init">nu.init</code></td>
<td>
<p> a small number (between 0 and 1) defining the step size or shrinkage parameter when <code>type.init="bst"</code>. </p>
</td></tr>
<tr><td><code id="irglmreg_fit_+3A_decreasing">decreasing</code></td>
<td>
<p> only used if <code>lambda=NULL</code>, a logical value used to determine regularization path direction either from lambda_max to a potentially modified lambda_min or vice versa if <code>type.init="bst", "heu"</code>. Since this is a nonconvex optimization, it is possible to generate different estimates for the same <code>lambda</code> depending on <code>decreasing</code>. The choice of <code>decreasing</code> picks different starting values.</p>
</td></tr>
<tr><td><code id="irglmreg_fit_+3A_iter">iter</code></td>
<td>
<p>number of iteration in the IRCO algorithm</p>
</td></tr>
<tr><td><code id="irglmreg_fit_+3A_maxit">maxit</code></td>
<td>
<p>Within each IRCO algorithm iteration, maximum number of coordinate descent iterations for each <code>lambda</code> value; default is 1000.</p>
</td></tr>
<tr><td><code id="irglmreg_fit_+3A_reltol">reltol</code></td>
<td>
<p>convergency criteria in the IRCO algorithm</p>
</td></tr> 
<tr><td><code id="irglmreg_fit_+3A_eps">eps</code></td>
<td>
<p>If a coefficient is less than <code>eps</code> in magnitude, then it is reported to be 0</p>
</td></tr>
<tr><td><code id="irglmreg_fit_+3A_epscycle">epscycle</code></td>
<td>
<p> If <code>nlambda</code> &gt; 1 and the relative loss values from two consecutive <code>lambda</code> values change &gt; <code>epscycle</code>, then re-estimate parameters in an effort to avoid trap of local optimization.</p>
</td></tr>
<tr><td><code id="irglmreg_fit_+3A_thresh">thresh</code></td>
<td>
<p>Convergence threshold for coordinate descent. Defaults value is <code>1e-6</code>.</p>
</td></tr>
<tr><td><code id="irglmreg_fit_+3A_penalty">penalty</code></td>
<td>
<p>Type of regularization</p>
</td></tr>
<tr><td><code id="irglmreg_fit_+3A_theta">theta</code></td>
<td>
<p> an overdispersion scaling parameter for <code>family="negbin"</code></p>
</td></tr>
<tr><td><code id="irglmreg_fit_+3A_parallel">parallel</code>, <code id="irglmreg_fit_+3A_n.cores">n.cores</code></td>
<td>
<p>If <code>TRUE</code>, to compute solution of <code>lambda</code> with parallel computing in number of <code>n.cores</code>. If <code>FALSE</code>, sequential computing. If <code>NULL</code>, still sequential computing with a different convergence criteria based on penalized loss values</p>
</td></tr>
<tr><td><code id="irglmreg_fit_+3A_trace">trace</code>, <code id="irglmreg_fit_+3A_tracelevel">tracelevel</code></td>
<td>
<p>If <code>TRUE</code>, fitting progress is reported. If <code>tracelevel=2</code>, deeper level of fitting progress is reported.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A case weighted penalized least squares or GLM is fit by the iteratively reweighted convex optimization (IRCO), where the loss function is a composite function <code>cfun</code>o<code>dfun</code> + penalty. Here convex is the loss function     induced by <code>dfun</code>, not the penalty function.
The sequence of robust models implied by <code>lambda</code> is fit by IRCO along with coordinate
descent. Note that the objective function is </p>
<p style="text-align: center;"><code class="reqn">weights*loss + \lambda*penalty,</code>
</p>
<p> if <code>standardize=FALSE</code> and </p>
<p style="text-align: center;"><code class="reqn">
  \frac{weights}{\sum(weights)}*loss + \lambda*penalty,</code>
</p>
<p> if <code>standardize=TRUE</code>. 
</p>


<h3>Value</h3>

<p>An object with S3 class <code>"irglmreg"</code> for the various types of models.
</p>
<table role = "presentation">
<tr><td><code>call</code></td>
<td>
<p>the call that produced the model fit</p>
</td></tr>
<tr><td><code>b0</code></td>
<td>
<p>Intercept sequence of length <code>length(lambda)</code></p>
</td></tr>
<tr><td><code>beta</code></td>
<td>
<p>A <code>nvars x length(lambda)</code> matrix of coefficients.</p>
</td></tr>
<tr><td><code>lambda</code></td>
<td>
<p>The actual sequence of <code>lambda</code> values used</p>
</td></tr>
<tr><td><code>weights_update</code></td>
<td>
<p>A <code>nobs x length(lambda)</code> matrix of weights computed by the IRCO algorithm. The entry of i-th row and j-th column is the weight for the i-th observation and j-th <code>lambda</code> value.</p>
</td></tr>
<tr><td><code>decreasing</code></td>
<td>
<p> if <code>lambda</code> is an increasing sequence or not, used to determine regularization path direction either from lambda_max to a potentially modified lambda_min or vice versa if <code>type.init="bst", "heu"</code>. </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Zhu Wang &lt;zwang145@uthsc.edu&gt;</p>


<h3>References</h3>

<p>Zhu Wang (2024)
<em>Unified Robust Estimation</em>, <em>Australian &amp; New Zealand Journal of      Statistics</em>. 66(1):77-102.  
</p>


<h3>See Also</h3>

<p><code><a href="#topic+irglmreg">irglmreg</a></code></p>

<hr>
<h2 id='irsvm'>fit case weighted support vector machines with robust loss functions</h2><span id='topic+irsvm'></span><span id='topic+irsvm.formula'></span><span id='topic+irsvm.matrix'></span><span id='topic+irsvm.default'></span><span id='topic+coef.irsvm'></span>

<h3>Description</h3>

<p>Fit case weighted support vector machines with robust loss functions. This is the wrapper function of <code>irsvm_fit</code>, which does the computing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'formula'
irsvm(formula, data, weights, contrasts=NULL, ...)
## S3 method for class 'matrix'
irsvm(x, y, weights, ...)
## Default S3 method:
irsvm(x,  ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="irsvm_+3A_formula">formula</code></td>
<td>
<p>symbolic description of the model, see details.</p>
</td></tr>
<tr><td><code id="irsvm_+3A_data">data</code></td>
<td>
<p>argument controlling formula processing
via <code><a href="stats.html#topic+model.frame">model.frame</a></code>.</p>
</td></tr>
<tr><td><code id="irsvm_+3A_weights">weights</code></td>
<td>
<p>optional numeric vector of weights</p>
</td></tr>
<tr><td><code id="irsvm_+3A_x">x</code></td>
<td>
<p>input matrix, of dimension nobs x nvars; each row is an
observation vector</p>
</td></tr>
<tr><td><code id="irsvm_+3A_y">y</code></td>
<td>
<p>response variable. Quantitative for <code>type="eps-regression", "nu-regression"</code> and -1/1 for <code>type="C-classification", "nu-Classification"</code>.</p>
</td></tr>
<tr><td><code id="irsvm_+3A_contrasts">contrasts</code></td>
<td>
<p>the contrasts corresponding to <code>levels</code> from the
respective models</p>
</td></tr>
<tr><td><code id="irsvm_+3A_...">...</code></td>
<td>
<p>Other arguments passing to <code>irsvm_fit</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Fit a robust SVM where the loss function is a composite function <code>cfun</code>o<code>type</code> + penalty.
The model is fit by the iteratively reweighted SVM, an application of the iteratively reweighted convex optimization (IRCO). Here convex is the loss function  induced by <code>type</code>. 
</p>
<p>For linear kernel, the coefficients of the regression/decision hyperplane
can be extracted using the <code>coef</code> method.
</p>


<h3>Value</h3>

<p>An object with S3 class <code>"wsvm"</code> for various types of models.
</p>
<table role = "presentation">
<tr><td><code>call</code></td>
<td>
<p>the call that produced this object</p>
</td></tr>
<tr><td><code>weights_update</code></td>
<td>
<p>weights in the final iteration of the IRCO algorithm</p>
</td></tr>
<tr><td><code>cfun</code>, <code>s</code></td>
<td>
<p>original input arguments</p>
</td></tr>
<tr><td><code>delta</code></td>
<td>
<p>delta value used for <code>cfun="gcave"</code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Zhu Wang &lt;zwang145@uthsc.edu&gt;</p>


<h3>References</h3>

<p>Zhu Wang (2024)
<em>Unified Robust Estimation</em>, <em>Australian &amp; New Zealand Journal of      Statistics</em>. 66(1):77-102.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+irsvm_fit">irsvm_fit</a></code>, <code><a href="base.html#topic+print">print</a></code>, <code><a href="stats.html#topic+predict">predict</a></code>, <code><a href="stats.html#topic+coef">coef</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>#binomial
x=matrix(rnorm(100*20),100,20)
g2=sample(c(-1,1),100,replace=TRUE)
fit=irsvm(x,g2,s=1,cfun="ccave",type="C-classification")
</code></pre>

<hr>
<h2 id='irsvm_fit'>Fit iteratively reweighted support vector machines for robust loss functions</h2><span id='topic+irsvm_fit'></span>

<h3>Description</h3>

<p><code>irsvm_fit</code> is used to train a subject weighted support vector machine where the weights are provided iteratively from robust loss function with the iteratively reweighted convex optimization (IRCO). It can be used to carry out robust regression and binary classification. This does computing for the wrapper function <code>irsvm</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>irsvm_fit(x, y, weights, cfun="ccave", s=NULL, delta=0.0001, type = NULL, 
          kernel="radial", cost=1, epsilon = 0.1, iter=10, reltol=1e-5, 
          trace=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="irsvm_fit_+3A_x">x</code></td>
<td>
<p>a data matrix, a vector, or a sparse '<em>design</em> matrix' (object of class
<code><a href="Matrix.html#topic+Matrix">Matrix</a></code> provided by the <span class="pkg">Matrix</span> package,
or of class <code><a href="SparseM.html#topic+matrix.csr">matrix.csr</a></code>
provided by the <span class="pkg">SparseM</span> package, or of class
<code><a href="slam.html#topic+simple_triplet_matrix">simple_triplet_matrix</a></code> provided by the <span class="pkg">slam</span>
package).</p>
</td></tr>
<tr><td><code id="irsvm_fit_+3A_y">y</code></td>
<td>
<p>a response vector with one label for each row/component of
<code>x</code>. Can be either a factor (for classification tasks)
or a numeric vector (for regression).</p>
</td></tr>
<tr><td><code id="irsvm_fit_+3A_weights">weights</code></td>
<td>
<p>the weight of each subject. It should be in the same length of <code>y</code>.</p>
</td></tr>
<tr><td><code id="irsvm_fit_+3A_cfun">cfun</code></td>
<td>
<p> character, type of convex cap (concave) function.<br />
Valid options are:
</p>

<ul>
<li> <p><code>"hcave"</code>
</p>
</li>
<li> <p><code>"acave"</code>
</p>
</li>
<li> <p><code>"bcave"</code>
</p>
</li>
<li> <p><code>"ccave"</code>
</p>
</li>
<li> <p><code>"dcave"</code>
</p>
</li>
<li> <p><code>"ecave"</code>
</p>
</li>
<li> <p><code>"gcave"</code>
</p>
</li>
<li> <p><code>"tcave"</code>
</p>
</li></ul>

</td></tr>
<tr><td><code id="irsvm_fit_+3A_s">s</code></td>
<td>
<p> tuning parameter of <code>cfun</code>. <code>s &gt; 0</code> and can be equal    to  0 for <code>cfun="tcave"</code>. If <code>s</code> is too close to 0 for <code>cfun="acave", "bcave", "ccave"</code>, the calculated weights can become 0 for all observations, thus crash the program.</p>
</td></tr>
<tr><td><code id="irsvm_fit_+3A_delta">delta</code></td>
<td>
<p>a small positive number provided by user only if                 <code>cfun="gcave"</code> and <code>0 &lt; s &lt;1</code></p>
</td></tr>
<tr><td><code id="irsvm_fit_+3A_type">type</code></td>
<td>
<p><code>irsvm_fit</code> can be used as a classification
machine, or as a regression machine.
Depending of whether <code>y</code> is
a factor or not, the default setting for <code>type</code> is <code>C-classification</code> or <code>eps-regression</code>, respectively, but may be overwritten by setting an explicit value.<br />
Valid options are:
</p>

<ul>
<li> <p><code>C-classification</code>
</p>
</li>
<li> <p><code>nu-classification</code>
</p>
</li>
<li> <p><code>eps-regression</code>
</p>
</li>
<li> <p><code>nu-regression</code>
</p>
</li></ul>

</td></tr>
<tr><td><code id="irsvm_fit_+3A_kernel">kernel</code></td>
<td>
<p>the kernel used in training and predicting. You
might consider changing some of the following parameters, depending
on the kernel type.<br />
</p>

<dl>
<dt>linear:</dt><dd><p><code class="reqn">u'v</code></p>
</dd>
<dt>polynomial:</dt><dd><p><code class="reqn">(\gamma u'v + coef0)^{degree}</code></p>
</dd>
<dt>radial basis:</dt><dd><p><code class="reqn">e^(-\gamma |u-v|^2)</code></p>
</dd>
<dt>sigmoid:</dt><dd><p><code class="reqn">tanh(\gamma u'v + coef0)</code></p>
</dd>
</dl>

</td></tr>
<tr><td><code id="irsvm_fit_+3A_cost">cost</code></td>
<td>
<p>cost of constraints violation (default: 1)&mdash;it is the
&lsquo;C&rsquo;-constant of the regularization term in the Lagrange formulation. This is proportional to the inverse of <code>lambda</code> in <code>irglmreg</code>.</p>
</td></tr> 
<tr><td><code id="irsvm_fit_+3A_epsilon">epsilon</code></td>
<td>
<p>epsilon in the insensitive-loss function (default: 0.1)</p>
</td></tr>
<tr><td><code id="irsvm_fit_+3A_iter">iter</code></td>
<td>
<p>number of iteration in the IRCO algorithm</p>
</td></tr>
<tr><td><code id="irsvm_fit_+3A_reltol">reltol</code></td>
<td>
<p>convergency criteria in the IRCO algorithm</p>
</td></tr>
<tr><td><code id="irsvm_fit_+3A_trace">trace</code></td>
<td>
<p>If <code>TRUE</code>, fitting progress is reported</p>
</td></tr>
<tr><td><code id="irsvm_fit_+3A_...">...</code></td>
<td>
<p>additional parameters for function <code>wsvm</code> in package <span class="pkg">WeightSVM</span></p>
</td></tr>
</table>


<h3>Details</h3>

<p>A case weighted SVM is fit by the IRCO algorithm, where the loss function is a composite function of <code>cfun</code>o<code>type</code>, plus a <code class="reqn">L\_2</code> penalty.
Additional arguments include <code>degree, gamma, coef0</code>, 
<code>class.weights, cachesize, tolerance, shrinking, propbability, fitted</code>, the same as <code>"wsvm"</code> in package <span class="pkg">WeightSVM</span>.
</p>


<h3>Value</h3>

<p>An object of class <code>"wsvm"</code> (see package <span class="pkg">WeightSVM</span>) containing the fitted model, including:
</p>
<table role = "presentation">
<tr><td><code>SV</code></td>
<td>
<p>The resulting support vectors (possibly scaled).</p>
</td></tr>
<tr><td><code>index</code></td>
<td>
<p>The index of the resulting support vectors in the data
matrix. Note that this index refers to the preprocessed data (after
the possible effect of <code>na.omit</code> and <code>subset</code>)</p>
</td></tr>
<tr><td><code>coefs</code></td>
<td>
<p>The corresponding coefficients times the training labels.</p>
</td></tr>
<tr><td><code>rho</code></td>
<td>
<p>The negative intercept.</p>
</td></tr>
<tr><td><code>sigma</code></td>
<td>
<p>In case of a probabilistic regression model, the scale
parameter of the hypothesized (zero-mean) laplace distribution estimated by
maximum likelihood.</p>
</td></tr>
<tr><td><code>probA</code>, <code>probB</code></td>
<td>
<p>numeric vectors of length 2, number of
classes, containing the parameters of the logistic distributions fitted to
the decision values of the binary classifiers (1 / (1 + exp(a x + b))).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Zhu Wang <a href="mailto:zwang145@uthsc.edu">zwang145@uthsc.edu</a>
</p>


<h3>References</h3>

<p>Zhu Wang (2024)
<em>Unified Robust Estimation</em>, <em>Australian &amp; New Zealand Journal of Statistics</em>. 66(1):77-102.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+irsvm">irsvm</a></code>, <code><a href="base.html#topic+print">print</a></code>, <code><a href="stats.html#topic+predict">predict</a></code>, <code><a href="stats.html#topic+coef">coef</a></code> and     <code><a href="base.html#topic+plot">plot</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(iris)
 iris &lt;- subset(iris, Species %in% c("setosa", "versicolor"))
 # default with factor response:
  model &lt;- irsvm(Species ~ ., data = iris, kernel="linear", trace=TRUE)
  model &lt;- irsvm(Species ~ ., data = iris)
 # alternatively the traditional interface:
  x &lt;- subset(iris, select = -Species)
  y &lt;- iris$Species
model &lt;- irsvm(x, y)
  # test with train data
  pred &lt;- predict(model, x)
  # (same as:)
  pred &lt;- fitted(model)
 
  # Check accuracy:
  table(pred, y)
 # compute decision values and probabilities:
  pred &lt;- predict(model, x, decision.values = TRUE)
  attr(pred, "decision.values")
 
  # visualize (classes by color, SV by crosses):
  plot(cmdscale(dist(iris[,-5])),
       col = as.integer(iris[,5]),
       pch = c("o","+")[1:100 %in% model$index + 1])
 
  ## try regression mode on two dimensions
 
  # create data
  x &lt;- seq(0.1, 5, by = 0.05)
  y &lt;- log(x) + rnorm(x, sd = 0.2)
 
  # estimate model and predict input values
  m   &lt;- irsvm(x, y)
  new &lt;- predict(m, x)
 
  # visualize
 plot(x, y)
  points(x, log(x), col = 2)
  points(x, new, col = 4) 
</code></pre>

<hr>
<h2 id='loss2'>Composite Loss Value</h2><span id='topic+loss2'></span>

<h3>Description</h3>

<p>Compute composite loss value
</p>


<h3>Usage</h3>

<pre><code class='language-R'>loss2(y, f, weights, cfun, dfun, s, delta=0.0001)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="loss2_+3A_y">y</code></td>
<td>
<p>response variable values</p>
</td></tr>
<tr><td><code id="loss2_+3A_f">f</code></td>
<td>
<p>linear predictor values of <code>y</code>. If <code>f</code> is predicted <code>response</code> of model, use function <code>loss3</code> instead</p>
</td></tr>
<tr><td><code id="loss2_+3A_weights">weights</code></td>
<td>
<p>observation weights, same length as <code>y</code></p>
</td></tr>
<tr><td><code id="loss2_+3A_cfun">cfun</code></td>
<td>
<p>integer from 1-8, concave function as in <code>irglm_fit</code></p>
</td></tr>
<tr><td><code id="loss2_+3A_dfun">dfun</code></td>
<td>
<p>integer from 1-7, convex function as in <code>irglm_fit</code></p>
</td></tr>
<tr><td><code id="loss2_+3A_s">s</code></td>
<td>
<p> tuning parameter of <code>cfun</code>. <code>s &gt; 0</code> and can be equal    to 0 for <code>cfun="tcave"</code>.</p>
</td></tr> 
<tr><td><code id="loss2_+3A_delta">delta</code></td>
<td>
<p>a small positive number provided by user only if <code>cfun="gcave"</code> and <code>0 &lt; s &lt;1</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>An internal function. For large <code>s</code> values, the loss can be 0 with <code>cfun=2,3,4</code>, or &quot;acave&quot;, &quot;bcave&quot;, &quot;ccave&quot;.</p>


<h3>Value</h3>

<p>Weighted loss values</p>


<h3>Author(s)</h3>

<p>Zhu Wang &lt;zwang145@uthsc.edu&gt;</p>


<h3>References</h3>

<p>Zhu Wang (2024)
<em>Unified Robust Estimation</em>, <em>Australian &amp; New Zealand Journal of      Statistics</em>. 66(1):77-102.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+loss3">loss3</a></code>
<code><a href="#topic+irglm">irglm</a></code>
<code><a href="#topic+irglmreg">irglmreg</a></code>
<code><a href="#topic+loss2_irsvm">loss2_irsvm</a></code>
</p>

<hr>
<h2 id='loss2_irsvm'>Composite Loss Value for epsilon-insensitive Type</h2><span id='topic+loss2_irsvm'></span>

<h3>Description</h3>

<p>Compute composite loss value for epsilon-insensitive type function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>loss2_irsvm(y, f, weights, cfun, dfun, s, eps, delta=0.0001)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="loss2_irsvm_+3A_y">y</code></td>
<td>
<p>response variable values</p>
</td></tr>
<tr><td><code id="loss2_irsvm_+3A_f">f</code></td>
<td>
<p>fitted values of <code>y</code></p>
</td></tr>
<tr><td><code id="loss2_irsvm_+3A_weights">weights</code></td>
<td>
<p>observation weights, same length as <code>y</code></p>
</td></tr>
<tr><td><code id="loss2_irsvm_+3A_cfun">cfun</code></td>
<td>
<p>integer from 1-8, concave function as in <code>irsvm_fit</code></p>
</td></tr>
<tr><td><code id="loss2_irsvm_+3A_dfun">dfun</code></td>
<td>
<p>integer value, only <code>dfun=2</code> is implemented for now. Convex function as in <code>irsvm_fit</code></p>
</td></tr>
<tr><td><code id="loss2_irsvm_+3A_s">s</code></td>
<td>
<p> tuning parameter of <code>cfun</code>. <code>s &gt; 0</code> and can be equal to 0 for <code>cfun="tcave"</code>.</p>
</td></tr>
<tr><td><code id="loss2_irsvm_+3A_delta">delta</code></td>
<td>
<p>a small positive number provided by user only if  <code>cfun="gcave"</code> and <code>0 &lt; s &lt;1</code></p>
</td></tr>
<tr><td><code id="loss2_irsvm_+3A_eps">eps</code></td>
<td>
<p>non-negative parameter for epsilon-insensitive loss</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For large <code>s</code> values, the loss can be 0 with <code>cfun=2,3,4</code>,   or &quot;acave&quot;, &quot;bcave&quot;, &quot;ccave&quot;.</p>


<h3>Value</h3>

<p>Weighted loss values</p>


<h3>Author(s)</h3>

<p>Zhu Wang &lt;zwang145@uthsc.edu&gt;</p>


<h3>References</h3>

<p>Zhu Wang (2024)
<em>Unified Robust Estimation</em>, <em>Australian &amp; New Zealand Journal of      Statistics</em>. 66(1):77-102.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+irglmreg">irglmreg</a></code>,
<code><a href="#topic+loss2">loss2</a></code>
</p>

<hr>
<h2 id='loss3'>Composite Loss Value for GLM</h2><span id='topic+loss3'></span>

<h3>Description</h3>

<p>Compute composite loss value
</p>


<h3>Usage</h3>

<pre><code class='language-R'>loss3(y, mu, theta, weights, cfun, family, s, delta)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="loss3_+3A_y">y</code></td>
<td>
<p>response variable values, 0/1 if <code>family=2</code>, or binomial</p>
</td></tr>
<tr><td><code id="loss3_+3A_mu">mu</code></td>
<td>
<p>response prediction of <code>y</code>. If <code>mu</code> is linear predictor, use function <code>loss2</code> instead</p>
</td></tr>
<tr><td><code id="loss3_+3A_theta">theta</code></td>
<td>
<p>scale parameter for <code>family=4</code>, negative binomial</p>
</td></tr>
<tr><td><code id="loss3_+3A_weights">weights</code></td>
<td>
<p>observation weights, same length as <code>y</code></p>
</td></tr>
<tr><td><code id="loss3_+3A_cfun">cfun</code></td>
<td>
<p>integer from 1-8, concave function as in <code>irglm_fit</code></p>
</td></tr>
<tr><td><code id="loss3_+3A_family">family</code></td>
<td>
<p>integer 2, 3 or 4, convex function binomial, Poisson or negative binomial, respectively</p>
</td></tr>
<tr><td><code id="loss3_+3A_s">s</code></td>
<td>
<p> tuning parameter of <code>cfun</code>. <code>s &gt; 0</code> and can be equal to 0 for <code>cfun="tcave"</code>.</p>
</td></tr> 
<tr><td><code id="loss3_+3A_delta">delta</code></td>
<td>
<p>a small positive number provided by user only if <code>cfun="gcave"</code> and <code>0 &lt; s &lt;1</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>For large <code>s</code> values, the loss can be 0 with <code>cfun=2,3,4</code>, or &quot;acave&quot;, &quot;bcave&quot;, &quot;ccave&quot;.</p>


<h3>Value</h3>

<p>Weighted loss values</p>


<h3>Author(s)</h3>

<p>Zhu Wang &lt;zwang145@uthsc.edu&gt;</p>


<h3>References</h3>

<p>Zhu Wang (2024)
<em>Unified Robust Estimation</em>, <em>Australian &amp; New Zealand Journal of      Statistics</em>. 66(1):77-102.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+loss2">loss2</a></code>
<code><a href="#topic+irglm">irglm</a></code>
<code><a href="#topic+irglmreg">irglmreg</a></code>
<code><a href="#topic+loss2_irsvm">loss2_irsvm</a></code>
</p>

<hr>
<h2 id='meatReg'>Meat Matrix Estimator</h2><span id='topic+meatReg'></span>

<h3>Description</h3>

<p>Estimating the variance of the first derivative of log-likelihood function</p>


<h3>Usage</h3>

<pre><code class='language-R'>meatReg(x, which, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="meatReg_+3A_x">x</code></td>
<td>
<p>a fitted model object. Currently only implemented for <code>zipath</code> object with <code>family="negbin"</code></p>
</td></tr>
<tr><td><code id="meatReg_+3A_which">which</code></td>
<td>
<p>which penalty parameter(s)?</p>
</td></tr>
<tr><td><code id="meatReg_+3A_...">...</code></td>
<td>
<p>arguments passed to the <code><a href="#topic+estfunReg">estfunReg</a></code> function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See reference below
</p>


<h3>Value</h3>

<p>A </p>
<p style="text-align: center;"><code class="reqn">k \times k</code>
</p>
<p> covariance matrix of first derivative of log-likelihood function</p>


<h3>Author(s)</h3>

<p>Zhu Wang &lt;zwang145@uthsc.edu&gt;</p>


<h3>References</h3>

<p>Zhu Wang, Shuangge Ma and Ching-Yun Wang (2015) <em>Variable selection for zero-inflated and overdispersed data with application to health care demand in Germany</em>, <em>Biometrical Journal</em>. 57(5):867-84.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sandwichReg">sandwichReg</a></code>, <code><a href="#topic+breadReg">breadReg</a></code>, <code><a href="#topic+estfunReg">estfunReg</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data("bioChemists", package = "pscl")
fm_zinb &lt;- zipath(art ~ . | ., data = bioChemists, family = "negbin", nlambda=10, maxit.em=1)
meatReg(fm_zinb, which=which.min(fm_zinb$bic))
</code></pre>

<hr>
<h2 id='methods'> Methods for mpath Objects </h2><span id='topic+AIC.glmreg'></span><span id='topic+AIC.zipath'></span><span id='topic+BIC.glmreg'></span><span id='topic+BIC.zipath'></span>

<h3>Description</h3>

<p>Methods for models fitted by coordinate descent algorithms.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'glmreg'
AIC(object, ..., k)
## S3 method for class 'zipath'
AIC(object, ..., k)
## S3 method for class 'glmreg'
BIC(object, ...)
## S3 method for class 'zipath'
BIC(object, ...)

</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="methods_+3A_object">object</code></td>
<td>
<p> objects of class <code>glmreg</code> or <code>zipath</code>.</p>
</td></tr>
<tr><td><code id="methods_+3A_...">...</code></td>
<td>
<p> additional arguments passed to calls. </p>
</td></tr>
<tr><td><code id="methods_+3A_k">k</code></td>
<td>
<p>  numeric, the <em>penalty</em> per parameter to be used; the default
<code>k = 2</code> is the classical AIC. <code>k</code> has been hard coded in the function and there is no impact to the value of <code>AIC</code> if <code>k</code> is changed </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Zhu Wang &lt;zwang145@uthsc.edu&gt;</p>


<h3>References</h3>

<p>Zhu Wang, Shuangge Ma, Michael Zappitelli, Chirag Parikh, Ching-Yun Wang and Prasad Devarajan (2014)      <em>Penalized Count Data Regression with Application to Hospital Stay after Pediatric Cardiac Surgery</em>, <em>Statistical Methods in Medical Research</em>. 2014 Apr 17. [Epub ahead of print]
</p>
<p>Zhu Wang, Shuangge Ma, Ching-Yun Wang, Michael Zappitelli, Prasad Devarajan and Chirag R. Parikh (2014)
<em>EM for Regularized Zero Inflated Regression Models with Applications to Postoperative Morbidity after Cardiac Surgery in Children</em>, <em>Statistics in Medicine</em>. 33(29):5192-208.
</p>
<p>Zhu Wang, Shuangge Ma and Ching-Yun Wang (2015) <em>Variable selection for zero-inflated and overdispersed data with application to health care demand in Germany</em>, <em>Biometrical Journal</em>. 57(5):867-84.
</p>

<hr>
<h2 id='mpath-internal'>Internal mpath functions</h2><span id='topic+balanced.folds'></span><span id='topic+cv.folds'></span><span id='topic+findlam'></span><span id='topic+g'></span><span id='topic+init'></span><span id='topic+llfun'></span><span id='topic+pen_sum'></span><span id='topic+predictzeroinfl1'></span><span id='topic+cfun2num'></span><span id='topic+y2num'></span><span id='topic+y2num4glm'></span><span id='topic+check_s'></span>

<h3>Description</h3>

<p>Internal mpath functions</p>


<h3>Details</h3>

<p>These are not intended for use by users. <code>findlam</code> is to compute the maximum value of <code>lambda</code> so that the coefficient estimation is zero. <code>g</code> is to compute a link function (not used at this moment), <code>init</code> is to compute eta, which is the estimated beta_0 in the intercept-only model. <code>pen_sum</code> is to compute the total penalty value from the estimated coefficients, <code>llfun</code> to compute the log-likelihood function. <code>convexMin</code> (from ncvreg) calculates the
lowest index for which the penalized objective function is locally convex. 
</p>
<p>Functions not used anymore: pen_eval, pen_sum, pen_zipath and zipath.control
</p>


<h3>Author(s)</h3>

<p>Zhu Wang, author of ncvreg, author of pamr:balanced.folds (see COPYRIGHTS)</p>

<hr>
<h2 id='ncl'>fit a nonconvex loss based robust linear model</h2><span id='topic+ncl'></span><span id='topic+ncl.formula'></span><span id='topic+ncl.matrix'></span><span id='topic+ncl.default'></span>

<h3>Description</h3>

<p>Fit a linear model via penalized nonconvex loss function.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'formula'
ncl(formula, data, weights, offset=NULL, contrasts=NULL, 
x.keep=FALSE, y.keep=TRUE, ...)
## S3 method for class 'matrix'
ncl(x, y, weights, offset=NULL, ...)
## Default S3 method:
ncl(x,  ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ncl_+3A_formula">formula</code></td>
<td>
<p>symbolic description of the model, see details.</p>
</td></tr>
<tr><td><code id="ncl_+3A_data">data</code></td>
<td>
<p>argument controlling formula processing
via <code><a href="stats.html#topic+model.frame">model.frame</a></code>.</p>
</td></tr>
<tr><td><code id="ncl_+3A_weights">weights</code></td>
<td>
<p>optional numeric vector of weights. If <code>standardize=TRUE</code>, weights are renormalized to weights/sum(weights). If <code>standardize=FALSE</code>, weights are kept as original input</p>
</td></tr>
<tr><td><code id="ncl_+3A_x">x</code></td>
<td>
<p>input matrix, of dimension nobs x nvars; each row is an
observation vector</p>
</td></tr>
<tr><td><code id="ncl_+3A_y">y</code></td>
<td>
<p>response variable. Quantitative for <code>rfamily="clossR"</code> and -1/1 for classification. </p>
</td></tr>
<tr><td><code id="ncl_+3A_offset">offset</code></td>
<td>
<p>Not implemented yet</p>
</td></tr>
<tr><td><code id="ncl_+3A_contrasts">contrasts</code></td>
<td>
<p>the contrasts corresponding to <code>levels</code> from the
respective models</p>
</td></tr>
<tr><td><code id="ncl_+3A_x.keep">x.keep</code>, <code id="ncl_+3A_y.keep">y.keep</code></td>
<td>
<p> For glmreg: logical values indicating whether the response
vector and model matrix used in the fitting process should be
returned as components of the returned value.
For ncl_fit: x is a design matrix of dimension n * p,
and x is a vector of observations of length n.</p>
</td></tr>
<tr><td><code id="ncl_+3A_...">...</code></td>
<td>
<p>Other arguments passing to <code>ncl_fit</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The robust linear model is fit by majorization-minimization along with linear regression. Note that the objective function is </p>
<p style="text-align: center;"><code class="reqn">weights*loss</code>
</p>
<p>.
</p>


<h3>Value</h3>

<p>An object with S3 class <code>"ncl"</code> for the various types of models.
</p>
<table role = "presentation">
<tr><td><code>call</code></td>
<td>
<p>the call that produced this object</p>
</td></tr>
<tr><td><code>fitted.values</code></td>
<td>
<p>predicted values</p>
</td></tr>
<tr><td><code>h</code></td>
<td>
<p> pseudo response values in the MM algorithm </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Zhu Wang &lt;zwang145@uthsc.edu&gt;</p>


<h3>References</h3>

<p>Zhu Wang (2021),
<em>MM for Penalized Estimation</em>,
<em>TEST</em>,
doi: <a href="https://doi.org/10.1007/s11749-021-00770-2">10.1007/s11749-021-00770-2</a>
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+print">print</a></code>, <code><a href="stats.html#topic+predict">predict</a></code>, <code><a href="stats.html#topic+coef">coef</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>#binomial
x=matrix(rnorm(100*20),100,20)
g2=sample(c(-1,1),100,replace=TRUE)
fit=ncl(x,g2,s=1,rfamily="closs")
</code></pre>

<hr>
<h2 id='ncl_fit'>Internal function to fit a nonconvex loss based robust linear model</h2><span id='topic+ncl_fit'></span>

<h3>Description</h3>

<p>Fit a linear model via penalized nonconvex loss function.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ncl_fit(x,y, weights, offset=NULL, 
        rfamily=c("clossR", "closs", "gloss", "qloss"), 
        s=NULL, fk=NULL, iter=10, reltol=1e-5, trace=FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ncl_fit_+3A_x">x</code></td>
<td>
<p>input matrix, of dimension nobs x nvars; each row is an
observation vector.</p>
</td></tr> 
<tr><td><code id="ncl_fit_+3A_y">y</code></td>
<td>
<p>response variable. Quantitative for <code>rfamily="clossR"</code> and -1/1 for classifications.</p>
</td></tr>
<tr><td><code id="ncl_fit_+3A_weights">weights</code></td>
<td>
<p>observation weights. Can be total counts if responses are proportion matrices. Default is 1 for each observation</p>
</td></tr>
<tr><td><code id="ncl_fit_+3A_offset">offset</code></td>
<td>
<p>this can be used to specify an a priori known component to be included in the linear predictor during fitting. This should be NULL or a numeric vector of length equal to the number of cases. Currently only one offset term can be included in the formula.</p>
</td></tr>
<tr><td><code id="ncl_fit_+3A_rfamily">rfamily</code></td>
<td>
<p>Response type and relevant loss functions (see above)</p>
</td></tr>
<tr><td><code id="ncl_fit_+3A_s">s</code></td>
<td>
<p> nonconvex loss tuning parameter for robust regression and classification. </p>
</td></tr>
<tr><td><code id="ncl_fit_+3A_fk">fk</code></td>
<td>
<p> predicted values at an iteration in the MM algorithm </p>
</td></tr>
<tr><td><code id="ncl_fit_+3A_iter">iter</code></td>
<td>
<p>number of iteration in the MM algorithm</p>
</td></tr>
<tr><td><code id="ncl_fit_+3A_reltol">reltol</code></td>
<td>
<p>convergency criteria</p>
</td></tr> 
<tr><td><code id="ncl_fit_+3A_trace">trace</code></td>
<td>
<p>If <code>TRUE</code>, fitting progress is reported</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The robust linear model is fit by majorization-minimization along with least squares.
Note that the objective function is </p>
<p style="text-align: center;"><code class="reqn">weights*loss</code>
</p>
<p>.
</p>


<h3>Value</h3>

<p>An object with S3 class <code>"ncl"</code> for the various types of models.
</p>
<table role = "presentation">
<tr><td><code>call</code></td>
<td>
<p>the call that produced the model fit</p>
</td></tr>
<tr><td><code>fitted.values</code></td>
<td>
<p>predicted values</p>
</td></tr>  
<tr><td><code>h</code></td>
<td>
<p> pseudo response values in the MM algorithm </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Zhu Wang &lt;zwang145@uthsc.edu&gt;</p>


<h3>References</h3>

<p>Zhu Wang (2021),
<em>MM for Penalized Estimation</em>,
<em>TEST</em>,
doi: <a href="https://doi.org/10.1007/s11749-021-00770-2">10.1007/s11749-021-00770-2</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ncl">ncl</a></code></p>

<hr>
<h2 id='nclreg'>Optimize a nonconvex loss with regularization</h2><span id='topic+nclreg'></span><span id='topic+nclreg.formula'></span><span id='topic+nclreg.matrix'></span><span id='topic+nclreg.default'></span>

<h3>Description</h3>

<p>Fit a linear model via penalized nonconvex loss function.  The
regularization path is computed for the lasso (or elastic net penalty), scad (or snet) and mcp (or mnet penalty), at a grid
of values for the regularization parameter lambda. The name refers to <b>N</b>on<b>C</b>onvex <b>L</b>oss with <b>REG</b>ularization.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'formula'
nclreg(formula, data, weights, offset=NULL, contrasts=NULL, ...)
## S3 method for class 'matrix'
nclreg(x, y, weights, offset=NULL, ...)
## Default S3 method:
nclreg(x,  ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nclreg_+3A_formula">formula</code></td>
<td>
<p>symbolic description of the model, see details.</p>
</td></tr>
<tr><td><code id="nclreg_+3A_data">data</code></td>
<td>
<p>argument controlling formula processing
via <code><a href="stats.html#topic+model.frame">model.frame</a></code>.</p>
</td></tr>
<tr><td><code id="nclreg_+3A_weights">weights</code></td>
<td>
<p>optional numeric vector of weights. If <code>standardize=TRUE</code>, weights are renormalized to weights/sum(weights). If <code>standardize=FALSE</code>, weights are kept as original input</p>
</td></tr>
<tr><td><code id="nclreg_+3A_x">x</code></td>
<td>
<p>input matrix, of dimension nobs x nvars; each row is an
observation vector</p>
</td></tr>
<tr><td><code id="nclreg_+3A_y">y</code></td>
<td>
<p>response variable. Quantitative for <code>rfamily="clossR"</code> and -1/1 for classification. </p>
</td></tr>
<tr><td><code id="nclreg_+3A_offset">offset</code></td>
<td>
<p>Not implemented yet</p>
</td></tr>
<tr><td><code id="nclreg_+3A_contrasts">contrasts</code></td>
<td>
<p>the contrasts corresponding to <code>levels</code> from the
respective models</p>
</td></tr>
<tr><td><code id="nclreg_+3A_...">...</code></td>
<td>
<p>Other arguments passing to <code>nclreg_fit</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The sequence of robust models implied by <code>lambda</code> is fit by majorization-minimization along with coordinate
descent. Note that the objective function is </p>
<p style="text-align: center;"><code class="reqn">weights*loss + \lambda*penalty,</code>
</p>
<p> if <code>standardize=FALSE</code> and </p>
<p style="text-align: center;"><code class="reqn">\frac{weights}{\sum(weights)}*loss + \lambda*penalty,</code>
</p>
<p> if <code>standardize=TRUE</code>. 
</p>


<h3>Value</h3>

<p>An object with S3 class <code>"nclreg"</code> for the various types of models.
</p>
<table role = "presentation">
<tr><td><code>call</code></td>
<td>
<p>the call that produced this object</p>
</td></tr>
<tr><td><code>b0</code></td>
<td>
<p>Intercept sequence of length <code>length(lambda)</code></p>
</td></tr>
<tr><td><code>beta</code></td>
<td>
<p>A <code>nvars x
      length(lambda)</code> matrix of coefficients.</p>
</td></tr>
<tr><td><code>lambda</code></td>
<td>
<p>The actual sequence of <code>lambda</code> values used</p>
</td></tr>
<tr><td><code>nobs</code></td>
<td>
<p>number of observations</p>
</td></tr>
<tr><td><code>risk</code></td>
<td>
<p>if <code>type.path="nonactive"</code>, a matrix with number of rows <code>iter</code> and number of columns <code>nlambda</code>, loss values along the regularization path. If <code>type.path="fast"</code>, a vector of length <code>nlambda</code>, loss values along the regularization path</p>
</td></tr>
<tr><td><code>pll</code></td>
<td>
<p>if <code>type.path="nonactive"</code>, a matrix with number of rows <code>iter</code> and number of columns <code>nlambda</code>, penalized loss values along the regularization path. If <code>type.path="fast"</code>, a vector of length <code>nlambda</code>, penalized loss values along the regularization path</p>
</td></tr>
<tr><td><code>fitted.values</code></td>
<td>
<p>predicted values depending on <code>standardize</code>, internal use only</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Zhu Wang &lt;zwang145@uthsc.edu&gt;</p>


<h3>References</h3>

<p>Zhu Wang (2021),
<em>MM for Penalized Estimation</em>,
<em>TEST</em>,
doi: <a href="https://doi.org/10.1007/s11749-021-00770-2">10.1007/s11749-021-00770-2</a>
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+print">print</a></code>, <code><a href="stats.html#topic+predict">predict</a></code>, <code><a href="stats.html#topic+coef">coef</a></code> and <code><a href="base.html#topic+plot">plot</a></code> methods, and the <code><a href="#topic+cv.nclreg">cv.nclreg</a></code> function.</p>


<h3>Examples</h3>

<pre><code class='language-R'>#binomial
x=matrix(rnorm(100*20),100,20)
g2=sample(c(-1,1),100,replace=TRUE)
### different solution paths via a combination of type.path, decreasing and type.init
fit1=nclreg(x,g2,s=1,rfamily="closs",type.path="active",decreasing=TRUE,type.init="bst")
fit2=nclreg(x,g2,s=1,rfamily="closs",type.path="active",decreasing=FALSE,type.init="bst")
fit3=nclreg(x,g2,s=1,rfamily="closs",type.path="nonactive",decreasing=TRUE,type.init="bst")
fit4=nclreg(x,g2,s=1,rfamily="closs",type.path="nonactive",decreasing=FALSE,type.init="bst")
fit5=nclreg(x,g2,s=1,rfamily="closs",type.path="active",decreasing=TRUE,type.init="ncl")
fit6=nclreg(x,g2,s=1,rfamily="closs",type.path="active",decreasing=FALSE,type.init="ncl")
fit7=nclreg(x,g2,s=1,rfamily="closs",type.path="nonactive",decreasing=TRUE,type.init="ncl")
fit8=nclreg(x,g2,s=1,rfamily="closs",type.path="nonactive",decreasing=FALSE,type.init="ncl")
</code></pre>

<hr>
<h2 id='nclreg_fit'>Internal function to fitting a nonconvex loss based robust linear model with regularization</h2><span id='topic+nclreg_fit'></span>

<h3>Description</h3>

<p>Fit a linear model via penalized nonconvex loss function.  The
regularization path is computed for the lasso (or elastic net penalty), scad (or snet) and mcp (or mnet penalty), at a grid
of values for the regularization parameter lambda.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nclreg_fit(x, y, weights, offset, rfamily=c("clossR", "closs", "gloss", "qloss"), 
           s=NULL, fk=NULL, iter=10, reltol=1e-5, 
           penalty=c("enet","mnet","snet"), nlambda=100,lambda=NULL, 
           type.path=c("active", "nonactive", "onestep"), decreasing=FALSE, 
           lambda.min.ratio=ifelse(nobs&lt;nvars,.05, .001), alpha=1, gamma=3, 
           standardize=TRUE, intercept=TRUE, penalty.factor=NULL, maxit=1000, 
           type.init=c("bst", "ncl", "heu"), mstop.init=10, nu.init=0.1, 
           eps=.Machine$double.eps, epscycle=10, thresh=1e-6, trace=FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nclreg_fit_+3A_x">x</code></td>
<td>
<p>input matrix, of dimension nobs x nvars; each row is an
observation vector.</p>
</td></tr> 
<tr><td><code id="nclreg_fit_+3A_y">y</code></td>
<td>
<p>response variable. Quantitative for <code>rfamily="clossR"</code> and -1/1 for classifications.</p>
</td></tr>
<tr><td><code id="nclreg_fit_+3A_weights">weights</code></td>
<td>
<p>observation weights. Can be total counts if responses are proportion matrices. Default is 1 for each observation</p>
</td></tr>
<tr><td><code id="nclreg_fit_+3A_offset">offset</code></td>
<td>
<p>this can be used to specify an a priori known component to be included in the linear predictor during fitting. This should be NULL or a numeric vector of length equal to the number of cases. Currently only one offset term can be included in the formula.</p>
</td></tr>
<tr><td><code id="nclreg_fit_+3A_rfamily">rfamily</code></td>
<td>
<p>Response type and relevant loss functions (see above)</p>
</td></tr>
<tr><td><code id="nclreg_fit_+3A_s">s</code></td>
<td>
<p> nonconvex loss tuning parameter for robust regression and classification. The <code>s</code> value is for robust nonconvex loss where smaller <code>s</code> value is more robust to outliers with <code>rfamily="closs"</code>, and larger <code>s</code> value more robust with<br /> <code>rfamily="clossR", "gloss", "qloss"</code>.</p>
</td></tr>
<tr><td><code id="nclreg_fit_+3A_fk">fk</code></td>
<td>
<p> predicted values at an iteration in the MM algorithm </p>
</td></tr>
<tr><td><code id="nclreg_fit_+3A_nlambda">nlambda</code></td>
<td>
<p>The number of <code>lambda</code> values - default is 100. The sequence may be truncated before <code>nlambda</code> is reached if a close to saturated model is fitted. See also <code>satu</code>.</p>
</td></tr>
<tr><td><code id="nclreg_fit_+3A_lambda">lambda</code></td>
<td>
<p> by default, the algorithm provides a sequence of regularization values, or a user supplied <code>lambda</code> sequence </p>
</td></tr>
<tr><td><code id="nclreg_fit_+3A_type.path">type.path</code></td>
<td>
<p>solution path. If <code>type.path="active"</code>, then cycle through only the active set in the next increasing <code>lambda</code> sequence. If <code>type.path="nonactive"</code>, no active set for each element of the lambda sequence and cycle through all the predictor variables. If <code>type.path="onestep"</code>, update for one element of lambda depending on <code>decreasing=FALSE</code> (last element of lambda) or <code>decreasing=TRUE</code> (then first element of lambda) in each MM iteration, and iterate until convergency of prediction. Then fit a solution path based on the sequence of lambda.</p>
</td></tr>
<tr><td><code id="nclreg_fit_+3A_lambda.min.ratio">lambda.min.ratio</code></td>
<td>
<p>Smallest value for <code>lambda</code>, as a fraction of
<code>lambda.max</code>, the (data derived) entry value (i.e. the smallest
value for which all coefficients are zero except the intercept). Note, there is no closed formula for <code>lambda.max</code>. The default of <code>lambda.min.ratio</code> depends on the
sample size <code>nobs</code> relative to the number of variables
<code>nvars</code>. If <code>nobs &gt; nvars</code>, the default is <code>0.001</code>,
close to zero.  If <code>nobs &lt; nvars</code>, the default is <code>0.05</code>.</p>
</td></tr>
<tr><td><code id="nclreg_fit_+3A_alpha">alpha</code></td>
<td>
<p>The <code class="reqn">L_2</code> penalty mixing parameter, with
<code class="reqn">0 \le alpha\le 1</code>. <code>alpha=1</code> is lasso (mcp, scad) penalty; and <code>alpha=0</code> the ridge penalty. However, if <code>alpha=0</code>, one must provide <code>lambda</code> values.</p>
</td></tr>
<tr><td><code id="nclreg_fit_+3A_gamma">gamma</code></td>
<td>
<p>The tuning parameter of the <code>snet</code> or <code>mnet</code> penalty.</p>
</td></tr>
<tr><td><code id="nclreg_fit_+3A_standardize">standardize</code></td>
<td>
<p>logical value for x variable standardization, prior to
fitting the model sequence. The coefficients are always returned on
the original scale. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="nclreg_fit_+3A_intercept">intercept</code></td>
<td>
<p>logical value: if TRUE (default), intercept(s) are fitted; otherwise, intercept(s)  are set to zero</p>
</td></tr>
<tr><td><code id="nclreg_fit_+3A_penalty.factor">penalty.factor</code></td>
<td>
<p>This is a number that multiplies <code>lambda</code> to allow
differential shrinkage of coefficients. Can be 0 for some variables, which implies
no shrinkage, and that variable is always included in the
model. Default is same shrinkage for all variables.</p>
</td></tr>
<tr><td><code id="nclreg_fit_+3A_type.init">type.init</code></td>
<td>
<p>a method to determine the initial values. If <code>type.init="ncl"</code>, an intercept-only model as initial parameter and run <code>nclreg</code> regularization path forward from lambda_max to lambda_min. If <code>type.init="heu"</code>, heuristic initial parameters and run <code>nclreg</code> path backward or forward depending on <code>decreasing</code>, between lambda_min and lambda_max. If <code>type.init="bst"</code>, run a boosting model with <code>bst</code> in package bst, depending on <code>mstop.init, nu.init</code> and run <code>nclreg</code> backward or forward depending on <code>decreasing</code>.</p>
</td></tr>
<tr><td><code id="nclreg_fit_+3A_mstop.init">mstop.init</code></td>
<td>
<p> an integer giving the number of boosting iterations when <code>type.init="bst"</code> </p>
</td></tr>
<tr><td><code id="nclreg_fit_+3A_nu.init">nu.init</code></td>
<td>
<p> a small number (between 0 and 1) defining the step size or shrinkage parameter when <code>type.init="bst"</code>. </p>
</td></tr>
<tr><td><code id="nclreg_fit_+3A_decreasing">decreasing</code></td>
<td>
<p> only used if <code>lambda=NULL</code>, a logical value used to    determine regularization path direction either from lambda_max to a potentially modified lambda_min or vice versa if <code>type.init="bst","heu"</code>. Since this is a nonconvex optimization, it is possible to generate different estimates for the same <code>lambda</code> depending on <code>decreasing</code>.  The choice of <code>decreasing</code> picks different starting values.</p>
</td></tr>
<tr><td><code id="nclreg_fit_+3A_iter">iter</code></td>
<td>
<p>number of iteration in the MM algorithm</p>
</td></tr>
<tr><td><code id="nclreg_fit_+3A_maxit">maxit</code></td>
<td>
<p>Within each MM algorithm iteration, maximum number of coordinate  descent iterations for each <code>lambda</code> value; default is 1000.</p>
</td></tr>
<tr><td><code id="nclreg_fit_+3A_reltol">reltol</code></td>
<td>
<p>convergency criteria</p>
</td></tr> 
<tr><td><code id="nclreg_fit_+3A_eps">eps</code></td>
<td>
<p>If a coefficient is less than <code>eps</code> in magnitude, then it is reported to be 0</p>
</td></tr>
<tr><td><code id="nclreg_fit_+3A_epscycle">epscycle</code></td>
<td>
<p> If <code>nlambda</code> &gt; 1 and the relative loss values from two consecutive <code>lambda</code> values change &gt; <code>epscycle</code>, then re-estimate parameters in an effort to avoid trap of local optimization.</p>
</td></tr>
<tr><td><code id="nclreg_fit_+3A_thresh">thresh</code></td>
<td>
<p>Convergence threshold for coordinate descent. Defaults value is <code>1e-6</code>.</p>
</td></tr>
<tr><td><code id="nclreg_fit_+3A_penalty">penalty</code></td>
<td>
<p>Type of regularization</p>
</td></tr>
<tr><td><code id="nclreg_fit_+3A_trace">trace</code></td>
<td>
<p>If <code>TRUE</code>, fitting progress is reported</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The sequence of robust models implied by <code>lambda</code> is fit by majorization-minimization along with coordinate
descent. Note that the objective function is </p>
<p style="text-align: center;"><code class="reqn">weights*loss + \lambda*penalty,</code>
</p>
<p> if <code>standardize=FALSE</code> and </p>
<p style="text-align: center;"><code class="reqn">\frac{weights}{\sum(weights)}*loss + \lambda*penalty,</code>
</p>
<p> if <code>standardize=TRUE</code>.
</p>


<h3>Value</h3>

<p>An object with S3 class <code>"nclreg"</code> for the various types of models.
</p>
<table role = "presentation">
<tr><td><code>call</code></td>
<td>
<p>the call that produced the model fit</p>
</td></tr>
<tr><td><code>b0</code></td>
<td>
<p>Intercept sequence of length <code>length(lambda)</code></p>
</td></tr>
<tr><td><code>beta</code></td>
<td>
<p>A <code>nvars x length(lambda)</code> matrix of coefficients.</p>
</td></tr>
<tr><td><code>lambda</code></td>
<td>
<p>The actual sequence of <code>lambda</code> values used</p>
</td></tr>
<tr><td><code>decreasing</code></td>
<td>
<p> if <code>lambda</code> is an increasing sequence or not, used to determine regularization path direction either from lambda_max to a potentially modified lambda_min or vice versa if <code>type.init="bst", "heu"</code>. </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Zhu Wang &lt;zwang145@uthsc.edu&gt;</p>


<h3>References</h3>

<p>Zhu Wang (2021),
<em>MM for Penalized Estimation</em>,
<em>TEST</em>,
doi: <a href="https://doi.org/10.1007/s11749-021-00770-2">10.1007/s11749-021-00770-2</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+nclreg">nclreg</a></code></p>

<hr>
<h2 id='plot.glmreg'>plot coefficients from a &quot;glmreg&quot; object</h2><span id='topic+plot.glmreg'></span>

<h3>Description</h3>

<p>Produces a coefficient profile plot of the coefficient paths for a
fitted <code>"glmreg"</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'glmreg'
plot(x, xvar = c("norm", "lambda", "dev"), label = FALSE, shade=TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.glmreg_+3A_x">x</code></td>
<td>
<p>fitted <code>"glmreg"</code> model</p>
</td></tr>
<tr><td><code id="plot.glmreg_+3A_xvar">xvar</code></td>
<td>
<p>What is on the X-axis. <code>"norm"</code> plots against the
L1-norm of the coefficients, <code>"lambda"</code> against the log-lambda
sequence, and <code>"dev"</code> against the percent deviance explained.</p>
</td></tr>
<tr><td><code id="plot.glmreg_+3A_label">label</code></td>
<td>
<p>If <code>TRUE</code>, label the curves with variable sequence
numbers.</p>
</td></tr>
<tr><td><code id="plot.glmreg_+3A_shade">shade</code></td>
<td>
<p>Should nonconvex region be shaded?  Default is TRUE. Code developed for all <code>weights=1</code> only</p>
</td></tr>
<tr><td><code id="plot.glmreg_+3A_...">...</code></td>
<td>
<p>Other graphical parameters to plot</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A coefficient profile plot is produced. 
</p>


<h3>Author(s)</h3>

<p>Zhu Wang zwang145@uthsc.edu</p>


<h3>See Also</h3>

<p><code>glmreg</code>, and <code>print</code>, <code>predict</code> and <code>coef</code> methods.</p>


<h3>Examples</h3>

<pre><code class='language-R'>x=matrix(rnorm(100*20),100,20)
y=rnorm(100)
fit1=glmreg(x,y)
plot(fit1)
plot(fit1,xvar="lambda",label=TRUE)
</code></pre>

<hr>
<h2 id='predict.glmreg'>Model predictions based on a fitted &quot;glmreg&quot; object.</h2><span id='topic+predict.glmreg'></span><span id='topic+coef.glmreg'></span>

<h3>Description</h3>

<p>This function returns predictions from
a fitted <code>"glmreg"</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'glmreg'
predict(object,newx,newoffset,which=1:length(object$lambda),
type=c("link","response","class","coefficients","nonzero"), na.action=na.pass, ...)
## S3 method for class 'glmreg'
coef(object,which=1:length(object$lambda),...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict.glmreg_+3A_object">object</code></td>
<td>
<p>Fitted <code>"glmreg"</code> model object.</p>
</td></tr>
<tr><td><code id="predict.glmreg_+3A_newx">newx</code></td>
<td>
<p>Matrix of values at which predictions are to be made.  Not
used for <code>type="coefficients"</code></p>
</td></tr>
<tr><td><code id="predict.glmreg_+3A_which">which</code></td>
<td>
<p>Indices of the penalty parameter <code>lambda</code> at which
predictions are required.  By default, all indices are returned.</p>
</td></tr>
<tr><td><code id="predict.glmreg_+3A_type">type</code></td>
<td>
<p>Type of prediction: <code>"link"</code> returns the
linear predictors; <code>"response"</code> gives the fitted values;
<code>"class"</code> returns the binomial outcome with the highest
probability; <code>"coefficients"</code> returns the coefficients.</p>
</td></tr>
<tr><td><code id="predict.glmreg_+3A_newoffset">newoffset</code></td>
<td>
<p>an offset term used in prediction</p>
</td></tr>
<tr><td><code id="predict.glmreg_+3A_na.action">na.action</code></td>
<td>
<p>action for missing data value</p>
</td></tr>
<tr><td><code id="predict.glmreg_+3A_...">...</code></td>
<td>
<p> arguments for predict </p>
</td></tr></table>


<h3>Value</h3>

<p>The returned object depends on <code>type</code>.</p>


<h3>Author(s)</h3>

<p>Zhu Wang &lt;zwang145@uthsc.edu&gt;</p>


<h3>References</h3>

<p>Zhu Wang, Shuangge Ma, Michael Zappitelli, Chirag Parikh, Ching-Yun Wang and Prasad Devarajan (2014)
<em>Penalized Count Data Regression with Application to Hospital Stay after Pediatric Cardiac Surgery</em>, <em>Statistical Methods in Medical Research</em>. 2014 Apr 17. [Epub ahead of print]
</p>


<h3>See Also</h3>

<p><code><a href="#topic+glmreg">glmreg</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Dobson (1990) Page 93: Randomized Controlled Trial :
counts &lt;- c(18,17,15,20,10,20,25,13,12)
outcome &lt;- gl(3,1,9)
treatment &lt;- gl(3,3)
print(d.AD &lt;- data.frame(treatment, outcome, counts))
fit &lt;- glmreg(counts ~ outcome + treatment, data=d.AD, family="poisson")
predict(fit, newx=d.AD[,1:2])
summary(fit)
coef(fit)
</code></pre>

<hr>
<h2 id='predict.zipath'>Methods for zipath Objects</h2><span id='topic+predict.zipath'></span><span id='topic+residuals.zipath'></span><span id='topic+terms.zipath'></span><span id='topic+model.matrix.zipath'></span><span id='topic+coef.zipath'></span><span id='topic+summary.zipath'></span><span id='topic+print.summary.zipath'></span><span id='topic+logLik.zipath'></span><span id='topic+fitted.zipath'></span><span id='topic+predprob.zipath'></span>

<h3>Description</h3>

<p>Methods for extracting information from fitted penalized zero-inflated
regression model objects of class <code>"zipath"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'zipath'
predict(object, newdata,  which = 1:object$nlambda, 
  type = c("response", "prob", "count", "zero", "nonzero"), na.action = na.pass,
  at = NULL, ...)
## S3 method for class 'zipath'
residuals(object, type = c("pearson", "response"), ...)

## S3 method for class 'zipath'
coef(object, which=1:object$nlambda, model = c("full", "count", "zero"), ...)

## S3 method for class 'zipath'
terms(x, model = c("count", "zero"), ...)
## S3 method for class 'zipath'
model.matrix(object, model = c("count", "zero"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict.zipath_+3A_object">object</code>, <code id="predict.zipath_+3A_x">x</code></td>
<td>
<p>an object of class <code>"zipath"</code> as returned by
<code><a href="#topic+zipath">zipath</a></code>.</p>
</td></tr>
<tr><td><code id="predict.zipath_+3A_newdata">newdata</code></td>
<td>
<p>optionally, a data frame in which to look for variables with
which to predict. If omitted, the original observations are used.</p>
</td></tr>
<tr><td><code id="predict.zipath_+3A_which">which</code></td>
<td>
<p>Indices of the penalty parameters <code>lambda</code> at which
predictions are required.  By default, all indices are returned.</p>
</td></tr>
<tr><td><code id="predict.zipath_+3A_type">type</code></td>
<td>
<p>character specifying the type of predictions or residuals,
respectively. For details see below.</p>
</td></tr>
<tr><td><code id="predict.zipath_+3A_na.action">na.action</code></td>
<td>
<p>function determining what should be done with missing values
in <code>newdata</code>. The default is to predict <code>NA</code>.</p>
</td></tr>
<tr><td><code id="predict.zipath_+3A_at">at</code></td>
<td>
<p>optionally, if <code>type = "prob"</code>, a numeric vector at which
the probabilities are evaluated. By default <code>0:max(y)</code> is used
where <code>y</code> is the original observed response.</p>
</td></tr>
<tr><td><code id="predict.zipath_+3A_model">model</code></td>
<td>
<p>character specifying for which component of the model the
terms or model matrix should be extracted.</p>
</td></tr>
<tr><td><code id="predict.zipath_+3A_...">...</code></td>
<td>
<p>currently not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Re-uses the design of function zeroinfl in package pscl (see reference). A set of standard extractor functions for fitted model objects is available for
objects of class <code>"zipath"</code>, including methods to the generic functions
<code><a href="base.html#topic+print">print</a></code> and <code><a href="base.html#topic+summary">summary</a></code> which print the estimated
coefficients along with some further information. 
As usual, the <code>summary</code> method returns an object of class <code>"summary.zipath"</code>
containing the relevant summary statistics which can subsequently be printed
using the associated <code>print</code> method.
</p>
<p>The methods for <code><a href="stats.html#topic+coef">coef</a></code> by default
return a single vector of coefficients and their associated covariance matrix,
respectively, i.e., all coefficients are concatenated. By setting the <code>model</code>
argument, the estimates for the corresponding model components can be extracted.
</p>
<p>Both the <code><a href="stats.html#topic+fitted">fitted</a></code> and <code><a href="stats.html#topic+predict">predict</a></code> methods can
compute fitted responses. The latter additionally provides the predicted density
(i.e., probabilities for the observed counts), the predicted mean from the count
component (without zero inflation) and the predicted probability for the zero
component. The <code><a href="stats.html#topic+residuals">residuals</a></code> method can compute
raw residuals (observed - fitted) and Pearson residuals (raw residuals scaled by
square root of variance function).
</p>


<h3>Author(s)</h3>

<p>Zhu Wang &lt;zwang145@uthsc.edu&gt;</p>


<h3>References</h3>

<p>Zhu Wang, Shuangge Ma, Michael Zappitelli, Chirag Parikh, Ching-Yun Wang and Prasad Devarajan (2014)      <em>Penalized Count Data Regression with Application to Hospital Stay after Pediatric Cardiac Surgery</em>, <em>Statistical Methods in Medical Research</em>. 2014 Apr 17. [Epub ahead of print]
</p>
<p>Zhu Wang, Shuangge Ma, Ching-Yun Wang, Michael Zappitelli, Prasad Devarajan and Chirag R. Parikh (2014)
<em>EM for Regularized Zero Inflated Regression Models with Applications to Postoperative Morbidity after Cardiac Surgery in Children</em>, <em>Statistics in Medicine</em>. 33(29):5192-208.
</p>
<p>Zhu Wang, Shuangge Ma and Ching-Yun Wang (2015) <em>Variable selection for zero-inflated and overdispersed data with application to health care demand in Germany</em>, <em>Biometrical Journal</em>. 57(5):867-84.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+zipath">zipath</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data("bioChemists", package = "pscl")
fm_zip &lt;- zipath(art ~ . | ., data = bioChemists, nlambda=10)
plot(residuals(fm_zip) ~ fitted(fm_zip))
coef(fm_zip, model = "count")
coef(fm_zip, model = "zero")
summary(fm_zip)
logLik(fm_zip)

## End(Not run)
</code></pre>

<hr>
<h2 id='pval.zipath'>compute p-values from penalized zero-inflated model with multi-split data</h2><span id='topic+pval.zipath'></span>

<h3>Description</h3>

<p>compute p-values from penalized zero-inflated Poisson, negative binomial and geometric model with multi-split data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pval.zipath(formula, data, weights, subset, na.action, offset, standardize=TRUE,
            family = c("poisson", "negbin", "geometric"),
            penalty = c("enet", "mnet", "snet"), gamma.count = 3, 
            gamma.zero = 3, prop=0.5, trace=TRUE, B=10, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pval.zipath_+3A_formula">formula</code></td>
<td>
<p>symbolic description of the model, see details.</p>
</td></tr>
<tr><td><code id="pval.zipath_+3A_data">data</code></td>
<td>
<p>argument controlling formula processing
via <code><a href="stats.html#topic+model.frame">model.frame</a></code>.</p>
</td></tr>
<tr><td><code id="pval.zipath_+3A_weights">weights</code></td>
<td>
<p>optional numeric vector of weights. If <code>standardize=TRUE</code>, weights are renormalized to weights/sum(weights). If <code>standardize=FALSE</code>, weights are kept as original input</p>
</td></tr>
<tr><td><code id="pval.zipath_+3A_subset">subset</code></td>
<td>
<p>subset of data</p>
</td></tr>
<tr><td><code id="pval.zipath_+3A_na.action">na.action</code></td>
<td>
<p>how to deal with missing data</p>
</td></tr>
<tr><td><code id="pval.zipath_+3A_offset">offset</code></td>
<td>
<p>Not implemented yet</p>
</td></tr>
<tr><td><code id="pval.zipath_+3A_standardize">standardize</code></td>
<td>
<p>logical value, should variables be standardized?</p>
</td></tr>
<tr><td><code id="pval.zipath_+3A_family">family</code></td>
<td>
<p>family to fit <code>zipath</code></p>
</td></tr>
<tr><td><code id="pval.zipath_+3A_penalty">penalty</code></td>
<td>
<p>penalty considered as one of <code>enet, mnet, snet</code>.</p>
</td></tr>
<tr><td><code id="pval.zipath_+3A_gamma.count">gamma.count</code></td>
<td>
<p>The tuning parameter of the <code>snet</code> or <code>mnet</code> penalty for the count part of model.</p>
</td></tr>
<tr><td><code id="pval.zipath_+3A_gamma.zero">gamma.zero</code></td>
<td>
<p>The tuning parameter of the <code>snet</code> or <code>mnet</code> penalty for the zero part of model.</p>
</td></tr>  
<tr><td><code id="pval.zipath_+3A_prop">prop</code></td>
<td>
<p>proportion of data split, default is 50/50 split</p>
</td></tr>
<tr><td><code id="pval.zipath_+3A_trace">trace</code></td>
<td>
<p>logical value, if TRUE, print detailed calculation results</p>
</td></tr>
<tr><td><code id="pval.zipath_+3A_b">B</code></td>
<td>
<p>number of repeated multi-split replications</p>
</td></tr> 
<tr><td><code id="pval.zipath_+3A_...">...</code></td>
<td>
<p>Other arguments passing to <code>glmreg_fit</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>compute p-values from penalized zero-inflated Poisson, negative binomial and geometric model with multi-split data
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>count.pval</code></td>
<td>
<p>raw p-values in the count component</p>
</td></tr>
<tr><td><code>zero.pval</code></td>
<td>
<p>raw p-values in the zero component</p>
</td></tr>
<tr><td><code>count.pval.q</code></td>
<td>
<p>Q value for the count component</p>
</td></tr>
<tr><td><code>zero.pval.q</code></td>
<td>
<p>Q value for the zero component</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Zhu Wang &lt;zwang145@uthsc.edu&gt;</p>


<h3>References</h3>

<p>Nicolai Meinshausen, Lukas Meier and Peter Buehlmann (2013)
<em>p-Values for High-Dimensional Regression</em>, <em>Journal of the American Statistical Association</em>, 104(488), 1671&ndash;1681.
</p>
<p>Zhu Wang, Shuangge Ma, Ching-Yun Wang, Michael Zappitelli, Prasad Devarajan and Chirag R. Parikh (2014)
<em>EM for Regularized Zero Inflated Regression Models with Applications to Postoperative Morbidity after Cardiac Surgery in Children</em>, <em>Statistics in Medicine</em>. 33(29):5192-208.
</p>
<p>Zhu Wang, Shuangge Ma and Ching-Yun Wang (2015) <em>Variable selection for zero-inflated and overdispersed data with application to health care demand in Germany</em>, <em>Biometrical Journal</em>. 57(5):867-84.
</p>

<hr>
<h2 id='rzi'>random number generation of zero-inflated count response</h2><span id='topic+rzi'></span>

<h3>Description</h3>

<p>random number generation of zero-inflated count response
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rzi(n, x, z, a, b, theta=1, family=c("poisson", "negbin", "geometric"), infl=TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rzi_+3A_n">n</code></td>
<td>
<p>sample size of random number generation</p>
</td></tr>
<tr><td><code id="rzi_+3A_x">x</code></td>
<td>
<p>design matrix of count model</p>
</td></tr>
<tr><td><code id="rzi_+3A_z">z</code></td>
<td>
<p>design matrix of zero model</p>
</td></tr>
<tr><td><code id="rzi_+3A_a">a</code></td>
<td>
<p>coefficient vector for <code>x</code>, length must be the same as column size of <code>x</code></p>
</td></tr>
<tr><td><code id="rzi_+3A_b">b</code></td>
<td>
<p>coefficient vector for <code>z</code>, length must be the same as column size of <code>z</code></p>
</td></tr>
<tr><td><code id="rzi_+3A_theta">theta</code></td>
<td>
<p>dispersion parameter for <code>family="negbin"</code></p>
</td></tr>
<tr><td><code id="rzi_+3A_family">family</code></td>
<td>
<p>distribution of count model</p>
</td></tr>
<tr><td><code id="rzi_+3A_infl">infl</code></td>
<td>
<p>logical value, if TRUE, zero-inflated count response</p>
</td></tr>
</table>


<h3>Details</h3>

<p>random number generation of zero-inflated count response</p>


<h3>Value</h3>

<p>numeric vector of zero-inflated count response</p>


<h3>Author(s)</h3>

<p>Zhu Wang &lt;zwang145@uthsc.edu&gt;</p>


<h3>References</h3>

<p>Zhu Wang, Shuangge Ma, Ching-Yun Wang, Michael Zappitelli, Prasad Devarajan and Chirag R. Parikh (2014)
<em>EM for Regularized Zero Inflated Regression Models with Applications to Postoperative Morbidity after Cardiac Surgery in Children</em>, <em>Statistics in Medicine</em>. 33(29):5192-208.
</p>
<p>Zhu Wang, Shuangge Ma and Ching-Yun Wang (2015) <em>Variable selection for zero-inflated and overdispersed data with application to health care demand in Germany</em>, <em>Biometrical Journal</em>. 57(5):867-84.
</p>

<hr>
<h2 id='sandwichReg'>Making Sandwiches with Bread and Meat for Regularized Estimators</h2><span id='topic+sandwichReg'></span>

<h3>Description</h3>

<p>Constructing sandwich covariance matrix estimators by
multiplying bread and meat matrices for regularized regression parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sandwichReg(x, breadreg.=breadReg, meatreg.=meatReg, which, log=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sandwichReg_+3A_x">x</code></td>
<td>
<p>a fitted model object.</p>
</td></tr>
<tr><td><code id="sandwichReg_+3A_breadreg.">breadreg.</code></td>
<td>
<p>either a breadReg matrix or a function for computing
this via <code>breadreg.(x)</code>.</p>
</td></tr>
<tr><td><code id="sandwichReg_+3A_meatreg.">meatreg.</code></td>
<td>
<p>either a breadReg matrix or a function for computing
this via <code>meatreg.(x, ...)</code>.</p>
</td></tr>
<tr><td><code id="sandwichReg_+3A_which">which</code></td>
<td>
<p>which penalty parameters(s) to compute?</p>
</td></tr>
<tr><td><code id="sandwichReg_+3A_log">log</code></td>
<td>
<p>if TRUE, the corresponding element is with respect to log(theta) in negative binomial regression. Otherwise, for theta</p>
</td></tr> 
<tr><td><code id="sandwichReg_+3A_...">...</code></td>
<td>
<p>arguments passed to the <code>meatReg</code> function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>sandwichReg</code> is a function to compute an estimator for the covariance of the non-zero parameters. It takes a breadReg matrix (i.e., estimator of the expectation of the negative
derivative of the penalized estimating functions) and a meatReg matrix (i.e.,
estimator of the variance of the log-likelihood function) and multiplies
them to a sandwich with meat between two slices of bread. By default
<code><a href="#topic+breadReg">breadReg</a></code> and <code><a href="#topic+meatReg">meatReg</a></code> are called. Implemented only for <code>zipath</code> object with <code>family="negbin"</code> in the current version. 
</p>


<h3>Value</h3>

<p>A matrix containing the sandwich covariance matrix estimate for the non-zero parameters.</p>


<h3>Author(s)</h3>

<p>Zhu Wang &lt;zwang145@uthsc.edu&gt;</p>


<h3>References</h3>

<p>Zhu Wang, Shuangge Ma and Ching-Yun Wang (2015) <em>Variable selection for zero-inflated and overdispersed data with application to health care demand in Germany</em>, <em>Biometrical Journal</em>. 57(5):867-84.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+breadReg">breadReg</a></code>, <code><a href="#topic+meatReg">meatReg</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data("bioChemists", package = "pscl")
fm_zinb &lt;- zipath(art ~ . | ., data = bioChemists, family = "negbin", nlambda=10, maxit.em=1)
sandwichReg(fm_zinb, which=which.min(fm_zinb$bic))
</code></pre>

<hr>
<h2 id='se'>Standard Error of Regularized Estimators</h2><span id='topic+se'></span><span id='topic+se.zipath'></span>

<h3>Description</h3>

<p>Generic function for computing standard errors of non-zero regularized estimators
</p>


<h3>Usage</h3>

<pre><code class='language-R'>se(x, which, log=TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="se_+3A_x">x</code></td>
<td>
<p>a fitted model object.</p>
</td></tr>
<tr><td><code id="se_+3A_which">which</code></td>
<td>
<p>which penalty parameter(s)?</p>
</td></tr>
<tr><td><code id="se_+3A_log">log</code></td>
<td>
<p>if TRUE, the computed standard error is for log(theta) for negative binomial regression, otherwise, for theta.</p>
</td></tr>
<tr><td><code id="se_+3A_...">...</code></td>
<td>
<p>arguments passed to methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector containing standard errors of non-zero regularized estimators.</p>


<h3>Author(s)</h3>

<p>Zhu Wang &lt;zwang145@uthsc.edu&gt;</p>


<h3>References</h3>

<p>Zhu Wang, Shuangge Ma and Ching-Yun Wang (2015) <em>Variable selection for zero-inflated and overdispersed data with application to health care demand in Germany</em>, <em>Biometrical Journal</em>. 57(5):867-84.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+zipath">zipath</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data("bioChemists", package = "pscl")
fm_zinb &lt;- zipath(art ~ . | ., data = bioChemists, family = "negbin", nlambda=10, maxit.em=1)
res &lt;- se(fm_zinb, which=which.min(fm_zinb$bic))
</code></pre>

<hr>
<h2 id='stan'>standardize variables</h2><span id='topic+stan'></span>

<h3>Description</h3>

<p>Standardize variables. For each column, return mean 0 and mean value of sum of squares = 1.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stan(x, weights)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="stan_+3A_x">x</code></td>
<td>
<p>numeric variables, can be a matrix or vector</p>
</td></tr>
<tr><td><code id="stan_+3A_weights">weights</code></td>
<td>
<p>numeric positive vector of weights</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following items.
</p>
<table role = "presentation">
<tr><td><code>x</code></td>
<td>
<p>standardized variables with each column: mean value 0 and mean value of sum of squares = 1.</p>
</td></tr>
<tr><td><code>meanx</code></td>
<td>
<p>a vector of means for each column in the original <code>x</code></p>
</td></tr>
<tr><td><code>normx</code></td>
<td>
<p>a vector of scales for each column in the original <code>x</code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Zhu Wang &lt;zwang145@uthsc.edu&gt;</p>

<hr>
<h2 id='summary.glmregNB'>
Summary Method Function for Objects of Class 'glmregNB'
</h2><span id='topic+summary.glmregNB'></span><span id='topic+print.summary.glmregNB'></span>

<h3>Description</h3>

<p>Summary results of fitted penalized negative binomial regression model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'glmregNB'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.glmregNB_+3A_object">object</code></td>
<td>

<p>fitted model object of class <code>glmregNB</code>.
</p>
</td></tr>
<tr><td><code id="summary.glmregNB_+3A_...">...</code></td>
<td>

<p>arguments passed to or from other methods.
</p>
</td></tr></table>


<h3>Details</h3>

<p>This function is a method for the generic function
<code>summary()</code> for class <code>"glmregNB"</code>.
It can be invoked by calling <code>summary(x)</code> for an
object <code>x</code> of the appropriate class, or directly by
calling <code>summary.glmregNB(x)</code> regardless of the
class of the object.
</p>


<h3>Value</h3>

<p>Summary of fitted penalized negative binomial model
</p>


<h3>Author(s)</h3>

<p>Zhu Wang &lt;zwang145@uthsc.edu&gt;</p>


<h3>References</h3>

<p>Zhu Wang, Shuangge Ma, Michael Zappitelli, Chirag Parikh, Ching-Yun Wang and Prasad Devarajan (2014)
<em>Penalized Count Data Regression with Application to Hospital Stay after Pediatric Cardiac Surgery</em>, <em>Statistical Methods in Medical Research</em>. 2014 Apr 17. [Epub ahead of print]
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+summary">summary</a></code>, <code><a href="MASS.html#topic+glm.nb">glm.nb</a></code></p>

<hr>
<h2 id='tuning.zipath'>find optimal path for penalized zero-inflated model</h2><span id='topic+tuning.zipath'></span>

<h3>Description</h3>

<p>Fit penalized zero-inflated models, generate multiple paths with varying penalty parameters, therefore determine optimal path with respect to a particular penalty parameter
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tuning.zipath(formula, data, weights, subset, na.action, offset, standardize=TRUE,
              family = c("poisson", "negbin", "geometric"), 
              penalty = c("enet", "mnet", "snet"), lambdaCountRatio = .0001, 
              lambdaZeroRatio = c(.1, .01, .001), maxit.theta=1, gamma.count=3, 
              gamma.zero=3, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tuning.zipath_+3A_formula">formula</code></td>
<td>
<p>symbolic description of the model, see details.</p>
</td></tr>
<tr><td><code id="tuning.zipath_+3A_data">data</code></td>
<td>
<p>argument controlling formula processing
via <code><a href="stats.html#topic+model.frame">model.frame</a></code>.</p>
</td></tr>
<tr><td><code id="tuning.zipath_+3A_weights">weights</code></td>
<td>
<p>optional numeric vector of weights. If <code>standardize=TRUE</code>, weights are renormalized to weights/sum(weights). If <code>standardize=FALSE</code>, weights are kept as original input</p>
</td></tr>
<tr><td><code id="tuning.zipath_+3A_subset">subset</code></td>
<td>
<p>subset of data</p>
</td></tr>
<tr><td><code id="tuning.zipath_+3A_na.action">na.action</code></td>
<td>
<p>how to deal with missing data</p>
</td></tr>
<tr><td><code id="tuning.zipath_+3A_offset">offset</code></td>
<td>
<p>Not implemented yet</p>
</td></tr>
<tr><td><code id="tuning.zipath_+3A_standardize">standardize</code></td>
<td>
<p>logical value, should variables be standardized?</p>
</td></tr>
<tr><td><code id="tuning.zipath_+3A_family">family</code></td>
<td>
<p>family to fit</p>
</td></tr>
<tr><td><code id="tuning.zipath_+3A_penalty">penalty</code></td>
<td>
<p>penalty considered as one of <code>enet, mnet, snet</code>.</p>
</td></tr>
<tr><td><code id="tuning.zipath_+3A_lambdacountratio">lambdaCountRatio</code>, <code id="tuning.zipath_+3A_lambdazeroratio">lambdaZeroRatio</code></td>
<td>
<p>Smallest value for <code>lambda.count</code>
and <code>lambda.zero</code>, respectively, as a fraction of
<code>lambda.max</code>, the (data derived) entry value (i.e. the smallest
value for which all coefficients are zero except the intercepts). This lambda.max can be a surrogate value for <code>penalty="mnet"</code> or <code>"snet"</code></p>
</td></tr>
<tr><td><code id="tuning.zipath_+3A_maxit.theta">maxit.theta</code></td>
<td>
<p>For family=&quot;negbin&quot;, the maximum iteration allowed for estimating scale parameter theta. Note, the default value 1 is for computing speed purposes, and is typically too small and less desirable in real data analysis</p>
</td></tr>
<tr><td><code id="tuning.zipath_+3A_gamma.count">gamma.count</code></td>
<td>
<p>The tuning parameter of the <code>snet</code> or <code>mnet</code> penalty for the count part of model.</p>
</td></tr>
<tr><td><code id="tuning.zipath_+3A_gamma.zero">gamma.zero</code></td>
<td>
<p>The tuning parameter of the <code>snet</code> or <code>mnet</code> penalty for the zero part of model.</p>
</td></tr>
<tr><td><code id="tuning.zipath_+3A_...">...</code></td>
<td>
<p>Other arguments passing to <code>zipath</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>From the default <code>lambdaZeroRatio = c(.1, .01, .001)</code> values, 
find optimal lambdaZeroRatio for penalized zero-inflated Poisson, negative binomial and geometric model 
</p>


<h3>Value</h3>

<p>An object of class zipath with the optimal lambdaZeroRatio
</p>


<h3>Author(s)</h3>

<p>Zhu Wang &lt;zwang145@uthsc.edu&gt;</p>


<h3>References</h3>

<p>Zhu Wang, Shuangge Ma, Michael Zappitelli, Chirag Parikh, Ching-Yun Wang and Prasad Devarajan (2014)      <em>Penalized Count Data Regression with Application to Hospital Stay after Pediatric Cardiac Surgery</em>, <em>Statistical Methods in Medical Research</em>. 2014 Apr 17. [Epub ahead of print]
</p>
<p>Zhu Wang, Shuangge Ma, Ching-Yun Wang, Michael Zappitelli, Prasad Devarajan and Chirag R. Parikh (2014)
<em>EM for Regularized Zero Inflated Regression Models with Applications to Postoperative Morbidity after Cardiac Surgery in Children</em>, <em>Statistics in Medicine</em>. 33(29):5192-208.
</p>
<p>Zhu Wang, Shuangge Ma and Ching-Yun Wang (2015) <em>Variable selection for zero-inflated and overdispersed data with application to health care demand in Germany</em>, <em>Biometrical Journal</em>. 57(5):867-84.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+zipath">zipath</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## data
data("bioChemists", package = "pscl")

## inflation with regressors
## ("art ~ . | ." is "art ~ fem + mar + kid5 + phd + ment | fem + mar + kid5 + phd + ment")
fm_zip2 &lt;- tuning.zipath(art ~ . | ., data = bioChemists, nlambda=10)
summary(fm_zip2)
fm_zinb2 &lt;- tuning.zipath(art ~ . | ., data = bioChemists, family = "negbin", nlambda=10)
summary(fm_zinb2)

## End(Not run)
</code></pre>

<hr>
<h2 id='update_wt'>Compute weight value</h2><span id='topic+update_wt'></span>

<h3>Description</h3>

<p>Compute weight value
</p>


<h3>Usage</h3>

<pre><code class='language-R'>update_wt(y, ypre, weights, cfun, s, dfun, delta=0.0001)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="update_wt_+3A_y">y</code></td>
<td>
<p>input value of response variable</p>
</td></tr>
<tr><td><code id="update_wt_+3A_ypre">ypre</code></td>
<td>
<p>predicted value of response variable</p>
</td></tr>
<tr><td><code id="update_wt_+3A_weights">weights</code></td>
<td>
<p>optional numeric vector of weights.</p>
</td></tr>
<tr><td><code id="update_wt_+3A_cfun">cfun</code></td>
<td>
<p>integer from 1-8, concave function as in <code>irglm_fit</code></p>
</td></tr>
<tr><td><code id="update_wt_+3A_dfun">dfun</code></td>
<td>
<p>integer value, convex function as in <code>irglm_fit</code></p>
</td></tr>
<tr><td><code id="update_wt_+3A_s">s</code></td>
<td>
<p>a numeric value, see details in <code>irglm_fit</code></p>
</td></tr>
<tr><td><code id="update_wt_+3A_delta">delta</code></td>
<td>
<p>a positive small value, see details in <code>irglm_fit</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Weight value</p>


<h3>Author(s)</h3>

<p>Zhu Wang &lt;zwang145@uthsc.edu&gt;</p>


<h3>References</h3>

<p>Zhu Wang (2024)
<em>Unified Robust Estimation</em>, <em>Australian &amp; New Zealand Journal of      Statistics</em>. 66(1):77-102.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+compute_wt">compute_wt</a></code></p>

<hr>
<h2 id='zipath'>Fit zero-inflated count data linear model with lasso (or elastic net), snet or mnet regularization</h2><span id='topic+zipath'></span><span id='topic+zipath.formula'></span><span id='topic+zipath.matrix'></span><span id='topic+zipath.default'></span>

<h3>Description</h3>

<p>Fit zero-inflated regression models for count data via penalized maximum likelihood.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'formula'
zipath(formula, data, weights, offset=NULL, contrasts=NULL, ... )
## S3 method for class 'matrix'
zipath(X, Z, Y, weights, offsetx=NULL, offsetz=NULL, ...)
## Default S3 method:
zipath(X, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="zipath_+3A_formula">formula</code></td>
<td>
<p>symbolic description of the model, see details.</p>
</td></tr>
<tr><td><code id="zipath_+3A_data">data</code></td>
<td>
<p>argument controlling formula processing
via <code><a href="stats.html#topic+model.frame">model.frame</a></code>.</p>
</td></tr>
<tr><td><code id="zipath_+3A_weights">weights</code></td>
<td>
<p>optional numeric vector of weights.</p>
</td></tr>
<tr><td><code id="zipath_+3A_offset">offset</code></td>
<td>
<p>optional numeric vector with an a priori known component to be
included in the linear predictor of the count model or zero model. See below for an example.</p>
</td></tr>
<tr><td><code id="zipath_+3A_contrasts">contrasts</code></td>
<td>
<p>a list with elements <code>"count"</code> and <code>"zero"</code>
containing the contrasts corresponding to <code>levels</code> from the
respective models</p>
</td></tr>
<tr><td><code id="zipath_+3A_x">X</code></td>
<td>
<p>predictor matrix of the count model</p>
</td></tr>
<tr><td><code id="zipath_+3A_z">Z</code></td>
<td>
<p>predictor matrix of the zero model</p>
</td></tr>
<tr><td><code id="zipath_+3A_y">Y</code></td>
<td>
<p>response variable</p>
</td></tr>
<tr><td><code id="zipath_+3A_offsetx">offsetx</code>, <code id="zipath_+3A_offsetz">offsetz</code></td>
<td>
<p>optional numeric vector with an a priori known component to be
included in the linear predictor of the count model (offsetx)or zero model (offsetz).</p>
</td></tr>
<tr><td><code id="zipath_+3A_...">...</code></td>
<td>
<p>Other arguments which can be passed to <code>glmreg</code> or <code>glmregNB</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>"zipath"</code>, i.e., a list with components including
</p>
<table role = "presentation">
<tr><td><code>coefficients</code></td>
<td>
<p>a list with elements <code>"count"</code> and <code>"zero"</code>
containing the coefficients from the respective models,</p>
</td></tr>
<tr><td><code>residuals</code></td>
<td>
<p>a vector of raw residuals (observed - fitted),</p>
</td></tr>
<tr><td><code>fitted.values</code></td>
<td>
<p>a vector of fitted means,</p>
</td></tr>
<tr><td><code>weights</code></td>
<td>
<p>the case weights used,</p>
</td></tr>
<tr><td><code>terms</code></td>
<td>
<p>a list with elements <code>"count"</code>, <code>"zero"</code> and
<code>"full"</code> containing the terms objects for the respective models,</p>
</td></tr>
<tr><td><code>theta</code></td>
<td>
<p>estimate of the additional <code class="reqn">\theta</code> parameter of the
negative binomial model (if a negative binomial regression is used),</p>
</td></tr>
<tr><td><code>loglik</code></td>
<td>
<p>log-likelihood of the fitted model,</p>
</td></tr>
<tr><td><code>family</code></td>
<td>
<p>character string describing the count distribution used,</p>
</td></tr>
<tr><td><code>link</code></td>
<td>
<p>character string describing the link of the zero-inflation model,</p>
</td></tr>
<tr><td><code>linkinv</code></td>
<td>
<p>the inverse link function corresponding to <code>link</code>,</p>
</td></tr>
<tr><td><code>converged</code></td>
<td>
<p>logical value, TRUE indicating successful convergence of <code>zipath</code>, FALSE indicating otherwise</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>the original function call</p>
</td></tr>
<tr><td><code>formula</code></td>
<td>
<p>the original formula</p>
</td></tr>
<tr><td><code>levels</code></td>
<td>
<p>levels of the categorical regressors</p>
</td></tr>
<tr><td><code>contrasts</code></td>
<td>
<p>a list with elements <code>"count"</code> and <code>"zero"</code>
containing the contrasts corresponding to <code>levels</code> from the
respective models,</p>
</td></tr>
<tr><td><code>model</code></td>
<td>
<p>the full model frame (if <code>model = TRUE</code>),</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>the response count vector (if <code>y = TRUE</code>),</p>
</td></tr>
<tr><td><code>x</code></td>
<td>
<p>a list with elements <code>"count"</code> and <code>"zero"</code>
containing the model matrices from the respective models
(if <code>x = TRUE</code>),</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Zhu Wang &lt;zwang145@uthsc.edu&gt;</p>


<h3>References</h3>

     
<p>Zhu Wang, Shuangge Ma, Michael Zappitelli, Chirag Parikh, Ching-Yun Wang and Prasad Devarajan (2014)      <em>Penalized Count Data Regression with Application to Hospital Stay after Pediatric Cardiac Surgery</em>, <em>Statistical Methods in Medical Research</em>. 2014 Apr 17. [Epub ahead of print]
</p>
<p>Zhu Wang, Shuangge Ma, Ching-Yun Wang, Michael Zappitelli, Prasad Devarajan and Chirag R. Parikh (2014)
<em>EM for Regularized Zero Inflated Regression Models with Applications to Postoperative Morbidity after Cardiac Surgery in Children</em>, <em>Statistics in Medicine</em>. 33(29):5192-208.
</p>
<p>Zhu Wang, Shuangge Ma and Ching-Yun Wang (2015) <em>Variable selection for zero-inflated and overdispersed data with application to health care demand in Germany</em>, <em>Biometrical Journal</em>. 57(5):867-84.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+zipath_fit">zipath_fit</a></code>,
<code><a href="#topic+glmreg">glmreg</a></code>, <code><a href="#topic+glmregNB">glmregNB</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## data
data("bioChemists", package = "pscl")
## with simple inflation (no regressors for zero component)
fm_zip &lt;- zipath(art ~ 1 | ., data = bioChemists, nlambda=10)
summary(fm_zip)
fm_zip &lt;- zipath(art ~ . | 1, data = bioChemists, nlambda=10)
summary(fm_zip)
## Not run: 
fm_zip &lt;- zipath(art ~ . | 1, data = bioChemists, nlambda=10)
summary(fm_zip)
fm_zinb &lt;- zipath(art ~ . | 1, data = bioChemists, family = "negbin", nlambda=10)
summary(fm_zinb)
## inflation with regressors
## ("art ~ . | ." is "art ~ fem + mar + kid5 + phd + ment | fem + mar + kid5 + phd + ment")
fm_zip2 &lt;- zipath(art ~ . | ., data = bioChemists, nlambda=10)
summary(fm_zip2)
fm_zinb2 &lt;- zipath(art ~ . | ., data = bioChemists, family = "negbin", nlambda=10)
summary(fm_zinb2)
### non-penalized regression, compare with zeroinfl
fm_zinb3 &lt;- zipath(art ~ . | ., data = bioChemists, family = "negbin", 
lambda.count=0, lambda.zero=0, reltol=1e-12)
summary(fm_zinb3)
library("pscl")
fm_zinb4 &lt;- zeroinfl(art ~ . | ., data = bioChemists, dist = "negbin")
summary(fm_zinb4)
### offset
exposure &lt;- rep(0.5, dim(bioChemists)[1])
fm_zinb &lt;- zipath(art ~ . +offset(log(exposure))| ., data = bioChemists, 
		  family = "poisson", nlambda=10)
coef &lt;- coef(fm_zinb)
### offset can't be specified in predict function as it has been contained
pred &lt;- predict(fm_zinb)
## without inflation
## ("art ~ ." is "art ~ fem + mar + kid5 + phd + ment")
fm_pois &lt;- glmreg(art ~ ., data = bioChemists, family = "poisson")
coef &lt;- coef(fm_pois)
fm_nb &lt;- glmregNB(art ~ ., data = bioChemists)
coef &lt;- coef(fm_nb)
### high-dimensional
#R CMD check --use-valgrind can be too time extensive for the following model
#bioChemists &lt;- cbind(matrix(rnorm(915*100), nrow=915), bioChemists)
#fm_zinb &lt;- zipath(art ~ . | ., data = bioChemists, family = "negbin", nlambda=10)

## End(Not run)
</code></pre>

<hr>
<h2 id='zipath_fit'>Internal function to fit zero-inflated count data linear model with lasso (or elastic net), snet or mnet regularization</h2><span id='topic+zipath_fit'></span>

<h3>Description</h3>

<p>Fit zero-inflated regression models for count data via penalized maximum likelihood.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>zipath_fit(X, Z, Y, weights, offsetx, offsetz, standardize=TRUE, 
           intercept = TRUE, family = c("poisson", "negbin", "geometric"), 
           link = c("logit", "probit", "cloglog", "cauchit", "log"), 
           penalty = c("enet", "mnet",  "snet"), start = NULL, y = TRUE, 
           x = FALSE, nlambda=100, lambda.count=NULL, lambda.zero=NULL, 
           type.path=c("active", "nonactive"), penalty.factor.count=NULL, 
           penalty.factor.zero=NULL, lambda.count.min.ratio=.0001, 
           lambda.zero.min.ratio=.1, alpha.count=1, alpha.zero=alpha.count, 
           gamma.count=3, gamma.zero=gamma.count, rescale=FALSE, 
           init.theta=NULL, theta.fixed=FALSE, EM=TRUE, maxit.em=200, 
           convtype=c("count", "both"), maxit= 1000, maxit.theta =10, 
           reltol = 1e-5, thresh=1e-6, eps.bino=1e-5, shortlist=FALSE, 
           trace=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="zipath_fit_+3A_x">X</code></td>
<td>
<p>predictor matrix of the count model</p>
</td></tr>
<tr><td><code id="zipath_fit_+3A_z">Z</code></td>
<td>
<p>predictor matrix of the zero model</p>
</td></tr>
<tr><td><code id="zipath_fit_+3A_y">Y</code></td>
<td>
<p>response variable</p>
</td></tr>
<tr><td><code id="zipath_fit_+3A_weights">weights</code></td>
<td>
<p>optional numeric vector of weights.</p>
</td></tr>
<tr><td><code id="zipath_fit_+3A_offsetx">offsetx</code></td>
<td>
<p>optional numeric vector with an a priori known component to be
included in the linear predictor of the count model.</p>
</td></tr>
<tr><td><code id="zipath_fit_+3A_offsetz">offsetz</code></td>
<td>
<p>optional numeric vector with an a priori known component to be
included in the linear predictor of the zero model.</p>
</td></tr>
<tr><td><code id="zipath_fit_+3A_intercept">intercept</code></td>
<td>
<p>Should intercept(s) be fitted (default=TRUE) or set to
zero (FALSE)</p>
</td></tr>
<tr><td><code id="zipath_fit_+3A_standardize">standardize</code></td>
<td>
<p>Logical flag for x variable standardization, prior to
fitting the model sequence. The coefficients are always returned on
the original scale. 
Default is <code>standardize=TRUE</code>.</p>
</td></tr>
<tr><td><code id="zipath_fit_+3A_family">family</code></td>
<td>
<p>character specification of count model family (a log link is 
always used).</p>
</td></tr>
<tr><td><code id="zipath_fit_+3A_link">link</code></td>
<td>
<p>character specification of link function in the binary
zero-inflation model (a binomial family is always used).</p>
</td></tr>
<tr><td><code id="zipath_fit_+3A_y">y</code>, <code id="zipath_fit_+3A_x">x</code></td>
<td>
<p>logicals. If <code>TRUE</code> the corresponding response and model matrix are returned.</p>
</td></tr>
<tr><td><code id="zipath_fit_+3A_penalty">penalty</code></td>
<td>
<p>penalty considered as one of <code>enet, mnet, snet</code>.</p>
</td></tr>
<tr><td><code id="zipath_fit_+3A_start">start</code></td>
<td>
<p>starting values for the parameters in the linear predictor.</p>
</td></tr>
<tr><td><code id="zipath_fit_+3A_nlambda">nlambda</code></td>
<td>
<p>number of <code>lambda</code> value, default value is 100. The sequence may be truncated before <code>nlambda</code> is reached if a close to saturated model for the zero component is fitted.</p>
</td></tr>
<tr><td><code id="zipath_fit_+3A_lambda.count">lambda.count</code></td>
<td>
<p>A user supplied <code>lambda.count</code> sequence. Typical usage is to have the program compute its own <code>lambda.count</code> and <code>lambda.zero</code> sequence based on
<code>nlambda</code> and <code>lambda.min.ratio</code>.</p>
</td></tr> 
<tr><td><code id="zipath_fit_+3A_lambda.zero">lambda.zero</code></td>
<td>
<p>A user supplied <code>lambda.zero</code> sequence.</p>
</td></tr>
<tr><td><code id="zipath_fit_+3A_type.path">type.path</code></td>
<td>
<p>solution path with default value <code>"active"</code>, which is less time computing than <code>"nonactive"</code>. If <code>type.path="nonactive"</code>, no active set for each element of the lambda sequence and cycle through all the predictor variables. 
If <code>type.path="active"</code>, then cycle through only the active set, then cycle through all the variables for the same penalty parameter. See details below.</p>
</td></tr> 
<tr><td><code id="zipath_fit_+3A_penalty.factor.count">penalty.factor.count</code>, <code id="zipath_fit_+3A_penalty.factor.zero">penalty.factor.zero</code></td>
<td>
<p>These are numeric vectors with the same length as predictor variables. that multiply <code>lambda.count, lambda.zero</code>, respectively, to allow differential shrinkage of coefficients. Can be 0 for some variables, which implies
no shrinkage, and that variable is always included in the
model. Default is same shrinkage for all variables.</p>
</td></tr>
<tr><td><code id="zipath_fit_+3A_lambda.count.min.ratio">lambda.count.min.ratio</code>, <code id="zipath_fit_+3A_lambda.zero.min.ratio">lambda.zero.min.ratio</code></td>
<td>
<p>Smallest value for <code>lambda.count</code> 
and <code>lambda.zero</code>, respectively, as a fraction of
<code>lambda.max</code>, the (data derived) entry value (i.e. the smallest
value for which all coefficients are zero except the intercepts).
Note, there is a closed formula for <code>lambda.max</code> for <code>penalty="enet"</code>. If <code>rescale=TRUE</code>, <code>lambda.max</code> is the same for <code>penalty="mnet" or "snet"</code>. Otherwise, some modifications are required. In the current implementation, for small <code>gamma</code> value, the square root of the computed <code>lambda.zero[1]</code> is used when <code>penalty="mnet" or "snet"</code>. 
</p>
</td></tr>
<tr><td><code id="zipath_fit_+3A_alpha.count">alpha.count</code></td>
<td>
<p>The elastic net mixing parameter for the count part of model. The default value 1 implies no L_2 penalty, as in LASSO.</p>
</td></tr>  
<tr><td><code id="zipath_fit_+3A_alpha.zero">alpha.zero</code></td>
<td>
<p>The elastic net mixing parameter for the zero part of model. The default value 1 implies no L_2 penalty, as in LASSO.</p>
</td></tr>  
<tr><td><code id="zipath_fit_+3A_gamma.count">gamma.count</code></td>
<td>
<p>The tuning parameter of the <code>snet</code> or <code>mnet</code> penalty for the count part of model.</p>
</td></tr>
<tr><td><code id="zipath_fit_+3A_gamma.zero">gamma.zero</code></td>
<td>
<p>The tuning parameter of the <code>snet</code> or <code>mnet</code> penalty for the zero part of model.</p>
</td></tr>
<tr><td><code id="zipath_fit_+3A_rescale">rescale</code></td>
<td>
<p>logical value, if TRUE, adaptive rescaling</p>
</td></tr>
<tr><td><code id="zipath_fit_+3A_init.theta">init.theta</code></td>
<td>
<p>The initial value of <code>theta</code> for <code>family="negbin"</code>. This is set to <code>NULL</code> since version 0.3-24.</p>
</td></tr> 
<tr><td><code id="zipath_fit_+3A_theta.fixed">theta.fixed</code></td>
<td>
<p>Logical value only used for <code>family="negbin"</code>. If <code>TRUE</code> and <code>init.theta</code> is provided with a numeric value &gt; 0, then <code>init.theta</code> is not updated. 
If <code>theta.fixed=FALSE</code>, then <code>init.theta</code> will be updated. In this case, if <code>init.theta=NULL</code>, its initial value is computed with intercept-only zero-inflated negbin model. </p>
</td></tr>
<tr><td><code id="zipath_fit_+3A_em">EM</code></td>
<td>
<p>Using <code>EM</code> algorithm. Not implemented otherwise</p>
</td></tr>
<tr><td><code id="zipath_fit_+3A_convtype">convtype</code></td>
<td>
<p>convergency type, default is for count component only for speedy computation</p>
</td></tr> 
<tr><td><code id="zipath_fit_+3A_maxit.em">maxit.em</code></td>
<td>
<p>Maximum number of EM algorithm</p>
</td></tr>
<tr><td><code id="zipath_fit_+3A_maxit">maxit</code></td>
<td>
<p>Maximum number of coordinate descent algorithm</p>
</td></tr>
<tr><td><code id="zipath_fit_+3A_maxit.theta">maxit.theta</code></td>
<td>
<p>Maximum number of iterations for estimating <code>theta</code> scaling parameter if family=&quot;negbin&quot;. Default value <code>maxit.theta</code> may be increased, yet may slow the algorithm</p>
</td></tr>
<tr><td><code id="zipath_fit_+3A_eps.bino">eps.bino</code></td>
<td>
<p>a lower bound of probabilities to be claimed as zero, for computing weights and related values when <code>family="binomial"</code>.</p>
</td></tr>
<tr><td><code id="zipath_fit_+3A_reltol">reltol</code></td>
<td>
<p>Convergence criteria, default value 1e-5 may be reduced to make more accurate yet slow</p>
</td></tr>
<tr><td><code id="zipath_fit_+3A_thresh">thresh</code></td>
<td>
<p>Convergence threshold for coordinate descent. Defaults value is <code>1e-6</code>.</p>
</td></tr>
<tr><td><code id="zipath_fit_+3A_shortlist">shortlist</code></td>
<td>
<p>logical value, if TRUE, limited results return</p>
</td></tr>
<tr><td><code id="zipath_fit_+3A_trace">trace</code></td>
<td>
<p>If <code>TRUE</code>, progress of algorithm is reported</p>
</td></tr>
<tr><td><code id="zipath_fit_+3A_...">...</code></td>
<td>
<p>Other arguments which can be passed to <code>glmreg</code> or <code>glmregNB</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The algorithm fits penalized zero-inflated count data regression models using the coordinate descent algorithm within the EM algorithm.
The returned fitted model object is of class <code>"zipath"</code> and is similar
to fitted <code>"glm"</code> and <code>"zeroinfl"</code> objects. For elements such as <code>"coefficients"</code> a list is returned with elements for the zero and count component,
respectively. 
</p>
<p>If <code>type.path="active"</code>, the algorithm iterates for a pair (lambda_count, lambda_zero) in a loop:<br />
Step 1: For initial coefficients start_count of the count model and start_zero of the zero model, the EM algorithm is iterated until convergence for the active set with non-zero coefficients determined from start_count and start_zero, respectively.<br />
Step 2: EM is iterated for all the predict variables once.<br />
Step 3: If active set obtained from Step 2 is the same as in Step 1, stop; otherwise, repeat Step 1 and Step 2.<br />
If <code>type.path="nonactive"</code>, the EM algorithm iterates for a pair (lambda_count, lambda_zero) with all the predict variables until convergence. 
</p>
<p>A set of standard extractor functions for fitted model objects is available for
objects of class <code>"zipath"</code>, including methods to the generic functions
<code><a href="base.html#topic+print">print</a></code>, <code><a href="stats.html#topic+coef">coef</a></code>, 
<code><a href="stats.html#topic+logLik">logLik</a></code>, <code><a href="stats.html#topic+residuals">residuals</a></code>, 
<code><a href="stats.html#topic+predict">predict</a></code>. 
See <code><a href="#topic+predict.zipath">predict.zipath</a></code> for more details on all methods.
</p>
<p>The program may terminate with the following message:
</p>
<p><code>Error in: while (j &lt;= maxit.em &amp;&amp; !converged)</code> <code>{ :</code><br />
<code> Missing value, where TRUE/FALSE is necessary</code><br />
<code>Calls: zipath</code><br />
<code>Additionally: Warning:</code><br />
<code>In glmreg_fit(Znew, probi, weights = weights, standardize = standardize,  :</code><br />
<code> saturated model, exiting ...</code><br />
<code>Execution halted</code><br />
</p>
<p>One possible reason is that the fitted model is too complex for the data. There are two suggestions to overcome the error. One is to reduce the number of variables. Second, find out what lambda values caused the problem and omit them. Try with other lambda values instead.
</p>


<h3>Value</h3>

<p>An object of class <code>"zipath"</code>, i.e., a list with components including
</p>
<table role = "presentation">
<tr><td><code>coefficients</code></td>
<td>
<p>a list with elements <code>"count"</code> and <code>"zero"</code>
containing the coefficients from the respective models,</p>
</td></tr>
<tr><td><code>residuals</code></td>
<td>
<p>a vector of raw residuals (observed - fitted),</p>
</td></tr>
<tr><td><code>fitted.values</code></td>
<td>
<p>a vector of fitted means,</p>
</td></tr>
<tr><td><code>weights</code></td>
<td>
<p>the case weights used,</p>
</td></tr>
<tr><td><code>terms</code></td>
<td>
<p>a list with elements <code>"count"</code>, <code>"zero"</code> and
<code>"full"</code> containing the terms objects for the respective models,</p>
</td></tr>
<tr><td><code>theta</code></td>
<td>
<p>estimate of the additional <code class="reqn">\theta</code> parameter of the
negative binomial model (if a negative binomial regression is used),</p>
</td></tr>
<tr><td><code>loglik</code></td>
<td>
<p>log-likelihood of the fitted model,</p>
</td></tr>
<tr><td><code>family</code></td>
<td>
<p>character string describing the count distribution used,</p>
</td></tr>
<tr><td><code>link</code></td>
<td>
<p>character string describing the link of the zero-inflation model,</p>
</td></tr>
<tr><td><code>linkinv</code></td>
<td>
<p>the inverse link function corresponding to <code>link</code>,</p>
</td></tr>
<tr><td><code>converged</code></td>
<td>
<p>logical value, TRUE indicating successful convergence of <code>zipath</code>, FALSE indicating otherwise</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>the original function call</p>
</td></tr>
<tr><td><code>formula</code></td>
<td>
<p>the original formula</p>
</td></tr>
<tr><td><code>levels</code></td>
<td>
<p>levels of the categorical regressors</p>
</td></tr>
<tr><td><code>model</code></td>
<td>
<p>the full model frame (if <code>model = TRUE</code>),</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>the response count vector (if <code>y = TRUE</code>),</p>
</td></tr>
<tr><td><code>x</code></td>
<td>
<p>a list with elements <code>"count"</code> and <code>"zero"</code>
containing the model matrices from the respective models
(if <code>x = TRUE</code>),</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Zhu Wang &lt;zwang145@uthsc.edu&gt;</p>


<h3>References</h3>

     
<p>Zhu Wang, Shuangge Ma, Michael Zappitelli, Chirag Parikh, Ching-Yun Wang and Prasad Devarajan (2014)      <em>Penalized Count Data Regression with Application to Hospital Stay after Pediatric Cardiac Surgery</em>, <em>Statistical Methods in Medical Research</em>. 2014 Apr 17. [Epub ahead of print]
</p>
<p>Zhu Wang, Shuangge Ma, Ching-Yun Wang, Michael Zappitelli, Prasad Devarajan and Chirag R. Parikh (2014)
<em>EM for Regularized Zero Inflated Regression Models with Applications to Postoperative Morbidity after Cardiac Surgery in Children</em>, <em>Statistics in Medicine</em>. 33(29):5192-208.
</p>
<p>Zhu Wang, Shuangge Ma and Ching-Yun Wang (2015) <em>Variable selection for zero-inflated and overdispersed data with application to health care demand in Germany</em>, <em>Biometrical Journal</em>. 57(5):867-84.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+zipath">zipath</a></code>,
<code><a href="#topic+glmreg">glmreg</a></code>, <code><a href="#topic+glmregNB">glmregNB</a></code>
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
