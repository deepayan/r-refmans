<!DOCTYPE html><html><head><title>Help for package Rpdb</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {Rpdb}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#addAxes'><p>Add Axes or PBC Box to the &lsquo;rgl&rsquo; Scene</p></a></li>
<li><a href='#addLabels'><p>Add Labels to the &lsquo;rgl&rsquo; Scene</p></a></li>
<li><a href='#atoms'><p>Create &lsquo;atoms&rsquo; Object</p></a></li>
<li><a href='#basis'><p>The Basis of an Object</p></a></li>
<li><a href='#bond-angle-dihedral'><p>Atomic Bond Lengths, Angles and Dihedrals</p></a></li>
<li><a href='#cellProperties'><p>Properties of a Unit Cell</p></a></li>
<li><a href='#centres'><p>Centres-of-Geometry and Centres-of-Mass</p></a></li>
<li><a href='#conect'><p>Create &lsquo;conect&rsquo; Object</p></a></li>
<li><a href='#coords'><p>The Atomic Coordinates of an Object</p></a></li>
<li><a href='#cryst1'><p>Create &lsquo;cryst1&rsquo; Object</p></a></li>
<li><a href='#distances'><p>Inter-Atomic Distances</p></a></li>
<li><a href='#elements'><p>Periodic Table of the Elements</p></a></li>
<li><a href='#inertia'><p>Moment of Inertia of a Molecular System</p></a></li>
<li><a href='#masses'><p>Mass of Chemical Elements</p></a></li>
<li><a href='#merge.coords'><p>Merging Molecular Systems</p></a></li>
<li><a href='#mirror'><p>Reflexion of Atomic Coordinates</p></a></li>
<li><a href='#mirrorHelpers'><p>Helper Functions for reflection of Atomic Coordinates</p></a></li>
<li><a href='#natom'><p>Number of Atoms in an Object Containing Atomic Coordinates</p></a></li>
<li><a href='#pdb'><p>Create an Object of Class &lsquo;pdb&rsquo;</p></a></li>
<li><a href='#range.coords'><p>Range of Atomic Coordinates</p></a></li>
<li><a href='#read.pdb'><p>PDB File Reader</p></a></li>
<li><a href='#reindex'><p>Reinitialize Object Indexing</p></a></li>
<li><a href='#replicate'><p>Replicate Atomic Coordinates</p></a></li>
<li><a href='#rotation'><p>Rotation of Atomic Coordinates</p></a></li>
<li><a href='#rotationHelpers'><p>Helper Functions for Rotation of Atomic Coordinates</p></a></li>
<li><a href='#Rpdb-package'><p>Read, Write, Visualize and Manipulate PDB Files</p></a></li>
<li><a href='#split.pdb'><p>Divide and Reassemble &lsquo;pdb&rsquo; Objects</p></a></li>
<li><a href='#subset.atoms'><p>Subsetting &lsquo;atoms&rsquo; and &lsquo;pdb&rsquo; Objects</p></a></li>
<li><a href='#toSymbols'><p>Atomic Symbols Converter</p></a></li>
<li><a href='#translation'><p>Translation of Atomic Coordinates</p></a></li>
<li><a href='#translationHelpers'><p>Helper Functions for Translation of Atomic Coordinates</p></a></li>
<li><a href='#universalConstants'><p>Universal Constants</p></a></li>
<li><a href='#unsplit'><p>Reassemble Groups</p></a></li>
<li><a href='#vectorialOperations'><p>Basic Vectorial Operations</p></a></li>
<li><a href='#viewAxis'><p>Set the View of the &lsquo;rgl&rsquo; Scene</p></a></li>
<li><a href='#visualize'><p>Visualize a Molecular Structure</p></a></li>
<li><a href='#wrap'><p>Wrap Atomic Coordinates</p></a></li>
<li><a href='#write.pdb'><p>PDB File Writer</p></a></li>
<li><a href='#xyz2abc'><p>From Cartesian to Fractional Coordinates and Vice Versa</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Read, Write, Visualize and Manipulate PDB Files</td>
</tr>
<tr>
<td>Version:</td>
<td>2.3.4</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-09-25</td>
</tr>
<tr>
<td>Depends:</td>
<td>rgl (&ge; 1.1.3)</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides tools to read, write, visualize Protein Data Bank (PDB) files and
    perform some structural manipulations.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/discoleo/Rpdb">https://github.com/discoleo/Rpdb</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/discoleo/Rpdb/issues">https://github.com/discoleo/Rpdb/issues</a></td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-09-27 09:52:12 UTC; Leo Mada</td>
</tr>
<tr>
<td>Author:</td>
<td>Leonard Mada [cre],
  Julien Id√© [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Leonard Mada &lt;leo.mada@syonic.eu&gt;</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-09-28 10:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='addAxes'>Add Axes or PBC Box to the &lsquo;rgl&rsquo; Scene</h2><span id='topic+addAxes'></span><span id='topic+addABC'></span><span id='topic+addXYZ'></span><span id='topic+addPBCBox'></span>

<h3>Description</h3>

<p>Add lattice vectors, Cartesian axes or PBC box to the current &lsquo;rgl&rsquo; 
scene.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>addABC(x, lwd = 2, labels = TRUE, cex = 2)

addXYZ(lwd = 2, labels = TRUE, cex = 2)

addPBCBox(x, lwd = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="addAxes_+3A_x">x</code></td>
<td>
<p>an object of class &lsquo;cryst1&rsquo; containing unit cell parameters.</p>
</td></tr>
<tr><td><code id="addAxes_+3A_lwd">lwd</code></td>
<td>
<p>a numeric value indicating the line width used to draw the axes or
the PBC box.</p>
</td></tr>
<tr><td><code id="addAxes_+3A_labels">labels</code></td>
<td>
<p>a logical value indicating whether the labels of the axes have 
to be drawn.</p>
</td></tr>
<tr><td><code id="addAxes_+3A_cex">cex</code></td>
<td>
<p>a numeric value indicating the magnification used to draw the 
labels of the axes.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>addABC</code>: Add the lattice vectors a, b and c to the current rgl 
device.<br /> <code>addXYZ</code>: Add the Cartesian axes x, y and z to the current 
rgl device.<br /> <code>addPBCBox</code>: Add a box representing the Periodic Boundary
Conditions of a molecular system.
</p>


<h3>Value</h3>

<p>Return (using invisible) a two-column data.frame containing the IDs 
and type indicators of the objects added to the scene.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+visualize">visualize</a></code>, <code><a href="rgl.html#topic+rgl.open">rgl.open</a></code>, <code><a href="rgl.html#topic+par3d">par3d</a></code>,
<code><a href="#topic+addLabels">addLabels</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- read.pdb(system.file("examples/PCBM_ODCB.pdb", package="Rpdb"))
visualize(x, type = "l", xyz = FALSE, abc = FALSE, pbc.box = FALSE, mode = NULL)
addXYZ()
addABC(x$cryst1)
addPBCBox(x$cryst1)

</code></pre>

<hr>
<h2 id='addLabels'>Add Labels to the &lsquo;rgl&rsquo; Scene</h2><span id='topic+addLabels'></span><span id='topic+addResLab'></span><span id='topic+addResLab.atoms'></span><span id='topic+addResLab.pdb'></span><span id='topic+addEleLab'></span><span id='topic+addEleLab.atoms'></span><span id='topic+addEleLab.pdb'></span><span id='topic+info3d'></span><span id='topic+info3d.atoms'></span><span id='topic+info3d.pdb'></span>

<h3>Description</h3>

<p>Add Labels to the current &lsquo;rgl&rsquo; scene.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>addResLab(x, ...)

## S3 method for class 'atoms'
addResLab(x, at.centre = TRUE, col = "black", ...)

## S3 method for class 'pdb'
addResLab(x, at.centre = TRUE, col = "black", ...)

addEleLab(x, ...)

## S3 method for class 'atoms'
addEleLab(x, eleid = FALSE, col = "black", ...)

## S3 method for class 'pdb'
addEleLab(x, eleid = FALSE, col = "black", ...)

info3d(...)

## S3 method for class 'atoms'
info3d(x, id = rgl::rgl.ids(), col = "black", verbose = TRUE, adj = 0, ...)

## S3 method for class 'pdb'
info3d(x, id = rgl::rgl.ids(), col = "black", verbose = TRUE, adj = 0, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="addLabels_+3A_x">x</code></td>
<td>
<p>an R object containing atomic coordinates.</p>
</td></tr>
<tr><td><code id="addLabels_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
<tr><td><code id="addLabels_+3A_at.centre">at.centre</code></td>
<td>
<p>a single element logical vector indicating if residue labels
have to be added only at the position of the residue's centre-of-mass 
instead of at each atomic position.</p>
</td></tr>
<tr><td><code id="addLabels_+3A_col">col</code></td>
<td>
<p>the colors used to display the labels.</p>
</td></tr>
<tr><td><code id="addLabels_+3A_eleid">eleid</code></td>
<td>
<p>a single element logical vector indicating if the element ids 
have to be concatenated with the element names to prepare the labels.</p>
</td></tr>
<tr><td><code id="addLabels_+3A_id">id</code></td>
<td>
<p>vector of ID numbers of &lsquo;rgl&rsquo; items, as returned by 
<code>rgl.ids</code>. The vertexes of these items are used to display the labels.</p>
</td></tr>
<tr><td><code id="addLabels_+3A_verbose">verbose</code></td>
<td>
<p>a logical value specifying if information have to be printed 
to the terminal.</p>
</td></tr>
<tr><td><code id="addLabels_+3A_adj">adj</code></td>
<td>
<p>one value specifying the horizontal adjustment, or two, specifying 
horizontal and vertical adjustment respectively. See 
<code><a href="rgl.html#topic+text3d">text3d</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>addResLab</code> add residue labels to the scene. If <code>at.centre==TRUE</code> 
only one label per residue is added at the centre of the residue. Otherwise, 
residue labels are added at each atomic positions. <code>addEleLab</code> add 
element labels to the scene at each atomic positions. <code>info3d</code> activate 
an interactive mode to add labels by selecting atoms by <b>right-clicking</b> 
on the current &lsquo;rgl&rsquo; scene. To escape the interactive mode press the 
ESC key. The labels are as follow: &quot;ResidResname:EleidElename&quot;
</p>


<h3>Value</h3>

<p><code>addResLab</code> and <code>addEleLab</code> return (using invisible) a
two-column data.frame containing the IDs and type indicators of the objects
added to the scene.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pdb">pdb</a></code>, <code><a href="#topic+visualize">visualize</a></code>, <code><a href="#topic+measure">measure</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- read.pdb(system.file("examples/PCBM_ODCB.pdb", package="Rpdb"))
visualize(x, type = "l", mode = NULL)
addResLab(x)
x &lt;- read.pdb(system.file("examples/Pentacene.pdb", package="Rpdb"))
visualize(x, type = "l", mode = NULL)
addEleLab(x)

</code></pre>

<hr>
<h2 id='atoms'>Create &lsquo;atoms&rsquo; Object</h2><span id='topic+atoms'></span><span id='topic+atoms.default'></span><span id='topic+is.atoms'></span>

<h3>Description</h3>

<p>Creates an object of class &lsquo;atoms&rsquo; containing the data related to ATOM
and HETATM records of a PDB file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>atoms(...)

## Default S3 method:
atoms(
  recname,
  eleid,
  elename,
  alt,
  resname,
  chainid,
  resid,
  insert,
  x1,
  x2,
  x3,
  occ,
  temp,
  segid,
  basis = "xyz",
  ...
)

is.atoms(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="atoms_+3A_...">...</code></td>
<td>
<p>arguments passed to methods.</p>
</td></tr>
<tr><td><code id="atoms_+3A_recname">recname</code></td>
<td>
<p>a character vector containing the record name for each element.</p>
</td></tr>
<tr><td><code id="atoms_+3A_eleid">eleid</code></td>
<td>
<p>a integer vector containing the element ID for each element.</p>
</td></tr>
<tr><td><code id="atoms_+3A_elename">elename</code></td>
<td>
<p>a character vector containing the element name for each element.</p>
</td></tr>
<tr><td><code id="atoms_+3A_alt">alt</code></td>
<td>
<p>a character vector containing the alternate location indicator for each element.</p>
</td></tr>
<tr><td><code id="atoms_+3A_resname">resname</code></td>
<td>
<p>a character vector containing the residue name for each element.</p>
</td></tr>
<tr><td><code id="atoms_+3A_chainid">chainid</code></td>
<td>
<p>a character vector containing the chain ID for each element.</p>
</td></tr>
<tr><td><code id="atoms_+3A_resid">resid</code></td>
<td>
<p>a integer vector containing the residue ID for each element.</p>
</td></tr>
<tr><td><code id="atoms_+3A_insert">insert</code></td>
<td>
<p>a character vector containing the codes for insertion of residue of each element.</p>
</td></tr>
<tr><td><code id="atoms_+3A_x1">x1</code>, <code id="atoms_+3A_x2">x2</code>, <code id="atoms_+3A_x3">x3</code></td>
<td>
<p>a numeric vector containing the first, second and third coordinate for each element.</p>
</td></tr>
<tr><td><code id="atoms_+3A_occ">occ</code></td>
<td>
<p>a numeric vector containing the occupancie for each element.</p>
</td></tr>
<tr><td><code id="atoms_+3A_temp">temp</code></td>
<td>
<p>a numeric vector containing the temperature factor for each element.</p>
</td></tr>
<tr><td><code id="atoms_+3A_segid">segid</code></td>
<td>
<p>a character vector containing the segment ID for each element.</p>
</td></tr>
<tr><td><code id="atoms_+3A_basis">basis</code></td>
<td>
<p>a single element character vector indicating the type of basis vector used to express the atomic coordinates.</p>
</td></tr>
<tr><td><code id="atoms_+3A_x">x</code></td>
<td>
<p>an R obecjt to be tested.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>atoms</code> is a generic function to create objects of class &lsquo;atoms&rsquo;.
The purpose of this class is to store ATOM and HETATM records from PDB files.
The default method creates a <code>atoms</code> object from its different
components, i.e.: <code>recname</code>, <code>eleid</code>, <code>elename</code>, <code>alt</code>,
<code>resname</code>, <code>chainid</code>, <code>resid</code>, <code>insert</code>, <code>x1</code>,
<code>x2</code>, <code>x3</code>, <code>occ</code>, <code>temp</code>, <code>segid</code> and <code>basis</code>.
All the arguments have to be specified except <code>basis</code> which by default
is set to &quot;xyz&quot; (Cartesian coordinates).<br /> <code>is.atoms</code> tests if an object
of class &lsquo;atoms&rsquo;, i.e. if it has a &ldquo;class&rdquo; attribute equal to
<code>atoms</code>.
</p>


<h3>Value</h3>

<p><code>atoms</code> returns a data.frame of class &lsquo;atoms&rsquo; with the following components:
</p>

<dl>
<dt>recname</dt><dd><p>a character vector containing the record name for each element.</p>
</dd>
<dt>eleid</dt><dd><p>a integer vector containing the element ID for each element.</p>
</dd>
<dt>elename</dt><dd><p>a character vector containing the element name for each element.</p>
</dd>
<dt>alt</dt><dd><p>a character vector containing the alternate location indicator for each element.</p>
</dd>
<dt>resname</dt><dd><p>a character vector containing the residue name for each element.</p>
</dd>
<dt>chainid</dt><dd><p>a character vector containing the chain ID for each element.</p>
</dd>
<dt>resid</dt><dd><p>a integer vector containing the residue ID for each element.</p>
</dd>
<dt>insert</dt><dd><p>a character vector containing the codes for insertion of residue for each element.</p>
</dd>
<dt>x1, x2, x3</dt><dd><p>a numeric vector containing the first, second and third coordinate for each element.</p>
</dd>
<dt>occ</dt><dd><p>a numeric vector containing the occupencie for each element.</p>
</dd>
<dt>temp</dt><dd><p>a numeric vector containing the temperature factor for each element.</p>
</dd>
<dt>segid</dt><dd><p>a character vector containing the segment ID for each element.</p>
</dd>
<dt>basis</dt><dd><p>a single element character vector indicating the type of basis vector used to express the atomic coordinates.</p>
</dd>
</dl>

<p><code>is.atoms</code> returns TRUE if <code>x</code> is an object of class &lsquo;atoms&rsquo; and FALSE otherwise.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+basis">basis</a></code>, <code><a href="#topic+coords">coords</a></code>, <code><a href="#topic+pdb">pdb</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- atoms(recname = c("ATOM","ATOM"), eleid = 1:2, elename = c("H","H"), alt = "",
  resname = c("H2","H2"), chainid = "", resid = c(1,1), insert = "",
  x1 = c(0,0), x2 = c(0,0), x3 = c(0,1), occ = c(0.0,0.0), temp = c(1.0,1.0),
  segid = c("H2","H2"))
print(x)
is.atoms(x)

</code></pre>

<hr>
<h2 id='basis'>The Basis of an Object</h2><span id='topic+basis'></span><span id='topic+basis.default'></span><span id='topic+basis+3C-'></span><span id='topic+basis+3C-.default'></span><span id='topic+basis.pdb'></span><span id='topic+basis+3C-.pdb'></span>

<h3>Description</h3>

<p>Functions to get or set the basis of an object containing atomic coordinates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>basis(x)

## Default S3 method:
basis(x)

basis(x) &lt;- value

## Default S3 replacement method:
basis(x) &lt;- value

## S3 method for class 'pdb'
basis(x)

## S3 replacement method for class 'pdb'
basis(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="basis_+3A_x">x</code></td>
<td>
<p>an R object containing atomic coordinates.</p>
</td></tr>
<tr><td><code id="basis_+3A_value">value</code></td>
<td>
<p>a single element character vector use to set the basis of 
<code>x</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>basis</code> and <code>basis&lt;-</code> are respectively generic accessor and 
replacement functions. The default methods get and set the <code>basis</code> 
attribute of an object containing atomic coordinates. This attribute indicate
the type basis vector used to express atomic coordinates.<br /> <code>value</code> 
must be equal to <code>"xyz"</code>, for Cartesian, or <code>"abc"</code>, for fractional
coordinates.<br /> The methods for objects of class &lsquo;pdb&rsquo; get and set the
<code>basis</code> attribute of its <code>atoms</code> component.
</p>


<h3>Value</h3>

 <dl>
<dt>For <code>basis</code>:</dt><dd><p>NULL or a single element
character vector. (NULL is given if the object has no <code>basis</code>
attribute.)</p>
</dd> <dt>For <code>basis&lt;-</code>:</dt><dd><p>the updated object. (Note that the
value of <code>basis(x) &lt;- value</code> is that of the assignment, value, not the
return value from the left-hand side.)</p>
</dd> </dl>



<h3>See Also</h3>

<p><code><a href="#topic+coords">coords</a></code>, <code><a href="#topic+atoms">atoms</a></code>, <code><a href="#topic+pdb">pdb</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- read.pdb(system.file("examples/PCBM_ODCB.pdb", package="Rpdb"))
basis(x)
x &lt;- xyz2abc(x)
basis(x)

</code></pre>

<hr>
<h2 id='bond-angle-dihedral'>Atomic Bond Lengths, Angles and Dihedrals</h2><span id='topic+bond-angle-dihedral'></span><span id='topic+bond'></span><span id='topic+bond.coords'></span><span id='topic+bond.pdb'></span><span id='topic+angle'></span><span id='topic+angle.coords'></span><span id='topic+angle.pdb'></span><span id='topic+dihedral'></span><span id='topic+dihedral.coords'></span><span id='topic+dihedral.pdb'></span><span id='topic+measure'></span><span id='topic+measure.default'></span><span id='topic+measure.coords'></span><span id='topic+measure.pdb'></span>

<h3>Description</h3>

<p>Compute bond lengths, angles and dihedral from atomic coordinates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bond(...)

## S3 method for class 'coords'
bond(x, sel1, sel2, ...)

## S3 method for class 'pdb'
bond(x, sel1, sel2, ...)

angle(...)

## S3 method for class 'coords'
angle(x, sel1, sel2, sel3, ...)

## S3 method for class 'pdb'
angle(x, sel1, sel2, sel3, ...)

dihedral(...)

## S3 method for class 'coords'
dihedral(x, sel1, sel2, sel3, sel4, ...)

## S3 method for class 'pdb'
dihedral(x, sel1, sel2, sel3, sel4, ...)

measure(...)

## Default S3 method:
measure(id = rgl::rgl.ids(), verbose = TRUE, ...)

## S3 method for class 'coords'
measure(x, id = rgl::rgl.ids(), verbose = TRUE, ...)

## S3 method for class 'pdb'
measure(x, id = rgl::rgl.ids(), verbose = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bond-angle-dihedral_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
<tr><td><code id="bond-angle-dihedral_+3A_x">x</code></td>
<td>
<p>an R object containing atomic coordinates.</p>
</td></tr>
<tr><td><code id="bond-angle-dihedral_+3A_sel1">sel1</code>, <code id="bond-angle-dihedral_+3A_sel2">sel2</code>, <code id="bond-angle-dihedral_+3A_sel3">sel3</code>, <code id="bond-angle-dihedral_+3A_sel4">sel4</code></td>
<td>
<p>an integer or logical vector used to select atoms 
defining bonds, angles or dihedrals. See details.</p>
</td></tr>
<tr><td><code id="bond-angle-dihedral_+3A_id">id</code></td>
<td>
<p>vector of ID numbers of &lsquo;rgl&rsquo; items, as returned by 
<code>rgl.ids</code>. The vertexes of these items are used to compute the bond 
lengths, angles or dihedrals.</p>
</td></tr>
<tr><td><code id="bond-angle-dihedral_+3A_verbose">verbose</code></td>
<td>
<p>a logical value specifying if the information have to be 
printed to the terminal.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The number of selected atoms with <code>sel1</code>, <code>sel2</code>, <code>sel3</code> and 
<code>sel4</code> must be the same. <code>sel1</code>, <code>sel2</code>, <code>sel3</code> and 
<code>sel4</code> respectively select the first, second, third and fouth atoms 
defining bonds, angles or dihedrals.<br /><br /><code>measure</code> activate an 
interactive mode to compute bond lengths, angles and dihedrals by selecting 
atoms by <b>right-clicing</b> on the current &lsquo;rgl&rsquo; scene. To escape 
the active mode press the ESC key.
</p>


<h3>Value</h3>

<p>A numeric vector containing atomic bond lengths (in Angstrom), angles
or dihedrals (in degrees)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+coords">coords</a></code>, <code><a href="#topic+pdb">pdb</a></code>, <code><a href="#topic+info3d">info3d</a></code>,
<code><a href="#topic+visualize">visualize</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Pen &lt;- read.pdb(system.file("examples/Pentacene.pdb", package="Rpdb"))
visualize(Pen, mode = NULL)
text3d(coords(Pen), texts = Pen$atoms$eleid)
bond(Pen, 3:4, 1:2)
angle(Pen, 3:4, 1:2, 5:6)
dihedral(Pen, 3:4, 1:2, 5:6, 6:5)

</code></pre>

<hr>
<h2 id='cellProperties'>Properties of a Unit Cell</h2><span id='topic+cellProperties'></span><span id='topic+cell.coords'></span><span id='topic+cell.coords.default'></span><span id='topic+cell.coords.cryst1'></span><span id='topic+cell.coords.pdb'></span><span id='topic+cell.volume'></span><span id='topic+cell.volume.cryst1'></span><span id='topic+cell.volume.pdb'></span><span id='topic+cell.density'></span><span id='topic+cell.density.default'></span><span id='topic+cell.density.pdb'></span>

<h3>Description</h3>

<p>Compute the Cartesian coordinates of lattice vectors, the volume or the density of a unit cell.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cell.coords(...)

## Default S3 method:
cell.coords(abc, abg = c(90, 90, 90), digits = 3, ...)

## S3 method for class 'cryst1'
cell.coords(x, digits = 3, ...)

## S3 method for class 'pdb'
cell.coords(x, digits = 3, ...)

cell.volume(...)

## S3 method for class 'cryst1'
cell.volume(x, ...)

## S3 method for class 'pdb'
cell.volume(x, ...)

cell.density(...)

## Default S3 method:
cell.density(masses, volume, ...)

## S3 method for class 'pdb'
cell.density(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cellProperties_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
<tr><td><code id="cellProperties_+3A_abc">abc</code></td>
<td>
<p>a length 3 numeric vector containing the length of the a, b and c lattice vectors.</p>
</td></tr>
<tr><td><code id="cellProperties_+3A_abg">abg</code></td>
<td>
<p>a length 3 numeric vector containing the angles (degrees) between the a, b and c lattice vectors (alpha, beta, gamma).</p>
</td></tr>
<tr><td><code id="cellProperties_+3A_digits">digits</code></td>
<td>
<p>an integer used to round the lattice vectors coordinates.</p>
</td></tr>
<tr><td><code id="cellProperties_+3A_x">x</code></td>
<td>
<p>an R object containing lattice parameters.</p>
</td></tr>
<tr><td><code id="cellProperties_+3A_masses">masses</code></td>
<td>
<p>a numeric vector containing atomic masses.</p>
</td></tr>
<tr><td><code id="cellProperties_+3A_volume">volume</code></td>
<td>
<p>a single element numeric vector containing the volume of the unit cell in Angstrom cube.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>cell.coords</code> is a generic function which computes a 3x3 matrix whose columns contrain the Cartesian coordinates of lattice vectors.
The 'a' and 'b' vectors are assumed to be respectively along the x-axis and in the xy-plane.
The default method takes directly the lattice parameters as arguments.
For objects of class <code><a href="#topic+cryst1">cryst1</a></code> the lattice parameters are first extracted from the object and then the default method is called.
For objects of class <code><a href="#topic+pdb">pdb</a></code> the lattice parameters are extracted from their <code>cryst1</code> component and the default method is called.
<br />
<br />
<code>cell.volume</code> is a generic function to compute the volume of a unit cell.
For objects of class &lsquo;cryst1&rsquo;, the unit cell parameters are directly used to compute the volume.
For objects of class &lsquo;pdb&rsquo;, their <code>cryst1</code> component is used.
<br />
<br />
<code>cell.density</code> is a generic function to compute the density of a unit cell.
For objects of class &lsquo;pdb&rsquo;:
First the volume of the unit cell is calculated by calling the <code>cell.volume</code> function on the <code>cryst1</code> component of the &lsquo;pdb&rsquo; object.
Then the element names are converted into element symbols using the <code>toSymbols</code> function and their masses are taken from the <code>elements</code> data set.
Finally the density is calculated using the sum of the atomic masses and the volume of the unit cell.
</p>


<h3>Value</h3>

<p><code>cell.coords</code> returns a 3x3 matrix containing the Cartesian coordinates of lattice vectors arranged by columns.<br />
<code>cell.volume</code> returns a single element numeric vector containing the volume of the unit cell in Angstrom cube.<br />
<code>cell.density</code> returns a single element numeric vector containing the density of the unit cell in g.cm-3.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cryst1">cryst1</a></code>, <code><a href="#topic+pdb">pdb</a></code>, <code><a href="#topic+xyz2abc">xyz2abc</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- read.pdb(system.file("examples/PCBM_ODCB.pdb", package="Rpdb"))
cell.volume(x)
cell.density(x)
cell.coords(x)

</code></pre>

<hr>
<h2 id='centres'>Centres-of-Geometry and Centres-of-Mass</h2><span id='topic+centres'></span><span id='topic+centres.coords'></span><span id='topic+centres.atoms'></span><span id='topic+centres.pdb'></span>

<h3>Description</h3>

<p>Computes centres-of-geometry and centres-of-mass of groups of atoms.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>centres(...)

## S3 method for class 'coords'
centres(x, factor = NULL, weights = NULL, unsplit = FALSE, na.rm = FALSE, ...)

## S3 method for class 'atoms'
centres(x, factor = NULL, weights = NULL, unsplit = FALSE, na.rm = FALSE, ...)

## S3 method for class 'pdb'
centres(x, factor = NULL, weights = NULL, unsplit = FALSE, na.rm = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="centres_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
<tr><td><code id="centres_+3A_x">x</code></td>
<td>
<p>an R object containing atomic coordinates.</p>
</td></tr>
<tr><td><code id="centres_+3A_factor">factor</code></td>
<td>
<p>a factor used to split the atomic coordinates by groups to
compute multiple centres.</p>
</td></tr>
<tr><td><code id="centres_+3A_weights">weights</code></td>
<td>
<p>a numerical vector containing atomic weights used to compute
centres-of-mass.</p>
</td></tr>
<tr><td><code id="centres_+3A_unsplit">unsplit</code></td>
<td>
<p>a logical value indicating whether the coordinates of the
centres have to be unsplit to repeat their coordinates for each atom used
for their calculation (used for wrapping by groups).</p>
</td></tr>
<tr><td><code id="centres_+3A_na.rm">na.rm</code></td>
<td>
<p>a logical value indicating whether NA values should be stripped
before the computation proceeds.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>centres</code> is a generic function to compute centres-of-geometry and 
centres-of-mass from an object containing atomic coordinates. For objects of 
class &lsquo;coords&rsquo;, &lsquo;atoms&rsquo; and &lsquo;pdb&rsquo;, the coordinates of 
<code>x</code> are first splitted into groups defined by <code>factor</code> using the 
<code><a href="base.html#topic+split">split</a></code> function. For each group, the weighted mean of the 
<code>x1</code>, <code>x2</code> and <code>x3</code> components of <code>x</code> are calculated 
using <code>weights</code>. By default all atoms are assumed to have the same 
weight (calculation of centres-of-geometry). Finally, if <code>unplit = TRUE</code>
the coordinates of the centres are unsplitted using the <code><a href="#topic+unsplit">unsplit</a></code>
function to assign to each atom the coordinates of the centre to which they 
are attached (used for wrapping by groups). <br /> <br /> For objects of class 
&lsquo;atoms&rsquo; and &lsquo;pdb&rsquo; by default <code>factor</code> is set to 
<code>x$resid</code> and <code>x$coordinates$resid</code>, respectively, to compute the 
centre-of-geometry of the different resdiues. Notice that coordinates can be 
neglected for the calculation of the centres using NA values in 
<code>factor</code>.
</p>


<h3>Value</h3>

<p>Return an object of class &lsquo;coords&rsquo; containing the coordinates
of centres.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+coords">coords</a></code>, <code><a href="#topic+atoms">atoms</a></code>, <code><a href="#topic+pdb">pdb</a></code>,
<code><a href="#topic+elements">elements</a></code> <br /><br /> and <code><a href="base.html#topic+split">split</a></code>, <code><a href="#topic+unsplit">unsplit</a></code>,
<code><a href="base.html#topic+factor">factor</a></code> for details about splitting data sets.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># First lets read a pdb file
x &lt;- read.pdb(system.file("examples/PCBM_ODCB.pdb", package="Rpdb"))

# Centres-of-geometry of the residues
centres(x)

# Centre-of-geometry of the whole structure
centres(x, factor = rep(1, natom(x)))
# or
centres(coords(x))

# Centres-of-geometry of the PCB and DCB residues
centres(x, factor = x$atoms$resname)

# Knowing the name of the elements forming
# the C60 of the PCBM molecules (PCB residues)
# we can compute the centres-of-geometry of
# the C60 by neglecting the other atoms of the
# PCB residues.
C60.elename &lt;- paste0("C", sprintf("%0.3d", 1:60))

is.PCB &lt;- x$atoms$resname == "PCB" # Produce a mask to select only the PCB residues
is.C60 &lt;- is.PCB &amp; x$atoms$elename %in% C60.elename # Produce a mask to keep only the C60

F &lt;- x$atoms$resid # We use the residue IDs to split the coordinates
F[!is.C60] &lt;- NA # We keep only the atoms of the C60

C60.centres &lt;- centres(x, factor = F)

# Lets check the position of the C60 centres
visualize(x , mode = NULL)
spheres3d(C60.centres)
text3d(Ty(C60.centres, 2), text=paste0("PCB_", rownames(C60.centres)), cex=2)

# Centres-of-mass of the resdiues
symb &lt;- toSymbols(x$atoms$elename) # Convert elename into elemental symbols
# Find the mass of the element in the periodic table
w &lt;- elements[match(symb, elements[,"symb"]), "mass"] 
centres(x, weights = w)

</code></pre>

<hr>
<h2 id='conect'>Create &lsquo;conect&rsquo; Object</h2><span id='topic+conect'></span><span id='topic+conect.default'></span><span id='topic+conect.coords'></span><span id='topic+conect.pdb'></span><span id='topic+is.conect'></span>

<h3>Description</h3>

<p>Creates an object of class &lsquo;conect&rsquo; containing the IDs of bonded atoms
defining the connectivity of a molecular system.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>conect(...)

## Default S3 method:
conect(eleid.1, eleid.2, ...)

## S3 method for class 'coords'
conect(x, radii = 0.75, safety = 1.2, by.block = FALSE, ...)

## S3 method for class 'pdb'
conect(x, safety = 1.2, by.block = FALSE, ...)

is.conect(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="conect_+3A_...">...</code></td>
<td>
<p>arguments passed to methods.</p>
</td></tr>
<tr><td><code id="conect_+3A_eleid.1">eleid.1</code></td>
<td>
<p>a integer vector containing the IDs of bonded atoms.</p>
</td></tr>
<tr><td><code id="conect_+3A_eleid.2">eleid.2</code></td>
<td>
<p>a integer vector containing the IDs of bonded atoms.</p>
</td></tr>
<tr><td><code id="conect_+3A_x">x</code></td>
<td>
<p>an R object containing atomic coordinates.</p>
</td></tr>
<tr><td><code id="conect_+3A_radii">radii</code></td>
<td>
<p>a numeric vector containing atomic radii used to find neigbours.</p>
</td></tr>
<tr><td><code id="conect_+3A_safety">safety</code></td>
<td>
<p>a numeric value used to extend the atomic radii.</p>
</td></tr>
<tr><td><code id="conect_+3A_by.block">by.block</code></td>
<td>
<p>a logical value indicating whether the connectivity has to be
determine by block (see details).</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>conect</code> is a generic function to create objects of class 
&lsquo;conect&rsquo;. The purpose of this class is to store CONECT records from 
PDB files, indicating the connectivity of a molecular system.<br /> The default 
method creates a <code>conect</code> object from its different components, i.e.: 
<code>eleid.1</code> and <code>eleid.2</code>. Both arguments have to be specified.<br /> 
The S3 method for object of class &lsquo;coords&rsquo; determine the connectivity 
from atomic coordinates. A distance matrix is computed, then, for each pair 
of atom the distance is compared to a bounding distance computed from atomic 
radii. If this distance is lower than the bounding distance then the atoms 
are assumed to be connected.<br /> The S3 method for object of class 
&lsquo;pdb&rsquo; first use element names to search for atomic radii in the 
<code>elements</code> data set. Then atomic coordinates and radii are passed to 
<code>conect.coords</code>.<br /> If <code>by.block == TRUE</code>, a grid is defined to 
determined the connectivity by block. The method is slow but allow to deal 
with very large systems. <br /> <code>is.conect</code> tests if an object of class 
&lsquo;conect&rsquo;, i.e. if it has a &ldquo;class&rdquo; attribute equal to 
<code>conect</code>.
</p>


<h3>Value</h3>

<p><code>conect</code> returns a two-column data.frame of class
&lsquo;conect&rsquo; whose rows contain the IDs of bonded atoms. The columns of
this data.frame are described below: </p>
<table>
<tr><td><code>eleid.1</code></td>
<td>
<p>a integer vector
containing the elements IDs defining the connectivity of the system.</p>
</td></tr> 
<tr><td><code>eleid.2</code></td>
<td>
<p>a integer vector containing the elements IDs defining the
connectivity of the system.</p>
</td></tr> </table>
<p><br /><br /> <code>is.conect</code> returns TRUE if <code>x</code>
is an object of class &lsquo;coords&rsquo; and FALSE otherwise.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pdb">pdb</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># If atom 1 is connected to atom 2, 3, 4 and 5
# then we can prepare the following 'conect' object:
x &lt;- conect(rep(1,4), 2:5)
print(x)
is.conect(x)

# Compute conectivity from coordinates
x &lt;- read.pdb(system.file("examples/PCBM_ODCB.pdb", package="Rpdb"), CONECT = FALSE)
x$conect
x$conect &lt;- conect(x)
x$conect

</code></pre>

<hr>
<h2 id='coords'>The Atomic Coordinates of an Object</h2><span id='topic+coords'></span><span id='topic+coords+3C-'></span><span id='topic+coords.default'></span><span id='topic+coords.data.frame'></span><span id='topic+coords.matrix'></span><span id='topic+coords.atoms'></span><span id='topic+coords+3C-.atoms'></span><span id='topic+coords.pdb'></span><span id='topic+coords+3C-.pdb'></span><span id='topic+is.coords'></span>

<h3>Description</h3>

<p>Get or set the atomic coordinates (either Cartesian or fractional 
coordinates) of an object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coords(...)

coords(x) &lt;- value

## Default S3 method:
coords(x1, x2, x3, basis = "xyz", ...)

## S3 method for class 'data.frame'
coords(x, basis = NULL, ...)

## S3 method for class 'matrix'
coords(x, basis = NULL, ...)

## S3 method for class 'atoms'
coords(x, ...)

## S3 replacement method for class 'atoms'
coords(x) &lt;- value

## S3 method for class 'pdb'
coords(x, ...)

## S3 replacement method for class 'pdb'
coords(x) &lt;- value

is.coords(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coords_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
<tr><td><code id="coords_+3A_x">x</code></td>
<td>
<p>an R object containing atomic coordinates.</p>
</td></tr>
<tr><td><code id="coords_+3A_value">value</code></td>
<td>
<p>an object of class &lsquo;coords&rsquo; used for replacement</p>
</td></tr>
<tr><td><code id="coords_+3A_x1">x1</code>, <code id="coords_+3A_x2">x2</code>, <code id="coords_+3A_x3">x3</code></td>
<td>
<p>numeric vectors containing the first, second and third coordinates.</p>
</td></tr>
<tr><td><code id="coords_+3A_basis">basis</code></td>
<td>
<p>a single element character vector indicating the type of basis vector
used to express the atomic coordinates.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The purpose of the &lsquo;coords&rsquo; class is to store the coordinates of a 
molecular system and facilitate their manipulation when passing from the 
Cartesian to fractional coordinates and vice versa.<br /> <code>coords</code> and 
<code>coords&lt;-</code> are generic accessor and replacement functions.<br /> The 
default method of the <code>coords</code> function is actually a builder allowing 
to create a &lsquo;coords&rsquo; object from its different components, i.e.: 
<code>x1</code>, <code>x2</code>, <code>x3</code>, and <code>basis</code>. All the arguments have to 
be specified except 'basis' which by default is set to &quot;xyz&quot; (Cartesian 
coordinates). <br /><br /> For an object of class &lsquo;atoms&rsquo;, the accessor 
function extracts its <code>x1</code>, <code>x2</code> and <code>x3</code> components as well 
as its <code>basis</code> attribute to create a &lsquo;coords&rsquo; object. The 
replacement function set its <code>x1</code>, <code>x2</code> and <code>x3</code> components as
well as its <code>basis</code> attribute. <br /><br /> For an object of class 
&lsquo;pdb&rsquo;, the accessor function extracts the <code>x1</code>, <code>x2</code> and 
<code>x3</code> components as well as the <code>basis</code> attribute of its 
<code>atoms</code> component to create a &lsquo;coords&rsquo; object. The replacement 
function set the <code>x1</code>, <code>x2</code> and <code>x3</code> components as well as the
<code>basis</code> attribute of its <code>atoms</code> component. <br /><br /> For 
&lsquo;matrix&rsquo; and &lsquo;data.frame&rsquo; objects, when <code>basis==NULL</code> this
function search x, y, z or a, b, c columns in <code>x</code>.<br /> If x, y, z columns
are found they are used to a set the first, second and third coordinates of 
the returned &lsquo;coords&rsquo; object. In that case the basis set of <code>x</code> 
is set to <code>"xyz"</code>.<br /> If a, b, c columns are found they are used to a 
set the first, second and third coordinates of the returned &lsquo;coords&rsquo; 
object. In that case the basis set of <code>x</code> is set to <code>"abc"</code>.<br /> If 
the function doesn't found neither the x, y, z nor the a, b, c columns an 
error is returned.<br /> When <code>basis!=NULL</code> it has to be equal to 
<code>"xyz"</code> or <code>"abc"</code> and <code>x</code> must have exactly 3 columns. <br /><br />
<code>is.coords</code> tests if x is an object of class &lsquo;coords&rsquo;, i.e. if x 
has a &ldquo;class&rdquo; attribute equal to <code>coords</code>.
</p>


<h3>Value</h3>

<p>The accessor function returns a data.frame of class &lsquo;coords&rsquo;
whose columns contain the three coordinates of the atoms of a molecular
system. The coordinates can either be Cartesian (<code>basis</code> attribute equal
to <code>"xyz"</code>) or fractional coordinates (<code>basis</code> attribute equal to
<code>"abc"</code>). <br /><br /> The replacement function returns an object of the same
class as <code>x</code> with updated coordinates. <br /><br /> <code>is.coords</code> returns
TRUE if x is an object of class &lsquo;coords&rsquo; and FALSE otherwise
</p>


<h3>See Also</h3>

<p><code><a href="#topic+basis">basis</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- read.pdb(system.file("examples/PCBM_ODCB.pdb", package="Rpdb"))
is.coords(x)
is.coords(x$atoms)

## Replace the coordinates of x by translated coordinates
coords(x) &lt;- coords(Tz(x, 10))
coords(x)

</code></pre>

<hr>
<h2 id='cryst1'>Create &lsquo;cryst1&rsquo; Object</h2><span id='topic+cryst1'></span><span id='topic+cryst1.default'></span><span id='topic+is.cryst1'></span>

<h3>Description</h3>

<p>Create an object of class &lsquo;cryst1&rsquo; containing the unit cell parameters
and the name of the space group to associate with an object of class 
&lsquo;pdb&rsquo;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cryst1(...)

## Default S3 method:
cryst1(abc, abg = c(90, 90, 90), sgroup = "P1", ...)

is.cryst1(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cryst1_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
<tr><td><code id="cryst1_+3A_abc">abc</code></td>
<td>
<p>a numeric vector of length 3 containing the norms of the lattice
vectors a, b and c.</p>
</td></tr>
<tr><td><code id="cryst1_+3A_abg">abg</code></td>
<td>
<p>a numeric vector of length 3 containing the angles between the
lattice vectors <code class="reqn">\alpha</code>, <code class="reqn">\beta</code> and <code class="reqn">\gamma</code>.</p>
</td></tr>
<tr><td><code id="cryst1_+3A_sgroup">sgroup</code></td>
<td>
<p>a character string giving the Hermann-Mauguin symbol of the
space group.</p>
</td></tr>
<tr><td><code id="cryst1_+3A_x">x</code></td>
<td>
<p>an R object to be tested.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>cryst1</code> is a generic function to create objects of class 
&lsquo;cryst1&rsquo;. The purpose of this class is to store CRYST1 records from 
PDB files which contain the unit cell parameters and the name of the space 
group of a molecular system stored in a PDB file. The default method of the 
<code>cryst1</code> function creates an object of class &lsquo;cryst1&rsquo; from its 
different components, i.e.: <code>abc</code>, <code>abg</code> and <code>sgroup</code>. At 
least <code>abc</code> has to be specified. <br /><br /> <code>is.cryst1</code> tests if an 
object is of class &lsquo;cryst1&rsquo;, i.e. if it has a &ldquo;class&rdquo; attribute 
equal to <code>cryst1</code>.
</p>


<h3>Value</h3>

<p>Function <code>cryst1</code> returns a list of class &lsquo;cryst1&rsquo; with the
following components:
</p>
<table>
<tr><td><code>abc</code></td>
<td>
<p>a numeric vector of length 3 containing the norms of the lattice
vectors a, b and c.</p>
</td></tr>
<tr><td><code>abg</code></td>
<td>
<p>a numeric vector of length 3 containing the angles between the
lattice vectors <code class="reqn">\alpha</code>, <code class="reqn">\beta</code> and <code class="reqn">\gamma</code>.</p>
</td></tr>
<tr><td><code>sgroup</code></td>
<td>
<p>a character string giving the Hermann-Mauguin symbol of the space group.</p>
</td></tr>
</table>
<p>Function <code>is.cryst1</code> returns TRUE if <code>x</code> is an object of class &lsquo;cryst1&rsquo;
and FALSE otherwise.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cell.coords">cell.coords</a></code>, <code><a href="#topic+pdb">pdb</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- cryst1(abc = c(10, 10, 10), abg = c(90,90,90), sgroup = "P1")
is.cryst1(x)
 
</code></pre>

<hr>
<h2 id='distances'>Inter-Atomic Distances</h2><span id='topic+distances'></span><span id='topic+distances.default'></span><span id='topic+distances.coords'></span><span id='topic+distances.atoms'></span><span id='topic+distances.pdb'></span><span id='topic+is.distances'></span><span id='topic+norm'></span><span id='topic+norm.distances'></span>

<h3>Description</h3>

<p>Computes inter-atomic distance vectors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distances(...)

## Default S3 method:
distances(
  dx1 = numeric(0),
  dx2 = numeric(0),
  dx3 = numeric(0),
  basis = "xyz",
  ...
)

## S3 method for class 'coords'
distances(x, sel1, sel2, ...)

## S3 method for class 'atoms'
distances(x, sel1, sel2, ...)

## S3 method for class 'pdb'
distances(x, sel1, sel2, ...)

is.distances(x)

norm(...)

## S3 method for class 'distances'
norm(x, type = "xyz", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="distances_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
<tr><td><code id="distances_+3A_dx1">dx1</code>, <code id="distances_+3A_dx2">dx2</code>, <code id="distances_+3A_dx3">dx3</code></td>
<td>
<p>numeric arrays containing the first, second and third components of the distance vectors.</p>
</td></tr>
<tr><td><code id="distances_+3A_basis">basis</code></td>
<td>
<p>a single element character vector indicating the type of basis vector used to express the coordinates.</p>
</td></tr>
<tr><td><code id="distances_+3A_x">x</code></td>
<td>
<p>an R object containing atomic coordinates.</p>
</td></tr>
<tr><td><code id="distances_+3A_sel1">sel1</code>, <code id="distances_+3A_sel2">sel2</code></td>
<td>
<p>integer or logical vectors defining two atomic selections between which the distance vectors are computed.</p>
</td></tr>
<tr><td><code id="distances_+3A_type">type</code></td>
<td>
<p>a single element character vector indicating how to project the distances vectors before computing the norms. See details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The purpose of the &lsquo;distances&rsquo; class is to store the inter-atomic 
distance vectors and facilitate their manipulation when passing from the 
Cartesian to fractional references and vice versa.<br /> The default method of 
the <code>distances</code> function is actually a builder allowing to create a 
&lsquo;distances&rsquo; object from its different components, i.e.: <code>dx1</code>, 
<code>dx2</code>, <code>dx3</code>, and <code>basis</code>. All the arguments have to be 
specified except 'basis' which by default is set to &quot;xyz&quot; (Cartesian 
reference).
</p>
<p>For objects of class &lsquo;coords&rsquo;, &lsquo;atoms&rsquo;, 
&lsquo;pdb&rsquo;, two sets of atomic coordinates, defined by <code>sel1</code> and 
<code>sel2</code>, are extracted and inter-atomic distance vectors are computed 
between these two sets.
</p>
<p>The method of the <code>norm</code> function for 
objects of class &lsquo;distances&rsquo; computes the norm of the distances 
vectors. <code>type</code> specify how to project the distance vectors before 
computing the norms. By default no projection is perform. The three dx, dy, 
and dz components of the distance vectors are used to compute the norm. 
<code>type</code> can take the following values: </p>
 <ul>
<li><p>   x: The distance 
vectors are projected over x. </p>
</li>
<li><p>   y: The distance vectors are projected 
over y. </p>
</li>
<li><p>   z: The distance vectors are projected over z. </p>
</li>
<li><p>  xy: The 
distance vectors are projected in the xy-plan. </p>
</li>
<li><p>  yz: The distance 
vectors are projected in the yz-plan. </p>
</li>
<li><p>  zx: The distance vectors are 
projected in the zx-plan. </p>
</li>
<li><p> xyz: The distance vectors are not projected 
(The three components of the distance vectors are used to compute the norm). 
</p>
</li></ul>
 <p><code>is.distances</code> tests if x is an object of class 
&lsquo;distances&rsquo;, i.e. if x has a &ldquo;class&rdquo; attribute equal to 
<code>distances</code>.
</p>


<h3>Value</h3>

<p>The <code>distance</code> function return an object of class
&lsquo;distances&rsquo; containing inter-atomic distance vectors. The <code>norm</code>
function return an array, with the same dimensions as the <code>dx1</code>,
<code>dx2</code>, <code>dx3</code> components of the &lsquo;distances&rsquo; object for which
the norms have to be computed, containing the norm of the distance vectors. 
<br /><br /> <code>is.distances</code> returns TRUE if x is an object of class
&lsquo;distances&rsquo; and FALSE otherwise
</p>


<h3>See Also</h3>

<p><code><a href="#topic+coords">coords</a></code>, <code><a href="#topic+basis">basis</a></code>, <code><a href="#topic+xyz2abc">xyz2abc</a></code>, <code><a href="#topic+abc2xyz">abc2xyz</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- read.pdb(system.file("examples/PCBM_ODCB.pdb", package="Rpdb"))
is.DCB7 &lt;- x$atoms$resname == "DCB" &amp; x$atoms$resid == 7
is.DCB8 &lt;- x$atoms$resname == "DCB" &amp; x$atoms$resid == 8
d &lt;- distances(x, is.DCB7, is.DCB8)
norm(d, type = "xyz")
norm(d, type = "xy")
norm(d, type = "x")

</code></pre>

<hr>
<h2 id='elements'>Periodic Table of the Elements</h2><span id='topic+elements'></span>

<h3>Description</h3>

<p>This data set gives various information on chemical elements
</p>


<h3>Format</h3>

<p>A data frame containing for each chemical element the following
information. </p>
 <dl>
<dt><code>num</code></dt><dd><p>atomic number</p>
</dd> 
<dt><code>symb</code></dt><dd><p>elemental symbol</p>
</dd> <dt><code>areneg</code></dt><dd><p>Allred and Rochow
electronegativity  (0.0 if unknown)</p>
</dd> <dt><code>rcov</code></dt><dd><p>covalent radii (in
Angstrom) (1.6 if unknown)</p>
</dd> <dt><code>rbo</code></dt><dd><p>&quot;bond order&quot; radii</p>
</dd> 
<dt><code>rvdw</code></dt><dd><p>van der Waals radii (in Angstrom) (2.0 if unknown)</p>
</dd> 
<dt><code>maxbnd</code></dt><dd><p>maximum bond valence (6 if unknown)</p>
</dd> 
<dt><code>mass</code></dt><dd><p>IUPAC recommended atomic masses (in amu)</p>
</dd> 
<dt><code>elneg</code></dt><dd><p>Pauling electronegativity (0.0 if unknown)</p>
</dd> 
<dt><code>ionization</code></dt><dd><p>ionization potential (in eV) (0.0 if unknown)</p>
</dd> 
<dt><code>elaffinity</code></dt><dd><p>electron affinity (in eV) (0.0 if unknown)</p>
</dd> 
<dt><code>red</code></dt><dd><p>red value for visualization</p>
</dd> <dt><code>green</code></dt><dd><p>green
value for visualization</p>
</dd> <dt><code>blue</code></dt><dd><p>blue value for visualization</p>
</dd> 
<dt><code>name</code></dt><dd><p>element name</p>
</dd> </dl>



<h3>Source</h3>

<p>Open Babel (2.3.1) file: element.txt<br />
<br />
Created from the Blue Obelisk Cheminformatics Data Repository<br />
Direct Source: http://www.blueobelisk.org/<br />
http://www.blueobelisk.org/repos/blueobelisk/elements.xml includes furhter bibliographic citation information<br />
<br />
- Allred and Rochow Electronegativity from http://www.hull.ac.uk/chemistry/electroneg.php?type=Allred-Rochow<br />
- Covalent radii from http://dx.doi.org/10.1039/b801115j<br />
- Van der Waals radii from http://dx.doi.org/10.1021/jp8111556<br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(elements)
elements

# Get the mass of some elements
symb &lt;- c("C","O","H")
elements[match(symb, elements[,"symb"]),"mass"]

# Get the van der Waals radii of some elements
symb &lt;- c("C","O","H")
elements[match(symb, elements[,"symb"]),"rvdw"]

</code></pre>

<hr>
<h2 id='inertia'>Moment of Inertia of a Molecular System</h2><span id='topic+inertia'></span><span id='topic+inertia.coords'></span><span id='topic+inertia.atoms'></span><span id='topic+inertia.pdb'></span>

<h3>Description</h3>

<p>Computes the inertia tensor of a molecular system from atomic coordinates and
masses.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inertia(...)

## S3 method for class 'coords'
inertia(x, m = NULL, ...)

## S3 method for class 'atoms'
inertia(x, m = NULL, ...)

## S3 method for class 'pdb'
inertia(x, m = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="inertia_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
<tr><td><code id="inertia_+3A_x">x</code></td>
<td>
<p>an R object containing atomic coordinates.</p>
</td></tr>
<tr><td><code id="inertia_+3A_m">m</code></td>
<td>
<p>a numeric vector containing atomic masses.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>inertia</code> is a generic function to compute the inertia tensor of a
molecular system. For object of class &lsquo;coords&rsquo; both atomic coordinates
and masses have to be speifyed. For object of class &lsquo;atoms&rsquo; the masses
are determined from the <code>elename</code> component of the object (see
<code><a href="#topic+toSymbols">toSymbols</a></code> and <code><a href="#topic+masses">masses</a></code>). For object of class
&lsquo;pdb&rsquo; the <code>atoms</code> component is used.
</p>


<h3>Value</h3>

<p>Return the inertia tensor in a 3x3 matrix.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+toSymbols">toSymbols</a></code>, <code><a href="#topic+masses">masses</a></code>, <code><a href="#topic+viewInertia">viewInertia</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>C70 &lt;- read.pdb(system.file("examples/C70.pdb", package="Rpdb"))
inertia(C70)
visualize(C70, mode = NULL)
viewXY()
viewInertia(C70)

</code></pre>

<hr>
<h2 id='masses'>Mass of Chemical Elements</h2><span id='topic+masses'></span><span id='topic+masses.default'></span><span id='topic+masses.pdb'></span>

<h3>Description</h3>

<p>Determine the mass of chemical elements
</p>


<h3>Usage</h3>

<pre><code class='language-R'>masses(...)

## Default S3 method:
masses(x, ...)

## S3 method for class 'pdb'
masses(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="masses_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
<tr><td><code id="masses_+3A_x">x</code></td>
<td>
<p>either a character or an integer vector containing element symbols
or atomic numbers, or an object of class &lsquo;pdb&rsquo; from which element
symbols are determined (see details).</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>masses</code> is a generic function to determine the mass of chemical 
elements. <br /><br /> For objects of class &lsquo;pdb&rsquo;:
</p>
 <ul>
<li><p> First the
element names are converted into element symbols using the <code>toSymbols</code> 
function. </p>
</li>
<li><p> Then their masses are taken from the <code>elements</code> data 
set. </p>
</li></ul>
 <p><code>NA</code> values are returned for unrecognized elements.
</p>


<h3>Value</h3>

<p>Return a numeric vector containing the mass of chemical elements.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+toSymbols">toSymbols</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- read.pdb(system.file("examples/PCBM_ODCB.pdb",package="Rpdb"))
masses(x)

masses(c("C","Cl",NA,"AA","N"))

</code></pre>

<hr>
<h2 id='merge.coords'>Merging Molecular Systems</h2><span id='topic+merge.coords'></span><span id='topic+merge.atoms'></span><span id='topic+merge.pdb'></span>

<h3>Description</h3>

<p>Merge two objects contaning atomic coordinates
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'coords'
merge(x, y, ...)

## S3 method for class 'atoms'
merge(x, y, reindex = TRUE, ...)

## S3 method for class 'pdb'
merge(x, y, reindex = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="merge.coords_+3A_x">x</code>, <code id="merge.coords_+3A_y">y</code></td>
<td>
<p>objects of class 'coords' to be merged.</p>
</td></tr>
<tr><td><code id="merge.coords_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
<tr><td><code id="merge.coords_+3A_reindex">reindex</code></td>
<td>
<p>a single element logical vector indicating if residue and
element IDs have to be reindexed after merging.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>To merge <code>x</code> and <code>y</code> they must have the same <code>basis</code> 
attributes (see <code><a href="#topic+basis">basis</a></code>). <br /><br /> For objects of class 
&lsquo;coords&rsquo; and &lsquo;atoms&rsquo; the atomic coordinates are directly merged
by row. <br /><br /> For objects of class &lsquo;pdb&rsquo;, the <code>atoms</code> and 
<code>conect</code> components of the two <code>pdb</code> objects are merged by row and 
the <code>cryst1</code> components of <code>x</code> is used to build the returned 
object. <br /><br /> For objects of class &lsquo;atoms&rsquo; and &lsquo;pdb&rsquo; the 
residue and element IDs of <code>y</code> are shifted to avoid any confusion with 
those of <code>x</code>. If <code>reindex == TRUE</code> the <code><a href="#topic+reindex">reindex</a></code> function
is called to reinitialize the indexing of the returned object.
</p>


<h3>Value</h3>

<p>Return an object of the same class as <code>x</code> and <code>y</code> merging 
<code>x</code> and <code>y</code>. If <code>x</code> and <code>y</code> have different <code>basis</code>
attributes an error is returned.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+coords">coords</a></code>, <code><a href="#topic+atoms">atoms</a></code>, <code><a href="#topic+pdb">pdb</a></code>,
<code><a href="#topic+basis">basis</a></code>, <code>merge</code>, <code>merge.data.frame</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>c1 &lt;- coords( 1:3 ,  4:6 ,  7:9 , basis = "xyz")
c2 &lt;- coords(10:12, 13:15, 16:18, basis = "xyz")
merge(c1,c2)


## Merging objects with different basis sets returns an error.
c2 &lt;- coords(9:11, 12:14, 15:17, basis = "abc")
try(merge(c1,c2))


## Prepare a Pentacene/C70 dimer
C70 &lt;- read.pdb(system.file("examples/C70.pdb", package="Rpdb"))
Pen &lt;- read.pdb(system.file("examples/Pentacene.pdb", package="Rpdb"))
x &lt;- merge(Tz(C70, 3.5, thickness=0.5), Pen)
  
</code></pre>

<hr>
<h2 id='mirror'>Reflexion of Atomic Coordinates</h2><span id='topic+mirror'></span><span id='topic+mirror.coords'></span><span id='topic+mirror.pdb'></span>

<h3>Description</h3>

<p>Perform a reflexion (or mirror) operation on atomic coordinates with respect 
to a given reflexion plane.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mirror(...)

## S3 method for class 'coords'
mirror(x, p1, p2 = NULL, p3 = NULL, mask = TRUE, cryst1 = NULL, ...)

## S3 method for class 'pdb'
mirror(x, p1, p2 = NULL, p3 = NULL, mask = TRUE, cryst1 = x$cryst1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mirror_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
<tr><td><code id="mirror_+3A_x">x</code></td>
<td>
<p>an R object containing atomic coordinates.</p>
</td></tr>
<tr><td><code id="mirror_+3A_p1">p1</code></td>
<td>
<p>a numeric vector of length 3 containing the coordinates of the
first point defining the reflexion plan. Can also be a 3x3 matrix or
data.frame containing by row <code>p1</code>, <code>p2</code> and <code>p3</code>.</p>
</td></tr>
<tr><td><code id="mirror_+3A_p2">p2</code></td>
<td>
<p>a numeric vector of length 3 containing the coordinates of the
second point defining the reflexion plane.</p>
</td></tr>
<tr><td><code id="mirror_+3A_p3">p3</code></td>
<td>
<p>a numeric vector of length 3 containing the coordinates of the
third point defining the reflexion plane.</p>
</td></tr>
<tr><td><code id="mirror_+3A_mask">mask</code></td>
<td>
<p>a logical vector indicating the set of coordinates to which to
apply the reflexion.</p>
</td></tr>
<tr><td><code id="mirror_+3A_cryst1">cryst1</code></td>
<td>
<p>an object of class &lsquo;cryst1&rsquo; use to convert fractional
into Cartesian coordinates when need.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>mirror</code> is a generic function. Method for objects of class 
&lsquo;coords&rsquo; first convert the coordinates into Cartesian coordinates 
using <code>cryst1</code> if needed. Once reflected, the coordinates are 
reconverted back to the orginal basis set using again <code>cryst1</code>. Method 
for objects of class &lsquo;pdb&rsquo; first extract coordinates from the object 
using the function <code>coords</code>, perform the reflection, and update the 
coordinates of the &lsquo;pdb&rsquo; object using the function <code>coords&lt;-</code>.
</p>


<h3>Value</h3>

<p>An object of the same class as <code>x</code> with reflected coordinates.
</p>


<h3>See Also</h3>

<p>Helper functions for reflection with respect to a given Cartesian
plane or a plane defined by two lattice vectors:<br /> <code><a href="#topic+Mxy">Mxy</a></code>,
<code><a href="#topic+Myz">Myz</a></code>, <code><a href="#topic+Mzx">Mzx</a></code>, <code><a href="#topic+Mab">Mab</a></code>, <code><a href="#topic+Mbc">Mbc</a></code>,
<code><a href="#topic+Mca">Mca</a></code><br /> Passing from Cartesian to fractional coordinates (or Vis
Versa):<br /> <code><a href="#topic+xyz2abc">xyz2abc</a></code>, <code><a href="#topic+abc2xyz">abc2xyz</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># First lets read a pdb file
x &lt;- read.pdb(system.file("examples/PCBM_ODCB.pdb", package="Rpdb"))
cell &lt;- cell.coords(x)
visualize(x, mode = NULL)

# Mirror operation with respect to the ab-plane
visualize(mirror(x, rep(0,3), p1=cell[, "a"], p2=cell[, "b"]), mode = NULL)
# Mirror operation with respect to the ab-plane for residue 1
visualize(mirror(x, rep(0,3), p1=cell[, "a"], p2=cell[, "b"],
   mask = x$atoms$resid == 1), mode = NULL)

</code></pre>

<hr>
<h2 id='mirrorHelpers'>Helper Functions for reflection of Atomic Coordinates</h2><span id='topic+mirrorHelpers'></span><span id='topic+Mxy'></span><span id='topic+Mxy.coords'></span><span id='topic+Mxy.pdb'></span><span id='topic+Myz'></span><span id='topic+Myz.coords'></span><span id='topic+Myz.pdb'></span><span id='topic+Mzx'></span><span id='topic+Mzx.coords'></span><span id='topic+Mzx.pdb'></span><span id='topic+Mab'></span><span id='topic+Mab.coords'></span><span id='topic+Mab.pdb'></span><span id='topic+Mbc'></span><span id='topic+Mbc.coords'></span><span id='topic+Mbc.pdb'></span><span id='topic+Mca'></span><span id='topic+Mca.coords'></span><span id='topic+Mca.pdb'></span>

<h3>Description</h3>

<p>Reflection of atomic coordinates with respect to a specific Cartesian plan or
a plan defined by two lattice vectors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Mxy(...)

## S3 method for class 'coords'
Mxy(x, mask = TRUE, cryst1 = NULL, ...)

## S3 method for class 'pdb'
Mxy(x, mask = TRUE, cryst1 = x$cryst1, ...)

Myz(...)

## S3 method for class 'coords'
Myz(x, mask = TRUE, cryst1 = NULL, ...)

## S3 method for class 'pdb'
Myz(x, mask = TRUE, cryst1 = x$cryst1, ...)

Mzx(...)

## S3 method for class 'coords'
Mzx(x, mask = TRUE, cryst1 = NULL, ...)

## S3 method for class 'pdb'
Mzx(x, mask = TRUE, cryst1 = x$cryst1, ...)

Mab(...)

## S3 method for class 'coords'
Mab(x, cryst1, mask = TRUE, ...)

## S3 method for class 'pdb'
Mab(x, cryst1 = x$cryst1, mask = TRUE, ...)

Mbc(...)

## S3 method for class 'coords'
Mbc(x, cryst1, mask = TRUE, ...)

## S3 method for class 'pdb'
Mbc(x, cryst1 = x$cryst1, mask = TRUE, ...)

Mca(...)

## S3 method for class 'coords'
Mca(x, cryst1, mask = TRUE, ...)

## S3 method for class 'pdb'
Mca(x, cryst1 = x$cryst1, mask = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mirrorHelpers_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
<tr><td><code id="mirrorHelpers_+3A_x">x</code></td>
<td>
<p>an R object containing atomic coordinates.</p>
</td></tr>
<tr><td><code id="mirrorHelpers_+3A_mask">mask</code></td>
<td>
<p>a logical vector indicating the set of coordinates to which to
apply the reflection.</p>
</td></tr>
<tr><td><code id="mirrorHelpers_+3A_cryst1">cryst1</code></td>
<td>
<p>an object of class &lsquo;cryst1&rsquo; use to convert fractional
into Cartesian coordinates when need.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions are helper functions to perform a reflection with respect to 
a specific Cartesian plan or a plan defined by two lattice vectors. All of 
them call the <code>mirror</code> function.
</p>


<h3>Value</h3>

<p>An object of the same class as <code>x</code> with reflected coordinates.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mirror">mirror</a></code> and <code><a href="#topic+xyz2abc">xyz2abc</a></code>,
<code><a href="#topic+abc2xyz">abc2xyz</a></code> for passing from Cartesian to fractional coordinates
(or Vis Versa).
</p>


<h3>Examples</h3>

<pre><code class='language-R'># First lets read a pdb file
x &lt;- read.pdb(system.file("examples/PCBM_ODCB.pdb", package="Rpdb"))
visualize(x, mode = NULL)

# Mirror operation with respect to the ab-plane
visualize(Mab(x), mode = NULL)
# Mirror operation with respect to the ab-plane for residue 1
visualize(Mab(x, mask = x$atoms$resid == 1), mode = NULL)

</code></pre>

<hr>
<h2 id='natom'>Number of Atoms in an Object Containing Atomic Coordinates</h2><span id='topic+natom'></span><span id='topic+natom.coords'></span><span id='topic+natom.atoms'></span><span id='topic+natom.pdb'></span>

<h3>Description</h3>

<p>Evaluates the number of atoms in an object containing atomic coordinates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>natom(x, ...)

## S3 method for class 'coords'
natom(x, factor = NULL, ...)

## S3 method for class 'atoms'
natom(x, factor = NULL, ATOM = TRUE, HETATM = TRUE, ...)

## S3 method for class 'pdb'
natom(x, factor = NULL, ATOM = TRUE, HETATM = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="natom_+3A_x">x</code></td>
<td>
<p>an R object containing atomic coordinates.</p>
</td></tr>
<tr><td><code id="natom_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
<tr><td><code id="natom_+3A_factor">factor</code></td>
<td>
<p>a factor used to split the object and evaluate the number of atoms
in each group.</p>
</td></tr>
<tr><td><code id="natom_+3A_atom">ATOM</code></td>
<td>
<p>a single element logical vector indicating if ATOM records have
to be considered or not.</p>
</td></tr>
<tr><td><code id="natom_+3A_hetatm">HETATM</code></td>
<td>
<p>a single element logical vector indicating if HETATM records
have to be considered or not.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>natom</code> is a generic function to evalute the number of atom in an object
containing atomic coordinates. The atomic coordinates of the object are first
filtered to keep ATOM and/or HETATM records as indicated by the 'ATOM' and 
'HETATM' arguments. Then, if <code>factor</code> is specify, the object is splitted
to evalute the number of atoms in each group defined by <code>factor</code>. If 
<code>factor</code> is not specify then the total number of atoms in the object is 
return.
</p>


<h3>Value</h3>

<p>Return an integer or a vector of integer of lenght equal to 
<code>nlevels(factor)</code> (if <code>factor</code> is specify) indication the number
of atoms in the object or in the groups defined by <code>factor</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+coords">coords</a></code>, <code><a href="#topic+atoms">atoms</a></code>, <code><a href="#topic+pdb">pdb</a></code>,
<code><a href="base.html#topic+factor">factor</a></code>, <code><a href="base.html#topic+split">split</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- read.pdb(system.file("examples/PCBM_ODCB.pdb", package="Rpdb"))

natom(x)
natom(x, x$atoms$resid)
natom(x, x$atoms$resname)
natom(x, HETATM = FALSE)
  
</code></pre>

<hr>
<h2 id='pdb'>Create an Object of Class &lsquo;pdb&rsquo;</h2><span id='topic+pdb'></span><span id='topic+pdb.default'></span><span id='topic+is.pdb'></span>

<h3>Description</h3>

<p>Creates an object of class 'pdb'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pdb(...)

## Default S3 method:
pdb(atoms, cryst1 = NULL, conect = NULL, remark = NULL, title = NULL, ...)

is.pdb(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pdb_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
<tr><td><code id="pdb_+3A_atoms">atoms</code></td>
<td>
<p>a data.frame of class <code>atoms</code> containing ATOM and HETATM records use to create the <code>pdb</code> object.</p>
</td></tr>
<tr><td><code id="pdb_+3A_cryst1">cryst1</code></td>
<td>
<p>a list of class <code>cryst1</code> containing the periodical bondary conditions and space group use to create the <code>pdb</code> object.</p>
</td></tr>
<tr><td><code id="pdb_+3A_conect">conect</code></td>
<td>
<p>a data.frame of class <code>conect</code> containing CONECT records use to create the <code>pdb</code> object.</p>
</td></tr>
<tr><td><code id="pdb_+3A_remark">remark</code></td>
<td>
<p>a character vector containing some REMARK records to be added to the <code>pdb</code> object.</p>
</td></tr>
<tr><td><code id="pdb_+3A_title">title</code></td>
<td>
<p>a character vector containing some TITLE records to be added to the <code>pdb</code> object.</p>
</td></tr>
<tr><td><code id="pdb_+3A_x">x</code></td>
<td>
<p>an R object to be tested</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is the generic function to create objects of class
&lsquo;pdb&rsquo;. The purpose of this class is to store the data of molecular
systems contained in PDB files. The default method of the <code>pdb</code> function
creates an object of class &lsquo;pdb&rsquo; from its different components, i.e.:
<code>title</code>, <code>remark</code>, <code>cryst1</code>, <code>atoms</code> and <code>conect</code>. 
At least an object of class &lsquo;atoms&rsquo; has to be specified. <br /><br /> 
<code>is.pdb</code> tests if x is an object of class &lsquo;pdb&rsquo;, i.e. if x has a
&ldquo;class&rdquo; attribute equal to <code>pdb</code>.
</p>


<h3>Value</h3>

<p><code>pdb</code> returns a list of class &lsquo;pdb&rsquo; with the following components:
</p>
<table>
<tr><td><code>title</code></td>
<td>
<p>a character vector containing the TITLE records found in a PDB file.</p>
</td></tr>
<tr><td><code>remark</code></td>
<td>
<p>a character vector containing the REMARK records found in a PDB file.</p>
</td></tr>
<tr><td><code>cryst1</code></td>
<td>
<p>a list of class &lsquo;cryst1&rsquo; containing the first CRYST1 record found in a PDB file. All others are ignored.</p>
</td></tr>
<tr><td><code>atoms</code></td>
<td>
<p>a data.frame of class &lsquo;atoms&rsquo; containing the ATOM and HETATM records found in a PDB file.</p>
</td></tr>
<tr><td><code>conect</code></td>
<td>
<p>a data.frame of class &lsquo;conect&rsquo; containing the CONECT records found in a PDB file.</p>
</td></tr>
</table>
<p><br />
<code>is.pdb</code> returns TRUE if x is an object of class &lsquo;pdb&rsquo; and FALSE otherwise.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+atoms">atoms</a></code>, <code><a href="#topic+coords">coords</a></code>, <code><a href="#topic+cryst1">cryst1</a></code>, <code><a href="#topic+conect">conect</a></code> and <code><a href="#topic+read.pdb">read.pdb</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>title  &lt;- "This is just an example"
remark &lt;- NULL
cryst1 &lt;- cryst1(c(10,10,10))
atoms &lt;- atoms(recname = c("ATOM","ATOM"), eleid = 1:2, elename = c("H","H"), alt = "",
               resname = c("H2","H2"), chainid = "", resid = c(1,1), insert = "",
               x1 = c(0,0), x2 = c(0,0), x3 = c(0,1), occ = c(0.0,0.0), temp = c(1.0,1.0),
               segid = c("H2","H2"))
conect &lt;- conect(eleid.1 = c(1), eleid.2 = c(2))
x &lt;- pdb(atoms = atoms, cryst1 = cryst1, conect = conect, remark = remark, title = title)
is.pdb(x)

</code></pre>

<hr>
<h2 id='range.coords'>Range of Atomic Coordinates</h2><span id='topic+range.coords'></span><span id='topic+range.atoms'></span><span id='topic+range.pdb'></span>

<h3>Description</h3>

<p>Determines the range of atomic coordinates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'coords'
range(x, na.rm = FALSE, finite = FALSE, ...)

## S3 method for class 'atoms'
range(x, na.rm = FALSE, finite = FALSE, ...)

## S3 method for class 'pdb'
range(x, na.rm = FALSE, finite = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="range.coords_+3A_x">x</code></td>
<td>
<p>an R object containing atomic coordinates.</p>
</td></tr>
<tr><td><code id="range.coords_+3A_na.rm">na.rm</code></td>
<td>
<p>logical, indicating if <code><a href="base.html#topic+NA">NA</a></code>'s should be omitted.</p>
</td></tr>
<tr><td><code id="range.coords_+3A_finite">finite</code></td>
<td>
<p>logical, indicating if all non-finite elements should be omitted.</p>
</td></tr>
<tr><td><code id="range.coords_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Return a <code><a href="base.html#topic+data.frame">data.frame</a></code> whose columns contain the range of
the first, second and third coordinates of <code>x</code>.
</p>


<h3>See Also</h3>

<p><code>range</code>, <code><a href="#topic+coords">coords</a></code>, <code><a href="#topic+atoms">atoms</a></code>, <code><a href="#topic+pdb">pdb</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- read.pdb(system.file("examples/PCBM_ODCB.pdb", package="Rpdb"))
range(x)
range(range(x))

</code></pre>

<hr>
<h2 id='read.pdb'>PDB File Reader</h2><span id='topic+read.pdb'></span>

<h3>Description</h3>

<p>Reads a Protein Data Bank (PDB) coordinate file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.pdb(
  file,
  ATOM = TRUE,
  HETATM = TRUE,
  CRYST1 = TRUE,
  CONECT = TRUE,
  TITLE = TRUE,
  REMARK = TRUE,
  MODEL = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read.pdb_+3A_file">file</code></td>
<td>
<p>a single element character vector containing the name of the PDB file to be read.</p>
</td></tr>
<tr><td><code id="read.pdb_+3A_atom">ATOM</code></td>
<td>
<p>a single element logical vector indicating whether ATOM records have to be read.</p>
</td></tr>
<tr><td><code id="read.pdb_+3A_hetatm">HETATM</code></td>
<td>
<p>a single element logical vector indicating whether HETATM records have to be read.</p>
</td></tr>
<tr><td><code id="read.pdb_+3A_cryst1">CRYST1</code></td>
<td>
<p>a single element logical vector indicating whether CRYST1 records have to be read.</p>
</td></tr>
<tr><td><code id="read.pdb_+3A_conect">CONECT</code></td>
<td>
<p>a single element logical vector indicating whether CONECT records have to be read.</p>
</td></tr>
<tr><td><code id="read.pdb_+3A_title">TITLE</code></td>
<td>
<p>a single element logical vector indicating whether TITLE records have to be read.</p>
</td></tr>
<tr><td><code id="read.pdb_+3A_remark">REMARK</code></td>
<td>
<p>a single element logical vector indicating whether REMARK records have to be read.</p>
</td></tr>
<tr><td><code id="read.pdb_+3A_model">MODEL</code></td>
<td>
<p>an integer vector containing the serial number of the MODEL sections to be read. Can also be equal to NULL to read all the MODEL sections or to NA to ignore MODEL records (see details).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>read.pdb</code> function reads the TITLE, REMARK, ATOM, HETATM, CRYST1 and CONECT records from a PDB file. Three different reading modes can be used depending on the value of <code>MODEL</code>: 
</p>

<ul>
<li><p> When <code>MODEL</code> is a vector of integers, MODEL sections whose serial numbers match these integers are read.
</p>
</li>
<li><p> When <code>MODEL == NULL</code>, all MODEL sections are read.
</p>
</li>
<li><p> When <code>MODEL == NA</code>, MODEL records are ignored to read all ATOM and/or HETATM records together to return a single object.
</p>
</li></ul>



<h3>Value</h3>

<p>When a single MODEL section is read, this function returns an object of class  &lsquo;pdb&rsquo; (a list with a <code>class</code> attribute equal to <code>pdb</code>) with the following components:
</p>
<table>
<tr><td><code>title</code></td>
<td>
<p>a character vector containing the TITLE records found in the PDB file.</p>
</td></tr>
<tr><td><code>remark</code></td>
<td>
<p>a character vector containing the REMARK records found in the PDB file.</p>
</td></tr>
<tr><td><code>cryst1</code></td>
<td>
<p>a list of class &lsquo;cryst1&rsquo; containing the first CRYST1 record found in the PDB file. All others are ignored.</p>
</td></tr>
<tr><td><code>atoms</code></td>
<td>
<p>a data.frame of class &lsquo;atoms&rsquo; containing the ATOM and HETATM records found in the PDB file.</p>
</td></tr>
<tr><td><code>conect</code></td>
<td>
<p>a data.frame of class &lsquo;conect&rsquo; containing the CONECT records found in the PDB file.</p>
</td></tr>
</table>
<p>When multiple MODEL sections are read, a list of object of class &lsquo;pdb&rsquo; is returned.
</p>


<h3>References</h3>

<p>PDB format has been taken from:
http://www.wwpdb.org/documentation/format33/v3.3.html
</p>


<h3>See Also</h3>

<p><code><a href="#topic+write.pdb">write.pdb</a></code>, <code><a href="#topic+pdb">pdb</a></code>, <code><a href="#topic+cryst1">cryst1</a></code>, <code><a href="#topic+atoms">atoms</a></code>, <code><a href="#topic+conect">conect</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Read a PDB file included with the package
x &lt;- read.pdb(system.file("examples/PCBM_ODCB.pdb", package="Rpdb"))

# Visualize the PDB file
visualize(x, mode = NULL)

# Write the 'pdb' object 'x' in file "Rpdb.pdb" into the current directory
write.pdb(x, file = "Rpdb.pdb")

# Cleanup
unlink("Rpdb.pdb")

</code></pre>

<hr>
<h2 id='reindex'>Reinitialize Object Indexing</h2><span id='topic+reindex'></span><span id='topic+reindex.atoms'></span><span id='topic+reindex.pdb'></span>

<h3>Description</h3>

<p>Reinitialize the indexing of an object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reindex(...)

## S3 method for class 'atoms'
reindex(x, eleid = TRUE, resid = TRUE, ...)

## S3 method for class 'pdb'
reindex(x, eleid = TRUE, resid = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reindex_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
<tr><td><code id="reindex_+3A_x">x</code></td>
<td>
<p>an R object.</p>
</td></tr>
<tr><td><code id="reindex_+3A_eleid">eleid</code></td>
<td>
<p>a single element logical vector indicating if elements IDs have to reindexed.</p>
</td></tr>
<tr><td><code id="reindex_+3A_resid">resid</code></td>
<td>
<p>a single element logical vector indicating if residues IDs have to reindexed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>reindex</code> is a generic function to reinitialize the indexing of an object or its components.
The methods for objects of class &lsquo;atoms&rsquo; reinitialize the residue and element IDs starting
from 1 and avoiding gaps in the indexes. For objects of class &lsquo;pdb&rsquo; their <code>atoms</code> and
<code>conect</code> components are reindexed consistently.
</p>


<h3>Value</h3>

<p>Return an object of the same class as <code>x</code> with updated indexes.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pdb">pdb</a></code>, <code><a href="#topic+atoms">atoms</a></code>, <code><a href="#topic+subset.atoms">subset.atoms</a></code>, <code><a href="#topic+subset.pdb">subset.pdb</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- read.pdb(system.file("examples/PCBM_ODCB.pdb", package="Rpdb"))
x &lt;- subset(x, x$atoms$eleid %in% sample(x$atoms$eleid, 10))
print(x)
x &lt;- reindex(x)
print(x)

</code></pre>

<hr>
<h2 id='replicate'>Replicate Atomic Coordinates</h2><span id='topic+replicate'></span><span id='topic+replicate.coords'></span><span id='topic+replicate.atoms'></span><span id='topic+replicate.pdb'></span>

<h3>Description</h3>

<p>Replicate atomic coordinates using periodic boundary conditions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>replicate(x, ...)

## S3 method for class 'coords'
replicate(x, cryst1 = NULL, a.ind = 0, b.ind = 0, c.ind = 0, ...)

## S3 method for class 'atoms'
replicate(x, cryst1 = NULL, a.ind = 0, b.ind = 0, c.ind = 0, ...)

## S3 method for class 'pdb'
replicate(x, a.ind = 0, b.ind = 0, c.ind = 0, cryst1 = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="replicate_+3A_x">x</code></td>
<td>
<p>an R object containing atomic coordinates to be replicated.</p>
</td></tr>
<tr><td><code id="replicate_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
<tr><td><code id="replicate_+3A_cryst1">cryst1</code></td>
<td>
<p>an object of class &lsquo;cryst1&rsquo; containing periodical boundary conditions used for replicating.</p>
</td></tr>
<tr><td><code id="replicate_+3A_a.ind">a.ind</code></td>
<td>
<p>a vector of integers indicating the positions of the replicated cells along the a-axis.</p>
</td></tr>
<tr><td><code id="replicate_+3A_b.ind">b.ind</code></td>
<td>
<p>a vector of integers indicating the positions of the replicated cells along the b-axis.</p>
</td></tr>
<tr><td><code id="replicate_+3A_c.ind">c.ind</code></td>
<td>
<p>a vector of integers indicating the positions of the replicated cells along the c-axis.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>replicate</code> function replicate a unit cell along the lattice vectors a, b and c
as as many times as indicated by the <code>a.ind</code>, <code>b.ind</code> and <code>c.ind</code> arguments.
Discontinuous integer vectors can be used for <code>a.ind</code>, <code>b.ind</code> and <code>c.ind</code>
to create layered supercells (See examples).
</p>


<h3>Value</h3>

<p>Return an object of class &lsquo;pdb&rsquo; with replicated atomic coordinates.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+coords">coords</a></code>, <code><a href="#topic+atoms">atoms</a></code>, <code><a href="#topic+pdb">pdb</a></code>, <code><a href="#topic+cryst1">cryst1</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- read.pdb(system.file("examples/PCBM_ODCB.pdb", package="Rpdb"))

# Create a 3x3 supercell
y &lt;- replicate(x, a.ind = 0:2, b.ind = 0:2, c.ind = 0:2)

# Create a 3x3 supercell which might need to be wrapped (if some molecules are outside the cell)
y &lt;- replicate(x, a.ind = -1:1, b.ind = -1:1, c.ind = -1:1)

# Create a layered supercell with a vacuum layer in the bc-plan
y &lt;- replicate(x, a.ind = c(0,2), b.ind = 0:2, c.ind = 0:2)

</code></pre>

<hr>
<h2 id='rotation'>Rotation of Atomic Coordinates</h2><span id='topic+rotation'></span><span id='topic+R'></span><span id='topic+R.coords'></span><span id='topic+R.pdb'></span>

<h3>Description</h3>

<p>Rotation of atomic coordinates around a given vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>R(...)

## S3 method for class 'coords'
R(obj, angle = 0, x = 0, y = 0, z = 1, mask = TRUE, cryst1 = NULL, ...)

## S3 method for class 'pdb'
R(obj, angle = 0, x = 0, y = 0, z = 1, mask = TRUE, cryst1 = obj$cryst1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rotation_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
<tr><td><code id="rotation_+3A_obj">obj</code></td>
<td>
<p>an R object containing atomic coordinates.</p>
</td></tr>
<tr><td><code id="rotation_+3A_angle">angle</code></td>
<td>
<p>the angle of the rotation in degrees.</p>
</td></tr>
<tr><td><code id="rotation_+3A_x">x</code></td>
<td>
<p>the x-component of the rotation vector.</p>
</td></tr>
<tr><td><code id="rotation_+3A_y">y</code></td>
<td>
<p>the y-component of the rotation vector.</p>
</td></tr>
<tr><td><code id="rotation_+3A_z">z</code></td>
<td>
<p>the z-component of the rotation vector.</p>
</td></tr>
<tr><td><code id="rotation_+3A_mask">mask</code></td>
<td>
<p>a logical vector indicating the set of coordinates to which the rotation has to be applyed.</p>
</td></tr>
<tr><td><code id="rotation_+3A_cryst1">cryst1</code></td>
<td>
<p>an object of class &lsquo;cryst1&rsquo; use to convert fractional into Cartesian coordinates when need.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>R</code> is generic functions. Method for objects of class &lsquo;coords&rsquo;
first convert the coordinates into Cartesian coordinates using <code>cryst1</code>
if needed. Once rotated, the coordinates are reconverted back to the orginal
basis set using again <code>cryst1</code>. Method for objects of class &lsquo;pdb&rsquo;
first extract coordinates from the object using the function <code>coords</code>,
perform the rotation, and update the coordinates of the &lsquo;pdb&rsquo; object
using the function <code>coords&lt;-</code>.
</p>


<h3>Value</h3>

<p>An object of the same class as <code>x</code> with rotated coordinates.
</p>


<h3>See Also</h3>

<p>Helper functions for rotation around a given Cartesian vector:<br />
<code><a href="#topic+Rx">Rx</a></code>, <code><a href="#topic+Ry">Ry</a></code>, <code><a href="#topic+Rz">Rz</a></code><br />
Passing from Cartesian to fractional coordinates (or Vis Versa):<br />
<code><a href="#topic+xyz2abc">xyz2abc</a></code>, <code><a href="#topic+abc2xyz">abc2xyz</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># First lets read a pdb file
x &lt;- read.pdb(system.file("examples/PCBM_ODCB.pdb", package="Rpdb"))
cell &lt;- cell.coords(x)
visualize(x, mode = NULL)

# Rotation of the structure around the c-axis
visualize(R(x, 90, x=cell["x","c"], y=cell["y","c"], z=cell["z","c"]),
          mode = NULL)
# Rotation of the residue 1 around the c-axis
visualize(R(x, 90, x=cell["x","c"], y=cell["y","c"], z=cell["z","c"], mask = x$atoms$resid == 1),
          mode = NULL)
          
</code></pre>

<hr>
<h2 id='rotationHelpers'>Helper Functions for Rotation of Atomic Coordinates</h2><span id='topic+rotationHelpers'></span><span id='topic+Rx'></span><span id='topic+Rx.coords'></span><span id='topic+Rx.pdb'></span><span id='topic+Ry'></span><span id='topic+Ry.coords'></span><span id='topic+Ry.pdb'></span><span id='topic+Rz'></span><span id='topic+Rz.coords'></span><span id='topic+Rz.pdb'></span>

<h3>Description</h3>

<p>Rotation of atomic coordinates along a specific Cartesian vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Rx(...)

## S3 method for class 'coords'
Rx(x, angle = 0, mask = TRUE, cryst1 = NULL, ...)

## S3 method for class 'pdb'
Rx(x, angle = 0, mask = TRUE, cryst1 = x$cryst1, ...)

Ry(...)

## S3 method for class 'coords'
Ry(x, angle = 0, mask = TRUE, cryst1 = NULL, ...)

## S3 method for class 'pdb'
Ry(x, angle = 0, mask = TRUE, cryst1 = x$cryst1, ...)

Rz(...)

## S3 method for class 'coords'
Rz(x, angle = 0, mask = TRUE, cryst1 = NULL, ...)

## S3 method for class 'pdb'
Rz(x, angle = 0, mask = TRUE, cryst1 = x$cryst1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rotationHelpers_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
<tr><td><code id="rotationHelpers_+3A_x">x</code></td>
<td>
<p>an R object containing atomic coordinates.</p>
</td></tr>
<tr><td><code id="rotationHelpers_+3A_angle">angle</code></td>
<td>
<p>the angle of the rotation in degrees.</p>
</td></tr>
<tr><td><code id="rotationHelpers_+3A_mask">mask</code></td>
<td>
<p>a logical vector indicating the set of coordinates to which the
rotation has to be applyed.</p>
</td></tr>
<tr><td><code id="rotationHelpers_+3A_cryst1">cryst1</code></td>
<td>
<p>an object of class &lsquo;cryst1&rsquo; use to convert fractional
into Cartesian coordinates when need.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions are helper functions to perform a rotation around a specific 
Cartesian vector. All of them call the <code>R</code> function.
</p>


<h3>Value</h3>

<p>An object of the same class as <code>x</code> with rotated coordinates.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+R">R</a></code> and <code><a href="#topic+xyz2abc">xyz2abc</a></code>, <code><a href="#topic+abc2xyz">abc2xyz</a></code> for
passing from Cartesian to fractional coordinates (or Vis Versa).
</p>


<h3>Examples</h3>

<pre><code class='language-R'># First lets read a pdb file
x &lt;- read.pdb(system.file("examples/PCBM_ODCB.pdb", package="Rpdb"))
cell &lt;- cell.coords(x)
visualize(x, mode = NULL)

# Rotation of the structure around the z-axis
visualize(Rz(x, 90), mode = NULL)
# Rotation of the residue 1 around the c-axis
visualize(Rz(x, 90, mask = x$atoms$resid == 1), mode = NULL)

</code></pre>

<hr>
<h2 id='Rpdb-package'>Read, Write, Visualize and Manipulate PDB Files</h2><span id='topic+Rpdb-package'></span>

<h3>Description</h3>

<p>Provides tools to read, write, visualize PDB files, and perform structural manipulations.
</p>


<h3>Details</h3>

<p>This package enables users, e.g. computational chemists,
to manipulate molecular structures stored in PDB files.
It enables users ro read, write and visualize PDB files.
Various basic structural manipulations are also supported.
Conversion of Cartesian coordinates into fractional coordinates.
Spliting a molecular structure into fragments.
Computation of centers-of-geometry and centers-of-mass.
Wrapping molecular structure using periodical boundary conditions.
Translation, rotation and reflection of atomic coordinates.
Calculate atomic bond lengths, angles and dihedrals.
</p>


<h3>Author(s)</h3>

<p>Julien Id√© <a href="mailto:julien.ide.fr@gmail.com">julien.ide.fr@gmail.com</a><br />
</p>


<h3>References</h3>

<p>More information on the PDB format can be found here:<br />
http://www.wwpdb.org/documentation/format33/v3.3.html
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Read a PDB file included in the package
x &lt;- read.pdb(system.file("examples/PCBM_ODCB.pdb", package="Rpdb"))

## Visualize the PDB file
visualize(x, mode = NULL)

## From Cartesian to fractional coordinates and vice versa
x &lt;- xyz2abc(x)
basis(x)
natom(x, x$atoms$resid)
range(x)
centres(x)
x &lt;- abc2xyz(x)
basis(x)
natom(x, x$atoms$resid)
range(x)
centres(x)

## Split and unsplit
F &lt;- x$atoms$resid
x &lt;-   split(x, F)
x &lt;- unsplit(x, F)

## Subset and merge
x.PCB.only &lt;- subset(x, resname == "PCB")
x.DCB.only &lt;- subset(x, resname == "DCB")
x &lt;- merge(x.PCB.only, x.DCB.only)

## Duplicate and wrap
x &lt;- replicate(x, a.ind = -1:1, b.ind = -1:1, c.ind = -1:1)
x &lt;- wrap(x)

## Write the 'pdb' object 'x' to a temporary file.
write.pdb(x, file = tempfile())

</code></pre>

<hr>
<h2 id='split.pdb'>Divide and Reassemble &lsquo;pdb&rsquo; Objects</h2><span id='topic+split.pdb'></span><span id='topic+unsplit.pdb'></span>

<h3>Description</h3>

<p><code>split</code> divides a &lsquo;pdb&rsquo; object by groups of atoms defined by 
<code>f</code>. <code>unsplit</code> reverses the effect of <code>split</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pdb'
split(x, f, drop = FALSE, ...)

## S3 method for class 'pdb'
unsplit(value, f, drop = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="split.pdb_+3A_x">x</code></td>
<td>
<p>an object of class &lsquo;pdb&rsquo; to be divided into groups.</p>
</td></tr>
<tr><td><code id="split.pdb_+3A_f">f</code></td>
<td>
<p>a &lsquo;factor&rsquo; in the sense that
<code><a href="base.html#topic+as.factor">as.factor</a>(f)</code> defines the grouping, or a list of such factors
in which case their interaction is used for the grouping.</p>
</td></tr>
<tr><td><code id="split.pdb_+3A_drop">drop</code></td>
<td>
<p>logical indicating if levels that do not occur should be
dropped (if <code>f</code> is a <code>factor</code> or a list).</p>
</td></tr>
<tr><td><code id="split.pdb_+3A_...">...</code></td>
<td>
<p>further potential arguments passed to methods.</p>
</td></tr>
<tr><td><code id="split.pdb_+3A_value">value</code></td>
<td>
<p>a list of 'pdb' objects compatible with a splitting of
<code>x</code>. Recycling applies if the lengths do not match.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>split</code> produce a list of &lsquo;pdb&rsquo; objects with the same 
<code>cryst1</code>, <code>title</code> and <code>remark</code> components as <code>x</code>. Only 
its <code>atoms</code> component is splitted while its <code>conect</code> component is 
cleaned to keep only the meaningful connectivity for each &lsquo;pdb&rsquo; object
of the list returned by the function. <code>unlist</code> produce a &lsquo;pdb&rsquo; 
object with the same <code>cryst1</code>, <code>title</code> and <code>remark</code> components
as the first element of <code>value</code>. The <code>atoms</code> and <code>conect</code> 
components of all the elements of <code>value</code> are combined by row.
</p>


<h3>Value</h3>

<p>The value returned from <code>split</code> is a list of &lsquo;pdb&rsquo;
objects containing the data for the groups of atoms. The components of the
list are named by the levels of <code>f</code> (after converting to a factor, or if
already a factor and <code>drop=TRUE</code>, dropping unused levels). <br /> 
<code>unsplit</code> returns a &lsquo;pdb&rsquo; object for which <code>split(x, f)</code>
equals <code>value</code>.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+split">split</a></code>, <code><a href="#topic+unsplit">unsplit</a></code>, <code><a href="#topic+pdb">pdb</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
### Split a pdb file by residue IDs and write them into separate files
x &lt;- read.pdb(system.file("examples/PCBM_ODCB.pdb", package="Rpdb"))

file.names &lt;- paste0(x$atoms$resname, "_", x$atoms$resid, ".pdb")
file.names &lt;- unique(file.names)
pdb.resid  &lt;- split(x, x$atoms$resid)
length(pdb.resid)
useless &lt;- mapply(write.pdb, pdb.resid, file.names)

# Cleanup
unlink(file.names)


</code></pre>

<hr>
<h2 id='subset.atoms'>Subsetting &lsquo;atoms&rsquo; and &lsquo;pdb&rsquo; Objects</h2><span id='topic+subset.atoms'></span><span id='topic+subset.pdb'></span>

<h3>Description</h3>

<p>Return subsets of &lsquo;atoms&rsquo; or &lsquo;pdb&rsquo; objects which meet
conditions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'atoms'
subset(x, subset, drop = FALSE, reindex.all = TRUE, ...)

## S3 method for class 'pdb'
subset(x, subset, drop = FALSE, reindex.all = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="subset.atoms_+3A_x">x</code></td>
<td>
<p>object to be subsetted.</p>
</td></tr>
<tr><td><code id="subset.atoms_+3A_subset">subset</code></td>
<td>
<p>logical expression indicating elements or rows to keep: missing values are taken as false.</p>
</td></tr>
<tr><td><code id="subset.atoms_+3A_drop">drop</code></td>
<td>
<p>passed on to [ indexing operator.</p>
</td></tr>
<tr><td><code id="subset.atoms_+3A_reindex.all">reindex.all</code></td>
<td>
<p>a single element logical vector indicating if residues and elements IDs have to be reindexed after subsetting.</p>
</td></tr>
<tr><td><code id="subset.atoms_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For an &lsquo;atoms&rsquo; object the method is similar to the data.frame method
(see <code><a href="base.html#topic+subset">subset</a></code>) but allow to directly reindex the elements and
residues IDs. For a &lsquo;pdb&rsquo; object subsetting is applied on the
<code>atoms</code> and <code>conect</code> components of the object in a consistent way.
First the <code>atoms</code> component is subsetted and then the <code>conect</code>
component is filtered to keep only the conectivity for the subset.
</p>


<h3>Value</h3>

<p>Return a subsetted object of the same class as <code>x</code>.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+subset">subset</a></code>, <code><a href="#topic+pdb">pdb</a></code>, <code><a href="#topic+atoms">atoms</a></code>, <code><a href="#topic+reindex">reindex</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- read.pdb(system.file("examples/PCBM_ODCB.pdb", package="Rpdb"))
y &lt;- subset(x, x$atoms$eleid %in% sample(x$atoms$eleid, 10))
is(y)
y &lt;- subset(x$atoms, x$atoms$eleid %in% sample(x$atoms$eleid, 10))
is(y)
x &lt;- coords(x)
y &lt;- subset(x, x &lt; 0)
is(y)

</code></pre>

<hr>
<h2 id='toSymbols'>Atomic Symbols Converter</h2><span id='topic+toSymbols'></span><span id='topic+toSymbols.integer'></span><span id='topic+toSymbols.numeric'></span><span id='topic+toSymbols.character'></span>

<h3>Description</h3>

<p>Converts character strings or atomic numbers into atomic symbols.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>toSymbols(x, ...)

## S3 method for class 'integer'
toSymbols(x, ...)

## S3 method for class 'numeric'
toSymbols(x, ...)

## S3 method for class 'character'
toSymbols(x, nletters = 3, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="toSymbols_+3A_x">x</code></td>
<td>
<p>a vector to be converted into atomic symbols.</p>
</td></tr>
<tr><td><code id="toSymbols_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
<tr><td><code id="toSymbols_+3A_nletters">nletters</code></td>
<td>
<p>an integer used to truncate the character strings before convertion.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Each elements of <code>x</code> are converted into atomic symbols.<br />
When <code>x</code> is an integer (or numeric) vector, atomic number are search into the <code>elements</code> data set to find associated atomic symbols.<br />
When <code>x</code> is a character vector, <code>toSymbols</code> first removes all leading and trailing white spaces and numbers.
Then translates the first character of the character strings to uppercase and all the others to lowercase.
Finally, the character strings are tested for matching with element symbols provided by the <code>elements</code> data set.
NA are produced for no matching.
</p>


<h3>Value</h3>

<p>a character vector containing atomic symbols
</p>


<h3>See Also</h3>

<p><code><a href="#topic+elements">elements</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c(1:10)
toSymbols(x)

x &lt;- c("C  "," o","h1","1h","UU","SI0","cR")
toSymbols(x)

# 'nletters' can be used to truncate the character strings before
# conversion, if needed:
toSymbols("SIL", nletters=3) # return NA
toSymbols("SIL", nletters=2) # return "Si"
toSymbols("SIL", nletters=1) # return "S"

</code></pre>

<hr>
<h2 id='translation'>Translation of Atomic Coordinates</h2><span id='topic+translation'></span><span id='topic+Txyz'></span><span id='topic+Txyz.coords'></span><span id='topic+Txyz.pdb'></span><span id='topic+Tabc'></span><span id='topic+Tabc.coords'></span><span id='topic+Tabc.pdb'></span>

<h3>Description</h3>

<p>Translation of Cartesian or fractional coordinates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Txyz(...)

## S3 method for class 'coords'
Txyz(
  obj,
  x = 0,
  y = 0,
  z = 0,
  mask = TRUE,
  thickness = NULL,
  cryst1 = NULL,
  ...
)

## S3 method for class 'pdb'
Txyz(
  obj,
  x = 0,
  y = 0,
  z = 0,
  mask = TRUE,
  thickness = NULL,
  cryst1 = obj$cryst1,
  ...
)

Tabc(...)

## S3 method for class 'coords'
Tabc(
  obj,
  a = 0,
  b = 0,
  c = 0,
  mask = TRUE,
  thickness = NULL,
  cryst1 = NULL,
  ...
)

## S3 method for class 'pdb'
Tabc(
  obj,
  a = 0,
  b = 0,
  c = 0,
  mask = TRUE,
  thickness = NULL,
  cryst1 = obj$cryst1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="translation_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
<tr><td><code id="translation_+3A_obj">obj</code></td>
<td>
<p>an R object containing atomic coordinates.</p>
</td></tr>
<tr><td><code id="translation_+3A_x">x</code></td>
<td>
<p>the x-component of the translation vector.</p>
</td></tr>
<tr><td><code id="translation_+3A_y">y</code></td>
<td>
<p>the y-component of the translation vector.</p>
</td></tr>
<tr><td><code id="translation_+3A_z">z</code></td>
<td>
<p>the z-component of the translation vector.</p>
</td></tr>
<tr><td><code id="translation_+3A_mask">mask</code></td>
<td>
<p>a logical vector indicating the set of coordinates to which to
apply the translation.</p>
</td></tr>
<tr><td><code id="translation_+3A_thickness">thickness</code></td>
<td>
<p>a numeric value indicating the fraction of the thicknees of
the selected atom to be added to the translation vector (Usually 0, 0.5 or
1. See details).</p>
</td></tr>
<tr><td><code id="translation_+3A_cryst1">cryst1</code></td>
<td>
<p>an object of class &lsquo;cryst1&rsquo; use to convert Cartesian
into fraction coordinates (or Vis Versa) when need.</p>
</td></tr>
<tr><td><code id="translation_+3A_a">a</code></td>
<td>
<p>the a-component of the translation vector.</p>
</td></tr>
<tr><td><code id="translation_+3A_b">b</code></td>
<td>
<p>the b-component of the translation vector.</p>
</td></tr>
<tr><td><code id="translation_+3A_c">c</code></td>
<td>
<p>the c-component of the translation vector.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>Txyz</code> and <code>Tabc</code> are generic functions. Method for objects of 
class &lsquo;coords&rsquo; first convert the coordinates into Cartesian or 
fractional coordinates using <code>cryst1</code> if needed to performed the 
translation. Once translated, the coordinates are reconverted back to the 
orginal basis set using again <code>cryst1</code>. Method for objects of class 
&lsquo;pdb&rsquo; first extract coordinates from the object using the function 
<code>coords</code>, perform the translation, and update the coordinates of the 
&lsquo;pdb&rsquo; object using the function <code>coords&lt;-</code>. The <code>thickness</code> 
argument can be use to translate selected atoms by a fraction of its 
thickness along the translation direction. This can be use when merging two 
fragments centered at the origin to build a dimer to avoid atomic overlap and
set the inter-fragment distance (see examples).
</p>


<h3>Value</h3>

<p>An object of the same class as <code>x</code> with translated coordinates.
</p>


<h3>See Also</h3>

<p>Helper functions for translation along given Cartesian or lattice vector:<br />
<code><a href="#topic+Tx">Tx</a></code>, <code><a href="#topic+Ty">Ty</a></code>, <code><a href="#topic+Tz">Tz</a></code>, <code><a href="#topic+Ta">Ta</a></code>, <code><a href="#topic+Tb">Tb</a></code>, <code><a href="#topic+Tc">Tc</a></code><br />
Passing from Cartesian to fractional coordinates (or Vis Versa):<br />
<code><a href="#topic+xyz2abc">xyz2abc</a></code>, <code><a href="#topic+abc2xyz">abc2xyz</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># First lets read a pdb file
x &lt;- read.pdb(system.file("examples/PCBM_ODCB.pdb", package="Rpdb"))
visualize(x, mode = NULL)
visualize(Txyz(x, y=10), mode = NULL)
visualize(Txyz(x, y=10, mask = x$atoms$resid==1), mode = NULL)
visualize(Tabc(x, b=1 ), mode = NULL)
visualize(Tabc(x, b=1 , mask = x$atoms$resid==1), mode = NULL)

# Lets build a C70/Pentacene dimer with an inter-molecular distance equal to 3.5
C70 &lt;- read.pdb(system.file("examples/C70.pdb", package="Rpdb"))
Pen &lt;- read.pdb(system.file("examples/Pentacene.pdb", package="Rpdb"))
x &lt;- merge(C70, Pen)
visualize(x, mode = NULL)
viewXY()
visualize(Txyz(x, x=0, y=0, z=3.5, mask = x$atoms$resname == "C70", thickness=0.5), mode = NULL)
viewXY()

</code></pre>

<hr>
<h2 id='translationHelpers'>Helper Functions for Translation of Atomic Coordinates</h2><span id='topic+translationHelpers'></span><span id='topic+Tx'></span><span id='topic+Tx.coords'></span><span id='topic+Tx.pdb'></span><span id='topic+Ty'></span><span id='topic+Ty.coords'></span><span id='topic+Ty.pdb'></span><span id='topic+Tz'></span><span id='topic+Tz.coords'></span><span id='topic+Tz.pdb'></span><span id='topic+Ta'></span><span id='topic+Ta.coords'></span><span id='topic+Ta.pdb'></span><span id='topic+Tb'></span><span id='topic+Tb.coords'></span><span id='topic+Tb.pdb'></span><span id='topic+Tc'></span><span id='topic+Tc.coords'></span><span id='topic+Tc.pdb'></span>

<h3>Description</h3>

<p>Translation of atomic coordinates along a specific Cartesian or lattice
vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Tx(...)

## S3 method for class 'coords'
Tx(obj, x = 0, mask = TRUE, thickness = NULL, cryst1 = NULL, ...)

## S3 method for class 'pdb'
Tx(obj, x = 0, mask = TRUE, thickness = NULL, cryst1 = obj$cryst1, ...)

Ty(...)

## S3 method for class 'coords'
Ty(obj, y = 0, mask = TRUE, thickness = NULL, cryst1 = NULL, ...)

## S3 method for class 'pdb'
Ty(obj, y = 0, mask = TRUE, thickness = NULL, cryst1 = obj$cryst1, ...)

Tz(...)

## S3 method for class 'coords'
Tz(obj, z = 0, mask = TRUE, thickness = NULL, cryst1 = NULL, ...)

## S3 method for class 'pdb'
Tz(obj, z = 0, mask = TRUE, thickness = NULL, cryst1 = obj$cryst1, ...)

Ta(...)

## S3 method for class 'coords'
Ta(obj, a = 0, mask = TRUE, cryst1 = NULL, ...)

## S3 method for class 'pdb'
Ta(obj, a = 0, mask = TRUE, cryst1 = obj$cryst1, ...)

Tb(...)

## S3 method for class 'coords'
Tb(obj, b = 0, mask = TRUE, cryst1 = NULL, ...)

## S3 method for class 'pdb'
Tb(obj, b = 0, mask = TRUE, cryst1 = obj$cryst1, ...)

Tc(...)

## S3 method for class 'coords'
Tc(obj, c = 0, mask = TRUE, cryst1 = NULL, ...)

## S3 method for class 'pdb'
Tc(obj, c = 0, mask = TRUE, cryst1 = obj$cryst1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="translationHelpers_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
<tr><td><code id="translationHelpers_+3A_obj">obj</code></td>
<td>
<p>an R object containing atomic coordinates.</p>
</td></tr>
<tr><td><code id="translationHelpers_+3A_x">x</code></td>
<td>
<p>the x-component of the translation vector.</p>
</td></tr>
<tr><td><code id="translationHelpers_+3A_mask">mask</code></td>
<td>
<p>a logical vector indicating the set of coordinates to which to apply the translation.</p>
</td></tr>
<tr><td><code id="translationHelpers_+3A_thickness">thickness</code></td>
<td>
<p>a numeric value indicating the fraction of the thicknees of the selected atom to be added to the translation vector (Usually 0, 0.5 or 1. See details).</p>
</td></tr>
<tr><td><code id="translationHelpers_+3A_cryst1">cryst1</code></td>
<td>
<p>an object of class &lsquo;cryst1&rsquo; use to convert Cartesian into fraction coordinates (or Vis Versa) when need.</p>
</td></tr>
<tr><td><code id="translationHelpers_+3A_y">y</code></td>
<td>
<p>the y-component of the translation vector.</p>
</td></tr>
<tr><td><code id="translationHelpers_+3A_z">z</code></td>
<td>
<p>the z-component of the translation vector.</p>
</td></tr>
<tr><td><code id="translationHelpers_+3A_a">a</code></td>
<td>
<p>the a-component of the translation vector.</p>
</td></tr>
<tr><td><code id="translationHelpers_+3A_b">b</code></td>
<td>
<p>the b-component of the translation vector.</p>
</td></tr>
<tr><td><code id="translationHelpers_+3A_c">c</code></td>
<td>
<p>the c-component of the translation vector.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions are helper functions to perform a translation along a
specific Cartesian or lattice vector. All of them call either the <code>Txyz</code>
or <code>Tabc</code> function.
</p>


<h3>Value</h3>

<p>An object of the same class as <code>x</code> with translated coordinates.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Txyz">Txyz</a></code>, <code><a href="#topic+Tabc">Tabc</a></code><br />
Passing from Cartesian to fractional coordinates (or Vis Versa):<br />
<code><a href="#topic+xyz2abc">xyz2abc</a></code>, <code><a href="#topic+abc2xyz">abc2xyz</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- read.pdb(system.file("examples/PCBM_ODCB.pdb", package="Rpdb"))
visualize(x, mode = NULL)
visualize(Ty(x, 10), mode = NULL)
visualize(Ty(x, 10, mask = x$atoms$resid==1), mode = NULL)
visualize(Tb(x, 1 ), mode = NULL)
visualize(Tb(x, 1 , mask = x$atoms$resid==1), mode = NULL)

# Lets build a C70/Pentacene dimer with an inter-molecular distance equal to 3.5
C70 &lt;- read.pdb(system.file("examples/C70.pdb", package="Rpdb"))
Pen &lt;- read.pdb(system.file("examples/Pentacene.pdb", package="Rpdb"))
x &lt;- merge(C70, Pen)
visualize(x, mode = NULL)
viewXY()
visualize(Tz(x, z=3.5, mask = x$atoms$resname == "C70", thickness=0.5), mode = NULL)
viewXY()

</code></pre>

<hr>
<h2 id='universalConstants'>Universal Constants</h2><span id='topic+universalConstants'></span>

<h3>Description</h3>

<p>This data set provides various universal constants
</p>


<h3>Format</h3>

<p>A data frame containing for each universal constant the following information.
</p>

<dl>
<dt><code>Quantity</code></dt><dd><p>a character vector containing a short description of the constants.</p>
</dd>
<dt><code>Value</code></dt><dd><p>a numeric vector containing the value of the constants.</p>
</dd>
<dt><code>Unit</code></dt><dd><p>a character vector indicating the unit of the constants.</p>
</dd>
</dl>



<h3>Source</h3>

<p>http://www.ebyte.it/library/educards/constants/ConstantsOfPhysicsAndMath.html
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Data for the speed of light
universalConstants["c",]

# Return the speed of light in m.s-1
universalConstants["c","Value"]

# Return the Planck constant in J.s
universalConstants["h","Value"]

</code></pre>

<hr>
<h2 id='unsplit'>Reassemble Groups</h2><span id='topic+unsplit'></span><span id='topic+unsplit.default'></span>

<h3>Description</h3>

<p><code>unsplit</code> reverses the effect of <code>split</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unsplit(value, f, drop = FALSE, ...)

## Default S3 method:
unsplit(value, f, drop = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unsplit_+3A_value">value</code></td>
<td>
<p>a list of vectors or data frames compatible with a splitting of
<code>x</code>. Recycling applies if the lengths do not match.</p>
</td></tr>
<tr><td><code id="unsplit_+3A_f">f</code></td>
<td>
<p>a &lsquo;factor&rsquo; in the sense that <code><a href="base.html#topic+as.factor">as.factor</a>(f)</code>
defines the grouping, or a list of such factors in which case their
interaction is used for the grouping.</p>
</td></tr>
<tr><td><code id="unsplit_+3A_drop">drop</code></td>
<td>
<p>logical indicating if levels that do not occur should be dropped
(if <code>f</code> is a <code>factor</code> or a list).</p>
</td></tr>
<tr><td><code id="unsplit_+3A_...">...</code></td>
<td>
<p>further potential arguments passed to methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>unsplit</code> is a generic functions with a default method (Method dispatch 
takes place based on the class of the first element of <code>value</code>) working 
with lists of vectors or data frames (assumed to have compatible structure, 
as if created by <code>split</code>). It puts elements or rows back in the 
positions given by <code>f</code>. In the data frame case, row names are obtained 
by unsplitting the row name vectors from the elements of <code>value</code>. <br /> 
<code>f</code> is recycled as necessary and if the length of <code>x</code> is not a 
multiple of the length of <code>f</code> a warning is printed. <br /> Any missing 
values in <code>f</code> are dropped together with the corresponding values of 
<code>x</code>.
</p>


<h3>Value</h3>

<p>Returns a vector or data frame for which <code>split(x, f)</code> equals
<code>value</code>
</p>


<h3>References</h3>

<p>Becker, R. A., Chambers, J. M. and Wilks, A. R. (1988) <em>The New S Language</em>. Wadsworth &amp; Brooks/Cole.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+cut">cut</a></code> to categorize numeric values.
<br />
<code><a href="base.html#topic+strsplit">strsplit</a></code> to split strings.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(stats); require(graphics)
n &lt;- 10; nn &lt;- 100
g &lt;- factor(round(n * runif(n * nn)))
x &lt;- rnorm(n * nn) + sqrt(as.numeric(g))
xg &lt;- split(x, g)
boxplot(xg, col = "lavender", notch = TRUE, varwidth = TRUE)
sapply(xg, length)
sapply(xg, mean)

### Calculate 'z-scores' by group (standardize to mean zero, variance one)
z &lt;- unsplit(lapply(split(x, g), scale), g)

# or

zz &lt;- x
split(zz, g) &lt;- lapply(split(x, g), scale)

# and check that the within-group std dev is indeed one
tapply(z, g, sd)
tapply(zz, g, sd)


### Data frame variation

# Notice that assignment form is not used since a variable is being added

g &lt;- airquality$Month
l &lt;- split(airquality, g)
l &lt;- lapply(l, transform, Oz.Z = scale(Ozone))
aq2 &lt;- unsplit(l, g)
head(aq2)
with(aq2, tapply(Oz.Z,  Month, sd, na.rm=TRUE))


### Split a matrix into a list by columns
ma &lt;- cbind(x = 1:10, y = (-4:5)^2)
split(ma, col(ma))

split(1:10, 1:2)

</code></pre>

<hr>
<h2 id='vectorialOperations'>Basic Vectorial Operations</h2><span id='topic+vectorialOperations'></span><span id='topic+dotProd'></span><span id='topic+vectNorm'></span><span id='topic+rotVect'></span><span id='topic+vectProd'></span>

<h3>Description</h3>

<p>Basic vectorial operations such as scalar product and vectorial product
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dotProd(U, V)

vectNorm(U)

rotVect(U, n = 1)

vectProd(U, V)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vectorialOperations_+3A_u">U</code></td>
<td>
<p>a numeric vector of length 3.</p>
</td></tr>
<tr><td><code id="vectorialOperations_+3A_v">V</code></td>
<td>
<p>a numeric vector of length 3.</p>
</td></tr>
<tr><td><code id="vectorialOperations_+3A_n">n</code></td>
<td>
<p>an integer.</p>
</td></tr>
</table>


<h3>Value</h3>


<ul>
<li><p><code>dotProct</code> return a single element numeric vector.
</p>
</li>
<li><p><code>vectNorm</code> return a single element numeric vector.
</p>
</li>
<li><p><code>rotVect</code> return a numeric vector of length 3.
</p>
</li>
<li><p><code>vectProct</code> return a numeric vector of length 3.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="base.html#topic+matmult">matmult</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Vx &lt;- c(3,0,0)
vectNorm(Vx)
Vx &lt;- Vx / vectNorm(Vx)
Vy &lt;- c(0,1,0)
Vz &lt;- vectProd(Vx, Vy)
print(Vz)

</code></pre>

<hr>
<h2 id='viewAxis'>Set the View of the &lsquo;rgl&rsquo; Scene</h2><span id='topic+viewAxis'></span><span id='topic+viewXY'></span><span id='topic+viewYZ'></span><span id='topic+viewZX'></span><span id='topic+viewAB'></span><span id='topic+viewBC'></span><span id='topic+viewCA'></span><span id='topic+viewInertia'></span>

<h3>Description</h3>

<p>Set the view of the current &lsquo;rgl&rsquo; scene aligning one vector 
perpendicularly to the screen and placing another one in the horizontal plane.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>viewAxis(V1, V2)

viewXY()

viewYZ()

viewZX()

viewAB(cryst1)

viewBC(cryst1)

viewCA(cryst1)

viewInertia(x, m = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="viewAxis_+3A_v1">V1</code></td>
<td>
<p>a length 3 numeric vector.</p>
</td></tr>
<tr><td><code id="viewAxis_+3A_v2">V2</code></td>
<td>
<p>a length 3 numeric vector.</p>
</td></tr>
<tr><td><code id="viewAxis_+3A_cryst1">cryst1</code></td>
<td>
<p>an object of class &lsquo;cryst1&rsquo;.</p>
</td></tr>
<tr><td><code id="viewAxis_+3A_x">x</code></td>
<td>
<p>an R object containing atomic coordinates.</p>
</td></tr>
<tr><td><code id="viewAxis_+3A_m">m</code></td>
<td>
<p>a numeric vector containing atomic masses.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>viewAxis</code> set the view of the current rgl scene (by setting
<code>UserMatrix</code>; see <code><a href="rgl.html#topic+par3d">par3d</a></code> for more details) so that
<code>V1</code> is perpendicular to the screen and <code>V2</code> is in the horizontal
plane. The other functions documented here are helper functions calling
<code>viewAxis</code> to set the view using particular Cartesian or lattice
vectors. For functions <code>viewAB</code>, <code>viewBC</code> and <code>viewCA</code> a
&lsquo;cryst1&rsquo; object has to be specifyed to define the lattice vectors
used to set the view. The function <code>viewInertia</code> computes the inertia
tensor from the atomic coordinates and masses (see <code><a href="#topic+inertia">inertia</a></code>)
and sets the view to its eigen vectors basis set.
</p>


<h3>Value</h3>

<p>No return value, called for side effects.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+visualize">visualize</a></code>, <code><a href="#topic+cell.coords">cell.coords</a></code>, <code><a href="rgl.html#topic+par3d">par3d</a></code>, <code><a href="rgl.html#topic+rgl.open">rgl.open</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- read.pdb(system.file("examples/PCBM_ODCB.pdb", package="Rpdb"))
visualize(x, mode = NULL)
viewAB(x$cryst1)

C70 &lt;- read.pdb(system.file("examples/C70.pdb", package="Rpdb"))
visualize(C70, mode = NULL)
viewXY()
viewInertia(C70)

</code></pre>

<hr>
<h2 id='visualize'>Visualize a Molecular Structure</h2><span id='topic+visualize'></span><span id='topic+visualize.coords'></span><span id='topic+visualize.data.frame'></span><span id='topic+visualize.matrix'></span><span id='topic+visualize.atoms'></span><span id='topic+visualize.pdb'></span><span id='topic+visualize.character'></span>

<h3>Description</h3>

<p>Use the rgl library to visualize in 3D a molecular structure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>visualize(...)

## S3 method for class 'coords'
visualize(
  x,
  elename = NULL,
  cryst1 = NULL,
  conect = NULL,
  mode = NULL,
  type = "l",
  xyz = NULL,
  abc = NULL,
  pbc.box = NULL,
  lwd = 2,
  lwd.xyz = lwd,
  lwd.abc = lwd,
  lwd.pbc.box = lwd,
  cex.xyz = 2,
  cex.abc = 2,
  col = NULL,
  bg = "#FAFAD2",
  radii = "rvdw",
  add = FALSE,
  windowRect = c(0, 0, 800, 600),
  FOV = 0,
  userMatrix = diag(4),
  ...
)

## S3 method for class 'data.frame'
visualize(
  x,
  elename = NULL,
  cryst1 = NULL,
  conect = NULL,
  mode = NULL,
  type = "l",
  xyz = NULL,
  abc = NULL,
  pbc.box = NULL,
  lwd = 2,
  lwd.xyz = lwd,
  lwd.abc = lwd,
  lwd.pbc.box = lwd,
  cex.xyz = 2,
  cex.abc = 2,
  col = NULL,
  bg = "#FAFAD2",
  radii = "rvdw",
  add = FALSE,
  windowRect = c(0, 0, 800, 600),
  FOV = 0,
  userMatrix = diag(4),
  ...
)

## S3 method for class 'matrix'
visualize(
  x,
  elename = NULL,
  cryst1 = NULL,
  conect = NULL,
  mode = NULL,
  type = "l",
  xyz = NULL,
  abc = NULL,
  pbc.box = NULL,
  lwd = 2,
  lwd.xyz = lwd,
  lwd.abc = lwd,
  lwd.pbc.box = lwd,
  cex.xyz = 2,
  cex.abc = 2,
  col = NULL,
  bg = "#FAFAD2",
  radii = "rvdw",
  add = FALSE,
  windowRect = c(0, 0, 800, 600),
  FOV = 0,
  userMatrix = diag(4),
  ...
)

## S3 method for class 'atoms'
visualize(
  x,
  cryst1 = NULL,
  conect = NULL,
  mode = NULL,
  type = "l",
  xyz = NULL,
  abc = NULL,
  pbc.box = NULL,
  lwd = 2,
  lwd.xyz = lwd,
  lwd.abc = lwd,
  lwd.pbc.box = lwd,
  cex.xyz = 2,
  cex.abc = 2,
  col = NULL,
  bg = "#FAFAD2",
  radii = "rvdw",
  add = FALSE,
  windowRect = c(0, 0, 800, 600),
  FOV = 0,
  userMatrix = diag(4),
  ...
)

## S3 method for class 'pdb'
visualize(
  x,
  mode = NULL,
  type = "l",
  xyz = NULL,
  abc = NULL,
  pbc.box = NULL,
  lwd = 2,
  lwd.xyz = lwd,
  lwd.abc = lwd,
  lwd.pbc.box = lwd,
  cex.xyz = 2,
  cex.abc = 2,
  col = NULL,
  bg = "#FAFAD2",
  radii = "rvdw",
  add = FALSE,
  windowRect = c(0, 0, 800, 600),
  FOV = 0,
  userMatrix = diag(4),
  ...
)

## S3 method for class 'character'
visualize(
  x,
  mode = NULL,
  type = "l",
  xyz = NULL,
  abc = NULL,
  pbc.box = NULL,
  lwd = 2,
  lwd.xyz = lwd,
  lwd.abc = lwd,
  lwd.pbc.box = lwd,
  cex.xyz = 2,
  cex.abc = 2,
  col = NULL,
  bg = "#FAFAD2",
  radii = "rvdw",
  add = FALSE,
  windowRect = c(0, 0, 800, 600),
  FOV = 0,
  userMatrix = diag(4),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="visualize_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
<tr><td><code id="visualize_+3A_x">x</code></td>
<td>
<p>an object or the name of a PDB file containing the molecular structure to visualize.</p>
</td></tr>
<tr><td><code id="visualize_+3A_elename">elename</code></td>
<td>
<p>a character vector containing the atomic names used to chose atom colors and radii.</p>
</td></tr>
<tr><td><code id="visualize_+3A_cryst1">cryst1</code></td>
<td>
<p>an object of class &lsquo;cryst1&rsquo;. See <code><a href="#topic+cryst1">cryst1</a></code></p>
</td></tr>
<tr><td><code id="visualize_+3A_conect">conect</code></td>
<td>
<p>an object of class &lsquo;conect&rsquo;. See <code><a href="#topic+conect">conect</a></code></p>
</td></tr>
<tr><td><code id="visualize_+3A_mode">mode</code></td>
<td>
<p>a single element character vector indicating the visualization mode (See details).</p>
</td></tr>
<tr><td><code id="visualize_+3A_type">type</code></td>
<td>
<p>a character string indicating the visualization style (See details).</p>
</td></tr>
<tr><td><code id="visualize_+3A_xyz">xyz</code></td>
<td>
<p>a logical value indicating whether the x, y and z axes have to be added to the scene. See details</p>
</td></tr>
<tr><td><code id="visualize_+3A_abc">abc</code></td>
<td>
<p>a logical value indicating whether the a, b and c axes have to be added to the scene. See details</p>
</td></tr>
<tr><td><code id="visualize_+3A_pbc.box">pbc.box</code></td>
<td>
<p>a logical value indicating whether the pbc box has to be added to the scene. See details</p>
</td></tr>
<tr><td><code id="visualize_+3A_lwd">lwd</code></td>
<td>
<p>a numeric value indication the line width used to plot the axes, the pbc box and atomic bonds when <code>type = "l"</code> (see details).</p>
</td></tr>
<tr><td><code id="visualize_+3A_lwd.xyz">lwd.xyz</code></td>
<td>
<p>a numeric value indicating the line width used to plot the x, y and z axes.</p>
</td></tr>
<tr><td><code id="visualize_+3A_lwd.abc">lwd.abc</code></td>
<td>
<p>a numeric value indicating the line width used to plot the a, b and c axes.</p>
</td></tr>
<tr><td><code id="visualize_+3A_lwd.pbc.box">lwd.pbc.box</code></td>
<td>
<p>a numeric value indicating the line width used to plot the pbc box.</p>
</td></tr>
<tr><td><code id="visualize_+3A_cex.xyz">cex.xyz</code></td>
<td>
<p>a numeric value indicating the magnification used to plot the labels of the x, y and z axes.</p>
</td></tr>
<tr><td><code id="visualize_+3A_cex.abc">cex.abc</code></td>
<td>
<p>a numeric value indicating the magnification used to plot the labels of the a, b and c axes.</p>
</td></tr>
<tr><td><code id="visualize_+3A_col">col</code></td>
<td>
<p>a vector indicating the colors to use to plot each atom.</p>
</td></tr>
<tr><td><code id="visualize_+3A_bg">bg</code></td>
<td>
<p>the color of the background</p>
</td></tr>
<tr><td><code id="visualize_+3A_radii">radii</code></td>
<td>
<p>either a character string indicating the type of radii or a numeric vector specifying the radii of each atom to use to plot atoms as spheres (see details).</p>
</td></tr>
<tr><td><code id="visualize_+3A_add">add</code></td>
<td>
<p>a logical value indicating whether the plot has be to added to a existing scene (see <code>rgl.cur</code> and <code>open3d</code>).</p>
</td></tr>
<tr><td><code id="visualize_+3A_windowrect">windowRect</code></td>
<td>
<p>a vector of four integers indicating the left, top, right and bottom of the displayed window in pixels (see <code>par3d</code>).</p>
</td></tr>
<tr><td><code id="visualize_+3A_fov">FOV</code></td>
<td>
<p>the field of view. This controls the degree of parallax in the perspective view (see par3d).</p>
</td></tr>
<tr><td><code id="visualize_+3A_usermatrix">userMatrix</code></td>
<td>
<p>a 4 by 4 matrix describing user actions to display the scene (see <code>par3d</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Three different visualization styles are allowed.
</p>

<ul>
<li><p>   When <code>type="p"</code>: Points are drawn at each atomic positions (very light visualization mode).
</p>
</li>
<li><p>   When <code>type="l"</code>: Lines are drawn between bonded atoms. The connectivity of the system has to be specifyed.
</p>
</li>
<li><p>   When <code>type="s"</code>: Spheres are drawn at each atomic positions (heavy visualization mode).
</p>
<p>The radii of the spheres are given by <code>radii</code>.
</p>

<ul>
<li><p>   When <code>radii="rcov"</code>: Covalent radii, taken from the <code>elements</code> data set, are used.
</p>
</li>
<li><p>   When <code>radii="rvdw"</code>: Van der Waals radii, taken from the <code>elements</code> data set, are used.
</p>
</li>
<li><p>   When <code>radii</code> is a numeric vector: The numeric values are used to assign to each atom a radius. If <code>length(radii) != natom(pdb)</code> <code>radii</code> is recycled.
</p>
</li></ul>

</li></ul>

<p>When <code>xyz</code>, <code>abc</code> or <code>pbc.box</code> are <code>NULL</code>, the axis or pbc box are are added depending if a &lsquo;cryst1&rsquo; object can be found.<br />
Two different interactive visualization modes are avalable:
</p>

<ul>
<li><p> When <code>mode="measure"</code>: bond lengths, angles and dihedrals can be measured by <b>right-clicing</b> on the atoms.
</p>
</li>
<li><p> When <code>mode="info"</code>: atomic labels can be added to the scene by <b>right-clicing</b> on the atoms. The labels are as follow: &quot;ResidResname:EleidElename&quot;
</p>
</li></ul>

<p>When <code>mode=NULL</code> the interactive mode is disabled. To escape the interactive mode press the ESC key.
</p>


<h3>Value</h3>

<p>Return (using invisible) a two-column data.frame containing the IDs
and type indicators of the objects added to the scene.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+addXYZ">addXYZ</a></code>, <code><a href="#topic+addABC">addABC</a></code>, <code><a href="#topic+addPBCBox">addPBCBox</a></code>, <code>par3d</code>, <code>select3d</code>, <code>measure</code>, <code>info3d</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- read.pdb(system.file("examples/PCBM_ODCB.pdb", package="Rpdb"))
visualize(x, type = "l", mode = NULL)
visualize(x, type = "s", radii = "rcov", mode = NULL)
visualize(x, type = "s", radii = "rvdw", mode = NULL)
visualize(x, type = "p", mode = NULL)
visualize(subset(x, resid != 1), type = "l", mode = NULL)
visualize(subset(x, resid == 1), type = "s", add = TRUE, mode = NULL)

</code></pre>

<hr>
<h2 id='wrap'>Wrap Atomic Coordinates</h2><span id='topic+wrap'></span><span id='topic+wrap.coords'></span><span id='topic+wrap.atoms'></span><span id='topic+wrap.pdb'></span>

<h3>Description</h3>

<p>Wraps atomic coordinates using periodic boundary conditions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wrap(x, ...)

## S3 method for class 'coords'
wrap(x, cryst1 = NULL, factor = NULL, ...)

## S3 method for class 'atoms'
wrap(x, cryst1 = NULL, factor = NULL, ...)

## S3 method for class 'pdb'
wrap(x, cryst1 = x$cryst1, factor = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wrap_+3A_x">x</code></td>
<td>
<p>an R object containing atomic coordinates to be wrapped.</p>
</td></tr>
<tr><td><code id="wrap_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
<tr><td><code id="wrap_+3A_cryst1">cryst1</code></td>
<td>
<p>an object of class &lsquo;cryst1&rsquo; containing periodic boundary
conditions used for wrapping.</p>
</td></tr>
<tr><td><code id="wrap_+3A_factor">factor</code></td>
<td>
<p>a factor used to wrap the atoms by groups.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>wrap</code> function translates all atoms out of the unit cell back into
the unit cell using periodic boundary conditions. To do so, the <code>wrap</code>
function first converts Cartesian into fractional coordinates. Then atoms
with fractional coordinates greater than 1 or lower than 0 are respectively
translated by -1 or +1. Finally, if the original atomic coordinates were
Cartesian coordinates their are reconverted into Cartesian coordinates.
</p>


<h3>Value</h3>

<p>Return an object of class &lsquo;pdb&rsquo; with wrapped atomic
coordinates.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+coords">coords</a></code>, <code><a href="#topic+atoms">atoms</a></code>, <code><a href="#topic+pdb">pdb</a></code>,
<code><a href="#topic+cryst1">cryst1</a></code>, <code><a href="#topic+centres.pdb">centres.pdb</a></code>, <code><a href="#topic+xyz2abc">xyz2abc</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- read.pdb(system.file("examples/PCBM_ODCB.pdb", package="Rpdb"))

# Translation of the atoms along x-axis
x$atoms$x1 &lt;- x$atoms$x1 + 10

# Wrapping the structure
y &lt;- wrap(x)

</code></pre>

<hr>
<h2 id='write.pdb'>PDB File Writer</h2><span id='topic+write.pdb'></span>

<h3>Description</h3>

<p>Writes a Protein Data Bank (PDB) coordinate file from an object of class &lsquo;pdb&rsquo;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write.pdb(x, file = "Rpdb.pdb")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="write.pdb_+3A_x">x</code></td>
<td>
<p>an object, or a list of objects, of class &lsquo;pdb&rsquo;.</p>
</td></tr>
<tr><td><code id="write.pdb_+3A_file">file</code></td>
<td>
<p>a single element character vector containing the name of the PDB file to be created.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>All data stored in the &lsquo;pdb&rsquo; object are written to a PDB file. A list of objects of class &lsquo;pdb&rsquo; can be provided to write multiple MODEL data into a single file. In this case, each &lsquo;pdb&rsquo; object of the list must have the same <code>cryst1</code> and <code>conect</code> components.
<br />
To write only a subset of a &lsquo;pdb&rsquo; object see function <code><a href="#topic+subset.pdb">subset.pdb</a></code>.
</p>


<h3>Value</h3>

<p>No return value, called for side effects.
</p>


<h3>References</h3>

<p>PDB format is described at:
http://www.wwpdb.org/documentation/format33/v3.3.html
</p>


<h3>See Also</h3>

<p><code><a href="#topic+read.pdb">read.pdb</a></code>, <code><a href="#topic+pdb">pdb</a></code>, <code><a href="#topic+cryst1">cryst1</a></code>, <code><a href="#topic+atoms">atoms</a></code>, <code><a href="#topic+conect">conect</a></code>, <code><a href="#topic+subset.pdb">subset.pdb</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Read a PDB file included with the package
pdb &lt;- read.pdb(system.file("examples/PCBM_ODCB.pdb", package="Rpdb"))

# Write the pdb object to file "Rpdb.pdb" in the current directory
write.pdb(pdb, file = "Rpdb.pdb")

# Cleanup
unlink("Rpdb.pdb")

</code></pre>

<hr>
<h2 id='xyz2abc'>From Cartesian to Fractional Coordinates and Vice Versa</h2><span id='topic+xyz2abc'></span><span id='topic+xyz2abc.coords'></span><span id='topic+xyz2abc.atoms'></span><span id='topic+xyz2abc.pdb'></span><span id='topic+xyz2abc.distances'></span><span id='topic+abc2xyz'></span><span id='topic+abc2xyz.coords'></span><span id='topic+abc2xyz.atoms'></span><span id='topic+abc2xyz.pdb'></span><span id='topic+abc2xyz.distances'></span>

<h3>Description</h3>

<p>Converts Cartesian coordinates into fractional coordinates and vice versa.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xyz2abc(...)

## S3 method for class 'coords'
xyz2abc(x, cryst1, ...)

## S3 method for class 'atoms'
xyz2abc(x, cryst1, ...)

## S3 method for class 'pdb'
xyz2abc(x, cryst1 = x$cryst1, ...)

## S3 method for class 'distances'
xyz2abc(x, cryst1, ...)

abc2xyz(...)

## S3 method for class 'coords'
abc2xyz(x, cryst1, ...)

## S3 method for class 'atoms'
abc2xyz(x, cryst1, ...)

## S3 method for class 'pdb'
abc2xyz(x, cryst1 = x$cryst1, ...)

## S3 method for class 'distances'
abc2xyz(x, cryst1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xyz2abc_+3A_...">...</code></td>
<td>
<p>arguments passed to methods.</p>
</td></tr>
<tr><td><code id="xyz2abc_+3A_x">x</code></td>
<td>
<p>an R object containing atomic coordinates.</p>
</td></tr>
<tr><td><code id="xyz2abc_+3A_cryst1">cryst1</code></td>
<td>
<p>an object of class <code><a href="#topic+cryst1">cryst1</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For <code><a href="#topic+atoms">atoms</a></code> and <code><a href="#topic+pdb">pdb</a></code> objects, the atomic coordinates
are first extracted from <code>x</code> using the <code><a href="#topic+coords">coords</a></code> function. 
Then, using the periodic boundary conditions stored into <code>cryst1</code>, the 
coordinates are converted from Cartesian to fractional (for the 
<code>xyz2abc</code> functions) or from fractional to Cartesian (for the 
<code>abc2xyz</code> functions) coordinates. Finally, for <code><a href="#topic+atoms">atoms</a></code> and 
<code><a href="#topic+pdb">pdb</a></code> objects, the new atomic coordinates are reassigned to the 
original <code>x</code> object using the <code><a href="#topic+coords+3C-">coords&lt;-</a></code> function and 
<code>x</code> is returned.
</p>


<h3>Value</h3>

<p>Return an object of the same class as <code>x</code>, with atomic 
coordinates expressed in a different basis set.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+basis">basis</a></code>, <code><a href="#topic+coords">coords</a></code>, <code><a href="#topic+atoms">atoms</a></code>,
<code><a href="#topic+pdb">pdb</a></code>, <code><a href="#topic+cryst1">cryst1</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- read.pdb(system.file("examples/PCBM_ODCB.pdb", package="Rpdb"))
basis(x)
x &lt;- xyz2abc(x)
basis(x)
x &lt;- abc2xyz(x)
basis(x)


  
  # This example returns an error because the coordinates stored
  # into the PDB file are already Cartesian coordinates.
  x &lt;- read.pdb(system.file("examples/PCBM_ODCB.pdb", package="Rpdb"))
  try(x &lt;- abc2xyz(x))


</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
