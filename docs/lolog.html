<!DOCTYPE html><html lang="en"><head><title>Help for package lolog</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {lolog}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#+5B'><p>indexing</p></a></li>
<li><a href='#as.BinaryNet'><p>Convert to either an UndirectedNet or DirectedNet object</p></a></li>
<li><a href='#as.BinaryNet.default'><p>Convert to either an UndirectedNet or DirectedNet object</p></a></li>
<li><a href='#as.network'><p>Network conversion</p></a></li>
<li><a href='#as.network.Rcpp_DirectedNet'><p>Convert a DirectedNet to a network object</p></a></li>
<li><a href='#as.network.Rcpp_UndirectedNet'><p>Convert a UndirectedNet to a network object</p></a></li>
<li><a href='#BinaryNet'><p>BinaryNet</p></a></li>
<li><a href='#calculateStatistics'><p>Calculate network statistics from a formula</p></a></li>
<li><a href='#call-symbols'><p>Internal Symbols</p></a></li>
<li><a href='#coef.lolog'><p>Extracts estimated model coefficients.</p></a></li>
<li><a href='#createCppModel'><p>Creates a model</p></a></li>
<li><a href='#createLatentOrderLikelihood'><p>Creates a probability model for a latent ordered network model</p></a></li>
<li><a href='#gofit'><p>Conduct goodness of fit diagnostics</p></a></li>
<li><a href='#gofit.lolog'><p>Goodness of Fit Diagnostics for a LOLOG fit</p></a></li>
<li><a href='#inlineLologPlugin'><p>An lolog plug-in for easy C++ prototyping and access</p></a></li>
<li><a href='#LatentOrderLikelihood'><p>LatentOrderLikelihood</p></a></li>
<li><a href='#lazega'><p>Collaboration Relationships Among Partners at a New England Law Firm</p></a></li>
<li><a href='#lolog'><p>Fits a LOLOG model via Monte Carlo Generalized Method of Moments</p></a></li>
<li><a href='#lolog-terms'><p>LOLOG Model Terms</p></a></li>
<li><a href='#LologModels'><p>Models</p></a></li>
<li><a href='#lologPackageSkeleton'><p>Create a skeleton for a package extending lolog</p></a></li>
<li><a href='#lologVariational'><p>Fits a latent ordered network model using Monte Carlo variational inference</p></a></li>
<li><a href='#plot.gofit'><p>Plots a gofit object</p></a></li>
<li><a href='#plot.lologGmm'><p>Conduct Monte Carlo diagnostics on a lolog model fit</p></a></li>
<li><a href='#plot.Rcpp_DirectedNet'><p>plot an DirectedNet object</p></a></li>
<li><a href='#plot.Rcpp_UndirectedNet'><p>Plot an UndirectedNet object</p></a></li>
<li><a href='#print.gofit'><p>prints a gofit object</p></a></li>
<li><a href='#print.lolog'><p>Print a 'lolog' object</p></a></li>
<li><a href='#print.lologVariationalFit'><p>Print of a lologVariationalFit object</p></a></li>
<li><a href='#registerDirectedStatistic'><p>Register Statistics</p></a></li>
<li><a href='#simulate.lolog'><p>Generates BinaryNetworks from a fit lolog object</p></a></li>
<li><a href='#summary.lolog'><p>Summary of a 'lolog' object</p></a></li>
<li><a href='#ukFaculty'><p>Friendship network of a UK university faculty</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Maintainer:</td>
<td>Ian E. Fellows &lt;ian@fellstat.com&gt;</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENCE</td>
</tr>
<tr>
<td>Title:</td>
<td>Latent Order Logistic Graph Models</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, BH</td>
</tr>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>Description:</td>
<td>Estimation of Latent Order Logistic (LOLOG) Models for Networks.
    LOLOGs are a flexible and fully general class of statistical graph models. 
    This package provides functions for performing MOM, GMM and variational 
    inference. Visual diagnostics and goodness of fit metrics are provided. 
    See Fellows (2018) &lt;<a href="https://doi.org/10.48550/arXiv.1804.04583">doi:10.48550/arXiv.1804.04583</a>&gt; for a detailed description of the methods.</td>
</tr>
<tr>
<td>Version:</td>
<td>1.3.1</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.0.0), methods, Rcpp (&ge; 0.9.4)</td>
</tr>
<tr>
<td>Imports:</td>
<td>network, parallel, ggplot2, reshape2, intergraph, Matrix</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, inline, knitr, rmarkdown, ergm, BH, igraph</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/statnet/lolog">https://github.com/statnet/lolog</a></td>
</tr>
<tr>
<td>RcppModules:</td>
<td>lolog</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.2</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-12-05 17:29:48 UTC; ianfellows</td>
</tr>
<tr>
<td>Author:</td>
<td>Ian E. Fellows [aut, cre],
  Mark S. Handcock [ctb]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-12-07 12:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='+5B'>indexing</h2><span id='topic++5B'></span><span id='topic++5B+2CRcpp_DirectedNet-method'></span><span id='topic++5B+2CRcpp_DirectedNet+2CANY+2CANY+2CANY-method'></span><span id='topic++5CS4method+7B+5B+7D+7BRcpp_DirectedNet+2CANY+2CANY+2CANY+7D'></span><span id='topic++5B+2CRcpp_UndirectedNet-method'></span><span id='topic++5B+2CRcpp_UndirectedNet+2CANY+2CANY+2CANY-method'></span><span id='topic++5CS4method+7B+5B+7D+7BRcpp_UndirectedNet+2CANY+2CANY+2CANY+7D'></span><span id='topic++5B+3C-'></span><span id='topic++5B+3C-+2CRcpp_DirectedNet-method'></span><span id='topic++5B+3C-+2CRcpp_DirectedNet+2CANY+2CANY+2CANY-method'></span><span id='topic++5CS4method+7B+5B+3C-+7D+7BRcpp_DirectedNet+2CANY+2CANY+2CANY+7D'></span><span id='topic++5B+3C-+2CRcpp_UndirectedNet-method'></span><span id='topic++5B+3C-+2CRcpp_UndirectedNet+2CANY+2CANY+2CANY-method'></span><span id='topic++5CS4method+7B+5B+3C-+7D+7BRcpp_UndirectedNet+2CANY+2CANY+2CANY+7D'></span>

<h3>Description</h3>

<p>indexing
</p>
<p>indexing
</p>
<p>indexing
</p>
<p>indexing
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Rcpp_DirectedNet,ANY,ANY,ANY'
x[i, j, ..., maskMissing = TRUE, drop = TRUE]

## S4 method for signature 'Rcpp_UndirectedNet,ANY,ANY,ANY'
x[i, j, ..., maskMissing = TRUE, drop = TRUE]

## S4 replacement method for signature 'Rcpp_DirectedNet,ANY,ANY,ANY'
x[i, j, ...] &lt;- value

## S4 replacement method for signature 'Rcpp_UndirectedNet,ANY,ANY,ANY'
x[i, j, ...] &lt;- value
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="+2B5B_+3A_x">x</code></td>
<td>
<p>object</p>
</td></tr>
<tr><td><code id="+2B5B_+3A_i">i</code></td>
<td>
<p>indices</p>
</td></tr>
<tr><td><code id="+2B5B_+3A_j">j</code></td>
<td>
<p>indices</p>
</td></tr>
<tr><td><code id="+2B5B_+3A_...">...</code></td>
<td>
<p>unused</p>
</td></tr>
<tr><td><code id="+2B5B_+3A_maskmissing">maskMissing</code></td>
<td>
<p>should missing values be masked by NA</p>
</td></tr>
<tr><td><code id="+2B5B_+3A_drop">drop</code></td>
<td>
<p>unused</p>
</td></tr>
<tr><td><code id="+2B5B_+3A_value">value</code></td>
<td>
<p>values to assign</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(ukFaculty)
net &lt;- as.BinaryNet(ukFaculty)


#dyad Extraction
net[1:2,1:5]
net$outNeighbors(c(1,2,3))

#dyad assignment
net[1,1:5] &lt;- rep(NA,5)
net[1:2,1:5]
net[1:2,1:5,maskMissing=FALSE] #remove the mask over missing values and see
#nothing was really changed

#node variables
net$variableNames()
net[["Group"]]
net[["rnorm"]] &lt;- rnorm(net$size())
net[["rnorm"]]
</code></pre>

<hr>
<h2 id='as.BinaryNet'>Convert to either an UndirectedNet or DirectedNet object</h2><span id='topic+as.BinaryNet'></span>

<h3>Description</h3>

<p>Convert to either an UndirectedNet or DirectedNet object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.BinaryNet(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as.BinaryNet_+3A_x">x</code></td>
<td>
<p>the object</p>
</td></tr>
<tr><td><code id="as.BinaryNet_+3A_...">...</code></td>
<td>
<p>unused</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Converts network objects to BinaryNets. This function also converts
other graph formats, such as igraph and tidygraph, utilizing
intergraph::asNetwork.
</p>


<h3>Value</h3>

<p>either an Rcpp_UndirectedNet or Rcpp_DirectedNet object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ukFaculty)
net &lt;- as.BinaryNet(ukFaculty)
net
</code></pre>

<hr>
<h2 id='as.BinaryNet.default'>Convert to either an UndirectedNet or DirectedNet object</h2><span id='topic+as.BinaryNet.default'></span>

<h3>Description</h3>

<p>Convert to either an UndirectedNet or DirectedNet object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## Default S3 method:
as.BinaryNet(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as.BinaryNet.default_+3A_x">x</code></td>
<td>
<p>the object</p>
</td></tr>
<tr><td><code id="as.BinaryNet.default_+3A_...">...</code></td>
<td>
<p>unused</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Converts network objects to BinaryNets. This function also converts
other graph formats, such as igraph and tidygraph, utilizing
intergraph::asNetwork.
</p>


<h3>Value</h3>

<p>either an Rcpp_UndirectedNet or Rcpp_DirectedNet object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ukFaculty)
net &lt;- as.BinaryNet(ukFaculty)
net
</code></pre>

<hr>
<h2 id='as.network'>Network conversion</h2><span id='topic+as.network'></span>

<h3>Description</h3>

<p>Network conversion
</p>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as.network_+3A_x">x</code></td>
<td>
<p>The object</p>
</td></tr>
<tr><td><code id="as.network_+3A_...">...</code></td>
<td>
<p>Additional parameters</p>
</td></tr>
</table>

<hr>
<h2 id='as.network.Rcpp_DirectedNet'>Convert a DirectedNet to a network object</h2><span id='topic+as.network.Rcpp_DirectedNet'></span>

<h3>Description</h3>

<p>Convert a DirectedNet to a network object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Rcpp_DirectedNet'
as.network(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as.network.Rcpp_DirectedNet_+3A_x">x</code></td>
<td>
<p>the object</p>
</td></tr>
<tr><td><code id="as.network.Rcpp_DirectedNet_+3A_...">...</code></td>
<td>
<p>unused</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A network object
</p>


<h3>See Also</h3>

<p><code><a href="#topic+DirectedNet">DirectedNet</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>el &lt;- matrix(c(1,2),ncol=2)

#make an UndirectedNet with one edge and 5 nodes
net &lt;- new(UndirectedNet, el, 5L)

nw &lt;- as.network(net)
nw
</code></pre>

<hr>
<h2 id='as.network.Rcpp_UndirectedNet'>Convert a UndirectedNet to a network object</h2><span id='topic+as.network.Rcpp_UndirectedNet'></span>

<h3>Description</h3>

<p>Convert a UndirectedNet to a network object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Rcpp_UndirectedNet'
as.network(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as.network.Rcpp_UndirectedNet_+3A_x">x</code></td>
<td>
<p>the object</p>
</td></tr>
<tr><td><code id="as.network.Rcpp_UndirectedNet_+3A_...">...</code></td>
<td>
<p>unused</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A network object
</p>


<h3>See Also</h3>

<p><code><a href="#topic+UndirectedNet">UndirectedNet</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>el &lt;- matrix(c(1,2),ncol=2)

#make an UndirectedNet with one edge and 5 nodes
net &lt;- new(UndirectedNet, el, 5L)
net[1:5,1:5]

nw &lt;- as.network(net)
nw
</code></pre>

<hr>
<h2 id='BinaryNet'>BinaryNet</h2><span id='topic+BinaryNet'></span><span id='topic+DirectedNet'></span><span id='topic+UndirectedNet'></span><span id='topic+Rcpp_DirectedNet-class'></span><span id='topic+Rcpp_UndirectedNet-class'></span>

<h3>Description</h3>

<p>BinaryNet
</p>


<h3>Details</h3>

<p>Rcpp_DirectedNet and Rcpp_UndirectedNet are the native network classes for the
lolog package. They are designed for algorithmic performance, and are thin wrappers
for an underlying C++ object. These network objects can be passed back and forth between
R and C++ with little overhead. Because they are pointers to C++ objects, serialization
via 'save' or 'dput' are not supported
</p>

<hr>
<h2 id='calculateStatistics'>Calculate network statistics from a formula</h2><span id='topic+calculateStatistics'></span>

<h3>Description</h3>

<p>Calculate network statistics from a formula
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculateStatistics(formula)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calculateStatistics_+3A_formula">formula</code></td>
<td>
<p>A lolog formula (See <code><a href="#topic+lolog">lolog</a></code>).</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(ukFaculty)
calculateStatistics(ukFaculty ~ edges + mutual + triangles)
</code></pre>

<hr>
<h2 id='call-symbols'>Internal Symbols</h2><span id='topic+call-symbols'></span><span id='topic+_lolog_initStats'></span><span id='topic+_rcpp_module_boot_lolog'></span><span id='topic+initLologStatistics'></span><span id='topic+runLologCppTests'></span>

<h3>Description</h3>

<p>Internal symbols used to access compiles code.
</p>

<hr>
<h2 id='coef.lolog'>Extracts estimated model coefficients.</h2><span id='topic+coef.lolog'></span>

<h3>Description</h3>

<p>Extracts estimated model coefficients.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lolog'
coef(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="coef.lolog_+3A_object">object</code></td>
<td>
<p>A 'lolog' object.</p>
</td></tr>
<tr><td><code id="coef.lolog_+3A_...">...</code></td>
<td>
<p>unused</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># Extract parameter estimates as a numeric vector:
data(ukFaculty)
fit &lt;- lolog(ukFaculty ~ edges)
coef(fit)
</code></pre>

<hr>
<h2 id='createCppModel'>Creates a model</h2><span id='topic+createCppModel'></span>

<h3>Description</h3>

<p>Creates a model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>createCppModel(formula, cloneNet = TRUE, theta = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="createCppModel_+3A_formula">formula</code></td>
<td>
<p>the model formula</p>
</td></tr>
<tr><td><code id="createCppModel_+3A_clonenet">cloneNet</code></td>
<td>
<p>create a deep copy of the network within the model object</p>
</td></tr>
<tr><td><code id="createCppModel_+3A_theta">theta</code></td>
<td>
<p>the model parameters.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Creates a C++ Model object. In general this isn't needed by most users of the
package.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ukFaculty)
model &lt;- createCppModel(ukFaculty ~ edges)
model$calculate()
model$statistics()
</code></pre>

<hr>
<h2 id='createLatentOrderLikelihood'>Creates a probability model for a latent ordered network model</h2><span id='topic+createLatentOrderLikelihood'></span>

<h3>Description</h3>

<p>Creates a probability model for a latent ordered network model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>createLatentOrderLikelihood(formula, theta = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="createLatentOrderLikelihood_+3A_formula">formula</code></td>
<td>
<p>A LOLOG formula. See <code>link{lolog}</code></p>
</td></tr>
<tr><td><code id="createLatentOrderLikelihood_+3A_theta">theta</code></td>
<td>
<p>Parameter values.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An Rcpp object representing the likelihood model
</p>


<h3>Examples</h3>

<pre><code class='language-R'># See the methods of the objects returned by this function
UndirectedLatentOrderLikelihood
DirectedLatentOrderLikelihood

# A Barabasi-Albert type graph model with 1000 vertices
el &lt;- matrix(0, nrow=0, ncol=2)
net &lt;- new(UndirectedNet, el, 1000L)
lolik &lt;- createLatentOrderLikelihood(net ~ preferentialAttachment(), theta=1)
banet &lt;- lolik$generateNetwork()$network # generate a random network from the model
degrees &lt;- banet$degree(1:1000)
hist(degrees, breaks=100) # plot the degree distribution
order &lt;- banet[["__order__"]] # The vertex inclusion order

# Earlier nodes have higher degrees
library(ggplot2)
qplot(order, degrees, alpha=I(.25)) + geom_smooth(method="loess")

</code></pre>

<hr>
<h2 id='gofit'>Conduct goodness of fit diagnostics</h2><span id='topic+gofit'></span>

<h3>Description</h3>

<p>Conduct goodness of fit diagnostics
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gofit(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gofit_+3A_object">object</code></td>
<td>
<p>the object to evaluate</p>
</td></tr>
<tr><td><code id="gofit_+3A_...">...</code></td>
<td>
<p>additional parameters</p>
</td></tr>
</table>


<h3>Details</h3>

<p>see <code><a href="#topic+gofit.lolog">gofit.lolog</a></code>
</p>

<hr>
<h2 id='gofit.lolog'>Goodness of Fit Diagnostics for a LOLOG fit</h2><span id='topic+gofit.lolog'></span>

<h3>Description</h3>

<p>Goodness of Fit Diagnostics for a LOLOG fit
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lolog'
gofit(object, formula, nsim = 100, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gofit.lolog_+3A_object">object</code></td>
<td>
<p>the object to evaluate</p>
</td></tr>
<tr><td><code id="gofit.lolog_+3A_formula">formula</code></td>
<td>
<p>A formula specifying the statistics on which to evaluate the fit</p>
</td></tr>
<tr><td><code id="gofit.lolog_+3A_nsim">nsim</code></td>
<td>
<p>The number of simulated statistics</p>
</td></tr>
<tr><td><code id="gofit.lolog_+3A_...">...</code></td>
<td>
<p>additional parameters</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>library(network)
data(ukFaculty)

# Delete vertices missing group
delete.vertices(ukFaculty, which(is.na(ukFaculty %v% "Group")))

# A dyad independent model
fitind &lt;- lolog(ukFaculty ~ edges() + nodeMatch("GroupC") + nodeCov("GroupC"))
summary(fitind)

# Check gof on degree distribution (bad!)
gind &lt;- gofit(fitind, ukFaculty ~ degree(0:50))
gind
plot(gind)

#check gof on esp distribution (bad!)
gind &lt;- gofit(fitind, ukFaculty ~ esp(0:25))
gind
plot(gind)

## Not run: 

#include triangles and 2-stars (in and out)
fitdep &lt;- lolog(ukFaculty ~ edges() + nodeMatch("GroupC") + nodeCov("GroupC") + 
                triangles + star(2, direction="in") + star(2, direction="out"), nsamp=1500)
summary(fitdep)

# Check gof on (in + out) degree distribution (good!)
gdep &lt;- gofit(fitdep, ukFaculty ~ degree(0:50))
gdep
plot(gdep)

#check gof on esp distribution (good!)
gdep &lt;- gofit(fitdep, ukFaculty ~ esp(0:25))
gdep
plot(gdep)


## End(Not run)


</code></pre>

<hr>
<h2 id='inlineLologPlugin'>An lolog plug-in for easy C++ prototyping and access</h2><span id='topic+inlineLologPlugin'></span>

<h3>Description</h3>

<p>An lolog plug-in for easy C++ prototyping and access
</p>
<p>The inline plug-in for lolog
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inlineLologPlugin(...)

inlineLologPlugin
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="inlineLologPlugin_+3A_...">...</code></td>
<td>
<p>plug-in arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The lolog Rcpp plugin allows for the rapid prototyping of compiled code.
new functions can be registered and exposed using <code><a href="Rcpp.html#topic+cppFunction">cppFunction</a></code>
and new statistics can be compiled and registered using <code><a href="Rcpp.html#topic+sourceCpp">sourceCpp</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="Rcpp.html#topic+cppFunction">cppFunction</a></code>, <code><a href="Rcpp.html#topic+sourceCpp">sourceCpp</a></code>, <code><a href="Rcpp.html#topic+cppFunction">cppFunction</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# This creates a function in C++ to create an empty network of size n
# and expose it to R.
src &lt;- "
lolog::BinaryNet&lt;lolog::Directed&gt; makeEmptyNetwork(const int n){
Rcpp::IntegerMatrix tmp(0,2);
lolog::BinaryNet&lt;lolog::Directed&gt; net(tmp, n);
return net;
}
"
Rcpp::registerPlugin("lolog",inlineLologPlugin)
emptyNetwork &lt;- cppFunction(src,plugin="lolog")
net &lt;- emptyNetwork(10L)
net[1:10,1:10]


## End(Not run)
</code></pre>

<hr>
<h2 id='LatentOrderLikelihood'>LatentOrderLikelihood</h2><span id='topic+LatentOrderLikelihood'></span><span id='topic+DirectedLatentOrderLikelihood'></span><span id='topic+UndirectedLatentOrderLikelihood'></span><span id='topic+Rcpp_DirectedLatentOrderLikelihood-class'></span><span id='topic+Rcpp_UndirectedLatentOrderLikelihood-class'></span>

<h3>Description</h3>

<p>LatentOrderLikelihood
</p>

<hr>
<h2 id='lazega'>Collaboration Relationships Among Partners at a New England Law Firm</h2><span id='topic+lazega'></span>

<h3>Description</h3>

<p>This data set comes from a network study of corporate law partnership that was 
carried out in a Northeastern US corporate law firm, referred to as SG&amp;R, 1988-1991 
in New England.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(lazega)
</code></pre>


<h3>Licenses and Citation</h3>

<p>CC BY 4.0. When publishing results obtained using this
data set, the original authors (Lazega, 2001)
should be cited, along with this <code>R</code> package.
</p>


<h3>Copyright</h3>

<p>Creative Commons Attribution-Share Alike 4.0 International License, 
see https://creativecommons.org/licenses/by/4.0/ for details.
</p>


<h3>Source</h3>

<p>See <a href="http://elazega.fr/?page_id=609">http://elazega.fr/?page_id=609</a> and <a href="https://www.stats.ox.ac.uk/~snijders/siena/Lazega_lawyers_data.htm">https://www.stats.ox.ac.uk/~snijders/siena/Lazega_lawyers_data.htm</a>
</p>


<h3>References</h3>

<p>Lazega, Emmanuel (2001), The Collegial Phenomenon: The Social Mechanisms of Cooperation 
among Peers in a Corporate Law Partnership, Oxford: Oxford University Press
</p>

<hr>
<h2 id='lolog'>Fits a LOLOG model via Monte Carlo Generalized Method of Moments</h2><span id='topic+lolog'></span>

<h3>Description</h3>

<p><code>lolog</code> is used to fit Latent Order Logistic Graph (LOLOG) models. LOLOG models are
motivated by the idea of network growth where the network begins empty, and edge variables
are sequentially 'added' to the network with an either unobserved, or partially observed
order <code class="reqn">s</code>. Conditional upon the inclusion order, the probability of an edge has a
logistic relationship with the change in network statistics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lolog(
  formula,
  auxFormula = NULL,
  theta = NULL,
  nsamp = 1000,
  includeOrderIndependent = TRUE,
  targetStats = NULL,
  weights = "full",
  tol = 0.1,
  nHalfSteps = 10,
  maxIter = 100,
  minIter = 2,
  startingStepSize = 0.1,
  maxStepSize = 0.5,
  cluster = NULL,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lolog_+3A_formula">formula</code></td>
<td>
<p>A lolog formula for the sufficient statistics (see details).</p>
</td></tr>
<tr><td><code id="lolog_+3A_auxformula">auxFormula</code></td>
<td>
<p>A lolog formula of statistics to use for moment matching.</p>
</td></tr>
<tr><td><code id="lolog_+3A_theta">theta</code></td>
<td>
<p>Initial parameters values. Estimated via <code><a href="#topic+lologVariational">lologVariational</a></code> if NULL.</p>
</td></tr>
<tr><td><code id="lolog_+3A_nsamp">nsamp</code></td>
<td>
<p>The number of sample networks to draw at each iteration.</p>
</td></tr>
<tr><td><code id="lolog_+3A_includeorderindependent">includeOrderIndependent</code></td>
<td>
<p>If TRUE, all order independent terms in formula are used for 
moment matching.</p>
</td></tr>
<tr><td><code id="lolog_+3A_targetstats">targetStats</code></td>
<td>
<p>A vector of network statistics to use as the target for the moment equations.
If <code>NULL</code>, the observed statistics for the network are used.</p>
</td></tr>
<tr><td><code id="lolog_+3A_weights">weights</code></td>
<td>
<p>The type of weights to use in the GMM objective. Either 'full' for the inverse 
of the full covariance matrix or 'diagonal' for the inverse of the diagonal of the covariance matrix.</p>
</td></tr>
<tr><td><code id="lolog_+3A_tol">tol</code></td>
<td>
<p>The Hotelling's T^2 p-value tolerance for convergence for the transformed moment conditions.</p>
</td></tr>
<tr><td><code id="lolog_+3A_nhalfsteps">nHalfSteps</code></td>
<td>
<p>The maximum number of half steps to take when the objective is not improved 
in an iteration.</p>
</td></tr>
<tr><td><code id="lolog_+3A_maxiter">maxIter</code></td>
<td>
<p>The maximum number of iterations.</p>
</td></tr>
<tr><td><code id="lolog_+3A_miniter">minIter</code></td>
<td>
<p>The minimum number of iterations.</p>
</td></tr>
<tr><td><code id="lolog_+3A_startingstepsize">startingStepSize</code></td>
<td>
<p>The starting dampening of the parameter update.</p>
</td></tr>
<tr><td><code id="lolog_+3A_maxstepsize">maxStepSize</code></td>
<td>
<p>The largest allowed value for dampening.</p>
</td></tr>
<tr><td><code id="lolog_+3A_cluster">cluster</code></td>
<td>
<p>A parallel cluster to use for graph simulation.</p>
</td></tr>
<tr><td><code id="lolog_+3A_verbose">verbose</code></td>
<td>
<p>Level of verbosity 0-3.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>LOLOG represents the probability of a tie, given the network grown up to a time point as
</p>
<p style="text-align: center;"><code class="reqn">
  \textrm{logit}\big(p(y_{s_t}=1 | \eta, y^{t-1}, s_{ \leq t})\big) = \theta \cdot c(y_{s_t}=1 | y^{t-1}, s_{ \leq t})
</code>
</p>

<p>where <code class="reqn">s_{\leq t}</code> is the growth order of the network up to time <code class="reqn">t</code>, <code class="reqn">y^{t-1}</code> is the
state of the graph at time <code class="reqn">t-1</code>. <code class="reqn">c(y_{s_t} | y^{t-1}, s_{ \leq t})</code> is a vector
representing the change in graph statistics from time <code class="reqn">t-1</code> to <code class="reqn">t</code> if an edge is present, and
<code class="reqn">\theta</code> is a vector of parameters.
</p>
<p>The motivating growth order proceeds 'by vertex.' The network begins 'empty' and then vertices are 'added'
to the network sequentially. The order of vertex inclusion may be random or fixed. When a vertex 'enters' the
network, each of the edge variables connecting it and vertices already in the network are considered for
edge creation in a completely random order.
</p>
<p>LOLOG formulas contain a network, DirectedNet or UndirectedNet object on the left hand side.
the right hand side contains the model terms used. for example,
</p>
<p><code>net ~ edges</code>
</p>
<p>represents and Erdos-Renyi model and
</p>
<p><code>net ~ edges + preferentialAttachment()</code>
</p>
<p>represents a Barabasi-Albert model. See <code><a href="#topic+lolog-terms">lolog-terms</a></code> for a list of allowed model statistics
</p>
<p>Conditioning on (partial) vertex order can be done by
placing an ordering variable on the right hand side of the '|' operator, as in
</p>
<p><code>net ~ edges + preferentialAttachment() | order</code>
</p>
<p>'order' should be a numeric vector with as many elements as there are vertices in the network.
Ties are allowed. Vertices with higher order values will always be included later. Those with the same
values will be included in a random order in each simulated network.
</p>
<p>offsets and constraints are specified by wrapping them with either <code>offset()</code> or <code>constraint()</code>,
for example, the following specifies an Erdos-Renyi model with the constraint that degrees must be less
that 10
</p>
<p><code>net ~ edges + constraint(boundedDegree(0L, 10L))</code>
</p>
<p>If the model contains any order dependent statistics, additional moment constraints
must be specified in <code>auxFormula</code>. Ideally these should be chosen to capture
the features modeled by the order dependent statistics. For example, <code>preferentialAttachment</code>
models the degree structure, so we might choose two-stars as a moment constraint.
</p>
<p><code>lolog(net ~ edges + preferentialAttachment(), net ~ star(2))</code>
</p>
<p>will fit a Barabasi-Albert model with the number of edges and number of two-stars as moment constraints.
</p>


<h3>Value</h3>

<p>An object of class 'lolog'. If the model is dyad independent, the returned object will
also be of class &quot;lologVariational&quot; (see <code><a href="#topic+lologVariational">lologVariational</a></code>, otherwise it will
also be a &quot;lologGmm&quot; object.
</p>
<p>lologGmm objects contain:
</p>
<table role = "presentation">
<tr><td><code>method</code></td>
<td>
<p>&quot;Method of Moments&quot; for order independent models, otherwise &quot;Generalized Method of Moments&quot;</p>
</td></tr>
<tr><td><code>formula</code></td>
<td>
<p>The model formula</p>
</td></tr>
<tr><td><code>auxFormula</code></td>
<td>
<p>The formula containing additional moment conditions</p>
</td></tr>
<tr><td><code>theta</code></td>
<td>
<p>The parameter estimates</p>
</td></tr>
<tr><td><code>stats</code></td>
<td>
<p>The statistics for each network in the last iteration</p>
</td></tr>
<tr><td><code>estats</code></td>
<td>
<p>The expected stats (G(y,s)) for each network in the last iteration</p>
</td></tr>
<tr><td><code>obsStats</code></td>
<td>
<p>The observed h(y) network statistics</p>
</td></tr>
<tr><td><code>targetStats</code></td>
<td>
<p>The target network statistics</p>
</td></tr>
<tr><td><code>obsModelStats</code></td>
<td>
<p>The observed g(y,s) network statistics</p>
</td></tr>
<tr><td><code>net</code></td>
<td>
<p>A network simulated from the fit model</p>
</td></tr>
<tr><td><code>grad</code></td>
<td>
<p>The gradient of the moment conditions (D)</p>
</td></tr>
<tr><td><code>vcov</code></td>
<td>
<p>The asymptotic covariance matrix of the parameter estimates</p>
</td></tr>
<tr><td><code>likelihoodModel</code></td>
<td>
<p>An object of class *LatentOrderLikelihood at the fit parameters</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>library(network)
set.seed(1)
data(flo)
flomarriage &lt;- network(flo,directed=FALSE)
flomarriage %v% "wealth" &lt;- c(10,36,27,146,55,44,20,8,42,103,48,49,10,48,32,3)

# A dyad independent model
fit &lt;- lolog(flomarriage ~ edges + nodeCov("wealth"))
summary(fit)

# A dyad dependent model with 2-stars and triangles
fit2 &lt;- lolog(flomarriage ~ edges + nodeCov("wealth") + star(2) + triangles, verbose=FALSE)
summary(fit2)

## Not run: 

# An order dependent model
fit3 &lt;- lolog(flomarriage ~ edges + nodeCov("wealth") + preferentialAttachment(),
              flomarriage ~ star(2:3), verbose=FALSE)
summary(fit3)

# Try something a bit more real
data(ukFaculty)

# Delete vertices missing group
delete.vertices(ukFaculty, which(is.na(ukFaculty %v% "Group")))

fituk &lt;- lolog(ukFaculty ~ edges() + nodeMatch("GroupC") + nodeCov("GroupC") + triangles + star(2))
summary(fituk)
plot(fituk$net, vertex.col= ukFaculty %v% "Group" + 2)


## End(Not run)

</code></pre>

<hr>
<h2 id='lolog-terms'>LOLOG Model Terms</h2><span id='topic+lolog-terms'></span>

<h3>Description</h3>

<p>LOLOG Model Terms
</p>


<h3>Statistic Descriptions</h3>


<dl>
<dt><code>edges</code>  (dyad-independent)  (order-independent)  (directed)  (undirected)</dt><dd> 
<p><em>Edges:</em> This term adds one network statistic equal to the number of edges 
(i.e. nonzero values) in the network. </p>
</dd>
<dt><code> star(k, direction="in")  </code> (order-independent) (directed)  (undirected)</dt><dd> 
<p>The <code>k</code> argument is a vector of distinct integers. 
This term adds one network statistic to the model for each element in <code>k</code>. 
The <code class="reqn">i</code>th such statistic counts the number of distinct <code>k[i]</code>-stars in the network, 
where a <code class="reqn">k</code>-star is defined to be a node <code class="reqn">N</code> and a set of <code class="reqn">k</code> different nodes 
<code class="reqn">\{O_1, \dots, O_k\}</code> such that the ties <code class="reqn">\{N, O_i\}</code> exist for <code class="reqn">i=1, \dots, k</code>. 
For directed networks, direction indicates whether the count is of in-stars (direction=&quot;in&quot;) 
or out-stars (direction=&quot;out&quot;)</p>
</dd>
<dt><code>triangles()</code> (order-independent) (directed)  (undirected)</dt><dd> 
<p>This term adds one statistic to the model equal to the number of triangles
in the network. For an undirected network, a triangle is defined to be any
set <code class="reqn">\{(i,j), (j,k), (k,i)\}</code> of three edges. For a directed network, a
triangle is defined as any set of three edges <code class="reqn">(i{\rightarrow}j)</code>
and <code class="reqn">(j{\rightarrow}k)</code> and either <code class="reqn">(k{\rightarrow}i)</code>
or <code class="reqn">(k{\leftarrow}i)</code>. </p>
</dd>
<dt><code>clustering()</code>  (order-independent) (undirected)</dt><dd> 
<p>The global clustering coefficient, defined as the number of triangles over the
number of possible triangles <a href="https://en.wikipedia.org/wiki/Clustering_coefficient">https://en.wikipedia.org/wiki/Clustering_coefficient</a>, or
3 * triangles / 2-stars.
</p>
</dd>
<dt><code>transitivity()</code>  (order-independent) (undirected)</dt><dd> 
<p>The Soffer-Vazquez   transitivity. This is clustering metric that adjusts for large degree
differences and is described by C in Equation 6 of #' <a href="https://pubmed.ncbi.nlm.nih.gov/16089694/">https://pubmed.ncbi.nlm.nih.gov/16089694/</a>. Note 
The approximation of the number of possible shared neighbors between node i and j of min(d_i,d_j) - 1
in this implementation.
</p>
</dd>
<dt><code> mutual() </code> (order-independent) (directed)</dt><dd><p> A count of the number of pairs of actors 
<code class="reqn">i</code> and <code class="reqn">j</code> for which <code class="reqn">(i{\rightarrow}j)</code> and <code class="reqn">(j{\rightarrow}i)</code> 
both exist. 
</p>
</dd>
<dt><code> nodeMatch(name) </code> (dyad-independent)  (order-independent)  (directed)  (undirected)</dt><dd> 
<p>For categorical network nodal variable 'name,' the number of edges between nodes with the same 
variable value.
</p>
</dd>
<dt><code> nodeMix(name) </code> (dyad-independent)  (order-independent)  (directed)  (undirected)</dt><dd> 
<p>For categorical network nodal variable 'name,' adds one statistic for each combination of levels of the
variable equal to the count of edges between those levels.
</p>
</dd>
<dt><code> degree(d, direction="undirected", lessThanOrEqual=FALSE) </code> (order-independent)  (directed)  
(undirected)</dt><dd> 
<p>The <code>d</code> argument is a vector of distinct integers. This term adds one
network statistic to the model for each element in <code>d</code>; the <code class="reqn">i</code>th
such statistic equals the number of nodes in the network of degree
<code>d[i]</code>, i.e. with exactly <code>d[i]</code> edges.
For directed networks if direction=&quot;undirected&quot;
degree is counted as the sum of the in and out degrees of a node. If direction=&quot;in&quot; then in-degrees are
used and direction=&quot;out&quot; indicates out-degrees.
</p>
<p>If lessThanOrEqual=TRUE, then the count is the number of nodes with degree less than or equal to d.
</p>
</dd>
<dt><code>twoPath</code> (order-independent) (directed)  (undirected)</dt><dd>
<p>This term adds one statistic to the model, equal to the number of 2-paths in
the network. For a directed network this is defined as a pair of edges
<code class="reqn">(i{\rightarrow}j), (j{\rightarrow}k)</code>, where <code class="reqn">i</code> and
<code class="reqn">j</code> must be distinct. That is, it is a directed path of length 2 from
<code class="reqn">i</code> to <code class="reqn">k</code> via <code class="reqn">j</code>. For directed networks a 2-path is also a
mixed 2-star.
For undirected networks a twopath is defined as a pair of edges
<code class="reqn">\{i,j\}, \{j,k\}</code>. That is, it is an undirected path of length 2 from
<code class="reqn">i</code> to <code class="reqn">k</code> via <code class="reqn">j</code>, also known as a 2-star.</p>
</dd>
<dt><code> degreeCrossProd() (order-independent)  (undirected) </code></dt><dd> 
<p>This term adds one network statistic equal to the mean of the cross-products
of the degrees of all pairs of nodes in the network which are tied.
</p>
</dd>
<dt><code> nodeCov(name) </code> (dyad-independent)  (order-independent)  (directed)  (undirected)</dt><dd> 
<p>The <code>name</code> argument is a character string giving the name of a
numeric attribute in the network's vertex attribute list.
This term adds a single network statistic to the model equaling the sum of
<code>name(i)</code> and <code>name(j)</code> for all edges <code class="reqn">(i,j)</code> in the
network. For categorical variables, levels are coded as 1,..,nlevels'.
</p>
</dd>
<dt><code> edgeCov(x, name=NULL) </code> (dyad-independent)  (order-independent)  (directed)  (undirected)</dt><dd> 
<p>The <code>x</code> argument is a square matrix of covariates, one for each possible edge in the network.
This term adds one statistic to the model, equal to the sum
of the covariate values for each edge appearing in the network. The
<code>edgeCov</code> term applies to both directed and undirected networks. For
undirected networks the covariates are also assumed to be undirected.
If present, the <code>name</code> argument is a character string providing a
name for the <code>edgeCov</code> term. The name will be &quot;edgeCov.&lt;name&gt;&quot;. It is
recommended that all <code>edgeCov</code> terms be given explicit names. In particular,
if two unnamed <code>edgeCov</code> terms are supplied an error will occur (as they will
have the same default name &quot;edgeCov.&quot;.
</p>
</dd>
<dt><code> edgeCovSparse(x, name=NULL) </code> (dyad-independent)  (order-independent)  (directed)  (undirected)</dt><dd> 
<p>Identical to edgeCov, except <code>x</code> should be a sparse matrix. This is especially useful for larger networks,
where passing a dense matrix to <code>edgeCov</code> is too memory intensive. 
</p>
</dd>
<dt><code>gwesp(alpha)</code>  (order-independent)  (directed)  (undirected)</dt><dd> 
<p>This term is just like <code>gwdsp</code> except it adds a statistic equal to the
geometrically weighted <em>edgewise</em> (not dyadwise) shared partner
distribution with decay parameter
<code>alpha</code> parameter, which should be non-negative.
</p>
</dd>
<dt><code> gwdegree(alpha, direction="undirected") </code>  (order-independent)  (directed)  (undirected)</dt><dd> 
<p>This term adds one network statistic to the model equal to the weighted
degree distribution with decay controlled by the <code>decay</code> parameter.
The <code>alpha</code> parameter is the same as theta_s in equation (14) in Hunter (2007).
</p>
<p>For directed networks if direction=&quot;undirected&quot; degree is counted as the sum of the in and 
out degrees of a node. If direction=&quot;in&quot; then in-degrees are used ans direction=&quot;out&quot; 
indicates out-degrees.
</p>
</dd>
<dt><code> gwdsp(alpha) </code> (order-independent)  (directed)  (undirected)</dt><dd> 
<p>This term adds one network statistic to the model equal to the geometrically
weighted dyadwise shared partner distribution with decay parameter
<code>decay</code> parameter, which should be non-negative. 
</p>
</dd>
<dt><code> esp(d, type=2) </code> (order-independent)  (directed)  (undirected)</dt><dd> 
<p>This term adds one network
statistic to the model for each element in <code>d</code> where the <code class="reqn">i</code>th such
statistic equals the number of <em>edges</em> (rather than dyads) in the
network with exactly <code>d[i]</code> shared partners. This term can be used with
directed and undirected networks. For directed networks the count depends on type: 
</p>
<p>type = 1     :   from -&gt; to -&gt; nbr -&gt; from
</p>
<p>type = 2     :   from -&gt; to &lt;- nbr &lt;- from (homogeneous)
</p>
<p>type = 3     :   either type 1 or 2
</p>
<p>type = 4     :   all combinations of from -&gt; to &lt;-&gt; nbr &lt;-&gt; from
</p>
</dd>
<dt><code> geoDist(long, lat, distCuts=Inf) </code>(dyad-independent)  (order-independent)  (undirected)</dt><dd>  
<p>given nodal variables for longitude and latitude, calculates the sum of the
great circle distance between connected nodes. distCuts splits this into
separate statistics that count the sum of the minimum of the cut point and the
distance.
</p>
</dd>
<dt><code> dist(names </code> (dyad-independent)  (order-independent) (undirected)</dt><dd> 
<p>Calculates a statistic equal to the sum of the euclidean distances between
connected nodes on the numeric nodal variables specified in names.
</p>
</dd>
<dt><code> preferentialAttachment(k=1, direction="in") </code> (directed) (undirected)</dt><dd> 
<p>An order dependent preferential attachment term. For each edge, adds
</p>
<p>log( (k+degree) / (n * (meanDegree + k)))
</p>
<p>where degree is the current degree of the acting node, n is the network size, and meanDegree is
the mean degree of the network. This depends upon the order in which edges are added. For directed networks,
if direction=&quot;in&quot; the in-degrees are used. If it is &quot;out&quot; the out degrees are used, otherwise &quot;undirected&quot;
means that the sum of the in and out degrees are used. 
</p>
</dd>
<dt><code> sharedNbrs(k=1) </code> (undirected)</dt><dd> 
<p>for each edge adds
</p>
<p>log(k + shared / minDeg)
</p>
<p>where shared is the current number of shared neighbors between the two nodes, and
minDeg is the minimum of the current degrees of the two nodes (i.e. the number of possible shared 
neighbors).
</p>
</dd>
<dt><code> nodeLogMaxCov(name) </code> (order-independent)  (undirected)</dt><dd> 
<p>For each edge (i,j) and nodal variable variable, add to the statistic
</p>
<p>log(max(variable[i],variable[j]))
</p>
<p>If the variable is a (partial) rank order of nodal inclusion into the network,
this statistic can be useful in modeling the mean degree over the course of the
growth process.
</p>
</dd>
<dt><code> nodeFactor(name, direction="undirected") </code> (order-independent)  (undirected) (directed)</dt><dd> 
<p>The <code>name</code> argument is a character vector giving
one or more names of categorical attributes in the network's vertex
attribute list. This term adds multiple network statistics to the
model, one for each of (a subset of) the unique values of the
<code>attrname</code> attribute (or each combination of the attributes
given). Each of these statistics gives the number of times a node
with that attribute or those attributes appears in an edge in the
network. In particular, for edges whose endpoints both have the same
attribute values, this value is counted twice.  For directed networks, if direction=&quot;in&quot; then in-edges are
used and direction=&quot;out&quot; indicates out-edges.
</p>
</dd>
<dt><code> absDiff(name, power=1) </code> (order-independent)  (undirected) (directed)</dt><dd> 
<p>The <code>name</code> argument is a character string giving the name
of one or mode quantitative attribute in the network's vertex attribute
list. This term adds one network statistic to the model equaling the
sum of <code>sum(abs(name[i]-name[j])^pow)</code> for all edges (i,j)
in the network. 
</p>
</dd>
</dl>



<h3>Constraint Descriptions</h3>


<dl>
<dt><code>boundedDegree(lower,upper)</code>  (order-independent)  (undirected)</dt><dd> 
<p>Adds a constraint that the degrees for the network must be between lower and upper.
</p>
</dd>
</dl>


<hr>
<h2 id='LologModels'>Models</h2><span id='topic+LologModels'></span><span id='topic+DirectedModel'></span><span id='topic+UndirectedModel'></span><span id='topic+Rcpp_DirectedModel-class'></span><span id='topic+Rcpp_UndirectedModel-class'></span>

<h3>Description</h3>

<p>Models
</p>

<hr>
<h2 id='lologPackageSkeleton'>Create a skeleton for a package extending lolog</h2><span id='topic+lologPackageSkeleton'></span>

<h3>Description</h3>

<p>Create a skeleton for a package extending lolog
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lologPackageSkeleton(path = ".")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lologPackageSkeleton_+3A_path">path</code></td>
<td>
<p>where to create the package</p>
</td></tr>
</table>


<h3>Details</h3>

<p>lolog is a modular package, and can be extended at 
both the R and C++ level. This function will build a package
skeleton that can be used as a starting point for
development. To create the package in the current directory
run:
</p>
<p><code>lologPackageSkeleton()</code>
</p>
<p>Build and install the package from the command line with
</p>
<p><code>R CMD build LologExtension</code>
</p>
<p><code>R CMD INSTALL LologExtension_1.0.tar.gz</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+inlineLologPlugin">inlineLologPlugin</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

#install package
lologPackageSkeleton()
system("R CMD build LologExtension")
system("R CMD INSTALL LologExtension_1.0.tar.gz")

library(LologExtension) #Load package

# Run model with new minDegree statistic
library(network)
m &lt;- matrix(0,20,20)
for(i in 1:19) for(j in (i+1):20) m[i,j] &lt;- m[j,i] &lt;- rbinom(1,1,.1)
g &lt;- network(m, directed=FALSE)
fit &lt;- lologVariational(g ~ edges() + minDegree(1L))
summary(fit)


## End(Not run)
</code></pre>

<hr>
<h2 id='lologVariational'>Fits a latent ordered network model using Monte Carlo variational inference</h2><span id='topic+lologVariational'></span>

<h3>Description</h3>

<p>Fits a latent ordered network model using Monte Carlo variational inference
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lologVariational(
  formula,
  nReplicates = 5L,
  dyadInclusionRate = NULL,
  edgeInclusionRate = NULL,
  targetFrameSize = 5e+05
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lologVariational_+3A_formula">formula</code></td>
<td>
<p>A lolog formula. See <code>link{lolog}</code></p>
</td></tr>
<tr><td><code id="lologVariational_+3A_nreplicates">nReplicates</code></td>
<td>
<p>An integer controlling how many dyad ordering to perform.</p>
</td></tr>
<tr><td><code id="lologVariational_+3A_dyadinclusionrate">dyadInclusionRate</code></td>
<td>
<p>Controls what proportion of non-edges in each ordering should be dropped.</p>
</td></tr>
<tr><td><code id="lologVariational_+3A_edgeinclusionrate">edgeInclusionRate</code></td>
<td>
<p>Controls what proportion of edges in each ordering should be dropped.</p>
</td></tr>
<tr><td><code id="lologVariational_+3A_targetframesize">targetFrameSize</code></td>
<td>
<p>Sets dyadInclusionRate so that the model frame for the logistic regression will have on average this amount of observations.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function approximates the maximum likelihood solution via a variational inference on the
graph (y) over the latent edge variable inclusion order (s). Specifically, it replaces
the conditional probability p(s | y) by p(s). If the LOLOG model contains only dyad independent
terms, then these two probabilities are identical, and thus variational inference is
exactly maximum likelihood inference. The objective function is
</p>
<p style="text-align: center;"><code class="reqn">E_{p(s)}\bigg(\log p(y| S, \theta) \bigg)</code>
</p>

<p>This can be approximated by drawing samples from p(s) to approximate the expectation. The
number of samples is controlled by the nReplicates parameter. The memory required is on the
order of nReplicates * (# of dyads). For large networks this can be impractical, so
adjusting dyadInclusionRate and edgeInclusionRate allows one to down sample the # of 
dyads in each replicate. By default these are set attempting to achieve as equal a number
of edges and non-edges as possible while targeting a model frame with targetFrameSize number of rows.
</p>
<p>If the model is dyad independent, replicates are redundant, and so nReplicates is set to
1 with a note.
</p>
<p>The functional form of the objective function is equivalent to logistic regression, and so
the <code><a href="stats.html#topic+glm">glm</a></code> function is used to maximize it. The asymptotic covariance of the parameter
estimates is calculated using the methods of Westling (2015).
</p>


<h3>Value</h3>

<p>An object of class c('lologVariationalFit','lolog','list') consisting of the following
items:
</p>
<table role = "presentation">
<tr><td><code>formula</code></td>
<td>
<p> The model formula</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>&quot;variational&quot;</p>
</td></tr>
<tr><td><code>theta</code></td>
<td>
<p>The fit parameter values</p>
</td></tr>
<tr><td><code>vcov</code></td>
<td>
<p>The asymptotic covariance matrix for the parameter values.</p>
</td></tr>
<tr><td><code>nReplicates</code></td>
<td>
<p>The number of replicates</p>
</td></tr>
<tr><td><code>dyadInclusionRate</code></td>
<td>
<p>The rate at which non-edges are included</p>
</td></tr>
<tr><td><code>edgeInclusionRate</code></td>
<td>
<p>The rate at which edges are included</p>
</td></tr>
<tr><td><code>allDyadIndependent</code></td>
<td>
<p>Logical indicating model dyad independence</p>
</td></tr>
<tr><td><code>likelihoodModel</code></td>
<td>
<p>An object of class *LatentOrderLikelihood at the fit parameters</p>
</td></tr>
<tr><td><code>outcome</code></td>
<td>
<p>The outcome vector for the logistic regression</p>
</td></tr>
<tr><td><code>predictors</code></td>
<td>
<p>The change statistic predictor matrix for the logistic regression</p>
</td></tr>
</table>


<h3>References</h3>

<p>Westling, T., &amp; McCormick, T. H. (2015). Beyond prediction: A framework for inference with variational approximations in mixture models. arXiv preprint arXiv:1510.08151.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(network)
data(ukFaculty)

# Delete vertices missing group
delete.vertices(ukFaculty, which(is.na(ukFaculty %v% "Group")))

fit &lt;- lologVariational(ukFaculty ~ edges() + nodeMatch("GroupC"),
                       nReplicates=1L, dyadInclusionRate=1)
summary(fit)


</code></pre>

<hr>
<h2 id='plot.gofit'>Plots a gofit object</h2><span id='topic+plot.gofit'></span>

<h3>Description</h3>

<p>Plots a gofit object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gofit'
plot(
  x,
  y,
  type = c("line", "box"),
  scaling = c("none", "std", "sqrt"),
  lineAlpha = 0.06,
  lineSize = 1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.gofit_+3A_x">x</code></td>
<td>
<p>the gofit object</p>
</td></tr>
<tr><td><code id="plot.gofit_+3A_y">y</code></td>
<td>
<p>unused</p>
</td></tr>
<tr><td><code id="plot.gofit_+3A_type">type</code></td>
<td>
<p>type of plot, boxplot or lineplot</p>
</td></tr>
<tr><td><code id="plot.gofit_+3A_scaling">scaling</code></td>
<td>
<p>type of scaling of the network statistics. If &quot;std&quot;, network statistics are scaling by subtracting off the observed statistics and scaling by the standard deviation. If &quot;sqrt&quot;, network statistics are plotted on the square root scale (The square root is the variance stabilizing transformation for a Poisson random variable). The default is &quot;none&quot;, where by the network statistics are not scaled.</p>
</td></tr>
<tr><td><code id="plot.gofit_+3A_linealpha">lineAlpha</code></td>
<td>
<p>The transparency of the simulated statistics lines</p>
</td></tr>
<tr><td><code id="plot.gofit_+3A_linesize">lineSize</code></td>
<td>
<p>The width of the lines</p>
</td></tr>
<tr><td><code id="plot.gofit_+3A_...">...</code></td>
<td>
<p>passed to either boxplot or geom_line</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>library(network)
data(ukFaculty)

# Delete vertices missing group
delete.vertices(ukFaculty, which(is.na(ukFaculty %v% "Group")))

# A dyad independent model
fitind &lt;- lolog(ukFaculty ~ edges() + nodeMatch("GroupC") + nodeCov("GroupC"))
summary(fitind)

# Check gof on degree distribution (bad!)
gind &lt;- gofit(fitind, ukFaculty ~ degree(0:50))
plot(gind)
plot(gind, type="box")
</code></pre>

<hr>
<h2 id='plot.lologGmm'>Conduct Monte Carlo diagnostics on a lolog model fit</h2><span id='topic+plot.lologGmm'></span>

<h3>Description</h3>

<p>This function creates simple diagnostic
plots for MC sampled statistics produced from a lolog fit.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lologGmm'
plot(x, type = c("histograms", "target", "model"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.lologGmm_+3A_x">x</code></td>
<td>
<p>A model fit object to be diagnosed.</p>
</td></tr>
<tr><td><code id="plot.lologGmm_+3A_type">type</code></td>
<td>
<p>The type of diagnostic plot. &quot;histograms&quot;, the default, produces histograms of the sampled
output statistic values with the observed statistics represented by vertical lines. &quot;target&quot; produces a pairs plot of the 
target output statistic values with the pairs of observed target statistics represented by red squares.
output statistic values with the observed statistics represented by vertical lines. &quot;model&quot; produces a pairs plot of the 
sampled output statistic values with the pairs of observed statistics represented by red squares.</p>
</td></tr>
<tr><td><code id="plot.lologGmm_+3A_...">...</code></td>
<td>
<p>Additional parameters. Passed to <a href="ggplot2.html#topic+geom_histogram">geom_histogram</a> if type=&quot;histogram&quot; 
and <a href="graphics.html#topic+pairs">pairs</a> otherwise.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Plots are produced that represent the distributions of the 
output sampled statistic values or the target statistics values.
The values of the observed target statistics for the networks are
also represented for comparison with the sampled statistics.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(network)
set.seed(1)
data(flo)
flomarriage &lt;- network(flo,directed=FALSE)
flomarriage %v% "wealth" &lt;- c(10,36,27,146,55,44,20,8,42,103,48,49,10,48,32,3)


# An order dependent model
fit3 &lt;- lolog(flomarriage ~ edges + nodeCov("wealth") + preferentialAttachment(),
              flomarriage ~ star(2:3), verbose=FALSE)
plot(fit3)
plot(fit3, "target")
plot(fit3, "model")
</code></pre>

<hr>
<h2 id='plot.Rcpp_DirectedNet'>plot an DirectedNet object</h2><span id='topic+plot.Rcpp_DirectedNet'></span>

<h3>Description</h3>

<p>plot an DirectedNet object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Rcpp_DirectedNet'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.Rcpp_DirectedNet_+3A_x">x</code></td>
<td>
<p>the Rcpp_DirectedNet object</p>
</td></tr>
<tr><td><code id="plot.Rcpp_DirectedNet_+3A_...">...</code></td>
<td>
<p>additional parameters for plot.network</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a thin wrapper around <code><a href="network.html#topic+plot.network">plot.network</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ukFaculty)
net &lt;- as.BinaryNet(ukFaculty)
plot(net, vertex.col=net[["Group"]]+1)
</code></pre>

<hr>
<h2 id='plot.Rcpp_UndirectedNet'>Plot an UndirectedNet object</h2><span id='topic+plot.Rcpp_UndirectedNet'></span>

<h3>Description</h3>

<p>Plot an UndirectedNet object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Rcpp_UndirectedNet'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.Rcpp_UndirectedNet_+3A_x">x</code></td>
<td>
<p>the object</p>
</td></tr>
<tr><td><code id="plot.Rcpp_UndirectedNet_+3A_...">...</code></td>
<td>
<p>additional parameters for plot.network</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a thin wrapper around <code><a href="network.html#topic+plot.network">plot.network</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>el &lt;- matrix(c(1,2),ncol=2)
net &lt;- new(UndirectedNet, el, 5L)
net[1,5] &lt;- 1
net[2,5] &lt;- 1
plot(net)
</code></pre>

<hr>
<h2 id='print.gofit'>prints a gofit object</h2><span id='topic+print.gofit'></span>

<h3>Description</h3>

<p>prints a gofit object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gofit'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.gofit_+3A_x">x</code></td>
<td>
<p>The object</p>
</td></tr>
<tr><td><code id="print.gofit_+3A_...">...</code></td>
<td>
<p>passed to print.data.frame</p>
</td></tr>
</table>

<hr>
<h2 id='print.lolog'>Print a 'lolog' object</h2><span id='topic+print.lolog'></span>

<h3>Description</h3>

<p>Print a 'lolog' object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lolog'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.lolog_+3A_x">x</code></td>
<td>
<p>the object</p>
</td></tr>
<tr><td><code id="print.lolog_+3A_...">...</code></td>
<td>
<p>additional parameters (unused)</p>
</td></tr>
</table>

<hr>
<h2 id='print.lologVariationalFit'>Print of a lologVariationalFit object</h2><span id='topic+print.lologVariationalFit'></span>

<h3>Description</h3>

<p>Print of a lologVariationalFit object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lologVariationalFit'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.lologVariationalFit_+3A_x">x</code></td>
<td>
<p>the object</p>
</td></tr>
<tr><td><code id="print.lologVariationalFit_+3A_...">...</code></td>
<td>
<p>additional parameters (unused)</p>
</td></tr>
</table>

<hr>
<h2 id='registerDirectedStatistic'>Register Statistics</h2><span id='topic+registerDirectedStatistic'></span><span id='topic+registerUndirectedStatistic'></span><span id='topic+registerDirectedOffset'></span><span id='topic+registerUndirectedOffset'></span>

<h3>Description</h3>

<p>Register Statistics
</p>


<h3>Usage</h3>

<pre><code class='language-R'>registerDirectedStatistic
</code></pre>

<hr>
<h2 id='simulate.lolog'>Generates BinaryNetworks from a fit lolog object</h2><span id='topic+simulate.lolog'></span>

<h3>Description</h3>

<p>Generates BinaryNetworks from a fit lolog object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lolog'
simulate(object, nsim = 1, seed = NULL, convert = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simulate.lolog_+3A_object">object</code></td>
<td>
<p>A 'lolog' object.</p>
</td></tr>
<tr><td><code id="simulate.lolog_+3A_nsim">nsim</code></td>
<td>
<p>The number of simulated networks</p>
</td></tr>
<tr><td><code id="simulate.lolog_+3A_seed">seed</code></td>
<td>
<p>Either NULL or an integer that will be used in a call to set.seed before simulating</p>
</td></tr>
<tr><td><code id="simulate.lolog_+3A_convert">convert</code></td>
<td>
<p>convert to a network object#'</p>
</td></tr>
<tr><td><code id="simulate.lolog_+3A_...">...</code></td>
<td>
<p>unused</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of BinaryNet (or network if convert=TRUE) objects. Networks contain an additional
vertex covariate &quot;__order__&quot; that indicates the sequence order in which the vertex was 'added' 
into the network.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(network)
data(flo)
flomarriage &lt;- network(flo,directed=FALSE)
flomarriage %v% "wealth" &lt;- c(10,36,27,146,55,44,20,8,42,103,48,49,10,48,32,3)
fit &lt;- lolog(flomarriage ~ edges + nodeCov("wealth"))
net &lt;- simulate(fit)[[1]]
plot(net)

</code></pre>

<hr>
<h2 id='summary.lolog'>Summary of a 'lolog' object</h2><span id='topic+summary.lolog'></span>

<h3>Description</h3>

<p>Summary of a 'lolog' object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lolog'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.lolog_+3A_object">object</code></td>
<td>
<p>the object</p>
</td></tr>
<tr><td><code id="summary.lolog_+3A_...">...</code></td>
<td>
<p>additional parameters (unused)</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(lazega)
fit &lt;- lologVariational(lazega ~ edges() + nodeMatch("office") + triangles, 
                        nReplicates=50L, dyadInclusionRate=1)
summary(fit)
</code></pre>

<hr>
<h2 id='ukFaculty'>Friendship network of a UK university faculty</h2><span id='topic+ukFaculty'></span>

<h3>Description</h3>

<p>The personal friendship network of a faculty of a UK university, 
consisting of 81 vertices (individuals) and 817 directed and weighted connections. 
The school affiliation of each individual is stored as a vertex attribute. The survey
contained missing data for the school of two individuals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(ukFaculty)
</code></pre>


<h3>Licenses and Citation</h3>

<p>When publishing results obtained using this
data set, the original authors (Nepusz T., Petroczi A., Negyessy L., Bazso F. 2008)
should be cited, along with this <code>R</code> package.
</p>


<h3>Copyright</h3>

<p>Creative Commons Attribution-Share Alike 2.0 UK: England &amp; Wales License, 
see http://creativecommons.org/licenses/by-sa/2.0/uk/ for details.
</p>


<h3>Source</h3>

<p>The data set was originally reported by Nepusz et. al. (2008) and was
subsequently processed and included by the igraphdata package. We have simply
converted their network from an igraph to a network object.
</p>


<h3>References</h3>

<p>Nepusz T., Petroczi A., Negyessy L., Bazso F.: Fuzzy communities and the 
concept of bridgeness in complex networks. Physical Review E 77:016107, 2008.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
