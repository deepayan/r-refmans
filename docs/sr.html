<!DOCTYPE html><html lang="en-US"><head><title>Help for package sr</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {sr}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#sr-package'><p>sr: Smooth Regression - The Gamma Test and Tools</p></a></li>
<li><a href='#fe_search'><p>Full Embedding Search</p></a></li>
<li><a href='#gamma_histogram'><p>Plot Histogram of Gammas</p></a></li>
<li><a href='#gamma_test'><p>Estimate Smoothness in an Input/output Dataset</p></a></li>
<li><a href='#get_Mlist'><p>Discover how Gamma varies with sample size</p></a></li>
<li><a href='#henon_x'><p>Henon Map</p></a></li>
<li><a href='#increasing_search'><p>Increasing Embedding Search engine, used by get/plot increasing_search</p></a></li>
<li><a href='#int_to_intMask'><p>Integer to Vector Bitmask</p></a></li>
<li><a href='#mask_histogram'><p>Mask Histogram</p></a></li>
<li><a href='#mgls'><p>Mackey-Glass time delayed differential equation</p></a></li>
<li><a href='#moving_window_search'><p>Moving Window Search</p></a></li>
<li><a href='#select_by_mask'><p>Select by Mask</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Smooth Regression - The Gamma Test and Tools</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Finds causal connections in precision data, finds lags and embeddings in 
  time series, guides training of neural networks and other smooth models, evaluates 
  their performance, gives a mathematically grounded answer to the over-training 
  problem.  Smooth regression is based on the Gamma test, which measures smoothness
  in a multivariate relationship.  Causal relations are smooth, noise is not.  
  'sr' includes the Gamma test and search techniques that use it. 
  References: Evans &amp; Jones (2002) &lt;<a href="https://doi.org/10.1098%2Frspa.2002.1010">doi:10.1098/rspa.2002.1010</a>&gt;, 
  AJ Jones (2004) &lt;<a href="https://doi.org/10.1007%2Fs10287-003-0006-1">doi:10.1007/s10287-003-0006-1</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>ggplot2, dplyr, progress, RANN, stats, vdiffr</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, magrittr, nnet, rmarkdown, testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://smoothregression.com">https://smoothregression.com</a>, <a href="https://github.com/haythorn/sr/">https://github.com/haythorn/sr/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/haythorn/sr/issues">https://github.com/haythorn/sr/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-03-09 20:56:16 UTC; wayne</td>
</tr>
<tr>
<td>Author:</td>
<td>Wayne Haythorn [aut, cre],
  Antonia Jones [aut] (Principal creator of the Gamma test),
  Sam Kemp [ctb] (Wrote the original code for the Gamma test in R)</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Wayne Haythorn &lt;support@smoothregression.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-03-10 08:00:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='sr-package'>sr: Smooth Regression - The Gamma Test and Tools</h2><span id='topic+sr'></span><span id='topic+sr-package'></span>

<h3>Description</h3>

<p>Finds causal connections in precision data, finds lags and embeddings in time series, guides training of neural networks and other smooth models, evaluates their performance, gives a mathematically grounded answer to the over-training problem. Smooth regression is based on the Gamma test, which measures smoothness in a multivariate relationship. Causal relations are smooth, noise is not. 'sr' includes the Gamma test and search techniques that use it. References: Evans &amp; Jones (2002) <a href="https://doi.org/10.1098/rspa.2002.1010">doi:10.1098/rspa.2002.1010</a>, AJ Jones (2004) <a href="https://doi.org/10.1007/s10287-003-0006-1">doi:10.1007/s10287-003-0006-1</a>.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Wayne Haythorn <a href="mailto:support@smoothregression.com">support@smoothregression.com</a>
</p>
<p>Authors:
</p>

<ul>
<li><p> Antonia Jones (Principal creator of the Gamma test)
</p>
</li></ul>

<p>Other contributors:
</p>

<ul>
<li><p> Sam Kemp (Wrote the original code for the Gamma test in R) [contributor]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://smoothregression.com">https://smoothregression.com</a>
</p>
</li>
<li> <p><a href="https://github.com/haythorn/sr/">https://github.com/haythorn/sr/</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/haythorn/sr/issues">https://github.com/haythorn/sr/issues</a>
</p>
</li></ul>


<hr>
<h2 id='fe_search'>Full Embedding Search</h2><span id='topic+fe_search'></span>

<h3>Description</h3>

<p>Calculates Gamma for all combinations of a set of input predictors
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fe_search(predictors, target, prog_bar = TRUE, n_neighbors = 10, eps = 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fe_search_+3A_predictors">predictors</code></td>
<td>
<p>A vector or matrix whose columns are proposed inputs to a
predictive function</p>
</td></tr>
<tr><td><code id="fe_search_+3A_target">target</code></td>
<td>
<p>A vector of double, the output variable that is to be predicted</p>
</td></tr>
<tr><td><code id="fe_search_+3A_prog_bar">prog_bar</code></td>
<td>
<p>Logical, set this to FALSE if you don't want progress bar displayed</p>
</td></tr>
<tr><td><code id="fe_search_+3A_n_neighbors">n_neighbors</code></td>
<td>
<p>Integer number of near neighbors to use in RANN search,
passed to gamma_test</p>
</td></tr>
<tr><td><code id="fe_search_+3A_eps">eps</code></td>
<td>
<p>The error limit for the approximate near neighbor search.  This
will be passed to gamma_test, which will pass it on to the ANN near neighbor search.  Setting
this greater than zero can significantly reduce search time for large data sets.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given a set of predictors and a target that is to be predicted, this search
will run the gamma test on every combination of the inputs.  It returns the
results in order of increasing gamma, so the best combinations of inputs for
prediction will be at the beginning of the list.  As this is a fully
combinatoric search, it will start to get slow beyond about 16 inputs.  By default,
<code>fe_search</code> will display a progress bar showing the time to completion.
</p>
<p><code>fe_search()</code> returns a data.frame with two columns: Gamma, a sorted vector of
Gamma values, and mask, an integer column containing the masks representing the inputs
used to calculate each Gamma.  To reconstruct the predictor set for a Gamma,
use its mask with int_to_intMask and select_by_mask as shown in their examples.
</p>


<h3>Value</h3>

<p>An invisible data frame with two columns, mask - an integer mask
representing a subset of the predictors, and Gamma, the value of Gamma using
those predictors.  The rows are sorted from lowest to highest Gamma.  The
return value also has an attribute named target_V, the target variance.
To get the vratio (estimated fraction of target variance due to noise), divide
any of the Gammas by target_v.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>e6 &lt;- embed(mgls, 7)
t &lt;- e6[ ,1]
p &lt;- e6[ ,2:7]
full_search &lt;- fe_search(predictors = p, target = t)
full_search &lt;- dplyr::mutate(full_search,
                             vratio = Gamma / attr(full_search, "target_v"))
</code></pre>

<hr>
<h2 id='gamma_histogram'>Plot Histogram of Gammas</h2><span id='topic+gamma_histogram'></span>

<h3>Description</h3>

<p>Produces a histogram showing the distribution in a population of Gamma
values, used to examine the result of a full embedding search.  Pass the result
of fe_search() to this function to look for structure in the predictors.
For example, it this histogram is bimodal, there is probably one input variable
which is absolutely required for a good predictive function, so the histogram
divides into the subset containing that variable, and the others that don't.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gamma_histogram(fe_results, bins = 100, caption = "")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gamma_histogram_+3A_fe_results">fe_results</code></td>
<td>
<p>The result of fe_search or full_embedding_search.  A matrix
containing a column labeled Gamma, of Numeric Gamma values.
It also contains an integer column of masks, but that is not used by this function.</p>
</td></tr>
<tr><td><code id="gamma_histogram_+3A_bins">bins</code></td>
<td>
<p>Numeric, number of bins in the histogram</p>
</td></tr>
<tr><td><code id="gamma_histogram_+3A_caption">caption</code></td>
<td>
<p>Character string caption for the plot</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a ggplot object, a histogram showing the distribution of Gamma values
full embedding search output
</p>


<h3>Examples</h3>

<pre><code class='language-R'>e6 &lt;- embed(mgls, 7)
t &lt;- e6[ ,1]
p &lt;- e6[ ,2:7]
full_search &lt;- fe_search(predictors = p, target = t)
gamma_histogram(full_search, caption = "my data")
</code></pre>

<hr>
<h2 id='gamma_test'>Estimate Smoothness in an Input/output Dataset</h2><span id='topic+gamma_test'></span>

<h3>Description</h3>

<p>The gamma test measures mean squared error in an input/output data set, relative
to an arbitrary, unknown smooth function.  This can usually be interpreted as testing
for the existence of a causal relationship, and estimating the expected error of the
best smooth model that could be built on that relationship.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gamma_test(
  predictors,
  target,
  n_neighbors = 10,
  eps = 0,
  plot = FALSE,
  caption = "",
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gamma_test_+3A_predictors">predictors</code></td>
<td>
<p>A Numeric vector or matrix whose columns are proposed inputs to a predictive function.</p>
</td></tr>
<tr><td><code id="gamma_test_+3A_target">target</code></td>
<td>
<p>A Numeric vector, the output variable that is to be predicted</p>
</td></tr>
<tr><td><code id="gamma_test_+3A_n_neighbors">n_neighbors</code></td>
<td>
<p>An Integer, the number of near neighbors to use in calculating gamma</p>
</td></tr>
<tr><td><code id="gamma_test_+3A_eps">eps</code></td>
<td>
<p>The error term passed to the approximate near neighbor search.  The default value
of zero means that exact near neighbors will be found, but time will be O(M^2), where an
approximate search can run in O(M*log(M))</p>
</td></tr>
<tr><td><code id="gamma_test_+3A_plot">plot</code></td>
<td>
<p>A Logical variable, whether to plot the delta/gamma graph.</p>
</td></tr>
<tr><td><code id="gamma_test_+3A_caption">caption</code></td>
<td>
<p>A character string which will be the caption for the plot if plot = TRUE</p>
</td></tr>
<tr><td><code id="gamma_test_+3A_verbose">verbose</code></td>
<td>
<p>A Logical variable, whether to return details of the computation</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If verbose == FALSE, a list containing Gamma and the vratio, If verbose == TRUE,
that list plus the distances from each point to its near neighbors, the average of squared distances,
and the value returned by lm on the delta and gamma averages.  Gamma is Coefficient 1 of lm.
</p>


<h3>References</h3>

<p><a href="https://royalsocietypublishing.org/doi/10.1098/rspa.2002.1010">https://royalsocietypublishing.org/doi/10.1098/rspa.2002.1010</a>,
<a href="https://link.springer.com/article/10.1007/s10287-003-0006-1">https://link.springer.com/article/10.1007/s10287-003-0006-1</a>,
<a href="https://smoothregression.com">https://smoothregression.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>he &lt;- embed(henon_x, 3)
t &lt;- he[ , 1]
p &lt;- he[ ,2:3]
gamma_test(predictors = p, target = t)
</code></pre>

<hr>
<h2 id='get_Mlist'>Discover how Gamma varies with sample size</h2><span id='topic+get_Mlist'></span>

<h3>Description</h3>

<p>Investigates the effect of sample size by calculating Gamma on larger and larger
samples.  Gamma will converge on the true noise in the relationship as sampling
density on the function increases.  <code>get_Mlist</code> produces a showing M values
(sample sizes), and the associated Gammas and vratios. It produces a graph by
default, and also returns an invisible data.frame.  The successive samples are
taken starting at the beginning of the inputs.  There is no option to sort
the input data; if you want the data to be randomized, do that before calling
<code>get_Mlist</code>.  The graph will become stable when the sample size is large enough.
If the M list does not become stable, there is not enough data for either the
Gamma test or a successful smooth model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_Mlist(
  predictors,
  target,
  plot = TRUE,
  caption = "",
  show = "Gamma",
  from = 20,
  to = length(target),
  by = 20
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_Mlist_+3A_predictors">predictors</code></td>
<td>
<p>A Numeric vector or matrix whose columns are proposed
inputs to a predictive relationship</p>
</td></tr>
<tr><td><code id="get_Mlist_+3A_target">target</code></td>
<td>
<p>A Numeric vector, the output variable that is to be predicted</p>
</td></tr>
<tr><td><code id="get_Mlist_+3A_plot">plot</code></td>
<td>
<p>A logical, set this to FALSE if you don't want the plot</p>
</td></tr>
<tr><td><code id="get_Mlist_+3A_caption">caption</code></td>
<td>
<p>Character string to be used as caption for the plot</p>
</td></tr>
<tr><td><code id="get_Mlist_+3A_show">show</code></td>
<td>
<p>Character string, if it equals &quot;vratio&quot;, vratios will be plotted,
otherwise Gamma is plotted</p>
</td></tr>
<tr><td><code id="get_Mlist_+3A_from">from</code></td>
<td>
<p>Integer length of the first data sample, as passed to seq</p>
</td></tr>
<tr><td><code id="get_Mlist_+3A_to">to</code></td>
<td>
<p>Integer maximum length of sample to test, passed to seq</p>
</td></tr>
<tr><td><code id="get_Mlist_+3A_by">by</code></td>
<td>
<p>Integer increment in lengths of successive windows, passed to seq</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An invisible data frame with three columns: M (a sample size), Gamma
and the associated vratio.  This is ordered by increasing M.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>he &lt;- embed(henon_x, 13)
t &lt;- he[ , 1]
p &lt;- he[ ,2:13]
get_Mlist(p, t, by = 2, caption = "this data")
</code></pre>

<hr>
<h2 id='henon_x'>Henon Map</h2><span id='topic+henon_x'></span>

<h3>Description</h3>

<p>1000 x data points from the Henon Map
</p>


<h3>Usage</h3>

<pre><code class='language-R'>henon_x
</code></pre>


<h3>Format</h3>

<p>An object of class <code>numeric</code> of length 1000.
</p>


<h3>References</h3>

<p>See Wikipedia entry on &quot;Henon map&quot;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>henon_embedded &lt;- embed(as.matrix(henon_x), 3)
targets &lt;- henon_embedded[ ,1]
predictors &lt;- henon_embedded[ ,2:3]
gamma_test(predictors, targets)
</code></pre>

<hr>
<h2 id='increasing_search'>Increasing Embedding Search engine, used by get/plot increasing_search</h2><span id='topic+increasing_search'></span>

<h3>Description</h3>

<p>Adds variables one at a time to the input set, to see how many are needed for prediction.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>increasing_search(
  predictors,
  target,
  plot = TRUE,
  caption = "",
  show = "Gamma"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="increasing_search_+3A_predictors">predictors</code></td>
<td>
<p>A vector or matrix whose columns are proposed inputs to a
predictive function</p>
</td></tr>
<tr><td><code id="increasing_search_+3A_target">target</code></td>
<td>
<p>A vector of double, the output variable that is to be predicted</p>
</td></tr>
<tr><td><code id="increasing_search_+3A_plot">plot</code></td>
<td>
<p>Logical, set plot = FALSE if you don't want the plot</p>
</td></tr>
<tr><td><code id="increasing_search_+3A_caption">caption</code></td>
<td>
<p>Character string to identify plot, for example, data being plotted</p>
</td></tr>
<tr><td><code id="increasing_search_+3A_show">show</code></td>
<td>
<p>Character string, if it equals &quot;vratio&quot;, vratios will be plotted,
otherwise Gamma is plotted</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An increasing embedding search is appropriate when the input variables are ordered,
most commonly in analyzing time series, when it's useful to know how many previous
time steps or lags should be examined to build a model.  Starting with lag 1, the
search adds previous values one at a time, and saves the resulting gammas.  These
results can be examined using plot_increasing_search()
</p>


<h3>Value</h3>

<p>An invisible data frame with three columns, Depth of search, from
1 to ncol(predictors), Gamma calculated using columns 1:Depth as predictors,
and vratio corresponding to that Gamma (Gamma / var(target))
</p>


<h3>Examples</h3>

<pre><code class='language-R'>he &lt;- embed(henon_x, 13)
t &lt;- he[ , 1]
p &lt;- he[ ,2:13]
increasing_search(p, t, caption = "henon data embedded 16")
df &lt;- increasing_search(predictors=p, target=t, plot = FALSE)
</code></pre>

<hr>
<h2 id='int_to_intMask'>Integer to Vector Bitmask</h2><span id='topic+int_to_intMask'></span>

<h3>Description</h3>

<p>Converts the bit representation of an integer into a vector of integers
</p>


<h3>Usage</h3>

<pre><code class='language-R'>int_to_intMask(i, length)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="int_to_intMask_+3A_i">i</code></td>
<td>
<p>A 32 bit integer</p>
</td></tr>
<tr><td><code id="int_to_intMask_+3A_length">length</code></td>
<td>
<p>Integer length of the bitmask to produce, must be &lt;= 32</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Converts an integer to a vector of ones and zeroes.  Used as a helper
function for full_embedding_search, it allows more compact storage of bit masks.
The result reads left to right, so the one bit will have index of one in the
vector corresponding to lag 1 in an embedding.  Works for masks up
to 32 bits
</p>


<h3>Value</h3>

<p>A vector of integer containing 1 or 0
</p>


<h3>Examples</h3>

<pre><code class='language-R'>he &lt;- embed(henon_x, 17)
t &lt;- he[ , 1]
p &lt;- he[ ,2:17]
mask &lt;- int_to_intMask(7, 16)     # pick out the first three columns
pn &lt;- select_by_mask(p, mask)
gamma_test(predictors = pn, target = t)
</code></pre>

<hr>
<h2 id='mask_histogram'>Mask Histogram</h2><span id='topic+mask_histogram'></span>

<h3>Description</h3>

<p>Display a histogram of mask bits.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mask_histogram(fe_result, dimension, tick_step = 2, caption = "")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mask_histogram_+3A_fe_result">fe_result</code></td>
<td>
<p>Output data frame from fe_search.  Normally you would filter
this by, for example, selecting the top 100 results from that output.  If the
whole fe_search result was passed in, all of the mask bits would have the same
frequency and the histogram would be flat.</p>
</td></tr>
<tr><td><code id="mask_histogram_+3A_dimension">dimension</code></td>
<td>
<p>Integer number of effective columns in a mask, ncol of the
predictors given to the search</p>
</td></tr>
<tr><td><code id="mask_histogram_+3A_tick_step">tick_step</code></td>
<td>
<p>Integer, where to put ticks on the x axis</p>
</td></tr>
<tr><td><code id="mask_histogram_+3A_caption">caption</code></td>
<td>
<p>A character string you can use to identify this graph</p>
</td></tr>
</table>


<h3>Details</h3>

<p>After a full embedding search, it is sometimes useful to see which bits
appear in a subset of the masks, for example, the masks with the lowest Gamma
values.  Filtering of the search results should be done before calling this
function, which uses whatever it is given.  The histogram can show which
predictors are generally useful.  For selecting an effective mask it isn't as
useful as you might think - it doesn't show interactions between predictors,
for mask selection it would only work for linear combinations of inputs.
</p>


<h3>Value</h3>

<p>A ggplot object, a histogram showing the mask bits used in the fe_search
results that are passed to it
</p>


<h3>Examples</h3>

<pre><code class='language-R'>e6 &lt;- embed(mgls, 7)
t &lt;- e6[ ,1]
p &lt;- e6[ ,2:7]
full_search &lt;- fe_search(predictors = p, target = t)
goodies &lt;- head(full_search, 20)
mask_histogram(goodies, 6, caption = "mask bits in top 20 Gammas")
baddies &lt;- tail(full_search, 20)
mask_histogram(baddies, 6, caption = "bits appearing in 20 worst Gammas")
</code></pre>

<hr>
<h2 id='mgls'>Mackey-Glass time delayed differential equation</h2><span id='topic+mgls'></span>

<h3>Description</h3>

<p>4999 data points
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mgls
</code></pre>


<h3>Format</h3>

<p>An object of class <code>numeric</code> of length 4999.
</p>


<h3>References</h3>

<p>See Wikipedia entry on &quot;Mackey-Glass equations&quot;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mgls_embedded &lt;- embed(as.matrix(mgls), 25)
targets &lt;- mgls_embedded[ ,1]
predictors &lt;- mgls_embedded[ ,2:25]
</code></pre>

<hr>
<h2 id='moving_window_search'>Moving Window Search</h2><span id='topic+moving_window_search'></span>

<h3>Description</h3>

<p>Calculate Gamma values for a window moving through the data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>moving_window_search(
  predictors,
  target,
  window_size = 40,
  by = 1,
  plot = TRUE,
  caption = "",
  show = "Gamma"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="moving_window_search_+3A_predictors">predictors</code></td>
<td>
<p>A Numeric vector or matrix whose columns are proposed inputs
to a predictive function</p>
</td></tr>
<tr><td><code id="moving_window_search_+3A_target">target</code></td>
<td>
<p>A Numeric vector, the output variable that is to be predicted</p>
</td></tr>
<tr><td><code id="moving_window_search_+3A_window_size">window_size</code></td>
<td>
<p>Integer width of the window that will move through the data</p>
</td></tr>
<tr><td><code id="moving_window_search_+3A_by">by</code></td>
<td>
<p>The increment between successive window starts</p>
</td></tr>
<tr><td><code id="moving_window_search_+3A_plot">plot</code></td>
<td>
<p>Logical, set this to FALSE if you don't want the plot</p>
</td></tr>
<tr><td><code id="moving_window_search_+3A_caption">caption</code></td>
<td>
<p>Character string, caption for plot</p>
</td></tr>
<tr><td><code id="moving_window_search_+3A_show">show</code></td>
<td>
<p>Character string, if it equals &quot;vratio&quot;, vratios will be plotted,
otherwise Gamma is plotted</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is used for data sets that are ordered on one or more dimension, such as
time series or spatial data.  The search slides a window across the data set,
calculating gamma for the data at each step.  A change in causal dynamics will
appear as a spike in gamma when the causal discontinuity is in the window.
</p>


<h3>Value</h3>

<p>An invisible data frame containing starting and ending positions of
each window with its associated gamma
</p>


<h3>Examples</h3>

<pre><code class='language-R'>he &lt;- embed(henon_x, 13)
t &lt;- he[ , 1]
p &lt;- he[ ,2:13]
moving_window_search(p, t, by = 5, caption = "my data")
</code></pre>

<hr>
<h2 id='select_by_mask'>Select by Mask</h2><span id='topic+select_by_mask'></span>

<h3>Description</h3>

<p>Select columns from a matrix using an integer bitmap
</p>


<h3>Usage</h3>

<pre><code class='language-R'>select_by_mask(data, intMask)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="select_by_mask_+3A_data">data</code></td>
<td>
<p>A numeric matrix in tidy form</p>
</td></tr>
<tr><td><code id="select_by_mask_+3A_intmask">intMask</code></td>
<td>
<p>An Integer vector whose length equals number of columns in data</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Selects columns from a matrix.  A column is included in the output when the
corresponding mask value is 1.
</p>


<h3>Value</h3>

<p>A matrix containing the columns of data for which intMask is 1
</p>


<h3>Examples</h3>

<pre><code class='language-R'>e12 &lt;- embed(mgls, 13)
tn &lt;- e12[ , 1]
pn &lt;- e12[ ,2:13]
msk &lt;- integer(12)
msk[c(1,2,3,4,6,7,9)] &lt;- 1  # select these columns
p &lt;- select_by_mask(pn, msk)
gamma_test(predictors = p, target = tn)

msk &lt;- int_to_intMask(15, 12)     # pick out the first four columns
p &lt;- select_by_mask(pn, msk)
gamma_test(predictors = p, target = tn)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
