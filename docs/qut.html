<!DOCTYPE html><html><head><title>Help for package qut</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {qut}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#affinelassotest'>
<p>Affine lasso test</p></a></li>
<li><a href='#chemometrics'>
<p>Chemometrics data set from Sardy (2008)</p></a></li>
<li><a href='#internetAd'>
<p>InternetAd data set from Kushmerick (1999)</p></a></li>
<li><a href='#lambdaqut'>
<p>Quantile Universal Threshold, regularization parameter for GLM-lasso</p></a></li>
<li><a href='#predict.qut'>
<p>Make predictions from a &quot;qut&quot; object.</p></a></li>
<li><a href='#processX'>
<p>Process X matrix</p></a></li>
<li><a href='#qut'>
<p>Fit a low dimensional GLM or Square-root lasso using the Quantile Universal Threshold</p></a></li>
<li><a href='#QUT-package'>
<p>Quantile Universal Threshold</p></a></li>
<li><a href='#riboflavin'>
<p>Riboflavin data set from Buhlmann et al. (2013)</p></a></li>
<li><a href='#sigmaqut'>
<p>Estimation of <code class="reqn">\sigma</code> based on the Quantile Universal Threshold</p></a></li>
<li><a href='#sigmarcv'>
<p>Variance estimation using refitted cross-validation</p></a></li>
<li><a href='#ztf'>
<p>Zero thresholding function</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Quantile Universal Threshold</td>
</tr>
<tr>
<td>Version:</td>
<td>2.2</td>
</tr>
<tr>
<td>Description:</td>
<td>Thresholding based tests for null hypothesis of the form A beta =c, and the Quantile Universal Threshold (QUT) for lasso regularization of Generalized Linear Models (GLM) and square-root lasso to obtain a sparse model with a good compromise between high true positive rate and low false discovery rate. Giacobino et al. (2017) &lt;<a href="https://doi.org/10.1214%2F17-EJS1366">doi:10.1214/17-EJS1366</a>&gt;. Sardy et al. (2017) &lt;<a href="https://arxiv.org/abs/1708.02908">arXiv:1708.02908</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>Matrix, glmnet, lars, flare</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-01-15 19:40:31 UTC; jairo</td>
</tr>
<tr>
<td>Author:</td>
<td>Jairo Diaz-Rodriguez [aut, cre, cph],
  Sylvain Sardy [aut, ths],
  Caroline Giacobino [aut],
  Nick Hengartner [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Jairo Diaz-Rodriguez &lt;adjairo@uninorte.edu.co&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-01-19 10:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='affinelassotest'>
Affine lasso test
</h2><span id='topic+affinelassotest'></span>

<h3>Description</h3>

<p>Perform thresholding tests for null hypothesis of the form H0: A beta = c.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>affinelassotest(y, Xdata, family = gaussian, alpha, beta0=NA, cc = NA, lambdas = NA, 
outrescale = NA, intercept = TRUE, group.sizes = rep(1, ncol(X)), A = ncol(X), 
LAD = FALSE, composite = TRUE, M = round(min(10000, max(1000, 1e+09/nrow(X)/ncol(X)))))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="affinelassotest_+3A_y">y</code></td>
<td>

<p>response variable. Quantitative for family=<code>gaussian</code>, or family=<code>poisson</code> (non-negative counts). For family=<code>binomial</code> should be a factor with two levels.
</p>
</td></tr>
<tr><td><code id="affinelassotest_+3A_xdata">Xdata</code></td>
<td>

<p>input matrix, of dimension n x p; each row is an observation vector.
</p>
</td></tr>
<tr><td><code id="affinelassotest_+3A_family">family</code></td>
<td>

<p>response type (see above). Default is <code>gaussian</code>.
</p>
</td></tr>
<tr><td><code id="affinelassotest_+3A_alpha">alpha</code></td>
<td>

<p>desired level of the test.
</p>
</td></tr>
<tr><td><code id="affinelassotest_+3A_beta0">beta0</code></td>
<td>

<p>if known, value of the nuissance parameter. Otherwise it takes beta0=0, and the statistic is asymptotically a pivot for non-Gaussian.
</p>
</td></tr>
<tr><td><code id="affinelassotest_+3A_cc">cc</code></td>
<td>

<p>vector c
</p>
</td></tr>
<tr><td><code id="affinelassotest_+3A_lambdas">lambdas</code></td>
<td>

<p>if not provided, the code performs M Monte Carlo simulation to obtain the empirical distribution <code class="reqn">\Lambda</code> and the corresponding value in the <code class="reqn">\alpha</code>-quantile for testing. Otherwise, vector with all the Monte Carlo values of lambda. Default is NA.
</p>
</td></tr>
<tr><td><code id="affinelassotest_+3A_outrescale">outrescale</code></td>
<td>

<p>object containing all variables corresponding to the rescaling and test options. If not provided, this is calculated authomatically with function <code>processX</code>. Default is NA.
</p>
</td></tr>
<tr><td><code id="affinelassotest_+3A_intercept">intercept</code></td>
<td>

<p>should intercept(s) be fitted (default=TRUE) or set to zero (FALSE).
</p>
</td></tr>
<tr><td><code id="affinelassotest_+3A_group.sizes">group.sizes</code></td>
<td>

<p>the vector of group sizes for affine group lasso. The number of elements is L and sum(group.sizes) should be equal to P. If L==P, then the lasso test is employed, otherwise group lasso. Default is no groups, so <code>rep(1,ncol(X))</code>.
</p>
</td></tr>
<tr><td><code id="affinelassotest_+3A_a">A</code></td>
<td>

<p>if A is a matrix it tests A beta = c. If A is a vector, then it gives the indexes of the parameters to be tested. Used if family=<code>gaussian</code>. Default is to test beta=0, so A=ncol(X).
</p>
</td></tr>
<tr><td><code id="affinelassotest_+3A_lad">LAD</code></td>
<td>

<p>set TRUE if LAD lasso test. Default is FALSE
</p>
</td></tr>
<tr><td><code id="affinelassotest_+3A_composite">composite</code></td>
<td>

<p>set TRUE if composite test (O &amp; +). Default is TRUE
</p>
</td></tr>
<tr><td><code id="affinelassotest_+3A_m">M</code></td>
<td>

<p>number of Monte Carlo Simulations to estimate the distribution <code class="reqn">\Lambda</code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>lambda.alpha</code></td>
<td>
<p>value of <code class="reqn">\lambda</code> in the <code class="reqn">\alpha</code>-quantile</p>
</td></tr>
<tr><td><code>lambda.data</code></td>
<td>
<p>value of <code class="reqn">\lambda</code> for the current data.</p>
</td></tr>
<tr><td><code>rejectH0</code></td>
<td>
<p>result of the test. TRUE if H0 is rejected.</p>
</td></tr>
<tr><td><code>lambdas</code></td>
<td>
<p>values of <code class="reqn">\lambda</code> of the Monte Carlo simulation under the null hypothesis.</p>
</td></tr>
<tr><td><code>outrescale</code></td>
<td>
<p>object containing all the rescaling variables.</p>
</td></tr>
<tr><td><code>pvalue</code></td>
<td>
<p>approximate p-value for current data.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Sylvain Sardy and Jairo Diaz Rodriguez
</p>


<h3>References</h3>

<p>Thresholding tests. Sylvain Sardy, Caroline Giacobino, Jairo Diaz.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>	# Test H0:beta=0
		P=200
		N=20
		s=1
		A=P
		alpha=0.05
		X=matrix(rnorm(N*P),N,P)
		M=100 #Leave the default or select higher value for better level.
	
	#when H0 is not rejected
		beta_scal=0
		beta=c(rep(beta_scal, s), rep(0, P-s)) 
		y=X%*%beta+rnorm(N)
		out=affinelassotest(y,X,gaussian,alpha,M=M)
		print(out$rejectH0)
	
	#when H0 is rejected
		beta_scal=10
		beta=c(rep(beta_scal, s), rep(0, P-s)) 
		y=X%*%beta+rnorm(N)
		out=affinelassotest(y,X,gaussian,alpha,M=M)
		print(out$rejectH0)
</code></pre>

<hr>
<h2 id='chemometrics'>
Chemometrics data set from Sardy (2008)
</h2><span id='topic+chemometrics'></span>

<h3>Description</h3>

<p>Fuel octane level measurements with sample size N = 434 and P = 351 spectrometer measurements.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(chemometrics)</code></pre>


<h3>Format</h3>

<p>A data frame with 434 observations on the following 2 variables.
</p>

<dl>
<dt><code>y</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>x</code></dt><dd><p>a matrix with 351 columns</p>
</dd>
</dl>



<h3>References</h3>

<p>S. Sardy. On the practice of rescaling covariates. International Statistical Review. 2008
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(chemometrics)
</code></pre>

<hr>
<h2 id='internetAd'>
InternetAd data set from Kushmerick (1999)
</h2><span id='topic+internetAd'></span>

<h3>Description</h3>

<p>Classification of N = 2359 possible advertisements on internet pages based on P = 1430 features
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(internetAd)</code></pre>


<h3>Format</h3>

<p>A data frame with 2359 observations on the following 2 variables.
</p>

<dl>
<dt><code>y</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>x</code></dt><dd><p>a matrix with 1430 columns</p>
</dd>
</dl>



<h3>References</h3>

<p>N. Kushmerick. Learning to remove internet advertisements. In Proceedings of the Third Annual Conference on Autonomous Agents. 1999
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(internetAd)
</code></pre>

<hr>
<h2 id='lambdaqut'>
Quantile Universal Threshold, regularization parameter for GLM-lasso
</h2><span id='topic+lambdaqut'></span>

<h3>Description</h3>

<p>Computes the Quantile Universal Threshold for GLM-lasso.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lambdaqut(y, X, family = gaussian, alpha.level = 0.05, M = 1000, 
qut.standardize = TRUE, intercept = TRUE, no.penalty = NULL, offset = NULL,
bootstrap=TRUE,beta0=NA,method='lasso',fixbeta0=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lambdaqut_+3A_y">y</code></td>
<td>

<p>response variable. Quantitative for family=<code>gaussian</code>, or family=<code>poisson</code> (non-negative counts). For family=<code>binomial</code> should be a factor with two levels.
</p>
</td></tr>
<tr><td><code id="lambdaqut_+3A_x">X</code></td>
<td>

<p>input matrix, of dimension n x p; each row is an observation vector.
</p>
</td></tr>
<tr><td><code id="lambdaqut_+3A_family">family</code></td>
<td>

<p>response type (see above). Default is <code>gaussian</code>.
</p>
</td></tr>
<tr><td><code id="lambdaqut_+3A_alpha.level">alpha.level</code></td>
<td>

<p>level, such that quantile <code class="reqn">\tau=(1-</code><code>alpha.level</code><code class="reqn">)/\gamma</code>. Default is 0.05.
</p>
</td></tr>
<tr><td><code id="lambdaqut_+3A_m">M</code></td>
<td>

<p>number of Monte Carlo Simulations to estimate the distribution <code class="reqn">\Lambda</code>. Default is 1000.
</p>
</td></tr>
<tr><td><code id="lambdaqut_+3A_qut.standardize">qut.standardize</code></td>
<td>

<p>standardize matrix X with a quantile-based standardization. Default is TRUE.
</p>
</td></tr>
<tr><td><code id="lambdaqut_+3A_intercept">intercept</code></td>
<td>

<p>should intercept(s) be fitted (default=TRUE) or set to zero (FALSE).
</p>
</td></tr>
<tr><td><code id="lambdaqut_+3A_no.penalty">no.penalty</code></td>
<td>

<p>unpenalized subset of covariates.
</p>
</td></tr>
<tr><td><code id="lambdaqut_+3A_offset">offset</code></td>
<td>

<p>a vector of length <code>n</code> that is included in the linear predictor. Useful for the &quot;poisson&quot; family (e.g. log of exposure time), or for refining a model by starting at a current fit. Default is NULL.
</p>
</td></tr>
<tr><td><code id="lambdaqut_+3A_bootstrap">bootstrap</code></td>
<td>

<p>set TRUE if it is desired to bootstrap matrix X when computing the Quantile Universal Threshold (Random scenario). Default is TRUE.
</p>
</td></tr>
<tr><td><code id="lambdaqut_+3A_beta0">beta0</code></td>
<td>

<p>coefficients of the unpenalized covariates for generating the null data for the Quantile Universal Threshold. By default is <code>NA</code> and it is estimated using the unpenalized covariates and/or the intercept if TRUE.
If it is desired to set <code>beta0</code> in advance, then it should be a vector of size the number of unpenalized covariates including the intercept if <code>intercept=TRUE</code>, in the same order. If there are not unpenalized covariates and <code>intercept=TRUE</code>, then it must be a real number.
</p>
</td></tr>
<tr><td><code id="lambdaqut_+3A_method">method</code></td>
<td>

<p>objective function for the zero thresholding. Select <code>lasso</code> for GLM-lasso or <code>sqrtlasso</code> for Square-root lasso.
</p>
</td></tr>
<tr><td><code id="lambdaqut_+3A_fixbeta0">fixbeta0</code></td>
<td>

<p>used when <code>beta0</code> is numeric. When TRUE, it does not estimate <code>beta0</code> for each monte carlo simulation.
</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>lambda</code></td>
<td>
<p>value of the Quantile Universal Threshold.</p>
</td></tr>
<tr><td><code>Xnew</code></td>
<td>
<p>standardized matrix X; <code>Xnew</code>=<code>X</code><code class="reqn">\times</code><code>scale.factor</code>.</p>
</td></tr>
<tr><td><code>scale.factor</code></td>
<td>
<p>scale factor for <code>Xnew</code>.</p>
</td></tr>
<tr><td><code>lambda.max</code></td>
<td>
<p>smallest lambda that sets the lasso estimates to the zero vector.</p>
</td></tr>
<tr><td><code>beta0</code></td>
<td>
<p>estimated value of the intercept when family is not <code>gaussian</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jairo Diaz
</p>


<h3>References</h3>

<p>C. Giacobino, J. Diaz, S. Sardy, N. Hengartner. Quantile universal threshold for model selection. 2016
Jianqing Fan, Shaojun Guo and Ning Hao. Variance estimation using refitted cross-validation in ultrahigh dimensional regression. Journal of the Royal Statistical Society: Series B. 2012
Stephen Reid, Robert Tibshirani, and Jerome Friedman. A Study of Error Variance Estimation in Lasso Regression. 2013
</p>


<h3>See Also</h3>

<p><code><a href="#topic+qut">qut</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>	X=matrix(rnorm(20*200),20,200)
	y=rnorm(20)+1
	lambda=lambdaqut(y,X,family=gaussian)
	
</code></pre>

<hr>
<h2 id='predict.qut'>
Make predictions from a &quot;qut&quot; object.
</h2><span id='topic+predict.qut'></span><span id='topic+coef.qut'></span>

<h3>Description</h3>

<p>Similar to other predict methods, this function predicts fitted values from a fitted &quot;qut&quot; object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'qut'
predict(object, newx, mode = "glm", offset = NULL,...)
## S3 method for class 'qut'
coef(object, mode = "glm",...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.qut_+3A_object">object</code></td>
<td>

<p>fitted &quot;qut&quot; model object.
</p>
</td></tr>
<tr><td><code id="predict.qut_+3A_newx">newx</code></td>
<td>

<p>matrix of new values for X at which predictions are to be made. Must be a matrix.
</p>
</td></tr>
<tr><td><code id="predict.qut_+3A_mode">mode</code></td>
<td>

<p>make predictions with lasso coefficients (type=<code>lasso</code>) or with fitted glm coefficients (type=<code>glm</code>). Default is <code>glm</code>.
</p>
</td></tr>
<tr><td><code id="predict.qut_+3A_offset">offset</code></td>
<td>

<p>if an offset is used in the fit, then one must be supplied for making predictions
</p>
</td></tr>
<tr><td><code id="predict.qut_+3A_...">...</code></td>
<td>

<p>not used. Other arguments to predict.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector/matrix of fitted values
</p>


<h3>Author(s)</h3>

<p>Jairo Diaz
</p>


<h3>See Also</h3>

<p><code><a href="#topic+qut">qut</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>	set.seed(1234)
	x=matrix(rnorm(200*20),200,20)
	y1=x[,1]*10+rnorm(100)

	fit1=qut(y1,x,family=gaussian,sigma=1)
	predict(fit1,newx=x[1:5,])
	predict(fit1,newx=x[1:5,],mode='lasso')
	y1[1:5]
	
	coef(fit1,mode='lasso')
	coef(fit1,mode='glm')

</code></pre>

<hr>
<h2 id='processX'>
Process X matrix
</h2><span id='topic+processX'></span>

<h3>Description</h3>

<p>Rescales and transforms the X matrix according to the desired parameters, and sets all the options required by the test.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>processX(X, family = gaussian, alpha, intercept = TRUE, group.sizes = rep(1, ncol(X)), 
A = ncol(X), LAD = FALSE, composite = TRUE, 
M = min(10000, max(1000, 1e+10/nrow(X)/ncol(X))))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="processX_+3A_x">X</code></td>
<td>

<p>input matrix, of dimension n x p; each row is an observation vector.
</p>
</td></tr>
<tr><td><code id="processX_+3A_family">family</code></td>
<td>

<p>response type (see above). Default is <code>gaussian</code>.
</p>
</td></tr>
<tr><td><code id="processX_+3A_alpha">alpha</code></td>
<td>

<p>alpha for quantile rescaling; if alpha=0, then no rescaling.
</p>
</td></tr>
<tr><td><code id="processX_+3A_intercept">intercept</code></td>
<td>

<p>should intercept(s) be fitted (default=TRUE) or set to zero (FALSE).
</p>
</td></tr>
<tr><td><code id="processX_+3A_group.sizes">group.sizes</code></td>
<td>

<p>the vector of group sizes for affine group lasso. The number of elements is L and sum(group.sizes) should be equal to P. If L==P, then the lasso test is employed, otherwise group lasso. Default is no groups, so <code>rep(1,ncol(X))</code>.
</p>
</td></tr>
<tr><td><code id="processX_+3A_a">A</code></td>
<td>

<p>if A is a matrix it tests A beta = c. If A is a vector, then it gives the indexes of the parameters to be tested. Used if family=<code>gaussian</code>. Default is to test beta=0, so A=ncol(X).
</p>
</td></tr>
<tr><td><code id="processX_+3A_lad">LAD</code></td>
<td>

<p>set TRUE if LAD lasso test. Default is FALSE
</p>
</td></tr>
<tr><td><code id="processX_+3A_composite">composite</code></td>
<td>

<p>set TRUE if composite test (O &amp; +). Default is TRUE
</p>
</td></tr>
<tr><td><code id="processX_+3A_m">M</code></td>
<td>

<p>number of Monte Carlo Simulations to estimate the distribution <code class="reqn">\Lambda</code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object containing all the variables corresponding to the rescaling and test options.
</p>


<h3>Author(s)</h3>

<p>Sylvain Sardy and Jairo Diaz
</p>


<h3>Examples</h3>

<pre><code class='language-R'>	# Test H0:beta=0
		P=200
		N=20
		s=1
		A=P
		alpha=0.05
		X=matrix(rnorm(N*P),N,P)
		outrescale=processX(X,gaussian,alpha)
		M=100 #Leave the default or select higher value for better level.
	
	#when H0 is not rejected
		beta_scal=0
		beta=c(rep(beta_scal, s), rep(0, P-s)) 
		y=X%*%beta+rnorm(N)
		out=affinelassotest(y,X,gaussian,alpha,M=M,outrescale=outrescale)
		print(out$rejectH0)
	
	#when H0 is rejected
		beta_scal=10
		beta=c(rep(beta_scal, s), rep(0, P-s)) 
		y=X%*%beta+rnorm(N)
		out=affinelassotest(y,X,gaussian,alpha,M=M,outrescale=outrescale)
		print(out$rejectH0)
</code></pre>

<hr>
<h2 id='qut'>
Fit a low dimensional GLM or Square-root lasso using the Quantile Universal Threshold
</h2><span id='topic+qut'></span>

<h3>Description</h3>

<p>Variable selection with GLM-lasso or Square-root lasso choosing the penalty parameter <code class="reqn">\lambda</code> with the Quantile Universal Threshold. The procedure goes towards sparse estimation of the coefficients for good selection of the important predictors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qut(y,X,fit,family=gaussian,alpha.level=0.05,M=1000,qut.standardize=TRUE,
intercept=TRUE,offset=NULL,bootstrap=TRUE,sigma=ifelse(n&gt;2*p,'ols','qut'),beta0='iterglm',
estimator='unbiased',type=c('glmnet','lars','flare'),lambda.seq=0,penalty.factor=rep(1,p),
lambda.min.ratio=ifelse(n&lt;p,0.01,0.0001),nlambda=ifelse(type=='flare',2,100),
lambda=NULL,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="qut_+3A_y">y</code></td>
<td>

<p>response variable. Quantitative for family=<code>gaussian</code>, or family=<code>poisson</code> (non-negative counts). For family=<code>binomial</code> should be a factor with two levels.
</p>
</td></tr>
<tr><td><code id="qut_+3A_x">X</code></td>
<td>

<p>input matrix, of dimension n x p; each row is an observation vector.
</p>
</td></tr>
<tr><td><code id="qut_+3A_fit">fit</code></td>
<td>

<p>a user supplied <code>glmnet</code> or lars object.  Typical usage is to leave it empty so that the program computes the regularization path using the algorithm selected in <code>type</code>. WARNING: use with care, if supplied, object options must match with user supplied options.
</p>
</td></tr>
<tr><td><code id="qut_+3A_family">family</code></td>
<td>

<p>response type (see above). Default is <code>gaussian</code>.
</p>
</td></tr>
<tr><td><code id="qut_+3A_alpha.level">alpha.level</code></td>
<td>

<p>level, such that quantile <code class="reqn">\tau=(1-</code><code>alpha.level</code>). Default is 0.05.
</p>
</td></tr>
<tr><td><code id="qut_+3A_m">M</code></td>
<td>

<p>number of Monte Carlo Simulations to estimate the distribution <code class="reqn">\Lambda</code>. Default is 1000.
</p>
</td></tr>
<tr><td><code id="qut_+3A_qut.standardize">qut.standardize</code></td>
<td>

<p>standardize matrix X with a quantile-based standardization. Default is TRUE. It is not used for sqrt-lasso.
</p>
</td></tr>
<tr><td><code id="qut_+3A_intercept">intercept</code></td>
<td>

<p>should intercept(s) be fitted (default=TRUE) or set to zero (FALSE).
</p>
</td></tr>
<tr><td><code id="qut_+3A_offset">offset</code></td>
<td>

<p>a vector of length <code>n</code> that is included in the linear predictor. Useful for the <code>poisson</code> family (e.g. log of exposure time), or for refining a model by starting at a current fit. Default is NULL.
</p>
</td></tr>
<tr><td><code id="qut_+3A_bootstrap">bootstrap</code></td>
<td>

<p>set TRUE if it is desired to bootstrap matrix X when computing the Quantile Universal Threshold (Random scenario). Default is TRUE.
</p>
</td></tr>
<tr><td><code id="qut_+3A_sigma">sigma</code></td>
<td>

<p>standard deviation of the Gaussian errors. Used only if family=<code>gaussian</code>. When sigma = 'qut', it is estimated based on the Quantile Universal Threshold (default if <code>n &lt;= 2p</code>); when sigma = 'rcv', it is estimated using Refitted Cross Validation in Fan et al. 2012; and when sigma = 'cv', it is estimated using cross validation as in Reid et al. 2013. If <code>sigma</code> is a positive real number, then that value is used for the standard deviation.
If <code>n&gt;p</code> and sigma='ols' it is estimated using the ordinary least squeares estimator (default if <code>n&gt;2p</code>)
</p>
</td></tr>
<tr><td><code id="qut_+3A_beta0">beta0</code></td>
<td>

<p>coefficients of the unpenalized covariates for generating the null data for the Quantile Universal Threshold. When is 'iterglm' (Default) or 'iter', it is estimated using one step iteration of the entire procedure with maximum likelihood estimation or the lasso estimation, respectively. If 'noiter' then it is estimated without iterating.
If it is desired to set <code>beta0</code> in advance, then it should be a vector of size the number of unpenalized covariates including the intercept if <code>intercept=TRUE</code>, in the same order. If there are not unpenalized covariates and <code>intercept=TRUE</code>, then it must be a real number.
</p>
</td></tr>	
<tr><td><code id="qut_+3A_estimator">estimator</code></td>
<td>

<p>type of estimation of sigma when <code>sigma</code> = 'qut'. It can be equal to 'unbiased' (standard unbiased formula), or 'mle' (maximum likelihood formula).
</p>
</td></tr>
<tr><td><code id="qut_+3A_type">type</code></td>
<td>

<p>algorithm for solving the optimization problem. It can be <code>lars</code> (<code>type</code>='lars') or <code>glmnet</code> (<code>type</code>='glmnet') for GLM-lasso, or <code>flare</code> (<code>type</code>='flare') for Square-root lasso. For GLM-lasso, if family is not gaussian, penalty.factor is different from default, or offset different from NULL, glmnet will be always used. Default is 'glmnet'.
</p>
</td></tr>
<tr><td><code id="qut_+3A_lambda.seq">lambda.seq</code></td>
<td>

<p>preset lambda sequence when type = 'glmnet'. If <code>lambda.seq</code>&lt;2 the sequence of lambdas goes decreasing from <code>lambda.max</code> to <code>lambda.qut</code>. If <code>lambda.seq</code>= 0, <code>lambda</code> sequence is equispaced. If <code>lambda.seq</code>= 1, <code>lambda</code> sequence is equispaced in the log scale. Use <code>lambda.seq</code>=2 for <code>glmnet</code> default options. Default is 0.
</p>
</td></tr>
<tr><td><code id="qut_+3A_penalty.factor">penalty.factor</code></td>
<td>

<p>separate penalty factors can be applied to each coefficient. This is a number that multiplies lambda to allow differential shrinkage. Can be 0 for some variables, which implies no shrinkage, and that variable is always included in the model. Default is 1 for all variables (and implicitly infinity for variables listed in exclude). Note: the penalty factors are internally rescaled to sum to n, and the lambda sequence will reflect this change.
</p>
</td></tr>
<tr><td><code id="qut_+3A_lambda.min.ratio">lambda.min.ratio</code></td>
<td>

<p>smallest value for lambda, as a fraction of <code>lambda.max</code>. As in <code>glmnet</code>.
</p>
</td></tr>
<tr><td><code id="qut_+3A_nlambda">nlambda</code></td>
<td>

<p>the number of <code>lambda</code>. As in <code>glmnet</code>. Default is 100.
</p>
</td></tr>
<tr><td><code id="qut_+3A_lambda">lambda</code></td>
<td>

<p>a user supplied <code>lambda</code> sequence. As in <code>glmnet</code>. Not used when <code>type</code>='flare'.
</p>
</td></tr>
<tr><td><code id="qut_+3A_...">...</code></td>
<td>

<p><code>glmnet</code> or <code>lars</code> options.
</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>lambda</code></td>
<td>
<p>value of the Quantile Universal Threshold.</p>
</td></tr>
<tr><td><code>fit</code></td>
<td>
<p>object fitted by <code>glmnet</code> or <code>lars</code>.</p>
</td></tr>
<tr><td><code>beta</code></td>
<td>
<p>coefficients obtained with the Quantile Universal Threshold.</p>
</td></tr>
<tr><td><code>betaglm</code></td>
<td>
<p>coefficients obtained fitting GLM with the non zero coefficients in <code>beta</code>.</p>
</td></tr>
<tr><td><code>beta0</code></td>
<td>
<p>estimated value of the intercept when family is not <code>gaussian</code>.</p>
</td></tr>
<tr><td><code>family</code></td>
<td>
<p>response type</p>
</td></tr>
<tr><td><code>sigma</code></td>
<td>
<p>standard deviation estimate of the errors (when family=<code>gaussian</code>)</p>
</td></tr>
<tr><td><code>scale.factor</code></td>
<td>
<p>scale factor used for standardizing <code class="reqn">X</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jairo Diaz Rodriguez
</p>


<h3>References</h3>

<p>C. Giacobino, J. Diaz, S. Sardy, N. Hengartner. Quantile universal threshold for model selection. 2016
Jianqing Fan, Shaojun Guo and Ning Hao. Variance estimation using refitted cross-validation in ultrahigh dimensional regression. Journal of the Royal Statistical Society: Series B. 2012
Stephen Reid, Robert Tibshirani, and Jerome Friedman. A Study of Error Variance Estimation in Lasso Regression. 2013
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lambdaqut">lambdaqut</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1234)
X=matrix(rnorm(50*500),50,500)
beta=c(rep(10,5),rep(0,500-5))
y=X %*% beta+rnorm(50)

outqut=qut(y,X,type='glmnet',family=gaussian,sigma=1) #Fitting with qut
betaqut=outqut$beta[-1]

outcv=cv.glmnet(X,y,family='gaussian') #fitting with Cross-Validation
betacv=coef(outcv$glmnet.fit,s=outcv$lambda.min)[-1]

results=rbind( 	c(sum(betaqut[1:5]!=0),sum(betaqut[-(1:5)]!=0)),
				c(sum( betacv[1:5]!=0), sum(betacv[-(1:5)]!=0)) )
colnames(results)=c('True Positive','False Positive')
rownames(results)=c('qut','cv')

print(results)

</code></pre>

<hr>
<h2 id='QUT-package'>
Quantile Universal Threshold
</h2><span id='topic+QUT-package'></span>

<h3>Description</h3>

<p>Selection of a threshold parameter <code class="reqn">\lambda</code> for GLM-lasso and Square-root lasso. The method consists in considering a null
model, finding the theoretical distribution of the threshold parameter under
the null, and setting <code class="reqn">\lambda</code> to an upper quantile of that distribution. Although
this strategy does not use the data to select <code class="reqn">\lambda</code> but simply considers
the behavior under the null model, it provides a theoretically and computationally
sound selection.
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> QUT</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL-2</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Author(s)</h3>

<p>Jairo Diaz Rodriguez &lt;jairo.diaz@unige.ch&gt;
</p>


<h3>References</h3>

<p>C. Giacobino, J. Diaz Rodriguez, S. Sardy, N. Hengartner. Quantile universal threshold for model selection. 2016
</p>

<hr>
<h2 id='riboflavin'>
Riboflavin data set from Buhlmann et al. (2013) 
</h2><span id='topic+riboflavin'></span>

<h3>Description</h3>

<p>Dataset of riboflavin production by Bacillus subtilis containing n = 71 observations of p = 4088
predictors (gene expressions) and a one-dimensional response (riboflavin production)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(riboflavin)</code></pre>


<h3>Format</h3>

<p>A data frame with 71 observations on the following 2 variables.
</p>

<dl>
<dt><code>y</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>x</code></dt><dd><p>a matrix with 4088 columns</p>
</dd>
</dl>



<h3>References</h3>

<p>Buhlmann, P., Kalisch, M. and Meier, L. (2013). High-dimensional statistics with a view towards
applications in biology. To appear in Annual Review of Statistics and its Applications.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(riboflavin)
</code></pre>

<hr>
<h2 id='sigmaqut'>
Estimation of <code class="reqn">\sigma</code> based on the Quantile Universal Threshold
</h2><span id='topic+sigmaqut'></span>

<h3>Description</h3>

<p>Estimation of <code class="reqn">\sigma</code> using a two layer estimation scheme as in Refitted Cross Validation, by performing variable selection with the Quantile Universal Threshold, and obtaining the two estimations of sigma with the ordinary least squares estimator.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sigmaqut(y, X, estimator = "unbiased", intercept = TRUE, 
alpha.level = "default", M = 1000, qut.standardize = TRUE, 
penalty.factor = rep(1, p), offset = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sigmaqut_+3A_y">y</code></td>
<td>

<p>response variable. Quantitative for family=<code>gaussian</code>, or family=<code>poisson</code> (non-negative counts). For family=<code>binomial</code> should be a factor with two levels.
</p>
</td></tr>
<tr><td><code id="sigmaqut_+3A_x">X</code></td>
<td>

<p>input matrix, of dimension n x p; each row is an observation vector.
</p>
</td></tr>
<tr><td><code id="sigmaqut_+3A_estimator">estimator</code></td>
<td>

<p>type of estimation of sigma when <code>sigma</code> = 'qut'. It can be equal to 'unbiased' (standard unbiased formula), or 'mle' (maximum likelihood formula).
</p>
</td></tr>
<tr><td><code id="sigmaqut_+3A_intercept">intercept</code></td>
<td>

<p>should intercept(s) be fitted (default=TRUE) or set to zero (FALSE).
</p>
</td></tr>
<tr><td><code id="sigmaqut_+3A_alpha.level">alpha.level</code></td>
<td>

<p>level, such that quantile <code class="reqn">\tau=(1-</code><code>alpha.level</code><code class="reqn">)/\gamma</code>. Default is <code class="reqn">1/(\sqrt{\pi\log(p)})</code>.
</p>
</td></tr>
<tr><td><code id="sigmaqut_+3A_m">M</code></td>
<td>

<p>number of Monte Carlo Simulations to estimate the distribution <code class="reqn">\Lambda</code>. Default is 1000.
</p>
</td></tr>
<tr><td><code id="sigmaqut_+3A_qut.standardize">qut.standardize</code></td>
<td>

<p>standardize matrix X with a quantile-based standardization. Default is TRUE.
</p>
</td></tr>
<tr><td><code id="sigmaqut_+3A_penalty.factor">penalty.factor</code></td>
<td>

<p>separate penalty factors can be applied to each coefficient. As in <code>qut</code>.
</p>
</td></tr>
<tr><td><code id="sigmaqut_+3A_offset">offset</code></td>
<td>

<p>a vector of length <code>n</code> that is included in the linear predictor. As in <code>qut</code>.
</p>
</td></tr>
<tr><td><code id="sigmaqut_+3A_...">...</code></td>
<td>

<p>other <code>glmnet</code> options.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Estimator of <code class="reqn">\sigma</code>
</p>


<h3>Note</h3>

<p><code><a href="#topic+lambdaqut">lambdaqut</a></code>,<code><a href="#topic+qut">qut</a></code>
</p>


<h3>Author(s)</h3>

<p>Jairo Diaz
</p>

<hr>
<h2 id='sigmarcv'>
Variance estimation using refitted cross-validation
</h2><span id='topic+sigmarcv'></span>

<h3>Description</h3>

<p>Variance estimation using refitted cross-validation in ultrahigh dimensional regression.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sigmarcv(y, X, cv = FALSE, fit = NA, intercept = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sigmarcv_+3A_y">y</code></td>
<td>

<p>response variable. Quantitative for family=<code>gaussian</code>, or family=<code>poisson</code> (non-negative counts). For family=<code>binomial</code> should be a factor with two levels.
</p>
</td></tr>
<tr><td><code id="sigmarcv_+3A_x">X</code></td>
<td>

<p>input matrix, of dimension n x p; each row is an observation vector.
</p>
</td></tr>
<tr><td><code id="sigmarcv_+3A_cv">cv</code></td>
<td>

<p>when FALSE, variance is estimated using Refitted Cross Validation in Fan et al. 2012; and when TRUE, it is estimated using cross validation as in Reid et al. 2013. Default is FALSE.
</p>
</td></tr>
<tr><td><code id="sigmarcv_+3A_fit">fit</code></td>
<td>

<p>A user supplied <code>glmnet</code> or lars object.  Typical usage is to leave it empty so that the program computes the regularization path using the algorithm selected in <code>type</code>. WARNING: use with care, if supplied, object options must match with user supplied options.
</p>
</td></tr>
<tr><td><code id="sigmarcv_+3A_intercept">intercept</code></td>
<td>

<p>should intercept(s) be fitted (default=TRUE) or set to zero (FALSE).
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Estimator of <code class="reqn">\sigma</code>
</p>


<h3>Author(s)</h3>

<p>Jianqing Fan, Shaojun Guo. Modified by Jairo Diaz.
</p>


<h3>References</h3>

<p>Jianqing Fan, Shaojun Guo and Ning Hao. Variance estimation using refitted cross-validation in ultrahigh dimensional regression. Journal of the Royal Statistical Society: Series B. 2012
</p>

<hr>
<h2 id='ztf'>
Zero thresholding function
</h2><span id='topic+ztf'></span>

<h3>Description</h3>

<p>Obtains the value of the minimum regularization parameter that sets all coefficients to zero for different types of thresholding tests.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ztf(y,Xdata, family=gaussian, A=ncol(Xdata), cc=NA, intercept=TRUE,
group.sizes=rep(1,ncol(Xdata)), LAD=FALSE, outrescale=NA, composite=TRUE, alpha=0,
M=min(1.e4, max(1000,1.e10/nrow(Xdata)/ncol(Xdata))))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ztf_+3A_y">y</code></td>
<td>

<p>response variable. Quantitative for family=<code>gaussian</code>, or family=<code>poisson</code> (non-negative counts). For family=<code>binomial</code> should be a factor with two levels.
</p>
</td></tr>
<tr><td><code id="ztf_+3A_xdata">Xdata</code></td>
<td>

<p>input matrix, of dimension n x p; each row is an observation vector.
</p>
</td></tr>
<tr><td><code id="ztf_+3A_family">family</code></td>
<td>

<p>response type (see above). Default is <code>gaussian</code>.
</p>
</td></tr>
<tr><td><code id="ztf_+3A_a">A</code></td>
<td>

<p>if A is a matrix it tests A beta = c. If A is a vector, then it gives the indexes of the parameters to be tested. Used if family=<code>gaussian</code>. Default is to test beta=0, so A=ncol(X).
</p>
</td></tr>
<tr><td><code id="ztf_+3A_cc">cc</code></td>
<td>

<p>vector c
</p>
</td></tr>
<tr><td><code id="ztf_+3A_intercept">intercept</code></td>
<td>

<p>should intercept(s) be fitted (default=TRUE) or set to zero (FALSE).
</p>
</td></tr>
<tr><td><code id="ztf_+3A_group.sizes">group.sizes</code></td>
<td>

<p>the vector of group sizes for affine group lasso. The number of elements is L and sum(group.sizes) should be equal to P. If L==P, then the lasso test is employed, otherwise group lasso. Default is no groups, so <code>rep(1,ncol(X))</code>.
</p>
</td></tr>
<tr><td><code id="ztf_+3A_lad">LAD</code></td>
<td>

<p>set TRUE if LAD lasso test. Default is FALSE
</p>
</td></tr>
<tr><td><code id="ztf_+3A_outrescale">outrescale</code></td>
<td>

<p>object containing all variables corresponding to the rescaling and test options. If not provided, this is calculated authomatically with function <code>processX</code>. Default is NA.
</p>
</td></tr>
<tr><td><code id="ztf_+3A_composite">composite</code></td>
<td>

<p>set TRUE if composite test (O &amp; +). Default is TRUE
</p>
</td></tr>
<tr><td><code id="ztf_+3A_alpha">alpha</code></td>
<td>

<p>alpha for quantile rescaling; if alpha=0, then no rescaling.
</p>
</td></tr>
<tr><td><code id="ztf_+3A_m">M</code></td>
<td>

<p>number of Monte Carlo Simulations to estimate the distribution <code class="reqn">\Lambda</code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>value of the minimum regularization parameter that sets all coefficients to zero
</p>


<h3>Author(s)</h3>

<p>Sylvain Sardy and Jairo Diaz
</p>


<h3>Examples</h3>

<pre><code class='language-R'>	# Test H0:beta=0
		P=200
		N=20
		s=1
		A=P
		X=matrix(rnorm(N*P),N,P)
		M=100 #Leave the default or select higher value for better level.
	#when H0 is not rejected
		beta_scal=0
		beta=c(rep(beta_scal, s), rep(0, P-s)) 
		y=X%*%beta+rnorm(N)
		zerolambda=ztf(y,X,M=M)
		print(zerolambda)
	
	#when H0 is rejected
		beta_scal=10
		beta=c(rep(beta_scal, s), rep(0, P-s)) 
		y=X%*%beta+rnorm(N)
		zerolambda=ztf(y,X,M=M)
		print(zerolambda)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
