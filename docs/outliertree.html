<!DOCTYPE html><html><head><title>Help for package outliertree</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {outliertree}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#[.outlieroutputs'><p>Slice or sub-set outliers</p></a></li>
<li><a href='#as.list.outlieroutputs'><p>Convert outlier outputs to R list</p></a></li>
<li><a href='#check.outlierness.bounds'><p>Check values that could potentially flag an observation as outlier</p></a></li>
<li><a href='#extract.training.outliers'><p>Extract outliers found in training data</p></a></li>
<li><a href='#hypothyroid'><p>Data about thyroid hormones for anonymous patients</p></a></li>
<li><a href='#outlier.tree'><p>Outlier Tree</p></a></li>
<li><a href='#predict.outliertree'><p>Predict method for Outlier Tree</p></a></li>
<li><a href='#print.outlieroutputs'><p>Print outliers in human-readable format</p></a></li>
<li><a href='#print.outliertree'><p>Print summary information from Outlier Tree model</p></a></li>
<li><a href='#summary.outlieroutputs'><p>Print outliers in human-readable format</p></a></li>
<li><a href='#summary.outliertree'><p>Print summary information from Outlier Tree model</p></a></li>
<li><a href='#titanic'><p>Data about passengers of the RMS Titanic</p></a></li>
<li><a href='#variable.names.outliertree'><p>Get Variable Names for OutlierTree Model</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Explainable Outlier Detection Through Decision Tree Conditioning</td>
</tr>
<tr>
<td>Version:</td>
<td>1.9.0</td>
</tr>
<tr>
<td>Author:</td>
<td>David Cortes</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>David Cortes &lt;david.cortes.rivera@gmail.com&gt;</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/david-cortes/outliertree">https://github.com/david-cortes/outliertree</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/david-cortes/outliertree/issues">https://github.com/david-cortes/outliertree/issues</a></td>
</tr>
<tr>
<td>Description:</td>
<td>Outlier detection method that flags suspicious values within observations,
  constrasting them against the normal values in a user-readable format, potentially
  describing conditions within the data that make a given outlier more rare.
  Full procedure is described in Cortes (2020) &lt;<a href="https://arxiv.org/abs/2001.00636">arXiv:2001.00636</a>&gt;.
  Loosely based on the 'GritBot' <a href="https://www.rulequest.com/gritbot-info.html">https://www.rulequest.com/gritbot-info.html</a> software.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 1.0.1), methods</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.3.0)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, kableExtra, data.table</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, Rcereal</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-02-09 20:49:40 UTC; david</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-02-09 21:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='+5B.outlieroutputs'>Slice or sub-set outliers</h2><span id='topic++5B.outlieroutputs'></span>

<h3>Description</h3>

<p>Select given rows from outlier results.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'outlieroutputs'
x[i]
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B5B.outlieroutputs_+3A_x">x</code></td>
<td>
<p>An object of class 'outlieroutputs', as returned by e.g. <a href="#topic+predict.outliertree">predict.outliertree</a>.</p>
</td></tr>
<tr><td><code id="+2B5B.outlieroutputs_+3A_i">i</code></td>
<td>
<p>Rows to select. Can pass numbers or strings. Works the same as when selecting
elements from a list.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class 'outlieroutputs' containing only the selected rows.
</p>

<hr>
<h2 id='as.list.outlieroutputs'>Convert outlier outputs to R list</h2><span id='topic+as.list.outlieroutputs'></span>

<h3>Description</h3>

<p>Converts outliers results (an object as returned from <a href="#topic+predict.outliertree">predict.outliertree</a>
or from <a href="#topic+extract.training.outliers">extract.training.outliers</a>) to an R list which can be modified
programatically.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'outlieroutputs'
as.list(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.list.outlieroutputs_+3A_x">x</code></td>
<td>
<p>Outliers flagged by an <a href="#topic+outlier.tree">outlier.tree</a> model, returned by e.g. the
prediction function.</p>
</td></tr>
<tr><td><code id="as.list.outlieroutputs_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The same outliers as a list of lists.
</p>

<hr>
<h2 id='check.outlierness.bounds'>Check values that could potentially flag an observation as outlier</h2><span id='topic+check.outlierness.bounds'></span>

<h3>Description</h3>

<p>Returns, for each numeric/date/timestamp column, a range of values *outside* of which
observations could potentially be flagged as being an outlier in some cluster, and
for categorical/ordinal/boolean columns, the factor levels that can be flagged as
being an outlier in some cluster. If the lower bound is higher than the upper bound, it means
any value can potentially be flagged as outlier.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check.outlierness.bounds(outlier_tree_model)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check.outlierness.bounds_+3A_outlier_tree_model">outlier_tree_model</code></td>
<td>
<p>An Outlier Tree model object as generated by 'outlier.tree'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with column as the names and the bounds or categories as values.
</p>

<hr>
<h2 id='extract.training.outliers'>Extract outliers found in training data</h2><span id='topic+extract.training.outliers'></span>

<h3>Description</h3>

<p>Extracts outliers from a model generated by 'outlier.tree' if
it was passed parameter 'save_outliers' = 'TRUE'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract.training.outliers(outlier_tree_model)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extract.training.outliers_+3A_outlier_tree_model">outlier_tree_model</code></td>
<td>
<p>An Outlier Tree object as returned by 'outlier.tree'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with the outliers, which can be pretty-printed by function
'print' from this same package.
</p>

<hr>
<h2 id='hypothyroid'>Data about thyroid hormones for anonymous patients</h2><span id='topic+hypothyroid'></span>

<h3>Description</h3>

<p>This data contains several obvious outliers from misspellings in data entry.
From Garavan Institute. For more details see link at the bottom.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(hypothyroid)
</code></pre>


<h3>Format</h3>

<p>An object of class <code>data.frame</code> with 2772 rows and 23 columns.
</p>


<h3>Source</h3>

<p><a href="http://archive.ics.uci.edu/ml/datasets/thyroid+disease">http://archive.ics.uci.edu/ml/datasets/thyroid+disease</a>
</p>

<hr>
<h2 id='outlier.tree'>Outlier Tree</h2><span id='topic+outlier.tree'></span>

<h3>Description</h3>

<p>Fit Outlier Tree model to normal data with perhaps some outliers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>outlier.tree(
  df,
  max_depth = 4L,
  min_gain = 0.01,
  z_norm = 2.67,
  z_outlier = 8,
  pct_outliers = 0.01,
  min_size_numeric = 25L,
  min_size_categ = 50L,
  categ_split = "binarize",
  categ_outliers = "tail",
  numeric_split = "raw",
  cols_ignore = NULL,
  follow_all = FALSE,
  gain_as_pct = TRUE,
  save_outliers = FALSE,
  outliers_print = 10L,
  min_decimals = 2L,
  nthreads = parallel::detectCores()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="outlier.tree_+3A_df">df</code></td>
<td>
<p>Data Frame with regular (i.e. non-outlier) data that might contain some outliers. See details for allowed column types.</p>
</td></tr>
<tr><td><code id="outlier.tree_+3A_max_depth">max_depth</code></td>
<td>
<p>Maximum depth of the trees to grow. Can also pass zero, in which case it will only look
for outliers with no conditions (i.e. takes each column as a 1-d distribution and looks for outliers in
there independently of the values in other columns).</p>
</td></tr>
<tr><td><code id="outlier.tree_+3A_min_gain">min_gain</code></td>
<td>
<p>Minimum gain that a split has to produce in order to consider it (both in terms of looking
for outliers in each branch, and in considering whether to continue branching from them). Note that default
value for GritBot is 1e-6, with &lsquo;gain_as_pct' = 'FALSE', but it&rsquo;s recommended to pass higher values (e.g. 1e-1) when using
'gain_as_pct' = 'FALSE'.</p>
</td></tr>
<tr><td><code id="outlier.tree_+3A_z_norm">z_norm</code></td>
<td>
<p>Maximum Z-value (from standard normal distribution) that can be considered as a normal
observation. Note that simply having values above this will not automatically flag observations as outliers,
nor does it assume that columns follow normal distributions. Also used for categorical and ordinal columns
for building approximate confidence intervals of proportions.</p>
</td></tr>
<tr><td><code id="outlier.tree_+3A_z_outlier">z_outlier</code></td>
<td>
<p>Minimum Z-value that can be considered as an outlier. There must be a large gap in the
Z-value of the next observation in sorted order to consider it as outlier, given by (z_outlier - z_norm).
Decreasing this parameter is likely to result in more observations being flagged as outliers.
Ignored for categorical and ordinal columns.</p>
</td></tr>
<tr><td><code id="outlier.tree_+3A_pct_outliers">pct_outliers</code></td>
<td>
<p>Approximate max percentage of outliers to expect in a given branch.</p>
</td></tr>
<tr><td><code id="outlier.tree_+3A_min_size_numeric">min_size_numeric</code></td>
<td>
<p>Minimum size that branches need to have when splitting a numeric column. In order to look for
outliers in a given branch for a numeric column, it must have a minimum of twice this number
of observations.</p>
</td></tr>
<tr><td><code id="outlier.tree_+3A_min_size_categ">min_size_categ</code></td>
<td>
<p>Minimum size that branches need to have when splitting a categorical or ordinal column. In order to
look for outliers in a given branch for a categorical, ordinal, or boolean column, it must have a minimum of twice
this number of observations.</p>
</td></tr>
<tr><td><code id="outlier.tree_+3A_categ_split">categ_split</code></td>
<td>
<p>How to produce categorical-by-categorical splits. Options are:
</p>

<ul>
<li><p> &lsquo;&quot;binarize&quot;' : Will binarize the target variable according to whether it&rsquo;s equal to each present category
within it (greater/less for ordinal), and split each binarized variable separately.
</p>
</li>
<li><p> '&quot;bruteforce&quot;' : Will evaluate each possible binary split of the categories (that is, it evaluates 2^n potential
splits every time). Note that trying this when there are many categories in a column will result
in exponential computation time that might never finish.
</p>
</li>
<li><p> '&quot;separate&quot;' : Will create one branch per category of the splitting variable (this is how GritBot handles them).
</p>
</li></ul>
</td></tr>
<tr><td><code id="outlier.tree_+3A_categ_outliers">categ_outliers</code></td>
<td>
<p>How to look for outliers in categorical variables. Options are:
</p>

<ul>
<li><p> '&quot;tail&quot;' : Will try to flag outliers if there is a large gap between proportions in sorted order, and this
gap is unexpected given the prior probabilities. Such criteria tends to sometimes flag too many
uninteresting outliers, but is able to detect more cases and recognize outliers when there is no
single dominant category.
</p>
</li>
<li><p> '&quot;majority&quot;' : Will calculate an equivalent to z-value according to the number of observations that do not
belong to the non-majority class, according to formula '(n-n_maj)/(n * p_prior) &lt; 1/z_outlier^2'.
Such criteria  tends to miss many interesting outliers and will only be able to flag outliers in
large sample sizes. This is the approach used by GritBot.
</p>
</li></ul>
</td></tr>
<tr><td><code id="outlier.tree_+3A_numeric_split">numeric_split</code></td>
<td>
<p>How to determine the split point in numeric variables. Options are:
</p>

<ul>
<li><p> &lsquo;&quot;mid&quot;' : Will calculate the midpoint between the largest observation that goes to the &rsquo;&lt;=' branch and the
smallest observation that goes to the '&gt;' branch.
</p>
</li>
<li><p> &lsquo;&quot;raw&quot;' : Will set the split point as the value of the largest observation that goes to the &rsquo;&lt;=' branch.
</p>
</li></ul>

<p>This doesn't affect how outliers are determined in the training data passed in 'df', but it does
affect the way in which they are presented and the way in which new outliers are detected when
using 'predict'. '&quot;mid&quot;' is recommended for continuous-valued variables, while '&quot;raw&quot;' will
provide more readable explanations for counts data at the expense of perhaps slightly worse
generalizability to unseen data.</p>
</td></tr>
<tr><td><code id="outlier.tree_+3A_cols_ignore">cols_ignore</code></td>
<td>
<p>Vector containing columns which will not be split, but will be evaluated for usage
in splitting other columns. Can pass either a logical (boolean) vector with the same number of columns
as 'df', or a character vector of column names (must match with those of 'df').
Pass 'NULL' to use all columns.</p>
</td></tr>
<tr><td><code id="outlier.tree_+3A_follow_all">follow_all</code></td>
<td>
<p>Whether to continue branching from each split that meets the size and gain criteria.
This will produce exponentially many more branches, and if depth is large, might take forever to finish.
Will also produce a lot more spurious outiers. Not recommended.</p>
</td></tr>
<tr><td><code id="outlier.tree_+3A_gain_as_pct">gain_as_pct</code></td>
<td>
<p>Whether the minimum gain above should be taken in absolute terms, or as a percentage of
the standard deviation (for numerical columns) or shannon entropy (for categorical columns). Taking it in
absolute terms will prefer making more splits on columns that have a large variance, while taking it as a
percentage might be more restrictive on them and might create deeper trees in some columns. For GritBot
this parameter would always be 'FALSE'. Recommended to pass higher values for 'min_gain' when passing 'FALSE'
here. Not that when 'gain_as_pct' = 'FALSE', the results will be sensitive to the scales of variables.</p>
</td></tr>
<tr><td><code id="outlier.tree_+3A_save_outliers">save_outliers</code></td>
<td>
<p>Whether to store outliers detected in 'df' in the object that is returned.
These outliers can then be extracted from the returned object through function
'extract.training.outliers'.</p>
</td></tr>
<tr><td><code id="outlier.tree_+3A_outliers_print">outliers_print</code></td>
<td>
<p>Maximum number of flagged outliers in the training data to print after fitting
the model. Pass zero or 'NULL' to avoid printing any. Outliers can be printed from resulting data frame
afterwards through the 'predict' method, or through the 'print' method (on the extracted outliers, not on
the model object) if passing 'save_outliers' = 'TRUE'.</p>
</td></tr>
<tr><td><code id="outlier.tree_+3A_min_decimals">min_decimals</code></td>
<td>
<p>Minimum number of decimals to use when printing numeric values for the flagged
outliers. The number of decimals will be dynamically increased according to the relative magnitudes of the
values being reported. Ignored when passing 'outliers_print=0' or 'outliers_print=FALSE'.</p>
</td></tr>
<tr><td><code id="outlier.tree_+3A_nthreads">nthreads</code></td>
<td>
<p>Number of parallel threads to use. When fitting the model, it will only use up to one
thread per column, while for prediction it will use up to one thread per row. The more threads that are
used, the more memory will be required and allocated, so using more threads will not always lead to better
speed. Can be changed after the object is already initialized.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Explainable outlier detection through decision-tree grouping. Tries to detect outliers by
generating decision trees that attempt to &quot;predict&quot; the values of each column based on each other column,
testing in each branch of every tried split (if it meets some minimum criteria) whether there are
observations that seem too distant from the others in a 1-D distribution for the column that the split
tries to &quot;predict&quot; (unlike other methods, this will not generate a score for each observation).
</p>
<p>Splits are based on gain, while outlierness is based on confidence intervals. Similar in spirit to the GritBot
software developed by RuleQuest research.
</p>
<p>Supports columns of types numeric (either as type 'numeric' or 'integer'), categorical (either as type 'character' or
'factor' with unordered levels), boolean (as type 'logical'), and ordinal (as type 'factor' with ordered levels as checked by
'is.ordered'). Can handle missing values in any of them. Can also pass dates/timestamps that will get converted to
numeric but shown as dates/timestamps in the output. Offers option to set columns to be used only for generating
conditions without looking at outliers in them.
</p>
<p>Infinite values will be taken into consideration when the column is used to split another column
(that is, +inf will go into the branch that is greater than something, -inf into the other branch),
but when a column is the target of the split, they will be taken as missing - that is, it will not report
infinite values as outliers.
</p>


<h3>Value</h3>

<p>An object with the fitted model that can be used to detect more outliers in new data, and from
which outliers in the training data can be extracted (when passing 'save_outliers' = 'TRUE').
</p>


<h3>References</h3>


<ul>
<li><p> GritBot software: <a href="https://www.rulequest.com/gritbot-info.html">https://www.rulequest.com/gritbot-info.html</a>
</p>
</li>
<li><p> Cortes, David. &quot;Explainable outlier detection through decision tree conditioning.&quot; arXiv preprint arXiv:2001.00636 (2020).
</p>
</li></ul>



<h3>See Also</h3>

<p><a href="#topic+predict.outliertree">predict.outliertree</a> <a href="#topic+extract.training.outliers">extract.training.outliers</a> <a href="#topic+hypothyroid">hypothyroid</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(outliertree)

### example dataset with interesting outliers
data(hypothyroid)

### fit the model and get a print of outliers
model &lt;- outlier.tree(hypothyroid,
  outliers_print=10,
  save_outliers=TRUE,
  nthreads=1)

### extract outlier info as R list
outliers &lt;- extract.training.outliers(model)
summary(outliers)

### information for row 745 (list of lists)
outliers[[745]]

### outliers can be sliced too
outliers[700:1000]

### use custom row names
df.w.names &lt;- hypothyroid
row.names(df.w.names) &lt;- paste0("rownum", 1:nrow(hypothyroid))
outliers.w.names &lt;- predict(model, df.w.names, return_outliers=TRUE, nthreads=1)
outliers.w.names[["rownum745"]]
</code></pre>

<hr>
<h2 id='predict.outliertree'>Predict method for Outlier Tree</h2><span id='topic+predict.outliertree'></span>

<h3>Description</h3>

<p>Predict method for Outlier Tree
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'outliertree'
predict(
  object,
  newdata,
  outliers_print = 15L,
  min_decimals = 2L,
  return_outliers = TRUE,
  nthreads = object$nthreads,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.outliertree_+3A_object">object</code></td>
<td>
<p>An Outlier Tree object as returned by 'outlier.tree'.</p>
</td></tr>
<tr><td><code id="predict.outliertree_+3A_newdata">newdata</code></td>
<td>
<p>A Data Frame in which to look for outliers according to the fitted model.</p>
</td></tr>
<tr><td><code id="predict.outliertree_+3A_outliers_print">outliers_print</code></td>
<td>
<p>How many outliers to print. Pass zero or 'NULL' to avoid printing them. Must pass
at least one of 'outliers_print' and 'return_outliers'.</p>
</td></tr>
<tr><td><code id="predict.outliertree_+3A_min_decimals">min_decimals</code></td>
<td>
<p>Minimum number of decimals to use when printing numeric values for the flagged
outliers. The number of decimals will be dynamically increased according to the relative magnitudes of the
values being reported. Ignored when passing 'outliers_print=0' or 'outliers_print=FALSE'.</p>
</td></tr>
<tr><td><code id="predict.outliertree_+3A_return_outliers">return_outliers</code></td>
<td>
<p>Whether to return the outliers in an R object (otherwise will just print them).</p>
</td></tr>
<tr><td><code id="predict.outliertree_+3A_nthreads">nthreads</code></td>
<td>
<p>Number of parallel threads to use. Parallelization is done by rows.</p>
</td></tr>
<tr><td><code id="predict.outliertree_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that after loading a serialized object from 'outlier.tree' through 'readRDS' or 'load',
it will only de-serialize the underlying C++ object upon running 'predict' or 'print', so the first run will
be slower, while subsequent runs will be faster as the C++ object will already be in-memory.
</p>


<h3>Value</h3>

<p>If passing 'return_outliers' = 'TRUE', will return a list of lists with the outliers and their
information (each row is an entry in the first list, with the same names as the rows in the input data
frame), which can be printed into a human-readable format after-the-fact through functions
'print' and 'summary' (they do the same thing).
Otherwise, will not return anything, but will print the outliers if any are detected.
Note that, while the object that is returned will display a short summary of only some observations
when printing it in the console, it actually contains information for all rows, and can be subsetted
to obtain information specific to one row.
</p>


<h3>See Also</h3>

<p><a href="#topic+outlier.tree">outlier.tree</a> <a href="#topic+print.outlieroutputs">print.outlieroutputs</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(outliertree)
### random data frame with an obvious outlier
nrows = 100
set.seed(1)
df = data.frame(
    numeric_col1 = c(rnorm(nrows - 1), 1e6),
    numeric_col2 = rgamma(nrows, 1),
    categ_col    = sample(c('categA', 'categB', 'categC'),
        size = nrows, replace = TRUE)
    )
    
### test data frame with another obvious outlier
nrows_test = 50
df_test = data.frame(
    numeric_col1 = rnorm(nrows_test),
    numeric_col2 = c(-1e6, rgamma(nrows_test - 1, 1)),
    categ_col    = sample(c('categA', 'categB', 'categC'),
        size = nrows_test, replace = TRUE)
)
    
### fit model on training data
outliers_model = outlier.tree(df, outliers_print=FALSE, nthreads=1)

### find the test outlier
test_outliers = predict(outliers_model, df_test,
    outliers_print = 1, return_outliers = TRUE,
    nthreads = 1)

### retrieve the outlier info (for row 1) as an R list
test_outliers[[1]]

### to turn it into a 6-column table:
# dt = t(data.table::as.data.table(test_outliers))
</code></pre>

<hr>
<h2 id='print.outlieroutputs'>Print outliers in human-readable format</h2><span id='topic+print.outlieroutputs'></span>

<h3>Description</h3>

<p>Pretty-prints outliers as output by the 'predict' function from an Outlier Tree
model (as generated by function 'outlier.tree'), or by 'extract.training.outliers'.
Same as function 'summary'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'outlieroutputs'
print(x, outliers_print = 15L, min_decimals = 2L, only_these_rows = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.outlieroutputs_+3A_x">x</code></td>
<td>
<p>Outliers as returned by predict method on an object from 'outlier.tree'.</p>
</td></tr>
<tr><td><code id="print.outlieroutputs_+3A_outliers_print">outliers_print</code></td>
<td>
<p>Maximum number of outliers to print.</p>
</td></tr>
<tr><td><code id="print.outlieroutputs_+3A_min_decimals">min_decimals</code></td>
<td>
<p>Minimum number of decimals to use when printing numeric values for the flagged
outliers. The number of decimals will be dynamically increased according to the relative magnitudes of the
values being reported. Ignored when passing 'outliers_print=0' or 'outliers_print=FALSE'.</p>
</td></tr>
<tr><td><code id="print.outlieroutputs_+3A_only_these_rows">only_these_rows</code></td>
<td>
<p>Specific rows to print (either numbers if the row names in the original
data frame were null, or the row names they had if non-null). Pass 'NULL' to print information
about potentially all rows</p>
</td></tr>
<tr><td><code id="print.outlieroutputs_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The same input 'x' that was passed (as 'invisible').
</p>


<h3>See Also</h3>

<p><a href="#topic+outlier.tree">outlier.tree</a> <a href="#topic+predict.outliertree">predict.outliertree</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### Example re-printing results for selected rows
library(outliertree)
data("hypothyroid")

### Fit model
otree &lt;- outlier.tree(hypothyroid,
  nthreads=1,
  outliers_print=0)
  
### Store predictions
pred &lt;- predict(otree,
  hypothyroid,
  outliers_print=0,
  return_outliers=TRUE,
  nthreads=1)
  
### Print stored predictions
### Row 531 is an outlier, but 532 is not
print(pred, only_these_rows = c(531, 532))
</code></pre>

<hr>
<h2 id='print.outliertree'>Print summary information from Outlier Tree model</h2><span id='topic+print.outliertree'></span>

<h3>Description</h3>

<p>Displays general statistics from a fitted Outlier Tree model (same as 'summary').
For printing the outliers discovered, use function 'print' on the returned outliers
(e.g. from 'predict'), not on the model object iself.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'outliertree'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.outliertree_+3A_x">x</code></td>
<td>
<p>An Outlier Tree model as produced by function 'outlier.tree'.</p>
</td></tr>
<tr><td><code id="print.outliertree_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that after loading a serialized object from 'outlier.tree' through 'readRDS' or 'load',
it will only de-serialize the underlying C++ object upon running 'predict' or 'print', so the first run will
be slower, while subsequent runs will be faster as the C++ object will already be in-memory.
</p>


<h3>Value</h3>

<p>The same input 'x' that was passed (as 'invisible').
</p>

<hr>
<h2 id='summary.outlieroutputs'>Print outliers in human-readable format</h2><span id='topic+summary.outlieroutputs'></span>

<h3>Description</h3>

<p>Pretty-prints outliers as output by the 'predict' function from an Outlier Tree
model (as generated by function 'outlier.tree'), or by 'extract.training.outliers'.
Same as function 'print' (see the documentation of 'print' for more information about
the parameters).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'outlieroutputs'
summary(object, outliers_print = 15, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.outlieroutputs_+3A_object">object</code></td>
<td>
<p>Outliers as returned by predict method on an object from 'outlier.tree'.</p>
</td></tr>
<tr><td><code id="summary.outlieroutputs_+3A_outliers_print">outliers_print</code></td>
<td>
<p>Maximum number of outliers to print.</p>
</td></tr>
<tr><td><code id="summary.outlieroutputs_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The same 'object' input, returned invisibly.
</p>


<h3>See Also</h3>

<p><a href="#topic+print.outlieroutputs">print.outlieroutputs</a>
</p>

<hr>
<h2 id='summary.outliertree'>Print summary information from Outlier Tree model</h2><span id='topic+summary.outliertree'></span>

<h3>Description</h3>

<p>Displays general statistics from a fitted Outlier Tree model (same as 'print').
For printing the outliers discovered, use function 'print' on the returned outliers
(e.g. from 'predict'), not on the model object iself.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'outliertree'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.outliertree_+3A_object">object</code></td>
<td>
<p>An Outlier Tree model as produced by function 'outlier.tree'.</p>
</td></tr>
<tr><td><code id="summary.outliertree_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The same input 'object' that was passed (as 'invisible').
</p>


<h3>See Also</h3>

<p><a href="#topic+print.outliertree">print.outliertree</a>
</p>

<hr>
<h2 id='titanic'>Data about passengers of the RMS Titanic</h2><span id='topic+titanic'></span>

<h3>Description</h3>

<p>This dataset contains information about 1,309 of the passengers who boarded the
<a href="https://en.wikipedia.org/wiki/Titanic">RMS Titanic ship</a> for its last
trip in the year 1912 (spoiler: the ship doesn't reach its destination).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(titanic)
</code></pre>


<h3>Format</h3>

<p>An object of class <code>data.frame</code> with 1309 rows and 14 columns.
</p>


<h3>Source</h3>

<p><a href="https://github.com/jbryer/CompStats/raw/master/Data/titanic3.csv">https://github.com/jbryer/CompStats/raw/master/Data/titanic3.csv</a>
</p>

<hr>
<h2 id='variable.names.outliertree'>Get Variable Names for OutlierTree Model</h2><span id='topic+variable.names.outliertree'></span>

<h3>Description</h3>

<p>Returns the variable names from the data to which an OutlierTree model was fitted.
</p>
<p>Columns will be returned in the following order according to their types, regardless of the order
that they had in theoriginal input data:</p>

<ul>
<li><p>1. Numeric.
</p>
</li>
<li><p>2. Date.
</p>
</li>
<li><p>3. Timestamp (POSIXct, POSIXlt).
</p>
</li>
<li><p>4. Categorical.
</p>
</li>
<li><p>5. Boolean / logical.
</p>
</li>
<li><p>6. Ordinal.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'outliertree'
variable.names(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="variable.names.outliertree_+3A_object">object</code></td>
<td>
<p>An OutlierTree model as returned by function <a href="#topic+outlier.tree">outlier.tree</a>.</p>
</td></tr>
<tr><td><code id="variable.names.outliertree_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector with the variable names.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
