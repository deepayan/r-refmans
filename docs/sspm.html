<!DOCTYPE html><html lang="en"><head><title>Help for package sspm</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {sspm}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#sspm-package'><p>sspm: Spatial Surplus Production Model Framework for Northern Shrimp Populations</p></a></li>
<li><a href='#+25+26gt+3B+25'><p>Pipe operator</p></a></li>
<li><a href='#+24+2Csspm_boundary-method'><p>Extract methods</p></a></li>
<li><a href='#as_discretization_method'><p>Cast into a <code>discretization_method</code> object</p></a></li>
<li><a href='#borealis_simulated'><p>Simulated biomass data</p></a></li>
<li><a href='#catch_simulated'><p>Simulated catch data</p></a></li>
<li><a href='#discretization_method-class'><p>sspm discretization method class</p></a></li>
<li><a href='#fit_smooths'><p>Fit the GAM part of a sspm model</p></a></li>
<li><a href='#map_formula'><p>Map model formula onto a sspm_dataset object</p></a></li>
<li><a href='#method_func'><p>Accessing OR replacing <code>discretization_method</code> model elements</p></a></li>
<li><a href='#plot'><p>Plot <code>sspm</code> objects</p></a></li>
<li><a href='#predator_simulated'><p>Simulated predator data</p></a></li>
<li><a href='#predict'><p>Predict with a SPM model</p></a></li>
<li><a href='#predict_intervals'><p>GAM confidence and prediction intervals</p></a></li>
<li><a href='#raw_formula'><p>Accessing OR replacing <code>sspm_formula</code> model elements</p></a></li>
<li><a href='#sfa_boundaries'><p>SFA boundaries data</p></a></li>
<li><a href='#smooth_time'><p>sspm Smoothing functions</p></a></li>
<li><a href='#spm'><p>Fit an SPM model</p></a></li>
<li><a href='#spm_aggregate'><p>Aggregate a dataset or fit data variable based on a boundary</p></a></li>
<li><a href='#spm_aggregate_catch'><p>Update biomass value from catch adta</p></a></li>
<li><a href='#spm_as_boundary'><p>Create a sspm_boundary object</p></a></li>
<li><a href='#spm_as_dataset'><p>Create a <code>sspm_dataset</code> dataset structure</p></a></li>
<li><a href='#spm_boundaries+2Csspm_boundary-method'><p>Accessing OR replacing <code>sspm_boundary</code> model elements</p></a></li>
<li><a href='#spm_data'><p>Accessing OR replacing <code>sspm_dataset</code> model elements</p></a></li>
<li><a href='#spm_discretize'><p>Discretize a <code>sspm</code> model object</p></a></li>
<li><a href='#spm_lag'><p>Create lagged columns in a sspm smoothed data slot</p></a></li>
<li><a href='#spm_methods'><p>Get the list of available discretization methods</p></a></li>
<li><a href='#spm_name'><p>Accessing OR replacing <code>sspm</code> model elements</p></a></li>
<li><a href='#spm_smooth'><p>Smooth a variable in a sspm dataset</p></a></li>
<li><a href='#spm_smooth_methods'><p>Get the list of available smoothing methods</p></a></li>
<li><a href='#spm_split'><p>Split data in test and train sets</p></a></li>
<li><a href='#spm_unique_ID+2Csspm_fit-method'><p>Accessing OR replacing <code>sspm_fit</code> model elements</p></a></li>
<li><a href='#sspm'><p>Create a <code>sspm</code> model object</p></a></li>
<li><a href='#sspm_boundary-class'><p>sspm boundary structure</p></a></li>
<li><a href='#sspm_dataset-class'><p>sspm dataset structure</p></a></li>
<li><a href='#sspm_discrete_boundary-class'><p>sspm discrete boundary structure</p></a></li>
<li><a href='#sspm_fit-class'><p>sspm fit</p></a></li>
<li><a href='#sspm_formula-class'><p>sspm formula object</p></a></li>
<li><a href='#sspm-class'><p>sspm model class</p></a></li>
<li><a href='#summary'><p>Summarises <code>sspm_fit</code> objects</p></a></li>
<li><a href='#tesselate_voronoi'><p>Perform voronoi tesselation</p></a></li>
<li><a href='#triangulate_delaunay'><p>Perform delaunay triangulation</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Spatial Surplus Production Model Framework for Northern Shrimp
Populations</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.3</td>
</tr>
<tr>
<td>Description:</td>
<td>Implement a GAM-based (Generalized Additive Models) spatial surplus 
    production model (spatial SPM), aimed at modeling northern shrimp population 
    in Atlantic Canada but potentially to any stock in any location. The package 
    is opinionated in its implementation of SPMs as it internally makes the choice 
    to use penalized spatial gams with time lags. However, it also aims to provide 
    options for the user to customize their model. The methods are described in 
    Pedersen et al. (2022, <a href="https://www.dfo-mpo.gc.ca/csas-sccs/Publications/ResDocs-DocRech/2022/2022_062-eng.html">https://www.dfo-mpo.gc.ca/csas-sccs/Publications/ResDocs-DocRech/2022/2022_062-eng.html</a>).</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/pedersen-fisheries-lab/sspm/issues">https://github.com/pedersen-fisheries-lab/sspm/issues</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://pedersen-fisheries-lab.github.io/sspm/">https://pedersen-fisheries-lab.github.io/sspm/</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>Depends:</td>
<td>sf, mgcv, R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, methods, units, checkmate, cli, tibble, magrittr,
tidyr, dplyr, purrr, stringr, rlang</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 3.0.0), covr, ggplot2, ggforce, lwgeom, tweedie,
sfdct, knitr, rmarkdown</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>LazyData:</td>
<td>True</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-02-11 20:54:13 UTC; vlucet</td>
</tr>
<tr>
<td>Author:</td>
<td>Valentin Lucet [aut, cre, cph],
  Eric Pedersen [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Valentin Lucet &lt;valentin.lucet@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-02-12 20:20:01 UTC</td>
</tr>
</table>
<hr>
<h2 id='sspm-package'>sspm: Spatial Surplus Production Model Framework for Northern Shrimp Populations</h2><span id='topic+sspm-package'></span>

<h3>Description</h3>

<p><img src="../help/figures/logo.png" style='float: right' alt='logo' width='120' />
</p>
<p>Implement a GAM-based (Generalized Additive Models) spatial surplus production model (spatial SPM), aimed at modeling northern shrimp population in Atlantic Canada but potentially to any stock in any location. The package is opinionated in its implementation of SPMs as it internally makes the choice to use penalized spatial gams with time lags. However, it also aims to provide options for the user to customize their model. The methods are described in Pedersen et al. (2022, <a href="https://www.dfo-mpo.gc.ca/csas-sccs/Publications/ResDocs-DocRech/2022/2022_062-eng.html">https://www.dfo-mpo.gc.ca/csas-sccs/Publications/ResDocs-DocRech/2022/2022_062-eng.html</a>).
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Valentin Lucet <a href="mailto:valentin.lucet@gmail.com">valentin.lucet@gmail.com</a> [copyright holder]
</p>
<p>Authors:
</p>

<ul>
<li><p> Eric Pedersen <a href="mailto:eric.pedersen@concordia.ca">eric.pedersen@concordia.ca</a>
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://pedersen-fisheries-lab.github.io/sspm/">https://pedersen-fisheries-lab.github.io/sspm/</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/pedersen-fisheries-lab/sspm/issues">https://github.com/pedersen-fisheries-lab/sspm/issues</a>
</p>
</li></ul>


<hr>
<h2 id='+25+26gt+3B+25'>Pipe operator</h2><span id='topic++25+3E+25'></span>

<h3>Description</h3>

<p>See <code>magrittr::<a href="magrittr.html#topic+pipe">%&gt;%</a></code> for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lhs %&gt;% rhs
</code></pre>


<h3>Value</h3>

<p>pipe operator
</p>

<hr>
<h2 id='+24+2Csspm_boundary-method'>Extract methods</h2><span id='topic++24+2Csspm_boundary-method'></span><span id='topic+extract'></span><span id='topic++24+2Csspm_discrete_boundary-method'></span><span id='topic++24+2Csspm_dataset-method'></span><span id='topic++24+2Csspm-method'></span>

<h3>Description</h3>

<p>WIP extract variables from sspm objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'sspm_boundary'
x$name

## S4 method for signature 'sspm_discrete_boundary'
x$name

## S4 method for signature 'sspm_dataset'
x$name

## S4 method for signature 'sspm'
x$name
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="+2B24+2B2Csspm_boundary-method_+3A_x">x</code></td>
<td>
<p><strong>[sspm_...]</strong> An object from this package.</p>
</td></tr>
<tr><td><code id="+2B24+2B2Csspm_boundary-method_+3A_name">name</code></td>
<td>
<p><strong>[character]</strong> The name of the column</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The <code>data.frame</code> matching the request.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sfa_boundaries
bounds &lt;- spm_as_boundary(boundaries = sfa_boundaries,
                          boundary = "sfa")
bounds$area_sfa

</code></pre>

<hr>
<h2 id='as_discretization_method'>Cast into a <code>discretization_method</code> object</h2><span id='topic+as_discretization_method'></span><span id='topic+as_discretization_method+2Ccharacter+2CANY-method'></span><span id='topic+as_discretization_method+2Cmissing+2Cfunction-method'></span>

<h3>Description</h3>

<p>Cast a character value into <code><a href="#topic+discretization_method-class">discretization_method</a></code>
object, using the list of possible methods in <code><a href="#topic+spm_methods">spm_methods</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_discretization_method(name, method)

## S4 method for signature 'character,ANY'
as_discretization_method(name)

## S4 method for signature 'missing,function'
as_discretization_method(method)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as_discretization_method_+3A_name">name</code></td>
<td>
<p><strong>[character]</strong> The name of the method.</p>
</td></tr>
<tr><td><code id="as_discretization_method_+3A_method">method</code></td>
<td>
<p><strong>[character]</strong> If custom method, the function to use. See
<code><a href="#topic+spm_discretize">spm_discretize</a></code> for more details.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An objectof class <code><a href="#topic+discretization_method-class">discretization_method</a></code>.
</p>


<h3>See Also</h3>

<p><a href="#topic+spm_methods">spm_methods</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>as_discretization_method("tesselate_voronoi")

</code></pre>

<hr>
<h2 id='borealis_simulated'>Simulated biomass data</h2><span id='topic+borealis_simulated'></span>

<h3>Description</h3>

<p>Simulated biomass data for test and practice.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>borealis_simulated
</code></pre>


<h3>Format</h3>

<p>A data frame:
</p>

<dl>
<dt>year_f</dt><dd><p>Year as a factor</p>
</dd>
<dt>sfa</dt><dd><p>SFA ID number</p>
</dd>
<dt>weight_per_km2</dt><dd><p>Simualated biomass in kg per km2</p>
</dd>
<dt>temp_at_bottom</dt><dd><p>Simulated water temperature</p>
</dd>
<dt>lon_dec</dt><dd><p>Longitude</p>
</dd>
<dt>lat_dec</dt><dd><p>Latitude</p>
</dd>
<dt>row</dt><dd><p>Row ID</p>
</dd>
<dt>uniqueID</dt><dd><p>Unique ID for simulated observation</p>
</dd>
</dl>


<hr>
<h2 id='catch_simulated'>Simulated catch data</h2><span id='topic+catch_simulated'></span>

<h3>Description</h3>

<p>Simulated catch data for test and practice.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>catch_simulated
</code></pre>


<h3>Format</h3>

<p>A data frame:
</p>

<dl>
<dt>year_f</dt><dd><p>Year as a factor</p>
</dd>
<dt>sfa</dt><dd><p>SFA ID number</p>
</dd>
<dt>catch</dt><dd><p>Simualated catch in kg</p>
</dd>
<dt>lon_dec</dt><dd><p>Longitude</p>
</dd>
<dt>lat_dec</dt><dd><p>Latitude</p>
</dd>
<dt>row</dt><dd><p>Row ID</p>
</dd>
<dt>uniqueID</dt><dd><p>Unique ID for simulated observation</p>
</dd>
</dl>


<hr>
<h2 id='discretization_method-class'>sspm discretization method class</h2><span id='topic+discretization_method-class'></span>

<h3>Description</h3>

<p>This class encapsulates a name and a method (function) used for
discretization.
</p>


<h3>Slots</h3>


<dl>
<dt><code>name</code></dt><dd><p><strong>[character]</strong> Name of the discretization method.</p>
</dd>
<dt><code>method</code></dt><dd><p><strong>[function]</strong> Function used for discretization.</p>
</dd>
</dl>

<hr>
<h2 id='fit_smooths'>Fit the GAM part of a sspm model</h2><span id='topic+fit_smooths'></span><span id='topic+fit_spm'></span><span id='topic+fit_smooths+2Csspm_dataset+2Csspm_discrete_boundary-method'></span><span id='topic+fit_spm+2Csspm+2Csspm_formula-method'></span>

<h3>Description</h3>

<p>Once formulas have been mapped onto a sspm discrete object, the GAMs can be
fitted with this function. Arguments can be passed onto <code>bam</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit_smooths(
  sspm_object,
  boundaries,
  keep_fit = TRUE,
  predict = TRUE,
  family = mgcv::tw,
  drop.unused.levels = F,
  method = "fREML",
  ...
)

fit_spm(
  sspm_object,
  sspm_formula,
  keep_fit = TRUE,
  family = mgcv::scat,
  drop.unused.levels = F,
  select = TRUE,
  method = "REML",
  ...
)

## S4 method for signature 'sspm_dataset,sspm_discrete_boundary'
fit_smooths(
  sspm_object,
  boundaries,
  keep_fit = TRUE,
  predict = TRUE,
  family = mgcv::tw,
  drop.unused.levels = F,
  method = "fREML",
  ...
)

## S4 method for signature 'sspm,sspm_formula'
fit_spm(
  sspm_object,
  sspm_formula,
  keep_fit = TRUE,
  family = mgcv::scat,
  drop.unused.levels = F,
  select = TRUE,
  method = "REML",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fit_smooths_+3A_sspm_object">sspm_object</code></td>
<td>
<p><strong>[sspm_dataset]</strong> An object of class
<a href="#topic+sspm_dataset-class">sspm_dataset</a>.</p>
</td></tr>
<tr><td><code id="fit_smooths_+3A_boundaries">boundaries</code></td>
<td>
<p><strong>[sspm_boundary]</strong> An object of class
<a href="#topic+sspm_boundary-class">sspm_discrete_boundary</a>.</p>
</td></tr>
<tr><td><code id="fit_smooths_+3A_keep_fit">keep_fit</code></td>
<td>
<p><strong>[logical]</strong> Whether or not to keep the fitted values and
model (default to TRUE, set to FALSE to reduce memory footprint).</p>
</td></tr>
<tr><td><code id="fit_smooths_+3A_predict">predict</code></td>
<td>
<p><strong>[logical]</strong> Whether or not to generate the smoothed
predictions (necessary to fit the final SPM model, default to TRUE).</p>
</td></tr>
<tr><td><code id="fit_smooths_+3A_family">family</code></td>
<td>

<p>This is a family object specifying the distribution and link to use in
fitting etc. See <code><a href="stats.html#topic+glm">glm</a></code> and <code><a href="stats.html#topic+family">family</a></code> for more
details. The extended families listed in <code><a href="mgcv.html#topic+family.mgcv">family.mgcv</a></code> can also be used.
</p>
</td></tr>
<tr><td><code id="fit_smooths_+3A_drop.unused.levels">drop.unused.levels</code></td>
<td>
<p>by default unused levels are dropped from factors before fitting. For some smooths 
involving factor variables you might want to turn this off. Only do so if you know what you are doing.</p>
</td></tr>
<tr><td><code id="fit_smooths_+3A_method">method</code></td>
<td>
<p>The smoothing parameter estimation method. <code>"GCV.Cp"</code> to use GCV for unknown scale parameter and
Mallows' Cp/UBRE/AIC for known scale. <code>"GACV.Cp"</code> is equivalent, but using GACV in place of GCV. <code>"REML"</code> 
for REML estimation, including of unknown scale, <code>"P-REML"</code> for REML estimation, but using a Pearson estimate 
of the scale. <code>"ML"</code> and <code>"P-ML"</code> are similar, but using maximum likelihood in place of REML. Default 
<code>"fREML"</code> uses fast REML computation.</p>
</td></tr>
<tr><td><code id="fit_smooths_+3A_...">...</code></td>
<td>

<p>Arguments passed on to <code><a href="mgcv.html#topic+bam">mgcv::bam</a></code>
</p>

<dl>
<dt><code>formula</code></dt><dd><p> A GAM formula (see <code><a href="mgcv.html#topic+formula.gam">formula.gam</a></code> and also <code><a href="mgcv.html#topic+gam.models">gam.models</a></code>). 
This is exactly like the formula for a GLM except that smooth terms, <code>s</code> and <code>te</code> can be added 
to the right hand side to specify that the linear predictor depends on smooth functions of predictors 
(or linear functionals of these).
</p>
</dd>
<dt><code>data</code></dt><dd><p> A data frame or list containing the model response variable and 
covariates required by the formula. By default the variables are taken 
from <code>environment(formula)</code>: typically the environment from 
which <code>gam</code> is called.</p>
</dd>
<dt><code>weights</code></dt><dd><p>  prior weights on the contribution of the data to the log likelihood. Note that a weight of 2, for example, 
is equivalent to having made exactly the same observation twice. If you want to reweight the contributions 
of each datum without changing the overall magnitude of the log likelihood, then you should normalize the weights
(e.g. <code>weights &lt;- weights/mean(weights)</code>).</p>
</dd>
<dt><code>subset</code></dt><dd><p> an optional vector specifying a subset of observations to be
used in the fitting process.</p>
</dd>
<dt><code>na.action</code></dt><dd><p> a function which indicates what should happen when the data
contain &lsquo;NA&rsquo;s.  The default is set by the &lsquo;na.action&rsquo; setting
of &lsquo;options&rsquo;, and is &lsquo;na.fail&rsquo; if that is unset.  The
&ldquo;factory-fresh&rdquo; default is &lsquo;na.omit&rsquo;.</p>
</dd>
<dt><code>offset</code></dt><dd><p>Can be used to supply a model offset for use in fitting. Note
that this offset will always be completely ignored when predicting, unlike an offset 
included in <code>formula</code> (this used to conform to the behaviour of
<code>lm</code> and <code>glm</code>).</p>
</dd>
<dt><code>control</code></dt><dd><p>A list of fit control parameters to replace defaults returned by 
<code><a href="mgcv.html#topic+gam.control">gam.control</a></code>. Any control parameters not supplied stay at their default values.</p>
</dd>
<dt><code>scale</code></dt><dd><p> If this is positive then it is taken as the known scale parameter. Negative signals that the 
scale paraemter is unknown. 0 signals that the scale parameter is 1  for Poisson and binomial and unknown otherwise. 
Note that (RE)ML methods can only work with scale parameter 1 for the Poisson and binomial cases.    
</p>
</dd>
<dt><code>gamma</code></dt><dd><p>Increase above 1 to force smoother fits. <code>gamma</code> is used to multiply the effective degrees of freedom in the GCV/UBRE/AIC score (so <code>log(n)/2</code> is BIC like). <code>n/gamma</code> can be viewed as an effective sample size, which allows it to play a similar role for RE/ML smoothing parameter estimation.</p>
</dd>
<dt><code>knots</code></dt><dd><p>this is an optional list containing user specified knot values to be used for basis construction. 
For most bases the user simply supplies the knots to be used, which must match up with the <code>k</code> value
supplied (note that the number of knots is not always just <code>k</code>). 
See <code><a href="mgcv.html#topic+tprs">tprs</a></code> for what happens in the <code>"tp"/"ts"</code> case. 
Different terms can use different numbers of knots, unless they share a covariate.
</p>
</dd>
<dt><code>sp</code></dt><dd><p>A vector of smoothing parameters can be provided here.
Smoothing parameters must be supplied in the order that the smooth terms appear in the model 
formula. Negative elements indicate that the parameter should be estimated, and hence a mixture 
of fixed and estimated parameters is possible. If smooths share smoothing parameters then <code>length(sp)</code> 
must correspond to the number of underlying smoothing parameters. Note that <code>discrete=TRUE</code>may result in
re-ordering of variables in tensor product smooths for improved efficiency, and <code>sp</code> must be supplied in re-ordered order.</p>
</dd>
<dt><code>min.sp</code></dt><dd><p>Lower bounds can be supplied for the smoothing parameters. Note
that if this option is used then the smoothing parameters <code>full.sp</code>, in the 
returned object, will need to be added to what is supplied here to get the 
smoothing parameters actually multiplying the penalties. <code>length(min.sp)</code> should 
always be the same as the total number of penalties (so it may be longer than <code>sp</code>,
if smooths share smoothing parameters).</p>
</dd>
<dt><code>paraPen</code></dt><dd><p>optional list specifying any penalties to be applied to parametric model terms. 
<code><a href="mgcv.html#topic+gam.models">gam.models</a></code> explains more.</p>
</dd>
<dt><code>chunk.size</code></dt><dd><p>The model matrix is created in chunks of this size, rather than ever being formed whole. 
Reset to <code>4*p</code> if <code>chunk.size &lt; 4*p</code> where <code>p</code> is the number of coefficients.</p>
</dd>
<dt><code>rho</code></dt><dd><p>An AR1 error model can be used for the residuals (based on dataframe order), of Gaussian-identity 
link models. This is the AR1 correlation parameter. Standardized residuals (approximately 
uncorrelated under correct model) returned in 
<code>std.rsd</code> if non zero. Also usable with other models when <code>discrete=TRUE</code>, in which case the AR model
is applied to the working residuals and corresponds to a GEE approximation.</p>
</dd>
<dt><code>AR.start</code></dt><dd><p>logical variable of same length as data, <code>TRUE</code> at first observation of an independent
section of AR1 correlation. Very first observation in data frame does not need this. If <code>NULL</code> then 
there are no breaks in AR1 correlaion.</p>
</dd>
<dt><code>discrete</code></dt><dd><p>with <code>method="fREML"</code> it is possible to discretize covariates for storage and efficiency reasons.
If <code>discrete</code> is <code>TRUE</code>, a number or a vector of numbers for each smoother term, then discretization happens. If numbers are supplied they give the number of discretization bins. Parametric terms use the maximum number specified.</p>
</dd>
<dt><code>cluster</code></dt><dd><p><code>bam</code> can compute the computationally dominant QR decomposition in parallel using <a href="parallel.html#topic+clusterApply">parLapply</a>
from the <code>parallel</code> package, if it is supplied with a cluster on which to do this (a cluster here can be some cores of a 
single machine). See details and example code. 
</p>
</dd>
<dt><code>nthreads</code></dt><dd><p>Number of threads to use for non-cluster computation (e.g. combining results from cluster nodes).
If <code>NA</code> set to <code>max(1,length(cluster))</code>. See details.</p>
</dd>
<dt><code>gc.level</code></dt><dd><p>to keep the memory footprint down, it can help to call the garbage collector often, but this takes 
a substatial amount of time. Setting this to zero means that garbage collection only happens when R decides it should. Setting to 2 gives frequent garbage collection. 1 is in between. Not as much of a problem as it used to be, but can really matter for very large datasets.
</p>
</dd>
<dt><code>use.chol</code></dt><dd><p>By default <code>bam</code> uses a very stable QR update approach to obtaining the QR decomposition
of the model matrix. For well conditioned models an alternative accumulates the crossproduct of the model matrix
and then finds its Choleski decomposition, at the end. This is somewhat more efficient, computationally.</p>
</dd>
<dt><code>samfrac</code></dt><dd><p>For very large sample size Generalized additive models the number of iterations needed for the model fit can 
be reduced by first fitting a model to a random sample of the data, and using the results to supply starting values. This initial fit is run with sloppy convergence tolerances, so is typically very low cost. <code>samfrac</code> is the sampling fraction to use. 0.1 is often reasonable. </p>
</dd>
<dt><code>coef</code></dt><dd><p>initial values for model coefficients</p>
</dd>
<dt><code>G</code></dt><dd><p>if not <code>NULL</code> then this should be the object returned by a previous call to <code>bam</code> with 
<code>fit=FALSE</code>. Causes all other arguments to be ignored except <code>sp</code>, <code>chunk.size</code>, <code>gamma</code>,<code>nthreads</code>, <code>cluster</code>, <code>rho</code>, <code>gc.level</code>, <code>samfrac</code>, <code>use.chol</code>, <code>method</code> and <code>scale</code> (if &gt;0).</p>
</dd>
<dt><code>fit</code></dt><dd><p>if <code>FALSE</code> then the model is set up for fitting but not estimated, and an object is returned, suitable for passing as the <code>G</code> argument to <code>bam</code>.</p>
</dd>
<dt><code>drop.intercept</code></dt><dd><p>Set to <code>TRUE</code> to force the model to really not have the a constant in the parametric model part,
even with factor variables present.</p>
</dd>
<dt><code>in.out</code></dt><dd><p>If supplied then this is a two item list of intial values. <code>sp</code> is initial smoothing parameter estiamtes and <code>scale</code> the initial scale parameter estimate (set to 1 if famiy does not have one).</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="fit_smooths_+3A_sspm_formula">sspm_formula</code></td>
<td>
<p><strong>[sspm_formula]</strong> The formula specifying the the
smoothing model.</p>
</td></tr>
<tr><td><code id="fit_smooths_+3A_select">select</code></td>
<td>
<p>Should selection penalties be added to the smooth effects, so that they can in principle be 
penalized out of the model? See <code>gamma</code> to increase penalization.  Has the side effect that smooths no longer have a fixed effect component (improper prior from a Bayesian perspective) allowing REML comparison of models with the same fixed effect structure. 
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A object of the class <code><a href="#topic+sspm_fit-class">sspm_fit</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
fit_smooths(boundaries = boundaries, keep_fit = TRUE, ...)
fit_spm(sspm_object = sspm_object, sspm_formula = sspm_formula, ...)

## End(Not run)
</code></pre>

<hr>
<h2 id='map_formula'>Map model formula onto a sspm_dataset object</h2><span id='topic+map_formula'></span><span id='topic+map_formula+2Csf+2CANY+2Cformula-method'></span><span id='topic+spm_smooth+2CANY+2Cmissing+2CANY-method'></span><span id='topic+spm_smooth+2CANY+2CANY+2Cmissing-method'></span><span id='topic+spm_smooth+2CANY+2CANY+2Csspm_boundary-method'></span>

<h3>Description</h3>

<p>This functions is now used internally to map a formula onto a <code>sspm_dataset</code>
or <code>sspm</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>map_formula(data_frame, boundaries, formula, time, ...)

## S4 method for signature 'sf,ANY,formula'
map_formula(data_frame, boundaries, formula, time, ...)

## S4 method for signature 'ANY,missing,ANY'
spm_smooth(
  sspm_object,
  formula,
  boundaries,
  keep_fit = TRUE,
  predict = TRUE,
  ...
)

## S4 method for signature 'ANY,ANY,missing'
spm_smooth(
  sspm_object,
  formula,
  boundaries,
  keep_fit = TRUE,
  predict = TRUE,
  ...
)

## S4 method for signature 'ANY,ANY,sspm_boundary'
spm_smooth(
  sspm_object,
  formula,
  boundaries,
  keep_fit = TRUE,
  predict = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="map_formula_+3A_data_frame">data_frame</code></td>
<td>
<p><strong>[sf data.frame]</strong> The data.</p>
</td></tr>
<tr><td><code id="map_formula_+3A_boundaries">boundaries</code></td>
<td>
<p><strong>[sspm_boundary]</strong> An object of class
<a href="#topic+sspm_boundary-class">sspm_discrete_boundary</a>.</p>
</td></tr>
<tr><td><code id="map_formula_+3A_formula">formula</code></td>
<td>
<p><strong>[formula]</strong> A formula definition of the form
response ~ smoothing_terms + ...</p>
</td></tr>
<tr><td><code id="map_formula_+3A_time">time</code></td>
<td>
<p><strong>[character]</strong> The time column.</p>
</td></tr>
<tr><td><code id="map_formula_+3A_...">...</code></td>
<td>
<p> a list of variables that are the covariates that this
smooth is a function of. Transformations whose form depends on
the values of the data are best avoided here: e.g. <code>s(log(x))</code>
is fine, but <code>s(I(x/sd(x)))</code> is not (see <code><a href="mgcv.html#topic+predict.gam">predict.gam</a></code>).</p>
</td></tr>
<tr><td><code id="map_formula_+3A_sspm_object">sspm_object</code></td>
<td>
<p><strong>[sspm_dataset]</strong> An object of class
<a href="#topic+sspm_dataset-class">sspm_dataset</a>.</p>
</td></tr>
<tr><td><code id="map_formula_+3A_keep_fit">keep_fit</code></td>
<td>
<p><strong>[logical]</strong> Whether or not to keep the fitted values and
model (default to TRUE, set to FALSE to reduce memory footprint).</p>
</td></tr>
<tr><td><code id="map_formula_+3A_predict">predict</code></td>
<td>
<p><strong>[logical]</strong> Whether or not to generate the smoothed
predictions (necessary to fit the final SPM model, default to TRUE).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The updated object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
map_formula(data_frame = all_data, boundaries = boundaries,
            formula = formula, time = time, ...)

## End(Not run)
</code></pre>

<hr>
<h2 id='method_func'>Accessing OR replacing <code>discretization_method</code> model elements</h2><span id='topic+method_func'></span><span id='topic+method_func+2Cdiscretization_method-method'></span><span id='topic+method_func+3C-'></span><span id='topic+method_func+3C-+2Cdiscretization_method-method'></span><span id='topic+spm_name+2Cdiscretization_method-method'></span><span id='topic+spm_name+3C-+2Cdiscretization_method-method'></span>

<h3>Description</h3>

<p>All methods described here allow to access the elements of contained in
objects of class <a href="#topic+discretization_method-class">discretization_method</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>method_func(sspm_object)

## S4 method for signature 'discretization_method'
method_func(sspm_object)

method_func(object) &lt;- value

## S4 replacement method for signature 'discretization_method'
method_func(object) &lt;- value

## S4 method for signature 'discretization_method'
spm_name(sspm_object)

## S4 replacement method for signature 'discretization_method'
spm_name(object) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="method_func_+3A_sspm_object">sspm_object</code></td>
<td>
<p><strong>[discretization_method]</strong> An object of class
<a href="#topic+discretization_method-class">discretization_method</a>.</p>
</td></tr>
<tr><td><code id="method_func_+3A_object">object</code></td>
<td>
<p><strong>[discretization_method]</strong> An object of class
<a href="#topic+discretization_method-class">discretization_method</a>.</p>
</td></tr>
<tr><td><code id="method_func_+3A_value">value</code></td>
<td>
<p>typically an array-like <span class="rlang"><b>R</b></span> object of a similar class as
<code>x</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The object in the required slot.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>method &lt;- as_discretization_method("tesselate_voronoi")
method_func(method)
</code></pre>

<hr>
<h2 id='plot'>Plot <code>sspm</code> objects</h2><span id='topic+plot'></span><span id='topic+plot.sspm'></span><span id='topic+plot+2Csspm_boundary+2Cmissing-method'></span><span id='topic+plot+2Csspm_dataset+2Cmissing-method'></span><span id='topic+plot+2Csspm_fit+2Cmissing-method'></span>

<h3>Description</h3>

<p>Plot methods for a range of sspm objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'sspm_boundary,missing'
plot(x, y, ...)

## S4 method for signature 'sspm_dataset,missing'
plot(
  x,
  y,
  ...,
  var = NULL,
  point_size = 1,
  line_size = 1,
  use_sf = FALSE,
  interval = FALSE,
  page = "first",
  nrow = 2,
  ncol = 2,
  log = FALSE,
  scales = "fixed",
  show_PI = TRUE,
  show_CI = TRUE
)

## S4 method for signature 'sspm_fit,missing'
plot(
  x,
  y,
  ...,
  point_size = 1,
  line_size = 1,
  train_test = FALSE,
  biomass = NULL,
  next_ts = FALSE,
  smoothed_biomass = FALSE,
  aggregate = FALSE,
  interval = FALSE,
  biomass_origin = NULL,
  use_sf = FALSE,
  page = "first",
  nrow = 2,
  ncol = 2,
  log = FALSE,
  scales = "fixed",
  show_PI = TRUE,
  show_CI = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_+3A_x">x</code></td>
<td>
<p><strong>[sspm_...]</strong> An object from this package.</p>
</td></tr>
<tr><td><code id="plot_+3A_y">y</code></td>
<td>
<p>NOT USED (from generic).</p>
</td></tr>
<tr><td><code id="plot_+3A_...">...</code></td>
<td>
<p>NOT USED (from generic).</p>
</td></tr>
<tr><td><code id="plot_+3A_var">var</code></td>
<td>
<p><strong>[character]</strong> (For sspm_dataset) Variable to plot.</p>
</td></tr>
<tr><td><code id="plot_+3A_point_size">point_size</code></td>
<td>
<p><strong>[numeric]</strong> Passed on to ggplot size parameter for
point size.</p>
</td></tr>
<tr><td><code id="plot_+3A_line_size">line_size</code></td>
<td>
<p><strong>[numeric]</strong> Passed on to ggplot size parameter for line
size.</p>
</td></tr>
<tr><td><code id="plot_+3A_use_sf">use_sf</code></td>
<td>
<p><strong>[logical]</strong> Whether to produce a spatial plot.</p>
</td></tr>
<tr><td><code id="plot_+3A_interval">interval</code></td>
<td>
<p><strong>[logical]</strong> (For sspm_fit &amp; sspm_dataset) Whether to plot
CI and PI intervals.</p>
</td></tr>
<tr><td><code id="plot_+3A_page">page</code></td>
<td>
<p>The page to draw</p>
</td></tr>
<tr><td><code id="plot_+3A_nrow">nrow</code></td>
<td>
<p>Number of rows per page</p>
</td></tr>
<tr><td><code id="plot_+3A_ncol">ncol</code></td>
<td>
<p>Number of columns per page</p>
</td></tr>
<tr><td><code id="plot_+3A_log">log</code></td>
<td>
<p><strong>[logical]</strong> For productivity, whether to plot log productivity,
(default to FALSE) for others, whether to plot on a log scale (default to TRUE).</p>
</td></tr>
<tr><td><code id="plot_+3A_scales">scales</code></td>
<td>
<p>Are scales shared across all facets (the default,
<code>"fixed"</code>), or do they vary across rows (<code>"free_x"</code>),
columns (<code>"free_y"</code>), or both rows and columns (<code>"free"</code>)?</p>
</td></tr>
<tr><td><code id="plot_+3A_show_pi">show_PI</code></td>
<td>
<p><strong>[character]</strong> Whether to show the PIs.</p>
</td></tr>
<tr><td><code id="plot_+3A_show_ci">show_CI</code></td>
<td>
<p><strong>[character]</strong> Whether to show the CIs.</p>
</td></tr>
<tr><td><code id="plot_+3A_train_test">train_test</code></td>
<td>
<p><strong>[logical]</strong> (For sspm_fit) Whether to plot a train/test
pair plot.</p>
</td></tr>
<tr><td><code id="plot_+3A_biomass">biomass</code></td>
<td>
<p><strong>[character]</strong> (For sspm_fit) The biomass variable for
predictions.</p>
</td></tr>
<tr><td><code id="plot_+3A_next_ts">next_ts</code></td>
<td>
<p><strong>[logical]</strong> (For sspm_fit) Whether to plot a predictions
for next timestep.</p>
</td></tr>
<tr><td><code id="plot_+3A_smoothed_biomass">smoothed_biomass</code></td>
<td>
<p><strong>[logical]</strong> (For sspm_fit) Whether to plot a the
smoothed biomass used for predictions.</p>
</td></tr>
<tr><td><code id="plot_+3A_aggregate">aggregate</code></td>
<td>
<p><strong>[logical]</strong> (For sspm_fit) For biomass predictions only,
whether to aggregate the data to the boundary level. Default to FALSE.</p>
</td></tr>
<tr><td><code id="plot_+3A_biomass_origin">biomass_origin</code></td>
<td>
<p><strong>[character]</strong> Biomass variable to plot (from
original dataset, optionnal).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot2 plot object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# To plot a boundary object and visualize patches/points
plot(sspm_boundary)
# To plot a dataset variable
plot(biomass_smooth, var = "weight_per_km2", log = FALSE)
plot(biomass_smooth, var = "weight_per_km2", use_sf = TRUE)
# To plot a fitted model
# Test-train plot
plot(sspm_model_fit, train_test = TRUE, scales = "free")
# Timeseries plot
plot(sspm_model_fit, log = T, scales = 'free')
plot(sspm_model_fit, log = T, use_sf = TRUE)
plot(sspm_model_fit, biomass = "weight_per_km2_borealis",  scales = "free")
plot(sspm_model_fit, biomass = "weight_per_km2_borealis", use_sf = TRUE)
plot(sspm_model_fit, biomass = "weight_per_km2_borealis",
     next_ts = TRUE, aggregate = TRUE, scales = "free", interval = T)

## End(Not run)

</code></pre>

<hr>
<h2 id='predator_simulated'>Simulated predator data</h2><span id='topic+predator_simulated'></span>

<h3>Description</h3>

<p>Simulated predator data for test and practice.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>predator_simulated
</code></pre>


<h3>Format</h3>

<p>A data frame:
</p>

<dl>
<dt>year_f</dt><dd><p>Year as a factor</p>
</dd>
<dt>sfa</dt><dd><p>SFA ID number</p>
</dd>
<dt>weight_per_km2</dt><dd><p>Simualated biomass in kg per km2</p>
</dd>
<dt>lon_dec</dt><dd><p>Longitude</p>
</dd>
<dt>lat_dec</dt><dd><p>Latitude</p>
</dd>
<dt>row</dt><dd><p>Row ID</p>
</dd>
<dt>uniqueID</dt><dd><p>Unique ID for simulated observation</p>
</dd>
</dl>


<hr>
<h2 id='predict'>Predict with a SPM model</h2><span id='topic+predict'></span><span id='topic+predict.sspm'></span><span id='topic+predict+2Csspm_fit-method'></span><span id='topic+predict+2Csspm_dataset-method'></span>

<h3>Description</h3>

<p>Predict using a fitted SPM model on the whole data or on new data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'sspm_fit'
predict(
  object,
  new_data = NULL,
  biomass = NULL,
  aggregate = FALSE,
  interval = FALSE,
  next_ts = FALSE,
  type = "response"
)

## S4 method for signature 'sspm_dataset'
predict(
  object,
  new_data = NULL,
  discrete = TRUE,
  type = "response",
  interval = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict_+3A_object">object</code></td>
<td>
<p><strong>[sspm_fit]</strong> Fit object to predict from.</p>
</td></tr>
<tr><td><code id="predict_+3A_new_data">new_data</code></td>
<td>
<p><strong>[data.frame]</strong> New data to predict with.</p>
</td></tr>
<tr><td><code id="predict_+3A_biomass">biomass</code></td>
<td>
<p><strong>[character]</strong> Biomass variable.</p>
</td></tr>
<tr><td><code id="predict_+3A_aggregate">aggregate</code></td>
<td>
<p><strong>[logical]</strong> For biomass predictions only, whether to
aggregate the data to the boundary level. Default to FALSE.</p>
</td></tr>
<tr><td><code id="predict_+3A_interval">interval</code></td>
<td>
<p><strong>[logical]</strong> Whether or not to calculate confidence, and
when possible, prediction intervals.</p>
</td></tr>
<tr><td><code id="predict_+3A_next_ts">next_ts</code></td>
<td>
<p><strong>[logical]</strong> For biomass, predict next timestep.</p>
</td></tr>
<tr><td><code id="predict_+3A_type">type</code></td>
<td>
<p> When this has the value <code>"link"</code> (default) the linear predictor (possibly with
associated standard errors) is returned. When <code>type="terms"</code> each component of the 
linear predictor is returned seperately (possibly with standard errors): this includes 
parametric model components, followed by each smooth component, but excludes
any offset and any intercept. <code>type="iterms"</code> is the same, except that any standard errors 
returned for smooth components will include the uncertainty about the intercept/overall mean.  When 
<code>type="response"</code> predictions 
on the scale of the response are returned (possibly with approximate
standard errors). When <code>type="lpmatrix"</code> then a matrix is returned
which yields the values of the linear predictor (minus any offset) when
postmultiplied by the
parameter vector (in this case <code>se.fit</code> is ignored). The latter
option is most useful for getting variance estimates for quantities derived from
the model: for example integrated quantities, or derivatives of smooths. A
linear predictor matrix can also be used to implement approximate prediction
outside <code>R</code> (see example code, below). </p>
</td></tr>
<tr><td><code id="predict_+3A_discrete">discrete</code></td>
<td>
<p><strong>[logical]</strong> If <code>new_data</code> is NULL, whether to predict
based on a discrete prediction matrix (default to TRUE).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>dataframe</code> of predictions.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Predictions for a model fit (usually, productivity)
predict(sspm_model_fit)
# To get biomass predictions, provide the variable name
predict(sspm_model_fit, biomass = "weight_per_km2_borealis")
# To get the next timestep predictions
predict(sspm_model_fit, biomass = "weight_per_km2_borealis", next_ts = TRUE)

## End(Not run)

</code></pre>

<hr>
<h2 id='predict_intervals'>GAM confidence and prediction intervals</h2><span id='topic+predict_intervals'></span>

<h3>Description</h3>

<p>Computes CI from posterior, and PI for Tweedie and scat gams.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>predict_intervals(object_fit, new_data, n = 1000, CI = TRUE, PI = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict_intervals_+3A_object_fit">object_fit</code></td>
<td>
<p><strong>[gam OR bam]</strong> The fit to use for predictions.</p>
</td></tr>
<tr><td><code id="predict_intervals_+3A_new_data">new_data</code></td>
<td>
<p><strong>[data.frame]</strong> The data to predict onto.</p>
</td></tr>
<tr><td><code id="predict_intervals_+3A_n">n</code></td>
<td>
<p><strong>[numeric]</strong> The number of simulations to run for parameters.</p>
</td></tr>
<tr><td><code id="predict_intervals_+3A_ci">CI</code></td>
<td>
<p><strong>[logical]</strong> Whether to compute the CI.</p>
</td></tr>
<tr><td><code id="predict_intervals_+3A_pi">PI</code></td>
<td>
<p><strong>[logical]</strong> Whether to compute the PI.</p>
</td></tr>
<tr><td><code id="predict_intervals_+3A_...">...</code></td>
<td>
<p>further arguments passed to the quantile function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code> with intervals.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>gam1 &lt;- gam(cyl ~ mpg, data=mtcars, family = tw)
predict_intervals(gam1)

</code></pre>

<hr>
<h2 id='raw_formula'>Accessing OR replacing <code>sspm_formula</code> model elements</h2><span id='topic+raw_formula'></span><span id='topic+raw_formula+2Csspm_formula-method'></span><span id='topic+raw_formula+3C-'></span><span id='topic+raw_formula+3C-+2Csspm_formula-method'></span><span id='topic+translated_formula'></span><span id='topic+translated_formula+2Csspm_formula-method'></span><span id='topic+translated_formula+3C-'></span><span id='topic+translated_formula+3C-+2Csspm_formula-method'></span><span id='topic+formula_vars'></span><span id='topic+formula_vars+2Csspm_formula-method'></span><span id='topic+formula_vars+3C-'></span><span id='topic+formula_vars+3C-+2Csspm_formula-method'></span><span id='topic+formula_type'></span><span id='topic+formula_type+2Csspm_formula-method'></span><span id='topic+formula_type+3C-'></span><span id='topic+formula_type+3C-+2Csspm_formula-method'></span><span id='topic+is_fitted'></span><span id='topic+is_fitted+2Csspm_formula-method'></span><span id='topic+is_fitted+3C-'></span><span id='topic+is_fitted+3C-+2Csspm_formula-method'></span><span id='topic+spm_response'></span><span id='topic+spm_response+2Csspm_formula-method'></span><span id='topic+spm_response+3C-'></span><span id='topic+spm_response+3C-+2Csspm_formula-method'></span><span id='topic+spm_lagged_vars'></span><span id='topic+spm_lagged_vars+2Csspm_formula-method'></span><span id='topic+spm_lagged_vars+3C-'></span><span id='topic+spm_lagged_vars+3C-+2Csspm_formula-method'></span>

<h3>Description</h3>

<p>All methods described here allow to access the elements of contained in
objects of class <a href="#topic+sspm_formula-class">sspm_formula</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>raw_formula(sspm_object)

## S4 method for signature 'sspm_formula'
raw_formula(sspm_object)

raw_formula(object) &lt;- value

## S4 replacement method for signature 'sspm_formula'
raw_formula(object) &lt;- value

translated_formula(sspm_object)

## S4 method for signature 'sspm_formula'
translated_formula(sspm_object)

translated_formula(object) &lt;- value

## S4 replacement method for signature 'sspm_formula'
translated_formula(object) &lt;- value

formula_vars(sspm_object)

## S4 method for signature 'sspm_formula'
formula_vars(sspm_object)

formula_vars(object) &lt;- value

## S4 replacement method for signature 'sspm_formula'
formula_vars(object) &lt;- value

formula_type(sspm_object)

## S4 method for signature 'sspm_formula'
formula_type(sspm_object)

formula_type(object) &lt;- value

## S4 replacement method for signature 'sspm_formula'
formula_type(object) &lt;- value

is_fitted(sspm_object)

## S4 method for signature 'sspm_formula'
is_fitted(sspm_object)

is_fitted(object) &lt;- value

## S4 replacement method for signature 'sspm_formula'
is_fitted(object) &lt;- value

spm_response(sspm_object)

## S4 method for signature 'sspm_formula'
spm_response(sspm_object)

spm_response(object) &lt;- value

## S4 replacement method for signature 'sspm_formula'
spm_response(object) &lt;- value

spm_lagged_vars(sspm_object)

## S4 method for signature 'sspm_formula'
spm_lagged_vars(sspm_object)

spm_lagged_vars(object) &lt;- value

## S4 replacement method for signature 'sspm_formula'
spm_lagged_vars(object) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="raw_formula_+3A_sspm_object">sspm_object</code></td>
<td>
<p><strong>[sspm_formula]</strong> An object of class
<a href="#topic+sspm_formula-class">sspm_formula</a>.</p>
</td></tr>
<tr><td><code id="raw_formula_+3A_object">object</code></td>
<td>
<p><strong>[sspm_formula]</strong> An object of class
<a href="#topic+sspm_formula-class">sspm_formula</a>.</p>
</td></tr>
<tr><td><code id="raw_formula_+3A_value">value</code></td>
<td>
<p>typically an array-like <span class="rlang"><b>R</b></span> object of a similar class as
<code>x</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The object in the required slot.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>form &lt;- new("sspm_formula",
            raw_formula = as.formula("weight_per_km2 ~ smooth_time()"),
            translated_formula = as.formula("weight_per_km2 ~ s(year_f,
                      k = 24L, bs = 're', xt = list(penalty = pen_mat_time))"),
                    vars = list(pen_mat_time = matrix(),
                                pen_mat_space = matrix()),
                    response = "weight_per_km2")
translated_formula(form)
</code></pre>

<hr>
<h2 id='sfa_boundaries'>SFA boundaries data</h2><span id='topic+sfa_boundaries'></span>

<h3>Description</h3>

<p>SFA boundaries.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sfa_boundaries
</code></pre>


<h3>Format</h3>

<p>A data frame and sf object:
</p>

<dl>
<dt>sfa</dt><dd><p>SFA ID number</p>
</dd>
<dt>geometry</dt><dd><p>sf geometry</p>
</dd>
<dt>area</dt><dd><p>sf geometry area</p>
</dd>
</dl>



<h3>Source</h3>

<p><a href="https://www.dfo-mpo.gc.ca/fisheries-peches/ifmp-gmp/shrimp-crevette/shrimp-crevette-2018-002-eng.html">https://www.dfo-mpo.gc.ca/fisheries-peches/ifmp-gmp/shrimp-crevette/shrimp-crevette-2018-002-eng.html</a>
</p>

<hr>
<h2 id='smooth_time'>sspm Smoothing functions</h2><span id='topic+smooth_time'></span><span id='topic+smooth_space'></span><span id='topic+smooth_space_time'></span><span id='topic+smooth_lag'></span><span id='topic+smooth_time+2Csf+2Csspm_discrete_boundary-method'></span><span id='topic+smooth_space+2Csf+2Csspm_discrete_boundary-method'></span><span id='topic+smooth_space_time+2Csf+2Csspm_discrete_boundary-method'></span><span id='topic+smooth_lag+2CANY+2Csf+2Csspm_discrete_boundary-method'></span>

<h3>Description</h3>

<p>A full sspm formula contains calls to the smoothing terms <code>smooth_time()</code>,
<code>smooth_space()</code>, <code>smooth_space_time()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>smooth_time(
  data_frame,
  boundaries,
  time,
  type = "ICAR",
  k = NULL,
  bs = "re",
  xt = NA,
  is_spm = FALSE,
  ...
)

smooth_space(
  data_frame,
  boundaries,
  time,
  type = "ICAR",
  k = NULL,
  bs = "mrf",
  xt = NULL,
  is_spm = FALSE,
  ...
)

smooth_space_time(
  data_frame,
  boundaries,
  time,
  type = "ICAR",
  k = c(NA, 30),
  bs = c("re", "mrf"),
  xt = list(NA, NULL),
  is_spm = FALSE,
  ...
)

smooth_lag(
  var,
  data_frame,
  boundaries,
  time,
  type = "LINPRED",
  k = 5,
  m = 1,
  ...
)

## S4 method for signature 'sf,sspm_discrete_boundary'
smooth_time(
  data_frame,
  boundaries,
  time,
  type = "ICAR",
  k = NULL,
  bs = "re",
  xt = NA,
  is_spm = FALSE,
  ...
)

## S4 method for signature 'sf,sspm_discrete_boundary'
smooth_space(
  data_frame,
  boundaries,
  time,
  type = "ICAR",
  k = NULL,
  bs = "mrf",
  xt = NULL,
  is_spm = FALSE,
  ...
)

## S4 method for signature 'sf,sspm_discrete_boundary'
smooth_space_time(
  data_frame,
  boundaries,
  time,
  type = "ICAR",
  k = c(NA, 30),
  bs = c("re", "mrf"),
  xt = list(NA, NULL),
  is_spm = FALSE,
  ...
)

## S4 method for signature 'ANY,sf,sspm_discrete_boundary'
smooth_lag(
  var,
  data_frame,
  boundaries,
  time,
  type = "LINPRED",
  k = 5,
  m = 1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="smooth_time_+3A_data_frame">data_frame</code></td>
<td>
<p><strong>[sf data.frame]</strong> The data.</p>
</td></tr>
<tr><td><code id="smooth_time_+3A_boundaries">boundaries</code></td>
<td>
<p><strong>[sspm_boundary]</strong> An object of class
<a href="#topic+sspm_boundary-class">sspm_discrete_boundary</a>.</p>
</td></tr>
<tr><td><code id="smooth_time_+3A_time">time</code></td>
<td>
<p><strong>[character]</strong> The time column.</p>
</td></tr>
<tr><td><code id="smooth_time_+3A_type">type</code></td>
<td>
<p><strong>[character]</strong> Type of smooth, currently only &quot;ICAR&quot; is
supported.</p>
</td></tr>
<tr><td><code id="smooth_time_+3A_k">k</code></td>
<td>
<p><strong>[numeric]</strong> Size of the smooths and/or size of the lag.</p>
</td></tr>
<tr><td><code id="smooth_time_+3A_bs">bs</code></td>
<td>
<p>a two letter character string indicating the (penalized) smoothing basis to use.
(eg <code>"tp"</code> for thin plate regression spline, <code>"cr"</code> for cubic regression spline).
see <code><a href="mgcv.html#topic+smooth.terms">smooth.terms</a></code> for an over view of what is available.
</p>
</td></tr>
<tr><td><code id="smooth_time_+3A_xt">xt</code></td>
<td>
<p>Any extra information required to set up a particular basis. Used
e.g. to set large data set handling behaviour for <code>"tp"</code> basis. If <code>xt$sumConv</code>
exists and is <code>FALSE</code> then the summation convention for matrix arguments is turned off. </p>
</td></tr>
<tr><td><code id="smooth_time_+3A_is_spm">is_spm</code></td>
<td>
<p>Whether or not an SPM is being fitted (used internally)</p>
</td></tr>
<tr><td><code id="smooth_time_+3A_...">...</code></td>
<td>
<p> a list of variables that are the covariates that this
smooth is a function of. Transformations whose form depends on
the values of the data are best avoided here: e.g. <code>s(log(x))</code>
is fine, but <code>s(I(x/sd(x)))</code> is not (see <code><a href="mgcv.html#topic+predict.gam">predict.gam</a></code>).</p>
</td></tr>
<tr><td><code id="smooth_time_+3A_var">var</code></td>
<td>
<p><strong>[symbol]</strong> Variable (only for smooth_lag).</p>
</td></tr>
<tr><td><code id="smooth_time_+3A_m">m</code></td>
<td>
<p>The order of the penalty for this term (e.g. 2 for
normal cubic spline penalty with 2nd derivatives when using 
default t.p.r.s basis). <code>NA</code> signals
autoinitialization. Only some smooth classes use this. The <code>"ps"</code> 
class can use a 2 item array giving the basis and penalty order separately.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of 2 lists:
</p>

<ul>
<li> <p><code>args</code>, contains the arguments to be passed on to the mgcv smooths
</p>
</li>
<li> <p><code>vars</code>, contains variables relevant to the evaluation of the smooth.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Not meant to be used directly
smooth_time(borealis_data, bounds_voronoi, time = "year")

## End(Not run)

</code></pre>

<hr>
<h2 id='spm'>Fit an SPM model</h2><span id='topic+spm'></span><span id='topic+spm+2Csspm+2Cmissing-method'></span><span id='topic+spm+2Csspm+2Cformula-method'></span>

<h3>Description</h3>

<p>Fit an spm model to a sspm object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spm(sspm_object, formula, ...)

## S4 method for signature 'sspm,missing'
spm(sspm_object, formula, ...)

## S4 method for signature 'sspm,formula'
spm(sspm_object, formula, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="spm_+3A_sspm_object">sspm_object</code></td>
<td>
<p><strong>[sspm_dataset]</strong> An object of class
<a href="#topic+sspm_dataset-class">sspm_dataset</a>.</p>
</td></tr>
<tr><td><code id="spm_+3A_formula">formula</code></td>
<td>
<p><strong>[formula]</strong> A formula definition of the form
response ~ smoothing_terms + ...</p>
</td></tr>
<tr><td><code id="spm_+3A_...">...</code></td>
<td>

<p>Arguments passed on to <code><a href="mgcv.html#topic+bam">mgcv::bam</a></code>
</p>

<dl>
<dt><code>family</code></dt><dd>
<p>This is a family object specifying the distribution and link to use in
fitting etc. See <code><a href="stats.html#topic+glm">glm</a></code> and <code><a href="stats.html#topic+family">family</a></code> for more
details. The extended families listed in <code><a href="mgcv.html#topic+family.mgcv">family.mgcv</a></code> can also be used.
</p>
</dd>
<dt><code>data</code></dt><dd><p> A data frame or list containing the model response variable and 
covariates required by the formula. By default the variables are taken 
from <code>environment(formula)</code>: typically the environment from 
which <code>gam</code> is called.</p>
</dd>
<dt><code>weights</code></dt><dd><p>  prior weights on the contribution of the data to the log likelihood. Note that a weight of 2, for example, 
is equivalent to having made exactly the same observation twice. If you want to reweight the contributions 
of each datum without changing the overall magnitude of the log likelihood, then you should normalize the weights
(e.g. <code>weights &lt;- weights/mean(weights)</code>).</p>
</dd>
<dt><code>subset</code></dt><dd><p> an optional vector specifying a subset of observations to be
used in the fitting process.</p>
</dd>
<dt><code>na.action</code></dt><dd><p> a function which indicates what should happen when the data
contain &lsquo;NA&rsquo;s.  The default is set by the &lsquo;na.action&rsquo; setting
of &lsquo;options&rsquo;, and is &lsquo;na.fail&rsquo; if that is unset.  The
&ldquo;factory-fresh&rdquo; default is &lsquo;na.omit&rsquo;.</p>
</dd>
<dt><code>offset</code></dt><dd><p>Can be used to supply a model offset for use in fitting. Note
that this offset will always be completely ignored when predicting, unlike an offset 
included in <code>formula</code> (this used to conform to the behaviour of
<code>lm</code> and <code>glm</code>).</p>
</dd>
<dt><code>method</code></dt><dd><p>The smoothing parameter estimation method. <code>"GCV.Cp"</code> to use GCV for unknown scale parameter and
Mallows' Cp/UBRE/AIC for known scale. <code>"GACV.Cp"</code> is equivalent, but using GACV in place of GCV. <code>"REML"</code> 
for REML estimation, including of unknown scale, <code>"P-REML"</code> for REML estimation, but using a Pearson estimate 
of the scale. <code>"ML"</code> and <code>"P-ML"</code> are similar, but using maximum likelihood in place of REML. Default 
<code>"fREML"</code> uses fast REML computation.</p>
</dd>
<dt><code>control</code></dt><dd><p>A list of fit control parameters to replace defaults returned by 
<code><a href="mgcv.html#topic+gam.control">gam.control</a></code>. Any control parameters not supplied stay at their default values.</p>
</dd>
<dt><code>select</code></dt><dd><p>Should selection penalties be added to the smooth effects, so that they can in principle be 
penalized out of the model? See <code>gamma</code> to increase penalization.  Has the side effect that smooths no longer have a fixed effect component (improper prior from a Bayesian perspective) allowing REML comparison of models with the same fixed effect structure. 
</p>
</dd>
<dt><code>scale</code></dt><dd><p> If this is positive then it is taken as the known scale parameter. Negative signals that the 
scale paraemter is unknown. 0 signals that the scale parameter is 1  for Poisson and binomial and unknown otherwise. 
Note that (RE)ML methods can only work with scale parameter 1 for the Poisson and binomial cases.    
</p>
</dd>
<dt><code>gamma</code></dt><dd><p>Increase above 1 to force smoother fits. <code>gamma</code> is used to multiply the effective degrees of freedom in the GCV/UBRE/AIC score (so <code>log(n)/2</code> is BIC like). <code>n/gamma</code> can be viewed as an effective sample size, which allows it to play a similar role for RE/ML smoothing parameter estimation.</p>
</dd>
<dt><code>knots</code></dt><dd><p>this is an optional list containing user specified knot values to be used for basis construction. 
For most bases the user simply supplies the knots to be used, which must match up with the <code>k</code> value
supplied (note that the number of knots is not always just <code>k</code>). 
See <code><a href="mgcv.html#topic+tprs">tprs</a></code> for what happens in the <code>"tp"/"ts"</code> case. 
Different terms can use different numbers of knots, unless they share a covariate.
</p>
</dd>
<dt><code>sp</code></dt><dd><p>A vector of smoothing parameters can be provided here.
Smoothing parameters must be supplied in the order that the smooth terms appear in the model 
formula. Negative elements indicate that the parameter should be estimated, and hence a mixture 
of fixed and estimated parameters is possible. If smooths share smoothing parameters then <code>length(sp)</code> 
must correspond to the number of underlying smoothing parameters. Note that <code>discrete=TRUE</code>may result in
re-ordering of variables in tensor product smooths for improved efficiency, and <code>sp</code> must be supplied in re-ordered order.</p>
</dd>
<dt><code>min.sp</code></dt><dd><p>Lower bounds can be supplied for the smoothing parameters. Note
that if this option is used then the smoothing parameters <code>full.sp</code>, in the 
returned object, will need to be added to what is supplied here to get the 
smoothing parameters actually multiplying the penalties. <code>length(min.sp)</code> should 
always be the same as the total number of penalties (so it may be longer than <code>sp</code>,
if smooths share smoothing parameters).</p>
</dd>
<dt><code>paraPen</code></dt><dd><p>optional list specifying any penalties to be applied to parametric model terms. 
<code><a href="mgcv.html#topic+gam.models">gam.models</a></code> explains more.</p>
</dd>
<dt><code>chunk.size</code></dt><dd><p>The model matrix is created in chunks of this size, rather than ever being formed whole. 
Reset to <code>4*p</code> if <code>chunk.size &lt; 4*p</code> where <code>p</code> is the number of coefficients.</p>
</dd>
<dt><code>rho</code></dt><dd><p>An AR1 error model can be used for the residuals (based on dataframe order), of Gaussian-identity 
link models. This is the AR1 correlation parameter. Standardized residuals (approximately 
uncorrelated under correct model) returned in 
<code>std.rsd</code> if non zero. Also usable with other models when <code>discrete=TRUE</code>, in which case the AR model
is applied to the working residuals and corresponds to a GEE approximation.</p>
</dd>
<dt><code>AR.start</code></dt><dd><p>logical variable of same length as data, <code>TRUE</code> at first observation of an independent
section of AR1 correlation. Very first observation in data frame does not need this. If <code>NULL</code> then 
there are no breaks in AR1 correlaion.</p>
</dd>
<dt><code>discrete</code></dt><dd><p>with <code>method="fREML"</code> it is possible to discretize covariates for storage and efficiency reasons.
If <code>discrete</code> is <code>TRUE</code>, a number or a vector of numbers for each smoother term, then discretization happens. If numbers are supplied they give the number of discretization bins. Parametric terms use the maximum number specified.</p>
</dd>
<dt><code>cluster</code></dt><dd><p><code>bam</code> can compute the computationally dominant QR decomposition in parallel using <a href="parallel.html#topic+clusterApply">parLapply</a>
from the <code>parallel</code> package, if it is supplied with a cluster on which to do this (a cluster here can be some cores of a 
single machine). See details and example code. 
</p>
</dd>
<dt><code>nthreads</code></dt><dd><p>Number of threads to use for non-cluster computation (e.g. combining results from cluster nodes).
If <code>NA</code> set to <code>max(1,length(cluster))</code>. See details.</p>
</dd>
<dt><code>gc.level</code></dt><dd><p>to keep the memory footprint down, it can help to call the garbage collector often, but this takes 
a substatial amount of time. Setting this to zero means that garbage collection only happens when R decides it should. Setting to 2 gives frequent garbage collection. 1 is in between. Not as much of a problem as it used to be, but can really matter for very large datasets.
</p>
</dd>
<dt><code>use.chol</code></dt><dd><p>By default <code>bam</code> uses a very stable QR update approach to obtaining the QR decomposition
of the model matrix. For well conditioned models an alternative accumulates the crossproduct of the model matrix
and then finds its Choleski decomposition, at the end. This is somewhat more efficient, computationally.</p>
</dd>
<dt><code>samfrac</code></dt><dd><p>For very large sample size Generalized additive models the number of iterations needed for the model fit can 
be reduced by first fitting a model to a random sample of the data, and using the results to supply starting values. This initial fit is run with sloppy convergence tolerances, so is typically very low cost. <code>samfrac</code> is the sampling fraction to use. 0.1 is often reasonable. </p>
</dd>
<dt><code>coef</code></dt><dd><p>initial values for model coefficients</p>
</dd>
<dt><code>drop.unused.levels</code></dt><dd><p>by default unused levels are dropped from factors before fitting. For some smooths 
involving factor variables you might want to turn this off. Only do so if you know what you are doing.</p>
</dd>
<dt><code>G</code></dt><dd><p>if not <code>NULL</code> then this should be the object returned by a previous call to <code>bam</code> with 
<code>fit=FALSE</code>. Causes all other arguments to be ignored except <code>sp</code>, <code>chunk.size</code>, <code>gamma</code>,<code>nthreads</code>, <code>cluster</code>, <code>rho</code>, <code>gc.level</code>, <code>samfrac</code>, <code>use.chol</code>, <code>method</code> and <code>scale</code> (if &gt;0).</p>
</dd>
<dt><code>fit</code></dt><dd><p>if <code>FALSE</code> then the model is set up for fitting but not estimated, and an object is returned, suitable for passing as the <code>G</code> argument to <code>bam</code>.</p>
</dd>
<dt><code>drop.intercept</code></dt><dd><p>Set to <code>TRUE</code> to force the model to really not have the a constant in the parametric model part,
even with factor variables present.</p>
</dd>
<dt><code>in.out</code></dt><dd><p>If supplied then this is a two item list of intial values. <code>sp</code> is initial smoothing parameter estiamtes and <code>scale</code> the initial scale parameter estimate (set to 1 if famiy does not have one).</p>
</dd>
</dl>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of type <code>sspm_fit</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
sspm_model_fit &lt;- sspm_model %&gt;%
    spm(log_productivity ~ sfa +
    weight_per_km2_all_predators_lag_1 +
    smooth_space(by = weight_per_km2_borealis_with_catch) +
    smooth_space(),
    family = mgcv::scat)

## End(Not run)

</code></pre>

<hr>
<h2 id='spm_aggregate'>Aggregate a dataset or fit data variable based on a boundary</h2><span id='topic+spm_aggregate'></span><span id='topic+spm_aggregate+2Csspm_dataset+2Cmissing-method'></span><span id='topic+spm_aggregate+2Csspm_dataset+2Csspm_discrete_boundary-method'></span>

<h3>Description</h3>

<p>Aggregate the data contained in a dataset or fit  based on the discretized
boundaries, using a function and a filling value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spm_aggregate(
  sspm_object,
  boundaries,
  level = "patch",
  type = "data",
  variable,
  fun,
  group_by = "spacetime",
  fill = FALSE,
  apply_to_df = FALSE,
  ...
)

## S4 method for signature 'sspm_dataset,missing'
spm_aggregate(
  sspm_object,
  boundaries,
  level = "patch",
  type = "data",
  variable,
  fun,
  group_by = "spacetime",
  fill = FALSE,
  apply_to_df = FALSE,
  ...
)

## S4 method for signature 'sspm_dataset,sspm_discrete_boundary'
spm_aggregate(
  sspm_object,
  boundaries,
  level = "patch",
  type = "data",
  variable,
  fun,
  group_by = "spacetime",
  fill = FALSE,
  apply_to_df = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="spm_aggregate_+3A_sspm_object">sspm_object</code></td>
<td>
<p><strong>[sspm_dataset or sspm_fit]</strong> The dataset object.</p>
</td></tr>
<tr><td><code id="spm_aggregate_+3A_boundaries">boundaries</code></td>
<td>
<p><strong>[sspm_discrete_boundary]</strong> The boundaries object
(optionnal).</p>
</td></tr>
<tr><td><code id="spm_aggregate_+3A_level">level</code></td>
<td>
<p><strong>[character]</strong> The aggregation level, &quot;patch&quot; or
&quot;boundary&quot;.</p>
</td></tr>
<tr><td><code id="spm_aggregate_+3A_type">type</code></td>
<td>
<p><strong>[character]</strong> The targeted type of aggregation, one of
&quot;data&quot; for base data or &quot;smoothed&quot; for smoothed data.</p>
</td></tr>
<tr><td><code id="spm_aggregate_+3A_variable">variable</code></td>
<td>
<p><strong>[character]</strong> Variable to aggregate (ignored in case
<code>apply_to_df</code> is <code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="spm_aggregate_+3A_fun">fun</code></td>
<td>
<p><strong>[function]</strong> Function to use to aggregate data.</p>
</td></tr>
<tr><td><code id="spm_aggregate_+3A_group_by">group_by</code></td>
<td>
<p><strong>[character]</strong> One of <code>time</code>, <code>space</code> and <code>spacetime</code>.</p>
</td></tr>
<tr><td><code id="spm_aggregate_+3A_fill">fill</code></td>
<td>
<p><strong>[logical OR numeric OR function]</strong> Whether to complete the
incomplete cases, default to <code>FALSE</code> for no completion.</p>
</td></tr>
<tr><td><code id="spm_aggregate_+3A_apply_to_df">apply_to_df</code></td>
<td>
<p><strong>[logical]</strong> Wether <code>fun</code> applied to  the data frame
group or to <code>variable</code>, default to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="spm_aggregate_+3A_...">...</code></td>
<td>
<p>More arguments passed onto <code>fun</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Updated <code>sspm_dataset</code> or <code>sspm_fit</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
spm_aggregate(sspm_object = catch,
              boundaries = spm_boundaries(biomass),
              variable = catch_variable,
              fun = fun, group_by = group_by,
              fill = fill, apply_to_df = apply_to_df,
              na.rm = TRUE, ...)

## End(Not run)

</code></pre>

<hr>
<h2 id='spm_aggregate_catch'>Update biomass value from catch adta</h2><span id='topic+spm_aggregate_catch'></span><span id='topic+spm_aggregate_catch+2Csspm_dataset+2Csspm_dataset+2Ccharacter+2Ccharacter-method'></span>

<h3>Description</h3>

<p>Aggregate the catch data contained in a catch dataset and update the biomass
dataset with the subtracted catch.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spm_aggregate_catch(
  biomass,
  catch,
  biomass_variable,
  catch_variable,
  corrections = NULL,
  fun = sum,
  group_by = "spacetime",
  fill,
  apply_to_df = FALSE,
  ...
)

## S4 method for signature 'sspm_dataset,sspm_dataset,character,character'
spm_aggregate_catch(
  biomass,
  catch,
  biomass_variable,
  catch_variable,
  corrections = NULL,
  fun = sum,
  group_by = "spacetime",
  fill,
  apply_to_df = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="spm_aggregate_catch_+3A_biomass">biomass</code></td>
<td>
<p><strong>[sspm_dataset (smoothed)]</strong> The dataset containing the
biomass variable.</p>
</td></tr>
<tr><td><code id="spm_aggregate_catch_+3A_catch">catch</code></td>
<td>
<p><strong>[sspm_dataset]</strong> The dataset containing the catch variable.</p>
</td></tr>
<tr><td><code id="spm_aggregate_catch_+3A_biomass_variable">biomass_variable</code></td>
<td>
<p><strong>[character]</strong> The biomass variab of <code>biomass</code>.</p>
</td></tr>
<tr><td><code id="spm_aggregate_catch_+3A_catch_variable">catch_variable</code></td>
<td>
<p><strong>[character]</strong> The catch column of <code>catch</code>.</p>
</td></tr>
<tr><td><code id="spm_aggregate_catch_+3A_corrections">corrections</code></td>
<td>
<p><strong>[data.frame]</strong> Optional landings corrections.</p>
</td></tr>
<tr><td><code id="spm_aggregate_catch_+3A_fun">fun</code></td>
<td>
<p><strong>[function]</strong> Function to use to aggregate data.</p>
</td></tr>
<tr><td><code id="spm_aggregate_catch_+3A_group_by">group_by</code></td>
<td>
<p><strong>[character]</strong> One of <code>time</code>, <code>space</code> and <code>spacetime</code>.</p>
</td></tr>
<tr><td><code id="spm_aggregate_catch_+3A_fill">fill</code></td>
<td>
<p><strong>[logical OR numeric OR function]</strong> Whether to complete the
incomplete cases, default to <code>FALSE</code> for no completion.</p>
</td></tr>
<tr><td><code id="spm_aggregate_catch_+3A_apply_to_df">apply_to_df</code></td>
<td>
<p><strong>[logical]</strong> Wether <code>fun</code> applied to  the data frame
group or to <code>variable</code>, default to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="spm_aggregate_catch_+3A_...">...</code></td>
<td>
<p>More arguments passed onto <code>fun</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Updated <code>sspm_dataset</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
spm_aggregate_catch(biomass = biomass_smooth, catch = catch_dataset,
                    biomass_variable = "weight_per_km2",
                    catch_variable = "catch",
                    fill = mean)

## End(Not run)

</code></pre>

<hr>
<h2 id='spm_as_boundary'>Create a sspm_boundary object</h2><span id='topic+spm_as_boundary'></span><span id='topic+spm_as_boundary+2Cmissing+2CANY+2CANY+2CANY-method'></span><span id='topic+spm_as_boundary+2CANY+2Cmissing+2CANY+2CANY-method'></span><span id='topic+spm_as_boundary+2Csf+2Ccharacter+2Cmissing+2Cmissing-method'></span><span id='topic+spm_as_boundary+2Csf+2Ccharacter+2CANY+2CANY-method'></span>

<h3>Description</h3>

<p>Create a sspm_boundary object. A boundary object serves as a basis to encode
the spatial extent of the model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spm_as_boundary(
  boundaries,
  boundary,
  patches = NULL,
  points = NULL,
  boundary_area = NULL,
  patch_area = NULL
)

## S4 method for signature 'missing,ANY,ANY,ANY'
spm_as_boundary(
  boundaries,
  boundary,
  patches = NULL,
  points = NULL,
  boundary_area = NULL,
  patch_area = NULL
)

## S4 method for signature 'ANY,missing,ANY,ANY'
spm_as_boundary(
  boundaries,
  boundary,
  patches = NULL,
  points = NULL,
  boundary_area = NULL,
  patch_area = NULL
)

## S4 method for signature 'sf,character,missing,missing'
spm_as_boundary(
  boundaries,
  boundary,
  patches = NULL,
  points = NULL,
  boundary_area = NULL,
  patch_area = NULL
)

## S4 method for signature 'sf,character,ANY,ANY'
spm_as_boundary(
  boundaries,
  boundary,
  patches = NULL,
  points = NULL,
  boundary_area = NULL,
  patch_area = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="spm_as_boundary_+3A_boundaries">boundaries</code></td>
<td>
<p><strong>[sf]</strong> The sf object to cast.</p>
</td></tr>
<tr><td><code id="spm_as_boundary_+3A_boundary">boundary</code></td>
<td>
<p><strong>[character]</strong> The column that contains the possible
subdivisions of the boundaries.</p>
</td></tr>
<tr><td><code id="spm_as_boundary_+3A_patches">patches</code></td>
<td>
<p><strong>[sf]</strong> Patches resulting from discretization.</p>
</td></tr>
<tr><td><code id="spm_as_boundary_+3A_points">points</code></td>
<td>
<p><strong>[sf]</strong> Sample points used for discretization.</p>
</td></tr>
<tr><td><code id="spm_as_boundary_+3A_boundary_area">boundary_area</code></td>
<td>
<p><strong>[character]</strong> The column that contains the area
of the subdivisions (optional).</p>
</td></tr>
<tr><td><code id="spm_as_boundary_+3A_patch_area">patch_area</code></td>
<td>
<p><strong>[character]</strong> The column that contains the area
of the patches (optional).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <a href="#topic+sspm_boundary-class">sspm_boundary</a> or
<a href="#topic+sspm_discrete_boundary-class">sspm_discrete_boundary</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sfa_boundaries
bounds &lt;- spm_as_boundary(boundaries = sfa_boundaries,
                          boundary = "sfa")
plot(bounds)

</code></pre>

<hr>
<h2 id='spm_as_dataset'>Create a <code>sspm_dataset</code> dataset structure</h2><span id='topic+spm_as_dataset'></span><span id='topic+spm_as_dataset+2Cdata.frame+2CANY+2CANY+2CANY+2CmissingOrNULL-method'></span><span id='topic+spm_as_dataset+2Cdata.frame+2CANY+2CANY+2CANY+2Clist-method'></span><span id='topic+spm_as_dataset+2Cdata.frame+2CANY+2CANY+2CANY+2Ccharacter-method'></span><span id='topic+spm_as_dataset+2Csf+2CANY+2CANY+2CANY+2CANY-method'></span>

<h3>Description</h3>

<p>This casts a <code>data.frame</code> or <code>sf</code> object into  an object of class
<code><a href="#topic+sspm_dataset-class">sspm_dataset</a></code>. This object is the format the package
uses to manage and manipulate the modeling data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spm_as_dataset(data, name, time, uniqueID, coords = NULL, ...)

## S4 method for signature 'data.frame,ANY,ANY,ANY,missingOrNULL'
spm_as_dataset(
  data,
  name,
  time,
  uniqueID,
  coords,
  crs = NULL,
  boundaries = NULL,
  biomass = NULL,
  density = NULL,
  biomass_units = NULL,
  density_units = NULL
)

## S4 method for signature 'data.frame,ANY,ANY,ANY,list'
spm_as_dataset(
  data,
  name,
  time,
  uniqueID,
  coords,
  crs = NULL,
  boundaries = NULL,
  biomass = NULL,
  density = NULL,
  biomass_units = "kg",
  density_units = "kg/km^2"
)

## S4 method for signature 'data.frame,ANY,ANY,ANY,character'
spm_as_dataset(
  data,
  name,
  time,
  uniqueID,
  coords,
  crs = NULL,
  boundaries = NULL,
  biomass = NULL,
  density = NULL,
  biomass_units = "kg",
  density_units = "kg/km^2"
)

## S4 method for signature 'sf,ANY,ANY,ANY,ANY'
spm_as_dataset(
  data,
  name,
  time,
  uniqueID,
  coords,
  crs = NULL,
  boundaries = NULL,
  biomass = NULL,
  density = NULL,
  biomass_units = "kg",
  density_units = "kg/km^2"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="spm_as_dataset_+3A_data">data</code></td>
<td>
<p><strong>[data.frame OR sf]</strong> The dataset.</p>
</td></tr>
<tr><td><code id="spm_as_dataset_+3A_name">name</code></td>
<td>
<p><strong>[character]</strong> The name of the dataset, default to &quot;Biomass&quot;.</p>
</td></tr>
<tr><td><code id="spm_as_dataset_+3A_time">time</code></td>
<td>
<p><strong>[character]</strong> The column of <code>data</code> for the temporal
dimensions (i.e. year).</p>
</td></tr>
<tr><td><code id="spm_as_dataset_+3A_uniqueid">uniqueID</code></td>
<td>
<p><strong>[character]</strong> The column of <code>data</code> that is unique for all
rows of the data matrix.</p>
</td></tr>
<tr><td><code id="spm_as_dataset_+3A_coords">coords</code></td>
<td>
<p><strong>[character]</strong> The column of <code>data</code> for longitude and
latitude of the observations.</p>
</td></tr>
<tr><td><code id="spm_as_dataset_+3A_...">...</code></td>
<td>
<p>Arguments passed onto methods.</p>
</td></tr>
<tr><td><code id="spm_as_dataset_+3A_crs">crs</code></td>
<td>
<p>Coordinate reference system, passed onto <a href="sf.html#topic+st_as_sf">st_as_sf</a>.</p>
</td></tr>
<tr><td><code id="spm_as_dataset_+3A_boundaries">boundaries</code></td>
<td>
<p><strong>[sspm_boundary]</strong> An object of class
<a href="#topic+sspm_boundary-class">sspm_discrete_boundary</a>.</p>
</td></tr>
<tr><td><code id="spm_as_dataset_+3A_biomass">biomass</code></td>
<td>
<p><strong>[character]</strong> Columns to be encoded as biomasses (required).</p>
</td></tr>
<tr><td><code id="spm_as_dataset_+3A_density">density</code></td>
<td>
<p><strong>[character]</strong> Columns to be encoded as densities (optionnal).</p>
</td></tr>
<tr><td><code id="spm_as_dataset_+3A_biomass_units">biomass_units</code></td>
<td>
<p><strong>[character]</strong> Units for biomass columns, default to &quot;kg&quot;.</p>
</td></tr>
<tr><td><code id="spm_as_dataset_+3A_density_units">density_units</code></td>
<td>
<p><strong>[character]</strong> Units for density columns, default to &quot;kg/km^2&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code><a href="#topic+sspm_dataset-class">sspm_dataset</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(borealis_simulated, package = "sspm")
biomass_dataset &lt;- spm_as_dataset(data.frame(borealis_simulated), name = "borealis",
                                  density = "weight_per_km2",
                                  time = "year_f",
                                  coords = c('lon_dec','lat_dec'),
                                  uniqueID = "uniqueID")
biomass_dataset

</code></pre>

<hr>
<h2 id='spm_boundaries+2Csspm_boundary-method'>Accessing OR replacing <code>sspm_boundary</code> model elements</h2><span id='topic+spm_boundaries+2Csspm_boundary-method'></span><span id='topic+spm_boundaries+3C-+2Csspm_boundary-method'></span><span id='topic+spm_discret_method'></span><span id='topic+spm_discret_method+2Csspm_discrete_boundary-method'></span><span id='topic+spm_discret_method+3C-'></span><span id='topic+spm_discret_method+3C-+2Csspm_discrete_boundary-method'></span><span id='topic+spm_patches'></span><span id='topic+spm_patches+2Csspm_discrete_boundary-method'></span><span id='topic+spm_patches+3C-'></span><span id='topic+spm_patches+3C-+2Csspm_discrete_boundary-method'></span><span id='topic+spm_points'></span><span id='topic+spm_points+2Csspm_discrete_boundary-method'></span><span id='topic+spm_points+3C-'></span><span id='topic+spm_points+3C-+2Csspm_discrete_boundary-method'></span><span id='topic+spm_boundary'></span><span id='topic+spm_boundary+2Csspm_boundary-method'></span><span id='topic+spm_boundary+3C-'></span><span id='topic+spm_boundary+3C-+2Csspm_boundary-method'></span><span id='topic+spm_boundary_area'></span><span id='topic+spm_boundary_area+2Csspm_boundary-method'></span><span id='topic+spm_boundary_area+3C-'></span><span id='topic+spm_boundary_area+3C-+2Csspm_boundary-method'></span><span id='topic+spm_patches_area'></span><span id='topic+spm_patches_area+2Csspm_discrete_boundary-method'></span><span id='topic+spm_patches_area+3C-'></span><span id='topic+spm_patches_area+3C-+2Csspm_discrete_boundary-method'></span>

<h3>Description</h3>

<p>All methods described here allow to access the elements of contained in
objects of class <a href="#topic+sspm_boundary-class">sspm_boundary</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'sspm_boundary'
spm_boundaries(sspm_object)

## S4 replacement method for signature 'sspm_boundary'
spm_boundaries(object) &lt;- value

spm_discret_method(sspm_object)

## S4 method for signature 'sspm_discrete_boundary'
spm_discret_method(sspm_object)

spm_discret_method(object) &lt;- value

## S4 replacement method for signature 'sspm_discrete_boundary'
spm_discret_method(object) &lt;- value

spm_patches(sspm_object)

## S4 method for signature 'sspm_discrete_boundary'
spm_patches(sspm_object)

spm_patches(object) &lt;- value

## S4 replacement method for signature 'sspm_discrete_boundary'
spm_patches(object) &lt;- value

spm_points(sspm_object)

## S4 method for signature 'sspm_discrete_boundary'
spm_points(sspm_object)

spm_points(object) &lt;- value

## S4 replacement method for signature 'sspm_discrete_boundary'
spm_points(object) &lt;- value

spm_boundary(sspm_object)

## S4 method for signature 'sspm_boundary'
spm_boundary(sspm_object)

spm_boundary(object) &lt;- value

## S4 replacement method for signature 'sspm_boundary'
spm_boundary(object) &lt;- value

spm_boundary_area(sspm_object)

## S4 method for signature 'sspm_boundary'
spm_boundary_area(sspm_object)

spm_boundary_area(object) &lt;- value

## S4 replacement method for signature 'sspm_boundary'
spm_boundary_area(object) &lt;- value

spm_patches_area(sspm_object)

## S4 method for signature 'sspm_discrete_boundary'
spm_patches_area(sspm_object)

spm_patches_area(object) &lt;- value

## S4 replacement method for signature 'sspm_discrete_boundary'
spm_patches_area(object) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="spm_boundaries+2B2Csspm_boundary-method_+3A_sspm_object">sspm_object</code></td>
<td>
<p><strong>[sspm_boundary]</strong> An object of class
<a href="#topic+sspm_boundary-class">sspm_boundary</a>.</p>
</td></tr>
<tr><td><code id="spm_boundaries+2B2Csspm_boundary-method_+3A_object">object</code></td>
<td>
<p><strong>[sspm_boundary]</strong> An object of class
<a href="#topic+sspm_boundary-class">sspm_boundary</a>.</p>
</td></tr>
<tr><td><code id="spm_boundaries+2B2Csspm_boundary-method_+3A_value">value</code></td>
<td>
<p>typically an array-like <span class="rlang"><b>R</b></span> object of a similar class as
<code>x</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The object in the required slot.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(borealis_simulated, package = "sspm")
biomass_dataset &lt;- spm_as_dataset(data.frame(borealis_simulated), name = "borealis",
                                  density = "weight_per_km2",
                                  time = "year_f",
                                  coords = c('lon_dec','lat_dec'),
                                  uniqueID = "uniqueID")
spm_boundaries(biomass_dataset)
</code></pre>

<hr>
<h2 id='spm_data'>Accessing OR replacing <code>sspm_dataset</code> model elements</h2><span id='topic+spm_data'></span><span id='topic+spm_data+2Csspm_dataset-method'></span><span id='topic+spm_data+3C-'></span><span id='topic+spm_data+3C-+2Csspm_dataset-method'></span><span id='topic+spm_name+2Csspm_dataset-method'></span><span id='topic+spm_name+3C-+2Csspm_dataset-method'></span><span id='topic+spm_unique_ID+2Csspm_dataset-method'></span><span id='topic+spm_unique_ID+3C-+2Csspm_dataset-method'></span><span id='topic+spm_coords_col'></span><span id='topic+spm_coords_col+2Csspm_dataset-method'></span><span id='topic+spm_coords_col+3C-'></span><span id='topic+spm_coords_col+3C-+2Csspm_dataset-method'></span><span id='topic+spm_time+2Csspm_dataset-method'></span><span id='topic+spm_time+3C-+2Csspm_dataset-method'></span><span id='topic+spm_biomass_vars'></span><span id='topic+spm_biomass_vars+2Csspm_dataset-method'></span><span id='topic+spm_biomass_vars+3C-'></span><span id='topic+spm_biomass_vars+3C-+2Csspm_dataset-method'></span><span id='topic+spm_density_vars'></span><span id='topic+spm_density_vars+2Csspm_dataset-method'></span><span id='topic+spm_density_vars+3C-'></span><span id='topic+spm_density_vars+3C-+2Csspm_dataset-method'></span><span id='topic+spm_formulas'></span><span id='topic+spm_formulas+2Csspm_dataset-method'></span><span id='topic+spm_formulas+3C-'></span><span id='topic+spm_formulas+3C-+2Csspm_dataset-method'></span><span id='topic+spm_smoothed_data+2Csspm_dataset-method'></span><span id='topic+spm_smoothed_data+3C-+2Csspm_dataset-method'></span><span id='topic+spm_smoothed_fit'></span><span id='topic+spm_smoothed_fit+2Csspm_dataset-method'></span><span id='topic+spm_smoothed_fit+3C-'></span><span id='topic+spm_smoothed_fit+3C-+2Csspm_dataset-method'></span><span id='topic+spm_smoothed_vars'></span><span id='topic+spm_smoothed_vars+2Csspm_dataset-method'></span><span id='topic+spm_smoothed_vars+3C-'></span><span id='topic+spm_smoothed_vars+3C-+2Csspm_dataset-method'></span><span id='topic+is_mapped'></span><span id='topic+is_mapped+2Csspm_dataset-method'></span><span id='topic+is_mapped+3C-'></span><span id='topic+is_mapped+3C-+2Csspm_dataset-method'></span><span id='topic+spm_boundaries+2Csspm_dataset-method'></span><span id='topic+spm_boundaries+3C-+2Csspm_dataset-method'></span>

<h3>Description</h3>

<p>All methods described here allow to access the elements of contained in
objects of class <a href="#topic+sspm_dataset-class">sspm_dataset</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spm_data(sspm_object)

## S4 method for signature 'sspm_dataset'
spm_data(sspm_object)

spm_data(object) &lt;- value

## S4 replacement method for signature 'sspm_dataset'
spm_data(object) &lt;- value

## S4 method for signature 'sspm_dataset'
spm_name(sspm_object)

## S4 replacement method for signature 'sspm_dataset'
spm_name(object) &lt;- value

## S4 method for signature 'sspm_dataset'
spm_unique_ID(sspm_object)

## S4 replacement method for signature 'sspm_dataset'
spm_unique_ID(object) &lt;- value

spm_coords_col(sspm_object)

## S4 method for signature 'sspm_dataset'
spm_coords_col(sspm_object)

spm_coords_col(object) &lt;- value

## S4 replacement method for signature 'sspm_dataset'
spm_coords_col(object) &lt;- value

## S4 method for signature 'sspm_dataset'
spm_time(sspm_object)

## S4 replacement method for signature 'sspm_dataset'
spm_time(object) &lt;- value

spm_biomass_vars(sspm_object)

## S4 method for signature 'sspm_dataset'
spm_biomass_vars(sspm_object)

spm_biomass_vars(object) &lt;- value

## S4 replacement method for signature 'sspm_dataset'
spm_biomass_vars(object) &lt;- value

spm_density_vars(sspm_object)

## S4 method for signature 'sspm_dataset'
spm_density_vars(sspm_object)

spm_density_vars(object) &lt;- value

## S4 replacement method for signature 'sspm_dataset'
spm_density_vars(object) &lt;- value

spm_formulas(sspm_object)

## S4 method for signature 'sspm_dataset'
spm_formulas(sspm_object)

spm_formulas(object) &lt;- value

## S4 replacement method for signature 'sspm_dataset'
spm_formulas(object) &lt;- value

## S4 method for signature 'sspm_dataset'
spm_smoothed_data(sspm_object)

## S4 replacement method for signature 'sspm_dataset'
spm_smoothed_data(object) &lt;- value

spm_smoothed_fit(sspm_object)

## S4 method for signature 'sspm_dataset'
spm_smoothed_fit(sspm_object)

spm_smoothed_fit(object) &lt;- value

## S4 replacement method for signature 'sspm_dataset'
spm_smoothed_fit(object) &lt;- value

spm_smoothed_vars(sspm_object)

## S4 method for signature 'sspm_dataset'
spm_smoothed_vars(sspm_object)

spm_smoothed_vars(object) &lt;- value

## S4 replacement method for signature 'sspm_dataset'
spm_smoothed_vars(object) &lt;- value

is_mapped(sspm_object)

## S4 method for signature 'sspm_dataset'
is_mapped(sspm_object)

is_mapped(object) &lt;- value

## S4 replacement method for signature 'sspm_dataset'
is_mapped(object) &lt;- value

## S4 method for signature 'sspm_dataset'
spm_boundaries(sspm_object)

## S4 replacement method for signature 'sspm_dataset'
spm_boundaries(object) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="spm_data_+3A_sspm_object">sspm_object</code></td>
<td>
<p><strong>[sspm_dataset]</strong> An object of class
<a href="#topic+sspm_dataset-class">sspm_dataset</a>.</p>
</td></tr>
<tr><td><code id="spm_data_+3A_object">object</code></td>
<td>
<p><strong>[sspm_dataset]</strong> An object of class
<a href="#topic+sspm_dataset-class">sspm_dataset</a>.</p>
</td></tr>
<tr><td><code id="spm_data_+3A_value">value</code></td>
<td>
<p>typically an array-like <span class="rlang"><b>R</b></span> object of a similar class as
<code>x</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The object in the required slot.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(borealis_simulated, package = "sspm")
biomass_dataset &lt;- spm_as_dataset(data.frame(borealis_simulated), name = "borealis",
                                  density = "weight_per_km2",
                                  time = "year_f",
                                  coords = c('lon_dec','lat_dec'),
                                  uniqueID = "uniqueID")
spm_data(biomass_dataset)
</code></pre>

<hr>
<h2 id='spm_discretize'>Discretize a <code>sspm</code> model object</h2><span id='topic+spm_discretize'></span><span id='topic+spm_discretize+2Csspm_boundary+2Cmissing+2CANY-method'></span><span id='topic+spm_discretize+2Csspm_boundary+2CANY+2Cmissing-method'></span><span id='topic+spm_discretize+2Csspm_boundary+2Ccharacter+2CANY-method'></span><span id='topic+spm_discretize+2Csspm_boundary+2Cfunction+2CANY-method'></span><span id='topic+spm_discretize+2Csspm_boundary+2Cdiscretization_method+2CANY-method'></span>

<h3>Description</h3>

<p>Discretize a <a href="#topic+sspm-class">sspm</a> model object with a function from a
<a href="#topic+discretization_method-class">discretization_method</a> object class. This
function divides the boundary polygons into smaller patches.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spm_discretize(boundary_object, method = "tesselate_voronoi", with = NULL, ...)

## S4 method for signature 'sspm_boundary,missing,ANY'
spm_discretize(boundary_object, method = "tesselate_voronoi", with = NULL, ...)

## S4 method for signature 'sspm_boundary,ANY,missing'
spm_discretize(boundary_object, method = "tesselate_voronoi", with = NULL, ...)

## S4 method for signature 'sspm_boundary,character,ANY'
spm_discretize(boundary_object, method = "tesselate_voronoi", with = NULL, ...)

## S4 method for signature 'sspm_boundary,function,ANY'
spm_discretize(boundary_object, method = "tesselate_voronoi", with = NULL, ...)

## S4 method for signature 'sspm_boundary,discretization_method,ANY'
spm_discretize(boundary_object, method = "tesselate_voronoi", with = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="spm_discretize_+3A_boundary_object">boundary_object</code></td>
<td>
<p><strong>[sspm]</strong> An object of class
<a href="#topic+sspm-class">sspm_boundary</a>.</p>
</td></tr>
<tr><td><code id="spm_discretize_+3A_method">method</code></td>
<td>
<p><strong>[character OR method]</strong>
Either a <code>character</code> from the list of available methods
(see <a href="#topic+spm_methods">spm_methods</a> for the list) <strong>OR</strong> an object of class
<a href="#topic+discretization_method-class">discretization_method</a>.</p>
</td></tr>
<tr><td><code id="spm_discretize_+3A_with">with</code></td>
<td>
<p><strong>[sspm_dataset OR sf]</strong> Either an object of class sspm_dataset or
a set of custom points.</p>
</td></tr>
<tr><td><code id="spm_discretize_+3A_...">...</code></td>
<td>
<p><strong>[named list]</strong> Further arguments to be passed onto the function
used in <code>method</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Custom discretization functions can be written. The function must:
</p>

<ol>
<li><p> Accept at least 1 argument: <strong>boundaries</strong> (the <code>sf</code> boundary object),
and optionnaly <strong>with</strong> (can be NULL) a separate object to be used for
discretization and <strong>boundary</strong>, the boundary column of
<strong>boundaries</strong> (these last 2 arguments are passed and connot be
overwritten but could be ignored).
</p>
</li>
<li><p> Returns a named list with 2 elements: <code>patches</code>. an <code>sf</code> object that
stores the discretized polygons, and <code>points</code>, an <code>sf</code> object that
stores the points that were used for discretization.
</p>
</li></ol>



<h3>Value</h3>

<p>An object of class <a href="#topic+sspm-class">sspm_discrete_boundary</a> (the updated
and discretized <code>sspm</code> object given as input).
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Voronoi tesselation
sfa_boundaries
bounds &lt;- spm_as_boundary(boundaries = sfa_boundaries,
                          boundary = "sfa")
biomass_dataset &lt;- spm_as_dataset(data.frame(borealis_simulated), name = "borealis",
                                  density = "weight_per_km2",
                                  time = "year_f",
                                  coords = c('lon_dec','lat_dec'),
                                  uniqueID = "uniqueID")
bounds_voronoi &lt;- bounds %&gt;%
  spm_discretize(method = "tesselate_voronoi",
                 with = biomass_dataset,
                 nb_samples = 10)

# Custom method
custom_func &lt;- function(boundaries, ...){
  args &lt;- list(...)
  # Can access passed arguments with args$arg_name
  # Do your custom discretization
  # Careful: must return sf objects!
  return(list(patches = c(),
              points = c())
         )
}

</code></pre>

<hr>
<h2 id='spm_lag'>Create lagged columns in a sspm smoothed data slot</h2><span id='topic+spm_lag'></span><span id='topic+spm_lag+2Csspm-method'></span><span id='topic+spm_lag+2Csspm_fit-method'></span>

<h3>Description</h3>

<p>This function is a wrapper around <a href="dplyr.html#topic+lead-lag">lag</a> (note that not all
arguments are supported). The default value for the lag is the mean of the
series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spm_lag(sspm_object, vars, n = 1, default = "mean", ...)

## S4 method for signature 'sspm'
spm_lag(sspm_object, vars, n = 1, default = "mean", ...)

## S4 method for signature 'sspm_fit'
spm_lag(sspm_object, vars, n = 1, default = "mean", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="spm_lag_+3A_sspm_object">sspm_object</code></td>
<td>
<p><strong>[sspm_dataset]</strong> An object of class
<a href="#topic+sspm_dataset-class">sspm_dataset</a>.</p>
</td></tr>
<tr><td><code id="spm_lag_+3A_vars">vars</code></td>
<td>
<p><strong>[character]</strong> Names of the variables to lag.</p>
</td></tr>
<tr><td><code id="spm_lag_+3A_n">n</code></td>
<td>
<p>Positive integer of length 1, giving the number of positions to
lag or lead by</p>
</td></tr>
<tr><td><code id="spm_lag_+3A_default">default</code></td>
<td>
<p>The value used to pad <code>x</code> back to its original size after the
lag or lead has been applied. The default, <code>NULL</code>, pads with a missing
value. If supplied, this must be a vector with size 1, which will be cast
to the type of <code>x</code>.</p>
</td></tr>
<tr><td><code id="spm_lag_+3A_...">...</code></td>
<td>
<p> a list of variables that are the covariates that this
smooth is a function of. Transformations whose form depends on
the values of the data are best avoided here: e.g. <code>s(log(x))</code>
is fine, but <code>s(I(x/sd(x)))</code> is not (see <code><a href="mgcv.html#topic+predict.gam">predict.gam</a></code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Updated <code>sspm_object</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
sspm_model &lt;- sspm_model %&gt;%
    spm_lag(vars = c("weight_per_km2_borealis_with_catch",
                     "weight_per_km2_all_predators"),
                     n = 1)

## End(Not run)

</code></pre>

<hr>
<h2 id='spm_methods'>Get the list of available discretization methods</h2><span id='topic+spm_methods'></span>

<h3>Description</h3>

<p>Currently, only one discretization method is supported:
* <code>"tesselate_voronoi"</code> Voronoi tessellation using the function
<a href="#topic+tesselate_voronoi">tesselate_voronoi</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spm_methods()
</code></pre>


<h3>Details</h3>

<p>You can create your own method (tutorial TBD).
</p>


<h3>Value</h3>

<p>A <code style="white-space: pre;">&#8288;character vector&#8288;</code> of all available discretization methods.
</p>

<hr>
<h2 id='spm_name'>Accessing OR replacing <code>sspm</code> model elements</h2><span id='topic+spm_name'></span><span id='topic+spm_'></span><span id='topic+spm_name+3C-'></span><span id='topic+spm_datasets'></span><span id='topic+spm_datasets+2Csspm-method'></span><span id='topic+spm_datasets+3C-'></span><span id='topic+spm_datasets+3C-+2Csspm-method'></span><span id='topic+spm_boundaries'></span><span id='topic+spm_boundaries+2Csspm-method'></span><span id='topic+spm_boundaries+3C-'></span><span id='topic+spm_boundaries+3C-+2Csspm-method'></span><span id='topic+spm_smoothed_data'></span><span id='topic+spm_smoothed_data+2Csspm-method'></span><span id='topic+spm_smoothed_data+3C-'></span><span id='topic+spm_smoothed_data+3C-+2Csspm-method'></span><span id='topic+spm_time'></span><span id='topic+spm_time+2Csspm-method'></span><span id='topic+spm_time+3C-'></span><span id='topic+spm_time+3C-+2Csspm-method'></span><span id='topic+is_split'></span><span id='topic+is_split+2Csspm-method'></span><span id='topic+is_split+3C-'></span><span id='topic+is_split+3C-+2Csspm-method'></span><span id='topic+spm_unique_ID'></span><span id='topic+spm_unique_ID+2Csspm-method'></span><span id='topic+spm_unique_ID+3C-'></span><span id='topic+spm_unique_ID+3C-+2Csspm-method'></span>

<h3>Description</h3>

<p>All methods described here allow to access the elements of contained in
objects of the different classes of the package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spm_name(sspm_object)

spm_name(object) &lt;- value

spm_datasets(sspm_object)

## S4 method for signature 'sspm'
spm_datasets(sspm_object)

spm_datasets(object) &lt;- value

## S4 replacement method for signature 'sspm'
spm_datasets(object) &lt;- value

spm_boundaries(sspm_object)

## S4 method for signature 'sspm'
spm_boundaries(sspm_object)

spm_boundaries(object) &lt;- value

## S4 replacement method for signature 'sspm'
spm_boundaries(object) &lt;- value

spm_smoothed_data(sspm_object)

## S4 method for signature 'sspm'
spm_smoothed_data(sspm_object)

spm_smoothed_data(object) &lt;- value

## S4 replacement method for signature 'sspm'
spm_smoothed_data(object) &lt;- value

spm_time(sspm_object)

## S4 method for signature 'sspm'
spm_time(sspm_object)

spm_time(object) &lt;- value

## S4 replacement method for signature 'sspm'
spm_time(object) &lt;- value

is_split(sspm_object)

## S4 method for signature 'sspm'
is_split(sspm_object)

is_split(object) &lt;- value

## S4 replacement method for signature 'sspm'
is_split(object) &lt;- value

spm_unique_ID(sspm_object)

## S4 method for signature 'sspm'
spm_unique_ID(sspm_object)

spm_unique_ID(object) &lt;- value

## S4 replacement method for signature 'sspm'
spm_unique_ID(object) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="spm_name_+3A_sspm_object">sspm_object</code></td>
<td>
<p><strong>[sspm OR adjacent]</strong> An object of class
<a href="#topic+sspm-class">sspm</a> or others derivative classes.</p>
</td></tr>
<tr><td><code id="spm_name_+3A_object">object</code></td>
<td>
<p><strong>[sspm OR adjacent]</strong> An object of class
<a href="#topic+sspm-class">sspm</a> or others derivative classes.</p>
</td></tr>
<tr><td><code id="spm_name_+3A_value">value</code></td>
<td>
<p>typically an array-like <span class="rlang"><b>R</b></span> object of a similar class as
<code>x</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The object in the required slot.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(borealis_simulated, package = "sspm")
biomass_dataset &lt;- spm_as_dataset(data.frame(borealis_simulated), name = "borealis",
                                  density = "weight_per_km2",
                                  time = "year_f",
                                  coords = c('lon_dec','lat_dec'),
                                  uniqueID = "uniqueID")
spm_name(biomass_dataset)
</code></pre>

<hr>
<h2 id='spm_smooth'>Smooth a variable in a sspm dataset</h2><span id='topic+spm_smooth'></span><span id='topic+spm_smooth+2Csspm_dataset+2Cformula+2Csspm_discrete_boundary-method'></span>

<h3>Description</h3>

<p>With a formula, smooth a variable in a sspm dataset. See Details for
more explanations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spm_smooth(
  sspm_object,
  formula,
  boundaries,
  keep_fit = TRUE,
  predict = TRUE,
  ...
)

## S4 method for signature 'sspm_dataset,formula,sspm_discrete_boundary'
spm_smooth(
  sspm_object,
  formula,
  boundaries,
  keep_fit = TRUE,
  predict = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="spm_smooth_+3A_sspm_object">sspm_object</code></td>
<td>
<p><strong>[sspm_dataset]</strong> An object of class
<a href="#topic+sspm_dataset-class">sspm_dataset</a>.</p>
</td></tr>
<tr><td><code id="spm_smooth_+3A_formula">formula</code></td>
<td>
<p><strong>[formula]</strong> A formula definition of the form
response ~ smoothing_terms + ...</p>
</td></tr>
<tr><td><code id="spm_smooth_+3A_boundaries">boundaries</code></td>
<td>
<p><strong>[sspm_boundary]</strong> An object of class
<a href="#topic+sspm_boundary-class">sspm_discrete_boundary</a>.</p>
</td></tr>
<tr><td><code id="spm_smooth_+3A_keep_fit">keep_fit</code></td>
<td>
<p><strong>[logical]</strong> Whether or not to keep the fitted values and
model (default to TRUE, set to FALSE to reduce memory footprint).</p>
</td></tr>
<tr><td><code id="spm_smooth_+3A_predict">predict</code></td>
<td>
<p><strong>[logical]</strong> Whether or not to generate the smoothed
predictions (necessary to fit the final SPM model, default to TRUE).</p>
</td></tr>
<tr><td><code id="spm_smooth_+3A_...">...</code></td>
<td>

<p>Arguments passed on to <code><a href="mgcv.html#topic+bam">mgcv::bam</a></code>
</p>

<dl>
<dt><code>family</code></dt><dd>
<p>This is a family object specifying the distribution and link to use in
fitting etc. See <code><a href="stats.html#topic+glm">glm</a></code> and <code><a href="stats.html#topic+family">family</a></code> for more
details. The extended families listed in <code><a href="mgcv.html#topic+family.mgcv">family.mgcv</a></code> can also be used.
</p>
</dd>
<dt><code>data</code></dt><dd><p> A data frame or list containing the model response variable and 
covariates required by the formula. By default the variables are taken 
from <code>environment(formula)</code>: typically the environment from 
which <code>gam</code> is called.</p>
</dd>
<dt><code>weights</code></dt><dd><p>  prior weights on the contribution of the data to the log likelihood. Note that a weight of 2, for example, 
is equivalent to having made exactly the same observation twice. If you want to reweight the contributions 
of each datum without changing the overall magnitude of the log likelihood, then you should normalize the weights
(e.g. <code>weights &lt;- weights/mean(weights)</code>).</p>
</dd>
<dt><code>subset</code></dt><dd><p> an optional vector specifying a subset of observations to be
used in the fitting process.</p>
</dd>
<dt><code>na.action</code></dt><dd><p> a function which indicates what should happen when the data
contain &lsquo;NA&rsquo;s.  The default is set by the &lsquo;na.action&rsquo; setting
of &lsquo;options&rsquo;, and is &lsquo;na.fail&rsquo; if that is unset.  The
&ldquo;factory-fresh&rdquo; default is &lsquo;na.omit&rsquo;.</p>
</dd>
<dt><code>offset</code></dt><dd><p>Can be used to supply a model offset for use in fitting. Note
that this offset will always be completely ignored when predicting, unlike an offset 
included in <code>formula</code> (this used to conform to the behaviour of
<code>lm</code> and <code>glm</code>).</p>
</dd>
<dt><code>method</code></dt><dd><p>The smoothing parameter estimation method. <code>"GCV.Cp"</code> to use GCV for unknown scale parameter and
Mallows' Cp/UBRE/AIC for known scale. <code>"GACV.Cp"</code> is equivalent, but using GACV in place of GCV. <code>"REML"</code> 
for REML estimation, including of unknown scale, <code>"P-REML"</code> for REML estimation, but using a Pearson estimate 
of the scale. <code>"ML"</code> and <code>"P-ML"</code> are similar, but using maximum likelihood in place of REML. Default 
<code>"fREML"</code> uses fast REML computation.</p>
</dd>
<dt><code>control</code></dt><dd><p>A list of fit control parameters to replace defaults returned by 
<code><a href="mgcv.html#topic+gam.control">gam.control</a></code>. Any control parameters not supplied stay at their default values.</p>
</dd>
<dt><code>select</code></dt><dd><p>Should selection penalties be added to the smooth effects, so that they can in principle be 
penalized out of the model? See <code>gamma</code> to increase penalization.  Has the side effect that smooths no longer have a fixed effect component (improper prior from a Bayesian perspective) allowing REML comparison of models with the same fixed effect structure. 
</p>
</dd>
<dt><code>scale</code></dt><dd><p> If this is positive then it is taken as the known scale parameter. Negative signals that the 
scale paraemter is unknown. 0 signals that the scale parameter is 1  for Poisson and binomial and unknown otherwise. 
Note that (RE)ML methods can only work with scale parameter 1 for the Poisson and binomial cases.    
</p>
</dd>
<dt><code>gamma</code></dt><dd><p>Increase above 1 to force smoother fits. <code>gamma</code> is used to multiply the effective degrees of freedom in the GCV/UBRE/AIC score (so <code>log(n)/2</code> is BIC like). <code>n/gamma</code> can be viewed as an effective sample size, which allows it to play a similar role for RE/ML smoothing parameter estimation.</p>
</dd>
<dt><code>knots</code></dt><dd><p>this is an optional list containing user specified knot values to be used for basis construction. 
For most bases the user simply supplies the knots to be used, which must match up with the <code>k</code> value
supplied (note that the number of knots is not always just <code>k</code>). 
See <code><a href="mgcv.html#topic+tprs">tprs</a></code> for what happens in the <code>"tp"/"ts"</code> case. 
Different terms can use different numbers of knots, unless they share a covariate.
</p>
</dd>
<dt><code>sp</code></dt><dd><p>A vector of smoothing parameters can be provided here.
Smoothing parameters must be supplied in the order that the smooth terms appear in the model 
formula. Negative elements indicate that the parameter should be estimated, and hence a mixture 
of fixed and estimated parameters is possible. If smooths share smoothing parameters then <code>length(sp)</code> 
must correspond to the number of underlying smoothing parameters. Note that <code>discrete=TRUE</code>may result in
re-ordering of variables in tensor product smooths for improved efficiency, and <code>sp</code> must be supplied in re-ordered order.</p>
</dd>
<dt><code>min.sp</code></dt><dd><p>Lower bounds can be supplied for the smoothing parameters. Note
that if this option is used then the smoothing parameters <code>full.sp</code>, in the 
returned object, will need to be added to what is supplied here to get the 
smoothing parameters actually multiplying the penalties. <code>length(min.sp)</code> should 
always be the same as the total number of penalties (so it may be longer than <code>sp</code>,
if smooths share smoothing parameters).</p>
</dd>
<dt><code>paraPen</code></dt><dd><p>optional list specifying any penalties to be applied to parametric model terms. 
<code><a href="mgcv.html#topic+gam.models">gam.models</a></code> explains more.</p>
</dd>
<dt><code>chunk.size</code></dt><dd><p>The model matrix is created in chunks of this size, rather than ever being formed whole. 
Reset to <code>4*p</code> if <code>chunk.size &lt; 4*p</code> where <code>p</code> is the number of coefficients.</p>
</dd>
<dt><code>rho</code></dt><dd><p>An AR1 error model can be used for the residuals (based on dataframe order), of Gaussian-identity 
link models. This is the AR1 correlation parameter. Standardized residuals (approximately 
uncorrelated under correct model) returned in 
<code>std.rsd</code> if non zero. Also usable with other models when <code>discrete=TRUE</code>, in which case the AR model
is applied to the working residuals and corresponds to a GEE approximation.</p>
</dd>
<dt><code>AR.start</code></dt><dd><p>logical variable of same length as data, <code>TRUE</code> at first observation of an independent
section of AR1 correlation. Very first observation in data frame does not need this. If <code>NULL</code> then 
there are no breaks in AR1 correlaion.</p>
</dd>
<dt><code>discrete</code></dt><dd><p>with <code>method="fREML"</code> it is possible to discretize covariates for storage and efficiency reasons.
If <code>discrete</code> is <code>TRUE</code>, a number or a vector of numbers for each smoother term, then discretization happens. If numbers are supplied they give the number of discretization bins. Parametric terms use the maximum number specified.</p>
</dd>
<dt><code>cluster</code></dt><dd><p><code>bam</code> can compute the computationally dominant QR decomposition in parallel using <a href="parallel.html#topic+clusterApply">parLapply</a>
from the <code>parallel</code> package, if it is supplied with a cluster on which to do this (a cluster here can be some cores of a 
single machine). See details and example code. 
</p>
</dd>
<dt><code>nthreads</code></dt><dd><p>Number of threads to use for non-cluster computation (e.g. combining results from cluster nodes).
If <code>NA</code> set to <code>max(1,length(cluster))</code>. See details.</p>
</dd>
<dt><code>gc.level</code></dt><dd><p>to keep the memory footprint down, it can help to call the garbage collector often, but this takes 
a substatial amount of time. Setting this to zero means that garbage collection only happens when R decides it should. Setting to 2 gives frequent garbage collection. 1 is in between. Not as much of a problem as it used to be, but can really matter for very large datasets.
</p>
</dd>
<dt><code>use.chol</code></dt><dd><p>By default <code>bam</code> uses a very stable QR update approach to obtaining the QR decomposition
of the model matrix. For well conditioned models an alternative accumulates the crossproduct of the model matrix
and then finds its Choleski decomposition, at the end. This is somewhat more efficient, computationally.</p>
</dd>
<dt><code>samfrac</code></dt><dd><p>For very large sample size Generalized additive models the number of iterations needed for the model fit can 
be reduced by first fitting a model to a random sample of the data, and using the results to supply starting values. This initial fit is run with sloppy convergence tolerances, so is typically very low cost. <code>samfrac</code> is the sampling fraction to use. 0.1 is often reasonable. </p>
</dd>
<dt><code>coef</code></dt><dd><p>initial values for model coefficients</p>
</dd>
<dt><code>drop.unused.levels</code></dt><dd><p>by default unused levels are dropped from factors before fitting. For some smooths 
involving factor variables you might want to turn this off. Only do so if you know what you are doing.</p>
</dd>
<dt><code>G</code></dt><dd><p>if not <code>NULL</code> then this should be the object returned by a previous call to <code>bam</code> with 
<code>fit=FALSE</code>. Causes all other arguments to be ignored except <code>sp</code>, <code>chunk.size</code>, <code>gamma</code>,<code>nthreads</code>, <code>cluster</code>, <code>rho</code>, <code>gc.level</code>, <code>samfrac</code>, <code>use.chol</code>, <code>method</code> and <code>scale</code> (if &gt;0).</p>
</dd>
<dt><code>fit</code></dt><dd><p>if <code>FALSE</code> then the model is set up for fitting but not estimated, and an object is returned, suitable for passing as the <code>G</code> argument to <code>bam</code>.</p>
</dd>
<dt><code>drop.intercept</code></dt><dd><p>Set to <code>TRUE</code> to force the model to really not have the a constant in the parametric model part,
even with factor variables present.</p>
</dd>
<dt><code>in.out</code></dt><dd><p>If supplied then this is a two item list of intial values. <code>sp</code> is initial smoothing parameter estiamtes and <code>scale</code> the initial scale parameter estimate (set to 1 if famiy does not have one).</p>
</dd>
</dl>
</td></tr>
</table>


<h3>Details</h3>

<p>This functions allows to specify a model formula for a given discrete sspm
object. The formula makes use of specific smoothing terms <code>smooth_time()</code>,
<code>smooth_space()</code>, <code>smooth_space_time()</code>. The formula can also contain fixed
effects and custom smooths, and can make use of specific smoothing terms
<code>smooth_time()</code>, <code>smooth_space()</code>, <code>smooth_space_time()</code>.
</p>


<h3>Value</h3>

<p>An updated <a href="#topic+sspm_dataset-class">sspm_dataset</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
biomass_smooth &lt;- biomass_dataset %&gt;%
    spm_smooth(weight_per_km2 ~ sfa + smooth_time(by = sfa) +
               smooth_space() +
               smooth_space_time(),
               boundaries = bounds_voronoi,
               family = tw)

## End(Not run)

</code></pre>

<hr>
<h2 id='spm_smooth_methods'>Get the list of available smoothing methods</h2><span id='topic+spm_smooth_methods'></span>

<h3>Description</h3>

<p>Currently, only one smoothing method is supported:
* <code>"ICAR"</code>: Intrinsic Conditional Auto-Regressive models.
* <code>"LINPRED"</code>: LINear PREDictors (lag smooths).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spm_smooth_methods()
</code></pre>


<h3>Value</h3>

<p>A <code style="white-space: pre;">&#8288;character vector&#8288;</code> of all available smoothing methods.
</p>

<hr>
<h2 id='spm_split'>Split data in test and train sets</h2><span id='topic+spm_split'></span><span id='topic+spm_split+2Csspm-method'></span>

<h3>Description</h3>

<p>Split data before fitting spm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spm_split(sspm_object, ...)

## S4 method for signature 'sspm'
spm_split(sspm_object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="spm_split_+3A_sspm_object">sspm_object</code></td>
<td>
<p><strong>[sspm]</strong> An object of class <a href="#topic+sspm-class">sspm</a>.</p>
</td></tr>
<tr><td><code id="spm_split_+3A_...">...</code></td>
<td>
<p><strong>[expression]</strong> Expression to evaluate to split data.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The updated sspm object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
sspm_model &lt;- sspm_model %&gt;%
    spm_split(year_f %in% c(1990:2017))

## End(Not run)

</code></pre>

<hr>
<h2 id='spm_unique_ID+2Csspm_fit-method'>Accessing OR replacing <code>sspm_fit</code> model elements</h2><span id='topic+spm_unique_ID+2Csspm_fit-method'></span><span id='topic+spm_unique_ID+3C-+2Csspm_fit-method'></span><span id='topic+spm_time+2Csspm_fit-method'></span><span id='topic+spm_time+3C-+2Csspm_fit-method'></span><span id='topic+spm_formulas+2Csspm_fit-method'></span><span id='topic+spm_formulas+3C-+2Csspm_fit-method'></span><span id='topic+spm_smoothed_data+2Csspm_fit-method'></span><span id='topic+spm_smoothed_data+3C-+2Csspm_fit-method'></span><span id='topic+spm_get_fit'></span><span id='topic+spm_get_fit+2Csspm_fit-method'></span><span id='topic+spm_get_fit+3C-'></span><span id='topic+spm_get_fit+3C-+2Csspm_fit-method'></span><span id='topic+spm_boundaries+2Csspm_fit-method'></span><span id='topic+spm_boundaries+3C-+2Csspm_fit-method'></span><span id='topic+spm_boundary+2Csspm_fit-method'></span><span id='topic+spm_boundary+3C-+2Csspm_fit-method'></span>

<h3>Description</h3>

<p>All methods described here allow to access the elements of contained in
objects of class <a href="#topic+sspm_fit-class">sspm_fit</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'sspm_fit'
spm_unique_ID(sspm_object)

## S4 replacement method for signature 'sspm_fit'
spm_unique_ID(object) &lt;- value

## S4 method for signature 'sspm_fit'
spm_time(sspm_object)

## S4 replacement method for signature 'sspm_fit'
spm_time(object) &lt;- value

## S4 method for signature 'sspm_fit'
spm_formulas(sspm_object)

## S4 replacement method for signature 'sspm_fit'
spm_formulas(object) &lt;- value

## S4 method for signature 'sspm_fit'
spm_smoothed_data(sspm_object)

## S4 replacement method for signature 'sspm_fit'
spm_smoothed_data(object) &lt;- value

spm_get_fit(sspm_object)

## S4 method for signature 'sspm_fit'
spm_get_fit(sspm_object)

spm_get_fit(object) &lt;- value

## S4 replacement method for signature 'sspm_fit'
spm_get_fit(object) &lt;- value

## S4 method for signature 'sspm_fit'
spm_boundaries(sspm_object)

## S4 replacement method for signature 'sspm_fit'
spm_boundaries(object) &lt;- value

## S4 method for signature 'sspm_fit'
spm_boundary(sspm_object)

## S4 replacement method for signature 'sspm_fit'
spm_boundary(object) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="spm_unique_ID+2B2Csspm_fit-method_+3A_sspm_object">sspm_object</code></td>
<td>
<p><strong>[sspm_fit]</strong> An object of class
<a href="#topic+sspm_fit-class">sspm_fit</a>.</p>
</td></tr>
<tr><td><code id="spm_unique_ID+2B2Csspm_fit-method_+3A_object">object</code></td>
<td>
<p><strong>[sspm_fit]</strong> An object of class
<a href="#topic+sspm_fit-class">sspm_fit</a>.</p>
</td></tr>
<tr><td><code id="spm_unique_ID+2B2Csspm_fit-method_+3A_value">value</code></td>
<td>
<p>typically an array-like <span class="rlang"><b>R</b></span> object of a similar class as
<code>x</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The object in the required slot.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(borealis_simulated, package = "sspm")
biomass_dataset &lt;- spm_as_dataset(data.frame(borealis_simulated), name = "borealis",
                                  density = "weight_per_km2",
                                  time = "year_f",
                                  coords = c('lon_dec','lat_dec'),
                                  uniqueID = "uniqueID")
spm_formulas(biomass_dataset)
</code></pre>

<hr>
<h2 id='sspm'>Create a <code>sspm</code> model object</h2><span id='topic+sspm'></span><span id='topic+sspm+2Csspm_dataset+2Cmissing-method'></span><span id='topic+sspm+2Csspm_dataset+2Csspm_dataset-method'></span><span id='topic+sspm+2Csspm_dataset+2Clist-method'></span>

<h3>Description</h3>

<p>Create a sspm_model object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sspm(biomass, predictors)

## S4 method for signature 'sspm_dataset,missing'
sspm(biomass, predictors)

## S4 method for signature 'sspm_dataset,sspm_dataset'
sspm(biomass, predictors)

## S4 method for signature 'sspm_dataset,list'
sspm(biomass, predictors)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sspm_+3A_biomass">biomass</code></td>
<td>
<p><strong>[sspm_dataset (smoothed)]</strong> The dataset containing the
biomass variable.</p>
</td></tr>
<tr><td><code id="sspm_+3A_predictors">predictors</code></td>
<td>
<p><strong>[list  OF sspm_dataset (smoothed)]</strong> The list of predictor
datasets.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class  <a href="#topic+sspm-class">sspm</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
sspm_model &lt;- sspm(biomass = biomass_smooth_w_catch,
                   predictors = predator_smooth)

## End(Not run)

</code></pre>

<hr>
<h2 id='sspm_boundary-class'>sspm boundary structure</h2><span id='topic+sspm_boundary-class'></span>

<h3>Description</h3>

<p>One of the first steps in the <code>sspm</code> workflow is to create one or more
object(s) of class <code>sspm_boundary</code> from an <code>sf</code> object.
</p>


<h3>Slots</h3>


<dl>
<dt><code>boundaries</code></dt><dd><p><strong>[sf]</strong> Spatial boundaries (polygons).</p>
</dd>
<dt><code>boundary</code></dt><dd><p><strong>[character]</strong> The column of <code>data</code> that represents the
spatial boundaries.</p>
</dd>
<dt><code>boundary_area</code></dt><dd><p><strong>[character]</strong> The column of <code>data</code> that represents the
area of spatial boundaries.</p>
</dd>
</dl>

<hr>
<h2 id='sspm_dataset-class'>sspm dataset structure</h2><span id='topic+sspm_dataset-class'></span>

<h3>Description</h3>

<p>One of the first step in the <code>sspm</code> workflow is to create one or more
object(s) of class <code>sspm_dataset</code> from a <code>data.frame</code>, <code>tibble</code> or <code>sf</code> object.
</p>


<h3>Slots</h3>


<dl>
<dt><code>name</code></dt><dd><p><strong>[character]</strong> The name of the dataset, default to &quot;Biomass&quot;.</p>
</dd>
<dt><code>data</code></dt><dd><p><strong>[data.frame OR sf OR tibble]</strong> The dataset.</p>
</dd>
<dt><code>biomass</code></dt><dd><p><strong>[character]</strong> The biomass columns of <code>data</code>.</p>
</dd>
<dt><code>density</code></dt><dd><p><strong>[character]</strong> The biomass density columns of <code>data</code>.</p>
</dd>
<dt><code>time</code></dt><dd><p><strong>[character]</strong> The column of <code>data</code> that represents the
temporal dimension of the dataset.</p>
</dd>
<dt><code>coords</code></dt><dd><p><strong>[character]</strong> The columns of <code>data</code> that represent the
spatial dimension of the dataset: the two columns for longitude and
latitude of the observations.</p>
</dd>
<dt><code>uniqueID</code></dt><dd><p><strong>[character]</strong> The column of <code>data</code> that is unique for all
rows of the data matrix.</p>
</dd>
<dt><code>boundaries</code></dt><dd><p><strong>[sspm_discrete_boundary]</strong> Spatial boundaries (polygons).</p>
</dd>
<dt><code>formulas</code></dt><dd><p><strong>[list]</strong> List of
<a href="#topic+sspm_formula-class">sspm_formula</a> objects that specifies the smoothed
variables.</p>
</dd>
<dt><code>smoothed_data</code></dt><dd><p><strong>[ANY (sf)]</strong> The smoothed data.</p>
</dd>
<dt><code>smoothed_vars</code></dt><dd><p><strong>[character]</strong> A vector storing the smoothed vars.</p>
</dd>
<dt><code>smoothed_fit</code></dt><dd><p><strong>[list]</strong> The fit from smoothing the data</p>
</dd>
<dt><code>is_mapped</code></dt><dd><p><strong>[logical]</strong> Whether the dataset has been mapped to
boundaries (used internally).</p>
</dd>
</dl>

<hr>
<h2 id='sspm_discrete_boundary-class'>sspm discrete boundary structure</h2><span id='topic+sspm_discrete_boundary-class'></span>

<h3>Description</h3>

<p>One of the first steps in the <code>sspm</code> workflow is to create one or more
object(s) of class <code>sspm_boundary</code> from an <code>sf</code> object.
</p>


<h3>Slots</h3>


<dl>
<dt><code>boundaries</code></dt><dd><p><strong>[sf]</strong> Spatial boundaries (polygons).</p>
</dd>
<dt><code>boundary</code></dt><dd><p><strong>[character]</strong> The column of <code>data</code> that represents the
spatial boundaries.</p>
</dd>
<dt><code>boundary_area</code></dt><dd><p><strong>[character]</strong> The column of <code>data</code> that represents the
area of spatial boundaries.</p>
</dd>
<dt><code>method</code></dt><dd><p><strong>[<a href="#topic+discretization_method-class">discretization_method</a>]</strong>
<em>(if discrete)</em> discretization method used.</p>
</dd>
<dt><code>patches</code></dt><dd><p><strong>[sf]</strong> <em>(if discrete)</em> Patches resulting from
discretization.</p>
</dd>
<dt><code>points</code></dt><dd><p><strong>[sf or NULL]</strong> <em>(if discrete)</em> Sample points used for
discretization.</p>
</dd>
<dt><code>patches_area</code></dt><dd><p><strong>[character]</strong> The column of <code>data</code> that represents the
area of patches.</p>
</dd>
</dl>

<hr>
<h2 id='sspm_fit-class'>sspm fit</h2><span id='topic+sspm_fit-class'></span>

<h3>Description</h3>

<p>The fit object for a sspm model
</p>


<h3>Slots</h3>


<dl>
<dt><code>smoothed_data</code></dt><dd><p><strong>[ANY (sf)]</strong> The smoothed data.</p>
</dd>
<dt><code>time</code></dt><dd><p><strong>[character]</strong> The column of <code>smoothed_data</code> that
represents the temporal dimension of the dataset.</p>
</dd>
<dt><code>uniqueID</code></dt><dd><p><strong>[character]</strong> The column of <code>smoothed_data</code> that is unique
for all rows of the data matrix.</p>
</dd>
<dt><code>formula</code></dt><dd><p><strong>[list]</strong> The <a href="#topic+sspm_formula-class">sspm_formula</a> object that
specifies the spm model.</p>
</dd>
<dt><code>boundaries</code></dt><dd><p><strong>[sf]</strong> Spatial boundaries (polygons).</p>
</dd>
<dt><code>fit</code></dt><dd><p><strong>[bam]</strong> The fit of the spm model.</p>
</dd>
</dl>

<hr>
<h2 id='sspm_formula-class'>sspm formula object</h2><span id='topic+sspm_formula-class'></span>

<h3>Description</h3>

<p>This class is a wrapper around the <code>formula</code> class. It is not intended for
users to directly manipulate and create new objects.
</p>


<h3>Slots</h3>


<dl>
<dt><code>raw_formula</code></dt><dd><p><strong>[formula]</strong> The raw formula call</p>
</dd>
<dt><code>translated_formula</code></dt><dd><p><strong>[formula]</strong> The translated formula call ready
to be evaluated.</p>
</dd>
<dt><code>vars</code></dt><dd><p><strong>[list]</strong> List of relevant variables for the evaluation of the
different smooths.</p>
</dd>
<dt><code>lag_vars</code></dt><dd><p>Smooth lag variables used for predictions</p>
</dd>
<dt><code>response</code></dt><dd><p><strong>[charatcer]</strong> The response variable in the formula.</p>
</dd>
<dt><code>is_fitted</code></dt><dd><p><strong>[logical]</strong> Whether this formula has already been fitted.</p>
</dd>
</dl>


<h3>See Also</h3>

<p>See the <code>mgcv</code> function for defining smooths: <a href="mgcv.html#topic+s">s()</a>.
</p>

<hr>
<h2 id='sspm-class'>sspm model class</h2><span id='topic+sspm-class'></span>

<h3>Description</h3>

<p>The <strong><code>sspm</code></strong> model object, made from biomass, predictor and catch data.
</p>


<h3>Slots</h3>


<dl>
<dt><code>datasets</code></dt><dd><p><strong>[list]</strong> List of
<a href="#topic+sspm_dataset-class">sspm_dataset</a> that define variables in the SPM model.</p>
</dd>
<dt><code>time</code></dt><dd><p><strong>[character]</strong> The column of <code>data</code> that represents the
temporal dimension of the dataset.</p>
</dd>
<dt><code>uniqueID</code></dt><dd><p><strong>[character]</strong> The column of <code>datasets</code> that is unique for
all rows of the data matrix.</p>
</dd>
<dt><code>boundaries</code></dt><dd><p><strong>[sf]</strong> Spatial boundaries (polygons).</p>
</dd>
<dt><code>smoothed_data</code></dt><dd><p><strong>[ANY (sf)]</strong> The smoothed data.</p>
</dd>
<dt><code>smoothed_vars</code></dt><dd><p><strong>[character]</strong> A vector storing the smoothed vars.</p>
</dd>
<dt><code>is_split</code></dt><dd><p><strong>[logical]</strong> Whether this object has been split into
train/test sets.</p>
</dd>
</dl>

<hr>
<h2 id='summary'>Summarises <code>sspm_fit</code> objects</h2><span id='topic+summary'></span><span id='topic+summary.sspm'></span><span id='topic+summary+2Csspm_fit-method'></span>

<h3>Description</h3>

<p>Summarises a <code>sspm_fit</code> object, both in terms of productivity and biomass.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'sspm_fit'
summary(object, biomass = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary_+3A_object">object</code></td>
<td>
<p><strong>[sspm_...]</strong> An object from this package.</p>
</td></tr>
<tr><td><code id="summary_+3A_biomass">biomass</code></td>
<td>
<p><strong>[character]</strong> Biomass variable.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Nothing is returned, but a summary is printed.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
summary(sspm_model_fit)
summary(sspm_model_fit, biomass = "weight_per_km2_borealis")

## End(Not run)

</code></pre>

<hr>
<h2 id='tesselate_voronoi'>Perform voronoi tesselation</h2><span id='topic+tesselate_voronoi'></span>

<h3>Description</h3>

<p>Generates voronoi polygons by first performing stratified sampling across
boundary polygons, then by running  the voronoisation with
<a href="sf.html#topic+geos_unary">st_voronoi()</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tesselate_voronoi(
  boundaries,
  with,
  boundary = "sfa",
  sample_surface = FALSE,
  sample_points = TRUE,
  nb_samples = NULL,
  min_size = 1500,
  stratify = TRUE,
  seed = 1
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tesselate_voronoi_+3A_boundaries">boundaries</code></td>
<td>
<p><strong>[sf]</strong> The boundaries to be used.</p>
</td></tr>
<tr><td><code id="tesselate_voronoi_+3A_with">with</code></td>
<td>
<p><strong>[sf]</strong> A set of data points to use for voronoisation.</p>
</td></tr>
<tr><td><code id="tesselate_voronoi_+3A_boundary">boundary</code></td>
<td>
<p><strong>[character]</strong> The column in <code>boundaries</code> that is to
be used for the stratified sampling.</p>
</td></tr>
<tr><td><code id="tesselate_voronoi_+3A_sample_surface">sample_surface</code></td>
<td>
<p><strong>[logical]</strong> Whether to sample the surfaces in
<code>boundaries</code>, Default to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="tesselate_voronoi_+3A_sample_points">sample_points</code></td>
<td>
<p><strong>[logical]</strong> Whether to sample points from <code>with</code> or
to take all points in <code>with</code>. Default to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="tesselate_voronoi_+3A_nb_samples">nb_samples</code></td>
<td>
<p><strong>[named character vector]</strong> The number of samples to draw
by boundary polygons (must bear the levels of <code>boundary</code> as names
or be a single value to be applied to each level).</p>
</td></tr>
<tr><td><code id="tesselate_voronoi_+3A_min_size">min_size</code></td>
<td>
<p><strong>[numeric]</strong> The minimum size for a polygon above which it
will be merged (in km2).</p>
</td></tr>
<tr><td><code id="tesselate_voronoi_+3A_stratify">stratify</code></td>
<td>
<p><strong>[logical]</strong> Whether the discretization happens within the
boundaries or whether the whole area is to be used (default to TRUE).</p>
</td></tr>
<tr><td><code id="tesselate_voronoi_+3A_seed">seed</code></td>
<td>
<p><strong>[numeric]</strong> Passed onto <code><a href="base.html#topic+Random">set.seed()</a></code>,
important for reproducibility of sampling.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named list with three elements (each an <code>sf</code> object):
* <code>patches</code>, the voronoi polygons generated
* <code>points</code>, the points used for the tessellation.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(borealis_simulated, package = "sspm")
data(sfa_boundaries, package = "sspm")
tesselate_voronoi(sfa_boundaries, with = borealis, sample_surface = TRUE,
                  boundary = "sfa", nb_samples = 10)

</code></pre>

<hr>
<h2 id='triangulate_delaunay'>Perform delaunay triangulation</h2><span id='topic+triangulate_delaunay'></span>

<h3>Description</h3>

<p>Generates delaunay triangles with <a href="sfdct.html#topic+ct_triangulate">ct_triangulate()</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>triangulate_delaunay(
  boundaries,
  with = NULL,
  boundary = "sfa",
  sample_surface = FALSE,
  sample_points = FALSE,
  nb_samples = NULL,
  min_size = 1000,
  seed = 1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="triangulate_delaunay_+3A_boundaries">boundaries</code></td>
<td>
<p><strong>[sf]</strong> The boundaries to be used.</p>
</td></tr>
<tr><td><code id="triangulate_delaunay_+3A_with">with</code></td>
<td>
<p><strong>[sf]</strong> A set of data points to use for voronoisation.</p>
</td></tr>
<tr><td><code id="triangulate_delaunay_+3A_boundary">boundary</code></td>
<td>
<p><strong>[character]</strong> The column in <code>boundaries</code> that is to
be used for the stratified sampling.</p>
</td></tr>
<tr><td><code id="triangulate_delaunay_+3A_sample_surface">sample_surface</code></td>
<td>
<p><strong>[logical]</strong> Whether to sample the surfaces in
<code>boundaries</code>, Default to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="triangulate_delaunay_+3A_sample_points">sample_points</code></td>
<td>
<p><strong>[logical]</strong> Whether to sample points from <code>with</code> or
to take all points in <code>with</code>. Default to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="triangulate_delaunay_+3A_nb_samples">nb_samples</code></td>
<td>
<p><strong>[named character vector]</strong> The number of samples to draw
by boundary polygons (must bear the levels of <code>boundary</code> as names
or be a single value to be applied to each level).</p>
</td></tr>
<tr><td><code id="triangulate_delaunay_+3A_min_size">min_size</code></td>
<td>
<p><strong>[numeric]</strong> The minimum size for a triangle above which it
will be merged (in km2).</p>
</td></tr>
<tr><td><code id="triangulate_delaunay_+3A_seed">seed</code></td>
<td>
<p><strong>[numeric]</strong> Passed onto <code><a href="base.html#topic+Random">set.seed()</a></code>,
important for reproducibility of sampling.</p>
</td></tr>
<tr><td><code id="triangulate_delaunay_+3A_...">...</code></td>
<td>

<p>Arguments passed on to <code><a href="RTriangle.html#topic+triangulate">RTriangle::triangulate</a></code>
</p>

<dl>
<dt><code>p</code></dt><dd><p>Planar straight line graph object; see
<code><a href="RTriangle.html#topic+pslg">pslg</a></code>.</p>
</dd>
<dt><code>a</code></dt><dd><p>Maximum triangle area. If specified, triangles cannot be
larger than this area.</p>
</dd>
<dt><code>q</code></dt><dd><p>Minimum triangle angle in degrees.</p>
</dd>
<dt><code>Y</code></dt><dd><p>If <code>TRUE</code> prohibits the insertion of Steiner points
on the mesh boundary.</p>
</dd>
<dt><code>j</code></dt><dd><p>If <code>TRUE</code> jettisons vertices that are not part of
the final triangulation from the output.</p>
</dd>
<dt><code>D</code></dt><dd><p>If <code>TRUE</code> produce a conforming Delaunay
triangulation. This ensures that all the triangles in the mesh
are truly Delaunay, and not merely constrained Delaunay. This
option invokes Ruppert's original algorithm, which splits every
subsegment whose diametral circle is encroached. It usually
increases the number of vertices and triangles.</p>
</dd>
<dt><code>S</code></dt><dd><p>Specifies the maximum number of added Steiner points. If
set to <code>Inf</code>, there is no limit on the number of Steine
points added - but this can lead to huge amounts of memory being
allocated.</p>
</dd>
<dt><code>V</code></dt><dd><p>Verbosity level. Specify higher values for more detailed
information about what the Triangle library is doing.</p>
</dd>
<dt><code>Q</code></dt><dd><p>If <code>TRUE</code> suppresses all explanation of what the
Triangle library is doing, unless an error occurs.</p>
</dd>
</dl>
</td></tr>
</table>


<h3>Value</h3>

<p>A named list with three elements (each an <code>sf</code> object):
* <code>patches</code>, the voronoi polygons generated
* <code>points</code>, the points used for the tessellation.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(borealis_simulated, package = "sspm")
data(sfa_boundaries, package = "sspm")
triangulate_delaunay(sfa_boundaries, with = borealis, sample_surface = TRUE,
                     boundary = "sfa", nb_samples = 10)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
