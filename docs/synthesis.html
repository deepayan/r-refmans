<!DOCTYPE html><html lang="en"><head><title>Help for package synthesis</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {synthesis}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#data.gen.affine'><p>Generate an affine error model.</p></a></li>
<li><a href='#data.gen.ar1'><p>Generate predictor and response data from AR1 model.</p></a></li>
<li><a href='#data.gen.ar4'><p>Generate predictor and response data from AR4 model.</p></a></li>
<li><a href='#data.gen.ar9'><p>Generate predictor and response data from AR9 model.</p></a></li>
<li><a href='#data.gen.blobs'><p>Gaussian Blobs</p></a></li>
<li><a href='#data.gen.bm'><p>Generate a time series of Brownian motion.</p></a></li>
<li><a href='#data.gen.BUWO'><p>Generate build-up and wash-off model for water quality modeling</p></a></li>
<li><a href='#data.gen.circles'><p>Circles</p></a></li>
<li><a href='#data.gen.Duffing'><p>Duffing map</p></a></li>
<li><a href='#data.gen.fbm'><p>Generate a time series of fractional Brownian motion.</p></a></li>
<li><a href='#data.gen.fm1'><p>Friedman with independent uniform variates</p></a></li>
<li><a href='#data.gen.fm2'><p>Friedman with correlated uniform variates</p></a></li>
<li><a href='#data.gen.gbm'><p>Generate a time series of geometric Brownian motion.</p></a></li>
<li><a href='#data.gen.Henon'><p>Henon map</p></a></li>
<li><a href='#data.gen.HL'><p>Generate predictor and response data: Hysteresis Loop</p></a></li>
<li><a href='#data.gen.LGSS'><p>Linear Gaussian state-space model</p></a></li>
<li><a href='#data.gen.Logistic'><p>Logistic map</p></a></li>
<li><a href='#data.gen.Lorenz'><p>Lorenz system</p></a></li>
<li><a href='#data.gen.nl1'><p>Nonlinear system with independent/correlate covariates</p></a></li>
<li><a href='#data.gen.nl2'><p>Nonlinear system with Exogenous covariates</p></a></li>
<li><a href='#data.gen.norm'><p>Generate correlated normal variates</p></a></li>
<li><a href='#data.gen.Rossler'><p>Rössler system</p></a></li>
<li><a href='#data.gen.rw'><p>Generate Random walk time series.</p></a></li>
<li><a href='#data.gen.spirals'><p>Spirals</p></a></li>
<li><a href='#data.gen.SW'><p>Generate predictor and response data: Sinusoidal model</p></a></li>
<li><a href='#data.gen.tar'><p>Generate a two-regime threshold autoregressive (TAR) process.</p></a></li>
<li><a href='#data.gen.tar1'><p>Generate predictor and response data from TAR1 model.</p></a></li>
<li><a href='#data.gen.tar2'><p>Generate predictor and response data from TAR2 model.</p></a></li>
<li><a href='#data.gen.unif'><p>Generate correlated uniform variates</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Generate Synthetic Data from Statistical Models</td>
</tr>
<tr>
<td>Version:</td>
<td>1.2.5</td>
</tr>
<tr>
<td>Author:</td>
<td>Ze Jiang <a href="https://orcid.org/0000-0002-3472-0829"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Ze Jiang &lt;ze.jiang@unsw.edu.au&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Generate synthetic time series from commonly used statistical models, including linear, nonlinear and chaotic systems. Applications to testing methods can be found in Jiang, Z., Sharma, A., &amp; Johnson, F. (2019) &lt;<a href="https://doi.org/10.1016%2Fj.advwatres.2019.103430">doi:10.1016/j.advwatres.2019.103430</a>&gt; and Jiang, Z., Sharma, A., &amp; Johnson, F. (2020) &lt;<a href="https://doi.org/10.1029%2F2019WR026962">doi:10.1029/2019WR026962</a>&gt; associated with an open-source tool by Jiang, Z., Rashid, M. M., Johnson, F., &amp; Sharma, A. (2020) &lt;<a href="https://doi.org/10.1016%2Fj.envsoft.2020.104907">doi:10.1016/j.envsoft.2020.104907</a>&gt;.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/zejiang-unsw/synthesis#readme">https://github.com/zejiang-unsw/synthesis#readme</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/zejiang-unsw/synthesis/issues">https://github.com/zejiang-unsw/synthesis/issues</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, MASS, graphics</td>
</tr>
<tr>
<td>Suggests:</td>
<td>zoo, knitr, rmarkdown, testthat, devtools</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-06-28 22:28:48 UTC; ze</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-07-07 15:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='data.gen.affine'>Generate an affine error model.</h2><span id='topic+data.gen.affine'></span>

<h3>Description</h3>

<p>Generate an affine error model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data.gen.affine(nobs, a = 0, b = 1, ndim = 3, mu = 0, sd = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="data.gen.affine_+3A_nobs">nobs</code></td>
<td>
<p>The data length to be generated.</p>
</td></tr>
<tr><td><code id="data.gen.affine_+3A_a">a</code></td>
<td>
<p>intercept</p>
</td></tr>
<tr><td><code id="data.gen.affine_+3A_b">b</code></td>
<td>
<p>slope</p>
</td></tr>
<tr><td><code id="data.gen.affine_+3A_ndim">ndim</code></td>
<td>
<p>The number of potential predictors (default is 9).</p>
</td></tr>
<tr><td><code id="data.gen.affine_+3A_mu">mu</code></td>
<td>
<p>mean of error term</p>
</td></tr>
<tr><td><code id="data.gen.affine_+3A_sd">sd</code></td>
<td>
<p>standard deviation of error term</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of 2 elements: a vector of response (x), and a matrix of potential predictors (dp) with each column containing one potential predictor.
</p>


<h3>References</h3>

<p>McColl, K. A., Vogelzang, J., Konings, A. G., Entekhabi, D., Piles, M., &amp; Stoffelen, A. (2014). Extended triple collocation: Estimating errors and correlation coefficients with respect to an unknown target. Geophysical Research Letters, 41(17), 6229-6236. doi:10.1002/2014gl061322
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Affine error model from paper with 3 dummy variables
data.affine&lt;-data.gen.affine(500)
plot.ts(cbind(data.affine$x,data.affine$dp))
</code></pre>

<hr>
<h2 id='data.gen.ar1'>Generate predictor and response data from AR1 model.</h2><span id='topic+data.gen.ar1'></span>

<h3>Description</h3>

<p>Generate predictor and response data from AR1 model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data.gen.ar1(nobs, ndim = 9)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="data.gen.ar1_+3A_nobs">nobs</code></td>
<td>
<p>The data length to be generated.</p>
</td></tr>
<tr><td><code id="data.gen.ar1_+3A_ndim">ndim</code></td>
<td>
<p>The number of potential predictors (default is 9).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of 2 elements: a vector of response (x), and a matrix of potential predictors (dp) with each column containing one potential predictor.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># AR1 model from paper with 9 dummy variables
data.ar1&lt;-data.gen.ar1(500)
plot.ts(cbind(data.ar1$x,data.ar1$dp))

</code></pre>

<hr>
<h2 id='data.gen.ar4'>Generate predictor and response data from AR4 model.</h2><span id='topic+data.gen.ar4'></span>

<h3>Description</h3>

<p>Generate predictor and response data from AR4 model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data.gen.ar4(nobs, ndim = 9)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="data.gen.ar4_+3A_nobs">nobs</code></td>
<td>
<p>The data length to be generated.</p>
</td></tr>
<tr><td><code id="data.gen.ar4_+3A_ndim">ndim</code></td>
<td>
<p>The number of potential predictors (default is 9).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of 2 elements: a vector of response (x), and a matrix of potential predictors (dp) with each column containing one potential predictor.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># AR4 model from paper with total 9 dimensions
data.ar4&lt;-data.gen.ar4(500)
plot.ts(cbind(data.ar4$x,data.ar4$dp))

</code></pre>

<hr>
<h2 id='data.gen.ar9'>Generate predictor and response data from AR9 model.</h2><span id='topic+data.gen.ar9'></span>

<h3>Description</h3>

<p>Generate predictor and response data from AR9 model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data.gen.ar9(nobs, ndim = 9)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="data.gen.ar9_+3A_nobs">nobs</code></td>
<td>
<p>The data length to be generated.</p>
</td></tr>
<tr><td><code id="data.gen.ar9_+3A_ndim">ndim</code></td>
<td>
<p>The number of potential predictors (default is 9).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of 2 elements: a vector of response (x), and a matrix of potential predictors (dp) with each column containing one potential predictor.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># AR9 model from paper with total 9 dimensions
data.ar9&lt;-data.gen.ar9(500)
plot.ts(cbind(data.ar9$x,data.ar9$dp))

</code></pre>

<hr>
<h2 id='data.gen.blobs'>Gaussian Blobs</h2><span id='topic+data.gen.blobs'></span>

<h3>Description</h3>

<p>Gaussian Blobs
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data.gen.blobs(
  nobs = 100,
  features = 2,
  centers = 3,
  sd = 1,
  bbox = c(-10, 10),
  do.plot = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="data.gen.blobs_+3A_nobs">nobs</code></td>
<td>
<p>The data length to be generated.</p>
</td></tr>
<tr><td><code id="data.gen.blobs_+3A_features">features</code></td>
<td>
<p>Features of dataset.</p>
</td></tr>
<tr><td><code id="data.gen.blobs_+3A_centers">centers</code></td>
<td>
<p>Either the number of centers, or a matrix of the chosen centers.</p>
</td></tr>
<tr><td><code id="data.gen.blobs_+3A_sd">sd</code></td>
<td>
<p>The level of Gaussian noise, default 1.</p>
</td></tr>
<tr><td><code id="data.gen.blobs_+3A_bbox">bbox</code></td>
<td>
<p>The bounding box of the dataset.</p>
</td></tr>
<tr><td><code id="data.gen.blobs_+3A_do.plot">do.plot</code></td>
<td>
<p>Logical value. If TRUE (default value), a plot of the generated Blobs is shown.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function generates a matrix of features creating multiclass datasets
by allocating each class one or more normally-distributed clusters of points.
It can control both centers and standard deviations of each cluster.
For example, we want to generate a dataset of weight and height (two features) of 500 people (data length),
including three groups, baby, children, and adult. Centers are the average weight and height for each group,
assuming both weight and height are normally distributed (i.e. follow Gaussian distribution).
The standard deviation (sd) is the sd of the Gaussian distribution
while the bounding box (bbox) is the range for each generated cluster center when only the number of centers is given.
</p>


<h3>Value</h3>

<p>A list of two variables, x and classes.
</p>


<h3>References</h3>

<p>Amos Elberg (2018). clusteringdatasets: Datasets useful for testing clustering algorithms. R package version 0.1.1. https://github.com/elbamos/clusteringdatasets
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Blobs=data.gen.blobs(nobs=1000, features=2, centers=3, sd=1, bbox=c(-10,10), do.plot=TRUE)
</code></pre>

<hr>
<h2 id='data.gen.bm'>Generate a time series of Brownian motion.</h2><span id='topic+data.gen.bm'></span>

<h3>Description</h3>

<p>This function generates a time series of one dimension Brownian motion.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data.gen.bm(
  x0 = 0,
  w0 = 0,
  time = seq(0, by = 0.01, length.out = 101),
  do.plot = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="data.gen.bm_+3A_x0">x0</code></td>
<td>
<p>the start value of x, with the default value 0</p>
</td></tr>
<tr><td><code id="data.gen.bm_+3A_w0">w0</code></td>
<td>
<p>the start value of w, with the default value 0</p>
</td></tr>
<tr><td><code id="data.gen.bm_+3A_time">time</code></td>
<td>
<p>the temporal interval at which the system will be generated. Default seq(0,by=0.01,len=101).</p>
</td></tr>
<tr><td><code id="data.gen.bm_+3A_do.plot">do.plot</code></td>
<td>
<p>a logical value. If TRUE (default value), a plot of the generated system is shown.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ts object.
</p>


<h3>References</h3>

<p>Yanping Chen, http://cos.name/wp-content/uploads/2008/12/stochastic-differential-equation-with-r.pdf
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)
x &lt;- data.gen.bm()
</code></pre>

<hr>
<h2 id='data.gen.BUWO'>Generate build-up and wash-off model for water quality modeling</h2><span id='topic+data.gen.BUWO'></span>

<h3>Description</h3>

<p>Generate build-up and wash-off model for water quality modeling
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data.gen.BUWO(nobs, k = 0.5, a = 1, m0 = 10, q = 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="data.gen.BUWO_+3A_nobs">nobs</code></td>
<td>
<p>The data length to be generated.</p>
</td></tr>
<tr><td><code id="data.gen.BUWO_+3A_k">k</code></td>
<td>
<p>build-up coefficient (kg*t-1)</p>
</td></tr>
<tr><td><code id="data.gen.BUWO_+3A_a">a</code></td>
<td>
<p>wash-off rate constant (m-3)</p>
</td></tr>
<tr><td><code id="data.gen.BUWO_+3A_m0">m0</code></td>
<td>
<p>threshold at which additional mass does not accumulate on the surface (kg)</p>
</td></tr>
<tr><td><code id="data.gen.BUWO_+3A_q">q</code></td>
<td>
<p>runoff (m3*t-1)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of 2 elements: a vector of build-up mass (x), and a vector of wash-off mass (y) per unit time.
</p>


<h3>References</h3>

<p>Wu, X., Marshall, L., &amp; Sharma, A. (2019). The influence of data transformations in simulating Total Suspended Solids using Bayesian inference. Environmental modelling &amp; software, 121, 104493. doi:https://doi.org/10.1016/j.envsoft.2019.104493
</p>
<p>Shaw, S. B., Stedinger, J. R., &amp; Walter, M. T. (2010). Evaluating Urban Pollutant Buildup/Wash-Off Models Using a Madison, Wisconsin Catchment. Journal of Environmental Engineering, 136(2), 194-203. https://doi.org/10.1061/(ASCE)EE.1943-7870.0000142
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Build up model
set.seed(101)
sample = 500
#create a gamma shape storm event
q&lt;- seq(0,20, length.out=sample)
p &lt;- pgamma(q, shape=9, rate =2, lower.tail = TRUE)
p &lt;- c(p[1],p[2:sample]-p[1:(sample-1)])

data.tss&lt;-data.gen.BUWO(sample, k=0.5, a=5, m0=10, q=p)
plot.ts(cbind(p, data.tss$x, data.tss$y), ylab=c("Q","Bulid-up","Wash-off"))
</code></pre>

<hr>
<h2 id='data.gen.circles'>Circles</h2><span id='topic+data.gen.circles'></span>

<h3>Description</h3>

<p>Circles
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data.gen.circles(
  n,
  r_vec = c(1, 2),
  start = runif(1, -1, 1),
  s,
  do.plot = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="data.gen.circles_+3A_n">n</code></td>
<td>
<p>The data length to be generated.</p>
</td></tr>
<tr><td><code id="data.gen.circles_+3A_r_vec">r_vec</code></td>
<td>
<p>The radius of circles.</p>
</td></tr>
<tr><td><code id="data.gen.circles_+3A_start">start</code></td>
<td>
<p>The center of circles.</p>
</td></tr>
<tr><td><code id="data.gen.circles_+3A_s">s</code></td>
<td>
<p>The level of Gaussian noise, default 0.</p>
</td></tr>
<tr><td><code id="data.gen.circles_+3A_do.plot">do.plot</code></td>
<td>
<p>Logical value. If TRUE (default value), a plot of the generated Circles is shown.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of two variables, x and classes.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Circles=data.gen.circles(n = 1000, r_vec=c(1,2), start=runif(1,-1,1), s=0.1, do.plot=TRUE)
</code></pre>

<hr>
<h2 id='data.gen.Duffing'>Duffing map</h2><span id='topic+data.gen.Duffing'></span>

<h3>Description</h3>

<p>Generates a 2-dimensional time series using the Duffing map.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data.gen.Duffing(
  nobs = 5000,
  a = 2.75,
  b = 0.2,
  start = runif(n = 2, min = -0.5, max = 0.5),
  s,
  do.plot = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="data.gen.Duffing_+3A_nobs">nobs</code></td>
<td>
<p>Length of the generated time series. Default: 5000 samples.</p>
</td></tr>
<tr><td><code id="data.gen.Duffing_+3A_a">a</code></td>
<td>
<p>The <em>a</em> parameter. Default: 2.75.</p>
</td></tr>
<tr><td><code id="data.gen.Duffing_+3A_b">b</code></td>
<td>
<p>The <em>b</em> parameter. Default: 0.2.</p>
</td></tr>
<tr><td><code id="data.gen.Duffing_+3A_start">start</code></td>
<td>
<p>A 2-dimensional vector indicating the starting values for the x and y Duffing coordinates.
Default: If the starting point is not specified, it is generated randomly.</p>
</td></tr>
<tr><td><code id="data.gen.Duffing_+3A_s">s</code></td>
<td>
<p>The level of noise, default 0.</p>
</td></tr>
<tr><td><code id="data.gen.Duffing_+3A_do.plot">do.plot</code></td>
<td>
<p>Logical value. If TRUE (default value), a plot of the generated Duffing system is shown.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Duffing map is defined as follows:
</p>
<p style="text-align: center;"><code class="reqn"> x_n = y_{n - 1}</code>
</p>

<p style="text-align: center;"><code class="reqn"> y_n = -b \cdot x_{n - 1} + a \cdot y_{n - 1} - y_{n - 1}^3</code>
</p>

<p>The default selection for both <em>a</em> and <em>b</em> parameters
(<em>a</em>=1.4 and <em>b</em>=0.3) is known to produce a deterministic chaotic
time series.
</p>


<h3>Value</h3>

<p>A list with two vectors named <em>x</em> and <em>y</em> containing the
x-components and the y-components of the Duffing map, respectively.
</p>


<h3>Note</h3>

<p>Some initial values may lead to an unstable system that will tend to infinity.
</p>


<h3>References</h3>

<p>Constantino A. Garcia (2019). nonlinearTseries: Nonlinear Time Series Analysis. R package version 0.2.7. https://CRAN.R-project.org/package=nonlinearTseries
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Duffing.map=data.gen.Duffing(nobs = 1000, do.plot=TRUE)
</code></pre>

<hr>
<h2 id='data.gen.fbm'>Generate a time series of fractional Brownian motion.</h2><span id='topic+data.gen.fbm'></span>

<h3>Description</h3>

<p>This function generates a a time series of one dimension fractional Brownian motion.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data.gen.fbm(
  hurst = 0.95,
  time = seq(0, by = 0.01, length.out = 1000),
  do.plot = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="data.gen.fbm_+3A_hurst">hurst</code></td>
<td>
<p>the hurst index, with the default value 0.95, ranging from [0,1].</p>
</td></tr>
<tr><td><code id="data.gen.fbm_+3A_time">time</code></td>
<td>
<p>the temporal interval at which the system will be generated. Default seq(0,by=0.01,len=1000).</p>
</td></tr>
<tr><td><code id="data.gen.fbm_+3A_do.plot">do.plot</code></td>
<td>
<p>a logical value. If TRUE (default value), a plot of the generated system is shown.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ts object.
</p>


<h3>References</h3>

<p>Zdravko Botev (2020). Fractional Brownian motion generator (https://www.mathworks.com/matlabcentral/fileexchange/38935-fractional-brownian-motion-generator), MATLAB Central File Exchange. Retrieved August 17, 2020.
</p>
<p>Kroese, D. P., &amp; Botev, Z. I. (2015). Spatial Process Simulation. In Stochastic Geometry, Spatial Statistics and Random Fields(pp. 369-404) Springer International Publishing, DOI: 10.1007/978-3-319-10064-7_12
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)
x &lt;- data.gen.fbm()
</code></pre>

<hr>
<h2 id='data.gen.fm1'>Friedman with independent uniform variates</h2><span id='topic+data.gen.fm1'></span>

<h3>Description</h3>

<p>Friedman with independent uniform variates
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data.gen.fm1(nobs, ndim = 9, noise = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="data.gen.fm1_+3A_nobs">nobs</code></td>
<td>
<p>The data length to be generated.</p>
</td></tr>
<tr><td><code id="data.gen.fm1_+3A_ndim">ndim</code></td>
<td>
<p>The number of potential predictors (default is 9).</p>
</td></tr>
<tr><td><code id="data.gen.fm1_+3A_noise">noise</code></td>
<td>
<p>The noise level in the time series.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of 3 elements: a vector of response (x), a matrix of potential predictors (dp) with each column containing one potential predictor, and a vector of true predictor numbers.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>###synthetic example - Friedman
#Friedman with independent uniform variates
data.fm1 &lt;- data.gen.fm1(nobs=1000, ndim = 9, noise = 0)

#Friedman with correlated uniform variates
data.fm2 &lt;- data.gen.fm2(nobs=1000, ndim = 9, r = 0.6, noise = 0)

plot.ts(cbind(data.fm1$x,data.fm2$x), col=c('red','blue'), main=NA, xlab=NA,
        ylab=c('Friedman with \n independent uniform variates',
        'Friedman with \n correlated uniform variates'))
</code></pre>

<hr>
<h2 id='data.gen.fm2'>Friedman with correlated uniform variates</h2><span id='topic+data.gen.fm2'></span>

<h3>Description</h3>

<p>Friedman with correlated uniform variates
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data.gen.fm2(nobs, ndim = 9, r = 0.6, noise = 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="data.gen.fm2_+3A_nobs">nobs</code></td>
<td>
<p>The data length to be generated.</p>
</td></tr>
<tr><td><code id="data.gen.fm2_+3A_ndim">ndim</code></td>
<td>
<p>The number of potential predictors (default is 9).</p>
</td></tr>
<tr><td><code id="data.gen.fm2_+3A_r">r</code></td>
<td>
<p>Target Spearman correlation.</p>
</td></tr>
<tr><td><code id="data.gen.fm2_+3A_noise">noise</code></td>
<td>
<p>The noise level in the time series.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of 3 elements: a vector of response (x), a matrix of potential predictors (dp) with each column containing one potential predictor, and a vector of true predictor numbers.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>###synthetic example - Friedman
#Friedman with independent uniform variates
data.fm1 &lt;- data.gen.fm1(nobs=1000, ndim = 9, noise = 0)

#Friedman with correlated uniform variates
data.fm2 &lt;- data.gen.fm2(nobs=1000, ndim = 9, r = 0.6, noise = 0)

plot.ts(cbind(data.fm1$x,data.fm2$x), col=c('red','blue'), main=NA, xlab=NA,
        ylab=c('Friedman with \n independent uniform variates',
        'Friedman with \n correlated uniform variates'))
</code></pre>

<hr>
<h2 id='data.gen.gbm'>Generate a time series of geometric Brownian motion.</h2><span id='topic+data.gen.gbm'></span>

<h3>Description</h3>

<p>This function generates a a time series of one dimension geometric Brownian motion.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data.gen.gbm(
  x0 = 10,
  w0 = 0,
  mu = 1,
  sigma = 0.5,
  time = seq(0, by = 0.01, length.out = 101),
  do.plot = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="data.gen.gbm_+3A_x0">x0</code></td>
<td>
<p>the start value of x, with the default value 10</p>
</td></tr>
<tr><td><code id="data.gen.gbm_+3A_w0">w0</code></td>
<td>
<p>the start value of w, with the default value 0</p>
</td></tr>
<tr><td><code id="data.gen.gbm_+3A_mu">mu</code></td>
<td>
<p>the interest/drifting rate, with the default value 1.</p>
</td></tr>
<tr><td><code id="data.gen.gbm_+3A_sigma">sigma</code></td>
<td>
<p>the diffusion coefficient, with the default value 0.5.</p>
</td></tr>
<tr><td><code id="data.gen.gbm_+3A_time">time</code></td>
<td>
<p>the temporal interval at which the system will be generated. Default seq(0,by=0.01,len=101).</p>
</td></tr>
<tr><td><code id="data.gen.gbm_+3A_do.plot">do.plot</code></td>
<td>
<p>a logical value. If TRUE (default value), a plot of the generated system is shown.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ts object.
</p>


<h3>References</h3>

<p>Yanping Chen, http://cos.name/wp-content/uploads/2008/12/stochastic-differential-equation-with-r.pdf
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)
x &lt;- data.gen.gbm()
</code></pre>

<hr>
<h2 id='data.gen.Henon'>Henon map</h2><span id='topic+data.gen.Henon'></span>

<h3>Description</h3>

<p>Generates a 2-dimensional time series using the Henon map.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data.gen.Henon(
  nobs = 5000,
  a = 1.4,
  b = 0.3,
  start = runif(n = 2, min = -0.5, max = 0.5),
  s,
  do.plot = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="data.gen.Henon_+3A_nobs">nobs</code></td>
<td>
<p>Length of the generated time series. Default: 5000 samples.</p>
</td></tr>
<tr><td><code id="data.gen.Henon_+3A_a">a</code></td>
<td>
<p>The <em>a</em> parameter. Default: 1.4.</p>
</td></tr>
<tr><td><code id="data.gen.Henon_+3A_b">b</code></td>
<td>
<p>The <em>b</em> parameter. Default: 0.3.</p>
</td></tr>
<tr><td><code id="data.gen.Henon_+3A_start">start</code></td>
<td>
<p>A 2-dimensional vector indicating the starting values for the x and y Henon coordinates.
Default: If the starting point is not specified, it is generated randomly.</p>
</td></tr>
<tr><td><code id="data.gen.Henon_+3A_s">s</code></td>
<td>
<p>The level of noise, default 0.</p>
</td></tr>
<tr><td><code id="data.gen.Henon_+3A_do.plot">do.plot</code></td>
<td>
<p>Logical value. If TRUE (default value), a plot of the generated Henon system is shown.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Henon map is defined as follows:
</p>
<p style="text-align: center;"><code class="reqn"> x_n = 1 - a \cdot x_{n - 1}^2 + y_{n - 1}</code>
</p>

<p style="text-align: center;"><code class="reqn"> y_n = b \cdot x_{n - 1}</code>
</p>

<p>The default selection for both <em>a</em> and <em>b</em> parameters
(<em>a</em>=1.4 and <em>b</em>=0.3) is known to produce a deterministic chaotic
time series.
</p>


<h3>Value</h3>

<p>A list with two vectors named <em>x</em> and <em>y</em> containing the
x-components and the y-components of the Henon map, respectively.
</p>


<h3>Note</h3>

<p>Some initial values may lead to an unstable system that will tend to infinity.
</p>


<h3>References</h3>

<p>Constantino A. Garcia (2019). nonlinearTseries: Nonlinear Time Series Analysis. R package version 0.2.7. https://CRAN.R-project.org/package=nonlinearTseries
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Henon.map=data.gen.Henon(nobs = 1000, do.plot=TRUE)
</code></pre>

<hr>
<h2 id='data.gen.HL'>Generate predictor and response data: Hysteresis Loop</h2><span id='topic+data.gen.HL'></span>

<h3>Description</h3>

<p>Generate predictor and response data: Hysteresis Loop
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data.gen.HL(
  nobs = 512,
  a = 0.8,
  b = 0.6,
  c = 0.2,
  m = 3,
  n = 5,
  fp = 25,
  fd,
  sd.x = 0.1,
  sd.y = 0.1
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="data.gen.HL_+3A_nobs">nobs</code></td>
<td>
<p>The data length to be generated.</p>
</td></tr>
<tr><td><code id="data.gen.HL_+3A_a">a</code></td>
<td>
<p>The <em>a</em> parameter. Default: 0.8.</p>
</td></tr>
<tr><td><code id="data.gen.HL_+3A_b">b</code></td>
<td>
<p>The <em>b</em> parameter. Default: 0.6.</p>
</td></tr>
<tr><td><code id="data.gen.HL_+3A_c">c</code></td>
<td>
<p>The <em>c</em> parameter. Default: 0.2.</p>
</td></tr>
<tr><td><code id="data.gen.HL_+3A_m">m</code></td>
<td>
<p>Positive integer for the split line parameter.
If m=1, split line is linear; If m is even, split line has a u shape;
If m is odd and higher than 1, split line has a chair or classical shape.</p>
</td></tr>
<tr><td><code id="data.gen.HL_+3A_n">n</code></td>
<td>
<p>Positive odd integer for the bulging parameter, indicates degree of outward curving (1=highest level of bulging).</p>
</td></tr>
<tr><td><code id="data.gen.HL_+3A_fp">fp</code></td>
<td>
<p>The frequency in the generated response. fp = 25 used in the WRR paper.</p>
</td></tr>
<tr><td><code id="data.gen.HL_+3A_fd">fd</code></td>
<td>
<p>A vector of frequencies for potential predictors. fd = c(3,5,10,15,25,30,55,70,95) used in the WRR paper.</p>
</td></tr>
<tr><td><code id="data.gen.HL_+3A_sd.x">sd.x</code></td>
<td>
<p>The noise level in the predictor.</p>
</td></tr>
<tr><td><code id="data.gen.HL_+3A_sd.y">sd.y</code></td>
<td>
<p>The noise level in the response.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Hysteresis is a common nonlinear phenomenon in natural systems and it can be numerical simulated by the following formulas:
</p>
<p style="text-align: center;"><code class="reqn">x_{t} = a*cos(2pi*f*t)</code>
</p>

<p style="text-align: center;"><code class="reqn">y_{t} = b*cos(2pi*f*t)^m - c*sin(2pi*f*t)^n</code>
</p>

<p>The default selection for the system parameters (<em>a</em> = 0.8, <em>b</em> = 0.6, <em>c</em> = 0.2, <em>m</em> = 3, <em>n</em> = 5) is known to generate a classical hysteresis loop.
</p>


<h3>Value</h3>

<p>A list of 3 elements: a vector of response (x), a matrix of potential predictors (dp) with each column containing one potential predictor, and a vector of true predictor numbers.
</p>


<h3>References</h3>

<p>LAPSHIN, R. V. 1995. Analytical model for the approximation of hysteresis loop and its application to the scanning tunneling microscope. Review of Scientific Instruments, 66, 4718-4730.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>###synthetic example - Hysteresis loop
#frequency, sampled from a given range
fd &lt;- c(3,5,10,15,25,30,55,70,95)

data.HL &lt;- data.gen.HL(m=3,n=5,nobs=512,fp=25,fd=fd)
plot.ts(cbind(data.HL$x,data.HL$dp))
</code></pre>

<hr>
<h2 id='data.gen.LGSS'>Linear Gaussian state-space model</h2><span id='topic+data.gen.LGSS'></span>

<h3>Description</h3>

<p>Generates data from a specific linear Gaussian state space model of the form
<code class="reqn"> x_{t} = \phi x_{t-1} + \sigma_v v_t </code> and <code class="reqn"> y_t = x_t +
\sigma_e e_t </code>, where <code class="reqn">v_t</code> and <code class="reqn">e_t</code> denote independent standard
Gaussian random variables, i.e. <code class="reqn">N(0,1)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data.gen.LGSS(
  theta,
  nobs,
  start = runif(n = 1, min = -1, max = 1),
  do.plot = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="data.gen.LGSS_+3A_theta">theta</code></td>
<td>
<p>The parameters <code class="reqn">\theta=\{\phi,\sigma_v,\sigma_e\}</code> of the LGSS model.</p>
</td></tr>
<tr><td><code id="data.gen.LGSS_+3A_nobs">nobs</code></td>
<td>
<p>The data length to be generated.</p>
</td></tr>
<tr><td><code id="data.gen.LGSS_+3A_start">start</code></td>
<td>
<p>A numeric value indicating the starting value for the time series.
If the starting point is not specified, it is generated randomly.</p>
</td></tr>
<tr><td><code id="data.gen.LGSS_+3A_do.plot">do.plot</code></td>
<td>
<p>Logical value. If TRUE (default value), a plot of the generated LGSS system is shown.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of two variables, state and response.
</p>


<h3>References</h3>

<p>#Dahlin, J. &amp; Schon, T. B. 'Getting Started with Particle Metropolis-Hastings for Inference in Nonlinear Dynamical Models.'
Journal of Statistical Software, Code Snippets, 88(2): 1&ndash;41, 2019.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data.LGSS &lt;- data.gen.LGSS(theta=c(0.75,1.00,0.10), nobs=500, start=0)
</code></pre>

<hr>
<h2 id='data.gen.Logistic'>Logistic map</h2><span id='topic+data.gen.Logistic'></span>

<h3>Description</h3>

<p>Generates a time series using the logistic map.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data.gen.Logistic(
  nobs = 5000,
  r = 4,
  start = runif(n = 1, min = 0, max = 1),
  s,
  do.plot = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="data.gen.Logistic_+3A_nobs">nobs</code></td>
<td>
<p>Length of the generated time series. Default: 5000 samples.</p>
</td></tr>
<tr><td><code id="data.gen.Logistic_+3A_r">r</code></td>
<td>
<p>The <em>r</em> parameter. Default: 4</p>
</td></tr>
<tr><td><code id="data.gen.Logistic_+3A_start">start</code></td>
<td>
<p>A numeric value indicating the starting value for the time series.
If the starting point is not specified, it is generated randomly.</p>
</td></tr>
<tr><td><code id="data.gen.Logistic_+3A_s">s</code></td>
<td>
<p>The level of noise, default 0.</p>
</td></tr>
<tr><td><code id="data.gen.Logistic_+3A_do.plot">do.plot</code></td>
<td>
<p>Logical value. If TRUE (default value), a plot of the generated Logistic system is shown.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The logistic map is defined as follows:
</p>
<p style="text-align: center;"><code class="reqn">x_n = r  \cdot  x_{n-1}   \cdot  (1 - x_{n-1})</code>
</p>



<h3>Value</h3>

<p>A vector of time series.
</p>


<h3>References</h3>

<p>Constantino A. Garcia (2019). nonlinearTseries: Nonlinear Time Series Analysis. R package version 0.2.7. https://CRAN.R-project.org/package=nonlinearTseries
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Logistic.map=data.gen.Logistic(nobs = 1000, do.plot=TRUE)
</code></pre>

<hr>
<h2 id='data.gen.Lorenz'>Lorenz system</h2><span id='topic+data.gen.Lorenz'></span>

<h3>Description</h3>

<p>Generates a 3-dimensional time series using the Lorenz equations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data.gen.Lorenz(
  sigma = 10,
  beta = 8/3,
  rho = 28,
  start = c(-13, -14, 47),
  time = seq(0, 50, length.out = 1000),
  s
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="data.gen.Lorenz_+3A_sigma">sigma</code></td>
<td>
<p>The <code class="reqn">\sigma</code> parameter. Default: 10.</p>
</td></tr>
<tr><td><code id="data.gen.Lorenz_+3A_beta">beta</code></td>
<td>
<p>The <code class="reqn">\beta</code> parameter. Default: 8/3.</p>
</td></tr>
<tr><td><code id="data.gen.Lorenz_+3A_rho">rho</code></td>
<td>
<p>The <code class="reqn">\rho</code> parameter. Default: 28.</p>
</td></tr>
<tr><td><code id="data.gen.Lorenz_+3A_start">start</code></td>
<td>
<p>A 3-dimensional numeric vector indicating the starting point for the time series.
Default: c(-13, -14, 47).</p>
</td></tr>
<tr><td><code id="data.gen.Lorenz_+3A_time">time</code></td>
<td>
<p>The temporal interval at which the system will be generated.
Default: time=seq(0,50,by = 0.01).</p>
</td></tr>
<tr><td><code id="data.gen.Lorenz_+3A_s">s</code></td>
<td>
<p>The level of noise, default 0.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Lorenz system is a system of ordinary differential equations defined as:
</p>
<p style="text-align: center;"><code class="reqn">\dot{x} = \sigma(y-x)</code>
</p>

<p style="text-align: center;"><code class="reqn">\dot{y} = \rho x-y-xz</code>
</p>

<p style="text-align: center;"><code class="reqn">\dot{z} = -\beta z + xy</code>
</p>

<p>The default selection for the system parameters (<code class="reqn">\sigma=10, \rho=28, \beta=8/3</code>) is known to
produce a deterministic chaotic time series.
</p>


<h3>Value</h3>

<p>A list with four vectors named <em>time</em>, <em>x</em>, <em>y</em>
and <em>z</em> containing the time, the x-components, the
y-components and the z-components of the Lorenz system, respectively.
</p>


<h3>Note</h3>

<p>Some initial values may lead to an unstable system that will tend to infinity.
</p>


<h3>References</h3>

<p>Constantino A. Garcia (2019). nonlinearTseries: Nonlinear Time Series Analysis. R package version 0.2.7. https://CRAN.R-project.org/package=nonlinearTseries
</p>


<h3>Examples</h3>

<pre><code class='language-R'>###Synthetic example - Lorenz
ts.l &lt;- data.gen.Lorenz(sigma = 10, beta = 8/3, rho = 28, start = c(-13, -14, 47),
                        time = seq(0, by=0.05, length.out = 2000))

ts.plot(cbind(ts.l$x,ts.l$y,ts.l$z), col=c('black','red','blue'))
</code></pre>

<hr>
<h2 id='data.gen.nl1'>Nonlinear system with independent/correlate covariates</h2><span id='topic+data.gen.nl1'></span>

<h3>Description</h3>

<p>Nonlinear system with independent/correlate covariates
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data.gen.nl1(nobs, ndim = 15, r = 0.6, noise = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="data.gen.nl1_+3A_nobs">nobs</code></td>
<td>
<p>The data length to be generated.</p>
</td></tr>
<tr><td><code id="data.gen.nl1_+3A_ndim">ndim</code></td>
<td>
<p>The number of potential predictors (default is 9).</p>
</td></tr>
<tr><td><code id="data.gen.nl1_+3A_r">r</code></td>
<td>
<p>Target Spearman correlation among covariates.</p>
</td></tr>
<tr><td><code id="data.gen.nl1_+3A_noise">noise</code></td>
<td>
<p>The noise level in the time series.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of 3 elements: a vector of response (x), a matrix of potential predictors (dp) with each column containing one potential predictor, and a vector of true predictor numbers.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>###synthetic example - Friedman
#Friedman with independent uniform variates
data.nl1 &lt;- data.gen.nl1(nobs=1000)

#Friedman with correlated uniform variates
data.nl2 &lt;- data.gen.nl2(nobs=1000)

plot.ts(cbind(data.nl1$x,data.nl2$x), col=c('red','blue'), main=NA, xlab=NA,
        ylab=c('Nonlinear system with \n independent uniform variates',
        'Nonlinear system with \n correlated uniform variates'))
</code></pre>

<hr>
<h2 id='data.gen.nl2'>Nonlinear system with Exogenous covariates</h2><span id='topic+data.gen.nl2'></span>

<h3>Description</h3>

<p>Nonlinear system with Exogenous covariates
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data.gen.nl2(nobs, ndim = 7, noise = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="data.gen.nl2_+3A_nobs">nobs</code></td>
<td>
<p>The data length to be generated.</p>
</td></tr>
<tr><td><code id="data.gen.nl2_+3A_ndim">ndim</code></td>
<td>
<p>The number of potential predictors (default is 9).</p>
</td></tr>
<tr><td><code id="data.gen.nl2_+3A_noise">noise</code></td>
<td>
<p>The noise level in the time series.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of 3 elements: a vector of response (x), a matrix of potential predictors (dp) with each column containing one potential predictor, and a vector of true predictor numbers.
</p>


<h3>References</h3>

<p>Sharma, A., &amp; Mehrotra, R. (2014). An information theoretic alternative to model a natural system using observational information alone. Water Resources Research, 50(1), 650-660.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>###synthetic example - Friedman
#Friedman with independent uniform variates
data.nl1 &lt;- data.gen.nl1(nobs=1000)

#Friedman with correlated uniform variates
data.nl2 &lt;- data.gen.nl2(nobs=1000)

plot.ts(cbind(data.nl1$x,data.nl2$x), col=c('red','blue'), main=NA, xlab=NA,
        ylab=c('Nonlinear system with \n independent uniform variates',
        'Nonlinear system with \n correlated uniform variates'))
</code></pre>

<hr>
<h2 id='data.gen.norm'>Generate correlated normal variates</h2><span id='topic+data.gen.norm'></span>

<h3>Description</h3>

<p>Generate correlated normal variates
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data.gen.norm(n, mu = rep(0, 2), sd = rep(1, 2), r = 0.6, sigma)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="data.gen.norm_+3A_n">n</code></td>
<td>
<p>The data length to be generated.</p>
</td></tr>
<tr><td><code id="data.gen.norm_+3A_mu">mu</code></td>
<td>
<p>A vector giving the means of the variables.</p>
</td></tr>
<tr><td><code id="data.gen.norm_+3A_sd">sd</code></td>
<td>
<p>A vector giving the standard deviation of the variables.</p>
</td></tr>
<tr><td><code id="data.gen.norm_+3A_r">r</code></td>
<td>
<p>The target Pearson correlation, default is 0.6.</p>
</td></tr>
<tr><td><code id="data.gen.norm_+3A_sigma">sigma</code></td>
<td>
<p>A positive-definite symmetric matrix specifying the covariance matrix of the variables.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of correlated normal variates
</p>

<hr>
<h2 id='data.gen.Rossler'>Rössler system</h2><span id='topic+data.gen.Rossler'></span>

<h3>Description</h3>

<p>Generates a 3-dimensional time series using the Rossler equations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data.gen.Rossler(
  a = 0.2,
  b = 0.2,
  w = 5.7,
  start = c(-2, -10, 0.2),
  time = seq(0, by = 0.05, length.out = 1000),
  s
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="data.gen.Rossler_+3A_a">a</code></td>
<td>
<p>The <em>a</em> parameter. Default: 0.2.</p>
</td></tr>
<tr><td><code id="data.gen.Rossler_+3A_b">b</code></td>
<td>
<p>The <em>b</em> parameter. Default: 0.2.</p>
</td></tr>
<tr><td><code id="data.gen.Rossler_+3A_w">w</code></td>
<td>
<p>The <em>w</em> parameter. Default: 5.7.</p>
</td></tr>
<tr><td><code id="data.gen.Rossler_+3A_start">start</code></td>
<td>
<p>A 3-dimensional numeric vector indicating the starting point for the time series.
Default: c(-2, -10, 0.2).</p>
</td></tr>
<tr><td><code id="data.gen.Rossler_+3A_time">time</code></td>
<td>
<p>The temporal interval at which the system will be generated.
Default: time=seq(0,50,by=0.01) or time = seq(0,by=0.01,length.out = 1000)</p>
</td></tr>
<tr><td><code id="data.gen.Rossler_+3A_s">s</code></td>
<td>
<p>The level of noise, default 0.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Rössler system is a system of ordinary differential equations defined as:
</p>
<p style="text-align: center;"><code class="reqn">\dot{x} = -(y + z)</code>
</p>

<p style="text-align: center;"><code class="reqn">\dot{y} = x+a \cdot y</code>
</p>

<p style="text-align: center;"><code class="reqn">\dot{z} = b + z*(x-w)</code>
</p>

<p>The default selection for the system parameters (<em>a</em> = 0.2, <em>b</em> = 0.2, <em>w</em> = 5.7) is known to
produce a deterministic chaotic time series. However, the values a = 0.1, b = 0.1, and c = 14 are more commonly used.
These Rössler equations are simpler than those Lorenz used since only one nonlinear term appears (the product xz in the third equation).
</p>
<p>Here, a = b = 0.1 and c changes. The bifurcation diagram reveals that low values of c are periodic,
but quickly become chaotic as c increases. This pattern repeats itself as c increases &mdash;
there are sections of periodicity interspersed with periods of chaos,
and the trend is towards higher-period orbits as c increases.
For example, the period one orbit only appears for values of c around 4
and is never found again in the bifurcation diagram. The same phenomenon is seen with period three;
until c = 12, period three orbits can be found, but thereafter, they do not appear.
</p>


<h3>Value</h3>

<p>A list with four vectors named <em>time</em>, <em>x</em>, <em>y</em>
and <em>z</em> containing the time, the x-components, the
y-components and the z-components of the Rössler system, respectively.
</p>


<h3>Note</h3>

<p>Some initial values may lead to an unstable system that will tend to infinity.
</p>


<h3>References</h3>

<p>Rössler, O. E. 1976. An equation for continuous chaos. Physics Letters A, 57, 397-398.
</p>
<p>Constantino A. Garcia (2019). nonlinearTseries: Nonlinear Time Series Analysis. R package version 0.2.7. https://CRAN.R-project.org/package=nonlinearTseries
</p>
<p>wikipedia https://en.wikipedia.org/wiki/R
</p>


<h3>Examples</h3>

<pre><code class='language-R'>###synthetic example - Rössler

ts.r &lt;- data.gen.Rossler(a = 0.1, b = 0.1, w = 8.7, start = c(-2, -10, 0.2),
                         time = seq(0, by=0.05, length.out = 10000))

oldpar &lt;- par(no.readonly = TRUE)
par(mfrow=c(1,1), ps=12, cex.lab=1.5)
plot.ts(cbind(ts.r$x,ts.r$y,ts.r$z), col=c('black','red','blue'))

par(mfrow=c(1,2), ps=12, cex.lab=1.5)
plot(ts.r$x,ts.r$y, xlab='x',ylab = 'y', type = 'l')
plot(ts.r$x,ts.r$z, xlab='x',ylab = 'z', type = 'l')
par(oldpar)

</code></pre>

<hr>
<h2 id='data.gen.rw'>Generate Random walk time series.</h2><span id='topic+data.gen.rw'></span>

<h3>Description</h3>

<p>Generate Random walk time series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data.gen.rw(nobs, drift = 0.2, sd = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="data.gen.rw_+3A_nobs">nobs</code></td>
<td>
<p>the data length to be generated</p>
</td></tr>
<tr><td><code id="data.gen.rw_+3A_drift">drift</code></td>
<td>
<p>drift</p>
</td></tr>
<tr><td><code id="data.gen.rw_+3A_sd">sd</code></td>
<td>
<p>the white noise in the data</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of 2 elements: random walk and random walk with drift
</p>


<h3>References</h3>

<p>Shumway, R. H. and D. S. Stoffer (2011). Time series regression and exploratory data analysis. Time series analysis and its applications, Springer: 47-82.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(154)
data.rw &lt;- data.gen.rw(200)
plot.ts(data.rw$xd, ylim=c(-5,55), main='random walk', ylab='')
lines(data.rw$x, col=4); abline(h=0, col=4, lty=2); abline(a=0, b=.2, lty=2)
</code></pre>

<hr>
<h2 id='data.gen.spirals'>Spirals</h2><span id='topic+data.gen.spirals'></span>

<h3>Description</h3>

<p>Spirals
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data.gen.spirals(n, cycles = 1, s = 0, do.plot = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="data.gen.spirals_+3A_n">n</code></td>
<td>
<p>The data length to be generated.</p>
</td></tr>
<tr><td><code id="data.gen.spirals_+3A_cycles">cycles</code></td>
<td>
<p>The number of cycles of spirals.</p>
</td></tr>
<tr><td><code id="data.gen.spirals_+3A_s">s</code></td>
<td>
<p>The level of Gaussian noise, default 0.</p>
</td></tr>
<tr><td><code id="data.gen.spirals_+3A_do.plot">do.plot</code></td>
<td>
<p>Logical value. If TRUE (default value), a plot of the generated Spirals is shown.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of two variables, x and classes.
</p>


<h3>References</h3>

<p>Friedrich Leisch &amp; Evgenia Dimitriadou (2010). mlbench: Machine Learning Benchmark Problems. R package version 2.1-1.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Spirals=data.gen.spirals(n = 2000, cycles=2, s=0.01, do.plot=TRUE)
</code></pre>

<hr>
<h2 id='data.gen.SW'>Generate predictor and response data: Sinusoidal model</h2><span id='topic+data.gen.SW'></span>

<h3>Description</h3>

<p>Generate predictor and response data: Sinusoidal model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data.gen.SW(nobs = 500, freq = 50, A = 2, phi = pi, mu = 0, sd = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="data.gen.SW_+3A_nobs">nobs</code></td>
<td>
<p>The data length to be generated.</p>
</td></tr>
<tr><td><code id="data.gen.SW_+3A_freq">freq</code></td>
<td>
<p>The frequencies in the generated response. Default freq=50.</p>
</td></tr>
<tr><td><code id="data.gen.SW_+3A_a">A</code></td>
<td>
<p>The amplitude of the sinusoidal series</p>
</td></tr>
<tr><td><code id="data.gen.SW_+3A_phi">phi</code></td>
<td>
<p>The phase of the sinusoidal series</p>
</td></tr>
<tr><td><code id="data.gen.SW_+3A_mu">mu</code></td>
<td>
<p>The mean of Gaussian noise in the variable.</p>
</td></tr>
<tr><td><code id="data.gen.SW_+3A_sd">sd</code></td>
<td>
<p>The standard deviation of Gaussian noise in the variable.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of time and x.
</p>


<h3>References</h3>

<p>Shumway, R. H., &amp; Stoffer, D. S. (2011). Characteristics of Time Series. In D. S. Stoffer (Ed.), Time series analysis and its applications (pp. 8-14). New York : Springer.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### Sinusoidal model
delta &lt;- 1/12 # sampling rate, assuming monthly
period.max&lt;- 2^5

N = 6*period.max/delta
scales&lt;- 2^(0:5)[c(2,6)] #pick two scales
scales

### scale, period, and frequency
# freq=1/T; T=s/delta so freq = delta/s

tmp &lt;- NULL
for(s in scales){
  tmp &lt;- cbind(tmp, data.gen.SW(nobs=N, freq = delta/s, A = 1, phi = 0, mu=0, sd = 0)$x)
}
x &lt;- rowSums(data.frame(tmp))
plot.ts(cbind(tmp,x), type = 'l', main=NA)
</code></pre>

<hr>
<h2 id='data.gen.tar'>Generate a two-regime threshold autoregressive (TAR) process.</h2><span id='topic+data.gen.tar'></span>

<h3>Description</h3>

<p>Generate a two-regime threshold autoregressive (TAR) process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data.gen.tar(
  nobs,
  ndim = 9,
  phi1 = c(0.6, -0.1),
  phi2 = c(-1.1, 0),
  theta = 0,
  d = 2,
  p = 2,
  noise = 0.1
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="data.gen.tar_+3A_nobs">nobs</code></td>
<td>
<p>the data length to be generated</p>
</td></tr>
<tr><td><code id="data.gen.tar_+3A_ndim">ndim</code></td>
<td>
<p>The number of potential predictors (default is 9)</p>
</td></tr>
<tr><td><code id="data.gen.tar_+3A_phi1">phi1</code></td>
<td>
<p>the coefficient vector of the lower-regime model</p>
</td></tr>
<tr><td><code id="data.gen.tar_+3A_phi2">phi2</code></td>
<td>
<p>the coefficient vector of the upper-regime model</p>
</td></tr>
<tr><td><code id="data.gen.tar_+3A_theta">theta</code></td>
<td>
<p>threshold</p>
</td></tr>
<tr><td><code id="data.gen.tar_+3A_d">d</code></td>
<td>
<p>delay</p>
</td></tr>
<tr><td><code id="data.gen.tar_+3A_p">p</code></td>
<td>
<p>maximum autoregressive order</p>
</td></tr>
<tr><td><code id="data.gen.tar_+3A_noise">noise</code></td>
<td>
<p>the white noise in the data</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The two-regime Threshold Autoregressive  (TAR) model is given by the following formula:
</p>
<p style="text-align: center;"><code class="reqn">Y_t = \phi_{1,0}+\phi_{1,1} Y_{t-1} +\ldots+ \phi_{1,p} Y_{t-p}+\sigma_1 e_t, \mbox{  if } Y_{t-d}\le r</code>
</p>

<p style="text-align: center;"><code class="reqn">Y_t = \phi_{2,0}+\phi_{2,1} Y_{t-1} +\ldots+ \phi_{2,p} Y_{t-p}+\sigma_2 e_t, \mbox{  if } Y_{t-d} &gt; r.</code>
</p>

<p>where r is the threshold and d the delay.
</p>


<h3>Value</h3>

<p>A list of 2 elements: a vector of response (x), and a matrix of potential predictors (dp) with each column containing one potential predictor.
</p>


<h3>References</h3>

<p>Cryer, J. D. and K.-S. Chan (2008). Time Series Analysis With Applications in R Second Edition Springer Science+ Business Media, LLC.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># TAR2 model from paper with total 9 dimensions
data.tar&lt;-data.gen.tar(500)
plot.ts(cbind(data.tar$x,data.tar$dp))
</code></pre>

<hr>
<h2 id='data.gen.tar1'>Generate predictor and response data from TAR1 model.</h2><span id='topic+data.gen.tar1'></span>

<h3>Description</h3>

<p>Generate predictor and response data from TAR1 model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data.gen.tar1(nobs, ndim = 9, noise = 0.1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="data.gen.tar1_+3A_nobs">nobs</code></td>
<td>
<p>The data length to be generated.</p>
</td></tr>
<tr><td><code id="data.gen.tar1_+3A_ndim">ndim</code></td>
<td>
<p>The number of potential predictors (default is 9).</p>
</td></tr>
<tr><td><code id="data.gen.tar1_+3A_noise">noise</code></td>
<td>
<p>The white noise in the data</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of 2 elements: a vector of response (x), and a matrix of potential predictors (dp) with each column containing one potential predictor.
</p>


<h3>References</h3>

<p>Sharma, A. (2000). Seasonal to interannual rainfall probabilistic forecasts for improved water supply management: Part 1 - A strategy for system predictor identification. Journal of Hydrology, 239(1-4), 232-239.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># TAR1 model from paper with total 9 dimensions
data.tar1&lt;-data.gen.tar1(500)
plot.ts(cbind(data.tar1$x,data.tar1$dp))
</code></pre>

<hr>
<h2 id='data.gen.tar2'>Generate predictor and response data from TAR2 model.</h2><span id='topic+data.gen.tar2'></span>

<h3>Description</h3>

<p>Generate predictor and response data from TAR2 model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data.gen.tar2(nobs, ndim = 9, noise = 0.1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="data.gen.tar2_+3A_nobs">nobs</code></td>
<td>
<p>The data length to be generated.</p>
</td></tr>
<tr><td><code id="data.gen.tar2_+3A_ndim">ndim</code></td>
<td>
<p>The number of potential predictors (default is 9).</p>
</td></tr>
<tr><td><code id="data.gen.tar2_+3A_noise">noise</code></td>
<td>
<p>The white noise in the data</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of 2 elements: a vector of response (x), and a matrix of potential predictors (dp) with each column containing one potential predictor.
</p>


<h3>References</h3>

<p>Sharma, A. (2000). Seasonal to interannual rainfall probabilistic forecasts for improved water supply management: Part 1 - A strategy for system predictor identification. Journal of Hydrology, 239(1-4), 232-239.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># TAR2 model from paper with total 9 dimensions
data.tar2&lt;-data.gen.tar2(500)
plot.ts(cbind(data.tar2$x,data.tar2$dp))
</code></pre>

<hr>
<h2 id='data.gen.unif'>Generate correlated uniform variates</h2><span id='topic+data.gen.unif'></span>

<h3>Description</h3>

<p>Generate correlated uniform variates
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data.gen.unif(n, ndim = 9, r = 0.6, sigma, method = c("pearson", "spearman"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="data.gen.unif_+3A_n">n</code></td>
<td>
<p>The data length to be generated.</p>
</td></tr>
<tr><td><code id="data.gen.unif_+3A_ndim">ndim</code></td>
<td>
<p>The number of potential predictors (default is 9).</p>
</td></tr>
<tr><td><code id="data.gen.unif_+3A_r">r</code></td>
<td>
<p>The target correlation, default is 0.6.</p>
</td></tr>
<tr><td><code id="data.gen.unif_+3A_sigma">sigma</code></td>
<td>
<p>A symmetric matrix of Pearson correlation, should be same as ndim.</p>
</td></tr>
<tr><td><code id="data.gen.unif_+3A_method">method</code></td>
<td>
<p>The target correlation type, inluding Pearson and Spearman correlation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of correlated uniform variates
</p>


<h3>References</h3>

<p>Schumann, E. (2009). Generating correlated uniform variates. COMISEF. http://comisef. wikidot. com/tutorial: correlateduniformvariates.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
