<!DOCTYPE html><html><head><title>Help for package ClaimsProblems</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {ClaimsProblems}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#AA'><p>Average of awards rule</p></a></li>
<li><a href='#allrules'><p>Summary of the division rules</p></a></li>
<li><a href='#APRO'><p>Adjusted proportional rule</p></a></li>
<li><a href='#CD'><p>Concede-and-divide rule</p></a></li>
<li><a href='#CE'><p>Constrained egalitarian rule</p></a></li>
<li><a href='#CEA'><p>Constrained equal awards rule</p></a></li>
<li><a href='#CEL'><p>Constrained equal losses rule</p></a></li>
<li><a href='#coalitionalgame'><p>Coalitional game associated with a claims problem</p></a></li>
<li><a href='#cumawardscurve'><p>Cumulative awards curve</p></a></li>
<li><a href='#deviationindex'><p>Deviation index</p></a></li>
<li><a href='#DT'><p>Dominguez-Thomson rule</p></a></li>
<li><a href='#dynamicplot'><p>Dynamic plot</p></a></li>
<li><a href='#giniindex'><p>Gini index</p></a></li>
<li><a href='#indexgpath'><p>Index path</p></a></li>
<li><a href='#lorenzcurve'><p>The Lorenz curve</p></a></li>
<li><a href='#lorenzdominance'><p>Lorenz-dominance relation</p></a></li>
<li><a href='#MO'><p>Minimal overlap rule</p></a></li>
<li><a href='#pathawards'><p>The path of awards for two claimants</p></a></li>
<li><a href='#pathawards3'><p>The path of awards for three claimants</p></a></li>
<li><a href='#PIN'><p>Piniles' rule</p></a></li>
<li><a href='#plotrule'><p>Plot of an awards vector</p></a></li>
<li><a href='#PRO'><p>Proportional rule</p></a></li>
<li><a href='#problemdata'><p>Claims problem data</p></a></li>
<li><a href='#RA'><p>Random arrival rule</p></a></li>
<li><a href='#schedrule'><p>Schedules of awards of a rule</p></a></li>
<li><a href='#schedrules'><p>Schedules of awards of several rules</p></a></li>
<li><a href='#setofawards'><p>Set of awards vectors for a claims problem</p></a></li>
<li><a href='#Talmud'><p>Talmud rule</p></a></li>
<li><a href='#verticalruleplot'><p>Vertical rule plot</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Analysis of Conflicting Claims</td>
</tr>
<tr>
<td>Version:</td>
<td>0.2.1</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Iago Núñez Lugilde &lt;iago.nunez.lugilde@uvigo.es&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>The analysis of conflicting claims arises when an amount has to be divided among a set of agents with claims that exceed what is available. A rule is a way of selecting a  division among the claimants. This package computes the main rules introduced in the literature from the old times until nowadays. The inventory of rules covers the proportional and the adjusted proportional rules, the constrained equal awards and the constrained equal losses rules, the  constrained egalitarian, the Piniles’ and the minimal overlap rules, the random arrival and the Talmud rules. Besides, the Dominguez and Thomson and the average of awards rules are also included. All of them can be found in the book of W. Thomson (2019), 'How to divide when there isn't enough. From Aristotle, the Talmud, and Maimonides to the axiomatics of resource allocation', with the exception of the average of awards rule (Mirás Calvo et al. (2022), &lt;<a href="https://doi.org/10.1007%2Fs00355-022-01414-6">doi:10.1007/s00355-022-01414-6</a>&gt;). In addition,  graphical diagrams allow the user to represent, among others, the set of awards, the paths of awards, and the schedules of awards of a rule, and some indexes. A good understanding of the similarities and the differences of the rules is useful for a better decision making. Therefore this package could be helpful to students, researchers and managers alike.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Imports:</td>
<td>graphics, rgl, geometry, grDevices, stats, pracma</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.2</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-01-12 10:05:59 UTC; iagol</td>
</tr>
<tr>
<td>Author:</td>
<td>Iago Núñez Lugilde [aut, cre] (SIDOR. Universidade de Vigo.
    Departamento de Estatística e Investigación Operativa. Spain),
  Miguel Ángel Mirás Calvo [aut] (RGEAF. Universidade de Vigo.
    Departamento de Matemáticas. Spain),
  Carmen Quinteiro Sandomingo [aut] (Universidade de Vigo. Departamento
    de Matemáticas.  Spain),
  Estela Sánchez Rodríguez [aut] (CINBIO. Universidade de Vigo. Grupo
    SIDOR. Departamento de Estatística e Investigación Operativa.
    Universidade de Vigo. Spain)</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-01-12 11:30:08 UTC</td>
</tr>
</table>
<hr>
<h2 id='AA'>Average of awards rule</h2><span id='topic+AA'></span>

<h3>Description</h3>

<p>This function returns the awards vector assigned by the average of awards rule (AA) to a claims problem.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AA(E, d, name = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="AA_+3A_e">E</code></td>
<td>
<p>The endowment.</p>
</td></tr>
<tr><td><code id="AA_+3A_d">d</code></td>
<td>
<p>The vector of claims.</p>
</td></tr>
<tr><td><code id="AA_+3A_name">name</code></td>
<td>
<p>A logical value.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Let <code class="reqn">E\ge 0</code> be the endowment to be divided and <code class="reqn">d\in \mathcal{R}^n</code> the vector of claims
with <code class="reqn">d\ge 0</code> and such that <code class="reqn">\sum_{i=1}^{n} d_i\ge E,\;</code> the sum of claims exceeds the endowment.
</p>
<p>A vector <code class="reqn">x=(x_1,\dots,x_n)</code> is an awards vector for the claims problem <code class="reqn">(E,d)</code> if <code class="reqn">0\le x \le d</code>
and satisfies the balance requirement, that is, <code class="reqn">\sum_{i=1}^{n}x_i=E</code> the sum of its coordinates is equal to <code class="reqn">E</code>.
Let <code class="reqn">X(E,d)</code> be the set of awards vectors for <code class="reqn">(E,d)</code>.
</p>
<p>The average of awards rule assigns to each claims problem <code class="reqn">(E,d)</code>
the expectation of the uniform distribution defined over the set of awards vectors, that is,
the centroid of <code class="reqn">X(E,d)</code>.
</p>
<p>Let <code class="reqn">\mu</code> be the (n-1)-dimensional Lebesgue measure and <code class="reqn">V(E,d)=\mu (X(E,d))</code> the measure (volume) of the set of awards <code class="reqn">X(E,d)</code>.
The average of awards rule assigns to each problem <code class="reqn">(E,d)</code> the awards vector given by:
</p>
<p style="text-align: center;"><code class="reqn">AA(E,d)=\frac{1}{V(E,d)}\int_{X(E,d)} x d\mu</code>
</p>

<p>The average of awards rule corresponds to the core-center of the associated coalitional (pessimistic) game.
</p>


<h3>Value</h3>

<p>The awards vector selected by the AA rule. If name = TRUE, the name of the function (AA) as a character string.
</p>


<h3>References</h3>

<p>Gonzalez-Díaz, J. and Sánchez-Rodríguez, E. (2007). A natural selection from the core of a TU game: the core-center. International Journal of Game Theory, 36(1), 27-46.
</p>
<p>Mirás Calvo, M.Á., Quinteiro Sandomingo, C., and Sánchez-Rodríguez, E. (2022). The average-of-awards rule for claims problems. Soc Choice Welf. doi: <a href="https://doi.org/10.1007/s00355-022-01414-6">10.1007/s00355-022-01414-6</a>
</p>
<p>Mirás Calvo, M.Á., Núñez Lugilde, I., Quinteiro Sandomingo, C., and Sánchez-Rodríguez, E. (2020). An algorithm to compute the core-center rule of a claims problem with an application to
the allocation of CO2 emissions. Working paper.
</p>


<h3>See Also</h3>

<p><a href="#topic+allrules">allrules</a>, <a href="#topic+CD">CD</a>, <a href="#topic+setofawards">setofawards</a>, <a href="#topic+coalitionalgame">coalitionalgame</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>E=10
d=c(2,4,7,8)
AA(E,d)
#The average of awards rule is self-dual: AA(E,d)=d-AA(D-E,d)
D=sum(d)
d-AA(D-E,d)
</code></pre>

<hr>
<h2 id='allrules'>Summary of the division rules</h2><span id='topic+allrules'></span>

<h3>Description</h3>

<p>This function returns the awards vectors selected, for a given claims problem, by the rules:  AA, APRO, CE, CEA, CEL, DT, MO, PIN, PRO, RA, and Talmud.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>allrules(E, d, draw = TRUE, col = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="allrules_+3A_e">E</code></td>
<td>
<p>The endowment.</p>
</td></tr>
<tr><td><code id="allrules_+3A_d">d</code></td>
<td>
<p>The vector of claims.</p>
</td></tr>
<tr><td><code id="allrules_+3A_draw">draw</code></td>
<td>
<p>A logical value.</p>
</td></tr>
<tr><td><code id="allrules_+3A_col">col</code></td>
<td>
<p>The colours (useful only if draw=TRUE). If col=NULL then the sequence of default colours is:
c(&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;, &quot;yellow&quot;, &quot;pink&quot;, &quot;coral4&quot;, &quot;darkgray&quot;, &quot;burlywood3&quot;, &quot;black&quot;, &quot;darkorange&quot;, &quot;darkviolet&quot;).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Let <code class="reqn">E\ge 0</code> be the endowment to be divided and <code class="reqn">d\in \mathcal{R}^n</code> the vector of claims with <code class="reqn">d\ge 0</code> and such that <code class="reqn">\sum_{i=1}^{n} d_i\ge E,\ </code>
the sum of claims exceeds the endowment.
</p>
<p>A vector <code class="reqn">x=(x_1,\dots,x_n)</code> is an awards vector for the claims problem <code class="reqn">(E,d)</code> if:
no claimant is asked to pay (<code class="reqn">0\le x</code>);
no claimant  receives more than his claim (<code class="reqn">x\le d</code>);
and the balance requirement is satisfied, that is, the sum of the awards is equal to the endowment (<code class="reqn">\sum_{i=1}^{n} x_i= E</code>).
</p>
<p>A rule is a function that assigns to each claims problem <code class="reqn">(E,d)</code> an awards vector for <code class="reqn">(E,d)</code>,
that is, a division between the claimants of the amount available.
</p>
<p>The formal definitions of the main rules are given in the corresponding function help.
</p>


<h3>Value</h3>

<p>A data-frame with the awards vectors selected by the main division rules. If draw = TRUE, it
displays a mosaic plot representing the data-frame.
</p>


<h3>References</h3>

<p>Mirás Calvo, M.Á., Quinteiro Sandomingo, C., and Sánchez-Rodríguez, E. (2022). The average-of-awards rule for claims problems. Soc Choice Welf. doi: <a href="https://doi.org/10.1007/s00355-022-01414-6">10.1007/s00355-022-01414-6</a>
</p>
<p>Thomson, W. (2019). How to divide when there isn't enough. From Aristotle, the Talmud, and Maimonides to the axiomatics of resource allocation. Cambridge University Press.
</p>


<h3>See Also</h3>

<p><a href="#topic+AA">AA</a>, <a href="#topic+APRO">APRO</a>, <a href="#topic+CD">CD</a>, <a href="#topic+CE">CE</a>, <a href="#topic+CEA">CEA</a>, <a href="#topic+CEL">CEL</a>
, <a href="#topic+DT">DT</a>, <a href="#topic+MO">MO</a>, <a href="#topic+PIN">PIN</a>, <a href="#topic+PRO">PRO</a>, <a href="#topic+RA">RA</a>, <a href="#topic+Talmud">Talmud</a>,  <a href="#topic+verticalruleplot">verticalruleplot</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>E=10
d=c(2,4,7,8)
allrules(E,d)
</code></pre>

<hr>
<h2 id='APRO'>Adjusted proportional rule</h2><span id='topic+APRO'></span>

<h3>Description</h3>

<p>This function returns the awards vector assigned by the adjusted proportional rule (APRO) to a claims problem.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>APRO(E, d, name = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="APRO_+3A_e">E</code></td>
<td>
<p>The endowment.</p>
</td></tr>
<tr><td><code id="APRO_+3A_d">d</code></td>
<td>
<p>The vector of claims.</p>
</td></tr>
<tr><td><code id="APRO_+3A_name">name</code></td>
<td>
<p>A logical value.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Let <code class="reqn">E\ge 0</code> be the endowment to be divided and <code class="reqn">d\in \mathcal{R}^n</code> the vector of claims
with <code class="reqn">d\ge 0</code> and such that <code class="reqn">\sum_{i=1}^{n} d_i\ge E,</code> the sum of claims exceeds the endowment.
</p>
<p>For each subset <code class="reqn">S</code> of the set of claimants <code class="reqn">N</code>, let <code class="reqn">d(S)=\sum_{j\in S}d_j</code> be the sum of claims of the members of <code class="reqn">S</code>
and let <code class="reqn">N\backslash S</code> be the complementary coalition of <code class="reqn">S</code>.
</p>
<p>The minimal right of claimant <code class="reqn">i</code> in <code class="reqn">(E,d)</code> is whatever is left after every other claimant has received his claim, or 0 if that is not possible:
</p>
<p style="text-align: center;"><code class="reqn">m_i(E,d)=\max\{0,E-d(N\backslash\{i\})\},\ i=1,\dots,n.</code>
</p>

<p>Let <code class="reqn">m(E,d)=(m_1(E,d),\dots,m_n(E,d))</code> be the vector of minimal rights.
</p>
<p>The truncated claim of claimant <code class="reqn">i</code> in <code class="reqn">(E,d)</code> is the minimum of the claim and the endowment:
</p>
<p style="text-align: center;"><code class="reqn">t_i(E,d)=\min\{d_i,E\},\ i=1,\dots,n.</code>
</p>

<p>Let <code class="reqn">t(E,d)=(t_1(E,d),\dots,t_n(E,d))</code> be the vector of truncated claims.
</p>
<p>The adjusted proportional rule first gives to each claimant the minimal right, and then divides the remainder
of the endowment <code class="reqn">E'=E-\sum_{i=1}^n m_i(E,d)</code>
proportionally with respect to the new claims. The vector of the new claims <code class="reqn">d'</code> is determined by the minimum of the remainder and the lowered claims,
<code class="reqn">d_i'=\min\{E-\sum_{j=1}^n m_j(E,d),d_i-m_i\},\  i=1,\dots,n</code>. Therefore:
</p>
<p style="text-align: center;"><code class="reqn">APRO(E,d)=m(E,d)+PRO(E',d').</code>
</p>

<p>The adjusted proportional rule corresponds to the <code class="reqn">\tau</code>-value of the associated (pessimistic) coalitional game.
</p>


<h3>Value</h3>

<p>The awards vector selected by the APRO rule. If name = TRUE, the name of the function (APRO) as a character string.
</p>


<h3>References</h3>

<p>Curiel, I. J., Maschler, M., and Tijs, S. H. (1987). Bankruptcy games. Zeitschrift für operations research, 31(5), A143-A159.
</p>
<p>Mirás Calvo, M.Á., Núñez Lugilde, I., Quinteiro Sandomingo, C., and Sánchez-Rodríguez, E. (2021). The adjusted proportional and the minimal overlap rules restricted to the lower-half, higher-half, and middle domains. Working paper 2021-02, ECOBAS.
</p>
<p>Thomson, W. (2019). How to divide when there isn't enough. From Aristotle, the Talmud, and Maimonides to the axiomatics of resource allocation. Cambridge University Press.
</p>


<h3>See Also</h3>

<p><a href="#topic+allrules">allrules</a>, <a href="#topic+CD">CD</a>, <a href="#topic+PRO">PRO</a>, <a href="#topic+coalitionalgame">coalitionalgame</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>E=10
d=c(2,4,7,8)
APRO(E,d)
#The adjusted proportional rule is self-dual: APRO(E,d)=d-APRO(D-E,d)
D=sum(d)
d-APRO(D-E,d)
</code></pre>

<hr>
<h2 id='CD'>Concede-and-divide rule</h2><span id='topic+CD'></span>

<h3>Description</h3>

<p>This function returns the awards vector assigned by the concede-and-divide (CD) rule to a two-claimant problem.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CD(E, d, name = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CD_+3A_e">E</code></td>
<td>
<p>The endowment.</p>
</td></tr>
<tr><td><code id="CD_+3A_d">d</code></td>
<td>
<p>The vector of two claims.</p>
</td></tr>
<tr><td><code id="CD_+3A_name">name</code></td>
<td>
<p>A logical value.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Let <code class="reqn">E\ge 0</code> be the endowment to be divided and <code class="reqn">d=(d_1,d_2)\in \mathcal{R}^2</code> the vector of claims
with <code class="reqn">d\ge 0</code> and such that the sum of the two claims exceeds the endowment <code class="reqn">d_1+d_2 \ge E</code>.
</p>
<p>The concede-and-divide rule first assigns to each of the two claimants the difference between the endowment and the other agent’s claim (or 0 if this
difference is negative), and divides the remainder equally.
</p>
<p style="text-align: center;"><code class="reqn">CD_1(E,d)=\max\{E-d_2,0\}+\frac{E-\max\{E-d_1,0\}-\max\{E-d_2,0\}}{2}</code>
</p>

<p style="text-align: center;"><code class="reqn">CD_2(E,d)=\max\{E-d_1,0\}+\frac{E-\max\{E-d_1,0\}-\max\{E-d_2,0\}}{2}</code>
</p>

<p>Several rules are extensions of the concede-and-divide rule to general populations: AA, APRO, MO, RA, and Talmud.
</p>


<h3>Value</h3>

<p>The awards vector selected by the CD rule. If name = TRUE, the name of the function (CD) as a character string.
</p>


<h3>References</h3>

<p>Aumann, R. and Maschler, M., (1985). Game theoretic analysis of a bankruptcy problem from the Talmud. J. Econ. Theory 36, 195–213.
</p>
<p>Mirás Calvo, M. Á., Núñez Lugilde, I., Quinteiro Sandomingo, C., and Sánchez Rodríguez, E. (2021).  Analyzing rules that extend the concede-and-divide principle. Preprint.
</p>
<p>Thomson, W. (2019). How to divide when there isn't enough. From Aristotle, the Talmud, and Maimonides to the axiomatics of resource allocation. Cambridge University Press.
</p>


<h3>See Also</h3>

<p><a href="#topic+allrules">allrules</a>, <a href="#topic+pathawards">pathawards</a>, <a href="#topic+AA">AA</a>, <a href="#topic+APRO">APRO</a>, <a href="#topic+MO">MO</a>, <a href="#topic+RA">RA</a>, <a href="#topic+Talmud">Talmud</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>E=10
d=c(7,8)
CD(E,d)
# Talmud, RA, MO, APRO, and AA coincide with CD for two-claimant problems
Talmud(E,d)
RA(E,d)
MO(E,d)
APRO(E,d)
AA(E,d)
</code></pre>

<hr>
<h2 id='CE'>Constrained egalitarian rule</h2><span id='topic+CE'></span>

<h3>Description</h3>

<p>This function returns  the awards vector assigned by the constrained egalitarian rule (CE) rule to a claims problem.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CE(E, d, name = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CE_+3A_e">E</code></td>
<td>
<p>The endowment.</p>
</td></tr>
<tr><td><code id="CE_+3A_d">d</code></td>
<td>
<p>The vector of claims.</p>
</td></tr>
<tr><td><code id="CE_+3A_name">name</code></td>
<td>
<p>A logical value.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Let <code class="reqn">E\ge 0</code> be the endowment to be divided and <code class="reqn">d\in \mathcal{R}^n</code> the vector of claims
with <code class="reqn">d\ge 0</code> and such that <code class="reqn">\sum_{i=1}^{n} d_i\ge E,\;</code> the sum of claims exceeds the endowment.
</p>
<p>Assume that the claims are ordered from small to large, <code class="reqn">0 \le d_1 \le...\le d_n</code>.
The constrained egalitarian rule coincides with the constrained equal awards rule (CEA) applied to
the problem <code class="reqn">(E, d/2)</code> if the endowment is less or equal than the half-sum of the claims <code class="reqn">D/2</code>.
Otherwise, any additional unit is assigned to claimant <code class="reqn">1</code> until she/he receives the minimum
of the claim and half of <code class="reqn">d_2</code>. If this minimun is <code class="reqn">d_1</code>, she/he stops there. If it is not, the next increment is
divided equally between claimants <code class="reqn">1</code> and <code class="reqn">2</code> until claimant <code class="reqn">1</code> receives <code class="reqn">d_1</code> (in this case she drops out) or they reach <code class="reqn">d_3/2</code>.
If claimant <code class="reqn">1</code> leaves, claimant <code class="reqn">2</code> receives any aditional increment until she/he reaches <code class="reqn">d_2</code> or <code class="reqn">d_3/2</code>. In the case that claimant <code class="reqn">1</code> and <code class="reqn">2</code> reach <code class="reqn">d_3/2</code>, any additional unit is divided between claimants <code class="reqn">1</code>, <code class="reqn">2</code>, and <code class="reqn">3</code> until the first one receives <code class="reqn">d_1</code> or they reach <code class="reqn">d_4/2</code>, and so on.
</p>
<p>Therefore:
</p>
<p>If <code class="reqn">E \le D/2</code> then  <code class="reqn">CE(E,d) = CEA(E,d/2)=(\min\{\frac{d_i}{2},\lambda\})_{i\in N}</code> where <code class="reqn">\lambda \ge 0</code> is chosen so as to achieve balance.
</p>
<p>If <code class="reqn">E \ge D/2</code> then the CE rule assigns to claimant <code class="reqn">i</code> the maximum of two quantities: the half-claim and the minimum of the claim and a value <code class="reqn">\lambda \ge 0</code>
chosen so as to achieve balance.
</p>
<p style="text-align: center;"><code class="reqn">CE_i(E,d)=\max\{\frac{d_i}{2},\min\{d_i,\lambda\}\},\ i=1,\dots,n, \ where \ \sum_{i=1}^{n}	CE_i(E,d)=E.</code>
</p>



<h3>Value</h3>

<p>The awards vector selected by the CE rule. If name = TRUE, the name of the function (CE) as a character string.
</p>


<h3>References</h3>

<p>Chun, Y., Schummer, J., Thomson, W. (2001). Constrained egalitarianism: a new solution for claims problems. Seoul J. Economics 14, 269–297.
</p>
<p>Thomson, W. (2019). How to divide when there isn't enough. From Aristotle, the Talmud, and Maimonides to the axiomatics of resource allocation. Cambridge University Press.
</p>


<h3>See Also</h3>

<p><a href="#topic+allrules">allrules</a>, <a href="#topic+CEA">CEA</a>, <a href="#topic+Talmud">Talmud</a>, <a href="#topic+PIN">PIN</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>E=10
d=c(2,4,7,8)
CE(E,d)
</code></pre>

<hr>
<h2 id='CEA'>Constrained equal awards rule</h2><span id='topic+CEA'></span>

<h3>Description</h3>

<p>This function returns the awards vector assigned by the constrained equal awards rule (CEA) to a claims problem.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CEA(E, d, name = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CEA_+3A_e">E</code></td>
<td>
<p>The endowment.</p>
</td></tr>
<tr><td><code id="CEA_+3A_d">d</code></td>
<td>
<p>The vector of claims.</p>
</td></tr>
<tr><td><code id="CEA_+3A_name">name</code></td>
<td>
<p>A logical value.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Let <code class="reqn">E\ge 0</code> be the endowment to be divided and let <code class="reqn">d\in \mathcal{R}^n</code> be the vector of claims
with <code class="reqn">d\ge 0</code> and such that <code class="reqn">\sum_{i=1}^{n} d_i\ge E,</code> the sum of claims exceeds the endowment.
</p>
<p>The constrained equal awards rule (CEA) equalizes awards under the constraint that no individual's
award exceeds his/her claim. Then, claimant <code class="reqn">i</code> receives the minimum of the claim and a value <code class="reqn">\lambda \ge 0</code> chosen so as to achieve balance.
</p>
<p style="text-align: center;"><code class="reqn"> CEA_i(E,d)=\min\{d_i,\lambda\},\ i=1,\dots,n, \ such \  that \ \sum_{i=1}^{n} CEA_i(E,d)=E.</code>
</p>

<p>The constrained equal awards rule corresponds to the Dutta-Ray solution to the associated (pessimistic) coalitional game.
The CEA and CEL rules are dual.
</p>


<h3>Value</h3>

<p>The awards vector selected by the CEA rule. If name = TRUE, the name of the function (CEA) as a character string.
</p>


<h3>References</h3>

<p>Maimonides, Moses, 1135-1204. Book of Judgements, Moznaim Publishing Corporation, New York, Jerusalem (Translated by Rabbi Elihahu Touger, 2000).
</p>
<p>Thomson, W. (2019). How to divide when there isn't enough. From Aristotle, the Talmud, and Maimonides to the axiomatics of resource allocation. Cambridge University Press.
</p>


<h3>See Also</h3>

<p><a href="#topic+allrules">allrules</a>, <a href="#topic+CE">CE</a>, <a href="#topic+CEL">CEL</a>, <a href="#topic+PIN">PIN</a>, <a href="#topic+Talmud">Talmud</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>E=10
d=c(2,4,7,8)
CEA(E,d)
# CEA and CEL are dual: CEA(E,d)=d-CEL(D-E,d)
D=sum(d)
d-CEL(D-E,d)
</code></pre>

<hr>
<h2 id='CEL'>Constrained equal losses rule</h2><span id='topic+CEL'></span>

<h3>Description</h3>

<p>This function returns the awards vector assigned by the constrained equal losses rule (CEL) to a claims problem.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CEL(E, d, name = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CEL_+3A_e">E</code></td>
<td>
<p>The endowment.</p>
</td></tr>
<tr><td><code id="CEL_+3A_d">d</code></td>
<td>
<p>The vector of claims.</p>
</td></tr>
<tr><td><code id="CEL_+3A_name">name</code></td>
<td>
<p>A logical value.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Let <code class="reqn">E\ge 0</code> be the endowment to be divided and let <code class="reqn">d\in \mathcal{R}^n</code> be the vector of claims
with <code class="reqn">d\ge 0</code> and such that <code class="reqn">\sum_{i=1}^{n} d_i\ge E,</code> the sum of claims exceeds the endowment.
</p>
<p>The constrained equal losses rule (CEL) equalizes losses under the constraint that no award
is negative. Then, claimant <code class="reqn">i</code> receives the maximum of zero and the claim minus a number <code class="reqn">\lambda \ge 0</code> chosen so as to achieve balance.
</p>
<p style="text-align: center;"><code class="reqn">CEL_i(E,d)=\max\{0,d_i-\lambda\},\ i=1,\dots,n, \ such \  that  \ \sum_{i=1}^n CEL_i(E,d)=E.</code>
</p>

<p>CEA and CEL are dual rules.
</p>


<h3>Value</h3>

<p>The awards vector selected by the CEL rule. If name = TRUE, the name of the function (CEL) as a character string.
</p>


<h3>References</h3>

<p>Maimonides, Moses, 1135-1204. Book of Judgements, Moznaim Publishing Corporation, New York, Jerusalem (Translated by Rabbi Elihahu Touger, 2000).
</p>
<p>Thomson, W. (2019). How to divide when there isn't enough. From Aristotle, the Talmud, and Maimonides to the axiomatics of resource allocation. Cambridge University Press.
</p>


<h3>See Also</h3>

<p><a href="#topic+allrules">allrules</a>, <a href="#topic+CEA">CEA</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>E=10
d=c(2,4,7,8)
CEL(E,d)
# CEL and CEA are dual: CEL(E,d)=d-CEA(D-E,d)
D=sum(d)
d-CEA(D-E,d)
</code></pre>

<hr>
<h2 id='coalitionalgame'>Coalitional game associated with a claims problem</h2><span id='topic+coalitionalgame'></span>

<h3>Description</h3>

<p>This function returns the pessimistic and optimistic coalitional games associated with a claims problem.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coalitionalgame(E, d, opt = FALSE, lex = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coalitionalgame_+3A_e">E</code></td>
<td>
<p>The endowment.</p>
</td></tr>
<tr><td><code id="coalitionalgame_+3A_d">d</code></td>
<td>
<p>The vector of claims.</p>
</td></tr>
<tr><td><code id="coalitionalgame_+3A_opt">opt</code></td>
<td>
<p>Logical parameter. If opt = TRUE, both the pessimist and optimistic associated coalitional games are given.
By default, opt = FALSE, and only the associated pessimistic coalitional game is computed.</p>
</td></tr>
<tr><td><code id="coalitionalgame_+3A_lex">lex</code></td>
<td>
<p>Logical parameter. If lex = TRUE, coalitions of claimants are ordered lexicographically. By default, lex = FALSE, and coalitions are ordered using their binary representations.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Let <code class="reqn">E\ge 0</code> be the endowment to be divided and <code class="reqn">d\in \mathcal{R}^n</code> the vector of claims
with <code class="reqn">d\ge 0</code> and such that <code class="reqn">\sum_{i=1}^{n} d_i\ge E,\;</code> the sum of claims exceeds the endowment.
</p>
<p>For each subset <code class="reqn">S</code> of the set of claimants <code class="reqn">N</code>, let <code class="reqn">d(S)=\sum_{j\in S}d_j</code> be the sum of claims of the members of <code class="reqn">S</code>
and let <code class="reqn">N\backslash S</code> be the complementary coalition of <code class="reqn">S</code>.
</p>
<p>Given a claims problem <code class="reqn">(E,d)</code>, its associated pessimistic coalitional game is the game  <code class="reqn">v_{pes}:2^N\rightarrow \mathcal{R}</code> assigning to each coalition <code class="reqn">S\in 2^N</code>
the real number:
</p>
<p style="text-align: center;"><code class="reqn">v_{pes}(S)=\max\{0,E-d(N\backslash S)\}.</code>
</p>

<p>Given a claims problem <code class="reqn">(E,d)</code>, its associated optimistic coalitional game  is the game <code class="reqn">v_{opt}:2^N\rightarrow \mathcal{R}</code>
assigning to each coalition <code class="reqn">S\in 2^N</code>
the real number:
</p>
<p style="text-align: center;"><code class="reqn">v_{opt}(S)=\min\{E,d(S)\}.</code>
</p>

<p>The optimistic and the pessimistic coalitional games are dual games, that is, for all <code class="reqn">S\in 2^N</code>:
</p>
<p style="text-align: center;"><code class="reqn">v_{opt}(S)=E-v_{pes}(N\backslash S).</code>
</p>

<p>An efficient way to represent a nonempty coalition <code class="reqn">S\in 2^N</code> is by identifying it with the binary sequence
<code class="reqn">a_{n}a_{n-1}\dots a_{1}</code> where <code class="reqn">a_i=1</code> if <code class="reqn">i\in S</code>
and <code class="reqn">a_i=0</code> otherwise.
Therefore, each coalition <code class="reqn">S</code> is represented by the number associated with its binary representation: <code class="reqn">\sum_{i\in T}2^{i-1}</code>.
Then coalitions can be ordered by their associated numbers.
</p>
<p>Alternatively, coalitions can be ordered lexicographically.
</p>
<p>Given a claims problem <code class="reqn">(E,d)</code>, its associated coalitional game <code class="reqn">v</code> can be represented by the vector whose coordinates are the values assigned by <code class="reqn">v</code> to all the nonempty coalitions.
For instance. if <code class="reqn">n=3</code>, the associated coalitional game can be represented by the vector of the values of all the 7 nonempty coalitions, ordered using the binary representation:
</p>
<p style="text-align: center;"><code class="reqn">v = [v(\{1\}),v(\{2\}),v(\{1,2\}),v(\{3\}),v(\{1,3\}),v(\{2,3\}),v(\{1,2,3\})]</code>
</p>

<p>Alternatively, the coordinates can be ordered lexicographically:
</p>
<p style="text-align: center;"><code class="reqn">v = [v(\{1\}),v(\{2\}),v(\{3\}),v(\{1,2\}),v(\{1,3\}),v(\{2,3\}),v(\{1,2,3\})]</code>
</p>

<p>When <code class="reqn">n=4</code>, the associated coalitional game can be represented by the vector of the values of all the 15 nonempty coalitions, ordered using the binary representation:
</p>
<p><code class="reqn">v = [v(\{1\}),v(\{2\}),v(\{1,2\}),v(\{3\}),v(\{1,3\}),v(\{2,3\}),v(\{1,2,3\}),v(\{4\}),</code>
</p>
<p><code class="reqn">v(\{1,4\}),v(\{2,4\}),v(\{1,2,4\}),v(\{3,4\}),v(\{1,3,4\}),v(\{2,3,4\}),v(\{1,2,3,4\})]</code>
</p>
<p>Alternatively, the coordinates can be ordered lexicographically:
</p>
<p><code class="reqn">v=[v(\{1\}),v(\{2\}),v(\{3\}),v(\{4\}),v(\{1,2\}),v(\{1,3\}),v(\{1,4\}),v(\{2,3\}),\dots</code>
</p>
<p><code class="reqn">\dots v(\{2,4\}),v(\{3,4\}),v(\{1,2,3\}),v(\{1,2,4\}),v(\{1,3,4\}),v(\{2,3,4\}),v(\{1,2,3,4\})]</code>
</p>


<h3>Value</h3>

<p>The pessimistic (and optimistic) associated coalitional game(s).
</p>


<h3>References</h3>

<p>O’Neill B (1982) A problem of rights arbitration from the Talmud. Math Soc Sci 2:345–371.
</p>


<h3>See Also</h3>

<p><a href="#topic+setofawards">setofawards</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>E=10
d=c(2,4,7,8)
v=coalitionalgame(E,d,opt=TRUE,lex=TRUE)
#The pessimistic and optimistic coalitional games are dual games
v_pes=v$v_pessimistic_lex
v_opt=v$v_optimistic_lex
v_opt[1:14]==10-v_pes[14:1]
</code></pre>

<hr>
<h2 id='cumawardscurve'>Cumulative awards curve</h2><span id='topic+cumawardscurve'></span>

<h3>Description</h3>

<p>The graphical representation of the cumulative curves of a rule (or several rules) with respect to a given rule, for a claims problem.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cumawardscurve(E, d, Rule = PRO, Rules, col = NULL, legend = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cumawardscurve_+3A_e">E</code></td>
<td>
<p>The endowment.</p>
</td></tr>
<tr><td><code id="cumawardscurve_+3A_d">d</code></td>
<td>
<p>The vector of claims.</p>
</td></tr>
<tr><td><code id="cumawardscurve_+3A_rule">Rule</code></td>
<td>
<p>Principal Rule: AA, APRO, CE, CEA, CEL, DT, MO, PIN, PRO, RA, Talmud. By default, Rule = PRO.</p>
</td></tr>
<tr><td><code id="cumawardscurve_+3A_rules">Rules</code></td>
<td>
<p>The rules: AA, APRO, CE, CEA, CEL, DT, MO, PIN, PRO, RA, Talmud.</p>
</td></tr>
<tr><td><code id="cumawardscurve_+3A_col">col</code></td>
<td>
<p>The colours. If col = NULL then the sequence of default colours is:
c(&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;, &quot;yellow&quot;, &quot;pink&quot;, &quot;coral4&quot;, &quot;darkgray&quot;, &quot;burlywood3&quot;, &quot;black&quot;, &quot;darkorange&quot;, &quot;darkviolet&quot;).</p>
</td></tr>
<tr><td><code id="cumawardscurve_+3A_legend">legend</code></td>
<td>
<p>A logical value. The colour legend is shown if legend = TRUE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Let <code class="reqn">E&gt; 0</code> be the endowment to be divided and <code class="reqn">d\in \mathcal{R}^n</code> the vector of claims
with <code class="reqn">d\ge 0</code> and such that the sum of claims <code class="reqn">D=\sum_{i=1}^{n} d_i\ge E</code> exceeds the endowment.
</p>
<p>Rearrange the claims from small to large, <code class="reqn">0 \le d_1 \le...\le d_n</code>. The cumulative curve allows us
to compare the division recommended by a specific rule <code class="reqn">R</code> with the division the division recommended by another specific rule <code class="reqn">S</code>.
</p>
<p>The cumulative awards curve of a rule <code class="reqn">S</code> with respect of a rule <code class="reqn">R</code> for the claims problem <code class="reqn">(E,d)</code> is the polygonal path connecting the <code class="reqn">n+1</code> points
</p>
<p style="text-align: center;"><code class="reqn">(0,0), (\frac{R_1}{E},\frac{S_1}{E}),\dots,(\frac{\sum_{i=1}^{n-1}R_i}{E},\frac{\sum_{i=1}^{n-1}S_i}{E}),(1,1).</code>
</p>

<p>The cumulative awards curve fully captures the Lorenz ranking of rules:
if a rule <code class="reqn">R</code> Lorenz-dominates a rule <code class="reqn">S</code> then, for each claims problem, the cumulative curve of <code class="reqn">R</code>
lies above the cumulative curve of <code class="reqn">S</code>.
If <code class="reqn">R = PRO</code>, the cumulative curve coincides with the cumulative claims-awards curve.
</p>
<p><code class="reqn">cumulativecurve</code> function of version 0.1.0 returned the cumulative claims-awards curve with respect to the proportional rule.
</p>


<h3>Value</h3>

<p>The graphical representation of the cumulative curves of a rule (or several rules) for a claims problem.
</p>


<h3>References</h3>

<p>Lorenz, M. O. (1905). Methods of measuring the concentration of wealth. Publications of the American statistical association, 9(70), 209-219.
</p>
<p>Mirás Calvo, M.Á., Núñez Lugilde, I., Quinteiro Sandomingo, C., and Sánchez Rodríguez, E. (2022). Deviation from proportionality and Lorenz-domination for claims problems. Rev Econ Design. doi: <a href="https://doi.org/10.1007/s10058-022-00300-y">10.1007/s10058-022-00300-y</a>
</p>


<h3>See Also</h3>

<p><a href="#topic+deviationindex">deviationindex</a>, <a href="#topic+indexgpath">indexgpath</a>, <a href="#topic+lorenzcurve">lorenzcurve</a>, <a href="#topic+giniindex">giniindex</a>, <a href="#topic+lorenzdominance">lorenzdominance</a>,  <a href="#topic+allrules">allrules</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>E=10
d=c(2,4,7,8)
Rule=PRO
Rules=c(AA,RA,Talmud,CEA,CEL)
cumawardscurve(E,d,Rule,Rules)
</code></pre>

<hr>
<h2 id='deviationindex'>Deviation index</h2><span id='topic+deviationindex'></span>

<h3>Description</h3>

<p>This function returns the deviation index and the signed deviation index for a rule with respect to another rule.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>deviationindex(E, d, R, S)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="deviationindex_+3A_e">E</code></td>
<td>
<p>The endowment.</p>
</td></tr>
<tr><td><code id="deviationindex_+3A_d">d</code></td>
<td>
<p>The vector of claims.</p>
</td></tr>
<tr><td><code id="deviationindex_+3A_r">R</code></td>
<td>
<p>A rule : AA, APRO, CE, CEA, CEL, DT, MO, PIN, PRO, RA, Talmud.</p>
</td></tr>
<tr><td><code id="deviationindex_+3A_s">S</code></td>
<td>
<p>A rule: AA, APRO, CE, CEA, CEL, DT, MO, PIN, PRO, RA, Talmud.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Let <code class="reqn">E&gt; 0</code> be the endowment to be divided and <code class="reqn">d\in \mathcal{R}^n</code> the vector of claims
with <code class="reqn">d\ge 0</code> and such that <code class="reqn">D=\sum_{i=1}^{n} d_i\ge E</code>, the sum of claims <code class="reqn">D</code> exceeds the endowment.
</p>
<p>Rearrange the claims from small to large, <code class="reqn">0 \le d_1 \le...\le d_n</code>.
The signed deviation index of the rule <code class="reqn">S</code> with respect to the rule <code class="reqn">R</code> for the problem <code class="reqn">(E,d)</code>, denoted by <code class="reqn">I(R(E,d),S(E,d))</code>, is
the ratio of the area that lies between the identity line and the cumulative curve over the total area under the identity line.
</p>
<p>Let <code class="reqn">R_0=0</code> and <code class="reqn">S_0=0</code>. For each <code class="reqn">k=1,\dots,n</code> define
<code class="reqn">X_k=\frac{1}{E} \sum_{j=0}^{k} R_j</code> and
<code class="reqn">Y_k=\frac{1}{E} \sum_{j=0}^{k} S_j</code>. Then
</p>
<p style="text-align: center;"><code class="reqn">I(R(E,d),S(E,d))=1-\sum_{k=1}^{n}(X_{k}-X_{k-1})(Y_{k}+Y_{k-1}).</code>
</p>

<p>In general  <code class="reqn">-1 \le I(R(E,d),S(E,d)) \le 1</code>.
</p>
<p>The deviation index of the rule <code class="reqn">S</code> with respect to the rule <code class="reqn">R</code> for the problem <code class="reqn">(E,d)</code>, denoted by <code class="reqn">I^{+}(R(E,d),S(E,d))</code>, is
the ratio of the area between the line of the cumulative sum of the distribution proposed by the rule <code class="reqn">R</code> and the cumulative curve over the area under the line <code class="reqn">x=y</code>.
</p>
<p>In general  <code class="reqn">0 \le I^{+}(R(E,d),S(E,d)) \le 1</code>.
</p>
<p>The proportionality deviation index is the deviation index when <code class="reqn">R = PRO</code>. The proportionality deviation index of the proportional rule is zero for all claims problems.
The signed proportionality deviation index is the signed deviation index with <code class="reqn">R = PRO</code>.
</p>
<p><code class="reqn">proportionalityindex</code> function of version 0.1.0 returned the the signed proportionality index.
</p>


<h3>Value</h3>

<p>The deviation index and the signed deviation index of a rule for a claims problem.
</p>


<h3>References</h3>

<p>Ceriani, L. and Verme, P. (2012). The origins of the Gini index: extracts from Variabilitá e Mutabilitá (1912) by Corrado Gini. The Journal of Economic Inequality, 10(3), 421-443.
</p>
<p>Mirás Calvo, M.Á., Núñez Lugilde, I., Quinteiro Sandomingo, C., and Sánchez Rodríguez, E. (2022). Deviation from proportionality and Lorenz-domination for claims problems. Rev Econ Design. doi: <a href="https://doi.org/10.1007/s10058-022-00300-y">10.1007/s10058-022-00300-y</a>
</p>


<h3>See Also</h3>

<p><a href="#topic+indexgpath">indexgpath</a>, <a href="#topic+cumawardscurve">cumawardscurve</a>, <a href="#topic+lorenzcurve">lorenzcurve</a>, <a href="#topic+giniindex">giniindex</a>, <a href="#topic+lorenzdominance">lorenzdominance</a>, <a href="#topic+allrules">allrules</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>E=10
d=c(2,4,7,8)
R=CEA
S=AA
deviationindex(E,d,R,S)
#The deviation index of rule R with respect of the rule R is 0.
deviationindex(E,d,PRO,PRO)
</code></pre>

<hr>
<h2 id='DT'>Dominguez-Thomson rule</h2><span id='topic+DT'></span>

<h3>Description</h3>

<p>This function returns the awards vector assigned by the Dominguez-Thomson rule (DT) to a claims problem.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DT(E, d, name = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DT_+3A_e">E</code></td>
<td>
<p>The endowment.</p>
</td></tr>
<tr><td><code id="DT_+3A_d">d</code></td>
<td>
<p>The vector of claims.</p>
</td></tr>
<tr><td><code id="DT_+3A_name">name</code></td>
<td>
<p>A logical value.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Let <code class="reqn">E\ge 0</code> be the endowment to be divided and <code class="reqn">d\in \mathcal{R}^n</code> the vector of claims
with <code class="reqn">d\ge 0</code> and such that <code class="reqn">\sum_{i=1}^{n} d_i\ge E,\;</code> the sum of claims exceeds the endowment.
</p>
<p>The truncated claim of claimant <code class="reqn">i</code> in <code class="reqn">(E,d)</code> is the minimum of the claim and the endowment.
</p>
<p style="text-align: center;"><code class="reqn">t_i(E,d)=\min\{d_i,E\},\ i=1,\dots,n</code>
</p>

<p>Let <code class="reqn">t(E,d)=(m_1(E,d),\dots,m_n(E,d))</code> be the vector of truncated claims
and <code class="reqn">b(E,d)=\frac{1}{n}t(E,d)</code>
</p>
<p>The DT rule is defined recursively such that, in each step, each claimant receives the <code class="reqn">n</code>-th part of the truncated claim.
</p>
<p>Let <code class="reqn">(E^1,d^1)=(E,d)</code>. For each <code class="reqn">k\ge 2</code> define:
</p>
<p style="text-align: center;"><code class="reqn">(E^k,d^k)=(E^{k-1}-\sum_{i=1}^n b_i(E^{k-1},d^{k-1}),d^{k-1}-b(E^{k-1},d^{k-1})).</code>
</p>

<p>In step 1, the endowment is E and the claims vector is d.
For <code class="reqn">k \ge 2</code>, the endowment is the remainder once all the claimants have received the amount of the previous steps and the new vector of claims is readjusted accordingly.
Observe that neither the endowment nor each agent's claim ever increases from one step to the next.
This recursive process exhausts <code class="reqn">E</code> in the limit.
</p>
<p>For each <code class="reqn">(E,d)</code> the Dominguez-Thomson rule assigns the awards vector:
</p>
<p style="text-align: center;"><code class="reqn">DT(E,d)=\sum_{k=1}^{\infty} b(E^k,d^k)</code>
</p>



<h3>Value</h3>

<p>The awards vector selected by the DT rule. If name = TRUE, the name of the function (DT) as a character string.
</p>


<h3>References</h3>

<p>Domínguez, D. and Thomson, W. (2006). A new solution to the problem of adjudicating conflicting claims. Economic Theory, 28(2), 283-307.
</p>
<p>Thomson, W. (2019). How to divide when there isn't enough. From Aristotle, the Talmud, and Maimonides to the axiomatics of resource allocation. Cambridge University Press.
</p>


<h3>See Also</h3>

<p><a href="#topic+allrules">allrules</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>E=10
d=c(2,4,7,8)
DT(E,d)
</code></pre>

<hr>
<h2 id='dynamicplot'>Dynamic plot</h2><span id='topic+dynamicplot'></span>

<h3>Description</h3>

<p>For each claimaint, it plots the awards of the chosen rules for a dynamic model with t periods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dynamicplot(
  E,
  d,
  Rules,
  claimant,
  percentage,
  times,
  col = NULL,
  legend = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dynamicplot_+3A_e">E</code></td>
<td>
<p>The endowment.</p>
</td></tr>
<tr><td><code id="dynamicplot_+3A_d">d</code></td>
<td>
<p>The vector of claims</p>
</td></tr>
<tr><td><code id="dynamicplot_+3A_rules">Rules</code></td>
<td>
<p>The rules: AA, APRO, CE, CEA, CEL, DT, MO, PIN, PRO, RA, Talmud.</p>
</td></tr>
<tr><td><code id="dynamicplot_+3A_claimant">claimant</code></td>
<td>
<p>A claimant.</p>
</td></tr>
<tr><td><code id="dynamicplot_+3A_percentage">percentage</code></td>
<td>
<p>A number in (0,1).</p>
</td></tr>
<tr><td><code id="dynamicplot_+3A_times">times</code></td>
<td>
<p>Number of iterations.</p>
</td></tr>
<tr><td><code id="dynamicplot_+3A_col">col</code></td>
<td>
<p>The colours. If col=NULL then the sequence of default colours is:
c(&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;, &quot;yellow&quot;, &quot;pink&quot;, &quot;coral4&quot;, &quot;darkgray&quot;, &quot;burlywood3&quot;, &quot;black&quot;, &quot;darkorange&quot;, &quot;darkviolet&quot;).</p>
</td></tr>
<tr><td><code id="dynamicplot_+3A_legend">legend</code></td>
<td>
<p>A logical value. The colour legend is shown if legend=TRUE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Let <code class="reqn">E\ge 0</code> be the endowment to be divided and <code class="reqn">d\in \mathcal{R}^n</code> the vector of claims with <code class="reqn">d\ge 0</code> and such that <code class="reqn">\sum_{i=1}^{n} d_i\ge E,\ </code>
the sum of claims exceeds the endowment.
</p>
<p>A vector <code class="reqn">x=(x_1,\dots,x_n)</code> is an awards vector for the claims problem <code class="reqn">(E,d)</code> if:
no claimant is asked to pay (<code class="reqn">0\le x</code>);
no claimant  receives more than his claim (<code class="reqn">x\le d</code>);
and the balance requirement is satisfied, that is, the sum of the awards is equal to the endowment (<code class="reqn">\sum_{i=1}^{n} x_i= E</code>).
</p>
<p>A rule is a function that assigns to each claims problem <code class="reqn">(E,d)</code> an awards vector for <code class="reqn">(E,d)</code>,
that is, a division between the claimants of the amount available.
</p>
<p>The formal definitions of the main rules are given in the corresponding function help.
</p>
<p>Given <code class="reqn">l</code> a natural number, the function solves each claims problem in time <code class="reqn">t</code>, which is <code class="reqn">(E_t,d)</code>, with <code class="reqn">E_t=(1-p)^t E</code>, <code class="reqn">p</code> <code class="reqn">\in</code> <code class="reqn">(0,1)</code> and <code class="reqn">t=1,\ldots,l</code>.
</p>


<h3>Value</h3>

<p>This function represents the awards proposed by different rules for a claimant if the resource decreases in each iteration by a given percentage.
</p>


<h3>References</h3>

<p>Thomson, W. (2019). How to divide when there isn't enough. From Aristotle, the Talmud, and Maimonides to the axiomatics of resource allocation. Cambridge University Press.
</p>
<p>Mirás Calvo, M.Á., Núñez Lugilde, I., Quinteiro Sandomingo, C., and Sánchez-Rodríguez, E. (2020). An algorithm to compute the core-center rule of a claims problem with an application to
the allocation of CO2 emissions. Working paper.
</p>


<h3>See Also</h3>

<p><a href="#topic+allrules">allrules</a>, <a href="#topic+pathawards">pathawards</a>, <a href="#topic+pathawards3">pathawards3</a>, <a href="#topic+schedrule">schedrule</a>, <a href="#topic+schedrules">schedrules</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>E=10
d=c(2,4,7,8)
Rules=c(Talmud,RA,AA,PRO)
claimant=1
percentage=0.076
times=10
dynamicplot(E,d,Rules,claimant,percentage,times)
</code></pre>

<hr>
<h2 id='giniindex'>Gini index</h2><span id='topic+giniindex'></span>

<h3>Description</h3>

<p>This function returns the Gini index of any rule for a claims problem.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>giniindex(E, d, Rule)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="giniindex_+3A_e">E</code></td>
<td>
<p>The endowment.</p>
</td></tr>
<tr><td><code id="giniindex_+3A_d">d</code></td>
<td>
<p>The vector of claims.</p>
</td></tr>
<tr><td><code id="giniindex_+3A_rule">Rule</code></td>
<td>
<p>A rule: AA, APRO, CE, CEA, CEL, DT, MO, PIN, PRO, RA, Talmud.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Let <code class="reqn">E&gt; 0</code> be the endowment to be divided and <code class="reqn">d\in \mathcal{R}^n</code> the vector of claims
with <code class="reqn">d\ge 0</code> and such that <code class="reqn">D=\sum_{i=1}^{n} d_i\ge E</code>, the sum of claims <code class="reqn">D</code> exceeds the endowment.
</p>
<p>Rearrange the claims from small to large, <code class="reqn">0 \le d_1 \le...\le d_n</code>. The Gini index is a number aimed at measuring the degree of inequality in a distribution.
The Gini index of the rule <code class="reqn">R</code> for the problem <code class="reqn">(E,d)</code>, denoted by <code class="reqn">G(R,E,d)</code>, is
the ratio of the area that lies between the identity line and the Lorenz curve of the rule over the total area under the identity line.
</p>
<p>Let <code class="reqn">R_0(E,d)=0</code>. For each <code class="reqn">k=0,\dots,n</code> define
<code class="reqn">X_k=\frac{k}{n}</code> and
<code class="reqn">Y_k=\frac{1}{E} \sum_{j=0}^{k} R_j(E,d)</code>. Then
</p>
<p style="text-align: center;"><code class="reqn">G(R,E,d)=1-\sum_{k=1}^{n}(X_{k}-X_{k-1})(Y_{k}+Y_{k-1}).</code>
</p>

<p>In general <code class="reqn">0\le G(R,E,d) \le 1</code>.
</p>


<h3>Value</h3>

<p>The Gini index of a rule for a claims problem and the Gini index of the vector of claims.
</p>


<h3>References</h3>

<p>Ceriani, L. and Verme, P. (2012). The origins of the Gini index: extracts from Variabilitá e Mutabilitá (1912) by Corrado Gini. The Journal of Economic Inequality, 10(3), 421-443.
</p>
<p>Mirás Calvo, M.Á., Núñez Lugilde, I., Quinteiro Sandomingo, C., and Sánchez Rodríguez, E. (2022). Deviation from proportionality and Lorenz-domination for claims problems. Rev Econ Design. doi: <a href="https://doi.org/10.1007/s10058-022-00300-y">10.1007/s10058-022-00300-y</a>
</p>


<h3>See Also</h3>

<p><a href="#topic+lorenzcurve">lorenzcurve</a>, <a href="#topic+cumawardscurve">cumawardscurve</a>, <a href="#topic+deviationindex">deviationindex</a>, <a href="#topic+indexgpath">indexgpath</a>, <a href="#topic+lorenzdominance">lorenzdominance</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>E=10
d=c(2,4,7,8)
Rule=AA
giniindex(E,d,Rule)
# The Gini index of the proportional awards coincides with the Gini index of the vector of claims
giniindex(E,d,PRO)
</code></pre>

<hr>
<h2 id='indexgpath'>Index path</h2><span id='topic+indexgpath'></span>

<h3>Description</h3>

<p>The function returns the deviation index path or the signed deviation index path for a rule with respect to another rule for a vector of claims.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>indexgpath(
  d,
  Rule = PRO,
  Rules,
  signed = TRUE,
  col = NULL,
  points = 201,
  legend = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="indexgpath_+3A_d">d</code></td>
<td>
<p>The vector of claims.</p>
</td></tr>
<tr><td><code id="indexgpath_+3A_rule">Rule</code></td>
<td>
<p>Principal Rule: AA, APRO, CE, CEA, CEL, DT, MO, PIN, PRO, RA, Talmud. By default, Rule = PRO.</p>
</td></tr>
<tr><td><code id="indexgpath_+3A_rules">Rules</code></td>
<td>
<p>The rules: AA, APRO, CE, CEA, CEL, DT, MO, PIN, PRO, RA, Talmud.</p>
</td></tr>
<tr><td><code id="indexgpath_+3A_signed">signed</code></td>
<td>
<p>A logical value. If signed = FALSE, it draws the deviation index path and, if signed = TRUE it draws the signed deviation index path. By default, signed = TRUE.</p>
</td></tr>
<tr><td><code id="indexgpath_+3A_col">col</code></td>
<td>
<p>The colours. If col = NULL then the sequence of default colours is:
c(&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;, &quot;yellow&quot;, &quot;pink&quot;, &quot;coral4&quot;, &quot;darkgray&quot;, &quot;burlywood3&quot;, &quot;black&quot;, &quot;darkorange&quot;, &quot;darkviolet&quot;).</p>
</td></tr>
<tr><td><code id="indexgpath_+3A_points">points</code></td>
<td>
<p>The number of endowment values to be drawn.</p>
</td></tr>
<tr><td><code id="indexgpath_+3A_legend">legend</code></td>
<td>
<p>A logical value. The legend is shown if legend = TRUE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Let <code class="reqn">d\in \mathcal{R}^n</code> be  a vector of claims rearranged from small to large, <code class="reqn">0 \le d_1 \le...\le d_n</code>.
</p>
<p>Given two rules <code class="reqn">R</code> and <code class="reqn">S</code>, consider the function <code class="reqn">J</code> that assigns to each <code class="reqn">E\in (0,D]</code>
the value <code class="reqn">J(E)=I(R(E,d),S(E,d))</code>, that is, the signed deviation index of the rules <code class="reqn">R</code> and <code class="reqn">S</code> for the problem <code class="reqn">(E,d)</code>.
The graph of <code class="reqn">J</code> is the signed index path of <code class="reqn">S</code> in function of the rule <code class="reqn">R</code> for the vector of claims <code class="reqn">d</code>.
</p>
<p>Given two rules <code class="reqn">R</code> and <code class="reqn">S</code>, consider the function <code class="reqn">J^{+}</code> that assigns to each <code class="reqn">E\in (0,D]</code>
the value <code class="reqn">J^{+}(E)=I^{+}(R(E,d),S(E,d))</code>, that is, the deviation index of the rules <code class="reqn">R</code> and <code class="reqn">S</code> for the problem <code class="reqn">(E,d)</code>.
The graph of <code class="reqn">J^{+}</code> is the index path of <code class="reqn">S</code> in function of the rule <code class="reqn">R</code> for the vector of claims <code class="reqn">d</code>.
</p>
<p>The signed index path and the index path are simple tools to visualize the discrepancy of the divisions
recommended by a rule for a vector of claims with respect to the divisions recommended by another rule.
If R = PRO, the function draws the proportionality deviation index path or the signed proportionality deviation index path.
</p>
<p><code class="reqn">indexpath</code> function of version 0.1.0 returned the signed proportionality deviation index path.
</p>


<h3>Value</h3>

<p>This function returns the deviation index path of a rule (or several rules) for a vector of claims.
</p>


<h3>References</h3>

<p>Ceriani, L. and Verme, P. (2012). The origins of the Gini index: extracts from Variabilitá e Mutabilitá (1912) by Corrado Gini. The Journal of Economic Inequality, 10(3), 421-443.
</p>
<p>Mirás Calvo, M.Á., Núñez Lugilde, I., Quinteiro Sandomingo, C., and Sánchez Rodríguez, E. (2022). Deviation from proportionality and Lorenz-domination for claims problems. Rev Econ Design. doi: <a href="https://doi.org/10.1007/s10058-022-00300-y">10.1007/s10058-022-00300-y</a>
</p>
<p>Thomson, W. (2019). How to divide when there isn't enough. From Aristotle, the Talmud, and Maimonides to the axiomatics of resource allocation. Cambridge University Press.
</p>


<h3>See Also</h3>

<p><a href="#topic+deviationindex">deviationindex</a>, <a href="#topic+cumawardscurve">cumawardscurve</a>, <a href="#topic+giniindex">giniindex</a>, <a href="#topic+lorenzcurve">lorenzcurve</a>, <a href="#topic+lorenzdominance">lorenzdominance</a>, <a href="#topic+allrules">allrules</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>d=c(2,4,7,8)
Rule=PRO
Rules=c(Talmud,RA,AA)
col=c("red","green","blue")
indexgpath(d,Rule,Rules,signed=TRUE,col)
</code></pre>

<hr>
<h2 id='lorenzcurve'>The Lorenz curve</h2><span id='topic+lorenzcurve'></span>

<h3>Description</h3>

<p>This function returns the Lorenz curve of any rule for a claims problem.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lorenzcurve(E, d, Rules, col = NULL, legend = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lorenzcurve_+3A_e">E</code></td>
<td>
<p>The endowment.</p>
</td></tr>
<tr><td><code id="lorenzcurve_+3A_d">d</code></td>
<td>
<p>The vector of claims.</p>
</td></tr>
<tr><td><code id="lorenzcurve_+3A_rules">Rules</code></td>
<td>
<p>The rules: AA, APRO, CE, CEA, CEL, DT, MO, PIN, PRO, RA, Talmud.</p>
</td></tr>
<tr><td><code id="lorenzcurve_+3A_col">col</code></td>
<td>
<p>The colours. If col=NULL then the sequence of default colors is:
c(&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;, &quot;yellow&quot;, &quot;pink&quot;, &quot;coral4&quot;, &quot;darkgray&quot;, &quot;burlywood3&quot;, &quot;black&quot;, &quot;darkorange&quot;, &quot;darkviolet&quot;).</p>
</td></tr>
<tr><td><code id="lorenzcurve_+3A_legend">legend</code></td>
<td>
<p>A logical value. The colour legend is shown if legend=TRUE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Let <code class="reqn">E&gt; 0</code> be the endowment to be divided and <code class="reqn">d\in \mathcal{R}^n</code> the vector of claims
with <code class="reqn">d\ge 0</code> and such that the sum of claims <code class="reqn">D=\sum_{i=1}^{n} d_i\ge E</code> exceeds the endowment.
</p>
<p>Rearrange the claims from small to large, <code class="reqn">0 \le d_1 \le...\le d_n</code>. The Lorenz curve represents the proportion of the awards given to each subset of claimants by a specific rule <code class="reqn">R</code>  as a function of the
cumulative distribution of population.
</p>
<p>The Lorenz curve of a rule <code class="reqn">R</code> for the claims problem <code class="reqn">(E,d)</code> is the polygonal path connecting the <code class="reqn">n+1</code> points
</p>
<p style="text-align: center;"><code class="reqn">(0,0), (\frac{1}{n},\frac{R_1(E,d)}{E}),\dots,(\frac{n-1}{n},\frac{\sum_{i=1}^{n-1}R_i(E,d)}{E}),(1,1)</code>
</p>

<p>Basically, it represents the cumulative percentage of the endowment assigned by the rule to each cumulative percentage of claimants.
</p>


<h3>Value</h3>

<p>The graphical representation of the Lorenz curve of a rule (or several rules) for a claims problem.
</p>


<h3>References</h3>

<p>Lorenz, M. O. (1905). Methods of measuring the concentration of wealth. Publications of the American statistical association, 9(70), 209-219.
</p>
<p>Mirás Calvo, M.Á., Núñez Lugilde, I., Quinteiro Sandomingo, C., and Sánchez Rodríguez, E. (2022). Deviation from proportionality and Lorenz-domination for claims problems. Rev Econ Design. doi: <a href="https://doi.org/10.1007/s10058-022-00300-y">10.1007/s10058-022-00300-y</a>
</p>


<h3>See Also</h3>

<p><a href="#topic+giniindex">giniindex</a>, <a href="#topic+cumawardscurve">cumawardscurve</a>, <a href="#topic+deviationindex">deviationindex</a>, <a href="#topic+indexgpath">indexgpath</a>, <a href="#topic+lorenzdominance">lorenzdominance</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>E=10
d=c(2,4,7,8)
Rules=c(AA,RA,Talmud,CEA,CEL)
col=c("red","blue","green","yellow","pink")
lorenzcurve(E,d,Rules,col)
</code></pre>

<hr>
<h2 id='lorenzdominance'>Lorenz-dominance relation</h2><span id='topic+lorenzdominance'></span>

<h3>Description</h3>

<p>This function checks whether or not the awards assigned by two rules to a claims problem are Lorenz-comparable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lorenzdominance(E, d, Rules, Info = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lorenzdominance_+3A_e">E</code></td>
<td>
<p>The endowment.</p>
</td></tr>
<tr><td><code id="lorenzdominance_+3A_d">d</code></td>
<td>
<p>The vector of claims.</p>
</td></tr>
<tr><td><code id="lorenzdominance_+3A_rules">Rules</code></td>
<td>
<p>The two rules: AA, APRO, CE, CEA, CEL, DT, MO, PIN, PRO, RA, Talmud.</p>
</td></tr>
<tr><td><code id="lorenzdominance_+3A_info">Info</code></td>
<td>
<p>A logical value.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Let <code class="reqn">E\ge 0</code> be the endowment to be divided and <code class="reqn">d\in \mathcal{R}^n</code> the vector of claims
with <code class="reqn">d\ge 0</code> and such that <code class="reqn">\sum_{i=1}^{n} d_i\ge E,\;</code> the sum of claims exceeds the endowment.
</p>
<p>A vector <code class="reqn">x=(x_1,\dots,x_n)</code> is an awards vector for the claims problem <code class="reqn">(E,d)</code> if <code class="reqn">0\le x \le d</code>
and satisfies the balance requirement, that is, <code class="reqn">\sum_{i=1}^{n}x_i=E</code> the sum of its coordinates is equal to <code class="reqn">E</code>.
Let <code class="reqn">X(E,d)</code> be the set of awards vectors for <code class="reqn">(E,d)</code>.
</p>
<p>Given a claims problem <code class="reqn">(E,d)</code>, in order to compare a pair of awards vectors <code class="reqn">x,y\in X(E,d)</code> with the Lorenz criterion,
first one has to rearrange the coordinates of each allocation in a non-decreasing order. Then we say that <code class="reqn">x</code> Lorenz-dominates <code class="reqn">y</code> (or, that <code class="reqn">y</code> is Lorenz-dominated by <code class="reqn">x</code>)
if all the cumulative sums of the rearranged coordinates are greater with <code class="reqn">x</code> than with <code class="reqn">y</code>. That is,
<code class="reqn">x</code> Lorenz-dominates <code class="reqn">y</code> if for each <code class="reqn">k=1,\dots,n-1</code> we have that
</p>
<p style="text-align: center;"><code class="reqn">\sum_{j=1}^{k}x_j \geq \sum_{j=1}^{k}y_j</code>
</p>

<p>Let <code class="reqn">R</code> and <code class="reqn">R'</code> be two rules. We say that <code class="reqn">R</code> Lorenz-dominates <code class="reqn">R'</code> if <code class="reqn">R(E,d)</code> Lorenz-dominates <code class="reqn">R'(E,d)</code> for all <code class="reqn">(E,d)</code>.
</p>


<h3>Value</h3>

<p>If Info = FALSE, the Lorenz-dominance relation between the awards vectors selected by both rules.
If both awards vectors are equal then cod = 2. If the awards vectors are not Lorenz-comparable then cod = 0.
If the awards vector  selected by the first rule Lorenz-dominates the awards vector  selected by the second rule then cod = 1; otherwise cod = -1.
If Info = TRUE, it also gives the corresponding cumulative sums.
</p>


<h3>References</h3>

<p>Lorenz, M. O. (1905). Methods of measuring the concentration of wealth. Publications of the American statistical association, 9(70), 209-219.
</p>
<p>Mirás Calvo, M.Á., Núñez Lugilde, I., Quinteiro Sandomingo, C., and Sánchez Rodríguez, E. (2022). Deviation from proportionality and Lorenz-domination for claims problems. Rev Econ Design. doi: <a href="https://doi.org/10.1007/s10058-022-00300-y">10.1007/s10058-022-00300-y</a>
</p>
<p>Mirás Calvo, M.Á., Núñez Lugilde, I., Quinteiro Sandomingo, C., and Sánchez-Rodríguez, E. (2021). The adjusted proportional and the minimal overlap rules restricted to the lower-half, higher-half, and middle domains. Working paper 2021-02, ECOBAS.
</p>


<h3>See Also</h3>

<p><a href="#topic+cumawardscurve">cumawardscurve</a>, <a href="#topic+deviationindex">deviationindex</a>, <a href="#topic+indexgpath">indexgpath</a>, <a href="#topic+lorenzcurve">lorenzcurve</a>, <a href="#topic+giniindex">giniindex</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>E=10
d=c(2,4,7,8)
Rules=c(AA,CEA)
lorenzdominance(E,d,Rules)
</code></pre>

<hr>
<h2 id='MO'>Minimal overlap rule</h2><span id='topic+MO'></span>

<h3>Description</h3>

<p>This function returns the awards vector assigned by the minimal overlap rule rule (MO) to a claims problem.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MO(E, d, name = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MO_+3A_e">E</code></td>
<td>
<p>The endowment.</p>
</td></tr>
<tr><td><code id="MO_+3A_d">d</code></td>
<td>
<p>The vector of claims.</p>
</td></tr>
<tr><td><code id="MO_+3A_name">name</code></td>
<td>
<p>A logical value.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Let <code class="reqn">E\ge 0</code> be the endowment to be divided and <code class="reqn">d\in \mathcal{R}^n</code> the vector of claims
with <code class="reqn">d\ge 0</code> and such that <code class="reqn">\sum_{i=1}^{n} d_i\ge E,\;</code> the sum of claims exceeds the endowment.
</p>
<p>The truncated claim of a claimant <code class="reqn">i</code> is the minimum of the claim and the endowment:
</p>
<p style="text-align: center;"><code class="reqn">t_i(E,d)=t_i=\min\{d_i,E\},\ i=1,\dots,n</code>
</p>

<p>Suppose that each agent claims specific parts of E equal to her/his
claim. After arranging which parts agents claim so as to “minimize
conflict”, equal division prevails among all agents claiming a
specific part and each agent receives the sum of the compensations
she/he gets from the various parts that he claimed.
</p>
<p>Let <code class="reqn">d_0=0</code>. The minimal overlap rule is defined, for each problem <code class="reqn">(E,d)</code> and each claimant <code class="reqn">i</code>, as:
</p>
<p>If <code class="reqn">E\le d_n</code> then
</p>
<p style="text-align: center;"><code class="reqn">MO_i(E,d)=\frac{t_1}{n}+\frac{t_2-t_1}{n-1}+\dots+\frac{t_i-t_{i-1}}{n-i+1}.</code>
</p>

<p>If <code class="reqn">E&gt;d_n</code> let <code class="reqn">s\in (d_k,d_{k+1}]</code>, with <code class="reqn">k\in \{0,1,\dots,n-2\}</code>,
be the unique solution to the equation <code class="reqn">\sum_{i \in N} \max\{d_i-s,0\} =E-s</code>. Then:
</p>
<p style="text-align: center;"><code class="reqn">MO_i(E,d)=\frac{d_1}{n}+\frac{d_2-d_1}{n-1}+\dots+\frac{d_i-d_{i-1}}{n-i+1}, \  i\in\{1,\dots,k\}</code>
</p>

<p style="text-align: center;"><code class="reqn">MO_i(E,d)=MO_i(s,d)+d_i-s, \  i\in\{k+1,\dots,n\}.</code>
</p>



<h3>Value</h3>

<p>The awards vector selected by the MO rule. If name = TRUE, the name of the function (MO) as a character string.
</p>


<h3>References</h3>

<p>Mirás Calvo, M.A., Núñez Lugilde, I., Quinteiro Sandomingo, C., and Sánchez-Rodríguez, E. (2021). The adjusted proportional and the minimal overlap rules restricted to the lower-half, higher-half, and middle domains. Working paper 2021-02, ECOBAS.
</p>
<p>O'Neill, B. (1982). A problem of rights arbitration from the Talmud. Math. Social Sci. 2, 345-371.
</p>
<p>Thomson, W. (2019). How to divide when there isn't enough. From Aristotle, the Talmud, and Maimonides to the axiomatics of resource allocation. Cambridge University Press.
</p>


<h3>See Also</h3>

<p><a href="#topic+allrules">allrules</a>, <a href="#topic+CD">CD</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>E=10
d=c(2,4,7,8)
MO(E,d)
</code></pre>

<hr>
<h2 id='pathawards'>The path of awards for two claimants</h2><span id='topic+pathawards'></span>

<h3>Description</h3>

<p>This function returns the graphical representation of the path of awards of any rule for a claims vector and a pair of claimants.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pathawards(d, claimants, Rule, col = "red", points = 201)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pathawards_+3A_d">d</code></td>
<td>
<p>The vector of claims.</p>
</td></tr>
<tr><td><code id="pathawards_+3A_claimants">claimants</code></td>
<td>
<p>Two claimants.</p>
</td></tr>
<tr><td><code id="pathawards_+3A_rule">Rule</code></td>
<td>
<p>The rule: AA, APRO, CE, CEA, CEL, DT, MO, PIN, PRO, RA, Talmud.</p>
</td></tr>
<tr><td><code id="pathawards_+3A_col">col</code></td>
<td>
<p>The colour.</p>
</td></tr>
<tr><td><code id="pathawards_+3A_points">points</code></td>
<td>
<p>The number of values of the endowment to draw the path.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Let <code class="reqn">d\in \mathcal{R}^n</code>, with <code class="reqn">d\ge 0</code>, be a vector of claims and
denote  <code class="reqn">D=\sum_{i=1}^{n} d_i</code> the sum of claims.
</p>
<p>The path of awards of a rule <code class="reqn">R</code> for two claimants <code class="reqn">i</code> and <code class="reqn">j</code> is the parametric curve:
</p>
<p style="text-align: center;"><code class="reqn">p(E)=\{(R_i(E,d),R_j(E,d))\in \mathcal{R}^2:\;E\in[0,D]\}.</code>
</p>



<h3>Value</h3>

<p>The graphical representation of the path of awards of a rule for the given claims and a pair of claimants.
</p>


<h3>References</h3>

<p>Thomson, W. (2019). How to divide when there isn't enough. From Aristotle, the Talmud, and Maimonides to the axiomatics of resource allocation. Cambridge University Press.
</p>


<h3>See Also</h3>

<p><a href="#topic+pathawards3">pathawards3</a>, <a href="#topic+schedrule">schedrule</a>, <a href="#topic+schedrules">schedrules</a>, <a href="#topic+verticalruleplot">verticalruleplot</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>d=c(2,4,7,8)
claimants=c(1,2)
Rule=Talmud
pathawards(d,claimants,Rule)
# The path of awards of the concede-and-divide rule
pathawards(c(2,3),c(1,2),CD)
#The path of awards of the DT rule for d=(d1,d2) with d2&lt;2d1
pathawards(c(1,1.5),c(1,2),DT,col="blue",points=1001)
#The path of awards of the DT rule for d=(d1,d2) with d2&gt;2d1
pathawards(c(1,2.5),c(1,2),DT,col="blue",points=1001)
</code></pre>

<hr>
<h2 id='pathawards3'>The path of awards for three claimants</h2><span id='topic+pathawards3'></span>

<h3>Description</h3>

<p>This function returns the graphical representation of the path of awards of any rule for a claims vector and three claimants.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pathawards3(d, claimants, Rule, col = "red", points = 300)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pathawards3_+3A_d">d</code></td>
<td>
<p>The vector of claims.</p>
</td></tr>
<tr><td><code id="pathawards3_+3A_claimants">claimants</code></td>
<td>
<p>Three claimants.</p>
</td></tr>
<tr><td><code id="pathawards3_+3A_rule">Rule</code></td>
<td>
<p>The rule: AA, APRO, CE, CEA, CEL, DT, MO, PIN, PRO, RA, Talmud.</p>
</td></tr>
<tr><td><code id="pathawards3_+3A_col">col</code></td>
<td>
<p>The colour of the path, by default, col=&quot;red&quot;.</p>
</td></tr>
<tr><td><code id="pathawards3_+3A_points">points</code></td>
<td>
<p>The number of values of the endowment to draw the path.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Let <code class="reqn">d\in \mathcal{R}^n</code>, with <code class="reqn">d\ge 0</code>, be a vector of claims and
denote  <code class="reqn">D=\sum_{i=1}^{n} d_i</code> the sum of claims.
</p>
<p>The path of awards of a rule <code class="reqn">R</code> for three claimants <code class="reqn">i</code>, <code class="reqn">j</code>, and <code class="reqn">k</code> is the parametric curve:
</p>
<p style="text-align: center;"><code class="reqn">p(E)=\{(R_i(E,d),R_j(E,d),R_k(E,d))\in \mathcal{R}^3:\;E\in[0,D]\}.</code>
</p>



<h3>Value</h3>

<p>The graphical representation of the path of awards of a rule for the given claims and three claimants.
</p>


<h3>See Also</h3>

<p><a href="#topic+pathawards">pathawards</a>, <a href="#topic+schedrule">schedrule</a>, <a href="#topic+schedrules">schedrules</a>, <a href="#topic+verticalruleplot">verticalruleplot</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>d=c(2,4,7,8)
claimants=c(1,3,4)
Rule=Talmud
pathawards3(d,claimants,Rule)
</code></pre>

<hr>
<h2 id='PIN'>Piniles' rule</h2><span id='topic+PIN'></span>

<h3>Description</h3>

<p>This function returns the awards vector assigned by the Piniles' rule (PIN) to a claims problem.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PIN(E, d, name = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PIN_+3A_e">E</code></td>
<td>
<p>The endowment.</p>
</td></tr>
<tr><td><code id="PIN_+3A_d">d</code></td>
<td>
<p>The vector of claims.</p>
</td></tr>
<tr><td><code id="PIN_+3A_name">name</code></td>
<td>
<p>A logical value.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Let <code class="reqn">E\ge 0</code> be the endowment to be divided and <code class="reqn">d\in \mathcal{R}^n</code> the vector of claims
with <code class="reqn">d\ge 0</code> and such that <code class="reqn">D=\sum_{i=1}^{n} d_i\ge E</code>, the sum of claims <code class="reqn">D</code> exceeds the endowment.
</p>
<p>The Piniles' rule coincides with the constrained equal awards rule (CEA) applied to
the problem <code class="reqn">(E, d/2)</code> if the endowment is less or equal than the half-sum of the claims, <code class="reqn">D/2</code>.
Otherwise it assigns to each claimant <code class="reqn">i</code> half of the claim, <code class="reqn">d_i/2</code> and,
then, it distributes the remainder with the CEA rule. Therefore:
</p>
<p>If <code class="reqn">E \le \frac{D}{2}</code> then,
</p>
<p style="text-align: center;"><code class="reqn">PIN(E,d)  = CEA(E,d/2).</code>
</p>

<p>If <code class="reqn">E \ge \frac{D}{2}</code> then,
</p>
<p style="text-align: center;"><code class="reqn">PIN(E,d)=d/2+CEA(E-D/2,d/2).</code>
</p>



<h3>Value</h3>

<p>The awards vector selected by the PIN rule. If name = TRUE, the name of the function (PIN) as a character string.
</p>


<h3>References</h3>

<p>Piniles, H.M. (1861). Darkah shel Torah. Forester, Vienna.
</p>
<p>Thomson, W. (2019). How to divide when there isn't enough. From Aristotle, the Talmud, and Maimonides to the axiomatics of resource allocation. Cambridge University Press.
</p>


<h3>See Also</h3>

<p><a href="#topic+allrules">allrules</a>, <a href="#topic+CEA">CEA</a>, <a href="#topic+Talmud">Talmud</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>E=10
d=c(2,4,7,8)
PIN(E,d)
</code></pre>

<hr>
<h2 id='plotrule'>Plot of an awards vector</h2><span id='topic+plotrule'></span>

<h3>Description</h3>

<p>This function plots an awards vector in the set of awards vectors for a claims problem.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotrule(E, d, Rule = NULL, awards = NULL, set = TRUE, col = "blue")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotrule_+3A_e">E</code></td>
<td>
<p>The endowment.</p>
</td></tr>
<tr><td><code id="plotrule_+3A_d">d</code></td>
<td>
<p>The vector of claims.</p>
</td></tr>
<tr><td><code id="plotrule_+3A_rule">Rule</code></td>
<td>
<p>A rule: AA, APRO, CE, CEA, CEL, DT, MO, PIN, PRO, RA, Talmud.</p>
</td></tr>
<tr><td><code id="plotrule_+3A_awards">awards</code></td>
<td>
<p>An awards vector.</p>
</td></tr>
<tr><td><code id="plotrule_+3A_set">set</code></td>
<td>
<p>A logical value.</p>
</td></tr>
<tr><td><code id="plotrule_+3A_col">col</code></td>
<td>
<p>The colour.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Let <code class="reqn">E\ge 0</code> be the endowment to be divided and <code class="reqn">d\in \mathcal{R}^n</code> the vector of claims
with <code class="reqn">d\ge 0</code> and such that <code class="reqn">\sum_{i=1}^{n} d_i\ge E,\;</code> the sum of claims exceeds the endowment.
</p>
<p>A vector <code class="reqn">x=(x_1,\dots,x_n)</code> is an awards vector for the claims problem <code class="reqn">(E,d)</code> if <code class="reqn">0\le x \le d</code>
and satisfies the balance requirement, that is, <code class="reqn">\sum_{i=1}^{n}x_i=E</code> the sum of its coordinates is equal to <code class="reqn">E</code>.
Let <code class="reqn">X(E,d)</code> be the set of awards vectors for the problem <code class="reqn">(E,d)</code>.
</p>
<p>A rule is a function that assigns to each claims problem <code class="reqn">(E,d)</code> an awards vector for <code class="reqn">(E,d)</code>,
that is, a division between the claimants of the amount available.
</p>


<h3>Value</h3>

<p>If set = TRUE, the function creates a new figure plotting both the set of awards vectors for the claims problem and the given awards vector.
Otherwise, it just adds to the current picture the point representing the given awards vector. The function only plots one awards vector at a time.
</p>
<p>The awards vector can be introduced directly as a vector. Alternatively, we can provide a rule and then the awards vector to be plotted is the one selected by the rule for the claims problem.
Therefore, if Rule = NULL it plots the given awards vector.
Otherwise, it plots the awards vector selected by the given rule for the claims problem.
In order to plot two (or more) awards vectors, draw the first one with the option set = TRUE and add the others, one by one, with the option set = FALSE.
</p>


<h3>See Also</h3>

<p><a href="#topic+setofawards">setofawards</a>, <a href="#topic+allrules">allrules</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>E=10
d=c(2,4,7,8)
plotrule(E,d,Rule=AA,col="red")
# Plotting the awards vector (1,3,5,1) and the AA rule
# First, plot the awards vector (1,3,5,1) and the set of awards
plotrule(E,d,awards=c(1,3,5,1),col="green")
# Second, add the AA rule with the option set=FALSE
plotrule(E,d,Rule=AA,set=FALSE,col="red")
</code></pre>

<hr>
<h2 id='PRO'>Proportional rule</h2><span id='topic+PRO'></span>

<h3>Description</h3>

<p>This function returns the awards vector assigned by the proportional rule (PRO) to a claims problem.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PRO(E, d, name = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PRO_+3A_e">E</code></td>
<td>
<p>The endowment.</p>
</td></tr>
<tr><td><code id="PRO_+3A_d">d</code></td>
<td>
<p>The vector of claims.</p>
</td></tr>
<tr><td><code id="PRO_+3A_name">name</code></td>
<td>
<p>A logical value.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Let <code class="reqn">E\ge 0</code> be the endowment to be divided and <code class="reqn">d\in \mathcal{R}^n</code> the vector of claims
with <code class="reqn">d\ge 0</code> and such that <code class="reqn">D=\sum_{i=1}^{n} d_i\ge E</code>, the sum of claims <code class="reqn">D</code> exceeds the endowment.
</p>
<p>The proportional rule distributes awards proportional to claims.
</p>
<p style="text-align: center;"><code class="reqn">PRO(E,d)=\frac{E}{D}d</code>
</p>



<h3>Value</h3>

<p>The awards vector selected by the PRO rule. If name = TRUE, the name of the function (PRO) as a character string.
</p>


<h3>References</h3>

<p>Aristotle, Ethics, Thompson, J.A.K., tr. 1985. Harmondsworth: Penguin.
</p>
<p>Thomson, W. (2019). How to divide when there isn't enough. From Aristotle, the Talmud, and Maimonides to the axiomatics of resource allocation. Cambridge University Press.
</p>


<h3>See Also</h3>

<p><a href="#topic+allrules">allrules</a>, <a href="#topic+APRO">APRO</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>E=10
d=c(2,4,7,8)
PRO(E,d)
</code></pre>

<hr>
<h2 id='problemdata'>Claims problem data</h2><span id='topic+problemdata'></span>

<h3>Description</h3>

<p>The function returns to which of the following sub-domains the claims problem belongs to:  the lower-half, higher-half, and  midpoint domains. In addittion, the function returns
the minimal rights vector, the truncated claims vector, the sum and the half-sum of claims.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>problemdata(E, d, draw = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="problemdata_+3A_e">E</code></td>
<td>
<p>The endowment.</p>
</td></tr>
<tr><td><code id="problemdata_+3A_d">d</code></td>
<td>
<p>The vector of claims.</p>
</td></tr>
<tr><td><code id="problemdata_+3A_draw">draw</code></td>
<td>
<p>A logical value.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Let <code class="reqn">E\ge 0</code> be the endowment to be divided and <code class="reqn">d\in \mathcal{R}^n</code> the vector of claims
with <code class="reqn">d\ge 0</code> and such that <code class="reqn">D=\sum_{i=1}^{n} d_i\ge E</code>, the sum of claims <code class="reqn">D</code> exceeds the endowment.
</p>
<p>The lower-half domain is the sub-domain of claims problems for which the endowment is less or equal than the half-sum of claims, <code class="reqn">E \le  D/2</code>.
</p>
<p>The higher-half domain is the sub-domain of claims problems for which the endowment is greater or equal than the half-sum of claims, <code class="reqn">E \ge  D/2</code>.
</p>
<p>The midpoint domain is the sub-domain of claims problems for which the endowment is equal to the half-sum of claims, <code class="reqn">E =  D/2</code>.
</p>
<p>The minimal right of claimant <code class="reqn">i</code> in <code class="reqn">(E,d)</code> is whatever is left after every other claimant has received his claim, or 0 if that is not possible:
</p>
<p style="text-align: center;"><code class="reqn">m_i(E,d)=\max\{0,E-d(N\backslash\{i\})\},\ i=1,\dots,n.</code>
</p>

<p>Let <code class="reqn">m(E,d)=(m_1(E,d),\dots,m_n(E,d))</code> be the vector of minimal rights.
</p>
<p>The truncated claim of claimant <code class="reqn">i</code> in <code class="reqn">(E,d)</code> is the minimum of the claim and the endowment:
</p>
<p style="text-align: center;"><code class="reqn">t_i(E,d)=\min\{d_i,E\},\ i=1,\dots,n.</code>
</p>

<p>Let <code class="reqn">t(E,d)=(t_1(E,d),\dots,t_n(E,d))</code> be the vector of truncated claims.
</p>


<h3>Value</h3>

<p>The minimal rights vector; the truncated claims vector; the sum, the half-sum of the claims, and the class (lower-half, higher-half, and midpoint domains) to which the claims problem belongs. It returns cod  = 1 if the claims problem belong to the lower-half domain, cod  =  -1  if it belongs to the higher-half domain, and cod = 0  for the midpoint domain.  Moreover, if  draw = TRUE a plot of the claims, from small to large in the interval [0,D], is given.
</p>


<h3>See Also</h3>

<p><a href="#topic+setofawards">setofawards</a>, <a href="#topic+allrules">allrules</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>E=10
d=c(2,4,7,8)
problemdata(E,d,draw=TRUE)
</code></pre>

<hr>
<h2 id='RA'>Random arrival rule</h2><span id='topic+RA'></span>

<h3>Description</h3>

<p>This function returns the awards vector assigned by the random arrival rule (RA) to a claims problem.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RA(E, d, name = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RA_+3A_e">E</code></td>
<td>
<p>The endowment.</p>
</td></tr>
<tr><td><code id="RA_+3A_d">d</code></td>
<td>
<p>The vector of claims.</p>
</td></tr>
<tr><td><code id="RA_+3A_name">name</code></td>
<td>
<p>A logical value.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Let <code class="reqn">E\ge 0</code> be the endowment to be divided and let <code class="reqn">d\in \mathcal{R}^n</code> be the vector of claims
with <code class="reqn">d\ge 0</code> and such that <code class="reqn">\sum_{i=1}^{n} d_i\ge E,\ </code> the sum of claims exceeds the endowment.
</p>
<p>For each subset <code class="reqn">S</code> of the set of claimants <code class="reqn">N</code>, let <code class="reqn">d(S)=\sum_{j\in S}d_j</code> be the sum of claims of the members of <code class="reqn">S</code>.
</p>
<p>The random arrival rule considers all the possible arrivals of the claimants
and applies the principle &ldquo;first to arrive, first to be served&quot;.
Then, for each order, the corresponding marginal worth vector assigns to each claimant the minimum of her/his claim
and what remains of the endowment. The rule averages all the marginal worth vectors  considering all the permutations of the elements of <code class="reqn">N</code>.
</p>
<p>Let <code class="reqn">\Pi^N</code> denote the set of permutations of the set of claimants <code class="reqn">N</code> and <code class="reqn">|\Pi^N|</code> its cardinality.
Given a permutation <code class="reqn">\pi \in \Pi</code> and a claimant <code class="reqn">i\in N</code> let
<code class="reqn">\pi_{\le i}</code> denote the set of claimants that precede <code class="reqn">i</code> in the order <code class="reqn">\pi</code>,
that is, <code class="reqn">\pi_{\le i}=\{ j \in N :\pi(j)&lt;\pi(i) \}</code>.
</p>
<p>The random arrival rule assigns to each <code class="reqn">(E,d)</code> and each <code class="reqn">i</code>
the value:
</p>
<p style="text-align: center;"><code class="reqn">RA_i(E,d)=\frac{1}{|\Pi^N|}\sum_{\pi\in \Pi^N}\min\{d_i,\max\{ 0,E-d(\pi_{\le i}) \}\}, \  i=1,\dots,n</code>
</p>

<p>The random arrival rule corresponds to the Shapley value of the associated (pessimistic) coalitional game.
</p>


<h3>Value</h3>

<p>The awards vector selected by the RA rule. If name = TRUE, the name of the function (RA) as a character string.
</p>


<h3>References</h3>

<p>O'Neill, B. (1982). A problem of rights arbitration from the Talmud. Math. Social Sci. 2, 345-371.
</p>
<p>Thomson, W. (2019). How to divide when there isn't enough. From Aristotle, the Talmud, and Maimonides to the axiomatics of resource allocation. Cambridge University Press.
</p>


<h3>See Also</h3>

<p><a href="#topic+allrules">allrules</a>, <a href="#topic+setofawards">setofawards</a>, <a href="#topic+Talmud">Talmud</a>, <a href="#topic+AA">AA</a>, <a href="#topic+CD">CD</a>, <a href="#topic+APRO">APRO</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>E=10
d=c(2,4,7,8)
RA(E,d)
D=sum(d)
#The random arrival rule is self-dual: RA(E,d)= d-RA(D-E,d)
d-RA(D-E,d)
</code></pre>

<hr>
<h2 id='schedrule'>Schedules of awards of a rule</h2><span id='topic+schedrule'></span>

<h3>Description</h3>

<p>This function returns the graphical representation of the schedules of awards of any rule for a claims vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>schedrule(d, claimants, Rule, col = NULL, points = 201, legend = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="schedrule_+3A_d">d</code></td>
<td>
<p>A vector of claims.</p>
</td></tr>
<tr><td><code id="schedrule_+3A_claimants">claimants</code></td>
<td>
<p>A subset of claimants.</p>
</td></tr>
<tr><td><code id="schedrule_+3A_rule">Rule</code></td>
<td>
<p>The rule: AA, APRO, CE, CEA, CEL, DT, MO, PIN, PRO, RA, or Talmud.</p>
</td></tr>
<tr><td><code id="schedrule_+3A_col">col</code></td>
<td>
<p>The colours. If col = NULL then the sequence of default colours is chosen randomly.</p>
</td></tr>
<tr><td><code id="schedrule_+3A_points">points</code></td>
<td>
<p>The number of values of the endowment to draw the path.</p>
</td></tr>
<tr><td><code id="schedrule_+3A_legend">legend</code></td>
<td>
<p>A logical value. The colour legend is shown if legend = TRUE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Let <code class="reqn">d\in \mathcal{R}^n</code>, with <code class="reqn">d\ge 0</code>, be a vector of claims and
denote  <code class="reqn">D=\sum_{i=1}^{n} d_i</code> the sum of claims.
</p>
<p>The schedules of awards of a rule <code class="reqn">R</code> for claimant <code class="reqn">i</code> is the function <code class="reqn">S</code> that assigns to each <code class="reqn">E\in [0,D]</code> the  value:
<code class="reqn">S(E)=R_i(E,d)\in \mathcal{R}</code>.
Therefore, the schedules of awards of a rule plots each claimants's award as a function of <code class="reqn">E</code>.
</p>


<h3>Value</h3>

<p>The graphical representation of the schedules of awards of a rule for a claims vector and a group of claimants.
</p>


<h3>References</h3>

<p>Thomson, W. (2019). How to divide when there isn't enough. From Aristotle, the Talmud, and Maimonides to the axiomatics of resource allocation. Cambridge University Press.
</p>


<h3>See Also</h3>

<p><a href="#topic+schedrules">schedrules</a>, <a href="#topic+pathawards">pathawards</a>, <a href="#topic+pathawards3">pathawards3</a>, <a href="#topic+verticalruleplot">verticalruleplot</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>d=c(2,4,7,8)
Rule=Talmud
claimants=c(1,2,3,4)
col=c("red","green","yellow","blue")
schedrule(d,claimants,Rule,col)
# The schedules of awards of the concede-and-divide rule.
schedrule(c(2,4),c(1,2),CD)
</code></pre>

<hr>
<h2 id='schedrules'>Schedules of awards of several rules</h2><span id='topic+schedrules'></span>

<h3>Description</h3>

<p>This function returns the graphical representation of the schedules of awards of different rules for a claims vector and a given claimant.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>schedrules(d, claimant, Rules, col = NULL, points = 201, legend = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="schedrules_+3A_d">d</code></td>
<td>
<p>A vector of claims.</p>
</td></tr>
<tr><td><code id="schedrules_+3A_claimant">claimant</code></td>
<td>
<p>A claimant.</p>
</td></tr>
<tr><td><code id="schedrules_+3A_rules">Rules</code></td>
<td>
<p>The rules: AA, APRO, CE, CEA, CEL, DT, MO, PIN, PRO, RA, Talmud.</p>
</td></tr>
<tr><td><code id="schedrules_+3A_col">col</code></td>
<td>
<p>The colours. If col = NULL then the sequence of default colours is:
c(&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;, &quot;yellow&quot;, &quot;pink&quot;, &quot;coral4&quot;, &quot;darkgray&quot;, &quot;burlywood3&quot;, &quot;black&quot;, &quot;darkorange&quot;, &quot;darkviolet&quot;).</p>
</td></tr>
<tr><td><code id="schedrules_+3A_points">points</code></td>
<td>
<p>The number of endowment values to draw the path.</p>
</td></tr>
<tr><td><code id="schedrules_+3A_legend">legend</code></td>
<td>
<p>A logical value. The colour legend is shown if legend = TRUE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Let <code class="reqn">d\in \mathcal{R}^n</code>, with <code class="reqn">d\ge 0</code>, be a vector of claims and
denote  <code class="reqn">D=\sum_{i=1}^{n} d_i</code> the sum of claims.
</p>
<p>The schedules of awards of a rule <code class="reqn">R</code> for claimant <code class="reqn">i</code> is the function <code class="reqn">S</code> that assigns to each <code class="reqn">E\in [0,D]</code> the  value:
<code class="reqn">S(E)=R_i(E,d)\in \mathcal{R}</code>.
Therefore, the schedules of awards of a rule plots each claimants's award as a function of <code class="reqn">E</code>.
</p>


<h3>Value</h3>

<p>The graphical representation of the schedules of awards of the rules for the claims vector and the same claimant.
</p>


<h3>References</h3>

<p>Thomson, W. (2019). How to divide when there isn't enough. From Aristotle, the Talmud, and Maimonides to the axiomatics of resource allocation. Cambridge University Press.
</p>


<h3>See Also</h3>

<p><a href="#topic+schedrule">schedrule</a>, <a href="#topic+pathawards">pathawards</a>, <a href="#topic+pathawards3">pathawards3</a>, <a href="#topic+verticalruleplot">verticalruleplot</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>d=c(2,4,7,8)
claimant=2
Rules=c(Talmud,RA,AA)
col=c("red","green","blue")
schedrules(d,claimant,Rules,col)
</code></pre>

<hr>
<h2 id='setofawards'>Set of awards vectors for a claims problem</h2><span id='topic+setofawards'></span>

<h3>Description</h3>

<p>This function plots the set of awards vectors for a claims problem with 2, 3, or 4 claimants and returns its vertices for any problem.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setofawards(E, d, draw = TRUE, col = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setofawards_+3A_e">E</code></td>
<td>
<p>The endowment.</p>
</td></tr>
<tr><td><code id="setofawards_+3A_d">d</code></td>
<td>
<p>The vector of claims.</p>
</td></tr>
<tr><td><code id="setofawards_+3A_draw">draw</code></td>
<td>
<p>A logical value.</p>
</td></tr>
<tr><td><code id="setofawards_+3A_col">col</code></td>
<td>
<p>The colour.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Let <code class="reqn">E\ge 0</code> be the endowment to be divided and <code class="reqn">d\in \mathcal{R}^n</code> the vector of claims
with <code class="reqn">d\ge 0</code> and such that <code class="reqn">\sum_{i=1}^{n} d_i\ge E,\;</code> the sum of claims exceeds the endowment.
</p>
<p>A vector <code class="reqn">x=(x_1,\dots,x_n)</code> is an awards vector for the claims problem <code class="reqn">(E,d)</code> if <code class="reqn">0\le x \le d</code>
and satisfies the balance requirement, that is, <code class="reqn">\sum_{i=1}^{n}x_i=E</code> the sum of its coordinates is equal to <code class="reqn">E</code>.
Let <code class="reqn">X(E,d)</code> be the set of awards vectors for the problem <code class="reqn">(E,d)</code>.
</p>
<p>For each subset <code class="reqn">S</code> of the set of claimants <code class="reqn">N</code>, let <code class="reqn">d(S)=\sum_{j\in S}d_j</code> be the sum of claims of the members of <code class="reqn">S</code>
and let <code class="reqn">N\backslash S</code> be the complementary coalition of <code class="reqn">S</code>.
</p>
<p>The minimal right of claimant <code class="reqn">i</code> in <code class="reqn">(E,d)</code> is whatever is left after every other claimant has received his claim, or 0 if that is not possible:
</p>
<p style="text-align: center;"><code class="reqn">m_i(E,d)=\max\{0,E-d(N\backslash\{i\})\},\ i=1,\dots,n.</code>
</p>

<p>Let <code class="reqn">m(E,d)=(m_1(E,d),\dots,m_n(E,d))</code> be the vector of minimal rights.
</p>
<p>The truncated claim of claimant <code class="reqn">i</code> in <code class="reqn">(E,d)</code> is the minimum of the claim and the endowment:
</p>
<p style="text-align: center;"><code class="reqn">t_i(E,d)=\min\{d_i,E\},\ i=1,\dots,n.</code>
</p>

<p>Let <code class="reqn">t(E,d)=(t_1(E,d),\dots,t_n(E,d))</code> be the vector of truncated claims.
</p>
<p>A vector <code class="reqn">x</code> is efficient if the sum of its coordinates coincides with the endowment. The set of awards is the the set of all efficient vectors bounded by the minimal right and trucated claim vectors.
</p>
<p>The set of awards vectors for the claims problem <code class="reqn">(E,d)</code> can be given in terms of the minimal rights and truncated claims vectors:
</p>
<p style="text-align: center;"><code class="reqn">X(E,d)=\bigl\{x \in \mathcal{R}^n: \sum_{i=1}^n x_i=E,  m_i(E,d) \le x_i \le t_i(E,d),\ i=1,\dots,n \bigr\}</code>
</p>

<p>The set of awards vectors for a problem coincides with the core of its associated coalitional (pessimistic) game.
</p>
<p>The vertices of the set of awards are the marginal worth vectors. For each order of the claimants, the marginal worth vectors are obtained applying  the principle &ldquo;first to arrive, first to be served&quot;.
Then, for each order, the corresponding marginal worth vector assigns to each claimant the minimum of her/his claim
and what remains of the endowment.
</p>


<h3>Value</h3>

<p>The vertices of the set of awards vectors for any claims problem.
For two-claimant and three-claimant problems, if draw = TRUE it plots the set of awards vectors.
For a four-claimant problem, if draw = TRUE, it plots the projection of the set of awards vector over the euclidean space of the first three coordinates.
For a claims problem with more than four claimants, it only displays the vertices of the set of awards.
The default colours (col = NULL) are: red for two-claimant problems, beige for three-claimant problems, and white for four-claimant problems.
</p>


<h3>References</h3>

<p>Thomson, W. (2019). How to divide when there isn't enough. From Aristotle, the Talmud, and Maimonides to the axiomatics of resource allocation. Cambridge University Press.
</p>


<h3>See Also</h3>

<p><a href="#topic+plotrule">plotrule</a>, <a href="#topic+problemdata">problemdata</a>, <a href="#topic+AA">AA</a>, <a href="#topic+RA">RA</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>E=10
d=c(2,4,7,8)
setofawards(E,d,col="darkgreen")
</code></pre>

<hr>
<h2 id='Talmud'>Talmud rule</h2><span id='topic+Talmud'></span>

<h3>Description</h3>

<p>This function returns the awards vector assigned by the Talmud rule to a claims problem.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Talmud(E, d, name = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Talmud_+3A_e">E</code></td>
<td>
<p>The endowment.</p>
</td></tr>
<tr><td><code id="Talmud_+3A_d">d</code></td>
<td>
<p>The vector of claims.</p>
</td></tr>
<tr><td><code id="Talmud_+3A_name">name</code></td>
<td>
<p>A logical value.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Let <code class="reqn">E\ge 0</code> be the endowment to be divided and <code class="reqn">d\in \mathcal{R}^n</code> the vector of claims
with <code class="reqn">d\ge 0</code> and such that <code class="reqn">D=\sum_{i=1}^{n} d_i\ge E</code>, the sum of claims <code class="reqn">D</code> exceeds the endowment.
</p>
<p>The Talmud rule coincides with the constrained equal awards rule (CEA)
applied to the problem <code class="reqn">(E, d/2)</code> if the endowment is less or equal than the half-sum of the claims, <code class="reqn">D/2</code>.
Otherwise, the Talmud rule assigns <code class="reqn">d/2</code> and
the remainder, <code class="reqn">E-D/2</code>, is awarded with the constrained equal losses rule with claims <code class="reqn">d/2</code>. Therefore:
</p>
<p>If <code class="reqn">E \le \frac{D}{2}</code> then:
</p>
<p style="text-align: center;"><code class="reqn">Talmud(E,d) = CEA(E,d/2).</code>
</p>

<p>If <code class="reqn">E \ge \frac{D}{2}</code> then:
</p>
<p style="text-align: center;"><code class="reqn">Talmud(E,d) =d/2+ CEL(E-D/2,d/2) = d-CEA(D-E,d/2).</code>
</p>

<p>The Talmud rule when applied to a two-claimant problem is often referred to as the contested garment rule and coincides with concede-and-divide rule.
The Talmud rule corresponds to the nucleolus of the associated (pessimistic) coalitional game.
</p>


<h3>Value</h3>

<p>The awards vector selected by the Talmud rule.
If name = TRUE, the name of the function (Talmud) as a character string.
</p>


<h3>References</h3>

<p>Aumann, R. and Maschler, M. (1985). Game theoretic analysis of a bankruptcy problem from the Talmud. Journal of Economic Theory 36, 195-213.
</p>
<p>Thomson, W. (2019). How to divide when there isn't enough. From Aristotle, the Talmud, and Maimonides to the axiomatics of resource allocation. Cambridge University Press.
</p>


<h3>See Also</h3>

<p><a href="#topic+allrules">allrules</a>, <a href="#topic+CEA">CEA</a>, <a href="#topic+CEL">CEL</a>, <a href="#topic+AA">AA</a>, <a href="#topic+APRO">APRO</a>, <a href="#topic+RA">RA</a>, <a href="#topic+CD">CD</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>E=10
d=c(2,4,7,8)
Talmud(E,d)
D=sum(d)
#The Talmud rule is self-dual
d-Talmud(D-E,d)
</code></pre>

<hr>
<h2 id='verticalruleplot'>Vertical rule plot</h2><span id='topic+verticalruleplot'></span>

<h3>Description</h3>

<p>For each claimant, it plots a vertical line with his claim and a point on the awards vector of the chosen rules.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>verticalruleplot(E, d, Rules, col = NULL, legend = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="verticalruleplot_+3A_e">E</code></td>
<td>
<p>The endowment.</p>
</td></tr>
<tr><td><code id="verticalruleplot_+3A_d">d</code></td>
<td>
<p>The vector of claims</p>
</td></tr>
<tr><td><code id="verticalruleplot_+3A_rules">Rules</code></td>
<td>
<p>The rules: AA, APRO, CE, CEA, CEL, DT, MO, PIN, PRO, RA, Talmud.</p>
</td></tr>
<tr><td><code id="verticalruleplot_+3A_col">col</code></td>
<td>
<p>The colours. If col=NULL then the sequence of default colours is:
c(&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;, &quot;yellow&quot;, &quot;pink&quot;, &quot;coral4&quot;, &quot;darkgray&quot;, &quot;burlywood3&quot;, &quot;black&quot;, &quot;darkorange&quot;, &quot;darkviolet&quot;).</p>
</td></tr>
<tr><td><code id="verticalruleplot_+3A_legend">legend</code></td>
<td>
<p>A logical value. The colour legend is shown if legend=TRUE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Let <code class="reqn">E\ge 0</code> be the endowment to be divided and <code class="reqn">d\in \mathcal{R}^n</code> the vector of claims with <code class="reqn">d\ge 0</code> and such that <code class="reqn">\sum_{i=1}^{n} d_i\ge E,\ </code>
the sum of claims exceeds the endowment.
</p>
<p>A vector <code class="reqn">x=(x_1,\dots,x_n)</code> is an awards vector for the claims problem <code class="reqn">(E,d)</code> if:
no claimant is asked to pay (<code class="reqn">0\le x</code>);
no claimant  receives more than his claim (<code class="reqn">x\le d</code>);
and the balance requirement is satisfied, that is, the sum of the awards is equal to the endowment (<code class="reqn">\sum_{i=1}^{n} x_i= E</code>).
</p>
<p>A rule is a function that assigns to each claims problem <code class="reqn">(E,d)</code> an awards vector for <code class="reqn">(E,d)</code>,
that is, a division between the claimants of the amount available.
</p>
<p>The formal definitions of the main rules are given in the corresponding function help.
</p>


<h3>Value</h3>

<p>This function represents the claims vector and the awards vector assigned by several rules as vertical segments.
</p>


<h3>References</h3>

<p>Thomson, W. (2019). How to divide when there isn't enough. From Aristotle, the Talmud, and Maimonides to the axiomatics of resource allocation. Cambridge University Press.
</p>


<h3>See Also</h3>

<p><a href="#topic+allrules">allrules</a>, <a href="#topic+pathawards">pathawards</a>, <a href="#topic+pathawards3">pathawards3</a>, <a href="#topic+schedrule">schedrule</a>, <a href="#topic+schedrules">schedrules</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>E=10
d=c(2,4,7,8)
Rules=c(Talmud,RA,AA)
col=c("red","green","blue")
verticalruleplot(E,d,Rules,col)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
