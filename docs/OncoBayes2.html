<!DOCTYPE html><html lang="en"><head><title>Help for package OncoBayes2</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {OncoBayes2}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#OncoBayes2'><p>OncoBayes2</p></a></li>
<li><a href='#.get_strata_group_fct'><p>extracts from a blrmfit object and a given data-set the group and</p>
stratum factor</a></li>
<li><a href='#.get_X'><p>Obtain design matrices.</p></a></li>
<li><a href='#.label_index'><p>Utility function to label parameter indices according to factor</p>
levels.</a></li>
<li><a href='#.validate_group_stratum_nesting'><p>Test if each group is assigned to exactly 1 stratum. Error</p>
otherwise.</a></li>
<li><a href='#bind_rows_0'><p>Bind rows of multiple data frames with zero fill</p></a></li>
<li><a href='#blrm_exnex'><p>Bayesian Logistic Regression Model for N-compounds with EXNEX</p></a></li>
<li><a href='#blrm_formula_linear'><p>Build a BLRM formula with linear interaction term in logit-space</p></a></li>
<li><a href='#blrm_formula_saturating'><p>Build a BLRM formula with saturating interaction term in logit-space</p></a></li>
<li><a href='#blrm_trial'><p>Dose-Escalation Trials guided by Bayesian Logistic Regression Model</p></a></li>
<li><a href='#codata_combo2'><p>Dataset: historical and concurrent data on a two-way combination</p></a></li>
<li><a href='#critical_quantile'><p>Critical quantile</p></a></li>
<li><a href='#diagnostic-quantities'><p>Extract Diagnostic Quantities of <span class="pkg">OncoBayes2</span> Models</p></a></li>
<li><a href='#dose_info_combo2'><p>Dataset: trial dose information for a dual-agent combination study</p></a></li>
<li><a href='#draws-OncoBayes2'><p>Transform <code>blrmfit</code> to <code>draws</code> objects</p></a></li>
<li><a href='#drug_info_combo2'><p>Dataset: drug information for a dual-agent combination study</p></a></li>
<li><a href='#example_model'><p>Runs example models</p></a></li>
<li><a href='#example-combo2'><p>Two-drug combination example</p></a></li>
<li><a href='#example-combo2_trial'><p>Two-drug combination example using BLRM Trial</p></a></li>
<li><a href='#example-combo3'><p>Three-drug combination example</p></a></li>
<li><a href='#example-single-agent'><p>Single Agent Example</p></a></li>
<li><a href='#hist_combo2'><p>Dataset: historical data on two single-agents to inform a combination study</p></a></li>
<li><a href='#hist_combo3'><p>Dataset: historical and concurrent data on a three-way combination</p></a></li>
<li><a href='#hist_SA'><p>Single-agent example</p></a></li>
<li><a href='#lodds'><p>Logit (log-odds) and inverse-logit function.</p></a></li>
<li><a href='#log_inv_logit'><p>Numerically stable summation of log inv logit</p></a></li>
<li><a href='#log_mean_exp'><p>Numerically stable mean of logs</p></a></li>
<li><a href='#nsamples.blrmfit'><p>Return the number of posterior samples</p></a></li>
<li><a href='#plot_blrm'><p>Plot a fitted model</p></a></li>
<li><a href='#posterior_interval.blrmfit'><p>Posterior intervals</p></a></li>
<li><a href='#posterior_linpred.blrmfit'><p>Posterior of linear predictor</p></a></li>
<li><a href='#posterior_predict.blrmfit'><p>Posterior of predictive</p></a></li>
<li><a href='#pp_data'><p>Internal function to simulate from the posterior new parameter draws</p></a></li>
<li><a href='#predictive_interval.blrmfit'><p>Posterior predictive intervals</p></a></li>
<li><a href='#prior_summary.blrmfit'><p>Summarise model prior</p></a></li>
<li><a href='#summary.blrm_trial'><p>Summarise trial</p></a></li>
<li><a href='#summary.blrmfit'><p>Summarise model results</p></a></li>
<li><a href='#update.blrm_trial'><p>Update data and/or prior of a BLRM trial</p></a></li>
<li><a href='#update.blrmfit'><p>Update data of a BLRM analysis</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Bayesian Logistic Regression for Oncology Dose-Escalation Trials</td>
</tr>
<tr>
<td>Description:</td>
<td>Bayesian logistic regression model with optional
  EXchangeability-NonEXchangeability parameter modelling for flexible
  borrowing from historical or concurrent data-sources. The safety model
  can guide dose-escalation decisions for adaptive oncology Phase I
  dose-escalation trials which involve an arbitrary number of
  drugs. Please refer to Neuenschwander et al. (2008)
  &lt;<a href="https://doi.org/10.1002%2Fsim.3230">doi:10.1002/sim.3230</a>&gt; and Neuenschwander et al. (2016)
  &lt;<a href="https://doi.org/10.1080%2F19466315.2016.1174149">doi:10.1080/19466315.2016.1174149</a>&gt; for details on the methodology.</td>
</tr>
<tr>
<td>Version:</td>
<td>0.9-1</td>
</tr>
<tr>
<td>Date:</td>
<td>2025-03-17</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0), RBesT (&ge; 1.8-0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>methods, Rcpp (&ge; 0.12.0), RcppParallel (&ge; 5.0.1), rstan (&ge;
2.32.0), rstantools (&ge; 2.4.0), posterior (&ge; 1.5.0),
assertthat (&ge; 0.2.1), checkmate, Formula, bayesplot (&ge;
1.4.0), ggplot2 (&ge; 3.0.0), dplyr (&ge; 1.1.0), tibble, tidyr (&ge;
1.0.0), abind, scales, rlang (&ge; 0.3.0), tidyselect, utils,
stats, matrixStats, brms, lifecycle, grDevices</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>BH (&ge; 1.75.0), Rcpp (&ge; 0.12.0), RcppEigen (&ge; 0.3.3.3.0),
RcppParallel (&ge; 5.0.1), rstan (&ge; 2.32.0), StanHeaders (&ge;
2.32.0)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>UseLTO:</td>
<td>true</td>
</tr>
<tr>
<td>Suggests:</td>
<td>rmarkdown, knitr, testthat (&ge; 2.0.0), withr, mvtnorm,
vdiffr, cmdstanr (&ge; 0.4.0), ragg</td>
</tr>
<tr>
<td>Additional_repositories:</td>
<td><a href="https://mc-stan.org/r-packages/">https://mc-stan.org/r-packages/</a></td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Biarch:</td>
<td>true</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>GNU make, pandoc (&gt;= 1.12.3), pngquant, C++17</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-03-17 18:32:26 UTC; weberse2</td>
</tr>
<tr>
<td>Author:</td>
<td>Novartis Pharma AG [cph],
  Sebastian Weber [aut, cre],
  Lukas A. Widmer [aut],
  Andrew Bean [aut],
  Trustees of Columbia University [cph] (R/stanmodels.R, configure,
    configure.win)</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Sebastian Weber &lt;sebastian.weber@novartis.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-03-17 19:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='OncoBayes2'>OncoBayes2</h2><span id='topic+OncoBayes2-package'></span><span id='topic+OncoBayes2'></span>

<h3>Description</h3>

<p>Bayesian logistic regression model with optional
EXchangeability-NonEXchangeability parameter modelling for flexible
borrowing from historical or concurrent data-sources. The safety
model can guide dose-escalation decisions for adaptive Oncology
phase I dose-escalation trials which involve an arbitrary number of
drugs.
</p>


<h3>Global Options</h3>


<table>
<tr>
 <td style="text-align: left;">
Option </td><td style="text-align: center;"> Default </td><td style="text-align: left;"> Description </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>OncoBayes2.MC.warmup</code> </td><td style="text-align: center;"> 1000 </td><td style="text-align: left;"> MCMC warmup iterations </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>OncoBayes2.MC.iter</code> </td><td style="text-align: center;"> 2000 </td><td style="text-align: left;"> total MCMC iterations </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>OncoBayes2.MC.save_warmup</code> </td><td style="text-align: center;"> TRUE </td><td style="text-align: left;"> save warmup samples </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>OncoBayes2.MC.chains</code> </td><td style="text-align: center;"> 4 </td><td style="text-align: left;"> MCMC chains</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>OncoBayes2.MC.thin</code> </td><td style="text-align: center;"> 1 </td><td style="text-align: left;"> MCMC thinning </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>OncoBayes2.MC.control</code> </td><td style="text-align: center;"> <code>list(adapt_delta=0.99,</code> </td><td style="text-align: left;"> sets <code>control</code> argument for Stan call</td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: center;"> <code>stepsize=0.1</code>) </td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>OncoBayes2.MC.backend</code> </td><td style="text-align: center;"> rstan </td><td style="text-align: left;"> Backend used to run Stan (<code>rstan</code> or <code>cmdstanr</code>) </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>OncoBayes2.abbreviate.min</code> </td><td style="text-align: center;"> 0 </td><td style="text-align: left;"> Minimal length of variable names </td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: center;"> </td><td style="text-align: left;"> when abbreviating variable names. </td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: center;"> </td><td style="text-align: left;"> The default 0 disables abbreviation.</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Sebastian Weber <a href="mailto:sebastian.weber@novartis.com">sebastian.weber@novartis.com</a>
</p>
<p>Authors:
</p>

<ul>
<li><p> Lukas A. Widmer <a href="mailto:lukas_andreas.widmer@novartis.com">lukas_andreas.widmer@novartis.com</a>
</p>
</li>
<li><p> Andrew Bean <a href="mailto:andrew.bean@novartis.com">andrew.bean@novartis.com</a>
</p>
</li></ul>

<p>Other contributors:
</p>

<ul>
<li><p> Novartis Pharma AG [copyright holder]
</p>
</li>
<li><p> Trustees of Columbia University (R/stanmodels.R, configure, configure.win) [copyright holder]
</p>
</li></ul>



<h3>References</h3>

<p>Neuenschwander, B., Roychoudhury, S., &amp; Schmidli, H.
(2016). On the use of co-data in clinical trials. <em>Statistics in
Biopharmaceutical Research</em>, 8(3), 345-354.
</p>
<p>Neuenschwander, B., Wandel, S., Roychoudhury, S., &amp;
Bailey, S. (2016). Robust exchangeability designs for early phase
clinical trials with multiple strata. <em>Pharmaceutical
statistics</em>, 15(2), 123-134.
</p>
<p>Neuenschwander, B., Branson, M., &amp; Gsponer, T. (2008).
Critical aspects of the Bayesian approach to phase I cancer trials.
<em>Statistics in medicine</em>, 27(13), 2420-2439.
</p>
<p>Neuenschwander, B., Matano, A., Tang, Z., Roychoudhury, S.,
Wandel, S. Bailey, Stuart. (2014). A Bayesian Industry Approach to
Phase I Combination Trials in Oncology. In <em>Statistical methods
in drug combination studies</em> (Vol. 69). CRC Press.
</p>
<p>Stan Development Team (2019). RStan: the R interface to Stan. R package version 2.19.2. https://mc-stan.org
</p>

<hr>
<h2 id='.get_strata_group_fct'>extracts from a blrmfit object and a given data-set the group and
stratum factor</h2><span id='topic+.get_strata_group_fct'></span>

<h3>Description</h3>

<p>extracts from a blrmfit object and a given data-set the group and
stratum factor
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.get_strata_group_fct(object, data)
</code></pre>

<hr>
<h2 id='.get_X'>Obtain design matrices.</h2><span id='topic+.get_X'></span>

<h3>Description</h3>

<p>Obtain design matrices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.get_X(formula, model_frame, num_comp, has_inter, idx_inter_term)
</code></pre>

<hr>
<h2 id='.label_index'>Utility function to label parameter indices according to factor
levels.</h2><span id='topic+.label_index'></span>

<h3>Description</h3>

<p>Utility function to label parameter indices according to factor
levels.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.label_index(stanfit, par, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".label_index_+3A_stanfit">stanfit</code></td>
<td>
<p>stan fit which names are being modified</p>
</td></tr>
<tr><td><code id=".label_index_+3A_par">par</code></td>
<td>
<p>parameter selected</p>
</td></tr>
<tr><td><code id=".label_index_+3A_...">...</code></td>
<td>
<p>must include as many factors as there are indices which
are used in the order given to translate indices to text labels</p>
</td></tr>
</table>

<hr>
<h2 id='.validate_group_stratum_nesting'>Test if each group is assigned to exactly 1 stratum. Error
otherwise.</h2><span id='topic+.validate_group_stratum_nesting'></span>

<h3>Description</h3>

<p>Test if each group is assigned to exactly 1 stratum. Error
otherwise.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.validate_group_stratum_nesting(group_def, strata_def)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".validate_group_stratum_nesting_+3A_group_def">group_def</code></td>
<td>
<p>groups of data</p>
</td></tr>
<tr><td><code id=".validate_group_stratum_nesting_+3A_strata_def">strata_def</code></td>
<td>
<p>assigned stratum to group</p>
</td></tr>
</table>

<hr>
<h2 id='bind_rows_0'>Bind rows of multiple data frames with zero fill</h2><span id='topic+bind_rows_0'></span>

<h3>Description</h3>

<p>A version of bind_rows out of dplyr that
fills non-common columns with zeroes instead of NA.
Gives an error if any of the input data contains NA already.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bind_rows_0(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bind_rows_0_+3A_...">...</code></td>
<td>
<p>Data frames to combine, passed into bind_rows (see dplyr documentation)</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Setting up dummy sampling for fast execution of example
## Please use 4 chains and 100x more warmup &amp; iter in practice
.user_mc_options &lt;- options(
  OncoBayes2.MC.warmup = 10, OncoBayes2.MC.iter = 20, OncoBayes2.MC.chains = 1,
  OncoBayes2.MC.save_warmup = FALSE
)

library(tibble)

dose_info_A &lt;- tibble(
  group_id = "hist_A",
  drug_A = 1
)

dose_info_B &lt;- tibble(
  group_id = "hist_B",
  drug_B = 100 * (1:2)
)

bind_rows_0(dose_info_A, dose_info_B)

## Recover user set sampling defaults
options(.user_mc_options)

</code></pre>

<hr>
<h2 id='blrm_exnex'>Bayesian Logistic Regression Model for N-compounds with EXNEX</h2><span id='topic+blrm_exnex'></span><span id='topic+print.blrmfit'></span>

<h3>Description</h3>

<p>Bayesian Logistic Regression Model (BLRM) for N
compounds using EXchangability and NonEXchangability (EXNEX)
modeling.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>blrm_exnex(
  formula,
  data,
  prior_EX_mu_comp,
  prior_EX_mu_mean_comp,
  prior_EX_mu_sd_comp,
  prior_EX_tau_comp,
  prior_EX_tau_mean_comp,
  prior_EX_tau_sd_comp,
  prior_EX_corr_eta_comp,
  prior_EX_mu_inter,
  prior_EX_mu_mean_inter,
  prior_EX_mu_sd_inter,
  prior_EX_tau_inter,
  prior_EX_tau_mean_inter,
  prior_EX_tau_sd_inter,
  prior_EX_corr_eta_inter,
  prior_is_EXNEX_inter,
  prior_is_EXNEX_comp,
  prior_EX_prob_comp,
  prior_EX_prob_inter,
  prior_NEX_mu_comp,
  prior_NEX_mu_mean_comp,
  prior_NEX_mu_sd_comp,
  prior_NEX_mu_inter,
  prior_NEX_mu_mean_inter,
  prior_NEX_mu_sd_inter,
  prior_tau_dist,
  sample_map = FALSE,
  iter = getOption("OncoBayes2.MC.iter", 2000),
  warmup = getOption("OncoBayes2.MC.warmup", 1000),
  save_warmup = getOption("OncoBayes2.MC.save_warmup", TRUE),
  thin = getOption("OncoBayes2.MC.thin", 1),
  init = getOption("OncoBayes2.MC.init", 0.5),
  chains = getOption("OncoBayes2.MC.chains", 4),
  cores = getOption("mc.cores", 1L),
  control = getOption("OncoBayes2.MC.control", list()),
  backend = getOption("OncoBayes2.MC.backend", "rstan"),
  prior_PD = FALSE,
  verbose = FALSE
)

## S3 method for class 'blrmfit'
print(x, ..., prob = 0.95, digits = 2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="blrm_exnex_+3A_formula">formula</code></td>
<td>
<p>the model formula describing the linear predictors
of the model. The lhs of the formula is a two-column matrix which
are the number of occured events and the number of times no event
occured. The rhs of the formula defines the linear predictors for
the marginal models for each drug component, then the interaction
model and at last the grouping and optional stratum factors of
the models. These elements of the formula are separated by a
vertical bar. The marginal models must follow a intercept and
slope form while the interaction model must not include an
interaction term. See the examples below for an example
instantiation.</p>
</td></tr>
<tr><td><code id="blrm_exnex_+3A_data">data</code></td>
<td>
<p>optional data frame containing the variables of the
model. If not found in <code>data</code>, the variables are taken from
<code>environment(formula)</code>.</p>
</td></tr>
<tr><td><code id="blrm_exnex_+3A_prior_ex_mu_comp">prior_EX_mu_comp</code></td>
<td>
<p>List of bivariate normal mixture priors for
intercept and slope parameters <code class="reqn">\boldsymbol\mu_i =
  (\mu_{\alpha i}, \mu_{\beta i})</code> of each component. In case of a
single drug model, then a mixture prior is accepted as well.</p>
</td></tr>
<tr><td><code id="blrm_exnex_+3A_prior_ex_mu_mean_comp">prior_EX_mu_mean_comp</code>, <code id="blrm_exnex_+3A_prior_ex_mu_sd_comp">prior_EX_mu_sd_comp</code></td>
<td>

<!------------->

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a> Please use <code>prior_EX_mu_comp</code>
instead. Mean and sd for the prior on the mean parameters
<code class="reqn">\boldsymbol\mu_i = (\mu_{\alpha i}, \mu_{\beta i})</code> of each
component.  Two column matrix (intercept, log-slope) with one row
per component.</p>
</td></tr>
<tr><td><code id="blrm_exnex_+3A_prior_ex_tau_comp">prior_EX_tau_comp</code></td>
<td>
<p>List of bivariate normal mixture priors
for heterogeniety parameter <code class="reqn">\boldsymbol\tau_{si} =
  (\tau_{\alpha s i}, \tau_{\beta s i})</code> of each stratum. If no
differential discounting is required (i.e. if there is only one
stratum <code class="reqn">s = 1</code>), then it suffices to provide a bivariate
normal mixture prior instead of a list with just one element.</p>
</td></tr>
<tr><td><code id="blrm_exnex_+3A_prior_ex_tau_mean_comp">prior_EX_tau_mean_comp</code>, <code id="blrm_exnex_+3A_prior_ex_tau_sd_comp">prior_EX_tau_sd_comp</code></td>
<td>

<!----------->

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a> Please use <code>prior_EX_tau_comp</code>
instead. Prior mean and sd for heterogeniety parameter
<code class="reqn">\boldsymbol\tau_{si} = (\tau_{\alpha s i}, \tau_{\beta s
  i})</code> of each stratum. If no differential discounting is required
(i.e. if there is only one stratum <code class="reqn">s = 1</code>), then it is a
two-column matrix (intercept, log-slope) with one row per
component. Otherwise it is a three-dimensional array whose first
dimension indexes the strata, second dimension indexes the
components, and third dimension of length two for (intercept,
log-slope).</p>
</td></tr>
<tr><td><code id="blrm_exnex_+3A_prior_ex_corr_eta_comp">prior_EX_corr_eta_comp</code></td>
<td>
<p>Prior LKJ correlation parameter for
each component given as numeric vector. If missing, then a 1 is
assumed corresponding to a marginal uniform prior of the
correlation.</p>
</td></tr>
<tr><td><code id="blrm_exnex_+3A_prior_ex_mu_inter">prior_EX_mu_inter</code></td>
<td>
<p>Multivariate normal mixture prior for
interaction parameter vector
<code class="reqn">\boldsymbol{\mu_{\eta}}</code>. Dimension must correspond to the
number of interactions.</p>
</td></tr>
<tr><td><code id="blrm_exnex_+3A_prior_ex_mu_mean_inter">prior_EX_mu_mean_inter</code>, <code id="blrm_exnex_+3A_prior_ex_mu_sd_inter">prior_EX_mu_sd_inter</code></td>
<td>

<!------------>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a> Please use <code>prior_EX_mu_inter</code>
instead. Prior mean and sd for population mean parameters
<code class="reqn">\mu_{\eta k}</code> of each interaction parameter. Vector of
length equal to the number of interactions.</p>
</td></tr>
<tr><td><code id="blrm_exnex_+3A_prior_ex_tau_inter">prior_EX_tau_inter</code></td>
<td>
<p>List of multivariate normal mixture
priors for heterogeniety interaction parameter vector
<code class="reqn">\boldsymbol{\tau_{\eta s}}</code> of each stratum. If no
differential discounting is required (i.e. if there is only one
stratum <code class="reqn">s = 1</code>), then it suffices to provide a mixture prior
instead of a list with just one element.</p>
</td></tr>
<tr><td><code id="blrm_exnex_+3A_prior_ex_tau_mean_inter">prior_EX_tau_mean_inter</code>, <code id="blrm_exnex_+3A_prior_ex_tau_sd_inter">prior_EX_tau_sd_inter</code></td>
<td>

<!---------->

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a> Please use
<code>prior_EX_tau_inter</code> instead. Prior mean and sd for heterogeniety
parameter <code class="reqn">\tau_{\eta s k}</code> of each stratum. Matrix with one
column per interaction and one row per stratum.</p>
</td></tr>
<tr><td><code id="blrm_exnex_+3A_prior_ex_corr_eta_inter">prior_EX_corr_eta_inter</code></td>
<td>
<p>Prior LKJ correlation parameter for
interaction given as numeric. If missing, then a 1 is assumed
corresponding to a marginal uniform prior of the correlations.</p>
</td></tr>
<tr><td><code id="blrm_exnex_+3A_prior_is_exnex_inter">prior_is_EXNEX_inter</code></td>
<td>
<p>Defines if non-exchangability is
admitted for a given interaction parameter. Logical vector of
length equal to the number of interactions. If missing
<code>FALSE</code> is assumed for all interactions.</p>
</td></tr>
<tr><td><code id="blrm_exnex_+3A_prior_is_exnex_comp">prior_is_EXNEX_comp</code></td>
<td>
<p>Defines if non-exchangability is
admitted for a given component. Logical vector of length equal to
the number of components. If missing <code>TRUE</code> is assumed for
all components.</p>
</td></tr>
<tr><td><code id="blrm_exnex_+3A_prior_ex_prob_comp">prior_EX_prob_comp</code></td>
<td>
<p>Prior probability <code class="reqn">p_{ij}</code> for
exchangability of each component per group. Matrix with one
column per component and one row per group. Values must lie in
<code class="reqn">[0-1]</code> range.</p>
</td></tr>
<tr><td><code id="blrm_exnex_+3A_prior_ex_prob_inter">prior_EX_prob_inter</code></td>
<td>
<p>Prior probability <code class="reqn">p_{\eta k j}</code> for
exchangability of each interaction per group. Matrix with one
column per interaction and one row per group. Values must lie in
<code class="reqn">[0-1]</code> range.</p>
</td></tr>
<tr><td><code id="blrm_exnex_+3A_prior_nex_mu_comp">prior_NEX_mu_comp</code></td>
<td>
<p>List of bivariate normal mixture priors
<code class="reqn">\boldsymbol m_{ij}</code> and <code class="reqn">\boldsymbol s_{ij} =
  \mbox{diag}(\boldsymbol S_{ij})</code> of each component for
non-exchangable case. If missing set to the same prior as given
for the EX part. It is required that the specification be the
same across groups j.</p>
</td></tr>
<tr><td><code id="blrm_exnex_+3A_prior_nex_mu_mean_comp">prior_NEX_mu_mean_comp</code>, <code id="blrm_exnex_+3A_prior_nex_mu_sd_comp">prior_NEX_mu_sd_comp</code></td>
<td>

<!----------->

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a> Please use <code>prior_NEX_mu_comp</code>
instead. Prior mean <code class="reqn">\boldsymbol m_{ij}</code> and sd
<code class="reqn">\boldsymbol s_{ij} = \mbox{diag}(\boldsymbol S_{ij})</code> of
each component for non-exchangable case. Two column matrix
(intercept, log-slope) with one row per component. If missing set
to the same prior as given for the EX part. It is required that
the specification be the same across groups j.</p>
</td></tr>
<tr><td><code id="blrm_exnex_+3A_prior_nex_mu_inter">prior_NEX_mu_inter</code></td>
<td>
<p>Multivariate normal mixture prior (mean
<code class="reqn">m_{\eta k j}</code>, sd <code class="reqn">s_{\eta k j}</code> and covariance) for the
interaction parameter vector for non-exchangable case. Dimension
must correspond to the number of interactions. If missing set to
the same prior as given for the EX part.</p>
</td></tr>
<tr><td><code id="blrm_exnex_+3A_prior_nex_mu_mean_inter">prior_NEX_mu_mean_inter</code>, <code id="blrm_exnex_+3A_prior_nex_mu_sd_inter">prior_NEX_mu_sd_inter</code></td>
<td>

<!--------->

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a> Please use
<code>prior_NEX_mu_inter</code> instead. Prior mean <code class="reqn">m_{\eta k j}</code> and
sd <code class="reqn">s_{\eta k j}</code> for each interaction parameter for
non-exchangable case. Vector of length equal to the number of
interactions. If missing set to the same prior as given for the
EX part.</p>
</td></tr>
<tr><td><code id="blrm_exnex_+3A_prior_tau_dist">prior_tau_dist</code></td>
<td>
<p>Defines the distribution used for
heterogeniety parameters. Choices are 0=fixed to it's mean,
1=log-normal, 2=truncated normal or <code>NULL</code> shutting off the
hierarchical structure of the model.</p>
</td></tr>
<tr><td><code id="blrm_exnex_+3A_sample_map">sample_map</code></td>
<td>
<p>Logical flag (defaults to <code>FALSE</code>)
controlling inclusion of MAP priors for each stratum defined as
part of the generated posterior. If set to <code>TRUE</code> then the
posterior samples will contain <code>map_log_beta</code> and
<code>map_eta</code> variables.</p>
</td></tr>
<tr><td><code id="blrm_exnex_+3A_iter">iter</code></td>
<td>
<p>number of iterations (including warmup).</p>
</td></tr>
<tr><td><code id="blrm_exnex_+3A_warmup">warmup</code></td>
<td>
<p>number of warmup iterations.</p>
</td></tr>
<tr><td><code id="blrm_exnex_+3A_save_warmup">save_warmup</code></td>
<td>
<p>save warmup samples (<code>TRUE</code> /
<code>FALSE</code>). Only if set to <code>TRUE</code>, then all random
variables are saved in the posterior. This substantially
increases the storage needs of the posterior.</p>
</td></tr>
<tr><td><code id="blrm_exnex_+3A_thin">thin</code></td>
<td>
<p>period of saving samples.</p>
</td></tr>
<tr><td><code id="blrm_exnex_+3A_init">init</code></td>
<td>
<p>positive number to specify uniform range on
unconstrained space for random initialization. See
<code><a href="rstan.html#topic+stan">stan</a></code>.</p>
</td></tr>
<tr><td><code id="blrm_exnex_+3A_chains">chains</code></td>
<td>
<p>number of Markov chains.</p>
</td></tr>
<tr><td><code id="blrm_exnex_+3A_cores">cores</code></td>
<td>
<p>number of cores for parallel sampling of chains.</p>
</td></tr>
<tr><td><code id="blrm_exnex_+3A_control">control</code></td>
<td>
<p>additional sampler parameters for NuTS algorithm.</p>
</td></tr>
<tr><td><code id="blrm_exnex_+3A_backend">backend</code></td>
<td>
<p>sets Stan backend to be used. Possible choices are
<code>"rstan"</code> (default) or <code>"cmdstanr"</code>.</p>
</td></tr>
<tr><td><code id="blrm_exnex_+3A_prior_pd">prior_PD</code></td>
<td>
<p>Logical flag (defaults to <code>FALSE</code>) indicating
if to sample the prior predictive distribution instead of
conditioning on the data.</p>
</td></tr>
<tr><td><code id="blrm_exnex_+3A_verbose">verbose</code></td>
<td>
<p>Logical flag (defaults to <code>FALSE</code>) controlling
if additional output like stan progress is reported.</p>
</td></tr>
<tr><td><code id="blrm_exnex_+3A_x">x</code></td>
<td>
<p><code>blrmfit</code> object to print</p>
</td></tr>
<tr><td><code id="blrm_exnex_+3A_...">...</code></td>
<td>
<p>not used in this function</p>
</td></tr>
<tr><td><code id="blrm_exnex_+3A_prob">prob</code></td>
<td>
<p>central probability mass to report, i.e. the quantiles
0.5-prob/2 and 0.5+prob/2 are displayed. Multiple central
widths can be specified.</p>
</td></tr>
<tr><td><code id="blrm_exnex_+3A_digits">digits</code></td>
<td>
<p>number of digits to show</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>blrm_exnex</code> is a flexible function for Bayesian meta-analytic
modeling of binomial count data. In particular, it is designed to
model counts of the number of observed dose limiting toxicities
(DLTs) by dose, for guiding dose-escalation studies in Oncology. To
accommodate dose escalation over more than one agent, the dose may
consist of combinations of study drugs, with any number of
treatment components.
</p>
<p>In the simplest case, the aim is to model the probability <code class="reqn">\pi</code> that
a patient experiences a DLT, by complementing the binomial likelihood with
a monotone logistic regression
</p>
<p style="text-align: center;"><code class="reqn">\mbox{logit}\,\pi(d) = \log\,\alpha + \beta \, t(d),</code>
</p>

<p>where <code class="reqn">\beta &gt; 0</code>. Most typically, <code class="reqn">d</code> represents the dose,
and <code class="reqn">t(d)</code> is an appropriate transformation, such as <code class="reqn">t(d)
= \log (d \big / d^*)</code>. A joint prior on <code class="reqn">\boldsymbol \theta =
(\log\,\alpha, \log\,\beta)</code> completes the model and ensures
monotonicity <code class="reqn">\beta &gt; 0</code>.
</p>
<p>Many extensions are possible. The function supports general
combination regimens, and also provides framework for Bayesian
meta-analysis of dose-toxicity data from multiple historical and
concurrent sources.
</p>
<p>For an example of a single-agent trial refer to <code><a href="#topic+example-single-agent">example-single-agent</a></code>.
</p>


<h3>Value</h3>

<p>The function returns a S3 object of type
<code>blrmfit</code>.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>print(blrmfit)</code>: print function.
</p>
</li></ul>


<h3>Combination of two treatments</h3>

<p>For a combination of two treatment components, the basic modeling
framework is that the DLT rate <code class="reqn">\pi(d_1,d_2)</code> is comprised of
(1) a &quot;no-interaction&quot; baseline model <code class="reqn">\tilde \pi(d_1,d_2)</code>
driven by the single-agent toxicity of each component, and (2)
optional interaction terms <code class="reqn">\gamma(d_1,d_2)</code> representing
synergy or antagonism between the drugs. On the log-odds scale,
</p>
<p style="text-align: center;"><code class="reqn">\mbox{logit} \,\pi(d_1,d_2) = \mbox{logit} \, \tilde \pi(d_1,d_2) + \eta \, \gamma(d_1,d_2). </code>
</p>

<p>The &quot;no interaction&quot; part <code class="reqn">\tilde \pi(d_1,d_2)</code> represents the probability
of a DLT triggered by either treatment component acting <em>independently</em>.
That is,
</p>
<p style="text-align: center;"><code class="reqn"> \tilde \pi(d_1,d_2) = 1- (1 - \pi_1(d_1))(1 - \pi_2(d_2)). </code>
</p>

<p>In simple terms, P(no DLT for combination) = P(no DLT for drug 1) * P(no DLT from drug 2).
To complete this part, the treatment components can then be modeled with monotone
logistic regressions as before.
</p>
<p style="text-align: center;"><code class="reqn">\mbox{logit} \, \pi_i(d_i) = \log\, \alpha_i + \beta_i \, t(d_i),</code>
</p>

<p>where <code class="reqn">t(d_i)</code> is a monotone transformation of the doses of the
respective drug component $i$, such as <code class="reqn">t(d_i) = \log (d_i \big
/ d_i^*)</code>.
</p>
<p>The inclusion of an interaction term <code class="reqn">\gamma(d_1,d_2)</code> allows
DLT rates above or below the &quot;no-interaction&quot; rate. The magnitude
of the interaction term may also be made dependent on the doses (or
other covariates) through regression. As an example, one could let
</p>
<p style="text-align: center;"><code class="reqn">\gamma(d_1, d_2) = \frac{d_1}{d_1^*} \frac{d_1}{d_2^*}.</code>
</p>

<p>The specific functional form is specified in the usual notation for
a design matrix. The interaction model must respect the constraint
that whenever any dose approaches zero, then the interaction
term must vanish as well. Therefore, the interaction model must not
include an intercept term which would violate this consistency
requirement. A dual combination example can be found in
<code><a href="#topic+example-combo2">example-combo2</a></code>.
</p>


<h3>General combinations</h3>

<p>The model is extended to general combination treatments consisting
of <code class="reqn">N</code> components by expressing the probability <code class="reqn">\pi</code> on
the logit scale as
</p>
<p style="text-align: center;"><code class="reqn"> \mbox{logit} \, \pi(d_1,\ldots,d_N) = \mbox{logit} \Bigl( 1 - \prod_{i = 1}^N ( 1 - \pi_i(d_i) ) \Bigr) + \sum_{k=1}^K \eta_k \, \gamma_k(d_1,\ldots,d_N), </code>
</p>

<p>Multiple drug-drug interactions among the <code class="reqn">N</code> components are
now possible, and are represented through the <code class="reqn">K</code> interaction
terms <code class="reqn">\gamma_k</code>.
</p>
<p>Regression models can be again be specified for each <code class="reqn">\pi_i</code>
and <code class="reqn">\gamma_k</code>, such as
</p>
<p style="text-align: center;"><code class="reqn"> \mbox{logit}\, \pi_i(d_i) = \log\, \alpha_i + \beta_i \, t(d_i) </code>
</p>

<p>Interactions for some subset <code class="reqn">I(k) \subset \{1,\ldots,N \}</code> of
the treatment components can be modeled with regression as well,
for example on products of doses,
</p>
<p style="text-align: center;"><code class="reqn"> \gamma_k(d_1,\ldots,d_N) = \prod_{i \in I(k)} \frac{d_i}{d_i^*}.</code>
</p>

<p>For example, <code class="reqn">I(k) = \{1,2,3\}</code> results in the three-way
interaction term
</p>
<p style="text-align: center;"><code class="reqn"> \frac{d_1}{d_1^*} \frac{d_2}{d_2^*} \frac{d_3}{d_3^*} </code>
</p>

<p>for drugs 1, 2, and 3.
</p>
<p>For a triple combination example please refer to
<code><a href="#topic+example-combo3">example-combo3</a></code>.
</p>


<h3>Meta-analytic framework</h3>

<p>Information on the toxicity of a drug may be available from
multiple studies or sources. Furthermore, one may wish to stratify
observations within a single study (for example into groups of
patients corresponding to different geographic regions, or multiple
dosing <code>dose_info</code> corresponding to different schedules).
</p>
<p><code>blrm_exnex</code> provides tools for robust Bayesian hierarchical
modeling to jointly model data from multiple sources. An additional
index <code class="reqn">j=1, \ldots, J</code> on the parameters and observations
denotes the <code class="reqn">J</code> groups. The resulting model allows the DLT rate
to differ across the groups. The general <code class="reqn">N</code>-component model
becomes
</p>
<p style="text-align: center;"><code class="reqn"> \mbox{logit} \, \pi_j(d_1,\ldots,d_N) = \mbox{logit} \Bigl( 1 - \prod_{i = 1}^N ( 1 - \pi_{ij}(d_i) ) \Bigr) + \sum_{k=1}^K \eta_{kj} \, \gamma_{k}(d_1,\ldots,d_N), </code>
</p>

<p>for groups <code class="reqn">j = 1,\ldots,J</code>. The component toxicities
<code class="reqn">\pi_{ij}</code> and interaction terms <code class="reqn">\gamma_{k}</code> are
modelled, as before, through regression. For example,
<code class="reqn">\pi_{ij}</code> could be a logistic regression on <code class="reqn">t(d_i) =
\log(d_i/d_i^*)</code> with intercept and log-slope <code class="reqn">\boldsymbol
\theta_{ij}</code>, and <code class="reqn">\gamma_{k}</code> regressed with coefficient
<code class="reqn">\eta_{kj}</code> on a product <code class="reqn">\prod_{i\in I(k)} (d_i/d_i^*)</code>
for some subset <code class="reqn">I(k)</code> of components.
</p>
<p>Thus, for <code class="reqn">j=1,\ldots,J</code>, we now have group-specific parameters
<code class="reqn">\boldsymbol\theta_{ij} = (\log\, \alpha_{ij}, \log\,
\beta_{ij})</code> and <code class="reqn">\boldsymbol\nu_{j} = (\eta_{1j}, \ldots,
\eta_{Kj})</code> for each component <code class="reqn">i=1,\ldots,N</code> and interaction
<code class="reqn">k=1,\ldots,K</code>.
</p>
<p>The structure of the prior on
<code class="reqn">(\boldsymbol\theta_{i1},\ldots,\boldsymbol\theta_{iJ})</code> and
<code class="reqn">(\boldsymbol\nu_{1}, \ldots, \boldsymbol\nu_{J})</code> determines how much
information will be shared across groups <code class="reqn">j</code>. Several modeling
choices are available in the function.
</p>

<ul>
<li> <p><em>EX (Full exchangeability):</em> One can assume the
parameters are conditionally exchangeable given hyperparameters
</p>
<p style="text-align: center;"><code class="reqn">\boldsymbol \theta_{ij} \sim \mbox{N}\bigl( \boldsymbol \mu_{\boldsymbol \theta i}, \boldsymbol \Sigma_{\boldsymbol \theta i} \bigr), </code>
</p>

<p>independently across groups <code class="reqn">j = 1,\ldots, J</code> and treatment
components <code class="reqn">i=1,\ldots,N</code>. The covariance matrix
<code class="reqn">\boldsymbol \Sigma_{\boldsymbol \theta i}</code> captures the patterns of cross-group
heterogeneity, and is parametrized with standard deviations
<code class="reqn">\boldsymbol \tau_{\boldsymbol\theta i} = (\tau_{\alpha i},
\tau_{\beta i})</code> and the correlation <code class="reqn">\rho_i</code>. Similarly for the
interactions, the fully-exchangeable model is
</p>
<p style="text-align: center;"><code class="reqn">\boldsymbol \nu_{j} \sim \mbox{N}\bigl( \boldsymbol \mu_{\boldsymbol \nu}, \boldsymbol \Sigma_{\boldsymbol \nu} \bigr)</code>
</p>

<p>for groups <code class="reqn">j = 1,\ldots, J</code> and interactions
<code class="reqn">k=1,\ldots,K</code>, and the prior on the covariance matrix
<code class="reqn">\boldsymbol \Sigma_{\boldsymbol \nu}</code> captures the amount of
heterogeneity expected in the interaction terms a-priori. The
covariance is again parametrized with standard deviations
<code class="reqn">(\tau_{\eta 1}, \ldots, \tau_{\eta K})</code> and its correlation matrix.
</p>
</li>
<li> <p><em>Differential discounting:</em> For one or more of the groups <code class="reqn">j=1,\ldots,J</code>,
larger deviations of <code class="reqn">\boldsymbol\theta_{ij}</code> may be expected from the mean
<code class="reqn">\boldsymbol\mu_i</code>, or of the interactions <code class="reqn">\eta_{kj}</code> from the mean
<code class="reqn">\mu_{\eta,k}</code>. Such differential heterogeneity can be modeled by mapping the groups
<code class="reqn">j = 1,\ldots,J</code> to <em>strata</em> through <code class="reqn">s_j \in \{1,\ldots,S\}</code>,
and modifying the model specification to
</p>
<p style="text-align: center;"><code class="reqn">\boldsymbol \theta_{ij} \sim \mbox{N}\bigl( \boldsymbol \mu_{\boldsymbol \theta i}, \boldsymbol \Sigma_{\boldsymbol \theta ij} \bigr), </code>
</p>

<p>where
</p>
<p style="text-align: center;"><code class="reqn">\boldsymbol \Sigma_{\boldsymbol \theta ij} = \left( \begin{array}{cc}
\tau^2_{\alpha s_j i} &amp; \rho_i \tau_{\alpha s_j i} \tau_{\beta s_j i}\\
\rho_i \tau_{\alpha s_j i} \tau_{\beta s_j i} &amp; \tau^2_{\beta s_j i}
\end{array} \right).</code>
</p>

<p>For the interactions, the model becomes
</p>
<p style="text-align: center;"><code class="reqn">\boldsymbol \nu_{j} \sim \mbox{N}\bigl( \boldsymbol \mu_{\boldsymbol \nu}, \boldsymbol \Sigma_{\boldsymbol \nu j} \bigr),</code>
</p>

<p>where the covariance matrix <code class="reqn">\boldsymbol \Sigma_{\boldsymbol \nu j}</code> is modelled as stratum specific standard deviations <code class="reqn">(\tau_{\eta 1 s_j}, \ldots, \tau_{\eta K s_j})</code> and a stratum independent correlation matrix.
Each stratum
<code class="reqn">s=1,\ldots,S</code> then corresponds to its own set of standard deviations <code class="reqn">\tau</code> leading to different discounting per stratum.
Independent priors are specified for the component parameters
<code class="reqn">\tau_{\alpha s i}</code> and <code class="reqn">\tau_{\beta s i}</code> and
for the interaction parameters <code class="reqn">\tau_{\eta s k}</code> for each stratum
<code class="reqn">s=1,\ldots,S</code>. Inference for strata <code class="reqn">s</code> where the prior is centered
on larger values of the <code class="reqn">\tau</code> parameters will exhibit less shrinkage
towards the the means, <code class="reqn">\boldsymbol\mu_{\boldsymbol \theta i}</code> and <code class="reqn">\boldsymbol \mu_{\boldsymbol \nu}</code> respectively.
</p>
</li>
<li> <p><em>EXNEX (Partial exchangeability):</em> Another mechansim for increasing
robustness is to introduce mixture priors for the group-specific parameters,
where one mixture component is shared across groups, and the other is group-specific.
The result, known as an EXchangeable-NonEXchangeable (EXNEX) type prior, has a form
</p>
<p style="text-align: center;"><code class="reqn">\boldsymbol \theta_{ij} \sim p_{\boldsymbol \theta ij}\, \mbox{N}\bigl( \boldsymbol \mu_{\boldsymbol \theta i}, \boldsymbol \Sigma_{\boldsymbol \theta i} \bigr) +(1-p_{\boldsymbol \theta ij})\, \mbox{N}\bigl(\boldsymbol m_{\boldsymbol \theta ij}, \boldsymbol S_{\boldsymbol \theta ij}\bigr)</code>
</p>

<p>when applied to the treatment-component parameters, and
</p>
<p style="text-align: center;"><code class="reqn">\boldsymbol \nu_{kj} \sim p_{\boldsymbol \nu_{kj}} \,\mbox{N}\bigl(\mu_{\boldsymbol \nu}, \boldsymbol \Sigma_{\boldsymbol \nu}\bigr)_k + (1-p_{\boldsymbol \nu_{kj}})\, \mbox{N}(m_{\boldsymbol \nu_{kj}}, s^2_{\boldsymbol \nu_{kj}})</code>
</p>

<p>when applied to the interaction parameters. The <em>exchangeability weights</em>
<code class="reqn">p_{\boldsymbol \theta ij}</code> and <code class="reqn">p_{\boldsymbol \nu_{kj}}</code> are fixed constants in the interval <code class="reqn">[0,1]</code>
that control the degree to which inference for group <code class="reqn">j</code> is informed
by the exchangeable mixture components. Larger values for the
weights correspond to greater exchange of information, while smaller values
increase robustness in case of outlying observations in individual groups
<code class="reqn">j</code>.
</p>
</li></ul>



<h3>References</h3>

<p>Neuenschwander, B., Roychoudhury, S., &amp; Schmidli, H.
(2016). On the use of co-data in clinical trials. <em>Statistics in
Biopharmaceutical Research</em>, 8(3), 345-354.
</p>
<p>Neuenschwander, B., Wandel, S., Roychoudhury, S., &amp;
Bailey, S. (2016). Robust exchangeability designs for early phase
clinical trials with multiple strata. <em>Pharmaceutical
statistics</em>, 15(2), 123-134.
</p>
<p>Neuenschwander, B., Branson, M., &amp; Gsponer, T. (2008).
Critical aspects of the Bayesian approach to phase I cancer trials.
<em>Statistics in medicine</em>, 27(13), 2420-2439.
</p>
<p>Neuenschwander, B., Matano, A., Tang, Z., Roychoudhury, S.,
Wandel, S. Bailey, Stuart. (2014). A Bayesian Industry Approach to
Phase I Combination Trials in Oncology. In <em>Statistical methods
in drug combination studies</em> (Vol. 69). CRC Press.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Setting up dummy sampling for fast execution of example
## Please use 4 chains and 100x more warmup &amp; iter in practice
.user_mc_options &lt;- options(
  OncoBayes2.MC.warmup = 10, OncoBayes2.MC.iter = 20, OncoBayes2.MC.chains = 1,
  OncoBayes2.MC.save_warmup = FALSE
)

# fit an example model. See documentation for "combo3" example
example_model("combo3")

# print a summary of the prior
prior_summary(blrmfit, digits = 3)

# print a summary of the posterior (model parameters)
print(blrmfit)

# summary of posterior for DLT rate by dose for observed covariate levels
summ &lt;- summary(blrmfit, interval_prob = c(0, 0.16, 0.33, 1))
print(cbind(hist_combo3, summ))

# summary of posterior for DLT rate by dose for new set of covariate levels
newdata &lt;- expand.grid(
  stratum_id = "BID", group_id = "Combo",
  drug_A = 400, drug_B = 800, drug_C = c(320, 400, 600, 800),
  stringsAsFactors = FALSE
)
summ_pred &lt;- summary(blrmfit, newdata = newdata, interval_prob = c(0, 0.16, 0.33, 1))
print(cbind(newdata, summ_pred))

# update the model after observing additional data
newdata$num_patients &lt;- rep(3, nrow(newdata))
newdata$num_toxicities &lt;- c(0, 1, 2, 2)
library(dplyr)
blrmfit_new &lt;- update(blrmfit,
  data = rbind(hist_combo3, newdata) %&gt;%
    arrange(stratum_id, group_id)
)

# updated posterior summary
summ_upd &lt;- summary(blrmfit_new, newdata = newdata, interval_prob = c(0, 0.16, 0.33, 1))
print(cbind(newdata, summ_upd)) 
## Recover user set sampling defaults
options(.user_mc_options)

</code></pre>

<hr>
<h2 id='blrm_formula_linear'>Build a BLRM formula with linear interaction term in logit-space</h2><span id='topic+blrm_formula_linear'></span>

<h3>Description</h3>

<p><code>blrm_formula_linear</code> is a convenience function
for generating a formula for <code>blrm_trial</code> and
<code>blrm_exnex</code> with an interaction of the form:
</p>
<p style="text-align: center;"><code class="reqn">\eta \, \prod_{i=1}^N (d_i \big / d_i^*))</code>
</p>



<h3>Usage</h3>

<pre><code class='language-R'>blrm_formula_linear(
  ref_doses,
  max_interaction_level = 2,
  specific_interaction_terms = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="blrm_formula_linear_+3A_ref_doses">ref_doses</code></td>
<td>
<p>Numeric vector of reference doses with names
corresponding to drug names</p>
</td></tr>
<tr><td><code id="blrm_formula_linear_+3A_max_interaction_level">max_interaction_level</code></td>
<td>
<p>Highest interaction order to consider
<code class="reqn">[1 - Inf]</code>. Default: 2</p>
</td></tr>
<tr><td><code id="blrm_formula_linear_+3A_specific_interaction_terms">specific_interaction_terms</code></td>
<td>
<p>List of custom interaction terms
to generate (e.g. list(c(&quot;drug1&quot;, &quot;drug2&quot;), c(&quot;drug1&quot;,
&quot;drug3&quot;))). Default: NULL</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns an object of class
<code>blrm_formula</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
ref_doses &lt;- c(drug_A = 10, drug_B = 20)

# can be used with blrm_trial
blrm_formula_linear(ref_doses)

</code></pre>

<hr>
<h2 id='blrm_formula_saturating'>Build a BLRM formula with saturating interaction term in logit-space</h2><span id='topic+blrm_formula_saturating'></span>

<h3>Description</h3>

<p><code>blrm_formula_saturating</code> is a convenience
function for generating a formula for <code>blrm_trial</code> and
<code>blrm_exnex</code> with an interaction of the form:
</p>
<p style="text-align: center;"><code class="reqn">2 \eta \, \frac{\prod_{i=1}^N (d_i \big / d_i^*)}{1 +
\prod_{i=1}^N (d_i \big / d_i^*)}</code>
</p>



<h3>Usage</h3>

<pre><code class='language-R'>blrm_formula_saturating(
  ref_doses,
  max_interaction_level = 2,
  specific_interaction_terms = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="blrm_formula_saturating_+3A_ref_doses">ref_doses</code></td>
<td>
<p>Numeric vector of reference doses with names
corresponding to drug names</p>
</td></tr>
<tr><td><code id="blrm_formula_saturating_+3A_max_interaction_level">max_interaction_level</code></td>
<td>
<p>Highest interaction order to consider
<code class="reqn">[1 - Inf]</code>. Default: 2</p>
</td></tr>
<tr><td><code id="blrm_formula_saturating_+3A_specific_interaction_terms">specific_interaction_terms</code></td>
<td>
<p>List of custom interaction terms
to generate (e.g. <code>list(c("drug1", "drug2"), c("drug1",
  "drug3"))</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns an object of class <code>blrm_formula</code>.
</p>


<h3>References</h3>

<p>Widmer, L.A., Bean, A., Ohlssen, D., Weber, S.,
Principled Drug-Drug Interaction Terms for Bayesian Logistic
Regression Models of Drug Safety in Oncology Phase I Combination Trials
<em>arXiv pre-print</em>, 2023, <a href="https://doi.org/10.48550/arXiv.2302.11437">doi:10.48550/arXiv.2302.11437</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
ref_doses &lt;- c(drug_A = 10, drug_B = 20)

# can be used with blrm_trial
blrm_formula_saturating(ref_doses)

</code></pre>

<hr>
<h2 id='blrm_trial'>Dose-Escalation Trials guided by Bayesian Logistic Regression Model</h2><span id='topic+blrm_trial'></span><span id='topic+print.blrm_trial'></span>

<h3>Description</h3>

<p><code>blrm_trial</code> facilitates the conduct of dose
escalation studies guided by Bayesian Logistic Regression
Models (BLRM). While the <code>blrm_exnex</code> only fits the BLRM
model to data, the <code>blrm_trial</code> function standardizes the
specification of the entire trial design and provides various
standardized functions for trial data accrual and derivation of
model summaries needed for dose-escalation decisions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>blrm_trial(
  data,
  dose_info,
  drug_info,
  simplified_prior = FALSE,
  EXNEX_comp = FALSE,
  EX_prob_comp_hist = 1,
  EX_prob_comp_new = 0.8,
  EXNEX_inter = FALSE,
  EX_prob_inter = 1,
  formula_generator = blrm_formula_saturating,
  interval_prob = c(0, 0.16, 0.33, 1),
  interval_max_mass = c(prob_underdose = 1, prob_target = 1, prob_overdose = 0.25),
  ...
)

## S3 method for class 'blrm_trial'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="blrm_trial_+3A_data">data</code></td>
<td>
<p>dose-toxicity data available at design stage of trial</p>
</td></tr>
<tr><td><code id="blrm_trial_+3A_dose_info">dose_info</code></td>
<td>
<p>specificaion of the dose levels as
planned for the ongoing trial arms.</p>
</td></tr>
<tr><td><code id="blrm_trial_+3A_drug_info">drug_info</code></td>
<td>
<p>specification of drugs used in trial arms.</p>
</td></tr>
<tr><td><code id="blrm_trial_+3A_simplified_prior">simplified_prior</code></td>
<td>
<p>logical (defaults to <code>FALSE</code>)
indicating whether a simplified prior should be employed based
on the <code>reference_p_dlt</code> values provided in
<code>drug_info</code>. <strong>Warning:</strong> The simplified prior will
change between releases. Please read instructions below in the
respective section for the simplified prior.</p>
</td></tr>
<tr><td><code id="blrm_trial_+3A_exnex_comp">EXNEX_comp</code></td>
<td>
<p>logical (default to <code>TRUE</code>) indicating
whether EXchangeable-NonEXchangeable priors should be employed
for all component parameters</p>
</td></tr>
<tr><td><code id="blrm_trial_+3A_ex_prob_comp_hist">EX_prob_comp_hist</code></td>
<td>
<p>prior weight (<code class="reqn">[0,1]</code>, default to 1)
on exchangeability for the component parameters in groups
representing historical data</p>
</td></tr>
<tr><td><code id="blrm_trial_+3A_ex_prob_comp_new">EX_prob_comp_new</code></td>
<td>
<p>prior weight (<code class="reqn">[0,1]</code>, default to 0.8)
on exchangeability for the component parameters in groups
representing new or concurrent data</p>
</td></tr>
<tr><td><code id="blrm_trial_+3A_exnex_inter">EXNEX_inter</code></td>
<td>
<p>logical (default to <code>FALSE</code>) indicating
whether EXchangeable-NonEXchangeable priors should be employed
for all interaction parameters</p>
</td></tr>
<tr><td><code id="blrm_trial_+3A_ex_prob_inter">EX_prob_inter</code></td>
<td>
<p>prior weight (<code class="reqn">[0,1]</code>, defaults to 0.8) on
exchangeability for the interaction parameters</p>
</td></tr>
<tr><td><code id="blrm_trial_+3A_formula_generator">formula_generator</code></td>
<td>
<p>formula generation function (see for
example <code>blrm_formula_linear</code> or
<code>blrm_formula_saturating</code>). The formula generator
defines the employed interaction model.</p>
</td></tr>
<tr><td><code id="blrm_trial_+3A_interval_prob">interval_prob</code></td>
<td>
<p>defines the interval probabilities reported in
the standard outputs. Defaults to <code>c(0, 0.16, 0.33, 1)</code>.</p>
</td></tr>
<tr><td><code id="blrm_trial_+3A_interval_max_mass">interval_max_mass</code></td>
<td>
<p>named vector defining for each interval of
the <code>interval_prob</code> vector a maxmimal admissable
probability mass for a given dose level. Whenever the posterior
probability mass in a given interval exceeds the threshold,
then the Escalation With Overdose Control (EWOC) criterion is
considered to be not fullfilled. Dose levels not fullfilling
EWOC are ineligible for the next cohort of patients. The
default restricts the overdose probability to less than 0.25.</p>
</td></tr>
<tr><td><code id="blrm_trial_+3A_...">...</code></td>
<td>
<p>Additional arguments are forwarded to <code>blrm_exnex</code>,
i.e. for the purpose of prior specification.</p>
</td></tr>
<tr><td><code id="blrm_trial_+3A_x">x</code></td>
<td>
<p><code>blrm_trial</code> object to print</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>blrm_trial</code> constructs an object of class
<code>blrm_trial</code> which stores the compelte information about
the study design of a dose-escalation trial. The study design
is defined through the data sets (see sections below for a
definition of the columns):
</p>

<dl>
<dt>data (historical data)</dt><dd><p>The <code>data</code> argument defines
available dose-toxicity data at the design stage of the
trial. Together with the prior of model (without any data) this
defines the prior used for the trial conduct.</p>
</dd>
<dt>dose_info</dt><dd><p>Definition of the pre-specified dose levels
explored in the ongoing trial arms. Thus, all dose-toxcitiy trial
data added to the object is expected correspond to one of the dose
levels in the pre-defined set of dose_info.</p>
</dd>
<dt>drug_info</dt><dd><p>Determines the drugs used in the trial, their
units, reference dose level and optionally defines the expected
probability for a toxicity at the reference dose.</p>
</dd>
</dl>

<p>Once the <code>blrm_trial</code> object is setup the complete trial
design is specified and the model is fitted to the given
<code>data</code>. This allows evaluation of the pre-specified dose
levels of the trial design wrt. to safety, i.e. whether the
starting dose of the trial fullfills the escalate with overdose
criterion (EWOC) condition.
</p>
<p>The <code>blrm_trial</code> trial can also be constructed in a 2-step
process which allows for a more convenient specification of the
prior since meta data like number of drugs and the like can be
used. See the example section for details.
</p>
<p>After setup of the initial <code>blrm_trial</code> object additional data
is added through the use of the <code>update</code> method which has a
<code>add_data</code> argument intended to add data from the ongoing
trial. The <code>summary</code> function finally allows to extract
various model summaries. In particular, the EWOC criterion can be
calculated for the pre-defined dose levels of the trial.
</p>


<h3>Value</h3>

<p>The function returns an object of class <code>blrm_trial</code>.
</p>


<h3>Methods (by generic)</h3>


<ul>
<li> <p><code>print(blrm_trial)</code>: print function.
</p>
</li></ul>


<h3>Simplified prior</h3>

<p>As a convenience for the user, a simplified prior can be specifed
whenever the <code>reference_p_dlt</code> column is present in the
<code>drug_info</code> data set. However, the user is <strong>warned</strong>
that the simplified prior will change in future releases of the
package and thus <strong>we strongly discourage the use of the
simplified prior for setting up trial designs</strong>. The functionality
is intended to provide the user a quick start and as a starting
point. The actually instantiated prior can be seen as demonstrated
below in the examples.
</p>


<h3>Input data</h3>

<p>The data given to the <code>data</code> argument of <code>blrm_trial</code> is
considered as the available at design stage of the trial. The
collected input data thus does not necessarily need to have the
same dose levels as the pre-specified dose_info for the
ongoing trial(s). It's data columns must include, but are not
limited to:
</p>

<dl>
<dt>group_id</dt><dd><p>study</p>
</dd>
<dt>stratum_id</dt><dd><p>optional, only required for differential discounting of groups</p>
</dd>
<dt>num_patients</dt><dd><p>number of patients</p>
</dd>
<dt>num_toxicities</dt><dd><p>number of toxicities</p>
</dd>
<dt>drug_A</dt><dd><p>Columns for the dose of each treatment component,
with column names matching the <code>drug_name</code> values specified
in the <code>drug_info</code> argument of <code>blrm_trial</code></p>
</dd>
</dl>



<h3>Drug info data</h3>

<p>The drug information data-set defines drug properties. The fields
included are:
</p>

<dl>
<dt>drug_name</dt><dd><p>name of drug which is also used as column name for the dose</p>
</dd>
<dt>dose_ref</dt><dd><p>reference dose</p>
</dd>
<dt>dose_unit</dt><dd><p>units used for drug amounts</p>
</dd>
<dt>reference_p_dlt</dt><dd><p>optional; if provided, allows setup of a simplified prior</p>
</dd>
</dl>



<h3>Dose info data</h3>

<p>The <code>drug_info</code> data-set pre-specifies the dose levels of the
ongoing trial. Thus, all data added to the <code>blrm_trial</code>
through the <code>update</code> command must be consistent with the
pre-defined dose levels as no other than those pre-specified ones
can be explored in an ongoing trial.
</p>

<dl>
<dt>dose_id</dt><dd><p>optional column which assigns a unique id to each
group_id/dose combination. If not specified the column is
internally generated.</p>
</dd>
<dt>group_id</dt><dd><p>study</p>
</dd>
<dt>drug_A</dt><dd><p>Columns for the dose of each treatment component,
with column names matching the <code>drug_name</code> values specified
in the <code>drug_info</code> argument of <code>blrm_trial</code></p>
</dd>
</dl>



<h3>References</h3>

<p>Babb, J., Rogatko, A., &amp; Zacks, S. (1998). Cancer
phase I clinical trials: efficient dose escalation with overdose
control. <em>Statistics in medicine</em>, 17(10), 1103-1120.
</p>
<p>Neuenschwander, B., Roychoudhury, S., &amp; Schmidli, H.
(2016). On the use of co-data in clinical trials. <em>Statistics in
Biopharmaceutical Research</em>, 8(3), 345-354.
</p>


<h3>See Also</h3>

<p>Other blrm_trial combo2 example: 
<code><a href="#topic+dose_info_combo2">dose_info_combo2</a></code>,
<code><a href="#topic+drug_info_combo2">drug_info_combo2</a></code>,
<code><a href="#topic+example-combo2_trial">example-combo2_trial</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Setting up dummy sampling for fast execution of example
## Please use 4 chains and 100x more warmup &amp; iter in practice
.user_mc_options &lt;- options(
  OncoBayes2.MC.warmup = 10, OncoBayes2.MC.iter = 20, OncoBayes2.MC.chains = 1,
  OncoBayes2.MC.save_warmup = FALSE
)


# construct initial blrm_trial object from built-in example datasets
combo2_trial_setup &lt;- blrm_trial(
  data = hist_combo2,
  dose_info = dose_info_combo2,
  drug_info = drug_info_combo2,
  simplified_prior = TRUE
)

# extract blrm_call to see setup of the prior as passed to blrm_exnex
summary(combo2_trial_setup, "blrm_exnex_call")

# Warning: The simplified prior will change between releases!
# please refer to the combo2_trial example for a complete
# example. You can obtain this example with
# ?example-combo2_trial
# or by running
# example_model("combo2_trial")

## Recover user set sampling defaults
options(.user_mc_options)

</code></pre>

<hr>
<h2 id='codata_combo2'>Dataset: historical and concurrent data on a two-way combination</h2><span id='topic+codata_combo2'></span>

<h3>Description</h3>

<p>One of two datasets from the application described in Neuenschwander et al
(2016). In the study <code>trial_AB</code>, the risk of DLT was studied as a function of
dose for two drugs, drug A and drug B. Historical information on the toxicity
profiles of these two drugs is available from single agent trials <code>trial_A</code>
and <code>trial_B</code>. Another study <code>IIT</code> was run concurrently to <code>trial_AB</code>, and
studies the same combination. A second dataset <code>hist_combo2</code> is
available from this example, which includes only the data from the single
agent studies, prior to the initiation of <code>trial_AB</code> and <code>IIT</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>codata_combo2
</code></pre>


<h3>Format</h3>

<p>A data frame with 20 rows and 5 variables:
</p>

<dl>
<dt>group_id</dt><dd><p>study</p>
</dd>
<dt>drug_A</dt><dd><p>dose of Drug A</p>
</dd>
<dt>drug_B</dt><dd><p>dose of Drug B</p>
</dd>
<dt>num_patients</dt><dd><p>number of patients</p>
</dd>
<dt>num_toxicities</dt><dd><p>number of DLTs</p>
</dd>
<dt>cohort_time</dt><dd><p>cohort number of patients</p>
</dd>
</dl>



<h3>References</h3>

<p>Neuenschwander, B., Roychoudhury, S., &amp; Schmidli, H.
(2016). On the use of co-data in clinical trials. <em>Statistics in
Biopharmaceutical Research</em>, 8(3), 345-354.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Setting up dummy sampling for fast execution of example
## Please use 4 chains and 100x more warmup &amp; iter in practice
.user_mc_options &lt;- options(
  OncoBayes2.MC.warmup = 10, OncoBayes2.MC.iter = 20, OncoBayes2.MC.chains = 1,
  OncoBayes2.MC.save_warmup = FALSE
)

dref &lt;- c(6, 960)

num_comp   &lt;- 2 # two investigational drugs
num_inter  &lt;- 1 # one drug-drug interaction needs to be modeled
num_groups &lt;- nlevels(codata_combo2$group_id) # no stratification needed
num_strata &lt;- 1 # no stratification needed

blrmfit &lt;- blrm_exnex(
  cbind(num_toxicities, num_patients - num_toxicities) ~
    1 + I(log(drug_A / dref[1])) |
      1 + I(log(drug_B / dref[2])) |
      0 + I(drug_A / dref[1] * drug_B / dref[2]) |
      group_id,
  data = codata_combo2,
  prior_EX_mu_comp  = list(mixmvnorm(c(1, logit(0.2), 0, diag(c(2^2, 1)))),
                           mixmvnorm(c(1, logit(0.2), 0, diag(c(2^2, 1))))),
  prior_EX_tau_comp = list(mixmvnorm(c(1,
                                       log(0.250), log(0.125),
                                       diag(c(log(4)/1.96, log(4)/1.96)^2))),
                           mixmvnorm(c(1,
                                       log(0.250), log(0.125),
                                       diag(c(log(4)/1.96, log(4)/1.96)^2)))),
  prior_EX_mu_inter = mixmvnorm(c(1, 0, 1.121^2)),
  prior_EX_tau_inter = mixmvnorm(c(1, log(0.125), (log(4) / 1.96)^2)),
  prior_is_EXNEX_comp = rep(FALSE, num_comp),
  prior_is_EXNEX_inter = rep(FALSE, num_inter),
  prior_EX_prob_comp = matrix(1, nrow = num_groups, ncol = num_comp),
  prior_EX_prob_inter = matrix(1, nrow = num_groups, ncol = num_inter),
  prior_tau_dist = 1
)
## Recover user set sampling defaults
options(.user_mc_options)

</code></pre>

<hr>
<h2 id='critical_quantile'>Critical quantile</h2><span id='topic+critical_quantile'></span><span id='topic+critical_quantile.blrmfit'></span><span id='topic+critical_quantile.blrm_trial'></span>

<h3>Description</h3>

<p>Calculates the critical value of a model covariate for
which a fixed quantile of the crude rate is equal to the
specified (tail or interval) probability. The specified
quantile can relate to the posterior or the predictive
distribution of the response rate.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>critical_quantile(object, ...)

## S3 method for class 'blrmfit'
critical_quantile(
  object,
  newdata,
  x,
  p,
  qc,
  lower.tail,
  interval.x,
  extendInt.x = c("auto", "no", "yes", "downX", "upX"),
  log.x,
  predictive = FALSE,
  maxiter = 100,
  ...
)

## S3 method for class 'blrm_trial'
critical_quantile(
  object,
  newdata,
  x,
  p,
  qc,
  lower.tail,
  interval.x,
  extendInt.x = c("auto", "no", "yes", "downX", "upX"),
  log.x,
  predictive = FALSE,
  maxiter = 100,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="critical_quantile_+3A_object">object</code></td>
<td>
<p>fitted model object</p>
</td></tr>
<tr><td><code id="critical_quantile_+3A_...">...</code></td>
<td>
<p>not used in this function</p>
</td></tr>
<tr><td><code id="critical_quantile_+3A_newdata">newdata</code></td>
<td>
<p>optional data frame specifying for what to predict;
if missing, then the data of the input model <code>object</code> is
used</p>
</td></tr>
<tr><td><code id="critical_quantile_+3A_x">x</code></td>
<td>
<p>character giving the covariate name which is being search
for to meet the critical conditions.  This also supports 'tidy'
parameter selection by specifying <code>x = vars(...)</code>, where
<code>...</code>  is specified the same way as in
<code><a href="dplyr.html#topic+select">dplyr::select()</a></code> and similar
functions. Examples of using <code>x</code> in this way can be found
in the examples. For <code>blrm_trial</code> methods, it defaults to
the first entry in <code>summary(blrm_trial,
    "drug_info")$drug_name</code>.</p>
</td></tr>
<tr><td><code id="critical_quantile_+3A_p">p</code></td>
<td>
<p>cumulative probability corresponding to the critical
quantile range.</p>
</td></tr>
<tr><td><code id="critical_quantile_+3A_qc">qc</code></td>
<td>
<p>if given as a sorted vector of length 2, then the two
entries define the interval on the response rate scale which
must correspond to the cumulative probability <code>p</code>. In this
case <code>lower.tail</code> must be <code>NULL</code> or left missing. If
<code>qc</code> is only a single number, then <code>lower.tail</code> must
be set to complete the specification of the tail area.</p>
</td></tr>
<tr><td><code id="critical_quantile_+3A_lower.tail">lower.tail</code></td>
<td>
<p>defines if probabilities are lower or upper tail
areas. Must be defined if <code>qc</code> is a single number and must
not be defined if <code>qc</code> denotes an interval.</p>
</td></tr>
<tr><td><code id="critical_quantile_+3A_interval.x">interval.x</code></td>
<td>
<p>interval the covariate <code>x</code> is
searched. Defaults to the minimal and maximal value of <code>x</code>
in the data set used. Whenever <code>lower.tail</code> is set such
that it is known that a tail area is used, then the function
will automatically attempt to enlarge the search interval since
the direction of the inverted function is determined around the
critical value.</p>
</td></tr>
<tr><td><code id="critical_quantile_+3A_extendint.x">extendInt.x</code></td>
<td>
<p>controls if the interval given in
<code>interval.x</code> should be extended during the root
finding. The default <code>"auto"</code> attempts to guess an
adequate setting in cases thats possible. Other possible values
are the same as for the <code>extendInt</code> argument of the
<code><a href="stats.html#topic+uniroot">stats::uniroot()</a></code> function.</p>
</td></tr>
<tr><td><code id="critical_quantile_+3A_log.x">log.x</code></td>
<td>
<p>determines if during the numerical search for the
critical value the covariate space is logarithmized. By default
<code>x</code> is log transformed whenever all values are positive.</p>
</td></tr>
<tr><td><code id="critical_quantile_+3A_predictive">predictive</code></td>
<td>
<p>logical indicates if the critical quantile
relates to the posterior (<code>FALSE</code>) or the predictive
(<code>TRUE</code>) distribution. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="critical_quantile_+3A_maxiter">maxiter</code></td>
<td>
<p>maximal number of iterations for root
finding. Defaults to <code>100</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function searches for a critical value <code class="reqn">x_c</code> of the covariate
<code class="reqn">x</code> (<code>x</code>) at which the integral over the model response in the
specified interval <code class="reqn">\pi_1</code> to <code class="reqn">\pi_2</code> (<code>qc</code>) is equal to the
given probability <code class="reqn">p</code> (<code>p</code>). The given interval is considered
a tail area when <code>lower.tail</code> is used such that <code class="reqn">\pi_1 = 0</code>
for <code>TRUE</code> and <code class="reqn">\pi_2=1</code> for <code>FALSE</code>. At the
critical value <code class="reqn">x_c</code> the equality holds
</p>
<p style="text-align: center;"><code class="reqn">p = \int_{\pi_1}^{\pi_2} p(\pi | x_c) \, d\pi .</code>
</p>

<p>Note that a solution not guranteed to exist under all
circumstances. However, for a single agent model and when
requesting a tail probability then a solution does exist. In case
an interval probability is specified, then the solution may not
necessarily exist and the root finding is confined to the range
specified in <code>interval.x</code>.
</p>
<p>In case the solution is requested for the predictive distribution
(<code>predictive=TRUE</code>), then the respective problem solved leads
to the equality of
</p>
<p style="text-align: center;"><code class="reqn">p = \sum_{y= r_1 = \lceil n \, \pi_1 \rceil }^{r_2 = \lceil n \, \pi_2 \rceil } \int p(y|\pi, n) \, p(\pi | x_c) \, d\pi .</code>
</p>

<p>Furthermore, the covariate space is log transformed by default
whenever all values of the covariate <code class="reqn">x</code> are positive in the data
set. Values of <code class="reqn">0</code> are shifted into the positive domain by the
machine precision to avoid issues with an ill-defined <code class="reqn">\log(0)</code>.
</p>
<p>For <code>blrm_trial</code> objects the default arguments for <code>p</code>,
<code>qc</code> and <code>lower.tail</code> are set to correspond to the
highest interval of <code>interval_prob</code> to be constrained by the
respective <code>interval_max_mass</code> (which are defined as part of
the <code>blrm_trial</code> objects). This will in the default case
correspond to the EWOC metric. These defaults are only applied if
<code>p</code>, <code>qc</code> and <code>lower.tail</code> are missing.
</p>


<h3>Value</h3>

<p>Vector of length equal to the number of rows of the input
data set with the crticial value for the covariate specified as
<code>x</code> which fullfills the requirements as detailled
above. May return <code>NA</code> for cases where no solution is
found on the specified interval <code>interval.x</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Setting up dummy sampling for fast execution of example
## Please use 4 chains and 100x more warmup &amp; iter in practice
.user_mc_options &lt;- options(
  OncoBayes2.MC.warmup = 10, OncoBayes2.MC.iter = 20, OncoBayes2.MC.chains = 1,
  OncoBayes2.MC.save_warmup = FALSE
)

# fit an example model. See documentation for "combo2" example
example_model("combo2", silent = TRUE)

# Find dose of drug_A at which EWOC criterium is just fulfilled
data_trial_ab &lt;- subset(codata_combo2, group_id == "trial_AB")
drug_A_crit &lt;- critical_quantile(blrmfit,
  newdata = data_trial_ab,
  x = "drug_A", p = 0.25, qc = 0.33,
  lower.tail = FALSE
)
data_trial_ab$drug_A &lt;- drug_A_crit
summary(blrmfit, newdata = data_trial_ab, interval_prob = c(0, 0.16, 0.33, 1))

## Recover user set sampling defaults
options(.user_mc_options)

</code></pre>

<hr>
<h2 id='diagnostic-quantities'>Extract Diagnostic Quantities of <span class="pkg">OncoBayes2</span> Models</h2><span id='topic+diagnostic-quantities'></span><span id='topic+log_posterior'></span><span id='topic+nuts_params'></span><span id='topic+rhat'></span><span id='topic+neff_ratio'></span><span id='topic+log_posterior.blrmfit'></span><span id='topic+nuts_params.blrmfit'></span><span id='topic+rhat.blrmfit'></span><span id='topic+neff_ratio.blrmfit'></span>

<h3>Description</h3>

<p>Extract quantities that can be used to diagnose sampling behavior
of the algorithms applied by <span class="pkg">Stan</span> at the back-end of
<span class="pkg">OncoBayes2</span>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'blrmfit'
log_posterior(object, ...)

## S3 method for class 'blrmfit'
nuts_params(object, pars = NULL, ...)

## S3 method for class 'blrmfit'
rhat(object, pars = NULL, ...)

## S3 method for class 'blrmfit'
neff_ratio(object, pars = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="diagnostic-quantities_+3A_object">object</code></td>
<td>
<p>A <code>blrmfit</code> or <code>blrmtrial</code> object.</p>
</td></tr>
<tr><td><code id="diagnostic-quantities_+3A_...">...</code></td>
<td>
<p>Arguments passed to individual methods.</p>
</td></tr>
<tr><td><code id="diagnostic-quantities_+3A_pars">pars</code></td>
<td>
<p>An optional character vector of parameter names.
For <code>nuts_params</code> these will be NUTS sampler parameter
names rather than model parameters. If <code>pars</code> is omitted
all parameters are included.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For more details see
<code><a href="bayesplot.html#topic+bayesplot-extractors">bayesplot-extractors</a></code>.
</p>


<h3>Value</h3>

<p>The exact form of the output depends on the method.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Setting up dummy sampling for fast execution of example
## Please use 4 chains and 100x more warmup &amp; iter in practice
.user_mc_options &lt;- options(
  OncoBayes2.MC.warmup = 10, OncoBayes2.MC.iter = 20, OncoBayes2.MC.chains = 1,
  OncoBayes2.MC.save_warmup = FALSE
)

example_model("single_agent", silent = TRUE)

head(log_posterior(blrmfit))

np &lt;- nuts_params(blrmfit)
str(np)
# extract the number of divergence transitions
sum(subset(np, Parameter == "divergent__")$Value)

head(rhat(blrmfit))
head(neff_ratio(blrmfit))

## Recover user set sampling defaults
options(.user_mc_options)

</code></pre>

<hr>
<h2 id='dose_info_combo2'>Dataset: trial dose information for a dual-agent combination study</h2><span id='topic+dose_info_combo2'></span>

<h3>Description</h3>

<p>The data set defines all pre-defined dose-levels which can be
explored in the dual-agent example trial.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dose_info_combo2
</code></pre>


<h3>Format</h3>

<p>An object of class <code>tbl_df</code> (inherits from <code>tbl</code>, <code>data.frame</code>) with 42 rows and 4 columns.
</p>


<h3>Details</h3>


<dl>
<dt>group_id</dt><dd><p>study</p>
</dd>
<dt>drug_A</dt><dd><p>drug A dose amount</p>
</dd>
<dt>drug_B</dt><dd><p>drug B dose amount</p>
</dd>
<dt>dose_id</dt><dd><p>unique id of record</p>
</dd>
</dl>



<h3>See Also</h3>

<p>Other blrm_trial combo2 example: 
<code><a href="#topic+blrm_trial">blrm_trial</a>()</code>,
<code><a href="#topic+drug_info_combo2">drug_info_combo2</a></code>,
<code><a href="#topic+example-combo2_trial">example-combo2_trial</a></code>
</p>

<hr>
<h2 id='draws-OncoBayes2'>Transform <code>blrmfit</code> to <code>draws</code> objects</h2><span id='topic+draws-OncoBayes2'></span><span id='topic+as_draws'></span><span id='topic+as_draws_matrix'></span><span id='topic+as_draws_array'></span><span id='topic+as_draws_df'></span><span id='topic+as_draws_rvars'></span><span id='topic+as_draws_list'></span><span id='topic+as_draws.blrmfit'></span><span id='topic+as_draws_matrix.blrmfit'></span><span id='topic+as_draws_array.blrmfit'></span><span id='topic+as_draws_df.blrmfit'></span><span id='topic+as_draws_list.blrmfit'></span><span id='topic+as_draws_rvars.blrmfit'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p>Transform a <code>blrmfit</code> object to a format supported by the
<span class="pkg">posterior</span> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'blrmfit'
as_draws(x, variable = NULL, regex = FALSE, inc_warmup = FALSE, ...)

## S3 method for class 'blrmfit'
as_draws_matrix(x, variable = NULL, regex = FALSE, inc_warmup = FALSE, ...)

## S3 method for class 'blrmfit'
as_draws_array(x, variable = NULL, regex = FALSE, inc_warmup = FALSE, ...)

## S3 method for class 'blrmfit'
as_draws_df(x, variable = NULL, regex = FALSE, inc_warmup = FALSE, ...)

## S3 method for class 'blrmfit'
as_draws_list(x, variable = NULL, regex = FALSE, inc_warmup = FALSE, ...)

## S3 method for class 'blrmfit'
as_draws_rvars(x, variable = NULL, regex = FALSE, inc_warmup = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="draws-OncoBayes2_+3A_x">x</code></td>
<td>
<p>A <code>blrmfit</code> object.</p>
</td></tr>
<tr><td><code id="draws-OncoBayes2_+3A_variable">variable</code></td>
<td>
<p>A character vector providing the variables to
extract.  By default, all variables are extracted.</p>
</td></tr>
<tr><td><code id="draws-OncoBayes2_+3A_regex">regex</code></td>
<td>
<p>Logical; Should variable be treated as a (vector of)
regular expressions? Any variable in <code>x</code> matching at least
one of the regular expressions will be selected. Defaults to
<code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="draws-OncoBayes2_+3A_inc_warmup">inc_warmup</code></td>
<td>
<p>Should warmup draws be included? Defaults to
<code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="draws-OncoBayes2_+3A_...">...</code></td>
<td>
<p>Arguments passed to individual methods (if applicable).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>To subset iterations, chains, or draws, use the
<code><a href="posterior.html#topic+subset_draws">subset_draws</a></code> method after
transforming the <code>blrmfit</code> to a <code>draws</code> object.
</p>
<p>The function is experimental as the set of exported posterior
variables are subject to updates.
</p>


<h3>See Also</h3>

<p><code><a href="posterior.html#topic+draws">draws</a></code>
<code><a href="posterior.html#topic+subset_draws">subset_draws</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Setting up dummy sampling for fast execution of example
## Please use 4 chains and 100x more warmup &amp; iter in practice
.user_mc_options &lt;- options(
  OncoBayes2.MC.warmup = 10, OncoBayes2.MC.iter = 20, OncoBayes2.MC.chains = 1,
  OncoBayes2.MC.save_warmup = FALSE
)

# fit an example model. See documentation for "combo2" example
example_model("combo2")

post &lt;- as_draws(blrmfit)

## Recover user set sampling defaults
options(.user_mc_options)

</code></pre>

<hr>
<h2 id='drug_info_combo2'>Dataset: drug information for a dual-agent combination study</h2><span id='topic+drug_info_combo2'></span>

<h3>Description</h3>

<p>Data set describing the two drugs involved in the example for a
dual-agent combination study.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>drug_info_combo2
</code></pre>


<h3>Format</h3>

<p>A tibble with 2 rows (one per durg) and 4 columns:
</p>

<dl>
<dt>drug_name</dt><dd><p>name of drug</p>
</dd>
<dt>dose_ref</dt><dd><p>reference dose</p>
</dd>
<dt>dose_unit</dt><dd><p>units used for drug amounts</p>
</dd>
<dt>reference_p_dlt</dt><dd><p>a-priori probability for a DLT at the reference dose</p>
</dd>
</dl>



<h3>See Also</h3>

<p>Other blrm_trial combo2 example: 
<code><a href="#topic+blrm_trial">blrm_trial</a>()</code>,
<code><a href="#topic+dose_info_combo2">dose_info_combo2</a></code>,
<code><a href="#topic+example-combo2_trial">example-combo2_trial</a></code>
</p>

<hr>
<h2 id='example_model'>Runs example models</h2><span id='topic+example_model'></span>

<h3>Description</h3>

<p>Runs example models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>example_model(topic, envir = parent.frame(), silent = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="example_model_+3A_topic">topic</code></td>
<td>
<p>example to run</p>
</td></tr>
<tr><td><code id="example_model_+3A_envir">envir</code></td>
<td>
<p>environment which the example is loaded into. Defaults
to the caller environment.</p>
</td></tr>
<tr><td><code id="example_model_+3A_silent">silent</code></td>
<td>
<p>logical controlling if execution is run silently
(defaults to <code>FALSE</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>When topic is not specified a list of all possible topics
is return. Whenever a valid topic is specified, the function
inserts the example into the environment given and returns
(invisibly) the updated environment.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Setting up dummy sampling for fast execution of example
## Please use 4 chains and 100x more warmup &amp; iter in practice
.user_mc_options &lt;- options(
  OncoBayes2.MC.warmup = 10, OncoBayes2.MC.iter = 20, OncoBayes2.MC.chains = 1,
  OncoBayes2.MC.save_warmup = FALSE
)


## get a list of available examples
example_model()

## run 3 component example
example_model("combo3")

## Recover user set sampling defaults
options(.user_mc_options)

</code></pre>

<hr>
<h2 id='example-combo2'>Two-drug combination example</h2><span id='topic+example-combo2'></span>

<h3>Description</h3>

<p>Example using a combination of two experimental drugs.
</p>


<h3>Details</h3>

<p>The following example is described in the reference
Neuenschwander, B. et al (2016). The data are described
in the help page for <code>codata_combo2</code>. In the study
<code>trial_AB</code>, the risk of DLT was studied as a function of
dose for two drugs, drug A and drug B. Historical information
on the toxicity profiles of these two drugs was available from
single agent trials <code>trial_A</code> and <code>trial_B</code>. Another
study <code>IIT</code> was run concurrently to <code>trial_AB</code>, and
studies the same combination.
</p>
<p>The model described in Neuenschwander, et al (2016) is adapted as follows.
For groups <code class="reqn">j = 1,\ldots, 4</code> representing each of the four sources
of data mentioned above,
</p>
<p style="text-align: center;"><code class="reqn">\mbox{logit}\, \pi_{1j}(d_1) = \log\, \alpha_{1j} + \beta_{1j} \, \log\, \Bigl(\frac{d_1}{d_1^*}\Bigr),</code>
</p>

<p>and
</p>
<p style="text-align: center;"><code class="reqn">\mbox{logit}\, \pi_{2j}(d_2) = \log\, \alpha_{2j} + \beta_{2j} \, \log\, \Bigl(\frac{d_2}{d_2^*}\Bigr),</code>
</p>

<p>are logistic regressions for the single-agent toxicity of drugs A and B,
respectively, when administered in group <code class="reqn">j</code>. Conditional on the
regression parameters
<code class="reqn">\boldsymbol\theta_{1j} = (\log \, \alpha_{1j}, \log \, \beta_{1j})</code> and
<code class="reqn">\boldsymbol\theta_{2j} = (\log \, \alpha_{2j}, \log \, \beta_{2j})</code>,
the toxicity <code class="reqn">\pi_{j}(d_1, d_2)</code> for
the combination is modeled as the &quot;no-interaction&quot; DLT rate,
</p>
<p style="text-align: center;"><code class="reqn">\tilde\pi_{j}(d_1, d_2) = 1 - (1-\pi_{1j}(d_1) )(1- \pi_{2j}(d_2))</code>
</p>

<p>with a single interaction term added on the log odds scale,
</p>
<p style="text-align: center;"><code class="reqn">\mbox{logit} \, \pi_{j}(d_1, d_2) = \mbox{logit} \, \tilde\pi_{j}(d_1, d_2) + \eta_j \frac{d_1}{d_1^*}\frac{d_2}{d_2^*}.</code>
</p>

<p>A hierarchical model across the four groups <code class="reqn">j</code> allows
dose-toxicity information to be shared through common hyperparameters.
</p>
<p>For the component parameters <code class="reqn">\boldsymbol\theta_{ij}</code>,
</p>
<p style="text-align: center;"><code class="reqn">\boldsymbol\theta_{ij} \sim \mbox{BVN}(\boldsymbol \mu_i, \boldsymbol\Sigma_i).</code>
</p>

<p>For the mean, a further prior is specified as
</p>
<p style="text-align: center;"><code class="reqn">\boldsymbol\mu_i = (\mu_{\alpha i}, \mu_{\beta i}) \sim \mbox{BVN}(\boldsymbol m_i, \boldsymbol S_i),</code>
</p>

<p>while in the manuscript the prior <code class="reqn">\boldsymbol m_i = (\mbox{logit}\, 0.1, \log 1)</code> and
<code class="reqn">\boldsymbol S_i  = \mbox{diag}(3.33^2, 1^2)</code> for each <code class="reqn">i = 1,2</code> is
used, we deviate here and use instead <code class="reqn">\boldsymbol m_i = (\mbox{logit}\, 0.2, \log 1)</code> and
<code class="reqn">\boldsymbol S_i  = \mbox{diag}(2^2, 1^2)</code>.
For the standard deviations and correlation parameters in the covariance matrix,
</p>
<p style="text-align: center;"><code class="reqn">\boldsymbol\Sigma_i = \left( \begin{array}{cc}
\tau^2_{\alpha i} &amp; \rho_i \tau_{\alpha i} \tau_{\beta i}\\
\rho_i \tau_{\alpha i} \tau_{\beta i} &amp; \tau^2_{\beta i}
\end{array} \right), </code>
</p>

<p>the specified priors are
<code class="reqn">\tau_{\alpha i} \sim \mbox{Log-Normal}(\log\, 0.25, ((\log 4) / 1.96)^2)</code>,
</p>
<p><code class="reqn">\tau_{\beta i} \sim \mbox{Log-Normal}(\log\, 0.125, ((\log 4) / 1.96)^2)</code>,
and <code class="reqn">\rho_i \sim \mbox{U}(-1,1)</code> for <code class="reqn">i = 1,2</code>.
</p>
<p>For the interaction parameters <code class="reqn">\eta_j</code> in each group, the hierarchical
model has
</p>
<p style="text-align: center;"><code class="reqn">\eta_j \sim \mbox{N}(\mu_\eta, \tau^2_\eta),</code>
</p>

<p>for <code class="reqn">j = 1,\ldots, 4</code>, with <code class="reqn">\mu_\eta \sim \mbox{N}(0, 1.121^2)</code>
and <code class="reqn">\tau_\eta \sim \mbox{Log-Normal}(\log\, 0.125, ((\log 4) / 1.96)^2).</code>
</p>
<p>Below is the syntax for specifying this fully exchangeable model in
<code>blrm_exnex</code>.
</p>


<h3>References</h3>

<p>Neuenschwander, B., Roychoudhury, S., &amp; Schmidli, H.
(2016). On the use of co-data in clinical trials. <em>Statistics in
Biopharmaceutical Research</em>, 8(3), 345-354.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Setting up dummy sampling for fast execution of example
## Please use 4 chains and 100x more warmup &amp; iter in practice
.user_mc_options &lt;- options(
  OncoBayes2.MC.warmup = 10, OncoBayes2.MC.iter = 20, OncoBayes2.MC.chains = 1,
  OncoBayes2.MC.save_warmup = FALSE
)

dref &lt;- c(6, 960)

num_comp   &lt;- 2 # two investigational drugs
num_inter  &lt;- 1 # one drug-drug interaction needs to be modeled
num_groups &lt;- nlevels(codata_combo2$group_id) # no stratification needed
num_strata &lt;- 1 # no stratification needed

blrmfit &lt;- blrm_exnex(
  cbind(num_toxicities, num_patients - num_toxicities) ~
    1 + I(log(drug_A / dref[1])) |
      1 + I(log(drug_B / dref[2])) |
      0 + I(drug_A / dref[1] * drug_B / dref[2]) |
      group_id,
  data = codata_combo2,
  prior_EX_mu_comp  = list(mixmvnorm(c(1, logit(0.2), 0, diag(c(2^2, 1)))),
                           mixmvnorm(c(1, logit(0.2), 0, diag(c(2^2, 1))))),
  prior_EX_tau_comp = list(mixmvnorm(c(1,
                                       log(0.250), log(0.125),
                                       diag(c(log(4)/1.96, log(4)/1.96)^2))),
                           mixmvnorm(c(1,
                                       log(0.250), log(0.125),
                                       diag(c(log(4)/1.96, log(4)/1.96)^2)))),
  prior_EX_mu_inter = mixmvnorm(c(1, 0, 1.121^2)),
  prior_EX_tau_inter = mixmvnorm(c(1, log(0.125), (log(4) / 1.96)^2)),
  prior_is_EXNEX_comp = rep(FALSE, num_comp),
  prior_is_EXNEX_inter = rep(FALSE, num_inter),
  prior_EX_prob_comp = matrix(1, nrow = num_groups, ncol = num_comp),
  prior_EX_prob_inter = matrix(1, nrow = num_groups, ncol = num_inter),
  prior_tau_dist = 1
)
## Recover user set sampling defaults
options(.user_mc_options)

</code></pre>

<hr>
<h2 id='example-combo2_trial'>Two-drug combination example using BLRM Trial</h2><span id='topic+example-combo2_trial'></span>

<h3>Description</h3>

<p>Example using <code><a href="#topic+blrm_trial">blrm_trial</a></code> to
guide the built-in two-drug combination study example.
</p>


<h3>Details</h3>

<p><code><a href="#topic+blrm_trial">blrm_trial</a></code> is used to collect
and store all relevant design information for the example. Subsequent
use of the <code><a href="#topic+update.blrm_trial">update.blrm_trial</a></code> command
allows convenient model fitting via
<code><a href="#topic+blrm_exnex">blrm_exnex</a></code>. The
<code><a href="#topic+summary.blrm_trial">summary.blrm_trial</a></code> method allows
exploration of the design and modeling results.
</p>
<p>To run this example, use <code>example_model("combo2_trial")</code>. See
<code><a href="#topic+example_model">example_model</a></code>.
</p>


<h3>See Also</h3>

<p>Other blrm_trial combo2 example: 
<code><a href="#topic+blrm_trial">blrm_trial</a>()</code>,
<code><a href="#topic+dose_info_combo2">dose_info_combo2</a></code>,
<code><a href="#topic+drug_info_combo2">drug_info_combo2</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Setting up dummy sampling for fast execution of example
## Please use 4 chains and 100x more warmup &amp; iter in practice
.user_mc_options &lt;- options(
  OncoBayes2.MC.warmup = 10, OncoBayes2.MC.iter = 20, OncoBayes2.MC.chains = 1,
  OncoBayes2.MC.save_warmup = FALSE
)

library(tibble)
library(dplyr)
library(tidyr)

# Combo2 example using blrm_trial functionality

# construct initial blrm_trial object from built-in example datasets
combo2_trial_setup &lt;- blrm_trial(
  data = hist_combo2,
  dose_info = dose_info_combo2,
  drug_info = drug_info_combo2,
  simplified_prior = FALSE
)

# summary of dimensionality of data structures
dims &lt;- summary(combo2_trial_setup, "dimensionality")

# Fit the initial model with the historical data and fully specified prior


combo2_trial_start &lt;- update(
   combo2_trial_setup,
   ## bivariate normal prior for drug A and drug B of intercept and
   ## log-slope
   prior_EX_mu_comp =
     replicate(2,
               mixmvnorm(c(1,
                           logit(0.2), 0,
                           diag(c(2^2, 1))))
             , FALSE),
   prior_EX_tau_comp =
     replicate(2,
               mixmvnorm(c(1,
                           log(0.25), log(0.125),
                           diag(c(log(4)/1.96, log(4)/1.96)^2)))
             , FALSE),
   prior_EX_mu_inter = mixmvnorm(c(1, 0, 1.121^2)),
   prior_EX_tau_inter = mixmvnorm(c(1, log(0.125), (log(4) / 1.96)^2)),
   prior_is_EXNEX_comp = c(FALSE, FALSE),
   prior_is_EXNEX_inter = FALSE,
   prior_EX_prob_comp = matrix(1,
     nrow = dims$num_groups,
     ncol = 2
   ),
   prior_EX_prob_inter = matrix(1,
     nrow = nlevels(dose_info_combo2$group_id),
     ncol = 1
   ),
   prior_tau_dist = 1
 )

# print summary of prior specification
prior_summary(combo2_trial_start)

# summarize inference at observed dose levels
summary(combo2_trial_start, "data_prediction")

# summarize inference at specified dose levels
summary(combo2_trial_start, "dose_prediction")


# Update again with new data

# using update() with data argument supplied
# dem &lt;- update(combo2_trial_start, data = codata_combo2)

# alternate way using update() with add_data argument for
# new observations only (those collected after the trial
# design stage).
new_data &lt;- filter(codata_combo2, cohort_time &gt; 0)

combo2_trial &lt;- update(combo2_trial_start, add_data = new_data)

summary(combo2_trial, "data") # cohort_time is tracked
summary(combo2_trial, "data_prediction")
summary(combo2_trial, "dose_prediction")

rm(dims, new_data)

## Recover user set sampling defaults
options(.user_mc_options)

</code></pre>

<hr>
<h2 id='example-combo3'>Three-drug combination example</h2><span id='topic+example-combo3'></span>

<h3>Description</h3>

<p>Example using a combination of two experimental drugs, with EXNEX
and differential discounting.
</p>


<h3>Details</h3>

<p>This dataset involves a hypothetical dose-escalation study of combination
therapy with three treatment components. From two previous studies
<code>HistAgent1</code> and <code>HistAgent2</code>, historical data is available on each
of the treatments as single-agents, as well as two of the two-way
combinations. However, due to a difference in treatment schedule between the
<code>Combo</code> study and the historical studies, a stratification (through <code>stratum_id</code>)
is made between the groups to allow differential discounting of the
alternate-schedule data. The association is as below.
</p>

<table>
<tr>
 <td style="text-align: center;">
group_id (j):  </td><td style="text-align: center;"> stratum_id (s_j): </td>
</tr>
<tr>
 <td style="text-align: center;">
Combo (1)      </td><td style="text-align: center;"> BID (1)         </td>
</tr>
<tr>
 <td style="text-align: center;">
HistAgent1 (2) </td><td style="text-align: center;"> QD (2)          </td>
</tr>
<tr>
 <td style="text-align: center;">
HistAgent2 (3) </td><td style="text-align: center;"> QD (2)
</td>
</tr>

</table>

<p>For additional robustness, EXNEX priors are used for all
group-level treatment components while not for the interaction
parameters. This is to limit the amount of borrowing in case of
significant heterogeneity across groups.
</p>
<p>The complete model is as follows. As a function of doses <code class="reqn">d_1,d_2,d_3</code>, the
DLT rate in group <code class="reqn">j</code> is, for <code class="reqn">j = 1,\ldots,3</code>,
</p>
<p style="text-align: center;"><code class="reqn">\mbox{logit}\, \pi_j(d_1,d_2,d_3) = \mbox{logit}\Bigl( 1 - \prod_{i=1}^3 (1-\pi_{ij}(d_i))\Bigr) + \eta_{j}^{(12)}\frac{d_1}{d_1^*}\frac{d_2}{d_2^*} + \eta_{j}^{(13)}\frac{d_1}{d_1^*}\frac{d_3}{d_3^*} + \eta_{j}^{(23)}\frac{d_2}{d_2^*}\frac{d_3}{d_3^*} + \eta_{j}^{(123)}\frac{d_1}{d_1^*}\frac{d_2}{d_2^*}\frac{d_3}{d_3^*}.</code>
</p>

<p>In group <code class="reqn">j</code> each treatment component <code class="reqn">i</code> toxicity is modeled with
logistic regression,
</p>
<p style="text-align: center;"><code class="reqn">\mbox{logit}\, \pi_{ij}(d_i) = \log\, \alpha_{ij} + \beta_{ij} \, \log\, \Bigl(\frac{d_i}{d_i^*}\Bigr).</code>
</p>

<p>The intercept and log-slope parameters <code class="reqn">\boldsymbol\theta_{ij} = (\log\, \alpha_{ij}, \log\, \beta_{ij})</code>
are are given an EXNEX prior
</p>
<p style="text-align: center;"><code class="reqn">\boldsymbol\theta_{ij} \sim p_{ij} \mbox{BVN}(\boldsymbol\mu_i, \boldsymbol\Sigma_{ij}) + (1-p_{ij}) \mbox{BVN}(\boldsymbol m_{ij}, \boldsymbol S_{ij}),</code>
</p>

<p>where the exchangeability weights are all <code class="reqn">p_{ij} = 0.9</code>.
The NEX parameters are set to <code class="reqn">\boldsymbol m_{ij} = (\mbox{logit}(1/3), \log\, 1)</code>,
<code class="reqn">\boldsymbol S_{ij} = \mbox{diag}(2^2, 1^2)</code> for all components <code class="reqn">i=1,2,3</code> and
groups <code class="reqn">j = 1,2,3</code>, and the EX parameters are modeled hierarchically. The
mean of the exchangeable part has the distribution
</p>
<p style="text-align: center;"><code class="reqn">\boldsymbol\mu_i = (\mu_{\alpha i}, \mu_{\beta i}) \sim \mbox{BVN}(\boldsymbol m_i, \boldsymbol S_i),</code>
</p>

<p>with <code class="reqn">\boldsymbol m_i = (\mbox{logit}(1/3), \log 1)</code> and
<code class="reqn">\boldsymbol S_i  = \mbox{diag}(2^2, 1^2)</code> for each component <code class="reqn">i = 1,2,3</code>.
For differentially discounting data from each schedule (QD and BID), the
covariance parameters for the exchangeable part
</p>
<p style="text-align: center;"><code class="reqn">\Sigma_{ij} = \left( \begin{array}{cc}
\tau^2_{\alpha s_j i} &amp; \rho_i \tau_{\alpha s_j i} \tau_{\beta s_j i}\\
\rho_i \tau_{\alpha s_j i} \tau_{\beta s_j i} &amp; \tau^2_{\beta s_j i}
\end{array} \right).</code>
</p>

<p>are allowed to vary across groups <code class="reqn">j</code> depending on their mapping
to strata <code class="reqn">s(j)</code> as described above. For stratum <code class="reqn">s=1</code> (<code>BID</code>,
which contains only the group <code class="reqn">j = 1</code> (<code>Combo</code>)), the standard
deviations are modeled as
</p>
<p style="text-align: center;"><code class="reqn">\tau_{\alpha 1 i} \sim \mbox{Log-Normal}(\log\,0.25, (\log 4 / 1.96)^2)</code>
</p>

<p style="text-align: center;"><code class="reqn">\tau_{\beta 1 i} \sim \mbox{Log-Normal}(\log\,0.125, (\log 4 / 1.96)^2).</code>
</p>

<p>Whereas in stratum <code class="reqn">s=2</code> (<code>QD</code>, which contains the historical groups
<code class="reqn">j=2,3</code> (<code>HistData1</code>, <code>HistData2</code>)), the standard deviations are
</p>
<p style="text-align: center;"><code class="reqn">\tau_{\alpha 2 i} \sim \mbox{Log-Normal}(\log\,0.5, (\log 4 / 1.96)^2)</code>
</p>

<p style="text-align: center;"><code class="reqn">\tau_{\beta 2 i} \sim \mbox{Log-Normal}(\log\,0.25, (\log 4 / 1.96)^2).</code>
</p>

<p>For all interaction parameters <code class="reqn">\eta_{j}^{(12)}</code>, <code class="reqn">\eta_{j}^{(13)}</code>,
<code class="reqn">\eta_{j}^{(23)}</code>, and <code class="reqn">\eta_{j}^{(123)}</code> (<code class="reqn">j = 1,2,3</code>), the following
prior is assumed:
</p>
<p style="text-align: center;"><code class="reqn">\eta_{j}^{(\cdot)} \sim  \mbox{N}(\mu_{\eta}^{(\cdot)},{\tau_{\eta s_j}^{(\cdot)}}^2).</code>
</p>

<p>The exchangeability weights are <code class="reqn">p_{\eta j}^{(\cdot)} = 0.9</code> for all
parameters with EXNEX. Here, for each <code class="reqn">\mu_{\eta}^{(12)}</code>, <code class="reqn">\mu_{\eta}^{(13)}</code>,
<code class="reqn">\mu_{\eta}^{(23)}</code>, and <code class="reqn">\mu_{\eta}^{(123)}</code>, we take
</p>
<p style="text-align: center;"><code class="reqn">\mu_{\eta}^{(\cdot)} \sim \mbox{N}(0, 1/2),</code>
</p>

<p>and for each <code class="reqn">\tau_{\eta s}^{(12)}</code>, <code class="reqn">\tau_{\eta s}^{(13)}</code>,
<code class="reqn">\tau_{\eta s}^{(23)}</code>, and <code class="reqn">\tau_{\eta s}^{(123)}</code>,
</p>
<p style="text-align: center;"><code class="reqn">\tau_{\eta s}^{(\cdot)} \sim \mbox{Log-Normal}(\log(0.25), (\log 2 / 1.96)^2),</code>
</p>

<p>for both strata <code class="reqn">s = 1,2</code>.
</p>
<p>Below is the syntax for specifying this model in <code>blrm_exnex</code>.
</p>


<h3>References</h3>

<p>Neuenschwander, B., Roychoudhury, S., &amp; Schmidli, H.
(2016). On the use of co-data in clinical trials. <em>Statistics in
Biopharmaceutical Research</em>, 8(3), 345-354.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Setting up dummy sampling for fast execution of example
## Please use 4 chains and 100x more warmup &amp; iter in practice
.user_mc_options &lt;- options(
  OncoBayes2.MC.warmup = 10, OncoBayes2.MC.iter = 20, OncoBayes2.MC.chains = 1,
  OncoBayes2.MC.save_warmup = FALSE
)

## example combo3

library(abind)

dref &lt;- c(500, 500, 1000)
num_comp &lt;- 3
num_inter &lt;- choose(3, 2) + 1
num_strata &lt;- nlevels(hist_combo3$stratum_id)
num_groups &lt;- nlevels(hist_combo3$group_id)

blrmfit &lt;- blrm_exnex(
  cbind(num_toxicities, num_patients - num_toxicities) ~
    1 + I(log(drug_A / dref[1])) |
      1 + I(log(drug_B / dref[2])) |
      1 + I(log(drug_C / dref[3])) |
      0
      + I(drug_A / dref[1] * drug_B / dref[2])
        + I(drug_A / dref[1] * drug_C / dref[3])
        + I(drug_B / dref[2] * drug_C / dref[3])
        + I(drug_A / dref[1] * drug_B / dref[2] * drug_C / dref[3]) |
      stratum_id / group_id,
  data = hist_combo3,
  prior_EX_mu_comp = replicate(num_comp, mixmvnorm(c(1, logit(1/3), 0, diag(c(2^2, 1)))), FALSE),
  prior_EX_tau_comp = list(replicate(num_comp,
                                     mixmvnorm(c(1, log(c(0.25, 0.125)),
                                               diag(c(log(4)/1.96, log(4)/1.96)^2))), FALSE),
                           replicate(num_comp,
                                     mixmvnorm(c(1, log(2 * c(0.25, 0.125)),
                                               diag(c(log(4)/1.96, log(4)/1.96)^2))), FALSE)),
  prior_EX_mu_inter = mixmvnorm(c(1, rep.int(0, num_inter),
                                     diag((rep.int(sqrt(2) / 2, num_inter))^2))),
  prior_EX_tau_inter = replicate(num_strata,
                                 mixmvnorm(c(1, rep.int(log(0.25), num_inter),
                                             diag((rep.int(log(2) / 1.96, num_inter))^2))), FALSE),
  prior_EX_prob_comp = matrix(0.9, nrow = num_groups, ncol = num_comp),
  prior_EX_prob_inter = matrix(1.0, nrow = num_groups, ncol = num_inter),
  prior_is_EXNEX_comp = rep(TRUE, num_comp),
  prior_is_EXNEX_inter = rep(FALSE, num_inter),
  prior_tau_dist = 1,
  prior_PD = FALSE
)
## Recover user set sampling defaults
options(.user_mc_options)

</code></pre>

<hr>
<h2 id='example-single-agent'>Single Agent Example</h2><span id='topic+example-single-agent'></span>

<h3>Description</h3>

<p>Example using a single experimental drug.
</p>


<h3>Details</h3>

<p>The single agent example is described in the reference
Neuenschwander, B. et al (2008). The data are described
in the help page for <code>hist_SA</code>. In this case, the data
come from only one study, with the treatment being only single
agent. Hence the model specified does not involve a hierarchical
prior for the intercept and log-slope parameters. The model
described in Neuenschwander, et al (2008) is adapted as follows:
</p>
<p style="text-align: center;"><code class="reqn">\mbox{logit}\, \pi(d) = \log\, \alpha + \beta \, \log\, \Bigl(\frac{d}{d^*}\Bigr),</code>
</p>

<p>where <code class="reqn">d^* = 250</code>, and the prior for
<code class="reqn">\boldsymbol\theta = (\log\, \alpha, \log\, \beta)</code> is
</p>
<p style="text-align: center;"><code class="reqn">\boldsymbol\theta \sim \mbox{N}(\boldsymbol m, \boldsymbol S),</code>
</p>

<p>and <code class="reqn">\boldsymbol m = (\mbox{logit}\, 0.5, \log\, 1)</code> and
<code class="reqn">\boldsymbol S = \mbox{diag}(2^2, 1^2)</code> are constants.
</p>
<p>The above model is non-hierarchical. To disable the hierarchical
model structure of the <code>blrm_exnex</code> framework, the user can
specify the option <code>prior_tau_dist=NULL</code>. This will internally
set all the heterogeniety parameters (<code class="reqn">\tau^2_\alpha</code> and
<code class="reqn">\tau^2_\beta</code>) to zero.
</p>


<h3>References</h3>

<p>Neuenschwander, B., Branson, M., &amp; Gsponer, T. (2008).
Critical aspects of the Bayesian approach to phase I cancer trials.
<em>Statistics in medicine</em>, 27(13), 2420-2439.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Setting up dummy sampling for fast execution of example
## Please use 4 chains and 100x more warmup &amp; iter in practice
.user_mc_options &lt;- options(
  OncoBayes2.MC.warmup = 10, OncoBayes2.MC.iter = 20, OncoBayes2.MC.chains = 1,
  OncoBayes2.MC.save_warmup = FALSE
)

## Example from Neuenschwander, B., et al. (2009). Stats in Medicine

dref &lt;- 50

## Since there is no prior information the hierarchical model
## is not used in this example by setting tau to (almost) 0.
blrmfit &lt;- blrm_exnex(
  cbind(num_toxicities, num_patients - num_toxicities) ~
      1 + log(drug_A / dref) |
      0 |
      group_id,
  data = hist_SA,
  prior_EX_mu_comp = mixmvnorm(c(1, logit(1 / 2), log(1), diag(c(2^2, 1)))),
  ## Setting prior_tau_dist=NULL disables the hierarchical prior which is
  ## not required in this example as we analyze a single trial.
  prior_tau_dist = NULL,
  prior_PD = FALSE
)
## Recover user set sampling defaults
options(.user_mc_options)

</code></pre>

<hr>
<h2 id='hist_combo2'>Dataset: historical data on two single-agents to inform a combination study</h2><span id='topic+hist_combo2'></span>

<h3>Description</h3>

<p>One of two datasets from the application described in Neuenschwander et al
(2016). The risk of DLT is to be studied as a function of dose for two drugs,
drug A and drug B. Historical information on the toxicity profiles of these
two drugs is available from single agent trials <code>trial_A</code> and <code>trial_B</code>.
A second dataset <code>codata_combo2</code> is available from this application,
which includes additional dose-toxicity data from <code>trial_AB</code> and <code>IIT</code> of the
combination of Drugs A and B.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hist_combo2
</code></pre>


<h3>Format</h3>

<p>A tibble with 11 rows and 5 variables:
</p>

<dl>
<dt>group_id</dt><dd><p>study</p>
</dd>
<dt>drug_A</dt><dd><p>dose of Drug A</p>
</dd>
<dt>drug_B</dt><dd><p>dose of Drug B</p>
</dd>
<dt>num_patients</dt><dd><p>number of patients</p>
</dd>
<dt>num_toxicities</dt><dd><p>number of DLTs</p>
</dd>
<dt>cohort_time</dt><dd><p>cohort number of patients</p>
</dd>
</dl>



<h3>References</h3>

<p>Neuenschwander, B., Roychoudhury, S., &amp; Schmidli, H.
(2016). On the use of co-data in clinical trials. <em>Statistics in
Biopharmaceutical Research</em>, 8(3), 345-354.
</p>

<hr>
<h2 id='hist_combo3'>Dataset: historical and concurrent data on a three-way combination</h2><span id='topic+hist_combo3'></span>

<h3>Description</h3>

<p>This dataset involves a hypothetical dose-escalation study of combination
therapy with three treatment components. From two previous studies
<code>HistAgent1</code> and <code>HistAgent2</code>, historical data is available on each
of the treatments as single-agents, as well as two of the two-way
combinations. However, due to a difference in treatment schedule between the
<code>Combo</code> study and the historical studies, a stratification (through <code>stratum_id</code>)
is made between the groups to allow differential discounting of the
alternate-dose data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hist_combo3
</code></pre>


<h3>Format</h3>

<p>A data frame with 18 rows and 7 variables:
</p>

<dl>
<dt>group_id</dt><dd><p>study</p>
</dd>
<dt>drug_A</dt><dd><p>dose of Drug A</p>
</dd>
<dt>drug_B</dt><dd><p>dose of Drug B</p>
</dd>
<dt>drug_C</dt><dd><p>dose of Drug C</p>
</dd>
<dt>num_patients</dt><dd><p>number of patients</p>
</dd>
<dt>num_toxicities</dt><dd><p>number of DLTs</p>
</dd>
<dt>stratum_id</dt><dd><p>stratum for <code>group_id</code>'s used for differential discounting</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>## Setting up dummy sampling for fast execution of example
## Please use 4 chains and 100x more warmup &amp; iter in practice
.user_mc_options &lt;- options(
  OncoBayes2.MC.warmup = 10, OncoBayes2.MC.iter = 20, OncoBayes2.MC.chains = 1,
  OncoBayes2.MC.save_warmup = FALSE
)

## example combo3

library(abind)

dref &lt;- c(500, 500, 1000)
num_comp &lt;- 3
num_inter &lt;- choose(3, 2) + 1
num_strata &lt;- nlevels(hist_combo3$stratum_id)
num_groups &lt;- nlevels(hist_combo3$group_id)

blrmfit &lt;- blrm_exnex(
  cbind(num_toxicities, num_patients - num_toxicities) ~
    1 + I(log(drug_A / dref[1])) |
      1 + I(log(drug_B / dref[2])) |
      1 + I(log(drug_C / dref[3])) |
      0
      + I(drug_A / dref[1] * drug_B / dref[2])
        + I(drug_A / dref[1] * drug_C / dref[3])
        + I(drug_B / dref[2] * drug_C / dref[3])
        + I(drug_A / dref[1] * drug_B / dref[2] * drug_C / dref[3]) |
      stratum_id / group_id,
  data = hist_combo3,
  prior_EX_mu_comp = replicate(num_comp, mixmvnorm(c(1, logit(1/3), 0, diag(c(2^2, 1)))), FALSE),
  prior_EX_tau_comp = list(replicate(num_comp,
                                     mixmvnorm(c(1, log(c(0.25, 0.125)),
                                               diag(c(log(4)/1.96, log(4)/1.96)^2))), FALSE),
                           replicate(num_comp,
                                     mixmvnorm(c(1, log(2 * c(0.25, 0.125)),
                                               diag(c(log(4)/1.96, log(4)/1.96)^2))), FALSE)),
  prior_EX_mu_inter = mixmvnorm(c(1, rep.int(0, num_inter),
                                     diag((rep.int(sqrt(2) / 2, num_inter))^2))),
  prior_EX_tau_inter = replicate(num_strata,
                                 mixmvnorm(c(1, rep.int(log(0.25), num_inter),
                                             diag((rep.int(log(2) / 1.96, num_inter))^2))), FALSE),
  prior_EX_prob_comp = matrix(0.9, nrow = num_groups, ncol = num_comp),
  prior_EX_prob_inter = matrix(1.0, nrow = num_groups, ncol = num_inter),
  prior_is_EXNEX_comp = rep(TRUE, num_comp),
  prior_is_EXNEX_inter = rep(FALSE, num_inter),
  prior_tau_dist = 1,
  prior_PD = FALSE
)
## Recover user set sampling defaults
options(.user_mc_options)

</code></pre>

<hr>
<h2 id='hist_SA'>Single-agent example</h2><span id='topic+hist_SA'></span>

<h3>Description</h3>

<p>Example data from the application in Neuenschwander, et. al. 2008, from
an &quot;open-label, multicenter, non-comparative, dose-escalation cancer trial to
characterize the safety, tolerability, and pharmacokinetic profile of a drug
and to determine its MTD.&quot;
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hist_SA
</code></pre>


<h3>Format</h3>

<p>A data frame with 5 rows and 4 variables:
</p>

<dl>
<dt>group_id</dt><dd><p>study</p>
</dd>
<dt>drug_A</dt><dd><p>dose</p>
</dd>
<dt>num_patients</dt><dd><p>number of patients</p>
</dd>
<dt>num_toxicities</dt><dd><p>number of events</p>
</dd>
</dl>



<h3>References</h3>

<p>Neuenschwander, B., Branson, M., &amp; Gsponer, T. (2008).
Critical aspects of the Bayesian approach to phase I cancer trials.
<em>Statistics in medicine</em>, 27(13), 2420-2439.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Setting up dummy sampling for fast execution of example
## Please use 4 chains and 100x more warmup &amp; iter in practice
.user_mc_options &lt;- options(
  OncoBayes2.MC.warmup = 10, OncoBayes2.MC.iter = 20, OncoBayes2.MC.chains = 1,
  OncoBayes2.MC.save_warmup = FALSE
)

## Example from Neuenschwander, B., et al. (2009). Stats in Medicine

dref &lt;- 50

## Since there is no prior information the hierarchical model
## is not used in this example by setting tau to (almost) 0.
blrmfit &lt;- blrm_exnex(
  cbind(num_toxicities, num_patients - num_toxicities) ~
      1 + log(drug_A / dref) |
      0 |
      group_id,
  data = hist_SA,
  prior_EX_mu_comp = mixmvnorm(c(1, logit(1 / 2), log(1), diag(c(2^2, 1)))),
  ## Setting prior_tau_dist=NULL disables the hierarchical prior which is
  ## not required in this example as we analyze a single trial.
  prior_tau_dist = NULL,
  prior_PD = FALSE
)
## Recover user set sampling defaults
options(.user_mc_options)

</code></pre>

<hr>
<h2 id='lodds'>Logit (log-odds) and inverse-logit function.</h2><span id='topic+lodds'></span><span id='topic+logit'></span><span id='topic+inv_logit'></span>

<h3>Description</h3>

<p>Calculates the logit (log-odds) and inverse-logit.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>logit(mu)

inv_logit(eta)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lodds_+3A_mu">mu</code></td>
<td>
<p>A numeric object with probabilies, with values in the in
the range <code class="reqn">[0,1]</code>. Missing values (NAs) are allowed.</p>
</td></tr>
<tr><td><code id="lodds_+3A_eta">eta</code></td>
<td>
<p>A numeric object with log-odds values, with values in
the range <code class="reqn">[-Inf,Inf]</code>. Missing values (NAs) are allowed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Values of mu equal to 0 or 1 will return -Inf or Inf
respectively.
</p>


<h3>Value</h3>

<p>A numeric object of the same type as mu and eta containing
the logits or inverse logit of the input values.  The logit and
inverse transformation equates to
</p>
<p style="text-align: center;"><code class="reqn">\mbox{logit}(\mu) = \log(\mu/(1-\mu))</code>
</p>

<p style="text-align: center;"><code class="reqn">\mbox{logit}^{-1}(\eta)= \exp(\eta)/(1 + \exp(\eta)).</code>
</p>



<h3>Examples</h3>

<pre><code class='language-R'>logit(0.2)
inv_logit(-1.386)

</code></pre>

<hr>
<h2 id='log_inv_logit'>Numerically stable summation of log inv logit</h2><span id='topic+log_inv_logit'></span>

<h3>Description</h3>

<p>Numerically stable summation of log inv logit
</p>


<h3>Usage</h3>

<pre><code class='language-R'>log_inv_logit(mat)
</code></pre>

<hr>
<h2 id='log_mean_exp'>Numerically stable mean of logs</h2><span id='topic+log_mean_exp'></span>

<h3>Description</h3>

<p>Numerically stable mean of logs
</p>


<h3>Usage</h3>

<pre><code class='language-R'>log_mean_exp(x)
</code></pre>

<hr>
<h2 id='nsamples.blrmfit'>Return the number of posterior samples</h2><span id='topic+nsamples.blrmfit'></span><span id='topic+nsamples'></span>

<h3>Description</h3>

<p>Return the number of posterior samples
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'blrmfit'
nsamples(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nsamples.blrmfit_+3A_object">object</code></td>
<td>
<p>fitted model object</p>
</td></tr>
<tr><td><code id="nsamples.blrmfit_+3A_...">...</code></td>
<td>
<p>not used in this function</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Setting up dummy sampling for fast execution of example
## Please use 4 chains and 100x more warmup &amp; iter in practice
.user_mc_options &lt;- options(
  OncoBayes2.MC.warmup = 10, OncoBayes2.MC.iter = 20, OncoBayes2.MC.chains = 1,
  OncoBayes2.MC.save_warmup = FALSE
)


## run single-agent analysis which defines blrmfit model object
example_model("single_agent", silent = TRUE)

nsamples(blrmfit)

## Recover user set sampling defaults
options(.user_mc_options)

</code></pre>

<hr>
<h2 id='plot_blrm'>Plot a fitted model</h2><span id='topic+plot_blrm'></span><span id='topic+plot_toxicity_curve'></span><span id='topic+plot_toxicity_intervals'></span><span id='topic+plot_toxicity_intervals_stacked'></span><span id='topic+plot_toxicity_curve.blrmfit'></span><span id='topic+plot_toxicity_curve.blrm_trial'></span><span id='topic+plot_toxicity_intervals.blrmfit'></span><span id='topic+plot_toxicity_intervals.blrm_trial'></span><span id='topic+plot_toxicity_intervals_stacked.blrmfit'></span><span id='topic+plot_toxicity_intervals_stacked.blrm_trial'></span>

<h3>Description</h3>

<p><strong>Warning</strong>: these methods are at an experimental stage of development, and
may change with future releases.
</p>
<p>Plotting methods for <code>blrmfit</code> and <code>blrm_trial</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_toxicity_curve(object, ...)

plot_toxicity_intervals(object, ...)

plot_toxicity_intervals_stacked(object, ...)

## S3 method for class 'blrmfit'
plot_toxicity_curve(
  object,
  newdata,
  x,
  group,
  xlim,
  ylim,
  transform = TRUE,
  prob = 0.5,
  prob_outer = 0.95,
  size = 0.75,
  alpha = 1,
  facet_args = list(),
  hline_at = c(0.16, 0.33),
  grid_length = 100,
  ...
)

## S3 method for class 'blrm_trial'
plot_toxicity_curve(
  object,
  newdata,
  x,
  group,
  xlim,
  ylim,
  transform = TRUE,
  prob = 0.5,
  prob_outer = 0.95,
  size = 0.75,
  alpha = 1,
  facet_args = list(),
  hline_at,
  grid_length = 100,
  ewoc_shading = TRUE,
  ...
)

## S3 method for class 'blrmfit'
plot_toxicity_intervals(
  object,
  newdata,
  x,
  group,
  interval_prob = c(0, 0.16, 0.33, 1),
  interval_max_mass = c(NA, NA, 0.25),
  ewoc_colors = c("green", "red"),
  facet_args = list(),
  ...
)

## S3 method for class 'blrm_trial'
plot_toxicity_intervals(
  object,
  newdata,
  x,
  group,
  interval_prob,
  interval_max_mass,
  ewoc_colors = c("green", "red"),
  ...
)

## S3 method for class 'blrmfit'
plot_toxicity_intervals_stacked(
  object,
  newdata,
  x,
  group,
  xlim,
  ylim = c(0, 0.5),
  predictive = FALSE,
  transform = !predictive,
  interval_prob,
  grid_length = 100,
  facet_args = list(),
  ...
)

## S3 method for class 'blrm_trial'
plot_toxicity_intervals_stacked(
  object,
  newdata,
  x,
  group,
  xlim,
  ylim = c(0, 0.5),
  predictive = FALSE,
  transform = !predictive,
  interval_prob,
  grid_length = 100,
  ewoc_shading = TRUE,
  facet_args = list(),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_blrm_+3A_object">object</code></td>
<td>
<p>fitted model object</p>
</td></tr>
<tr><td><code id="plot_blrm_+3A_...">...</code></td>
<td>
<p>currently unused</p>
</td></tr>
<tr><td><code id="plot_blrm_+3A_newdata">newdata</code></td>
<td>
<p>optional data frame specifying for what to predict;
if missing, then the data of the input model <code>object</code> is
used. If <code>object</code> is a <code>blrmfit</code> object, <code>newdata</code> defaults to
the <code>data</code> argument. If <code>object</code> is a <code>blrm_trial</code>, it defaults
to <code>summary(object, "dose_info")</code>.</p>
</td></tr>
<tr><td><code id="plot_blrm_+3A_x">x</code></td>
<td>
<p>Character giving the parameter name to be mapped to the
x-axis.  This also supports 'tidy' parameter selection by
specifying <code>x = vars(...)</code>, where <code>...</code> is specified
the same way as in <code><a href="dplyr.html#topic+select">dplyr::select()</a></code>
and similar functions. Examples of using <code>x</code> in this way
can be found in the examples. For <code>blrm_trial</code> methods, it
defaults to the first entry in <code>summary(blrm_trial,
    "drug_info")$drug_name</code>.</p>
</td></tr>
<tr><td><code id="plot_blrm_+3A_group">group</code></td>
<td>
<p>Grouping variable(s) whose levels will be mapped to
different facets of the plot. <code>group</code> can be a character
vector, tidy parameter(s) of the form <code>group = vars(...)</code>,
or a formula to be passed directly to
<code><a href="ggplot2.html#topic+facet_wrap">ggplot2::facet_wrap()</a></code>. For
<code>blrm_trial</code> methods, it defaults to <code>group_id</code>, plus
all entries of <code>summary(blrm_trial,
    "drug_info")$drug_name</code> except the first, which is mapped to
<code>x</code>.</p>
</td></tr>
<tr><td><code id="plot_blrm_+3A_xlim">xlim</code></td>
<td>
<p>x-axis limits</p>
</td></tr>
<tr><td><code id="plot_blrm_+3A_ylim">ylim</code></td>
<td>
<p>y-axis limits on the probability scale</p>
</td></tr>
<tr><td><code id="plot_blrm_+3A_transform">transform</code></td>
<td>
<p>logical (defaults to <code>FALSE</code>) indicating if
the linear predictor on the logit link scale is transformed
with <code>inv_logit</code> to the 0-1 response scale.</p>
</td></tr>
<tr><td><code id="plot_blrm_+3A_prob">prob</code></td>
<td>
<p>central probability mass to report for the inner ribbon, i.e.
the quantiles <code>0.5-prob/2</code> and <code>0.5+prob/2</code> are displayed.</p>
</td></tr>
<tr><td><code id="plot_blrm_+3A_prob_outer">prob_outer</code></td>
<td>
<p>central probability mass to report for the outer ribbon, i.e.
the quantiles <code>0.5-prob/2</code> and <code>0.5+prob/2</code> are displayed.</p>
</td></tr>
<tr><td><code id="plot_blrm_+3A_alpha">alpha</code>, <code id="plot_blrm_+3A_size">size</code></td>
<td>
<p>Arguments passed to geoms. For this plot, <code>alpha</code> is
passed to <code><a href="ggplot2.html#topic+geom_ribbon">ggplot2::geom_ribbon()</a></code>, and <code>size</code> is passed to
<code><a href="ggplot2.html#topic+geom_line">ggplot2::geom_line()</a></code>.</p>
</td></tr>
<tr><td><code id="plot_blrm_+3A_facet_args">facet_args</code></td>
<td>
<p>A named list of arguments (other than <code>facets</code>) passed
to <code><a href="ggplot2.html#topic+facet_wrap">ggplot2::facet_wrap()</a></code>.</p>
</td></tr>
<tr><td><code id="plot_blrm_+3A_hline_at">hline_at</code></td>
<td>
<p>Location(s) of horizontal guide lines (passed to
<code><a href="bayesplot.html#topic+hline_at">bayesplot::hline_at()</a></code>).</p>
</td></tr>
<tr><td><code id="plot_blrm_+3A_grid_length">grid_length</code></td>
<td>
<p>Number of grid points within <code>xlim</code> for plotting.</p>
</td></tr>
<tr><td><code id="plot_blrm_+3A_ewoc_shading">ewoc_shading</code></td>
<td>
<p>logical indicates if doses violating EWOC should be
shaded in gray. Applies only to <code>blrm_trial</code> methods. Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="plot_blrm_+3A_interval_prob">interval_prob</code></td>
<td>
<p>defines the interval probabilities reported in
the standard outputs. Defaults to <code>c(0, 0.16, 0.33, 1)</code>,
when <code>predictive = FALSE</code> and/or <code>transform = TRUE</code>, or to intervals
giving 0, 1, or 2+ DLTs when <code>predictive = TRUE</code> and <code>transform = FALSE</code>.
For <code>blrm_trial</code> methods, this is taken from
<code>summary(blrm_trial, "interval_prob")</code> by default.</p>
</td></tr>
<tr><td><code id="plot_blrm_+3A_interval_max_mass">interval_max_mass</code></td>
<td>
<p>vector defining for each interval of
the <code>interval_prob</code> vector a maximal admissible
probability mass for a given dose level. Whenever the posterior
probability mass in a given interval exceeds the threshold,
then the Escalation With Overdose Control (EWOC) criterion is
considered to be not fulfilled. Dose levels not fulfilling
EWOC are ineligible for the next cohort of patients. The
default restricts the overdose probability to less than 0.25. For
<code>blrm_trial</code> methods, this is taken from
<code>summary(blrm_trial, "interval_max_mass")</code> by default.</p>
</td></tr>
<tr><td><code id="plot_blrm_+3A_ewoc_colors">ewoc_colors</code></td>
<td>
<p>Fill colors used for bars indicating EWOC OK or not.
Vector of two characters, each of which must correspond to
<code><a href="bayesplot.html#topic+bayesplot-package">bayesplot-package</a></code> color schemes
(see <code>?<a href="bayesplot.html#topic+color_scheme_get">bayesplot::color_scheme_get()</a></code>)</p>
</td></tr>
<tr><td><code id="plot_blrm_+3A_predictive">predictive</code></td>
<td>
<p>logical indicates if the posterior predictive is
being summarized. Defaults to <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>plot_toxicity_curve</code> plots continuous profiles of the dose-toxicity curve.
</p>
<p><code>plot_toxicity_intervals</code> plots the posterior probability mass in
subintervals of <code class="reqn">[0,1]</code>, at a discrete set of provisional doses.
</p>
<p><code>plot_toxicity_intervals_stacked</code> is similar to
<code>plot_toxicity_intervals</code>, but over a continuous range of doses.
</p>


<h3>Value</h3>

<p>A ggplot object that can be further
customized using the <code><a href="ggplot2.html#topic+ggplot2">ggplot2</a></code> package.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Setting up dummy sampling for fast execution of example
## Please use 4 chains and 100x more warmup &amp; iter in practice
.user_mc_options &lt;- options(
  OncoBayes2.MC.warmup = 10, OncoBayes2.MC.iter = 20, OncoBayes2.MC.chains = 1,
  OncoBayes2.MC.save_warmup = FALSE
)


example_model("combo2", silent = TRUE)

# Plot the dose-toxicity curve
plot_toxicity_curve(blrmfit,
  x = "drug_A",
  group = ~ group_id * drug_B,
  newdata = subset(dose_info_combo2, group_id == "trial_AB"),
  facet_args = list(ncol = 4)
)

# Plot posterior DLT-rate-interval probabilities at discrete dose levels
plot_toxicity_intervals(blrmfit,
  x = "drug_A",
  group = ~ group_id * drug_B,
  newdata = subset(dose_info_combo2, group_id == "trial_AB")
)

# Plot posterior DLT-rate-interval probabilities over continuous dose
plot_toxicity_intervals_stacked(blrmfit,
  x = "drug_A",
  group = ~ group_id * drug_B,
  newdata = subset(dose_info_combo2, group_id == "trial_AB")
)

# Plot predictive distribution probabilities over continuous dose
plot_toxicity_intervals_stacked(blrmfit,
  x = "drug_A",
  group = ~ group_id * drug_B,
  predictive = TRUE,
  interval_prob = c(-1, 0, 1, 6),
  newdata = transform(
    subset(
      dose_info_combo2,
      group_id == "trial_AB"
    ),
    num_patients = 6,
    num_toxicities = 0
  )
)
## Recover user set sampling defaults
options(.user_mc_options)

</code></pre>

<hr>
<h2 id='posterior_interval.blrmfit'>Posterior intervals</h2><span id='topic+posterior_interval.blrmfit'></span><span id='topic+posterior_interval'></span>

<h3>Description</h3>

<p>Posterior intervals of all model parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'blrmfit'
posterior_interval(object, prob = 0.95, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="posterior_interval.blrmfit_+3A_object">object</code></td>
<td>
<p>fitted model object</p>
</td></tr>
<tr><td><code id="posterior_interval.blrmfit_+3A_prob">prob</code></td>
<td>
<p>central probability mass to report, i.e. the quantiles
0.5-prob/2 and 0.5+prob/2 are displayed. Multiple central
widths can be specified.</p>
</td></tr>
<tr><td><code id="posterior_interval.blrmfit_+3A_...">...</code></td>
<td>
<p>not used in this function</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Reports the quantiles of posterior parameters which correspond to
the central probability mass specified. The output includes the
posterior of the hyper-parameters and the posterior of each group
estimate.
</p>


<h3>Value</h3>

<p>Matrix of two columns for the central probability interval
<code>prob</code> for all parameters of the model.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Setting up dummy sampling for fast execution of example
## Please use 4 chains and 100x more warmup &amp; iter in practice
.user_mc_options &lt;- options(
  OncoBayes2.MC.warmup = 10, OncoBayes2.MC.iter = 20, OncoBayes2.MC.chains = 1,
  OncoBayes2.MC.save_warmup = FALSE
)

example_model("single_agent", silent = TRUE)

posterior_interval(blrmfit)

## Recover user set sampling defaults
options(.user_mc_options)

</code></pre>

<hr>
<h2 id='posterior_linpred.blrmfit'>Posterior of linear predictor</h2><span id='topic+posterior_linpred.blrmfit'></span><span id='topic+posterior_linpred'></span>

<h3>Description</h3>

<p>Calculates the posterior of the linear predictor.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'blrmfit'
posterior_linpred(object, transform = FALSE, newdata, draws, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="posterior_linpred.blrmfit_+3A_object">object</code></td>
<td>
<p>fitted model object</p>
</td></tr>
<tr><td><code id="posterior_linpred.blrmfit_+3A_transform">transform</code></td>
<td>
<p>logical (defaults to <code>FALSE</code>) indicating if
the linear predictor on the logit link scale is transformed
with <code>inv_logit</code> to the 0-1 response scale.</p>
</td></tr>
<tr><td><code id="posterior_linpred.blrmfit_+3A_newdata">newdata</code></td>
<td>
<p>optional data frame specifying for what to predict;
if missing, then the data of the input model <code>object</code> is
used</p>
</td></tr>
<tr><td><code id="posterior_linpred.blrmfit_+3A_draws">draws</code></td>
<td>
<p>number of returned posterior draws; by default the
entire posterior is returned</p>
</td></tr>
<tr><td><code id="posterior_linpred.blrmfit_+3A_...">...</code></td>
<td>
<p>not used in this function</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Simulates the posterior of the linear predictor of the model
<code>object</code> for the specified data set.
</p>


<h3>Value</h3>

<p>Matrix of dimensions <code>draws</code> by <code>nrow(newdata)</code>
where row correspond to a draw of the posterior and each
column corresponds to a row in <code>newdata</code>. The columns are
labelled with the <code>row.names</code> of <code>newdata</code>.
</p>


<h3>Group and strata definitions</h3>

<p>The groups and strata as defined when running the <code>blrm_exnex</code>
analysis cannot be changed at a later stage. As a result no
evaluations can be performed for groups which have not been present
in the data set used for running the analysis. However, it is
admissible to code the group (and/or stratum) column as a
<code>factor</code> which contains empty levels. These groups are thus
not contained in the fitting data set and they are assigned by
default to the first stratum. In addition priors must be setup for
these groups (and/or strata). These empty group (and/or strata)
levels are then allowed in subsequent evaluations. This enables the
evaluation of the hierarchical model in terms of representing a
prior for future groups.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Setting up dummy sampling for fast execution of example
## Please use 4 chains and 100x more warmup &amp; iter in practice
.user_mc_options &lt;- options(
  OncoBayes2.MC.warmup = 10, OncoBayes2.MC.iter = 20, OncoBayes2.MC.chains = 1,
  OncoBayes2.MC.save_warmup = FALSE
)


## run single-agent analysis which defines blrmfit model object
example_model("single_agent", silent = TRUE)

## obtain posterior of linear prediction on 0-1 scale
post_prob_dlt &lt;- posterior_linpred(blrmfit, TRUE, newdata = hist_SA)
## name columns to obtain nice bayesplot labels
colnames(post_prob_dlt) &lt;- hist_SA$drug_A

library(bayesplot)
library(ggplot2)
mcmc_intervals(post_prob_dlt, prob = 0.5, prob_outer = 0.95) +
  coord_flip() +
  vline_at(c(0.16, 0.33), linetype = 2) +
  ylab("Dose [mg]") +
  ggtitle("Posterior Probability of a DLT") +
  scale_x_continuous(breaks = c(0.1, 0.16, 0.33, 0.5, 0.75))

## Recover user set sampling defaults
options(.user_mc_options)

</code></pre>

<hr>
<h2 id='posterior_predict.blrmfit'>Posterior of predictive</h2><span id='topic+posterior_predict.blrmfit'></span><span id='topic+posterior_predict'></span>

<h3>Description</h3>

<p>Simulation of the predictive distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'blrmfit'
posterior_predict(object, newdata, draws, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="posterior_predict.blrmfit_+3A_object">object</code></td>
<td>
<p>fitted model object</p>
</td></tr>
<tr><td><code id="posterior_predict.blrmfit_+3A_newdata">newdata</code></td>
<td>
<p>optional data frame specifying for what to predict;
if missing, then the data of the input model <code>object</code> is
used</p>
</td></tr>
<tr><td><code id="posterior_predict.blrmfit_+3A_draws">draws</code></td>
<td>
<p>number of returned posterior draws; by default the
entire posterior is returned</p>
</td></tr>
<tr><td><code id="posterior_predict.blrmfit_+3A_...">...</code></td>
<td>
<p>not used in this function</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Simulates the posterior predictive of the model <code>object</code> for
the specified data set.
</p>


<h3>Value</h3>

<p>Matrix of dimensions <code>draws</code> by <code>nrow(newdata)</code>
where row correspond to a draw of the posterior and each
column corresponds to a row in <code>newdata</code>. The columns are
labelled with the <code>row.names</code> of <code>newdata</code>.
</p>


<h3>Group and strata definitions</h3>

<p>The groups and strata as defined when running the <code>blrm_exnex</code>
analysis cannot be changed at a later stage. As a result no
evaluations can be performed for groups which have not been present
in the data set used for running the analysis. However, it is
admissible to code the group (and/or stratum) column as a
<code>factor</code> which contains empty levels. These groups are thus
not contained in the fitting data set and they are assigned by
default to the first stratum. In addition priors must be setup for
these groups (and/or strata). These empty group (and/or strata)
levels are then allowed in subsequent evaluations. This enables the
evaluation of the hierarchical model in terms of representing a
prior for future groups.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Setting up dummy sampling for fast execution of example
## Please use 4 chains and 100x more warmup &amp; iter in practice
.user_mc_options &lt;- options(
  OncoBayes2.MC.warmup = 10, OncoBayes2.MC.iter = 20, OncoBayes2.MC.chains = 1,
  OncoBayes2.MC.save_warmup = FALSE
)


example_model("single_agent", silent = TRUE)

post_pred &lt;- posterior_predict(blrmfit)
## turn DLT counts into DLT rates
post_pred_rate &lt;- sweep(post_pred, 2, hist_SA$num_patients, "/")

library(bayesplot)
library(ggplot2)

## compare posterior predictive of the model for the response rates
## with observed data
with(
  hist_SA,
  ppc_intervals(num_toxicities / num_patients, post_pred_rate, x = drug_A, prob_outer = 0.95)
) +
  xlab("Dose [mg]")

## Recover user set sampling defaults
options(.user_mc_options)

</code></pre>

<hr>
<h2 id='pp_data'>Internal function to simulate from the posterior new parameter draws</h2><span id='topic+pp_data'></span>

<h3>Description</h3>

<p>Internal function to simulate from the posterior new parameter draws
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pp_data(object, newdata, draws, re.form)
</code></pre>

<hr>
<h2 id='predictive_interval.blrmfit'>Posterior predictive intervals</h2><span id='topic+predictive_interval.blrmfit'></span><span id='topic+predictive_interval'></span>

<h3>Description</h3>

<p>Posterior predictive intervals of the model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'blrmfit'
predictive_interval(object, prob = 0.95, newdata, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predictive_interval.blrmfit_+3A_object">object</code></td>
<td>
<p>fitted model object</p>
</td></tr>
<tr><td><code id="predictive_interval.blrmfit_+3A_prob">prob</code></td>
<td>
<p>central probability mass to report, i.e. the quantiles
0.5-prob/2 and 0.5+prob/2 are displayed. Multiple central
widths can be specified.</p>
</td></tr>
<tr><td><code id="predictive_interval.blrmfit_+3A_newdata">newdata</code></td>
<td>
<p>optional data frame specifying for what to predict;
if missing, then the data of the input model <code>object</code> is
used</p>
</td></tr>
<tr><td><code id="predictive_interval.blrmfit_+3A_...">...</code></td>
<td>
<p>not used in this function</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Reports for each row of the input data set the predictive interval
according to the fitted model.
</p>


<h3>Value</h3>

<p>Matrix with as many rows as the input data set and two
columns which contain the lower and upper quantile
corresponding to the central probability mass <code>prob</code> for
the number of responses of the predictive distribution.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Setting up dummy sampling for fast execution of example
## Please use 4 chains and 100x more warmup &amp; iter in practice
.user_mc_options &lt;- options(
  OncoBayes2.MC.warmup = 10, OncoBayes2.MC.iter = 20, OncoBayes2.MC.chains = 1,
  OncoBayes2.MC.save_warmup = FALSE
)

example_model("single_agent", silent = TRUE)

predictive_interval(blrmfit)

## Recover user set sampling defaults
options(.user_mc_options)

</code></pre>

<hr>
<h2 id='prior_summary.blrmfit'>Summarise model prior</h2><span id='topic+prior_summary.blrmfit'></span><span id='topic+prior_summary'></span>

<h3>Description</h3>

<p>Extracts a summary of the prior in a structured data format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'blrmfit'
prior_summary(object, digits = 2, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="prior_summary.blrmfit_+3A_object">object</code></td>
<td>
<p><code>blrmfit</code> (<code>blrm_trial</code>) object as returned from <code><a href="#topic+blrm_exnex">blrm_exnex</a></code> (<code><a href="#topic+blrm_trial">blrm_trial</a></code>) analysis</p>
</td></tr>
<tr><td><code id="prior_summary.blrmfit_+3A_digits">digits</code></td>
<td>
<p>number of digits to show</p>
</td></tr>
<tr><td><code id="prior_summary.blrmfit_+3A_...">...</code></td>
<td>
<p>ignored by the function</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The summary of the prior creates a structured
representation of the specified prior from a
<code><a href="#topic+blrm_exnex">blrm_exnex</a></code> (<code><a href="#topic+blrm_trial">blrm_trial</a></code>) analysis.
</p>


<h3>Value</h3>

<p>Returns an analysis specific list, which has it's own
<code>print</code> function. The returned list contains arrays which
represent the prior in a structured format.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Setting up dummy sampling for fast execution of example
## Please use 4 chains and 100x more warmup &amp; iter in practice
.user_mc_options &lt;- options(
  OncoBayes2.MC.warmup = 10, OncoBayes2.MC.iter = 20, OncoBayes2.MC.chains = 1,
  OncoBayes2.MC.save_warmup = FALSE
)

## run combo2 analysis which defines blrmfit model object
example_model("combo2", silent = TRUE)

prior_summary(blrmfit)

prior_sum &lt;- prior_summary(blrmfit)
names(prior_sum)

## the entries of the prior list are labelled arrays
dimnames(prior_sum$EX_mu_log_beta)

## Recover user set sampling defaults
options(.user_mc_options)

</code></pre>

<hr>
<h2 id='summary.blrm_trial'>Summarise trial</h2><span id='topic+summary.blrm_trial'></span>

<h3>Description</h3>

<p>Provides model summaries for <code><a href="#topic+blrm_trial">blrm_trial</a></code> analyses.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'blrm_trial'
summary(
  object,
  summarize = c("blrmfit", "blrm_exnex_call", "data", "drug_info", "dose_info",
    "dose_prediction", "data_prediction", "newdata_prediction", "dimensionality",
    "interval_prob", "interval_max_mass", "ewoc_check"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.blrm_trial_+3A_object">object</code></td>
<td>
<p><code><a href="#topic+blrm_trial">blrm_trial</a></code> object</p>
</td></tr>
<tr><td><code id="summary.blrm_trial_+3A_summarize">summarize</code></td>
<td>
<p>one of the following options:
</p>

<dl>
<dt><code>blrmfit</code></dt><dd><p>summary of the underlying blrmfit object with further arguments ...</p>
</dd>
<dt><code>blrm_exnex_call</code></dt><dd><p>blrm_exnex call used to create the <code>blrmfit</code> object</p>
</dd>
<dt><code>drug_info</code></dt><dd><p>drug_info for the trial, contains drugs, reference doses and units</p>
</dd>
<dt><code>dose_info</code></dt><dd><p>dose_info that were defined</p>
</dd>
<dt><code>dose_prediction</code></dt><dd><p>prediction for the defined <code>dose_info</code></p>
</dd>
<dt><code>data</code></dt><dd><p>data that were observed</p>
</dd>
<dt><code>data_prediction</code></dt><dd><p>prediction for the observed data</p>
</dd>
<dt><code>newdata_prediction</code></dt><dd><p>prediction for data provided with the <code>newdata</code> argument</p>
</dd>
<dt><code>dimensionality</code></dt><dd><p>numeric vector with entries <code>"num_components"</code>,
<code>"num_interaction_terms"</code>, <code>"num_groups"</code>, <code>"num_strata"</code></p>
</dd>
<dt><code>interval_prob</code></dt><dd><p>interval probabilities reported in the standard outputs</p>
</dd>
<dt><code>interval_max_mass</code></dt><dd><p>named vector defining for each interval of the
<code>interval_prob</code> vector a maxmimal admissable
probability mass for a given dose level</p>
</dd>
<dt><code>ewoc_check</code></dt><dd><p>MCMC diagnostic and precision estimates of ewoc defining metrics for the defined doses in <code>dose_info</code> (default) or for the doses provided in the <code>newdata</code> argument. Please refer to the details for reported diagnostics.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="summary.blrm_trial_+3A_...">...</code></td>
<td>
<p>further arguments for <code><a href="#topic+summary.blrmfit">summary.blrmfit</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>ewoc_check</code> summary routine allows to assess the
accuracy and reliability of the ewoc criterion with respect to
MCMC sampling noise. The returned summary provides detailled
MCMC convergence and precision estimates for all criteria
defined by <code>interval_prob</code> and <code>interval_max_mass</code>
which contribute to EWOC metric. That is, for each interval
probability with a maximal mass of less than unity the routine
will return these columns:
</p>

<dl>
<dt><code>est</code></dt><dd><p>the MCMC estimate defining the critical value. For intervals defined by a tail probability this corresponds to the respective critical quantile while for interval probabilites this is equal to the interval probability.</p>
</dd>
<dt><code>stat</code></dt><dd><p>centered and standardized test quantity. The estimate is centered by the critical value and scaled by the Monte-Carlo standard error (MCSE) of the estimate. Hence, negative (positive) values correspond to the constraint being (not) fulfilled. The standardization with the MCSE allows to compare the values to standard normal quantiles accordingly.</p>
</dd>
<dt><code>mcse</code></dt><dd><p>the Monte-Carlo standard error of the estimate determined with <code><a href="posterior.html#topic+mcse_quantile">mcse_quantile</a></code> (tail probability) or <code><a href="posterior.html#topic+mcse_mean">mcse_mean</a></code> (interval probability) functions.</p>
</dd>
<dt><code>ess</code></dt><dd><p>the Monte-Carlo effective sample size of the estimate determined with <code><a href="posterior.html#topic+ess_quantile">ess_quantile</a></code> (tail probability) or <code><a href="posterior.html#topic+ess_mean">ess_mean</a></code> (interval probability) functions.</p>
</dd>
<dt><code>rhat</code></dt><dd><p>the Monte-Carlo non-convergence diagnostic Rhat as determined with the <code><a href="posterior.html#topic+rhat">rhat</a> function</code>.</p>
</dd>
</dl>

<p>For the common case of requiring that 33\
exceeded by more than 25\
estimate column <code>est</code> contains the 75\
<code class="reqn">q_{75\%}</code> and the standardized statistic <code>stat</code> is
defined as:
</p>
<p style="text-align: center;"><code class="reqn">\mbox{stat} = \frac{q_{75\%} - 33\%}{\mbox{mcse}_{q_{75\%}}}</code>
</p>

<p>The statistic is approximately distributed as a standard normal
variate. The <code>ewoc_check</code> summary can be used to ensure that
the MCMC estimation accuracy is sufficient.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Setting up dummy sampling for fast execution of example
## Please use 4 chains and 100x more warmup &amp; iter in practice
.user_mc_options &lt;- options(
  OncoBayes2.MC.warmup = 10, OncoBayes2.MC.iter = 20, OncoBayes2.MC.chains = 1,
  OncoBayes2.MC.save_warmup = FALSE
)

# construct initial blrm_trial object from built-in example datasets
combo2_trial_setup &lt;- blrm_trial(
  data = hist_combo2,
  dose_info = dose_info_combo2,
  drug_info = drug_info_combo2,
  simplified_prior = TRUE
)

# extract blrm_call to see setup of the prior as passed to blrm_exnex
summary(combo2_trial_setup, "blrm_exnex_call")

# extract ewoc precision accuracy
ec &lt;- summary(combo2_trial_setup, "ewoc_check")

# find any ewoc metrics which are within 95% MCMC error of the threshold
# these are counted as "imprecise" when printing blrm_trial objects
subset(ec, abs(prob_overdose_stat) &lt; qnorm(0.975))

# ensure that the ewoc metric only flags "ok" whenever the MCMC error
# is with 95% below the threshold
ewoc_ok &lt;- ec$prob_overdose_stat &lt; qnorm(0.025)

## Recover user set sampling defaults
options(.user_mc_options)

</code></pre>

<hr>
<h2 id='summary.blrmfit'>Summarise model results</h2><span id='topic+summary.blrmfit'></span>

<h3>Description</h3>

<p>Provides model summaries for <code><a href="#topic+blrm_exnex">blrm_exnex</a></code> and
<code><a href="#topic+blrm_trial">blrm_trial</a></code> analyses.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'blrmfit'
summary(
  object,
  newdata,
  transform = !predictive,
  prob = 0.95,
  interval_prob,
  predictive = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.blrmfit_+3A_object">object</code></td>
<td>
<p>fitted model object</p>
</td></tr>
<tr><td><code id="summary.blrmfit_+3A_newdata">newdata</code></td>
<td>
<p>optional data frame specifying for what to predict;
if missing, then the data of the input model <code>object</code> is
used</p>
</td></tr>
<tr><td><code id="summary.blrmfit_+3A_transform">transform</code></td>
<td>
<p>logical (defaults to <code>FALSE</code>) indicating if
the linear predictor on the logit link scale is transformed
with <code>inv_logit</code> to the 0-1 response scale.</p>
</td></tr>
<tr><td><code id="summary.blrmfit_+3A_prob">prob</code></td>
<td>
<p>central probability mass to report, i.e. the quantiles
0.5-prob/2 and 0.5+prob/2 are displayed. Multiple central
widths can be specified.</p>
</td></tr>
<tr><td><code id="summary.blrmfit_+3A_interval_prob">interval_prob</code></td>
<td>
<p>optional vector of sorted quantiles for which
the interval probabilities are calculated</p>
</td></tr>
<tr><td><code id="summary.blrmfit_+3A_predictive">predictive</code></td>
<td>
<p>logical indicates if the posterior predictive is
being summarized. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="summary.blrmfit_+3A_...">...</code></td>
<td>
<p>not used in this function</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The calculated posterior summaries are returned as a
<code>data.frame</code> and contain optional interval probabilites for
the specified vector of sorted quantiles. These summaries are
calculated on the response scale by default and can be obtained on
the link scale when setting <code>transform=FALSE</code>.
</p>
<p>When the results are requested for the predictive distribution with
<code>predictive=TRUE</code>, then the link scale refers to the total
counts while the transformed scale divides the (predictive) counts
by the number of trials such that results are on the 0-1 scale.
</p>


<h3>Value</h3>

<p>Returns a <code>data.frame</code> of the key summaries of the
posterior mean, standard deviation, central probability
interval, median and optional interval probabilities. Each row
of the <code>data.frame</code> corresponds to the respective input
data which is by default the same data set as used for the
<code><a href="#topic+blrm_exnex">blrm_exnex</a></code> analysis or the data specified in the
<code>newdata</code> argument.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Setting up dummy sampling for fast execution of example
## Please use 4 chains and 100x more warmup &amp; iter in practice
.user_mc_options &lt;- options(
  OncoBayes2.MC.warmup = 10, OncoBayes2.MC.iter = 20, OncoBayes2.MC.chains = 1,
  OncoBayes2.MC.save_warmup = FALSE
)

example_model("single_agent", silent = TRUE)

## obtain underdosing (0-0.16], target dosing (0.16-0.33] and
## overdosing (0.33-1] probabilities
summary(blrmfit, interval_prob = c(0, 0.16, 0.33, 1))

## obtain predictive distribution for respective cohorts and
## calculate probability for no event, 1 event or &gt;1 event
## note that this does the calculation for the cohort sizes
## as put into the data-set
summary(blrmfit, interval_prob = c(-1, 0, 1, 10), predictive = TRUE)

## to obtain the predictive for a cohort-size of 6 for all patients
## in the data-set one would need to use the newdata argument, e.g.
summary(blrmfit,
  newdata = transform(hist_SA, num_patients = 6),
  interval_prob = c(-1, 0, 1, 10), predictive = TRUE
)

## Recover user set sampling defaults
options(.user_mc_options)

</code></pre>

<hr>
<h2 id='update.blrm_trial'>Update data and/or prior of a BLRM trial</h2><span id='topic+update.blrm_trial'></span>

<h3>Description</h3>


<ul>
<li><p> Adds data rows to a <code><a href="#topic+blrm_trial">blrm_trial</a></code> object (add_data argument)
</p>
</li>
<li><p> Replaces data of a <code><a href="#topic+blrm_trial">blrm_trial</a></code> object (data argument)
</p>
</li>
<li><p> Sets the prior of a <code><a href="#topic+blrm_trial">blrm_trial</a></code> object (... argument will be
passed to blrm_exnex)
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'blrm_trial'
update(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="update.blrm_trial_+3A_object">object</code></td>
<td>
<p>blrm_trial object</p>
</td></tr>
<tr><td><code id="update.blrm_trial_+3A_...">...</code></td>
<td>
<p>passed to default <code>update</code> command of <code>blrm_exnex</code></p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Setting up dummy sampling for fast execution of example
## Please use 4 chains and 100x more warmup &amp; iter in practice
.user_mc_options &lt;- options(
  OncoBayes2.MC.warmup = 10, OncoBayes2.MC.iter = 20, OncoBayes2.MC.chains = 1,
  OncoBayes2.MC.save_warmup = FALSE
)


# the combo2_trial example demonstrates the use of add_data of
# update.blrmfit
example_model("combo2_trial")

## Recover user set sampling defaults
options(.user_mc_options)

</code></pre>

<hr>
<h2 id='update.blrmfit'>Update data of a BLRM analysis</h2><span id='topic+update.blrmfit'></span>

<h3>Description</h3>

<p>Adds data rows to a <code><a href="#topic+blrm_exnex">blrm_exnex</a></code> or
<code><a href="#topic+blrm_trial">blrm_trial</a></code> analysis object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'blrmfit'
update(object, ..., add_data)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="update.blrmfit_+3A_object">object</code></td>
<td>
<p>blrmfit analysis object</p>
</td></tr>
<tr><td><code id="update.blrmfit_+3A_...">...</code></td>
<td>
<p>passed to default <code>update</code> command
</p>
<p>The data in <code>add_data</code> will be combined with data in
<code>object</code> using <code>bind_rows</code>. The indices for groups and
stratums (if defined) are matched between <code>add_data</code> and the
data of the analysis <code>object</code>.
</p>
<p>Note that the <code>add_data</code> argument must be named explicitly as
demonstrated in the example.</p>
</td></tr>
<tr><td><code id="update.blrmfit_+3A_add_data">add_data</code></td>
<td>
<p>additional data added to analysis data of <code>object</code></p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Setting up dummy sampling for fast execution of example
## Please use 4 chains and 100x more warmup &amp; iter in practice
.user_mc_options &lt;- options(
  OncoBayes2.MC.warmup = 10, OncoBayes2.MC.iter = 20, OncoBayes2.MC.chains = 1,
  OncoBayes2.MC.save_warmup = FALSE
)

example_model("single_agent", silent = TRUE)

library(tibble)
new_cohort &lt;- tibble(group_id = "trial_A", drug_A = 50, num_patients = 4, num_toxicities = 1)

## this would fail, since add_data argument must be named
## new_blrmfit &lt;- update(blrmfit, new_cohort)
new_blrmfit &lt;- update(blrmfit, add_data = new_cohort)

## Recover user set sampling defaults
options(.user_mc_options)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
