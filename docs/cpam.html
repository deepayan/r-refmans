<!DOCTYPE html><html lang="en"><head><title>Help for package cpam</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {cpam}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#cpam-package'><p>cpam: Changepoint Additive Models for Time Series Omics Data</p></a></li>
<li><a href='#+25+26gt+3B+25'><p>Pipe operator</p></a></li>
<li><a href='#compute_normalization_factors'><p>Compute normalization factors</p></a></li>
<li><a href='#compute_p_values'><p>Compute p-values for each target ID</p></a></li>
<li><a href='#convert_to_long_format'><p>Convert count matrix to long format and join with experiment design</p></a></li>
<li><a href='#cpam-class'><p>The cpam class</p></a></li>
<li><a href='#estimate_changepoint'><p>Use model selection to estimate changepoints</p></a></li>
<li><a href='#estimate_dispersions_wrapper'><p>Wrapper for estimating dispersions</p></a></li>
<li><a href='#handle_gene_aggregation'><p>Handle gene aggregation in long format data</p></a></li>
<li><a href='#import_count_data'><p>Import count data from files</p></a></li>
<li><a href='#ose_rule'><p>Apply the one-standard-error rule for model selection</p></a></li>
<li><a href='#plot_cluster'><p>Plot clustered targets</p></a></li>
<li><a href='#plot_cpam'><p>Plot fitted changepoint additive models</p></a></li>
<li><a href='#prepare_cpam'><p>Prepare a cpam object</p></a></li>
<li><a href='#process_bootstrap_data'><p>Process bootstrap data</p></a></li>
<li><a href='#process_count_matrix'><p>Process count matrix when importing is not needed</p></a></li>
<li><a href='#results'><p>Create a results table from a cpam object</p></a></li>
<li><a href='#select_shape'><p>Use model selection to select a shape for each target</p></a></li>
<li><a href='#simulate_p_mvn'><p>Simulate p-values using multivariate normal distribution</p></a></li>
<li><a href='#summarise_bootstraps'><p>Summarize bootstrap samples</p></a></li>
<li><a href='#ts_filter'><p>Removes lowly expressed genes</p></a></li>
<li><a href='#validate_cores'><p>Validate and adjust number of cores</p></a></li>
<li><a href='#validate_inputs'><p>Validate input parameters for prepare_cpam</p></a></li>
<li><a href='#visualise'><p>Launches a Shiny app to visualise the data and fitted models of a cpam object</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Changepoint Additive Models for Time Series Omics Data</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.3</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides a comprehensive framework for time series omics analysis,
  integrating changepoint detection, smooth and shape-constrained trends,
  and uncertainty quantification. It supports gene- and transcript-level inferences,
  p-value aggregation for improved power, and both case-only and case-control designs.
  It includes an interactive 'shiny' interface. The methods are described in Yates et al. (2024) &lt;<a href="https://doi.org/10.1101%2F2024.12.22.630003">doi:10.1101/2024.12.22.630003</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>Imports:</td>
<td>bslib, cli, dplyr, edgeR, ggplot2, grDevices, magrittr,
matrixStats, mgcv, mvnfast, parallel, pbmcapply, purrr,
RColorBrewer, rlang, scam, shiny, shinyjs, stats, stringr,
tidyr, tximport</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5)</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://l-a-yates.github.io/cpam/">https://l-a-yates.github.io/cpam/</a>,
<a href="https://github.com/l-a-yates/cpam">https://github.com/l-a-yates/cpam</a></td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/l-a-yates/cpam/issues">https://github.com/l-a-yates/cpam/issues</a></td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-03-11 23:41:12 UTC; layates</td>
</tr>
<tr>
<td>Author:</td>
<td>Luke Yates <a href="https://orcid.org/0000-0002-1685-3169"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cre, cph],
  Michael Charleston [aut],
  Jazmine Humphreys [aut],
  Steven Smith [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Luke Yates &lt;luke.yates@utas.edu.au&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-03-13 13:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='cpam-package'>cpam: Changepoint Additive Models for Time Series Omics Data</h2><span id='topic+cpam-package'></span>

<h3>Description</h3>

<p>Provides a comprehensive framework for time series omics analysis, integrating changepoint detection, smooth and shape-constrained trends, and uncertainty quantification. It supports gene- and transcript-level inferences, p-value aggregation for improved power, and both case-only and case-control designs. It includes an interactive 'shiny' interface. The methods are described in Yates et al. (2024) <a href="https://doi.org/10.1101/2024.12.22.630003">doi:10.1101/2024.12.22.630003</a>.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Luke Yates <a href="mailto:luke.yates@utas.edu.au">luke.yates@utas.edu.au</a> (<a href="https://orcid.org/0000-0002-1685-3169">ORCID</a>) [copyright holder]
</p>
<p>Authors:
</p>

<ul>
<li><p> Michael Charleston
</p>
</li>
<li><p> Jazmine Humphreys
</p>
</li>
<li><p> Steven Smith
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://l-a-yates.github.io/cpam/">https://l-a-yates.github.io/cpam/</a>
</p>
</li>
<li> <p><a href="https://github.com/l-a-yates/cpam">https://github.com/l-a-yates/cpam</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/l-a-yates/cpam/issues">https://github.com/l-a-yates/cpam/issues</a>
</p>
</li></ul>


<hr>
<h2 id='+25+26gt+3B+25'>Pipe operator</h2><span id='topic++25+3E+25'></span>

<h3>Description</h3>

<p>See <code>magrittr::<a href="magrittr.html#topic+pipe">%&gt;%</a></code> for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lhs %&gt;% rhs
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="+2B25+2B26gt+2B3B+2B25_+3A_lhs">lhs</code></td>
<td>
<p>A value or the magrittr placeholder.</p>
</td></tr>
<tr><td><code id="+2B25+2B26gt+2B3B+2B25_+3A_rhs">rhs</code></td>
<td>
<p>A function call using the magrittr semantics.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The result of calling <code>rhs(lhs)</code>.
</p>

<hr>
<h2 id='compute_normalization_factors'>Compute normalization factors</h2><span id='topic+compute_normalization_factors'></span>

<h3>Description</h3>

<p>Compute normalization factors
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_normalization_factors(count_matrix_filtered, normalize)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="compute_normalization_factors_+3A_count_matrix_filtered">count_matrix_filtered</code></td>
<td>
<p>Filtered count matrix</p>
</td></tr>
<tr><td><code id="compute_normalization_factors_+3A_normalize">normalize</code></td>
<td>
<p>Whether to perform normalization</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector of normalization factors
</p>

<hr>
<h2 id='compute_p_values'>Compute p-values for each target ID</h2><span id='topic+compute_p_values'></span>

<h3>Description</h3>

<p>Compute p-values for each target ID
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_p_values(
  cpo,
  subset = NULL,
  p_adj_method = "BH",
  gam_method = "REML",
  gam_optimizer = "efs",
  silent = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="compute_p_values_+3A_cpo">cpo</code></td>
<td>
<p>a cpam object</p>
</td></tr>
<tr><td><code id="compute_p_values_+3A_subset">subset</code></td>
<td>
<p>a character vector of target_id names</p>
</td></tr>
<tr><td><code id="compute_p_values_+3A_p_adj_method">p_adj_method</code></td>
<td>
<p>method for p-value adjustment</p>
</td></tr>
<tr><td><code id="compute_p_values_+3A_gam_method">gam_method</code></td>
<td>
<p>fitting method for <code>mgcv::gam</code> (default is &quot;REML&quot;)</p>
</td></tr>
<tr><td><code id="compute_p_values_+3A_gam_optimizer">gam_optimizer</code></td>
<td>
<p>optimization method for <code>mgcv::gam</code> (default is &quot;efs&quot;)</p>
</td></tr>
<tr><td><code id="compute_p_values_+3A_silent">silent</code></td>
<td>
<p>logical; silences warnings from model fitting (default is TRUE)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function computes p-values for each target_id in the supplied cpam object.
The p-values are computed from a negative binomial GAM model
with a thin-plate spline basis function(s) for time
using the <code>mgcv</code> package.
</p>
<p>The p-values are stored in the new slot <code>p_table</code> in the cpam object.
If <code>aggregate_to_gene</code> is set to <code>TRUE</code> (default),
the target p-values are aggregated to the gene level using the <code>lancaster</code> method.
The columns <code>p_val_target</code> and <code>p_val_gene</code> store the raw p-values for target- and gene-level, respectively.
The function also computes adjusted p-values using the <code>p_adj_method</code>.
The default method is &quot;BH&quot; (Benjamini-Hochberg),
but any methods supported by the function <code>p.adjust</code> can be used.
The adjusted p-values are stored in the columns <code>q_val_target</code> and <code>q_val_gene</code>.
</p>


<h3>Value</h3>

<p>an updated cpam object with raw, adjusted, and possibly aggregated p-values stored in the new slot &quot;p_table&quot;
</p>


<h3>References</h3>

<p>Wood, S.N. (2013a) On p-values for smooth components of an extended
generalized additive model. Biometrika 100:221-228 doi:10.1093/biomet/ass048
</p>
<p>Yi L, Pachter L (2018). aggregation: p-Value Aggregation Methods. R package version 1.0.1,
https://CRAN.R-project.org/package=aggregation.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(cpam)

# load gene-only example cpam object
load(system.file("extdata", "cpo_example.rda", package = "cpam"))

# run on a small subset of the example data
cpo &lt;- compute_p_values(cpo_example, subset = paste0("g00",1:9))
cpo$p_table

</code></pre>

<hr>
<h2 id='convert_to_long_format'>Convert count matrix to long format and join with experiment design</h2><span id='topic+convert_to_long_format'></span>

<h3>Description</h3>

<p>Convert count matrix to long format and join with experiment design
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convert_to_long_format(counts_raw, exp_design)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="convert_to_long_format_+3A_counts_raw">counts_raw</code></td>
<td>
<p>Raw count matrix</p>
</td></tr>
<tr><td><code id="convert_to_long_format_+3A_exp_design">exp_design</code></td>
<td>
<p>Experimental design</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Long format data frame
</p>

<hr>
<h2 id='cpam-class'>The cpam class</h2><span id='topic+cpam-class'></span><span id='topic+cpam'></span>

<h3>Description</h3>

<p>The <code>cpam</code> class stores data and analysis results for a time series
omics experiment. This object is generated by the <code><a href="#topic+prepare_cpam">prepare_cpam</a></code>
function and contains all necessary data and parameters for downstream analysis.
</p>


<h3>Details</h3>

<p>A <code>cpam</code> object is a list with the following components:
</p>

<dl>
<dt>exp_design</dt><dd><p>A data frame containing the experimental design information, with columns for 'sample', 'time', and potentially other variables.</p>
</dd>
<dt>count_matrix_raw</dt><dd><p>The original count matrix before filtering.</p>
</dd>
<dt>count_matrix_filtered</dt><dd><p>The count matrix after filtering low-count genes/transcripts.</p>
</dd>
<dt>target_to_keep</dt><dd><p>A vector of transcript/gene IDs that passed the filtering criteria.</p>
</dd>
<dt>data_long</dt><dd><p>A long-format data frame containing all relevant information for each target and sample.</p>
</dd>
<dt>t2g</dt><dd><p>A transcript-to-gene mapping data frame if provided.</p>
</dd>
<dt>regularize</dt><dd><p>Logical; whether empirical Bayes regularization of dispersions was used.</p>
</dd>
<dt>overdispersion.prior</dt><dd><p>Median overdispersion.</p>
</dd>
<dt>model_type</dt><dd><p>String; the type of design used, either &quot;case-only&quot; or &quot;case-control&quot;.</p>
</dd>
<dt>condition_var</dt><dd><p>String; the column name in exp_design for the condition variable (for case-control models).</p>
</dd>
<dt>case_value</dt><dd><p>The value of condition_var that indicates the &quot;case&quot; in case-control models.</p>
</dd>
<dt>bootstrap</dt><dd><p>Logical; whether bootstrap samples (inferential replicates) were used.</p>
</dd>
<dt>nboot</dt><dd><p>The number of bootstrap samples used, if applicable.</p>
</dd>
<dt>filter</dt><dd><p>A list containing the filtering function and its arguments used.</p>
</dd>
<dt>gene_level</dt><dd><p>Logical; whether the analysis was performed at the gene level.</p>
</dd>
<dt>aggregate_to_gene</dt><dd><p>Logical; whether p-values should be aggregated from transcript to gene level.</p>
</dd>
<dt>times</dt><dd><p>An ordered vector of unique time points in the experimental design.</p>
</dd>
<dt>num_cores</dt><dd><p>The number of cores used for parallel computation.</p>
</dd>
<dt>fixed_effects</dt><dd><p>The formula for fixed effects in the model.</p>
</dd>
<dt>intercept_cc</dt><dd><p>String; the intercept type for case-control models.</p>
</dd>
<dt>bss</dt><dd><p>A vector of basis function types used for modelling.</p>
</dd>
</dl>



<h3>Methods</h3>

<p>Objects of class <code>cpam</code> have print and summary methods available.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+prepare_cpam">prepare_cpam</a></code> for creating a cpam object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# load gene-only example data
load(system.file("extdata", "exp_design_example.rda", package = "cpam"))
load(system.file("extdata", "count_matrix_example.rda", package = "cpam"))

# Create a cpam object with the example data
cpo &lt;- prepare_cpam(exp_design = exp_design_example,
                    count_matrix = count_matrix_example,
                    gene_level = TRUE)

# Print the object structure
cpo

# Get a summary of the cpam object
summary(cpo)

</code></pre>

<hr>
<h2 id='estimate_changepoint'>Use model selection to estimate changepoints</h2><span id='topic+estimate_changepoint'></span>

<h3>Description</h3>

<p>Use model selection to estimate changepoints
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimate_changepoint(
  cpo,
  cps = NULL,
  degs_only = TRUE,
  deg_threshold = 0.05,
  subset = NULL,
  sp = NULL,
  bss = "tp",
  family = c("nb", "gaussian"),
  score = "aic",
  compute_mvn = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="estimate_changepoint_+3A_cpo">cpo</code></td>
<td>
<p>a cpam object</p>
</td></tr>
<tr><td><code id="estimate_changepoint_+3A_cps">cps</code></td>
<td>
<p>vector of candidate changepoints. Defaults to the set of observed timepoints</p>
</td></tr>
<tr><td><code id="estimate_changepoint_+3A_degs_only">degs_only</code></td>
<td>
<p>logical; should changepoints only be estimated for differentially expressed genes</p>
</td></tr>
<tr><td><code id="estimate_changepoint_+3A_deg_threshold">deg_threshold</code></td>
<td>
<p>logical; the threshold value for DEGs (ignored of <code>degs_only = F</code>)</p>
</td></tr>
<tr><td><code id="estimate_changepoint_+3A_subset">subset</code></td>
<td>
<p>character vector; names of targets or genes (if <code>cpo$gene_level = T</code>)
for which changepoints will be estimated</p>
</td></tr>
<tr><td><code id="estimate_changepoint_+3A_sp">sp</code></td>
<td>
<p>numerical &gt;= 0; supply a fixed smoothing parameter.
This can decrease the fitting time but it is not recommended as changepoints estimation
is sensitive to smoothness.</p>
</td></tr>
<tr><td><code id="estimate_changepoint_+3A_bss">bss</code></td>
<td>
<p>character vector; names of candidate spline bases (i.e., candidate shape types).
Default is thin plate (&quot;tp&quot;) splines.</p>
</td></tr>
<tr><td><code id="estimate_changepoint_+3A_family">family</code></td>
<td>
<p>character; negative binomial (&quot;nb&quot;, default) or Gaussian (&quot;gaussian&quot;, not currently supported)</p>
</td></tr>
<tr><td><code id="estimate_changepoint_+3A_score">score</code></td>
<td>
<p>character; model selection score, either Generalised Cross Validation (&quot;gcv&quot;) or
Akaike Information Criterion (&quot;aic&quot;)</p>
</td></tr>
<tr><td><code id="estimate_changepoint_+3A_compute_mvn">compute_mvn</code></td>
<td>
<p>Use simulation to compute p-value under multivariate normal model of the
model scores</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function estimates changepoints for each target_id. The assumed
trajectory type for this modelling stage is initially constant followed by
a changepoint into thin-plate smoothing spline.
</p>
<p>By default, candidate time points are limited to the discrete observed values
in the series, since, despite the use of smoothing constraints,
there is generally insufficient information to infer the timing of
changepoints beyond the temporal resolution of the data. In any case, the
candidate points can be set manually using the <code>cps</code> argument.
</p>
<p>To estimate changepoints, a model is fit for each candidate changepoint and
generalised cross-validation (GCV, default) or the Akaike Information
Criterion (AIC) are used to select among them. Model-selection uncertainty
is dealt with by computing the one-standard-error rule, which identifies the
least complex model within one standard error of the best scoring model.
</p>
<p>Both the minimum and the one-standard-error (default) models are stored in the returned
slot &quot;changepoints&quot; so that either can be used. In addition to these, this function also computes the
probability (denoted <code>p_mvn</code>) that the null model is the best scoring model, using a simulation
based approach based on the multivariate normal model of the pointwise
model scores.
</p>
<p>Given the computational cost of fitting a separate model for each candidate
changepoint, cpam only estimates changepoints for targets associated with
'significant' genes at the chosen threshold <code>deg_threshold</code>.
</p>


<h3>Value</h3>

<p>a cpam object with the estimated changepoint table added to the slot &quot;changepoints&quot;
</p>


<h3>References</h3>

<p>Yates, L. A., S. A. Richards, and B. W. Brook. 2021.
Parsimonious model selection using information theory:
a modified selection rule.
Ecology 102(10):e03475. 10.1002/ecy.3475
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(cpam)
library(dplyr)

# load example data
load(system.file("extdata", "exp_design_example.rda", package = "cpam"))
load(system.file("extdata", "count_matrix_example.rda", package = "cpam"))

cpo &lt;- prepare_cpam(exp_design = exp_design_example,
                    count_matrix = count_matrix_example[1:20,],
                    gene_level = TRUE,
                    num_cores = 1)
cpo &lt;- compute_p_values(cpo)
cpo &lt;- estimate_changepoint(cpo)
cpo$changepoints

</code></pre>

<hr>
<h2 id='estimate_dispersions_wrapper'>Wrapper for estimating dispersions</h2><span id='topic+estimate_dispersions_wrapper'></span>

<h3>Description</h3>

<p>Wrapper for estimating dispersions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimate_dispersions_wrapper(
  count_matrix_filtered,
  exp_design,
  bootstrap,
  catch
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="estimate_dispersions_wrapper_+3A_count_matrix_filtered">count_matrix_filtered</code></td>
<td>
<p>Filtered count matrix</p>
</td></tr>
<tr><td><code id="estimate_dispersions_wrapper_+3A_exp_design">exp_design</code></td>
<td>
<p>Experimental design</p>
</td></tr>
<tr><td><code id="estimate_dispersions_wrapper_+3A_bootstrap">bootstrap</code></td>
<td>
<p>Whether bootstrap was used</p>
</td></tr>
<tr><td><code id="estimate_dispersions_wrapper_+3A_catch">catch</code></td>
<td>
<p>Overdispersion calculations from bootstrap</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Estimated dispersions
</p>

<hr>
<h2 id='handle_gene_aggregation'>Handle gene aggregation in long format data</h2><span id='topic+handle_gene_aggregation'></span>

<h3>Description</h3>

<p>Handle gene aggregation in long format data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>handle_gene_aggregation(data_long, t2g, aggregate_to_gene)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="handle_gene_aggregation_+3A_data_long">data_long</code></td>
<td>
<p>Long format data</p>
</td></tr>
<tr><td><code id="handle_gene_aggregation_+3A_t2g">t2g</code></td>
<td>
<p>Transcript to gene mapping</p>
</td></tr>
<tr><td><code id="handle_gene_aggregation_+3A_aggregate_to_gene">aggregate_to_gene</code></td>
<td>
<p>Whether to aggregate to gene level</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Updated long format data with gene ID information
</p>

<hr>
<h2 id='import_count_data'>Import count data from files</h2><span id='topic+import_count_data'></span>

<h3>Description</h3>

<p>Import count data from files
</p>


<h3>Usage</h3>

<pre><code class='language-R'>import_count_data(exp_design, t2g, import_type, gene_level, bootstrap)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="import_count_data_+3A_exp_design">exp_design</code></td>
<td>
<p>Experimental design</p>
</td></tr>
<tr><td><code id="import_count_data_+3A_t2g">t2g</code></td>
<td>
<p>Transcript to gene mapping</p>
</td></tr>
<tr><td><code id="import_count_data_+3A_import_type">import_type</code></td>
<td>
<p>Import type</p>
</td></tr>
<tr><td><code id="import_count_data_+3A_gene_level">gene_level</code></td>
<td>
<p>Whether to aggregate to gene level</p>
</td></tr>
<tr><td><code id="import_count_data_+3A_bootstrap">bootstrap</code></td>
<td>
<p>Whether to use bootstrap samples</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List containing imported data and related variables
</p>

<hr>
<h2 id='ose_rule'>Apply the one-standard-error rule for model selection</h2><span id='topic+ose_rule'></span>

<h3>Description</h3>

<p>Apply the one-standard-error rule for model selection
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ose_rule(tab, nse = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ose_rule_+3A_tab">tab</code></td>
<td>
<p>A table containing model scores</p>
</td></tr>
<tr><td><code id="ose_rule_+3A_nse">nse</code></td>
<td>
<p>Number of standard errors to use (default: 1)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Implements the one-standard-error rule which selects the most parsimonious model
within a specified number of standard errors of the best-scoring model.
</p>


<h3>Value</h3>

<p>The selected model that is most parsimonious within nse standard errors of the best model
</p>

<hr>
<h2 id='plot_cluster'>Plot clustered targets</h2><span id='topic+plot_cluster'></span>

<h3>Description</h3>

<p>Plot clustered targets
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_cluster(cpo, res, changepoints, shapes, alpha = 0.1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_cluster_+3A_cpo">cpo</code></td>
<td>
<p>a cpam object</p>
</td></tr>
<tr><td><code id="plot_cluster_+3A_res">res</code></td>
<td>
<p>a tibble, output from <code><a href="#topic+results">results()</a></code> containing columns target_id, cp, and shape</p>
</td></tr>
<tr><td><code id="plot_cluster_+3A_changepoints">changepoints</code></td>
<td>
<p>numerical or character; one or more changepoints (these should be the same as the ones used in <code><a href="#topic+estimate_changepoint">estimate_changepoint()</a></code></p>
</td></tr>
<tr><td><code id="plot_cluster_+3A_shapes">shapes</code></td>
<td>
<p>character; one or more shapes (these should be the same as the ones used in <code><a href="#topic+select_shape">select_shape()</a></code></p>
</td></tr>
<tr><td><code id="plot_cluster_+3A_alpha">alpha</code></td>
<td>
<p>numeric between 0 and 1; controls line transparency in plot (default: 0.1)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Plots the fitted trends for a set of targets whose estimated changepoints and
shapes are given by the arguments <code>changepoints</code> and <code>shapes</code>, respectively.
</p>
<p>Creates a combined plot showing fitted expression trends for all targets that
share specified changepoint times and shape patterns. Each line represents one
target's fitted trajectory, with transparency controlled by alpha.
</p>


<h3>Value</h3>

<p>A ggplot object showing overlaid fitted trends, or NULL if no matching
targets are found
</p>


<h3>See Also</h3>

<p><code><a href="#topic+results">results()</a></code>, <code><a href="#topic+plot_cpam">plot_cpam()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(cpam)

# load gene-only example cpam object
load(system.file("extdata", "cpo_example.rda", package = "cpam"))

# Generate results table
res_example &lt;- results(cpo_example)

# plot all targets with changepoint at timepoint 0 and shape "ilin" (increasing linear)
plot_cluster(cpo_example, res_example, changepoints = 2, shapes = "ilin")

</code></pre>

<hr>
<h2 id='plot_cpam'>Plot fitted changepoint additive models</h2><span id='topic+plot_cpam'></span>

<h3>Description</h3>

<p>Plot fitted changepoint additive models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_cpam(
  cpo,
  gene_id = NULL,
  target_id = NULL,
  cp_type = c("cp_1se", "cp_min"),
  shape_type = "shape1",
  bs = "auto",
  cp_fix = -1,
  facet = FALSE,
  sp = NULL,
  show_fit = TRUE,
  show_data = TRUE,
  show_fit_ci = TRUE,
  show_data_ci = TRUE,
  ci_prob = "se",
  remove_null = FALSE,
  null_threshold = 0.05,
  null_threshold_adj = TRUE,
  k_mult = 1.2,
  return_fits_only = FALSE,
  family = "nb",
  common_y_scale = TRUE,
  scaled = FALSE,
  base_size = 12
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_cpam_+3A_cpo">cpo</code></td>
<td>
<p>A cpam object containing count data, model fits, and optional changepoint/shape estimates</p>
</td></tr>
<tr><td><code id="plot_cpam_+3A_gene_id">gene_id</code></td>
<td>
<p>character; gene_id (mutually exclusive with target_id)</p>
</td></tr>
<tr><td><code id="plot_cpam_+3A_target_id">target_id</code></td>
<td>
<p>character; target_id (mutually exclusive with gene_id)</p>
</td></tr>
<tr><td><code id="plot_cpam_+3A_cp_type">cp_type</code></td>
<td>
<p>One of &quot;cp_1se&quot; or &quot;cp_min&quot;; rule for selecting changepoint from fitted models.
See <code><a href="#topic+estimate_changepoint">estimate_changepoint()</a></code> for details.</p>
</td></tr>
<tr><td><code id="plot_cpam_+3A_shape_type">shape_type</code></td>
<td>
<p>One of &quot;shape1&quot; or &quot;shape2&quot;; which set of fitted shape patterns to use.
See <code><a href="#topic+select_shape">select_shape()</a></code> for details.</p>
</td></tr>
<tr><td><code id="plot_cpam_+3A_bs">bs</code></td>
<td>
<p>Shape pattern to fit (&quot;null&quot;, &quot;lin&quot;, &quot;ilin&quot;, &quot;dlin&quot;, or from cpo$bss).
Use &quot;auto&quot; (default) to use estimated shapes as per <code>shape_type</code>.</p>
</td></tr>
<tr><td><code id="plot_cpam_+3A_cp_fix">cp_fix</code></td>
<td>
<p>Numeric; fixed changepoint time. Set to -1 (default) to use estimated changepoints</p>
</td></tr>
<tr><td><code id="plot_cpam_+3A_facet">facet</code></td>
<td>
<p>Logical; for multiple transcripts, plot in separate facets?</p>
</td></tr>
<tr><td><code id="plot_cpam_+3A_sp">sp</code></td>
<td>
<p>numerical; set the smooth parameter. NULL (default) for automatic selection</p>
</td></tr>
<tr><td><code id="plot_cpam_+3A_show_fit">show_fit</code></td>
<td>
<p>logical; show the fitted trend?</p>
</td></tr>
<tr><td><code id="plot_cpam_+3A_show_data">show_data</code></td>
<td>
<p>logical; show (possibly normalized and scaled) data points?</p>
</td></tr>
<tr><td><code id="plot_cpam_+3A_show_fit_ci">show_fit_ci</code></td>
<td>
<p>logical; show credible interval for the fitted trend?</p>
</td></tr>
<tr><td><code id="plot_cpam_+3A_show_data_ci">show_data_ci</code></td>
<td>
<p>logical; show bootstrapped quantile for data points?</p>
</td></tr>
<tr><td><code id="plot_cpam_+3A_ci_prob">ci_prob</code></td>
<td>
<p>&quot;se&quot; for standard error bands (see <code><a href="mgcv.html#topic+predict.gam">mgcv::predict.gam()</a></code>), or numeric for simulation-based intervals.
If numerical, sets the probability for the simulation-based estimates of credible interval.</p>
</td></tr>
<tr><td><code id="plot_cpam_+3A_remove_null">remove_null</code></td>
<td>
<p>logical; only plot differentially expressed transcripts (not applicable for gene-only analyses)</p>
</td></tr>
<tr><td><code id="plot_cpam_+3A_null_threshold">null_threshold</code></td>
<td>
<p>numeric; P value threshold for filtering out NULL transcripts</p>
</td></tr>
<tr><td><code id="plot_cpam_+3A_null_threshold_adj">null_threshold_adj</code></td>
<td>
<p>logical; use adjusted (default) or non-adjusted p-values for filtering targets</p>
</td></tr>
<tr><td><code id="plot_cpam_+3A_k_mult">k_mult</code></td>
<td>
<p>numerical; multiplier for the number of knots in the spline. Not recommended to change this value.</p>
</td></tr>
<tr><td><code id="plot_cpam_+3A_return_fits_only">return_fits_only</code></td>
<td>
<p>logical; return the model fits. Does not plot the function</p>
</td></tr>
<tr><td><code id="plot_cpam_+3A_family">family</code></td>
<td>
<p>character; negative binomial (&quot;nb&quot;, default) or Gaussian (&quot;gaussian&quot;)</p>
</td></tr>
<tr><td><code id="plot_cpam_+3A_common_y_scale">common_y_scale</code></td>
<td>
<p>logical; for faceted plots of multiple transcripts, should the scale of the y-axis
be common or free.</p>
</td></tr>
<tr><td><code id="plot_cpam_+3A_scaled">scaled</code></td>
<td>
<p>logical; scaled data by overdispersions (for bootstrapped data only)</p>
</td></tr>
<tr><td><code id="plot_cpam_+3A_base_size">base_size</code></td>
<td>
<p>numeric; base font size for the plot</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Plots the fitted trend and data points for a given gene or target. If a gene ID
is supplied, the function will plot all transcripts for that gene.
The function can also be used to return the model fit(s) only, which are
<code>gamObject</code> objects from the <code>mgcv</code> package.
</p>


<h3>Value</h3>

<p>a ggplot object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(cpam)

# load gene-only example cpam object
load(system.file("extdata", "cpo_example.rda", package = "cpam"))

# example gene
plot_cpam(cpo_example, gene_id = "g003")

# gene with estimated changepoint at timepoint 3
plot_cpam(cpo_example, gene_id = "g013")

# manually set the changepoint
plot_cpam(cpo_example, gene_id = "g013", cp_fix = 2)

</code></pre>

<hr>
<h2 id='prepare_cpam'>Prepare a cpam object</h2><span id='topic+prepare_cpam'></span>

<h3>Description</h3>

<p>Prepare a cpam object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prepare_cpam(
  exp_design,
  count_matrix = NULL,
  t2g = NULL,
  import_type = NULL,
  model_type = c("case-only", "case-control"),
  bootstrap = TRUE,
  filter_fun = "ts_filter",
  filter_fun_args = list(min_reads = 5, min_prop = 3/5),
  regularize = TRUE,
  gene_level = FALSE,
  aggregate_to_gene = !gene_level,
  condition_var = "condition",
  case_value = "treatment",
  num_cores = 1,
  normalize = TRUE,
  fixed_effects = NULL,
  intercept_cc = c("1", condition_var)
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="prepare_cpam_+3A_exp_design">exp_design</code></td>
<td>
<p>a dataframe or tibble with the experimental design, containing at least a 'time' and a 'sample' column</p>
</td></tr>
<tr><td><code id="prepare_cpam_+3A_count_matrix">count_matrix</code></td>
<td>
<p>a matrix of counts. Column names must be in 'sample' column of <code>exp_design</code>,</p>
</td></tr>
<tr><td><code id="prepare_cpam_+3A_t2g">t2g</code></td>
<td>
<p>a transcript to gene dataframe or tibble with columns target_id and gene_id</p>
</td></tr>
<tr><td><code id="prepare_cpam_+3A_import_type">import_type</code></td>
<td>
<p>software used for quantification, one of &quot;kallisto&quot;, &quot;salmon&quot; ,.... Ignored if <code>count_matrix</code> is supplied.</p>
</td></tr>
<tr><td><code id="prepare_cpam_+3A_model_type">model_type</code></td>
<td>
<p>&quot;case-only&quot; (default) or &quot;case-control&quot;</p>
</td></tr>
<tr><td><code id="prepare_cpam_+3A_bootstrap">bootstrap</code></td>
<td>
<p>logical; load bootstrap samples, also called inferential replicates, if available, and rescale counts.</p>
</td></tr>
<tr><td><code id="prepare_cpam_+3A_filter_fun">filter_fun</code></td>
<td>
<p>filter function to remove lowly expressed genes (default is <code>filter_fun()</code>)</p>
</td></tr>
<tr><td><code id="prepare_cpam_+3A_filter_fun_args">filter_fun_args</code></td>
<td>
<p>arguments for filter function</p>
</td></tr>
<tr><td><code id="prepare_cpam_+3A_regularize">regularize</code></td>
<td>
<p>logical; use empirical Bayes regularization of dispersions (default is TRUE)</p>
</td></tr>
<tr><td><code id="prepare_cpam_+3A_gene_level">gene_level</code></td>
<td>
<p>logical; aggregate counts to gene level before data preparation and modelling (default is FALSE)</p>
</td></tr>
<tr><td><code id="prepare_cpam_+3A_aggregate_to_gene">aggregate_to_gene</code></td>
<td>
<p>logical; aggregate p values from transcript- to gene-level</p>
</td></tr>
<tr><td><code id="prepare_cpam_+3A_condition_var">condition_var</code></td>
<td>
<p>string; column name in <code>exp_design</code> for the condition variable (for <code>model_type</code> = &quot;case_control&quot; only)</p>
</td></tr>
<tr><td><code id="prepare_cpam_+3A_case_value">case_value</code></td>
<td>
<p>value of <code>condition_var</code> that indicates the &quot;case&quot;. All other values are deemed to be control</p>
</td></tr>
<tr><td><code id="prepare_cpam_+3A_num_cores">num_cores</code></td>
<td>
<p>integer; number of cores to use for parallel computation</p>
</td></tr>
<tr><td><code id="prepare_cpam_+3A_normalize">normalize</code></td>
<td>
<p>logical; use model offsets based on sampling depth and gene length</p>
</td></tr>
<tr><td><code id="prepare_cpam_+3A_fixed_effects">fixed_effects</code></td>
<td>
<p>a model formula of the form <code>~ effect1 + effect2</code></p>
</td></tr>
<tr><td><code id="prepare_cpam_+3A_intercept_cc">intercept_cc</code></td>
<td>
<p>string; intercept for case-control model: &quot;1&quot; (default) for common intercept  or &quot;condition&quot;</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function prepares a cpam object for analysis.
The function loads count data from files or a matrix,
filters lowly expressed genes, computes normalisation factors,
and estimates dispersions. Many of these steps can be customised or turned off.
</p>
<p>When bootstrap samples (inferential replicates) are available, it loads and
summarises these using means, standard errors, and estimated overdispersions.
The latter are a measure of quantification uncertainty and they are used to
rescale the counts which accounts for this uncertainty during the modelling steps.
</p>


<h3>Value</h3>

<p>an object of class <code><a href="#topic+cpam-class">cpam-class</a></code>. The returned object has
methods <code>print</code> and <code>summary</code> for displaying information.
See <code><a href="#topic+cpam-class">cpam-class</a></code> for details on the structure of the returned object.
</p>


<h3>References</h3>

<p>Pedro L Baldoni, Yunshun Chen, Soroor Hediyeh-zadeh, Yang Liao, Xueyi Dong,
Matthew E Ritchie, Wei Shi, Gordon K Smyth,
Dividing out quantification uncertainty allows efficient assessment of
differential transcript expression with edgeR,
Nucleic Acids Research, Volume 52, Issue 3, 9 February 2024,
Page e13, https://doi.org/10.1093/nar/gkad1167
</p>
<p>Yunshun Chen, Lizhong Chen, Aaron T L Lun, Pedro L Baldoni, Gordon K Smyth,
edgeR v4: powerful differential analysis of sequencing data with
expanded functionality and improved support for small counts
and larger datasets, Nucleic Acids Research, Volume 53, Issue 2,
27 January 2025, https://doi.org/10.1093/nar/gkaf018
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(cpam)

# load gene-only example data
load(system.file("extdata", "exp_design_example.rda", package = "cpam"))
load(system.file("extdata", "count_matrix_example.rda", package = "cpam"))

cpo &lt;- prepare_cpam(exp_design = exp_design_example,
                    count_matrix = count_matrix_example,
                    gene_level = TRUE)
cpo

</code></pre>

<hr>
<h2 id='process_bootstrap_data'>Process bootstrap data</h2><span id='topic+process_bootstrap_data'></span>

<h3>Description</h3>

<p>Process bootstrap data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>process_bootstrap_data(data_long, catch, boot)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="process_bootstrap_data_+3A_data_long">data_long</code></td>
<td>
<p>Long format data</p>
</td></tr>
<tr><td><code id="process_bootstrap_data_+3A_catch">catch</code></td>
<td>
<p>Overdispersion calculations</p>
</td></tr>
<tr><td><code id="process_bootstrap_data_+3A_boot">boot</code></td>
<td>
<p>Bootstrap summary</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Updated data with bootstrap information
</p>

<hr>
<h2 id='process_count_matrix'>Process count matrix when importing is not needed</h2><span id='topic+process_count_matrix'></span>

<h3>Description</h3>

<p>Process count matrix when importing is not needed
</p>


<h3>Usage</h3>

<pre><code class='language-R'>process_count_matrix(count_matrix, t2g, gene_level)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="process_count_matrix_+3A_count_matrix">count_matrix</code></td>
<td>
<p>Count matrix</p>
</td></tr>
<tr><td><code id="process_count_matrix_+3A_t2g">t2g</code></td>
<td>
<p>Transcript to gene mapping</p>
</td></tr>
<tr><td><code id="process_count_matrix_+3A_gene_level">gene_level</code></td>
<td>
<p>Whether to aggregate to gene level</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Processed count matrix
</p>

<hr>
<h2 id='results'>Create a results table from a cpam object</h2><span id='topic+results'></span>

<h3>Description</h3>

<p>Create a results table from a cpam object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>results(
  cpo,
  p_threshold = 0.05,
  p_type = c("p_gam", "p_mvn"),
  min_lfc = 0,
  min_count = 0,
  aggregate_to_gene = cpo$aggregate_to_gene,
  add_lfc = TRUE,
  add_counts = TRUE,
  cp_type = c("cp_1se", "cp_min"),
  shape_type = c("shape1", "shape2"),
  summarise_to_gene = FALSE,
  remove_null_targets = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="results_+3A_cpo">cpo</code></td>
<td>
<p>a cpam object</p>
</td></tr>
<tr><td><code id="results_+3A_p_threshold">p_threshold</code></td>
<td>
<p>numerical; threshold for adjusted p-values; default is 0.05</p>
</td></tr>
<tr><td><code id="results_+3A_p_type">p_type</code></td>
<td>
<p>character; choose the type of p-value. Options are &quot;p_gam&quot; (default)
or &quot;p_mvn&quot; (see <code><a href="#topic+compute_p_values">compute_p_values()</a></code> for details).</p>
</td></tr>
<tr><td><code id="results_+3A_min_lfc">min_lfc</code></td>
<td>
<p>numerical; maximum absolute log (base 2) fold change must
exceed this minimum value; default is 0</p>
</td></tr>
<tr><td><code id="results_+3A_min_count">min_count</code></td>
<td>
<p>numerical; maximum of the modelled counts evaluated at
the set of observed time points must exceed this minimum value for</p>
</td></tr>
<tr><td><code id="results_+3A_aggregate_to_gene">aggregate_to_gene</code></td>
<td>
<p>logical; filter by gene-aggregated p-values</p>
</td></tr>
<tr><td><code id="results_+3A_add_lfc">add_lfc</code></td>
<td>
<p>logical; add log (base 2) fold changes for each time point</p>
</td></tr>
<tr><td><code id="results_+3A_add_counts">add_counts</code></td>
<td>
<p>logical; add modelled counts for each time point</p>
</td></tr>
<tr><td><code id="results_+3A_cp_type">cp_type</code></td>
<td>
<p>character; model-selection rule used to select the changepoint</p>
</td></tr>
<tr><td><code id="results_+3A_shape_type">shape_type</code></td>
<td>
<p>character; &quot;shape1&quot; to include unconstrained or otherwise &quot;shape2&quot;</p>
</td></tr>
<tr><td><code id="results_+3A_summarise_to_gene">summarise_to_gene</code></td>
<td>
<p>logical; return gene-level results only</p>
</td></tr>
<tr><td><code id="results_+3A_remove_null_targets">remove_null_targets</code></td>
<td>
<p>logical; remove targets with null shapes (default is T).
If F, targets with null shapes will be included if the aggregated p-value for
the corresponding gene passes the specified filtering thresholds.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is usually called after
<code><a href="#topic+compute_p_values">compute_p_values()</a></code>, <code><a href="#topic+estimate_changepoint">estimate_changepoint</a></code>, and <code>select_shape</code> have
been run. The function has several useful filters such as adjusted p-value
thresholds, minimum log-fold changes, and minimum counts.
</p>


<h3>Value</h3>

<p>a tibble
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(cpam)

# load gene-only example cpam object
load(system.file("extdata", "cpo_example.rda", package = "cpam"))

results(cpo_example)

# Add filters
results(cpo_example, p_threshold = 0.01, min_lfc = 1)

</code></pre>

<hr>
<h2 id='select_shape'>Use model selection to select a shape for each target</h2><span id='topic+select_shape'></span>

<h3>Description</h3>

<p>Use model selection to select a shape for each target
</p>


<h3>Usage</h3>

<pre><code class='language-R'>select_shape(
  cpo,
  subset = NULL,
  sp = NULL,
  bss = c("micv", "mdcx", "cv", "cx", "lin", "tp", "null"),
  family = c("nb", "gaussian"),
  score = "gcv",
  cp_type = c("cp_1se", "cp_min")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="select_shape_+3A_cpo">cpo</code></td>
<td>
<p>a cpam object</p>
</td></tr>
<tr><td><code id="select_shape_+3A_subset">subset</code></td>
<td>
<p>character vector; names of targets or genes (if <code>cpo$gene_level = T</code>)
for which changepoints will be estimated</p>
</td></tr>
<tr><td><code id="select_shape_+3A_sp">sp</code></td>
<td>
<p>numerical &gt;= 0; supply a fixed smoothing parameter. If NULL (default), the smoothing
parameter is estimated. Note, this fixed value is in any case applied only to
shape constrained bases (i.e., not <code>bs = 'tp'</code>).</p>
</td></tr>
<tr><td><code id="select_shape_+3A_bss">bss</code></td>
<td>
<p>character vector; names of candidate spline bases (i.e., candidate shape types).</p>
</td></tr>
<tr><td><code id="select_shape_+3A_family">family</code></td>
<td>
<p>character; negative binomial (&quot;nb&quot;, default) or Gaussian (&quot;gaussian&quot;)</p>
</td></tr>
<tr><td><code id="select_shape_+3A_score">score</code></td>
<td>
<p>character; model selection score, either Generalised Cross Validation (&quot;gcv&quot;) or
Akaike Information Criterion (&quot;aic&quot;)</p>
</td></tr>
<tr><td><code id="select_shape_+3A_cp_type">cp_type</code></td>
<td>
<p>character; if changepoints have been estimated using <code><a href="#topic+estimate_changepoint">estimate_changepoint()</a></code>,
which selection rule should be used. See <code><a href="#topic+estimate_changepoint">estimate_changepoint()</a></code> for details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function selects the best shape from a list of candidate shapes for each target.
It is typically the last step in the analysis, called after p-values have
been estimated using <code><a href="#topic+compute_p_values">compute_p_values()</a></code> and changepoints have
been estimated using <code><a href="#topic+estimate_changepoint">estimate_changepoint()</a></code>.
</p>
<p>Two shape selections are generated. The first selecting among linear,
convex and concave shape classes and their monotonic variants (or the shape
set given by bss), and the second selecting among the first options plus an
'unconstrained' smooth. The inclusion of the 'unconstrained' type provides
the flexibility to detect targets beyond simpler trends.
For computational reasons, as per the changepoint estimation,
shapes are selected only for those genes, or their isoforms,
identified as significant at the chosen FDR threshold. This is
overridden by providing a subset of target names to the <code>subset</code> argument,
provided these targets have estimated changepoints.
</p>


<h3>Value</h3>

<p>a cpam object with the selected shapes added to the slot &quot;shapes&quot;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(cpam)

# load example data
load(system.file("extdata", "exp_design_example.rda", package = "cpam"))
load(system.file("extdata", "count_matrix_example.rda", package = "cpam"))

# Using a small subset of the example data
cpo &lt;- prepare_cpam(exp_design = exp_design_example,
                    count_matrix = count_matrix_example[1:20,],
                    gene_level = TRUE,
                    num_cores = 1)
cpo &lt;- compute_p_values(cpo)
cpo &lt;- estimate_changepoint(cpo)
cpo &lt;- select_shape(cpo)
cpo$shapes


</code></pre>

<hr>
<h2 id='simulate_p_mvn'>Simulate p-values using multivariate normal distribution</h2><span id='topic+simulate_p_mvn'></span>

<h3>Description</h3>

<p>Simulate p-values using multivariate normal distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulate_p_mvn(score_table, nsim = 10000, reg = 0.001)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simulate_p_mvn_+3A_score_table">score_table</code></td>
<td>
<p>Table of model scores</p>
</td></tr>
<tr><td><code id="simulate_p_mvn_+3A_nsim">nsim</code></td>
<td>
<p>Number of simulations (default: 1e4)</p>
</td></tr>
<tr><td><code id="simulate_p_mvn_+3A_reg">reg</code></td>
<td>
<p>Regularization parameter for covariance matrix (default: 1e-3)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Uses Monte Carlo simulation to compute the probability that the null model
is the best scoring model under multivariate normal assumptions.
</p>


<h3>Value</h3>

<p>Probability that the null model is the best scoring model
</p>

<hr>
<h2 id='summarise_bootstraps'>Summarize bootstrap samples</h2><span id='topic+summarise_bootstraps'></span>

<h3>Description</h3>

<p>Internal function to process inferential replicates from tximport objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>summarise_bootstraps(txi)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summarise_bootstraps_+3A_txi">txi</code></td>
<td>
<p>A tximport object containing inferential replicates</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble with bootstrap summary statistics
</p>

<hr>
<h2 id='ts_filter'>Removes lowly expressed genes</h2><span id='topic+ts_filter'></span>

<h3>Description</h3>

<p>Removes lowly expressed genes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ts_filter(data, min_reads = 5, min_prop = 3/5)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ts_filter_+3A_data">data</code></td>
<td>
<p>A tibble or data.frame containing columns:
</p>

<ul>
<li><p> target_id (character): Transcript identifiers
</p>
</li>
<li><p> time (numeric): Time point of measurement
</p>
</li>
<li><p> counts (numeric): Read counts
</p>
</li></ul>
</td></tr>
<tr><td><code id="ts_filter_+3A_min_reads">min_reads</code></td>
<td>
<p>minimum reads per transcript per sample</p>
</td></tr>
<tr><td><code id="ts_filter_+3A_min_prop">min_prop</code></td>
<td>
<p>minimum proportion of samples that exceed <code>min_read</code> at a
given time point (default: 3/5)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Identifies targets that show strong and consistent expression in at least one timepoint.
For each timepoint, the function calculates the proportion of samples
where a targets exceeds <code>min_reads</code>. Targets are retained if they meet
the minimum proportion (<code>min_prop</code>) at any timepoint in the experiment.
</p>


<h3>Value</h3>

<p>a character vector of transcript IDs to keep
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data &lt;- dplyr::tibble(
  target_id = rep(paste0("t", 1:3), each = 6),
  time = rep(c(0, 4, 8), 6),
  counts = c(6,6,6, 0,0,0, 6,0,6, 0,6,6, 6,6,6, 6,0,0)
)
ts_filter(data)

</code></pre>

<hr>
<h2 id='validate_cores'>Validate and adjust number of cores</h2><span id='topic+validate_cores'></span>

<h3>Description</h3>

<p>Validate and adjust number of cores
</p>


<h3>Usage</h3>

<pre><code class='language-R'>validate_cores(num_cores)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="validate_cores_+3A_num_cores">num_cores</code></td>
<td>
<p>Number of cores requested</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Validated number of cores
</p>

<hr>
<h2 id='validate_inputs'>Validate input parameters for prepare_cpam</h2><span id='topic+validate_inputs'></span>

<h3>Description</h3>

<p>Validate input parameters for prepare_cpam
</p>


<h3>Usage</h3>

<pre><code class='language-R'>validate_inputs(
  exp_design,
  count_matrix,
  t2g,
  import_type,
  model_type,
  condition_var,
  case_value,
  fixed_effects,
  aggregate_to_gene,
  gene_level,
  import
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="validate_inputs_+3A_exp_design">exp_design</code></td>
<td>
<p>Experimental design data frame</p>
</td></tr>
<tr><td><code id="validate_inputs_+3A_count_matrix">count_matrix</code></td>
<td>
<p>Count matrix</p>
</td></tr>
<tr><td><code id="validate_inputs_+3A_t2g">t2g</code></td>
<td>
<p>Transcript to gene mapping</p>
</td></tr>
<tr><td><code id="validate_inputs_+3A_import_type">import_type</code></td>
<td>
<p>Import type</p>
</td></tr>
<tr><td><code id="validate_inputs_+3A_model_type">model_type</code></td>
<td>
<p>Model type</p>
</td></tr>
<tr><td><code id="validate_inputs_+3A_condition_var">condition_var</code></td>
<td>
<p>Condition variable</p>
</td></tr>
<tr><td><code id="validate_inputs_+3A_case_value">case_value</code></td>
<td>
<p>Case value</p>
</td></tr>
<tr><td><code id="validate_inputs_+3A_fixed_effects">fixed_effects</code></td>
<td>
<p>Fixed effects formula</p>
</td></tr>
<tr><td><code id="validate_inputs_+3A_aggregate_to_gene">aggregate_to_gene</code></td>
<td>
<p>Whether to aggregate to gene level</p>
</td></tr>
<tr><td><code id="validate_inputs_+3A_gene_level">gene_level</code></td>
<td>
<p>Whether data is at gene level</p>
</td></tr>
<tr><td><code id="validate_inputs_+3A_import">import</code></td>
<td>
<p>Whether to import data</p>
</td></tr>
</table>


<h3>Value</h3>

<p>NULL, throws error if validation fails
</p>

<hr>
<h2 id='visualise'>Launches a Shiny app to visualise the data and fitted models of a cpam object</h2><span id='topic+visualise'></span><span id='topic+visualize'></span>

<h3>Description</h3>

<p>Launches a Shiny app to visualise the data and fitted models of a cpam object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>visualise(
  cpo,
  subset = NULL,
  degs_only = TRUE,
  deg_threshold = 0.05,
  p_type = c("p_gam", "p_mvn"),
  shape_type = c("shape1", "shape2")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="visualise_+3A_cpo">cpo</code></td>
<td>
<p>A cpam object containing count data, model fits, and optional changepoint/shape estimates</p>
</td></tr>
<tr><td><code id="visualise_+3A_subset">subset</code></td>
<td>
<p>Character vector; names of targets or genes (if <code>cpo$gene_level = TRUE</code>)
to load into the Shiny app. If NULL, all genes/targets are included based on <code>degs_only</code>.</p>
</td></tr>
<tr><td><code id="visualise_+3A_degs_only">degs_only</code></td>
<td>
<p>Logical; if TRUE, display only differentially expressed genes/targets
with adjusted p-value below <code>deg_threshold</code>. Default is TRUE.</p>
</td></tr>
<tr><td><code id="visualise_+3A_deg_threshold">deg_threshold</code></td>
<td>
<p>Numeric; significance threshold for differentially expressed genes/targets.
Only used when <code>degs_only = TRUE</code>. Default is 0.05.</p>
</td></tr>
<tr><td><code id="visualise_+3A_p_type">p_type</code></td>
<td>
<p>character; choose the type of p-value. Options are &quot;p_gam&quot; (default)
or &quot;p_mvn&quot; (see <code><a href="#topic+compute_p_values">compute_p_values()</a></code> for details).</p>
</td></tr>
<tr><td><code id="visualise_+3A_shape_type">shape_type</code></td>
<td>
<p>character; &quot;shape1&quot; to include unconstrained or otherwise &quot;shape2&quot;.
Default is &quot;shape1&quot;. In some instances, all of the transcripts for a gene may be &quot;null&quot; shaped,
but the p-value for the gene may still be significant. This is due to the different
methods of determining significance for the changepoints and the gene-level p-values.
Here, conservatively, we remove these null-shaped genes from the DEG list.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None (launches Shiny app in browser)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (interactive()){

# A simple gene-level example
cpo &lt;- cpo_example

# Launch visualization with all genes
visualise(cpo, degs_only = FALSE)

# Launch with only significant genes
visualise(cpo, deg_threshold = 0.05)

# Launch with specific genes
visualise(cpo, subset = c("g001","g002","g003"))
}
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
