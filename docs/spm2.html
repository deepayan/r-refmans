<!DOCTYPE html><html><head><title>Help for package spm2</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {spm2}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#bees'><p>A dataset of bees count data and relevant information in oilseed Brassica fields in an Australian temperate landscape.</p></a></li>
<li><a href='#ccr'><p>Correct classification rate for predictive models based on cross</p>
-validation</a></li>
<li><a href='#cran-comments'>
<p>Note on notes</p></a></li>
<li><a href='#datasplit'><p>Split data for k-fold cross-validation</p></a></li>
<li><a href='#decimaldigit'><p>Digit number after decimal point for a numeric variable</p></a></li>
<li><a href='#gbmkrigeidwcv'><p>Cross validation, n-fold and leave-one-out for the hybrid methods of</p>
generalized boosted regression modeling ('gbm'), 'kriging' and
inverse distance weighted ('IDW').</a></li>
<li><a href='#gbmkrigeidwpred'><p>Generate spatial predictions using the hybrid methods of</p>
generalized boosted regression modeling ('gbm'), 'kriging' and inverse distance weighted ('IDW').</a></li>
<li><a href='#glmcv'><p>Cross validation, n-fold and leave-one-out for generalised linear models  ('glm')</p></a></li>
<li><a href='#glmidwcv'><p>Cross validation, n-fold and leave-one-out for the hybrid method of</p>
generalised linear models  ('glm') and inverse distance weighted ('IDW') ('glmidw')</a></li>
<li><a href='#glmidwpred'><p>Generate spatial predictions using the hybrid method of generalised</p>
linear models  ('glm') and inverse distance weighted ('IDW') ('glmidw')</a></li>
<li><a href='#glmkrigecv'><p>Cross validation, n-fold and leave-one-out for the hybrid method of</p>
generalised linear models  ('glm') and 'krige' ('glmkrige')</a></li>
<li><a href='#glmkrigeidwcv'><p>Cross validation, n-fold and leave-one-out for the hybrid methods of</p>
generalised linear models  ('glm'), 'kriging' and inverse distance weighted ('IDW').</a></li>
<li><a href='#glmkrigeidwpred'><p>Generate spatial predictions using the hybrid methods of</p>
generalised linear models  ('glm'), 'kriging' and inverse distance weighted ('IDW').</a></li>
<li><a href='#glmkrigepred'><p>Generate spatial predictions using the hybrid method of generalised</p>
linear models  ('glm') and 'krige'</a></li>
<li><a href='#glmnetcv'><p>Cross validation, n-fold and leave-one-out, for 'glmnet' in 'glmnet' package</p></a></li>
<li><a href='#glmpred'><p>Generate spatial predictions using generalised linear models  ('glm')</p></a></li>
<li><a href='#glscv'><p>Cross validation, n-fold and leave-one-out for generalized least squares ('gls')</p></a></li>
<li><a href='#glsidwcv'><p>Cross validation, n-fold and leave-one-out for the hybrid method of</p>
generalized least squares ('gls') and inverse distance weighted ('idw')
(glsidw)</a></li>
<li><a href='#glsidwpred'><p>Generate spatial predictions using the hybrid method of generalized</p>
least squares ('gls')  and inverse distance weighted ('IDW') ('glsidw')</a></li>
<li><a href='#glskrigecv'><p>Cross validation, n-fold and leave-one-out for the hybrid method of</p>
generalized least squares ('gls') and kriging ('krige') ('glskrige')</a></li>
<li><a href='#glskrigeidwcv'><p>Cross validation, n-fold and leave-one-out for the hybrid methods of</p>
generalised least squares ('gls'), 'kriging' and inverse distance weighted ('IDW')</a></li>
<li><a href='#glskrigeidwpred'><p>Generate spatial predictions using the hybrid methods of</p>
generalised least squares ('gls'), 'kriging' and inverse distance weighted ('IDW')</a></li>
<li><a href='#glskrigepred'><p>Generate spatial predictions using the hybrid method of generalized</p>
least squares ('gls') and kriging ('krige') ('glskrige')</a></li>
<li><a href='#glspred'><p>Generate spatial predictions using generalized least squares ('gls')</p></a></li>
<li><a href='#krigecv'><p>Cross validation, n-fold and leave-one-out for kriging methods ('krige')</p></a></li>
<li><a href='#krigepred'><p>Generate spatial predictions using kriging methods ('krige')</p></a></li>
<li><a href='#rfkrigeidwcv'><p>Cross validation, n-fold and leave-one-out for the hybrid methods of</p>
'random forest' ('RF'), 'kriging' and inverse distance weighted ('IDW')</a></li>
<li><a href='#rfkrigeidwpred'><p>Generate spatial predictions using the hybrid methods of 'random forest' ('RF'),</p>
'kriging' and inverse distance weighted ('IDW').</a></li>
<li><a href='#sponge2'><p>A dataset of sponge species richness in the Timor Sea region, northern Australia marine margin</p></a></li>
<li><a href='#spongelonglat'><p>A dataset of sponge species richness in the Timor Sea region, northern Australia marine margin</p></a></li>
<li><a href='#svmcv'><p>Cross validation, n-fold and leave-one-out for support vector machine ('svm')</p></a></li>
<li><a href='#svmidwcv'><p>Cross validation, n-fold and leave-one-out for the hybrid method of support vector machine ('svm')</p>
regression and inverse distance weighted ('IDW') (svmidw)</a></li>
<li><a href='#svmidwpred'><p>Generate spatial predictions using the hybrid method of support vector machine ('svm')</p>
regression and inverse distance weighted ('IDW') ('svmidw')</a></li>
<li><a href='#svmkrigecv'><p>Cross validation, n-fold and leave-one-out for the hybrid method of support vector machine ('svm')</p>
regression and 'krige' (svmkrige)</a></li>
<li><a href='#svmkrigeidwcv'><p>Cross validation, n-fold and leave-one-out for the hybrid methods of</p>
support vector machine ('svm') regression , 'kriging' and inverse distance weighted ('IDW').</a></li>
<li><a href='#svmkrigeidwpred'><p>Generate spatial predictions using the hybrid methods of</p>
support vector machine ('svm') regression , 'kriging' and inverse distance weighted ('IDW').</a></li>
<li><a href='#svmkrigepred'><p>Generate spatial predictions using the hybrid method of support</p>
vector machine ('svm') regression and 'krige' (svmkrige)</a></li>
<li><a href='#svmpred'><p>Generate spatial predictions using support vector machine ('svm')</p></a></li>
<li><a href='#tpscv'><p>Cross validation, n-fold and leave-one-out for thin plate splines ('TPS')</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Spatial Predictive Modeling</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1.3</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-04-05</td>
</tr>
<tr>
<td>Description:</td>
<td>An updated and extended version of 'spm' package, by introducing some further novel functions for modern statistical methods (i.e., generalised linear models, glmnet, generalised least squares), thin plate splines, support vector machine, kriging methods (i.e., simple kriging, universal kriging, block kriging, kriging with an external drift), and novel hybrid methods (228 hybrids plus numerous variants) of modern statistical methods or machine learning methods with mathematical and/or univariate geostatistical methods for spatial predictive modelling. For each method, two functions are provided, with one function for assessing the predictive errors and accuracy of the method based on cross-validation, and the other for generating spatial predictions. It also contains a couple of functions for data preparation and predictive accuracy assessment. </td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>Imports:</td>
<td>spm, gstat, sp, randomForest, gbm, stats, fields, nlme,
glmnet, e1071</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-04-06 04:45:43 UTC; Jin</td>
</tr>
<tr>
<td>Author:</td>
<td>Jin Li [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Jin Li &lt;jinli68@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-04-06 12:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='bees'>A dataset of bees count data and relevant information in oilseed Brassica fields in an Australian temperate landscape.
</h2><span id='topic+bees'></span>

<h3>Description</h3>

<p>This dataset contains 212 samples of 61 variables including three bee species, inflorescence, temperature, wid speed and various derived landscape variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("bees")</code></pre>


<h3>Format</h3>

<p>A data frame with 212 observations on the following 61 variables.
</p>

<dl>
<dt><code>transid</code></dt><dd><p>a factor with levels <code>G1</code> <code>G10</code> <code>G11</code> <code>G12</code> <code>G13</code> <code>G14</code> <code>G15</code> <code>G16</code> <code>G1D1</code> <code>G1D10</code> <code>G1D11</code> <code>G1D12</code> <code>G1D13</code> <code>G1D14</code> <code>G1D15</code> <code>G1D16</code> <code>G1D17</code> <code>G1D2</code> <code>G1D3</code> <code>G1D4</code> <code>G1D5</code> <code>G1D6</code> <code>G1D7</code> <code>G1D8</code> <code>G1D9</code> <code>G1G1</code> <code>G1G10</code> <code>G1G11</code> <code>G1G12</code> <code>G1G13</code> <code>G1G14</code> <code>G1G15</code> <code>G1G16</code> <code>G1G17</code> <code>G1G2</code> <code>G1G3</code> <code>G1G4</code> <code>G1G5</code> <code>G1G6</code> <code>G1G7</code> <code>G1G8</code> <code>G1G9</code> <code>G2</code> <code>G2H1</code> <code>G2H10</code> <code>G2H11</code> <code>G2H2</code> <code>G2H3</code> <code>G2H4</code> <code>G2H5</code> <code>G2H6</code> <code>G2H7</code> <code>G2H8</code> <code>G2H9</code> <code>G2S1</code> <code>G2S10</code> <code>G2S11</code> <code>G2S2</code> <code>G2S3</code> <code>G2S4</code> <code>G2S5</code> <code>G2S6</code> <code>G2S7</code> <code>G2S8</code> <code>G2S9</code> <code>G3</code> <code>G4</code> <code>G5</code> <code>G6</code> <code>G7</code> <code>G8</code> <code>G9</code> <code>GCH1</code> <code>GCH10</code> <code>GCH11</code> <code>GCH12</code> <code>GCH13</code> <code>GCH14</code> <code>GCH15</code> <code>GCH16</code> <code>GCH17</code> <code>GCH18</code> <code>GCH2</code> <code>GCH3</code> <code>GCH4</code> <code>GCH5</code> <code>GCH6</code> <code>GCH7</code> <code>GCH8</code> <code>GCH9</code> <code>GCS1</code> <code>GCS10</code> <code>GCS11</code> <code>GCS12</code> <code>GCS13</code> <code>GCS14</code> <code>GCS15</code> <code>GCS16</code> <code>GCS17</code> <code>GCS18</code> <code>GCS2</code> <code>GCS3</code> <code>GCS4</code> <code>GCS5</code> <code>GCS6</code> <code>GCS7</code> <code>GCS8</code> <code>GCS9</code> <code>H1</code> <code>H10</code> <code>H11</code> <code>H12</code> <code>H13</code> <code>H14</code> <code>H15</code> <code>H16</code> <code>H2</code> <code>H3</code> <code>H4</code> <code>H5</code> <code>H6</code> <code>H7</code> <code>H8</code> <code>H9</code> <code>MC1G1</code> <code>MC1G2</code> <code>MC1G3</code> <code>MC1G4</code> <code>MC1G5</code> <code>MC1G6</code> <code>MC1G7</code> <code>MC1G8</code> <code>MC1G9</code> <code>MC1H1</code> <code>MC1H2</code> <code>MC1H3</code> <code>MC1H4</code> <code>MC1H5</code> <code>MC1H6</code> <code>MC1H7</code> <code>MC1H8</code> <code>MC1H9</code> <code>MC2AH1</code> <code>MC2AH10</code> <code>MC2AH11</code> <code>MC2AH12</code> <code>MC2AH13</code> <code>MC2AH14</code> <code>MC2AH15</code> <code>MC2AH16</code> <code>MC2AH17</code> <code>MC2AH18</code> <code>MC2AH2</code> <code>MC2AH3</code> <code>MC2AH4</code> <code>MC2AH5</code> <code>MC2AH6</code> <code>MC2AH7</code> <code>MC2AH8</code> <code>MC2AH9</code> <code>MC2AS1</code> <code>MC2AS10</code> <code>MC2AS11</code> <code>MC2AS12</code> <code>MC2AS13</code> <code>MC2AS14</code> <code>MC2AS15</code> <code>MC2AS16</code> <code>MC2AS17</code> <code>MC2AS18</code> <code>MC2AS2</code> <code>MC2AS3</code> <code>MC2AS4</code> <code>MC2AS5</code> <code>MC2AS6</code> <code>MC2AS7</code> <code>MC2AS8</code> <code>MC2AS9</code> <code>MC2BB1</code> <code>MC2BB10</code> <code>MC2BB11</code> <code>MC2BB12</code> <code>MC2BB13</code> <code>MC2BB14</code> <code>MC2BB15</code> <code>MC2BB16</code> <code>MC2BB17</code> <code>MC2BB2</code> <code>MC2BB3</code> <code>MC2BB4</code> <code>MC2BB5</code> <code>MC2BB6</code> <code>MC2BB7</code> <code>MC2BB8</code> <code>MC2BB9</code> <code>MC2BG1</code> <code>MC2BG10</code> <code>MC2BG11</code> <code>MC2BG12</code> <code>MC2BG13</code> <code>MC2BG14</code> <code>MC2BG15</code> <code>MC2BG16</code> <code>MC2BG17</code> <code>MC2BG2</code> <code>MC2BG3</code> <code>MC2BG4</code> <code>MC2BG5</code> <code>MC2BG6</code> <code>MC2BG7</code> <code>MC2BG8</code> <code>MC2BG9</code></p>
</dd>
<dt><code>transsurv</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>plotsurv</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>paddock</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>plot</code></dt><dd><p>a factor with levels <code>G1-1</code> <code>G1-10</code> <code>G1-11</code> <code>G1-12</code> <code>G1-13</code> <code>G1-14</code> <code>G1-15</code> <code>G1-16</code> <code>G1-17</code> <code>G1-2</code> <code>G1-3</code> <code>G1-4</code> <code>G1-5</code> <code>G1-6</code> <code>G1-7</code> <code>G1-8</code> <code>G1-9</code> <code>G21</code> <code>G210</code> <code>G211</code> <code>G22</code> <code>G23</code> <code>G24</code> <code>G25</code> <code>G26</code> <code>G27</code> <code>G28</code> <code>G29</code> <code>GC1</code> <code>GC10</code> <code>GC11</code> <code>GC12</code> <code>GC13</code> <code>GC14</code> <code>GC15</code> <code>GC16</code> <code>GC17</code> <code>GC18</code> <code>GC2</code> <code>GC3</code> <code>GC4</code> <code>GC5</code> <code>GC6</code> <code>GC7</code> <code>GC8</code> <code>GC9</code> <code>MC-1</code> <code>MC-10</code> <code>MC-11</code> <code>MC-12</code> <code>MC-13</code> <code>MC-14</code> <code>MC-15</code> <code>MC-16</code> <code>MC-2</code> <code>MC-3</code> <code>MC-4</code> <code>MC-5</code> <code>MC-6</code> <code>MC-7</code> <code>MC-8</code> <code>MC-9</code> <code>MC1-1</code> <code>MC1-2</code> <code>MC1-3</code> <code>MC1-4</code> <code>MC1-5</code> <code>MC1-6</code> <code>MC1-7</code> <code>MC1-8</code> <code>MC1-9</code> <code>MC2-A1</code> <code>MC2-A10</code> <code>MC2-A11</code> <code>MC2-A12</code> <code>MC2-A13</code> <code>MC2-A14</code> <code>MC2-A15</code> <code>MC2-A16</code> <code>MC2-A17</code> <code>MC2-A18</code> <code>MC2-A2</code> <code>MC2-A3</code> <code>MC2-A4</code> <code>MC2-A5</code> <code>MC2-A6</code> <code>MC2-A7</code> <code>MC2-A8</code> <code>MC2-A9</code> <code>MC2-B1</code> <code>MC2-B10</code> <code>MC2-B11</code> <code>MC2-B12</code> <code>MC2-B13</code> <code>MC2-B14</code> <code>MC2-B15</code> <code>MC2-B16</code> <code>MC2-B17</code> <code>MC2-B2</code> <code>MC2-B3</code> <code>MC2-B4</code> <code>MC2-B5</code> <code>MC2-B6</code> <code>MC2-B7</code> <code>MC2-B8</code> <code>MC2-B9</code></p>
</dd>
<dt><code>obs</code></dt><dd><p>a factor with levels <code>Andrew</code> <code>Barbara</code> <code>Micah</code> <code>Sonia</code> <code>Steve</code></p>
</dd>
<dt><code>hbee</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>nbee</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>hover</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>date</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>sx</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>fx</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>sy</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>fy</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>loc</code></dt><dd><p>a factor with levels <code>100</code> <code>150</code> <code>200</code> <code>400</code> <code>450</code> <code>edge</code></p>
</dd>
<dt><code>pair</code></dt><dd><p>a factor with levels <code>I</code> <code>O</code></p>
</dd>
<dt><code>inf</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>rankinf</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>dupl</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>temp</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>windspeed</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>winddir</code></dt><dd><p>a factor with levels <code>N</code> <code>NE</code> <code>NNE</code> <code>NNW</code> <code>NW</code></p>
</dd>
<dt><code>cloudc</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>disttoedgecalc</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>disttoedgemeasured</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>w100</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>w200</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>w300</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>w400</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>w500</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>w600</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>w700</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>w800</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>w900</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>w1000</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>w1500</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>w2000</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>c100</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>c200</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>c300</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>c400</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>c500</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>c1000</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>c1500</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>area</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>perimeter</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>gyration</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>paratio</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>shape</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>fractaldimention</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>circumscircle</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>contiguity</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>links100</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>links200</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>links300</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>links400</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>links500</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>links1000</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>links1500</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>links2000</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>windspeed2</code></dt><dd><p>a numeric vector</p>
</dd>
</dl>



<h3>Details</h3>

<p>For details, please see the source. This dataset was published as an appendix of the paper listed in the source. Where the long and lat were reprojected to easting and northing
</p>


<h3>Source</h3>

<p>The data source is [https://doi.org/10.25919/5f17b34638cca] or [https://data.csiro.au/collections/collection/CIcsiro:45533], which provides bees count data and relevant predictive variables along with a brief description of the data. The detailed descriptions of the data are available in: &quot;Arthur, A. D., et al. (2010). &quot;Influence of woody vegetation on pollinator densities in oilseed Brassica fields in an Australian temperate landscape.&quot; Basic and Applied Ecology 11: 406-414.&quot;
</p>


<h3>References</h3>

<p>Arthur, A. D., Li, J., Henry, S., Cunningham, S.A. (2010). &quot;Influence of woody vegetation on pollinator densities in oilseed Brassica fields in an Australian temperate landscape.&quot; Basic and Applied Ecology 11: 406-414.
</p>

<hr>
<h2 id='ccr'>Correct classification rate for predictive models based on cross
-validation</h2><span id='topic+ccr'></span>

<h3>Description</h3>

<p>This function is to calculates correct classification
rate (ccr) for categorical data with the observed (obs) data specified
as factor. It based on the differences between the predicted values for
and the observed values of validation samples for cross-validation. For 0
and 1 data, the observed values need to be specified as factor in order
to use this accuracy measure. It is modified from the function 'pred.acc'
in 'spm' package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ccr(obs, pred)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ccr_+3A_obs">obs</code></td>
<td>
<p>a vector of observation values of validation samples.</p>
</td></tr>
<tr><td><code id="ccr_+3A_pred">pred</code></td>
<td>
<p>a vector of prediction values of predictive models for validation samples.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following component:
ccr (correct classification rate) for categorical data.
</p>


<h3>Author(s)</h3>

<p>Jin Li
</p>


<h3>References</h3>

<p>Jin Li (2019). spm: Spatial Predictive Modeling. R package
version 1.2.0. https://CRAN.R-project.org/package=spm.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1234)
x &lt;- as.factor(sample(letters[1:2], 30, TRUE))
y &lt;- sample(x, 30)
ccr(x, y)

</code></pre>

<hr>
<h2 id='cran-comments'>
Note on notes
</h2><span id='topic+cran-comments'></span>

<h3>Description</h3>

<p>This is an updated and extended version of &lsquo;spm' package. The change in package name from 'spm' to 'spm2' is due to the change in Author&rsquo;s support from Geoscience Australia to Data2Action Australia.
</p>
<p>## R CMD check results
0 errors | 0 warnings | 0 notes
</p>


<h3>Author(s)</h3>

<p>Jin Li
</p>

<hr>
<h2 id='datasplit'>Split data for k-fold cross-validation</h2><span id='topic+datasplit'></span>

<h3>Description</h3>

<p>This function is a data splitting function for k-fold cross-
validation and uses a stratified random sampling technique. It resamples the
training data based on sample quantiles.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>datasplit(trainy, k.fold = 10)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="datasplit_+3A_trainy">trainy</code></td>
<td>
<p>a vector of response, must have a length equal to sample size.</p>
</td></tr>
<tr><td><code id="datasplit_+3A_k.fold">k.fold</code></td>
<td>
<p>integer; number of folds in the cross-validation. if &gt; 1,
then apply k-fold cross validation; the default is 10, i.e., 10-fold cross
validation that is recommended.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of samples each with an index of k-fold number.
</p>


<h3>Note</h3>

<p>This function is largely based on rfcv in randomForest.
</p>


<h3>Author(s)</h3>

<p>Jin Li
</p>


<h3>References</h3>

<p>A. Liaw and M. Wiener (2002). Classification and Regression
by randomForest. R News 2(3), 18-22.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(spm)
data(petrel)
idx1 &lt;- datasplit(petrel[, 3], k.fold = 10)
table(idx1)

</code></pre>

<hr>
<h2 id='decimaldigit'>Digit number after decimal point for a numeric variable</h2><span id='topic+decimaldigit'></span>

<h3>Description</h3>

<p>This function is to derive the digit number after decimal point for a
numeric variable (e.g., lat and long).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>decimaldigit(x, dechar = ".", nint = NA, ndec = NA, pad.left = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="decimaldigit_+3A_x">x</code></td>
<td>
<p>one or more decimal numbers.</p>
</td></tr>
<tr><td><code id="decimaldigit_+3A_dechar">dechar</code></td>
<td>
<p>The character used to separate the decimal part of a number.</p>
</td></tr>
<tr><td><code id="decimaldigit_+3A_nint">nint</code></td>
<td>
<p>The number of characters to which the integer part of the numbers should be padded.</p>
</td></tr>
<tr><td><code id="decimaldigit_+3A_ndec">ndec</code></td>
<td>
<p>The number of characters to which the decimal part of the numbers should be padded.</p>
</td></tr>
<tr><td><code id="decimaldigit_+3A_pad.left">pad.left</code></td>
<td>
<p>Whether the left (integer) side of the numbers should be padded as well as the right.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of integer number to show digit number after decimal point of x.
</p>


<h3>Note</h3>

<p>This function is modified from decimal.align in 'prettyR' package.
</p>


<h3>Author(s)</h3>

<p>Jin Li
</p>


<h3>References</h3>

<p>Jim Lemon and Philippe Grosjean (2019). 'prettyR': Pretty Descriptive Stats. R package version 2.1.1.
https://CRAN.R-project.org/package=prettyR.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x&lt;-c(0.1, 2.2, 3.03, 44.444, 555.0005, 6666.66666)
decimaldigit(x)

</code></pre>

<hr>
<h2 id='gbmkrigeidwcv'>Cross validation, n-fold and leave-one-out for the hybrid methods of
generalized boosted regression modeling ('gbm'), 'kriging' and
inverse distance weighted ('IDW').</h2><span id='topic+gbmkrigeidwcv'></span>

<h3>Description</h3>

<p>This function is a cross validation function for 38 hybrid
methods of 'gbm', 'kriging' and 'IDW', including the average of 'gbmkrige'
and 'gbmidw' ('gbmkrigegbmidw') and  the average of 'gbm', 'gbmkrige' and 'gbmidw'
('gbmgbmkrigegbmidw'), where 'kriging' methods include ordinary kriging
('OK'), simple kriging ('SK'), block 'OK' ('BOK') and block 'SK'('BSK')
and 'IDW' also covers 'NN' and 'KNN'. The data splitting is based on a stratified
random sampling method (see the 'datasplit' function for details).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gbmkrigeidwcv(
  longlat,
  trainx,
  trainy,
  var.monotone = rep(0, ncol(trainx)),
  family = "gaussian",
  n.trees = 3000,
  learning.rate = 0.001,
  interaction.depth = 2,
  bag.fraction = 0.5,
  train.fraction = 1,
  n.minobsinnode = 10,
  transformation = "none",
  weights = rep(1, nrow(trainx)),
  keep.data = FALSE,
  verbose = TRUE,
  delta = 1,
  formula = res1 ~ 1,
  vgm.args = "Sph",
  anis = c(0, 1),
  alpha = 0,
  block = 0,
  beta,
  nmaxkrige = 12,
  idp = 2,
  nmaxidw = 12,
  hybrid.parameter = 2,
  lambda = 1,
  validation = "CV",
  cv.fold = 10,
  predacc = "VEcv",
  n.cores = 6,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gbmkrigeidwcv_+3A_longlat">longlat</code></td>
<td>
<p>a dataframe contains longitude and latitude of point samples.</p>
</td></tr>
<tr><td><code id="gbmkrigeidwcv_+3A_trainx">trainx</code></td>
<td>
<p>a dataframe or matrix contains columns of predictive variables.</p>
</td></tr>
<tr><td><code id="gbmkrigeidwcv_+3A_trainy">trainy</code></td>
<td>
<p>a vector of the response variable.</p>
</td></tr>
<tr><td><code id="gbmkrigeidwcv_+3A_var.monotone">var.monotone</code></td>
<td>
<p>an optional vector, the same length as the number of
predictors, indicating which variables have a monotone increasing (+1),
decreasing (-1), or arbitrary (0) relationship with the outcome. By default,
a vector of 0 is used.</p>
</td></tr>
<tr><td><code id="gbmkrigeidwcv_+3A_family">family</code></td>
<td>
<p>either a character string specifying the name of the distribution to
use or a list with a component name specifying the distribution and any
additional parameters needed. See gbm for details. By default, &quot;gaussian&quot; is
used.</p>
</td></tr>
<tr><td><code id="gbmkrigeidwcv_+3A_n.trees">n.trees</code></td>
<td>
<p>the total number of trees to fit. This is equivalent to the
number of iterations and the number of basis functions in the additive
expansion. By default, 3000 is used.</p>
</td></tr>
<tr><td><code id="gbmkrigeidwcv_+3A_learning.rate">learning.rate</code></td>
<td>
<p>a shrinkage parameter applied to each tree in the
expansion. Also known as step-size reduction.</p>
</td></tr>
<tr><td><code id="gbmkrigeidwcv_+3A_interaction.depth">interaction.depth</code></td>
<td>
<p>the maximum depth of variable interactions.
1 implies an additive model, 2 implies a model with up to 2-way
interactions, etc. By default, 2 is used.</p>
</td></tr>
<tr><td><code id="gbmkrigeidwcv_+3A_bag.fraction">bag.fraction</code></td>
<td>
<p>the fraction of the training set observations randomly
selected to propose the next tree in the expansion. By default, 0.5 is used.</p>
</td></tr>
<tr><td><code id="gbmkrigeidwcv_+3A_train.fraction">train.fraction</code></td>
<td>
<p>The first train.fraction * nrows(data) observations
are used to fit the gbm and the remainder are used for computing
out-of-sample estimates of the loss function.</p>
</td></tr>
<tr><td><code id="gbmkrigeidwcv_+3A_n.minobsinnode">n.minobsinnode</code></td>
<td>
<p>minimum number of observations in the trees terminal
nodes. Note that this is the actual number of observations not the total
weight. By default, 10 is used.</p>
</td></tr>
<tr><td><code id="gbmkrigeidwcv_+3A_transformation">transformation</code></td>
<td>
<p>transform the residuals of 'gbm' to normalize the data for 'krige';
can be &quot;sqrt&quot; for square root, &quot;arcsine&quot; for arcsine, &quot;log&quot; or &quot;none&quot;
for non transformation. By default, &quot;none&quot; is used.</p>
</td></tr>
<tr><td><code id="gbmkrigeidwcv_+3A_weights">weights</code></td>
<td>
<p>an optional vector of weights to be used in the fitting
process. Must be positive but do not need to be normalized.
If keep.data = FALSE in the initial call to gbm then it is the user's
responsibility to resupply the weights to gbm.more. By default, a vector of
1 is used.</p>
</td></tr>
<tr><td><code id="gbmkrigeidwcv_+3A_keep.data">keep.data</code></td>
<td>
<p>a logical variable indicating whether to keep the data and
an index of the data stored with the object. Keeping the data and index
makes subsequent calls to gbm.more faster at the cost of storing an extra
copy of the dataset. By default, 'FALSE' is used.</p>
</td></tr>
<tr><td><code id="gbmkrigeidwcv_+3A_verbose">verbose</code></td>
<td>
<p>If TRUE, gbm will print out progress and performance
indicators. By default, 'TRUE' is used.</p>
</td></tr>
<tr><td><code id="gbmkrigeidwcv_+3A_delta">delta</code></td>
<td>
<p>numeric; to avoid log(0) in the log transformation. The default is 1.</p>
</td></tr>
<tr><td><code id="gbmkrigeidwcv_+3A_formula">formula</code></td>
<td>
<p>formula defining the response vector and (possible) regressor.
an object (i.e., 'variogram.formula') for 'variogram' or a formula for
'krige'. see 'variogram' and 'krige' in 'gstat' for details. The default is
'formula = res1 ~ 1'.</p>
</td></tr>
<tr><td><code id="gbmkrigeidwcv_+3A_vgm.args">vgm.args</code></td>
<td>
<p>arguments for 'vgm', e.g. variogram model of response
variable and anisotropy parameters. see 'vgm' in 'gstat' for details.
By default, &quot;Sph&quot; is used.</p>
</td></tr>
<tr><td><code id="gbmkrigeidwcv_+3A_anis">anis</code></td>
<td>
<p>anisotropy parameters: see notes 'vgm' in 'gstat' for details.</p>
</td></tr>
<tr><td><code id="gbmkrigeidwcv_+3A_alpha">alpha</code></td>
<td>
<p>direction in plane (x,y). see variogram in 'gstat' for details.</p>
</td></tr>
<tr><td><code id="gbmkrigeidwcv_+3A_block">block</code></td>
<td>
<p>block size. see 'krige' in 'gstat' for details.</p>
</td></tr>
<tr><td><code id="gbmkrigeidwcv_+3A_beta">beta</code></td>
<td>
<p>for simple kriging. see 'krige' in 'gstat' for details.</p>
</td></tr>
<tr><td><code id="gbmkrigeidwcv_+3A_nmaxkrige">nmaxkrige</code></td>
<td>
<p>for a local predicting: the number of nearest observations that
should be used for a prediction or simulation, where nearest is defined in
terms of the space of the spatial locations. By default, 12 observations
are used.</p>
</td></tr>
<tr><td><code id="gbmkrigeidwcv_+3A_idp">idp</code></td>
<td>
<p>a numeric number specifying the inverse distance weighting power.</p>
</td></tr>
<tr><td><code id="gbmkrigeidwcv_+3A_nmaxidw">nmaxidw</code></td>
<td>
<p>for a local predicting: the number of nearest observations that
should be used for a prediction or simulation, where nearest is defined in
terms of the space of the spatial locations. By default, 12 observations
are used.</p>
</td></tr>
<tr><td><code id="gbmkrigeidwcv_+3A_hybrid.parameter">hybrid.parameter</code></td>
<td>
<p>the default is 2 that is for 'gbmkrigegbmidw';
for 'gbmgbmkrigegbmidw', it needs to be 3.</p>
</td></tr>
<tr><td><code id="gbmkrigeidwcv_+3A_lambda">lambda</code></td>
<td>
<p>ranging from 0 to 2; the default is 1 for 'gbmkrigegbmidw'
and 'gbmgbmkrigegbmidw'; and if it is &lt; 1, more weight is placed on 'krige',
otherwise more weight is placed on 'idw'; and if it is 0, 'idw' is not
considered and the resultant methods is 'gbmkrige' when the default
'hybrid.parameter' is used; and if it is 2, then the resultant method is
'gbmidw' when the default 'hybrid.parameter' is used.</p>
</td></tr>
<tr><td><code id="gbmkrigeidwcv_+3A_validation">validation</code></td>
<td>
<p>validation methods, include 'LOO': leave-one-out, and 'CV':
cross-validation.</p>
</td></tr>
<tr><td><code id="gbmkrigeidwcv_+3A_cv.fold">cv.fold</code></td>
<td>
<p>integer; number of folds in the cross-validation. if &gt; 1,
then apply n-fold cross validation; the default is 10, i.e., 10-fold cross
validation that is recommended.</p>
</td></tr>
<tr><td><code id="gbmkrigeidwcv_+3A_predacc">predacc</code></td>
<td>
<p>can be either &quot;VEcv&quot; for vecv or &quot;ALL&quot; for all measures
in function pred.acc.</p>
</td></tr>
<tr><td><code id="gbmkrigeidwcv_+3A_n.cores">n.cores</code></td>
<td>
<p>The number of CPU cores to use. See gbm for details. By
default, 6 is used.</p>
</td></tr>
<tr><td><code id="gbmkrigeidwcv_+3A_...">...</code></td>
<td>
<p>other arguments passed on to 'randomForest', 'krige' and 'gstat'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following components:
me, rme, mae, rmae, mse, rmse, rrmse, vecv and e1; or vecv only
</p>


<h3>Note</h3>

<p>This function is largely based on 'gbmcv' in 'spm', and 'krigecv'
in 'spm2'.
</p>


<h3>Author(s)</h3>

<p>Jin Li
</p>


<h3>References</h3>

<p>Li, J. (2022). Spatial Predictive Modeling with R. Boca Raton,
Chapman and Hall/CRC.
</p>
<p>Li, J., Potter, A., Huang, Z., and Heap, A. (2012). Predicting Seabed
Sand Content across the Australian Margin Using Machine Learning and Geostatistical
Methods, Geoscience Australia, Record 2012/48, 115pp.
</p>
<p>Li, J., Heap, A., Potter, A., and Danilel, J.J. (2011). Predicting Seabed Mud Content
across the Australian Margin II: Performance of Machine Learning Methods and Their
Combination with Ordinary Kriging and Inverse Distance Squared, Geoscience Australia,
Record 2011/07, 69pp.
</p>
<p>Greg Ridgeway with contributions from others (2015). gbm: Generalized
Boosted Regression Models. R package version 2.1.1.
https://CRAN.R-project.org/package=gbm
</p>
<p>Pebesma, E.J., 2004. Multivariable geostatistics in S: the gstat package.
Computers &amp; Geosciences, 30: 683-691.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

library(spm)
# gbmgbmokgbmidw
data(sponge)
longlat &lt;- sponge[, 1:2]
set.seed(1234)
gbmgbmkrigegbmidwcv1 &lt;- gbmkrigeidwcv(longlat = longlat,
trainx = sponge[, -3], trainy = sponge[, 3], family = "poisson", interaction.depth = 3,
transformation = "none", formula = res1 ~ 1, vgm.args = "Sph",
nmaxkrige = 12, idp = 2, nmaxidw = 12, hybrid.parameter = 3, validation = "CV",
predacc = "ALL", n.cores = 2)
gbmgbmkrigegbmidwcv1

# gbmokgbmidw for count data
data(sponge)
longlat &lt;- sponge2[, 1:2]
y = sponge[, 3]
trainx = sponge[, -3]
set.seed(1234)
n &lt;- 20 # number of iterations,60 to 100 is recommended.
VEcv &lt;- NULL
for (i in 1:n) {
  gbmkrigegbmidwcv1 &lt;- gbmkrigeidwcv(longlat = longlat,
  trainx = trainx, trainy = y, family = "poisson", interaction.depth = 3,
  transformation = "none", formula = res1 ~ 1, vgm.args = ("Sph"),
  nmaxkrige = 12, idp = 2, nmaxidw = 12, hybrid.parameter = 2, validation = "CV",
  predacc = "VEcv", n.cores = 2)
  VEcv [i] &lt;- gbmkrigegbmidwcv1
 }
 plot(VEcv ~ c(1:n), xlab = "Iteration for gbmokgbmidw", ylab = "VEcv (%)")
 points(cumsum(VEcv) / c(1:n) ~ c(1:n), col = 2)
 abline(h = mean(VEcv), col = 'blue', lwd = 2)


</code></pre>

<hr>
<h2 id='gbmkrigeidwpred'>Generate spatial predictions using the hybrid methods of
generalized boosted regression modeling ('gbm'), 'kriging' and inverse distance weighted ('IDW').</h2><span id='topic+gbmkrigeidwpred'></span>

<h3>Description</h3>

<p>This function is for generating spatial predictions using the
hybrid methods of 'gbm', 'kriging' and 'IDW', including all methods implemented
in 'gbmkrigeidwcv'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gbmkrigeidwpred(
  longlat,
  trainx,
  predx,
  trainy,
  longlatpredx,
  var.monotone = rep(0, ncol(trainx)),
  family = "gaussian",
  n.trees = 3000,
  learning.rate = 0.001,
  interaction.depth = 2,
  bag.fraction = 0.5,
  train.fraction = 1,
  n.minobsinnode = 10,
  transformation = "none",
  weights = rep(1, nrow(trainx)),
  keep.data = FALSE,
  verbose = TRUE,
  delta = 1,
  formula = res1 ~ 1,
  vgm.args = "Sph",
  anis = c(0, 1),
  alpha = 0,
  block = 0,
  beta,
  nmaxkrige = 12,
  idp = 2,
  nmaxidw = 12,
  hybrid.parameter = 2,
  lambda = 1,
  cv.fold = 10,
  n.cores = 8,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gbmkrigeidwpred_+3A_longlat">longlat</code></td>
<td>
<p>a dataframe contains longitude and latitude of point samples.</p>
</td></tr>
<tr><td><code id="gbmkrigeidwpred_+3A_trainx">trainx</code></td>
<td>
<p>a dataframe contains longitude (long), latitude (lat),
predictive variables and the response variable of point samples.</p>
</td></tr>
<tr><td><code id="gbmkrigeidwpred_+3A_predx">predx</code></td>
<td>
<p>a dataframe or matrix contains columns of predictive variables
for the grids to be predicted.</p>
</td></tr>
<tr><td><code id="gbmkrigeidwpred_+3A_trainy">trainy</code></td>
<td>
<p>a vector of the response variable in the formula, that is, the left
part of the formula.</p>
</td></tr>
<tr><td><code id="gbmkrigeidwpred_+3A_longlatpredx">longlatpredx</code></td>
<td>
<p>a dataframe contains longitude and latitude of point locations
(i.e., the centers of grids) to be predicted.</p>
</td></tr>
<tr><td><code id="gbmkrigeidwpred_+3A_var.monotone">var.monotone</code></td>
<td>
<p>an optional vector, the same length as the number of
predictors, indicating which variables have a monotone increasing (+1),
decreasing (-1), or arbitrary (0) relationship with the outcome. By default,
a vector of 0 is used.</p>
</td></tr>
<tr><td><code id="gbmkrigeidwpred_+3A_family">family</code></td>
<td>
<p>either a character string specifying the name of the distribution to
use or a list with a component name specifying the distribution and any
additional parameters needed. See gbm for details. By default, &quot;gaussian&quot; is
used.</p>
</td></tr>
<tr><td><code id="gbmkrigeidwpred_+3A_n.trees">n.trees</code></td>
<td>
<p>the total number of trees to fit. This is equivalent to the
number of iterations and the number of basis functions in the additive
expansion. By default, 3000 is used.</p>
</td></tr>
<tr><td><code id="gbmkrigeidwpred_+3A_learning.rate">learning.rate</code></td>
<td>
<p>a shrinkage parameter applied to each tree in the
expansion. Also known as step-size reduction.</p>
</td></tr>
<tr><td><code id="gbmkrigeidwpred_+3A_interaction.depth">interaction.depth</code></td>
<td>
<p>the maximum depth of variable interactions.
1 implies an additive model, 2 implies a model with up to 2-way
interactions, etc. By default, 2 is used.</p>
</td></tr>
<tr><td><code id="gbmkrigeidwpred_+3A_bag.fraction">bag.fraction</code></td>
<td>
<p>the fraction of the training set observations randomly
selected to propose the next tree in the expansion. By default, 0.5 is used.</p>
</td></tr>
<tr><td><code id="gbmkrigeidwpred_+3A_train.fraction">train.fraction</code></td>
<td>
<p>The first 'train.fraction * nrows(data)' observations
are used to fit the gbm and the remainder are used for computing
out-of-sample estimates of the loss function.</p>
</td></tr>
<tr><td><code id="gbmkrigeidwpred_+3A_n.minobsinnode">n.minobsinnode</code></td>
<td>
<p>minimum number of observations in the trees terminal
nodes. Note that this is the actual number of observations not the total
weight. By default, 10 is used.</p>
</td></tr>
<tr><td><code id="gbmkrigeidwpred_+3A_transformation">transformation</code></td>
<td>
<p>transform the residuals of 'gbm' to normalise the data;
can be &quot;sqrt&quot; for square root, &quot;arcsine&quot; for arcsine, &quot;log&quot; or &quot;none&quot;
for non transformation. By default, &quot;none&quot; is used.</p>
</td></tr>
<tr><td><code id="gbmkrigeidwpred_+3A_weights">weights</code></td>
<td>
<p>an optional vector of weights to be used in the fitting
process. Must be positive but do not need to be normalized.
If keep.data = FALSE in the initial call to gbm then it is the user's
responsibility to resupply the weights to gbm.more. By default, a vector of
1 is used.</p>
</td></tr>
<tr><td><code id="gbmkrigeidwpred_+3A_keep.data">keep.data</code></td>
<td>
<p>a logical variable indicating whether to keep the data and
an index of the data stored with the object. Keeping the data and index
makes subsequent calls to gbm.more faster at the cost of storing an extra
copy of the dataset. By default, 'FALSE' is used.</p>
</td></tr>
<tr><td><code id="gbmkrigeidwpred_+3A_verbose">verbose</code></td>
<td>
<p>If TRUE, gbm will print out progress and performance
indicators. By default, 'TRUE' is used.</p>
</td></tr>
<tr><td><code id="gbmkrigeidwpred_+3A_delta">delta</code></td>
<td>
<p>numeric; to avoid log(0) in the log transformation. The default is 1.</p>
</td></tr>
<tr><td><code id="gbmkrigeidwpred_+3A_formula">formula</code></td>
<td>
<p>formula defining the response vector and (possible) regressor.
an object (i.e., 'variogram.formula') for 'variogram' or a formula for
'krige'. see 'variogram' and 'krige' in 'gstat' for details. The default is
'formula = res1 ~ 1'.</p>
</td></tr>
<tr><td><code id="gbmkrigeidwpred_+3A_vgm.args">vgm.args</code></td>
<td>
<p>arguments for 'vgm', e.g. variogram model of response
variable and anisotropy parameters. see 'vgm' in 'gstat' for details.
By default, &quot;Sph&quot; is used.</p>
</td></tr>
<tr><td><code id="gbmkrigeidwpred_+3A_anis">anis</code></td>
<td>
<p>anisotropy parameters: see notes 'vgm' in 'gstat' for details.</p>
</td></tr>
<tr><td><code id="gbmkrigeidwpred_+3A_alpha">alpha</code></td>
<td>
<p>direction in plane (x,y). see variogram in 'gstat' for details.</p>
</td></tr>
<tr><td><code id="gbmkrigeidwpred_+3A_block">block</code></td>
<td>
<p>block size. see 'krige' in 'gstat' for details.</p>
</td></tr>
<tr><td><code id="gbmkrigeidwpred_+3A_beta">beta</code></td>
<td>
<p>for simple kriging. see 'krige' in 'gstat' for details.</p>
</td></tr>
<tr><td><code id="gbmkrigeidwpred_+3A_nmaxkrige">nmaxkrige</code></td>
<td>
<p>for a local predicting: the number of nearest observations that
should be used for a prediction or simulation, where nearest is defined in
terms of the space of the spatial locations. By default, 12 observations
are used.</p>
</td></tr>
<tr><td><code id="gbmkrigeidwpred_+3A_idp">idp</code></td>
<td>
<p>a numeric number specifying the inverse distance weighting power.</p>
</td></tr>
<tr><td><code id="gbmkrigeidwpred_+3A_nmaxidw">nmaxidw</code></td>
<td>
<p>for a local predicting: the number of nearest observations that
should be used for a prediction or simulation, where nearest is defined in
terms of the space of the spatial locations. By default, 12 observations
are used.</p>
</td></tr>
<tr><td><code id="gbmkrigeidwpred_+3A_hybrid.parameter">hybrid.parameter</code></td>
<td>
<p>the default is 2 that is for 'gbmkrigegbmidw';
for 'gbmgbmkrigegbmidw', it needs to be 3.</p>
</td></tr>
<tr><td><code id="gbmkrigeidwpred_+3A_lambda">lambda</code></td>
<td>
<p>ranging from 0 to 2; the default is 1 for 'gbmkrigegbmidw'
and 'gbmgbmkrigegbmidw'; and if it is &lt; 1, more weight is placed on 'krige',
otherwise more weight is placed on 'idw'; and if it is 0, 'idw' is not
considered and the resultant methods is 'gbmkrige' when the default
'hybrid.parameter' is used; and if it is 2, then the resultant method is
'gbmidw' when the default 'hybrid.parameter' is used.</p>
</td></tr>
<tr><td><code id="gbmkrigeidwpred_+3A_cv.fold">cv.fold</code></td>
<td>
<p>integer; number of folds in the cross-validation. if &gt; 1,
then apply n-fold cross validation; the default is 10, i.e., 10-fold cross
validation that is recommended.</p>
</td></tr>
<tr><td><code id="gbmkrigeidwpred_+3A_n.cores">n.cores</code></td>
<td>
<p>The number of CPU cores to use. See gbm for details. By
default, 6 is used.</p>
</td></tr>
<tr><td><code id="gbmkrigeidwpred_+3A_...">...</code></td>
<td>
<p>other arguments passed on to 'gbm', 'krige' and 'gstat'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe of longitude, latitude, and predictions.
</p>


<h3>Author(s)</h3>

<p>Jin Li
</p>


<h3>References</h3>

<p>Li, J., Potter, A., Huang, Z., and Heap, A. (2012). Predicting Seabed
Sand Content across the Australian Margin Using Machine Learning and Geostatistical
Methods, Geoscience Australia, Record 2012/48, 115pp.
</p>
<p>Li, J., Heap, A., Potter, A., and Danilel, J.J. (2011). Predicting Seabed Mud Content
across the Australian Margin II: Performance of Machine Learning Methods and Their
Combination with Ordinary Kriging and Inverse Distance Squared, Geoscience Australia,
Record 2011/07, 69pp.
</p>
<p>Greg Ridgeway with contributions from others (2015). gbm: Generalized
Boosted Regression Models. R package version 2.1.1.
https://CRAN.R-project.org/package=gbm
</p>
<p>Pebesma, E.J., 2004. Multivariable geostatistics in S: the gstat package.
Computers &amp; Geosciences, 30: 683-691.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(spm)

data(sponge)
data(sponge.grid)
longlat &lt;- sponge[, 1:2]

set.seed(1234)

gbmkrigeidwpred1 &lt;- gbmkrigeidwpred(longlat = longlat, trainx = sponge[, -3],
predx = sponge.grid, trainy = sponge[, 3], longlatpredx = sponge.grid[, c(1:2)],
family = "poisson", interaction.depth = 3, transformation = "none", formula = res1 ~ 1,
vgm.args = "Sph", nmaxkrige = 12, idp = 2, nmaxidw = 12, hybrid.parameter = 3,
n.cores = 2)

names(gbmkrigeidwpred1)

range(gbmkrigeidwpred1$predictions)


</code></pre>

<hr>
<h2 id='glmcv'>Cross validation, n-fold and leave-one-out for generalised linear models  ('glm')</h2><span id='topic+glmcv'></span>

<h3>Description</h3>

<p>This function is a cross validation function
for 'glm' method in 'stats' package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>glmcv(
  formula = NULL,
  trainxy,
  y,
  family = "gaussian",
  validation = "CV",
  cv.fold = 10,
  predacc = "VEcv",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="glmcv_+3A_formula">formula</code></td>
<td>
<p>a formula defining the response variable and predictive variables.</p>
</td></tr>
<tr><td><code id="glmcv_+3A_trainxy">trainxy</code></td>
<td>
<p>a dataframe contains predictive variables and the response
variable of point samples. The location information, longitude (long),
latitude (lat), need to be included in the 'trainx' for spatial predictive
modeling.</p>
</td></tr>
<tr><td><code id="glmcv_+3A_y">y</code></td>
<td>
<p>a vector of the response variable in the formula, that is, the left
part of the formula.</p>
</td></tr>
<tr><td><code id="glmcv_+3A_family">family</code></td>
<td>
<p>a description of the error distribution and link function to
be used in the model. See '?glm' for details.</p>
</td></tr>
<tr><td><code id="glmcv_+3A_validation">validation</code></td>
<td>
<p>validation methods, include 'LOO': leave-one-out, and 'CV':
cross-validation.</p>
</td></tr>
<tr><td><code id="glmcv_+3A_cv.fold">cv.fold</code></td>
<td>
<p>integer; number of folds in the cross-validation. if &gt; 1,
then apply n-fold cross validation; the default is 10, i.e., 10-fold cross
validation that is recommended.</p>
</td></tr>
<tr><td><code id="glmcv_+3A_predacc">predacc</code></td>
<td>
<p>can be either &quot;VEcv&quot; for vecv or &quot;ALL&quot; for all measures
in function pred.acc.</p>
</td></tr>
<tr><td><code id="glmcv_+3A_...">...</code></td>
<td>
<p>other arguments passed on to 'glm'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following components:
me, rme, mae, rmae, mse, rmse, rrmse, vecv and e1; or vecv only
</p>


<h3>Note</h3>

<p>This function is largely based on 'rfcv' in 'randomForest' and
'glm' in 'stats'.
</p>


<h3>Author(s)</h3>

<p>Jin Li
</p>


<h3>References</h3>

<p>A. Liaw and M. Wiener (2002). Classification and Regression by
randomForest. R News 2(3), 18-22.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(spm)

data(petrel)
gravel &lt;- petrel[, c(1, 2, 6:9, 5)]
model &lt;- log(gravel + 1) ~  lat +  bathy + I(long^3) + I(lat^2) + I(lat^3)
set.seed(1234)
glmcv1 &lt;- glmcv(formula = model, gravel, log(gravel[, 7] +1), validation = "CV",
 predacc = "ALL")
glmcv1 # Since the default 'family' is used, it is actually a 'lm' model.

data(sponge)
model &lt;- sponge ~ easting + I(easting^2)
set.seed(1234)
glmcv1 &lt;- glmcv(formula = model, sponge, sponge[, 3], family = poisson,
validation = "CV",  predacc = "ALL")
glmcv1

# For glm
model &lt;- gravel / 100 ~  lat +  bathy + I(long^3) + I(lat^2) + I(lat^3)
set.seed(1234)
n &lt;- 20 # number of iterations,60 to 100 is recommended.
VEcv &lt;- NULL
for (i in 1:n) {
glmcv1 &lt;- glmcv(formula = model, gravel, gravel[, 7] / 100, family =
binomial(link=logit), validation = "CV", predacc = "VEcv")
VEcv [i] &lt;- glmcv1
}
plot(VEcv ~ c(1:n), xlab = "Iteration for GLM", ylab = "VEcv (%)")
points(cumsum(VEcv) / c(1:n) ~ c(1:n), col = 2)
abline(h = mean(VEcv), col = 'blue', lwd = 2)


</code></pre>

<hr>
<h2 id='glmidwcv'>Cross validation, n-fold and leave-one-out for the hybrid method of
generalised linear models  ('glm') and inverse distance weighted ('IDW') ('glmidw')</h2><span id='topic+glmidwcv'></span>

<h3>Description</h3>

<p>This function is a cross validation function
for the hybrid method of 'glm' and 'idw' using 'gstat' (glmidw) (see
reference #1), where the  data splitting is based on a stratified random
sampling method (see the  'datasplit' function for details).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>glmidwcv(
  formula = NULL,
  longlat,
  trainxy,
  y,
  family = "gaussian",
  idp = 2,
  nmaxidw = 12,
  validation = "CV",
  cv.fold = 10,
  predacc = "VEcv",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="glmidwcv_+3A_formula">formula</code></td>
<td>
<p>a formula defining the response variable and predictive variables
for 'glm'.</p>
</td></tr>
<tr><td><code id="glmidwcv_+3A_longlat">longlat</code></td>
<td>
<p>a dataframe contains longitude and latitude of point samples.</p>
</td></tr>
<tr><td><code id="glmidwcv_+3A_trainxy">trainxy</code></td>
<td>
<p>a dataframe contains longitude (long), latitude (lat),
predictive variables and the response variable of point samples.</p>
</td></tr>
<tr><td><code id="glmidwcv_+3A_y">y</code></td>
<td>
<p>a vector of the response variable in the formula, that is, the left
part of the formula.</p>
</td></tr>
<tr><td><code id="glmidwcv_+3A_family">family</code></td>
<td>
<p>a description of the error distribution and link function to
be used in the model. See '?glm' for details.</p>
</td></tr>
<tr><td><code id="glmidwcv_+3A_idp">idp</code></td>
<td>
<p>a numeric number specifying the inverse distance weighting power.</p>
</td></tr>
<tr><td><code id="glmidwcv_+3A_nmaxidw">nmaxidw</code></td>
<td>
<p>for a local predicting: the number of nearest observations that
should be used for a prediction or simulation, where nearest is defined in
terms of the space of the spatial locations. By default, 12 observations
are used.</p>
</td></tr>
<tr><td><code id="glmidwcv_+3A_validation">validation</code></td>
<td>
<p>validation methods, include 'LOO': leave-one-out, and 'CV':
cross-validation.</p>
</td></tr>
<tr><td><code id="glmidwcv_+3A_cv.fold">cv.fold</code></td>
<td>
<p>integer; number of folds in the cross-validation. if &gt; 1,
then apply n-fold cross validation; the default is 10, i.e., 10-fold cross
validation that is recommended.</p>
</td></tr>
<tr><td><code id="glmidwcv_+3A_predacc">predacc</code></td>
<td>
<p>can be either &quot;VEcv&quot; for vecv or &quot;ALL&quot; for all measures
in function pred.acc.</p>
</td></tr>
<tr><td><code id="glmidwcv_+3A_...">...</code></td>
<td>
<p>other arguments passed on to 'glm' and 'gstat'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following components:
me, rme, mae, rmae, mse, rmse, rrmse, vecv and e1; or vecv only.
</p>


<h3>Note</h3>

<p>This function is largely based on 'rfcv' in 'randomForest', 'idwcv'
in 'spm'and 'glm' in 'stats'.
</p>


<h3>Author(s)</h3>

<p>Jin Li
</p>


<h3>References</h3>

<p>Li, J., Alvarez, B., Siwabessy, J., Tran, M., Huang, Z.,
Przeslawski, R., Radke, L., Howard, F. and Nichol, S. (2017). &quot;Application
of random forest, generalised linear model and their hybrid methods with
geostatistical techniques to count data: Predicting sponge species richness.&quot;
Environmental Modelling &amp; Software 97: 112-129.
</p>
<p>A. Liaw and M. Wiener (2002). Classification and Regression by
randomForest. R News 2(3), 18-22.
</p>
<p>Pebesma, E.J., 2004. Multivariable geostatistics in S: the gstat package.
Computers &amp; Geosciences, 30: 683-691.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(spm)

data(petrel)
gravel &lt;- petrel[, c(1, 2, 6:9, 5)]
longlat &lt;- petrel[, c(1, 2)]
model &lt;- log(gravel + 1) ~  lat +  bathy + I(long^3) + I(lat^2) + I(lat^3)
y &lt;- log(gravel[, 7] +1)

set.seed(1234)
glmidwcv1 &lt;- glmidwcv(formula = model, longlat = longlat, trainxy =  gravel,
y = y, idp = 2, nmaxidw = 12, validation = "CV", predacc = "ALL")
glmidwcv1 # Since the default 'family' is used, actually a 'lm' model is used.

data(spongelonglat)
longlat &lt;- spongelonglat[, 7:8]
model &lt;- sponge ~ long + I(long^2)
y = spongelonglat[, 1]
set.seed(1234)
glmidwcv1 &lt;- glmidwcv(formula = model, longlat = longlat, trainxy = spongelonglat,
y = y, family = poisson, idp = 2, nmaxidw = 12, validation = "CV",
predacc = "ALL")
glmidwcv1

# glmidw for count data
data(spongelonglat)
longlat &lt;- spongelonglat[, 7:8]
model &lt;- sponge ~ . # use all predictive variables in the dataset
y = spongelonglat[, 1]
set.seed(1234)
n &lt;- 20 # number of iterations,60 to 100 is recommended.
VEcv &lt;- NULL
for (i in 1:n) {
 glmidwcv1 &lt;- glmidwcv(formula = model, longlat = longlat, trainxy = spongelonglat,
 y = y, family = poisson, idp = 2, nmaxidw = 12, validation = "CV",
 predacc = "VEcv")
 VEcv [i] &lt;- glmidwcv1
 }
 plot(VEcv ~ c(1:n), xlab = "Iteration for GLM", ylab = "VEcv (%)")
 points(cumsum(VEcv) / c(1:n) ~ c(1:n), col = 2)
 abline(h = mean(VEcv), col = 'blue', lwd = 2)

# glmidw for percentage data
longlat &lt;- petrel[, c(1, 2)]
model &lt;- gravel / 100 ~  lat +  bathy + I(long^3) + I(lat^2) + I(lat^3)
set.seed(1234)
n &lt;- 20 # number of iterations,60 to 100 is recommended.
VEcv &lt;- NULL
for (i in 1:n) {
glmidwcv1 &lt;- glmcv(formula = model, longlat = longlat, trainxy = gravel,
y = gravel[, 7] / 100, family = binomial(link=logit), idp = 2, nmaxidw = 12,
validation = "CV", predacc = "VEcv")
VEcv [i] &lt;- glmidwcv1
}
plot(VEcv ~ c(1:n), xlab = "Iteration for GLM", ylab = "VEcv (%)")
points(cumsum(VEcv) / c(1:n) ~ c(1:n), col = 2)
abline(h = mean(VEcv), col = 'blue', lwd = 2)


</code></pre>

<hr>
<h2 id='glmidwpred'>Generate spatial predictions using the hybrid method of generalised
linear models  ('glm') and inverse distance weighted ('IDW') ('glmidw')</h2><span id='topic+glmidwpred'></span>

<h3>Description</h3>

<p>This function is for generating spatial predictions using the hybrid
method of 'glm' and 'idw' ('glmidw') (see reference #1).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>glmidwpred(
  formula = NULL,
  longlat,
  trainxy,
  y,
  longlatpredx,
  predx,
  family = "gaussian",
  idp = 2,
  nmaxidw = 12,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="glmidwpred_+3A_formula">formula</code></td>
<td>
<p>a formula defining the response variable and predictive variables
for 'glm'.</p>
</td></tr>
<tr><td><code id="glmidwpred_+3A_longlat">longlat</code></td>
<td>
<p>a dataframe contains longitude and latitude of point samples. The
location information must be named as 'long' and 'lat'.</p>
</td></tr>
<tr><td><code id="glmidwpred_+3A_trainxy">trainxy</code></td>
<td>
<p>a dataframe contains longitude (long), latitude (lat),
predictive variables and the response variable of point samples. That is,
the location information must be named as 'long' and 'lat'.</p>
</td></tr>
<tr><td><code id="glmidwpred_+3A_y">y</code></td>
<td>
<p>a vector of the response variable in the formula, that is, the left
part of the formula.</p>
</td></tr>
<tr><td><code id="glmidwpred_+3A_longlatpredx">longlatpredx</code></td>
<td>
<p>a dataframe contains longitude and latitude of point locations
(i.e., the centers of grids) to be predicted.</p>
</td></tr>
<tr><td><code id="glmidwpred_+3A_predx">predx</code></td>
<td>
<p>a dataframe or matrix contains columns of predictive variables
for the grids to be predicted.</p>
</td></tr>
<tr><td><code id="glmidwpred_+3A_family">family</code></td>
<td>
<p>a description of the error distribution and link function to
be used in the model. See '?glm' for details.</p>
</td></tr>
<tr><td><code id="glmidwpred_+3A_idp">idp</code></td>
<td>
<p>a numeric number specifying the inverse distance weighting power.</p>
</td></tr>
<tr><td><code id="glmidwpred_+3A_nmaxidw">nmaxidw</code></td>
<td>
<p>for a local predicting: the number of nearest observations that
should be used for a prediction or simulation, where nearest is defined in
terms of the space of the spatial locations. By default, 12 observations
are used.</p>
</td></tr>
<tr><td><code id="glmidwpred_+3A_...">...</code></td>
<td>
<p>other arguments passed on to 'glm'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe of longitude, latitude, and predictions.
</p>


<h3>Author(s)</h3>

<p>Jin Li
</p>


<h3>References</h3>

<p>Li, J., Alvarez, B., Siwabessy, J., Tran, M., Huang, Z.,
Przeslawski, R., Radke, L., Howard, F. and Nichol, S. (2017). &quot;Application
of random forest, generalised linear model and their hybrid methods with
geostatistical techniques to count data: Predicting sponge species richness.&quot;
Environmental Modelling &amp; Software 97: 112-129.
</p>
<p>Pebesma, E.J., 2004. Multivariable geostatistics in S: the gstat package.
Computers &amp; Geosciences, 30: 683-691.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(spm)
data(petrel)
data(petrel.grid)

gravel &lt;- petrel[, c(1, 2, 6:9, 5)]
longlat &lt;- petrel[, c(1, 2)]
model &lt;- log(gravel + 1) ~  lat +  bathy + I(long^3) + I(lat^2) + I(lat^3)
y &lt;- log(gravel[, 7] +1)

glmidwpred1 &lt;- glmidwpred(formula = model, longlat = longlat, trainxy =  gravel,
y = y, longlatpredx = petrel.grid[, c(1:2)], predx = petrel.grid, idp = 2,
 nmaxidw = 12)
 # Since the default 'family' is used, actually a 'lm' model is used.

names(glmidwpred1)

# Back transform 'glmidwpred$predictions' to generate the final predictions
glmidwpred1$predictions.bt &lt;- exp(glmidwpred1$predictions) - 1
range(glmidwpred1$predictions.bt)


</code></pre>

<hr>
<h2 id='glmkrigecv'>Cross validation, n-fold and leave-one-out for the hybrid method of
generalised linear models  ('glm') and 'krige' ('glmkrige')</h2><span id='topic+glmkrigecv'></span>

<h3>Description</h3>

<p>This function is a cross validation function
for the hybrid method of 'glm' and 'krige' (glmkrige), where 'krige' methods
include ordinary kriging  ('OK'), simple kriging ('SK'), block 'OK' ('BOK')
and block 'SK'('BSK') (see reference #1 for further info).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>glmkrigecv(
  formula.glm = NULL,
  longlat,
  trainxy,
  y,
  family = "gaussian",
  transformation = "none",
  delta = 1,
  formula.krige = res1 ~ 1,
  vgm.args = c("Sph"),
  anis = c(0, 1),
  alpha = 0,
  block = 0,
  beta,
  nmaxkrige = 12,
  validation = "CV",
  cv.fold = 10,
  predacc = "VEcv",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="glmkrigecv_+3A_formula.glm">formula.glm</code></td>
<td>
<p>a formula defining the response variable and predictive variables for 'glm'.</p>
</td></tr>
<tr><td><code id="glmkrigecv_+3A_longlat">longlat</code></td>
<td>
<p>a dataframe contains longitude and latitude of point samples.</p>
</td></tr>
<tr><td><code id="glmkrigecv_+3A_trainxy">trainxy</code></td>
<td>
<p>a dataframe contains longitude (long), latitude (lat),
predictive variables and the response variable of point samples.</p>
</td></tr>
<tr><td><code id="glmkrigecv_+3A_y">y</code></td>
<td>
<p>a vector of the response variable in the formula, that is, the left
part of the formula.</p>
</td></tr>
<tr><td><code id="glmkrigecv_+3A_family">family</code></td>
<td>
<p>a description of the error distribution and link function to
be used in the model. See '?glm' for details.</p>
</td></tr>
<tr><td><code id="glmkrigecv_+3A_transformation">transformation</code></td>
<td>
<p>transform the residuals of 'glm' to normalise the data;
can be &quot;sqrt&quot; for square root, &quot;arcsine&quot; for arcsine, &quot;log&quot; or &quot;none&quot;
for non transformation. By default, &quot;none&quot; is used.</p>
</td></tr>
<tr><td><code id="glmkrigecv_+3A_delta">delta</code></td>
<td>
<p>numeric; to avoid log(0) in the log transformation. The default is 1.</p>
</td></tr>
<tr><td><code id="glmkrigecv_+3A_formula.krige">formula.krige</code></td>
<td>
<p>formula defining the response vector and (possible) regressor.
an object (i.e., 'variogram.formula') for 'variogram' or a formula for
'krige'. see 'variogram' and 'krige' in 'gstat' for details.</p>
</td></tr>
<tr><td><code id="glmkrigecv_+3A_vgm.args">vgm.args</code></td>
<td>
<p>arguments for 'vgm', e.g. variogram model of response
variable and anisotropy parameters. see 'vgm' in 'gstat' for details.
By default, &quot;Sph&quot; is used.</p>
</td></tr>
<tr><td><code id="glmkrigecv_+3A_anis">anis</code></td>
<td>
<p>anisotropy parameters: see notes 'vgm' in 'gstat' for details.</p>
</td></tr>
<tr><td><code id="glmkrigecv_+3A_alpha">alpha</code></td>
<td>
<p>direction in plane (x,y). see variogram in 'gstat' for details.</p>
</td></tr>
<tr><td><code id="glmkrigecv_+3A_block">block</code></td>
<td>
<p>block size. see 'krige' in 'gstat' for details.</p>
</td></tr>
<tr><td><code id="glmkrigecv_+3A_beta">beta</code></td>
<td>
<p>for simple kriging. see 'krige' in 'gstat' for details.</p>
</td></tr>
<tr><td><code id="glmkrigecv_+3A_nmaxkrige">nmaxkrige</code></td>
<td>
<p>for a local predicting: the number of nearest observations that
should be used for a prediction or simulation, where nearest is defined in
terms of the space of the spatial locations. By default, 12 observations
are used.</p>
</td></tr>
<tr><td><code id="glmkrigecv_+3A_validation">validation</code></td>
<td>
<p>validation methods, include 'LOO': leave-one-out, and 'CV':
cross-validation.</p>
</td></tr>
<tr><td><code id="glmkrigecv_+3A_cv.fold">cv.fold</code></td>
<td>
<p>integer; number of folds in the cross-validation. if &gt; 1,
then apply n-fold cross validation; the default is 10, i.e., 10-fold cross
validation that is recommended.</p>
</td></tr>
<tr><td><code id="glmkrigecv_+3A_predacc">predacc</code></td>
<td>
<p>can be either &quot;VEcv&quot; for vecv or &quot;ALL&quot; for all measures
in function pred.acc.</p>
</td></tr>
<tr><td><code id="glmkrigecv_+3A_...">...</code></td>
<td>
<p>other arguments passed on to 'glm' and 'krige'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following components:
me, rme, mae, rmae, mse, rmse, rrmse, vecv and e1; or vecv only
</p>


<h3>Note</h3>

<p>This function is largely based on 'rfcv' in 'randomForest', 'krigecv'
in 'spm2'and 'glm' in 'stats'.
</p>


<h3>Author(s)</h3>

<p>Jin Li
</p>


<h3>References</h3>

<p>Li, J., Alvarez, B., Siwabessy, J., Tran, M., Huang, Z.,
Przeslawski, R., Radke, L., Howard, F. and Nichol, S. (2017). &quot;Application
of random forest, generalised linear model and their hybrid methods with
geostatistical techniques to count data: Predicting sponge species richness.&quot;
Environmental Modelling &amp; Software 97: 112-129.
</p>
<p>Pebesma, E.J., 2004. Multivariable geostatistics in S: the gstat package.
Computers &amp; Geosciences, 30: 683-691.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(spm)

data(petrel)

gravel &lt;- petrel[, c(1, 2, 6:9, 5)]
longlat &lt;- petrel[, c(1, 2)]
model &lt;- log(gravel + 1) ~  lat +  bathy + I(long^3) + I(lat^2) + I(lat^3)
y &lt;- log(gravel[, 7] +1)
set.seed(1234)
glmkrigecv1 &lt;- glmkrigecv(formula.glm = model, longlat = longlat, trainxy =  gravel,
y = y, transformation = "none", formula.krige = res1 ~ 1, vgm.args = "Sph",
nmaxkrige = 12, validation = "CV", predacc = "ALL")
glmkrigecv1 # Since the default 'family' is used, actually a 'lm' model is used.

data(spongelonglat)
longlat &lt;- spongelonglat[, 7:8]
model &lt;- sponge ~ long + I(long^2)
y = spongelonglat[, 1]
set.seed(1234)
glmkrigecv1 &lt;- glmkrigecv(formula.glm = model, longlat = longlat, trainxy =
spongelonglat, y = y, family = poisson, transformation = "arcsine",
formula.krige = res1 ~ 1, vgm.args = ("Sph"), nmaxkrige = 12,
validation = "CV", predacc = "ALL")
glmkrigecv1

# glmok for count data
data(spongelonglat)
longlat &lt;- spongelonglat[, 7:8]
model &lt;- sponge ~ . # use all predictive variables in the dataset
y = spongelonglat[, 1]
set.seed(1234)
n &lt;- 20 # number of iterations,60 to 100 is recommended.
VEcv &lt;- NULL
for (i in 1:n) {
 glmkrigecv1 &lt;- glmkrigecv(formula.glm = model, longlat = longlat, trainxy = spongelonglat,
 y = y, family = poisson, formula.krige = res1 ~ 1, vgm.args = ("Sph"), nmaxkrige = 12,
 validation = "CV",  predacc = "VEcv")
 VEcv [i] &lt;- glmkrigecv1
 }
 plot(VEcv ~ c(1:n), xlab = "Iteration for GLM", ylab = "VEcv (%)")
 points(cumsum(VEcv) / c(1:n) ~ c(1:n), col = 2)
 abline(h = mean(VEcv), col = 'blue', lwd = 2)

# glmok for percentage data
longlat &lt;- petrel[, c(1, 2)]
model &lt;- gravel / 100 ~  lat +  bathy + I(long^3) + I(lat^2) + I(lat^3)
set.seed(1234)
n &lt;- 20 # number of iterations,60 to 100 is recommended.
VEcv &lt;- NULL
for (i in 1:n) {
glmkrigecv1 &lt;- glmkrigecv(formula.glm = model, longlat = longlat, trainxy = gravel,
y = gravel[, 7] / 100, family = binomial(link=logit), formula.krige = res1 ~ 1,
vgm.args = ("Sph"), nmaxkrige = 12, validation = "CV", predacc = "VEcv")
VEcv [i] &lt;- glmkrigecv1
}
plot(VEcv ~ c(1:n), xlab = "Iteration for GLM", ylab = "VEcv (%)")
points(cumsum(VEcv) / c(1:n) ~ c(1:n), col = 2)
abline(h = mean(VEcv), col = 'blue', lwd = 2)


</code></pre>

<hr>
<h2 id='glmkrigeidwcv'>Cross validation, n-fold and leave-one-out for the hybrid methods of
generalised linear models  ('glm'), 'kriging' and inverse distance weighted ('IDW').</h2><span id='topic+glmkrigeidwcv'></span>

<h3>Description</h3>

<p>This function is a cross validation function
for 38 hybrid  methods of 'glm', 'kriging' and 'IDW', including the average
of 'glmkrige' and 'glmidw' ('glmkrigeglmidw') and  the average of 'glm',
'glmkrige' and 'glmidw' ('glmglmkrigeglmidw'), where 'kriging' methods
include ordinary kriging  ('OK'), simple kriging ('SK'), block 'OK' ('BOK')
and block 'SK'('BSK') and 'IDW' also covers 'NN' and 'KNN' (for details, see
reference #1). This function can also be sued for 38 hybrid methods of 'lm',
'kriging' and 'IDW'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>glmkrigeidwcv(
  formula.glm = NULL,
  longlat,
  trainxy,
  y,
  family = "gaussian",
  transformation = "none",
  delta = 1,
  formula.krige = res1 ~ 1,
  vgm.args = c("Sph"),
  anis = c(0, 1),
  alpha = 0,
  block = 0,
  beta,
  nmaxkrige = 12,
  idp = 2,
  nmaxidw = 12,
  hybrid.parameter = 2,
  lambda = 1,
  validation = "CV",
  cv.fold = 10,
  predacc = "VEcv",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="glmkrigeidwcv_+3A_formula.glm">formula.glm</code></td>
<td>
<p>a formula defining the response variable and predictive variables for 'glm'.</p>
</td></tr>
<tr><td><code id="glmkrigeidwcv_+3A_longlat">longlat</code></td>
<td>
<p>a dataframe contains longitude and latitude of point samples.</p>
</td></tr>
<tr><td><code id="glmkrigeidwcv_+3A_trainxy">trainxy</code></td>
<td>
<p>a dataframe contains longitude (long), latitude (lat),
predictive variables and the response variable of point samples.</p>
</td></tr>
<tr><td><code id="glmkrigeidwcv_+3A_y">y</code></td>
<td>
<p>a vector of the response variable in the formula, that is, the left
part of the formula.</p>
</td></tr>
<tr><td><code id="glmkrigeidwcv_+3A_family">family</code></td>
<td>
<p>a description of the error distribution and link function to
be used in the model. See '?glm' for details.</p>
</td></tr>
<tr><td><code id="glmkrigeidwcv_+3A_transformation">transformation</code></td>
<td>
<p>transform the residuals of 'glm' to normalise the data for 'krige';
can be &quot;sqrt&quot; for square root, &quot;arcsine&quot; for arcsine, &quot;log&quot; or &quot;none&quot;
for non transformation. By default, &quot;none&quot; is used.</p>
</td></tr>
<tr><td><code id="glmkrigeidwcv_+3A_delta">delta</code></td>
<td>
<p>numeric; to avoid log(0) in the log transformation. The default is 1.</p>
</td></tr>
<tr><td><code id="glmkrigeidwcv_+3A_formula.krige">formula.krige</code></td>
<td>
<p>formula defining the response vector and (possible) regressor.
an object (i.e., 'variogram.formula') for 'variogram' or a formula for
'krige'. see 'variogram' and 'krige' in 'gstat' for details.</p>
</td></tr>
<tr><td><code id="glmkrigeidwcv_+3A_vgm.args">vgm.args</code></td>
<td>
<p>arguments for 'vgm', e.g. variogram model of response
variable and anisotropy parameters. see 'vgm' in 'gstat' for details.
By default, &quot;Sph&quot; is used.</p>
</td></tr>
<tr><td><code id="glmkrigeidwcv_+3A_anis">anis</code></td>
<td>
<p>anisotropy parameters: see notes 'vgm' in 'gstat' for details.</p>
</td></tr>
<tr><td><code id="glmkrigeidwcv_+3A_alpha">alpha</code></td>
<td>
<p>direction in plane (x,y). see variogram in 'gstat' for details.</p>
</td></tr>
<tr><td><code id="glmkrigeidwcv_+3A_block">block</code></td>
<td>
<p>block size. see 'krige' in 'gstat' for details.</p>
</td></tr>
<tr><td><code id="glmkrigeidwcv_+3A_beta">beta</code></td>
<td>
<p>for simple kriging. see 'krige' in 'gstat' for details.</p>
</td></tr>
<tr><td><code id="glmkrigeidwcv_+3A_nmaxkrige">nmaxkrige</code></td>
<td>
<p>for a local predicting: the number of nearest observations that
should be used for a prediction or simulation, where nearest is defined in
terms of the space of the spatial locations. By default, 12 observations
are used.</p>
</td></tr>
<tr><td><code id="glmkrigeidwcv_+3A_idp">idp</code></td>
<td>
<p>a numeric number specifying the inverse distance weighting power.</p>
</td></tr>
<tr><td><code id="glmkrigeidwcv_+3A_nmaxidw">nmaxidw</code></td>
<td>
<p>for a local predicting: the number of nearest observations that
should be used for a prediction or simulation, where nearest is defined in
terms of the space of the spatial locations. By default, 12 observations
are used.</p>
</td></tr>
<tr><td><code id="glmkrigeidwcv_+3A_hybrid.parameter">hybrid.parameter</code></td>
<td>
<p>the default is 2 that is for 'glmkrigeglmidw';
for 'glmglmkrigeglmidw', it needs to be 3.</p>
</td></tr>
<tr><td><code id="glmkrigeidwcv_+3A_lambda">lambda</code></td>
<td>
<p>ranging from 0 to 2; the default is 1 for 'glmkrigeglmidw'
and 'glmglmkrigeglmidw'; and if it is &lt; 1, more weight is placed on 'krige',
otherwise more weight is placed on 'idw'; and if it is 0, 'idw' is not
considered and the resultant methods is 'glmkrige' when the default
'hybrid.parameter' is used; and if it is 2, then the resultant method is
'glmidw' when the default 'hybrid.parameter' is used.</p>
</td></tr>
<tr><td><code id="glmkrigeidwcv_+3A_validation">validation</code></td>
<td>
<p>validation methods, include 'LOO': leave-one-out, and 'CV':
cross-validation.</p>
</td></tr>
<tr><td><code id="glmkrigeidwcv_+3A_cv.fold">cv.fold</code></td>
<td>
<p>integer; number of folds in the cross-validation. if &gt; 1,
then apply n-fold cross validation; the default is 10, i.e., 10-fold cross
validation that is recommended.</p>
</td></tr>
<tr><td><code id="glmkrigeidwcv_+3A_predacc">predacc</code></td>
<td>
<p>can be either &quot;VEcv&quot; for vecv or &quot;ALL&quot; for all measures
in function pred.acc.</p>
</td></tr>
<tr><td><code id="glmkrigeidwcv_+3A_...">...</code></td>
<td>
<p>other arguments passed on to 'glm', 'krige' and 'gstat'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following components:
me, rme, mae, rmae, mse, rmse, rrmse, vecv and e1; or vecv only
</p>


<h3>Note</h3>

<p>This function is largely based on 'rfcv' in 'randomForest', 'krigecv'
in 'spm2'and 'glm' in 'stats'.
</p>


<h3>Author(s)</h3>

<p>Jin Li
</p>


<h3>References</h3>

<p>Li, J. (2022). Spatial Predictive Modeling with R. Boca Raton,
Chapman and Hall/CRC.
</p>
<p>Li, J., Alvarez, B., Siwabessy, J., Tran, M., Huang, Z.,
Przeslawski, R., Radke, L., Howard, F. and Nichol, S. (2017). &quot;Application
of random forest, generalised linear model and their hybrid methods with
geostatistical techniques to count data: Predicting sponge species richness.&quot;
Environmental Modelling &amp; Software 97: 112-129.
</p>
<p>A. Liaw and M. Wiener (2002). Classification and Regression by
randomForest. R News 2(3), 18-22.
</p>
<p>Pebesma, E.J., 2004. Multivariable geostatistics in S: the gstat package.
Computers &amp; Geosciences, 30: 683-691.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(spm)
# glmokglidw
data(petrel)
gravel &lt;- petrel[, c(1, 2, 6:9, 5)]
longlat &lt;- petrel[, c(1, 2)]
model &lt;- log(gravel + 1) ~  lat +  bathy + I(long^3) + I(lat^2) + I(lat^3)
y &lt;- log(gravel[, 7] +1)
set.seed(1234)
glmkrigeglmidwcv1 &lt;- glmkrigeidwcv(formula.glm = model, longlat = longlat,
trainxy =  gravel, y = y, transformation = "none", formula.krige = res1 ~ 1,
vgm.args = "Sph", nmaxkrige = 12, idp = 2, nmaxidw = 12, validation = "CV",
 predacc = "ALL")
glmkrigeglmidwcv1 # Since the default 'family' is used, actually a 'lm' model is used.

# glmokglmidw
data(spongelonglat)
longlat &lt;- spongelonglat[, 7:8]
model &lt;- sponge ~ long + I(long^2)
y = spongelonglat[, 1]
set.seed(1234)
glmkrigeglmidwcv1 &lt;- glmkrigeidwcv(formula.glm = model, longlat = longlat,
trainxy = spongelonglat, y = y, family = poisson, transformation = "arcsine",
formula.krige = res1 ~ 1, vgm.args = ("Sph"), nmaxkrige = 12, idp = 2,
nmaxidw = 12, validation = "CV", predacc = "ALL")
glmkrigeglmidwcv1

# glmglmokglmidw
data(spongelonglat)
longlat &lt;- spongelonglat[, 7:8]
model &lt;- sponge ~ long + I(long^2)
y = spongelonglat[, 1]
set.seed(1234)
glmglmkrigeglmidwcv1 &lt;- glmkrigeidwcv(formula.glm = model, longlat = longlat,
trainxy = spongelonglat, y = y, family = poisson, transformation = "arcsine",
formula.krige = res1 ~ 1, vgm.args = ("Sph"), nmaxkrige = 12, idp = 2,
nmaxidw = 12, hybrid.parameter = 3, validation = "CV", predacc = "ALL")
glmglmkrigeglmidwcv1

# glmokglidw for count data
data(spongelonglat)
longlat &lt;- spongelonglat[, 7:8]
model &lt;- sponge ~ . # use all predictive variables in the dataset
y = spongelonglat[, 1]
set.seed(1234)
n &lt;- 20 # number of iterations,60 to 100 is recommended.
VEcv &lt;- NULL
for (i in 1:n) {
 glmkrigeglmidwcv1 &lt;- glmkrigeidwcv(formula.glm = model, longlat = longlat,
 trainxy = spongelonglat, y = y, family = poisson, formula.krige = res1 ~ 1,
 vgm.args = ("Sph"), nmaxkrige = 12, idp = 2, nmaxidw = 12, validation = "CV",
 predacc = "VEcv")
 VEcv [i] &lt;- glmkrigeglmidwcv1
 }
 plot(VEcv ~ c(1:n), xlab = "Iteration for GLM", ylab = "VEcv (%)")
 points(cumsum(VEcv) / c(1:n) ~ c(1:n), col = 2)
 abline(h = mean(VEcv), col = 'blue', lwd = 2)

# glmokglmidw for percentage data
longlat &lt;- petrel[, c(1, 2)]
model &lt;- gravel / 100 ~  lat +  bathy + I(long^3) + I(lat^2) + I(lat^3)
set.seed(1234)
n &lt;- 20 # number of iterations,60 to 100 is recommended.
VEcv &lt;- NULL
for (i in 1:n) {
glmkrigeglmidwcv1 &lt;- glmkrigeidwcv(formula.glm = model, longlat = longlat,
trainxy = gravel, y = gravel[, 7] / 100, family = binomial(link=logit),
formula.krige = res1 ~ 1, vgm.args = ("Sph"), nmaxkrige = 12, idp = 2,
nmaxidw = 12, validation = "CV", predacc = "VEcv")
VEcv [i] &lt;- glmkrigeglmidwcv1
}
plot(VEcv ~ c(1:n), xlab = "Iteration for GLM", ylab = "VEcv (%)")
points(cumsum(VEcv) / c(1:n) ~ c(1:n), col = 2)
abline(h = mean(VEcv), col = 'blue', lwd = 2)


</code></pre>

<hr>
<h2 id='glmkrigeidwpred'>Generate spatial predictions using the hybrid methods of
generalised linear models  ('glm'), 'kriging' and inverse distance weighted ('IDW').</h2><span id='topic+glmkrigeidwpred'></span>

<h3>Description</h3>

<p>This function is for generating spatial predictions using the
hybrid methods of 'glm', 'kriging' and 'IDW', including all methods implemented
in 'glmkrigeidwcv'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>glmkrigeidwpred(
  formula.glm = NULL,
  longlat,
  trainxy,
  predx,
  y,
  longlatpredx,
  family = "gaussian",
  transformation = "none",
  delta = 1,
  formula.krige = res1 ~ 1,
  vgm.args = c("Sph"),
  anis = c(0, 1),
  alpha = 0,
  block = 0,
  beta,
  nmaxkrige = 12,
  idp = 2,
  nmaxidw = 12,
  hybrid.parameter = 2,
  lambda = 1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="glmkrigeidwpred_+3A_formula.glm">formula.glm</code></td>
<td>
<p>a formula defining the response variable and predictive variables for 'glm'.</p>
</td></tr>
<tr><td><code id="glmkrigeidwpred_+3A_longlat">longlat</code></td>
<td>
<p>a dataframe contains longitude and latitude of point samples.</p>
</td></tr>
<tr><td><code id="glmkrigeidwpred_+3A_trainxy">trainxy</code></td>
<td>
<p>a dataframe contains longitude (long), latitude (lat),
predictive variables and the response variable of point samples.</p>
</td></tr>
<tr><td><code id="glmkrigeidwpred_+3A_predx">predx</code></td>
<td>
<p>a dataframe or matrix contains columns of predictive variables
for the grids to be predicted.</p>
</td></tr>
<tr><td><code id="glmkrigeidwpred_+3A_y">y</code></td>
<td>
<p>a vector of the response variable in the formula, that is, the left
part of the formula.</p>
</td></tr>
<tr><td><code id="glmkrigeidwpred_+3A_longlatpredx">longlatpredx</code></td>
<td>
<p>a dataframe contains longitude and latitude of point locations
(i.e., the centers of grids) to be predicted.</p>
</td></tr>
<tr><td><code id="glmkrigeidwpred_+3A_family">family</code></td>
<td>
<p>a description of the error distribution and link function to
be used in the model. See '?glm' for details.</p>
</td></tr>
<tr><td><code id="glmkrigeidwpred_+3A_transformation">transformation</code></td>
<td>
<p>transform the residuals of 'glm' to normalise the data;
can be &quot;sqrt&quot; for square root, &quot;arcsine&quot; for arcsine, &quot;log&quot; or &quot;none&quot;
for non transformation. By default, &quot;none&quot; is used.</p>
</td></tr>
<tr><td><code id="glmkrigeidwpred_+3A_delta">delta</code></td>
<td>
<p>numeric; to avoid log(0) in the log transformation. The default is 1.</p>
</td></tr>
<tr><td><code id="glmkrigeidwpred_+3A_formula.krige">formula.krige</code></td>
<td>
<p>formula defining the response vector and (possible) regressor.
an object (i.e., 'variogram.formula') for 'variogram' or a formula for
'krige'. see 'variogram' and 'krige' in 'gstat' for details.</p>
</td></tr>
<tr><td><code id="glmkrigeidwpred_+3A_vgm.args">vgm.args</code></td>
<td>
<p>arguments for 'vgm', e.g. variogram model of response
variable and anisotropy parameters. see 'vgm' in 'gstat' for details.
By default, &quot;Sph&quot; is used.</p>
</td></tr>
<tr><td><code id="glmkrigeidwpred_+3A_anis">anis</code></td>
<td>
<p>anisotropy parameters: see notes 'vgm' in 'gstat' for details.</p>
</td></tr>
<tr><td><code id="glmkrigeidwpred_+3A_alpha">alpha</code></td>
<td>
<p>direction in plane (x,y). see variogram in 'gstat' for details.</p>
</td></tr>
<tr><td><code id="glmkrigeidwpred_+3A_block">block</code></td>
<td>
<p>block size. see 'krige' in 'gstat' for details.</p>
</td></tr>
<tr><td><code id="glmkrigeidwpred_+3A_beta">beta</code></td>
<td>
<p>for simple kriging. see 'krige' in 'gstat' for details.</p>
</td></tr>
<tr><td><code id="glmkrigeidwpred_+3A_nmaxkrige">nmaxkrige</code></td>
<td>
<p>for a local predicting: the number of nearest observations that
should be used for a prediction or simulation, where nearest is defined in
terms of the space of the spatial locations. By default, 12 observations
are used.</p>
</td></tr>
<tr><td><code id="glmkrigeidwpred_+3A_idp">idp</code></td>
<td>
<p>a numeric number specifying the inverse distance weighting power.</p>
</td></tr>
<tr><td><code id="glmkrigeidwpred_+3A_nmaxidw">nmaxidw</code></td>
<td>
<p>for a local predicting: the number of nearest observations that
should be used for a prediction or simulation, where nearest is defined in
terms of the space of the spatial locations. By default, 12 observations
are used.</p>
</td></tr>
<tr><td><code id="glmkrigeidwpred_+3A_hybrid.parameter">hybrid.parameter</code></td>
<td>
<p>the default is 2 that is for 'glmkrigeglmidw';
for 'glmglmkrigeglmidw', it needs to be 3.</p>
</td></tr>
<tr><td><code id="glmkrigeidwpred_+3A_lambda">lambda</code></td>
<td>
<p>ranging from 0 to 2; the default is 1 for 'glmkrigeglmidw'
and 'glmglmkrigeglmidw'; and if it is &lt; 1, more weight is placed on 'krige',
otherwise more weight is placed on 'idw'; and if it is 0, 'idw' is not
considered and the resultant methods is 'glmkrige' when the default
'hybrid.parameter' is used; and if it is 2, then the resultant method is
'glmidw' when the default 'hybrid.parameter' is used.</p>
</td></tr>
<tr><td><code id="glmkrigeidwpred_+3A_...">...</code></td>
<td>
<p>other arguments passed on to 'glm', 'krige' and 'gstat'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe of longitude, latitude, and predictions.
</p>


<h3>Author(s)</h3>

<p>Jin Li
</p>


<h3>References</h3>

<p>Li, J., Alvarez, B., Siwabessy, J., Tran, M., Huang, Z.,
Przeslawski, R., Radke, L., Howard, F. and Nichol, S. (2017). &quot;Application
of random forest, generalised linear model and their hybrid methods with
geostatistical techniques to count data: Predicting sponge species richness.&quot;
Environmental Modelling &amp; Software 97: 112-129.
</p>
<p>Pebesma, E.J., 2004. Multivariable geostatistics in S: the gstat package.
Computers &amp; Geosciences, 30: 683-691.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(spm)

data(petrel)
data(petrel.grid)

gravel &lt;- petrel[, c(1, 2, 6:9, 5)]
longlat &lt;- petrel[, c(1, 2)]
model &lt;- log(gravel + 1) ~  lat +  bathy + I(long^3) + I(lat^2) + I(lat^3)
y &lt;- log(gravel[, 7] +1)

glmkrigeidwpred1 &lt;- glmkrigeidwpred(formula.glm = model, longlat = longlat, trainxy =  gravel,
predx = petrel.grid, y = y, longlatpredx = petrel.grid[, c(1:2)],
formula.krige = res1 ~ 1, vgm.args = "Sph", nmaxkrige = 12, idp = 2, nmaxidw = 12)
 # Since the default 'family' is used, actually a 'lm' model is used.

names(glmkrigeidwpred1)

# Back transform 'glmkrigeidwpred$predictions' to generate the final predictions
glmkrigeidw.predictions &lt;- exp(glmkrigeidwpred1$predictions) - 1
range(glmkrigeidw.predictions)


</code></pre>

<hr>
<h2 id='glmkrigepred'>Generate spatial predictions using the hybrid method of generalised
linear models  ('glm') and 'krige'</h2><span id='topic+glmkrigepred'></span>

<h3>Description</h3>

<p>This function is for generating spatial predictions using the hybrid method of
'glm' and 'krige', including all methods implemented
in 'glmkrigecv'. (see reference #1 for further info).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>glmkrigepred(
  formula.glm = NULL,
  longlat,
  trainxy,
  predx,
  y,
  longlatpredx,
  family = "gaussian",
  transformation = "none",
  delta = 1,
  formula.krige = res1 ~ 1,
  vgm.args = c("Sph"),
  anis = c(0, 1),
  alpha = 0,
  block = 0,
  beta,
  nmaxkrige = 12,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="glmkrigepred_+3A_formula.glm">formula.glm</code></td>
<td>
<p>a formula defining the response variable and predictive variables for 'glm'.</p>
</td></tr>
<tr><td><code id="glmkrigepred_+3A_longlat">longlat</code></td>
<td>
<p>a dataframe contains longitude and latitude of point samples.</p>
</td></tr>
<tr><td><code id="glmkrigepred_+3A_trainxy">trainxy</code></td>
<td>
<p>a dataframe contains longitude (long), latitude (lat),
predictive variables and the response variable of point samples.</p>
</td></tr>
<tr><td><code id="glmkrigepred_+3A_predx">predx</code></td>
<td>
<p>a dataframe or matrix contains columns of predictive variables
for the grids to be predicted.</p>
</td></tr>
<tr><td><code id="glmkrigepred_+3A_y">y</code></td>
<td>
<p>a vector of the response variable in the formula, that is, the left
part of the formula.</p>
</td></tr>
<tr><td><code id="glmkrigepred_+3A_longlatpredx">longlatpredx</code></td>
<td>
<p>a dataframe contains longitude and latitude of point locations
(i.e., the centers of grids) to be predicted.</p>
</td></tr>
<tr><td><code id="glmkrigepred_+3A_family">family</code></td>
<td>
<p>a description of the error distribution and link function to
be used in the model. See '?glm' for details.</p>
</td></tr>
<tr><td><code id="glmkrigepred_+3A_transformation">transformation</code></td>
<td>
<p>transform the residuals of 'glm' to normalise the data;
can be &quot;sqrt&quot; for square root, &quot;arcsine&quot; for arcsine, &quot;log&quot; or &quot;none&quot;
for non transformation. By default, &quot;none&quot; is used.</p>
</td></tr>
<tr><td><code id="glmkrigepred_+3A_delta">delta</code></td>
<td>
<p>numeric; to avoid log(0) in the log transformation. The default is 1.</p>
</td></tr>
<tr><td><code id="glmkrigepred_+3A_formula.krige">formula.krige</code></td>
<td>
<p>formula defining the response vector and (possible) regressor.
an object (i.e., 'variogram.formula') for 'variogram' or a formula for
'krige'. see 'variogram' and 'krige' in 'gstat' for details.</p>
</td></tr>
<tr><td><code id="glmkrigepred_+3A_vgm.args">vgm.args</code></td>
<td>
<p>arguments for 'vgm', e.g. variogram model of response
variable and anisotropy parameters. see 'vgm' in 'gstat' for details.
By default, &quot;Sph&quot; is used.</p>
</td></tr>
<tr><td><code id="glmkrigepred_+3A_anis">anis</code></td>
<td>
<p>anisotropy parameters: see notes 'vgm' in 'gstat' for details.</p>
</td></tr>
<tr><td><code id="glmkrigepred_+3A_alpha">alpha</code></td>
<td>
<p>direction in plane (x,y). see variogram in 'gstat' for details.</p>
</td></tr>
<tr><td><code id="glmkrigepred_+3A_block">block</code></td>
<td>
<p>block size. see 'krige' in 'gstat' for details.</p>
</td></tr>
<tr><td><code id="glmkrigepred_+3A_beta">beta</code></td>
<td>
<p>for simple kriging. see 'krige' in 'gstat' for details.</p>
</td></tr>
<tr><td><code id="glmkrigepred_+3A_nmaxkrige">nmaxkrige</code></td>
<td>
<p>for a local predicting: the number of nearest observations that
should be used for a prediction or simulation, where nearest is defined in
terms of the space of the spatial locations. By default, 12 observations
are used.</p>
</td></tr>
<tr><td><code id="glmkrigepred_+3A_...">...</code></td>
<td>
<p>other arguments passed on to 'glm' and 'krige'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe of longitude, latitude, and predictions.
</p>


<h3>Author(s)</h3>

<p>Jin Li
</p>


<h3>References</h3>

<p>Li, J., Alvarez, B., Siwabessy, J., Tran, M., Huang, Z.,
Przeslawski, R., Radke, L., Howard, F. and Nichol, S. (2017). &quot;Application
of random forest, generalised linear model and their hybrid methods with
geostatistical techniques to count data: Predicting sponge species richness.&quot;
Environmental Modelling &amp; Software 97: 112-129.
</p>
<p>Pebesma, E.J., 2004. Multivariable geostatistics in S: the gstat package.
Computers &amp; Geosciences, 30: 683-691.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(spm)

data(petrel)
data(petrel.grid)

gravel &lt;- petrel[, c(1, 2, 6:9, 5)]
longlat &lt;- petrel[, c(1, 2)]
model &lt;- log(gravel + 1) ~  lat +  bathy + I(long^3) + I(lat^2) + I(lat^3)
y &lt;- log(gravel[, 7] +1)

glmkrigepred1 &lt;- glmkrigepred(formula.glm = model, longlat = longlat, trainxy =  gravel,
predx = petrel.grid, y = y, longlatpredx = petrel.grid[, c(1:2)],
transformation = "none", formula.krige = res1 ~ 1, vgm.args = "Sph", nmaxkrige = 12)
 # Since the default 'family' is used, actually a 'lm' model is used.

names(glmkrigepred1)

# Back transform 'glmkrigepred$predictions' to generate the final predictions
glmkrige.predictions &lt;- exp(glmkrigepred1$predictions) - 1
range(glmkrige.predictions)


</code></pre>

<hr>
<h2 id='glmnetcv'>Cross validation, n-fold and leave-one-out, for 'glmnet' in 'glmnet' package</h2><span id='topic+glmnetcv'></span>

<h3>Description</h3>

<p>This function is a cross validation function
for 'glmnet' method in 'glmnet' package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>glmnetcv(
  trainx,
  y,
  family = "gaussian",
  alpha = 0.5,
  relax = FALSE,
  type.measure = "mse",
  validation = "CV",
  cv.fold = 10,
  predacc = "VEcv",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="glmnetcv_+3A_trainx">trainx</code></td>
<td>
<p>a matrix contains predictive variables of point samples.
The location information, longitude (long), latitude (lat), need to be included
in the 'trainx' for spatial predictive modelling.</p>
</td></tr>
<tr><td><code id="glmnetcv_+3A_y">y</code></td>
<td>
<p>a vector of the response variable in the formula, that is, the left
part of the formula.</p>
</td></tr>
<tr><td><code id="glmnetcv_+3A_family">family</code></td>
<td>
<p>a description of the error distribution and link function to
be used in the model. See '?glmnet' for details.</p>
</td></tr>
<tr><td><code id="glmnetcv_+3A_alpha">alpha</code></td>
<td>
<p>an elasticnet mixing parameter, with $0 &lt;= alpha &lt;= 1$.
See '?glmnet' for details.</p>
</td></tr>
<tr><td><code id="glmnetcv_+3A_relax">relax</code></td>
<td>
<p>if TRUE then for each active set in the path of solutions,
the model is refit without any regularization. See '?glmnet' for more information.</p>
</td></tr>
<tr><td><code id="glmnetcv_+3A_type.measure">type.measure</code></td>
<td>
<p>loss to use for cross-validation. The default is
type.measure=&quot;mse&quot;. See '?cv.glmnet' for more information.</p>
</td></tr>
<tr><td><code id="glmnetcv_+3A_validation">validation</code></td>
<td>
<p>validation methods, include 'LOO': leave-one-out, and 'CV':
cross-validation.</p>
</td></tr>
<tr><td><code id="glmnetcv_+3A_cv.fold">cv.fold</code></td>
<td>
<p>integer; number of folds in the cross-validation. if &gt; 1,
then apply n-fold cross validation; the default is 10, i.e., 10-fold cross
validation that is recommended.</p>
</td></tr>
<tr><td><code id="glmnetcv_+3A_predacc">predacc</code></td>
<td>
<p>can be either &quot;VEcv&quot; for vecv or &quot;ALL&quot; for all measures
in function pred.acc.</p>
</td></tr>
<tr><td><code id="glmnetcv_+3A_...">...</code></td>
<td>
<p>other arguments passed on to 'fields'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following components:
me, rme, mae, rmae, mse, rmse, rrmse, vecv and e1; or vecv only
</p>


<h3>Note</h3>

<p>This function is largely based on 'glmcv' in this 'spm2' package.
</p>


<h3>Author(s)</h3>

<p>Jin Li
</p>


<h3>References</h3>

<p>A. Liaw and M. Wiener (2002). Classification and Regression by
randomForest. R News 2(3), 18-22.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(spm)

data(petrel)
x &lt;- as.matrix(petrel[, c(1, 2, 6:9)])
y &lt;- log(petrel[, 5] + 1)
set.seed(1234)
glmnetcv1 &lt;- glmnetcv(x, y, validation = "CV",  predacc = "ALL")
glmnetcv1

data(sponge)
x &lt;- as.matrix(cbind(sponge$easting, sponge$easting^2))
set.seed(1234)
glmnetcv1 &lt;- glmnetcv(x, sponge[, 3], family = poisson, validation = "CV",
predacc = "ALL")
glmnetcv1

# For glmnet with gaussian
x &lt;- as.matrix(petrel[, c(1, 2, 6:9)])
y &lt;- log(petrel[, 5] + 1)
set.seed(1234)
n &lt;- 20 # number of iterations,60 to 100 is recommended.
VEcv &lt;- NULL
for (i in 1:n) {
  glmnetcv1 &lt;- glmnetcv(x, y, validation = "CV", predacc = "VEcv")
  VEcv [i] &lt;- glmnetcv1
 }
plot(VEcv ~ c(1:n), xlab = "Iteration for glmnet", ylab = "VEcv (%)")
points(cumsum(VEcv) / c(1:n) ~ c(1:n), col = 2)
abline(h = mean(VEcv), col = 'blue', lwd = 2)

# For glmnet with binomial
x &lt;- as.matrix(cbind(petrel[, c(2, 6)], petrel$long^3, petrel$lat^2, petrel$lat^3))
set.seed(1234)
n &lt;- 20 # number of iterations,60 to 100 is recommended.
VEcv &lt;- NULL
for (i in 1:n) {
glmnetcv1 &lt;- glmnetcv(x, petrel[, 5] / 100, family = binomial(link=logit),
validation = "CV", predacc = "VEcv")
VEcv [i] &lt;- glmnetcv1
}
plot(VEcv ~ c(1:n), xlab = "Iteration for glmnet", ylab = "VEcv (%)")
points(cumsum(VEcv) / c(1:n) ~ c(1:n), col = 2)
abline(h = mean(VEcv), col = 'blue', lwd = 2)


</code></pre>

<hr>
<h2 id='glmpred'>Generate spatial predictions using generalised linear models  ('glm')</h2><span id='topic+glmpred'></span>

<h3>Description</h3>

<p>This function is for generating spatial predictions using 'glm' method
in 'stats' package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>glmpred(formula = NULL, trainxy, longlatpredx, predx, family = "gaussian", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="glmpred_+3A_formula">formula</code></td>
<td>
<p>a formula defining the response variable and predictive variables.</p>
</td></tr>
<tr><td><code id="glmpred_+3A_trainxy">trainxy</code></td>
<td>
<p>a dataframe contains predictive variables and the response
variable of point samples. The location information, longitude (long),
latitude (lat), need to be included in the 'trainx' for spatial predictive
modeling, need to be named as 'long' and 'lat'.</p>
</td></tr>
<tr><td><code id="glmpred_+3A_longlatpredx">longlatpredx</code></td>
<td>
<p>a dataframe contains longitude and latitude of point
locations (i.e., the centers of grids) to be predicted.</p>
</td></tr>
<tr><td><code id="glmpred_+3A_predx">predx</code></td>
<td>
<p>a dataframe or matrix contains columns of predictive variables
for the grids to be predicted.</p>
</td></tr>
<tr><td><code id="glmpred_+3A_family">family</code></td>
<td>
<p>a description of the error distribution and link function to
be used in the model. See '?glm' for details.</p>
</td></tr>
<tr><td><code id="glmpred_+3A_...">...</code></td>
<td>
<p>other arguments passed on to 'glm'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe of longitude, latitude and predictions.
</p>


<h3>Author(s)</h3>

<p>Jin Li
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(spm)
data(petrel)
data(petrel.grid)

gravel &lt;- petrel[, c(1, 2, 6:9, 5)]
model &lt;- log(gravel + 1) ~  lat +  bathy + I(long^3) + I(lat^2) + I(lat^3)

glmpred1 &lt;- glmpred(formula = model, trainxy = gravel,
longlatpredx = petrel.grid[, c(1:2)], predx = petrel.grid)

names(glmpred1)

# Back transform 'glmpred1$pred.glm1' to generate the final predictions
glm.predictions &lt;- exp(glmpred1$pred.glm1) - 1
range(glm.predictions)


</code></pre>

<hr>
<h2 id='glscv'>Cross validation, n-fold and leave-one-out for generalized least squares ('gls')</h2><span id='topic+glscv'></span>

<h3>Description</h3>

<p>This function is a cross validation function for 'gls' method
in 'nlme' package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>glscv(
  model = var1 ~ 1,
  trainxy,
  y,
  corr.args = NULL,
  weights = NULL,
  validation = "CV",
  cv.fold = 10,
  predacc = "VEcv",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="glscv_+3A_model">model</code></td>
<td>
<p>a formula defining the response variable and predictive variables.</p>
</td></tr>
<tr><td><code id="glscv_+3A_trainxy">trainxy</code></td>
<td>
<p>a dataframe contains longitude (long), latitude (lat),
predictive variables and the response variable of point samples. That is,
the location information must be names as 'long' and 'lat'.</p>
</td></tr>
<tr><td><code id="glscv_+3A_y">y</code></td>
<td>
<p>a vector of the response variable in the formula, that is, the left
part of the formula.</p>
</td></tr>
<tr><td><code id="glscv_+3A_corr.args">corr.args</code></td>
<td>
<p>arguments for 'correlation' in 'gls'. See '?corClasses' in 'nlme'
for details. By default, &quot;NULL&quot; is used. When &quot;NULL&quot; is used,
then 'gls' is actually performing 'lm'.</p>
</td></tr>
<tr><td><code id="glscv_+3A_weights">weights</code></td>
<td>
<p>describing the within-group heteroscedasticity structure. Defaults
to &quot;NULL&quot;, corresponding to homoscedastic errors. See '?gls' in 'nlme'
for details.</p>
</td></tr>
<tr><td><code id="glscv_+3A_validation">validation</code></td>
<td>
<p>validation methods, include 'LOO': leave-one-out, and 'CV':
cross-validation.</p>
</td></tr>
<tr><td><code id="glscv_+3A_cv.fold">cv.fold</code></td>
<td>
<p>integer; number of folds in the cross-validation. if &gt; 1,
then apply n-fold cross validation; the default is 10, i.e., 10-fold cross
validation that is recommended.</p>
</td></tr>
<tr><td><code id="glscv_+3A_predacc">predacc</code></td>
<td>
<p>can be either &quot;VEcv&quot; for vecv or &quot;ALL&quot; for all measures
in function pred.acc.</p>
</td></tr>
<tr><td><code id="glscv_+3A_...">...</code></td>
<td>
<p>other arguments passed on to 'gls'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following components:
me, rme, mae, rmae, mse, rmse, rrmse, vecv and e1; or vecv only
</p>


<h3>Note</h3>

<p>This function is largely based on rfcv in 'randomForest' and
'gls' in 'library(nlme)'.
</p>


<h3>Author(s)</h3>

<p>Jin Li
</p>


<h3>References</h3>

<p>Pinheiro, J. C. and D. M. Bates (2000). Mixed-Effects Models
in S and S-PLUS. New York, Springer.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(spm)
library(nlme)

data(petrel)
gravel &lt;- petrel[, c(1, 2, 6:9, 5)]
range1 &lt;- 0.8
nugget1 &lt;- 0.5

model &lt;- log(gravel + 1) ~  long + lat +  bathy + dist + I(long^2) + I(lat^2) +
I(lat^3) + I(bathy^2) + I(bathy^3) + I(dist^2) + I(dist^3) + I(relief^2) + I(relief^3)


glscv1 &lt;- glscv(model = model, gravel, log(gravel[, 7] +1), validation = "CV",
 corr.args = corSpher(c(range1, nugget1), form = ~ long + lat, nugget = TRUE),
 predacc = "ALL")
glscv1

#For gls
set.seed(1234)
n &lt;- 20 # number of iterations,60 to 100 is recommended.
VEcv &lt;- NULL
for (i in 1:n) {
glscv1 &lt;- glscv(model = model, gravel, log(gravel[, 7] +1), validation = "CV",
          corr.args = corSpher(c(range1, nugget1), form = ~ long + lat,
          nugget = TRUE), predacc = "VEcv")
VEcv [i] &lt;- glscv1
}
plot(VEcv ~ c(1:n), xlab = "Iteration for GLS", ylab = "VEcv (%)")
points(cumsum(VEcv) / c(1:n) ~ c(1:n), col = 2)
abline(h = mean(VEcv), col = 'blue', lwd = 2)

# For lm, that is, gls with 'correlation = NULL'
n &lt;- 20 # number of iterations,60 to 100 is recommended.
VEcv &lt;- NULL
set.seed(1234)
for (i in 1:n) {
glscv1 &lt;- glscv(model = model, gravel, log(gravel[, 7] +1),
validation = "CV", predacc = "VEcv")
VEcv [i] &lt;- glscv1
}
plot(VEcv ~ c(1:n), xlab = "Iteration for GLS", ylab = "VEcv (%)")
points(cumsum(VEcv) / c(1:n) ~ c(1:n), col = 2)
abline(h = mean(VEcv), col = 'blue', lwd = 2)


</code></pre>

<hr>
<h2 id='glsidwcv'>Cross validation, n-fold and leave-one-out for the hybrid method of
generalized least squares ('gls') and inverse distance weighted ('idw')
(glsidw)</h2><span id='topic+glsidwcv'></span>

<h3>Description</h3>

<p>This function is a cross validation function
for the hybrid method  of 'gls' and 'idw', where the data splitting is based
on a stratified random  sampling method (see the 'datasplit' function for details)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>glsidwcv(
  model = var1 ~ 1,
  longlat,
  trainxy,
  y,
  corr.args = NULL,
  weights = NULL,
  idp = 2,
  nmaxidw = 12,
  validation = "CV",
  cv.fold = 10,
  predacc = "VEcv",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="glsidwcv_+3A_model">model</code></td>
<td>
<p>a formula defining the response variable and predictive variables.</p>
</td></tr>
<tr><td><code id="glsidwcv_+3A_longlat">longlat</code></td>
<td>
<p>a dataframe contains longitude and latitude of point samples.</p>
</td></tr>
<tr><td><code id="glsidwcv_+3A_trainxy">trainxy</code></td>
<td>
<p>a dataframe contains longitude (long), latitude (lat),
predictive variables and the response variable of point samples. That is,
the location information must be names as 'long' and 'lat'.</p>
</td></tr>
<tr><td><code id="glsidwcv_+3A_y">y</code></td>
<td>
<p>a vector of the response variable in the formula, that is, the left
part of the formula.</p>
</td></tr>
<tr><td><code id="glsidwcv_+3A_corr.args">corr.args</code></td>
<td>
<p>arguments for 'correlation' in 'gls'. See '?corClasses' in 'nlme'
for details. By default, &quot;NULL&quot; is used. When &quot;NULL&quot; is used,
then 'gls' is actually performing 'lm'.</p>
</td></tr>
<tr><td><code id="glsidwcv_+3A_weights">weights</code></td>
<td>
<p>describing the within-group heteroscedasticity structure. Defaults
to &quot;NULL&quot;, corresponding to homoscedastic errors. See '?gls' in 'nlme'
for details.</p>
</td></tr>
<tr><td><code id="glsidwcv_+3A_idp">idp</code></td>
<td>
<p>a numeric number specifying the inverse distance weighting power.</p>
</td></tr>
<tr><td><code id="glsidwcv_+3A_nmaxidw">nmaxidw</code></td>
<td>
<p>for a local predicting: the number of nearest observations that
should be used for a prediction or simulation, where nearest is defined in
terms of the space of the spatial locations. By default, 12 observations
are used.</p>
</td></tr>
<tr><td><code id="glsidwcv_+3A_validation">validation</code></td>
<td>
<p>validation methods, include 'LOO': leave-one-out, and 'CV':
cross-validation.</p>
</td></tr>
<tr><td><code id="glsidwcv_+3A_cv.fold">cv.fold</code></td>
<td>
<p>integer; number of folds in the cross-validation. if &gt; 1,
then apply n-fold cross validation; the default is 10, i.e., 10-fold cross
validation that is recommended.</p>
</td></tr>
<tr><td><code id="glsidwcv_+3A_predacc">predacc</code></td>
<td>
<p>can be either &quot;VEcv&quot; for vecv or &quot;ALL&quot; for all measures
in function pred.acc.</p>
</td></tr>
<tr><td><code id="glsidwcv_+3A_...">...</code></td>
<td>
<p>other arguments passed on to 'gls' and 'gstat'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following components:
me, rme, mae, rmae, mse, rmse, rrmse, vecv and e1; or vecv only.
</p>


<h3>Note</h3>

<p>This function is largely based on rfcv in 'randomForest' and
'gls' in 'library(nlme)'.
</p>


<h3>Author(s)</h3>

<p>Jin Li
</p>


<h3>References</h3>

<p>Pinheiro, J. C. and D. M. Bates (2000). Mixed-Effects Models
in S and S-PLUS. New York, Springer.
</p>
<p>Pebesma, E.J., 2004. Multivariable geostatistics in S: the gstat package.
Computers &amp; Geosciences, 30: 683-691.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(spm)
library(nlme)

data(petrel)
gravel &lt;- petrel[, c(1, 2, 6:9, 5)]
longlat &lt;- petrel[, c(1, 2)]
range1 &lt;- 0.8
nugget1 &lt;- 0.5
model &lt;- log(gravel + 1) ~  long + lat +  bathy + dist + I(long^2) + I(lat^2) +
I(lat^3) + I(bathy^2) + I(bathy^3) + I(dist^2) + I(dist^3) + I(relief^2) + I(relief^3)

glsidwcv1 &lt;- glsidwcv(model = model, longlat = longlat, trainxy = gravel,
y = log(gravel[, 7] +1), idp = 2, nmaxidw = 12, validation = "CV",
 corr.args = corSpher(c(range1, nugget1), form = ~ lat + long, nugget = TRUE),
 predacc = "ALL")
glsidwcv1

# For glsidw
set.seed(1234)
n &lt;- 20 # number of iterations,60 to 100 is recommended.
VEcv &lt;- NULL
for (i in 1:n) {
glsidwcv1 &lt;- glsidwcv(model = model, longlat = longlat, trainxy = gravel,
y = log(gravel[, 7] +1), idp = 2, nmaxidw = 12, validation = "CV",
corr.args = corSpher(c(range1, nugget1), form = ~ lat + long, nugget = TRUE),
predacc = "VEcv")
VEcv [i] &lt;- glsidwcv1
}
plot(VEcv ~ c(1:n), xlab = "Iteration for GLSIDW", ylab = "VEcv (%)")
points(cumsum(VEcv) / c(1:n) ~ c(1:n), col = 2)
abline(h = mean(VEcv), col = 'blue', lwd = 2)


</code></pre>

<hr>
<h2 id='glsidwpred'>Generate spatial predictions using the hybrid method of generalized
least squares ('gls')  and inverse distance weighted ('IDW') ('glsidw')</h2><span id='topic+glsidwpred'></span>

<h3>Description</h3>

<p>This function is for generating spatial predictions using the hybrid
method of 'gls' and 'idw' ('glsidw') (see reference #1).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>glsidwpred(
  model = var1 ~ 1,
  longlat,
  trainxy,
  y,
  longlatpredx,
  predx,
  corr.args = NULL,
  weights = NULL,
  idp = 2,
  nmaxidw = 12,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="glsidwpred_+3A_model">model</code></td>
<td>
<p>a formula defining the response variable and predictive variables.</p>
</td></tr>
<tr><td><code id="glsidwpred_+3A_longlat">longlat</code></td>
<td>
<p>a dataframe contains longitude and latitude of point samples.</p>
</td></tr>
<tr><td><code id="glsidwpred_+3A_trainxy">trainxy</code></td>
<td>
<p>a dataframe contains longitude (long), latitude (lat),
predictive variables and the response variable of point samples. That is,
the location information must be names as 'long' and 'lat'.</p>
</td></tr>
<tr><td><code id="glsidwpred_+3A_y">y</code></td>
<td>
<p>a vector of the response variable in the formula, that is, the left
part of the formula.</p>
</td></tr>
<tr><td><code id="glsidwpred_+3A_longlatpredx">longlatpredx</code></td>
<td>
<p>a dataframe contains longitude and latitude of point locations
(i.e., the centers of grids) to be predicted. The location information must be
named as 'long' and 'lat'.</p>
</td></tr>
<tr><td><code id="glsidwpred_+3A_predx">predx</code></td>
<td>
<p>a dataframe or matrix contains columns of predictive variables
for the grids to be predicted.</p>
</td></tr>
<tr><td><code id="glsidwpred_+3A_corr.args">corr.args</code></td>
<td>
<p>arguments for 'correlation' in 'gls'. See '?corClasses' in 'nlme'
for details. By default, &quot;NULL&quot; is used. When &quot;NULL&quot; is used,
then 'gls' is actually performing 'lm'.</p>
</td></tr>
<tr><td><code id="glsidwpred_+3A_weights">weights</code></td>
<td>
<p>describing the within-group heteroscedasticity structure. Defaults
to &quot;NULL&quot;, corresponding to homoscedastic errors. See '?gls' in 'nlme'
for details.</p>
</td></tr>
<tr><td><code id="glsidwpred_+3A_idp">idp</code></td>
<td>
<p>a numeric number specifying the inverse distance weighting power.</p>
</td></tr>
<tr><td><code id="glsidwpred_+3A_nmaxidw">nmaxidw</code></td>
<td>
<p>for a local predicting: the number of nearest observations that
should be used for a prediction or simulation, where nearest is defined in
terms of the space of the spatial locations. By default, 12 observations
are used.</p>
</td></tr>
<tr><td><code id="glsidwpred_+3A_...">...</code></td>
<td>
<p>other arguments passed on to 'gls' and 'gstat'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe of longitude, latitude, and predictions.
</p>


<h3>Author(s)</h3>

<p>Jin Li
</p>


<h3>References</h3>

<p>Pinheiro, J. C. and D. M. Bates (2000). Mixed-Effects Models
in S and S-PLUS. New York, Springer.
</p>
<p>Pebesma, E.J., 2004. Multivariable geostatistics in S: the gstat package.
Computers &amp; Geosciences, 30: 683-691.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(spm)
library(nlme)

data(petrel)
data(petrel.grid)

gravel &lt;- petrel[, c(1, 2, 6:9, 5)]
longlat &lt;- petrel[, c(1, 2)]
range1 &lt;- 0.8
nugget1 &lt;- 0.5
model &lt;- log(gravel + 1) ~  long + lat +  bathy + dist + I(long^2) + I(lat^2) +
I(lat^3) + I(bathy^2) + I(bathy^3) + I(dist^2) + I(dist^3) + I(relief^2) + I(relief^3)
y &lt;- log(gravel[, 7] +1)

glsidwpred1 &lt;- glsidwpred(model = model, longlat = longlat, trainxy = gravel,
y = y, longlatpredx = petrel.grid[, c(1:2)], predx = petrel.grid,
 idp = 2, nmaxidw = 12, corr.args = corSpher(c(range1, nugget1),
 form = ~ lat + long, nugget = TRUE))

names(glsidwpred1)

# Back transform 'glsidwpred$predictions' to generate the final predictions
glsidw.predictions &lt;- exp(glsidwpred1$predictions) - 1
range(glsidw.predictions)


</code></pre>

<hr>
<h2 id='glskrigecv'>Cross validation, n-fold and leave-one-out for the hybrid method of
generalized least squares ('gls') and kriging ('krige') ('glskrige')</h2><span id='topic+glskrigecv'></span>

<h3>Description</h3>

<p>This function is a cross validation function
for the hybrid method  of 'gls' and 'krige' ('glskrige'), where the data
splitting is based on a stratified random  sampling method (see the
'datasplit' function for details)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>glskrigecv(
  model = var1 ~ 1,
  longlat,
  trainxy,
  y,
  corr.args = NULL,
  weights = NULL,
  transformation = "none",
  delta = 1,
  formula.krige = res1 ~ 1,
  vgm.args = c("Sph"),
  anis = c(0, 1),
  alpha = 0,
  block = 0,
  beta,
  nmaxkrige = 12,
  validation = "CV",
  cv.fold = 10,
  predacc = "VEcv",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="glskrigecv_+3A_model">model</code></td>
<td>
<p>a formula defining the response variable and predictive variables.</p>
</td></tr>
<tr><td><code id="glskrigecv_+3A_longlat">longlat</code></td>
<td>
<p>a dataframe contains longitude and latitude of point samples.</p>
</td></tr>
<tr><td><code id="glskrigecv_+3A_trainxy">trainxy</code></td>
<td>
<p>a dataframe contains longitude (long), latitude (lat),
predictive variables and the response variable of point samples. That is,
the location information must be names as 'long' and 'lat'.</p>
</td></tr>
<tr><td><code id="glskrigecv_+3A_y">y</code></td>
<td>
<p>a vector of the response variable in the formula, that is, the left
part of the formula.</p>
</td></tr>
<tr><td><code id="glskrigecv_+3A_corr.args">corr.args</code></td>
<td>
<p>arguments for 'correlation' in 'gls'. See '?corClasses' in 'nlme'
for details. By default, &quot;NULL&quot; is used. When &quot;NULL&quot; is used,
then 'gls' is actually performing 'lm'.</p>
</td></tr>
<tr><td><code id="glskrigecv_+3A_weights">weights</code></td>
<td>
<p>describing the within-group heteroscedasticity structure. Defaults
to &quot;NULL&quot;, corresponding to homoscedastic errors. See '?gls' in 'nlme'
for details.</p>
</td></tr>
<tr><td><code id="glskrigecv_+3A_transformation">transformation</code></td>
<td>
<p>transform the residuals of 'gls' to normalize the data;
can be &quot;sqrt&quot; for square root, &quot;arcsine&quot; for arcsine, &quot;log&quot; or &quot;none&quot;
for non transformation. By default, &quot;none&quot; is used.</p>
</td></tr>
<tr><td><code id="glskrigecv_+3A_delta">delta</code></td>
<td>
<p>numeric; to avoid log(0) in the log transformation. The default is 1.</p>
</td></tr>
<tr><td><code id="glskrigecv_+3A_formula.krige">formula.krige</code></td>
<td>
<p>formula defining the response vector and (possible) regressor.
an object (i.e., 'variogram.formula') for 'variogram' or a formula for
'krige'. see 'variogram' and 'krige' in 'gstat' for details.</p>
</td></tr>
<tr><td><code id="glskrigecv_+3A_vgm.args">vgm.args</code></td>
<td>
<p>arguments for 'vgm', e.g. variogram model of response
variable and anisotropy parameters. see 'vgm' in 'gstat' for details.
By default, &quot;Sph&quot; is used.</p>
</td></tr>
<tr><td><code id="glskrigecv_+3A_anis">anis</code></td>
<td>
<p>anisotropy parameters: see notes 'vgm' in 'gstat' for details.</p>
</td></tr>
<tr><td><code id="glskrigecv_+3A_alpha">alpha</code></td>
<td>
<p>direction in plane (x,y). see variogram in 'gstat' for details.</p>
</td></tr>
<tr><td><code id="glskrigecv_+3A_block">block</code></td>
<td>
<p>block size. see 'krige' in 'gstat' for details.</p>
</td></tr>
<tr><td><code id="glskrigecv_+3A_beta">beta</code></td>
<td>
<p>for simple kriging. see 'krige' in 'gstat' for details.</p>
</td></tr>
<tr><td><code id="glskrigecv_+3A_nmaxkrige">nmaxkrige</code></td>
<td>
<p>for a local predicting: the number of nearest observations that
should be used for a prediction or simulation, where nearest is defined in
terms of the space of the spatial locations. By default, 12 observations
are used.</p>
</td></tr>
<tr><td><code id="glskrigecv_+3A_validation">validation</code></td>
<td>
<p>validation methods, include 'LOO': leave-one-out, and 'CV':
cross-validation.</p>
</td></tr>
<tr><td><code id="glskrigecv_+3A_cv.fold">cv.fold</code></td>
<td>
<p>integer; number of folds in the cross-validation. if &gt; 1,
then apply n-fold cross validation; the default is 10, i.e., 10-fold cross
validation that is recommended.</p>
</td></tr>
<tr><td><code id="glskrigecv_+3A_predacc">predacc</code></td>
<td>
<p>can be either &quot;VEcv&quot; for vecv or &quot;ALL&quot; for all measures
in function pred.acc.</p>
</td></tr>
<tr><td><code id="glskrigecv_+3A_...">...</code></td>
<td>
<p>other arguments passed on to 'gls' and 'krige'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following components:
me, rme, mae, rmae, mse, rmse, rrmse, vecv and e1; or vecv only.
</p>


<h3>Note</h3>

<p>This function is largely based on rfcv in 'randomForest', 'krigecv' in 'spm2'
and 'gls' in 'library(nlme)'.
</p>


<h3>Author(s)</h3>

<p>Jin Li
</p>


<h3>References</h3>

<p>Pinheiro, J. C. and D. M. Bates (2000). Mixed-Effects Models
in S and S-PLUS. New York, Springer.
</p>
<p>Pebesma, E.J., 2004. Multivariable geostatistics in S: the gstat package.
Computers &amp; Geosciences, 30: 683-691.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(spm)
library(nlme)

data(petrel)
gravel &lt;- petrel[, c(1, 2, 6:9, 5)]
longlat &lt;- petrel[, c(1, 2)]
range1 &lt;- 0.8
nugget1 &lt;- 0.5
model &lt;- log(gravel + 1) ~  long + lat +  bathy + dist + I(long^2) + I(lat^2) +
I(lat^3) + I(bathy^2) + I(bathy^3) + I(dist^2) + I(dist^3) + I(relief^2) + I(relief^3)

glskrigecv1 &lt;- glskrigecv(model = model, longlat = longlat, trainxy = gravel,
y = log(gravel[, 7] +1), transformation = "none", formula.krige = res1 ~ 1,
vgm.args = "Sph", nmaxkrige = 12, validation = "CV",
 corr.args = corSpher(c(range1, nugget1), form = ~ lat + long, nugget = TRUE),
 predacc = "ALL")
glskrigecv1

# For glskrige
set.seed(1234)
n &lt;- 20 # number of iterations,60 to 100 is recommended.
VEcv &lt;- NULL
for (i in 1:n) {
glskrigecv1 &lt;- glskrigecv(model = model, longlat = longlat, trainxy = gravel,
y = log(gravel[, 7] +1), transformation = "none", formula.krige = res1 ~ 1,
vgm.args = "Sph", nmaxok = 12, validation = "CV",
corr.args = corSpher(c(range1, nugget1), form = ~ lat + long, nugget = TRUE),
 predacc = "VEcv")
VEcv [i] &lt;- glskrigecv1
}
plot(VEcv ~ c(1:n), xlab = "Iteration for GLSOK", ylab = "VEcv (%)")
points(cumsum(VEcv) / c(1:n) ~ c(1:n), col = 2)
abline(h = mean(VEcv), col = 'blue', lwd = 2)


</code></pre>

<hr>
<h2 id='glskrigeidwcv'>Cross validation, n-fold and leave-one-out for the hybrid methods of
generalised least squares ('gls'), 'kriging' and inverse distance weighted ('IDW')</h2><span id='topic+glskrigeidwcv'></span>

<h3>Description</h3>

<p>This function is a cross validation function for 38 hybrid
methods of 'gls', 'kriging' and 'IDW', including the average of 'glskrige'
and 'glsidw' ('glskrigeglsidw') and  the average of 'gls', 'glskrige' and 'glsidw'
('glsglskrigeglsidw'), where 'kriging' methods include ordinary kriging ('OK'),
simple kriging ('SK'), block 'OK' ('BOK') and block 'SK'('BSK') and
'IDW' also covers 'NN' and 'KNN'.. The data splitting is based on a
stratified random  sampling method (see the 'datasplit' function for details).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>glskrigeidwcv(
  model = var1 ~ 1,
  longlat,
  trainxy,
  y,
  corr.args = NULL,
  weights = NULL,
  transformation = "none",
  delta = 1,
  formula.krige = res1 ~ 1,
  vgm.args = c("Sph"),
  anis = c(0, 1),
  alpha = 0,
  block = 0,
  beta,
  nmaxkrige = 12,
  idp = 2,
  nmaxidw = 12,
  hybrid.parameter = 2,
  lambda = 1,
  validation = "CV",
  cv.fold = 10,
  predacc = "VEcv",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="glskrigeidwcv_+3A_model">model</code></td>
<td>
<p>a formula defining the response variable and predictive variables.</p>
</td></tr>
<tr><td><code id="glskrigeidwcv_+3A_longlat">longlat</code></td>
<td>
<p>a dataframe contains longitude and latitude of point samples.</p>
</td></tr>
<tr><td><code id="glskrigeidwcv_+3A_trainxy">trainxy</code></td>
<td>
<p>a dataframe contains longitude (long), latitude (lat),
predictive variables and the response variable of point samples. That is,
the location information must be names as 'long' and 'lat'.</p>
</td></tr>
<tr><td><code id="glskrigeidwcv_+3A_y">y</code></td>
<td>
<p>a vector of the response variable in the formula, that is, the left
part of the formula.</p>
</td></tr>
<tr><td><code id="glskrigeidwcv_+3A_corr.args">corr.args</code></td>
<td>
<p>arguments for 'correlation' in 'gls'. See '?corClasses' in 'nlme'
for details. By default, &quot;NULL&quot; is used. When &quot;NULL&quot; is used,
then 'gls' is actually performing 'lm'.</p>
</td></tr>
<tr><td><code id="glskrigeidwcv_+3A_weights">weights</code></td>
<td>
<p>describing the within-group heteroscedasticity structure. Defaults
to &quot;NULL&quot;, corresponding to homoscedastic errors. See '?gls' in 'nlme'
for details.</p>
</td></tr>
<tr><td><code id="glskrigeidwcv_+3A_transformation">transformation</code></td>
<td>
<p>transform the residuals of 'gls' to normalise the data for 'krige';
can be &quot;sqrt&quot; for square root, &quot;arcsine&quot; for arcsine, &quot;log&quot; or &quot;none&quot;
for non transformation. By default, &quot;none&quot; is used.</p>
</td></tr>
<tr><td><code id="glskrigeidwcv_+3A_delta">delta</code></td>
<td>
<p>numeric; to avoid log(0) in the log transformation. The default is 1.</p>
</td></tr>
<tr><td><code id="glskrigeidwcv_+3A_formula.krige">formula.krige</code></td>
<td>
<p>formula defining the response vector and (possible) regressor.
an object (i.e., 'variogram.formula') for 'variogram' or a formula for
'krige'. see 'variogram' and 'krige' in 'gstat' for details.</p>
</td></tr>
<tr><td><code id="glskrigeidwcv_+3A_vgm.args">vgm.args</code></td>
<td>
<p>arguments for 'vgm', e.g. variogram model of response
variable and anisotropy parameters. see 'vgm' in 'gstat' for details.
By default, &quot;Sph&quot; is used.</p>
</td></tr>
<tr><td><code id="glskrigeidwcv_+3A_anis">anis</code></td>
<td>
<p>anisotropy parameters: see notes 'vgm' in 'gstat' for details.</p>
</td></tr>
<tr><td><code id="glskrigeidwcv_+3A_alpha">alpha</code></td>
<td>
<p>direction in plane (x,y). see variogram in 'gstat' for details.</p>
</td></tr>
<tr><td><code id="glskrigeidwcv_+3A_block">block</code></td>
<td>
<p>block size. see 'krige' in 'gstat' for details.</p>
</td></tr>
<tr><td><code id="glskrigeidwcv_+3A_beta">beta</code></td>
<td>
<p>for simple kriging. see 'krige' in 'gstat' for details.</p>
</td></tr>
<tr><td><code id="glskrigeidwcv_+3A_nmaxkrige">nmaxkrige</code></td>
<td>
<p>for a local predicting: the number of nearest observations that
should be used for a prediction or simulation, where nearest is defined in
terms of the space of the spatial locations. By default, 12 observations
are used.</p>
</td></tr>
<tr><td><code id="glskrigeidwcv_+3A_idp">idp</code></td>
<td>
<p>a numeric number specifying the inverse distance weighting power.</p>
</td></tr>
<tr><td><code id="glskrigeidwcv_+3A_nmaxidw">nmaxidw</code></td>
<td>
<p>for a local predicting: the number of nearest observations that
should be used for a prediction or simulation, where nearest is defined in
terms of the space of the spatial locations. By default, 12 observations
are used.</p>
</td></tr>
<tr><td><code id="glskrigeidwcv_+3A_hybrid.parameter">hybrid.parameter</code></td>
<td>
<p>the default is 2 that is for 'glskrigeglsidw';
for 'glsglskrigeglsidw', it needs to be 3.</p>
</td></tr>
<tr><td><code id="glskrigeidwcv_+3A_lambda">lambda</code></td>
<td>
<p>ranging from 0 to 2; the default is 1 for 'glskrigeglsidw'
and 'glsglskrigeglsidw'; and if it is &lt; 1, more weight is placed on 'krige',
otherwise more weight is placed on 'idw'; and if it is 0, 'idw' is not
considered and the resultant methods is 'glskrige' when the default
'hybrid.parameter' is used; and if it is 2, then the resultant method is
'glsidw' when the default 'hybrid.parameter' is used.</p>
</td></tr>
<tr><td><code id="glskrigeidwcv_+3A_validation">validation</code></td>
<td>
<p>validation methods, include 'LOO': leave-one-out, and 'CV':
cross-validation.</p>
</td></tr>
<tr><td><code id="glskrigeidwcv_+3A_cv.fold">cv.fold</code></td>
<td>
<p>integer; number of folds in the cross-validation. if &gt; 1,
then apply n-fold cross validation; the default is 10, i.e., 10-fold cross
validation that is recommended.</p>
</td></tr>
<tr><td><code id="glskrigeidwcv_+3A_predacc">predacc</code></td>
<td>
<p>can be either &quot;VEcv&quot; for vecv or &quot;ALL&quot; for all measures
in function pred.acc.</p>
</td></tr>
<tr><td><code id="glskrigeidwcv_+3A_...">...</code></td>
<td>
<p>other arguments passed on to 'gls', 'krige' and 'gstat'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following components:
me, rme, mae, rmae, mse, rmse, rrmse, vecv and e1; or vecv only.
</p>


<h3>Note</h3>

<p>This function is largely based on rfcv in 'randomForest', 'krigecv' in 'spm2'
and 'gls' in 'library(nlme)'.
</p>


<h3>Author(s)</h3>

<p>Jin Li
</p>


<h3>References</h3>

<p>Li, J. (2022). Spatial Predictive Modeling with R. Boca Raton,
Chapman and Hall/CRC.
</p>
<p>Pinheiro, J. C. and D. M. Bates (2000). Mixed-Effects Models
in S and S-PLUS. New York, Springer.
</p>
<p>Pebesma, E.J., 2004. Multivariable geostatistics in S: the gstat package.
Computers &amp; Geosciences, 30: 683-691.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(spm)
library(nlme)

data(petrel)
gravel &lt;- petrel[, c(1, 2, 6:9, 5)]
longlat &lt;- petrel[, c(1, 2)]
range1 &lt;- 0.8
nugget1 &lt;- 0.5
model &lt;- log(gravel + 1) ~  long + lat +  bathy + dist + I(long^2) + I(lat^2) +
I(lat^3) + I(bathy^2) + I(bathy^3) + I(dist^2) + I(dist^3) + I(relief^2) + I(relief^3)

glskrigeidwcv1 &lt;- glskrigeidwcv(model = model, longlat = longlat, trainxy = gravel,
y = log(gravel[, 7] +1), transformation = "none", formula.krige = res1 ~ 1,
vgm.args = "Sph", nmaxkrige = 12, idp = 2, nmaxidw = 12, validation = "CV",
 corr.args = corSpher(c(range1, nugget1), form = ~ lat + long, nugget = TRUE),
 predacc = "ALL")
glskrigeidwcv1

# For glskrigeglsidw
set.seed(1234)
n &lt;- 20 # number of iterations,60 to 100 is recommended.
VEcv &lt;- NULL
for (i in 1:n) {
glskrigeidwcv1 &lt;- glskrigeidwcv(model = model, longlat = longlat, trainxy = gravel,
y = log(gravel[, 7] +1), transformation = "none", formula.krige = res1 ~ 1,
vgm.args = "Sph", nmaxkrige = 12, idp = 2, nmaxidw = 12, validation = "CV",
corr.args = corSpher(c(range1, nugget1), form = ~ lat + long, nugget = TRUE),
 predacc = "VEcv")
VEcv [i] &lt;- glskrigeidwcv1
}
plot(VEcv ~ c(1:n), xlab = "Iteration for GLSOKGLSIDW", ylab = "VEcv (%)")
points(cumsum(VEcv) / c(1:n) ~ c(1:n), col = 2)
abline(h = mean(VEcv), col = 'blue', lwd = 2)


# For glsglskrigeglsidw
set.seed(1234)
n &lt;- 20 # number of iterations,60 to 100 is recommended.
VEcv &lt;- NULL
for (i in 1:n) {
glskrigeidwcv1 &lt;- glskrigeidwcv(model = model, longlat = longlat, trainxy = gravel,
y = log(gravel[, 7] +1), transformation = "none", formula.krige = res1 ~ 1,
vgm.args = "Sph", nmaxkrige = 12, idp = 2, nmaxidw = 12, hybrid.parameter = 3,
validation = "CV", corr.args = corSpher(c(range1, nugget1), form = ~ lat + long,
 nugget = TRUE), predacc = "VEcv")
VEcv [i] &lt;- glskrigeidwcv1
}
plot(VEcv ~ c(1:n), xlab = "Iteration for GLSOKGLSIDW", ylab = "VEcv (%)")
points(cumsum(VEcv) / c(1:n) ~ c(1:n), col = 2)
abline(h = mean(VEcv), col = 'blue', lwd = 2)


</code></pre>

<hr>
<h2 id='glskrigeidwpred'>Generate spatial predictions using the hybrid methods of
generalised least squares ('gls'), 'kriging' and inverse distance weighted ('IDW')</h2><span id='topic+glskrigeidwpred'></span>

<h3>Description</h3>

<p>This function is for generating spatial predictions using the
hybrid methods of 'gls', 'kriging' and 'IDW', including all methods implemented
in 'glskrigeidwcv'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>glskrigeidwpred(
  model = var1 ~ 1,
  longlat,
  trainxy,
  predx,
  y,
  longlatpredx,
  corr.args = NULL,
  weights = NULL,
  transformation = "none",
  delta = 1,
  formula.krige = res1 ~ 1,
  vgm.args = c("Sph"),
  anis = c(0, 1),
  alpha = 0,
  block = 0,
  beta,
  nmaxkrige = 12,
  idp = 2,
  nmaxidw = 12,
  hybrid.parameter = 2,
  lambda = 1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="glskrigeidwpred_+3A_model">model</code></td>
<td>
<p>a formula defining the response variable and predictive variables.</p>
</td></tr>
<tr><td><code id="glskrigeidwpred_+3A_longlat">longlat</code></td>
<td>
<p>a dataframe contains longitude and latitude of point samples.</p>
</td></tr>
<tr><td><code id="glskrigeidwpred_+3A_trainxy">trainxy</code></td>
<td>
<p>a dataframe contains longitude (long), latitude (lat),
predictive variables and the response variable of point samples. That is,
the location information must be names as 'long' and 'lat'.</p>
</td></tr>
<tr><td><code id="glskrigeidwpred_+3A_predx">predx</code></td>
<td>
<p>a dataframe or matrix contains columns of predictive variables
for the grids to be predicted.</p>
</td></tr>
<tr><td><code id="glskrigeidwpred_+3A_y">y</code></td>
<td>
<p>a vector of the response variable in the formula, that is, the left
part of the formula.</p>
</td></tr>
<tr><td><code id="glskrigeidwpred_+3A_longlatpredx">longlatpredx</code></td>
<td>
<p>a dataframe contains longitude and latitude of point locations
(i.e., the centers of grids) to be predicted. The location information must be
named as 'long' and 'lat'.</p>
</td></tr>
<tr><td><code id="glskrigeidwpred_+3A_corr.args">corr.args</code></td>
<td>
<p>arguments for 'correlation' in 'gls'. See '?corClasses' in 'nlme'
for details. By default, &quot;NULL&quot; is used. When &quot;NULL&quot; is used,
then 'gls' is actually performing 'lm'.</p>
</td></tr>
<tr><td><code id="glskrigeidwpred_+3A_weights">weights</code></td>
<td>
<p>describing the within-group heteroscedasticity structure. Defaults
to &quot;NULL&quot;, corresponding to homoscedastic errors. See '?gls' in 'nlme'
for details.</p>
</td></tr>
<tr><td><code id="glskrigeidwpred_+3A_transformation">transformation</code></td>
<td>
<p>transform the residuals of 'gls' to normalise the data for 'krige';
can be &quot;sqrt&quot; for square root, &quot;arcsine&quot; for arcsine, &quot;log&quot; or &quot;none&quot;
for non transformation. By default, &quot;none&quot; is used.</p>
</td></tr>
<tr><td><code id="glskrigeidwpred_+3A_delta">delta</code></td>
<td>
<p>numeric; to avoid log(0) in the log transformation. The default is 1.</p>
</td></tr>
<tr><td><code id="glskrigeidwpred_+3A_formula.krige">formula.krige</code></td>
<td>
<p>formula defining the response vector and (possible) regressor.
an object (i.e., 'variogram.formula') for 'variogram' or a formula for
'krige'. see 'variogram' and 'krige' in 'gstat' for details.</p>
</td></tr>
<tr><td><code id="glskrigeidwpred_+3A_vgm.args">vgm.args</code></td>
<td>
<p>arguments for 'vgm', e.g. variogram model of response
variable and anisotropy parameters. see 'vgm' in 'gstat' for details.
By default, &quot;Sph&quot; is used.</p>
</td></tr>
<tr><td><code id="glskrigeidwpred_+3A_anis">anis</code></td>
<td>
<p>anisotropy parameters: see notes 'vgm' in 'gstat' for details.</p>
</td></tr>
<tr><td><code id="glskrigeidwpred_+3A_alpha">alpha</code></td>
<td>
<p>direction in plane (x,y). see variogram in 'gstat' for details.</p>
</td></tr>
<tr><td><code id="glskrigeidwpred_+3A_block">block</code></td>
<td>
<p>block size. see 'krige' in 'gstat' for details.</p>
</td></tr>
<tr><td><code id="glskrigeidwpred_+3A_beta">beta</code></td>
<td>
<p>for simple kriging. see 'krige' in 'gstat' for details.</p>
</td></tr>
<tr><td><code id="glskrigeidwpred_+3A_nmaxkrige">nmaxkrige</code></td>
<td>
<p>for a local predicting: the number of nearest observations that
should be used for a prediction or simulation, where nearest is defined in
terms of the space of the spatial locations. By default, 12 observations
are used.</p>
</td></tr>
<tr><td><code id="glskrigeidwpred_+3A_idp">idp</code></td>
<td>
<p>a numeric number specifying the inverse distance weighting power.</p>
</td></tr>
<tr><td><code id="glskrigeidwpred_+3A_nmaxidw">nmaxidw</code></td>
<td>
<p>for a local predicting: the number of nearest observations that
should be used for a prediction or simulation, where nearest is defined in
terms of the space of the spatial locations. By default, 12 observations
are used.</p>
</td></tr>
<tr><td><code id="glskrigeidwpred_+3A_hybrid.parameter">hybrid.parameter</code></td>
<td>
<p>the default is 2 that is for 'glskrigeglsidw';
for 'glsglskrigeglsidw', it needs to be 3.</p>
</td></tr>
<tr><td><code id="glskrigeidwpred_+3A_lambda">lambda</code></td>
<td>
<p>ranging from 0 to 2; the default is 1 for 'glskrigeglsidw'
and 'glsglskrigeglsidw'; and if it is &lt; 1, more weight is placed on 'krige',
otherwise more weight is placed on 'idw'; and if it is 0, 'idw' is not
considered and the resultant methods is 'glskrige' when the default
'hybrid.parameter' is used; and if it is 2, then the resultant method is
'glsidw' when the default 'hybrid.parameter' is used.</p>
</td></tr>
<tr><td><code id="glskrigeidwpred_+3A_...">...</code></td>
<td>
<p>other arguments passed on to 'gls', 'krige' and 'gstat'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe of longitude, latitude, and predictions.
</p>


<h3>Author(s)</h3>

<p>Jin Li
</p>


<h3>References</h3>

<p>Pinheiro, J. C. and D. M. Bates (2000). Mixed-Effects Models
in S and S-PLUS. New York, Springer.
</p>
<p>Pebesma, E.J., 2004. Multivariable geostatistics in S: the gstat package.
Computers &amp; Geosciences, 30: 683-691.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(spm)
library(nlme)

data(petrel)
data(petrel.grid)

gravel &lt;- petrel[, c(1, 2, 6:9, 5)]
longlat &lt;- petrel[, c(1, 2)]
range1 &lt;- 0.8
nugget1 &lt;- 0.5
model &lt;- log(gravel + 1) ~  long + lat +  bathy + dist + I(long^2) + I(lat^2) +
I(lat^3) + I(bathy^2) + I(bathy^3) + I(dist^2) + I(dist^3) + I(relief^2) + I(relief^3)
y &lt;- log(gravel[, 7] +1)

glskrigeidwpred1 &lt;- glskrigeidwpred(model = model, longlat = longlat, trainxy = gravel,
predx = petrel.grid, y = y, longlatpredx = petrel.grid[, c(1:2)],
transformation = "none", formula.krige = res1 ~ 1, vgm.args = "Sph", nmaxkrige = 12,
idp = 2, nmaxidw = 12,  corr.args = corSpher(c(range1, nugget1),
form = ~ lat + long, nugget = TRUE))

names(glskrigeidwpred1)

# Back transform 'glskrigeidwpred$predictions' to generate the final predictions
glskrigeidw.predictions &lt;- exp(glskrigeidwpred1$predictions) - 1
range(glskrigeidw.predictions)


</code></pre>

<hr>
<h2 id='glskrigepred'>Generate spatial predictions using the hybrid method of generalized
least squares ('gls') and kriging ('krige') ('glskrige')</h2><span id='topic+glskrigepred'></span>

<h3>Description</h3>

<p>This function is for generating spatial predictions using the
hybrid method of 'gls' and 'krige' (glskrige).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>glskrigepred(
  model = var1 ~ 1,
  longlat,
  trainxy,
  predx,
  y,
  longlatpredx,
  corr.args = NULL,
  weights = NULL,
  transformation = "none",
  delta = 1,
  formula.krige = res1 ~ 1,
  vgm.args = c("Sph"),
  anis = c(0, 1),
  alpha = 0,
  block = 0,
  beta,
  nmaxkrige = 12,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="glskrigepred_+3A_model">model</code></td>
<td>
<p>a formula defining the response variable and predictive variables.</p>
</td></tr>
<tr><td><code id="glskrigepred_+3A_longlat">longlat</code></td>
<td>
<p>a dataframe contains longitude and latitude of point samples.</p>
</td></tr>
<tr><td><code id="glskrigepred_+3A_trainxy">trainxy</code></td>
<td>
<p>a dataframe contains longitude (long), latitude (lat),
predictive variables and the response variable of point samples. That is,
the location information must be names as 'long' and 'lat'.</p>
</td></tr>
<tr><td><code id="glskrigepred_+3A_predx">predx</code></td>
<td>
<p>a dataframe or matrix contains columns of predictive variables
for the grids to be predicted.</p>
</td></tr>
<tr><td><code id="glskrigepred_+3A_y">y</code></td>
<td>
<p>a vector of the response variable in the formula, that is, the left
part of the formula.</p>
</td></tr>
<tr><td><code id="glskrigepred_+3A_longlatpredx">longlatpredx</code></td>
<td>
<p>a dataframe contains longitude and latitude of point locations
(i.e., the centers of grids) to be predicted. The location information must be
named as 'long' and 'lat'.</p>
</td></tr>
<tr><td><code id="glskrigepred_+3A_corr.args">corr.args</code></td>
<td>
<p>arguments for 'correlation' in 'gls'. See '?corClasses' in 'nlme'
for details. By default, &quot;NULL&quot; is used. When &quot;NULL&quot; is used,
then 'gls' is actually performing 'lm'.</p>
</td></tr>
<tr><td><code id="glskrigepred_+3A_weights">weights</code></td>
<td>
<p>describing the within-group heteroscedasticity structure. Defaults
to &quot;NULL&quot;, corresponding to homoscedastic errors. See '?gls' in 'nlme'
for details.</p>
</td></tr>
<tr><td><code id="glskrigepred_+3A_transformation">transformation</code></td>
<td>
<p>transform the residuals of 'gls' to normalize the data;
can be &quot;sqrt&quot; for square root, &quot;arcsine&quot; for arcsine, &quot;log&quot; or &quot;none&quot;
for non transformation. By default, &quot;none&quot; is used.</p>
</td></tr>
<tr><td><code id="glskrigepred_+3A_delta">delta</code></td>
<td>
<p>numeric; to avoid log(0) in the log transformation. The default is 1.</p>
</td></tr>
<tr><td><code id="glskrigepred_+3A_formula.krige">formula.krige</code></td>
<td>
<p>formula defining the response vector and (possible) regressor.
an object (i.e., 'variogram.formula') for 'variogram' or a formula for
'krige'. see 'variogram' and 'krige' in 'gstat' for details.</p>
</td></tr>
<tr><td><code id="glskrigepred_+3A_vgm.args">vgm.args</code></td>
<td>
<p>arguments for 'vgm', e.g. variogram model of response
variable and anisotropy parameters. see 'vgm' in 'gstat' for details.
By default, &quot;Sph&quot; is used.</p>
</td></tr>
<tr><td><code id="glskrigepred_+3A_anis">anis</code></td>
<td>
<p>anisotropy parameters: see notes 'vgm' in 'gstat' for details.</p>
</td></tr>
<tr><td><code id="glskrigepred_+3A_alpha">alpha</code></td>
<td>
<p>direction in plane (x,y). see variogram in 'gstat' for details.</p>
</td></tr>
<tr><td><code id="glskrigepred_+3A_block">block</code></td>
<td>
<p>block size. see 'krige' in 'gstat' for details.</p>
</td></tr>
<tr><td><code id="glskrigepred_+3A_beta">beta</code></td>
<td>
<p>for simple kriging. see 'krige' in 'gstat' for details.</p>
</td></tr>
<tr><td><code id="glskrigepred_+3A_nmaxkrige">nmaxkrige</code></td>
<td>
<p>for a local predicting: the number of nearest observations that
should be used for a prediction or simulation, where nearest is defined in
terms of the space of the spatial locations. By default, 12 observations
are used.</p>
</td></tr>
<tr><td><code id="glskrigepred_+3A_...">...</code></td>
<td>
<p>other arguments passed on to 'gls' and 'krige'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe of longitude, latitude, and predictions.
</p>


<h3>Author(s)</h3>

<p>Jin Li
</p>


<h3>References</h3>

<p>Pinheiro, J. C. and D. M. Bates (2000). Mixed-Effects Models
in S and S-PLUS. New York, Springer.
</p>
<p>Pebesma, E.J., 2004. Multivariable geostatistics in S: the gstat package.
Computers &amp; Geosciences, 30: 683-691.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(spm)
library(nlme)

data(petrel)
data(petrel.grid)

gravel &lt;- petrel[, c(1, 2, 6:9, 5)]
longlat &lt;- petrel[, c(1, 2)]
range1 &lt;- 0.8
nugget1 &lt;- 0.5
model &lt;- log(gravel + 1) ~  long + lat +  bathy + dist + I(long^2) + I(lat^2) +
I(lat^3) + I(bathy^2) + I(bathy^3) + I(dist^2) + I(dist^3) + I(relief^2) + I(relief^3)
y &lt;- log(gravel[, 7] +1)

glskrigepred1 &lt;- glskrigepred(model = model, longlat = longlat, trainxy = gravel,
predx = petrel.grid, y = y, longlatpredx = petrel.grid[, c(1:2)],
transformation = "none", formula.krige = res1 ~ 1,
vgm.args = "Sph", nmaxkrige = 12, corr.args = corSpher(c(range1, nugget1),
form = ~ lat + long, nugget = TRUE))

names(glskrigepred1)

# Back transform 'glskrigepred$predictions' to generate the final predictions
glskrige.predictions &lt;- exp(glskrigepred1$predictions) - 1
range(glskrige.predictions)


</code></pre>

<hr>
<h2 id='glspred'>Generate spatial predictions using generalized least squares ('gls')</h2><span id='topic+glspred'></span>

<h3>Description</h3>

<p>This function is for generating spatial predictions using  'gls' method
in 'nlme' package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>glspred(
  model = var1 ~ 1,
  trainxy,
  longlatpredx,
  predx,
  corr.args = NULL,
  weights = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="glspred_+3A_model">model</code></td>
<td>
<p>a formula defining the response variable and predictive variables.</p>
</td></tr>
<tr><td><code id="glspred_+3A_trainxy">trainxy</code></td>
<td>
<p>a dataframe contains longitude (long), latitude (lat),
predictive variables and the response variable of point samples. That is,
the location information must be names as 'long' and 'lat'.</p>
</td></tr>
<tr><td><code id="glspred_+3A_longlatpredx">longlatpredx</code></td>
<td>
<p>a dataframe contains longitude and latitude of point
locations (i.e., the centers of grids) to be predicted, need to be named as
'long' and 'lat'.</p>
</td></tr>
<tr><td><code id="glspred_+3A_predx">predx</code></td>
<td>
<p>a dataframe or matrix contains columns of predictive variables
for the grids to be predicted.</p>
</td></tr>
<tr><td><code id="glspred_+3A_corr.args">corr.args</code></td>
<td>
<p>arguments for 'correlation' in 'gls'. See '?corClasses' in 'nlme'
for details. By default, &quot;NULL&quot; is used. When &quot;NULL&quot; is used,
then 'gls' is actually performing 'lm'.</p>
</td></tr>
<tr><td><code id="glspred_+3A_weights">weights</code></td>
<td>
<p>describing the within-group heteroscedasticity structure. Defaults
to &quot;NULL&quot;, corresponding to homoscedastic errors. See '?gls' in 'nlme'
for details.</p>
</td></tr>
<tr><td><code id="glspred_+3A_...">...</code></td>
<td>
<p>other arguments passed on to 'gls'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe of longitude, latitude and predictions.
</p>


<h3>Author(s)</h3>

<p>Jin Li
</p>


<h3>References</h3>

<p>Pinheiro, J. C. and D. M. Bates (2000). Mixed-Effects Models
in S and S-PLUS. New York, Springer.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(spm)
library(nlme)

data(petrel)
data(petrel.grid)

gravel &lt;- petrel[, c(1, 2, 6:9, 5)]
range1 &lt;- 0.8
nugget1 &lt;- 0.5

model &lt;- log(gravel + 1) ~  long + lat +  bathy + dist + I(long^2) + I(lat^2) +
I(lat^3) + I(bathy^2) + I(bathy^3) + I(dist^2) + I(dist^3) + I(relief^2) + I(relief^3)

glspred1 &lt;- glspred(model = model, trainxy = gravel,
 longlatpredx = petrel.grid[, c(1:2)], predx = petrel.grid,
 corr.args = corSpher(c(range1, nugget1), form = ~ lat + long, nugget = TRUE))

names(glspred1)

# Back transform 'glspred1$predictions' to generate the final predictions
gls.predictions &lt;- exp(glspred1$predictions) - 1
range(gls.predictions)


</code></pre>

<hr>
<h2 id='krigecv'>Cross validation, n-fold and leave-one-out for kriging methods ('krige')</h2><span id='topic+krigecv'></span>

<h3>Description</h3>

<p>This function is a cross validation function
for kriging methods ('krige') in 'gstat'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>krigecv(
  longlat,
  trainy,
  trainpredx = NULL,
  validation = "CV",
  cv.fold = 10,
  nmax = 12,
  transformation = "none",
  delta = 1,
  formula = var1 ~ 1,
  vgm.args = ("Sph"),
  anis = c(0, 1),
  alpha = 0,
  block = 0,
  beta,
  predacc = "VEcv",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="krigecv_+3A_longlat">longlat</code></td>
<td>
<p>a dataframe contains longitude and latitude of point samples.</p>
</td></tr>
<tr><td><code id="krigecv_+3A_trainy">trainy</code></td>
<td>
<p>a vector of response, must have length equal to the number of
rows in trainx.</p>
</td></tr>
<tr><td><code id="krigecv_+3A_trainpredx">trainpredx</code></td>
<td>
<p>a dataframe contains predictive variables of point samples.
If longitude and latitude are going to be used as predictive variables, they
should also be included but they should be named in names other than 'long' and 'lat'.</p>
</td></tr>
<tr><td><code id="krigecv_+3A_validation">validation</code></td>
<td>
<p>validation methods, include 'LOO': leave-one-out, and 'CV':
cross-validation.</p>
</td></tr>
<tr><td><code id="krigecv_+3A_cv.fold">cv.fold</code></td>
<td>
<p>integer; number of folds in the cross-validation. if &gt; 1,
then apply n-fold cross validation; the default is 10, i.e., 10-fold cross
validation that is recommended.</p>
</td></tr>
<tr><td><code id="krigecv_+3A_nmax">nmax</code></td>
<td>
<p>for local kriging: the number of nearest observations that
should be used for a kriging prediction or simulation, where nearest is
defined in terms of the space of the spatial locations. By default, 12
observations are used.</p>
</td></tr>
<tr><td><code id="krigecv_+3A_transformation">transformation</code></td>
<td>
<p>transform response variable to normalise the data;
can be &quot;sqrt&quot; for square root, &quot;arcsine&quot; for arcsine, &quot;log&quot; or &quot;none&quot;
for non transformation. By default, &quot;none&quot; is used.</p>
</td></tr>
<tr><td><code id="krigecv_+3A_delta">delta</code></td>
<td>
<p>numeric; to avoid 'log(0)' in &quot;log&quot; transformation. The default is 1.</p>
</td></tr>
<tr><td><code id="krigecv_+3A_formula">formula</code></td>
<td>
<p>formula defining response vector and (possible) regressor.
an object (i.e., 'variogram.formula') for 'variogram' or a formula for
'krige'. see 'variogram' and 'krige' in the 'gstat' package for details.</p>
</td></tr>
<tr><td><code id="krigecv_+3A_vgm.args">vgm.args</code></td>
<td>
<p>arguments for 'vgm', e.g. variogram model of response
variable and anisotropy parameters. see 'vgm' in the 'gstat' package for details.
By default, &quot;Sph&quot; is used.</p>
</td></tr>
<tr><td><code id="krigecv_+3A_anis">anis</code></td>
<td>
<p>anisotropy parameters: see notes 'vgm' in the 'gstat' package for details.</p>
</td></tr>
<tr><td><code id="krigecv_+3A_alpha">alpha</code></td>
<td>
<p>direction in plane (x,y). see variogram in the 'gstat' package for details.</p>
</td></tr>
<tr><td><code id="krigecv_+3A_block">block</code></td>
<td>
<p>block size. see 'krige' in the 'gstat' package for details.</p>
</td></tr>
<tr><td><code id="krigecv_+3A_beta">beta</code></td>
<td>
<p>for simple kriging. see 'krige' in the 'gstat' package for details.</p>
</td></tr>
<tr><td><code id="krigecv_+3A_predacc">predacc</code></td>
<td>
<p>can be either &quot;VEcv&quot; for vecv or &quot;ALL&quot; for all measures
in function pred.acc.</p>
</td></tr>
<tr><td><code id="krigecv_+3A_...">...</code></td>
<td>
<p>other arguments passed on to the function 'gstat'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following components:
me, rme, mae, rmae, mse, rmse, rrmse, vecv and e1; or vecv only
</p>


<h3>Note</h3>

<p>This function is largely based on rfcv in 'randomForest' and
some functions in 'library(gstat)'.  When 'A zero or negative range was fitted
to variogram' occurs, to allow 'gstat' running, the range was set to be positive by
using 'min(vgm1$dist)'. In this case, caution should be taken in applying this
method. If it still occurs for 'okpred' function, different method may need to be
used.
</p>


<h3>Author(s)</h3>

<p>Jin Li
</p>


<h3>References</h3>

<p>Li, J., 2013. Predictive Modelling Using Random Forest and Its
Hybrid Methods with Geostatistical Techniques in Marine Environmental
Geosciences, In: Christen, P., Kennedy, P., Liu, L., Ong, K.-L., Stranieri,
A., Zhao, Y. (Eds.), The proceedings of the Eleventh Australasian Data
Mining Conference (AusDM 2013), Canberra, Australia, 13-15 November 2013.
Conferences in Research and Practice in Information Technology, Vol. 146.
</p>
<p>A. Liaw and M. Wiener (2002). Classification and Regression by
randomForest. R News 2(3), 18-22.
</p>
<p>Pebesma, E.J., 2004. Multivariable geostatistics in S: the gstat
package. Computers &amp; Geosciences, 30: 683-691.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(sp)
library(spm)
data(swmud)
data(petrel)

set.seed(1234)
okcv1 &lt;- krigecv(longlat = swmud[, c(1,2)], trainy = swmud[, 3], nmax = 7, transformation =
"arcsine", vgm.args = ("Sph"), predacc = "VEcv")
okcv1

set.seed(1234)
skcv1 &lt;- krigecv(longlat = swmud[, c(1,2)], trainy = swmud[, 3], nmax = 7, transformation =
"arcsine", vgm.args = ("Sph"), predacc = "VEcv", beta = mean(swmud[, 3]))
skcv1

set.seed(1234)
ukcv1 &lt;- krigecv(longlat = swmud[, c(1,2)], trainy = swmud[, 3], nmax = 7, transformation =
"arcsine", formula = var1 ~ long + lat, vgm.args = ("Sph"), predacc = "VEcv")
ukcv1

set.seed(1234)
okcv2 &lt;- krigecv(longlat = swmud[, c(1,2)], trainy = swmud[, 3], validation = "LOO", nmax = 7,
transformation = "arcsine", vgm.args = ("Sph"), predacc = "ALL")
okcv2

set.seed(1234)
n &lt;- 20 # number of iterations,60 to 100 is recommended.
VEcv &lt;- NULL
for (i in 1:n) {
okcv1 &lt;- krigecv(longlat = petrel[, c(1,2)], trainy = petrel[, 5], nmax = 12,
transformation = "arcsine", predacc = "VEcv")
VEcv [i] &lt;- okcv1
}
plot(VEcv ~ c(1:n), xlab = "Iteration for OK", ylab = "VEcv (%)")
points(cumsum(VEcv) / c(1:n) ~ c(1:n), col = 2)
abline(h = mean(VEcv), col = 'blue', lwd = 2)

set.seed(1234)
n &lt;- 20 # number of iterations, 60 to 100 is recommended.
measures &lt;- NULL
for (i in 1:n) {
okcv1 &lt;- krigecv(longlat = petrel[, c(1,2)], trainy = petrel[, 3], nmax = 12, transformation =
"arcsine", predacc = "ALL")
measures &lt;- rbind(measures, okcv1$vecv)
}
plot(measures ~ c(1:n), xlab = "Iteration for OK", ylab = "VEcv (%)")
points(cumsum(measures) / c(1:n) ~ c(1:n), col = 2)
abline(h = mean(measures), col = 'blue', lwd = 2)


</code></pre>

<hr>
<h2 id='krigepred'>Generate spatial predictions using kriging methods ('krige')</h2><span id='topic+krigepred'></span>

<h3>Description</h3>

<p>This function is to make spatial predictions using kriging methods ('krige').
</p>


<h3>Usage</h3>

<pre><code class='language-R'>krigepred(
  trainx,
  trainy,
  trainx2,
  nmax = 12,
  transformation = "none",
  delta = 1,
  formula = var1 ~ 1,
  vgm.args = ("Sph"),
  anis = c(0, 1),
  alpha = 0,
  block = 0,
  beta,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="krigepred_+3A_trainx">trainx</code></td>
<td>
<p>a dataframe contains longitude (long), latitude (lat) and
predictive variables of point samples. The location information must be named
as 'long' and 'lat'.</p>
</td></tr>
<tr><td><code id="krigepred_+3A_trainy">trainy</code></td>
<td>
<p>a vector of response, must have length equal to the number of
rows in trainx.</p>
</td></tr>
<tr><td><code id="krigepred_+3A_trainx2">trainx2</code></td>
<td>
<p>a dataframe contains longitude (long), latitude (lat) and
predictive variables of point locations (i.e., the centres of grids) to
be predicted. The location information must be named as 'long' and 'lat' and
in the first two columns respectively..</p>
</td></tr>
<tr><td><code id="krigepred_+3A_nmax">nmax</code></td>
<td>
<p>for local kriging: the number of nearest observations that
should be used for a kriging prediction or simulation, where nearest is
defined in terms of the space of the spatial locations. By default, 12
observations are used.</p>
</td></tr>
<tr><td><code id="krigepred_+3A_transformation">transformation</code></td>
<td>
<p>transform the response variable to normalise the data;
can be &quot;sqrt&quot; for square root, &quot;arcsine&quot; for arcsine, &quot;log&quot; or &quot;none&quot;
for non transformation. By default, &quot;none&quot; is used.</p>
</td></tr>
<tr><td><code id="krigepred_+3A_delta">delta</code></td>
<td>
<p>numeric; to avoid log(0) in the log transformation.</p>
</td></tr>
<tr><td><code id="krigepred_+3A_formula">formula</code></td>
<td>
<p>formula defining the response vector and (possible) regressor.
an object (i.e., 'variogram.formula') for 'variogram' or a formula for
'krige'. see 'variogram' and 'krige' in gstat for details.</p>
</td></tr>
<tr><td><code id="krigepred_+3A_vgm.args">vgm.args</code></td>
<td>
<p>arguments for vgm, e.g. variogram model of response
variable and anisotropy parameters. see notes vgm in gstat for details.
By default, &quot;Sph&quot; is used.</p>
</td></tr>
<tr><td><code id="krigepred_+3A_anis">anis</code></td>
<td>
<p>anisotropy parameters: see notes vgm in gstat for details.</p>
</td></tr>
<tr><td><code id="krigepred_+3A_alpha">alpha</code></td>
<td>
<p>direction in plane (x,y). see variogram in gstat for details.</p>
</td></tr>
<tr><td><code id="krigepred_+3A_block">block</code></td>
<td>
<p>block size. see krige in gstat for details.</p>
</td></tr>
<tr><td><code id="krigepred_+3A_beta">beta</code></td>
<td>
<p>for simple kriging. see krige in gstat for details.</p>
</td></tr>
<tr><td><code id="krigepred_+3A_...">...</code></td>
<td>
<p>other arguments passed on to gstat.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe of longitude, latitude, predictions and variances.
</p>


<h3>Note</h3>

<p>The variances in the output are not transformed back when a transformation
is used. This is because kriging variances are not measuring the uncertainty of
predictions but they are indicator of the spatial distribution of sample density.
The variances are exported only for interested users; and if needed,
they can be transformed back from the output.
</p>


<h3>Author(s)</h3>

<p>Jin Li
</p>


<h3>References</h3>

<p>Pebesma, E.J., 2004. Multivariable geostatistics in S: the gstat
package. Computers &amp; Geosciences, 30: 683-691.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(sp)
library(spm)
data(swmud)
data(sw)
okpred1 &lt;- krigepred(swmud[, c(1,2)], swmud[, 3], sw, nmax = 7, transformation =
"arcsine", vgm.args = ("Sph"))
names(okpred1)


</code></pre>

<hr>
<h2 id='rfkrigeidwcv'>Cross validation, n-fold and leave-one-out for the hybrid methods of
'random forest' ('RF'), 'kriging' and inverse distance weighted ('IDW')</h2><span id='topic+rfkrigeidwcv'></span>

<h3>Description</h3>

<p>This function is a cross validation function for 38 hybrid
methods of 'RF', 'kriging' and 'IDW', including the average of 'rfkrige'
and 'rfidw' ('rfkrigerfidw') and  the average of 'rf', 'rfkrige' and 'rfidw'
('rfrfkrigerfidw'), where 'kriging' methods include ordinary kriging ('OK'),
simple kriging ('SK'), block 'OK' ('BOK') and block 'SK'('BSK') and 'IDW'
also covers 'NN' and 'KNN'.. The data splitting is based on a stratified
random sampling method (see the 'datasplit' function for details).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rfkrigeidwcv(
  longlat,
  trainx,
  trainy,
  mtry = function(p) max(1, floor(sqrt(p))),
  ntree = 500,
  transformation = "none",
  delta = 1,
  formula = res1 ~ 1,
  vgm.args = c("Sph"),
  anis = c(0, 1),
  alpha = 0,
  block = 0,
  beta,
  nmaxkrige = 12,
  idp = 2,
  nmaxidw = 12,
  hybrid.parameter = 2,
  lambda = 1,
  validation = "CV",
  cv.fold = 10,
  predacc = "VEcv",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rfkrigeidwcv_+3A_longlat">longlat</code></td>
<td>
<p>a dataframe contains longitude and latitude of point samples.</p>
</td></tr>
<tr><td><code id="rfkrigeidwcv_+3A_trainx">trainx</code></td>
<td>
<p>a dataframe or matrix contains columns of predictive variables.</p>
</td></tr>
<tr><td><code id="rfkrigeidwcv_+3A_trainy">trainy</code></td>
<td>
<p>a vector of the response variable.</p>
</td></tr>
<tr><td><code id="rfkrigeidwcv_+3A_mtry">mtry</code></td>
<td>
<p>a function of number of remaining predictor variables to use as
the 'mtry' parameter in the 'randomForest' call.</p>
</td></tr>
<tr><td><code id="rfkrigeidwcv_+3A_ntree">ntree</code></td>
<td>
<p>number of trees to grow. This should not be set to too small a
number, to ensure that every input row gets predicted at least a few times.
By default, 500 is used.</p>
</td></tr>
<tr><td><code id="rfkrigeidwcv_+3A_transformation">transformation</code></td>
<td>
<p>transform the residuals of 'rf' to normalize the data for 'krige';
can be &quot;sqrt&quot; for square root, &quot;arcsine&quot; for arcsine, &quot;log&quot; or &quot;none&quot;
for non transformation. By default, &quot;none&quot; is used.</p>
</td></tr>
<tr><td><code id="rfkrigeidwcv_+3A_delta">delta</code></td>
<td>
<p>numeric; to avoid log(0) in the log transformation. The default is 1.</p>
</td></tr>
<tr><td><code id="rfkrigeidwcv_+3A_formula">formula</code></td>
<td>
<p>formula defining the response vector and (possible) regressor.
an object (i.e., 'variogram.formula') for 'variogram' or a formula for
'krige'. see 'variogram' and 'krige' in 'gstat' for details.</p>
</td></tr>
<tr><td><code id="rfkrigeidwcv_+3A_vgm.args">vgm.args</code></td>
<td>
<p>arguments for 'vgm', e.g. variogram model of response
variable and anisotropy parameters. see 'vgm' in 'gstat' for details.
By default, &quot;Sph&quot; is used.</p>
</td></tr>
<tr><td><code id="rfkrigeidwcv_+3A_anis">anis</code></td>
<td>
<p>anisotropy parameters: see notes 'vgm' in 'gstat' for details.</p>
</td></tr>
<tr><td><code id="rfkrigeidwcv_+3A_alpha">alpha</code></td>
<td>
<p>direction in plane (x,y). see variogram in 'gstat' for details.</p>
</td></tr>
<tr><td><code id="rfkrigeidwcv_+3A_block">block</code></td>
<td>
<p>block size. see 'krige' in 'gstat' for details.</p>
</td></tr>
<tr><td><code id="rfkrigeidwcv_+3A_beta">beta</code></td>
<td>
<p>for simple kriging. see 'krige' in 'gstat' for details.</p>
</td></tr>
<tr><td><code id="rfkrigeidwcv_+3A_nmaxkrige">nmaxkrige</code></td>
<td>
<p>for a local predicting: the number of nearest observations that
should be used for a prediction or simulation, where nearest is defined in
terms of the space of the spatial locations. By default, 12 observations
are used.</p>
</td></tr>
<tr><td><code id="rfkrigeidwcv_+3A_idp">idp</code></td>
<td>
<p>a numeric number specifying the inverse distance weighting power.</p>
</td></tr>
<tr><td><code id="rfkrigeidwcv_+3A_nmaxidw">nmaxidw</code></td>
<td>
<p>for a local predicting: the number of nearest observations that
should be used for a prediction or simulation, where nearest is defined in
terms of the space of the spatial locations. By default, 12 observations
are used.</p>
</td></tr>
<tr><td><code id="rfkrigeidwcv_+3A_hybrid.parameter">hybrid.parameter</code></td>
<td>
<p>the default is 2 that is for 'rfkrigerfidw';
for 'rfrfkrigerfidw', it needs to be 3.</p>
</td></tr>
<tr><td><code id="rfkrigeidwcv_+3A_lambda">lambda</code></td>
<td>
<p>ranging from 0 to 2; the default is 1 for 'rfkrigerfidw'
and 'rfrfkrigerfidw'; and if it is &lt; 1, more weight is placed on 'krige',
otherwise more weight is placed on 'idw'; and if it is 0, 'idw' is not
considered and the resultant methods is 'rfkrige' when the default
'hybrid.parameter' is used; and if it is 2, then the resultant method is
'rfidw' when the default 'hybrid.parameter' is used.</p>
</td></tr>
<tr><td><code id="rfkrigeidwcv_+3A_validation">validation</code></td>
<td>
<p>validation methods, include 'LOO': leave-one-out, and 'CV':
cross-validation.</p>
</td></tr>
<tr><td><code id="rfkrigeidwcv_+3A_cv.fold">cv.fold</code></td>
<td>
<p>integer; number of folds in the cross-validation. if &gt; 1,
then apply n-fold cross validation; the default is 10, i.e., 10-fold cross
validation that is recommended.</p>
</td></tr>
<tr><td><code id="rfkrigeidwcv_+3A_predacc">predacc</code></td>
<td>
<p>can be either &quot;VEcv&quot; for vecv or &quot;ALL&quot; for all measures
in function pred.acc.</p>
</td></tr>
<tr><td><code id="rfkrigeidwcv_+3A_...">...</code></td>
<td>
<p>other arguments passed on to 'randomForest', 'krige' and 'gstat'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following components:
me, rme, mae, rmae, mse, rmse, rrmse, vecv and e1; or vecv only
</p>


<h3>Note</h3>

<p>This function is largely based on 'rfcv' in 'randomForest', and 'krigecv'
in 'spm2'.
</p>


<h3>Author(s)</h3>

<p>Jin Li
</p>


<h3>References</h3>

<p>Li, J. (2022). Spatial Predictive Modeling with R. Boca Raton,
Chapman and Hall/CRC.
</p>
<p>Li, J., Potter, A., Huang, Z., and Heap, A. (2012). Predicting Seabed
Sand Content across the Australian Margin Using Machine Learning and Geostatistical
Methods, Geoscience Australia, Record 2012/48, 115pp.
</p>
<p>Li, J., Heap, A., Potter, A., and Danilel, J.J. (2011). Predicting Seabed Mud Content
across the Australian Margin II: Performance of Machine Learning Methods and Their
Combination with Ordinary Kriging and Inverse Distance Squared, Geoscience Australia,
Record 2011/07, 69pp.
</p>
<p>Liaw, A. and M. Wiener (2002). Classification and Regression by
randomForest. R News 2(3), 18-22.
</p>
<p>Pebesma, E.J., 2004. Multivariable geostatistics in S: the gstat package.
Computers &amp; Geosciences, 30: 683-691.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(spm)
# rfrfokrfidw
data(sponge)
longlat &lt;- sponge[, 1:2]
set.seed(1234)
rfrfkrigerfidwcv1 &lt;- rfkrigeidwcv(longlat = longlat,
trainx = sponge[, -3], trainy = sponge[, 3], formula = res1 ~ 1, vgm.args = ("Sph"),
nmaxkrige = 12, idp = 2, nmaxidw = 12, hybrid.parameter = 3, validation = "CV",
predacc = "ALL")
rfrfkrigerfidwcv1

# rfokrfidw for count data
data(sponge)
longlat &lt;- sponge2[, 1:2]
y = sponge[, 3]
trainx = sponge[, -3]
set.seed(1234)
n &lt;- 20 # number of iterations,60 to 100 is recommended.
VEcv &lt;- NULL
for (i in 1:n) {
 rfkrigerfidwcv1 &lt;- rfkrigeidwcv(longlat = longlat,
 trainx = trainx, trainy = y, formula = res1 ~ 1, vgm.args = ("Sph"),
 nmaxkrige = 12, idp = 2, nmaxidw = 12, validation = "CV",  predacc = "VEcv")
 VEcv [i] &lt;- rfkrigerfidwcv1
 }
 plot(VEcv ~ c(1:n), xlab = "Iteration for rfokrfidw", ylab = "VEcv (%)")
 points(cumsum(VEcv) / c(1:n) ~ c(1:n), col = 2)
 abline(h = mean(VEcv), col = 'blue', lwd = 2)


</code></pre>

<hr>
<h2 id='rfkrigeidwpred'>Generate spatial predictions using the hybrid methods of 'random forest' ('RF'),
'kriging' and inverse distance weighted ('IDW').</h2><span id='topic+rfkrigeidwpred'></span>

<h3>Description</h3>

<p>This function is for generating spatial predictions using the
hybrid methods of 'RF', 'kriging' and 'IDW', including all methods implemented
in 'rfkrigeidwcv'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rfkrigeidwpred(
  longlat,
  trainx,
  predx,
  trainy,
  longlatpredx,
  mtry = function(p) max(1, floor(sqrt(p))),
  ntree = 500,
  transformation = "none",
  delta = 1,
  formula.krige = res1 ~ 1,
  vgm.args = c("Sph"),
  anis = c(0, 1),
  alpha = 0,
  block = 0,
  beta,
  nmaxkrige = 12,
  idp = 2,
  nmaxidw = 12,
  hybrid.parameter = 2,
  lambda = 1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rfkrigeidwpred_+3A_longlat">longlat</code></td>
<td>
<p>a dataframe contains longitude and latitude of point samples.</p>
</td></tr>
<tr><td><code id="rfkrigeidwpred_+3A_trainx">trainx</code></td>
<td>
<p>a dataframe contains longitude (long), latitude (lat),
predictive variables and the response variable of point samples. That is,
the location information must be named as 'long' and 'lat'.</p>
</td></tr>
<tr><td><code id="rfkrigeidwpred_+3A_predx">predx</code></td>
<td>
<p>a dataframe or matrix contains columns of predictive variables
for the grids to be predicted.</p>
</td></tr>
<tr><td><code id="rfkrigeidwpred_+3A_trainy">trainy</code></td>
<td>
<p>a vector of the response variable in the formula, that is, the left
part of the formula.</p>
</td></tr>
<tr><td><code id="rfkrigeidwpred_+3A_longlatpredx">longlatpredx</code></td>
<td>
<p>a dataframe contains longitude and latitude of point locations
(i.e., the centers of grids) to be predicted.</p>
</td></tr>
<tr><td><code id="rfkrigeidwpred_+3A_mtry">mtry</code></td>
<td>
<p>a function of number of remaining predictor variables to use as
the 'mtry' parameter in the 'randomForest' call.</p>
</td></tr>
<tr><td><code id="rfkrigeidwpred_+3A_ntree">ntree</code></td>
<td>
<p>number of trees to grow. This should not be set to too small a
number, to ensure that every input row gets predicted at least a few times.
By default, 500 is used.
#' @param longlatpredx    a dataframe contains longitude and latitude of point locations
(i.e., the centers of grids) to be predicted. The location information must be
named as 'long' and 'lat'.</p>
</td></tr>
<tr><td><code id="rfkrigeidwpred_+3A_transformation">transformation</code></td>
<td>
<p>transform the residuals of 'rf' to normalise the data;
can be &quot;sqrt&quot; for square root, &quot;arcsine&quot; for arcsine, &quot;log&quot; or &quot;none&quot;
for non transformation. By default, &quot;none&quot; is used.</p>
</td></tr>
<tr><td><code id="rfkrigeidwpred_+3A_delta">delta</code></td>
<td>
<p>numeric; to avoid log(0) in the log transformation. The default is 1.</p>
</td></tr>
<tr><td><code id="rfkrigeidwpred_+3A_formula.krige">formula.krige</code></td>
<td>
<p>formula defining the response vector and (possible) regressor.
an object (i.e., 'variogram.formula') for 'variogram' or a formula for
'krige'. see 'variogram' and 'krige' in 'gstat' for details.</p>
</td></tr>
<tr><td><code id="rfkrigeidwpred_+3A_vgm.args">vgm.args</code></td>
<td>
<p>arguments for 'vgm', e.g. variogram model of response
variable and anisotropy parameters. see 'vgm' in 'gstat' for details.
By default, &quot;Sph&quot; is used.</p>
</td></tr>
<tr><td><code id="rfkrigeidwpred_+3A_anis">anis</code></td>
<td>
<p>anisotropy parameters: see notes 'vgm' in 'gstat' for details.</p>
</td></tr>
<tr><td><code id="rfkrigeidwpred_+3A_alpha">alpha</code></td>
<td>
<p>direction in plane (x,y). see variogram in 'gstat' for details.</p>
</td></tr>
<tr><td><code id="rfkrigeidwpred_+3A_block">block</code></td>
<td>
<p>block size. see 'krige' in 'gstat' for details.</p>
</td></tr>
<tr><td><code id="rfkrigeidwpred_+3A_beta">beta</code></td>
<td>
<p>for simple kriging. see 'krige' in 'gstat' for details.</p>
</td></tr>
<tr><td><code id="rfkrigeidwpred_+3A_nmaxkrige">nmaxkrige</code></td>
<td>
<p>for a local predicting: the number of nearest observations that
should be used for a prediction or simulation, where nearest is defined in
terms of the space of the spatial locations. By default, 12 observations
are used.</p>
</td></tr>
<tr><td><code id="rfkrigeidwpred_+3A_idp">idp</code></td>
<td>
<p>a numeric number specifying the inverse distance weighting power.</p>
</td></tr>
<tr><td><code id="rfkrigeidwpred_+3A_nmaxidw">nmaxidw</code></td>
<td>
<p>for a local predicting: the number of nearest observations that
should be used for a prediction or simulation, where nearest is defined in
terms of the space of the spatial locations. By default, 12 observations
are used.</p>
</td></tr>
<tr><td><code id="rfkrigeidwpred_+3A_hybrid.parameter">hybrid.parameter</code></td>
<td>
<p>the default is 2 that is for 'rfkrigerfidw';
for 'rfrfkrigerfidw', it needs to be 3.</p>
</td></tr>
<tr><td><code id="rfkrigeidwpred_+3A_lambda">lambda</code></td>
<td>
<p>ranging from 0 to 2; the default is 1 for 'rfkrigerfidw'
and 'rfrfkrigerfidw'; and if it is &lt; 1, more weight is placed on 'krige',
otherwise more weight is placed on 'idw'; and if it is 0, 'idw' is not
considered and the resultant methods is 'rfkrige' when the default
'hybrid.parameter' is used; and if it is 2, then the resultant method is
'rfidw' when the default 'hybrid.parameter' is used.</p>
</td></tr>
<tr><td><code id="rfkrigeidwpred_+3A_...">...</code></td>
<td>
<p>other arguments passed on to 'rf', 'krige' and 'gstat'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe of longitude, latitude, and predictions.
</p>


<h3>Author(s)</h3>

<p>Jin Li
</p>


<h3>References</h3>

<p>Li, J., Potter, A., Huang, Z., and Heap, A. (2012). Predicting Seabed
Sand Content across the Australian Margin Using Machine Learning and Geostatistical
Methods, Geoscience Australia, Record 2012/48, 115pp.
</p>
<p>Li, J., Heap, A., Potter, A., and Danilel, J.J. (2011). Predicting Seabed Mud Content
across the Australian Margin II: Performance of Machine Learning Methods and Their
Combination with Ordinary Kriging and Inverse Distance Squared, Geoscience Australia,
Record 2011/07, 69pp.
</p>
<p>Liaw, A. and M. Wiener (2002). Classification and Regression by
randomForest. R News 2(3), 18-22.
</p>
<p>Pebesma, E.J., 2004. Multivariable geostatistics in S: the gstat package.
Computers &amp; Geosciences, 30: 683-691.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(spm)

data(sponge)
data(sponge.grid)
longlat &lt;- sponge[, 1:2]
y = sponge[, 3]
trainx = sponge[, -3]

set.seed(1234)

rfkrigeidwpred1 &lt;- rfkrigeidwpred(longlat = longlat, trainx =  trainx,
predx = sponge.grid, trainy = y, longlatpredx = sponge.grid[, c(1:2)],
formula.krige = res1 ~ 1, vgm.args = "Sph", nmaxkrige = 12, idp = 2, nmaxidw = 12)

names(rfkrigeidwpred1)

range(rfkrigeidwpred1$predictions)


</code></pre>

<hr>
<h2 id='sponge2'>A dataset of sponge species richness in the Timor Sea region, northern Australia marine margin</h2><span id='topic+sponge2'></span>

<h3>Description</h3>

<p>This dataset contains 77 samples of 81 variables including easting (longitude), northing (latitude), bathy, backscatter and their derived variables.</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("sponge2")</code></pre>


<h3>Format</h3>

<p>A data frame with 77 observations on the following 89 variables.
</p>

<dl>
<dt><code>easting</code></dt><dd><p>a numeric vector, m</p>
</dd>
<dt><code>northing</code></dt><dd><p>a numeric vector, m</p>
</dd>
<dt><code>species.richness</code></dt><dd><p>a numeric vector, no unit</p>
</dd>
<dt><code>mud</code></dt><dd><p>a numeric vector, percentage</p>
</dd>
<dt><code>sand</code></dt><dd><p>a numeric vector, percentage</p>
</dd>
<dt><code>gravel</code></dt><dd><p>a numeric vector, percentage</p>
</dd>
<dt><code>bathy</code></dt><dd><p>a numeric vector, m</p>
</dd>
<dt><code>bs25</code></dt><dd><p>a numeric vector, dB</p>
</dd>
<dt><code>bs10</code></dt><dd><p>a numeric vector, dB</p>
</dd>
<dt><code>bs11</code></dt><dd><p>a numeric vector, dB</p>
</dd>
<dt><code>bs12</code></dt><dd><p>a numeric vector, dB</p>
</dd>
<dt><code>bs13</code></dt><dd><p>a numeric vector, dB</p>
</dd>
<dt><code>bs14</code></dt><dd><p>a numeric vector, dB</p>
</dd>
<dt><code>bs15</code></dt><dd><p>a numeric vector, dB</p>
</dd>
<dt><code>bs16</code></dt><dd><p>a numeric vector, dB</p>
</dd>
<dt><code>bs17</code></dt><dd><p>a numeric vector, dB</p>
</dd>
<dt><code>bs18</code></dt><dd><p>a numeric vector, dB</p>
</dd>
<dt><code>bs19</code></dt><dd><p>a numeric vector, dB</p>
</dd>
<dt><code>bs20</code></dt><dd><p>a numeric vector, dB</p>
</dd>
<dt><code>bs21</code></dt><dd><p>a numeric vector, dB</p>
</dd>
<dt><code>bs22</code></dt><dd><p>a numeric vector, dB</p>
</dd>
<dt><code>bs23</code></dt><dd><p>a numeric vector, dB</p>
</dd>
<dt><code>bs24</code></dt><dd><p>a numeric vector, dB</p>
</dd>
<dt><code>bs26</code></dt><dd><p>a numeric vector, dB</p>
</dd>
<dt><code>bs27</code></dt><dd><p>a numeric vector, dB</p>
</dd>
<dt><code>bs28</code></dt><dd><p>a numeric vector, dB</p>
</dd>
<dt><code>bs29</code></dt><dd><p>a numeric vector, dB</p>
</dd>
<dt><code>bs30</code></dt><dd><p>a numeric vector, dB</p>
</dd>
<dt><code>bs31</code></dt><dd><p>a numeric vector, dB</p>
</dd>
<dt><code>bs32</code></dt><dd><p>a numeric vector, dB</p>
</dd>
<dt><code>bs33</code></dt><dd><p>a numeric vector, dB</p>
</dd>
<dt><code>bs34</code></dt><dd><p>a numeric vector, dB</p>
</dd>
<dt><code>bs35</code></dt><dd><p>a numeric vector, dB</p>
</dd>
<dt><code>bs36</code></dt><dd><p>a numeric vector, dB</p>
</dd>
<dt><code>bs_o</code></dt><dd><p>a numeric vector, dB</p>
</dd>
<dt><code>bs_homo_o</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>bs_entro_o</code></dt><dd><p>a numeric vector, no unit</p>
</dd>
<dt><code>bs_var_o</code></dt><dd><p>a numeric vector, dB^2</p>
</dd>
<dt><code>bs_lmi_o</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>bathy_o</code></dt><dd><p>a numeric vector, m</p>
</dd>
<dt><code>bathy_lmi_o</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>tpi_o</code></dt><dd><p>a numeric vector, no unit</p>
</dd>
<dt><code>slope_o</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>plan_cur_o</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>prof_cur_o</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>relief_o</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>rugosity_o</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>dist.coast</code></dt><dd><p>a numeric vector, m</p>
</dd>
<dt><code>rugosity3</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>rugosity5</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>rugosity7</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>tpi3</code></dt><dd><p>a numeric vector, no unit</p>
</dd>
<dt><code>tpi5</code></dt><dd><p>a numeric vector, no unit</p>
</dd>
<dt><code>tpi7</code></dt><dd><p>a numeric vector, no unit</p>
</dd>
<dt><code>bathy_lmi3</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>bathy_lmi5</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>bathy_lmi7</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>plan_curv3</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>plan_curv5</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>plan_curv7</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>relief_3</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>relief_5</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>relief_7</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>slope3</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>slope5</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>slope7</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>prof_cur3</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>prof_cur5</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>prof_cur7</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>entro3</code></dt><dd><p>a numeric vector, no unit</p>
</dd>
<dt><code>entro5</code></dt><dd><p>a numeric vector, no unit</p>
</dd>
<dt><code>entro7</code></dt><dd><p>a numeric vector, no unit</p>
</dd>
<dt><code>homo3</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>homo5</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>homo7</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>var3</code></dt><dd><p>a numeric vector, dB^2</p>
</dd>
<dt><code>var5</code></dt><dd><p>a numeric vector, dB^2</p>
</dd>
<dt><code>var7</code></dt><dd><p>a numeric vector, dB^2</p>
</dd>
<dt><code>bs_lmi3</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>bs_lmi5</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>bs_lmi7</code></dt><dd><p>a numeric vector</p>
</dd>
</dl>



<h3>Details</h3>

<p>For details, please see the source. This dataset was published as an appendix of the paper listed in the source. Where the long and lat were reprojected to easting and northing.</p>


<h3>Source</h3>

<p>see Appendix A-D. Supplementary data at: &quot;http://dx.doi.org/10.1016/j.envsoft.2017.07.016.&quot;</p>


<h3>References</h3>

<p>Li, J., B. Alvarez, J. Siwabessy, M. Tran, Z. Huang, R. Przeslawski, L. Radke, F. Howard, and S. Nichol. 2017. Application of random forest, generalised linear model and their hybrid methods with geostatistical techniques to count data: Predicting sponge species richness. Environmental Modelling &amp; Software, 97: 112-129.
</p>

<hr>
<h2 id='spongelonglat'>A dataset of sponge species richness in the Timor Sea region, northern Australia marine margin</h2><span id='topic+spongelonglat'></span>

<h3>Description</h3>

<p>This dataset contains 77 samples of 7 predictive variables including longitude, latitude, bathy, backscatter and their derived variables. It is the sponge dataset in 'spm' package, but with long and lat instead of easting and northing.</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("spongelonglat")</code></pre>


<h3>Format</h3>

<p>A data frame with 77 observations on the following 8 variables.
</p>

<dl>
<dt><code>sponge</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>tpi3</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>var7</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>entro7</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>bs34</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>bs11</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>long</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>lat</code></dt><dd><p>a numeric vector</p>
</dd>
</dl>



<h3>Details</h3>

<p>For details, please see sponge dataset in library(spm). Where the long and lat were projected to easting and northing.</p>


<h3>Source</h3>

<p>sponge dataset in library(spm)</p>


<h3>References</h3>

<p>Li, J., B. Alvarez, J. Siwabessy, M. Tran, Z. Huang, R. Przeslawski, L. Radke, F. Howard, and S. Nichol. 2017. Application of random forest, generalised linear model and their hybrid methods with geostatistical techniques to count data: Predicting sponge species richness. Environmental Modelling &amp; Software, 97: 112-129.</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(spongelonglat)
## maybe str(spongelonglat) ; plot(spongelonglat) ...
</code></pre>

<hr>
<h2 id='svmcv'>Cross validation, n-fold and leave-one-out for support vector machine ('svm')</h2><span id='topic+svmcv'></span>

<h3>Description</h3>

<p>This function is a cross validation function
for 'svm' regression in 'e1071' package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>svmcv(
  formula = NULL,
  trainxy,
  y,
  scale = TRUE,
  type = NULL,
  kernel = "radial",
  degree = 3,
  gamma = if (is.vector(trainxy)) 1 else 1/ncol(trainxy),
  coef0 = 0,
  cost = 1,
  nu = 0.5,
  tolerance = 0.001,
  epsilon = 0.1,
  validation = "CV",
  cv.fold = 10,
  predacc = "VEcv",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="svmcv_+3A_formula">formula</code></td>
<td>
<p>a formula defining the response variable and predictive variables.</p>
</td></tr>
<tr><td><code id="svmcv_+3A_trainxy">trainxy</code></td>
<td>
<p>a dataframe contains predictive variables and the response
variable of point samples. The location information, longitude (long),
latitude (lat), need to be included in the 'trainx' for spatial predictive
modelling, need to be named as 'long' and 'lat'.</p>
</td></tr>
<tr><td><code id="svmcv_+3A_y">y</code></td>
<td>
<p>a vector of the response variable in the formula, that is, the left
part of the formula.</p>
</td></tr>
<tr><td><code id="svmcv_+3A_scale">scale</code></td>
<td>
<p>A logical vector indicating the variables to be scaled (default: TRUE).</p>
</td></tr>
<tr><td><code id="svmcv_+3A_type">type</code></td>
<td>
<p>the default setting is 'NULL'. See '?svm' for various options.</p>
</td></tr>
<tr><td><code id="svmcv_+3A_kernel">kernel</code></td>
<td>
<p>the default setting is 'radial'. See '?svm' for other options.</p>
</td></tr>
<tr><td><code id="svmcv_+3A_degree">degree</code></td>
<td>
<p>a parameter needed for kernel of type polynomial (default: 3).</p>
</td></tr>
<tr><td><code id="svmcv_+3A_gamma">gamma</code></td>
<td>
<p>a parameter needed for all 'kernels' except 'linear'
(default: 1/(data dimension)).</p>
</td></tr>
<tr><td><code id="svmcv_+3A_coef0">coef0</code></td>
<td>
<p>a parameter needed for kernels of type 'polynomial' and 'sigmoid'(default: 0).</p>
</td></tr>
<tr><td><code id="svmcv_+3A_cost">cost</code></td>
<td>
<p>cost of constraints violation (default: 1).</p>
</td></tr>
<tr><td><code id="svmcv_+3A_nu">nu</code></td>
<td>
<p>a parameter needed for 'nu-classification', 'nu-regression', and 'one-classification' (default: 0.5).</p>
</td></tr>
<tr><td><code id="svmcv_+3A_tolerance">tolerance</code></td>
<td>
<p>tolerance of termination criterion (default: 0.001).</p>
</td></tr>
<tr><td><code id="svmcv_+3A_epsilon">epsilon</code></td>
<td>
<p>'epsilon' in the insensitive-loss function (default: 0.1).</p>
</td></tr>
<tr><td><code id="svmcv_+3A_validation">validation</code></td>
<td>
<p>validation methods, include 'LOO': leave-one-out, and 'CV':
cross-validation.</p>
</td></tr>
<tr><td><code id="svmcv_+3A_cv.fold">cv.fold</code></td>
<td>
<p>integer; number of folds in the cross-validation. if &gt; 1,
then apply n-fold cross validation; the default is 10, i.e., 10-fold cross
validation that is recommended.</p>
</td></tr>
<tr><td><code id="svmcv_+3A_predacc">predacc</code></td>
<td>
<p>can be either &quot;VEcv&quot; for 'vecv' or &quot;ALL&quot; for all measures
in function pred.acc.</p>
</td></tr>
<tr><td><code id="svmcv_+3A_...">...</code></td>
<td>
<p>other arguments passed on to 'svm'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following components:
me, rme, mae, rmae, mse, rmse, rrmse, vecv and e1; or vecv only
</p>


<h3>Note</h3>

<p>This function is largely based on 'rfcv' in 'randomForest' and
'svm' in 'e1071'.
</p>


<h3>Author(s)</h3>

<p>Jin Li
</p>


<h3>References</h3>

<p>David Meyer, Evgenia Dimitriadou, Kurt Hornik, Andreas Weingessel and Friedrich
Leisch (2020). e1071: Misc Functions of the Department of Statistics, Probability
Theory Group (Formerly: E1071), TU Wien. R package version 1.7-4.
https://CRAN.R-project.org/package=e1071.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(spm)

data(petrel)
gravel &lt;- petrel[, c(1, 2, 6:9, 5)]
model &lt;- log(gravel + 1) ~ lat +  bathy + I(long^3) + I(lat^2) + I(lat^3)
set.seed(1234)
svmcv1 &lt;- svmcv(formula = model, gravel, log(gravel[, 7] +1), validation = "CV",
 predacc = "ALL")
svmcv1

data(sponge2)
model &lt;- species.richness ~ .
set.seed(1234)
svmcv1 &lt;- svmcv(formula = model, sponge2[, -4], sponge[, 3], gamma = 0.01, cost = 3.5,
scale = TRUE, validation = "CV",  predacc = "VEcv")
svmcv1

# For svm
model &lt;- species.richness ~ .
set.seed(1234)
n &lt;- 20 # number of iterations,60 to 100 is recommended.
VEcv &lt;- NULL
for (i in 1:n) {
svmcv1 &lt;- svmcv(formula = model, sponge2[, -4], sponge[, 3], gamma = 0.01, cost = 3.5,
scale = TRUE, validation = "CV",  predacc = "VEcv")
VEcv [i] &lt;- svmcv1
}
plot(VEcv ~ c(1:n), xlab = "Iteration for svm", ylab = "VEcv (%)")
points(cumsum(VEcv) / c(1:n) ~ c(1:n), col = 2)
abline(h = mean(VEcv), col = 'blue', lwd = 2)


</code></pre>

<hr>
<h2 id='svmidwcv'>Cross validation, n-fold and leave-one-out for the hybrid method of support vector machine ('svm')
regression and inverse distance weighted ('IDW') (svmidw)</h2><span id='topic+svmidwcv'></span>

<h3>Description</h3>

<p>This function is a cross validation function for the hybrid
method of 'svm' regression and 'idw' using 'gstat' (svmidw), where the
data splitting is based on a stratified random sampling method (see the
'datasplit' function for details).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>svmidwcv(
  formula = NULL,
  longlat,
  trainxy,
  y,
  scale = TRUE,
  type = NULL,
  kernel = "radial",
  degree = 3,
  gamma = if (is.vector(trainxy)) 1 else 1/ncol(trainxy),
  coef0 = 0,
  cost = 1,
  nu = 0.5,
  tolerance = 0.001,
  epsilon = 0.1,
  idp = 2,
  nmaxidw = 12,
  validation = "CV",
  cv.fold = 10,
  predacc = "VEcv",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="svmidwcv_+3A_formula">formula</code></td>
<td>
<p>a formula defining the response variable and predictive variables
for 'svm'.</p>
</td></tr>
<tr><td><code id="svmidwcv_+3A_longlat">longlat</code></td>
<td>
<p>a dataframe contains longitude and latitude of point samples.</p>
</td></tr>
<tr><td><code id="svmidwcv_+3A_trainxy">trainxy</code></td>
<td>
<p>a dataframe contains longitude (long), latitude (lat),
predictive variables and the response variable of point samples. That is,
the location information must be named as 'long' and 'lat'.</p>
</td></tr>
<tr><td><code id="svmidwcv_+3A_y">y</code></td>
<td>
<p>a vector of the response variable in the formula, that is, the left
part of the formula.</p>
</td></tr>
<tr><td><code id="svmidwcv_+3A_scale">scale</code></td>
<td>
<p>A logical vector indicating the variables to be scaled (default: TRUE).</p>
</td></tr>
<tr><td><code id="svmidwcv_+3A_type">type</code></td>
<td>
<p>the default setting is 'NULL'. See '?svm' for various options.</p>
</td></tr>
<tr><td><code id="svmidwcv_+3A_kernel">kernel</code></td>
<td>
<p>the default setting is 'radial'. See '?svm' for other options.</p>
</td></tr>
<tr><td><code id="svmidwcv_+3A_degree">degree</code></td>
<td>
<p>a parameter needed for kernel of type polynomial (default: 3).</p>
</td></tr>
<tr><td><code id="svmidwcv_+3A_gamma">gamma</code></td>
<td>
<p>a parameter needed for all 'kernels' except 'linear'
(default: 1/(data dimension)).</p>
</td></tr>
<tr><td><code id="svmidwcv_+3A_coef0">coef0</code></td>
<td>
<p>a parameter needed for kernels of type 'polynomial' and 'sigmoid'(default: 0).</p>
</td></tr>
<tr><td><code id="svmidwcv_+3A_cost">cost</code></td>
<td>
<p>cost of constraints violation (default: 1).</p>
</td></tr>
<tr><td><code id="svmidwcv_+3A_nu">nu</code></td>
<td>
<p>a parameter needed for 'nu-classification', 'nu-regression', and 'one-classification' (default: 0.5).</p>
</td></tr>
<tr><td><code id="svmidwcv_+3A_tolerance">tolerance</code></td>
<td>
<p>tolerance of termination criterion (default: 0.001).</p>
</td></tr>
<tr><td><code id="svmidwcv_+3A_epsilon">epsilon</code></td>
<td>
<p>'epsilon' in the insensitive-loss function (default: 0.1).</p>
</td></tr>
<tr><td><code id="svmidwcv_+3A_idp">idp</code></td>
<td>
<p>a numeric number specifying the inverse distance weighting power.</p>
</td></tr>
<tr><td><code id="svmidwcv_+3A_nmaxidw">nmaxidw</code></td>
<td>
<p>for a local predicting: the number of nearest observations that
should be used for a prediction or simulation, where nearest is defined in
terms of the space of the spatial locations. By default, 12 observations
are used.</p>
</td></tr>
<tr><td><code id="svmidwcv_+3A_validation">validation</code></td>
<td>
<p>validation methods, include 'LOO': leave-one-out, and 'CV':
cross-validation.</p>
</td></tr>
<tr><td><code id="svmidwcv_+3A_cv.fold">cv.fold</code></td>
<td>
<p>integer; number of folds in the cross-validation. if &gt; 1,
then apply n-fold cross validation; the default is 10, i.e., 10-fold cross
validation that is recommended.</p>
</td></tr>
<tr><td><code id="svmidwcv_+3A_predacc">predacc</code></td>
<td>
<p>can be either &quot;VEcv&quot; for 'vecv' or &quot;ALL&quot; for all measures
in function pred.acc.</p>
</td></tr>
<tr><td><code id="svmidwcv_+3A_...">...</code></td>
<td>
<p>other arguments passed on to 'svm' and 'gstat'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following components:
me, rme, mae, rmae, mse, rmse, rrmse, vecv and e1; or vecv only.
</p>


<h3>Note</h3>

<p>This function is largely based on 'rfcv' in 'randomForest', 'idwcv'
in 'spm'and 'svm' in 'e1071'.
</p>


<h3>Author(s)</h3>

<p>Jin Li
</p>


<h3>References</h3>

<p>Li, J., Potter, A., Huang, Z., and Heap, A. (2012). Predicting Seabed
Sand Content across the Australian Margin Using Machine Learning and Geostatistical
Methods, Geoscience Australia, Record 2012/48, 115pp.
</p>
<p>Li, J., Heap, A., Potter, A., and Danilel, J.J. (2011). Predicting Seabed Mud Content
across the Australian Margin II: Performance of Machine Learning Methods and Their
Combination with Ordinary Kriging and Inverse Distance Squared, Geoscience Australia,
Record 2011/07, 69pp.
</p>
<p>David Meyer, Evgenia Dimitriadou, Kurt Hornik, Andreas Weingessel and Friedrich
Leisch (2020). e1071: Misc Functions of the Department of Statistics, Probability
Theory Group (Formerly: E1071), TU Wien. R package version 1.7-4.
https://CRAN.R-project.org/package=e1071.
</p>
<p>Pebesma, E.J., 2004. Multivariable geostatistics in S: the gstat package.
Computers &amp; Geosciences, 30: 683-691.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(spm)

data(petrel)
gravel &lt;- petrel[, c(1, 2, 6:9, 5)]
longlat &lt;- petrel[, c(1, 2)]
model &lt;- log(gravel + 1) ~  lat +  bathy + I(long^3) + I(lat^2) + I(lat^3)
y &lt;- log(gravel[, 7] +1)

set.seed(1234)
svmidwcv1 &lt;- svmidwcv(formula = model, longlat = longlat, trainxy =  gravel,
y = y, idp = 2, nmaxidw = 12, validation = "CV", predacc = "ALL")
svmidwcv1

# svmidw for count data
data(sponge2)
model &lt;- species.richness ~ . # use all predictive variables in the dataset
longlat &lt;- sponge2[, 1:2]
set.seed(1234)
n &lt;- 20 # number of iterations,60 to 100 is recommended.
VEcv &lt;- NULL
for (i in 1:n) {
 svmidwcv1 &lt;- svmidwcv(formula = model, longlat = longlat, trainxy = sponge2[, -4],
 y = sponge[, 3], gamma = 0.01,  cost = 3.5, scale = TRUE, idp = 2, nmaxidw = 12,
 validation = "CV", predacc = "VEcv")
 VEcv [i] &lt;- svmidwcv1
 }
 plot(VEcv ~ c(1:n), xlab = "Iteration for svmidw", ylab = "VEcv (%)")
 points(cumsum(VEcv) / c(1:n) ~ c(1:n), col = 2)
 abline(h = mean(VEcv), col = 'blue', lwd = 2)


</code></pre>

<hr>
<h2 id='svmidwpred'>Generate spatial predictions using the hybrid method of support vector machine ('svm')
regression and inverse distance weighted ('IDW') ('svmidw')</h2><span id='topic+svmidwpred'></span>

<h3>Description</h3>

<p>This function is for generating spatial predictions using the hybrid
method of 'svm' and 'idw' ('svmidw').
</p>


<h3>Usage</h3>

<pre><code class='language-R'>svmidwpred(
  formula = NULL,
  longlat,
  trainxy,
  y,
  longlatpredx,
  predx,
  scale = TRUE,
  type = NULL,
  kernel = "radial",
  degree = 3,
  gamma = if (is.vector(trainxy)) 1 else 1/ncol(trainxy),
  coef0 = 0,
  cost = 1,
  nu = 0.5,
  tolerance = 0.001,
  epsilon = 0.1,
  idp = 2,
  nmaxidw = 12,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="svmidwpred_+3A_formula">formula</code></td>
<td>
<p>a formula defining the response variable and predictive variables
for 'svm'.</p>
</td></tr>
<tr><td><code id="svmidwpred_+3A_longlat">longlat</code></td>
<td>
<p>a dataframe contains longitude and latitude of point samples. The
location information must be named as 'long' and 'lat'.</p>
</td></tr>
<tr><td><code id="svmidwpred_+3A_trainxy">trainxy</code></td>
<td>
<p>a dataframe contains longitude (long), latitude (lat),
predictive variables and the response variable of point samples.</p>
</td></tr>
<tr><td><code id="svmidwpred_+3A_y">y</code></td>
<td>
<p>a vector of the response variable in the formula, that is, the left
part of the formula.</p>
</td></tr>
<tr><td><code id="svmidwpred_+3A_longlatpredx">longlatpredx</code></td>
<td>
<p>a dataframe contains longitude and latitude of point locations
(i.e., the centers of grids) to be predicted.</p>
</td></tr>
<tr><td><code id="svmidwpred_+3A_predx">predx</code></td>
<td>
<p>a dataframe or matrix contains columns of predictive variables
for the grids to be predicted.</p>
</td></tr>
<tr><td><code id="svmidwpred_+3A_scale">scale</code></td>
<td>
<p>A logical vector indicating the variables to be scaled (default: TRUE).</p>
</td></tr>
<tr><td><code id="svmidwpred_+3A_type">type</code></td>
<td>
<p>the default setting is 'NULL'. See '?svm' for various options.</p>
</td></tr>
<tr><td><code id="svmidwpred_+3A_kernel">kernel</code></td>
<td>
<p>the default setting is 'radial'. See '?svm' for other options.</p>
</td></tr>
<tr><td><code id="svmidwpred_+3A_degree">degree</code></td>
<td>
<p>a parameter needed for kernel of type polynomial (default: 3).</p>
</td></tr>
<tr><td><code id="svmidwpred_+3A_gamma">gamma</code></td>
<td>
<p>a parameter needed for all 'kernels' except 'linear'
(default: 1/(data dimension)).</p>
</td></tr>
<tr><td><code id="svmidwpred_+3A_coef0">coef0</code></td>
<td>
<p>a parameter needed for kernels of type 'polynomial' and 'sigmoid'(default: 0).</p>
</td></tr>
<tr><td><code id="svmidwpred_+3A_cost">cost</code></td>
<td>
<p>cost of constraints violation (default: 1).</p>
</td></tr>
<tr><td><code id="svmidwpred_+3A_nu">nu</code></td>
<td>
<p>a parameter needed for 'nu-classification', 'nu-regression', and 'one-classification' (default: 0.5).</p>
</td></tr>
<tr><td><code id="svmidwpred_+3A_tolerance">tolerance</code></td>
<td>
<p>tolerance of termination criterion (default: 0.001).</p>
</td></tr>
<tr><td><code id="svmidwpred_+3A_epsilon">epsilon</code></td>
<td>
<p>'epsilon' in the insensitive-loss function (default: 0.1).
See '?svm' for details.</p>
</td></tr>
<tr><td><code id="svmidwpred_+3A_idp">idp</code></td>
<td>
<p>a numeric number specifying the inverse distance weighting power.</p>
</td></tr>
<tr><td><code id="svmidwpred_+3A_nmaxidw">nmaxidw</code></td>
<td>
<p>for a local predicting: the number of nearest observations that
should be used for a prediction or simulation, where nearest is defined in
terms of the space of the spatial locations. By default, 12 observations
are used.</p>
</td></tr>
<tr><td><code id="svmidwpred_+3A_...">...</code></td>
<td>
<p>other arguments passed on to 'svm'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe of longitude, latitude, and predictions.
</p>


<h3>Author(s)</h3>

<p>Jin Li
</p>


<h3>References</h3>

<p>Li, J., Potter, A., Huang, Z., and Heap, A. (2012). Predicting Seabed
Sand Content across the Australian Margin Using Machine Learning and Geostatistical
Methods, Geoscience Australia, Record 2012/48, 115pp.
</p>
<p>Li, J., Heap, A., Potter, A., and Danilel, J.J. (2011). Predicting Seabed Mud Content
across the Australian Margin II: Performance of Machine Learning Methods and Their
Combination with Ordinary Kriging and Inverse Distance Squared, Geoscience Australia,
Record 2011/07, 69pp.
</p>
<p>David Meyer, Evgenia Dimitriadou, Kurt Hornik, Andreas Weingessel and Friedrich
Leisch (2020). e1071: Misc Functions of the Department of Statistics, Probability
Theory Group (Formerly: E1071), TU Wien. R package version 1.7-4.
https://CRAN.R-project.org/package=e1071.
</p>
<p>Pebesma, E.J., 2004. Multivariable geostatistics in S: the gstat package.
Computers &amp; Geosciences, 30: 683-691.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(spm)
data(petrel)
data(petrel.grid)

gravel &lt;- petrel[, c(1, 2, 6:9, 5)]
longlat &lt;- petrel[, c(1, 2)]
model &lt;- log(gravel + 1) ~  lat +  bathy + I(long^3) + I(lat^2) + I(lat^3)
y &lt;- log(gravel[, 7] +1)

svmidwpred1 &lt;- svmidwpred(formula = model, longlat = longlat, trainxy =  gravel,
y = y, longlatpredx = petrel.grid[, c(1:2)], predx = petrel.grid, idp = 2,
 nmaxidw = 12)

names(svmidwpred1)

# Back transform 'svmidwpred$predictions' to generate the final predictions
svmidw.predictions &lt;- exp(svmidwpred1$predictions) - 1
range(svmidw.predictions)


</code></pre>

<hr>
<h2 id='svmkrigecv'>Cross validation, n-fold and leave-one-out for the hybrid method of support vector machine ('svm')
regression and 'krige' (svmkrige)</h2><span id='topic+svmkrigecv'></span>

<h3>Description</h3>

<p>This function is a cross validation function for the hybrid method of
'svm' regression and 'krige' (svmkrige), where the data splitting is based on a stratified
random sampling method (see the 'datasplit' function for details).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>svmkrigecv(
  formula.svm = NULL,
  longlat,
  trainxy,
  y,
  scale = TRUE,
  type = NULL,
  kernel = "radial",
  degree = 3,
  gamma = if (is.vector(trainxy)) 1 else 1/ncol(trainxy),
  coef0 = 0,
  cost = 1,
  nu = 0.5,
  tolerance = 0.001,
  epsilon = 0.1,
  transformation = "none",
  delta = 1,
  formula.krige = res1 ~ 1,
  vgm.args = c("Sph"),
  anis = c(0, 1),
  alpha = 0,
  block = 0,
  beta,
  nmaxkrige = 12,
  validation = "CV",
  cv.fold = 10,
  predacc = "VEcv",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="svmkrigecv_+3A_formula.svm">formula.svm</code></td>
<td>
<p>a formula defining the response variable and predictive variables for 'svm'.</p>
</td></tr>
<tr><td><code id="svmkrigecv_+3A_longlat">longlat</code></td>
<td>
<p>a dataframe contains longitude and latitude of point samples.</p>
</td></tr>
<tr><td><code id="svmkrigecv_+3A_trainxy">trainxy</code></td>
<td>
<p>a dataframe contains longitude (long), latitude (lat),
predictive variables and the response variable of point samples. That is,
the location information must be named as 'long' and 'lat'.</p>
</td></tr>
<tr><td><code id="svmkrigecv_+3A_y">y</code></td>
<td>
<p>a vector of the response variable in the formula.svm, that is, the left
part of the formula.svm.</p>
</td></tr>
<tr><td><code id="svmkrigecv_+3A_scale">scale</code></td>
<td>
<p>A logical vector indicating the variables to be scaled (default: TRUE).</p>
</td></tr>
<tr><td><code id="svmkrigecv_+3A_type">type</code></td>
<td>
<p>the default setting is 'NULL'. See '?svm' for various options.</p>
</td></tr>
<tr><td><code id="svmkrigecv_+3A_kernel">kernel</code></td>
<td>
<p>the default setting is 'radial'. See '?svm' for other options.</p>
</td></tr>
<tr><td><code id="svmkrigecv_+3A_degree">degree</code></td>
<td>
<p>a parameter needed for kernel of type polynomial (default: 3).</p>
</td></tr>
<tr><td><code id="svmkrigecv_+3A_gamma">gamma</code></td>
<td>
<p>a parameter needed for all 'kernels' except 'linear'
(default: 1/(data dimension)).</p>
</td></tr>
<tr><td><code id="svmkrigecv_+3A_coef0">coef0</code></td>
<td>
<p>a parameter needed for kernels of type 'polynomial' and 'sigmoid'(default: 0).</p>
</td></tr>
<tr><td><code id="svmkrigecv_+3A_cost">cost</code></td>
<td>
<p>cost of constraints violation (default: 1).</p>
</td></tr>
<tr><td><code id="svmkrigecv_+3A_nu">nu</code></td>
<td>
<p>a parameter needed for 'nu-classification', 'nu-regression', and 'one-classification' (default: 0.5).</p>
</td></tr>
<tr><td><code id="svmkrigecv_+3A_tolerance">tolerance</code></td>
<td>
<p>tolerance of termination criterion (default: 0.001).</p>
</td></tr>
<tr><td><code id="svmkrigecv_+3A_epsilon">epsilon</code></td>
<td>
<p>'epsilon' in the insensitive-loss function (default: 0.1).</p>
</td></tr>
<tr><td><code id="svmkrigecv_+3A_transformation">transformation</code></td>
<td>
<p>transform the residuals of 'svm' to normalise the data;
can be &quot;sqrt&quot; for square root, &quot;arcsine&quot; for arcsine, &quot;log&quot; or &quot;none&quot;
for non transformation. By default, &quot;none&quot; is used.</p>
</td></tr>
<tr><td><code id="svmkrigecv_+3A_delta">delta</code></td>
<td>
<p>numeric; to avoid log(0) in the log transformation. The default is 1.</p>
</td></tr>
<tr><td><code id="svmkrigecv_+3A_formula.krige">formula.krige</code></td>
<td>
<p>formula defining the response vector and (possible) regressor.
an object (i.e., 'variogram.formula') for 'variogram' or a formula for
'krige'. see 'variogram' and 'krige' in 'gstat' for details.</p>
</td></tr>
<tr><td><code id="svmkrigecv_+3A_vgm.args">vgm.args</code></td>
<td>
<p>arguments for 'vgm', e.g. variogram model of response
variable and anisotropy parameters. see 'vgm' in 'gstat' for details.
By default, &quot;Sph&quot; is used.</p>
</td></tr>
<tr><td><code id="svmkrigecv_+3A_anis">anis</code></td>
<td>
<p>anisotropy parameters: see notes 'vgm' in 'gstat' for details.</p>
</td></tr>
<tr><td><code id="svmkrigecv_+3A_alpha">alpha</code></td>
<td>
<p>direction in plane (x,y). see variogram in 'gstat' for details.</p>
</td></tr>
<tr><td><code id="svmkrigecv_+3A_block">block</code></td>
<td>
<p>block size. see 'krige' in 'gstat' for details.</p>
</td></tr>
<tr><td><code id="svmkrigecv_+3A_beta">beta</code></td>
<td>
<p>for simple kriging. see 'krige' in 'gstat' for details.</p>
</td></tr>
<tr><td><code id="svmkrigecv_+3A_nmaxkrige">nmaxkrige</code></td>
<td>
<p>for a local predicting: the number of nearest observations that
should be used for a prediction or simulation, where nearest is defined in
terms of the space of the spatial locations. By default, 12 observations
are used.</p>
</td></tr>
<tr><td><code id="svmkrigecv_+3A_validation">validation</code></td>
<td>
<p>validation methods, include 'LOO': leave-one-out, and 'CV':
cross-validation.</p>
</td></tr>
<tr><td><code id="svmkrigecv_+3A_cv.fold">cv.fold</code></td>
<td>
<p>integer; number of folds in the cross-validation. if &gt; 1,
then apply n-fold cross validation; the default is 10, i.e., 10-fold cross
validation that is recommended.</p>
</td></tr>
<tr><td><code id="svmkrigecv_+3A_predacc">predacc</code></td>
<td>
<p>can be either &quot;VEcv&quot; for 'vecv' or &quot;ALL&quot; for all measures
in function pred.acc.</p>
</td></tr>
<tr><td><code id="svmkrigecv_+3A_...">...</code></td>
<td>
<p>other arguments passed on to 'svm' and 'krige'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following components:
me, rme, mae, rmae, mse, rmse, rrmse, vecv and e1; or vecv only
</p>


<h3>Note</h3>

<p>This function is largely based on 'rfcv' in 'randomForest', 'krigecv'
in 'spm2'and 'svm' in 'e1071'.
</p>


<h3>Author(s)</h3>

<p>Jin Li
</p>


<h3>References</h3>

<p>Li, J., Potter, A., Huang, Z., and Heap, A. (2012). Predicting Seabed
Sand Content across the Australian Margin Using Machine Learning and Geostatistical
Methods, Geoscience Australia, Record 2012/48, 115pp.
</p>
<p>Li, J., Heap, A., Potter, A., and Danilel, J.J. (2011). Predicting Seabed Mud Content
across the Australian Margin II: Performance of Machine Learning Methods and Their
Combination with Ordinary Kriging and Inverse Distance Squared, Geoscience Australia,
Record 2011/07, 69pp.
</p>
<p>David Meyer, Evgenia Dimitriadou, Kurt Hornik, Andreas Weingessel and Friedrich
Leisch (2020). e1071: Misc Functions of the Department of Statistics, Probability
Theory Group (Formerly: E1071), TU Wien. R package version 1.7-4.
https://CRAN.R-project.org/package=e1071.
</p>
<p>Pebesma, E.J., 2004. Multivariable geostatistics in S: the gstat package.
Computers &amp; Geosciences, 30: 683-691.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(spm)

data(petrel)

gravel &lt;- petrel[, c(1, 2, 6:9, 5)]
longlat &lt;- petrel[, c(1, 2)]
model &lt;- log(gravel + 1) ~  lat +  bathy + I(long^3) + I(lat^2) + I(lat^3)
y &lt;- log(gravel[, 7] +1)
set.seed(1234)
svmkrigecv1 &lt;- svmkrigecv(formula.svm = model, longlat = longlat, trainxy =  gravel,
y = y, transformation = "none", formula.krige = res1 ~ 1, vgm.args = "Sph",
nmaxkrige = 12, validation = "CV", predacc = "ALL")
svmkrigecv1

# svmok for count data
data(sponge2)
model &lt;- species.richness ~ . # use all predictive variables in the dataset
longlat &lt;- sponge2[, 1:2]
set.seed(1234)
n &lt;- 20 # number of iterations,60 to 100 is recommended.
VEcv &lt;- NULL
for (i in 1:n) {
 svmkrigecv1 &lt;- svmkrigecv(formula.svm = model, longlat = longlat, trainxy = sponge2[, -4],
 y = sponge2[, 3], gamma = 0.01, cost = 3.5, scale = TRUE,  formula.krige = res1 ~ 1,
 vgm.args = ("Sph"), nmaxkrige = 12,  validation = "CV",  predacc = "VEcv")
 VEcv [i] &lt;- svmkrigecv1
 }
 plot(VEcv ~ c(1:n), xlab = "Iteration for svm", ylab = "VEcv (%)")
 points(cumsum(VEcv) / c(1:n) ~ c(1:n), col = 2)
 abline(h = mean(VEcv), col = 'blue', lwd = 2)


</code></pre>

<hr>
<h2 id='svmkrigeidwcv'>Cross validation, n-fold and leave-one-out for the hybrid methods of
support vector machine ('svm') regression , 'kriging' and inverse distance weighted ('IDW').</h2><span id='topic+svmkrigeidwcv'></span>

<h3>Description</h3>

<p>This function is a cross validation function for 38 hybrid
methods of 'svm', 'kriging' and 'IDW', including the average of 'svmkrige'
and 'svmidw' ('svmkrigesvmidw') and  the average of 'svm', 'svmkrige' and 'svmidw'
('svmsvmkrigesvmidw'), where 'kriging' methods include ordinary kriging
('OK'), simple kriging ('SK'), block 'OK' ('BOK') and block 'SK'('BSK') and
'IDW' also covers 'NN' and 'KNN'.. The data splitting is based on a stratified
random sampling method (see the 'datasplit' function for details).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>svmkrigeidwcv(
  formula.svm = NULL,
  longlat,
  trainxy,
  y,
  scale = TRUE,
  type = NULL,
  kernel = "radial",
  degree = 3,
  gamma = if (is.vector(trainxy)) 1 else 1/ncol(trainxy),
  coef0 = 0,
  cost = 1,
  nu = 0.5,
  tolerance = 0.001,
  epsilon = 0.1,
  transformation = "none",
  delta = 1,
  formula.krige = res1 ~ 1,
  vgm.args = c("Sph"),
  anis = c(0, 1),
  alpha = 0,
  block = 0,
  beta,
  nmaxkrige = 12,
  idp = 2,
  nmaxidw = 12,
  hybrid.parameter = 2,
  lambda = 1,
  validation = "CV",
  cv.fold = 10,
  predacc = "VEcv",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="svmkrigeidwcv_+3A_formula.svm">formula.svm</code></td>
<td>
<p>a formula defining the response variable and predictive variables for 'svm'.</p>
</td></tr>
<tr><td><code id="svmkrigeidwcv_+3A_longlat">longlat</code></td>
<td>
<p>a dataframe contains longitude and latitude of point samples.</p>
</td></tr>
<tr><td><code id="svmkrigeidwcv_+3A_trainxy">trainxy</code></td>
<td>
<p>a dataframe contains longitude (long), latitude (lat),
predictive variables and the response variable of point samples. That is,
the location information must be named as 'long' and 'lat'.</p>
</td></tr>
<tr><td><code id="svmkrigeidwcv_+3A_y">y</code></td>
<td>
<p>a vector of the response variable in the formula, that is, the left
part of the formula.</p>
</td></tr>
<tr><td><code id="svmkrigeidwcv_+3A_scale">scale</code></td>
<td>
<p>A logical vector indicating the variables to be scaled (default: TRUE).</p>
</td></tr>
<tr><td><code id="svmkrigeidwcv_+3A_type">type</code></td>
<td>
<p>the default setting is 'NULL'. See '?svm' for various options.</p>
</td></tr>
<tr><td><code id="svmkrigeidwcv_+3A_kernel">kernel</code></td>
<td>
<p>the default setting is 'radial'. See '?svm' for other options.</p>
</td></tr>
<tr><td><code id="svmkrigeidwcv_+3A_degree">degree</code></td>
<td>
<p>a parameter needed for kernel of type polynomial (default: 3).</p>
</td></tr>
<tr><td><code id="svmkrigeidwcv_+3A_gamma">gamma</code></td>
<td>
<p>a parameter needed for all 'kernels' except 'linear'
(default: 1/(data dimension)).</p>
</td></tr>
<tr><td><code id="svmkrigeidwcv_+3A_coef0">coef0</code></td>
<td>
<p>a parameter needed for kernels of type 'polynomial' and 'sigmoid'(default: 0).</p>
</td></tr>
<tr><td><code id="svmkrigeidwcv_+3A_cost">cost</code></td>
<td>
<p>cost of constraints violation (default: 1).</p>
</td></tr>
<tr><td><code id="svmkrigeidwcv_+3A_nu">nu</code></td>
<td>
<p>a parameter needed for 'nu-classification', 'nu-regression', and 'one-classification' (default: 0.5).</p>
</td></tr>
<tr><td><code id="svmkrigeidwcv_+3A_tolerance">tolerance</code></td>
<td>
<p>tolerance of termination criterion (default: 0.001).</p>
</td></tr>
<tr><td><code id="svmkrigeidwcv_+3A_epsilon">epsilon</code></td>
<td>
<p>'epsilon' in the insensitive-loss function (default: 0.1).</p>
</td></tr>
<tr><td><code id="svmkrigeidwcv_+3A_transformation">transformation</code></td>
<td>
<p>transform the residuals of 'svm' to normalise the data for 'krige';
can be &quot;sqrt&quot; for square root, &quot;arcsine&quot; for arcsine, &quot;log&quot; or &quot;none&quot;
for non transformation. By default, &quot;none&quot; is used.</p>
</td></tr>
<tr><td><code id="svmkrigeidwcv_+3A_delta">delta</code></td>
<td>
<p>numeric; to avoid log(0) in the log transformation. The default is 1.</p>
</td></tr>
<tr><td><code id="svmkrigeidwcv_+3A_formula.krige">formula.krige</code></td>
<td>
<p>formula defining the response vector and (possible) regressor.
an object (i.e., 'variogram.formula') for 'variogram' or a formula for
'krige'. see 'variogram' and 'krige' in 'gstat' for details.</p>
</td></tr>
<tr><td><code id="svmkrigeidwcv_+3A_vgm.args">vgm.args</code></td>
<td>
<p>arguments for 'vgm', e.g. variogram model of response
variable and anisotropy parameters. see 'vgm' in 'gstat' for details.
By default, &quot;Sph&quot; is used.</p>
</td></tr>
<tr><td><code id="svmkrigeidwcv_+3A_anis">anis</code></td>
<td>
<p>anisotropy parameters: see notes 'vgm' in 'gstat' for details.</p>
</td></tr>
<tr><td><code id="svmkrigeidwcv_+3A_alpha">alpha</code></td>
<td>
<p>direction in plane (x,y). see variogram in 'gstat' for details.</p>
</td></tr>
<tr><td><code id="svmkrigeidwcv_+3A_block">block</code></td>
<td>
<p>block size. see 'krige' in 'gstat' for details.</p>
</td></tr>
<tr><td><code id="svmkrigeidwcv_+3A_beta">beta</code></td>
<td>
<p>for simple kriging. see 'krige' in 'gstat' for details.</p>
</td></tr>
<tr><td><code id="svmkrigeidwcv_+3A_nmaxkrige">nmaxkrige</code></td>
<td>
<p>for a local predicting: the number of nearest observations that
should be used for a prediction or simulation, where nearest is defined in
terms of the space of the spatial locations. By default, 12 observations
are used.</p>
</td></tr>
<tr><td><code id="svmkrigeidwcv_+3A_idp">idp</code></td>
<td>
<p>a numeric number specifying the inverse distance weighting power.</p>
</td></tr>
<tr><td><code id="svmkrigeidwcv_+3A_nmaxidw">nmaxidw</code></td>
<td>
<p>for a local predicting: the number of nearest observations that
should be used for a prediction or simulation, where nearest is defined in
terms of the space of the spatial locations. By default, 12 observations
are used.</p>
</td></tr>
<tr><td><code id="svmkrigeidwcv_+3A_hybrid.parameter">hybrid.parameter</code></td>
<td>
<p>the default is 2 that is for 'svmkrigesvmidw';
for 'svmsvmkrigesvmidw', it needs to be 3.</p>
</td></tr>
<tr><td><code id="svmkrigeidwcv_+3A_lambda">lambda</code></td>
<td>
<p>ranging from 0 to 2; the default is 1 for 'svmkrigesvmidw'
and 'svmsvmkrigesvmidw'; and if it is &lt; 1, more weight is placed on 'krige',
otherwise more weight is placed on 'idw'; and if it is 0, 'idw' is not
considered and the resultant methods is 'svmkrige' when the default
'hybrid.parameter' is used; and if it is 2, then the resultant method is
'svmidw' when the default 'hybrid.parameter' is used.</p>
</td></tr>
<tr><td><code id="svmkrigeidwcv_+3A_validation">validation</code></td>
<td>
<p>validation methods, include 'LOO': leave-one-out, and 'CV':
cross-validation.</p>
</td></tr>
<tr><td><code id="svmkrigeidwcv_+3A_cv.fold">cv.fold</code></td>
<td>
<p>integer; number of folds in the cross-validation. if &gt; 1,
then apply n-fold cross validation; the default is 10, i.e., 10-fold cross
validation that is recommended.</p>
</td></tr>
<tr><td><code id="svmkrigeidwcv_+3A_predacc">predacc</code></td>
<td>
<p>can be either &quot;VEcv&quot; for vecv or &quot;ALL&quot; for all measures
in function pred.acc.</p>
</td></tr>
<tr><td><code id="svmkrigeidwcv_+3A_...">...</code></td>
<td>
<p>other arguments passed on to 'svm', 'krige' and 'gstat'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following components:
me, rme, mae, rmae, mse, rmse, rrmse, vecv and e1; or vecv only
</p>


<h3>Note</h3>

<p>This function is largely based on 'rfcv' in 'randomForest', 'krigecv'
in 'spm2'and 'svm' in 'e1071'.
</p>


<h3>Author(s)</h3>

<p>Jin Li
</p>


<h3>References</h3>

<p>Li, J. (2022). Spatial Predictive Modeling with R. Boca Raton,
Chapman and Hall/CRC.
</p>
<p>Li, J., Potter, A., Huang, Z., and Heap, A. (2012). Predicting Seabed
Sand Content across the Australian Margin Using Machine Learning and Geostatistical
Methods, Geoscience Australia, Record 2012/48, 115pp.
</p>
<p>Li, J., Heap, A., Potter, A., and Danilel, J.J. (2011). Predicting Seabed Mud Content
across the Australian Margin II: Performance of Machine Learning Methods and Their
Combination with Ordinary Kriging and Inverse Distance Squared, Geoscience Australia,
Record 2011/07, 69pp.
</p>
<p>David Meyer, Evgenia Dimitriadou, Kurt Hornik, Andreas Weingessel and Friedrich
Leisch (2020). e1071: Misc Functions of the Department of Statistics, Probability
Theory Group (Formerly: E1071), TU Wien. R package version 1.7-4.
https://CRAN.R-project.org/package=e1071.
</p>
<p>Pebesma, E.J., 2004. Multivariable geostatistics in S: the gstat package.
Computers &amp; Geosciences, 30: 683-691.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(spm)
# svmokglidw
data(petrel)
gravel &lt;- petrel[, c(1, 2, 6:9, 5)]
longlat &lt;- petrel[, c(1, 2)]
model &lt;- log(gravel + 1) ~  lat +  bathy + I(long^3) + I(lat^2) + I(lat^3)
y &lt;- log(gravel[, 7] +1)
set.seed(1234)
svmkrigesvmidwcv1 &lt;- svmkrigeidwcv(formula.svm = model, longlat = longlat,
trainxy =  gravel, y = y, transformation = "none", formula.krige = res1 ~ 1,
vgm.args = "Sph", nmaxkrige = 12, idp = 2, nmaxidw = 12, validation = "CV",
 predacc = "ALL")
svmkrigesvmidwcv1

# svmsvmoksvmidw
data(sponge2)
model &lt;- species.richness ~ . # use all predictive variables in the dataset
longlat &lt;- sponge2[, 1:2]
y = sponge[, 3]
set.seed(1234)
svmsvmkrigesvmidwcv1 &lt;- svmkrigeidwcv(formula.svm = model, longlat = longlat,
trainxy = sponge2[, -4], y = y, gamma = 0.01, cost = 3.5, scale = TRUE,
formula.krige = res1 ~ 1, vgm.args = ("Sph"), nmaxkrige = 12, idp = 2,
nmaxidw = 12, hybrid.parameter = 3, validation = "CV", predacc = "ALL")
svmsvmkrigesvmidwcv1

# svmoksvmidw for count data
data(sponge2)
model &lt;- species.richness ~ . # use all predictive variables in the dataset
longlat &lt;- sponge2[, 1:2]
y = sponge2[, 3]
set.seed(1234)
n &lt;- 20 # number of iterations,60 to 100 is recommended.
VEcv &lt;- NULL
for (i in 1:n) {
 svmkrigesvmidwcv1 &lt;- svmkrigeidwcv(formula.svm = model, longlat = longlat,
 trainxy = sponge2[, -4], y = y, gamma = 0.01, cost = 3.5, scale = TRUE,
 formula.krige = res1 ~ 1, vgm.args = ("Sph"), nmaxkrige = 12, idp = 2,
 nmaxidw = 12, validation = "CV",  predacc = "VEcv")
 VEcv [i] &lt;- svmkrigesvmidwcv1
 }
 plot(VEcv ~ c(1:n), xlab = "Iteration for svm", ylab = "VEcv (%)")
 points(cumsum(VEcv) / c(1:n) ~ c(1:n), col = 2)
 abline(h = mean(VEcv), col = 'blue', lwd = 2)


</code></pre>

<hr>
<h2 id='svmkrigeidwpred'>Generate spatial predictions using the hybrid methods of
support vector machine ('svm') regression , 'kriging' and inverse distance weighted ('IDW').</h2><span id='topic+svmkrigeidwpred'></span>

<h3>Description</h3>

<p>This function is for generating spatial predictions using the
hybrid methods of 'svm', 'kriging' and 'IDW', including all methods implemented
in 'svmkrigeidwcv'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>svmkrigeidwpred(
  formula.svm = NULL,
  longlat,
  trainxy,
  predx,
  y,
  longlatpredx,
  scale = TRUE,
  type = NULL,
  kernel = "radial",
  degree = 3,
  gamma = if (is.vector(trainxy)) 1 else 1/ncol(trainxy),
  coef0 = 0,
  cost = 1,
  nu = 0.5,
  tolerance = 0.001,
  epsilon = 0.1,
  transformation = "none",
  delta = 1,
  formula.krige = res1 ~ 1,
  vgm.args = c("Sph"),
  anis = c(0, 1),
  alpha = 0,
  block = 0,
  beta,
  nmaxkrige = 12,
  idp = 2,
  nmaxidw = 12,
  hybrid.parameter = 2,
  lambda = 1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="svmkrigeidwpred_+3A_formula.svm">formula.svm</code></td>
<td>
<p>a formula defining the response variable and predictive variables for 'svm'.</p>
</td></tr>
<tr><td><code id="svmkrigeidwpred_+3A_longlat">longlat</code></td>
<td>
<p>a dataframe contains longitude and latitude of point samples.</p>
</td></tr>
<tr><td><code id="svmkrigeidwpred_+3A_trainxy">trainxy</code></td>
<td>
<p>a dataframe contains longitude (long), latitude (lat),
predictive variables and the response variable of point samples.</p>
</td></tr>
<tr><td><code id="svmkrigeidwpred_+3A_predx">predx</code></td>
<td>
<p>a dataframe or matrix contains columns of predictive variables
for the grids to be predicted.</p>
</td></tr>
<tr><td><code id="svmkrigeidwpred_+3A_y">y</code></td>
<td>
<p>a vector of the response variable in the formula, that is, the left
part of the formula.</p>
</td></tr>
<tr><td><code id="svmkrigeidwpred_+3A_longlatpredx">longlatpredx</code></td>
<td>
<p>a dataframe contains longitude and latitude of point locations
(i.e., the centers of grids) to be predicted.</p>
</td></tr>
<tr><td><code id="svmkrigeidwpred_+3A_scale">scale</code></td>
<td>
<p>A logical vector indicating the variables to be scaled (default: TRUE).</p>
</td></tr>
<tr><td><code id="svmkrigeidwpred_+3A_type">type</code></td>
<td>
<p>the default setting is 'NULL'. See '?svm' for various options.</p>
</td></tr>
<tr><td><code id="svmkrigeidwpred_+3A_kernel">kernel</code></td>
<td>
<p>the default setting is 'radial'. See '?svm' for other options.</p>
</td></tr>
<tr><td><code id="svmkrigeidwpred_+3A_degree">degree</code></td>
<td>
<p>a parameter needed for kernel of type polynomial (default: 3).</p>
</td></tr>
<tr><td><code id="svmkrigeidwpred_+3A_gamma">gamma</code></td>
<td>
<p>a parameter needed for all 'kernels' except 'linear'
(default: 1/(data dimension)).</p>
</td></tr>
<tr><td><code id="svmkrigeidwpred_+3A_coef0">coef0</code></td>
<td>
<p>a parameter needed for kernels of type 'polynomial' and 'sigmoid'(default: 0).</p>
</td></tr>
<tr><td><code id="svmkrigeidwpred_+3A_cost">cost</code></td>
<td>
<p>cost of constraints violation (default: 1).</p>
</td></tr>
<tr><td><code id="svmkrigeidwpred_+3A_nu">nu</code></td>
<td>
<p>a parameter needed for 'nu-classification', 'nu-regression', and 'one-classification' (default: 0.5).</p>
</td></tr>
<tr><td><code id="svmkrigeidwpred_+3A_tolerance">tolerance</code></td>
<td>
<p>tolerance of termination criterion (default: 0.001).</p>
</td></tr>
<tr><td><code id="svmkrigeidwpred_+3A_epsilon">epsilon</code></td>
<td>
<p>'epsilon' in the insensitive-loss function (default: 0.1).
See '?svm' for details.</p>
</td></tr>
<tr><td><code id="svmkrigeidwpred_+3A_transformation">transformation</code></td>
<td>
<p>transform the residuals of 'svm' to normalise the data;
can be &quot;sqrt&quot; for square root, &quot;arcsine&quot; for arcsine, &quot;log&quot; or &quot;none&quot;
for non transformation. By default, &quot;none&quot; is used.</p>
</td></tr>
<tr><td><code id="svmkrigeidwpred_+3A_delta">delta</code></td>
<td>
<p>numeric; to avoid log(0) in the log transformation. The default is 1.</p>
</td></tr>
<tr><td><code id="svmkrigeidwpred_+3A_formula.krige">formula.krige</code></td>
<td>
<p>formula defining the response vector and (possible) regressor.
an object (i.e., 'variogram.formula') for 'variogram' or a formula for
'krige'. see 'variogram' and 'krige' in 'gstat' for details.</p>
</td></tr>
<tr><td><code id="svmkrigeidwpred_+3A_vgm.args">vgm.args</code></td>
<td>
<p>arguments for 'vgm', e.g. variogram model of response
variable and anisotropy parameters. see 'vgm' in 'gstat' for details.
By default, &quot;Sph&quot; is used.</p>
</td></tr>
<tr><td><code id="svmkrigeidwpred_+3A_anis">anis</code></td>
<td>
<p>anisotropy parameters: see notes 'vgm' in 'gstat' for details.</p>
</td></tr>
<tr><td><code id="svmkrigeidwpred_+3A_alpha">alpha</code></td>
<td>
<p>direction in plane (x,y). see variogram in 'gstat' for details.</p>
</td></tr>
<tr><td><code id="svmkrigeidwpred_+3A_block">block</code></td>
<td>
<p>block size. see 'krige' in 'gstat' for details.</p>
</td></tr>
<tr><td><code id="svmkrigeidwpred_+3A_beta">beta</code></td>
<td>
<p>for simple kriging. see 'krige' in 'gstat' for details.</p>
</td></tr>
<tr><td><code id="svmkrigeidwpred_+3A_nmaxkrige">nmaxkrige</code></td>
<td>
<p>for a local predicting: the number of nearest observations that
should be used for a prediction or simulation, where nearest is defined in
terms of the space of the spatial locations. By default, 12 observations
are used.</p>
</td></tr>
<tr><td><code id="svmkrigeidwpred_+3A_idp">idp</code></td>
<td>
<p>a numeric number specifying the inverse distance weighting power.</p>
</td></tr>
<tr><td><code id="svmkrigeidwpred_+3A_nmaxidw">nmaxidw</code></td>
<td>
<p>for a local predicting: the number of nearest observations that
should be used for a prediction or simulation, where nearest is defined in
terms of the space of the spatial locations. By default, 12 observations
are used.</p>
</td></tr>
<tr><td><code id="svmkrigeidwpred_+3A_hybrid.parameter">hybrid.parameter</code></td>
<td>
<p>the default is 2 that is for 'svmkrigesvmidw';
for 'svmsvmkrigesvmidw', it needs to be 3.</p>
</td></tr>
<tr><td><code id="svmkrigeidwpred_+3A_lambda">lambda</code></td>
<td>
<p>ranging from 0 to 2; the default is 1 for 'svmkrigesvmidw'
and 'svmsvmkrigesvmidw'; and if it is &lt; 1, more weight is placed on 'krige',
otherwise more weight is placed on 'idw'; and if it is 0, 'idw' is not
considered and the resultant methods is 'svmkrige' when the default
'hybrid.parameter' is used; and if it is 2, then the resultant method is
'svmidw' when the default 'hybrid.parameter' is used.</p>
</td></tr>
<tr><td><code id="svmkrigeidwpred_+3A_...">...</code></td>
<td>
<p>other arguments passed on to 'svm', 'krige' and 'gstat'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe of longitude, latitude, and predictions.
</p>


<h3>Author(s)</h3>

<p>Jin Li
</p>


<h3>References</h3>

<p>Li, J., Potter, A., Huang, Z., and Heap, A. (2012). Predicting Seabed
Sand Content across the Australian Margin Using Machine Learning and Geostatistical
Methods, Geoscience Australia, Record 2012/48, 115pp.
</p>
<p>Li, J., Heap, A., Potter, A., and Danilel, J.J. (2011). Predicting Seabed Mud Content
across the Australian Margin II: Performance of Machine Learning Methods and Their
Combination with Ordinary Kriging and Inverse Distance Squared, Geoscience Australia,
Record 2011/07, 69pp.
</p>
<p>David Meyer, Evgenia Dimitriadou, Kurt Hornik, Andreas Weingessel and Friedrich
Leisch (2020). e1071: Misc Functions of the Department of Statistics, Probability
Theory Group (Formerly: E1071), TU Wien. R package version 1.7-4.
https://CRAN.R-project.org/package=e1071.
</p>
<p>Pebesma, E.J., 2004. Multivariable geostatistics in S: the gstat package.
Computers &amp; Geosciences, 30: 683-691.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(spm)

data(petrel)
data(petrel.grid)

gravel &lt;- petrel[, c(1, 2, 6:9, 5)]
longlat &lt;- petrel[, c(1, 2)]
model &lt;- log(gravel + 1) ~  lat +  bathy + I(long^3) + I(lat^2) + I(lat^3)
y &lt;- log(gravel[, 7] +1)

svmkrigeidwpred1 &lt;- svmkrigeidwpred(formula.svm = model, longlat = longlat, trainxy =  gravel,
predx = petrel.grid, y = y, longlatpredx = petrel.grid[, c(1:2)],
formula.krige = res1 ~ 1, vgm.args = "Sph", nmaxkrige = 12, idp = 2, nmaxidw = 12)

names(svmkrigeidwpred1)

# Back transform 'svmkrigeidwpred$predictions' to generate the final predictions
svmkrigeidw.predictions &lt;- exp(svmkrigeidwpred1$predictions) - 1
range(svmkrigeidw.predictions)


</code></pre>

<hr>
<h2 id='svmkrigepred'>Generate spatial predictions using the hybrid method of support
vector machine ('svm') regression and 'krige' (svmkrige)</h2><span id='topic+svmkrigepred'></span>

<h3>Description</h3>

<p>This function is for generating spatial predictions using the hybrid method of
'svm' and 'krige' (svmkrige).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>svmkrigepred(
  formula.svm = NULL,
  longlat,
  trainxy,
  predx,
  y,
  longlatpredx,
  scale = TRUE,
  type = NULL,
  kernel = "radial",
  degree = 3,
  gamma = if (is.vector(trainxy)) 1 else 1/ncol(trainxy),
  coef0 = 0,
  cost = 1,
  nu = 0.5,
  tolerance = 0.001,
  epsilon = 0.1,
  transformation = "none",
  delta = 1,
  formula.krige = res1 ~ 1,
  vgm.args = c("Sph"),
  anis = c(0, 1),
  alpha = 0,
  block = 0,
  beta,
  nmaxkrige = 12,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="svmkrigepred_+3A_formula.svm">formula.svm</code></td>
<td>
<p>a formula defining the response variable and predictive variables for 'svm'.</p>
</td></tr>
<tr><td><code id="svmkrigepred_+3A_longlat">longlat</code></td>
<td>
<p>a dataframe contains longitude and latitude of point samples.</p>
</td></tr>
<tr><td><code id="svmkrigepred_+3A_trainxy">trainxy</code></td>
<td>
<p>a dataframe contains longitude (long), latitude (lat),
predictive variables and the response variable of point samples.</p>
</td></tr>
<tr><td><code id="svmkrigepred_+3A_predx">predx</code></td>
<td>
<p>a dataframe or matrix contains columns of predictive variables
for the grids to be predicted.</p>
</td></tr>
<tr><td><code id="svmkrigepred_+3A_y">y</code></td>
<td>
<p>a vector of the response variable in the formula, that is, the left
part of the formula.</p>
</td></tr>
<tr><td><code id="svmkrigepred_+3A_longlatpredx">longlatpredx</code></td>
<td>
<p>a dataframe contains longitude and latitude of point locations
(i.e., the centers of grids) to be predicted.</p>
</td></tr>
<tr><td><code id="svmkrigepred_+3A_scale">scale</code></td>
<td>
<p>A logical vector indicating the variables to be scaled (default: TRUE).</p>
</td></tr>
<tr><td><code id="svmkrigepred_+3A_type">type</code></td>
<td>
<p>the default setting is 'NULL'. See '?svm' for various options.</p>
</td></tr>
<tr><td><code id="svmkrigepred_+3A_kernel">kernel</code></td>
<td>
<p>the default setting is 'radial'. See '?svm' for other options.</p>
</td></tr>
<tr><td><code id="svmkrigepred_+3A_degree">degree</code></td>
<td>
<p>a parameter needed for kernel of type polynomial (default: 3).</p>
</td></tr>
<tr><td><code id="svmkrigepred_+3A_gamma">gamma</code></td>
<td>
<p>a parameter needed for all 'kernels' except 'linear'
(default: 1/(data dimension)).</p>
</td></tr>
<tr><td><code id="svmkrigepred_+3A_coef0">coef0</code></td>
<td>
<p>a parameter needed for kernels of type 'polynomial' and 'sigmoid'(default: 0).</p>
</td></tr>
<tr><td><code id="svmkrigepred_+3A_cost">cost</code></td>
<td>
<p>cost of constraints violation (default: 1).</p>
</td></tr>
<tr><td><code id="svmkrigepred_+3A_nu">nu</code></td>
<td>
<p>a parameter needed for 'nu-classification', 'nu-regression', and 'one-classification' (default: 0.5).</p>
</td></tr>
<tr><td><code id="svmkrigepred_+3A_tolerance">tolerance</code></td>
<td>
<p>tolerance of termination criterion (default: 0.001).</p>
</td></tr>
<tr><td><code id="svmkrigepred_+3A_epsilon">epsilon</code></td>
<td>
<p>'epsilon' in the insensitive-loss function (default: 0.1).
See '?svm' for details.</p>
</td></tr>
<tr><td><code id="svmkrigepred_+3A_transformation">transformation</code></td>
<td>
<p>transform the residuals of 'svm' to normalise the data;
can be &quot;sqrt&quot; for square root, &quot;arcsine&quot; for arcsine, &quot;log&quot; or &quot;none&quot;
for non transformation. By default, &quot;none&quot; is used.</p>
</td></tr>
<tr><td><code id="svmkrigepred_+3A_delta">delta</code></td>
<td>
<p>numeric; to avoid log(0) in the log transformation. The default is 1.</p>
</td></tr>
<tr><td><code id="svmkrigepred_+3A_formula.krige">formula.krige</code></td>
<td>
<p>formula defining the response vector and (possible) regressor.
an object (i.e., 'variogram.formula') for 'variogram' or a formula for
'krige'. see 'variogram' and 'krige' in 'gstat' for details.</p>
</td></tr>
<tr><td><code id="svmkrigepred_+3A_vgm.args">vgm.args</code></td>
<td>
<p>arguments for 'vgm', e.g. variogram model of response
variable and anisotropy parameters. see 'vgm' in 'gstat' for details.
By default, &quot;Sph&quot; is used.</p>
</td></tr>
<tr><td><code id="svmkrigepred_+3A_anis">anis</code></td>
<td>
<p>anisotropy parameters: see notes 'vgm' in 'gstat' for details.</p>
</td></tr>
<tr><td><code id="svmkrigepred_+3A_alpha">alpha</code></td>
<td>
<p>direction in plane (x,y). see variogram in 'gstat' for details.</p>
</td></tr>
<tr><td><code id="svmkrigepred_+3A_block">block</code></td>
<td>
<p>block size. see 'krige' in 'gstat' for details.</p>
</td></tr>
<tr><td><code id="svmkrigepred_+3A_beta">beta</code></td>
<td>
<p>for simple kriging. see 'krige' in 'gstat' for details.</p>
</td></tr>
<tr><td><code id="svmkrigepred_+3A_nmaxkrige">nmaxkrige</code></td>
<td>
<p>for a local predicting: the number of nearest observations that
should be used for a prediction or simulation, where nearest is defined in
terms of the space of the spatial locations. By default, 12 observations
are used.</p>
</td></tr>
<tr><td><code id="svmkrigepred_+3A_...">...</code></td>
<td>
<p>other arguments passed on to 'svm' and 'krige'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe of longitude, latitude, and predictions.
</p>


<h3>Author(s)</h3>

<p>Jin Li
</p>


<h3>References</h3>

<p>Li, J., Potter, A., Huang, Z., and Heap, A. (2012). Predicting Seabed
Sand Content across the Australian Margin Using Machine Learning and Geostatistical
Methods, Geoscience Australia, Record 2012/48, 115pp.
</p>
<p>Li, J., Heap, A., Potter, A., and Danilel, J.J. (2011). Predicting Seabed Mud Content
across the Australian Margin II: Performance of Machine Learning Methods and Their
Combination with Ordinary Kriging and Inverse Distance Squared, Geoscience Australia,
Record 2011/07, 69pp.
</p>
<p>David Meyer, Evgenia Dimitriadou, Kurt Hornik, Andreas Weingessel and Friedrich
Leisch (2020). e1071: Misc Functions of the Department of Statistics, Probability
Theory Group (Formerly: E1071), TU Wien. R package version 1.7-4.
https://CRAN.R-project.org/package=e1071.
</p>
<p>Pebesma, E.J., 2004. Multivariable geostatistics in S: the gstat package.
Computers &amp; Geosciences, 30: 683-691.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(spm)

data(petrel)
data(petrel.grid)

gravel &lt;- petrel[, c(1, 2, 6:9, 5)]
longlat &lt;- petrel[, c(1, 2)]
model &lt;- log(gravel + 1) ~  lat +  bathy + I(long^3) + I(lat^2) + I(lat^3)
y &lt;- log(gravel[, 7] +1)

svmkrigepred1 &lt;- svmkrigepred(formula.svm = model, longlat = longlat, trainxy =  gravel,
predx = petrel.grid, y = y, longlatpredx = petrel.grid[, c(1:2)],
transformation = "none", formula.krige = res1 ~ 1, vgm.args = "Sph", nmaxkrige = 12)

names(svmkrigepred1)

# Back transform 'svmkrigepred$predictions' to generate the final predictions
svmkrige.predictions &lt;- exp(svmkrigepred1$predictions) - 1
range(svmkrige.predictions)


</code></pre>

<hr>
<h2 id='svmpred'>Generate spatial predictions using support vector machine ('svm')</h2><span id='topic+svmpred'></span>

<h3>Description</h3>

<p>This function is for generating spatial predictions using 'svm' method
in 'e1071' package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>svmpred(
  formula = NULL,
  trainxy,
  longlatpredx,
  predx,
  scale = TRUE,
  type = NULL,
  kernel = "radial",
  degree = 3,
  gamma = if (is.vector(trainxy)) 1 else 1/ncol(trainxy),
  coef0 = 0,
  cost = 1,
  nu = 0.5,
  tolerance = 0.001,
  epsilon = 0.1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="svmpred_+3A_formula">formula</code></td>
<td>
<p>a formula defining the response variable and predictive variables.</p>
</td></tr>
<tr><td><code id="svmpred_+3A_trainxy">trainxy</code></td>
<td>
<p>a dataframe contains predictive variables and the response
variable of point samples. The location information, longitude (long),
latitude (lat), need to be included in the 'trainx' for spatial predictive
modeling, need to be named as 'long' and 'lat'.</p>
</td></tr>
<tr><td><code id="svmpred_+3A_longlatpredx">longlatpredx</code></td>
<td>
<p>a dataframe contains longitude and latitude of point
locations (i.e., the centers of grids) to be predicted, need to be named as
'long' and 'lat'.</p>
</td></tr>
<tr><td><code id="svmpred_+3A_predx">predx</code></td>
<td>
<p>a dataframe or matrix contains columns of predictive variables
for the grids to be predicted.</p>
</td></tr>
<tr><td><code id="svmpred_+3A_scale">scale</code></td>
<td>
<p>A logical vector indicating the variables to be scaled (default: TRUE).</p>
</td></tr>
<tr><td><code id="svmpred_+3A_type">type</code></td>
<td>
<p>the default setting is 'NULL'. See '?svm' for various options.</p>
</td></tr>
<tr><td><code id="svmpred_+3A_kernel">kernel</code></td>
<td>
<p>the default setting is 'radial'. See '?svm' for other options.</p>
</td></tr>
<tr><td><code id="svmpred_+3A_degree">degree</code></td>
<td>
<p>a parameter needed for kernel of type polynomial (default: 3).</p>
</td></tr>
<tr><td><code id="svmpred_+3A_gamma">gamma</code></td>
<td>
<p>a parameter needed for all 'kernels' except 'linear'
(default: 1/(data dimension)).</p>
</td></tr>
<tr><td><code id="svmpred_+3A_coef0">coef0</code></td>
<td>
<p>a parameter needed for kernels of type 'polynomial' and 'sigmoid'(default: 0).</p>
</td></tr>
<tr><td><code id="svmpred_+3A_cost">cost</code></td>
<td>
<p>cost of constraints violation (default: 1).</p>
</td></tr>
<tr><td><code id="svmpred_+3A_nu">nu</code></td>
<td>
<p>a parameter needed for 'nu-classification', 'nu-regression', and 'one-classification' (default: 0.5).</p>
</td></tr>
<tr><td><code id="svmpred_+3A_tolerance">tolerance</code></td>
<td>
<p>tolerance of termination criterion (default: 0.001).</p>
</td></tr>
<tr><td><code id="svmpred_+3A_epsilon">epsilon</code></td>
<td>
<p>'epsilon' in the insensitive-loss function (default: 0.1).
See '?svm' for details.</p>
</td></tr>
<tr><td><code id="svmpred_+3A_...">...</code></td>
<td>
<p>other arguments passed on to 'svm'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe of longitude, latitude and predictions.
</p>


<h3>Author(s)</h3>

<p>Jin Li
</p>


<h3>References</h3>

<p>David Meyer, Evgenia Dimitriadou, Kurt Hornik, Andreas Weingessel and Friedrich
Leisch (2020). e1071: Misc Functions of the Department of Statistics, Probability
Theory Group (Formerly: E1071), TU Wien. R package version 1.7-4.
https://CRAN.R-project.org/package=e1071.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(spm)
data(petrel)
data(petrel.grid)

gravel &lt;- petrel[, c(1, 2, 6:9, 5)]
model &lt;- log(gravel + 1) ~  lat +  bathy + I(long^3) + I(lat^2) + I(lat^3)

svmpred1 &lt;- svmpred(formula = model, trainxy = gravel,
longlatpredx = petrel.grid[, c(1:2)], predx = petrel.grid)

names(svmpred1)

# Back transform 'svmpred1$pred.svm1' to generate the final predictions
svm.predictions &lt;- exp(svmpred1$pred.svm1) - 1
range(svm.predictions)


</code></pre>

<hr>
<h2 id='tpscv'>Cross validation, n-fold and leave-one-out for thin plate splines ('TPS')</h2><span id='topic+tpscv'></span>

<h3>Description</h3>

<p>This function is a cross validation function for 'Tps' method
in 'fields' package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tpscv(
  trainx,
  trainy,
  m = NULL,
  p = NULL,
  theta = 3,
  lambda = NULL,
  lon.lat = TRUE,
  validation = "CV",
  cv.fold = 10,
  predacc = "VEcv",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tpscv_+3A_trainx">trainx</code></td>
<td>
<p>a dataframe contains longitude (long), latitude (lat) and
predictive variables of point samples. That is, they must be names as
'long' and 'lat'.</p>
</td></tr>
<tr><td><code id="tpscv_+3A_trainy">trainy</code></td>
<td>
<p>a vector of response, must have length equal to the number
of rows in trainx.</p>
</td></tr>
<tr><td><code id="tpscv_+3A_m">m</code></td>
<td>
<p>A polynomial function of degree (m-1) will be included in the
model as the drift (or spatial trend) component. Default is 'm = NULL'
that is the value such that 2m-d is greater than zero where d is the
dimension of x.</p>
</td></tr>
<tr><td><code id="tpscv_+3A_p">p</code></td>
<td>
<p>polynomial power for Wendland radial basis functions as in 'Tps'.
'p = NULL' that leads to a default value of 2 for spatial predictive
modelling based on 'x' containing only the location information.</p>
</td></tr>
<tr><td><code id="tpscv_+3A_theta">theta</code></td>
<td>
<p>the tapering range. 'theta = 3' degrees is a very generous
taper range. For spatial predictive modeling the taper should be large
enough to about 20 non zero nearest neighbors for every location.</p>
</td></tr>
<tr><td><code id="tpscv_+3A_lambda">lambda</code></td>
<td>
<p>smoothing parameter, the default is 'NULL'. See '?Tps' for further info.</p>
</td></tr>
<tr><td><code id="tpscv_+3A_lon.lat">lon.lat</code></td>
<td>
<p>if 'TRUE' locations are interpreted as longitude and
latitude and great circle distance is used to find distances among
locations.</p>
</td></tr>
<tr><td><code id="tpscv_+3A_validation">validation</code></td>
<td>
<p>validation methods, include 'LOO': leave-one-out, and
'CV': cross-validation.</p>
</td></tr>
<tr><td><code id="tpscv_+3A_cv.fold">cv.fold</code></td>
<td>
<p>integer; number of folds in the cross-validation. if &gt; 1,
then apply n-fold cross validation; the default is 10, i.e., 10-fold cross
validation that is recommended.</p>
</td></tr>
<tr><td><code id="tpscv_+3A_predacc">predacc</code></td>
<td>
<p>can be either &quot;VEcv&quot; for vecv or &quot;ALL&quot; for all measures
in function pred.acc.</p>
</td></tr>
<tr><td><code id="tpscv_+3A_...">...</code></td>
<td>
<p>other arguments passed on to 'gstat'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following components:
me, rme, mae, rmae, mse, rmse, rrmse, vecv and e1; or vecv only
</p>


<h3>Note</h3>

<p>This function is largely based on 'krigecv' in this package and
'Tps' and 'fastTpsMLE' in 'fields' package.
</p>


<h3>Author(s)</h3>

<p>Jin Li
</p>


<h3>References</h3>

<p>Douglas Nychka and Reinhard Furrer and John Paige and Stephan
Sain and Florian Gerber and Matthew Iverson, 2020. fields: Tools for
Spatial Data, R package version 10.3
https://CRAN.R-project.org/package=fields.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(fields)
library(spm)
data(petrel)

tpscv1 &lt;- tpscv(petrel[, c(1,2)], petrel[, 5], cv.fold = 5, predacc = "VEcv")
tpscv1

tpscv1 &lt;- tpscv(petrel[, c(1,2)], petrel[, 5], lambda = 0.9, cv.fold = 5, predacc = "VEcv")
tpscv1

tpscv1 &lt;- tpscv(petrel[, c(1,2)], petrel[, 5], validation = "LOO", predacc = "VEcv")
tpscv1

set.seed(1234)
n &lt;- 20 # number of iterations,60 to 100 is recommended.
VEcv &lt;- NULL
for (i in 1:n) {
tpscv1 &lt;- tpscv(petrel[, c(1,2)], petrel[, 5], cv.fold = 10,  lambda = 0.13, predacc = "VEcv")
VEcv [i] &lt;- tpscv1
}
plot(VEcv ~ c(1:n), xlab = "Iteration for TPS", ylab = "VEcv (%)")
points(cumsum(VEcv) / c(1:n) ~ c(1:n), col = 2)
abline(h = mean(VEcv), col = 'blue', lwd = 2)

n &lt;- 20 # number of iterations,60 to 100 is recommended.
# set.seed(1234)
VEcv &lt;- NULL
for (i in 1:n) {
set.seed(1234 + i) # set random seed for each iteration. You can remove
# this line and use above set.seed(1234) and see what you can get.
tpscv1 &lt;- tpscv(petrel[, c(1,2)], petrel[, 5], predacc = "VEcv")
VEcv [i] &lt;- tpscv1
}
plot(VEcv ~ c(1:n), xlab = "Iteration for TPS", ylab = "VEcv (%)")
points(cumsum(VEcv) / c(1:n) ~ c(1:n), col = 2)
abline(h = mean(VEcv), col = 'blue', lwd = 2)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
