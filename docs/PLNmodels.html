<!DOCTYPE html><html><head><title>Help for package PLNmodels</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {PLNmodels}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#%&gt;%'><p>Pipe operator</p></a></li>
<li><a href='#barents'><p>Barents fish data set</p></a></li>
<li><a href='#coef.PLNfit'><p>Extract model coefficients</p></a></li>
<li><a href='#coef.PLNLDAfit'><p>Extracts model coefficients from objects returned by <code>PLNLDA()</code></p></a></li>
<li><a href='#coef.PLNmixturefit'><p>Extract model coefficients</p></a></li>
<li><a href='#coef.ZIPLNfit'><p>Extract model coefficients</p></a></li>
<li><a href='#coefficient_path'><p>Extract the regularization path of a PLNnetwork fit</p></a></li>
<li><a href='#compute_offset'><p>Compute offsets from a count data using one of several normalization schemes</p></a></li>
<li><a href='#compute_PLN_starting_point'><p>Helper function for PLN initialization.</p></a></li>
<li><a href='#extract_probs'><p>Extract edge selection frequency in bootstrap subsamples</p></a></li>
<li><a href='#fitted.PLNfit'><p>Extracts model fitted values from objects returned by <code>PLN()</code> and its variants</p></a></li>
<li><a href='#fitted.PLNmixturefit'><p>Extracts model fitted values from objects returned by <code>PLNmixture()</code> and its variants</p></a></li>
<li><a href='#fitted.ZIPLNfit'><p>Extracts model fitted values from objects returned by <code>ZIPLN()</code> and its variants</p></a></li>
<li><a href='#getBestModel.PLNPCAfamily'><p>Best model extraction from a collection of models</p></a></li>
<li><a href='#getModel.PLNPCAfamily'><p>Model extraction from a collection of models</p></a></li>
<li><a href='#mollusk'><p>Mollusk data set</p></a></li>
<li><a href='#Networkfamily'><p>An R6 Class to virtually represent a collection of network fits</p></a></li>
<li><a href='#oaks'><p>Oaks amplicon data set</p></a></li>
<li><a href='#PLN'><p>Poisson lognormal model</p></a></li>
<li><a href='#PLN_param'><p>Control of a PLN fit</p></a></li>
<li><a href='#PLNfamily'><p>An R6 Class to represent a collection of PLNfit</p></a></li>
<li><a href='#PLNfit'><p>An R6 Class to represent a PLNfit in a standard, general framework</p></a></li>
<li><a href='#PLNfit_diagonal'><p>An R6 Class to represent a PLNfit in a standard, general framework, with diagonal residual covariance</p></a></li>
<li><a href='#PLNfit_fixedcov'><p>An R6 Class to represent a PLNfit in a standard, general framework, with fixed (inverse) residual covariance</p></a></li>
<li><a href='#PLNfit_spherical'><p>An R6 Class to represent a PLNfit in a standard, general framework, with spherical residual covariance</p></a></li>
<li><a href='#PLNLDA'><p>Poisson lognormal model towards Linear Discriminant Analysis</p></a></li>
<li><a href='#PLNLDA_param'><p>Control of a PLNLDA fit</p></a></li>
<li><a href='#PLNLDAfit'><p>An R6 Class to represent a PLNfit in a LDA framework</p></a></li>
<li><a href='#PLNLDAfit_diagonal'><p>An R6 Class to represent a PLNfit in a LDA framework with diagonal covariance</p></a></li>
<li><a href='#PLNmixture'><p>Poisson lognormal mixture model</p></a></li>
<li><a href='#PLNmixture_param'><p>Control of a PLNmixture fit</p></a></li>
<li><a href='#PLNmixturefamily'><p>An R6 Class to represent a collection of PLNmixturefit</p></a></li>
<li><a href='#PLNmixturefit'><p>An R6 Class to represent a PLNfit in a mixture framework</p></a></li>
<li><a href='#PLNmodels-package'><p>PLNmodels: Poisson Lognormal Models</p></a></li>
<li><a href='#PLNnetwork'><p>Sparse Poisson lognormal model for network inference</p></a></li>
<li><a href='#PLNnetwork_param'><p>Control of PLNnetwork fit</p></a></li>
<li><a href='#PLNnetworkfamily'><p>An R6 Class to represent a collection of <code>PLNnetworkfit</code>s</p></a></li>
<li><a href='#PLNnetworkfit'><p>An R6 Class to represent a PLNfit in a sparse inverse covariance framework</p></a></li>
<li><a href='#PLNPCA'><p>Poisson lognormal model towards Principal Component Analysis</p></a></li>
<li><a href='#PLNPCA_param'><p>Control of PLNPCA fit</p></a></li>
<li><a href='#PLNPCAfamily'><p>An R6 Class to represent a collection of PLNPCAfit</p></a></li>
<li><a href='#PLNPCAfit'><p>An R6 Class to represent a PLNfit in a PCA framework</p></a></li>
<li><a href='#plot.Networkfamily'><p>Display various outputs (goodness-of-fit criteria, robustness, diagnostic) associated with a collection of network fits (either <code>PLNnetworkfamily</code> or <code>ZIPLNnetworkfamily</code>)</p></a></li>
<li><a href='#plot.PLNfamily'><p>Display the criteria associated with a collection of PLN fits (a PLNfamily)</p></a></li>
<li><a href='#plot.PLNLDAfit'><p>LDA visualization (individual and/or variable factor map(s)) for a <code>PLNPCAfit</code> object</p></a></li>
<li><a href='#plot.PLNmixturefamily'><p>Display the criteria associated with a collection of PLNmixture fits (a PLNmixturefamily)</p></a></li>
<li><a href='#plot.PLNmixturefit'><p>Mixture visualization of a <code>PLNmixturefit</code> object</p></a></li>
<li><a href='#plot.PLNnetworkfit'><p>Extract and plot the network (partial correlation, support or inverse covariance) from a <code>PLNnetworkfit</code> object</p></a></li>
<li><a href='#plot.PLNPCAfamily'><p>Display the criteria associated with a collection of PLNPCA fits (a PLNPCAfamily)</p></a></li>
<li><a href='#plot.PLNPCAfit'><p>PCA visualization (individual and/or variable factor map(s)) for a <code>PLNPCAfit</code> object</p></a></li>
<li><a href='#plot.ZIPLNfit_sparse'><p>Extract and plot the network (partial correlation, support or inverse covariance) from a <code>ZIPLNfit_sparse</code> object</p></a></li>
<li><a href='#predict_cond'><p>Predict counts conditionally</p></a></li>
<li><a href='#predict.PLNfit'><p>Predict counts of a new sample</p></a></li>
<li><a href='#predict.PLNLDAfit'><p>Predict group of new samples</p></a></li>
<li><a href='#predict.PLNmixturefit'><p>Prediction for a <code>PLNmixturefit</code> object</p></a></li>
<li><a href='#predict.ZIPLNfit'><p>Predict counts of a new sample</p></a></li>
<li><a href='#prepare_data'><p>Prepare data for use in PLN models</p></a></li>
<li><a href='#rPLN'><p>PLN RNG</p></a></li>
<li><a href='#scRNA'><p>Single cell RNA-seq data</p></a></li>
<li><a href='#sigma.PLNfit'><p>Extract variance-covariance of residuals 'Sigma'</p></a></li>
<li><a href='#sigma.PLNmixturefit'><p>Extract variance-covariance of residuals 'Sigma'</p></a></li>
<li><a href='#sigma.ZIPLNfit'><p>Extract variance-covariance of residuals 'Sigma'</p></a></li>
<li><a href='#stability_selection'><p>Compute the stability path by stability selection</p></a></li>
<li><a href='#standard_error.PLNPCAfit'><p>Component-wise standard errors of B</p></a></li>
<li><a href='#trichoptera'><p>Trichoptera data set</p></a></li>
<li><a href='#vcov.PLNfit'><p>Calculate Variance-Covariance Matrix for a fitted <code>PLN()</code> model object</p></a></li>
<li><a href='#ZIPLN'><p>Zero Inflated Poisson lognormal model</p></a></li>
<li><a href='#ZIPLN_param'><p>Control of a ZIPLN fit</p></a></li>
<li><a href='#ZIPLNfit'><p>An R6 Class to represent a ZIPLNfit</p></a></li>
<li><a href='#ZIPLNfit_diagonal'><p>An R6 Class to represent a ZIPLNfit in a standard, general framework, with diagonal residual covariance</p></a></li>
<li><a href='#ZIPLNfit_fixed'><p>An R6 Class to represent a ZIPLNfit in a standard, general framework, with fixed (inverse) residual covariance</p></a></li>
<li><a href='#ZIPLNfit_sparse'><p>An R6 Class to represent a ZIPLNfit in a standard, general framework, with sparse inverse residual covariance</p></a></li>
<li><a href='#ZIPLNfit_spherical'><p>An R6 Class to represent a ZIPLNfit in a standard, general framework, with spherical residual covariance</p></a></li>
<li><a href='#ZIPLNnetwork'><p>Zero Inflated Sparse Poisson lognormal model for network inference</p></a></li>
<li><a href='#ZIPLNnetwork_param'><p>Control of ZIPLNnetwork fit</p></a></li>
<li><a href='#ZIPLNnetworkfamily'><p>An R6 Class to represent a collection of ZIPLNnetwork</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Poisson Lognormal Models</td>
</tr>
<tr>
<td>Version:</td>
<td>1.2.0</td>
</tr>
<tr>
<td>Description:</td>
<td>The Poisson-lognormal model and variants (Chiquet, Mariadassou and Robin, 
    2021 &lt;<a href="https://doi.org/10.3389%2Ffevo.2021.588292">doi:10.3389/fevo.2021.588292</a>&gt;) can be used for 
    a variety of multivariate problems when count data are at play, including 
    principal component analysis for count data, discriminant analysis, model-based clustering and 
    network inference. Implements variational algorithms to fit such models accompanied with a set of 
    functions for visualization and diagnostic. </td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://pln-team.github.io/PLNmodels/">https://pln-team.github.io/PLNmodels/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/pln-team/PLNmodels/issues">https://github.com/pln-team/PLNmodels/issues</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.4)</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Imports:</td>
<td>methods, stats, MASS, future, future.apply, R6, glassoFast,
pscl, Matrix, Rcpp, nloptr, igraph, grid, gridExtra, dplyr,
tidyr, purrr, ggplot2, corrplot, magrittr, torch, rlang</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, testthat, pkgdown, spelling, factoextra</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo, nloptr</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Collate:</td>
<td>'PLNfit-class.R' 'PLN.R' 'PLNLDA.R' 'PLNLDAfit-S3methods.R'
'PLNLDAfit-class.R' 'PLNPCA.R' 'PLNPCAfamily-S3methods.R'
'PLNfamily-class.R' 'PLNPCAfamily-class.R'
'PLNPCAfit-S3methods.R' 'PLNPCAfit-class.R'
'PLNfamily-S3methods.R' 'PLNfit-S3methods.R' 'PLNmixture.R'
'PLNmixturefamily-S3methods.R' 'PLNmixturefamily-class.R'
'PLNmixturefit-S3methods.R' 'PLNmixturefit-class.R'
'PLNmodels-package.R' 'PLNnetwork.R'
'PLNnetworkfamily-S3methods.R' 'PLNnetworkfamily-class.R'
'PLNnetworkfit-S3methods.R' 'PLNnetworkfit-class.R'
'RcppExports.R' 'ZIPLNfit-class.R' 'ZIPLN.R'
'ZIPLNfit-S3methods.R' 'ZIPLNnetwork.R' 'barents.R'
'import_utils.R' 'mollusk.R' 'oaks.R' 'plot_utils.R' 'scRNA.R'
'trichoptera.R' 'utils-pipe.R' 'utils-zipln.R' 'utils.R'
'zzz.R'</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-03-05 15:19:47 UTC; jchiquet</td>
</tr>
<tr>
<td>Author:</td>
<td>Julien Chiquet <a href="https://orcid.org/0000-0002-3629-3429"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Mahendra Mariadassou
    <a href="https://orcid.org/0000-0003-2986-354X"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  Stéphane Robin [aut],
  François Gindraud [aut],
  Julie Aubert [ctb],
  Bastien Batardière [ctb],
  Giovanni Poggiato [ctb],
  Cole Trapnell [ctb],
  Maddy Duran [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Julien Chiquet &lt;julien.chiquet@inrae.fr&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-03-05 15:50:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='+25+26gt+3B+25'>Pipe operator</h2><span id='topic++25+3E+25'></span>

<h3>Description</h3>

<p>See <code>magrittr::<a href="magrittr.html#topic+pipe">%&gt;%</a></code> for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lhs %&gt;% rhs
</code></pre>

<hr>
<h2 id='barents'>Barents fish data set</h2><span id='topic+barents'></span>

<h3>Description</h3>

<p>This data set gives the abundance of 30 fish species observed in 89 sites in the Barents sea.
For each site, 4 additional covariates are known. Subsample of the original datasets studied by Fossheim et al, 2006.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>barents
</code></pre>


<h3>Format</h3>

<p>A data frame with 6 variables:
</p>

<ul>
<li><p> Abundance: A 30 fish species by 89 sites count matrix
</p>
</li>
<li><p> Offset: A 30 fish species by 116 samples offset matrix, measuring the sampling effort in each site
</p>
</li>
<li><p> 4 covariates for latitude, longitude, depth (in meters), temperature (in Celsius degrees).
</p>
</li></ul>



<h3>Source</h3>

<p>Data from M. Fossheim and coauthors.
</p>


<h3>References</h3>

<p>Fossheim, Maria, Einar M. Nilssen, and Michaela Aschan. &quot;Fish assemblages in the Barents Sea.&quot; Marine Biology Research 2.4 (2006). <a href="https://doi.org/10.1080/17451000600815698">doi:10.1080/17451000600815698</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(barents)
</code></pre>

<hr>
<h2 id='coef.PLNfit'>Extract model coefficients</h2><span id='topic+coef.PLNfit'></span>

<h3>Description</h3>

<p>Extracts model coefficients from objects returned by <code><a href="#topic+PLN">PLN()</a></code> and its variants
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'PLNfit'
coef(object, type = c("main", "covariance"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coef.PLNfit_+3A_object">object</code></td>
<td>
<p>an R6 object with class <code><a href="#topic+PLNfit">PLNfit</a></code></p>
</td></tr>
<tr><td><code id="coef.PLNfit_+3A_type">type</code></td>
<td>
<p>type of parameter that should be extracted. Either &quot;main&quot; (default) for </p>
<p style="text-align: center;"><code class="reqn">B</code>
</p>
<p> or &quot;covariance&quot; for </p>
<p style="text-align: center;"><code class="reqn">\Sigma</code>
</p>
</td></tr>
<tr><td><code id="coef.PLNfit_+3A_...">...</code></td>
<td>
<p>additional parameters for S3 compatibility. Not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of coefficients extracted from the PLNfit model.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sigma.PLNfit">sigma.PLNfit()</a></code>, <code><a href="#topic+vcov.PLNfit">vcov.PLNfit()</a></code>, <code><a href="#topic+standard_error.PLNfit">standard_error.PLNfit()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(trichoptera)
trichoptera &lt;- prepare_data(trichoptera$Abundance, trichoptera$Covariate)
myPLN &lt;- PLN(Abundance ~ 1 + offset(log(Offset)), data = trichoptera)
coef(myPLN) ## B
coef(myPLN, type = "covariance") ## Sigma
</code></pre>

<hr>
<h2 id='coef.PLNLDAfit'>Extracts model coefficients from objects returned by <code><a href="#topic+PLNLDA">PLNLDA()</a></code></h2><span id='topic+coef.PLNLDAfit'></span>

<h3>Description</h3>

<p>The method for objects returned by <code><a href="#topic+PLNLDA">PLNLDA()</a></code> only returns
coefficients associated to the </p>
<p style="text-align: center;"><code class="reqn">\Theta</code>
</p>
<p> part of the model (see the PLNLDA vignette
for mathematical details).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'PLNLDAfit'
coef(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coef.PLNLDAfit_+3A_object">object</code></td>
<td>
<p>an R6 object with class PLNLDAfit</p>
</td></tr>
<tr><td><code id="coef.PLNLDAfit_+3A_...">...</code></td>
<td>
<p>additional parameters for S3 compatibility. Not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Either NULL or a matrix of coefficients extracted from the PLNLDAfit model.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(trichoptera)
trichoptera &lt;- prepare_data(trichoptera$Abundance, trichoptera$Covariate)
myPLNLDA &lt;- PLNLDA(Abundance ~ Wind, grouping = Group, data = trichoptera)
coef(myPLNLDA)
</code></pre>

<hr>
<h2 id='coef.PLNmixturefit'>Extract model coefficients</h2><span id='topic+coef.PLNmixturefit'></span>

<h3>Description</h3>

<p>Extracts model coefficients from objects returned by <code><a href="#topic+PLN">PLN()</a></code> and its variants
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'PLNmixturefit'
coef(object, type = c("main", "means", "covariance", "mixture"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coef.PLNmixturefit_+3A_object">object</code></td>
<td>
<p>an R6 object with class <code><a href="#topic+PLNmixturefit">PLNmixturefit</a></code></p>
</td></tr>
<tr><td><code id="coef.PLNmixturefit_+3A_type">type</code></td>
<td>
<p>type of parameter that should be extracted. Either &quot;main&quot; (default) for </p>
<p style="text-align: center;"><code class="reqn">\Theta</code>
</p>
<p>,
&quot;means&quot; for </p>
<p style="text-align: center;"><code class="reqn">\mu</code>
</p>
<p>, &quot;mixture&quot; for </p>
<p style="text-align: center;"><code class="reqn">\pi</code>
</p>
<p> or &quot;covariance&quot; for </p>
<p style="text-align: center;"><code class="reqn">\Sigma</code>
</p>
</td></tr>
<tr><td><code id="coef.PLNmixturefit_+3A_...">...</code></td>
<td>
<p>additional parameters for S3 compatibility. Not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of coefficients extracted from the PLNfit model.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sigma.PLNmixturefit">sigma.PLNmixturefit()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(trichoptera)
trichoptera &lt;- prepare_data(trichoptera$Abundance, trichoptera$Covariate)
myPLN &lt;- PLNmixture(Abundance ~ 1 + offset(log(Offset)),
           data = trichoptera, control = PLNmixture_param(smoothing = "none"))  %&gt;% getBestModel()
coef(myPLN) ## Theta - empty here
coef(myPLN, type = "mixture") ## pi
coef(myPLN, type = "means") ## mu
coef(myPLN, type = "covariance") ## Sigma
</code></pre>

<hr>
<h2 id='coef.ZIPLNfit'>Extract model coefficients</h2><span id='topic+coef.ZIPLNfit'></span>

<h3>Description</h3>

<p>Extracts model coefficients from objects returned by <code><a href="#topic+ZIPLN">ZIPLN()</a></code> and its variants
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ZIPLNfit'
coef(object, type = c("count", "zero", "precision", "covariance"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coef.ZIPLNfit_+3A_object">object</code></td>
<td>
<p>an R6 object with class <code><a href="#topic+ZIPLNfit">ZIPLNfit</a></code></p>
</td></tr>
<tr><td><code id="coef.ZIPLNfit_+3A_type">type</code></td>
<td>
<p>type of parameter that should be extracted. Either &quot;count&quot; (default) for <code class="reqn">B</code>,
&quot;zero&quot; for <code class="reqn">B0</code>, &quot;precision&quot; for <code class="reqn">\Omega</code>, &quot;covariance&quot; for <code class="reqn">\Sigma</code></p>
</td></tr>
<tr><td><code id="coef.ZIPLNfit_+3A_...">...</code></td>
<td>
<p>additional parameters for S3 compatibility. Not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of coefficients extracted from the ZIPLNfit model.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sigma.ZIPLNfit">sigma.ZIPLNfit()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(scRNA)
# data subsample: only 100 random cell and the 50 most varying transcript
subset &lt;- sample.int(nrow(scRNA), 100)
myPLN  &lt;- ZIPLN(counts[, 1:50] ~ 1 + offset(log(total_counts)), subset = subset, data = scRNA)

</code></pre>

<hr>
<h2 id='coefficient_path'>Extract the regularization path of a PLNnetwork fit</h2><span id='topic+coefficient_path'></span>

<h3>Description</h3>

<p>Extract the regularization path of a PLNnetwork fit
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coefficient_path(Robject, precision = TRUE, corr = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coefficient_path_+3A_robject">Robject</code></td>
<td>
<p>an object with class <code><a href="#topic+Networkfamily">Networkfamily</a></code>, i.e. an output from <code><a href="#topic+PLNnetwork">PLNnetwork()</a></code></p>
</td></tr>
<tr><td><code id="coefficient_path_+3A_precision">precision</code></td>
<td>
<p>a logical, should the coefficients of the precision matrix Omega or the covariance matrix Sigma be sent back. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="coefficient_path_+3A_corr">corr</code></td>
<td>
<p>a logical, should the correlation (partial in case  <code>precision = TRUE</code>) be sent back. Default is <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Sends back a tibble/data.frame.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(trichoptera)
trichoptera &lt;- prepare_data(trichoptera$Abundance, trichoptera$Covariate)
fits &lt;- PLNnetwork(Abundance ~ 1, data = trichoptera)
head(coefficient_path(fits))
</code></pre>

<hr>
<h2 id='compute_offset'>Compute offsets from a count data using one of several normalization schemes</h2><span id='topic+compute_offset'></span>

<h3>Description</h3>

<p>Computes offsets from the count table using one of several normalization schemes (TSS, CSS, RLE, GMPR, Wrench, TMM, etc) described in the literature.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_offset(
  counts,
  offset = c("TSS", "GMPR", "RLE", "CSS", "Wrench", "TMM", "none"),
  scale = c("none", "count"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute_offset_+3A_counts">counts</code></td>
<td>
<p>Required. An abundance count table, preferably with dimensions names and species as columns.</p>
</td></tr>
<tr><td><code id="compute_offset_+3A_offset">offset</code></td>
<td>
<p>Optional. Normalization scheme used to compute scaling factors used as offset during PLN inference. Available schemes are &quot;TSS&quot; (Total Sum Scaling, default), &quot;CSS&quot; (Cumulative Sum Scaling, used in metagenomeSeq), &quot;RLE&quot; (Relative Log Expression, used in DESeq2), &quot;GMPR&quot; (Geometric Mean of Pairwise Ratio, introduced in Chen et al., 2018), Wrench (introduced in Kumar et al., 2018) or &quot;none&quot;. Alternatively the user can supply its own vector or matrix of offsets (see note for specification of the user-supplied offsets).</p>
</td></tr>
<tr><td><code id="compute_offset_+3A_scale">scale</code></td>
<td>
<p>Either <code>"none"</code> (default) or <code>"count"</code>. Should the offset be normalized to be on the same scale as the counts ?</p>
</td></tr>
<tr><td><code id="compute_offset_+3A_...">...</code></td>
<td>
<p>Additional parameters passed on to specific methods (for now CSS and RLE)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>RLE has additional <code>pseudocounts</code> and <code>type</code> arguments to add pseudocounts to the observed counts (defaults to 0L) and to compute offsets using only positive counts (if <code>type == "poscounts"</code>). This mimics the behavior of <code>DESeq2::DESeq()</code> when using <code>sfType == "poscounts"</code>. CSS has an additional <code>reference</code> argument to choose the location function used to compute the reference quantiles (defaults to <code>median</code> as in the Nature publication but can be set to <code>mean</code> to reproduce behavior of functions cumNormStat* from metagenomeSeq). Wrench has two additional parameters: <code>groups</code> to specify sample groups and <code>type</code> to either reproduce exactly the default <code>Wrench::wrench()</code> behavior (<code>type = "wrench"</code>, default) or to use simpler heuristics (<code>type = "simple"</code>). Note that (i) CSS normalization fails when the median absolute deviation around quantiles does not become instable for high quantiles (limited count variations both within and across samples) and/or one sample has less than two positive counts, (ii) RLE fails when there are no common species across all samples (unless <code>type == "poscounts"</code> has been specified) and (iii) GMPR fails if a sample does not share any species with all other samples.
TMM code between two libraries is simplified and adapted from M. Robinson (edgeR:::.calcFactorTMM).
The final output is however different from the one produced by edgeR:::.calcFactorTMM as they are intended
to be used as such in the model (whereas they need to be multiplied by sequencing depths in edgeR)
</p>


<h3>Value</h3>

<p>If <code>offset = "none"</code>, <code>NULL</code> else a vector of length <code>nrow(counts)</code> with one offset per sample.
</p>


<h3>References</h3>

<p>Chen, L., Reeve, J., Zhang, L., Huang, S., Wang, X. and Chen, J. (2018) GMPR: A robust normalization method for zero-inflated count data with application to microbiome sequencing data. PeerJ, 6, e4600 <a href="https://doi.org/10.7717/peerj.4600">doi:10.7717/peerj.4600</a>
</p>
<p>Paulson, J. N., Colin Stine, O., Bravo, H. C. and Pop, M. (2013) Differential abundance analysis for microbial marker-gene surveys. Nature Methods, 10, 1200-1202 <a href="https://doi.org/10.1038/nmeth.2658">doi:10.1038/nmeth.2658</a>
</p>
<p>Anders, S. and Huber, W. (2010) Differential expression analysis for sequence count data. Genome Biology, 11, R106 <a href="https://doi.org/10.1186/gb-2010-11-10-r106">doi:10.1186/gb-2010-11-10-r106</a>
</p>
<p>Kumar, M., Slud, E., Okrah, K. et al. (2018) Analysis and correction of compositional bias in sparse sequencing count data. BMC Genomics 19, 799 <a href="https://doi.org/10.1186/s12864-018-5160-5">doi:10.1186/s12864-018-5160-5</a>
</p>
<p>Robinson, M.D., Oshlack, A. (2010) A scaling normalization method for differential expression analysis of RNA-seq data. Genome Biol 11, R25 <a href="https://doi.org/10.1186/gb-2010-11-3-r25">doi:10.1186/gb-2010-11-3-r25</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(trichoptera)
counts &lt;- trichoptera$Abundance
compute_offset(counts)
## Other normalization schemes
compute_offset(counts, offset = "RLE", pseudocounts = 1)
compute_offset(counts, offset = "Wrench", groups = trichoptera$Covariate$Group)
compute_offset(counts, offset = "GMPR")
compute_offset(counts, offset = "TMM")
## User supplied offsets
my_offset &lt;- setNames(rep(1, nrow(counts)), rownames(counts))
compute_offset(counts, offset = my_offset)
</code></pre>

<hr>
<h2 id='compute_PLN_starting_point'>Helper function for PLN initialization.</h2><span id='topic+compute_PLN_starting_point'></span>

<h3>Description</h3>

<p>Barebone function to compute starting points for B, M and S when fitting a PLN. Mostly intended for internal use.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_PLN_starting_point(Y, X, O, w, s = 0.1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute_PLN_starting_point_+3A_y">Y</code></td>
<td>
<p>Response count matrix</p>
</td></tr>
<tr><td><code id="compute_PLN_starting_point_+3A_x">X</code></td>
<td>
<p>Covariate matrix</p>
</td></tr>
<tr><td><code id="compute_PLN_starting_point_+3A_o">O</code></td>
<td>
<p>Offset matrix (in log-scale)</p>
</td></tr>
<tr><td><code id="compute_PLN_starting_point_+3A_w">w</code></td>
<td>
<p>Weight vector (defaults to 1)</p>
</td></tr>
<tr><td><code id="compute_PLN_starting_point_+3A_s">s</code></td>
<td>
<p>Scale parameter for S (defaults to 0.1)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The default strategy to estimate B and M is to fit a linear model with covariates <code>X</code> to the response count matrix (after adding a pseudocount of 1, scaling by the offset and taking the log). The regression matrix is used to initialize <code>B</code> and the residuals to initialize <code>M</code>. <code>S</code> is initialized as a constant conformable matrix with value <code>s</code>.
</p>


<h3>Value</h3>

<p>a named list of starting values for model parameter B and variational parameters M and S used in the iterative optimization algorithm of <code><a href="#topic+PLN">PLN()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(barents)
Y &lt;- barents$Abundance
X &lt;- model.matrix(Abundance ~ Latitude + Longitude + Depth + Temperature, data = barents)
O &lt;- log(barents$Offset)
w &lt;-- rep(1, nrow(Y))
compute_PLN_starting_point(Y, X, O, w)

## End(Not run)

</code></pre>

<hr>
<h2 id='extract_probs'>Extract edge selection frequency in bootstrap subsamples</h2><span id='topic+extract_probs'></span>

<h3>Description</h3>

<p>Extracts edge selection frequency in networks reconstructed from bootstrap subsamples
during the stars stability selection procedure, as either a matrix or a named vector. In the latter
case, edge names follow igraph naming convention.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract_probs(
  Robject,
  penalty = NULL,
  index = NULL,
  crit = c("StARS", "BIC", "EBIC"),
  format = c("matrix", "vector"),
  tol = 1e-05
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extract_probs_+3A_robject">Robject</code></td>
<td>
<p>an object with class <code><a href="#topic+PLNnetworkfamily">PLNnetworkfamily</a></code>, i.e. an output from <code><a href="#topic+PLNnetwork">PLNnetwork()</a></code></p>
</td></tr>
<tr><td><code id="extract_probs_+3A_penalty">penalty</code></td>
<td>
<p>penalty used for the bootstrap subsamples</p>
</td></tr>
<tr><td><code id="extract_probs_+3A_index">index</code></td>
<td>
<p>Integer index of the model to be returned. Only the first value is taken into account.</p>
</td></tr>
<tr><td><code id="extract_probs_+3A_crit">crit</code></td>
<td>
<p>a character for the criterion used to performed the selection. Either
&quot;BIC&quot;, &quot;ICL&quot;, &quot;EBIC&quot;, &quot;StARS&quot;, &quot;R_squared&quot;. Default is <code>ICL</code> for <code>PLNPCA</code>, and <code>BIC</code> for <code>PLNnetwork</code>.
If StARS (Stability Approach to Regularization Selection) is chosen and stability selection
was not yet performed, the function will call the method <code><a href="#topic+stability_selection">stability_selection()</a></code> with default argument.</p>
</td></tr>
<tr><td><code id="extract_probs_+3A_format">format</code></td>
<td>
<p>output format. Either a matrix (default) or a named vector.</p>
</td></tr>
<tr><td><code id="extract_probs_+3A_tol">tol</code></td>
<td>
<p>tolerance for rounding error when comparing penalties.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Either a matrix or named vector of edge-wise probabilities. In the latter case, edge names follow igraph convention.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(trichoptera)
trichoptera &lt;- prepare_data(trichoptera$Abundance, trichoptera$Covariate)
nets &lt;- PLNnetwork(Abundance ~ 1 + offset(log(Offset)), data = trichoptera)
## Not run: 
stability_selection(nets)
probs &lt;- extract_probs(nets, crit = "StARS", format = "vector")
probs

## End(Not run)

## Not run: 
## Add edge attributes to graph using igraph
net_stars &lt;- getBestModel(nets, "StARS")
g &lt;- plot(net_stars, type = "partial_cor", plot=F)
library(igraph)
E(g)$prob &lt;- probs[as_ids(E(g))]
g

## End(Not run)

</code></pre>

<hr>
<h2 id='fitted.PLNfit'>Extracts model fitted values from objects returned by <code><a href="#topic+PLN">PLN()</a></code> and its variants</h2><span id='topic+fitted.PLNfit'></span>

<h3>Description</h3>

<p>Extracts model fitted values from objects returned by <code><a href="#topic+PLN">PLN()</a></code> and its variants
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'PLNfit'
fitted(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitted.PLNfit_+3A_object">object</code></td>
<td>
<p>an R6 object with class <code><a href="#topic+PLNfit">PLNfit</a></code></p>
</td></tr>
<tr><td><code id="fitted.PLNfit_+3A_...">...</code></td>
<td>
<p>additional parameters for S3 compatibility. Not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of Fitted values extracted from the object object.
</p>

<hr>
<h2 id='fitted.PLNmixturefit'>Extracts model fitted values from objects returned by <code><a href="#topic+PLNmixture">PLNmixture()</a></code> and its variants</h2><span id='topic+fitted.PLNmixturefit'></span>

<h3>Description</h3>

<p>Extracts model fitted values from objects returned by <code><a href="#topic+PLNmixture">PLNmixture()</a></code> and its variants
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'PLNmixturefit'
fitted(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitted.PLNmixturefit_+3A_object">object</code></td>
<td>
<p>an R6 object with class <code><a href="#topic+PLNmixturefit">PLNmixturefit</a></code></p>
</td></tr>
<tr><td><code id="fitted.PLNmixturefit_+3A_...">...</code></td>
<td>
<p>additional parameters for S3 compatibility. Not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of Fitted values extracted from the object object.
</p>

<hr>
<h2 id='fitted.ZIPLNfit'>Extracts model fitted values from objects returned by <code><a href="#topic+ZIPLN">ZIPLN()</a></code> and its variants</h2><span id='topic+fitted.ZIPLNfit'></span>

<h3>Description</h3>

<p>Extracts model fitted values from objects returned by <code><a href="#topic+ZIPLN">ZIPLN()</a></code> and its variants
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ZIPLNfit'
fitted(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitted.ZIPLNfit_+3A_object">object</code></td>
<td>
<p>an R6 object with class <code><a href="#topic+ZIPLNfit">ZIPLNfit</a></code></p>
</td></tr>
<tr><td><code id="fitted.ZIPLNfit_+3A_...">...</code></td>
<td>
<p>additional parameters for S3 compatibility. Not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of Fitted values extracted from the object object.
</p>

<hr>
<h2 id='getBestModel.PLNPCAfamily'>Best model extraction from a collection of models</h2><span id='topic+getBestModel.PLNPCAfamily'></span><span id='topic+getBestModel'></span><span id='topic+getBestModel.PLNmixturefamily'></span><span id='topic+getBestModel.Networkfamily'></span><span id='topic+getBestModel.PLNnetworkfamily'></span><span id='topic+getBestModel.ZIPLNnetworkfamily'></span>

<h3>Description</h3>

<p>Best model extraction from a collection of models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'PLNPCAfamily'
getBestModel(Robject, crit = c("ICL", "BIC"), ...)

getBestModel(Robject, crit, ...)

## S3 method for class 'PLNmixturefamily'
getBestModel(Robject, crit = c("ICL", "BIC"), ...)

## S3 method for class 'Networkfamily'
getBestModel(Robject, crit = c("BIC", "EBIC", "StARS"), ...)

## S3 method for class 'PLNnetworkfamily'
getBestModel(Robject, crit = c("BIC", "EBIC", "StARS"), ...)

## S3 method for class 'ZIPLNnetworkfamily'
getBestModel(Robject, crit = c("BIC", "EBIC", "StARS"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getBestModel.PLNPCAfamily_+3A_robject">Robject</code></td>
<td>
<p>an object with class PLNPCAfamilly ot PLNnetworkfamily</p>
</td></tr>
<tr><td><code id="getBestModel.PLNPCAfamily_+3A_crit">crit</code></td>
<td>
<p>a character for the criterion used to performed the selection. Either
&quot;BIC&quot;, &quot;ICL&quot;, &quot;EBIC&quot;, &quot;StARS&quot;, &quot;R_squared&quot;. Default is <code>ICL</code> for <code>PLNPCA</code>, and <code>BIC</code> for <code>PLNnetwork</code>.
If StARS (Stability Approach to Regularization Selection) is chosen and stability selection
was not yet performed, the function will call the method <code><a href="#topic+stability_selection">stability_selection()</a></code> with default argument.</p>
</td></tr>
<tr><td><code id="getBestModel.PLNPCAfamily_+3A_...">...</code></td>
<td>
<p>additional parameters for StARS criterion (only for <code>PLNnetwork</code>). <code>stability</code>, a scalar indicating the target stability (= 1 - 2 beta) at which the network is selected. Default is <code>0.9</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Send back an object with class <code><a href="#topic+PLNPCAfit">PLNPCAfit</a></code> or <code><a href="#topic+PLNnetworkfit">PLNnetworkfit</a></code>
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>getBestModel(PLNPCAfamily)</code>: Model extraction for <code><a href="#topic+PLNPCAfamily">PLNPCAfamily</a></code>
</p>
</li>
<li> <p><code>getBestModel(PLNmixturefamily)</code>: Model extraction for <code><a href="#topic+PLNmixturefamily">PLNmixturefamily</a></code>
</p>
</li>
<li> <p><code>getBestModel(Networkfamily)</code>: Model extraction for <code><a href="#topic+PLNnetworkfamily">PLNnetworkfamily</a></code> or <code><a href="#topic+ZIPLNnetworkfamily">ZIPLNnetworkfamily</a></code>
</p>
</li>
<li> <p><code>getBestModel(PLNnetworkfamily)</code>: Model extraction for <code><a href="#topic+PLNnetworkfamily">PLNnetworkfamily</a></code>
</p>
</li>
<li> <p><code>getBestModel(ZIPLNnetworkfamily)</code>: Model extraction for <code><a href="#topic+ZIPLNnetworkfamily">ZIPLNnetworkfamily</a></code>
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(trichoptera)
trichoptera &lt;- prepare_data(trichoptera$Abundance, trichoptera$Covariate)
myPCA &lt;- PLNPCA(Abundance ~ 1 + offset(log(Offset)), data = trichoptera, ranks = 1:4)
myModel &lt;- getBestModel(myPCA)

## End(Not run)
</code></pre>

<hr>
<h2 id='getModel.PLNPCAfamily'>Model extraction from a collection of models</h2><span id='topic+getModel.PLNPCAfamily'></span><span id='topic+getModel'></span><span id='topic+getModel.PLNmixturefamily'></span><span id='topic+getModel.Networkfamily'></span><span id='topic+getModel.PLNnetworkfamily'></span><span id='topic+getModel.ZIPLNnetworkfamily'></span>

<h3>Description</h3>

<p>Model extraction from a collection of models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'PLNPCAfamily'
getModel(Robject, var, index = NULL)

getModel(Robject, var, index)

## S3 method for class 'PLNmixturefamily'
getModel(Robject, var, index = NULL)

## S3 method for class 'Networkfamily'
getModel(Robject, var, index = NULL)

## S3 method for class 'PLNnetworkfamily'
getModel(Robject, var, index = NULL)

## S3 method for class 'ZIPLNnetworkfamily'
getModel(Robject, var, index = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getModel.PLNPCAfamily_+3A_robject">Robject</code></td>
<td>
<p>an R6 object with class <code><a href="#topic+PLNPCAfamily">PLNPCAfamily</a></code> or <code><a href="#topic+PLNnetworkfamily">PLNnetworkfamily</a></code></p>
</td></tr>
<tr><td><code id="getModel.PLNPCAfamily_+3A_var">var</code></td>
<td>
<p>value of the parameter (<code>rank</code> for PLNPCA, <code>sparsity</code> for PLNnetwork) that identifies the model to be extracted from the collection. If no exact match is found, the model with closest parameter value is returned with a warning.</p>
</td></tr>
<tr><td><code id="getModel.PLNPCAfamily_+3A_index">index</code></td>
<td>
<p>Integer index of the model to be returned. Only the first value is taken into account.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Sends back an object with class <code><a href="#topic+PLNPCAfit">PLNPCAfit</a></code> or <code><a href="#topic+PLNnetworkfit">PLNnetworkfit</a></code>.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>getModel(PLNPCAfamily)</code>: Model extraction for <code><a href="#topic+PLNPCAfamily">PLNPCAfamily</a></code>
</p>
</li>
<li> <p><code>getModel(PLNmixturefamily)</code>: Model extraction for <code><a href="#topic+PLNmixturefamily">PLNmixturefamily</a></code>
</p>
</li>
<li> <p><code>getModel(Networkfamily)</code>: Model extraction for <code><a href="#topic+PLNnetworkfamily">PLNnetworkfamily</a></code> or <code><a href="#topic+ZIPLNnetworkfamily">ZIPLNnetworkfamily</a></code>
</p>
</li>
<li> <p><code>getModel(PLNnetworkfamily)</code>: Model extraction for <code><a href="#topic+PLNnetworkfamily">PLNnetworkfamily</a></code>
</p>
</li>
<li> <p><code>getModel(ZIPLNnetworkfamily)</code>: Model extraction for <code><a href="#topic+ZIPLNnetworkfamily">ZIPLNnetworkfamily</a></code>
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(trichoptera)
trichoptera &lt;- prepare_data(trichoptera$Abundance, trichoptera$Covariate)
myPCA &lt;- PLNPCA(Abundance ~ 1 + offset(log(Offset)), data = trichoptera, ranks = 1:5)
myModel &lt;- getModel(myPCA, 2)

## End(Not run)
</code></pre>

<hr>
<h2 id='mollusk'>Mollusk data set</h2><span id='topic+mollusk'></span>

<h3>Description</h3>

<p>This data set gives the abundance of 32 mollusk species in 163 samples.
For each sample, 4 additional covariates are known.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mollusk
</code></pre>


<h3>Format</h3>

<p>A list with 2 two data frames:
</p>

<dl>
<dt>Abundance</dt><dd><p>a 163 x 32 data frame of abundancies/counts (163 samples and 32 mollusk species)</p>
</dd>
<dt>Covariate</dt><dd><p>a 163 x 4 data frame of covariates:
</p>

<dl>
<dt>site</dt><dd><p>a factor with 8 levels indicating the sampling site</p>
</dd>
<dt>season</dt><dd><p>a factor with 4 levels indicating the season</p>
</dd>
<dt>method</dt><dd><p>a factor with 2 levels for the method of sampling - wood or string</p>
</dd>
<dt>duration</dt><dd><p>a numeric with 3 levels for the time of exposure in week</p>
</dd>
</dl>

</dd>
</dl>

<p>In order to prepare the data for using formula in multivariate analysis (multiple outputs and inputs), use <code><a href="#topic+prepare_data">prepare_data()</a></code>.
Original data set has been extracted from ade4.
</p>


<h3>Source</h3>

<p>Data from Richardot-Coulet, Chessel and Bournaud.
</p>


<h3>References</h3>

<p>Richardot-Coulet, M., Chessel D. and Bournaud M. (1986) Typological value of the benthos of old beds of a large river. Methodological approach. Archiv fùr Hydrobiologie, 107, 363–383.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+prepare_data">prepare_data()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(mollusk)
mollusc &lt;- prepare_data(mollusk$Abundance, mollusk$Covariate)
</code></pre>

<hr>
<h2 id='Networkfamily'>An R6 Class to virtually represent a collection of network fits</h2><span id='topic+Networkfamily'></span>

<h3>Description</h3>

<p>The functions <code><a href="#topic+PLNnetwork">PLNnetwork()</a></code> and <code><a href="#topic+ZIPLNnetwork">ZIPLNnetwork()</a></code> both produce an instance of this class, which can be thought of as a vector of <code><a href="#topic+PLNnetworkfit">PLNnetworkfit</a></code>s <code><a href="#topic+ZIPLNfit_sparse">ZIPLNfit_sparse</a></code>s (indexed by penalty parameter)
</p>
<p>This class comes with a set of methods mostly used to compare
network fits (in terms of goodness of fit) or extract one from
the family (based on penalty parameter and/or goodness of it).
See the documentation for <code><a href="#topic+getBestModel">getBestModel()</a></code>,
<code><a href="#topic+getModel">getModel()</a></code> and <a href="#topic+plot.Networkfamily">plot()</a> for the user-facing ones.
</p>


<h3>Super class</h3>

<p><code><a href="#topic+PLNfamily">PLNmodels::PLNfamily</a></code> -&gt; <code>Networkfamily</code>
</p>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>penalties</code></dt><dd><p>the sparsity level of the network in the successively fitted models</p>
</dd>
<dt><code>stability_path</code></dt><dd><p>the stability path of each edge as returned by the stars procedure</p>
</dd>
<dt><code>stability</code></dt><dd><p>mean edge stability along the penalty path</p>
</dd>
<dt><code>criteria</code></dt><dd><p>a data frame with the values of some criteria (variational log-likelihood, (E)BIC, ICL and R2, stability) for the collection of models / fits
BIC, ICL and EBIC are defined so that they are on the same scale as the model log-likelihood, i.e. with the form, loglik - 0.5 penalty</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-Networkfamily-new"><code>Networkfamily$new()</code></a>
</p>
</li>
<li> <p><a href="#method-Networkfamily-optimize"><code>Networkfamily$optimize()</code></a>
</p>
</li>
<li> <p><a href="#method-Networkfamily-coefficient_path"><code>Networkfamily$coefficient_path()</code></a>
</p>
</li>
<li> <p><a href="#method-Networkfamily-getBestModel"><code>Networkfamily$getBestModel()</code></a>
</p>
</li>
<li> <p><a href="#method-Networkfamily-plot"><code>Networkfamily$plot()</code></a>
</p>
</li>
<li> <p><a href="#method-Networkfamily-plot_stars"><code>Networkfamily$plot_stars()</code></a>
</p>
</li>
<li> <p><a href="#method-Networkfamily-plot_objective"><code>Networkfamily$plot_objective()</code></a>
</p>
</li>
<li> <p><a href="#method-Networkfamily-show"><code>Networkfamily$show()</code></a>
</p>
</li>
<li> <p><a href="#method-Networkfamily-clone"><code>Networkfamily$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="PLNmodels" data-topic="PLNfamily" data-id="getModel"><a href='../../PLNmodels/html/PLNfamily.html#method-PLNfamily-getModel'><code>PLNmodels::PLNfamily$getModel()</code></a></span></li>
<li><span class="pkg-link" data-pkg="PLNmodels" data-topic="PLNfamily" data-id="postTreatment"><a href='../../PLNmodels/html/PLNfamily.html#method-PLNfamily-postTreatment'><code>PLNmodels::PLNfamily$postTreatment()</code></a></span></li>
<li><span class="pkg-link" data-pkg="PLNmodels" data-topic="PLNfamily" data-id="print"><a href='../../PLNmodels/html/PLNfamily.html#method-PLNfamily-print'><code>PLNmodels::PLNfamily$print()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-Networkfamily-new"></a>



<h4>Method <code>new()</code></h4>

<p>Initialize all models in the collection
</p>


<h5>Usage</h5>

<div class="r"><pre>Networkfamily$new(penalties, data, control)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>penalties</code></dt><dd><p>a vector of positive real number controlling the level of sparsity of the underlying network.</p>
</dd>
<dt><code>data</code></dt><dd><p>a named list used internally to carry the data matrices</p>
</dd>
<dt><code>control</code></dt><dd><p>a list for controlling the optimization.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>Update all network fits in the family with smart starting values
</p>


<hr>
<a id="method-Networkfamily-optimize"></a>



<h4>Method <code>optimize()</code></h4>

<p>Call to the C++ optimizer on all models of the collection
</p>


<h5>Usage</h5>

<div class="r"><pre>Networkfamily$optimize(data, config)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>data</code></dt><dd><p>a named list used internally to carry the data matrices</p>
</dd>
<dt><code>config</code></dt><dd><p>a list for controlling the optimization.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Networkfamily-coefficient_path"></a>



<h4>Method <code>coefficient_path()</code></h4>

<p>Extract the regularization path of a <code><a href="#topic+Networkfamily">Networkfamily</a></code>
</p>


<h5>Usage</h5>

<div class="r"><pre>Networkfamily$coefficient_path(precision = TRUE, corr = TRUE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>precision</code></dt><dd><p>Logical. Should the regularization path be extracted from the precision matrix Omega (<code>TRUE</code>, default) or from the variance matrix Sigma (<code>FALSE</code>)</p>
</dd>
<dt><code>corr</code></dt><dd><p>Logical. Should the matrix be transformed to (partial) correlation matrix before extraction? Defaults to <code>TRUE</code></p>
</dd>
</dl>

</div>


<hr>
<a id="method-Networkfamily-getBestModel"></a>



<h4>Method <code>getBestModel()</code></h4>

<p>Extract the best network in the family according to some criteria
</p>


<h5>Usage</h5>

<div class="r"><pre>Networkfamily$getBestModel(crit = c("BIC", "EBIC", "StARS"), stability = 0.9)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>crit</code></dt><dd><p>character. Criterion used to perform the selection. If &quot;StARS&quot; is chosen but <code style="white-space: pre;">&#8288;$stability&#8288;</code> field is empty, will compute stability path.</p>
</dd>
<dt><code>stability</code></dt><dd><p>Only used for &quot;StARS&quot; criterion. A scalar indicating the target stability (= 1 - 2 beta) at which the network is selected. Default is <code>0.9</code>.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>For BIC and EBIC criteria, higher is better.
</p>


<hr>
<a id="method-Networkfamily-plot"></a>



<h4>Method <code>plot()</code></h4>

<p>Display various outputs (goodness-of-fit criteria, robustness, diagnostic) associated with a collection of network fits (a <code><a href="#topic+Networkfamily">Networkfamily</a></code>)
</p>


<h5>Usage</h5>

<div class="r"><pre>Networkfamily$plot(
  criteria = c("loglik", "pen_loglik", "BIC", "EBIC"),
  reverse = FALSE,
  log.x = TRUE
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>criteria</code></dt><dd><p>vector of characters. The criteria to plot in <code>c("loglik", "pen_loglik", "BIC", "EBIC")</code>. Defaults to all of them.</p>
</dd>
<dt><code>reverse</code></dt><dd><p>A logical indicating whether to plot the value of the criteria in the &quot;natural&quot; direction
(loglik - 0.5 penalty) or in the &quot;reverse&quot; direction (-2 loglik + penalty). Default to FALSE, i.e use the
natural direction, on the same scale as the log-likelihood.</p>
</dd>
<dt><code>log.x</code></dt><dd><p>logical: should the x-axis be represented in log-scale? Default is <code>TRUE</code>.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>a <code><a href="ggplot2.html#topic+ggplot">ggplot</a></code> graph
</p>


<hr>
<a id="method-Networkfamily-plot_stars"></a>



<h4>Method <code>plot_stars()</code></h4>

<p>Plot stability path
</p>


<h5>Usage</h5>

<div class="r"><pre>Networkfamily$plot_stars(stability = 0.9, log.x = TRUE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>stability</code></dt><dd><p>scalar: the targeted level of stability using stability selection. Default is <code>0.9</code>.</p>
</dd>
<dt><code>log.x</code></dt><dd><p>logical: should the x-axis be represented in log-scale? Default is <code>TRUE</code>.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>a <code><a href="ggplot2.html#topic+ggplot">ggplot</a></code> graph
</p>


<hr>
<a id="method-Networkfamily-plot_objective"></a>



<h4>Method <code>plot_objective()</code></h4>

<p>Plot objective value of the optimization problem along the penalty path
</p>


<h5>Usage</h5>

<div class="r"><pre>Networkfamily$plot_objective()</pre></div>



<h5>Returns</h5>

<p>a <code><a href="ggplot2.html#topic+ggplot">ggplot</a></code> graph
</p>


<hr>
<a id="method-Networkfamily-show"></a>



<h4>Method <code>show()</code></h4>

<p>User friendly print method
</p>


<h5>Usage</h5>

<div class="r"><pre>Networkfamily$show()</pre></div>


<hr>
<a id="method-Networkfamily-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>Networkfamily$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p>The functions <code><a href="#topic+PLNnetwork">PLNnetwork()</a></code>, <code><a href="#topic+ZIPLNnetwork">ZIPLNnetwork()</a></code> and the classes <code><a href="#topic+PLNnetworkfit">PLNnetworkfit</a></code>, <code><a href="#topic+ZIPLNfit_sparse">ZIPLNfit_sparse</a></code>
</p>

<hr>
<h2 id='oaks'>Oaks amplicon data set</h2><span id='topic+oaks'></span>

<h3>Description</h3>

<p>This data set gives the abundance of 114 taxa (66 bacterial OTU, 48 fungal OTUs) in 116 samples.
For each sample, 11 additional covariates are known.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>oaks
</code></pre>


<h3>Format</h3>

<p>A data frame with 13 variables:
</p>

<ul>
<li><p> Abundance: A 114 taxa by 116 samples count matrix
</p>
</li>
<li><p> Offset: A 114 taxa by 116 samples offset matrix
</p>
</li>
<li><p> Sample: Unique sample id
</p>
</li>
<li><p> tree: Tree status with respect to the pathogen (susceptible, intermediate or resistant)
</p>
</li>
<li><p> branch: Unique branch id in each tree (4 branches were sampled in each tree, with 10 leaves per branch)
</p>
</li>
<li><p> leafNO: Unique leaf id in each tree (40 leaves were sampled in each tree)
</p>
</li>
<li><p> distTObase: Distance of the sampled leaf to the base of the branch
</p>
</li>
<li><p> distTOtrunk: Distance of the sampled leaf to the base of the tree trunk
</p>
</li>
<li><p> distTOground: Distance of the sampled leaf to the base of the ground
</p>
</li>
<li><p> pmInfection: Powdery mildew infection, proportion of the upper leaf area displaying mildew symptoms
</p>
</li>
<li><p> orientation: Orientation of the branch (South-West SW or North-East NE)
</p>
</li>
<li><p> readsTOTfun: Total number of ITS1 reads for that leaf
</p>
</li>
<li><p> readsTOTbac: Total number of 16S reads for that leaf
</p>
</li></ul>



<h3>Source</h3>

<p>Data from B. Jakuschkin and coauthors.
</p>


<h3>References</h3>

<p>Jakuschkin, B., Fievet, V., Schwaller, L. et al. Deciphering the Pathobiome: Intra- and Interkingdom Interactions Involving the Pathogen Erysiphe alphitoides . Microb Ecol 72, 870–880 (2016). <a href="https://doi.org/10.1007/s00248-016-0777-x">doi:10.1007/s00248-016-0777-x</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+prepare_data">prepare_data()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(oaks)
## Not run: 
oaks_networks &lt;- PLNnetwork(formula = Abundance ~ 1 + offset(log(Offset)), data = oaks)

## End(Not run)
</code></pre>

<hr>
<h2 id='PLN'>Poisson lognormal model</h2><span id='topic+PLN'></span>

<h3>Description</h3>

<p>Fit the multivariate Poisson lognormal model with a variational algorithm. Use the (g)lm syntax for model specification (covariates, offsets, weights).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PLN(formula, data, subset, weights, control = PLN_param())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PLN_+3A_formula">formula</code></td>
<td>
<p>an object of class &quot;formula&quot;: a symbolic description of the model to be fitted.</p>
</td></tr>
<tr><td><code id="PLN_+3A_data">data</code></td>
<td>
<p>an optional data frame, list or environment (or object coercible by as.data.frame to a data frame) containing the variables in the model. If not found in data, the variables are taken from environment(formula), typically the environment from which PLN is called.</p>
</td></tr>
<tr><td><code id="PLN_+3A_subset">subset</code></td>
<td>
<p>an optional vector specifying a subset of observations to be used in the fitting process.</p>
</td></tr>
<tr><td><code id="PLN_+3A_weights">weights</code></td>
<td>
<p>an optional vector of observation weights to be used in the fitting process.</p>
</td></tr>
<tr><td><code id="PLN_+3A_control">control</code></td>
<td>
<p>a list-like structure for controlling the optimization, with default generated by <code><a href="#topic+PLN_param">PLN_param()</a></code>. See the associated documentation
for details.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an R6 object with class <code><a href="#topic+PLNfit">PLNfit</a></code>
</p>


<h3>See Also</h3>

<p>The class <code><a href="#topic+PLNfit">PLNfit</a></code> and the configuration function <code><a href="#topic+PLN_param">PLN_param()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(trichoptera)
trichoptera &lt;- prepare_data(trichoptera$Abundance, trichoptera$Covariate)
myPLN &lt;- PLN(Abundance ~ 1, data = trichoptera)
</code></pre>

<hr>
<h2 id='PLN_param'>Control of a PLN fit</h2><span id='topic+PLN_param'></span>

<h3>Description</h3>

<p>Helper to define list of parameters to control the PLN fit. All arguments have defaults.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PLN_param(
  backend = c("nlopt", "torch"),
  trace = 1,
  covariance = c("full", "diagonal", "spherical", "fixed"),
  Omega = NULL,
  config_post = list(),
  config_optim = list(),
  inception = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PLN_param_+3A_backend">backend</code></td>
<td>
<p>optimization back used, either &quot;nlopt&quot; or &quot;torch&quot;. Default is &quot;nlopt&quot;</p>
</td></tr>
<tr><td><code id="PLN_param_+3A_trace">trace</code></td>
<td>
<p>a integer for verbosity.</p>
</td></tr>
<tr><td><code id="PLN_param_+3A_covariance">covariance</code></td>
<td>
<p>character setting the model for the covariance matrix. Either &quot;full&quot;, &quot;diagonal&quot;, &quot;spherical&quot; or &quot;fixed&quot;. Default is &quot;full&quot;.</p>
</td></tr>
<tr><td><code id="PLN_param_+3A_omega">Omega</code></td>
<td>
<p>precision matrix of the latent variables. Inverse of Sigma. Must be specified if <code>covariance</code> is &quot;fixed&quot;</p>
</td></tr>
<tr><td><code id="PLN_param_+3A_config_post">config_post</code></td>
<td>
<p>a list for controlling the post-treatments (optional bootstrap, jackknife, R2, etc.). See details</p>
</td></tr>
<tr><td><code id="PLN_param_+3A_config_optim">config_optim</code></td>
<td>
<p>a list for controlling the optimizer (either &quot;nlopt&quot; or &quot;torch&quot; backend). See details</p>
</td></tr>
<tr><td><code id="PLN_param_+3A_inception">inception</code></td>
<td>
<p>Set up the parameters initialization: by default, the model is initialized with a multivariate linear model applied on
log-transformed data, and with the same formula as the one provided by the user. However, the user can provide a PLNfit (typically obtained from a previous fit),
which sometimes speeds up the inference.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The list of parameters <code>config_optim</code> controls the optimizers. When &quot;nlopt&quot; is chosen the following entries are relevant
</p>

<ul>
<li><p> &quot;algorithm&quot; the optimization method used by NLOPT among LD type, e.g. &quot;CCSAQ&quot;, &quot;MMA&quot;, &quot;LBFGS&quot;. See NLOPT documentation for further details. Default is &quot;CCSAQ&quot;.
</p>
</li>
<li><p> &quot;maxeval&quot; stop when the number of iteration exceeds maxeval. Default is 10000
</p>
</li>
<li><p> &quot;ftol_rel&quot; stop when an optimization step changes the objective function by less than ftol multiplied by the absolute value of the parameter. Default is 1e-8
</p>
</li>
<li><p> &quot;xtol_rel&quot; stop when an optimization step changes every parameters by less than xtol multiplied by the absolute value of the parameter. Default is 1e-6
</p>
</li>
<li><p> &quot;ftol_abs&quot; stop when an optimization step changes the objective function by less than ftol_abs. Default is 0.0 (disabled)
</p>
</li>
<li><p> &quot;xtol_abs&quot; stop when an optimization step changes every parameters by less than xtol_abs. Default is 0.0 (disabled)
</p>
</li>
<li><p> &quot;maxtime&quot; stop when the optimization time (in seconds) exceeds maxtime. Default is -1 (disabled)
</p>
</li></ul>

<p>When &quot;torch&quot; backend is used (only for PLN and PLNLDA for now), the following entries are relevant:
</p>

<ul>
<li><p> &quot;algorithm&quot; the optimizer used by torch among RPROP (default), RMSPROP, ADAM and ADAGRAD
</p>
</li>
<li><p> &quot;maxeval&quot; stop when the number of iteration exceeds maxeval. Default is 10 000
</p>
</li>
<li><p> &quot;numepoch&quot; stop training once this number of epochs exceeds numepoch. Set to -1 to enable infinite training. Default is 1 000
</p>
</li>
<li><p> &quot;num_batch&quot; number of batches to use during training. Defaults to 1 (use full dataset at each epoch)
</p>
</li>
<li><p> &quot;ftol_rel&quot; stop when an optimization step changes the objective function by less than ftol multiplied by the absolute value of the parameter. Default is 1e-8
</p>
</li>
<li><p> &quot;xtol_rel&quot; stop when an optimization step changes every parameters by less than xtol multiplied by the absolute value of the parameter. Default is 1e-6
</p>
</li>
<li><p> &quot;lr&quot; learning rate. Default is 0.1.
</p>
</li>
<li><p> &quot;momentum&quot; momentum factor. Default is 0 (no momentum). Only used in RMSPROP
</p>
</li>
<li><p> &quot;weight_decay&quot; Weight decay penalty. Default is 0 (no decay). Not used in RPROP
</p>
</li>
<li><p> &quot;step_sizes&quot; pair of minimal (default: 1e-6) and maximal (default: 50) allowed step sizes. Only used in RPROP
</p>
</li>
<li><p> &quot;etas&quot; pair of multiplicative increase and decrease factors. Default is (0.5, 1.2). Only used in RPROP
</p>
</li>
<li><p> &quot;centered&quot; if TRUE, compute the centered RMSProp where the gradient is normalized by an estimation of its variance weight_decay (L2 penalty). Default to FALSE. Only used in RMSPROP
</p>
</li></ul>

<p>The list of parameters <code>config_post</code> controls the post-treatment processing (for most <code style="white-space: pre;">&#8288;PLN*()&#8288;</code> functions), with the following entries (defaults may vary depending on the specific function, check <code style="white-space: pre;">&#8288;config_post_default_*&#8288;</code> for defaults values):
</p>

<ul>
<li><p> jackknife boolean indicating whether jackknife should be performed to evaluate bias and variance of the model parameters. Default is FALSE.
</p>
</li>
<li><p> bootstrap integer indicating the number of bootstrap resamples generated to evaluate the variance of the model parameters. Default is 0 (inactivated).
</p>
</li>
<li><p> variational_var boolean indicating whether variational Fisher information matrix should be computed to estimate the variance of the model parameters (highly underestimated). Default is FALSE.
</p>
</li>
<li><p> sandwich_var boolean indicating whether sandwich estimation should be used to estimate the variance of the model parameters (highly underestimated). Default is FALSE.
</p>
</li>
<li><p> rsquared boolean indicating whether approximation of R2 based on deviance should be computed. Default is TRUE
</p>
</li></ul>



<h3>Value</h3>

<p>list of parameters configuring the fit.
</p>

<hr>
<h2 id='PLNfamily'>An R6 Class to represent a collection of PLNfit</h2><span id='topic+PLNfamily'></span>

<h3>Description</h3>

<p>super class for <code><a href="#topic+PLNPCAfamily">PLNPCAfamily</a></code> and <code><a href="#topic+PLNnetworkfamily">PLNnetworkfamily</a></code>.
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>responses</code></dt><dd><p>the matrix of responses common to every models</p>
</dd>
<dt><code>covariates</code></dt><dd><p>the matrix of covariates common to every models</p>
</dd>
<dt><code>offsets</code></dt><dd><p>the matrix of offsets common to every models</p>
</dd>
<dt><code>weights</code></dt><dd><p>the vector of observation weights</p>
</dd>
<dt><code>inception</code></dt><dd><p>a <a href="#topic+PLNfit">PLNfit</a> object, obtained when no sparsifying penalty is applied.</p>
</dd>
<dt><code>models</code></dt><dd><p>a list of <a href="#topic+PLNfit">PLNfit</a> object, one per penalty.</p>
</dd>
</dl>

</div>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>criteria</code></dt><dd><p>a data frame with the values of some criteria (approximated log-likelihood, BIC, ICL, etc.) for the collection of models / fits
BIC and ICL are defined so that they are on the same scale as the model log-likelihood, i.e. with the form, loglik - 0.5 penalty</p>
</dd>
<dt><code>convergence</code></dt><dd><p>sends back a data frame with some convergence diagnostics associated with the optimization process (method, optimal value, etc)</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-PLNfamily-new"><code>PLNfamily$new()</code></a>
</p>
</li>
<li> <p><a href="#method-PLNfamily-postTreatment"><code>PLNfamily$postTreatment()</code></a>
</p>
</li>
<li> <p><a href="#method-PLNfamily-getModel"><code>PLNfamily$getModel()</code></a>
</p>
</li>
<li> <p><a href="#method-PLNfamily-plot"><code>PLNfamily$plot()</code></a>
</p>
</li>
<li> <p><a href="#method-PLNfamily-show"><code>PLNfamily$show()</code></a>
</p>
</li>
<li> <p><a href="#method-PLNfamily-print"><code>PLNfamily$print()</code></a>
</p>
</li>
<li> <p><a href="#method-PLNfamily-clone"><code>PLNfamily$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-PLNfamily-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a new <code><a href="#topic+PLNfamily">PLNfamily</a></code> object.
</p>


<h5>Usage</h5>

<div class="r"><pre>PLNfamily$new(responses, covariates, offsets, weights, control)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>responses</code></dt><dd><p>the matrix of responses common to every models</p>
</dd>
<dt><code>covariates</code></dt><dd><p>the matrix of covariates common to every models</p>
</dd>
<dt><code>offsets</code></dt><dd><p>the matrix of offsets common to every models</p>
</dd>
<dt><code>weights</code></dt><dd><p>the vector of observation weights</p>
</dd>
<dt><code>control</code></dt><dd><p>list controlling the optimization and the model</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A new <code><a href="#topic+PLNfamily">PLNfamily</a></code> object
</p>


<hr>
<a id="method-PLNfamily-postTreatment"></a>



<h4>Method <code>postTreatment()</code></h4>

<p>Update fields after optimization
</p>


<h5>Usage</h5>

<div class="r"><pre>PLNfamily$postTreatment(config_post, config_optim)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>config_post</code></dt><dd><p>a list for controlling the post-treatments (optional bootstrap, jackknife, R2, etc.).</p>
</dd>
<dt><code>config_optim</code></dt><dd><p>a list for controlling the optimization parameters used during post_treatments</p>
</dd>
</dl>

</div>


<hr>
<a id="method-PLNfamily-getModel"></a>



<h4>Method <code>getModel()</code></h4>

<p>Extract a model from a collection of models
</p>


<h5>Usage</h5>

<div class="r"><pre>PLNfamily$getModel(var, index = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>var</code></dt><dd><p>value of the parameter (<code>rank</code> for PLNPCA, <code>sparsity</code> for PLNnetwork) that identifies the model to be extracted from the collection. If no exact match is found, the model with closest parameter value is returned with a warning.</p>
</dd>
<dt><code>index</code></dt><dd><p>Integer index of the model to be returned. Only the first value is taken into account.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A <code><a href="#topic+PLNfit">PLNfit</a></code> object
</p>


<hr>
<a id="method-PLNfamily-plot"></a>



<h4>Method <code>plot()</code></h4>

<p>Lineplot of selected criteria for all models in the collection
</p>


<h5>Usage</h5>

<div class="r"><pre>PLNfamily$plot(criteria, reverse)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>criteria</code></dt><dd><p>A valid model selection criteria for the collection of models. Includes loglik, BIC (all), ICL (PLNPCA) and pen_loglik, EBIC (PLNnetwork)</p>
</dd>
<dt><code>reverse</code></dt><dd><p>A logical indicating whether to plot the value of the criteria in the &quot;natural&quot; direction
(loglik - penalty) or in the &quot;reverse&quot; direction (-2 loglik + penalty). Default to FALSE, i.e use the natural direction, on
the same scale as the log-likelihood.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A <code><a href="ggplot2.html#topic+ggplot2">ggplot2</a></code> object
</p>


<hr>
<a id="method-PLNfamily-show"></a>



<h4>Method <code>show()</code></h4>

<p>User friendly print method
</p>


<h5>Usage</h5>

<div class="r"><pre>PLNfamily$show()</pre></div>


<hr>
<a id="method-PLNfamily-print"></a>



<h4>Method <code>print()</code></h4>

<p>User friendly print method
</p>


<h5>Usage</h5>

<div class="r"><pre>PLNfamily$print()</pre></div>


<hr>
<a id="method-PLNfamily-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>PLNfamily$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p><code><a href="#topic+getModel">getModel()</a></code>
</p>

<hr>
<h2 id='PLNfit'>An R6 Class to represent a PLNfit in a standard, general framework</h2><span id='topic+PLNfit'></span>

<h3>Description</h3>

<p>The function <code><a href="#topic+PLN">PLN()</a></code> fit a model which is an instance of a object with class <code><a href="#topic+PLNfit">PLNfit</a></code>.
Objects produced by the functions <code><a href="#topic+PLNnetwork">PLNnetwork()</a></code>, <code><a href="#topic+PLNPCA">PLNPCA()</a></code>, <code><a href="#topic+PLNmixture">PLNmixture()</a></code> and <code><a href="#topic+PLNLDA">PLNLDA()</a></code> also enjoy the methods of <code><a href="#topic+PLNfit">PLNfit()</a></code> by inheritance.
</p>
<p>This class comes with a set of R6 methods, some of them being useful for the user and exported as S3 methods.
See the documentation for <code><a href="stats.html#topic+coef">coef()</a></code>, <code><a href="stats.html#topic+sigma">sigma()</a></code>, <code><a href="stats.html#topic+predict">predict()</a></code>, <code><a href="stats.html#topic+vcov">vcov()</a></code> and <code><a href="#topic+standard_error">standard_error()</a></code>.
</p>
<p>Fields are accessed via active binding and cannot be changed by the user.
</p>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>n</code></dt><dd><p>number of samples</p>
</dd>
<dt><code>q</code></dt><dd><p>number of dimensions of the latent space</p>
</dd>
<dt><code>p</code></dt><dd><p>number of species</p>
</dd>
<dt><code>d</code></dt><dd><p>number of covariates</p>
</dd>
<dt><code>nb_param</code></dt><dd><p>number of parameters in the current PLN model</p>
</dd>
<dt><code>model_par</code></dt><dd><p>a list with the matrices of the model parameters: B (covariates), Sigma (covariance), Omega (precision matrix), plus some others depending on the variant)</p>
</dd>
<dt><code>var_par</code></dt><dd><p>a list with the matrices of the variational parameters: M (means) and S2 (variances)</p>
</dd>
<dt><code>optim_par</code></dt><dd><p>a list with parameters useful for monitoring the optimization</p>
</dd>
<dt><code>latent</code></dt><dd><p>a matrix: values of the latent vector (Z in the model)</p>
</dd>
<dt><code>latent_pos</code></dt><dd><p>a matrix: values of the latent position vector (Z) without covariates effects or offset</p>
</dd>
<dt><code>fitted</code></dt><dd><p>a matrix: fitted values of the observations (A in the model)</p>
</dd>
<dt><code>vcov_coef</code></dt><dd><p>matrix of sandwich estimator of the variance-covariance of B (need fixed -ie known- covariance at the moment)</p>
</dd>
<dt><code>vcov_model</code></dt><dd><p>character: the model used for the residual covariance</p>
</dd>
<dt><code>weights</code></dt><dd><p>observational weights</p>
</dd>
<dt><code>loglik</code></dt><dd><p>(weighted) variational lower bound of the loglikelihood</p>
</dd>
<dt><code>loglik_vec</code></dt><dd><p>element-wise variational lower bound of the loglikelihood</p>
</dd>
<dt><code>BIC</code></dt><dd><p>variational lower bound of the BIC</p>
</dd>
<dt><code>entropy</code></dt><dd><p>Entropy of the variational distribution</p>
</dd>
<dt><code>ICL</code></dt><dd><p>variational lower bound of the ICL</p>
</dd>
<dt><code>R_squared</code></dt><dd><p>approximated goodness-of-fit criterion</p>
</dd>
<dt><code>criteria</code></dt><dd><p>a vector with loglik, BIC, ICL and number of parameters</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-PLNfit-new"><code>PLNfit$new()</code></a>
</p>
</li>
<li> <p><a href="#method-PLNfit-update"><code>PLNfit$update()</code></a>
</p>
</li>
<li> <p><a href="#method-PLNfit-optimize"><code>PLNfit$optimize()</code></a>
</p>
</li>
<li> <p><a href="#method-PLNfit-optimize_vestep"><code>PLNfit$optimize_vestep()</code></a>
</p>
</li>
<li> <p><a href="#method-PLNfit-postTreatment"><code>PLNfit$postTreatment()</code></a>
</p>
</li>
<li> <p><a href="#method-PLNfit-predict"><code>PLNfit$predict()</code></a>
</p>
</li>
<li> <p><a href="#method-PLNfit-predict_cond"><code>PLNfit$predict_cond()</code></a>
</p>
</li>
<li> <p><a href="#method-PLNfit-show"><code>PLNfit$show()</code></a>
</p>
</li>
<li> <p><a href="#method-PLNfit-print"><code>PLNfit$print()</code></a>
</p>
</li>
<li> <p><a href="#method-PLNfit-clone"><code>PLNfit$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-PLNfit-new"></a>



<h4>Method <code>new()</code></h4>

<p>Initialize a <code><a href="#topic+PLNfit">PLNfit</a></code> model
</p>


<h5>Usage</h5>

<div class="r"><pre>PLNfit$new(responses, covariates, offsets, weights, formula, control)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>responses</code></dt><dd><p>the matrix of responses (called Y in the model). Will usually be extracted from the corresponding field in PLNfamily-class</p>
</dd>
<dt><code>covariates</code></dt><dd><p>design matrix (called X in the model). Will usually be extracted from the corresponding field in PLNfamily-class</p>
</dd>
<dt><code>offsets</code></dt><dd><p>offset matrix (called O in the model). Will usually be extracted from the corresponding field in PLNfamily-class</p>
</dd>
<dt><code>weights</code></dt><dd><p>an optional vector of observation weights to be used in the fitting process.</p>
</dd>
<dt><code>formula</code></dt><dd><p>model formula used for fitting, extracted from the formula in the upper-level call</p>
</dd>
<dt><code>control</code></dt><dd><p>a list-like structure for controlling the fit, see <code><a href="#topic+PLN_param">PLN_param()</a></code>.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-PLNfit-update"></a>



<h4>Method <code>update()</code></h4>

<p>Update a <code><a href="#topic+PLNfit">PLNfit</a></code> object
</p>


<h5>Usage</h5>

<div class="r"><pre>PLNfit$update(
  B = NA,
  Sigma = NA,
  Omega = NA,
  M = NA,
  S = NA,
  Ji = NA,
  R2 = NA,
  Z = NA,
  A = NA,
  monitoring = NA
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>B</code></dt><dd><p>matrix of regression matrix</p>
</dd>
<dt><code>Sigma</code></dt><dd><p>variance-covariance matrix of the latent variables</p>
</dd>
<dt><code>Omega</code></dt><dd><p>precision matrix of the latent variables. Inverse of Sigma.</p>
</dd>
<dt><code>M</code></dt><dd><p>matrix of variational parameters for the mean</p>
</dd>
<dt><code>S</code></dt><dd><p>matrix of variational parameters for the variance</p>
</dd>
<dt><code>Ji</code></dt><dd><p>vector of variational lower bounds of the log-likelihoods (one value per sample)</p>
</dd>
<dt><code>R2</code></dt><dd><p>approximate R^2 goodness-of-fit criterion</p>
</dd>
<dt><code>Z</code></dt><dd><p>matrix of latent vectors (includes covariates and offset effects)</p>
</dd>
<dt><code>A</code></dt><dd><p>matrix of fitted values</p>
</dd>
<dt><code>monitoring</code></dt><dd><p>a list with optimization monitoring quantities</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>Update the current <code><a href="#topic+PLNfit">PLNfit</a></code> object
</p>


<hr>
<a id="method-PLNfit-optimize"></a>



<h4>Method <code>optimize()</code></h4>

<p>Call to the NLopt or TORCH optimizer and update of the relevant fields
</p>


<h5>Usage</h5>

<div class="r"><pre>PLNfit$optimize(responses, covariates, offsets, weights, config)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>responses</code></dt><dd><p>the matrix of responses (called Y in the model). Will usually be extracted from the corresponding field in PLNfamily-class</p>
</dd>
<dt><code>covariates</code></dt><dd><p>design matrix (called X in the model). Will usually be extracted from the corresponding field in PLNfamily-class</p>
</dd>
<dt><code>offsets</code></dt><dd><p>offset matrix (called O in the model). Will usually be extracted from the corresponding field in PLNfamily-class</p>
</dd>
<dt><code>weights</code></dt><dd><p>an optional vector of observation weights to be used in the fitting process.</p>
</dd>
<dt><code>config</code></dt><dd><p>part of the <code>control</code> argument which configures the optimizer</p>
</dd>
</dl>

</div>


<hr>
<a id="method-PLNfit-optimize_vestep"></a>



<h4>Method <code>optimize_vestep()</code></h4>

<p>Result of one call to the VE step of the optimization procedure: optimal variational parameters (M, S) and corresponding log likelihood values for fixed model parameters (Sigma, B). Intended to position new data in the latent space.
</p>


<h5>Usage</h5>

<div class="r"><pre>PLNfit$optimize_vestep(
  covariates,
  offsets,
  responses,
  weights,
  B = self$model_par$B,
  Omega = self$model_par$Omega,
  control = PLN_param(backend = "nlopt")
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>covariates</code></dt><dd><p>design matrix (called X in the model). Will usually be extracted from the corresponding field in PLNfamily-class</p>
</dd>
<dt><code>offsets</code></dt><dd><p>offset matrix (called O in the model). Will usually be extracted from the corresponding field in PLNfamily-class</p>
</dd>
<dt><code>responses</code></dt><dd><p>the matrix of responses (called Y in the model). Will usually be extracted from the corresponding field in PLNfamily-class</p>
</dd>
<dt><code>weights</code></dt><dd><p>an optional vector of observation weights to be used in the fitting process.</p>
</dd>
<dt><code>B</code></dt><dd><p>Optional fixed value of the regression parameters</p>
</dd>
<dt><code>Omega</code></dt><dd><p>precision matrix of the latent variables. Inverse of Sigma.</p>
</dd>
<dt><code>control</code></dt><dd><p>a list-like structure for controlling the fit, see <code><a href="#topic+PLN_param">PLN_param()</a></code>.</p>
</dd>
<dt><code>Sigma</code></dt><dd><p>variance-covariance matrix of the latent variables</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A list with three components:
</p>

<ul>
<li><p> the matrix <code>M</code> of variational means,
</p>
</li>
<li><p> the matrix <code>S2</code> of variational variances
</p>
</li>
<li><p> the vector <code>log.lik</code> of (variational) log-likelihood of each new observation
</p>
</li></ul>



<hr>
<a id="method-PLNfit-postTreatment"></a>



<h4>Method <code>postTreatment()</code></h4>

<p>Update R2, fisher and std_err fields after optimization
</p>


<h5>Usage</h5>

<div class="r"><pre>PLNfit$postTreatment(
  responses,
  covariates,
  offsets,
  weights = rep(1, nrow(responses)),
  config_post,
  config_optim,
  nullModel = NULL
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>responses</code></dt><dd><p>the matrix of responses (called Y in the model). Will usually be extracted from the corresponding field in PLNfamily-class</p>
</dd>
<dt><code>covariates</code></dt><dd><p>design matrix (called X in the model). Will usually be extracted from the corresponding field in PLNfamily-class</p>
</dd>
<dt><code>offsets</code></dt><dd><p>offset matrix (called O in the model). Will usually be extracted from the corresponding field in PLNfamily-class</p>
</dd>
<dt><code>weights</code></dt><dd><p>an optional vector of observation weights to be used in the fitting process.</p>
</dd>
<dt><code>config_post</code></dt><dd><p>a list for controlling the post-treatments (optional bootstrap, jackknife, R2, etc.). See details</p>
</dd>
<dt><code>config_optim</code></dt><dd><p>a list for controlling the optimization (optional bootstrap, jackknife, R2, etc.). See details</p>
</dd>
<dt><code>nullModel</code></dt><dd><p>null model used for approximate R2 computations. Defaults to a GLM model with same design matrix but not latent variable.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>The list of parameters <code>config</code> controls the post-treatment processing, with the following entries:
</p>

<ul>
<li><p> jackknife boolean indicating whether jackknife should be performed to evaluate bias and variance of the model parameters. Default is FALSE.
</p>
</li>
<li><p> bootstrap integer indicating the number of bootstrap resamples generated to evaluate the variance of the model parameters. Default is 0 (inactivated).
</p>
</li>
<li><p> variational_var boolean indicating whether variational Fisher information matrix should be computed to estimate the variance of the model parameters (highly underestimated). Default is FALSE.
</p>
</li>
<li><p> rsquared boolean indicating whether approximation of R2 based on deviance should be computed. Default is TRUE
</p>
</li>
<li><p> trace integer for verbosity. should be &gt; 1 to see output in post-treatments
</p>
</li></ul>



<hr>
<a id="method-PLNfit-predict"></a>



<h4>Method <code>predict()</code></h4>

<p>Predict position, scores or observations of new data.
</p>


<h5>Usage</h5>

<div class="r"><pre>PLNfit$predict(
  newdata,
  responses = NULL,
  type = c("link", "response"),
  level = 1,
  envir = parent.frame()
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>newdata</code></dt><dd><p>A data frame in which to look for variables with which to predict. If omitted, the fitted values are used.</p>
</dd>
<dt><code>responses</code></dt><dd><p>Optional data frame containing the count of the observed variables (matching the names of the provided as data in the PLN function), assuming the interest in in testing the model.</p>
</dd>
<dt><code>type</code></dt><dd><p>Scale used for the prediction. Either <code>link</code> (default, predicted positions in the latent space) or <code>response</code> (predicted counts).</p>
</dd>
<dt><code>level</code></dt><dd><p>Optional integer value the level to be used in obtaining the predictions. Level zero corresponds to the population predictions (default if <code>responses</code> is not provided) while level one (default) corresponds to predictions after evaluating the variational parameters for the new data.</p>
</dd>
<dt><code>envir</code></dt><dd><p>Environment in which the prediction is evaluated</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>Note that <code>level = 1</code> can only be used if responses are provided,
as the variational parameters can't be estimated otherwise. In the absence of responses, <code>level</code> is ignored and the fitted values are returned
</p>



<h5>Returns</h5>

<p>A matrix with predictions scores or counts.
</p>


<hr>
<a id="method-PLNfit-predict_cond"></a>



<h4>Method <code>predict_cond()</code></h4>

<p>Predict position, scores or observations of new data, conditionally on the observation of a (set of) variables
</p>


<h5>Usage</h5>

<div class="r"><pre>PLNfit$predict_cond(
  newdata,
  cond_responses,
  type = c("link", "response"),
  var_par = FALSE,
  envir = parent.frame()
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>newdata</code></dt><dd><p>a data frame containing the covariates of the sites where to predict</p>
</dd>
<dt><code>cond_responses</code></dt><dd><p>a data frame containing the count of the observed variables (matching the names of the provided as data in the PLN function)</p>
</dd>
<dt><code>type</code></dt><dd><p>Scale used for the prediction. Either <code>link</code> (default, predicted positions in the latent space) or <code>response</code> (predicted counts).</p>
</dd>
<dt><code>var_par</code></dt><dd><p>Boolean. Should new estimations of the variational parameters of mean and variance be sent back, as attributes of the matrix of predictions. Default to <code>FALSE</code>.</p>
</dd>
<dt><code>envir</code></dt><dd><p>Environment in which the prediction is evaluated</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A matrix with predictions scores or counts.
</p>


<hr>
<a id="method-PLNfit-show"></a>



<h4>Method <code>show()</code></h4>

<p>User friendly print method
</p>


<h5>Usage</h5>

<div class="r"><pre>PLNfit$show(
  model = paste("A multivariate Poisson Lognormal fit with", self$vcov_model,
    "covariance model.\n")
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>model</code></dt><dd><p>First line of the print output</p>
</dd>
</dl>

</div>


<hr>
<a id="method-PLNfit-print"></a>



<h4>Method <code>print()</code></h4>

<p>User friendly print method
</p>


<h5>Usage</h5>

<div class="r"><pre>PLNfit$print()</pre></div>


<hr>
<a id="method-PLNfit-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>PLNfit$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(trichoptera)
trichoptera &lt;- prepare_data(trichoptera$Abundance, trichoptera$Covariate)
myPLN &lt;- PLN(Abundance ~ 1, data = trichoptera)
class(myPLN)
print(myPLN)

## End(Not run)
</code></pre>

<hr>
<h2 id='PLNfit_diagonal'>An R6 Class to represent a PLNfit in a standard, general framework, with diagonal residual covariance</h2><span id='topic+PLNfit_diagonal'></span><span id='topic+PLNLDAfit_spherical'></span>

<h3>Description</h3>

<p>The function <code><a href="#topic+PLNLDA">PLNLDA()</a></code> produces an instance of an object with class <code><a href="#topic+PLNLDAfit">PLNLDAfit</a></code>.
</p>
<p>This class comes with a set of methods, some of them being useful for the user:
See the documentation for the methods inherited by <code><a href="#topic+PLNfit">PLNfit()</a></code>, the <code><a href="graphics.html#topic+plot">plot()</a></code> method for
LDA visualization and <code><a href="stats.html#topic+predict">predict()</a></code> method for prediction
</p>


<h3>Super class</h3>

<p><code><a href="#topic+PLNfit">PLNmodels::PLNfit</a></code> -&gt; <code>PLNfit_diagonal</code>
</p>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>nb_param</code></dt><dd><p>number of parameters in the current PLN model</p>
</dd>
<dt><code>vcov_model</code></dt><dd><p>character: the model used for the residual covariance</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-PLNfit_diagonal-new"><code>PLNfit_diagonal$new()</code></a>
</p>
</li>
<li> <p><a href="#method-PLNfit_diagonal-clone"><code>PLNfit_diagonal$clone()</code></a>
</p>
</li></ul>



<details><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="PLNmodels" data-topic="PLNfit" data-id="optimize"><a href='../../PLNmodels/html/PLNfit.html#method-PLNfit-optimize'><code>PLNmodels::PLNfit$optimize()</code></a></span></li>
<li><span class="pkg-link" data-pkg="PLNmodels" data-topic="PLNfit" data-id="optimize_vestep"><a href='../../PLNmodels/html/PLNfit.html#method-PLNfit-optimize_vestep'><code>PLNmodels::PLNfit$optimize_vestep()</code></a></span></li>
<li><span class="pkg-link" data-pkg="PLNmodels" data-topic="PLNfit" data-id="postTreatment"><a href='../../PLNmodels/html/PLNfit.html#method-PLNfit-postTreatment'><code>PLNmodels::PLNfit$postTreatment()</code></a></span></li>
<li><span class="pkg-link" data-pkg="PLNmodels" data-topic="PLNfit" data-id="predict"><a href='../../PLNmodels/html/PLNfit.html#method-PLNfit-predict'><code>PLNmodels::PLNfit$predict()</code></a></span></li>
<li><span class="pkg-link" data-pkg="PLNmodels" data-topic="PLNfit" data-id="predict_cond"><a href='../../PLNmodels/html/PLNfit.html#method-PLNfit-predict_cond'><code>PLNmodels::PLNfit$predict_cond()</code></a></span></li>
<li><span class="pkg-link" data-pkg="PLNmodels" data-topic="PLNfit" data-id="print"><a href='../../PLNmodels/html/PLNfit.html#method-PLNfit-print'><code>PLNmodels::PLNfit$print()</code></a></span></li>
<li><span class="pkg-link" data-pkg="PLNmodels" data-topic="PLNfit" data-id="show"><a href='../../PLNmodels/html/PLNfit.html#method-PLNfit-show'><code>PLNmodels::PLNfit$show()</code></a></span></li>
<li><span class="pkg-link" data-pkg="PLNmodels" data-topic="PLNfit" data-id="update"><a href='../../PLNmodels/html/PLNfit.html#method-PLNfit-update'><code>PLNmodels::PLNfit$update()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-PLNfit_diagonal-new"></a>



<h4>Method <code>new()</code></h4>

<p>Initialize a <code><a href="#topic+PLNfit">PLNfit</a></code> model
</p>


<h5>Usage</h5>

<div class="r"><pre>PLNfit_diagonal$new(responses, covariates, offsets, weights, formula, control)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>responses</code></dt><dd><p>the matrix of responses (called Y in the model). Will usually be extracted from the corresponding field in PLNfamily-class</p>
</dd>
<dt><code>covariates</code></dt><dd><p>design matrix (called X in the model). Will usually be extracted from the corresponding field in PLNfamily-class</p>
</dd>
<dt><code>offsets</code></dt><dd><p>offset matrix (called O in the model). Will usually be extracted from the corresponding field in PLNfamily-class</p>
</dd>
<dt><code>weights</code></dt><dd><p>an optional vector of observation weights to be used in the fitting process.</p>
</dd>
<dt><code>formula</code></dt><dd><p>model formula used for fitting, extracted from the formula in the upper-level call</p>
</dd>
<dt><code>control</code></dt><dd><p>a list for controlling the optimization. See details.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-PLNfit_diagonal-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>PLNfit_diagonal$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Super classes</h3>

<p><code><a href="#topic+PLNfit">PLNmodels::PLNfit</a></code> -&gt; <code><a href="#topic+PLNLDAfit">PLNmodels::PLNLDAfit</a></code> -&gt; <code>PLNLDAfit_spherical</code>
</p>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>vcov_model</code></dt><dd><p>character: the model used for the residual covariance</p>
</dd>
<dt><code>nb_param</code></dt><dd><p>number of parameters in the current PLN model</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-PLNLDAfit_spherical-new"><code>PLNLDAfit_spherical$new()</code></a>
</p>
</li>
<li> <p><a href="#method-PLNLDAfit_spherical-clone"><code>PLNLDAfit_spherical$clone()</code></a>
</p>
</li></ul>



<details><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="PLNmodels" data-topic="PLNfit" data-id="optimize_vestep"><a href='../../PLNmodels/html/PLNfit.html#method-PLNfit-optimize_vestep'><code>PLNmodels::PLNfit$optimize_vestep()</code></a></span></li>
<li><span class="pkg-link" data-pkg="PLNmodels" data-topic="PLNfit" data-id="predict_cond"><a href='../../PLNmodels/html/PLNfit.html#method-PLNfit-predict_cond'><code>PLNmodels::PLNfit$predict_cond()</code></a></span></li>
<li><span class="pkg-link" data-pkg="PLNmodels" data-topic="PLNfit" data-id="print"><a href='../../PLNmodels/html/PLNfit.html#method-PLNfit-print'><code>PLNmodels::PLNfit$print()</code></a></span></li>
<li><span class="pkg-link" data-pkg="PLNmodels" data-topic="PLNfit" data-id="update"><a href='../../PLNmodels/html/PLNfit.html#method-PLNfit-update'><code>PLNmodels::PLNfit$update()</code></a></span></li>
<li><span class="pkg-link" data-pkg="PLNmodels" data-topic="PLNLDAfit" data-id="optimize"><a href='../../PLNmodels/html/PLNLDAfit.html#method-PLNLDAfit-optimize'><code>PLNmodels::PLNLDAfit$optimize()</code></a></span></li>
<li><span class="pkg-link" data-pkg="PLNmodels" data-topic="PLNLDAfit" data-id="plot_LDA"><a href='../../PLNmodels/html/PLNLDAfit.html#method-PLNLDAfit-plot_LDA'><code>PLNmodels::PLNLDAfit$plot_LDA()</code></a></span></li>
<li><span class="pkg-link" data-pkg="PLNmodels" data-topic="PLNLDAfit" data-id="plot_correlation_map"><a href='../../PLNmodels/html/PLNLDAfit.html#method-PLNLDAfit-plot_correlation_map'><code>PLNmodels::PLNLDAfit$plot_correlation_map()</code></a></span></li>
<li><span class="pkg-link" data-pkg="PLNmodels" data-topic="PLNLDAfit" data-id="plot_individual_map"><a href='../../PLNmodels/html/PLNLDAfit.html#method-PLNLDAfit-plot_individual_map'><code>PLNmodels::PLNLDAfit$plot_individual_map()</code></a></span></li>
<li><span class="pkg-link" data-pkg="PLNmodels" data-topic="PLNLDAfit" data-id="postTreatment"><a href='../../PLNmodels/html/PLNLDAfit.html#method-PLNLDAfit-postTreatment'><code>PLNmodels::PLNLDAfit$postTreatment()</code></a></span></li>
<li><span class="pkg-link" data-pkg="PLNmodels" data-topic="PLNLDAfit" data-id="predict"><a href='../../PLNmodels/html/PLNLDAfit.html#method-PLNLDAfit-predict'><code>PLNmodels::PLNLDAfit$predict()</code></a></span></li>
<li><span class="pkg-link" data-pkg="PLNmodels" data-topic="PLNLDAfit" data-id="setVisualization"><a href='../../PLNmodels/html/PLNLDAfit.html#method-PLNLDAfit-setVisualization'><code>PLNmodels::PLNLDAfit$setVisualization()</code></a></span></li>
<li><span class="pkg-link" data-pkg="PLNmodels" data-topic="PLNLDAfit" data-id="show"><a href='../../PLNmodels/html/PLNLDAfit.html#method-PLNLDAfit-show'><code>PLNmodels::PLNLDAfit$show()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-PLNLDAfit_spherical-new"></a>



<h4>Method <code>new()</code></h4>

<p>Initialize a <code><a href="#topic+PLNfit">PLNfit</a></code> model
</p>


<h5>Usage</h5>

<div class="r"><pre>PLNLDAfit_spherical$new(
  grouping,
  responses,
  covariates,
  offsets,
  weights,
  formula,
  control
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>grouping</code></dt><dd><p>a factor specifying the class of each observation used for discriminant analysis.</p>
</dd>
<dt><code>responses</code></dt><dd><p>the matrix of responses (called Y in the model). Will usually be extracted from the corresponding field in PLNfamily-class</p>
</dd>
<dt><code>covariates</code></dt><dd><p>design matrix (called X in the model). Will usually be extracted from the corresponding field in PLNfamily-class</p>
</dd>
<dt><code>offsets</code></dt><dd><p>offset matrix (called O in the model). Will usually be extracted from the corresponding field in PLNfamily-class</p>
</dd>
<dt><code>weights</code></dt><dd><p>an optional vector of observation weights to be used in the fitting process.</p>
</dd>
<dt><code>formula</code></dt><dd><p>model formula used for fitting, extracted from the formula in the upper-level call</p>
</dd>
<dt><code>control</code></dt><dd><p>a list for controlling the optimization. See details.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-PLNLDAfit_spherical-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>PLNLDAfit_spherical$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(trichoptera)
trichoptera &lt;- prepare_data(trichoptera$Abundance, trichoptera$Covariate)
myPLN &lt;- PLN(Abundance ~ 1, data = trichoptera)
class(myPLN)
print(myPLN)

## End(Not run)
## Not run: 
data(trichoptera)
trichoptera &lt;- prepare_data(trichoptera$Abundance, trichoptera$Covariate)
myPLNLDA &lt;- PLNLDA(Abundance ~ 1, data = trichoptera, control = PLN_param(covariance = "spherical"))
class(myPLNLDA)
print(myPLNLDA)

## End(Not run)
</code></pre>

<hr>
<h2 id='PLNfit_fixedcov'>An R6 Class to represent a PLNfit in a standard, general framework, with fixed (inverse) residual covariance</h2><span id='topic+PLNfit_fixedcov'></span>

<h3>Description</h3>

<p>An R6 Class to represent a PLNfit in a standard, general framework, with fixed (inverse) residual covariance
</p>
<p>An R6 Class to represent a PLNfit in a standard, general framework, with fixed (inverse) residual covariance
</p>


<h3>Super class</h3>

<p><code><a href="#topic+PLNfit">PLNmodels::PLNfit</a></code> -&gt; <code>PLNfit_fixedcov</code>
</p>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>nb_param</code></dt><dd><p>number of parameters in the current PLN model</p>
</dd>
<dt><code>vcov_model</code></dt><dd><p>character: the model used for the residual covariance</p>
</dd>
<dt><code>vcov_coef</code></dt><dd><p>matrix of sandwich estimator of the variance-covariance of B (needs known covariance at the moment)</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-PLNfit_fixedcov-new"><code>PLNfit_fixedcov$new()</code></a>
</p>
</li>
<li> <p><a href="#method-PLNfit_fixedcov-optimize"><code>PLNfit_fixedcov$optimize()</code></a>
</p>
</li>
<li> <p><a href="#method-PLNfit_fixedcov-postTreatment"><code>PLNfit_fixedcov$postTreatment()</code></a>
</p>
</li>
<li> <p><a href="#method-PLNfit_fixedcov-clone"><code>PLNfit_fixedcov$clone()</code></a>
</p>
</li></ul>



<details><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="PLNmodels" data-topic="PLNfit" data-id="optimize_vestep"><a href='../../PLNmodels/html/PLNfit.html#method-PLNfit-optimize_vestep'><code>PLNmodels::PLNfit$optimize_vestep()</code></a></span></li>
<li><span class="pkg-link" data-pkg="PLNmodels" data-topic="PLNfit" data-id="predict"><a href='../../PLNmodels/html/PLNfit.html#method-PLNfit-predict'><code>PLNmodels::PLNfit$predict()</code></a></span></li>
<li><span class="pkg-link" data-pkg="PLNmodels" data-topic="PLNfit" data-id="predict_cond"><a href='../../PLNmodels/html/PLNfit.html#method-PLNfit-predict_cond'><code>PLNmodels::PLNfit$predict_cond()</code></a></span></li>
<li><span class="pkg-link" data-pkg="PLNmodels" data-topic="PLNfit" data-id="print"><a href='../../PLNmodels/html/PLNfit.html#method-PLNfit-print'><code>PLNmodels::PLNfit$print()</code></a></span></li>
<li><span class="pkg-link" data-pkg="PLNmodels" data-topic="PLNfit" data-id="show"><a href='../../PLNmodels/html/PLNfit.html#method-PLNfit-show'><code>PLNmodels::PLNfit$show()</code></a></span></li>
<li><span class="pkg-link" data-pkg="PLNmodels" data-topic="PLNfit" data-id="update"><a href='../../PLNmodels/html/PLNfit.html#method-PLNfit-update'><code>PLNmodels::PLNfit$update()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-PLNfit_fixedcov-new"></a>



<h4>Method <code>new()</code></h4>

<p>Initialize a <code><a href="#topic+PLNfit">PLNfit</a></code> model
</p>


<h5>Usage</h5>

<div class="r"><pre>PLNfit_fixedcov$new(responses, covariates, offsets, weights, formula, control)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>responses</code></dt><dd><p>the matrix of responses (called Y in the model). Will usually be extracted from the corresponding field in PLNfamily-class</p>
</dd>
<dt><code>covariates</code></dt><dd><p>design matrix (called X in the model). Will usually be extracted from the corresponding field in PLNfamily-class</p>
</dd>
<dt><code>offsets</code></dt><dd><p>offset matrix (called O in the model). Will usually be extracted from the corresponding field in PLNfamily-class</p>
</dd>
<dt><code>weights</code></dt><dd><p>an optional vector of observation weights to be used in the fitting process.</p>
</dd>
<dt><code>formula</code></dt><dd><p>model formula used for fitting, extracted from the formula in the upper-level call</p>
</dd>
<dt><code>control</code></dt><dd><p>a list for controlling the optimization. See details.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-PLNfit_fixedcov-optimize"></a>



<h4>Method <code>optimize()</code></h4>

<p>Call to the NLopt or TORCH optimizer and update of the relevant fields
</p>


<h5>Usage</h5>

<div class="r"><pre>PLNfit_fixedcov$optimize(responses, covariates, offsets, weights, config)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>responses</code></dt><dd><p>the matrix of responses (called Y in the model). Will usually be extracted from the corresponding field in PLNfamily-class</p>
</dd>
<dt><code>covariates</code></dt><dd><p>design matrix (called X in the model). Will usually be extracted from the corresponding field in PLNfamily-class</p>
</dd>
<dt><code>offsets</code></dt><dd><p>offset matrix (called O in the model). Will usually be extracted from the corresponding field in PLNfamily-class</p>
</dd>
<dt><code>weights</code></dt><dd><p>an optional vector of observation weights to be used in the fitting process.</p>
</dd>
<dt><code>config</code></dt><dd><p>part of the <code>control</code> argument which configures the optimizer</p>
</dd>
</dl>

</div>


<hr>
<a id="method-PLNfit_fixedcov-postTreatment"></a>



<h4>Method <code>postTreatment()</code></h4>

<p>Update R2, fisher and std_err fields after optimization
</p>


<h5>Usage</h5>

<div class="r"><pre>PLNfit_fixedcov$postTreatment(
  responses,
  covariates,
  offsets,
  weights = rep(1, nrow(responses)),
  config_post,
  config_optim,
  nullModel = NULL
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>responses</code></dt><dd><p>the matrix of responses (called Y in the model). Will usually be extracted from the corresponding field in PLNfamily-class</p>
</dd>
<dt><code>covariates</code></dt><dd><p>design matrix (called X in the model). Will usually be extracted from the corresponding field in PLNfamily-class</p>
</dd>
<dt><code>offsets</code></dt><dd><p>offset matrix (called O in the model). Will usually be extracted from the corresponding field in PLNfamily-class</p>
</dd>
<dt><code>weights</code></dt><dd><p>an optional vector of observation weights to be used in the fitting process.</p>
</dd>
<dt><code>config_post</code></dt><dd><p>a list for controlling the post-treatments (optional bootstrap, jackknife, R2, etc.). See details</p>
</dd>
<dt><code>config_optim</code></dt><dd><p>a list for controlling the optimization parameter. See details</p>
</dd>
<dt><code>nullModel</code></dt><dd><p>null model used for approximate R2 computations. Defaults to a GLM model with same design matrix but not latent variable.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>The list of parameters <code>config</code> controls the post-treatment processing, with the following entries:
</p>

<ul>
<li><p> trace integer for verbosity. should be &gt; 1 to see output in post-treatments
</p>
</li>
<li><p> jackknife boolean indicating whether jackknife should be performed to evaluate bias and variance of the model parameters. Default is FALSE.
</p>
</li>
<li><p> bootstrap integer indicating the number of bootstrap resamples generated to evaluate the variance of the model parameters. Default is 0 (inactivated).
</p>
</li>
<li><p> variational_var boolean indicating whether variational Fisher information matrix should be computed to estimate the variance of the model parameters (highly underestimated). Default is FALSE.
</p>
</li>
<li><p> rsquared boolean indicating whether approximation of R2 based on deviance should be computed. Default is TRUE
</p>
</li></ul>



<hr>
<a id="method-PLNfit_fixedcov-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>PLNfit_fixedcov$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(trichoptera)
trichoptera &lt;- prepare_data(trichoptera$Abundance, trichoptera$Covariate)
myPLN &lt;- PLN(Abundance ~ 1, data = trichoptera)
class(myPLN)
print(myPLN)

## End(Not run)
</code></pre>

<hr>
<h2 id='PLNfit_spherical'>An R6 Class to represent a PLNfit in a standard, general framework, with spherical residual covariance</h2><span id='topic+PLNfit_spherical'></span>

<h3>Description</h3>

<p>An R6 Class to represent a PLNfit in a standard, general framework, with spherical residual covariance
</p>
<p>An R6 Class to represent a PLNfit in a standard, general framework, with spherical residual covariance
</p>


<h3>Super class</h3>

<p><code><a href="#topic+PLNfit">PLNmodels::PLNfit</a></code> -&gt; <code>PLNfit_spherical</code>
</p>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>nb_param</code></dt><dd><p>number of parameters in the current PLN model</p>
</dd>
<dt><code>vcov_model</code></dt><dd><p>character: the model used for the residual covariance</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-PLNfit_spherical-new"><code>PLNfit_spherical$new()</code></a>
</p>
</li>
<li> <p><a href="#method-PLNfit_spherical-clone"><code>PLNfit_spherical$clone()</code></a>
</p>
</li></ul>



<details><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="PLNmodels" data-topic="PLNfit" data-id="optimize"><a href='../../PLNmodels/html/PLNfit.html#method-PLNfit-optimize'><code>PLNmodels::PLNfit$optimize()</code></a></span></li>
<li><span class="pkg-link" data-pkg="PLNmodels" data-topic="PLNfit" data-id="optimize_vestep"><a href='../../PLNmodels/html/PLNfit.html#method-PLNfit-optimize_vestep'><code>PLNmodels::PLNfit$optimize_vestep()</code></a></span></li>
<li><span class="pkg-link" data-pkg="PLNmodels" data-topic="PLNfit" data-id="postTreatment"><a href='../../PLNmodels/html/PLNfit.html#method-PLNfit-postTreatment'><code>PLNmodels::PLNfit$postTreatment()</code></a></span></li>
<li><span class="pkg-link" data-pkg="PLNmodels" data-topic="PLNfit" data-id="predict"><a href='../../PLNmodels/html/PLNfit.html#method-PLNfit-predict'><code>PLNmodels::PLNfit$predict()</code></a></span></li>
<li><span class="pkg-link" data-pkg="PLNmodels" data-topic="PLNfit" data-id="predict_cond"><a href='../../PLNmodels/html/PLNfit.html#method-PLNfit-predict_cond'><code>PLNmodels::PLNfit$predict_cond()</code></a></span></li>
<li><span class="pkg-link" data-pkg="PLNmodels" data-topic="PLNfit" data-id="print"><a href='../../PLNmodels/html/PLNfit.html#method-PLNfit-print'><code>PLNmodels::PLNfit$print()</code></a></span></li>
<li><span class="pkg-link" data-pkg="PLNmodels" data-topic="PLNfit" data-id="show"><a href='../../PLNmodels/html/PLNfit.html#method-PLNfit-show'><code>PLNmodels::PLNfit$show()</code></a></span></li>
<li><span class="pkg-link" data-pkg="PLNmodels" data-topic="PLNfit" data-id="update"><a href='../../PLNmodels/html/PLNfit.html#method-PLNfit-update'><code>PLNmodels::PLNfit$update()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-PLNfit_spherical-new"></a>



<h4>Method <code>new()</code></h4>

<p>Initialize a <code><a href="#topic+PLNfit">PLNfit</a></code> model
</p>


<h5>Usage</h5>

<div class="r"><pre>PLNfit_spherical$new(responses, covariates, offsets, weights, formula, control)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>responses</code></dt><dd><p>the matrix of responses (called Y in the model). Will usually be extracted from the corresponding field in PLNfamily-class</p>
</dd>
<dt><code>covariates</code></dt><dd><p>design matrix (called X in the model). Will usually be extracted from the corresponding field in PLNfamily-class</p>
</dd>
<dt><code>offsets</code></dt><dd><p>offset matrix (called O in the model). Will usually be extracted from the corresponding field in PLNfamily-class</p>
</dd>
<dt><code>weights</code></dt><dd><p>an optional vector of observation weights to be used in the fitting process.</p>
</dd>
<dt><code>formula</code></dt><dd><p>model formula used for fitting, extracted from the formula in the upper-level call</p>
</dd>
<dt><code>control</code></dt><dd><p>a list for controlling the optimization. See details.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-PLNfit_spherical-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>PLNfit_spherical$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(trichoptera)
trichoptera &lt;- prepare_data(trichoptera$Abundance, trichoptera$Covariate)
myPLN &lt;- PLN(Abundance ~ 1, data = trichoptera)
class(myPLN)
print(myPLN)

## End(Not run)
</code></pre>

<hr>
<h2 id='PLNLDA'>Poisson lognormal model towards Linear Discriminant Analysis</h2><span id='topic+PLNLDA'></span>

<h3>Description</h3>

<p>Fit the Poisson lognormal for LDA with a variational algorithm. Use the (g)lm syntax for model specification (covariates, offsets).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PLNLDA(formula, data, subset, weights, grouping, control = PLN_param())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PLNLDA_+3A_formula">formula</code></td>
<td>
<p>an object of class &quot;formula&quot;: a symbolic description of the model to be fitted.</p>
</td></tr>
<tr><td><code id="PLNLDA_+3A_data">data</code></td>
<td>
<p>an optional data frame, list or environment (or object coercible by as.data.frame to a data frame) containing the variables in the model. If not found in data, the variables are taken from environment(formula), typically the environment from which lm is called.</p>
</td></tr>
<tr><td><code id="PLNLDA_+3A_subset">subset</code></td>
<td>
<p>an optional vector specifying a subset of observations to be used in the fitting process.</p>
</td></tr>
<tr><td><code id="PLNLDA_+3A_weights">weights</code></td>
<td>
<p>an optional vector of observation weights to be used in the fitting process.</p>
</td></tr>
<tr><td><code id="PLNLDA_+3A_grouping">grouping</code></td>
<td>
<p>a factor specifying the class of each observation used for discriminant analysis.</p>
</td></tr>
<tr><td><code id="PLNLDA_+3A_control">control</code></td>
<td>
<p>a list-like structure for controlling the optimization, with default generated by <code><a href="#topic+PLN_param">PLN_param()</a></code>.  See the associated documentation</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The parameter <code>control</code> is a list controlling the optimization with the following entries:
</p>

<ul>
<li><p> &quot;covariance&quot; character setting the model for the covariance matrix. Either &quot;full&quot; or &quot;spherical&quot;. Default is &quot;full&quot;.
</p>
</li>
<li><p> &quot;trace&quot; integer for verbosity.
</p>
</li>
<li><p> &quot;inception&quot; Set up the initialization. By default, the model is initialized with a multivariate linear model applied on log-transformed data. However, the user can provide a PLNfit (typically obtained from a previous fit), which often speed up the inference.
</p>
</li>
<li><p> &quot;ftol_rel&quot; stop when an optimization step changes the objective function by less than ftol multiplied by the absolute value of the parameter. Default is 1e-8
</p>
</li>
<li><p> &quot;ftol_abs&quot; stop when an optimization step changes the objective function by less than ftol multiplied by the absolute value of the parameter. Default is 0
</p>
</li>
<li><p> &quot;xtol_rel&quot; stop when an optimization step changes every parameters by less than xtol multiplied by the absolute value of the parameter. Default is 1e-6
</p>
</li>
<li><p> &quot;xtol_abs&quot; stop when an optimization step changes every parameters by less than xtol multiplied by the absolute value of the parameter. Default is 0
</p>
</li>
<li><p> &quot;maxeval&quot; stop when the number of iteration exceeds maxeval. Default is 10000
</p>
</li>
<li><p> &quot;maxtime&quot; stop when the optimization time (in seconds) exceeds maxtime. Default is -1 (no restriction)
</p>
</li>
<li><p> &quot;algorithm&quot; the optimization method used by NLOPT among LD type, i.e. &quot;CCSAQ&quot;, &quot;MMA&quot;, &quot;LBFGS&quot;, &quot;VAR1&quot;, &quot;VAR2&quot;. See NLOPT documentation for further details. Default is &quot;CCSAQ&quot;.
</p>
</li></ul>



<h3>Value</h3>

<p>an R6 object with class <code><a href="#topic+PLNLDAfit">PLNLDAfit()</a></code>
</p>


<h3>See Also</h3>

<p>The class <code><a href="#topic+PLNLDAfit">PLNLDAfit</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(trichoptera)
trichoptera &lt;- prepare_data(trichoptera$Abundance, trichoptera$Covariate)
myPLNLDA &lt;- PLNLDA(Abundance ~ 1, grouping = Group, data = trichoptera)
</code></pre>

<hr>
<h2 id='PLNLDA_param'>Control of a PLNLDA fit</h2><span id='topic+PLNLDA_param'></span>

<h3>Description</h3>

<p>Helper to define list of parameters to control the PLNLDA fit. All arguments have defaults.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PLNLDA_param(
  backend = c("nlopt", "torch"),
  trace = 1,
  covariance = c("full", "diagonal", "spherical"),
  config_post = list(),
  config_optim = list(),
  inception = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PLNLDA_param_+3A_backend">backend</code></td>
<td>
<p>optimization back used, either &quot;nlopt&quot; or &quot;torch&quot;. Default is &quot;nlopt&quot;</p>
</td></tr>
<tr><td><code id="PLNLDA_param_+3A_trace">trace</code></td>
<td>
<p>a integer for verbosity.</p>
</td></tr>
<tr><td><code id="PLNLDA_param_+3A_covariance">covariance</code></td>
<td>
<p>character setting the model for the covariance matrix. Either &quot;full&quot;, &quot;diagonal&quot; or &quot;spherical&quot;. Default is &quot;full&quot;.</p>
</td></tr>
<tr><td><code id="PLNLDA_param_+3A_config_post">config_post</code></td>
<td>
<p>a list for controlling the post-treatments (optional bootstrap, jackknife, R2, etc.). See details</p>
</td></tr>
<tr><td><code id="PLNLDA_param_+3A_config_optim">config_optim</code></td>
<td>
<p>a list for controlling the optimizer (either &quot;nlopt&quot; or &quot;torch&quot; backend). See details</p>
</td></tr>
<tr><td><code id="PLNLDA_param_+3A_inception">inception</code></td>
<td>
<p>Set up the parameters initialization: by default, the model is initialized with a multivariate linear model applied on
log-transformed data, and with the same formula as the one provided by the user. However, the user can provide a PLNfit (typically obtained from a previous fit),
which sometimes speeds up the inference.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The list of parameters <code>config_optim</code> controls the optimizers. When &quot;nlopt&quot; is chosen the following entries are relevant
</p>

<ul>
<li><p> &quot;algorithm&quot; the optimization method used by NLOPT among LD type, e.g. &quot;CCSAQ&quot;, &quot;MMA&quot;, &quot;LBFGS&quot;. See NLOPT documentation for further details. Default is &quot;CCSAQ&quot;.
</p>
</li>
<li><p> &quot;maxeval&quot; stop when the number of iteration exceeds maxeval. Default is 10000
</p>
</li>
<li><p> &quot;ftol_rel&quot; stop when an optimization step changes the objective function by less than ftol multiplied by the absolute value of the parameter. Default is 1e-8
</p>
</li>
<li><p> &quot;xtol_rel&quot; stop when an optimization step changes every parameters by less than xtol multiplied by the absolute value of the parameter. Default is 1e-6
</p>
</li>
<li><p> &quot;ftol_abs&quot; stop when an optimization step changes the objective function by less than ftol_abs. Default is 0.0 (disabled)
</p>
</li>
<li><p> &quot;xtol_abs&quot; stop when an optimization step changes every parameters by less than xtol_abs. Default is 0.0 (disabled)
</p>
</li>
<li><p> &quot;maxtime&quot; stop when the optimization time (in seconds) exceeds maxtime. Default is -1 (disabled)
</p>
</li></ul>

<p>When &quot;torch&quot; backend is used (only for PLN and PLNLDA for now), the following entries are relevant:
</p>

<ul>
<li><p> &quot;algorithm&quot; the optimizer used by torch among RPROP (default), RMSPROP, ADAM and ADAGRAD
</p>
</li>
<li><p> &quot;maxeval&quot; stop when the number of iteration exceeds maxeval. Default is 10 000
</p>
</li>
<li><p> &quot;numepoch&quot; stop training once this number of epochs exceeds numepoch. Set to -1 to enable infinite training. Default is 1 000
</p>
</li>
<li><p> &quot;num_batch&quot; number of batches to use during training. Defaults to 1 (use full dataset at each epoch)
</p>
</li>
<li><p> &quot;ftol_rel&quot; stop when an optimization step changes the objective function by less than ftol multiplied by the absolute value of the parameter. Default is 1e-8
</p>
</li>
<li><p> &quot;xtol_rel&quot; stop when an optimization step changes every parameters by less than xtol multiplied by the absolute value of the parameter. Default is 1e-6
</p>
</li>
<li><p> &quot;lr&quot; learning rate. Default is 0.1.
</p>
</li>
<li><p> &quot;momentum&quot; momentum factor. Default is 0 (no momentum). Only used in RMSPROP
</p>
</li>
<li><p> &quot;weight_decay&quot; Weight decay penalty. Default is 0 (no decay). Not used in RPROP
</p>
</li>
<li><p> &quot;step_sizes&quot; pair of minimal (default: 1e-6) and maximal (default: 50) allowed step sizes. Only used in RPROP
</p>
</li>
<li><p> &quot;etas&quot; pair of multiplicative increase and decrease factors. Default is (0.5, 1.2). Only used in RPROP
</p>
</li>
<li><p> &quot;centered&quot; if TRUE, compute the centered RMSProp where the gradient is normalized by an estimation of its variance weight_decay (L2 penalty). Default to FALSE. Only used in RMSPROP
</p>
</li></ul>

<p>The list of parameters <code>config_post</code> controls the post-treatment processing (for most <code style="white-space: pre;">&#8288;PLN*()&#8288;</code> functions), with the following entries (defaults may vary depending on the specific function, check <code style="white-space: pre;">&#8288;config_post_default_*&#8288;</code> for defaults values):
</p>

<ul>
<li><p> jackknife boolean indicating whether jackknife should be performed to evaluate bias and variance of the model parameters. Default is FALSE.
</p>
</li>
<li><p> bootstrap integer indicating the number of bootstrap resamples generated to evaluate the variance of the model parameters. Default is 0 (inactivated).
</p>
</li>
<li><p> variational_var boolean indicating whether variational Fisher information matrix should be computed to estimate the variance of the model parameters (highly underestimated). Default is FALSE.
</p>
</li>
<li><p> sandwich_var boolean indicating whether sandwich estimation should be used to estimate the variance of the model parameters (highly underestimated). Default is FALSE.
</p>
</li>
<li><p> rsquared boolean indicating whether approximation of R2 based on deviance should be computed. Default is TRUE
</p>
</li></ul>



<h3>Value</h3>

<p>list of parameters configuring the fit.
</p>

<hr>
<h2 id='PLNLDAfit'>An R6 Class to represent a PLNfit in a LDA framework</h2><span id='topic+PLNLDAfit'></span>

<h3>Description</h3>

<p>The function <code><a href="#topic+PLNLDA">PLNLDA()</a></code> produces an instance of an object with class <code><a href="#topic+PLNLDAfit">PLNLDAfit</a></code>.
</p>
<p>This class comes with a set of methods, some of them being useful for the user:
See the documentation for the methods inherited by <code><a href="#topic+PLNfit">PLNfit()</a></code>, the <code><a href="graphics.html#topic+plot">plot()</a></code> method for
LDA visualization and <code><a href="stats.html#topic+predict">predict()</a></code> method for prediction
</p>


<h3>Super class</h3>

<p><code><a href="#topic+PLNfit">PLNmodels::PLNfit</a></code> -&gt; <code>PLNLDAfit</code>
</p>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>rank</code></dt><dd><p>the dimension of the current model</p>
</dd>
<dt><code>nb_param</code></dt><dd><p>number of parameters in the current PLN model</p>
</dd>
<dt><code>model_par</code></dt><dd><p>a list with the matrices associated with the estimated parameters of the PLN model: B (covariates), Sigma (latent covariance), C (latent loadings), P (latent position) and Mu (group means)</p>
</dd>
<dt><code>percent_var</code></dt><dd><p>the percent of variance explained by each axis</p>
</dd>
<dt><code>corr_map</code></dt><dd><p>a matrix of correlations to plot the correlation circles</p>
</dd>
<dt><code>scores</code></dt><dd><p>a matrix of scores to plot the individual factor maps</p>
</dd>
<dt><code>group_means</code></dt><dd><p>a matrix of group mean vectors in the latent space.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-PLNLDAfit-new"><code>PLNLDAfit$new()</code></a>
</p>
</li>
<li> <p><a href="#method-PLNLDAfit-optimize"><code>PLNLDAfit$optimize()</code></a>
</p>
</li>
<li> <p><a href="#method-PLNLDAfit-postTreatment"><code>PLNLDAfit$postTreatment()</code></a>
</p>
</li>
<li> <p><a href="#method-PLNLDAfit-setVisualization"><code>PLNLDAfit$setVisualization()</code></a>
</p>
</li>
<li> <p><a href="#method-PLNLDAfit-plot_individual_map"><code>PLNLDAfit$plot_individual_map()</code></a>
</p>
</li>
<li> <p><a href="#method-PLNLDAfit-plot_correlation_map"><code>PLNLDAfit$plot_correlation_map()</code></a>
</p>
</li>
<li> <p><a href="#method-PLNLDAfit-plot_LDA"><code>PLNLDAfit$plot_LDA()</code></a>
</p>
</li>
<li> <p><a href="#method-PLNLDAfit-predict"><code>PLNLDAfit$predict()</code></a>
</p>
</li>
<li> <p><a href="#method-PLNLDAfit-show"><code>PLNLDAfit$show()</code></a>
</p>
</li>
<li> <p><a href="#method-PLNLDAfit-clone"><code>PLNLDAfit$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="PLNmodels" data-topic="PLNfit" data-id="optimize_vestep"><a href='../../PLNmodels/html/PLNfit.html#method-PLNfit-optimize_vestep'><code>PLNmodels::PLNfit$optimize_vestep()</code></a></span></li>
<li><span class="pkg-link" data-pkg="PLNmodels" data-topic="PLNfit" data-id="predict_cond"><a href='../../PLNmodels/html/PLNfit.html#method-PLNfit-predict_cond'><code>PLNmodels::PLNfit$predict_cond()</code></a></span></li>
<li><span class="pkg-link" data-pkg="PLNmodels" data-topic="PLNfit" data-id="print"><a href='../../PLNmodels/html/PLNfit.html#method-PLNfit-print'><code>PLNmodels::PLNfit$print()</code></a></span></li>
<li><span class="pkg-link" data-pkg="PLNmodels" data-topic="PLNfit" data-id="update"><a href='../../PLNmodels/html/PLNfit.html#method-PLNfit-update'><code>PLNmodels::PLNfit$update()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-PLNLDAfit-new"></a>



<h4>Method <code>new()</code></h4>

<p>Initialize a <code><a href="#topic+PLNLDAfit">PLNLDAfit</a></code> object
</p>


<h5>Usage</h5>

<div class="r"><pre>PLNLDAfit$new(
  grouping,
  responses,
  covariates,
  offsets,
  weights,
  formula,
  control
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>grouping</code></dt><dd><p>a factor specifying the class of each observation used for discriminant analysis.</p>
</dd>
<dt><code>responses</code></dt><dd><p>the matrix of responses (called Y in the model). Will usually be extracted from the corresponding field in PLNfamily-class</p>
</dd>
<dt><code>covariates</code></dt><dd><p>design matrix (called X in the model). Will usually be extracted from the corresponding field in PLNfamily-class</p>
</dd>
<dt><code>offsets</code></dt><dd><p>offset matrix (called O in the model). Will usually be extracted from the corresponding field in PLNfamily-class</p>
</dd>
<dt><code>weights</code></dt><dd><p>an optional vector of observation weights to be used in the fitting process.</p>
</dd>
<dt><code>formula</code></dt><dd><p>model formula used for fitting, extracted from the formula in the upper-level call</p>
</dd>
<dt><code>control</code></dt><dd><p>list controlling the optimization and the model</p>
</dd>
</dl>

</div>


<hr>
<a id="method-PLNLDAfit-optimize"></a>



<h4>Method <code>optimize()</code></h4>

<p>Compute group means and axis of the LDA (noted B in the model) in the
latent space, update corresponding fields
</p>


<h5>Usage</h5>

<div class="r"><pre>PLNLDAfit$optimize(grouping, responses, covariates, offsets, weights, config)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>grouping</code></dt><dd><p>a factor specifying the class of each observation used for discriminant analysis.</p>
</dd>
<dt><code>responses</code></dt><dd><p>the matrix of responses (called Y in the model). Will usually be extracted from the corresponding field in PLNfamily-class</p>
</dd>
<dt><code>covariates</code></dt><dd><p>design matrix. Automatically built from the covariates and the formula from the call</p>
</dd>
<dt><code>offsets</code></dt><dd><p>offset matrix (called O in the model). Will usually be extracted from the corresponding field in PLNfamily-class</p>
</dd>
<dt><code>weights</code></dt><dd><p>an optional vector of observation weights to be used in the fitting process.</p>
</dd>
<dt><code>config</code></dt><dd><p>list controlling the optimization</p>
</dd>
<dt><code>X</code></dt><dd><p>Abundance matrix.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-PLNLDAfit-postTreatment"></a>



<h4>Method <code>postTreatment()</code></h4>

<p>Update R2, fisher and std_err fields and visualization
</p>


<h5>Usage</h5>

<div class="r"><pre>PLNLDAfit$postTreatment(
  grouping,
  responses,
  covariates,
  offsets,
  config_post,
  config_optim
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>grouping</code></dt><dd><p>a factor specifying the class of each observation used for discriminant analysis.</p>
</dd>
<dt><code>responses</code></dt><dd><p>the matrix of responses (called Y in the model). Will usually be extracted from the corresponding field in PLNfamily-class</p>
</dd>
<dt><code>covariates</code></dt><dd><p>design matrix (called X in the model). Will usually be extracted from the corresponding field in PLNfamily-class</p>
</dd>
<dt><code>offsets</code></dt><dd><p>offset matrix (called O in the model). Will usually be extracted from the corresponding field in PLNfamily-class</p>
</dd>
<dt><code>config_post</code></dt><dd><p>a list for controlling the post-treatments (optional bootstrap, jackknife, R2, etc.).</p>
</dd>
<dt><code>config_optim</code></dt><dd><p>list controlling the optimization parameters</p>
</dd>
</dl>

</div>


<hr>
<a id="method-PLNLDAfit-setVisualization"></a>



<h4>Method <code>setVisualization()</code></h4>

<p>Compute LDA scores in the latent space and update corresponding fields.
</p>


<h5>Usage</h5>

<div class="r"><pre>PLNLDAfit$setVisualization(scale.unit = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>scale.unit</code></dt><dd><p>Logical. Should LDA scores be rescaled to have unit variance</p>
</dd>
</dl>

</div>


<hr>
<a id="method-PLNLDAfit-plot_individual_map"></a>



<h4>Method <code>plot_individual_map()</code></h4>

<p>Plot the factorial map of the LDA
</p>


<h5>Usage</h5>

<div class="r"><pre>PLNLDAfit$plot_individual_map(
  axes = 1:min(2, self$rank),
  main = "Individual Factor Map",
  plot = TRUE
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>axes</code></dt><dd><p>numeric, the axes to use for the plot when map = &quot;individual&quot; or &quot;variable&quot;. Default it c(1,min(rank))</p>
</dd>
<dt><code>main</code></dt><dd><p>character. A title for the single plot (individual or variable factor map). If NULL (the default), an hopefully appropriate title will be used.</p>
</dd>
<dt><code>plot</code></dt><dd><p>logical. Should the plot be displayed or sent back as ggplot object</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>a <code><a href="ggplot2.html#topic+ggplot">ggplot</a></code> graphic
</p>


<hr>
<a id="method-PLNLDAfit-plot_correlation_map"></a>



<h4>Method <code>plot_correlation_map()</code></h4>

<p>Plot the correlation circle of a specified axis for a <code><a href="#topic+PLNLDAfit">PLNLDAfit</a></code> object
</p>


<h5>Usage</h5>

<div class="r"><pre>PLNLDAfit$plot_correlation_map(
  axes = 1:min(2, self$rank),
  main = "Variable Factor Map",
  cols = "default",
  plot = TRUE
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>axes</code></dt><dd><p>numeric, the axes to use for the plot when map = &quot;individual&quot; or &quot;variable&quot;. Default it c(1,min(rank))</p>
</dd>
<dt><code>main</code></dt><dd><p>character. A title for the single plot (individual or variable factor map). If NULL (the default), an hopefully appropriate title will be used.</p>
</dd>
<dt><code>cols</code></dt><dd><p>a character, factor or numeric to define the color associated with the variables. By default, all variables receive the default color of the current palette.</p>
</dd>
<dt><code>plot</code></dt><dd><p>logical. Should the plot be displayed or sent back as ggplot object</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>a <code><a href="ggplot2.html#topic+ggplot">ggplot</a></code> graphic
</p>


<hr>
<a id="method-PLNLDAfit-plot_LDA"></a>



<h4>Method <code>plot_LDA()</code></h4>

<p>Plot a summary of the <code><a href="#topic+PLNLDAfit">PLNLDAfit</a></code> object
</p>


<h5>Usage</h5>

<div class="r"><pre>PLNLDAfit$plot_LDA(
  nb_axes = min(3, self$rank),
  var_cols = "default",
  plot = TRUE
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>nb_axes</code></dt><dd><p>scalar: the number of axes to be considered when map = &quot;both&quot;. The default is min(3,rank).</p>
</dd>
<dt><code>var_cols</code></dt><dd><p>a character, factor or numeric to define the color associated with the variables. By default, all variables receive the default color of the current palette.</p>
</dd>
<dt><code>plot</code></dt><dd><p>logical. Should the plot be displayed or sent back as ggplot object</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>a <code><a href="grid.html#topic+grob">grob</a></code> object
</p>


<hr>
<a id="method-PLNLDAfit-predict"></a>



<h4>Method <code>predict()</code></h4>

<p>Predict group of new samples
</p>


<h5>Usage</h5>

<div class="r"><pre>PLNLDAfit$predict(
  newdata,
  type = c("posterior", "response", "scores"),
  scale = c("log", "prob"),
  prior = NULL,
  control = PLN_param(backend = "nlopt"),
  envir = parent.frame()
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>newdata</code></dt><dd><p>A data frame in which to look for variables, offsets and counts  with which to predict.</p>
</dd>
<dt><code>type</code></dt><dd><p>The type of prediction required. The default are posterior probabilities for each group (in either unnormalized log-scale or natural probabilities, see &quot;scale&quot; for details), &quot;response&quot; is the group with maximal posterior probability and &quot;scores&quot; is the average score along each separation axis in the latent space, with weights equal to the posterior probabilities.</p>
</dd>
<dt><code>scale</code></dt><dd><p>The scale used for the posterior probability. Either log-scale (&quot;log&quot;, default) or natural probabilities summing up to 1 (&quot;prob&quot;).</p>
</dd>
<dt><code>prior</code></dt><dd><p>User-specified prior group probabilities in the new data. If NULL (default), prior probabilities are computed from the learning set.</p>
</dd>
<dt><code>control</code></dt><dd><p>a list for controlling the optimization. See <code><a href="#topic+PLN">PLN()</a></code> for details.</p>
</dd>
<dt><code>envir</code></dt><dd><p>Environment in which the prediction is evaluated</p>
</dd>
</dl>

</div>


<hr>
<a id="method-PLNLDAfit-show"></a>



<h4>Method <code>show()</code></h4>

<p>User friendly print method
</p>


<h5>Usage</h5>

<div class="r"><pre>PLNLDAfit$show()</pre></div>


<hr>
<a id="method-PLNLDAfit-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>PLNLDAfit$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p>The function <code><a href="#topic+PLNLDA">PLNLDA</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(trichoptera)
trichoptera &lt;- prepare_data(trichoptera$Abundance, trichoptera$Covariate)
myPLNLDA &lt;- PLNLDA(Abundance ~ 1, grouping = Group, data = trichoptera)
class(myPLNLDA)
print(myPLNLDA)

## End(Not run)
</code></pre>

<hr>
<h2 id='PLNLDAfit_diagonal'>An R6 Class to represent a PLNfit in a LDA framework with diagonal covariance</h2><span id='topic+PLNLDAfit_diagonal'></span>

<h3>Description</h3>

<p>The function <code><a href="#topic+PLNLDA">PLNLDA()</a></code> produces an instance of an object with class <code><a href="#topic+PLNLDAfit">PLNLDAfit</a></code>.
</p>
<p>This class comes with a set of methods, some of them being useful for the user:
See the documentation for the methods inherited by <code><a href="#topic+PLNfit">PLNfit()</a></code>, the <code><a href="graphics.html#topic+plot">plot()</a></code> method for
LDA visualization and <code><a href="stats.html#topic+predict">predict()</a></code> method for prediction
</p>


<h3>Super classes</h3>

<p><code><a href="#topic+PLNfit">PLNmodels::PLNfit</a></code> -&gt; <code><a href="#topic+PLNLDAfit">PLNmodels::PLNLDAfit</a></code> -&gt; <code>PLNLDAfit_diagonal</code>
</p>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>vcov_model</code></dt><dd><p>character: the model used for the residual covariance</p>
</dd>
<dt><code>nb_param</code></dt><dd><p>number of parameters in the current PLN model</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-PLNLDAfit_diagonal-new"><code>PLNLDAfit_diagonal$new()</code></a>
</p>
</li>
<li> <p><a href="#method-PLNLDAfit_diagonal-clone"><code>PLNLDAfit_diagonal$clone()</code></a>
</p>
</li></ul>



<details><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="PLNmodels" data-topic="PLNfit" data-id="optimize_vestep"><a href='../../PLNmodels/html/PLNfit.html#method-PLNfit-optimize_vestep'><code>PLNmodels::PLNfit$optimize_vestep()</code></a></span></li>
<li><span class="pkg-link" data-pkg="PLNmodels" data-topic="PLNfit" data-id="predict_cond"><a href='../../PLNmodels/html/PLNfit.html#method-PLNfit-predict_cond'><code>PLNmodels::PLNfit$predict_cond()</code></a></span></li>
<li><span class="pkg-link" data-pkg="PLNmodels" data-topic="PLNfit" data-id="print"><a href='../../PLNmodels/html/PLNfit.html#method-PLNfit-print'><code>PLNmodels::PLNfit$print()</code></a></span></li>
<li><span class="pkg-link" data-pkg="PLNmodels" data-topic="PLNfit" data-id="update"><a href='../../PLNmodels/html/PLNfit.html#method-PLNfit-update'><code>PLNmodels::PLNfit$update()</code></a></span></li>
<li><span class="pkg-link" data-pkg="PLNmodels" data-topic="PLNLDAfit" data-id="optimize"><a href='../../PLNmodels/html/PLNLDAfit.html#method-PLNLDAfit-optimize'><code>PLNmodels::PLNLDAfit$optimize()</code></a></span></li>
<li><span class="pkg-link" data-pkg="PLNmodels" data-topic="PLNLDAfit" data-id="plot_LDA"><a href='../../PLNmodels/html/PLNLDAfit.html#method-PLNLDAfit-plot_LDA'><code>PLNmodels::PLNLDAfit$plot_LDA()</code></a></span></li>
<li><span class="pkg-link" data-pkg="PLNmodels" data-topic="PLNLDAfit" data-id="plot_correlation_map"><a href='../../PLNmodels/html/PLNLDAfit.html#method-PLNLDAfit-plot_correlation_map'><code>PLNmodels::PLNLDAfit$plot_correlation_map()</code></a></span></li>
<li><span class="pkg-link" data-pkg="PLNmodels" data-topic="PLNLDAfit" data-id="plot_individual_map"><a href='../../PLNmodels/html/PLNLDAfit.html#method-PLNLDAfit-plot_individual_map'><code>PLNmodels::PLNLDAfit$plot_individual_map()</code></a></span></li>
<li><span class="pkg-link" data-pkg="PLNmodels" data-topic="PLNLDAfit" data-id="postTreatment"><a href='../../PLNmodels/html/PLNLDAfit.html#method-PLNLDAfit-postTreatment'><code>PLNmodels::PLNLDAfit$postTreatment()</code></a></span></li>
<li><span class="pkg-link" data-pkg="PLNmodels" data-topic="PLNLDAfit" data-id="predict"><a href='../../PLNmodels/html/PLNLDAfit.html#method-PLNLDAfit-predict'><code>PLNmodels::PLNLDAfit$predict()</code></a></span></li>
<li><span class="pkg-link" data-pkg="PLNmodels" data-topic="PLNLDAfit" data-id="setVisualization"><a href='../../PLNmodels/html/PLNLDAfit.html#method-PLNLDAfit-setVisualization'><code>PLNmodels::PLNLDAfit$setVisualization()</code></a></span></li>
<li><span class="pkg-link" data-pkg="PLNmodels" data-topic="PLNLDAfit" data-id="show"><a href='../../PLNmodels/html/PLNLDAfit.html#method-PLNLDAfit-show'><code>PLNmodels::PLNLDAfit$show()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-PLNLDAfit_diagonal-new"></a>



<h4>Method <code>new()</code></h4>

<p>Initialize a <code><a href="#topic+PLNfit">PLNfit</a></code> model
</p>


<h5>Usage</h5>

<div class="r"><pre>PLNLDAfit_diagonal$new(
  grouping,
  responses,
  covariates,
  offsets,
  weights,
  formula,
  control
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>grouping</code></dt><dd><p>a factor specifying the class of each observation used for discriminant analysis.</p>
</dd>
<dt><code>responses</code></dt><dd><p>the matrix of responses (called Y in the model). Will usually be extracted from the corresponding field in PLNfamily-class</p>
</dd>
<dt><code>covariates</code></dt><dd><p>design matrix (called X in the model). Will usually be extracted from the corresponding field in PLNfamily-class</p>
</dd>
<dt><code>offsets</code></dt><dd><p>offset matrix (called O in the model). Will usually be extracted from the corresponding field in PLNfamily-class</p>
</dd>
<dt><code>weights</code></dt><dd><p>an optional vector of observation weights to be used in the fitting process.</p>
</dd>
<dt><code>formula</code></dt><dd><p>model formula used for fitting, extracted from the formula in the upper-level call</p>
</dd>
<dt><code>control</code></dt><dd><p>a list for controlling the optimization. See details.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-PLNLDAfit_diagonal-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>PLNLDAfit_diagonal$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(trichoptera)
trichoptera &lt;- prepare_data(trichoptera$Abundance, trichoptera$Covariate)
myPLNLDA &lt;- PLNLDA(Abundance ~ 1, data = trichoptera, control = PLN_param(covariance = "diagonal"))
class(myPLNLDA)
print(myPLNLDA)

## End(Not run)
</code></pre>

<hr>
<h2 id='PLNmixture'>Poisson lognormal mixture model</h2><span id='topic+PLNmixture'></span>

<h3>Description</h3>

<p>Fit the mixture variants of the Poisson lognormal with a variational algorithm. Use the (g)lm syntax for model specification (covariates, offsets).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PLNmixture(formula, data, subset, clusters = 1:5, control = PLNmixture_param())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PLNmixture_+3A_formula">formula</code></td>
<td>
<p>an object of class &quot;formula&quot;: a symbolic description of the model to be fitted.</p>
</td></tr>
<tr><td><code id="PLNmixture_+3A_data">data</code></td>
<td>
<p>an optional data frame, list or environment (or object coercible by as.data.frame to a data frame) containing the variables in the model. If not found in data, the variables are taken from environment(formula), typically the environment from which lm is called.</p>
</td></tr>
<tr><td><code id="PLNmixture_+3A_subset">subset</code></td>
<td>
<p>an optional vector specifying a subset of observations to be used in the fitting process.</p>
</td></tr>
<tr><td><code id="PLNmixture_+3A_clusters">clusters</code></td>
<td>
<p>a vector of integer containing the successive number of clusters (or components) to be considered</p>
</td></tr>
<tr><td><code id="PLNmixture_+3A_control">control</code></td>
<td>
<p>a list-like structure for controlling the optimization, with default generated by <code><a href="#topic+PLNmixture_param">PLNmixture_param()</a></code>. See the associated documentation
for details.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an R6 object with class <code><a href="#topic+PLNmixturefamily">PLNmixturefamily</a></code>, which contains
a collection of models with class <code><a href="#topic+PLNmixturefit">PLNmixturefit</a></code>
</p>


<h3>See Also</h3>

<p>The classes <code><a href="#topic+PLNmixturefamily">PLNmixturefamily</a></code>, <code><a href="#topic+PLNmixturefit">PLNmixturefit</a></code> and <code><a href="#topic+PLNmixture_param">PLNmixture_param()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Use future to dispatch the computations on 2 workers
## Not run: 
future::plan("multisession", workers = 2)

## End(Not run)

data(trichoptera)
trichoptera &lt;- prepare_data(trichoptera$Abundance, trichoptera$Covariate)
myMixtures &lt;- PLNmixture(Abundance ~ 1 + offset(log(Offset)), clusters = 1:4, data = trichoptera,
                         control = PLNmixture_param(smoothing = 'none'))

# Shut down parallel workers
## Not run: 
future::plan("sequential")

## End(Not run)
</code></pre>

<hr>
<h2 id='PLNmixture_param'>Control of a PLNmixture fit</h2><span id='topic+PLNmixture_param'></span>

<h3>Description</h3>

<p>Helper to define list of parameters to control the PLNmixture fit. All arguments have defaults.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PLNmixture_param(
  backend = "nlopt",
  trace = 1,
  covariance = "spherical",
  init_cl = "kmeans",
  smoothing = "both",
  config_optim = list(),
  config_post = list(),
  inception = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PLNmixture_param_+3A_backend">backend</code></td>
<td>
<p>optimization back used, either &quot;nlopt&quot; or &quot;torch&quot;. Default is &quot;nlopt&quot;</p>
</td></tr>
<tr><td><code id="PLNmixture_param_+3A_trace">trace</code></td>
<td>
<p>a integer for verbosity.</p>
</td></tr>
<tr><td><code id="PLNmixture_param_+3A_covariance">covariance</code></td>
<td>
<p>character setting the model for the covariance matrices of the mixture components. Either &quot;full&quot;, &quot;diagonal&quot; or &quot;spherical&quot;. Default is &quot;spherical&quot;.</p>
</td></tr>
<tr><td><code id="PLNmixture_param_+3A_init_cl">init_cl</code></td>
<td>
<p>The initial clustering to apply. Either, 'kmeans', CAH' or a user defined clustering given as a list of  clusterings, the size of which is equal to the number of clusters considered. Default is 'kmeans'.</p>
</td></tr>
<tr><td><code id="PLNmixture_param_+3A_smoothing">smoothing</code></td>
<td>
<p>The smoothing to apply. Either, 'none', forward', 'backward' or 'both'. Default is 'both'.</p>
</td></tr>
<tr><td><code id="PLNmixture_param_+3A_config_optim">config_optim</code></td>
<td>
<p>a list for controlling the optimizer (either &quot;nlopt&quot; or &quot;torch&quot; backend). See details</p>
</td></tr>
<tr><td><code id="PLNmixture_param_+3A_config_post">config_post</code></td>
<td>
<p>a list for controlling the post-treatments (optional bootstrap, jackknife, R2, etc.).</p>
</td></tr>
<tr><td><code id="PLNmixture_param_+3A_inception">inception</code></td>
<td>
<p>Set up the parameters initialization: by default, the model is initialized with a multivariate linear model applied on
log-transformed data, and with the same formula as the one provided by the user. However, the user can provide a PLNfit (typically obtained from a previous fit),
which sometimes speeds up the inference.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <code><a href="#topic+PLN_param">PLN_param()</a></code> for a full description of the generic optimization parameters. PLNmixture_param() also has additional parameters controlling the optimization due the inner-outer loop structure of the optimizer:
</p>

<ul>
<li><p> &quot;ftol_out&quot; outer solver stops when an optimization step changes the objective function by less than xtol multiplied by the absolute value of the parameter. Default is 1e-6
</p>
</li>
<li><p> &quot;maxit_out&quot; outer solver stops when the number of iteration exceeds maxit_out. Default is 50
</p>
</li>
<li><p> &quot;it_smoothing&quot; number of the iterations of the smoothing procedure. Default is 1.
</p>
</li></ul>



<h3>Value</h3>

<p>list of parameters configuring the fit.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+PLN_param">PLN_param()</a></code>
</p>

<hr>
<h2 id='PLNmixturefamily'>An R6 Class to represent a collection of PLNmixturefit</h2><span id='topic+PLNmixturefamily'></span>

<h3>Description</h3>

<p>The function <code><a href="#topic+PLNmixture">PLNmixture()</a></code> produces an instance of this class.
</p>
<p>This class comes with a set of methods, some of them being useful for the user:
See the documentation for <code><a href="#topic+getBestModel">getBestModel()</a></code>, <code><a href="#topic+getModel">getModel()</a></code> and <code><a href="#topic+plot.PLNmixturefamily">plot()</a></code>.
</p>


<h3>Super class</h3>

<p><code><a href="#topic+PLNfamily">PLNmodels::PLNfamily</a></code> -&gt; <code>PLNmixturefamily</code>
</p>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>clusters</code></dt><dd><p>vector indicating the number of clusters considered is the successively fitted models</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-PLNmixturefamily-new"><code>PLNmixturefamily$new()</code></a>
</p>
</li>
<li> <p><a href="#method-PLNmixturefamily-optimize"><code>PLNmixturefamily$optimize()</code></a>
</p>
</li>
<li> <p><a href="#method-PLNmixturefamily-smooth"><code>PLNmixturefamily$smooth()</code></a>
</p>
</li>
<li> <p><a href="#method-PLNmixturefamily-plot"><code>PLNmixturefamily$plot()</code></a>
</p>
</li>
<li> <p><a href="#method-PLNmixturefamily-plot_objective"><code>PLNmixturefamily$plot_objective()</code></a>
</p>
</li>
<li> <p><a href="#method-PLNmixturefamily-getBestModel"><code>PLNmixturefamily$getBestModel()</code></a>
</p>
</li>
<li> <p><a href="#method-PLNmixturefamily-show"><code>PLNmixturefamily$show()</code></a>
</p>
</li>
<li> <p><a href="#method-PLNmixturefamily-print"><code>PLNmixturefamily$print()</code></a>
</p>
</li>
<li> <p><a href="#method-PLNmixturefamily-clone"><code>PLNmixturefamily$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="PLNmodels" data-topic="PLNfamily" data-id="getModel"><a href='../../PLNmodels/html/PLNfamily.html#method-PLNfamily-getModel'><code>PLNmodels::PLNfamily$getModel()</code></a></span></li>
<li><span class="pkg-link" data-pkg="PLNmodels" data-topic="PLNfamily" data-id="postTreatment"><a href='../../PLNmodels/html/PLNfamily.html#method-PLNfamily-postTreatment'><code>PLNmodels::PLNfamily$postTreatment()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-PLNmixturefamily-new"></a>



<h4>Method <code>new()</code></h4>

<p>helper function for forward smoothing: split a group
</p>
<p>Initialize all models in the collection.
</p>


<h5>Usage</h5>

<div class="r"><pre>PLNmixturefamily$new(
  clusters,
  responses,
  covariates,
  offsets,
  formula,
  control
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>clusters</code></dt><dd><p>the dimensions of the successively fitted models</p>
</dd>
<dt><code>responses</code></dt><dd><p>the matrix of responses common to every models</p>
</dd>
<dt><code>covariates</code></dt><dd><p>the matrix of covariates common to every models</p>
</dd>
<dt><code>offsets</code></dt><dd><p>the matrix of offsets common to every models</p>
</dd>
<dt><code>formula</code></dt><dd><p>model formula used for fitting, extracted from the formula in the upper-level call</p>
</dd>
<dt><code>control</code></dt><dd><p>a list for controlling the optimization. See details.</p>
</dd>
<dt><code>control</code></dt><dd><p>a list for controlling the optimization. See details.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-PLNmixturefamily-optimize"></a>



<h4>Method <code>optimize()</code></h4>

<p>Call to the optimizer on all models of the collection
</p>


<h5>Usage</h5>

<div class="r"><pre>PLNmixturefamily$optimize(config)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>config</code></dt><dd><p>a list for controlling the optimization</p>
</dd>
</dl>

</div>


<hr>
<a id="method-PLNmixturefamily-smooth"></a>



<h4>Method <code>smooth()</code></h4>

<p>function to restart clustering to avoid local minima by smoothing the loglikelihood values as a function of the number of clusters
</p>


<h5>Usage</h5>

<div class="r"><pre>PLNmixturefamily$smooth(control)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>control</code></dt><dd><p>a list to control the smoothing process</p>
</dd>
</dl>

</div>


<hr>
<a id="method-PLNmixturefamily-plot"></a>



<h4>Method <code>plot()</code></h4>

<p>Lineplot of selected criteria for all models in the collection
</p>


<h5>Usage</h5>

<div class="r"><pre>PLNmixturefamily$plot(criteria = c("loglik", "BIC", "ICL"), reverse = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>criteria</code></dt><dd><p>A valid model selection criteria for the collection of models. Any of &quot;loglik&quot;, &quot;BIC&quot; or &quot;ICL&quot; (all).</p>
</dd>
<dt><code>reverse</code></dt><dd><p>A logical indicating whether to plot the value of the criteria in the &quot;natural&quot; direction
(loglik - 0.5 penalty) or in the &quot;reverse&quot; direction (-2 loglik + penalty). Default to FALSE, i.e use the
natural direction, on the same scale as the log-likelihood..</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A <code><a href="ggplot2.html#topic+ggplot2">ggplot2</a></code> object
</p>


<hr>
<a id="method-PLNmixturefamily-plot_objective"></a>



<h4>Method <code>plot_objective()</code></h4>

<p>Plot objective value of the optimization problem along the penalty path
</p>


<h5>Usage</h5>

<div class="r"><pre>PLNmixturefamily$plot_objective()</pre></div>



<h5>Returns</h5>

<p>a <code><a href="ggplot2.html#topic+ggplot">ggplot</a></code> graph
</p>


<hr>
<a id="method-PLNmixturefamily-getBestModel"></a>



<h4>Method <code>getBestModel()</code></h4>

<p>Extract best model in the collection
</p>


<h5>Usage</h5>

<div class="r"><pre>PLNmixturefamily$getBestModel(crit = c("BIC", "ICL", "loglik"))</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>crit</code></dt><dd><p>a character for the criterion used to performed the selection. Either
&quot;BIC&quot;, &quot;ICL&quot; or &quot;loglik&quot;. Default is <code>ICL</code></p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>a <code><a href="#topic+PLNmixturefit">PLNmixturefit</a></code> object
</p>


<hr>
<a id="method-PLNmixturefamily-show"></a>



<h4>Method <code>show()</code></h4>

<p>User friendly print method
</p>


<h5>Usage</h5>

<div class="r"><pre>PLNmixturefamily$show()</pre></div>


<hr>
<a id="method-PLNmixturefamily-print"></a>



<h4>Method <code>print()</code></h4>

<p>User friendly print method
</p>


<h5>Usage</h5>

<div class="r"><pre>PLNmixturefamily$print()</pre></div>


<hr>
<a id="method-PLNmixturefamily-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>PLNmixturefamily$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p>The function <code><a href="#topic+PLNmixture">PLNmixture</a></code>, the class <code><a href="#topic+PLNmixturefit">PLNmixturefit</a></code>
</p>

<hr>
<h2 id='PLNmixturefit'>An R6 Class to represent a PLNfit in a mixture framework</h2><span id='topic+PLNmixturefit'></span>

<h3>Description</h3>

<p>The function <code><a href="#topic+PLNmixture">PLNmixture</a></code> produces a collection of models which are instances of object with class <code>PLNmixturefit</code>.
A <code>PLNmixturefit</code> (say, with k components) is itself a collection of k <code>PLNfit</code>.
</p>
<p>This class comes with a set of methods, some of them being useful for the user:
See the documentation for ...
</p>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>n</code></dt><dd><p>number of samples</p>
</dd>
<dt><code>p</code></dt><dd><p>number of dimensions of the latent space</p>
</dd>
<dt><code>k</code></dt><dd><p>number of components</p>
</dd>
<dt><code>d</code></dt><dd><p>number of covariates</p>
</dd>
<dt><code>components</code></dt><dd><p>components of the mixture (PLNfits)</p>
</dd>
<dt><code>latent</code></dt><dd><p>a matrix: values of the latent vector (Z in the model)</p>
</dd>
<dt><code>latent_pos</code></dt><dd><p>a matrix: values of the latent position vector (Z) without covariates effects or offset</p>
</dd>
<dt><code>posteriorProb</code></dt><dd><p>matrix ofposterior probability for cluster belonging</p>
</dd>
<dt><code>memberships</code></dt><dd><p>vector for cluster index</p>
</dd>
<dt><code>mixtureParam</code></dt><dd><p>vector of cluster proportions</p>
</dd>
<dt><code>optim_par</code></dt><dd><p>a list with parameters useful for monitoring the optimization</p>
</dd>
<dt><code>nb_param</code></dt><dd><p>number of parameters in the current PLN model</p>
</dd>
<dt><code>entropy_clustering</code></dt><dd><p>Entropy of the variational distribution of the cluster (multinomial)</p>
</dd>
<dt><code>entropy_latent</code></dt><dd><p>Entropy of the variational distribution of the latent vector (Gaussian)</p>
</dd>
<dt><code>entropy</code></dt><dd><p>Full entropy of the variational distribution (latent vector + clustering)</p>
</dd>
<dt><code>loglik</code></dt><dd><p>variational lower bound of the loglikelihood</p>
</dd>
<dt><code>loglik_vec</code></dt><dd><p>element-wise variational lower bound of the loglikelihood</p>
</dd>
<dt><code>BIC</code></dt><dd><p>variational lower bound of the BIC</p>
</dd>
<dt><code>ICL</code></dt><dd><p>variational lower bound of the ICL (include entropy of both the clustering and latent distributions)</p>
</dd>
<dt><code>R_squared</code></dt><dd><p>approximated goodness-of-fit criterion</p>
</dd>
<dt><code>criteria</code></dt><dd><p>a vector with loglik, BIC, ICL, and number of parameters</p>
</dd>
<dt><code>model_par</code></dt><dd><p>a list with the matrices of parameters found in the model (Theta, Sigma, Mu and Pi)</p>
</dd>
<dt><code>vcov_model</code></dt><dd><p>character: the model used for the covariance (either &quot;spherical&quot;, &quot;diagonal&quot; or &quot;full&quot;)</p>
</dd>
<dt><code>fitted</code></dt><dd><p>a matrix: fitted values of the observations (A in the model)</p>
</dd>
<dt><code>group_means</code></dt><dd><p>a matrix of group mean vectors in the latent space.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-PLNmixturefit-new"><code>PLNmixturefit$new()</code></a>
</p>
</li>
<li> <p><a href="#method-PLNmixturefit-optimize"><code>PLNmixturefit$optimize()</code></a>
</p>
</li>
<li> <p><a href="#method-PLNmixturefit-predict"><code>PLNmixturefit$predict()</code></a>
</p>
</li>
<li> <p><a href="#method-PLNmixturefit-plot_clustering_data"><code>PLNmixturefit$plot_clustering_data()</code></a>
</p>
</li>
<li> <p><a href="#method-PLNmixturefit-plot_clustering_pca"><code>PLNmixturefit$plot_clustering_pca()</code></a>
</p>
</li>
<li> <p><a href="#method-PLNmixturefit-postTreatment"><code>PLNmixturefit$postTreatment()</code></a>
</p>
</li>
<li> <p><a href="#method-PLNmixturefit-show"><code>PLNmixturefit$show()</code></a>
</p>
</li>
<li> <p><a href="#method-PLNmixturefit-print"><code>PLNmixturefit$print()</code></a>
</p>
</li>
<li> <p><a href="#method-PLNmixturefit-clone"><code>PLNmixturefit$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-PLNmixturefit-new"></a>



<h4>Method <code>new()</code></h4>

<p>Optimize a the
</p>
<p>Initialize a <code><a href="#topic+PLNmixturefit">PLNmixturefit</a></code> model
</p>


<h5>Usage</h5>

<div class="r"><pre>PLNmixturefit$new(
  responses,
  covariates,
  offsets,
  posteriorProb,
  formula,
  control
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>responses</code></dt><dd><p>the matrix of responses common to every models</p>
</dd>
<dt><code>covariates</code></dt><dd><p>the matrix of covariates common to every models</p>
</dd>
<dt><code>offsets</code></dt><dd><p>the matrix of offsets common to every models</p>
</dd>
<dt><code>posteriorProb</code></dt><dd><p>matrix ofposterior probability for cluster belonging</p>
</dd>
<dt><code>formula</code></dt><dd><p>model formula used for fitting, extracted from the formula in the upper-level call</p>
</dd>
<dt><code>control</code></dt><dd><p>a list for controlling the optimization.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-PLNmixturefit-optimize"></a>



<h4>Method <code>optimize()</code></h4>

<p>Optimize a <code><a href="#topic+PLNmixturefit">PLNmixturefit</a></code> model
</p>


<h5>Usage</h5>

<div class="r"><pre>PLNmixturefit$optimize(responses, covariates, offsets, config)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>responses</code></dt><dd><p>the matrix of responses common to every models</p>
</dd>
<dt><code>covariates</code></dt><dd><p>the matrix of covariates common to every models</p>
</dd>
<dt><code>offsets</code></dt><dd><p>the matrix of offsets common to every models</p>
</dd>
<dt><code>config</code></dt><dd><p>a list for controlling the optimization</p>
</dd>
</dl>

</div>


<hr>
<a id="method-PLNmixturefit-predict"></a>



<h4>Method <code>predict()</code></h4>

<p>Predict group of new samples
</p>


<h5>Usage</h5>

<div class="r"><pre>PLNmixturefit$predict(
  newdata,
  type = c("posterior", "response", "position"),
  prior = matrix(rep(1/self$k, self$k), nrow(newdata), self$k, byrow = TRUE),
  control = PLNmixture_param(),
  envir = parent.frame()
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>newdata</code></dt><dd><p>A data frame in which to look for variables, offsets and counts with which to predict.</p>
</dd>
<dt><code>type</code></dt><dd><p>The type of prediction required. The default <code>posterior</code> are posterior probabilities for each group ,
<code>response</code> is the group with maximal posterior probability and <code>latent</code> is the averaged latent coordinate (without
offset and nor covariate effects),
with weights equal to the posterior probabilities.</p>
</dd>
<dt><code>prior</code></dt><dd><p>User-specified prior group probabilities in the new data. The default uses a uniform prior.</p>
</dd>
<dt><code>control</code></dt><dd><p>a list-like structure for controlling the fit. See <code><a href="#topic+PLNmixture_param">PLNmixture_param()</a></code> for details.</p>
</dd>
<dt><code>envir</code></dt><dd><p>Environment in which the prediction is evaluated</p>
</dd>
</dl>

</div>


<hr>
<a id="method-PLNmixturefit-plot_clustering_data"></a>



<h4>Method <code>plot_clustering_data()</code></h4>

<p>Plot the matrix of expected mean counts (without offsets, without covariate effects) reordered according the inferred clustering
</p>


<h5>Usage</h5>

<div class="r"><pre>PLNmixturefit$plot_clustering_data(
  main = "Expected counts reorder by clustering",
  plot = TRUE,
  log_scale = TRUE
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>main</code></dt><dd><p>character. A title for the plot.  An hopefully appropriate title will be used by default.</p>
</dd>
<dt><code>plot</code></dt><dd><p>logical. Should the plot be displayed or sent back as <code><a href="ggplot2.html#topic+ggplot">ggplot</a></code> object</p>
</dd>
<dt><code>log_scale</code></dt><dd><p>logical. Should the color scale values be log-transform before plotting? Default is <code>TRUE</code>.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>a <code><a href="ggplot2.html#topic+ggplot">ggplot</a></code> graphic
</p>


<hr>
<a id="method-PLNmixturefit-plot_clustering_pca"></a>



<h4>Method <code>plot_clustering_pca()</code></h4>

<p>Plot the individual map of a PCA performed on the latent coordinates, where individuals are colored according to the memberships
</p>


<h5>Usage</h5>

<div class="r"><pre>PLNmixturefit$plot_clustering_pca(
  main = "Clustering labels in Individual Factor Map",
  plot = TRUE
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>main</code></dt><dd><p>character. A title for the plot. An hopefully appropriate title will be used by default.</p>
</dd>
<dt><code>plot</code></dt><dd><p>logical. Should the plot be displayed or sent back as <code><a href="ggplot2.html#topic+ggplot">ggplot</a></code> object</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>a <code><a href="ggplot2.html#topic+ggplot">ggplot</a></code> graphic
</p>


<hr>
<a id="method-PLNmixturefit-postTreatment"></a>



<h4>Method <code>postTreatment()</code></h4>

<p>Update fields after optimization
</p>


<h5>Usage</h5>

<div class="r"><pre>PLNmixturefit$postTreatment(
  responses,
  covariates,
  offsets,
  weights,
  config_post,
  config_optim,
  nullModel
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>responses</code></dt><dd><p>the matrix of responses common to every models</p>
</dd>
<dt><code>covariates</code></dt><dd><p>the matrix of covariates common to every models</p>
</dd>
<dt><code>offsets</code></dt><dd><p>the matrix of offsets common to every models</p>
</dd>
<dt><code>weights</code></dt><dd><p>an optional vector of observation weights to be used in the fitting process.</p>
</dd>
<dt><code>config_post</code></dt><dd><p>a list for controlling the post-treatment</p>
</dd>
<dt><code>config_optim</code></dt><dd><p>a list for controlling the optimization during the post-treatment computations</p>
</dd>
<dt><code>nullModel</code></dt><dd><p>null model used for approximate R2 computations. Defaults to a GLM model with same design matrix but not latent variable.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-PLNmixturefit-show"></a>



<h4>Method <code>show()</code></h4>

<p>User friendly print method
</p>


<h5>Usage</h5>

<div class="r"><pre>PLNmixturefit$show()</pre></div>


<hr>
<a id="method-PLNmixturefit-print"></a>



<h4>Method <code>print()</code></h4>

<p>User friendly print method
</p>


<h5>Usage</h5>

<div class="r"><pre>PLNmixturefit$print()</pre></div>


<hr>
<a id="method-PLNmixturefit-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>PLNmixturefit$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p>The function <code><a href="#topic+PLNmixture">PLNmixture</a></code>, the class <code><a href="#topic+PLNmixturefamily">PLNmixturefamily</a></code>
</p>

<hr>
<h2 id='PLNmodels-package'>PLNmodels: Poisson Lognormal Models</h2><span id='topic+PLNmodels'></span><span id='topic+PLNmodels-package'></span>

<h3>Description</h3>

<p><img src="../help/figures/logo.png" style='float: right' alt='logo' width='120' />
</p>
<p>The Poisson-lognormal model and variants (Chiquet, Mariadassou and Robin, 2021 <a href="https://doi.org/10.3389/fevo.2021.588292">doi:10.3389/fevo.2021.588292</a>) can be used for a variety of multivariate problems when count data are at play, including principal component analysis for count data, discriminant analysis, model-based clustering and network inference. Implements variational algorithms to fit such models accompanied with a set of functions for visualization and diagnostic.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Julien Chiquet <a href="mailto:julien.chiquet@inrae.fr">julien.chiquet@inrae.fr</a> (<a href="https://orcid.org/0000-0002-3629-3429">ORCID</a>)
</p>
<p>Authors:
</p>

<ul>
<li><p> Mahendra Mariadassou <a href="mailto:mahendra.mariadassou@inrae.fr">mahendra.mariadassou@inrae.fr</a> (<a href="https://orcid.org/0000-0003-2986-354X">ORCID</a>)
</p>
</li>
<li><p> Stéphane Robin <a href="mailto:stephane.robin@inrae.fr">stephane.robin@inrae.fr</a>
</p>
</li>
<li><p> François Gindraud <a href="mailto:francois.gindraud@gmail.com">francois.gindraud@gmail.com</a>
</p>
</li></ul>

<p>Other contributors:
</p>

<ul>
<li><p> Julie Aubert <a href="mailto:julie.aubert@inrae.fr">julie.aubert@inrae.fr</a> [contributor]
</p>
</li>
<li><p> Bastien Batardière <a href="mailto:bastien.batardiere@inrae.fr">bastien.batardiere@inrae.fr</a> [contributor]
</p>
</li>
<li><p> Giovanni Poggiato <a href="mailto:giov.poggiato@gmail.com">giov.poggiato@gmail.com</a> [contributor]
</p>
</li>
<li><p> Cole Trapnell <a href="mailto:coletrap@uw.edu">coletrap@uw.edu</a> [contributor]
</p>
</li>
<li><p> Maddy Duran <a href="mailto:duran@uw.edu">duran@uw.edu</a> [contributor]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://pln-team.github.io/PLNmodels/">https://pln-team.github.io/PLNmodels/</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/pln-team/PLNmodels/issues">https://github.com/pln-team/PLNmodels/issues</a>
</p>
</li></ul>


<hr>
<h2 id='PLNnetwork'>Sparse Poisson lognormal model for network inference</h2><span id='topic+PLNnetwork'></span>

<h3>Description</h3>

<p>Perform sparse inverse covariance estimation for the Zero Inflated Poisson lognormal model
using a variational algorithm. Iterate over a range of logarithmically spaced sparsity parameter values.
Use the (g)lm syntax to specify the model (including covariates and offsets).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PLNnetwork(
  formula,
  data,
  subset,
  weights,
  penalties = NULL,
  control = PLNnetwork_param()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PLNnetwork_+3A_formula">formula</code></td>
<td>
<p>an object of class &quot;formula&quot;: a symbolic description of the model to be fitted.</p>
</td></tr>
<tr><td><code id="PLNnetwork_+3A_data">data</code></td>
<td>
<p>an optional data frame, list or environment (or object coercible by as.data.frame to a data frame) containing the variables in the model. If not found in data, the variables are taken from environment(formula), typically the environment from which lm is called.</p>
</td></tr>
<tr><td><code id="PLNnetwork_+3A_subset">subset</code></td>
<td>
<p>an optional vector specifying a subset of observations to be used in the fitting process.</p>
</td></tr>
<tr><td><code id="PLNnetwork_+3A_weights">weights</code></td>
<td>
<p>an optional vector of observation weights to be used in the fitting process.</p>
</td></tr>
<tr><td><code id="PLNnetwork_+3A_penalties">penalties</code></td>
<td>
<p>an optional vector of positive real number controlling the level of sparsity of the underlying network. if NULL (the default), will be set internally. See <code>PLNnetwork_param()</code> for additional tuning of the penalty.</p>
</td></tr>
<tr><td><code id="PLNnetwork_+3A_control">control</code></td>
<td>
<p>a list-like structure for controlling the optimization, with default generated by <code><a href="#topic+PLNnetwork_param">PLNnetwork_param()</a></code>. See the corresponding documentation for details;</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an R6 object with class <code><a href="#topic+PLNnetworkfamily">PLNnetworkfamily</a></code>, which contains
a collection of models with class <code><a href="#topic+PLNnetworkfit">PLNnetworkfit</a></code>
</p>


<h3>See Also</h3>

<p>The classes <code><a href="#topic+PLNnetworkfamily">PLNnetworkfamily</a></code> and <code><a href="#topic+PLNnetworkfit">PLNnetworkfit</a></code>, and the and the configuration function <code><a href="#topic+PLNnetwork_param">PLNnetwork_param()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(trichoptera)
trichoptera &lt;- prepare_data(trichoptera$Abundance, trichoptera$Covariate)
fits &lt;- PLNnetwork(Abundance ~ 1, data = trichoptera)
</code></pre>

<hr>
<h2 id='PLNnetwork_param'>Control of PLNnetwork fit</h2><span id='topic+PLNnetwork_param'></span>

<h3>Description</h3>

<p>Helper to define list of parameters to control the PLN fit. All arguments have defaults.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PLNnetwork_param(
  backend = c("nlopt", "torch"),
  inception_cov = c("full", "spherical", "diagonal"),
  trace = 1,
  n_penalties = 30,
  min_ratio = 0.1,
  penalize_diagonal = TRUE,
  penalty_weights = NULL,
  config_post = list(),
  config_optim = list(),
  inception = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PLNnetwork_param_+3A_backend">backend</code></td>
<td>
<p>optimization back used, either &quot;nlopt&quot; or &quot;torch&quot;. Default is &quot;nlopt&quot;</p>
</td></tr>
<tr><td><code id="PLNnetwork_param_+3A_inception_cov">inception_cov</code></td>
<td>
<p>Covariance structure used for the inception model used to initialize the PLNfamily. Defaults to &quot;full&quot; and can be constrained to &quot;diagonal&quot; and &quot;spherical&quot;.</p>
</td></tr>
<tr><td><code id="PLNnetwork_param_+3A_trace">trace</code></td>
<td>
<p>a integer for verbosity.</p>
</td></tr>
<tr><td><code id="PLNnetwork_param_+3A_n_penalties">n_penalties</code></td>
<td>
<p>an integer that specifies the number of values for the penalty grid when internally generated. Ignored when penalties is non <code>NULL</code></p>
</td></tr>
<tr><td><code id="PLNnetwork_param_+3A_min_ratio">min_ratio</code></td>
<td>
<p>the penalty grid ranges from the minimal value that produces a sparse to this value multiplied by <code>min_ratio</code>. Default is 0.1.</p>
</td></tr>
<tr><td><code id="PLNnetwork_param_+3A_penalize_diagonal">penalize_diagonal</code></td>
<td>
<p>boolean: should the diagonal terms be penalized in the graphical-Lasso? Default is <code>TRUE</code></p>
</td></tr>
<tr><td><code id="PLNnetwork_param_+3A_penalty_weights">penalty_weights</code></td>
<td>
<p>either a single or a list of p x p matrix of weights (default: all weights equal to 1) to adapt the amount of shrinkage to each pairs of node. Must be symmetric with positive values.</p>
</td></tr>
<tr><td><code id="PLNnetwork_param_+3A_config_post">config_post</code></td>
<td>
<p>a list for controlling the post-treatment (optional bootstrap, jackknife, R2, etc).</p>
</td></tr>
<tr><td><code id="PLNnetwork_param_+3A_config_optim">config_optim</code></td>
<td>
<p>a list for controlling the optimizer (either &quot;nlopt&quot; or &quot;torch&quot; backend). See details</p>
</td></tr>
<tr><td><code id="PLNnetwork_param_+3A_inception">inception</code></td>
<td>
<p>Set up the parameters initialization: by default, the model is initialized with a multivariate linear model applied on
log-transformed data, and with the same formula as the one provided by the user. However, the user can provide a PLNfit (typically obtained from a previous fit),
which sometimes speeds up the inference.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <code><a href="#topic+PLN_param">PLN_param()</a></code> for a full description of the generic optimization parameters. PLNnetwork_param() also has two additional parameters controlling the optimization due the inner-outer loop structure of the optimizer:
</p>

<ul>
<li><p> &quot;ftol_out&quot; outer solver stops when an optimization step changes the objective function by less than ftol multiplied by the absolute value of the parameter. Default is 1e-6
</p>
</li>
<li><p> &quot;maxit_out&quot; outer solver stops when the number of iteration exceeds maxit_out. Default is 50
</p>
</li></ul>



<h3>Value</h3>

<p>list of parameters configuring the fit.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+PLN_param">PLN_param()</a></code>
</p>

<hr>
<h2 id='PLNnetworkfamily'>An R6 Class to represent a collection of <code><a href="#topic+PLNnetworkfit">PLNnetworkfit</a></code>s</h2><span id='topic+PLNnetworkfamily'></span>

<h3>Description</h3>

<p>The function <code><a href="#topic+PLNnetwork">PLNnetwork()</a></code> produces an instance of this class.
</p>
<p>This class comes with a set of methods mostly used to compare
network fits (in terms of goodness of fit) or extract one from
the family (based on penalty parameter and/or goodness of it).
See the documentation for <code><a href="#topic+getBestModel">getBestModel()</a></code>,
<code><a href="#topic+getModel">getModel()</a></code> and <a href="#topic+plot.Networkfamily">plot()</a> for the user-facing ones.
</p>


<h3>Super classes</h3>

<p><code><a href="#topic+PLNfamily">PLNmodels::PLNfamily</a></code> -&gt; <code><a href="#topic+Networkfamily">PLNmodels::Networkfamily</a></code> -&gt; <code>PLNnetworkfamily</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-PLNnetworkfamily-new"><code>PLNnetworkfamily$new()</code></a>
</p>
</li>
<li> <p><a href="#method-PLNnetworkfamily-stability_selection"><code>PLNnetworkfamily$stability_selection()</code></a>
</p>
</li>
<li> <p><a href="#method-PLNnetworkfamily-clone"><code>PLNnetworkfamily$clone()</code></a>
</p>
</li></ul>



<details><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="PLNmodels" data-topic="PLNfamily" data-id="getModel"><a href='../../PLNmodels/html/PLNfamily.html#method-PLNfamily-getModel'><code>PLNmodels::PLNfamily$getModel()</code></a></span></li>
<li><span class="pkg-link" data-pkg="PLNmodels" data-topic="PLNfamily" data-id="postTreatment"><a href='../../PLNmodels/html/PLNfamily.html#method-PLNfamily-postTreatment'><code>PLNmodels::PLNfamily$postTreatment()</code></a></span></li>
<li><span class="pkg-link" data-pkg="PLNmodels" data-topic="PLNfamily" data-id="print"><a href='../../PLNmodels/html/PLNfamily.html#method-PLNfamily-print'><code>PLNmodels::PLNfamily$print()</code></a></span></li>
<li><span class="pkg-link" data-pkg="PLNmodels" data-topic="Networkfamily" data-id="coefficient_path"><a href='../../PLNmodels/html/Networkfamily.html#method-Networkfamily-coefficient_path'><code>PLNmodels::Networkfamily$coefficient_path()</code></a></span></li>
<li><span class="pkg-link" data-pkg="PLNmodels" data-topic="Networkfamily" data-id="getBestModel"><a href='../../PLNmodels/html/Networkfamily.html#method-Networkfamily-getBestModel'><code>PLNmodels::Networkfamily$getBestModel()</code></a></span></li>
<li><span class="pkg-link" data-pkg="PLNmodels" data-topic="Networkfamily" data-id="optimize"><a href='../../PLNmodels/html/Networkfamily.html#method-Networkfamily-optimize'><code>PLNmodels::Networkfamily$optimize()</code></a></span></li>
<li><span class="pkg-link" data-pkg="PLNmodels" data-topic="Networkfamily" data-id="plot"><a href='../../PLNmodels/html/Networkfamily.html#method-Networkfamily-plot'><code>PLNmodels::Networkfamily$plot()</code></a></span></li>
<li><span class="pkg-link" data-pkg="PLNmodels" data-topic="Networkfamily" data-id="plot_objective"><a href='../../PLNmodels/html/Networkfamily.html#method-Networkfamily-plot_objective'><code>PLNmodels::Networkfamily$plot_objective()</code></a></span></li>
<li><span class="pkg-link" data-pkg="PLNmodels" data-topic="Networkfamily" data-id="plot_stars"><a href='../../PLNmodels/html/Networkfamily.html#method-Networkfamily-plot_stars'><code>PLNmodels::Networkfamily$plot_stars()</code></a></span></li>
<li><span class="pkg-link" data-pkg="PLNmodels" data-topic="Networkfamily" data-id="show"><a href='../../PLNmodels/html/Networkfamily.html#method-Networkfamily-show'><code>PLNmodels::Networkfamily$show()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-PLNnetworkfamily-new"></a>



<h4>Method <code>new()</code></h4>

<p>Initialize all models in the collection
</p>


<h5>Usage</h5>

<div class="r"><pre>PLNnetworkfamily$new(penalties, data, control)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>penalties</code></dt><dd><p>a vector of positive real number controlling the level of sparsity of the underlying network.</p>
</dd>
<dt><code>data</code></dt><dd><p>a named list used internally to carry the data matrices</p>
</dd>
<dt><code>control</code></dt><dd><p>a list for controlling the optimization.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>Update current <code><a href="#topic+PLNnetworkfit">PLNnetworkfit</a></code> with smart starting values
</p>


<hr>
<a id="method-PLNnetworkfamily-stability_selection"></a>



<h4>Method <code>stability_selection()</code></h4>

<p>Compute the stability path by stability selection
</p>


<h5>Usage</h5>

<div class="r"><pre>PLNnetworkfamily$stability_selection(
  subsamples = NULL,
  control = PLNnetwork_param()
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>subsamples</code></dt><dd><p>a list of vectors describing the subsamples. The number of vectors (or list length) determines the number of subsamples used in the stability selection. Automatically set to 20 subsamples with size <code>10*sqrt(n)</code> if <code>n &gt;= 144</code> and <code>0.8*n</code> otherwise following Liu et al. (2010) recommendations.</p>
</dd>
<dt><code>control</code></dt><dd><p>a list controlling the main optimization process in each call to <code><a href="#topic+PLNnetwork">PLNnetwork()</a></code>. See <code><a href="#topic+PLNnetwork">PLNnetwork()</a></code> and <code><a href="#topic+PLN_param">PLN_param()</a></code> for details.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-PLNnetworkfamily-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>PLNnetworkfamily$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p>The function <code><a href="#topic+PLNnetwork">PLNnetwork()</a></code>, the class <code><a href="#topic+PLNnetworkfit">PLNnetworkfit</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(trichoptera)
trichoptera &lt;- prepare_data(trichoptera$Abundance, trichoptera$Covariate)
fits &lt;- PLNnetwork(Abundance ~ 1, data = trichoptera)
class(fits)
</code></pre>

<hr>
<h2 id='PLNnetworkfit'>An R6 Class to represent a PLNfit in a sparse inverse covariance framework</h2><span id='topic+PLNnetworkfit'></span>

<h3>Description</h3>

<p>The function <code><a href="#topic+PLNnetwork">PLNnetwork()</a></code> produces a collection of models which are instances of object with class <code><a href="#topic+PLNnetworkfit">PLNnetworkfit</a></code>.
This class comes with a set of methods, some of them being useful for the user:
See the documentation for <code><a href="#topic+plot.PLNnetworkfit">plot()</a></code> and methods inherited from <code><a href="#topic+PLNfit">PLNfit</a></code>.
</p>


<h3>Super classes</h3>

<p><code><a href="#topic+PLNfit">PLNmodels::PLNfit</a></code> -&gt; <code><a href="#topic+PLNfit_fixedcov">PLNmodels::PLNfit_fixedcov</a></code> -&gt; <code>PLNnetworkfit</code>
</p>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>vcov_model</code></dt><dd><p>character: the model used for the residual covariance</p>
</dd>
<dt><code>penalty</code></dt><dd><p>the global level of sparsity in the current model</p>
</dd>
<dt><code>penalty_weights</code></dt><dd><p>a matrix of weights controlling the amount of penalty element-wise.</p>
</dd>
<dt><code>n_edges</code></dt><dd><p>number of edges if the network (non null coefficient of the sparse precision matrix)</p>
</dd>
<dt><code>nb_param</code></dt><dd><p>number of parameters in the current PLN model</p>
</dd>
<dt><code>pen_loglik</code></dt><dd><p>variational lower bound of the l1-penalized loglikelihood</p>
</dd>
<dt><code>EBIC</code></dt><dd><p>variational lower bound of the EBIC</p>
</dd>
<dt><code>density</code></dt><dd><p>proportion of non-null edges in the network</p>
</dd>
<dt><code>criteria</code></dt><dd><p>a vector with loglik, penalized loglik, BIC, EBIC, ICL, R_squared, number of parameters, number of edges and graph density</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-PLNnetworkfit-new"><code>PLNnetworkfit$new()</code></a>
</p>
</li>
<li> <p><a href="#method-PLNnetworkfit-optimize"><code>PLNnetworkfit$optimize()</code></a>
</p>
</li>
<li> <p><a href="#method-PLNnetworkfit-latent_network"><code>PLNnetworkfit$latent_network()</code></a>
</p>
</li>
<li> <p><a href="#method-PLNnetworkfit-plot_network"><code>PLNnetworkfit$plot_network()</code></a>
</p>
</li>
<li> <p><a href="#method-PLNnetworkfit-show"><code>PLNnetworkfit$show()</code></a>
</p>
</li>
<li> <p><a href="#method-PLNnetworkfit-clone"><code>PLNnetworkfit$clone()</code></a>
</p>
</li></ul>



<details><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="PLNmodels" data-topic="PLNfit" data-id="optimize_vestep"><a href='../../PLNmodels/html/PLNfit.html#method-PLNfit-optimize_vestep'><code>PLNmodels::PLNfit$optimize_vestep()</code></a></span></li>
<li><span class="pkg-link" data-pkg="PLNmodels" data-topic="PLNfit" data-id="predict"><a href='../../PLNmodels/html/PLNfit.html#method-PLNfit-predict'><code>PLNmodels::PLNfit$predict()</code></a></span></li>
<li><span class="pkg-link" data-pkg="PLNmodels" data-topic="PLNfit" data-id="predict_cond"><a href='../../PLNmodels/html/PLNfit.html#method-PLNfit-predict_cond'><code>PLNmodels::PLNfit$predict_cond()</code></a></span></li>
<li><span class="pkg-link" data-pkg="PLNmodels" data-topic="PLNfit" data-id="print"><a href='../../PLNmodels/html/PLNfit.html#method-PLNfit-print'><code>PLNmodels::PLNfit$print()</code></a></span></li>
<li><span class="pkg-link" data-pkg="PLNmodels" data-topic="PLNfit" data-id="update"><a href='../../PLNmodels/html/PLNfit.html#method-PLNfit-update'><code>PLNmodels::PLNfit$update()</code></a></span></li>
<li><span class="pkg-link" data-pkg="PLNmodels" data-topic="PLNfit_fixedcov" data-id="postTreatment"><a href='../../PLNmodels/html/PLNfit_fixedcov.html#method-PLNfit_fixedcov-postTreatment'><code>PLNmodels::PLNfit_fixedcov$postTreatment()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-PLNnetworkfit-new"></a>



<h4>Method <code>new()</code></h4>

<p>Initialize a <code><a href="#topic+PLNnetworkfit">PLNnetworkfit</a></code> object
</p>


<h5>Usage</h5>

<div class="r"><pre>PLNnetworkfit$new(data, control)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>data</code></dt><dd><p>a named list used internally to carry the data matrices</p>
</dd>
<dt><code>control</code></dt><dd><p>a list for controlling the optimization.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-PLNnetworkfit-optimize"></a>



<h4>Method <code>optimize()</code></h4>

<p>Call to the C++ optimizer and update of the relevant fields
</p>


<h5>Usage</h5>

<div class="r"><pre>PLNnetworkfit$optimize(data, config)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>data</code></dt><dd><p>a named list used internally to carry the data matrices</p>
</dd>
<dt><code>config</code></dt><dd><p>a list for controlling the optimization</p>
</dd>
</dl>

</div>


<hr>
<a id="method-PLNnetworkfit-latent_network"></a>



<h4>Method <code>latent_network()</code></h4>

<p>Extract interaction network in the latent space
</p>


<h5>Usage</h5>

<div class="r"><pre>PLNnetworkfit$latent_network(type = c("partial_cor", "support", "precision"))</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>type</code></dt><dd><p>edge value in the network. Can be &quot;support&quot; (binary edges), &quot;precision&quot; (coefficient of the precision matrix) or &quot;partial_cor&quot; (partial correlation between species)</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>a square matrix of size <code>PLNnetworkfit$n</code>
</p>


<hr>
<a id="method-PLNnetworkfit-plot_network"></a>



<h4>Method <code>plot_network()</code></h4>

<p>plot the latent network.
</p>


<h5>Usage</h5>

<div class="r"><pre>PLNnetworkfit$plot_network(
  type = c("partial_cor", "support"),
  output = c("igraph", "corrplot"),
  edge.color = c("#F8766D", "#00BFC4"),
  remove.isolated = FALSE,
  node.labels = NULL,
  layout = layout_in_circle,
  plot = TRUE
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>type</code></dt><dd><p>edge value in the network. Either &quot;precision&quot; (coefficient of the precision matrix) or &quot;partial_cor&quot; (partial correlation between species).</p>
</dd>
<dt><code>output</code></dt><dd><p>Output type. Either <code>igraph</code> (for the network) or <code>corrplot</code> (for the adjacency matrix)</p>
</dd>
<dt><code>edge.color</code></dt><dd><p>Length 2 color vector. Color for positive/negative edges. Default is <code>c("#F8766D", "#00BFC4")</code>. Only relevant for igraph output.</p>
</dd>
<dt><code>remove.isolated</code></dt><dd><p>if <code>TRUE</code>, isolated node are remove before plotting. Only relevant for igraph output.</p>
</dd>
<dt><code>node.labels</code></dt><dd><p>vector of character. The labels of the nodes. The default will use the column names ot the response matrix.</p>
</dd>
<dt><code>layout</code></dt><dd><p>an optional igraph layout. Only relevant for igraph output.</p>
</dd>
<dt><code>plot</code></dt><dd><p>logical. Should the final network be displayed or only sent back to the user. Default is <code>TRUE</code>.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-PLNnetworkfit-show"></a>



<h4>Method <code>show()</code></h4>

<p>User friendly print method
</p>


<h5>Usage</h5>

<div class="r"><pre>PLNnetworkfit$show()</pre></div>


<hr>
<a id="method-PLNnetworkfit-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>PLNnetworkfit$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p>The function <code><a href="#topic+PLNnetwork">PLNnetwork()</a></code>, the class <code><a href="#topic+PLNnetworkfamily">PLNnetworkfamily</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(trichoptera)
trichoptera &lt;- prepare_data(trichoptera$Abundance, trichoptera$Covariate)
nets &lt;- PLNnetwork(Abundance ~ 1, data = trichoptera)
myPLNnet &lt;- getBestModel(nets)
class(myPLNnet)
print(myPLNnet)

## End(Not run)
</code></pre>

<hr>
<h2 id='PLNPCA'>Poisson lognormal model towards Principal Component Analysis</h2><span id='topic+PLNPCA'></span>

<h3>Description</h3>

<p>Fit the PCA variants of the Poisson lognormal with a variational algorithm. Use the (g)lm syntax for model specification (covariates, offsets).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PLNPCA(formula, data, subset, weights, ranks = 1:5, control = PLNPCA_param())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PLNPCA_+3A_formula">formula</code></td>
<td>
<p>an object of class &quot;formula&quot;: a symbolic description of the model to be fitted.</p>
</td></tr>
<tr><td><code id="PLNPCA_+3A_data">data</code></td>
<td>
<p>an optional data frame, list or environment (or object coercible by as.data.frame to a data frame) containing the variables in the model. If not found in data, the variables are taken from environment(formula), typically the environment from which lm is called.</p>
</td></tr>
<tr><td><code id="PLNPCA_+3A_subset">subset</code></td>
<td>
<p>an optional vector specifying a subset of observations to be used in the fitting process.</p>
</td></tr>
<tr><td><code id="PLNPCA_+3A_weights">weights</code></td>
<td>
<p>an optional vector of observation weights to be used in the fitting process.</p>
</td></tr>
<tr><td><code id="PLNPCA_+3A_ranks">ranks</code></td>
<td>
<p>a vector of integer containing the successive ranks (or number of axes to be considered)</p>
</td></tr>
<tr><td><code id="PLNPCA_+3A_control">control</code></td>
<td>
<p>a list-like structure for controlling the optimization, with default generated by <code><a href="#topic+PLNPCA_param">PLNPCA_param()</a></code>.  See the associated documentation.
for details.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an R6 object with class <code><a href="#topic+PLNPCAfamily">PLNPCAfamily</a></code>, which contains
a collection of models with class <code><a href="#topic+PLNPCAfit">PLNPCAfit</a></code>
</p>


<h3>See Also</h3>

<p>The classes <code><a href="#topic+PLNPCAfamily">PLNPCAfamily</a></code> and <code><a href="#topic+PLNPCAfit">PLNPCAfit</a></code>, and the configuration function <code><a href="#topic+PLNPCA_param">PLNPCA_param()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#' ## Use future to dispatch the computations on 2 workers
## Not run: 
future::plan("multisession", workers = 2)

## End(Not run)

data(trichoptera)
trichoptera &lt;- prepare_data(trichoptera$Abundance, trichoptera$Covariate)
myPCA &lt;- PLNPCA(Abundance ~ 1 + offset(log(Offset)), data = trichoptera, ranks = 1:5)

# Shut down parallel workers
## Not run: 
future::plan("sequential")

## End(Not run)
</code></pre>

<hr>
<h2 id='PLNPCA_param'>Control of PLNPCA fit</h2><span id='topic+PLNPCA_param'></span>

<h3>Description</h3>

<p>Helper to define list of parameters to control the PLNPCA fit. All arguments have defaults.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PLNPCA_param(
  backend = "nlopt",
  trace = 1,
  config_optim = list(),
  config_post = list(),
  inception = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PLNPCA_param_+3A_backend">backend</code></td>
<td>
<p>optimization back used, either &quot;nlopt&quot; or &quot;torch&quot;. Default is &quot;nlopt&quot;</p>
</td></tr>
<tr><td><code id="PLNPCA_param_+3A_trace">trace</code></td>
<td>
<p>a integer for verbosity.</p>
</td></tr>
<tr><td><code id="PLNPCA_param_+3A_config_optim">config_optim</code></td>
<td>
<p>a list for controlling the optimizer (either &quot;nlopt&quot; or &quot;torch&quot; backend). See details</p>
</td></tr>
<tr><td><code id="PLNPCA_param_+3A_config_post">config_post</code></td>
<td>
<p>a list for controlling the post-treatments (optional bootstrap, jackknife, R2, etc.). See details</p>
</td></tr>
<tr><td><code id="PLNPCA_param_+3A_inception">inception</code></td>
<td>
<p>Set up the parameters initialization: by default, the model is initialized with a multivariate linear model applied on
log-transformed data, and with the same formula as the one provided by the user. However, the user can provide a PLNfit (typically obtained from a previous fit),
which sometimes speeds up the inference.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The list of parameters <code>config_optim</code> controls the optimizers. When &quot;nlopt&quot; is chosen the following entries are relevant
</p>

<ul>
<li><p> &quot;algorithm&quot; the optimization method used by NLOPT among LD type, e.g. &quot;CCSAQ&quot;, &quot;MMA&quot;, &quot;LBFGS&quot;. See NLOPT documentation for further details. Default is &quot;CCSAQ&quot;.
</p>
</li>
<li><p> &quot;maxeval&quot; stop when the number of iteration exceeds maxeval. Default is 10000
</p>
</li>
<li><p> &quot;ftol_rel&quot; stop when an optimization step changes the objective function by less than ftol multiplied by the absolute value of the parameter. Default is 1e-8
</p>
</li>
<li><p> &quot;xtol_rel&quot; stop when an optimization step changes every parameters by less than xtol multiplied by the absolute value of the parameter. Default is 1e-6
</p>
</li>
<li><p> &quot;ftol_abs&quot; stop when an optimization step changes the objective function by less than ftol_abs. Default is 0.0 (disabled)
</p>
</li>
<li><p> &quot;xtol_abs&quot; stop when an optimization step changes every parameters by less than xtol_abs. Default is 0.0 (disabled)
</p>
</li>
<li><p> &quot;maxtime&quot; stop when the optimization time (in seconds) exceeds maxtime. Default is -1 (disabled)
</p>
</li></ul>

<p>When &quot;torch&quot; backend is used (only for PLN and PLNLDA for now), the following entries are relevant:
</p>

<ul>
<li><p> &quot;algorithm&quot; the optimizer used by torch among RPROP (default), RMSPROP, ADAM and ADAGRAD
</p>
</li>
<li><p> &quot;maxeval&quot; stop when the number of iteration exceeds maxeval. Default is 10 000
</p>
</li>
<li><p> &quot;numepoch&quot; stop training once this number of epochs exceeds numepoch. Set to -1 to enable infinite training. Default is 1 000
</p>
</li>
<li><p> &quot;num_batch&quot; number of batches to use during training. Defaults to 1 (use full dataset at each epoch)
</p>
</li>
<li><p> &quot;ftol_rel&quot; stop when an optimization step changes the objective function by less than ftol multiplied by the absolute value of the parameter. Default is 1e-8
</p>
</li>
<li><p> &quot;xtol_rel&quot; stop when an optimization step changes every parameters by less than xtol multiplied by the absolute value of the parameter. Default is 1e-6
</p>
</li>
<li><p> &quot;lr&quot; learning rate. Default is 0.1.
</p>
</li>
<li><p> &quot;momentum&quot; momentum factor. Default is 0 (no momentum). Only used in RMSPROP
</p>
</li>
<li><p> &quot;weight_decay&quot; Weight decay penalty. Default is 0 (no decay). Not used in RPROP
</p>
</li>
<li><p> &quot;step_sizes&quot; pair of minimal (default: 1e-6) and maximal (default: 50) allowed step sizes. Only used in RPROP
</p>
</li>
<li><p> &quot;etas&quot; pair of multiplicative increase and decrease factors. Default is (0.5, 1.2). Only used in RPROP
</p>
</li>
<li><p> &quot;centered&quot; if TRUE, compute the centered RMSProp where the gradient is normalized by an estimation of its variance weight_decay (L2 penalty). Default to FALSE. Only used in RMSPROP
</p>
</li></ul>

<p>The list of parameters <code>config_post</code> controls the post-treatment processing (for most <code style="white-space: pre;">&#8288;PLN*()&#8288;</code> functions), with the following entries (defaults may vary depending on the specific function, check <code style="white-space: pre;">&#8288;config_post_default_*&#8288;</code> for defaults values):
</p>

<ul>
<li><p> jackknife boolean indicating whether jackknife should be performed to evaluate bias and variance of the model parameters. Default is FALSE.
</p>
</li>
<li><p> bootstrap integer indicating the number of bootstrap resamples generated to evaluate the variance of the model parameters. Default is 0 (inactivated).
</p>
</li>
<li><p> variational_var boolean indicating whether variational Fisher information matrix should be computed to estimate the variance of the model parameters (highly underestimated). Default is FALSE.
</p>
</li>
<li><p> sandwich_var boolean indicating whether sandwich estimation should be used to estimate the variance of the model parameters (highly underestimated). Default is FALSE.
</p>
</li>
<li><p> rsquared boolean indicating whether approximation of R2 based on deviance should be computed. Default is TRUE
</p>
</li></ul>



<h3>Value</h3>

<p>list of parameters configuring the fit.
</p>

<hr>
<h2 id='PLNPCAfamily'>An R6 Class to represent a collection of PLNPCAfit</h2><span id='topic+PLNPCAfamily'></span>

<h3>Description</h3>

<p>The function <code><a href="#topic+PLNPCA">PLNPCA()</a></code> produces an instance of this class.
</p>
<p>This class comes with a set of methods, some of them being useful for the user:
See the documentation for <code><a href="#topic+getBestModel">getBestModel()</a></code>,
<code><a href="#topic+getModel">getModel()</a></code> and <code><a href="#topic+plot.PLNPCAfamily">plot()</a></code>.
</p>


<h3>Super class</h3>

<p><code><a href="#topic+PLNfamily">PLNmodels::PLNfamily</a></code> -&gt; <code>PLNPCAfamily</code>
</p>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>ranks</code></dt><dd><p>the dimensions of the successively fitted models</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-PLNPCAfamily-new"><code>PLNPCAfamily$new()</code></a>
</p>
</li>
<li> <p><a href="#method-PLNPCAfamily-optimize"><code>PLNPCAfamily$optimize()</code></a>
</p>
</li>
<li> <p><a href="#method-PLNPCAfamily-getModel"><code>PLNPCAfamily$getModel()</code></a>
</p>
</li>
<li> <p><a href="#method-PLNPCAfamily-getBestModel"><code>PLNPCAfamily$getBestModel()</code></a>
</p>
</li>
<li> <p><a href="#method-PLNPCAfamily-plot"><code>PLNPCAfamily$plot()</code></a>
</p>
</li>
<li> <p><a href="#method-PLNPCAfamily-show"><code>PLNPCAfamily$show()</code></a>
</p>
</li>
<li> <p><a href="#method-PLNPCAfamily-clone"><code>PLNPCAfamily$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="PLNmodels" data-topic="PLNfamily" data-id="postTreatment"><a href='../../PLNmodels/html/PLNfamily.html#method-PLNfamily-postTreatment'><code>PLNmodels::PLNfamily$postTreatment()</code></a></span></li>
<li><span class="pkg-link" data-pkg="PLNmodels" data-topic="PLNfamily" data-id="print"><a href='../../PLNmodels/html/PLNfamily.html#method-PLNfamily-print'><code>PLNmodels::PLNfamily$print()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-PLNPCAfamily-new"></a>



<h4>Method <code>new()</code></h4>

<p>Initialize all models in the collection.
</p>


<h5>Usage</h5>

<div class="r"><pre>PLNPCAfamily$new(
  ranks,
  responses,
  covariates,
  offsets,
  weights,
  formula,
  control
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>ranks</code></dt><dd><p>the dimensions of the successively fitted models</p>
</dd>
<dt><code>responses</code></dt><dd><p>the matrix of responses common to every models</p>
</dd>
<dt><code>covariates</code></dt><dd><p>the matrix of covariates common to every models</p>
</dd>
<dt><code>offsets</code></dt><dd><p>the matrix of offsets common to every models</p>
</dd>
<dt><code>weights</code></dt><dd><p>the vector of observation weights</p>
</dd>
<dt><code>formula</code></dt><dd><p>model formula used for fitting, extracted from the formula in the upper-level call</p>
</dd>
<dt><code>control</code></dt><dd><p>list controlling the optimization and the model</p>
</dd>
</dl>

</div>


<hr>
<a id="method-PLNPCAfamily-optimize"></a>



<h4>Method <code>optimize()</code></h4>

<p>Call to the C++ optimizer on all models of the collection
</p>


<h5>Usage</h5>

<div class="r"><pre>PLNPCAfamily$optimize(config)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>config</code></dt><dd><p>list controlling the optimization.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-PLNPCAfamily-getModel"></a>



<h4>Method <code>getModel()</code></h4>

<p>Extract model from collection and add &quot;PCA&quot; class for compatibility with <code><a href="factoextra.html#topic+fviz">factoextra::fviz()</a></code>
</p>


<h5>Usage</h5>

<div class="r"><pre>PLNPCAfamily$getModel(var, index = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>var</code></dt><dd><p>value of the parameter (rank for PLNPCA, sparsity for PLNnetwork) that identifies the model to be extracted from the collection. If no exact match is found, the model with closest parameter value is returned with a warning.</p>
</dd>
<dt><code>index</code></dt><dd><p>Integer index of the model to be returned. Only the first value is taken into account.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>a <code><a href="#topic+PLNPCAfit">PLNPCAfit</a></code> object
</p>


<hr>
<a id="method-PLNPCAfamily-getBestModel"></a>



<h4>Method <code>getBestModel()</code></h4>

<p>Extract best model in the collection
</p>


<h5>Usage</h5>

<div class="r"><pre>PLNPCAfamily$getBestModel(crit = c("ICL", "BIC"))</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>crit</code></dt><dd><p>a character for the criterion used to performed the selection. Either
&quot;ICL&quot;, &quot;BIC&quot;. Default is <code>ICL</code></p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>a <code><a href="#topic+PLNPCAfit">PLNPCAfit</a></code> object
</p>


<hr>
<a id="method-PLNPCAfamily-plot"></a>



<h4>Method <code>plot()</code></h4>

<p>Lineplot of selected criteria for all models in the collection
</p>


<h5>Usage</h5>

<div class="r"><pre>PLNPCAfamily$plot(criteria = c("loglik", "BIC", "ICL"), reverse = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>criteria</code></dt><dd><p>A valid model selection criteria for the collection of models. Any of &quot;loglik&quot;, &quot;BIC&quot; or &quot;ICL&quot; (all).</p>
</dd>
<dt><code>reverse</code></dt><dd><p>A logical indicating whether to plot the value of the criteria in the &quot;natural&quot; direction
(loglik - penalty) or in the &quot;reverse&quot; direction (-2 loglik + penalty). Default to FALSE, i.e use the natural direction, on
the same scale as the log-likelihood.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A <code><a href="ggplot2.html#topic+ggplot2">ggplot2</a></code> object
</p>


<hr>
<a id="method-PLNPCAfamily-show"></a>



<h4>Method <code>show()</code></h4>

<p>User friendly print method
</p>


<h5>Usage</h5>

<div class="r"><pre>PLNPCAfamily$show()</pre></div>


<hr>
<a id="method-PLNPCAfamily-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>PLNPCAfamily$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p>The function <code><a href="#topic+PLNPCA">PLNPCA()</a></code>, the class <code><a href="#topic+PLNPCAfit">PLNPCAfit()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(trichoptera)
trichoptera &lt;- prepare_data(trichoptera$Abundance, trichoptera$Covariate)
myPCAs &lt;- PLNPCA(Abundance ~ 1 + offset(log(Offset)), data = trichoptera, ranks = 1:5)
class(myPCAs)
</code></pre>

<hr>
<h2 id='PLNPCAfit'>An R6 Class to represent a PLNfit in a PCA framework</h2><span id='topic+PLNPCAfit'></span>

<h3>Description</h3>

<p>The function <code><a href="#topic+PLNPCA">PLNPCA()</a></code> produces a collection of models which are instances of object with class <code><a href="#topic+PLNPCAfit">PLNPCAfit</a></code>.
This class comes with a set of methods, some of them being useful for the user:
See the documentation for the methods inherited by  <code><a href="#topic+PLNfit">PLNfit</a></code> and the <code><a href="graphics.html#topic+plot">plot()</a></code> methods for PCA visualization
</p>


<h3>Super class</h3>

<p><code><a href="#topic+PLNfit">PLNmodels::PLNfit</a></code> -&gt; <code>PLNPCAfit</code>
</p>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>rank</code></dt><dd><p>the dimension of the current model</p>
</dd>
<dt><code>vcov_model</code></dt><dd><p>character: the model used for the residual covariance</p>
</dd>
<dt><code>nb_param</code></dt><dd><p>number of parameters in the current PLN model</p>
</dd>
<dt><code>entropy</code></dt><dd><p>entropy of the variational distribution</p>
</dd>
<dt><code>latent_pos</code></dt><dd><p>a matrix: values of the latent position vector (Z) without covariates effects or offset</p>
</dd>
<dt><code>model_par</code></dt><dd><p>a list with the matrices associated with the estimated parameters of the pPCA model: B (covariates), Sigma (covariance), Omega (precision) and C (loadings)</p>
</dd>
<dt><code>percent_var</code></dt><dd><p>the percent of variance explained by each axis</p>
</dd>
<dt><code>corr_circle</code></dt><dd><p>a matrix of correlations to plot the correlation circles</p>
</dd>
<dt><code>scores</code></dt><dd><p>a matrix of scores to plot the individual factor maps (a.k.a. principal components)</p>
</dd>
<dt><code>rotation</code></dt><dd><p>a matrix of rotation of the latent space</p>
</dd>
<dt><code>eig</code></dt><dd><p>description of the eigenvalues, similar to percent_var but for use with external methods</p>
</dd>
<dt><code>var</code></dt><dd><p>a list of data frames with PCA results for the variables: <code>coord</code> (coordinates of the variables), <code>cor</code> (correlation between variables and dimensions), <code>cos2</code> (Cosine of the variables) and <code>contrib</code> (contributions of the variable to the axes)</p>
</dd>
<dt><code>ind</code></dt><dd><p>a list of data frames with PCA results for the individuals: <code>coord</code> (coordinates of the individuals), <code>cos2</code> (Cosine of the individuals), <code>contrib</code> (contributions of individuals to an axis inertia) and <code>dist</code> (distance of individuals to the origin).</p>
</dd>
<dt><code>call</code></dt><dd><p>Hacky binding for compatibility with factoextra functions</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-PLNPCAfit-new"><code>PLNPCAfit$new()</code></a>
</p>
</li>
<li> <p><a href="#method-PLNPCAfit-update"><code>PLNPCAfit$update()</code></a>
</p>
</li>
<li> <p><a href="#method-PLNPCAfit-optimize"><code>PLNPCAfit$optimize()</code></a>
</p>
</li>
<li> <p><a href="#method-PLNPCAfit-optimize_vestep"><code>PLNPCAfit$optimize_vestep()</code></a>
</p>
</li>
<li> <p><a href="#method-PLNPCAfit-project"><code>PLNPCAfit$project()</code></a>
</p>
</li>
<li> <p><a href="#method-PLNPCAfit-setVisualization"><code>PLNPCAfit$setVisualization()</code></a>
</p>
</li>
<li> <p><a href="#method-PLNPCAfit-postTreatment"><code>PLNPCAfit$postTreatment()</code></a>
</p>
</li>
<li> <p><a href="#method-PLNPCAfit-plot_individual_map"><code>PLNPCAfit$plot_individual_map()</code></a>
</p>
</li>
<li> <p><a href="#method-PLNPCAfit-plot_correlation_circle"><code>PLNPCAfit$plot_correlation_circle()</code></a>
</p>
</li>
<li> <p><a href="#method-PLNPCAfit-plot_PCA"><code>PLNPCAfit$plot_PCA()</code></a>
</p>
</li>
<li> <p><a href="#method-PLNPCAfit-show"><code>PLNPCAfit$show()</code></a>
</p>
</li>
<li> <p><a href="#method-PLNPCAfit-clone"><code>PLNPCAfit$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="PLNmodels" data-topic="PLNfit" data-id="predict"><a href='../../PLNmodels/html/PLNfit.html#method-PLNfit-predict'><code>PLNmodels::PLNfit$predict()</code></a></span></li>
<li><span class="pkg-link" data-pkg="PLNmodels" data-topic="PLNfit" data-id="predict_cond"><a href='../../PLNmodels/html/PLNfit.html#method-PLNfit-predict_cond'><code>PLNmodels::PLNfit$predict_cond()</code></a></span></li>
<li><span class="pkg-link" data-pkg="PLNmodels" data-topic="PLNfit" data-id="print"><a href='../../PLNmodels/html/PLNfit.html#method-PLNfit-print'><code>PLNmodels::PLNfit$print()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-PLNPCAfit-new"></a>



<h4>Method <code>new()</code></h4>

<p>Initialize a <code><a href="#topic+PLNPCAfit">PLNPCAfit</a></code> object
</p>


<h5>Usage</h5>

<div class="r"><pre>PLNPCAfit$new(rank, responses, covariates, offsets, weights, formula, control)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>rank</code></dt><dd><p>rank of the PCA (or equivalently, dimension of the latent space)</p>
</dd>
<dt><code>responses</code></dt><dd><p>the matrix of responses (called Y in the model). Will usually be extracted from the corresponding field in <code><a href="#topic+PLNfamily">PLNfamily</a></code></p>
</dd>
<dt><code>covariates</code></dt><dd><p>design matrix (called X in the model). Will usually be extracted from the corresponding field in <code><a href="#topic+PLNfamily">PLNfamily</a></code></p>
</dd>
<dt><code>offsets</code></dt><dd><p>offset matrix (called O in the model). Will usually be extracted from the corresponding field in <code><a href="#topic+PLNfamily">PLNfamily</a></code></p>
</dd>
<dt><code>weights</code></dt><dd><p>an optional vector of observation weights to be used in the fitting process.</p>
</dd>
<dt><code>formula</code></dt><dd><p>model formula used for fitting, extracted from the formula in the upper-level call</p>
</dd>
<dt><code>control</code></dt><dd><p>a list for controlling the optimization. See details.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-PLNPCAfit-update"></a>



<h4>Method <code>update()</code></h4>

<p>Update a <code><a href="#topic+PLNPCAfit">PLNPCAfit</a></code> object
</p>


<h5>Usage</h5>

<div class="r"><pre>PLNPCAfit$update(
  B = NA,
  Sigma = NA,
  Omega = NA,
  C = NA,
  M = NA,
  S = NA,
  Z = NA,
  A = NA,
  Ji = NA,
  R2 = NA,
  monitoring = NA
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>B</code></dt><dd><p>matrix of regression matrix</p>
</dd>
<dt><code>Sigma</code></dt><dd><p>variance-covariance matrix of the latent variables</p>
</dd>
<dt><code>Omega</code></dt><dd><p>precision matrix of the latent variables. Inverse of Sigma.</p>
</dd>
<dt><code>C</code></dt><dd><p>matrix of PCA loadings (in the latent space)</p>
</dd>
<dt><code>M</code></dt><dd><p>matrix of mean vectors for the variational approximation</p>
</dd>
<dt><code>S</code></dt><dd><p>matrix of variance vectors for the variational approximation</p>
</dd>
<dt><code>Z</code></dt><dd><p>matrix of latent vectors (includes covariates and offset effects)</p>
</dd>
<dt><code>A</code></dt><dd><p>matrix of fitted values</p>
</dd>
<dt><code>Ji</code></dt><dd><p>vector of variational lower bounds of the log-likelihoods (one value per sample)</p>
</dd>
<dt><code>R2</code></dt><dd><p>approximate R^2 goodness-of-fit criterion</p>
</dd>
<dt><code>monitoring</code></dt><dd><p>a list with optimization monitoring quantities</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>Update the current <code><a href="#topic+PLNPCAfit">PLNPCAfit</a></code> object
</p>


<hr>
<a id="method-PLNPCAfit-optimize"></a>



<h4>Method <code>optimize()</code></h4>

<p>Call to the C++ optimizer and update of the relevant fields
</p>


<h5>Usage</h5>

<div class="r"><pre>PLNPCAfit$optimize(responses, covariates, offsets, weights, config)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>responses</code></dt><dd><p>the matrix of responses (called Y in the model). Will usually be extracted from the corresponding field in <code><a href="#topic+PLNfamily">PLNfamily</a></code></p>
</dd>
<dt><code>covariates</code></dt><dd><p>design matrix (called X in the model). Will usually be extracted from the corresponding field in <code><a href="#topic+PLNfamily">PLNfamily</a></code></p>
</dd>
<dt><code>offsets</code></dt><dd><p>offset matrix (called O in the model). Will usually be extracted from the corresponding field in <code><a href="#topic+PLNfamily">PLNfamily</a></code></p>
</dd>
<dt><code>weights</code></dt><dd><p>an optional vector of observation weights to be used in the fitting process.</p>
</dd>
<dt><code>config</code></dt><dd><p>part of the <code>control</code> argument which configures the optimizer</p>
</dd>
</dl>

</div>


<hr>
<a id="method-PLNPCAfit-optimize_vestep"></a>



<h4>Method <code>optimize_vestep()</code></h4>

<p>Result of one call to the VE step of the optimization procedure: optimal variational parameters (M, S) and corresponding log likelihood values for fixed model parameters (C, B). Intended to position new data in the latent space for further use with PCA.
</p>


<h5>Usage</h5>

<div class="r"><pre>PLNPCAfit$optimize_vestep(
  covariates,
  offsets,
  responses,
  weights = rep(1, self$n),
  control = PLNPCA_param(backend = "nlopt")
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>covariates</code></dt><dd><p>design matrix (called X in the model). Will usually be extracted from the corresponding field in <code><a href="#topic+PLNfamily">PLNfamily</a></code></p>
</dd>
<dt><code>offsets</code></dt><dd><p>offset matrix (called O in the model). Will usually be extracted from the corresponding field in <code><a href="#topic+PLNfamily">PLNfamily</a></code></p>
</dd>
<dt><code>responses</code></dt><dd><p>the matrix of responses (called Y in the model). Will usually be extracted from the corresponding field in <code><a href="#topic+PLNfamily">PLNfamily</a></code></p>
</dd>
<dt><code>weights</code></dt><dd><p>an optional vector of observation weights to be used in the fitting process.</p>
</dd>
<dt><code>control</code></dt><dd><p>a list for controlling the optimization. See details.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A list with three components:
</p>

<ul>
<li><p> the matrix <code>M</code> of variational means,
</p>
</li>
<li><p> the matrix <code>S2</code> of variational variances
</p>
</li>
<li><p> the vector <code>log.lik</code> of (variational) log-likelihood of each new observation
</p>
</li></ul>



<hr>
<a id="method-PLNPCAfit-project"></a>



<h4>Method <code>project()</code></h4>

<p>Project new samples into the PCA space using one VE step
</p>


<h5>Usage</h5>

<div class="r"><pre>PLNPCAfit$project(newdata, control = PLNPCA_param(), envir = parent.frame())</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>newdata</code></dt><dd><p>A data frame in which to look for variables, offsets and counts  with which to predict.</p>
</dd>
<dt><code>control</code></dt><dd><p>a list for controlling the optimization. See <code><a href="#topic+PLN">PLN()</a></code> for details.</p>
</dd>
<dt><code>envir</code></dt><dd><p>Environment in which the projection is evaluated</p>
</dd>
</dl>

</div>



<h5>Returns</h5>


<ul>
<li><p> the named matrix of scores for the newdata, expressed in the same coordinate system as <code>self$scores</code>
</p>
</li></ul>



<hr>
<a id="method-PLNPCAfit-setVisualization"></a>



<h4>Method <code>setVisualization()</code></h4>

<p>Compute PCA scores in the latent space and update corresponding fields.
</p>


<h5>Usage</h5>

<div class="r"><pre>PLNPCAfit$setVisualization(scale.unit = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>scale.unit</code></dt><dd><p>Logical. Should PCA scores be rescaled to have unit variance</p>
</dd>
</dl>

</div>


<hr>
<a id="method-PLNPCAfit-postTreatment"></a>



<h4>Method <code>postTreatment()</code></h4>

<p>Update R2, fisher, std_err fields and set up visualization
</p>


<h5>Usage</h5>

<div class="r"><pre>PLNPCAfit$postTreatment(
  responses,
  covariates,
  offsets,
  weights,
  config_post,
  config_optim,
  nullModel
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>responses</code></dt><dd><p>the matrix of responses (called Y in the model). Will usually be extracted from the corresponding field in <code><a href="#topic+PLNfamily">PLNfamily</a></code></p>
</dd>
<dt><code>covariates</code></dt><dd><p>design matrix (called X in the model). Will usually be extracted from the corresponding field in <code><a href="#topic+PLNfamily">PLNfamily</a></code></p>
</dd>
<dt><code>offsets</code></dt><dd><p>offset matrix (called O in the model). Will usually be extracted from the corresponding field in <code><a href="#topic+PLNfamily">PLNfamily</a></code></p>
</dd>
<dt><code>weights</code></dt><dd><p>an optional vector of observation weights to be used in the fitting process.</p>
</dd>
<dt><code>config_post</code></dt><dd><p>a list for controlling the post-treatments (optional bootstrap, jackknife, R2, etc.). See details</p>
</dd>
<dt><code>config_optim</code></dt><dd><p>a list for controlling the optimizer (either &quot;nlopt&quot; or &quot;torch&quot; backend). See details</p>
</dd>
<dt><code>nullModel</code></dt><dd><p>null model used for approximate R2 computations. Defaults to a GLM model with same design matrix but not latent variable.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>The list of parameters <code>config_post</code> controls the post-treatment processing, with the following entries:
</p>

<ul>
<li><p> jackknife boolean indicating whether jackknife should be performed to evaluate bias and variance of the model parameters. Default is FALSE.
</p>
</li>
<li><p> bootstrap integer indicating the number of bootstrap resamples generated to evaluate the variance of the model parameters. Default is 0 (inactivated).
</p>
</li>
<li><p> variational_var boolean indicating whether variational Fisher information matrix should be computed to estimate the variance of the model parameters (highly underestimated). Default is FALSE.
</p>
</li>
<li><p> rsquared boolean indicating whether approximation of R2 based on deviance should be computed. Default is TRUE
</p>
</li>
<li><p> trace integer for verbosity. should be &gt; 1 to see output in post-treatments
</p>
</li></ul>



<hr>
<a id="method-PLNPCAfit-plot_individual_map"></a>



<h4>Method <code>plot_individual_map()</code></h4>

<p>Plot the factorial map of the PCA
</p>


<h5>Usage</h5>

<div class="r"><pre>PLNPCAfit$plot_individual_map(
  axes = 1:min(2, self$rank),
  main = "Individual Factor Map",
  plot = TRUE,
  cols = "default"
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>axes</code></dt><dd><p>numeric, the axes to use for the plot when map = &quot;individual&quot; or &quot;variable&quot;. Default it c(1,min(rank))</p>
</dd>
<dt><code>main</code></dt><dd><p>character. A title for the single plot (individual or variable factor map). If NULL (the default), an hopefully appropriate title will be used.</p>
</dd>
<dt><code>plot</code></dt><dd><p>logical. Should the plot be displayed or sent back as ggplot object</p>
</dd>
<dt><code>cols</code></dt><dd><p>a character, factor or numeric to define the color associated with the individuals. By default, all individuals receive the default color of the current palette.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>a <code><a href="ggplot2.html#topic+ggplot">ggplot</a></code> graphic
</p>


<hr>
<a id="method-PLNPCAfit-plot_correlation_circle"></a>



<h4>Method <code>plot_correlation_circle()</code></h4>

<p>Plot the correlation circle of a specified axis for a <code><a href="#topic+PLNLDAfit">PLNLDAfit</a></code> object
</p>


<h5>Usage</h5>

<div class="r"><pre>PLNPCAfit$plot_correlation_circle(
  axes = 1:min(2, self$rank),
  main = "Variable Factor Map",
  cols = "default",
  plot = TRUE
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>axes</code></dt><dd><p>numeric, the axes to use for the plot when map = &quot;individual&quot; or &quot;variable&quot;. Default it c(1,min(rank))</p>
</dd>
<dt><code>main</code></dt><dd><p>character. A title for the single plot (individual or variable factor map). If NULL (the default), an hopefully appropriate title will be used.</p>
</dd>
<dt><code>cols</code></dt><dd><p>a character, factor or numeric to define the color associated with the variables. By default, all variables receive the default color of the current palette.</p>
</dd>
<dt><code>plot</code></dt><dd><p>logical. Should the plot be displayed or sent back as ggplot object</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>a <code><a href="ggplot2.html#topic+ggplot">ggplot</a></code> graphic
</p>


<hr>
<a id="method-PLNPCAfit-plot_PCA"></a>



<h4>Method <code>plot_PCA()</code></h4>

<p>Plot a summary of the <code><a href="#topic+PLNPCAfit">PLNPCAfit</a></code> object
</p>


<h5>Usage</h5>

<div class="r"><pre>PLNPCAfit$plot_PCA(
  nb_axes = min(3, self$rank),
  ind_cols = "ind_cols",
  var_cols = "var_cols",
  plot = TRUE
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>nb_axes</code></dt><dd><p>scalar: the number of axes to be considered when map = &quot;both&quot;. The default is min(3,rank).</p>
</dd>
<dt><code>ind_cols</code></dt><dd><p>a character, factor or numeric to define the color associated with the individuals. By default, all variables receive the default color of the current palette.</p>
</dd>
<dt><code>var_cols</code></dt><dd><p>a character, factor or numeric to define the color associated with the variables. By default, all variables receive the default color of the current palette.</p>
</dd>
<dt><code>plot</code></dt><dd><p>logical. Should the plot be displayed or sent back as ggplot object</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>a <code><a href="grid.html#topic+grob">grob</a></code> object
</p>


<hr>
<a id="method-PLNPCAfit-show"></a>



<h4>Method <code>show()</code></h4>

<p>User friendly print method
</p>


<h5>Usage</h5>

<div class="r"><pre>PLNPCAfit$show()</pre></div>


<hr>
<a id="method-PLNPCAfit-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>PLNPCAfit$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p>The function <code><a href="#topic+PLNPCA">PLNPCA</a></code>, the class <code><a href="#topic+PLNPCAfamily">PLNPCAfamily</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(trichoptera)
trichoptera &lt;- prepare_data(trichoptera$Abundance, trichoptera$Covariate)
myPCAs &lt;- PLNPCA(Abundance ~ 1 + offset(log(Offset)), data = trichoptera, ranks = 1:5)
myPCA &lt;- getBestModel(myPCAs)
class(myPCA)
print(myPCA)
</code></pre>

<hr>
<h2 id='plot.Networkfamily'>Display various outputs (goodness-of-fit criteria, robustness, diagnostic) associated with a collection of network fits (either <code><a href="#topic+PLNnetworkfamily">PLNnetworkfamily</a></code> or <code><a href="#topic+ZIPLNnetworkfamily">ZIPLNnetworkfamily</a></code>)</h2><span id='topic+plot.Networkfamily'></span><span id='topic+plot.PLNnetworkfamily'></span><span id='topic+plot.ZIPLNnetworkfamily'></span>

<h3>Description</h3>

<p>Display various outputs (goodness-of-fit criteria, robustness, diagnostic) associated with a collection of network fits (either <code><a href="#topic+PLNnetworkfamily">PLNnetworkfamily</a></code> or <code><a href="#topic+ZIPLNnetworkfamily">ZIPLNnetworkfamily</a></code>)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Networkfamily'
plot(
  x,
  type = c("criteria", "stability", "diagnostic"),
  criteria = c("loglik", "pen_loglik", "BIC", "EBIC"),
  reverse = FALSE,
  log.x = TRUE,
  stability = 0.9,
  ...
)

## S3 method for class 'PLNnetworkfamily'
plot(
  x,
  type = c("criteria", "stability", "diagnostic"),
  criteria = c("loglik", "pen_loglik", "BIC", "EBIC"),
  reverse = FALSE,
  log.x = TRUE,
  stability = 0.9,
  ...
)

## S3 method for class 'ZIPLNnetworkfamily'
plot(
  x,
  type = c("criteria", "stability", "diagnostic"),
  criteria = c("loglik", "pen_loglik", "BIC", "EBIC"),
  reverse = FALSE,
  log.x = TRUE,
  stability = 0.9,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.Networkfamily_+3A_x">x</code></td>
<td>
<p>an R6 object with class <code><a href="#topic+PLNnetworkfamily">PLNnetworkfamily</a></code> or <code><a href="#topic+ZIPLNnetworkfamily">ZIPLNnetworkfamily</a></code></p>
</td></tr>
<tr><td><code id="plot.Networkfamily_+3A_type">type</code></td>
<td>
<p>a character, either &quot;criteria&quot;, &quot;stability&quot; or &quot;diagnostic&quot; for the type of plot.</p>
</td></tr>
<tr><td><code id="plot.Networkfamily_+3A_criteria">criteria</code></td>
<td>
<p>Vector of criteria to plot, to be selected among &quot;loglik&quot; (log-likelihood),
&quot;BIC&quot;, &quot;ICL&quot;, &quot;R_squared&quot;, &quot;EBIC&quot; and &quot;pen_loglik&quot; (penalized log-likelihood).
Default is  c(&quot;loglik&quot;, &quot;pen_loglik&quot;, &quot;BIC&quot;, &quot;EBIC&quot;). Only used when <code>type = "criteria"</code>.</p>
</td></tr>
<tr><td><code id="plot.Networkfamily_+3A_reverse">reverse</code></td>
<td>
<p>A logical indicating whether to plot the value of the criteria in the &quot;natural&quot; direction
(loglik - 0.5 penalty) or in the &quot;reverse&quot; direction (-2 loglik + penalty). Default to FALSE, i.e use the
natural direction, on the same scale as the log-likelihood.</p>
</td></tr>
<tr><td><code id="plot.Networkfamily_+3A_log.x">log.x</code></td>
<td>
<p>logical: should the x-axis be represented in log-scale? Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="plot.Networkfamily_+3A_stability">stability</code></td>
<td>
<p>scalar: the targeted level of stability in stability plot. Default is .9.</p>
</td></tr>
<tr><td><code id="plot.Networkfamily_+3A_...">...</code></td>
<td>
<p>additional parameters for S3 compatibility. Not used</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The BIC and ICL criteria have the form 'loglik - 1/2 * penalty'
so that they are on the same scale as the model log-likelihood. You can change this direction and use the alternate form '-2*loglik + penalty', as some authors do, by setting <code>reverse = TRUE</code>.
</p>


<h3>Value</h3>

<p>Produces either a diagnostic plot (with <code>type = 'diagnostic'</code>), a stability plot
(with <code>type = 'stability'</code>) or the evolution of the criteria of the different models considered
(with <code>type = 'criteria'</code>, the default).
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>plot(PLNnetworkfamily)</code>: Display various outputs associated with a collection of network fits
</p>
</li>
<li> <p><code>plot(ZIPLNnetworkfamily)</code>: Display various outputs associated with a collection of network fits
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>data(trichoptera)
trichoptera &lt;- prepare_data(trichoptera$Abundance, trichoptera$Covariate)
fits &lt;- PLNnetwork(Abundance ~ 1, data = trichoptera)
## Not run: 
plot(fits)

## End(Not run)
</code></pre>

<hr>
<h2 id='plot.PLNfamily'>Display the criteria associated with a collection of PLN fits (a PLNfamily)</h2><span id='topic+plot.PLNfamily'></span>

<h3>Description</h3>

<p>Display the criteria associated with a collection of PLN fits (a PLNfamily)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'PLNfamily'
plot(x, criteria = c("loglik", "BIC", "ICL"), reverse = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.PLNfamily_+3A_x">x</code></td>
<td>
<p>an R6 object with class <code><a href="#topic+PLNfamily">PLNfamily</a></code></p>
</td></tr>
<tr><td><code id="plot.PLNfamily_+3A_criteria">criteria</code></td>
<td>
<p>vector of characters. The criteria to plot in c(&quot;loglik&quot;, &quot;BIC&quot;, &quot;ICL&quot;).
Default is  c(&quot;loglik&quot;, &quot;BIC&quot;, &quot;ICL&quot;).</p>
</td></tr>
<tr><td><code id="plot.PLNfamily_+3A_reverse">reverse</code></td>
<td>
<p>A logical indicating whether to plot the value of the criteria in the &quot;natural&quot; direction
(loglik - 0.5 penalty) or in the &quot;reverse&quot; direction (-2 loglik + penalty). Default to FALSE, i.e use the
natural direction, on the same scale as the log-likelihood.</p>
</td></tr>
<tr><td><code id="plot.PLNfamily_+3A_...">...</code></td>
<td>
<p>additional parameters for S3 compatibility. Not used</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The BIC and ICL criteria have the form 'loglik - 1/2 * penalty'
so that they are on the same scale as the model log-likelihood. You can change this direction and use the alternate form '-2*loglik + penalty', as some authors do, by setting <code>reverse = TRUE</code>.
</p>


<h3>Value</h3>

<p>Produces a plot  representing the evolution of the criteria of the different models considered,
highlighting the best model in terms of BIC and ICL (see details).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.PLNPCAfamily">plot.PLNPCAfamily()</a></code> and <code><a href="#topic+plot.PLNnetworkfamily">plot.PLNnetworkfamily()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(trichoptera)
trichoptera &lt;- prepare_data(trichoptera$Abundance, trichoptera$Covariate)
myPCAs &lt;- PLNPCA(Abundance ~ 1 + offset(log(Offset)), data = trichoptera, ranks = 1:5)
## Not run: 
plot(myPCAs)

## End(Not run)
</code></pre>

<hr>
<h2 id='plot.PLNLDAfit'>LDA visualization (individual and/or variable factor map(s)) for a <code><a href="#topic+PLNPCAfit">PLNPCAfit</a></code> object</h2><span id='topic+plot.PLNLDAfit'></span>

<h3>Description</h3>

<p>LDA visualization (individual and/or variable factor map(s)) for a <code><a href="#topic+PLNPCAfit">PLNPCAfit</a></code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'PLNLDAfit'
plot(
  x,
  map = c("both", "individual", "variable"),
  nb_axes = min(3, x$rank),
  axes = seq.int(min(2, x$rank)),
  var_cols = "var_colors",
  plot = TRUE,
  main = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.PLNLDAfit_+3A_x">x</code></td>
<td>
<p>an R6 object with class PLNPCAfit</p>
</td></tr>
<tr><td><code id="plot.PLNLDAfit_+3A_map">map</code></td>
<td>
<p>the type of output for the PCA visualization: either &quot;individual&quot;, &quot;variable&quot; or &quot;both&quot;. Default is &quot;both&quot;.</p>
</td></tr>
<tr><td><code id="plot.PLNLDAfit_+3A_nb_axes">nb_axes</code></td>
<td>
<p>scalar: the number of axes to be considered when map = &quot;both&quot;. The default is min(3,rank).</p>
</td></tr>
<tr><td><code id="plot.PLNLDAfit_+3A_axes">axes</code></td>
<td>
<p>numeric, the axes to use for the plot when map = &quot;individual&quot; or &quot;variable&quot;. Default it c(1,min(rank))</p>
</td></tr>
<tr><td><code id="plot.PLNLDAfit_+3A_var_cols">var_cols</code></td>
<td>
<p>a character or factor to define the color associated with the variables. By default, all variables receive the default color of the current palette.</p>
</td></tr>
<tr><td><code id="plot.PLNLDAfit_+3A_plot">plot</code></td>
<td>
<p>logical. Should the plot be displayed or sent back as <code><a href="ggplot2.html#topic+ggplot2">ggplot2</a></code> object</p>
</td></tr>
<tr><td><code id="plot.PLNLDAfit_+3A_main">main</code></td>
<td>
<p>character. A title for the single plot (individual or variable factor map). If NULL (the default), an hopefully appropriate title will be used.</p>
</td></tr>
<tr><td><code id="plot.PLNLDAfit_+3A_...">...</code></td>
<td>
<p>Not used (S3 compatibility).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>displays an individual and/or variable factor maps for the corresponding axes, and/or sends back a <code><a href="ggplot2.html#topic+ggplot2">ggplot2</a></code> or gtable object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(trichoptera)
trichoptera &lt;- prepare_data(trichoptera$Abundance, trichoptera$Covariate)
myPLNLDA &lt;- PLNLDA(Abundance ~ 1, grouping = Group, data = trichoptera)
## Not run: 
plot(myPLNLDA, map = "individual", nb_axes = 2)

## End(Not run)
</code></pre>

<hr>
<h2 id='plot.PLNmixturefamily'>Display the criteria associated with a collection of PLNmixture fits (a PLNmixturefamily)</h2><span id='topic+plot.PLNmixturefamily'></span>

<h3>Description</h3>

<p>Display the criteria associated with a collection of PLNmixture fits (a PLNmixturefamily)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'PLNmixturefamily'
plot(
  x,
  type = c("criteria", "diagnostic"),
  criteria = c("loglik", "BIC", "ICL"),
  reverse = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.PLNmixturefamily_+3A_x">x</code></td>
<td>
<p>an R6 object with class <code><a href="#topic+PLNmixturefamily">PLNmixturefamily</a></code></p>
</td></tr>
<tr><td><code id="plot.PLNmixturefamily_+3A_type">type</code></td>
<td>
<p>a character, either <code>"criteria"</code> or <code>"diagnostic"</code> for the type of plot.</p>
</td></tr>
<tr><td><code id="plot.PLNmixturefamily_+3A_criteria">criteria</code></td>
<td>
<p>vector of characters. The criteria to plot in c(&quot;loglik&quot;, &quot;BIC&quot;, &quot;ICL&quot;).
Default is  c(&quot;loglik&quot;, &quot;BIC&quot;, &quot;ICL&quot;).</p>
</td></tr>
<tr><td><code id="plot.PLNmixturefamily_+3A_reverse">reverse</code></td>
<td>
<p>A logical indicating whether to plot the value of the criteria in the &quot;natural&quot; direction
(loglik - 0.5 penalty) or in the &quot;reverse&quot; direction (-2 loglik + penalty). Default to FALSE, i.e use the
natural direction, on the same scale as the log-likelihood.</p>
</td></tr>
<tr><td><code id="plot.PLNmixturefamily_+3A_...">...</code></td>
<td>
<p>additional parameters for S3 compatibility. Not used</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The BIC and ICL criteria have the form 'loglik - 1/2 * penalty'
so that they are on the same scale as the model log-likelihood. You can change this direction and use the alternate form '-2*loglik + penalty', as some authors do, by setting <code>reverse = TRUE</code>.
</p>


<h3>Value</h3>

<p>Produces either a diagnostic plot (with <code>type = 'diagnostic'</code>) or the evolution of the criteria
of the different models considered (with <code>type = 'criteria'</code>, the default).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(trichoptera)
trichoptera &lt;- prepare_data(trichoptera$Abundance, trichoptera$Covariate)
myMixtures &lt;- PLNmixture(Abundance ~ 1 + offset(log(Offset)),
           data = trichoptera, control = PLNmixture_param(smoothing = "none"))
plot(myMixtures, reverse = TRUE)
</code></pre>

<hr>
<h2 id='plot.PLNmixturefit'>Mixture visualization of a <code><a href="#topic+PLNmixturefit">PLNmixturefit</a></code> object</h2><span id='topic+plot.PLNmixturefit'></span>

<h3>Description</h3>

<p>Represent the result of the clustering either by coloring the individual in a two-dimension PCA factor map,
or by representing the expected matrix  of count reorder according to the clustering.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'PLNmixturefit'
plot(x, type = c("pca", "matrix"), main = NULL, plot = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.PLNmixturefit_+3A_x">x</code></td>
<td>
<p>an R6 object with class <code><a href="#topic+PLNmixturefit">PLNmixturefit</a></code></p>
</td></tr>
<tr><td><code id="plot.PLNmixturefit_+3A_type">type</code></td>
<td>
<p>character for the type of plot, either &quot;pca&quot;, for or &quot;matrix&quot;. Default is <code>"pca"</code>.</p>
</td></tr>
<tr><td><code id="plot.PLNmixturefit_+3A_main">main</code></td>
<td>
<p>character. A title for the  plot. If NULL (the default), an hopefully appropriate title will be used.</p>
</td></tr>
<tr><td><code id="plot.PLNmixturefit_+3A_plot">plot</code></td>
<td>
<p>logical. Should the plot be displayed or sent back as <code><a href="ggplot2.html#topic+ggplot">ggplot</a></code> object</p>
</td></tr>
<tr><td><code id="plot.PLNmixturefit_+3A_...">...</code></td>
<td>
<p>Not used (S3 compatibility).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code><a href="ggplot2.html#topic+ggplot">ggplot</a></code> graphic
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(trichoptera)
trichoptera &lt;- prepare_data(trichoptera$Abundance, trichoptera$Covariate)
myPLN &lt;- PLNmixture(Abundance ~ 1 + offset(log(Offset)),
           data = trichoptera, control = PLNmixture_param(smoothing = "none"))  %&gt;% getBestModel()
## Not run: 
plot(myPLN, "pca")
plot(myPLN, "matrix")

## End(Not run)
</code></pre>

<hr>
<h2 id='plot.PLNnetworkfit'>Extract and plot the network (partial correlation, support or inverse covariance) from a <code><a href="#topic+PLNnetworkfit">PLNnetworkfit</a></code> object</h2><span id='topic+plot.PLNnetworkfit'></span>

<h3>Description</h3>

<p>Extract and plot the network (partial correlation, support or inverse covariance) from a <code><a href="#topic+PLNnetworkfit">PLNnetworkfit</a></code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'PLNnetworkfit'
plot(
  x,
  type = c("partial_cor", "support"),
  output = c("igraph", "corrplot"),
  edge.color = c("#F8766D", "#00BFC4"),
  remove.isolated = FALSE,
  node.labels = NULL,
  layout = layout_in_circle,
  plot = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.PLNnetworkfit_+3A_x">x</code></td>
<td>
<p>an R6 object with class <code><a href="#topic+PLNnetworkfit">PLNnetworkfit</a></code></p>
</td></tr>
<tr><td><code id="plot.PLNnetworkfit_+3A_type">type</code></td>
<td>
<p>character. Value of the weight of the edges in the network, either &quot;partial_cor&quot; (partial correlation) or &quot;support&quot; (binary). Default is <code>"partial_cor"</code>.</p>
</td></tr>
<tr><td><code id="plot.PLNnetworkfit_+3A_output">output</code></td>
<td>
<p>the type of output used: either 'igraph' or 'corrplot'. Default is <code>'igraph'</code>.</p>
</td></tr>
<tr><td><code id="plot.PLNnetworkfit_+3A_edge.color">edge.color</code></td>
<td>
<p>Length 2 color vector. Color for positive/negative edges. Default is <code>c("#F8766D", "#00BFC4")</code>. Only relevant for igraph output.</p>
</td></tr>
<tr><td><code id="plot.PLNnetworkfit_+3A_remove.isolated">remove.isolated</code></td>
<td>
<p>if <code>TRUE</code>, isolated node are remove before plotting. Only relevant for igraph output.</p>
</td></tr>
<tr><td><code id="plot.PLNnetworkfit_+3A_node.labels">node.labels</code></td>
<td>
<p>vector of character. The labels of the nodes. The default will use the column names ot the response matrix.</p>
</td></tr>
<tr><td><code id="plot.PLNnetworkfit_+3A_layout">layout</code></td>
<td>
<p>an optional igraph layout. Only relevant for igraph output.</p>
</td></tr>
<tr><td><code id="plot.PLNnetworkfit_+3A_plot">plot</code></td>
<td>
<p>logical. Should the final network be displayed or only sent back to the user. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="plot.PLNnetworkfit_+3A_...">...</code></td>
<td>
<p>Not used (S3 compatibility).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Send back an invisible object (igraph or Matrix, depending on the output chosen) and optionally displays a graph (via igraph or corrplot for large ones)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(trichoptera)
trichoptera &lt;- prepare_data(trichoptera$Abundance, trichoptera$Covariate)
fits &lt;- PLNnetwork(Abundance ~ 1, data = trichoptera)
myNet &lt;- getBestModel(fits)
## Not run: 
plot(myNet)

## End(Not run)
</code></pre>

<hr>
<h2 id='plot.PLNPCAfamily'>Display the criteria associated with a collection of PLNPCA fits (a PLNPCAfamily)</h2><span id='topic+plot.PLNPCAfamily'></span>

<h3>Description</h3>

<p>Display the criteria associated with a collection of PLNPCA fits (a PLNPCAfamily)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'PLNPCAfamily'
plot(x, criteria = c("loglik", "BIC", "ICL"), reverse = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.PLNPCAfamily_+3A_x">x</code></td>
<td>
<p>an R6 object with class <code><a href="#topic+PLNPCAfamily">PLNPCAfamily</a></code></p>
</td></tr>
<tr><td><code id="plot.PLNPCAfamily_+3A_criteria">criteria</code></td>
<td>
<p>vector of characters. The criteria to plot in c(&quot;loglik&quot;, &quot;BIC&quot;, &quot;ICL&quot;).
Default is  c(&quot;loglik&quot;, &quot;BIC&quot;, &quot;ICL&quot;).</p>
</td></tr>
<tr><td><code id="plot.PLNPCAfamily_+3A_reverse">reverse</code></td>
<td>
<p>A logical indicating whether to plot the value of the criteria in the &quot;natural&quot; direction
(loglik - 0.5 penalty) or in the &quot;reverse&quot; direction (-2 loglik + penalty). Default to FALSE, i.e use the
natural direction, on the same scale as the log-likelihood.</p>
</td></tr>
<tr><td><code id="plot.PLNPCAfamily_+3A_...">...</code></td>
<td>
<p>additional parameters for S3 compatibility. Not used</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The BIC and ICL criteria have the form 'loglik - 1/2 * penalty'
so that they are on the same scale as the model log-likelihood. You can change this direction and use the alternate form '-2*loglik + penalty', as some authors do, by setting <code>reverse = TRUE</code>.
</p>


<h3>Value</h3>

<p>Produces a plot  representing the evolution of the criteria of the different models considered,
highlighting the best model in terms of BIC and ICL (see details).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(trichoptera)
trichoptera &lt;- prepare_data(trichoptera$Abundance, trichoptera$Covariate)
myPCAs &lt;- PLNPCA(Abundance ~ 1 + offset(log(Offset)), data = trichoptera, ranks = 1:5)
## Not run: 
plot(myPCAs)

## End(Not run)
</code></pre>

<hr>
<h2 id='plot.PLNPCAfit'>PCA visualization (individual and/or variable factor map(s)) for a <code><a href="#topic+PLNPCAfit">PLNPCAfit</a></code> object</h2><span id='topic+plot.PLNPCAfit'></span>

<h3>Description</h3>

<p>PCA visualization (individual and/or variable factor map(s)) for a <code><a href="#topic+PLNPCAfit">PLNPCAfit</a></code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'PLNPCAfit'
plot(
  x,
  map = c("both", "individual", "variable"),
  nb_axes = min(3, x$rank),
  axes = seq.int(min(2, x$rank)),
  ind_cols = "ind_colors",
  var_cols = "var_colors",
  plot = TRUE,
  main = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.PLNPCAfit_+3A_x">x</code></td>
<td>
<p>an R6 object with class PLNPCAfit</p>
</td></tr>
<tr><td><code id="plot.PLNPCAfit_+3A_map">map</code></td>
<td>
<p>the type of output for the PCA visualization: either &quot;individual&quot;, &quot;variable&quot; or &quot;both&quot;. Default is &quot;both&quot;.</p>
</td></tr>
<tr><td><code id="plot.PLNPCAfit_+3A_nb_axes">nb_axes</code></td>
<td>
<p>scalar: the number of axes to be considered when <code>map = "both"</code>. The default is <code>min(3,rank)</code>.</p>
</td></tr>
<tr><td><code id="plot.PLNPCAfit_+3A_axes">axes</code></td>
<td>
<p>numeric, the axes to use for the plot when <code>map = "individual"</code> or <code>map = "variable"</code>. Default it <code>c(1,min(rank))</code></p>
</td></tr>
<tr><td><code id="plot.PLNPCAfit_+3A_ind_cols">ind_cols</code></td>
<td>
<p>a character, factor or numeric to define the color associated with the individuals. By default, all variables receive the default color of the current palette.</p>
</td></tr>
<tr><td><code id="plot.PLNPCAfit_+3A_var_cols">var_cols</code></td>
<td>
<p>a character, factor or numeric to define the color associated with the variables. By default, all variables receive the default color of the current palette.</p>
</td></tr>
<tr><td><code id="plot.PLNPCAfit_+3A_plot">plot</code></td>
<td>
<p>logical. Should the plot be displayed or sent back as <code><a href="ggplot2.html#topic+ggplot">ggplot</a></code> object</p>
</td></tr>
<tr><td><code id="plot.PLNPCAfit_+3A_main">main</code></td>
<td>
<p>character. A title for the single plot (individual or variable factor map). If NULL (the default), an hopefully appropriate title will be used.</p>
</td></tr>
<tr><td><code id="plot.PLNPCAfit_+3A_...">...</code></td>
<td>
<p>Not used (S3 compatibility).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>displays an individual and/or variable factor maps for the corresponding axes, and/or sends back a <code><a href="ggplot2.html#topic+ggplot">ggplot</a></code> or gtable object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(trichoptera)
trichoptera &lt;- prepare_data(trichoptera$Abundance, trichoptera$Covariate)
myPCAs &lt;- PLNPCA(Abundance ~ 1 + offset(log(Offset)), data = trichoptera, ranks = 1:5)
myPCA &lt;- getBestModel(myPCAs)
## Not run: 
plot(myPCA, map = "individual", nb_axes=2, ind_cols = trichoptera$Group)
plot(myPCA, map = "variable", nb_axes=2)
plot(myPCA, map = "both", nb_axes=2, ind_cols = trichoptera$Group)

## End(Not run)
</code></pre>

<hr>
<h2 id='plot.ZIPLNfit_sparse'>Extract and plot the network (partial correlation, support or inverse covariance) from a <code><a href="#topic+ZIPLNfit_sparse">ZIPLNfit_sparse</a></code> object</h2><span id='topic+plot.ZIPLNfit_sparse'></span>

<h3>Description</h3>

<p>Extract and plot the network (partial correlation, support or inverse covariance) from a <code><a href="#topic+ZIPLNfit_sparse">ZIPLNfit_sparse</a></code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ZIPLNfit_sparse'
plot(
  x,
  type = c("partial_cor", "support"),
  output = c("igraph", "corrplot"),
  edge.color = c("#F8766D", "#00BFC4"),
  remove.isolated = FALSE,
  node.labels = NULL,
  layout = layout_in_circle,
  plot = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.ZIPLNfit_sparse_+3A_x">x</code></td>
<td>
<p>an R6 object with class <code><a href="#topic+ZIPLNfit_sparse">ZIPLNfit_sparse</a></code></p>
</td></tr>
<tr><td><code id="plot.ZIPLNfit_sparse_+3A_type">type</code></td>
<td>
<p>character. Value of the weight of the edges in the network, either &quot;partial_cor&quot; (partial correlation) or &quot;support&quot; (binary). Default is <code>"partial_cor"</code>.</p>
</td></tr>
<tr><td><code id="plot.ZIPLNfit_sparse_+3A_output">output</code></td>
<td>
<p>the type of output used: either 'igraph' or 'corrplot'. Default is <code>'igraph'</code>.</p>
</td></tr>
<tr><td><code id="plot.ZIPLNfit_sparse_+3A_edge.color">edge.color</code></td>
<td>
<p>Length 2 color vector. Color for positive/negative edges. Default is <code>c("#F8766D", "#00BFC4")</code>. Only relevant for igraph output.</p>
</td></tr>
<tr><td><code id="plot.ZIPLNfit_sparse_+3A_remove.isolated">remove.isolated</code></td>
<td>
<p>if <code>TRUE</code>, isolated node are remove before plotting. Only relevant for igraph output.</p>
</td></tr>
<tr><td><code id="plot.ZIPLNfit_sparse_+3A_node.labels">node.labels</code></td>
<td>
<p>vector of character. The labels of the nodes. The default will use the column names ot the response matrix.</p>
</td></tr>
<tr><td><code id="plot.ZIPLNfit_sparse_+3A_layout">layout</code></td>
<td>
<p>an optional igraph layout. Only relevant for igraph output.</p>
</td></tr>
<tr><td><code id="plot.ZIPLNfit_sparse_+3A_plot">plot</code></td>
<td>
<p>logical. Should the final network be displayed or only sent back to the user. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="plot.ZIPLNfit_sparse_+3A_...">...</code></td>
<td>
<p>Not used (S3 compatibility).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Send back an invisible object (igraph or Matrix, depending on the output chosen) and optionally displays a graph (via igraph or corrplot for large ones)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(trichoptera)
trichoptera &lt;- prepare_data(trichoptera$Abundance, trichoptera$Covariate)
fit &lt;- ZIPLN(Abundance ~ 1, data = trichoptera, control = ZIPLN_param(penalty = 0.1))
## Not run: 
plot(fit)

## End(Not run)
</code></pre>

<hr>
<h2 id='predict_cond'>Predict counts conditionally</h2><span id='topic+predict_cond'></span><span id='topic+predict_cond.PLNfit'></span>

<h3>Description</h3>

<p>Predict counts of a new sample conditionally on a (set of) observed variables
</p>


<h3>Usage</h3>

<pre><code class='language-R'>predict_cond(
  object,
  newdata,
  cond_responses,
  type = c("link", "response"),
  var_par = FALSE
)

## S3 method for class 'PLNfit'
predict_cond(
  object,
  newdata,
  cond_responses,
  type = c("link", "response"),
  var_par = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict_cond_+3A_object">object</code></td>
<td>
<p>an R6 object with class <code><a href="#topic+PLNfit">PLNfit</a></code></p>
</td></tr>
<tr><td><code id="predict_cond_+3A_newdata">newdata</code></td>
<td>
<p>A data frame in which to look for variables and offsets with which to predict</p>
</td></tr>
<tr><td><code id="predict_cond_+3A_cond_responses">cond_responses</code></td>
<td>
<p>a data frame containing the counts of the observed variables (matching the names provided as data in the PLN function)</p>
</td></tr>
<tr><td><code id="predict_cond_+3A_type">type</code></td>
<td>
<p>The type of prediction required. The default is on the scale of the linear predictors (i.e. log average count)</p>
</td></tr>
<tr><td><code id="predict_cond_+3A_var_par">var_par</code></td>
<td>
<p>Boolean. Should new estimations of the variational parameters of mean and variance be sent back, as attributes of the matrix of predictions. Default to <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing:
</p>
<table>
<tr><td><code>pred</code></td>
<td>
<p>A matrix of predicted log-counts (if <code>type = "link"</code>) or predicted counts (if <code>type = "response"</code>)</p>
</td></tr>
<tr><td><code>M</code></td>
<td>
<p>A matrix containing E(Z_uncond | Y_c) for each given site.</p>
</td></tr>
<tr><td><code>S</code></td>
<td>
<p>A matrix containing Var(Z_uncond | Y_c) for each given site (sites are the third dimension of the array)</p>
</td></tr>
</table>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>predict_cond(PLNfit)</code>: Predict counts of a new sample conditionally on a (set of) observed variables for a <code><a href="#topic+PLNfit">PLNfit</a></code>
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>data(trichoptera)
trichoptera_prep &lt;- prepare_data(trichoptera$Abundance, trichoptera$Covariate)
myPLN &lt;- PLN(Abundance ~ Temperature + Wind, trichoptera_prep)
#Condition on the set of the first two species in the dataset (Hym, Hys) at the ten first sites
Yc &lt;- trichoptera$Abundance[1:10, c(1, 2), drop=FALSE]
newX &lt;- cbind(1, trichoptera$Covariate[1:10, c("Temperature", "Wind")])
pred &lt;- predict_cond(myPLN, newX, Yc, type = "response")
</code></pre>

<hr>
<h2 id='predict.PLNfit'>Predict counts of a new sample</h2><span id='topic+predict.PLNfit'></span>

<h3>Description</h3>

<p>Predict counts of a new sample
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'PLNfit'
predict(
  object,
  newdata,
  responses = NULL,
  level = 1,
  type = c("link", "response"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.PLNfit_+3A_object">object</code></td>
<td>
<p>an R6 object with class <code><a href="#topic+PLNfit">PLNfit</a></code></p>
</td></tr>
<tr><td><code id="predict.PLNfit_+3A_newdata">newdata</code></td>
<td>
<p>A data frame in which to look for variables and offsets with which to predict</p>
</td></tr>
<tr><td><code id="predict.PLNfit_+3A_responses">responses</code></td>
<td>
<p>Optional data frame containing the count of the observed variables (matching the names of the provided as data in the PLN function), assuming the interest in in testing the model.</p>
</td></tr>
<tr><td><code id="predict.PLNfit_+3A_level">level</code></td>
<td>
<p>Optional integer value the level to be used in obtaining the predictions. Level zero corresponds to the population predictions (default if <code>responses</code> is not provided) while level one (default) corresponds to predictions after evaluating the variational parameters for the new data.</p>
</td></tr>
<tr><td><code id="predict.PLNfit_+3A_type">type</code></td>
<td>
<p>The type of prediction required. The default is on the scale of the linear predictors (i.e. log average count)</p>
</td></tr>
<tr><td><code id="predict.PLNfit_+3A_...">...</code></td>
<td>
<p>additional parameters for S3 compatibility. Not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of predicted log-counts (if <code>type = "link"</code>) or predicted counts (if <code>type = "response"</code>).
</p>

<hr>
<h2 id='predict.PLNLDAfit'>Predict group of new samples</h2><span id='topic+predict.PLNLDAfit'></span>

<h3>Description</h3>

<p>Predict group of new samples
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'PLNLDAfit'
predict(
  object,
  newdata,
  type = c("posterior", "response", "scores"),
  scale = c("log", "prob"),
  prior = NULL,
  control = PLN_param(backend = "nlopt"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.PLNLDAfit_+3A_object">object</code></td>
<td>
<p>an R6 object with class <code><a href="#topic+PLNLDAfit">PLNLDAfit</a></code></p>
</td></tr>
<tr><td><code id="predict.PLNLDAfit_+3A_newdata">newdata</code></td>
<td>
<p>A data frame in which to look for variables, offsets and counts  with which to predict.</p>
</td></tr>
<tr><td><code id="predict.PLNLDAfit_+3A_type">type</code></td>
<td>
<p>The type of prediction required. The default are posterior probabilities for each group (in either unnormalized log-scale or natural probabilities, see &quot;scale&quot; for details), &quot;response&quot; is the group with maximal posterior probability and &quot;scores&quot; is the average score along each separation axis in the latent space, with weights equal to the posterior probabilities.</p>
</td></tr>
<tr><td><code id="predict.PLNLDAfit_+3A_scale">scale</code></td>
<td>
<p>The scale used for the posterior probability. Either log-scale (&quot;log&quot;, default) or natural probabilities summing up to 1 (&quot;prob&quot;).</p>
</td></tr>
<tr><td><code id="predict.PLNLDAfit_+3A_prior">prior</code></td>
<td>
<p>User-specified prior group probabilities in the new data. If NULL (default), prior probabilities are computed from the learning set.</p>
</td></tr>
<tr><td><code id="predict.PLNLDAfit_+3A_control">control</code></td>
<td>
<p>a list for controlling the optimization. See <code><a href="#topic+PLN">PLN()</a></code> for details.</p>
</td></tr>
<tr><td><code id="predict.PLNLDAfit_+3A_...">...</code></td>
<td>
<p>additional parameters for S3 compatibility. Not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of posterior probabilities for each group (if type = &quot;posterior&quot;), a matrix of (average) scores in the latent space (if type = &quot;scores&quot;) or a vector of predicted groups (if type = &quot;response&quot;).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(trichoptera)
trichoptera &lt;- prepare_data(trichoptera$Abundance, trichoptera$Covariate)
myLDA &lt;- PLNLDA(Abundance ~ 0 + offset(log(Offset)),
                grouping = Group,
                data = trichoptera)
## Not run: 
post_probs &lt;- predict(myLDA, newdata = trichoptera, type = "posterior", scale = "prob")
head(round(post_probs, digits = 3))
predicted_group &lt;- predict(myLDA, newdata = trichoptera, type = "response")
table(predicted_group, trichoptera$Group, dnn = c("predicted", "true"))

## End(Not run)
</code></pre>

<hr>
<h2 id='predict.PLNmixturefit'>Prediction for a <code><a href="#topic+PLNmixturefit">PLNmixturefit</a></code> object</h2><span id='topic+predict.PLNmixturefit'></span>

<h3>Description</h3>

<p>Predict either posterior probabilities for each group or latent positions based on new samples
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'PLNmixturefit'
predict(
  object,
  newdata,
  type = c("posterior", "response", "position"),
  prior = matrix(rep(1/object$k, object$k), nrow(newdata), object$k, byrow = TRUE),
  control = PLNmixture_param(),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.PLNmixturefit_+3A_object">object</code></td>
<td>
<p>an R6 object with class <code><a href="#topic+PLNmixturefit">PLNmixturefit</a></code></p>
</td></tr>
<tr><td><code id="predict.PLNmixturefit_+3A_newdata">newdata</code></td>
<td>
<p>A data frame in which to look for variables, offsets and counts with which to predict.</p>
</td></tr>
<tr><td><code id="predict.PLNmixturefit_+3A_type">type</code></td>
<td>
<p>The type of prediction required. The default <code>posterior</code> are posterior probabilities for each group ,
<code>response</code> is the group with maximal posterior probability and <code>latent</code> is the averaged latent in the latent space,
with weights equal to the posterior probabilities.</p>
</td></tr>
<tr><td><code id="predict.PLNmixturefit_+3A_prior">prior</code></td>
<td>
<p>User-specified prior group probabilities in the new data. The default uses a uniform prior.</p>
</td></tr>
<tr><td><code id="predict.PLNmixturefit_+3A_control">control</code></td>
<td>
<p>a list-like structure for controlling the fit. See <code><a href="#topic+PLNmixture_param">PLNmixture_param()</a></code> for details.</p>
</td></tr>
<tr><td><code id="predict.PLNmixturefit_+3A_...">...</code></td>
<td>
<p>additional parameters for S3 compatibility. Not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of posterior probabilities for each group (if type = &quot;posterior&quot;), a matrix of (average) position in the
latent space (if type = &quot;position&quot;) or a vector of predicted groups (if type = &quot;response&quot;).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(trichoptera)
trichoptera &lt;- prepare_data(trichoptera$Abundance, trichoptera$Covariate)
myPLN &lt;- PLNmixture(Abundance ~ 1 + offset(log(Offset)),
           data = trichoptera, control = PLNmixture_param(smoothing = "none"))  %&gt;% getBestModel()
predict(myPLN, trichoptera, "posterior")
predict(myPLN, trichoptera, "position")
predict(myPLN, trichoptera, "response")
</code></pre>

<hr>
<h2 id='predict.ZIPLNfit'>Predict counts of a new sample</h2><span id='topic+predict.ZIPLNfit'></span>

<h3>Description</h3>

<p>Predict counts of a new sample
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ZIPLNfit'
predict(
  object,
  newdata,
  responses = NULL,
  level = 1,
  type = c("link", "response", "deflated"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.ZIPLNfit_+3A_object">object</code></td>
<td>
<p>an R6 object with class <code><a href="#topic+ZIPLNfit">ZIPLNfit</a></code></p>
</td></tr>
<tr><td><code id="predict.ZIPLNfit_+3A_newdata">newdata</code></td>
<td>
<p>A data frame in which to look for variables and offsets with which to predict</p>
</td></tr>
<tr><td><code id="predict.ZIPLNfit_+3A_responses">responses</code></td>
<td>
<p>Optional data frame containing the count of the observed variables (matching the names of the provided as data in the PLN function), assuming the interest in in testing the model.</p>
</td></tr>
<tr><td><code id="predict.ZIPLNfit_+3A_level">level</code></td>
<td>
<p>Optional integer value the level to be used in obtaining the predictions. Level zero corresponds to the population predictions (default if <code>responses</code> is not provided) while level one (default) corresponds to predictions after evaluating the variational parameters for the new data.</p>
</td></tr>
<tr><td><code id="predict.ZIPLNfit_+3A_type">type</code></td>
<td>
<p>Scale used for the prediction. Either <code>"link"</code> (default, predicted positions in the latent space), <code>"response"</code> (predicted average counts, accounting for zero-inflation) or <code>"deflated"</code> (predicted average counts, not accounting for zero-inflation and using only the PLN part of the model).</p>
</td></tr>
<tr><td><code id="predict.ZIPLNfit_+3A_...">...</code></td>
<td>
<p>additional parameters for S3 compatibility. Not used</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that <code>level = 1</code> can only be used if responses are provided,
as the variational parameters can't be estimated otherwise. In the absence of responses, <code>level</code> is ignored and the fitted values are returned
</p>
<p>Note also that when <code>type = "response"</code> corresponds to predicting
values with <code class="reqn">(1 - \pi)A</code>, where <code class="reqn">A</code> is the average count in
the PLN part of the model and <code class="reqn">\pi</code> the probability of zero-inflation,
whereas <code>type = "deflated"</code> corresponds to <code class="reqn">A</code>.
</p>

<hr>
<h2 id='prepare_data'>Prepare data for use in PLN models</h2><span id='topic+prepare_data'></span>

<h3>Description</h3>

<p>Prepare data in proper format for use in PLN model and its variants. The function (i) merges a count table and
a covariate data frame in the most comprehensive way and (ii) computes offsets from the count table using one of several normalization schemes (TSS, CSS, RLE, GMPR, Wrench, etc). The function fails with informative messages when the heuristics used for sample matching fail.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prepare_data(counts, covariates, offset = "TSS", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prepare_data_+3A_counts">counts</code></td>
<td>
<p>Required. An abundance count table, preferably with dimensions names and species as columns.</p>
</td></tr>
<tr><td><code id="prepare_data_+3A_covariates">covariates</code></td>
<td>
<p>Required. A covariates data frame, preferably with row names.</p>
</td></tr>
<tr><td><code id="prepare_data_+3A_offset">offset</code></td>
<td>
<p>Optional. Normalization scheme used to compute scaling factors used as offset during PLN inference. Available schemes are &quot;TSS&quot; (Total Sum Scaling, default), &quot;CSS&quot; (Cumulative Sum Scaling, used in metagenomeSeq), &quot;RLE&quot; (Relative Log Expression, used in DESeq2), &quot;GMPR&quot; (Geometric Mean of Pairwise Ratio, introduced in Chen et al., 2018), Wrench (introduced in Kumar et al., 2018) or &quot;none&quot;. Alternatively the user can supply its own vector or matrix of offsets (see note for specification of the user-supplied offsets).</p>
</td></tr>
<tr><td><code id="prepare_data_+3A_...">...</code></td>
<td>
<p>Additional parameters passed on to <code><a href="#topic+compute_offset">compute_offset()</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame suited for use in <code><a href="#topic+PLN">PLN()</a></code> and its variants with two specials components: an abundance count matrix (in component &quot;Abundance&quot;) and an offset vector/matrix (in component &quot;Offset&quot;, only if offset is not set to &quot;none&quot;)
</p>


<h3>Note</h3>

<p>User supplied offsets should be either vectors/column-matrices or have the same number of column as the original count matrix and either (i) dimension names or (ii) the same dimensions as the count matrix. Samples are trimmed in exactly the same way to remove empty samples.
</p>


<h3>References</h3>

<p>Chen, L., Reeve, J., Zhang, L., Huang, S., Wang, X. and Chen, J. (2018) GMPR: A robust normalization method for zero-inflated count data with application to microbiome sequencing data. PeerJ, 6, e4600 <a href="https://doi.org/10.7717/peerj.4600">doi:10.7717/peerj.4600</a>
</p>
<p>Paulson, J. N., Colin Stine, O., Bravo, H. C. and Pop, M. (2013) Differential abundance analysis for microbial marker-gene surveys. Nature Methods, 10, 1200-1202 <a href="https://doi.org/10.1038/nmeth.2658">doi:10.1038/nmeth.2658</a>
</p>
<p>Anders, S. and Huber, W. (2010) Differential expression analysis for sequence count data. Genome Biology, 11, R106 <a href="https://doi.org/10.1186/gb-2010-11-10-r106">doi:10.1186/gb-2010-11-10-r106</a>
</p>
<p>Kumar, M., Slud, E., Okrah, K. et al. (2018) Analysis and correction of compositional bias in sparse sequencing count data. BMC Genomics 19, 799 <a href="https://doi.org/10.1186/s12864-018-5160-5">doi:10.1186/s12864-018-5160-5</a>
</p>
<p>Robinson, M.D., Oshlack, A. (2010) A scaling normalization method for differential expression analysis of RNA-seq data. Genome Biol 11, R25 <a href="https://doi.org/10.1186/gb-2010-11-3-r25">doi:10.1186/gb-2010-11-3-r25</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+compute_offset">compute_offset()</a></code> for details on the different normalization schemes
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(trichoptera)
proper_data &lt;- prepare_data(
 counts     = trichoptera$Abundance,
 covariates = trichoptera$Covariate,
 offset     = "GMPR",
 scale      = "count"
)
proper_data$Abundance
proper_data$Offset
</code></pre>

<hr>
<h2 id='rPLN'>PLN RNG</h2><span id='topic+rPLN'></span>

<h3>Description</h3>

<p>Random generation for the PLN model with latent mean equal to mu, latent covariance matrix
equal to Sigma and average depths (sum of counts in a sample) equal to depths
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rPLN(
  n = 10,
  mu = rep(0, ncol(Sigma)),
  Sigma = diag(1, 5, 5),
  depths = rep(10000, n)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rPLN_+3A_n">n</code></td>
<td>
<p>the sample size</p>
</td></tr>
<tr><td><code id="rPLN_+3A_mu">mu</code></td>
<td>
<p>vectors of means of the latent variable</p>
</td></tr>
<tr><td><code id="rPLN_+3A_sigma">Sigma</code></td>
<td>
<p>covariance matrix of the latent variable</p>
</td></tr>
<tr><td><code id="rPLN_+3A_depths">depths</code></td>
<td>
<p>Numeric vector of target depths. The first is recycled if there are not <code>n</code> values</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The default value for mu and Sigma assume equal abundances and no correlation between
the different species.
</p>


<h3>Value</h3>

<p>a n * p count matrix, with row-sums close to depths, with an attribute &quot;offsets&quot;
corresponding to the true generated offsets (in log-scale).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## 10 samples of 5 species with equal abundances, no covariance and target depths of 10,000
rPLN()
## 2 samples of 10 highly correlated species with target depths 1,000 and 100,000
## very different abundances
mu &lt;- rep(c(1, -1), each = 5)
Sigma &lt;- matrix(0.8, 10, 10); diag(Sigma) &lt;- 1
rPLN(n=2, mu = mu, Sigma = Sigma, depths = c(1e3, 1e5))

</code></pre>

<hr>
<h2 id='scRNA'>Single cell RNA-seq data</h2><span id='topic+scRNA'></span>

<h3>Description</h3>

<p>A dataset containing the counts of the 500 most varying transcripts in the mixtures of
5 cell lines in human liver (obtained with standard 10x scRNAseq Chromium protocol).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scRNA
</code></pre>


<h3>Format</h3>

<p>A data frame named 'scRNA' with 3918 rows (the cells) and 3 variables:
</p>

<dl>
<dt>counts</dt><dd><p>a 500 trancript by 3918 count matrix</p>
</dd>
<dt>cell_line</dt><dd><p>factor, the cell line of the current row (among 5)</p>
</dd>
<dt>total_counts</dt><dd><p>Total number of reads for that cell</p>
</dd>
</dl>
<p>...

</p>


<h3>Source</h3>

<p><a href="https://github.com/LuyiTian/sc_mixology/">https://github.com/LuyiTian/sc_mixology/</a>
</p>

<hr>
<h2 id='sigma.PLNfit'>Extract variance-covariance of residuals 'Sigma'</h2><span id='topic+sigma.PLNfit'></span>

<h3>Description</h3>

<p>Extract the variance-covariance matrix of the residuals, usually noted </p>
<p style="text-align: center;"><code class="reqn">\Sigma</code>
</p>
<p> in PLN models. This captures the correlation between the species in the latent space.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'PLNfit'
sigma(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sigma.PLNfit_+3A_object">object</code></td>
<td>
<p>an R6 object with class <code><a href="#topic+PLNfit">PLNfit</a></code></p>
</td></tr>
<tr><td><code id="sigma.PLNfit_+3A_...">...</code></td>
<td>
<p>additional parameters for S3 compatibility. Not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A semi definite positive matrix of size p, assuming there are p species in the model.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+coef.PLNfit">coef.PLNfit()</a></code>, <code><a href="#topic+standard_error.PLNfit">standard_error.PLNfit()</a></code> and <code><a href="#topic+vcov.PLNfit">vcov.PLNfit()</a></code> for other ways to access </p>
<p style="text-align: center;"><code class="reqn">\Sigma</code>
</p>
<p>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(trichoptera)
trichoptera &lt;- prepare_data(trichoptera$Abundance, trichoptera$Covariate)
myPLN &lt;- PLN(Abundance ~ 1 + offset(log(Offset)), data = trichoptera)
sigma(myPLN) ## Sigma
</code></pre>

<hr>
<h2 id='sigma.PLNmixturefit'>Extract variance-covariance of residuals 'Sigma'</h2><span id='topic+sigma.PLNmixturefit'></span>

<h3>Description</h3>

<p>Extract the variance-covariance matrix of the residuals, usually noted </p>
<p style="text-align: center;"><code class="reqn">\Sigma</code>
</p>
<p> in PLN models. This captures the correlation between the species in the latent space.
or PLNmixture, it is a weighted mean of the variance-covariance matrices of each component.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'PLNmixturefit'
sigma(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sigma.PLNmixturefit_+3A_object">object</code></td>
<td>
<p>an R6 object with class <code><a href="#topic+PLNmixturefit">PLNmixturefit</a></code></p>
</td></tr>
<tr><td><code id="sigma.PLNmixturefit_+3A_...">...</code></td>
<td>
<p>additional parameters for S3 compatibility. Not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A semi definite positive matrix of size p, assuming there are p species in the model.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+coef.PLNmixturefit">coef.PLNmixturefit()</a></code> for other ways to access </p>
<p style="text-align: center;"><code class="reqn">\Sigma</code>
</p>
<p>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(trichoptera)
trichoptera &lt;- prepare_data(trichoptera$Abundance, trichoptera$Covariate)
myPLN &lt;- PLNmixture(Abundance ~ 1 + offset(log(Offset)),
           data = trichoptera, control = PLNmixture_param(smoothing = "none"))  %&gt;% getBestModel()
sigma(myPLN) ## Sigma
</code></pre>

<hr>
<h2 id='sigma.ZIPLNfit'>Extract variance-covariance of residuals 'Sigma'</h2><span id='topic+sigma.ZIPLNfit'></span>

<h3>Description</h3>

<p>Extract the variance-covariance matrix of the residuals, usually noted <code class="reqn">\Sigma</code> in ZIPLN models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ZIPLNfit'
sigma(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sigma.ZIPLNfit_+3A_object">object</code></td>
<td>
<p>an R6 object with class <code><a href="#topic+ZIPLNfit">ZIPLNfit</a></code></p>
</td></tr>
<tr><td><code id="sigma.ZIPLNfit_+3A_...">...</code></td>
<td>
<p>additional parameters for S3 compatibility. Not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A semi definite positive matrix of size p, assuming there are p species in the model.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+coef.ZIPLNfit">coef.ZIPLNfit()</a></code>
</p>

<hr>
<h2 id='stability_selection'>Compute the stability path by stability selection</h2><span id='topic+stability_selection'></span>

<h3>Description</h3>

<p>This function computes the StARS stability criteria over a path of penalties. If a path has already been computed, the functions stops with a message unless <code>force = TRUE</code> has been specified.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stability_selection(
  Robject,
  subsamples = NULL,
  control = PLNnetwork_param(),
  force = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stability_selection_+3A_robject">Robject</code></td>
<td>
<p>an object with class <code><a href="#topic+PLNnetworkfamily">PLNnetworkfamily</a></code> or <code><a href="#topic+ZIPLNnetworkfamily">ZIPLNnetworkfamily</a></code>, i.e. an output from <code><a href="#topic+PLNnetwork">PLNnetwork()</a></code> or <code><a href="#topic+ZIPLNnetwork">ZIPLNnetwork()</a></code></p>
</td></tr>
<tr><td><code id="stability_selection_+3A_subsamples">subsamples</code></td>
<td>
<p>a list of vectors describing the subsamples. The number of vectors (or list length) determines th number of subsamples used in the stability selection. Automatically set to 20 subsamples with size <code>10*sqrt(n)</code> if <code>n &gt;= 144</code> and <code>0.8*n</code> otherwise following Liu et al. (2010) recommendations.</p>
</td></tr>
<tr><td><code id="stability_selection_+3A_control">control</code></td>
<td>
<p>a list controlling the main optimization process in each call to <code><a href="#topic+PLNnetwork">PLNnetwork()</a></code> or <code><a href="#topic+ZIPLNnetwork">ZIPLNnetwork()</a></code>. See <code><a href="#topic+PLN_param">PLN_param()</a></code> or <code><a href="#topic+ZIPLN_param">ZIPLN_param()</a></code> for details.</p>
</td></tr>
<tr><td><code id="stability_selection_+3A_force">force</code></td>
<td>
<p>force computation of the stability path, even if a previous one has been detected.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the list of subsamples. The estimated probabilities of selection of the edges are stored in the fields <code>stability_path</code> of the initial Robject with class <code><a href="#topic+Networkfamily">Networkfamily</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(trichoptera)
trichoptera &lt;- prepare_data(trichoptera$Abundance, trichoptera$Covariate)
fits &lt;- PLNnetwork(Abundance ~ 1, data = trichoptera)
## Not run: 
n &lt;- nrow(trichoptera)
subs &lt;- replicate(10, sample.int(n, size = n/2), simplify = FALSE)
stability_selection(nets, subsamples = subs)

## End(Not run)
</code></pre>

<hr>
<h2 id='standard_error.PLNPCAfit'>Component-wise standard errors of B</h2><span id='topic+standard_error.PLNPCAfit'></span><span id='topic+standard_error'></span><span id='topic+standard_error.PLNfit'></span><span id='topic+standard_error.PLNfit_fixedcov'></span><span id='topic+standard_error.PLNmixturefit'></span><span id='topic+standard_error.PLNnetworkfit'></span>

<h3>Description</h3>

<p>Extracts univariate standard errors for the estimated coefficient of B. Standard errors are computed from the (approximate) Fisher information matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'PLNPCAfit'
standard_error(
  object,
  type = c("variational", "jackknife", "sandwich"),
  parameter = c("B", "Omega")
)

standard_error(
  object,
  type = c("variational", "jackknife", "sandwich"),
  parameter = c("B", "Omega")
)

## S3 method for class 'PLNfit'
standard_error(
  object,
  type = c("variational", "jackknife", "bootstrap", "sandwich"),
  parameter = c("B", "Omega")
)

## S3 method for class 'PLNfit_fixedcov'
standard_error(
  object,
  type = c("variational", "jackknife", "bootstrap", "sandwich"),
  parameter = c("B", "Omega")
)

## S3 method for class 'PLNmixturefit'
standard_error(
  object,
  type = c("variational", "jackknife", "sandwich"),
  parameter = c("B", "Omega")
)

## S3 method for class 'PLNnetworkfit'
standard_error(
  object,
  type = c("variational", "jackknife", "sandwich"),
  parameter = c("B", "Omega")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="standard_error.PLNPCAfit_+3A_object">object</code></td>
<td>
<p>an R6 object with class PLNfit</p>
</td></tr>
<tr><td><code id="standard_error.PLNPCAfit_+3A_type">type</code></td>
<td>
<p>string describing the type of variance approximation: &quot;variational&quot;, &quot;jackknife&quot;, &quot;sandwich&quot; (only for fixed covariance). Default is &quot;variational&quot;.</p>
</td></tr>
<tr><td><code id="standard_error.PLNPCAfit_+3A_parameter">parameter</code></td>
<td>
<p>string describing the target parameter: either B (regression coefficients) or Omega (inverse residual covariance)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A p * d positive matrix (same size as <code class="reqn">B</code>) with standard errors for the coefficients of <code class="reqn">B</code>
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>standard_error(PLNPCAfit)</code>: Component-wise standard errors of B in <code><a href="#topic+PLNPCAfit">PLNPCAfit</a></code> (not implemented yet)
</p>
</li>
<li> <p><code>standard_error(PLNfit)</code>: Component-wise standard errors of B in <code><a href="#topic+PLNfit">PLNfit</a></code>
</p>
</li>
<li> <p><code>standard_error(PLNfit_fixedcov)</code>: Component-wise standard errors of B in <code><a href="#topic+PLNfit_fixedcov">PLNfit_fixedcov</a></code>
</p>
</li>
<li> <p><code>standard_error(PLNmixturefit)</code>: Component-wise standard errors of B in <code><a href="#topic+PLNmixturefit">PLNmixturefit</a></code> (not implemented yet)
</p>
</li>
<li> <p><code>standard_error(PLNnetworkfit)</code>: Component-wise standard errors of B in <code><a href="#topic+PLNnetworkfit">PLNnetworkfit</a></code> (not implemented yet)
</p>
</li></ul>


<h3>See Also</h3>

<p><code><a href="#topic+vcov.PLNfit">vcov.PLNfit()</a></code> for the complete variance covariance estimation of the coefficient
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(trichoptera)
trichoptera &lt;- prepare_data(trichoptera$Abundance, trichoptera$Covariate)
myPLN &lt;- PLN(Abundance ~ 1 + offset(log(Offset)), data = trichoptera,
              control = PLN_param(config_post = list(variational_var = TRUE)))
standard_error(myPLN)
</code></pre>

<hr>
<h2 id='trichoptera'>Trichoptera data set</h2><span id='topic+trichoptera'></span>

<h3>Description</h3>

<p>Data gathered between 1959 and 1960 during 49 insect trapping nights.
For each trapping night, the abundance of 17 Trichoptera
species is recorded as well as 6 meteorological variables which may influence
the abundance of each species. Finally, the observations (that is to say,
the trapping nights), have been classified into 12 groups corresponding to
contiguous nights between summer 1959 and summer 1960.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trichoptera
</code></pre>


<h3>Format</h3>

<p>A list with 2 two data frames:
</p>

<dl>
<dt>Abundance</dt><dd><p>a 49 x 17 matrix of abundancies/counts (49 trapping nights and 17 trichoptera species)</p>
</dd>
<dt>Covariate</dt><dd><p>a 49 x 7 data frame of covariates:
</p>

<dl>
<dt>Temperature</dt><dd><p>Evening Temperature in Celsius</p>
</dd>
<dt>Wind</dt><dd><p>Wind in m/s</p>
</dd>
<dt>Pressure</dt><dd><p>Pressure in mm Hg</p>
</dd>
<dt>Humidity</dt><dd><p>relative to evening humidity in percent</p>
</dd>
<dt>Cloudiness</dt><dd><p>proportion of sky coverage at 9pm</p>
</dd>
<dt>Precipitation</dt><dd><p>Nighttime precipitation in mm</p>
</dd>
<dt>Group</dt><dd><p>a factor of 12 levels for the definition of the consecutive night groups</p>
</dd>
</dl>

</dd>
</dl>

<p>In order to prepare the data for using formula in multivariate analysis (multiple outputs and inputs), use <code><a href="#topic+prepare_data">prepare_data()</a></code>.
We only kept a subset of the original meteorological covariates for illustration purposes.
</p>


<h3>Source</h3>

<p>Data from P. Usseglio-Polatera.
</p>


<h3>References</h3>

<p>Usseglio-Polatera, P. and Auda, Y. (1987) Influence des facteurs météorologiques sur les résultats de piégeage lumineux. Annales de Limnologie, 23, 65–79. (code des espèces p. 76)
See a data description at <a href="http://pbil.univ-lyon1.fr/R/pdf/pps034.pdf">http://pbil.univ-lyon1.fr/R/pdf/pps034.pdf</a> (in French)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+prepare_data">prepare_data()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(trichoptera)
trichoptera &lt;- prepare_data(trichoptera$Abundance, trichoptera$Covariate)
</code></pre>

<hr>
<h2 id='vcov.PLNfit'>Calculate Variance-Covariance Matrix for a fitted <code><a href="#topic+PLN">PLN()</a></code> model object</h2><span id='topic+vcov.PLNfit'></span>

<h3>Description</h3>

<p>Returns the variance-covariance matrix of the main parameters of a fitted <code><a href="#topic+PLN">PLN()</a></code> model object. The main parameters of the model correspond to </p>
<p style="text-align: center;"><code class="reqn">B</code>
</p>
<p>, as returned by <code><a href="#topic+coef.PLNfit">coef.PLNfit()</a></code>. The function can also be used to return the variance-covariance matrix of the residuals. The latter matrix can also be accessed via <code><a href="#topic+sigma.PLNfit">sigma.PLNfit()</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'PLNfit'
vcov(object, type = c("main", "covariance"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vcov.PLNfit_+3A_object">object</code></td>
<td>
<p>an R6 object with class <code><a href="#topic+PLNfit">PLNfit</a></code></p>
</td></tr>
<tr><td><code id="vcov.PLNfit_+3A_type">type</code></td>
<td>
<p>type of parameter that should be extracted. Either &quot;main&quot; (default) for </p>
<p style="text-align: center;"><code class="reqn">B</code>
</p>
<p> or &quot;covariance&quot; for </p>
<p style="text-align: center;"><code class="reqn">\Sigma</code>
</p>
</td></tr>
<tr><td><code id="vcov.PLNfit_+3A_...">...</code></td>
<td>
<p>additional parameters for S3 compatibility. Not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of variance/covariance extracted from the PLNfit model. If type=&quot;main&quot; and <code class="reqn">B</code> is a matrix of size d * p, the result is a block-diagonal matrix with p (number of species) blocks of size d (number of covariates). if type=&quot;main&quot;, it is a symmetric matrix of size p.
.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sigma.PLNfit">sigma.PLNfit()</a></code>, <code><a href="#topic+coef.PLNfit">coef.PLNfit()</a></code>, <code><a href="#topic+standard_error.PLNfit">standard_error.PLNfit()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(trichoptera)
trichoptera &lt;- prepare_data(trichoptera$Abundance, trichoptera$Covariate)
myPLN &lt;- PLN(Abundance ~ 1 + offset(log(Offset)), data = trichoptera)
vcov(myPLN, type = "covariance") ## Sigma
</code></pre>

<hr>
<h2 id='ZIPLN'>Zero Inflated Poisson lognormal model</h2><span id='topic+ZIPLN'></span>

<h3>Description</h3>

<p>Fit the multivariate Zero Inflated Poisson lognormal model with a variational algorithm. Use the (g)lm syntax for model specification (covariates, offsets, subset).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ZIPLN(
  formula,
  data,
  subset,
  zi = c("single", "row", "col"),
  control = ZIPLN_param()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ZIPLN_+3A_formula">formula</code></td>
<td>
<p>an object of class &quot;formula&quot;: a symbolic description of the model to be fitted.</p>
</td></tr>
<tr><td><code id="ZIPLN_+3A_data">data</code></td>
<td>
<p>an optional data frame, list or environment (or object coercible by as.data.frame to a data frame) containing the variables in the model. If not found in data, the variables are taken from environment(formula), typically the environment from which PLN is called.</p>
</td></tr>
<tr><td><code id="ZIPLN_+3A_subset">subset</code></td>
<td>
<p>an optional vector specifying a subset of observations to be used in the fitting process.</p>
</td></tr>
<tr><td><code id="ZIPLN_+3A_zi">zi</code></td>
<td>
<p>a character describing the model used for zero inflation, either of
</p>

<ul>
<li><p> &quot;single&quot; (default, one parameter shared by all counts)
</p>
</li>
<li><p> &quot;col&quot; (one parameter per variable / feature)
</p>
</li>
<li><p> &quot;row&quot; (one parameter per sample / individual).
If covariates are specified in the formula RHS (see details) this parameter is ignored.
</p>
</li></ul>
</td></tr>
<tr><td><code id="ZIPLN_+3A_control">control</code></td>
<td>
<p>a list-like structure for controlling the optimization, with default generated by <code><a href="#topic+ZIPLN_param">ZIPLN_param()</a></code>. See the associated documentation
for details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Covariates for the Zero-Inflation parameter (using a logistic regression model) can be specified in the formula RHS using the pipe
(<code style="white-space: pre;">&#8288;~ PLN effect | ZI effect&#8288;</code>) to separate covariates for the PLN part of the model from those for the Zero-Inflation part.
Note that different covariates can be used for each part.
</p>


<h3>Value</h3>

<p>an R6 object with class <code><a href="#topic+ZIPLNfit">ZIPLNfit</a></code>
</p>


<h3>See Also</h3>

<p>The class <code><a href="#topic+ZIPLNfit">ZIPLNfit</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(trichoptera)
trichoptera &lt;- prepare_data(trichoptera$Abundance, trichoptera$Covariate)
## Use different models for zero-inflation...
myZIPLN_single &lt;- ZIPLN(Abundance ~ 1, data = trichoptera, zi = "single")
## Not run: 
myZIPLN_row    &lt;- ZIPLN(Abundance ~ 1, data = trichoptera, zi = "row")
myZIPLN_col    &lt;- ZIPLN(Abundance ~ 1, data = trichoptera, zi = "col")
## ...including logistic regression on covariates
myZIPLN_covar  &lt;- ZIPLN(Abundance ~ 1 | 1 + Wind, data = trichoptera)

## End(Not run)
</code></pre>

<hr>
<h2 id='ZIPLN_param'>Control of a ZIPLN fit</h2><span id='topic+ZIPLN_param'></span>

<h3>Description</h3>

<p>Helper to define list of parameters to control the PLN fit. All arguments have defaults.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ZIPLN_param(
  backend = c("nlopt"),
  trace = 1,
  covariance = c("full", "diagonal", "spherical", "fixed", "sparse"),
  Omega = NULL,
  penalty = 0,
  penalize_diagonal = TRUE,
  penalty_weights = NULL,
  config_post = list(),
  config_optim = list(),
  inception = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ZIPLN_param_+3A_backend">backend</code></td>
<td>
<p>optimization back used, either &quot;nlopt&quot; or &quot;torch&quot;. Default is &quot;nlopt&quot;</p>
</td></tr>
<tr><td><code id="ZIPLN_param_+3A_trace">trace</code></td>
<td>
<p>a integer for verbosity.</p>
</td></tr>
<tr><td><code id="ZIPLN_param_+3A_covariance">covariance</code></td>
<td>
<p>character setting the model for the covariance matrix. Either &quot;full&quot;, &quot;diagonal&quot;, &quot;spherical&quot; or &quot;fixed&quot;. Default is &quot;full&quot;.</p>
</td></tr>
<tr><td><code id="ZIPLN_param_+3A_omega">Omega</code></td>
<td>
<p>precision matrix of the latent variables. Inverse of Sigma. Must be specified if <code>covariance</code> is &quot;fixed&quot;</p>
</td></tr>
<tr><td><code id="ZIPLN_param_+3A_penalty">penalty</code></td>
<td>
<p>a user-defined penalty to sparsify the residual covariance. Defaults to 0 (no sparsity).</p>
</td></tr>
<tr><td><code id="ZIPLN_param_+3A_penalize_diagonal">penalize_diagonal</code></td>
<td>
<p>boolean: should the diagonal terms be penalized in the graphical-Lasso? Default is <code>TRUE</code></p>
</td></tr>
<tr><td><code id="ZIPLN_param_+3A_penalty_weights">penalty_weights</code></td>
<td>
<p>either a single or a list of p x p matrix of weights (default: all weights equal to 1) to adapt the amount of shrinkage to each pairs of node. Must be symmetric with positive values.</p>
</td></tr>
<tr><td><code id="ZIPLN_param_+3A_config_post">config_post</code></td>
<td>
<p>a list for controlling the post-treatments (optional bootstrap, jackknife, R2, etc.). See details</p>
</td></tr>
<tr><td><code id="ZIPLN_param_+3A_config_optim">config_optim</code></td>
<td>
<p>a list for controlling the optimizer (either &quot;nlopt&quot; or &quot;torch&quot; backend). See details</p>
</td></tr>
<tr><td><code id="ZIPLN_param_+3A_inception">inception</code></td>
<td>
<p>Set up the parameters initialization: by default, the model is initialized with a multivariate linear model applied on
log-transformed data, and with the same formula as the one provided by the user. However, the user can provide a PLNfit (typically obtained from a previous fit),
which sometimes speeds up the inference.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <code><a href="#topic+PLN_param">PLN_param()</a></code> and <code><a href="#topic+PLNnetwork_param">PLNnetwork_param()</a></code> for a full description of the generic optimization parameters. Like <code><a href="#topic+PLNnetwork_param">PLNnetwork_param()</a></code>, ZIPLN_param() has two parameters controlling the optimization due the inner-outer loop structure of the optimizer:
</p>

<ul>
<li><p> &quot;ftol_out&quot; outer solver stops when an optimization step changes the objective function by less than <code>ftol_out</code> multiplied by the absolute value of the parameter. Default is 1e-6
</p>
</li>
<li><p> &quot;maxit_out&quot; outer solver stops when the number of iteration exceeds <code>maxit_out</code>. Default is 100
and one additional parameter controlling the form of the variational approximation of the zero inflation:
</p>
</li>
<li><p> &quot;approx_ZI&quot; either uses an exact or approximated conditional distribution for the zero inflation. Default is FALSE
</p>
</li></ul>



<h3>Value</h3>

<p>list of parameters used during the fit and post-processing steps
</p>

<hr>
<h2 id='ZIPLNfit'>An R6 Class to represent a ZIPLNfit</h2><span id='topic+ZIPLNfit'></span>

<h3>Description</h3>

<p>The function <code><a href="#topic+ZIPLN">ZIPLN()</a></code> fits a model which is an instance of an object with class <code><a href="#topic+ZIPLNfit">ZIPLNfit</a></code>.
</p>
<p>This class comes with a set of R6 methods, some of which are useful for the end-user and exported as S3 methods.
See the documentation for <code><a href="stats.html#topic+coef">coef()</a></code>, <code><a href="stats.html#topic+sigma">sigma()</a></code>, <code><a href="stats.html#topic+predict">predict()</a></code>.
</p>
<p>Fields are accessed via active binding and cannot be changed by the user.
</p>


<h3>Details</h3>

<p>Covariates for the Zero-Inflation parameter (using a logistic regression model) can be specified in the formula RHS using the pipe
(<code style="white-space: pre;">&#8288;~ PLN effect | ZI effect&#8288;</code>) to separate covariates for the PLN part of the model from those for the Zero-Inflation part.
Note that different covariates can be used for each part.
</p>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>n</code></dt><dd><p>number of samples/sites</p>
</dd>
<dt><code>q</code></dt><dd><p>number of dimensions of the latent space</p>
</dd>
<dt><code>p</code></dt><dd><p>number of variables/species</p>
</dd>
<dt><code>d</code></dt><dd><p>number of covariates in the PLN part</p>
</dd>
<dt><code>d0</code></dt><dd><p>number of covariates in the ZI part</p>
</dd>
<dt><code>nb_param_zi</code></dt><dd><p>number of parameters in the ZI part of the model</p>
</dd>
<dt><code>nb_param_pln</code></dt><dd><p>number of parameters in the PLN part of the model</p>
</dd>
<dt><code>nb_param</code></dt><dd><p>number of parameters in the ZIPLN model</p>
</dd>
<dt><code>model_par</code></dt><dd><p>a list with the matrices of parameters found in the model (B, Sigma, plus some others depending on the variant)</p>
</dd>
<dt><code>var_par</code></dt><dd><p>a list with two matrices, M and S2, which are the estimated parameters in the variational approximation</p>
</dd>
<dt><code>optim_par</code></dt><dd><p>a list with parameters useful for monitoring the optimization</p>
</dd>
<dt><code>latent</code></dt><dd><p>a matrix: values of the latent vector (Z in the model)</p>
</dd>
<dt><code>latent_pos</code></dt><dd><p>a matrix: values of the latent position vector (Z) without covariates effects or offset</p>
</dd>
<dt><code>fitted</code></dt><dd><p>a matrix: fitted values of the observations (A in the model)</p>
</dd>
<dt><code>vcov_model</code></dt><dd><p>character: the model used for the covariance (either &quot;spherical&quot;, &quot;diagonal&quot;, &quot;full&quot; or &quot;sparse&quot;)</p>
</dd>
<dt><code>zi_model</code></dt><dd><p>character: the model used for the zero inflation (either &quot;single&quot;, &quot;row&quot;, &quot;col&quot; or &quot;covar&quot;)</p>
</dd>
<dt><code>loglik</code></dt><dd><p>(weighted) variational lower bound of the loglikelihood</p>
</dd>
<dt><code>loglik_vec</code></dt><dd><p>element-wise variational lower bound of the loglikelihood</p>
</dd>
<dt><code>BIC</code></dt><dd><p>variational lower bound of the BIC</p>
</dd>
<dt><code>entropy</code></dt><dd><p>Entropy of the variational distribution</p>
</dd>
<dt><code>entropy_ZI</code></dt><dd><p>Entropy of the variational distribution</p>
</dd>
<dt><code>entropy_PLN</code></dt><dd><p>Entropy of the Gaussian variational distribution in the PLN component</p>
</dd>
<dt><code>ICL</code></dt><dd><p>variational lower bound of the ICL</p>
</dd>
<dt><code>criteria</code></dt><dd><p>a vector with loglik, BIC, ICL and number of parameters</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-ZIPLNfit-update"><code>ZIPLNfit$update()</code></a>
</p>
</li>
<li> <p><a href="#method-ZIPLNfit-new"><code>ZIPLNfit$new()</code></a>
</p>
</li>
<li> <p><a href="#method-ZIPLNfit-optimize"><code>ZIPLNfit$optimize()</code></a>
</p>
</li>
<li> <p><a href="#method-ZIPLNfit-optimize_vestep"><code>ZIPLNfit$optimize_vestep()</code></a>
</p>
</li>
<li> <p><a href="#method-ZIPLNfit-predict"><code>ZIPLNfit$predict()</code></a>
</p>
</li>
<li> <p><a href="#method-ZIPLNfit-show"><code>ZIPLNfit$show()</code></a>
</p>
</li>
<li> <p><a href="#method-ZIPLNfit-print"><code>ZIPLNfit$print()</code></a>
</p>
</li>
<li> <p><a href="#method-ZIPLNfit-clone"><code>ZIPLNfit$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-ZIPLNfit-update"></a>



<h4>Method <code>update()</code></h4>

<p>Update a <code><a href="#topic+ZIPLNfit">ZIPLNfit</a></code> object
</p>


<h5>Usage</h5>

<div class="r"><pre>ZIPLNfit$update(
  B = NA,
  B0 = NA,
  Pi = NA,
  Omega = NA,
  Sigma = NA,
  M = NA,
  S = NA,
  R = NA,
  Ji = NA,
  Z = NA,
  A = NA,
  monitoring = NA
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>B</code></dt><dd><p>matrix of regression parameters in the Poisson lognormal component</p>
</dd>
<dt><code>B0</code></dt><dd><p>matrix of regression parameters in the zero inflated component</p>
</dd>
<dt><code>Pi</code></dt><dd><p>Zero inflated probability parameter (either scalar, row-vector, col-vector or matrix)</p>
</dd>
<dt><code>Omega</code></dt><dd><p>precision matrix of the latent variables</p>
</dd>
<dt><code>Sigma</code></dt><dd><p>covariance matrix of the latent variables</p>
</dd>
<dt><code>M</code></dt><dd><p>matrix of mean vectors for the variational approximation</p>
</dd>
<dt><code>S</code></dt><dd><p>matrix of standard deviation parameters for the variational approximation</p>
</dd>
<dt><code>R</code></dt><dd><p>matrix of probabilities for the variational approximation</p>
</dd>
<dt><code>Ji</code></dt><dd><p>vector of variational lower bounds of the log-likelihoods (one value per sample)</p>
</dd>
<dt><code>Z</code></dt><dd><p>matrix of latent vectors (includes covariates and offset effects)</p>
</dd>
<dt><code>A</code></dt><dd><p>matrix of fitted values</p>
</dd>
<dt><code>monitoring</code></dt><dd><p>a list with optimization monitoring quantities</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>Update the current <code><a href="#topic+ZIPLNfit">ZIPLNfit</a></code> object
</p>


<hr>
<a id="method-ZIPLNfit-new"></a>



<h4>Method <code>new()</code></h4>

<p>Initialize a <code><a href="#topic+ZIPLNfit">ZIPLNfit</a></code> model
</p>


<h5>Usage</h5>

<div class="r"><pre>ZIPLNfit$new(data, control)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>data</code></dt><dd><p>a named list used internally to carry the data matrices</p>
</dd>
<dt><code>control</code></dt><dd><p>a list for controlling the optimization. See details.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-ZIPLNfit-optimize"></a>



<h4>Method <code>optimize()</code></h4>

<p>Call to the Cpp optimizer and update of the relevant fields
</p>


<h5>Usage</h5>

<div class="r"><pre>ZIPLNfit$optimize(data, control)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>data</code></dt><dd><p>a named list used internally to carry the data matrices</p>
</dd>
<dt><code>control</code></dt><dd><p>a list for controlling the optimization. See details.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-ZIPLNfit-optimize_vestep"></a>



<h4>Method <code>optimize_vestep()</code></h4>

<p>Result of one call to the VE step of the optimization procedure: optimal variational parameters (M, S, R) and corresponding log likelihood values for fixed model parameters (Sigma, B, B0). Intended to position new data in the latent space.
</p>


<h5>Usage</h5>

<div class="r"><pre>ZIPLNfit$optimize_vestep(
  data,
  B = self$model_par$B,
  B0 = self$model_par$B0,
  Omega = self$model_par$Omega,
  control = ZIPLN_param(backend = "nlopt")$config_optim
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>data</code></dt><dd><p>a named list used internally to carry the data matrices</p>
</dd>
<dt><code>B</code></dt><dd><p>Optional fixed value of the regression parameters in the PLN component</p>
</dd>
<dt><code>B0</code></dt><dd><p>Optional fixed value of the regression parameters in the ZI component</p>
</dd>
<dt><code>Omega</code></dt><dd><p>inverse variance-covariance matrix of the latent variables</p>
</dd>
<dt><code>control</code></dt><dd><p>a list for controlling the optimization. See details.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A list with three components:
</p>

<ul>
<li><p> the matrix <code>M</code> of variational means,
</p>
</li>
<li><p> the matrix <code>S</code> of variational standard deviations
</p>
</li>
<li><p> the matrix <code>R</code> of variational ZI probabilities
</p>
</li>
<li><p> the vector <code>Ji</code> of (variational) log-likelihood of each new observation
</p>
</li>
<li><p> a list <code>monitoring</code> with information about convergence status
</p>
</li></ul>



<hr>
<a id="method-ZIPLNfit-predict"></a>



<h4>Method <code>predict()</code></h4>

<p>Predict position, scores or observations of new data. See <code><a href="#topic+predict.ZIPLNfit">predict.ZIPLNfit()</a></code> for the S3 method and additional details
</p>


<h5>Usage</h5>

<div class="r"><pre>ZIPLNfit$predict(
  newdata,
  responses = NULL,
  type = c("link", "response", "deflated"),
  level = 1,
  envir = parent.frame()
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>newdata</code></dt><dd><p>A data frame in which to look for variables with which to predict. If omitted, the fitted values are used.</p>
</dd>
<dt><code>responses</code></dt><dd><p>Optional data frame containing the count of the observed variables (matching the names of the provided as data in the PLN function), assuming the interest in in testing the model.</p>
</dd>
<dt><code>type</code></dt><dd><p>Scale used for the prediction. Either <code>"link"</code> (default, predicted positions in the latent space), <code>"response"</code> (predicted average counts, accounting for zero-inflation) or <code>"deflated"</code> (predicted average counts, not accounting for zero-inflation and using only the PLN part of the model).</p>
</dd>
<dt><code>level</code></dt><dd><p>Optional integer value the level to be used in obtaining the predictions. Level zero corresponds to the population predictions (default if <code>responses</code> is not provided) while level one (default) corresponds to predictions after evaluating the variational parameters for the new data.</p>
</dd>
<dt><code>envir</code></dt><dd><p>Environment in which the prediction is evaluated</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A matrix with predictions scores or counts.
</p>


<hr>
<a id="method-ZIPLNfit-show"></a>



<h4>Method <code>show()</code></h4>

<p>User friendly print method
</p>


<h5>Usage</h5>

<div class="r"><pre>ZIPLNfit$show(
  model = paste("A multivariate Zero Inflated Poisson Lognormal fit with",
    private$covariance, "covariance model.\n")
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>model</code></dt><dd><p>First line of the print output</p>
</dd>
</dl>

</div>


<hr>
<a id="method-ZIPLNfit-print"></a>



<h4>Method <code>print()</code></h4>

<p>User friendly print method
</p>


<h5>Usage</h5>

<div class="r"><pre>ZIPLNfit$print()</pre></div>


<hr>
<a id="method-ZIPLNfit-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>ZIPLNfit$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# See other examples in function ZIPLN
data(trichoptera)
trichoptera &lt;- prepare_data(trichoptera$Abundance, trichoptera$Covariate)
myPLN &lt;- ZIPLN(Abundance ~ 1, data = trichoptera)
class(myPLN)
print(myPLN)

## End(Not run)

</code></pre>

<hr>
<h2 id='ZIPLNfit_diagonal'>An R6 Class to represent a ZIPLNfit in a standard, general framework, with diagonal residual covariance</h2><span id='topic+ZIPLNfit_diagonal'></span>

<h3>Description</h3>

<p>An R6 Class to represent a ZIPLNfit in a standard, general framework, with diagonal residual covariance
</p>
<p>An R6 Class to represent a ZIPLNfit in a standard, general framework, with diagonal residual covariance
</p>


<h3>Super class</h3>

<p><code><a href="#topic+ZIPLNfit">PLNmodels::ZIPLNfit</a></code> -&gt; <code>ZIPLNfit_diagonal</code>
</p>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>nb_param_pln</code></dt><dd><p>number of parameters in the PLN part of the current model</p>
</dd>
<dt><code>vcov_model</code></dt><dd><p>character: the model used for the residual covariance</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-ZIPLNfit_diagonal-new"><code>ZIPLNfit_diagonal$new()</code></a>
</p>
</li>
<li> <p><a href="#method-ZIPLNfit_diagonal-clone"><code>ZIPLNfit_diagonal$clone()</code></a>
</p>
</li></ul>



<details><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="PLNmodels" data-topic="ZIPLNfit" data-id="optimize"><a href='../../PLNmodels/html/ZIPLNfit.html#method-ZIPLNfit-optimize'><code>PLNmodels::ZIPLNfit$optimize()</code></a></span></li>
<li><span class="pkg-link" data-pkg="PLNmodels" data-topic="ZIPLNfit" data-id="optimize_vestep"><a href='../../PLNmodels/html/ZIPLNfit.html#method-ZIPLNfit-optimize_vestep'><code>PLNmodels::ZIPLNfit$optimize_vestep()</code></a></span></li>
<li><span class="pkg-link" data-pkg="PLNmodels" data-topic="ZIPLNfit" data-id="predict"><a href='../../PLNmodels/html/ZIPLNfit.html#method-ZIPLNfit-predict'><code>PLNmodels::ZIPLNfit$predict()</code></a></span></li>
<li><span class="pkg-link" data-pkg="PLNmodels" data-topic="ZIPLNfit" data-id="print"><a href='../../PLNmodels/html/ZIPLNfit.html#method-ZIPLNfit-print'><code>PLNmodels::ZIPLNfit$print()</code></a></span></li>
<li><span class="pkg-link" data-pkg="PLNmodels" data-topic="ZIPLNfit" data-id="show"><a href='../../PLNmodels/html/ZIPLNfit.html#method-ZIPLNfit-show'><code>PLNmodels::ZIPLNfit$show()</code></a></span></li>
<li><span class="pkg-link" data-pkg="PLNmodels" data-topic="ZIPLNfit" data-id="update"><a href='../../PLNmodels/html/ZIPLNfit.html#method-ZIPLNfit-update'><code>PLNmodels::ZIPLNfit$update()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-ZIPLNfit_diagonal-new"></a>



<h4>Method <code>new()</code></h4>

<p>Initialize a <code><a href="#topic+ZIPLNfit_diagonal">ZIPLNfit_diagonal</a></code> model
</p>


<h5>Usage</h5>

<div class="r"><pre>ZIPLNfit_diagonal$new(data, control)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>data</code></dt><dd><p>a named list used internally to carry the data matrices</p>
</dd>
<dt><code>control</code></dt><dd><p>a list for controlling the optimization. See details.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-ZIPLNfit_diagonal-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>ZIPLNfit_diagonal$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# See other examples in function ZIPLN
data(trichoptera)
trichoptera &lt;- prepare_data(trichoptera$Abundance, trichoptera$Covariate)
myPLN &lt;- ZIPLN(Abundance ~ 1, data = trichoptera, control = ZIPLN_param(covariance = "diagonal"))
class(myPLN)
print(myPLN)

## End(Not run)
</code></pre>

<hr>
<h2 id='ZIPLNfit_fixed'>An R6 Class to represent a ZIPLNfit in a standard, general framework, with fixed (inverse) residual covariance</h2><span id='topic+ZIPLNfit_fixed'></span>

<h3>Description</h3>

<p>An R6 Class to represent a ZIPLNfit in a standard, general framework, with fixed (inverse) residual covariance
</p>
<p>An R6 Class to represent a ZIPLNfit in a standard, general framework, with fixed (inverse) residual covariance
</p>


<h3>Super class</h3>

<p><code><a href="#topic+ZIPLNfit">PLNmodels::ZIPLNfit</a></code> -&gt; <code>ZIPLNfit_fixed</code>
</p>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>nb_param_pln</code></dt><dd><p>number of parameters in the PLN part of the current model</p>
</dd>
<dt><code>vcov_model</code></dt><dd><p>character: the model used for the residual covariance</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-ZIPLNfit_fixed-new"><code>ZIPLNfit_fixed$new()</code></a>
</p>
</li>
<li> <p><a href="#method-ZIPLNfit_fixed-clone"><code>ZIPLNfit_fixed$clone()</code></a>
</p>
</li></ul>



<details><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="PLNmodels" data-topic="ZIPLNfit" data-id="optimize"><a href='../../PLNmodels/html/ZIPLNfit.html#method-ZIPLNfit-optimize'><code>PLNmodels::ZIPLNfit$optimize()</code></a></span></li>
<li><span class="pkg-link" data-pkg="PLNmodels" data-topic="ZIPLNfit" data-id="optimize_vestep"><a href='../../PLNmodels/html/ZIPLNfit.html#method-ZIPLNfit-optimize_vestep'><code>PLNmodels::ZIPLNfit$optimize_vestep()</code></a></span></li>
<li><span class="pkg-link" data-pkg="PLNmodels" data-topic="ZIPLNfit" data-id="predict"><a href='../../PLNmodels/html/ZIPLNfit.html#method-ZIPLNfit-predict'><code>PLNmodels::ZIPLNfit$predict()</code></a></span></li>
<li><span class="pkg-link" data-pkg="PLNmodels" data-topic="ZIPLNfit" data-id="print"><a href='../../PLNmodels/html/ZIPLNfit.html#method-ZIPLNfit-print'><code>PLNmodels::ZIPLNfit$print()</code></a></span></li>
<li><span class="pkg-link" data-pkg="PLNmodels" data-topic="ZIPLNfit" data-id="show"><a href='../../PLNmodels/html/ZIPLNfit.html#method-ZIPLNfit-show'><code>PLNmodels::ZIPLNfit$show()</code></a></span></li>
<li><span class="pkg-link" data-pkg="PLNmodels" data-topic="ZIPLNfit" data-id="update"><a href='../../PLNmodels/html/ZIPLNfit.html#method-ZIPLNfit-update'><code>PLNmodels::ZIPLNfit$update()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-ZIPLNfit_fixed-new"></a>



<h4>Method <code>new()</code></h4>

<p>Initialize a <code><a href="#topic+ZIPLNfit_fixed">ZIPLNfit_fixed</a></code> model
</p>


<h5>Usage</h5>

<div class="r"><pre>ZIPLNfit_fixed$new(data, control)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>data</code></dt><dd><p>a named list used internally to carry the data matrices</p>
</dd>
<dt><code>control</code></dt><dd><p>a list for controlling the optimization. See details.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-ZIPLNfit_fixed-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>ZIPLNfit_fixed$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# See other examples in function ZIPLN
data(trichoptera)
trichoptera &lt;- prepare_data(trichoptera$Abundance, trichoptera$Covariate)
myPLN &lt;- ZIPLN(Abundance ~ 1, data = trichoptera,
    control = ZIPLN_param(Omega = diag(ncol(trichoptera$Abundance))))
class(myPLN)
print(myPLN)

## End(Not run)
</code></pre>

<hr>
<h2 id='ZIPLNfit_sparse'>An R6 Class to represent a ZIPLNfit in a standard, general framework, with sparse inverse residual covariance</h2><span id='topic+ZIPLNfit_sparse'></span>

<h3>Description</h3>

<p>An R6 Class to represent a ZIPLNfit in a standard, general framework, with sparse inverse residual covariance
</p>
<p>An R6 Class to represent a ZIPLNfit in a standard, general framework, with sparse inverse residual covariance
</p>


<h3>Super class</h3>

<p><code><a href="#topic+ZIPLNfit">PLNmodels::ZIPLNfit</a></code> -&gt; <code>ZIPLNfit_sparse</code>
</p>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>penalty</code></dt><dd><p>the global level of sparsity in the current model</p>
</dd>
<dt><code>penalty_weights</code></dt><dd><p>a matrix of weights controlling the amount of penalty element-wise.</p>
</dd>
<dt><code>n_edges</code></dt><dd><p>number of edges if the network (non null coefficient of the sparse precision matrix)</p>
</dd>
<dt><code>nb_param_pln</code></dt><dd><p>number of parameters in the PLN part of the current model</p>
</dd>
<dt><code>vcov_model</code></dt><dd><p>character: the model used for the residual covariance</p>
</dd>
<dt><code>pen_loglik</code></dt><dd><p>variational lower bound of the l1-penalized loglikelihood</p>
</dd>
<dt><code>EBIC</code></dt><dd><p>variational lower bound of the EBIC</p>
</dd>
<dt><code>density</code></dt><dd><p>proportion of non-null edges in the network</p>
</dd>
<dt><code>criteria</code></dt><dd><p>a vector with loglik, penalized loglik, BIC, EBIC, ICL, R_squared, number of parameters, number of edges and graph density</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-ZIPLNfit_sparse-new"><code>ZIPLNfit_sparse$new()</code></a>
</p>
</li>
<li> <p><a href="#method-ZIPLNfit_sparse-latent_network"><code>ZIPLNfit_sparse$latent_network()</code></a>
</p>
</li>
<li> <p><a href="#method-ZIPLNfit_sparse-plot_network"><code>ZIPLNfit_sparse$plot_network()</code></a>
</p>
</li>
<li> <p><a href="#method-ZIPLNfit_sparse-clone"><code>ZIPLNfit_sparse$clone()</code></a>
</p>
</li></ul>



<details><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="PLNmodels" data-topic="ZIPLNfit" data-id="optimize"><a href='../../PLNmodels/html/ZIPLNfit.html#method-ZIPLNfit-optimize'><code>PLNmodels::ZIPLNfit$optimize()</code></a></span></li>
<li><span class="pkg-link" data-pkg="PLNmodels" data-topic="ZIPLNfit" data-id="optimize_vestep"><a href='../../PLNmodels/html/ZIPLNfit.html#method-ZIPLNfit-optimize_vestep'><code>PLNmodels::ZIPLNfit$optimize_vestep()</code></a></span></li>
<li><span class="pkg-link" data-pkg="PLNmodels" data-topic="ZIPLNfit" data-id="predict"><a href='../../PLNmodels/html/ZIPLNfit.html#method-ZIPLNfit-predict'><code>PLNmodels::ZIPLNfit$predict()</code></a></span></li>
<li><span class="pkg-link" data-pkg="PLNmodels" data-topic="ZIPLNfit" data-id="print"><a href='../../PLNmodels/html/ZIPLNfit.html#method-ZIPLNfit-print'><code>PLNmodels::ZIPLNfit$print()</code></a></span></li>
<li><span class="pkg-link" data-pkg="PLNmodels" data-topic="ZIPLNfit" data-id="show"><a href='../../PLNmodels/html/ZIPLNfit.html#method-ZIPLNfit-show'><code>PLNmodels::ZIPLNfit$show()</code></a></span></li>
<li><span class="pkg-link" data-pkg="PLNmodels" data-topic="ZIPLNfit" data-id="update"><a href='../../PLNmodels/html/ZIPLNfit.html#method-ZIPLNfit-update'><code>PLNmodels::ZIPLNfit$update()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-ZIPLNfit_sparse-new"></a>



<h4>Method <code>new()</code></h4>

<p>Initialize a <code><a href="#topic+ZIPLNfit_fixed">ZIPLNfit_fixed</a></code> model
</p>


<h5>Usage</h5>

<div class="r"><pre>ZIPLNfit_sparse$new(data, control)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>data</code></dt><dd><p>a named list used internally to carry the data matrices</p>
</dd>
<dt><code>control</code></dt><dd><p>a list for controlling the optimization. See details.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-ZIPLNfit_sparse-latent_network"></a>



<h4>Method <code>latent_network()</code></h4>

<p>Extract interaction network in the latent space
</p>


<h5>Usage</h5>

<div class="r"><pre>ZIPLNfit_sparse$latent_network(type = c("partial_cor", "support", "precision"))</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>type</code></dt><dd><p>edge value in the network. Can be &quot;support&quot; (binary edges), &quot;precision&quot; (coefficient of the precision matrix) or &quot;partial_cor&quot; (partial correlation between species)</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>a square matrix of size <code>ZIPLNfit_sparse$n</code>
</p>


<hr>
<a id="method-ZIPLNfit_sparse-plot_network"></a>



<h4>Method <code>plot_network()</code></h4>

<p>plot the latent network.
</p>


<h5>Usage</h5>

<div class="r"><pre>ZIPLNfit_sparse$plot_network(
  type = c("partial_cor", "support"),
  output = c("igraph", "corrplot"),
  edge.color = c("#F8766D", "#00BFC4"),
  remove.isolated = FALSE,
  node.labels = NULL,
  layout = layout_in_circle,
  plot = TRUE
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>type</code></dt><dd><p>edge value in the network. Either &quot;precision&quot; (coefficient of the precision matrix) or &quot;partial_cor&quot; (partial correlation between species).</p>
</dd>
<dt><code>output</code></dt><dd><p>Output type. Either <code>igraph</code> (for the network) or <code>corrplot</code> (for the adjacency matrix)</p>
</dd>
<dt><code>edge.color</code></dt><dd><p>Length 2 color vector. Color for positive/negative edges. Default is <code>c("#F8766D", "#00BFC4")</code>. Only relevant for igraph output.</p>
</dd>
<dt><code>remove.isolated</code></dt><dd><p>if <code>TRUE</code>, isolated node are remove before plotting. Only relevant for igraph output.</p>
</dd>
<dt><code>node.labels</code></dt><dd><p>vector of character. The labels of the nodes. The default will use the column names ot the response matrix.</p>
</dd>
<dt><code>layout</code></dt><dd><p>an optional igraph layout. Only relevant for igraph output.</p>
</dd>
<dt><code>plot</code></dt><dd><p>logical. Should the final network be displayed or only sent back to the user. Default is <code>TRUE</code>.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-ZIPLNfit_sparse-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>ZIPLNfit_sparse$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# See other examples in function ZIPLN
data(trichoptera)
trichoptera &lt;- prepare_data(trichoptera$Abundance, trichoptera$Covariate)
myPLN &lt;- ZIPLN(Abundance ~ 1, data = trichoptera, control=  ZIPLN_param(penalty = 1))
class(myPLN)
print(myPLN)
plot(myPLN)

## End(Not run)
</code></pre>

<hr>
<h2 id='ZIPLNfit_spherical'>An R6 Class to represent a ZIPLNfit in a standard, general framework, with spherical residual covariance</h2><span id='topic+ZIPLNfit_spherical'></span>

<h3>Description</h3>

<p>An R6 Class to represent a ZIPLNfit in a standard, general framework, with spherical residual covariance
</p>
<p>An R6 Class to represent a ZIPLNfit in a standard, general framework, with spherical residual covariance
</p>


<h3>Super class</h3>

<p><code><a href="#topic+ZIPLNfit">PLNmodels::ZIPLNfit</a></code> -&gt; <code>ZIPLNfit_spherical</code>
</p>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>nb_param_pln</code></dt><dd><p>number of parameters in the PLN part of the current model</p>
</dd>
<dt><code>vcov_model</code></dt><dd><p>character: the model used for the residual covariance</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-ZIPLNfit_spherical-new"><code>ZIPLNfit_spherical$new()</code></a>
</p>
</li>
<li> <p><a href="#method-ZIPLNfit_spherical-clone"><code>ZIPLNfit_spherical$clone()</code></a>
</p>
</li></ul>



<details><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="PLNmodels" data-topic="ZIPLNfit" data-id="optimize"><a href='../../PLNmodels/html/ZIPLNfit.html#method-ZIPLNfit-optimize'><code>PLNmodels::ZIPLNfit$optimize()</code></a></span></li>
<li><span class="pkg-link" data-pkg="PLNmodels" data-topic="ZIPLNfit" data-id="optimize_vestep"><a href='../../PLNmodels/html/ZIPLNfit.html#method-ZIPLNfit-optimize_vestep'><code>PLNmodels::ZIPLNfit$optimize_vestep()</code></a></span></li>
<li><span class="pkg-link" data-pkg="PLNmodels" data-topic="ZIPLNfit" data-id="predict"><a href='../../PLNmodels/html/ZIPLNfit.html#method-ZIPLNfit-predict'><code>PLNmodels::ZIPLNfit$predict()</code></a></span></li>
<li><span class="pkg-link" data-pkg="PLNmodels" data-topic="ZIPLNfit" data-id="print"><a href='../../PLNmodels/html/ZIPLNfit.html#method-ZIPLNfit-print'><code>PLNmodels::ZIPLNfit$print()</code></a></span></li>
<li><span class="pkg-link" data-pkg="PLNmodels" data-topic="ZIPLNfit" data-id="show"><a href='../../PLNmodels/html/ZIPLNfit.html#method-ZIPLNfit-show'><code>PLNmodels::ZIPLNfit$show()</code></a></span></li>
<li><span class="pkg-link" data-pkg="PLNmodels" data-topic="ZIPLNfit" data-id="update"><a href='../../PLNmodels/html/ZIPLNfit.html#method-ZIPLNfit-update'><code>PLNmodels::ZIPLNfit$update()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-ZIPLNfit_spherical-new"></a>



<h4>Method <code>new()</code></h4>

<p>Initialize a <code><a href="#topic+ZIPLNfit_spherical">ZIPLNfit_spherical</a></code> model
</p>


<h5>Usage</h5>

<div class="r"><pre>ZIPLNfit_spherical$new(data, control)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>data</code></dt><dd><p>a named list used internally to carry the data matrices</p>
</dd>
<dt><code>control</code></dt><dd><p>a list for controlling the optimization. See details.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-ZIPLNfit_spherical-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>ZIPLNfit_spherical$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# See other examples in function ZIPLN
data(trichoptera)
trichoptera &lt;- prepare_data(trichoptera$Abundance, trichoptera$Covariate)
myPLN &lt;- ZIPLN(Abundance ~ 1, data = trichoptera, control = ZIPLN_param(covariance = "spherical"))
class(myPLN)
print(myPLN)

## End(Not run)
</code></pre>

<hr>
<h2 id='ZIPLNnetwork'>Zero Inflated Sparse Poisson lognormal model for network inference</h2><span id='topic+ZIPLNnetwork'></span>

<h3>Description</h3>

<p>Perform sparse inverse covariance estimation for the Zero Inflated Poisson lognormal model
using a variational algorithm. Iterate over a range of logarithmically spaced sparsity parameter values.
Use the (g)lm syntax to specify the model (including covariates and offsets).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ZIPLNnetwork(
  formula,
  data,
  subset,
  weights,
  zi = c("single", "row", "col"),
  penalties = NULL,
  control = ZIPLNnetwork_param()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ZIPLNnetwork_+3A_formula">formula</code></td>
<td>
<p>an object of class &quot;formula&quot;: a symbolic description of the model to be fitted.</p>
</td></tr>
<tr><td><code id="ZIPLNnetwork_+3A_data">data</code></td>
<td>
<p>an optional data frame, list or environment (or object coercible by as.data.frame to a data frame) containing the variables in the model. If not found in data, the variables are taken from environment(formula), typically the environment from which lm is called.</p>
</td></tr>
<tr><td><code id="ZIPLNnetwork_+3A_subset">subset</code></td>
<td>
<p>an optional vector specifying a subset of observations to be used in the fitting process.</p>
</td></tr>
<tr><td><code id="ZIPLNnetwork_+3A_weights">weights</code></td>
<td>
<p>an optional vector of observation weights to be used in the fitting process.</p>
</td></tr>
<tr><td><code id="ZIPLNnetwork_+3A_zi">zi</code></td>
<td>
<p>a character describing the model used for zero inflation, either of
</p>

<ul>
<li><p> &quot;single&quot; (default, one parameter shared by all counts)
</p>
</li>
<li><p> &quot;col&quot; (one parameter per variable / feature)
</p>
</li>
<li><p> &quot;row&quot; (one parameter per sample / individual).
If covariates are specified in the formula RHS (see details) this parameter is ignored.
</p>
</li></ul>
</td></tr>
<tr><td><code id="ZIPLNnetwork_+3A_penalties">penalties</code></td>
<td>
<p>an optional vector of positive real number controlling the level of sparsity of the underlying network. if NULL (the default), will be set internally. See <code>PLNnetwork_param()</code> for additional tuning of the penalty.</p>
</td></tr>
<tr><td><code id="ZIPLNnetwork_+3A_control">control</code></td>
<td>
<p>a list-like structure for controlling the optimization, with default generated by <code><a href="#topic+ZIPLNnetwork_param">ZIPLNnetwork_param()</a></code>. See the associated documentation
for details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Covariates for the Zero-Inflation parameter (using a logistic regression model) can be specified in the formula RHS using the pipe
(<code style="white-space: pre;">&#8288;~ PLN effect | ZI effect&#8288;</code>) to separate covariates for the PLN part of the model from those for the Zero-Inflation part.
Note that different covariates can be used for each part.
</p>


<h3>Value</h3>

<p>an R6 object with class <code><a href="#topic+ZIPLNnetworkfamily">ZIPLNnetworkfamily</a></code>
</p>


<h3>See Also</h3>

<p>The classes <code><a href="#topic+ZIPLNfit">ZIPLNfit</a></code> and <code><a href="#topic+ZIPLNnetworkfamily">ZIPLNnetworkfamily</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(trichoptera)
trichoptera &lt;- prepare_data(trichoptera$Abundance, trichoptera$Covariate)
myZIPLNs &lt;- ZIPLNnetwork(Abundance ~ 1, data = trichoptera, zi = "single")
</code></pre>

<hr>
<h2 id='ZIPLNnetwork_param'>Control of ZIPLNnetwork fit</h2><span id='topic+ZIPLNnetwork_param'></span>

<h3>Description</h3>

<p>Helper to define list of parameters to control the ZIPLNnetwork fit. All arguments have defaults.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ZIPLNnetwork_param(
  backend = c("nlopt"),
  inception_cov = c("full", "spherical", "diagonal"),
  trace = 1,
  n_penalties = 30,
  min_ratio = 0.1,
  penalize_diagonal = TRUE,
  penalty_weights = NULL,
  config_post = list(),
  config_optim = list(),
  inception = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ZIPLNnetwork_param_+3A_backend">backend</code></td>
<td>
<p>optimization back used, either &quot;nlopt&quot; or &quot;torch&quot;. Default is &quot;nlopt&quot;</p>
</td></tr>
<tr><td><code id="ZIPLNnetwork_param_+3A_inception_cov">inception_cov</code></td>
<td>
<p>Covariance structure used for the inception model used to initialize the PLNfamily. Defaults to &quot;full&quot; and can be constrained to &quot;diagonal&quot; and &quot;spherical&quot;.</p>
</td></tr>
<tr><td><code id="ZIPLNnetwork_param_+3A_trace">trace</code></td>
<td>
<p>a integer for verbosity.</p>
</td></tr>
<tr><td><code id="ZIPLNnetwork_param_+3A_n_penalties">n_penalties</code></td>
<td>
<p>an integer that specifies the number of values for the penalty grid when internally generated. Ignored when penalties is non <code>NULL</code></p>
</td></tr>
<tr><td><code id="ZIPLNnetwork_param_+3A_min_ratio">min_ratio</code></td>
<td>
<p>the penalty grid ranges from the minimal value that produces a sparse to this value multiplied by <code>min_ratio</code>. Default is 0.1.</p>
</td></tr>
<tr><td><code id="ZIPLNnetwork_param_+3A_penalize_diagonal">penalize_diagonal</code></td>
<td>
<p>boolean: should the diagonal terms be penalized in the graphical-Lasso? Default is <code>TRUE</code></p>
</td></tr>
<tr><td><code id="ZIPLNnetwork_param_+3A_penalty_weights">penalty_weights</code></td>
<td>
<p>either a single or a list of p x p matrix of weights (default: all weights equal to 1) to adapt the amount of shrinkage to each pairs of node. Must be symmetric with positive values.</p>
</td></tr>
<tr><td><code id="ZIPLNnetwork_param_+3A_config_post">config_post</code></td>
<td>
<p>a list for controlling the post-treatment (optional bootstrap, jackknife, R2, etc).</p>
</td></tr>
<tr><td><code id="ZIPLNnetwork_param_+3A_config_optim">config_optim</code></td>
<td>
<p>a list for controlling the optimizer (either &quot;nlopt&quot; or &quot;torch&quot; backend). See details</p>
</td></tr>
<tr><td><code id="ZIPLNnetwork_param_+3A_inception">inception</code></td>
<td>
<p>Set up the parameters initialization: by default, the model is initialized with a multivariate linear model applied on
log-transformed data, and with the same formula as the one provided by the user. However, the user can provide a PLNfit (typically obtained from a previous fit),
which sometimes speeds up the inference.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <code><a href="#topic+PLNnetwork_param">PLNnetwork_param()</a></code> for a full description of the optimization parameters. Note that some defaults values are different than those used in <code><a href="#topic+PLNnetwork_param">PLNnetwork_param()</a></code>:
</p>

<ul>
<li><p> &quot;ftol_out&quot; (outer loop convergence tolerance the objective function) is set by default to 1e-6
</p>
</li>
<li><p> &quot;maxit_out&quot; (max number of iterations for the outer loop) is set by default to 100
</p>
</li></ul>



<h3>Value</h3>

<p>list of parameters configuring the fit.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+PLNnetwork_param">PLNnetwork_param()</a></code> and <code><a href="#topic+PLN_param">PLN_param()</a></code>
</p>

<hr>
<h2 id='ZIPLNnetworkfamily'>An R6 Class to represent a collection of ZIPLNnetwork</h2><span id='topic+ZIPLNnetworkfamily'></span>

<h3>Description</h3>

<p>The function <code><a href="#topic+ZIPLNnetwork">ZIPLNnetwork()</a></code> produces an instance of this class.
</p>
<p>This class comes with a set of methods, some of them being useful for the user:
See the documentation for <code><a href="#topic+getBestModel">getBestModel()</a></code>,
<code><a href="#topic+getModel">getModel()</a></code> and <a href="#topic+plot.ZIPLNnetworkfamily">plot()</a>
</p>


<h3>Super classes</h3>

<p><code><a href="#topic+PLNfamily">PLNmodels::PLNfamily</a></code> -&gt; <code><a href="#topic+Networkfamily">PLNmodels::Networkfamily</a></code> -&gt; <code>ZIPLNnetworkfamily</code>
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>covariates0</code></dt><dd><p>the matrix of covariates included in the ZI component</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-ZIPLNnetworkfamily-new"><code>ZIPLNnetworkfamily$new()</code></a>
</p>
</li>
<li> <p><a href="#method-ZIPLNnetworkfamily-stability_selection"><code>ZIPLNnetworkfamily$stability_selection()</code></a>
</p>
</li>
<li> <p><a href="#method-ZIPLNnetworkfamily-clone"><code>ZIPLNnetworkfamily$clone()</code></a>
</p>
</li></ul>



<details><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="PLNmodels" data-topic="PLNfamily" data-id="getModel"><a href='../../PLNmodels/html/PLNfamily.html#method-PLNfamily-getModel'><code>PLNmodels::PLNfamily$getModel()</code></a></span></li>
<li><span class="pkg-link" data-pkg="PLNmodels" data-topic="PLNfamily" data-id="postTreatment"><a href='../../PLNmodels/html/PLNfamily.html#method-PLNfamily-postTreatment'><code>PLNmodels::PLNfamily$postTreatment()</code></a></span></li>
<li><span class="pkg-link" data-pkg="PLNmodels" data-topic="PLNfamily" data-id="print"><a href='../../PLNmodels/html/PLNfamily.html#method-PLNfamily-print'><code>PLNmodels::PLNfamily$print()</code></a></span></li>
<li><span class="pkg-link" data-pkg="PLNmodels" data-topic="Networkfamily" data-id="coefficient_path"><a href='../../PLNmodels/html/Networkfamily.html#method-Networkfamily-coefficient_path'><code>PLNmodels::Networkfamily$coefficient_path()</code></a></span></li>
<li><span class="pkg-link" data-pkg="PLNmodels" data-topic="Networkfamily" data-id="getBestModel"><a href='../../PLNmodels/html/Networkfamily.html#method-Networkfamily-getBestModel'><code>PLNmodels::Networkfamily$getBestModel()</code></a></span></li>
<li><span class="pkg-link" data-pkg="PLNmodels" data-topic="Networkfamily" data-id="optimize"><a href='../../PLNmodels/html/Networkfamily.html#method-Networkfamily-optimize'><code>PLNmodels::Networkfamily$optimize()</code></a></span></li>
<li><span class="pkg-link" data-pkg="PLNmodels" data-topic="Networkfamily" data-id="plot"><a href='../../PLNmodels/html/Networkfamily.html#method-Networkfamily-plot'><code>PLNmodels::Networkfamily$plot()</code></a></span></li>
<li><span class="pkg-link" data-pkg="PLNmodels" data-topic="Networkfamily" data-id="plot_objective"><a href='../../PLNmodels/html/Networkfamily.html#method-Networkfamily-plot_objective'><code>PLNmodels::Networkfamily$plot_objective()</code></a></span></li>
<li><span class="pkg-link" data-pkg="PLNmodels" data-topic="Networkfamily" data-id="plot_stars"><a href='../../PLNmodels/html/Networkfamily.html#method-Networkfamily-plot_stars'><code>PLNmodels::Networkfamily$plot_stars()</code></a></span></li>
<li><span class="pkg-link" data-pkg="PLNmodels" data-topic="Networkfamily" data-id="show"><a href='../../PLNmodels/html/Networkfamily.html#method-Networkfamily-show'><code>PLNmodels::Networkfamily$show()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-ZIPLNnetworkfamily-new"></a>



<h4>Method <code>new()</code></h4>

<p>Initialize all models in the collection
</p>


<h5>Usage</h5>

<div class="r"><pre>ZIPLNnetworkfamily$new(penalties, data, control)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>penalties</code></dt><dd><p>a vector of positive real number controlling the level of sparsity of the underlying network.</p>
</dd>
<dt><code>data</code></dt><dd><p>a named list used internally to carry the data matrices</p>
</dd>
<dt><code>control</code></dt><dd><p>a list for controlling the optimization.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>Update current <code><a href="#topic+PLNnetworkfit">PLNnetworkfit</a></code> with smart starting values
</p>


<hr>
<a id="method-ZIPLNnetworkfamily-stability_selection"></a>



<h4>Method <code>stability_selection()</code></h4>

<p>Compute the stability path by stability selection
</p>


<h5>Usage</h5>

<div class="r"><pre>ZIPLNnetworkfamily$stability_selection(
  subsamples = NULL,
  control = ZIPLNnetwork_param()
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>subsamples</code></dt><dd><p>a list of vectors describing the subsamples. The number of vectors (or list length) determines the number of subsamples used in the stability selection. Automatically set to 20 subsamples with size <code>10*sqrt(n)</code> if <code>n &gt;= 144</code> and <code>0.8*n</code> otherwise following Liu et al. (2010) recommendations.</p>
</dd>
<dt><code>control</code></dt><dd><p>a list controlling the main optimization process in each call to <code><a href="#topic+PLNnetwork">PLNnetwork()</a></code>. See <code><a href="#topic+ZIPLNnetwork">ZIPLNnetwork()</a></code> and <code><a href="#topic+ZIPLN_param">ZIPLN_param()</a></code> for details.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-ZIPLNnetworkfamily-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>ZIPLNnetworkfamily$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p>The function <code><a href="#topic+ZIPLNnetwork">ZIPLNnetwork()</a></code>, the class <code><a href="#topic+ZIPLNfit_sparse">ZIPLNfit_sparse</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(trichoptera)
trichoptera &lt;- prepare_data(trichoptera$Abundance, trichoptera$Covariate)
fits &lt;- PLNnetwork(Abundance ~ 1, data = trichoptera)
class(fits)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
