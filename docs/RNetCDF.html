<!DOCTYPE html><html lang="en"><head><title>Help for package RNetCDF</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {RNetCDF}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#RNetCDF'><p>R Interface to NetCDF Datasets</p></a></li>
<li><a href='#att.copy.nc'><p>Copy Attribute from One NetCDF to Another</p></a></li>
<li><a href='#att.delete.nc'><p>Delete a NetCDF Attribute</p></a></li>
<li><a href='#att.get.nc'><p>Get a NetCDF Attribute</p></a></li>
<li><a href='#att.inq.nc'><p>Inquire About a NetCDF Attribute</p></a></li>
<li><a href='#att.put.nc'><p>Put a NetCDF Attribute</p></a></li>
<li><a href='#att.rename.nc'><p>Rename a NetCDF Attribute</p></a></li>
<li><a href='#close.nc'><p>Close a NetCDF Dataset</p></a></li>
<li><a href='#config.nc'><p>Configured options</p></a></li>
<li><a href='#create.nc'><p>Create a NetCDF Dataset</p></a></li>
<li><a href='#dim.def.nc'><p>Define a NetCDF Dimension</p></a></li>
<li><a href='#dim.inq.nc'><p>Inquire About a NetCDF Dimension</p></a></li>
<li><a href='#dim.rename.nc'><p>Rename a NetCDF Dimension</p></a></li>
<li><a href='#file.inq.nc'><p>Inquire About a NetCDF Dataset</p></a></li>
<li><a href='#grp.def.nc'><p>Define a NetCDF Group</p></a></li>
<li><a href='#grp.inq.nc'><p>Inquire About a NetCDF Group</p></a></li>
<li><a href='#grp.rename.nc'><p>Rename a NetCDF Group</p></a></li>
<li><a href='#open.nc'><p>Open a NetCDF Dataset</p></a></li>
<li><a href='#print.nc'><p>Print Summary Information About a NetCDF Dataset</p></a></li>
<li><a href='#read.nc'><p>Read a NetCDF Dataset</p></a></li>
<li><a href='#sync.nc'><p>Synchronize a NetCDF Dataset</p></a></li>
<li><a href='#type.def.nc'><p>Define a NetCDF Type</p></a></li>
<li><a href='#type.inq.nc'><p>Inquire About a NetCDF Type</p></a></li>
<li><a href='#utcal.nc'><p>Convert Temporal Amounts to UTC Referenced Dates</p></a></li>
<li><a href='#utinit.nc'><p>Initialize the UDUNITS2 Library</p></a></li>
<li><a href='#utinvcal.nc'><p>Convert UTC Referenced Dates Into Temporal Amounts</p></a></li>
<li><a href='#var.def.nc'><p>Define a NetCDF Variable</p></a></li>
<li><a href='#var.get.nc'><p>Read Data from a NetCDF Variable</p></a></li>
<li><a href='#var.inq.nc'><p>Inquire About a NetCDF Variable</p></a></li>
<li><a href='#var.par.nc'><p>Change Parallel Access Mode</p></a></li>
<li><a href='#var.put.nc'><p>Write Data to a NetCDF Variable</p></a></li>
<li><a href='#var.rename.nc'><p>Rename a NetCDF Variable</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Version:</td>
<td>2.9-2</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-03-24</td>
</tr>
<tr>
<td>Title:</td>
<td>Interface to 'NetCDF' Datasets</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0.0)</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>netcdf (&gt;=4.1.3), udunits-2 (&gt;=2.0.4)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>bit64, tools</td>
</tr>
<tr>
<td>Enhances:</td>
<td>pbdMPI, Rmpi</td>
</tr>
<tr>
<td>Description:</td>
<td>An interface to the 'NetCDF' file formats designed by Unidata
  for efficient storage of array-oriented scientific data and descriptions.
  Most capabilities of 'NetCDF' version 4 are supported. Optional conversions
  of time units are enabled by 'UDUNITS' version 2, also from Unidata.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> | file LICENSE [expanded from: GPL (&ge; 2) | file LICENSE]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/mjwoods/RNetCDF">https://github.com/mjwoods/RNetCDF</a>
<a href="https://www.unidata.ucar.edu/software/netcdf/">https://www.unidata.ucar.edu/software/netcdf/</a>
<a href="https://www.unidata.ucar.edu/software/udunits/">https://www.unidata.ucar.edu/software/udunits/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/mjwoods/RNetCDF/issues">https://github.com/mjwoods/RNetCDF/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-03-24 03:45:20 UTC; mwoods</td>
</tr>
<tr>
<td>Author:</td>
<td>Pavel Michna [aut],
  Milton Woods [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Milton Woods &lt;miltonjwoods@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-03-25 00:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='RNetCDF'>R Interface to NetCDF Datasets</h2><span id='topic+RNetCDF'></span><span id='topic+RNetCDF-package'></span>

<h3>Description</h3>

<p>This package provides an interface to Unidata's NetCDF library functions (version 4) and furthermore access to Unidata's UDUNITS (version 2) calendar conversions. The routines and the documentation follow the NetCDF and UDUNITS C interface, so the corresponding manuals can be consulted for more detailed information.
</p>
<p>NetCDF is an abstraction that supports a view of data as a collection of self-describing, portable objects that can be accessed through a simple interface. Array values may be accessed directly, without knowing details of how the data are stored. Auxiliary information about the data, such as what units are used, may be stored with the data. Generic utilities and application programs can access NetCDF datasets and transform, combine, analyze, or display specified fields of the data.
</p>
<p>First versions of the R and C code of this package were based on the <code>netCDF</code> package by Thomas Lumley and the <code>ncdf</code> package by David Pierce. Milton Woods added some enhancements of the NetCDF library versions 3.6 and 4.x.
</p>


<h3>Functions</h3>

<p>Help pages are available for the following RNetCDF functions:
</p>

<table>
<tr>
 <td style="text-align: left;">
    <b>Category</b> </td><td style="text-align: left;"> <b>Function</b> </td>
</tr>
<tr>
 <td style="text-align: left;">
    Dataset   </td><td style="text-align: left;"> <code><a href="#topic+close.nc">close.nc</a></code> </td>
</tr>
<tr>
 <td style="text-align: left;">
              </td><td style="text-align: left;"> <code><a href="#topic+create.nc">create.nc</a></code> </td>
</tr>
<tr>
 <td style="text-align: left;">
              </td><td style="text-align: left;"> <code><a href="#topic+file.inq.nc">file.inq.nc</a></code> </td>
</tr>
<tr>
 <td style="text-align: left;">
              </td><td style="text-align: left;"> <code><a href="#topic+open.nc">open.nc</a></code> </td>
</tr>
<tr>
 <td style="text-align: left;">
              </td><td style="text-align: left;"> <code><a href="#topic+print.nc">print.nc</a></code> </td>
</tr>
<tr>
 <td style="text-align: left;">
              </td><td style="text-align: left;"> <code><a href="#topic+read.nc">read.nc</a></code> </td>
</tr>
<tr>
 <td style="text-align: left;">
              </td><td style="text-align: left;"> <code><a href="#topic+sync.nc">sync.nc</a></code> </td>
</tr>
<tr>
 <td style="text-align: left;">
    Group     </td><td style="text-align: left;"> <code><a href="#topic+grp.def.nc">grp.def.nc</a></code> </td>
</tr>
<tr>
 <td style="text-align: left;">
              </td><td style="text-align: left;"> <code><a href="#topic+grp.inq.nc">grp.inq.nc</a></code> </td>
</tr>
<tr>
 <td style="text-align: left;">
              </td><td style="text-align: left;"> <code><a href="#topic+grp.rename.nc">grp.rename.nc</a></code> </td>
</tr>
<tr>
 <td style="text-align: left;">
    Attribute </td><td style="text-align: left;"> <code><a href="#topic+att.copy.nc">att.copy.nc</a></code> </td>
</tr>
<tr>
 <td style="text-align: left;">
              </td><td style="text-align: left;"> <code><a href="#topic+att.delete.nc">att.delete.nc</a></code> </td>
</tr>
<tr>
 <td style="text-align: left;">
              </td><td style="text-align: left;"> <code><a href="#topic+att.get.nc">att.get.nc</a></code> </td>
</tr>
<tr>
 <td style="text-align: left;">
              </td><td style="text-align: left;"> <code><a href="#topic+att.inq.nc">att.inq.nc</a></code> </td>
</tr>
<tr>
 <td style="text-align: left;">
              </td><td style="text-align: left;"> <code><a href="#topic+att.put.nc">att.put.nc</a></code> </td>
</tr>
<tr>
 <td style="text-align: left;">
              </td><td style="text-align: left;"> <code><a href="#topic+att.rename.nc">att.rename.nc</a></code> </td>
</tr>
<tr>
 <td style="text-align: left;">
    Dimension </td><td style="text-align: left;"> <code><a href="#topic+dim.def.nc">dim.def.nc</a></code> </td>
</tr>
<tr>
 <td style="text-align: left;">
              </td><td style="text-align: left;"> <code><a href="#topic+dim.inq.nc">dim.inq.nc</a></code> </td>
</tr>
<tr>
 <td style="text-align: left;">
              </td><td style="text-align: left;"> <code><a href="#topic+dim.rename.nc">dim.rename.nc</a></code> </td>
</tr>
<tr>
 <td style="text-align: left;">
    Data type </td><td style="text-align: left;"> <code><a href="#topic+type.def.nc">type.def.nc</a></code> </td>
</tr>
<tr>
 <td style="text-align: left;">
              </td><td style="text-align: left;"> <code><a href="#topic+type.inq.nc">type.inq.nc</a></code> </td>
</tr>
<tr>
 <td style="text-align: left;">
    Variable  </td><td style="text-align: left;"> <code><a href="#topic+var.def.nc">var.def.nc</a></code> </td>
</tr>
<tr>
 <td style="text-align: left;">
              </td><td style="text-align: left;"> <code><a href="#topic+var.get.nc">var.get.nc</a></code> </td>
</tr>
<tr>
 <td style="text-align: left;">
              </td><td style="text-align: left;"> <code><a href="#topic+var.inq.nc">var.inq.nc</a></code> </td>
</tr>
<tr>
 <td style="text-align: left;">
              </td><td style="text-align: left;"> <code><a href="#topic+var.par.nc">var.par.nc</a></code> </td>
</tr>
<tr>
 <td style="text-align: left;">
              </td><td style="text-align: left;"> <code><a href="#topic+var.put.nc">var.put.nc</a></code> </td>
</tr>
<tr>
 <td style="text-align: left;">
              </td><td style="text-align: left;"> <code><a href="#topic+var.rename.nc">var.rename.nc</a></code> </td>
</tr>
<tr>
 <td style="text-align: left;">
    Calendar  </td><td style="text-align: left;"> <code><a href="#topic+utcal.nc">utcal.nc</a></code> </td>
</tr>
<tr>
 <td style="text-align: left;">
              </td><td style="text-align: left;"> <code><a href="#topic+utinit.nc">utinit.nc</a></code> </td>
</tr>
<tr>
 <td style="text-align: left;">
              </td><td style="text-align: left;"> <code><a href="#topic+utinvcal.nc">utinvcal.nc</a></code>
  </td>
</tr>

</table>



<h3>Data Types</h3>

<p>The external types supported by all NetCDF datasets are:
</p>

<table>
<tr>
 <td style="text-align: left;">
    <code>NC_CHAR</code>      </td><td style="text-align: left;"> 8-bit characters intended for representing text. </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>NC_BYTE</code>      </td><td style="text-align: left;"> 8-bit signed integers. </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>NC_SHORT</code>     </td><td style="text-align: left;"> 16-bit signed integers. </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>NC_INT</code>       </td><td style="text-align: left;"> 32-bit signed integers. </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>NC_FLOAT</code>     </td><td style="text-align: left;"> 32-bit IEEE floating-point. </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>NC_DOUBLE</code>    </td><td style="text-align: left;"> 64-bit IEEE floating-point. </td>
</tr>
<tr>
 <td style="text-align: left;">
  </td>
</tr>

</table>

<p>Datasets in NetCDF4 format support additional external types, including:
</p>

<table>
<tr>
 <td style="text-align: left;">
    <code>NC_UBYTE</code>      </td><td style="text-align: left;"> 8-bit unsigned integers. </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>NC_USHORT</code>     </td><td style="text-align: left;"> 16-bit unsigned integers. </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>NC_UINT</code>       </td><td style="text-align: left;"> 32-bit unsigned integers. </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>NC_INT64</code>      </td><td style="text-align: left;"> 64-bit signed integers. </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>NC_UINT64</code>     </td><td style="text-align: left;"> 64-bit unsigned integers. </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>NC_STRING</code>     </td><td style="text-align: left;"> variable length character strings. </td>
</tr>
<tr>
 <td style="text-align: left;">
  </td>
</tr>

</table>

<p>These types are called &ldquo;external&rdquo;, because they correspond to the portable external representation for NetCDF data. When a program reads external NetCDF data into an internal variable, the data is converted, if necessary, into the specified internal type. Similarly, if you write internal data into a NetCDF variable, this may cause it to be converted to a different external type, if the external type for the NetCDF variable differs from the internal type.
</p>
<p>In addition to the external types, NetCDF4 supports user-defined types. See <code><a href="#topic+type.def.nc">type.def.nc</a></code> for more explanation.
</p>


<h3>Note</h3>

<p>When installing RNetCDF from source code, the netcdf4 library and header files must be installed on the system. Calendar functions will only be enabled in RNetCDF if the udunits2 library and header files are detected during the build process. Parallel file access requires a netcdf4 library built with MPI support along with an MPI interface package installed in R (e.g. pbdMPI or Rmpi).</p>


<h3>Author(s)</h3>

<p>Pavel Michna, Milton Woods</p>


<h3>References</h3>

<p><a href="https://www.unidata.ucar.edu/software/netcdf/">https://www.unidata.ucar.edu/software/netcdf/</a>
</p>
<p><a href="https://www.unidata.ucar.edu/software/udunits/">https://www.unidata.ucar.edu/software/udunits/</a>
</p>

<hr>
<h2 id='att.copy.nc'>Copy Attribute from One NetCDF to Another</h2><span id='topic+att.copy.nc'></span>

<h3>Description</h3>

<p>Copy attribute from one NetCDF to another.</p>


<h3>Usage</h3>

<pre><code class='language-R'>att.copy.nc(ncfile.in, variable.in, attribute, ncfile.out, variable.out)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="att.copy.nc_+3A_ncfile.in">ncfile.in</code></td>
<td>
<p>Object of class <code>NetCDF</code> which points to the input NetCDF dataset from which the attribute will be copied (as returned from <code><a href="#topic+open.nc">open.nc</a></code>).</p>
</td></tr>
<tr><td><code id="att.copy.nc_+3A_variable.in">variable.in</code></td>
<td>
<p>ID or name of the variable in the input NetCDF dataset from which the attribute will be copied, or <code>"NC_GLOBAL"</code> for a global attribute.</p>
</td></tr>
<tr><td><code id="att.copy.nc_+3A_attribute">attribute</code></td>
<td>
<p>Name or ID of the attribute in the input NetCDF dataset to be copied.</p>
</td></tr>
<tr><td><code id="att.copy.nc_+3A_ncfile.out">ncfile.out</code></td>
<td>
<p>Object of class <code>NetCDF</code> which points to the output NetCDF dataset to which the attribute will be copied (as returned from <code><a href="#topic+open.nc">open.nc</a></code>). It is permissible for the input and output NetCDF object to be the same.</p>
</td></tr>
<tr><td><code id="att.copy.nc_+3A_variable.out">variable.out</code></td>
<td>
<p>ID or name of the variable in the output NetCDF dataset to which the attribute will be copied, or <code>"NC_GLOBAL"</code> to copy to a global attribute.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function copies an attribute from one open NetCDF dataset to another. It can also be used to copy an attribute from one variable to another within the same NetCDF dataset.
</p>
<p>Valid attribute ID numbers range from 0 to the number of attributes minus 1. The number of attributes of a file, group, or variable can be found using the relevant inquiry function (<code><a href="#topic+file.inq.nc">file.inq.nc</a></code>, <code><a href="#topic+grp.inq.nc">grp.inq.nc</a></code>, or <code><a href="#topic+var.inq.nc">var.inq.nc</a></code>).
</p>


<h3>Author(s)</h3>

<p>Pavel Michna, Milton Woods</p>


<h3>References</h3>

<p><a href="https://www.unidata.ucar.edu/software/netcdf/">https://www.unidata.ucar.edu/software/netcdf/</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>##  Create two new NetCDF datasets and define two dimensions
file1 &lt;- tempfile("att.copy_", fileext=".nc")
file2 &lt;- tempfile("att.copy_", fileext=".nc")
nc.1 &lt;- create.nc(file1)
nc.2 &lt;- create.nc(file2)

dim.def.nc(nc.1, "station", 5)
dim.def.nc(nc.1, "time", unlim=TRUE)

dim.def.nc(nc.2, "station", 5)
dim.def.nc(nc.2, "time", unlim=TRUE)

##  Create two variables, one as coordinate variable
var.def.nc(nc.1, "time", "NC_INT", "time")
var.def.nc(nc.1, "temperature", "NC_DOUBLE", c(0,1))

var.def.nc(nc.2, "time", "NC_INT", "time")
var.def.nc(nc.2, "temperature", "NC_DOUBLE", c(0,1))

##  Put some attributes to the first dataset
att.put.nc(nc.1, "temperature", "_FillValue", "NC_DOUBLE", -99999.9)
att.put.nc(nc.1, "NC_GLOBAL", "title", "NC_CHAR", "Data from Foo")

##  Copy the attributes to the second dataset
att.copy.nc(nc.1, 1, 0, nc.2, 1)
att.copy.nc(nc.1, "NC_GLOBAL", "title", nc.2, "NC_GLOBAL")

close.nc(nc.1)
close.nc(nc.2)
unlink(file1)
unlink(file2)
</code></pre>

<hr>
<h2 id='att.delete.nc'>Delete a NetCDF Attribute</h2><span id='topic+att.delete.nc'></span>

<h3>Description</h3>

<p>Delete a NetCDF attribute.</p>


<h3>Usage</h3>

<pre><code class='language-R'>att.delete.nc(ncfile, variable, attribute)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="att.delete.nc_+3A_ncfile">ncfile</code></td>
<td>
<p>Object of class <code>NetCDF</code> which points to the NetCDF dataset (as returned from <code><a href="#topic+open.nc">open.nc</a></code>).</p>
</td></tr>
<tr><td><code id="att.delete.nc_+3A_variable">variable</code></td>
<td>
<p>ID or name of the attribute's variable, or <code>"NC_GLOBAL"</code> for a global attribute.</p>
</td></tr>
<tr><td><code id="att.delete.nc_+3A_attribute">attribute</code></td>
<td>
<p>The name or ID of the attribute to be deleted.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function deletes a NetCDF attribute from a NetCDF dataset open for writing.
</p>
<p>Valid attribute ID numbers range from 0 to the number of attributes minus 1. The number of attributes of a file, group, or variable can be found using the relevant inquiry function (<code><a href="#topic+file.inq.nc">file.inq.nc</a></code>, <code><a href="#topic+grp.inq.nc">grp.inq.nc</a></code>, or <code><a href="#topic+var.inq.nc">var.inq.nc</a></code>).
</p>


<h3>Author(s)</h3>

<p>Pavel Michna, Milton Woods</p>


<h3>References</h3>

<p><a href="https://www.unidata.ucar.edu/software/netcdf/">https://www.unidata.ucar.edu/software/netcdf/</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>##  Create a new NetCDF dataset and define two dimensions
file1 &lt;- tempfile("att.delete_", fileext=".nc")
nc &lt;- create.nc(file1)

dim.def.nc(nc, "station", 5)
dim.def.nc(nc, "time", unlim=TRUE)

##  Create two variables, one as coordinate variable
var.def.nc(nc, "time", "NC_INT", "time")
var.def.nc(nc, "temperature", "NC_DOUBLE", c(0,1))

##  Put some attributes
att.put.nc(nc, "temperature", "_FillValue", "NC_DOUBLE", -99999.9)
att.put.nc(nc, "NC_GLOBAL", "title", "NC_CHAR", "Data from Foo")

##  Delete these attributes
att.delete.nc(nc, "temperature", "_FillValue")
att.delete.nc(nc, "NC_GLOBAL", "title")

close.nc(nc)
unlink(file1)
</code></pre>

<hr>
<h2 id='att.get.nc'>Get a NetCDF Attribute</h2><span id='topic+att.get.nc'></span>

<h3>Description</h3>

<p>Get an attribute from a NetCDF dataset.</p>


<h3>Usage</h3>

<pre><code class='language-R'>att.get.nc(ncfile, variable, attribute, rawchar=FALSE, fitnum=FALSE)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="att.get.nc_+3A_ncfile">ncfile</code></td>
<td>
<p>Object of class <code>NetCDF</code> which points to the NetCDF dataset (as returned from <code><a href="#topic+open.nc">open.nc</a></code>).</p>
</td></tr>
<tr><td><code id="att.get.nc_+3A_variable">variable</code></td>
<td>
<p>ID or name of the variable from which the attribute will be read, or <code>"NC_GLOBAL"</code> for a global attribute.</p>
</td></tr>
<tr><td><code id="att.get.nc_+3A_attribute">attribute</code></td>
<td>
<p>Attribute name or ID.</p>
</td></tr>
<tr><td><code id="att.get.nc_+3A_rawchar">rawchar</code></td>
<td>
<p>This option only relates to NetCDF attributes of type <code>NC_CHAR</code>. When <code>rawchar</code> is <code>FALSE</code> (default), a NetCDF attribute of type <code>NC_CHAR</code> is converted to a <code>character</code> string in R. If <code>rawchar</code> is <code>TRUE</code>, the bytes of <code>NC_CHAR</code> data are read into an R <code>raw</code> vector.</p>
</td></tr>
<tr><td><code id="att.get.nc_+3A_fitnum">fitnum</code></td>
<td>
<p>By default, all numeric variables are read into R as double precision values. When <code>fitnum==TRUE</code>, the smallest R numeric type that can exactly represent each external type is used, as follows:
</p>

<table>
<tr>
 <td style="text-align: left;">
    <code>NC_BYTE</code>       </td><td style="text-align: left;"> <code><a href="base.html#topic+integer">integer</a></code> </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>NC_UBYTE</code>      </td><td style="text-align: left;"> <code><a href="base.html#topic+integer">integer</a></code> </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>NC_SHORT</code>      </td><td style="text-align: left;"> <code><a href="base.html#topic+integer">integer</a></code> </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>NC_USHORT</code>     </td><td style="text-align: left;"> <code><a href="base.html#topic+integer">integer</a></code> </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>NC_INT</code>        </td><td style="text-align: left;"> <code><a href="base.html#topic+integer">integer</a></code> </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>NC_UINT</code>       </td><td style="text-align: left;"> <code><a href="base.html#topic+double">double</a></code> </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>NC_FLOAT</code>      </td><td style="text-align: left;"> <code><a href="base.html#topic+double">double</a></code> </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>NC_DOUBLE</code>     </td><td style="text-align: left;"> <code><a href="base.html#topic+double">double</a></code> </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>NC_INT64</code>      </td><td style="text-align: left;"> <code><a href="bit64.html#topic+bit64-package">integer64</a></code> </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>NC_UINT64</code>     </td><td style="text-align: left;"> <code><a href="bit64.html#topic+bit64-package">integer64</a></code> </td>
</tr>
<tr>
 <td style="text-align: left;">
  </td>
</tr>

</table>
</td></tr>
</table>


<h3>Details</h3>

<p>This function returns the value of the attribute.</p>


<h3>Value</h3>

<p>Vector with a data type that depends on the NetCDF variable. For NetCDF variables of type <code>NC_CHAR</code>, the R type is either <code>character</code> or <code>raw</code>, as specified by argument <code>rawchar</code>. For <code>NC_STRING</code>, the R type is <code>character</code>. Numeric variables are read as double precision by default, but the smallest R type that exactly represents each external type is used if <code>fitnum</code> is <code>TRUE</code>.
</p>
<p>Valid attribute ID numbers range from 0 to the number of attributes minus 1. The number of attributes of a file, group, or variable can be found using the relevant inquiry function (<code><a href="#topic+file.inq.nc">file.inq.nc</a></code>, <code><a href="#topic+grp.inq.nc">grp.inq.nc</a></code>, or <code><a href="#topic+var.inq.nc">var.inq.nc</a></code>).
</p>


<h3>Note</h3>

<p><code>NC_BYTE</code> is always interpreted as signed.</p>


<h3>Author(s)</h3>

<p>Pavel Michna, Milton Woods</p>


<h3>References</h3>

<p><a href="https://www.unidata.ucar.edu/software/netcdf/">https://www.unidata.ucar.edu/software/netcdf/</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>##  Create a new NetCDF dataset and define two dimensions
file1 &lt;- tempfile("att.get_", fileext=".nc")
nc &lt;- create.nc(file1)

dim.def.nc(nc, "station", 5)
dim.def.nc(nc, "time", unlim=TRUE)

##  Create two variables, one as coordinate variable
var.def.nc(nc, "time", "NC_INT", "time")
var.def.nc(nc, "temperature", "NC_DOUBLE", c(0,1))

##  Put some attributes
att.put.nc(nc, "temperature", "_FillValue", "NC_DOUBLE", -99999.9)
att.put.nc(nc, "temperature", "long_name", "NC_CHAR", "air temperature")
att.put.nc(nc, "NC_GLOBAL", "title", "NC_CHAR", "Data from Foo")
att.put.nc(nc, "NC_GLOBAL", "history", "NC_CHAR", paste("Created on", date()))

##  Get these attributes
att.get.nc(nc, "temperature", "_FillValue")
att.get.nc(nc, "temperature", "long_name")
att.get.nc(nc, "NC_GLOBAL", "title")
att.get.nc(nc, "NC_GLOBAL", "history")

close.nc(nc)
unlink(file1)
</code></pre>

<hr>
<h2 id='att.inq.nc'>Inquire About a NetCDF Attribute</h2><span id='topic+att.inq.nc'></span>

<h3>Description</h3>

<p>Inquire about a NetCDF attribute.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>att.inq.nc(ncfile, variable, attribute)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="att.inq.nc_+3A_ncfile">ncfile</code></td>
<td>
<p>Object of class <code>NetCDF</code> which points to the NetCDF dataset (as returned from <code><a href="#topic+open.nc">open.nc</a></code>).</p>
</td></tr>
<tr><td><code id="att.inq.nc_+3A_variable">variable</code></td>
<td>
<p>Either the ID or the name of the attribute's variable or <code>"NC_GLOBAL"</code> for a global attribute.</p>
</td></tr>
<tr><td><code id="att.inq.nc_+3A_attribute">attribute</code></td>
<td>
<p>Either the ID or the name of the attribute to be inquired.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function returns information about a NetCDF attribute. Information about an attribute include its ID, its name, its type, and its length. In general, attributes are accessed by name rather than by their ID number because the attribute number is more volatile than the name, since it can change when other attributes of the same variable are deleted.
</p>
<p>Valid attribute ID numbers range from 0 to the number of attributes minus 1. The number of attributes of a file, group, or variable can be found using the relevant inquiry function (<code><a href="#topic+file.inq.nc">file.inq.nc</a></code>, <code><a href="#topic+grp.inq.nc">grp.inq.nc</a></code>, or <code><a href="#topic+var.inq.nc">var.inq.nc</a></code>).
</p>


<h3>Value</h3>

<p>A list containing the following components:
</p>
<table role = "presentation">
<tr><td><code>id</code></td>
<td>
<p>Attribute ID.</p>
</td></tr>
<tr><td><code>name</code></td>
<td>
<p>Attribute name.</p>
</td></tr>
<tr><td><code>type</code></td>
<td>
<p>External NetCDF data type as one of the following labels: <code>NC_BYTE</code>, <code>NC_UBYTE</code>, <code>NC_CHAR</code>, <code>NC_SHORT</code>, <code>NC_USHORT</code>, <code>NC_INT</code>, <code>NC_UINT</code>, <code>NC_INT64</code>, <code>NC_UINT64</code>, <code>NC_FLOAT</code>, <code>NC_DOUBLE</code>, <code>NC_STRING</code>, or a user-defined type name.</p>
</td></tr>
<tr><td><code>length</code></td>
<td>
<p>Length of this attribute.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Pavel Michna, Milton Woods</p>


<h3>References</h3>

<p><a href="https://www.unidata.ucar.edu/software/netcdf/">https://www.unidata.ucar.edu/software/netcdf/</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>##  Create a new NetCDF dataset and define two dimensions
file1 &lt;- tempfile("att.inq_", fileext=".nc")
nc &lt;- create.nc(file1)

dim.def.nc(nc, "station", 5)
dim.def.nc(nc, "time", unlim=TRUE)

##  Create two variables, one as coordinate variable
var.def.nc(nc, "time", "NC_INT", "time")
var.def.nc(nc, "temperature", "NC_DOUBLE", c(0,1))

##  Put some attributes
att.put.nc(nc, "temperature", "_FillValue", "NC_DOUBLE", -99999.9)
att.put.nc(nc, "NC_GLOBAL", "title", "NC_CHAR", "Data from Foo")

##  Inquire about these attributes
att.inq.nc(nc, "temperature", "_FillValue")
att.inq.nc(nc, "NC_GLOBAL", "title")

close.nc(nc)
unlink(file1)
</code></pre>

<hr>
<h2 id='att.put.nc'>Put a NetCDF Attribute</h2><span id='topic+att.put.nc'></span>

<h3>Description</h3>

<p>Put an attribute to a NetCDF dataset.</p>


<h3>Usage</h3>

<pre><code class='language-R'>att.put.nc(ncfile, variable, name, type, value)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="att.put.nc_+3A_ncfile">ncfile</code></td>
<td>
<p>Object of class <code>NetCDF</code> which points to the NetCDF dataset (as returned from <code><a href="#topic+open.nc">open.nc</a></code>).</p>
</td></tr>
<tr><td><code id="att.put.nc_+3A_variable">variable</code></td>
<td>
<p>ID or name of the variable to which the attribute will be assigned or <code>"NC_GLOBAL"</code> for a global attribute.</p>
</td></tr>
<tr><td><code id="att.put.nc_+3A_name">name</code></td>
<td>
<p>Attribute name. Must begin with an alphabetic character, followed by zero or more alphanumeric characters including the underscore (<code>"_"</code>). Case is significant. Attribute name conventions are assumed by some NetCDF generic applications, e.g., <code>units</code> as the name for a string attribute that gives the units for a NetCDF variable.</p>
</td></tr>
<tr><td><code id="att.put.nc_+3A_type">type</code></td>
<td>
<p>External NetCDF data type as one of the following labels: <code>NC_BYTE</code>, <code>NC_UBYTE</code>, <code>NC_CHAR</code>, <code>NC_SHORT</code>, <code>NC_USHORT</code>, <code>NC_INT</code>, <code>NC_UINT</code>, <code>NC_INT64</code>, <code>NC_UINT64</code>, <code>NC_FLOAT</code>, <code>NC_DOUBLE</code>, <code>NC_STRING</code>, or a user-defined type name.</p>
</td></tr>
<tr><td><code id="att.put.nc_+3A_value">value</code></td>
<td>
<p>Attribute value. This can be either a single numeric value or a vector of numeric values, or alternatively a character string.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Names commencing with underscore (<code>"_"</code>) are reserved for use by the NetCDF library. Most generic applications that process NetCDF datasets assume standard attribute conventions and it is strongly recommended that these be followed unless there are good reasons for not doing so.
</p>
<p>Text represented by R type <code>character</code> can be written to NetCDF types <code>NC_CHAR</code> and <code>NC_STRING</code>, and R type <code>raw</code> can be written to NetCDF type <code>NC_CHAR</code>.
</p>
<p>R <code>numeric</code> and <code>integer</code> variables can be written to NetCDF numeric types. The NetCDF library handles type conversions, but conversions of values outside the range of a type will result in an error. Due to the lack of native support for 64-bit integers in R, this function accepts <code><a href="bit64.html#topic+bit64-package">integer64</a></code> vectors.
</p>


<h3>Note</h3>

<p><code>NC_BYTE</code> is always interpreted as signed.</p>


<h3>Author(s)</h3>

<p>Pavel Michna, Milton Woods</p>


<h3>References</h3>

<p><a href="https://www.unidata.ucar.edu/software/netcdf/">https://www.unidata.ucar.edu/software/netcdf/</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>##  Create a new NetCDF dataset and define two dimensions
file1 &lt;- tempfile("att.put_", fileext=".nc")
nc &lt;- create.nc(file1)

dim.def.nc(nc, "station", 5)
dim.def.nc(nc, "time", unlim=TRUE)

##  Create two variables, one as coordinate variable
var.def.nc(nc, "time", "NC_INT", "time")
var.def.nc(nc, "temperature", "NC_DOUBLE", c(0,1))

##  Put some attributes
att.put.nc(nc, "temperature", "_FillValue", "NC_DOUBLE", -99999.9)
att.put.nc(nc, "temperature", "long_name", "NC_CHAR", "air temperature")
att.put.nc(nc, "NC_GLOBAL", "title", "NC_CHAR", "Data from Foo")
att.put.nc(nc, "NC_GLOBAL", "history", "NC_CHAR", paste("Created on", date()))

close.nc(nc)
unlink(file1)
</code></pre>

<hr>
<h2 id='att.rename.nc'>Rename a NetCDF Attribute</h2><span id='topic+att.rename.nc'></span>

<h3>Description</h3>

<p>Rename a NetCDF attribute.</p>


<h3>Usage</h3>

<pre><code class='language-R'>att.rename.nc(ncfile, variable, attribute, newname)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="att.rename.nc_+3A_ncfile">ncfile</code></td>
<td>
<p>Object of class <code>NetCDF</code> which points to the NetCDF dataset (as returned from <code><a href="#topic+open.nc">open.nc</a></code>).</p>
</td></tr>
<tr><td><code id="att.rename.nc_+3A_variable">variable</code></td>
<td>
<p>ID or name of the attribute's variable, or <code>"NC_GLOBAL"</code> for a global attribute.</p>
</td></tr>
<tr><td><code id="att.rename.nc_+3A_attribute">attribute</code></td>
<td>
<p>The current attribute name or ID.</p>
</td></tr>
<tr><td><code id="att.rename.nc_+3A_newname">newname</code></td>
<td>
<p>The new name to be assigned to the specified attribute.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function changes the name of an existing attribute in a NetCDF dataset open for writing. An attribute cannot be renamed to have the same name as another attribute of the same variable.
</p>
<p>Valid attribute ID numbers range from 0 to the number of attributes minus 1. The number of attributes of a file, group, or variable can be found using the relevant inquiry function (<code><a href="#topic+file.inq.nc">file.inq.nc</a></code>, <code><a href="#topic+grp.inq.nc">grp.inq.nc</a></code>, or <code><a href="#topic+var.inq.nc">var.inq.nc</a></code>).</p>


<h3>Author(s)</h3>

<p>Pavel Michna, Milton Woods</p>


<h3>References</h3>

<p><a href="https://www.unidata.ucar.edu/software/netcdf/">https://www.unidata.ucar.edu/software/netcdf/</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>##  Create a new NetCDF dataset and define two dimensions
file1 &lt;- tempfile("att.rename_", fileext=".nc")
nc &lt;- create.nc(file1)

dim.def.nc(nc, "station", 5)
dim.def.nc(nc, "time", unlim=TRUE)

##  Create two variables, one as coordinate variable
var.def.nc(nc, "time", "NC_INT", "time")
var.def.nc(nc, "temperature", "NC_DOUBLE", c(0,1))

##  Put some attributes
att.put.nc(nc, "temperature", "_FillValue", "NC_DOUBLE", -99999.9)
att.put.nc(nc, "NC_GLOBAL", "title", "NC_CHAR", "Data from Foo")

##  Rename these attributes
att.rename.nc(nc, "temperature", "_FillValue", "my__FillValue")
att.rename.nc(nc, "NC_GLOBAL", "title", "my_title")

close.nc(nc)
unlink(file1)
</code></pre>

<hr>
<h2 id='close.nc'>Close a NetCDF Dataset</h2><span id='topic+close.nc'></span>

<h3>Description</h3>

<p>Close an open NetCDF dataset.</p>


<h3>Usage</h3>

<pre><code class='language-R'>close.nc(con, ...)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="close.nc_+3A_con">con</code></td>
<td>
<p>Object of class <code>NetCDF</code> which points to the NetCDF dataset (as returned from <code><a href="#topic+open.nc">open.nc</a></code>).</p>
</td></tr>
<tr><td><code id="close.nc_+3A_...">...</code></td>
<td>
<p>Arguments passed to or from other methods (not used).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function closes an open NetCDF dataset. After an open NetCDF dataset is closed, its NetCDF ID may be reassigned to the next NetCDF dataset that is opened or created. Therefore, the passed object (<code>ncfile</code>) should be deleted by the user after calling this function.</p>


<h3>Author(s)</h3>

<p>Pavel Michna, Milton Woods</p>


<h3>References</h3>

<p><a href="https://www.unidata.ucar.edu/software/netcdf/">https://www.unidata.ucar.edu/software/netcdf/</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>##  Create a void NetCDF dataset
file1 &lt;- tempfile("close_", fileext=".nc")
nc &lt;- create.nc(file1)
close.nc(nc)
unlink(file1)
</code></pre>

<hr>
<h2 id='config.nc'>Configured options</h2><span id='topic+config.nc'></span>

<h3>Description</h3>

<p>Find NetCDF options detected when installing RNetCDF.</p>


<h3>Usage</h3>

<pre><code class='language-R'>config.nc()</code></pre>


<h3>Details</h3>

<p>This function is not intended for user code, and it is subject to change or removal without notice. It is currently needed for RNetCDF package tests, to determine expected behaviour of the NetCDF C library.
</p>
<p>Unless otherwise documented, optional NetCDF features that are not detected when installing RNetCDF will raise an error when called from R code. If necessary, work arounds can be implemented by wrapping the relevant code in <code>try</code> or <code>tryCatch</code>.
</p>


<h3>Author(s)</h3>

<p>Pavel Michna, Milton Woods</p>

<hr>
<h2 id='create.nc'>Create a NetCDF Dataset</h2><span id='topic+create.nc'></span>

<h3>Description</h3>

<p>Create a new NetCDF dataset.</p>


<h3>Usage</h3>

<pre><code class='language-R'>create.nc(filename, clobber=TRUE, share=FALSE, prefill=TRUE,
         format="classic", large=FALSE, diskless=FALSE, persist=FALSE,
         mpi_comm=NULL, mpi_info=NULL)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="create.nc_+3A_filename">filename</code></td>
<td>
<p>Filename for the NetCDF dataset to be created.</p>
</td></tr>
<tr><td><code id="create.nc_+3A_clobber">clobber</code></td>
<td>
<p>The creation mode. If <code>TRUE</code> (default), any existing dataset with the same filename will be overwritten. Otherwise set to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="create.nc_+3A_share">share</code></td>
<td>
<p>The buffer scheme. If <code>FALSE</code> (default), dataset access is buffered and cached for performance. However, if one or more processes may be reading while another process is writing the dataset, set to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="create.nc_+3A_prefill">prefill</code></td>
<td>
<p>The prefill mode. If <code>TRUE</code> (default), newly defined variables are initialised with fill values when they are first accessed. This allows unwritten array elements to be detected when reading, but it also implies duplicate writes if all elements are subsequently written with user-specified data. Enhanced write performance can be obtained by setting <code>prefill=FALSE</code>.</p>
</td></tr>
<tr><td><code id="create.nc_+3A_format">format</code></td>
<td>
<p>The file format. One of <code>"classic"</code>, <code>"offset64"</code>, <code>"data64"</code>, <code>"netcdf4"</code> or <code>"classic4"</code>. See below for details.</p>
</td></tr>
<tr><td><code id="create.nc_+3A_large">large</code></td>
<td>
<p>(Deprecated) <code>large=TRUE</code> sets the file format to <code>"offset64"</code> when <code>format="classic"</code>.</p>
</td></tr>
<tr><td><code id="create.nc_+3A_diskless">diskless</code></td>
<td>
<p>When <code>diskless=TRUE</code>, the file is created in memory without writing to disk. This allows netcdf datasets to be used as fast, temporary files. When the file is closed, the contents are lost unless <code>persist=TRUE</code>.</p>
</td></tr>
<tr><td><code id="create.nc_+3A_persist">persist</code></td>
<td>
<p>When <code>persist=TRUE</code>, a file created with <code>diskless=TRUE</code> is flushed to disk when closed. In some cases, this may be faster than manipulating files directly on disk.</p>
</td></tr>
<tr><td><code id="create.nc_+3A_mpi_comm">mpi_comm</code></td>
<td>
<p>Fortran handle of MPI communicator for parallel I/O. The default of <code>NULL</code> implies serial I/O. Valid Fortran handles may be obtained from your chosen MPI package for R - for example <a href="pbdMPI.html#topic+comm.c2f">comm.c2f</a> or <a href="Rmpi.html#topic+mpi.comm.c2f">mpi.comm.c2f</a>.</p>
</td></tr>
<tr><td><code id="create.nc_+3A_mpi_info">mpi_info</code></td>
<td>
<p>Fortran handle of MPI Info object for parallel I/O. The default value <code>NULL</code> specifies that the <code>MPI_INFO_NULL</code> object is used. Other valid Fortran handles may be obtained from your chosen MPI package for R - for example <a href="pbdMPI.html#topic+info.c2f">info.c2f</a>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function creates a new NetCDF dataset, returning an object of class <code>NetCDF</code> that can be used in R.
</p>
<p>The file format is specified by the <code>format</code> argument, which may take the following values:
</p>

<dl>
<dt><code>"classic"</code></dt><dd><p>(default) Original netcdf file format, still widely used and recommended for maximum portability of datasets. Uses a signed 32-bit offset in its internal structures, so files larger than 2GB can only be created under limited conditions.</p>
</dd>
<dt><code>"offset64"</code></dt><dd><p>64-bit offset extension of original format, introduced by netcdf-3.6. Allows larger files and variables than <code>"classic"</code> format, but there remain some restrictions on files larger than 2GB.</p>
</dd>
<dt><code>"data64"</code></dt><dd><p>Extension of <code>"classic"</code> format to support large files (i.e. over 2GB) and large variables (over 2B array elements). This format was introduced in netcdf-4.4.0.</p>
</dd>
<dt><code>"netcdf4"</code></dt><dd><p>Netcdf in an HDF5 container, introduced by netcdf-4.0. Allows dataset sizes up to filesystem limits, and extends the feature set of the older formats.</p>
</dd>
<dt><code>"classic4"</code></dt><dd><p>Same file format as <code>"netcdf4"</code>, but this option ensures that only classic netcdf data structures are stored in the file for compatibility with older software (when linked with the netcdf4 library).</p>
</dd>
</dl>



<h3>Value</h3>

<p>Object of class <code>NetCDF</code> which points to the NetCDF dataset, returned invisibly.</p>


<h3>Author(s)</h3>

<p>Pavel Michna, Milton Woods</p>


<h3>References</h3>

<p><a href="https://www.unidata.ucar.edu/software/netcdf/">https://www.unidata.ucar.edu/software/netcdf/</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>##  Create empty NetCDF datasets with different formats
file1 &lt;- tempfile("create3_", fileext=".nc")
nc &lt;- create.nc(file1)
close.nc(nc)
unlink(file1)

file2 &lt;- tempfile("create64_", fileext=".nc")
nc2 &lt;- create.nc(file2,format="offset64")
close.nc(nc2)
unlink(file2)

file3 &lt;- tempfile("create4_", fileext=".nc")
nc3 &lt;- create.nc(file3,format="netcdf4")
close.nc(nc3)
unlink(file3)
</code></pre>

<hr>
<h2 id='dim.def.nc'>Define a NetCDF Dimension</h2><span id='topic+dim.def.nc'></span>

<h3>Description</h3>

<p>Define a new NetCDF dimension.</p>


<h3>Usage</h3>

<pre><code class='language-R'>dim.def.nc(ncfile, dimname, dimlength=1, unlim=FALSE)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dim.def.nc_+3A_ncfile">ncfile</code></td>
<td>
<p>Object of class <code>NetCDF</code> which points to the NetCDF dataset (as returned from <code><a href="#topic+open.nc">open.nc</a></code>).</p>
</td></tr>
<tr><td><code id="dim.def.nc_+3A_dimname">dimname</code></td>
<td>
<p>Dimension name. Must begin with an alphabetic character, followed by zero or more alphanumeric characters including the underscore (<code>"_"</code>). Case is significant.</p>
</td></tr>
<tr><td><code id="dim.def.nc_+3A_dimlength">dimlength</code></td>
<td>
<p>Length of dimension, that is, number of values for this dimension as an index to variables that use it. This must be a positive integer. If an unlimited dimension is created (<code>unlim=TRUE</code>), the value of <code>length</code> is not used.</p>
</td></tr>
<tr><td><code id="dim.def.nc_+3A_unlim">unlim</code></td>
<td>
<p>Set to <code>TRUE</code> if an unlimited dimension should be created, otherwise to <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function creates a new NetCDF dimension. There is a suggested limit (100) to the number of dimensions. Ordinarily, the name and length of a dimension are fixed when the dimension is first defined. The name may be changed later, but the length of a dimension (other than the unlimited dimension) cannot be changed without copying all the data to a new NetCDF dataset with a redefined dimension length. A NetCDF dimension in an open NetCDF dataset is referred to by a small integer called a dimension ID. In the C interface, dimension IDs are 0, 1, 2, ..., in the order in which the dimensions were defined. At most one unlimited length dimension may be defined for each NetCDF dataset.</p>


<h3>Value</h3>

<p>NetCDF variable identifier, returned invisibly.</p>


<h3>Author(s)</h3>

<p>Pavel Michna, Milton Woods</p>


<h3>References</h3>

<p><a href="https://www.unidata.ucar.edu/software/netcdf/">https://www.unidata.ucar.edu/software/netcdf/</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>##  Create a new NetCDF dataset and define two dimensions
file1 &lt;- tempfile("dim.def_", fileext=".nc")
nc &lt;- create.nc(file1)

dim.def.nc(nc, "station", 5)
dim.def.nc(nc, "time", unlim=TRUE)

close.nc(nc)
unlink(file1)
</code></pre>

<hr>
<h2 id='dim.inq.nc'>Inquire About a NetCDF Dimension</h2><span id='topic+dim.inq.nc'></span>

<h3>Description</h3>

<p>Inquire about a NetCDF dimension.</p>


<h3>Usage</h3>

<pre><code class='language-R'>dim.inq.nc(ncfile, dimension)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dim.inq.nc_+3A_ncfile">ncfile</code></td>
<td>
<p>Object of class <code>NetCDF</code> which points to the NetCDF dataset (as returned from <code><a href="#topic+open.nc">open.nc</a></code>).</p>
</td></tr>
<tr><td><code id="dim.inq.nc_+3A_dimension">dimension</code></td>
<td>
<p>Either the ID or the name of the dimension to be inquired.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function returns information about a NetCDF dimension. Information about a dimension include its name, its ID, its length and a flag if it is the unlimited dimension of this NetCDF dataset, if any. The length of the unlimited dimension, if any, is the number of records written so far.</p>


<h3>Value</h3>

<p>A list containing the following components:
</p>
<table role = "presentation">
<tr><td><code>id</code></td>
<td>
<p>Dimension ID.</p>
</td></tr>
<tr><td><code>name</code></td>
<td>
<p>Dimension name.</p>
</td></tr>
<tr><td><code>length</code></td>
<td>
<p>Length of dimension. For the unlimited dimension, this is the number of records written so far.</p>
</td></tr>
<tr><td><code>unlim</code></td>
<td>
<p><code>TRUE</code> if it is the unlimited dimension, <code>FALSE</code> otherwise.</p>
</td></tr> 
</table>


<h3>Author(s)</h3>

<p>Pavel Michna, Milton Woods</p>


<h3>References</h3>

<p><a href="https://www.unidata.ucar.edu/software/netcdf/">https://www.unidata.ucar.edu/software/netcdf/</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>##  Create a new NetCDF dataset and define two dimensions
file1 &lt;- tempfile("dim.inq_", fileext=".nc")
nc &lt;- create.nc(file1)

dim.def.nc(nc, "station", 5)
dim.def.nc(nc, "time", unlim=TRUE)

##  Inquire about the dimensions
dim.inq.nc(nc, 0)
dim.inq.nc(nc, "time")

close.nc(nc)
unlink(file1)
</code></pre>

<hr>
<h2 id='dim.rename.nc'>Rename a NetCDF Dimension</h2><span id='topic+dim.rename.nc'></span>

<h3>Description</h3>

<p>Rename a NetCDF dimension.</p>


<h3>Usage</h3>

<pre><code class='language-R'>dim.rename.nc(ncfile, dimension, newname)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dim.rename.nc_+3A_ncfile">ncfile</code></td>
<td>
<p>Object of class <code>NetCDF</code> which points to the NetCDF dataset (as returned from <code><a href="#topic+open.nc">open.nc</a></code>).</p>
</td></tr>
<tr><td><code id="dim.rename.nc_+3A_dimension">dimension</code></td>
<td>
<p>Either the ID or the name of the dimension to be renamed.</p>
</td></tr>
<tr><td><code id="dim.rename.nc_+3A_newname">newname</code></td>
<td>
<p>The new dimension name.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function renames an existing dimension in a NetCDF dataset open for writing. A dimension cannot be renamed to have the same name as another dimension.</p>


<h3>Author(s)</h3>

<p>Pavel Michna, Milton Woods</p>


<h3>References</h3>

<p><a href="https://www.unidata.ucar.edu/software/netcdf/">https://www.unidata.ucar.edu/software/netcdf/</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>##  Create a new NetCDF dataset and define two dimensions
file1 &lt;- tempfile("dim.rename_", fileext=".nc")
nc &lt;- create.nc(file1)

dim.def.nc(nc, "station", 5)
dim.def.nc(nc, "time", unlim=TRUE)

##  Rename the dimensions
dim.rename.nc(nc, 0, "mystation")
dim.rename.nc(nc, "time", "mytime")

close.nc(nc)
unlink(file1)
</code></pre>

<hr>
<h2 id='file.inq.nc'>Inquire About a NetCDF Dataset</h2><span id='topic+file.inq.nc'></span>

<h3>Description</h3>

<p>Inquire about a NetCDF dataset.</p>


<h3>Usage</h3>

<pre><code class='language-R'>file.inq.nc(ncfile)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="file.inq.nc_+3A_ncfile">ncfile</code></td>
<td>
<p>Object of class <code>NetCDF</code> which points to the NetCDF dataset (as returned from <code><a href="#topic+open.nc">open.nc</a></code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the following components:
</p>
<table role = "presentation">
<tr><td><code>ndims</code></td>
<td>
<p>Number of dimensions defined for this NetCDF dataset.</p>
</td></tr>
<tr><td><code>nvars</code></td>
<td>
<p>Number of variables defined for this NetCDF dataset.</p>
</td></tr>
<tr><td><code>ngatts</code></td>
<td>
<p>Number of global attributes for this NetCDF dataset.</p>
</td></tr>
<tr><td><code>unlimdimid</code></td>
<td>
<p>ID of the unlimited dimension, if there is one for this NetCDF dataset. Otherwise <code>NA</code> will be returned.</p>
</td></tr> 
<tr><td><code>format</code></td>
<td>
<p>Format of file, typically <code>"classic"</code>, <code>"offset64"</code>, <code>"data64"</code>, <code>"classic4"</code> or <code>"netcdf4"</code>.</p>
</td></tr>
<tr><td><code>libvers</code></td>
<td>
<p>Version string of the NetCDF library in the current R session.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Pavel Michna, Milton Woods</p>


<h3>References</h3>

<p><a href="https://www.unidata.ucar.edu/software/netcdf/">https://www.unidata.ucar.edu/software/netcdf/</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>##  Create a new NetCDF dataset and define two dimensions
file1 &lt;- tempfile("file.inq_", fileext=".nc")
nc &lt;- create.nc(file1)

dim.def.nc(nc, "station", 5)
dim.def.nc(nc, "time", unlim=TRUE)

##  Create two variables, one as coordinate variable
var.def.nc(nc, "time", "NC_INT", "time")
var.def.nc(nc, "temperature", "NC_DOUBLE", c(0,1))

##  Put some attributes
att.put.nc(nc, "temperature", "_FillValue", "NC_DOUBLE", -99999.9)
att.put.nc(nc, "temperature", "long_name", "NC_CHAR", "air temperature")
att.put.nc(nc, "NC_GLOBAL", "title", "NC_CHAR", "Data from Foo")
att.put.nc(nc, "NC_GLOBAL", "history", "NC_CHAR", paste("Created on", date()))

##  Inquire about the dataset
file.inq.nc(nc)

close.nc(nc)
unlink(file1)
</code></pre>

<hr>
<h2 id='grp.def.nc'>Define a NetCDF Group</h2><span id='topic+grp.def.nc'></span>

<h3>Description</h3>

<p>Define a NetCDF Group.</p>


<h3>Usage</h3>

<pre><code class='language-R'>grp.def.nc(ncid, grpname)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="grp.def.nc_+3A_ncid">ncid</code></td>
<td>
<p>Object of class <code>NetCDF</code> which points to the NetCDF dataset (as returned from <code><a href="#topic+open.nc">open.nc</a></code>) or parent group (as returned by this function).</p>
</td></tr>
<tr><td><code id="grp.def.nc_+3A_grpname">grpname</code></td>
<td>
<p>Group name. Must begin with an alphabetic character, followed by zero or more alphanumeric characters including the underscore (<code>"_"</code>). Case is significant.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function may only be used with datasets in <code>netcdf4</code> format. It creates a new NetCDF group, which may be used as a container for other NetCDF objects, including groups, dimensions, variables and attributes.
</p>
<p>Most NetCDF object types, including groups, variables and global attributes, are visible only in the group where they are defined. However, dimensions are visible in their groups and all child groups.</p>


<h3>Value</h3>

<p>Object of class <code>NetCDF</code> which points to the NetCDF group, returned invisibly.</p>


<h3>Author(s)</h3>

<p>Pavel Michna, Milton Woods</p>


<h3>References</h3>

<p><a href="https://www.unidata.ucar.edu/software/netcdf/">https://www.unidata.ucar.edu/software/netcdf/</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>##  Create a new NetCDF4 dataset
file1 &lt;- tempfile("grp.def_", fileext=".nc")
nc &lt;- create.nc(file1, format="netcdf4")

## Define dimensions, variables and attributes in the root group
dim.def.nc(nc, "station", 5)
var.def.nc(nc, "station", "NC_CHAR", c("station"))
att.put.nc(nc, "NC_GLOBAL", "Description", "NC_CHAR", "Site-based measurements") 

## Define a group
grp &lt;- grp.def.nc(nc, "time_series")

## Define dimensions and variables in the new group
dim.def.nc(grp, "time", unlim=TRUE)
var.def.nc(grp, "time", "NC_INT", "time")
var.def.nc(grp, "temperature", "NC_DOUBLE", c("station","time"))
att.put.nc(nc, "NC_GLOBAL", "Description", "NC_CHAR", "Time-series at sites")

close.nc(nc)
unlink(file1)
</code></pre>

<hr>
<h2 id='grp.inq.nc'>Inquire About a NetCDF Group</h2><span id='topic+grp.inq.nc'></span>

<h3>Description</h3>

<p>Inquire about a NetCDF group.</p>


<h3>Usage</h3>

<pre><code class='language-R'>grp.inq.nc(ncid,grpname=NULL,ancestors=TRUE)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="grp.inq.nc_+3A_ncid">ncid</code></td>
<td>
<p>Object of class <code>NetCDF</code> which points to a NetCDF group (from <code><a href="#topic+grp.def.nc">grp.def.nc</a></code>) or dataset (from <code><a href="#topic+open.nc">open.nc</a></code>).</p>
</td></tr>
<tr><td><code id="grp.inq.nc_+3A_grpname">grpname</code></td>
<td>
<p>By default, the inquiry relates to the group represented by <code>ncid</code>. If <code>grpname</code> is a character string, a group with this name is examined instead. A hierarchical search is performed if <code>grpname</code> contains <code>"/"</code>, otherwise only the immediate group of <code>ncid</code> is searched for a matching group name.</p>
</td></tr>
<tr><td><code id="grp.inq.nc_+3A_ancestors">ancestors</code></td>
<td>
<p>If <code>TRUE</code>, dimensions and names of ancestor groups are examined. Otherwise, only dimensions and names defined in the current group are reported.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function provides information about the structure of a NetCDF group or dataset. The results allow programs to explore a dataset without prior knowledge of the contents.</p>


<h3>Value</h3>

<p>A list containing the following components:
</p>
<table role = "presentation">
<tr><td><code>self</code></td>
<td>
<p>Object of class <code>NetCDF</code> representing the group.</p>
</td></tr>
<tr><td><code>parent</code></td>
<td>
<p>Object of class <code>NetCDF</code> representing the parent group, or <code>NULL</code> for the root group.</p>
</td></tr>
<tr><td><code>grps</code></td>
<td>
<p>List of objects of class <code>NetCDF</code> representing the groups in the group.</p>
</td></tr>
<tr><td><code>name</code></td>
<td>
<p>Name of the NetCDF group.</p>
</td></tr>
<tr><td><code>fullname</code></td>
<td>
<p>Full name of the NetCDF group, with ancestors listed in order from the root group of the dataset and separated by <code>"/"</code>. Omitted if <code>ancestors</code> is <code>FALSE</code>.</p>
</td></tr> 
<tr><td><code>dimids</code></td>
<td>
<p>Vector of dimension identifiers. If <code>ancestors</code> is <code>TRUE</code> (default), all visible dimensions in the group and its ancestors are reported, otherwise only dimensions defined in the group of <code>ncid</code> are shown.</p>
</td></tr>
<tr><td><code>unlimids</code></td>
<td>
<p>Vector of identifiers for unlimited dimensions. If <code>ancestors</code> is <code>TRUE</code> (default), all unlimited dimensions in the group and its ancestors are reported, otherwise only unlimited dimensions defined in the group of <code>ncid</code> are shown.</p>
</td></tr>
<tr><td><code>varids</code></td>
<td>
<p>Vector of identifiers for variables in the group.</p>
</td></tr>
<tr><td><code>typeids</code></td>
<td>
<p>Vector of identifiers for types in the group.</p>
</td></tr>
<tr><td><code>ngatts</code></td>
<td>
<p>Number of group attributes.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Pavel Michna, Milton Woods</p>


<h3>References</h3>

<p><a href="https://www.unidata.ucar.edu/software/netcdf/">https://www.unidata.ucar.edu/software/netcdf/</a></p>


<h3>Examples</h3>

<pre><code class='language-R'># Create a new NetCDF dataset:
file1 &lt;- tempfile("grp.inq_", fileext=".nc")
nc &lt;- create.nc(file1, format="netcdf4")

# Define groups in root group.
# (Any names can be used; hierarchical numbers are used here for clarity)
grp11 &lt;- grp.def.nc(nc, "group1.1")
grp12 &lt;- grp.def.nc(nc, "group1.2")

# Define group nested in group1.1:
grp111 &lt;- grp.def.nc(grp11, "group1.1.1")

# Put some attributes in each group.
# (We could also define dimensions, types, and variables).
att.put.nc(nc, "NC_GLOBAL", "title", "NC_CHAR", "Group 1 (root)")
att.put.nc(grp11, "NC_GLOBAL", "title", "NC_CHAR", "Group 1.1")
att.put.nc(grp12, "NC_GLOBAL", "title", "NC_CHAR", "Group 1.2")
att.put.nc(grp111, "NC_GLOBAL", "title", "NC_CHAR", "Group 1.1.1")

## Examine contents of a group directly using its hierarchical name ...

mygrp &lt;- grp.inq.nc(nc, "/group1.1/group1.1.1")
att.get.nc(mygrp$self, "NC_GLOBAL", "title")

## Recursively examine contents of nested groups ...
# (See also print.nc for a visual overview)

get_global_atts &lt;- function(ncid) {
  inq &lt;- grp.inq.nc(ncid)
  atts &lt;- character(inq$ngatts)
  for (ii in seq_len(inq$ngatts)) {
    atts[ii] &lt;- att.get.nc(ncid, "NC_GLOBAL", ii-1)
  }
  ngrps &lt;- length(inq$grps)
  grps &lt;- vector("list", ngrps + 1)
  grps[[1]] &lt;- atts
  for (ii in seq_len(ngrps)) {
    grps[[ii + 1]] &lt;- get_global_atts(inq$grps[[ii]])
  }
  return(grps)
}

get_global_atts(nc)

## Tidy up:
close.nc(nc)
unlink(file1)
</code></pre>

<hr>
<h2 id='grp.rename.nc'>Rename a NetCDF Group</h2><span id='topic+grp.rename.nc'></span>

<h3>Description</h3>

<p>Rename a NetCDF group.</p>


<h3>Usage</h3>

<pre><code class='language-R'>grp.rename.nc(ncid, newname, oldname=NULL)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="grp.rename.nc_+3A_ncid">ncid</code></td>
<td>
<p>Object of class <code>NetCDF</code> which points to a NetCDF group (from <code><a href="#topic+grp.def.nc">grp.def.nc</a></code>) or dataset (from <code><a href="#topic+open.nc">open.nc</a></code>).</p>
</td></tr>
<tr><td><code id="grp.rename.nc_+3A_newname">newname</code></td>
<td>
<p>The new group name.</p>
</td></tr>
<tr><td><code id="grp.rename.nc_+3A_oldname">oldname</code></td>
<td>
<p>By default, the rename applies to the group represented by <code>ncid</code>. If <code>oldname</code> is a character string, a group with this name is renamed instead. A hierarchical search is performed if <code>oldname</code> contains <code>"/"</code>, otherwise only the immediate group of <code>ncid</code> is searched for a matching group name.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function renames an existing group in a dataset of <code>"netcdf4"</code> format that is open for writing. A group cannot be renamed to have the same name as another group, type or variable in the parent group.</p>


<h3>Author(s)</h3>

<p>Pavel Michna, Milton Woods</p>


<h3>References</h3>

<p><a href="https://www.unidata.ucar.edu/software/netcdf/">https://www.unidata.ucar.edu/software/netcdf/</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>##  Create a new NetCDF dataset and define a group
file1 &lt;- tempfile("grp.rename_", fileext=".nc")
nc &lt;- create.nc(file1, format="netcdf4")

grp &lt;- grp.def.nc(nc, "oldgroup")

##  Rename the group (operation not supported by early versions of the netcdf4 library)
try(grp.rename.nc(grp, "newgroup"))

close.nc(nc)
unlink(file1)
</code></pre>

<hr>
<h2 id='open.nc'>Open a NetCDF Dataset</h2><span id='topic+open.nc'></span>

<h3>Description</h3>

<p>Open an existing NetCDF dataset for reading and (optionally) writing.</p>


<h3>Usage</h3>

<pre><code class='language-R'>   open.nc(con, write=FALSE, share=FALSE, prefill=TRUE, diskless=FALSE, persist=FALSE,
           mpi_comm=NULL, mpi_info=NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="open.nc_+3A_con">con</code></td>
<td>
<p>Filename of the NetCDF dataset to be opened. If the underlying NetCDF library supports OPeNDAP, <code>con</code> may be an OPeNDAP URL.</p>
</td></tr>
<tr><td><code id="open.nc_+3A_write">write</code></td>
<td>
<p>If <code>FALSE</code> (default), the dataset will be opened read-only. If <code>TRUE</code>, the dataset will be opened read-write.</p>
</td></tr>
<tr><td><code id="open.nc_+3A_share">share</code></td>
<td>
<p>The buffer scheme. If <code>FALSE</code> (default), dataset access is buffered and cached for performance. However, if one or more processes may be reading while another process is writing the dataset, set to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="open.nc_+3A_prefill">prefill</code></td>
<td>
<p>The prefill mode. If <code>TRUE</code> (default), newly defined variables are initialised with fill values when they are first accessed. This allows unwritten array elements to be detected when reading, but it also implies duplicate writes if all elements are subsequently written with user-specified data. Enhanced write performance can be obtained by setting <code>prefill=FALSE</code>.</p>
</td></tr>
<tr><td><code id="open.nc_+3A_diskless">diskless</code></td>
<td>
<p>When <code>diskless=TRUE</code>, the file is read entirely into memory, and any changes are kept in memory without writing to disk. The netcdf library may ignore this option for files in netcdf4 format.</p>
</td></tr>
<tr><td><code id="open.nc_+3A_persist">persist</code></td>
<td>
<p>When <code>persist=TRUE</code>, a file opened with <code>diskless=TRUE</code> is flushed to disk when closed. In some cases, this may be faster than manipulating files directly on disk.</p>
</td></tr>
<tr><td><code id="open.nc_+3A_mpi_comm">mpi_comm</code></td>
<td>
<p>Fortran handle of MPI communicator for parallel I/O. The default of <code>NULL</code> implies serial I/O. Valid Fortran handles may be obtained from your chosen MPI package for R - for example <a href="pbdMPI.html#topic+comm.c2f">comm.c2f</a> or <a href="Rmpi.html#topic+mpi.comm.c2f">mpi.comm.c2f</a>.</p>
</td></tr>
<tr><td><code id="open.nc_+3A_mpi_info">mpi_info</code></td>
<td>
<p>Fortran handle of MPI Info object for parallel I/O. The default value <code>NULL</code> specifies that the <code>MPI_INFO_NULL</code> object is used. Other valid Fortran handles may be obtained from your chosen MPI package for R - for example <a href="pbdMPI.html#topic+info.c2f">info.c2f</a>.</p>
</td></tr>
<tr><td><code id="open.nc_+3A_...">...</code></td>
<td>
<p>Arguments passed to or from other methods (not used).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function opens an existing NetCDF dataset for access. By default, the dataset is opened read-only. If <code>write=TRUE</code>, then the dataset can be changed. This includes appending or changing data, adding dimensions, variables, and attributes.</p>


<h3>Value</h3>

<p>Object of class <code>NetCDF</code> which points to the NetCDF dataset, returned invisibly.</p>


<h3>Author(s)</h3>

<p>Pavel Michna, Milton Woods</p>


<h3>References</h3>

<p><a href="https://www.unidata.ucar.edu/software/netcdf/">https://www.unidata.ucar.edu/software/netcdf/</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>##  Create a void NetCDF dataset
file1 &lt;- tempfile("open_", fileext=".nc")
nc &lt;- create.nc(file1)
close.nc(nc)

##  Open the NetCDF dataset for writing
nc &lt;- open.nc(file1, write=TRUE)
close.nc(nc)
unlink(file1)
</code></pre>

<hr>
<h2 id='print.nc'>Print Summary Information About a NetCDF Dataset</h2><span id='topic+print.nc'></span>

<h3>Description</h3>

<p>Print summary information about a NetCDF dataset.</p>


<h3>Usage</h3>

<pre><code class='language-R'>print.nc(x, ...)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.nc_+3A_x">x</code></td>
<td>
<p>Object of class <code>NetCDF</code> which points to the NetCDF dataset (as returned from <code><a href="#topic+open.nc">open.nc</a></code>).</p>
</td></tr>
<tr><td><code id="print.nc_+3A_...">...</code></td>
<td>
<p>Arguments passed to or from other methods (not used).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function prints information about the structure of a NetCDF dataset, including lists of all groups, dimensions, user-defined types, variables and attributes.
</p>
<p>The output of this function is similar to the <code>ncdump -h</code> command supplied with the NetCDF C library. One important difference is that array dimensions are shown by <code>print.nc</code> in the order used by R, where the leftmost subscript varies fastest.
</p>


<h3>Author(s)</h3>

<p>Pavel Michna, Milton Woods</p>


<h3>References</h3>

<p><a href="https://www.unidata.ucar.edu/software/netcdf/">https://www.unidata.ucar.edu/software/netcdf/</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>##  Create a new NetCDF dataset
file1 &lt;- tempfile("print_", fileext=".nc")
nc &lt;- create.nc(file1, format="netcdf4")

## Create a group (just because we can!):
grp &lt;- grp.def.nc(nc, "data")

## Create some dimensions, putting one inside the group:
dim.def.nc(nc, "time", unlim=TRUE)
dim.def.nc(grp, "station", 5)

##  Create two variables, putting one inside the group:
var.def.nc(nc, "time", "NC_INT", "time")
var.def.nc(grp, "temperature", "NC_DOUBLE", c("station","time"))

##  Put some attributes
att.put.nc(nc, "NC_GLOBAL", "history", "NC_CHAR", paste("Created on", date()))
att.put.nc(grp, "temperature", "_FillValue", "NC_DOUBLE", -99999.9)
att.put.nc(grp, "temperature", "long_name", "NC_CHAR", "air temperature")
att.put.nc(grp, "NC_GLOBAL", "title", "NC_CHAR", "Data from Foo")

##  Print summary information about the dataset
print.nc(nc)

close.nc(nc)
unlink(file1)
</code></pre>

<hr>
<h2 id='read.nc'>Read a NetCDF Dataset</h2><span id='topic+read.nc'></span>

<h3>Description</h3>

<p>Read all data from a NetCDF dataset.</p>


<h3>Usage</h3>

<pre><code class='language-R'>   read.nc(ncfile, recursive=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="read.nc_+3A_ncfile">ncfile</code></td>
<td>
<p>Object of class <code>NetCDF</code> which points to the NetCDF dataset (as returned from <code><a href="#topic+open.nc">open.nc</a></code>).</p>
</td></tr>
<tr><td><code id="read.nc_+3A_recursive">recursive</code></td>
<td>
<p>Descend recursively into any groups in the dataset if <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="read.nc_+3A_...">...</code></td>
<td>
<p>Optional arguments passed to <code>var.get.nc</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function reads all variable data from a NetCDF dataset into a list. The list elements (arrays) have the same names as the variables in the NetCDF dataset.
</p>
<p>Groups in the dataset may optionally be read recursively and returned as nested lists. Each list has the name of the corresponding group in the dataset.
</p>


<h3>Value</h3>

<p>A list with the list elements containing an array for each variable or a (possibly nested) list for each group in the NetCDF dataset.</p>


<h3>Author(s)</h3>

<p>Pavel Michna, Milton Woods</p>


<h3>References</h3>

<p><a href="https://www.unidata.ucar.edu/software/netcdf/">https://www.unidata.ucar.edu/software/netcdf/</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>##  Create a new NetCDF dataset
file1 &lt;- tempfile("read_", fileext=".nc")
nc &lt;- create.nc(file1, format="netcdf4")

dim.def.nc(nc, "station", 5)
dim.def.nc(nc, "time", unlim=TRUE)
dim.def.nc(nc, "max_string_length", 32)

##  Create two coordinate variables
var.def.nc(nc, "time", "NC_INT", "time")
var.def.nc(nc, "name", "NC_CHAR", c("max_string_length", "station"))

## Create a group to contain the data
# This is not necessary, but shows it can be done.
grp &lt;- grp.def.nc(nc, "data")

## Create a data variable
var.def.nc(grp, "temperature", "NC_DOUBLE", c("station","time"))

##  Put some _FillValue attribute for temperature
att.put.nc(grp, "temperature", "_FillValue", "NC_DOUBLE", -99999.9)

##  Define variable values
mytime        &lt;- c(1:2)
mytemperature &lt;- c(1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, NA, NA, 9.9)
myname        &lt;- c("alfa", "bravo", "charlie", "delta", "echo")

##  Put the data
var.put.nc(nc, "time", mytime, 1, length(mytime))
var.put.nc(nc, "name", myname, c(1,1), c(32,5))
var.put.nc(grp, "temperature", mytemperature, c(1,1), c(5,2))

sync.nc(nc)

##  Read the dataset, including the contents of any groups
read.nc(nc, recursive=TRUE)

close.nc(nc)
unlink(file1)
</code></pre>

<hr>
<h2 id='sync.nc'>Synchronize a NetCDF Dataset</h2><span id='topic+sync.nc'></span>

<h3>Description</h3>

<p>Synchronize an open NetCDF dataset to disk.</p>


<h3>Usage</h3>

<pre><code class='language-R'>sync.nc(ncfile)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sync.nc_+3A_ncfile">ncfile</code></td>
<td>
<p>Object of class <code>NetCDF</code> which points to the NetCDF dataset (as returned from <code><a href="#topic+open.nc">open.nc</a></code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function offers a way to synchronize the disk copy of a NetCDF dataset with in-memory buffers. There are two reasons one might want to synchronize after writes: To minimize data loss in case of abnormal termination, or to make data available to other processes for reading immediately after it is written.</p>


<h3>Author(s)</h3>

<p>Pavel Michna, Milton Woods</p>


<h3>References</h3>

<p><a href="https://www.unidata.ucar.edu/software/netcdf/">https://www.unidata.ucar.edu/software/netcdf/</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>##  Create a new NetCDF dataset and define two dimensions
file1 &lt;- tempfile("sync_", fileext=".nc")
nc &lt;- create.nc(file1)

dim.def.nc(nc, "station", 5)
dim.def.nc(nc, "time", unlim=TRUE)

##  Create two variables, one as coordinate variable
var.def.nc(nc, "time", "NC_INT", "time")
var.def.nc(nc, "temperature", "NC_DOUBLE", c(0,1))

##  Define variable values
mytime &lt;- c(1:2)
dim(mytime) &lt;- c(2)
mytemp &lt;- c(0.0, 1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8, 9.9)
dim(mytemp) &lt;- c(5,2)

##  Put the data
var.put.nc(nc, "time", mytime)
var.put.nc(nc, "temperature", mytemp)

##  Synchronize to disk
sync.nc(nc)

##  Open a new connection to the dataset and read data:
nc2 &lt;- open.nc(file1)
newtime &lt;- var.get.nc(nc2, 0)
newtemp &lt;- var.get.nc(nc2, "temperature")
stopifnot(all.equal(newtime,mytime))
stopifnot(all.equal(newtemp,mytemp))

close.nc(nc)
close.nc(nc2)
unlink(file1)
</code></pre>

<hr>
<h2 id='type.def.nc'>Define a NetCDF Type</h2><span id='topic+type.def.nc'></span>

<h3>Description</h3>

<p>Define complex data structures based on existing NetCDF data types.</p>


<h3>Usage</h3>

<pre><code class='language-R'>type.def.nc(ncfile, typename, class, size=NULL, basetype=NULL,
            names=NULL, values=NULL, subtypes=NULL, dimsizes=NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="type.def.nc_+3A_ncfile">ncfile</code></td>
<td>
<p>Object of class <code>NetCDF</code> which points to the NetCDF dataset (as returned from <code><a href="#topic+open.nc">open.nc</a></code>).</p>
</td></tr>
<tr><td><code id="type.def.nc_+3A_typename">typename</code></td>
<td>
<p>Name to identify the new data type. Must begin with an alphabetic character, followed by zero or more alphanumeric characters including the underscore (<code>"_"</code>). Case is significant.</p>
</td></tr>
<tr><td><code id="type.def.nc_+3A_class">class</code></td>
<td>
<p>One of the keywords <code>"compound"</code>, <code>"enum"</code>, <code>"opaque"</code> or <code>"vlen"</code>.</p>
</td></tr>
<tr><td><code id="type.def.nc_+3A_size">size</code></td>
<td>
<p>(<code>"opaque"</code>) Size in bytes of a single item of the opaque type.</p>
</td></tr>
<tr><td><code id="type.def.nc_+3A_basetype">basetype</code></td>
<td>
<p>(<code>"enum"</code> or <code>"vlen"</code>) Base type, given as the name or identifier of an existing NetCDF type. Only built-in integer types (e.g. <code>"NC_INT"</code>) are allowed for <code>class="enum"</code>.</p>
</td></tr>
<tr><td><code id="type.def.nc_+3A_names">names</code></td>
<td>
<p>(<code>"compound"</code> or <code>"enum"</code>) Name of each field or member (character vector).</p>
</td></tr>
<tr><td><code id="type.def.nc_+3A_values">values</code></td>
<td>
<p>(<code>"enum"</code>) Numeric value of each member (numeric vector).</p>
</td></tr>
<tr><td><code id="type.def.nc_+3A_subtypes">subtypes</code></td>
<td>
<p>(<code>"compound"</code>) NetCDF type of each field, given by name (character vector) or identifier (numeric vector).</p>
</td></tr>
<tr><td><code id="type.def.nc_+3A_dimsizes">dimsizes</code></td>
<td>
<p>(<code>"compound"</code>) Array dimensions of each field, specified as a list of numeric vectors. Dimensions are given in R order (leftmost index varies fastest; opposite to CDL conventions). If a list item is <code>NULL</code>, the corresponding field is a scalar.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>User-defined types are supported by files in <code>"netcdf4"</code> format. This function creates a new NetCDF data type, which can be used in definitions of NetCDF variables and attributes.
</p>
<p>Several varieties of data type are supported, as specified by argument <code>class</code>:
</p>

<table>
<tr>
 <td style="text-align: left;">
    <code>"compound"</code> </td><td style="text-align: left;"> Combines atomic and user-defined types into C-like structs. </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>"enum"</code>     </td><td style="text-align: left;"> Set of named integer values, similar to an R <code>factor</code>. </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>"opaque"</code>   </td><td style="text-align: left;"> Blobs of arbitrary data with a given size. </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>"vlen"</code>     </td><td style="text-align: left;"> Variable length vectors of a given base type. </td>
</tr>
<tr>
 <td style="text-align: left;">
  </td>
</tr>

</table>

<p><code>type.def.nc</code> may be repeated to insert additional members of an <code>"enum"</code> type or fields of a <code>"compound"</code> type. However, the size of a <code>"compound"</code> type is calculated from the fields specified when it is first defined, and later insertion of fields will only succeed if there is sufficient free space after the last field. Existing fields/members cannot be modified, and types cannot be removed from a dataset.
</p>


<h3>Value</h3>

<p>NetCDF type identifier, returned invisibly.</p>


<h3>Author(s)</h3>

<p>Pavel Michna, Milton Woods</p>


<h3>References</h3>

<p><a href="https://www.unidata.ucar.edu/software/netcdf/">https://www.unidata.ucar.edu/software/netcdf/</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>##  Create a new NetCDF4 dataset and define types
file1 &lt;- tempfile("type.def_", fileext=".nc")
nc &lt;- create.nc(file1, format="netcdf4")

# Compound type:
type.def.nc(nc, "astruct", "compound",
            names=c("siteid", "height", "colour"),
            subtypes=c("NC_INT", "NC_DOUBLE", "NC_SHORT"),
            dimsizes=list(NULL, NULL, c(3)))

# Enum type:
type.def.nc(nc, "afactor", "enum", basetype="NC_INT",
            names=c("peanut butter", "jelly"),
            values=c(101,102))

# Opaque type:
type.def.nc(nc, "ablob", "opaque", size=128)

# Vlen type:
type.def.nc(nc, "avector", "vlen", basetype="NC_FLOAT")

close.nc(nc)
unlink(file1)
</code></pre>

<hr>
<h2 id='type.inq.nc'>Inquire About a NetCDF Type</h2><span id='topic+type.inq.nc'></span>

<h3>Description</h3>

<p>Inquire about a NetCDF builtin or user-defined data type.</p>


<h3>Usage</h3>

<pre><code class='language-R'>type.inq.nc(ncfile, type, fields=TRUE)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="type.inq.nc_+3A_ncfile">ncfile</code></td>
<td>
<p>Object of class <code>NetCDF</code> which points to the NetCDF dataset or group.</p>
</td></tr>
<tr><td><code id="type.inq.nc_+3A_type">type</code></td>
<td>
<p>ID or name of a NetCDF data type.</p>
</td></tr>
<tr><td><code id="type.inq.nc_+3A_fields">fields</code></td>
<td>
<p>Read members of enum types or fields of compound types (default <code>TRUE</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function obtains information about a NetCDF data type, which could be builtin or user-defined. The items in the return list depend on the class of the NetCDF type.</p>


<h3>Value</h3>

<p>A list containing the following components:
</p>
<table role = "presentation">
<tr><td><code>id</code></td>
<td>
<p>Type ID.</p>
</td></tr>
<tr><td><code>name</code></td>
<td>
<p>Type name.</p>
</td></tr>
<tr><td><code>class</code></td>
<td>
<p>One of the keywords <code>"builtin"</code>, <code>"compound"</code>, <code>"enum"</code>, <code>"opaque"</code> or <code>"vlen"</code>.</p>
</td></tr>
<tr><td><code>size</code></td>
<td>
<p>Size in bytes of a single item of the type (or a single element of a <code>"vlen"</code>).</p>
</td></tr>
<tr><td><code>basetype</code></td>
<td>
<p>(<code>"enum"</code> or <code>"vlen"</code>) Name of the NetCDF type of each element.</p>
</td></tr>
</table>
<p>If <code>fields=TRUE</code>, the return list includes details about members of enum types or fields of compound types:
</p>
<table role = "presentation">
<tr><td><code>value</code></td>
<td>
<p>(<code>"enum"</code> only) Named vector with numeric values of all members.</p>
</td></tr>
<tr><td><code>offset</code></td>
<td>
<p>(<code>"compound"</code> only) Named vector with the offset of each field in bytes from the beginning of the compound type.</p>
</td></tr>
<tr><td><code>subtype</code></td>
<td>
<p>(<code>"compound"</code> only) Named vector with the NetCDF type name of each field.</p>
</td></tr>
<tr><td><code>dimsizes</code></td>
<td>
<p>(<code>"compound"</code> only) Named list with array dimensions of each field. Dimension lengths are reported in R order (leftmost index varies fastest; opposite to CDL conventions). A <code>NULL</code> length indicates a scalar.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Pavel Michna, Milton Woods</p>


<h3>References</h3>

<p><a href="https://www.unidata.ucar.edu/software/netcdf/">https://www.unidata.ucar.edu/software/netcdf/</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+grp.inq.nc">grp.inq.nc</a></code> - get a list of NetCDF types defined in a dataset or group.
</p>
<p><code><a href="#topic+type.def.nc">type.def.nc</a></code> - define a new NetCDF type.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##  Create a new NetCDF4 dataset and define types
file1 &lt;- tempfile("type.inq_", fileext=".nc")
nc &lt;- create.nc(file1, format="netcdf4")

# Define a type of each class:
type.def.nc(nc, "blob", "opaque", size=128)
type.def.nc(nc, "vector", "vlen", basetype="NC_FLOAT")

type.def.nc(nc, "factor", "enum", basetype="NC_INT",
            names=c("peanut butter", "jelly"),
            values=c(101, 102))

type.def.nc(nc, "struct", "compound",
            names=c("siteid", "height", "colour"),
            subtypes=c("NC_INT", "NC_DOUBLE", "NC_SHORT"),
            dimsizes=list(NULL, NULL, c(3))) 

# Inquire about the types:
typeids &lt;- grp.inq.nc(nc)$typeids

for (typeid in typeids) {
  print(type.inq.nc(nc, typeid))
}

close.nc(nc)
unlink(file1)
</code></pre>

<hr>
<h2 id='utcal.nc'>Convert Temporal Amounts to UTC Referenced Dates</h2><span id='topic+utcal.nc'></span>

<h3>Description</h3>

<p>Convert temporal amounts to UTC referenced date and time.</p>


<h3>Usage</h3>

<pre><code class='language-R'>utcal.nc(unitstring, value, type="n")</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="utcal.nc_+3A_unitstring">unitstring</code></td>
<td>
<p>A temporal unit with an origin (e.g., <code>"days since 1900-01-01"</code>).</p>
</td></tr>
<tr><td><code id="utcal.nc_+3A_value">value</code></td>
<td>
<p>An amount (quantity) of the given temporal unit.</p>
</td></tr>
<tr><td><code id="utcal.nc_+3A_type">type</code></td>
<td>
<p>Character string which determines the output type. Can be <code>"n"</code> for numeric, <code>"s"</code> for string or <code>"c"</code> for POSIXct output.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Converts the amount, <code>value</code>, of the temporal unit, <code>unitstring</code>, into a UTC-referenced date and time.
</p>
<p>Functions <code>utcal.nc</code> and <code>utinvcal.nc</code> provide a convenient way to convert time values between the forms used by NetCDF variables and R functions. Most R functions require times to be expressed as seconds since the beginning of 1970 in the UTC time zone, typically using objects of class <code>POSIXct</code> or <code>POSIXlt</code>. NetCDF files store times in numeric variables with a wide variety of units. The units and calendar are stored in attributes of the time variable, as described by the CF Conventions. Units are expressed as a string, in the form of a time unit since a fixed date-time (e.g. <code>"hours since 2000-01-01 00:00:00 +00:00"</code>, or more simply <code>"hours since 2000-01-01"</code>).
</p>
<p>The conversions of times between units are performed by the UDUNITS library using a mixed Gregorian/Julian calendar system. Dates prior to 1582-10-15 are assumed to use the Julian calendar, which was introduced by Julius Caesar in 46 BCE and is based on a year that is exactly 365.25 days long. Dates on and after 1582-10-15 are assumed to use the Gregorian calendar, which was introduced on that date and is based on a year that is exactly 365.2425 days long. (A year is actually approximately 365.242198781 days long.) Seemingly strange behavior of the UDUNITS package can result if a user-given time interval includes the changeover date.
</p>
<p>Conversions involving alternative calendars are not supported by UDUNITS, but they can be performed by other R packages. For example, <a href="https://CRAN.R-project.org/package=PCICt">https://CRAN.R-project.org/package=PCICt</a> implements 360- and 365-day calendars.
</p>


<h3>Value</h3>

<p>If the output type is set to numeric, result is a matrix containing the corresponding date(s) and time(s), with the following columns: year, month, day, hour, minute, second. If the output type is string, result is a vector of strings in the form <code>"YYYY-MM-DD hh:mm:ss"</code>. Otherwise result is a vector of POSIXct values.</p>


<h3>Author(s)</h3>

<p>Pavel Michna, Milton Woods</p>


<h3>References</h3>

<p><a href="https://www.unidata.ucar.edu/software/udunits/">https://www.unidata.ucar.edu/software/udunits/</a>
</p>
<p><a href="http://cfconventions.org">http://cfconventions.org</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+utinvcal.nc">utinvcal.nc</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>if (inherits(try(utcal.nc("seconds since 1970-01-01", 0)), "try-error")) {
  warning("UDUNITS calendar conversions not supported by this build of RNetCDF")

} else {

  ##  Convert units to UTC referenced time
  utcal.nc("hours since 1900-01-01 00:00:00 +01:00", c(0:5))
  utcal.nc("hours since 1900-01-01 00:00:00 +01:00", c(0:5), type="s")
  utcal.nc("hours since 1900-01-01 00:00:00 +01:00", c(0:5), type="c")

  ## Create netcdf file with a time coordinate variable.

  # Create a time variable (using type POSIXct for convenience):
  nt &lt;- 24
  time_posixct &lt;- seq(ISOdatetime(1900,1,1,0,0,0,tz="UTC"), by="hour", len=nt)

  # Convert time variable to specified units:
  time_unit &lt;- "hours since 1900-01-01 00:00:00 +00:00"
  time_coord &lt;- utinvcal.nc(time_unit, time_posixct)

  # Create a netcdf file:
  file1 &lt;- tempfile("utcal_", fileext=".nc")
  nc &lt;- create.nc(file1)

  # Global attributes:
  att.put.nc(nc, "NC_GLOBAL", "Conventions", "NC_CHAR", "CF-1.6")
  att.put.nc(nc, "NC_GLOBAL", "title", "NC_CHAR", "RNetCDF example: time coordinate")
  att.put.nc(nc, "NC_GLOBAL", "institution", "NC_CHAR", "University of Areland")
  att.put.nc(nc, "NC_GLOBAL", "source", "NC_CHAR", 
    paste("RNetCDF", utils::packageVersion("RNetCDF"), sep="_"))
  att.put.nc(nc, "NC_GLOBAL", "history", "NC_CHAR",
    paste(Sys.time(), "File created"))
  att.put.nc(nc, "NC_GLOBAL", "references", "NC_CHAR",
    "https://www.unidata.ucar.edu/software/udunits")
  att.put.nc(nc, "NC_GLOBAL", "comment", "NC_CHAR",
    "Uses attributes recommended by http://cfconventions.org")

  # Define time coordinate and attributes:
  dim.def.nc(nc, "time", nt)
  var.def.nc(nc, "time", "NC_DOUBLE", "time")
  att.put.nc(nc, "time", "long_name", "NC_CHAR", "time")
  att.put.nc(nc, "time", "units", "NC_CHAR", time_unit)
  # Calendar is optional (gregorian is the default):
  att.put.nc(nc, "time", "calendar", "NC_CHAR", "gregorian")

  # Write the data:
  var.put.nc(nc, "time", time_coord)

  close.nc(nc)

  ## Read time coordinate from netcdf file:

  # Open the file prepared earlier:
  nc &lt;- open.nc(file1)

  # Read time coordinate and attributes:
  time_coord2 &lt;- var.get.nc(nc, "time")
  time_unit2 &lt;- att.get.nc(nc, "time", "units")

  close.nc(nc)
  unlink(file1)

  # Convert the time variable to POSIXct:
  time_posixct2 &lt;- utcal.nc(time_unit2, time_coord2, "c")

  # Compare with original POSIXct variable:
  stopifnot(all.equal(time_posixct, time_posixct2))

}
</code></pre>

<hr>
<h2 id='utinit.nc'>Initialize the UDUNITS2 Library</h2><span id='topic+utinit.nc'></span>

<h3>Description</h3>

<p>Initialize the UDUNITS2 library.</p>


<h3>Usage</h3>

<pre><code class='language-R'>utinit.nc(path="")</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="utinit.nc_+3A_path">path</code></td>
<td>
<p>Path to an XML-formatted unit-database for UDUNITS2.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function initializes the UDUNITS2 library. It is called by <code>.onLoad</code> when the package is loaded. Normally, the user does not need to call this function.
</p>
<p>UDUNITS2 obtains a unit system by reading an XML file. The file name is given by argument <code>path</code>, if it is a non-empty character string. Otherwise, the file name is taken from environment variable <code>UDUNITS2_XML_PATH</code>, if it is a non-empty character string. By default, the file name is set to an XML file distributed with RNetCDF.
</p>


<h3>Author(s)</h3>

<p>Pavel Michna, Milton Woods</p>


<h3>References</h3>

<p><a href="https://www.unidata.ucar.edu/software/udunits/">https://www.unidata.ucar.edu/software/udunits/</a></p>

<hr>
<h2 id='utinvcal.nc'>Convert UTC Referenced Dates Into Temporal Amounts</h2><span id='topic+utinvcal.nc'></span>

<h3>Description</h3>

<p>Convert a UTC referenced date into a temporal amount.</p>


<h3>Usage</h3>

<pre><code class='language-R'>utinvcal.nc(unitstring, value)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="utinvcal.nc_+3A_unitstring">unitstring</code></td>
<td>
<p>A temporal unit with an origin (e.g., <code>"days since 1900-01-01"</code>).</p>
</td></tr>
<tr><td><code id="utinvcal.nc_+3A_value">value</code></td>
<td>
<p>Dates to convert as a numeric vector or array, or a vector of strings or POSIXct values.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Uses the UDUNITS library to convert a UTC-referenced date and time into the amount, <code>value</code>, of the temporal unit, <code>unitstring</code>.
</p>
<p>If the dates are given in string form, the structure must be exactly <code>"YYYY-MM-DD hh:mm:ss"</code>.
</p>
<p>A vector of POSIXct values is also accepted as input. These are converted to the specified units by a linear transformation, without an intermediate separation into date components.
</p>


<h3>Value</h3>

<p>A vector containing the amount(s) of the temporal unit(s) corresponding to the given date(s).</p>


<h3>Author(s)</h3>

<p>Pavel Michna, Milton Woods</p>


<h3>References</h3>

<p><a href="https://www.unidata.ucar.edu/software/udunits/">https://www.unidata.ucar.edu/software/udunits/</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+utcal.nc">utcal.nc</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>if (inherits(try(utcal.nc("seconds since 1970-01-01", 0)), "try-error")) {
  warning("UDUNITS calendar conversions not supported by this build of RNetCDF")

} else {

  ##  Convert UTC referenced time to other time units
  utinvcal.nc("hours since 1900-01-01 00:00:00 +01:00", c(1900,1,1,5,25,0))
  utinvcal.nc("hours since 1900-01-01 00:00:00 +01:00", "1900-01-01 05:25:00")
  utinvcal.nc("hours since 1900-01-01 00:00:00 +01:00", ISOdatetime(1900,1,1,5,25,0,tz="UTC"))

}

##  An example of reading and writing a netcdf time coordinate 
##  is given in the help for utcal.nc
</code></pre>

<hr>
<h2 id='var.def.nc'>Define a NetCDF Variable</h2><span id='topic+var.def.nc'></span>

<h3>Description</h3>

<p>Define a new NetCDF variable.</p>


<h3>Usage</h3>

<pre><code class='language-R'>var.def.nc(ncfile, varname, vartype, dimensions,
                  chunking=NA, chunksizes=NULL, deflate=NA, shuffle=FALSE,
                  big_endian=NA, fletcher32=FALSE,
                  filter_id=integer(0), filter_params=list())</code></pre>


<h3>Arguments</h3>

<p>Arguments marked <code>"netcdf4"</code> are optional for datasets in that format and ignored for other formats.
</p>
<table role = "presentation">
<tr><td><code id="var.def.nc_+3A_ncfile">ncfile</code></td>
<td>
<p>Object of class <code>NetCDF</code> which points to the NetCDF dataset (as returned from <code><a href="#topic+open.nc">open.nc</a></code>).</p>
</td></tr>
<tr><td><code id="var.def.nc_+3A_varname">varname</code></td>
<td>
<p>Variable name. Must begin with an alphabetic character, followed by zero or more alphanumeric characters including the underscore (<code>"_"</code>). Case is significant.</p>
</td></tr>
<tr><td><code id="var.def.nc_+3A_vartype">vartype</code></td>
<td>
<p>External NetCDF data type as one of the following labels: <code>NC_BYTE</code>, <code>NC_UBYTE</code>, <code>NC_CHAR</code>, <code>NC_SHORT</code>, <code>NC_USHORT</code>, <code>NC_INT</code>, <code>NC_UINT</code>, <code>NC_INT64</code>, <code>NC_UINT64</code>, <code>NC_FLOAT</code>, <code>NC_DOUBLE</code>, <code>NC_STRING</code>, or a user-defined type name.</p>
</td></tr>
<tr><td><code id="var.def.nc_+3A_dimensions">dimensions</code></td>
<td>
<p>Vector of <code>ndims</code> dimension IDs or their names corresponding to the variable dimensions or <code>NA</code> if a scalar variable should be created. If the ID (or name) of the unlimited dimension is included, it must be last.</p>
</td></tr>
<tr><td><code id="var.def.nc_+3A_chunking">chunking</code></td>
<td>
<p>(<code>"netcdf4"</code>) <code>TRUE</code> selects chunking, <code>FALSE</code> implies contiguous storage, <code>NA</code> allows the NetCDF library to choose a storage layout. Ignored for scalar variables.</p>
</td></tr>
<tr><td><code id="var.def.nc_+3A_chunksizes">chunksizes</code></td>
<td>
<p>(<code>"netcdf4"</code>) Chunk size expressed as the number of elements along each dimension, in the same order as <code>dimensions</code>. If <code>NULL</code>, the NetCDF library uses a default chunking strategy, which is intended to give reasonable performance in typical applications. Ignored unless <code>chunking</code> is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="var.def.nc_+3A_deflate">deflate</code></td>
<td>
<p>(<code>"netcdf4"</code>) Integer indicating level of compression, from 0 (minimum) to 9 (maximum), or <code>NA</code> for no compression.</p>
</td></tr>
<tr><td><code id="var.def.nc_+3A_shuffle">shuffle</code></td>
<td>
<p>(<code>"netcdf4"</code>) <code>TRUE</code> to enable byte shuffling, which may improve compression with <code>deflate</code>.</p>
</td></tr>
<tr><td><code id="var.def.nc_+3A_big_endian">big_endian</code></td>
<td>
<p>(<code>"netcdf4"</code>) Byte order of the variable. <code>TRUE</code> for big-endian, <code>FALSE</code> for little-endian, <code>NA</code> for native endianness of the platform.</p>
</td></tr>
<tr><td><code id="var.def.nc_+3A_fletcher32">fletcher32</code></td>
<td>
<p>(<code>"netcdf4"</code>) <code>TRUE</code> to enable the fletcher32 checksum.</p>
</td></tr>
<tr><td><code id="var.def.nc_+3A_filter_id">filter_id</code></td>
<td>
<p>(<code>"netcdf4"</code>) Vector of filter IDs to associate with the variable (empty vector denotes no filters). For information about the available filters, please see the NetCDF documentation. Ignored if the installed NetCDF library does not support the multi-filter interface.</p>
</td></tr>
<tr><td><code id="var.def.nc_+3A_filter_params">filter_params</code></td>
<td>
<p>(<code>"netcdf4"</code>) List with one element for each <code>filter_id</code>. Each list member is a vector of <code>numeric</code> parameters (which are converted to unsigned integers). The meaning of the parameters depends on the filter implementation, and RNetCDF is unable to perform any validation. Ignored if the installed NetCDF library does not support the multi-filter interface.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function creates a new NetCDF variable. A NetCDF variable has a name, a type, and a shape, which are specified when it is defined. A variable may also have values, which are established later in data mode. 
</p>
<p>Ordinarily, the name, type, and shape are fixed when the variable is first defined. The name may be changed, but the type and shape of a variable cannot be changed. However, a variable defined in terms of the unlimited dimension can grow without bound in that dimension. The fastest varying dimension has to be first in <code>dimensions</code>, the slowest varying dimension last (this is the same way as an array is defined in R; i.e., opposite to the CDL conventions).
</p>
<p>A NetCDF variable in an open NetCDF dataset is referred to by a small integer called a variable ID. Variable IDs are 0, 1, 2,..., in the order in which the variables were defined within a NetCDF dataset.
</p>
<p>Attributes may be associated with a variable to specify such properties as units.</p>


<h3>Value</h3>

<p>NetCDF variable identifier, returned invisibly.</p>


<h3>Author(s)</h3>

<p>Pavel Michna, Milton Woods</p>


<h3>References</h3>

<p><a href="https://www.unidata.ucar.edu/software/netcdf/">https://www.unidata.ucar.edu/software/netcdf/</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>##  Create a new NetCDF dataset and define two dimensions
file1 &lt;- tempfile("var.def_", fileext=".nc")
nc &lt;- create.nc(file1)

dim.def.nc(nc, "station", 5)
dim.def.nc(nc, "time", unlim=TRUE)

##  Create two variables, one as coordinate variable
var.def.nc(nc, "time", "NC_INT", "time")
var.def.nc(nc, "temperature", "NC_DOUBLE", c(0,1))

close.nc(nc)
unlink(file1)
</code></pre>

<hr>
<h2 id='var.get.nc'>Read Data from a NetCDF Variable</h2><span id='topic+var.get.nc'></span>

<h3>Description</h3>

<p>Read the contents of a NetCDF variable.</p>


<h3>Usage</h3>

<pre><code class='language-R'>var.get.nc(ncfile, variable, start=NA, count=NA,
  na.mode=4, collapse=TRUE, unpack=FALSE, rawchar=FALSE, fitnum=FALSE,
  cache_bytes=NA, cache_slots=NA, cache_preemption=NA)</code></pre>


<h3>Arguments</h3>

<p>Arguments marked <code>"netcdf4"</code> are optional for datasets in that format and ignored for other formats.
</p>
<table role = "presentation">
<tr><td><code id="var.get.nc_+3A_ncfile">ncfile</code></td>
<td>
<p>Object of class <code>NetCDF</code> which points to the NetCDF dataset (as returned from <code><a href="#topic+open.nc">open.nc</a></code>).</p>
</td></tr>
<tr><td><code id="var.get.nc_+3A_variable">variable</code></td>
<td>
<p>ID or name of the NetCDF variable.</p>
</td></tr>
<tr><td><code id="var.get.nc_+3A_start">start</code></td>
<td>
<p>A vector of indices specifying the element where reading starts along each dimension of <code>variable</code>. Indices are numbered from 1 onwards, and the order of dimensions is shown by <code><a href="#topic+print.nc">print.nc</a></code> (array elements are stored sequentially with leftmost indices varying fastest). By default (<code>start=NA</code>), all dimensions of <code>variable</code> are read from the first element onwards. Otherwise, <code>start</code> must be a vector whose length is not less than the number of dimensions in <code>variable</code> (excess elements are ignored). Any <code>NA</code> values in vector <code>start</code> are set to 1.</p>
</td></tr>
<tr><td><code id="var.get.nc_+3A_count">count</code></td>
<td>
<p>A vector of integers specifying the number of values to read along each dimension of <code>variable</code>. The order of dimensions is the same as for <code>start</code>. By default (<code>count=NA</code>), all dimensions of <code>variable</code> are read from <code>start</code> to end. Otherwise, <code>count</code> must be a vector whose length is not less than the number of dimensions in <code>variable</code> (excess elements are ignored). Any <code>NA</code> value in vector <code>count</code> indicates that the corresponding dimension should be read from the <code>start</code> index to the end of the dimension.</p>
</td></tr>
<tr><td><code id="var.get.nc_+3A_na.mode">na.mode</code></td>
<td>
<p>Missing values in the NetCDF dataset are converted to <code>NA</code> values in the result returned to R. The missing values are defined by attributes of the NetCDF <code>variable</code>, which are selected by the following modes:
</p>

<table>
<tr>
 <td style="text-align: left;">
    mode </td><td style="text-align: left;"> data type </td><td style="text-align: left;"> attribute(s) </td>
</tr>
<tr>
 <td style="text-align: left;">
    0 </td><td style="text-align: left;"> numeric </td><td style="text-align: left;"> <code>_FillValue</code>, then <code>missing_value</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
    1 </td><td style="text-align: left;"> numeric </td><td style="text-align: left;"> <code>_FillValue</code> only </td>
</tr>
<tr>
 <td style="text-align: left;">
    2 </td><td style="text-align: left;"> numeric </td><td style="text-align: left;"> <code>missing_value</code> only </td>
</tr>
<tr>
 <td style="text-align: left;">
    3 </td><td style="text-align: left;"> any </td><td style="text-align: left;"> no conversion </td>
</tr>
<tr>
 <td style="text-align: left;">
    4 </td><td style="text-align: left;"> numeric </td><td style="text-align: left;"> <code>valid_range</code>, <code>valid_min</code>, <code>valid_max</code>, <code>_FillValue</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
    5 </td><td style="text-align: left;"> any </td><td style="text-align: left;"> same as mode 4 for numeric types; </td>
</tr>
<tr>
 <td style="text-align: left;">
      </td><td style="text-align: left;">     </td><td style="text-align: left;"> <code>_FillValue</code> for other types </td>
</tr>
<tr>
 <td style="text-align: left;">
    </td>
</tr>

</table>

<p>For explanation of attribute conventions used by mode 4, please see:
<a href="https://docs.unidata.ucar.edu/nug/current/attribute_conventions.html">https://docs.unidata.ucar.edu/nug/current/attribute_conventions.html</a>
</p>
</td></tr>
<tr><td><code id="var.get.nc_+3A_collapse">collapse</code></td>
<td>
<p><code>TRUE</code> if degenerated dimensions (length=1) should be omitted.</p>
</td></tr>
<tr><td><code id="var.get.nc_+3A_unpack">unpack</code></td>
<td>
<p>Packed variables are unpacked if <code>unpack=TRUE</code> and the attributes <code>add_offset</code> and/or <code>scale_factor</code> are defined. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="var.get.nc_+3A_rawchar">rawchar</code></td>
<td>
<p>This option only relates to NetCDF variables of type <code>NC_CHAR</code>. When <code>rawchar</code> is <code>FALSE</code> (default), a NetCDF variable of type <code>NC_CHAR</code> is converted to a <code>character</code> array in R. The <code>character</code> values are from the fastest-varying dimension of the NetCDF variable, so that the R <code>character</code> array has one fewer dimensions than the <code>NC_CHAR</code> array. If <code>rawchar</code> is <code>TRUE</code>, the bytes of <code>NC_CHAR</code> data are read into an R <code>raw</code> array of the same shape.</p>
</td></tr>
<tr><td><code id="var.get.nc_+3A_fitnum">fitnum</code></td>
<td>
<p>By default, all numeric variables are read into R as double precision values. When <code>fitnum==TRUE</code>, the smallest R numeric type that can exactly represent each external type is used, as follows:
</p>

<table>
<tr>
 <td style="text-align: left;">
    <code>NC_BYTE</code>       </td><td style="text-align: left;"> <code><a href="base.html#topic+integer">integer</a></code> </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>NC_UBYTE</code>      </td><td style="text-align: left;"> <code><a href="base.html#topic+integer">integer</a></code> </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>NC_SHORT</code>      </td><td style="text-align: left;"> <code><a href="base.html#topic+integer">integer</a></code> </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>NC_USHORT</code>     </td><td style="text-align: left;"> <code><a href="base.html#topic+integer">integer</a></code> </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>NC_INT</code>        </td><td style="text-align: left;"> <code><a href="base.html#topic+integer">integer</a></code> </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>NC_UINT</code>       </td><td style="text-align: left;"> <code><a href="base.html#topic+double">double</a></code> </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>NC_FLOAT</code>      </td><td style="text-align: left;"> <code><a href="base.html#topic+double">double</a></code> </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>NC_DOUBLE</code>     </td><td style="text-align: left;"> <code><a href="base.html#topic+double">double</a></code> </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>NC_INT64</code>      </td><td style="text-align: left;"> <code><a href="bit64.html#topic+bit64-package">integer64</a></code> </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>NC_UINT64</code>     </td><td style="text-align: left;"> <code><a href="bit64.html#topic+bit64-package">integer64</a></code> </td>
</tr>
<tr>
 <td style="text-align: left;">
  </td>
</tr>

</table>
</td></tr>
<tr><td><code id="var.get.nc_+3A_cache_bytes">cache_bytes</code></td>
<td>
<p>(<code>"netcdf4"</code>) Size of chunk cache in bytes. Value of <code>NA</code> (default) implies no change.</p>
</td></tr>
<tr><td><code id="var.get.nc_+3A_cache_slots">cache_slots</code></td>
<td>
<p>(<code>"netcdf4"</code>) Number of slots in chunk cache. Value of <code>NA</code> (default) implies no change.</p>
</td></tr>
<tr><td><code id="var.get.nc_+3A_cache_preemption">cache_preemption</code></td>
<td>
<p>(<code>"netcdf4"</code>) Value between 0 and 1 (inclusive) that biases the cache scheme towards eviction of chunks that have been fully read. Value of <code>NA</code> (default) implies no change.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>NetCDF numeric variables cannot portably represent <code>NA</code> values from R. NetCDF does allow attributes to be defined for variables, and several conventions exist for attributes that define missing values and valid ranges. The convention in use can be specified by argument <code>na.mode</code>. Values of a NetCDF variable that are deemed to be missing are automatically converted to <code>NA</code> in the results returned to R. Unusual cases can be handled directly in user code by setting <code>na.mode=3</code>.
</p>
<p>To reduce the storage space required by a NetCDF file, numeric variables are sometimes packed into types of lower precision. The original data can be recovered (approximately) by multiplication of the stored values by attribute <code>scale_factor</code> followed by addition of attribute <code>add_offset</code>. This unpacking operation is performed automatically for variables with attributes <code>scale_factor</code> and/or <code>add_offset</code> if argument <code>unpack</code> is set to <code>TRUE</code>. If <code>unpack</code> is <code>FALSE</code>, values are read from each variable without alteration.
</p>
<p>Data in a NetCDF variable is represented as a multi-dimensional array. The number and length of dimensions is determined when the variable is created. The <code>start</code> and <code>count</code> arguments of this routine indicate where the reading starts and the number of values to read along each dimension.
</p>
<p>The argument <code>collapse</code> allows to keep degenerated dimensions (if set to <code>FALSE</code>). As default, array dimensions with length=1 are omitted (e.g., an array with dimensions [2,1,3,4] in the NetCDF dataset is returned as [2,3,4]).
</p>
<p>Awkwardness arises mainly from one thing: NetCDF data are written with the last dimension varying fastest, whereas R works opposite. Thus, the order of the dimensions according to the CDL conventions (e.g., time, latitude, longitude) is reversed in the R array (e.g., longitude, latitude, time).</p>


<h3>Value</h3>

<p>An array with dimensions determined by <code>count</code> and a data type that depends on the type of <code>variable</code>. For NetCDF variables of type <code>NC_CHAR</code>, the R type is either <code>character</code> or <code>raw</code>, as specified by argument <code>rawchar</code>. For <code>NC_STRING</code>, the R type is <code>character</code>. Numeric variables are read as double precision by default, but the smallest R type that exactly represents each external type is used if <code>fitnum</code> is <code>TRUE</code>.
</p>
<p>Variables of user-defined types are supported. <code>"compound"</code> arrays are read into R as lists, with items named for the compound fields; items of base NetCDF data types are converted to R arrays, with leading dimensions from the field dimensions (if any) and trailing dimensions from the NetCDF variable. <code>"enum"</code> arrays are read into R as factor arrays. <code>"opaque"</code> arrays are read into R as raw (byte) arrays, with a leading dimension for bytes of the opaque type and trailing dimensions from the NetCDF variable. <code>"vlen"</code> arrays are read into R as a list with dimensions of the NetCDF variable; items in the list may have different lengths; base NetCDF data types are converted to R vectors.
</p>
<p>The dimension order in the R array is reversed relative to the order reported by NetCDF commands such as <code>ncdump</code>, because NetCDF arrays are stored in row-major (C) order whereas R arrays are stored in column-major (Fortran) order.
</p>
<p>Arrays of type <code>character</code> drop the fastest-varying dimension of the corresponding <code>NC_CHAR</code> array, because this dimension corresponds to the length of the individual <code>character</code> elements. For example, an <code>NC_CHAR</code> array with dimensions (5,10) would be returned as a <code>character</code> vector containing 5 elements, each with a maximum length of 10 characters.
</p>
<p>The arguments marked for <code>"netcdf4"</code> format refer to the chunk cache used for reading and writing variables. Default cache settings are defined by the NetCDF library, and they can be adjusted for each variable to improve performance in some applications.
</p>


<h3>Note</h3>

<p><code>NC_BYTE</code> is always interpreted as signed.</p>


<h3>Author(s)</h3>

<p>Pavel Michna, Milton Woods</p>


<h3>References</h3>

<p><a href="https://www.unidata.ucar.edu/software/netcdf/">https://www.unidata.ucar.edu/software/netcdf/</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>##  Create a new NetCDF dataset and define two dimensions
file1 &lt;- tempfile("var.get_", fileext=".nc")
nc &lt;- create.nc(file1)

dim.def.nc(nc, "station", 5)
dim.def.nc(nc, "time", unlim=TRUE)
dim.def.nc(nc, "max_string_length", 32)

##  Create three variables, one as coordinate variable
var.def.nc(nc, "time", "NC_INT", "time")
var.def.nc(nc, "temperature", "NC_DOUBLE", c(0,1))
var.def.nc(nc, "name", "NC_CHAR", c("max_string_length", "station"))

##  Put some _FillValue attribute for temperature
att.put.nc(nc, "temperature", "_FillValue", "NC_DOUBLE", -99999.9)

##  Define variable values
mytime        &lt;- c(1:2)
mytemperature &lt;- c(1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, NA, NA, 9.9)
myname        &lt;- c("alfa", "bravo", "charlie", "delta", "echo")

##  Put the data
var.put.nc(nc, "time", mytime, 1, length(mytime))
var.put.nc(nc, "temperature", mytemperature, c(1,1), c(5,2))
var.put.nc(nc, "name", myname, c(1,1), c(32,5))

sync.nc(nc)

##  Get the data (or a subset)
var.get.nc(nc, 0)
var.get.nc(nc, "temperature")
var.get.nc(nc, "temperature", c(3,1), c(1,1))
var.get.nc(nc, "temperature", c(3,2))
var.get.nc(nc, "temperature", c(NA,2), c(NA,1))
var.get.nc(nc, "name")
var.get.nc(nc, "name", c(1,2), c(4,2))
var.get.nc(nc, "name", c(1,2), c(NA,2))

close.nc(nc)
unlink(file1)
</code></pre>

<hr>
<h2 id='var.inq.nc'>Inquire About a NetCDF Variable</h2><span id='topic+var.inq.nc'></span>

<h3>Description</h3>

<p>Inquire about a NetCDF variable.</p>


<h3>Usage</h3>

<pre><code class='language-R'>var.inq.nc(ncfile, variable)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="var.inq.nc_+3A_ncfile">ncfile</code></td>
<td>
<p>Object of class <code>NetCDF</code> which points to the NetCDF dataset (as returned from <code><a href="#topic+open.nc">open.nc</a></code>).</p>
</td></tr>
<tr><td><code id="var.inq.nc_+3A_variable">variable</code></td>
<td>
<p>Either the ID or the name of the variable to be inquired.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function returns information about a NetCDF variable, including its name, ID, type, number of dimensions, a vector of the dimension IDs, and the number of attributes.</p>


<h3>Value</h3>

<p>A list of named components, some of which are only included for datasets in <code>"netcdf4"</code> format (as reported by <code><a href="#topic+file.inq.nc">file.inq.nc</a></code>).
</p>
<table role = "presentation">
<tr><td><code>id</code></td>
<td>
<p>Variable ID.</p>
</td></tr>
<tr><td><code>name</code></td>
<td>
<p>Variable name.</p>
</td></tr>
<tr><td><code>type</code></td>
<td>
<p>External NetCDF data type as one of the following labels: <code>NC_BYTE</code>, <code>NC_UBYTE</code>, <code>NC_CHAR</code>, <code>NC_SHORT</code>, <code>NC_USHORT</code>, <code>NC_INT</code>, <code>NC_UINT</code>, <code>NC_INT64</code>, <code>NC_UINT64</code>, <code>NC_FLOAT</code>, <code>NC_DOUBLE</code>, <code>NC_STRING</code>, or a user-defined type name.</p>
</td></tr>
<tr><td><code>ndims</code></td>
<td>
<p>Number of dimensions the variable was defined as using.</p>
</td></tr>
<tr><td><code>dimids</code></td>
<td>
<p>Vector of dimension IDs corresponding to the variable dimensions (<code>NA</code> for scalar variables). Order is leftmost varying fastest.</p>
</td></tr>
<tr><td><code>natts</code></td>
<td>
<p>Number of variable attributes assigned to this variable.</p>
</td></tr>
<tr><td><code>chunksizes</code></td>
<td>
<p>(<code>"netcdf4"</code>) Chunk size expressed as the number of elements along each dimension, in the same order as <code>dimids</code>. <code>NULL</code> implies contiguous storage.</p>
</td></tr>
<tr><td><code>cache_bytes</code></td>
<td>
<p>(<code>"netcdf4"</code>) Size of chunk cache in bytes (<code>NULL</code> if unsupported).</p>
</td></tr>
<tr><td><code>cache_slots</code></td>
<td>
<p>(<code>"netcdf4"</code>) The number of slots in the chunk cache (<code>NULL</code> if unsupported).</p>
</td></tr>
<tr><td><code>cache_preemption</code></td>
<td>
<p>(<code>"netcdf4"</code>) A value between 0 and 1 (inclusive) that biases the cache scheme towards eviction of chunks that have been fully read (<code>NULL</code> if unsupported).</p>
</td></tr>
<tr><td><code>deflate</code></td>
<td>
<p>(<code>"netcdf4"</code>) Integer indicating level of compression, from 0 (minimum) to 9 (maximum), or <code>NA</code> if compression is not enabled.</p>
</td></tr>
<tr><td><code>shuffle</code></td>
<td>
<p>(<code>"netcdf4"</code>) <code>TRUE</code> if byte shuffling is enabled for the variable, <code>FALSE</code> otherwise.</p>
</td></tr>
<tr><td><code>big_endian</code></td>
<td>
<p>(<code>"netcdf4"</code>) Byte order of the variable. <code>TRUE</code> for big-endian, <code>FALSE</code> for little-endian, <code>NA</code> for not yet determined, or <code>NULL</code> if unsupported.</p>
</td></tr>
<tr><td><code>fletcher32</code></td>
<td>
<p>(<code>"netcdf4"</code>) <code>TRUE</code> if the fletcher32 checksum is enabled for this variable, <code>FALSE</code> otherwise.</p>
</td></tr>
<tr><td><code>szip_options</code></td>
<td>
<p>(<code>"netcdf4"</code>) Integer containing a bitmask of szip options. <code>NA</code> if szip is not used, or <code>NULL</code> if unsupported.</p>
</td></tr>
<tr><td><code>szip_bits</code></td>
<td>
<p>(<code>"netcdf4"</code>) Number of bits per pixel for szip. <code>NA</code> if szip is not used, or <code>NULL</code> if unsupported.</p>
</td></tr>
<tr><td><code>filter_id</code></td>
<td>
<p>(<code>"netcdf4"</code>) Vector of filter IDs associated with the variable, or <code>NULL</code> if the NetCDF library does not support the multi-filter interface.</p>
</td></tr>
<tr><td><code>filter_params</code></td>
<td>
<p>(<code>"netcdf4"</code>) List with one element per <code>filter_id</code>, or <code>NULL</code> if the NetCDF library does not support the multi-filter interface. Each list member is a vector of <code>numeric</code> parameters for the corresponding filter. Please see the NetCDF documentation for information about the available filters and their parameters.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Pavel Michna, Milton Woods</p>


<h3>References</h3>

<p><a href="https://www.unidata.ucar.edu/software/netcdf/">https://www.unidata.ucar.edu/software/netcdf/</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>##  Create a new NetCDF dataset and define two dimensions
file1 &lt;- tempfile("var.inq_", fileext=".nc")
nc &lt;- create.nc(file1)

dim.def.nc(nc, "station", 5)
dim.def.nc(nc, "time", unlim=TRUE)

##  Create two variables, one as coordinate variable
var.def.nc(nc, "time", "NC_INT", "time")
var.def.nc(nc, "temperature", "NC_DOUBLE", c(0,1))

##  Inquire about these variables
var.inq.nc(nc, 0)
var.inq.nc(nc, "temperature")

close.nc(nc)
unlink(file1)
</code></pre>

<hr>
<h2 id='var.par.nc'>Change Parallel Access Mode</h2><span id='topic+var.par.nc'></span>

<h3>Description</h3>

<p>Change the parallel access mode of a NetCDF variable from independent to collective and vice versa.</p>


<h3>Usage</h3>

<pre><code class='language-R'>var.par.nc(ncfile, variable, access="NC_COLLECTIVE")</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="var.par.nc_+3A_ncfile">ncfile</code></td>
<td>
<p>Object of class <code>NetCDF</code> which points to the NetCDF dataset (as returned from <code><a href="#topic+open.nc">open.nc</a></code>).</p>
</td></tr>
<tr><td><code id="var.par.nc_+3A_variable">variable</code></td>
<td>
<p>Numeric ID or name of the variable for which to change the parallel access mode. Use <code>"NC_GLOBAL"</code> to change the parallel access mode for all variables in the dataset.</p>
</td></tr>
<tr><td><code id="var.par.nc_+3A_access">access</code></td>
<td>
<p>Parallel access mode as one of the following strings: <code>"NC_COLLECTIVE"</code> or <code>"NC_INDEPENDENT"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Parallel file access is either collective (all processors must participate) or independent (any processor may access the data without waiting for others). Data reads and writes (i.e. calls to <code>var.put.nc</code> and <code>var.get.nc</code>) are independent by default. Use this function to change the parallel access mode for a variable from independent to collective mode or vice versa.
</p>
<p>All netCDF metadata writing operations are collective - all creation of groups, types, variables, dimensions, or attributes.
</p>
<p>Note that when the file format is <code>"classic"</code> or <code>"offset64"</code>, the change always applies to all variables in the file, even if a single variable is specified in argument <code>variable</code>.</p>


<h3>Author(s)</h3>

<p>Pavel Michna, Milton Woods</p>


<h3>References</h3>

<p><a href="https://www.unidata.ucar.edu/software/netcdf/">https://www.unidata.ucar.edu/software/netcdf/</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# This example assumes that the NetCDF library was built with MPI support,
# and that both RNetCDF and pbdMPI are installed in R.
# If the example code is stored in a file myexample.R,
# run R under MPI using a command similar to:
# SHELL&gt; mpiexec -np 2 Rscript --vanilla myexample.R

library(pbdMPI, quiet = TRUE)
library(RNetCDF, quiet = TRUE)

# Get MPI parameters
init()
rank &lt;- comm.rank()
size &lt;- comm.size()

# Define dimensions and data
nr &lt;- 5
nc_local &lt;- 4
nc &lt;- nc_local * size
data_local &lt;- matrix(rank, nrow=nr, ncol=nc_local)

# Open file for parallel access and define metadata
filename &lt;- "myexample.nc"
info.create()
ncid &lt;- create.nc(filename, format="netcdf4", mpi_comm=comm.c2f(), mpi_info=info.c2f())
rdim &lt;- dim.def.nc(ncid, "rows", nr)
cdim &lt;- dim.def.nc(ncid, "cols", nc)
varid &lt;- var.def.nc(ncid, "data", "NC_INT", c(rdim, cdim))

# Use collective I/O
var.par.nc(ncid, "data", "NC_COLLECTIVE")

# Write data
var.put.nc(ncid, varid, data_local, start=c(1,rank*nc_local+1), count=c(nr,nc_local))

# Finish up
close.nc(ncid)
info.free()

finalize()

## End(Not run)</code></pre>

<hr>
<h2 id='var.put.nc'>Write Data to a NetCDF Variable</h2><span id='topic+var.put.nc'></span>

<h3>Description</h3>

<p>Write the contents of a NetCDF variable.</p>


<h3>Usage</h3>

<pre><code class='language-R'>var.put.nc(ncfile, variable, data, start=NA, count=NA, na.mode=4, pack=FALSE,
  cache_bytes=NA, cache_slots=NA, cache_preemption=NA)</code></pre>


<h3>Arguments</h3>

<p>Arguments marked <code>"netcdf4"</code> are optional for datasets in that format and ignored for other formats.
</p>
<table role = "presentation">
<tr><td><code id="var.put.nc_+3A_ncfile">ncfile</code></td>
<td>
<p>Object of class <code>NetCDF</code> which points to the NetCDF dataset (as returned from <code><a href="#topic+open.nc">open.nc</a></code>).</p>
</td></tr>
<tr><td><code id="var.put.nc_+3A_variable">variable</code></td>
<td>
<p>ID or name of the NetCDF variable.</p>
</td></tr>
<tr><td><code id="var.put.nc_+3A_data">data</code></td>
<td>
<p>An R vector or array of data to be written to the NetCDF variable. Values are taken from <code>data</code> in the order of R vector elements, so that leftmost indices vary fastest over an array.</p>
</td></tr>
<tr><td><code id="var.put.nc_+3A_start">start</code></td>
<td>
<p>A vector of indices specifying the element where writing starts along each dimension of <code>variable</code>. Indices are numbered from 1 onwards, and the order of dimensions is shown by <code><a href="#topic+print.nc">print.nc</a></code> (array elements are stored sequentially with leftmost indices varying fastest). By default (<code>start=NA</code>), all dimensions of <code>variable</code> are written from the first element onwards. Otherwise, <code>start</code> must be a vector whose length is not less than the number of dimensions in <code>variable</code> (excess elements are ignored). Any <code>NA</code> values in vector <code>start</code> are set to 1.</p>
</td></tr>
<tr><td><code id="var.put.nc_+3A_count">count</code></td>
<td>
<p>A vector of integers specifying the number of values to write along each dimension of <code>variable</code>. The order of dimensions is the same as for <code>start</code>. By default (<code>count=NA</code>), <code>count</code> is set to <code>dim(data)</code> for an array or <code>length(data)</code> for a vector. Otherwise, <code>count</code> must be a vector whose length is not less than the number of dimensions in <code>variable</code> (excess elements are ignored). Any <code>NA</code> value in vector <code>count</code> indicates that the corresponding dimension should be written from the <code>start</code> index to the end of the dimension. Note that an unlimited dimension initially has zero length, and the dimension is extended by setting the corresponding element of <code>count</code> greater than the current length.</p>
</td></tr>
<tr><td><code id="var.put.nc_+3A_na.mode">na.mode</code></td>
<td>
<p><code>NA</code> values in <code>data</code> are converted to a missing value in the NetCDF dataset. The missing value is defined by attributes of the NetCDF <code>variable</code>, which are selected by the following modes:
</p>

<table>
<tr>
 <td style="text-align: left;">
    mode </td><td style="text-align: left;"> data type </td><td style="text-align: left;"> attribute(s) </td>
</tr>
<tr>
 <td style="text-align: left;">
    0 </td><td style="text-align: left;"> numeric </td><td style="text-align: left;"> <code>_FillValue</code>, then <code>missing_value</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
    1 </td><td style="text-align: left;"> numeric </td><td style="text-align: left;"> <code>_FillValue</code> only </td>
</tr>
<tr>
 <td style="text-align: left;">
    2 </td><td style="text-align: left;"> numeric </td><td style="text-align: left;"> <code>missing_value</code> only </td>
</tr>
<tr>
 <td style="text-align: left;">
    3 </td><td style="text-align: left;"> any </td><td style="text-align: left;"> no conversion </td>
</tr>
<tr>
 <td style="text-align: left;">
    4 </td><td style="text-align: left;"> numeric </td><td style="text-align: left;"> <code>valid_range</code> <code>valid_min</code>, <code>valid_max</code>, <code>_FillValue</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
    5 </td><td style="text-align: left;"> any </td><td style="text-align: left;"> same as mode 4 for numeric types; </td>
</tr>
<tr>
 <td style="text-align: left;">
      </td><td style="text-align: left;">     </td><td style="text-align: left;"> <code>_FillValue</code> for other types </td>
</tr>
<tr>
 <td style="text-align: left;">
  </td>
</tr>

</table>

<p>For explanation of attribute conventions used by mode 4, please see:
<a href="https://docs.unidata.ucar.edu/nug/current/attribute_conventions.html">https://docs.unidata.ucar.edu/nug/current/attribute_conventions.html</a>
</p>
</td></tr>
<tr><td><code id="var.put.nc_+3A_pack">pack</code></td>
<td>
<p>Variables are packed if <code>pack=TRUE</code> and the attributes <code>add_offset</code> and/or <code>scale_factor</code> are defined. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="var.put.nc_+3A_cache_bytes">cache_bytes</code></td>
<td>
<p>(<code>"netcdf4"</code>) Size of chunk cache in bytes. Value of <code>NA</code> (default) implies no change.</p>
</td></tr>
<tr><td><code id="var.put.nc_+3A_cache_slots">cache_slots</code></td>
<td>
<p>(<code>"netcdf4"</code>) Number of slots in chunk cache. Value of <code>NA</code> (default) implies no change.</p>
</td></tr>
<tr><td><code id="var.put.nc_+3A_cache_preemption">cache_preemption</code></td>
<td>
<p>(<code>"netcdf4"</code>) Value between 0 and 1 (inclusive) that biases the cache scheme towards eviction of chunks that have been fully read. Value of <code>NA</code> (default) implies no change.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function writes values to a NetCDF variable. Data values in R are automatically converted to the correct type of NetCDF variable.
</p>
<p>Text represented by R type <code>character</code> can be written to NetCDF types <code>NC_CHAR</code> and <code>NC_STRING</code>, and R type <code>raw</code> can be written to NetCDF type <code>NC_CHAR</code>. When writing to <code>NC_CHAR</code> variables, <code>character</code> variables have an implied dimension corresponding to the string length. This implied dimension must be defined explicitly as the fastest-varying dimension of the <code>NC_CHAR</code> variable, and it must be included as the first element of arguments <code>start</code> and <code>count</code> taken by this function.
</p>
<p>Due to the lack of native support for 64-bit integers in R, NetCDF types <code>NC_INT64</code> and <code>NC_UINT64</code> require special attention. This function accepts the usual R <code>integer</code> (signed 32-bit) and <code>numeric</code> (double precision) types, but to represent integers larger than about 53-bits without truncation, <code><a href="bit64.html#topic+bit64-package">integer64</a></code> vectors are also supported.
</p>
<p>NetCDF numeric variables cannot portably represent <code>NA</code> values from R. NetCDF does allow attributes to be defined for variables, and several conventions exist for attributes that define missing values and valid ranges. The convention in use can be specified by argument <code>na.mode</code>. Values of <code>NA</code> in argument <code>data</code> are converted to a missing or fill value before writing to the NetCDF variable. Unusual cases can be handled directly in user code by setting <code>na.mode=3</code>.
</p>
<p>Variables of user-defined types are supported, subject to conditions on the corresponding data structures in R. <code>"compound"</code> arrays must be stored in R as lists, with items named for the compound fields; items of base NetCDF data types are stored as R arrays, with leading dimensions from the field dimensions (if any) and trailing dimensions from the NetCDF variable. <code>"enum"</code> arrays are stored in R as factor arrays. <code>"opaque"</code> arrays are stored in R as raw (byte) arrays, with a leading dimension for bytes of the opaque type and trailing dimensions from the NetCDF variable. <code>"vlen"</code> arrays are stored in R as a list with dimensions of the NetCDF variable; items in the list may have different lengths; base NetCDF data types are stored as R vectors.
</p>
<p>To reduce the storage space required by a NetCDF file, numeric variables can be packed into types of lower precision. The packing operation involves subtraction of attribute <code>add_offset</code> before division by attribute <code>scale_factor</code>. This packing operation is performed automatically for variables defined with the attributes <code>add_offset</code> and/or <code>scale_factor</code> if argument <code>pack</code> is set to <code>TRUE</code>. If <code>pack</code> is <code>FALSE</code>, <code>data</code> values are assumed to be packed correctly and are written to the variable without alteration.
</p>
<p>Data in a NetCDF variable is represented as a multi-dimensional array. The number and length of dimensions is determined when the variable is created. The <code>start</code> and <code>count</code> arguments of this routine indicate where the writing starts and the number of values to write along each dimension.
</p>
<p>Awkwardness arises mainly from one thing: NetCDF data are written with the last dimension varying fastest, whereas R works opposite. Thus, the order of the dimensions according to the CDL conventions (e.g., time, latitude, longitude) is reversed in the R array (e.g., longitude, latitude, time).
</p>
<p>The arguments marked for <code>"netcdf4"</code> format refer to the chunk cache used for reading and writing variables. Default cache settings are defined by the NetCDF library, and they can be adjusted for each variable to improve performance in some applications.
</p>


<h3>Note</h3>

<p><code>NC_BYTE</code> is always interpreted as signed. For best performance, it is recommended that the definition of dimensions, variables and attributes is completed before variables are read or written.</p>


<h3>Author(s)</h3>

<p>Pavel Michna, Milton Woods</p>


<h3>References</h3>

<p><a href="https://www.unidata.ucar.edu/software/netcdf/">https://www.unidata.ucar.edu/software/netcdf/</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>##  Create a new NetCDF dataset and define two dimensions
file1 &lt;- tempfile("var.put_", fileext=".nc")
nc &lt;- create.nc(file1)

dim.def.nc(nc, "station", 5)
dim.def.nc(nc, "time", unlim=TRUE)
dim.def.nc(nc, "max_string_length", 32)

##  Create three variables, one as coordinate variable
var.def.nc(nc, "time", "NC_INT", "time")
var.def.nc(nc, "temperature", "NC_DOUBLE", c(0,1))
var.def.nc(nc, "name", "NC_CHAR", c("max_string_length", "station"))

##  Put some _FillValue attribute for temperature
att.put.nc(nc, "temperature", "_FillValue", "NC_DOUBLE", -99999.9)

##  Define variable values
mytime        &lt;- c(1:2)
mytemperature &lt;- c(1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, NA, NA, 9.9)
myname        &lt;- c("alfa", "bravo", "charlie", "delta", "echo")

dim(mytemperature) &lt;- c(5,2)

##  Put subsets of the data:
var.put.nc(nc, "time", mytime, start=2, count=1)
var.put.nc(nc, "temperature", mytemperature[3:4,2], start=c(3,2), count=c(2,1))
var.put.nc(nc, "name", myname[3:4], start=c(NA,3), count=c(NA,2))
sync.nc(nc)

##  Put all of the data:
var.put.nc(nc, "time", mytime)
var.put.nc(nc, "temperature", mytemperature)
var.put.nc(nc, "name", myname)

close.nc(nc)
unlink(file1)
</code></pre>

<hr>
<h2 id='var.rename.nc'>Rename a NetCDF Variable</h2><span id='topic+var.rename.nc'></span>

<h3>Description</h3>

<p>Rename a NetCDF variable.</p>


<h3>Usage</h3>

<pre><code class='language-R'>var.rename.nc(ncfile, variable, newname)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="var.rename.nc_+3A_ncfile">ncfile</code></td>
<td>
<p>Object of class <code>NetCDF</code> which points to the NetCDF dataset (as returned from <code><a href="#topic+open.nc">open.nc</a></code>).</p>
</td></tr>
<tr><td><code id="var.rename.nc_+3A_variable">variable</code></td>
<td>
<p>Either the ID or the name of the variable to be renamed.</p>
</td></tr>
<tr><td><code id="var.rename.nc_+3A_newname">newname</code></td>
<td>
<p>The new variable name.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function renames an existing variable in a NetCDF dataset open for writing. A variable cannot be renamed to have the same name as another variable.</p>


<h3>Author(s)</h3>

<p>Pavel Michna, Milton Woods</p>


<h3>References</h3>

<p><a href="https://www.unidata.ucar.edu/software/netcdf/">https://www.unidata.ucar.edu/software/netcdf/</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>##  Create a new NetCDF dataset and define two dimensions
file1 &lt;- tempfile("var.rename_", fileext=".nc")
nc &lt;- create.nc(file1)

dim.def.nc(nc, "station", 5)
dim.def.nc(nc, "time", unlim=TRUE)

##  Create two variables, one as coordinate variable
var.def.nc(nc, "time", "NC_INT", "time")
var.def.nc(nc, "temperature", "NC_DOUBLE", c(0,1))

##  Rename these variables
var.rename.nc(nc, 0, "mytime")
var.rename.nc(nc, "temperature", "mytemperature")

close.nc(nc)
unlink(file1)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
