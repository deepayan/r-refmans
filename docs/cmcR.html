<!DOCTYPE html><html><head><title>Help for package cmcR</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {cmcR}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#+25+26gt+3B+25'><p>Pipe operator</p></a></li>
<li><a href='#cmcPlot'><p>Plot Congruent Matching Cells results for a pair of cartridge cases.</p></a></li>
<li><a href='#comparison_alignedTargetCell'><p>Extract a matrix from the target region of the same dimension as the reference</p>
cell depending on the estimated translation calculated from comparison_fft_ccf</a></li>
<li><a href='#comparison_allTogether'><p>Performs all steps in the cell-based comparison procedure.</p></a></li>
<li><a href='#comparison_calcPropMissing'><p>Calculate the proportion of missing values in a breech face scan</p></a></li>
<li><a href='#comparison_cellDivision'><p>Split a reference scan into a grid of cells</p></a></li>
<li><a href='#comparison_cor'><p>Calculates correlation between a cell and a matrix of the same dimensions</p>
extracted from the cell's associated region.</a></li>
<li><a href='#comparison_fft_ccf'><p>Estimate translation alignment between a cell/region pair based on the</p>
Cross-Correlation Theorem.</a></li>
<li><a href='#comparison_getTargetRegions'><p>Extract regions from a target scan based on associated cells in reference scan</p></a></li>
<li><a href='#comparison_replaceMissing'><p>Replace missing values in a scan</p></a></li>
<li><a href='#comparison_standardizeHeights'><p>Standardize height values of a scan by centering/scaling by desired statistics</p>
and replacing missing values</a></li>
<li><a href='#decision_CMC'><p>Applies the decision rules of the original method of Song (2013) or the High</p>
CMC method of Tong et al. (2015)</a></li>
<li><a href='#decision_combineDirections'><p>Combine data frames containing CMC results from 2 comparison directions</p></a></li>
<li><a href='#decision_highCMC_cmcThetaDistrib'><p>Compute CMC-theta distribution for a set of comparison features</p></a></li>
<li><a href='#decision_highCMC_identifyHighCMCThetas'><p>Classify theta values in CMC-theta distribution as having &quot;High&quot; or &quot;Low&quot; CMC</p>
candidate counts</a></li>
<li><a href='#fadulData_processed'><p>Processed versions of the fadul1.1_raw and  fadul1.2_raw datasets using</p>
preProcess_* functions from the cmcR package</a></li>
<li><a href='#preProcess_crop'><p>Remove observations from the exterior of interior of a breech face scan</p></a></li>
<li><a href='#preProcess_erode'><p>Erode the interior or exterior of a cartridge case surface</p></a></li>
<li><a href='#preProcess_gaussFilter'><p>Performs a low, high, or bandpass Gaussian filter on a surface matrix with a</p>
particular cut-off wavelength.</a></li>
<li><a href='#preProcess_ransacLevel'><p>Finds plane of breechface marks using the RANSAC method</p></a></li>
<li><a href='#preProcess_removeFPCircle'><p>Given a surface matrix, estimates and filters any pixels within the estimated</p>
firing pin impression circle</a></li>
<li><a href='#preProcess_removeTrend'><p>Level a breech face impression surface matrix by a conditional statistic</p></a></li>
<li><a href='#x3pListPlot'><p>Plot a list of x3ps</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>An Implementation of the 'Congruent Matching Cells' Method</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.11</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Joe Zemmels &lt;jzemmels@iastate.edu&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>An open-source implementation of the 'Congruent Matching Cells' 
    method for cartridge case identification as proposed by Song (2013) <a href="https://tsapps.nist.gov/publication/get_pdf.cfm?pub_id=911193">https://tsapps.nist.gov/publication/get_pdf.cfm?pub_id=911193</a> as well 
    as an extension of the method proposed by Tong et al. (2015) &lt;<a href="https://doi.org/10.6028%2Fjres.120.008">doi:10.6028/jres.120.008</a>&gt;.
    Provides a wide range of pre, inter, and post-processing options when
    working with cartridge case scan data and their associated comparisons. See
    the cmcR package website for more details and examples.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.2</td>
</tr>
<tr>
<td>Imports:</td>
<td>magrittr, x3ptools, dplyr, ggplot2 (&ge; 3.3.5), imager, purrr,
zoo, stringr, stats, utils, scales, ggnewscale (&ge; 0.4.6),
quantreg, tibble, tidyr, rlang, patchwork, ggplotify</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, markdown, testthat, DT, magick, rgl, covr,
gridExtra, cowplot</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-12-10 01:35:41 UTC; jzemm</td>
</tr>
<tr>
<td>Author:</td>
<td>Joe Zemmels [aut, cre],
  Heike Hofmann [aut],
  Susan VanderPlas [aut]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-12-10 14:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='+25+26gt+3B+25'>Pipe operator</h2><span id='topic++25+3E+25'></span>

<h3>Description</h3>

<p>See <code>magrittr::<a href="magrittr.html#topic+pipe">%&gt;%</a></code> for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lhs %&gt;% rhs
</code></pre>

<hr>
<h2 id='cmcPlot'>Plot Congruent Matching Cells results for a pair of cartridge cases.</h2><span id='topic+cmcPlot'></span>

<h3>Description</h3>

<p>Plot Congruent Matching Cells results for a pair of cartridge cases.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cmcPlot(
  reference,
  target,
  cmcClassifs,
  type = "faceted",
  cmcCol = "originalMethod",
  corrCol = "pairwiseCompCor"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cmcPlot_+3A_reference">reference</code></td>
<td>
<p>the scan that is partitioned into a grid of cells</p>
</td></tr>
<tr><td><code id="cmcPlot_+3A_target">target</code></td>
<td>
<p>the scan to which each reference cell is compared during the
cell-based comparison procedure</p>
</td></tr>
<tr><td><code id="cmcPlot_+3A_cmcclassifs">cmcClassifs</code></td>
<td>
<p>a data frame containing columns cellHeightValues,
alignedTargetCell, cellIndex, theta, and user-defined cmcCol &amp; corrCol</p>
</td></tr>
<tr><td><code id="cmcPlot_+3A_type">type</code></td>
<td>
<p>the form of the returned plot object(s). Either &quot;faceted,&quot; meaning
the reference and target plot will be shown side-by-side or &quot;list&quot; meaning
each element of the plot (referece, target, and legend) will be returned
separately as elements of a list</p>
</td></tr>
<tr><td><code id="cmcPlot_+3A_cmccol">cmcCol</code></td>
<td>
<p>name of column containing CMC classifications as returned by the
decision_CMC function. Defaults to &quot;originalMethod&quot;</p>
</td></tr>
<tr><td><code id="cmcPlot_+3A_corrcol">corrCol</code></td>
<td>
<p>name of column containing correlation values for each cell.
Defaults to &quot;pairwiseCompCor,&quot; but &quot;fft_ccf&quot; is a common alternative.</p>
</td></tr>
</table>

<hr>
<h2 id='comparison_alignedTargetCell'>Extract a matrix from the target region of the same dimension as the reference
cell depending on the estimated translation calculated from comparison_fft_ccf</h2><span id='topic+comparison_alignedTargetCell'></span>

<h3>Description</h3>

<p>Extract a matrix from the target region of the same dimension as the reference
cell depending on the estimated translation calculated from comparison_fft_ccf
</p>


<h3>Usage</h3>

<pre><code class='language-R'>comparison_alignedTargetCell(
  cellHeightValues,
  regionHeightValues,
  target,
  theta,
  fft_ccf_df
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="comparison_alignedTargetCell_+3A_cellheightvalues">cellHeightValues</code></td>
<td>
<p>list/tibble column of x3p objects containing a
reference scan's cells (as returned by comparison_cellDivision)</p>
</td></tr>
<tr><td><code id="comparison_alignedTargetCell_+3A_regionheightvalues">regionHeightValues</code></td>
<td>
<p>list/tibble column of x3p objects containing a
target scan's regions (as returned by comparison_getTargetRegions)</p>
</td></tr>
<tr><td><code id="comparison_alignedTargetCell_+3A_target">target</code></td>
<td>
<p>the scan to which each cell in the partitioned scan was
compared.</p>
</td></tr>
<tr><td><code id="comparison_alignedTargetCell_+3A_theta">theta</code></td>
<td>
<p>the theta (rotation) value associated with each cellHeightValues,
regionHeightValues pairing</p>
</td></tr>
<tr><td><code id="comparison_alignedTargetCell_+3A_fft_ccf_df">fft_ccf_df</code></td>
<td>
<p>data frame/tibble column containing the data frame of (x,y)
and CCF values returned by comparison_fft_ccf</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of x3p objects containing surface matrices extracted from
regionHeightValues of the same dimension as the x3p objects in
cellHeightValues
</p>

<hr>
<h2 id='comparison_allTogether'>Performs all steps in the cell-based comparison procedure.</h2><span id='topic+comparison_allTogether'></span>

<h3>Description</h3>

<p>Performs all steps in the cell-based comparison procedure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>comparison_allTogether(
  reference,
  target,
  theta = 0,
  numCells = c(8, 8),
  maxMissingProp = 0.85,
  sideLengthMultiplier = 3,
  returnX3Ps = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="comparison_allTogether_+3A_reference">reference</code></td>
<td>
<p>an x3p object containing a breech face scan to be treated as
the &quot;reference scan&quot; partitioned into a grid of cells</p>
</td></tr>
<tr><td><code id="comparison_allTogether_+3A_target">target</code></td>
<td>
<p>an x3p object containing a breech face scan to be treated as the
&quot;target scan&quot; that the reference scan's cells are compared to</p>
</td></tr>
<tr><td><code id="comparison_allTogether_+3A_theta">theta</code></td>
<td>
<p>degrees that the target scan is to be rotated prior extracting
regions.</p>
</td></tr>
<tr><td><code id="comparison_allTogether_+3A_numcells">numCells</code></td>
<td>
<p>a vector of two numbers representing the number of cells along
the row and column dimensions into which the x3p is partitioned</p>
</td></tr>
<tr><td><code id="comparison_allTogether_+3A_maxmissingprop">maxMissingProp</code></td>
<td>
<p>maximum proportion of missing values allowed for each
cell/region.</p>
</td></tr>
<tr><td><code id="comparison_allTogether_+3A_sidelengthmultiplier">sideLengthMultiplier</code></td>
<td>
<p>ratio between the target region and reference cell
side lengths. For example, sideLengthMultiplier = 3 implies each region will
be 9 times larger than its paired reference cell.</p>
</td></tr>
<tr><td><code id="comparison_allTogether_+3A_returnx3ps">returnX3Ps</code></td>
<td>
<p>boolean to return the cellHeightValues and
alignedTargetCells for each cell index. Note that setting this argument to
TRUE significantly increases the size of the returned object.
</p>
<p>data(fadul1.1_processed,fadul1.2_processed)
</p>
<p>comparisonDF &lt;- comparison_allTogether(reference = fadul1.1_processed,
target = fadul1.2_processed)
</p>
<p>head(comparisonDF)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a tibble object containing cell indices and the x, y, FFT-based CCF,
and pairwise-complete correlation associated with the comparison between
each cell and its associated target scan region (after rotating the target
scan by theta degrees)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(fadul1.1_processed,fadul1.2_processed)

cellTibble &lt;- comparison_allTogether(reference = fadul1.1_processed,target = fadul1.2_processed)

head(cellTibble)

</code></pre>

<hr>
<h2 id='comparison_calcPropMissing'>Calculate the proportion of missing values in a breech face scan</h2><span id='topic+comparison_calcPropMissing'></span>

<h3>Description</h3>

<p>Calculate the proportion of missing values in a breech face scan
</p>


<h3>Usage</h3>

<pre><code class='language-R'>comparison_calcPropMissing(heightValues)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="comparison_calcPropMissing_+3A_heightvalues">heightValues</code></td>
<td>
<p>list/tibble column of x3p objects</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of the same length as the input containing the proportion of
missing values in each x3p object's breech face scan.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(fadul1.1_processed)

cellTibble &lt;- fadul1.1_processed %&gt;%
comparison_cellDivision(numCells = c(8,8)) %&gt;%
dplyr::mutate(cellPropMissing = comparison_calcPropMissing(heightValues = cellHeightValues))

head(cellTibble)

</code></pre>

<hr>
<h2 id='comparison_cellDivision'>Split a reference scan into a grid of cells</h2><span id='topic+comparison_cellDivision'></span>

<h3>Description</h3>

<p>Split a reference scan into a grid of cells
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="comparison_cellDivision_+3A_x3p">x3p</code></td>
<td>
<p>an x3p object containing a breech face scan</p>
</td></tr>
<tr><td><code id="comparison_cellDivision_+3A_numcells">numCells</code></td>
<td>
<p>a vector of two numbers representing the number of cells along
the row and column dimensions into which the x3p is partitioned</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble containing a prod(numCells) number of rows. Each row contains
a single cell's index of the form (row #, col #) and an x3p object
containing the breech face scan of that cell.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(fadul1.1_processed)

cellTibble &lt;- fadul1.1_processed %&gt;%
comparison_cellDivision(numCells = c(8,8))

head(cellTibble)

</code></pre>

<hr>
<h2 id='comparison_cor'>Calculates correlation between a cell and a matrix of the same dimensions
extracted from the cell's associated region.</h2><span id='topic+comparison_cor'></span>

<h3>Description</h3>

<p>Calculates correlation between a cell and a matrix of the same dimensions
extracted from the cell's associated region.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>comparison_cor(
  cellHeightValues,
  regionHeightValues,
  fft_ccf_df,
  use = "pairwise.complete.obs"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="comparison_cor_+3A_cellheightvalues">cellHeightValues</code></td>
<td>
<p>list/tibble column of x3p objects containing a
reference scan's cells (as returned by comparison_cellDivision)</p>
</td></tr>
<tr><td><code id="comparison_cor_+3A_regionheightvalues">regionHeightValues</code></td>
<td>
<p>list/tibble column of x3p objects containing a
target scan's regions (as returned by comparison_getTargetRegions)</p>
</td></tr>
<tr><td><code id="comparison_cor_+3A_fft_ccf_df">fft_ccf_df</code></td>
<td>
<p>data frame/tibble column containing the data frame of (x,y)
and CCF values returned by comparison_fft_ccf</p>
</td></tr>
<tr><td><code id="comparison_cor_+3A_use">use</code></td>
<td>
<p>argument for stats::cor</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of the same length as the input containing correlation values
at the estimated alignment between each reference cell and its associated
target region
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(fadul1.1_processed,fadul1.2_processed)

cellTibble &lt;- fadul1.1_processed %&gt;%
comparison_cellDivision(numCells = c(8,8)) %&gt;%
dplyr::mutate(regionHeightValues =
             comparison_getTargetRegions(cellHeightValues = cellHeightValues,
                                         target = fadul1.2_processed)) %&gt;%
dplyr::mutate(cellPropMissing =
           comparison_calcPropMissing(heightValues = cellHeightValues),
              regionPropMissing =
           comparison_calcPropMissing(heightValues = regionHeightValues)) %&gt;%
dplyr::filter(cellPropMissing &lt;= .85 &amp; regionPropMissing &lt;= .85) %&gt;%
dplyr::mutate(cellHeightValues =
        comparison_standardizeHeights(heightValues = cellHeightValues),
              regionHeightValues =
        comparison_standardizeHeights(heightValues = regionHeightValues)) %&gt;%
dplyr::mutate(cellHeightValues =
                  comparison_replaceMissing(heightValues = cellHeightValues),
              regionHeightValues =
            comparison_replaceMissing(heightValues = regionHeightValues)) %&gt;%
dplyr::mutate(fft_ccf_df = comparison_fft_ccf(cellHeightValues,
                                              regionHeightValues)) %&gt;%
dplyr::mutate(pairwiseCompCor = comparison_cor(cellHeightValues,
                                               regionHeightValues,
                                               fft_ccf_df))

head(cellTibble)

</code></pre>

<hr>
<h2 id='comparison_fft_ccf'>Estimate translation alignment between a cell/region pair based on the
Cross-Correlation Theorem.</h2><span id='topic+comparison_fft_ccf'></span>

<h3>Description</h3>

<p>Estimate translation alignment between a cell/region pair based on the
Cross-Correlation Theorem.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>comparison_fft_ccf(cellHeightValues, regionHeightValues)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="comparison_fft_ccf_+3A_cellheightvalues">cellHeightValues</code></td>
<td>
<p>list/tibble column of x3p objects containing a
reference scan's cells (as returned by comparison_cellDivision)</p>
</td></tr>
<tr><td><code id="comparison_fft_ccf_+3A_regionheightvalues">regionHeightValues</code></td>
<td>
<p>list/tibble column of x3p objects containing a
target scan's regions (as returned by comparison_getTargetRegions)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of the same length as the input containing data frames of the
translation (x,y) values at which each reference cell is estimated to align
in its associated target region and the CCF value at this alignment.
</p>
<p>a data frame containing the translation (x,y) at which the CCF was
maximized in aligning a target scan region to its associated reference scan
cell.
</p>


<h3>Note</h3>

<p>The FFT is not defined for matrices containing missing values. The
missing values in the cell and region need to be replaced before using this
function. See the <a href="#topic+comparison_replaceMissing">comparison_replaceMissing</a> function to replace
missing values after standardization.
</p>


<h3>See Also</h3>

<p><a href="https://mathworld.wolfram.com/Cross-CorrelationTheorem.html">https://mathworld.wolfram.com/Cross-CorrelationTheorem.html</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(fadul1.1_processed,fadul1.2_processed)

cellTibble &lt;- fadul1.1_processed %&gt;%
comparison_cellDivision(numCells = c(8,8)) %&gt;%
dplyr::mutate(regionHeightValues =
             comparison_getTargetRegions(cellHeightValues = cellHeightValues,
                                         target = fadul1.2_processed)) %&gt;%
dplyr::mutate(cellPropMissing =
           comparison_calcPropMissing(heightValues = cellHeightValues),
              regionPropMissing =
           comparison_calcPropMissing(heightValues = regionHeightValues)) %&gt;%
dplyr::filter(cellPropMissing &lt;= .85 &amp; regionPropMissing &lt;= .85) %&gt;%
dplyr::mutate(cellHeightValues =
        comparison_standardizeHeights(heightValues = cellHeightValues),
             regionHeightValues =
        comparison_standardizeHeights(heightValues = regionHeightValues)) %&gt;%
dplyr::mutate(cellHeightValues =
                  comparison_replaceMissing(heightValues = cellHeightValues),
             regionHeightValues =
            comparison_replaceMissing(heightValues = regionHeightValues)) %&gt;%
dplyr::mutate(fft_ccf_df = comparison_fft_ccf(cellHeightValues,
                                             regionHeightValues))

cellTibble %&gt;%
tidyr::unnest(cols = fft_ccf_df) %&gt;%
head()

</code></pre>

<hr>
<h2 id='comparison_getTargetRegions'>Extract regions from a target scan based on associated cells in reference scan</h2><span id='topic+comparison_getTargetRegions'></span>

<h3>Description</h3>

<p>Extract regions from a target scan based on associated cells in reference scan
</p>


<h3>Usage</h3>

<pre><code class='language-R'>comparison_getTargetRegions(
  cellHeightValues,
  target,
  theta = 0,
  sideLengthMultiplier = 3,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="comparison_getTargetRegions_+3A_cellheightvalues">cellHeightValues</code></td>
<td>
<p>list/tibble column of x3p objects containing a
reference scan's cells (as returned by comparison_cellDivision)</p>
</td></tr>
<tr><td><code id="comparison_getTargetRegions_+3A_target">target</code></td>
<td>
<p>x3p object containing a breech face scan to be compared to the
reference cell.</p>
</td></tr>
<tr><td><code id="comparison_getTargetRegions_+3A_theta">theta</code></td>
<td>
<p>degrees that the target scan is to be rotated prior extracting
regions.</p>
</td></tr>
<tr><td><code id="comparison_getTargetRegions_+3A_sidelengthmultiplier">sideLengthMultiplier</code></td>
<td>
<p>ratio between the target region and reference cell
side lengths. For example, sideLengthMultiplier = 3 implies each region will
be 9 times larger than its paired reference cell.</p>
</td></tr>
<tr><td><code id="comparison_getTargetRegions_+3A_...">...</code></td>
<td>
<p>internal usage</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of the same length as the input containing x3p objects from the
target scan.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(fadul1.1_processed,fadul1.2_processed)

cellTibble &lt;- fadul1.1_processed %&gt;%
comparison_cellDivision(numCells = c(8,8)) %&gt;%
dplyr::mutate(regionHeightValues = comparison_getTargetRegions(cellHeightValues = cellHeightValues,
                                                               target = fadul1.2_processed)) %&gt;%
dplyr::mutate(cellPropMissing = comparison_calcPropMissing(heightValues = cellHeightValues),
              regionPropMissing = comparison_calcPropMissing(heightValues = regionHeightValues)) %&gt;%
dplyr::filter(cellPropMissing &lt;= .85 &amp; regionPropMissing &lt;= .85)

head(cellTibble)

</code></pre>

<hr>
<h2 id='comparison_replaceMissing'>Replace missing values in a scan</h2><span id='topic+comparison_replaceMissing'></span>

<h3>Description</h3>

<p>Replace missing values in a scan
</p>


<h3>Usage</h3>

<pre><code class='language-R'>comparison_replaceMissing(heightValues, replacement = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="comparison_replaceMissing_+3A_heightvalues">heightValues</code></td>
<td>
<p>list/tibble column of x3p objects</p>
</td></tr>
<tr><td><code id="comparison_replaceMissing_+3A_replacement">replacement</code></td>
<td>
<p>value to replace NAs</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of the same length as the input containing x3p objects for
which NA values have been replaced.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(fadul1.1_processed,fadul1.2_processed)

cellTibble &lt;- fadul1.1_processed %&gt;%
comparison_cellDivision(numCells = c(8,8)) %&gt;%
dplyr::mutate(regionHeightValues =
             comparison_getTargetRegions(cellHeightValues = cellHeightValues,
                                         target = fadul1.2_processed)) %&gt;%
dplyr::mutate(cellPropMissing =
                 comparison_calcPropMissing(heightValues = cellHeightValues),
              regionPropMissing =
           comparison_calcPropMissing(heightValues = regionHeightValues)) %&gt;%
dplyr::filter(cellPropMissing &lt;= .85 &amp; regionPropMissing &lt;= .85) %&gt;%
dplyr::mutate(cellHeightValues =
              comparison_standardizeHeights(heightValues = cellHeightValues),
             regionHeightValues =
        comparison_standardizeHeights(heightValues = regionHeightValues)) %&gt;%
dplyr::mutate(cellHeightValues =
                  comparison_replaceMissing(heightValues = cellHeightValues),
             regionHeightValues =
                comparison_replaceMissing(heightValues = regionHeightValues))

head(cellTibble)

</code></pre>

<hr>
<h2 id='comparison_standardizeHeights'>Standardize height values of a scan by centering/scaling by desired statistics
and replacing missing values</h2><span id='topic+comparison_standardizeHeights'></span>

<h3>Description</h3>

<p>Standardize height values of a scan by centering/scaling by desired statistics
and replacing missing values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>comparison_standardizeHeights(
  heightValues,
  withRespectTo = "individualCell",
  centerBy = mean,
  scaleBy = sd
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="comparison_standardizeHeights_+3A_heightvalues">heightValues</code></td>
<td>
<p>list/tibble column of x3p objects</p>
</td></tr>
<tr><td><code id="comparison_standardizeHeights_+3A_withrespectto">withRespectTo</code></td>
<td>
<p>currently ignored</p>
</td></tr>
<tr><td><code id="comparison_standardizeHeights_+3A_centerby">centerBy</code></td>
<td>
<p>statistic by which to center (i.e., subtract from) the height
values</p>
</td></tr>
<tr><td><code id="comparison_standardizeHeights_+3A_scaleby">scaleBy</code></td>
<td>
<p>statistic by which to scale (i.e., divide) the height values</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of the same length as the input containing x3p objects with
standardized surface matrices
</p>


<h3>Note</h3>

<p>this function adds information to the metainformation of the x3p scan it
is given that is required for calculating, for example, the
pairwise-complete correlation using the comparison_cor function.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(fadul1.1_processed,fadul1.2_processed)

cellTibble &lt;- fadul1.1_processed %&gt;%
comparison_cellDivision(numCells = c(8,8)) %&gt;%
dplyr::mutate(regionHeightValues = comparison_getTargetRegions(cellHeightValues = cellHeightValues,
                                                               target = fadul1.2_processed)) %&gt;%
dplyr::mutate(cellPropMissing = comparison_calcPropMissing(heightValues = cellHeightValues),
              regionPropMissing = comparison_calcPropMissing(heightValues = regionHeightValues)) %&gt;%
dplyr::filter(cellPropMissing &lt;= .85 &amp; regionPropMissing &lt;= .85) %&gt;%
dplyr::mutate(cellHeightValues = comparison_standardizeHeights(heightValues = cellHeightValues),
             regionHeightValues = comparison_standardizeHeights(heightValues = regionHeightValues))

head(cellTibble)

</code></pre>

<hr>
<h2 id='decision_CMC'>Applies the decision rules of the original method of Song (2013) or the High
CMC method of Tong et al. (2015)</h2><span id='topic+decision_CMC'></span>

<h3>Description</h3>

<p>Applies the decision rules of the original method of Song (2013) or the High
CMC method of Tong et al. (2015)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>decision_CMC(
  cellIndex,
  x,
  y,
  theta,
  corr,
  xThresh = 20,
  yThresh = xThresh,
  thetaThresh = 6,
  corrThresh = 0.5,
  tau = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="decision_CMC_+3A_cellindex">cellIndex</code></td>
<td>
<p>vector/tibble column containing cell indices corresponding to
a reference cell</p>
</td></tr>
<tr><td><code id="decision_CMC_+3A_x">x</code></td>
<td>
<p>vector/tibble column containing x horizontal translation values</p>
</td></tr>
<tr><td><code id="decision_CMC_+3A_y">y</code></td>
<td>
<p>vector/tibble column containing y vertical translation values</p>
</td></tr>
<tr><td><code id="decision_CMC_+3A_theta">theta</code></td>
<td>
<p>vector/tibble column containing theta rotation values</p>
</td></tr>
<tr><td><code id="decision_CMC_+3A_corr">corr</code></td>
<td>
<p>vector/tibble column containing correlation similarity scores
between a reference cell and its associated target region</p>
</td></tr>
<tr><td><code id="decision_CMC_+3A_xthresh">xThresh</code></td>
<td>
<p>used to classify particular x values &quot;congruent&quot; (conditional
on a particular theta value) if they are within xThresh of the
theta-specific median x value</p>
</td></tr>
<tr><td><code id="decision_CMC_+3A_ythresh">yThresh</code></td>
<td>
<p>used to classify particular y values &quot;congruent&quot; (conditional
on a particular theta value) if they are within yThresh of the
theta-specific median y value</p>
</td></tr>
<tr><td><code id="decision_CMC_+3A_thetathresh">thetaThresh</code></td>
<td>
<p>(original method of Song (2013)) used to classify
particular theta values &quot;congruent&quot; if they are within thetaThresh of the
median theta value. (High CMC) defines how wide a High CMC mode is allowed
to be in the CMC-theta distribution before it's considered too diffuse</p>
</td></tr>
<tr><td><code id="decision_CMC_+3A_corrthresh">corrThresh</code></td>
<td>
<p>to classify particular correlation values &quot;congruent&quot;
(conditional on a particular theta value) if they are at least corrThresh</p>
</td></tr>
<tr><td><code id="decision_CMC_+3A_tau">tau</code></td>
<td>
<p>(optional) parameter required to apply the High CMC method of Tong
et al. (2015). If not given, then the decision rule of the original method
of Song (2013) is applied. This number is subtracted from the maximum CMC
count achieved in the CMC-theta distribution. Theta values with CMC counts
above this value are considered to have &quot;high&quot; CMC counts.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of the same length as the input containing the CMC
classification under one of the two decision rules.
</p>


<h3>See Also</h3>

<p><a href="https://tsapps.nist.gov/publication/get_pdf.cfm?pub_id=911193">https://tsapps.nist.gov/publication/get_pdf.cfm?pub_id=911193</a>
</p>
<p><a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4730689/pdf/jres.120.008.pdf">https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4730689/pdf/jres.120.008.pdf</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(fadul1.1_processed,fadul1.2_processed)

comparisonDF &lt;- purrr::map_dfr(seq(-30,30,by = 3),
                              ~ comparison_allTogether(fadul1.1_processed,
                                                       fadul1.2_processed,
                                                       theta = .))


comparisonDF &lt;- comparisonDF %&gt;%
dplyr::mutate(originalMethodClassif = decision_CMC(cellIndex = cellIndex,
                                                   x = x,
                                                   y = y,
                                                   theta = theta,
                                                   corr = pairwiseCompCor),
              highCMCClassif = decision_CMC(cellIndex = cellIndex,
                                           x = x,
                                           y = y,
                                           theta = theta,
                                           corr = pairwiseCompCor,
                                           tau = 1))


comparisonDF %&gt;%
dplyr::filter(originalMethodClassif == "CMC" | highCMCClassif == "CMC")

## End(Not run)
</code></pre>

<hr>
<h2 id='decision_combineDirections'>Combine data frames containing CMC results from 2 comparison directions</h2><span id='topic+decision_combineDirections'></span>

<h3>Description</h3>

<p>Combines CMC results from two comparison directions of a single
cartridge case pair (i.e., where each cartridge case scan has been treated
as both the reference and target scan). This function assumes that the CMC
results are data frames withcolumns called &quot;originalMethodClassif&quot; and
&quot;highCMCClassif&quot; containing CMCs identified under the original method of
Song (2013) and the High CMC method of Tong et al. (2015) (see example).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>decision_combineDirections(
  reference_v_target_CMCs,
  target_v_reference_CMCs,
  corColName = "pairwiseCompCor",
  missingThetaDecision = "fail",
  compareThetas = TRUE,
  thetaThresh = 6
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="decision_combineDirections_+3A_reference_v_target_cmcs">reference_v_target_CMCs</code></td>
<td>
<p>CMCs for the comparison between the reference
scan and the target scan.</p>
</td></tr>
<tr><td><code id="decision_combineDirections_+3A_target_v_reference_cmcs">target_v_reference_CMCs</code></td>
<td>
<p>(optional) CMCs for the comparison between the
target scan and the reference scan. If this is missing, then only the
original method CMCs will be plotted</p>
</td></tr>
<tr><td><code id="decision_combineDirections_+3A_corcolname">corColName</code></td>
<td>
<p>name of correlation similarity score column used to identify
the CMCs in the two comparison_*_df data frames (e.g., pairwiseCompCor)</p>
</td></tr>
<tr><td><code id="decision_combineDirections_+3A_missingthetadecision">missingThetaDecision</code></td>
<td>
<p>dictates how function should handle situations in
which one direction passes the high CMC criterion while another direction
does not. &quot;dismiss&quot;: only counts the initial CMCs in failed direction and
high CMCs in successful direction. &quot;fail&quot;: only counts the initial CMCs in
either direction and returns the minimum of these two numbers.</p>
</td></tr>
<tr><td><code id="decision_combineDirections_+3A_comparethetas">compareThetas</code></td>
<td>
<p>dictates if the consensus theta values determined under
the initially proposed method should be compared to the consensus theta
values determined under the High CMC method. In particular, determines for
each direction whether the consensus theta values determined under the two
methods are within theta_thresh of each other. It is often the case that
non-matching cartridge cases, even if they pass the High CMC criterion, will
have differing consensus theta values under the two methods. If this isn't
taken into account, non-matches tend to be assigned a lot of false positive
CMCs under the High CMC method.</p>
</td></tr>
<tr><td><code id="decision_combineDirections_+3A_thetathresh">thetaThresh</code></td>
<td>
<p>(original method of Song (2013)) used to classify
particular theta values &quot;congruent&quot; if they are within thetaThresh of the
median theta value. (High CMC) defines how wide a High CMC mode is allowed
to be in the CMC-theta distribution before it's considered too diffuse. This
is also used in this function to determine whether the estimated alignment
theta values from the two comparison directions are &quot;approximately&quot; opposite
(i.e., within thetaThresh of each other in absolute value), which they
should be if the cartridge case pair is a known match.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of 2 elements: (1) the CMCs identified under the original
method of Song (2013) for both comparison directions since Song (2013) does
not indicate whether/how results are combined and (2) the combined CMC
results under the High CMC method.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(fadul1.1_processed,fadul1.2_processed)

comparisonDF_1to2 &lt;- purrr::map_dfr(seq(-30,30,by = 3),
                                   ~ comparison_allTogether(fadul1.1_processed,
                                                       fadul1.2_processed,
                                                       theta = .))
comparisonDF_2to1 &lt;- purrr::map_dfr(seq(-30,30,by = 3),
                                   ~ comparison_allTogether(fadul1.2_processed,
                                                       fadul1.1_processed,
                                                       theta = .))

comparisonDF_1to2 &lt;- comparisonDF_1to2 %&gt;%
dplyr::mutate(originalMethodClassif = decision_CMC(cellIndex = cellIndex,
                                                   x = x,
                                                   y = y,
                                                   theta = theta,
                                                   corr = pairwiseCompCor),
              highCMCClassif = decision_CMC(cellIndex = cellIndex,
                                           x = x,
                                           y = y,
                                           theta = theta,
                                           corr = pairwiseCompCor,
                                           tau = 1))


comparisonDF_2to1 &lt;- comparisonDF_2to1 %&gt;%
dplyr::mutate(originalMethodClassif = decision_CMC(cellIndex = cellIndex,
                                                   x = x,
                                                   y = y,
                                                   theta = theta,
                                                   corr = pairwiseCompCor),
              highCMCClassif = decision_CMC(cellIndex = cellIndex,
                                           x = x,
                                           y = y,
                                           theta = theta,
                                           corr = pairwiseCompCor,
                                           tau = 1))

decision_combineDirections(comparisonDF_1to2,comparisonDF_2to1)

## End(Not run)
</code></pre>

<hr>
<h2 id='decision_highCMC_cmcThetaDistrib'>Compute CMC-theta distribution for a set of comparison features</h2><span id='topic+decision_highCMC_cmcThetaDistrib'></span>

<h3>Description</h3>

<p>Compute CMC-theta distribution for a set of comparison features
</p>


<h3>Usage</h3>

<pre><code class='language-R'>decision_highCMC_cmcThetaDistrib(
  cellIndex,
  x,
  y,
  theta,
  corr,
  xThresh = 20,
  yThresh = xThresh,
  corrThresh = 0.5
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="decision_highCMC_cmcThetaDistrib_+3A_cellindex">cellIndex</code></td>
<td>
<p>vector/tibble column containing cell indices corresponding to
a reference cell</p>
</td></tr>
<tr><td><code id="decision_highCMC_cmcThetaDistrib_+3A_x">x</code></td>
<td>
<p>vector/tibble column containing x horizontal translation values</p>
</td></tr>
<tr><td><code id="decision_highCMC_cmcThetaDistrib_+3A_y">y</code></td>
<td>
<p>vector/tibble column containing y vertical translation values</p>
</td></tr>
<tr><td><code id="decision_highCMC_cmcThetaDistrib_+3A_theta">theta</code></td>
<td>
<p>vector/tibble column containing theta rotation values</p>
</td></tr>
<tr><td><code id="decision_highCMC_cmcThetaDistrib_+3A_corr">corr</code></td>
<td>
<p>vector/tibble column containing correlation similarity scores
between a reference cell and its associated target region</p>
</td></tr>
<tr><td><code id="decision_highCMC_cmcThetaDistrib_+3A_xthresh">xThresh</code></td>
<td>
<p>used to classify particular x values &quot;congruent&quot; (conditional
on a particular theta value) if they are within xThresh of the
theta-specific median x value</p>
</td></tr>
<tr><td><code id="decision_highCMC_cmcThetaDistrib_+3A_ythresh">yThresh</code></td>
<td>
<p>used to classify particular y values &quot;congruent&quot; (conditional
on a particular theta value) if they are within yThresh of the
theta-specific median y value</p>
</td></tr>
<tr><td><code id="decision_highCMC_cmcThetaDistrib_+3A_corrthresh">corrThresh</code></td>
<td>
<p>to classify particular correlation values &quot;congruent&quot;
(conditional on a particular theta value) if they are at least corrThresh</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of the same length as the input containing a &quot;CMC Candidate&quot;
or &quot;Non-CMC Candidate&quot; classification based on whether the particular
cellIndex has congruent x,y, and theta features.
</p>


<h3>Note</h3>

<p>This function is a helper internally called in the decision_CMC
function. It is exported to be used as a diagnostic tool for the High CMC
method
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(fadul1.1_processed,fadul1.2_processed)

comparisonDF &lt;- purrr::map_dfr(seq(-30,30,by = 3),
                              ~ comparison_allTogether(fadul1.1_processed,
                                                       fadul1.2_processed,
                                                       theta = .))

comparisonDF &lt;- comparisonDF %&gt;%
dplyr::mutate(cmcThetaDistribClassif = decision_highCMC_cmcThetaDistrib(cellIndex = cellIndex,
                                                                 x = x,
                                                                 y = y,
                                                                 theta = theta,
                                                                 corr = pairwiseCompCor))

comparisonDF %&gt;%
dplyr::filter(cmcThetaDistribClassif == "CMC Candidate") %&gt;%
ggplot2::ggplot(ggplot2::aes(x = theta)) +
ggplot2::geom_bar(stat = "count")

## End(Not run)
</code></pre>

<hr>
<h2 id='decision_highCMC_identifyHighCMCThetas'>Classify theta values in CMC-theta distribution as having &quot;High&quot; or &quot;Low&quot; CMC
candidate counts</h2><span id='topic+decision_highCMC_identifyHighCMCThetas'></span>

<h3>Description</h3>

<p>Classify theta values in CMC-theta distribution as having &quot;High&quot; or &quot;Low&quot; CMC
candidate counts
</p>


<h3>Usage</h3>

<pre><code class='language-R'>decision_highCMC_identifyHighCMCThetas(cmcThetaDistrib, tau = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="decision_highCMC_identifyHighCMCThetas_+3A_cmcthetadistrib">cmcThetaDistrib</code></td>
<td>
<p>output of the decision_highCMC_cmcThetaDistrib function</p>
</td></tr>
<tr><td><code id="decision_highCMC_identifyHighCMCThetas_+3A_tau">tau</code></td>
<td>
<p>constant used to define a &quot;high&quot; CMC count. This number is
subtracted from the maximum CMC count achieved in the CMC-theta
distribution. Theta values with CMC counts above this value are considered
to have &quot;high&quot; CMC counts.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of the same length as the input containing &quot;High&quot; or &quot;Low&quot;
classification based on whether the associated theta value has a High CMC
Candidate count.
</p>


<h3>Note</h3>

<p>This function is a helper internally called in the decision_CMC
function. It is exported to be used as a diagnostic tool for the High CMC
method
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(fadul1.1_processed,fadul1.2_processed)

comparisonDF &lt;- purrr::map_dfr(seq(-30,30,by = 3),
                              ~ comparison_allTogether(fadul1.1_processed,
                                                       fadul1.2_processed,
                                                       theta = .))

highCMCthetas &lt;- comparisonDF %&gt;%
dplyr::mutate(cmcThetaDistribClassif = decision_highCMC_cmcThetaDistrib(cellIndex = cellIndex,
                                                                 x = x,
                                                                 y = y,
                                                                 theta = theta,
                                                                 corr = pairwiseCompCor)) %&gt;%
decision_highCMC_identifyHighCMCThetas(tau = 1)


highCMCthetas %&gt;%
dplyr::filter(cmcThetaDistribClassif == "CMC Candidate") %&gt;%
ggplot2::ggplot(ggplot2::aes(x = theta,fill = thetaCMCIdentif)) +
ggplot2::geom_bar(stat = "count")

## End(Not run)
</code></pre>

<hr>
<h2 id='fadulData_processed'>Processed versions of the fadul1.1_raw and  fadul1.2_raw datasets using
preProcess_* functions from the cmcR package</h2><span id='topic+fadulData_processed'></span><span id='topic+fadul1.1_processed'></span><span id='topic+fadul1.2_processed'></span>

<h3>Description</h3>

<p>&quot;Fadul 1-1&quot; and &quot;Fadul 1-2&quot; cartridge cases from Fadul et al. (2011). The
scans have been downsampled by a factor of 8 and processed using functions
from the cmcR package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fadul1.1_processed

fadul1.2_processed
</code></pre>


<h3>Format</h3>

<p>An x3p object containing a surface matrix and metainformation
concerning the conditions under which the scan was taken </p>

<dl>
<dt>header.info</dt><dd><p>size and resolution of scan</p>
</dd>
<dt>surface.matrix</dt><dd><p>spatially-ordered matrix of elements representing the
height values of the processed cartridge case surface at particular
locations</p>
</dd>
<dt>feature.info</dt><dd><p>provides structure for storing surface data</p>
</dd>
<dt>general.info</dt><dd><p>information concerning the author of the scan and
capturing device</p>
</dd>
<dt>matrix.info</dt><dd><p>provides link to surface measurements in binary format</p>
</dd>
</dl>

<p>An object of class <code>x3p</code> of length 5.
</p>


<h3>Source</h3>

<p><a href="https://tsapps.nist.gov/NRBTD/Studies/CartridgeMeasurement/Details/2d9cc51f-6f66-40a0-973a-a9292dbee36d">https://tsapps.nist.gov/NRBTD/Studies/CartridgeMeasurement/Details/2d9cc51f-6f66-40a0-973a-a9292dbee36d</a>
</p>


<h3>See Also</h3>

<p>T. Fadul, G. Hernandez, S. Stoiloff, and G. Sneh. An Empirical Study
to Improve the Scientific Foundation of Forensic Firearm and Tool Mark
Identification Utilizing 10 Consecutively Manufactured Slides, 2011.
</p>
<p><a href="https://github.com/heike/x3ptools">https://github.com/heike/x3ptools</a>
</p>

<hr>
<h2 id='preProcess_crop'>Remove observations from the exterior of interior of a breech face scan</h2><span id='topic+preProcess_crop'></span>

<h3>Description</h3>

<p>Remove observations from the exterior of interior of a breech face scan
</p>


<h3>Usage</h3>

<pre><code class='language-R'>preProcess_crop(x3p, region = "exterior", offset = 0, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="preProcess_crop_+3A_x3p">x3p</code></td>
<td>
<p>an x3p object containing the surface matrix of a cartridge case
scan</p>
</td></tr>
<tr><td><code id="preProcess_crop_+3A_region">region</code></td>
<td>
<p>dictates whether the observations on the &quot;exterior&quot; or
&quot;interior&quot; of the scan are removed</p>
</td></tr>
<tr><td><code id="preProcess_crop_+3A_offset">offset</code></td>
<td>
<p>an integer (positive or negative) value to add to the estimated
radius of the associated region</p>
</td></tr>
<tr><td><code id="preProcess_crop_+3A_...">...</code></td>
<td>
<p>internal usage</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An x3p object containing the surface matrix of a breech face
impression scan where the observations on the exterior/interior of the
breech face scan surface.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#Process fadul1.1 "from scratch" (takes &gt; 5 seconds to run)
## Not run: 
nbtrd_link &lt;- "https://tsapps.nist.gov/NRBTD/Studies/CartridgeMeasurement/"
fadul1.1_link &lt;- "DownloadMeasurement/2d9cc51f-6f66-40a0-973a-a9292dbee36d"

fadul1.1 &lt;- x3ptools::read_x3p(paste0(nbtrd_link,fadul1.1_link))

fadul1.1_extCropped &lt;- preProcess_crop(x3p = fadul1.1,
                                       radiusOffset = -30,
                                       region = "exterior")

fadul1.1_extIntCropped &lt;- preProcess_crop(x3p = fadul1.1_extCropped,
                                          radiusOffset = 200,
                                          region = "interior")

x3pListPlot(list("Original" = fadul1.1,
                 "Exterior Cropped" = fadul1.1_extCropped,
                 "Exterior &amp; Interior Cropped" = fadul1.1_extIntCropped ))

## End(Not run)
</code></pre>

<hr>
<h2 id='preProcess_erode'>Erode the interior or exterior of a cartridge case surface</h2><span id='topic+preProcess_erode'></span>

<h3>Description</h3>

<p>performs the morphological operations and dilation to &quot;shave&quot;
observations off of the interior or exterior of a cartridge case surface
matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>preProcess_erode(x3p, region, morphRadius = 50)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="preProcess_erode_+3A_x3p">x3p</code></td>
<td>
<p>an x3p object</p>
</td></tr>
<tr><td><code id="preProcess_erode_+3A_region">region</code></td>
<td>
<p>either &quot;interior,&quot; meaning the observations around the firing
pin hole will be eroded, or &quot;exterior,&quot; meaning the observations around the
outer edge of the cartridge case primer will be eroded</p>
</td></tr>
<tr><td><code id="preProcess_erode_+3A_morphradius">morphRadius</code></td>
<td>
<p>controls the amount of erosion. Larger values correspond to
a larger (circular) morphological mask leading to more erosion.</p>
</td></tr>
</table>

<hr>
<h2 id='preProcess_gaussFilter'>Performs a low, high, or bandpass Gaussian filter on a surface matrix with a
particular cut-off wavelength.</h2><span id='topic+preProcess_gaussFilter'></span>

<h3>Description</h3>

<p>Performs a low, high, or bandpass Gaussian filter on a surface matrix with a
particular cut-off wavelength.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>preProcess_gaussFilter(x3p, wavelength = c(16, 500), filtertype = "bp")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="preProcess_gaussFilter_+3A_x3p">x3p</code></td>
<td>
<p>an x3p object containing a surface matrix</p>
</td></tr>
<tr><td><code id="preProcess_gaussFilter_+3A_wavelength">wavelength</code></td>
<td>
<p>cut-off wavelength</p>
</td></tr>
<tr><td><code id="preProcess_gaussFilter_+3A_filtertype">filtertype</code></td>
<td>
<p>specifies whether a low pass, &quot;lp&quot;, high pass, &quot;hp&quot;, or
bandpass, &quot;bp&quot; filter is to be used. Note that setting filterype = &quot;bp&quot;
means that wavelength should be a vector of two numbers. In this case, the
max of these two number will be used for the high pass filter and the min
for the low pass filter.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An x3p object containing the Gaussian-filtered surface matrix.
</p>


<h3>See Also</h3>

<p>https://www.mathworks.com/matlabcentral/fileexchange/61003-filt2-2d-geospatial-data-filter?focused=7181587&amp;tab=example
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(fadul1.1_processed)

#Applying the function to fadul1.1_processed (note that this scan has already
#  been Gaussian filtered)
cmcR::preProcess_gaussFilter(fadul1.1_processed)

#As a part of the recommended preprocessing pipeline (take &gt; 5 sec to run):
## Not run: 
nbtrd_link &lt;- "https://tsapps.nist.gov/NRBTD/Studies/CartridgeMeasurement/"
fadul1.1_link &lt;- "DownloadMeasurement/2d9cc51f-6f66-40a0-973a-a9292dbee36d"

fadul1.1 &lt;- x3ptools::read_x3p(paste0(nbtrd_link,fadul1.1_link))
fadul1.1_extCropped &lt;- preProcess_crop(x3p = fadul1.1,
                                       region = "exterior",
                                       radiusOffset = -30)

fadul1.1_intCroped &lt;- preProcess_crop(x3p = fadul1.1_extCropped,
                                      region = "interior",
                                      radiusOffset = 200)

fadul1.1_leveled &lt;- preProcess_removeTrend(x3p = fadul1.1_intCroped,
                                           statistic = "quantile",
                                           tau = .5,
                                           method = "fn")
fadul1.1_filtered &lt;- preProcess_gaussFilter(x3p = fadul1.1_leveled,
                                            wavelength = c(16,500),
                                            filtertype = "bp")

x3pListPlot(list("Original" = fadul1.1,
                 "Ext. &amp; Int. Cropped" = fadul1.1_intCroped,
                 "Cropped and Leveled" = fadul1.1_leveled,
                 "Filtered" = fadul1.1_filtered),type = "list")

## End(Not run)

</code></pre>

<hr>
<h2 id='preProcess_ransacLevel'>Finds plane of breechface marks using the RANSAC method</h2><span id='topic+preProcess_ransacLevel'></span>

<h3>Description</h3>

<p>Finds plane of breechface marks using the RANSAC method
</p>


<h3>Usage</h3>

<pre><code class='language-R'>preProcess_ransacLevel(
  x3p,
  ransacInlierThresh = 1e-06,
  ransacFinalSelectThresh = 2e-05,
  iters = 300,
  returnResiduals = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="preProcess_ransacLevel_+3A_x3p">x3p</code></td>
<td>
<p>an x3p object containing a surface matrix</p>
</td></tr>
<tr><td><code id="preProcess_ransacLevel_+3A_ransacinlierthresh">ransacInlierThresh</code></td>
<td>
<p>threshold to declare an observed value close to the
fitted plane an &quot;inlier&quot;. A smaller value will yield a more stable
estimate.</p>
</td></tr>
<tr><td><code id="preProcess_ransacLevel_+3A_ransacfinalselectthresh">ransacFinalSelectThresh</code></td>
<td>
<p>once the RANSAC plane is fitted based on the
ransacInlierThresh, this argument dictates which observations are selected
as the final breech face estimate.</p>
</td></tr>
<tr><td><code id="preProcess_ransacLevel_+3A_iters">iters</code></td>
<td>
<p>number of candidate planes to fit (higher value yields more
stable breech face estimate)</p>
</td></tr>
<tr><td><code id="preProcess_ransacLevel_+3A_returnresiduals">returnResiduals</code></td>
<td>
<p>dictates whether the difference between the estimated
breech face and fitted plane are returned (residuals) or if the estimates
breech face is simply shifted down by its mean value</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an x3p object containing the leveled surface matrix.
</p>


<h3>Note</h3>

<p>Given input depths (in microns), find best-fitting plane using
RANSAC. This should be the plane that the breechface marks are on. Adapted
from cartridges3D::findPlaneRansac function. This a modified version of the
findPlaneRansac function available in the cartridges3D package on GitHub.
</p>
<p>The preProcess_ransacLevel function will throw an error if the final
plane estimate is rank-deficient (which is relatively unlikely, but
theoretically possible). Re-run the function (possibly setting a different
seed) if this occurs.
</p>


<h3>See Also</h3>

<p>https://github.com/xhtai/cartridges3D
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
nbtrd_link &lt;- "https://tsapps.nist.gov/NRBTD/Studies/CartridgeMeasurement/"
fadul1.1_link &lt;- "DownloadMeasurement/2d9cc51f-6f66-40a0-973a-a9292dbee36d"

fadul1.1 &lt;- x3ptools::read_x3p(paste0(nbtrd_link,fadul1.1_link))

fadul1.1_ransacLeveled &lt;- fadul1.1 %&gt;%
                     preProcess_crop(region = "exterior",
                                     radiusOffset = -30) %&gt;%
                     preProcess_crop(region = "interior",
                                     radiusOffset = 200) %&gt;%
                     preProcess_removeTrend(statistic = "quantile",
                                            tau = .5,
                                            method = "fn")

x3pListPlot(list("Original" = fadul1.1,
                 "RANSAC Leveled" = fadul1.1_ransacLeveled),type = "list")

## End(Not run)

</code></pre>

<hr>
<h2 id='preProcess_removeFPCircle'>Given a surface matrix, estimates and filters any pixels within the estimated
firing pin impression circle</h2><span id='topic+preProcess_removeFPCircle'></span>

<h3>Description</h3>

<p>Given a surface matrix, estimates and filters any pixels within the estimated
firing pin impression circle
</p>


<h3>Usage</h3>

<pre><code class='language-R'>preProcess_removeFPCircle(
  x3p,
  aggregationFunction = mean,
  smootherSize = 2 * round((0.1 * nrow(surfaceMat)/2)) + 1,
  gridSize = 40,
  gridGranularity = 1,
  houghScoreQuant = 0.9
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="preProcess_removeFPCircle_+3A_x3p">x3p</code></td>
<td>
<p>an x3p object containing a surface matrix</p>
</td></tr>
<tr><td><code id="preProcess_removeFPCircle_+3A_aggregationfunction">aggregationFunction</code></td>
<td>
<p>function to select initial radius estimate from
those calculated using fpRadiusGridSearch</p>
</td></tr>
<tr><td><code id="preProcess_removeFPCircle_+3A_smoothersize">smootherSize</code></td>
<td>
<p>size of average smoother (to be passed to zoo::roll_mean)</p>
</td></tr>
<tr><td><code id="preProcess_removeFPCircle_+3A_gridsize">gridSize</code></td>
<td>
<p>size of grid, centered on the initial radius estimate, to be
used to determine the best fitting circle to the surface matrix via the
Hough transform method</p>
</td></tr>
<tr><td><code id="preProcess_removeFPCircle_+3A_gridgranularity">gridGranularity</code></td>
<td>
<p>granularity of radius grid used to determine the best
fitting circle to the surface matrix via the Hough transform method</p>
</td></tr>
<tr><td><code id="preProcess_removeFPCircle_+3A_houghscorequant">houghScoreQuant</code></td>
<td>
<p>quantile cut-off to be used when determining a final
radius estimate using the score values returned by the imager::hough_circle</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An x3p object containing a surface matrix with the estimated firing
pin circle pixels replaced with NAs.
</p>


<h3>Note</h3>

<p>imager treats a matrix as its transpose (i.e., x and y axes are
swapped). As such, relative to the original surface matrix, the x and y
columns in the data frame fpImpressionCircle actually correspond to the row
and column indices at which the center of the firing pin impression circle
is estiamted to be.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
nbtrd_link &lt;- "https://tsapps.nist.gov/NRBTD/Studies/CartridgeMeasurement/"
fadul1.1_link &lt;- "DownloadMeasurement/2d9cc51f-6f66-40a0-973a-a9292dbee36d"

fadul1.1 &lt;- x3ptools::read_x3p(paste0(nbtrd_link,fadul1.1_link))

fadul1.1_labelCropped &lt;- fadul1.1 %&gt;%
                     preProcess_crop(region = "exterior",
                                     radiusOffset = -30) %&gt;%
                     preProcess_crop(region = "interior",
                                     radiusOffset = 200) %&gt;%
                     preProcess_removeTrend(statistic = "quantile",
                                            tau = .5,
                                            method = "fn")

fadul1.1_houghCropped &lt;- fadul1.1 %&gt;%
                          x3ptools::x3p_sample() %&gt;%
                          preProcess_ransacLevel() %&gt;%
                          preProcess_crop(region = "exterior",
                                          radiusOffset = -30) %&gt;%
                          preProcess_removeFPCircle()

x3pListPlot(list("Original" = fadul1.1,
                 "Cropped by Labeling" = fadul1.1_labelCropped,
                 "Cropped by Hough" = fadul1.1_houghCropped),type = "list")

## End(Not run)
</code></pre>

<hr>
<h2 id='preProcess_removeTrend'>Level a breech face impression surface matrix by a conditional statistic</h2><span id='topic+preProcess_removeTrend'></span>

<h3>Description</h3>

<p>Level a breech face impression surface matrix by a conditional statistic
</p>


<h3>Usage</h3>

<pre><code class='language-R'>preProcess_removeTrend(x3p, statistic = "mean", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="preProcess_removeTrend_+3A_x3p">x3p</code></td>
<td>
<p>an x3p object containing the surface matrix of a cartridge case
scan</p>
</td></tr>
<tr><td><code id="preProcess_removeTrend_+3A_statistic">statistic</code></td>
<td>
<p>either &quot;mean&quot; or &quot;quantile&quot;</p>
</td></tr>
<tr><td><code id="preProcess_removeTrend_+3A_...">...</code></td>
<td>
<p>arguments to be set in the quantreg::rq function if statistic =
&quot;quantile&quot; is set. In this case, tau = .5 and method = &quot;fn&quot; are recommended</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an x3p object containing the leveled cartridge case scan surface
matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#Process fadul1.1 "from scratch" (takes &gt; 5 seconds to run)
## Not run: 
nbtrd_link &lt;- "https://tsapps.nist.gov/NRBTD/Studies/CartridgeMeasurement/"
fadul1.1_link &lt;- "DownloadMeasurement/2d9cc51f-6f66-40a0-973a-a9292dbee36d"

fadul1.1 &lt;- x3ptools::read_x3p(paste0(nbtrd_link,fadul1.1_link))
fadul1.1_extCropped &lt;- preProcess_crop(x3p = fadul1.1,
                                       region = "exterior",
                                       radiusOffset = -30)

fadul1.1_intCroped &lt;- preProcess_crop(x3p = fadul1.1_extCropped,
                                      region = "interior",
                                      radiusOffset = 200)

fadul1.1_leveled &lt;- preProcess_removeTrend(x3p = fadul1.1_intCroped,
                                           statistic = "quantile",
                                           tau = .5,
                                           method = "fn")

x3pListPlot(list("Original" = fadul1.1,
                 "Ext. Cropped" = fadul1.1_extCropped,
                 "Ext. &amp; Int. Cropped" = fadul1.1_intCroped,
                 "Cropped and Leveled" = fadul1.1_leveled))

## End(Not run)
</code></pre>

<hr>
<h2 id='x3pListPlot'>Plot a list of x3ps</h2><span id='topic+x3pListPlot'></span>

<h3>Description</h3>

<p>Plots the surface matrices in a list of x3p objects. Either
creates one plot faceted by surface matrix or creates individual plots per
surface matrix and returns them in a list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>x3pListPlot(
  x3pList,
  type = "faceted",
  legend.quantiles = c(0, 0.01, 0.25, 0.5, 0.75, 0.99, 1),
  height.quantiles = c(0, 0.01, 0.025, 0.1, 0.25, 0.5, 0.75, 0.9, 0.975, 0.99, 1),
  height.colors = rev(c("#7f3b08", "#b35806", "#e08214", "#fdb863", "#fee0b6", "#f7f7f7",
    "#d8daeb", "#b2abd2", "#8073ac", "#542788", "#2d004b")),
  na.value = "gray65"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="x3pListPlot_+3A_x3plist">x3pList</code></td>
<td>
<p>a list of x3p objects. If the x3p objects are named in the
list, then these names will be included in the title of their respective
plot</p>
</td></tr>
<tr><td><code id="x3pListPlot_+3A_type">type</code></td>
<td>
<p>dictates whether one plot faceted by surface matrix or a list of
plots per surface matrix is returned. The faceted plot will have a
consistent height scale across all surface matrices.</p>
</td></tr>
<tr><td><code id="x3pListPlot_+3A_legend.quantiles">legend.quantiles</code></td>
<td>
<p>vector of quantiles to be shown as tick marks on
legend plot</p>
</td></tr>
<tr><td><code id="x3pListPlot_+3A_height.quantiles">height.quantiles</code></td>
<td>
<p>vector of quantiles associated with each color defined
in the height.colors argument</p>
</td></tr>
<tr><td><code id="x3pListPlot_+3A_height.colors">height.colors</code></td>
<td>
<p>vector of colors to be passed to scale_fill_gradientn
that dictates the height value colorscale</p>
</td></tr>
<tr><td><code id="x3pListPlot_+3A_na.value">na.value</code></td>
<td>
<p>color to be used for NA values (passed to
scale_fill_gradientn)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot object or list of ggplot objects showing the surface matrix
height values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(fadul1.1_processed,fadul1.2_processed)

x3pListPlot(list("Fadul 1-1" = fadul1.1_processed,
                 "Fadul 1-2" = fadul1.2_processed))
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
