<!DOCTYPE html><html><head><title>Help for package motif</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {motif}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#motif-package'><p>motif: Local Pattern Analysis</p></a></li>
<li><a href='#determine_classes'><p>Determine unique classes (internal function)</p></a></li>
<li><a href='#lsp_add_clusters'><p>Adds clusters' ids to a lsp object</p></a></li>
<li><a href='#lsp_add_examples'><p>Adds spatial data of each region in an lsp or sf object</p></a></li>
<li><a href='#lsp_add_quality'><p>Calculates quality metrics of clustering or segmentation</p></a></li>
<li><a href='#lsp_add_sf'><p>Creates or adds a sf object</p></a></li>
<li><a href='#lsp_add_stars'><p>Creates or adds a stars object</p></a></li>
<li><a href='#lsp_add_terra'><p>Creates or adds a terra object</p></a></li>
<li><a href='#lsp_compare'><p>Comparison between spatial patterns</p></a></li>
<li><a href='#lsp_extract'><p>Extracts a local landscape</p></a></li>
<li><a href='#lsp_mosaic'><p>Creates a raster mosaic</p></a></li>
<li><a href='#lsp_restructure'><p>Changes structure of the lsp object</p></a></li>
<li><a href='#lsp_search'><p>Search for similar spatial pattern</p></a></li>
<li><a href='#lsp_signature'><p>Creates a spatial signature</p></a></li>
<li><a href='#lsp_to_dist'><p>Calculate Distance Matrix</p></a></li>
<li><a href='#lsp_transform'><p>Transforms lsp objects</p></a></li>
<li><a href='#prepare_window'><p>Prepares window* arguments (internal function)</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Local Pattern Analysis</td>
</tr>
<tr>
<td>Version:</td>
<td>0.6.4</td>
</tr>
<tr>
<td>Description:</td>
<td>Describes spatial patterns of categorical raster data for 
    any defined regular and irregular areas. 
    Patterns are described quantitatively using built-in signatures 
    based on co-occurrence matrices but also allows for 
    any user-defined functions. 
    It enables spatial analysis such as search, change detection,
    and clustering to be performed on spatial patterns (Nowosad (2021) &lt;<a href="https://doi.org/10.1007%2Fs10980-020-01135-0">doi:10.1007/s10980-020-01135-0</a>&gt;).</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.1)</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>comat (&ge; 0.7.0), Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>Imports:</td>
<td>comat, philentropy (&ge; 0.6.0), Rcpp, sf, stars, tibble</td>
</tr>
<tr>
<td>Suggests:</td>
<td>covr, dplyr, spdep, knitr, rmarkdown, testthat (&ge; 2.1.0),
terra</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://jakubnowosad.com/motif/">https://jakubnowosad.com/motif/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/Nowosad/motif/issues">https://github.com/Nowosad/motif/issues</a></td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-06-29 15:08:20 UTC; jn</td>
</tr>
<tr>
<td>Author:</td>
<td>Jakub Nowosad <a href="https://orcid.org/0000-0002-1057-3721"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Jakub Nowosad &lt;nowosad.jakub@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-06-29 18:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='motif-package'>motif: Local Pattern Analysis</h2><span id='topic+motif'></span><span id='topic+motif-package'></span>

<h3>Description</h3>

<p><img src="../help/figures/logo.png" style='float: right' alt='logo' width='120' />
</p>
<p>Describes spatial patterns of categorical raster data for any defined regular and irregular areas. Patterns are described quantitatively using built-in signatures based on co-occurrence matrices but also allows for any user-defined functions. It enables spatial analysis such as search, change detection, and clustering to be performed on spatial patterns (Nowosad (2021) <a href="https://doi.org/10.1007/s10980-020-01135-0">doi:10.1007/s10980-020-01135-0</a>).
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Jakub Nowosad <a href="mailto:nowosad.jakub@gmail.com">nowosad.jakub@gmail.com</a> (<a href="https://orcid.org/0000-0002-1057-3721">ORCID</a>)
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://jakubnowosad.com/motif/">https://jakubnowosad.com/motif/</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/Nowosad/motif/issues">https://github.com/Nowosad/motif/issues</a>
</p>
</li></ul>


<hr>
<h2 id='determine_classes'>Determine unique classes (internal function)</h2><span id='topic+determine_classes'></span>

<h3>Description</h3>

<p>Determine unique classes (internal function)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>determine_classes(x, window)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="determine_classes_+3A_x">x</code></td>
<td>

<ul>
<li><p> a <code>stars</code> or <code>stars_proxy</code> object
</p>
</li></ul>
</td></tr>
<tr><td><code id="determine_classes_+3A_window">window</code></td>
<td>

<ul>
<li><p> a windows argument from <code>lsp_signature()</code>, <code>lsp_search()</code>, or <code>lsp_compare()</code>
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with vector of numbers (unique classes)
</p>

<hr>
<h2 id='lsp_add_clusters'>Adds clusters' ids to a lsp object</h2><span id='topic+lsp_add_clusters'></span>

<h3>Description</h3>

<p>Adds clusters' ids to a lsp object.
The output can be of <code>stars</code>, <code>sf</code>, or <code>terra</code> class.
See examples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lsp_add_clusters(x, clust, output = "sf", window = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lsp_add_clusters_+3A_x">x</code></td>
<td>
<p>Object of class <code>lsp</code> - usually the output of
the <code>lsp_signature()</code> function</p>
</td></tr>
<tr><td><code id="lsp_add_clusters_+3A_clust">clust</code></td>
<td>
<p>Vector containing an id value for each row in <code>x</code></p>
</td></tr>
<tr><td><code id="lsp_add_clusters_+3A_output">output</code></td>
<td>
<p>The class of the output. Either <code>stars</code>, <code>sf</code>, or <code>terra</code></p>
</td></tr>
<tr><td><code id="lsp_add_clusters_+3A_window">window</code></td>
<td>
<p>Specifies areas for analysis. It can be either: <code>NULL</code> or an <code>sf</code> object. If <code>window=NULL</code> calculations are performed based on the metadata from <code>x</code>. If an <code>sf</code> object is provided, each feature (row) defines the extent of a local pattern. The <code>sf</code> object should have one attribute (otherwise, the first attribute is used as an id).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Object of class <code>stars</code>, <code>sf</code>, or <code>terra</code> (depending on the <code>output</code> argument) with an additional column <code>"clust"</code> representing clusters' id values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(stars)
library(sf)
landform = read_stars(system.file("raster/landforms.tif", package = "motif"))
landform_cove = lsp_signature(landform,
                               type = "cove",
                               window = 200,
                               normalization = "pdf")

landform_dist = lsp_to_dist(landform_cove,
                            dist_fun = "jensen-shannon")

landform_hclust = hclust(landform_dist, method = "ward.D2")
#plot(landform_hclust)

clusters = cutree(landform_hclust, k = 4)

landform_grid_sf = lsp_add_clusters(landform_cove, clusters)
#plot(landform_grid_sf["clust"])

#landform_grid_sfq = lsp_add_quality(landform_grid_sf,
#                                        landform_dist)
#plot(landform_grid_sfq["quality"])

## larger data example
# library(stars)
# library(sf)
# landform = read_stars(system.file("raster/landform.tif", package = "motif"),
#                       proxy = FALSE)
# landform_cove = lsp_signature(landform,
#                                type = "cove",
#                                window = 200,
#                                normalization = "pdf")
#
# landform_dist = lsp_to_dist(landform_cove,
#                             dist_fun = "jensen-shannon")
#
# landform_hclust = hclust(landform_dist, method = "ward.D2")
# plot(landform_hclust)
#
# clusters = cutree(landform_hclust, k = 6)
#
# landform_grid_sf = lsp_add_clusters(landform_cove, clusters)
# plot(landform_grid_sf["clust"])
#
# landform_grid_sfq = lsp_add_quality(landform_grid_sf,
#                                        landform_dist)
# plot(landform_grid_sfq["quality"])
</code></pre>

<hr>
<h2 id='lsp_add_examples'>Adds spatial data of each region in an lsp or sf object</h2><span id='topic+lsp_add_examples'></span><span id='topic+lsp_add_examples.lsp'></span><span id='topic+lsp_add_examples.sf'></span>

<h3>Description</h3>

<p>Adds spatial data of each region in an lsp or sf object.
The output is an lsp or sf object with an additional column <code>"region"</code>.
See examples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lsp_add_examples(x, y, window = NULL)

## S3 method for class 'lsp'
lsp_add_examples(x, y, window = NULL)

## S3 method for class 'sf'
lsp_add_examples(x, y, window = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lsp_add_examples_+3A_x">x</code></td>
<td>
<p>Object of class <code>lsp</code> - usually a subset of the output of <code>lsp_signature()</code>
or an object of class <code>sf</code> - usually a subset of the output of <code>lsp_search()</code></p>
</td></tr>
<tr><td><code id="lsp_add_examples_+3A_y">y</code></td>
<td>
<p>Object of class <code>stars</code>, <code>stars_proxy</code>, or terra's <code>SpatRaster</code>.</p>
</td></tr>
<tr><td><code id="lsp_add_examples_+3A_window">window</code></td>
<td>
<p>Specifies areas for analysis. It can be either: <code>NULL</code> or an <code>sf</code> object.
The <code>sf</code> object is only needed for adding examples of irregular regions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The input object with a new column <code>"region"</code>.
The <code>"region"</code> column is a list with a raster extracted for each row.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(stars)

landcover = read_stars(system.file("raster/landcover2015s.tif", package = "motif"))

landcover_coma = lsp_signature(landcover, type = "coma", threshold = 0.9, window = 100)
selected_coma = subset(landcover_coma, id %in% c(5, 10, 15, 35))
selected_coma

selected_coma = lsp_add_examples(x = selected_coma, y = landcover)
selected_coma

plot(selected_coma$region[[1]])
plot(selected_coma$region[[4]])


# larger data example
library(stars)

landcover = read_stars(system.file("raster/landcover2015.tif", package = "motif"))

landcover_coma = lsp_signature(landcover, type = "coma", threshold = 0.9, window = 100)
selected_coma = subset(landcover_coma, id %in% c(5, 80, 1971, 2048))
selected_coma

selected_coma = lsp_add_examples(x = selected_coma, y = landcover)
selected_coma

plot(selected_coma$region[[1]])
plot(selected_coma$region[[4]])

</code></pre>

<hr>
<h2 id='lsp_add_quality'>Calculates quality metrics of clustering or segmentation</h2><span id='topic+lsp_add_quality'></span>

<h3>Description</h3>

<p>Calculates three metrics to evaluate quality of spatial patterns' clustering or segmentation.
When the type is <code>"cluster"</code>, then metrics of inhomogeneity, distinction, and quality are calculated.
When the type is <code>"segmentation"</code>, then metrics of inhomogeneity, isolation, and quality are calculated.
For more information, see Details below.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lsp_add_quality(x, x_dist, type = "cluster", regions = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lsp_add_quality_+3A_x">x</code></td>
<td>
<p>Object of class <code>sf</code> - usually the output of the <code>lsp_add_clusters()</code> function</p>
</td></tr>
<tr><td><code id="lsp_add_quality_+3A_x_dist">x_dist</code></td>
<td>
<p>Object of class <code>dist</code> - usually the output of
the <code>lsp_to_dist()</code> function</p>
</td></tr>
<tr><td><code id="lsp_add_quality_+3A_type">type</code></td>
<td>
<p>Either <code>"cluster"</code> or <code>"segmentation"</code></p>
</td></tr>
<tr><td><code id="lsp_add_quality_+3A_regions">regions</code></td>
<td>
<p>Not implemented yet</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For type <code>"cluster"</code>, this function calculates three quality metrics to evaluate spatial patterns' clustering:
(1) inhomogeneity - it measures a degree of mutual dissimilarity
between all objects in a cluster. This value is between 0 and 1,
where small value indicates that all objects in the cluster
represent consistent patterns so the cluster is pattern-homogeneous.
(2) distinction - it is an average distance between the focus cluster
and all of the other clusters.
This value is between 0 and 1, where large value indicates that the cluster
stands out from the other clusters.
(3) quality - overall quality of a cluster. It is calculated as
1 - (inhomogeneity / distinction). This value is also between 0 and 1,
where increased values indicate increased quality.
</p>
<p>For type <code>"segmentation"</code>, this function calculates three quality metrics to evaluate spatial patterns' segmentation:
(1) inhomogeneity - it measures a degree of mutual dissimilarity
between all objects in a cluster. This value is between 0 and 1,
where small value indicates that all objects in the cluster
represent consistent patterns so the cluster is pattern-homogeneous.
(2) isolation - it is an average distance between the focus cluster
and all of its neighbors. This value is between 0 and 1,
where large value indicates that the cluster
stands out from its surroundings.
(3) quality - overall quality of a cluster. It is calculated as
1 - (inhomogeneity / distinction). This value is also between 0 and 1,
where increased values indicate increased quality.
</p>


<h3>Value</h3>

<p>Object of class <code>sf</code> with three additional columns representing quality metrics.
</p>


<h3>References</h3>

<p>Jakub Nowosad &amp; Tomasz F. Stepinski (2021) Pattern-based identification and mapping of landscape types using multi-thematic data, International Journal of Geographical Information Science, DOI: 10.1080/13658816.2021.1893324
</p>


<h3>See Also</h3>

<p>lsp_add_clusters
</p>


<h3>Examples</h3>

<pre><code class='language-R'># see examples of `lsp_add_clusters()`

</code></pre>

<hr>
<h2 id='lsp_add_sf'>Creates or adds a sf object</h2><span id='topic+lsp_add_sf'></span><span id='topic+lsp_add_sf.default'></span><span id='topic+lsp_add_sf.lsp'></span>

<h3>Description</h3>

<p>Creates or adds a sf object based on the input object or a set of parameters.
It accepts either an object of class <code>stars</code> or <code>lsp</code>.
In the first case, the output is created based on
a set of parameters (<code>window_size</code> and <code>window_shift</code> or <code>window</code>).
In the second case, the output converts the <code>lsp</code> object into
a <code>sf</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lsp_add_sf(x = NULL, window = NULL, metadata = TRUE)

## Default S3 method:
lsp_add_sf(x = NULL, window = NULL, metadata = TRUE)

## S3 method for class 'lsp'
lsp_add_sf(x = NULL, window = NULL, metadata = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lsp_add_sf_+3A_x">x</code></td>
<td>
<p>Object of class <code>stars</code> or <code>lsp</code>.
For <code>stars</code>, <code>window</code> or <code>window_size</code> can be used.</p>
</td></tr>
<tr><td><code id="lsp_add_sf_+3A_window">window</code></td>
<td>
<p>Specifies areas for analysis. It can be either: <code>NULL</code>, a numeric value, or an <code>sf</code> object. If <code>window=NULL</code> calculations are performed for a whole area. If the <code>window</code> argument is numeric, it is a length of the side of a square-shaped block of cells. Expressed in the numbers of cells, it defines the extent of a local pattern. If an <code>sf</code> object is provided, each feature (row) defines the extent of a local pattern. The <code>sf</code> object should have one attribute (otherwise, the first attribute is used as an id).</p>
</td></tr>
<tr><td><code id="lsp_add_sf_+3A_metadata">metadata</code></td>
<td>
<p>Logical. Only when <code style="white-space: pre;">&#8288;x`` is of class &#8288;</code>lsp<code style="white-space: pre;">&#8288;. If &#8288;</code>TRUE<code style="white-space: pre;">&#8288;, the output object will have metadata ("id" and "na_prop"). If &#8288;</code>FALSE', the output object will not have metadata (&quot;id&quot; and &quot;na_prop&quot;).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code>sf</code> object converted from the input object or a provided set of parameters
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(stars)
landform = read_stars(system.file("raster/landforms.tif", package = "motif"))
plot(landform)
landform_lsp = lsp_add_sf(landform, window = 100)
plot(landform_lsp)

lc_cove = lsp_signature(landform, type = "cove", window = 200, normalization = "pdf")
lc_cove_lsp = lsp_add_sf(lc_cove)
plot(lc_cove_lsp["id"])
plot(lc_cove_lsp["na_prop"])


# larger data example
library(stars)
landform = read_stars(system.file("raster/landform.tif", package = "motif"))
plot(landform)
landform_lsp = lsp_add_sf(landform, window = 100)
plot(landform_lsp)

lc_cove = lsp_signature(landform, type = "cove", window = 200, normalization = "pdf")
lc_cove_lsp = lsp_add_sf(lc_cove)
plot(lc_cove_lsp["id"])
plot(lc_cove_lsp["na_prop"])

</code></pre>

<hr>
<h2 id='lsp_add_stars'>Creates or adds a stars object</h2><span id='topic+lsp_add_stars'></span><span id='topic+lsp_add_stars.default'></span><span id='topic+lsp_add_stars.lsp'></span>

<h3>Description</h3>

<p>Creates or adds a stars object based on the input object or a set of parameters.
It accepts either an object of class <code>stars</code> or <code>lsp</code>.
In the first case, the output is created based on
the <code>window</code> parameter.
In the second case, the output converts the <code>lsp</code> object into
a <code>stars</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lsp_add_stars(x = NULL, window = NULL, metadata = TRUE)

## Default S3 method:
lsp_add_stars(x = NULL, window = NULL, metadata = TRUE)

## S3 method for class 'lsp'
lsp_add_stars(x = NULL, window = NULL, metadata = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lsp_add_stars_+3A_x">x</code></td>
<td>
<p>Object of class <code>stars</code> or <code>lsp</code>.
For <code>stars</code>, <code>window</code> or <code>window_size</code> can be used.</p>
</td></tr>
<tr><td><code id="lsp_add_stars_+3A_window">window</code></td>
<td>
<p>Specifies areas for analysis. It can be either: <code>NULL</code>, a numeric value, or an <code>sf</code> object. If <code>window=NULL</code> calculations are performed for a whole area. If the <code>window</code> argument is numeric, it is a length of the side of a square-shaped block of cells. Expressed in the numbers of cells, it defines the extent of a local pattern. If an <code>sf</code> object is provided, each feature (row) defines the extent of a local pattern. The <code>sf</code> object should have one attribute (otherwise, the first attribute is used as an id).</p>
</td></tr>
<tr><td><code id="lsp_add_stars_+3A_metadata">metadata</code></td>
<td>
<p>Logical. Only when <code style="white-space: pre;">&#8288;x`` is of class &#8288;</code>lsp<code style="white-space: pre;">&#8288;. If &#8288;</code>TRUE<code style="white-space: pre;">&#8288;, the output object will have metadata ("id" and "na_prop"). If &#8288;</code>FALSE', the output object will not have metadata (&quot;id&quot; and &quot;na_prop&quot;).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>stars</code> object converted from the input object or a provided set of parameters
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(stars)
landform = read_stars(system.file("raster/landforms.tif", package = "motif"))
plot(landform)
landform_lsp = lsp_add_stars(landform, window = 100)
plot(landform_lsp)

lc_cove = lsp_signature(landform, type = "cove", window = 200, normalization = "pdf")
lc_cove_lsp = lsp_add_stars(lc_cove)
plot(lc_cove_lsp)
plot(lc_cove_lsp["na_prop"])



# larger data example
library(stars)
landform = read_stars(system.file("raster/landform.tif", package = "motif"))
plot(landform)
landform_lsp = lsp_add_stars(landform, window = 100)
plot(landform_lsp)

lc_cove = lsp_signature(landform, type = "cove", window = 200, normalization = "pdf")
lc_cove_lsp = lsp_add_stars(lc_cove)
plot(lc_cove_lsp)
plot(lc_cove_lsp["na_prop"])

</code></pre>

<hr>
<h2 id='lsp_add_terra'>Creates or adds a terra object</h2><span id='topic+lsp_add_terra'></span>

<h3>Description</h3>

<p>Creates or adds a terra object based on the input object or a set of parameters.
It accepts either an object of class <code>stars</code> or <code>lsp</code>.
In the first case, the output is created based on
the <code>window</code> parameter.
In the second case, the output converts the <code>lsp</code> object into
a <code>terra</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lsp_add_terra(x = NULL, window = NULL, metadata = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lsp_add_terra_+3A_x">x</code></td>
<td>
<p>Object of class <code>stars</code> or <code>lsp</code>.
For <code>stars</code>, <code>window</code> or <code>window_size</code> can be used.</p>
</td></tr>
<tr><td><code id="lsp_add_terra_+3A_window">window</code></td>
<td>
<p>Specifies areas for analysis. It can be either: <code>NULL</code>, a numeric value, or an <code>sf</code> object. If <code>window=NULL</code> calculations are performed for a whole area. If the <code>window</code> argument is numeric, it is a length of the side of a square-shaped block of cells. Expressed in the numbers of cells, it defines the extent of a local pattern. If an <code>sf</code> object is provided, each feature (row) defines the extent of a local pattern. The <code>sf</code> object should have one attribute (otherwise, the first attribute is used as an id).</p>
</td></tr>
<tr><td><code id="lsp_add_terra_+3A_metadata">metadata</code></td>
<td>
<p>Logical. Only when <code style="white-space: pre;">&#8288;x`` is of class &#8288;</code>lsp<code style="white-space: pre;">&#8288;. If &#8288;</code>TRUE<code style="white-space: pre;">&#8288;, the output object will have metadata ("id" and "na_prop"). If &#8288;</code>FALSE', the output object will not have metadata (&quot;id&quot; and &quot;na_prop&quot;).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>terra</code> object converted from the input object or a provided set of parameters
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(stars)
library(terra)
landform = read_stars(system.file("raster/landforms.tif", package = "motif"))
#plot(landform)
landform_lsp = lsp_add_terra(landform, window = 100)
#plot(landform_lsp)

#lc_cove = lsp_signature(landform, type = "cove", window = 200, normalization = "pdf")
#lc_cove_lsp = lsp_add_terra(lc_cove)
#plot(lc_cove_lsp)
#plot(lc_cove_lsp["na_prop"])

</code></pre>

<hr>
<h2 id='lsp_compare'>Comparison between spatial patterns</h2><span id='topic+lsp_compare'></span>

<h3>Description</h3>

<p>Compares two spatial datasets containing categorical raster data.
It accepts a categorical raster dataset with one or more attributes, and compares it to the second dataset with the same attributes and dimensions.
The both dataset are either compared to as whole areas, areas divided into regular windows, or areas divided into irregular windows.
This function allows for several types of comparisons using different representations of spatial patterns, including &quot;coma&quot; (co-occurrence matrix), &quot;cove&quot; (co-occurrence vector), &quot;cocoma&quot; (co-located co-occurrence matrix), &quot;cocove&quot; (co-located co-occurrence vector), &quot;wecoma&quot; (weighted co-occurrence matrix), &quot;wecove&quot; (weighted co-occurrence vector), &quot;incoma&quot; (integrated co-occurrence matrix), &quot;incove&quot; (integrated co-occurrence vector). These representations are created for both datasets, and next a distance between them is calculated using a selected measure from the <code>philentropy::distance</code> function.
Additional parameters, such as neighbourhood or normalization types, are also available.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lsp_compare(
  x,
  y,
  type,
  dist_fun,
  window = NULL,
  output = "stars",
  neighbourhood = 4,
  threshold = 0.5,
  ordered = FALSE,
  repeated = FALSE,
  normalization = "pdf",
  wecoma_fun = "mean",
  wecoma_na_action = "replace",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lsp_compare_+3A_x">x</code></td>
<td>
<p>Object of class <code>stars</code>, <code>stars_proxy</code>, or terra's <code>SpatRaster</code>. It should have one attribute (for <code>"coma"</code>, <code>"cove"</code>), two attributes (<code>"cocoma"</code>, <code>"cocove"</code>, <code>"wecoma"</code>, <code>"wecove"</code>), two or more attributes (<code>"incoma"</code>, <code>"incove"</code>), or any number of attributes suitable for user-defined functions.</p>
</td></tr>
<tr><td><code id="lsp_compare_+3A_y">y</code></td>
<td>
<p>Object of class <code>stars</code>, <code>stars_proxy</code>, or terra's <code>SpatRaster</code>. It should have one attribute (for <code>"coma"</code>, <code>"cove"</code>), two attributes (<code>"cocoma"</code>, <code>"cocove"</code>, <code>"wecoma"</code>, <code>"wecove"</code>), two or more attributes (<code>"incoma"</code>, <code>"incove"</code>), or any number of attributes suitable for user-defined functions.</p>
</td></tr>
<tr><td><code id="lsp_compare_+3A_type">type</code></td>
<td>
<p>Type of the calculated signature. It can be <code>"coma"</code> (co-occurrence matrix), <code>"cove"</code> (co-occurrence vector), <code>"cocoma"</code> (co-located co-occurrence matrix), <code>"cocove"</code> (co-located co-occurrence vector), <code>"wecoma"</code> (weighted co-occurrence matrix), <code>"wecove"</code> (weighted co-occurrence vector), <code>"incoma"</code> (integrated co-occurrence matrix), <code>"incove"</code> (integrated co-occurrence vector), <code>"composition"</code> or any function that can summarize <code>stars</code> objects.</p>
</td></tr>
<tr><td><code id="lsp_compare_+3A_dist_fun">dist_fun</code></td>
<td>
<p>Distance measure used. This function uses the <code>philentropy::distance</code> function in the background. Run <code>philentropy::getDistMethods()</code> to find possible distance measures.</p>
</td></tr>
<tr><td><code id="lsp_compare_+3A_window">window</code></td>
<td>
<p>Specifies areas for analysis. It can be either: <code>NULL</code>, a numeric value, or an <code>sf</code> object. If <code>window=NULL</code> calculations are performed for a whole area. If the <code>window</code> argument is numeric, it is a length of the side of a square-shaped block of cells. Expressed in the numbers of cells, it defines the extent of a local pattern. If an <code>sf</code> object is provided, each feature (row) defines the extent of a local pattern. The <code>sf</code> object should have one attribute (otherwise, the first attribute is used as an id).</p>
</td></tr>
<tr><td><code id="lsp_compare_+3A_output">output</code></td>
<td>
<p>The class of the output. Either <code>"stars"</code>, <code>"sf"</code>, or <code>"terra"</code></p>
</td></tr>
<tr><td><code id="lsp_compare_+3A_neighbourhood">neighbourhood</code></td>
<td>
<p>The number of directions in which cell adjacencies are considered as neighbours:
4 (rook's case) or 8 (queen's case). The default is 4.</p>
</td></tr>
<tr><td><code id="lsp_compare_+3A_threshold">threshold</code></td>
<td>
<p>The share of NA cells to allow metrics calculation.</p>
</td></tr>
<tr><td><code id="lsp_compare_+3A_ordered">ordered</code></td>
<td>
<p>For <code>"cove"</code>, <code>"cocove"</code>, <code>"wecove"</code> and <code>"incove"</code> only. The type of pairs considered.
Either &quot;ordered&quot; (TRUE) or &quot;unordered&quot; (FALSE).
The default is FALSE.</p>
</td></tr>
<tr><td><code id="lsp_compare_+3A_repeated">repeated</code></td>
<td>
<p>For <code>"incove"</code> only. Should the repeated co-located co-occurrence matrices be used?
Either &quot;ordered&quot; (TRUE) or &quot;unordered&quot; (FALSE).
The default is FALSE.</p>
</td></tr>
<tr><td><code id="lsp_compare_+3A_normalization">normalization</code></td>
<td>
<p>For <code>"cove"</code>, <code>"cocove"</code>, <code>"wecove"</code>, <code>"incove"</code>, <code>"composition"</code>, or user-provided functions only.
Should the output vector be normalized?
Either &quot;none&quot; or &quot;pdf&quot;.
The &quot;pdf&quot; option normalizes a vector to sum to one.
The default is &quot;pdf&quot;.</p>
</td></tr>
<tr><td><code id="lsp_compare_+3A_wecoma_fun">wecoma_fun</code></td>
<td>
<p>For <code>"wecoma"</code> and <code>"wecove"</code> only. Function to calculate values from adjacent cells to contribute to exposure matrix, <code>"mean"</code> - calculate average values of local population densities from adjacent cells, <code>"geometric_mean"</code> - calculate geometric mean values of local population densities from adjacent cells, or <code>"focal"</code> assign a value from the focal cell</p>
</td></tr>
<tr><td><code id="lsp_compare_+3A_wecoma_na_action">wecoma_na_action</code></td>
<td>
<p>For <code>"wecoma"</code> and <code>"wecove"</code> only. Decides on how to behave in the presence of missing values in <code>w</code>. Possible options are <code>"replace"</code>, <code>"omit"</code>, <code>"keep"</code>. The default, <code>"replace"</code>, replaces missing values with 0, <code>"omit"</code> does not use cells with missing values, and <code>"keep"</code> keeps missing values.</p>
</td></tr>
<tr><td><code id="lsp_compare_+3A_...">...</code></td>
<td>
<p>Additional arguments for the <code>philentropy::distance</code> function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Object of class <code>stars</code> (or <code>sf</code> or terra's <code>SpatRaster</code>, depending on the <code>output</code> argument).
It has four attributes:
(1) <code>id</code> - an id of each window.
For irregular windows, it is the values provided in the <code>window</code> argument,
(2) <code>na_prop_x</code> - share (0-1) of <code>NA</code> cells for each window in the <code>x</code> object,
(3) <code>na_prop_y</code> - share (0-1) of <code>NA</code> cells for each window in the <code>y</code> object,
(4) <code>dist</code>- calculated distance between signatures for each window
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(stars)

lc15 = read_stars(system.file("raster/landcover2015s.tif", package = "motif"))
lc01 = read_stars(system.file("raster/landcover2001s.tif", package = "motif"))
ecoregions = read_sf(system.file("vector/ecoregionss.gpkg", package = "motif"))

ecoregions = st_transform(ecoregions, st_crs(lc15))

c1 = lsp_compare(lc01, lc15, type = "cove",
    dist_fun = "jensen-shannon", window = ecoregions["id"])
plot(c1["dist"])


# larger data example
library(stars)

lc15 = read_stars(system.file("raster/landcover2015.tif", package = "motif"))
lc01 = read_stars(system.file("raster/landcover2001.tif", package = "motif"))
ecoregions = read_sf(system.file("vector/ecoregions.gpkg", package = "motif"))

ecoregions = st_transform(ecoregions, st_crs(lc15))

c1 = lsp_compare(lc01, lc15, type = "cove",
    dist_fun = "jensen-shannon", window = ecoregions["id"])
plot(c1["dist"])

</code></pre>

<hr>
<h2 id='lsp_extract'>Extracts a local landscape</h2><span id='topic+lsp_extract'></span>

<h3>Description</h3>

<p>Extracts a local landscape from categorical raster data based on its id and provided <code>window</code> argument.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lsp_extract(x, window, id)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lsp_extract_+3A_x">x</code></td>
<td>
<p>Object of class <code>stars</code>, <code>stars_proxy</code>, or terra's <code>SpatRaster</code>.</p>
</td></tr>
<tr><td><code id="lsp_extract_+3A_window">window</code></td>
<td>
<p>Specifies areas for analysis. It can be either: <code>NULL</code>, a numeric value, or an <code>sf</code> object.</p>
</td></tr>
<tr><td><code id="lsp_extract_+3A_id">id</code></td>
<td>
<p>Id of the local landscape - it is possible to find in the output of <code>lsp_signature()</code>, <code>lsp_search()</code>, <code>lsp_compare()</code>, or <code>lsp_add_clusters()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>stars</code>or <code>terra</code> object cropped to the extent of a selected local landscape
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(stars)
landform = read_stars(system.file("raster/landforms.tif", package = "motif"))
ecoregions = read_sf(system.file("vector/ecoregionss.gpkg", package = "motif"))

extract1 = lsp_extract(x = landform, window = 100, id = 25)
plot(extract1)

ecoregions = st_transform(ecoregions, st_crs(landform))
extract2 = lsp_extract(x = landform, window = ecoregions["id"], id = 11)
plot(extract2)


# larger data example
library(stars)
landform = read_stars(system.file("raster/landform.tif", package = "motif"))
ecoregions = read_sf(system.file("vector/ecoregions.gpkg", package = "motif"))

extract1 = lsp_extract(x = landform, window = 100, id = 1895)
plot(extract1)

ecoregions = st_transform(ecoregions, st_crs(landform))
extract2 = lsp_extract(x = landform, window = ecoregions["id"], id = 7)
plot(extract2)

</code></pre>

<hr>
<h2 id='lsp_mosaic'>Creates a raster mosaic</h2><span id='topic+lsp_mosaic'></span>

<h3>Description</h3>

<p>Creates a raster mosaic by rearranging spatial data for example regions.
See examples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lsp_mosaic(x, output = "stars")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lsp_mosaic_+3A_x">x</code></td>
<td>
<p>Usually the output of the <code>lsp_add_examples()</code> function</p>
</td></tr>
<tr><td><code id="lsp_mosaic_+3A_output">output</code></td>
<td>
<p>The class of the output. Either <code>"stars"</code> or <code>terra</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>stars</code> or <code>terra</code> object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# larger data example
library(stars)
library(sf)
landform = read_stars(system.file("raster/landform.tif", package = "motif"))
landform_cove = lsp_signature(landform,
                               type = "cove",
                               window = 200,
                               normalization = "pdf")

landform_dist = lsp_to_dist(landform_cove,
                            dist_fun = "jensen-shannon")

landform_hclust = hclust(landform_dist, method = "ward.D2")
plot(landform_hclust)

clusters = cutree(landform_hclust, k = 6)

landform_grid_sf = lsp_add_clusters(landform_cove, clusters)
plot(landform_grid_sf["clust"])

landform_grid_sf_sel = landform_grid_sf %&gt;%
    dplyr::filter(na_prop == 0) %&gt;%
    dplyr::group_by(clust) %&gt;%
    dplyr::slice_sample(n = 16, replace = TRUE)

landform_grid_sf_sel = lsp_add_examples(x = landform_grid_sf_sel, y = landform)
landform_grid_sf_sel

landform_clust_m = lsp_mosaic(landform_grid_sf_sel)

plot(landform_clust_m)

</code></pre>

<hr>
<h2 id='lsp_restructure'>Changes structure of the lsp object</h2><span id='topic+lsp_restructure'></span>

<h3>Description</h3>

<p>Converts a list-column with signatures into many numeric columns
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lsp_restructure(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lsp_restructure_+3A_x">x</code></td>
<td>

<ul>
<li><p> an lsp object
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>Object of class <code>lsp</code>.
It has several columns: (1) <code>id</code> - an id of each window.
For irregular windows, it is the values provided in the <code>window</code> argument,
(2) <code>na_prop</code> - share (0-1) of <code>NA</code> cells for each window,
(3) one or more columns representing values of the signature
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(stars)

landcover = read_stars(system.file("raster/landcover2015s.tif", package = "motif"))

landcover_cove = lsp_signature(landcover, type = "cove", threshold = 0.9, window = 100)
landcover_cover = lsp_restructure(landcover_cove)
landcover_cover

lsp_add_sf(landcover_cover)
</code></pre>

<hr>
<h2 id='lsp_search'>Search for similar spatial pattern</h2><span id='topic+lsp_search'></span>

<h3>Description</h3>

<p>Searches for areas with similar spatial patterns in categorical data.
It accepts a categorical raster dataset with one or more attributes, and compares it to the second (usually larger) dataset with the same attributes.
The first dataset is either compared to a whole area, areas divided into regular windows, or areas divided into irregular windows from the second dataset.
This function allows for several types of comparisons using different representations of spatial patterns, including &quot;coma&quot; (co-occurrence matrix), &quot;cove&quot; (co-occurrence vector), &quot;cocoma&quot; (co-located co-occurrence matrix), &quot;cocove&quot; (co-located co-occurrence vector), &quot;wecoma&quot; (weighted co-occurrence matrix), &quot;wecove&quot; (weighted co-occurrence vector), &quot;incoma&quot; (integrated co-occurrence matrix), &quot;incove&quot; (integrated co-occurrence vector). These representations are created for both datasets, and next a distance between them is calculated using a selected measure from the <code>philentropy::distance</code> function.
Additional parameters, such as neighbourhood or normalization types, are also available.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lsp_search(
  x,
  y,
  type,
  dist_fun,
  window = NULL,
  output = "stars",
  neighbourhood = 4,
  threshold = 0.5,
  ordered = FALSE,
  repeated = FALSE,
  normalization = "pdf",
  wecoma_fun = "mean",
  wecoma_na_action = "replace",
  classes = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lsp_search_+3A_x">x</code></td>
<td>
<p>Object of class <code>stars</code>, <code>stars_proxy</code>, or terra's <code>SpatRaster</code>. It should have one attribute (for <code>"coma"</code>, <code>"cove"</code>), two attributes (<code>"cocoma"</code>, <code>"cocove"</code>, <code>"wecoma"</code>, <code>"wecove"</code>), two or more attributes (<code>"incoma"</code>, <code>"incove"</code>), or any number of attributes suitable for user-defined functions.</p>
</td></tr>
<tr><td><code id="lsp_search_+3A_y">y</code></td>
<td>
<p>Object of class <code>stars</code>, <code>stars_proxy</code>, or terra's <code>SpatRaster</code>. It should have one attribute (for <code>"coma"</code>, <code>"cove"</code>), two attributes (<code>"cocoma"</code>, <code>"cocove"</code>, <code>"wecoma"</code>, <code>"wecove"</code>), two or more attributes (<code>"incoma"</code>, <code>"incove"</code>), or any number of attributes suitable for user-defined functions.</p>
</td></tr>
<tr><td><code id="lsp_search_+3A_type">type</code></td>
<td>
<p>Type of the calculated signature. It can be <code>"coma"</code> (co-occurrence matrix), <code>"cove"</code> (co-occurrence vector), <code>"cocoma"</code> (co-located co-occurrence matrix), <code>"cocove"</code> (co-located co-occurrence vector), <code>"wecoma"</code> (weighted co-occurrence matrix), <code>"wecove"</code> (weighted co-occurrence vector), <code>"incoma"</code> (integrated co-occurrence matrix), <code>"incove"</code> (integrated co-occurrence vector), <code>"composition"</code> or any function that can summarize <code>stars</code> objects.</p>
</td></tr>
<tr><td><code id="lsp_search_+3A_dist_fun">dist_fun</code></td>
<td>
<p>Distance measure used. This function uses the <code>philentropy::distance</code> function in the background. Run <code>philentropy::getDistMethods()</code> to find possible distance measures.</p>
</td></tr>
<tr><td><code id="lsp_search_+3A_window">window</code></td>
<td>
<p>Specifies areas for analysis. It can be either: <code>NULL</code>, a numeric value, or an <code>sf</code> object. If <code>window=NULL</code> calculations are performed for a whole area. If the <code>window</code> argument is numeric, it is a length of the side of a square-shaped block of cells. Expressed in the numbers of cells, it defines the extent of a local pattern. If an <code>sf</code> object is provided, each feature (row) defines the extent of a local pattern. The <code>sf</code> object should have one attribute (otherwise, the first attribute is used as an id).</p>
</td></tr>
<tr><td><code id="lsp_search_+3A_output">output</code></td>
<td>
<p>The class of the output. Either <code>"stars"</code>, <code>"sf"</code>, or <code>"terra"</code></p>
</td></tr>
<tr><td><code id="lsp_search_+3A_neighbourhood">neighbourhood</code></td>
<td>
<p>The number of directions in which cell adjacencies are considered as neighbours:
4 (rook's case) or 8 (queen's case). The default is 4.</p>
</td></tr>
<tr><td><code id="lsp_search_+3A_threshold">threshold</code></td>
<td>
<p>The share of NA cells to allow metrics calculation.</p>
</td></tr>
<tr><td><code id="lsp_search_+3A_ordered">ordered</code></td>
<td>
<p>For <code>"cove"</code>, <code>"cocove"</code>, <code>"wecove"</code> and <code>"incove"</code> only. The type of pairs considered.
Either &quot;ordered&quot; (TRUE) or &quot;unordered&quot; (FALSE).
The default is FALSE.</p>
</td></tr>
<tr><td><code id="lsp_search_+3A_repeated">repeated</code></td>
<td>
<p>For <code>"incove"</code> only. Should the repeated co-located co-occurrence matrices be used?
Either &quot;ordered&quot; (TRUE) or &quot;unordered&quot; (FALSE).
The default is FALSE.</p>
</td></tr>
<tr><td><code id="lsp_search_+3A_normalization">normalization</code></td>
<td>
<p>For <code>"cove"</code>, <code>"cocove"</code>, <code>"wecove"</code>, <code>"incove"</code>, <code>"composition"</code>, or user-provided functions only.
Should the output vector be normalized?
Either &quot;none&quot; or &quot;pdf&quot;.
The &quot;pdf&quot; option normalizes a vector to sum to one.
The default is &quot;pdf&quot;.</p>
</td></tr>
<tr><td><code id="lsp_search_+3A_wecoma_fun">wecoma_fun</code></td>
<td>
<p>For <code>"wecoma"</code> and <code>"wecove"</code> only. Function to calculate values from adjacent cells to contribute to exposure matrix, <code>"mean"</code> - calculate average values of local population densities from adjacent cells, <code>"geometric_mean"</code> - calculate geometric mean values of local population densities from adjacent cells, or <code>"focal"</code> assign a value from the focal cell</p>
</td></tr>
<tr><td><code id="lsp_search_+3A_wecoma_na_action">wecoma_na_action</code></td>
<td>
<p>For <code>"wecoma"</code> and <code>"wecove"</code> only. Decides on how to behave in the presence of missing values in <code>w</code>. Possible options are <code>"replace"</code>, <code>"omit"</code>, <code>"keep"</code>. The default, <code>"replace"</code>, replaces missing values with 0, <code>"omit"</code> does not use cells with missing values, and <code>"keep"</code> keeps missing values.</p>
</td></tr>
<tr><td><code id="lsp_search_+3A_classes">classes</code></td>
<td>
<p>Which classes (categories) should be analyzed? This parameter expects a list of the same length as the number of attributes in <code>x</code>, where each element of the list contains integer vector. The default is <code>NULL</code>, which means that the classes are calculated directly from the input data and all of them are used in the calculations.</p>
</td></tr>
<tr><td><code id="lsp_search_+3A_...">...</code></td>
<td>
<p>Additional arguments for the <code>philentropy::distance</code> function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Object of class <code>stars</code> (or <code>sf</code> or terra's <code>SpatRaster</code>, depending on the <code>output</code> argument).
It has three attributes:
(1) <code>id</code> - an id of each window.
For irregular windows, it is the values provided in the <code>window</code> argument,
(2) <code>na_prop</code> - share (0-1) of <code>NA</code> cells for each window in the <code>y</code> object,
(3) <code>dist</code>- calculated distance between the <code>x</code> object and each window in the <code>y</code> object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(stars)

landcover = read_stars(system.file("raster/landcover2015s.tif", package = "motif"))
plot(landcover)

ext = st_bbox(c(xmin = -249797.344531127, xmax = -211162.693944285,
                ymin = -597280.143035389, ymax = -558645.492448547),
                crs = st_crs(landcover))

landcover_ext = landcover[ext]
plot(landcover_ext)

ecoregions = read_sf(system.file("vector/ecoregionss.gpkg", package = "motif"))
plot(ecoregions["id"])

s1 = lsp_search(landcover_ext, landcover, type = "cove",
  dist_fun = "jensen-shannon", threshold = 0.9, window = 100)
plot(s1["dist"])

ecoregions = st_transform(ecoregions, st_crs(landcover))
s2 = lsp_search(landcover_ext, landcover, type = "cove",
  dist_fun = "jensen-shannon", threshold = 0.5, window = ecoregions["id"])
plot(s2["dist"])


# larger data example
library(stars)

landcover = read_stars(system.file("raster/landcover2015.tif", package = "motif"))
plot(landcover)

ext = st_bbox(c(xmin = -249797.344531127, xmax = -211162.693944285,
                ymin = -597280.143035389, ymax = -558645.492448547),
                crs = st_crs(landcover))

landcover_ext = landcover[ext]
plot(landcover_ext)

ecoregions = read_sf(system.file("vector/ecoregions.gpkg", package = "motif"))
plot(ecoregions["id"])

s1 = lsp_search(landcover_ext, landcover, type = "cove",
  dist_fun = "jensen-shannon", threshold = 0.9, window = 1000)
plot(s1["dist"])

ecoregions = st_transform(ecoregions, st_crs(landcover))
s2 = lsp_search(landcover_ext, landcover, type = "cove",
  dist_fun = "jensen-shannon", threshold = 0.5, window = ecoregions["id"])
plot(s2["dist"])

</code></pre>

<hr>
<h2 id='lsp_signature'>Creates a spatial signature</h2><span id='topic+lsp_signature'></span>

<h3>Description</h3>

<p>Calculates selected spatial signatures based on categorical raster data. It also allows for calculations for any defined regular and irregular areas. It has several built-in signatures but also allows for any user-defined functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lsp_signature(
  x,
  type,
  window = NULL,
  neighbourhood = 4,
  threshold = 0.9,
  ordered = FALSE,
  repeated = FALSE,
  normalization = "pdf",
  wecoma_fun = "mean",
  wecoma_na_action = "replace",
  classes = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lsp_signature_+3A_x">x</code></td>
<td>
<p>Object of class <code>stars</code>, <code>stars_proxy</code>, or terra's <code>SpatRaster</code>. It should have one attribute (for <code>"coma"</code>, <code>"cove"</code>), two attributes (<code>"cocoma"</code>, <code>"cocove"</code>, <code>"wecoma"</code>, <code>"wecove"</code>), two or more attributes (<code>"incoma"</code>, <code>"incove"</code>), or any number of attributes suitable for user-defined functions.</p>
</td></tr>
<tr><td><code id="lsp_signature_+3A_type">type</code></td>
<td>
<p>Type of the calculated signature. It can be <code>"coma"</code> (co-occurrence matrix), <code>"cove"</code> (co-occurrence vector), <code>"cocoma"</code> (co-located co-occurrence matrix), <code>"cocove"</code> (co-located co-occurrence vector), <code>"wecoma"</code> (weighted co-occurrence matrix), <code>"wecove"</code> (weighted co-occurrence vector), <code>"incoma"</code> (integrated co-occurrence matrix), <code>"incove"</code> (integrated co-occurrence vector), <code>"composition"</code> or any function that can summarize <code>stars</code> objects.</p>
</td></tr>
<tr><td><code id="lsp_signature_+3A_window">window</code></td>
<td>
<p>Specifies areas for analysis. It can be either: <code>NULL</code>, a numeric value, or an <code>sf</code> object. If <code>window=NULL</code> calculations are performed for a whole area. If the <code>window</code> argument is numeric, it is a length of the side of a square-shaped block of cells. Expressed in the numbers of cells, it defines the extent of a local pattern. If an <code>sf</code> object is provided, each feature (row) defines the extent of a local pattern. The <code>sf</code> object should have one attribute (otherwise, the first attribute is used as an id).</p>
</td></tr>
<tr><td><code id="lsp_signature_+3A_neighbourhood">neighbourhood</code></td>
<td>
<p>The number of directions in which cell adjacencies are considered as neighbours:
4 (rook's case) or 8 (queen's case). The default is 4.</p>
</td></tr>
<tr><td><code id="lsp_signature_+3A_threshold">threshold</code></td>
<td>
<p>The share of NA cells (0-1) to allow metrics calculation.</p>
</td></tr>
<tr><td><code id="lsp_signature_+3A_ordered">ordered</code></td>
<td>
<p>For <code>"cove"</code>, <code>"cocove"</code>, <code>"wecove"</code> and <code>"incove"</code> only. The type of pairs considered.
Either &quot;ordered&quot; (TRUE) or &quot;unordered&quot; (FALSE).
The default is FALSE.</p>
</td></tr>
<tr><td><code id="lsp_signature_+3A_repeated">repeated</code></td>
<td>
<p>For <code>"incove"</code> only. Should the repeated co-located co-occurrence matrices be used?
Either &quot;ordered&quot; (TRUE) or &quot;unordered&quot; (FALSE).
The default is FALSE.</p>
</td></tr>
<tr><td><code id="lsp_signature_+3A_normalization">normalization</code></td>
<td>
<p>For <code>"cove"</code>, <code>"cocove"</code>, <code>"wecove"</code>, <code>"incove"</code>, <code>"composition"</code>, or user-provided functions only. Should the output vector be normalized?
Either &quot;none&quot; or &quot;pdf&quot;.
The &quot;pdf&quot; option normalizes a vector to sum to one.
The default is &quot;pdf&quot;.</p>
</td></tr>
<tr><td><code id="lsp_signature_+3A_wecoma_fun">wecoma_fun</code></td>
<td>
<p>For <code>"wecoma"</code> and <code>"wecove"</code> only. Function to calculate values from adjacent cells to contribute to exposure matrix, <code>"mean"</code> - calculate average values of local population densities from adjacent cells, <code>"geometric_mean"</code> - calculate geometric mean values of local population densities from adjacent cells, or <code>"focal"</code> assign a value from the focal cell</p>
</td></tr>
<tr><td><code id="lsp_signature_+3A_wecoma_na_action">wecoma_na_action</code></td>
<td>
<p>For <code>"wecoma"</code> and <code>"wecove"</code> only. Decides on how to behave in the presence of missing values in <code>w</code>. Possible options are <code>"replace"</code>, <code>"omit"</code>, <code>"keep"</code>. The default, <code>"replace"</code>, replaces missing values with 0, <code>"omit"</code> does not use cells with missing values, and <code>"keep"</code> keeps missing values.</p>
</td></tr>
<tr><td><code id="lsp_signature_+3A_classes">classes</code></td>
<td>
<p>Which classes (categories) should be analyzed? This parameter expects a list of the same length as the number of attributes in <code>x</code>, where each element of the list contains integer vector. The default is <code>NULL</code>, which means that the classes are calculated directly from the input data and all of them are used in the calculations.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Object of class <code>lsp</code>.
It has three columns: (1) <code>id</code> - an id of each window.
For irregular windows, it is the values provided in the <code>window</code> argument,
(2) <code>na_prop</code> - share (0-1) of <code>NA</code> cells for each window,
(3) <code>signature</code> - a list-column containing calculated signatures
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(stars)

landcover = read_stars(system.file("raster/landcover2015s.tif", package = "motif"))

landcover_coma = lsp_signature(landcover, type = "coma", threshold = 0.9, window = 2000)
landcover_coma

landcover_comp = lsp_signature(landcover, type = "composition", threshold = 0.9)
landcover_comp


# larger data example
library(stars)

landcover = read_stars(system.file("raster/landcover2015.tif", package = "motif"))

landcover_coma = lsp_signature(landcover, type = "coma", threshold = 0.9, window = 2000)
landcover_coma

landcover_comp = lsp_signature(landcover, type = "composition", threshold = 0.9)
landcover_comp

</code></pre>

<hr>
<h2 id='lsp_to_dist'>Calculate Distance Matrix</h2><span id='topic+lsp_to_dist'></span>

<h3>Description</h3>

<p>Calculates a distance matrix based on an object of class <code>lsp</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lsp_to_dist(x, dist_fun, unit = "log2", p = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lsp_to_dist_+3A_x">x</code></td>
<td>
<p>An object of class <code>lsp</code> - usually the output of
the <code>lsp_signature()</code> function</p>
</td></tr>
<tr><td><code id="lsp_to_dist_+3A_dist_fun">dist_fun</code></td>
<td>
<p>A distance/dissimilarity method used.
All possible values can be found using
the <code><a href="philentropy.html#topic+getDistMethods">philentropy::getDistMethods()</a></code> function</p>
</td></tr>
<tr><td><code id="lsp_to_dist_+3A_unit">unit</code></td>
<td>
<p>A character string specifying the logarithm unit
that should be used to compute distances that depend on log computations:
<code style="white-space: pre;">&#8288;"log", "log2", "log10"&#8288;</code>.
The default is <code>"log"</code></p>
</td></tr>
<tr><td><code id="lsp_to_dist_+3A_p">p</code></td>
<td>
<p>Power of the Minkowski distance.
Used only when the <code>dist_fun = "minkowski"</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class '&quot;dist&quot;&ldquo;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(stars)
landcover = read_stars(system.file("raster/landcover2015s.tif", package = "motif"))

landcover_cove = lsp_signature(landcover, type = "cove", threshold = 0.9, window = 400)
landcover_cove

dist_cov = lsp_to_dist(landcover_cove, dist_fun = "jensen-shannon")
dist_cov


# larger data example
library(stars)
landcover = read_stars(system.file("raster/landcover2015.tif", package = "motif"))

landcover_cove = lsp_signature(landcover, type = "cove", threshold = 0.9, window = 2000)
landcover_cove

dist_cov = lsp_to_dist(landcover_cove, dist_fun = "jensen-shannon")
dist_cov

</code></pre>

<hr>
<h2 id='lsp_transform'>Transforms lsp objects</h2><span id='topic+lsp_transform'></span>

<h3>Description</h3>

<p>It allows for transforming spatial signatures (outputs of
the <code>lsp_signature()</code> function) using user-provided functions.
See examples for more details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lsp_transform(x, fun, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lsp_transform_+3A_x">x</code></td>
<td>
<p>Object of class <code>lsp</code> - usually the output of
the <code>lsp_signature()</code> function.</p>
</td></tr>
<tr><td><code id="lsp_transform_+3A_fun">fun</code></td>
<td>
<p>A user-provided function.</p>
</td></tr>
<tr><td><code id="lsp_transform_+3A_...">...</code></td>
<td>
<p>Additional arguments for <code>fun</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Object of class <code>lsp</code>.
It has three columns: (1) <code>id</code> - an id of each window.
For irregular windows, it is the values provided in the <code>window</code> argument,
(2) <code>na_prop</code> - share (0-1) of <code>NA</code> cells for each window,
(3) <code>signature</code> - a list-column containing with calculated signatures
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(stars)
landform = read_stars(system.file("raster/landforms.tif", package = "motif"))
result_coma500 = lsp_signature(landform, type = "coma", threshold = 0.5, window = 500)

#see how the first signature looks
result_coma500$signature[[1]]

my_function = function(mat){
    mat_c = colSums(mat)
    freqs = mat_c / sum(mat)
    # entropy
    -sum(freqs * log2(freqs), na.rm = TRUE)
}

result_coma500_2 = lsp_transform(result_coma500, my_function)

#see how the first signature looks after transformation
result_coma500_2$signature[[1]]


# larger data example
library(stars)
landform = read_stars(system.file("raster/landform.tif", package = "motif"))
result_coma500 = lsp_signature(landform, type = "coma", threshold = 0.5, window = 500)

#see how the first signature looks
result_coma500$signature[[1]]

my_function = function(mat){
    mat_c = colSums(mat)
    freqs = mat_c / sum(mat)
    # entropy
    -sum(freqs * log2(freqs), na.rm = TRUE)
}

result_coma500_2 = lsp_transform(result_coma500, my_function)

#see how the first signature looks after transformation
result_coma500_2$signature[[1]]

</code></pre>

<hr>
<h2 id='prepare_window'>Prepares window* arguments (internal function)</h2><span id='topic+prepare_window'></span>

<h3>Description</h3>

<p>Prepares window* arguments (internal function)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prepare_window(x, window)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prepare_window_+3A_x">x</code></td>
<td>
<p>Object of class <code>stars</code> or <code>stars_proxy</code></p>
</td></tr>
<tr><td><code id="prepare_window_+3A_window">window</code></td>
<td>
<p>Specifies areas for analysis. It can be either: <code>NULL</code>, a numeric value, or an <code>sf</code> object. If <code>window=NULL</code> calculations are performed for a whole area. If the <code>window</code> argument is numeric, it is a length of the side of a square-shaped block of cells. Expressed in the numbers of cells, it defines the extent of a local pattern. If an <code>sf</code> object is provided, each feature (row) defines the extent of a local pattern. The <code>sf</code> object should have one attribute (otherwise, the first attribute is used as an id).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with <code>window</code>, <code>window_size</code>, and <code>window_shift</code>
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
