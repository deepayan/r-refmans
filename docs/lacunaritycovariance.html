<!DOCTYPE html><html><head><title>Help for package lacunaritycovariance</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {lacunaritycovariance}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#cencovariance'><p>Centred covariance estimation</p></a></li>
<li><a href='#contagdiscstate'><p>Disc State Contagion</p></a></li>
<li><a href='#contagpixelgrid'><p>Pixel Adjacency Contagion</p></a></li>
<li><a href='#coverageprob'><p>Estimate the coverage probability of a stationary RACS</p></a></li>
<li><a href='#cppicka'><p>Picka's Reduced Window Estimator of Coverage Probability</p></a></li>
<li><a href='#gbl'><p>Gliding box lacunarity estimation using all estimators</p></a></li>
<li><a href='#gblc'><p>Gliding box lacunarity estimator using plug-in moment covariance estimator</p></a></li>
<li><a href='#gblcc'><p>Centred covariance based estimates of gliding box lacunarity</p></a></li>
<li><a href='#gblemp'><p>Empirical Gliding Box Lacunarity</p></a></li>
<li><a href='#gblg'><p>Pair-correlation based estimates of gliding box lacunarity</p></a></li>
<li><a href='#innerprod.im'><p>Inner Product of Two Functions Represented as Images</p></a></li>
<li><a href='#isbinarymap'><p>Test if an <code>im</code> object is a binary map</p></a></li>
<li><a href='#lacunaritycovariance-package'><p>lacunaritycovariance: Gliding Box Lacunarity and Other Metrics for 2D Random Closed Sets</p></a></li>
<li><a href='#paircorr'><p>Balanced estimation of pair-correlation.</p></a></li>
<li><a href='#placegrainsfromlib'><p>Place grains randomly on a point pattern</p></a></li>
<li><a href='#plugincvc'><p>Plug-in moment covariance estimator</p></a></li>
<li><a href='#racscovariance'><p>Covariance Estimation</p></a></li>
<li><a href='#rbdd'><p>Simulation of Boolean Model of Deterministic Discs</p></a></li>
<li><a href='#rbdr'><p>Simulation of Boolean Model of Deterministic Rectangles</p></a></li>
<li><a href='#rblnd'><p>Simulate a Boolean model of discs with log normal disc radii</p></a></li>
<li><a href='#rbpto'><p>Simulate Boolean Model with Grains Scaled According to a Truncated</p>
Pareto Distribution</a></li>
<li><a href='#secondorderprops'><p>Estimate Second-Order Properties of a RACS</p></a></li>
<li><a href='#summary.imlist'><p>Pointwise summary of a list of <code>im</code> objects</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Gliding Box Lacunarity and Other Metrics for 2D Random Closed
Sets</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1-7</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-11-02</td>
</tr>
<tr>
<td>Author:</td>
<td>Kassel Liam Hingee</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Kassel Liam Hingee &lt;kassel.hingee@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Functions for estimating the gliding box lacunarity (GBL),
    covariance, and pair-correlation of a random closed set (RACS) in 2D
    from a binary coverage map (e.g. presence-absence land cover maps).
    Contains a number of newly-developed covariance-based estimators of
    GBL (Hingee et al., 2019) &lt;<a href="https://doi.org/10.1007%2Fs13253-019-00351-9">doi:10.1007/s13253-019-00351-9</a>&gt; and
    balanced estimators, proposed by Picka (2000)
    <a href="http://www.jstor.org/stable/1428408">http://www.jstor.org/stable/1428408</a>, for covariance, centred
    covariance, and pair-correlation.  Also contains methods for
    estimating contagion-like properties of RACS and simulating 2D Boolean
    models.  Binary coverage maps are usually represented as raster images
    with pixel values of TRUE, FALSE or NA, with NA representing
    unobserved pixels.  A demo for extracting such a binary map from a
    geospatial data format is provided.  Binary maps may also be
    represented using polygonal sets as the foreground, however for most
    computations such maps are converted into raster images.  The package
    is based on research conducted during the author's PhD studies.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/kasselhingee/lacunaritycovariance">https://github.com/kasselhingee/lacunaritycovariance</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>spatstat (&ge; 2.0-0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>RcppRoll, spatstat.explore (&ge; 3.0-3), spatstat.geom,
spatstat.random</td>
</tr>
<tr>
<td>Suggests:</td>
<td>cubature, sf, terra, testthat</td>
</tr>
<tr>
<td>ByteCompile:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-11-01 21:58:39 UTC; kassel</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-11-02 13:10:07 UTC</td>
</tr>
</table>
<hr>
<h2 id='cencovariance'>Centred covariance estimation</h2><span id='topic+cencovariance'></span><span id='topic+cencovariance.cvchat'></span>

<h3>Description</h3>

<p>This function estimates the centred covariance of a stationary RACS.
Available estimators are the plug-in moment centred covariance estimator, two 'balanced' estimators suggested by Picka (2000),
and a third 'balanced' estimator inspired by one of Picka's pair-correlation estimators.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cencovariance(
  xi,
  obswin = NULL,
  setcov_boundarythresh = NULL,
  estimators = "all",
  drop = FALSE
)

cencovariance.cvchat(
  cvchat,
  cpp1 = NULL,
  phat = NULL,
  setcov_boundarythresh = NULL,
  estimators = "all",
  drop = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cencovariance_+3A_xi">xi</code></td>
<td>
<p>An observation of a RACS of interest as a full binary map (as an <code>im</code> object) or as the foreground set (as an <code>owin</code> object).
In the latter case the observation window, <code>obswin</code>, must be supplied.</p>
</td></tr>
<tr><td><code id="cencovariance_+3A_obswin">obswin</code></td>
<td>
<p>If <code>xi</code> is an <code>owin</code> object then <code>obswin</code> is an
<code>owin</code> object that specifies the observation window.</p>
</td></tr>
<tr><td><code id="cencovariance_+3A_setcov_boundarythresh">setcov_boundarythresh</code></td>
<td>
<p>To avoid instabilities caused by dividing by very small quantities, if the set covariance of the observation window
is smaller than <code>setcov_boundarythresh</code>, then the covariance is given a value of NA.</p>
</td></tr>
<tr><td><code id="cencovariance_+3A_estimators">estimators</code></td>
<td>
<p>A list of strings specifying estimators to use.
See details.
<code>estimators = "all"</code> will select all available estimators.</p>
</td></tr>
<tr><td><code id="cencovariance_+3A_drop">drop</code></td>
<td>
<p>If TRUE and one estimator selected then the returned value will be a single <code>im</code> object and not a list of <code>im</code> object.</p>
</td></tr>
<tr><td><code id="cencovariance_+3A_cvchat">cvchat</code></td>
<td>
<p>The plug-in moment estimate of covariance as an <code>im</code> object.
Typically created with <code><a href="#topic+plugincvc">plugincvc</a></code>.</p>
</td></tr>
<tr><td><code id="cencovariance_+3A_cpp1">cpp1</code></td>
<td>
<p>Picka's reduced window estimate of coverage probability as an <code>im</code> object - used in improved (balanced) covariance estimators.
Can be generated using <code><a href="#topic+cppicka">cppicka</a></code>.</p>
</td></tr>
<tr><td><code id="cencovariance_+3A_phat">phat</code></td>
<td>
<p>The usual estimate of coverage probability,
which is the observed foreground area in <code>xi</code> divided by the total area of the observation window.
See <code><a href="#topic+coverageprob">coverageprob</a></code> for more information.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The centred covariance of a stationary RACS is </p>
<p style="text-align: center;"><code class="reqn">\kappa(v) =
  C(v) - p^2.</code>
</p>

<p>The estimators available are (see (Section 3.4, Hingee, 2019) for
more information):
</p>

<ul>
<li><p><code>plugin</code> the plug-in moment centred
covariance estimator
</p>
</li>
<li><p><code>mattfeldt</code> an estimator inspired by an
'intrinsically' balanced pair-correlation estimator from Picka (1997) that was
later studied in an isotropic situation by Mattfeldt and Stoyan
(Mattfeldt and Stoyan, 2000)
</p>
</li>
<li><p><code>pickaint</code> Picka's 'intrinsically' balanced
centred covariance estimator (Picka, 2000).
</p>
</li>
<li><p><code>pickaH</code> Picka's
'additively' balanced centred covariance estimator (Picka, 2000).
</p>
</li></ul>

<p>Currently computes centred covariance using <code><a href="#topic+racscovariance">racscovariance</a></code>.
</p>


<h3>Value</h3>

<p>If <code>drop = TRUE</code> and only one estimator is requested then a
<code>im</code> object containing the centred covariance estimate is returned. Otherwise a
named <code>imlist</code> of <code>im</code> objects containing the centred covariance
estimates for each requested estimator.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>cencovariance()</code>: Centred covariance estimates from a binary map.
</p>
</li>
<li> <p><code>cencovariance.cvchat()</code>: Generates centred covariances estimates from
a plug-in moment estimate of covariance, Picka's reduced window estimate of coverage probability,
and the plug-in moment estimate of coverage probability.
If these estimates already exist, then <code><a href="#topic+cencovariance.cvchat">cencovariance.cvchat</a></code> saves significant computation time over <code>cencovariance</code>.
</p>
</li></ul>


<h3>Author(s)</h3>

<p>Kassel Liam Hingee
</p>


<h3>References</h3>

<p>Hingee, K.L. (2019) <em>Spatial Statistics of Random Closed Sets for Earth Observations</em>. PhD: Perth, Western Australia: University of Western Australia. Submitted.
</p>
<p>Mattfeldt, T. and Stoyan, D. (2000) Improved estimation of the pair correlation function of random sets. <em>Journal of Microscopy</em>, 200, 158-173.
</p>
<p>Picka, J.D. (1997) <em>Variance-Reducing Modifications for Estimators of Dependence in Random Sets</em>. Ph.D.: Illinois, USA: The University of Chicago.
</p>
<p>Picka, J.D. (2000) Variance reducing modifications for estimators of standardized moments of random sets. <em>Advances in Applied Probability</em>, 32, 682-700.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>xi &lt;- heather$coarse
obswin &lt;- Frame(xi)
cencovariance(xi, obswin, estimators = "all")

</code></pre>

<hr>
<h2 id='contagdiscstate'>Disc State Contagion</h2><span id='topic+contagdiscstate'></span>

<h3>Description</h3>

<p>Calculates the disc-state contagion landscape metric as described in (Hingee, 2016; Hingee, 2019). The
disc-state contagion landscape metric describes the entropy (mixing) between four
possible states of a disc: </p>
 <ol>
<li><p> the disc is completely
contained in <code class="reqn">\Xi</code> </p>
</li>
<li><p> the disc does not intersect <code class="reqn">\Xi</code> </p>
</li>
<li>
<p>the centre of the disc is in <code class="reqn">\Xi</code> but the disc is not contained in
<code class="reqn">\Xi</code> </p>
</li>
<li><p> the disc intersects <code class="reqn">\Xi</code> but the centre is outside
<code class="reqn">\Xi</code> </p>
</li></ol>

<p>Disc-state contagion is a function of the disc radius.
</p>
<p>The main difference to classical contagion (O'Neill, 1988) is that disc-state contagion
is based on the spherical contact distribution instead of pixel neighbours.
One impact of this design is that the distance with which to quantify the
mixing between <code class="reqn">\Xi</code> and the background may be chosen by the user by
choosing the disc radius (for classical contagion this distance is fixed by
the map resolution).
</p>
<p>Note: to create <code>fv</code> objects the function copies about 20 lines of code from the <span class="pkg">spatstat</span> collection of packages.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>contagdiscstate(XiH, XicH, p, normalise = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="contagdiscstate_+3A_xih">XiH</code></td>
<td>
<p>Conditional spherical contact distribution function for <code class="reqn">\Xi</code>.
Typically this is an <code>fv</code> object but could also be a vector of values.
In applications <code>XiH</code> would likely be estimated from a binary map
using <code><a href="spatstat.explore.html#topic+Hest">Hest</a></code> in <span class="pkg">spatstat.explore</span>.</p>
</td></tr>
<tr><td><code id="contagdiscstate_+3A_xich">XicH</code></td>
<td>
<p>Conditional spherical contact distribution for the complement of
<code class="reqn">\Xi</code>. This is called the Conditional Core Probability in Hingee 2016.
Typically this is an <code>fv</code> object but could also be a vector of values.
In applications <code>XiH</code> would likely be estimated from a binary map using
<code><a href="spatstat.explore.html#topic+Hest">Hest</a></code> in <span class="pkg">spatstat.explore</span>.</p>
</td></tr>
<tr><td><code id="contagdiscstate_+3A_p">p</code></td>
<td>
<p>The coverage probability of <code class="reqn">\Xi</code>. Can be estimated from binary maps using <code><a href="#topic+coverageprob">coverageprob</a></code>.</p>
</td></tr>
<tr><td><code id="contagdiscstate_+3A_normalise">normalise</code></td>
<td>
<p>Optional. If TRUE <code>contagdiscstate</code> normalises the
results so that all RACS return a value between 0 and 1. Default is FALSE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>XiH</code> should be a function of radius that contains (estimates of) the
probability of a disc of radius <code class="reqn">r</code> not intersecting <code class="reqn">\Xi</code> if the
disc's centre is not in <code class="reqn">\Xi</code> </p>
<p style="text-align: center;"><code class="reqn">\code{XiH}(r) = P(B_r(x) \subseteq
  \Xi^c | x \in \Xi^c).</code>
</p>
<p> Similarly <code>XicH</code> should be (an estimate of) the
probability of a disc being fully contained in <code class="reqn">\Xi</code> given its centre
is in <code class="reqn">\Xi</code> </p>
<p style="text-align: center;"><code class="reqn">\code{XicH}(r)\approx P(B_r(x) \subseteq \Xi | x \in
  \Xi).</code>
</p>
<p> These can both be obtained using <code>Hest</code> in
<span class="pkg">spatstat</span>. For <code>XicH</code> take care to apply <code>Hest</code> to the complement
of <code class="reqn">\Xi</code> with the observation window <code class="reqn">W</code>.
</p>
<p>If <code>normalise</code> is <code>TRUE</code> then the result is divided by
<code class="reqn">-2ln(2)</code> and increased by 1 so that contagion will always be between 0
and 1.
</p>


<h3>Value</h3>

<p>If <code>XiH</code> is an <code>fv</code> object then an <code>fv</code> object is returned.
If <code>XiH</code> is a vector then the returned object is a vector the same length as <code>XiH</code> with each element
corresponding to the contagion at each <code>r</code> value of <code>XiH</code>.
</p>


<h3>References</h3>

<p>Hingee, K.L. (2016) Statistics for patch observations. <em>International Archives of the Photogrammetry, Remote Sensing and Spatial Information Sciences</em> pp. 235-242. Prague: ISPRS.
</p>
<p>Hingee, K.L. (2019) <em>Spatial Statistics of Random Closed Sets for Earth Observations</em>. PhD: Perth, Western Australia: University of Western Australia. Submitted.
</p>
<p>O'Neill, R.V., Krummel, J.R., Gardner, R.H., Sugihara, G., Jackson, B., DeAngelis, D.L., et al. (1988) Indices of landscape pattern. <em>Landscape Ecology</em>, 1, 153-162.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>xi &lt;- heather$coarse
obswindow &lt;- Frame(heather$coarse)
p &lt;- coverageprob(xi, Frame(xi))
xiH &lt;- Hest(xi, W = obswindow) #Sph. Contact Distrution Estimate
xicH &lt;- Hest(complement.owin(xi), W = obswindow) #Conditional Core Prob. Estimate

contagion &lt;- contagdiscstate(xiH, xicH, p)

</code></pre>

<hr>
<h2 id='contagpixelgrid'>Pixel Adjacency Contagion</h2><span id='topic+contagpixelgrid'></span><span id='topic+adjacency'></span>

<h3>Description</h3>

<p>Function for calculating the classic pixel-adjacency contagion landscape metric from a binary map (O'Neill, 1988).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>contagpixelgrid(xi, obswin, normalise = FALSE)

adjacency(xi, obswin = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="contagpixelgrid_+3A_xi">xi</code></td>
<td>
<p>A raster binary map (as an <code>im</code> object) or as a foreground set (as an <code>owin</code> object).
In the latter case the observation window, <code>obswin</code>, must be supplied.
See <code><a href="#topic+lacunaritycovariance-package">lacunaritycovariance-package</a></code> for details.
If <code>xi</code> is an <code>owin</code> object it must be of <code>mask</code> type.</p>
</td></tr>
<tr><td><code id="contagpixelgrid_+3A_obswin">obswin</code></td>
<td>
<p>If <code>xi</code> is an <code>owin</code> object then <code>obswin</code> is an
<code>owin</code> object that specifies the observation window.</p>
</td></tr>
<tr><td><code id="contagpixelgrid_+3A_normalise">normalise</code></td>
<td>
<p>If <code>TRUE</code> will divide result by <code class="reqn">2 ln(2)</code> and add 1 to make contagion between 0 and 1 for all binary maps.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The unnormalised contagion landscape metric of categorical map is defined as
</p>
<p style="text-align: center;"><code class="reqn">\sum_i \sum_j Qij ln(Qij),</code>
</p>
<p> where <code class="reqn">Qij</code> is the probability of
randomly selected adjacent pixels being in class <code class="reqn">i</code> and class <code class="reqn">j</code>
respectively, and <code class="reqn">m</code> is the number of classes.
</p>
<p>Here <code class="reqn">m = 2</code> as <code>xi</code> is a binary map and we have defined 'adjacent'
pixels using the 4-neighbourhood regime.
</p>
<p>Contagion is calculated from an adjacency matrix created using the function <code>adjacency</code>.
The adjacency matrix is a 2 by 2 table containing the number of pairs of neighbouring pixels (where order matters) such that:
</p>

<table>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"> Second pixel in <code>xi</code> </td><td style="text-align: left;"> Second pixel not in <code>xi</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
First pixel in <code>xi</code> </td><td style="text-align: left;"> - </td><td style="text-align: left;"> - </td>
</tr>
<tr>
 <td style="text-align: left;">
First pixel not in <code>xi</code> </td><td style="text-align: left;"> - </td><td style="text-align: left;"> -
</td>
</tr>

</table>



<h3>Value</h3>

<p>The computed pixel-adjacency contagion value. If <code>normalise</code> is <code>TRUE</code> then the value will be between 0 and 1. Otherwise the value will be negative.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>contagpixelgrid()</code>: Pixel-adjacency contagion landscape metric of a binary map.
</p>
</li>
<li> <p><code>adjacency()</code>: Calculates the adjacency matrix used in the pixel contagion
</p>
</li></ul>


<h3>Warning</h3>

<p>Will fail if map is either all foreground or all background.
</p>


<h3>References</h3>

<p>O'Neill, R.V., Krummel, J.R., Gardner, R.H., Sugihara, G., Jackson, B., DeAngelis, D.L., et al. (1988) Indices of landscape pattern. <em>Landscape Ecology</em>, 1, 153-162.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>xi &lt;- heather$coarse
obswin &lt;- owin(xrange = c(0,7),yrange=c(0,16))
adjmat &lt;- adjacency(xi,obswin)
pixeladjcontagion &lt;- contagpixelgrid(xi,obswin)
</code></pre>

<hr>
<h2 id='coverageprob'>Estimate the coverage probability of a stationary RACS</h2><span id='topic+coverageprob'></span><span id='topic+coveragefrac'></span><span id='topic+cp'></span>

<h3>Description</h3>

<p>Computes the proportion of the observation window that is foreground, which is the usual estimate for the coverage probability of a stationary RACS from a binary map.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coverageprob(xi, obswin = NULL)

coveragefrac(xi, obswin = NULL)

cp(xi, obswin = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coverageprob_+3A_xi">xi</code></td>
<td>
<p>An observation of a RACS of interest as a full binary map (as an <code>im</code> object) or as the foreground set (as an <code>owin</code> object).
In the latter case the observation window, <code>obswin</code>, must be supplied.</p>
</td></tr>
<tr><td><code id="coverageprob_+3A_obswin">obswin</code></td>
<td>
<p>The window of observation (not necessarily rectangular) also as an <code>owin</code> object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The coverage probability of a stationary RACS is the probability that an arbitrary point is covered by the RACS.
Given a binary map, <code>xi</code>, of a realisation of stationary RACS <code class="reqn">\Xi</code> in a window <code class="reqn">W</code>,
this function computes the fraction of <code class="reqn">W</code> covered by foreground,
which is an estimate of the coverage probability.
See (Chiu et al., 2013, Section 6.4.2) for more details.
</p>
<p>If <code>xi</code> is an <code>im</code> object then <code>xi</code> must be an image of 1s, 0s and NAs
representing inside the set, outside the set and outside the observation window respectively.
<code>coverageprob</code> will not accept a <code>obswin</code> argument if <code>xi</code> is an <code>im</code> object.
</p>


<h3>Value</h3>

<p>An estimate of the coverage probability
</p>


<h3>Author(s)</h3>

<p>Kassel Liam Hingee
</p>


<h3>References</h3>

<p>Chiu, S.N., Stoyan, D., Kendall, W.S. and Mecke, J. (2013) Stochastic Geometry and Its Applications, 3rd ed. Chichester, United Kingdom: John Wiley &amp; Sons.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>xi &lt;- heather$coarse
obswindow &lt;- Frame(heather$coarse)
cp &lt;- coverageprob(xi, obswindow)
</code></pre>

<hr>
<h2 id='cppicka'>Picka's Reduced Window Estimator of Coverage Probability</h2><span id='topic+cppicka'></span>

<h3>Description</h3>

<p>This function provides estimates of coverage probability from subsets of the observation window,
which are a key component of balanced estimators of covariance, centred covariance, pair-correlation and gliding box lacunarity.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cppicka(xi, obswin = NULL, setcov_boundarythresh = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cppicka_+3A_xi">xi</code></td>
<td>
<p>An observation of a RACS of interest as a full binary map (as an <code>im</code> object) or as the foreground set (as an <code>owin</code> object).
In the latter case the observation window, <code>obswin</code>, must be supplied.</p>
</td></tr>
<tr><td><code id="cppicka_+3A_obswin">obswin</code></td>
<td>
<p>If <code>xi</code> is an <code>owin</code> object then <code>obswin</code> is an
<code>owin</code> object that specifies the observation window.</p>
</td></tr>
<tr><td><code id="cppicka_+3A_setcov_boundarythresh">setcov_boundarythresh</code></td>
<td>
<p>To avoid instabilities caused by dividing by very small quantities, if the set covariance of the observation window
is smaller than <code>setcov_boundarythresh</code>, then the returned pixel value is NA.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The plug-in moment covariance estimator (<code><a href="#topic+plugincvc">plugincvc</a></code>) uses less of the observation window than the usual coverage probability estimators.
Picka (1997, 2000) created new 'balanced' estimators of centred covariance and pair-correlation
that accounted for this difference.
A key component of Picka's estimators is an estimate of the coverage probability from the subregion of the binary map that is
the intersection between <code class="reqn">W</code> and <code class="reqn">W</code> shifted by vector <code class="reqn">v</code>, where <code class="reqn">W</code> is the observation window (p.~687, Picka, 2000).
If we treat <code class="reqn">X</code> and <code class="reqn">W</code> as indicator functions representing the foreground and observation window respectively,
this coverage probability estimator used by Picka is
</p>
<p style="text-align: center;"><code class="reqn"> \frac{\int X(u) W(u) W(u - v) du} {\int W(u) W(u - v) du}. </code>
</p>

<p><code>cppicka</code> produces these estimates for an array of vectors <code class="reqn">v</code> using fast Fourier transforms.
</p>


<h3>Value</h3>

<p>An <code>im</code> object. Pixel values correspond to estimates of the coverage probability
from the subregion of the observation window, <code class="reqn">W</code>, that is the intersection of <code class="reqn">W</code> and <code class="reqn">W</code> shifted by vector <code class="reqn">v</code>, where <code class="reqn">v</code> is the pixel location.
</p>


<h3>Author(s)</h3>

<p>Kassel Liam Hingee
</p>


<h3>References</h3>

<p>Picka, J.D. (1997) <em>Variance-Reducing Modifications for Estimators of Dependence in Random Sets</em>. Ph.D.: Illinois, USA: The University of Chicago.
</p>
<p>Picka, J.D. (2000) Variance reducing modifications for estimators of standardized moments of random sets. <em>Advances in Applied Probability</em>, 32, 682-700.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>xi &lt;- heather$coarse
obswindow &lt;- Frame(heather$coarse)
cp &lt;- coverageprob(xi, obswindow)
cpp1 &lt;- cppicka(xi, obswindow)
</code></pre>

<hr>
<h2 id='gbl'>Gliding box lacunarity estimation using all estimators</h2><span id='topic+gbl'></span><span id='topic+gbl.cvchat'></span>

<h3>Description</h3>

<p>Estimates gliding box lacunarity (GBL) for square boxes using all estimators described in (Hingee et al., 2017).
It calls the functions <code><a href="#topic+gblc">gblc</a></code>, <code><a href="#topic+gblg">gblg</a></code>, <code><a href="#topic+gblcc">gblcc</a></code> and <code><a href="#topic+gblemp">gblemp</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gbl(
  xi,
  boxwidths,
  estimators = c("GBLcc.pickaH"),
  obswin = NULL,
  includenormed = FALSE,
  setcov_boundarythresh = 1e-06
)

gbl.cvchat(
  boxwidths,
  estimators = c("GBLg.mattfeldt", "GBLg.pickaint", "GBLg.pickaH", "GBLcc.mattfeldt",
    "GBLcc.pickaint", "GBLc"),
  phat = NULL,
  cvchat = NULL,
  cpp1 = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gbl_+3A_xi">xi</code></td>
<td>
<p>An observation of a RACS of interest as a full binary map (as an <code>im</code> object) or as the foreground set (as an <code>owin</code> object).
In the latter case the observation window, <code>obswin</code>, must be supplied.</p>
</td></tr>
<tr><td><code id="gbl_+3A_boxwidths">boxwidths</code></td>
<td>
<p>A list of box widths</p>
</td></tr>
<tr><td><code id="gbl_+3A_estimators">estimators</code></td>
<td>
<p>A vector of estimator names - see details for possible names. <code>estimators = "all"</code> will select all estimators.</p>
</td></tr>
<tr><td><code id="gbl_+3A_obswin">obswin</code></td>
<td>
<p>If <code>xi</code> is an <code>owin</code> object then <code>obswin</code> is an
<code>owin</code> object that specifies the observation window.</p>
</td></tr>
<tr><td><code id="gbl_+3A_includenormed">includenormed</code></td>
<td>
<p>A logical value. If TRUE then GBL estimates normalised by the GBL values at zero will be included in a returned list of <code>fv</code> objects</p>
</td></tr>
<tr><td><code id="gbl_+3A_setcov_boundarythresh">setcov_boundarythresh</code></td>
<td>
<p>To avoid instabilities caused by dividing by very small quantities, if the set covariance of the observation window
is smaller than <code>setcov_boundarythresh</code>, then the covariance is given a value of NA.
If NULL is supplied (default) then <code>setcov_boundarythresh</code> is set to 1E-6.</p>
</td></tr>
<tr><td><code id="gbl_+3A_phat">phat</code></td>
<td>
<p>The fraction of foreground area in the observation window, which is the usual estimator of coverage probability given by <code><a href="#topic+coverageprob">coverageprob</a></code>.</p>
</td></tr>
<tr><td><code id="gbl_+3A_cvchat">cvchat</code></td>
<td>
<p>The plug-in moment covariance estimate (often from <code><a href="#topic+plugincvc">plugincvc</a></code>).</p>
</td></tr>
<tr><td><code id="gbl_+3A_cpp1">cpp1</code></td>
<td>
<p>Picka's estimate of coverage probability for subsets of the observation window. See <code><a href="#topic+cppicka">cppicka</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>As empirical GBL is one of the GBL estimators available through this function, non-square boxes are not allowed.
To estimate GBL for non-square boxes use <code>gblcc</code> or <code>gblg</code> directly.
</p>
<p>If <code>xi</code> is an <code>owin</code> object then <code>obswin</code> and <code>xi</code> are converted
into an <code>im</code> object using <code><a href="spatstat.geom.html#topic+as.im">as.im</a></code>
</p>
<p>The estimators available are
</p>

<ul>
<li><p><code>"GBLc"</code> The unmodified (unbalanced) covariance estimator provided by <code><a href="#topic+gblc">gblc</a></code>
</p>
</li>
<li><p><code>"GBLemp"</code> Empirical gliding box lacunarity (Allain and Cloitre, 1991). Calls <code><a href="#topic+gblemp">gblemp</a></code>
</p>
</li>
<li><p><code>"GBLg.mattfeldt"</code> See help for <code><a href="#topic+gblg">gblg</a></code> and <code><a href="#topic+paircorr">paircorr</a></code>
</p>
</li>
<li><p><code>"GBLg.pickaint"</code> See help for <code><a href="#topic+gblg">gblg</a></code> and <code><a href="#topic+paircorr">paircorr</a></code>
</p>
</li>
<li><p><code>"GBLg.pickaH"</code> See help for <code><a href="#topic+gblg">gblg</a></code> and <code><a href="#topic+paircorr">paircorr</a></code>
</p>
</li>
<li><p><code>"GBLcc.mattfeldt"</code> See help for <code><a href="#topic+gblcc">gblcc</a></code>
</p>
</li>
<li><p><code>"GBLcc.pickaint"</code> See help for <code><a href="#topic+gblcc">gblcc</a></code>
</p>
</li>
<li><p><code>"GBLcc.pickaH"</code> See help for <code><a href="#topic+gblcc">gblcc</a></code>
</p>
</li></ul>

<p>The default, GBLcc.pickaH, is a method based on centred covariance.
Centred covariance approaches zero for large vectors, and are thus easier to integrate with the set covariance of the boxes.
</p>
<p>The set covariance of the boxes is computed empirically using <span class="pkg">spatstat</span>'s <code><a href="spatstat.geom.html#topic+setcov">setcov</a></code> function, which converts <code class="reqn">B</code> into a binary pixel mask using <code><a href="spatstat.geom.html#topic+as.mask">as.mask</a></code> defaults. Computation speed can be increased by setting a small default number of pixels, <code>npixel</code>, in <span class="pkg">spatstat</span>'s global options (accessed through <code><a href="spatstat.geom.html#topic+spatstat.options">spatstat.options</a></code>), however fewer pixels also decreases the accuracy of the GBL computation.
</p>


<h3>Value</h3>

<p>An <code>fv</code> object.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>gbl()</code>: computes GBL estimates from a binary map.
</p>
</li>
<li> <p><code>gbl.cvchat()</code>: computes covariance-based estimator of GBL from the plug-in moment estimate of covariance,
Picka's reduced window coverage probability estimates (see <code><a href="#topic+cppicka">cppicka</a></code>) and the usual coverage probability estimate, <code>phat</code>.
</p>
</li></ul>


<h3>References</h3>

<p>Allain, C. and Cloitre, M. (1991) Characterizing the lacunarity of random and deterministic fractal sets. <em>Physical Review A</em>, 44, 3552-3558.
</p>
<p>Hingee K, Baddeley A, Caccetta P, Nair G (2019). Computation of lacunarity from covariance of spatial binary maps. <em>Journal of Agricultural, Biological and Environmental Statistics</em>, 24, 264-288. DOI: 10.1007/s13253-019-00351-9.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>xi &lt;- as.im(heather$coarse, value = TRUE,
            na.replace = FALSE)
boxwidths &lt;- seq(1, 10, by = 0.5)

# reduce resolution in setcov() for faster (less accurate) computation 
oldopt &lt;- spatstat.options()
spatstat.options("npixel" = 2^5)

gblests &lt;- gbl(xi, boxwidths, estimators = "GBLcc.pickaH")
spatstat.options(oldopt)
</code></pre>

<hr>
<h2 id='gblc'>Gliding box lacunarity estimator using plug-in moment covariance estimator</h2><span id='topic+gblc'></span>

<h3>Description</h3>

<p>Can be used to estimate the gliding box lacunarity (GBL) of a stationary RACS from a binary map
using the plug-in moment covariance covariance estimator (Hingee et al., 2019).
It can also calculate the GBL of a RACS from a given covariance function and coverage probability.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gblc(
  boxes,
  covariance = NULL,
  p = NULL,
  xiim = NULL,
  integrationMethod = "cubature"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gblc_+3A_boxes">boxes</code></td>
<td>
<p>Either a list of side lengths for square boxes or a list of <code>owin</code> objects of any shape.</p>
</td></tr>
<tr><td><code id="gblc_+3A_covariance">covariance</code></td>
<td>
<p>A <code>im</code> object containing the covariance function</p>
</td></tr>
<tr><td><code id="gblc_+3A_p">p</code></td>
<td>
<p>The coverage probability. Typically estimated by the fraction of the observation window covered by the set of interest.</p>
</td></tr>
<tr><td><code id="gblc_+3A_xiim">xiim</code></td>
<td>
<p>A binary coverage map as an <code>im</code> object. <code>xiim</code> must have values of either 1, 0 or NA; 1 denotes inside the RACS, 0 denotes outside, and NA denotes unobserved.</p>
</td></tr>
<tr><td><code id="gblc_+3A_integrationmethod">integrationMethod</code></td>
<td>
<p>The integration method used by <code><a href="#topic+innerprod.im">innerprod.im()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Computes a numerical approximation of
</p>
<p style="text-align: center;"><code class="reqn">\int \gamma_B(v) C(v) dv / (p^2 |B|^2).</code>
</p>

<p>where <code class="reqn">B</code> is each of the sets (often called a box) specified by <code>boxes</code>,
<code class="reqn">\gamma_B</code> is the set covariance of <code class="reqn">B</code>,
<code class="reqn">|B|</code> is the area of <code class="reqn">B</code>,
<code class="reqn">p</code> is the coverage probability of a stationary RACS, and
<code class="reqn">C(v)</code> is the covariance of a stationary RACS.
This can be used to compute the GBL from model parameters by passing <code>gblc</code> the
covariance and coverage probability of the model.
</p>
<p>The set covariance of <code class="reqn">B</code> is computed empirically using <span class="pkg">spatstat</span>'s <code><a href="spatstat.geom.html#topic+setcov">setcov</a></code> function, which converts <code class="reqn">B</code> into a binary pixel mask using <code><a href="spatstat.geom.html#topic+as.mask">as.mask</a></code> defaults. Computation speed can be increased by setting a small default number of pixels, <code>npixel</code>, in <span class="pkg">spatstat</span>'s global options (accessed through <code><a href="spatstat.geom.html#topic+spatstat.options">spatstat.options</a></code>), however fewer pixels also decreases the accuracy of the GBL computation.
</p>
<p>The default method of integration for the above integral is <code><a href="cubature.html#topic+cubintegrate">cubature::cubintegrate()</a></code> from the <span class="pkg">cubature</span> package.
The '<code>harmonisesum</code>' method is known to produce numerical artefacts (Section 6.2 of (Hingee et al., 2019))
</p>
<p>If a binary map is supplied then <code class="reqn">p</code> and <code class="reqn">C(v)</code> are estimated using
the usual coverage probability estimator and the plug-in moment covariance estimator, respectively
(see <code><a href="#topic+coverageprob">coverageprob</a></code> and <code><a href="#topic+plugincvc">plugincvc</a></code>).
</p>


<h3>Value</h3>

<p>If <code>boxes</code> is a list of numerical values then GBL is estimated
for square boxes with side length given by <code>boxes</code>.
The returned object is then an <code>fv</code> object containing estimates of GBL,
box mass variance and box mass mean.
If <code>boxes</code> is a list of <code>owin</code> objects then <code>gblc</code> returns a
dataframe with columns corresponding to estimates of GBL, box mass variance and box mass mean.
</p>
<p>Note if <code>NA</code> or <code>NaN</code> values in the <code>covariance</code> object are used then <code>gblc</code> will return <code>NA</code> or <code>NaN</code>.
</p>


<h3>References</h3>

<p>Hingee K, Baddeley A, Caccetta P, Nair G (2019). Computation of lacunarity from covariance of spatial binary maps. <em>Journal of Agricultural, Biological and Environmental Statistics</em>, 24, 264-288. DOI: 10.1007/s13253-019-00351-9.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>xi &lt;- heather$coarse

# reduce resolution in setcov() for faster (less accurate) computation 
oldopt &lt;- spatstat.options()
spatstat.options("npixel" = 2^5)

covar &lt;- plugincvc(xi, Frame(xi))
p &lt;- area(xi) / area(Frame(xi))
sidelengths &lt;- seq(0.3, 14, by = 1)

# compute GBL estimate for square boxes from estimated covariance
gblest &lt;- gblc(sidelengths, covar, p)

# compute GBL estimate for boxes that are discs 
discboxes &lt;- lapply(sidelengths / 2, disc)
discgbls &lt;- gblc(discboxes, covar, p)

# compute GBL estimates from binary map
xiim &lt;- as.im(xi, na.replace = 0)
gblest &lt;- gblc(sidelengths, xiim = xiim)

spatstat.options(oldopt)

</code></pre>

<hr>
<h2 id='gblcc'>Centred covariance based estimates of gliding box lacunarity</h2><span id='topic+gblcc'></span><span id='topic+gblcc.inputcovar'></span>

<h3>Description</h3>

<p>Estimates the gliding box lacunarity (GBL) of a stationary RACS using centred covariance estimates (Hingee et al., 2017).
The centred covariance and coverage probability can be provided or estimated from binary map.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gblcc(
  boxes,
  cencovar = NULL,
  p = NULL,
  xiim = NULL,
  estimator = "pickaH",
  integrationMethod = "harmonisesum"
)

gblcc.inputcovar(boxes, cencovar, p, integrationMethod = "harmonisesum")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gblcc_+3A_boxes">boxes</code></td>
<td>
<p>Either a list of side lengths for square boxes or a list of <code>owin</code> objects of any shape.</p>
</td></tr>
<tr><td><code id="gblcc_+3A_cencovar">cencovar</code></td>
<td>
<p>A <code>im</code> object containing the centred covariance function</p>
</td></tr>
<tr><td><code id="gblcc_+3A_p">p</code></td>
<td>
<p>The coverage probability. Typically estimated by the fraction of the observation window covered by the set of interest.</p>
</td></tr>
<tr><td><code id="gblcc_+3A_xiim">xiim</code></td>
<td>
<p>An observation of a stationary RACS as an <code>im</code> object. <code>xiim</code> must have values of either 1, 0 or NA; 1 denotes inside the RACS, 0 denotes outside, and NA denotes unobserved.</p>
</td></tr>
<tr><td><code id="gblcc_+3A_estimator">estimator</code></td>
<td>
<p>If an observation <code>xiim</code> is passed then <code>estimator</code> will select the balancing method that <code>ccvc</code> uses to estimate the centred covariance.</p>
</td></tr>
<tr><td><code id="gblcc_+3A_integrationmethod">integrationMethod</code></td>
<td>
<p>The integration method used by <code><a href="#topic+innerprod.im">innerprod.im()</a></code>. Default is 'harmonisesum' due centred covariance approaching zero for large vectors.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If we denote the estimated centred covariance by
<code class="reqn">\hat{\kappa}(v)</code> and coverage probability <code class="reqn">\hat{p}</code> then
the estimate of GBL is
</p>
<p style="text-align: center;"><code class="reqn">1 + \frac{1}{\hat{p}^2 |B|^2}\int \gamma_B(v)\hat{\kappa}(v)dv, </code>
</p>

<p>where <code class="reqn">B</code> is each of the sets (often called a box) specified by <code>boxes</code>,
<code class="reqn">\gamma_B</code> is the set covariance of <code class="reqn">B</code>,
<code class="reqn">|B|</code> is the area of <code class="reqn">B</code>,
<code class="reqn">p</code> is the coverage probability of a stationary RACS.
</p>
<p>The set covariance of <code class="reqn">B</code> is computed empirically using <span class="pkg">spatstat</span>'s <code><a href="spatstat.geom.html#topic+setcov">setcov</a></code> function, which converts <code class="reqn">B</code> into a binary pixel mask using <code><a href="spatstat.geom.html#topic+as.mask">as.mask</a></code> defaults. Computation speed can be increased by setting a small default number of pixels, <code>npixel</code>, in <span class="pkg">spatstat</span>'s global options (accessed through <code><a href="spatstat.geom.html#topic+spatstat.options">spatstat.options</a></code>), however fewer pixels also decreases the accuracy of the GBL computation.
</p>


<h3>Value</h3>

<p>If <code>boxes</code> is a list of numerical values then GBL is estimated for square boxes with side length given by <code>boxes</code>.
The returned object is then an <code>fv</code> object containing estimates of GBL, box mass variance and box mass mean.
</p>
<p>If <code>boxes</code> is a list of <code>owin</code> objects then <code>gblcc</code> returns a dataframe of with columns corresponding to estimates of GBL, box mass variance and box mass mean.
Note if <code>NA</code> or <code>NaN</code> values in the <code>covariance</code> object are used then <code>gblc</code> will return <code>NA</code> or <code>NaN</code> instead of an GBL value.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>gblcc.inputcovar()</code>: GBL estimates from already estimated centred covariance.
</p>
</li></ul>


<h3>References</h3>

<p>Hingee K, Baddeley A, Caccetta P, Nair G (2019). Computation of lacunarity from covariance of spatial binary maps. <em>Journal of Agricultural, Biological and Environmental Statistics</em>, 24, 264-288. DOI: 10.1007/s13253-019-00351-9.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>xi &lt;- heather$coarse
cencovar &lt;- cencovariance(xi, obswin = Frame(xi), estimators = c("pickaH"), drop = TRUE)
p &lt;- area(xi) / area(Frame(xi))
sidelengths &lt;- seq(0.3, 14, by = 1)

# reduce resolution in setcov() for faster (less accurate) computation 
oldopt &lt;- spatstat.options()
spatstat.options("npixel" = 2^5)

# compute GBL estimate for square boxes from estimated centred covariance
gblccest &lt;- gblcc(sidelengths, cencovar, p)

# compute GBL estimate for boxes that are discs
discboxes &lt;- lapply(sidelengths / 2, disc)
discgbls &lt;- gblcc(discboxes, cencovar, p)

# compute GBL estimates from binary map
xiim &lt;- as.im(xi, na.replace = 0)
gblccest &lt;- gblcc(sidelengths, xiim = xiim, estimator = "pickaH")

spatstat.options(oldopt)

</code></pre>

<hr>
<h2 id='gblemp'>Empirical Gliding Box Lacunarity</h2><span id='topic+gblemp'></span><span id='topic+gbltrad'></span>

<h3>Description</h3>

<p>Calculates empirical gliding box lacunarity of a binary map, which was proposed by Allain and Cloitre (1991).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gblemp(boxwidths, xiim, obswin = Frame(xiim))

gbltrad(boxwidths, xiim, obswin = Frame(xiim))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gblemp_+3A_boxwidths">boxwidths</code></td>
<td>
<p>A list of suggested box widths in the same units as <code>xiim</code>.
Note the actual box widths used by <code>gblemp</code> will be the closest multiple of an odd number of pixel widths.</p>
</td></tr>
<tr><td><code id="gblemp_+3A_xiim">xiim</code></td>
<td>
<p>An image of pixels valued either <code>0</code>, <code>1</code> or <code>NA</code>. <code>NA</code> valued pixels are assumed to be outside the observation window.</p>
</td></tr>
<tr><td><code id="gblemp_+3A_obswin">obswin</code></td>
<td>
<p>Optional observation window. The observation window used for the estimator will be the intersection of <code>obswin</code> and the pixels that are not <code>NA</code> in <code>xiim</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Calculates empirical gliding box lacunarity (Allain and Cloitre, 1991) for a given range of square box sizes,
</p>
<p style="text-align: center;"><code class="reqn">1 + Var(area(B . xi)) / E[area(B . xi)]^2, </code>
</p>

<p>where <code class="reqn">B</code> is a box that has a random location in the observation window and <code class="reqn">area(B . xi)</code> is the (random) area of the foreground in <code class="reqn">B</code>.
This is an estimate of the gliding box lacunarity of a RACS (Hingee et al., 2017).
</p>
<p>The algorithm uses the pixel locations in <code>xiim</code> as an array of box centre locations to compute
the mean and variance of the area in a random box of a given size.
Locations where the box is not completely within the observation window are ignored.
</p>


<h3>Value</h3>

<p>An <code>fv</code> object containing empirical GBL, variance of the area in the box and mean of the area in the box.
The box widths (labelled <code>s</code>) are always odd multiples of the pixel width.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>gbltrad()</code>: An alias of <code>gblemp</code> used in past versions of this package. This alias may be removed in future versions.
</p>
</li></ul>


<h3>WARNING</h3>

<p>The box side lengths are rounded such that they are an odd number of pixels across.
<code>gblemp</code> uses the <code><a href="RcppRoll.html#topic+roll_sum">roll_sum</a></code> function in <span class="pkg">RcppRoll</span> to operate, so <span class="pkg">RcppRoll</span> must be installed to run <code>gblemp</code>.
</p>


<h3>References</h3>

<p>Allain, C. and Cloitre, M. (1991) Characterizing the lacunarity of random and deterministic fractal sets. <em>Physical Review A</em>, 44, 3552-3558.
</p>
<p>Hingee K, Baddeley A, Caccetta P, Nair G (2019). Computation of lacunarity from covariance of spatial binary maps. <em>Journal of Agricultural, Biological and Environmental Statistics</em>, 24, 264-288. DOI: 10.1007/s13253-019-00351-9.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>xiim &lt;- as.im(heather$coarse, na.replace = 0)
boxwidths &lt;- seq(0.2, 14, by = 0.2) #in units of xiim
gblest &lt;- gblemp(boxwidths, xiim)

</code></pre>

<hr>
<h2 id='gblg'>Pair-correlation based estimates of gliding box lacunarity</h2><span id='topic+gblg'></span>

<h3>Description</h3>

<p>Estimates the gliding box lacunarity (GBL) of a stationary RACS by estimating pair-correlation from a binary map (Hingee et al., 2017).
It can also calculate the GBL of a RACS from a provided pair-correlation function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gblg(boxes, paircorr = NULL, xiim = NULL, integrationMethod = "cubature")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gblg_+3A_boxes">boxes</code></td>
<td>
<p>Either a list of side lengths for square boxes or a list of <code>owin</code> objects of any shape.</p>
</td></tr>
<tr><td><code id="gblg_+3A_paircorr">paircorr</code></td>
<td>
<p>A <code>im</code> object containing the pair-correlation function</p>
</td></tr>
<tr><td><code id="gblg_+3A_xiim">xiim</code></td>
<td>
<p>An observation of a stationary RACS as an <code>im</code> object. <code>xiim</code> must have values of either 1, 0 or NA; 1 denotes inside the RACS, 0 denotes outside, and NA denotes unobserved.</p>
</td></tr>
<tr><td><code id="gblg_+3A_integrationmethod">integrationMethod</code></td>
<td>
<p>The integration method used by <code><a href="#topic+innerprod.im">innerprod.im()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If we denote the estimated pair-correlation by <code class="reqn">\hat{g}(v)</code> then the estimate of GBL is
</p>
<p style="text-align: center;"><code class="reqn">\frac{1}{|B|^2}\int \gamma_B(v)\hat{g}(v)dv, </code>
</p>

<p>where <code class="reqn">B</code> is each of the sets (often called a box) specified by <code>boxes</code>,
<code class="reqn">\gamma_B</code> is the set covariance of <code class="reqn">B</code>,
<code class="reqn">|B|</code> is the area of <code class="reqn">B</code>,
<code class="reqn">p</code> is the coverage probability of a stationary RACS.
This can be used to compute the GBL from model parameters by passing <code>gblc</code> the
covariance and coverage probability of the model.
</p>
<p>If the <code>xiim</code> argument to <code>gblg</code> is used then pair correlation is estimated from <code>xiim</code> using <code><a href="#topic+paircorr">paircorr</a></code> and the <code>pickaH</code> estimator.
</p>
<p>The set covariance of <code class="reqn">B</code> is computed empirically using <span class="pkg">spatstat</span>'s <code><a href="spatstat.geom.html#topic+setcov">setcov</a></code> function, which converts <code class="reqn">B</code> into a binary pixel mask using <code><a href="spatstat.geom.html#topic+as.mask">as.mask</a></code> defaults. Computation speed can be increased by setting a small default number of pixels, <code>npixel</code>, in <span class="pkg">spatstat</span>'s global options (accessed through <code><a href="spatstat.geom.html#topic+spatstat.options">spatstat.options</a></code>), however fewer pixels also decreases the accuracy of the GBL computation.
</p>
<p>The default integration method for this function uses <code><a href="cubature.html#topic+cubintegrate">cubature::cubintegrate()</a></code> from the <span class="pkg">cubature</span> package.
The 'harmonisesum' integration method is known to produce numerical artefacts (Section 6.2 of (Hingee et al., 2019))
</p>


<h3>Value</h3>

<p>If <code>boxes</code> is a list of numerical values then GBL is estimated for square boxes with side length given by <code>boxes</code>.
The returned object is then an <code>fv</code> object containing estimates of GBL.
If <code>boxes</code> is a list of <code>owin</code> objects then <code>gblg</code> returns a dataframe of with columns corresponding to estimates of GBL.
</p>
<p>Note that if any values in the <code>paircorr</code> object needed for <code>gblg</code> are <code>NA</code> or <code>NaN</code> then <code>gblg</code> will return <code>NA</code> or <code>NaN</code>, respectively.
</p>


<h3>References</h3>

<p>Hingee K, Baddeley A, Caccetta P, Nair G (2019). Computation of lacunarity from covariance of spatial binary maps. <em>Journal of Agricultural, Biological and Environmental Statistics</em>, 24, 264-288. DOI: 10.1007/s13253-019-00351-9.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>xi &lt;- as.im(heather$coarse, na.replace = 0, eps = 4 * heather$coarse$xstep)
sidelengths &lt;- seq(0.3, 14, by = 3)

# reduce resolution in setcov() for faster (less accurate) computation 
oldopt &lt;- spatstat.options()
spatstat.options("npixel" = 2^4)

# compute GBL estimates from binary map
xiim &lt;- as.im(xi, na.replace = 0)
gblgest &lt;- gblg(sidelengths, xiim = xiim)

spatstat.options(oldopt)

</code></pre>

<hr>
<h2 id='innerprod.im'>Inner Product of Two Functions Represented as Images</h2><span id='topic+innerprod.im'></span>

<h3>Description</h3>

<p>Given two functions, f and g, that map from 2D space to 1D, and values of f and g represented as <code>im</code> objects
then <code>innerprod.im</code> computes the (function space) inner product
</p>
<p style="text-align: center;"><code class="reqn">\int f(v) g(v) dv.</code>
</p>



<h3>Usage</h3>

<pre><code class='language-R'>innerprod.im(
  A,
  B,
  outsideA = NA,
  outsideB = NA,
  na.replace = TRUE,
  method = "cubature"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="innerprod.im_+3A_a">A</code></td>
<td>
<p>An <code>im</code> object containing function values representing function <code class="reqn">f</code>.</p>
</td></tr>
<tr><td><code id="innerprod.im_+3A_b">B</code></td>
<td>
<p>An <code>im</code> object containing function values representing function <code class="reqn">g</code>.</p>
</td></tr>
<tr><td><code id="innerprod.im_+3A_outsidea">outsideA</code></td>
<td>
<p>The value of <code class="reqn">f</code> outside the domain of <code>A</code>. Typically will be 0 or NA. Default is NA.</p>
</td></tr>
<tr><td><code id="innerprod.im_+3A_outsideb">outsideB</code></td>
<td>
<p>The value of <code class="reqn">g</code> outside the domain of <code>B</code>. Typically will be <code>0</code> or <code>NA</code>. Default is <code>NA</code>.</p>
</td></tr>
<tr><td><code id="innerprod.im_+3A_na.replace">na.replace</code></td>
<td>
<p>Logical. If TRUE NA values in <code>A</code> and <code>B</code> are replaced by <code>outsideA</code> and <code>outsideB</code>, respectively. This allows the cubature integration to be performed (roughly) twice as quickly.</p>
</td></tr>
<tr><td><code id="innerprod.im_+3A_method">method</code></td>
<td>
<p>Either &quot;cubature&quot; or &quot;harmonisesum&quot;. The former uses <code><a href="cubature.html#topic+cubintegrate">cubature::cubintegrate()</a></code>,
the latter harmonises the images using <code><a href="spatstat.geom.html#topic+as.mask">spatstat.geom::as.mask()</a></code> and sums the product of <code>A</code> and <code>B</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function uses the package <span class="pkg">cubature</span> to integrate the multiple of the two images. If <span class="pkg">cubature</span> is not available then it harmonises the two input images, multiplies them together and returns the
integral of the resulting image.
<code>outsideA</code> and <code>outsideB</code> are used to determine result if the inner product requires
values outside the domain of A or B. For example if <code>outsideA=0</code> and the
domain of <code>B</code> is larger than <code>A</code>'s domain then the inner product
can still be computed. However if <code>A</code> is <code>NA</code> outside (e.g. not
known/not provided) and the domain of <code>B</code> is larger than <code>A</code>'s
domain then the inner product can not be computed and the returned value is <code>NA</code>
</p>
<p>The <code>harmonisesum</code> method appears to perform well when used by <code><a href="#topic+gblcc">gblcc()</a></code>, but produces numerical artefacts when used by <code><a href="#topic+gblc">gblc()</a></code> and <code><a href="#topic+gblg">gblg()</a></code>. The <code>cubature</code> method takes longer to compute and is more accurate for functions (A or B) that are non-zero for large vectors. This makes it suitable for use by <code><a href="#topic+gblc">gblc()</a></code> and <code><a href="#topic+gblg">gblg()</a></code>.
</p>


<h3>Value</h3>

<p>If the inner product can be computed then returns sum(<code>A</code> * <code>B</code>), otherwise returns <code>NA</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>xi &lt;- heather$coarse
covar &lt;- plugincvc(xi, Frame(xi))
B &lt;- setcov(square(1))
innerprod.im(covar, B, outsideB = 0)
</code></pre>

<hr>
<h2 id='isbinarymap'>Test if an <code>im</code> object is a binary map</h2><span id='topic+isbinarymap'></span>

<h3>Description</h3>

<p>Tests whether <code>xi</code> is a binary map.
The pixel values must be of logical type (<code>TRUE</code>, <code>FALSE</code> and <code>NA</code> only), or numerical (1, 0 or <code>NA</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>isbinarymap(xi, requiretrue = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="isbinarymap_+3A_xi">xi</code></td>
<td>
<p>an image object</p>
</td></tr>
<tr><td><code id="isbinarymap_+3A_requiretrue">requiretrue</code></td>
<td>
<p>Logical. If TRUE then <code>isbinarymap</code> will error if xi is NOT a binary map.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Logical value. <code>TRUE</code> if <code>xi</code> is a binary map. Otherwise <code>FALSE</code>.
If <code>requiretrue = TRUE</code> and <code>xi</code> is not a binary map then an error will occur.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># The following return TRUE
isbinarymap(as.im(heather$coarse, na.value = 0))
isbinarymap(as.im(heather$coarse, na.value = FALSE, value = TRUE))

# The following return FALSE
isbinarymap(as.im(heather$coarse, na.value = 0.2, value = 1))
isbinarymap(as.im(heather$coarse, na.value = 0, value = 1.5))
</code></pre>

<hr>
<h2 id='lacunaritycovariance-package'>lacunaritycovariance: Gliding Box Lacunarity and Other Metrics for 2D Random Closed Sets</h2><span id='topic+lacunaritycovariance'></span><span id='topic+lacunaritycovariance-package'></span>

<h3>Description</h3>

<p>Functions for estimating the gliding box lacunarity (GBL), covariance, and pair-correlation of a random closed set (RACS) in 2D from a binary coverage map (e.g. presence-absence land cover maps). Contains a number of newly-developed covariance-based estimators of GBL (Hingee et al., 2019) <a href="https://doi.org/10.1007/s13253-019-00351-9">doi:10.1007/s13253-019-00351-9</a> and balanced estimators, proposed by Picka (2000) <a href="http://www.jstor.org/stable/1428408">http://www.jstor.org/stable/1428408</a>, for covariance, centred covariance, and pair-correlation. Also contains methods for estimating contagion-like properties of RACS and simulating 2D Boolean models. Binary coverage maps are usually represented as raster images with pixel values of TRUE, FALSE or NA, with NA representing unobserved pixels. A demo for extracting such a binary map from a geospatial data format is provided. Binary maps may also be represented using polygonal sets as the foreground, however for most computations such maps are converted into raster images. The package is based on research conducted during the author's PhD studies.
</p>


<h3>Details</h3>

<p>Random closed sets (RACS) (Chiu et al., 2013; Molchanov, 2005) are a well known tool for modelling binary coverage maps.
The package author recently developed new, improved estimators of gliding box lacunarity (GBL) for RACS (Hingee et al., 2017) and described contagion-like properties for RACS (Hingee, 2016).
The PhD thesis (Hingee, 2019) provides additional background for GBL, and for RACS in landscape metrics (which includes contagion).
</p>
<p>This package expects RACS observations to be in the form of binary maps either in raster format, or as a set representing foreground with a second set giving the observation window.
If in raster format, the binary map is expected to be a <code><a href="spatstat.geom.html#topic+im">spatstat.geom::im()</a></code> object with pixel values that are only 1 and 0, or are logically valued (i.e. <code>TRUE</code> or <code>FALSE</code>). In both cases the observation window is taken to be the set of pixels with values that are not <code>NA</code> (i.e. <code>NA</code> values are considered outside the observation window).
The foreground of the binary map, corresponding to locations within the realisation of the RACS, is taken to be pixels that have value <code>1</code> or <code>TRUE</code>.
If the binary map is in set format then a <code><a href="spatstat.geom.html#topic+owin">spatstat.geom::owin()</a></code> object is used to represent foreground and a second <code>owin</code> object is used to represent the observation window.
</p>
<p>We will usually denote a RACS as <code class="reqn">\Xi</code> ('Xi') and a realisation of <code class="reqn">\Xi</code> observed as a binary map as <code class="reqn">xi</code>. We will usually denote the observation window as <code>obswin</code>.
</p>
<p>A demonstration converting remotely sensed data into a binary map in <code>im</code> format can be accessed by typing <code>demo("import_remote_sense_data", package = "lacunaritycovariance")</code>.
A short example of estimating RACS properties can be found in the vignette <code>estimate_RACS_properties</code>, which can be accessed with <code>vignette("estimate_RACS_properties")</code>.
</p>
<p>The key functions within this package for estimating properties of RACS are:
</p>

<ul>
<li> <p><code><a href="#topic+coverageprob">coverageprob()</a></code> estimates the coverage probability of a stationary RACS
</p>
</li>
<li> <p><code><a href="#topic+racscovariance">racscovariance()</a></code> estimates the covariance of a stationary RACS
</p>
</li>
<li> <p><code><a href="#topic+gbl">gbl()</a></code> estimates the GBL of a stationary RACS
</p>
</li>
<li> <p><code><a href="#topic+cencovariance">cencovariance()</a></code> estimates the centred covariance of a stationary RACS
</p>
</li>
<li> <p><code><a href="#topic+paircorr">paircorr()</a></code> estimates the pair-correlation of a stationary RACS
</p>
</li>
<li> <p><code><a href="#topic+secondorderprops">secondorderprops()</a></code> estimates GBL, covariance and other second order properties of stationary RACS
</p>
</li>
<li> <p><code><a href="#topic+contagdiscstate">contagdiscstate()</a></code> estimates the disc-state contagion of a stationary RACS
</p>
</li></ul>

<p>Key functions for simulating RACS are:
</p>

<ul>
<li> <p><code><a href="#topic+rbdd">rbdd()</a></code> simulates a Boolean model with grains that are discs with fixed radius (deterministic discs).
</p>
</li>
<li> <p><code><a href="#topic+rbdr">rbdr()</a></code> simulates a Boolean model with grains that are rectangles of fixed size and orientation.
</p>
</li>
<li> <p><code><a href="#topic+rbpto">rbpto()</a></code> simulates a Boolean model with grains that of fixed shape and random scale distributed according to a truncated Pareto distribution.
</p>
</li>
<li> <p><code><a href="#topic+placegrainsfromlib">placegrainsfromlib()</a></code> randomly places grains on a set of points (used to simulate Boolean models and other germ-grain models).
</p>
</li></ul>



<h3>References</h3>

<p>Chiu, S.N., Stoyan, D., Kendall, W.S. and Mecke, J. (2013) <em>Stochastic Geometry and Its Applications</em>, 3rd ed. Chichester, United Kingdom: John Wiley &amp; Sons.
</p>
<p>Hingee, K.L. (2016) Statistics for patch observations. <em>International Archives of the Photogrammetry, Remote Sensing and Spatial Information Sciences</em> pp. 235-242. Prague: ISPRS.
</p>
<p>Hingee, K.L. (2019) <em>Spatial Statistics of Random Closed Sets for Earth Observations</em>. PhD: Perth, Western Australia: University of Western Australia. <a href="https://doi.org/10.26182/5dbb81b6480f9">doi:10.26182/5dbb81b6480f9</a>
</p>
<p>Hingee K, Baddeley A, Caccetta P, Nair G (2019). Computation of lacunarity from covariance of spatial binary maps. <em>Journal of Agricultural, Biological and Environmental Statistics</em>, 24, 264-288. <a href="https://doi.org/10.1007/s13253-019-00351-9">doi:10.1007/s13253-019-00351-9</a>.
</p>
<p>Molchanov, I.S. (2005) <em>Theory of Random Sets</em>. USA: Springer.
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/kasselhingee/lacunaritycovariance">https://github.com/kasselhingee/lacunaritycovariance</a>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># Estimates from the heather data in spatstat
xi_owin &lt;- heather$coarse
xi_owin_obswin &lt;- Frame(heather$coarse)

# Convert binary map to an im object (optional)
xi &lt;- as.im(xi_owin, value = TRUE, na.replace = FALSE)

# Estimate coverage probability, covariance, GBL, and disc-state contagion
cphat &lt;- coverageprob(xi)
cvchat &lt;- racscovariance(xi, estimator = "pickaH")

  gblhat &lt;- gbl(xi, seq(0.1, 5, by = 1), estimators = "GBLcc.pickaH")
  contagds &lt;- contagdiscstate(Hest(xi), Hest(!xi), p = cphat)


# Simulate a Boolean model with grains that are discs of fixed radius:

  xi_sim &lt;- rbdd(10, 0.1, owin())

</code></pre>

<hr>
<h2 id='paircorr'>Balanced estimation of pair-correlation.</h2><span id='topic+paircorr'></span><span id='topic+paircorr.cvchat'></span>

<h3>Description</h3>

<p>Estimates the pair-correlation function of a stationary RACS.
The plug-in moment pair-correlation estimator and three 'balanced' estimators suggested by Picka (2000)
are available.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>paircorr(
  xi,
  obswin = NULL,
  setcov_boundarythresh = NULL,
  estimators = "all",
  drop = FALSE
)

paircorr.cvchat(
  cvchat,
  cpp1 = NULL,
  phat = NULL,
  estimators = "all",
  drop = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="paircorr_+3A_xi">xi</code></td>
<td>
<p>An observation of a RACS of interest as a full binary map (as an <code>im</code> object) or as the foreground set (as an <code>owin</code> object).
In the latter case the observation window, <code>obswin</code>, must be supplied.
See <code><a href="#topic+lacunaritycovariance-package">lacunaritycovariance-package</a></code> for details.</p>
</td></tr>
<tr><td><code id="paircorr_+3A_obswin">obswin</code></td>
<td>
<p>If <code>xi</code> is an <code>owin</code> object then <code>obswin</code> is an
<code>owin</code> object that specifies the observation window.</p>
</td></tr>
<tr><td><code id="paircorr_+3A_setcov_boundarythresh">setcov_boundarythresh</code></td>
<td>
<p>To avoid instabilities caused by dividing by very small quantities, if the set covariance of the observation window
is smaller than <code>setcov_boundarythresh</code>, then the covariance is given a value of NA.</p>
</td></tr>
<tr><td><code id="paircorr_+3A_estimators">estimators</code></td>
<td>
<p>A list of strings specifying estimators to use.
See details.
<code>estimators = "all"</code> will select all available estimators.</p>
</td></tr>
<tr><td><code id="paircorr_+3A_drop">drop</code></td>
<td>
<p>If TRUE and one estimator selected then the returned value will be a single <code>im</code> object and not a list of <code>im</code> object.
<code>estimators = "all"</code> will select all inbuilt estimators. See details.</p>
</td></tr>
<tr><td><code id="paircorr_+3A_cvchat">cvchat</code></td>
<td>
<p>The plug-in moment estimate of covariance as an <code>im</code> object.
Typically created with <code><a href="#topic+plugincvc">plugincvc</a></code>.</p>
</td></tr>
<tr><td><code id="paircorr_+3A_cpp1">cpp1</code></td>
<td>
<p>Picka's reduced window estimate of coverage probability as an <code>im</code> object - used in improved (balanced) covariance estimators.
Can be generated using <code><a href="#topic+cppicka">cppicka</a></code>.</p>
</td></tr>
<tr><td><code id="paircorr_+3A_phat">phat</code></td>
<td>
<p>The plug-in moment estimate of coverage probability,
which is the observed foreground area in <code>xi</code> divided by the total area of the observation window.
See <code><a href="#topic+coverageprob">coverageprob</a></code> for more information.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The pair-correlation of a stationary RACS is
</p>
<p style="text-align: center;"><code class="reqn">g(v) = C(v) / p^2.</code>
</p>

<p>The estimators available are (see (Hingee, 2019) for
more information):
</p>

<ul>
<li><p><code>plugin</code> the plug-in moment pair-correlation estimator which is <code class="reqn">Chat(v) / (phat^2)</code>, where <code class="reqn">Chat</code> and <code class="reqn">phat</code> are
the plug-in moment estimate of covariance and the usual estimate of coverage probability, respectively.
</p>
</li>
<li><p><code>mattfeldt</code> an 'intrinsically' balanced pair-correlation estimator suggested by Picka (1997).
A similar isotropic pair-correlation estimator was later studied by Mattfeldt and Stoyan (2000).
</p>
</li>
<li><p><code>pickaint</code> Picka's 'intrinsically' balanced pair-correlation estimator (Picka, 2000).
</p>
</li>
<li><p><code>pickaH</code> Picka's 'additively' balanced pair-correlation estimator (Picka, 2000).
</p>
</li></ul>



<h3>Value</h3>

<p>If <code>drop = TRUE</code> and a single estimator is requested then an
<code>im</code> object containing the pair-correlation estimate is returned. Otherwise a
named <code>imlist</code> of <code>im</code> objects containing the pair-correlation
estimates for each requested estimator.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>paircorr()</code>: Estimates pair-correlation from a binary map.
</p>
</li>
<li> <p><code>paircorr.cvchat()</code>: Generates pair-correlation estimates from
the plug-in moment estimates of covariance, Picka's reduced window estimate of coverage probability,
and the coverage fraction (which is an unbiased estimate of the coverage probability).
If these estimates already exist then <code>paircorr.cvchat</code> can save significant computation time.
</p>
</li></ul>


<h3>Author(s)</h3>

<p>Kassel Liam Hingee
</p>


<h3>References</h3>

<p>Hingee, K.L. (2019) <em>Spatial Statistics of Random Closed Sets for Earth Observations</em>. PhD: Perth, Western Australia: University of Western Australia. Submitted.
</p>
<p>Mattfeldt, T. and Stoyan, D. (2000) Improved estimation of the pair correlation function of random sets. <em>Journal of Microscopy</em>, 200, 158-173.
</p>
<p>Picka, J.D. (1997) <em>Variance-Reducing Modifications for Estimators of Dependence in Random Sets</em>. Ph.D.: Illinois, USA: The University of Chicago.
</p>
<p>Picka, J.D. (2000) Variance reducing modifications for estimators of standardized moments of random sets. <em>Advances in Applied Probability</em>, 32, 682-700.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>xi &lt;- as.im(heather$coarse, na.replace = 0, eps = 4 * heather$coarse$xstep)

# Estimate pair correlation from a binary map
pclns_directest &lt;- paircorr(xi, estimators = "all")

phat &lt;- coverageprob(xi)
cvchat &lt;- plugincvc(xi)
cpp1 &lt;- cppicka(xi)

# Compute pair correlation estimates from estimates covariance,
# coverage probability and Picka's reduced-window coverage probability.
pclns_fromcvc &lt;- paircorr.cvchat(cvchat, cpp1, phat, estimators = "all")
</code></pre>

<hr>
<h2 id='placegrainsfromlib'>Place grains randomly on a point pattern</h2><span id='topic+placegrainsfromlib'></span><span id='topic+meanarea.grainlib'></span><span id='topic+meansetcov.grainlib'></span><span id='topic+covar.grainlib'></span>

<h3>Description</h3>

<p>Places subsets (grains) of two dimension space randomly on a given point pattern.
This is useful for simulating germ-grain models such as Boolean models.
Also described here are functions for computing summary properties of the a list of grains.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>placegrainsfromlib(
  pp,
  grainlib,
  replace = TRUE,
  prob = NULL,
  w = NULL,
  xy = NULL
)

meanarea.grainlib(
  grainlib,
  weights = rep(1/length(grainlib), length(grainlib))
)

meansetcov.grainlib(
  grainlib,
  weights = rep(1/length(grainlib), length(grainlib)),
  xy
)

covar.grainlib(lambda, grainlib, weights, xy)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="placegrainsfromlib_+3A_pp">pp</code></td>
<td>
<p>A point pattern (in <code>ppp</code> format).</p>
</td></tr>
<tr><td><code id="placegrainsfromlib_+3A_grainlib">grainlib</code></td>
<td>
<p>A list of grains as <code>owin</code> objects in a <code><a href="spatstat.geom.html#topic+solist">solist</a></code>.</p>
</td></tr>
<tr><td><code id="placegrainsfromlib_+3A_replace">replace</code></td>
<td>
<p>passed directly to <code><a href="base.html#topic+sample">sample</a></code>. When TRUE grains are chosen from library with replacement.</p>
</td></tr>
<tr><td><code id="placegrainsfromlib_+3A_prob">prob</code></td>
<td>
<p>A list of probability weights for each grain in the library. Passed directly to <code><a href="base.html#topic+sample">sample</a></code>.
If NULL the grains are selected with equal probability.</p>
</td></tr>
<tr><td><code id="placegrainsfromlib_+3A_w">w</code></td>
<td>
<p>Optional desired observation window. If this is non-null then any grains with Frame outside the Frame of <code>w</code> will be ignored.
This reduces polygonal intersection calculations for very large buffer distances</p>
</td></tr>
<tr><td><code id="placegrainsfromlib_+3A_xy">xy</code></td>
<td>
<p>An <code>im</code> or binary mask object that is used to specify the pixel array of objects.</p>
</td></tr>
<tr><td><code id="placegrainsfromlib_+3A_weights">weights</code></td>
<td>
<p>Probability of selecting each grain in the library</p>
</td></tr>
<tr><td><code id="placegrainsfromlib_+3A_lambda">lambda</code></td>
<td>
<p>Intensity of germs of a Boolean model - for computing the covariance of a Boolean model that has grain distribution given by <code>grainlib</code> and <code>weights</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Germ-grain models have two components, a point process (called germs) and a process that creates
grains that are centred on the germs.
The point process of germs can be easily simulated using a number of <span class="pkg">spatstat</span> functions
(e.g. <code><a href="spatstat.random.html#topic+rpoispp">rpoispp</a></code> for Boolean models).
To simulate a germ-grain model in a window <code class="reqn">W</code> the germ process must be simulated in a larger window
because grains centred outside <code class="reqn">W</code> can intersect <code class="reqn">W</code>.
The result must then be cropped to <code class="reqn">W</code> to achieve a realisation of the germ-grain process within <code class="reqn">W</code>.
</p>
<p><code>placegrainsfromlib</code> randomly samples from a library of grains (<code>grainlib</code>) and places these on the points in <code>pp</code>.
Sampling of the grain is independent of the location of the point in <code>pp</code>.
It can be used to simulate the grain process in some germ-grain models.
</p>


<h3>Value</h3>

<p>Returns an <code>owin</code> object.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>placegrainsfromlib()</code>: Place grains randomly from a list of grains.
</p>
</li>
<li> <p><code>meanarea.grainlib()</code>: Compute mean area of a random grain given by the library
</p>
</li>
<li> <p><code>meansetcov.grainlib()</code>: Computes the mean of the set covariance of the grains in <code>grainlib</code>.
<code>xy</code> is required because the set covariance function must rasterise the <code>owin</code> objects.
</p>
</li>
<li> <p><code>covar.grainlib()</code>: Compute the covariance of a Boolean model with random grain given by the library
</p>
</li></ul>


<h3>Author(s)</h3>

<p>Kassel Liam Hingee
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simulate a germ-grain model where germs are a Poisson point process
# and grains are randomly selected from 3 different disc sizes.
grainlib &lt;- solist(disc(radius = 1), disc(radius = 1.9), disc(radius = 0.2))
bufferdist &lt;- 2 #chosen to be larger than the largest radius in library
w &lt;- owin(xrange = c(0, 10), yrange = c(0, 10))

# Simulate the germ process in the window plus a buffer region around window
pp &lt;- rpoispp(lambda = 0.1, win = dilation(w, bufferdist), nsim = 1, drop = TRUE)
xi_withbuffer &lt;- placegrainsfromlib(pp, grainlib)

# Simulation of germ-grain model is the part within the window
xi &lt;- intersect.owin(xi_withbuffer, w)

# Computation of properties from parameters 
lambda &lt;- 0.1
discr &lt;- 10
weights &lt;- c(0.9999, 0.0001)
grainlib &lt;- solist(disc(r = discr), disc(r = 2*discr))
meanarea.grainlib(grainlib, weights)
truecovar &lt;- covar.grainlib(lambda, grainlib, weights, xy = as.mask(w, eps = 2))
</code></pre>

<hr>
<h2 id='plugincvc'>Plug-in moment covariance estimator</h2><span id='topic+plugincvc'></span>

<h3>Description</h3>

<p>This function computes the plug-in moment covariance estimate of a stationary RACS from a binary map.
For a stationary RACS, <code class="reqn">\Xi</code>, the covariance
for a vector <code class="reqn">v</code> is the probability of two points separated by a vector <code class="reqn">v</code> are covered by <code class="reqn">\Xi</code>
</p>
<p style="text-align: center;"><code class="reqn">C(v) = P(\{x,x+v\}\subseteq \Xi).</code>
</p>



<h3>Usage</h3>

<pre><code class='language-R'>plugincvc(xi, obswin = NULL, setcov_boundarythresh = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plugincvc_+3A_xi">xi</code></td>
<td>
<p>An observation of a RACS of interest as a full binary map (as an <code>im</code> object) or as the foreground set (as an <code>owin</code> object).
In the latter case the observation window, <code>obswin</code>, must be supplied.</p>
</td></tr>
<tr><td><code id="plugincvc_+3A_obswin">obswin</code></td>
<td>
<p>If <code>xi</code> is an <code>owin</code> object then <code>obswin</code> is an
<code>owin</code> object that specifies the observation window.</p>
</td></tr>
<tr><td><code id="plugincvc_+3A_setcov_boundarythresh">setcov_boundarythresh</code></td>
<td>
<p>To avoid instabilities caused by dividing by very small quantities, if the set covariance of the observation window
is smaller than <code>setcov_boundarythresh</code>, then the covariance is given a value of NA.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The plug-in moment covariance estimator is (Serra, 1982)
</p>
<p style="text-align: center;"><code class="reqn"> \hat{C}(v) = \frac{\gamma_{W\cap X}(v)}{\gamma_W(v)}</code>
</p>

<p>where <code class="reqn">\gamma_{W}(v)</code> is the set covariance of the observation window <code class="reqn">W</code>
and <code class="reqn">\gamma_{W\cap X}(v)</code> is the set covariance of the foreground within <code class="reqn">W</code>.
<code>plugincvc</code> uses Fourier transforms to calculate the set covariance (using the <code><a href="spatstat.geom.html#topic+setcov">setcov</a></code> of the foreground and observation window.
Vectors with small <code class="reqn">\gamma_W(v)</code> are eliminated using <code>setcov_boundarythresh</code>
as division by small values is numerically unstable.
</p>


<h3>Value</h3>

<p>A <span class="pkg">SpatStat</span> <code>im</code> object containing the estimated covariance.
</p>


<h3>Author(s)</h3>

<p>Kassel Liam Hingee
</p>


<h3>References</h3>

<p>Serra, J.P. (1982) <em>Image Analysis and Mathematical Morphology</em>. London; New York: Academic Press.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>xi &lt;- as.im(heather$coarse, na.replace = 0)
covar &lt;- plugincvc(xi)
</code></pre>

<hr>
<h2 id='racscovariance'>Covariance Estimation</h2><span id='topic+racscovariance'></span><span id='topic+racscovariance.cvchat'></span>

<h3>Description</h3>

<p>Estimates the covariance of a stationary RACS.
The plug-in moment covariance estimator and
newer balanced estimators based on (Picka, 1997; Picka, 2000) are available.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>racscovariance(
  xi,
  obswin = NULL,
  setcov_boundarythresh = NULL,
  estimators = "all",
  drop = FALSE
)

racscovariance.cvchat(
  cvchat,
  cpp1 = NULL,
  phat = NULL,
  estimators = "all",
  drop = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="racscovariance_+3A_xi">xi</code></td>
<td>
<p>A binary map. Either an <code>im</code> object or a <code>owin</code> object.
If an <code>im</code> object then pixel values of 1 or TRUE represent foreground,
0 or <code>FALSE</code> values represent background, and <code>NA</code> values
represent outside the  observation window. If an <code>owin</code> object then
<code>xi</code> represents foreground and <code>obswin</code> is required to specify
the observation window.</p>
</td></tr>
<tr><td><code id="racscovariance_+3A_obswin">obswin</code></td>
<td>
<p>The observation window as an <code>owin</code> object if <code>xi</code> is also as an <code>owin</code> object.</p>
</td></tr>
<tr><td><code id="racscovariance_+3A_setcov_boundarythresh">setcov_boundarythresh</code></td>
<td>
<p>To avoid instabilities caused by dividing by very small quantities, if the set covariance of the observation window
is smaller than <code>setcov_boundarythresh</code>, then the covariance is given a value of NA.</p>
</td></tr>
<tr><td><code id="racscovariance_+3A_estimators">estimators</code></td>
<td>
<p>A list of strings specifying covariance estimators to use.
See details.
Passing <code>estimators = "all"</code> will select all available estimators.</p>
</td></tr>
<tr><td><code id="racscovariance_+3A_drop">drop</code></td>
<td>
<p>If TRUE and one estimator is selected then the returned value will be a single <code>im</code> object and not a list of <code>im</code> objects.</p>
</td></tr>
<tr><td><code id="racscovariance_+3A_cvchat">cvchat</code></td>
<td>
<p>The plug-in moment estimate of covariance as an <code>im</code> object.
Typically created with <code><a href="#topic+plugincvc">plugincvc</a></code>.</p>
</td></tr>
<tr><td><code id="racscovariance_+3A_cpp1">cpp1</code></td>
<td>
<p>Picka's reduced window estimate of coverage probability as an <code>im</code> object - used in improved (balanced) covariance estimators.
Can be generated using <code><a href="#topic+cppicka">cppicka</a></code>.</p>
</td></tr>
<tr><td><code id="racscovariance_+3A_phat">phat</code></td>
<td>
<p>The classical estimate of coverage probability,
which is the observed area in <code>xi</code> divided by the total area of the observation window.
See <code><a href="#topic+coverageprob">coverageprob</a></code> for more information.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The covariance of a RACS is also known as the two-point coverage probability, and is
closely related to the semivariogram.
The covariance of a stationary RACS <code class="reqn">\Xi</code> given a vector <code class="reqn">v</code> is
the probability that two points separated by a vector <code class="reqn">v</code> are covered by
<code class="reqn">\Xi</code>.
</p>
<p>Given a vector <code class="reqn">v</code>, the plug-in moment covariance estimate from a binary map is the volume of the set of points, <code class="reqn">x</code>, such that both
<code class="reqn">x</code> and <code class="reqn">x+v</code> are observed to be in the foreground
relative to the volume of points, <code class="reqn">x</code>, for which both <code class="reqn">x</code> and <code class="reqn">x+v</code>
are in the observation window (Hingee, 2019).
Picka (1997, 2000) suggested a number of improvements to centred
covariance estimation (see <code><a href="#topic+cencovariance">cencovariance</a></code>) that 'balanced' the
data used to estimate covariance with the data used to estimate coverage
probability. These lead to covariance estimators that give
estimates for the covariance of <code class="reqn">\Xi</code> that are a constant offset from
covariance estimates for the complement of <code class="reqn">\Xi</code> (note the constant offset
depends on the coverage probability), which
appears to avoid some surprising behaviour that the plug-in moment covariance estimator
suffers (Hingee, 2019).
These estimators are called <code>pickaint</code> and <code>pickaH</code> in this package.
</p>
<p>Another improved estimator, inspired by an 'intrinsic modification' briefly mentioned by Picka (1997)
for pair-correlation estimators, is also available.
We have called this estimator <code>mattfeldt</code> as a similar isotropic estimator for pair-correlation
was studied by Mattfeldt and Stoyan (2000).
</p>
<p>The estimators available are (see (Hingee, 2019) for more information):
</p>

<ul>
<li><p><code>plugin</code> the plug-in moment covariance estimator
</p>
</li>
<li><p><code>mattfeldt</code> an estimator inspired by an
'intrinsically' balanced pair-correlation estimator from Picka that was later studied in an
isotropic situation by Mattfeldt and Stoyan (2000)
</p>
</li>
<li><p><code>pickaint</code> an estimator inspired by an
'intrinsically' balanced centred covariance estimator from Picka (2000).
</p>
</li>
<li><p><code>pickaH</code> an estimator inspired by the
'additively' balanced centred covariance estimator from Picka (2000).
</p>
</li></ul>



<h3>Value</h3>

<p>If <code>drop = TRUE</code> and only one estimator is requested then
an <code>im</code> object containing the covariance estimate.
Otherwise a named <code>imlist</code> of covariance estimates corresponding to each requested estimator.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>racscovariance()</code>: Estimates covariance from a binary map.
</p>
</li>
<li> <p><code>racscovariance.cvchat()</code>: Computes covariance estimates from
a plug-in moment estimate of covariance, Picka's reduced window estimate of coverage probability,
and the usual estimate of coverage probability.
If these estimates already exist then <code>racscovariance.cvchat</code> can save significant computation time.
</p>
</li></ul>


<h3>Author(s)</h3>

<p>Kassel Liam Hingee
</p>


<h3>References</h3>

<p>Hingee, K.L. (2019) <em>Spatial Statistics of Random Closed Sets for Earth Observations</em>. PhD: Perth, Western Australia: University of Western Australia. Submitted.
</p>
<p>Mattfeldt, T. and Stoyan, D. (2000) Improved estimation of the pair correlation function of random sets. <em>Journal of Microscopy</em>, 200, 158-173.
</p>
<p>Picka, J.D. (1997) <em>Variance-Reducing Modifications for Estimators of Dependence in Random Sets</em>. Ph.D.: Illinois, USA: The University of Chicago.
</p>
<p>Picka, J.D. (2000) Variance reducing modifications for estimators of standardized moments of random sets. <em>Advances in Applied Probability</em>, 32, 682-700.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>xi &lt;- heather$coarse
obswin &lt;- Frame(xi)

# Estimate from a binary map
balancedcvchats_direct &lt;- racscovariance(xi, obswin = obswin, estimators = "all")

phat &lt;- coverageprob(xi, obswin = obswin)
cvchat &lt;- plugincvc(xi, obswin)
cpp1 &lt;- cppicka(xi, obswin = Frame(heather$coarse))
harmonised &lt;- harmonise.im(cvchat = cvchat, cpp1 = cpp1)
cvchat &lt;- harmonised$cvchat
cpp1 &lt;- harmonised$cpp1

# Compute balanced estimate of covariance from other estimates
balancedcvchats_fromplugincvc &lt;- racscovariance.cvchat(cvchat,
                         cpp1, phat, estimators = "pickaH", drop = TRUE)

</code></pre>

<hr>
<h2 id='rbdd'>Simulation of Boolean Model of Deterministic Discs</h2><span id='topic+rbdd'></span><span id='topic+bddcoverageprob'></span><span id='topic+bddlambda'></span><span id='topic+bdddiscr'></span><span id='topic+bddcovar.iso'></span><span id='topic+bddcovar'></span>

<h3>Description</h3>

<p>Functions for simulating a Boolean model with grains that are
discs of fixed constant radius (the abbreviation 'bdd' is short for Boolean
model with Deterministic Discs). A Boolean model is a two stage model,
first the locations (called germs) of grains are randomly distributed
according to a Poisson point process, then a random grain is placed on each
germ independently. Introductions to Boolean models are available in many
stochastic geometry books (Chiu et al., 2013). Also described here are
functions for calculating the coverage probability, germ intensity, and
covariance from model parameters for a Boolean model with deterministic discs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rbdd(lambda, discr, window, seed = NULL)

bddcoverageprob(lambda, discr)

bddlambda(coverp, discr)

bdddiscr(coverp, lambda)

bddcovar.iso(r, lambda, discr)

bddcovar(xrange, yrange, eps, lambda, discr)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rbdd_+3A_lambda">lambda</code></td>
<td>
<p>Intensity of the germ process (which is a Poisson point
process)</p>
</td></tr>
<tr><td><code id="rbdd_+3A_discr">discr</code></td>
<td>
<p>Radius of the discs</p>
</td></tr>
<tr><td><code id="rbdd_+3A_window">window</code></td>
<td>
<p>The window to simulate in (an <code>owin</code> object)</p>
</td></tr>
<tr><td><code id="rbdd_+3A_seed">seed</code></td>
<td>
<p>Optional input (default in NULL). Is an integer passed to
<code><a href="base.html#topic+set.seed">set.seed</a></code>. Used to reproduce patterns exactly.</p>
</td></tr>
<tr><td><code id="rbdd_+3A_coverp">coverp</code></td>
<td>
<p>Coverage probability of the Boolean model</p>
</td></tr>
<tr><td><code id="rbdd_+3A_r">r</code></td>
<td>
<p>is the radius to calculate covariance</p>
</td></tr>
<tr><td><code id="rbdd_+3A_xrange">xrange</code></td>
<td>
<p>range of x values for <code>bddcovar</code></p>
</td></tr>
<tr><td><code id="rbdd_+3A_yrange">yrange</code></td>
<td>
<p>range of y values for <code>bddcovar</code></p>
</td></tr>
<tr><td><code id="rbdd_+3A_eps">eps</code></td>
<td>
<p>list of length 2 of the steps between samples points in x and y respectively for <code>bddcovar</code>.
If eps is of length 1 then the steps between sample points in the x and y directions will both be equal to eps.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>See Functions section.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>rbdd()</code>: Returns an <code>owin</code> that is a set generated by simulating a Boolean
model with specified intensity and disc radius.
The window information is not contained in this object.
If the simulated set is empty then an empty <code>owin</code> object is returned.
The point process of germs is generated using <span class="pkg">spatstat</span>'s <code><a href="spatstat.random.html#topic+rpoispp">rpoispp</a></code>.
</p>
</li>
<li> <p><code>bddcoverageprob()</code>: Returns the true coverage probability given the intensity and disc radius.
</p>
</li>
<li> <p><code>bddlambda()</code>: Returns the germ intensity given coverage probability and disc radius.
</p>
</li>
<li> <p><code>bdddiscr()</code>: Returns the disc radius given coverage probability and germ intensity.
</p>
</li>
<li> <p><code>bddcovar.iso()</code>: Returns the true covariance of points separated by a distance <code>r</code> given the intensity, <code>lambda</code> and disc radius <code>discr</code> of the model.
</p>
</li>
<li> <p><code>bddcovar()</code>: Returns an image of the covariance as calculated from disc radius and intensity.
</p>
</li></ul>


<h3>WARNING</h3>

<p>The returned object of <code>rbdd</code> is an <code>owin</code> specifying the realisation of the Boolean model within the simulation window. The simulation window is not included, thus the object returned by <code>rbdd</code> can have much smaller extent than the simulation window (e.g. when the simulated set is empty).
</p>


<h3>References</h3>

<p>Chiu, S.N., Stoyan, D., Kendall, W.S. and Mecke, J. (2013) <em>Stochastic Geometry and Its Applications</em>, 3rd ed. Chichester, United Kingdom: John Wiley &amp; Sons.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simulate Boolean model with discs of radius 10.
# The coverage probability is very close to 0.5.
discr &lt;- 10
w &lt;- owin(xrange = c(0, 100), c(0, 100))
lambda &lt;- 2.2064E-3 
xi &lt;- rbdd(lambda, discr, w)

# Compute properties of Boolean model from parameters
cp &lt;- bddcoverageprob(lambda, discr)
cvc &lt;- bddcovar(c(-10, 10), c(-10, 10), c(0.2, 0.2), lambda, discr)
</code></pre>

<hr>
<h2 id='rbdr'>Simulation of Boolean Model of Deterministic Rectangles</h2><span id='topic+rbdr'></span><span id='topic+bdrcoverageprob'></span><span id='topic+bdrcovar'></span>

<h3>Description</h3>

<p>Functions for simulating a Boolean model with grains that are deterministic rectangles.
A Boolean model is a two stage model, first the locations (called germs) of grains are randomly distributed according to a Poisson point process, then a random grain is placed on each germ independently.
An introduction can be found in (Chiu et al., 2013).
Also described in this help file are functions for calculating the coverage probability and covariance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rbdr(lambda, grain, win, seed = NULL)

bdrcoverageprob(lambda, grain)

bdrcovar(lambda, grain, xy)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rbdr_+3A_lambda">lambda</code></td>
<td>
<p>Intensity of the germ process (which is a Poisson point process)</p>
</td></tr>
<tr><td><code id="rbdr_+3A_grain">grain</code></td>
<td>
<p>Rectangle object specifying the grain</p>
</td></tr>
<tr><td><code id="rbdr_+3A_win">win</code></td>
<td>
<p>The window to simulate in (an <code>owin</code> object)</p>
</td></tr>
<tr><td><code id="rbdr_+3A_seed">seed</code></td>
<td>
<p>Optional input (default in NULL). Is an integer passed to <code><a href="base.html#topic+set.seed">set.seed</a></code>. Used to reproduce patterns exactly.</p>
</td></tr>
<tr><td><code id="rbdr_+3A_xy">xy</code></td>
<td>
<p>A raster object that specifies the pixel coordinates of the desired covariance image. <code>xy</code> works in similar fashion to passing an image or pixel mask through the <code>xy</code> argument of <code><a href="spatstat.geom.html#topic+as.mask">as.mask</a></code> in <span class="pkg">spatstat</span>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Depends on the function used (see Functions section).
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>rbdr()</code>: Returns an <code>owin</code> that is a set generated by simulating a Boolean
model with a specified intensity and fixed rectangular grain.
The window information is not contained in this object.
If the simulated set is empty then an empty <code>owin</code> object is returned.
The point process of germs is generated using spatstat's <code><a href="spatstat.random.html#topic+rpoispp">rpoispp</a></code>.
</p>
</li>
<li> <p><code>bdrcoverageprob()</code>: Returns the true coverage probability given the intensity and grain.
</p>
</li>
<li> <p><code>bdrcovar()</code>: Returns an image of the covariance as calculated from disc radius and intensity.
</p>
</li></ul>


<h3>WARNING</h3>

<p>The returned object of <code>rbdr</code> is only the foreground of a binary map and thus can have much smaller extent than the simulation window (e.g. when the simulated set is empty).
</p>


<h3>References</h3>

<p>Chiu, S.N., Stoyan, D., Kendall, W.S. and Mecke, J. (2013) <em>Stochastic Geometry and Its Applications</em>, 3rd ed. Chichester, United Kingdom: John Wiley &amp; Sons.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>grain &lt;- owin(xrange = c(-5, 5), yrange = c(-5, 5))
win &lt;- owin(xrange = c(0, 100), c(0, 100))
lambda &lt;- 4.2064E-3
xi &lt;- rbdr(lambda, grain, win)

cp_theoretical &lt;- bdrcoverageprob(lambda, grain)
xy &lt;- as.mask(dilationAny(win, win), eps = c(1, 1))
cvc_theoretical &lt;- bdrcovar(lambda, grain, xy)
</code></pre>

<hr>
<h2 id='rblnd'>Simulate a Boolean model of discs with log normal disc radii</h2><span id='topic+rblnd'></span>

<h3>Description</h3>

<p>Simulates a Boolean model of discs with log normal radii by first simulating a Poisson point process and then placing discs
of random radii around each point (the radii are generated using a log normal distribution).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rblnd(obswin, bufferdist, lambda, meanlog, sdlog, seed = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rblnd_+3A_obswin">obswin</code></td>
<td>
<p>An <code>owin</code> object specifying the desired simulation region</p>
</td></tr>
<tr><td><code id="rblnd_+3A_bufferdist">bufferdist</code></td>
<td>
<p>A distance to expand <code>obswin</code> so that discs with centres near <code>obswin</code> are also simulated.</p>
</td></tr>
<tr><td><code id="rblnd_+3A_lambda">lambda</code></td>
<td>
<p>Intensity of the Poisson point process, passed to <a href="spatstat.random.html#topic+rpoispp">rpoispp</a>.
It could be either a single positive number, or any other object that <a href="spatstat.random.html#topic+rpoispp">rpoispp</a> can understand.</p>
</td></tr>
<tr><td><code id="rblnd_+3A_meanlog">meanlog</code></td>
<td>
<p>For the distribution of radii. The logarithm of the distribution is set to have mean <code>meanlog</code>.</p>
</td></tr>
<tr><td><code id="rblnd_+3A_sdlog">sdlog</code></td>
<td>
<p>For the distribution of radii. The logarithm of the distribution is set to have standard deviation <code>sdlog</code></p>
</td></tr>
<tr><td><code id="rblnd_+3A_seed">seed</code></td>
<td>
<p>Optional input (default is <code>NULL</code>). Is an integer passed to <code><a href="base.html#topic+set.seed">set.seed</a></code>. Used to reproduce patterns exactly.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The point process needs to be simulated in a larger region than the desired observation window to account for the possibility of discs that intersect the observation window, but have germs outside the observation window.
</p>
<p>The point process of germs is generated using spatstat's <code><a href="spatstat.random.html#topic+rpoispp">rpoispp</a></code>.
</p>


<h3>Value</h3>

<p>Returns an <code>owin</code> object cropped to <code>obswin</code>.
</p>


<h3>Warning</h3>

<p>A good choice of <code>bufferdist</code> is required and will be sensitive to the distribution of radii.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>w &lt;- owin(xrange = c(0, 10), yrange = c(0, 10))
xi &lt;- rblnd(w, 2, 0.3, -1, 0.2)
</code></pre>

<hr>
<h2 id='rbpto'>Simulate Boolean Model with Grains Scaled According to a Truncated
Pareto Distribution</h2><span id='topic+rbpto'></span><span id='topic+bpto.coverageprob'></span><span id='topic+bpto.germintensity'></span><span id='topic+bpto.covar'></span>

<h3>Description</h3>

<p>Functions for simulation and computing theoretical values of a
Boolean model with identically shaped grains with size given by a
truncated Pareto distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rbpto(lambda, grain, win, xm, alpha, lengthscales, seed = NULL, xy = NULL)

bpto.coverageprob(lambda, grain, xm, alpha, lengthscales = 1:500)

bpto.germintensity(coverp, grain, xm, alpha, lengthscales = 1:500)

bpto.covar(lambda, grain, xm, alpha, lengthscales = 1:500, xy)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rbpto_+3A_lambda">lambda</code></td>
<td>
<p>Intensity of the germ process (which is a Poisson point
process)</p>
</td></tr>
<tr><td><code id="rbpto_+3A_grain">grain</code></td>
<td>
<p>A single <code>owin</code> object that gives the shape and size of the grain
at scale 1</p>
</td></tr>
<tr><td><code id="rbpto_+3A_win">win</code></td>
<td>
<p>The window to simulate in (an <code>owin</code> object)</p>
</td></tr>
<tr><td><code id="rbpto_+3A_xm">xm</code></td>
<td>
<p>A parameter governing the shape of the Pareto distribution used -
see details</p>
</td></tr>
<tr><td><code id="rbpto_+3A_alpha">alpha</code></td>
<td>
<p>A parameter governing the shape of the Pareto distribution used
</p>

<ul>
<li><p> see details
</p>
</li></ul>
</td></tr>
<tr><td><code id="rbpto_+3A_lengthscales">lengthscales</code></td>
<td>
<p>A list of scales of the <code>grain</code> for which to
approximate the Pareto distribution: The grain for a germ is chosen by
selecting a scaled version of <code>grain</code> where <code>lengthscales</code>
specifies the possible scales and the Pareto distribution is used to
specify the probability of selection of each scale.</p>
</td></tr>
<tr><td><code id="rbpto_+3A_seed">seed</code></td>
<td>
<p>Optional input (default in NULL). Is an integer passed to
<code><a href="base.html#topic+set.seed">set.seed</a></code>. Used to reproduce patterns exactly.</p>
</td></tr>
<tr><td><code id="rbpto_+3A_xy">xy</code></td>
<td>
<p>A raster object that specifies pixel coordinates of the final
simulated binary map. It is used the same way as <code>xy</code> is
<code><a href="spatstat.geom.html#topic+as.mask">as.mask</a></code> in <span class="pkg">spatstat</span>. If non-null then the
computations will be performed using rasters. Otherwise if <code>grain</code> and
<code>win</code> are polygonal then computations may be all polygonal.</p>
</td></tr>
<tr><td><code id="rbpto_+3A_coverp">coverp</code></td>
<td>
<p>Coverage probability of the Boolean model.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The parameters <code>xm</code> and <code>alpha</code> are such that the CDF of the Pareto distribution is <code class="reqn">P(s &lt;= x) = 1 - (xm / x)^{alpha}</code>.
The distribution of grains scales is a step-function approximation to the CDF with steps at <code>lengthscales</code>.
</p>


<h3>Value</h3>

<p>An <code>owin</code> object.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>rbpto()</code>: Simulate Boolean model with grain size distributed according to a truncated Pareto distribution.
</p>
</li>
<li> <p><code>bpto.coverageprob()</code>: The coverage probability of the Boolean model with grain size distributed according to a truncated Pareto distribution.
</p>
</li>
<li> <p><code>bpto.germintensity()</code>: The germ intensity of the Boolean model with grain size distributed according to a truncated Pareto distribution.
</p>
</li>
<li> <p><code>bpto.covar()</code>: The covariance of the Boolean model with grain size distributed according to a truncated Pareto distribution.
<code>xy</code> is required to specify resolution and offset of pixel grid.
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>lambda &lt;- 0.2
win &lt;- square(r = 10)
grain &lt;- disc(r = 0.2)
xm &lt;- 0.01
alpha &lt;- 2
lengthscales &lt;- seq(1, 5, by = 0.1)
xi &lt;- rbpto(lambda, grain, win, xm, alpha, lengthscales = lengthscales)

# Compute properties of the Boolean model from parameters
bpto.coverageprob(lambda, grain, xm, alpha, lengthscales = lengthscales)
covar &lt;- bpto.covar(lambda, grain, xm, alpha, lengthscales = lengthscales,
                    xy = as.mask(win, eps = 2))
</code></pre>

<hr>
<h2 id='secondorderprops'>Estimate Second-Order Properties of a RACS</h2><span id='topic+secondorderprops'></span>

<h3>Description</h3>

<p>Estimates many second order properties of RACS, gliding box lacunarity, covariance, centred covariance,
and pair-correlation.
This can be faster than computing estimates of multiple second order properties separately as
Fourier transforms of the binary map are not repeated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>secondorderprops(
  xiim,
  gblargs = NULL,
  covarargs = NULL,
  cencovarargs = NULL,
  paircorrargs = NULL,
  returnrotmean = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="secondorderprops_+3A_xiim">xiim</code></td>
<td>
<p>A <span class="pkg">spatstat</span> <code>im</code> object with pixel values that are either TRUE, FALSE or NA. TRUE represents foreground, FALSE represents background and NA represents unobserved locations.</p>
</td></tr>
<tr><td><code id="secondorderprops_+3A_gblargs">gblargs</code></td>
<td>
<p>A list of named arguments passed to <code><a href="#topic+gblemp">gblemp</a></code> and <code><a href="#topic+gbl.cvchat">gbl.cvchat</a></code>. The estimators used can be specified by passing an argument named 'estimators' contain a list of estimator names, as given in <code><a href="#topic+gbl">gbl</a></code>. If NULL then GBL will not be estimated.</p>
</td></tr>
<tr><td><code id="secondorderprops_+3A_covarargs">covarargs</code></td>
<td>
<p>A list of named arguments passed to <code><a href="#topic+racscovariance.cvchat">racscovariance.cvchat</a></code>. If NULL then covariance will not be returned.</p>
</td></tr>
<tr><td><code id="secondorderprops_+3A_cencovarargs">cencovarargs</code></td>
<td>
<p>A list of named arguments passed to <code><a href="#topic+cencovariance.cvchat">cencovariance.cvchat</a></code>. If NULL then pair correlation will not be returned.</p>
</td></tr>
<tr><td><code id="secondorderprops_+3A_paircorrargs">paircorrargs</code></td>
<td>
<p>A list of named arguments passed to <code><a href="#topic+paircorr.cvchat">paircorr.cvchat</a></code>. If NULL then pair correlation will not be returned.</p>
</td></tr>
<tr><td><code id="secondorderprops_+3A_returnrotmean">returnrotmean</code></td>
<td>
<p>Logical. If FALSE the anisotropic estimates of covariance and pair-correlation will be returned as <code>im</code> objects.
If TRUE then average covariance and pair-correlation over all directions will be returned as <code>fv</code> objects.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named list of estimated properties. When multiple estimators have been requested for the same property, then the entry in the list is itself a list, with each entry corresponding to a different estimator.
</p>


<h3>Warning</h3>

<p>The user interface for this function is substantially more  stretched the knowledge of the author, Kassel Hingee. Therefore, there is greater chance of encountering bugs. Kassel Hingee apologises for any bugs you encounter, and requests to be informed (thank you!).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>xiim &lt;- as.im(heather$coarse, value = TRUE,
              na.replace = FALSE)
gblargs = list(boxwidths = seq(1, 10, by = 1), estimators = c("GBLemp", "GBLcc.pickaH"))
covarargs = list(estimators = "all")
cencovarargs = list(estimators = "pickaH")
paircorrargs = list(estimators = "pickaH")
returnrotmean = TRUE
secondests &lt;- secondorderprops(xiim,
   gblargs = gblargs,
   covarargs = covarargs,
   cencovarargs = cencovarargs,
   paircorrargs = paircorrargs, 
   returnrotmean = FALSE)
</code></pre>

<hr>
<h2 id='summary.imlist'>Pointwise summary of a list of <code>im</code> objects</h2><span id='topic+summary.imlist'></span>

<h3>Description</h3>

<p>This function assumes that <code>im</code> objects are each realisations of the same (stochastic) object.
It returns pointwise summaries such as observed sample mean and sample variance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'imlist'
summary(object, ..., harmonizeobject = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.imlist_+3A_object">object</code></td>
<td>
<p>A list of <code>im</code> objects</p>
</td></tr>
<tr><td><code id="summary.imlist_+3A_...">...</code></td>
<td>
<p>Ignored</p>
</td></tr>
<tr><td><code id="summary.imlist_+3A_harmonizeobject">harmonizeobject</code></td>
<td>
<p>If TRUE (default) the pixel dimensions of the images will be harmonized. Otherwise the object will be tested for compatibility.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list <code>im</code> objects containing the pointwise mean, variance and maxima and minima.
</p>


<h3>Author(s)</h3>

<p>Kassel Hingee
</p>


<h3>Examples</h3>

<pre><code class='language-R'># reduce resolution in setcov() for faster (less accurate) computation 
oldopt &lt;- spatstat.options()
spatstat.options("npixel" = 2^4)

obspatterns &lt;- replicate(3, rbdd(10, 0.05, window = square(1)), simplify = FALSE)
ims &lt;- solapply(obspatterns,
 function(x) racscovariance(x, obswin = square(1), estimators = "pickaH", drop = TRUE))
summ &lt;- summary.imlist(ims, harmonizeobject = FALSE)
spatstat.options(oldopt)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
