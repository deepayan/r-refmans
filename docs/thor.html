<!DOCTYPE html><html lang="en-GB"><head><title>Help for package thor</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {thor}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#mdb_cursor'><p>Use mdb transactions</p></a></li>
<li><a href='#mdb_dbi'><p>Use mdb transactions</p></a></li>
<li><a href='#mdb_env'><p>Create an mdb_env environment</p></a></li>
<li><a href='#mdb_proxy'><p>Proxy values</p></a></li>
<li><a href='#mdb_txn'><p>Use mdb transactions</p></a></li>
<li><a href='#storr_thor'><p>Thor driver for storr</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Interface to 'LMDB'</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1.6</td>
</tr>
<tr>
<td>Description:</td>
<td>Key-value store, implemented as a wrapper around 'LMDB';
    the "lightning memory-mapped database" <a href="https://www.symas.com/lmdb">https://www.symas.com/lmdb</a>.
    'LMDB' is a transactional key value store that uses a memory map
    for efficient access.  This package wraps the entire 'LMDB'
    interface (except duplicated keys), and provides objects for
    transactions and cursors.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/richfitz/thor">https://github.com/richfitz/thor</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/richfitz/thor/issues">https://github.com/richfitz/thor/issues</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>R6, storr</td>
</tr>
<tr>
<td>Suggests:</td>
<td>ids, knitr, rmarkdown, testthat</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>ByteCompile:</td>
<td>true</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Language:</td>
<td>en-GB</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-09-16 12:12:50 UTC; rfitzjoh</td>
</tr>
<tr>
<td>Author:</td>
<td>Rich FitzJohn [aut, cre],
  Howard Chu [aut, cph],
  Symas Corporation [cph],
  Martin Hedenfalk [aut, cph],
  The OpenLDAP Foundation [cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Rich FitzJohn &lt;rich.fitzjohn@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-09-16 17:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='mdb_cursor'>Use mdb transactions</h2><span id='topic+mdb_cursor'></span>

<h3>Description</h3>

<p>Cursors are required for some advanced queries on an mdb database,
when the basic set of functions in <code><a href="#topic+mdb_txn">mdb_txn</a></code> is not
sufficient.
</p>


<h3>Details</h3>

<p>Cursors must be created from within a transaction (which in turn
are created from an environment).
</p>


<h3>Methods</h3>


<dl>
<dt><code>close</code></dt><dd>
<p>Close the cursor
</p>
<p><em>Usage:</em>
<code>close()</code>
</p>
<p><em>Value</em>:
None, called for side effects only
</p>
<p><em>Note</em>: In lmdb.h this is <code>mdb_cursor_close()</code>
</p>
</dd>
<dt><code>put</code></dt><dd>
<p>Store data using the cursor
</p>
<p><em>Usage:</em>
<code>put(key, value, overwrite = TRUE, append = FALSE)</code>
</p>
<p><em>Arguments:</em>
</p>

<ul>
<li><p><code>key</code>:   The key (string or raw)

</p>
</li>
<li><p><code>value</code>:   The value (string or raw)

</p>
</li>
<li><p><code>overwrite</code>:   As for <code><a href="#topic+mdb_txn">mdb_txn</a></code> <code>$put</code>

</p>
</li>
<li><p><code>append</code>:   As for <code><a href="#topic+mdb_txn">mdb_txn</a></code> <code>$put</code>

</p>
</li></ul>

<p><em>Value</em>:
Logical scalar, indicating if data was previously stored at this key
</p>
<p><em>Note</em>: In lmdb.h this is <code>mdb_cursor_put()</code>
</p>
</dd>
<dt><code>del</code></dt><dd>
<p>Delete the current key
</p>
<p><em>Usage:</em>
<code>del()</code>
</p>
<p><em>Value</em>:
Logical, indicating if a value was deleted (which will be <code>TRUE</code> if the cursor was valid before this operation). Primarily called for its side effect of deleting the data.  After deletion, we call <code>mdb_cursor_get</code> with <code>MDB_GET_CURRENT</code> which will re-validate the cursor.
</p>
<p><em>Note</em>: In lmdb.h this is <code>mdb_cursor_del()</code>
</p>
</dd>
<dt><code>replace</code></dt><dd>
<p>Replace a key's current value with a new value, returning the old value.  This is like doing a <code>get()</code> followed by a <code>put</code> within a transaction.
</p>
<p><em>Usage:</em>
<code>replace(key, value, as_raw = NULL)</code>
</p>
<p><em>Arguments:</em>
</p>

<ul>
<li><p><code>key</code>:   The key to replace

</p>
</li>
<li><p><code>value</code>:   The new value to store

</p>
</li>
<li><p><code>as_raw</code>:   Return the value as raw.  With a value of <code>NULL</code> it will return a string if possible (i.e., if there are no null bytes) and a raw vector otherwise.  With <code>as_raw = TRUE</code> we always return a raw vector.  With <code>as_raw = FALSE</code> we always return a string, or throw an error if this is not possible.

</p>
</li></ul>

</dd>
<dt><code>pop</code></dt><dd>
<p>Delete a key's value, returning the value just before it was deleted.  This is like doing a <code>get</code> followed by a <code>del</code> within a transaction.
</p>
<p><em>Usage:</em>
<code>pop(key, as_raw = NULL)</code>
</p>
<p><em>Arguments:</em>
</p>

<ul>
<li><p><code>key</code>:   The key to delete

</p>
</li>
<li><p><code>as_raw</code>:   Return the value as raw.  With a value of <code>NULL</code> it will return a string if possible (i.e., if there are no null bytes) and a raw vector otherwise.  With <code>as_raw = TRUE</code> we always return a raw vector.  With <code>as_raw = FALSE</code> we always return a string, or throw an error if this is not possible.

</p>
</li></ul>

<p><em>Value</em>:
Depending on <code>as_raw</code> and if there is a value stored, <code>NULL</code>, a character string or a raw vector
</p>
</dd>
<dt><code>first</code></dt><dd>
<p>Move the cursor to the first item in the database
</p>
<p><em>Usage:</em>
<code>first()</code>
</p>
<p><em>Value</em>:
Invisibly, a logical indicating if the cursor position is valid, but primarily called for side effects
</p>
</dd>
<dt><code>last</code></dt><dd>
<p>Move the cursor to the last item in the database
</p>
<p><em>Usage:</em>
<code>last()</code>
</p>
<p><em>Value</em>:
Invisibly, a logical indicating if the cursor position is valid, but primarily called for side effects
</p>
</dd>
<dt><code>move_next</code></dt><dd>
<p>Move the cursor to the next item in the database.  If called while at the last item in the database, this will invalidate the cursor position.
</p>
<p><em>Usage:</em>
<code>move_next()</code>
</p>
<p><em>Value</em>:
Invisibly, a logical indicating if the cursor position is valid, but primarily called for side effects
</p>
</dd>
<dt><code>move_prev</code></dt><dd>
<p>Move the cursor to the previous item in the database.  If called while at the first item in the database, this will invalidate the cursor position.
</p>
<p><em>Usage:</em>
<code>move_prev()</code>
</p>
<p><em>Value</em>:
Invisibly, a logical indicating if the cursor position is valid, but primarily called for side effects
</p>
</dd>
<dt><code>move_to</code></dt><dd>
<p>Move the cursor to the item in the database with key <code>key</code>. If <code>key</code> does not exist, this will invalidate the cursor position.
</p>
<p><em>Usage:</em>
<code>move_to(key)</code>
</p>
<p><em>Arguments:</em>
</p>

<ul>
<li><p><code>key</code>:   Key to move to (string or raw)

</p>
</li></ul>

<p><em>Value</em>:
Invisibly, a logical indicating if the cursor position is valid, but primarily called for side effects
</p>
</dd>
<dt><code>seek</code></dt><dd>
<p>Move the cursor to the item in the database with key equal to or greater than <code>key</code>.  If <code>key</code> does not exist and no key with a key greater than <code>key</code> exists, this will invalidate the cursor position.
</p>
<p><em>Usage:</em>
<code>seek(key)</code>
</p>
<p><em>Arguments:</em>
</p>

<ul>
<li><p><code>key</code>:   Key to seek (string or raw)

</p>
</li></ul>

<p><em>Value</em>:
Invisibly, a logical indicating if the cursor position is valid, but primarily called for side effects
</p>
</dd>
<dt><code>get</code></dt><dd>
<p>Move to a key and fetch the value
</p>
<p><em>Usage:</em>
<code>get(key, as_proxy = FALSE, as_raw = NULL)</code>
</p>
<p><em>Arguments:</em>
</p>

<ul>
<li><p><code>key</code>:   The key to find (string or raw)

</p>
</li>
<li><p><code>as_proxy</code>:   Return as an <code><a href="#topic+mdb_proxy">mdb_proxy</a></code> object?

</p>
</li>
<li><p><code>as_raw</code>:   Return the value as raw.  With a value of <code>NULL</code> it will return a string if possible (i.e., if there are no null bytes) and a raw vector otherwise.  With <code>as_raw = TRUE</code> we always return a raw vector.  With <code>as_raw = FALSE</code> we always return a string, or throw an error if this is not possible.

</p>
</li></ul>

<p><em>Value</em>:
Depending on <code>as_raw</code> and if there is a value stored, <code>NULL</code>, a character string or a raw vector
</p>
</dd>
<dt><code>is_valid</code></dt><dd>
<p>Test if cursor is valid (i.e., that it is pointing at data that can be retrieved).  Cursors start off invalid until placed (e.g., <code>first</code>, <code>last</code>) and can be invalidated by moving off the beginning or end of the database.
</p>
<p><em>Usage:</em>
<code>is_valid()</code>
</p>
</dd>
<dt><code>key</code></dt><dd>
<p>Return the current key
</p>
<p><em>Usage:</em>
<code>key(as_proxy = FALSE, as_raw = NULL)</code>
</p>
<p><em>Arguments:</em>
</p>

<ul>
<li><p><code>as_proxy</code>:   Return as an <code><a href="#topic+mdb_proxy">mdb_proxy</a></code> object?

</p>
</li>
<li><p><code>as_raw</code>:   Return the value as raw.  With a value of <code>NULL</code> it will return a string if possible (i.e., if there are no null bytes) and a raw vector otherwise.  With <code>as_raw = TRUE</code> we always return a raw vector.  With <code>as_raw = FALSE</code> we always return a string, or throw an error if this is not possible.

</p>
</li></ul>

</dd>
<dt><code>value</code></dt><dd>
<p>Return the current value
</p>
<p><em>Usage:</em>
<code>value(as_proxy = FALSE, as_raw = NULL)</code>
</p>
<p><em>Arguments:</em>
</p>

<ul>
<li><p><code>as_proxy</code>:   Return as an <code><a href="#topic+mdb_proxy">mdb_proxy</a></code> object?

</p>
</li>
<li><p><code>as_raw</code>:   Return the value as raw.  With a value of <code>NULL</code> it will return a string if possible (i.e., if there are no null bytes) and a raw vector otherwise.  With <code>as_raw = TRUE</code> we always return a raw vector.  With <code>as_raw = FALSE</code> we always return a string, or throw an error if this is not possible.

</p>
</li></ul>

</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'># Start by creating a new environment, and within that a write
# transaction, and from that a new cursor.  But first put a bunch
# of data into the database
env &lt;- thor::mdb_env(tempfile())
env$mput(letters, LETTERS)
txn &lt;- env$begin(write = TRUE)
cur &lt;- txn$cursor()

# Move the cursor to the first position
cur$first()

# The key and value:
cur$key()
cur$value()

# Move to a different key:
cur$move_to("g")
cur$value()

# Delete the current item
cur$del()
cur$key()

# We can't move to 'g' any more as it's gone:
(cur$move_to("g"))
cur$key() # NULL

# But we can *seek* 'g', which will move to 'h'
(cur$seek("g"))
cur$key() # "h"

# Get raw values out:
cur$value(as_raw = TRUE)

# Cleanup
env$destroy()
</code></pre>

<hr>
<h2 id='mdb_dbi'>Use mdb transactions</h2><span id='topic+mdb_dbi'></span>

<h3>Description</h3>

<p>Database handles are fairly opaque objects used to indicate which
database within an <code><a href="#topic+mdb_env">mdb_env</a></code> operations will happen
to.  This object has therefore got very few methods, all of which
are purely informative.  Most commonly, a <code>mdb_dbi</code> object
will be passed into the <code><a href="#topic+mdb_env">mdb_env</a></code>'s <code>$begin()</code>
method to begin a transaction on a particular database.
</p>


<h3>Methods</h3>


<dl>
<dt><code>path</code></dt><dd>
<p>Return the absolute path to the LMDB store (on disk)
</p>
<p><em>Usage:</em>
<code>path()</code>
</p>
<p><em>Value</em>:
A string
</p>
<p><em>Note</em>: In lmdb.h this is <code>mdb_env_get_path()</code>
</p>
</dd>
<dt><code>flags</code></dt><dd>
<p>Return flags as used in construction of the LMDB environment
</p>
<p><em>Usage:</em>
<code>flags()</code>
</p>
<p><em>Value</em>:
A named logical vector.  Names correspond to arguments to the constructor.
</p>
<p><em>Note</em>: In lmdb.h this is <code>mdb_env_get_flags()</code>
</p>
</dd>
<dt><code>info</code></dt><dd>
<p>Brief information about the LMDB environment
</p>
<p><em>Usage:</em>
<code>info()</code>
</p>
<p><em>Value</em>:
An integer vector with elements <code>mapsize</code>, <code>last_pgno</code>, <code>last_txnid</code>, <code>maxreaders</code> and <code>numreaders</code>.
</p>
<p><em>Note</em>: In lmdb.h this is <code>mdb_env_info()</code>
</p>
</dd>
<dt><code>stat</code></dt><dd>
<p>Brief statistics about the LMDB environment.
</p>
<p><em>Usage:</em>
<code>stat()</code>
</p>
<p><em>Value</em>:
An integer vector with elements <code>psize</code> (the size of a database page), <code>depth</code> (depth of the B-tree), <code>brancb_pages</code> (number of internal non-leaf) pages), <code>leaf_pages</code> (number of leaf pages), <code>overflow_pages</code> (number of overflow pages) and <code>entries</code> (number of data items).
</p>
<p><em>Note</em>: In lmdb.h this is <code>mdb_env_stat()</code>
</p>
</dd>
<dt><code>maxkeysize</code></dt><dd>
<p>The maximum size of a key (the value can be bigger than this)
</p>
<p><em>Usage:</em>
<code>maxkeysize()</code>
</p>
<p><em>Value</em>:
A single integer
</p>
<p><em>Note</em>: In lmdb.h this is <code>mdb_env_get_maxkeysize()</code>
</p>
</dd>
<dt><code>maxreaders</code></dt><dd>
<p>The maximum number of readers
</p>
<p><em>Usage:</em>
<code>maxreaders()</code>
</p>
<p><em>Value</em>:
A single integer
</p>
<p><em>Note</em>: In lmdb.h this is <code>mdb_env_get_maxreaders()</code>
</p>
</dd>
<dt><code>begin</code></dt><dd>
<p>Begin a transaction
</p>
<p><em>Usage:</em>
<code>begin(db = NULL, write = FALSE, sync = NULL, metasync = NULL)</code>
</p>
<p><em>Arguments:</em>
</p>

<ul>
<li><p><code>db</code>:   A database handle, as returned by <code>open_database</code>.  If <code>NULL</code> (the default) then the default database will be used.

</p>
</li>
<li><p><code>write</code>:   Scalar logical, indicating if this should be a write transaction.  There can be only one write transaction per database (see <code><a href="#topic+mdb_txn">mdb_txn</a></code> for more details) - it is an error to try to open more than one.

</p>
</li>
<li><p><code>sync</code>:   Scalar logical, indicating if the data should be synchronised synchronised (flushed to disk) after writes; see main parameter list.

</p>
</li>
<li><p><code>metasync</code>:   Scalar logical, indicating if the metadata should be synchronised (flushed to disk) after writes; see main parameter list.

</p>
</li></ul>

<p><em>Details:</em>
Transactions are the key objects for interacting with an LMDB database (aside from the convenience interface below).  They are described in more detail in <code><a href="#topic+mdb_txn">mdb_txn</a></code>.
</p>
<p><em>Value</em>:
A <code><a href="#topic+mdb_txn">mdb_txn</a></code> object
</p>
<p><em>Note</em>: In lmdb.h this is <code>mdb_begin()</code>
</p>
</dd>
<dt><code>with_transaction</code></dt><dd>
<p>Evaluate some code within a transaction
</p>
<p><em>Usage:</em>
<code>with_transaction(fun, db = NULL, write = FALSE)</code>
</p>
<p><em>Arguments:</em>
</p>

<ul>
<li><p><code>fun</code>:   A function of one argument that does the work of the transaction.  <code>with_transaction</code> will pass the transaction to this function.  This is most easily explained with an example, so see the bottom of the help

</p>
</li>
<li><p><code>db</code>:   A database handle, as returned by <code>open_database</code>.  If <code>NULL</code> (the default) then the default database will be used.

</p>
</li>
<li><p><code>write</code>:   Scalar logical, indicating if this should be a write transaction.  There can be only one write transaction per database (see <code><a href="#topic+mdb_txn">mdb_txn</a></code> for more details) - it is an error to try to open more than one.

</p>
</li></ul>

<p><em>Details:</em>
This exists to simplify a pattern where one wants to open a transaction, evaluate some code with that transaction and if anything goes wrong abort, but otherwise commit.  It is most useful with read-write transactions, but can be used with both (and the default is for readonly transactions, like <code>begin()</code>.
</p>
</dd>
<dt><code>open_database</code></dt><dd>
<p>Open a named database, or return one if already opened.
</p>
<p><em>Usage:</em>
<code>open_database(key = NULL, reversekey = FALSE, create = TRUE)</code>
</p>
<p><em>Arguments:</em>
</p>

<ul>
<li><p><code>key</code>:   Name of the database; if <code>NULL</code> this returns the default database (always open).

</p>
</li>
<li><p><code>reversekey</code>:   Compare strings in reverse order? See <code>reversekey</code> documentation above

</p>
</li>
<li><p><code>create</code>:   Create database if it does not exist already?

</p>
</li></ul>

<p><em>Details:</em>
LMDB environments can hold multiple databases, provided they have been opened with <code>maxdbs</code> greater than one.  There is always a &quot;default&quot; database - this is unnamed and cannot be dropped. Other databases have a key (i.e., a name) and can be dropped. These database objects are passed through to other methods, notably <code>drop_database</code> and <code>begin</code>
</p>
<p><em>Note</em>: In lmdb.h this is <code>mdb_open()</code>
</p>
</dd>
<dt><code>drop_database</code></dt><dd>
<p>Drop a database
</p>
<p><em>Usage:</em>
<code>drop_database(db, delete = TRUE)</code>
</p>
<p><em>Arguments:</em>
</p>

<ul>
<li><p><code>db</code>:   A database object, as returned by <code>open_database</code>

</p>
</li>
<li><p><code>delete</code>:   Scalar logical, indicating if the database should be deleted too.  If <code>FALSE</code>, the values are deleted from the database (i.e., it is emptied). If <code>TRUE</code> then the actual database is deleted too.

</p>
</li></ul>

<p><em>Value</em>:
No return value, called for side effects only
</p>
<p><em>Note</em>: In lmdb.h this is <code>mdb_drop()</code>
</p>
</dd>
<dt><code>sync</code></dt><dd>
<p>Flush the data buffers to disk.
</p>
<p><em>Usage:</em>
<code>sync(force = FALSE)</code>
</p>
<p><em>Arguments:</em>
</p>

<ul>
<li><p><code>force</code>:   Scalar logical; force a synchronous flush.  Otherwise if the environment was constructed with <code>sync = FALSE</code> the flushes will be omitted, and with <code>mapasync = TRUE</code> they will be asynchronous.

</p>
</li></ul>

<p><em>Details:</em>
Data is always written to disk when a transaction is committed, but the operating system may keep it buffered.  LMDB always flushes the OS buffers upon commit as well, unless the environment was opened with <code>sync = FALSE</code> or in part <code>metasync = FALSE</code>.  This call is not valid if the environment was opened with <code>readonly = TRUE</code>.
</p>
<p><em>Note</em>: In lmdb.h this is <code>mdb_env_sync()</code>
</p>
</dd>
<dt><code>copy</code></dt><dd>
<p>Copy the entire environment state to a new path.  This can be used to make a backup of the database.
</p>
<p><em>Usage:</em>
<code>copy(path, compact = FALSE)</code>
</p>
<p><em>Arguments:</em>
</p>

<ul>
<li><p><code>path</code>:   Scalar character; the new path

</p>
</li>
<li><p><code>compact</code>:   Scalar logical; perform compaction while copying?  This omits free pages and sequentially renumbers all pages in output.  This can take longer than the default but produce a smaller database

</p>
</li></ul>

<p><em>Value</em>:
Invisibly, the new path (allowing use of <code>$copy(tempfile)</code>)
</p>
<p><em>Note</em>: In lmdb.h this is <code>mdb_env_copy()</code> &amp; <code>mdb_env_copy2()</code>
</p>
</dd>
<dt><code>close</code></dt><dd>
<p>Close the environment.  This closes all cursors and transactions (active write transactions are aborted).
</p>
<p><em>Usage:</em>
<code>close()</code>
</p>
<p><em>Value</em>:
No return value, called for side effects only
</p>
<p><em>Note</em>: In lmdb.h this is <code>mdb_env_close()</code>
</p>
</dd>
<dt><code>destroy</code></dt><dd>
<p>Totally destroy an LMDB environment.  This closes the database and removes the files.  Use with care!
</p>
<p><em>Usage:</em>
<code>destroy()</code>
</p>
<p><em>Value</em>:
No return value, called for side effects only
</p>
</dd>
<dt><code>reader_list</code></dt><dd>
<p>List information about database readers
</p>
<p><em>Usage:</em>
<code>reader_list()</code>
</p>
<p><em>Value</em>:
A character matrix with columns <code>pid</code> (process ID), <code>thread</code> (a pointer address), and <code>txnid</code> (a small integer)
</p>
<p><em>Note</em>: In lmdb.h this is <code>mdb_reader_list()</code>
</p>
</dd>
<dt><code>reader_check</code></dt><dd>
<p>Check for, and remove, stale entries in the reader lock table.
</p>
<p><em>Usage:</em>
<code>reader_check()</code>
</p>
<p><em>Value</em>:
An integer, being the number of stale readers discarded.  However, this function is primarily called for its side effect.
</p>
<p><em>Note</em>: In lmdb.h this is <code>mdb_reader_check()</code>
</p>
</dd>
<dt><code>get</code></dt><dd>
<p>Retrieve a value from the database
</p>
<p><em>Usage:</em>
<code>get(key, missing_is_error = TRUE, as_raw = NULL, db = NULL)</code>
</p>
<p><em>Arguments:</em>
</p>

<ul>
<li><p><code>key</code>:   A string (or raw vector) - the key to get

</p>
</li>
<li><p><code>missing_is_error</code>:   Logical, indicating if a missing value is an error (by default it is).  Alternatively, with <code>missing_is_error = FALSE</code>, a missing value will return <code>NULL</code>.  Because no value can be <code>NULL</code> (all values must have nonzero length) a <code>NULL</code> is unambiguously missing.

</p>
</li>
<li><p><code>as_raw</code>:   Either <code>NULL</code>, or a logical, to indicate the result type required.  With <code>as_raw = NULL</code>, the default, the value will be returned as a string if possible.  If not possible it will return a raw vector.  With <code>as_raw = TRUE</code>, <code>get()</code> will <em>always</em> return a raw vector, even when it is possibly to represent the value as a string.  If <code>as_raw = FALSE</code>, <code>get</code> will return a string, but throw an error if this is not possible.  This is discussed in more detail in the thor vignette (<code>vignette("thor")</code>)

</p>
</li>
<li><p><code>db</code>:   A database handle that would be passed through to create the transaction (see the <code>$begin</code> method).

</p>
</li></ul>

<p><em>Details:</em>
This is a helper method that establishes a temporary read-only transaction, calls the corresponding method in <code><a href="#topic+mdb_txn">mdb_txn</a></code> and then aborts the transaction.
</p>
<p><em>Note</em>: In lmdb.h this is <code>mdb_get()</code>
</p>
</dd>
<dt><code>put</code></dt><dd>
<p>Put values into the database.  In other systems, this might be called &quot;<code>set</code>&quot;.
</p>
<p><em>Usage:</em>
<code>put(key, value, overwrite = TRUE, append = FALSE, db = NULL)</code>
</p>
<p><em>Arguments:</em>
</p>

<ul>
<li><p><code>key</code>:   The name of the key (string or raw vector)

</p>
</li>
<li><p><code>value</code>:   The value to save (string or raw vector)

</p>
</li>
<li><p><code>overwrite</code>:   Logical - when <code>TRUE</code> it will overwrite existing data; when <code>FALSE</code> throw an error

</p>
</li>
<li><p><code>append</code>:   Logical - when <code>TRUE</code>, append the given key/value to the end of the database.  This option allows fast bulk loading when keys are already known to be in the correct order.  But if you load unsorted keys with <code>append = TRUE</code> an error will be thrown

</p>
</li>
<li><p><code>db</code>:   A database handle that would be passed through to create the transaction (see the <code>$begin</code> method).

</p>
</li></ul>

<p><em>Details:</em>
This is a helper method that establishes a temporary read-write transaction, calls the corresponding method in <code><a href="#topic+mdb_txn">mdb_txn</a></code> and then commits the transaction.  This will only be possible to use if there is not an existing write transaction in effect for this environment.
</p>
<p><em>Note</em>: In lmdb.h this is <code>mdb_put()</code>
</p>
</dd>
<dt><code>del</code></dt><dd>
<p>Remove a key/value pair from the database
</p>
<p><em>Usage:</em>
<code>del(key, db = NULL)</code>
</p>
<p><em>Arguments:</em>
</p>

<ul>
<li><p><code>key</code>:   The name of the key (string or raw vector)

</p>
</li>
<li><p><code>db</code>:   A database handle that would be passed through to create the transaction (see the <code>$begin</code> method).

</p>
</li></ul>

<p><em>Details:</em>
This is a helper method that establishes a temporary read-write transaction, calls the corresponding method in <code><a href="#topic+mdb_txn">mdb_txn</a></code> and then commits the transaction.  This will only be possible to use if there is not an existing write transaction in effect for this environment.
</p>
<p><em>Value</em>:
A scalar logical, indicating if the value was deleted
</p>
<p><em>Note</em>: In lmdb.h this is <code>mdb_del()</code>
</p>
</dd>
<dt><code>exists</code></dt><dd>
<p>Test if a key exists in the database.
</p>
<p><em>Usage:</em>
<code>exists(key, db = NULL)</code>
</p>
<p><em>Arguments:</em>
</p>

<ul>
<li><p><code>key</code>:   The name of the key to test (string or raw vector).  Unlike <code>get</code>, <code>put</code> and <code>del</code> (but like <code>mget</code>, <code>mput</code> and <code>mdel</code>), <code>exists</code> is <em>vectorised</em>.  So the input here can be; a character vector of any length (returning the same length logical vector), a raw vector (representing one key, returning a scalar logical) or a <code>list</code> with each element being either a scalar character or a raw vector, returning a logical the same length as the list.

</p>
</li>
<li><p><code>db</code>:   A database handle that would be passed through to create the transaction (see the <code>$begin</code> method).

</p>
</li></ul>

<p><em>Details:</em>
This is an extension of the raw LMDB API and works by using <code>mdb_get</code> for each key (which for lmdb need not copy data) and then testing whether the return value is <code>MDB_SUCCESS</code> or <code>MDB_NOTFOUND</code>.
</p>
<p>This is a helper method that establishes a temporary read-only transaction, calls the corresponding method in <code><a href="#topic+mdb_txn">mdb_txn</a></code> and then aborts the transaction.
</p>
<p><em>Value</em>:
A logical vector
</p>
</dd>
<dt><code>list</code></dt><dd>
<p>List keys in the database
</p>
<p><em>Usage:</em>
<code>list(starts_with = NULL, as_raw = FALSE, size = NULL, db = NULL)</code>
</p>
<p><em>Arguments:</em>
</p>

<ul>
<li><p><code>starts_with</code>:   Optionally, a prefix for all strings.  Note that is not a regular expression or a filename glob.  Using <code>foo</code> will match <code>foo</code>, <code>foo:bar</code> and <code>foobar</code> but not <code>fo</code> or <code>FOO</code>.  Because LMDB stores keys in a sorted tree, using a prefix can greatly reduce the number of keys that need to be tested.

</p>
</li>
<li><p><code>as_raw</code>:   Same interpretation as <code>as_raw</code> in <code>$get()</code> but with a different default.  It is expected that most of the time keys will be strings, so by default we'll try and return a character vector <code>as_raw = FALSE</code>.  Change the default if your database contains raw keys.

</p>
</li>
<li><p><code>size</code>:   For use with <code>starts_with</code>, optionally a guess at the number of keys that would be returned.  with <code>starts_with = NULL</code> we can look the number of keys up directly so this is ignored.

</p>
</li>
<li><p><code>db</code>:   A database handle that would be passed through to create the transaction (see the <code>$begin</code> method).

</p>
</li></ul>

<p><em>Details:</em>
This is a helper method that establishes a temporary read-only transaction, calls the corresponding method in <code><a href="#topic+mdb_txn">mdb_txn</a></code> and then aborts the transaction.
</p>
</dd>
<dt><code>mget</code></dt><dd>
<p>Get values for multiple keys at once (like <code>$get</code> but vectorised over <code>key</code>)
</p>
<p><em>Usage:</em>
<code>mget(key, as_raw = NULL, db = NULL)</code>
</p>
<p><em>Arguments:</em>
</p>

<ul>
<li><p><code>key</code>:   The keys to get values for.  Zero, one or more keys are allowed.

</p>
</li>
<li><p><code>as_raw</code>:   As for <code>$get()</code>, logical (or <code>NULL</code>) indicating if raw or string output is expected or desired.

</p>
</li>
<li><p><code>db</code>:   A database handle that would be passed through to create the transaction (see the <code>$begin</code> method).

</p>
</li></ul>

<p><em>Details:</em>
This is a helper method that establishes a temporary read-only transaction, calls the corresponding method in <code><a href="#topic+mdb_txn">mdb_txn</a></code> and then aborts the transaction.
</p>
</dd>
<dt><code>mput</code></dt><dd>
<p>Put multiple values into the database (like <code>$put</code> but vectorised over <code>key</code>/<code>value</code>).
</p>
<p><em>Usage:</em>
<code>mput(key, value, overwrite = TRUE, append = FALSE, db = NULL)</code>
</p>
<p><em>Arguments:</em>
</p>

<ul>
<li><p><code>key</code>:   The keys to set

</p>
</li>
<li><p><code>value</code>:   The values to set against these keys.  Must be the same length as <code>key</code>.

</p>
</li>
<li><p><code>overwrite</code>:   As for <code>$put</code>

</p>
</li>
<li><p><code>append</code>:   As for <code>$put</code>

</p>
</li>
<li><p><code>db</code>:   A database handle that would be passed through to create the transaction (see the <code>$begin</code> method).

</p>
</li></ul>

<p><em>Details:</em>
The implementation simply calls <code>mdb_put</code> repeatedly (but with a single round of error checking) so duplicate <code>key</code> entries will result in the last key winning.
</p>
<p>This is a helper method that establishes a temporary read-write transaction, calls the corresponding method in <code><a href="#topic+mdb_txn">mdb_txn</a></code> and then commits the transaction.  This will only be possible to use if there is not an existing write transaction in effect for this environment.
</p>
</dd>
<dt><code>mdel</code></dt><dd>
<p>Delete multiple values from the database (like <code>$del</code> but vectorised over <code>key</code>).
</p>
<p><em>Usage:</em>
<code>mdel(key, db = NULL)</code>
</p>
<p><em>Arguments:</em>
</p>

<ul>
<li><p><code>key</code>:   The keys to delete

</p>
</li>
<li><p><code>db</code>:   A database handle that would be passed through to create the transaction (see the <code>$begin</code> method).

</p>
</li></ul>

<p><em>Details:</em>
This is a helper method that establishes a temporary read-write transaction, calls the corresponding method in <code><a href="#topic+mdb_txn">mdb_txn</a></code> and then commits the transaction.  This will only be possible to use if there is not an existing write transaction in effect for this environment.
</p>
<p><em>Value</em>:
A logical vector, the same length as <code>key</code>, indicating if each key was deleted.
</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>
# As always, start with the environment.  Because we're going to
# use more than one database, we must set `maxdbs` to more than 1:
env &lt;- thor::mdb_env(tempfile(), maxdbs = 10)

# The default environment - every database
db &lt;- env$open_database()
# The default database will always have id 1 and no name
db$id()
db$name()

# A different database
foo &lt;- env$open_database("foo")
foo$id()
foo$name()

# Opening a database multiple times has no effect - it returns the
# same data base every call.
identical(env$open_database("foo"), foo) # TRUE

# Then we can put some data int the new database:
txn &lt;- env$begin(foo, write = TRUE)
txn$put("hello", "world")
txn$commit()

# Now we have values in the "foo" database, but not the default one:
env$get("hello", db = NULL, missing_is_error = FALSE) # NULL
env$get("hello", db = foo,  missing_is_error = FALSE) # "world"

# Cleanup
env$destroy()
</code></pre>

<hr>
<h2 id='mdb_env'>Create an mdb_env environment</h2><span id='topic+mdb_env'></span>

<h3>Description</h3>

<p>Create a <code>mdb_env</code> &quot;environment&quot; object.  This is the way
that interacts with a lmdb database and once created, includes
methods for querying the environment, creating databases, starting
transactions and (through those) adding, getting and removing
data.  This page includes <em>reference</em> documentation for the
object and readers are first directed to the vignette
(<code>vignette("thor"</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mdb_env(
  path,
  mode = as.octmode("644"),
  subdir = TRUE,
  readonly = FALSE,
  metasync = TRUE,
  sync = TRUE,
  writemap = FALSE,
  lock = TRUE,
  mapasync = FALSE,
  rdahead = TRUE,
  meminit = TRUE,
  maxdbs = NULL,
  maxreaders = NULL,
  mapsize = NULL,
  reversekey = FALSE,
  create = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mdb_env_+3A_path">path</code></td>
<td>
<p>The directory in which the database files will reside.
If <code>create</code> is <code>TRUE</code> this path will be created for
you if it does not exist (in contrast with the <code>lmdb</code> C
API).  If <code>subdir</code> is <code>FALSE</code> this is the path to the
database file and an additional lock file will be created by
appending &quot;-lock&quot; to <code>path</code>.</p>
</td></tr>
<tr><td><code id="mdb_env_+3A_mode">mode</code></td>
<td>
<p>The file mode (UNIX file permissions) to set on
created files.  this must be an <code>octmode</code> object, with the
default (<code>as.octmode("644"</code>) being user-writeable and
world-readable.</p>
</td></tr>
<tr><td><code id="mdb_env_+3A_subdir">subdir</code></td>
<td>
<p>By default, lmdb creates its files within a directory
(at <code>path</code>).  If <code>subdir = FALSE</code> then the <code>path</code>
is interpreted as the path to the main database file and a lock
file will be created with &quot;-lock&quot; appended to the filename.
Passing <code>subdir = FALSE</code> is equivalent to lmdb's
<code>MDB_NOSUBDIR</code> flag.</p>
</td></tr>
<tr><td><code id="mdb_env_+3A_readonly">readonly</code></td>
<td>
<p>Open the environment in read-only mode.  No write
operations are allowed.  LMDB will still modify the lock file.
Passing <code>readonly = TRUE</code> is equivalent to lmdb's
<code>MDB_RDONLY</code> flag.  If you want a to modify nothing no
disk, pass <code>lock = FALSE</code> also (but beware that concurrent
access may not go to plan).</p>
</td></tr>
<tr><td><code id="mdb_env_+3A_metasync">metasync</code></td>
<td>
<p>If <code>FALSE</code>, flush system buffers to disk only
once per transaction, omit the metadata flush. Defer that until
the system flushes files to disk, or next commit or the next
call to the <code>$sync()</code> method.  This optimization maintains
database integrity, but a system crash may undo the last
committed transaction. I.e. it preserves the A, C and I (atomicity,
consistency, isolation) properties but not D (durability) database
property.  Passing <code>metasync = FALSE</code> is equivalent to
lmdb's <code>MDB_NOMETASYNC</code> flag.</p>
</td></tr>
<tr><td><code id="mdb_env_+3A_sync">sync</code></td>
<td>
<p>If <code>FALSE</code>, don't flush system buffers to disk
when committing a transaction.  This optimization means a system
crash can corrupt the database or lose the last transactions if
buffers are not yet flushed to disk.  The risk is governed by
how often the system flushes dirty buffers to disk and how often
the <code>$sync()</code> method is called.  However, if the filesystem
preserves write order and <code>writemap = FALSE</code>, transactions
exhibit ACI (atomicity, consistency, isolation) properties and
only lose D (durability).  I.e. database integrity is
maintained, but a system crash may undo the final transactions.
Note that <code>sync = FALSE, writemap = TRUE</code> leaves the system
with no hint for when to write transactions to disk, unless
<code>$sync()</code> is called.  <code>map_async = TRUE, writemap =
TRUE</code> may be preferable.  Passing <code>sync = FALSE</code> is
equivalent to lmdb's <code>MDB_NOSYNC</code> flag.</p>
</td></tr>
<tr><td><code id="mdb_env_+3A_writemap">writemap</code></td>
<td>
<p>If <code>TRUE</code>, use a writeable memory map unless
<code>readonly = TRUE</code> is set. This uses fewer mallocs but loses
protection from application bugs like wild pointer writes and
other bad updates into the database. This may be slightly faster
for databases that fit entirely in RAM, but is slower for
databases larger than RAM. Incompatible with nested
transactions. Do not mix processes with <code>writemap = TRUE</code>
and <code>writemap = FALSE</code> on the same environment.  This can
defeat durability (<code>$sync()</code> etc).  Passing <code>writemap
= TRUE</code> is equivalent to lmdb's <code>MDB_WRITEMAP</code> flag.</p>
</td></tr>
<tr><td><code id="mdb_env_+3A_lock">lock</code></td>
<td>
<p>If <code>FALSE</code>, don't do any locking. If concurrent
access is anticipated, the caller must manage all concurrency
itself. For proper operation the caller must enforce
single-writer semantics, and must ensure that no readers are
using old transactions while a writer is active. The simplest
approach is to use an exclusive lock so that no readers may be
active at all when a writer begins.  Passing <code>lock = FALSE</code>
is equivalent to lmdb's <code>MDB_NOLOCK</code> flag.</p>
</td></tr>
<tr><td><code id="mdb_env_+3A_mapasync">mapasync</code></td>
<td>
<p>If <code>TRUE</code>, When using <code>writemap = TRUE</code>,
use asynchronous flushes to disk.  As with <code>sync = FALSE</code>,
a system crash can then corrupt the database or lose the last
transactions. Calling <code>$sync()</code> ensures on-disk database
integrity until next commit.  Passing <code>mapasync = FALSE</code> is
equivalent to lmdb's <code>MDB_MAPASYNC</code> flag.</p>
</td></tr>
<tr><td><code id="mdb_env_+3A_rdahead">rdahead</code></td>
<td>
<p>If <code>FALSE</code>, turn off readahead. Most operating
systems perform readahead on read requests by default. This
option turns it off if the OS supports it. Turning it off may
help random read performance when the DB is larger than RAM and
system RAM is full.  <code>rdahead = FALSE</code> is not implemented
on Windows.  Passing <code>rdahead = FALSE</code> is equivalent to
lmdb's <code>MDB_NORDAHEAD</code> flag.</p>
</td></tr>
<tr><td><code id="mdb_env_+3A_meminit">meminit</code></td>
<td>
<p>If <code>FALSE</code>, don't initialize malloc'd memory
before writing to unused spaces in the data file. By default,
memory for pages written to the data file is obtained using
malloc. While these pages may be reused in subsequent
transactions, freshly malloc'd pages will be initialized to
zeroes before use. This avoids persisting leftover data from
other code (that used the heap and subsequently freed the
memory) into the data file. Note that many other system
libraries may allocate and free memory from the heap for
arbitrary uses. E.g., stdio may use the heap for file I/O
buffers. This initialization step has a modest performance cost
so some applications may want to disable it using this
flag. This option can be a problem for applications which handle
sensitive data like passwords, and it makes memory checkers like
Valgrind noisy. This flag is not needed with <code>writemap =
TRUE</code>, which writes directly to the mmap instead of using malloc
for pages.  Passing <code>meminit = FALSE</code> is equivalent to
lmdb's <code>MDB_NOMEMINIT</code>.</p>
</td></tr>
<tr><td><code id="mdb_env_+3A_maxdbs">maxdbs</code></td>
<td>
<p>The number of databases available within the
environment.  If 0 (the default), then the environment holds
just one database (the main db).  To use named databases this
must be set greater than one.</p>
</td></tr>
<tr><td><code id="mdb_env_+3A_maxreaders">maxreaders</code></td>
<td>
<p>Maximum number of simultaneous read
transactions.  Can only be set in the first process to open an
environment.</p>
</td></tr>
<tr><td><code id="mdb_env_+3A_mapsize">mapsize</code></td>
<td>
<p>Maximum size database may grow to; used to size the
memory mapping. This is measured in bytes, and the default (as
set in lmdb) is only 1MB (2^20 bytes). If database grows larger
than <code>map_size</code>, an error will be thrown and the user must
close and reopen the <code>mdb_env</code>.  On 64-bit there is no
penalty for making this huge (say 1TB). Must be &lt;2GB on 32-bit.
Increasing this may cause your operating system to report the
disk as being used while your database is open, though this is
just the amount reserved.</p>
</td></tr>
<tr><td><code id="mdb_env_+3A_reversekey">reversekey</code></td>
<td>
<p>Passed through to <code>open_database</code> for the
main database.  If <code>TRUE</code>, keys are strings to be compared
in reverse order, from the end of the strings to the beginning
(e.g., DNS names). By default, keys are treated as strings and
compared from beginning to end.  Passing <code>reversekey = TRUE</code>
is equivalent to lmdb's <code>MDB_REVERSEKEY</code>.</p>
</td></tr>
<tr><td><code id="mdb_env_+3A_create">create</code></td>
<td>
<p>If <code>FALSE</code>, do not create the directory
<code>path</code> if it is missing.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>thor</code> package is a wrapper around <code>lmdb</code> and so
below I have provided pointers to relevant options in <code>lmdb</code>
- the wrapper is fairly thin and so picks up limitations and
restrictions from the underlying library.  Some portions of the
documentation here derives from the lmdb source documentation -
the file lmdb.h in particular.
</p>


<h3>Methods</h3>


<dl>
<dt><code>path</code></dt><dd>
<p>Return the absolute path to the LMDB store (on disk)
</p>
<p><em>Usage:</em>
<code>path()</code>
</p>
<p><em>Value</em>:
A string
</p>
<p><em>Note</em>: In lmdb.h this is <code>mdb_env_get_path()</code>
</p>
</dd>
<dt><code>flags</code></dt><dd>
<p>Return flags as used in construction of the LMDB environment
</p>
<p><em>Usage:</em>
<code>flags()</code>
</p>
<p><em>Value</em>:
A named logical vector.  Names correspond to arguments to the constructor.
</p>
<p><em>Note</em>: In lmdb.h this is <code>mdb_env_get_flags()</code>
</p>
</dd>
<dt><code>info</code></dt><dd>
<p>Brief information about the LMDB environment
</p>
<p><em>Usage:</em>
<code>info()</code>
</p>
<p><em>Value</em>:
An integer vector with elements <code>mapsize</code>, <code>last_pgno</code>, <code>last_txnid</code>, <code>maxreaders</code> and <code>numreaders</code>.
</p>
<p><em>Note</em>: In lmdb.h this is <code>mdb_env_info()</code>
</p>
</dd>
<dt><code>stat</code></dt><dd>
<p>Brief statistics about the LMDB environment.
</p>
<p><em>Usage:</em>
<code>stat()</code>
</p>
<p><em>Value</em>:
An integer vector with elements <code>psize</code> (the size of a database page), <code>depth</code> (depth of the B-tree), <code>brancb_pages</code> (number of internal non-leaf) pages), <code>leaf_pages</code> (number of leaf pages), <code>overflow_pages</code> (number of overflow pages) and <code>entries</code> (number of data items).
</p>
<p><em>Note</em>: In lmdb.h this is <code>mdb_env_stat()</code>
</p>
</dd>
<dt><code>maxkeysize</code></dt><dd>
<p>The maximum size of a key (the value can be bigger than this)
</p>
<p><em>Usage:</em>
<code>maxkeysize()</code>
</p>
<p><em>Value</em>:
A single integer
</p>
<p><em>Note</em>: In lmdb.h this is <code>mdb_env_get_maxkeysize()</code>
</p>
</dd>
<dt><code>maxreaders</code></dt><dd>
<p>The maximum number of readers
</p>
<p><em>Usage:</em>
<code>maxreaders()</code>
</p>
<p><em>Value</em>:
A single integer
</p>
<p><em>Note</em>: In lmdb.h this is <code>mdb_env_get_maxreaders()</code>
</p>
</dd>
<dt><code>begin</code></dt><dd>
<p>Begin a transaction
</p>
<p><em>Usage:</em>
<code>begin(db = NULL, write = FALSE, sync = NULL, metasync = NULL)</code>
</p>
<p><em>Arguments:</em>
</p>

<ul>
<li><p><code>db</code>:   A database handle, as returned by <code>open_database</code>.  If <code>NULL</code> (the default) then the default database will be used.

</p>
</li>
<li><p><code>write</code>:   Scalar logical, indicating if this should be a write transaction.  There can be only one write transaction per database (see <code><a href="#topic+mdb_txn">mdb_txn</a></code> for more details) - it is an error to try to open more than one.

</p>
</li>
<li><p><code>sync</code>:   Scalar logical, indicating if the data should be synchronised synchronised (flushed to disk) after writes; see main parameter list.

</p>
</li>
<li><p><code>metasync</code>:   Scalar logical, indicating if the metadata should be synchronised (flushed to disk) after writes; see main parameter list.

</p>
</li></ul>

<p><em>Details:</em>
Transactions are the key objects for interacting with an LMDB database (aside from the convenience interface below).  They are described in more detail in <code><a href="#topic+mdb_txn">mdb_txn</a></code>.
</p>
<p><em>Value</em>:
A <code><a href="#topic+mdb_txn">mdb_txn</a></code> object
</p>
<p><em>Note</em>: In lmdb.h this is <code>mdb_begin()</code>
</p>
</dd>
<dt><code>with_transaction</code></dt><dd>
<p>Evaluate some code within a transaction
</p>
<p><em>Usage:</em>
<code>with_transaction(fun, db = NULL, write = FALSE)</code>
</p>
<p><em>Arguments:</em>
</p>

<ul>
<li><p><code>fun</code>:   A function of one argument that does the work of the transaction.  <code>with_transaction</code> will pass the transaction to this function.  This is most easily explained with an example, so see the bottom of the help

</p>
</li>
<li><p><code>db</code>:   A database handle, as returned by <code>open_database</code>.  If <code>NULL</code> (the default) then the default database will be used.

</p>
</li>
<li><p><code>write</code>:   Scalar logical, indicating if this should be a write transaction.  There can be only one write transaction per database (see <code><a href="#topic+mdb_txn">mdb_txn</a></code> for more details) - it is an error to try to open more than one.

</p>
</li></ul>

<p><em>Details:</em>
This exists to simplify a pattern where one wants to open a transaction, evaluate some code with that transaction and if anything goes wrong abort, but otherwise commit.  It is most useful with read-write transactions, but can be used with both (and the default is for readonly transactions, like <code>begin()</code>.
</p>
</dd>
<dt><code>open_database</code></dt><dd>
<p>Open a named database, or return one if already opened.
</p>
<p><em>Usage:</em>
<code>open_database(key = NULL, reversekey = FALSE, create = TRUE)</code>
</p>
<p><em>Arguments:</em>
</p>

<ul>
<li><p><code>key</code>:   Name of the database; if <code>NULL</code> this returns the default database (always open).

</p>
</li>
<li><p><code>reversekey</code>:   Compare strings in reverse order? See <code>reversekey</code> documentation above

</p>
</li>
<li><p><code>create</code>:   Create database if it does not exist already?

</p>
</li></ul>

<p><em>Details:</em>
LMDB environments can hold multiple databases, provided they have been opened with <code>maxdbs</code> greater than one.  There is always a &quot;default&quot; database - this is unnamed and cannot be dropped. Other databases have a key (i.e., a name) and can be dropped. These database objects are passed through to other methods, notably <code>drop_database</code> and <code>begin</code>
</p>
<p><em>Note</em>: In lmdb.h this is <code>mdb_open()</code>
</p>
</dd>
<dt><code>drop_database</code></dt><dd>
<p>Drop a database
</p>
<p><em>Usage:</em>
<code>drop_database(db, delete = TRUE)</code>
</p>
<p><em>Arguments:</em>
</p>

<ul>
<li><p><code>db</code>:   A database object, as returned by <code>open_database</code>

</p>
</li>
<li><p><code>delete</code>:   Scalar logical, indicating if the database should be deleted too.  If <code>FALSE</code>, the values are deleted from the database (i.e., it is emptied). If <code>TRUE</code> then the actual database is deleted too.

</p>
</li></ul>

<p><em>Value</em>:
No return value, called for side effects only
</p>
<p><em>Note</em>: In lmdb.h this is <code>mdb_drop()</code>
</p>
</dd>
<dt><code>sync</code></dt><dd>
<p>Flush the data buffers to disk.
</p>
<p><em>Usage:</em>
<code>sync(force = FALSE)</code>
</p>
<p><em>Arguments:</em>
</p>

<ul>
<li><p><code>force</code>:   Scalar logical; force a synchronous flush.  Otherwise if the environment was constructed with <code>sync = FALSE</code> the flushes will be omitted, and with <code>mapasync = TRUE</code> they will be asynchronous.

</p>
</li></ul>

<p><em>Details:</em>
Data is always written to disk when a transaction is committed, but the operating system may keep it buffered.  LMDB always flushes the OS buffers upon commit as well, unless the environment was opened with <code>sync = FALSE</code> or in part <code>metasync = FALSE</code>.  This call is not valid if the environment was opened with <code>readonly = TRUE</code>.
</p>
<p><em>Note</em>: In lmdb.h this is <code>mdb_env_sync()</code>
</p>
</dd>
<dt><code>copy</code></dt><dd>
<p>Copy the entire environment state to a new path.  This can be used to make a backup of the database.
</p>
<p><em>Usage:</em>
<code>copy(path, compact = FALSE)</code>
</p>
<p><em>Arguments:</em>
</p>

<ul>
<li><p><code>path</code>:   Scalar character; the new path

</p>
</li>
<li><p><code>compact</code>:   Scalar logical; perform compaction while copying?  This omits free pages and sequentially renumbers all pages in output.  This can take longer than the default but produce a smaller database

</p>
</li></ul>

<p><em>Value</em>:
Invisibly, the new path (allowing use of <code>$copy(tempfile)</code>)
</p>
<p><em>Note</em>: In lmdb.h this is <code>mdb_env_copy()</code> &amp; <code>mdb_env_copy2()</code>
</p>
</dd>
<dt><code>close</code></dt><dd>
<p>Close the environment.  This closes all cursors and transactions (active write transactions are aborted).
</p>
<p><em>Usage:</em>
<code>close()</code>
</p>
<p><em>Value</em>:
No return value, called for side effects only
</p>
<p><em>Note</em>: In lmdb.h this is <code>mdb_env_close()</code>
</p>
</dd>
<dt><code>destroy</code></dt><dd>
<p>Totally destroy an LMDB environment.  This closes the database and removes the files.  Use with care!
</p>
<p><em>Usage:</em>
<code>destroy()</code>
</p>
<p><em>Value</em>:
No return value, called for side effects only
</p>
</dd>
<dt><code>reader_list</code></dt><dd>
<p>List information about database readers
</p>
<p><em>Usage:</em>
<code>reader_list()</code>
</p>
<p><em>Value</em>:
A character matrix with columns <code>pid</code> (process ID), <code>thread</code> (a pointer address), and <code>txnid</code> (a small integer)
</p>
<p><em>Note</em>: In lmdb.h this is <code>mdb_reader_list()</code>
</p>
</dd>
<dt><code>reader_check</code></dt><dd>
<p>Check for, and remove, stale entries in the reader lock table.
</p>
<p><em>Usage:</em>
<code>reader_check()</code>
</p>
<p><em>Value</em>:
An integer, being the number of stale readers discarded.  However, this function is primarily called for its side effect.
</p>
<p><em>Note</em>: In lmdb.h this is <code>mdb_reader_check()</code>
</p>
</dd>
<dt><code>get</code></dt><dd>
<p>Retrieve a value from the database
</p>
<p><em>Usage:</em>
<code>get(key, missing_is_error = TRUE, as_raw = NULL, db = NULL)</code>
</p>
<p><em>Arguments:</em>
</p>

<ul>
<li><p><code>key</code>:   A string (or raw vector) - the key to get

</p>
</li>
<li><p><code>missing_is_error</code>:   Logical, indicating if a missing value is an error (by default it is).  Alternatively, with <code>missing_is_error = FALSE</code>, a missing value will return <code>NULL</code>.  Because no value can be <code>NULL</code> (all values must have nonzero length) a <code>NULL</code> is unambiguously missing.

</p>
</li>
<li><p><code>as_raw</code>:   Either <code>NULL</code>, or a logical, to indicate the result type required.  With <code>as_raw = NULL</code>, the default, the value will be returned as a string if possible.  If not possible it will return a raw vector.  With <code>as_raw = TRUE</code>, <code>get()</code> will <em>always</em> return a raw vector, even when it is possibly to represent the value as a string.  If <code>as_raw = FALSE</code>, <code>get</code> will return a string, but throw an error if this is not possible.  This is discussed in more detail in the thor vignette (<code>vignette("thor")</code>)

</p>
</li>
<li><p><code>db</code>:   A database handle that would be passed through to create the transaction (see the <code>$begin</code> method).

</p>
</li></ul>

<p><em>Details:</em>
This is a helper method that establishes a temporary read-only transaction, calls the corresponding method in <code><a href="#topic+mdb_txn">mdb_txn</a></code> and then aborts the transaction.
</p>
<p><em>Note</em>: In lmdb.h this is <code>mdb_get()</code>
</p>
</dd>
<dt><code>put</code></dt><dd>
<p>Put values into the database.  In other systems, this might be called &quot;<code>set</code>&quot;.
</p>
<p><em>Usage:</em>
<code>put(key, value, overwrite = TRUE, append = FALSE, db = NULL)</code>
</p>
<p><em>Arguments:</em>
</p>

<ul>
<li><p><code>key</code>:   The name of the key (string or raw vector)

</p>
</li>
<li><p><code>value</code>:   The value to save (string or raw vector)

</p>
</li>
<li><p><code>overwrite</code>:   Logical - when <code>TRUE</code> it will overwrite existing data; when <code>FALSE</code> throw an error

</p>
</li>
<li><p><code>append</code>:   Logical - when <code>TRUE</code>, append the given key/value to the end of the database.  This option allows fast bulk loading when keys are already known to be in the correct order.  But if you load unsorted keys with <code>append = TRUE</code> an error will be thrown

</p>
</li>
<li><p><code>db</code>:   A database handle that would be passed through to create the transaction (see the <code>$begin</code> method).

</p>
</li></ul>

<p><em>Details:</em>
This is a helper method that establishes a temporary read-write transaction, calls the corresponding method in <code><a href="#topic+mdb_txn">mdb_txn</a></code> and then commits the transaction.  This will only be possible to use if there is not an existing write transaction in effect for this environment.
</p>
<p><em>Note</em>: In lmdb.h this is <code>mdb_put()</code>
</p>
</dd>
<dt><code>del</code></dt><dd>
<p>Remove a key/value pair from the database
</p>
<p><em>Usage:</em>
<code>del(key, db = NULL)</code>
</p>
<p><em>Arguments:</em>
</p>

<ul>
<li><p><code>key</code>:   The name of the key (string or raw vector)

</p>
</li>
<li><p><code>db</code>:   A database handle that would be passed through to create the transaction (see the <code>$begin</code> method).

</p>
</li></ul>

<p><em>Details:</em>
This is a helper method that establishes a temporary read-write transaction, calls the corresponding method in <code><a href="#topic+mdb_txn">mdb_txn</a></code> and then commits the transaction.  This will only be possible to use if there is not an existing write transaction in effect for this environment.
</p>
<p><em>Value</em>:
A scalar logical, indicating if the value was deleted
</p>
<p><em>Note</em>: In lmdb.h this is <code>mdb_del()</code>
</p>
</dd>
<dt><code>exists</code></dt><dd>
<p>Test if a key exists in the database.
</p>
<p><em>Usage:</em>
<code>exists(key, db = NULL)</code>
</p>
<p><em>Arguments:</em>
</p>

<ul>
<li><p><code>key</code>:   The name of the key to test (string or raw vector).  Unlike <code>get</code>, <code>put</code> and <code>del</code> (but like <code>mget</code>, <code>mput</code> and <code>mdel</code>), <code>exists</code> is <em>vectorised</em>.  So the input here can be; a character vector of any length (returning the same length logical vector), a raw vector (representing one key, returning a scalar logical) or a <code>list</code> with each element being either a scalar character or a raw vector, returning a logical the same length as the list.

</p>
</li>
<li><p><code>db</code>:   A database handle that would be passed through to create the transaction (see the <code>$begin</code> method).

</p>
</li></ul>

<p><em>Details:</em>
This is an extension of the raw LMDB API and works by using <code>mdb_get</code> for each key (which for lmdb need not copy data) and then testing whether the return value is <code>MDB_SUCCESS</code> or <code>MDB_NOTFOUND</code>.
</p>
<p>This is a helper method that establishes a temporary read-only transaction, calls the corresponding method in <code><a href="#topic+mdb_txn">mdb_txn</a></code> and then aborts the transaction.
</p>
<p><em>Value</em>:
A logical vector
</p>
</dd>
<dt><code>list</code></dt><dd>
<p>List keys in the database
</p>
<p><em>Usage:</em>
<code>list(starts_with = NULL, as_raw = FALSE, size = NULL, db = NULL)</code>
</p>
<p><em>Arguments:</em>
</p>

<ul>
<li><p><code>starts_with</code>:   Optionally, a prefix for all strings.  Note that is not a regular expression or a filename glob.  Using <code>foo</code> will match <code>foo</code>, <code>foo:bar</code> and <code>foobar</code> but not <code>fo</code> or <code>FOO</code>.  Because LMDB stores keys in a sorted tree, using a prefix can greatly reduce the number of keys that need to be tested.

</p>
</li>
<li><p><code>as_raw</code>:   Same interpretation as <code>as_raw</code> in <code>$get()</code> but with a different default.  It is expected that most of the time keys will be strings, so by default we'll try and return a character vector <code>as_raw = FALSE</code>.  Change the default if your database contains raw keys.

</p>
</li>
<li><p><code>size</code>:   For use with <code>starts_with</code>, optionally a guess at the number of keys that would be returned.  with <code>starts_with = NULL</code> we can look the number of keys up directly so this is ignored.

</p>
</li>
<li><p><code>db</code>:   A database handle that would be passed through to create the transaction (see the <code>$begin</code> method).

</p>
</li></ul>

<p><em>Details:</em>
This is a helper method that establishes a temporary read-only transaction, calls the corresponding method in <code><a href="#topic+mdb_txn">mdb_txn</a></code> and then aborts the transaction.
</p>
</dd>
<dt><code>mget</code></dt><dd>
<p>Get values for multiple keys at once (like <code>$get</code> but vectorised over <code>key</code>)
</p>
<p><em>Usage:</em>
<code>mget(key, as_raw = NULL, db = NULL)</code>
</p>
<p><em>Arguments:</em>
</p>

<ul>
<li><p><code>key</code>:   The keys to get values for.  Zero, one or more keys are allowed.

</p>
</li>
<li><p><code>as_raw</code>:   As for <code>$get()</code>, logical (or <code>NULL</code>) indicating if raw or string output is expected or desired.

</p>
</li>
<li><p><code>db</code>:   A database handle that would be passed through to create the transaction (see the <code>$begin</code> method).

</p>
</li></ul>

<p><em>Details:</em>
This is a helper method that establishes a temporary read-only transaction, calls the corresponding method in <code><a href="#topic+mdb_txn">mdb_txn</a></code> and then aborts the transaction.
</p>
</dd>
<dt><code>mput</code></dt><dd>
<p>Put multiple values into the database (like <code>$put</code> but vectorised over <code>key</code>/<code>value</code>).
</p>
<p><em>Usage:</em>
<code>mput(key, value, overwrite = TRUE, append = FALSE, db = NULL)</code>
</p>
<p><em>Arguments:</em>
</p>

<ul>
<li><p><code>key</code>:   The keys to set

</p>
</li>
<li><p><code>value</code>:   The values to set against these keys.  Must be the same length as <code>key</code>.

</p>
</li>
<li><p><code>overwrite</code>:   As for <code>$put</code>

</p>
</li>
<li><p><code>append</code>:   As for <code>$put</code>

</p>
</li>
<li><p><code>db</code>:   A database handle that would be passed through to create the transaction (see the <code>$begin</code> method).

</p>
</li></ul>

<p><em>Details:</em>
The implementation simply calls <code>mdb_put</code> repeatedly (but with a single round of error checking) so duplicate <code>key</code> entries will result in the last key winning.
</p>
<p>This is a helper method that establishes a temporary read-write transaction, calls the corresponding method in <code><a href="#topic+mdb_txn">mdb_txn</a></code> and then commits the transaction.  This will only be possible to use if there is not an existing write transaction in effect for this environment.
</p>
</dd>
<dt><code>mdel</code></dt><dd>
<p>Delete multiple values from the database (like <code>$del</code> but vectorised over <code>key</code>).
</p>
<p><em>Usage:</em>
<code>mdel(key, db = NULL)</code>
</p>
<p><em>Arguments:</em>
</p>

<ul>
<li><p><code>key</code>:   The keys to delete

</p>
</li>
<li><p><code>db</code>:   A database handle that would be passed through to create the transaction (see the <code>$begin</code> method).

</p>
</li></ul>

<p><em>Details:</em>
This is a helper method that establishes a temporary read-write transaction, calls the corresponding method in <code><a href="#topic+mdb_txn">mdb_txn</a></code> and then commits the transaction.  This will only be possible to use if there is not an existing write transaction in effect for this environment.
</p>
<p><em>Value</em>:
A logical vector, the same length as <code>key</code>, indicating if each key was deleted.
</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'># Create a new environment (just using defaults)
env &lt;- thor::mdb_env(tempfile())

# At its most simple (using temporary transactions)
env$put("a", "hello world")
env$get("a")

# Or create transactions
txn &lt;- env$begin(write = TRUE)
txn$put("b", "another")
txn$put("c", "value")

# Transaction not committed so value not visible outside our transaction
env$get("b", missing_is_error = FALSE)

# After committing, the values are visible for new transactions
txn$commit()
env$get("b", missing_is_error = FALSE)

# A convenience method, 'with_transaction' exists to allow
# transactional workflows with less code repetition.

# This will get the old value of a key 'a', set 'a' to a new value
# and return the old value:
env$with_transaction(function(txn) {
  val &lt;- txn$get("a")
  txn$put("a", "new_value")
  val
}, write = TRUE)

# If an error occurred, the transaction would be aborted.  So far,
# not very interesting!

# More interesting: implementing redis's RPOPLPUSH that takes the
# last value off of the end of one list and pushes it into the
# start of another.
rpoplpush &lt;- function(env, src, dest) {
  f &lt;- function(txn) {
    # Take the value out of the source list and update
    val &lt;- unserialize(txn$get(src, as_raw = TRUE))
    take &lt;- val[[length(val)]]
    txn$put(src, serialize(val[-length(val)], NULL))

    # Put the value onto the destination list
    val &lt;- unserialize(txn$get(dest, as_raw = TRUE))
    txn$put(dest, serialize(c(val, take), NULL))

    # And we'll return the value that was modified
    take
  }
  env$with_transaction(f, write = TRUE)
}

# Set things up - a source list with numbers 1:5 and an empty
# destination list
env$put("src", serialize(1:5, NULL))
env$put("dest", serialize(integer(0), NULL))

# then try it out:
rpoplpush(env, "src", "dest") # 5
rpoplpush(env, "src", "dest") # 4
rpoplpush(env, "src", "dest") # 3

# Here is the state of the two lists
unserialize(env$get("src"))
unserialize(env$get("dest"))

# The above code will fail if one of the lists is available
env$del("dest")
try(rpoplpush(env, "src", "dest"))

# but because it's in a transaction, this failed attempt leaves src
# unchanged
unserialize(env$get("src"))
</code></pre>

<hr>
<h2 id='mdb_proxy'>Proxy values</h2><span id='topic+mdb_proxy'></span>

<h3>Description</h3>

<p>Proxy object.  These exist to try and exploit LMDB's copy-free
design.  LMDB can pass back a read-only pointer to memory without
copying it.  So rather than immediately trying to read the whole
thing in, this class provides a &quot;proxy&quot; to the data.  At the
moment they're not terribly useful - all you can do is get the
length, and peek at the first bytes!  They are used internally in
the package to support cursors.
</p>


<h3>Methods</h3>


<dl>
<dt><code>data</code></dt><dd>
<p>Return the value from a proxy object
</p>
<p><em>Usage:</em>
<code>data(as_raw = NULL)</code>
</p>
<p><em>Arguments:</em>
</p>

<ul>
<li><p><code>as_raw</code>:   Return the value as a raw vector?  This has the same semantics as <code>mdb_env$get</code> - if <code>NULL</code> then the value will be returned as a string as possible, otherwise as a raw vector.  If <code>TRUE</code> then the value is always returned as a raw vector, and if <code>FALSE</code> then the value is always returned as a string (or an error is thrown if that is not possible).

</p>
</li></ul>

<p><em>Value</em>:
A string or raw vector
</p>
</dd>
<dt><code>head</code></dt><dd>
<p>Read the first <code>n</code> bytes from a proxy
</p>
<p><em>Usage:</em>
<code>head(n = 6L, as_raw = NULL)</code>
</p>
<p><em>Arguments:</em>
</p>

<ul>
<li><p><code>n</code>:   The number of bytes to read.  If <code>n</code> is greater than the length of the object the whole object is returned (same behaviour as <code><a href="utils.html#topic+head">head</a></code>

</p>
</li>
<li><p><code>as_raw</code>:   As for <code>$data()</code>

</p>
</li></ul>

</dd>
<dt><code>is_raw</code></dt><dd>
<p>Return whether we know a value to be raw or not.  This is affected by whether we have successfully turned the value into a string (in which case we can return <code>FALSE</code>) or if any <code>NULL</code> bytes have been detected.  The latter condition may be satisfied by reading the first bit of the proxy with <code>$head()</code>
</p>
<p><em>Usage:</em>
<code>is_raw()</code>
</p>
<p><em>Value</em>:
A logical if we can, otherwise <code>NULL</code> (for symmetry with <code>as_raw</code>)
</p>
</dd>
<dt><code>is_valid</code></dt><dd>
<p>Test if a proxy object is still valid.  Once the proxy is invalid, it cannot be read from any more.  Proxies are invalidated if their parent transaction is closed, or if any write operations (e.g., <code>put</code>, <code>del</code>) have occurred.
</p>
<p><em>Usage:</em>
<code>is_valid()</code>
</p>
<p><em>Value</em>:
Scalar logical
</p>
</dd>
<dt><code>size</code></dt><dd>
<p>The size of the data - the number of characters in the string, or number of bytes in the raw vector.
</p>
<p><em>Usage:</em>
<code>size()</code>
</p>
<p><em>Value</em>:
Scalar integer
</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'># Start with a write transaction that has written a little data:
env &lt;- thor::mdb_env(tempfile())
txn &lt;- env$begin(write = TRUE)
txn$put("a", "apple")
txn$put("b", "banana")

# We can get a proxy object back by passing as_proxy = TRUE
p &lt;- txn$get("a", as_proxy = TRUE)
p

# Without copying anything we can get the length of the data
p$size() # == nchar("apple")

# And of course we can get the data
p$data()
p$data(as_raw = TRUE)

# Referencing an invalid proxy is an error, but you can use
# "is_valid()" check to see if it is valid
p$is_valid()

txn$put("c", "cabbage")
p$is_valid()
try(p$data())

# It is possible to read the first few bytes; this might be useful
# to determine if (say) a value is a serialised R object:
txn$put("d", serialize(mtcars, NULL))

# The first 6 bytes of a binary serialised rds object is always
#
#   0x58 0x0a 0x00 0x00 0x00 0x02
#
# for XDR serialisation, or
#
#   0x42 0x0a 0x02 0x00 0x00 0x00
#
# for native little-endian serialisation.
#
# So with a little helper function
is_rds &lt;- function(x) {
  h_xdr &lt;- as.raw(c(0x58, 0x0a, 0x00, 0x00, 0x00, 0x02))
  h_bin &lt;- as.raw(c(0x42, 0x0a, 0x02, 0x00, 0x00, 0x00))
  x6 &lt;- head(x, 6L)
  identical(x6, h_xdr) || identical(x6, h_bin)
}

# We can see that the value stored at 'a' is not rds
p1 &lt;- txn$get("a", as_proxy = TRUE)
is_rds(p1$head(6, as_raw = TRUE))

# But the value stored at 'd' is:
p2 &lt;- txn$get("d", as_proxy = TRUE)
is_rds(p2$head(6, as_raw = TRUE))

# Retrieve and unserialise the value:
head(unserialize(p2$data()))
</code></pre>

<hr>
<h2 id='mdb_txn'>Use mdb transactions</h2><span id='topic+mdb_txn'></span>

<h3>Description</h3>

<p>Transactions are required for every mdb operation.  Even when
using the convenience functions in <code><a href="#topic+mdb_env">mdb_env</a></code>
(<code>get</code>, etc), a transaction is created and committed each
time.  Within a transaction, either everything happens or nothing
happens, and everything gets a single consistent view of the
database.
</p>


<h3>Details</h3>

<p>There can be many read transactions per environment, but only one
write transactions.  Because R is single-threaded, that means that
you can only simultaneously write from an mdb environment from a
single object - any further attempts to open write transactions it
would block forever while waiting for a lock that can't be
released because there is only one thread!
</p>


<h3>Methods</h3>


<dl>
<dt><code>id</code></dt><dd>
<p>Return the mdb internal id of the transaction
</p>
<p><em>Usage:</em>
<code>id()</code>
</p>
<p><em>Value</em>:
An integer
</p>
<p><em>Note</em>: In lmdb.h this is <code>mdb_txn_id()</code>
</p>
</dd>
<dt><code>stat</code></dt><dd>
<p>Brief statistics about the database.  This is the same as <code><a href="#topic+mdb_env">mdb_env</a></code>'s <code>stat()</code> but applying to the transaction
</p>
<p><em>Usage:</em>
<code>stat()</code>
</p>
<p><em>Value</em>:
An integer vector with elements <code>psize</code> (the size of a database page), <code>depth</code> (depth of the B-tree), <code>brancb_pages</code> (number of internal non-leaf) pages), <code>leaf_pages</code> (number of leaf pages), <code>overflow_pages</code> (number of overflow pages) and <code>entries</code> (number of data items).
</p>
<p><em>Note</em>: In lmdb.h this is <code>mdb_stat()</code>
</p>
</dd>
<dt><code>commit</code></dt><dd>
<p>Commit all changes made in this transaction to the database, and invalidate the transaction, and any cursors belonging to it (i.e., once committed the transaction cannot be used again)
</p>
<p><em>Usage:</em>
<code>commit()</code>
</p>
<p><em>Value</em>:
Nothing, called for its side effects only
</p>
<p><em>Note</em>: In lmdb.h this is <code>mdb_txn_commit()</code>
</p>
</dd>
<dt><code>abort</code></dt><dd>
<p>Abandon all changes made in this transaction to the database, and invalidate the transaction, and any cursors belonging to it (i.e., once aborted the transaction cannot be used again).  For read-only transactions there is no practical difference between abort and commit, except that using <code>abort</code> allows the transaction to be recycled more efficiently.
</p>
<p><em>Usage:</em>
<code>abort(cache = TRUE)</code>
</p>
<p><em>Arguments:</em>
</p>

<ul>
<li><p><code>cache</code>:   Logical, indicating if a read-only transaction should be cached for recycling

</p>
</li></ul>

<p><em>Value</em>:
Nothing, called for its side effects only
</p>
<p><em>Note</em>: In lmdb.h this is <code>mdb_txn_abort()</code>
</p>
</dd>
<dt><code>cursor</code></dt><dd>
<p>Create a <code><a href="#topic+mdb_cursor">mdb_cursor</a></code> object in this transaction. This can be used for more powerful database interactions.
</p>
<p><em>Usage:</em>
<code>cursor()</code>
</p>
<p><em>Value</em>:
A <code><a href="#topic+mdb_cursor">mdb_cursor</a></code> object.
</p>
<p><em>Note</em>: In lmdb.h this is <code>mdb_cursor_open()</code>
</p>
</dd>
<dt><code>get</code></dt><dd>
<p>Retrieve a value from the database
</p>
<p><em>Usage:</em>
<code>get(key, missing_is_error = TRUE, as_proxy = FALSE, as_raw = NULL)</code>
</p>
<p><em>Arguments:</em>
</p>

<ul>
<li><p><code>key</code>:   A string (or raw vector) - the key to get

</p>
</li>
<li><p><code>missing_is_error</code>:   Logical, indicating if a missing value is an error (by default it is).  Alternatively, with <code>missing_is_error = FALSE</code>, a missing value will return <code>NULL</code>.  Because no value can be <code>NULL</code> (all values must have nonzero length) a <code>NULL</code> is unambiguously missing.

</p>
</li>
<li><p><code>as_proxy</code>:   Return a &quot;proxy&quot; object, which defers doing a copy into R.  See <code><a href="#topic+mdb_proxy">mdb_proxy</a></code> for more information.

</p>
</li>
<li><p><code>as_raw</code>:   Either <code>NULL</code>, or a logical, to indicate the result type required.  With <code>as_raw = NULL</code>, the default, the value will be returned as a string if possible.  If not possible it will return a raw vector.  With <code>as_raw = TRUE</code>, <code>get()</code> will <em>always</em> return a raw vector, even when it is possibly to represent the value as a string.  If <code>as_raw = FALSE</code>, <code>get</code> will return a string, but throw an error if this is not possible.  This is discussed in more detail in the thor vignette (<code>vignette("thor")</code>)

</p>
</li></ul>

<p><em>Note</em>: In lmdb.h this is <code>mdb_get()</code>
</p>
</dd>
<dt><code>put</code></dt><dd>
<p>Put values into the database.  In other systems, this might be called &quot;<code>set</code>&quot;.
</p>
<p><em>Usage:</em>
<code>put(key, value, overwrite = TRUE, append = FALSE)</code>
</p>
<p><em>Arguments:</em>
</p>

<ul>
<li><p><code>key</code>:   The name of the key (string or raw vector)

</p>
</li>
<li><p><code>value</code>:   The value to save (string or raw vector)

</p>
</li>
<li><p><code>overwrite</code>:   Logical - when <code>TRUE</code> it will overwrite existing data; when <code>FALSE</code> throw an error

</p>
</li>
<li><p><code>append</code>:   Logical - when <code>TRUE</code>, append the given key/value to the end of the database.  This option allows fast bulk loading when keys are already known to be in the correct order.  But if you load unsorted keys with <code>append = TRUE</code> an error will be thrown

</p>
</li></ul>

<p><em>Note</em>: In lmdb.h this is <code>mdb_put()</code>
</p>
</dd>
<dt><code>del</code></dt><dd>
<p>Remove a key/value pair from the database
</p>
<p><em>Usage:</em>
<code>del(key)</code>
</p>
<p><em>Arguments:</em>
</p>

<ul>
<li><p><code>key</code>:   The name of the key (string or raw vector)

</p>
</li></ul>

<p><em>Value</em>:
A scalar logical, indicating if the value was deleted
</p>
<p><em>Note</em>: In lmdb.h this is <code>mdb_del()</code>
</p>
</dd>
<dt><code>exists</code></dt><dd>
<p>Test if a key exists in the database.
</p>
<p><em>Usage:</em>
<code>exists(key)</code>
</p>
<p><em>Arguments:</em>
</p>

<ul>
<li><p><code>key</code>:   The name of the key to test (string or raw vector).  Unlike <code>get</code>, <code>put</code> and <code>del</code> (but like <code>mget</code>, <code>mput</code> and <code>mdel</code>), <code>exists</code> is <em>vectorised</em>.  So the input here can be; a character vector of any length (returning the same length logical vector), a raw vector (representing one key, returning a scalar logical) or a <code>list</code> with each element being either a scalar character or a raw vector, returning a logical the same length as the list.

</p>
</li></ul>

<p><em>Details:</em>
This is an extension of the raw LMDB API and works by using <code>mdb_get</code> for each key (which for lmdb need not copy data) and then testing whether the return value is <code>MDB_SUCCESS</code> or <code>MDB_NOTFOUND</code>.
</p>
<p><em>Value</em>:
A logical vector
</p>
</dd>
<dt><code>list</code></dt><dd>
<p>List keys in the database
</p>
<p><em>Usage:</em>
<code>list(starts_with = NULL, as_raw = FALSE, size = NULL)</code>
</p>
<p><em>Arguments:</em>
</p>

<ul>
<li><p><code>starts_with</code>:   Optionally, a prefix for all strings.  Note that is not a regular expression or a filename glob.  Using <code>foo</code> will match <code>foo</code>, <code>foo:bar</code> and <code>foobar</code> but not <code>fo</code> or <code>FOO</code>.  Because LMDB stores keys in a sorted tree, using a prefix can greatly reduce the number of keys that need to be tested.

</p>
</li>
<li><p><code>as_raw</code>:   Same interpretation as <code>as_raw</code> in <code>$get()</code> but with a different default.  It is expected that most of the time keys will be strings, so by default we'll try and return a character vector <code>as_raw = FALSE</code>.  Change the default if your database contains raw keys.

</p>
</li>
<li><p><code>size</code>:   For use with <code>starts_with</code>, optionally a guess at the number of keys that would be returned.  with <code>starts_with = NULL</code> we can look the number of keys up directly so this is ignored.

</p>
</li></ul>

</dd>
<dt><code>mget</code></dt><dd>
<p>Get values for multiple keys at once (like <code>$get</code> but vectorised over <code>key</code>)
</p>
<p><em>Usage:</em>
<code>mget(key, as_proxy = FALSE, as_raw = NULL)</code>
</p>
<p><em>Arguments:</em>
</p>

<ul>
<li><p><code>key</code>:   The keys to get values for.  Zero, one or more keys are allowed.

</p>
</li>
<li><p><code>as_proxy</code>:   Logical, indicating if a list of <code><a href="#topic+mdb_proxy">mdb_proxy</a></code> objects should be returned.

</p>
</li>
<li><p><code>as_raw</code>:   As for <code>$get()</code>, logical (or <code>NULL</code>) indicating if raw or string output is expected or desired.

</p>
</li></ul>

</dd>
<dt><code>mput</code></dt><dd>
<p>Put multiple values into the database (like <code>$put</code> but vectorised over <code>key</code>/<code>value</code>).
</p>
<p><em>Usage:</em>
<code>mput(key, value, overwrite = TRUE, append = FALSE)</code>
</p>
<p><em>Arguments:</em>
</p>

<ul>
<li><p><code>key</code>:   The keys to set

</p>
</li>
<li><p><code>value</code>:   The values to set against these keys.  Must be the same length as <code>key</code>.

</p>
</li>
<li><p><code>overwrite</code>:   As for <code>$put</code>

</p>
</li>
<li><p><code>append</code>:   As for <code>$put</code>

</p>
</li></ul>

<p><em>Details:</em>
The implementation simply calls <code>mdb_put</code> repeatedly (but with a single round of error checking) so duplicate <code>key</code> entries will result in the last key winning.
</p>
</dd>
<dt><code>mdel</code></dt><dd>
<p>Delete multiple values from the database (like <code>$del</code> but vectorised over <code>key</code>).
</p>
<p><em>Usage:</em>
<code>mdel(key)</code>
</p>
<p><em>Arguments:</em>
</p>

<ul>
<li><p><code>key</code>:   The keys to delete

</p>
</li></ul>

<p><em>Value</em>:
A logical vector, the same length as <code>key</code>, indicating if each key was deleted.
</p>
</dd>
<dt><code>replace</code></dt><dd>
<p>Use a temporary cursor to replace an item; this function will replace the data held at <code>key</code> and return the previous value (or <code>NULL</code> if it doesn't exist).  See <code><a href="#topic+mdb_cursor">mdb_cursor</a></code> for fuller documentation.
</p>
<p><em>Usage:</em>
<code>replace(key, value, as_raw = NULL)</code>
</p>
<p><em>Arguments:</em>
</p>

<ul>
<li><p><code>key</code>:   The key to replace

</p>
</li>
<li><p><code>value</code>:   The new value value to st <code>key</code> to

</p>
</li>
<li><p><code>as_raw</code>:   For the returned value, how should the data be returned?

</p>
</li></ul>

<p><em>Value</em>:
As for <code>$get()</code>, a single data item as either a string or raw vector.
</p>
</dd>
<dt><code>pop</code></dt><dd>
<p>Use a temporary cursor to &quot;pop&quot; an item; this function will delete an item but return the value that it had as it deletes it.
</p>
<p><em>Usage:</em>
<code>pop(key, as_raw = NULL)</code>
</p>
<p><em>Arguments:</em>
</p>

<ul>
<li><p><code>key</code>:   The key to pop

</p>
</li>
<li><p><code>as_raw</code>:   For the returned value, how should the data be returned?

</p>
</li></ul>

<p><em>Value</em>:
As for <code>$get()</code>, a single data item as either a string or raw vector.
</p>
</dd>
<dt><code>cmp</code></dt><dd>
<p>Compare two keys for ordering
</p>
<p><em>Usage:</em>
<code>cmp(a, b)</code>
</p>
<p><em>Arguments:</em>
</p>

<ul>
<li><p><code>a</code>:   A key (string or raw); it need not be in the database

</p>
</li>
<li><p><code>b</code>:   A key to compare with b (string or raw)

</p>
</li></ul>

<p><em>Value</em>:
A scalar integer, being -1 (if a &lt; b), 0 (if a == b) or 1 (if a &gt; b).
</p>
<p><em>Note</em>: In lmdb.h this is <code>mdb_cmp()</code>
</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'># Start by creating a new environment, and within that a write
# transaction
env &lt;- thor::mdb_env(tempfile())
txn &lt;- env$begin(write = TRUE)

# With this transaction we can write values and see them as set
txn$put("a", "hello")
txn$get("a")

# But because the transaction is not committed, any new
# transaction will not see the values:
env$get("a", missing_is_error = FALSE) # NULL
txn2 &lt;- env$begin()
txn2$get("a", missing_is_error = FALSE) # NULL

# Once we commit a transaction, *new* transactions will see the
# value
txn$commit()
env$get("a") # "hello"
env$begin()$get("a") # "hello"

# But old transactions retain their consistent view of the database
txn2$get("a", missing_is_error = FALSE)

# Cleanup
env$destroy()
</code></pre>

<hr>
<h2 id='storr_thor'>Thor driver for storr</h2><span id='topic+storr_thor'></span><span id='topic+driver_thor'></span>

<h3>Description</h3>

<p>Storr driver for thor.  This allows thor to be used as a storage
backend with the storr package and presents a higher level content
addressable key/value store suitable for storing R objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>storr_thor(
  env,
  prefix = "",
  hash_algorithm = NULL,
  default_namespace = "objects"
)

driver_thor(env, prefix = "", hash_algorithm = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="storr_thor_+3A_env">env</code></td>
<td>
<p>A thor environment</p>
</td></tr>
<tr><td><code id="storr_thor_+3A_prefix">prefix</code></td>
<td>
<p>An optional prefix.  If given, use a <code>:</code> as the
last character for nice looking keys (e.g., <code>storr:</code> will
generate keys like <code>storr:keys:namespace:name</code>.  If not
given then we assume that storr is the only user of this
database and if <code>destroy</code> is called it will delete the
entire database.</p>
</td></tr>
<tr><td><code id="storr_thor_+3A_hash_algorithm">hash_algorithm</code></td>
<td>
<p>Optional hash algorithm to use.  Defaults to
md5, or whatever the existing algorithm is if the database has
been opened.  You cannot mix algorithms.</p>
</td></tr>
<tr><td><code id="storr_thor_+3A_default_namespace">default_namespace</code></td>
<td>
<p>The default namespace to store objects
in.  Defaults to <code>objects</code>, as does other storr drivers.</p>
</td></tr>
</table>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
