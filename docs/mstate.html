<!DOCTYPE html><html lang="en"><head><title>Help for package mstate</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {mstate}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#mstate-package'><p>Data preparation, estimation and prediction in multi-state models</p></a></li>
<li><a href='#aidssi'><p>Data from the Amsterdam Cohort Studies on HIV infection and AIDS</p></a></li>
<li><a href='#bmt'><p>BMT data from Klein and Moeschberger</p></a></li>
<li><a href='#crprep.default'><p>Function to create weighted data set for competing risks analyses</p></a></li>
<li><a href='#Cuminc'><p>Calculate nonparametric cumulative incidence functions and associated</p>
standard errors</a></li>
<li><a href='#cutLMms'><p>Cut a multi-state data set at a landmark time point</p></a></li>
<li><a href='#EBMT+20cause+20of+20death+20data'><p>Data from the European Society for Blood and Marrow Transplantation (EBMT)</p></a></li>
<li><a href='#EBMT+20data'><p>Data from the European Society for Blood and Marrow Transplantation (EBMT)</p></a></li>
<li><a href='#EBMT+20platelet+20recovery+20data'><p>Data from the European Society for Blood and Marrow Transplantation (EBMT)</p></a></li>
<li><a href='#EBMT+20year+20of+20relapse+20data'><p>Data from the European Society for Blood and Marrow Transplantation (EBMT)</p></a></li>
<li><a href='#ELOS'><p>Expected length of stay</p></a></li>
<li><a href='#etm2msdata'><p>Converts between etm and msdata format</p></a></li>
<li><a href='#events'><p>Count number of observed transitions</p></a></li>
<li><a href='#expand.covs'><p>Expand covariates in competing risks dataset in stacked format</p></a></li>
<li><a href='#expand.covs.msdata'><p>Expand covariates in multi-state dataset in long format</p></a></li>
<li><a href='#haz_function'><p>Helper function that calculates excess and population hazards for a given transition</p></a></li>
<li><a href='#Liver+20cirrhosis+20data'><p>Abnormal prothrombin levels in liver cirrhosis</p></a></li>
<li><a href='#LMAJ'><p>Landmark Aalen-Johansen method</p></a></li>
<li><a href='#MarkovTest'><p>Log-rank based test for the validity of the Markov assumption</p></a></li>
<li><a href='#modify_transMat'><p>Upgrade the transMat object for the multi-state/relsurv setting.</p></a></li>
<li><a href='#msboot'><p>Bootstrap function in multi-state models</p></a></li>
<li><a href='#msboot.relsurv'><p>Bootstrap function for upgraded multi-state models using relsurv</p></a></li>
<li><a href='#msboot.relsurv.boot'><p>Default theta function used for msboot.relsurv</p></a></li>
<li><a href='#msdata2etm'><p>msdata to etm format</p></a></li>
<li><a href='#msfit'><p>Compute subject-specific transition hazards with (co-)variances</p></a></li>
<li><a href='#msfit.relsurv'><p>Extend a multi-state model using relative survival</p></a></li>
<li><a href='#msprep'><p>Function to prepare dataset for multi-state modeling in long format from</p>
dataset in wide format</a></li>
<li><a href='#mssample'><p>Sample paths through a multi-state model</p></a></li>
<li><a href='#paths'><p>Find all possible trajectories through a given multi-state model</p></a></li>
<li><a href='#plot.Cuminc'><p>Plot method for Cuminc objects</p></a></li>
<li><a href='#plot.MarkovTest'><p>Plot method for a MarkovTest object</p></a></li>
<li><a href='#plot.msfit'><p>Plot method for an msfit object</p></a></li>
<li><a href='#plot.probtrans'><p>Plot method for a probtrans object</p></a></li>
<li><a href='#print.MarkovTest'><p>Print method for a MarkovTest object</p></a></li>
<li><a href='#print.msdata'><p>Print method for a msdata object</p></a></li>
<li><a href='#print.summary.msfit'><p>Print method for summary.msfit object</p></a></li>
<li><a href='#print.summary.probtrans'><p>Print method for a summary.probtrans object</p></a></li>
<li><a href='#probtrans'><p>Compute subject-specific or overall transition probabilities with standard</p>
errors</a></li>
<li><a href='#redrank'><p>Reduced rank proportional hazards model for competing risks and multi-state</p>
models</a></li>
<li><a href='#summary.Cuminc'><p>Summary method for a summary.Cuminc object</p></a></li>
<li><a href='#summary.msfit'><p>Summary method for an msfit object</p></a></li>
<li><a href='#summary.probtrans'><p>Summary method for a probtrans object</p></a></li>
<li><a href='#trans2tra'><p>Convert transition matrix from mstate to etm format</p></a></li>
<li><a href='#transhelp'><p>Help functions for transition matrix</p></a></li>
<li><a href='#transMat'><p>Define transition matrix for multi-state model</p></a></li>
<li><a href='#varHaz.fixed'><p>Upgrade the varHaz object</p></a></li>
<li><a href='#vis.mirror.pt'><p>Mirror plot comparing two probtrans objects</p></a></li>
<li><a href='#vis.multiple.pt'><p>Visualise multiple probtrans objects</p></a></li>
<li><a href='#xsect'><p>Make a cross-section of multi-state data at a given time point</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Version:</td>
<td>0.3.3</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-07-03</td>
</tr>
<tr>
<td>Title:</td>
<td>Data Preparation, Estimation and Prediction in Multi-State
Models</td>
</tr>
<tr>
<td>Depends:</td>
<td>survival (&ge; 3.1)</td>
</tr>
<tr>
<td>Imports:</td>
<td>rlang, data.table, lattice, RColorBrewer, viridisLite</td>
</tr>
<tr>
<td>Suggests:</td>
<td>cmprsk, ggplot2, knitr, rmarkdown, relsurv (&ge; 2.2-5)</td>
</tr>
<tr>
<td>Description:</td>
<td>Contains functions for data preparation, descriptives, hazard estimation and prediction with Aalen-Johansen or simulation in competing risks and multi-state models, see Putter, Fiocco, Geskus (2007) &lt;<a href="https://doi.org/10.1002%2Fsim.2712">doi:10.1002/sim.2712</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/hputter/mstate">https://github.com/hputter/mstate</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-07-11 08:03:11 UTC; efbonneville</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/hputter/mstate/issues">https://github.com/hputter/mstate/issues</a></td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Author:</td>
<td>Hein Putter [aut, cre],
  Liesbeth C. de Wreede [aut],
  Marta Fiocco [aut],
  Ronald B. Geskus [ctb],
  Edouard F. Bonneville [aut],
  Damjan Manevski [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Hein Putter &lt;H.Putter@lumc.nl&gt;</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-07-11 21:30:06 UTC</td>
</tr>
</table>
<hr>
<h2 id='mstate-package'>Data preparation, estimation and prediction in multi-state models</h2><span id='topic+mstate-package'></span><span id='topic+mstate'></span>

<h3>Description</h3>

<p>Functions for data preparation, descriptives, (hazard) estimation and
prediction (Aalen-Johansen) in competing risks and multi-state models.
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;"> Package: </td><td style="text-align: left;"> mstate</td>
</tr>
<tr>
 <td style="text-align: left;"> Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;"> Version: </td><td style="text-align: left;">
0.2.10</td>
</tr>
<tr>
 <td style="text-align: left;"> Date: </td><td style="text-align: left;"> 2016-12-03</td>
</tr>
<tr>
 <td style="text-align: left;"> License: </td><td style="text-align: left;"> GPL 2.0</td>
</tr>
<tr>
 <td style="text-align: left;"> </td>
</tr>

</table>



<h3>Author(s)</h3>

<p>Liesbeth de Wreede, Marta Fiocco, Hein Putter. Maintainer: Hein
Putter &lt;H.Putter@lumc.nl&gt;
</p>


<h3>References</h3>

<p>Putter H, Fiocco M, Geskus RB (2007). Tutorial in biostatistics:
Competing risks and multi-state models. <em>Statistics in Medicine</em>
<b>26</b>, 2389&ndash;2430.
</p>
<p>de Wreede LC, Fiocco M, and Putter H (2010). The mstate package for
estimation and prediction in non- and semi-parametric multi-state and
competing risks models. <em>Computer Methods and Programs in Biomedicine</em>
<b>99</b>, 261&ndash;274.
</p>
<p>de Wreede LC, Fiocco M, and Putter H (2011). mstate: An R Package for the
Analysis of Competing Risks and Multi-State Models. <em>Journal of
Statistical Software</em>, Volume 38, Issue 7.
</p>

<hr>
<h2 id='aidssi'>Data from the Amsterdam Cohort Studies on HIV infection and AIDS</h2><span id='topic+aidssi'></span><span id='topic+aidssi2'></span>

<h3>Description</h3>

<p>These data sets give the times (in years) from HIV infection to AIDS, SI
switch and death in 329 men who have sex with men (MSM). Data are from the
period until combination anti-retroviral therapy became available (1996).
For more background information on the cohort, ccr5 and SI, see Geskus
<em>et al.</em> (2000, 2003)
</p>


<h3>Format</h3>

<p>aidssi </p>

<table>
<tr>
 <td style="text-align: left;"> patnr:</td><td style="text-align: left;"> Patient identification number</td>
</tr>
<tr>
 <td style="text-align: left;">
time:</td><td style="text-align: left;"> Time from HIV infection to first of SI appearance and AIDS, or
last follow-up</td>
</tr>
<tr>
 <td style="text-align: left;"> status:</td><td style="text-align: left;"> Event indicator; 0 = censored, 1 = AIDS, 2 =
SI appearance</td>
</tr>
<tr>
 <td style="text-align: left;"> cause:</td><td style="text-align: left;"> Failure cause; factor with levels "event-free",
"AIDS", "SI"</td>
</tr>
<tr>
 <td style="text-align: left;"> ccr5:</td><td style="text-align: left;"> CCR5 genotype; factor with levels "WW" (wild type
allele on both chromosomes),</td>
</tr>
<tr>
 <td style="text-align: left;"> </td><td style="text-align: left;"> "WM" (mutant allele on one
chromosome)</td>
</tr>
<tr>
 <td style="text-align: left;"> </td>
</tr>

</table>
<p> aidssi2 </p>

<table>
<tr>
 <td style="text-align: left;"> patnr:</td><td style="text-align: left;"> Patient identification
number</td>
</tr>
<tr>
 <td style="text-align: left;"> entry.time:</td><td style="text-align: left;"> Time from HIV infection to cohort entry. Value is
zero if HIV infection occurred while in follow-up.</td>
</tr>
<tr>
 <td style="text-align: left;"> aids.time:</td><td style="text-align: left;"> Time
from HIV infection to AIDS, or last follow-up if AIDS was not observed</td>
</tr>
<tr>
 <td style="text-align: left;">
aids.stat:</td><td style="text-align: left;"> Event indicator with respect to AIDS, with values 0
(censored) and 1 (AIDS)</td>
</tr>
<tr>
 <td style="text-align: left;"> si.time:</td><td style="text-align: left;"> Time from HIV infection to SI
switch, or last follow-up if SI switch was not observed</td>
</tr>
<tr>
 <td style="text-align: left;"> si.stat:</td><td style="text-align: left;">
Event indicator with respect to SI switch, with values 0 (no switch) and 1
(switch)</td>
</tr>
<tr>
 <td style="text-align: left;"> death.time:</td><td style="text-align: left;"> Time from HIV infection to death, or last
follow-up if death was not observed</td>
</tr>
<tr>
 <td style="text-align: left;"> death.stat:</td><td style="text-align: left;"> Event indicator with
respect to death; 0 = alive, 1 = dead</td>
</tr>
<tr>
 <td style="text-align: left;"> age.inf:</td><td style="text-align: left;"> Age at HIV
infection</td>
</tr>
<tr>
 <td style="text-align: left;"> ccr5:</td><td style="text-align: left;"> CCR5 genotype; factor with levels "WW" (wild type
allele on both chromosomes),</td>
</tr>
<tr>
 <td style="text-align: left;"> </td><td style="text-align: left;"> "WM" (mutant allele on one
chromosome)</td>
</tr>
<tr>
 <td style="text-align: left;"> </td>
</tr>

</table>



<h3>Details</h3>

<p><code>aidssi</code> contains follow-up data until the first of AIDS and SI switch.
It was used as example for the competing risks analyses in Putter, Fiocco,
Geskus (2007) and in Geskus (2016).
</p>
<p><code>aidssi2</code> extends the <code>aidssi</code> data set in three ways. First, it
considers events after the initial one. Second, it includes the entry times
of the individuals that entered the study after HIV infection. Third, age at
HIV infection has been added as extra covariable. Numbers differ slightly
from the <code>aidssi</code> data set. Some individuals were diagnosed with AIDS
only when they died and others had their last follow-up at AIDS diagnosis.
In order to prevent two transitions to happen at the same time, their time
to AIDS was shortened by 0.25 years. This data set was used as example for
the multi-state analyses in Geskus (2016).
</p>


<h3>Source</h3>

<p>Geskus RB (2000). On the inclusion of prevalent cases in HIV/AIDS
natural history studies through a marker-based estimate of time since
seroconversion.  <em>Statistics in Medicine</em> <b>19</b>, 1753&ndash;1769.
</p>
<p>Geskus RB, Miedema FA, Goudsmit J, Reiss P, Schuitemaker H, Coutinho RA
(2003).  Prediction of residual time to AIDS and death based on markers and
cofactors.  <em>Journal of AIDS</em> <b>32</b>, 514&ndash;521.
</p>


<h3>References</h3>

<p>Geskus, Ronald B. (2016). <em>Data Analysis with Competing
Risks and Intermediate States.</em> CRC Press, Boca Raton.
</p>
<p>Putter H, Fiocco M, Geskus RB (2007). Tutorial in biostatistics: Competing
risks and multi-state models. <em>Statistics in Medicine</em> <b>26</b>,
2389&ndash;2430.
</p>

<hr>
<h2 id='bmt'>BMT data from Klein and Moeschberger</h2><span id='topic+bmt'></span>

<h3>Description</h3>

<p>A data frame of 137 rows (patients) and 22 columns. The included variables
are </p>
 <dl>
<dt>group</dt><dd><p> Disease group; 1 = ALL, 2 = AML Low Risk, 3 =
AML High Risk </p>
</dd> <dt>t1</dt><dd><p> Time in days to death or last follow-up </p>
</dd>
<dt>t2</dt><dd><p> Disease-free survival time in days (time to relapse, death or
last follow-up) </p>
</dd> <dt>d1</dt><dd><p> Death indicator; 1 = dead, 0 = alive </p>
</dd>
<dt>d2</dt><dd><p> Relapse indicator; 1 = relapsed, 0 = disease-free </p>
</dd> <dt>d3</dt><dd>
<p>Disease-free survival indicator; 1 = dead or relapsed, 0 = alive and
disease-free) </p>
</dd> <dt>ta</dt><dd><p> Time in days to Acute Graft-versus-Host Disease
(AGVHD) </p>
</dd> <dt>da</dt><dd><p> Acute GVHD indicator; 1 = Acute GVHD, 0 = No Acute GVHD
</p>
</dd> <dt>tc</dt><dd><p> Time (days) to Chronic Graft-vrsus-Host Disease (CGVHD) </p>
</dd>
<dt>dc</dt><dd><p> Chronic GVHD indicator; 1 = Chronic GVHD, 0 = No Chronic GVHD </p>
</dd>
<dt>tp</dt><dd><p> Time (days) to platelet recovery </p>
</dd> <dt>dp</dt><dd><p> Platelet recovery
indicator; 1 = platelets returned to normal, 0 = platelets never returned to
normal </p>
</dd> <dt>z1</dt><dd><p> Patient age in years </p>
</dd> <dt>z2</dt><dd><p> Donor age in years </p>
</dd>
<dt>z3</dt><dd><p> Patient sex; 1 = male, 0 = female </p>
</dd> <dt>z4</dt><dd><p> Donor sex; 1 =
male, 0 = female </p>
</dd> <dt>z5</dt><dd><p> Patient CMV status; 1 = CMV positive, 0 = CMV
negative </p>
</dd> <dt>z6</dt><dd><p> Donor CMV status; 1 = CMV positive, 0 = CMV negative </p>
</dd>
<dt>z7</dt><dd><p> Waiting time to transplant in days </p>
</dd> <dt>z8</dt><dd><p> FAB; 1 = FAB
grade 4 or 5 and AML, 0 = Otherwise </p>
</dd> <dt>z9</dt><dd><p> Hospital; 1 = The Ohio
State University, 2 = Alferd , 3 = St. Vincent, 4 = Hahnemann </p>
</dd> <dt>z10</dt><dd>
<p>MTX used as a Graft-versus-Host prophylactic; 1 = yes, 0 = no </p>
</dd> </dl>



<h3>Format</h3>

<p>A data frame, see <code><a href="base.html#topic+data.frame">data.frame</a></code>.
</p>


<h3>References</h3>

<p>Klein and Moeschberger (1997). <em>Survival Analysis
Techniques for Censored and Truncated Data</em>, Springer, New York.
</p>

<hr>
<h2 id='crprep.default'>Function to create weighted data set for competing risks analyses</h2><span id='topic+crprep.default'></span><span id='topic+crprep'></span>

<h3>Description</h3>

<p>This function converts a dataset that is in short format (one subject per
line) into a counting process format with time-varying weights that correct
for right censored and left truncated data. With this data set, analyses
based on the subdistribution hazard can be performed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## Default S3 method:
crprep(
  Tstop,
  status,
  data,
  trans = 1,
  cens = 0,
  Tstart = 0,
  id,
  strata,
  keep,
  shorten = TRUE,
  rm.na = TRUE,
  origin = 0,
  prec.factor = 1000,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="crprep.default_+3A_tstop">Tstop</code></td>
<td>
<p>Either 1) a vector containing the time at which the follow-up
is ended, or 2) a character string indicating the column name in <code>data</code>
that contains the end times (see Details).</p>
</td></tr>
<tr><td><code id="crprep.default_+3A_status">status</code></td>
<td>
<p>Either 1) a vector describing status at end of follow-up,
having the same length as <code>Tstop</code>, or 2) a character string indicating
the column name that contains this information.</p>
</td></tr>
<tr><td><code id="crprep.default_+3A_data">data</code></td>
<td>
<p>Data frame in which to interpret <code>Tstart</code>, <code>status</code>,
<code>Tstart</code>, <code>id</code>, <code>strata</code> and <code>keep</code>, if given as
character value (specification 2, &quot;by name&quot;).</p>
</td></tr>
<tr><td><code id="crprep.default_+3A_trans">trans</code></td>
<td>
<p>Values of <code>status</code> for which weights are to be calculated.</p>
</td></tr>
<tr><td><code id="crprep.default_+3A_cens">cens</code></td>
<td>
<p>Value that denotes censoring in <code>status</code> column.</p>
</td></tr>
<tr><td><code id="crprep.default_+3A_tstart">Tstart</code></td>
<td>
<p>Either 1) a vector containing the time at which the follow-up
is started, having the same length as <code>Tstop</code>, or 2) a character string
indicating the column name that contains the entry times, or 3) one numeric
value in case it is the same for every subject. Default is 0.</p>
</td></tr>
<tr><td><code id="crprep.default_+3A_id">id</code></td>
<td>
<p>Either 1) a vector, having the same length as <code>Tstop</code>,
containing the subject identifiers, or 2) a character string indicating the
column name containing these subject identifiers. If not provided, a column
<code>id</code> is created with subjects having values 1,...,n.</p>
</td></tr>
<tr><td><code id="crprep.default_+3A_strata">strata</code></td>
<td>
<p>Either 1) a vector of the same length as <code>Tstop</code>, or 2) a
character string indicating the column name that contains this information.
Weights are calculated for per value in this vector.</p>
</td></tr>
<tr><td><code id="crprep.default_+3A_keep">keep</code></td>
<td>
<p>Either 1) a data frame or matrix or a numeric or factor vector
containing covariate(s) that need to be retained in the output dataset.
Number of rows/length should correspond with <code>Tstop</code>, or 2) a character
vector containing the column names of these covariates in <code>data</code>.</p>
</td></tr>
<tr><td><code id="crprep.default_+3A_shorten">shorten</code></td>
<td>
<p>Logical. If true, number of rows in output is reduced by
collapsing rows within a subject in which weights do not change.</p>
</td></tr>
<tr><td><code id="crprep.default_+3A_rm.na">rm.na</code></td>
<td>
<p>Logical. If true, rows for which <code>status</code> is missing are
deleted.</p>
</td></tr>
<tr><td><code id="crprep.default_+3A_origin">origin</code></td>
<td>
<p>Substract origin time units from all Tstop and Tstart times.</p>
</td></tr>
<tr><td><code id="crprep.default_+3A_prec.factor">prec.factor</code></td>
<td>
<p>Factor by which to multiply the machine's precision.
Censoring and truncation times are shifted by prec.factor*precision if event
times and censoring/truncation times are equal.</p>
</td></tr>
<tr><td><code id="crprep.default_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed to or from other methods. They
are ignored in this function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For each event type as specified via <code>trans</code>, individuals with a
competing event remain in the risk set with weights that are determined by
the product-limit forms of the time-to-censoring and time-to-entry
estimates. Typically, their weights change over follow-up, and therefore
such individuals are split into several rows. Censoring weights are always
computed. Truncation weights are computed only if <code>Tstart</code> is
specified.
</p>
<p>If several event types are specified at once, regression analyses using the
stacked format data set can be performed (see Putter et al. 2007 and Chapter
4 in Geskus 2016). The data set can also be used for a regression on the
cause-specific hazard by restricting to the subset <code>subset=count==0</code>.
</p>
<p>Missing values are allowed in <code>Tstop</code>, <code>status</code>, <code>Tstart</code>,
<code>strata</code> and <code>keep</code>. Rows for which <code>Tstart</code> or <code>Tstart</code>
is missing are deleted.
</p>
<p>There are two ways to supply the data. If given &quot;by value&quot; (option 1), the
actual data vectors are used. If given &quot;by name&quot; (option 2), the column
names are specified, which are read from the data set in <code>data</code>. In
general, the second option is preferred.
</p>
<p>If data are given by value, the following holds for the naming of the
columns in the output data set. If <code>keep</code>, <code>strata</code> or <code>id</code>
is a vector from a (sub)-list, e.g. obj$name2$name1, then the column name is
based on the most inner part (i.e.\ &quot;name1&quot;). If it is a vector of the form
obj[,&quot;name1&quot;], then the column is named &quot;name1&quot;. For all other vector
specifications, the name is copied as is. If <code>keep</code> is a data.frame or
a named matrix, the same names are used for the covariate columns in the
output data set. If keep is a matrix without names, then the covariate
columns are given the names &quot;V1&quot; until &quot;Vk&quot;.
</p>
<p>The current function does not allow to create a weighted data set in which
the censoring and/or truncation mechanisms depend on covariates via a
regression model.
</p>


<h3>Value</h3>

<p>A data frame in long (counting process) format containing the
covariates (replicated per subject). The following column names are used:
</p>
<table role = "presentation">
<tr><td><code>Tstart</code></td>
<td>
<p>start dates of dataset</p>
</td></tr> <tr><td><code>Tstop</code></td>
<td>
<p>stop dates of dataset</p>
</td></tr>
<tr><td><code>status</code></td>
<td>
<p>status of the subject at the end of that row</p>
</td></tr>
<tr><td><code>weight.cens</code></td>
<td>
<p>weights due to censoring mechanism</p>
</td></tr>
<tr><td><code>weight.trunc</code></td>
<td>
<p>weights due to truncation mechanism (if present)</p>
</td></tr>
<tr><td><code>count</code></td>
<td>
<p>row number within subject and event type under consideration</p>
</td></tr>
<tr><td><code>failcode</code></td>
<td>
<p>event type under consideration</p>
</td></tr>
</table>
<p>The first column is the subject identifier. If the argument &quot;id&quot; is missing,
it has values 1:n and is named &quot;id&quot;. Otherwise the information is taken from
the <code>id</code> argument.
</p>
<p>Variables as specified in <code>strata</code> and/or <code>keep</code> are included as
well (see Details).
</p>


<h3>Author(s)</h3>

<p>Ronald Geskus
</p>


<h3>References</h3>

<p>Geskus RB (2011). Cause-Specific Cumulative Incidence Estimation
and the Fine and Gray Model Under Both Left Truncation and Right Censoring.
<em>Biometrics</em> <b>67</b>, 39&ndash;49.
</p>
<p>Geskus, Ronald B. (2016). <em>Data Analysis with Competing Risks and
Intermediate States.</em> CRC Press, Boca Raton.
</p>
<p>Putter H, Fiocco M, Geskus RB (2007). Tutorial in biostatistics: Competing
risks and multi-state models. <em>Statistics in Medicine</em> <b>26</b>,
2389&ndash;2430.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(aidssi)
aidssi.w &lt;- crprep("time", "cause", data=aidssi, trans=c("AIDS","SI"),
                   cens="event-free", id="patnr", keep="ccr5")

# calculate cause-specific cumulative incidence, no truncation,
# compare with Cuminc (also from mstate)
ci &lt;- Cuminc(aidssi$time, aidssi$status)
sf &lt;- survfit(Surv(Tstart,Tstop,status=="AIDS")~1, data=aidssi.w,
              weight=weight.cens, subset=failcode=="AIDS")
plot(sf, fun="event", mark.time=FALSE)
lines(CI.1~time,data=ci,type="s",col="red")
sf &lt;- survfit(Surv(Tstart,Tstop,status=="SI")~1, data=aidssi.w,
              weight=weight.cens, subset=failcode=="SI")
plot(sf, fun="event", mark.time=FALSE)
lines(CI.2~time,data=ci,type="s",col="red")

# Fine and Gray regression for cause 1
cw &lt;- coxph(Surv(Tstart,Tstop,status=="AIDS")~ccr5, data=aidssi.w,
      weight=weight.cens, subset=failcode=="AIDS")
cw
# This can be checked with the results of crr (cmprsk)
# crr(ftime=aidssi$time, fstatus=aidssi$status, cov1=as.numeric(aidssi$ccr5))

# Gray's log-rank test
aidssi.wCCR &lt;- crprep("time", "cause", data=aidssi, trans=c("AIDS","SI"),
                      cens="event-free", id="patnr", strata="ccr5")
test.AIDS &lt;- coxph(Surv(Tstart,Tstop,status=="AIDS")~ccr5, data=aidssi.wCCR,
                   weights=weight.cens, subset=failcode=="AIDS")
test.SI &lt;- coxph(Surv(Tstart,Tstop,status=="SI")~ccr5, data=aidssi.wCCR,
                 weights=weight.cens, subset=failcode=="SI")
## score test statistic and p-value
c(test.AIDS$score, 1-pchisq(test.AIDS$score,1)) # AIDS
c(test.SI$score, 1-pchisq(test.SI$score,1))     # SI
# This can be compared with the results of cuminc (cmprsk)
# with(aidssi, cuminc(time, status, group=ccr5)$Tests)
# Note: results are not exactly the same

</code></pre>

<hr>
<h2 id='Cuminc'>Calculate nonparametric cumulative incidence functions and associated
standard errors</h2><span id='topic+Cuminc'></span><span id='topic+print.Cuminc'></span>

<h3>Description</h3>

<p>This function computes nonparametric cumulative incidence functions and
associated standard errors for each value of a group variable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Cuminc(time, status, data, group, na.status = c("remove", "extra"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Cuminc_+3A_time">time</code></td>
<td>
<p>Either 1) a numeric vector containing the failure times or 2) a
string containing the column name indicating these failure times</p>
</td></tr>
<tr><td><code id="Cuminc_+3A_status">status</code></td>
<td>
<p>Either 1) a numeric, factor or character vector containing the
failure codes or 2) a string containing the column name indicating these
failure codes</p>
</td></tr>
<tr><td><code id="Cuminc_+3A_data">data</code></td>
<td>
<p>When appropriate, a data frame containing <code>time</code>,
<code>status</code> and/or <code>group</code> variables</p>
</td></tr>
<tr><td><code id="Cuminc_+3A_group">group</code></td>
<td>
<p>Optionally, name of column in data indicating a grouping
variable; cumulative incidence functions are calculated for each value or
level of <code>group</code>. If missing no groups are considered</p>
</td></tr>
<tr><td><code id="Cuminc_+3A_na.status">na.status</code></td>
<td>
<p>One of <code>"remove"</code> (default) or <code>"extra"</code>,
indicating whether subjects with missing cause of failure should be removed
or whether missing cause of failure should be treated as a separate cause of
failure</p>
</td></tr>
<tr><td><code id="Cuminc_+3A_...">...</code></td>
<td>
<p>Allows extra arguments for future extensions, but for now just
used for backwards compatibility (e.g. allowing use of defunct <code>failcodes</code>
argument in reverse dependencies).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The estimated cumulative incidences are as described in Putter, Fiocco &amp;
Geskus (2007); the standard errors are the square roots of the Greenwood
variance estimators, see eg. Andersen, Borgan, Gill &amp; Keiding (1993), de
Wreede, Fiocco &amp; Putter (2009), and they correspond to the variances in eg.
Marubini &amp; Valsecchi (1995). In case of no censoring, the estimated
cumulative incidences and variances reduce to simple binomial frequencies
and their variances.
</p>


<h3>Value</h3>

<p>An object of class <code>"Cuminc"</code>, which is a data frame containing
the estimated failure-free probabilities and cumulative incidences and their
standard errors. The names of the dataframe are <code>time</code>, <code>Surv</code>,
<code>seSurv</code>, and <code>cuminc</code> and <code>secuminc</code> followed by the values
or levels of the <code>failcodes</code>. If <code>group</code> was specified, a
<code>group</code> variable is included with the same name and values/levels as
the original grouping variable, and with estimated cumulative incidences
(SE) for each value/level of <code>group</code>.
</p>
<p>Cuminc is now simply a wrapper around survfit of the survival package with
type=<code>"mstate"</code>, only maintained for backward compatibility. The
survfit object is kept as attribute (<code>attr("survfit")</code>), and the print,
plot and summary functions are simply print, plot and summary applied to the
survfit object. Subsetting the <code>"Cuminc"</code> object results in subsetting
the data frame, not in subsetting the survfit object.
</p>


<h3>Author(s)</h3>

<p>Hein Putter <a href="mailto:H.Putter@lumc.nl">H.Putter@lumc.nl</a>
</p>


<h3>References</h3>

<p>Andersen PK, Borgan O, Gill RD, Keiding N (1993).
<em>Statistical Models Based on Counting Processes</em>. Springer, New York.
</p>
<p>Marubini E, Valsecchi MG (1995). <em>Analysing Survival Data from Clinical
Trials and Observational Studies</em>. Wiley, New York.
</p>
<p>Putter H, Fiocco M, Geskus RB (2007). Tutorial in biostatistics: Competing
risks and multi-state models. <em>Statistics in Medicine</em> <b>26</b>,
2389&ndash;2430.
</p>
<p>de Wreede L, Fiocco M, Putter H (2009). The mstate package for estimation
and prediction in non- and semi-parametric multi-state models. Submitted.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
### These data were used in Putter, Fiocco &amp; Geskus (2007)
data(aidssi)
ci &lt;- Cuminc(time=aidssi$time, status=aidssi$status)
head(ci); tail(ci)
ci &lt;- Cuminc(time="time", status="status", data=aidssi, group="ccr5")
head(ci); tail(ci)

### Some fake data
fake &lt;- data.frame(surv=c(seq(2,10,by=2),seq(1,13,by=3),seq(1,9,by=2),seq(1,13,by=3)),
                    stat=rep(0:3,5),Tstage=c(1:4,rep(1:4,rep(4,4))))
fake$stat[fake$stat==0 &amp; fake$Tstage==2] &lt;- 3
fake$stat[fake$stat==3 &amp; fake$Tstage==1] &lt;- 2
fake
Cuminc(time="surv", status="stat", data=fake)
# If we remove all entries with status=0,
# we should get binomial sample probabilities and corresponding SEs
fake0 &lt;- fake[fake$stat!=0,]
Cuminc(time="surv", status="stat", data=fake0)

</code></pre>

<hr>
<h2 id='cutLMms'>Cut a multi-state data set at a landmark time point</h2><span id='topic+cutLMms'></span>

<h3>Description</h3>

<p>Given a dataset in long format, for instance generated by
<code><a href="#topic+msprep">msprep</a></code>, this function cuts a multi-state data frame (object of
type &quot;msdata&quot;) at a landmark time point LM. Administrative censoring can be
applied at time <code>cens</code>, equal for all individuals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cutLMms(msdata, LM, cens)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cutLMms_+3A_msdata">msdata</code></td>
<td>
<p>An object of class <code>"msdata"</code>, such as output by
<code><a href="#topic+msprep">msprep</a></code></p>
</td></tr>
<tr><td><code id="cutLMms_+3A_lm">LM</code></td>
<td>
<p>The landmark time point at which the cut is to be made</p>
</td></tr>
<tr><td><code id="cutLMms_+3A_cens">cens</code></td>
<td>
<p>The time point at which administrative censoring is to be
applied; if missing, no administrative censoring will be applied</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function has a similar purpose as the <code>cutLM</code> function in the
<code>dynpred</code> package. Only follow-up after a landmark time point LM is
considered, so all subjects who are no longer at risk are removed. Column
<code>time</code> is updated based on the new Tstart and Tstop.
</p>


<h3>Value</h3>

<p>An object of class <code>"msdata"</code> again, containing only follow-up
data after LM. The data frame contains an extra column <code>Tentry</code> with
the time of entry into the present state.
</p>


<h3>Author(s)</h3>

<p>Hein Putter <a href="mailto:H.Putter@lumc.nl">H.Putter@lumc.nl</a>
</p>


<h3>References</h3>

<p>L. C. de Wreede, M. Fiocco, and H. Putter (2011). mstate: An R
Package for the Analysis of Competing Risks and Multi-State Models. Journal
of Statistical Software 38: 7.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
tmat &lt;- trans.illdeath(names=c("Tx","PR","RelDeath"))
data(ebmt3) # data from Section 4 of Putter, Fiocco &amp; Geskus (2007)
msebmt &lt;- msprep(time=c(NA,"prtime","rfstime"),status=c(NA,"prstat","rfsstat"),
		data=ebmt3,trans=tmat)
# Cut at 5 years
cutLMms(msebmt, LM=1826)
events(cutLMms(msebmt, LM=1826))

</code></pre>

<hr>
<h2 id='EBMT+20cause+20of+20death+20data'>Data from the European Society for Blood and Marrow Transplantation (EBMT)</h2><span id='topic+EBMT+20cause+20of+20death+20data'></span><span id='topic+ebmt2'></span>

<h3>Description</h3>

<p>A data frame of 8966 patients transplanted at the EBMT. The included
variables are </p>
 <dl>
<dt>id</dt><dd><p>Patient identification number</p>
</dd>
<dt>time</dt><dd><p>Time in months from transplantation to death or last follow-up</p>
</dd>
<dt>status</dt><dd><p>Survival status; 0 = censored; 1,...,6 = death due to the
following causes: Relapse (1), GvHD (2), Bacterial infections (3), Viral
infections (4), Fungal infections (5), Other causes (6)</p>
</dd> <dt>cod</dt><dd><p>Cause of
death as factor with levels &quot;Alive&quot;, &quot;Relapse&quot;, &quot;GvHD&quot;, &quot;Bacterial&quot;,
&quot;Viral&quot;, &quot;Fungal&quot;, &quot;Other&quot;</p>
</dd> <dt>dissub</dt><dd><p>Disease subclassification; factor
with levels &quot;AML&quot;, &quot;ALL&quot;, &quot;CML&quot;</p>
</dd> <dt>match</dt><dd><p>Donor-recipient gender match;
factor with levels &quot;No gender mismatch&quot;, &quot;Gender mismatch&quot;</p>
</dd>
<dt>tcd</dt><dd><p>T-cell depletion; factor with levels &quot;No TCD&quot;, &quot;TCD&quot;, &quot;Unknown&quot;</p>
</dd>
<dt>year</dt><dd><p>Year of transplantation; factor with levels &quot;1985-1989&quot;,
&quot;1990-1994&quot;, &quot;1995-1998&quot;</p>
</dd> <dt>age</dt><dd><p>Patient age at transplant; factor with
levels &quot;&lt;=20&quot;, &quot;20-40&quot;, &quot;&gt;40&quot;</p>
</dd> </dl>



<h3>Format</h3>

<p>A data frame, see <code><a href="base.html#topic+data.frame">data.frame</a></code>.
</p>


<h3>Source</h3>

<p>We acknowledge the European Society for Blood and Marrow
Transplantation (EBMT) for making available these data. Disclaimer: these
data were simplified for the purpose of illustration of the analysis of
competing risks and multi-state models and do not reflect any real life
situation. No clinical conclusions should be drawn from these data.
</p>


<h3>References</h3>

<p>Fiocco M, Putter H, van Houwelingen JC (2005). Reduced rank
proportional hazards model for competing risks. <em>Biostatistics</em>
<b>6</b>, 465&ndash;478.
</p>

<hr>
<h2 id='EBMT+20data'>Data from the European Society for Blood and Marrow Transplantation (EBMT)</h2><span id='topic+EBMT+20data'></span><span id='topic+ebmt4'></span>

<h3>Description</h3>

<p>A data frame of 2279 patients transplanted at the EBMT between 1985 and
1998. These data were used in Fiocco, Putter &amp; van Houwelingen (2008), van
Houwelingen &amp; Putter (2008, 2012) and de Wreede, Fiocco &amp; Putter (2011). The
included variables are </p>
 <dl>
<dt>id</dt><dd><p>Patient identification number</p>
</dd>
<dt>rec</dt><dd><p>Time in days from transplantation to recovery or last follow-up</p>
</dd>
<dt>rec.s</dt><dd><p>Recovery status; 1 = recovery, 0 = censored</p>
</dd> <dt>ae</dt><dd><p>Time in
days from transplantation to adverse event (AE) or last follow-up</p>
</dd>
<dt>ae.s</dt><dd><p>Adverse event status; 1 = adverse event, 0 = censored</p>
</dd>
<dt>recae</dt><dd><p>Time in days from transplantation to both recovery and AE or
last follow-up</p>
</dd> <dt>recae.s</dt><dd><p>Recovery and AE status; 1 = both recovery and
AE, 0 = no recovery or no AE or censored</p>
</dd> <dt>rel</dt><dd><p>Time in days from
transplantation to relapse or last follow-up</p>
</dd> <dt>rel.s</dt><dd><p>Relapse status; 1
= relapse, 0 = censored</p>
</dd> <dt>srv</dt><dd><p>Time in days from transplantation to
death or last follow-up</p>
</dd> <dt>srv.s</dt><dd><p>Relapse status; 1 = dead, 0 =
censored</p>
</dd> <dt>year</dt><dd><p>Year of transplantation; factor with levels
&quot;1985-1989&quot;, &quot;1990-1994&quot;, &quot;1995-1998&quot;</p>
</dd> <dt>agecl</dt><dd><p>Patient age at
transplant; factor with levels &quot;&lt;=20&quot;, &quot;20-40&quot;, &quot;&gt;40&quot;</p>
</dd>
<dt>proph</dt><dd><p>Prophylaxis; factor with levels &quot;no&quot;, &quot;yes&quot;</p>
</dd>
<dt>match</dt><dd><p>Donor-recipient gender match; factor with levels &quot;no gender
mismatch&quot;, &quot;gender mismatch&quot;</p>
</dd> </dl>



<h3>Format</h3>

<p>A data frame, see <code><a href="base.html#topic+data.frame">data.frame</a></code>.
</p>


<h3>Source</h3>

<p>We acknowledge the European Society for Blood and Marrow
Transplantation (EBMT) for making available these data. Disclaimer: these
data were simplified for the purpose of illustration of the analysis of
competing risks and multi-state models and do not reflect any real life
situation. No clinical conclusions should be drawn from these data.
</p>


<h3>References</h3>

<p>Fiocco M, Putter H, van Houwelingen HC (2008). Reduced-rank
proportional hazards regression and simulation-based prediction for
multi-state models. <em>Statistics in Medicine</em> <b>27</b>, 4340&ndash;4358.
</p>
<p>van Houwelingen HC, Putter H (2008). Dynamic predicting by landmarking as an
alternative for multi-state modeling: an application to acute lymphoid
leukemia data. <em>Lifetime Data Anal</em> <b>14</b>, 447&ndash;463.
</p>
<p>van Houwelingen HC, Putter H (2012). Dynamic Prediction in Clinical Survival
Analaysis. Chapman &amp; Hall/CRC Press, Boca Raton.
</p>
<p>de Wreede LC, Fiocco M, and Putter H (2011). mstate: An R Package for the
Analysis of Competing Risks and Multi-State Models. <em>Journal of
Statistical Software</em>, Volume 38, Issue 7.
</p>

<hr>
<h2 id='EBMT+20platelet+20recovery+20data'>Data from the European Society for Blood and Marrow Transplantation (EBMT)</h2><span id='topic+EBMT+20platelet+20recovery+20data'></span><span id='topic+ebmt3'></span>

<h3>Description</h3>

<p>A data frame of 2204 patients transplanted at the EBMT between 1995 and
1998. These data were used in Section 4 of the tutorial on competing risks
and multi-state models (Putter, Fiocco &amp; Geskus, 2007). The included
variables are </p>
 <dl>
<dt>id</dt><dd><p>Patient identification number</p>
</dd>
<dt>prtime</dt><dd><p>Time in days from transplantation to platelet recovery or last
follow-up</p>
</dd> <dt>prstat</dt><dd><p>Platelet recovery status; 1 = platelet recovery, 0
= censored</p>
</dd> <dt>rfstime</dt><dd><p>Time in days from transplantation to relapse or
death or last follow-up (relapse-free survival time)</p>
</dd>
<dt>rfsstat</dt><dd><p>Relapse-free survival status; 1 = relapsed or dead, 0 =
censored</p>
</dd> <dt>dissub</dt><dd><p>Disease subclassification; factor with levels &quot;AML&quot;,
&quot;ALL&quot;, &quot;CML&quot;</p>
</dd> <dt>age</dt><dd><p>Patient age at transplant; factor with levels
&quot;&lt;=20&quot;, &quot;20-40&quot;, &quot;&gt;40&quot;</p>
</dd> <dt>drmatch</dt><dd><p>Donor-recipient gender match; factor
with levels &quot;No gender mismatch&quot;, &quot;Gender mismatch&quot;</p>
</dd> <dt>tcd</dt><dd><p>T-cell
depletion; factor with levels &quot;No TCD&quot;, &quot;TCD&quot;</p>
</dd> </dl>



<h3>Format</h3>

<p>A data frame, see <code><a href="base.html#topic+data.frame">data.frame</a></code>.
</p>


<h3>Source</h3>

<p>We acknowledge the European Society for Blood and Marrow
Transplantation (EBMT) for making available these data. Disclaimer: these
data were simplified for the purpose of illustration of the analysis of
competing risks and multi-state models and do not reflect any real life
situation. No clinical conclusions should be drawn from these data.
</p>


<h3>References</h3>

<p>Putter H, Fiocco M, Geskus RB (2007). Tutorial in biostatistics:
Competing risks and multi-state models. <em>Statistics in Medicine</em>
<b>26</b>, 2389&ndash;2430.
</p>

<hr>
<h2 id='EBMT+20year+20of+20relapse+20data'>Data from the European Society for Blood and Marrow Transplantation (EBMT)</h2><span id='topic+EBMT+20year+20of+20relapse+20data'></span><span id='topic+ebmt1'></span>

<h3>Description</h3>

<p>A data frame of 1977 patients transplanted for CML. The included variables
are </p>
 <dl>
<dt>patid</dt><dd><p>Patient identification number</p>
</dd> <dt>srv</dt><dd><p>Time
in days from transplantation to death or last follow-up</p>
</dd>
<dt>srvstat</dt><dd><p>Survival status; 1 = death; 0 = censored</p>
</dd> <dt>rel</dt><dd><p>Time in
days from transplantation to relapse or last follow-up</p>
</dd>
<dt>relstat</dt><dd><p>Relapse status; 1 = relapsed; 0 = censored</p>
</dd>
<dt>yrel</dt><dd><p>Calendar year of relapse; factor with levels &quot;1993-1996&quot;,&quot;
1997-1999&quot;, &quot;2000-&quot;</p>
</dd> <dt>age</dt><dd><p>Patient age at transplant (years)</p>
</dd>
<dt>score</dt><dd><p>Gratwohl score; factor with levels &quot;Low risk&quot;, &quot;Medium risk&quot;,
&quot;High risk&quot;</p>
</dd> </dl>



<h3>Format</h3>

<p>A data frame, see <code><a href="base.html#topic+data.frame">data.frame</a></code>.
</p>


<h3>Source</h3>

<p>We acknowledge the European Society for Blood and Marrow
Transplantation (EBMT) for making available these data. Disclaimer: these
data were simplified for the purpose of illustration of the analysis of
competing risks and multi-state models and do not reflect any real life
situation. No clinical conclusions should be drawn from these data.
</p>

<hr>
<h2 id='ELOS'>Expected length of stay</h2><span id='topic+ELOS'></span>

<h3>Description</h3>

<p>Given a <code>"probtrans"</code> object, ELOS calculates the (restricted) expected
length of stay in each of the states of the multi-state model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ELOS(pt, tau)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ELOS_+3A_pt">pt</code></td>
<td>
<p>An object of class <code>"probtrans"</code></p>
</td></tr>
<tr><td><code id="ELOS_+3A_tau">tau</code></td>
<td>
<p>The horizon until which ELOS is calculated; if missing, the
maximum of the observed transition times is taken</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The object <code>pt</code> needs to be a <code>"probtrans"</code> object, obtained with
forward prediction (the default, <code>direction</code>=<code>"forward"</code>, in the
call to <code><a href="#topic+probtrans">probtrans</a></code>). The restriction to <code>tau</code> is there
because, as in ordinary survival analysis, the probability of being in a
state can be positive until infinity, resulting in infinite values. The
(restricted, until tau) expected length of stay in state h, given in state g
at time s, is given by the integral from s to tau of P_gh(s,t), see for
instance Beyersmann and Putter (2014).
</p>


<h3>Value</h3>

<p>A K x K matrix (with K number of states), with the (g,h)'th element
containing E_gh(s,tau). The starting time point s is inferred from <code>pt</code>
(the smallest time point, should be equal to the <code>predt</code> value in the
call to <code><a href="#topic+probtrans">probtrans</a></code>. The row- and column names of the matrix
have been named &quot;from1&quot; until &quot;fromK&quot; and &quot;in1&quot; until &quot;inK&quot;, respectively.
</p>


<h3>Author(s)</h3>

<p>Hein Putter <a href="mailto:H.Putter@lumc.nl">H.Putter@lumc.nl</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# transition matrix for illness-death model
tmat &lt;- trans.illdeath()
# data in wide format, for transition 1 this is dataset E1 of
# Therneau &amp; Grambsch (2000)
tg &lt;- data.frame(illt=c(1,1,6,6,8,9),ills=c(1,0,1,1,0,1),
        dt=c(5,1,9,7,8,12),ds=c(1,1,1,1,1,1),
        x1=c(1,1,1,0,0,0),x2=c(6:1))
# data in long format using msprep
tglong &lt;- msprep(time=c(NA,"illt","dt"),status=c(NA,"ills","ds"),
		data=tg,keep=c("x1","x2"),trans=tmat)
# events
events(tglong)
table(tglong$status,tglong$to,tglong$from)
# expanded covariates
tglong &lt;- expand.covs(tglong,c("x1","x2"))
# Cox model with different covariate
cx &lt;- coxph(Surv(Tstart,Tstop,status)~x1.1+x2.2+strata(trans),
        data=tglong,method="breslow")
summary(cx)
# new data, to check whether results are the same for transition 1 as
# those in appendix E.1 of Therneau &amp; Grambsch (2000)
newdata &lt;- data.frame(trans=1:3,x1.1=c(0,0,0),x2.2=c(0,1,0),strata=1:3)
HvH &lt;- msfit(cx,newdata,trans=tmat)
# probtrans
pt &lt;- probtrans(HvH,predt=0)
# ELOS until last observed time point
ELOS(pt)
# Restricted ELOS until tau=10
ELOS(pt, tau=10)

</code></pre>

<hr>
<h2 id='etm2msdata'>Converts between etm and msdata format</h2><span id='topic+etm2msdata'></span><span id='topic+tra2trans'></span>

<h3>Description</h3>

<p>Converts multi-state data back and forth between etm and msdata formats.
Covariates have to be dealt with separately.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>etm2msdata(etmdata, id, tra, covs)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="etm2msdata_+3A_etmdata">etmdata</code></td>
<td>
<p>Multi-state data in <code>etm</code> format</p>
</td></tr>
<tr><td><code id="etm2msdata_+3A_id">id</code></td>
<td>
<p>Column name identifying the subject id</p>
</td></tr>
<tr><td><code id="etm2msdata_+3A_tra">tra</code></td>
<td>
<p>Transition matrix in <code>etm</code> format</p>
</td></tr>
<tr><td><code id="etm2msdata_+3A_covs">covs</code></td>
<td>
<p>Vector of column names containing covariates to be included</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>msdata2etm</code> will convert from <code>msdata</code> format to <code>etm</code>
format; <code>etm2msdata</code> will convert from <code>etm</code> format to
<code>msdata</code> format. Both <code>msdata2etm</code> and <code>etm2msdata</code> work with
basic time-fixed covariates. Time-dependent covariates are not supported.
The function <code>msdata2etm</code> will work for transition-specific covariates,
but the result does not really make much sense when used in etm.
</p>


<h3>Author(s)</h3>

<p>Hein Putter <a href="mailto:H.Putter@lumc.nl">H.Putter@lumc.nl</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Transition matrix for illness-death model
tmat &lt;- trans.illdeath()
# Data in wide format, for transition 1 this is dataset E1 of
# Therneau &amp; Grambsch (T&amp;G)
tg &lt;- data.frame(id=1:6,illt=c(1,1,6,6,8,9),ills=c(1,0,1,1,0,1),
                 dt=c(5,1,9,7,8,12),ds=c(1,1,1,1,1,1),
                 x1=c(1,1,1,0,0,0),x2=c(6:1))
# Data in long format using msprep
tglong &lt;- msprep(time=c(NA,"illt","dt"),status=c(NA,"ills","ds"),
                 data=tg,keep=c("x1","x2"),trans=tmat, id="id")
# Same thing in etm format
tra &lt;- trans2tra(tmat)
tgetm &lt;- msdata2etm(tglong, id="id")
tgetm &lt;- msdata2etm(tglong, id="id", covs=c("x1", "x2")) # with covariates
# And back
etm2msdata(tgetm, id="id", tra=tra)
etm2msdata(tgetm, id="id", tra=tra, covs=c("x1", "x2")) # with covariates
</code></pre>

<hr>
<h2 id='events'>Count number of observed transitions</h2><span id='topic+events'></span>

<h3>Description</h3>

<p>Given a dataset in long format, for instance generated by
<code><a href="#topic+msprep">msprep</a></code>, and a transition matrix for the multi-state model,
this function counts the number of observed transitions in the multi-state
model and gives their percentages.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>events(msdata)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="events_+3A_msdata">msdata</code></td>
<td>
<p>An object of class <code>"msdata"</code>, such as output by
<code><a href="#topic+msprep">msprep</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Although <code>msdata</code> does not need to be the result of a call to
<code><a href="#topic+msprep">msprep</a></code>, it does need to be an object of class <code>"msdata"</code>,
which is essentially a data frame in long format, with one row for each
transition for which the subject is at risk. The columns <code>from</code>,
<code>to</code>, and <code>status</code> need to be present, with appropriate meaning,
see <code><a href="#topic+msprep">msprep</a></code>. The <code>msdata</code> argument needs to have a
<code>"trans"</code> attributes, which holds the transition matrix of the
multi-state model.
</p>


<h3>Value</h3>

<p>A list containing two tables, the first, called <code>Frequencies</code>,
with the number of observed transitions in the multi-state model occurring
in <code>msdata</code>, the second, called <code>Proportions</code>, with the
corresponding proportions.
</p>


<h3>Author(s)</h3>

<p>Hein Putter <a href="mailto:H.Putter@lumc.nl">H.Putter@lumc.nl</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
tmat &lt;- trans.illdeath(names=c("Tx","PR","RelDeath"))
data(ebmt3) # data from Section 4 of Putter, Fiocco &amp; Geskus (2007)
msebmt &lt;- msprep(time=c(NA,"prtime","rfstime"),status=c(NA,"prstat","rfsstat"),
		data=ebmt3,trans=tmat)
events(msebmt) # see Fig 13 of Putter, Fiocco &amp; Geskus (2007)

</code></pre>

<hr>
<h2 id='expand.covs'>Expand covariates in competing risks dataset in stacked format</h2><span id='topic+expand.covs'></span><span id='topic+expand.covs.default'></span>

<h3>Description</h3>

<p>Given a competing risks dataset in stacked format, and one or more
covariates, this function adds type-specific covariates to the dataset. The
original dataset with the type-specific covariates appended is returned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expand.covs(data, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="expand.covs_+3A_data">data</code></td>
<td>
<p>An object of class <code>"msdata"</code>, such as output by
<code><a href="#topic+msprep">msprep</a></code></p>
</td></tr>
<tr><td><code id="expand.covs_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed to or from other methods. They
are ignored in this function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Type-specific covariates can be used to analyse separate effects on all
event types in a single analysis based on a stacked data set (Putter, Fiocco
&amp; Geskus (2007) and Geskus (2016)). It is only unambiguously defined for
numeric covariates or for explicit codings. Rows that contain the data for
that specific event type have the value copied from the original covariate
in case it is numeric. In all other rows it has the value zero. If the
covariate is a factor, it will be expanded on the design matrix given by
<code><a href="stats.html#topic+model.matrix">model.matrix</a></code>. For standard &quot;treatment
contrasts&quot; this means that dummy variables are created.  If the covariate is
a factor, the column name combines the name of the covariate with the
specific event type. If <code>longnames</code>=<code>TRUE</code>, both parts are
intersected by the specific labels in the coding. Missing values in the
basic covariates are allowed and result in missing values in the expanded
covariates.
</p>


<h3>Value</h3>

<p>An data frame object of the same class as the data argument,
containing the design matrix for the type-specific covariates, either on its
own (<code>append</code>=<code>FALSE</code>) or appended to the data
(<code>append</code>=<code>TRUE</code>).
</p>


<h3>Author(s)</h3>

<p>Ronald Geskus and Hein Putter <a href="mailto:H.Putter@lumc.nl">H.Putter@lumc.nl</a>
</p>


<h3>References</h3>

<p>Putter H, Fiocco M, Geskus RB (2007). Tutorial in biostatistics:
Competing risks and multi-state models. <em>Statistics in Medicine</em>
<b>26</b>, 2389&ndash;2430.
</p>
<p>Geskus, Ronald B. (2016). <em>Data Analysis with Competing Risks and
Intermediate States.</em> CRC Press, Boca Raton.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+expand.covs.msdata">expand.covs.msdata</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# small data set in stacked format
tg &lt;- data.frame(time=c(5,5,1,1,9,9),status=c(1,0,2,2,0,1),failcode=rep(c("I","II"),3),
        x1=c(1,1,2,2,2,2),x2=c(3,3,2,2,1,1))
tg$x1 &lt;- factor(tg$x1,labels=c("male","female"))
# expanded covariates
expand.covs(tg,covs=c("x1","x2"))
expand.covs(tg,covs=c("x1","x2"),longnames=TRUE)
expand.covs(tg,covs=c("x1","x2"),append=FALSE)

</code></pre>

<hr>
<h2 id='expand.covs.msdata'>Expand covariates in multi-state dataset in long format</h2><span id='topic+expand.covs.msdata'></span>

<h3>Description</h3>

<p>Given a multi-state dataset in long format, and one or more covariates, this
function adds transition-specific covariates, expanding the original
covariate(s), to the dataset. The original dataset with the
transition-specific covariates appended is returned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'msdata'
expand.covs(data, covs, append = TRUE, longnames = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="expand.covs.msdata_+3A_data">data</code></td>
<td>
<p>An object of class <code>"msdata"</code>, such as output by
<code><a href="#topic+msprep">msprep</a></code></p>
</td></tr>
<tr><td><code id="expand.covs.msdata_+3A_covs">covs</code></td>
<td>
<p>A character vector containing the names of the covariates in
<code>data</code> to be expanded</p>
</td></tr>
<tr><td><code id="expand.covs.msdata_+3A_append">append</code></td>
<td>
<p>Logical value indicating whether or not the design matrix for
the expanded covariates should be appended to the data (default=<code>TRUE</code>)</p>
</td></tr>
<tr><td><code id="expand.covs.msdata_+3A_longnames">longnames</code></td>
<td>
<p>Logical value indicating whether or not the labels are to
be used for the names of the expanded covariates that are categorical
(default=<code>TRUE</code>); in case of <code>FALSE</code> numbers from 1 up to the
number of contrasts are used</p>
</td></tr>
<tr><td><code id="expand.covs.msdata_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed to or from other methods. They
are ignored in this function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For a given basic covariate <code>Z</code>, the transition-specific covariate for
transition <code>s</code> is called <code>Z.s</code>. The concept of transition-specific
covariates in the context of multi-state models was introduced by Andersen,
Hansen &amp; Keiding (1991), see also Putter, Fiocco &amp; Geskus (2007). It is only
unambiguously defined for numeric covariates or for explicit codings. Then
it will take the value 0 for all rows in the long format dataframe for which
<code>trans</code> does not equal <code>s</code>. For the rows for which <code>trans</code>
equals <code>s</code>, the original value of <code>Z</code> is copied. In
<code>expand.covs</code>, when a given covariate is a factor, it will be expanded
on the design matrix given by
<code><a href="stats.html#topic+model.matrix">model.matrix</a></code>. Missing values in the basic
covariates are allowed and result in missing values in the expanded
covariates.
</p>


<h3>Value</h3>

<p>An object of class 'msdata', containing the design matrix for the
transition- specific covariates, either on its own
(<code>append</code>=<code>FALSE</code>) or appended to the data
(<code>append</code>=<code>TRUE</code>).
</p>


<h3>Author(s)</h3>

<p>Hein Putter <a href="mailto:H.Putter@lumc.nl">H.Putter@lumc.nl</a>
</p>


<h3>References</h3>

<p>Andersen PK, Hansen LS, Keiding N (1991). Non- and
semi-parametric estimation of transition probabilities from censored
observation of a non-homogeneous Markov process. <em>Scandinavian Journal
of Statistics</em> <b>18</b>, 153&ndash;167.
</p>
<p>Putter H, Fiocco M, Geskus RB (2007). Tutorial in biostatistics: Competing
risks and multi-state models. <em>Statistics in Medicine</em> <b>26</b>,
2389&ndash;2430.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# transition matrix for illness-death model
tmat &lt;- trans.illdeath()
# small data set in wide format
tg &lt;- data.frame(illt=c(1,1,6,6,8,9),ills=c(1,0,1,1,0,1),
        dt=c(5,1,9,7,8,12),ds=c(1,1,1,1,1,1),
        x1=c(1,1,1,2,2,2),x2=c(6:1))
tg$x1 &lt;- factor(tg$x1,labels=c("male","female"))
# data in long format using msprep
tglong &lt;- msprep(time=c(NA,"illt","dt"),
        status=c(NA,"ills","ds"),data=tg,
        keep=c("x1","x2"),trans=tmat)
# expanded covariates
expand.covs(tglong,c("x1","x2"),append=FALSE)
expand.covs(tglong,"x1")
expand.covs(tglong,"x1",longnames=FALSE)

</code></pre>

<hr>
<h2 id='haz_function'>Helper function that calculates excess and population hazards for a given transition</h2><span id='topic+haz_function'></span>

<h3>Description</h3>

<p>A function that calculates the excess and population hazards
for a given transition. Code is based on function rs.surv from
the relsurv package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>haz_function(
  formula = formula(data),
  data,
  ratetable = relsurv::slopop,
  na.action,
  add.times,
  rmap,
  include.all.times = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="haz_function_+3A_formula">formula</code></td>
<td>
<p>A non-parametric Surv-based formula, e.g. Surv(times, status)~1</p>
</td></tr>
<tr><td><code id="haz_function_+3A_data">data</code></td>
<td>
<p>A subset of the msprep object (dataset) where there's 
only data for the chosen transition</p>
</td></tr>
<tr><td><code id="haz_function_+3A_ratetable">ratetable</code></td>
<td>
<p>A table of event rates, organized as a ratetable object, such as slopop</p>
</td></tr>
<tr><td><code id="haz_function_+3A_na.action">na.action</code></td>
<td>
<p>A missing-data filter function, applied to the model.frame, after any subset argument has been used. Default is options()$na.action</p>
</td></tr>
<tr><td><code id="haz_function_+3A_add.times">add.times</code></td>
<td>
<p>Additional times at which the hazards should be evaluated</p>
</td></tr>
<tr><td><code id="haz_function_+3A_rmap">rmap</code></td>
<td>
<p>An optional list to be used if the variables are not organized and named in the same way as in the ratetable object</p>
</td></tr>
<tr><td><code id="haz_function_+3A_include.all.times">include.all.times</code></td>
<td>
<p>Should hazards be evaluated at all times in seq(minimum time, maximum time, by=1). Default is FALSE</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the needed hazards.
</p>


<h3>Author(s)</h3>

<p>Damjan Manevski <a href="mailto:damjan.manevski@mf.uni-lj.si">damjan.manevski@mf.uni-lj.si</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+msfit.relsurv">msfit.relsurv</a></code>
</p>

<hr>
<h2 id='Liver+20cirrhosis+20data'>Abnormal prothrombin levels in liver cirrhosis</h2><span id='topic+Liver+20cirrhosis+20data'></span><span id='topic+prothr'></span>

<h3>Description</h3>

<p>A data frame of 488 liver cirrhosis patients from a randomized clinical
trial concerning prednisone treatment in these patients. The dataset is in
long format. The included variables are </p>
 <dl>
<dt>id</dt><dd><p>Patient
identification number</p>
</dd> <dt>from</dt><dd><p>Starting state</p>
</dd> <dt>to</dt><dd><p>Receiving
state</p>
</dd> <dt>trans</dt><dd><p>Transition number</p>
</dd> <dt>Tstart</dt><dd><p>Starting time</p>
</dd>
<dt>Tstop</dt><dd><p>Transition time</p>
</dd> <dt>status</dt><dd><p>Status variable; 1=transition,
0=censored</p>
</dd> <dt>treat</dt><dd><p>Treatment; factor with levels &quot;Placebo&quot;,
&quot;Prednisone&quot;</p>
</dd> </dl>



<h3>Format</h3>

<p>A data frame, see <code><a href="base.html#topic+data.frame">data.frame</a></code>.
</p>


<h3>Details</h3>

<p>This data was kindly provided by Per Kragh Andersen. It was introduced in
Andersen, Borgan, Gill &amp; Keiding (1993), Example 1.3.12, and used as
illustration for computation of transition probabilities in multi-state
models, see Sections IV.4 (Example IV.4.4) and VII.2 (Example VII.2.10).
</p>


<h3>References</h3>

<p>Andersen PK, Borgan O, Gill RD, Keiding N (1993).
<em>Statistical Models Based on Counting Processes</em>. Springer, New York.
</p>

<hr>
<h2 id='LMAJ'>Landmark Aalen-Johansen method</h2><span id='topic+LMAJ'></span>

<h3>Description</h3>

<p>This function implements the landmark Aalen-Johansen method of Putter &amp;
Spitoni (2016) for non-parametric estimation of transition probabilities in
non-Markov models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LMAJ(msdata, s, from, method = c("aalen", "greenwood"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="LMAJ_+3A_msdata">msdata</code></td>
<td>
<p>An <code>"msdata"</code> object, as for instance prepared by
<code>link{msprep}</code></p>
</td></tr>
<tr><td><code id="LMAJ_+3A_s">s</code></td>
<td>
<p>The prediction time point s from which transition probabilities are
to be obtained</p>
</td></tr>
<tr><td><code id="LMAJ_+3A_from">from</code></td>
<td>
<p>Either a single state or a set of states in the state space
1,...,S</p>
</td></tr>
<tr><td><code id="LMAJ_+3A_method">method</code></td>
<td>
<p>The method for calculating variances, as in
<code><a href="#topic+probtrans">probtrans</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame containing estimates and associated standard errors of
the transition probabilities P(X(t)=k | X(s) in <code>from</code>) with <code>s</code>
and <code>from</code> the arguments of the function.
</p>


<h3>Author(s)</h3>

<p>Hein Putter <a href="mailto:H.Putter@lumc.nl">H.Putter@lumc.nl</a>
</p>
<p>Edouard F. Bonneville <a href="mailto:e.f.bonneville@lumc.nl">e.f.bonneville@lumc.nl</a>
</p>


<h3>References</h3>

<p>H. Putter and C. Spitoni (2016). Estimators of transition
probabilities in non-Markov multi-state models. Submitted.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(prothr)
tmat &lt;- attr(prothr, "trans")
pr0 &lt;- subset(prothr, treat=="Placebo")
attr(pr0, "trans") &lt;- tmat
pr1 &lt;- subset(prothr, treat=="Prednisone")
attr(pr1, "trans") &lt;- tmat
c0 &lt;- coxph(Surv(Tstart, Tstop, status) ~ strata(trans), data=pr0)
c1 &lt;- coxph(Surv(Tstart, Tstop, status) ~ strata(trans), data=pr1)
msf0 &lt;- msfit(c0, trans=tmat)
msf1 &lt;- msfit(c1, trans=tmat)
# Comparison as in Figure 2 of Titman (2015)
# Aalen-Johansen
pt0 &lt;- probtrans(msf0, predt=1000)[[2]]
pt1 &lt;- probtrans(msf1, predt=1000)[[2]]
par(mfrow=c(1,2))
plot(pt0$time, pt0$pstate1, type="s", lwd=2, xlim=c(1000,4000), ylim=c(0,0.61),
     xlab="Time since randomisation (days)", ylab="Probability")
lines(pt1$time, pt1$pstate1, type="s", lwd=2, lty=3)
legend("topright", c("Placebo", "Prednisone"), lwd=2, lty=1:2, bty="n")
title(main="Aalen-Johansen")
# Landmark Aalen-Johansen
LMpt0 &lt;- LMAJ(msdata=pr0, s=1000, from=2)
LMpt1 &lt;- LMAJ(msdata=pr1, s=1000, from=2)
plot(LMpt0$time, LMpt0$pstate1, type="s", lwd=2, xlim=c(1000,4000), ylim=c(0,0.61),
     xlab="Time since randomisation (days)", ylab="Probability")
lines(LMpt1$time, LMpt1$pstate1, type="s", lwd=2, lty=3)
legend("topright", c("Placebo", "Prednisone"), lwd=2, lty=1:2, bty="n")
title(main="Landmark Aalen-Johansen")

</code></pre>

<hr>
<h2 id='MarkovTest'>Log-rank based test for the validity of the Markov assumption</h2><span id='topic+MarkovTest'></span><span id='topic+optimal_weights_multiple'></span><span id='topic+optimal_weights_matrix'></span>

<h3>Description</h3>

<p>Log-rank based test for the validity of the Markov assumption
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MarkovTest(
  data,
  id,
  formula = NULL,
  transition,
  grid,
  B = 1000,
  fn = list(function(x) mean(abs(x), na.rm = TRUE)),
  fn2 = list(function(x) mean(x, na.rm = TRUE)),
  min_time = 0,
  other_weights = NULL,
  dist = c("poisson", "normal")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MarkovTest_+3A_data">data</code></td>
<td>
<p>Multi-state data in <code>msdata</code> format. Should also contain
(dummy codings of) the relevant covariates; no factors allowed</p>
</td></tr>
<tr><td><code id="MarkovTest_+3A_id">id</code></td>
<td>
<p>Column name in <code>data</code> containing subject id</p>
</td></tr>
<tr><td><code id="MarkovTest_+3A_formula">formula</code></td>
<td>
<p>Right-hand side of the formula. If NULL will fit with no
covariates (formula=&quot;1&quot; will also work), offset terms can also be specified.</p>
</td></tr>
<tr><td><code id="MarkovTest_+3A_transition">transition</code></td>
<td>
<p>Transition number of the transition to be tested (in the
transition matrix as attribute to <code>data</code>)</p>
</td></tr>
<tr><td><code id="MarkovTest_+3A_grid">grid</code></td>
<td>
<p>Grid of time points at which to compute the statistic</p>
</td></tr>
<tr><td><code id="MarkovTest_+3A_b">B</code></td>
<td>
<p>Number of wild bootstrap replications to perform</p>
</td></tr>
<tr><td><code id="MarkovTest_+3A_fn">fn</code></td>
<td>
<p>A list of summary functions to be applied to the individual zbar
traces (or a list of lists)</p>
</td></tr>
<tr><td><code id="MarkovTest_+3A_fn2">fn2</code></td>
<td>
<p>A list of summary functions to be applied to the overall
chi-squared trace</p>
</td></tr>
<tr><td><code id="MarkovTest_+3A_min_time">min_time</code></td>
<td>
<p>The minimum time for calculating optimal weights</p>
</td></tr>
<tr><td><code id="MarkovTest_+3A_other_weights">other_weights</code></td>
<td>
<p>Other (than optimal) weights can be specified here</p>
</td></tr>
<tr><td><code id="MarkovTest_+3A_dist">dist</code></td>
<td>
<p>Distribution of wild bootstrap random weights, either &quot;poisson&quot;
for centred Poisson (default), or &quot;normal&quot; for standard normal</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function MarkovTest performs the log-rank test described in Titman &amp; Putter
(2020). Function optimal_weights_matrix implements the optimal weighting for
the state-specific trace. Function optimal_weights_multiple implements the
optimal weighting for the chi-squared trace.
</p>


<h3>Value</h3>

<p>MarkovTest returns an object of class &quot;MarkovTest&quot;, which is a list
with the following items: </p>
<table role = "presentation">
<tr><td><code>orig_stat</code></td>
<td>
<p>Summary statistic for each of the
starting states</p>
</td></tr> <tr><td><code>orig_ch_stat</code></td>
<td>
<p>Overall chi-squared summary statistic</p>
</td></tr>
<tr><td><code>p_stat_wb</code></td>
<td>
<p>P-values corresponding to each of the summary statistics
for each starting state</p>
</td></tr> <tr><td><code>p_ch_stat_wb</code></td>
<td>
<p>P-values for overall
chi-squared summary statistic</p>
</td></tr> <tr><td><code>b_stat_wb</code></td>
<td>
<p>Bootstrap summary statistics
for each of the starting states</p>
</td></tr> <tr><td><code>zbar</code></td>
<td>
<p>Individual traces for each of
the starting states</p>
</td></tr> <tr><td><code>nobs_grid</code></td>
<td>
<p>The number of events after time s for
each s in the grid</p>
</td></tr> <tr><td><code>Nsub</code></td>
<td>
<p>Number of patients who are ever at risk of
the transition of interest</p>
</td></tr> <tr><td><code>est_quant</code></td>
<td>
<p>Pointwise 2.5 and 97.5 quantile
limits for each of the traces</p>
</td></tr> <tr><td><code>obs_chisq_trace</code></td>
<td>
<p>Trace of the
chi-squared statistic</p>
</td></tr> <tr><td><code>nch_wb_trace</code></td>
<td>
<p>Individual values of the
chi-squared statistic trace for the wild bootstrap samples</p>
</td></tr>
<tr><td><code>n_wb_trace</code></td>
<td>
<p>Individual values of the log-rank z statistic traces for
the wild bootstrap samples</p>
</td></tr> <tr><td><code>est_cov</code></td>
<td>
<p>Estimated covariance matrix
between the log-rank statistics at each grid point</p>
</td></tr> <tr><td><code>transition</code></td>
<td>
<p>The
transition number tested</p>
</td></tr> <tr><td><code>from</code></td>
<td>
<p>The from state of the transition
tested</p>
</td></tr> <tr><td><code>to</code></td>
<td>
<p>The to state of the transition tested</p>
</td></tr> <tr><td><code>B</code></td>
<td>
<p>The number
of wild bootstrap replications</p>
</td></tr> <tr><td><code>dist</code></td>
<td>
<p>The distribution used in the
wild bootstrap</p>
</td></tr> <tr><td><code>qualset</code></td>
<td>
<p>Set of qualifying states corresponding to the
components of the above traces</p>
</td></tr> <tr><td><code>coxfit</code></td>
<td>
<p>Fitted coxph object</p>
</td></tr>
<tr><td><code>fn</code></td>
<td>
<p>List of functions applied to state-specific trace</p>
</td></tr> <tr><td><code>fn2</code></td>
<td>
<p>List
of functions applied to overall trace</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Andrew Titman <a href="mailto:a.titman@lancaster.ac.uk">a.titman@lancaster.ac.uk</a>, transported to
mstate by Hein Putter <a href="mailto:H.Putter@lumc.nl">H.Putter@lumc.nl</a>
</p>


<h3>References</h3>

<p>Titman AC, Putter H (2020). General tests of the Markov property
in multi-state models. <em>Biostatistics</em> To appear.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
# Example provided by the prothrombin data
data("prothr")
# Apply Markov test to grid of monthly time points over the first 7.5 years
year &lt;- 365.25
month &lt;- year / 12
grid &lt;- month * (1 : 90)
# Markov test for transition 1 (wild bootstrap based on 25 replications, 1000 recommended)
MT &lt;- MarkovTest(prothr, id = "id", transition = 1,
                 grid = grid, B = 25)

# Plot traces
plot(MT, grid, what="states", idx=1:10, states=rownames(attr(prothr, "trans")),
     xlab="Days since randomisation", ylab="Log-rank test statistic",
     main="Transition Normal -&gt; Low")
plot(MT, grid,what="overall", idx=1:10,
     xlab="Days since randomisation", ylab="Chi-square test statistic",
     main="Transition Normal -&gt; Low")

# Example using optimal weights and adjustment for covariates
oweights_fun &lt;-
  optimal_weights_matrix(prothr, id = "id", grid=grid, transition = 1,
                         other_weights=list(
                           function(x) mean(abs(x),na.rm=TRUE),
                           function(x) max(abs(x),na.rm=TRUE)))

oweights_chi &lt;- optimal_weights_multiple(prothr, id = "id", grid=grid, transition = 1)

# Formula in MarkovTest only works for continuous covariates and dummy coded variables
# No factors allowed
prothr$prednisone &lt;- as.numeric(prothr$treat == "Prednisone")
MT &lt;- MarkovTest(prothr, id = "id", 
                 formula = "prednisone",
                 transition = 1,
                 grid = grid, B = 25,
                 fn = oweights_fun,
                 fn2 = list(
                   function(x) weighted.mean(x, w=oweights_chi, na.rm=TRUE),
                   function(x) mean(x, na.rm=TRUE),
                   function(x) max(x, na.rm=TRUE)))

## End(Not run)

</code></pre>

<hr>
<h2 id='modify_transMat'>Upgrade the transMat object for the multi-state/relsurv setting.</h2><span id='topic+modify_transMat'></span>

<h3>Description</h3>

<p>A function that upgrades the transMat object so that the population
and excess-related transitions are included in the transition matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>modify_transMat(trans, split.transitions)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="modify_transMat_+3A_trans">trans</code></td>
<td>
<p>The original transition matrix (usually generated using function
transMat from mstate). Also often present in the msfit object.</p>
</td></tr>
<tr><td><code id="modify_transMat_+3A_split.transitions">split.transitions</code></td>
<td>
<p>The transitions that should be split.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An upgraded transition matrix that contains the population and
excess transitions.
</p>


<h3>Author(s)</h3>

<p>Damjan Manevski <a href="mailto:damjan.manevski@mf.uni-lj.si">damjan.manevski@mf.uni-lj.si</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+transMat">transMat</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# transition matrix for illness-death model
trans &lt;- transMat(list(c(2,3),c(4), c(), c()), 
      names = c("Alive", "Relapse","Non-relapse mortality", "Death after relapse"))
split.transitions &lt;- c(2,3)
modify_transMat(trans, split.transitions) 

</code></pre>

<hr>
<h2 id='msboot'>Bootstrap function in multi-state models</h2><span id='topic+msboot'></span>

<h3>Description</h3>

<p>A generic nonparametric bootstrapping function for multi-state models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>msboot(theta, data, B = 5, id = "id", verbose = 0, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="msboot_+3A_theta">theta</code></td>
<td>
<p>A function of <code>data</code> and perhaps other arguments,
returning the value of the statistic to be bootstrapped; the output of theta
should be a scalar or numeric vector</p>
</td></tr>
<tr><td><code id="msboot_+3A_data">data</code></td>
<td>
<p>An object of class 'msdata', such as output from
<code><a href="#topic+msprep">msprep</a></code></p>
</td></tr>
<tr><td><code id="msboot_+3A_b">B</code></td>
<td>
<p>The number of bootstrap replications; the default is taken to be
quite small (5) since bootstrapping can be time-consuming</p>
</td></tr>
<tr><td><code id="msboot_+3A_id">id</code></td>
<td>
<p>Character string indicating which column identifies the subjects
to be resampled</p>
</td></tr>
<tr><td><code id="msboot_+3A_verbose">verbose</code></td>
<td>
<p>The level of output; default 0 = no output, 1 = print the
replication</p>
</td></tr>
<tr><td><code id="msboot_+3A_...">...</code></td>
<td>
<p>Any further arguments to the function <code>theta</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>msboot</code> samples randomly with replacement subjects from
the original dataset <code>data</code>. The individuals are identified with
<code>id</code>, and bootstrap datasets are produced by concatenating all selected
rows.
</p>


<h3>Value</h3>

<p>Matrix of dimension (length of output of theta) x B, with b'th
column being the value of theta for the b'th bootstrap dataset
</p>


<h3>Author(s)</h3>

<p>Marta Fiocco, Hein Putter &lt;H.Putter@lumc.nl&gt;
</p>


<h3>References</h3>

<p>Fiocco M, Putter H, van Houwelingen HC (2008). Reduced-rank
proportional hazards regression and simulation-based prediction for
multi-state models. <em>Statistics in Medicine</em> <b>27</b>, 4340&ndash;4358.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
tmat &lt;- trans.illdeath()
data(ebmt1)
covs &lt;- c("score","yrel")
msebmt &lt;- msprep(time=c(NA,"rel","srv"),status=c(NA,"relstat","srvstat"),
		data=ebmt1,id="patid",keep=covs,trans=tmat)
# define a function (this one returns vector of regression coef's)
regcoefvec &lt;- function(data) {
  cx &lt;- coxph(Surv(Tstart,Tstop,status)~score+strata(trans),
          data=data,method="breslow")
  return(coef(cx))
}
regcoefvec(msebmt)
set.seed(1234)
msboot(theta=regcoefvec,data=msebmt,id="patid")

</code></pre>

<hr>
<h2 id='msboot.relsurv'>Bootstrap function for upgraded multi-state models using relsurv</h2><span id='topic+msboot.relsurv'></span>

<h3>Description</h3>

<p>A helper nonparametric bootstrapping function for variances
in extended multi-state models using relative survival.
This implementation is written based on function mstate:::msboot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>msboot.relsurv(
  theta,
  data,
  B = 10,
  id = "id",
  verbose = 0,
  transmat,
  all_times,
  split.transitions,
  rmap,
  time.format,
  boot_orig_msfit,
  ratetable = relsurv::slopop,
  add.times,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="msboot.relsurv_+3A_theta">theta</code></td>
<td>
<p>A function of data and perhaps other arguments, returning the value of the statistic to be bootstrapped</p>
</td></tr>
<tr><td><code id="msboot.relsurv_+3A_data">data</code></td>
<td>
<p>An object of class 'msdata', such as output from msprep</p>
</td></tr>
<tr><td><code id="msboot.relsurv_+3A_b">B</code></td>
<td>
<p>The number of bootstrap replications; the default is B=10</p>
</td></tr>
<tr><td><code id="msboot.relsurv_+3A_id">id</code></td>
<td>
<p>Character string indicating which column identifies the subjects to be resampled</p>
</td></tr>
<tr><td><code id="msboot.relsurv_+3A_verbose">verbose</code></td>
<td>
<p>The level of output; default 0 = no output, 1 = print the replication</p>
</td></tr>
<tr><td><code id="msboot.relsurv_+3A_transmat">transmat</code></td>
<td>
<p>The transition matrix of class transMat</p>
</td></tr>
<tr><td><code id="msboot.relsurv_+3A_all_times">all_times</code></td>
<td>
<p>All times at which the hazards have to be evaluated</p>
</td></tr>
<tr><td><code id="msboot.relsurv_+3A_split.transitions">split.transitions</code></td>
<td>
<p>An integer vector containing the numbered transitions that should be split. Use same numbering as in the given transition matrix</p>
</td></tr>
<tr><td><code id="msboot.relsurv_+3A_rmap">rmap</code></td>
<td>
<p>An optional list to be used if the variables in the dataset are not organized (and named) in the same way as in the ratetable object</p>
</td></tr>
<tr><td><code id="msboot.relsurv_+3A_time.format">time.format</code></td>
<td>
<p>Define the time format which is used in the dataset Possible options: c('days', 'years', 'months'). Default is 'days'</p>
</td></tr>
<tr><td><code id="msboot.relsurv_+3A_boot_orig_msfit">boot_orig_msfit</code></td>
<td>
<p>Logical, if true, do the bootstrap for the basic msfit model</p>
</td></tr>
<tr><td><code id="msboot.relsurv_+3A_ratetable">ratetable</code></td>
<td>
<p>The population mortality table. A table of event rates, organized as a ratetable object, see for example relsurv::slopop. Default is slopop</p>
</td></tr>
<tr><td><code id="msboot.relsurv_+3A_add.times">add.times</code></td>
<td>
<p>Additional times at which hazards should be evaluated</p>
</td></tr>
<tr><td><code id="msboot.relsurv_+3A_...">...</code></td>
<td>
<p>Any further arguments to the function theta</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of size B containing the results for every bootstrap replication.
</p>


<h3>Author(s)</h3>

<p>Damjan Manevski <a href="mailto:damjan.manevski@mf.uni-lj.si">damjan.manevski@mf.uni-lj.si</a>, Marta Fiocco, Hein Putter <a href="mailto:H.Putter@lumc.nl">H.Putter@lumc.nl</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+msboot">msboot</a></code>
</p>

<hr>
<h2 id='msboot.relsurv.boot'>Default theta function used for msboot.relsurv</h2><span id='topic+msboot.relsurv.boot'></span>

<h3>Description</h3>

<p>Helper function used for calling inside msboot.relsurv
(used for every bootstrap dataset).
This function is used for calculating split hazards
and evaluating them at all needed times.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>msboot.relsurv.boot(
  data,
  transmat,
  all_times,
  split.transitions,
  rmap,
  time.format,
  boot_orig_msfit = FALSE,
  ratetable = relsurv::slopop,
  add.times
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="msboot.relsurv.boot_+3A_data">data</code></td>
<td>
<p>An object of class 'msdata' containing a bootstrapped sample</p>
</td></tr>
<tr><td><code id="msboot.relsurv.boot_+3A_transmat">transmat</code></td>
<td>
<p>The transition matrix of class transMat</p>
</td></tr>
<tr><td><code id="msboot.relsurv.boot_+3A_all_times">all_times</code></td>
<td>
<p>All times at which the hazards have to be evaluated</p>
</td></tr>
<tr><td><code id="msboot.relsurv.boot_+3A_split.transitions">split.transitions</code></td>
<td>
<p>An integer vector containing the numbered transitions that should be split. Use same numbering as in the given transition matrix</p>
</td></tr>
<tr><td><code id="msboot.relsurv.boot_+3A_rmap">rmap</code></td>
<td>
<p>An optional list to be used if the variables in the dataset are not organized (and named) in the same way as in the ratetable object</p>
</td></tr>
<tr><td><code id="msboot.relsurv.boot_+3A_time.format">time.format</code></td>
<td>
<p>Define the time format which is used in the dataset Possible options: c('days', 'years', 'months'). Default is 'days'</p>
</td></tr>
<tr><td><code id="msboot.relsurv.boot_+3A_boot_orig_msfit">boot_orig_msfit</code></td>
<td>
<p>Logical, if true, do the bootstrap for the basic msfit model</p>
</td></tr>
<tr><td><code id="msboot.relsurv.boot_+3A_ratetable">ratetable</code></td>
<td>
<p>The population mortality table. A table of event rates, organized as a ratetable object, see for example relsurv::slopop. Default is slopop</p>
</td></tr>
<tr><td><code id="msboot.relsurv.boot_+3A_add.times">add.times</code></td>
<td>
<p>Additional times at which hazards should be evaluated</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of calculated values for the given bootstrap sample.
</p>


<h3>Author(s)</h3>

<p>Damjan Manevski <a href="mailto:damjan.manevski@mf.uni-lj.si">damjan.manevski@mf.uni-lj.si</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+msboot.relsurv">msboot.relsurv</a></code>
</p>

<hr>
<h2 id='msdata2etm'>msdata to etm format</h2><span id='topic+msdata2etm'></span>

<h3>Description</h3>

<p>msdata to etm format
</p>


<h3>Usage</h3>

<pre><code class='language-R'>msdata2etm(msdata, id, covs)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="msdata2etm_+3A_msdata">msdata</code></td>
<td>
<p>Multi-state data in <code>msdata</code> format, as used in
<code>mstate</code></p>
</td></tr>
<tr><td><code id="msdata2etm_+3A_id">id</code></td>
<td>
<p>Column name identifying the subject id</p>
</td></tr>
<tr><td><code id="msdata2etm_+3A_covs">covs</code></td>
<td>
<p>Vector of column names containing covariates to be included</p>
</td></tr>
</table>

<hr>
<h2 id='msfit'>Compute subject-specific transition hazards with (co-)variances</h2><span id='topic+msfit'></span>

<h3>Description</h3>

<p>This function computes subject-specific or overall cumulative transition
hazards for each of the possible transitions in the multi-state model. If
requested, also the variances and covariances of the estimated cumulative
transition hazards are calculated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>msfit(
  object,
  newdata,
  variance = TRUE,
  vartype = c("aalen", "greenwood"),
  trans
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="msfit_+3A_object">object</code></td>
<td>
<p>A <code><a href="survival.html#topic+coxph">coxph</a></code> object describing the
fit of the multi-state model</p>
</td></tr>
<tr><td><code id="msfit_+3A_newdata">newdata</code></td>
<td>
<p>A data frame with the same variable names as those that
appear in the <code>coxph</code> formula. Its use is somewhat different from
<code><a href="survival.html#topic+survfit">survfit</a></code>. See Details.  The argument
<code>newdata</code> may be omitted only if the right hand side of the formula in
the <code>coxph</code> object is <code>~strata(trans)</code></p>
</td></tr>
<tr><td><code id="msfit_+3A_variance">variance</code></td>
<td>
<p>A logical value indicating whether the (co-)variances of the
subject-specific transition hazards should be computed. Default is
<code>TRUE</code></p>
</td></tr>
<tr><td><code id="msfit_+3A_vartype">vartype</code></td>
<td>
<p>A character string specifying the type of variances to be
computed (so only needed if <code>variance</code>=<code>TRUE</code>).  Possible values
are <code>"aalen"</code> or <code>"greenwood"</code></p>
</td></tr>
<tr><td><code id="msfit_+3A_trans">trans</code></td>
<td>
<p>Transition matrix describing the states and transitions in the
multi-state model. See <code>trans</code> in <code><a href="#topic+msprep">msprep</a></code> for more
detailed information</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The data frame needs to have one row for each transition in the multi-state
model. An additional column <code>strata</code> (numeric) is needed to describe
for each transition to which stratum it belongs. The name has to be
<code>strata</code>, even if in the original <code>coxph</code> call another variable
was used. For details refer to de Wreede, Fiocco &amp; Putter (2010). So far,
the results have been checked only for the <code>"breslow"</code> method of
dealing with ties in <code><a href="survival.html#topic+coxph">coxph</a></code>, so this is
recommended.
</p>


<h3>Value</h3>

<p>An object of class <code>"msfit"</code>, which is a list containing
</p>
<table role = "presentation">
<tr><td><code>Haz</code></td>
<td>
<p>A data frame with <code>time</code>, <code>Haz</code>, <code>trans</code>,
containing the estimated subject-specific hazards for each of the
transitions in the multi-state model</p>
</td></tr> <tr><td><code>varHaz</code></td>
<td>
<p>A data frame with
<code>time</code>, <code>Haz</code>, <code>trans1</code>, <code>trans2</code> containing the
variances (<code>trans1</code>=<code>trans2</code>) and covariances
(<code>trans1</code>&lt;<code>trans2</code>) of the estimated hazards. This element is only
returned when <code>variance</code>=<code>TRUE</code></p>
</td></tr> <tr><td><code>trans</code></td>
<td>
<p>The transition
matrix used</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Hein Putter <a href="mailto:H.Putter@lumc.nl">H.Putter@lumc.nl</a>
</p>


<h3>References</h3>

<p>Putter H, Fiocco M, Geskus RB (2007). Tutorial in biostatistics:
Competing risks and multi-state models. <em>Statistics in Medicine</em>
<b>26</b>, 2389&ndash;2430.
</p>
<p>Therneau TM, Grambsch PM (2000). <em>Modeling Survival Data: Extending the
Cox Model</em>. Springer, New York.
</p>
<p>de Wreede LC, Fiocco M, and Putter H (2010). The mstate package for
estimation and prediction in non- and semi-parametric multi-state and
competing risks models. <em>Computer Methods and Programs in Biomedicine</em>
<b>99</b>, 261&ndash;274.
</p>
<p>de Wreede LC, Fiocco M, and Putter H (2011). mstate: An R Package for the
Analysis of Competing Risks and Multi-State Models. <em>Journal of
Statistical Software</em>, Volume 38, Issue 7.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.msfit">plot.msfit</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# transition matrix for illness-death model
tmat &lt;- trans.illdeath()
# data in wide format, for transition 1 this is dataset E1 of
# Therneau &amp; Grambsch (2000)
tg &lt;- data.frame(illt=c(1,1,6,6,8,9),ills=c(1,0,1,1,0,1),
        dt=c(5,1,9,7,8,12),ds=c(1,1,1,1,1,1),
        x1=c(1,1,1,0,0,0),x2=c(6:1))
# data in long format using msprep
tglong &lt;- msprep(time=c(NA,"illt","dt"),status=c(NA,"ills","ds"),
		data=tg,keep=c("x1","x2"),trans=tmat)
# events
events(tglong)
table(tglong$status,tglong$to,tglong$from)
# expanded covariates
tglong &lt;- expand.covs(tglong,c("x1","x2"))
# Cox model with different covariate
cx &lt;- coxph(Surv(Tstart,Tstop,status)~x1.1+x2.2+strata(trans),
	data=tglong,method="breslow")
summary(cx)
# new data, to check whether results are the same for transition 1 as
# those in appendix E.1 of Therneau &amp; Grambsch (2000)
newdata &lt;- data.frame(trans=1:3,x1.1=c(0,0,0),x2.2=c(0,1,0),strata=1:3)
msfit(cx,newdata,trans=tmat)

</code></pre>

<hr>
<h2 id='msfit.relsurv'>Extend a multi-state model using relative survival</h2><span id='topic+msfit.relsurv'></span>

<h3>Description</h3>

<p>A function that takes a fitted msfit object and upgrades
it using relative survival, where chosen transitions are
split in population and excess transitions. This upgraded 
msfit object contains the split hazards based on the transition
matrix (transMat). The (co)variance matrix is also upgraded, if provided.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>msfit.relsurv(
  msfit.obj,
  data,
  split.transitions,
  ratetable = relsurv::slopop,
  rmap,
  time.format = "days",
  var.pop.haz = c("fixed", "bootstrap", "both"),
  B = 10,
  seed = NULL,
  add.times,
  substitution = TRUE,
  link_trans_ind = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="msfit.relsurv_+3A_msfit.obj">msfit.obj</code></td>
<td>
<p>The msfit object which has to be upgraded</p>
</td></tr>
<tr><td><code id="msfit.relsurv_+3A_data">data</code></td>
<td>
<p>The data used for fitting the msfit model</p>
</td></tr>
<tr><td><code id="msfit.relsurv_+3A_split.transitions">split.transitions</code></td>
<td>
<p>An integer vector containing the numbered transitions that should be split. Use same numbering as in the given transition matrix</p>
</td></tr>
<tr><td><code id="msfit.relsurv_+3A_ratetable">ratetable</code></td>
<td>
<p>The population mortality table. A table of event rates, organized as a ratetable object, see for example relsurv::slopop. Default is slopop</p>
</td></tr>
<tr><td><code id="msfit.relsurv_+3A_rmap">rmap</code></td>
<td>
<p>An optional list to be used if the variables in the data are not organized (and named) in the same way as in the ratetable object</p>
</td></tr>
<tr><td><code id="msfit.relsurv_+3A_time.format">time.format</code></td>
<td>
<p>Define the time format which is used in the data. Possible options: c('days', 'years', 'months'). Default is 'days'</p>
</td></tr>
<tr><td><code id="msfit.relsurv_+3A_var.pop.haz">var.pop.haz</code></td>
<td>
<p>If 'fixed' (default), the Greenwood estimator for the variances is used, where it is assumed that the variance of the population hazards is zero. If 'bootstrap', one gets boostrap estimates for all all transitions. Option 'both' gives both variance estimates</p>
</td></tr>
<tr><td><code id="msfit.relsurv_+3A_b">B</code></td>
<td>
<p>Number of bootstrap replications. Relevant only if var.pop.haz == 'bootstrap' or 'both'. Default is B=10.</p>
</td></tr>
<tr><td><code id="msfit.relsurv_+3A_seed">seed</code></td>
<td>
<p>Set seed</p>
</td></tr>
<tr><td><code id="msfit.relsurv_+3A_add.times">add.times</code></td>
<td>
<p>Additional times at which hazards should be evaluated</p>
</td></tr>
<tr><td><code id="msfit.relsurv_+3A_substitution">substitution</code></td>
<td>
<p>Whether function substitute should be used for rmap argument. Default is TRUE</p>
</td></tr>
<tr><td><code id="msfit.relsurv_+3A_link_trans_ind">link_trans_ind</code></td>
<td>
<p>Choose whether the linkage between the old and new transition matrix should be saved. Default is FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a msfit object that contains estimates for the extended model
with split (population and excess) transitions.
</p>


<h3>Author(s)</h3>

<p>Damjan Manevski <a href="mailto:damjan.manevski@mf.uni-lj.si">damjan.manevski@mf.uni-lj.si</a>
</p>


<h3>References</h3>

<p>Manevski D, Putter H, Pohar Perme M, Bonneville EF, Schetelig J, de Wreede LC (2021).
Integrating relative survival in multi-state models &ndash; a non-parametric approach.
https://arxiv.org/abs/2106.12399
</p>


<h3>See Also</h3>

<p><code><a href="#topic+msfit">msfit</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
library(mstate)
# Load dataset:
data("ebmt1")
# Transition matrix:
tmat &lt;- transMat(list(c(2,3),c(4), c(), c()), 
                 names = c("Alive relapse-free", "Relapse","NRM", "DaR"))
# Data in long format using msprep
df &lt;- msprep(time=c(NA,"rel","srv","srv"), status=c(NA,"relstat","srvstat","srvstat"),
             data=ebmt1, trans=tmat)
# Generate demographic covariates (which are usually present in datasets) 
# and based on them estimate the population hazard.
set.seed(510)
df$age &lt;- runif(nrow(df), 45, 65)
df$sex &lt;- sample(c("male", "female"), size = nrow(df), replace = TRUE)
df$dateHCT &lt;- sample(seq(as.Date('1990/01/01'), 
    as.Date('2000/01/01'), by="day"), nrow(df), replace = TRUE) # generate years
# Cox object:
cx &lt;- coxph(Surv(Tstart,Tstop,status)~strata(trans),
            data=df,method="breslow")
# Basic multi-state model:
mod &lt;- msfit(cx,trans=tmat)
# Extended multi-state model, where the two transition
# reaching death are split in excess and population parts.
# We assume patients live like in the Slovene population,
# thus we use Slovene mortality tables in this example.
# Variances estimated using 25 bootstrap replications.
mod.relsurv &lt;- msfit.relsurv(msfit.obj = mod, data=df, split.transitions = c(2,3),
                            ratetable = relsurv::slopop, 
                            rmap = list(age=age*365.241, year=dateHCT),
                            time.format = "days",
                            var.pop.haz = "bootstrap",
                            B = 25)
# Estimate transition probabilities:
pt &lt;- probtrans(mod.relsurv, predt=0, method='greenwood')
# Estimated cumulative hazards with the corresponding 
# bootstrap standard errors at 300, 600, 900 days:
summary(object = mod.relsurv, times = c(300, 600, 900), conf.type = 'log')
# Estimated transition probabilities together with the corresponding 
# bootstrap standard errors and log.boot confidence intervals 
# at 300, 600, 900 days:
summary(object = pt, times = c(300, 600, 900), conf.type = 'log')
# Plot the measures:
plot(mod.relsurv, use.ggplot = TRUE)
plot(pt, use.ggplot = TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='msprep'>Function to prepare dataset for multi-state modeling in long format from
dataset in wide format</h2><span id='topic+msprep'></span>

<h3>Description</h3>

<p>This function converts a dataset which is in wide format (one subject per
line, multiple columns indicating time and status for different states) into
a dataset in long format (one line for each transition for which a subject
is at risk). Selected covariates are replicated per subjects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>msprep(time, status, data, trans, start, id, keep)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="msprep_+3A_time">time</code></td>
<td>
<p>Either 1) a matrix or data frame of dimension n x S (n being the
number of individuals and S the number of states in the multi-state model),
containing the times at which the states are visited or last follow-up time,
or 2) a character vector of length S containing the column names indicating
these times. In the latter cases, some elements of <code>time</code> may be NA,
see Details</p>
</td></tr>
<tr><td><code id="msprep_+3A_status">status</code></td>
<td>
<p>Either 1) a matrix or data frame of dimension n x S,
containing, for each of the states, event indicators taking the value 1 if
the state is visited or 0 if it is not (censored), or 2) a character vector
of length S containing the column names indicating these status variables.
In the latter cases, some elements of <code>status</code> may be NA, see Details</p>
</td></tr>
<tr><td><code id="msprep_+3A_data">data</code></td>
<td>
<p>Data frame (not a tibble) in wide format in which to interpret
<code>time</code>, <code>status</code>, <code>id</code> or <code>keep</code>, if appropriate</p>
</td></tr>
<tr><td><code id="msprep_+3A_trans">trans</code></td>
<td>
<p>Transition matrix describing the states and transitions in the
multi-state model. If S is the number of states in the multi-state model,
<code>trans</code> should be an S x S matrix, with (i,j)-element a positive
integer if a transition from i to j is possible in the multi-state model,
<code>NA</code> otherwise. In particular, all diagonal elements should be
<code>NA</code>. The integers indicating the possible transitions in the
multi-state model should be sequentially numbered, 1,...,K, with K the
number of transitions</p>
</td></tr>
<tr><td><code id="msprep_+3A_start">start</code></td>
<td>
<p>List with elements <code>state</code> and <code>time</code>, containing
starting states and times of the subjects in the data.  Default is
<code>NULL</code>, in which case all subjects start in state 1 at time 0. If a
single state and time are given this state and time is used for all
subjects, otherwise the length of <code>state</code> and <code>time</code> should equal
the number of subjects in <code>data</code></p>
</td></tr>
<tr><td><code id="msprep_+3A_id">id</code></td>
<td>
<p>Either 1) a vector of length n containing the subject
identifications, or 2) a character string indicating the column name
containing these subject ids. If not provided, <code>"id"</code> will be assigned
with values 1,...,n</p>
</td></tr>
<tr><td><code id="msprep_+3A_keep">keep</code></td>
<td>
<p>Either 1) a data frame or matrix with n rows or a numeric or
factor vector of length n containing covariate(s) that need to be retained
in the output dataset, or 2) a character vector containing the column names
of these covariates in <code>data</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>For <code>msprep</code>, the transition matrix should correspond to an
irreversible acyclic Markov chain. In particular, on the diagonals only
<code>NA</code>s are allowed.
</p>
<p>The transition matrix, if irreversible and acyclic, will have starting
states, i.e. states into which no transitions are possible. For these
starting states <code>NA</code>s are allowed in the <code>time</code> and <code>status</code>
arguments, either as columns, when specified as matrix or data frame, or as
elements of the character vector when specified as character vector.
</p>
<p>The function <code>msprep</code> uses a recursive algorithm through calls to the
recursive function <code>msprepEngine</code>. First, with the current transition
matrix, all starting states are detected (defined as states into which there
are no transitions). For each of these starting states, all subjects
starting from that state are selected and for each subject the next visited
state is detected by looking at all transitions from that starting state and
determining the smallest transition time with <code>status</code>=1. The recursive
<code>msprepEngine</code> is called again with the starting states deleted from
the transition matrix and with subjects deleted that either reached an
absorbing state or that were censored. For the remaining subjects the
starting states and times are updated in the next call. Datasets returned
from the <code>msprepEngine</code> calls are appended to the current dataset in
long format and finally sorted.
</p>
<p>A warning is issued for a subject, if multiple transitions exist with the
same smallest transition time (and <code>status</code>=0). In such cases the next
transition cannot be determined unambiguously, and the state with the
smallest number is chosen. In our experience, occasionally the shortest
transition time has <code>status</code>=0, while a higher transition time has
<code>status</code>=1. Then this larger transition time and the corresponding
transition is selected. No warning is issued for these data inconsistencies.
</p>


<h3>Value</h3>

<p>An object of class <code>"msdata"</code>, which is a data frame in long
(counting process) format containing the subject id, the covariates
(replicated per subject), and </p>
<table role = "presentation">
<tr><td><code>from</code></td>
<td>
<p>the starting state</p>
</td></tr> <tr><td><code>to</code></td>
<td>
<p>the
receiving state</p>
</td></tr> <tr><td><code>trans</code></td>
<td>
<p>the transition number</p>
</td></tr> <tr><td><code>Tstart</code></td>
<td>
<p>the
starting time of the transition</p>
</td></tr> <tr><td><code>Tstop</code></td>
<td>
<p>the stopping time of the
transition</p>
</td></tr> <tr><td><code>status</code></td>
<td>
<p>status variable, with 1 indicating an event
(transition), 0 a censoring</p>
</td></tr></table>
<p> The <code>"msdata"</code> object has the transition
matrix as <code>"trans"</code> attribute.
</p>


<h3>Author(s)</h3>

<p>Hein Putter <a href="mailto:H.Putter@lumc.nl">H.Putter@lumc.nl</a> and Marta Fiocco
</p>


<h3>References</h3>

<p>Putter H, Fiocco M, Geskus RB (2007). Tutorial in biostatistics:
Competing risks and multi-state models. <em>Statistics in Medicine</em>
<b>26</b>, 2389&ndash;2430.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# transition matrix for illness-death model
tmat &lt;- trans.illdeath()
# some data in wide format
tg &lt;- data.frame(stt=rep(0,6),sts=rep(0,6),
        illt=c(1,1,6,6,8,9),ills=c(1,0,1,1,0,1),
        dt=c(5,1,9,7,8,12),ds=c(1,1,1,1,1,1),
        x1=c(1,1,1,2,2,2),x2=c(6:1))
tg$x1 &lt;- factor(tg$x1,labels=c("male","female"))
tg$patid &lt;- factor(2:7,levels=1:8,labels=as.character(1:8))
# define time, status and covariates also as matrices
tt &lt;- matrix(c(rep(NA,6),tg$illt,tg$dt),6,3)
st &lt;- matrix(c(rep(NA,6),tg$ills,tg$ds),6,3)
keepmat &lt;- data.frame(gender=tg$x1,age=tg$x2)
# data in long format using msprep
msprep(time=tt,status=st,trans=tmat,keep=as.matrix(keepmat))
msprep(time=c(NA,"illt","dt"),status=c(NA,"ills","ds"),data=tg,
		id="patid",keep=c("x1","x2"),trans=tmat)
# Patient no 5, 6 now start in state 2 at time t=4 and t=10
msprep(time=tt,status=st,trans=tmat,keep=keepmat,
        start=list(state=c(1,1,1,1,2,2),time=c(0,0,0,0,4,10)))

</code></pre>

<hr>
<h2 id='mssample'>Sample paths through a multi-state model</h2><span id='topic+mssample'></span>

<h3>Description</h3>

<p>Given cumulative transition hazards sample paths through the multi-state
model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mssample(
  Haz,
  trans,
  history = list(state = 1, time = 0, tstate = NULL),
  beta.state = NULL,
  clock = c("forward", "reset"),
  output = c("state", "path", "data"),
  tvec,
  cens = NULL,
  M = 10,
  do.trace = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mssample_+3A_haz">Haz</code></td>
<td>
<p>Cumulative hazards to be sampled from. These should be given as a
data frame with columns <code>time</code>, <code>Haz</code>, <code>trans</code>, for instance
as the <code>Haz</code> list element given by <code><a href="#topic+msfit">msfit</a></code>.</p>
</td></tr>
<tr><td><code id="mssample_+3A_trans">trans</code></td>
<td>
<p>Transition matrix describing the multi-state model.  See
<code>trans</code> in <code><a href="#topic+msprep">msprep</a></code> for more detailed information</p>
</td></tr>
<tr><td><code id="mssample_+3A_history">history</code></td>
<td>
<p>A list with elements <code>state</code>, specifying the starting
state(s), <code>time</code>, the starting time(s), and <code>tstate</code>, a numeric
vector of length the number of states, specifying at what times states have
been visited, if appropriate. The default of <code>tstate</code> is <code>NULL</code>;
more information can be found under Details.
</p>
<p>The elements <code>state</code> and <code>time</code> may either be scalars or vectors,
in which case different sampled paths may start from different states or at
different times. By default, all sampled paths start from state 1 at time 0.</p>
</td></tr>
<tr><td><code id="mssample_+3A_beta.state">beta.state</code></td>
<td>
<p>A matrix of dimension (no states) x (no transitions)
specifying estimated effects of times at which earlier states were reached
on subsequent transitions. If these are not in the model, the value
<code>NULL</code> (default) suffices; more information can be found under Details</p>
</td></tr>
<tr><td><code id="mssample_+3A_clock">clock</code></td>
<td>
<p>Character argument, either <code>"forward"</code> (default) or
<code>"reset"</code>, specifying whether the time-scale of the cumulative hazards
is in forward time (<code>"forward"</code>) or duration in the present state
(<code>"reset"</code>)</p>
</td></tr>
<tr><td><code id="mssample_+3A_output">output</code></td>
<td>
<p>One of <code>"state"</code>, <code>"path"</code>, or <code>"data"</code>,
specifying whether states, paths, or data should be output.</p>
</td></tr>
<tr><td><code id="mssample_+3A_tvec">tvec</code></td>
<td>
<p>A numeric vector of time points at which the states or paths
should be evaluated. Ignored if <code>output</code>=<code>"data"</code></p>
</td></tr>
<tr><td><code id="mssample_+3A_cens">cens</code></td>
<td>
<p>An independent censoring distribution, given as a data frame
with time and Haz</p>
</td></tr>
<tr><td><code id="mssample_+3A_m">M</code></td>
<td>
<p>The number of sampled trajectories through the multi-state model.
The default is 10, since the procedure can become quite time-consuming</p>
</td></tr>
<tr><td><code id="mssample_+3A_do.trace">do.trace</code></td>
<td>
<p>An integer, specifying that the replication number should be
written to the console every <code>do.trace</code> replications. Default is
<code>NULL</code> in which case no output is written to the console during the
simulation</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The procedure is described in detail in Fiocco, Putter &amp; van Houwelingen
(2008). The argument <code>beta.state</code> and the element <code>tstate</code> from
the argument <code>history</code> are meant to incorporate situations where the
time at which some previous states were visited may affect future transition
rates. The relation between time of visit of state <code>s</code> and transition
<code>k</code> is assumed to be linear on the log-hazards; the corresponding
regression coefficient is to be supplied as the (s,k)-element of
<code>beta.state</code>, which is 0 if no such effect has been included in the
model. If no such effects are present, then <code>beta.state</code>=<code>NULL</code>
(default) suffices. In the <code>tstate</code> element of <code>history</code>, the
<code>s</code>-th element is the time at which state <code>s</code> was visited. This is
only relevant for states which have been visited prior to the beginning of
sampling, i.e. before the <code>time</code> element of <code>history</code>; the
elements of <code>tstate</code> are internally updated when in the sampling
process new states are visited (only if <code>beta.state</code> is not <code>NULL</code>
to avoid unnecessary computations).
</p>


<h3>Value</h3>

<p>M simulated paths through the multi-state model given by
<code>trans</code> and <code>Haz</code>. It is either a data frame with columns
<code>time</code>, <code>pstate1</code>, ..., <code>pstateS</code> for S states when
<code>output="state"</code>, or with columns <code>time</code>, <code>ppath1</code>,...,
<code>ppathP</code> for the P paths specified in <code><a href="#topic+paths">paths</a></code>(trans) when
<code>output="path"</code>. When <code>output="data"</code>, the sampled paths are
stored in an <code>"msdata"</code> object, a data frame in long format such as
that obtained by <code><a href="#topic+msprep">msprep</a></code>. This may be useful for
(semi-)parametric bootstrap procedures, in which case <code>cens</code> may be
used as censoring distribution (assumed to be independent of all transition
times and independent of any covariates).
</p>


<h3>Author(s)</h3>

<p>Marta Fiocco, Hein Putter <a href="mailto:H.Putter@lumc.nl">H.Putter@lumc.nl</a>
</p>


<h3>References</h3>

<p>Fiocco M, Putter H, van Houwelingen HC (2008). Reduced-rank
proportional hazards regression and simulation-based prediction for
multi-state models. <em>Statistics in Medicine</em> <b>27</b>, 4340&ndash;4358.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# transition matrix for illness-death model
tmat &lt;- trans.illdeath()
# data in wide format, for transition 1 this is dataset E1 of
# Therneau &amp; Grambsch (T&amp;G)
tg &lt;- data.frame(illt=c(1,1,6,6,8,9),ills=c(1,0,1,1,0,1),
        dt=c(5,1,9,7,8,12),ds=c(1,1,1,1,1,1),
        x1=c(1,1,1,0,0,0),x2=c(6:1))
# data in long format using msprep
tglong &lt;- msprep(time=c(NA,"illt","dt"),status=c(NA,"ills","ds"),
        data=tg,keep=c("x1","x2"),trans=tmat)
# expanded covariates
tglong &lt;- expand.covs(tglong,c("x1","x2"))
# Cox model with different covariate
cx &lt;- coxph(Surv(Tstart,Tstop,status)~x1.1+x2.2+strata(trans),
        data=tglong,method="breslow")
# new data, to check whether results are the same for transition 1 as T&amp;G
newdata &lt;- data.frame(trans=1:3,x1.1=c(0,0,0),x2.2=c(0,1,0),strata=1:3)
fit &lt;- msfit(cx,newdata,trans=tmat)
tv &lt;- unique(fit$Haz$time)
# mssample
set.seed(1234)
mssample(Haz=fit$Haz,trans=tmat,tvec=tv,M=100)
set.seed(1234)
paths(tmat)
mssample(Haz=fit$Haz,trans=tmat,tvec=tv,M=100,output="path")
set.seed(1234)
mssample(Haz=fit$Haz,trans=tmat,tvec=tv,M=100,output="data",do.trace=25)

</code></pre>

<hr>
<h2 id='paths'>Find all possible trajectories through a given multi-state model</h2><span id='topic+paths'></span>

<h3>Description</h3>

<p>For a given multi-state model, specified through a transition matrix,
<code>paths</code> recursively finds all the possible trajectories or paths
through that multi-state starting from a specified state. DO NOT USE for
reversible or cyclic multi-state models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>paths(trans, start = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="paths_+3A_trans">trans</code></td>
<td>
<p>The transition matrix describing the multi-state model, see
<code><a href="#topic+msprep">msprep</a></code></p>
</td></tr>
<tr><td><code id="paths_+3A_start">start</code></td>
<td>
<p>The starting state for the trajectories</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function is recursive. It starts in <code>start</code>, looks at what states
can be visited from <code>start</code>, and appends the results of the next call
to the current value (matrix). If the transition matrix contains loops, the
function will find infinitely many paths, so do not use <code>paths</code> for
reversible or cyclic multi-state models. A warning is not yet incorporated!
</p>


<h3>Value</h3>

<p>A matrix, each row of which specifies a possible path through the
multi-state model.
</p>


<h3>Author(s)</h3>

<p>Hein Putter &lt;H.Putter@lumc.nl&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
tmat &lt;- matrix(NA,5,5)
tmat[1,2:3] &lt;- 1:2
tmat[1,5] &lt;- 3
tmat[2,4:5] &lt;- 4:5
tmat[3,4:5] &lt;- 6:7
tmat[4,5] &lt;- 8
paths(tmat)
paths(tmat, start=3)

</code></pre>

<hr>
<h2 id='plot.Cuminc'>Plot method for Cuminc objects</h2><span id='topic+plot.Cuminc'></span>

<h3>Description</h3>

<p>Plot the estimates of the non-parametric Aalen-Johansen estimate of the 
cumulative incidence functions (competing risks data). Note this is a method
for <code>mstate::Cuminc</code> and not <code>cmprsk::cuminc</code>. Both return the same 
estimates, though the former does so in a dataframe, and the latter in the list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Cuminc'
plot(
  x,
  use.ggplot = FALSE,
  xlab = "Time",
  ylab = "Probability",
  xlim,
  ylim,
  lty,
  legend,
  cols,
  conf.type = c("log", "plain", "none"),
  conf.int = 0.95,
  legend.pos = "right",
  facet = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.Cuminc_+3A_x">x</code></td>
<td>
<p>Object of class <code>"Cuminc"</code> to be printed or plotted</p>
</td></tr>
<tr><td><code id="plot.Cuminc_+3A_use.ggplot">use.ggplot</code></td>
<td>
<p>Default FALSE, set TRUE for ggplot version of plot</p>
</td></tr>
<tr><td><code id="plot.Cuminc_+3A_xlab">xlab</code></td>
<td>
<p>A title for the x-axis; default is <code>"Time"</code></p>
</td></tr>
<tr><td><code id="plot.Cuminc_+3A_ylab">ylab</code></td>
<td>
<p>A title for the y-axis; default is <code>"Probability"</code></p>
</td></tr>
<tr><td><code id="plot.Cuminc_+3A_xlim">xlim</code></td>
<td>
<p>The x limits of the plot(s), default is range of time</p>
</td></tr>
<tr><td><code id="plot.Cuminc_+3A_ylim">ylim</code></td>
<td>
<p>The y limits of the plot(s); if ylim is specified for
type=&quot;separate&quot;, then all plots use the same ylim for y limits</p>
</td></tr>
<tr><td><code id="plot.Cuminc_+3A_lty">lty</code></td>
<td>
<p>The line type, see <code><a href="graphics.html#topic+par">par</a></code>; default is 1</p>
</td></tr>
<tr><td><code id="plot.Cuminc_+3A_legend">legend</code></td>
<td>
<p>Character vector corresponding to number of absorbing states.
In case of a grouped <code>"Cuminc"</code> object, with facet = FALSE the 
length of the vector is number absorbing states * group levels. 
Only relevant when use.ggplot = TRUE</p>
</td></tr>
<tr><td><code id="plot.Cuminc_+3A_cols">cols</code></td>
<td>
<p>Vector (numeric or character) specifying colours of the lines</p>
</td></tr>
<tr><td><code id="plot.Cuminc_+3A_conf.type">conf.type</code></td>
<td>
<p>Type of confidence interval - either &quot;log&quot; or &quot;plain&quot; . See
function details for details.</p>
</td></tr>
<tr><td><code id="plot.Cuminc_+3A_conf.int">conf.int</code></td>
<td>
<p>Confidence level (%) from 0-1 for probabilities, 
default is 0.95 (95% CI). Setting to 0 removes the CIs.</p>
</td></tr>
<tr><td><code id="plot.Cuminc_+3A_legend.pos">legend.pos</code></td>
<td>
<p>The position of the legend, see <code><a href="graphics.html#topic+legend">legend</a></code>;
default is <code>"topleft"</code></p>
</td></tr>
<tr><td><code id="plot.Cuminc_+3A_facet">facet</code></td>
<td>
<p>Logical, in case of group used for <code>"Cuminc"</code>, facet by it - 
only relevant when use.ggplot = TRUE</p>
</td></tr>
<tr><td><code id="plot.Cuminc_+3A_...">...</code></td>
<td>
<p>Further arguments to plot or print method</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Grouped cumulative incidences can be plotted either in the same plot or in facets,
see the <code>facet</code> argument.
</p>


<h3>Value</h3>

<p>A ggplot object if use.ggplot = T used, otherwise NULL.
</p>


<h3>Author(s)</h3>

<p>Edouard F. Bonneville <a href="mailto:e.f.bonneville@lumc.nl">e.f.bonneville@lumc.nl</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(ggplot2)

data("aidssi")
head(aidssi)
si &lt;- aidssi

# No grouping
cum_incid &lt;- Cuminc(
time = "time",
status = "status",
data = si
)

plot(
x = cum_incid,
use.ggplot = TRUE,
conf.type = "none",
lty = 1:2,
conf.int = 0.95
)

# With grouping
cum_incid_grp &lt;- Cuminc(
time = "time",
status = "status",
group = "ccr5",
data = si
)

plot(
 x = cum_incid_grp,
 use.ggplot = TRUE,
 conf.type = "none",
 lty = 1:4, 
 facet = TRUE 
)
  
</code></pre>

<hr>
<h2 id='plot.MarkovTest'>Plot method for a MarkovTest object</h2><span id='topic+plot.MarkovTest'></span>

<h3>Description</h3>

<p>Plot method for an object of class 'MarkovTest'. It plots the trace of the
log-rank statistics provided by <code><a href="#topic+MarkovTest">MarkovTest</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'MarkovTest'
plot(
  x,
  y,
  what = c("states", "overall"),
  idx = NULL,
  quantiles = TRUE,
  qsup,
  states,
  xlab,
  ylab,
  main,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.MarkovTest_+3A_x">x</code></td>
<td>
<p>Object of class 'MarkovTest'</p>
</td></tr>
<tr><td><code id="plot.MarkovTest_+3A_y">y</code></td>
<td>
<p>The grid at which <code>MarkovTest</code> was calculated</p>
</td></tr>
<tr><td><code id="plot.MarkovTest_+3A_what">what</code></td>
<td>
<p>Choose &quot;states&quot; for plotting state-specific traces, and
&quot;overall&quot; for the overall chi-squared trace</p>
</td></tr>
<tr><td><code id="plot.MarkovTest_+3A_idx">idx</code></td>
<td>
<p>Vector of indices of wild bootstrap traces to plot</p>
</td></tr>
<tr><td><code id="plot.MarkovTest_+3A_quantiles">quantiles</code></td>
<td>
<p>Boolean whether or not to plot the 2.5 and 97.5 percent
quantiles, default is <code>TRUE</code></p>
</td></tr>
<tr><td><code id="plot.MarkovTest_+3A_qsup">qsup</code></td>
<td>
<p>The index of the function in either <code>fn</code> (when plotting
state-specific) or <code>fn2</code> (when plotting overall) to plot along with the
traces; when missing this line is not included</p>
</td></tr>
<tr><td><code id="plot.MarkovTest_+3A_states">states</code></td>
<td>
<p>Number of the qualifying state(s) to plot trace for</p>
</td></tr>
<tr><td><code id="plot.MarkovTest_+3A_xlab">xlab</code></td>
<td>
<p>Text for x-axis label</p>
</td></tr>
<tr><td><code id="plot.MarkovTest_+3A_ylab">ylab</code></td>
<td>
<p>Text for y-axis label</p>
</td></tr>
<tr><td><code id="plot.MarkovTest_+3A_main">main</code></td>
<td>
<p>Text for title (main)</p>
</td></tr>
<tr><td><code id="plot.MarkovTest_+3A_...">...</code></td>
<td>
<p>Further arguments to plot</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value
</p>


<h3>Author(s)</h3>

<p>Hein Putter <a href="mailto:H.Putter@lumc.nl">H.Putter@lumc.nl</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+MarkovTest">MarkovTest</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
# Example provided by the prothrombin data
data("prothr")
# Apply Markov test to grid of monthly time points over the first 7.5 years
year &lt;- 365.25
month &lt;- year / 12
grid &lt;- month * (1:90)
# Markov test for transition 1 (wild bootstrap based on 100 replications)
MT &lt;- MarkovTest(prothr, id = "id", transition = 1,
                 grid = grid, B = 100)

plot(MT, grid, what="states", idx=1:50, states=rownames(attr(prothr, "trans")),
     xlab="Days since randomisation", ylab="Log-rank test statistic",
     main="Transition Normal -&gt; Low")

plot(MT, grid,what="overall", idx=1:50,
     xlab="Days since randomisation", ylab="Chi-square test statistic",
     main="Transition Normal -&gt; Low")

plot(MT, grid, what="states", quantiles=FALSE) # only trace
plot(MT, grid, what="states") # trace plus quantiles (default)
plot(MT, grid, what="states", idx=1:10) # trace plus quantiles, plus first 10 bootstrap traces
 
plot(MT, grid, what="overall", quantiles=FALSE) # only trace
plot(MT, grid, what="overall") # trace plus quantiles (default)
plot(MT, grid, what="overall", idx=1:10) # trace plus quantiles, plus first 10 bootstrap traces


## End(Not run)

</code></pre>

<hr>
<h2 id='plot.msfit'>Plot method for an msfit object</h2><span id='topic+plot.msfit'></span>

<h3>Description</h3>

<p>Plot method for an object of class <code>"msfit"</code>. It plots the estimated
cumulative transition intensities in the multi-state model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'msfit'
plot(
  x,
  type = c("single", "separate"),
  cols,
  xlab = "Time",
  ylab = "Cumulative hazard",
  ylim,
  lwd,
  lty,
  legend,
  legend.pos = "right",
  bty = "n",
  use.ggplot = FALSE,
  xlim,
  scale_type = "fixed",
  conf.int = 0.95,
  conf.type = "none",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.msfit_+3A_x">x</code></td>
<td>
<p>Object of class <code>"msfit"</code>, containing estimated cumulative transition
intensities for all transitions in a multi-state model</p>
</td></tr>
<tr><td><code id="plot.msfit_+3A_type">type</code></td>
<td>
<p>One of <code>"single"</code> (default) or <code>"separate"</code>; in case
of <code>"single"</code>, all estimated cumulative hazards are drawn in a single
plot, in case of <code>"separate"</code>, separate plots are shown for the
estimated transition intensities</p>
</td></tr>
<tr><td><code id="plot.msfit_+3A_cols">cols</code></td>
<td>
<p>A vector specifying colors for the different transitions;
default is 1:K (K no of transitions), when type=<code>"single"</code>, and 1
(black), when type=<code>"separate"</code></p>
</td></tr>
<tr><td><code id="plot.msfit_+3A_xlab">xlab</code></td>
<td>
<p>A title for the x-axis; default is <code>"Time"</code></p>
</td></tr>
<tr><td><code id="plot.msfit_+3A_ylab">ylab</code></td>
<td>
<p>A title for the y-axis; default is <code>"Cumulative hazard"</code></p>
</td></tr>
<tr><td><code id="plot.msfit_+3A_ylim">ylim</code></td>
<td>
<p>The y limits of the plot(s); if ylim is specified for
type=&quot;separate&quot;, then all plots use the same ylim for y limits</p>
</td></tr>
<tr><td><code id="plot.msfit_+3A_lwd">lwd</code></td>
<td>
<p>The line width, see <code><a href="graphics.html#topic+par">par</a></code>; default is 1</p>
</td></tr>
<tr><td><code id="plot.msfit_+3A_lty">lty</code></td>
<td>
<p>The line type, see <code><a href="graphics.html#topic+par">par</a></code>; default is 1</p>
</td></tr>
<tr><td><code id="plot.msfit_+3A_legend">legend</code></td>
<td>
<p>Character vector of length equal to the number of transitions,
to be used in a legend; if missing, these will be taken from the row- and
column-names of the transition matrix contained in <code>x$trans</code>. Also used
as titles of plots for type=<code>"separate"</code></p>
</td></tr>
<tr><td><code id="plot.msfit_+3A_legend.pos">legend.pos</code></td>
<td>
<p>The position of the legend, see <code><a href="graphics.html#topic+legend">legend</a></code>;
default is <code>"topleft"</code></p>
</td></tr>
<tr><td><code id="plot.msfit_+3A_bty">bty</code></td>
<td>
<p>The box type of the legend, see <code><a href="graphics.html#topic+legend">legend</a></code></p>
</td></tr>
<tr><td><code id="plot.msfit_+3A_use.ggplot">use.ggplot</code></td>
<td>
<p>Default FALSE, set TRUE for ggplot version of plot</p>
</td></tr>
<tr><td><code id="plot.msfit_+3A_xlim">xlim</code></td>
<td>
<p>Limits of x axis, relevant if use_ggplot = T</p>
</td></tr>
<tr><td><code id="plot.msfit_+3A_scale_type">scale_type</code></td>
<td>
<p>&quot;fixed&quot;, &quot;free&quot;, &quot;free_x&quot; or &quot;free_y&quot;, see scales argument
of facet_wrap(). Only relevant for use_ggplot = T.</p>
</td></tr>
<tr><td><code id="plot.msfit_+3A_conf.int">conf.int</code></td>
<td>
<p>Confidence level (%) from 0-1 for the cumulative hazard, 
default is 0.95. Only relevant for use_ggplot = T</p>
</td></tr>
<tr><td><code id="plot.msfit_+3A_conf.type">conf.type</code></td>
<td>
<p>Type of confidence interval - either &quot;log&quot; or &quot;plain&quot; . See
function details of <code>plot.probtrans</code> for details</p>
</td></tr>
<tr><td><code id="plot.msfit_+3A_...">...</code></td>
<td>
<p>Further arguments to plot</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value
</p>


<h3>Author(s)</h3>

<p>Hein Putter <a href="mailto:H.Putter@lumc.nl">H.Putter@lumc.nl</a>
</p>
<p>Edouard F. Bonneville <a href="mailto:e.f.bonneville@lumc.nl">e.f.bonneville@lumc.nl</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+msfit">msfit</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# transition matrix for illness-death model
tmat &lt;- trans.illdeath()
# data in wide format, for transition 1 this is dataset E1 of
# Therneau &amp; Grambsch (2000)
tg &lt;- data.frame(illt=c(1,1,6,6,8,9),ills=c(1,0,1,1,0,1),
        dt=c(5,1,9,7,8,12),ds=c(1,1,1,1,1,1),
        x1=c(1,1,1,0,0,0),x2=c(6:1))
# data in long format using msprep
tglong &lt;- msprep(time=c(NA,"illt","dt"),status=c(NA,"ills","ds"),
		data=tg,keep=c("x1","x2"),trans=tmat)
# events
events(tglong)
table(tglong$status,tglong$to,tglong$from)
# expanded covariates
tglong &lt;- expand.covs(tglong,c("x1","x2"))
# Cox model with different covariate
cx &lt;- coxph(Surv(Tstart,Tstop,status)~x1.1+x2.2+strata(trans),
	data=tglong,method="breslow")
summary(cx)
# new data, to check whether results are the same for transition 1 as
# those in appendix E.1 of Therneau &amp; Grambsch (2000)
newdata &lt;- data.frame(trans=1:3,x1.1=c(0,0,0),x2.2=c(0,1,0),strata=1:3)
msf &lt;- msfit(cx,newdata,trans=tmat)
# standard plot
plot(msf)
# specifying line width, color, and legend
plot(msf,lwd=2,col=c("darkgreen","darkblue","darkred"),legend=c("1-&gt;2","1-&gt;3","2-&gt;3"))
# separate plots
par(mfrow=c(2,2))
plot(msf,type="separate",lwd=2)
par(mfrow=c(1,1))

# ggplot version - see vignette for details
library(ggplot2)
plot(msf, use.ggplot = TRUE)

</code></pre>

<hr>
<h2 id='plot.probtrans'>Plot method for a probtrans object</h2><span id='topic+plot.probtrans'></span>

<h3>Description</h3>

<p>Plot method for an object of class 'probtrans'. It plots the transition
probabilities as estimated by <code><a href="#topic+probtrans">probtrans</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'probtrans'
plot(
  x,
  from = 1,
  type = c("filled", "single", "separate", "stacked"),
  ord,
  cols,
  xlab = "Time",
  ylab = "Probability",
  xlim,
  ylim,
  lwd,
  lty,
  cex,
  legend,
  legend.pos = "right",
  bty = "n",
  xaxs = "i",
  yaxs = "i",
  use.ggplot = FALSE,
  conf.int = 0.95,
  conf.type = c("log", "plain", "none"),
  label,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.probtrans_+3A_x">x</code></td>
<td>
<p>Object of class 'probtrans', containing estimated transition
probabilities</p>
</td></tr>
<tr><td><code id="plot.probtrans_+3A_from">from</code></td>
<td>
<p>The starting state from which the probabilities are used to plot</p>
</td></tr>
<tr><td><code id="plot.probtrans_+3A_type">type</code></td>
<td>
<p>One of <code>"stacked"</code> (default), <code>"filled"</code>,
<code>"single"</code> or <code>"separate"</code>; in case of <code>"stacked"</code>, the
transition probabilities are stacked and the distance between two adjacent
curves indicates the probability, this is also true for <code>"filled"</code>, but
the space between adjacent curves are filled, in case of <code>"single"</code>,
the probabilities are shown as different curves in a single plot, in case of
<code>"separate"</code>, separate plots are shown for the estimated transition
probabilities</p>
</td></tr>
<tr><td><code id="plot.probtrans_+3A_ord">ord</code></td>
<td>
<p>A vector of length equal to the number of states, specifying the
order of plotting in case type=<code>"stacked"</code> or <code>"filled"</code></p>
</td></tr>
<tr><td><code id="plot.probtrans_+3A_cols">cols</code></td>
<td>
<p>A vector specifying colors for the different transitions;
default is a palette from green to red, when type=<code>"filled"</code> (reordered
according to <code>ord</code>, and 1 (black), otherwise</p>
</td></tr>
<tr><td><code id="plot.probtrans_+3A_xlab">xlab</code></td>
<td>
<p>A title for the x-axis; default is <code>"Time"</code></p>
</td></tr>
<tr><td><code id="plot.probtrans_+3A_ylab">ylab</code></td>
<td>
<p>A title for the y-axis; default is <code>"Probability"</code></p>
</td></tr>
<tr><td><code id="plot.probtrans_+3A_xlim">xlim</code></td>
<td>
<p>The x limits of the plot(s), default is range of time</p>
</td></tr>
<tr><td><code id="plot.probtrans_+3A_ylim">ylim</code></td>
<td>
<p>The y limits of the plot(s); if ylim is specified for
type=&quot;separate&quot;, then all plots use the same ylim for y limits</p>
</td></tr>
<tr><td><code id="plot.probtrans_+3A_lwd">lwd</code></td>
<td>
<p>The line width, see <code><a href="graphics.html#topic+par">par</a></code>; default is 1</p>
</td></tr>
<tr><td><code id="plot.probtrans_+3A_lty">lty</code></td>
<td>
<p>The line type, see <code><a href="graphics.html#topic+par">par</a></code>; default is 1</p>
</td></tr>
<tr><td><code id="plot.probtrans_+3A_cex">cex</code></td>
<td>
<p>Character size, used in text; only used when
type=<code>"stacked"</code> or <code>"filled"</code></p>
</td></tr>
<tr><td><code id="plot.probtrans_+3A_legend">legend</code></td>
<td>
<p>Character vector of length equal to the number of transitions,
to be used in a legend; if missing, numbers will be used; this and the
legend arguments following are ignored when type=&quot;separate&quot;</p>
</td></tr>
<tr><td><code id="plot.probtrans_+3A_legend.pos">legend.pos</code></td>
<td>
<p>The position of the legend, see <code><a href="graphics.html#topic+legend">legend</a></code>;
default is <code>"topleft"</code></p>
</td></tr>
<tr><td><code id="plot.probtrans_+3A_bty">bty</code></td>
<td>
<p>The box type of the legend, see <code><a href="graphics.html#topic+legend">legend</a></code></p>
</td></tr>
<tr><td><code id="plot.probtrans_+3A_xaxs">xaxs</code></td>
<td>
<p>See <code><a href="graphics.html#topic+par">par</a></code>, default is &quot;i&quot;, for type=<code>"stacked"</code></p>
</td></tr>
<tr><td><code id="plot.probtrans_+3A_yaxs">yaxs</code></td>
<td>
<p>See <code><a href="graphics.html#topic+par">par</a></code>, default is &quot;i&quot;, for type=<code>"stacked"</code></p>
</td></tr>
<tr><td><code id="plot.probtrans_+3A_use.ggplot">use.ggplot</code></td>
<td>
<p>Default FALSE, set TRUE for ggplot version of plot</p>
</td></tr>
<tr><td><code id="plot.probtrans_+3A_conf.int">conf.int</code></td>
<td>
<p>Confidence level (%) from 0-1 for probabilities, 
default is 0.95 (95% CI). Setting to 0 removes the CIs.</p>
</td></tr>
<tr><td><code id="plot.probtrans_+3A_conf.type">conf.type</code></td>
<td>
<p>Type of confidence interval - either &quot;log&quot; or &quot;plain&quot; . See
function details for details.</p>
</td></tr>
<tr><td><code id="plot.probtrans_+3A_label">label</code></td>
<td>
<p>Only relevant for type = &quot;filled&quot; or &quot;stacked&quot;, set to 
&quot;annotate&quot; to have state labels on plot, or leave unspecified.</p>
</td></tr>
<tr><td><code id="plot.probtrans_+3A_...">...</code></td>
<td>
<p>Further arguments to plot</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Regarding confidence intervals: let <code class="reqn">p</code> denote a predicted probability,
<code class="reqn">\sigma</code> its estimated standard error,
and <code class="reqn">z_{\alpha/2}</code> denote the critical value of the standard normal 
distribution at confidence level <code class="reqn">1 - \alpha</code>.
</p>
<p>The confidence interval of type &quot;plain&quot; is then
</p>
<p style="text-align: center;"><code class="reqn">p \pm z_{\alpha/2} * \sigma</code>
</p>

<p>The confidence interval of type &quot;log&quot;, based on the Delta method, is then
</p>
<p style="text-align: center;"><code class="reqn">\exp(\log(p) \pm z_{\alpha/2} * \sigma / p)</code>
</p>



<h3>Value</h3>

<p>No return value
</p>


<h3>Author(s)</h3>

<p>Hein Putter <a href="mailto:H.Putter@lumc.nl">H.Putter@lumc.nl</a>
</p>
<p>Edouard F. Bonneville <a href="mailto:e.f.bonneville@lumc.nl">e.f.bonneville@lumc.nl</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+probtrans">probtrans</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# transition matrix for illness-death model
tmat &lt;- trans.illdeath()
# data in wide format, for transition 1 this is dataset E1 of
# Therneau and Grambsch (2000)
tg &lt;- data.frame(illt=c(1,1,6,6,8,9),ills=c(1,0,1,1,0,1),
        dt=c(5,1,9,7,8,12),ds=c(1,1,1,1,1,1),
        x1=c(1,1,1,0,0,0),x2=c(6:1))
# data in long format using msprep
tglong &lt;- msprep(time=c(NA,"illt","dt"),status=c(NA,"ills","ds"),
		data=tg,keep=c("x1","x2"),trans=tmat)
# events
events(tglong)
table(tglong$status,tglong$to,tglong$from)
# expanded covariates
tglong &lt;- expand.covs(tglong,c("x1","x2"))
# Cox model with different covariate
cx &lt;- coxph(Surv(Tstart,Tstop,status)~x1.1+x2.2+strata(trans),
	data=tglong,method="breslow")
summary(cx)
# new data, to check whether results are the same for transition 1 as
# those in appendix E.1 of Therneau and Grambsch (2000)
newdata &lt;- data.frame(trans=1:3,x1.1=c(0,0,0),x2.2=c(0,1,0),strata=1:3)
msf &lt;- msfit(cx,newdata,trans=tmat)
# probtrans
pt &lt;- probtrans(msf,predt=0)
# default plot
plot(pt,ord=c(2,3,1),lwd=2,cex=0.75)
# filled plot
plot(pt,type="filled",ord=c(2,3,1),lwd=2,cex=0.75)
# single plot
plot(pt,type="single",lwd=2,col=rep(1,3),lty=1:3,legend.pos=c(8,1))
# separate plots
par(mfrow=c(2,2))
plot(pt,type="sep",lwd=2)
par(mfrow=c(1,1))

# ggplot version - see vignette for details
library(ggplot2)
plot(pt, ord=c(2,3,1), use.ggplot = TRUE)

</code></pre>

<hr>
<h2 id='print.MarkovTest'>Print method for a MarkovTest object</h2><span id='topic+print.MarkovTest'></span>

<h3>Description</h3>

<p>Print method for an object of class 'MarkovTest'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'MarkovTest'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.MarkovTest_+3A_x">x</code></td>
<td>
<p>Object of class 'markovTest', as obtained by call to
<code><a href="#topic+MarkovTest">MarkovTest</a></code></p>
</td></tr>
<tr><td><code id="print.MarkovTest_+3A_...">...</code></td>
<td>
<p>Further arguments to print</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value
</p>


<h3>Author(s)</h3>

<p>Hein Putter <a href="mailto:H.Putter@lumc.nl">H.Putter@lumc.nl</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+MarkovTest">MarkovTest</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
# Example provided by the prothrombin data
data("prothr")
# Apply Markov test to grid of monthly time points over the first 7.5 years
year &lt;- 365.25
month &lt;- year / 12
grid &lt;- month * (1:90)
# Markov test for transition 1 (wild bootstrap based on 25 replications for brevity)
MT &lt;- MarkovTest(prothr, id = "id", transition = 1,
                 grid = grid, B = 25)
MT

## End(Not run)

</code></pre>

<hr>
<h2 id='print.msdata'>Print method for a msdata object</h2><span id='topic+print.msdata'></span>

<h3>Description</h3>

<p>Print method for an object of class 'msdata'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'msdata'
print(x, trans = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.msdata_+3A_x">x</code></td>
<td>
<p>Object of class 'msdata', as prepared for instance by
<code><a href="#topic+msprep">msprep</a></code></p>
</td></tr>
<tr><td><code id="print.msdata_+3A_trans">trans</code></td>
<td>
<p>Boolean specifying whether or not the transition matrix should
be printed as well; default is <code>FALSE</code></p>
</td></tr>
<tr><td><code id="print.msdata_+3A_...">...</code></td>
<td>
<p>Further arguments to print</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value
</p>


<h3>Author(s)</h3>

<p>Hein Putter <a href="mailto:H.Putter@lumc.nl">H.Putter@lumc.nl</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+probtrans">probtrans</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# transition matrix for illness-death model
tmat &lt;- trans.illdeath()
# some data in wide format
tg &lt;- data.frame(stt=rep(0,6),sts=rep(0,6),
        illt=c(1,1,6,6,8,9),ills=c(1,0,1,1,0,1),
        dt=c(5,1,9,7,8,12),ds=c(1,1,1,1,1,1),
        x1=c(1,1,1,2,2,2),x2=c(6:1))
tg$x1 &lt;- factor(tg$x1,labels=c("male","female"))
tg$patid &lt;- factor(2:7,levels=1:8,labels=as.character(1:8))
# define time, status and covariates also as matrices
tt &lt;- matrix(c(rep(NA,6),tg$illt,tg$dt),6,3)
st &lt;- matrix(c(rep(NA,6),tg$ills,tg$ds),6,3)
keepmat &lt;- data.frame(gender=tg$x1,age=tg$x2)
# data in long format using msprep
msp &lt;- msprep(time=tt,status=st,trans=tmat,keep=as.matrix(keepmat))
print(msp)
print(msp, trans=TRUE)

</code></pre>

<hr>
<h2 id='print.summary.msfit'>Print method for summary.msfit object</h2><span id='topic+print.summary.msfit'></span>

<h3>Description</h3>

<p>Print method for summary.msfit object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'summary.msfit'
print(x, complete = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.summary.msfit_+3A_x">x</code></td>
<td>
<p>Object of class 'summary.msfit', to be printed</p>
</td></tr>
<tr><td><code id="print.summary.msfit_+3A_complete">complete</code></td>
<td>
<p>Whether or not the complete estimated cumulative transition
intensities should be printed (<code>TRUE</code>) or not (<code>FALSE</code>); default
is <code>FALSE</code>, in which case the estimated cumulative transition hazards
will be printed for the first and last 6 time points of each transition or
of the selected times (or all when there are at most 12 of these time points</p>
</td></tr>
<tr><td><code id="print.summary.msfit_+3A_...">...</code></td>
<td>
<p>Further arguments to print</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# If all time points should be printed, specify complete=TRUE in the print statement
print(x, complete=TRUE)

## End(Not run)

</code></pre>

<hr>
<h2 id='print.summary.probtrans'>Print method for a summary.probtrans object</h2><span id='topic+print.summary.probtrans'></span>

<h3>Description</h3>

<p>Print method for a summary.probtrans object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'summary.probtrans'
print(x, complete = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.summary.probtrans_+3A_x">x</code></td>
<td>
<p>Object of class 'summary.probtrans', to be printed</p>
</td></tr>
<tr><td><code id="print.summary.probtrans_+3A_complete">complete</code></td>
<td>
<p>Whether or not the complete estimated transition
probabilities should be printed (<code>TRUE</code>) or not (<code>FALSE</code>); default
is <code>FALSE</code>, in which case the estimated transition probilities will be
printed for the first and last 6 time points of each starting state or of
the selected times (or all when there are at most 12 of these time points</p>
</td></tr>
<tr><td><code id="print.summary.probtrans_+3A_...">...</code></td>
<td>
<p>Further arguments to print</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
# If all time points should be printed, specify complete=TRUE in the print statement
print(x, complete=TRUE)

## End(Not run)

</code></pre>

<hr>
<h2 id='probtrans'>Compute subject-specific or overall transition probabilities with standard
errors</h2><span id='topic+probtrans'></span>

<h3>Description</h3>

<p>This function computes subject-specific or overall transition probabilities
in multi-state models. If requested, also standard errors are calculated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>probtrans(
  object,
  predt,
  direction = c("forward", "fixedhorizon"),
  method = c("aalen", "greenwood"),
  variance = TRUE,
  covariance = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="probtrans_+3A_object">object</code></td>
<td>
<p><a href="#topic+msfit">msfit</a> object containing estimated cumulative hazards
for each of the transitions in the multi-state model and, if standard errors
are requested, (co)variances of these cumulative hazards for each pair of
transitions</p>
</td></tr>
<tr><td><code id="probtrans_+3A_predt">predt</code></td>
<td>
<p>A positive number indicating the prediction time. This is
either the time at which the prediction is made (if <code>direction</code>=
<code>"forward"</code>) or the time for which the prediction is to be made (if
<code>direction</code>=<code>"fixedhorizon"</code>)</p>
</td></tr>
<tr><td><code id="probtrans_+3A_direction">direction</code></td>
<td>
<p>One of <code>"forward"</code> (default) or <code>"fixedhorizon"</code>,
indicating whether prediction is forward or for a fixed horizon</p>
</td></tr>
<tr><td><code id="probtrans_+3A_method">method</code></td>
<td>
<p>A character string specifying the type of variances to be
computed (so only needed if either <code>variance</code> or <code>covariance</code> is
<code>TRUE</code>). Possible values are <code>"aalen"</code> or <code>"greenwood"</code></p>
</td></tr>
<tr><td><code id="probtrans_+3A_variance">variance</code></td>
<td>
<p>Logical value indicating whether standard errors are to be
calculated (default is <code>TRUE</code>)</p>
</td></tr>
<tr><td><code id="probtrans_+3A_covariance">covariance</code></td>
<td>
<p>Logical value indicating whether covariances of transition
probabilities for different states are to be calculated (default is
<code>FALSE</code>)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For details refer to de Wreede, Fiocco &amp; Putter (2010).
</p>


<h3>Value</h3>

<p>An object of class <code>"probtrans"</code>, which is a list of which item
[[s]] contains a data frame with the estimated transition probabilities (and
standard errors if <code>variance</code>=<code>TRUE</code>) from state s.  If
<code>covariance</code>=<code>TRUE</code>, item <code>varMatrix</code> contains an array of
dimension K^2 x K^2 x (nt+1) (with K the number of states and nt the
distinct transition time points); the time points correspond to those in the
data frames with the estimated transition probabilities.  Finally, there are
items <code>trans</code>, <code>method</code>, <code>predt</code>, <code>direction</code>, recording
the transition matrix, and the method, predt and direction arguments used in
the call to probtrans.  Plot and summary methods have been defined for
<code>"probtrans"</code> objects.
</p>


<h3>Author(s)</h3>

<p>Liesbeth de Wreede and Hein Putter <a href="mailto:H.Putter@lumc.nl">H.Putter@lumc.nl</a>
</p>


<h3>References</h3>

<p>Andersen PK, Borgan O, Gill RD, Keiding N (1993).
<em>Statistical Models Based on Counting Processes</em>. Springer, New York.
</p>
<p>Putter H, Fiocco M, Geskus RB (2007). Tutorial in biostatistics: Competing
risks and multi-state models. <em>Statistics in Medicine</em> <b>26</b>,
2389&ndash;2430.
</p>
<p>Therneau TM, Grambsch PM (2000). <em>Modeling Survival Data: Extending the
Cox Model</em>. Springer, New York.
</p>
<p>de Wreede LC, Fiocco M, and Putter H (2010). The mstate package for
estimation and prediction in non- and semi-parametric multi-state and
competing risks models. <em>Computer Methods and Programs in Biomedicine</em>
<b>99</b>, 261&ndash;274.
</p>
<p>de Wreede LC, Fiocco M, and Putter H (2011). mstate: An R Package for the
Analysis of Competing Risks and Multi-State Models. <em>Journal of
Statistical Software</em>, Volume 38, Issue 7.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# transition matrix for illness-death model
tmat &lt;- trans.illdeath()
# data in wide format, for transition 1 this is dataset E1 of
# Therneau &amp; Grambsch (2000)
tg &lt;- data.frame(illt=c(1,1,6,6,8,9),ills=c(1,0,1,1,0,1),
        dt=c(5,1,9,7,8,12),ds=c(1,1,1,1,1,1),
        x1=c(1,1,1,0,0,0),x2=c(6:1))
# data in long format using msprep
tglong &lt;- msprep(time=c(NA,"illt","dt"),status=c(NA,"ills","ds"),
		data=tg,keep=c("x1","x2"),trans=tmat)
# events
events(tglong)
table(tglong$status,tglong$to,tglong$from)
# expanded covariates
tglong &lt;- expand.covs(tglong,c("x1","x2"))
# Cox model with different covariate
cx &lt;- coxph(Surv(Tstart,Tstop,status)~x1.1+x2.2+strata(trans),
        data=tglong,method="breslow")
summary(cx)
# new data, to check whether results are the same for transition 1 as
# those in appendix E.1 of Therneau &amp; Grambsch (2000)
newdata &lt;- data.frame(trans=1:3,x1.1=c(0,0,0),x2.2=c(0,1,0),strata=1:3)
HvH &lt;- msfit(cx,newdata,trans=tmat)
# probtrans
pt &lt;- probtrans(HvH,predt=0)
# predictions from state 1
pt[[1]]

</code></pre>

<hr>
<h2 id='redrank'>Reduced rank proportional hazards model for competing risks and multi-state
models</h2><span id='topic+redrank'></span>

<h3>Description</h3>

<p>This function estimates regression coefficients in reduced rank proportional
hazards models for competing risks and multi-state models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>redrank(
  redrank,
  full = ~1,
  data,
  R,
  strata = NULL,
  Gamma.start,
  method = "breslow",
  eps = 1e-05,
  print.level = 1
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="redrank_+3A_redrank">redrank</code></td>
<td>
<p>Survival formula, starting with either Surv(time,status) ~ or
with Surv(Tstart,Tstop,status) ~, followed by a formula containing
covariates for which a reduced rank estimate is to be found</p>
</td></tr>
<tr><td><code id="redrank_+3A_full">full</code></td>
<td>
<p>Optional, formula specifying that part which needs to be
retained in the model (so not subject to reduced rank)</p>
</td></tr>
<tr><td><code id="redrank_+3A_data">data</code></td>
<td>
<p>Object of class 'msdata', as prepared for instance by
<code><a href="#topic+msprep">msprep</a></code>, in which to interpret the <code>redrank</code> and,
optionally, the <code>full</code> formulas</p>
</td></tr>
<tr><td><code id="redrank_+3A_r">R</code></td>
<td>
<p>Numeric, indicating the rank of the solution</p>
</td></tr>
<tr><td><code id="redrank_+3A_strata">strata</code></td>
<td>
<p>Name of covariate to be used inside the
<code><a href="survival.html#topic+strata">strata</a></code> part of
<code><a href="survival.html#topic+coxph">coxph</a></code></p>
</td></tr>
<tr><td><code id="redrank_+3A_gamma.start">Gamma.start</code></td>
<td>
<p>A matrix of dimension K x R, with K the number of
transitions and R the rank, to be used as starting value</p>
</td></tr>
<tr><td><code id="redrank_+3A_method">method</code></td>
<td>
<p>The method for handling ties in
<code><a href="survival.html#topic+coxph">coxph</a></code></p>
</td></tr>
<tr><td><code id="redrank_+3A_eps">eps</code></td>
<td>
<p>Numeric value determining when the iterative algorithm is
finished (when for two subsequent iterations the difference in
log-likelihood is smaller than <code>eps</code>)</p>
</td></tr>
<tr><td><code id="redrank_+3A_print.level">print.level</code></td>
<td>
<p>Determines how much output is written to the screen; 0:
no output, 1: iterations, for each iteration solutions of Alpha, Gamma,
log-likelihood, 2: also the Cox regression results</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For details refer to Fiocco, Putter &amp; van Houwelingen (2005, 2008).
</p>


<h3>Value</h3>

<p>A list with elements </p>
<table role = "presentation">
<tr><td><code>Alpha</code></td>
<td>
<p>the Alpha matrix</p>
</td></tr> <tr><td><code>Gamma</code></td>
<td>
<p>the
Gamma matrix</p>
</td></tr> <tr><td><code>Beta</code></td>
<td>
<p>the Beta matrix corresponding to
<code>covariates</code></p>
</td></tr> <tr><td><code>Beta2</code></td>
<td>
<p>the Beta matrix corresponding to
<code>fullcovs</code></p>
</td></tr> <tr><td><code>cox.itr1</code></td>
<td>
<p>the <code><a href="survival.html#topic+coxph">coxph</a></code>
object resulting from the last call giving <code>Alpha</code></p>
</td></tr> <tr><td><code>alphaX</code></td>
<td>
<p>the
matrix of prognostic scores given by <code>Alpha</code>, n x R, with n number of
subjects</p>
</td></tr> <tr><td><code>niter</code></td>
<td>
<p>the number of iterations needed to reach convergence</p>
</td></tr>
<tr><td><code>df</code></td>
<td>
<p>the number of regression parameters estimated</p>
</td></tr> <tr><td><code>loglik</code></td>
<td>
<p>the
log-likelihood</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Marta Fiocco and Hein Putter <a href="mailto:H.Putter@lumc.nl">H.Putter@lumc.nl</a>
</p>


<h3>References</h3>

<p>Fiocco M, Putter H, van Houwelingen JC (2005). Reduced rank
proportional hazards model for competing risks. <em>Biostatistics</em>
<b>6</b>, 465&ndash;478.
</p>
<p>Fiocco M, Putter H, van Houwelingen HC (2008). Reduced-rank proportional
hazards regression and simulation-based prediction for multi-state models.
<em>Statistics in Medicine</em> <b>27</b>, 4340&ndash;4358.
</p>
<p>Putter H, Fiocco M, Geskus RB (2007). Tutorial in biostatistics: Competing
risks and multi-state models. <em>Statistics in Medicine</em> <b>26</b>,
2389&ndash;2430.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
    # This reproduces the results in Fiocco, Putter &amp; van Houwelingen (2005)
    # Takes a while to run
    data(ebmt2)
    # transition matrix for competing risks
    tmat &lt;- trans.comprisk(6,names=c("Relapse","GvHD","Bacterial","Viral","Fungal","Other"))
    # preparing long dataset
    ebmt2$stat1 &lt;- as.numeric(ebmt2$status==1)
    ebmt2$stat2 &lt;- as.numeric(ebmt2$status==2)
    ebmt2$stat3 &lt;- as.numeric(ebmt2$status==3)
    ebmt2$stat4 &lt;- as.numeric(ebmt2$status==4)
    ebmt2$stat5 &lt;- as.numeric(ebmt2$status==5)
    ebmt2$stat6 &lt;- as.numeric(ebmt2$status==6)
    covs &lt;- c("dissub","match","tcd","year","age")
    ebmtlong &lt;- msprep(time=c(NA,rep("time",6)),
                       stat=c(NA,paste("stat",1:6,sep="")),
                       data=ebmt2,keep=covs,trans=tmat)

    # The reduced rank 2 solution
    rr2 &lt;- redrank(Surv(Tstart,Tstop,status) ~ dissub+match+tcd+year+age,
                   data=ebmtlong, R=2)
    rr3$Alpha; rr3$Gamma; rr3$Beta; rr3$loglik
    # The reduced rank 3 solution
    rr3 &lt;- redrank(Surv(Tstart,Tstop,status) ~ dissub+match+tcd+year+age,
                   data=ebmtlong, R=3)
    rr3$Alpha; rr3$Gamma; rr3$Beta; rr3$loglik
    # The reduced rank 3 solution, with no reduction on age
    rr3 &lt;- redrank(Surv(Tstart,Tstop,status) ~ dissub+match+tcd+year, full=~age,
                   data=ebmtlong, R=3)
    rr3$Alpha; rr3$Gamma; rr3$Beta; rr3$loglik
    # The full rank solution
    fullrank &lt;- redrank(Surv(Tstart,Tstop,status) ~ dissub+match+tcd+year+age,
                        data=ebmtlong, R=6)
    fullrank$Beta; fullrank$loglik

## End(Not run)

</code></pre>

<hr>
<h2 id='summary.Cuminc'>Summary method for a summary.Cuminc object</h2><span id='topic+summary.Cuminc'></span>

<h3>Description</h3>

<p>Summary method for a summary.Cuminc object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Cuminc'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.Cuminc_+3A_object">object</code></td>
<td>
<p>Object of class 'Cuminc', to be summarised</p>
</td></tr>
<tr><td><code id="summary.Cuminc_+3A_...">...</code></td>
<td>
<p>Further arguments to summarise</p>
</td></tr>
</table>

<hr>
<h2 id='summary.msfit'>Summary method for an msfit object</h2><span id='topic+summary.msfit'></span>

<h3>Description</h3>

<p>Summary method for an object of class 'msfit'. It prints a selection of the
estimated cumulative transition intensities, and, if requested, also of the
(co)variances.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'msfit'
summary(
  object,
  times,
  transitions,
  variance = TRUE,
  conf.int = 0.95,
  conf.type = c("log", "none", "plain"),
  extend = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.msfit_+3A_object">object</code></td>
<td>
<p>Object of class 'msfit', containing estimated cumulative
transition intensities for all transitions in a multi-state model</p>
</td></tr>
<tr><td><code id="summary.msfit_+3A_times">times</code></td>
<td>
<p>Time points at which to evaluate the cumulative transition
hazards</p>
</td></tr>
<tr><td><code id="summary.msfit_+3A_transitions">transitions</code></td>
<td>
<p>The transition for which to summarize the cumulative
transition hazards</p>
</td></tr>
<tr><td><code id="summary.msfit_+3A_variance">variance</code></td>
<td>
<p>Whether or not the standard errors of the estimated
cumulative transition intensities should be printed; default is <code>TRUE</code></p>
</td></tr>
<tr><td><code id="summary.msfit_+3A_conf.int">conf.int</code></td>
<td>
<p>The proportion to be covered by the confidence intervals,
default is 0.95</p>
</td></tr>
<tr><td><code id="summary.msfit_+3A_conf.type">conf.type</code></td>
<td>
<p>The type of confidence interval, one of &quot;log&quot;, &quot;none&quot;, or
&quot;plain&quot;. Defaults to &quot;log&quot;</p>
</td></tr>
<tr><td><code id="summary.msfit_+3A_extend">extend</code></td>
<td>
<p>logical value: if <code>TRUE</code>, prints information for all
specified times, even if there are no subjects left at the end of the
specified times. This is only valid if the times argument is present</p>
</td></tr>
<tr><td><code id="summary.msfit_+3A_...">...</code></td>
<td>
<p>Further arguments to summary</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Function <code>summary.msfit</code> returns an object of class
&quot;summary.msfit&quot;, which is a list (for each <code>from</code> state) of cumulative
transition hazaards at the specified (or all) time points. The <code>print</code>
method of a <code>summary.probtrans</code> doesn't return a value.
</p>


<h3>Author(s)</h3>

<p>Hein Putter <a href="mailto:H.Putter@lumc.nl">H.Putter@lumc.nl</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+msfit">msfit</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Start with example from msfit
tmat &lt;- trans.illdeath()
tg &lt;- data.frame(illt=c(1,1,6,6,8,9),ills=c(1,0,1,1,0,1),
                 dt=c(5,1,9,7,8,12),ds=c(1,1,1,1,1,1),
                 x1=c(1,1,1,0,0,0),x2=c(6:1))
tglong &lt;- msprep(time=c(NA,"illt","dt"),status=c(NA,"ills","ds"),
                 data=tg,keep=c("x1","x2"),trans=tmat)
tglong &lt;- expand.covs(tglong,c("x1","x2"))
cx &lt;- coxph(Surv(Tstart,Tstop,status)~x1.1+x2.2+strata(trans),
            data=tglong,method="breslow")
newdata &lt;- data.frame(trans=1:3,x1.1=c(0,0,0),x2.2=c(0,1,0),strata=1:3)
msf &lt;- msfit(cx,newdata,trans=tmat)

# Default, all transitions, with SE
summary(msf)
summary(msf, conf.type="plain")
# Only transitions 1 and 3
summary(msf, tra=c(1, 3))
# Default is 95% confidence interval, change here to 90% 
summary(msf, conf.int=0.90)
# Do not show variances (nor confidence intervals)
summary(msf, variance=FALSE)
# Cumulative hazards only at specified time points
summary(msf, times=seq(0, 15, by=3))
# Last specified time point is larger than last observed, not printed
# Use extend=TRUE as in summary.survfit
summary(msf, times=seq(0, 15, by=3), extend=TRUE)
# Different types of confidence intervals, default is log
summary(msf, times=seq(0, 15, by=3), conf.type="plain")
summary(msf, times=seq(0, 15, by=3), conf.type="no")
# When the number of time points specified is larger than 12, head and tail is shown
x &lt;- summary(msf, times=seq(5, 8, by=0.25))
x

</code></pre>

<hr>
<h2 id='summary.probtrans'>Summary method for a probtrans object</h2><span id='topic+summary.probtrans'></span>

<h3>Description</h3>

<p>Summary method for an object of class 'probtrans'. It prints a selection of
the estimated transition probabilities, and, if requested, also of the
variances.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'probtrans'
summary(
  object,
  times,
  from = 1,
  to = 0,
  variance = TRUE,
  conf.int = 0.95,
  conf.type = c("log", "none", "plain"),
  extend = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.probtrans_+3A_object">object</code></td>
<td>
<p>Object of class 'probtrans', containing estimated transition
probabilities from and to all states in a multi-state model</p>
</td></tr>
<tr><td><code id="summary.probtrans_+3A_times">times</code></td>
<td>
<p>Time points at which to evaluate the transition probabilites</p>
</td></tr>
<tr><td><code id="summary.probtrans_+3A_from">from</code></td>
<td>
<p>Specifies from which state the transition probabilities are to
be printed. Should be subset of 1:S, with S the number of states in the
multi-state model. Default is print from state 1 only. User can specify
from=0 to print transition probabilities from all states</p>
</td></tr>
<tr><td><code id="summary.probtrans_+3A_to">to</code></td>
<td>
<p>Specifies the transition probabilities to which state are to be
printed. User can specify to=0 to print transition probabilities to all
states. This is also the default</p>
</td></tr>
<tr><td><code id="summary.probtrans_+3A_variance">variance</code></td>
<td>
<p>Whether or not the standard errors of the estimated
transition probabilities should be printed; default is <code>TRUE</code></p>
</td></tr>
<tr><td><code id="summary.probtrans_+3A_conf.int">conf.int</code></td>
<td>
<p>The proportion to be covered by the confidence intervals,
default is 0.95</p>
</td></tr>
<tr><td><code id="summary.probtrans_+3A_conf.type">conf.type</code></td>
<td>
<p>The type of confidence interval, one of &quot;log&quot;, &quot;none&quot;, or
&quot;plain&quot;. Defaults to &quot;log&quot;</p>
</td></tr>
<tr><td><code id="summary.probtrans_+3A_extend">extend</code></td>
<td>
<p>logical value: if <code>TRUE</code>, prints information for all
specified times, even if there are no subjects left at the end of the
specified times. This is only valid if the times argument is present</p>
</td></tr>
<tr><td><code id="summary.probtrans_+3A_...">...</code></td>
<td>
<p>Further arguments to print</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Function <code>summary.probtrans</code> returns an object of class
&quot;summary.probtrans&quot;, which is a list (for each <code>from</code> state) of
transition probabilities at the specified (or all) time points. The
<code>print</code> method of a <code>summary.probtrans</code> doesn't return a value.
</p>


<h3>Author(s)</h3>

<p>Hein Putter <a href="mailto:H.Putter@lumc.nl">H.Putter@lumc.nl</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+probtrans">probtrans</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# First run the example of probtrans
tmat &lt;- trans.illdeath()
tg &lt;- data.frame(illt=c(1,1,6,6,8,9),ills=c(1,0,1,1,0,1),
                 dt=c(5,1,9,7,8,12),ds=c(1,1,1,1,1,1),
                 x1=c(1,1,1,0,0,0),x2=c(6:1))
tglong &lt;- msprep(time=c(NA,"illt","dt"),status=c(NA,"ills","ds"),
                 data=tg,keep=c("x1","x2"),trans=tmat)
tglong &lt;- expand.covs(tglong,c("x1","x2"))
cx &lt;- coxph(Surv(Tstart,Tstop,status)~x1.1+x2.2+strata(trans),
            data=tglong,method="breslow")
newdata &lt;- data.frame(trans=1:3,x1.1=c(0,0,0),x2.2=c(0,1,0),strata=1:3)
HvH &lt;- msfit(cx,newdata,trans=tmat)
pt &lt;- probtrans(HvH,predt=0)

# Default, prediction from state 1
summary(pt)
# Only from states 1 and 3
summary(pt, from=c(1, 3))
# Use from=0 for prediction from all states
summary(pt, from=0)
# Only to states 1 and 2
summary(pt, to=1:2)
# Default is 95% confidence interval, change here to 90% 
summary(pt, to=1:2, conf.int=0.90)
# Do not show variances (nor confidence intervals)
summary(pt, to=1:2, variance=FALSE)
# Transition probabilities only at specified time points
summary(pt, times=seq(0, 15, by=3))
# Last specified time point is larger than last observed, not printed
# Use extend=TRUE as in summary.survfit
summary(pt, times=seq(0, 15, by=3), extend=TRUE)
# Different types of confidence intervals, default is log
summary(pt, times=seq(0, 15, by=3), conf.type="plain")
summary(pt, times=seq(0, 15, by=3), conf.type="no")
# When the number of time points specified is larger than 12, head and tail is shown
x &lt;- summary(pt, times=seq(5, 8, by=0.25))
x

</code></pre>

<hr>
<h2 id='trans2tra'>Convert transition matrix from mstate to etm format</h2><span id='topic+trans2tra'></span>

<h3>Description</h3>

<p>Convert transition matrix from mstate to etm format
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trans2tra(trans)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="trans2tra_+3A_trans">trans</code></td>
<td>
<p>Transition matrix in <code>mstate</code> format</p>
</td></tr>
</table>

<hr>
<h2 id='transhelp'>Help functions for transition matrix</h2><span id='topic+transhelp'></span><span id='topic+to.trans2'></span><span id='topic+trans2Q'></span><span id='topic+absorbing'></span><span id='topic+is.circular'></span>

<h3>Description</h3>

<p>Help functions to get insight into the structure of a transition matrix.
</p>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="transhelp_+3A_trans">trans</code></td>
<td>
<p>Transition matrix, for instance produced by <code>transMat</code>),
<code>trans.comprisk</code>, or <code>trans.illdeath</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function <code>to.trans2</code> simply lists the transitions in <code>trans</code> in a
data frame; function <code>trans2Q</code> converts <code>trans</code> to a <code>Q</code>
matrix, the (j,k)th element of which contains the (shortest) number of
transitions needed to travel from the jth to the kth state; function
<code>absorbing</code> returns a vector (named if <code>trans</code> contains row or
columnc names) with the state numbers that are absorbing; function
<code>is.circular</code> returns (a Boolean) whether the transition matrix
specified in <code>trans</code> is circular or not.
</p>


<h3>Value</h3>

<p>See details.
</p>


<h3>Author(s)</h3>

<p>Hein Putter &lt;H.Putter@lumc.nl&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Irreversible illness-death model
tmat &lt;- trans.illdeath(c("Healthy", "Illness", "Death"))
tmat
to.trans2(tmat)
trans2Q(tmat)
absorbing(tmat)
is.circular(tmat)
# Reversible illness-death model
tmat &lt;- transMat(x = list( c(2, 3), c(1, 3), c() ),
                 names = c("Healthy", "Illness", "Death"))
tmat
to.trans2(tmat)
trans2Q(tmat)
absorbing(tmat)
is.circular(tmat)

</code></pre>

<hr>
<h2 id='transMat'>Define transition matrix for multi-state model</h2><span id='topic+transMat'></span><span id='topic+trans.illdeath'></span><span id='topic+trans.comprisk'></span>

<h3>Description</h3>

<p>Define transition matrices for multi-state model. Specific functions for
defining such transition matrices are pre-defined for common multi-state
models like the competing risks model and the illness-death model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>transMat(x, names)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="transMat_+3A_x">x</code></td>
<td>
<p>List of possible transitions; x[[i]] consists of a vector of state
numbers reachable from state i</p>
</td></tr>
<tr><td><code id="transMat_+3A_names">names</code></td>
<td>
<p>A character vector containing the names of either the competing
risks or the states in the multi-state model specified by the competing
risks or illness-death model. <code>names</code> should have the same length as
the list <code>x</code> (for <code>transMat</code>), or either <code>K</code> or <code>K</code>+1
(for <code>trans.comprisk</code>), or 3 (for <code>trans.illdeath</code>)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>names</code> is missing, the names <code>"eventfree"</code>, <code>"cause1"</code>,
etcetera are assigned in <code>trans.comprisk</code>, or <code>"healthy"</code>,
<code>"illness"</code>, <code>"death"</code> in <code>trans.illdeath</code>.
</p>


<h3>Value</h3>

<p>A transition matrix describing the states and transitions in the
multi-state model.
</p>


<h3>Author(s)</h3>

<p>Steven McKinney &lt;smckinney@bccrc.ca&gt;; Hein Putter
&lt;H.Putter@lumc.nl&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
transMat(list(c(2, 3), c(), c(1, 2)),
	names = c("Disease-free", "Death", "Relapsed"))
tmat &lt;- transMat(x = list( c(2, 3), c(1, 3), c() ),
                 names = c("Normal", "Low", "Death"))
tmat
transListn &lt;- list("Normal" = c(2, 3), "Low" = c(1, 3), "Death" = c())
transMat(transListn)
trans.comprisk(3)
trans.comprisk(3,c("c1","c2","c3"))
trans.comprisk(3,c("nothing","c1","c2","c3"))
trans.illdeath()
trans.illdeath(c("nothing","ill","death"))

</code></pre>

<hr>
<h2 id='varHaz.fixed'>Upgrade the varHaz object</h2><span id='topic+varHaz.fixed'></span>

<h3>Description</h3>

<p>A function that upgrades varHaz from the msfit object where the variances are
estimated using the Greenwood estimator; it is further assumed that variances for the population
hazards are equal to zero.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>varHaz.fixed(varHaz, link_trans, varHaz_original)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="varHaz.fixed_+3A_varhaz">varHaz</code></td>
<td>
<p>The varHaz object (present in a msfit object).</p>
</td></tr>
<tr><td><code id="varHaz.fixed_+3A_link_trans">link_trans</code></td>
<td>
<p>A list that gives the linkage between the original and upgraded 
transition matrix.</p>
</td></tr>
<tr><td><code id="varHaz.fixed_+3A_varhaz_original">varHaz_original</code></td>
<td>
<p>The original varHaz object from msfit (without the eventual time conversion).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Return the upgraded varHaz object containing variances for the split transitions.
</p>


<h3>Author(s)</h3>

<p>Damjan Manevski <a href="mailto:damjan.manevski@mf.uni-lj.si">damjan.manevski@mf.uni-lj.si</a>
</p>

<hr>
<h2 id='vis.mirror.pt'>Mirror plot comparing two probtrans objects</h2><span id='topic+vis.mirror.pt'></span>

<h3>Description</h3>

<p>A mirror plot for comparing two different <code>"probtrans"</code> objects. Useful
for comparing predicted probabilities for different levels of a covariate,
or for different subgroups at some prediction time horizon.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vis.mirror.pt(
  x,
  titles,
  size_titles = 5,
  horizon = NULL,
  breaks_x_left,
  breaks_x_right,
  from = 1,
  cols,
  ord,
  xlab = "Time",
  ylab = "Probability",
  legend.pos = "right"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vis.mirror.pt_+3A_x">x</code></td>
<td>
<p>A list of two <code>"probtrans"</code> objects. 
The first element will be on the left of the mirror plot, 
and the second on the right</p>
</td></tr>
<tr><td><code id="vis.mirror.pt_+3A_titles">titles</code></td>
<td>
<p>A character vector c(&quot;Title for left&quot;, &quot;Title for right&quot;)</p>
</td></tr>
<tr><td><code id="vis.mirror.pt_+3A_size_titles">size_titles</code></td>
<td>
<p>Numeric, size of the title text</p>
</td></tr>
<tr><td><code id="vis.mirror.pt_+3A_horizon">horizon</code></td>
<td>
<p>Numeric, position denoting (in time) where to symmetrically 
mirror the plots. Default is maximum follow-up of from both plots.</p>
</td></tr>
<tr><td><code id="vis.mirror.pt_+3A_breaks_x_left">breaks_x_left</code></td>
<td>
<p>Numeric vector specifying axis breaks on the left plot</p>
</td></tr>
<tr><td><code id="vis.mirror.pt_+3A_breaks_x_right">breaks_x_right</code></td>
<td>
<p>Numeric vector specifying axis breaks on the right plot</p>
</td></tr>
<tr><td><code id="vis.mirror.pt_+3A_from">from</code></td>
<td>
<p>The starting state from which the probabilities are used to plot</p>
</td></tr>
<tr><td><code id="vis.mirror.pt_+3A_cols">cols</code></td>
<td>
<p>A vector specifying colors for the different transitions;
default is a palette from green to red, when type=<code>"filled"</code> (reordered
according to <code>ord</code>, and 1 (black), otherwise</p>
</td></tr>
<tr><td><code id="vis.mirror.pt_+3A_ord">ord</code></td>
<td>
<p>A vector of length equal to the number of states, specifying the
order of plotting in case type=<code>"stacked"</code> or <code>"filled"</code></p>
</td></tr>
<tr><td><code id="vis.mirror.pt_+3A_xlab">xlab</code></td>
<td>
<p>A title for the x-axis, default is &quot;Time&quot;</p>
</td></tr>
<tr><td><code id="vis.mirror.pt_+3A_ylab">ylab</code></td>
<td>
<p>A title for the y-axis, default is &quot;Probability&quot;</p>
</td></tr>
<tr><td><code id="vis.mirror.pt_+3A_legend.pos">legend.pos</code></td>
<td>
<p>Position of the legend, default is &quot;right&quot;</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot2 object.
</p>


<h3>Author(s)</h3>

<p>Edouard F. Bonneville <a href="mailto:e.f.bonneville@lumc.nl">e.f.bonneville@lumc.nl</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.probtrans">plot.probtrans</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(ggplot2)

data("aidssi")
head(aidssi)
si &lt;- aidssi

# Prepare transition matrix
tmat &lt;- trans.comprisk(2, names = c("event-free", "AIDS", "SI"))

# Run msprep
si$stat1 &lt;- as.numeric(si$status == 1)
si$stat2 &lt;- as.numeric(si$status == 2)

silong &lt;- msprep(
time = c(NA, "time", "time"), 
status = c(NA, "stat1", "stat2"), 
data = si, keep = "ccr5", trans = tmat
)

# Run cox model
silong &lt;- expand.covs(silong, "ccr5")
c1 &lt;- coxph(Surv(time, status) ~ ccr5WM.1 + ccr5WM.2 + strata(trans),
            data = silong)
            
# 1. Prepare reference patient data - both CCR5 genotypes
WW &lt;- data.frame(
ccr5WM.1 = c(0, 0), 
ccr5WM.2 = c(0, 0), 
trans = c(1, 2), 
strata = c(1, 2)
)

WM &lt;- data.frame(
ccr5WM.1 = c(1, 0), 
ccr5WM.2 = c(0, 1),
trans = c(1, 2), 
strata = c(1, 2)
)

# 2. Make msfit objects
msf.WW &lt;- msfit(c1, WW, trans = tmat)
msf.WM &lt;- msfit(c1, WM, trans = tmat)

# 3. Make probtrans objects
pt.WW &lt;- probtrans(msf.WW, predt = 0)
pt.WM &lt;- probtrans(msf.WM, predt = 0)           

# Mirror plot split at 10 years - see vignette for more details
vis.mirror.pt(
x = list(pt.WW, pt.WM),
titles = c("WW", "WM"),
horizon = 10
)

</code></pre>

<hr>
<h2 id='vis.multiple.pt'>Visualise multiple probtrans objects</h2><span id='topic+vis.multiple.pt'></span>

<h3>Description</h3>

<p>Helper function allowing to visualise state probabilities for 
different reference patients/covariates. Multiple <code>"probtrans"</code> objects
are thus needed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vis.multiple.pt(
  x,
  from = 1,
  to,
  xlab = "Time",
  ylab = "Probability",
  xlim = NULL,
  ylim = NULL,
  cols,
  lwd,
  labels,
  conf.int = 0.95,
  conf.type = c("log", "plain", "none"),
  legend.title
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vis.multiple.pt_+3A_x">x</code></td>
<td>
<p>A list of <code>"probtrans"</code> objects</p>
</td></tr>
<tr><td><code id="vis.multiple.pt_+3A_from">from</code></td>
<td>
<p>The starting state from which the probabilities are used to plot
Numeric, as in <code>plot.probtrans</code></p>
</td></tr>
<tr><td><code id="vis.multiple.pt_+3A_to">to</code></td>
<td>
<p>(Numeric) destination state</p>
</td></tr>
<tr><td><code id="vis.multiple.pt_+3A_xlab">xlab</code></td>
<td>
<p>A title for the x-axis; default is <code>"Time"</code></p>
</td></tr>
<tr><td><code id="vis.multiple.pt_+3A_ylab">ylab</code></td>
<td>
<p>A title for the y-axis; default is <code>"Probability"</code></p>
</td></tr>
<tr><td><code id="vis.multiple.pt_+3A_xlim">xlim</code></td>
<td>
<p>The x limits of the plot(s), default is range of time</p>
</td></tr>
<tr><td><code id="vis.multiple.pt_+3A_ylim">ylim</code></td>
<td>
<p>The y limits of the plot(s); if ylim is specified for
type=&quot;separate&quot;, then all plots use the same ylim for y limits</p>
</td></tr>
<tr><td><code id="vis.multiple.pt_+3A_cols">cols</code></td>
<td>
<p>A vector specifying colors for the different transitions;
default is a palette from green to red, when type=<code>"filled"</code> (reordered
according to <code>ord</code>, and 1 (black), otherwise</p>
</td></tr>
<tr><td><code id="vis.multiple.pt_+3A_lwd">lwd</code></td>
<td>
<p>The line width, see <code><a href="graphics.html#topic+par">par</a></code>; default is 1</p>
</td></tr>
<tr><td><code id="vis.multiple.pt_+3A_labels">labels</code></td>
<td>
<p>Character vector labelling each element of x (e.g. label
for a reference patient) - so labels = c(&quot;Patient 1&quot;, &quot;Patient 2&quot;)</p>
</td></tr>
<tr><td><code id="vis.multiple.pt_+3A_conf.int">conf.int</code></td>
<td>
<p>Confidence level (%) from 0-1 for probabilities, 
default is 0.95 (95% CI). Setting to 0 removes the CIs.</p>
</td></tr>
<tr><td><code id="vis.multiple.pt_+3A_conf.type">conf.type</code></td>
<td>
<p>Type of confidence interval - either &quot;log&quot; or &quot;plain&quot; . See
function details for details.</p>
</td></tr>
<tr><td><code id="vis.multiple.pt_+3A_legend.title">legend.title</code></td>
<td>
<p>Character - title of legend</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot object.
</p>


<h3>Author(s)</h3>

<p>Edouard F. Bonneville <a href="mailto:e.f.bonneville@lumc.nl">e.f.bonneville@lumc.nl</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(ggplot2)

data("aidssi")
head(aidssi)
si &lt;- aidssi

# Prepare transition matrix
tmat &lt;- trans.comprisk(2, names = c("event-free", "AIDS", "SI"))

# Run msprep
si$stat1 &lt;- as.numeric(si$status == 1)
si$stat2 &lt;- as.numeric(si$status == 2)

silong &lt;- msprep(
time = c(NA, "time", "time"), 
status = c(NA, "stat1", "stat2"), 
data = si, keep = "ccr5", trans = tmat
)

# Run cox model
silong &lt;- expand.covs(silong, "ccr5")
c1 &lt;- coxph(Surv(time, status) ~ ccr5WM.1 + ccr5WM.2 + strata(trans),
            data = silong)
            
# 1. Prepare patient data - both CCR5 genotypes
WW &lt;- data.frame(
ccr5WM.1 = c(0, 0), 
ccr5WM.2 = c(0, 0), 
trans = c(1, 2), 
strata = c(1, 2)
)

WM &lt;- data.frame(
ccr5WM.1 = c(1, 0), 
ccr5WM.2 = c(0, 1),
trans = c(1, 2), 
strata = c(1, 2)
)

# 2. Make msfit objects
msf.WW &lt;- msfit(c1, WW, trans = tmat)
msf.WM &lt;- msfit(c1, WM, trans = tmat)

# 3. Make probtrans objects
pt.WW &lt;- probtrans(msf.WW, predt = 0)
pt.WM &lt;- probtrans(msf.WM, predt = 0)           

# Plot - see vignette for more details
vis.multiple.pt(
x = list(pt.WW, pt.WM), 
from = 1,
to = 2, 
conf.type = "log",
cols = c(1, 2),
labels = c("Pat WW", "Pat WM"),
legend.title = "Ref patients"
)

</code></pre>

<hr>
<h2 id='xsect'>Make a cross-section of multi-state data at a given time point</h2><span id='topic+xsect'></span>

<h3>Description</h3>

<p>Given a dataset in long format, for instance generated by
<code><a href="#topic+msprep">msprep</a></code>, this function takes a cross-section at a given time
point, to list the subjects under observation (at risk) at that time point
and the states currently occupied.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xsect(msdata, xtime = 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="xsect_+3A_msdata">msdata</code></td>
<td>
<p>An object of class <code>"msdata"</code>, such as output by
<code><a href="#topic+msprep">msprep</a></code></p>
</td></tr>
<tr><td><code id="xsect_+3A_xtime">xtime</code></td>
<td>
<p>The time point at which the intersection is to be made</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It is possible that subjects have moved to one of the absorbing states prior
to <code>xtime</code>; this is NOT taken into account. The function <code>xsect</code>
only concerns subjects currently (at <code>time</code>) at risk.
</p>


<h3>Value</h3>

<p>A list containing <code>idstate</code>, a data frame containing
<code>id</code>'s and <code>state</code>, the number of the state currently occupied;
<code>atrisk</code>, the number at risk, and <code>prop</code>, a table counting how
many of those at risk occupy which state.
</p>


<h3>Author(s)</h3>

<p>Hein Putter <a href="mailto:H.Putter@lumc.nl">H.Putter@lumc.nl</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
tmat &lt;- trans.illdeath(names=c("Tx","PR","RelDeath"))
data(ebmt3) # data from Section 4 of Putter, Fiocco &amp; Geskus (2007)
msebmt &lt;- msprep(time=c(NA,"prtime","rfstime"),status=c(NA,"prstat","rfsstat"),
		data=ebmt3,trans=tmat)
# At the start everyone is in state 1 (default xtime=0 is used)
xsect(msebmt)
# At 5 years
xsect(msebmt, xtime=1826)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
