<!DOCTYPE html><html><head><title>Help for package landscapemetrics</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {landscapemetrics}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#landscapemetrics'><p>landscapemetrics</p></a></li>
<li><a href='#augusta_nlcd'><p>Augusta NLCD 2011</p></a></li>
<li><a href='#calculate_correlation'><p>Calculate correlation</p></a></li>
<li><a href='#calculate_lsm'><p>calculate_lsm</p></a></li>
<li><a href='#check_landscape'><p>Check input landscape</p></a></li>
<li><a href='#construct_buffer'><p>construct_buffer</p></a></li>
<li><a href='#data_info'><p>data_info</p></a></li>
<li><a href='#extract_lsm'><p>extract_lsm</p></a></li>
<li><a href='#get_adjacencies'><p>get_adjacencies</p></a></li>
<li><a href='#get_area_patches'><p>get_area_patches</p></a></li>
<li><a href='#get_boundaries'><p>get_boundaries</p></a></li>
<li><a href='#get_centroids'><p>get_centroids</p></a></li>
<li><a href='#get_circumscribingcircle'><p>get_circumscribingcircle</p></a></li>
<li><a href='#get_class_patches'><p>get_class_patches</p></a></li>
<li><a href='#get_complexity'><p>get_complexity</p></a></li>
<li><a href='#get_enn_patch'><p>get_enn_patch</p></a></li>
<li><a href='#get_nearestneighbour'><p>get_nearestneighbour</p></a></li>
<li><a href='#get_patches'><p>get_patches</p></a></li>
<li><a href='#get_perimeter_patch'><p>get_perimeter_patch</p></a></li>
<li><a href='#get_points'><p>get_points</p></a></li>
<li><a href='#get_unique_values'><p>get_unique_values</p></a></li>
<li><a href='#landscape'><p>Example map (random cluster neutral landscape model).</p></a></li>
<li><a href='#landscape_as_list'><p>Landscape as list</p></a></li>
<li><a href='#list_lsm'><p>List landscape metrics</p></a></li>
<li><a href='#lsm_abbreviations_names'><p>Tibble of abbreviations coming from FRAGSTATS</p></a></li>
<li><a href='#lsm_c_ai'><p>AI (class level)</p></a></li>
<li><a href='#lsm_c_area_cv'><p>AREA_CV (class level)</p></a></li>
<li><a href='#lsm_c_area_mn'><p>AREA_MN (class level)</p></a></li>
<li><a href='#lsm_c_area_sd'><p>AREA_SD (class level)</p></a></li>
<li><a href='#lsm_c_ca'><p>CA (class level)</p></a></li>
<li><a href='#lsm_c_cai_cv'><p>CAI_CV (class level)</p></a></li>
<li><a href='#lsm_c_cai_mn'><p>CAI_MN (class level)</p></a></li>
<li><a href='#lsm_c_cai_sd'><p>CAI_SD (class level)</p></a></li>
<li><a href='#lsm_c_circle_cv'><p>CIRCLE_CV (Class level)</p></a></li>
<li><a href='#lsm_c_circle_mn'><p>CIRCLE_MN (Class level)</p></a></li>
<li><a href='#lsm_c_circle_sd'><p>CIRCLE_SD (Class level)</p></a></li>
<li><a href='#lsm_c_clumpy'><p>CLUMPY (class level)</p></a></li>
<li><a href='#lsm_c_cohesion'><p>COHESION (class level)</p></a></li>
<li><a href='#lsm_c_contig_cv'><p>CONTIG_CV (class level)</p></a></li>
<li><a href='#lsm_c_contig_mn'><p>CONTIG_MN (class level)</p></a></li>
<li><a href='#lsm_c_contig_sd'><p>CONTIG_SD (class level)</p></a></li>
<li><a href='#lsm_c_core_cv'><p>CORE_CV (class level)</p></a></li>
<li><a href='#lsm_c_core_mn'><p>CORE_MN (class level)</p></a></li>
<li><a href='#lsm_c_core_sd'><p>CORE_SD (class level)</p></a></li>
<li><a href='#lsm_c_cpland'><p>CPLAND (class level)</p></a></li>
<li><a href='#lsm_c_dcad'><p>DCAD (class level)</p></a></li>
<li><a href='#lsm_c_dcore_cv'><p>DCORE_CV (class level)</p></a></li>
<li><a href='#lsm_c_dcore_mn'><p>DCORE_MN (class level)</p></a></li>
<li><a href='#lsm_c_dcore_sd'><p>DCORE_SD (class level)</p></a></li>
<li><a href='#lsm_c_division'><p>DIVISION (class level)</p></a></li>
<li><a href='#lsm_c_ed'><p>ED (class level)</p></a></li>
<li><a href='#lsm_c_enn_cv'><p>ENN_CV (class level)</p></a></li>
<li><a href='#lsm_c_enn_mn'><p>ENN_MN (class level)</p></a></li>
<li><a href='#lsm_c_enn_sd'><p>ENN_SD (class level)</p></a></li>
<li><a href='#lsm_c_frac_cv'><p>FRAC_CV (class level)</p></a></li>
<li><a href='#lsm_c_frac_mn'><p>FRAC_MN (class level)</p></a></li>
<li><a href='#lsm_c_frac_sd'><p>FRAC_SD (class level)</p></a></li>
<li><a href='#lsm_c_gyrate_cv'><p>GYRATE_CV (class level)</p></a></li>
<li><a href='#lsm_c_gyrate_mn'><p>GYRATE_MN (class level)</p></a></li>
<li><a href='#lsm_c_gyrate_sd'><p>GYRATE_SD (class level)</p></a></li>
<li><a href='#lsm_c_iji'><p>Interspersion and Juxtaposition index (class level)</p></a></li>
<li><a href='#lsm_c_lpi'><p>LPI (class level)</p></a></li>
<li><a href='#lsm_c_lsi'><p>LSI (class level)</p></a></li>
<li><a href='#lsm_c_mesh'><p>MESH (class level)</p></a></li>
<li><a href='#lsm_c_ndca'><p>NDCA (class level)</p></a></li>
<li><a href='#lsm_c_nlsi'><p>nLSI (class level)</p></a></li>
<li><a href='#lsm_c_np'><p>NP (class level)</p></a></li>
<li><a href='#lsm_c_pafrac'><p>PAFRAC  (class level)</p></a></li>
<li><a href='#lsm_c_para_cv'><p>PARA_CV (class level)</p></a></li>
<li><a href='#lsm_c_para_mn'><p>PARA_MN (class level)</p></a></li>
<li><a href='#lsm_c_para_sd'><p>PARA_SD (class level)</p></a></li>
<li><a href='#lsm_c_pd'><p>PD (class level)</p></a></li>
<li><a href='#lsm_c_pladj'><p>PLADJ (class level)</p></a></li>
<li><a href='#lsm_c_pland'><p>PLAND (class level)</p></a></li>
<li><a href='#lsm_c_shape_cv'><p>SHAPE_CV (class level)</p></a></li>
<li><a href='#lsm_c_shape_mn'><p>SHAPE_MN (class level)</p></a></li>
<li><a href='#lsm_c_shape_sd'><p>SHAPE_SD (class level)</p></a></li>
<li><a href='#lsm_c_split'><p>SPLIT (class level)</p></a></li>
<li><a href='#lsm_c_tca'><p>TCA (class level)</p></a></li>
<li><a href='#lsm_c_te'><p>TE (class level)</p></a></li>
<li><a href='#lsm_l_ai'><p>AI (landscape level)</p></a></li>
<li><a href='#lsm_l_area_cv'><p>AREA_CV (landscape level)</p></a></li>
<li><a href='#lsm_l_area_mn'><p>AREA_MN (landscape level)</p></a></li>
<li><a href='#lsm_l_area_sd'><p>AREA_SD (landscape level)</p></a></li>
<li><a href='#lsm_l_cai_cv'><p>CAI_CV (landscape level)</p></a></li>
<li><a href='#lsm_l_cai_mn'><p>CAI_MN (landscape level)</p></a></li>
<li><a href='#lsm_l_cai_sd'><p>CAI_SD (landscape level)</p></a></li>
<li><a href='#lsm_l_circle_cv'><p>CIRCLE_CV (landscape level)</p></a></li>
<li><a href='#lsm_l_circle_mn'><p>CIRCLE_MN (landscape level)</p></a></li>
<li><a href='#lsm_l_circle_sd'><p>CIRCLE_SD (landscape level)</p></a></li>
<li><a href='#lsm_l_cohesion'><p>COHESION (landscape level)</p></a></li>
<li><a href='#lsm_l_condent'><p>Conditional entropy (landscape level)</p></a></li>
<li><a href='#lsm_l_contag'><p>CONTAG (landscape level)</p></a></li>
<li><a href='#lsm_l_contig_cv'><p>CONTIG_CV (landscape level)</p></a></li>
<li><a href='#lsm_l_contig_mn'><p>CONTIG_MN (landscape level)</p></a></li>
<li><a href='#lsm_l_contig_sd'><p>CONTIG_SD (landscape level)</p></a></li>
<li><a href='#lsm_l_core_cv'><p>CORE_CV (landscape level)</p></a></li>
<li><a href='#lsm_l_core_mn'><p>CORE_MN (landscape level)</p></a></li>
<li><a href='#lsm_l_core_sd'><p>CORE_SD (landscape level)</p></a></li>
<li><a href='#lsm_l_dcad'><p>DCAD (landscape level)</p></a></li>
<li><a href='#lsm_l_dcore_cv'><p>DCORE_CV (landscape level)</p></a></li>
<li><a href='#lsm_l_dcore_mn'><p>DCORE_MN (landscape level)</p></a></li>
<li><a href='#lsm_l_dcore_sd'><p>DCORE_SD (landscape level)</p></a></li>
<li><a href='#lsm_l_division'><p>DIVISION (landscape level)</p></a></li>
<li><a href='#lsm_l_ed'><p>ED (landscape level)</p></a></li>
<li><a href='#lsm_l_enn_cv'><p>ENN_CV (landscape level)</p></a></li>
<li><a href='#lsm_l_enn_mn'><p>ENN_MN (landscape level)</p></a></li>
<li><a href='#lsm_l_enn_sd'><p>ENN_SD (landscape level)</p></a></li>
<li><a href='#lsm_l_ent'><p>ENT (landscape level)</p></a></li>
<li><a href='#lsm_l_frac_cv'><p>FRAC_CV (landscape level)</p></a></li>
<li><a href='#lsm_l_frac_mn'><p>FRAC_MN (landscape level)</p></a></li>
<li><a href='#lsm_l_frac_sd'><p>FRAC_SD (landscape level)</p></a></li>
<li><a href='#lsm_l_gyrate_cv'><p>GYRATE_CV (landscape level)</p></a></li>
<li><a href='#lsm_l_gyrate_mn'><p>GYRATE_MN (landscape level)</p></a></li>
<li><a href='#lsm_l_gyrate_sd'><p>GYRATE_SD (landscape level)</p></a></li>
<li><a href='#lsm_l_iji'><p>Interspersion and Juxtaposition index (landscape level)</p></a></li>
<li><a href='#lsm_l_joinent'><p>JOINENT (landscape level)</p></a></li>
<li><a href='#lsm_l_lpi'><p>LPI (landscape level)</p></a></li>
<li><a href='#lsm_l_lsi'><p>LSI (landscape level)</p></a></li>
<li><a href='#lsm_l_mesh'><p>MESH (landscape level)</p></a></li>
<li><a href='#lsm_l_msidi'><p>MSIDI (landscape level)</p></a></li>
<li><a href='#lsm_l_msiei'><p>MSIEI (landscape level)</p></a></li>
<li><a href='#lsm_l_mutinf'><p>MUTINF (landscape level)</p></a></li>
<li><a href='#lsm_l_ndca'><p>NDCA (landscape level)</p></a></li>
<li><a href='#lsm_l_np'><p>NP (landscape level)</p></a></li>
<li><a href='#lsm_l_pafrac'><p>PAFRAC  (landscape level)</p></a></li>
<li><a href='#lsm_l_para_cv'><p>PARA_CV (landscape level)</p></a></li>
<li><a href='#lsm_l_para_mn'><p>PARA_MN (landscape level)</p></a></li>
<li><a href='#lsm_l_para_sd'><p>PARA_SD (landscape level)</p></a></li>
<li><a href='#lsm_l_pd'><p>PD (landscape level)</p></a></li>
<li><a href='#lsm_l_pladj'><p>PLADJ (landscape level)</p></a></li>
<li><a href='#lsm_l_pr'><p>PR (landscape level)</p></a></li>
<li><a href='#lsm_l_prd'><p>PRD (landscape level)</p></a></li>
<li><a href='#lsm_l_relmutinf'><p>RELMUTINF (landscape level)</p></a></li>
<li><a href='#lsm_l_rpr'><p>RPD (landscape level)</p></a></li>
<li><a href='#lsm_l_shape_cv'><p>SHAPE_CV (landscape level)</p></a></li>
<li><a href='#lsm_l_shape_mn'><p>SHAPE_MN (landscape level)</p></a></li>
<li><a href='#lsm_l_shape_sd'><p>SHAPE_SD (landscape level)</p></a></li>
<li><a href='#lsm_l_shdi'><p>SHDI (landscape level)</p></a></li>
<li><a href='#lsm_l_shei'><p>SHEI (landscape level)</p></a></li>
<li><a href='#lsm_l_sidi'><p>SIDI (landscape level)</p></a></li>
<li><a href='#lsm_l_siei'><p>SIEI (landscape level)</p></a></li>
<li><a href='#lsm_l_split'><p>SPLIT (landscape level)</p></a></li>
<li><a href='#lsm_l_ta'><p>TA (landscape level)</p></a></li>
<li><a href='#lsm_l_tca'><p>TCA (landscape level)</p></a></li>
<li><a href='#lsm_l_te'><p>TE (landscape level)</p></a></li>
<li><a href='#lsm_p_area'><p>AREA (patch level)</p></a></li>
<li><a href='#lsm_p_cai'><p>CAI (patch level)</p></a></li>
<li><a href='#lsm_p_circle'><p>CIRCLE (patch level)</p></a></li>
<li><a href='#lsm_p_contig'><p>CONTIG (patch level)</p></a></li>
<li><a href='#lsm_p_core'><p>CORE (patch level)</p></a></li>
<li><a href='#lsm_p_enn'><p>ENN (patch level)</p></a></li>
<li><a href='#lsm_p_frac'><p>FRAC (patch level)</p></a></li>
<li><a href='#lsm_p_gyrate'><p>GYRATE (patch level)</p></a></li>
<li><a href='#lsm_p_ncore'><p>NCORE (patch level)</p></a></li>
<li><a href='#lsm_p_para'><p>PARA (patch level)</p></a></li>
<li><a href='#lsm_p_perim'><p>PERIM (patch level)</p></a></li>
<li><a href='#lsm_p_shape'><p>SHAPE (patch level)</p></a></li>
<li><a href='#matrix_to_raster'><p>matrix_to_raster</p></a></li>
<li><a href='#options_landscapemetrics'><p>options_landscapemetrics</p></a></li>
<li><a href='#pad_raster'><p>pad_raster</p></a></li>
<li><a href='#podlasie_ccilc'><p>Podlasie ESA CCI LC</p></a></li>
<li><a href='#points_as_mat'><p>points_as_mat</p></a></li>
<li><a href='#prepare_extras'><p>prepare_extras</p></a></li>
<li><a href='#proj_info'><p>proj_info</p></a></li>
<li><a href='#raster_to_points'><p>raster_to_points</p></a></li>
<li><a href='#rcpp_cell_from_xy'><p>Get cell number</p></a></li>
<li><a href='#rcpp_create_neighborhood'><p>Create neighborhood coordinates</p></a></li>
<li><a href='#rcpp_get_nearest_neighbor'><p>First nearest neighbor distance</p></a></li>
<li><a href='#rcpp_xy_from_matrix'><p>Coordinates from a matrix</p></a></li>
<li><a href='#sample_lsm'><p>sample_lsm</p></a></li>
<li><a href='#show_cores'><p>Show core area</p></a></li>
<li><a href='#show_correlation'><p>Show correlation</p></a></li>
<li><a href='#show_lsm'><p>Show landscape metrics</p></a></li>
<li><a href='#show_patches'><p>Show patches</p></a></li>
<li><a href='#spatialize_lsm'><p>spatialize_lsm</p></a></li>
<li><a href='#unpad_raster'><p>unpad_raster</p></a></li>
<li><a href='#window_lsm'><p>window_lsm</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Landscape Metrics for Categorical Map Patterns</td>
</tr>
<tr>
<td>Version:</td>
<td>2.1.3</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Maximilian H.K. Hesselbarth &lt;mhk.hesselbarth@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Calculates landscape metrics for categorical landscape patterns in 
    a tidy workflow. 'landscapemetrics' reimplements the most common metrics from
    'FRAGSTATS' (<a href="https://www.fragstats.org/">https://www.fragstats.org/</a>) and new ones from the current 
    literature on landscape metrics. This package supports 'terra' SpatRaster objects 
    as input arguments. It further provides utility functions to visualize patches, 
    select metrics and building blocks to develop new metrics.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://r-spatialecology.github.io/landscapemetrics/">https://r-spatialecology.github.io/landscapemetrics/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/r-spatialecology/landscapemetrics/issues">https://github.com/r-spatialecology/landscapemetrics/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.6)</td>
</tr>
<tr>
<td>Imports:</td>
<td>cli, ggplot2, methods, Rcpp (&ge; 0.11.0), stats, terra, tibble</td>
</tr>
<tr>
<td>Suggests:</td>
<td>covr, dplyr, knitr, raster, rmarkdown, sf, sp, stars,
stringr, testthat, tidyr</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>ByteCompile:</td>
<td>true</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-06-26 12:45:40 UTC; mhesselbarth</td>
</tr>
<tr>
<td>Author:</td>
<td>Maximilian H.K. Hesselbarth
    <a href="https://orcid.org/0000-0003-1125-9918"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre],
  Marco Sciaini <a href="https://orcid.org/0000-0002-3042-5435"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Jakub Nowosad <a href="https://orcid.org/0000-0002-1057-3721"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Sebastian Hanss <a href="https://orcid.org/0000-0002-3990-4897"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Laura J. Graham [ctb] (Input on package structure),
  Jeffrey Hollister [ctb] (Input on package structure),
  Kimberly A. With [ctb] (Input on package structure),
  Florian Privé [ctb] (Original author of underlying C++ code for
    get_nearestneighbour() function),
  Project Nayuki [ctb] (Original author of underlying C++ code for
    get_circumscribingcircle and lsm_p_circle),
  Matt Strimas-Mackey [ctb] (Bugfix in sample_metrics())</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-06-26 13:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='landscapemetrics'>landscapemetrics</h2><span id='topic+landscapemetrics-package'></span><span id='topic+landscapemetrics'></span>

<h3>Description</h3>

<p>Calculates landscape metrics for categorical landscape patterns in a tidy workflow.
'landscapemetrics' reimplements the most common metrics from 'FRAGSTATS' (<a href="https://www.fragstats.org/">https://www.fragstats.org/</a>)
and adds new ones from the current literature on landscape metrics. This package
supports 'terra' SpatRaster objects as input arguments. It further provides
utility functions to visualize patches, select metrics and building blocks to
develop new metrics.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Maximilian H.K. Hesselbarth <a href="mailto:mhk.hesselbarth@gmail.com">mhk.hesselbarth@gmail.com</a> (<a href="https://orcid.org/0000-0003-1125-9918">ORCID</a>)
</p>
<p>Authors:
</p>

<ul>
<li><p> Marco Sciaini <a href="mailto:sciaini.marco@gmail.com">sciaini.marco@gmail.com</a> (<a href="https://orcid.org/0000-0002-3042-5435">ORCID</a>)
</p>
</li>
<li><p> Jakub Nowosad <a href="mailto:nowosad.jakub@gmail.com">nowosad.jakub@gmail.com</a> (<a href="https://orcid.org/0000-0002-1057-3721">ORCID</a>)
</p>
</li>
<li><p> Sebastian Hanss (<a href="https://orcid.org/0000-0002-3990-4897">ORCID</a>)
</p>
</li></ul>

<p>Other contributors:
</p>

<ul>
<li><p> Laura J. Graham (Input on package structure) [contributor]
</p>
</li>
<li><p> Jeffrey Hollister (Input on package structure) [contributor]
</p>
</li>
<li><p> Kimberly A. With (Input on package structure) [contributor]
</p>
</li>
<li><p> Florian Privé (Original author of underlying C++ code for get_nearestneighbour() function) [contributor]
</p>
</li>
<li><p> Project Nayuki (Original author of underlying C++ code for get_circumscribingcircle and lsm_p_circle) [contributor]
</p>
</li>
<li><p> Matt Strimas-Mackey (Bugfix in sample_metrics()) [contributor]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://r-spatialecology.github.io/landscapemetrics/">https://r-spatialecology.github.io/landscapemetrics/</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/r-spatialecology/landscapemetrics/issues">https://github.com/r-spatialecology/landscapemetrics/issues</a>
</p>
</li></ul>


<hr>
<h2 id='augusta_nlcd'>Augusta NLCD 2011</h2><span id='topic+augusta_nlcd'></span>

<h3>Description</h3>

<p>A real landscape of area near Augusta, Georgia obtained from the National
Land Cover Database (NLCD)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>augusta_nlcd
</code></pre>


<h3>Format</h3>

<p>A raster object.
</p>


<h3>Source</h3>

<p>https://www.mrlc.gov/nlcd2011.php
</p>


<h3>References</h3>

<p>Homer, C.G., Dewitz, J.A., Yang, L., Jin, S., Danielson, P., Xian, G., Coulston, J., Herold, N.D., Wickham, J.D., and Megown, K., 2015, Completion of the 2011 National Land Cover Database for the conterminous United States-Representing a decade of land cover change information. Photogrammetric Engineering and Remote Sensing, v. 81, no. 5, p. 345-354
</p>

<hr>
<h2 id='calculate_correlation'>Calculate correlation</h2><span id='topic+calculate_correlation'></span>

<h3>Description</h3>

<p>Calculate correlation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculate_correlation(
  metrics,
  method = "pearson",
  diag = TRUE,
  simplify = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calculate_correlation_+3A_metrics">metrics</code></td>
<td>
<p>Tibble with results of as returned by the landscapemetrics package.</p>
</td></tr>
<tr><td><code id="calculate_correlation_+3A_method">method</code></td>
<td>
<p>Type of correlation. See <code>link{cor}</code> for details.</p>
</td></tr>
<tr><td><code id="calculate_correlation_+3A_diag">diag</code></td>
<td>
<p>If FALSE, values on the diagonal will be NA.</p>
</td></tr>
<tr><td><code id="calculate_correlation_+3A_simplify">simplify</code></td>
<td>
<p>If TRUE and only one level is present, only a tibble is returned.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The functions calculates the correlation between all metrics. In order to calculate correlations,
for the landscape level more than one landscape needs to be present. All input
must be structured as returned by the <strong>landscapemetrics</strong> package.
</p>


<h3>Value</h3>

<p>list
</p>


<h3>Examples</h3>

<pre><code class='language-R'>landscape &lt;- terra::rast(landscapemetrics::landscape)
metrics &lt;- calculate_lsm(landscape, what = c("patch", "class"))
calculate_correlation(metrics, method = "pearson")

</code></pre>

<hr>
<h2 id='calculate_lsm'>calculate_lsm</h2><span id='topic+calculate_lsm'></span>

<h3>Description</h3>

<p>Calculate a selected group of metrics
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculate_lsm(
  landscape,
  level = NULL,
  metric = NULL,
  name = NULL,
  type = NULL,
  what = NULL,
  directions = 8,
  count_boundary = FALSE,
  consider_boundary = FALSE,
  edge_depth = 1,
  cell_center = FALSE,
  classes_max = NULL,
  neighbourhood = 4,
  ordered = TRUE,
  base = "log2",
  full_name = FALSE,
  verbose = TRUE,
  progress = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calculate_lsm_+3A_landscape">landscape</code></td>
<td>
<p>A categorical raster object: SpatRaster; Raster* Layer, Stack, Brick; stars or a list of SpatRasters.</p>
</td></tr>
<tr><td><code id="calculate_lsm_+3A_level">level</code></td>
<td>
<p>Level of metrics. Either 'patch', 'class' or 'landscape' (or vector with combination).</p>
</td></tr>
<tr><td><code id="calculate_lsm_+3A_metric">metric</code></td>
<td>
<p>Abbreviation of metrics (e.g. 'area').</p>
</td></tr>
<tr><td><code id="calculate_lsm_+3A_name">name</code></td>
<td>
<p>Full name of metrics (e.g. 'core area').</p>
</td></tr>
<tr><td><code id="calculate_lsm_+3A_type">type</code></td>
<td>
<p>Type according to FRAGSTATS grouping (e.g. 'aggregation metrics').</p>
</td></tr>
<tr><td><code id="calculate_lsm_+3A_what">what</code></td>
<td>
<p>Selected level of metrics: either &quot;patch&quot;, &quot;class&quot; or &quot;landscape&quot;.
It is also possible to specify functions as a vector of strings, e.g. <code>what = c("lsm_c_ca", "lsm_l_ta")</code>.</p>
</td></tr>
<tr><td><code id="calculate_lsm_+3A_directions">directions</code></td>
<td>
<p>The number of directions in which patches should be
connected: 4 (rook's case) or 8 (queen's case).</p>
</td></tr>
<tr><td><code id="calculate_lsm_+3A_count_boundary">count_boundary</code></td>
<td>
<p>Include landscape boundary in edge length.</p>
</td></tr>
<tr><td><code id="calculate_lsm_+3A_consider_boundary">consider_boundary</code></td>
<td>
<p>Logical if cells that only neighbour the landscape
boundary should be considered as core.</p>
</td></tr>
<tr><td><code id="calculate_lsm_+3A_edge_depth">edge_depth</code></td>
<td>
<p>Distance (in cells) a cell has to be away from the patch
edge to be considered as core cell.</p>
</td></tr>
<tr><td><code id="calculate_lsm_+3A_cell_center">cell_center</code></td>
<td>
<p>If true, the coordinates of the centroid are forced to be
a cell center within the patch.</p>
</td></tr>
<tr><td><code id="calculate_lsm_+3A_classes_max">classes_max</code></td>
<td>
<p>Potential maximum number of present classes.</p>
</td></tr>
<tr><td><code id="calculate_lsm_+3A_neighbourhood">neighbourhood</code></td>
<td>
<p>The number of directions in which cell adjacencies are considered as neighbours:
4 (rook's case) or 8 (queen's case). The default is 4.</p>
</td></tr>
<tr><td><code id="calculate_lsm_+3A_ordered">ordered</code></td>
<td>
<p>The type of pairs considered. Either ordered (TRUE) or unordered (FALSE).
The default is TRUE.</p>
</td></tr>
<tr><td><code id="calculate_lsm_+3A_base">base</code></td>
<td>
<p>The unit in which entropy is measured. The default is &quot;log2&quot;,
which compute entropy in &quot;bits&quot;. &quot;log&quot; and &quot;log10&quot; can be also used.</p>
</td></tr>
<tr><td><code id="calculate_lsm_+3A_full_name">full_name</code></td>
<td>
<p>Should the full names of all functions be included in the
tibble.</p>
</td></tr>
<tr><td><code id="calculate_lsm_+3A_verbose">verbose</code></td>
<td>
<p>Print warning messages.</p>
</td></tr>
<tr><td><code id="calculate_lsm_+3A_progress">progress</code></td>
<td>
<p>Print progress report.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Wrapper to calculate several landscape metrics. The metrics can be specified
by the arguments <code>what</code>, <code>level</code>, <code>metric</code>, <code>name</code> and/or <code>type</code> (combinations
of different arguments are possible (e.g. <code style="white-space: pre;">&#8288;level = "class", type = "aggregation metric"&#8288;</code>).
If an argument is not provided, automatically all possibilities are
selected. Therefore, to get <strong>all</strong> available metrics, don't specify any of the
above arguments.
</p>
<p>For all metrics based on distances or areas please make sure your data is valid
using <code><a href="#topic+check_landscape">check_landscape</a></code>.
</p>


<h3>Value</h3>

<p>tibble
</p>


<h3>References</h3>

<p>McGarigal K., SA Cushman, and E Ene. 2023. FRAGSTATS v4: Spatial Pattern Analysis
Program for Categorical Maps. Computer software program produced by the authors;
available at the following web site: https://www.fragstats.org
</p>


<h3>See Also</h3>

<p><code><a href="#topic+list_lsm">list_lsm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
landscape &lt;- terra::rast(landscapemetrics::landscape)
calculate_lsm(landscape, progress = TRUE)
calculate_lsm(landscape, what = c("patch", "lsm_c_te", "lsm_l_pr"))
calculate_lsm(landscape, level = c("class", "landscape"),
type = "aggregation metric")

## End(Not run)

</code></pre>

<hr>
<h2 id='check_landscape'>Check input landscape</h2><span id='topic+check_landscape'></span>

<h3>Description</h3>

<p>Check input landscape
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_landscape(landscape, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_landscape_+3A_landscape">landscape</code></td>
<td>
<p>Raster* Layer, Stack, Brick, Stars or a list of rasterLayers</p>
</td></tr>
<tr><td><code id="check_landscape_+3A_verbose">verbose</code></td>
<td>
<p>Print warning messages.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function extracts basic information about
the input landscape.
It includes a type of coordinate reference system (crs) -
either &quot;geographic&quot;, &quot;projected&quot;, or NA,
units of the coordinate reference system, a class of the input landscape's
values and the number of classes found in the landscape.
</p>


<h3>Value</h3>

<p>tibble
</p>


<h3>Examples</h3>

<pre><code class='language-R'>augusta_nlcd &lt;- terra::rast(landscapemetrics::augusta_nlcd)
check_landscape(augusta_nlcd)
podlasie_ccilc &lt;- terra::rast(landscapemetrics::podlasie_ccilc)
check_landscape(podlasie_ccilc)
landscape &lt;- terra::rast(landscapemetrics::landscape)
check_landscape(c(landscape, landscape))

</code></pre>

<hr>
<h2 id='construct_buffer'>construct_buffer</h2><span id='topic+construct_buffer'></span>

<h3>Description</h3>

<p>Internal function to construct plot area around coordinates
</p>


<h3>Usage</h3>

<pre><code class='language-R'>construct_buffer(
  coords,
  shape,
  size,
  return_vec = TRUE,
  crs = "",
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="construct_buffer_+3A_coords">coords</code></td>
<td>
<p>SpatVector, sf object or 2-column matrix with coordinates of sample points</p>
</td></tr>
<tr><td><code id="construct_buffer_+3A_shape">shape</code></td>
<td>
<p>String specifying plot shape. Either &quot;circle&quot; or &quot;square&quot;</p>
</td></tr>
<tr><td><code id="construct_buffer_+3A_size">size</code></td>
<td>
<p>Size of sample plot. Equals the radius for circles or the
side-length for squares in map units</p>
</td></tr>
<tr><td><code id="construct_buffer_+3A_return_vec">return_vec</code></td>
<td>
<p>If TRUE, vector objects are returned.</p>
</td></tr>
<tr><td><code id="construct_buffer_+3A_crs">crs</code></td>
<td>
<p>The coordinate reference system used for vector objects.</p>
</td></tr>
<tr><td><code id="construct_buffer_+3A_verbose">verbose</code></td>
<td>
<p>Print warning messages.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix or SpatVector object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>coords &lt;- matrix(c(10, 5, 25, 15, 5, 25), ncol = 2, byrow = TRUE)
construct_buffer(coords = coords, shape = "square", size = 5)

</code></pre>

<hr>
<h2 id='data_info'>data_info</h2><span id='topic+data_info'></span>

<h3>Description</h3>

<p>Data info
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data_info(landscape)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="data_info_+3A_landscape">landscape</code></td>
<td>
<p>RasterLayer</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Check class of raster values and number of classes
</p>


<h3>Value</h3>

<p>raster
</p>


<h3>Examples</h3>

<pre><code class='language-R'>augusta_nlcd &lt;- terra::rast(landscapemetrics::augusta_nlcd)
data_info(augusta_nlcd)
podlasie_ccilc &lt;- terra::rast(landscapemetrics::podlasie_ccilc)
data_info(podlasie_ccilc)
landscape &lt;- terra::rast(landscapemetrics::landscape)
data_info(landscape)

</code></pre>

<hr>
<h2 id='extract_lsm'>extract_lsm</h2><span id='topic+extract_lsm'></span>

<h3>Description</h3>

<p>Extract metrics
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract_lsm(
  landscape,
  y,
  extract_id = NULL,
  metric = NULL,
  name = NULL,
  type = NULL,
  what = NULL,
  directions = 8,
  progress = FALSE,
  verbose = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extract_lsm_+3A_landscape">landscape</code></td>
<td>
<p>A categorical raster object: SpatRaster; Raster* Layer, Stack, Brick; stars or a list of SpatRasters.</p>
</td></tr>
<tr><td><code id="extract_lsm_+3A_y">y</code></td>
<td>
<p>2-column matrix with coordinates or sf point geometries.</p>
</td></tr>
<tr><td><code id="extract_lsm_+3A_extract_id">extract_id</code></td>
<td>
<p>Vector with id of sample points. If not provided, sample
points will be labelled 1...n.</p>
</td></tr>
<tr><td><code id="extract_lsm_+3A_metric">metric</code></td>
<td>
<p>Abbreviation of metrics (e.g. 'area').</p>
</td></tr>
<tr><td><code id="extract_lsm_+3A_name">name</code></td>
<td>
<p>Full name of metrics (e.g. 'core area')</p>
</td></tr>
<tr><td><code id="extract_lsm_+3A_type">type</code></td>
<td>
<p>Type according to FRAGSTATS grouping (e.g. 'aggregation metrics').</p>
</td></tr>
<tr><td><code id="extract_lsm_+3A_what">what</code></td>
<td>
<p>Selected level of metrics: either &quot;patch&quot;, &quot;class&quot; or &quot;landscape&quot;.
It is also possible to specify functions as a vector of strings, e.g. <code>what = c("lsm_c_ca", "lsm_l_ta")</code>.</p>
</td></tr>
<tr><td><code id="extract_lsm_+3A_directions">directions</code></td>
<td>
<p>The number of directions in which patches should be
connected: 4 (rook's case) or 8 (queen's case).</p>
</td></tr>
<tr><td><code id="extract_lsm_+3A_progress">progress</code></td>
<td>
<p>Print progress report.</p>
</td></tr>
<tr><td><code id="extract_lsm_+3A_verbose">verbose</code></td>
<td>
<p>Print warning messages.</p>
</td></tr>
<tr><td><code id="extract_lsm_+3A_...">...</code></td>
<td>
<p>Arguments passed to <code>calculate_lsm()</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This functions extracts the metrics of all patches the spatial object(s) <code>y</code>
(e.g. spatial points) are located within. Only patch level metrics are possible
to extract. Please be aware that the output is slightly different to all
other <code>lsm</code>-function of <code>landscapemetrics</code>. Returns a tibble with chosen
metrics and the ID of the spatial objects.
</p>


<h3>Value</h3>

<p>tibble
</p>


<h3>See Also</h3>

<p><code><a href="#topic+calculate_lsm">calculate_lsm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>landscape &lt;- terra::rast(landscapemetrics::landscape)

points &lt;- matrix(c(10, 5, 25, 15, 5, 25), ncol = 2, byrow = TRUE)
extract_lsm(landscape, y = points)
extract_lsm(landscape, y = points, type = "aggregation metric")

## Not run: 
# use lines


## End(Not run)

</code></pre>

<hr>
<h2 id='get_adjacencies'>get_adjacencies</h2><span id='topic+get_adjacencies'></span>

<h3>Description</h3>

<p>Fast calculation of adjacencies between classes in a raster
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_adjacencies(landscape, neighbourhood = 4, what = "full", upper = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_adjacencies_+3A_landscape">landscape</code></td>
<td>
<p>A categorical raster object: SpatRaster; Raster* Layer, Stack, Brick; stars or a list of SpatRasters.</p>
</td></tr>
<tr><td><code id="get_adjacencies_+3A_neighbourhood">neighbourhood</code></td>
<td>
<p>The number of directions in which cell adjacencies are
considered as neighbours: 4 (rook's case), 8 (queen's case) or a binary matrix
where the ones define the neighbourhood. The default is 4.</p>
</td></tr>
<tr><td><code id="get_adjacencies_+3A_what">what</code></td>
<td>
<p>Which adjacencies to calculate: &quot;full&quot; for a full adjacency matrix,
&quot;like&quot; for the diagonal, &quot;unlike&quot; for the off diagonal part of the matrix and
&quot;triangle&quot; for a triangular matrix counting adjacencies only once.</p>
</td></tr>
<tr><td><code id="get_adjacencies_+3A_upper">upper</code></td>
<td>
<p>Logical value indicating whether the upper triangle of the adjacency matrix
should be returned (default FALSE).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A fast implementation with Rcpp to calculate the adjacency matrix for raster.
The adjacency matrix is most often used in landscape metrics to describe
the configuration of landscapes, is it is a cellwise count of edges between classes.
</p>
<p>The &quot;full&quot; adjacency matrix is double-count method, as it contains the pairwise
counts of cells between all classes. The diagonal of this matrix contains the
like adjacencies, a count for how many edges a shared in each class with the same class.
</p>
<p>The &quot;unlike&quot; adjacencies are counting the cellwise edges between different classes.
</p>


<h3>Value</h3>

<p>matrix with adjacencies between classes in a raster and between cells from the same class.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>landscape &lt;- terra::rast(landscapemetrics::landscape)
# calculate full adjacency matrix
get_adjacencies(landscape, 4)

# equivalent with the terra package:
adjacencies &lt;- terra::adjacent(landscape, 1:terra::ncell(landscape), "rook", pairs = TRUE)
table(terra::values(landscape, mat = FALSE)[adjacencies[,1]],
terra::values(landscape, mat = FALSE)[adjacencies[,2]])

# count diagonal neighbour adjacencies
diagonal_matrix &lt;- matrix(c(1,  NA,  1,
                            NA,  0, NA,
                            1,  NA,  1), 3, 3, byrow = TRUE)
get_adjacencies(landscape, diagonal_matrix)

</code></pre>

<hr>
<h2 id='get_area_patches'>get_area_patches</h2><span id='topic+get_area_patches'></span>

<h3>Description</h3>

<p>Get areas of patches for each class
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_area_patches(class_patches, classes, resolution)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_area_patches_+3A_class_patches">class_patches</code></td>
<td>
<p>A list with matrices of patches for each class (output of get_class_patches)</p>
</td></tr>
<tr><td><code id="get_area_patches_+3A_classes">classes</code></td>
<td>
<p>A vector with unique values (output of get_unique_values_int)</p>
</td></tr>
<tr><td><code id="get_area_patches_+3A_resolution">resolution</code></td>
<td>
<p>A vector with two numbers (usually calculated using terra::res)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Calculate areas of patches for each class
</p>


<h3>Value</h3>

<p>list with vectors of areas of patches for each class
</p>


<h3>Examples</h3>

<pre><code class='language-R'>landscape &lt;- terra::rast(landscapemetrics::landscape)
landscape_mat &lt;- terra::as.matrix(landscape, wide = TRUE)
classes &lt;- landscapemetrics:::get_unique_values_int(landscape_mat)
class_patches &lt;- get_class_patches(landscape_mat, classes, directions = 8)
area_patches &lt;- get_area_patches(class_patches, classes, resolution = terra::res(landscape))

</code></pre>

<hr>
<h2 id='get_boundaries'>get_boundaries</h2><span id='topic+get_boundaries'></span>

<h3>Description</h3>

<p>Get boundary cells of patches
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_boundaries(
  landscape,
  consider_boundary = FALSE,
  edge_depth = 1,
  as_NA = FALSE,
  patch_id = FALSE,
  return_raster = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_boundaries_+3A_landscape">landscape</code></td>
<td>
<p>SpatRaster or matrix.</p>
</td></tr>
<tr><td><code id="get_boundaries_+3A_consider_boundary">consider_boundary</code></td>
<td>
<p>Logical if cells that only neighbour the landscape
boundary should be considered as edge.</p>
</td></tr>
<tr><td><code id="get_boundaries_+3A_edge_depth">edge_depth</code></td>
<td>
<p>Distance (in cells) a cell has the be away from the patch
edge to be considered as core cell.</p>
</td></tr>
<tr><td><code id="get_boundaries_+3A_as_na">as_NA</code></td>
<td>
<p>If true, non-boundary cells area labeld NA.</p>
</td></tr>
<tr><td><code id="get_boundaries_+3A_patch_id">patch_id</code></td>
<td>
<p>If true, boundary/edge cells are labeled with the original patch id.</p>
</td></tr>
<tr><td><code id="get_boundaries_+3A_return_raster">return_raster</code></td>
<td>
<p>If false, matrix is returned.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>All boundary/edge cells are labeled 1, all non-boundary cells 0. NA values are
not changed. Boundary cells are defined as cells that neighbour either a NA
cell or a cell with a different value than itself. Non-boundary cells only
neighbour cells with the same value than themself.
</p>


<h3>Value</h3>

<p>List with SpatRaster or matrix
</p>


<h3>Examples</h3>

<pre><code class='language-R'>landscape &lt;- terra::rast(landscapemetrics::landscape)
class_1 &lt;- get_patches(landscape, class = 1)[[1]][[1]]

get_boundaries(class_1)
get_boundaries(class_1, return_raster = FALSE)

</code></pre>

<hr>
<h2 id='get_centroids'>get_centroids</h2><span id='topic+get_centroids'></span>

<h3>Description</h3>

<p>Centroid of patches
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_centroids(
  landscape,
  directions = 8,
  cell_center = FALSE,
  return_vec = FALSE,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_centroids_+3A_landscape">landscape</code></td>
<td>
<p>A categorical raster object: SpatRaster; Raster* Layer, Stack, Brick; stars or a list of SpatRasters.</p>
</td></tr>
<tr><td><code id="get_centroids_+3A_directions">directions</code></td>
<td>
<p>The number of directions in which patches should be
connected: 4 (rook's case) or 8 (queen's case).</p>
</td></tr>
<tr><td><code id="get_centroids_+3A_cell_center">cell_center</code></td>
<td>
<p>If true, the coordinates of the centroid are forced to be
a cell center within the patch.</p>
</td></tr>
<tr><td><code id="get_centroids_+3A_return_vec">return_vec</code></td>
<td>
<p>If true, a sf object is returned.</p>
</td></tr>
<tr><td><code id="get_centroids_+3A_verbose">verbose</code></td>
<td>
<p>Print warning messages</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Get the coordinates of the centroid of each patch. The centroid is by default
defined as the mean location of all cell centers. To force the centroid to be
located within each patch, use the <code>cell_center</code> argument. In this case, the
centroid is defined as the cell center that is the closest to the mean location.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># get centroid location
landscape &lt;- terra::rast(landscapemetrics::landscape)
get_centroids(landscape)

</code></pre>

<hr>
<h2 id='get_circumscribingcircle'>get_circumscribingcircle</h2><span id='topic+get_circumscribingcircle'></span>

<h3>Description</h3>

<p>Diameter of the circumscribing circle around patches
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_circumscribingcircle(landscape, directions = 8, level = "patch")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_circumscribingcircle_+3A_landscape">landscape</code></td>
<td>
<p>SpatRaster or matrix (with x, y, id columns)</p>
</td></tr>
<tr><td><code id="get_circumscribingcircle_+3A_directions">directions</code></td>
<td>
<p>The number of directions in which patches should be
connected: 4 (rook's case) or 8 (queen's case).</p>
</td></tr>
<tr><td><code id="get_circumscribingcircle_+3A_level">level</code></td>
<td>
<p>Either 'patch' or 'class' for the corresponding level.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The diameter of the smallest circumscribing circle around a patch in the landscape
is based on the maximum distance between the corners of each cell. This ensures that all
cells of the patch are included in the patch.
</p>
<p>Because the metric is based on distances or areas please make sure your data
is valid using <code><a href="#topic+check_landscape">check_landscape</a></code>.
</p>


<h3>References</h3>

<p>Based on C++ code from Project Nayuki (https://www.nayuki.io/page/smallest-enclosing-circle).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>landscape &lt;- terra::rast(landscapemetrics::landscape)

# get circle around each patch
get_circumscribingcircle(landscape)

# get circle around whole class
get_circumscribingcircle(landscape, level = "class")

</code></pre>

<hr>
<h2 id='get_class_patches'>get_class_patches</h2><span id='topic+get_class_patches'></span>

<h3>Description</h3>

<p>Get patches for each class
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_class_patches(landscape_mat, classes, directions)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_class_patches_+3A_landscape_mat">landscape_mat</code></td>
<td>
<p>A matrix object</p>
</td></tr>
<tr><td><code id="get_class_patches_+3A_classes">classes</code></td>
<td>
<p>A vector with unique values (output of get_unique_values_int)</p>
</td></tr>
<tr><td><code id="get_class_patches_+3A_directions">directions</code></td>
<td>
<p>The number of directions in which patches should be connected: 4 (rook's case) or 8 (queen's case).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Calculate patches for each class
</p>


<h3>Value</h3>

<p>list with matrices of patches for each class
</p>


<h3>Examples</h3>

<pre><code class='language-R'>landscape &lt;- terra::rast(landscapemetrics::landscape)
landscape_mat &lt;- terra::as.matrix(landscape, wide = TRUE)
classes &lt;- landscapemetrics:::get_unique_values_int(landscape_mat)
class_patches &lt;- get_class_patches(landscape_mat, classes, directions = 8)

</code></pre>

<hr>
<h2 id='get_complexity'>get_complexity</h2><span id='topic+get_complexity'></span>

<h3>Description</h3>

<p>Calculate complexity of the landscape
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_complexity(landscape_mat, neighbourhood, ordered, base)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_complexity_+3A_landscape_mat">landscape_mat</code></td>
<td>
<p>A matrix object</p>
</td></tr>
<tr><td><code id="get_complexity_+3A_neighbourhood">neighbourhood</code></td>
<td>
<p>The number of directions in which cell adjacencies are considered as neighbours: 4 (rook's case) or 8 (queen's case). The default is 4.</p>
</td></tr>
<tr><td><code id="get_complexity_+3A_ordered">ordered</code></td>
<td>
<p>The type of pairs considered. Either ordered (TRUE) or unordered (FALSE).</p>
</td></tr>
<tr><td><code id="get_complexity_+3A_base">base</code></td>
<td>
<p>The unit in which entropy is measured. The default is &quot;log2&quot;,</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Calculate complexity of the landscape: entropy of the co-occurrence matrix
</p>


<h3>Value</h3>

<p>matrix
</p>


<h3>Examples</h3>

<pre><code class='language-R'>landscape &lt;- terra::rast(landscapemetrics::landscape)
landscape_mat &lt;- terra::as.matrix(landscape, wide = TRUE)
get_complexity(landscape_mat, neighbourhood = 4, ordered = TRUE, base = "log2")

</code></pre>

<hr>
<h2 id='get_enn_patch'>get_enn_patch</h2><span id='topic+get_enn_patch'></span>

<h3>Description</h3>

<p>Euclidean Nearest-Neighbor Distance
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_enn_patch(classes, class_patches, points, resolution, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_enn_patch_+3A_classes">classes</code></td>
<td>
<p>A vector with unique values (output of get_unique_values_int)</p>
</td></tr>
<tr><td><code id="get_enn_patch_+3A_class_patches">class_patches</code></td>
<td>
<p>A list with matrices of patches for each class (output of get_class_patches)</p>
</td></tr>
<tr><td><code id="get_enn_patch_+3A_points">points</code></td>
<td>
<p>A matrix with three columns: col, row, value (output of get_points)</p>
</td></tr>
<tr><td><code id="get_enn_patch_+3A_resolution">resolution</code></td>
<td>
<p>A vector with two numbers (usually calculated using terra::res)</p>
</td></tr>
<tr><td><code id="get_enn_patch_+3A_verbose">verbose</code></td>
<td>
<p>A logical indicating whether to print warnings</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Calculate Euclidean Nearest-Neighbor Distance for each patch in each class
</p>


<h3>Value</h3>

<p>tibble with two columns: class, value
</p>


<h3>Examples</h3>

<pre><code class='language-R'>landscape &lt;- terra::rast(landscapemetrics::landscape)
landscape_mat &lt;- terra::as.matrix(landscape, wide = TRUE)
classes &lt;- landscapemetrics:::get_unique_values_int(landscape_mat)
class_patches &lt;- get_class_patches(landscape_mat, classes, directions = 8)
points &lt;- get_points(landscape_mat, terra::res(landscape))
enns &lt;- get_enn_patch(classes, class_patches, points, terra::res(landscape))

</code></pre>

<hr>
<h2 id='get_nearestneighbour'>get_nearestneighbour</h2><span id='topic+get_nearestneighbour'></span>

<h3>Description</h3>

<p>Euclidean distance to nearest neighbour
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_nearestneighbour(landscape, return_id = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_nearestneighbour_+3A_landscape">landscape</code></td>
<td>
<p>SpatRaster or matrix (with x,y,id columns).</p>
</td></tr>
<tr><td><code id="get_nearestneighbour_+3A_return_id">return_id</code></td>
<td>
<p>If TRUE, also the patch ID of the nearest neighbour is returned.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Fast and memory safe Rcpp implementation for calculating the minimum Euclidean
distances to the nearest patch of the same class in a raster or matrix.
All patches need an unique ID (see <code><a href="#topic+get_patches">get_patches</a></code>). Please be aware
that the patch ID is not identical to the patch ID of all metric functions (lsm_).
If <code>return_ID = TRUE</code>, for some focal patches several nearest neighbour patches
might be returned.
</p>
<p>Because the metric is based on distances or areas please make sure your data
is valid using <code><a href="#topic+check_landscape">check_landscape</a></code>.
</p>


<h3>References</h3>

<p>Based on RCpp code of Florian Privé <a href="mailto:florian.prive.21@gmail.com">florian.prive.21@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># get patches for class 1
landscape &lt;- terra::rast(landscapemetrics::landscape)
class_1 &lt;- get_patches(landscape, class = 2)[[1]][[1]]

# calculate the distance between patches
get_nearestneighbour(class_1)
get_nearestneighbour(class_1, return_id = TRUE)

</code></pre>

<hr>
<h2 id='get_patches'>get_patches</h2><span id='topic+get_patches'></span>

<h3>Description</h3>

<p>Connected components labeling to derive patches in a landscape.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_patches(
  landscape,
  class = "all",
  directions = 8,
  to_disk = getOption("to_disk", default = FALSE),
  return_raster = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_patches_+3A_landscape">landscape</code></td>
<td>
<p>A categorical raster object: SpatRaster; Raster* Layer, Stack, Brick; stars or a list of SpatRasters.</p>
</td></tr>
<tr><td><code id="get_patches_+3A_class">class</code></td>
<td>
<p>Either &quot;all&quot; (default) for every class in the raster, or specify
class value. See Details.</p>
</td></tr>
<tr><td><code id="get_patches_+3A_directions">directions</code></td>
<td>
<p>The number of directions in which patches should be
connected: 4 (rook's case) or 8 (queen's case).</p>
</td></tr>
<tr><td><code id="get_patches_+3A_to_disk">to_disk</code></td>
<td>
<p>Logical argument, if FALSE results of get_patches are hold
in memory. If true, get_patches writes temporary files and hence, does not hold everything in memory.
Can be set with a global option, e.g. <code>option(to_disk = TRUE)</code>. See Details.</p>
</td></tr>
<tr><td><code id="get_patches_+3A_return_raster">return_raster</code></td>
<td>
<p>If false, matrix is returned</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Searches for connected patches (neighbouring cells of the same class i).
The 8-neighbours rule ('queen's case) or 4-neighbours rule (rook's case) is
used. Returns a list with raster. For each class the connected patches have
the value 1 - n. All cells not belonging to the class are <code>NA</code>.
</p>
<p>Landscape metrics rely on the delineation of patches. Hence, <code>get_patches</code> is
heavily used in <strong>landscapemetrics</strong>. As raster can be quite big, the fact that
<code>get_patches</code> creates a copy of the raster for each class in a landscape becomes
a burden for computer memory. Hence, the argument <em>to_disk</em> allows to
store the results of the connected labeling algorithm on disk. Furthermore,
this option can be set globally, so that every function that internally uses
<code>get_patches</code> can make use of that.
</p>


<h3>Value</h3>

<p>List of SpatRaster
</p>


<h3>References</h3>

<p>Vincent, L., Soille, P. 1991. Watersheds in digital spaces: an efficient
algorithm based on immersion simulations. IEEE Transactions on Pattern
Analysis and Machine Intelligence. 13 (6), 583-598
</p>


<h3>Examples</h3>

<pre><code class='language-R'>landscape &lt;- terra::rast(landscapemetrics::landscape)

# check for patches of class 1
patched_raster &lt;- get_patches(landscape, class = 1)

# count patches
nrow(terra::unique(patched_raster[[1]][[1]]))

# check for patches of every class
patched_raster &lt;-  get_patches(landscape)

</code></pre>

<hr>
<h2 id='get_perimeter_patch'>get_perimeter_patch</h2><span id='topic+get_perimeter_patch'></span>

<h3>Description</h3>

<p>Perimeter of each patch in each class
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_perimeter_patch(classes, class_patches, resolution)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_perimeter_patch_+3A_classes">classes</code></td>
<td>
<p>A vector with unique values (output of get_unique_values_int)</p>
</td></tr>
<tr><td><code id="get_perimeter_patch_+3A_class_patches">class_patches</code></td>
<td>
<p>A list with matrices of patches for each class (output of get_class_patches)</p>
</td></tr>
<tr><td><code id="get_perimeter_patch_+3A_resolution">resolution</code></td>
<td>
<p>A vector with two numbers (usually calculated using terra::res)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Calculate perimeter of each patch in each class
</p>


<h3>Value</h3>

<p>A tibble with two columns: class, value
</p>


<h3>Examples</h3>

<pre><code class='language-R'>landscape &lt;- terra::rast(landscapemetrics::landscape)
landscape_mat &lt;- terra::as.matrix(landscape, wide = TRUE)
classes &lt;- landscapemetrics:::get_unique_values_int(landscape_mat)
class_patches &lt;- get_class_patches(landscape_mat, classes, directions = 8)
pp &lt;- get_perimeter_patch(classes, class_patches, terra::res(landscape))

</code></pre>

<hr>
<h2 id='get_points'>get_points</h2><span id='topic+get_points'></span>

<h3>Description</h3>

<p>Raster to col, row, value
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_points(landscape_mat, resolution)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_points_+3A_landscape_mat">landscape_mat</code></td>
<td>
<p>A matrix object</p>
</td></tr>
<tr><td><code id="get_points_+3A_resolution">resolution</code></td>
<td>
<p>A vector with two numbers (usually calculated using terra::res)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The col and row values are multiplied by the resolution to get the (internal) coordinates of the points.
</p>


<h3>Value</h3>

<p>matrix with three columns: col, row, value
</p>


<h3>Examples</h3>

<pre><code class='language-R'>landscape &lt;- terra::rast(landscapemetrics::landscape)
landscape_mat &lt;- terra::as.matrix(landscape, wide = TRUE)
resolution &lt;- terra::res(landscape)
get_points(landscape_mat, resolution)

</code></pre>

<hr>
<h2 id='get_unique_values'>get_unique_values</h2><span id='topic+get_unique_values'></span>

<h3>Description</h3>

<p>This function returns the unique values of an object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_unique_values(x, simplify = FALSE, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_unique_values_+3A_x">x</code></td>
<td>
<p>Vector, matrix, raster, stars, or terra object or list of previous.</p>
</td></tr>
<tr><td><code id="get_unique_values_+3A_simplify">simplify</code></td>
<td>
<p>If true, a vector will be returned instead of a list for
1-dimensional input</p>
</td></tr>
<tr><td><code id="get_unique_values_+3A_verbose">verbose</code></td>
<td>
<p>If true, warning messages are printed</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Fast and memory friendly Rcpp implementation to find the unique values of an object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>landscape &lt;- terra::rast(landscapemetrics::landscape)

get_unique_values(landscape)

landscape_stack &lt;- c(landscape, landscape, landscape)
get_unique_values(landscape_stack)

landscape_matrix &lt;- terra::as.matrix(landscape, wide = TRUE)
get_unique_values(landscape_matrix)

x_vec &lt;- c(1, 2, 1, 1, 2, 2)
get_unique_values(x_vec)

landscape_list &lt;- list(landscape, landscape_matrix, x_vec)
get_unique_values(landscape_list)

</code></pre>

<hr>
<h2 id='landscape'>Example map (random cluster neutral landscape model).</h2><span id='topic+landscape'></span>

<h3>Description</h3>

<p>An example map to show landscapemetrics functionality
generated with the <code>nlm_randomcluster()</code> algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>landscape
</code></pre>


<h3>Format</h3>

<p>A raster object.
</p>


<h3>Source</h3>

<p>Simulated neutral landscape model with R. https://github.com/ropensci/NLMR/
</p>

<hr>
<h2 id='landscape_as_list'>Landscape as list</h2><span id='topic+landscape_as_list'></span><span id='topic+landscape_as_list.SpatRaster'></span><span id='topic+landscape_as_list.RasterLayer'></span><span id='topic+landscape_as_list.RasterBrick'></span><span id='topic+landscape_as_list.RasterStack'></span><span id='topic+landscape_as_list.stars'></span><span id='topic+landscape_as_list.list'></span><span id='topic+landscape_as_list.matrix'></span><span id='topic+landscape_as_list.numeric'></span>

<h3>Description</h3>

<p>Convert raster input to list
</p>


<h3>Usage</h3>

<pre><code class='language-R'>landscape_as_list(landscape)

## S3 method for class 'SpatRaster'
landscape_as_list(landscape)

## S3 method for class 'RasterLayer'
landscape_as_list(landscape)

## S3 method for class 'RasterBrick'
landscape_as_list(landscape)

## S3 method for class 'RasterStack'
landscape_as_list(landscape)

## S3 method for class 'stars'
landscape_as_list(landscape)

## S3 method for class 'list'
landscape_as_list(landscape)

## S3 method for class 'matrix'
landscape_as_list(landscape)

## S3 method for class 'numeric'
landscape_as_list(landscape)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="landscape_as_list_+3A_landscape">landscape</code></td>
<td>
<p>A categorical raster object: SpatRaster; Raster* Layer, Stack, Brick; stars or a list of SpatRasters</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Mainly for internal use
</p>


<h3>Value</h3>

<p>list
</p>


<h3>Examples</h3>

<pre><code class='language-R'>landscape &lt;- terra::rast(landscapemetrics::landscape)
landscape_as_list(c(landscape, landscape))

</code></pre>

<hr>
<h2 id='list_lsm'>List landscape metrics</h2><span id='topic+list_lsm'></span>

<h3>Description</h3>

<p>List landscape metrics
</p>


<h3>Usage</h3>

<pre><code class='language-R'>list_lsm(
  level = NULL,
  metric = NULL,
  name = NULL,
  type = NULL,
  what = NULL,
  simplify = FALSE,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="list_lsm_+3A_level">level</code></td>
<td>
<p>Level of metrics. Either 'patch', 'class' or 'landscape' (or vector with combination).</p>
</td></tr>
<tr><td><code id="list_lsm_+3A_metric">metric</code></td>
<td>
<p>Abbreviation of metrics (e.g. 'area').</p>
</td></tr>
<tr><td><code id="list_lsm_+3A_name">name</code></td>
<td>
<p>Full name of metrics (e.g. 'core area')</p>
</td></tr>
<tr><td><code id="list_lsm_+3A_type">type</code></td>
<td>
<p>Type according to FRAGSTATS grouping (e.g. 'aggregation metrics').</p>
</td></tr>
<tr><td><code id="list_lsm_+3A_what">what</code></td>
<td>
<p>Selected level of metrics: either &quot;patch&quot;, &quot;class&quot; or &quot;landscape&quot;.
It is also possible to specify functions as a vector of strings, e.g. <code>what = c("lsm_c_ca", "lsm_l_ta")</code>.</p>
</td></tr>
<tr><td><code id="list_lsm_+3A_simplify">simplify</code></td>
<td>
<p>If true, function names are returned as vector.</p>
</td></tr>
<tr><td><code id="list_lsm_+3A_verbose">verbose</code></td>
<td>
<p>Print warning messages</p>
</td></tr>
</table>


<h3>Details</h3>

<p>List all available landscape metrics depending on the provided filter
arguments. If an argument is not provided, automatically all possibilities are
selected. Therefore, to get <strong>all</strong> available metrics, use simply <code>list_lsm()</code>.
For all arguments with exception of the <code>what</code> argument, it is also possible to
use a negative subset, i.e. all metrics  <strong>but</strong> the selected ones. Therefore,
simply use e.g. <code>level = "-patch".</code> Furthermore, it is possible to only
get a vector with all function names instead of the full tibble.
</p>


<h3>Value</h3>

<p>tibble
</p>


<h3>References</h3>

<p>McGarigal K., SA Cushman, and E Ene. 2023. FRAGSTATS v4: Spatial Pattern Analysis
Program for Categorical Maps. Computer software program produced by the authors;
available at the following web site: https://www.fragstats.org
</p>


<h3>Examples</h3>

<pre><code class='language-R'>list_lsm(level = c("patch", "landscape"), type = "aggregation metric")
list_lsm(level = "-patch", type = "area and edge metric")
list_lsm(metric = "area", simplify = TRUE)

list_lsm(metric = "area", what = "lsm_p_shape")
list_lsm(metric = "area", what = c("patch", "lsm_l_ta"))
list_lsm(what = c("lsm_c_tca", "lsm_l_ta"))

</code></pre>

<hr>
<h2 id='lsm_abbreviations_names'>Tibble of abbreviations coming from FRAGSTATS</h2><span id='topic+lsm_abbreviations_names'></span>

<h3>Description</h3>

<p>A single tibble for every abbreviation of every metric that is
reimplemented in landscapemetrics and its corresponding full name
in the literature.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lsm_abbreviations_names
</code></pre>


<h3>Format</h3>

<p>A tibble object.
</p>


<h3>Details</h3>

<p>Can be used after calculating the metric(s) with a join to have
a more readable results tibble or for visualizing your results.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>landscape &lt;- terra::rast(landscapemetrics::landscape)
patch_area &lt;- lsm_p_area(landscape)
patch_area &lt;- merge(x = patch_area, y = lsm_abbreviations_names, by = c("level", "metric"))

</code></pre>

<hr>
<h2 id='lsm_c_ai'>AI (class level)</h2><span id='topic+lsm_c_ai'></span>

<h3>Description</h3>

<p>Aggregation index (Aggregation metric)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lsm_c_ai(landscape)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lsm_c_ai_+3A_landscape">landscape</code></td>
<td>
<p>A categorical raster object: SpatRaster; Raster* Layer, Stack, Brick; stars or a list of SpatRasters</p>
</td></tr>
</table>


<h3>Details</h3>

<p style="text-align: center;"><code class="reqn">AI = \Bigg[\frac{g_{ii}}{max-g_{ii}} \Bigg](100) </code>
</p>

<p>where <code class="reqn">g_{ii}</code> is the number of like adjacencies based on the single-count method and
<code class="reqn">max-g_{ii}</code> is the classwise maximum number of like adjacencies of class i.
</p>
<p>AI is an 'Aggregation metric'. It equals the number of like adjacencies divided
by the theoretical maximum possible number of like adjacencies for that class.
The metric is based on he adjacency matrix and the the single-count method.
</p>


<h4>Units</h4>

<p>Percent</p>



<h4>Range</h4>

<p>0 &lt;= AI &lt;= 100</p>



<h4>Behaviour</h4>

<p>Equals 0 for maximally disaggregated and 100
for maximally aggregated classes.</p>



<h3>Value</h3>

<p>tibble
</p>


<h3>References</h3>

<p>McGarigal K., SA Cushman, and E Ene. 2023. FRAGSTATS v4: Spatial Pattern Analysis
Program for Categorical Maps. Computer software program produced by the authors;
available at the following web site: https://www.fragstats.org
</p>
<p>He, H. S., DeZonia, B. E., &amp; Mladenoff, D. J. 2000. An aggregation index (AI)
to quantify spatial patterns of landscapes. Landscape ecology, 15(7), 591-601.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lsm_l_ai">lsm_l_ai</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>landscape &lt;- terra::rast(landscapemetrics::landscape)
lsm_c_ai(landscape)

</code></pre>

<hr>
<h2 id='lsm_c_area_cv'>AREA_CV (class level)</h2><span id='topic+lsm_c_area_cv'></span>

<h3>Description</h3>

<p>Coefficient of variation of patch area (Area and edge metric)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lsm_c_area_cv(landscape, directions = 8)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lsm_c_area_cv_+3A_landscape">landscape</code></td>
<td>
<p>A categorical raster object: SpatRaster; Raster* Layer, Stack, Brick; stars or a list of SpatRasters</p>
</td></tr>
<tr><td><code id="lsm_c_area_cv_+3A_directions">directions</code></td>
<td>
<p>The number of directions in which patches should be connected: 4 (rook's case) or 8 (queen's case).</p>
</td></tr>
</table>


<h3>Details</h3>

<p style="text-align: center;"><code class="reqn">AREA_{CV} = cv(AREA[patch_{ij}])</code>
</p>

<p>where <code class="reqn">AREA[patch_{ij}]</code> is the area of each patch in hectares.
</p>
<p>AREA_CV is an 'Area and Edge metric'. The metric summarises each class
as the Coefficient of variation of all patch areas belonging to class i.
The metric describes the differences among patches of the same class i in
the landscape and is easily comparable because it is scaled to the mean.
</p>
<p>Because the metric is based on distances or areas please make sure your data
is valid using <code><a href="#topic+check_landscape">check_landscape</a></code>.
</p>


<h4>Units</h4>

<p>Hectares</p>



<h4>Range</h4>

<p>AREA_CV &gt;= 0</p>



<h4>Behaviour</h4>

<p>Equals AREA_CV = 0 if all patches are identical in size.
Increases, without limit, as the variation of patch areas increases.</p>



<h3>Value</h3>

<p>tibble
</p>


<h3>References</h3>

<p>McGarigal K., SA Cushman, and E Ene. 2023. FRAGSTATS v4: Spatial Pattern Analysis
Program for Categorical Maps. Computer software program produced by the authors;
available at the following web site: https://www.fragstats.org
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lsm_p_area">lsm_p_area</a></code>, <br />
<code><a href="#topic+lsm_c_area_mn">lsm_c_area_mn</a></code>,
<code><a href="#topic+lsm_c_area_sd">lsm_c_area_sd</a></code>, <br />
<code><a href="#topic+lsm_l_area_mn">lsm_l_area_mn</a></code>,
<code><a href="#topic+lsm_l_area_sd">lsm_l_area_sd</a></code>,
<code><a href="#topic+lsm_l_area_cv">lsm_l_area_cv</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>landscape &lt;- terra::rast(landscapemetrics::landscape)
lsm_c_area_cv(landscape)

</code></pre>

<hr>
<h2 id='lsm_c_area_mn'>AREA_MN (class level)</h2><span id='topic+lsm_c_area_mn'></span>

<h3>Description</h3>

<p>Mean of patch area (Area and edge metric)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lsm_c_area_mn(landscape, directions = 8)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lsm_c_area_mn_+3A_landscape">landscape</code></td>
<td>
<p>A categorical raster object: SpatRaster; Raster* Layer, Stack, Brick; stars or a list of SpatRasters</p>
</td></tr>
<tr><td><code id="lsm_c_area_mn_+3A_directions">directions</code></td>
<td>
<p>The number of directions in which patches should be connected: 4 (rook's case) or 8 (queen's case).</p>
</td></tr>
</table>


<h3>Details</h3>

<p style="text-align: center;"><code class="reqn">AREA_{MN} = mean(AREA[patch_{ij}])</code>
</p>

<p>where <code class="reqn">AREA[patch_{ij}]</code> is the area of each patch in hectares
</p>
<p>AREA_MN is an 'Area and Edge metric'. The metric summarises each class
as the mean of all patch areas belonging to class i. The metric is a simple way
to describe the composition of the landscape. Especially together with the total
class area (<code><a href="#topic+lsm_c_ca">lsm_c_ca</a></code>), it can also give an an idea of patch structure
(e.g. many small patches vs. few larges patches).
</p>
<p>Because the metric is based on distances or areas please make sure your data
is valid using <code><a href="#topic+check_landscape">check_landscape</a></code>.
</p>


<h4>Units</h4>

<p>Hectares</p>



<h4>Range</h4>

<p>AREA_MN &gt; 0</p>



<h4>Behaviour</h4>

<p>Approaches AREA_MN = 0 if all patches are small. Increases, without
limit, as the patch areas increase.</p>



<h3>Value</h3>

<p>tibble
</p>


<h3>References</h3>

<p>McGarigal K., SA Cushman, and E Ene. 2023. FRAGSTATS v4: Spatial Pattern Analysis
Program for Categorical Maps. Computer software program produced by the authors;
available at the following web site: https://www.fragstats.org
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lsm_p_area">lsm_p_area</a></code>,
<code><a href="base.html#topic+mean">mean</a></code>, <br />
<code><a href="#topic+lsm_c_area_cv">lsm_c_area_cv</a></code>,
<code><a href="#topic+lsm_c_area_sd">lsm_c_area_sd</a></code>, <br />
<code><a href="#topic+lsm_l_area_mn">lsm_l_area_mn</a></code>,
<code><a href="#topic+lsm_l_area_sd">lsm_l_area_sd</a></code>,
<code><a href="#topic+lsm_l_area_cv">lsm_l_area_cv</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>landscape &lt;- terra::rast(landscapemetrics::landscape)
lsm_c_area_mn(landscape)

</code></pre>

<hr>
<h2 id='lsm_c_area_sd'>AREA_SD (class level)</h2><span id='topic+lsm_c_area_sd'></span>

<h3>Description</h3>

<p>Standard deviation of patch area (Area and edge metric)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lsm_c_area_sd(landscape, directions = 8)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lsm_c_area_sd_+3A_landscape">landscape</code></td>
<td>
<p>A categorical raster object: SpatRaster; Raster* Layer, Stack, Brick; stars or a list of SpatRasters</p>
</td></tr>
<tr><td><code id="lsm_c_area_sd_+3A_directions">directions</code></td>
<td>
<p>The number of directions in which patches should be
connected: 4 (rook's case) or 8 (queen's case).</p>
</td></tr>
</table>


<h3>Details</h3>

<p style="text-align: center;"><code class="reqn">AREA_{SD} = sd(AREA[patch_{ij}])</code>
</p>

<p>where <code class="reqn">AREA[patch_{ij}]</code> is the area of each patch in hectares.
</p>
<p>AREA_SD is an 'Area and Edge metric'. The metric summarises each class
as the standard deviation of all patch areas belonging to class i.
The metric describes the differences among patches of the same class i in
the landscape.
</p>
<p>Because the metric is based on distances or areas please make sure your data
is valid using <code><a href="#topic+check_landscape">check_landscape</a></code>.
</p>


<h4>Units</h4>

<p>Hectares</p>



<h4>Range</h4>

<p>AREA_SD &gt;= 0</p>



<h4>Behaviour</h4>

<p>Equals AREA_SD = 0 if all patches are identical in size.
Increases, without limit, as the variation of patch areas increases.</p>



<h3>Value</h3>

<p>tibble
</p>


<h3>References</h3>

<p>McGarigal K., SA Cushman, and E Ene. 2023. FRAGSTATS v4: Spatial Pattern Analysis
Program for Categorical Maps. Computer software program produced by the authors;
available at the following web site: https://www.fragstats.org
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lsm_p_area">lsm_p_area</a></code>,
<code><a href="stats.html#topic+sd">sd</a></code> <br />
<code><a href="#topic+lsm_c_area_mn">lsm_c_area_mn</a></code>,
<code><a href="#topic+lsm_c_area_cv">lsm_c_area_cv</a></code>, <br />
<code><a href="#topic+lsm_l_area_mn">lsm_l_area_mn</a></code>,
<code><a href="#topic+lsm_l_area_sd">lsm_l_area_sd</a></code>,
<code><a href="#topic+lsm_l_area_cv">lsm_l_area_cv</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>landscape &lt;- terra::rast(landscapemetrics::landscape)
lsm_c_area_sd(landscape)

</code></pre>

<hr>
<h2 id='lsm_c_ca'>CA (class level)</h2><span id='topic+lsm_c_ca'></span>

<h3>Description</h3>

<p>Total (class) area (Area and edge metric)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lsm_c_ca(landscape, directions = 8)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lsm_c_ca_+3A_landscape">landscape</code></td>
<td>
<p>A categorical raster object: SpatRaster; Raster* Layer, Stack, Brick; stars or a list of SpatRasters.</p>
</td></tr>
<tr><td><code id="lsm_c_ca_+3A_directions">directions</code></td>
<td>
<p>The number of directions in which patches should be
connected: 4 (rook's case) or 8 (queen's case).</p>
</td></tr>
</table>


<h3>Details</h3>

<p style="text-align: center;"><code class="reqn">CA = sum(AREA[patch_{ij}])</code>
</p>

<p>where <code class="reqn">AREA[patch_{ij}]</code> is the area of each patch in hectares.
</p>
<p>CA is an 'Area and edge metric' and a measure of composition.
The total (class) area sums the area of all patches belonging to class i.
It shows if the landscape is e.g. dominated by one class or if all classes
are equally present. CA is an absolute measure, making comparisons among
landscapes with different total areas difficult.
</p>
<p>Because the metric is based on distances or areas please make sure your data
is valid using <code><a href="#topic+check_landscape">check_landscape</a></code>.
</p>


<h4>Units</h4>

<p>Hectares</p>



<h4>Range</h4>

<p>CA &gt; 0</p>



<h4>Behaviour</h4>

<p>Approaches CA &gt; 0 as the patch areas of class i
become small. Increases, without limit, as the patch areas of class i become
large. CA = TA if only one class is present.</p>



<h3>Value</h3>

<p>tibble
</p>


<h3>References</h3>

<p>McGarigal K., SA Cushman, and E Ene. 2023. FRAGSTATS v4: Spatial Pattern Analysis
Program for Categorical Maps. Computer software program produced by the authors;
available at the following web site: https://www.fragstats.org
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lsm_p_area">lsm_p_area</a></code>,
<code><a href="base.html#topic+sum">sum</a></code>, <br />
<code><a href="#topic+lsm_l_ta">lsm_l_ta</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>landscape &lt;- terra::rast(landscapemetrics::landscape)
lsm_c_ca(landscape)

</code></pre>

<hr>
<h2 id='lsm_c_cai_cv'>CAI_CV (class level)</h2><span id='topic+lsm_c_cai_cv'></span>

<h3>Description</h3>

<p>Coefficient of variation of core area index (Core area metric)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lsm_c_cai_cv(
  landscape,
  directions = 8,
  consider_boundary = FALSE,
  edge_depth = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lsm_c_cai_cv_+3A_landscape">landscape</code></td>
<td>
<p>A categorical raster object: SpatRaster; Raster* Layer, Stack, Brick; stars or a list of SpatRasters.</p>
</td></tr>
<tr><td><code id="lsm_c_cai_cv_+3A_directions">directions</code></td>
<td>
<p>The number of directions in which patches should be
connected: 4 (rook's case) or 8 (queen's case).</p>
</td></tr>
<tr><td><code id="lsm_c_cai_cv_+3A_consider_boundary">consider_boundary</code></td>
<td>
<p>Logical if cells that only neighbour the landscape
boundary should be considered as core</p>
</td></tr>
<tr><td><code id="lsm_c_cai_cv_+3A_edge_depth">edge_depth</code></td>
<td>
<p>Distance (in cells) a cell has the be away from the patch
edge to be considered as core cell</p>
</td></tr>
</table>


<h3>Details</h3>

<p style="text-align: center;"><code class="reqn">CAI_{CV} = cv(CAI[patch_{ij}]</code>
</p>

<p>where <code class="reqn">CAI[patch_{ij}]</code> is the core area index of each patch.
</p>
<p>CAI_CV is a 'Core area metric'. The metric summarises each class
as the Coefficient of variation of the core area index of all patches
belonging to class i. The core area index is the percentage of core area
in relation to patch area. A cell is defined as core area if the cell has
no neighbour with a different value than itself (rook's case). The metric
describes the differences among patches of the same class i in
the landscape.
</p>
<p>Because the metric is based on distances or areas please make sure your data
is valid using <code><a href="#topic+check_landscape">check_landscape</a></code>.
</p>


<h4>Units</h4>

<p>Percent</p>



<h4>Range</h4>

<p>CAI_CV &gt;= 0</p>



<h4>Behaviour</h4>

<p>Equals CAI_CV = 0 if the core area index is identical
for all patches. Increases, without limit, as the variation of the core area
indices increases.</p>



<h3>Value</h3>

<p>tibble
</p>


<h3>References</h3>

<p>McGarigal K., SA Cushman, and E Ene. 2023. FRAGSTATS v4: Spatial Pattern Analysis
Program for Categorical Maps. Computer software program produced by the authors;
available at the following web site: https://www.fragstats.org
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lsm_p_cai">lsm_p_cai</a></code>, <br />
<code><a href="#topic+lsm_c_cai_mn">lsm_c_cai_mn</a></code>,
<code><a href="#topic+lsm_c_cai_sd">lsm_c_cai_sd</a></code>, <br />
<code><a href="#topic+lsm_l_cai_mn">lsm_l_cai_mn</a></code>,
<code><a href="#topic+lsm_l_cai_sd">lsm_l_cai_sd</a></code>,
<code><a href="#topic+lsm_l_cai_cv">lsm_l_cai_cv</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>landscape &lt;- terra::rast(landscapemetrics::landscape)
lsm_c_cai_cv(landscape)

</code></pre>

<hr>
<h2 id='lsm_c_cai_mn'>CAI_MN (class level)</h2><span id='topic+lsm_c_cai_mn'></span>

<h3>Description</h3>

<p>Mean of core area index (Core area metric)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lsm_c_cai_mn(
  landscape,
  directions = 8,
  consider_boundary = FALSE,
  edge_depth = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lsm_c_cai_mn_+3A_landscape">landscape</code></td>
<td>
<p>A categorical raster object: SpatRaster; Raster* Layer, Stack, Brick; stars or a list of SpatRasters.</p>
</td></tr>
<tr><td><code id="lsm_c_cai_mn_+3A_directions">directions</code></td>
<td>
<p>The number of directions in which patches should be
connected: 4 (rook's case) or 8 (queen's case).</p>
</td></tr>
<tr><td><code id="lsm_c_cai_mn_+3A_consider_boundary">consider_boundary</code></td>
<td>
<p>Logical if cells that only neighbour the landscape
boundary should be considered as core</p>
</td></tr>
<tr><td><code id="lsm_c_cai_mn_+3A_edge_depth">edge_depth</code></td>
<td>
<p>Distance (in cells) a cell has the be away from the patch
edge to be considered as core cell</p>
</td></tr>
</table>


<h3>Details</h3>

<p style="text-align: center;"><code class="reqn">CAI_{MN} = mean(CAI[patch_{ij}]</code>
</p>

<p>where <code class="reqn">CAI[patch_{ij}]</code> is the core area index of each patch.
</p>
<p>CAI_MN is a 'Core area metric'. The metric summarises each class
as the mean of the core area index of all patches belonging to class i.
The core area index is the percentage of core area in relation to patch area.
A cell is defined as core area if the cell has no neighbour with a different
value than itself (rook's case).
</p>
<p>Because the metric is based on distances or areas please make sure your data
is valid using <code><a href="#topic+check_landscape">check_landscape</a></code>.
</p>


<h4>Units</h4>

<p>Percent</p>



<h4>Range</h4>

<p>0 &lt;= CAI_MN &lt;= 100</p>



<h4>Behaviour</h4>

<p>CAI_MN = 0 when all patches have no core area and
approaches CAI_MN = 100 with increasing percentage of core area within patches.</p>



<h3>Value</h3>

<p>tibble
</p>


<h3>References</h3>

<p>McGarigal K., SA Cushman, and E Ene. 2023. FRAGSTATS v4: Spatial Pattern Analysis
Program for Categorical Maps. Computer software program produced by the authors;
available at the following web site: https://www.fragstats.org
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lsm_p_cai">lsm_p_cai</a></code>,
<code><a href="base.html#topic+mean">mean</a></code>, <br />
<code><a href="#topic+lsm_c_cai_sd">lsm_c_cai_sd</a></code>,
<code><a href="#topic+lsm_c_cai_cv">lsm_c_cai_cv</a></code>, <br />
<code><a href="#topic+lsm_l_cai_mn">lsm_l_cai_mn</a></code>,
<code><a href="#topic+lsm_l_cai_sd">lsm_l_cai_sd</a></code>,
<code><a href="#topic+lsm_l_cai_cv">lsm_l_cai_cv</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>landscape &lt;- terra::rast(landscapemetrics::landscape)
lsm_c_cai_mn(landscape)

</code></pre>

<hr>
<h2 id='lsm_c_cai_sd'>CAI_SD (class level)</h2><span id='topic+lsm_c_cai_sd'></span>

<h3>Description</h3>

<p>Standard deviation of core area index (Core area metric)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lsm_c_cai_sd(
  landscape,
  directions = 8,
  consider_boundary = FALSE,
  edge_depth = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lsm_c_cai_sd_+3A_landscape">landscape</code></td>
<td>
<p>A categorical raster object: SpatRaster; Raster* Layer, Stack, Brick; stars or a list of SpatRasters.</p>
</td></tr>
<tr><td><code id="lsm_c_cai_sd_+3A_directions">directions</code></td>
<td>
<p>The number of directions in which patches should be
connected: 4 (rook's case) or 8 (queen's case).</p>
</td></tr>
<tr><td><code id="lsm_c_cai_sd_+3A_consider_boundary">consider_boundary</code></td>
<td>
<p>Logical if cells that only neighbour the landscape
boundary should be considered as core</p>
</td></tr>
<tr><td><code id="lsm_c_cai_sd_+3A_edge_depth">edge_depth</code></td>
<td>
<p>Distance (in cells) a cell has the be away from the patch
edge to be considered as core cell</p>
</td></tr>
</table>


<h3>Details</h3>

<p style="text-align: center;"><code class="reqn">CAI_{SD} = sd(CAI[patch_{ij}]</code>
</p>

<p>where <code class="reqn">CAI[patch_{ij}]</code> is the core area index of each patch.
</p>
<p>CAI_SD is a 'Core area metric'. The metric summarises each class
as the standard deviation of the core area index of all patches belonging to class i.
The core area index is the percentage of core area in relation to patch area.
A cell is defined as core area if the cell has no neighbour with a different
value than itself (rook's case). The metric describes the differences among patches
of the same class i in the landscape.
</p>
<p>Because the metric is based on distances or areas please make sure your data
is valid using <code><a href="#topic+check_landscape">check_landscape</a></code>.
</p>


<h4>Units</h4>

<p>Percent</p>



<h4>Range</h4>

<p>CAI_SD &gt;= 0</p>



<h4>Behaviour</h4>

<p>Equals CAI_SD = 0 if the core area index is identical
for all patches. Increases, without limit, as the variation of core area
indices increases.</p>



<h3>Value</h3>

<p>tibble
</p>


<h3>References</h3>

<p>McGarigal K., SA Cushman, and E Ene. 2023. FRAGSTATS v4: Spatial Pattern Analysis
Program for Categorical Maps. Computer software program produced by the authors;
available at the following web site: https://www.fragstats.org
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lsm_p_cai">lsm_p_cai</a></code>,
<code><a href="stats.html#topic+sd">sd</a></code> <br />
<code><a href="#topic+lsm_c_cai_mn">lsm_c_cai_mn</a></code>,
<code><a href="#topic+lsm_c_cai_cv">lsm_c_cai_cv</a></code>, <br />
<code><a href="#topic+lsm_l_cai_mn">lsm_l_cai_mn</a></code>,
<code><a href="#topic+lsm_l_cai_sd">lsm_l_cai_sd</a></code>,
<code><a href="#topic+lsm_l_cai_cv">lsm_l_cai_cv</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>landscape &lt;- terra::rast(landscapemetrics::landscape)
lsm_c_cai_sd(landscape)

</code></pre>

<hr>
<h2 id='lsm_c_circle_cv'>CIRCLE_CV (Class level)</h2><span id='topic+lsm_c_circle_cv'></span>

<h3>Description</h3>

<p>Coefficient of variation of related circumscribing circle (Shape metric)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lsm_c_circle_cv(landscape, directions = 8)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lsm_c_circle_cv_+3A_landscape">landscape</code></td>
<td>
<p>A categorical raster object: SpatRaster; Raster* Layer, Stack, Brick; stars or a list of SpatRasters.</p>
</td></tr>
<tr><td><code id="lsm_c_circle_cv_+3A_directions">directions</code></td>
<td>
<p>The number of directions in which patches should be
connected: 4 (rook's case) or 8 (queen's case).</p>
</td></tr>
</table>


<h3>Details</h3>

<p style="text-align: center;"><code class="reqn">CIRCLE_{CV} = cv(CIRCLE[patch_{ij}])</code>
</p>

<p>where <code class="reqn">CIRCLE[patch_{ij}]</code> is the related circumscribing circle of each patch.
</p>
<p>CIRCLE_CV is a 'Shape metric' and summarises each class as the Coefficient of variation of
the related circumscribing circle of all patches belonging to class i. CIRCLE describes
the ratio between the patch area and the smallest circumscribing circle of the patch
and characterises the compactness of the patch. CIRCLE_CV describes the differences among
patches of the same class i in the landscape. Because it is scaled to the mean,
it is easily comparable.
</p>
<p>Because the metric is based on distances or areas please make sure your data
is valid using <code><a href="#topic+check_landscape">check_landscape</a></code>.
</p>


<h4>Units</h4>

<p>None</p>



<h4>Range</h4>

<p>CIRCLE_CV &gt;= 0</p>



<h4>Behaviour</h4>

<p>Equals CIRCLE_CV if the related circumscribing circle is identical
for all patches. Increases, without limit, as the variation of related circumscribing
circles increases.</p>



<h3>Value</h3>

<p>tibble
</p>


<h3>References</h3>

<p>McGarigal K., SA Cushman, and E Ene. 2023. FRAGSTATS v4: Spatial Pattern Analysis
Program for Categorical Maps. Computer software program produced by the authors;
available at the following web site: https://www.fragstats.org
</p>
<p>Baker, W. L., and Y. Cai. 1992. The r.le programs for multiscale analysis of
landscape structure using the GRASS geographical information system.
Landscape Ecology 7: 291-302.
</p>
<p>Based on C++ code from Project Nayuki (https://www.nayuki.io/page/smallest-enclosing-circle).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lsm_p_circle">lsm_p_circle</a></code>,
<code><a href="base.html#topic+mean">mean</a></code>, <br />
<code><a href="#topic+lsm_c_circle_mn">lsm_c_circle_mn</a></code>,
<code><a href="#topic+lsm_c_circle_sd">lsm_c_circle_sd</a></code>, <br />
<code><a href="#topic+lsm_l_circle_mn">lsm_l_circle_mn</a></code>,
<code><a href="#topic+lsm_l_circle_sd">lsm_l_circle_sd</a></code>,
<code><a href="#topic+lsm_l_circle_cv">lsm_l_circle_cv</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>landscape &lt;- terra::rast(landscapemetrics::landscape)
lsm_c_circle_cv(landscape)

</code></pre>

<hr>
<h2 id='lsm_c_circle_mn'>CIRCLE_MN (Class level)</h2><span id='topic+lsm_c_circle_mn'></span>

<h3>Description</h3>

<p>Mean of related circumscribing circle (Shape metric)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lsm_c_circle_mn(landscape, directions = 8)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lsm_c_circle_mn_+3A_landscape">landscape</code></td>
<td>
<p>A categorical raster object: SpatRaster; Raster* Layer, Stack, Brick; stars or a list of SpatRasters.</p>
</td></tr>
<tr><td><code id="lsm_c_circle_mn_+3A_directions">directions</code></td>
<td>
<p>The number of directions in which patches should be
connected: 4 (rook's case) or 8 (queen's case).</p>
</td></tr>
</table>


<h3>Details</h3>

<p style="text-align: center;"><code class="reqn">CIRCLE_{MN} = mean(CIRCLE[patch_{ij}])</code>
</p>

<p>where <code class="reqn">CIRCLE[patch_{ij}]</code> is the related circumscribing circle of each patch.
</p>
<p>CIRCLE_MN is a 'Shape metric' and summarises each class as the mean of the related
circumscribing circle of all patches belonging to class i. CIRCLE describes
the ratio between the patch area and the smallest circumscribing circle of the patch
and characterises the compactness of the patch.
</p>
<p>Because the metric is based on distances or areas please make sure your data
is valid using <code><a href="#topic+check_landscape">check_landscape</a></code>.
</p>


<h4>Units</h4>

<p>None</p>



<h4>Range</h4>

<p>CIRCLE_MN &gt; 0</p>



<h4>Behaviour</h4>

<p>Approaches CIRCLE_MN = 0 if the related circumscribing circle
of all patches is small. Increases, without limit, as the related circumscribing circles
increase.</p>



<h3>Value</h3>

<p>tibble
</p>


<h3>References</h3>

<p>McGarigal K., SA Cushman, and E Ene. 2023. FRAGSTATS v4: Spatial Pattern Analysis
Program for Categorical Maps. Computer software program produced by the authors;
available at the following web site: https://www.fragstats.org
</p>
<p>Baker, W. L., and Y. Cai. 1992. The r.le programs for multiscale analysis of
landscape structure using the GRASS geographical information system.
Landscape Ecology 7: 291-302.
</p>
<p>Based on C++ code from Project Nayuki (https://www.nayuki.io/page/smallest-enclosing-circle).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lsm_p_circle">lsm_p_circle</a></code>,
<code><a href="base.html#topic+mean">mean</a></code>, <br />
<code><a href="#topic+lsm_c_circle_sd">lsm_c_circle_sd</a></code>,
<code><a href="#topic+lsm_c_circle_cv">lsm_c_circle_cv</a></code>, <br />
<code><a href="#topic+lsm_l_circle_mn">lsm_l_circle_mn</a></code>,
<code><a href="#topic+lsm_l_circle_sd">lsm_l_circle_sd</a></code>,
<code><a href="#topic+lsm_l_circle_cv">lsm_l_circle_cv</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>landscape &lt;- terra::rast(landscapemetrics::landscape)
lsm_c_circle_mn(landscape)

</code></pre>

<hr>
<h2 id='lsm_c_circle_sd'>CIRCLE_SD (Class level)</h2><span id='topic+lsm_c_circle_sd'></span>

<h3>Description</h3>

<p>Standard deviation of related circumscribing circle (Shape metric)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lsm_c_circle_sd(landscape, directions = 8)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lsm_c_circle_sd_+3A_landscape">landscape</code></td>
<td>
<p>A categorical raster object: SpatRaster; Raster* Layer, Stack, Brick; stars or a list of SpatRasters.</p>
</td></tr>
<tr><td><code id="lsm_c_circle_sd_+3A_directions">directions</code></td>
<td>
<p>The number of directions in which patches should be connected: 4 (rook's case) or 8 (queen's case).</p>
</td></tr>
</table>


<h3>Details</h3>

<p style="text-align: center;"><code class="reqn">CIRCLE_{SD} = sd(CIRCLE[patch_{ij}])</code>
</p>

<p>where <code class="reqn">CIRCLE[patch_{ij}]</code> is the related circumscribing circle of each patch.
</p>
<p>CIRCLE_SD is a 'Shape metric' and summarises each class as the standard deviation of
the related circumscribing circle of all patches belonging to class i. CIRCLE describes
the ratio between the patch area and the smallest circumscribing circle of the patch
and characterises the compactness of the patch. The metric describes the differences
among patches of the same class i in the landscape.
</p>
<p>Because the metric is based on distances or areas please make sure your data
is valid using <code><a href="#topic+check_landscape">check_landscape</a></code>.
</p>


<h4>Units</h4>

<p>None</p>



<h4>Range</h4>

<p>CIRCLE_SD &gt;= 0</p>



<h4>Behaviour</h4>

<p>Equals CIRCLE_SD if the related circumscribing circle is identical
for all patches. Increases, without limit, as the variation of related circumscribing
circles increases.</p>



<h3>Value</h3>

<p>tibble
</p>


<h3>References</h3>

<p>McGarigal K., SA Cushman, and E Ene. 2023. FRAGSTATS v4: Spatial Pattern Analysis
Program for Categorical Maps. Computer software program produced by the authors;
available at the following web site: https://www.fragstats.org
</p>
<p>Baker, W. L., and Y. Cai. 1992. The r.le programs for multiscale analysis of
landscape structure using the GRASS geographical information system.
Landscape Ecology 7: 291-302.
</p>
<p>Based on C++ code from Project Nayuki (https://www.nayuki.io/page/smallest-enclosing-circle).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lsm_p_circle">lsm_p_circle</a></code>,
<code><a href="base.html#topic+mean">mean</a></code>, <br />
<code><a href="#topic+lsm_c_circle_mn">lsm_c_circle_mn</a></code>,
<code><a href="#topic+lsm_c_circle_cv">lsm_c_circle_cv</a></code>, <br />
<code><a href="#topic+lsm_l_circle_mn">lsm_l_circle_mn</a></code>,
<code><a href="#topic+lsm_l_circle_sd">lsm_l_circle_sd</a></code>,
<code><a href="#topic+lsm_l_circle_cv">lsm_l_circle_cv</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>landscape &lt;- terra::rast(landscapemetrics::landscape)
lsm_c_circle_sd(landscape)

</code></pre>

<hr>
<h2 id='lsm_c_clumpy'>CLUMPY (class level)</h2><span id='topic+lsm_c_clumpy'></span>

<h3>Description</h3>

<p>Clumpiness index (Aggregation metric)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lsm_c_clumpy(landscape)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lsm_c_clumpy_+3A_landscape">landscape</code></td>
<td>
<p>A categorical raster object: SpatRaster; Raster* Layer, Stack, Brick; stars or a list of SpatRasters</p>
</td></tr>
</table>


<h3>Details</h3>

<p style="text-align: center;"><code class="reqn">Given G_{i} = \Bigg(\frac{g_{ii}}{ (\sum\limits_{k=1}^m g_{ik}) - min e_{i}} \Bigg)</code>
</p>

<p style="text-align: center;"><code class="reqn">CLUMPY = \Bigg[ \frac{G_{i} - P_{i}}{P_{i}} for G_{i} &lt; P_{i} \&amp; P_{i} &lt; .5; else \\  \frac{G_{i} - P_{i}}{1 -P_{i}} \Bigg] </code>
</p>

<p>where <code class="reqn">g_{ii}</code> is the number of like adjacencies, <code class="reqn">g_{ik}</code> is the classwise
number of all adjacencies including the focal class, <code class="reqn">min e_{i}</code> is the
minimum perimeter of the total class in terms of cell surfaces assuming total clumping and
<code class="reqn">P_{i}</code> is the proportion of landscape occupied by each class.
</p>
<p>CLUMPY is an 'Aggregation metric'. It equals the proportional deviation of
the proportion of like adjacencies involving the corresponding class from that expected
under a spatially random distribution. The metric is based on he adjacency matrix and the
the double-count method.
</p>


<h4>Units</h4>

<p>None</p>



<h4>Range</h4>

<p>-1 &lt;= CLUMPY &lt;= 1</p>



<h4>Behaviour</h4>

<p>Equals -1 for maximally disaggregated, 0 for randomly distributed
and 1 for maximally aggregated classes.</p>



<h3>Value</h3>

<p>tibble
</p>


<h3>References</h3>

<p>McGarigal K., SA Cushman, and E Ene. 2023. FRAGSTATS v4: Spatial Pattern Analysis
Program for Categorical Maps. Computer software program produced by the authors;
available at the following web site: https://www.fragstats.org
</p>


<h3>Examples</h3>

<pre><code class='language-R'>landscape &lt;- terra::rast(landscapemetrics::landscape)
lsm_c_clumpy(landscape)

</code></pre>

<hr>
<h2 id='lsm_c_cohesion'>COHESION (class level)</h2><span id='topic+lsm_c_cohesion'></span>

<h3>Description</h3>

<p>Patch Cohesion Index (Aggregation metric)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lsm_c_cohesion(landscape, directions = 8)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lsm_c_cohesion_+3A_landscape">landscape</code></td>
<td>
<p>A categorical raster object: SpatRaster; Raster* Layer, Stack, Brick; stars or a list of SpatRasters.</p>
</td></tr>
<tr><td><code id="lsm_c_cohesion_+3A_directions">directions</code></td>
<td>
<p>The number of directions in which patches should be
connected: 4 (rook's case) or 8 (queen's case).</p>
</td></tr>
</table>


<h3>Details</h3>

<p style="text-align: center;"><code class="reqn">COHESION = 1 - (\frac{\sum \limits_{j = 1}^{n} p_{ij}} {\sum \limits_{j = 1}^{n} p_{ij} \sqrt{a_{ij}}}) * (1 - \frac{1} {\sqrt{Z}}) ^ {-1} * 100</code>
</p>

<p>where <code class="reqn">p_{ij}</code> is the perimeter in meters, <code class="reqn">a_{ij}</code> is the area in square
meters and <code class="reqn">Z</code> is the number of cells.
</p>
<p>COHESION is an 'Aggregation metric'. It characterises the connectedness of patches
belonging to class i. It can be used to asses if patches of the same class are located
aggregated or rather isolated and thereby COHESION gives information about the
configuration of the landscape.
</p>
<p>Because the metric is based on distances or areas please make sure your data
is valid using <code><a href="#topic+check_landscape">check_landscape</a></code>.
</p>


<h4>Units</h4>

<p>Percent</p>



<h4>Ranges</h4>

<p>0 &lt; COHESION &lt; 100</p>



<h4>Behaviour</h4>

<p>Approaches COHESION = 0 if patches of class i become more isolated.
Increases if patches of class i become more aggregated.</p>



<h3>Value</h3>

<p>tibble
</p>


<h3>References</h3>

<p>McGarigal K., SA Cushman, and E Ene. 2023. FRAGSTATS v4: Spatial Pattern Analysis
Program for Categorical Maps. Computer software program produced by the authors;
available at the following web site: https://www.fragstats.org
</p>
<p>Schumaker, N. H. 1996. Using landscape indices to predict habitat
connectivity. Ecology, 77(4), 1210-1225.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lsm_p_perim">lsm_p_perim</a></code>,
<code><a href="#topic+lsm_p_area">lsm_p_area</a></code>, <br />
<code><a href="#topic+lsm_l_cohesion">lsm_l_cohesion</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>landscape &lt;- terra::rast(landscapemetrics::landscape)
lsm_c_cohesion(landscape)

</code></pre>

<hr>
<h2 id='lsm_c_contig_cv'>CONTIG_CV (class level)</h2><span id='topic+lsm_c_contig_cv'></span>

<h3>Description</h3>

<p>Coefficient of variation of Contiguity index (Shape metric)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lsm_c_contig_cv(landscape, directions = 8)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lsm_c_contig_cv_+3A_landscape">landscape</code></td>
<td>
<p>A categorical raster object: SpatRaster; Raster* Layer, Stack, Brick; stars or a list of SpatRasters.</p>
</td></tr>
<tr><td><code id="lsm_c_contig_cv_+3A_directions">directions</code></td>
<td>
<p>The number of directions in which patches should be connected: 4 (rook's case) or 8 (queen's case).</p>
</td></tr>
</table>


<h3>Details</h3>

<p style="text-align: center;"><code class="reqn">CONTIG_{CV} =  cv(CONTIG[patch_{ij}])</code>
</p>

<p>where <code class="reqn">CONTIG[patch_{ij}]</code> is the contiguity of each patch.
</p>
<p>CONTIG_CV is a 'Shape metric'. It summarises each class as the mean of each patch
belonging to class i. CONTIG_CV asses the spatial connectedness (contiguity) of
cells in patches. The metric coerces patch values to a value of 1 and the background
to NA. A nine cell focal filter matrix:
</p>
<div class="sourceCode"><pre>filter_matrix &lt;- matrix(c(1, 2, 1,
                          2, 1, 2,
                          1, 2, 1), 3, 3, byrow = T)
</pre></div>
<p>... is then used to weight orthogonally contiguous pixels more heavily than
diagonally contiguous pixels. Therefore, larger and more connections between
patch cells in the rookie case result in larger contiguity index values.
</p>


<h4>Units</h4>

<p>None</p>



<h4>Range</h4>

<p>CONTIG_CV &gt;= 0</p>



<h4>Behaviour</h4>

<p>CONTIG_CV = 0 if the contiguity index is
identical for all patches. Increases, without limit, as the variation of
CONTIG increases.</p>



<h3>Value</h3>

<p>tibble
</p>


<h3>References</h3>

<p>McGarigal K., SA Cushman, and E Ene. 2023. FRAGSTATS v4: Spatial Pattern Analysis
Program for Categorical Maps. Computer software program produced by the authors;
available at the following web site: https://www.fragstats.org
</p>
<p>LaGro, J. 1991. Assessing patch shape in landscape mosaics.
Photogrammetric Engineering and Remote Sensing, 57(3), 285-293
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lsm_p_contig">lsm_p_contig</a></code>,
<code><a href="#topic+lsm_c_contig_mn">lsm_c_contig_mn</a></code>,
<code><a href="#topic+lsm_c_contig_cv">lsm_c_contig_cv</a></code>, <br />
<code><a href="#topic+lsm_l_contig_mn">lsm_l_contig_mn</a></code>,
<code><a href="#topic+lsm_l_contig_sd">lsm_l_contig_sd</a></code>,
<code><a href="#topic+lsm_l_contig_cv">lsm_l_contig_cv</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>landscape &lt;- terra::rast(landscapemetrics::landscape)
lsm_c_contig_cv(landscape)

</code></pre>

<hr>
<h2 id='lsm_c_contig_mn'>CONTIG_MN (class level)</h2><span id='topic+lsm_c_contig_mn'></span>

<h3>Description</h3>

<p>Mean of Contiguity index (Shape metric)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lsm_c_contig_mn(landscape, directions = 8)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lsm_c_contig_mn_+3A_landscape">landscape</code></td>
<td>
<p>A categorical raster object: SpatRaster; Raster* Layer, Stack, Brick; stars or a list of SpatRasters.</p>
</td></tr>
<tr><td><code id="lsm_c_contig_mn_+3A_directions">directions</code></td>
<td>
<p>The number of directions in which patches should be connected: 4 (rook's case) or 8 (queen's case).</p>
</td></tr>
</table>


<h3>Details</h3>

<p style="text-align: center;"><code class="reqn">CONTIG_{MN} =  mean(CONTIG[patch_{ij}])</code>
</p>

<p>where <code class="reqn">CONTIG[patch_{ij}]</code> is the contiguity of each patch.
</p>
<p>CONTIG_MN is a 'Shape metric'. It summarises each class as the mean of each patch
belonging to class i. CONTIG_MN asses the spatial connectedness (contiguity) of
cells in patches. The metric coerces patch values to a value of 1 and the background
to NA. A nine cell focal filter matrix:
</p>
<div class="sourceCode"><pre>filter_matrix &lt;- matrix(c(1, 2, 1,
                          2, 1, 2,
                          1, 2, 1), 3, 3, byrow = T)
</pre></div>
<p>... is then used to weight orthogonally contiguous pixels more heavily than
diagonally contiguous pixels. Therefore, larger and more connections between
patch cells in the rookie case result in larger contiguity index values.
</p>


<h4>Units</h4>

<p>None</p>



<h4>Range</h4>

<p>0 &gt;= CONTIG_MN &lt;= 1</p>



<h4>Behaviour</h4>

<p>CONTIG equals the mean of the contiguity index on class level for all
patches.</p>



<h3>Value</h3>

<p>tibble
</p>


<h3>References</h3>

<p>McGarigal K., SA Cushman, and E Ene. 2023. FRAGSTATS v4: Spatial Pattern Analysis
Program for Categorical Maps. Computer software program produced by the authors;
available at the following web site: https://www.fragstats.org
</p>
<p>LaGro, J. 1991. Assessing patch shape in landscape mosaics.
Photogrammetric Engineering and Remote Sensing, 57(3), 285-293
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lsm_p_contig">lsm_p_contig</a></code>,
<code><a href="#topic+lsm_c_contig_sd">lsm_c_contig_sd</a></code>,
<code><a href="#topic+lsm_c_contig_cv">lsm_c_contig_cv</a></code>, <br />
<code><a href="#topic+lsm_l_contig_mn">lsm_l_contig_mn</a></code>,
<code><a href="#topic+lsm_l_contig_sd">lsm_l_contig_sd</a></code>,
<code><a href="#topic+lsm_l_contig_cv">lsm_l_contig_cv</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>landscape &lt;- terra::rast(landscapemetrics::landscape)
lsm_c_contig_mn(landscape)

</code></pre>

<hr>
<h2 id='lsm_c_contig_sd'>CONTIG_SD (class level)</h2><span id='topic+lsm_c_contig_sd'></span>

<h3>Description</h3>

<p>Standard deviation of Contiguity index (Shape metric)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lsm_c_contig_sd(landscape, directions = 8)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lsm_c_contig_sd_+3A_landscape">landscape</code></td>
<td>
<p>A categorical raster object: SpatRaster; Raster* Layer, Stack, Brick; stars or a list of SpatRasters.</p>
</td></tr>
<tr><td><code id="lsm_c_contig_sd_+3A_directions">directions</code></td>
<td>
<p>The number of directions in which patches should be connected: 4 (rook's case) or 8 (queen's case).</p>
</td></tr>
</table>


<h3>Details</h3>

<p style="text-align: center;"><code class="reqn">CONTIG_{SD} =  sd(CONTIG[patch_{ij}])</code>
</p>

<p>where <code class="reqn">CONTIG[patch_{ij}]</code> is the contiguity of each patch.
</p>
<p>CONTIG_SD is a 'Shape metric'. It summarises each class as the mean of each patch
belonging to class i. CONTIG_SD asses the spatial connectedness (contiguity) of
cells in patches. The metric coerces patch values to a value of 1 and the background
to NA. A nine cell focal filter matrix:
</p>
<div class="sourceCode"><pre>filter_matrix &lt;- matrix(c(1, 2, 1,
                          2, 1, 2,
                          1, 2, 1), 3, 3, byrow = T)
</pre></div>
<p>... is then used to weight orthogonally contiguous pixels more heavily than
diagonally contiguous pixels. Therefore, larger and more connections between
patch cells in the rookie case result in larger contiguity index values.
</p>


<h4>Units</h4>

<p>None</p>



<h4>Range</h4>

<p>CONTIG_CV &gt;= 0</p>



<h4>Behaviour</h4>

<p>CONTIG_SD = 0 if the contiguity index is
identical for all patches. Increases, without limit, as the variation of
CONTIG increases.</p>



<h3>Value</h3>

<p>tibble
</p>


<h3>References</h3>

<p>McGarigal K., SA Cushman, and E Ene. 2023. FRAGSTATS v4: Spatial Pattern Analysis
Program for Categorical Maps. Computer software program produced by the authors;
available at the following web site: https://www.fragstats.org
</p>
<p>LaGro, J. 1991. Assessing patch shape in landscape mosaics.
Photogrammetric Engineering and Remote Sensing, 57(3), 285-293
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lsm_p_contig">lsm_p_contig</a></code>,
<code><a href="#topic+lsm_c_contig_mn">lsm_c_contig_mn</a></code>,
<code><a href="#topic+lsm_c_contig_cv">lsm_c_contig_cv</a></code>, <br />
<code><a href="#topic+lsm_l_contig_mn">lsm_l_contig_mn</a></code>,
<code><a href="#topic+lsm_l_contig_sd">lsm_l_contig_sd</a></code>,
<code><a href="#topic+lsm_l_contig_cv">lsm_l_contig_cv</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>landscape &lt;- terra::rast(landscapemetrics::landscape)
lsm_c_contig_sd(landscape)

</code></pre>

<hr>
<h2 id='lsm_c_core_cv'>CORE_CV (class level)</h2><span id='topic+lsm_c_core_cv'></span>

<h3>Description</h3>

<p>Coefficient of variation of core area (Core area metric)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lsm_c_core_cv(
  landscape,
  directions = 8,
  consider_boundary = FALSE,
  edge_depth = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lsm_c_core_cv_+3A_landscape">landscape</code></td>
<td>
<p>A categorical raster object: SpatRaster; Raster* Layer, Stack, Brick; stars or a list of SpatRasters.</p>
</td></tr>
<tr><td><code id="lsm_c_core_cv_+3A_directions">directions</code></td>
<td>
<p>The number of directions in which patches should be connected: 4 (rook's case) or 8 (queen's case).</p>
</td></tr>
<tr><td><code id="lsm_c_core_cv_+3A_consider_boundary">consider_boundary</code></td>
<td>
<p>Logical if cells that only neighbour the landscape
boundary should be considered as core</p>
</td></tr>
<tr><td><code id="lsm_c_core_cv_+3A_edge_depth">edge_depth</code></td>
<td>
<p>Distance (in cells) a cell has the be away from the patch
edge to be considered as core cell</p>
</td></tr>
</table>


<h3>Details</h3>

<p style="text-align: center;"><code class="reqn">CORE_{CV} = cv(CORE[patch_{ij}])</code>
</p>

<p>where <code class="reqn">CORE[patch_{ij}]</code> is the core area in square meters of each patch.
</p>
<p>CORE_CV is a 'Core area metric'. It equals the Coefficient of variation of the core area
of each patch belonging to class i. The core area is defined as all cells that have no
neighbour with a different value than themselves (rook's case). The metric describes the
differences among patches of the same class i in the landscape and is easily comparable
because it is scaled to the mean.
</p>
<p>Because the metric is based on distances or areas please make sure your data
is valid using <code><a href="#topic+check_landscape">check_landscape</a></code>.
</p>


<h4>Units</h4>

<p>Hectares</p>



<h4>Range</h4>

<p>CORE_CV &gt;= 0</p>



<h4>Behaviour</h4>

<p>Equals CORE_CV = 0 if all patches have the same core area.
Increases, without limit, as the variation of patch core areas increases.</p>



<h3>Value</h3>

<p>tibble
</p>


<h3>References</h3>

<p>McGarigal K., SA Cushman, and E Ene. 2023. FRAGSTATS v4: Spatial Pattern Analysis
Program for Categorical Maps. Computer software program produced by the authors;
available at the following web site: https://www.fragstats.org
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lsm_p_core">lsm_p_core</a></code>, <br />
<code><a href="#topic+lsm_c_core_mn">lsm_c_core_mn</a></code>,
<code><a href="#topic+lsm_c_core_sd">lsm_c_core_sd</a></code>, <br />
<code><a href="#topic+lsm_l_core_mn">lsm_l_core_mn</a></code>,
<code><a href="#topic+lsm_l_core_sd">lsm_l_core_sd</a></code>,
<code><a href="#topic+lsm_l_core_cv">lsm_l_core_cv</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>landscape &lt;- terra::rast(landscapemetrics::landscape)
lsm_c_core_cv(landscape)

</code></pre>

<hr>
<h2 id='lsm_c_core_mn'>CORE_MN (class level)</h2><span id='topic+lsm_c_core_mn'></span>

<h3>Description</h3>

<p>Mean of core area (Core area metric)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lsm_c_core_mn(
  landscape,
  directions = 8,
  consider_boundary = FALSE,
  edge_depth = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lsm_c_core_mn_+3A_landscape">landscape</code></td>
<td>
<p>A categorical raster object: SpatRaster; Raster* Layer, Stack, Brick; stars or a list of SpatRasters.</p>
</td></tr>
<tr><td><code id="lsm_c_core_mn_+3A_directions">directions</code></td>
<td>
<p>The number of directions in which patches should be connected: 4 (rook's case) or 8 (queen's case).</p>
</td></tr>
<tr><td><code id="lsm_c_core_mn_+3A_consider_boundary">consider_boundary</code></td>
<td>
<p>Logical if cells that only neighbour the landscape
boundary should be considered as core</p>
</td></tr>
<tr><td><code id="lsm_c_core_mn_+3A_edge_depth">edge_depth</code></td>
<td>
<p>Distance (in cells) a cell has the be away from the patch
edge to be considered as core cell</p>
</td></tr>
</table>


<h3>Details</h3>

<p style="text-align: center;"><code class="reqn">CORE_{MN} = mean(CORE[patch_{ij}])</code>
</p>

<p>where <code class="reqn">CORE[patch_{ij}]</code> is the core area in square meters of each patch.
</p>
<p>CORE_MN is a 'Core area metric' and equals the mean of core areas of all patches
belonging to class i. The core area is defined as all cells that have no
neighbour with a different value than themselves (rook's case).
</p>
<p>Because the metric is based on distances or areas please make sure your data
is valid using <code><a href="#topic+check_landscape">check_landscape</a></code>.
</p>


<h4>Units</h4>

<p>Hectares</p>



<h4>Range</h4>

<p>CORE_MN &gt;= 0</p>



<h4>Behaviour</h4>

<p>Equals CORE_MN = 0 if CORE = 0 for all patches. Increases,
without limit, as the core area indices increase.</p>



<h3>Value</h3>

<p>tibble
</p>


<h3>References</h3>

<p>McGarigal K., SA Cushman, and E Ene. 2023. FRAGSTATS v4: Spatial Pattern Analysis
Program for Categorical Maps. Computer software program produced by the authors;
available at the following web site: https://www.fragstats.org
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lsm_p_core">lsm_p_core</a></code>,
<code><a href="base.html#topic+mean">mean</a></code>, <br />
<code><a href="#topic+lsm_c_core_sd">lsm_c_core_sd</a></code>,
<code><a href="#topic+lsm_c_core_cv">lsm_c_core_cv</a></code>, <br />
<code><a href="#topic+lsm_l_core_mn">lsm_l_core_mn</a></code>,
<code><a href="#topic+lsm_l_core_sd">lsm_l_core_sd</a></code>,
<code><a href="#topic+lsm_l_core_cv">lsm_l_core_cv</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>landscape &lt;- terra::rast(landscapemetrics::landscape)
lsm_c_core_mn(landscape)

</code></pre>

<hr>
<h2 id='lsm_c_core_sd'>CORE_SD (class level)</h2><span id='topic+lsm_c_core_sd'></span>

<h3>Description</h3>

<p>Standard deviation patch core area (class level)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lsm_c_core_sd(
  landscape,
  directions = 8,
  consider_boundary = FALSE,
  edge_depth = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lsm_c_core_sd_+3A_landscape">landscape</code></td>
<td>
<p>A categorical raster object: SpatRaster; Raster* Layer, Stack, Brick; stars or a list of SpatRasters.</p>
</td></tr>
<tr><td><code id="lsm_c_core_sd_+3A_directions">directions</code></td>
<td>
<p>The number of directions in which patches should be connected: 4 (rook's case) or 8 (queen's case).</p>
</td></tr>
<tr><td><code id="lsm_c_core_sd_+3A_consider_boundary">consider_boundary</code></td>
<td>
<p>Logical if cells that only neighbour the landscape
boundary should be considered as core</p>
</td></tr>
<tr><td><code id="lsm_c_core_sd_+3A_edge_depth">edge_depth</code></td>
<td>
<p>Distance (in cells) a cell has the be away from the patch
edge to be considered as core cell</p>
</td></tr>
</table>


<h3>Details</h3>

<p style="text-align: center;"><code class="reqn">CORE_{SD} = sd(CORE[patch_{ij}])</code>
</p>

<p>where <code class="reqn">CORE[patch_{ij}]</code> is the core area in square meters of each patch.
</p>
<p>CORE_SD is a 'Core area metric'. It equals the standard deviation of the core area
of each patch belonging to class i. The core area is defined as all cells that have no
neighbour with a different value than themselves (rook's case). The metric describes the
differences among patches of the same class i in the landscape.
</p>
<p>Because the metric is based on distances or areas please make sure your data
is valid using <code><a href="#topic+check_landscape">check_landscape</a></code>.
</p>


<h4>Units</h4>

<p>Hectares</p>



<h4>Range</h4>

<p>CORE_SD &gt;= 0</p>



<h4>Behaviour</h4>

<p>Equals CORE_SD = 0 if all patches have the same core area.
Increases, without limit, as the variation of patch core areas increases.</p>



<h3>Value</h3>

<p>tibble
</p>


<h3>References</h3>

<p>McGarigal K., SA Cushman, and E Ene. 2023. FRAGSTATS v4: Spatial Pattern Analysis
Program for Categorical Maps. Computer software program produced by the authors;
available at the following web site: https://www.fragstats.org
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lsm_p_core">lsm_p_core</a></code>,
<code><a href="stats.html#topic+sd">sd</a></code> <br />
<code><a href="#topic+lsm_c_core_mn">lsm_c_core_mn</a></code>,
<code><a href="#topic+lsm_c_core_cv">lsm_c_core_cv</a></code>, <br />
<code><a href="#topic+lsm_l_core_mn">lsm_l_core_mn</a></code>,
<code><a href="#topic+lsm_l_core_sd">lsm_l_core_sd</a></code>,
<code><a href="#topic+lsm_l_core_cv">lsm_l_core_cv</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>landscape &lt;- terra::rast(landscapemetrics::landscape)
lsm_c_core_sd(landscape)

</code></pre>

<hr>
<h2 id='lsm_c_cpland'>CPLAND (class level)</h2><span id='topic+lsm_c_cpland'></span>

<h3>Description</h3>

<p>Core area percentage of landscape (Core area metric)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lsm_c_cpland(
  landscape,
  directions = 8,
  consider_boundary = FALSE,
  edge_depth = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lsm_c_cpland_+3A_landscape">landscape</code></td>
<td>
<p>A categorical raster object: SpatRaster; Raster* Layer, Stack, Brick; stars or a list of SpatRasters.</p>
</td></tr>
<tr><td><code id="lsm_c_cpland_+3A_directions">directions</code></td>
<td>
<p>The number of directions in which patches should be
connected: 4 (rook's case) or 8 (queen's case).</p>
</td></tr>
<tr><td><code id="lsm_c_cpland_+3A_consider_boundary">consider_boundary</code></td>
<td>
<p>Logical if cells that only neighbour the landscape
boundary should be considered as core</p>
</td></tr>
<tr><td><code id="lsm_c_cpland_+3A_edge_depth">edge_depth</code></td>
<td>
<p>Distance (in cells) a cell has the be away from the patch
edge to be considered as core cell</p>
</td></tr>
</table>


<h3>Details</h3>

<p style="text-align: center;"><code class="reqn">CPLAND = (\frac{\sum \limits_{j = 1}^{n} a_{ij}^{core}} {A}) * 100</code>
</p>

<p>where <code class="reqn">a_{ij}^{core}</code> is the core area in square meters and <code class="reqn">A</code>
is the total landscape area in square meters.
</p>
<p>CPLAND is a 'Core area metric'. It is the percentage of core area of class i in relation to
the total landscape area. A cell is defined as core area if the cell has
no neighbour with a different value than itself (rook's case). Because CPLAND is
a relative measure, it is comparable among landscapes with different total areas.
</p>
<p>Because the metric is based on distances or areas please make sure your data
is valid using <code><a href="#topic+check_landscape">check_landscape</a></code>.
</p>


<h4>Units</h4>

<p>Percentage</p>



<h4>Range</h4>

<p>0 &lt;= CPLAND &lt; 100</p>



<h4>Behaviour</h4>

<p>Approaches CPLAND = 0 if CORE = 0 for all patches. Increases as
the amount of core area increases, i.e. patches become larger while being rather simple
in shape.</p>



<h3>Value</h3>

<p>tibble
</p>


<h3>References</h3>

<p>McGarigal K., SA Cushman, and E Ene. 2023. FRAGSTATS v4: Spatial Pattern Analysis
Program for Categorical Maps. Computer software program produced by the authors;
available at the following web site: https://www.fragstats.org
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lsm_p_core">lsm_p_core</a></code> and <code><a href="#topic+lsm_l_ta">lsm_l_ta</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>landscape &lt;- terra::rast(landscapemetrics::landscape)
lsm_c_cpland(landscape)

</code></pre>

<hr>
<h2 id='lsm_c_dcad'>DCAD (class level)</h2><span id='topic+lsm_c_dcad'></span>

<h3>Description</h3>

<p>Disjunct core area density (core area metric)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lsm_c_dcad(
  landscape,
  directions = 8,
  consider_boundary = FALSE,
  edge_depth = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lsm_c_dcad_+3A_landscape">landscape</code></td>
<td>
<p>A categorical raster object: SpatRaster; Raster* Layer, Stack, Brick; stars or a list of SpatRasters.</p>
</td></tr>
<tr><td><code id="lsm_c_dcad_+3A_directions">directions</code></td>
<td>
<p>The number of directions in which patches should be
connected: 4 (rook's case) or 8 (queen's case).</p>
</td></tr>
<tr><td><code id="lsm_c_dcad_+3A_consider_boundary">consider_boundary</code></td>
<td>
<p>Logical if cells that only neighbour the landscape
boundary should be considered as core</p>
</td></tr>
<tr><td><code id="lsm_c_dcad_+3A_edge_depth">edge_depth</code></td>
<td>
<p>Distance (in cells) a cell has the be away from the patch
edge to be considered as core cell</p>
</td></tr>
</table>


<h3>Details</h3>

<p style="text-align: center;"><code class="reqn">DCAD = (\frac{\sum \limits_{j = 1}^{n} n_{ij}^{core}} {A}) * 10000 * 100</code>
</p>

<p>where <code class="reqn">n_{ij}^{core}</code> is the number of disjunct core areas and <code class="reqn">A</code>
is the total landscape area in square meters.
</p>
<p>DCAD is a 'Core area metric'. It equals the number of disjunct core areas per
100 ha relative to the total area. A disjunct core area is a 'patch within
the patch' containing only core cells. A cell is defined as core area if the cell has no
neighbour with a different value than itself (rook's case). The metric is relative and
therefore comparable among landscapes with different total areas.
</p>
<p>Because the metric is based on distances or areas please make sure your data
is valid using <code><a href="#topic+check_landscape">check_landscape</a></code>.
</p>


<h4>Units</h4>

<p>Number per 100 hectares</p>



<h4>Range</h4>

<p>DCAD &gt;= 0</p>



<h4>Behaviour</h4>

<p>Equals DCAD = 0 when DCORE = 0, i.e. no patch of class i contains
a disjunct core area. Increases, without limit, as disjunct core areas become more
present, i.e. patches becoming larger and less complex.</p>



<h3>Value</h3>

<p>tibble
</p>


<h3>References</h3>

<p>McGarigal K., SA Cushman, and E Ene. 2023. FRAGSTATS v4: Spatial Pattern Analysis
Program for Categorical Maps. Computer software program produced by the authors;
available at the following web site: https://www.fragstats.org
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lsm_c_ndca">lsm_c_ndca</a></code>,
<code><a href="#topic+lsm_l_ta">lsm_l_ta</a></code>, <br />
<code><a href="#topic+lsm_l_dcad">lsm_l_dcad</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>landscape &lt;- terra::rast(landscapemetrics::landscape)
lsm_c_dcad(landscape)

</code></pre>

<hr>
<h2 id='lsm_c_dcore_cv'>DCORE_CV (class level)</h2><span id='topic+lsm_c_dcore_cv'></span>

<h3>Description</h3>

<p>Coefficient of variation number of disjunct core areas (Core area metric)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lsm_c_dcore_cv(
  landscape,
  directions = 8,
  consider_boundary = FALSE,
  edge_depth = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lsm_c_dcore_cv_+3A_landscape">landscape</code></td>
<td>
<p>A categorical raster object: SpatRaster; Raster* Layer, Stack, Brick; stars or a list of SpatRasters.</p>
</td></tr>
<tr><td><code id="lsm_c_dcore_cv_+3A_directions">directions</code></td>
<td>
<p>The number of directions in which patches should be
connected: 4 (rook's case) or 8 (queen's case).</p>
</td></tr>
<tr><td><code id="lsm_c_dcore_cv_+3A_consider_boundary">consider_boundary</code></td>
<td>
<p>Logical if cells that only neighbour the landscape
boundary should be considered as core</p>
</td></tr>
<tr><td><code id="lsm_c_dcore_cv_+3A_edge_depth">edge_depth</code></td>
<td>
<p>Distance (in cells) a cell has the be away from the patch
edge to be considered as core cell</p>
</td></tr>
</table>


<h3>Details</h3>

<p style="text-align: center;"><code class="reqn">DCORE_{CV} = cv(NCORE[patch_{ij}])</code>
</p>

<p>where <code class="reqn">NCORE[patch_{ij}]</code> is the number of core areas.
</p>
<p>DCORE_CV is an 'Core area metric'. It summarises each class as the Coefficient
of variation of all patch areas belonging to class i. A cell is defined as core if the cell
has no neighbour with a different value than itself (rook's case). NCORE counts the disjunct
core areas, whereby a core area is a 'patch within the patch' containing only core cells.
The metric describes the differences among patches of the same class i in
the landscape and is easily comparable because it is scaled to the mean.
</p>


<h4>Units</h4>

<p>None</p>



<h4>Range</h4>

<p>DCORE_CV &gt;= 0</p>



<h4>Behaviour</h4>

<p>Equals DCORE_CV = 0 if all patches have the same number of disjunct
core areas. Increases, without limit, as the variation of number of disjunct core areas
increases.</p>



<h3>Value</h3>

<p>tibble
</p>


<h3>References</h3>

<p>McGarigal K., SA Cushman, and E Ene. 2023. FRAGSTATS v4: Spatial Pattern Analysis
Program for Categorical Maps. Computer software program produced by the authors;
available at the following web site: https://www.fragstats.org
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lsm_p_ncore">lsm_p_ncore</a></code>, <br />
<code><a href="#topic+lsm_c_dcore_mn">lsm_c_dcore_mn</a></code>,
<code><a href="#topic+lsm_c_dcore_sd">lsm_c_dcore_sd</a></code>, <br />
<code><a href="#topic+lsm_l_dcore_mn">lsm_l_dcore_mn</a></code>,
<code><a href="#topic+lsm_l_dcore_sd">lsm_l_dcore_sd</a></code>,
<code><a href="#topic+lsm_l_dcore_cv">lsm_l_dcore_cv</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>landscape &lt;- terra::rast(landscapemetrics::landscape)
lsm_c_dcore_cv(landscape)

</code></pre>

<hr>
<h2 id='lsm_c_dcore_mn'>DCORE_MN (class level)</h2><span id='topic+lsm_c_dcore_mn'></span>

<h3>Description</h3>

<p>Mean number of disjunct core areas (Core area metric)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lsm_c_dcore_mn(
  landscape,
  directions = 8,
  consider_boundary = FALSE,
  edge_depth = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lsm_c_dcore_mn_+3A_landscape">landscape</code></td>
<td>
<p>A categorical raster object: SpatRaster; Raster* Layer, Stack, Brick; stars or a list of SpatRasters.</p>
</td></tr>
<tr><td><code id="lsm_c_dcore_mn_+3A_directions">directions</code></td>
<td>
<p>The number of directions in which patches should be
connected: 4 (rook's case) or 8 (queen's case).</p>
</td></tr>
<tr><td><code id="lsm_c_dcore_mn_+3A_consider_boundary">consider_boundary</code></td>
<td>
<p>Logical if cells that only neighbour the landscape
boundary should be considered as core</p>
</td></tr>
<tr><td><code id="lsm_c_dcore_mn_+3A_edge_depth">edge_depth</code></td>
<td>
<p>Distance (in cells) a cell has the be away from the patch
edge to be considered as core cell</p>
</td></tr>
</table>


<h3>Details</h3>

<p style="text-align: center;"><code class="reqn">DCORE_{MN} = mean(NCORE[patch_{ij}])</code>
</p>

<p>where <code class="reqn">NCORE[patch_{ij}]</code> is the number of core areas.
</p>
<p>DCORE_MN is an 'Core area metric'. It summarises each class as the mean of all
patch areas belonging to class i. A cell is defined as core if the cell
has no neighbour with a different value than itself (rook's case). NCORE counts the disjunct
core areas, whereby a core area is a 'patch within the patch' containing only core cells.
</p>


<h4>Units</h4>

<p>None</p>



<h4>Range</h4>

<p>DCORE_MN &gt; 0</p>



<h4>Behaviour</h4>

<p>Equals DCORE_MN = 0 if NCORE = 0 for all patches. Increases,
without limit, as the number of disjunct core areas increases.</p>



<h3>Value</h3>

<p>tibble
</p>


<h3>References</h3>

<p>McGarigal K., SA Cushman, and E Ene. 2023. FRAGSTATS v4: Spatial Pattern Analysis
Program for Categorical Maps. Computer software program produced by the authors;
available at the following web site: https://www.fragstats.org
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lsm_p_ncore">lsm_p_ncore</a></code>,
<code><a href="base.html#topic+mean">mean</a></code>, <br />
<code><a href="#topic+lsm_c_dcore_sd">lsm_c_dcore_sd</a></code>,
<code><a href="#topic+lsm_c_dcore_cv">lsm_c_dcore_cv</a></code>, <br />
<code><a href="#topic+lsm_l_dcore_mn">lsm_l_dcore_mn</a></code>,
<code><a href="#topic+lsm_l_dcore_sd">lsm_l_dcore_sd</a></code>,
<code><a href="#topic+lsm_l_dcore_cv">lsm_l_dcore_cv</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>landscape &lt;- terra::rast(landscapemetrics::landscape)
lsm_c_dcore_mn(landscape)

</code></pre>

<hr>
<h2 id='lsm_c_dcore_sd'>DCORE_SD (class level)</h2><span id='topic+lsm_c_dcore_sd'></span>

<h3>Description</h3>

<p>Standard deviation number of disjunct core areas (Core area metric)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lsm_c_dcore_sd(
  landscape,
  directions = 8,
  consider_boundary = FALSE,
  edge_depth = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lsm_c_dcore_sd_+3A_landscape">landscape</code></td>
<td>
<p>A categorical raster object: SpatRaster; Raster* Layer, Stack, Brick; stars or a list of SpatRasters.</p>
</td></tr>
<tr><td><code id="lsm_c_dcore_sd_+3A_directions">directions</code></td>
<td>
<p>The number of directions in which patches should be
connected: 4 (rook's case) or 8 (queen's case).</p>
</td></tr>
<tr><td><code id="lsm_c_dcore_sd_+3A_consider_boundary">consider_boundary</code></td>
<td>
<p>Logical if cells that only neighbour the landscape
boundary should be considered as core</p>
</td></tr>
<tr><td><code id="lsm_c_dcore_sd_+3A_edge_depth">edge_depth</code></td>
<td>
<p>Distance (in cells) a cell has the be away from the patch
edge to be considered as core cell</p>
</td></tr>
</table>


<h3>Details</h3>

<p style="text-align: center;"><code class="reqn">DCORE_{SD} = sd(NCORE[patch_{ij}])</code>
</p>

<p>where <code class="reqn">NCORE[patch_{ij}]</code> is the number of core areas.
</p>
<p>DCORE_SD is an 'Core area metric'. It summarises each class as the standard deviation
of all patch areas belonging to class i. A cell is defined as core if the cell
has no neighbour with a different value than itself (rook's case). NCORE counts the disjunct
core areas, whereby a core area is a 'patch within the patch' containing only core cells.
The metric describes the differences among patches of the same class i in the landscape.
</p>


<h4>Units</h4>

<p>None</p>



<h4>Range</h4>

<p>DCORE_SD &gt;= 0</p>



<h4>Behaviour</h4>

<p>Equals DCORE_SD = 0 if all patches have the same number of disjunct
core areas. Increases, without limit, as the variation of number of disjunct core areas
increases.</p>



<h3>Value</h3>

<p>tibble
</p>


<h3>References</h3>

<p>McGarigal K., SA Cushman, and E Ene. 2023. FRAGSTATS v4: Spatial Pattern Analysis
Program for Categorical Maps. Computer software program produced by the authors;
available at the following web site: https://www.fragstats.org
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lsm_p_ncore">lsm_p_ncore</a></code>,
<code><a href="stats.html#topic+sd">sd</a></code> <br />
<code><a href="#topic+lsm_c_dcore_mn">lsm_c_dcore_mn</a></code>,
<code><a href="#topic+lsm_c_dcore_cv">lsm_c_dcore_cv</a></code>, <br />
<code><a href="#topic+lsm_l_dcore_mn">lsm_l_dcore_mn</a></code>,
<code><a href="#topic+lsm_l_dcore_sd">lsm_l_dcore_sd</a></code>,
<code><a href="#topic+lsm_l_dcore_cv">lsm_l_dcore_cv</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>landscape &lt;- terra::rast(landscapemetrics::landscape)
lsm_c_dcore_sd(landscape)

</code></pre>

<hr>
<h2 id='lsm_c_division'>DIVISION (class level)</h2><span id='topic+lsm_c_division'></span>

<h3>Description</h3>

<p>Landscape division index (Aggregation metric)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lsm_c_division(landscape, directions = 8)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lsm_c_division_+3A_landscape">landscape</code></td>
<td>
<p>A categorical raster object: SpatRaster; Raster* Layer, Stack, Brick; stars or a list of SpatRasters.</p>
</td></tr>
<tr><td><code id="lsm_c_division_+3A_directions">directions</code></td>
<td>
<p>The number of directions in which patches should be connected: 4 (rook's case) or 8 (queen's case).</p>
</td></tr>
</table>


<h3>Details</h3>

<p style="text-align: center;"><code class="reqn">DIVISON = (1 - \sum \limits_{j = 1}^{n} (\frac{a_{ij}} {A}) ^ 2)</code>
</p>

<p>where <code class="reqn">a_{ij}</code> is the area in square meters and <code class="reqn">A</code> is the total
landscape area in square meters.
</p>
<p>DIVISION is an 'Aggregation metric. It can be in as the probability that two
randomly selected cells are not located in the same patch of class i. The landscape
division index is negatively correlated with the  effective mesh size  (<code><a href="#topic+lsm_c_mesh">lsm_c_mesh</a></code>).
</p>
<p>Because the metric is based on distances or areas please make sure your data
is valid using <code><a href="#topic+check_landscape">check_landscape</a></code>.
</p>


<h4>Units</h4>

<p>Proportion </p>



<h4>Ranges</h4>

<p>0 &lt;= Division &lt; 1</p>



<h4>Behaviour</h4>

<p>Equals DIVISION = 0 if only one patch is present. Approaches
DIVISION = 1 if all patches of class i are single cells.</p>



<h3>Value</h3>

<p>tibble
</p>


<h3>References</h3>

<p>McGarigal K., SA Cushman, and E Ene. 2023. FRAGSTATS v4: Spatial Pattern Analysis
Program for Categorical Maps. Computer software program produced by the authors;
available at the following web site: https://www.fragstats.org
</p>
<p>Jaeger, J. A. 2000. Landscape division, splitting index, and effective mesh
size: new measures of landscape fragmentation.
Landscape ecology, 15(2), 115-130.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lsm_p_area">lsm_p_area</a></code>,
<code><a href="#topic+lsm_l_ta">lsm_l_ta</a></code>, <br />
<code><a href="#topic+lsm_l_division">lsm_l_division</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>landscape &lt;- terra::rast(landscapemetrics::landscape)
lsm_c_division(landscape)

</code></pre>

<hr>
<h2 id='lsm_c_ed'>ED (class level)</h2><span id='topic+lsm_c_ed'></span>

<h3>Description</h3>

<p>Edge Density (Area and Edge metric)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lsm_c_ed(landscape, count_boundary = FALSE, directions = 8)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lsm_c_ed_+3A_landscape">landscape</code></td>
<td>
<p>A categorical raster object: SpatRaster; Raster* Layer, Stack, Brick; stars or a list of SpatRasters.</p>
</td></tr>
<tr><td><code id="lsm_c_ed_+3A_count_boundary">count_boundary</code></td>
<td>
<p>Count landscape boundary as edge.</p>
</td></tr>
<tr><td><code id="lsm_c_ed_+3A_directions">directions</code></td>
<td>
<p>The number of directions in which patches should be connected: 4 (rook's case) or 8 (queen's case).</p>
</td></tr>
</table>


<h3>Details</h3>

<p style="text-align: center;"><code class="reqn">ED = \frac{\sum \limits_{k = 1}^{m} e_{ik}} {A} * 10000</code>
</p>

<p>where <code class="reqn">e_{ik}</code> is the total edge length in meters and <code class="reqn">A</code> is the total
landscape area in square meters.
</p>
<p>ED is an 'Area and Edge metric'. The edge density equals the sum of all edges of class i
in relation to the landscape area. The boundary of the landscape is only included in the
corresponding total class edge length if <code>count_boundary = TRUE</code>.
The metric describes the configuration of the landscape, e.g. because  an  aggregation
of the same class will result in a low edge density. The metric is standardized to the
total landscape area, and therefore comparisons among landscapes with different total
areas are possible.
</p>
<p>Because the metric is based on distances or areas please make sure your data
is valid using <code><a href="#topic+check_landscape">check_landscape</a></code>.
</p>


<h4>Units</h4>

<p>Meters per hectare</p>



<h4>Range</h4>

<p>ED &gt;= 0</p>



<h4>Behaviour</h4>

<p>Equals ED = 0 if only one patch is present (and the landscape
boundary is not included) and increases, without limit, as the landscapes becomes more
patchy</p>



<h3>Value</h3>

<p>tibble
</p>


<h3>References</h3>

<p>McGarigal K., SA Cushman, and E Ene. 2023. FRAGSTATS v4: Spatial Pattern Analysis
Program for Categorical Maps. Computer software program produced by the authors;
available at the following web site: https://www.fragstats.org
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lsm_c_te">lsm_c_te</a></code>,
<code><a href="#topic+lsm_l_ta">lsm_l_ta</a></code>, <br />
<code><a href="#topic+lsm_l_ed">lsm_l_ed</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>landscape &lt;- terra::rast(landscapemetrics::landscape)
lsm_c_ed(landscape)

</code></pre>

<hr>
<h2 id='lsm_c_enn_cv'>ENN_CV (class level)</h2><span id='topic+lsm_c_enn_cv'></span>

<h3>Description</h3>

<p>Coefficient of variation of euclidean nearest-neighbor distance (Aggregation metric)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lsm_c_enn_cv(landscape, directions = 8, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lsm_c_enn_cv_+3A_landscape">landscape</code></td>
<td>
<p>A categorical raster object: SpatRaster; Raster* Layer, Stack, Brick; stars or a list of SpatRasters.</p>
</td></tr>
<tr><td><code id="lsm_c_enn_cv_+3A_directions">directions</code></td>
<td>
<p>The number of directions in which patches should be connected: 4 (rook's case) or 8 (queen's case).</p>
</td></tr>
<tr><td><code id="lsm_c_enn_cv_+3A_verbose">verbose</code></td>
<td>
<p>Print warning message if not sufficient patches are present</p>
</td></tr>
</table>


<h3>Details</h3>

<p style="text-align: center;"><code class="reqn">ENN_{CV} = cv(ENN[patch_{ij}])</code>
</p>

<p>where <code class="reqn">ENN[patch_{ij}]</code> is the euclidean nearest-neighbor distance
of each patch.
</p>
<p>ENN_CV is an 'Aggregation metric'. It summarises each class as the Coefficient
of variation of each patch belonging to class i. ENN measures the distance to the  nearest
neighbouring patch of the same class i. The distance is measured from edge-to-edge.
The range is limited by the cell resolution on the lower limit and the landscape extent
on the upper limit. The metric is a simple way to describe patch isolation. Because it is
scaled to the mean, it is easily comparable among different landscapes.
</p>
<p>Because the metric is based on distances or areas please make sure your data
is valid using <code><a href="#topic+check_landscape">check_landscape</a></code>.
</p>


<h4>Units</h4>

<p>Meters</p>



<h4>Range</h4>

<p>ENN_CV &gt;= 0</p>



<h4>Behaviour</h4>

<p>Equals ENN_CV = 0 if the euclidean nearest-neighbor distance is
identical for all patches. Increases, without limit, as the variation of ENN increases.</p>



<h3>Value</h3>

<p>tibble
</p>


<h3>References</h3>

<p>McGarigal K., SA Cushman, and E Ene. 2023. FRAGSTATS v4: Spatial Pattern Analysis
Program for Categorical Maps. Computer software program produced by the authors;
available at the following web site: https://www.fragstats.org
</p>
<p>McGarigal, K., and McComb, W. C. (1995). Relationships between landscape
structure and breeding birds in the Oregon Coast Range.
Ecological monographs, 65(3), 235-260.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lsm_p_enn">lsm_p_enn</a></code>, <br />
<code><a href="#topic+lsm_c_enn_mn">lsm_c_enn_mn</a></code>,
<code><a href="#topic+lsm_c_enn_sd">lsm_c_enn_sd</a></code>, <br />
<code><a href="#topic+lsm_l_enn_mn">lsm_l_enn_mn</a></code>,
<code><a href="#topic+lsm_l_enn_sd">lsm_l_enn_sd</a></code>,
<code><a href="#topic+lsm_l_enn_cv">lsm_l_enn_cv</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>landscape &lt;- terra::rast(landscapemetrics::landscape)
lsm_c_enn_cv(landscape)

</code></pre>

<hr>
<h2 id='lsm_c_enn_mn'>ENN_MN (class level)</h2><span id='topic+lsm_c_enn_mn'></span>

<h3>Description</h3>

<p>Mean of euclidean nearest-neighbor distance (Aggregation metric)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lsm_c_enn_mn(landscape, directions = 8, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lsm_c_enn_mn_+3A_landscape">landscape</code></td>
<td>
<p>A categorical raster object: SpatRaster; Raster* Layer, Stack, Brick; stars or a list of SpatRasters.</p>
</td></tr>
<tr><td><code id="lsm_c_enn_mn_+3A_directions">directions</code></td>
<td>
<p>The number of directions in which patches should be connected: 4 (rook's case) or 8 (queen's case).</p>
</td></tr>
<tr><td><code id="lsm_c_enn_mn_+3A_verbose">verbose</code></td>
<td>
<p>Print warning message if not sufficient patches are present</p>
</td></tr>
</table>


<h3>Details</h3>

<p style="text-align: center;"><code class="reqn">ENN_{MN} = mean(ENN[patch_{ij}])</code>
</p>

<p>where <code class="reqn">ENN[patch_{ij}]</code> is the euclidean nearest-neighbor distance
of each patch.
</p>
<p>ENN_MN is an 'Aggregation metric'. It summarises each class as the mean of each patch
belonging to class i. ENN measures the distance to the  nearest neighbouring patch
of the same class i. The distance is measured from edge-to-edge. The range is limited
by the cell resolution on the lower limit and the landscape extent on the upper limit.
</p>
<p>Because the metric is based on distances or areas please make sure your data
is valid using <code><a href="#topic+check_landscape">check_landscape</a></code>.
</p>


<h4>Units</h4>

<p>Meters</p>



<h4>Range</h4>

<p>ENN_MN &gt; 0</p>



<h4>Behaviour</h4>

<p>Approaches ENN_MN = 0 as the distance to the nearest neighbour
decreases, i.e. patches of the same class i are more aggregated. Increases, without limit,
as the distance between neighbouring patches of the same class i increases, i.e. patches are
more isolated.</p>



<h3>Value</h3>

<p>tibble
</p>


<h3>References</h3>

<p>McGarigal K., SA Cushman, and E Ene. 2023. FRAGSTATS v4: Spatial Pattern Analysis
Program for Categorical Maps. Computer software program produced by the authors;
available at the following web site: https://www.fragstats.org
</p>
<p>McGarigal, K., and McComb, W. C. (1995). Relationships between landscape
structure and breeding birds in the Oregon Coast Range.
Ecological monographs, 65(3), 235-260.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lsm_p_enn">lsm_p_enn</a></code>,
<code><a href="base.html#topic+mean">mean</a></code>, <br />
<code><a href="#topic+lsm_c_enn_sd">lsm_c_enn_sd</a></code>,
<code><a href="#topic+lsm_c_enn_cv">lsm_c_enn_cv</a></code>, <br />
<code><a href="#topic+lsm_l_enn_mn">lsm_l_enn_mn</a></code>,
<code><a href="#topic+lsm_l_enn_sd">lsm_l_enn_sd</a></code>,
<code><a href="#topic+lsm_l_enn_cv">lsm_l_enn_cv</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>landscape &lt;- terra::rast(landscapemetrics::landscape)
lsm_c_enn_mn(landscape)

</code></pre>

<hr>
<h2 id='lsm_c_enn_sd'>ENN_SD (class level)</h2><span id='topic+lsm_c_enn_sd'></span>

<h3>Description</h3>

<p>Standard deviation of euclidean nearest-neighbor distance (Aggregation metric)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lsm_c_enn_sd(landscape, directions = 8, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lsm_c_enn_sd_+3A_landscape">landscape</code></td>
<td>
<p>A categorical raster object: SpatRaster; Raster* Layer, Stack, Brick; stars or a list of SpatRasters.</p>
</td></tr>
<tr><td><code id="lsm_c_enn_sd_+3A_directions">directions</code></td>
<td>
<p>The number of directions in which patches should be connected: 4 (rook's case) or 8 (queen's case).</p>
</td></tr>
<tr><td><code id="lsm_c_enn_sd_+3A_verbose">verbose</code></td>
<td>
<p>Print warning message if not sufficient patches are present</p>
</td></tr>
</table>


<h3>Details</h3>

<p style="text-align: center;"><code class="reqn">ENN_{SD} = sd(ENN[patch_{ij}])</code>
</p>

<p>where <code class="reqn">ENN[patch_{ij}]</code> is the euclidean nearest-neighbor distance
of each patch.
</p>
<p>ENN_CV is an 'Aggregation metric'. It summarises each class as the standard
deviation of each patch belonging to class i. ENN measures the distance to the  nearest
neighbouring patch of the same class i. The distance is measured from edge-to-edge.
The range is limited by the cell resolution on the lower limit and the landscape extent
on the upper limit. The metric is a simple way to describe patch isolation. Because it is
scaled to the mean, it is easily comparable among different landscapes.
</p>
<p>Because the metric is based on distances or areas please make sure your data
is valid using <code><a href="#topic+check_landscape">check_landscape</a></code>.
</p>


<h4>Units</h4>

<p>Meters</p>



<h4>Range</h4>

<p>ENN_SD &gt;= 0</p>



<h4>Behaviour</h4>

<p>Equals ENN_SD = 0 if the euclidean nearest-neighbor distance is
identical for all patches. Increases, without limit, as the variation of ENN increases.</p>



<h3>Value</h3>

<p>tibble
</p>


<h3>References</h3>

<p>McGarigal K., SA Cushman, and E Ene. 2023. FRAGSTATS v4: Spatial Pattern Analysis
Program for Categorical Maps. Computer software program produced by the authors;
available at the following web site: https://www.fragstats.org
</p>
<p>McGarigal, K., and McComb, W. C. (1995). Relationships between landscape
structure and breeding birds in the Oregon Coast Range.
Ecological monographs, 65(3), 235-260.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lsm_p_enn">lsm_p_enn</a></code>,
<code><a href="stats.html#topic+sd">sd</a></code> <br />
<code><a href="#topic+lsm_c_enn_mn">lsm_c_enn_mn</a></code>,
<code><a href="#topic+lsm_c_enn_cv">lsm_c_enn_cv</a></code>, <br />
<code><a href="#topic+lsm_l_enn_mn">lsm_l_enn_mn</a></code>,
<code><a href="#topic+lsm_l_enn_sd">lsm_l_enn_sd</a></code>,
<code><a href="#topic+lsm_l_enn_cv">lsm_l_enn_cv</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>landscape &lt;- terra::rast(landscapemetrics::landscape)
lsm_c_enn_sd(landscape)

</code></pre>

<hr>
<h2 id='lsm_c_frac_cv'>FRAC_CV (class level)</h2><span id='topic+lsm_c_frac_cv'></span>

<h3>Description</h3>

<p>Coefficient of variation fractal dimension index (Shape metric)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lsm_c_frac_cv(landscape, directions = 8)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lsm_c_frac_cv_+3A_landscape">landscape</code></td>
<td>
<p>A categorical raster object: SpatRaster; Raster* Layer, Stack, Brick; stars or a list of SpatRasters.</p>
</td></tr>
<tr><td><code id="lsm_c_frac_cv_+3A_directions">directions</code></td>
<td>
<p>The number of directions in which patches should be
connected: 4 (rook's case) or 8 (queen's case).</p>
</td></tr>
</table>


<h3>Details</h3>

<p style="text-align: center;"><code class="reqn">FRAC_{CV} = cv(FRAC[patch_{ij}])</code>
</p>

<p>where <code class="reqn">FRAC[patch_{ij}]</code> equals the fractal dimension index of each patch.
</p>
<p>FRAC_CV is a 'Shape metric'. The metric summarises each class
as the Coefficient of variation of the fractal dimension index of all patches
belonging to class i. The fractal dimension index is based on the patch perimeter and
the patch area and describes the patch complexity. The Coefficient of variation is
scaled to the mean and comparable among different landscapes.
</p>
<p>Because the metric is based on distances or areas please make sure your data
is valid using <code><a href="#topic+check_landscape">check_landscape</a></code>.
</p>


<h4>Units</h4>

<p>None</p>



<h4>Range</h4>

<p>FRAC_CV &gt;= 0 </p>



<h4>Behaviour</h4>

<p>Equals FRAC_CV = 0 if the fractal dimension index is identical
for all patches. Increases, without limit, as the variation of the fractal dimension
indices increases.</p>



<h3>Value</h3>

<p>tibble
</p>


<h3>References</h3>

<p>McGarigal K., SA Cushman, and E Ene. 2023. FRAGSTATS v4: Spatial Pattern Analysis
Program for Categorical Maps. Computer software program produced by the authors;
available at the following web site: https://www.fragstats.org
</p>
<p>Mandelbrot, B. B. 1977. Fractals: Form, Chance, and Dimension.
San Francisco. W. H. Freeman and Company.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lsm_p_frac">lsm_p_frac</a></code>, <br />
<code><a href="#topic+lsm_c_frac_mn">lsm_c_frac_mn</a></code>,
<code><a href="#topic+lsm_c_frac_sd">lsm_c_frac_sd</a></code>, <br />
<code><a href="#topic+lsm_l_frac_mn">lsm_l_frac_mn</a></code>,
<code><a href="#topic+lsm_l_frac_sd">lsm_l_frac_sd</a></code>,
<code><a href="#topic+lsm_l_frac_cv">lsm_l_frac_cv</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>landscape &lt;- terra::rast(landscapemetrics::landscape)
lsm_c_frac_cv(landscape)

</code></pre>

<hr>
<h2 id='lsm_c_frac_mn'>FRAC_MN (class level)</h2><span id='topic+lsm_c_frac_mn'></span>

<h3>Description</h3>

<p>Mean fractal dimension index (Shape metric)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lsm_c_frac_mn(landscape, directions = 8)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lsm_c_frac_mn_+3A_landscape">landscape</code></td>
<td>
<p>A categorical raster object: SpatRaster; Raster* Layer, Stack, Brick; stars or a list of SpatRasters.</p>
</td></tr>
<tr><td><code id="lsm_c_frac_mn_+3A_directions">directions</code></td>
<td>
<p>The number of directions in which patches should be
connected: 4 (rook's case) or 8 (queen's case).</p>
</td></tr>
</table>


<h3>Details</h3>

<p style="text-align: center;"><code class="reqn">FRAC_{MN} = mean(FRAC[patch_{ij}])</code>
</p>

<p>where <code class="reqn">FRAC[patch_{ij}]</code> equals the fractal dimension index of each patch.
</p>
<p>FRAC_MN is a 'Shape metric'. The metric summarises each class
as the mean of the fractal dimension index of all patches belonging to class i.
The fractal dimension index is based on the patch perimeter and
the patch area and describes the patch complexity. The Coefficient of variation is
scaled to the mean and comparable among different landscapes.
</p>
<p>Because the metric is based on distances or areas please make sure your data
is valid using <code><a href="#topic+check_landscape">check_landscape</a></code>.
</p>


<h4>Units</h4>

<p>None</p>



<h4>Range</h4>

<p>FRAC_MN &gt; 0 </p>



<h4>Behaviour</h4>

<p>Approaches FRAC_MN = 1 if all patches are squared and FRAC_MN = 2
if all patches are irregular.</p>



<h3>References</h3>

<p>McGarigal K., SA Cushman, and E Ene. 2023. FRAGSTATS v4: Spatial Pattern Analysis
Program for Categorical Maps. Computer software program produced by the authors;
available at the following web site: https://www.fragstats.org
</p>
<p>Mandelbrot, B. B. 1977. Fractals: Form, Chance, and Dimension.
San Francisco. W. H. Freeman and Company.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lsm_p_frac">lsm_p_frac</a></code>,
<code><a href="base.html#topic+mean">mean</a></code>, <br />
<code><a href="#topic+lsm_c_frac_sd">lsm_c_frac_sd</a></code>,
<code><a href="#topic+lsm_c_frac_cv">lsm_c_frac_cv</a></code>, <br />
<code><a href="#topic+lsm_l_frac_mn">lsm_l_frac_mn</a></code>,
<code><a href="#topic+lsm_l_frac_sd">lsm_l_frac_sd</a></code>,
<code><a href="#topic+lsm_l_frac_cv">lsm_l_frac_cv</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>landscape &lt;- terra::rast(landscapemetrics::landscape)
lsm_c_frac_mn(landscape)

</code></pre>

<hr>
<h2 id='lsm_c_frac_sd'>FRAC_SD (class level)</h2><span id='topic+lsm_c_frac_sd'></span>

<h3>Description</h3>

<p>Standard deviation fractal dimension index (Shape metric)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lsm_c_frac_sd(landscape, directions = 8)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lsm_c_frac_sd_+3A_landscape">landscape</code></td>
<td>
<p>A categorical raster object: SpatRaster; Raster* Layer, Stack, Brick; stars or a list of SpatRasters.</p>
</td></tr>
<tr><td><code id="lsm_c_frac_sd_+3A_directions">directions</code></td>
<td>
<p>The number of directions in which patches should be
connected: 4 (rook's case) or 8 (queen's case).</p>
</td></tr>
</table>


<h3>Details</h3>

<p style="text-align: center;"><code class="reqn">FRAC_{SD} = sd(FRAC[patch_{ij}])</code>
</p>

<p>where <code class="reqn">FRAC[patch_{ij}]</code> equals the fractal dimension index of each patch.
</p>
<p>FRAC_SD is a 'Shape metric'. The metric summarises each class
as the standard deviation of the fractal dimension index of all patches
belonging to class i. The fractal dimension index is based on the patch perimeter and
the patch area and describes the patch complexity.
</p>
<p>Because the metric is based on distances or areas please make sure your data
is valid using <code><a href="#topic+check_landscape">check_landscape</a></code>.
</p>


<h4>Units</h4>

<p>None</p>



<h4>Range</h4>

<p>FRAC_SD&gt;= 0 </p>



<h4>Behaviour</h4>

<p>Equals FRAC_SD = 0 if the fractal dimension index is identical
for all patches. Increases, without limit, as the variation of the fractal dimension
indices increases.</p>



<h3>Value</h3>

<p>tibble
</p>


<h3>References</h3>

<p>McGarigal K., SA Cushman, and E Ene. 2023. FRAGSTATS v4: Spatial Pattern Analysis
Program for Categorical Maps. Computer software program produced by the authors;
available at the following web site: https://www.fragstats.org
</p>
<p>Mandelbrot, B. B. 1977. Fractals: Form, Chance, and Dimension.
San Francisco. W. H. Freeman and Company.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lsm_p_frac">lsm_p_frac</a></code>,
<code><a href="stats.html#topic+sd">sd</a></code> <br />
<code><a href="#topic+lsm_c_frac_mn">lsm_c_frac_mn</a></code>,
<code><a href="#topic+lsm_c_frac_cv">lsm_c_frac_cv</a></code>, <br />
<code><a href="#topic+lsm_l_frac_mn">lsm_l_frac_mn</a></code>,
<code><a href="#topic+lsm_l_frac_sd">lsm_l_frac_sd</a></code>,
<code><a href="#topic+lsm_l_frac_cv">lsm_l_frac_cv</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>landscape &lt;- terra::rast(landscapemetrics::landscape)
lsm_c_frac_sd(landscape)

</code></pre>

<hr>
<h2 id='lsm_c_gyrate_cv'>GYRATE_CV (class level)</h2><span id='topic+lsm_c_gyrate_cv'></span>

<h3>Description</h3>

<p>Coefficient of variation radius of gyration (Area and edge metric)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lsm_c_gyrate_cv(landscape, directions = 8, cell_center = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lsm_c_gyrate_cv_+3A_landscape">landscape</code></td>
<td>
<p>A categorical raster object: SpatRaster; Raster* Layer, Stack, Brick; stars or a list of SpatRasters.</p>
</td></tr>
<tr><td><code id="lsm_c_gyrate_cv_+3A_directions">directions</code></td>
<td>
<p>The number of directions in which patches should be
connected: 4 (rook's case) or 8 (queen's case).</p>
</td></tr>
<tr><td><code id="lsm_c_gyrate_cv_+3A_cell_center">cell_center</code></td>
<td>
<p>If true, the coordinates of the centroid are forced to be
a cell center within the patch.</p>
</td></tr>
</table>


<h3>Details</h3>

<p style="text-align: center;"><code class="reqn">GYRATE_{CV} = cv(GYRATE[patch_{ij}])</code>
</p>

<p>where <code class="reqn">GYRATE[patch_{ij}]</code> equals the radius of gyration of each patch.
</p>
<p>GYRATE_CV is an 'Area and edge metric'. The metric summarises each class
as the Coefficient of variation of the radius of gyration of all patches
belonging to class i. GYRATE measures the distance from each cell to the patch
centroid and is based on cell center-to-cell center distances. The metrics characterises
both the patch area and compactness. The Coefficient of variation is
scaled to the mean and comparable among different landscapes.
</p>
<p>If <code>cell_center = TRUE</code> some patches might have several possible cell-center
centroids. In this case, the gyrate index is based on the mean distance of all
cells to all possible cell-center centroids.
</p>
<p>Because the metric is based on distances or areas please make sure your data
is valid using <code><a href="#topic+check_landscape">check_landscape</a></code>.
</p>


<h4>Units</h4>

<p>Meters</p>



<h4>Range</h4>

<p>GYRATE_CV &gt;= 0 </p>



<h4>Behaviour</h4>

<p>Equals GYRATE_CV = 0 if the radius of gyration is identical
for all patches. Increases, without limit, as the variation of the radius of gyration
increases.</p>



<h3>Value</h3>

<p>tibble
</p>


<h3>References</h3>

<p>McGarigal K., SA Cushman, and E Ene. 2023. FRAGSTATS v4: Spatial Pattern Analysis
Program for Categorical Maps. Computer software program produced by the authors;
available at the following web site: https://www.fragstats.org
</p>
<p>Keitt, T. H., Urban, D. L., &amp; Milne, B. T. 1997. Detecting critical scales
in fragmented landscapes. Conservation ecology, 1(1).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lsm_p_gyrate">lsm_p_gyrate</a></code>, <br />
<code><a href="#topic+lsm_c_gyrate_mn">lsm_c_gyrate_mn</a></code>,
<code><a href="#topic+lsm_c_gyrate_sd">lsm_c_gyrate_sd</a></code>, <br />
<code><a href="#topic+lsm_l_gyrate_mn">lsm_l_gyrate_mn</a></code>,
<code><a href="#topic+lsm_l_gyrate_sd">lsm_l_gyrate_sd</a></code>,
<code><a href="#topic+lsm_l_gyrate_cv">lsm_l_gyrate_cv</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>landscape &lt;- terra::rast(landscapemetrics::landscape)
lsm_c_gyrate_cv(landscape)

</code></pre>

<hr>
<h2 id='lsm_c_gyrate_mn'>GYRATE_MN (class level)</h2><span id='topic+lsm_c_gyrate_mn'></span>

<h3>Description</h3>

<p>Mean radius of gyration (Area and edge metric)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lsm_c_gyrate_mn(landscape, directions = 8, cell_center = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lsm_c_gyrate_mn_+3A_landscape">landscape</code></td>
<td>
<p>A categorical raster object: SpatRaster; Raster* Layer, Stack, Brick; stars or a list of SpatRasters.</p>
</td></tr>
<tr><td><code id="lsm_c_gyrate_mn_+3A_directions">directions</code></td>
<td>
<p>The number of directions in which patches should be
connected: 4 (rook's case) or 8 (queen's case).</p>
</td></tr>
<tr><td><code id="lsm_c_gyrate_mn_+3A_cell_center">cell_center</code></td>
<td>
<p>If true, the coordinates of the centroid are forced to be
a cell center within the patch.</p>
</td></tr>
</table>


<h3>Details</h3>

<p style="text-align: center;"><code class="reqn">GYRATE_{MN} = mean(GYRATE[patch_{ij}])</code>
</p>

<p>where <code class="reqn">GYRATE[patch_{ij}]</code> equals the radius of gyration of each patch.
</p>
<p>GYRATE_MN is an 'Area and edge metric'. The metric summarises each class
as the mean of the radius of gyration of all patches belonging to class i.
GYRATE measures the distance from each cell to the patch centroid and is based on
cell center-to-cell center distances. The metrics characterises
both the patch area and compactness.
</p>
<p>If <code>cell_center = TRUE</code> some patches might have several possible cell-center
centroids. In this case, the gyrate index is based on the mean distance of all
cells to all possible cell-center centroids.
</p>
<p>Because the metric is based on distances or areas please make sure your data
is valid using <code><a href="#topic+check_landscape">check_landscape</a></code>.
</p>


<h4>Units</h4>

<p>Meters</p>



<h4>Range</h4>

<p>GYRATE_MN &gt;= 0 </p>



<h4>Behaviour</h4>

<p>Approaches GYRATE_MN = 0 if every patch is a single cell. Increases,
without limit, when only one patch is present.</p>



<h3>Value</h3>

<p>tibble
</p>


<h3>References</h3>

<p>McGarigal K., SA Cushman, and E Ene. 2023. FRAGSTATS v4: Spatial Pattern Analysis
Program for Categorical Maps. Computer software program produced by the authors;
available at the following web site: https://www.fragstats.org
</p>
<p>Keitt, T. H., Urban, D. L., &amp; Milne, B. T. 1997. Detecting critical scales
in fragmented landscapes. Conservation ecology, 1(1).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lsm_p_gyrate">lsm_p_gyrate</a></code>,
<code><a href="base.html#topic+mean">mean</a></code>, <br />
<code><a href="#topic+lsm_c_gyrate_sd">lsm_c_gyrate_sd</a></code>,
<code><a href="#topic+lsm_c_gyrate_cv">lsm_c_gyrate_cv</a></code>, <br />
<code><a href="#topic+lsm_l_gyrate_mn">lsm_l_gyrate_mn</a></code>,
<code><a href="#topic+lsm_l_gyrate_sd">lsm_l_gyrate_sd</a></code>,
<code><a href="#topic+lsm_l_gyrate_cv">lsm_l_gyrate_cv</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>landscape &lt;- terra::rast(landscapemetrics::landscape)
lsm_c_gyrate_mn(landscape)

</code></pre>

<hr>
<h2 id='lsm_c_gyrate_sd'>GYRATE_SD (class level)</h2><span id='topic+lsm_c_gyrate_sd'></span>

<h3>Description</h3>

<p>Standard deviation radius of gyration (Area and edge metric)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lsm_c_gyrate_sd(landscape, directions = 8, cell_center = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lsm_c_gyrate_sd_+3A_landscape">landscape</code></td>
<td>
<p>A categorical raster object: SpatRaster; Raster* Layer, Stack, Brick; stars or a list of SpatRasters.</p>
</td></tr>
<tr><td><code id="lsm_c_gyrate_sd_+3A_directions">directions</code></td>
<td>
<p>The number of directions in which patches should be
connected: 4 (rook's case) or 8 (queen's case).</p>
</td></tr>
<tr><td><code id="lsm_c_gyrate_sd_+3A_cell_center">cell_center</code></td>
<td>
<p>If true, the coordinates of the centroid are forced to be
a cell center within the patch.</p>
</td></tr>
</table>


<h3>Details</h3>

<p style="text-align: center;"><code class="reqn">GYRATE_{SD} = sd(GYRATE[patch_{ij}])</code>
</p>

<p>where <code class="reqn">GYRATE[patch_{ij}]</code> equals the radius of gyration of each patch.
</p>
<p>GYRATE_SD is an 'Area and edge metric'. The metric summarises each class
as the standard deviation of the radius of gyration of all patches
belonging to class i. GYRATE measures the distance from each cell to the patch
centroid and is based on cell center-to-cell center distances. The metrics characterises
both the patch area and compactness.
</p>
<p>If <code>cell_center = TRUE</code> some patches might have several possible cell-center
centroids. In this case, the gyrate index is based on the mean distance of all
cells to all possible cell-center centroids.
</p>
<p>Because the metric is based on distances or areas please make sure your data
is valid using <code><a href="#topic+check_landscape">check_landscape</a></code>.
</p>


<h4>Units</h4>

<p>Meters</p>



<h4>Range</h4>

<p>GYRATE_SD &gt;= 0 </p>



<h4>Behaviour</h4>

<p>Equals GYRATE_SD = 0 if the radius of gyration is identical
for all patches. Increases, without limit, as the variation of the radius of gyration
increases.</p>



<h3>Value</h3>

<p>tibble
</p>


<h3>References</h3>

<p>McGarigal K., SA Cushman, and E Ene. 2023. FRAGSTATS v4: Spatial Pattern Analysis
Program for Categorical Maps. Computer software program produced by the authors;
available at the following web site: https://www.fragstats.org
</p>
<p>Keitt, T. H., Urban, D. L., &amp; Milne, B. T. 1997. Detecting critical scales
in fragmented landscapes. Conservation ecology, 1(1).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lsm_p_gyrate">lsm_p_gyrate</a></code>, <br />
<code><a href="#topic+lsm_c_gyrate_mn">lsm_c_gyrate_mn</a></code>,
<code><a href="#topic+lsm_c_gyrate_cv">lsm_c_gyrate_cv</a></code>, <br />
<code><a href="#topic+lsm_l_gyrate_mn">lsm_l_gyrate_mn</a></code>,
<code><a href="#topic+lsm_l_gyrate_sd">lsm_l_gyrate_sd</a></code>,
<code><a href="#topic+lsm_l_gyrate_cv">lsm_l_gyrate_cv</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>landscape &lt;- terra::rast(landscapemetrics::landscape)
lsm_c_gyrate_sd(landscape)

</code></pre>

<hr>
<h2 id='lsm_c_iji'>Interspersion and Juxtaposition index (class level)</h2><span id='topic+lsm_c_iji'></span>

<h3>Description</h3>

<p>Interspersion and Juxtaposition index (Aggregation metric)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lsm_c_iji(landscape, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lsm_c_iji_+3A_landscape">landscape</code></td>
<td>
<p>A categorical raster object: SpatRaster; Raster* Layer, Stack, Brick; stars or a list of SpatRasters.</p>
</td></tr>
<tr><td><code id="lsm_c_iji_+3A_verbose">verbose</code></td>
<td>
<p>Print warning message if not sufficient patches are present</p>
</td></tr>
</table>


<h3>Details</h3>

<p style="text-align: center;"><code class="reqn">IJI = \frac{- \sum \limits_{k = 1}^{m} \Bigg[ \Bigg( \frac{e_{ik}}{\sum \limits_{k = 1}^{m} e_{ik}} \Bigg) ln \Bigg( \frac{e_{ik}}{\sum \limits_{k = 1}^{m} e_{ik}} \Bigg) \Bigg]}{ln(m - 1)}  * 100</code>
</p>

<p>where <code class="reqn">e_{ik}</code> are the unique adjacencies of all classes (lower/upper triangle of
the adjacency table - without the diagonal) and <code class="reqn">m</code> is the number of classes.
</p>
<p>IJI is an 'Aggregation metric'. It is a so called &quot;salt and pepper&quot; metric and
describes the intermixing of classes (i.e. without considering like adjacencies - the
diagonal of the adjacency table). The number of classes to calculate IJI must be &gt;= than 3.
</p>


<h4>Units</h4>

<p>Percent</p>



<h4>Range</h4>

<p>0 &lt; IJI &lt;= 100</p>



<h4>Behaviour</h4>

<p>Approaches 0 if a class is only adjacent to a single other class
and equals 100 when a class is equally adjacent to all other classes.</p>



<h3>Value</h3>

<p>tibble
</p>


<h3>References</h3>

<p>McGarigal K., SA Cushman, and E Ene. 2023. FRAGSTATS v4: Spatial Pattern Analysis
Program for Categorical Maps. Computer software program produced by the authors;
available at the following web site: https://www.fragstats.org
</p>
<p>McGarigal, K., &amp; Marks, B. J. 1995. FRAGSTATS: spatial pattern analysis
program for quantifying landscape structure. Gen. Tech. Rep. PNW-GTR-351.
Portland, OR: US Department of Agriculture, Forest Service, Pacific Northwest
Research Station. 122 p, 351.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lsm_l_iji">lsm_l_iji</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>landscape &lt;- terra::rast(landscapemetrics::landscape)
lsm_c_iji(landscape)

</code></pre>

<hr>
<h2 id='lsm_c_lpi'>LPI (class level)</h2><span id='topic+lsm_c_lpi'></span>

<h3>Description</h3>

<p>Largest patch index (Area and Edge metric)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lsm_c_lpi(landscape, directions = 8)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lsm_c_lpi_+3A_landscape">landscape</code></td>
<td>
<p>A categorical raster object: SpatRaster; Raster* Layer, Stack, Brick; stars or a list of SpatRasters.</p>
</td></tr>
<tr><td><code id="lsm_c_lpi_+3A_directions">directions</code></td>
<td>
<p>The number of directions in which patches should be
connected: 4 (rook's case) or 8 (queen's case).</p>
</td></tr>
</table>


<h3>Details</h3>

<p style="text-align: center;"><code class="reqn">LPI = \frac{\max \limits_{j = 1}^{n} (a_{ij})} {A} * 100</code>
</p>

<p>where <code class="reqn">max(a_{ij})</code> is the area of the patch in square meters and <code class="reqn">A</code>
is the total landscape area in square meters.
</p>
<p>The largest patch index is an 'Area and edge metric'. It is the percentage of the
landscape covered by the corresponding largest patch of each class i. It is a simple
measure of dominance.
</p>
<p>Because the metric is based on distances or areas please make sure your data
is valid using <code><a href="#topic+check_landscape">check_landscape</a></code>.
</p>


<h4>Units</h4>

<p>Percentage</p>



<h4>Range</h4>

<p>0 &lt; LPI &lt;= 100</p>



<h4>Behaviour</h4>

<p>Approaches LPI = 0 when the largest patch is becoming small
and equals LPI = 100 when only one patch is present</p>



<h3>Value</h3>

<p>tibble
</p>


<h3>References</h3>

<p>McGarigal K., SA Cushman, and E Ene. 2023. FRAGSTATS v4: Spatial Pattern Analysis
Program for Categorical Maps. Computer software program produced by the authors;
available at the following web site: https://www.fragstats.org
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lsm_p_area">lsm_p_area</a></code>,
<code><a href="#topic+lsm_l_ta">lsm_l_ta</a></code>, <br />
<code><a href="#topic+lsm_l_lpi">lsm_l_lpi</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>landscape &lt;- terra::rast(landscapemetrics::landscape)
lsm_c_lpi(landscape)

</code></pre>

<hr>
<h2 id='lsm_c_lsi'>LSI (class level)</h2><span id='topic+lsm_c_lsi'></span>

<h3>Description</h3>

<p>Landscape shape index (Aggregation metric)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lsm_c_lsi(landscape)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lsm_c_lsi_+3A_landscape">landscape</code></td>
<td>
<p>A categorical raster object: SpatRaster; Raster* Layer, Stack, Brick; stars or a list of SpatRasters.</p>
</td></tr>
</table>


<h3>Details</h3>

<p style="text-align: center;"><code class="reqn">LSI = \frac{e_{i}} {\min e_{i}}</code>
</p>

<p>where <code class="reqn">e_{i}</code> is the total edge length in cell surfaces and <code class="reqn">\min e_{i}</code>
is the minimum total edge length in cell surfaces.
</p>
<p>LSI is an 'Aggregation metric'. It is the ratio between the actual edge length of
class i and the hypothetical minimum edge length of class i. The minimum edge length equals
the edge length if class i would be maximally aggregated.
</p>


<h4>Units</h4>

<p>None</p>



<h4>Ranges</h4>

<p>LSI &gt;= 1</p>



<h4>Behaviour</h4>

<p>Equals LSI = 1 when only one squared patch is present or all
patches are maximally aggregated. Increases, without limit, as the length of the
actual edges increases, i.e. the patches become less compact.</p>

<p>Because the metric is based on distances or areas please make sure your data
is valid using <code><a href="#topic+check_landscape">check_landscape</a></code>.
</p>


<h3>Value</h3>

<p>tibble
</p>


<h3>References</h3>

<p>McGarigal K., SA Cushman, and E Ene. 2023. FRAGSTATS v4: Spatial Pattern Analysis
Program for Categorical Maps. Computer software program produced by the authors;
available at the following web site: https://www.fragstats.org
</p>
<p>Patton, D. R. 1975. A diversity index for quantifying habitat &quot;edge&quot;.
Wildl. Soc.Bull. 3:171-173.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lsm_p_shape">lsm_p_shape</a></code>, <br />
<code><a href="#topic+lsm_l_lsi">lsm_l_lsi</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>landscape &lt;- terra::rast(landscapemetrics::landscape)
lsm_c_lsi(landscape)

</code></pre>

<hr>
<h2 id='lsm_c_mesh'>MESH (class level)</h2><span id='topic+lsm_c_mesh'></span>

<h3>Description</h3>

<p>Effective Mesh Size (Aggregation metric)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lsm_c_mesh(landscape, directions = 8)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lsm_c_mesh_+3A_landscape">landscape</code></td>
<td>
<p>A categorical raster object: SpatRaster; Raster* Layer, Stack, Brick; stars or a list of SpatRasters.</p>
</td></tr>
<tr><td><code id="lsm_c_mesh_+3A_directions">directions</code></td>
<td>
<p>The number of directions in which patches should be
connected: 4 (rook's case) or 8 (queen's case).</p>
</td></tr>
</table>


<h3>Details</h3>

<p style="text-align: center;"><code class="reqn">MESH = \frac{\sum \limits_{j = 1}^{n} a_{ij} ^ 2} {A} * \frac{1} {10000}</code>
</p>

<p>where <code class="reqn">a_{ij}</code> is the patch area in square meters and <code class="reqn">A</code> is the
total landscape area in square meters.
</p>
<p>The effective mesh size is an 'Aggregation metric'. Because each patch is squared
before the sums for each group i are calculated and the sum is standardized by the
total landscape area, MESH is a relative measure of patch structure. MESH is
perfectly, negatively correlated to <code><a href="#topic+lsm_c_division">lsm_c_division</a></code>.
</p>
<p>Because the metric is based on distances or areas please make sure your data
is valid using <code><a href="#topic+check_landscape">check_landscape</a></code>.
</p>


<h4>Units</h4>

<p>Hectares</p>



<h4>Range</h4>

<p>cell size / total area &lt;= MESH &lt;= total area</p>



<h4>Behaviour</h4>

<p>Equals cellsize/total area if class covers only
one cell and equals total area if only one patch is present.</p>



<h3>Value</h3>

<p>tibble
</p>


<h3>References</h3>

<p>McGarigal K., SA Cushman, and E Ene. 2023. FRAGSTATS v4: Spatial Pattern Analysis
Program for Categorical Maps. Computer software program produced by the authors;
available at the following web site: https://www.fragstats.org
</p>
<p>Jaeger, J. A. 2000. Landscape division, splitting index, and effective mesh
size: new measures of landscape fragmentation.
Landscape ecology, 15(2), 115-130.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lsm_p_area">lsm_p_area</a></code>,
<code><a href="#topic+lsm_l_ta">lsm_l_ta</a></code>, <br />
<code><a href="#topic+lsm_l_mesh">lsm_l_mesh</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>landscape &lt;- terra::rast(landscapemetrics::landscape)
lsm_c_mesh(landscape)

</code></pre>

<hr>
<h2 id='lsm_c_ndca'>NDCA (class level)</h2><span id='topic+lsm_c_ndca'></span>

<h3>Description</h3>

<p>Number of disjunct core areas (Core area metric)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lsm_c_ndca(
  landscape,
  directions = 8,
  consider_boundary = FALSE,
  edge_depth = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lsm_c_ndca_+3A_landscape">landscape</code></td>
<td>
<p>A categorical raster object: SpatRaster; Raster* Layer, Stack, Brick; stars or a list of SpatRasters.</p>
</td></tr>
<tr><td><code id="lsm_c_ndca_+3A_directions">directions</code></td>
<td>
<p>The number of directions in which patches should be
connected: 4 (rook's case) or 8 (queen's case).</p>
</td></tr>
<tr><td><code id="lsm_c_ndca_+3A_consider_boundary">consider_boundary</code></td>
<td>
<p>Logical if cells that only neighbour the landscape
boundary should be considered as core</p>
</td></tr>
<tr><td><code id="lsm_c_ndca_+3A_edge_depth">edge_depth</code></td>
<td>
<p>Distance (in cells) a cell has the be away from the patch
edge to be considered as core cell</p>
</td></tr>
</table>


<h3>Details</h3>

<p style="text-align: center;"><code class="reqn">NDCA = \sum \limits_{j = 1}^{n} n_{ij}^{core}</code>
</p>

<p>where <code class="reqn">n_{ij}^{core}</code> is the number of disjunct core areas.
</p>
<p>NDCA is a 'Core area metric'. The metric summarises class i as the sum of all
patches belonging to class i. A cell is defined as core if the cell has no
neighbour with a different value than itself (rook's case). NDCA counts the disjunct
core areas, whereby a core area is a 'patch within the patch' containing only core cells.
It describes patch area and shape simultaneously (more core area when the patch is large,
however, the shape must allow disjunct core areas). Thereby, a compact shape (e.g. a square)
will contain less disjunct core areas than a more irregular patch.
</p>


<h4>Units</h4>

<p>None</p>



<h4>Range</h4>

<p>NDCA &gt;= 0</p>



<h4>Behaviour</h4>

<p>NDCA = 0 when TCA = 0, i.e. every cell in patches of class i is
an edge. NDCA increases, with out limit, as core area increases and patch shapes allow
disjunct core areas (i.e. patch shapes become rather complex).</p>



<h3>Value</h3>

<p>tibble
</p>


<h3>References</h3>

<p>McGarigal K., SA Cushman, and E Ene. 2023. FRAGSTATS v4: Spatial Pattern Analysis
Program for Categorical Maps. Computer software program produced by the authors;
available at the following web site: https://www.fragstats.org
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lsm_c_tca">lsm_c_tca</a></code>, <br />
<code><a href="#topic+lsm_p_ncore">lsm_p_ncore</a></code>,
<code><a href="#topic+lsm_l_ndca">lsm_l_ndca</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>landscape &lt;- terra::rast(landscapemetrics::landscape)
lsm_c_ndca(landscape)

</code></pre>

<hr>
<h2 id='lsm_c_nlsi'>nLSI (class level)</h2><span id='topic+lsm_c_nlsi'></span>

<h3>Description</h3>

<p>Normalized landscape shape index (Aggregation metric)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lsm_c_nlsi(landscape)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lsm_c_nlsi_+3A_landscape">landscape</code></td>
<td>
<p>A categorical raster object: SpatRaster; Raster* Layer, Stack, Brick; stars or a list of SpatRasters.</p>
</td></tr>
</table>


<h3>Details</h3>

<p style="text-align: center;"><code class="reqn">nLSI = \frac{e_{i} - \min e_{i}} {\max e_{i} - \min e_{i}}</code>
</p>

<p>where <code class="reqn">e_{i}</code> is the total edge length in cell surfaces and <code class="reqn">\min e_{i}</code>
<code class="reqn">\max e_{i}</code> are the minimum and maximum total edge length in cell surfaces, respectively.
</p>
<p>nLSI is an 'Aggregation metric'. It is closely related to the <code><a href="#topic+lsm_c_lsi">lsm_c_lsi</a></code>
and describes the ratio of the actual edge length of class i in relation to the
hypothetical range of possible edge lengths of class i (min/max).
</p>
<p>Currently, nLSI ignores all background cells when calculating the minimum and maximum
total edge length. Also, a correct calculation of the minimum and maximum
total edge length is currently only possible for rectangular landscapes.
</p>
<p>Because the metric is based on distances or areas please make sure your data
is valid using <code><a href="#topic+check_landscape">check_landscape</a></code>.
</p>


<h4>Units</h4>

<p>None</p>



<h4>Ranges</h4>

<p>0 &lt;= nlsi &lt;= 1</p>



<h4>Behaviour</h4>

<p>Equals nLSI = 0 when only one squared patch is present. nLSI
increases the more disaggregated patches are and equals nLSI = 1 for a maximal disaggregated
(i.e. a &quot;checkerboard pattern&quot;).</p>



<h3>Value</h3>

<p>tibble
</p>


<h3>References</h3>

<p>McGarigal K., SA Cushman, and E Ene. 2023. FRAGSTATS v4: Spatial Pattern Analysis
Program for Categorical Maps. Computer software program produced by the authors;
available at the following web site: https://www.fragstats.org
</p>
<p>Patton, D. R. 1975. A diversity index for quantifying habitat &quot;edge&quot;.
Wildl. Soc.Bull. 3:171-173.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lsm_c_lsi">lsm_c_lsi</a></code>
<code><a href="#topic+lsm_l_lsi">lsm_l_lsi</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>landscape &lt;- terra::rast(landscapemetrics::landscape)
lsm_c_nlsi(landscape)

</code></pre>

<hr>
<h2 id='lsm_c_np'>NP (class level)</h2><span id='topic+lsm_c_np'></span>

<h3>Description</h3>

<p>Number of patches (Aggregation metric)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lsm_c_np(landscape, directions = 8)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lsm_c_np_+3A_landscape">landscape</code></td>
<td>
<p>A categorical raster object: SpatRaster; Raster* Layer, Stack, Brick; stars or a list of SpatRasters.</p>
</td></tr>
<tr><td><code id="lsm_c_np_+3A_directions">directions</code></td>
<td>
<p>The number of directions in which patches should be
connected: 4 (rook's case) or 8 (queen's case).</p>
</td></tr>
</table>


<h3>Details</h3>

<p style="text-align: center;"><code class="reqn">NP = n_{i}</code>
</p>

<p>where <code class="reqn">n_{i}</code> is the number of patches.
</p>
<p>NP is an 'Aggregation metric'. It describes the fragmentation of a class, however, does not
necessarily contain information about the configuration or composition of the class.
</p>


<h4>Units</h4>

<p>None</p>



<h4>Ranges</h4>

<p>NP &gt;= 1</p>



<h4>Behaviour</h4>

<p>Equals NP = 1 when only one patch is present and
increases, without limit, as the number of patches increases</p>



<h3>Value</h3>

<p>tibble
</p>


<h3>References</h3>

<p>McGarigal K., SA Cushman, and E Ene. 2023. FRAGSTATS v4: Spatial Pattern Analysis
Program for Categorical Maps. Computer software program produced by the authors;
available at the following web site: https://www.fragstats.org
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lsm_l_np">lsm_l_np</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>landscape &lt;- terra::rast(landscapemetrics::landscape)
lsm_c_np(landscape)

</code></pre>

<hr>
<h2 id='lsm_c_pafrac'>PAFRAC  (class level)</h2><span id='topic+lsm_c_pafrac'></span>

<h3>Description</h3>

<p>Perimeter-Area Fractal Dimension (Shape metric)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lsm_c_pafrac(landscape, directions = 8, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lsm_c_pafrac_+3A_landscape">landscape</code></td>
<td>
<p>A categorical raster object: SpatRaster; Raster* Layer, Stack, Brick; stars or a list of SpatRasters.</p>
</td></tr>
<tr><td><code id="lsm_c_pafrac_+3A_directions">directions</code></td>
<td>
<p>The number of directions in which patches should be
connected: 4 (rook's case) or 8 (queen's case).</p>
</td></tr>
<tr><td><code id="lsm_c_pafrac_+3A_verbose">verbose</code></td>
<td>
<p>Print warning message if not sufficient patches are present</p>
</td></tr>
</table>


<h3>Details</h3>

<p style="text-align: center;"><code class="reqn">PAFRAC = \frac{2}{\beta}</code>
</p>

<p>where <code class="reqn">\beta</code> is the slope of the regression of the area against the perimeter
(logarithm) <code class="reqn">n_{i}\sum \limits_{j = 1}^{n} \ln a_{ij} = a + \beta n_{i}\sum \limits_{j = 1}^{n} \ln p_{ij}</code>
</p>
<p>PAFRAC is a 'Shape metric'. It describes the patch complexity of class i while being
scale independent. This means that increasing the patch size while not changing the
patch form will not change the metric. However, it is only meaningful if the relationship
between the area and perimeter is linear on a logarithmic scale. Furthermore, if there
are less than 10 patches in class i, the metric returns NA because of the small-sample
issue.
</p>
<p>Because the metric is based on distances or areas please make sure your data
is valid using <code><a href="#topic+check_landscape">check_landscape</a></code>.
</p>


<h4>Units</h4>

<p>None</p>



<h4>Range</h4>

<p>1 &lt;= PAFRAC &lt;= 2</p>



<h4>Behaviour</h4>

<p>Approaches PAFRAC = 1 for patches with simple shapes and
approaches PAFRAC = 2 for irregular shapes</p>



<h3>Value</h3>

<p>tibble
</p>


<h3>References</h3>

<p>McGarigal K., SA Cushman, and E Ene. 2023. FRAGSTATS v4: Spatial Pattern Analysis
Program for Categorical Maps. Computer software program produced by the authors;
available at the following web site: https://www.fragstats.org
</p>
<p>Burrough, P. A. 1986. Principles of Geographical Information Systems for
Land Resources Assessment. Monographs on Soil and Resources Survey No. 12.
Clarendon Press, Oxford
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lsm_p_area">lsm_p_area</a></code>,
<code><a href="#topic+lsm_p_perim">lsm_p_perim</a></code>, <br />
<code><a href="#topic+lsm_l_pafrac">lsm_l_pafrac</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>landscape &lt;- terra::rast(landscapemetrics::landscape)
lsm_c_pafrac(landscape)

</code></pre>

<hr>
<h2 id='lsm_c_para_cv'>PARA_CV (class level)</h2><span id='topic+lsm_c_para_cv'></span>

<h3>Description</h3>

<p>Coefficient of variation perimeter-area ratio (Shape metric)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lsm_c_para_cv(landscape, directions = 8)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lsm_c_para_cv_+3A_landscape">landscape</code></td>
<td>
<p>A categorical raster object: SpatRaster; Raster* Layer, Stack, Brick; stars or a list of SpatRasters.</p>
</td></tr>
<tr><td><code id="lsm_c_para_cv_+3A_directions">directions</code></td>
<td>
<p>The number of directions in which patches should be
connected: 4 (rook's case) or 8 (queen's case).</p>
</td></tr>
</table>


<h3>Details</h3>

<p style="text-align: center;"><code class="reqn">PARA_{CV} = cv(PARA[patch_{ij}]</code>
</p>

<p>where <code class="reqn">PARA[patch_{ij}]</code> is the perimeter area ratio of each patch.
</p>
<p>PARA_CV is a 'Shape metric'. It summarises each class as the Coefficient of variation of
each patch belonging to class i. The perimeter-area ratio describes the patch complexity
in a straightforward way. However, because it is not standarised to a certain shape
(e.g. a square), it is not scale independent, meaning that increasing the patch size
while not changing the patch form will change the ratio.
</p>
<p>Because the metric is based on distances or areas please make sure your data
is valid using <code><a href="#topic+check_landscape">check_landscape</a></code>.
</p>


<h4>Units</h4>

<p>None</p>



<h4>Range</h4>

<p>PARA_CV &gt;= 0</p>



<h4>Behaviour</h4>

<p>Equals PARA_CV = 0 if the perimeter-area ratio is identical for
all patches. Increases, without limit, as the variation of the perimeter-area ratio
increases.</p>



<h3>Value</h3>

<p>tibble
</p>


<h3>References</h3>

<p>McGarigal K., SA Cushman, and E Ene. 2023. FRAGSTATS v4: Spatial Pattern Analysis
Program for Categorical Maps. Computer software program produced by the authors;
available at the following web site: https://www.fragstats.org
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lsm_p_para">lsm_p_para</a></code>, <br />
<code><a href="#topic+lsm_c_para_mn">lsm_c_para_mn</a></code>,
<code><a href="#topic+lsm_c_para_sd">lsm_c_para_sd</a></code>, <br />
<code><a href="#topic+lsm_l_para_mn">lsm_l_para_mn</a></code>,
<code><a href="#topic+lsm_l_para_sd">lsm_l_para_sd</a></code>,
<code><a href="#topic+lsm_l_para_cv">lsm_l_para_cv</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>landscape &lt;- terra::rast(landscapemetrics::landscape)
lsm_c_para_cv(landscape)

</code></pre>

<hr>
<h2 id='lsm_c_para_mn'>PARA_MN (class level)</h2><span id='topic+lsm_c_para_mn'></span>

<h3>Description</h3>

<p>Mean perimeter-area ratio (Shape metric)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lsm_c_para_mn(landscape, directions = 8)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lsm_c_para_mn_+3A_landscape">landscape</code></td>
<td>
<p>A categorical raster object: SpatRaster; Raster* Layer, Stack, Brick; stars or a list of SpatRasters.</p>
</td></tr>
<tr><td><code id="lsm_c_para_mn_+3A_directions">directions</code></td>
<td>
<p>The number of directions in which patches should be
connected: 4 (rook's case) or 8 (queen's case).</p>
</td></tr>
</table>


<h3>Details</h3>

<p style="text-align: center;"><code class="reqn">PARA_{MN} = mean(PARA[patch_{ij}]</code>
</p>

<p>where <code class="reqn">PARA[patch_{ij}]</code> is the perimeter area ratio of each patch.
</p>
<p>PARA_MN is a 'Shape metric'. It summarises each class as the mean of
each patch belonging to class i. The perimeter-area ratio describes the patch complexity
in a straightforward way. However, because it is not standarised to a certain shape
(e.g. a square), it is not scale independent, meaning that increasing the patch size
while not changing the patch form will change the ratio.
</p>
<p>Because the metric is based on distances or areas please make sure your data
is valid using <code><a href="#topic+check_landscape">check_landscape</a></code>.
</p>


<h4>Units</h4>

<p>None</p>



<h4>Range</h4>

<p>PARA_MN &gt; 0</p>



<h4>Behaviour</h4>

<p>Approaches PARA_MN &gt; 0 if PARA for each patch approaches PARA &gt; 0,
i.e. the form approaches a rather small square. Increases, without limit, as PARA increases,
i.e. patches become more complex.</p>



<h3>Value</h3>

<p>tibble
</p>


<h3>References</h3>

<p>McGarigal K., SA Cushman, and E Ene. 2023. FRAGSTATS v4: Spatial Pattern Analysis
Program for Categorical Maps. Computer software program produced by the authors;
available at the following web site: https://www.fragstats.org
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lsm_p_para">lsm_p_para</a></code>,
<code><a href="base.html#topic+mean">mean</a></code>, <br />
<code><a href="#topic+lsm_c_para_sd">lsm_c_para_sd</a></code>,
<code><a href="#topic+lsm_c_para_cv">lsm_c_para_cv</a></code>, <br />
<code><a href="#topic+lsm_l_para_mn">lsm_l_para_mn</a></code>,
<code><a href="#topic+lsm_l_para_sd">lsm_l_para_sd</a></code>,
<code><a href="#topic+lsm_l_para_cv">lsm_l_para_cv</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>landscape &lt;- terra::rast(landscapemetrics::landscape)
lsm_c_para_mn(landscape)

</code></pre>

<hr>
<h2 id='lsm_c_para_sd'>PARA_SD (class level)</h2><span id='topic+lsm_c_para_sd'></span>

<h3>Description</h3>

<p>Standard deviation perimeter-area ratio (Shape metric)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lsm_c_para_sd(landscape, directions = 8)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lsm_c_para_sd_+3A_landscape">landscape</code></td>
<td>
<p>A categorical raster object: SpatRaster; Raster* Layer, Stack, Brick; stars or a list of SpatRasters.</p>
</td></tr>
<tr><td><code id="lsm_c_para_sd_+3A_directions">directions</code></td>
<td>
<p>The number of directions in which patches should be
connected: 4 (rook's case) or 8 (queen's case).</p>
</td></tr>
</table>


<h3>Details</h3>

<p style="text-align: center;"><code class="reqn">PARA_{SD} = sd(PARA[patch_{ij}]</code>
</p>

<p>where <code class="reqn">PARA[patch_{ij}]</code> is the perimeter area ratio of each patch.
</p>
<p>PARA_SD is a 'Shape metric'. It summarises each class as the standard deviation of
each patch belonging to class i. The perimeter-area ratio describes the patch complexity
in a straightforward way. However, because it is not standarised to a certain shape
(e.g. a square), it is not scale independent, meaning that increasing the patch size
while not changing the patch form will change the ratio.
</p>
<p>Because the metric is based on distances or areas please make sure your data
is valid using <code><a href="#topic+check_landscape">check_landscape</a></code>.
</p>


<h4>Units</h4>

<p>None</p>



<h4>Range</h4>

<p>PARA_SD &gt;= 0</p>



<h4>Behaviour</h4>

<p>Equals PARA_SD = 0 if the perimeter-area ratio is identical for
all patches. Increases, without limit, as the variation of the perimeter-area ratio
increases.</p>



<h3>Value</h3>

<p>tibble
</p>


<h3>References</h3>

<p>McGarigal K., SA Cushman, and E Ene. 2023. FRAGSTATS v4: Spatial Pattern Analysis
Program for Categorical Maps. Computer software program produced by the authors;
available at the following web site: https://www.fragstats.org
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lsm_p_para">lsm_p_para</a></code>,
<code><a href="stats.html#topic+sd">sd</a></code> <br />
<code><a href="#topic+lsm_c_para_mn">lsm_c_para_mn</a></code>,
<code><a href="#topic+lsm_c_para_cv">lsm_c_para_cv</a></code>, <br />
<code><a href="#topic+lsm_l_para_mn">lsm_l_para_mn</a></code>,
<code><a href="#topic+lsm_l_para_sd">lsm_l_para_sd</a></code>,
<code><a href="#topic+lsm_l_para_cv">lsm_l_para_cv</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>landscape &lt;- terra::rast(landscapemetrics::landscape)
lsm_c_para_sd(landscape)

</code></pre>

<hr>
<h2 id='lsm_c_pd'>PD (class level)</h2><span id='topic+lsm_c_pd'></span>

<h3>Description</h3>

<p>Patch density (Aggregation metric)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lsm_c_pd(landscape, directions = 8)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lsm_c_pd_+3A_landscape">landscape</code></td>
<td>
<p>A categorical raster object: SpatRaster; Raster* Layer, Stack, Brick; stars or a list of SpatRasters.</p>
</td></tr>
<tr><td><code id="lsm_c_pd_+3A_directions">directions</code></td>
<td>
<p>The number of directions in which patches should be
connected: 4 (rook's case) or 8 (queen's case).</p>
</td></tr>
</table>


<h3>Details</h3>

<p style="text-align: center;"><code class="reqn">PD = \frac{n_{i}} {A} * 10000 * 100</code>
</p>

<p>where <code class="reqn">n_{i}</code> is the number of patches and <code class="reqn">A</code> is the total landscape
area in square meters.
</p>
<p>PD is an 'Aggregation metric'. It describes the fragmentation of a class, however, does not
necessarily contain information about the configuration or composition of the class. In
contrast to <code><a href="#topic+lsm_c_np">lsm_c_np</a></code> it is standardized to the area and comparisons among
landscapes with different total area are possible.
</p>
<p>Because the metric is based on distances or areas please make sure your data
is valid using <code><a href="#topic+check_landscape">check_landscape</a></code>.
</p>


<h4>Units</h4>

<p>Number per 100 hectares</p>



<h4>Ranges</h4>

<p>0 &lt; PD &lt;= 1e+06</p>



<h4>Behaviour</h4>

<p>Increases as the landscape gets more patchy. Reaches its maximum
if every cell is a different patch.</p>



<h3>Value</h3>

<p>tibble
</p>


<h3>References</h3>

<p>McGarigal K., SA Cushman, and E Ene. 2023. FRAGSTATS v4: Spatial Pattern Analysis
Program for Categorical Maps. Computer software program produced by the authors;
available at the following web site: https://www.fragstats.org
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lsm_c_np">lsm_c_np</a></code>,
<code><a href="#topic+lsm_l_ta">lsm_l_ta</a></code>, <br />
<code><a href="#topic+lsm_l_pd">lsm_l_pd</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>landscape &lt;- terra::rast(landscapemetrics::landscape)
lsm_c_pd(landscape)

</code></pre>

<hr>
<h2 id='lsm_c_pladj'>PLADJ (class level)</h2><span id='topic+lsm_c_pladj'></span>

<h3>Description</h3>

<p>Percentage of Like Adjacencies (Aggregation metric)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lsm_c_pladj(landscape)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lsm_c_pladj_+3A_landscape">landscape</code></td>
<td>
<p>A categorical raster object: SpatRaster; Raster* Layer, Stack, Brick; stars or a list of SpatRasters.</p>
</td></tr>
</table>


<h3>Details</h3>

<p style="text-align: center;"><code class="reqn">PLADJ = (\frac{g_{ij}} {\sum \limits_{k = 1}^{m} g_{ik}}) * 100</code>
</p>

<p>where <code class="reqn">g_{ii}</code> is the number of adjacencies between cells of class i
and <code class="reqn">g_{ik}</code> is the number of adjacencies between cells of class i and k.
</p>
<p>PLADJ is an 'Aggregation metric'. It calculates the frequency how often patches of
different classes i (focal class) and k are next to each other, and following is a
measure of class aggregation. The adjacencies are counted using the double-count method.
</p>


<h4>Units</h4>

<p>Percent</p>



<h4>Ranges</h4>

<p>0 &lt;= PLADJ &lt;= 100</p>



<h4>Behaviour</h4>

<p>Equals PLADJ = 0 if class i is maximal disaggregated,
i.e. every cell is a different patch. Equals PLADJ = 100 when the only one patch
is present.</p>



<h3>Value</h3>

<p>tibble
</p>


<h3>References</h3>

<p>McGarigal K., SA Cushman, and E Ene. 2023. FRAGSTATS v4: Spatial Pattern Analysis
Program for Categorical Maps. Computer software program produced by the authors;
available at the following web site: https://www.fragstats.org.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>landscape &lt;- terra::rast(landscapemetrics::landscape)
lsm_c_pladj(landscape)

</code></pre>

<hr>
<h2 id='lsm_c_pland'>PLAND (class level)</h2><span id='topic+lsm_c_pland'></span>

<h3>Description</h3>

<p>Percentage of landscape of class (Area and Edge metric)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lsm_c_pland(landscape, directions = 8)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lsm_c_pland_+3A_landscape">landscape</code></td>
<td>
<p>A categorical raster object: SpatRaster; Raster* Layer, Stack, Brick; stars or a list of SpatRasters.</p>
</td></tr>
<tr><td><code id="lsm_c_pland_+3A_directions">directions</code></td>
<td>
<p>The number of directions in which patches should be
connected: 4 (rook's case) or 8 (queen's case).</p>
</td></tr>
</table>


<h3>Details</h3>

<p style="text-align: center;"><code class="reqn">PLAND = \frac{\sum \limits_{j = 1}^{n} a_{ij}} {A} * 100</code>
</p>

<p>where <code class="reqn">a_{ij}</code> is the area of each patch and <code class="reqn">A</code> is the total
landscape area.
</p>
<p>PLAND is an 'Area and edge metric'. It is the percentage of the landscape
belonging to class i. It is a measure of composition and because of the relative
character directly comparable among landscapes with different total areas.
</p>
<p>Because the metric is based on distances or areas please make sure your data
is valid using <code><a href="#topic+check_landscape">check_landscape</a></code>.
</p>


<h4>Units</h4>

<p>Percentage</p>



<h4>Range</h4>

<p>0 &lt; PLAND &lt;= 100</p>



<h4>Behaviour</h4>

<p>Approaches PLAND = 0 when the proportional class area is decreasing.
Equals PLAND = 100 when only one patch is present.</p>



<h3>Value</h3>

<p>tibble
</p>


<h3>References</h3>

<p>McGarigal K., SA Cushman, and E Ene. 2023. FRAGSTATS v4: Spatial Pattern Analysis
Program for Categorical Maps. Computer software program produced by the authors;
available at the following web site: https://www.fragstats.org
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lsm_c_ca">lsm_c_ca</a></code>,
<code><a href="#topic+lsm_l_ta">lsm_l_ta</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>landscape &lt;- terra::rast(landscapemetrics::landscape)
lsm_c_pland(landscape)

</code></pre>

<hr>
<h2 id='lsm_c_shape_cv'>SHAPE_CV (class level)</h2><span id='topic+lsm_c_shape_cv'></span>

<h3>Description</h3>

<p>Covariance of variation shape index (Shape metric)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lsm_c_shape_cv(landscape, directions = 8)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lsm_c_shape_cv_+3A_landscape">landscape</code></td>
<td>
<p>A categorical raster object: SpatRaster; Raster* Layer, Stack, Brick; stars or a list of SpatRasters.</p>
</td></tr>
<tr><td><code id="lsm_c_shape_cv_+3A_directions">directions</code></td>
<td>
<p>The number of directions in which patches should be
connected: 4 (rook's case) or 8 (queen's case).</p>
</td></tr>
</table>


<h3>Details</h3>

<p style="text-align: center;"><code class="reqn">SHAPE_{CV} = cv(SHAPE[patch_{ij}])</code>
</p>

<p>where <code class="reqn">SHAPE[patch_{ij}]</code> is the shape index of each patch.
</p>
<p>SHAPE_CV is a 'Shape metric'. Each class is summarised as the Coefficient of variation
of each patch belonging to class i. SHAPE describes the ratio between the actual perimeter of
the patch and the square root of patch area.
</p>
<p>Because the metric is based on distances or areas please make sure your data
is valid using <code><a href="#topic+check_landscape">check_landscape</a></code>.
</p>


<h4>Units</h4>

<p>None</p>



<h4>Range</h4>

<p>SHAPE_CV &gt;= 0</p>



<h4>Behaviour</h4>

<p>Equals SHAPE_CV = 0 if all patches have an identical shape index.
Increases, without limit, as the variation of the shape index increases.</p>



<h3>Value</h3>

<p>tibble
</p>


<h3>References</h3>

<p>McGarigal K., SA Cushman, and E Ene. 2023. FRAGSTATS v4: Spatial Pattern Analysis
Program for Categorical Maps. Computer software program produced by the authors;
available at the following web site: https://www.fragstats.org
</p>
<p>Patton, D. R. 1975. A diversity index for quantifying habitat &quot;edge&quot;.
Wildl. Soc.Bull. 3:171-173.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lsm_p_shape">lsm_p_shape</a></code>, <br />
<code><a href="#topic+lsm_c_shape_mn">lsm_c_shape_mn</a></code>,
<code><a href="#topic+lsm_c_shape_sd">lsm_c_shape_sd</a></code>, <br />
<code><a href="#topic+lsm_l_shape_mn">lsm_l_shape_mn</a></code>,
<code><a href="#topic+lsm_l_shape_sd">lsm_l_shape_sd</a></code>,
<code><a href="#topic+lsm_l_shape_cv">lsm_l_shape_cv</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>landscape &lt;- terra::rast(landscapemetrics::landscape)
lsm_c_shape_cv(landscape)

</code></pre>

<hr>
<h2 id='lsm_c_shape_mn'>SHAPE_MN (class level)</h2><span id='topic+lsm_c_shape_mn'></span>

<h3>Description</h3>

<p>Mean shape index (Shape metric)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lsm_c_shape_mn(landscape, directions = 8)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lsm_c_shape_mn_+3A_landscape">landscape</code></td>
<td>
<p>A categorical raster object: SpatRaster; Raster* Layer, Stack, Brick; stars or a list of SpatRasters.</p>
</td></tr>
<tr><td><code id="lsm_c_shape_mn_+3A_directions">directions</code></td>
<td>
<p>The number of directions in which patches should be
connected: 4 (rook's case) or 8 (queen's case).</p>
</td></tr>
</table>


<h3>Details</h3>

<p style="text-align: center;"><code class="reqn">SHAPE_{MN} = mean(SHAPE[patch_{ij}])</code>
</p>

<p>where <code class="reqn">SHAPE[patch_{ij}]</code> is the shape index of each patch.
</p>
<p>SHAPE_MN is a 'Shape metric'. Each class is summarised as the mean
of each patch belonging to class i. SHAPE describes the ratio between the actual perimeter of
the patch and the square root of patch area.
</p>
<p>Because the metric is based on distances or areas please make sure your data
is valid using <code><a href="#topic+check_landscape">check_landscape</a></code>.
</p>


<h4>Units</h4>

<p>None</p>



<h4>Range</h4>

<p>SHAPE_SD &gt;= 1</p>



<h4>Behaviour</h4>

<p>Equals SHAPE_MN = 1 if all patches are squares.
Increases, without limit, as the shapes of patches become more complex.</p>



<h3>Value</h3>

<p>tibble
</p>


<h3>References</h3>

<p>McGarigal K., SA Cushman, and E Ene. 2023. FRAGSTATS v4: Spatial Pattern Analysis
Program for Categorical Maps. Computer software program produced by the authors;
available at the following web site: https://www.fragstats.org
</p>
<p>Patton, D. R. 1975. A diversity index for quantifying habitat &quot;edge&quot;.
Wildl. Soc.Bull. 3:171-173.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lsm_p_shape">lsm_p_shape</a></code>,
<code><a href="base.html#topic+mean">mean</a></code>, <br />
<code><a href="#topic+lsm_c_shape_sd">lsm_c_shape_sd</a></code>,
<code><a href="#topic+lsm_c_shape_cv">lsm_c_shape_cv</a></code>, <br />
<code><a href="#topic+lsm_l_shape_mn">lsm_l_shape_mn</a></code>,
<code><a href="#topic+lsm_l_shape_sd">lsm_l_shape_sd</a></code>,
<code><a href="#topic+lsm_l_shape_cv">lsm_l_shape_cv</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>landscape &lt;- terra::rast(landscapemetrics::landscape)
lsm_c_shape_mn(landscape)

</code></pre>

<hr>
<h2 id='lsm_c_shape_sd'>SHAPE_SD (class level)</h2><span id='topic+lsm_c_shape_sd'></span>

<h3>Description</h3>

<p>Standard deviation shape index (Shape metric)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lsm_c_shape_sd(landscape, directions = 8)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lsm_c_shape_sd_+3A_landscape">landscape</code></td>
<td>
<p>A categorical raster object: SpatRaster; Raster* Layer, Stack, Brick; stars or a list of SpatRasters.</p>
</td></tr>
<tr><td><code id="lsm_c_shape_sd_+3A_directions">directions</code></td>
<td>
<p>The number of directions in which patches should be
connected: 4 (rook's case) or 8 (queen's case).</p>
</td></tr>
</table>


<h3>Details</h3>

<p style="text-align: center;"><code class="reqn">SHAPE_{SD} = sd(SHAPE[patch_{ij}])</code>
</p>

<p>where <code class="reqn">SHAPE[patch_{ij}]</code> is the shape index of each patch.
</p>
<p>SHAPE_SD is a 'Shape metric'. Each class is summarised as the standard deviation
of each patch belonging to class i. SHAPE describes the ratio between the actual perimeter of
the patch and the square root of patch area.
</p>
<p>Because the metric is based on distances or areas please make sure your data
is valid using <code><a href="#topic+check_landscape">check_landscape</a></code>.
</p>


<h4>Units</h4>

<p>None</p>



<h4>Range</h4>

<p>SHAPE_SD &gt;= 0</p>



<h4>Behaviour</h4>

<p>Equals SHAPE_SD = 0 if all patches have an identical shape index.
Increases, without limit, as the variation of the shape index increases.</p>



<h3>Value</h3>

<p>tibble
</p>


<h3>References</h3>

<p>McGarigal K., SA Cushman, and E Ene. 2023. FRAGSTATS v4: Spatial Pattern Analysis
Program for Categorical Maps. Computer software program produced by the authors;
available at the following web site: https://www.fragstats.org
</p>
<p>Patton, D. R. 1975. A diversity index for quantifying habitat &quot;edge&quot;.
Wildl. Soc.Bull. 3:171-173.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lsm_p_shape">lsm_p_shape</a></code>,
<code><a href="stats.html#topic+sd">sd</a></code> <br />
<code><a href="#topic+lsm_c_shape_mn">lsm_c_shape_mn</a></code>,
<code><a href="#topic+lsm_c_shape_cv">lsm_c_shape_cv</a></code>, <br />
<code><a href="#topic+lsm_l_shape_mn">lsm_l_shape_mn</a></code>,
<code><a href="#topic+lsm_l_shape_sd">lsm_l_shape_sd</a></code>,
<code><a href="#topic+lsm_l_shape_cv">lsm_l_shape_cv</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>landscape &lt;- terra::rast(landscapemetrics::landscape)
lsm_c_shape_sd(landscape)

</code></pre>

<hr>
<h2 id='lsm_c_split'>SPLIT (class level)</h2><span id='topic+lsm_c_split'></span>

<h3>Description</h3>

<p>Splitting index (Aggregation metric)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lsm_c_split(landscape, directions = 8)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lsm_c_split_+3A_landscape">landscape</code></td>
<td>
<p>A categorical raster object: SpatRaster; Raster* Layer, Stack, Brick; stars or a list of SpatRasters.</p>
</td></tr>
<tr><td><code id="lsm_c_split_+3A_directions">directions</code></td>
<td>
<p>The number of directions in which patches should be
connected: 4 (rook's case) or 8 (queen's case).</p>
</td></tr>
</table>


<h3>Details</h3>

<p style="text-align: center;"><code class="reqn">SPLIT = \frac{A^2} {\sum \limits_{j = 1}^{n} a_{ij}^2}</code>
</p>

<p>where <code class="reqn">a_{ij}</code> is the patch area in square meters and <code class="reqn">A</code> is the
total landscape area.
</p>
<p>SPLIT is an 'Aggregation metric'. It describes the number of patches if all patches of
class i would be divided into equally sized patches.
</p>
<p>Because the metric is based on distances or areas please make sure your data
is valid using <code><a href="#topic+check_landscape">check_landscape</a></code>.
</p>


<h4>Units</h4>

<p>None</p>



<h4>Range</h4>

<p>1 &lt;= SPLIT &lt;= Number of cells squared</p>



<h4>Behaviour</h4>

<p>Equals SPLIT = 1 if only one patch is present. Increases as
the number of patches of class i increases and is limited if all cells are a patch</p>



<h3>Value</h3>

<p>tibble
</p>


<h3>References</h3>

<p>McGarigal K., SA Cushman, and E Ene. 2023. FRAGSTATS v4: Spatial Pattern Analysis
Program for Categorical Maps. Computer software program produced by the authors;
available at the following web site: https://www.fragstats.org
</p>
<p>Jaeger, J. A. 2000. Landscape division, splitting index, and effective mesh
size: new measures of landscape fragmentation.
Landscape ecology, 15(2), 115-130.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lsm_p_area">lsm_p_area</a></code>,
<code><a href="#topic+lsm_l_ta">lsm_l_ta</a></code>, <br />
<code><a href="#topic+lsm_l_split">lsm_l_split</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>landscape &lt;- terra::rast(landscapemetrics::landscape)
lsm_c_split(landscape)

</code></pre>

<hr>
<h2 id='lsm_c_tca'>TCA (class level)</h2><span id='topic+lsm_c_tca'></span>

<h3>Description</h3>

<p>Total core area (Core area metric)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lsm_c_tca(landscape, directions = 8, consider_boundary = FALSE, edge_depth = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lsm_c_tca_+3A_landscape">landscape</code></td>
<td>
<p>A categorical raster object: SpatRaster; Raster* Layer, Stack, Brick; stars or a list of SpatRasters.</p>
</td></tr>
<tr><td><code id="lsm_c_tca_+3A_directions">directions</code></td>
<td>
<p>The number of directions in which patches should be
connected: 4 (rook's case) or 8 (queen's case).</p>
</td></tr>
<tr><td><code id="lsm_c_tca_+3A_consider_boundary">consider_boundary</code></td>
<td>
<p>Logical if cells that only neighbour the landscape
boundary should be considered as core</p>
</td></tr>
<tr><td><code id="lsm_c_tca_+3A_edge_depth">edge_depth</code></td>
<td>
<p>Distance (in cells) a cell has the be away from the patch
edge to be considered as core cell</p>
</td></tr>
</table>


<h3>Details</h3>

<p style="text-align: center;"><code class="reqn">TCA = \sum_{j = 1}^{n} a_{ij}^{core} * (\frac{1} {10000})</code>
</p>

<p>where here <code class="reqn">a_{ij}^{core}</code> is the core area in square meters.
</p>
<p>TCA is a 'Core area metric' and equals the sum of core areas of all patches belonging
to class i. A cell is defined as core area if the cell has no neighbour with a different
value than itself (rook's case). In other words, the core area of a patch is all area that
is not an edge. It characterises patch areas and shapes of patches belonging to class i
simultaneously (more core area when the patch is large and the shape is rather compact,
i.e. a square). Additionally, TCA is a measure for the configuration of the landscape,
because the sum of edges increase as patches are less aggregated.
</p>
<p>Because the metric is based on distances or areas please make sure your data
is valid using <code><a href="#topic+check_landscape">check_landscape</a></code>.
</p>


<h4>Units</h4>

<p>Hectares</p>



<h4>Range</h4>

<p>TCA &gt;= 0</p>



<h4>Behaviour</h4>

<p>Increases, without limit, as patch areas increase
and patch shapes simplify. TCA = 0 when every cell in every patch of class i
is an edge.</p>



<h3>Value</h3>

<p>tibble
</p>


<h3>References</h3>

<p>McGarigal K., SA Cushman, and E Ene. 2023. FRAGSTATS v4: Spatial Pattern Analysis
Program for Categorical Maps. Computer software program produced by the authors;
available at the following web site: https://www.fragstats.org
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lsm_p_core">lsm_p_core</a></code>,
<code><a href="#topic+lsm_l_tca">lsm_l_tca</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>landscape &lt;- terra::rast(landscapemetrics::landscape)
lsm_c_tca(landscape)

</code></pre>

<hr>
<h2 id='lsm_c_te'>TE (class level)</h2><span id='topic+lsm_c_te'></span>

<h3>Description</h3>

<p>Total (class) edge (Area and Edge metric)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lsm_c_te(landscape, count_boundary = FALSE, directions = 8)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lsm_c_te_+3A_landscape">landscape</code></td>
<td>
<p>A categorical raster object: SpatRaster; Raster* Layer, Stack, Brick; stars or a list of SpatRasters.</p>
</td></tr>
<tr><td><code id="lsm_c_te_+3A_count_boundary">count_boundary</code></td>
<td>
<p>Include landscape boundary in edge length</p>
</td></tr>
<tr><td><code id="lsm_c_te_+3A_directions">directions</code></td>
<td>
<p>The number of directions in which patches should be
connected: 4 (rook's case) or 8 (queen's case).</p>
</td></tr>
</table>


<h3>Details</h3>

<p style="text-align: center;"><code class="reqn">TE = \sum \limits_{k = 1}^{m} e_{ik}</code>
</p>

<p>where <code class="reqn">e_{ik}</code> is the edge lengths in meters.
TE is an 'Area and edge metric'. Total (class) edge includes all edges between class i and
all other classes k. It measures the configuration of the landscape because a highly
fragmented landscape will have many edges. However, total edge is an absolute measure,
making comparisons among landscapes with different total areas difficult. If
<code>count_boundary = TRUE</code> also edges to the landscape boundary are included.
</p>
<p>Because the metric is based on distances or areas please make sure your data
is valid using <code><a href="#topic+check_landscape">check_landscape</a></code>.
</p>


<h4>Units</h4>

<p>Meters</p>



<h4>Range</h4>

<p>TE &gt;= 0</p>



<h4>Behaviour</h4>

<p>Equals TE = 0 if all cells are edge cells. Increases, without limit,
as landscape becomes more fragmented</p>



<h3>Value</h3>

<p>tibble
</p>


<h3>References</h3>

<p>McGarigal K., SA Cushman, and E Ene. 2023. FRAGSTATS v4: Spatial Pattern Analysis
Program for Categorical Maps. Computer software program produced by the authors;
available at the following web site: https://www.fragstats.org
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lsm_p_perim">lsm_p_perim</a></code>
<code><a href="#topic+lsm_l_te">lsm_l_te</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>landscape &lt;- terra::rast(landscapemetrics::landscape)
lsm_c_te(landscape)

</code></pre>

<hr>
<h2 id='lsm_l_ai'>AI (landscape level)</h2><span id='topic+lsm_l_ai'></span>

<h3>Description</h3>

<p>Aggregation index (Aggregation metric)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lsm_l_ai(landscape, directions = 8)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lsm_l_ai_+3A_landscape">landscape</code></td>
<td>
<p>A categorical raster object: SpatRaster; Raster* Layer, Stack, Brick; stars or a list of SpatRasters</p>
</td></tr>
<tr><td><code id="lsm_l_ai_+3A_directions">directions</code></td>
<td>
<p>The number of directions in which patches should be
connected: 4 (rook's case) or 8 (queen's case).</p>
</td></tr>
</table>


<h3>Details</h3>

<p style="text-align: center;"><code class="reqn">AI = \Bigg[\sum\limits_{i=1}^m \Big( \frac{g_{ii}}{max-g_{ii}} \Big) P_{i} \Bigg](100) </code>
</p>

<p>where <code class="reqn">g_{ii}</code> is the number of like adjacencies based on the single-count method and
<code class="reqn">max-g_{ii}</code> is the classwise maximum number of like adjacencies of class i and <code class="reqn">P_{i}</code>
the proportion of landscape compromised of class i.
</p>
<p>AI is an 'Aggregation metric'. It equals the number of like adjacencies divided
by the theoretical maximum possible number of like adjacencies for that class
summed over each class for the entire landscape. The metric is based on the
adjacency matrix and the single-count method.
</p>


<h4>Units</h4>

<p>Percent</p>



<h4>Range</h4>

<p>0 &lt;= AI &lt;= 100</p>



<h4>Behaviour</h4>

<p>Equals 0 for maximally disaggregated and 100
for maximally aggregated classes.</p>



<h3>Value</h3>

<p>tibble
</p>


<h3>References</h3>

<p>McGarigal K., SA Cushman, and E Ene. 2023. FRAGSTATS v4: Spatial Pattern Analysis
Program for Categorical Maps. Computer software program produced by the authors;
available at the following web site: https://www.fragstats.org
</p>
<p>He, H. S., DeZonia, B. E., &amp; Mladenoff, D. J. 2000. An aggregation index (AI)
to quantify spatial patterns of landscapes. Landscape ecology, 15(7), 591-601.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lsm_c_ai">lsm_c_ai</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>landscape &lt;- terra::rast(landscapemetrics::landscape)
lsm_l_ai(landscape)

</code></pre>

<hr>
<h2 id='lsm_l_area_cv'>AREA_CV (landscape level)</h2><span id='topic+lsm_l_area_cv'></span>

<h3>Description</h3>

<p>Coefficient of variation of patch area (Area and edge metric)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lsm_l_area_cv(landscape, directions = 8)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lsm_l_area_cv_+3A_landscape">landscape</code></td>
<td>
<p>A categorical raster object: SpatRaster; Raster* Layer, Stack, Brick; stars or a list of SpatRasters</p>
</td></tr>
<tr><td><code id="lsm_l_area_cv_+3A_directions">directions</code></td>
<td>
<p>The number of directions in which patches should be connected: 4 (rook's case) or 8 (queen's case).</p>
</td></tr>
</table>


<h3>Details</h3>

<p style="text-align: center;"><code class="reqn">AREA_{CV} = cv(AREA[patch_{ij}])</code>
</p>

<p>where <code class="reqn">AREA[patch_{ij}]</code> is the area of each patch in hectares.
</p>
<p>AREA_CV is an 'Area and Edge metric'. The metric summarises the landscape
as the Coefficient of variation of all patches in the landscape.
The metric describes the differences among patches in the landscape and is
easily comparable because it is scaled to the mean.
</p>
<p>Because the metric is based on distances or areas please make sure your data
is valid using <code><a href="#topic+check_landscape">check_landscape</a></code>.
</p>


<h4>Units</h4>

<p>Hectares</p>



<h4>Range</h4>

<p>AREA_CV &gt;= 0</p>



<h4>Behaviour</h4>

<p>Equals AREA_CV = 0 if all patches are identical in size.
Increases, without limit, as the variation of patch areas increases.</p>



<h3>Value</h3>

<p>tibble
</p>


<h3>References</h3>

<p>McGarigal K., SA Cushman, and E Ene. 2023. FRAGSTATS v4: Spatial Pattern Analysis
Program for Categorical Maps. Computer software program produced by the authors;
available at the following web site: https://www.fragstats.org
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lsm_p_area">lsm_p_area</a></code>, <br />
<code><a href="#topic+lsm_c_area_mn">lsm_c_area_mn</a></code>,
<code><a href="#topic+lsm_c_area_sd">lsm_c_area_sd</a></code>,
<code><a href="#topic+lsm_c_area_cv">lsm_c_area_cv</a></code>, <br />
<code><a href="#topic+lsm_l_area_mn">lsm_l_area_mn</a></code>,
<code><a href="#topic+lsm_l_area_sd">lsm_l_area_sd</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>landscape &lt;- terra::rast(landscapemetrics::landscape)
lsm_l_area_cv(landscape)

</code></pre>

<hr>
<h2 id='lsm_l_area_mn'>AREA_MN (landscape level)</h2><span id='topic+lsm_l_area_mn'></span>

<h3>Description</h3>

<p>Mean of patch area (Area and edge metric)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lsm_l_area_mn(landscape, directions = 8)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lsm_l_area_mn_+3A_landscape">landscape</code></td>
<td>
<p>A categorical raster object: SpatRaster; Raster* Layer, Stack, Brick; stars or a list of SpatRasters</p>
</td></tr>
<tr><td><code id="lsm_l_area_mn_+3A_directions">directions</code></td>
<td>
<p>The number of directions in which patches should be connected: 4 (rook's case) or 8 (queen's case).</p>
</td></tr>
</table>


<h3>Details</h3>

<p style="text-align: center;"><code class="reqn">AREA_{MN} = mean(AREA[patch_{ij}])</code>
</p>

<p>where <code class="reqn">AREA[patch_{ij}]</code> is the area of each patch in hectares
</p>
<p>AREA_MN is an 'Area and Edge metric'. The metric summarises the landscape
as the mean of all patch in the landscape. The metric is a simple way
to describe the composition of the landscape. Especially together with the total
landscape area (<code><a href="#topic+lsm_l_ta">lsm_l_ta</a></code>), it can also give an an idea of patch structure
(e.g. many small patches vs. few larges patches).
</p>
<p>Because the metric is based on distances or areas please make sure your data
is valid using <code><a href="#topic+check_landscape">check_landscape</a></code>.
</p>


<h4>Units</h4>

<p>Hectares</p>



<h4>Range</h4>

<p>AREA_MN &gt; 0</p>



<h4>Behaviour</h4>

<p>Approaches AREA_MN = 0 if all patches are small. Increases, without
limit, as the patch areas increase.</p>



<h3>Value</h3>

<p>tibble
</p>


<h3>References</h3>

<p>McGarigal K., SA Cushman, and E Ene. 2023. FRAGSTATS v4: Spatial Pattern Analysis
Program for Categorical Maps. Computer software program produced by the authors;
available at the following web site: https://www.fragstats.org
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lsm_p_area">lsm_p_area</a></code>,
<code><a href="base.html#topic+mean">mean</a></code>, <br />
<code><a href="#topic+lsm_c_area_mn">lsm_c_area_mn</a></code>,
<code><a href="#topic+lsm_c_area_sd">lsm_c_area_sd</a></code>,
<code><a href="#topic+lsm_c_area_cv">lsm_c_area_cv</a></code> <br />
<code><a href="#topic+lsm_l_area_sd">lsm_l_area_sd</a></code>,
<code><a href="#topic+lsm_l_area_cv">lsm_l_area_cv</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>landscape &lt;- terra::rast(landscapemetrics::landscape)
lsm_l_area_mn(landscape)

</code></pre>

<hr>
<h2 id='lsm_l_area_sd'>AREA_SD (landscape level)</h2><span id='topic+lsm_l_area_sd'></span>

<h3>Description</h3>

<p>Standard deviation of patch area (Area and edge metric)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lsm_l_area_sd(landscape, directions = 8)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lsm_l_area_sd_+3A_landscape">landscape</code></td>
<td>
<p>A categorical raster object: SpatRaster; Raster* Layer, Stack, Brick; stars or a list of SpatRasters</p>
</td></tr>
<tr><td><code id="lsm_l_area_sd_+3A_directions">directions</code></td>
<td>
<p>The number of directions in which patches should be connected: 4 (rook's case) or 8 (queen's case).</p>
</td></tr>
</table>


<h3>Details</h3>

<p style="text-align: center;"><code class="reqn">AREA_{SD} = sd(AREA[patch_{ij}])</code>
</p>

<p>where <code class="reqn">AREA[patch_{ij}]</code> is the area of each patch in hectares.
</p>
<p>AREA_SD is an 'Area and Edge metric'. The metric summarises the landscape
as the standard deviation of all patch in the landscape. The metric describes
the differences among all patches in the landscape.
</p>
<p>Because the metric is based on distances or areas please make sure your data
is valid using <code><a href="#topic+check_landscape">check_landscape</a></code>.
</p>


<h4>Units</h4>

<p>Hectares</p>



<h4>Range</h4>

<p>AREA_SD &gt;= 0</p>



<h4>Behaviour</h4>

<p>Equals AREA_SD = 0 if all patches are identical in size.
Increases, without limit, as the variation of patch areas increases.</p>



<h3>Value</h3>

<p>tibble
</p>


<h3>References</h3>

<p>McGarigal K., SA Cushman, and E Ene. 2023. FRAGSTATS v4: Spatial Pattern Analysis
Program for Categorical Maps. Computer software program produced by the authors;
available at the following web site: https://www.fragstats.org
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lsm_p_area">lsm_p_area</a></code>,
<code><a href="stats.html#topic+sd">sd</a></code> <br />
<code><a href="#topic+lsm_c_area_mn">lsm_c_area_mn</a></code>,
<code><a href="#topic+lsm_c_area_sd">lsm_c_area_sd</a></code>,
<code><a href="#topic+lsm_c_area_cv">lsm_c_area_cv</a></code> <br />
<code><a href="#topic+lsm_l_area_mn">lsm_l_area_mn</a></code>,
<code><a href="#topic+lsm_l_area_cv">lsm_l_area_cv</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>landscape &lt;- terra::rast(landscapemetrics::landscape)
lsm_l_area_sd(landscape)

</code></pre>

<hr>
<h2 id='lsm_l_cai_cv'>CAI_CV (landscape level)</h2><span id='topic+lsm_l_cai_cv'></span>

<h3>Description</h3>

<p>Coefficient of variation of core area index (Core area metric)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lsm_l_cai_cv(
  landscape,
  directions = 8,
  consider_boundary = FALSE,
  edge_depth = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lsm_l_cai_cv_+3A_landscape">landscape</code></td>
<td>
<p>A categorical raster object: SpatRaster; Raster* Layer, Stack, Brick; stars or a list of SpatRasters.</p>
</td></tr>
<tr><td><code id="lsm_l_cai_cv_+3A_directions">directions</code></td>
<td>
<p>The number of directions in which patches should be
connected: 4 (rook's case) or 8 (queen's case).</p>
</td></tr>
<tr><td><code id="lsm_l_cai_cv_+3A_consider_boundary">consider_boundary</code></td>
<td>
<p>Logical if cells that only neighbour the landscape
boundary should be considered as core</p>
</td></tr>
<tr><td><code id="lsm_l_cai_cv_+3A_edge_depth">edge_depth</code></td>
<td>
<p>Distance (in cells) a cell has the be away from the patch
edge to be considered as core cell</p>
</td></tr>
</table>


<h3>Details</h3>

<p style="text-align: center;"><code class="reqn">CAI_{CV} = cv(CAI[patch_{ij}]</code>
</p>

<p>where <code class="reqn">CAI[patch_{ij}]</code> is the core area index of each patch.
</p>
<p>CAI_CV is a 'Core area metric'. The metric summarises the landscape
as the Coefficient of variation of the core area index of all patches
in the landscape. The core area index is the percentage of core area
in relation to patch area. A cell is defined as core area if the cell has
no neighbour with a different value than itself (rook's case). The metric
describes the differences among all patches in the landscape. Because it is
scaled to the mean, it is easily comparable.
</p>
<p>Because the metric is based on distances or areas please make sure your data
is valid using <code><a href="#topic+check_landscape">check_landscape</a></code>.
</p>


<h4>Units</h4>

<p>Percent</p>



<h4>Range</h4>

<p>CAI_CV &gt;= 0</p>



<h4>Behaviour</h4>

<p>Equals CAI_CV = 0 if the core area index is identical for
all patches. Increases, without limit, as the variation of the core area
indices increases.</p>



<h3>Value</h3>

<p>tibble
</p>


<h3>References</h3>

<p>McGarigal K., SA Cushman, and E Ene. 2023. FRAGSTATS v4: Spatial Pattern Analysis
Program for Categorical Maps. Computer software program produced by the authors;
available at the following web site: https://www.fragstats.org
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lsm_p_cai">lsm_p_cai</a></code>, <br />
<code><a href="#topic+lsm_c_cai_mn">lsm_c_cai_mn</a></code>,
<code><a href="#topic+lsm_c_cai_sd">lsm_c_cai_sd</a></code>,
<code><a href="#topic+lsm_c_cai_cv">lsm_c_cai_cv</a></code>, <br />
<code><a href="#topic+lsm_l_cai_mn">lsm_l_cai_mn</a></code>,
<code><a href="#topic+lsm_l_cai_sd">lsm_l_cai_sd</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>landscape &lt;- terra::rast(landscapemetrics::landscape)
lsm_l_cai_cv(landscape)

</code></pre>

<hr>
<h2 id='lsm_l_cai_mn'>CAI_MN (landscape level)</h2><span id='topic+lsm_l_cai_mn'></span>

<h3>Description</h3>

<p>Mean of core area index (Core area metric)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lsm_l_cai_mn(
  landscape,
  directions = 8,
  consider_boundary = FALSE,
  edge_depth = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lsm_l_cai_mn_+3A_landscape">landscape</code></td>
<td>
<p>A categorical raster object: SpatRaster; Raster* Layer, Stack, Brick; stars or a list of SpatRasters.</p>
</td></tr>
<tr><td><code id="lsm_l_cai_mn_+3A_directions">directions</code></td>
<td>
<p>The number of directions in which patches should be
connected: 4 (rook's case) or 8 (queen's case).</p>
</td></tr>
<tr><td><code id="lsm_l_cai_mn_+3A_consider_boundary">consider_boundary</code></td>
<td>
<p>Logical if cells that only neighbour the landscape
boundary should be considered as core</p>
</td></tr>
<tr><td><code id="lsm_l_cai_mn_+3A_edge_depth">edge_depth</code></td>
<td>
<p>Distance (in cells) a cell has the be away from the patch
edge to be considered as core cell</p>
</td></tr>
</table>


<h3>Details</h3>

<p style="text-align: center;"><code class="reqn">CAI_{MN} = mean(CAI[patch_{ij}]</code>
</p>

<p>where <code class="reqn">CAI[patch_{ij}]</code> is the core area index of each patch.
</p>
<p>CAI_MN is a 'Core area metric'. The metric summarises the landscape
as the mean of the core area index of all patches in the landscape.
The core area index is the percentage of core area in relation to patch area.
A cell is defined as core area if the cell has no neighbour with a different
value than itself (rook's case).
</p>
<p>Because the metric is based on distances or areas please make sure your data
is valid using <code><a href="#topic+check_landscape">check_landscape</a></code>.
</p>


<h4>Units</h4>

<p>Percent</p>



<h4>Range</h4>

<p>0 &lt;= CAI_MN &lt;= 100</p>



<h4>Behaviour</h4>

<p>CAI_MN = 0 when all patches have no core area and
approaches CAI_MN = 100 with increasing percentage of core area within patches.</p>



<h3>Value</h3>

<p>tibble
</p>


<h3>References</h3>

<p>McGarigal K., SA Cushman, and E Ene. 2023. FRAGSTATS v4: Spatial Pattern Analysis
Program for Categorical Maps. Computer software program produced by the authors;
available at the following web site: https://www.fragstats.org
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lsm_p_cai">lsm_p_cai</a></code>,
<code><a href="base.html#topic+mean">mean</a></code>, <br />
<code><a href="#topic+lsm_c_cai_sd">lsm_c_cai_sd</a></code>,
<code><a href="#topic+lsm_c_cai_sd">lsm_c_cai_sd</a></code>,
<code><a href="#topic+lsm_c_cai_cv">lsm_c_cai_cv</a></code>, <br />
<code><a href="#topic+lsm_l_cai_sd">lsm_l_cai_sd</a></code>,
<code><a href="#topic+lsm_l_cai_cv">lsm_l_cai_cv</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>landscape &lt;- terra::rast(landscapemetrics::landscape)
lsm_l_cai_mn(landscape)

</code></pre>

<hr>
<h2 id='lsm_l_cai_sd'>CAI_SD (landscape level)</h2><span id='topic+lsm_l_cai_sd'></span>

<h3>Description</h3>

<p>Standard deviation of core area index (Core area metric)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lsm_l_cai_sd(
  landscape,
  directions = 8,
  consider_boundary = FALSE,
  edge_depth = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lsm_l_cai_sd_+3A_landscape">landscape</code></td>
<td>
<p>A categorical raster object: SpatRaster; Raster* Layer, Stack, Brick; stars or a list of SpatRasters.</p>
</td></tr>
<tr><td><code id="lsm_l_cai_sd_+3A_directions">directions</code></td>
<td>
<p>The number of directions in which patches should be
connected: 4 (rook's case) or 8 (queen's case).</p>
</td></tr>
<tr><td><code id="lsm_l_cai_sd_+3A_consider_boundary">consider_boundary</code></td>
<td>
<p>Logical if cells that only neighbour the landscape
boundary should be considered as core</p>
</td></tr>
<tr><td><code id="lsm_l_cai_sd_+3A_edge_depth">edge_depth</code></td>
<td>
<p>Distance (in cells) a cell has the be away from the patch
edge to be considered as core cell</p>
</td></tr>
</table>


<h3>Details</h3>

<p style="text-align: center;"><code class="reqn">CAI_{SD} = sd(CAI[patch_{ij}]</code>
</p>

<p>where <code class="reqn">CAI[patch_{ij}]</code> is the core area index of each patch.
</p>
<p>CAI_SD is a 'Core area metric'. The metric summarises the landscape
as the standard deviation of the core area index of all patches in the landscape.
The core area index is the percentage of core area in relation to patch area.
A cell is defined as core area if the cell has no neighbour with a different
value than itself (rook's case). The metric describes the differences among all patches
in the landscape.
</p>
<p>Because the metric is based on distances or areas please make sure your data
is valid using <code><a href="#topic+check_landscape">check_landscape</a></code>.
</p>


<h4>Units</h4>

<p>Percent</p>



<h4>Range</h4>

<p>CAI_SD &gt;= 0</p>



<h4>Behaviour</h4>

<p>Equals CAI_SD = 0 if the core area index is identical for
all patches. Increases, without limit, as the variation of core area
indices increases.</p>



<h3>Value</h3>

<p>tibble
</p>


<h3>References</h3>

<p>McGarigal K., SA Cushman, and E Ene. 2023. FRAGSTATS v4: Spatial Pattern Analysis
Program for Categorical Maps. Computer software program produced by the authors;
available at the following web site: https://www.fragstats.org
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lsm_p_cai">lsm_p_cai</a></code>,
<code><a href="stats.html#topic+sd">sd</a></code> <br />
<code><a href="#topic+lsm_c_cai_mn">lsm_c_cai_mn</a></code>,
<code><a href="#topic+lsm_c_cai_sd">lsm_c_cai_sd</a></code>,
<code><a href="#topic+lsm_c_cai_cv">lsm_c_cai_cv</a></code>, <br />
<code><a href="#topic+lsm_l_cai_mn">lsm_l_cai_mn</a></code>,
<code><a href="#topic+lsm_l_cai_cv">lsm_l_cai_cv</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>landscape &lt;- terra::rast(landscapemetrics::landscape)
lsm_l_cai_sd(landscape)

</code></pre>

<hr>
<h2 id='lsm_l_circle_cv'>CIRCLE_CV (landscape level)</h2><span id='topic+lsm_l_circle_cv'></span>

<h3>Description</h3>

<p>Coefficient of variation of related circumscribing circle (Shape metric)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lsm_l_circle_cv(landscape, directions = 8)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lsm_l_circle_cv_+3A_landscape">landscape</code></td>
<td>
<p>A categorical raster object: SpatRaster; Raster* Layer, Stack, Brick; stars or a list of SpatRasters.</p>
</td></tr>
<tr><td><code id="lsm_l_circle_cv_+3A_directions">directions</code></td>
<td>
<p>The number of directions in which patches should be connected: 4 (rook's case) or 8 (queen's case).</p>
</td></tr>
</table>


<h3>Details</h3>

<p style="text-align: center;"><code class="reqn">CIRCLE_{CV} = cv(CIRCLE[patch_{ij}])</code>
</p>

<p>where <code class="reqn">CIRCLE[patch_{ij}]</code> is the related circumscribing circle of each patch.
</p>
<p>CIRCLE_CV is a 'Shape metric' and summarises the landscape as the Coefficient of variation
of the related circumscribing circle of all patches in the landscape. CIRCLE describes
the ratio between the patch area and the smallest circumscribing circle of the patch
and characterises the compactness of the patch. CIRCLE_CV describes the differences among
all patches in the landscape. Because it is scaled to the mean, it is easily comparable.
</p>
<p>Because the metric is based on distances or areas please make sure your data
is valid using <code><a href="#topic+check_landscape">check_landscape</a></code>.
</p>


<h4>Units</h4>

<p>None</p>



<h4>Range</h4>

<p>CIRCLE_CV &gt;= 0</p>



<h4>Behaviour</h4>

<p>Equals CIRCLE_CV if the related circumscribing circle is identical
for all patches. Increases, without limit, as the variation of related circumscribing
circles increases.</p>



<h3>Value</h3>

<p>tibble
</p>


<h3>References</h3>

<p>McGarigal K., SA Cushman, and E Ene. 2023. FRAGSTATS v4: Spatial Pattern Analysis
Program for Categorical Maps. Computer software program produced by the authors;
available at the following web site: https://www.fragstats.org
</p>
<p>Baker, W. L., and Y. Cai. 1992. The r.le programs for multiscale analysis of
landscape structure using the GRASS geographical information system.
Landscape Ecology 7: 291-302.
</p>
<p>Based on C++ code from Project Nayuki (https://www.nayuki.io/page/smallest-enclosing-circle).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lsm_p_circle">lsm_p_circle</a></code>,
<code><a href="base.html#topic+mean">mean</a></code>, <br />
<code><a href="#topic+lsm_c_circle_mn">lsm_c_circle_mn</a></code>,
<code><a href="#topic+lsm_c_circle_sd">lsm_c_circle_sd</a></code>,
<code><a href="#topic+lsm_c_circle_cv">lsm_c_circle_cv</a></code>, <br />
<code><a href="#topic+lsm_l_circle_mn">lsm_l_circle_mn</a></code>,
<code><a href="#topic+lsm_l_circle_sd">lsm_l_circle_sd</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>landscape &lt;- terra::rast(landscapemetrics::landscape)
lsm_l_circle_cv(landscape)

</code></pre>

<hr>
<h2 id='lsm_l_circle_mn'>CIRCLE_MN (landscape level)</h2><span id='topic+lsm_l_circle_mn'></span>

<h3>Description</h3>

<p>Mean of related circumscribing circle (Shape metric)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lsm_l_circle_mn(landscape, directions = 8)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lsm_l_circle_mn_+3A_landscape">landscape</code></td>
<td>
<p>A categorical raster object: SpatRaster; Raster* Layer, Stack, Brick; stars or a list of SpatRasters.</p>
</td></tr>
<tr><td><code id="lsm_l_circle_mn_+3A_directions">directions</code></td>
<td>
<p>The number of directions in which patches should be connected: 4 (rook's case) or 8 (queen's case).</p>
</td></tr>
</table>


<h3>Details</h3>

<p style="text-align: center;"><code class="reqn">CIRCLE_{MN} = mean(CIRCLE[patch_{ij}])</code>
</p>

<p>where <code class="reqn">CIRCLE[patch_{ij}]</code> is the related circumscribing circle of each patch.
</p>
<p>CIRCLE_MN is a 'Shape metric' and summarises the landscape as the mean of the related
circumscribing circle of all patches in the landscape. CIRCLE describes
the ratio between the patch area and the smallest circumscribing circle of the patch
and characterises the compactness of the patch.
</p>
<p>Because the metric is based on distances or areas please make sure your data
is valid using <code><a href="#topic+check_landscape">check_landscape</a></code>.
</p>


<h4>Units</h4>

<p>None</p>



<h4>Range</h4>

<p>CIRCLE_MN &gt; 0</p>



<h4>Behaviour</h4>

<p>Approaches CIRCLE_MN = 0 if the related circumscribing circle
of all patches is small. Increases, without limit, as the related circumscribing circles
increase.</p>



<h3>Value</h3>

<p>tibble
</p>


<h3>References</h3>

<p>McGarigal K., SA Cushman, and E Ene. 2023. FRAGSTATS v4: Spatial Pattern Analysis
Program for Categorical Maps. Computer software program produced by the authors;
available at the following web site: https://www.fragstats.org
</p>
<p>Baker, W. L., and Y. Cai. 1992. The r.le programs for multiscale analysis of
landscape structure using the GRASS geographical information system.
Landscape Ecology 7: 291-302.
</p>
<p>Based on C++ code from Project Nayuki (https://www.nayuki.io/page/smallest-enclosing-circle).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lsm_p_circle">lsm_p_circle</a></code>,
<code><a href="base.html#topic+mean">mean</a></code>, <br />
<code><a href="#topic+lsm_c_circle_mn">lsm_c_circle_mn</a></code>,
<code><a href="#topic+lsm_c_circle_sd">lsm_c_circle_sd</a></code>,
<code><a href="#topic+lsm_c_circle_cv">lsm_c_circle_cv</a></code>, <br />
<code><a href="#topic+lsm_l_circle_sd">lsm_l_circle_sd</a></code>,
<code><a href="#topic+lsm_l_circle_cv">lsm_l_circle_cv</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>landscape &lt;- terra::rast(landscapemetrics::landscape)
lsm_l_circle_mn(landscape)

</code></pre>

<hr>
<h2 id='lsm_l_circle_sd'>CIRCLE_SD (landscape level)</h2><span id='topic+lsm_l_circle_sd'></span>

<h3>Description</h3>

<p>Standard deviation of related circumscribing circle (Shape metric)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lsm_l_circle_sd(landscape, directions = 8)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lsm_l_circle_sd_+3A_landscape">landscape</code></td>
<td>
<p>A categorical raster object: SpatRaster; Raster* Layer, Stack, Brick; stars or a list of SpatRasters.</p>
</td></tr>
<tr><td><code id="lsm_l_circle_sd_+3A_directions">directions</code></td>
<td>
<p>The number of directions in which patches should be
connected: 4 (rook's case) or 8 (queen's case).</p>
</td></tr>
</table>


<h3>Details</h3>

<p style="text-align: center;"><code class="reqn">CIRCLE_{SD} = sd(CIRCLE[patch_{ij}])</code>
</p>

<p>where <code class="reqn">CIRCLE[patch_{ij}]</code> is the related circumscribing circle of each patch.
</p>
<p>CIRCLE_SD is a 'Shape metric' and summarises the landscape as the standard deviation of
the related circumscribing circle of all patches in the landscape. CIRCLE describes
the ratio between the patch area and the smallest circumscribing circle of the patch
and characterises the compactness of the patch. The metric describes the differences
among all patches of the landscape.
</p>
<p>Because the metric is based on distances or areas please make sure your data
is valid using <code><a href="#topic+check_landscape">check_landscape</a></code>.
</p>


<h4>Units</h4>

<p>None</p>



<h4>Range</h4>

<p>CIRCLE_SD &gt;= 0</p>



<h4>Behaviour</h4>

<p>Equals CIRCLE_SD if the related circumscribing circle is identical
for all patches. Increases, without limit, as the variation of related circumscribing
circles increases.</p>



<h3>Value</h3>

<p>tibble
</p>


<h3>References</h3>

<p>McGarigal K., SA Cushman, and E Ene. 2023. FRAGSTATS v4: Spatial Pattern Analysis
Program for Categorical Maps. Computer software program produced by the authors;
available at the following web site: https://www.fragstats.org
</p>
<p>Baker, W. L., and Y. Cai. 1992. The r.le programs for multiscale analysis of
landscape structure using the GRASS geographical information system.
Landscape Ecology 7: 291-302.
</p>
<p>Based on C++ code from Project Nayuki (https://www.nayuki.io/page/smallest-enclosing-circle).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lsm_p_circle">lsm_p_circle</a></code>,
<code><a href="base.html#topic+mean">mean</a></code>, <br />
<code><a href="#topic+lsm_c_circle_mn">lsm_c_circle_mn</a></code>,
<code><a href="#topic+lsm_c_circle_sd">lsm_c_circle_sd</a></code>,
<code><a href="#topic+lsm_c_circle_cv">lsm_c_circle_cv</a></code>, <br />
<code><a href="#topic+lsm_l_circle_mn">lsm_l_circle_mn</a></code>,
<code><a href="#topic+lsm_l_circle_cv">lsm_l_circle_cv</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>landscape &lt;- terra::rast(landscapemetrics::landscape)
lsm_l_circle_sd(landscape)

</code></pre>

<hr>
<h2 id='lsm_l_cohesion'>COHESION (landscape level)</h2><span id='topic+lsm_l_cohesion'></span>

<h3>Description</h3>

<p>Patch Cohesion Index (Aggregation metric)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lsm_l_cohesion(landscape, directions = 8)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lsm_l_cohesion_+3A_landscape">landscape</code></td>
<td>
<p>A categorical raster object: SpatRaster; Raster* Layer, Stack, Brick; stars or a list of SpatRasters.</p>
</td></tr>
<tr><td><code id="lsm_l_cohesion_+3A_directions">directions</code></td>
<td>
<p>The number of directions in which patches should be connected: 4 (rook's case) or 8 (queen's case).</p>
</td></tr>
</table>


<h3>Details</h3>

<p style="text-align: center;"><code class="reqn">COHESION = 1 - (\frac{\sum \limits_{i = 1}^{m} \sum \limits_{j = 1}^{n} p_{ij}} {\sum \limits_{i = 1}^{m} \sum \limits_{j = 1}^{n} p_{ij} \sqrt{a_{ij}}}) * (1 - \frac{1} {\sqrt{Z}}) ^ {-1} * 100</code>
</p>

<p>where <code class="reqn">p_{ij}</code> is the perimeter in meters, <code class="reqn">a_{ij}</code> is the area in square
meters and <code class="reqn">Z</code> is the number of cells.
</p>
<p>COHESION is an 'Aggregation metric'.
</p>
<p>Because the metric is based on distances or areas please make sure your data
is valid using <code><a href="#topic+check_landscape">check_landscape</a></code>.
</p>


<h4>Units</h4>

<p>Percent</p>



<h4>Ranges</h4>

<p>Unknown</p>



<h4>Behaviour</h4>

<p>Unknown</p>



<h3>Value</h3>

<p>tibble
</p>


<h3>References</h3>

<p>McGarigal K., SA Cushman, and E Ene. 2023. FRAGSTATS v4: Spatial Pattern Analysis
Program for Categorical Maps. Computer software program produced by the authors;
available at the following web site: https://www.fragstats.org
</p>
<p>Schumaker, N. H. 1996. Using landscape indices to predict habitat
connectivity. Ecology, 77(4), 1210-1225.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lsm_p_perim">lsm_p_perim</a></code>,
<code><a href="#topic+lsm_p_area">lsm_p_area</a></code>, <br />
<code><a href="#topic+lsm_l_cohesion">lsm_l_cohesion</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>landscape &lt;- terra::rast(landscapemetrics::landscape)
lsm_l_cohesion(landscape)

</code></pre>

<hr>
<h2 id='lsm_l_condent'>Conditional entropy (landscape level)</h2><span id='topic+lsm_l_condent'></span>

<h3>Description</h3>

<p>Conditional entropy \[H(y|x)\]
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lsm_l_condent(landscape, neighbourhood = 4, ordered = TRUE, base = "log2")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lsm_l_condent_+3A_landscape">landscape</code></td>
<td>
<p>A categorical raster object: SpatRaster; Raster* Layer, Stack, Brick; stars or a list of SpatRasters.</p>
</td></tr>
<tr><td><code id="lsm_l_condent_+3A_neighbourhood">neighbourhood</code></td>
<td>
<p>The number of directions in which cell adjacencies are considered as neighbours:
4 (rook's case) or 8 (queen's case). The default is 4.</p>
</td></tr>
<tr><td><code id="lsm_l_condent_+3A_ordered">ordered</code></td>
<td>
<p>The type of pairs considered.
Either ordered (TRUE) or unordered (FALSE).
The default is TRUE.</p>
</td></tr>
<tr><td><code id="lsm_l_condent_+3A_base">base</code></td>
<td>
<p>The unit in which entropy is measured.
The default is &quot;log2&quot;, which compute entropy in &quot;bits&quot;.
&quot;log&quot; and &quot;log10&quot; can be also used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Complexity of a landscape pattern configuration. It measures a only a geometric
intricacy (configurational complexity) of a landscape pattern.
</p>


<h3>Value</h3>

<p>tibble
</p>


<h3>References</h3>

<p>Nowosad J., TF Stepinski. 2019. Information theory as a consistent framework
for quantification and classification of landscape patterns. https://doi.org/10.1007/s10980-019-00830-x
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lsm_l_ent">lsm_l_ent</a></code>,
<code><a href="#topic+lsm_l_mutinf">lsm_l_mutinf</a></code>,
<code><a href="#topic+lsm_l_joinent">lsm_l_joinent</a></code>,
<code><a href="#topic+lsm_l_relmutinf">lsm_l_relmutinf</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>landscape &lt;- terra::rast(landscapemetrics::landscape)
lsm_l_condent(landscape)

</code></pre>

<hr>
<h2 id='lsm_l_contag'>CONTAG (landscape level)</h2><span id='topic+lsm_l_contag'></span>

<h3>Description</h3>

<p>Contagion (Aggregation metric)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lsm_l_contag(landscape, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lsm_l_contag_+3A_landscape">landscape</code></td>
<td>
<p>A categorical raster object: SpatRaster; Raster* Layer, Stack, Brick; stars or a list of SpatRasters.</p>
</td></tr>
<tr><td><code id="lsm_l_contag_+3A_verbose">verbose</code></td>
<td>
<p>Print warning message if not sufficient patches are present</p>
</td></tr>
</table>


<h3>Details</h3>

<p style="text-align: center;"><code class="reqn">CONTAG = 1 + \frac{\sum \limits_{q = 1}^{n_{a}} p_{q} ln(p_{q})}{2ln(t)}</code>
</p>

<p>where <code class="reqn">p_{q}</code> the adjacency table for all classes divided by the sum of that table and
<code class="reqn">t</code> the number of classes in the landscape.
</p>
<p>CONTAG is an 'Aggregation metric'. It is based on cell adjacencies and describes
the probability of two random cells belonging to the same class. <code class="reqn">p_{q}</code> is
the cell adjacency table, where the order is preserved and pairs of adjacent cells
are counted twice. Contagion is affected by both the dispersion and interspersion
of classes. E.g., low class dispersion (= high proportion of like adjacencies) and
low interspersion (= uneven distribution of pairwise adjacencies) lead to a high
contagion value.
</p>
<p>The number of classes to calculate CONTAG must be &gt;= than 2.
</p>


<h4>Units</h4>

<p>Percent</p>



<h4>Range</h4>

<p>0 &lt; Contag &lt;=100</p>



<h4>Behaviour</h4>

<p>Approaches CONTAG = 0 if all cells are unevenly distributed
and 100 indicates that all cells are equally adjacent to all other classes.</p>



<h3>Value</h3>

<p>tibble
</p>


<h3>References</h3>

<p>McGarigal K., SA Cushman, and E Ene. 2023. FRAGSTATS v4: Spatial Pattern Analysis
Program for Categorical Maps. Computer software program produced by the authors;
available at the following web site: https://www.fragstats.org
</p>
<p>Riitters, K.H., O'Neill, R.V., Wickham, J.D. &amp; Jones, K.B. (1996). A note on
contagion indices for landscape analysis. Landscape ecology, 11, 197-202.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>landscape &lt;- terra::rast(landscapemetrics::landscape)
lsm_l_contag(landscape)

</code></pre>

<hr>
<h2 id='lsm_l_contig_cv'>CONTIG_CV (landscape level)</h2><span id='topic+lsm_l_contig_cv'></span>

<h3>Description</h3>

<p>Coefficient of variation of Contiguity index (Shape metric)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lsm_l_contig_cv(landscape, directions = 8)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lsm_l_contig_cv_+3A_landscape">landscape</code></td>
<td>
<p>A categorical raster object: SpatRaster; Raster* Layer, Stack, Brick; stars or a list of SpatRasters.</p>
</td></tr>
<tr><td><code id="lsm_l_contig_cv_+3A_directions">directions</code></td>
<td>
<p>The number of directions in which patches should be connected: 4 (rook's case) or 8 (queen's case).</p>
</td></tr>
</table>


<h3>Details</h3>

<p style="text-align: center;"><code class="reqn">CONTIG_{CV} =  cv(CONTIG[patch_{ij}])</code>
</p>

<p>where <code class="reqn">CONTIG[patch_{ij}]</code> is the contiguity of each patch.
</p>
<p>CONTIG_CV is a 'Shape metric'. It summarises the landscape as the coefficient of variation of all patches
in the landscape. CONTIG_CV asses the spatial connectedness (contiguity) of
cells in patches. The metric coerces patch values to a value of 1 and the background
to NA. A nine cell focal filter matrix:
</p>
<div class="sourceCode"><pre>filter_matrix &lt;- matrix(c(1, 2, 1,
                          2, 1, 2,
                          1, 2, 1), 3, 3, byrow = T)
</pre></div>
<p>... is then used to weight orthogonally contiguous pixels more heavily than
diagonally contiguous pixels. Therefore, larger and more connections between
patch cells in the rookie case result in larger contiguity index values.
</p>


<h4>Units</h4>

<p>None</p>



<h4>Range</h4>

<p>CONTIG_CV &gt;= 0</p>



<h4>Behaviour</h4>

<p>CONTIG_CV = 0 if the contiguity index is
identical for all patches. Increases, without limit, as the variation of
CONTIG increases.</p>



<h3>Value</h3>

<p>tibble
</p>


<h3>References</h3>

<p>McGarigal K., SA Cushman, and E Ene. 2023. FRAGSTATS v4: Spatial Pattern Analysis
Program for Categorical Maps. Computer software program produced by the authors;
available at the following web site: https://www.fragstats.org
</p>
<p>LaGro, J. 1991. Assessing patch shape in landscape mosaics.
Photogrammetric Engineering and Remote Sensing, 57(3), 285-293
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lsm_p_contig">lsm_p_contig</a></code>,
<code><a href="#topic+lsm_c_contig_sd">lsm_c_contig_sd</a></code>,
<code><a href="#topic+lsm_c_contig_cv">lsm_c_contig_cv</a></code>,
<code><a href="#topic+lsm_c_contig_mn">lsm_c_contig_mn</a></code>, <br />
<code><a href="#topic+lsm_l_contig_sd">lsm_l_contig_sd</a></code>,
<code><a href="#topic+lsm_l_contig_mn">lsm_l_contig_mn</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>landscape &lt;- terra::rast(landscapemetrics::landscape)
lsm_l_contig_cv(landscape)

</code></pre>

<hr>
<h2 id='lsm_l_contig_mn'>CONTIG_MN (landscape level)</h2><span id='topic+lsm_l_contig_mn'></span>

<h3>Description</h3>

<p>Mean of Contiguity index (Shape metric)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lsm_l_contig_mn(landscape, directions = 8)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lsm_l_contig_mn_+3A_landscape">landscape</code></td>
<td>
<p>A categorical raster object: SpatRaster; Raster* Layer, Stack, Brick; stars or a list of SpatRasters.</p>
</td></tr>
<tr><td><code id="lsm_l_contig_mn_+3A_directions">directions</code></td>
<td>
<p>The number of directions in which patches should be connected: 4 (rook's case) or 8 (queen's case).</p>
</td></tr>
</table>


<h3>Details</h3>

<p style="text-align: center;"><code class="reqn">CONTIG_{MN} =  mean(CONTIG[patch_{i}])</code>
</p>

<p>where <code class="reqn">CONTIG[patch_{ij}]</code> is the contiguity of each patch.
</p>
<p>CONTIG_MN is a 'Shape metric'. It summarises the landscape as the mean of all patches
in the landscape. CONTIG_MN asses the spatial connectedness (contiguity) of
cells in patches. The metric coerces patch values to a value of 1 and the background
to NA. A nine cell focal filter matrix:
</p>
<div class="sourceCode"><pre>filter_matrix &lt;- matrix(c(1, 2, 1,
                          2, 1, 2,
                          1, 2, 1), 3, 3, byrow = T)
</pre></div>
<p>... is then used to weight orthogonally contiguous pixels more heavily than
diagonally contiguous pixels. Therefore, larger and more connections between
patch cells in the rookie case result in larger contiguity index values.
</p>


<h4>Units</h4>

<p>None</p>



<h4>Range</h4>

<p>0 &gt;= CONTIG_MN &lt;= 1</p>



<h4>Behaviour</h4>

<p>CONTIG equals the mean of the contiguity index on landscape level for all
patches.</p>



<h3>Value</h3>

<p>tibble
</p>


<h3>References</h3>

<p>McGarigal K., SA Cushman, and E Ene. 2023. FRAGSTATS v4: Spatial Pattern Analysis
Program for Categorical Maps. Computer software program produced by the authors;
available at the following web site: https://www.fragstats.org
</p>
<p>LaGro, J. 1991. Assessing patch shape in landscape mosaics.
Photogrammetric Engineering and Remote Sensing, 57(3), 285-293
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lsm_p_contig">lsm_p_contig</a></code>,
<code><a href="#topic+lsm_c_contig_sd">lsm_c_contig_sd</a></code>,
<code><a href="#topic+lsm_c_contig_cv">lsm_c_contig_cv</a></code>,
<code><a href="#topic+lsm_c_contig_mn">lsm_c_contig_mn</a></code>, <br />
<code><a href="#topic+lsm_l_contig_sd">lsm_l_contig_sd</a></code>,
<code><a href="#topic+lsm_l_contig_cv">lsm_l_contig_cv</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>landscape &lt;- terra::rast(landscapemetrics::landscape)
lsm_l_contig_mn(landscape)

</code></pre>

<hr>
<h2 id='lsm_l_contig_sd'>CONTIG_SD (landscape level)</h2><span id='topic+lsm_l_contig_sd'></span>

<h3>Description</h3>

<p>Standard deviation of Contiguity index (Shape metric)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lsm_l_contig_sd(landscape, directions = 8)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lsm_l_contig_sd_+3A_landscape">landscape</code></td>
<td>
<p>A categorical raster object: SpatRaster; Raster* Layer, Stack, Brick; stars or a list of SpatRasters.</p>
</td></tr>
<tr><td><code id="lsm_l_contig_sd_+3A_directions">directions</code></td>
<td>
<p>The number of directions in which patches should be connected: 4 (rook's case) or 8 (queen's case).</p>
</td></tr>
</table>


<h3>Details</h3>

<p style="text-align: center;"><code class="reqn">CONTIG_{SD} =  sd(CONTIG[patch_{ij}])</code>
</p>

<p>where <code class="reqn">CONTIG[patch_{ij}]</code> is the contiguity of each patch.
</p>
<p>CONTIG_SD is a 'Shape metric'. It summarises the landscape as the standard deviation of all patches
in the landscape. CONTIG_SD asses the spatial connectedness (contiguity) of
cells in patches. The metric coerces patch values to a value of 1 and the background
to NA. A nine cell focal filter matrix:
</p>
<div class="sourceCode"><pre>filter_matrix &lt;- matrix(c(1, 2, 1,
                          2, 1, 2,
                          1, 2, 1), 3, 3, byrow = TRUE)
</pre></div>
<p>... is then used to weight orthogonally contiguous pixels more heavily than
diagonally contiguous pixels. Therefore, larger and more connections between
patch cells in the rookie case result in larger contiguity index values.
</p>


<h4>Units</h4>

<p>None</p>



<h4>Range</h4>

<p>CONTIG_SD &gt;= 0</p>



<h4>Behaviour</h4>

<p>CONTIG_SD = 0 if the contiguity index is
identical for all patches. Increases, without limit, as the variation of
CONTIG increases.</p>



<h3>Value</h3>

<p>tibble
</p>


<h3>References</h3>

<p>McGarigal K., SA Cushman, and E Ene. 2023. FRAGSTATS v4: Spatial Pattern Analysis
Program for Categorical Maps. Computer software program produced by the authors;
available at the following web site: https://www.fragstats.org
</p>
<p>LaGro, J. 1991. Assessing patch shape in landscape mosaics.
Photogrammetric Engineering and Remote Sensing, 57(3), 285-293
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lsm_p_contig">lsm_p_contig</a></code>,
<code><a href="#topic+lsm_c_contig_sd">lsm_c_contig_sd</a></code>,
<code><a href="#topic+lsm_c_contig_cv">lsm_c_contig_cv</a></code>,
<code><a href="#topic+lsm_c_contig_mn">lsm_c_contig_mn</a></code>, <br />
<code><a href="#topic+lsm_l_contig_cv">lsm_l_contig_cv</a></code>,
<code><a href="#topic+lsm_l_contig_mn">lsm_l_contig_mn</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>landscape &lt;- terra::rast(landscapemetrics::landscape)
lsm_l_contig_sd(landscape)

</code></pre>

<hr>
<h2 id='lsm_l_core_cv'>CORE_CV (landscape level)</h2><span id='topic+lsm_l_core_cv'></span>

<h3>Description</h3>

<p>Coefficient of variation of core area (Core area metric)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lsm_l_core_cv(
  landscape,
  directions = 8,
  consider_boundary = FALSE,
  edge_depth = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lsm_l_core_cv_+3A_landscape">landscape</code></td>
<td>
<p>A categorical raster object: SpatRaster; Raster* Layer, Stack, Brick; stars or a list of SpatRasters.</p>
</td></tr>
<tr><td><code id="lsm_l_core_cv_+3A_directions">directions</code></td>
<td>
<p>The number of directions in which patches should be
connected: 4 (rook's case) or 8 (queen's case).</p>
</td></tr>
<tr><td><code id="lsm_l_core_cv_+3A_consider_boundary">consider_boundary</code></td>
<td>
<p>Logical if cells that only neighbour the landscape
boundary should be considered as core</p>
</td></tr>
<tr><td><code id="lsm_l_core_cv_+3A_edge_depth">edge_depth</code></td>
<td>
<p>Distance (in cells) a cell has the be away from the patch
edge to be considered as core cell</p>
</td></tr>
</table>


<h3>Details</h3>

<p style="text-align: center;"><code class="reqn">CORE_{CV} = cv(CORE[patch_{ij}])</code>
</p>

<p>where <code class="reqn">CORE[patch_{ij}]</code> is the core area in square meters of each patch.
</p>
<p>CORE_CV is a 'Core area metric'. It equals the Coefficient of variation of the core area
of each patch in the landscape. The core area is defined as all cells that have no
neighbour with a different value than themselves (rook's case). The metric describes the
differences among all patches in the landscape and is easily comparable
because it is scaled to the mean.
</p>
<p>Because the metric is based on distances or areas please make sure your data
is valid using <code><a href="#topic+check_landscape">check_landscape</a></code>.
</p>


<h4>Units</h4>

<p>Hectares</p>



<h4>Range</h4>

<p>CORE_CV &gt;= 0</p>



<h4>Behaviour</h4>

<p>Equals CORE_CV = 0 if all patches have the same core area.
Increases, without limit, as the variation of patch core areas increases.</p>



<h3>Value</h3>

<p>tibble
</p>


<h3>References</h3>

<p>McGarigal K., SA Cushman, and E Ene. 2023. FRAGSTATS v4: Spatial Pattern Analysis
Program for Categorical Maps. Computer software program produced by the authors;
available at the following web site: https://www.fragstats.org
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lsm_p_core">lsm_p_core</a></code>, <br />
<code><a href="#topic+lsm_c_core_mn">lsm_c_core_mn</a></code>,
<code><a href="#topic+lsm_c_core_sd">lsm_c_core_sd</a></code>,
<code><a href="#topic+lsm_c_core_cv">lsm_c_core_cv</a></code>, <br />
<code><a href="#topic+lsm_l_core_mn">lsm_l_core_mn</a></code>,
<code><a href="#topic+lsm_l_core_sd">lsm_l_core_sd</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>landscape &lt;- terra::rast(landscapemetrics::landscape)
lsm_l_core_cv(landscape)

</code></pre>

<hr>
<h2 id='lsm_l_core_mn'>CORE_MN (landscape level)</h2><span id='topic+lsm_l_core_mn'></span>

<h3>Description</h3>

<p>Mean of core area (Core area metric)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lsm_l_core_mn(
  landscape,
  directions = 8,
  consider_boundary = FALSE,
  edge_depth = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lsm_l_core_mn_+3A_landscape">landscape</code></td>
<td>
<p>A categorical raster object: SpatRaster; Raster* Layer, Stack, Brick; stars or a list of SpatRasters.</p>
</td></tr>
<tr><td><code id="lsm_l_core_mn_+3A_directions">directions</code></td>
<td>
<p>The number of directions in which patches should be
connected: 4 (rook's case) or 8 (queen's case).</p>
</td></tr>
<tr><td><code id="lsm_l_core_mn_+3A_consider_boundary">consider_boundary</code></td>
<td>
<p>Logical if cells that only neighbour the landscape
boundary should be considered as core</p>
</td></tr>
<tr><td><code id="lsm_l_core_mn_+3A_edge_depth">edge_depth</code></td>
<td>
<p>Distance (in cells) a cell has the be away from the patch
edge to be considered as core cell</p>
</td></tr>
</table>


<h3>Details</h3>

<p style="text-align: center;"><code class="reqn">CORE_{MN} = mean(CORE[patch_{ij}])</code>
</p>

<p>where <code class="reqn">CORE[patch_{ij}]</code> is the core area in square meters of each patch.
</p>
<p>CORE_MN is a 'Core area metric' and equals the mean of core areas of all patches
in the landscape. The core area is defined as all cells that have no
neighbour with a different value than themselves (rook's case).
</p>
<p>Because the metric is based on distances or areas please make sure your data
is valid using <code><a href="#topic+check_landscape">check_landscape</a></code>.
</p>


<h4>Units</h4>

<p>Hectares</p>



<h4>Range</h4>

<p>CORE_MN &gt;= 0</p>



<h4>Behaviour</h4>

<p>Equals CORE_MN = 0 if CORE = 0 for all patches. Increases,
without limit, as the core area indices increase.</p>



<h3>Value</h3>

<p>tibble
</p>


<h3>References</h3>

<p>McGarigal K., SA Cushman, and E Ene. 2023. FRAGSTATS v4: Spatial Pattern Analysis
Program for Categorical Maps. Computer software program produced by the authors;
available at the following web site: https://www.fragstats.org
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lsm_p_core">lsm_p_core</a></code>,
<code><a href="base.html#topic+mean">mean</a></code>, <br />
<code><a href="#topic+lsm_c_core_mn">lsm_c_core_mn</a></code>,
<code><a href="#topic+lsm_c_core_sd">lsm_c_core_sd</a></code>,
<code><a href="#topic+lsm_c_core_cv">lsm_c_core_cv</a></code>, <br />
<code><a href="#topic+lsm_l_core_sd">lsm_l_core_sd</a></code>,
<code><a href="#topic+lsm_l_core_cv">lsm_l_core_cv</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>landscape &lt;- terra::rast(landscapemetrics::landscape)
lsm_l_core_mn(landscape)

</code></pre>

<hr>
<h2 id='lsm_l_core_sd'>CORE_SD (landscape level)</h2><span id='topic+lsm_l_core_sd'></span>

<h3>Description</h3>

<p>Standard deviation of patch core area (class level)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lsm_l_core_sd(
  landscape,
  directions = 8,
  consider_boundary = FALSE,
  edge_depth = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lsm_l_core_sd_+3A_landscape">landscape</code></td>
<td>
<p>A categorical raster object: SpatRaster; Raster* Layer, Stack, Brick; stars or a list of SpatRasters.</p>
</td></tr>
<tr><td><code id="lsm_l_core_sd_+3A_directions">directions</code></td>
<td>
<p>The number of directions in which patches should be
connected: 4 (rook's case) or 8 (queen's case).</p>
</td></tr>
<tr><td><code id="lsm_l_core_sd_+3A_consider_boundary">consider_boundary</code></td>
<td>
<p>Logical if cells that only neighbour the landscape
boundary should be considered as core</p>
</td></tr>
<tr><td><code id="lsm_l_core_sd_+3A_edge_depth">edge_depth</code></td>
<td>
<p>Distance (in cells) a cell has the be away from the patch
edge to be considered as core cell</p>
</td></tr>
</table>


<h3>Details</h3>

<p style="text-align: center;"><code class="reqn">CORE_{SD} = sd(CORE[patch_{ij}])</code>
</p>

<p>where <code class="reqn">CORE[patch_{ij}]</code> is the core area in square meters of each patch.
</p>
<p>CORE_SD is a 'Core area metric'. It equals the standard deviation of the core area
of all patches in the landscape. The core area is defined as all cells that have no
neighbour with a different value than themselves (rook's case). The metric describes the
differences among all patches in the landscape.
</p>
<p>Because the metric is based on distances or areas please make sure your data
is valid using <code><a href="#topic+check_landscape">check_landscape</a></code>.
</p>


<h4>Units</h4>

<p>Hectares</p>



<h4>Range</h4>

<p>CORE_SD &gt;= 0</p>



<h4>Behaviour</h4>

<p>Equals CORE_SD = 0 if all patches have the same core area.
Increases, without limit, as the variation of patch core areas increases.</p>



<h3>Value</h3>

<p>tibble
</p>


<h3>References</h3>

<p>McGarigal K., SA Cushman, and E Ene. 2023. FRAGSTATS v4: Spatial Pattern Analysis
Program for Categorical Maps. Computer software program produced by the authors;
available at the following web site: https://www.fragstats.org
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lsm_p_core">lsm_p_core</a></code>,
<code><a href="stats.html#topic+sd">sd</a></code> <br />
<code><a href="#topic+lsm_c_core_mn">lsm_c_core_mn</a></code>,
<code><a href="#topic+lsm_c_core_sd">lsm_c_core_sd</a></code>,
<code><a href="#topic+lsm_c_core_cv">lsm_c_core_cv</a></code>, <br />
<code><a href="#topic+lsm_l_core_mn">lsm_l_core_mn</a></code>,
<code><a href="#topic+lsm_l_core_cv">lsm_l_core_cv</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>landscape &lt;- terra::rast(landscapemetrics::landscape)
lsm_l_core_sd(landscape)

</code></pre>

<hr>
<h2 id='lsm_l_dcad'>DCAD (landscape level)</h2><span id='topic+lsm_l_dcad'></span>

<h3>Description</h3>

<p>Disjunct core area density (core area metric)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lsm_l_dcad(
  landscape,
  directions = 8,
  consider_boundary = FALSE,
  edge_depth = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lsm_l_dcad_+3A_landscape">landscape</code></td>
<td>
<p>A categorical raster object: SpatRaster; Raster* Layer, Stack, Brick; stars or a list of SpatRasters.</p>
</td></tr>
<tr><td><code id="lsm_l_dcad_+3A_directions">directions</code></td>
<td>
<p>The number of directions in which patches should be
connected: 4 (rook's case) or 8 (queen's case).</p>
</td></tr>
<tr><td><code id="lsm_l_dcad_+3A_consider_boundary">consider_boundary</code></td>
<td>
<p>Logical if cells that only neighbour the landscape
boundary should be considered as core</p>
</td></tr>
<tr><td><code id="lsm_l_dcad_+3A_edge_depth">edge_depth</code></td>
<td>
<p>Distance (in cells) a cell has the be away from the patch
edge to be considered as core cell</p>
</td></tr>
</table>


<h3>Details</h3>

<p style="text-align: center;"><code class="reqn">DCAD = (\frac{\sum \limits_{i = 1}^{m} \sum \limits_{j = 1}^{n} n_{ij}^{core}} {A}) * 10000 * 100</code>
</p>

<p>where <code class="reqn">n_{ij}^{core}</code> is the number of disjunct core areas and <code class="reqn">A</code>
is the total landscape area in square meters.
</p>
<p>DCAD is a 'Core area metric'. It equals the number of disjunct core areas per
100 ha relative to the total area. A disjunct core area is a 'patch within
the patch' containing only core cells. A cell is defined as core area if the cell has no
neighbour with a different value than itself (rook's case). The metric is relative and
therefore comparable among landscapes with different total areas.
</p>
<p>Because the metric is based on distances or areas please make sure your data
is valid using <code><a href="#topic+check_landscape">check_landscape</a></code>.
</p>


<h4>Units</h4>

<p>Number per 100 hectares</p>



<h4>Range</h4>

<p>DCAD &gt;= 0</p>



<h4>Behaviour</h4>

<p>Equals DCAD = 0 when DCORE = 0, i.e. no patch contains
a disjunct core area. Increases, without limit, as disjunct core areas become more
present, i.e. patches becoming larger and less complex.</p>



<h3>Value</h3>

<p>tibble
</p>


<h3>References</h3>

<p>McGarigal K., SA Cushman, and E Ene. 2023. FRAGSTATS v4: Spatial Pattern Analysis
Program for Categorical Maps. Computer software program produced by the authors;
available at the following web site: https://www.fragstats.org
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lsm_c_ndca">lsm_c_ndca</a></code>,
<code><a href="#topic+lsm_l_ta">lsm_l_ta</a></code>, <br />
<code><a href="#topic+lsm_c_dcad">lsm_c_dcad</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>landscape &lt;- terra::rast(landscapemetrics::landscape)
lsm_l_dcad(landscape)

</code></pre>

<hr>
<h2 id='lsm_l_dcore_cv'>DCORE_CV (landscape level)</h2><span id='topic+lsm_l_dcore_cv'></span>

<h3>Description</h3>

<p>Coefficient of variation number of disjunct core areas (Core area metric)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lsm_l_dcore_cv(
  landscape,
  directions = 8,
  consider_boundary = FALSE,
  edge_depth = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lsm_l_dcore_cv_+3A_landscape">landscape</code></td>
<td>
<p>A categorical raster object: SpatRaster; Raster* Layer, Stack, Brick; stars or a list of SpatRasters.</p>
</td></tr>
<tr><td><code id="lsm_l_dcore_cv_+3A_directions">directions</code></td>
<td>
<p>The number of directions in which patches should be
connected: 4 (rook's case) or 8 (queen's case).</p>
</td></tr>
<tr><td><code id="lsm_l_dcore_cv_+3A_consider_boundary">consider_boundary</code></td>
<td>
<p>Logical if cells that only neighbour the landscape
boundary should be considered as core</p>
</td></tr>
<tr><td><code id="lsm_l_dcore_cv_+3A_edge_depth">edge_depth</code></td>
<td>
<p>Distance (in cells) a cell has the be away from the patch
edge to be considered as core cell</p>
</td></tr>
</table>


<h3>Details</h3>

<p style="text-align: center;"><code class="reqn">DCORE_{CV} = cv(NCORE[patch_{ij}])</code>
</p>

<p>where <code class="reqn">NCORE[patch_{ij}]</code> is the number of core areas.
</p>
<p>DCORE_CV is an 'Core area metric'. It summarises the landscape as the Coefficient
of variation of all patches belonging to the landscape. A cell is defined as core if
the cell has no neighbour with a different value than itself (rook's case). NCORE counts
the disjunct core areas, whereby a core area is a 'patch within the patch' containing
only core cells. The metric describes the differences among all patches in the landscape
and is easily comparable because it is scaled to the mean.
</p>


<h4>Units</h4>

<p>None</p>



<h4>Range</h4>

<p>DCORE_CV &gt;= 0</p>



<h4>Behaviour</h4>

<p>Equals DCORE_CV = 0 if all patches have the same number of disjunct
core areas. Increases, without limit, as the variation of number of disjunct core areas
increases.</p>



<h3>Value</h3>

<p>tibble
</p>


<h3>References</h3>

<p>McGarigal K., SA Cushman, and E Ene. 2023. FRAGSTATS v4: Spatial Pattern Analysis
Program for Categorical Maps. Computer software program produced by the authors;
available at the following web site: https://www.fragstats.org
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lsm_p_ncore">lsm_p_ncore</a></code>, <br />
<code><a href="#topic+lsm_c_dcore_mn">lsm_c_dcore_mn</a></code>,
<code><a href="#topic+lsm_c_dcore_sd">lsm_c_dcore_sd</a></code>,
<code><a href="#topic+lsm_c_dcore_cv">lsm_c_dcore_cv</a></code>, <br />
<code><a href="#topic+lsm_l_dcore_mn">lsm_l_dcore_mn</a></code>,
<code><a href="#topic+lsm_l_dcore_sd">lsm_l_dcore_sd</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>landscape &lt;- terra::rast(landscapemetrics::landscape)
lsm_l_dcore_cv(landscape)

</code></pre>

<hr>
<h2 id='lsm_l_dcore_mn'>DCORE_MN (landscape level)</h2><span id='topic+lsm_l_dcore_mn'></span>

<h3>Description</h3>

<p>Mean number of disjunct core areas (Core area metric)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lsm_l_dcore_mn(
  landscape,
  directions = 8,
  consider_boundary = FALSE,
  edge_depth = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lsm_l_dcore_mn_+3A_landscape">landscape</code></td>
<td>
<p>A categorical raster object: SpatRaster; Raster* Layer, Stack, Brick; stars or a list of SpatRasters.</p>
</td></tr>
<tr><td><code id="lsm_l_dcore_mn_+3A_directions">directions</code></td>
<td>
<p>The number of directions in which patches should be
connected: 4 (rook's case) or 8 (queen's case).</p>
</td></tr>
<tr><td><code id="lsm_l_dcore_mn_+3A_consider_boundary">consider_boundary</code></td>
<td>
<p>Logical if cells that only neighbour the landscape
boundary should be considered as core</p>
</td></tr>
<tr><td><code id="lsm_l_dcore_mn_+3A_edge_depth">edge_depth</code></td>
<td>
<p>Distance (in cells) a cell has the be away from the patch
edge to be considered as core cell</p>
</td></tr>
</table>


<h3>Details</h3>

<p style="text-align: center;"><code class="reqn">DCORE_{MN} = mean(NCORE[patch_{ij}])</code>
</p>

<p>where <code class="reqn">NCORE[patch_{ij}]</code> is the number of core areas.
</p>
<p>DCORE_MN is an 'Core area metric'. It summarises the landscape as the mean of all
patches in the landscape. A cell is defined as core if the cell has no neighbour with
a different value than itself (rook's case). NCORE counts the disjunct core areas,
whereby a core area is a 'patch within the patch' containing only core cells.
</p>


<h4>Units</h4>

<p>None</p>



<h4>Range</h4>

<p>DCORE_MN &gt; 0</p>



<h4>Behaviour</h4>

<p>Equals DCORE_MN = 0 if NCORE = 0 for all patches. Increases,
without limit, as the number of disjunct core areas increases.</p>



<h3>Value</h3>

<p>tibble
</p>


<h3>References</h3>

<p>McGarigal K., SA Cushman, and E Ene. 2023. FRAGSTATS v4: Spatial Pattern Analysis
Program for Categorical Maps. Computer software program produced by the authors;
available at the following web site: https://www.fragstats.org
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lsm_p_ncore">lsm_p_ncore</a></code>,
<code><a href="base.html#topic+mean">mean</a></code>, <br />
<code><a href="#topic+lsm_c_dcore_mn">lsm_c_dcore_mn</a></code>,
<code><a href="#topic+lsm_c_dcore_sd">lsm_c_dcore_sd</a></code>,
<code><a href="#topic+lsm_c_dcore_cv">lsm_c_dcore_cv</a></code>, <br />
<code><a href="#topic+lsm_l_dcore_sd">lsm_l_dcore_sd</a></code>,
<code><a href="#topic+lsm_l_dcore_cv">lsm_l_dcore_cv</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>landscape &lt;- terra::rast(landscapemetrics::landscape)
lsm_l_dcore_mn(landscape)

</code></pre>

<hr>
<h2 id='lsm_l_dcore_sd'>DCORE_SD (landscape level)</h2><span id='topic+lsm_l_dcore_sd'></span>

<h3>Description</h3>

<p>Standard deviation number of disjunct core areas (Core area metric)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lsm_l_dcore_sd(
  landscape,
  directions = 8,
  consider_boundary = FALSE,
  edge_depth = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lsm_l_dcore_sd_+3A_landscape">landscape</code></td>
<td>
<p>A categorical raster object: SpatRaster; Raster* Layer, Stack, Brick; stars or a list of SpatRasters.</p>
</td></tr>
<tr><td><code id="lsm_l_dcore_sd_+3A_directions">directions</code></td>
<td>
<p>The number of directions in which patches should be
connected: 4 (rook's case) or 8 (queen's case).</p>
</td></tr>
<tr><td><code id="lsm_l_dcore_sd_+3A_consider_boundary">consider_boundary</code></td>
<td>
<p>Logical if cells that only neighbour the landscape
boundary should be considered as core</p>
</td></tr>
<tr><td><code id="lsm_l_dcore_sd_+3A_edge_depth">edge_depth</code></td>
<td>
<p>Distance (in cells) a cell has the be away from the patch
edge to be considered as core cell</p>
</td></tr>
</table>


<h3>Details</h3>

<p style="text-align: center;"><code class="reqn">DCORE_{SD} = sd(NCORE[patch_{ij}])</code>
</p>

<p>where <code class="reqn">NCORE[patch_{ij}]</code> is the number of core areas.
</p>
<p>DCORE_SD is an 'Core area metric'. It summarises the landscape as the standard deviation
of all patches. A cell is defined as core if the cell has no neighbour with a different
value than itself (rook's case). NCORE counts the disjunct core areas, whereby a core
area is a 'patch within the patch' containing only core cells. The metric describes the
differences among all patches in the landscape.
</p>


<h4>Units</h4>

<p>None</p>



<h4>Range</h4>

<p>DCORE_SD &gt;= 0</p>



<h4>Behaviour</h4>

<p>Equals DCORE_SD = 0 if all patches have the same number of disjunct
core areas. Increases, without limit, as the variation of number of disjunct core areas
increases.</p>



<h3>Value</h3>

<p>tibble
</p>


<h3>References</h3>

<p>McGarigal K., SA Cushman, and E Ene. 2023. FRAGSTATS v4: Spatial Pattern Analysis
Program for Categorical Maps. Computer software program produced by the authors;
available at the following web site: https://www.fragstats.org
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lsm_p_ncore">lsm_p_ncore</a></code>,
<code><a href="stats.html#topic+sd">sd</a></code> <br />
<code><a href="#topic+lsm_c_dcore_mn">lsm_c_dcore_mn</a></code>,
<code><a href="#topic+lsm_c_dcore_sd">lsm_c_dcore_sd</a></code>, <br />
<code><a href="#topic+lsm_c_dcore_cv">lsm_c_dcore_cv</a></code>,
<code><a href="#topic+lsm_l_dcore_mn">lsm_l_dcore_mn</a></code>,
<code><a href="#topic+lsm_l_dcore_cv">lsm_l_dcore_cv</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>landscape &lt;- terra::rast(landscapemetrics::landscape)
lsm_l_dcore_sd(landscape)

</code></pre>

<hr>
<h2 id='lsm_l_division'>DIVISION (landscape level)</h2><span id='topic+lsm_l_division'></span>

<h3>Description</h3>

<p>Landscape division index (Aggregation metric)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lsm_l_division(landscape, directions = 8)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lsm_l_division_+3A_landscape">landscape</code></td>
<td>
<p>A categorical raster object: SpatRaster; Raster* Layer, Stack, Brick; stars or a list of SpatRasters.</p>
</td></tr>
<tr><td><code id="lsm_l_division_+3A_directions">directions</code></td>
<td>
<p>The number of directions in which patches should be connected: 4 (rook's case) or 8 (queen's case).</p>
</td></tr>
</table>


<h3>Details</h3>

<p style="text-align: center;"><code class="reqn">DIVISON = (1 - \sum \limits_{i = 1}^{m} \sum \limits_{j = 1}^{n} (\frac{a_{ij}} {A}) ^ 2) </code>
</p>

<p>where <code class="reqn">a_{ij}</code> is the area in square meters and <code class="reqn">A</code> is the total
landscape area in square meters.
</p>
<p>DIVISION is an 'Aggregation metric. It can be in as the probability that two
randomly selected cells are not located in the same patch. The landscape
division index is negatively correlated with the  effective mesh size (<code><a href="#topic+lsm_l_mesh">lsm_l_mesh</a></code>).
</p>
<p>Because the metric is based on distances or areas please make sure your data
is valid using <code><a href="#topic+check_landscape">check_landscape</a></code>.
</p>


<h4>Units</h4>

<p>Proportion </p>



<h4>Ranges</h4>

<p>0 &lt;= Division &lt; 1</p>



<h4>Behaviour</h4>

<p>Equals DIVISION = 0 if only one patch is present. Approaches
DIVISION = 1 if all patches of class i are single cells.</p>



<h3>Value</h3>

<p>tibble
</p>


<h3>References</h3>

<p>McGarigal K., SA Cushman, and E Ene. 2023. FRAGSTATS v4: Spatial Pattern Analysis
Program for Categorical Maps. Computer software program produced by the authors;
available at the following web site: https://www.fragstats.org
</p>
<p>Jaeger, J. A. 2000. Landscape division, splitting index, and effective mesh
size: new measures of landscape fragmentation.
Landscape ecology, 15(2), 115-130.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lsm_p_area">lsm_p_area</a></code>,
<code><a href="#topic+lsm_l_ta">lsm_l_ta</a></code>, <br />
<code><a href="#topic+lsm_c_division">lsm_c_division</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>landscape &lt;- terra::rast(landscapemetrics::landscape)
lsm_l_division(landscape)

</code></pre>

<hr>
<h2 id='lsm_l_ed'>ED (landscape level)</h2><span id='topic+lsm_l_ed'></span>

<h3>Description</h3>

<p>Edge Density (Area and Edge metric)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lsm_l_ed(landscape, count_boundary = FALSE, directions = 8)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lsm_l_ed_+3A_landscape">landscape</code></td>
<td>
<p>A categorical raster object: SpatRaster; Raster* Layer, Stack, Brick; stars or a list of SpatRasters.</p>
</td></tr>
<tr><td><code id="lsm_l_ed_+3A_count_boundary">count_boundary</code></td>
<td>
<p>Count landscape boundary as edge</p>
</td></tr>
<tr><td><code id="lsm_l_ed_+3A_directions">directions</code></td>
<td>
<p>The number of directions in which patches should be connected: 4 (rook's case) or 8 (queen's case).</p>
</td></tr>
</table>


<h3>Details</h3>

<p style="text-align: center;"><code class="reqn">ED = \frac{E} {A} * 10000</code>
</p>

<p>where <code class="reqn">E</code> is the total landscape edge in meters and <code class="reqn">A</code> is the total
landscape area in square meters.
</p>
<p>ED is an 'Area and Edge metric'. The edge density equals all edges in the landscape
in relation to the landscape area. The boundary of the landscape is only included in the
corresponding total class edge length if <code>count_boundary = TRUE</code>.
The metric describes the configuration of the landscape, e.g. because an overall aggregation
of  classes will result in a low edge density. The metric is standardized to the
total landscape area, and therefore comparisons among landscapes with different total
areas are possible.
</p>
<p>Because the metric is based on distances or areas please make sure your data
is valid using <code><a href="#topic+check_landscape">check_landscape</a></code>.
</p>


<h4>Units</h4>

<p>Meters per hectare</p>



<h4>Range</h4>

<p>ED &gt;= 0</p>



<h4>Behaviour</h4>

<p>Equals ED = 0 if only one patch is present (and the landscape
boundary is not included) and increases, without limit, as the landscapes becomes more
patchy</p>



<h3>Value</h3>

<p>tibble
</p>


<h3>References</h3>

<p>McGarigal K., SA Cushman, and E Ene. 2023. FRAGSTATS v4: Spatial Pattern Analysis
Program for Categorical Maps. Computer software program produced by the authors;
available at the following web site: https://www.fragstats.org
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lsm_l_te">lsm_l_te</a></code>,
<code><a href="#topic+lsm_l_ta">lsm_l_ta</a></code>, <br />
<code><a href="#topic+lsm_c_ed">lsm_c_ed</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>landscape &lt;- terra::rast(landscapemetrics::landscape)
lsm_l_ed(landscape)

</code></pre>

<hr>
<h2 id='lsm_l_enn_cv'>ENN_CV (landscape level)</h2><span id='topic+lsm_l_enn_cv'></span>

<h3>Description</h3>

<p>Coefficient of variation of euclidean nearest-neighbor distance (Aggregation metric)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lsm_l_enn_cv(landscape, directions = 8, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lsm_l_enn_cv_+3A_landscape">landscape</code></td>
<td>
<p>A categorical raster object: SpatRaster; Raster* Layer, Stack, Brick; stars or a list of SpatRasters.</p>
</td></tr>
<tr><td><code id="lsm_l_enn_cv_+3A_directions">directions</code></td>
<td>
<p>The number of directions in which patches should be connected: 4 (rook's case) or 8 (queen's case).</p>
</td></tr>
<tr><td><code id="lsm_l_enn_cv_+3A_verbose">verbose</code></td>
<td>
<p>Print warning message if not sufficient patches are present</p>
</td></tr>
</table>


<h3>Details</h3>

<p style="text-align: center;"><code class="reqn">ENN_{CV} = cv(ENN[patch_{ij}])</code>
</p>

<p>where <code class="reqn">ENN[patch_{ij}]</code> is the euclidean nearest-neighbor distance
of each patch.
</p>
<p>ENN_CV is an 'Aggregation metric'. It summarises the landscape as the Coefficient
of variation of all patches in the landscape. ENN measures the distance to the  nearest
neighbouring patch of the same class i. The distance is measured from edge-to-edge.
The range is limited by the cell resolution on the lower limit and the landscape extent
on the upper limit. The metric is a simple way to describe patch isolation. Because it is
scaled to the mean, it is easily comparable among different landscapes.
</p>
<p>Because the metric is based on distances or areas please make sure your data
is valid using <code><a href="#topic+check_landscape">check_landscape</a></code>.
</p>


<h4>Units</h4>

<p>Meters</p>



<h4>Range</h4>

<p>ENN_CV &gt;= 0</p>



<h4>Behaviour</h4>

<p>Equals ENN_CV = 0 if the euclidean nearest-neighbor distance is
identical for all patches. Increases, without limit, as the variation of ENN increases.</p>



<h3>Value</h3>

<p>tibble
</p>


<h3>References</h3>

<p>McGarigal K., SA Cushman, and E Ene. 2023. FRAGSTATS v4: Spatial Pattern Analysis
Program for Categorical Maps. Computer software program produced by the authors;
available at the following web site: https://www.fragstats.org
</p>
<p>McGarigal, K., and McComb, W. C. (1995). Relationships between landscape
structure and breeding birds in the Oregon Coast Range.
Ecological monographs, 65(3), 235-260.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lsm_p_enn">lsm_p_enn</a></code>, <br />
<code><a href="#topic+lsm_c_enn_mn">lsm_c_enn_mn</a></code>,
<code><a href="#topic+lsm_c_enn_sd">lsm_c_enn_sd</a></code>,
<code><a href="#topic+lsm_c_enn_cv">lsm_c_enn_cv</a></code>, <br />
<code><a href="#topic+lsm_l_enn_mn">lsm_l_enn_mn</a></code>,
<code><a href="#topic+lsm_l_enn_sd">lsm_l_enn_sd</a></code>,
</p>


<h3>Examples</h3>

<pre><code class='language-R'>landscape &lt;- terra::rast(landscapemetrics::landscape)
lsm_l_enn_cv(landscape)

</code></pre>

<hr>
<h2 id='lsm_l_enn_mn'>ENN_MN (landscape level)</h2><span id='topic+lsm_l_enn_mn'></span>

<h3>Description</h3>

<p>Mean of euclidean nearest-neighbor distance (Aggregation metric)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lsm_l_enn_mn(landscape, directions = 8, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lsm_l_enn_mn_+3A_landscape">landscape</code></td>
<td>
<p>A categorical raster object: SpatRaster; Raster* Layer, Stack, Brick; stars or a list of SpatRasters.</p>
</td></tr>
<tr><td><code id="lsm_l_enn_mn_+3A_directions">directions</code></td>
<td>
<p>The number of directions in which patches should be connected: 4 (rook's case) or 8 (queen's case).</p>
</td></tr>
<tr><td><code id="lsm_l_enn_mn_+3A_verbose">verbose</code></td>
<td>
<p>Print warning message if not sufficient patches are present</p>
</td></tr>
</table>


<h3>Details</h3>

<p style="text-align: center;"><code class="reqn">ENN_{MN} = cv(mean[patch_{ij}])</code>
</p>

<p>where <code class="reqn">ENN[patch_{ij}]</code> is the euclidean nearest-neighbor distance
of each patch.
</p>
<p>ENN_CV is an 'Aggregation metric'. It summarises the landscape as the mean of all patches
in the landscape. ENN measures the distance to the  nearest neighbouring patch
of the same class i. The distance is measured from edge-to-edge. The range is limited
by the cell resolution on the lower limit and the landscape extent on the upper limit.
</p>
<p>Because the metric is based on distances or areas please make sure your data
is valid using <code><a href="#topic+check_landscape">check_landscape</a></code>.
</p>


<h4>Units</h4>

<p>Meters</p>



<h4>Range</h4>

<p>ENN_MN &gt; 0</p>



<h4>Behaviour</h4>

<p>Approaches ENN_MN = 0 as the distance to the nearest neighbour
decreases, i.e. patches of the same class i are more aggregated. Increases, without limit,
as the distance between neighbouring patches of the same class i increases, i.e. patches are
more isolated.</p>



<h3>Value</h3>

<p>tibble
</p>


<h3>References</h3>

<p>McGarigal K., SA Cushman, and E Ene. 2023. FRAGSTATS v4: Spatial Pattern Analysis
Program for Categorical Maps. Computer software program produced by the authors;
available at the following web site: https://www.fragstats.org
</p>
<p>McGarigal, K., and McComb, W. C. (1995). Relationships between landscape
structure and breeding birds in the Oregon Coast Range.
Ecological monographs, 65(3), 235-260.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lsm_p_enn">lsm_p_enn</a></code>,
<code><a href="base.html#topic+mean">mean</a></code>, <br />
<code><a href="#topic+lsm_c_enn_mn">lsm_c_enn_mn</a></code>,
<code><a href="#topic+lsm_c_enn_sd">lsm_c_enn_sd</a></code>,
<code><a href="#topic+lsm_c_enn_cv">lsm_c_enn_cv</a></code>, <br />
<code><a href="#topic+lsm_l_enn_sd">lsm_l_enn_sd</a></code>,
<code><a href="#topic+lsm_l_enn_cv">lsm_l_enn_cv</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>landscape &lt;- terra::rast(landscapemetrics::landscape)
lsm_l_enn_mn(landscape)

</code></pre>

<hr>
<h2 id='lsm_l_enn_sd'>ENN_SD (landscape level)</h2><span id='topic+lsm_l_enn_sd'></span>

<h3>Description</h3>

<p>Standard deviation of euclidean nearest-neighbor distance (Aggregation metric)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lsm_l_enn_sd(landscape, directions = 8, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lsm_l_enn_sd_+3A_landscape">landscape</code></td>
<td>
<p>A categorical raster object: SpatRaster; Raster* Layer, Stack, Brick; stars or a list of SpatRasters.</p>
</td></tr>
<tr><td><code id="lsm_l_enn_sd_+3A_directions">directions</code></td>
<td>
<p>The number of directions in which patches should be connected: 4 (rook's case) or 8 (queen's case).</p>
</td></tr>
<tr><td><code id="lsm_l_enn_sd_+3A_verbose">verbose</code></td>
<td>
<p>Print warning message if not sufficient patches are present</p>
</td></tr>
</table>


<h3>Details</h3>

<p style="text-align: center;"><code class="reqn">ENN_{SD} = sd(ENN[patch_{ij}])</code>
</p>

<p>where <code class="reqn">ENN[patch_{ij}]</code> is the euclidean nearest-neighbor distance
of each patch.
</p>
<p>ENN_CV is an 'Aggregation metric'. It summarises in the landscape as the standard
deviation of all patches in the landscape. ENN measures the distance to the  nearest
neighbouring patch of the same class i. The distance is measured from edge-to-edge.
The range is limited by the cell resolution on the lower limit and the landscape extent
on the upper limit. The metric is a simple way to describe patch isolation. Because it is
scaled to the mean, it is easily comparable among different landscapes.
</p>
<p>Because the metric is based on distances or areas please make sure your data
is valid using <code><a href="#topic+check_landscape">check_landscape</a></code>.
</p>


<h4>Units</h4>

<p>Meters</p>



<h4>Range</h4>

<p>ENN_SD &gt;= 0</p>



<h4>Behaviour</h4>

<p>Equals ENN_SD = 0 if the euclidean nearest-neighbor distance is
identical for all patches. Increases, without limit, as the variation of ENN increases.</p>



<h3>Value</h3>

<p>tibble
</p>


<h3>References</h3>

<p>McGarigal K., SA Cushman, and E Ene. 2023. FRAGSTATS v4: Spatial Pattern Analysis
Program for Categorical Maps. Computer software program produced by the authors;
available at the following web site: https://www.fragstats.org
</p>
<p>McGarigal, K., and McComb, W. C. (1995). Relationships between landscape
structure and breeding birds in the Oregon Coast Range.
Ecological monographs, 65(3), 235-260.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lsm_p_enn">lsm_p_enn</a></code>,
<code><a href="stats.html#topic+sd">sd</a></code> <br />
<code><a href="#topic+lsm_c_enn_mn">lsm_c_enn_mn</a></code>,
<code><a href="#topic+lsm_c_enn_sd">lsm_c_enn_sd</a></code>,
<code><a href="#topic+lsm_c_enn_cv">lsm_c_enn_cv</a></code>, <br />
<code><a href="#topic+lsm_l_enn_mn">lsm_l_enn_mn</a></code>,
<code><a href="#topic+lsm_l_enn_cv">lsm_l_enn_cv</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>landscape &lt;- terra::rast(landscapemetrics::landscape)
lsm_l_enn_sd(landscape)

</code></pre>

<hr>
<h2 id='lsm_l_ent'>ENT (landscape level)</h2><span id='topic+lsm_l_ent'></span>

<h3>Description</h3>

<p>Marginal entropy \[H(x)\]
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lsm_l_ent(landscape, neighbourhood = 4, base = "log2")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lsm_l_ent_+3A_landscape">landscape</code></td>
<td>
<p>A categorical raster object: SpatRaster; Raster* Layer, Stack, Brick; stars or a list of SpatRasters.</p>
</td></tr>
<tr><td><code id="lsm_l_ent_+3A_neighbourhood">neighbourhood</code></td>
<td>
<p>The number of directions in which cell adjacencies are considered as neighbours:
4 (rook's case) or 8 (queen's case). The default is 4.</p>
</td></tr>
<tr><td><code id="lsm_l_ent_+3A_base">base</code></td>
<td>
<p>The unit in which entropy is measured.
The default is &quot;log2&quot;, which compute entropy in &quot;bits&quot;.
&quot;log&quot; and &quot;log10&quot; can be also used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It measures a diversity (thematic complexity) of landscape classes.
</p>


<h3>Value</h3>

<p>tibble
</p>


<h3>References</h3>

<p>Nowosad J., TF Stepinski. 2019. Information theory as a consistent framework
for quantification and classification of landscape patterns. https://doi.org/10.1007/s10980-019-00830-x
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lsm_l_condent">lsm_l_condent</a></code>,
<code><a href="#topic+lsm_l_mutinf">lsm_l_mutinf</a></code>,
<code><a href="#topic+lsm_l_joinent">lsm_l_joinent</a></code>,
<code><a href="#topic+lsm_l_relmutinf">lsm_l_relmutinf</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>landscape &lt;- terra::rast(landscapemetrics::landscape)
lsm_l_ent(landscape)

</code></pre>

<hr>
<h2 id='lsm_l_frac_cv'>FRAC_CV (landscape level)</h2><span id='topic+lsm_l_frac_cv'></span>

<h3>Description</h3>

<p>Coefficient of variation fractal dimension index (Shape metric)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lsm_l_frac_cv(landscape, directions = 8)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lsm_l_frac_cv_+3A_landscape">landscape</code></td>
<td>
<p>A categorical raster object: SpatRaster; Raster* Layer, Stack, Brick; stars or a list of SpatRasters.</p>
</td></tr>
<tr><td><code id="lsm_l_frac_cv_+3A_directions">directions</code></td>
<td>
<p>The number of directions in which patches should be
connected: 4 (rook's case) or 8 (queen's case).</p>
</td></tr>
</table>


<h3>Details</h3>

<p style="text-align: center;"><code class="reqn">FRAC_{CV} = cv(FRAC[patch_{ij}])</code>
</p>

<p>where <code class="reqn">FRAC[patch_{ij}]</code> equals the fractal dimension index of each patch.
</p>
<p>FRAC_CV is a 'Shape metric'. The metric summarises the landscape
as the Coefficient of variation of the fractal dimension index of all patches
in the landscape. The fractal dimension index is based on the patch perimeter and
the patch area and describes the patch complexity. The Coefficient of variation is
scaled to the mean and comparable among different landscapes.
</p>
<p>Because the metric is based on distances or areas please make sure your data
is valid using <code><a href="#topic+check_landscape">check_landscape</a></code>.
</p>


<h4>Units</h4>

<p>None</p>



<h4>Range</h4>

<p>FRAC_CV &gt;= 0 </p>



<h4>Behaviour</h4>

<p>Equals FRAC_CV = 0 if the fractal dimension index is identical
for all patches. Increases, without limit, as the variation of the fractal dimension
indices increases.</p>



<h3>Value</h3>

<p>tibble
</p>


<h3>References</h3>

<p>McGarigal K., SA Cushman, and E Ene. 2023. FRAGSTATS v4: Spatial Pattern Analysis
Program for Categorical Maps. Computer software program produced by the authors;
available at the following web site: https://www.fragstats.org
</p>
<p>Mandelbrot, B. B. 1977. Fractals: Form, Chance, and Dimension.
San Francisco. W. H. Freeman and Company.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lsm_p_frac">lsm_p_frac</a></code>, <br />
<code><a href="#topic+lsm_c_frac_mn">lsm_c_frac_mn</a></code>,
<code><a href="#topic+lsm_c_frac_sd">lsm_c_frac_sd</a></code>,
<code><a href="#topic+lsm_c_frac_cv">lsm_c_frac_cv</a></code>, <br />
<code><a href="#topic+lsm_l_frac_mn">lsm_l_frac_mn</a></code>,
<code><a href="#topic+lsm_l_frac_sd">lsm_l_frac_sd</a></code>,
</p>


<h3>Examples</h3>

<pre><code class='language-R'>landscape &lt;- terra::rast(landscapemetrics::landscape)
lsm_l_frac_cv(landscape)

</code></pre>

<hr>
<h2 id='lsm_l_frac_mn'>FRAC_MN (landscape level)</h2><span id='topic+lsm_l_frac_mn'></span>

<h3>Description</h3>

<p>Mean fractal dimension index (Shape metric)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lsm_l_frac_mn(landscape, directions = 8)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lsm_l_frac_mn_+3A_landscape">landscape</code></td>
<td>
<p>A categorical raster object: SpatRaster; Raster* Layer, Stack, Brick; stars or a list of SpatRasters.</p>
</td></tr>
<tr><td><code id="lsm_l_frac_mn_+3A_directions">directions</code></td>
<td>
<p>The number of directions in which patches should be
connected: 4 (rook's case) or 8 (queen's case).</p>
</td></tr>
</table>


<h3>Details</h3>

<p style="text-align: center;"><code class="reqn">FRAC_{MN} = mean(FRAC[patch_{ij}])</code>
</p>

<p>where <code class="reqn">FRAC[patch_{ij}]</code> equals the fractal dimension index of each patch.
</p>
<p>FRAC_MN is a 'Shape metric'. The metric summarises the landscape
as the mean of the fractal dimension index of all patches in the landscape.
The fractal dimension index is based on the patch perimeter and
the patch area and describes the patch complexity. The Coefficient of variation is
scaled to the mean and comparable among different landscapes.
</p>
<p>Because the metric is based on distances or areas please make sure your data
is valid using <code><a href="#topic+check_landscape">check_landscape</a></code>.
</p>


<h4>Units</h4>

<p>None</p>



<h4>Range</h4>

<p>FRAC_MN &gt; 0 </p>



<h4>Behaviour</h4>

<p>Approaches FRAC_MN = 1 if all patches are squared and FRAC_MN = 2
if all patches are irregular.</p>



<h3>Value</h3>

<p>tibble
</p>


<h3>References</h3>

<p>McGarigal K., SA Cushman, and E Ene. 2023. FRAGSTATS v4: Spatial Pattern Analysis
Program for Categorical Maps. Computer software program produced by the authors;
available at the following web site: https://www.fragstats.org
</p>
<p>Mandelbrot, B. B. 1977. Fractals: Form, Chance, and Dimension.
San Francisco. W. H. Freeman and Company.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lsm_p_frac">lsm_p_frac</a></code>,
<code><a href="base.html#topic+mean">mean</a></code>, <br />
<code><a href="#topic+lsm_c_frac_mn">lsm_c_frac_mn</a></code>,
<code><a href="#topic+lsm_c_frac_sd">lsm_c_frac_sd</a></code>,
<code><a href="#topic+lsm_c_frac_cv">lsm_c_frac_cv</a></code>, <br />
<code><a href="#topic+lsm_l_frac_sd">lsm_l_frac_sd</a></code>,
<code><a href="#topic+lsm_l_frac_cv">lsm_l_frac_cv</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>landscape &lt;- terra::rast(landscapemetrics::landscape)
lsm_l_frac_mn(landscape)

</code></pre>

<hr>
<h2 id='lsm_l_frac_sd'>FRAC_SD (landscape level)</h2><span id='topic+lsm_l_frac_sd'></span>

<h3>Description</h3>

<p>Standard deviation fractal dimension index (Shape metric)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lsm_l_frac_sd(landscape, directions = 8)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lsm_l_frac_sd_+3A_landscape">landscape</code></td>
<td>
<p>A categorical raster object: SpatRaster; Raster* Layer, Stack, Brick; stars or a list of SpatRasters.</p>
</td></tr>
<tr><td><code id="lsm_l_frac_sd_+3A_directions">directions</code></td>
<td>
<p>The number of directions in which patches should be
connected: 4 (rook's case) or 8 (queen's case).</p>
</td></tr>
</table>


<h3>Details</h3>

<p style="text-align: center;"><code class="reqn">FRAC_{SD} = sd(FRAC[patch_{ij}])</code>
</p>

<p>where <code class="reqn">FRAC[patch_{ij}]</code> equals the fractal dimension index of each patch.
</p>
<p>FRAC_SD is a 'Shape metric'. The metric summarises the landscape
as the standard deviation of the fractal dimension index of all patches
in the landscape. The fractal dimension index is based on the patch perimeter and
the patch area and describes the patch complexity.
</p>
<p>Because the metric is based on distances or areas please make sure your data
is valid using <code><a href="#topic+check_landscape">check_landscape</a></code>.
</p>


<h4>Units</h4>

<p>None</p>



<h4>Range</h4>

<p>FRAC_SD&gt;= 0 </p>



<h4>Behaviour</h4>

<p>Equals FRAC_SD = 0 if the fractal dimension index is identical
for all patches. Increases, without limit, as the variation of the fractal dimension
indices increases.</p>



<h3>Value</h3>

<p>tibble
</p>


<h3>References</h3>

<p>McGarigal K., SA Cushman, and E Ene. 2023. FRAGSTATS v4: Spatial Pattern Analysis
Program for Categorical Maps. Computer software program produced by the authors;
available at the following web site: https://www.fragstats.org
</p>
<p>Mandelbrot, B. B. 1977. Fractals: Form, Chance, and Dimension.
San Francisco. W. H. Freeman and Company.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lsm_p_frac">lsm_p_frac</a></code>,
<code><a href="stats.html#topic+sd">sd</a></code> <br />
<code><a href="#topic+lsm_c_frac_mn">lsm_c_frac_mn</a></code>,
<code><a href="#topic+lsm_c_frac_sd">lsm_c_frac_sd</a></code>,
<code><a href="#topic+lsm_c_frac_cv">lsm_c_frac_cv</a></code>, <br />
<code><a href="#topic+lsm_l_frac_mn">lsm_l_frac_mn</a></code>,
<code><a href="#topic+lsm_l_frac_cv">lsm_l_frac_cv</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>landscape &lt;- terra::rast(landscapemetrics::landscape)
lsm_l_frac_sd(landscape)

</code></pre>

<hr>
<h2 id='lsm_l_gyrate_cv'>GYRATE_CV (landscape level)</h2><span id='topic+lsm_l_gyrate_cv'></span>

<h3>Description</h3>

<p>Coefficient of variation radius of gyration (Area and edge metric)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lsm_l_gyrate_cv(landscape, directions = 8, cell_center = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lsm_l_gyrate_cv_+3A_landscape">landscape</code></td>
<td>
<p>A categorical raster object: SpatRaster; Raster* Layer, Stack, Brick; stars or a list of SpatRasters.</p>
</td></tr>
<tr><td><code id="lsm_l_gyrate_cv_+3A_directions">directions</code></td>
<td>
<p>The number of directions in which patches should be
connected: 4 (rook's case) or 8 (queen's case).</p>
</td></tr>
<tr><td><code id="lsm_l_gyrate_cv_+3A_cell_center">cell_center</code></td>
<td>
<p>If true, the coordinates of the centroid are forced to be
a cell center within the patch.</p>
</td></tr>
</table>


<h3>Details</h3>

<p style="text-align: center;"><code class="reqn">GYRATE_{CV} = cv(GYRATE[patch_{ij}])</code>
</p>

<p>where <code class="reqn">GYRATE[patch_{ij}]</code> equals the radius of gyration of each patch.
</p>
<p>GYRATE_CV is an 'Area and edge metric'. The metric summarises the landscape
as the Coefficient of variation of the radius of gyration of all patches
in the landscape. GYRATE measures the distance from each cell to the patch
centroid and is based on cell center-to-cell center distances. The metrics characterises
both the patch area and compactness. The Coefficient of variation is
scaled to the mean and comparable among different landscapes.
</p>
<p>If <code>cell_center = TRUE</code> some patches might have several possible cell-center
centroids. In this case, the gyrate index is based on the mean distance of all
cells to all possible cell-center centroids.
</p>
<p>Because the metric is based on distances or areas please make sure your data
is valid using <code><a href="#topic+check_landscape">check_landscape</a></code>.
</p>


<h4>Units</h4>

<p>Meters</p>



<h4>Range</h4>

<p>GYRATE_CV &gt;= 0 </p>



<h4>Behaviour</h4>

<p>Equals GYRATE_CV = 0 if the radius of gyration is identical
for all patches. Increases, without limit, as the variation of the radius of gyration
increases.</p>



<h3>Value</h3>

<p>tibble
</p>


<h3>References</h3>

<p>McGarigal K., SA Cushman, and E Ene. 2023. FRAGSTATS v4: Spatial Pattern Analysis
Program for Categorical Maps. Computer software program produced by the authors;
available at the following web site: https://www.fragstats.org
</p>
<p>Keitt, T. H., Urban, D. L., &amp; Milne, B. T. 1997. Detecting critical scales
in fragmented landscapes. Conservation ecology, 1(1).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lsm_p_gyrate">lsm_p_gyrate</a></code>, <br />
<code><a href="#topic+lsm_c_gyrate_mn">lsm_c_gyrate_mn</a></code>,
<code><a href="#topic+lsm_c_gyrate_sd">lsm_c_gyrate_sd</a></code>,
<code><a href="#topic+lsm_c_gyrate_cv">lsm_c_gyrate_cv</a></code>, <br />
<code><a href="#topic+lsm_l_gyrate_mn">lsm_l_gyrate_mn</a></code>,
<code><a href="#topic+lsm_l_gyrate_sd">lsm_l_gyrate_sd</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>landscape &lt;- terra::rast(landscapemetrics::landscape)
lsm_l_gyrate_cv(landscape)

</code></pre>

<hr>
<h2 id='lsm_l_gyrate_mn'>GYRATE_MN (landscape level)</h2><span id='topic+lsm_l_gyrate_mn'></span>

<h3>Description</h3>

<p>Mean radius of gyration (Area and edge metric)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lsm_l_gyrate_mn(landscape, directions = 8, cell_center = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lsm_l_gyrate_mn_+3A_landscape">landscape</code></td>
<td>
<p>A categorical raster object: SpatRaster; Raster* Layer, Stack, Brick; stars or a list of SpatRasters.</p>
</td></tr>
<tr><td><code id="lsm_l_gyrate_mn_+3A_directions">directions</code></td>
<td>
<p>The number of directions in which patches should be
connected: 4 (rook's case) or 8 (queen's case).</p>
</td></tr>
<tr><td><code id="lsm_l_gyrate_mn_+3A_cell_center">cell_center</code></td>
<td>
<p>If true, the coordinates of the centroid are forced to be
a cell center within the patch.</p>
</td></tr>
</table>


<h3>Details</h3>

<p style="text-align: center;"><code class="reqn">GYRATE_{MN} = mean(GYRATE[patch_{ij}])</code>
</p>

<p>where <code class="reqn">GYRATE[patch_{ij}]</code> equals the radius of gyration of each patch.
</p>
<p>GYRATE_MN is an 'Area and edge metric'. The metric summarises the landscape
as the mean of the radius of gyration of all patches in the landscape.
GYRATE measures the distance from each cell to the patch centroid and is based on
cell center-to-cell center distances. The metrics characterises
both the patch area and compactness.
</p>
<p>If <code>cell_center = TRUE</code> some patches might have several possible cell-center
centroids. In this case, the gyrate index is based on the mean distance of all
cells to all possible cell-center centroids.
</p>
<p>Because the metric is based on distances or areas please make sure your data
is valid using <code><a href="#topic+check_landscape">check_landscape</a></code>.
</p>


<h4>Units</h4>

<p>Meters</p>



<h4>Range</h4>

<p>GYRATE_MN &gt;= 0 </p>



<h4>Behaviour</h4>

<p>Approaches GYRATE_MN = 0 if every patch is a single cell. Increases,
without limit, when only one patch is present.</p>



<h3>Value</h3>

<p>tibble
</p>


<h3>References</h3>

<p>McGarigal K., SA Cushman, and E Ene. 2023. FRAGSTATS v4: Spatial Pattern Analysis
Program for Categorical Maps. Computer software program produced by the authors;
available at the following web site: https://www.fragstats.org
</p>
<p>Keitt, T. H., Urban, D. L., &amp; Milne, B. T. 1997. Detecting critical scales
in fragmented landscapes. Conservation ecology, 1(1).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lsm_p_gyrate">lsm_p_gyrate</a></code>,
<code><a href="base.html#topic+mean">mean</a></code>, <br />
<code><a href="#topic+lsm_c_gyrate_mn">lsm_c_gyrate_mn</a></code>,
<code><a href="#topic+lsm_c_gyrate_sd">lsm_c_gyrate_sd</a></code>,
<code><a href="#topic+lsm_c_gyrate_cv">lsm_c_gyrate_cv</a></code>, <br />
<code><a href="#topic+lsm_l_gyrate_sd">lsm_l_gyrate_sd</a></code>,
<code><a href="#topic+lsm_l_gyrate_cv">lsm_l_gyrate_cv</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>landscape &lt;- terra::rast(landscapemetrics::landscape)
lsm_l_gyrate_mn(landscape)

</code></pre>

<hr>
<h2 id='lsm_l_gyrate_sd'>GYRATE_SD (landscape level)</h2><span id='topic+lsm_l_gyrate_sd'></span>

<h3>Description</h3>

<p>Standard deviation radius of gyration (Area and edge metric)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lsm_l_gyrate_sd(landscape, directions = 8, cell_center = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lsm_l_gyrate_sd_+3A_landscape">landscape</code></td>
<td>
<p>A categorical raster object: SpatRaster; Raster* Layer, Stack, Brick; stars or a list of SpatRasters.</p>
</td></tr>
<tr><td><code id="lsm_l_gyrate_sd_+3A_directions">directions</code></td>
<td>
<p>The number of directions in which patches should be
connected: 4 (rook's case) or 8 (queen's case).</p>
</td></tr>
<tr><td><code id="lsm_l_gyrate_sd_+3A_cell_center">cell_center</code></td>
<td>
<p>If true, the coordinates of the centroid are forced to be
a cell center within the patch.</p>
</td></tr>
</table>


<h3>Details</h3>

<p style="text-align: center;"><code class="reqn">GYRATE_{SD} = sd(GYRATE[patch_{ij}])</code>
</p>

<p>where <code class="reqn">GYRATE[patch_{ij}]</code> equals the radius of gyration of each patch.
</p>
<p>GYRATE_SD is an 'Area and edge metric'. The metric summarises the landscape
as the standard deviation of the radius of gyration of all patches
in the landscape. GYRATE measures the distance from each cell to the patch
centroid and is based on cell center-to-cell center distances. The metrics characterises
both the patch area and compactness.
</p>
<p>If <code>cell_center = TRUE</code> some patches might have several possible cell-center
centroids. In this case, the gyrate index is based on the mean distance of all
cells to all possible cell-center centroids.
</p>
<p>Because the metric is based on distances or areas please make sure your data
is valid using <code><a href="#topic+check_landscape">check_landscape</a></code>.
</p>


<h4>Units</h4>

<p>Meters</p>



<h4>Range</h4>

<p>GYRATE_SD &gt;= 0 </p>



<h4>Behaviour</h4>

<p>Equals GYRATE_SD = 0 if the radius of gyration is identical
for all patches. Increases, without limit, as the variation of the radius of gyration
increases.</p>



<h3>Value</h3>

<p>tibble
</p>


<h3>References</h3>

<p>McGarigal K., SA Cushman, and E Ene. 2023. FRAGSTATS v4: Spatial Pattern Analysis
Program for Categorical Maps. Computer software program produced by the authors;
available at the following web site: https://www.fragstats.org
</p>
<p>Keitt, T. H., Urban, D. L., &amp; Milne, B. T. 1997. Detecting critical scales
in fragmented landscapes. Conservation ecology, 1(1).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lsm_p_gyrate">lsm_p_gyrate</a></code>, <br />
<code><a href="#topic+lsm_c_gyrate_mn">lsm_c_gyrate_mn</a></code>,
<code><a href="#topic+lsm_c_gyrate_sd">lsm_c_gyrate_sd</a></code>,
<code><a href="#topic+lsm_c_gyrate_cv">lsm_c_gyrate_cv</a></code>, <br />
<code><a href="#topic+lsm_l_gyrate_mn">lsm_l_gyrate_mn</a></code>,
<code><a href="#topic+lsm_l_gyrate_cv">lsm_l_gyrate_cv</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>landscape &lt;- terra::rast(landscapemetrics::landscape)
lsm_l_gyrate_sd(landscape)

</code></pre>

<hr>
<h2 id='lsm_l_iji'>Interspersion and Juxtaposition index (landscape level)</h2><span id='topic+lsm_l_iji'></span>

<h3>Description</h3>

<p>Interspersion and Juxtaposition index (Aggregation metric)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lsm_l_iji(landscape, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lsm_l_iji_+3A_landscape">landscape</code></td>
<td>
<p>A categorical raster object: SpatRaster; Raster* Layer, Stack, Brick; stars or a list of SpatRasters.</p>
</td></tr>
<tr><td><code id="lsm_l_iji_+3A_verbose">verbose</code></td>
<td>
<p>Print warning message if not sufficient patches are present</p>
</td></tr>
</table>


<h3>Details</h3>

<p style="text-align: center;"><code class="reqn">IJI = \frac{- \sum \limits_{i = 1}^{m} \sum \limits_{k = i + 1}^{m} \Bigg[ \Bigg( \frac{e_{ik}}{E} \Bigg) ln \Bigg( \frac{e_{ik}}{E} \Bigg) \Bigg]}{ln(0.5[m(m - 1)])}  * 100</code>
</p>

<p>where <code class="reqn">e_{ik}</code> are the unique adjacencies of all classes (lower/upper triangle of
the adjacency table - without the diagonal), <code class="reqn">E</code> is the total length of edges in the landscape
and <code class="reqn">m</code> is the number of classes.
</p>
<p>IJI is an 'Aggregation metric'. It is a so called &quot;salt and pepper&quot; metric and
describes the intermixing of classes (i.e. without considering like adjacencies - the
diagonal of the adjacency table). The number of classes to calculate IJI must be &gt;= than 3.
</p>


<h4>Units</h4>

<p>Percent</p>



<h4>Range</h4>

<p>0 &lt; IJI &lt;= 100</p>



<h4>Behaviour</h4>

<p>Approaches 0 if a class is only adjacent to a single other class
and equals 100 when a class is equally adjacent to all other classes.</p>



<h3>Value</h3>

<p>tibble
</p>


<h3>References</h3>

<p>McGarigal K., SA Cushman, and E Ene. 2023. FRAGSTATS v4: Spatial Pattern Analysis
Program for Categorical Maps. Computer software program produced by the authors;
available at the following web site: https://www.fragstats.org
</p>
<p>McGarigal, K., &amp; Marks, B. J. 1995. FRAGSTATS: spatial pattern analysis
program for quantifying landscape structure. Gen. Tech. Rep. PNW-GTR-351.
Portland, OR: US Department of Agriculture, Forest Service, Pacific Northwest
Research Station. 122 p, 351.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lsm_c_iji">lsm_c_iji</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>landscape &lt;- terra::rast(landscapemetrics::landscape)
lsm_l_iji(landscape)

</code></pre>

<hr>
<h2 id='lsm_l_joinent'>JOINENT (landscape level)</h2><span id='topic+lsm_l_joinent'></span>

<h3>Description</h3>

<p>Joint entropy \[H(x, y)\]
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lsm_l_joinent(landscape, neighbourhood = 4, ordered = TRUE, base = "log2")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lsm_l_joinent_+3A_landscape">landscape</code></td>
<td>
<p>A categorical raster object: SpatRaster; Raster* Layer, Stack, Brick; stars or a list of SpatRasters.</p>
</td></tr>
<tr><td><code id="lsm_l_joinent_+3A_neighbourhood">neighbourhood</code></td>
<td>
<p>The number of directions in which cell adjacencies are considered as neighbours:
4 (rook's case) or 8 (queen's case). The default is 4.</p>
</td></tr>
<tr><td><code id="lsm_l_joinent_+3A_ordered">ordered</code></td>
<td>
<p>The type of pairs considered.
Either ordered (TRUE) or unordered (FALSE).
The default is TRUE.</p>
</td></tr>
<tr><td><code id="lsm_l_joinent_+3A_base">base</code></td>
<td>
<p>The unit in which entropy is measured.
The default is &quot;log2&quot;, which compute entropy in &quot;bits&quot;.
&quot;log&quot; and &quot;log10&quot; can be also used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Complexity of a landscape pattern. An overall spatio-thematic complexity metric.
</p>


<h3>Value</h3>

<p>tibble
</p>


<h3>References</h3>

<p>Nowosad J., TF Stepinski. 2019. Information theory as a consistent framework
for quantification and classification of landscape patterns. https://doi.org/10.1007/s10980-019-00830-x
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lsm_l_ent">lsm_l_ent</a></code>,
<code><a href="#topic+lsm_l_condent">lsm_l_condent</a></code>,
<code><a href="#topic+lsm_l_mutinf">lsm_l_mutinf</a></code>,
<code><a href="#topic+lsm_l_relmutinf">lsm_l_relmutinf</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>landscape &lt;- terra::rast(landscapemetrics::landscape)
lsm_l_joinent(landscape)

</code></pre>

<hr>
<h2 id='lsm_l_lpi'>LPI (landscape level)</h2><span id='topic+lsm_l_lpi'></span>

<h3>Description</h3>

<p>Largest patch index (Area and Edge metric)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lsm_l_lpi(landscape, directions = 8)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lsm_l_lpi_+3A_landscape">landscape</code></td>
<td>
<p>A categorical raster object: SpatRaster; Raster* Layer, Stack, Brick; stars or a list of SpatRasters.</p>
</td></tr>
<tr><td><code id="lsm_l_lpi_+3A_directions">directions</code></td>
<td>
<p>The number of directions in which patches should be
connected: 4 (rook's case) or 8 (queen's case).</p>
</td></tr>
</table>


<h3>Details</h3>

<p style="text-align: center;"><code class="reqn">LPI = \frac{\max (a_{ij})} {A} * 100</code>
</p>

<p>where <code class="reqn">max(a_{ij})</code> is the area of the patch in square meters and <code class="reqn">A</code>
is the total landscape area in square meters.
</p>
<p>The largest patch index is an 'Area and edge metric'. It is the percentage of the
landscape covered by the largest patch in the landscape. It is a simple
measure of dominance.
</p>
<p>Because the metric is based on distances or areas please make sure your data
is valid using <code><a href="#topic+check_landscape">check_landscape</a></code>.
</p>


<h4>Units</h4>

<p>Percentage</p>



<h4>Range</h4>

<p>0 &lt; LPI &lt;= 100</p>



<h4>Behaviour</h4>

<p>Approaches LPI = 0 when the largest patch is becoming small
and equals LPI = 100 when only one patch is present</p>



<h3>Value</h3>

<p>tibble
</p>


<h3>References</h3>

<p>McGarigal K., SA Cushman, and E Ene. 2023. FRAGSTATS v4: Spatial Pattern Analysis
Program for Categorical Maps. Computer software program produced by the authors;
available at the following web site: https://www.fragstats.org
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lsm_p_area">lsm_p_area</a></code>,
<code><a href="#topic+lsm_l_ta">lsm_l_ta</a></code>, <br />
<code><a href="#topic+lsm_c_lpi">lsm_c_lpi</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>landscape &lt;- terra::rast(landscapemetrics::landscape)
lsm_l_lpi(landscape)

</code></pre>

<hr>
<h2 id='lsm_l_lsi'>LSI (landscape level)</h2><span id='topic+lsm_l_lsi'></span>

<h3>Description</h3>

<p>Landscape shape index (Aggregation metric)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lsm_l_lsi(landscape)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lsm_l_lsi_+3A_landscape">landscape</code></td>
<td>
<p>A categorical raster object: SpatRaster; Raster* Layer, Stack, Brick; stars or a list of SpatRasters.</p>
</td></tr>
</table>


<h3>Details</h3>

<p style="text-align: center;"><code class="reqn">LSI = \frac{E} {\min E}</code>
</p>

<p>where <code class="reqn">E</code> is the total edge length in cell surfaces and <code class="reqn">\min E</code>
is the minimum total edge length in cell surfaces.
</p>
<p>LSI is an 'Aggregation metric'. It is the ratio between the actual landscape edge length
and the hypothetical minimum edge length. The minimum edge length equals
the edge length if only one patch would be present.
</p>
<p>Because the metric is based on distances or areas please make sure your data
is valid using <code><a href="#topic+check_landscape">check_landscape</a></code>.
</p>


<h4>Units</h4>

<p>None</p>



<h4>Ranges</h4>

<p>LSI &gt;= 1</p>



<h4>Behaviour</h4>

<p>Equals LSI = 1 when only one squared patch is present.
Increases, without limit, as the length of the actual edges increases, i.e.
the patches become less compact.</p>



<h3>Value</h3>

<p>tibble
</p>


<h3>References</h3>

<p>McGarigal K., SA Cushman, and E Ene. 2023. FRAGSTATS v4: Spatial Pattern Analysis
Program for Categorical Maps. Computer software program produced by the authors;
available at the following web site: https://www.fragstats.org
</p>
<p>Patton, D. R. 1975. A diversity index for quantifying habitat &quot;edge&quot;.
Wildl. Soc.Bull. 3:171-173.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lsm_p_shape">lsm_p_shape</a></code>, <br />
<code><a href="#topic+lsm_c_lsi">lsm_c_lsi</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>landscape &lt;- terra::rast(landscapemetrics::landscape)
lsm_l_lsi(landscape)

</code></pre>

<hr>
<h2 id='lsm_l_mesh'>MESH (landscape level)</h2><span id='topic+lsm_l_mesh'></span>

<h3>Description</h3>

<p>Effective Mesh Size (Aggregation metric)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lsm_l_mesh(landscape, directions = 8)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lsm_l_mesh_+3A_landscape">landscape</code></td>
<td>
<p>A categorical raster object: SpatRaster; Raster* Layer, Stack, Brick; stars or a list of SpatRasters.</p>
</td></tr>
<tr><td><code id="lsm_l_mesh_+3A_directions">directions</code></td>
<td>
<p>The number of directions in which patches should be
connected: 4 (rook's case) or 8 (queen's case).</p>
</td></tr>
</table>


<h3>Details</h3>

<p style="text-align: center;"><code class="reqn">MESH = \frac{\sum \limits_{i = 1}^{m} \sum \limits_{j = 1}^{n} a_{ij} ^ 2}{A} * \frac{1} {10000}</code>
</p>

<p>where <code class="reqn">a_{ij}</code> is the patch area in square meters and <code class="reqn">A</code> is the
total landscape area in square meters.
</p>
<p>The effective mesh size is an 'Aggregation metric'. Because each patch is squared
before the sum is calculated and the sum is standardized by the
total landscape area, MESH is a relative measure of patch structure. MESH is
perfectly, negatively correlated to <code><a href="#topic+lsm_l_division">lsm_l_division</a></code>.
</p>
<p>Because the metric is based on distances or areas please make sure your data
is valid using <code><a href="#topic+check_landscape">check_landscape</a></code>.
</p>


<h4>Units</h4>

<p>Hectares</p>



<h4>Range</h4>

<p>cell size / total area &lt;= MESH &lt;= total area</p>



<h4>Behaviour</h4>

<p>Equals cellsize/total area if class covers only
one cell and equals total area if only one patch is present.</p>



<h3>Value</h3>

<p>tibble
</p>


<h3>References</h3>

<p>McGarigal K., SA Cushman, and E Ene. 2023. FRAGSTATS v4: Spatial Pattern Analysis
Program for Categorical Maps. Computer software program produced by the authors;
available at the following web site: https://www.fragstats.org
</p>
<p>Jaeger, J. A. 2000. Landscape division, splitting index, and effective mesh
size: new measures of landscape fragmentation.
Landscape ecology, 15(2), 115-130.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lsm_p_area">lsm_p_area</a></code>,
<code><a href="#topic+lsm_l_ta">lsm_l_ta</a></code>, <br />
<code><a href="#topic+lsm_c_mesh">lsm_c_mesh</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>landscape &lt;- terra::rast(landscapemetrics::landscape)
lsm_l_mesh(landscape)

</code></pre>

<hr>
<h2 id='lsm_l_msidi'>MSIDI (landscape level)</h2><span id='topic+lsm_l_msidi'></span>

<h3>Description</h3>

<p>Modified Simpson's diversity index (Diversity metric)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lsm_l_msidi(landscape, directions = 8)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lsm_l_msidi_+3A_landscape">landscape</code></td>
<td>
<p>A categorical raster object: SpatRaster; Raster* Layer, Stack, Brick; stars or a list of SpatRasters.</p>
</td></tr>
<tr><td><code id="lsm_l_msidi_+3A_directions">directions</code></td>
<td>
<p>The number of directions in which patches should be
connected: 4 (rook's case) or 8 (queen's case).</p>
</td></tr>
</table>


<h3>Details</h3>

<p style="text-align: center;"><code class="reqn">MSIDI = -\ln \sum \limits_{i = 1}^{m} P_{i}^{2}</code>
</p>

<p>where <code class="reqn">P_{i}</code> is the landscape area proportion of class i.
</p>
<p>MSIDI is a 'Diversity metric'.
</p>
<p>Because the metric is based on distances or areas please make sure your data
is valid using <code><a href="#topic+check_landscape">check_landscape</a></code>.
</p>


<h4>Units</h4>

<p>None</p>



<h4>Range</h4>

<p>MSIDI &gt;= 0</p>



<h4>Behaviour</h4>

<p>MSIDI = 0 if only one patch is present and increases, without
limit, as the amount of patches with equally distributed landscape proportions increases</p>



<h3>Value</h3>

<p>tibble
</p>


<h3>References</h3>

<p>McGarigal K., SA Cushman, and E Ene. 2023. FRAGSTATS v4: Spatial Pattern Analysis
Program for Categorical Maps. Computer software program produced by the authors;
available at the following web site: https://www.fragstats.org
</p>
<p>Simpson, E. H. 1949. Measurement of diversity. Nature 163:688
</p>
<p>Pielou, E. C. 1975. Ecological Diversity. Wiley-Interscience, New York.
</p>
<p>Romme, W. H. 1982. Fire and landscapediversity in subalpine forests of
Yellowstone National Park.Ecol.Monogr. 52:199-221
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lsm_l_sidi">lsm_l_sidi</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>landscape &lt;- terra::rast(landscapemetrics::landscape)
lsm_l_msidi(landscape)

</code></pre>

<hr>
<h2 id='lsm_l_msiei'>MSIEI (landscape level)</h2><span id='topic+lsm_l_msiei'></span>

<h3>Description</h3>

<p>Modified Simpson's evenness index (Diversity metric)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lsm_l_msiei(landscape, directions = 8)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lsm_l_msiei_+3A_landscape">landscape</code></td>
<td>
<p>A categorical raster object: SpatRaster; Raster* Layer, Stack, Brick; stars or a list of SpatRasters.</p>
</td></tr>
<tr><td><code id="lsm_l_msiei_+3A_directions">directions</code></td>
<td>
<p>The number of directions in which patches should be
connected: 4 (rook's case) or 8 (queen's case).</p>
</td></tr>
</table>


<h3>Details</h3>

<p style="text-align: center;"><code class="reqn">MSIEi = \frac{- \ln \sum \limits_{i = 1}^{m} P_{i}^{2}} {\ln m}</code>
</p>

<p>where <code class="reqn">P_{i}</code> is the landscape area proportion of class i and <code class="reqn">m</code> is
the number of classes.
</p>
<p>MSIEI is a 'Diversity metric'.
</p>
<p>Because the metric is based on distances or areas please make sure your data
is valid using <code><a href="#topic+check_landscape">check_landscape</a></code>.
</p>


<h4>Units</h4>

<p>None</p>



<h4>Range</h4>

<p>0 &lt;= MSIEI &lt; 1</p>



<h4>Behaviour</h4>

<p>MSIEI = 0 when only one patch is present and approaches
MSIEI = 1 as the proportional distribution of patches becomes more even</p>



<h3>Value</h3>

<p>tibble
</p>


<h3>References</h3>

<p>McGarigal K., SA Cushman, and E Ene. 2023. FRAGSTATS v4: Spatial Pattern Analysis
Program for Categorical Maps. Computer software program produced by the authors;
available at the following web site: https://www.fragstats.org
</p>
<p>Simpson, E. H. 1949. Measurement of diversity. Nature 163:688
</p>
<p>Pielou, E. C. 1975. Ecological Diversity. Wiley-Interscience, New York.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lsm_l_siei">lsm_l_siei</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>landscape &lt;- terra::rast(landscapemetrics::landscape)
lsm_l_msiei(landscape)

</code></pre>

<hr>
<h2 id='lsm_l_mutinf'>MUTINF (landscape level)</h2><span id='topic+lsm_l_mutinf'></span>

<h3>Description</h3>

<p>Mutual information \[I(y,x)\]
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lsm_l_mutinf(landscape, neighbourhood = 4, ordered = TRUE, base = "log2")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lsm_l_mutinf_+3A_landscape">landscape</code></td>
<td>
<p>A categorical raster object: SpatRaster; Raster* Layer, Stack, Brick; stars or a list of SpatRasters.</p>
</td></tr>
<tr><td><code id="lsm_l_mutinf_+3A_neighbourhood">neighbourhood</code></td>
<td>
<p>The number of directions in which cell adjacencies are considered as neighbours:
4 (rook's case) or 8 (queen's case). The default is 4.</p>
</td></tr>
<tr><td><code id="lsm_l_mutinf_+3A_ordered">ordered</code></td>
<td>
<p>The type of pairs considered.
Either ordered (TRUE) or unordered (FALSE).
The default is TRUE.</p>
</td></tr>
<tr><td><code id="lsm_l_mutinf_+3A_base">base</code></td>
<td>
<p>The unit in which entropy is measured.
The default is &quot;log2&quot;, which compute entropy in &quot;bits&quot;.
&quot;log&quot; and &quot;log10&quot; can be also used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It disambiguates landscape pattern types characterize by the same value of an
overall complexity (<code><a href="#topic+lsm_l_joinent">lsm_l_joinent</a></code>).
</p>


<h3>Value</h3>

<p>tibble
</p>


<h3>References</h3>

<p>Nowosad J., TF Stepinski. 2019. Information theory as a consistent framework
for quantification and classification of landscape patterns. https://doi.org/10.1007/s10980-019-00830-x
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lsm_l_ent">lsm_l_ent</a></code>,
<code><a href="#topic+lsm_l_condent">lsm_l_condent</a></code>,
<code><a href="#topic+lsm_l_joinent">lsm_l_joinent</a></code>,
<code><a href="#topic+lsm_l_relmutinf">lsm_l_relmutinf</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>landscape &lt;- terra::rast(landscapemetrics::landscape)
lsm_l_mutinf(landscape)

</code></pre>

<hr>
<h2 id='lsm_l_ndca'>NDCA (landscape level)</h2><span id='topic+lsm_l_ndca'></span>

<h3>Description</h3>

<p>Number of disjunct core areas (Core area metric)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lsm_l_ndca(
  landscape,
  directions = 8,
  consider_boundary = FALSE,
  edge_depth = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lsm_l_ndca_+3A_landscape">landscape</code></td>
<td>
<p>A categorical raster object: SpatRaster; Raster* Layer, Stack, Brick; stars or a list of SpatRasters.</p>
</td></tr>
<tr><td><code id="lsm_l_ndca_+3A_directions">directions</code></td>
<td>
<p>The number of directions in which patches should be
connected: 4 (rook's case) or 8 (queen's case).</p>
</td></tr>
<tr><td><code id="lsm_l_ndca_+3A_consider_boundary">consider_boundary</code></td>
<td>
<p>Logical if cells that only neighbour the landscape
boundary should be considered as core</p>
</td></tr>
<tr><td><code id="lsm_l_ndca_+3A_edge_depth">edge_depth</code></td>
<td>
<p>Distance (in cells) a cell has the be away from the patch
edge to be considered as core cell</p>
</td></tr>
</table>


<h3>Details</h3>

<p style="text-align: center;"><code class="reqn">NDCA = \sum \limits_{i = 1}^{m} \sum \limits_{j = 1}^{n} n_{ij}^{core}</code>
</p>

<p>where <code class="reqn">n_{ij}^{core}</code> is the number of disjunct core areas.
</p>
<p>NDCA is a 'Core area metric'. The metric summarises the landscape as the sum of all
patches in the landscape. A cell is defined as core if the cell has no
neighbour with a different value than itself (rook's case). NDCA counts the disjunct
core areas, whereby a core area is a 'patch within the patch' containing only core cells.
It describes patch area and shape simultaneously (more core area when the patch is large,
however, the shape must allow disjunct core areas). Thereby, a compact shape (e.g. a square)
will contain less disjunct core areas than a more irregular patch.
</p>


<h4>Units</h4>

<p>None</p>



<h4>Range</h4>

<p>NDCA &gt;= 0</p>



<h4>Behaviour</h4>

<p>NDCA = 0 when TCA = 0, i.e. every cell in the landscape is
an edge cell. NDCA increases, with out limit, as core area increases and patch shapes allow
disjunct core areas (i.e. patch shapes become rather complex).</p>



<h3>Value</h3>

<p>tibble
</p>


<h3>References</h3>

<p>McGarigal K., SA Cushman, and E Ene. 2023. FRAGSTATS v4: Spatial Pattern Analysis
Program for Categorical Maps. Computer software program produced by the authors;
available at the following web site: https://www.fragstats.org
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lsm_c_tca">lsm_c_tca</a></code>, <br />
<code><a href="#topic+lsm_p_ncore">lsm_p_ncore</a></code>,
<code><a href="#topic+lsm_c_ndca">lsm_c_ndca</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>landscape &lt;- terra::rast(landscapemetrics::landscape)
lsm_l_ndca(landscape)

</code></pre>

<hr>
<h2 id='lsm_l_np'>NP (landscape level)</h2><span id='topic+lsm_l_np'></span>

<h3>Description</h3>

<p>Number of patches (Aggregation metric)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lsm_l_np(landscape, directions = 8)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lsm_l_np_+3A_landscape">landscape</code></td>
<td>
<p>A categorical raster object: SpatRaster; Raster* Layer, Stack, Brick; stars or a list of SpatRasters.</p>
</td></tr>
<tr><td><code id="lsm_l_np_+3A_directions">directions</code></td>
<td>
<p>The number of directions in which patches should be
connected: 4 (rook's case) or 8 (queen's case).</p>
</td></tr>
</table>


<h3>Details</h3>

<p style="text-align: center;"><code class="reqn">NP = N</code>
</p>

<p>where <code class="reqn">N</code> is the number of patches.
</p>
<p>NP is an 'Aggregation metric'. It describes the fragmentation of the landscape,
however, does not necessarily contain information about the configuration or
composition of the landscape.
</p>


<h4>Units</h4>

<p>None</p>



<h4>Ranges</h4>

<p>NP &gt;= 1</p>



<h4>Behaviour</h4>

<p>Equals NP = 1 when only one patch is present and
increases, without limit, as the number of patches increases</p>



<h3>Value</h3>

<p>tibble
</p>


<h3>References</h3>

<p>McGarigal K., SA Cushman, and E Ene. 2023. FRAGSTATS v4: Spatial Pattern Analysis
Program for Categorical Maps. Computer software program produced by the authors;
available at the following web site: https://www.fragstats.org
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lsm_c_np">lsm_c_np</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>landscape &lt;- terra::rast(landscapemetrics::landscape)
lsm_l_np(landscape)

</code></pre>

<hr>
<h2 id='lsm_l_pafrac'>PAFRAC  (landscape level)</h2><span id='topic+lsm_l_pafrac'></span>

<h3>Description</h3>

<p>Perimeter-Area Fractal Dimension (Shape metric)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lsm_l_pafrac(landscape, directions = 8, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lsm_l_pafrac_+3A_landscape">landscape</code></td>
<td>
<p>A categorical raster object: SpatRaster; Raster* Layer, Stack, Brick; stars or a list of SpatRasters.</p>
</td></tr>
<tr><td><code id="lsm_l_pafrac_+3A_directions">directions</code></td>
<td>
<p>The number of directions in which patches should be
connected: 4 (rook's case) or 8 (queen's case).</p>
</td></tr>
<tr><td><code id="lsm_l_pafrac_+3A_verbose">verbose</code></td>
<td>
<p>Print warning message if not sufficient patches are present</p>
</td></tr>
</table>


<h3>Details</h3>

<p style="text-align: center;"><code class="reqn">PAFRAC = \frac{2}{\beta}</code>
</p>

<p>where <code class="reqn">\beta</code> is the slope of the regression of the area against the perimeter
(logarithm) <code class="reqn">N \sum \limits_{i = 1}^{m} \sum \limits_{j = 1}^{n} \ln a_{ij} = a + \beta N \sum \limits_{i = 1}^{m} \sum \limits_{j = 1}^{n} \ln p_{ij}</code>
</p>
<p>PAFRAC is a 'Shape metric'. It describes the patch complexity of the landscape while being
scale independent. This means that increasing the patch size while not changing the
patch form will not change the metric. However, it is only meaningful if the relationship
between the area and perimeter is linear on a logarithmic scale. Furthermore, if there
are less than 10 patches in the landscape, the metric returns NA because of the small-sample
issue.
</p>
<p>Because the metric is based on distances or areas please make sure your data
is valid using <code><a href="#topic+check_landscape">check_landscape</a></code>.
</p>


<h4>Units</h4>

<p>None</p>



<h4>Range</h4>

<p>1 &lt;= PAFRAC &lt;= 2</p>



<h4>Behaviour</h4>

<p>Approaches PAFRAC = 1 for patches with simple shapes and
approaches PAFRAC = 2 for irregular shapes</p>



<h3>Value</h3>

<p>tibble
</p>


<h3>References</h3>

<p>McGarigal K., SA Cushman, and E Ene. 2023. FRAGSTATS v4: Spatial Pattern Analysis
Program for Categorical Maps. Computer software program produced by the authors;
available at the following web site: https://www.fragstats.org
</p>
<p>Burrough, P. A. 1986. Principles of Geographical Information Systems for
Land Resources Assessment. Monographs on Soil and Resources Survey No. 12.
Clarendon Press, Oxford
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lsm_p_area">lsm_p_area</a></code>,
<code><a href="#topic+lsm_p_perim">lsm_p_perim</a></code>, <br />
<code><a href="#topic+lsm_c_pafrac">lsm_c_pafrac</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>landscape &lt;- terra::rast(landscapemetrics::landscape)
lsm_l_pafrac(landscape)

</code></pre>

<hr>
<h2 id='lsm_l_para_cv'>PARA_CV (landscape level)</h2><span id='topic+lsm_l_para_cv'></span>

<h3>Description</h3>

<p>Coefficient of variation perimeter-area ratio (Shape metric)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lsm_l_para_cv(landscape, directions = 8)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lsm_l_para_cv_+3A_landscape">landscape</code></td>
<td>
<p>A categorical raster object: SpatRaster; Raster* Layer, Stack, Brick; stars or a list of SpatRasters.</p>
</td></tr>
<tr><td><code id="lsm_l_para_cv_+3A_directions">directions</code></td>
<td>
<p>The number of directions in which patches should be
connected: 4 (rook's case) or 8 (queen's case).</p>
</td></tr>
</table>


<h3>Details</h3>

<p style="text-align: center;"><code class="reqn">PARA_{CV} = cv(PARA[patch_{ij}]</code>
</p>

<p>where <code class="reqn">PARA[patch_{ij}]</code> is the perimeter area ratio of each patch.
</p>
<p>PARA_CV is a 'Shape metric'. It summarises the landscape as the Coefficient of variation of
each patch belonging in the landscape The perimeter-area ratio describes the patch complexity
in a straightforward way. However, because it is not standarised to a certain shape
(e.g. a square), it is not scale independent, meaning that increasing the patch size
while not changing the patch form will change the ratio.
</p>
<p>Because the metric is based on distances or areas please make sure your data
is valid using <code><a href="#topic+check_landscape">check_landscape</a></code>.
</p>


<h4>Units</h4>

<p>None</p>



<h4>Range</h4>

<p>PARA_CV &gt;= 0</p>



<h4>Behaviour</h4>

<p>Equals PARA_CV = 0 if the perimeter-area ratio is identical for
all patches. Increases, without limit, as the variation of the perimeter-area ratio
increases.</p>



<h3>Value</h3>

<p>tibble
</p>


<h3>References</h3>

<p>McGarigal K., SA Cushman, and E Ene. 2023. FRAGSTATS v4: Spatial Pattern Analysis
Program for Categorical Maps. Computer software program produced by the authors;
available at the following web site: https://www.fragstats.org
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lsm_p_para">lsm_p_para</a></code>, <br />
<code><a href="#topic+lsm_c_para_mn">lsm_c_para_mn</a></code>,
<code><a href="#topic+lsm_c_para_sd">lsm_c_para_sd</a></code>,
<code><a href="#topic+lsm_c_para_cv">lsm_c_para_cv</a></code>, <br />
<code><a href="#topic+lsm_l_para_mn">lsm_l_para_mn</a></code>,
<code><a href="#topic+lsm_l_para_sd">lsm_l_para_sd</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>landscape &lt;- terra::rast(landscapemetrics::landscape)
lsm_l_para_cv(landscape)

</code></pre>

<hr>
<h2 id='lsm_l_para_mn'>PARA_MN (landscape level)</h2><span id='topic+lsm_l_para_mn'></span>

<h3>Description</h3>

<p>Mean perimeter-area ratio (Shape metric)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lsm_l_para_mn(landscape, directions = 8)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lsm_l_para_mn_+3A_landscape">landscape</code></td>
<td>
<p>A categorical raster object: SpatRaster; Raster* Layer, Stack, Brick; stars or a list of SpatRasters.</p>
</td></tr>
<tr><td><code id="lsm_l_para_mn_+3A_directions">directions</code></td>
<td>
<p>The number of directions in which patches should be
connected: 4 (rook's case) or 8 (queen's case).</p>
</td></tr>
</table>


<h3>Details</h3>

<p style="text-align: center;"><code class="reqn">PARA_{MN} = mean(PARA[patch_{ij}]</code>
</p>

<p>where <code class="reqn">PARA[patch_{ij}]</code> is the perimeter area ratio of each patch.
</p>
<p>PARA_MN is a 'Shape metric'. It summarises the landscape as the mean of
each patch in the landscape. The perimeter-area ratio describes the patch complexity
in a straightforward way. However, because it is not standarised to a certain shape
(e.g. a square), it is not scale independent, meaning that increasing the patch size
while not changing the patch form will change the ratio.
</p>
<p>Because the metric is based on distances or areas please make sure your data
is valid using <code><a href="#topic+check_landscape">check_landscape</a></code>.
</p>


<h4>Units</h4>

<p>None</p>



<h4>Range</h4>

<p>PARA_MN &gt; 0</p>



<h4>Behaviour</h4>

<p>Approaches PARA_MN &gt; 0 if PARA for each patch approaches PARA &gt; 0,
i.e. the form approaches a rather small square. Increases, without limit, as PARA increases,
i.e. patches become more complex.</p>



<h3>Value</h3>

<p>tibble
</p>


<h3>References</h3>

<p>McGarigal K., SA Cushman, and E Ene. 2023. FRAGSTATS v4: Spatial Pattern Analysis
Program for Categorical Maps. Computer software program produced by the authors;
available at the following web site: https://www.fragstats.org
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lsm_p_para">lsm_p_para</a></code>,
<code><a href="base.html#topic+mean">mean</a></code>, <br />
<code><a href="#topic+lsm_c_para_mn">lsm_c_para_mn</a></code>,
<code><a href="#topic+lsm_c_para_sd">lsm_c_para_sd</a></code>,
<code><a href="#topic+lsm_c_para_cv">lsm_c_para_cv</a></code>, <br />
<code><a href="#topic+lsm_l_para_sd">lsm_l_para_sd</a></code>,
<code><a href="#topic+lsm_l_para_cv">lsm_l_para_cv</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>landscape &lt;- terra::rast(landscapemetrics::landscape)
lsm_l_para_mn(landscape)

</code></pre>

<hr>
<h2 id='lsm_l_para_sd'>PARA_SD (landscape level)</h2><span id='topic+lsm_l_para_sd'></span>

<h3>Description</h3>

<p>Standard deviation perimeter-area ratio (Shape metric)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lsm_l_para_sd(landscape, directions = 8)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lsm_l_para_sd_+3A_landscape">landscape</code></td>
<td>
<p>A categorical raster object: SpatRaster; Raster* Layer, Stack, Brick; stars or a list of SpatRasters.</p>
</td></tr>
<tr><td><code id="lsm_l_para_sd_+3A_directions">directions</code></td>
<td>
<p>The number of directions in which patches should be
connected: 4 (rook's case) or 8 (queen's case).</p>
</td></tr>
</table>


<h3>Details</h3>

<p style="text-align: center;"><code class="reqn">PARA_{SD} = sd(PARA[patch_{ij}]</code>
</p>

<p>where <code class="reqn">PARA[patch_{ij}]</code> is the perimeter area ratio of each patch.
</p>
<p>PARA_SD is a 'Shape metric'. It summarises the landscape as the standard deviation of
each patch belonging in the landscape. The perimeter-area ratio describes the patch complexity
in a straightforward way. However, because it is not standarised to a certain shape
(e.g. a square), it is not scale independent, meaning that increasing the patch size
while not changing the patch form will change the ratio.
</p>
<p>Because the metric is based on distances or areas please make sure your data
is valid using <code><a href="#topic+check_landscape">check_landscape</a></code>.
</p>


<h4>Units</h4>

<p>None</p>



<h4>Range</h4>

<p>PARA_SD &gt;= 0</p>



<h4>Behaviour</h4>

<p>Equals PARA_SD = 0 if the perimeter-area ratio is identical for
all patches. Increases, without limit, as the variation of the perimeter-area ratio
increases.</p>



<h3>Value</h3>

<p>tibble
</p>


<h3>References</h3>

<p>McGarigal K., SA Cushman, and E Ene. 2023. FRAGSTATS v4: Spatial Pattern Analysis
Program for Categorical Maps. Computer software program produced by the authors;
available at the following web site: https://www.fragstats.org
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lsm_p_para">lsm_p_para</a></code>,
<code><a href="stats.html#topic+sd">sd</a></code> <br />
<code><a href="#topic+lsm_c_para_mn">lsm_c_para_mn</a></code>,
<code><a href="#topic+lsm_c_para_sd">lsm_c_para_sd</a></code>,
<code><a href="#topic+lsm_c_para_cv">lsm_c_para_cv</a></code>, <br />
<code><a href="#topic+lsm_l_para_mn">lsm_l_para_mn</a></code>,
<code><a href="#topic+lsm_l_para_cv">lsm_l_para_cv</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>landscape &lt;- terra::rast(landscapemetrics::landscape)
lsm_l_para_sd(landscape)

</code></pre>

<hr>
<h2 id='lsm_l_pd'>PD (landscape level)</h2><span id='topic+lsm_l_pd'></span>

<h3>Description</h3>

<p>Patch density (Aggregation metric)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lsm_l_pd(landscape, directions = 8)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lsm_l_pd_+3A_landscape">landscape</code></td>
<td>
<p>A categorical raster object: SpatRaster; Raster* Layer, Stack, Brick; stars or a list of SpatRasters.</p>
</td></tr>
<tr><td><code id="lsm_l_pd_+3A_directions">directions</code></td>
<td>
<p>The number of directions in which patches should be
connected: 4 (rook's case) or 8 (queen's case).</p>
</td></tr>
</table>


<h3>Details</h3>

<p style="text-align: center;"><code class="reqn">PD = \frac{N} {A} * 10000 * 100</code>
</p>

<p>where <code class="reqn">N</code> is the number of patches and <code class="reqn">A</code> is the total landscape
area in square meters.
</p>
<p>PD is an 'Aggregation metric'. It describes the fragmentation the landscape, however,
does not necessarily contain information about the configuration or composition of the
landscape. In contrast to <code><a href="#topic+lsm_l_np">lsm_l_np</a></code> it is standardized to the area and
comparisons among landscapes with different total area are possible.
</p>
<p>Because the metric is based on distances or areas please make sure your data
is valid using <code><a href="#topic+check_landscape">check_landscape</a></code>.
</p>


<h4>Units</h4>

<p>Number per 100 hectares</p>



<h4>Ranges</h4>

<p>0 &lt; PD &lt;= 1e+06</p>



<h4>Behaviour</h4>

<p>Increases as the landscape gets more patchy. Reaches its maximum
if every cell is a different patch.</p>



<h3>Value</h3>

<p>tibble
</p>


<h3>References</h3>

<p>McGarigal K., SA Cushman, and E Ene. 2023. FRAGSTATS v4: Spatial Pattern Analysis
Program for Categorical Maps. Computer software program produced by the authors;
available at the following web site: https://www.fragstats.org
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lsm_c_np">lsm_c_np</a></code>,
<code><a href="#topic+lsm_l_ta">lsm_l_ta</a></code>, <br />
<code><a href="#topic+lsm_c_pd">lsm_c_pd</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>landscape &lt;- terra::rast(landscapemetrics::landscape)
lsm_l_pd(landscape)

</code></pre>

<hr>
<h2 id='lsm_l_pladj'>PLADJ (landscape level)</h2><span id='topic+lsm_l_pladj'></span>

<h3>Description</h3>

<p>Percentage of Like Adjacencies (Aggregation metric)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lsm_l_pladj(landscape)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lsm_l_pladj_+3A_landscape">landscape</code></td>
<td>
<p>A categorical raster object: SpatRaster; Raster* Layer, Stack, Brick; stars or a list of SpatRasters.</p>
</td></tr>
</table>


<h3>Details</h3>

<p style="text-align: center;"><code class="reqn">PLADJ = (\frac{g_{ij}} {\sum \limits_{k = 1}^{m} g_{ik}}) * 100</code>
</p>

<p>where <code class="reqn">g_{ii}</code> is the number of adjacencies between cells of class i
and <code class="reqn">g_{ik}</code> is the number of adjacencies between cells of class i and k.
</p>
<p>PLADJ is an 'Aggregation metric'. It calculates the frequency how often patches of
different classes i (focal class) and k are next to each other, and following is a
measure of class aggregation. The adjacencies are counted using the double-count method.
</p>


<h4>Units</h4>

<p>Percent</p>



<h4>Ranges</h4>

<p>0 &lt;= PLADJ &lt;= 100</p>



<h4>Behaviour</h4>

<p>Equals PLADJ = 0 if class i is maximal disaggregated,
i.e. every cell is a different patch. Equals PLADJ = 100 when the only one patch
is present.</p>



<h3>Value</h3>

<p>tibble
</p>


<h3>References</h3>

<p>McGarigal K., SA Cushman, and E Ene. 2023. FRAGSTATS v4: Spatial Pattern Analysis
Program for Categorical Maps. Computer software program produced by the authors;
available at the following web site: https://www.fragstats.org.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>landscape &lt;- terra::rast(landscapemetrics::landscape)
lsm_l_pladj(landscape)

</code></pre>

<hr>
<h2 id='lsm_l_pr'>PR (landscape level)</h2><span id='topic+lsm_l_pr'></span>

<h3>Description</h3>

<p>Patch richness (Diversity metric)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lsm_l_pr(landscape)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lsm_l_pr_+3A_landscape">landscape</code></td>
<td>
<p>A categorical raster object: SpatRaster; Raster* Layer, Stack, Brick; stars or a list of SpatRasters.</p>
</td></tr>
</table>


<h3>Details</h3>

<p style="text-align: center;"><code class="reqn">PR = m</code>
</p>

<p>where <code class="reqn">m</code> is the number of classes
</p>
<p>PR is a 'Diversity metric'. It is one of the simplest diversity and composition measures.
However, because of its absolute nature, it is not comparable among landscapes with
different total areas.
</p>


<h4>Units</h4>

<p>None</p>



<h4>Range</h4>

<p>PR &gt;= 1</p>



<h4>Behaviour</h4>

<p>Equals PR = 1 when only one patch is present and increases, without
limit, as the number of classes increases</p>



<h3>Value</h3>

<p>tibble
</p>


<h3>References</h3>

<p>McGarigal K., SA Cushman, and E Ene. 2023. FRAGSTATS v4: Spatial Pattern Analysis
Program for Categorical Maps. Computer software program produced by the authors;
available at the following web site: https://www.fragstats.org
</p>


<h3>Examples</h3>

<pre><code class='language-R'>landscape &lt;- terra::rast(landscapemetrics::landscape)
lsm_l_pr(landscape)

</code></pre>

<hr>
<h2 id='lsm_l_prd'>PRD (landscape level)</h2><span id='topic+lsm_l_prd'></span>

<h3>Description</h3>

<p>Patch richness density (Diversity metric)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lsm_l_prd(landscape, directions = 8)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lsm_l_prd_+3A_landscape">landscape</code></td>
<td>
<p>A categorical raster object: SpatRaster; Raster* Layer, Stack, Brick; stars or a list of SpatRasters.</p>
</td></tr>
<tr><td><code id="lsm_l_prd_+3A_directions">directions</code></td>
<td>
<p>The number of directions in which patches should be
connected: 4 (rook's case) or 8 (queen's case).</p>
</td></tr>
</table>


<h3>Details</h3>

<p style="text-align: center;"><code class="reqn">PRD = \frac{m} {A} * 10000 * 100 </code>
</p>

<p>where <code class="reqn">m</code> is the number of classes and <code class="reqn">A</code> is the total landscape area in
square meters.
</p>
<p>PRD is a 'Diversity metric'. It is one of the simplest diversity and composition measures.
In contrast to <code><a href="#topic+lsm_l_pr">lsm_l_pr</a></code>, it is a relative measure and following, comparable
among landscapes with different total landscape areas.
</p>
<p>Because the metric is based on distances or areas please make sure your data
is valid using <code><a href="#topic+check_landscape">check_landscape</a></code>.
</p>


<h4>Units</h4>

<p>Number per 100 hectares</p>



<h4>Range</h4>

<p>PR &gt; 0</p>



<h4>Behaviour</h4>

<p>Approaches PRD &gt; 1 when only one patch is present and the landscape
is rather large. Increases, without limit, as the number of classes increases and the
total landscape area decreases.</p>



<h3>Value</h3>

<p>tibble
</p>


<h3>References</h3>

<p>McGarigal K., SA Cushman, and E Ene. 2023. FRAGSTATS v4: Spatial Pattern Analysis
Program for Categorical Maps. Computer software program produced by the authors;
available at the following web site: https://www.fragstats.org
</p>


<h3>Examples</h3>

<pre><code class='language-R'>landscape &lt;- terra::rast(landscapemetrics::landscape)
lsm_l_prd(landscape)

</code></pre>

<hr>
<h2 id='lsm_l_relmutinf'>RELMUTINF (landscape level)</h2><span id='topic+lsm_l_relmutinf'></span>

<h3>Description</h3>

<p>Relative mutual information
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lsm_l_relmutinf(landscape, neighbourhood = 4, ordered = TRUE, base = "log2")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lsm_l_relmutinf_+3A_landscape">landscape</code></td>
<td>
<p>A categorical raster object: SpatRaster; Raster* Layer, Stack, Brick; stars or a list of SpatRasters.</p>
</td></tr>
<tr><td><code id="lsm_l_relmutinf_+3A_neighbourhood">neighbourhood</code></td>
<td>
<p>The number of directions in which cell adjacencies are considered as neighbours:
4 (rook's case) or 8 (queen's case). The default is 4.</p>
</td></tr>
<tr><td><code id="lsm_l_relmutinf_+3A_ordered">ordered</code></td>
<td>
<p>The type of pairs considered.
Either ordered (TRUE) or unordered (FALSE).
The default is TRUE.</p>
</td></tr>
<tr><td><code id="lsm_l_relmutinf_+3A_base">base</code></td>
<td>
<p>The unit in which entropy is measured.
The default is &quot;log2&quot;, which compute entropy in &quot;bits&quot;.
&quot;log&quot; and &quot;log10&quot; can be also used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Due to the spatial autocorrelation, the value of mutual information tends to grow
with a diversity of the landscape (marginal entropy). To adjust this tendency,
it is possible to calculate relative mutual information by dividing the mutual
information by the marginal entropy. Relative mutual information always has a
range between 0 and 1 and can be used to compare spatial data with different
number and distribution of categories. When the value of mutual information equals
to 0, then relative mutual information is 1.
</p>


<h3>Value</h3>

<p>tibble
</p>


<h3>References</h3>

<p>Nowosad J., TF Stepinski. 2019. Information theory as a consistent framework
for quantification and classification of landscape patterns. https://doi.org/10.1007/s10980-019-00830-x
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lsm_l_ent">lsm_l_ent</a></code>,
<code><a href="#topic+lsm_l_condent">lsm_l_condent</a></code>,
<code><a href="#topic+lsm_l_joinent">lsm_l_joinent</a></code>,
<code><a href="#topic+lsm_l_mutinf">lsm_l_mutinf</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>landscape &lt;- terra::rast(landscapemetrics::landscape)
lsm_l_relmutinf(landscape)

</code></pre>

<hr>
<h2 id='lsm_l_rpr'>RPD (landscape level)</h2><span id='topic+lsm_l_rpr'></span>

<h3>Description</h3>

<p>Relative patch richness (Diversity metric)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lsm_l_rpr(landscape, classes_max = NULL, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lsm_l_rpr_+3A_landscape">landscape</code></td>
<td>
<p>A categorical raster object: SpatRaster; Raster* Layer, Stack, Brick; stars or a list of SpatRasters.</p>
</td></tr>
<tr><td><code id="lsm_l_rpr_+3A_classes_max">classes_max</code></td>
<td>
<p>Potential maximum number of present classes</p>
</td></tr>
<tr><td><code id="lsm_l_rpr_+3A_verbose">verbose</code></td>
<td>
<p>Print warning message if not sufficient patches are present</p>
</td></tr>
</table>


<h3>Details</h3>

<p style="text-align: center;"><code class="reqn">RPR = \frac{m} {m_{max}} * 100</code>
</p>

<p>where <code class="reqn">m</code> is the number of classes and <code class="reqn">m_{max}</code> is the (theoretical)
maximum number of classes.
</p>
<p>RPR is an 'Diversity metric'. The metric calculates the percentage of present classes
in the landscape in relation to a (theoretical) number of maximum classes. The user has to
specify the maximum number of classes. Note, that if <code>classes_max</code> is not provided,
the functions returns <code>NA</code>.
</p>


<h4>Units</h4>

<p>Percentage</p>



<h4>Ranges</h4>

<p>0 &lt; RPR &lt;= 100</p>



<h4>Behaviour</h4>

<p>Approaches RPR &gt; 0 when only one class type is present,
but the maximum number of classes is large. Equals RPR = 100 when m = m_max</p>



<h3>Value</h3>

<p>tibble
</p>


<h3>References</h3>

<p>McGarigal K., SA Cushman, and E Ene. 2023. FRAGSTATS v4: Spatial Pattern Analysis
Program for Categorical Maps. Computer software program produced by the authors;
available at the following web site: https://www.fragstats.org
</p>
<p>Romme, W. H. 1982. Fire and landscapediversity in subalpine forests of
Yellowstone National Park.Ecol.Monogr. 52:199-221
</p>


<h3>Examples</h3>

<pre><code class='language-R'>landscape &lt;- terra::rast(landscapemetrics::landscape)
lsm_l_rpr(landscape, classes_max = 5)

</code></pre>

<hr>
<h2 id='lsm_l_shape_cv'>SHAPE_CV (landscape level)</h2><span id='topic+lsm_l_shape_cv'></span>

<h3>Description</h3>

<p>Coefficient of variation shape index (Shape metric)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lsm_l_shape_cv(landscape, directions = 8)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lsm_l_shape_cv_+3A_landscape">landscape</code></td>
<td>
<p>A categorical raster object: SpatRaster; Raster* Layer, Stack, Brick; stars or a list of SpatRasters.</p>
</td></tr>
<tr><td><code id="lsm_l_shape_cv_+3A_directions">directions</code></td>
<td>
<p>The number of directions in which patches should be
connected: 4 (rook's case) or 8 (queen's case).</p>
</td></tr>
</table>


<h3>Details</h3>

<p style="text-align: center;"><code class="reqn">SHAPE_{CV} = cv(SHAPE[patch_{ij}])</code>
</p>

<p>where <code class="reqn">SHAPE[patch_{ij}]</code> is the shape index of each patch.
</p>
<p>SHAPE_CV is a 'Shape metric'. The landscape is summarised as the Coefficient of variation
of all patches in the landscape. SHAPE describes the ratio between the actual perimeter of
the patch and the square root of patch area.
</p>
<p>Because the metric is based on distances or areas please make sure your data
is valid using <code><a href="#topic+check_landscape">check_landscape</a></code>.
</p>


<h4>Units</h4>

<p>None</p>



<h4>Range</h4>

<p>SHAPE_CV &gt;= 0</p>



<h4>Behaviour</h4>

<p>Equals SHAPE_CV = 0 if all patches have an identical shape index.
Increases, without limit, as the variation of the shape index increases.</p>



<h3>Value</h3>

<p>tibble
</p>


<h3>References</h3>

<p>McGarigal K., SA Cushman, and E Ene. 2023. FRAGSTATS v4: Spatial Pattern Analysis
Program for Categorical Maps. Computer software program produced by the authors;
available at the following web site: https://www.fragstats.org
</p>
<p>Patton, D. R. 1975. A diversity index for quantifying habitat &quot;edge&quot;.
Wildl. Soc.Bull. 3:171-173.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lsm_p_shape">lsm_p_shape</a></code>, <br />
<code><a href="#topic+lsm_c_shape_mn">lsm_c_shape_mn</a></code>,
<code><a href="#topic+lsm_c_shape_sd">lsm_c_shape_sd</a></code>, <br />
<code><a href="#topic+lsm_c_shape_cv">lsm_c_shape_cv</a></code>,
<code><a href="#topic+lsm_l_shape_mn">lsm_l_shape_mn</a></code>,
<code><a href="#topic+lsm_l_shape_sd">lsm_l_shape_sd</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>landscape &lt;- terra::rast(landscapemetrics::landscape)
lsm_l_shape_cv(landscape)

</code></pre>

<hr>
<h2 id='lsm_l_shape_mn'>SHAPE_MN (landscape level)</h2><span id='topic+lsm_l_shape_mn'></span>

<h3>Description</h3>

<p>Mean shape index (Shape metric)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lsm_l_shape_mn(landscape, directions = 8)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lsm_l_shape_mn_+3A_landscape">landscape</code></td>
<td>
<p>A categorical raster object: SpatRaster; Raster* Layer, Stack, Brick; stars or a list of SpatRasters.</p>
</td></tr>
<tr><td><code id="lsm_l_shape_mn_+3A_directions">directions</code></td>
<td>
<p>The number of directions in which patches should be
connected: 4 (rook's case) or 8 (queen's case).</p>
</td></tr>
</table>


<h3>Details</h3>

<p style="text-align: center;"><code class="reqn">SHAPE_{MN} = mean(SHAPE[patch_{ij}])</code>
</p>

<p>where <code class="reqn">SHAPE[patch_{ij}]</code> is the shape index of each patch.
</p>
<p>SHAPE_MN is a 'Shape metric'. The landscape is summarised as the mean
of all patches in the landscape. SHAPE describes the ratio between the actual perimeter of
the patch and the square root of patch area.
</p>
<p>Because the metric is based on distances or areas please make sure your data
is valid using <code><a href="#topic+check_landscape">check_landscape</a></code>.
</p>


<h4>Units</h4>

<p>None</p>



<h4>Range</h4>

<p>SHAPE_SD &gt;= 1</p>



<h4>Behaviour</h4>

<p>Equals SHAPE_MN = 1 if all patches are squares.
Increases, without limit, as the shapes of patches become more complex.</p>



<h3>Value</h3>

<p>tibble
</p>


<h3>References</h3>

<p>McGarigal K., SA Cushman, and E Ene. 2023. FRAGSTATS v4: Spatial Pattern Analysis
Program for Categorical Maps. Computer software program produced by the authors;
available at the following web site: https://www.fragstats.org
</p>
<p>Patton, D. R. 1975. A diversity index for quantifying habitat &quot;edge&quot;.
Wildl. Soc.Bull. 3:171-173.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lsm_p_shape">lsm_p_shape</a></code>,
<code><a href="base.html#topic+mean">mean</a></code>, <br />
<code><a href="#topic+lsm_c_shape_mn">lsm_c_shape_mn</a></code>,
<code><a href="#topic+lsm_c_shape_sd">lsm_c_shape_sd</a></code>,
<code><a href="#topic+lsm_c_shape_cv">lsm_c_shape_cv</a></code>, <br />
<code><a href="#topic+lsm_l_shape_sd">lsm_l_shape_sd</a></code>,
<code><a href="#topic+lsm_l_shape_cv">lsm_l_shape_cv</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>landscape &lt;- terra::rast(landscapemetrics::landscape)
lsm_l_shape_mn(landscape)

</code></pre>

<hr>
<h2 id='lsm_l_shape_sd'>SHAPE_SD (landscape level)</h2><span id='topic+lsm_l_shape_sd'></span>

<h3>Description</h3>

<p>Standard deviation shape index (Shape metric)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lsm_l_shape_sd(landscape, directions = 8)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lsm_l_shape_sd_+3A_landscape">landscape</code></td>
<td>
<p>A categorical raster object: SpatRaster; Raster* Layer, Stack, Brick; stars or a list of SpatRasters.</p>
</td></tr>
<tr><td><code id="lsm_l_shape_sd_+3A_directions">directions</code></td>
<td>
<p>The number of directions in which patches should be
connected: 4 (rook's case) or 8 (queen's case).</p>
</td></tr>
</table>


<h3>Details</h3>

<p style="text-align: center;"><code class="reqn">SHAPE_{SD} = sd(SHAPE[patch_{ij}])</code>
</p>

<p>where <code class="reqn">SHAPE[patch_{ij}]</code> is the shape index of each patch.
</p>
<p>SHAPE_SD is a 'Shape metric'. The landscape summarised as the standard deviation
of all patches in the landscape. SHAPE describes the ratio between the actual perimeter of
the patch and the square root of patch area.
</p>
<p>Because the metric is based on distances or areas please make sure your data
is valid using <code><a href="#topic+check_landscape">check_landscape</a></code>.
</p>


<h4>Units</h4>

<p>None</p>



<h4>Range</h4>

<p>SHAPE_SD &gt;= 0</p>



<h4>Behaviour</h4>

<p>Equals SHAPE_SD = 0 if all patches have an identical shape index.
Increases, without limit, as the variation of the shape index increases.</p>



<h3>Value</h3>

<p>tibble
</p>


<h3>References</h3>

<p>McGarigal K., SA Cushman, and E Ene. 2023. FRAGSTATS v4: Spatial Pattern Analysis
Program for Categorical Maps. Computer software program produced by the authors;
available at the following web site: https://www.fragstats.org
</p>
<p>Patton, D. R. 1975. A diversity index for quantifying habitat &quot;edge&quot;.
Wildl. Soc.Bull. 3:171-173.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lsm_p_shape">lsm_p_shape</a></code>,
<code><a href="stats.html#topic+sd">sd</a></code> <br />
<code><a href="#topic+lsm_c_shape_mn">lsm_c_shape_mn</a></code>,
<code><a href="#topic+lsm_c_shape_sd">lsm_c_shape_sd</a></code>,
<code><a href="#topic+lsm_c_shape_cv">lsm_c_shape_cv</a></code>, <br />
<code><a href="#topic+lsm_l_shape_mn">lsm_l_shape_mn</a></code>,
<code><a href="#topic+lsm_l_shape_cv">lsm_l_shape_cv</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>landscape &lt;- terra::rast(landscapemetrics::landscape)
lsm_l_shape_sd(landscape)

</code></pre>

<hr>
<h2 id='lsm_l_shdi'>SHDI (landscape level)</h2><span id='topic+lsm_l_shdi'></span>

<h3>Description</h3>

<p>Shannon's diversity index (Diversity metric)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lsm_l_shdi(landscape)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lsm_l_shdi_+3A_landscape">landscape</code></td>
<td>
<p>A categorical raster object: SpatRaster; Raster* Layer, Stack, Brick; stars or a list of SpatRasters.</p>
</td></tr>
</table>


<h3>Details</h3>

<p style="text-align: center;"><code class="reqn">SHDI = - \sum \limits_{i = 1}^{m} (P_{i} * \ln P_{i})</code>
</p>

<p>where <code class="reqn">P_{i}</code> is the proportion of class i.
</p>
<p>SHDI is a 'Diversity metric'. It is a widely used metric in biodiversity and ecology
and takes both the number of classes and the abundance of each class into account.
</p>


<h4>Units</h4>

<p>None</p>



<h4>Range</h4>

<p>SHDI &gt;= 0</p>



<h4>Behaviour</h4>

<p>Equals SHDI = 0 when only one patch is present and increases,
without limit, as the number of classes increases while the proportions are
equally distributed</p>



<h3>Value</h3>

<p>tibble
</p>


<h3>References</h3>

<p>McGarigal K., SA Cushman, and E Ene. 2023. FRAGSTATS v4: Spatial Pattern Analysis
Program for Categorical Maps. Computer software program produced by the authors;
available at the following web site: https://www.fragstats.org
</p>
<p>Shannon, C., and W. Weaver. 1949. The mathematical theory of
communication. Univ. IllinoisPress, Urbana
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lsm_c_pland">lsm_c_pland</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>landscape &lt;- terra::rast(landscapemetrics::landscape)
lsm_l_shdi(landscape)

</code></pre>

<hr>
<h2 id='lsm_l_shei'>SHEI (landscape level)</h2><span id='topic+lsm_l_shei'></span>

<h3>Description</h3>

<p>Shannons's evenness index (Diversity metric)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lsm_l_shei(landscape)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lsm_l_shei_+3A_landscape">landscape</code></td>
<td>
<p>A categorical raster object: SpatRaster; Raster* Layer, Stack, Brick; stars or a list of SpatRasters.</p>
</td></tr>
</table>


<h3>Details</h3>

<p style="text-align: center;"><code class="reqn">SHEI = \frac{- \sum \limits_{i = 1} ^ {m} (P_{i} * \ln P_{i})} {\ln m}</code>
</p>

<p>where <code class="reqn">P_{i}</code> is the proportion of class i and <code class="reqn">m</code> is the
number of classes.
</p>
<p>SHEI is a 'Diversity metric'. It is the ratio between the actual Shannon's diversity index
and and the theoretical maximum of the Shannon diversity index. It can be understood as a
measure of dominance.
</p>


<h4>Units</h4>

<p>None</p>



<h4>Range</h4>

<p>0 &lt;= SHEI &lt; 1</p>



<h4>Behaviour</h4>

<p>Equals SHEI = 0 when only one patch  present and equals SHEI = 1
when the proportion of classes is completely equally distributed</p>



<h3>Value</h3>

<p>tibble
</p>


<h3>References</h3>

<p>McGarigal K., SA Cushman, and E Ene. 2023. FRAGSTATS v4: Spatial Pattern Analysis
Program for Categorical Maps. Computer software program produced by the authors;
available at the following web site: https://www.fragstats.org
</p>
<p>Shannon, C., and W. Weaver. 1949. The mathematical theory of
communication. Univ. IllinoisPress, Urbana
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lsm_c_pland">lsm_c_pland</a></code>,
<code><a href="#topic+lsm_l_pr">lsm_l_pr</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>landscape &lt;- terra::rast(landscapemetrics::landscape)
lsm_l_shei(landscape)

</code></pre>

<hr>
<h2 id='lsm_l_sidi'>SIDI (landscape level)</h2><span id='topic+lsm_l_sidi'></span>

<h3>Description</h3>

<p>Simpson's diversity index (Diversity metric)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lsm_l_sidi(landscape, directions = 8)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lsm_l_sidi_+3A_landscape">landscape</code></td>
<td>
<p>A categorical raster object: SpatRaster; Raster* Layer, Stack, Brick; stars or a list of SpatRasters.</p>
</td></tr>
<tr><td><code id="lsm_l_sidi_+3A_directions">directions</code></td>
<td>
<p>The number of directions in which patches should be
connected: 4 (rook's case) or 8 (queen's case).</p>
</td></tr>
</table>


<h3>Details</h3>

<p style="text-align: center;"><code class="reqn">SIDI = 1 - \sum \limits_{i = 1}^{m} P_{i}^{2}</code>
</p>

<p>where <code class="reqn">P_{i}</code> is the proportion of class i and <code class="reqn">m</code> is the
number of classes.
</p>
<p>SIDI is a 'Diversity metric'. It is widely used in biodiversity and ecology. It is
less sensitive to rare class types than <code><a href="#topic+lsm_l_shdi">lsm_l_shdi</a></code>. It can be interpreted
as the probability that two randomly selected cells belong to the same class.
</p>


<h4>Units</h4>

<p>None</p>



<h4>Range</h4>

<p>0 &lt;= SIDI &lt; 1</p>



<h4>Behaviour</h4>

<p>Equals SIDI = 0 when only one patch is present and approaches
SIDI &lt; 1 when the number of class types increases while the proportions are equally
distributed</p>



<h3>Value</h3>

<p>tibble
</p>


<h3>References</h3>

<p>McGarigal K., SA Cushman, and E Ene. 2023. FRAGSTATS v4: Spatial Pattern Analysis
Program for Categorical Maps. Computer software program produced by the authors;
available at the following web site: https://www.fragstats.org
</p>
<p>Simpson, E. H. 1949. Measurement of diversity. Nature 163:688
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lsm_c_pland">lsm_c_pland</a></code>,
<code><a href="#topic+lsm_l_pr">lsm_l_pr</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>landscape &lt;- terra::rast(landscapemetrics::landscape)
lsm_l_sidi(landscape)

</code></pre>

<hr>
<h2 id='lsm_l_siei'>SIEI (landscape level)</h2><span id='topic+lsm_l_siei'></span>

<h3>Description</h3>

<p>Simpson's evenness index (Diversity metric)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lsm_l_siei(landscape, directions = 8)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lsm_l_siei_+3A_landscape">landscape</code></td>
<td>
<p>A categorical raster object: SpatRaster; Raster* Layer, Stack, Brick; stars or a list of SpatRasters.</p>
</td></tr>
<tr><td><code id="lsm_l_siei_+3A_directions">directions</code></td>
<td>
<p>The number of directions in which patches should be
connected: 4 (rook's case) or 8 (queen's case).</p>
</td></tr>
</table>


<h3>Details</h3>

<p style="text-align: center;"><code class="reqn">SIEI = \frac{1 - \sum \limits_{i = 1}^{m} P_{i}^{2}} {1 - \frac{1} {m}}</code>
</p>

<p>where <code class="reqn">P_{i}</code> is the proportion of class i and <code class="reqn">m</code> is the
number of classes.
</p>
<p>SIEI is a 'Diversity metric'. The metric is widely used in biodiversity and ecology.
It is the ratio between the actual Simpson's diversity  index and the theoretical maximum
Simpson's diversity index.
</p>


<h4>Units</h4>

<p>None</p>



<h4>Range</h4>

<p>0 &lt; SIEI &lt;= 1</p>



<h4>Behaviour</h4>

<p>Equals SIEI = 0 when only one patch is present and approaches
SIEI = 1 when the number of class types increases while the proportions are
equally distributed</p>



<h3>Value</h3>

<p>tibble
</p>


<h3>References</h3>

<p>McGarigal K., SA Cushman, and E Ene. 2023. FRAGSTATS v4: Spatial Pattern Analysis
Program for Categorical Maps. Computer software program produced by the authors;
available at the following web site: https://www.fragstats.org
</p>
<p>Simpson, E. H. 1949. Measurement of diversity. Nature 163:688
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lsm_c_pland">lsm_c_pland</a></code>,
<code><a href="#topic+lsm_l_pr">lsm_l_pr</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>landscape &lt;- terra::rast(landscapemetrics::landscape)
lsm_l_siei(landscape)

</code></pre>

<hr>
<h2 id='lsm_l_split'>SPLIT (landscape level)</h2><span id='topic+lsm_l_split'></span>

<h3>Description</h3>

<p>Splitting index (Aggregation metric)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lsm_l_split(landscape, directions = 8)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lsm_l_split_+3A_landscape">landscape</code></td>
<td>
<p>A categorical raster object: SpatRaster; Raster* Layer, Stack, Brick; stars or a list of SpatRasters.</p>
</td></tr>
<tr><td><code id="lsm_l_split_+3A_directions">directions</code></td>
<td>
<p>The number of directions in which patches should be
connected: 4 (rook's case) or 8 (queen's case).</p>
</td></tr>
</table>


<h3>Details</h3>

<p style="text-align: center;"><code class="reqn">SSPLIT = \frac{A^2} {\sum \limits_{i = 1}^{m} \sum \limits_{j = 1}^{n} a_{ij}^2}</code>
</p>

<p>where <code class="reqn">a_{ij}</code> is the patch area in square meters and <code class="reqn">A</code> is the
total landscape area.
</p>
<p>SPLIT is an 'Aggregation metric'. It describes the number of patches if all patches the
landscape would be divided into equally sized patches.
</p>
<p>Because the metric is based on distances or areas please make sure your data
is valid using <code><a href="#topic+check_landscape">check_landscape</a></code>.
</p>


<h4>Units</h4>

<p>None</p>



<h4>Range</h4>

<p>1 &lt;= SPLIT &lt;= Number of cells squared</p>



<h4>Behaviour</h4>

<p>Equals SPLIT = 1 if only one patch is present. Increases as
the number of patches increases and is limited if all cells are a patch</p>



<h3>Value</h3>

<p>tibble
</p>


<h3>References</h3>

<p>McGarigal K., SA Cushman, and E Ene. 2023. FRAGSTATS v4: Spatial Pattern Analysis
Program for Categorical Maps. Computer software program produced by the authors;
available at the following web site: https://www.fragstats.org
</p>
<p>Jaeger, J. A. 2000. Landscape division, splitting index, and effective mesh
size: new measures of landscape fragmentation.
Landscape ecology, 15(2), 115-130.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lsm_p_area">lsm_p_area</a></code>,
<code><a href="#topic+lsm_l_ta">lsm_l_ta</a></code>, <br />
<code><a href="#topic+lsm_c_split">lsm_c_split</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>landscape &lt;- terra::rast(landscapemetrics::landscape)
lsm_l_split(landscape)

</code></pre>

<hr>
<h2 id='lsm_l_ta'>TA (landscape level)</h2><span id='topic+lsm_l_ta'></span>

<h3>Description</h3>

<p>Total area (Area and edge metric)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lsm_l_ta(landscape, directions = 8)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lsm_l_ta_+3A_landscape">landscape</code></td>
<td>
<p>A categorical raster object: SpatRaster; Raster* Layer, Stack, Brick; stars or a list of SpatRasters.</p>
</td></tr>
<tr><td><code id="lsm_l_ta_+3A_directions">directions</code></td>
<td>
<p>The number of directions in which patches should be
connected: 4 (rook's case) or 8 (queen's case).</p>
</td></tr>
</table>


<h3>Details</h3>

<p style="text-align: center;"><code class="reqn">CA = sum(AREA[patch_{ij}])</code>
</p>

<p>where <code class="reqn">AREA[patch_{ij}]</code> is the area of each patch in hectares.
</p>
<p>TA is an 'Area and edge metric'. The total (class) area sums the area of all patches
in the landscape. It is the area of the observation area.
</p>
<p>Because the metric is based on distances or areas please make sure your data
is valid using <code><a href="#topic+check_landscape">check_landscape</a></code>.
</p>


<h4>Units</h4>

<p>Hectares</p>



<h4>Range</h4>

<p>TA &gt; 0</p>



<h4>Behaviour</h4>

<p>Approaches TA &gt; 0 if the landscape is small and increases,
without limit, as the size of the landscape increases.</p>



<h3>Value</h3>

<p>tibble
</p>


<h3>References</h3>

<p>McGarigal K., SA Cushman, and E Ene. 2023. FRAGSTATS v4: Spatial Pattern Analysis
Program for Categorical Maps. Computer software program produced by the authors;
available at the following web site: https://www.fragstats.org
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lsm_p_area">lsm_p_area</a></code>,
<code><a href="base.html#topic+sum">sum</a></code>, <br />
<code><a href="#topic+lsm_c_ca">lsm_c_ca</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>landscape &lt;- terra::rast(landscapemetrics::landscape)
lsm_l_ta(landscape)

</code></pre>

<hr>
<h2 id='lsm_l_tca'>TCA (landscape level)</h2><span id='topic+lsm_l_tca'></span>

<h3>Description</h3>

<p>Total core area (Core area metric)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lsm_l_tca(landscape, directions = 8, consider_boundary = FALSE, edge_depth = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lsm_l_tca_+3A_landscape">landscape</code></td>
<td>
<p>A categorical raster object: SpatRaster; Raster* Layer, Stack, Brick; stars or a list of SpatRasters.</p>
</td></tr>
<tr><td><code id="lsm_l_tca_+3A_directions">directions</code></td>
<td>
<p>The number of directions in which patches should be
connected: 4 (rook's case) or 8 (queen's case).</p>
</td></tr>
<tr><td><code id="lsm_l_tca_+3A_consider_boundary">consider_boundary</code></td>
<td>
<p>Logical if cells that only neighbour the landscape
boundary should be considered as core</p>
</td></tr>
<tr><td><code id="lsm_l_tca_+3A_edge_depth">edge_depth</code></td>
<td>
<p>Distance (in cells) a cell has the be away from the patch
edge to be considered as core cell</p>
</td></tr>
</table>


<h3>Details</h3>

<p style="text-align: center;"><code class="reqn">TCA = \sum \limits_{j = 1}^{n} a_{ij}^{core} * (\frac{1} {10000})</code>
</p>

<p>where here <code class="reqn">a_{ij}^{core}</code> is the core area in square meters.
</p>
<p>TCA is a 'Core area metric' and equals the sum of core areas of all patches in the
landscape. A cell is defined as core area if the cell has no neighbour with a different
value than itself (rook's case). In other words, the core area of a patch is all area that
is not an edge. It characterises patch areas and shapes of all patches in the landscape
simultaneously (more core area when the patch is large and the shape is rather compact,
i.e. a square). Additionally, TCA is a measure for the configuration of the landscape,
because the sum of edges increase as patches are less aggregated.
</p>
<p>Because the metric is based on distances or areas please make sure your data
is valid using <code><a href="#topic+check_landscape">check_landscape</a></code>.
</p>


<h4>Units</h4>

<p>Hectares</p>



<h4>Range</h4>

<p>TCA &gt;= 0</p>



<h4>Behaviour</h4>

<p>Increases, without limit, as patch areas increase
and patch shapes simplify. TCA = 0 when every cell in every patch is an edge.</p>



<h3>Value</h3>

<p>tibble
</p>


<h3>References</h3>

<p>McGarigal K., SA Cushman, and E Ene. 2023. FRAGSTATS v4: Spatial Pattern Analysis
Program for Categorical Maps. Computer software program produced by the authors;
available at the following web site: https://www.fragstats.org
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lsm_p_core">lsm_p_core</a></code>,
<code><a href="#topic+lsm_c_tca">lsm_c_tca</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>landscape &lt;- terra::rast(landscapemetrics::landscape)
lsm_l_tca(landscape)

</code></pre>

<hr>
<h2 id='lsm_l_te'>TE (landscape level)</h2><span id='topic+lsm_l_te'></span>

<h3>Description</h3>

<p>Total edge (Area and Edge metric)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lsm_l_te(landscape, count_boundary = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lsm_l_te_+3A_landscape">landscape</code></td>
<td>
<p>A categorical raster object: SpatRaster; Raster* Layer, Stack, Brick; stars or a list of SpatRasters.</p>
</td></tr>
<tr><td><code id="lsm_l_te_+3A_count_boundary">count_boundary</code></td>
<td>
<p>Include landscape boundary in edge length</p>
</td></tr>
</table>


<h3>Details</h3>

<p style="text-align: center;"><code class="reqn">TE = \sum \limits_{k = 1}^{m} e_{ik}</code>
</p>

<p>where <code class="reqn">e_{ik}</code> is the edge lengths in meters.
TE is an 'Area and edge metric'. Total edge includes all edges. It measures the
configuration of the landscape because a highly fragmented landscape will have many
edges. However, total edge is an absolute measure, making comparisons among landscapes
with different total areas difficult. If <code>count_boundary = TRUE</code> also edges to the
landscape boundary are included.
</p>
<p>Because the metric is based on distances or areas please make sure your data
is valid using <code><a href="#topic+check_landscape">check_landscape</a></code>.
</p>


<h4>Units</h4>

<p>Meters</p>



<h4>Range</h4>

<p>TE &gt;= 0</p>



<h4>Behaviour</h4>

<p>Equals TE = 0 if all cells are edge cells. Increases, without limit,
as landscape becomes more fragmented</p>



<h3>Value</h3>

<p>tibble
</p>


<h3>References</h3>

<p>McGarigal K., SA Cushman, and E Ene. 2023. FRAGSTATS v4: Spatial Pattern Analysis
Program for Categorical Maps. Computer software program produced by the authors;
available at the following web site: https://www.fragstats.org
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lsm_p_perim">lsm_p_perim</a></code>
<code><a href="#topic+lsm_l_te">lsm_l_te</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>landscape &lt;- terra::rast(landscapemetrics::landscape)
lsm_l_te(landscape)

</code></pre>

<hr>
<h2 id='lsm_p_area'>AREA (patch level)</h2><span id='topic+lsm_p_area'></span>

<h3>Description</h3>

<p>Patch area (Area and edge metric)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lsm_p_area(landscape, directions = 8)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lsm_p_area_+3A_landscape">landscape</code></td>
<td>
<p>A categorical raster object: SpatRaster; Raster* Layer, Stack, Brick; stars or a list of SpatRasters.</p>
</td></tr>
<tr><td><code id="lsm_p_area_+3A_directions">directions</code></td>
<td>
<p>The number of directions in which patches should be
connected: 4 (rook's case) or 8 (queen's case).</p>
</td></tr>
</table>


<h3>Details</h3>

<p style="text-align: center;"><code class="reqn">AREA = a_{ij} * (\frac{1} {10000})</code>
</p>

<p>where <code class="reqn">a_{ij}</code> is the area in square meters.
</p>
<p>AREA is an 'Area and edge metric' and equals the area of each patch in hectares.
The lower limit of AREA is limited by the resolution of the input raster,
i.e. AREA can't be smaller than the resolution squared (in hectares). It is one of
the most basic, but also most important metrics, to characterise a landscape. The
metric is the simplest measure of composition.
</p>
<p>Because the metric is based on distances or areas please make sure your data
is valid using <code><a href="#topic+check_landscape">check_landscape</a></code>.
</p>


<h4>Units</h4>

<p>Hectares</p>



<h4>Range</h4>

<p>AREA &gt; 0</p>



<h4>Behaviour</h4>

<p>Increases, without limit, as the patch size increases.</p>



<h3>Value</h3>

<p>tibble
</p>


<h3>References</h3>

<p>McGarigal K., SA Cushman, and E Ene. 2023. FRAGSTATS v4: Spatial Pattern Analysis
Program for Categorical Maps. Computer software program produced by the authors;
available at the following web site: https://www.fragstats.org
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lsm_c_area_mn">lsm_c_area_mn</a></code>,
<code><a href="#topic+lsm_c_area_sd">lsm_c_area_sd</a></code>,
<code><a href="#topic+lsm_c_area_cv">lsm_c_area_cv</a></code>,
<code><a href="#topic+lsm_c_ca">lsm_c_ca</a></code>, <br />
<code><a href="#topic+lsm_l_area_mn">lsm_l_area_mn</a></code>,
<code><a href="#topic+lsm_l_area_sd">lsm_l_area_sd</a></code>,
<code><a href="#topic+lsm_l_area_cv">lsm_l_area_cv</a></code>,
<code><a href="#topic+lsm_l_ta">lsm_l_ta</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>landscape &lt;- terra::rast(landscapemetrics::landscape)
lsm_p_area(landscape)

</code></pre>

<hr>
<h2 id='lsm_p_cai'>CAI (patch level)</h2><span id='topic+lsm_p_cai'></span>

<h3>Description</h3>

<p>Core area index (Core area metric)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lsm_p_cai(landscape, directions = 8, consider_boundary = FALSE, edge_depth = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lsm_p_cai_+3A_landscape">landscape</code></td>
<td>
<p>A categorical raster object: SpatRaster; Raster* Layer, Stack, Brick; stars or a list of SpatRasters.</p>
</td></tr>
<tr><td><code id="lsm_p_cai_+3A_directions">directions</code></td>
<td>
<p>The number of directions in which patches should be
connected: 4 (rook's case) or 8 (queen's case).</p>
</td></tr>
<tr><td><code id="lsm_p_cai_+3A_consider_boundary">consider_boundary</code></td>
<td>
<p>Logical if cells that only neighbour the landscape
boundary should be considered as core</p>
</td></tr>
<tr><td><code id="lsm_p_cai_+3A_edge_depth">edge_depth</code></td>
<td>
<p>Distance (in cells) a cell has the be away from the patch
edge to be considered as core cell</p>
</td></tr>
</table>


<h3>Details</h3>

<p style="text-align: center;"><code class="reqn">CAI = (\frac{a_{ij}^{core}} {a_{ij}}) * 100</code>
</p>

<p>where <code class="reqn">a_{ij}^{core}</code> is the core area in square meters and <code class="reqn">a_{ij}</code>
is the area in square meters.
</p>
<p>CAI is a 'Core area metric'. It equals the percentage of a patch that is core area.
A cell is defined as core area if the cell has no neighbour with a different value
than itself (rook's case). It describes patch area and shape simultaneously (more core area
when the patch is large and the shape is rather compact, i.e. a square). Because the index is
relative, it is comparable among patches with different area.
</p>
<p>Because the metric is based on distances or areas please make sure your data
is valid using <code><a href="#topic+check_landscape">check_landscape</a></code>.
</p>


<h4>Units</h4>

<p>Percent</p>



<h4>Range</h4>

<p>0 &lt;= CAI &lt;= 100</p>



<h4>Behaviour</h4>

<p>CAI = 0 when the patch has no core area and
approaches CAI = 100 with increasing percentage of core area within a patch.</p>



<h3>Value</h3>

<p>tibble
</p>


<h3>References</h3>

<p>McGarigal K., SA Cushman, and E Ene. 2023. FRAGSTATS v4: Spatial Pattern Analysis
Program for Categorical Maps. Computer software program produced by the authors;
available at the following web site: https://www.fragstats.org
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lsm_p_core">lsm_p_core</a></code>,
<code><a href="#topic+lsm_p_area">lsm_p_area</a></code>, <br />
<code><a href="#topic+lsm_c_cai_mn">lsm_c_cai_mn</a></code>,
<code><a href="#topic+lsm_c_cai_sd">lsm_c_cai_sd</a></code>,
<code><a href="#topic+lsm_c_cai_cv">lsm_c_cai_cv</a></code>,
<code><a href="#topic+lsm_c_cpland">lsm_c_cpland</a></code>, <br />
<code><a href="#topic+lsm_l_cai_mn">lsm_l_cai_mn</a></code>,
<code><a href="#topic+lsm_l_cai_sd">lsm_l_cai_sd</a></code>,
<code><a href="#topic+lsm_l_cai_cv">lsm_l_cai_cv</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>landscape &lt;- terra::rast(landscapemetrics::landscape)
lsm_p_cai(landscape)

</code></pre>

<hr>
<h2 id='lsm_p_circle'>CIRCLE (patch level)</h2><span id='topic+lsm_p_circle'></span>

<h3>Description</h3>

<p>Related Circumscribing Circle (Shape metric)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lsm_p_circle(landscape, directions = 8)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lsm_p_circle_+3A_landscape">landscape</code></td>
<td>
<p>A categorical raster object: SpatRaster; Raster* Layer, Stack, Brick; stars or a list of SpatRasters.</p>
</td></tr>
<tr><td><code id="lsm_p_circle_+3A_directions">directions</code></td>
<td>
<p>The number of directions in which patches should be
connected: 4 (rook's case) or 8 (queen's case).</p>
</td></tr>
</table>


<h3>Details</h3>

<p style="text-align: center;"><code class="reqn">CIRCLE = 1 - (\frac{a_{ij}} {a_{ij}^{circle}})</code>
</p>

<p>where <code class="reqn">a_{ij}</code> is the area in square meters and <code class="reqn">a_{ij}^{circle}</code> the area of
the smallest circumscribing circle.
</p>
<p>CIRCLE is a 'Shape metric'. The metric is the ratio between the patch area and the smallest
circumscribing circle of the patch. The diameter of the smallest circumscribing circle is
the 'diameter' of the patch connecting the opposing corner points of the two cells
that are the furthest away from each other. The metric characterises the compactness
of the patch and is comparable among patches with different area.
</p>
<p>Because the metric is based on distances or areas please make sure your data
is valid using <code><a href="#topic+check_landscape">check_landscape</a></code>.
</p>


<h4>Units</h4>

<p>None</p>



<h4>Range</h4>

<p>0 &lt;= CIRCLE &lt; 1</p>



<h4>Behaviour</h4>

<p>CIRCLE = 0 for a circular patch and approaches CIRCLE = 1 for
a linear patch.</p>



<h3>Value</h3>

<p>tibble
</p>


<h3>References</h3>

<p>McGarigal K., SA Cushman, and E Ene. 2023. FRAGSTATS v4: Spatial Pattern Analysis
Program for Categorical Maps. Computer software program produced by the authors;
available at the following web site: https://www.fragstats.org
</p>
<p>Baker, W. L., and Y. Cai. 1992. The r.le programs for multiscale analysis of
landscape structure using the GRASS geographical information system.
Landscape Ecology 7: 291-302.
</p>
<p>Based on C++ code from Project Nayuki (https://www.nayuki.io/page/smallest-enclosing-circle).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lsm_p_area">lsm_p_area</a></code>, <br />
<code><a href="#topic+lsm_c_circle_mn">lsm_c_circle_mn</a></code>,
<code><a href="#topic+lsm_c_circle_sd">lsm_c_circle_sd</a></code>,
<code><a href="#topic+lsm_c_circle_cv">lsm_c_circle_cv</a></code>, <br />
<code><a href="#topic+lsm_l_circle_mn">lsm_l_circle_mn</a></code>,
<code><a href="#topic+lsm_l_circle_sd">lsm_l_circle_sd</a></code>,
<code><a href="#topic+lsm_l_circle_cv">lsm_l_circle_cv</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>landscape &lt;- terra::rast(landscapemetrics::landscape)
lsm_p_circle(landscape)

</code></pre>

<hr>
<h2 id='lsm_p_contig'>CONTIG (patch level)</h2><span id='topic+lsm_p_contig'></span>

<h3>Description</h3>

<p>Contiguity index (Shape metric)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lsm_p_contig(landscape, directions = 8)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lsm_p_contig_+3A_landscape">landscape</code></td>
<td>
<p>A categorical raster object: SpatRaster; Raster* Layer, Stack, Brick; stars or a list of SpatRasters.</p>
</td></tr>
<tr><td><code id="lsm_p_contig_+3A_directions">directions</code></td>
<td>
<p>The number of directions in which patches should be
connected: 4 (rook's case) or 8 (queen's case).</p>
</td></tr>
</table>


<h3>Details</h3>

<p style="text-align: center;"><code class="reqn">CONTIG =  \frac{\Bigg[\frac{\sum\limits_{r=1}^z  c_{ijr}}{a_{ij}}\Bigg] - 1 }{ v - 1} </code>
</p>

<p>where <code class="reqn">c_{ijr}</code> is the contiguity value for pixel r in patch ij,
<code class="reqn">a_{ij}</code> the area of the respective patch (number of cells) and <code class="reqn">v</code> is
the size of the filter matrix (13 in this case).
</p>
<p>CONTIG is a 'Shape metric'. It asses the spatial connectedness (contiguity) of
cells in patches. CONTIG coerces patch values to a value of 1 and the background
to NA. A nine cell focal filter matrix:
</p>
<div class="sourceCode"><pre>filter_matrix &lt;- matrix(c(1, 2, 1,
                          2, 1, 2,
                          1, 2, 1), 3, 3, byrow = T)
</pre></div>
<p>... is then used to weight orthogonally contiguous pixels more heavily than
diagonally contiguous pixels. Therefore, larger and more connections between
patch cells in the rookie case result in larger contiguity index values.
</p>


<h4>Units</h4>

<p>None</p>



<h4>Range</h4>

<p>0 &gt;= CONTIG &lt;= 1</p>



<h4>Behaviour</h4>

<p>Equals 0 for one-pixel patches and increases to a limit
of 1 (fully connected patch).</p>



<h3>Value</h3>

<p>tibble
</p>


<h3>References</h3>

<p>McGarigal K., SA Cushman, and E Ene. 2023. FRAGSTATS v4: Spatial Pattern Analysis
Program for Categorical Maps. Computer software program produced by the authors;
available at the following web site: https://www.fragstats.org
</p>
<p>LaGro, J. 1991. Assessing patch shape in landscape mosaics.
Photogrammetric Engineering and Remote Sensing, 57(3), 285-293
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lsm_c_contig_mn">lsm_c_contig_mn</a></code>,
<code><a href="#topic+lsm_c_contig_sd">lsm_c_contig_sd</a></code>,
<code><a href="#topic+lsm_c_contig_cv">lsm_c_contig_cv</a></code>, <br />
<code><a href="#topic+lsm_l_contig_mn">lsm_l_contig_mn</a></code>,
<code><a href="#topic+lsm_l_contig_sd">lsm_l_contig_sd</a></code>,
<code><a href="#topic+lsm_l_contig_cv">lsm_l_contig_cv</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>landscape &lt;- terra::rast(landscapemetrics::landscape)
lsm_p_contig(landscape)

</code></pre>

<hr>
<h2 id='lsm_p_core'>CORE (patch level)</h2><span id='topic+lsm_p_core'></span>

<h3>Description</h3>

<p>Core area (Core area metric)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lsm_p_core(
  landscape,
  directions = 8,
  consider_boundary = FALSE,
  edge_depth = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lsm_p_core_+3A_landscape">landscape</code></td>
<td>
<p>A categorical raster object: SpatRaster; Raster* Layer, Stack, Brick; stars or a list of SpatRasters.</p>
</td></tr>
<tr><td><code id="lsm_p_core_+3A_directions">directions</code></td>
<td>
<p>The number of directions in which patches should be
connected: 4 (rook's case) or 8 (queen's case).</p>
</td></tr>
<tr><td><code id="lsm_p_core_+3A_consider_boundary">consider_boundary</code></td>
<td>
<p>Logical if cells that only neighbour the landscape
boundary should be considered as core</p>
</td></tr>
<tr><td><code id="lsm_p_core_+3A_edge_depth">edge_depth</code></td>
<td>
<p>Distance (in cells) a cell has the be away from the patch
edge to be considered as core cell</p>
</td></tr>
</table>


<h3>Details</h3>

<p style="text-align: center;"><code class="reqn">CORE = a_{ij}^{core}</code>
</p>

<p>where <code class="reqn">a_{ij}^{core}</code> is the core area in square meters
</p>
<p>CORE is a 'Core area metric' and equals the area within a patch that is not
on the edge of it. A cell is defined as core area if the cell has no
neighbour with a different value than itself (rook's case). It describes patch area
and shape simultaneously (more core area when the patch is large and the shape is
rather compact, i.e. a square).
</p>
<p>Because the metric is based on distances or areas please make sure your data
is valid using <code><a href="#topic+check_landscape">check_landscape</a></code>.
</p>


<h4>Units</h4>

<p>Hectares</p>



<h4>Range</h4>

<p>CORE &gt;= 0</p>



<h4>Behaviour</h4>

<p>Increases, without limit, as the patch area increases
and the patch shape simplifies (more core area). CORE = 0 when every cell in
the patch is an edge.</p>



<h3>Value</h3>

<p>tibble
</p>


<h3>References</h3>

<p>McGarigal K., SA Cushman, and E Ene. 2023. FRAGSTATS v4: Spatial Pattern Analysis
Program for Categorical Maps. Computer software program produced by the authors;
available at the following web site: https://www.fragstats.org
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lsm_c_core_mn">lsm_c_core_mn</a></code>,
<code><a href="#topic+lsm_c_core_sd">lsm_c_core_sd</a></code>,
<code><a href="#topic+lsm_c_core_cv">lsm_c_core_cv</a></code>,
<code><a href="#topic+lsm_c_tca">lsm_c_tca</a></code>, <br />
<code><a href="#topic+lsm_l_core_mn">lsm_l_core_mn</a></code>,
<code><a href="#topic+lsm_l_core_sd">lsm_l_core_sd</a></code>,
<code><a href="#topic+lsm_l_core_cv">lsm_l_core_cv</a></code>,
<code><a href="#topic+lsm_l_tca">lsm_l_tca</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>landscape &lt;- terra::rast(landscapemetrics::landscape)
lsm_p_core(landscape)

</code></pre>

<hr>
<h2 id='lsm_p_enn'>ENN (patch level)</h2><span id='topic+lsm_p_enn'></span>

<h3>Description</h3>

<p>Euclidean Nearest-Neighbor Distance (Aggregation metric)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lsm_p_enn(landscape, directions = 8, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lsm_p_enn_+3A_landscape">landscape</code></td>
<td>
<p>A categorical raster object: SpatRaster; Raster* Layer, Stack, Brick; stars or a list of SpatRasters.</p>
</td></tr>
<tr><td><code id="lsm_p_enn_+3A_directions">directions</code></td>
<td>
<p>The number of directions in which patches should be
connected: 4 (rook's case) or 8 (queen's case).</p>
</td></tr>
<tr><td><code id="lsm_p_enn_+3A_verbose">verbose</code></td>
<td>
<p>Print warning message if not sufficient patches are present</p>
</td></tr>
</table>


<h3>Details</h3>

<p style="text-align: center;"><code class="reqn">ENN = h_{ij}</code>
</p>

<p>where <code class="reqn">h_{ij}</code> is the distance to the nearest neighbouring patch of
the same class i in meters
</p>
<p>ENN is an 'Aggregation metric'. The distance to the nearest neighbouring patch of
the same class i. The distance is measured from edge-to-edge. The range is limited by the
cell resolution on the lower limit and the landscape extent on the upper limit. The metric
is a simple way to describe patch isolation.
</p>
<p>Because the metric is based on distances or areas please make sure your data
is valid using <code><a href="#topic+check_landscape">check_landscape</a></code>.
</p>


<h4>Units</h4>

<p>Meters</p>



<h4>Range</h4>

<p>ENN &gt; 0</p>



<h4>Behaviour</h4>

<p>Approaches ENN = 0 as the distance to the nearest neighbour
decreases, i.e. patches of the same class i are more aggregated. Increases, without limit,
as the distance between neighbouring patches of the same class i increases, i.e. patches are
more isolated.</p>



<h3>Value</h3>

<p>tibble
</p>


<h3>References</h3>

<p>McGarigal K., SA Cushman, and E Ene. 2023. FRAGSTATS v4: Spatial Pattern Analysis
Program for Categorical Maps. Computer software program produced by the authors;
available at the following web site: https://www.fragstats.org
</p>
<p>McGarigal, K., and McComb, W. C. (1995). Relationships between landscape
structure and breeding birds in the Oregon Coast Range.
Ecological monographs, 65(3), 235-260.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lsm_c_enn_mn">lsm_c_enn_mn</a></code>,
<code><a href="#topic+lsm_c_enn_sd">lsm_c_enn_sd</a></code>,
<code><a href="#topic+lsm_c_enn_cv">lsm_c_enn_cv</a></code>, <br />
<code><a href="#topic+lsm_l_enn_mn">lsm_l_enn_mn</a></code>,
<code><a href="#topic+lsm_l_enn_sd">lsm_l_enn_sd</a></code>,
<code><a href="#topic+lsm_l_enn_cv">lsm_l_enn_cv</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>landscape &lt;- terra::rast(landscapemetrics::landscape)
lsm_p_enn(landscape)

</code></pre>

<hr>
<h2 id='lsm_p_frac'>FRAC (patch level)</h2><span id='topic+lsm_p_frac'></span>

<h3>Description</h3>

<p>Fractal dimension index (Shape metric)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lsm_p_frac(landscape, directions = 8)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lsm_p_frac_+3A_landscape">landscape</code></td>
<td>
<p>A categorical raster object: SpatRaster; Raster* Layer, Stack, Brick; stars or a list of SpatRasters.</p>
</td></tr>
<tr><td><code id="lsm_p_frac_+3A_directions">directions</code></td>
<td>
<p>The number of directions in which patches should be
connected: 4 (rook's case) or 8 (queen's case).</p>
</td></tr>
</table>


<h3>Details</h3>

<p style="text-align: center;"><code class="reqn">FRAC = \frac{2 * \ln * (0.25 * p_{ij})} {\ln a_{ij}}</code>
</p>

<p>where <code class="reqn">p_{ij}</code> is the perimeter in meters and <code class="reqn">a_{ij}</code> is the
area in square meters
</p>
<p>FRAC is a 'Shape metric'. The index is based on the patch perimeter and
the patch area and describes the patch complexity. Because it is standardized,
it is scale independent, meaning that increasing the patch size while not changing the
patch form will not change the ratio.
</p>
<p>Because the metric is based on distances or areas please make sure your data
is valid using <code><a href="#topic+check_landscape">check_landscape</a></code>.
</p>


<h4>Units</h4>

<p>None</p>



<h4>Range</h4>

<p>1 &lt;= FRAC &lt;= 2 </p>



<h4>Behaviour</h4>

<p>Approaches FRAC = 1 for a squared patch shape form and FRAC = 2
for a irregular patch shape.</p>



<h3>Value</h3>

<p>tibble
</p>


<h3>References</h3>

<p>McGarigal K., SA Cushman, and E Ene. 2023. FRAGSTATS v4: Spatial Pattern Analysis
Program for Categorical Maps. Computer software program produced by the authors;
available at the following web site: https://www.fragstats.org
</p>
<p>Mandelbrot, B. B. 1977. Fractals: Form, Chance, and Dimension.
San Francisco. W. H. Freeman and Company.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lsm_p_area">lsm_p_area</a></code>,
<code><a href="#topic+lsm_p_perim">lsm_p_perim</a></code>, <br />
<code><a href="#topic+lsm_c_frac_mn">lsm_c_frac_mn</a></code>,
<code><a href="#topic+lsm_c_frac_sd">lsm_c_frac_sd</a></code>,
<code><a href="#topic+lsm_c_frac_cv">lsm_c_frac_cv</a></code>, <br />
<code><a href="#topic+lsm_l_frac_mn">lsm_l_frac_mn</a></code>,
<code><a href="#topic+lsm_l_frac_sd">lsm_l_frac_sd</a></code>,
<code><a href="#topic+lsm_l_frac_cv">lsm_l_frac_cv</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>landscape &lt;- terra::rast(landscapemetrics::landscape)
lsm_p_frac(landscape)

</code></pre>

<hr>
<h2 id='lsm_p_gyrate'>GYRATE (patch level)</h2><span id='topic+lsm_p_gyrate'></span>

<h3>Description</h3>

<p>Radius of Gyration (Area and edge metric)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lsm_p_gyrate(landscape, directions = 8, cell_center = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lsm_p_gyrate_+3A_landscape">landscape</code></td>
<td>
<p>A categorical raster object: SpatRaster; Raster* Layer, Stack, Brick; stars or a list of SpatRasters.</p>
</td></tr>
<tr><td><code id="lsm_p_gyrate_+3A_directions">directions</code></td>
<td>
<p>The number of directions in which patches should be
connected: 4 (rook's case) or 8 (queen's case).</p>
</td></tr>
<tr><td><code id="lsm_p_gyrate_+3A_cell_center">cell_center</code></td>
<td>
<p>If true, the coordinates of the centroid are forced to be
a cell center within the patch.</p>
</td></tr>
</table>


<h3>Details</h3>

<p style="text-align: center;"><code class="reqn">GYRATE = \sum \limits_{r = 1}^{z} \frac{h_{ijr}} {z}</code>
</p>

<p>where <code class="reqn">h_{ijr}</code> is the distance from each cell to the centroid of the
patch and <code class="reqn">z</code> is the number of cells.
</p>
<p>GYRATE is an 'Area and edge metric'. The distance from each cell to the
patch centroid is based on cell center to centroid distances. The metric
characterises both the patch area and compactness.
</p>
<p>If <code>cell_center = TRUE</code> some patches might have several possible cell-center
centroids. In this case, the gyrate index is based on the mean distance of all
cells to all possible cell-center centroids.
</p>
<p>Because the metric is based on distances or areas please make sure your data
is valid using <code><a href="#topic+check_landscape">check_landscape</a></code>.
</p>


<h4>Units</h4>

<p>Meters</p>



<h4>Range</h4>

<p>GYRATE &gt;= 0</p>



<h4>Behaviour</h4>

<p>Approaches GYRATE = 0 if patch is a single cell.
Increases, without limit, when only one patch is present.</p>



<h3>Value</h3>

<p>tibble
</p>


<h3>References</h3>

<p>McGarigal K., SA Cushman, and E Ene. 2023. FRAGSTATS v4: Spatial Pattern Analysis
Program for Categorical Maps. Computer software program produced by the authors;
available at the following web site: https://www.fragstats.org
</p>
<p>Keitt, T. H., Urban, D. L., &amp; Milne, B. T. 1997. Detecting critical scales
in fragmented landscapes. Conservation ecology, 1(1).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lsm_c_gyrate_mn">lsm_c_gyrate_mn</a></code>,
<code><a href="#topic+lsm_c_gyrate_sd">lsm_c_gyrate_sd</a></code>,
<code><a href="#topic+lsm_c_gyrate_cv">lsm_c_gyrate_cv</a></code>, <br />
<code><a href="#topic+lsm_l_gyrate_mn">lsm_l_gyrate_mn</a></code>,
<code><a href="#topic+lsm_l_gyrate_sd">lsm_l_gyrate_sd</a></code>,
<code><a href="#topic+lsm_l_gyrate_cv">lsm_l_gyrate_cv</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>landscape &lt;- terra::rast(landscapemetrics::landscape)
lsm_p_gyrate(landscape)

</code></pre>

<hr>
<h2 id='lsm_p_ncore'>NCORE (patch level)</h2><span id='topic+lsm_p_ncore'></span>

<h3>Description</h3>

<p>Number of core areas (Core area metric)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lsm_p_ncore(
  landscape,
  directions = 8,
  consider_boundary = FALSE,
  edge_depth = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lsm_p_ncore_+3A_landscape">landscape</code></td>
<td>
<p>A categorical raster object: SpatRaster; Raster* Layer, Stack, Brick; stars or a list of SpatRasters.</p>
</td></tr>
<tr><td><code id="lsm_p_ncore_+3A_directions">directions</code></td>
<td>
<p>The number of directions in which patches should be
connected: 4 (rook's case) or 8 (queen's case).</p>
</td></tr>
<tr><td><code id="lsm_p_ncore_+3A_consider_boundary">consider_boundary</code></td>
<td>
<p>Logical if cells that only neighbour the landscape
boundary should be considered as core</p>
</td></tr>
<tr><td><code id="lsm_p_ncore_+3A_edge_depth">edge_depth</code></td>
<td>
<p>Distance (in cells) a cell has the be away from the patch
edge to be considered as core cell
</p>
<p>#' @details
</p>
<p style="text-align: center;"><code class="reqn">NCORE = n_{ij}^{core}</code>
</p>

<p>where <code class="reqn">n_{ij}^{core}</code> is the number of disjunct core areas.
</p>
<p>NCORE is a 'Core area metric'. A cell is defined as core if the cell has no
neighbour with a different value than itself (rook's case). The metric
counts the disjunct core areas, whereby a core area is a 'patch within the
patch' containing only core cells. It describes patch area and shape
simultaneously (more core area when the patch is large, however, the shape
must allow disjunct core areas). Thereby, a compact shape (e.g. a square)
will contain less disjunct core areas than a more irregular patch.
</p>


<h4>Units</h4>

<p>None</p>



<h4>Range</h4>

<p>NCORE &gt;= 0</p>



<h4>Behaviour</h4>

<p>NCORE = 0 when CORE = 0, i.e. every cell in patch is
edge. Increases, without limit, as core area increases and patch shape
allows disjunct core areas (i.e. patch shape becomes rather complex).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>tibble
</p>


<h3>References</h3>

<p>McGarigal K., SA Cushman, and E Ene. 2023. FRAGSTATS v4: Spatial Pattern Analysis
Program for Categorical Maps. Computer software program produced by the authors;
available at the following web site: https://www.fragstats.org
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lsm_c_dcore_mn">lsm_c_dcore_mn</a></code>,
<code><a href="#topic+lsm_c_dcore_sd">lsm_c_dcore_sd</a></code>,
<code><a href="#topic+lsm_c_dcore_cv">lsm_c_dcore_cv</a></code>,
<code><a href="#topic+lsm_c_ndca">lsm_c_ndca</a></code>, <br />
<code><a href="#topic+lsm_l_dcore_mn">lsm_l_dcore_mn</a></code>,
<code><a href="#topic+lsm_l_dcore_sd">lsm_l_dcore_sd</a></code>,
<code><a href="#topic+lsm_l_dcore_cv">lsm_l_dcore_cv</a></code>,
<code><a href="#topic+lsm_l_ndca">lsm_l_ndca</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>landscape &lt;- terra::rast(landscapemetrics::landscape)
lsm_p_ncore(landscape)

</code></pre>

<hr>
<h2 id='lsm_p_para'>PARA (patch level)</h2><span id='topic+lsm_p_para'></span>

<h3>Description</h3>

<p>Perimeter-Area ratio (Shape metric)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lsm_p_para(landscape, directions = 8)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lsm_p_para_+3A_landscape">landscape</code></td>
<td>
<p>A categorical raster object: SpatRaster; Raster* Layer, Stack, Brick; stars or a list of SpatRasters</p>
</td></tr>
<tr><td><code id="lsm_p_para_+3A_directions">directions</code></td>
<td>
<p>The number of directions in which patches should be
connected: 4 (rook's case) or 8 (queen's case).</p>
</td></tr>
</table>


<h3>Details</h3>

<p style="text-align: center;"><code class="reqn">PARA = \frac{p_{ij}} {a_{ij}}</code>
</p>

<p>where <code class="reqn">p_{ij}</code> is the perimeter in meters and <code class="reqn">a_{ij}</code> is the
area in square meters.
</p>
<p>PARA is a 'Shape metric'. It describes the patch complexity in a
straightforward way. However, because it is not standarised to a certain
shape (e.g. a square), it is not scale independent, meaning that increasing
the patch size while not changing the patch form will change the ratio.
</p>
<p>Because the metric is based on distances or areas please make sure your data
is valid using <code><a href="#topic+check_landscape">check_landscape</a></code>.
</p>


<h4>Units</h4>

<p>None</p>



<h4>Range</h4>

<p>PARA &gt; 0</p>



<h4>Behaviour</h4>

<p>Increases, without limit, as the shape complexity
increases.</p>



<h3>Value</h3>

<p>tibble
</p>


<h3>References</h3>

<p>McGarigal K., SA Cushman, and E Ene. 2023. FRAGSTATS v4: Spatial Pattern Analysis
Program for Categorical Maps. Computer software program produced by the authors;
available at the following web site: https://www.fragstats.org
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lsm_p_area">lsm_p_area</a></code>,
<code><a href="#topic+lsm_p_perim">lsm_p_perim</a></code>, <br />
<code><a href="#topic+lsm_c_para_mn">lsm_c_para_mn</a></code>,
<code><a href="#topic+lsm_c_para_sd">lsm_c_para_sd</a></code>,
<code><a href="#topic+lsm_c_para_cv">lsm_c_para_cv</a></code>, <br />
<code><a href="#topic+lsm_l_para_mn">lsm_l_para_mn</a></code>,
<code><a href="#topic+lsm_l_para_sd">lsm_l_para_sd</a></code>,
<code><a href="#topic+lsm_l_para_cv">lsm_l_para_cv</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>landscape &lt;- terra::rast(landscapemetrics::landscape)
lsm_p_para(landscape)

</code></pre>

<hr>
<h2 id='lsm_p_perim'>PERIM (patch level)</h2><span id='topic+lsm_p_perim'></span>

<h3>Description</h3>

<p>Perimeter (Area and edge metric)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lsm_p_perim(landscape, directions = 8)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lsm_p_perim_+3A_landscape">landscape</code></td>
<td>
<p>A categorical raster object: SpatRaster; Raster* Layer, Stack, Brick; stars or a list of SpatRasters.</p>
</td></tr>
<tr><td><code id="lsm_p_perim_+3A_directions">directions</code></td>
<td>
<p>The number of directions in which patches should be
connected: 4 (rook's case) or 8 (queen's case).</p>
</td></tr>
</table>


<h3>Details</h3>

<p style="text-align: center;"><code class="reqn">PERIM = p_{ij}</code>
</p>

<p>where <code class="reqn">p_{ij}</code> is the perimeter in meters.
</p>
<p>PERIM is an 'Area and edge metric'. It equals the perimeter of the patch
including also the edge to the landscape boundary. The metric describes
patch area (larger perimeter for larger patches), but also patch shape
(large perimeter for irregular shapes).
</p>
<p>Because the metric is based on distances or areas please make sure your data
is valid using <code><a href="#topic+check_landscape">check_landscape</a></code>.
</p>


<h4>Units</h4>

<p>Meters</p>



<h4>Range</h4>

<p>PERIM &gt; 0</p>



<h4>Behaviour</h4>

<p>Increases, without limit, as patch size and
complexity increases.</p>



<h3>Value</h3>

<p>tibble
</p>


<h3>References</h3>

<p>McGarigal K., SA Cushman, and E Ene. 2023. FRAGSTATS v4: Spatial Pattern Analysis
Program for Categorical Maps. Computer software program produced by the authors;
available at the following web site: https://www.fragstats.org
</p>


<h3>Examples</h3>

<pre><code class='language-R'>landscape &lt;- terra::rast(landscapemetrics::landscape)
lsm_p_perim(landscape)

</code></pre>

<hr>
<h2 id='lsm_p_shape'>SHAPE (patch level)</h2><span id='topic+lsm_p_shape'></span>

<h3>Description</h3>

<p>Shape index (Shape metric)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lsm_p_shape(landscape, directions = 8)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lsm_p_shape_+3A_landscape">landscape</code></td>
<td>
<p>A categorical raster object: SpatRaster; Raster* Layer, Stack, Brick; stars or a list of SpatRasters.</p>
</td></tr>
<tr><td><code id="lsm_p_shape_+3A_directions">directions</code></td>
<td>
<p>The number of directions in which patches should be
connected: 4 (rook's case) or 8 (queen's case).</p>
</td></tr>
</table>


<h3>Details</h3>

<p style="text-align: center;"><code class="reqn">SHAPE = \frac{0.25 * p_{ij}} {\sqrt a_{ij}}</code>
</p>

<p>where <code class="reqn">p_{ij}</code> is the perimeter (m) and <code class="reqn">a_{ij}</code> is the area (m2).
</p>
<p>SHAPE is a 'Shape metric'. It describes the ratio between the actual perimeter of
the patch and the square root of patch area and thus adjusting for a square standard.
Thus, it is a simple measure of shape complexity.
</p>
<p>Because the metric is based on distances or areas please make sure your data
is valid using <code><a href="#topic+check_landscape">check_landscape</a></code>.
</p>


<h4>Units</h4>

<p>None</p>



<h4>Range</h4>

<p>SHAPE &gt;= 1</p>



<h4>Behaviour</h4>

<p>Equals SHAPE = 1 for a squared patch and
increases, without limit, as the patch shape becomes more complex.</p>



<h3>Value</h3>

<p>tibble
</p>


<h3>References</h3>

<p>McGarigal K., SA Cushman, and E Ene. 2023. FRAGSTATS v4: Spatial Pattern Analysis
Program for Categorical Maps. Computer software program produced by the authors;
available at the following web site: https://www.fragstats.org
</p>
<p>Patton, D. R. 1975. A diversity index for quantifying habitat &quot;edge&quot;.
Wildl. Soc.Bull. 3:171-173.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lsm_p_perim">lsm_p_perim</a></code>,
<code><a href="#topic+lsm_p_area">lsm_p_area</a></code>, <br />
<code><a href="#topic+lsm_c_shape_mn">lsm_c_shape_mn</a></code>,
<code><a href="#topic+lsm_c_shape_sd">lsm_c_shape_sd</a></code>,
<code><a href="#topic+lsm_c_shape_cv">lsm_c_shape_cv</a></code>, <br />
<code><a href="#topic+lsm_l_shape_mn">lsm_l_shape_mn</a></code>,
<code><a href="#topic+lsm_l_shape_sd">lsm_l_shape_sd</a></code>,
<code><a href="#topic+lsm_l_shape_cv">lsm_l_shape_cv</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>landscape &lt;- terra::rast(landscapemetrics::landscape)
lsm_p_shape(landscape)

</code></pre>

<hr>
<h2 id='matrix_to_raster'>matrix_to_raster</h2><span id='topic+matrix_to_raster'></span>

<h3>Description</h3>

<p>Convert matrix to raster
</p>


<h3>Usage</h3>

<pre><code class='language-R'>matrix_to_raster(
  matrix,
  landscape = NULL,
  landscape_empty = FALSE,
  extent = NULL,
  resolution = NULL,
  crs = NULL,
  to_disk = getOption("to_disk", default = FALSE)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="matrix_to_raster_+3A_matrix">matrix</code></td>
<td>
<p>matrix with values.</p>
</td></tr>
<tr><td><code id="matrix_to_raster_+3A_landscape">landscape</code></td>
<td>
<p>SpatRaster</p>
</td></tr>
<tr><td><code id="matrix_to_raster_+3A_landscape_empty">landscape_empty</code></td>
<td>
<p>If true, SpatRaster is landscape_empty</p>
</td></tr>
<tr><td><code id="matrix_to_raster_+3A_extent">extent</code></td>
<td>
<p>Extent of SpatRaster</p>
</td></tr>
<tr><td><code id="matrix_to_raster_+3A_resolution">resolution</code></td>
<td>
<p>Resolution of SpatRaster</p>
</td></tr>
<tr><td><code id="matrix_to_raster_+3A_crs">crs</code></td>
<td>
<p>CRS of raster layer.</p>
</td></tr>
<tr><td><code id="matrix_to_raster_+3A_to_disk">to_disk</code></td>
<td>
<p>If TRUE raster will be saved to disk.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Converts <code>matrix</code> to a raster with same characteristics as <code>landscape</code>. Either
<code>landscape</code> or <code>extent</code>, <code>resolution</code> and <code>crs</code> must be specified.
</p>


<h3>Value</h3>

<p>raster
</p>


<h3>Examples</h3>

<pre><code class='language-R'>augusta_nlcd &lt;- terra::rast(landscapemetrics::augusta_nlcd)

test_matrix &lt;- terra::as.matrix(augusta_nlcd, wide = TRUE)
matrix_to_raster(matrix = test_matrix, landscape = augusta_nlcd)

</code></pre>

<hr>
<h2 id='options_landscapemetrics'>options_landscapemetrics</h2><span id='topic+options_landscapemetrics'></span>

<h3>Description</h3>

<p>Sets global options for landscapemetrics
</p>


<h3>Usage</h3>

<pre><code class='language-R'>options_landscapemetrics(to_disk = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="options_landscapemetrics_+3A_to_disk">to_disk</code></td>
<td>
<p>Logical argument, if FALSE results of get_patches are hold
in memory. If true, get_patches writes temporary files and hence, does not hold everything in memory.
Can be set with a global option, e.g. <code>options(to_disk = TRUE)</code>. See Details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Landscape metrics rely on the delineation of patches. Hence, <code>get_patches</code> is
heavily used in <strong>landscapemetrics</strong>. As raster can be quite big, the fact that
<code>get_patches</code> creates a copy of the raster for each class in a landscape becomes
a burden for computer memory. Hence, the argument <em>to_disk</em> allows to
store the results of the connected labeling algorithm on disk. Furthermore,
this option can be set globally, so that every function that internally uses
<code>get_patches</code> can make use of that.
</p>


<h3>Value</h3>

<p>Global option to be used internally in the package
</p>

<hr>
<h2 id='pad_raster'>pad_raster</h2><span id='topic+pad_raster'></span>

<h3>Description</h3>

<p>Adding padding to raster
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pad_raster(
  landscape,
  pad_raster_value = -999,
  pad_raster_cells = 1,
  global = FALSE,
  return_raster = TRUE,
  to_disk = getOption("to_disk", default = FALSE)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pad_raster_+3A_landscape">landscape</code></td>
<td>
<p>A categorical raster object: SpatRaster; Raster* Layer, Stack, Brick; stars or a list of SpatRasters.</p>
</td></tr>
<tr><td><code id="pad_raster_+3A_pad_raster_value">pad_raster_value</code></td>
<td>
<p>Value of cells added</p>
</td></tr>
<tr><td><code id="pad_raster_+3A_pad_raster_cells">pad_raster_cells</code></td>
<td>
<p>Number of rows and columns added</p>
</td></tr>
<tr><td><code id="pad_raster_+3A_global">global</code></td>
<td>
<p>If TRUE, NAs within the landscape are replace with the value; if FALSE only
padding around the raster is added.</p>
</td></tr>
<tr><td><code id="pad_raster_+3A_return_raster">return_raster</code></td>
<td>
<p>If false, matrix is returned</p>
</td></tr>
<tr><td><code id="pad_raster_+3A_to_disk">to_disk</code></td>
<td>
<p>Logical argument, if FALSE results of get_patches are hold
in memory. If true, pad_raster writes temporary files and hence, does not hold
everything in memory. Can be set with a global option, e.g. <code>option(to_disk = TRUE)</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Adds equally (in all four directions) additional cells around the raster
</p>


<h3>Value</h3>

<p>raster
</p>


<h3>Examples</h3>

<pre><code class='language-R'>landscape &lt;- terra::rast(landscapemetrics::landscape)
pad_raster(landscape, pad_raster_value = -1, pad_raster_cells = 2)

</code></pre>

<hr>
<h2 id='podlasie_ccilc'>Podlasie ESA CCI LC</h2><span id='topic+podlasie_ccilc'></span>

<h3>Description</h3>

<p>A real landscape of the Podlasie region in Poland from the ESA CCI Land
Cover
</p>


<h3>Usage</h3>

<pre><code class='language-R'>podlasie_ccilc
</code></pre>


<h3>Format</h3>

<p>A raster object.
</p>


<h3>Source</h3>

<p>http://maps.elie.ucl.ac.be/CCI/viewer/
</p>

<hr>
<h2 id='points_as_mat'>points_as_mat</h2><span id='topic+points_as_mat'></span>

<h3>Description</h3>

<p>Points as matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>points_as_mat(pts)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="points_as_mat_+3A_pts">pts</code></td>
<td>
<p>SpatVector points or sf object</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Converts sf points to coordinates matrix
</p>


<h3>Value</h3>

<p>matrix
</p>

<hr>
<h2 id='prepare_extras'>prepare_extras</h2><span id='topic+prepare_extras'></span>

<h3>Description</h3>

<p>Prepare an extras object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prepare_extras(
  metrics,
  landscape_mat,
  directions,
  neighbourhood,
  ordered,
  base,
  resolution
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prepare_extras_+3A_metrics">metrics</code></td>
<td>
<p>A vector with metric abbreviations</p>
</td></tr>
<tr><td><code id="prepare_extras_+3A_landscape_mat">landscape_mat</code></td>
<td>
<p>A matrix object</p>
</td></tr>
<tr><td><code id="prepare_extras_+3A_directions">directions</code></td>
<td>
<p>The number of directions in which patches should be connected: 4 (rook's case) or 8 (queen's case).</p>
</td></tr>
<tr><td><code id="prepare_extras_+3A_neighbourhood">neighbourhood</code></td>
<td>
<p>The number of directions in which cell adjacencies are considered as neighbours: 4 (rook's case) or 8 (queen's case). The default is 4.</p>
</td></tr>
<tr><td><code id="prepare_extras_+3A_ordered">ordered</code></td>
<td>
<p>The type of pairs considered. Either ordered (TRUE) or unordered (FALSE).
The default is TRUE.</p>
</td></tr>
<tr><td><code id="prepare_extras_+3A_base">base</code></td>
<td>
<p>The unit in which entropy is measured. The default is &quot;log2&quot;,
which compute entropy in &quot;bits&quot;. &quot;log&quot; and &quot;log10&quot; can be also used.</p>
</td></tr>
<tr><td><code id="prepare_extras_+3A_resolution">resolution</code></td>
<td>
<p>A vector with two numbers (usually calculated using terra::res)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Wrapper around terra::xyFromCell and terra::getValues to get raster_to_points
function including NA values
</p>


<h3>Value</h3>

<p>A list with zero or more of the following components:
</p>

<ul>
<li><p> points: matrix with three columns: col, row, value
</p>
</li>
<li><p> classes: vector with unique values
</p>
</li>
<li><p> class_patches: list with matrices of patches for each class
</p>
</li>
<li><p> area_patches: list with vectors of areas of patches for each class
</p>
</li>
<li><p> composition_vector: vector with the number of cells for each class
</p>
</li>
<li><p> neighbor_matrix: matrix with the number of cell pairs for each class
</p>
</li>
<li><p> comp: entropy of the neighbor_matrix
</p>
</li>
<li><p> cplx: complexity of the landscape
</p>
</li>
<li><p> enn_patch: matrix with the euclidean nearest neighbour distance for each patch
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+get_points">get_points</a></code>,
<code><a href="#topic+get_class_patches">get_class_patches</a></code>,
<code><a href="#topic+get_area_patches">get_area_patches</a></code>,
<code><a href="#topic+get_complexity">get_complexity</a></code>,
<code><a href="#topic+get_enn_patch">get_enn_patch</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>landscape &lt;- terra::rast(landscapemetrics::landscape)
landscape_mat &lt;- terra::as.matrix(landscape, wide = TRUE)
prepare_extras("lsm_l_ent", landscape_mat, neighbourhood = 4, base = "log2")

## Not run: 
metrics = list_lsm()$function_name
landscape &lt;- terra::rast(landscapemetrics::landscape)
landscape_mat &lt;- terra::as.matrix(landscape, wide = TRUE)
prepare_extras(metrics, landscape_mat, directions = 8, neighbourhood = 4,
               ordered = FALSE, base = "log2", resolution = terra::res(landscape))

## End(Not run)

</code></pre>

<hr>
<h2 id='proj_info'>proj_info</h2><span id='topic+proj_info'></span>

<h3>Description</h3>

<p>Projection info
</p>


<h3>Usage</h3>

<pre><code class='language-R'>proj_info(landscape)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="proj_info_+3A_landscape">landscape</code></td>
<td>
<p>RasterLayer</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Check projection of RasterLayer
</p>


<h3>Value</h3>

<p>raster
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
augusta_nlcd &lt;- terra::rast(landscapemetrics::augusta_nlcd)
proj_info(augusta_nlcd)
podlasie_ccilc &lt;- terra::rast(landscapemetrics::podlasie_ccilc)
proj_info(podlasie_ccilc)
landscape &lt;- terra::rast(landscapemetrics::landscape)
proj_info(landscape)

</code></pre>

<hr>
<h2 id='raster_to_points'>raster_to_points</h2><span id='topic+raster_to_points'></span>

<h3>Description</h3>

<p>Raster to points
</p>


<h3>Usage</h3>

<pre><code class='language-R'>raster_to_points(landscape, return_NA = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="raster_to_points_+3A_landscape">landscape</code></td>
<td>
<p>A categorical raster object: SpatRaster; Raster* Layer, Stack, Brick; stars or a list of SpatRasters.</p>
</td></tr>
<tr><td><code id="raster_to_points_+3A_return_na">return_NA</code></td>
<td>
<p>If true, NA cells are also included</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Wrapper around terra::xyFromCell and terra::getValues to get raster_to_points
function including NA values
</p>


<h3>Value</h3>

<p>matrix
</p>


<h3>Examples</h3>

<pre><code class='language-R'>landscape &lt;- terra::rast(landscapemetrics::landscape)
raster_to_points(landscape)

</code></pre>

<hr>
<h2 id='rcpp_cell_from_xy'>Get cell number</h2><span id='topic+rcpp_cell_from_xy'></span>

<h3>Description</h3>

<p>Get cell number(s) of a matrix from row and column numbers.
Cell numbers start at 0 in the upper left corner,
and increase from top to bottom, and then from left to right.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rcpp_cell_from_xy(x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rcpp_cell_from_xy_+3A_x">x</code></td>
<td>
<p>A matrix</p>
</td></tr>
<tr><td><code id="rcpp_cell_from_xy_+3A_y">y</code></td>
<td>
<p>A matrix with two columns (row and column numbers)</p>
</td></tr>
</table>

<hr>
<h2 id='rcpp_create_neighborhood'>Create neighborhood coordinates</h2><span id='topic+rcpp_create_neighborhood'></span>

<h3>Description</h3>

<p>This function creates a neighborhood coordinates matrix based on the directions parameter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rcpp_create_neighborhood(directions)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rcpp_create_neighborhood_+3A_directions">directions</code></td>
<td>
<p>The number of directions in which cells should be connected:
4 (rook's case), 8 (queen's case), or a neighbourhood matrix.
The neighbourhood matrix should have one cell with value 0 (the focal cell),
and at least one cell with value 1 (the adjacent cells).
Cells with other values (e.g. NA) are ignored.</p>
</td></tr>
</table>

<hr>
<h2 id='rcpp_get_nearest_neighbor'>First nearest neighbor distance</h2><span id='topic+rcpp_get_nearest_neighbor'></span>

<h3>Description</h3>

<p>Efficiently calculate the distance to the first nearest neighbor.
Quasi linear runtime.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rcpp_get_nearest_neighbor(points)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rcpp_get_nearest_neighbor_+3A_points">points</code></td>
<td>
<p>A two numeric matrix, where the first two columns are x and y</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector
</p>


<h3>Author(s)</h3>

<p>Florian Privé <a href="mailto:florian.prive.21@gmail.com">florian.prive.21@gmail.com</a>
</p>

<hr>
<h2 id='rcpp_xy_from_matrix'>Coordinates from a matrix</h2><span id='topic+rcpp_xy_from_matrix'></span>

<h3>Description</h3>

<p>This function gets coordinates (row and column numbers) of the matrix cells.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rcpp_xy_from_matrix(x, cell = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rcpp_xy_from_matrix_+3A_x">x</code></td>
<td>
<p>A matrix</p>
</td></tr>
<tr><td><code id="rcpp_xy_from_matrix_+3A_cell">cell</code></td>
<td>
<p>A vector of cell number.
If NULL, the coordinates will be calculated for the whole matrix</p>
</td></tr>
</table>

<hr>
<h2 id='sample_lsm'>sample_lsm</h2><span id='topic+sample_lsm'></span>

<h3>Description</h3>

<p>Sample metrics
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sample_lsm(
  landscape,
  y,
  plot_id = NULL,
  shape = "square",
  size = NULL,
  all_classes = FALSE,
  return_raster = FALSE,
  verbose = TRUE,
  progress = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sample_lsm_+3A_landscape">landscape</code></td>
<td>
<p>A categorical raster object: SpatRaster; Raster* Layer, Stack, Brick; stars or a list of SpatRasters.</p>
</td></tr>
<tr><td><code id="sample_lsm_+3A_y">y</code></td>
<td>
<p>2-column matrix with coordinates or sf point geometries.</p>
</td></tr>
<tr><td><code id="sample_lsm_+3A_plot_id">plot_id</code></td>
<td>
<p>Vector with id of sample points. If not provided, sample
points will be labelled 1...n.</p>
</td></tr>
<tr><td><code id="sample_lsm_+3A_shape">shape</code></td>
<td>
<p>String specifying plot shape. Either &quot;circle&quot; or &quot;square&quot;</p>
</td></tr>
<tr><td><code id="sample_lsm_+3A_size">size</code></td>
<td>
<p>Approximated size of sample plot. Equals the radius for circles or half of
the side-length for squares in map units. For lines size equals the width of the buffer.</p>
</td></tr>
<tr><td><code id="sample_lsm_+3A_all_classes">all_classes</code></td>
<td>
<p>Logical if NA should be returned for classes not present in some sample plots.</p>
</td></tr>
<tr><td><code id="sample_lsm_+3A_return_raster">return_raster</code></td>
<td>
<p>Logical if the clipped raster of the sample plot should
be returned</p>
</td></tr>
<tr><td><code id="sample_lsm_+3A_verbose">verbose</code></td>
<td>
<p>Print warning messages.</p>
</td></tr>
<tr><td><code id="sample_lsm_+3A_progress">progress</code></td>
<td>
<p>Print progress report.</p>
</td></tr>
<tr><td><code id="sample_lsm_+3A_...">...</code></td>
<td>
<p>Arguments passed on to <code>calculate_lsm()</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function samples the selected metrics in a buffer area (sample plot)
around sample points, sample lines or within provided polygons. The size of the actual
sampled landscape can be different to the provided size due to two reasons.
Firstly, because clipping raster cells using a circle or a sample plot not directly
at a cell center lead to inaccuracies. Secondly, sample plots can exceed the
landscape boundary. Therefore, we report the actual clipped sample plot area relative
in relation to the theoretical, maximum sample plot area e.g. a sample plot only half
within the landscape will have a <code>percentage_inside = 50</code>. Additionally, if the polygon
representing the sample plot is smaller than the cell size of the raster,
the <code>percentage_inside</code> may exceed 100%.Please be aware that the
output is slightly different to all other <code>lsm</code>-function of <code>landscapemetrics</code>.
</p>
<p>Please be aware that the function behaves differently for POLYGONS and MULTIPOLYGONS.
In the first case, each polygon is used as a singular sample area, while in the second
case all polygons are used as one sample area.
</p>
<p>The metrics can be specified by the arguments <code>what</code>, <code>level</code>, <code>metric</code>, <code>name</code>
and/or <code>type</code> (combinations of different arguments are possible (e.g.
<code style="white-space: pre;">&#8288;level = "class", type = "aggregation metric"&#8288;</code>). If an argument is not provided,
automatically all possibilities are selected. Therefore, to get <strong>all</strong>
available metrics, don't specify any of the above arguments.
</p>
<p>For all metrics based on distances or areas please make sure your data is valid
using <code><a href="#topic+check_landscape">check_landscape</a></code>.
</p>


<h3>Value</h3>

<p>tibble
</p>


<h3>See Also</h3>

<p><code><a href="#topic+list_lsm">list_lsm</a></code> <br />
<code><a href="#topic+calculate_lsm">calculate_lsm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>landscape &lt;- terra::rast(landscapemetrics::landscape)

# use a matrix
sample_points &lt;- matrix(c(10, 5, 25, 15, 5, 25), ncol = 2, byrow = TRUE)
sample_lsm(landscape, y = sample_points, size = 15, what = "lsm_l_np")

</code></pre>

<hr>
<h2 id='show_cores'>Show core area</h2><span id='topic+show_cores'></span>

<h3>Description</h3>

<p>Show core area
</p>


<h3>Usage</h3>

<pre><code class='language-R'>show_cores(
  landscape,
  directions = 8,
  class = "all",
  labels = FALSE,
  nrow = NULL,
  ncol = NULL,
  consider_boundary = TRUE,
  edge_depth = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="show_cores_+3A_landscape">landscape</code></td>
<td>
<p>Raster object</p>
</td></tr>
<tr><td><code id="show_cores_+3A_directions">directions</code></td>
<td>
<p>The number of directions in which patches should be
connected: 4 (rook's case) or 8 (queen's case).</p>
</td></tr>
<tr><td><code id="show_cores_+3A_class">class</code></td>
<td>
<p>How to show the core area: &quot;global&quot; (single map), &quot;all&quot; (every class as facet), or a vector with the specific classes one wants to show (every selected class as facet).</p>
</td></tr>
<tr><td><code id="show_cores_+3A_labels">labels</code></td>
<td>
<p>Logical flag indicating whether to print or not to print core labels.
boundary should be considered as core</p>
</td></tr>
<tr><td><code id="show_cores_+3A_nrow">nrow</code>, <code id="show_cores_+3A_ncol">ncol</code></td>
<td>
<p>Number of rows and columns for the facet.</p>
</td></tr>
<tr><td><code id="show_cores_+3A_consider_boundary">consider_boundary</code></td>
<td>
<p>Logical if cells that only neighbour the landscape
boundary should be considered as core.</p>
</td></tr>
<tr><td><code id="show_cores_+3A_edge_depth">edge_depth</code></td>
<td>
<p>Distance (in cells) a cell has the be away from the patch
edge to be considered as core cell</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The functions plots the core area of patches labeled with the
corresponding patch id. The edges are the grey cells surrounding the patches and are always shown.
</p>


<h3>Value</h3>

<p>ggplot
</p>


<h3>Examples</h3>

<pre><code class='language-R'>landscape &lt;- terra::rast(landscapemetrics::landscape)

# show "global" core area
show_cores(landscape, class = "global", labels = FALSE)

# show the core area of every class as facet
show_cores(landscape, class = "all", labels = FALSE)

# show only the core area of class 1 and 3
show_cores(landscape, class = c(1, 3), labels = TRUE)

</code></pre>

<hr>
<h2 id='show_correlation'>Show correlation</h2><span id='topic+show_correlation'></span>

<h3>Description</h3>

<p>Show correlation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>show_correlation(
  data,
  method = "pearson",
  diag = TRUE,
  labels = FALSE,
  vjust = 0,
  text_size = 15
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="show_correlation_+3A_data">data</code></td>
<td>
<p>Tibble with results of as returned by the landscapemetrics package.</p>
</td></tr>
<tr><td><code id="show_correlation_+3A_method">method</code></td>
<td>
<p>Type of correlation. See <code>link{cor}</code> for details.</p>
</td></tr>
<tr><td><code id="show_correlation_+3A_diag">diag</code></td>
<td>
<p>If FALSE, values on the diagonal will be NA and not plotted.</p>
</td></tr>
<tr><td><code id="show_correlation_+3A_labels">labels</code></td>
<td>
<p>If TRUE, the correlation value will be added as text.</p>
</td></tr>
<tr><td><code id="show_correlation_+3A_vjust">vjust</code></td>
<td>
<p>Will be passed on to ggplot2 as vertical justification of x-axis text.</p>
</td></tr>
<tr><td><code id="show_correlation_+3A_text_size">text_size</code></td>
<td>
<p>Text size of the plot.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The functions calculates the correlation between all metrics. In order
to calculate  correlations, for the landscape level more than one landscape needs
to be present. All input must be structured as returned by the <strong>landscapemetrics</strong>
package.
</p>
<p>For all metrics based on distances or areas please make sure your data is valid
using <code><a href="#topic+check_landscape">check_landscape</a></code>.
</p>


<h3>Value</h3>

<p>ggplot
</p>


<h3>Examples</h3>

<pre><code class='language-R'>landscape &lt;- terra::rast(landscapemetrics::landscape)

metrics &lt;- calculate_lsm(landscape, what = c("patch", "class"))
show_correlation(data = metrics, method = "pearson")

## Not run: 
metrics &lt;- calculate_lsm(landscape, what = c("patch", "class"))
correlations &lt;- calculate_correlation(metrics)
show_correlation(data = correlations, method = "pearson")

## End(Not run)

</code></pre>

<hr>
<h2 id='show_lsm'>Show landscape metrics</h2><span id='topic+show_lsm'></span>

<h3>Description</h3>

<p>Show landscape metrics on patch level printed in their corresponding patch.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>show_lsm(
  landscape,
  what,
  class = "global",
  directions = 8,
  consider_boundary = FALSE,
  edge_depth = 1,
  labels = FALSE,
  label_lsm = FALSE,
  nrow = NULL,
  ncol = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="show_lsm_+3A_landscape">landscape</code></td>
<td>
<p>*Raster object</p>
</td></tr>
<tr><td><code id="show_lsm_+3A_what">what</code></td>
<td>
<p>Patch level what to plot</p>
</td></tr>
<tr><td><code id="show_lsm_+3A_class">class</code></td>
<td>
<p>How to show the labeled patches: &quot;global&quot; (single map), &quot;all&quot; (every class as facet),
or a vector with the specific classes one wants to show (every selected class as facet).</p>
</td></tr>
<tr><td><code id="show_lsm_+3A_directions">directions</code></td>
<td>
<p>The number of directions in which patches should be
connected: 4 (rook's case) or 8 (queen's case).</p>
</td></tr>
<tr><td><code id="show_lsm_+3A_consider_boundary">consider_boundary</code></td>
<td>
<p>Logical if cells that only neighbour the landscape boundary should be considered as core</p>
</td></tr>
<tr><td><code id="show_lsm_+3A_edge_depth">edge_depth</code></td>
<td>
<p>Distance (in cells) a cell has the be away from the patch edge to be considered as core cell</p>
</td></tr>
<tr><td><code id="show_lsm_+3A_labels">labels</code></td>
<td>
<p>Logical flag indicating whether to print or not to print patch labels.</p>
</td></tr>
<tr><td><code id="show_lsm_+3A_label_lsm">label_lsm</code></td>
<td>
<p>If true, the value of the landscape metric is used as label</p>
</td></tr>
<tr><td><code id="show_lsm_+3A_nrow">nrow</code>, <code id="show_lsm_+3A_ncol">ncol</code></td>
<td>
<p>Number of rows and columns for the facet.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function plots all patches with a fill corresponding to the value
of the chosen landscape metric on patch level.
</p>
<p>For all metrics based on distances or areas please make sure your data is valid
using <code><a href="#topic+check_landscape">check_landscape</a></code>.
</p>


<h3>Value</h3>

<p>ggplot
</p>


<h3>Examples</h3>

<pre><code class='language-R'>landscape &lt;- terra::rast(landscapemetrics::landscape)

show_lsm(landscape, what = "lsm_p_area", directions = 4)
show_lsm(landscape, what = "lsm_p_shape", class = c(1, 2), label_lsm = TRUE)
show_lsm(landscape, what = "lsm_p_circle", class = 3, labels = TRUE)

</code></pre>

<hr>
<h2 id='show_patches'>Show patches</h2><span id='topic+show_patches'></span>

<h3>Description</h3>

<p>Show patches
</p>


<h3>Usage</h3>

<pre><code class='language-R'>show_patches(
  landscape,
  class = "global",
  directions = 8,
  labels = FALSE,
  nrow = NULL,
  ncol = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="show_patches_+3A_landscape">landscape</code></td>
<td>
<p>*Raster object</p>
</td></tr>
<tr><td><code id="show_patches_+3A_class">class</code></td>
<td>
<p>How to show the labeled patches: &quot;global&quot; (single map), &quot;all&quot; (every class as facet), or a vector with the specific classes one wants to show (every selected class as facet).</p>
</td></tr>
<tr><td><code id="show_patches_+3A_directions">directions</code></td>
<td>
<p>The number of directions in which patches should be
connected: 4 (rook's case) or 8 (queen's case).</p>
</td></tr>
<tr><td><code id="show_patches_+3A_labels">labels</code></td>
<td>
<p>Logical flag indicating whether to print or not to print patch labels.</p>
</td></tr>
<tr><td><code id="show_patches_+3A_nrow">nrow</code>, <code id="show_patches_+3A_ncol">ncol</code></td>
<td>
<p>Number of rows and columns for the facet.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The functions plots the landscape with the patches labeled with the
corresponding patch id.
</p>


<h3>Value</h3>

<p>ggplot
</p>


<h3>Examples</h3>

<pre><code class='language-R'>landscape &lt;- terra::rast(landscapemetrics::landscape)

show_patches(landscape)
show_patches(landscape, class = c(1, 2))
show_patches(landscape, class = 3, labels = FALSE)

</code></pre>

<hr>
<h2 id='spatialize_lsm'>spatialize_lsm</h2><span id='topic+spatialize_lsm'></span>

<h3>Description</h3>

<p>Spatialize landscape metric values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spatialize_lsm(
  landscape,
  level = "patch",
  metric = NULL,
  name = NULL,
  type = NULL,
  what = NULL,
  directions = 8,
  progress = FALSE,
  to_disk = getOption("to_disk", default = FALSE),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spatialize_lsm_+3A_landscape">landscape</code></td>
<td>
<p>A categorical raster object: SpatRaster; Raster* Layer, Stack, Brick; stars or a list of SpatRasters.</p>
</td></tr>
<tr><td><code id="spatialize_lsm_+3A_level">level</code></td>
<td>
<p>Level of metrics. Either 'patch', 'class' or 'landscape' (or vector with combination).</p>
</td></tr>
<tr><td><code id="spatialize_lsm_+3A_metric">metric</code></td>
<td>
<p>Abbreviation of metrics (e.g. 'area').</p>
</td></tr>
<tr><td><code id="spatialize_lsm_+3A_name">name</code></td>
<td>
<p>Full name of metrics (e.g. 'core area')</p>
</td></tr>
<tr><td><code id="spatialize_lsm_+3A_type">type</code></td>
<td>
<p>Type according to FRAGSTATS grouping (e.g. 'aggregation metrics').</p>
</td></tr>
<tr><td><code id="spatialize_lsm_+3A_what">what</code></td>
<td>
<p>Selected level of metrics: either &quot;patch&quot;, &quot;class&quot; or &quot;landscape&quot;.
It is also possible to specify functions as a vector of strings, e.g. <code>what = c("lsm_c_ca", "lsm_l_ta")</code>.</p>
</td></tr>
<tr><td><code id="spatialize_lsm_+3A_directions">directions</code></td>
<td>
<p>The number of directions in which patches should be
connected: 4 (rook's case) or 8 (queen's case).</p>
</td></tr>
<tr><td><code id="spatialize_lsm_+3A_progress">progress</code></td>
<td>
<p>Print progress report.</p>
</td></tr>
<tr><td><code id="spatialize_lsm_+3A_to_disk">to_disk</code></td>
<td>
<p>If TRUE raster will be saved to disk.</p>
</td></tr>
<tr><td><code id="spatialize_lsm_+3A_...">...</code></td>
<td>
<p>Arguments passed on to <code>calculate_lsm()</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The functions returns a nested list with <code>RasterLayer</code>s. The first level
contains each input layer (only one element if <code>RasterLayer</code> was provided).
The second level contains a <code>RasterLayer</code> for each selected metric
(see <code>list_lsm</code> for details) where each cell has the landscape metric
value of the patch it belongs to. Only patch level metrics are allowed.
</p>
<p>For all metrics based on distances or areas please make sure your data is valid
using <code><a href="#topic+check_landscape">check_landscape</a></code>.
</p>


<h3>Value</h3>

<p>list
</p>


<h3>See Also</h3>

<p><code><a href="#topic+list_lsm">list_lsm</a></code> <br />
<code><a href="#topic+show_lsm">show_lsm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>landscape &lt;- terra::rast(landscapemetrics::landscape)
p_area_raster &lt;- spatialize_lsm(landscape, what = "lsm_p_area")
terra::plot(p_area_raster[[1]][[1]])

</code></pre>

<hr>
<h2 id='unpad_raster'>unpad_raster</h2><span id='topic+unpad_raster'></span>

<h3>Description</h3>

<p>Adding padding to raster
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unpad_raster(
  landscape,
  unpad_raster_cells = 1,
  return_raster = TRUE,
  to_disk = getOption("to_disk", default = FALSE)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unpad_raster_+3A_landscape">landscape</code></td>
<td>
<p>A categorical raster object: SpatRaster; Raster* Layer, Stack, Brick; stars or a list of SpatRasters.</p>
</td></tr>
<tr><td><code id="unpad_raster_+3A_unpad_raster_cells">unpad_raster_cells</code></td>
<td>
<p>Number of rows and columns added</p>
</td></tr>
<tr><td><code id="unpad_raster_+3A_return_raster">return_raster</code></td>
<td>
<p>If false, matrix is returned</p>
</td></tr>
<tr><td><code id="unpad_raster_+3A_to_disk">to_disk</code></td>
<td>
<p>Logical argument, if FALSE results of get_patches are hold
in memory. If true, unpad_raster writes temporary files and hence, does not hold
everything in memory. Can be set with a global option, e.g. <code>option(to_disk = TRUE)</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Removes equally (in all four directions) additional cells around the raster
</p>


<h3>Value</h3>

<p>raster
</p>


<h3>Examples</h3>

<pre><code class='language-R'>landscape &lt;- terra::rast(landscapemetrics::landscape)
lsm_padded &lt;- pad_raster(landscape, pad_raster_cells = 2, pad_raster_value = -1)
unpad_raster(lsm_padded[[1]], unpad_raster_cells = 2)

</code></pre>

<hr>
<h2 id='window_lsm'>window_lsm</h2><span id='topic+window_lsm'></span>

<h3>Description</h3>

<p>Moving window
</p>


<h3>Usage</h3>

<pre><code class='language-R'>window_lsm(
  landscape,
  window,
  level = "landscape",
  metric = NULL,
  name = NULL,
  type = NULL,
  what = NULL,
  progress = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="window_lsm_+3A_landscape">landscape</code></td>
<td>
<p>A categorical raster object: SpatRaster; Raster* Layer, Stack, Brick; stars or a list of SpatRasters.</p>
</td></tr>
<tr><td><code id="window_lsm_+3A_window">window</code></td>
<td>
<p>Moving window matrix.</p>
</td></tr>
<tr><td><code id="window_lsm_+3A_level">level</code></td>
<td>
<p>Level of metrics. Either 'patch', 'class' or 'landscape' (or vector with combination).</p>
</td></tr>
<tr><td><code id="window_lsm_+3A_metric">metric</code></td>
<td>
<p>Abbreviation of metrics (e.g. 'area').</p>
</td></tr>
<tr><td><code id="window_lsm_+3A_name">name</code></td>
<td>
<p>Full name of metrics (e.g. 'core area')</p>
</td></tr>
<tr><td><code id="window_lsm_+3A_type">type</code></td>
<td>
<p>Type according to FRAGSTATS grouping (e.g. 'aggregation metrics').</p>
</td></tr>
<tr><td><code id="window_lsm_+3A_what">what</code></td>
<td>
<p>Selected level of metrics: either &quot;patch&quot;, &quot;class&quot; or &quot;landscape&quot;.
It is also possible to specify functions as a vector of strings, e.g. <code>what = c("lsm_c_ca", "lsm_l_ta")</code>.</p>
</td></tr>
<tr><td><code id="window_lsm_+3A_progress">progress</code></td>
<td>
<p>Print progress report.</p>
</td></tr>
<tr><td><code id="window_lsm_+3A_...">...</code></td>
<td>
<p>Arguments passed on to <code>calculate_lsm()</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function calculates for each focal cell the selected landscape metrics (currently only landscape level
metrics are allowed) for a local neighbourhood. The neighbourhood can be specified using a matrix. For more
details, see <code>?terra::focal()</code>. The result will be a <code>RasterLayer</code> in which each focal cell includes
the value of its neighbourhood and thereby allows to show gradients and variability in the landscape (Hagen-Zanker 2016).
To be type stable, the actual result is always a nested list (first level for <code>RasterStack</code> layers, second level
for selected landscape metrics).
</p>
<p>Note, that in situations when the moving window does not contain any patches, the result is NA.
</p>


<h3>Value</h3>

<p>list
</p>


<h3>References</h3>

<p>Fletcher, R., Fortin, M.-J. 2018. Spatial Ecology and Conservation Modeling: Applications
with R. Springer International Publishing. 523 pages
</p>
<p>Hagen-Zanker, A. (2016). A computational framework for generalized moving windows
and its application to landscape pattern analysis. International journal of applied
earth observation and geoinformation, 44, 205-216.
</p>
<p>McGarigal K., SA Cushman, and E Ene. 2023. FRAGSTATS v4: Spatial Pattern Analysis
Program for Categorical Maps. Computer software program produced by the authors;
available at the following web site: https://www.fragstats.org
</p>


<h3>See Also</h3>

<p><code><a href="#topic+list_lsm">list_lsm</a></code> <br />
<code><a href="#topic+calculate_lsm">calculate_lsm</a></code> <br />
<code><a href="terra.html#topic+focal">focal</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
landscape &lt;- terra::rast(landscapemetrics::landscape)
landscape_stack &lt;- c(landscape, landscape)
window &lt;- matrix(1, nrow = 5,ncol = 5)
window_lsm(landscape, window = window, what = c("lsm_l_pr", "lsm_l_joinent"))
window_lsm(landscape_stack, window = window, what = c("lsm_l_pr", "lsm_l_joinent"))

window_circular &lt;- matrix(c(NA, 1, NA, 1, 1, 1, NA, 1, NA), nrow = 3, ncol = 3)
window_lsm(landscape, window = window_circular, what = c("lsm_l_pr", "lsm_l_joinent"))

## End(Not run)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
