<!DOCTYPE html><html lang="en"><head><title>Help for package freegroup</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {freegroup}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#freegroup-package'>
<p>The Free Group</p></a></li>
<li><a href='#abelianize'><p>Abelianization of free group elements</p></a></li>
<li><a href='#abs.free'><p>Absolute value of a <code>free</code> object</p></a></li>
<li><a href='#alpha'><p>Alphabetical free group elements</p></a></li>
<li><a href='#backwards'><p>Write free objects backwards</p></a></li>
<li><a href='#c'><p>Concatenation of free objects</p></a></li>
<li><a href='#char_to_free'><p>Convert character vectors to free objects</p></a></li>
<li><a href='#cumsum'><p>Cumulative sum</p></a></li>
<li><a href='#cycred'><p>Cyclic reductions of a word</p></a></li>
<li><a href='#donames'><p>Names attributes of free group elements</p></a></li>
<li><a href='#dot-class'><p>Class &ldquo;dot&rdquo;</p></a></li>
<li><a href='#Extract'><p>Extract or replace parts of a free group object</p></a></li>
<li><a href='#free'><p>Objects of class <code>free</code></p></a></li>
<li><a href='#getlet'><p>Get letters of a freegroup object</p></a></li>
<li><a href='#identity'><p>The identity element</p></a></li>
<li><a href='#keep'><p>Keep or drop symbols</p></a></li>
<li><a href='#nielsen'><p>Outer automorphisms of the free group</p></a></li>
<li><a href='#Ops.free'><p>Arithmetic Ops methods for the free group</p></a></li>
<li><a href='#primitive'><p>Primitive elements of the free algebra</p></a></li>
<li><a href='#print'><p>Print free objects</p></a></li>
<li><a href='#reduce'><p>Reduction of a word to reduced form</p></a></li>
<li><a href='#rfree'><p>Random free objects</p></a></li>
<li><a href='#shift'><p>Permute elements of a vector in a cycle</p></a></li>
<li><a href='#size'>
<p>Bignesses of a free object</p></a></li>
<li><a href='#subs'><p>Substitute and invert symbols</p></a></li>
<li><a href='#sum'><p>Repeated summation by concatenation</p></a></li>
<li><a href='#tietze'><p>Tietze form for free group objects</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>The Free Group</td>
</tr>
<tr>
<td>Version:</td>
<td>1.2-0</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Robin K. S. Hankin &lt;hankin.robin@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>The free group in R; juxtaposition is represented by a
  plus.  Includes inversion, multiplication by a scalar,
  group-theoretic power operation, and Tietze forms.  To cite the
  package in publications please use Hankin (2022)
  &lt;<a href="https://doi.org/10.48550%2FARXIV.2212.05883">doi:10.48550/ARXIV.2212.05883</a>&gt;.</td>
</tr>
<tr>
<td>Depends:</td>
<td>methods, plyr, R (&ge; 4.1.0)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, permutations, testthat, covr</td>
</tr>
<tr>
<td>LazyData:</td>
<td>yes</td>
</tr>
<tr>
<td>Imports:</td>
<td>freealg (&ge; 1.0-4), magic (&ge; 1.5-9), magrittr</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/RobinHankin/freegroup">https://github.com/RobinHankin/freegroup</a>,
<a href="https://robinhankin.github.io/freegroup/">https://robinhankin.github.io/freegroup/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/RobinHankin/freegroup/issues">https://github.com/RobinHankin/freegroup/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-03-20 10:55:29 UTC; rhankin</td>
</tr>
<tr>
<td>Author:</td>
<td>Robin K. S. Hankin
    <a href="https://orcid.org/0000-0001-5982-0415"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-03-20 11:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='freegroup-package'>
The Free Group
</h2><span id='topic+freegroup-package'></span><span id='topic+freegroup'></span>

<h3>Description</h3>

<p>The free group in R; juxtaposition is represented by a
  plus.  Includes inversion, multiplication by a scalar,
  group-theoretic power operation, and Tietze forms.  To cite the
  package in publications please use Hankin (2022)
  &lt;doi:10.48550/ARXIV.2212.05883&gt;.
</p>


<h3>Details</h3>

<p>The DESCRIPTION file:
</p>

<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> freegroup</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Title: </td><td style="text-align: left;"> The Free Group</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 1.2-0</td>
</tr>
<tr>
 <td style="text-align: left;">
Authors@R: </td><td style="text-align: left;"> c(person(c("Robin", "K. S. "), "Hankin", 
    role=c("aut","cre"),
    email="hankin.robin@gmail.com",
		comment = c(ORCID = "0000-0001-5982-0415")))</td>
</tr>
<tr>
 <td style="text-align: left;">
Maintainer: </td><td style="text-align: left;"> Robin K. S. Hankin &lt;hankin.robin@gmail.com&gt;</td>
</tr>
<tr>
 <td style="text-align: left;">
Description: </td><td style="text-align: left;"> The free group in R; juxtaposition is represented by a
  plus.  Includes inversion, multiplication by a scalar,
  group-theoretic power operation, and Tietze forms.  To cite the
  package in publications please use Hankin (2022)
  &lt;doi:10.48550/ARXIV.2212.05883&gt;.</td>
</tr>
<tr>
 <td style="text-align: left;">
Depends: </td><td style="text-align: left;"> methods, plyr, R (&gt;= 4.1.0)</td>
</tr>
<tr>
 <td style="text-align: left;">
Suggests: </td><td style="text-align: left;"> knitr, rmarkdown, permutations, testthat, covr</td>
</tr>
<tr>
 <td style="text-align: left;">
LazyData: </td><td style="text-align: left;"> yes</td>
</tr>
<tr>
 <td style="text-align: left;">
Imports: </td><td style="text-align: left;"> freealg (&gt;= 1.0-4), magic (&gt;= 1.5-9), magrittr</td>
</tr>
<tr>
 <td style="text-align: left;">
VignetteBuilder: </td><td style="text-align: left;"> knitr</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL-2</td>
</tr>
<tr>
 <td style="text-align: left;">
URL: </td><td style="text-align: left;"> https://github.com/RobinHankin/freegroup, https://robinhankin.github.io/freegroup/</td>
</tr>
<tr>
 <td style="text-align: left;">
BugReports: </td><td style="text-align: left;"> https://github.com/RobinHankin/freegroup/issues</td>
</tr>
<tr>
 <td style="text-align: left;">
Author: </td><td style="text-align: left;"> Robin K. S. Hankin [aut, cre] (&lt;https://orcid.org/0000-0001-5982-0415&gt;)</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>


<p>Index of help topics:
</p>
<pre>
Extract.free            Extract or replace parts of a free group object
Ops.free                Arithmetic Ops methods for the free group
abelianize              Abelianization of free group elements
abs.free                Absolute value of a 'free' object
alpha                   Alphabetical free group elements
backwards               Write free objects backwards
c                       Concatenation of free objects
char_to_free            Convert character vectors to free objects
cumsum                  Cumulative sum
cycred                  Cyclic reductions of a word
donames                 Names attributes of free group elements
dot-class               Class "dot"
free                    Objects of class 'free'
freegroup-package       The Free Group
getlet                  Get letters of a freegroup object
identity                The identity element
keep                    Keep or drop symbols
nielsen                 Outer automorphisms of the free group
primitive               Primitive elements of the free algebra
print.free              Print free objects
reduce                  Reduction of a word to reduced form
rfree                   Random free objects
shift                   Permute elements of a vector in a cycle
size                    Bignesses of a free object
subs                    Substitute and invert symbols
sum                     Repeated summation by concatenation
tietze                  Tietze form for free group objects
</pre>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin [aut, cre] (&lt;https://orcid.org/0000-0001-5982-0415&gt;)
</p>
<p>Maintainer: Robin K. S. Hankin &lt;hankin.robin@gmail.com&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p &lt;- rfree(10,6,3)
x &lt;- as.free('x')

p+x

p^x

sum(p)

abelianize(p)

subsu(p,"ab","z")
subs(p,a='z')


discard(p+x,'a')

</code></pre>

<hr>
<h2 id='abelianize'>Abelianization of free group elements</h2><span id='topic+abelianize'></span><span id='topic+abelianized'></span><span id='topic+is.abelian'></span>

<h3>Description</h3>

<p>Function <code>abelianize()</code> returns a word that is
equivalent to its argument under assumption of Abelianness.  The symbols
are placed in alphabetical order.</p>


<h3>Usage</h3>

<pre><code class='language-R'>  abelianize(x)
  is.abelian(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="abelianize_+3A_x">x</code></td>
<td>
<p>An object of class <code>free</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Abelianizing a free group element means that the symbols can commute
past one another.  Abelianization is vectorized.
</p>
<p>Function <code>is.abelian()</code> is trivial: it just checks to see whether
argument <code>x</code> has its symbols in alphabetical order.  It might have
been better to call this <code>abelianized()</code>.
</p>
<p>Package <a href="https://CRAN.R-project.org/package=frab"><span class="pkg">frab</span></a> presents extensive R-centric functionality for
dealing with the free Abelian group.  It is much more efficient than
this package for Abelian operations, and contains bespoke methods for
working with a range of applications such as tables of counts.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- as.free("aabAA")
x
abelianize(x)

x &lt;- rfree(10,10,2)
x
abelianize(x)

abelianize(.[rfree(),rfree()])


p &lt;- free(rbind(rep(1:5,4),rep(1:4,5)))
p
abelianize(p)
</code></pre>

<hr>
<h2 id='abs.free'>Absolute value of a <code>free</code> object</h2><span id='topic+abs.free'></span><span id='topic+abs'></span>

<h3>Description</h3>

<p>Replaces every term's power with its absolute value
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'free'
abs(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="abs.free_+3A_x">x</code></td>
<td>
<p>Object of class <code>free</code></p>
</td></tr></table>


<h3>Details</h3>

<p>Replaces every term's power with its absolute value
</p>


<h3>Note</h3>

<p>The function's name is motivated  by the inequality in the examples
section.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>See Also</h3>

<p><code><a href="#topic+subs">subs</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
abs(abc(-5:5))

a &lt;- rfree(10,4,7)
b &lt;- rfree(10,4,7)

a
abs(a)

## following should all be TRUE:
all(size(abs(a+b))  &lt;=  size(abs(a) + abs(b)))
all(total(abs(a+b)) &lt;=  total(abs(a) + abs(b)))
all(number(abs(a+b)) &lt;= number(abs(a) + abs(b)))

all(size(a+b)   &lt;= size(abs(a) + abs(b)))
all(total(a+b)  &lt;= total(abs(a) + abs(b)))
all(number(a+b) &lt;= number(abs(a) + abs(b)))

</code></pre>

<hr>
<h2 id='alpha'>Alphabetical free group elements</h2><span id='topic+alpha'></span><span id='topic+abc'></span><span id='topic+alphabet'></span>

<h3>Description</h3>

<p>Produces simple vectors of free group elements based on the
alphabet</p>


<h3>Usage</h3>

<pre><code class='language-R'>alpha(v)
abc(v)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="alpha_+3A_v">v</code></td>
<td>
<p>Vector of integers</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function <code>alpha()</code> takes an integer <code>i</code> and returns the
letter <code>i</code> of the alphabet.  Thus <code>alpha(3)</code> returns
<code>c</code>.  The function is vectorised: <code>alpha(1:3)</code> returns
<code>a b c</code>.
</p>
<p>Function <code>abc()</code> takes an integer <code>i</code> and returns letters
1 to <code>i</code> of the alphabet.  Thus <code>abc(4)</code> returns
<code>a.b.c.d</code>.  The function is vectorised.
</p>
<p>Remember that &ldquo;letters of the alphabet&rdquo; is just a phrase:
above it refers to the default print method which can be changed,
see the examples.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>Examples</h3>

<pre><code class='language-R'>alpha(5)  # just the single letter 'e'
abc(5)    # product of a,b,c,d,e

alpha(1:26)  # the whole alphabet; c

all(alpha(1:26) == as.free(letters))  # should be TRUE

z &lt;- alpha(26)  # variable 'z' is symbol 26, aka 'z'.
abc(1:10) ^ z

abc(-5:5)
alpha(-5:5)
sum(abc(-5:5))


## bear in mind that the symbols used are purely for the print method:
jj &lt;- LETTERS[1:10]
options(freegroup_symbols = apply(expand.grid(jj,jj),1,paste,collapse=""))
alpha(c(66,67,68,69))   # sensible output
options(freegroup_symbols=NULL)   # restore to symbols to default letters
alpha(c(66,67,68,69))   # print method not very helpful now
</code></pre>

<hr>
<h2 id='backwards'>Write free objects backwards</h2><span id='topic+backwards'></span>

<h3>Description</h3>

<p>Write free objects in reverse order</p>


<h3>Usage</h3>

<pre><code class='language-R'>backwards(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="backwards_+3A_x">x</code></td>
<td>
<p>Object of class <code>free</code></p>
</td></tr>
</table>


<h3>Note</h3>

<p>For each element of a <code>free</code> object, function <code>backwards()</code>
writes the symbols in reverse order.  It is distinct from
<code>rev()</code>, see examples.
</p>
<p>Function backwards is an involution: it is its own inverse.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>Examples</h3>

<pre><code class='language-R'>abc(1:5)
backwards(abc(1:5))
rev(abc(1:5))

x &lt;- rfree(10,5)
backwards(backwards(x)) == x  # involution
all(abelianize(x) == abelianize(backwards(x))) # should be TRUE
</code></pre>

<hr>
<h2 id='c'>Concatenation of free objects</h2><span id='topic+c'></span><span id='topic+c.free'></span><span id='topic+rep.free'></span>

<h3>Description</h3>

<p>Concatenate free objects together 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'free'
c(...)
## S3 method for class 'free'
rep(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="c_+3A_...">...</code></td>
<td>
<p>In the method for <code>c()</code>, objects to be
concatenated.  Should all be of the same type</p>
</td></tr>
<tr><td><code id="c_+3A_x">x</code></td>
<td>
<p>In the method for <code>rep()</code>, a free object</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin
</p>


<h3>Examples</h3>

<pre><code class='language-R'>(x &lt;- abc(1:3))
(y &lt;- alpha(22:25))

c(x,y,x,x)


## NB: compare
rep(x,2)  
x*2  
</code></pre>

<hr>
<h2 id='char_to_free'>Convert character vectors to free objects</h2><span id='topic+char_to_free'></span><span id='topic+char_to_matrix'></span>

<h3>Description</h3>

<p>Convert character vectors to free objects</p>


<h3>Usage</h3>

<pre><code class='language-R'>char_to_matrix(x)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="char_to_free_+3A_x">x</code></td>
<td>
<p>A character vector</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function <code>char_to_matrix()</code> gives very basic conversion between
character vectors and free objects.  Current functionality is limited
to strings like &ldquo;<code>aaabaacd</code>&rdquo;, which would give
<code class="reqn">a^3ba^2cd</code>.  It would be nice to take a string
like &ldquo;<code>a^3b^(-3)</code>&rdquo; but this is not yet implemented.
</p>
<p>Function <code>char_to_free()</code> is a vectorized version that coerces
output to <code>free</code>.
</p>


<h3>Note</h3>

<p>The function is not particularly robust; for example, passing anything
other than letters a-z or A-Z will give possibly undesirable
behaviour.
</p>
<p>Upper-case letters A-Z are interpreted by <code>char_to_matrix()</code> as
the inverse of their corresponding lower-case equivalents.  This
behaviour is inherited by <code>char_to_free()</code> and <code>as.free()</code>,
so that <code>as.free("A") == inverse(as.free("a"))</code>.
</p>
<p>Function <code>char_to_free()</code> is consistent with the default print
options (which are that the symbols are the lowercase letters a-z).
If you change the symbols' names, for example
<code>options(freegroup_symbols=sample(letters))</code>, then things can get
confusing.  The print method does not change the internal
representation of a <code>free</code> object, which is a list of integer
matrices.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>See Also</h3>

<p><code><a href="#topic+print.free">print.free</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
char_to_matrix("aaabcABC")

rfree(10,3) + as.free('xxxxxxxxxxxx')

as.free(letters)*7

all(is.id(as.free(letters) + as.free(LETTERS)))


as.free('')  # identity element

</code></pre>

<hr>
<h2 id='cumsum'>Cumulative sum</h2><span id='topic+cumsum'></span><span id='topic+cumsum.free'></span>

<h3>Description</h3>

<p>Cumulative sum of free vectors</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'free'
cumsum(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cumsum_+3A_x">x</code></td>
<td>
<p>Vector of class free</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>See Also</h3>

<p><code><a href="#topic+sum">sum</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>abc(1:6)
cumsum(abc(1:6))

x &lt;- rfree(10,2)
cumsum(c(x,-rev(x)))
</code></pre>

<hr>
<h2 id='cycred'>Cyclic reductions of a word</h2><span id='topic+cycred'></span><span id='topic+cyclic'></span><span id='topic+cyclically'></span><span id='topic+cyclically_reduced'></span><span id='topic+cyclically_reduce'></span><span id='topic+cyclic_reduction'></span><span id='topic+is.cyclically.reduced'></span><span id='topic+as.cyclically_reduced'></span><span id='topic+is.cyclically_reduced'></span><span id='topic+cyclically_reduce_tietze'></span><span id='topic+is.conjugate_single'></span><span id='topic+conjugate'></span><span id='topic+is.conjugate'></span><span id='topic+is.conjugate.free'></span><span id='topic++25~+25'></span><span id='topic+allconj'></span>

<h3>Description</h3>

<p>Functionality to cyclically reduce words and detect conjugacy</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.cyclically_reduced(a)
as.cyclically_reduced(a)
cyclically_reduce(a)
cyclically_reduce_tietze(p)
is.conjugate_single(u,v)
x %~% y
## S3 method for class 'free'
is.conjugate(x,y)
allconj(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cycred_+3A_a">a</code>, <code id="cycred_+3A_x">x</code>, <code id="cycred_+3A_y">y</code></td>
<td>
<p>An object of class <code>free</code></p>
</td></tr>
<tr><td><code id="cycred_+3A_p">p</code>, <code id="cycred_+3A_u">u</code>, <code id="cycred_+3A_v">v</code></td>
<td>
<p>Integer vector corresponding to Tietze form of a word</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A <code>free</code> object is <dfn>cyclically reduced</dfn> iff every cyclic
permutation of the word is reduced.  A reduced word is cyclically
reduced iff the first letter is not the inverse of the last one.  A
reduced word is cyclically reduced if the first and last symbol differ
(irrespective of power) or, if identical, have powers of opposite
sign.  For example, <code>abac</code> and <code>abca</code> are cyclically reduced
but <code>abca^{-1}</code> is not.  Function <code>is.cyclically_reduced()</code>
tests for this.  
</p>
<p>Function <code>as.cyclically_reduced()</code> takes a vector of free objects
and returns the elementwise cyclically reduced equivalents.  Function
<code>cyclically_reduce()</code> is a synonym with better (English) grammar.
</p>
<p>The identity is cyclically reduced: it cannot be shortened by a
combination of cyclic permutation followed by reduction.  This ensures
that <code>is.cyclically_reduced(as.cyclically_reduced(x))</code> is always
TRUE.  Also, it is clear that the identity should be conjugate to
itself.
</p>
<p>Two words <code class="reqn">a,b</code> are <dfn>conjugate</dfn> if there exists a <code class="reqn">x</code> such
that <code class="reqn">ax=xb</code> (or equivalently <code class="reqn">a=x^{-1}bx</code>).  This
is detected by function <code>is.conjugate()</code>.  Functions
<code>is_conjugate_single()</code> and <code>cyclically_reduce_tietze()</code> are
lower-level helper functions.
</p>
<p>Function <code>allconj()</code> returns all cyclically reduced words
conjugate to its argument.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>See Also</h3>

<p><code><a href="#topic+reduce">reduce</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
(x &lt;- abc(1:9) - abc(9:1))
as.cyclically_reduced(x)

 a &lt;- rfree(1000,3)
 all(size(as.cyclically_reduced(a)) &lt;= size(a))
 all(total(as.cyclically_reduced(a)) &lt;= total(a))
 all(number(as.cyclically_reduced(a)) &lt;= number(a))



 x &lt;- rfree(1000,2)
 y &lt;- as.free('ab')
 table(conjugate = (x%~%y), equal = (x==y))  # note zero at top right

 allconj(as.free('aaaaab'))
 allconj(sum(abc(seq_len(3))))



 x &lt;- rfree(1,10,8,8)
 all(is.id(allconj(x) + allconj(-x)[shift(rev(seq_len(total(x))))]))



</code></pre>

<hr>
<h2 id='donames'>Names attributes of free group elements</h2><span id='topic+donames'></span><span id='topic+names'></span>

<h3>Description</h3>

<p>Get and set names of free group elements and arithmetic operations</p>


<h3>Usage</h3>

<pre><code class='language-R'>donames(f,e1,e2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="donames_+3A_f">f</code></td>
<td>
<p>A vector, typically of class <code>free</code></p>
</td></tr>
<tr><td><code id="donames_+3A_e1">e1</code>, <code id="donames_+3A_e2">e2</code></td>
<td>
<p>Objects of class <code>free</code>, possibly with names</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function <code>donames()</code> is a low-level helper function that ensures
that the result of arithmetic operations such as <code>+</code> and <code>^</code>
have the correct names attributes.  The behaviour is inherited from
that of <code>base::`+`</code>.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>See Also</h3>

<p><code><a href="#topic+Ops.free">Ops.free</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- rfree(9,4)
x
names(x) &lt;- letters[1:9]
x

z &lt;- as.free('z')
x + x 
x^z
z^x

n &lt;- 1:9
names(n) &lt;- LETTERS[1:9]

x*n
n*x  # note different names 


</code></pre>

<hr>
<h2 id='dot-class'>Class &ldquo;dot&rdquo;</h2><span id='topic+dot'></span><span id='topic+.'></span><span id='topic+dot-class'></span><span id='topic+extract'></span><span id='topic+commutator'></span><span id='topic+jacobi'></span><span id='topic+dot_error'></span><span id='topic++5B.dot'></span><span id='topic++5B+2Cdot-method'></span><span id='topic++5B+2Cdot+2CANY+2CANY-method'></span><span id='topic++5B+2Cdot+2CANY+2Cmissing-method'></span><span id='topic++5B+2Cdot+2Cmissing+2CANY-method'></span><span id='topic++5B+2Cdot+2Cmissing+2Cmissing-method'></span><span id='topic++5B+2Cdot+2Cfree+2CANY-method'></span><span id='topic++5B+2Cdot+2Cfree+2CANY+2CANY-method'></span><span id='topic++5B+2Cdot+2Cmatrix+2Cmatrix-method'></span>

<h3>Description</h3>

<p>The dot object is defined in the <a href="https://CRAN.R-project.org/package=freealg"><span class="pkg">freealg</span></a> package, and
imported here, so that idiom like <code>.[x,y]</code> returns the
commutator, that is, <code>x^-1 y^-1 xy</code>.
</p>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dot-class_+3A_x">x</code></td>
<td>
<p>Object of any class</p>
</td></tr>
<tr><td><code id="dot-class_+3A_i">i</code>, <code id="dot-class_+3A_j">j</code></td>
<td>
<p>elements to commute</p>
</td></tr>
<tr><td><code id="dot-class_+3A_...">...</code></td>
<td>
<p>Further arguments to <code>dot_error()</code>, currently ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Always returns an object of the same class as <code>xy</code>.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>Examples</h3>

<pre><code class='language-R'>
.[as.free("x"), as.free("y")]

.[abc(1:6),"z"]

x &lt;- rfree()
y &lt;- rfree()
z &lt;- rfree()

.[x,y] == -x-y+x+y   # should be TRUE

abelianize(.[x,y])

## Jacobi identity _not_ satisfied with this definition:
is.id(.[x,.[y,z]] + .[y,.[z,x]] + .[z,.[x,y]])

## But the Hall-Witt identity is:
all(is.id(.[.[x,-y],z]^y + .[.[y,-z],x]^z + .[.[z,-x],y]^x))

</code></pre>

<hr>
<h2 id='Extract'>Extract or replace parts of a free group object</h2><span id='topic+Extract.free'></span><span id='topic++5B.free'></span><span id='topic++5B+3C-.free'></span>

<h3>Description</h3>

<p>Extract or replace subsets of free objects</p>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Extract_+3A_x">x</code></td>
<td>
<p>Object of class <code>free</code></p>
</td></tr>
<tr><td><code id="Extract_+3A_index">index</code></td>
<td>
<p>elements to extract or replace</p>
</td></tr>
<tr><td><code id="Extract_+3A_value">value</code></td>
<td>
<p>replacement value</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These methods (should) work as expected: an object of class
<code>free</code> is a list but standard extraction techniques should work.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
(x &lt;- rfree(20,8,8))

x[5:6]
x[1:2]  &lt;- -x[11:12]

x[1:5] &lt;- keep(x[1:5],1:3)

</code></pre>

<hr>
<h2 id='free'>Objects of class <code>free</code></h2><span id='topic+free'></span><span id='topic+free-class'></span><span id='topic+as.free'></span><span id='topic+is.free'></span><span id='topic+list_to_free'></span>

<h3>Description</h3>

<p>Generate, and test for, objects of class <code>free</code></p>


<h3>Usage</h3>

<pre><code class='language-R'>free(x)
as.free(x)
is.free(x)
list_to_free(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="free_+3A_x">x</code></td>
<td>
<p>Function <code>free()</code> needs either a two-row matrix, or a
list of two-row matrices; function <code>as.free()</code>
attempts to coerce different types of argument before passing to
<code>free()</code> (possibly via <code>list_to_free()</code>)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The basic structure of an element of the free group is a two-row matrix.
The top row is the symbols (1=a, 2=b, 3=c, etc) and the bottom row is
the corresponding power.  Thus <code class="reqn">a^2ba^{-1}c^9</code> would be
</p>
<pre>
&gt; rbind(c(1,2,1,3),c(2,1,-1,9))
     [,1] [,2] [,3] [,4]
[1,]    1    2    1    3
[2,]    2    1   -1    9
&gt;
</pre>
<p>Function <code>free()</code> needs either a two-row matrix or a list of
two-row matrices.  It is the only place in the package that sets the
class of an object to <code>free</code>.  Function <code>as.free()</code> is a bit
more user-friendly and tries a bit harder to do the Right Thing.
</p>
<p>The package uses <code>setOldClass("free")</code> for the <code>dot</code> methods.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>See Also</h3>

<p><code><a href="#topic+char_to_free">char_to_free</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>free(rbind(1:5,5:1))

x &lt;- rfree(10,3)
x
x+x
x-x
x[1:5]*(1:5)


as.free(c(4,3,2,2,2))
as.free("aaaabccccaaaaa")
as.free(c("a","A","abAAA"))
</code></pre>

<hr>
<h2 id='getlet'>Get letters of a freegroup object</h2><span id='topic+getlet'></span>

<h3>Description</h3>

<p>Get the symbols in a freegroup object</p>


<h3>Usage</h3>

<pre><code class='language-R'>getlet(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getlet_+3A_x">x</code></td>
<td>
<p>Object of class <code>free</code></p>
</td></tr>
</table>


<h3>Note</h3>

<p>By default, return a list with elements corresponding to the elements
of <code>x</code>.  But, if object <code>x</code> is of length 1, a vector is
returned.  The result is sorted for convenience.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>Examples</h3>

<pre><code class='language-R'>
(x &lt;- rfree(6,7,3))

getlet(x)

as.free(getlet(x))  

identical(as.free(getlet(abc(1:26))), abc(1:26))

</code></pre>

<hr>
<h2 id='identity'>The identity element</h2><span id='topic+identity'></span><span id='topic+id'></span><span id='topic+is.id'></span><span id='topic+is.identity'></span><span id='topic+is.id.free'></span><span id='topic+neutral'></span>

<h3>Description</h3>

<p>Create and test for the identity element</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.id(x)
id(n)
## S3 method for class 'free'
is.id(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="identity_+3A_x">x</code></td>
<td>
<p>Object of class <code>free</code></p>
</td></tr>
<tr><td><code id="identity_+3A_n">n</code></td>
<td>
<p>Strictly positive integer</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function <code>id()</code> returns a vector of <code>n</code> free objects, all of
which are the identity element.  Do not ask what happens if <code class="reqn">n=0</code>.
</p>
<p>Function <code>is.id()</code> returns a Boolean indicating whether an element
is the identity or not.  The identity can also be generated using
<code>as.free(0)</code>.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>Examples</h3>

<pre><code class='language-R'>id()
as.free(0)   # convenient R idiom for creating the identity

x &lt;- rfree(10,3)
stopifnot(all(x == x + as.free(0)))
stopifnot(all(is.id(x-x)))

</code></pre>

<hr>
<h2 id='keep'>Keep or drop symbols</h2><span id='topic+keep'></span><span id='topic+discard'></span><span id='topic+drop'></span><span id='topic+retain'></span><span id='topic+drop.free'></span>

<h3>Description</h3>

<p>Keep or drop symbols</p>


<h3>Usage</h3>

<pre><code class='language-R'>keep(a, yes)
discard(a, no)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="keep_+3A_a">a</code></td>
<td>
<p>Object of class <code>free</code></p>
</td></tr>
<tr><td><code id="keep_+3A_yes">yes</code>, <code id="keep_+3A_no">no</code></td>
<td>
<p>Specification of symbols to either keep (yes) or discard 
(no), coerced to a free object</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Function <code>keep()</code> needs an explicit <code>return()</code> to prevent it
from returning invisibly.
</p>
<p>The functions are vectorised in the first argument but not the
second.
</p>
<p>The second argument&mdash;the symbols to keep or discard&mdash;is formally a
vector of nonnegative integers, but the functions coerce it to a free
object.  The symbols kept or dropped are the union of the symbols in
the elements of the vector.  Function <code>discard()</code> was formerly
known as <code>drop()</code> but this conflicted with <code>base::drop()</code>.
</p>
<p>These functions have nothing in common with APL's <code>take()</code> and
<code>drop()</code>.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>Examples</h3>

<pre><code class='language-R'>(x &lt;- rfree(20,5,8))

keep(x,abc(4))           # keep only symbols a,b,c,d
discard(x,as.free('cde'))   # drop symbols c,d,e

keep(x,alpha(3))  # keep only abc 

</code></pre>

<hr>
<h2 id='nielsen'>Outer automorphisms of the free group</h2><span id='topic+nielsen'></span><span id='topic+outer'></span><span id='topic+automorphism'></span><span id='topic+automorphisms'></span><span id='topic+permsymb_single_X'></span><span id='topic+permsymb_single_f'></span><span id='topic+permsymb_vec'></span><span id='topic+permsymb'></span><span id='topic+autosub_lowlevel'></span><span id='topic+autosub'></span>

<h3>Description</h3>

<p>Vectorized functionality to implement outer automorphisms
of the free group</p>


<h3>Usage</h3>

<pre><code class='language-R'>permsymb_single_X(X,f)
permsymb_single_f(X,f)
permsymb_vec(X,f)
permsymb(X,f)
autosub_lowlevel(M,e,S)
autosub(X,e,S,automorphism_warning=TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nielsen_+3A_x">X</code>, <code id="nielsen_+3A_s">S</code></td>
<td>
<p>Object of class <code>free</code></p>
</td></tr>
<tr><td><code id="nielsen_+3A_f">f</code></td>
<td>
<p>Permutation function</p>
</td></tr>
<tr><td><code id="nielsen_+3A_m">M</code></td>
<td>
<p>Single free group element, in two-row matrix form</p>
</td></tr>
<tr><td><code id="nielsen_+3A_e">e</code></td>
<td>
<p>Single element to substitute</p>
</td></tr>
<tr><td><code id="nielsen_+3A_automorphism_warning">automorphism_warning</code></td>
<td>
<p>Boolean, with default <code>TRUE</code> meaning
to give a warning if the requested substitution is not an
automorphism and <code>FALSE</code> meaning not to give the warning</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In 1924, Nielsen showed that the automorphism group of the free group
with basis <code class="reqn">[x_1,\ldots,x_n]</code> is generated by the
following four elementary Nielsen transformations:
</p>

<ol>
<li><p> switch <code class="reqn">x_1</code> and <code class="reqn">x_2</code>
</p>
</li>
<li><p> Cyclically permute <code class="reqn">x_1,x_2,\ldots,x_n</code>
to <code class="reqn">x_2,\ldots,x_n,x_1</code>
</p>
</li>
<li><p> Replace <code class="reqn">x_1</code> with <code class="reqn">x_1^{-1}</code>
</p>
</li>
<li><p> Replace <code class="reqn">x_1</code> with <code class="reqn">x_1x_2</code>.
</p>
</li></ol>

<p>The functions documented here give vectorized methods to effect such
outer automorphisms, using the <a href="https://CRAN.R-project.org/package=permutations"><span class="pkg">permutations</span></a> package.
</p>
<p>Operations 1 and 2 above generate the symmetric group <code class="reqn">S_n</code> and such
automorphisms are effected by function <code>permsymb()</code>.  Operation
3 is carried out by by <code>flip()</code> and operation 4 by <code>subsymb()</code>.
</p>
<p>Functions <code>permsymb_single_X()</code>, <code>permsymb_single_f()</code>,
<code>permsymb_vec()</code> and <code>subsymb_lowlevel()</code> are low-level helper
functions that are not really suited for the end user; use
<code>permsymb()</code>, <code>(flip)</code> and <code>subsymb()</code> instead.
</p>


<h3>Note</h3>

<p>Function <code>permsymb()</code> is intended to work nicely with the
<a href="https://CRAN.R-project.org/package=permutations"><span class="pkg">permutations</span></a> package; see <code>inst/outer.Rmd</code> for some
illustrations.  The function is not perfect. </p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>References</h3>

<p>Wikipedia contributors. (2018, October 29).  &ldquo;Automorphism
group of a free group&rdquo;. In <em>Wikipedia, The Free
Encyclopedia</em>. Retrieved 19:58, January 10, 2019, from
<a href="https://en.wikipedia.org/w/index.php?title=Automorphism_group_of_a_free_group&amp;oldid=866270661">https://en.wikipedia.org/w/index.php?title=Automorphism_group_of_a_free_group&amp;oldid=866270661</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+flip">flip</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
P &lt;- as.free(c("abc","aba","cc","ca"))
autosub(P,"c",as.free("xyz"))

flip(P,"c")
flip(P,"ac")



</code></pre>

<hr>
<h2 id='Ops.free'>Arithmetic Ops methods for the free group</h2><span id='topic+Ops.free'></span><span id='topic+ops'></span><span id='topic+free_equal'></span><span id='topic+free_power'></span><span id='topic+free_repeat'></span><span id='topic+juxtapose'></span><span id='topic+inverse'></span><span id='topic+inverse.free'></span><span id='topic+inverse.matrix'></span>

<h3>Description</h3>

<p>Allows arithmetic operators to be used for manipulation of free group elements
such as addition, multiplication, powers, etc
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'free'
Ops(e1, e2)
free_equal(e1,e2)
free_power(e1,e2)
free_repeat(e1,n)
juxtapose(e1,e2)
## S3 method for class 'free'
inverse(e1)
## S3 method for class 'matrix'
inverse(e1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Ops.free_+3A_e1">e1</code>, <code id="Ops.free_+3A_e2">e2</code></td>
<td>
<p>Objects of class <code>free</code></p>
</td></tr>
<tr><td><code id="Ops.free_+3A_n">n</code></td>
<td>
<p>An integer, possibly non-positive</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>Ops.free()</code> passes binary arithmetic operators
(&ldquo;<code>+</code>&rdquo;, &ldquo;<code>-</code>&rdquo;, &ldquo;<code>*</code>&rdquo;,
&ldquo;<code>^</code>&rdquo;, and &ldquo;<code>==</code>&rdquo;) to the appropriate
specialist function.
</p>
<p>There are two non-trivial basic operations: juxtaposition, denoted
&ldquo;<code>a+b</code>&rdquo;, and inversion, denoted &ldquo;<code>-a</code>&rdquo;.  Note
that juxtaposition is noncommutative and <code>a+b</code> will not, in
general, be equal to <code>b+a</code>.
</p>
<p>All operations return a reduced word.
</p>
<p>The caret, as in <code>a^b</code>, denotes group-theoretic exponentiation
(<code>-b+a+b</code>); the notation is motivated by the identities
<code>x^(yz) == (x^y)^z</code> and <code>(xy)^z == x^z * y^z</code>, as in the
<code>permutations</code> package.
</p>
<p><strong>As an experimental feature</strong> the package now accepts
multiplicative notation, so these identities manifest in package idiom
as written.  However, this renders distributivity incorrect so that
<code>x*(y + z)</code> and <code>x*y + x*z</code> are not equal, in general
[distributivity manifests as <code>x*c(y, z) == c(x*y, x*z)</code>].
</p>
<p>Multiplication between a free object <code>a</code> and an integer <code>n</code>
(as in <code>a*n</code> or <code>n*a</code>) is defined as juxtaposing <code>n</code>
copies of <code>a</code> and reducing.  Zero and negative values of <code>n</code>
work as expected.
</p>
<p>Comparing a <code>free</code> object with a numeric does not make sense and
idiom such as <code>rfree() &gt; 4</code> will return an error.  Comparing a
<code>free</code> object with another <code>free</code> object might be desirable
[specifically, lexicographic ordering], but is not currently
implemented.
</p>


<h3>Note</h3>

<p>The package uses additive notation but multiplicative notation might
have been better.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>Examples</h3>

<pre><code class='language-R'>

x &lt;- as.free(c("a","ab","aaab","abacc"))
y &lt;- as.free(c("aa","BA","Bab","aaaaa"))
x
y


x + x
x + y
x + as.free("xyz")

x+y == y+x    # not equal in  general

x*5 == x+x+x+x+x      # always true

x + alpha(26)

x^y
</code></pre>

<hr>
<h2 id='primitive'>Primitive elements of the free algebra</h2><span id='topic+primitive'></span><span id='topic+is.primitive'></span><span id='topic+is.power'></span>

<h3>Description</h3>

<p>A <dfn>primitive word</dfn> is one that is not of the form <code>a^m</code> for
any <code class="reqn">m&gt;1</code>.  The concept is used in Lyndon and Schutzenberger 1962.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.primitive(x)
is.power(d,n)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="primitive_+3A_x">x</code></td>
<td>
<p>Freegroup object, coerced to Tietze form</p>
</td></tr>
<tr><td><code id="primitive_+3A_d">d</code></td>
<td>
<p>Numeric vector</p>
</td></tr>
<tr><td><code id="primitive_+3A_n">n</code></td>
<td>
<p>Integer</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function <code>is.primitive()</code> returns a boolean vector indicating
whether the elements of its argument are primitive.
</p>
<p>Function <code>is.power()</code> is a lower-level helper function.
<code>is.power(d,n)</code> determines whether <code>d</code> is an <code>n</code>-th power
(that is, <code>d</code> may be written as <code>n</code> copies of some numeric
vector).
</p>
<p>Thus <code>is_power(c(4,5,7,4,5,7,4,5,7,4,5,7),4)</code> returns <code>TRUE</code>
because its primary argument is indeed a fourth power (of
<code>c(4,5,7)</code>).
</p>


<h3>Value</h3>

<p>Returns a boolean.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin.  The code for finding the factors of an integer
was (somewhat more than) inspired by the <a href="https://CRAN.R-project.org/package=numbers"><span class="pkg">numbers</span></a> package.
</p>


<h3>References</h3>

<p>R. C. Lyndon and M. P. Schutzenberger 1962.  &ldquo;The equation
<code class="reqn">a^M=b^Nc^P</code> in a free group&rdquo;.  Michigan Mathematical Journal,
9(4): 289&ndash;298.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
is.primitive(as.free(c("a","aaaa", "aaaab", "aabaab", "aabcaabcaabcaabc")))

is.power(c(7,8,4,7,8,4,7,8,4,7,8,4),4)


table(is.primitive(rfree(100)))


## primitive with &gt;1 symbols is rare:
x &lt;- rfree(1000)
x[!is.primitive(x) &amp; number(x)&gt;1]
##  try x &lt;- rfree(10000) [but this takes a long time]


</code></pre>

<hr>
<h2 id='print'>Print free objects</h2><span id='topic+print.free'></span><span id='topic+print.freegroup'></span><span id='topic+as.character_free'></span>

<h3>Description</h3>

<p>Print methods for free objects</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'free'
print(x,...)
as.character_free(m,latex=getOption("latex"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print_+3A_x">x</code></td>
<td>
<p>Object of class <code>free</code> in the print method</p>
</td></tr>
<tr><td><code id="print_+3A_m">m</code></td>
<td>
<p>A two-row matrix in function <code>as.character_free()</code></p>
</td></tr>
<tr><td><code id="print_+3A_latex">latex</code></td>
<td>
<p>Boolean, with <code>TRUE</code> meaning to print latex-friendly
output including curly braces, and default <code>NULL</code> option
meaning to give a nicer-looking output that latex would typeset
incorrectly</p>
</td></tr>
<tr><td><code id="print_+3A_...">...</code></td>
<td>
<p>Further arguments, currently ignored</p>
</td></tr>
</table>


<h3>Note</h3>

<p>The print method does not change the internal representation of a
<code>free</code> object, which is a list of integer matrices.
</p>
<p>The default print method uses multiplicative notation (powers) which is
inconsistent with the juxtaposition method &ldquo;<code>+</code>&rdquo;.
</p>
<p>The print method has special dispensation for length-zero free objects
but these are not handled entirely consistently.
</p>
<p>The default print method uses lowercase letters a-z, but it is possible
to override this using <code>options("freegroup_symbols" = foo)</code>, where
<code>foo</code> is a character vector.  This is desirable if you have more
than 26 symbols, because unallocated symbols appear as <code>NA</code>.
</p>
<p>The package will allow the user to set
<code>options("freegroup_symbols")</code> to unhelpful things like
<code>rep("a",20)</code> without complaining (but don't actually do it, you
crazy fool).
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>See Also</h3>

<p><code><a href="#topic+char_to_free">char_to_free</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
## default symbols:

abc(26)
rfree(1,10)


# if we need more than 26:
options(freegroup_symbols=state.name)
rfree(10,4)

# or even:
jj &lt;- letters[1:10]
options(freegroup_symbols=apply(expand.grid(jj,jj),1,paste,collapse=""))
rfree(10,10,100,4)

options(freegroup_symbols=NULL)  #  NULL is interpreted as letters a-z
rfree(10,4)            #  back to normal
</code></pre>

<hr>
<h2 id='reduce'>Reduction of a word to reduced form</h2><span id='topic+reduce'></span><span id='topic+remove_zero_powers'></span><span id='topic+is_reduced'></span><span id='topic+consolidate'></span><span id='topic+is_proper'></span>

<h3>Description</h3>

<p>Given a word, remove redundant zero-power terms, and
consolidate adjacent like terms into a single power</p>


<h3>Usage</h3>

<pre><code class='language-R'>reduce(a)
is_reduced(a)
remove_zero_powers(a)
consolidate(a)
is_proper(a)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="reduce_+3A_a">a</code></td>
<td>
<p>An object of class <code>free</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>A word is <dfn>reduced</dfn> if no symbol appears next to its own inverse
and no symbol has zero power.  The essence of the package is to reduce
a word into a reduced form.  Thus <code class="reqn">a^2b^{-1}ba</code> will
transformed into <code class="reqn">a^3</code>.
</p>
<p>In the package, reduction happens automatically at creation, in
function <code>free()</code>.
</p>
<p>Apart from <code>is_proper()</code>, the functions all take a <code>free</code>
object, but the meat of the function operates on a single two-row
matrix.
</p>
<p>Reduction is carried out by repeatedly consolidating adjacent terms of
identical symbol (function <code>consolidate()</code>), and removing zero
power terms (function <code>remove_zero_power()</code>) until the word is in
reduced form (function <code>is_reduced()</code>).
</p>
<p>Function <code>is_proper()</code> checks to see whether a matrix is suitably
formed for passing to <code>reduce()</code>.
</p>
<p>A <code>free</code> object is <dfn>cyclically reduced</dfn> iff every cyclic
permutation of the word is reduced.  A reduced word is cyclically
reduced iff the first letter is not the inverse of the last one.  A
reduced word is cyclically reduced if the first and last symbol differ
(irrespective of power) or, if identical, have powers of opposite
sign.  For example, <code>abac</code> and <code>abca</code> are cyclically reduced
but <code>abca^{-1}</code> is not.  Function <code>is.cyclically.reduced()</code>
tests for this, documented at <code>cycred.Rd</code>.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>See Also</h3>

<p><code><a href="#topic+cycred">cycred</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
## create a matrix:
(M &lt;- rbind(c(1,2,3,3,2,3,2,1),c(1,2,3,-3,5,0,7,0)))

## call the print method (note non-reduced form):
as.character_free(M)

## show the effect of reduce():
as.character_free(reduce(M))

## free() calls reduce() automatically:
free(M)
</code></pre>

<hr>
<h2 id='rfree'>Random free objects</h2><span id='topic+rfree'></span><span id='topic+rfreee'></span><span id='topic+rfreeee'></span>

<h3>Description</h3>

<p>Creates a vector of random free objects.  Intended as a
quick &ldquo;get you going&rdquo; example of free group objects</p>


<h3>Usage</h3>

<pre><code class='language-R'>rfree(n = 7, size = 4, number = size, powers = seq(from = -size, to = size))
rfreee(n = 30, size = 8, number = size, powers = seq(from = -size, to = size))
rfreeee(n = 40, size = 25, number = size, powers = seq(from = -size, to = size))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rfree_+3A_n">n</code></td>
<td>
<p>Length of random vector to generate</p>
</td></tr>
<tr><td><code id="rfree_+3A_size">size</code></td>
<td>
<p>Maximum length of each element</p>
</td></tr>
<tr><td><code id="rfree_+3A_number">number</code></td>
<td>
<p>How many distinct letters to sample from</p>
</td></tr>
<tr><td><code id="rfree_+3A_powers">powers</code></td>
<td>
<p>Powers in resulting polynomial.  An integer <code>n</code> is
interpreted (via <code>sample()</code>) as <code>seq_len(n)</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The auxiliary arguments specify the general complexity of the returned
object with small meaning simpler.
</p>
<p>Functions <code>rfreee()</code> and <code>rfreeee()</code> give, by default,
successively more complicated expressions.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>See Also</h3>

<p><code><a href="#topic+size">size</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
rfree()

abelianize(rfree())

rfree(10,2)
rfree(10,30,26)

rfree(powers=5)
rfree(powers=5:6)

rfree(20,2)^alpha(26)

</code></pre>

<hr>
<h2 id='shift'>Permute elements of a vector in a cycle</h2><span id='topic+shift'></span>

<h3>Description</h3>

<p>Given a vector, permute the elements with a cyclic permutation</p>


<h3>Usage</h3>

<pre><code class='language-R'>shift(x,i=1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="shift_+3A_x">x</code></td>
<td>
<p>Vector</p>
</td></tr>
<tr><td><code id="shift_+3A_i">i</code></td>
<td>
<p>Integer, number of places to permute.  Negative values mean
to count from the end</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is that of the <a href="https://CRAN.R-project.org/package=magic"><span class="pkg">magic</span></a> package, where it is
motivated and discussed.
</p>


<h3>Value</h3>

<p>Returns a vector</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>Examples</h3>

<pre><code class='language-R'>
shift(1:9)
shift(1:9,-1)

shift(1:9,2)


</code></pre>

<hr>
<h2 id='size'>
Bignesses of a free object</h2><span id='topic+size'></span><span id='topic+total'></span><span id='topic+number'></span><span id='topic+bigness'></span>

<h3>Description</h3>

<p>Various metrics to describe how &ldquo;big&rdquo; a free object is</p>


<h3>Usage</h3>

<pre><code class='language-R'>size(a)
total(a)
number(a)
bigness(a)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="size_+3A_a">a</code></td>
<td>
<p>Vector of free group objects</p>
</td></tr>
</table>


<h3>Details</h3>


<ul>
<li><p> The <dfn>size</dfn> of an object is the number of pure powers in
it (this is the number of columns of the matrix representation of
the word)
</p>
</li>
<li><p> The <dfn>total</dfn> of an object is the sum of the absolute
values of its powers
</p>
</li>
<li><p> The <dfn>number</dfn> of an object is the number of distinct symbols
in it
</p>
</li></ul>

<p>Thus <code>size(a^2ba)=3</code>, <code>total(a^2ba)=4</code>, and
<code>number(a^2ba)=2</code>.
</p>
<p>Function <code>bigness()</code> is a convenience wrapper that returns all
three bigness measures.
</p>


<h3>Value</h3>

<p>These functions return an integer vector.</p>


<h3>Note</h3>

<p>I would like to thank Murray Jorgensen for his insightful comments which
inspired this functionality.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>See Also</h3>

<p><code><a href="#topic+abs">abs</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
(a &lt;- rfree(20,6,4))
size(a)
total(a)
number(a)

a &lt;- rfree(20,6,4)
b &lt;- rfree(20,6,4)

## Following should all be TRUE
size(a+b)   &lt;= size(a)  + size(b)
total(a+b)  &lt;= total(a) + total(b)
number(a+b) &lt;= number(a)+ number(b)

bigness(rfree(10,3,3))
bigness(allconj(rfree(1,6,1)))

</code></pre>

<hr>
<h2 id='subs'>Substitute and invert symbols</h2><span id='topic+subs'></span><span id='topic+subsu'></span><span id='topic+flip'></span>

<h3>Description</h3>

<p>Substitute and invert specific symbols in a free object</p>


<h3>Usage</h3>

<pre><code class='language-R'>subsu(X, from, to)
subs(X, ...)
flip(X, turn)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="subs_+3A_x">X</code></td>
<td>
<p>Object of class <code>free</code></p>
</td></tr>
<tr><td><code id="subs_+3A_from">from</code>, <code id="subs_+3A_to">to</code>, <code id="subs_+3A_turn">turn</code></td>
<td>
<p>Objects coerced to class <code>free</code> specifying symbols
to alter.  These arguments are coerced to symbols using
<code>getlet(as.free())</code></p>
</td></tr>
<tr><td><code id="subs_+3A_...">...</code></td>
<td>
<p>Named arguments for substitution</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function <code>subsu(X,from,to)</code> takes object <code>X</code> and transforms
every symbol present in <code>from</code> into the symbol specified in
<code>to</code>.
</p>
<p>Function <code>flip(X,turn)</code> takes object <code>X</code> and replaces every
symbol present in <code>turn</code> with its inverse.
</p>
<p>Function <code>discard()</code>, documented at <code>keep.Rd</code>, effectively
substitutes a symbol with the identity element (thereby discarding
it).
</p>
<p>Experimental function <code>subs()</code> is modelled on similar
functionality in the <a href="https://CRAN.R-project.org/package=freealg"><span class="pkg">freealg</span></a> package and makes idiom such as
<code>subs(X,a='z')</code> work as expected (viz, taking each instance of
symbol <code>a</code> and replacing it with <code>x</code>).
</p>


<h3>Note</h3>

<p>Functions <code>subs()</code> and <code>subsu()</code> substitute for particular
symbols, not free group elements.  In particular, be careful with
uppercase (inverse) symbols; because the power is discarded,
substituting with <code>x</code> is the same as substituting for <code>X</code>.
This behaviour might change in the future.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>See Also</h3>

<p><code><a href="#topic+abs">abs</a></code>,<code><a href="#topic+discard">discard</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
subsu(abc(1:10),abc(5),'z')
flip(abc(1:10),abc(5))


o &lt;- rfree(30,5,10)

# Following tests should all be TRUE:
size(flip(o,'a'))   == size(o)
number(flip(o,'a')) == number(o)
total(flip(o,'a'))  == total(o)

size(subsu(o,'a','b'))   &lt;= size(o)
number(subsu(o,'a','b')) &lt;= number(o)
total(subsu(o,'a','b'))  &lt;= total(o)


frog &lt;- rfree()
subs(frog,a='x')

</code></pre>

<hr>
<h2 id='sum'>Repeated summation by concatenation</h2><span id='topic+sum'></span><span id='topic+sum.free'></span><span id='topic+prodfree'></span><span id='topic+freeprod'></span>

<h3>Description</h3>

<p>Concatenates its arguments to give a single free object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'free'
sum(..., na.rm = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sum_+3A_...">...</code></td>
<td>
<p>Objects of class <code>free</code>, to be summed</p>
</td></tr>
<tr><td><code id="sum_+3A_na.rm">na.rm</code></td>
<td>
<p>Boolean, indicating whether to ignore <code>NA</code> entries
(currently ignored)</p>
</td></tr>    
</table>


<h3>Details</h3>

<p>Concatenates its arguments and gives a single element of the free
group.  It works nicely with <code>rev()</code>, see the examples.
</p>


<h3>Note</h3>

<p>The package uses additive notation, but it is easy to forget this and
wonder why idiom like <code>prod(rfree())</code> does not work as desired.  Of
course, the package using additive notation means that one probably
wants <code>sum(rfree())</code>.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>Examples</h3>

<pre><code class='language-R'>
(x &lt;- rfree(10,3))
sum(x)
abelianize(sum(x))

(y &lt;- rfree(10,6))

sum(x,y)
sum(x,y) == sum(sum(x),sum(y))
x+y  # not the same!

sum(x,-x)
sum(x,rev(-x))

z &lt;- alpha(26)
stopifnot(sum(x^z) == sum(x)^z)

</code></pre>

<hr>
<h2 id='tietze'>Tietze form for free group objects</h2><span id='topic+tietze'></span><span id='topic+Tietze'></span><span id='topic+tietze.matrix'></span><span id='topic+tietze.free'></span><span id='topic+vec_to_matrix'></span>

<h3>Description</h3>

<p>Translate an object of class <code>free</code> to and from Tietze form</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'free'
tietze(x)
## S3 method for class 'matrix'
tietze(x)
vec_to_matrix(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tietze_+3A_x">x</code></td>
<td>
<p>Object to be converted</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Tietze form for a word is a list of integers corresponding to the
symbols of the word; typically <code class="reqn">a=1,b=2,c=3,d=4</code>, etc.  Negative
integers represent the inverses of the symbols.  Thus
<code>c^4.d^-2.a.c</code> becomes <code>3 3 3 3 -4 -4 1 3</code>.
</p>
<p>Function <code>vec_to_matrix()</code> is a low-level helper function that
returns a two-row integer matrix.  If given <code>0</code> or <code>NULL</code>,
it returns a two-row, zero-column matrix.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>Examples</h3>

<pre><code class='language-R'>
(x &lt;- rfree(10,3))
tietze(x)

vec_to_matrix(c(1,3,-1,-1,-1,2))

as.free(list(c(1,1,8),c(2,-4,-4)))

all(as.free(tietze(abc(1:30))) == abc(1:30))

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
