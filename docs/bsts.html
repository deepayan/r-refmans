<!DOCTYPE html><html><head><title>Help for package bsts</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {bsts}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#add.ar'>
<p>AR(p) state component</p></a></li>
<li><a href='#add.dynamic.regression'>
<p>Dynamic Regression State Component</p></a></li>
<li><a href='#add.local.level'>
<p>Local level trend state component</p></a></li>
<li><a href='#add.local.linear.trend'>
<p>Local linear trend state component</p></a></li>
<li><a href='#add.monthly.annual.cycle'><p>Monthly Annual Cycle State Component</p></a></li>
<li><a href='#add.random.walk.holiday'>
<p>Random Walk Holiday State Model</p></a></li>
<li><a href='#add.seasonal'>
<p>Seasonal State Component</p></a></li>
<li><a href='#add.semilocal.linear.trend'><p>Semilocal Linear Trend</p></a></li>
<li><a href='#add.shared.local.level'>
<p>Local level trend state component</p></a></li>
<li><a href='#add.static.intercept'>
<p>Static Intercept State Component</p></a></li>
<li><a href='#add.student.local.linear.trend'>
<p>Robust local linear trend</p></a></li>
<li><a href='#add.trig'>
<p>Trigonometric Seasonal State Component</p></a></li>
<li><a href='#aggregate.time.series'><p>Aggregate a fine time series to a coarse summary</p></a></li>
<li><a href='#aggregate.weeks.to.months'><p>Aggregate a weekly time series to monthly</p></a></li>
<li><a href='#auto.ar'>
<p>Sparse AR(p)</p></a></li>
<li><a href='#bsts'><p>Bayesian Structural Time Series</p></a></li>
<li><a href='#bsts-package'>
<p>bsts</p></a></li>
<li><a href='#bsts.options.Rd'><p>Bsts Model Options</p></a></li>
<li><a href='#compare.bsts.models'>
<p>Compare bsts models</p></a></li>
<li><a href='#date.range'>
<p>Date Range</p></a></li>
<li><a href='#descriptive-plots'><p>Descriptive Plots</p></a></li>
<li><a href='#diagnostic-plots'><p>Diagnostic Plots</p></a></li>
<li><a href='#dirm'><p>Dynamic intercept regression model</p></a></li>
<li><a href='#dirm-model-optoins'><p>Specify Options for a Dynamic Intercept Regression Model</p></a></li>
<li><a href='#estimate.time.scale'><p>Intervals between dates</p></a></li>
<li><a href='#extend.time'>
<p>Extends a vector of dates to a given length</p></a></li>
<li><a href='#format.timestamps'><p>Checking for Regularity</p></a></li>
<li><a href='#gdp'><p>Gross Domestic Product for 57 Countries</p></a></li>
<li><a href='#geometric.sequence'>
<p>Create a Geometric Sequence</p></a></li>
<li><a href='#get.fraction'>
<p>Compute membership fractions</p></a></li>
<li><a href='#goog'><p>Google stock price</p></a></li>
<li><a href='#HarveyCumulator'><p>HarveyCumulator</p></a></li>
<li><a href='#holiday'>
<p>Specifying Holidays</p></a></li>
<li><a href='#iclaims'><p>Initial Claims Data</p></a></li>
<li><a href='#last.day.in.month'><p>Find the last day in a month</p></a></li>
<li><a href='#MATCH.NumericTimestamps'><p>Match Numeric Timestamps</p></a></li>
<li><a href='#match.week.to.month'>
<p>Find the month containing a week</p></a></li>
<li><a href='#max.window.width'><p>Maximum Window Width for a Holiday</p></a></li>
<li><a href='#mbsts'><p>Multivariate Bayesian Structural Time Series</p></a></li>
<li><a href='#mixed.frequency'><p>Models for mixed frequency time series</p></a></li>
<li><a href='#month.distance'><p>Elapsed time in months</p></a></li>
<li><a href='#named.holidays'><p>Holidays Recognized by Name</p></a></li>
<li><a href='#new.home.sales'><p>New home sales and Google trends</p></a></li>
<li><a href='#one.step.prediction.errors'><p>Prediction Errors</p></a></li>
<li><a href='#plot.bsts'><p>Plotting functions for Bayesian structural time series</p></a></li>
<li><a href='#plot.bsts.mixed'><p>Plotting functions for mixed frequency Bayesian structural time series</p></a></li>
<li><a href='#plot.bsts.prediction'><p>Plot predictions from Bayesian structural time series</p></a></li>
<li><a href='#plot.bsts.predictors'><p>Plot the most likely predictors</p></a></li>
<li><a href='#plot.holiday'><p>Plot Holiday Effects</p></a></li>
<li><a href='#plot.mbsts'><p>Plotting Functions for Multivariate Bayesian Structural Time Series</p></a></li>
<li><a href='#plot.mbsts.prediction'><p>Plot Multivariate Bsts Predictions</p></a></li>
<li><a href='#predict.bsts'><p>Prediction for Bayesian Structural Time Series</p></a></li>
<li><a href='#predict.mbsts'><p>Prediction for Multivariate Bayesian Structural Time Series</p></a></li>
<li><a href='#quarter'><p>Find the quarter in which a date occurs</p></a></li>
<li><a href='#regression.holiday'>
<p>Regression Based Holiday Models</p></a></li>
<li><a href='#regularize.timestamps'><p>Produce a Regular Series of Time Stamps</p></a></li>
<li><a href='#residuals.bsts'><p>Residuals from a bsts Object</p></a></li>
<li><a href='#rsxfs'><p>Retail sales, excluding food services</p></a></li>
<li><a href='#shark'><p>Shark Attacks in Florida.</p></a></li>
<li><a href='#shorten'>
<p>Shorten long names</p></a></li>
<li><a href='#simulate.fake.mixed.frequency.data'><p>Simulate fake mixed frequency data</p></a></li>
<li><a href='#spike.slab.ar.prior'>
<p>Spike and Slab Priors for AR Processes</p></a></li>
<li><a href='#state.sizes'>
<p>Compute state dimensions</p></a></li>
<li><a href='#StateSpecification'>
<p>Add a state component to a Bayesian structural time series model</p></a></li>
<li><a href='#SuggestBurn'><p>Suggested burn-in size</p></a></li>
<li><a href='#summary.bsts'><p>Summarize a Bayesian structural time series object</p></a></li>
<li><a href='#to.posixt'><p>Convert to POSIXt</p></a></li>
<li><a href='#turkish'><p>Turkish Electricity Usage</p></a></li>
<li><a href='#week.ends'>
<p>Check to see if a week contains the end of a month or quarter</p></a></li>
<li><a href='#weekday.names'><p>Days of the Week</p></a></li>
<li><a href='#wide.to.long'>
<p>Convert Between Wide and Long Format</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>0.9.10</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-01-16</td>
</tr>
<tr>
<td>Title:</td>
<td>Bayesian Structural Time Series</td>
</tr>
<tr>
<td>Author:</td>
<td>Steven L. Scott &lt;steve.the.bayesian@gmail.com&gt;</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Steven L. Scott &lt;steve.the.bayesian@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Time series regression using dynamic linear models fit using
  MCMC. See Scott and Varian (2014) &lt;<a href="https://doi.org/10.1504%2FIJMMNO.2014.059942">doi:10.1504/IJMMNO.2014.059942</a>&gt;, among many
  other sources.</td>
</tr>
<tr>
<td>Depends:</td>
<td>BoomSpikeSlab (&ge; 1.2.6), zoo (&ge; 1.8), xts, Boom (&ge; 0.9.13),
R(&ge; 3.4.0)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Boom (&ge; 0.9.13)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/LGPL-2.1">LGPL-2.1</a> | <a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-01-16 23:31:15 UTC; steve</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-01-17 13:02:07 UTC</td>
</tr>
</table>
<hr>
<h2 id='add.ar'>
AR(p) state component
</h2><span id='topic+AddAr'></span>

<h3>Description</h3>

<p>Add an AR(p) state component to the state specification.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AddAr(state.specification,
      y,
      lags = 1,
      sigma.prior,
      initial.state.prior = NULL,
      sdy)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add.ar_+3A_state.specification">state.specification</code></td>
<td>
<p>A list of state components.  If omitted,
an empty list is assumed.</p>
</td></tr>
<tr><td><code id="add.ar_+3A_y">y</code></td>
<td>
<p>  A numeric vector.  The time series to be modeled.</p>
</td></tr>
<tr><td><code id="add.ar_+3A_lags">lags</code></td>
<td>
<p>The number of lags (&quot;p&quot;) in the AR(p) process.</p>
</td></tr>
<tr><td><code id="add.ar_+3A_sigma.prior">sigma.prior</code></td>
<td>
<p>An object created by SdPrior.  The prior for
the standard deviation of the process increments.</p>
</td></tr>
<tr><td><code id="add.ar_+3A_initial.state.prior">initial.state.prior</code></td>
<td>
<p> An object of class MvnPrior describing the
values of the state at time 0.  This argument can be <code>NULL</code>,
in which case the stationary distribution of the AR(p) process
will be used as the initial state distribution.</p>
</td></tr>
<tr><td><code id="add.ar_+3A_sdy">sdy</code></td>
<td>
<p>The sample standard deviation of the time series to be
modeled.  Used to scale the prior distribution.  This can be omitted
if <code>y</code> is supplied.  </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The model is
</p>
<p style="text-align: center;"><code class="reqn">\alpha_{t} = \phi_1\alpha_{i, t-1} + \cdots + \phi_p
    \alpha_{t-p} + \epsilon_{t-1} \qquad
    \epsilon_t \sim \mathcal{N}(0, \sigma^2)</code>
</p>

<p>The state consists of the last <code>p</code> lags of <code>alpha</code>.  The
state transition matrix has <code>phi</code> in its first row, ones along
its first subdiagonal, and zeros elsewhere.  The state variance matrix
has <code>sigma^2</code> in its upper left corner and is zero elsewhere.
The observation matrix has 1 in its first element and is zero
otherwise.
</p>


<h3>Value</h3>

<p> Returns <code>state.specification</code> with an AR(p) state component
added to the end.</p>


<h3>Author(s)</h3>

<p>Steven L. Scott <a href="mailto:steve.the.bayesian@gmail.com">steve.the.bayesian@gmail.com</a>
</p>


<h3>References</h3>

<p>Harvey (1990), &quot;Forecasting, structural time series, and the Kalman
filter&quot;, Cambridge University Press.
</p>
<p>Durbin and Koopman (2001), &quot;Time series analysis by state space
methods&quot;, Oxford University Press.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bsts">bsts</a></code>.
<code><a href="Boom.html#topic+SdPrior">SdPrior</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 100
residual.sd &lt;- .001

# Actual values of the AR coefficients
true.phi &lt;- c(-.7, .3, .15)
ar &lt;- arima.sim(model = list(ar = true.phi),
                n = n,
                sd = 3)

## Layer some noise on top of the AR process.
y &lt;- ar + rnorm(n, 0, residual.sd)
ss &lt;- AddAr(list(), lags = 3, sigma.prior = SdPrior(3.0, 1.0))

# Fit the model with knowledge with residual.sd essentially fixed at the
# true value.
model &lt;- bsts(y, state.specification=ss, niter = 500, prior = SdPrior(residual.sd, 100000))

# Now compare the empirical ACF to the true ACF.
acf(y, lag.max = 30)
points(0:30, ARMAacf(ar = true.phi, lag.max = 30), pch = "+")
points(0:30, ARMAacf(ar = colMeans(model$AR3.coefficients), lag.max = 30))
legend("topright", leg = c("empirical", "truth", "MCMC"), pch = c(NA, "+", "o"))
</code></pre>

<hr>
<h2 id='add.dynamic.regression'>
Dynamic Regression State Component
</h2><span id='topic+AddDynamicRegression'></span><span id='topic+DynamicRegressionOptions'></span><span id='topic+DynamicRegressionArOptions'></span><span id='topic+DynamicRegressionRandomWalkOptions'></span><span id='topic+DynamicRegressionHierarchicalRandomWalkOptions'></span>

<h3>Description</h3>

<p> Add a dynamic regression component to the state
specification of a bsts model.  A dynamic regression is a regression
model where the coefficients change over time according to a random
walk.  </p>


<h3>Usage</h3>

<pre><code class='language-R'>AddDynamicRegression(
    state.specification,
    formula,
    data,
    model.options = NULL,
    sigma.mean.prior.DEPRECATED = NULL,
    shrinkage.parameter.prior.DEPRECATED = GammaPrior(a = 10, b = 1),
    sigma.max.DEPRECATED = NULL,
    contrasts = NULL,
    na.action = na.pass)

DynamicRegressionRandomWalkOptions(
    sigma.prior = NULL,
    sdy = NULL,
    sdx = NULL)

DynamicRegressionHierarchicalRandomWalkOptions(
     sdy = NULL,
     sigma.mean.prior = NULL,
     shrinkage.parameter.prior = GammaPrior(a = 10, b = 1),
     sigma.max = NULL)

DynamicRegressionArOptions(lags = 1, sigma.prior = SdPrior(1, 1))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add.dynamic.regression_+3A_state.specification">state.specification</code></td>
<td>
<p>A list of state components that you wish to add to.  If
omitted, an empty list will be assumed.  </p>
</td></tr>
<tr><td><code id="add.dynamic.regression_+3A_formula">formula</code></td>
<td>
<p>A formula describing the regression portion of the
relationship between y and X. If no regressors are desired
then the formula can be replaced by a numeric vector giving
the time series to be modeled.</p>
</td></tr>
<tr><td><code id="add.dynamic.regression_+3A_data">data</code></td>
<td>
<p> An optional data frame, list or environment (or object
coercible by <code><a href="base.html#topic+as.data.frame">as.data.frame</a></code> to a data frame) containing
the variables in the model.  If not found in <code>data</code>, the
variables are taken from 'environment(formula)', typically the
environment from which <code>AddDynamicRegression</code> is called.  </p>
</td></tr>
<tr><td><code id="add.dynamic.regression_+3A_model.options">model.options</code></td>
<td>
<p>An object inheriting from
<code><a href="#topic+DynamicRegressionOptions">DynamicRegressionOptions</a></code> giving the specific transition model for
the dynamic regression coefficients, and the prior distribution for
any hyperparameters associated with the transition model.</p>
</td></tr>
<tr><td><code id="add.dynamic.regression_+3A_sigma.mean.prior">sigma.mean.prior</code></td>
<td>
<p> An object created by
<code><a href="Boom.html#topic+GammaPrior">GammaPrior</a></code> describing the prior distribution of
b/a (see details below).</p>
</td></tr>
<tr><td><code id="add.dynamic.regression_+3A_sigma.mean.prior.deprecated">sigma.mean.prior.DEPRECATED</code></td>
<td>
<p> This option should be set using
model.options.  It will be removed in a future release.</p>
</td></tr>
<tr><td><code id="add.dynamic.regression_+3A_shrinkage.parameter.prior">shrinkage.parameter.prior</code></td>
<td>
<p>An object of class
<code><a href="Boom.html#topic+GammaPrior">GammaPrior</a></code> describing the shrinkage parameter, a
(see details below).</p>
</td></tr>
<tr><td><code id="add.dynamic.regression_+3A_shrinkage.parameter.prior.deprecated">shrinkage.parameter.prior.DEPRECATED</code></td>
<td>
<p>This option should be set using
model.options.  It will be removed in a future release.</p>
</td></tr>
<tr><td><code id="add.dynamic.regression_+3A_sigma.max">sigma.max</code></td>
<td>
<p> The largest supported value of each
<code>sigma[i]</code>.  Truncating the support of sigma can keep
ill-conditioned models from crashing.  This must be a positive
number (<code>Inf</code> is okay), or <code>NULL</code>.  A <code>NULL</code> value
will set <code>sigma.max = sd(y)</code>, which is a substantially larger
value than one would expect, so in well behaved models this
constraint will not affect the analysis.  </p>
</td></tr>
<tr><td><code id="add.dynamic.regression_+3A_sigma.max.deprecated">sigma.max.DEPRECATED</code></td>
<td>
<p> This option should be set using
model.options.  It will be removed in a future release.</p>
</td></tr>
<tr><td><code id="add.dynamic.regression_+3A_contrasts">contrasts</code></td>
<td>
<p>An optional list. See the <code>contrasts.arg</code> of
<code>model.matrix.default</code>.  This argument is only used if a model
formula is specified.  It can usually be ignored even then.</p>
</td></tr>
<tr><td><code id="add.dynamic.regression_+3A_na.action">na.action</code></td>
<td>
<p>What to do about missing values.  The default is to
allow missing responses, but no missing predictors.  Set this to
na.omit or na.exclude if you want to omit missing responses
altogether.</p>
</td></tr>
<tr><td><code id="add.dynamic.regression_+3A_sdy">sdy</code></td>
<td>
<p>The standard deviation of the response variable.  This is
used to scale default priors and <code>sigma.max</code> if other arguments
are left <code>NULL</code>.  If all other arguments are non-<code>NULL</code>
then <code>sdy</code> is not used.</p>
</td></tr>
<tr><td><code id="add.dynamic.regression_+3A_sdx">sdx</code></td>
<td>
<p>The vector of standard deviations of each predictor
variable in the dynamic regression.  Used only to scale the default
prior.  This argument is not used if a prior is specified directly.</p>
</td></tr>
<tr><td><code id="add.dynamic.regression_+3A_lags">lags</code></td>
<td>
<p>The number of lags in the autoregressive process for the
coefficients.</p>
</td></tr>
<tr><td><code id="add.dynamic.regression_+3A_sigma.prior">sigma.prior</code></td>
<td>
<p>Either an object of class <code><a href="Boom.html#topic+SdPrior">SdPrior</a></code> or
a list of such objects.  If a single <code><a href="Boom.html#topic+SdPrior">SdPrior</a></code> is given
then it specifies the prior on the innovation variance for all the
coefficients.  If a list of <code><a href="Boom.html#topic+SdPrior">SdPrior</a></code> objects is given,
then each element gives the prior distribution for the corresponding
regression coefficient.  The length of such a list must match the
number of predictors in the dynamic regression part of the model.  </p>
</td></tr>
</table>


<h3>Details</h3>

<p>For the standard &quot;random walk&quot; coefficient model, the model is
</p>
<p style="text-align: center;"><code class="reqn">\beta_{i, t+1} = beta_{i, t} + \epsilon_t \qquad
    \epsilon_t \sim \mathcal{N}(0, \sigma^2_i / variance_{xi})</code>
</p>

<p style="text-align: center;"><code class="reqn"> \frac{1}{\sigma^2_i} \sim Ga(a, b)</code>
</p>

<p style="text-align: center;"><code class="reqn">\sqrt{b/a} \sim sigma.mean.prior</code>
</p>

<p style="text-align: center;"><code class="reqn"> a \sim shrinkage.parameter.prior</code>
</p>

<p>That is, each coefficient evolves independently, with its own variance
term which is scaled by the variance of the i'th column of X.  The
parameters of the hyperprior are interpretable as: sqrt(b/a) typical
amount that a coefficient might change in a single time period, and
'a' is the 'sample size' or 'shrinkage parameter' measuring the degree
of similarity in sigma[i] among the arms.
</p>
<p>In most cases we hope b/a is small, so that sigma[i]'s will be
small and the series will be forecastable.  We also hope that 'a'
is large because it means that the sigma[i]'s will be similar to
one another.
</p>
<p>The default prior distribution is a pair of independent Gamma
priors for sqrt(b/a) and a.  The mean of sigma[i] is set to .01 *
sd(y) with shape parameter equal to 1.  The mean of the shrinkage
parameter is set to 10, but with shape parameter equal to 1.
</p>
<p>If the coefficients have AR dynamics, then the model is that each
coefficient independently follows an AR(p) process, where p is given
by the <code>lags</code> argument.  Independent priors are assumed for each
coefficient's model, with a uniform prior on AR coefficients (with
support restricted to the finite region where the process is
stationary), while the <code>sigma.prior</code> argument gives the prior for
each coefficient's innovation variance.
</p>


<h3>Value</h3>

<p> Returns a list with the elements necessary to specify a dynamic
regression model.</p>


<h3>Author(s)</h3>

<p>Steven L. Scott
</p>


<h3>References</h3>

<p>Harvey (1990), &quot;Forecasting, structural time series, and the Kalman
filter&quot;, Cambridge University Press.
</p>
<p>Durbin and Koopman (2001), &quot;Time series analysis by state space
methods&quot;, Oxford University Press.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bsts">bsts</a></code>.
<code><a href="Boom.html#topic+SdPrior">SdPrior</a></code>
<code><a href="Boom.html#topic+NormalPrior">NormalPrior</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Setting the seed to avoid small sample effects resulting from small
## number of iterations.
set.seed(8675309)
n &lt;- 1000
x &lt;- matrix(rnorm(n))

# beta follows a random walk with sd = .1 starting at -12.
beta &lt;- cumsum(rnorm(n, 0, .1)) - 12

# level is a local level model with sd = 1 starting at 18.
level &lt;- cumsum(rnorm(n)) + 18

# sigma.obs is .1
error &lt;- rnorm(n, 0, .1)

y &lt;- level + x * beta + error
par(mfrow = c(1, 3))
plot(y, main = "Raw Data")
plot(x, y - level, main = "True Regression Effect")
plot(y - x * beta, main = "Local Level Effect")

ss &lt;- list()
ss &lt;- AddLocalLevel(ss, y)
ss &lt;- AddDynamicRegression(ss, y ~ x)
## In a real appliction you'd probably want more than 100
## iterations. See comment above about the random seed.
model &lt;- bsts(y, state.specification = ss, niter = 100, seed = 8675309)
plot(model, "dynamic", burn = 10)

xx &lt;- rnorm(10)
pred &lt;- predict(model, newdata = xx)
plot(pred)
</code></pre>

<hr>
<h2 id='add.local.level'>
Local level trend state component
</h2><span id='topic+AddLocalLevel'></span>

<h3>Description</h3>

<p>Add a local level model to a state specification.
The local level model assumes the trend is a
random walk: </p>
<p style="text-align: center;"><code class="reqn">\alpha_{t+1} = \alpha_t + \epsilon_t \qquad
      \epsilon_t \sim \mathcal{N}(0,\sigma).</code>
</p>

<p>The prior is on the <code class="reqn">\sigma</code>
parameter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  AddLocalLevel(
     state.specification,
     y,
     sigma.prior,
     initial.state.prior,
     sdy,
     initial.y)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add.local.level_+3A_state.specification">state.specification</code></td>
<td>
<p>A list of state components that you wish to add to.  If
omitted, an empty list will be assumed.  </p>
</td></tr>
<tr><td><code id="add.local.level_+3A_y">y</code></td>
<td>
<p> The time series to be modeled, as a numeric vector.</p>
</td></tr>
<tr><td><code id="add.local.level_+3A_sigma.prior">sigma.prior</code></td>
<td>
<p>An object created by <code><a href="Boom.html#topic+SdPrior">SdPrior</a></code>
describing the prior distribution for the standard deviation of the
random walk increments.</p>
</td></tr>
<tr><td><code id="add.local.level_+3A_initial.state.prior">initial.state.prior</code></td>
<td>
<p>An object created using
<code><a href="Boom.html#topic+NormalPrior">NormalPrior</a></code>, describing the prior distribution
of the initial state vector (at time 1).</p>
</td></tr>
<tr><td><code id="add.local.level_+3A_sdy">sdy</code></td>
<td>
<p>The standard deviation of the series to be modeled.  This
will be ignored if <code>y</code> is provided, or if all the required
prior distributions are supplied directly.  </p>
</td></tr>
<tr><td><code id="add.local.level_+3A_initial.y">initial.y</code></td>
<td>
<p>The initial value of the series being modeled.  This will be
ignored if <code>y</code> is provided, or if the priors for the initial
state are all provided directly.</p>
</td></tr>
</table>


<h3>Value</h3>

<p> Returns a list with the elements necessary to specify a local
linear trend state model.</p>


<h3>Author(s)</h3>

<p>Steven L. Scott <a href="mailto:steve.the.bayesian@gmail.com">steve.the.bayesian@gmail.com</a>
</p>


<h3>References</h3>

<p>Harvey (1990), &quot;Forecasting, structural time series, and the Kalman
filter&quot;, Cambridge University Press.
</p>
<p>Durbin and Koopman (2001), &quot;Time series analysis by state space
methods&quot;, Oxford University Press.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bsts">bsts</a></code>.
<code><a href="Boom.html#topic+SdPrior">SdPrior</a></code>
<code><a href="Boom.html#topic+NormalPrior">NormalPrior</a></code>
</p>

<hr>
<h2 id='add.local.linear.trend'>
Local linear trend state component
</h2><span id='topic+AddLocalLinearTrend'></span>

<h3>Description</h3>

<p>Add a local linear trend model to a state specification.
The local linear trend model assumes that both the mean and the slope of the
trend follow random walks.  The equation for the mean is
</p>
<p style="text-align: center;"><code class="reqn">\mu_{t+1} = \mu_t + \delta_t + \epsilon_t  \qquad \epsilon_t
    \sim \mathcal{N}(0, \sigma_\mu).</code>
</p>
<p>  The
equation for the slope is
</p>
<p style="text-align: center;"><code class="reqn">\delta_{t+1} = \delta_t + \eta_t \qquad \eta_t \sim
    \mathcal{N}(0, \sigma_\delta).</code>
</p>

<p>The prior distribution is on the level standard deviation
<code class="reqn">\sigma_\mu</code> and the slope standard deviation
<code class="reqn">\sigma_\delta</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  AddLocalLinearTrend(
     state.specification = NULL,
     y,
     level.sigma.prior = NULL,
     slope.sigma.prior = NULL,
     initial.level.prior = NULL,
     initial.slope.prior = NULL,
     sdy,
     initial.y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add.local.linear.trend_+3A_state.specification">state.specification</code></td>
<td>
<p>A list of state components that you wish to add to.  If
omitted, an empty list will be assumed.  </p>
</td></tr>
<tr><td><code id="add.local.linear.trend_+3A_y">y</code></td>
<td>
<p>The time series to be modeled, as a numeric vector.</p>
</td></tr>
<tr><td><code id="add.local.linear.trend_+3A_level.sigma.prior">level.sigma.prior</code></td>
<td>
<p>An object created by
<code><a href="Boom.html#topic+SdPrior">SdPrior</a></code> describing the prior distribution for
the standard deviation of the level component.</p>
</td></tr>
<tr><td><code id="add.local.linear.trend_+3A_slope.sigma.prior">slope.sigma.prior</code></td>
<td>
<p>An object created by
<code><a href="Boom.html#topic+SdPrior">SdPrior</a></code> describing the prior distribution of
the standard deviation of the slope component.</p>
</td></tr>
<tr><td><code id="add.local.linear.trend_+3A_initial.level.prior">initial.level.prior</code></td>
<td>
<p>An object created by
<code><a href="Boom.html#topic+NormalPrior">NormalPrior</a></code> describing the initial distribution
of the level portion of the initial state vector.</p>
</td></tr>
<tr><td><code id="add.local.linear.trend_+3A_initial.slope.prior">initial.slope.prior</code></td>
<td>
<p>An object created by
<code><a href="Boom.html#topic+NormalPrior">NormalPrior</a></code> describing the prior distribution
for the slope portion of the initial state vector.</p>
</td></tr>
<tr><td><code id="add.local.linear.trend_+3A_sdy">sdy</code></td>
<td>
<p>The standard deviation of the series to be modeled.  This
will be ignored if <code>y</code> is provided, or if all the required
prior distributions are supplied directly.  </p>
</td></tr>
<tr><td><code id="add.local.linear.trend_+3A_initial.y">initial.y</code></td>
<td>
<p>The initial value of the series being modeled.  This will be
ignored if <code>y</code> is provided, or if the priors for the initial
state are all provided directly.</p>
</td></tr>
</table>


<h3>Value</h3>

<p> Returns a list with the elements necessary to specify a local
linear trend state model.</p>


<h3>Author(s)</h3>

<p>Steven L. Scott <a href="mailto:steve.the.bayesian@gmail.com">steve.the.bayesian@gmail.com</a>
</p>


<h3>References</h3>

<p>Harvey (1990), &quot;Forecasting, structural time series, and the Kalman
filter&quot;, Cambridge University Press.
</p>
<p>Durbin and Koopman (2001), &quot;Time series analysis by state space
methods&quot;, Oxford University Press.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bsts">bsts</a></code>.
<code><a href="Boom.html#topic+SdPrior">SdPrior</a></code>
<code><a href="Boom.html#topic+NormalPrior">NormalPrior</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  data(AirPassengers)
  y &lt;- log(AirPassengers)
  ss &lt;- AddLocalLinearTrend(list(), y)
  ss &lt;- AddSeasonal(ss, y, nseasons = 12)
  model &lt;- bsts(y, state.specification = ss, niter = 500)
  pred &lt;- predict(model, horizon = 12, burn = 100)
  plot(pred)
</code></pre>

<hr>
<h2 id='add.monthly.annual.cycle'>Monthly Annual Cycle State Component</h2><span id='topic+AddMonthlyAnnualCycle'></span><span id='topic+MonthlyAnnualCycle'></span>

<h3>Description</h3>

<p>A seasonal state component for daily data, representing
the contribution of each month to the annual seasonal cycle.
I.e. this is the &quot;January, February, March, ...&quot; effect, with 12
seasons.  There is a step change at the start of each month, and then
the contribution of that month is constant over the course of the
month.
</p>
<p>Note that if you have anything other than daily data, then you're
probably looking for <code><a href="#topic+AddSeasonal">AddSeasonal</a></code> instead.
</p>
<p>The state of this model is an 11-vector <code class="reqn">\gamma_t</code>
where the first element is the contribution to the mean for the
current month, and the remaining elements are the values for the 10
most recent months.  When <code class="reqn">t</code> is the first day in the month
then
</p>
<p style="text-align: center;"><code class="reqn">\gamma_{t+1} = -\sum_{i = 2}^11 \gamma_{t, i} + %
    \epsilon_t  \qquad \epsilon_t \sim \mathcal{N}(0, \sigma)</code>
</p>

<p>And the remaining elements are <code class="reqn">\gamma_t</code> shifted down
one.  When <code class="reqn">t</code> is any other day then <code class="reqn">\gamma_{t+1} = %
  \gamma_t</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AddMonthlyAnnualCycle(state.specification,
                      y,
                      date.of.first.observation = NULL,
                      sigma.prior = NULL,
                      initial.state.prior = NULL,
                      sdy)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add.monthly.annual.cycle_+3A_state.specification">state.specification</code></td>
<td>
<p>A list of state components, to which the
monthly annual cycle will be added.  If omitted, an empty list will
be assumed.</p>
</td></tr>
<tr><td><code id="add.monthly.annual.cycle_+3A_y">y</code></td>
<td>
<p> The time series to be modeled, as a numeric vector.</p>
</td></tr>
<tr><td><code id="add.monthly.annual.cycle_+3A_date.of.first.observation">date.of.first.observation</code></td>
<td>
<p>The time stamp of the first
observation in <code>y</code>, as a <code><a href="base.html#topic+Date">Date</a></code> or
<code><a href="base.html#topic+POSIXt">POSIXt</a></code> object.  If <code>y</code> is a <code><a href="zoo.html#topic+zoo">zoo</a></code>
object with appropriate time stamps then this argument will be
deduced.</p>
</td></tr>
<tr><td><code id="add.monthly.annual.cycle_+3A_sigma.prior">sigma.prior</code></td>
<td>
<p>An object created by <code><a href="Boom.html#topic+SdPrior">SdPrior</a></code>
describing the prior distribution for the standard deviation of the
random walk increments.</p>
</td></tr>
<tr><td><code id="add.monthly.annual.cycle_+3A_initial.state.prior">initial.state.prior</code></td>
<td>
<p>An object created using
<code><a href="Boom.html#topic+NormalPrior">NormalPrior</a></code>, describing the prior distribution
of the the initial state vector (at time 1).</p>
</td></tr>
<tr><td><code id="add.monthly.annual.cycle_+3A_sdy">sdy</code></td>
<td>
<p>The standard deviation of the series to be modeled.  This
will be ignored if <code>y</code> is provided, or if all the required
prior distributions are supplied directly.  </p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
  ## Let's simulate some fake daily data with a monthly cycle.
## Not run: 
  residuals &lt;- rnorm(365 * 5)

## End(Not run)

  n &lt;- length(residuals)
  dates &lt;- seq.Date(from = as.Date("2014-01-01"),
                    len = n,
                    by = 1)
  monthly.cycle &lt;- rnorm(12)
  monthly.cycle &lt;- monthly.cycle - mean(monthly.cycle)
  timestamps &lt;- as.POSIXlt(dates)
  month &lt;- timestamps$mon + 1

  new.month &lt;- c(TRUE, diff(timestamps$mon) != 0)
  month.effect &lt;- cumsum(new.month) 
  month.effect[month.effect == 0] &lt;- 12

  response &lt;- monthly.cycle[month] + residuals
  response &lt;- zoo(response, timestamps)

  ## Now let's fit a bsts model to the daily data with a monthly annual
  ## cycle.
  ss &lt;- AddLocalLevel(list(), response)
  ss &lt;- AddMonthlyAnnualCycle(ss, response)

  ## In real life you'll probably want more iterations.
  model &lt;- bsts(response, state.specification = ss, niter = 200)
  plot(model)
  plot(model, "monthly")
</code></pre>

<hr>
<h2 id='add.random.walk.holiday'>
Random Walk Holiday State Model
</h2><span id='topic+AddRandomWalkHoliday'></span><span id='topic+RandomWalkHolidayStateModel'></span>

<h3>Description</h3>

<p>Adds a random walk holiday state model to the state specification.
This model says
</p>
<p style="text-align: center;"><code class="reqn">%
   y_t = \alpha_{d(t), t} + \epsilon_t
 </code>
</p>

<p>where there is one element in <code class="reqn">\alpha_t</code> for each day
in the holiday influence window.  The transition equation is
</p>
<p style="text-align: center;"><code class="reqn"> %
   \alpha_{d(t+1), t+1} = \alpha_{d(t+1), t} + \epsilon_{t+1}
 </code>
</p>

<p>if t+1 occurs on day d(t+1) of the influence window, and
</p>
<p style="text-align: center;"><code class="reqn">
      \alpha_{d(t+1), t+1} = \alpha_{d(t+1), t} %
 </code>
</p>

<p>otherwise.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AddRandomWalkHoliday(state.specification = NULL,
                     y,
                     holiday,
                     time0 = NULL, 
                     sigma.prior = NULL,
                     initial.state.prior = NULL,
                     sdy = sd(as.numeric(y), na.rm = TRUE))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add.random.walk.holiday_+3A_state.specification">state.specification</code></td>
<td>
<p>A list of state components that you wish
augment.  If omitted, an empty list will be assumed.  </p>
</td></tr>
<tr><td><code id="add.random.walk.holiday_+3A_y">y</code></td>
<td>
<p>The time series to be modeled, as a numeric vector
convertible to <code><a href="xts.html#topic+xts">xts</a></code>.  This state model assumes <code>y</code>
contains daily data.</p>
</td></tr>
<tr><td><code id="add.random.walk.holiday_+3A_holiday">holiday</code></td>
<td>
<p>An object of class <code><a href="#topic+Holiday">Holiday</a></code> describing the
influence window of the holiday being modeled.</p>
</td></tr>
<tr><td><code id="add.random.walk.holiday_+3A_time0">time0</code></td>
<td>
<p>An object convertible to <code><a href="base.html#topic+Date">Date</a></code> containing
the date of the initial observation in the training data.  If
omitted and <code>y</code> is a <code><a href="zoo.html#topic+zoo">zoo</a></code> or
<code><a href="xts.html#topic+xts">xts</a></code> object, then <code>time0</code> will be obtained
from the index of <code>y[1]</code>.</p>
</td></tr>
<tr><td><code id="add.random.walk.holiday_+3A_sigma.prior">sigma.prior</code></td>
<td>
<p>An object created by <code><a href="Boom.html#topic+SdPrior">SdPrior</a></code>
describing the prior distribution for the standard deviation of the
random walk increments.</p>
</td></tr>
<tr><td><code id="add.random.walk.holiday_+3A_initial.state.prior">initial.state.prior</code></td>
<td>
<p>An object created using
<code><a href="Boom.html#topic+NormalPrior">NormalPrior</a></code>, describing the prior distribution
of the the initial state vector (at time 1).</p>
</td></tr>
<tr><td><code id="add.random.walk.holiday_+3A_sdy">sdy</code></td>
<td>
<p>The standard deviation of the series to be modeled.  This
will be ignored if <code>y</code> is provided, or if all the required
prior distributions are supplied directly.  </p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list describing the specification of the random walk holiday state
model, formatted as expected by the underlying C++ code.
</p>


<h3>Author(s)</h3>

<p>Steven L. Scott <a href="mailto:steve.the.bayesian@gmail.com">steve.the.bayesian@gmail.com</a>
</p>


<h3>References</h3>

<p>Harvey (1990), &quot;Forecasting, structural time series, and the Kalman
filter&quot;, Cambridge University Press.
</p>
<p>Durbin and Koopman (2001), &quot;Time series analysis by state space
methods&quot;, Oxford University Press.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bsts">bsts</a></code>.
<code><a href="#topic+RegressionHolidayStateModel">RegressionHolidayStateModel</a></code>
<code><a href="#topic+HierarchicalRegressionHolidayStateModel">HierarchicalRegressionHolidayStateModel</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>trend &lt;- cumsum(rnorm(730, 0, .1))
dates &lt;- seq.Date(from = as.Date("2014-01-01"), length = length(trend),
  by = "day")
y &lt;- zoo(trend + rnorm(length(trend), 0, .2), dates)

AddHolidayEffect &lt;- function(y, dates, effect) {
  ## Adds a holiday effect to simulated data.
  ## Args:
  ##   y: A zoo time series, with Dates for indices.
  ##   dates: The dates of the holidays.
  ##   effect: A vector of holiday effects of odd length.  The central effect is
  ##     the main holiday, with a symmetric influence window on either side.
  ## Returns:
  ##   y, with the holiday effects added.
  time &lt;- dates - (length(effect) - 1) / 2
  for (i in 1:length(effect)) {
    y[time] &lt;- y[time] + effect[i]
    time &lt;- time + 1
  }
  return(y)
}

## Define some holidays.
memorial.day &lt;- NamedHoliday("MemorialDay")
memorial.day.effect &lt;- c(.3, 3, .5)
memorial.day.dates &lt;- as.Date(c("2014-05-26", "2015-05-25"))
y &lt;- AddHolidayEffect(y, memorial.day.dates, memorial.day.effect)

presidents.day &lt;- NamedHoliday("PresidentsDay")
presidents.day.effect &lt;- c(.5, 2, .25)
presidents.day.dates &lt;- as.Date(c("2014-02-17", "2015-02-16"))
y &lt;- AddHolidayEffect(y, presidents.day.dates, presidents.day.effect)

labor.day &lt;- NamedHoliday("LaborDay")
labor.day.effect &lt;- c(1, 2, 1)
labor.day.dates &lt;- as.Date(c("2014-09-01", "2015-09-07"))
y &lt;- AddHolidayEffect(y, labor.day.dates, labor.day.effect)

## The holidays can be in any order.
holiday.list &lt;- list(memorial.day, labor.day, presidents.day)
number.of.holidays &lt;- length(holiday.list)

## In a real example you'd want more than 100 MCMC iterations.
niter &lt;- 100
ss &lt;- AddLocalLevel(list(), y)
ss &lt;- AddRandomWalkHoliday(ss, y, memorial.day)
ss &lt;- AddRandomWalkHoliday(ss, y, labor.day)
ss &lt;- AddRandomWalkHoliday(ss, y, presidents.day)
model &lt;- bsts(y, state.specification = ss, niter = niter, seed = 8675309)

## Plot model components.
plot(model, "comp")

## Plot the effect of the specific state component.
plot(ss[[2]], model)
</code></pre>

<hr>
<h2 id='add.seasonal'>
Seasonal State Component
</h2><span id='topic+AddSeasonal'></span>

<h3>Description</h3>

<p>Add a seasonal model to a state specification.
</p>
<p>The seasonal model can be thought of as a regression on
<code>nseasons</code> dummy variables with coefficients constrained to sum
to 1 (in expectation).  If there are <code>S</code> seasons then the state
vector <code class="reqn">\gamma</code> is of dimension <code>S-1</code>.  The first
element of the state vector obeys
</p>
<p style="text-align: center;"><code class="reqn">\gamma_{t+1, 1} = -\sum_{i = 2}^S \gamma_{t, i} + \epsilon_t
  \qquad \epsilon_t \sim \mathcal{N}(0, \sigma)</code>
</p>



<h3>Usage</h3>

<pre><code class='language-R'>  AddSeasonal(
     state.specification,
     y,
     nseasons,
     season.duration = 1,
     sigma.prior,
     initial.state.prior,
     sdy)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add.seasonal_+3A_state.specification">state.specification</code></td>
<td>
<p>A list of state components that you wish to add to.  If
omitted, an empty list will be assumed.  </p>
</td></tr>
<tr><td><code id="add.seasonal_+3A_y">y</code></td>
<td>
<p> The time series to be modeled, as a numeric vector.</p>
</td></tr>
<tr><td><code id="add.seasonal_+3A_nseasons">nseasons</code></td>
<td>
<p>The number of seasons to be modeled.</p>
</td></tr>
<tr><td><code id="add.seasonal_+3A_season.duration">season.duration</code></td>
<td>
<p>The number of time periods in each season.</p>
</td></tr>
<tr><td><code id="add.seasonal_+3A_sigma.prior">sigma.prior</code></td>
<td>
<p>An object created by <code><a href="Boom.html#topic+SdPrior">SdPrior</a></code>
describing the prior distribution for the standard deviation of the
random walk increments.</p>
</td></tr>
<tr><td><code id="add.seasonal_+3A_initial.state.prior">initial.state.prior</code></td>
<td>
<p>An object created using
<code><a href="Boom.html#topic+NormalPrior">NormalPrior</a></code>, describing the prior distribution
of the the initial state vector (at time 1).</p>
</td></tr>
<tr><td><code id="add.seasonal_+3A_sdy">sdy</code></td>
<td>
<p>The standard deviation of the series to be modeled.  This
will be ignored if <code>y</code> is provided, or if all the required
prior distributions are supplied directly.  </p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list with the elements necessary to specify a seasonal
state model.</p>


<h3>Author(s)</h3>

<p>Steven L. Scott <a href="mailto:steve.the.bayesian@gmail.com">steve.the.bayesian@gmail.com</a>
</p>


<h3>References</h3>

<p>Harvey (1990), &quot;Forecasting, structural time series, and the Kalman
filter&quot;, Cambridge University Press.
</p>
<p>Durbin and Koopman (2001), &quot;Time series analysis by state space
methods&quot;, Oxford University Press.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bsts">bsts</a></code>.
<code><a href="Boom.html#topic+SdPrior">SdPrior</a></code>
<code><a href="Boom.html#topic+NormalPrior">NormalPrior</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  data(AirPassengers)
  y &lt;- log(AirPassengers)
  ss &lt;- AddLocalLinearTrend(list(), y)
  ss &lt;- AddSeasonal(ss, y, nseasons = 12)
  model &lt;- bsts(y, state.specification = ss, niter = 500)
  pred &lt;- predict(model, horizon = 12, burn = 100)
  plot(pred)
</code></pre>

<hr>
<h2 id='add.semilocal.linear.trend'>Semilocal Linear Trend</h2><span id='topic+AddGeneralizedLocalLinearTrend'></span><span id='topic+AddSemilocalLinearTrend'></span>

<h3>Description</h3>

<p>The semi-local linear trend model is similar to the local linear
trend, but more useful for long-term forecasting.  It assumes the
level component moves according to a random walk, but the slope
component moves according to an AR1 process centered on a
potentially nonzero value <code class="reqn">D</code>.  The equation for the level is
</p>
<p style="text-align: center;"><code class="reqn">\mu_{t+1} = \mu_t + \delta_t + \epsilon_t \qquad \epsilon_t \sim
    \mathcal{N(0, \sigma_\mu)}.</code>
</p>

<p>The equation for the slope is </p>
<p style="text-align: center;"><code class="reqn">\delta_{t+1} = D + \phi
    (\delta_t - D) + \eta_t \qquad \eta_t \sim \mathcal{N(0,
      \sigma_\delta)}.</code>
</p>

<p>This model differs from the local linear trend model in that the
latter assumes the slope <code class="reqn">\delta_t</code> follows a random
walk.  A stationary AR(1) process is less variable than a random walk
when making projections far into the future, so this model often gives
more reasonable uncertainty estimates when making long term forecasts.
</p>
<p>The prior distribution for the semi-local linear trend has four
independent components.  These are:
</p>

<ul>
<li><p>an inverse gamma prior on the level
standard deviation <code class="reqn">\sigma_\mu</code>,
</p>
</li>
<li><p>an inverse gamma prior on the slope standard deviation
<code class="reqn">\sigma_\delta</code>, 
</p>
</li>
<li><p>a Gaussian prior on the long run slope parameter <code class="reqn">D</code>,
</p>
</li>
<li><p>and a potentially truncated Gaussian prior on the AR1
coefficient <code class="reqn">\phi</code>.  If the prior on <code class="reqn">\phi</code> is
truncated to (-1, 1), then the slope will exhibit short term
stationary variation around the long run slope <code class="reqn">D</code>.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>  AddSemilocalLinearTrend(
     state.specification = list(),
     y = NULL,
     level.sigma.prior = NULL,
     slope.mean.prior = NULL,
     slope.ar1.prior = NULL,
     slope.sigma.prior = NULL,
     initial.level.prior = NULL,
     initial.slope.prior = NULL,
     sdy = NULL,
     initial.y = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add.semilocal.linear.trend_+3A_state.specification">state.specification</code></td>
<td>
<p>A list of state components that you wish to add to.  If
omitted, an empty list will be assumed.  </p>
</td></tr>
<tr><td><code id="add.semilocal.linear.trend_+3A_y">y</code></td>
<td>
<p>The time series to be modeled, as a numeric vector.  This can
be omitted if <code>sdy</code> and <code>initial.y</code> are supplied, or if
all prior distributions are supplied directly.</p>
</td></tr>
<tr><td><code id="add.semilocal.linear.trend_+3A_level.sigma.prior">level.sigma.prior</code></td>
<td>
<p>An object created by
<code><a href="Boom.html#topic+SdPrior">SdPrior</a></code> describing the prior
distribution for the standard deviation of the level component.</p>
</td></tr>
<tr><td><code id="add.semilocal.linear.trend_+3A_slope.mean.prior">slope.mean.prior</code></td>
<td>
<p>An object created by
<code><a href="Boom.html#topic+NormalPrior">NormalPrior</a></code> giving the prior distribution for
the mean parameter in the generalized local linear trend model (see
below). </p>
</td></tr>
<tr><td><code id="add.semilocal.linear.trend_+3A_slope.ar1.prior">slope.ar1.prior</code></td>
<td>
<p>An object created by
<code><a href="Boom.html#topic+Ar1CoefficientPrior">Ar1CoefficientPrior</a></code> giving the prior
distribution for the ar1 coefficient parameter in the generalized
local linear trend model (see below). </p>
</td></tr>
<tr><td><code id="add.semilocal.linear.trend_+3A_slope.sigma.prior">slope.sigma.prior</code></td>
<td>
<p>An object created by
<code><a href="Boom.html#topic+SdPrior">SdPrior</a></code> describing the prior distribution of
the standard deviation of the slope component.</p>
</td></tr>
<tr><td><code id="add.semilocal.linear.trend_+3A_initial.level.prior">initial.level.prior</code></td>
<td>
<p>An object created by
<code><a href="Boom.html#topic+NormalPrior">NormalPrior</a></code> describing the initial distribution
of the level portion of the initial state vector.</p>
</td></tr>
<tr><td><code id="add.semilocal.linear.trend_+3A_initial.slope.prior">initial.slope.prior</code></td>
<td>
<p>An object created by
<code><a href="Boom.html#topic+NormalPrior">NormalPrior</a></code> describing the prior distribution
for the slope portion of the initial state vector.</p>
</td></tr>
<tr><td><code id="add.semilocal.linear.trend_+3A_sdy">sdy</code></td>
<td>
<p>The standard deviation of the series to be modeled.  This
will be ignored if <code>y</code> is provided, or if all the required
prior distributions are supplied directly.  </p>
</td></tr>
<tr><td><code id="add.semilocal.linear.trend_+3A_initial.y">initial.y</code></td>
<td>
<p>The initial value of the series being modeled.  This will be
ignored if <code>y</code> is provided, or if the priors for the initial
state are all provided directly.</p>
</td></tr>
</table>


<h3>Value</h3>

<p> Returns a list with the elements necessary to specify a
generalized local linear trend state model.</p>


<h3>Author(s)</h3>

<p>Steven L. Scott <a href="mailto:steve.the.bayesian@gmail.com">steve.the.bayesian@gmail.com</a>
</p>


<h3>References</h3>

<p>Harvey (1990), &quot;Forecasting, structural time series, and the Kalman
filter&quot;, Cambridge University Press.
</p>
<p>Durbin and Koopman (2001), &quot;Time series analysis by state space
methods&quot;, Oxford University Press.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bsts">bsts</a></code>.
<code><a href="Boom.html#topic+SdPrior">SdPrior</a></code>
<code><a href="Boom.html#topic+NormalPrior">NormalPrior</a></code>
</p>

<hr>
<h2 id='add.shared.local.level'>
Local level trend state component
</h2><span id='topic+AddSharedLocalLevel'></span>

<h3>Description</h3>

<p>Add a shared local level model to a state specification.
The shared local level model assumes the trend is a
multivariate random walk:
</p>
<p style="text-align: center;"><code class="reqn">\alpha_{t+1} = \alpha_t + \eta_t \qquad
    \eta_{tj} \sim \mathcal{N}(0,\sigma_j).</code>
</p>

<p>The contribution to the mean of the observed series obeys </p>
<p style="text-align: center;"><code class="reqn">y_{t}
  = B \alpha_t + \epsilon_t.</code>
</p>
<p> plus
observation error.  Identifiability constraints imply that the
observation coefficients <code>B</code> form a rectangular lower triangular
matrix with diagonal 1.0.
</p>
<p>If there are <code class="reqn">m</code> time series and <code class="reqn">p</code> factors, then <code class="reqn">B</code> has
<code class="reqn">m</code> rows and <code class="reqn">p</code> columns.  Having <code class="reqn">B</code> be lower triangular
means that the first factor affects all series.  The second affects
all but the first, the third excludes the first two, etc.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  AddSharedLocalLevel(
     state.specification,
     response,
     nfactors,
     coefficient.prior = NULL,
     initial.state.prior = NULL,
     timestamps = NULL,
     series.id = NULL,
     sdy,
     ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add.shared.local.level_+3A_state.specification">state.specification</code></td>
<td>
<p>A pre-existing list of state components
that you wish to add to.  If omitted, an empty list will be assumed.
</p>
</td></tr>
<tr><td><code id="add.shared.local.level_+3A_response">response</code></td>
<td>
<p> The time series to be modeled. This can either be a
matrix with rows as time and columns as series, or it can be a numeric
vector.  If a vector is passed then <code>timestamps</code> and
<code>series.id</code> are required.  Otherwise they are unused.</p>
</td></tr>
<tr><td><code id="add.shared.local.level_+3A_nfactors">nfactors</code></td>
<td>
<p>The number of latent factors to include in the model.
This is the dimension of the state for this model component.</p>
</td></tr>
<tr><td><code id="add.shared.local.level_+3A_coefficient.prior">coefficient.prior</code></td>
<td>
<p>Prior distribution on the observation
coefficients. </p>
</td></tr>
<tr><td><code id="add.shared.local.level_+3A_initial.state.prior">initial.state.prior</code></td>
<td>
<p>An object of class
<code><a href="Boom.html#topic+MvnPrior">MvnPrior</a></code>, describing the prior distribution of
the initial state vector (at time 1).</p>
</td></tr>
<tr><td><code id="add.shared.local.level_+3A_timestamps">timestamps</code></td>
<td>
<p>If <code>response</code> is in long format (i.e. a vector
instead of a matrix) this argument is a vector of the same
length indicating the time index to which each element of
<code>response</code> belongs. </p>
</td></tr>
<tr><td><code id="add.shared.local.level_+3A_series.id">series.id</code></td>
<td>
<p>If <code>response</code> is in long format (i.e. a vector
instead of a matrix) this argument is a vector of the same length
indicating the time series to which each element of <code>response</code>
belongs. </p>
</td></tr>
<tr><td><code id="add.shared.local.level_+3A_sdy">sdy</code></td>
<td>
<p>A vector giving the standard deviation of each series to be
modeled.  This argument is only necessary if <code>response</code> cannot
be supplied directly.</p>
</td></tr>
<tr><td><code id="add.shared.local.level_+3A_...">...</code></td>
<td>
<p>Extra arguments passed to
<code><a href="BoomSpikeSlab.html#topic+ConditionalZellnerPrior">ConditionalZellnerPrior</a></code>, used to create
a default prior for the observation coefficients when
<code>coefficient.prior</code> is left as <code>NULL</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p> Returns a list with the elements necessary to specify a local
linear trend state model.</p>


<h3>Author(s)</h3>

<p>Steven L. Scott <a href="mailto:steve.the.bayesian@gmail.com">steve.the.bayesian@gmail.com</a>
</p>


<h3>References</h3>

<p>Harvey (1990), &quot;Forecasting, structural time series, and the Kalman
filter&quot;, Cambridge University Press.
</p>
<p>Durbin and Koopman (2001), &quot;Time series analysis by state space
methods&quot;, Oxford University Press.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bsts">bsts</a></code>.
<code><a href="Boom.html#topic+SdPrior">SdPrior</a></code>
<code><a href="Boom.html#topic+NormalPrior">NormalPrior</a></code>
</p>

<hr>
<h2 id='add.static.intercept'>
Static Intercept State Component
</h2><span id='topic+AddStaticIntercept'></span>

<h3>Description</h3>

<p>Adds a static intercept term to a state space model.  If the model includes
a traditional trend component (e.g. local level, local linear trend, etc)
then a separate intercept is not needed (and will probably cause trouble,
as it will be confounded with the initial state of the trend model).
However, if there is no trend, or the trend is an AR process centered
around zero, then adding a static intercept will shift the center to a
data-determined value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AddStaticIntercept(
    state.specification,
    y,
    initial.state.prior = NormalPrior(y[1], sd(y, na.rm = TRUE)))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add.static.intercept_+3A_state.specification">state.specification</code></td>
<td>
<p>A list of state components that you wish to add to.  If
omitted, an empty list will be assumed.  </p>
</td></tr>
<tr><td><code id="add.static.intercept_+3A_y">y</code></td>
<td>
<p>The time series to be modeled, as a numeric vector.</p>
</td></tr>
<tr><td><code id="add.static.intercept_+3A_initial.state.prior">initial.state.prior</code></td>
<td>
<p>An object created using
<code><a href="Boom.html#topic+NormalPrior">NormalPrior</a></code>, describing the prior distribution
of the intecept term.</p>
</td></tr>
</table>


<h3>Value</h3>

<p> Returns a list with the information required to specify the
state component. If initial.state.prior is specified then y is unused.
</p>


<h3>Author(s)</h3>

<p>Steven L. Scott
</p>


<h3>References</h3>

<p>Harvey (1990), &quot;Forecasting, structural time series, and the Kalman
filter&quot;, Cambridge University Press.
</p>
<p>Durbin and Koopman (2001), &quot;Time series analysis by state space
methods&quot;, Oxford University Press.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bsts">bsts</a></code>.
<code><a href="Boom.html#topic+SdPrior">SdPrior</a></code>
<code><a href="Boom.html#topic+NormalPrior">NormalPrior</a></code>
</p>

<hr>
<h2 id='add.student.local.linear.trend'>
Robust local linear trend
</h2><span id='topic+AddStudentLocalLinearTrend'></span>

<h3>Description</h3>

<p>Add a local level model to a state specification.
The local linear trend model assumes that both the mean and the slope of the
trend follow random walks.  The equation for the mean is
</p>
<p style="text-align: center;"><code class="reqn">\mu_{t+1} = \mu_t + \delta_t + \epsilon_t  \qquad \epsilon_t
    \sim \mathcal{T}_{\nu_\mu}(0, \sigma_\mu).</code>
</p>
<p>  The
equation for the slope is
</p>
<p style="text-align: center;"><code class="reqn">\delta_{t+1} = \delta_t + \eta_t \qquad \eta_t \sim
    \mathcal{T}_{\nu_\delta}(0, \sigma_\delta).</code>
</p>

<p>Independent prior distributions are assumed on the level standard
deviation, <code class="reqn">\sigma_\mu</code> the slope standard deviation
<code class="reqn">\sigma_\delta</code>, the level tail thickness
<code class="reqn">\nu_\mu</code>, and the slope tail thickness
<code class="reqn">\nu_\delta</code>.  </p>


<h3>Usage</h3>

<pre><code class='language-R'>  AddStudentLocalLinearTrend(
     state.specification = NULL,
     y,
     save.weights = FALSE,
     level.sigma.prior = NULL,
     level.nu.prior = NULL,
     slope.sigma.prior = NULL,
     slope.nu.prior = NULL,
     initial.level.prior = NULL,
     initial.slope.prior = NULL,
     sdy,
     initial.y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add.student.local.linear.trend_+3A_state.specification">state.specification</code></td>
<td>
<p>A list of state components that you wish to add to.  If
omitted, an empty list will be assumed.  </p>
</td></tr>
<tr><td><code id="add.student.local.linear.trend_+3A_y">y</code></td>
<td>
<p>The time series to be modeled, as a numeric vector.</p>
</td></tr>
<tr><td><code id="add.student.local.linear.trend_+3A_save.weights">save.weights</code></td>
<td>
<p>A logical value indicating whether to save the
draws of the weights from the normal mixture representation.</p>
</td></tr>
<tr><td><code id="add.student.local.linear.trend_+3A_level.sigma.prior">level.sigma.prior</code></td>
<td>
<p>An object created by
<code><a href="Boom.html#topic+SdPrior">SdPrior</a></code> describing the prior distribution for
the standard deviation of the level component.</p>
</td></tr>
<tr><td><code id="add.student.local.linear.trend_+3A_level.nu.prior">level.nu.prior</code></td>
<td>
<p>An object inheritng from the class
<code><a href="Boom.html#topic+DoubleModel">DoubleModel</a></code>, representing the prior
distribution on the <code>nu</code> tail thickness parameter of the T
distribution for errors in the evolution equation for the level
component.</p>
</td></tr>
<tr><td><code id="add.student.local.linear.trend_+3A_slope.sigma.prior">slope.sigma.prior</code></td>
<td>
<p>An object created by
<code><a href="Boom.html#topic+SdPrior">SdPrior</a></code> describing the prior distribution of
the standard deviation of the slope component.</p>
</td></tr>
<tr><td><code id="add.student.local.linear.trend_+3A_slope.nu.prior">slope.nu.prior</code></td>
<td>
<p>An object inheritng from the class
<code><a href="Boom.html#topic+DoubleModel">DoubleModel</a></code>, representing the prior
distribution on the <code>nu</code> tail thickness parameter of the T
distribution for errors in the evolution equation for the slope
component.</p>
</td></tr>
<tr><td><code id="add.student.local.linear.trend_+3A_initial.level.prior">initial.level.prior</code></td>
<td>
<p>An object created by
<code><a href="Boom.html#topic+NormalPrior">NormalPrior</a></code> describing the initial distribution
of the level portion of the initial state vector.</p>
</td></tr>
<tr><td><code id="add.student.local.linear.trend_+3A_initial.slope.prior">initial.slope.prior</code></td>
<td>
<p>An object created by
<code><a href="Boom.html#topic+NormalPrior">NormalPrior</a></code> describing the prior distribution
for the slope portion of the initial state vector.</p>
</td></tr>
<tr><td><code id="add.student.local.linear.trend_+3A_sdy">sdy</code></td>
<td>
<p>The standard deviation of the series to be modeled.  This
will be ignored if <code>y</code> is provided, or if all the required
prior distributions are supplied directly.  </p>
</td></tr>
<tr><td><code id="add.student.local.linear.trend_+3A_initial.y">initial.y</code></td>
<td>
<p>The initial value of the series being modeled.  This will be
ignored if <code>y</code> is provided, or if the priors for the initial
state are all provided directly.</p>
</td></tr>
</table>


<h3>Value</h3>

<p> Returns a list with the elements necessary to specify a local
linear trend state model.</p>


<h3>Author(s)</h3>

<p>Steven L. Scott <a href="mailto:steve.the.bayesian@gmail.com">steve.the.bayesian@gmail.com</a>
</p>


<h3>References</h3>

<p>Harvey (1990), &quot;Forecasting, structural time series, and the Kalman
filter&quot;, Cambridge University Press.
</p>
<p>Durbin and Koopman (2001), &quot;Time series analysis by state space
methods&quot;, Oxford University Press.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bsts">bsts</a></code>.
<code><a href="Boom.html#topic+SdPrior">SdPrior</a></code>
<code><a href="Boom.html#topic+NormalPrior">NormalPrior</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  data(rsxfs)
  ss &lt;- AddStudentLocalLinearTrend(list(), rsxfs)
  model &lt;- bsts(rsxfs, state.specification = ss, niter = 500)
  pred &lt;- predict(model, horizon = 12, burn = 100)
  plot(pred)
</code></pre>

<hr>
<h2 id='add.trig'>
Trigonometric Seasonal State Component
</h2><span id='topic+AddTrig'></span>

<h3>Description</h3>

<p>Add a trigonometric seasonal model to a state specification.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  AddTrig(
     state.specification = NULL,
     y,
     period,
     frequencies,
     sigma.prior = NULL,
     initial.state.prior = NULL,
     sdy = sd(y, na.rm = TRUE),
     method = c("harmonic", "direct"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add.trig_+3A_state.specification">state.specification</code></td>
<td>
<p>A list of state components that you wish to
add to.  If omitted, an empty list will be assumed.  </p>
</td></tr>
<tr><td><code id="add.trig_+3A_y">y</code></td>
<td>
<p> The time series to be modeled, as a numeric vector.</p>
</td></tr>
<tr><td><code id="add.trig_+3A_period">period</code></td>
<td>
<p>A positive scalar giving the number of time steps
required for the longest cycle to repeat.</p>
</td></tr>
<tr><td><code id="add.trig_+3A_frequencies">frequencies</code></td>
<td>
<p>A vector of positive real numbers giving the number
of times each cyclic component repeats in a period.  One sine and
one cosine term will be added for each frequency.  
</p>
</td></tr>
<tr><td><code id="add.trig_+3A_sigma.prior">sigma.prior</code></td>
<td>
<p>An object created by <code><a href="Boom.html#topic+SdPrior">SdPrior</a></code>
describing the prior distribution for the standard deviation of the
increments for the harmonic coefficients.</p>
</td></tr>
<tr><td><code id="add.trig_+3A_initial.state.prior">initial.state.prior</code></td>
<td>
<p>An object created using
<code><a href="Boom.html#topic+NormalPrior">NormalPrior</a></code>, describing the prior distribution
of the the initial state vector (at time 1).</p>
</td></tr>
<tr><td><code id="add.trig_+3A_sdy">sdy</code></td>
<td>
<p>The standard deviation of the series to be modeled.  This
will be ignored if <code>y</code> is provided, or if all the required
prior distributions are supplied directly.  </p>
</td></tr>
<tr><td><code id="add.trig_+3A_method">method</code></td>
<td>
<p>The method of including the sinusoids.  The &quot;harmonic&quot;
method is strongly preferred, with &quot;direct&quot; offered mainly for
teaching purposes.  </p>
</td></tr>
</table>


<h3>Details</h3>



<h4>Harmonic Method</h4>

 
<p>Each frequency <code class="reqn">lambda_j = 2\pi j / S</code> where S
is the period (number of time points in a full cycle) is associated
with two time-varying random components: <code class="reqn">\gamma_{jt}</code>, and <code class="reqn">gamma^*_{jt}</code>.  They evolve through
time as
</p>
<p style="text-align: center;"><code class="reqn">%
     \gamma_{j, t + 1} = \gamma_{jt}  \cos(\lambda_j) + \gamma^*_{j, t}  %
     \sin(\lambda_j) + \epsilon_{0t}</code>
</p>

<p style="text-align: center;"><code class="reqn">%
      \gamma^*_{j, t + 1} = \gamma^*[j, t] \cos(\lambda_j) - \gamma_{jt} *
      \sin(\lambda_j) + \epsilon_1</code>
</p>

<p>where <code class="reqn">\epsilon_0</code> and <code class="reqn">\epsilon_1</code> are
independent with the same variance.  This is the real-valued version
of a harmonic function: <code class="reqn">\gamma \exp(i\theta)</code>.
</p>
<p>The transition matrix multiplies the function by
<code class="reqn">\exp(i \lambda_j</code>, so that
after 't' steps the harmonic's value is
<code class="reqn">\gamma \exp(i \lambda_j t)</code>.
</p>
<p>The model dynamics  allows gamma to drift over time in a random walk.
</p>
<p>The state of the model is
<code class="reqn">(\gamma_{jt}, \gamma^*_{jt})</code>,
for j = 1, ... number of frequencies.
</p>
<p>The state transition matrix is a block diagonal matrix, where block 'j' is
</p>
<p style="text-align: center;"><code class="reqn">\cos(\lambda_j)   \sin(\lambda_j)</code>
</p>

<p style="text-align: center;"><code class="reqn">-\sin(\lambda_j)  \cos(\lambda_j)</code>
</p>

<p>The error variance matrix is sigma^2 * I.  There is a common sigma^2
parameter shared by all frequencies.
</p>
<p>The model is full rank, so the state error expander matrix R_t is the
identity.
</p>
<p>The observation_matrix is (1, 0, 1, 0, ...), where the 1's pick out the
'real' part of the state contributions.
</p>



<h4>Direct Method</h4>

<p>Under the 'direct' method the trig component adds a collection of sine
and cosine terms with randomly varying coefficients to the state
model.  The coefficients are the states, while the sine and cosine
values are part of the &quot;observation matrix&quot;.
</p>
<p>This state component adds the sum of its terms to the observation
equation.
</p>
<p style="text-align: center;"><code class="reqn">y_t = \sum_j \beta_{jt} sin(f_j t) + \gamma_{jt} cos(f_j t)</code>
</p>

<p>The evolution equation is that each of the sinusoid coefficients
follows a random walk with standard deviation sigma[j].
</p>
<p style="text-align: center;"><code class="reqn">\beta_{jt} = \beta_{jt-1} + N(0, sigma_{sj}^2)
    \gamma_{jt} = \gamma_{j-1} + N(0, sigma_{cj}^2) </code>
</p>

<p>The direct method is generally inferior to the harmonic method.  It
may be removed in the future.
</p>



<h3>Value</h3>

<p>Returns a list with the elements necessary to specify a seasonal
state model.</p>


<h3>Author(s)</h3>

<p>Steven L. Scott <a href="mailto:steve.the.bayesian@gmail.com">steve.the.bayesian@gmail.com</a>
</p>


<h3>References</h3>

<p>Harvey (1990), &quot;Forecasting, structural time series, and the Kalman
filter&quot;, Cambridge University Press.
</p>
<p>Durbin and Koopman (2001), &quot;Time series analysis by state space
methods&quot;, Oxford University Press.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bsts">bsts</a></code>.
<code><a href="Boom.html#topic+SdPrior">SdPrior</a></code>
<code><a href="Boom.html#topic+MvnPrior">MvnPrior</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  data(AirPassengers)
  y &lt;- log(AirPassengers)
  ss &lt;- AddLocalLinearTrend(list(), y)
  ss &lt;- AddTrig(ss, y, period = 12, frequencies = 1:3)
  model &lt;- bsts(y, state.specification = ss, niter = 200)
  plot(model)

  ## The "harmonic" method is much more stable than the "direct" method.
  ss &lt;- AddLocalLinearTrend(list(), y)
  ss &lt;- AddTrig(ss, y, period = 12, frequencies = 1:3, method = "direct")
  model2 &lt;- bsts(y, state.specification = ss, niter = 200)
  plot(model2)

</code></pre>

<hr>
<h2 id='aggregate.time.series'>Aggregate a fine time series to a coarse summary</h2><span id='topic+AggregateTimeSeries'></span>

<h3>Description</h3>

<p> Aggregate measurements from a fine scaled time series into
a coarse time series.  This is similar to functions from the
<code>xts</code> package, but it can handle aggregation from weeks to
months.  </p>


<h3>Usage</h3>

<pre><code class='language-R'>   AggregateTimeSeries(fine.series,
                       contains.end,
                       membership.fraction,
                       trim.left = any(membership.fraction &lt; 1),
                       trim.right = NULL,
                       byrow = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="aggregate.time.series_+3A_fine.series">fine.series</code></td>
<td>
<p>A numeric vector or matrix giving the fine scale
time series to be aggregated.</p>
</td></tr>
<tr><td><code id="aggregate.time.series_+3A_contains.end">contains.end</code></td>
<td>
<p>A logical vector corresponding to
<code>fine.series</code> indicating whether each fine time interval
contains the end of a coarse time interval.</p>
</td></tr>
<tr><td><code id="aggregate.time.series_+3A_membership.fraction">membership.fraction</code></td>
<td>
<p>A numeric vector corresponding to
<code>fine.series</code>, giving the fraction of each time interval's
observation attributable to the coarse interval containing the fine
interval's first day.  This will usually be a vector of 1's, unless
<code>fine.series</code> is weekly.</p>
</td></tr>
<tr><td><code id="aggregate.time.series_+3A_trim.left">trim.left</code></td>
<td>
<p>Logical indicating whether the first observation in
the coarse aggregate should be removed.</p>
</td></tr>
<tr><td><code id="aggregate.time.series_+3A_trim.right">trim.right</code></td>
<td>
<p>Logical indicating whether the final observation in
the coarse aggregate should be removed.</p>
</td></tr>
<tr><td><code id="aggregate.time.series_+3A_byrow">byrow</code></td>
<td>
<p>Logical.  If <code>fine.series</code> is a matrix, this
argument indicates whether rows (<code>TRUE</code>) or columns
(<code>FALSE</code>) correspond to time points.</p>
</td></tr>
</table>


<h3>Value</h3>

<p> A matrix (if <code>fine.series</code> is a matrix) or vector
(otherwise) containing the aggregated values of <code>fine.series</code>.  </p>


<h3>Author(s)</h3>

<p>Steven L. Scott <a href="mailto:steve.the.bayesian@gmail.com">steve.the.bayesian@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  week.ending &lt;- as.Date(c("2011-11-05",
                           "2011-11-12",
                           "2011-11-19",
                           "2011-11-26",
                           "2011-12-03",
                           "2011-12-10",
                           "2011-12-17",
                           "2011-12-24",
                           "2011-12-31"))
  membership.fraction &lt;- GetFractionOfDaysInInitialMonth(week.ending)
  which.month &lt;- MatchWeekToMonth(week.ending, as.Date("2011-11-01"))
  contains.end &lt;- WeekEndsMonth(week.ending)

  weekly.values &lt;- rnorm(length(week.ending))
  monthly.values &lt;- AggregateTimeSeries(weekly.values, contains.end, membership.fraction)

</code></pre>

<hr>
<h2 id='aggregate.weeks.to.months'>Aggregate a weekly time series to monthly</h2><span id='topic+AggregateWeeksToMonths'></span>

<h3>Description</h3>

<p>Aggregate measurements from a weekly time series into
a monthly time series.  </p>


<h3>Usage</h3>

<pre><code class='language-R'>   AggregateWeeksToMonths(weekly.series,
                          membership.fraction = NULL,
                          trim.left = TRUE,
                          trim.right = NULL)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="aggregate.weeks.to.months_+3A_weekly.series">weekly.series</code></td>
<td>
<p>A numeric vector or matrix of class
<code><a href="zoo.html#topic+zoo">zoo</a></code> giving the weekly time series to be aggregated.
The index must be convertible to class <code><a href="base.html#topic+Date">Date</a></code>.</p>
</td></tr>
<tr><td><code id="aggregate.weeks.to.months_+3A_membership.fraction">membership.fraction</code></td>
<td>
<p>A optional numeric vector corresponding to
<code>weekly.series</code>, giving the fraction of each week's observation
attributable to the month containing the week's first day.  If
missing, then weeks will be split across months in proportion to the
number of days in each month.</p>
</td></tr>
<tr><td><code id="aggregate.weeks.to.months_+3A_trim.left">trim.left</code></td>
<td>
<p>Logical indicating whether the first observation in
the monthly aggregate should be removed.</p>
</td></tr>
<tr><td><code id="aggregate.weeks.to.months_+3A_trim.right">trim.right</code></td>
<td>
<p>Logical indicating whether the final observation in
the monthly aggregate should be removed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p> A zoo-matrix (if <code>weekly.series</code> is a matrix) or vector
(otherwise) containing the aggregated values of <code>weekly.series</code>.
</p>


<h3>Author(s)</h3>

<p>Steven L. Scott <a href="mailto:steve.the.bayesian@gmail.com">steve.the.bayesian@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+AggregateTimeSeries">AggregateTimeSeries</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  week.ending &lt;- as.Date(c("2011-11-05",
                           "2011-11-12",
                           "2011-11-19",
                           "2011-11-26",
                           "2011-12-03",
                           "2011-12-10",
                           "2011-12-17",
                           "2011-12-24",
                           "2011-12-31"))

  weekly.values &lt;- zoo(rnorm(length(week.ending)), week.ending)
  monthly.values &lt;- AggregateWeeksToMonths(weekly.values)
</code></pre>

<hr>
<h2 id='auto.ar'>
Sparse AR(p)
</h2><span id='topic+AddAutoAr'></span>

<h3>Description</h3>

<p> Add a sparse AR(p) process to the state distribution.  A
sparse AR(p) is an AR(p) process with a spike and slab prior on the
autoregression coefficients.  </p>


<h3>Usage</h3>

<pre><code class='language-R'>AddAutoAr(state.specification,
          y,
          lags = 1,
          prior = NULL,
          sdy = NULL,
          ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="auto.ar_+3A_state.specification">state.specification</code></td>
<td>
<p>A list of state components.  If omitted,
an empty list is assumed.</p>
</td></tr>
<tr><td><code id="auto.ar_+3A_y">y</code></td>
<td>
<p> A numeric vector.  The time series to be modeled.  This can
be omitted if <code>sdy</code> is supplied.</p>
</td></tr>
<tr><td><code id="auto.ar_+3A_lags">lags</code></td>
<td>
<p>The maximum number of lags (&quot;p&quot;) to be considered in the AR(p) process.</p>
</td></tr>
<tr><td><code id="auto.ar_+3A_prior">prior</code></td>
<td>
<p>An object inheriting from <code><a href="#topic+SpikeSlabArPrior">SpikeSlabArPrior</a></code>, or
<code>NULL</code>.  If the latter, then a default
<code><a href="#topic+SpikeSlabArPrior">SpikeSlabArPrior</a></code> will be created.</p>
</td></tr>
<tr><td><code id="auto.ar_+3A_sdy">sdy</code></td>
<td>
<p>The sample standard deviation of the time series to be
modeled.  Used to scale the prior distribution.  This can be omitted
if <code>y</code> is supplied.  </p>
</td></tr>
<tr><td><code id="auto.ar_+3A_...">...</code></td>
<td>
<p>Extra arguments passed to <code><a href="#topic+SpikeSlabArPrior">SpikeSlabArPrior</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The model contributes alpha[t] to the expected value of y[t], where
the transition equation is
</p>
<p style="text-align: center;"><code class="reqn">\alpha_{t} = \phi_1\alpha_{i, t-1} + \cdots + \phi_p
    \alpha_{t-p} + \epsilon_{t-1} \qquad
    \epsilon_t \sim \mathcal{N}(0, \sigma^2)</code>
</p>

<p>The state consists of the last <code>p</code> lags of <code>alpha</code>.  The
state transition matrix has <code>phi</code> in its first row, ones along
its first subdiagonal, and zeros elsewhere.  The state variance matrix
has <code>sigma^2</code> in its upper left corner and is zero elsewhere.
The observation matrix has 1 in its first element and is zero
otherwise.
</p>
<p>This model differs from the one in <code><a href="#topic+AddAr">AddAr</a></code> only in that
some of its coefficients may be set to zero.
</p>


<h3>Value</h3>

<p> Returns <code>state.specification</code> with an AR(p) state component
added to the end.</p>


<h3>Author(s)</h3>

<p>Steven L. Scott <a href="mailto:steve.the.bayesian@gmail.com">steve.the.bayesian@gmail.com</a>
</p>


<h3>References</h3>

<p>Harvey (1990), &quot;Forecasting, structural time series, and the Kalman
filter&quot;, Cambridge University Press.
</p>
<p>Durbin and Koopman (2001), &quot;Time series analysis by state space
methods&quot;, Oxford University Press.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bsts">bsts</a></code>.
<code><a href="Boom.html#topic+SdPrior">SdPrior</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 100
residual.sd &lt;- .001

# Actual values of the AR coefficients
true.phi &lt;- c(-.7, .3, .15)
ar &lt;- arima.sim(model = list(ar = true.phi),
                n = n,
                sd = 3)

## Layer some noise on top of the AR process.
y &lt;- ar + rnorm(n, 0, residual.sd)
ss &lt;- AddAutoAr(list(), y, lags = 6)

# Fit the model with knowledge with residual.sd essentially fixed at the
# true value.
model &lt;- bsts(y, state.specification=ss, niter = 500, prior = SdPrior(residual.sd, 100000))

# Now compare the empirical ACF to the true ACF.
acf(y, lag.max = 30)
points(0:30, ARMAacf(ar = true.phi, lag.max = 30), pch = "+")
points(0:30, ARMAacf(ar = colMeans(model$AR6.coefficients), lag.max = 30))
legend("topright", leg = c("empirical", "truth", "MCMC"), pch = c(NA, "+", "o"))
</code></pre>

<hr>
<h2 id='bsts'>Bayesian Structural Time Series</h2><span id='topic+bsts'></span>

<h3>Description</h3>

<p>Uses MCMC to sample from the posterior distribution of a Bayesian
structural time series model.  This function can be used either with
or without contemporaneous predictor variables (in a time series
regression).
</p>
<p>If predictor variables are present, the regression coefficients are
fixed (as opposed to time varying, though time varying coefficients
might be added as state component).  The predictors and response in
the formula are contemporaneous, so if you want lags and differences
you need to put them in the predictor matrix yourself.
</p>
<p>If no predictor variables are used, then the model is an ordinary
state space time series model.
</p>
<p>The model allows for several useful extensions beyond standard
Bayesian dynamic linear models.
</p>

<ul>
<li><p>A spike-and-slab prior is used for the (static) regression
component of models that include predictor variables.  This is
especially useful with large numbers of regressor series.
</p>
</li>
<li><p>Both the spike-and-slab component (for static regressors) and
the Kalman filter (for components of time series state) require
observations and state variables to be Gaussian.  The <code>bsts</code>
package allows for non-Gaussian error families in the observation
equation (as well as some state components) by using data
augmentation to express these families as conditionally
Gaussian. 
</p>
</li>
<li><p>As of version 0.7.0, <code>bsts</code> supports having multiple
observations at the same time point.  In this case the basic model
is taken to be
</p>
<p style="text-align: center;"><code class="reqn">y_{t,j} = Z_t^T \alpha_t + \beta^Tx_{t, j} + \epsilon_{t,j}.</code>
</p>

<p>This is a regression model where all observations with the same
time point share a common time series effect.

</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>bsts(formula,
     state.specification,
     family = c("gaussian", "logit", "poisson", "student"),
     data,
     prior,
     contrasts = NULL,
     na.action = na.pass,
     niter,
     ping = niter / 10,
     model.options = BstsOptions(),
     timestamps = NULL,
     seed = NULL,
     ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bsts_+3A_formula">formula</code></td>
<td>
<p> A formula describing the regression portion of the
relationship between y and X.
</p>
<p>If no regressors are desired then the formula can be replaced by a
numeric vector giving the time series to be modeled.  Missing values
are not allowed in predictors, but they are allowed in the response
variable.
</p>
<p>If the response variable is of class <code><a href="zoo.html#topic+zoo">zoo</a></code>,
<code><a href="xts.html#topic+xts">xts</a></code>, or <code><a href="stats.html#topic+ts">ts</a></code>, then the time series
information it contains will be used in many of the plotting methods
called from <code><a href="#topic+plot.bsts">plot.bsts</a></code>.  </p>
</td></tr>
<tr><td><code id="bsts_+3A_state.specification">state.specification</code></td>
<td>
<p>A list with elements created by
<code><a href="#topic+AddLocalLinearTrend">AddLocalLinearTrend</a></code>, <code><a href="#topic+AddSeasonal">AddSeasonal</a></code>, and similar
functions for adding components of state.  See the help page for
<code><a href="#topic+state.specification">state.specification</a></code>.</p>
</td></tr>
<tr><td><code id="bsts_+3A_family">family</code></td>
<td>
<p>The model family for the observation equation.
Non-Gaussian model families use data augmentation to recover a
conditionally Gaussian model.</p>
</td></tr>
<tr><td><code id="bsts_+3A_data">data</code></td>
<td>
<p>An optional data frame, list or environment (or object
coercible by <code><a href="base.html#topic+as.data.frame">as.data.frame</a></code> to a data frame) containing the
variables in the model.  If not found in <code>data</code>, the variables
are taken from <code>environment(formula)</code>, typically the
environment from which <code><a href="#topic+bsts">bsts</a></code> is called.</p>
</td></tr>
<tr><td><code id="bsts_+3A_prior">prior</code></td>
<td>
<p>If regressors are supplied in the model formula, then
this is a prior distribution for the regression component of the
model, as created by <code><a href="BoomSpikeSlab.html#topic+SpikeSlabPrior">SpikeSlabPrior</a></code>.  The prior
for the time series component of the model will be specified during
the creation of state.specification.  This argument is only used if
a formula is specified.
</p>
<p>If the model contains no regressors, then this is simply the prior
on the residual standard deviation, expressed as an object created
by <code><a href="Boom.html#topic+SdPrior">SdPrior</a></code>. </p>
</td></tr>
<tr><td><code id="bsts_+3A_contrasts">contrasts</code></td>
<td>
<p>An optional list containing the names of contrast
functions to use when converting factors numeric variables in a
regression formula.  This argument works exactly as it does in
<code><a href="stats.html#topic+lm">lm</a></code>.  The names of the list elements correspond to
factor variables in your model formula.  The list elements
themselves are the names of contrast functions (see
<code>help(<a href="stats.html#topic+contr.treatment">contr.treatment</a>)</code> and the
<code>contrasts.arg</code> argument to
<code><a href="stats.html#topic+model.matrix.default">model.matrix.default</a></code>).  This argument is only used if
a model formula is specified, and even then the default is probably
what you want.</p>
</td></tr>
<tr><td><code id="bsts_+3A_na.action">na.action</code></td>
<td>
<p>What to do about missing values.  The default is to
allow missing responses, but no missing predictors.  Set this to
na.omit or na.exclude if you want to omit missing responses
altogether.</p>
</td></tr>
<tr><td><code id="bsts_+3A_niter">niter</code></td>
<td>
<p>A positive integer giving the desired number of MCMC
draws.</p>
</td></tr>
<tr><td><code id="bsts_+3A_ping">ping</code></td>
<td>
<p> A scalar giving the desired frequency of status messages.
If ping &gt; 0 then the program will print a status message to the
screen every <code>ping</code> MCMC iterations.</p>
</td></tr>
<tr><td><code id="bsts_+3A_model.options">model.options</code></td>
<td>
<p>An object (list) returned by
<code><a href="#topic+BstsOptions">BstsOptions</a></code>.  See that function for details.  </p>
</td></tr>
<tr><td><code id="bsts_+3A_timestamps">timestamps</code></td>
<td>
<p>The timestamp associated with each value of the
response.  This argument is primarily useful in cases where the
response has missing gaps, or where there are multiple observations
per time point.  If the response is a &quot;regular&quot; time series with a
single observation per time point then you can leave this argument
as <code>NULL</code>.  In that case, if either the response or the
<code>data</code> argument is a type convertible to <code><a href="zoo.html#topic+zoo">zoo</a></code> then
timestamps will be inferred.</p>
</td></tr>
<tr><td><code id="bsts_+3A_seed">seed</code></td>
<td>
<p>An integer to use as the random seed for the underlying
C++ code.  If <code>NULL</code> then the seed will be set using the
clock.</p>
</td></tr>
<tr><td><code id="bsts_+3A_...">...</code></td>
<td>
<p> Extra arguments to be passed to
<code><a href="BoomSpikeSlab.html#topic+SpikeSlabPrior">SpikeSlabPrior</a></code> (see the entry for the
<code>prior</code> argument, above).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the model family is logit, then there are two ways one can
format the response variable.  If the response is 0/1,
TRUE/FALSE, or 1/-1, then the response variable can be passed
as with any other model family.  If the response is a set of
counts out of a specified number of trials then it can be
passed as a two-column matrix, where the first column contains
the counts of successes and the second contains the count of
failures.
</p>
<p>Likewise, if the model family is Poisson, the response can be passed
as a single vector of counts, under the assumption that each
observation has unit exposure.  If the exposures differ across
observations, then the resopnse can be a two column matrix, with the
first column containing the event counts and the second containing
exposure times.  </p>


<h3>Value</h3>

<p>An object of class <code><a href="#topic+bsts">bsts</a></code> which is a list with the
following components
</p>
<table>
<tr><td><code>coefficients</code></td>
<td>
<p> A <code>niter</code> by <code>ncol(X)</code> matrix of MCMC
draws of the regression coefficients, where <code>X</code> is the design
matrix implied by <code>formula</code>.  This is only present if a model
formula was supplied.</p>
</td></tr>
<tr><td><code>sigma.obs</code></td>
<td>
<p>A vector of length <code>niter</code> containing MCMC draws
of the residual standard deviation.</p>
</td></tr>
</table>
<p>The returned object will also contain named elements holding the MCMC
draws of model parameters belonging to the state models.  The names of
each component are supplied by the entries in
<code>state.specification</code>.  If a model parameter is a scalar, then
the list element is a vector with <code>niter</code> elements.  If the
parameter is a vector then the list element is a matrix with
<code>niter</code> rows.  If the parameter is a matrix then the list element
is a 3-way array with first dimension <code>niter</code>.
</p>
<p>Finally, if a model formula was supplied, then the returned object
will contain the information necessary for the predict method to build
the design matrix when a new prediction is made.
</p>


<h3>Author(s)</h3>

<p>Steven L. Scott  <a href="mailto:steve.the.bayesian@gmail.com">steve.the.bayesian@gmail.com</a>
</p>


<h3>References</h3>

<p>Scott and Varian (2014)
&quot;Predicting the Present with Bayesian Structural Time Series&quot;,
International Journal of Mathematical Modelling and Numerical
Optimization.  4&ndash;23.
</p>
<p>Scott and Varian (2015)
&quot;Bayesian Variable Selection for Nowcasting Economic Time Series&quot;,
Economic Analysis of the Digital Economy, pp 119-135.
</p>
<p>Harvey (1990), &quot;Forecasting, structural time series, and the Kalman
filter&quot;, Cambridge University Press.
</p>
<p>Durbin and Koopman (2001), &quot;Time series analysis by state space
methods&quot;, Oxford University Press.
</p>
<p>George and McCulloch (1997)
&quot;Approaches for Bayesian variable selection&quot;, Statistica Sinica pp
339&ndash;374.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bsts">bsts</a></code>,
<code><a href="#topic+AddLocalLevel">AddLocalLevel</a></code>,
<code><a href="#topic+AddLocalLinearTrend">AddLocalLinearTrend</a></code>,
<code><a href="#topic+AddSemilocalLinearTrend">AddSemilocalLinearTrend</a></code>,
<code><a href="#topic+AddSeasonal">AddSeasonal</a></code>
<code><a href="#topic+AddDynamicRegression">AddDynamicRegression</a></code>
<code><a href="BoomSpikeSlab.html#topic+SpikeSlabPrior">SpikeSlabPrior</a></code>,
<code><a href="Boom.html#topic+SdPrior">SdPrior</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  ## Example 1:  Time series (ts) data
  data(AirPassengers)
  y &lt;- log(AirPassengers)
  ss &lt;- AddLocalLinearTrend(list(), y)
  ss &lt;- AddSeasonal(ss, y, nseasons = 12)
  model &lt;- bsts(y, state.specification = ss, niter = 500)
  pred &lt;- predict(model, horizon = 12, burn = 100)
  par(mfrow = c(1,2))
  plot(model)
  plot(pred)

## Not run: 

  MakePlots &lt;- function(model, ask = TRUE) {
    ## Make all the plots callable by plot.bsts.
    opar &lt;- par(ask = ask)
    on.exit(par(opar))
    plot.types &lt;- c("state", "components", "residuals",
                    "prediction.errors", "forecast.distribution")
    for (plot.type in plot.types) {
      plot(model, plot.type)
    }
    if (model$has.regression) {
      regression.plot.types &lt;- c("coefficients", "predictors", "size")
      for (plot.type in regression.plot.types) {
        plot(model, plot.type)
      }
    }
  }

  ## Example 2: GOOG is the Google stock price, an xts series of daily
  ##            data.
  data(goog)
  ss &lt;- AddSemilocalLinearTrend(list(), goog)
  model &lt;- bsts(goog, state.specification = ss, niter = 500)
  MakePlots(model)

  ## Example 3:  Change GOOG to be zoo, and not xts.
  goog &lt;- zoo(goog, index(goog))
  ss &lt;- AddSemilocalLinearTrend(list(), goog)
  model &lt;- bsts(goog, state.specification = ss, niter = 500)
  MakePlots(model)

  ## Example 4:  Naked numeric data works too
  y &lt;- rnorm(100)
  ss &lt;- AddLocalLinearTrend(list(), y)
  model &lt;- bsts(y, state.specification = ss, niter = 500)
  MakePlots(model)

  ## Example 5:  zoo data with intra-day measurements
  y &lt;- zoo(rnorm(100),
           seq(from = as.POSIXct("2012-01-01 7:00 EST"), len = 100, by = 100))
  ss &lt;- AddLocalLinearTrend(list(), y)
  model &lt;- bsts(y, state.specification = ss, niter = 500)
  MakePlots(model)

\dontrun{
  ## Example 6:  Including regressors
  data(iclaims)
  ss &lt;- AddLocalLinearTrend(list(), initial.claims$iclaimsNSA)
  ss &lt;- AddSeasonal(ss, initial.claims$iclaimsNSA, nseasons = 52)
  model &lt;- bsts(iclaimsNSA ~ ., state.specification = ss, data =
                initial.claims, niter = 1000)
  plot(model)
  plot(model, "components")
  plot(model, "coefficients")
  plot(model, "predictors")
}

## End(Not run)

## Not run: 
  ## Example 7:  Regressors with multiple time stamps.
  number.of.time.points &lt;- 50
  sample.size.per.time.point &lt;- 10
  total.sample.size &lt;- number.of.time.points * sample.size.per.time.point
  sigma.level &lt;- .1
  sigma.obs &lt;- 1

  ## Simulate some fake data with a local level state component.
  trend &lt;- cumsum(rnorm(number.of.time.points, 0, sigma.level))
  predictors &lt;- matrix(rnorm(total.sample.size * 2), ncol = 2)
  colnames(predictors) &lt;- c("X1", "X2")
  coefficients &lt;- c(-10, 10)
  regression &lt;- as.numeric(predictors %*% coefficients)
  y.hat &lt;- rep(trend, sample.size.per.time.point) + regression
  y &lt;- rnorm(length(y.hat), y.hat, sigma.obs)

  ## Create some time stamps, with multiple observations per time stamp.
  first &lt;- as.POSIXct("2013-03-24")
  dates &lt;- seq(from = first, length = number.of.time.points, by = "month")
  timestamps &lt;- rep(dates, sample.size.per.time.point)

  ## Run the model with a local level trend, and an unnecessary seasonal component.
  ss &lt;- AddLocalLevel(list(), y)
  ss &lt;- AddSeasonal(ss, y, nseasons = 7)
  model &lt;- bsts(y ~ predictors, ss, niter = 250, timestamps = timestamps,
                seed = 8675309)
  plot(model)
  plot(model, "components")

## End(Not run)

## Example 8: Non-Gaussian data
## Poisson counts of shark attacks in Florida.
data(shark)
logshark &lt;- log1p(shark$Attacks)
ss.level &lt;- AddLocalLevel(list(), y = logshark)
model &lt;- bsts(shark$Attacks, ss.level, niter = 500,
              ping = 250, family = "poisson", seed = 8675309)

## Poisson data can have an 'exposure' as the second column of a
## two-column matrix.
model &lt;- bsts(cbind(shark$Attacks, shark$Population / 1000),
              state.specification = ss.level, niter = 500,
              family = "poisson", ping = 250, seed = 8675309)

</code></pre>

<hr>
<h2 id='bsts-package'>
bsts
</h2><span id='topic+bsts-package'></span>

<h3>Description</h3>

<p>Time series regression using dynamic linear models fit using
MCMC. See Scott and Varian (2014) &lt;DOI:10.1504/IJMMNO.2014.059942&gt;, among many
other sources.
</p>


<h3>Details</h3>



<h4>Installation note for Linux users</h4>

<p> If you are installing bsts
using <code><a href="utils.html#topic+install.packages">install.packages</a></code> on a Linux machine (and thus
compiling yourself) you will almost certainly want to set the
<code>Ncpus</code> argument to a large number.  Windows and Mac users can
ignore this advice.  </p>



<h3>Author(s)</h3>

<p>Author: Steven L. Scott &lt;steve.the.bayesian@gmail.com&gt;
Maintainer: Steven L. Scott &lt;steve.the.bayesian@gmail.com&gt;
</p>


<h3>References</h3>

<p>Please see the references in the help page for the <code><a href="#topic+bsts">bsts</a></code> function.
</p>


<h3>See Also</h3>

<p>See the examples in the <code><a href="#topic+bsts">bsts</a></code> function.
</p>

<hr>
<h2 id='bsts.options.Rd'>Bsts Model Options</h2><span id='topic+BstsOptions'></span>

<h3>Description</h3>

<p>Rarely used modeling options for bsts models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BstsOptions(save.state.contributions = TRUE,
            save.prediction.errors = TRUE,
            bma.method = c("SSVS", "ODA"),
            oda.options = list(
                fallback.probability = 0.0,
                eigenvalue.fudge.factor = 0.01),
            timeout.seconds = Inf,
            save.full.state = FALSE)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bsts.options.Rd_+3A_save.state.contributions">save.state.contributions</code></td>
<td>
<p>Logical.  If <code>TRUE</code> then a 3-way
array named <code>state.contributions</code> will be stored in the
returned object.  The indices correspond to MCMC iteration, state
model number, and time.  Setting <code>save.state.contributions</code> to
<code>FALSE</code> yields a smaller object, but <code>plot</code> will not be
able to plot the the &quot;state&quot;, &quot;components&quot;, or &quot;residuals&quot; for the
fitted model.</p>
</td></tr>
<tr><td><code id="bsts.options.Rd_+3A_save.prediction.errors">save.prediction.errors</code></td>
<td>
<p>Logical.  If <code>TRUE</code> then a matrix
named <code>one.step.prediction.errors</code> will be saved as part of the
model object.  The rows of the matrix represent MCMC iterations, and
the columns represent time.  The matrix entries are the
one-step-ahead prediction errors from the Kalman filter.  </p>
</td></tr>
<tr><td><code id="bsts.options.Rd_+3A_bma.method">bma.method</code></td>
<td>
<p>If the model contains a regression component, this
argument specifies the method to use for Bayesian model averaging.
&quot;SSVS&quot; is stochastic search variable selection, which is the classic
approach from George and McCulloch (1997).  &quot;ODA&quot; is orthoganal data
augmentation, from Ghosh and Clyde (2011).  It adds a set of latent
observations that make the <code class="reqn">X^TX</code> matrix diagonal, vastly
simplifying complete data MCMC for model selection.</p>
</td></tr>
<tr><td><code id="bsts.options.Rd_+3A_oda.options">oda.options</code></td>
<td>
<p>If bma.method == &quot;ODA&quot; then these are some options
for fine tuning the ODA algorithm.
</p>

<ul>
<li> <p><code>fallback.probability</code>: Each MCMC iteration will use
SSVS instead of ODA with this probability.  In cases where
the latent data have high leverage, ODA mixing can suffer.
Mixing in a few SSVS steps can help keep an errant algorithm
on track.
</p>
</li>
<li> <p><code>eigenvalue.fudge.factor</code>: The latent X's will be
chosen so that the complete data <code class="reqn">X^TX</code> matrix (after
scaling) is a constant diagonal matrix equal to the largest
eigenvalue of the observed (scaled) <code class="reqn">X^TX</code> times (1 +
eigenvalue.fudge.factor).  This should be a small positive number.
</p>
</li></ul>
 </td></tr>
<tr><td><code id="bsts.options.Rd_+3A_timeout.seconds">timeout.seconds</code></td>
<td>
<p>The number of seconds that sampler will be
allowed to run.  If the timeout is exceeded the returned object will
be truncated to the final draw that took place before the timeout
occurred, as if that had been the requested number of iterations.</p>
</td></tr>
<tr><td><code id="bsts.options.Rd_+3A_save.full.state">save.full.state</code></td>
<td>
<p>Logical.  If <code>TRUE</code> then the full
distribution of the state vector will be preserved.  It will be
stored in the model under the name <code>full.state</code>, which is a
3-way array with dimenions corresponding to MCMC iteration, state
dimension, and time.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The arguments are checked to make sure they have legal types and
values, then a list is returned containing the arguments.
</p>


<h3>Author(s)</h3>

<p>Steven L. Scott <a href="mailto:steve.the.bayesian@gmail.com">steve.the.bayesian@gmail.com</a>
</p>

<hr>
<h2 id='compare.bsts.models'>
Compare bsts models
</h2><span id='topic+CompareBstsModels'></span>

<h3>Description</h3>

<p> Produce a set of line plots showing the cumulative
absolute one step ahead prediction errors for different models.  This
plot not only shows which model is doing the best job predicting the
data, it highlights regions of the data where the predictions are
particularly good or bad.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CompareBstsModels(model.list,
                  burn = SuggestBurn(.1, model.list[[1]]),
                  filename = "",
                  colors = NULL,
                  lwd = 2,
                  xlab = "Time",
                  main = "",
                  grid = TRUE,
                  cutpoint = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compare.bsts.models_+3A_model.list">model.list</code></td>
<td>
<p>A list of <code><a href="#topic+bsts">bsts</a></code> models.</p>
</td></tr>
<tr><td><code id="compare.bsts.models_+3A_burn">burn</code></td>
<td>
<p>The number of initial MCMC iterations to remove from each
model as burn-in.</p>
</td></tr>
<tr><td><code id="compare.bsts.models_+3A_filename">filename</code></td>
<td>
<p> A string.  If non-empty string then a pdf of the plot
will be saved in the specified file.</p>
</td></tr>
<tr><td><code id="compare.bsts.models_+3A_colors">colors</code></td>
<td>
<p>A vector of colors to use for the different lines in the
plot.  If <code>NULL</code> then the <code><a href="grDevices.html#topic+rainbow">rainbow</a></code> pallette will
be used.  </p>
</td></tr>
<tr><td><code id="compare.bsts.models_+3A_lwd">lwd</code></td>
<td>
<p>The width of the lines to be drawn.</p>
</td></tr>
<tr><td><code id="compare.bsts.models_+3A_xlab">xlab</code></td>
<td>
<p>Label for the horizontal axis.</p>
</td></tr>
<tr><td><code id="compare.bsts.models_+3A_main">main</code></td>
<td>
<p>Main title for the plot.</p>
</td></tr>
<tr><td><code id="compare.bsts.models_+3A_grid">grid</code></td>
<td>
<p>Logical.  Should gridlines be drawn in the background?</p>
</td></tr>
<tr><td><code id="compare.bsts.models_+3A_cutpoint">cutpoint</code></td>
<td>
<p>Either <code>NULL</code>, or an integer giving the
observation number used to define a holdout sample.  Prediction
errors occurring after the cutpoint will be true out of sample
errors.  If <code>NULL</code> then all prediction errors are &quot;in sample&quot;.
See the discussion in <code><a href="#topic+bsts.prediction.errors">bsts.prediction.errors</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Invisibly returns the matrix of cumulative one-step ahead prediction
errors (the lines in the top panel of the plot).  Each row in the
matrix corresponds to a model in model.list.
</p>


<h3>Author(s)</h3>

<p>Steven L. Scott  <a href="mailto:steve.the.bayesian@gmail.com">steve.the.bayesian@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  data(AirPassengers)
  y &lt;- log(AirPassengers)
  ss &lt;- AddLocalLinearTrend(list(), y)
  trend.only &lt;- bsts(y, ss, niter = 250)

  ss &lt;- AddSeasonal(ss, y, nseasons = 12)
  trend.and.seasonal &lt;- bsts(y, ss, niter = 250)

  CompareBstsModels(list(trend = trend.only,
                         "trend and seasonal" = trend.and.seasonal))

  CompareBstsModels(list(trend = trend.only,
                         "trend and seasonal" = trend.and.seasonal),
                          cutpoint = 100)

</code></pre>

<hr>
<h2 id='date.range'>
Date Range
</h2><span id='topic+DateRange'></span>

<h3>Description</h3>

<p>Returns the first and last dates of the influence window for the given
holiday, among the given timestamps.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  DateRange(holiday, timestamps)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="date.range_+3A_holiday">holiday</code></td>
<td>
<p>An object of class <code><a href="#topic+Holiday">Holiday</a></code>.</p>
</td></tr>
<tr><td><code id="date.range_+3A_timestamps">timestamps</code></td>
<td>
<p>A vector of timestamps of class <code><a href="base.html#topic+Date">Date</a></code>
or class <code><a href="base.html#topic+POSIXt">POSIXt</a></code>.  This function assumes daily
data.  Use with care in other settings.</p>
</td></tr>
</table>


<h3>Value</h3>

<p> Returns a two-column data frame giving the first and last dates
of the influence window for the holiday in the period covered by
<code>timestamps</code>.
</p>


<h3>Author(s)</h3>

<p>Steven L. Scott <a href="mailto:steve.the.bayesian@gmail.com">steve.the.bayesian@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
holiday &lt;- NamedHoliday("MemorialDay", days.before = 2, days.after = 2)
timestamps &lt;- seq.Date(from = as.Date("2001-01-01"), by = "day",
   length.out = 365 * 10)
influence &lt;- DateRange(holiday, timestamps)

</code></pre>

<hr>
<h2 id='descriptive-plots'>Descriptive Plots</h2><span id='topic+YearPlot'></span><span id='topic+MonthPlot'></span><span id='topic+DayPlot'></span>

<h3>Description</h3>

<p>Plots for describing time series data.</p>


<h3>Usage</h3>

<pre><code class='language-R'>  DayPlot(y, colors = NULL, ylab = NULL, ...)
  MonthPlot(y, seasonal.identifier = months, colors = NULL, ylab = NULL, ...)
  YearPlot(y, colors = NULL, ylab = NULL, ylim = NULL, legend = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="descriptive-plots_+3A_y">y</code></td>
<td>
<p>A time series to plot.  Must be of class <code><a href="stats.html#topic+ts">ts</a></code>, or
<code><a href="zoo.html#topic+zoo">zoo</a></code>.  If a zoo object then the timestamps must be of
type <code><a href="base.html#topic+Date">Date</a></code>, <code><a href="zoo.html#topic+yearmon">yearmon</a></code>, or <code><a href="base.html#topic+POSIXt">POSIXt</a></code>.
</p>
</td></tr>
<tr><td><code id="descriptive-plots_+3A_seasonal.identifier">seasonal.identifier</code></td>
<td>

<p>A function that takes a vector of class <code><a href="base.html#topic+POSIXt">POSIXt</a></code>
(date/time) and returns a character vector indicating the season to
which each element belongs.  Each unique element returned by this
function returns a &quot;season&quot; to be plotted.  See
<code><a href="base.html#topic+weekdays">weekdays</a></code>, <code><a href="base.html#topic+months">months</a></code>,
and <code><a href="base.html#topic+quarters">quarters</a></code> for examples of how this should work.  </p>
</td></tr>
<tr><td><code id="descriptive-plots_+3A_colors">colors</code></td>
<td>
<p>A vector of colors to use for the lines.</p>
</td></tr>
<tr><td><code id="descriptive-plots_+3A_legend">legend</code></td>
<td>
<p>Logical.  If <code>TRUE</code> then a legend is added to the plot.</p>
</td></tr>
<tr><td><code id="descriptive-plots_+3A_ylab">ylab</code></td>
<td>
<p>Label for the vertical axis.</p>
</td></tr>
<tr><td><code id="descriptive-plots_+3A_ylim">ylim</code></td>
<td>
<p>Limits for the vertical axis. (a 2-vector)</p>
</td></tr>
<tr><td><code id="descriptive-plots_+3A_...">...</code></td>
<td>
<p>Extra arguments passed to <code><a href="graphics.html#topic+plot">plot</a></code> or <code><a href="graphics.html#topic+lines">lines</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>DayPlot</code> and <code>MonthPlot</code> plot the time series one season at
a time, on the same set of axes.  The intent is to use DayPlot for
daily data and MonthPlot for monthly or quarterly data.
</p>
<p><code>YearPlot</code> plots each year of the time series as a separate line
on the same set of axes.
</p>
<p>Both sets of plots help visualize seasonal patterns.
</p>


<h3>Value</h3>

<p>Returns <code>invisible{NULL}</code>.
</p>


<h3>See Also</h3>

 <p><code><a href="stats.html#topic+monthplot">monthplot</a></code> is a base R function for plotting time
series of type <code><a href="stats.html#topic+ts">ts</a></code>.  </p>


<h3>Examples</h3>

<pre><code class='language-R'>## Plot a 'ts' time series.
data(AirPassengers)
par(mfrow = c(1,2))
MonthPlot(AirPassengers)
YearPlot(AirPassengers)

## Plot a 'zoo' time series.
data(turkish)
par(mfrow = c(1,2))
YearPlot(turkish)
DayPlot(turkish)

</code></pre>

<hr>
<h2 id='diagnostic-plots'>Diagnostic Plots</h2><span id='topic+qqdist'></span><span id='topic+AcfDist'></span>

<h3>Description</h3>

<p>Diagnostic plots for distributions of residuals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  qqdist(draws, ...)
  AcfDist(draws, lag.max = NULL, xlab = "Lag", ylab = "Autocorrelation", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="diagnostic-plots_+3A_draws">draws</code></td>
<td>
<p>A matrix of Monte Carlo draws of residual errors.  Each
row is a Monte Carlo draw, and each column is an observation.  In the
case of AcfDist successive observations are assumed to be sequential
in time.</p>
</td></tr>
<tr><td><code id="diagnostic-plots_+3A_lag.max">lag.max</code></td>
<td>
<p>The number of lags to plot in the autocorrelation
function.  See <code><a href="stats.html#topic+acf">acf</a></code>.</p>
</td></tr>
<tr><td><code id="diagnostic-plots_+3A_xlab">xlab</code></td>
<td>
<p>Label for the horizontal axis.</p>
</td></tr>
<tr><td><code id="diagnostic-plots_+3A_ylab">ylab</code></td>
<td>
<p>Label for the vertical axis.</p>
</td></tr>
<tr><td><code id="diagnostic-plots_+3A_...">...</code></td>
<td>
<p>Extra arguments passed to either <code><a href="graphics.html#topic+boxplot">boxplot</a></code>
(for <code>AcfDist</code>) or <code><a href="Boom.html#topic+PlotDynamicDistribution">PlotDynamicDistribution</a></code> (for
<code>qqdist</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>qqdist</code> sorts the columns of <code>draws</code> by their mean, and
plots the resulting set of curves against the quantiles of the
standard normal distribution.  A reference line is added, and the mean
of each column of draws is represented by a blue dot.  The dots and
the line are the transpose of what you get with <code><a href="stats.html#topic+qqnorm">qqnorm</a></code>
and <code><a href="stats.html#topic+qqline">qqline</a></code>.
</p>
<p><code>AcfDist</code> plots the posterior distribution of the autocorrelation
function using a set of side-by-side boxplots.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(AirPassengers)
y &lt;- log(AirPassengers)

ss &lt;- AddLocalLinearTrend(list(), y)
ss &lt;- AddSeasonal(ss, y, nseasons = 12)
model &lt;- bsts(y, ss, niter = 500)

r &lt;- residuals(model)
par(mfrow = c(1,2))
qqdist(r)   ## A bit of departure in the upper tail
AcfDist(r)  

</code></pre>

<hr>
<h2 id='dirm'>Dynamic intercept regression model</h2><span id='topic+dirm'></span>

<h3>Description</h3>

<p>A dynamic intercept regression is a regression model where the
intercept term is a state space model.  This model differs from
<code><a href="#topic+bsts">bsts</a></code> in that there can be multiple observations per time
point.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dirm(formula,
     state.specification,
     data,
     prior = NULL,
     contrasts = NULL,
     na.action = na.pass,
     niter,
     ping = niter / 10,
     model.options = DirmModelOptions(),
     timestamps = NULL,
     seed = NULL,
     ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dirm_+3A_formula">formula</code></td>
<td>
<p> A formula, as you would supply to <code><a href="stats.html#topic+lm">lm</a></code>
describing the regression portion of the relationship between y and
X.</p>
</td></tr>
<tr><td><code id="dirm_+3A_state.specification">state.specification</code></td>
<td>
<p>A list with elements created by
<code><a href="#topic+AddLocalLinearTrend">AddLocalLinearTrend</a></code>, <code><a href="#topic+AddSeasonal">AddSeasonal</a></code>, and similar
functions for adding components of state.  See the help page for
<code><a href="#topic+state.specification">state.specification</a></code>.
</p>
<p>The state specification describes the dynamic intercept term in the
regression model.
</p>
</td></tr>
<tr><td><code id="dirm_+3A_data">data</code></td>
<td>
<p>An optional data frame, list or environment (or object
coercible by <code><a href="base.html#topic+as.data.frame">as.data.frame</a></code> to a data frame) containing the
variables in the model.  If not found in <code>data</code>, the variables
are taken from <code>environment(formula)</code>, typically the
environment from which <code><a href="#topic+dirm">dirm</a></code> is called.</p>
</td></tr>
<tr><td><code id="dirm_+3A_prior">prior</code></td>
<td>
<p>A prior distribution for the regression component of the
model, as created by <code><a href="BoomSpikeSlab.html#topic+SpikeSlabPrior">SpikeSlabPrior</a></code>.
The prior for the time series component of the model will be
specified during the creation of state.specification.  </p>
</td></tr>
<tr><td><code id="dirm_+3A_contrasts">contrasts</code></td>
<td>
<p>An optional list containing the names of contrast
functions to use when converting factors numeric variables in a
regression formula.  This argument works exactly as it does in
<code><a href="stats.html#topic+lm">lm</a></code>.  The names of the list elements correspond to
factor variables in your model formula.  The list elements
themselves are the names of contrast functions (see
<code>help(<a href="stats.html#topic+contr.treatment">contr.treatment</a>)</code> and the
<code>contrasts.arg</code> argument to
<code><a href="stats.html#topic+model.matrix.default">model.matrix.default</a></code>).  This argument can usually be
omitted.</p>
</td></tr>
<tr><td><code id="dirm_+3A_na.action">na.action</code></td>
<td>
<p>What to do about missing values.  The default is to
allow missing responses, but no missing predictors.  Set this to
na.omit or na.exclude if you want to omit missing responses
altogether.</p>
</td></tr>
<tr><td><code id="dirm_+3A_niter">niter</code></td>
<td>
<p>A positive integer giving the desired number of MCMC
draws.</p>
</td></tr>
<tr><td><code id="dirm_+3A_ping">ping</code></td>
<td>
<p> A scalar giving the desired frequency of status messages.
If ping &gt; 0 then the program will print a status message to the
screen every <code>ping</code> MCMC iterations.</p>
</td></tr>
<tr><td><code id="dirm_+3A_model.options">model.options</code></td>
<td>
<p> An object created by
<code><a href="#topic+DirmModelOptions">DirmModelOptions</a></code> specifying the desired model
options. </p>
</td></tr>
<tr><td><code id="dirm_+3A_timestamps">timestamps</code></td>
<td>
<p>The timestamp associated with each value of the
response.  This is most likely a <code><a href="base.html#topic+Date">Date</a></code> or
<code><a href="base.html#topic+POSIXt">POSIXt</a></code>.  It is expected that there will be multiple
observations per time point (otherwise 'bsts' should be used instead
of 'dirm'), and thus the 'timestamps' argument will contain many
duplicate values.
</p>
</td></tr>
<tr><td><code id="dirm_+3A_seed">seed</code></td>
<td>
<p>An integer to use as the random seed for the underlying
C++ code.  If <code>NULL</code> then the seed will be set using the
clock.</p>
</td></tr>
<tr><td><code id="dirm_+3A_...">...</code></td>
<td>
<p> Extra arguments to be passed to
<code><a href="BoomSpikeSlab.html#topic+SpikeSlabPrior">SpikeSlabPrior</a></code> (see the entry for the
<code>prior</code> argument, above).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The fitted model is a regression model with an intercept term given by
a structural time series model.  This is similar to the model fit by
<code><a href="#topic+bsts">bsts</a></code>, but it allows for multiple observations per time
period.
</p>
<p>Currently <code>dirm</code> only supports Gaussian observation errors, but
look for that to change in future releases.
</p>


<h3>Value</h3>

<p>An object of class <code><a href="#topic+bsts">bsts</a></code> which is a list with the
following components
</p>
<table>
<tr><td><code>coefficients</code></td>
<td>
<p> A <code>niter</code> by <code>ncol(X)</code> matrix of MCMC
draws of the regression coefficients, where <code>X</code> is the design
matrix implied by <code>formula</code>.  This is only present if a model
formula was supplied.</p>
</td></tr>
<tr><td><code>sigma.obs</code></td>
<td>
<p>A vector of length <code>niter</code> containing MCMC draws
of the residual standard deviation.</p>
</td></tr>
</table>
<p>The returned object will also contain named elements holding the MCMC
draws of model parameters belonging to the state models.  The names of
each component are supplied by the entries in
<code>state.specification</code>.  If a model parameter is a scalar, then
the list element is a vector with <code>niter</code> elements.  If the
parameter is a vector then the list element is a matrix with
<code>niter</code> rows.  If the parameter is a matrix then the list element
is a 3-way array with first dimension <code>niter</code>.
</p>
<p>Finally, if a model formula was supplied, then the returned object
will contain the information necessary for the predict method to build
the design matrix when a new prediction is made.
</p>


<h3>Author(s)</h3>

<p>Steven L. Scott  <a href="mailto:steve.the.bayesian@gmail.com">steve.the.bayesian@gmail.com</a>
</p>


<h3>References</h3>

<p>Harvey (1990), &quot;Forecasting, structural time series, and the Kalman
filter&quot;, Cambridge University Press.
</p>
<p>Durbin and Koopman (2001), &quot;Time series analysis by state space
methods&quot;, Oxford University Press.
</p>
<p>George and McCulloch (1997)
&quot;Approaches for Bayesian variable selection&quot;, Statistica Sinica pp
339&ndash;374.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bsts">bsts</a></code>,
<code><a href="#topic+AddLocalLevel">AddLocalLevel</a></code>,
<code><a href="#topic+AddLocalLinearTrend">AddLocalLinearTrend</a></code>,
<code><a href="#topic+AddSemilocalLinearTrend">AddSemilocalLinearTrend</a></code>,
<code><a href="#topic+AddSeasonal">AddSeasonal</a></code>
<code><a href="#topic+AddDynamicRegression">AddDynamicRegression</a></code>
<code><a href="BoomSpikeSlab.html#topic+SpikeSlabPrior">SpikeSlabPrior</a></code>,
<code><a href="Boom.html#topic+SdPrior">SdPrior</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
SimulateDirmData &lt;- function(observation.sd = 1, trend.sd = .1,
                             time.dimension = 100, nobs.per.period = 3,
                             xdim = 4) {
  trend &lt;- cumsum(rnorm(time.dimension, 0, trend.sd))
  total.sample.size &lt;- nobs.per.period * time.dimension
  predictors &lt;- matrix(rnorm(total.sample.size * xdim),
    nrow = total.sample.size)
  coefficients &lt;- rnorm(xdim)
  expanded.trend &lt;- rep(trend, each = nobs.per.period)
  response &lt;- expanded.trend + predictors %*% coefficients + rnorm(
    total.sample.size, 0, observation.sd)
  timestamps &lt;- seq.Date(from = as.Date("2008-01-01"),
                         len = time.dimension, by = "day")
  extended.timestamps &lt;- rep(timestamps, each = nobs.per.period)
  return(list(response = response,
    predictors = predictors,
    timestamps = extended.timestamps,
    trend = trend,
    coefficients = coefficients))
}


data &lt;- SimulateDirmData(time.dimension = 20)
ss &lt;- AddLocalLevel(list(), data$response)

# In real life you'd want more than 50 MCMC iterations.
model &lt;- dirm(data$response ~ data$predictors, ss, niter = 50,
  timestamps = data$timestamps)


</code></pre>

<hr>
<h2 id='dirm-model-optoins'>Specify Options for a Dynamic Intercept Regression Model</h2><span id='topic+DirmModelOptions'></span>

<h3>Description</h3>

<p>Specify modeling options for a dynamic intercept regression model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DirmModelOptions(timeout.seconds = Inf,
                 high.dimensional.threshold.factor = 1.0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dirm-model-optoins_+3A_timeout.seconds">timeout.seconds</code></td>
<td>
<p>The overall time budget for model fitting.  If
the MCMC algorithm takes longer than this number, the current
iteration will complete, and then the fitting algorithm will return
with however many MCMC iterations were managed during the allotted
time. </p>
</td></tr>
<tr><td><code id="dirm-model-optoins_+3A_high.dimensional.threshold.factor">high.dimensional.threshold.factor</code></td>
<td>
<p> When doing Kalman filter
updates for the model, Sherman-Morrisson-Woodbury style updates are
applied for high dimensional data, while direct linear algebra is
used for low dimensional data.  The definition of &quot;high dimensional&quot;
is relative to the dimension of the state.  An observation is
considered high dimensional if its dimension exceeds the state
dimension times this factor.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>DirmModelOptions</code>, which is simply a list
containing values of the function arguments.
</p>
<p>The value of using this function instead of making a list &quot;by hand&quot; is
that argument types are properly checked, and list names are sure to
be correct.
</p>

<hr>
<h2 id='estimate.time.scale'>Intervals between dates</h2><span id='topic+EstimateTimeScale'></span>

<h3>Description</h3>

<p>Estimate the time scale used in time series data.</p>


<h3>Usage</h3>

<pre><code class='language-R'>EstimateTimeScale(dates)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estimate.time.scale_+3A_dates">dates</code></td>
<td>
<p>A sorted vector of class <code><a href="base.html#topic+Date">Date</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character string.  Either &quot;daily&quot;, &quot;weekly&quot;, &quot;yearly&quot;,
&quot;monthly&quot;, &quot;quarterly&quot;, or &quot;other&quot;.  The value is determined based on
counting the number of days between successive observations in <code>dates</code>.</p>


<h3>Author(s)</h3>

<p>Steven L. Scott <a href="mailto:steve.the.bayesian@gmail.com">steve.the.bayesian@gmail.com</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>weekly.data &lt;- as.Date(c("2011-10-01",
                         "2011-10-08",
                         "2011-10-15",
                         "2011-10-22",
                         "2011-10-29",
                         "2011-11-05"))

EstimateTimeScale(weekly.data) # "weekly"

almost.weekly.data &lt;- as.Date(c("2011-10-01",
                                "2011-10-08",
                                "2011-10-15",
                                "2011-10-22",
                                "2011-10-29",
                                "2011-11-06"))  # last day is one later

EstimateTimeScale(weekly.data) # "other"
</code></pre>

<hr>
<h2 id='extend.time'>
Extends a vector of dates to a given length
</h2><span id='topic+ExtendTime'></span>

<h3>Description</h3>

<p>Pads a vector of dates to a specified length.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>   ExtendTime(dates, number.of.periods, dt = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extend.time_+3A_dates">dates</code></td>
<td>
<p>An ordered vector of class <code><a href="base.html#topic+Date">Date</a></code>.</p>
</td></tr>
<tr><td><code id="extend.time_+3A_number.of.periods">number.of.periods</code></td>
<td>
<p>The desired length of the output.</p>
</td></tr>
<tr><td><code id="extend.time_+3A_dt">dt</code></td>
<td>
<p>A character string describing the frequency of the dates in
<code>dates</code>.  Possible values are &quot;daily&quot;, &quot;weekly&quot;, &quot;monthly&quot;,
&quot;quarterly&quot;, &quot;yearly&quot;, or &quot;other&quot;.  An attempt to deduce <code>dt</code>
will be made if it is missing.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>number.of.periods</code> is longer than <code>length(dates)</code>, then
<code>dates</code> will be padded to the desired length.  Extra dates are
added at time intervals matching the average interval in
<code>dates</code>.  Thus they may not be
</p>


<h3>Author(s)</h3>

<p>Steven L. Scott <a href="mailto:steve.the.bayesian@gmail.com">steve.the.bayesian@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bsts.mixed">bsts.mixed</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  origin.month &lt;- as.Date("2011-09-01")
  week.ending &lt;- as.Date(c("2011-10-01",   ## 1
                           "2011-10-08",   ## 2
                           "2011-12-03",   ## 3
                           "2011-12-31"))  ## 4
  MatchWeekToMonth(week.ending, origin.month) == 1:4
</code></pre>

<hr>
<h2 id='format.timestamps'>Checking for Regularity</h2><span id='topic+NoDuplicates'></span><span id='topic+NoGaps'></span><span id='topic+IsRegular'></span><span id='topic+HasDuplicateTimestamps'></span>

<h3>Description</h3>

<p>Tools for checking if a series of timestamps is 'regular' meaning that
it has no duplicates, and no gaps.  Checking for regularity can be
tricky.  For example, if you have monthly observations with
<code><a href="base.html#topic+Date">Date</a></code> or <code><a href="base.html#topic+POSIXt">POSIXt</a></code> timestamps then gaps
between timestamps can be 28, 29, 30, or 31 days, but the series is
still &quot;regular&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  NoDuplicates(timestamps)
  NoGaps(timestamps)
  IsRegular(timestamps)

  HasDuplicateTimestamps(bsts.object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="format.timestamps_+3A_timestamps">timestamps</code></td>
<td>
<p>A set of (possibly irregular or non-unique)
timestamps.  This could be a set of integers (like 1, 2, , 3...), a
set of numeric like (1945, 1945.083, 1945.167, ...) indicating years
and fractions of years, a <code><a href="base.html#topic+Date">Date</a></code> object, or a
<code><a href="base.html#topic+POSIXt">POSIXt</a></code> object.</p>
</td></tr>
<tr><td><code id="format.timestamps_+3A_bsts.object">bsts.object</code></td>
<td>
<p>A bsts model object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>All four functions return scalar logical values.  <code>NoDuplicates</code>
returns <code>TRUE</code> if all elements of <code>timestamps</code> are unique.
</p>
<p><code>NoGaps</code> examines the smallest nonzero gap between time points.
As long as no gaps between time points are more than twice as wide as
the smallest gap, it returns <code>TRUE</code>, indicating that there are no
missing timestamps.  Otherwise it returns <code>FALSE</code>.
</p>
<p><code>IsRegular</code> returns <code>TRUE</code> if <code>NoDuplicates</code> and
<code>NoGaps</code> both return <code>TRUE</code>.
</p>
<p><code>HasDuplicateTimestamps</code> returns <code>FALSE</code> if the data used to
fit bsts.model either has NULL timestamps, or if the timestamps
contain no duplicate values.
</p>


<h3>Author(s)</h3>

<p>Steven L. Scott <a href="mailto:steve.the.bayesian@gmail.com">steve.the.bayesian@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  first &lt;- as.POSIXct("2015-04-19 08:00:04")
  monthly &lt;- seq(from = first, length.out = 24, by = "month")
  IsRegular(monthly) ## TRUE

  skip.one &lt;- monthly[-8]
  IsRegular(skip.one) ## FALSE

  has.duplicates &lt;- monthly
  has.duplicates[1] &lt;- has.duplicates[2]
  IsRegular(has.duplicates) ## FALSE
</code></pre>

<hr>
<h2 id='gdp'>Gross Domestic Product for 57 Countries</h2><span id='topic+gdp'></span>

<h3>Description</h3>

<p>Annual gross domestic product for 57 countries, as produced
by the OECD.  
</p>
<p>Fields:
</p>

<ul>
<li><p>LOCATION: Three letter country code.
</p>
</li>
<li><p>MEASURE: MLN_USD signifies a total GDP number in millions of
US dollars.  USD_CAP is per capita GDP in US dollars.
</p>
</li>
<li><p>TIME: The year of the measurement.
</p>
</li>
<li><p>Value: The measured value.
</p>
</li>
<li><p>Flag.Codes: P for provisional data, B for a break in the
series, and E for an estimated value.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>data(gdp)
</code></pre>


<h3>Format</h3>

<p>data frame</p>


<h3>Source</h3>

<p>OECD website: See
https://data.oecd.org/gdp/gross-domestic-product-gdp.htm</p>

<hr>
<h2 id='geometric.sequence'>
Create a Geometric Sequence
</h2><span id='topic+GeometricSequence'></span>

<h3>Description</h3>

<p> Create a geometric sequence.</p>


<h3>Usage</h3>

<pre><code class='language-R'>  GeometricSequence(length, initial.value = 1, discount.factor = .5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geometric.sequence_+3A_length">length</code></td>
<td>
<p>A positive integer giving the length of the desired sequence.</p>
</td></tr>
<tr><td><code id="geometric.sequence_+3A_initial.value">initial.value</code></td>
<td>
<p>The first term in the sequence.  Cannot be zero.</p>
</td></tr>
<tr><td><code id="geometric.sequence_+3A_discount.factor">discount.factor</code></td>
<td>
<p>The ratio between a sequence term and the
preceding term.  Cannot be zero.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector containing the desired sequence.
</p>


<h3>Author(s)</h3>

<p>Steven L. Scott <a href="mailto:steve.the.bayesian@gmail.com">steve.the.bayesian@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>GeometricSequence(4, .8, .6)
# [1] 0.8000 0.4800 0.2880 0.1728

GeometricSequence(5, 2, 3)
# [1]   2   6  18  54 162

## Not run: 
GeometricSequence(0, -1, -2)
# Error: length &gt; 0 is not TRUE

## End(Not run)
</code></pre>

<hr>
<h2 id='get.fraction'>
Compute membership fractions
</h2><span id='topic+GetFractionOfDaysInInitialMonth'></span><span id='topic+GetFractionOfDaysInInitialQuarter'></span>

<h3>Description</h3>

<p>Returns the fraction of days in a week that occur in the ear
</p>


<h3>Usage</h3>

<pre><code class='language-R'>   GetFractionOfDaysInInitialMonth(week.ending)
   GetFractionOfDaysInInitialQuarter(week.ending)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.fraction_+3A_week.ending">week.ending</code></td>
<td>
<p>A vector of class <code><a href="base.html#topic+Date">Date</a></code>.  Each entry contains the
date of the last day in a week.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a numeric vector of the same length as <code>week.ending</code>.
Each entry gives the fraction of days in the week that occur in the
coarse time interval (month or quarter) containing the start of the
week (i.e the date 6 days before).
</p>


<h3>Author(s)</h3>

<p>Steven L. Scott <a href="mailto:steve.the.bayesian@gmail.com">steve.the.bayesian@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bsts.mixed">bsts.mixed</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    dates &lt;- as.Date(c("2003-03-31",
                       "2003-04-01",
                       "2003-04-02",
                       "2003-04-03",
                       "2003-04-04",
                       "2003-04-05",
                       "2003-04-06",
                       "2003-04-07"))
    fraction &lt;- GetFractionOfDaysInInitialMonth(dates)
    fraction == c(1, 6/7, 5/7, 4/7, 3/7, 2/7, 1/7, 1)
</code></pre>

<hr>
<h2 id='goog'>Google stock price</h2><span id='topic+goog'></span><span id='topic+GOOG'></span>

<h3>Description</h3>

<p>Daily closing price of Google stock.</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(goog)</code></pre>


<h3>Format</h3>

<p>xts time series</p>


<h3>Source</h3>

<p>The Internets</p>

<hr>
<h2 id='HarveyCumulator'>HarveyCumulator</h2><span id='topic+HarveyCumulator'></span>

<h3>Description</h3>

<p> Given a state space model on a fine scale, the Harvey
cumulator aggregates the model to a coarser scale (e.g. from days to
weeks, or weeks to months).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>HarveyCumulator(fine.series,
                contains.end,
                membership.fraction)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="HarveyCumulator_+3A_fine.series">fine.series</code></td>
<td>
<p>The fine-scale time series to be aggregated.</p>
</td></tr>
<tr><td><code id="HarveyCumulator_+3A_contains.end">contains.end</code></td>
<td>
<p>A logical vector, with length matching
<code>fine.series</code> indicating whether each fine scale time interval
contains the end of a coarse time interval.  For example, months
don't contain a fixed number of weeks, so when cumulating a weekly
time series into a monthly series, you need to know which weeks
contain the end of a month.</p>
</td></tr>
<tr><td><code id="HarveyCumulator_+3A_membership.fraction">membership.fraction</code></td>
<td>
<p>The fraction of each fine-scale time
observation belonging to the coarse scale time observation at the
beginning of the time interval.  For example, if week i started in
March and ended in April, <code>membership.fraction[i]</code> is the
fraction of fine.series[i] that should be attributed to March.  This
should be 1 for most observations.</p>
</td></tr>
</table>


<h3>Value</h3>

<p> Returns a vector containing the course scale partial aggregates
of <code>fine.series</code>.  </p>


<h3>Author(s)</h3>

<p>Steven L. Scott <a href="mailto:steve.the.bayesian@gmail.com">steve.the.bayesian@gmail.com</a>
</p>


<h3>References</h3>

<p>Harvey (1990), &quot;Forecasting, structural time series, and the Kalman
filter&quot;, Cambridge University Press.
</p>
<p>Durbin and Koopman (2001), &quot;Time series analysis by state space
methods&quot;, Oxford University Press.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bsts.mixed">bsts.mixed</a></code>,
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(goog)
days &lt;- factor(weekdays(index(goog)),
               levels = c("Monday", "Tuesday", "Wednesday",
                          "Thursday", "Friday"),
               ordered = TRUE)

## Because of holidays, etc the days do not always go in sequence.
## (Sorry, Rebecca Black! https://www.youtube.com/watch?v=kfVsfOSbJY0)
## diff.days[i] is the number of days between days[i-1] and days[i].
## We know that days[i] is the end of a week if diff.days[i] &lt; 0.
diff.days &lt;- tail(as.numeric(days), -1) - head(as.numeric(days), -1)
contains.end &lt;- c(FALSE, diff.days &lt; 0)

goog.weekly &lt;- HarveyCumulator(goog, contains.end, 1)


</code></pre>

<hr>
<h2 id='holiday'>
Specifying Holidays
</h2><span id='topic+Holiday'></span><span id='topic+holiday'></span><span id='topic+NamedHoliday'></span><span id='topic+FixedDateHoliday'></span><span id='topic+NthWeekdayInMonthHoliday'></span><span id='topic+LastWeekdayInMonthHoliday'></span><span id='topic+DateRangeHoliday'></span>

<h3>Description</h3>

<p>Specify holidays for use with holiday state models.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
FixedDateHoliday(holiday.name,
                 month = base::month.name,
                 day,
                 days.before = 1,
                 days.after = 1)

NthWeekdayInMonthHoliday(holiday.name,
                         month = base::month.name,
                         day.of.week = weekday.names,
                         week.number = 1,
                         days.before = 1,
                         days.after = 1)

LastWeekdayInMonthHoliday(holiday.name,
                          month = base::month.name,
                          day.of.week = weekday.names,
                          days.before = 1,
                          days.after = 1)

NamedHoliday(holiday.name = named.holidays,
             days.before = 1,
             days.after = 1)

DateRangeHoliday(holiday.name,
                 start.date,
                 end.date)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="holiday_+3A_holiday.name">holiday.name</code></td>
<td>
<p>A string that can be used to label the holiday in
output.</p>
</td></tr>
<tr><td><code id="holiday_+3A_month">month</code></td>
<td>
<p>A string naming the month in which the holiday occurs.
Unambiguous partial matches are acceptable.  Capitalize the first
letter.</p>
</td></tr>
<tr><td><code id="holiday_+3A_day">day</code></td>
<td>
<p>An integer specifying the day of the month on which the
<code>FixedDateHoliday</code> occurs.</p>
</td></tr>
<tr><td><code id="holiday_+3A_day.of.week">day.of.week</code></td>
<td>
<p>A string giving the day of the week on which the
holiday occurs.</p>
</td></tr>
<tr><td><code id="holiday_+3A_week.number">week.number</code></td>
<td>
<p>An integer specifying the week of the month on
which the <code>NthWeekdayInMonthHoliday</code> occurs.</p>
</td></tr>
<tr><td><code id="holiday_+3A_days.before">days.before</code></td>
<td>
<p>An integer giving the number of days of influence
that the holiday exerts prior to the actual holiday.</p>
</td></tr>
<tr><td><code id="holiday_+3A_days.after">days.after</code></td>
<td>
<p>An integer giving the number of days of influence
that holiday exerts after the actual holiday.</p>
</td></tr>
<tr><td><code id="holiday_+3A_named.holidays">named.holidays</code></td>
<td>
<p>A character vector containing one or more
recognized holiday names.</p>
</td></tr>
<tr><td><code id="holiday_+3A_start.date">start.date</code></td>
<td>
<p>A vector of starting dates for the holiday.  Each
instance of the holiday in the training data or the forecast period
must be represented by an element in this vector.  Thus if this is
an annual holiday and, there are 10 years of training data, and a
1-year forecast is needed, then this will be a vector of length 11.
</p>
</td></tr>
<tr><td><code id="holiday_+3A_end.date">end.date</code></td>
<td>
<p>A vector of ending dates for the holiday.  Each date
must occur on or after the corresponding element of
<code>start.date</code>, and <code>end.date[i]</code> must come before
<code>start.date[i+1]</code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p> Each function returns a list containing the information from the
function arguments, formatted as expected by the underlying C++ code.
State models that focus on holidays, such as
<code><a href="#topic+AddRandomWalkHoliday">AddRandomWalkHoliday</a></code>,
<code><a href="#topic+AddRegressionHoliday">AddRegressionHoliday</a></code>, and
<code><a href="#topic+AddHierarchicalRegressionHoliday">AddHierarchicalRegressionHoliday</a></code>, will expect one or
more holiday objects as arguments.
</p>

<ul>
<li><p><code>FixedDateHoliday</code> describes a holiday that occurs on the
same date each year, like US independence day (July 4).
</p>
</li>
<li><p><code>NthWeekdayInMonthHoliday</code> describes a holiday that
occurs a particular weekday of a particular week of a particular
month.  For example, US Labor Day is the first Monday in
September.
</p>
</li>
<li><p><code>LastWeekdayInMonthHoliday</code> describes a holiday that
occurs on the last instance of a particular weekday in a
particular month.  For example, US Memorial Day is the last Monday
in May.
</p>
</li>
<li><p><code>DateRangeHoliday</code> describes an irregular holiday that
might not follow a particular pattern.  You can handle this type
of holiday by manually specifying a range of dates for each
instance of the holiday in your data set.  NOTE: If you plan on
using the model to forecast, be sure to include date ranges in the
forecast period as well as the period covered by the training
data.  
</p>
</li>
<li><p><code>NamedHoliday</code> is a convenience class for describing
several important holidays in the US.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Steven L. Scott <a href="mailto:steve.the.bayesian@gmail.com">steve.the.bayesian@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+AddRandomWalkHoliday">AddRandomWalkHoliday</a></code>,
<code><a href="#topic+AddRegressionHoliday">AddRegressionHoliday</a></code>,
<code><a href="#topic+AddHierarchicalRegressionHoliday">AddHierarchicalRegressionHoliday</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
july4 &lt;- FixedDateHoliday("July4", "July", 4)
memorial.day &lt;- LastWeekdayInMonthHoliday("MemorialDay", "May", "Monday")
labor.day &lt;- NthWeekdayInMonthHoliday("LaborDay", "September", "Monday", 1)
another.way.to.get.memorial.day &lt;- NamedHoliday("MemorialDay")
easter &lt;- NamedHoliday("Easter")
winter.olympics &lt;- DateRangeHoliday("WinterOlympicsSince2000",
                     start = as.Date(c("2002-02-08",
                                        "2006-02-10",
                                        "2010-02-12",
                                        "2014-02-07",
                                        "2018-02-07")),
                     end = as.Date(c("2002-02-24",
                                     "2006-02-26",
                                     "2010-02-28",
                                     "2014-02-23",
                                     "2018-02-25")))

</code></pre>

<hr>
<h2 id='iclaims'>Initial Claims Data</h2><span id='topic+initial.claims'></span><span id='topic+iclaims'></span>

<h3>Description</h3>

<p>A weekly time series of US initial claims for unemployment.
The first column contains the initial claims numbers from FRED.  The
others contain a measure of the relative popularity of various search
queries identified by Google Correlate.</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(iclaims)
</code></pre>


<h3>Format</h3>

<p>zoo time series</p>


<h3>Source</h3>

<p>FRED.              http://research.stlouisfed.org/fred2/series/ICNSA,<br />
Google correlate.  http://www.google.com/trends/correlate</p>


<h3>See Also</h3>

<p><code><a href="#topic+bsts">bsts</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(iclaims)
plot(initial.claims)
</code></pre>

<hr>
<h2 id='last.day.in.month'>Find the last day in a month</h2><span id='topic+LastDayInMonth'></span>

<h3>Description</h3>

<p>Finds the last day in the month containing a specefied date.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>   LastDayInMonth(dates)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="last.day.in.month_+3A_dates">dates</code></td>
<td>
<p>A vector of class <code><a href="base.html#topic+Date">Date</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of class <code><a href="base.html#topic+Date">Date</a></code> where each entry is the last day
in the month containing the corresponding entry in <code>dates</code>.
</p>


<h3>Author(s)</h3>

<p>Steven L. Scott <a href="mailto:steve.the.bayesian@gmail.com">steve.the.bayesian@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> inputs &lt;- as.Date(c("2007-01-01",
                     "2007-01-31",
                     "2008-02-01",
                     "2008-02-29",
                     "2008-03-14",
                     "2008-12-01",
                     "2008-12-31"))
 expected.outputs &lt;- as.Date(c("2007-01-31",
                              "2007-01-31",
                              "2008-02-29",
                              "2008-02-29",
                              "2008-03-31",
                              "2008-12-31",
                              "2008-12-31"))
 LastDayInMonth(inputs) == expected.outputs
</code></pre>

<hr>
<h2 id='MATCH.NumericTimestamps'>Match Numeric Timestamps</h2><span id='topic+MATCH.NumericTimestamps'></span>

<h3>Description</h3>

<p>S3 generic method for MATCH function supplied in the zoo package.</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'NumericTimestamps'
MATCH(x, table, nomatch = NA, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MATCH.NumericTimestamps_+3A_x">x</code></td>
<td>
<p>A numeric set of timestamps.</p>
</td></tr>
<tr><td><code id="MATCH.NumericTimestamps_+3A_table">table</code></td>
<td>
<p>A set of regular numeric timestamps to match against. </p>
</td></tr>
<tr><td><code id="MATCH.NumericTimestamps_+3A_nomatch">nomatch</code></td>
<td>
<p>The value to be returned in the case when no match is found.
Note that it is coerced to integer.</p>
</td></tr>
<tr><td><code id="MATCH.NumericTimestamps_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code><a href="base.html#topic+match">match</a></code>. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Numeric timestamps match if they agree to 8 significant digits.
</p>


<h3>Value</h3>

<p>Returns the index of the entry in <code>table</code> matched by each
argument in <code>x</code>.  If an entry has no match then <code>nomatch</code> is
returned at that position.
</p>


<h3>See Also</h3>

<p><code><a href="zoo.html#topic+MATCH">MATCH</a></code>
</p>

<hr>
<h2 id='match.week.to.month'>
Find the month containing a week
</h2><span id='topic+MatchWeekToMonth'></span>

<h3>Description</h3>

<p>Returns the index of a month, in a sequence of months, that contains a
given week.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>   MatchWeekToMonth(week.ending, origin.month)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="match.week.to.month_+3A_week.ending">week.ending</code></td>
<td>
<p>A vector of class <code><a href="base.html#topic+Date">Date</a></code>.  Each entry contains the
date of the last day in a week.</p>
</td></tr>
<tr><td><code id="match.week.to.month_+3A_origin.month">origin.month</code></td>
<td>
<p>A <code><a href="base.html#topic+Date">Date</a></code>, giving any day in the month
to use as the origin of the sequence (month 1).</p>
</td></tr>
</table>


<h3>Value</h3>

<p> The index of the month matching the month containing the first
day in <code>week.ending</code>.  The origin is month 1.  It is the caller's
responsibility to ensure that these indices correspond to legal values
in a particular vector of months.  </p>


<h3>Author(s)</h3>

<p>Steven L. Scott <a href="mailto:steve.the.bayesian@gmail.com">steve.the.bayesian@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bsts.mixed">bsts.mixed</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  origin.month &lt;- as.Date("2011-09-01")
  week.ending &lt;- as.Date(c("2011-10-01",   ## 1
                           "2011-10-08",   ## 2
                           "2011-12-03",   ## 3
                           "2011-12-31"))  ## 4
  MatchWeekToMonth(week.ending, origin.month) == 1:4
</code></pre>

<hr>
<h2 id='max.window.width'>Maximum Window Width for a Holiday</h2><span id='topic+MaxWindowWidth'></span><span id='topic+MaxWindowWidth.default'></span><span id='topic+MaxWindowWidth.DateRangeHoliday'></span>

<h3>Description</h3>

<p>The maximum width of a holiday's influence window</p>


<h3>Usage</h3>

<pre><code class='language-R'>## Default S3 method:
MaxWindowWidth(holiday, ...)
## S3 method for class 'DateRangeHoliday'
MaxWindowWidth(holiday, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="max.window.width_+3A_holiday">holiday</code></td>
<td>
<p>An object of class <code><a href="#topic+Holiday">Holiday</a></code>.</p>
</td></tr>
<tr><td><code id="max.window.width_+3A_...">...</code></td>
<td>
<p>Other arguments (not used).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the number of days in a holiday's influence window.
</p>


<h3>Author(s)</h3>

<p>Steven L. Scott <a href="mailto:steve.the.bayesian@gmail.com">steve.the.bayesian@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Holiday">Holiday</a></code>.
<code><a href="#topic+AddRegressionHoliday">AddRegressionHoliday</a></code>.
<code><a href="#topic+AddRandomWalkHoliday">AddRandomWalkHoliday</a></code>.
<code><a href="#topic+AddHierarchicalRegressionHoliday">AddHierarchicalRegressionHoliday</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
easter &lt;- NamedHoliday("Easter", days.before = 2, days.after = 1)
if (MaxWindowWidth(easter) == 4) {
  print("That's the right answer!\n")
}

## This holiday lasts two days longer in 2005 than in 2004.
may18 &lt;- DateRangeHoliday("May18",
     start = as.Date(c("2004-05-17",
                       "2005-05-16")),
     end   = as.Date(c("2004-05-19",
                       "2005-05-20")))

if (MaxWindowWidth(may18) == 5) {
   print("Right again!\n")
}

</code></pre>

<hr>
<h2 id='mbsts'>Multivariate Bayesian Structural Time Series</h2><span id='topic+mbsts'></span>

<h3>Description</h3>

<p>Fit a multivariate Bayesian structural time series model, also known
as a &quot;dynamic factor model.&quot;
</p>
<p>** NOTE ** This code is experimental.  Please feel free to experiment
with it and report any bugs to the maintainer.  Expect it to improve
substantially in the next release.  </p>


<h3>Usage</h3>

<pre><code class='language-R'>mbsts(formula,
      shared.state.specification,
      series.state.specification = NULL,
      data = NULL,
      timestamps = NULL,
      series.id = NULL,
      prior = NULL,  # TODO
      opts = NULL,
      contrasts = NULL,
      na.action = na.pass,
      niter,
      ping = niter / 10,
      data.format = c("long", "wide"),
      seed = NULL,
      ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mbsts_+3A_formula">formula</code></td>
<td>
<p>A formula describing the regression portion of the
relationship between y and X.
</p>
<p>If no regressors are desired then the formula can be replaced by a
numeric matrix giving the multivariate time series to be modeled.
</p>
</td></tr>
<tr><td><code id="mbsts_+3A_shared.state.specification">shared.state.specification</code></td>
<td>
<p>A list with elements created by
<code><a href="#topic+AddSharedLocalLevel">AddSharedLocalLevel</a></code>, and similar functions for adding
components of state.
</p>
<p>This list defines the components of state which are shared across
all time series.  These are the &quot;factors&quot; in the dynamic factor
model.
</p>
</td></tr>
<tr><td><code id="mbsts_+3A_series.state.specification">series.state.specification</code></td>
<td>
<p> This argument specifies state
components needed by a particular series.  Not all series need have
the same state components (e.g. some series may require a seasonal
component, while others do not).  It can be <code>NULL</code>, indicating
that there are no series-specific state components.
</p>
<p>It can be a list of elements created by <code><a href="#topic+AddLocalLevel">AddLocalLevel</a></code>,
<code><a href="#topic+AddSeasonal">AddSeasonal</a></code>, and similar functions for adding state
component to scalar bsts models.  In this case the same,
independent, individual components will be added to each series.
For example, each series will get its own independent Seasonal state
component if AddSeasonal was used to add a seasonal component to
this argument.
</p>
<p>In its most general form, this argument can be a list of lists, some
of which can be NULL, but with non-NULL lists specifying state
components for individual series, as above.
</p>
</td></tr>
<tr><td><code id="mbsts_+3A_data">data</code></td>
<td>
<p>An optional data frame, list or environment (or object
coercible by <code><a href="base.html#topic+as.data.frame">as.data.frame</a></code> to a data frame) containing
the variables mentioned in the <code>formula</code> argument.  If not
found in <code>data</code>, the variables are taken from
<code>environment(formula)</code>, typically the environment from which
<code><a href="#topic+bsts">bsts</a></code> is called.</p>
</td></tr>
<tr><td><code id="mbsts_+3A_timestamps">timestamps</code></td>
<td>
<p>A vector of timestamps indicating the time of each
observation.  If <code>data.format</code> is <code>"long"</code> then this
argument is required.  If &quot;wide&quot; data is passed then it is optional.
</p>
<p>TODO:  TEST THIS under wide and long formats in regression and
non-regression settings.
</p>
</td></tr>
<tr><td><code id="mbsts_+3A_series.id">series.id</code></td>
<td>
<p>A factor (or object coercible to factor) indicating
the series to which each observation in &quot;long&quot; format belongs.  This
argument is ignored for data in &quot;wide&quot; format.  </p>
</td></tr>
<tr><td><code id="mbsts_+3A_prior">prior</code></td>
<td>
<p>A list of <code><a href="BoomSpikeSlab.html#topic+SpikeSlabPrior">SpikeSlabPrior</a></code> objects, one for
each time series.  Or this argument can be NULL in which case a
default prior will be used.  Note that the prior is on both the
regression coefficients and the residual sd for each time series. </p>
</td></tr>
<tr><td><code id="mbsts_+3A_opts">opts</code></td>
<td>
<p>A list containing model options.  This is currently only
used for debugging, so leave this as <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="mbsts_+3A_contrasts">contrasts</code></td>
<td>
<p>An optional list containing the names of contrast
functions to use when converting factors numeric variables in a
regression formula.  This argument works exactly as it does in
<code><a href="stats.html#topic+lm">lm</a></code>.  The names of the list elements correspond to
factor variables in your model formula.  The list elements
themselves are the names of contrast functions (see
<code>help(<a href="stats.html#topic+contr.treatment">contr.treatment</a>)</code> and the
<code>contrasts.arg</code> argument to
<code><a href="stats.html#topic+model.matrix.default">model.matrix.default</a></code>).  This argument is only used if
a model formula is specified, and even then the default is probably
what you want.</p>
</td></tr>
<tr><td><code id="mbsts_+3A_na.action">na.action</code></td>
<td>
<p>What to do about missing values.  The default is to
allow missing responses, but no missing predictors.  Set this to
na.omit or na.exclude if you want to omit missing responses
altogether.</p>
</td></tr>
<tr><td><code id="mbsts_+3A_niter">niter</code></td>
<td>
<p>A positive integer giving the desired number of MCMC
draws.</p>
</td></tr>
<tr><td><code id="mbsts_+3A_ping">ping</code></td>
<td>
<p> A scalar giving the desired frequency of status messages.
If ping &gt; 0 then the program will print a status message to the
screen every <code>ping</code> MCMC iterations.</p>
</td></tr>
<tr><td><code id="mbsts_+3A_data.format">data.format</code></td>
<td>
<p>Whether the data are store in wide (each row is a
time point, and columns are values from different series) or long
(each row is the value of a particular series at a particular point
in time) format.  For <code>"long"</code> see <code>timestamps</code> and
<code>series.id</code>.
</p>
</td></tr>
<tr><td><code id="mbsts_+3A_seed">seed</code></td>
<td>
<p>An integer to use as the random seed for the underlying
C++ code.  If <code>NULL</code> then the seed will be set using the
clock.</p>
</td></tr>
<tr><td><code id="mbsts_+3A_...">...</code></td>
<td>
<p> Extra arguments to be passed to
<code><a href="BoomSpikeSlab.html#topic+SpikeSlabPrior">SpikeSlabPrior</a></code> (see the
entry for the <code>prior</code> argument, above).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code><a href="#topic+mbsts">mbsts</a></code> which is a list with the
following components
</p>
<table>
<tr><td><code>coefficients</code></td>
<td>
<p> A <code>niter</code> by <code>ncol(X)</code> matrix of MCMC
draws of the regression coefficients, where <code>X</code> is the design
matrix implied by <code>formula</code>.  This is only present if a model
formula was supplied.</p>
</td></tr>
<tr><td><code>sigma.obs</code></td>
<td>
<p>A vector of length <code>niter</code> containing MCMC draws
of the residual standard deviation.</p>
</td></tr>
</table>
<p>The returned object will also contain named elements holding the MCMC
draws of model parameters belonging to the state models.  The names of
each component are supplied by the entries in
<code>state.specification</code>.  If a model parameter is a scalar, then
the list element is a vector with <code>niter</code> elements.  If the
parameter is a vector then the list element is a matrix with
<code>niter</code> rows.  If the parameter is a matrix then the list element
is a 3-way array with first dimension <code>niter</code>.
</p>
<p>Finally, if a model formula was supplied, then the returned object
will contain the information necessary for the predict method to build
the design matrix when a new prediction is made.
</p>


<h3>Author(s)</h3>

<p>Steven L. Scott  <a href="mailto:steve.the.bayesian@gmail.com">steve.the.bayesian@gmail.com</a>
</p>


<h3>References</h3>

<p>Harvey (1990), &quot;Forecasting, structural time series, and the Kalman
filter&quot;, Cambridge University Press.
</p>
<p>Durbin and Koopman (2001), &quot;Time series analysis by state space
methods&quot;, Oxford University Press.
</p>
<p>George and McCulloch (1997)
&quot;Approaches for Bayesian variable selection&quot;, Statistica Sinica pp
339&ndash;374.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bsts">bsts</a></code>,
<code><a href="#topic+AddLocalLevel">AddLocalLevel</a></code>,
<code><a href="#topic+AddLocalLinearTrend">AddLocalLinearTrend</a></code>,
<code><a href="#topic+AddSemilocalLinearTrend">AddSemilocalLinearTrend</a></code>,
<code><a href="#topic+AddSeasonal">AddSeasonal</a></code>
<code><a href="#topic+AddDynamicRegression">AddDynamicRegression</a></code>
<code><a href="BoomSpikeSlab.html#topic+SpikeSlabPrior">SpikeSlabPrior</a></code>,
<code><a href="Boom.html#topic+SdPrior">SdPrior</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

# This example takes 12s on Windows, which is longer than CRAN's 10s
# limit.  Marking code as 'dontrun' to prevent CRAN auto checks from
# timing out.

seed &lt;- 8675309
set.seed(seed)

ntimes &lt;- 250
nseries &lt;- 20
nfactors &lt;- 6
residual.sd &lt;- 1.2
state.innovation.sd &lt;- .75

##---------------------------------------------------------------------------
## simulate latent state for fake data.
##---------------------------------------------------------------------------
state &lt;- matrix(rnorm(ntimes * nfactors, 0, state.innovation.sd), nrow = ntimes)
for (i in 1:ncol(state)) {
  state[, i] &lt;- cumsum(state[, i])
}

##---------------------------------------------------------------------------
## Simulate "observed" data from state.
##---------------------------------------------------------------------------
observation.coefficients &lt;- matrix(rnorm(nseries * nfactors), nrow = nseries)
diag(observation.coefficients) &lt;- 1.0
observation.coefficients[upper.tri(observation.coefficients)] &lt;- 0

errors &lt;- matrix(rnorm(nseries * ntimes, 0, residual.sd), ncol = ntimes)
y &lt;- t(observation.coefficients %*% t(state) + errors)

##---------------------------------------------------------------------------
## Plot the data.
##---------------------------------------------------------------------------
par(mfrow=c(1,2))
plot.ts(y, plot.type="single", col = rainbow(nseries), main = "observed data")
plot.ts(state, plot.type = "single", col = 1:nfactors, main = "latent state")

##---------------------------------------------------------------------------
## Fit the model
##---------------------------------------------------------------------------
ss &lt;- AddSharedLocalLevel(list(), y, nfactors = nfactors)

opts &lt;- list("fixed.state" = t(state),
  fixed.residual.sd = rep(residual.sd, nseries),
  fixed.regression.coefficients = matrix(rep(0, nseries), ncol = 1))

model &lt;- mbsts(y, shared.state.specification = ss, niter = 100,
  data.format = "wide", seed = seed)

##---------------------------------------------------------------------------
## Plot the state
##---------------------------------------------------------------------------
par(mfrow=c(1, nfactors))
ylim &lt;- range(model$shared.state, state)
for (j in 1:nfactors) {
  PlotDynamicDistribution(model$shared.state[, j, ], ylim=ylim)
  lines(state[, j], col = "blue")
}

##---------------------------------------------------------------------------
## Plot the factor loadings.
##---------------------------------------------------------------------------
opar &lt;- par(mfrow=c(nfactors,1), mar=c(0, 4, 0, 4), omi=rep(.25, 4))
burn &lt;- 10
for(j in 1:nfactors) {
  BoxplotTrue(model$shared.local.level.coefficients[-(1:burn), j, ],
    t(observation.coefficients)[, j], axes=F, truth.color="blue")
  abline(h=0, lty=3)
  box()
  axis(2)
}
axis(1)
par(opar)

##---------------------------------------------------------------------------
## Plot the predicted values of the series.
##---------------------------------------------------------------------------
index &lt;- 1:12
nr &lt;- floor(sqrt(length(index)))
nc &lt;- ceiling(length(index) / nr)
opar &lt;- par(mfrow = c(nr, nc), mar = c(2, 4, 1, 2))
for (i in index) {
  PlotDynamicDistribution(
    model$shared.state.contributions[, 1, i, ]
    + model$regression.coefficients[, i, 1]
  , ylim=range(y))
  points(y[, i], col="blue", pch = ".", cex = .2)
}
par(opar)
# next line closes 'dontrun'

## End(Not run)
# next line closes 'examples'
</code></pre>

<hr>
<h2 id='mixed.frequency'>Models for mixed frequency time series</h2><span id='topic+bsts.mixed'></span>

<h3>Description</h3>

<p>Fit a structured time series to mixed frequncy data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>   bsts.mixed(target.series,
              predictors,
              which.coarse.interval,
              membership.fraction,
              contains.end,
              state.specification,
              regression.prior,
              niter,
              ping = niter / 10,
              seed = NULL,
              truth = NULL,
              ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mixed.frequency_+3A_target.series">target.series</code></td>
<td>
<p>A vector object of class <code><a href="zoo.html#topic+zoo">zoo</a></code>
indexed by calendar dates.  The date associated with each element is
the LAST DAY in the time interval measured by the corresponding value.
The value is what Harvey (1989) calls a 'flow' variable.  It is a
number that can be viewed as an accumulation over the measured time
interval.  </p>
</td></tr>
<tr><td><code id="mixed.frequency_+3A_predictors">predictors</code></td>
<td>
<p> A matrix of class <code><a href="zoo.html#topic+zoo">zoo</a></code> indexed by
calendar dates.  The date associated with each row is the LAST DAY
in the time interval encompasing the measurement.  The dates are
expected to be at a finer scale than the dates in
<code>target.series</code>.  Any predictors should be at sufficient lags
to be able to predict the rest of the cycle.</p>
</td></tr>
<tr><td><code id="mixed.frequency_+3A_which.coarse.interval">which.coarse.interval</code></td>
<td>
<p>A numeric vector of length
<code>nrow(predictors)</code> giving the index of the coarse interval
corresponding to the end of each fine interval.</p>
</td></tr>
<tr><td><code id="mixed.frequency_+3A_membership.fraction">membership.fraction</code></td>
<td>
<p>A numeric vector of length
<code>nrow(predictors)</code> giving the fraction of activity attributed
to the coarse interval corresponding to the beginning of each fine
interval.  This is always positive, and will be 1 except when a fine
interval spans the boundary between two coarse intervals.</p>
</td></tr>
<tr><td><code id="mixed.frequency_+3A_contains.end">contains.end</code></td>
<td>
<p>A logical vector of length <code>nrow(predictors)</code>
indicating whether each fine interval contains the end of a coarse
interval.</p>
</td></tr>
<tr><td><code id="mixed.frequency_+3A_state.specification">state.specification</code></td>
<td>
<p>A state specification like that required
by <code>bsts</code>.</p>
</td></tr>
<tr><td><code id="mixed.frequency_+3A_regression.prior">regression.prior</code></td>
<td>
<p>A prior distribution created by
<code><a href="BoomSpikeSlab.html#topic+SpikeSlabPrior">SpikeSlabPrior</a></code>.  A default prior will be generated
if none is specified.</p>
</td></tr>
<tr><td><code id="mixed.frequency_+3A_niter">niter</code></td>
<td>
<p>The desired number of MCMC iterations.</p>
</td></tr>
<tr><td><code id="mixed.frequency_+3A_ping">ping</code></td>
<td>
<p>An integer indicating the frequency with which progress
reports get printed.  E.g. setting <code>ping = 100</code> will print a
status message with a time and iteration stamp every 100 iterations.
If you don't want these messages set <code>ping &lt; 0</code>.</p>
</td></tr>
<tr><td><code id="mixed.frequency_+3A_seed">seed</code></td>
<td>
<p>An integer to use as the random seed for the underlying
C++ code.  If <code>NULL</code> then the seed will be set using the
clock.</p>
</td></tr>
<tr><td><code id="mixed.frequency_+3A_truth">truth</code></td>
<td>
<p>For debugging purposes only.  A list containing one or
more of the following elements.  If any are present then
corresponding values will be held fixed in the MCMC algorithm.
</p>

<ul>
<li><p> A matrix named <code>state</code> containing the state of the
coarse model from a fake-data simulation.
</p>
</li>
<li><p> A vector named <code>beta</code> of regression coefficients.
</p>
</li>
<li><p> A scalar named <code>sigma.obs</code>.
</p>
</li></ul>

</td></tr>
<tr><td><code id="mixed.frequency_+3A_...">...</code></td>
<td>
<p>Extra arguments passed to SpikeSlabPrior</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>bsts.mixed</code>, which is a list with the
following elements.  Many of these are arrays, in which case the first
index of the array corresponds to the MCMC iteration number.
</p>
<table>
<tr><td><code>coefficients</code></td>
<td>
<p>A matrix containing the MCMC draws of the
regression coefficients.  Rows correspond to MCMC draws, and columns
correspond to variables.</p>
</td></tr>
<tr><td><code>sigma.obs</code></td>
<td>
<p>The standard deviation of the weekly latent
observations. </p>
</td></tr>
<tr><td><code>state.contributions</code></td>
<td>
<p>A three-dimensional array containing the
MCMC draws of each state model's contributions to the state of the
weekly model.  The three dimensions are MCMC iteration, state model,
and week number.</p>
</td></tr>
<tr><td><code>weekly</code></td>
<td>
<p>A matrix of MCMC draws of the weekly latent
observations.  Rows are MCMC iterations, and columns are weekly time
points.</p>
</td></tr>
<tr><td><code>cumulator</code></td>
<td>
<p>A matrix of MCMC draws of the cumulator variable.</p>
</td></tr>
</table>
<p>The returned object also contains MCMC draws for the parameters of the
state models supplied as part of <code>state.specification</code>, relevant
information passed to the function call, and other supplemental
information.
</p>


<h3>Author(s)</h3>

<p>Steven L. Scott <a href="mailto:steve.the.bayesian@gmail.com">steve.the.bayesian@gmail.com</a>
</p>


<h3>References</h3>

<p>Harvey (1990), &quot;Forecasting, structural time series, and the Kalman
filter&quot;, Cambridge University Press.
</p>
<p>Durbin and Koopman (2001), &quot;Time series analysis by state space
methods&quot;, Oxford University Press.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bsts">bsts</a></code>,
<code><a href="#topic+AddLocalLevel">AddLocalLevel</a></code>,
<code><a href="#topic+AddLocalLinearTrend">AddLocalLinearTrend</a></code>,
<code><a href="#topic+AddSemilocalLinearTrend">AddSemilocalLinearTrend</a></code>,
<code><a href="BoomSpikeSlab.html#topic+SpikeSlabPrior">SpikeSlabPrior</a></code>,
<code><a href="Boom.html#topic+SdPrior">SdPrior</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
  data &lt;- SimulateFakeMixedFrequencyData(nweeks = 104, xdim = 20)

  ## Setting an upper limit on the standard deviations can help keep the
  ## MCMC from flying off to infinity.
  sd.limit &lt;- sd(data$coarse.target)
  state.specification &lt;-
       AddLocalLinearTrend(list(),
                     data$coarse.target,
                     level.sigma.prior = SdPrior(1.0, 5, upper.limit = sd.limit),
                     slope.sigma.prior = SdPrior(.5, 5, upper.limit = sd.limit))
  weeks &lt;- index(data$predictor)
  months &lt;- index(data$coarse.target)
  which.month &lt;- MatchWeekToMonth(weeks, months[1])
  membership.fraction &lt;- GetFractionOfDaysInInitialMonth(weeks)
  contains.end &lt;- WeekEndsMonth(weeks)

  model &lt;- bsts.mixed(target.series = data$coarse.target,
                      predictors = data$predictors,
                      membership.fraction = membership.fraction,
                      contains.end = contains.end,
                      which.coarse = which.month,
                      state.specification = state.specification,
                      niter = 500,
                      expected.r2 = .999,
                      prior.df = 1)

  plot(model, "state")
  plot(model, "components")

## End(Not run)
</code></pre>

<hr>
<h2 id='month.distance'>Elapsed time in months</h2><span id='topic+MonthDistance'></span>

<h3>Description</h3>

<p>The (integer) number of months between dates.</p>


<h3>Usage</h3>

<pre><code class='language-R'>   MonthDistance(dates, origin)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="month.distance_+3A_dates">dates</code></td>
<td>
<p>A vector of class <code><a href="base.html#topic+Date">Date</a></code> to be measured.</p>
</td></tr>
<tr><td><code id="month.distance_+3A_origin">origin</code></td>
<td>
<p>A scalar of class <code><a href="base.html#topic+Date">Date</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p> Returns a numeric vector giving the integer number of months
that have elapsed between <code>origin</code> and each element in
<code>dates</code>.  The daily component of each date is ignored, so two
dates that are in the same month will have the same measured
distance.  Distances are signed, so months that occur before
<code>origin</code> will have negative values.  </p>


<h3>Author(s)</h3>

<p>Steven L. Scott <a href="mailto:steve.the.bayesian@gmail.com">steve.the.bayesian@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  dates &lt;- as.Date(c("2008-04-17",
                     "2008-05-01",
                     "2008-05-31",
                     "2008-06-01"))
  origin &lt;- as.Date("2008-05-15")
  MonthDistance(dates, origin) ==  c(-1, 0, 0, 1)
</code></pre>

<hr>
<h2 id='named.holidays'>Holidays Recognized by Name</h2><span id='topic+named.holidays'></span>

<h3>Description</h3>

<p>A character vector listing the names of pre-specified holidays.</p>


<h3>Usage</h3>

<pre><code class='language-R'>named.holidays
</code></pre>


<h3>Value</h3>

<p>&quot;NewYearsDay&quot;                 &quot;SuperBowlSunday&quot;            
&quot;MartinLutherKingDay&quot;         &quot;PresidentsDay&quot;              
&quot;ValentinesDay&quot;               &quot;SaintPatricksDay&quot;           
&quot;USDaylightSavingsTimeBegins&quot; &quot;USDaylightSavingsTimeEnds&quot;  
&quot;EasterSunday&quot;                &quot;USMothersDay&quot;               
&quot;IndependenceDay&quot;             &quot;LaborDay&quot;                   
&quot;ColumbusDay&quot;                 &quot;Halloween&quot;                  
&quot;Thanksgiving&quot;                &quot;MemorialDay&quot;                
&quot;VeteransDay&quot;                 &quot;Christmas&quot;
</p>

<hr>
<h2 id='new.home.sales'>New home sales and Google trends</h2><span id='topic+new.home.sales'></span>

<h3>Description</h3>

<p> The first column, HSN1FNSA is a time series of new home
sales in the US, obtained from the FRED online data base.  The series
has been manually deseasonalized.  The remaining columns contain
search terms from Google trends (obtained from
http://trends.google.com/correlate).  These show the relative
popularity of each search term among all serach terms typed into
Google.  All series in this data set have been standardized by
subtracting off their mean and dividing by their standard deviation.</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(new.home.sales)</code></pre>


<h3>Format</h3>

<p>zoo time series</p>


<h3>Source</h3>

<p>FRED and trends.google.com</p>

<hr>
<h2 id='one.step.prediction.errors'>Prediction Errors</h2><span id='topic+bsts.prediction.errors'></span>

<h3>Description</h3>

<p>Computes the one-step-ahead prediction errors for a <code><a href="#topic+bsts">bsts</a></code>
model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bsts.prediction.errors(bsts.object,
                       cutpoints = NULL,
                       burn = SuggestBurn(.1, bsts.object),
                       standardize = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="one.step.prediction.errors_+3A_bsts.object">bsts.object</code></td>
<td>
<p> An object of class <code><a href="#topic+bsts">bsts</a></code>.</p>
</td></tr>
<tr><td><code id="one.step.prediction.errors_+3A_cutpoints">cutpoints</code></td>
<td>
<p>An increasing sequence of integers between 1 and the
number of time points in the trainig data for <code>bsts.object</code>, or
<code>NULL</code>.  If <code>NULL</code> then the in-sample one-step prediction
errors from the bsts object will be extracted and returned.
Otherwise the model will be re-fit with a separate MCMC run
for each entry in 'cutpoints'.  Data up to each cutpoint will be
included in the fit, and one-step prediction errors for data after
the cutpoint will be computed.  </p>
</td></tr>
<tr><td><code id="one.step.prediction.errors_+3A_burn">burn</code></td>
<td>
<p>An integer giving the number of MCMC iterations to discard
as burn-in.  If <code>burn &lt;= 0</code> then no burn-in sample will be
discarded.</p>
</td></tr>
<tr><td><code id="one.step.prediction.errors_+3A_standardize">standardize</code></td>
<td>
<p> Logical.  If <code>TRUE</code> then the prediction
errors are divided by the square root of the one-step-ahead forecast
variance.  If <code>FALSE</code> the raw errors are returned.  </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Returns the posterior distribution of the one-step-ahead prediction errors
from the bsts.object.  The errors are computing using the Kalman filter,
and are of two types.
</p>
<p>Purely in-sample errors are computed as a by-product of the Kalman
filter as a result of fitting the model.  These are stored in the
bsts.object assuming the <code>save.prediction.errors</code> option is TRUE,
which is the default (See <code><a href="#topic+BstsOptions">BstsOptions</a></code>).  The in-sample
errors are 'in-sample' in the sense that the parameter values used to
run the Kalman filter are drawn from their posterior distribution given
complete data.  Conditional on the parameters in that MCMC iteration,
each 'error' is the difference between the observed y[t] and its
expectation given data to t-1.
</p>
<p>Purely out-of-sample errors can be computed by specifying the 'cutpoints'
argument.  If cutpoints are supplied then a separate MCMC is run using just
data up to the cutpoint.  The Kalman filter is then run on the remaining
data, again finding the difference between y[t] and its expectation given
data to t-1, but conditional on parameters estimated using data up to the
cutpoint.
</p>


<h3>Value</h3>

<p>A matrix of draws of the one-step-ahead prediction errors.  Rows of
the matrix correspond to MCMC draws.  Columns correspond to time.
</p>


<h3>Author(s)</h3>

<p>Steven L. Scott <a href="mailto:steve.the.bayesian@gmail.com">steve.the.bayesian@gmail.com</a>
</p>


<h3>References</h3>

<p>Harvey (1990), &quot;Forecasting, structural time series, and the Kalman
filter&quot;, Cambridge University Press.
</p>
<p>Durbin and Koopman (2001), &quot;Time series analysis by state space
methods&quot;, Oxford University Press.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bsts">bsts</a></code>,
<code><a href="#topic+AddLocalLevel">AddLocalLevel</a></code>,
<code><a href="#topic+AddLocalLinearTrend">AddLocalLinearTrend</a></code>,
<code><a href="#topic+AddSemilocalLinearTrend">AddSemilocalLinearTrend</a></code>,
<code><a href="BoomSpikeSlab.html#topic+SpikeSlabPrior">SpikeSlabPrior</a></code>,
<code><a href="Boom.html#topic+SdPrior">SdPrior</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  data(AirPassengers)
  y &lt;- log(AirPassengers)
  ss &lt;- AddLocalLinearTrend(list(), y)
  ss &lt;- AddSeasonal(ss, y, nseasons = 12)

## Not run: 
  model &lt;- bsts(y, state.specification = ss, niter = 500)

## End(Not run)

  errors &lt;- bsts.prediction.errors(model, burn = 100)
  PlotDynamicDistribution(errors$in.sample)

  ## Compute out of sample prediction errors beyond times 80 and 120.
  errors &lt;- bsts.prediction.errors(model, cutpoints = c(80, 120))
  standardized.errors &lt;- bsts.prediction.errors(
      model, cutpoints = c(80, 120), standardize = TRUE)
  plot(model, "prediction.errors", cutpoints = c(80, 120))
  str(errors)     ## three matrices, with 400 ( = 500 - 100) rows
                  ## and length(y) columns
</code></pre>

<hr>
<h2 id='plot.bsts'>Plotting functions for Bayesian structural time series</h2><span id='topic+plot.bsts'></span><span id='topic+PlotBstsCoefficients'></span><span id='topic+PlotBstsComponents'></span><span id='topic+PlotBstsState'></span><span id='topic+PlotBstsResiduals'></span><span id='topic+PlotBstsPredictionErrors'></span><span id='topic+PlotBstsSize'></span><span id='topic+PlotDynamicRegression'></span><span id='topic+PlotBstsForecastDistribution'></span><span id='topic+PlotSeasonalEffect'></span><span id='topic+PlotMonthlyAnnualCycle'></span>

<h3>Description</h3>

<p>Functions to plot the results of a model fit using
<code><a href="#topic+bsts">bsts</a></code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'bsts'
plot(x, y = c("state", "components", "residuals",
              "coefficients", "prediction.errors",
              "forecast.distribution",
              "predictors", "size", "dynamic", "seasonal", "monthly",
              "help"),
      ...)

  PlotBstsCoefficients(bsts.object, burn = SuggestBurn(.1, bsts.object),
                       inclusion.threshold = 0, number.of.variables = NULL, ...)

  PlotBstsComponents(bsts.object,
                     burn = SuggestBurn(.1, bsts.object),
                     time,
                     same.scale = TRUE,
                     layout = c("square", "horizontal", "vertical"),
                     style = c("dynamic", "boxplot"),
                     ylim = NULL,
                     components = 1:length(bsts.object$state.specification),
                     ...)

  PlotDynamicRegression(bsts.object,
                        burn = SuggestBurn(.1, bsts.object),
                        time = NULL,
                        same.scale = FALSE,
                        style = c("dynamic", "boxplot"),
                        layout = c("square", "horizontal", "vertical"),
                        ylim = NULL,
                        zero.width = 2,
                        zero.color = "green",
                        ...)

  PlotBstsState(bsts.object, burn = SuggestBurn(.1, bsts.object),
                       time, show.actuals = TRUE,
                       style = c("dynamic", "boxplot"),
                       scale = c("linear", "mean"),
                       ylim = NULL,
                       ...)

  PlotBstsResiduals(bsts.object, burn = SuggestBurn(.1, bsts.object),
                       time, style = c("dynamic", "boxplot"), means =
                       TRUE, ...)

  PlotBstsPredictionErrors(bsts.object, cutpoints = NULL,
                           burn = SuggestBurn(.1, bsts.object),
                           style = c("dynamic", "boxplot"),
                           xlab = "Time", ylab = "", main = "",
                           ...)

  PlotBstsForecastDistribution(bsts.object, cutpoints = NULL,
                               burn = SuggestBurn(.1, bsts.object),
                               style = c("dynamic", "boxplot"),
                               xlab = "Time",
                               ylab = "",
                               main = "",
                               show.actuals = TRUE,
                               col.actuals = "blue",
                               ...)

  PlotBstsSize(bsts.object, burn = SuggestBurn(.1, bsts.object), style =
                       c("histogram", "ts"), ...)

  PlotSeasonalEffect(bsts.object, nseasons = 7, season.duration = 1,
                     same.scale = TRUE, ylim = NULL, get.season.name = NULL,
                     burn = SuggestBurn(.1, bsts.object),  ...)

  PlotMonthlyAnnualCycle(bsts.object, ylim = NULL, same.scale = TRUE,
                     burn = SuggestBurn(.1, bsts.object),  ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.bsts_+3A_x">x</code></td>
<td>
<p>An object of class <code><a href="#topic+bsts">bsts</a></code>.</p>
</td></tr>
<tr><td><code id="plot.bsts_+3A_bsts.object">bsts.object</code></td>
<td>
<p>An object of class <code><a href="#topic+bsts">bsts</a></code>.</p>
</td></tr>
<tr><td><code id="plot.bsts_+3A_y">y</code></td>
<td>
<p>A character string indicating the aspect of the model that
should be plotted.</p>
</td></tr>
<tr><td><code id="plot.bsts_+3A_burn">burn</code></td>
<td>
<p>The number of MCMC iterations to discard as burn-in.</p>
</td></tr>
<tr><td><code id="plot.bsts_+3A_col.actuals">col.actuals</code></td>
<td>
<p>The color to use for the actual data when comparing
actuals vs forecasts.</p>
</td></tr>
<tr><td><code id="plot.bsts_+3A_components">components</code></td>
<td>
<p>A numeric vector indicating which components to
plot. Component indices correspond to elements of the state
specification that was used to build the bsts model being plotted.</p>
</td></tr>
<tr><td><code id="plot.bsts_+3A_cutpoints">cutpoints</code></td>
<td>
<p>A numeric vector of integers, or <code>NULL</code>.  For
diagnostic plots of prediction errors or forecast distributions, the
model will be re-fit with a separate MCMC run for each entry in
'cutpoints'.  Data up to each cutpoint will be included in the fit,
and one-step prediction errors for data after the cutpoint will be
computed.
</p>
</td></tr>
<tr><td><code id="plot.bsts_+3A_get.season.name">get.season.name</code></td>
<td>
<p>A function that can be used to infer the title
of each seasonal plot.  It should take a single <code><a href="base.html#topic+POSIXt">POSIXt</a></code>,
<code><a href="base.html#topic+Date">Date</a></code>, or similar object as an argument, and return
a single string that can be used as a panel title.  If
<code>get.season.name</code> is <code>NULL</code> and <code>nseasons</code> is
specified or inferred to be one of the following values, then the
following functions will be used.
</p>

<ul>
<li><p> 4:  <code><a href="base.html#topic+quarters">quarters</a></code>
</p>
</li>
<li><p> 7:  <code><a href="base.html#topic+weekdays">weekdays</a></code>
</p>
</li>
<li><p> 12: <code><a href="base.html#topic+months">months</a></code>
</p>
</li></ul>

</td></tr>
<tr><td><code id="plot.bsts_+3A_inclusion.threshold">inclusion.threshold</code></td>
<td>
<p>An inclusion probability that individual
coefficients must exceed in order to be displayed when <code>what ==
    "coefficients"</code>.  See the help file for
<code><a href="BoomSpikeSlab.html#topic+plot.lm.spike">plot.lm.spike</a>.</code></p>
</td></tr>
<tr><td><code id="plot.bsts_+3A_layout">layout</code></td>
<td>
<p>For controlling the layout of functions that generate
mutiple plots.</p>
</td></tr>
<tr><td><code id="plot.bsts_+3A_main">main</code></td>
<td>
<p>Main title for the plot.</p>
</td></tr>
<tr><td><code id="plot.bsts_+3A_means">means</code></td>
<td>
<p>Logical.  If TRUE then the mean of each residual is
plotted as a blue dot.  If false only the distribution of the
residuals is plotted.</p>
</td></tr>
<tr><td><code id="plot.bsts_+3A_nseasons">nseasons</code></td>
<td>
<p>If there is only one seasonal component in the model,
this argument is ignored.  If there are multiple seasonal
components then <code>nseasons</code> and <code>season.duration</code> are used
to select the desired one.</p>
</td></tr>
<tr><td><code id="plot.bsts_+3A_number.of.variables">number.of.variables</code></td>
<td>
<p>If non-<code>NULL</code> this specifies the
number of coefficients to plot, taking precedence over
<code>inclusion.threshold</code>.  See <code><a href="BoomSpikeSlab.html#topic+plot.lm.spike">plot.lm.spike</a>.</code></p>
</td></tr>
<tr><td><code id="plot.bsts_+3A_same.scale">same.scale</code></td>
<td>
<p>Logical.  If <code>TRUE</code> then all the state
components will be plotted with the same scale on the vertical axis.
If <code>FALSE</code> then each component will get its own scale for the
vertical axis.</p>
</td></tr>
<tr><td><code id="plot.bsts_+3A_scale">scale</code></td>
<td>
<p>The scale on which to plot the state.  If the error
family is &quot;logit&quot; or &quot;poisson&quot; then the state can either be plotted
on the scale of the linear predictor (e.g. trend + seasonal +
regression) or the linear predictor can be passed through the link
function so as to plot the distribution of the conditional mean.</p>
</td></tr>
<tr><td><code id="plot.bsts_+3A_season.duration">season.duration</code></td>
<td>
<p>If there is only one seasonal component in the
model, this argument is ignored.  If there are multiple seasonal
components then <code>nseasons</code> and <code>season.duration</code> are used
to select the desired one.</p>
</td></tr>
<tr><td><code id="plot.bsts_+3A_show.actuals">show.actuals</code></td>
<td>
<p>Logical.  If <code>TRUE</code> then actual values from
the fitted series will be shown on the plot.</p>
</td></tr>
<tr><td><code id="plot.bsts_+3A_style">style</code></td>
<td>
<p>The desired plot style.  Partial matching is allowed, so
&quot;dyn&quot; would match &quot;dynamic&quot;, for example.</p>
</td></tr>
<tr><td><code id="plot.bsts_+3A_time">time</code></td>
<td>
<p>An optional vector of values to plot against.  If missing,
the default is to diagnose the time scale of the original time
series.</p>
</td></tr>
<tr><td><code id="plot.bsts_+3A_xlab">xlab</code></td>
<td>
<p>Label for the horizontal axis.</p>
</td></tr>
<tr><td><code id="plot.bsts_+3A_ylab">ylab</code></td>
<td>
<p>Label for the vertical axis.</p>
</td></tr>
<tr><td><code id="plot.bsts_+3A_ylim">ylim</code></td>
<td>
<p>Limits for the vertical axis.  If <code>NULL</code> these will
be inferred from the state components and the <code>same.scale</code>
argument.  Otherwise all plots will be created with the same
<code>ylim</code> values.</p>
</td></tr>
<tr><td><code id="plot.bsts_+3A_zero.width">zero.width</code></td>
<td>
<p>A numerical value for the width of the reference
line at zero.  If <code>NULL</code> then the line will be omitted.</p>
</td></tr>
<tr><td><code id="plot.bsts_+3A_zero.color">zero.color</code></td>
<td>
<p>A color for the width of the reference line at zero.
If <code>NULL</code> then the line will be omitted.</p>
</td></tr>
<tr><td><code id="plot.bsts_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to
<code><a href="Boom.html#topic+PlotDynamicDistribution">PlotDynamicDistribution</a></code>, or
<code><a href="Boom.html#topic+TimeSeriesBoxplot">TimeSeriesBoxplot</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code><a href="#topic+PlotBstsState">PlotBstsState</a></code>, <code><a href="#topic+PlotBstsComponents">PlotBstsComponents</a></code>, and
<code><a href="#topic+PlotBstsResiduals">PlotBstsResiduals</a></code> all produce dynamic distribution
plots.  <code><a href="#topic+PlotBstsState">PlotBstsState</a></code> plots the aggregate state
contribution (including regression effects) to the mean, while
<code><a href="#topic+PlotBstsComponents">PlotBstsComponents</a></code> plots the contribution of each state
component.  <code><a href="#topic+PlotBstsResiduals">PlotBstsResiduals</a></code> plots the posterior
distribution of the residuals given complete data (i.e. looking
forward and backward in time).  <code><a href="#topic+PlotBstsPredictionErrors">PlotBstsPredictionErrors</a></code>
plots filtering errors (i.e. the one-step-ahead prediction errors
given data up to the previous time point).
<code><a href="#topic+PlotBstsForecastDistribution">PlotBstsForecastDistribution</a></code> plots the one-step-ahead
forecasts instead of the prediction errors.
</p>
<p><code><a href="#topic+PlotBstsCoefficients">PlotBstsCoefficients</a></code> creates a significance plot for
the predictors used in the state space regression model.  It is
obviously not useful for models with no regressors.
</p>
<p><code><a href="#topic+PlotBstsSize">PlotBstsSize</a></code> plots the distribution of the number of
predictors included in the model.
</p>
<p><code><a href="#topic+PlotSeasonalEffect">PlotSeasonalEffect</a></code> generates an array of plots showing
how the distibution of the seasonal effect changes, for each season,
for models that include a seasonal state component.
</p>
<p><code><a href="#topic+PlotMonthlyAnnualCycle">PlotMonthlyAnnualCycle</a></code> produces an array of plots much
like <code><a href="#topic+PlotSeasonalEffect">PlotSeasonalEffect</a></code>, for models that include a
<code><a href="#topic+MonthlyAnnualCycle">MonthlyAnnualCycle</a></code> state component.
</p>


<h3>Value</h3>

<p>These functions are called for their side effect, which is to produce
a plot on the current graphics device.
</p>
<p><code>PlotBstsState</code> invisibly returns the state object being plotted.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bsts">bsts</a></code>
<code><a href="Boom.html#topic+PlotDynamicDistribution">PlotDynamicDistribution</a></code>
<code><a href="BoomSpikeSlab.html#topic+plot.lm.spike">plot.lm.spike</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  data(AirPassengers)
  y &lt;- log(AirPassengers)
  ss &lt;- AddLocalLinearTrend(list(), y)
  ss &lt;- AddSeasonal(ss, y, nseasons = 12)
  model &lt;- bsts(y, state.specification = ss, niter = 500)
  plot(model, burn = 100)
  plot(model, "residuals", burn = 100)
  plot(model, "components", burn = 100)
  plot(model, "forecast.distribution", burn = 100)
</code></pre>

<hr>
<h2 id='plot.bsts.mixed'>Plotting functions for mixed frequency Bayesian structural time series</h2><span id='topic+plot.bsts.mixed'></span><span id='topic+PlotBstsMixedComponents'></span><span id='topic+PlotBstsMixedState'></span>

<h3>Description</h3>

<p>Functions for plotting the output of a mixed frequency time series regression.</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'bsts.mixed'
plot(x,
                            y = c("state", "components",
                                  "coefficients", "predictors", "size"),
                            ...)

   PlotBstsMixedState(bsts.mixed.object,
                      burn = SuggestBurn(.1, bsts.mixed.object),
                      time = NULL,
                      fine.scale = FALSE,
                      style = c("dynamic", "boxplot"),
                      trim.left = NULL,
                      trim.right = NULL,
                      ...)

   PlotBstsMixedComponents(bsts.mixed.object,
                           burn = SuggestBurn(.1, bsts.mixed.object),
                           time = NULL,
                           same.scale = TRUE,
                           fine.scale = FALSE,
                           style = c("dynamic", "boxplot"),
                           layout = c("square", "horizontal", "vertical"),
                           ylim = NULL,
                           trim.left = NULL,
                           trim.right = NULL,
                           ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.bsts.mixed_+3A_x">x</code></td>
<td>
<p>An object of class <code><a href="#topic+bsts.mixed">bsts.mixed</a></code>.</p>
</td></tr>
<tr><td><code id="plot.bsts.mixed_+3A_bsts.mixed.object">bsts.mixed.object</code></td>
<td>
<p>An object of class <code><a href="#topic+bsts.mixed">bsts.mixed</a></code>.</p>
</td></tr>
<tr><td><code id="plot.bsts.mixed_+3A_y">y</code></td>
<td>
<p>A character string indicating the aspect of the model that
should be plotted. </p>
</td></tr>
<tr><td><code id="plot.bsts.mixed_+3A_burn">burn</code></td>
<td>
<p>The number of MCMC iterations to discard as burn-in.</p>
</td></tr>
<tr><td><code id="plot.bsts.mixed_+3A_time">time</code></td>
<td>
<p>An optional vector of values to plot against.  If missing,
the default is to obtain the time scale from the original time
series.</p>
</td></tr>
<tr><td><code id="plot.bsts.mixed_+3A_fine.scale">fine.scale</code></td>
<td>
<p>Logical.  If <code>TRUE</code> then the plots will be at
the weekly level of granularity.  If <code>FALSE</code> they will be at
the monthly level.</p>
</td></tr>
<tr><td><code id="plot.bsts.mixed_+3A_same.scale">same.scale</code></td>
<td>
<p>Logical.  If <code>TRUE</code> then all the state
components will be plotted with the same scale on the vertical axis.
If <code>FALSE</code> then each component will get its own scale for the
vertical axis.</p>
</td></tr>
<tr><td><code id="plot.bsts.mixed_+3A_style">style</code></td>
<td>
<p>character.  If &quot;dynamic&quot; then a dynamic distribution plot
will be shown.  If &quot;box&quot; then boxplots will be shown.</p>
</td></tr>
<tr><td><code id="plot.bsts.mixed_+3A_layout">layout</code></td>
<td>
<p>A character string indicating whether the plots showing
components of state should be laid out in a square, horizontally, or
vertically.</p>
</td></tr>
<tr><td><code id="plot.bsts.mixed_+3A_trim.left">trim.left</code></td>
<td>
<p> A logical indicating whether the first (presumedly
partial) observation in the aggregated state time series should be
removed.  </p>
</td></tr>
<tr><td><code id="plot.bsts.mixed_+3A_trim.right">trim.right</code></td>
<td>
<p> A logical indicating whether the last (presumedly
partial) observation in the aggregated state time series should be
removed.  </p>
</td></tr>
<tr><td><code id="plot.bsts.mixed_+3A_ylim">ylim</code></td>
<td>
<p>Limits for the vertical axis.  Optional.</p>
</td></tr>
<tr><td><code id="plot.bsts.mixed_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to
<code><a href="Boom.html#topic+PlotDynamicDistribution">PlotDynamicDistribution</a></code> or <code><a href="Boom.html#topic+TimeSeriesBoxplot">TimeSeriesBoxplot</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p><code><a href="#topic+PlotBstsMixedState">PlotBstsMixedState</a></code> plots the aggregate state
contribution (including regression effects) to the mean, while
<code><a href="#topic+PlotBstsComponents">PlotBstsComponents</a></code> plots the contribution of each state
component separately.  <code><a href="#topic+PlotBstsCoefficients">PlotBstsCoefficients</a></code> creates a
significance plot for the predictors used in the state space
regression model.
</p>


<h3>Value</h3>

<p>These functions are called for their side effect, which is to produce
a plot on the current graphics device.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bsts.mixed">bsts.mixed</a></code>
<code><a href="Boom.html#topic+PlotDynamicDistribution">PlotDynamicDistribution</a></code>
<code><a href="BoomSpikeSlab.html#topic+plot.lm.spike">plot.lm.spike</a></code>
<code><a href="#topic+PlotBstsSize">PlotBstsSize</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
## This example is flaky and needs to be fixed
  data &lt;- SimulateFakeMixedFrequencyData(nweeks = 104, xdim = 20)
  state.specification &lt;- AddLocalLinearTrend(list(), data$coarse.target)
  weeks &lt;- index(data$predictor)
  months &lt;- index(data$coarse.target)
  which.month &lt;- MatchWeekToMonth(weeks, months[1])
  membership.fraction &lt;- GetFractionOfDaysInInitialMonth(weeks)
  contains.end &lt;- WeekEndsMonth(weeks)

  model &lt;- bsts.mixed(target.series = data$coarse.target,
                      predictors = data$predictors,
                      membership.fraction = membership.fraction,
                      contains.end = contains.end,
                      which.coarse = which.month,
                      state.specification = state.specification,
                      niter = 500)

  plot(model, "state")
  plot(model, "components")

## End(Not run)
</code></pre>

<hr>
<h2 id='plot.bsts.prediction'>Plot predictions from Bayesian structural time series</h2><span id='topic+plot.bsts.prediction'></span>

<h3>Description</h3>

<p>Plot the posterior predictive distribution from a
<code><a href="#topic+bsts">bsts</a></code> prediction object.</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'bsts.prediction'
plot(x,
     y = NULL,
     burn = 0,
     plot.original = TRUE,
     median.color = "blue",
     median.type = 1,
     median.width = 3,
     interval.quantiles = c(.025, .975),
     interval.color = "green",
     interval.type = 2,
     interval.width = 2,
     style = c("dynamic", "boxplot"),
     ylim = NULL,
     ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.bsts.prediction_+3A_x">x</code></td>
<td>
<p>An object of class <code><a href="#topic+bsts.prediction">bsts.prediction</a></code>
created by calling <code>predict</code> on a <code><a href="#topic+bsts">bsts</a></code> object.</p>
</td></tr>
<tr><td><code id="plot.bsts.prediction_+3A_y">y</code></td>
<td>
<p>A dummy argument necessary to match the signature of the
<code><a href="graphics.html#topic+plot">plot</a></code> generic function.  This argument is unused.</p>
</td></tr>
<tr><td><code id="plot.bsts.prediction_+3A_plot.original">plot.original</code></td>
<td>
<p>Logical or numeric.  If <code>TRUE</code> then the
prediction is plotted after a time series plot of the original
series.  If <code>FALSE</code>, the prediction fills the entire plot.
If numeric, then it specifies the number of trailing observations
of the original time series to plot in addition to the
predictions.</p>
</td></tr>
<tr><td><code id="plot.bsts.prediction_+3A_burn">burn</code></td>
<td>
<p>The number of observations you wish to discard as burn-in
from the posterior predictive distribution.  This is in addition
to the burn-in discarded using <code><a href="#topic+predict.bsts">predict.bsts</a></code>.</p>
</td></tr>
<tr><td><code id="plot.bsts.prediction_+3A_median.color">median.color</code></td>
<td>
<p>The color to use for the posterior median of the
prediction.</p>
</td></tr>
<tr><td><code id="plot.bsts.prediction_+3A_median.type">median.type</code></td>
<td>
<p>The type of line (lty) to use for the posterior median
of the prediction.</p>
</td></tr>
<tr><td><code id="plot.bsts.prediction_+3A_median.width">median.width</code></td>
<td>
<p>The width of line (lwd) to use for the posterior median
of the prediction.</p>
</td></tr>
<tr><td><code id="plot.bsts.prediction_+3A_interval.quantiles">interval.quantiles</code></td>
<td>
<p>The lower and upper limits of the credible
interval to be plotted.</p>
</td></tr>
<tr><td><code id="plot.bsts.prediction_+3A_interval.color">interval.color</code></td>
<td>
<p>The color to use for the upper and lower limits
of the 95% credible interval for the prediction.</p>
</td></tr>
<tr><td><code id="plot.bsts.prediction_+3A_interval.type">interval.type</code></td>
<td>
<p>The type of line (lty) to use for the upper and
lower limits of the 95% credible inerval for of the
prediction.</p>
</td></tr>
<tr><td><code id="plot.bsts.prediction_+3A_interval.width">interval.width</code></td>
<td>
<p>The width of line (lwd) to use for the upper and
lower limits of the 95% credible inerval for of the
prediction.</p>
</td></tr>
<tr><td><code id="plot.bsts.prediction_+3A_style">style</code></td>
<td>
<p>Either &quot;dynamic&quot;, for dynamic distribution plots, or
&quot;boxplot&quot;, for box plots.  Partial matching is allowed, so &quot;dyn&quot; or
&quot;box&quot; would work, for example.</p>
</td></tr>
<tr><td><code id="plot.bsts.prediction_+3A_ylim">ylim</code></td>
<td>
<p>Limits on the vertical axis.</p>
</td></tr>
<tr><td><code id="plot.bsts.prediction_+3A_...">...</code></td>
<td>
<p>Extra arguments to be passed to
<code><a href="Boom.html#topic+PlotDynamicDistribution">PlotDynamicDistribution</a></code>
and <code><a href="graphics.html#topic+lines">lines</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p> Plots the posterior predictive distribution described by
<code>x</code> using a dynamic distribution plot generated by
<code><a href="Boom.html#topic+PlotDynamicDistribution">PlotDynamicDistribution</a></code>.  Overlays the
posterior median and 95% prediction limits for the predictive
distribution.  </p>


<h3>Value</h3>

<p>Returns NULL.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bsts">bsts</a></code>
<code><a href="Boom.html#topic+PlotDynamicDistribution">PlotDynamicDistribution</a></code>
<code><a href="BoomSpikeSlab.html#topic+plot.lm.spike">plot.lm.spike</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  data(AirPassengers)
  y &lt;- log(AirPassengers)
  ss &lt;- AddLocalLinearTrend(list(), y)
  ss &lt;- AddSeasonal(ss, y, nseasons = 12)
  model &lt;- bsts(y, state.specification = ss, niter = 500)
  pred &lt;- predict(model, horizon = 12, burn = 100)
  plot(pred)
</code></pre>

<hr>
<h2 id='plot.bsts.predictors'>Plot the most likely predictors</h2><span id='topic+PlotBstsPredictors'></span>

<h3>Description</h3>

<p>Creates a time series plot showing the most likely
predictors of a time series used to fit a <code><a href="#topic+bsts">bsts</a></code> object.</p>


<h3>Usage</h3>

<pre><code class='language-R'>  PlotBstsPredictors(bsts.object,
                     burn = SuggestBurn(.1, bsts.object),
                     inclusion.threshold = .1,
                     ylim = NULL,
                     flip.signs = TRUE,
                     show.legend = TRUE,
                     grayscale = TRUE,
                     short.names = TRUE,
                     ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.bsts.predictors_+3A_bsts.object">bsts.object</code></td>
<td>
<p>An object of class <code><a href="#topic+bsts">bsts</a></code>.</p>
</td></tr>
<tr><td><code id="plot.bsts.predictors_+3A_burn">burn</code></td>
<td>
<p>The number of observations you wish to discard as burn-in.</p>
</td></tr>
<tr><td><code id="plot.bsts.predictors_+3A_inclusion.threshold">inclusion.threshold</code></td>
<td>
<p>Plot predictors with marginal inclusion
probabilities above this threshold.</p>
</td></tr>
<tr><td><code id="plot.bsts.predictors_+3A_ylim">ylim</code></td>
<td>
<p>Scale for the vertical axis.  </p>
</td></tr>
<tr><td><code id="plot.bsts.predictors_+3A_flip.signs">flip.signs</code></td>
<td>
<p>If true then a predictor with a negative sign will
be flipped before being plotted, to better align visually
with the target series.</p>
</td></tr>
<tr><td><code id="plot.bsts.predictors_+3A_show.legend">show.legend</code></td>
<td>

<p>Should a legend be shown indicating which predictors are plotted?
</p>
</td></tr>
<tr><td><code id="plot.bsts.predictors_+3A_grayscale">grayscale</code></td>
<td>
<p>Logical.  If <code>TRUE</code> then lines for different
predictors grow progressively lighter as their inclusion probability
decreases.  If <code>FALSE</code> then lines are drawn in black.</p>
</td></tr>
<tr><td><code id="plot.bsts.predictors_+3A_short.names">short.names</code></td>
<td>
<p>Logical.  If <code>TRUE</code> then a common prefix or
suffix shared by all the variables will be discarded.</p>
</td></tr>
<tr><td><code id="plot.bsts.predictors_+3A_...">...</code></td>
<td>
<p>Extra arguments to be passed to <code><a href="graphics.html#topic+plot">plot</a></code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+bsts">bsts</a></code>
<code><a href="Boom.html#topic+PlotDynamicDistribution">PlotDynamicDistribution</a></code>
<code><a href="BoomSpikeSlab.html#topic+plot.lm.spike">plot.lm.spike</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  data(AirPassengers)
  y &lt;- log(AirPassengers)
  lag.y &lt;- c(NA, head(y, -1))
  ss &lt;- AddLocalLinearTrend(list(), y)
  ss &lt;- AddSeasonal(ss, y, nseasons = 12)
  ## Call bsts with na.action = na.omit to omit the leading NA in lag.y
  model &lt;- bsts(y ~ lag.y, state.specification = ss, niter = 500,
                na.action = na.omit)
  plot(model, "predictors")
</code></pre>

<hr>
<h2 id='plot.holiday'>Plot Holiday Effects</h2><span id='topic+PlotHoliday'></span>

<h3>Description</h3>

<p> Plot the estimated effect of the given holiday.</p>


<h3>Usage</h3>

<pre><code class='language-R'>  PlotHoliday(holiday, model, show.raw.data = TRUE, ylim = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.holiday_+3A_holiday">holiday</code></td>
<td>
<p>An object of class <code><a href="#topic+Holiday">Holiday</a></code>.</p>
</td></tr>
<tr><td><code id="plot.holiday_+3A_model">model</code></td>
<td>
<p>A model fit by <code><a href="#topic+bsts">bsts</a></code> containing either a
<code><a href="#topic+RegressionHolidayStateModel">RegressionHolidayStateModel</a></code> or
<code><a href="#topic+HierarchicalRegressionHolidayStateModel">HierarchicalRegressionHolidayStateModel</a></code> that includes
<code>holiday</code>.  </p>
</td></tr>
<tr><td><code id="plot.holiday_+3A_show.raw.data">show.raw.data</code></td>
<td>
<p>Logical indicating if the raw data corresponding
to <code>holiday</code> should be superimposed on the plot.  The 'raw
data' are the actual values of the target series, minus the value of
the target series the day before the holiday began, which is a
(somewhat poor) proxy for remaining state elements.  The raw data
can appear artificially noisy if there are other strong state
effects such as a day-of-week effect for holidays that don't always
occur on the same day of the week.  </p>
</td></tr>
<tr><td><code id="plot.holiday_+3A_ylim">ylim</code></td>
<td>
<p>Limits on the vertical axis of the plots.</p>
</td></tr>
<tr><td><code id="plot.holiday_+3A_...">...</code></td>
<td>
<p>Extra arguments passed to <code><a href="graphics.html#topic+boxplot">boxplot</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns <code>invisible{NULL}</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bsts">bsts</a></code>
<code><a href="#topic+AddRandomWalkHoliday">AddRandomWalkHoliday</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  trend &lt;- cumsum(rnorm(730, 0, .1))
  dates &lt;- seq.Date(from = as.Date("2014-01-01"), length = length(trend),
    by = "day")
  y &lt;- zoo(trend + rnorm(length(trend), 0, .2), dates)

  AddHolidayEffect &lt;- function(y, dates, effect) {
    ## Adds a holiday effect to simulated data.
    ## Args:
    ##   y: A zoo time series, with Dates for indices.
    ##   dates: The dates of the holidays.
    ##   effect: A vector of holiday effects of odd length.  The central effect is
    ##     the main holiday, with a symmetric influence window on either side.
    ## Returns:
    ##   y, with the holiday effects added.
    time &lt;- dates - (length(effect) - 1) / 2
    for (i in 1:length(effect)) {
      y[time] &lt;- y[time] + effect[i]
      time &lt;- time + 1
    }
    return(y)
  }

  ## Define some holidays.
  memorial.day &lt;- NamedHoliday("MemorialDay")
  memorial.day.effect &lt;- c(.3, 3, .5)
  memorial.day.dates &lt;- as.Date(c("2014-05-26", "2015-05-25"))
  y &lt;- AddHolidayEffect(y, memorial.day.dates, memorial.day.effect)
  
  presidents.day &lt;- NamedHoliday("PresidentsDay")
  presidents.day.effect &lt;- c(.5, 2, .25)
  presidents.day.dates &lt;- as.Date(c("2014-02-17", "2015-02-16"))
  y &lt;- AddHolidayEffect(y, presidents.day.dates, presidents.day.effect)
  
  labor.day &lt;- NamedHoliday("LaborDay")
  labor.day.effect &lt;- c(1, 2, 1)
  labor.day.dates &lt;- as.Date(c("2014-09-01", "2015-09-07"))
  y &lt;- AddHolidayEffect(y, labor.day.dates, labor.day.effect)
  
  ## The holidays can be in any order.
  holiday.list &lt;- list(memorial.day, labor.day, presidents.day)
  number.of.holidays &lt;- length(holiday.list)
  
  ## In a real example you'd want more than 100 MCMC iterations.
  niter &lt;- 100
  ss &lt;- AddLocalLevel(list(), y)
  ss &lt;- AddRegressionHoliday(ss, y, holiday.list = holiday.list)
  model &lt;- bsts(y, state.specification = ss, niter = niter)

  PlotHoliday(memorial.day, model)
</code></pre>

<hr>
<h2 id='plot.mbsts'>Plotting Functions for Multivariate Bayesian Structural Time Series</h2><span id='topic+plot.mbsts'></span><span id='topic+PlotMbstsSeriesMeans'></span>

<h3>Description</h3>

<p>Functions to plot the results of a model fit using
<code><a href="#topic+mbsts">mbsts</a></code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>
## S3 method for class 'mbsts'
plot(x, y = c("means", "help"), ...)

PlotMbstsSeriesMeans(mbsts.object,
                     series.id = NULL,
                     same.scale = TRUE,
                     burn = SuggestBurn(.1, mbsts.object),
                     time,
                     show.actuals = TRUE,
                     ylim = NULL,
                     gap = 0,
                     cex.actuals = 0.2,
                     ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.mbsts_+3A_x">x</code></td>
<td>
<p>An object of class <code><a href="#topic+mbsts">mbsts</a></code>.</p>
</td></tr>
<tr><td><code id="plot.mbsts_+3A_y">y</code></td>
<td>
<p>A character string indicating the aspect of the model that
should be plotted.</p>
</td></tr>
<tr><td><code id="plot.mbsts_+3A_mbsts.object">mbsts.object</code></td>
<td>
<p>An object of class <code><a href="#topic+mbsts">mbsts</a></code>.</p>
</td></tr>
<tr><td><code id="plot.mbsts_+3A_series.id">series.id</code></td>
<td>
<p>Indicates which series should be plotted.  An
integer, logical, or character vector.</p>
</td></tr>
<tr><td><code id="plot.mbsts_+3A_same.scale">same.scale</code></td>
<td>
<p>Logical.  If <code>TRUE</code> then all the series or
state components will be plotted with the same scale on the vertical
axis.  If <code>FALSE</code> then each plot will get its own scale for the
vertical axis.</p>
</td></tr>
<tr><td><code id="plot.mbsts_+3A_burn">burn</code></td>
<td>
<p>The number of MCMC iterations to discard as burn-in.</p>
</td></tr>
<tr><td><code id="plot.mbsts_+3A_time">time</code></td>
<td>
<p>An optional vector of values to plot against.  If missing,
the default is to diagnose the time scale of the original time
series.</p>
</td></tr>
<tr><td><code id="plot.mbsts_+3A_show.actuals">show.actuals</code></td>
<td>
<p>Logical.  If <code>TRUE</code> then actual values from
the fitted series will be shown on the plot.</p>
</td></tr>
<tr><td><code id="plot.mbsts_+3A_ylim">ylim</code></td>
<td>
<p>Limits for the vertical axis.  If <code>NULL</code> these will
be inferred from the state components and the <code>same.scale</code>
argument.  Otherwise all plots will be created with the same
<code>ylim</code> values.</p>
</td></tr>
<tr><td><code id="plot.mbsts_+3A_gap">gap</code></td>
<td>
<p>The number of lines to leave between plots.  This need not
be an integer.</p>
</td></tr>
<tr><td><code id="plot.mbsts_+3A_cex.actuals">cex.actuals</code></td>
<td>
<p>Scale factor to use for plotting the raw data.</p>
</td></tr>
<tr><td><code id="plot.mbsts_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to
<code><a href="Boom.html#topic+PlotDynamicDistribution">PlotDynamicDistribution</a></code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+plot.bsts">plot.bsts</a></code>
</p>

<hr>
<h2 id='plot.mbsts.prediction'>Plot Multivariate Bsts Predictions</h2><span id='topic+plot.mbsts.prediction'></span>

<h3>Description</h3>

<p>Plot the posterior predictive distribution from an
<code><a href="#topic+mbsts">mbsts</a></code> prediction object.</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'mbsts.prediction'
plot(x,
     y = NULL,
     burn = 0,
     plot.original = TRUE,
     median.color = "blue",
     median.type = 1,
     median.width = 3,
     interval.quantiles = c(.025, .975),
     interval.color = "green",
     interval.type = 2,
     interval.width = 2,
     style = c("dynamic", "boxplot"),
     ylim = NULL,
     series.id = NULL,
     same.scale = TRUE,
     gap = 0,
     ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.mbsts.prediction_+3A_x">x</code></td>
<td>
<p>An object of class <code><a href="#topic+bsts.prediction">bsts.prediction</a></code>
created by calling <code>predict</code> on a <code><a href="#topic+bsts">bsts</a></code> object.</p>
</td></tr>
<tr><td><code id="plot.mbsts.prediction_+3A_y">y</code></td>
<td>
<p>A dummy argument necessary to match the signature of the
<code><a href="graphics.html#topic+plot">plot</a></code> generic function.  This argument is unused.</p>
</td></tr>
<tr><td><code id="plot.mbsts.prediction_+3A_plot.original">plot.original</code></td>
<td>
<p>Logical or numeric.  If <code>TRUE</code> then the
prediction is plotted after a time series plot of the original
series.  If <code>FALSE</code>, the prediction fills the entire plot.
If numeric, then it specifies the number of trailing observations
of the original time series to plot in addition to the
predictions.</p>
</td></tr>
<tr><td><code id="plot.mbsts.prediction_+3A_burn">burn</code></td>
<td>
<p>The number of observations you wish to discard as burn-in
from the posterior predictive distribution.  This is in addition
to the burn-in discarded using <code><a href="#topic+predict.bsts">predict.bsts</a></code>.</p>
</td></tr>
<tr><td><code id="plot.mbsts.prediction_+3A_median.color">median.color</code></td>
<td>
<p>The color to use for the posterior median of the
prediction.</p>
</td></tr>
<tr><td><code id="plot.mbsts.prediction_+3A_median.type">median.type</code></td>
<td>
<p>The type of line (lty) to use for the posterior median
of the prediction.</p>
</td></tr>
<tr><td><code id="plot.mbsts.prediction_+3A_median.width">median.width</code></td>
<td>
<p>The width of line (lwd) to use for the posterior median
of the prediction.</p>
</td></tr>
<tr><td><code id="plot.mbsts.prediction_+3A_interval.quantiles">interval.quantiles</code></td>
<td>
<p>The lower and upper limits of the credible
interval to be plotted.</p>
</td></tr>
<tr><td><code id="plot.mbsts.prediction_+3A_interval.color">interval.color</code></td>
<td>
<p>The color to use for the upper and lower limits
of the 95% credible interval for the prediction.</p>
</td></tr>
<tr><td><code id="plot.mbsts.prediction_+3A_interval.type">interval.type</code></td>
<td>
<p>The type of line (lty) to use for the upper and
lower limits of the 95% credible inerval for of the
prediction.</p>
</td></tr>
<tr><td><code id="plot.mbsts.prediction_+3A_interval.width">interval.width</code></td>
<td>
<p>The width of line (lwd) to use for the upper and
lower limits of the 95% credible inerval for of the
prediction.</p>
</td></tr>
<tr><td><code id="plot.mbsts.prediction_+3A_style">style</code></td>
<td>
<p>Either &quot;dynamic&quot;, for dynamic distribution plots, or
&quot;boxplot&quot;, for box plots.  Partial matching is allowed, so &quot;dyn&quot; or
&quot;box&quot; would work, for example.</p>
</td></tr>
<tr><td><code id="plot.mbsts.prediction_+3A_ylim">ylim</code></td>
<td>
<p>Limits on the vertical axis.</p>
</td></tr>
<tr><td><code id="plot.mbsts.prediction_+3A_series.id">series.id</code></td>
<td>
<p>A factor, string, or integer used to indicate which
of the multivariate series to plot.  If NULL then predictions for
all series will be plotted.  If there are many series this can make
the plot unreadable.</p>
</td></tr>
<tr><td><code id="plot.mbsts.prediction_+3A_same.scale">same.scale</code></td>
<td>
<p> Logical.  If TRUE then all predictions are plotted
with the same scale, and limits are drawn on the Y axis. If FALSE
then each prediction is drawn to fill its plot region, and no tick
marks are drawn on the y axis.  If ylim is specified then it is used
for all plots, and same.scale is ignored.</p>
</td></tr>
<tr><td><code id="plot.mbsts.prediction_+3A_gap">gap</code></td>
<td>
<p>The amount of space to leave between plots, measured in
lines of text.</p>
</td></tr>
<tr><td><code id="plot.mbsts.prediction_+3A_...">...</code></td>
<td>
<p>Extra arguments to be passed to
<code><a href="Boom.html#topic+PlotDynamicDistribution">PlotDynamicDistribution</a></code>
and <code><a href="graphics.html#topic+lines">lines</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p> Plots the posterior predictive distribution described by
<code>x</code> using a dynamic distribution plot generated by
<code><a href="Boom.html#topic+PlotDynamicDistribution">PlotDynamicDistribution</a></code>.  Overlays the
posterior median and 95% prediction limits for the predictive
distribution.  </p>


<h3>Value</h3>

<p>Returns NULL.
</p>

<hr>
<h2 id='predict.bsts'>Prediction for Bayesian Structural Time Series</h2><span id='topic+predict.bsts'></span><span id='topic+bsts.prediction'></span>

<h3>Description</h3>

<p>Generate draws from the posterior predictive distribution
of a <code><a href="#topic+bsts">bsts</a></code> object.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bsts'
predict(object,
        horizon = 1,
        newdata = NULL,
        timestamps = NULL,
        burn = SuggestBurn(.1, object),
        na.action = na.exclude,
        olddata = NULL,
        olddata.timestamps = NULL,
        trials.or.exposure = 1,
        quantiles = c(.025, .975),
        seed = NULL,
        ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.bsts_+3A_object">object</code></td>
<td>
<p>An object of class <code>bsts</code> created by a call to the
function <code><a href="#topic+bsts">bsts</a></code>.</p>
</td></tr>
<tr><td><code id="predict.bsts_+3A_horizon">horizon</code></td>
<td>
<p>An integer specifying the number of periods into the
future you wish to predict.  If <code>object</code> contains a regression
component then the forecast horizon is <code>nrow(X)</code>, and this
argument is not used.</p>
</td></tr>
<tr><td><code id="predict.bsts_+3A_newdata">newdata</code></td>
<td>
<p>a vector, matrix, or data frame containing the
predictor variables to use in making the prediction.  This is only
required if <code>object</code> contains a regression component.  If a data
frame, it must include variables with the same names as the data
used to fit <code>object</code>.  The first observation in <code>newdata</code>
is assumed to be one time unit after the end of the last observation
used in fitting <code>object</code>, and the subsequent observations are
sequential time points.  If the regression part of <code>object</code>
contains only a single predictor then <code>newdata</code> can be a
vector.  If <code>newdata</code> is passed as a matrix it is the caller's
responsibility to ensure that it contains the correct number of
columns and that the columns correspond to those in
<code>object$coefficients</code>.
</p>
</td></tr>
<tr><td><code id="predict.bsts_+3A_timestamps">timestamps</code></td>
<td>
<p> A vector of time stamps (of the same type as the
timestamps used to fit <code>object</code>), with one per row of
<code>newdata</code> (or element of <code>newdata</code>, if <code>newdata</code> is a
vector).  The time stamps give the time points as which each
prediction is desired.  They must be interpretable as integer (0 or
larger) time steps following the last time stamp in <code>object</code>.
If <code>NULL</code>, then the requested predictions are interpreted as
being at 1, 2, 3, ... steps following the training data.  </p>
</td></tr>
<tr><td><code id="predict.bsts_+3A_burn">burn</code></td>
<td>
<p>An integer describing the number of MCMC
iterations in <code>object</code> to be discarded as burn-in.  If
<code>burn &lt;= 0</code> then no burn-in period will be discarded.
</p>
</td></tr>
<tr><td><code id="predict.bsts_+3A_na.action">na.action</code></td>
<td>
<p>A function determining what should be done with
missing values in <code>newdata</code>.</p>
</td></tr>
<tr><td><code id="predict.bsts_+3A_olddata">olddata</code></td>
<td>
<p>This is an optional component allowing predictions to
be made conditional on data other than the data used to fit the
model.  If omitted, then it is assumed that forecasts are to be made
relative to the final observation in the training data.  If
<code>olddata</code> is supplied then it will be filtered to get the
distribution of the next state before a prediction is made, and it
is assumed that the first entry in <code>newdata</code> comes immediately
after the last entry in <code>olddata</code>.
</p>
<p>The value for <code>olddata</code> depends on whether or not <code>object</code>
contains a regression component.
</p>

<ul>
<li><p> If a regression component is present, then <code>olddata</code>
is a <code>data.frame</code> including variables with the same names
as the data used to fit <code>object</code>, including the response .
</p>
</li>
<li><p> If no regression component is present, then <code>olddata</code>
is a vector containing historical values of a time series.
</p>
</li></ul>

</td></tr>
<tr><td><code id="predict.bsts_+3A_olddata.timestamps">olddata.timestamps</code></td>
<td>
<p> A set of timestamps corresponding to the
observations supplied in <code>olddata</code>.  If <code>olddata</code> is
<code>NULL</code> then this argument is not used.  If <code>olddata</code> is
supplied and this is <code>NULL</code> then trivial timestamps (1, 2, ...)
will be assumed.  Otherwise this argument behaves like the
<code>timestamps</code> argument to the <code><a href="#topic+bsts">bsts</a></code> function.  </p>
</td></tr>
<tr><td><code id="predict.bsts_+3A_trials.or.exposure">trials.or.exposure</code></td>
<td>
<p>For logit or Poisson models, the number of
binomial trials (or the exposure time) to assume at each time point
in the forecast period.  This can either be a scalar (if the number
of trials is to be the same for each time period), or it can be a
vector with length equal to <code>horizon</code> (if the model contains no
regression term) or <code>nrow(newdata)</code> if the model contains a
regression term.</p>
</td></tr>
<tr><td><code id="predict.bsts_+3A_quantiles">quantiles</code></td>
<td>
<p>A numeric vector of length 2 giving the lower and
upper quantiles to use for the forecast interval estimate.
</p>
</td></tr>
<tr><td><code id="predict.bsts_+3A_seed">seed</code></td>
<td>
<p>An integer to use as the C++ random seed.  If <code>NULL</code>
then the C++ seed will be set using the clock.</p>
</td></tr>
<tr><td><code id="predict.bsts_+3A_...">...</code></td>
<td>
<p>This is a dummy argument included to match the signature
of the generic <code><a href="stats.html#topic+predict">predict</a></code> function.  It is not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Samples from the posterior distribution of a Bayesian structural time
series model.  This function can be used either with or without
contemporaneous predictor variables (in a time series regression).
</p>
<p>If predictor variables are present, the regression coefficients are
fixed (as opposed to time varying, though time varying coefficients
might be added as state component).  The predictors and response in
the formula are contemporaneous, so if you want lags and differences
you need to put them in the predictor matrix yourself.
</p>
<p>If no predictor variables are used, then the model is an ordinary
state space time series model.
</p>


<h3>Value</h3>

<p>Returns an object of class <code>bsts.prediction</code>, which is a list
with the following components.
</p>
<table>
<tr><td><code>mean</code></td>
<td>
<p>A vector giving the posterior mean of the prediction.</p>
</td></tr>
<tr><td><code>interval</code></td>
<td>
<p>A two (column/row?) matrix giving the upper and lower
bounds of the 95 percent credible interval for the prediction.</p>
</td></tr>
<tr><td><code>distribution</code></td>
<td>
<p>A matrix of draws from the posterior predictive
distribution.  Each row in the matrix is one MCMC draw.  Columns
represent time.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Steven L. Scott
</p>


<h3>References</h3>

<p>Harvey (1990), &quot;Forecasting, structural time series, and the Kalman
filter&quot;, Cambridge University Press.
</p>
<p>Durbin and Koopman (2001), &quot;Time series analysis by state space
methods&quot;, Oxford University Press.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bsts">bsts</a></code>.
<code><a href="#topic+AddLocalLevel">AddLocalLevel</a></code>.
<code><a href="#topic+AddLocalLinearTrend">AddLocalLinearTrend</a></code>.
<code><a href="#topic+AddSemilocalLinearTrend">AddSemilocalLinearTrend</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# The number of MCMC draws in the following examples is artificially low.


  ## Making predictions when there is no regression component.
  data(AirPassengers)
  y &lt;- log(AirPassengers)
  ss &lt;- AddLocalLinearTrend(list(), y)
  ss &lt;- AddSeasonal(ss, y, nseasons = 12)
  model &lt;- bsts(y, state.specification = ss, niter = 250)
  pred &lt;- predict(model, horizon = 12, burn = 100)
  plot(pred)

  ## An example using the olddata argument.
  full.pred &lt;- pred
  training &lt;- window(y, end = c(1959, 12))
  model &lt;- bsts(training, state.specification = ss, niter = 250)
  ## Predict the next 12 months.
  pred &lt;- predict(model, horizon = 12)
  ## Compare the predictions to the actual data.
  plot(pred)
  lines(as.numeric(y, col = "red", lty = 2, lwd = 2))

  ## Predict the 12 months of 1961 based on the posterior distribution
  ## of the model fit to data through 1959, but with state filtered
  ## through 1960.
  updated.pred &lt;- predict(model, horizon = 12, olddata = y)
  par(mfrow = c(1, 2))
  plot(full.pred, ylim = c(4, 7))
  plot(updated.pred, ylim = c(4, 7))

  ## Examples including a regression component.
  ##
  data(iclaims)
  training &lt;- initial.claims[1:402, ]
  holdout1 &lt;- initial.claims[403:450, ]
  holdout2 &lt;- initial.claims[451:456, ]

## Not run: 

## This example puts the total run time over 5 seconds, which is a CRAN
## violation.

  ss &lt;- AddLocalLinearTrend(list(), training$iclaimsNSA)
  ss &lt;- AddSeasonal(ss, training$iclaimsNSA, nseasons = 52)
  ## In real life you'd want more iterations...
  model &lt;- bsts(iclaimsNSA ~ ., state.specification = ss, data =
                training, niter = 100)

  ## Predict the holdout set given the training set.
  ## This is really fast, because we can use saved state from the MCMC
  ## algorithm.
  pred.full &lt;- predict(model, newdata = rbind(holdout1, holdout2))

  ## Predict holdout 2, given training and holdout1.
  ## This is much slower because we need to re-filter the 'olddata' before
  ## simulating the predictions.
  pred.update &lt;- predict(model, newdata = holdout2,
    olddata = rbind(training, holdout1))

## End(Not run)
</code></pre>

<hr>
<h2 id='predict.mbsts'>Prediction for Multivariate Bayesian Structural Time Series</h2><span id='topic+predict.mbsts'></span><span id='topic+mbsts.prediction'></span>

<h3>Description</h3>

<p>Generate draws from the posterior predictive distribution
of an <code><a href="#topic+mbsts">mbsts</a></code> object.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mbsts'
predict(object,
        horizon = 1,
        newdata = NULL,
        timestamps = NULL,
        burn = SuggestBurn(.1, object),
        na.action = na.exclude,
        quantiles = c(.025, .975),
        seed = NULL,
        ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.mbsts_+3A_object">object</code></td>
<td>
<p>An object of class <code><a href="#topic+mbsts">mbsts</a></code>.</p>
</td></tr>
<tr><td><code id="predict.mbsts_+3A_horizon">horizon</code></td>
<td>
<p>An integer specifying the number of periods into the
future you wish to predict.  If <code>object</code> contains a regression
component then the forecast horizon is <code>nrow(newdata)</code> and this
argument is not used.</p>
</td></tr>
<tr><td><code id="predict.mbsts_+3A_newdata">newdata</code></td>
<td>
<p>A vector, matrix, or data frame containing the
predictor variables to use in making the prediction.  This is only
required if <code>object</code> contains a regression component.  If a
data frame, it must include variables with the same names as the
data used to fit <code>object</code>.  The first observation in newdata is
assumed to be one time unit after the end of the last data used in
fitting <code>object</code>, and the subsequent observations are
sequential time points.  If the regression part of <code>object</code>
contains only a single predictor then newdata can be a vector.  If
<code>newdata</code> is passed as a matrix it is the caller's
responsibility to ensure that it contains the correct number of
columns and that the columns correspond to those in
object$coefficients.  </p>
</td></tr>
<tr><td><code id="predict.mbsts_+3A_timestamps">timestamps</code></td>
<td>
<p>A vector of time stamps (of the same type as the
timestamps used to fit <code>object</code>), with one per row of
<code>newdata</code> (or element of <code>newdata</code>, if <code>newdata</code> is a
vector).  The time stamps give the time points as which each
prediction is desired.  They must be interpretable as integer (0 or
larger) time steps following the last time stamp in <code>object</code>.
If <code>NULL</code>, then the requested predictions are interpreted as
being at 1, 2, 3, ... steps following the training data.</p>
</td></tr>
<tr><td><code id="predict.mbsts_+3A_burn">burn</code></td>
<td>
<p>An integer describing the number of MCMC iterations in
<code>object</code> to be discarded as burn-in.  If burn &lt;= 0 then no
burn-in period will be discarded.</p>
</td></tr>
<tr><td><code id="predict.mbsts_+3A_na.action">na.action</code></td>
<td>
<p>A function determining what should be done with
missing values in <code>newdata</code>.</p>
</td></tr>
<tr><td><code id="predict.mbsts_+3A_quantiles">quantiles</code></td>
<td>
<p>A numeric vector of length 2 giving the lower and
upper quantiles to use for the forecast interval estimate.</p>
</td></tr>
<tr><td><code id="predict.mbsts_+3A_seed">seed</code></td>
<td>
<p>An integer to use as the C++ random seed.  If
<code>NULL</code> then the C++ seed will be set using the clock.</p>
</td></tr>
<tr><td><code id="predict.mbsts_+3A_...">...</code></td>
<td>
<p>Not used.  Present to match the signature of the
default predict method.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The prediction is based off of samples taken from the posterior
distribution of a multivariate Bayesian structural time series model.
</p>
<p>As an added convenience, means and interval estimates are produced
from the posterior predictive distribution.
</p>


<h3>Value</h3>

<p>Returns an object of class mbsts.prediction, which is a list.
</p>


<h3>Author(s)</h3>

<p>Steven L. Scott
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mbsts">mbsts</a></code>.
<code><a href="#topic+predict.bsts">predict.bsts</a></code>
<code><a href="#topic+plot.mbsts.prediction">plot.mbsts.prediction</a></code>
</p>

<hr>
<h2 id='quarter'>Find the quarter in which a date occurs</h2><span id='topic+Quarter'></span>

<h3>Description</h3>

<p>Returns the quarter and year in which a date occurs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>   Quarter(date)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="quarter_+3A_date">date</code></td>
<td>
<p>A vector convertible to <code><a href="base.html#topic+POSIXlt">POSIXlt</a></code>.  A
<code><a href="base.html#topic+Date">Date</a></code> or <code>character</code> is fine.</p>
</td></tr>
</table>


<h3>Value</h3>

<p> A numeric vector identifying the quarter that each element of
<code>date</code> corresponds to, expressed as a number of years since 1900.
Thus Q1-2000 is 100.00, and Q3-2007 is 107.50.  </p>


<h3>Author(s)</h3>

<p>Steven L. Scott <a href="mailto:steve.the.bayesian@gmail.com">steve.the.bayesian@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  Quarter(c("2008-02-29", "2008-04-29"))
  # [1] 108.00 108.25
</code></pre>

<hr>
<h2 id='regression.holiday'>
Regression Based Holiday Models
</h2><span id='topic+AddRegressionHoliday'></span><span id='topic+RegressionHolidayStateModel'></span><span id='topic+AddHierarchicalRegressionHoliday'></span><span id='topic+HierarchicalRegressionHolidayStateModel'></span>

<h3>Description</h3>

<p>Add a regression-based holiday model to the state specification.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
AddRegressionHoliday(
    state.specification = NULL,
    y,
    holiday.list,
    time0 = NULL,
    prior = NULL,
    sdy = sd(as.numeric(y), na.rm = TRUE))

AddHierarchicalRegressionHoliday(
    state.specification = NULL,
    y,
    holiday.list,
    coefficient.mean.prior = NULL,
    coefficient.variance.prior = NULL,
    time0 = NULL,
    sdy = sd(as.numeric(y), na.rm = TRUE))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="regression.holiday_+3A_state.specification">state.specification</code></td>
<td>
<p>A list of state components that you wish to add to.  If
omitted, an empty list will be assumed.  </p>
</td></tr>
<tr><td><code id="regression.holiday_+3A_holiday.list">holiday.list</code></td>
<td>
<p>A list of objects of type <code><a href="#topic+Holiday">Holiday</a></code>.
The width of the influence window should be the same number of days
for all the holidays in this list.  If the data contains many
instances of holidays with different window widths, then multiple
instances HierarchicalRegressionHolidayModel can be used as long as
all holidays in the same state component model have the same sized
window width.</p>
</td></tr>
<tr><td><code id="regression.holiday_+3A_y">y</code></td>
<td>
<p>The time series to be modeled, as a numeric vector
convertible to <code><a href="xts.html#topic+xts">xts</a></code>.  This state model assumes <code>y</code>
contains daily data.</p>
</td></tr>
<tr><td><code id="regression.holiday_+3A_prior">prior</code></td>
<td>
<p>An object of class <code><a href="Boom.html#topic+NormalPrior">NormalPrior</a></code>
describing the expected variation among daily holiday effects.</p>
</td></tr>
<tr><td><code id="regression.holiday_+3A_coefficient.mean.prior">coefficient.mean.prior</code></td>
<td>
<p>An object of type
<code><a href="Boom.html#topic+MvnPrior">MvnPrior</a></code> giving the hyperprior for the average
effect of a holiday in each day of the influence window.</p>
</td></tr>
<tr><td><code id="regression.holiday_+3A_coefficient.variance.prior">coefficient.variance.prior</code></td>
<td>
<p>An object of type
<code><a href="Boom.html#topic+InverseWishartPrior">InverseWishartPrior</a></code> describing the prior belief
about the variation in holiday effects from one holiday to the
next.</p>
</td></tr>
<tr><td><code id="regression.holiday_+3A_time0">time0</code></td>
<td>
<p>An object convertible to <code><a href="base.html#topic+Date">Date</a></code> containing
the date of the initial observation in the training data.  If
omitted and <code>y</code> is a <code><a href="zoo.html#topic+zoo">zoo</a></code> or
<code><a href="xts.html#topic+xts">xts</a></code> object, then <code>time0</code> will be obtained
from the index of <code>y[1]</code>.</p>
</td></tr>
<tr><td><code id="regression.holiday_+3A_sdy">sdy</code></td>
<td>
<p>The standard deviation of the series to be modeled.  This
will be ignored if <code>y</code> is provided, or if all the required
prior distributions are supplied directly.  </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The model assumes that
</p>
<p style="text-align: center;"><code class="reqn">
    y_t  = \beta_{d(t)} + \epsilon_t %
  </code>
</p>

<p>The regression state model assumes vector of regression coefficients
<code class="reqn">\beta</code> contains elements <code class="reqn">\beta_d \sim N(0,
    \sigma)</code>.
</p>
<p>The HierarchicalRegressionHolidayModel assumes <code class="reqn">\beta</code> is
composed of holiday-specific sub-vectors
<code class="reqn">\beta_h \sim N(b_0, V)</code>, where each
<code class="reqn">\beta_h</code> contains coefficients describing the days in
the influence window of holiday h.  The hierarchical version of the
model treats <code class="reqn">b_0</code> and <code class="reqn">V</code> as parameters to be learned,
with prior distributions
</p>
<p style="text-align: center;"><code class="reqn">b_0 \sim N(\bar b, \Omega)</code>
</p>
<p> and
</p>
<p style="text-align: center;"><code class="reqn">V \sim IW(\nu, S)</code>
</p>

<p>where <code class="reqn">IW</code> represents the inverse Wishart distribution.
</p>


<h3>Value</h3>

<p> Returns a list with the elements necessary to specify a local
linear trend state model.</p>


<h3>Author(s)</h3>

<p>Steven L. Scott <a href="mailto:steve.the.bayesian@gmail.com">steve.the.bayesian@gmail.com</a>
</p>


<h3>References</h3>

<p>Harvey (1990), &quot;Forecasting, structural time series, and the Kalman
filter&quot;, Cambridge University Press.
</p>
<p>Durbin and Koopman (2001), &quot;Time series analysis by state space
methods&quot;, Oxford University Press.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bsts">bsts</a></code>.
<code><a href="#topic+RandomWalkHolidayStateModel">RandomWalkHolidayStateModel</a></code>.
<code><a href="Boom.html#topic+SdPrior">SdPrior</a></code>
<code><a href="Boom.html#topic+NormalPrior">NormalPrior</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>trend &lt;- cumsum(rnorm(730, 0, .1))
  dates &lt;- seq.Date(from = as.Date("2014-01-01"), length = length(trend), by = "day")
  y &lt;- zoo(trend + rnorm(length(trend), 0, .2), dates)

AddHolidayEffect &lt;- function(y, dates, effect) {
  ## Adds a holiday effect to simulated data.
  ## Args:
  ##   y: A zoo time series, with Dates for indices.
  ##   dates: The dates of the holidays.
  ##   effect: A vector of holiday effects of odd length.  The central effect is
  ##     the main holiday, with a symmetric influence window on either side.
  ## Returns:
  ##   y, with the holiday effects added.
  time &lt;- dates - (length(effect) - 1) / 2
  for (i in 1:length(effect)) {
    y[time] &lt;- y[time] + effect[i]
    time &lt;- time + 1
  }
  return(y)
}

## Define some holidays.
memorial.day &lt;- NamedHoliday("MemorialDay")
memorial.day.effect &lt;- c(.3, 3, .5)
memorial.day.dates &lt;- as.Date(c("2014-05-26", "2015-05-25"))
y &lt;- AddHolidayEffect(y, memorial.day.dates, memorial.day.effect)

presidents.day &lt;- NamedHoliday("PresidentsDay")
presidents.day.effect &lt;- c(.5, 2, .25)
presidents.day.dates &lt;- as.Date(c("2014-02-17", "2015-02-16"))
y &lt;- AddHolidayEffect(y, presidents.day.dates, presidents.day.effect)

labor.day &lt;- NamedHoliday("LaborDay")
labor.day.effect &lt;- c(1, 2, 1)
labor.day.dates &lt;- as.Date(c("2014-09-01", "2015-09-07"))
y &lt;- AddHolidayEffect(y, labor.day.dates, labor.day.effect)

## The holidays can be in any order.
holiday.list &lt;- list(memorial.day, labor.day, presidents.day)

## In a real example you'd want more than 100 MCMC iterations.
niter &lt;- 100

## Fit the model
ss &lt;- AddLocalLevel(list(), y)
ss &lt;- AddRegressionHoliday(ss, y, holiday.list = holiday.list)
model &lt;- bsts(y, state.specification = ss, niter = niter)

## Plot all model state components.
plot(model, "comp")

## Plot the specific holiday state component.
plot(ss[[2]], model)

## Try again with some shrinkage.  With only 3 holidays there won't be much
## shrinkage.  
ss2 &lt;- AddLocalLevel(list(), y)

## Plot the specific holiday state component.
ss2 &lt;- AddHierarchicalRegressionHoliday(ss2, y, holiday.list = holiday.list)
model2 &lt;- bsts(y, state.specification = ss2, niter = niter)

plot(model2, "comp")
plot(ss2[[2]], model2)
</code></pre>

<hr>
<h2 id='regularize.timestamps'>Produce a Regular Series of Time Stamps</h2><span id='topic+RegularizeTimestamps'></span><span id='topic+RegularizeTimestamps.default'></span><span id='topic+RegularizeTimestamps.numeric'></span><span id='topic+RegularizeTimestamps.Date'></span><span id='topic+RegularizeTimestamps.POSIXt'></span>

<h3>Description</h3>

<p>Given an set of timestamps that might contain duplicates and gaps,
produce a set of timestamps that has no duplicates and no gaps.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  RegularizeTimestamps(timestamps)

  ## Default S3 method:
RegularizeTimestamps(timestamps)

  ## S3 method for class 'numeric'
RegularizeTimestamps(timestamps)

  ## S3 method for class 'Date'
RegularizeTimestamps(timestamps)

  ## S3 method for class 'POSIXt'
RegularizeTimestamps(timestamps)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="regularize.timestamps_+3A_timestamps">timestamps</code></td>
<td>
<p>A set of (possibly irregular or non-unique)
timestamps.  This could be a set of integers (like 1, 2, , 3...), a
set of numeric like (1945, 1945.083, 1945.167, ...) indicating years
and fractions of years, a <code><a href="base.html#topic+Date">Date</a></code> object, or a
<code><a href="base.html#topic+POSIXt">POSIXt</a></code> object.</p>
</td></tr></table>
<p>  If the argument is <code>NULL</code> a
<code>NULL</code> will be returned.</p>


<h3>Value</h3>

<p>A set of regularly spaced timestamps of the same class as the argument
(which might be <code>NULL</code>).
</p>


<h3>Author(s)</h3>

<p>Steven L. Scott <a href="mailto:steve.the.bayesian@gmail.com">steve.the.bayesian@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  first &lt;- as.POSIXct("2015-04-19 08:00:04")
  monthly &lt;- seq(from = first, length.out = 24, by = "month")
  skip.one &lt;- monthly[-8]
  has.duplicates &lt;- monthly
  has.duplicates[2] &lt;- has.duplicates[3]

  reg1 &lt;- RegularizeTimestamps(skip.one)
  all.equal(reg1, monthly) ## TRUE

  reg2 &lt;- RegularizeTimestamps(has.duplicates)
  all.equal(reg2, monthly)  ## TRUE

</code></pre>

<hr>
<h2 id='residuals.bsts'>Residuals from a bsts Object</h2><span id='topic+residuals.bsts'></span>

<h3>Description</h3>

<p>Residuals (or posterior distribution of residuals) from a
bsts object.</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'bsts'
residuals(object,
    burn = SuggestBurn(.1, object),
    mean.only = FALSE,
    ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="residuals.bsts_+3A_object">object</code></td>
<td>
<p>An object of class <code><a href="#topic+bsts">bsts</a></code> created by the function
of the same name.</p>
</td></tr>
<tr><td><code id="residuals.bsts_+3A_burn">burn</code></td>
<td>
<p>The number of MCMC iterations to discard as burn-in.</p>
</td></tr>
<tr><td><code id="residuals.bsts_+3A_mean.only">mean.only</code></td>
<td>
<p>Logical.  If <code>TRUE</code> then the mean residual for
each time period is returned.  If <code>FALSE</code> then the full
posterior distribution is returned.</p>
</td></tr>
<tr><td><code id="residuals.bsts_+3A_...">...</code></td>
<td>
<p>Not used.  This argument is here to comply with the
signature of the generic residuals function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>mean.only</code> is <code>TRUE</code> then this function returns a vector
of residuals with the same &quot;time stamp&quot; as the original series.  If
<code>mean.only</code> is <code>FALSE</code> then the posterior distribution of
the residuals is returned instead, as a matrix of draws.  Each row of
the matrix is an MCMC draw, and each column is a time point.  The
colnames of the returned matrix will be the timestamps of the original
series, as text.  </p>


<h3>See Also</h3>

<p><code><a href="#topic+bsts">bsts</a></code>, <code><a href="#topic+plot.bsts">plot.bsts</a></code>.
</p>

<hr>
<h2 id='rsxfs'>Retail sales, excluding food services</h2><span id='topic+rsxfs'></span><span id='topic+RSXFS'></span><span id='topic+retail.sales'></span>

<h3>Description</h3>

<p>A monthly time series of retail sales in the US, excluding
food services.  In millions of dollars.  Seasonally adjusted.</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(rsxfs)
</code></pre>


<h3>Format</h3>

<p>zoo time series</p>


<h3>Source</h3>

<p>FRED.  See http://research.stlouisfed.org/fred2/series/RSXFS</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(rsxfs)
plot(rsxfs)
</code></pre>

<hr>
<h2 id='shark'>Shark Attacks in Florida.</h2><span id='topic+shark'></span>

<h3>Description</h3>

<p>An annual time series of shark attacks and fatalities in Florida.</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(shark)
</code></pre>


<h3>Format</h3>

<p>zoo time series</p>


<h3>Source</h3>

<p>From Jeffrey Simonoff &quot;Analysis of Categorical Data&quot;.
http://people.stern.nyu.edu/jsimonof/AnalCatData/Data/Comma_separated/floridashark.csv</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(shark)
head(shark)
</code></pre>

<hr>
<h2 id='shorten'>
Shorten long names
</h2><span id='topic+Shorten'></span>

<h3>Description</h3>

<p>Removes common prefixes and suffixes from character vectors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  Shorten(words)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="shorten_+3A_words">words</code></td>
<td>
<p>A character vector to be shortened.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The argument <code>words</code> is returned, after common prefixes and
suffixes have been removed.  If all arguments are identical then no
shortening is done.
</p>


<h3>Author(s)</h3>

<p>Steven L. Scott <a href="mailto:steve.the.bayesian@gmail.com">steve.the.bayesian@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bsts.mixed">bsts.mixed</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  Shorten(c("/usr/common/foo.tex", "/usr/common/barbarian.tex"))
  # returns c("foo", "barbarian")

  Shorten(c("hello", "hellobye"))
  # returns c("", "bye")

  Shorten(c("hello", "hello"))
  # returns c("hello", "hello")

  Shorten(c("", "x", "xx"))
  # returns c("", "x", "xx")

  Shorten("abcde")
  # returns "abcde"
</code></pre>

<hr>
<h2 id='simulate.fake.mixed.frequency.data'>Simulate fake mixed frequency data</h2><span id='topic+SimulateFakeMixedFrequencyData'></span>

<h3>Description</h3>

<p>Simulate a fake data set that can be used to test mixed frequency code.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SimulateFakeMixedFrequencyData(nweeks,
                               xdim,
                               number.nonzero = xdim,
                               start.date = as.Date("2009-01-03"),
                               sigma.obs = 1.0,
                               sigma.slope = .5,
                               sigma.level = .5,
                               beta.sd = 10)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simulate.fake.mixed.frequency.data_+3A_nweeks">nweeks</code></td>
<td>
<p>The number of weeks of data to simulate.</p>
</td></tr>
<tr><td><code id="simulate.fake.mixed.frequency.data_+3A_xdim">xdim</code></td>
<td>
<p>The dimension of the predictor variables to be simulated.</p>
</td></tr>
<tr><td><code id="simulate.fake.mixed.frequency.data_+3A_number.nonzero">number.nonzero</code></td>
<td>
<p>The number nonzero coefficients.  Must be
less than or equal to <code>xdim</code>.</p>
</td></tr>
<tr><td><code id="simulate.fake.mixed.frequency.data_+3A_start.date">start.date</code></td>
<td>
<p>The date of the first simulated week.</p>
</td></tr>
<tr><td><code id="simulate.fake.mixed.frequency.data_+3A_sigma.obs">sigma.obs</code></td>
<td>
<p>The residual standard deviation for the fine time
scale model.</p>
</td></tr>
<tr><td><code id="simulate.fake.mixed.frequency.data_+3A_sigma.slope">sigma.slope</code></td>
<td>
<p>The standard deviation of the slope component of
the local linear trend model for the fine time scale data.</p>
</td></tr>
<tr><td><code id="simulate.fake.mixed.frequency.data_+3A_sigma.level">sigma.level</code></td>
<td>
<p>The standard deviation of the level component fo
the local linear trend model for the fine time scale data.</p>
</td></tr>
<tr><td><code id="simulate.fake.mixed.frequency.data_+3A_beta.sd">beta.sd</code></td>
<td>
<p>The standard deviation of the regression coefficients
to be simulated.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The simulation begins by simulating a local linear trend model for
<code>nweeks</code> to get the trend component.
</p>
<p>Next a <code>nweeks</code> by <code>xdim</code> matrix of predictor variables is
simulated as IID normal(0, 1) deviates, and a <code>xdim</code>-vector of
regression coefficients is simulated as IID normal(0, <code>beta.sd</code>).
The product of the predictor matrix and regression coefficients is
added to the output of the local linear trend model to get
<code>fine.target</code>.
</p>
<p>Finally, <code>fine.target</code> is aggregated to the month level to get
<code>coarse.target</code>.
</p>


<h3>Value</h3>

<p>Returns a list with the following components
</p>
<table>
<tr><td><code>coarse.target</code></td>
<td>
<p>A <code><a href="zoo.html#topic+zoo">zoo</a></code> time series containing the
monthly values to be modeled.</p>
</td></tr>
<tr><td><code>fine.target</code></td>
<td>
<p>A <code><a href="zoo.html#topic+zoo">zoo</a></code> time series containing the
weekly observations that aggregate to <code>coarse.target</code>. </p>
</td></tr>
<tr><td><code>predictors</code></td>
<td>
<p>A <code><a href="zoo.html#topic+zoo">zoo</a></code> matrix corresponding to
<code>fine.target</code> containing the set of predictors variables to use
in <code><a href="#topic+bsts.mixed">bsts.mixed</a></code> prediction.</p>
</td></tr>
<tr><td><code>true.beta</code></td>
<td>
<p>The vector of &quot;true&quot; regression coefficients used to
simulate <code>fine.target</code>.</p>
</td></tr>
<tr><td><code>true.sigma.obs</code></td>
<td>
<p>The residual standard deviation that was used to
simulate <code>fine.target</code>.</p>
</td></tr>
<tr><td><code>true.sigma.slope</code></td>
<td>
<p>The value of <code>sigma.slope</code> used to
simulate <code>fine.target</code>.</p>
</td></tr>
<tr><td><code>true.sigma.level</code></td>
<td>
<p>The value of <code>sigma.level</code> use to
simulate <code>fine.target</code>.</p>
</td></tr>
<tr><td><code>true.trend</code></td>
<td>
<p>The combined contribution of the simulated latent
state on <code>fine.target</code>, including regression effects.</p>
</td></tr>
<tr><td><code>true.state</code></td>
<td>
<p>A matrix containin the fine-scale state of the model
being simulated.  Columns represent time (weeks).  Rows correspond
to regression (a constant 1), the local linear trend level, the
local linear trend slope, the values of <code>fine.target</code>, and the
weekly partial aggregates of <code>coarse.target</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Steven L. Scott <a href="mailto:steve.the.bayesian@gmail.com">steve.the.bayesian@gmail.com</a>
</p>


<h3>References</h3>

<p>Harvey (1990), &quot;Forecasting, structural time series, and the Kalman
filter&quot;, Cambridge University Press.
</p>
<p>Durbin and Koopman (2001), &quot;Time series analysis by state space
methods&quot;, Oxford University Press.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bsts.mixed">bsts.mixed</a></code>,
<code><a href="#topic+AddLocalLinearTrend">AddLocalLinearTrend</a></code>,
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  fake.data &lt;- SimulateFakeMixedFrequencyData(nweeks = 100, xdim = 10)
  plot(fake.data$coarse.target)
</code></pre>

<hr>
<h2 id='spike.slab.ar.prior'>
Spike and Slab Priors for AR Processes
</h2><span id='topic+SpikeSlabArPrior'></span>

<h3>Description</h3>

<p> Returns a spike and slab prior for the parameters of an
AR(p) process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SpikeSlabArPrior(
    lags,
    prior.inclusion.probabilities =
        GeometricSequence( lags, initial.value = .8, discount.factor = .8),
    prior.mean = rep(0, lags),
    prior.sd =
        GeometricSequence(lags, initial.value = .5, discount.factor = .8),
    sdy,
    prior.df = 1,
    expected.r2 = .5,
    sigma.upper.limit = Inf,
    truncate = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spike.slab.ar.prior_+3A_lags">lags</code></td>
<td>
<p>A positive integer giving the maximum number of lags to
consider.</p>
</td></tr>
<tr><td><code id="spike.slab.ar.prior_+3A_prior.inclusion.probabilities">prior.inclusion.probabilities</code></td>
<td>
<p> A vector of length <code>lags</code>
giving the prior probability that the corresponding AR coefficient
is nonzero.  </p>
</td></tr>
<tr><td><code id="spike.slab.ar.prior_+3A_prior.mean">prior.mean</code></td>
<td>
<p>A vector of length <code>lags</code> giving the prior mean
of the AR coefficients.  This should almost surely stay set at zero.
</p>
</td></tr>
<tr><td><code id="spike.slab.ar.prior_+3A_prior.sd">prior.sd</code></td>
<td>
<p>A vector of length <code>lags</code> giving the prior
standard deviations of the AR coefficients, which are modeled as
a-priori independent of one another.</p>
</td></tr>
<tr><td><code id="spike.slab.ar.prior_+3A_sdy">sdy</code></td>
<td>
<p>The sample standard deviation of the series being modeled.</p>
</td></tr>
<tr><td><code id="spike.slab.ar.prior_+3A_expected.r2">expected.r2</code></td>
<td>
<p>The expected fraction of variation in the response
explained by this AR proces.</p>
</td></tr>
<tr><td><code id="spike.slab.ar.prior_+3A_prior.df">prior.df</code></td>
<td>
<p>A positive number indicating the number of
observations (time points) worth of weight to assign to the guess at
<code>expected.r2</code>.</p>
</td></tr>
<tr><td><code id="spike.slab.ar.prior_+3A_sigma.upper.limit">sigma.upper.limit</code></td>
<td>
<p>A positive number less than infinity
truncates the support of the prior distribution to regions where the
residual standard deviation is less than the specified limit.  Any
other value indicates support over the entire positive real line.</p>
</td></tr>
<tr><td><code id="spike.slab.ar.prior_+3A_truncate">truncate</code></td>
<td>
<p>If <code>TRUE</code> then the support of the distribution is
truncated to the region where the AR coefficients imply a stationary
process.  If <code>FALSE</code> the coefficients are unconstrained.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of class <code>SpikeSlabArPrior</code> containing the information
needed for the underlying C++ code to instantiate this prior.
</p>


<h3>Author(s)</h3>

<p>Steven L. Scott <a href="mailto:steve.the.bayesian@gmail.com">steve.the.bayesian@gmail.com</a>
</p>

<hr>
<h2 id='state.sizes'>
Compute state dimensions
</h2><span id='topic+StateSizes'></span>

<h3>Description</h3>

<p> Returns a vector containing the size of each state
component (i.e. the state dimension) in the state vector.  </p>


<h3>Usage</h3>

<pre><code class='language-R'>  StateSizes(state.specification)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="state.sizes_+3A_state.specification">state.specification</code></td>
<td>
<p>A list containing state specification
components, such as would be passed to <code><a href="#topic+bsts">bsts</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector giving the dimension of each state component.
</p>


<h3>Author(s)</h3>

<p>Steven L. Scott <a href="mailto:steve.the.bayesian@gmail.com">steve.the.bayesian@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    y &lt;- rnorm(1000)
    state.specification &lt;- AddLocalLinearTrend(list(), y)
    state.specification &lt;- AddSeasonal(state.specification, y, 7)
    StateSizes(state.specification)
</code></pre>

<hr>
<h2 id='StateSpecification'>
Add a state component to a Bayesian structural time series model
</h2><span id='topic+state.specification'></span><span id='topic+StateSpecification'></span>

<h3>Description</h3>

<p>Add a state component to the <code>state.specification</code> argument in a
<code><a href="#topic+bsts">bsts</a></code> model.
</p>


<h3>Author(s)</h3>

<p>Steven L. Scott <a href="mailto:steve.the.bayesian@gmail.com">steve.the.bayesian@gmail.com</a>
</p>


<h3>References</h3>

<p>Harvey (1990), &quot;Forecasting, structural time series, and the Kalman
filter&quot;, Cambridge University Press.
</p>
<p>Durbin and Koopman (2001), &quot;Time series analysis by state space
methods&quot;, Oxford University Press.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bsts">bsts</a></code>.
<code><a href="Boom.html#topic+SdPrior">SdPrior</a></code>
<code><a href="Boom.html#topic+NormalPrior">NormalPrior</a></code>
<code><a href="Boom.html#topic+Ar1CoefficientPrior">Ar1CoefficientPrior</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  data(AirPassengers)
  y &lt;- log(AirPassengers)
  ss &lt;- AddLocalLinearTrend(list(), y)
  ss &lt;- AddSeasonal(ss, y, nseasons = 12)
  model &lt;- bsts(y, state.specification = ss, niter = 500)
  pred &lt;- predict(model, horizon = 12, burn = 100)
  plot(pred)
</code></pre>

<hr>
<h2 id='SuggestBurn'>Suggested burn-in size</h2><span id='topic+SuggestBurn'></span>

<h3>Description</h3>

<p>Suggest the size of an MCMC burn in sample as a proportion
of the total run.</p>


<h3>Usage</h3>

<pre><code class='language-R'>SuggestBurn(proportion, bsts.object)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SuggestBurn_+3A_proportion">proportion</code></td>
<td>
<p>The proportion of the MCMC run to discard as burn in.</p>
</td></tr>
<tr><td><code id="SuggestBurn_+3A_bsts.object">bsts.object</code></td>
<td>
<p>An object of class <code><a href="#topic+bsts">bsts</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An integer number of iterations to discard.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bsts">bsts</a></code>
</p>

<hr>
<h2 id='summary.bsts'>Summarize a Bayesian structural time series object</h2><span id='topic+summary.bsts'></span>

<h3>Description</h3>

<p>Print a summary of a <code><a href="#topic+bsts">bsts</a></code> object.</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'bsts'
summary(object, burn = SuggestBurn(.1, object), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.bsts_+3A_object">object</code></td>
<td>
<p>An object of class <code><a href="#topic+bsts">bsts</a></code> created by the function
of the same name.</p>
</td></tr>
<tr><td><code id="summary.bsts_+3A_burn">burn</code></td>
<td>
<p>The number of MCMC iterations to discard as burn-in.</p>
</td></tr>
<tr><td><code id="summary.bsts_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to
<code><a href="BoomSpikeSlab.html#topic+summary.lm.spike">summary.lm.spike</a></code> if <code>object</code> has a regression component.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list with the following elements.
</p>
<table>
<tr><td><code>residual.sd</code></td>
<td>
<p>The posterior mean of the residual standard
deviation parameter.</p>
</td></tr>
<tr><td><code>prediction.sd</code></td>
<td>
<p>The standard deviation of the one-step-ahead
prediction errors for the training data.</p>
</td></tr>
<tr><td><code>rsquare</code></td>
<td>
<p>Proportion by which the residual variance is less
than the variance of the original observations.</p>
</td></tr>
<tr><td><code>relative.gof</code></td>
<td>
<p>Harvey's goodness of fit statistic.  Let
<code class="reqn">\nu</code> denote the one step ahead prediction errors,
<code class="reqn">n</code> denote the length of the series, and <code class="reqn">y</code> denote
the original series.  The goodness of fit statistic is </p>
<p style="text-align: center;"><code class="reqn"> 1 -
       \sum_{i = 1}^n \nu_i^2 / \sum_{i = 2}{n} (\Delta y_i- \Delta \bar
       y)^2.</code>
</p>

<p>This statistic is analogous to <code class="reqn">R^2</code> in a regression
model, but the reduction in sum of squared errors is relative to a
random walk with a constant drift, </p>
<p style="text-align: center;"><code class="reqn">y_{t+1} = y_t + \beta +
     \epsilon_t,</code>
</p>
<p> which Harvey
(1989, equation 5.5.14) argues is a more relevant baseline than a
simple mean.  Unlike a traditional R-square statistic, this can be
negative.</p>
</td></tr>
<tr><td><code>size</code></td>
<td>
<p>Distribution of the number of nonzero coefficients
appearing in the model</p>
</td></tr>
<tr><td><code>coefficients</code></td>
<td>
<p>If <code>object</code> contains a regression component then the
output contains matrix with rows corresponding to coefficients, and
columns corresponding to:
</p>

<ul>
<li><p> The posterior probability the variable is included.
</p>
</li>
<li><p> The posterior probability that the variable is positive.
</p>
</li>
<li><p> The conditional expectation of the coefficient, given inclusion.
</p>
</li>
<li><p> The conditional standard deviation of the coefficient, given inclusion.
</p>
</li></ul>

</td></tr>
</table>


<h3>References</h3>

<p>Harvey's goodness of fit statistic is from Harvey (1989)
<em>Forecasting, structural time series models, and the Kalman filter.</em>
Page 268.</p>


<h3>See Also</h3>

<p><code><a href="#topic+bsts">bsts</a></code>, <code><a href="#topic+plot.bsts">plot.bsts</a></code>, <code><a href="BoomSpikeSlab.html#topic+summary.lm.spike">summary.lm.spike</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  data(AirPassengers)
  y &lt;- log(AirPassengers)
  ss &lt;- AddLocalLinearTrend(list(), y)
  ss &lt;- AddSeasonal(ss, y, nseasons = 12)
  model &lt;- bsts(y, state.specification = ss, niter = 100)
  summary(model, burn  = 20)
</code></pre>

<hr>
<h2 id='to.posixt'>Convert to POSIXt</h2><span id='topic+YearMonToPOSIX'></span><span id='topic+DateToPOSIX'></span>

<h3>Description</h3>

<p>Convert an object of class Date to class POSIXct without getting bogged
down in timezone calculation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  DateToPOSIX(timestamps)
  YearMonToPOSIX(timestamps)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="to.posixt_+3A_timestamps">timestamps</code></td>
<td>
<p>An object of class <code><a href="zoo.html#topic+yearmon">yearmon</a></code> or
<code><a href="base.html#topic+Date">Date</a></code> to be converted to POSIXct.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Calling <code><a href="base.html#topic+as.POSIXct">as.POSIXct</a></code> on another date/time object
(e.g. Date) applies a timezone correction to the object.  This can
shift the time marker by a few hours, which can have the effect of
shifting the day by one unit.  If the day was the first or last in a
month or year, then the month or year will be off by one as well.
</p>
<p>Coercing the object to the character representation of a Date prevents this
adjustment from being applied, and leaves the POSIXt return value with the
intended day, month, and year.
</p>


<h3>Author(s)</h3>

<p>Steven L. Scott  <a href="mailto:steve.the.bayesian@gmail.com">steve.the.bayesian@gmail.com</a>
</p>

<hr>
<h2 id='turkish'>Turkish Electricity Usage</h2><span id='topic+turkish'></span>

<h3>Description</h3>

<p>A daily time series of electricity usaage in Turkey.  </p>


<h3>Usage</h3>

<pre><code class='language-R'>data(turkish)
</code></pre>


<h3>Format</h3>

<p>zoo time series</p>


<h3>Source</h3>

<p>https://robjhyndman.com/data/turkey_elec.csv
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bsts">bsts</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(turkish)
plot(turkish)
</code></pre>

<hr>
<h2 id='week.ends'>
Check to see if a week contains the end of a month or quarter
</h2><span id='topic+WeekEndsMonth'></span><span id='topic+WeekEndsQuarter'></span>

<h3>Description</h3>

<p>Returns a logical vector indicating whether the given week contains
the end of a month or quarter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  WeekEndsMonth(week.ending)
  WeekEndsQuarter(week.ending)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="week.ends_+3A_week.ending">week.ending</code></td>
<td>
<p>A vector of class <code><a href="base.html#topic+Date">Date</a></code>.  Each entry contains the
date of the last day in a week.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical vector indicating whether the given week contains the
end of a month or a quarter.</p>


<h3>Author(s)</h3>

<p>Steven L. Scott <a href="mailto:steve.the.bayesian@gmail.com">steve.the.bayesian@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bsts.mixed">bsts.mixed</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  week.ending &lt;- as.Date(c("2011-10-01",
                           "2011-10-08",
                           "2011-12-03",
                           "2011-12-31"))
  WeekEndsMonth(week.ending) == c(TRUE, FALSE, TRUE, TRUE)
  WeekEndsQuarter(week.ending) == c(TRUE, FALSE, FALSE, TRUE)
</code></pre>

<hr>
<h2 id='weekday.names'>Days of the Week</h2><span id='topic+weekday.names'></span>

<h3>Description</h3>

<p>A character vector listing the names the days of the week.</p>


<h3>Usage</h3>

<pre><code class='language-R'>weekday.names
</code></pre>


<h3>See Also</h3>

<p><code><a href="base.html#topic+month.name">month.name</a></code>
</p>

<hr>
<h2 id='wide.to.long'>
Convert Between Wide and Long Format
</h2><span id='topic+WideToLong'></span><span id='topic+LongToWide'></span>

<h3>Description</h3>

<p>Convert a multivariate time series between wide and long formats.  In
&quot;wide&quot; format there is one row per time point, with series organzied
by columns.  In &quot;long&quot; format there is one row per observation, with
variables indicating the series and time point to which an observation
belongs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  WideToLong(response, na.rm = TRUE)
  LongToWide(response, series.id, timestamps)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wide.to.long_+3A_response">response</code></td>
<td>
<p>For <code>WideToLong</code> this is a matrix, with rows
representing time and columns representing variables.  This can be a
<code><a href="zoo.html#topic+zoo">zoo</a></code> matrix with timestamps as an index.
</p>
<p>For <code>LongToWide</code>, <code>response</code> is a vector.</p>
</td></tr>
<tr><td><code id="wide.to.long_+3A_na.rm">na.rm</code></td>
<td>
<p>If TRUE then missing values will be omitted from the
returned data frame (their absence denoting missingness).
Otherwise, missing values will be included as NA's.</p>
</td></tr>
<tr><td><code id="wide.to.long_+3A_series.id">series.id</code></td>
<td>
<p>A factor (or variable coercible to factor) of the
same length as <code>response</code>, indicating the series to which each
observation belongs. </p>
</td></tr>
<tr><td><code id="wide.to.long_+3A_timestamps">timestamps</code></td>
<td>
<p>A variable of the same length as <code>response</code>,
indicating the time period to which each observation belongs.</p>
</td></tr>  
</table>


<h3>Value</h3>

<p><code>LongToWide</code> returns a zoo matrix with the time series in wide format.
<code>WideToLong</code> returns a 3-column data frame with columns &quot;time&quot;, &quot;series&quot;, and &quot;values&quot;.
</p>


<h3>Author(s)</h3>

<p>Steven L. Scott <a href="mailto:steve.the.bayesian@gmail.com">steve.the.bayesian@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(gdp)
gdp.wide &lt;- LongToWide(gdp$GDP, gdp$Country, gdp$Time)
gdp.long &lt;- WideToLong(gdp.wide)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
