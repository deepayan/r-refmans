<!DOCTYPE html><html><head><title>Help for package googlesheets4</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {googlesheets4}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#%&gt;%'><p>Pipe operator</p></a></li>
<li><a href='#cell-specification'><p>Specify cells</p></a></li>
<li><a href='#googlesheets4-configuration'><p>googlesheets4 configuration</p></a></li>
<li><a href='#googlesheets4-package'><p>googlesheets4: Access Google Sheets using the Sheets API V4</p></a></li>
<li><a href='#googlesheets4-vctrs'><p>Internal vctrs methods</p></a></li>
<li><a href='#gs4_auth'><p>Authorize googlesheets4</p></a></li>
<li><a href='#gs4_auth_configure'><p>Edit and view auth configuration</p></a></li>
<li><a href='#gs4_browse'><p>Visit a Sheet in a web browser</p></a></li>
<li><a href='#gs4_create'><p>Create a new Sheet</p></a></li>
<li><a href='#gs4_deauth'><p>Suspend authorization</p></a></li>
<li><a href='#gs4_endpoints'><p>List Sheets endpoints</p></a></li>
<li><a href='#gs4_examples'><p>Example Sheets</p></a></li>
<li><a href='#gs4_find'><p>Find Google Sheets</p></a></li>
<li><a href='#gs4_fodder'><p>Create useful spreadsheet filler</p></a></li>
<li><a href='#gs4_formula'><p>Class for Google Sheets formulas</p></a></li>
<li><a href='#gs4_get'><p>Get Sheet metadata</p></a></li>
<li><a href='#gs4_has_token'><p>Is there a token on hand?</p></a></li>
<li><a href='#gs4_oauth_app'><p>Get currently configured OAuth app (deprecated)</p></a></li>
<li><a href='#gs4_random'><p>Generate a random Sheet name</p></a></li>
<li><a href='#gs4_scopes'><p>Produce scopes specific to the Sheets API</p></a></li>
<li><a href='#gs4_token'><p>Produce configured token</p></a></li>
<li><a href='#gs4_user'><p>Get info on current user</p></a></li>
<li><a href='#range_autofit'><p>Auto-fit columns or rows to the data</p></a></li>
<li><a href='#range_delete'><p>Delete cells</p></a></li>
<li><a href='#range_flood'><p>Flood or clear a range of cells</p></a></li>
<li><a href='#range_read'><p>Read a Sheet into a data frame</p></a></li>
<li><a href='#range_read_cells'><p>Read cells from a Sheet</p></a></li>
<li><a href='#range_speedread'><p>Read Sheet as CSV</p></a></li>
<li><a href='#range_write'><p>(Over)write new data into a range</p></a></li>
<li><a href='#request_generate'><p>Generate a Google Sheets API request</p></a></li>
<li><a href='#request_make'><p>Make a Google Sheets API request</p></a></li>
<li><a href='#sheet_add'><p>Add one or more (work)sheets</p></a></li>
<li><a href='#sheet_append'><p>Append rows to a sheet</p></a></li>
<li><a href='#sheet_copy'><p>Copy a (work)sheet</p></a></li>
<li><a href='#sheet_delete'><p>Delete one or more (work)sheets</p></a></li>
<li><a href='#sheet_properties'><p>Get data about (work)sheets</p></a></li>
<li><a href='#sheet_relocate'><p>Relocate one or more (work)sheets</p></a></li>
<li><a href='#sheet_rename'><p>Rename a (work)sheet</p></a></li>
<li><a href='#sheet_resize'><p>Change the size of a (work)sheet</p></a></li>
<li><a href='#sheet_write'><p>(Over)write new data into a Sheet</p></a></li>
<li><a href='#sheets_id'><p><code>sheets_id</code> class</p></a></li>
<li><a href='#spread_sheet'><p>Spread a data frame of cells into spreadsheet shape</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Access Google Sheets using the Sheets API V4</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1.1</td>
</tr>
<tr>
<td>Description:</td>
<td>Interact with Google Sheets through the Sheets API v4
    <a href="https://developers.google.com/sheets/api">https://developers.google.com/sheets/api</a>. "API" is an acronym for
    "application programming interface"; the Sheets API allows users to
    interact with Google Sheets programmatically, instead of via a web
    browser. The "v4" refers to the fact that the Sheets API is currently
    at version 4. This package can read and write both the metadata and
    the cell data in a Sheet.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://googlesheets4.tidyverse.org">https://googlesheets4.tidyverse.org</a>,
<a href="https://github.com/tidyverse/googlesheets4">https://github.com/tidyverse/googlesheets4</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/tidyverse/googlesheets4/issues">https://github.com/tidyverse/googlesheets4/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.6)</td>
</tr>
<tr>
<td>Imports:</td>
<td>cellranger, cli (&ge; 3.0.0), curl, gargle (&ge; 1.5.0), glue (&ge;
1.3.0), googledrive (&ge; 2.1.0), httr, ids, lifecycle, magrittr,
methods, purrr, rematch2, rlang (&ge; 1.0.2), tibble (&ge; 2.1.1),
utils, vctrs (&ge; 0.2.3), withr</td>
</tr>
<tr>
<td>Suggests:</td>
<td>readr, rmarkdown, spelling, testthat (&ge; 3.1.7)</td>
</tr>
<tr>
<td>ByteCompile:</td>
<td>true</td>
</tr>
<tr>
<td>Config/Needs/website:</td>
<td>tidyverse, tidyverse/tidytemplate</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-06-11 01:11:05 UTC; jenny</td>
</tr>
<tr>
<td>Author:</td>
<td>Jennifer Bryan <a href="https://orcid.org/0000-0002-6983-2759"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [cre, aut],
  Posit Software, PBC [cph, fnd]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Jennifer Bryan &lt;jenny@posit.co&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-06-11 04:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='+25+26gt+3B+25'>Pipe operator</h2><span id='topic++25+3E+25'></span>

<h3>Description</h3>

<p>See <code>magrittr::<a href="magrittr.html#topic++25+3E+25">%&gt;%</a></code> for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lhs %&gt;% rhs
</code></pre>

<hr>
<h2 id='cell-specification'>Specify cells</h2><span id='topic+cell-specification'></span><span id='topic+cell_limits'></span><span id='topic+cell_rows'></span><span id='topic+cell_cols'></span><span id='topic+anchored'></span>

<h3>Description</h3>

<p>Many functions in googlesheets4 use a <code>range</code> argument to target specific
cells. The Sheets v4 API expects user-specified ranges to be expressed via
<a href="https://developers.google.com/sheets/api/guides/concepts#a1_notation">its A1 notation</a>,
but googlesheets4 accepts and converts a few alternative specifications
provided by the functions in the <a href="cellranger.html#topic+cellranger">cellranger</a> package. Of course,
you can always provide A1-style ranges directly to functions like
<code><a href="#topic+read_sheet">read_sheet()</a></code> or <code><a href="#topic+range_read_cells">range_read_cells()</a></code>. Why would you use the
<a href="cellranger.html#topic+cellranger">cellranger</a> helpers? Some ranges are practically impossible to
express in A1 notation, specifically when you want to describe rectangles
with some bounds that are specified and others determined by the data.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
ss &lt;- gs4_example("mini-gap")

# Specify only the rows or only the columns
read_sheet(ss, range = cell_rows(1:3))
read_sheet(ss, range = cell_cols("C:D"))
read_sheet(ss, range = cell_cols(1))

# Specify upper or lower bound on row or column
read_sheet(ss, range = cell_rows(c(NA, 4)))
read_sheet(ss, range = cell_cols(c(NA, "D")))
read_sheet(ss, range = cell_rows(c(3, NA)))
read_sheet(ss, range = cell_cols(c(2, NA)))
read_sheet(ss, range = cell_cols(c("C", NA)))

# Specify a partially open rectangle
read_sheet(ss, range = cell_limits(c(2, 3), c(NA, NA)), col_names = FALSE)
read_sheet(ss, range = cell_limits(c(1, 2), c(NA, 4)))

</code></pre>

<hr>
<h2 id='googlesheets4-configuration'>googlesheets4 configuration</h2><span id='topic+googlesheets4-configuration'></span><span id='topic+local_gs4_quiet'></span><span id='topic+with_gs4_quiet'></span>

<h3>Description</h3>

<p>Some aspects of googlesheets4 behaviour can be controlled via an option.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>local_gs4_quiet(env = parent.frame())

with_gs4_quiet(code)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="googlesheets4-configuration_+3A_env">env</code></td>
<td>
<p>The environment to use for scoping</p>
</td></tr>
<tr><td><code id="googlesheets4-configuration_+3A_code">code</code></td>
<td>
<p>Code to execute quietly</p>
</td></tr>
</table>


<h3>Messages</h3>

<p>The <code>googlesheets4_quiet</code> option can be used to suppress messages from
googlesheets4. By default, googlesheets4 always messages, i.e. it is <em>not</em>
quiet.
</p>
<p>Set <code>googlesheets4_quiet</code> to <code>TRUE</code> to suppress messages, by one of these
means, in order of decreasing scope:
</p>

<ul>
<li><p> Put <code>options(googlesheets4_quiet = TRUE)</code> in a start-up file, such as
<code>.Rprofile</code>, or in your R script
</p>
</li>
<li><p> Use <code>local_gs4_quiet()</code> to silence googlesheets4 in a specific scope
</p>
</li>
<li><p> Use <code>with_gs4_quiet()</code> to run a small bit of code silently
</p>
</li></ul>

<p><code>local_gs4_quiet()</code> and <code>with_gs4_quiet()</code> follow the conventions of the
the withr package (<a href="https://withr.r-lib.org">https://withr.r-lib.org</a>).
</p>


<h3>Auth</h3>

<p>Read about googlesheets4's main auth function, <code><a href="#topic+gs4_auth">gs4_auth()</a></code>. It is powered
by the gargle package, which consults several options:
</p>

<ul>
<li><p> Default Google user or, more precisely, <code>email</code>: see
<code><a href="gargle.html#topic+gargle_options">gargle::gargle_oauth_email()</a></code>
</p>
</li>
<li><p> Whether or where to cache OAuth tokens: see
<code><a href="gargle.html#topic+gargle_options">gargle::gargle_oauth_cache()</a></code>
</p>
</li>
<li><p> Whether to prefer &quot;out-of-band&quot; auth: see
<code><a href="gargle.html#topic+gargle_options">gargle::gargle_oob_default()</a></code>
</p>
</li>
<li><p> Application Default Credentials: see <code><a href="gargle.html#topic+credentials_app_default">gargle::credentials_app_default()</a></code>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
# message: "Creating new Sheet ..."
(ss &lt;- gs4_create("gs4-quiet-demo", sheets = "alpha"))

# message: "Editing ..., Writing ..."
range_write(ss, data = data.frame(x = 1, y = "a"))

# suppress messages for a small amount of code
with_gs4_quiet(
  ss %&gt;% sheet_append(data.frame(x = 2, y = "b"))
)

# message: "Writing ..., Appending ..."
ss %&gt;% sheet_append(data.frame(x = 3, y = "c"))

# suppress messages until end of current scope
local_gs4_quiet()
ss %&gt;% sheet_append(data.frame(x = 4, y = "d"))

# see that all the data was, in fact, written
read_sheet(ss)

# clean up
gs4_find("gs4-quiet-demo") %&gt;%
  googledrive::drive_trash()

</code></pre>

<hr>
<h2 id='googlesheets4-package'>googlesheets4: Access Google Sheets using the Sheets API V4</h2><span id='topic+googlesheets4'></span><span id='topic+googlesheets4-package'></span>

<h3>Description</h3>

<p><img src="../help/figures/logo.png" style='float: right' alt='logo' width='120' />
</p>
<p>Interact with Google Sheets through the Sheets API v4 <a href="https://developers.google.com/sheets/api">https://developers.google.com/sheets/api</a>. &quot;API&quot; is an acronym for &quot;application programming interface&quot;; the Sheets API allows users to interact with Google Sheets programmatically, instead of via a web browser. The &quot;v4&quot; refers to the fact that the Sheets API is currently at version 4. This package can read and write both the metadata and the cell data in a Sheet.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Jennifer Bryan <a href="mailto:jenny@posit.co">jenny@posit.co</a> (<a href="https://orcid.org/0000-0002-6983-2759">ORCID</a>)
</p>
<p>Other contributors:
</p>

<ul>
<li><p> Posit Software, PBC [copyright holder, funder]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://googlesheets4.tidyverse.org">https://googlesheets4.tidyverse.org</a>
</p>
</li>
<li> <p><a href="https://github.com/tidyverse/googlesheets4">https://github.com/tidyverse/googlesheets4</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/tidyverse/googlesheets4/issues">https://github.com/tidyverse/googlesheets4/issues</a>
</p>
</li></ul>


<hr>
<h2 id='googlesheets4-vctrs'>Internal vctrs methods</h2><span id='topic+googlesheets4-vctrs'></span><span id='topic+vec_ptype2.googlesheets4_formula'></span><span id='topic+vec_cast.googlesheets4_formula'></span>

<h3>Description</h3>

<p>Internal vctrs methods
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'googlesheets4_formula'
vec_ptype2(x, y, ...)

## S3 method for class 'googlesheets4_formula'
vec_cast(x, to, ...)
</code></pre>

<hr>
<h2 id='gs4_auth'>Authorize googlesheets4</h2><span id='topic+gs4_auth'></span>

<h3>Description</h3>

<p>Authorize googlesheets4 to view and manage your Google Sheets. This function is a
wrapper around <code><a href="gargle.html#topic+token_fetch">gargle::token_fetch()</a></code>.
</p>
<p>By default, you are directed to a web browser, asked to sign in to your
Google account, and to grant googlesheets4 permission to operate on your
behalf with Google Sheets. By default, with your permission, these user
credentials are cached in a folder below your home directory, from where
they can be automatically refreshed, as necessary. Storage at the user
level means the same token can be used across multiple projects and
tokens are less likely to be synced to the cloud by accident.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gs4_auth(
  email = gargle::gargle_oauth_email(),
  path = NULL,
  subject = NULL,
  scopes = "spreadsheets",
  cache = gargle::gargle_oauth_cache(),
  use_oob = gargle::gargle_oob_default(),
  token = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gs4_auth_+3A_email">email</code></td>
<td>
<p>Optional. If specified, <code>email</code> can take several different
forms:
</p>

<ul>
<li> <p><code>"jane@gmail.com"</code>, i.e. an actual email address. This allows the user to
target a specific Google identity. If specified, this is used for token
lookup, i.e. to determine if a suitable token is already available in the
cache. If no such token is found, <code>email</code> is used to pre-select the targeted
Google identity in the OAuth chooser. (Note, however, that the email
associated with a token when it's cached is always determined from the token
itself, never from this argument).
</p>
</li>
<li> <p><code>"*@example.com"</code>, i.e. a domain-only glob pattern. This can be helpful if
you need code that &quot;just works&quot; for both <code>alice@example.com</code> and
<code>bob@example.com</code>.
</p>
</li>
<li> <p><code>TRUE</code> means that you are approving email auto-discovery. If exactly one
matching token is found in the cache, it will be used.
</p>
</li>
<li> <p><code>FALSE</code> or <code>NA</code> mean that you want to ignore the token cache and force a
new OAuth dance in the browser.
</p>
</li></ul>

<p>Defaults to the option named <code>"gargle_oauth_email"</code>, retrieved by
<code><a href="gargle.html#topic+gargle_oauth_email">gargle_oauth_email()</a></code> (unless a wrapper package implements different
default behavior).</p>
</td></tr>
<tr><td><code id="gs4_auth_+3A_path">path</code></td>
<td>
<p>JSON identifying the service account, in one of the forms
supported for the <code>txt</code> argument of <code><a href="jsonlite.html#topic+fromJSON">jsonlite::fromJSON()</a></code> (typically, a
file path or JSON string).</p>
</td></tr>
<tr><td><code id="gs4_auth_+3A_subject">subject</code></td>
<td>
<p>An optional subject claim. Specify this if you wish to use the
service account represented by <code>path</code> to impersonate the <code>subject</code>, who is
a normal user. Before this can work, an administrator must grant the service
account domain-wide authority. Identify the user to impersonate via their
email, e.g. <code>subject = "user@example.com"</code>. Note that gargle automatically
adds the non-sensitive <code>"https://www.googleapis.com/auth/userinfo.email"</code>
scope, so this scope must be enabled for the service account, along with
any other <code>scopes</code> being requested.</p>
</td></tr>
<tr><td><code id="gs4_auth_+3A_scopes">scopes</code></td>
<td>
<p>One or more API scopes. Each scope can be specified in full or,
for Sheets API-specific scopes, in an abbreviated form that is recognized by
<code><a href="#topic+gs4_scopes">gs4_scopes()</a></code>:
</p>

<ul>
<li><p> &quot;spreadsheets&quot; = &quot;https://www.googleapis.com/auth/spreadsheets&quot;
(the default)
</p>
</li>
<li><p> &quot;spreadsheets.readonly&quot; =
&quot;https://www.googleapis.com/auth/spreadsheets.readonly&quot;
</p>
</li>
<li><p> &quot;drive&quot; = &quot;https://www.googleapis.com/auth/drive&quot;
</p>
</li>
<li><p> &quot;drive.readonly&quot; = &quot;https://www.googleapis.com/auth/drive.readonly&quot;
</p>
</li>
<li><p> &quot;drive.file&quot; = &quot;https://www.googleapis.com/auth/drive.file&quot;
</p>
</li></ul>

<p>See
<a href="https://developers.google.com/identity/protocols/oauth2/scopes#sheets">https://developers.google.com/identity/protocols/oauth2/scopes#sheets</a> for
details on the permissions for each scope.</p>
</td></tr>
<tr><td><code id="gs4_auth_+3A_cache">cache</code></td>
<td>
<p>Specifies the OAuth token cache. Defaults to the option named
<code>"gargle_oauth_cache"</code>, retrieved via <code><a href="gargle.html#topic+gargle_oauth_cache">gargle_oauth_cache()</a></code>.</p>
</td></tr>
<tr><td><code id="gs4_auth_+3A_use_oob">use_oob</code></td>
<td>
<p>Whether to use out-of-band authentication (or, perhaps, a
variant implemented by gargle and known as &quot;pseudo-OOB&quot;) when first
acquiring the token. Defaults to the value returned by
<code><a href="gargle.html#topic+gargle_oob_default">gargle_oob_default()</a></code>. Note that (pseudo-)OOB auth only affects
the initial OAuth dance. If we retrieve (and possibly refresh) a
cached token, <code>use_oob</code> has no effect.
</p>
<p>If the OAuth client is provided implicitly by a wrapper package, its type
probably defaults to the value returned by
<code><a href="gargle.html#topic+gargle_oauth_client_type">gargle_oauth_client_type()</a></code>. You can take control of the client
type by setting <code>options(gargle_oauth_client_type = "web")</code> or
<code>options(gargle_oauth_client_type = "installed")</code>.</p>
</td></tr>
<tr><td><code id="gs4_auth_+3A_token">token</code></td>
<td>
<p>A token with class <a href="httr.html#topic+Token-class">Token2.0</a> or an object of
httr's class <code>request</code>, i.e. a token that has been prepared with
<code><a href="httr.html#topic+config">httr::config()</a></code> and has a <a href="httr.html#topic+Token-class">Token2.0</a> in the
<code>auth_token</code> component.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Most users, most of the time, do not need to call <code>gs4_auth()</code>
explicitly &ndash; it is triggered by the first action that requires
authorization. Even when called, the default arguments often suffice.
</p>
<p>However, when necessary, <code>gs4_auth()</code> allows the user to explicitly:
</p>

<ul>
<li><p> Declare which Google identity to use, via an <code>email</code> specification.
</p>
</li>
<li><p> Use a service account token or workload identity federation via
<code>path</code>.
</p>
</li>
<li><p> Bring your own <code>token</code>.
</p>
</li>
<li><p> Customize <code>scopes</code>.
</p>
</li>
<li><p> Use a non-default <code>cache</code> folder or turn caching off.
</p>
</li>
<li><p> Explicitly request out-of-bound (OOB) auth via <code>use_oob</code>.
</p>
</li></ul>

<p>If you are interacting with R within a browser (applies to RStudio
Server, Posit Workbench, Posit Cloud, and Google Colaboratory), you need
OOB auth or the pseudo-OOB variant. If this does not happen
automatically, you can request it explicitly with <code>use_oob = TRUE</code> or,
more persistently, by setting an option via
<code>options(gargle_oob_default = TRUE)</code>.
</p>
<p>The choice between conventional OOB or pseudo-OOB auth is determined
by the type of OAuth client. If the client is of the &quot;installed&quot; type,
<code>use_oob = TRUE</code> results in conventional OOB auth. If the client is of
the &quot;web&quot; type, <code>use_oob = TRUE</code> results in pseudo-OOB auth. Packages
that provide a built-in OAuth client can usually detect which type of
client to use. But if you need to set this explicitly, use the
<code>"gargle_oauth_client_type"</code> option:
</p>
<div class="sourceCode r"><pre>options(gargle_oauth_client_type = "web")       # pseudo-OOB
# or, alternatively
options(gargle_oauth_client_type = "installed") # conventional OOB
</pre></div>
<p>For details on the many ways to find a token, see
<code><a href="gargle.html#topic+token_fetch">gargle::token_fetch()</a></code>. For deeper control over auth, use
<code><a href="#topic+gs4_auth_configure">gs4_auth_configure()</a></code> to bring your own OAuth client or API key.
To learn more about gargle options, see <a href="gargle.html#topic+gargle_options">gargle::gargle_options</a>.
</p>


<h3>See Also</h3>

<p>Other auth functions: 
<code><a href="#topic+gs4_auth_configure">gs4_auth_configure</a>()</code>,
<code><a href="#topic+gs4_deauth">gs4_deauth</a>()</code>,
<code><a href="#topic+gs4_scopes">gs4_scopes</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# load/refresh existing credentials, if available
# otherwise, go to browser for authentication and authorization
gs4_auth()

# indicate the specific identity you want to auth as
gs4_auth(email = "jenny@example.com")

# force a new browser dance, i.e. don't even try to use existing user
# credentials
gs4_auth(email = NA)

# use a 'read only' scope, so it's impossible to edit or delete Sheets
gs4_auth(scopes = "spreadsheets.readonly")

# use a service account token
gs4_auth(path = "foofy-83ee9e7c9c48.json")

</code></pre>

<hr>
<h2 id='gs4_auth_configure'>Edit and view auth configuration</h2><span id='topic+gs4_auth_configure'></span><span id='topic+gs4_api_key'></span><span id='topic+gs4_oauth_client'></span>

<h3>Description</h3>

<p>These functions give more control over and visibility into the auth
configuration than <code><a href="#topic+gs4_auth">gs4_auth()</a></code> does. <code>gs4_auth_configure()</code>
lets the user specify their own:
</p>

<ul>
<li><p> OAuth client, which is used when obtaining a user token.
</p>
</li>
<li><p> API key. If googlesheets4 is de-authorized via <code><a href="#topic+gs4_deauth">gs4_deauth()</a></code>, all
requests are sent with an API key in lieu of a token.
</p>
</li></ul>

<p>See the <code>vignette("get-api-credentials", package = "gargle")</code>
for more.
If the user does not configure these settings, internal defaults
are used.
</p>
<p><code>gs4_oauth_client()</code> and <code>gs4_api_key()</code> retrieve the
currently configured OAuth client and API key, respectively.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gs4_auth_configure(client, path, api_key, app = deprecated())

gs4_api_key()

gs4_oauth_client()
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gs4_auth_configure_+3A_client">client</code></td>
<td>
<p>A Google OAuth client, presumably constructed via
<code><a href="gargle.html#topic+gargle_oauth_client_from_json">gargle::gargle_oauth_client_from_json()</a></code>. Note, however, that it is
preferred to specify the client with JSON, using the <code>path</code> argument.</p>
</td></tr>
<tr><td><code id="gs4_auth_configure_+3A_path">path</code></td>
<td>
<p>JSON downloaded from <a href="https://console.cloud.google.com">Google Cloud Console</a>, containing a client id and
secret, in one of the forms supported for the <code>txt</code> argument of
<code><a href="jsonlite.html#topic+fromJSON">jsonlite::fromJSON()</a></code> (typically, a file path or JSON string).</p>
</td></tr>
<tr><td><code id="gs4_auth_configure_+3A_api_key">api_key</code></td>
<td>
<p>API key.</p>
</td></tr>
<tr><td><code id="gs4_auth_configure_+3A_app">app</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a> Replaced by the <code>client</code>
argument.</p>
</td></tr>
</table>


<h3>Value</h3>


<ul>
<li> <p><code>gs4_auth_configure()</code>: An object of R6 class
<a href="gargle.html#topic+AuthState-class">gargle::AuthState</a>, invisibly.
</p>
</li>
<li> <p><code>gs4_oauth_client()</code>: the current user-configured OAuth client.
</p>
</li>
<li> <p><code>gs4_api_key()</code>: the current user-configured API key.
</p>
</li></ul>



<h3>See Also</h3>

<p>Other auth functions: 
<code><a href="#topic+gs4_auth">gs4_auth</a>()</code>,
<code><a href="#topic+gs4_deauth">gs4_deauth</a>()</code>,
<code><a href="#topic+gs4_scopes">gs4_scopes</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># see and store the current user-configured OAuth client (probably `NULL`)
(original_client &lt;- gs4_oauth_client())

# see and store the current user-configured API key (probably `NULL`)
(original_api_key &lt;- gs4_api_key())

# the preferred way to configure your own client is via a JSON file
# downloaded from Google Developers Console
# this example JSON is indicative, but fake
path_to_json &lt;- system.file(
  "extdata", "client_secret_installed.googleusercontent.com.json",
  package = "gargle"
)
gs4_auth_configure(path = path_to_json)

# this is also obviously a fake API key
gs4_auth_configure(api_key = "the_key_I_got_for_a_google_API")

# confirm the changes
gs4_oauth_client()
gs4_api_key()

# restore original auth config
gs4_auth_configure(client = original_client, api_key = original_api_key)
</code></pre>

<hr>
<h2 id='gs4_browse'>Visit a Sheet in a web browser</h2><span id='topic+gs4_browse'></span>

<h3>Description</h3>

<p>Visits a Google Sheet in your default browser, if session is interactive.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gs4_browse(ss)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gs4_browse_+3A_ss">ss</code></td>
<td>
<p>Something that identifies a Google Sheet:
</p>

<ul>
<li><p> its file id as a string or <code><a href="googledrive.html#topic+drive_id">drive_id</a></code>
</p>
</li>
<li><p> a URL from which we can recover the id
</p>
</li>
<li><p> a one-row <code><a href="googledrive.html#topic+dribble">dribble</a></code>, which is how googledrive
represents Drive files
</p>
</li>
<li><p> an instance of <code>googlesheets4_spreadsheet</code>, which is what <code><a href="#topic+gs4_get">gs4_get()</a></code>
returns
</p>
</li></ul>

<p>Processed through <code><a href="#topic+as_sheets_id">as_sheets_id()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The Sheet's browser URL, invisibly.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>gs4_example("mini-gap") %&gt;% gs4_browse()
</code></pre>

<hr>
<h2 id='gs4_create'>Create a new Sheet</h2><span id='topic+gs4_create'></span>

<h3>Description</h3>

<p>Creates an entirely new (spread)Sheet (or, in Excel-speak, workbook).
Optionally, you can also provide names and/or data for the initial set of
(work)sheets. Any initial data provided via <code>sheets</code> is styled as a table,
as described in <code><a href="#topic+sheet_write">sheet_write()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gs4_create(name = gs4_random(), ..., sheets = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gs4_create_+3A_name">name</code></td>
<td>
<p>The name of the new spreadsheet.</p>
</td></tr>
<tr><td><code id="gs4_create_+3A_...">...</code></td>
<td>
<p>Optional spreadsheet properties that can be set through this API
endpoint, such as locale and time zone.</p>
</td></tr>
<tr><td><code id="gs4_create_+3A_sheets">sheets</code></td>
<td>
<p>Optional input for initializing (work)sheets. If unspecified,
the Sheets API automatically creates an empty &quot;Sheet1&quot;. You can provide a
vector of sheet names, a data frame, or a (possibly named) list of data
frames. See the examples.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The input <code>ss</code>, as an instance of <code><a href="#topic+sheets_id">sheets_id</a></code>
</p>


<h3>See Also</h3>

<p>Wraps the <code>spreadsheets.create</code> endpoint:
</p>

<ul>
<li> <p><a href="https://developers.google.com/sheets/api/reference/rest/v4/spreadsheets/create">https://developers.google.com/sheets/api/reference/rest/v4/spreadsheets/create</a>
</p>
</li></ul>

<p>There is an article on writing Sheets:
</p>

<ul>
<li> <p><a href="https://googlesheets4.tidyverse.org/articles/articles/write-sheets.html">https://googlesheets4.tidyverse.org/articles/articles/write-sheets.html</a>
</p>
</li></ul>

<p>Other write functions: 
<code><a href="#topic+gs4_formula">gs4_formula</a>()</code>,
<code><a href="#topic+range_delete">range_delete</a>()</code>,
<code><a href="#topic+range_flood">range_flood</a>()</code>,
<code><a href="#topic+range_write">range_write</a>()</code>,
<code><a href="#topic+sheet_append">sheet_append</a>()</code>,
<code><a href="#topic+sheet_write">sheet_write</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
gs4_create("gs4-create-demo-1")

gs4_create("gs4-create-demo-2", locale = "en_CA")

gs4_create(
  "gs4-create-demo-3",
  locale = "fr_FR",
  timeZone = "Europe/Paris"
)

gs4_create(
  "gs4-create-demo-4",
  sheets = c("alpha", "beta")
)

my_data &lt;- data.frame(x = 1)
gs4_create(
  "gs4-create-demo-5",
  sheets = my_data
)

gs4_create(
  "gs4-create-demo-6",
  sheets = list(chickwts = head(chickwts), mtcars = head(mtcars))
)

# Clean up
gs4_find("gs4-create-demo") %&gt;%
  googledrive::drive_trash()

</code></pre>

<hr>
<h2 id='gs4_deauth'>Suspend authorization</h2><span id='topic+gs4_deauth'></span>

<h3>Description</h3>

<p>Put googlesheets4 into a de-authorized state. Instead of sending a token,
googlesheets4 will send an API key. This can be used to access public
resources for which no Google sign-in is required. This is handy for using
googlesheets4 in a non-interactive setting to make requests that do not
require a token. It will prevent the attempt to obtain a token
interactively in the browser. The user can configure their own API key
via <code><a href="#topic+gs4_auth_configure">gs4_auth_configure()</a></code> and retrieve that key via
<code><a href="#topic+gs4_api_key">gs4_api_key()</a></code>.
In the absence of a user-configured key, a built-in default key is used.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gs4_deauth()
</code></pre>


<h3>See Also</h3>

<p>Other auth functions: 
<code><a href="#topic+gs4_auth_configure">gs4_auth_configure</a>()</code>,
<code><a href="#topic+gs4_auth">gs4_auth</a>()</code>,
<code><a href="#topic+gs4_scopes">gs4_scopes</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
gs4_deauth()
gs4_user()

# get metadata on the public 'deaths' spreadsheet
gs4_example("deaths") %&gt;%
  gs4_get()

</code></pre>

<hr>
<h2 id='gs4_endpoints'>List Sheets endpoints</h2><span id='topic+gs4_endpoints'></span>

<h3>Description</h3>

<p>Returns a list of selected Sheets API v4 endpoints, as stored inside the
googlesheets4 package. The names of this list (or the <code>id</code> sub-elements) are
the nicknames that can be used to specify an endpoint in
<code><a href="#topic+request_generate">request_generate()</a></code>. For each endpoint, we store its nickname or <code>id</code>, the
associated HTTP <code>method</code>, the <code>path</code>, and details about the parameters. This
list is derived programmatically from the Sheets API v4 Discovery
Document (<code style="white-space: pre;">&#8288;https://www.googleapis.com/discovery/v1/apis/sheets/v4/rest&#8288;</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gs4_endpoints(i = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gs4_endpoints_+3A_i">i</code></td>
<td>
<p>The name(s) or integer index(ices) of the endpoints to return.
Optional. By default, the entire list is returned.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing some or all of the subset of the Sheets API v4
endpoints that are used internally by googlesheets4.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>str(gs4_endpoints(), max.level = 2)
gs4_endpoints("sheets.spreadsheets.values.get")
gs4_endpoints(4)
</code></pre>

<hr>
<h2 id='gs4_examples'>Example Sheets</h2><span id='topic+gs4_examples'></span><span id='topic+gs4_example'></span>

<h3>Description</h3>

<p>googlesheets4 makes a variety of world-readable example Sheets available for
use in documentation and reprexes. These functions help you access the
example Sheets. See <code>vignette("example-sheets", package = "googlesheets4")</code>
for more.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gs4_examples(matches)

gs4_example(matches)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gs4_examples_+3A_matches">matches</code></td>
<td>
<p>A regular expression that matches the name of the desired
example Sheet(s). <code>matches</code> is optional for the plural <code>gs4_examples()</code>
and, if provided, it can match multiple Sheets. The singular
<code>gs4_example()</code> requires <code>matches</code> and it must match exactly one Sheet.</p>
</td></tr>
</table>


<h3>Value</h3>


<ul>
<li> <p><code>gs4_example()</code>: a <a href="#topic+sheets_id">sheets_id</a>
</p>
</li>
<li> <p><code>gs4_examples()</code>: a named vector of all built-in examples, with class
<code><a href="googledrive.html#topic+drive_id">drive_id</a></code>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
gs4_examples()
gs4_examples("gap")

gs4_example("gapminder")
gs4_example("deaths")

</code></pre>

<hr>
<h2 id='gs4_find'>Find Google Sheets</h2><span id='topic+gs4_find'></span>

<h3>Description</h3>

<p>Finds your Google Sheets. This is a very thin wrapper around
<code><a href="googledrive.html#topic+drive_find">googledrive::drive_find()</a></code>, that specifies you want to list Drive files
where <code>type = "spreadsheet"</code>. Therefore, note that this will require auth for
googledrive! See the article <a href="https://googlesheets4.tidyverse.org/articles/articles/drive-and-sheets.html">Using googlesheets4 with googledrive</a>
if you want to coordinate auth between googlesheets4 and googledrive. This
function will emit an informational message if you are currently logged in
with both googlesheets4 and googledrive, but as different users.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gs4_find(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gs4_find_+3A_...">...</code></td>
<td>
<p>Arguments (other than <code>type</code>, which is hard-wired as <code>type = "spreadsheet"</code>) that are passed along to <code><a href="googledrive.html#topic+drive_find">googledrive::drive_find()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code><a href="googledrive.html#topic+dribble">dribble</a></code>, a tibble with one row per file.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# see all your Sheets
gs4_find()

# see 5 Sheets, prioritized by creation time
x &lt;- gs4_find(order_by = "createdTime desc", n_max = 5)
x

# hoist the creation date, using other packages in the tidyverse
# x %&gt;%
#   tidyr::hoist(drive_resource, created_on = "createdTime") %&gt;%
#   dplyr::mutate(created_on = as.Date(created_on))

</code></pre>

<hr>
<h2 id='gs4_fodder'>Create useful spreadsheet filler</h2><span id='topic+gs4_fodder'></span>

<h3>Description</h3>

<p>Creates a data frame that is useful for filling a spreadsheet, when you just
need a sheet to experiment with. The data frame has <code>n</code> rows and <code>m</code> columns
with these properties:
</p>

<ul>
<li><p> Column names match what Sheets displays: &quot;A&quot;, &quot;B&quot;, &quot;C&quot;, and so on.
</p>
</li>
<li><p> Inner cell values reflect the coordinates where each value will land in
the sheet, in A1-notation. So the first row is &quot;B2&quot;, &quot;C2&quot;, and so on.
Note that this <code>n</code>-row data frame will occupy <code>n + 1</code> rows in the sheet,
because the column names occupy the first row.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>gs4_fodder(n = 10, m = n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gs4_fodder_+3A_n">n</code></td>
<td>
<p>Number of rows.</p>
</td></tr>
<tr><td><code id="gs4_fodder_+3A_m">m</code></td>
<td>
<p>Number of columns.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame of character vectors.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>gs4_fodder()
gs4_fodder(5, 3)
</code></pre>

<hr>
<h2 id='gs4_formula'>Class for Google Sheets formulas</h2><span id='topic+gs4_formula'></span>

<h3>Description</h3>

<p>In order to write a formula into Google Sheets, you need to store it as an
object of class <code>googlesheets4_formula</code>. This is how we distinguish a
&quot;regular&quot; character string from a string that should be interpreted as a
formula. <code>googlesheets4_formula</code> is an S3 class implemented using the <a href="https://vctrs.r-lib.org/articles/s3-vector.html">vctrs package</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gs4_formula(x = character())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gs4_formula_+3A_x">x</code></td>
<td>
<p>Character.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An S3 vector of class <code>googlesheets4_formula</code>.
</p>


<h3>See Also</h3>

<p>Other write functions: 
<code><a href="#topic+gs4_create">gs4_create</a>()</code>,
<code><a href="#topic+range_delete">range_delete</a>()</code>,
<code><a href="#topic+range_flood">range_flood</a>()</code>,
<code><a href="#topic+range_write">range_write</a>()</code>,
<code><a href="#topic+sheet_append">sheet_append</a>()</code>,
<code><a href="#topic+sheet_write">sheet_write</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
dat &lt;- data.frame(x = c(1, 5, 3, 2, 4, 6))

ss &lt;- gs4_create("gs4-formula-demo", sheets = dat)
ss

summaries &lt;- tibble::tribble(
  ~desc, ~summaries,
  "max", "=max(A:A)",
  "sum", "=sum(A:A)",
  "min", "=min(A:A)",
  "sparkline", "=SPARKLINE(A:A, {\"color\", \"blue\"})"
)

# explicitly declare a column as `googlesheets4_formula`
summaries$summaries &lt;- gs4_formula(summaries$summaries)
summaries

range_write(ss, data = summaries, range = "C1", reformat = FALSE)

miscellany &lt;- tibble::tribble(
  ~desc, ~example,
  "hyperlink", "=HYPERLINK(\"http://www.google.com/\",\"Google\")",
  "image", "=IMAGE(\"https://www.google.com/images/srpr/logo3w.png\")"
)
miscellany$example &lt;- gs4_formula(miscellany$example)
miscellany

sheet_write(miscellany, ss = ss)

# clean up
gs4_find("gs4-formula-demo") %&gt;%
  googledrive::drive_trash()

</code></pre>

<hr>
<h2 id='gs4_get'>Get Sheet metadata</h2><span id='topic+gs4_get'></span>

<h3>Description</h3>

<p>Retrieve spreadsheet-specific metadata, such as details on the individual
(work)sheets or named ranges.
</p>

<ul>
<li> <p><code>gs4_get()</code> complements <code><a href="googledrive.html#topic+drive_get">googledrive::drive_get()</a></code>, which
returns metadata that exists for any file on Drive.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>gs4_get(ss)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gs4_get_+3A_ss">ss</code></td>
<td>
<p>Something that identifies a Google Sheet:
</p>

<ul>
<li><p> its file id as a string or <code><a href="googledrive.html#topic+drive_id">drive_id</a></code>
</p>
</li>
<li><p> a URL from which we can recover the id
</p>
</li>
<li><p> a one-row <code><a href="googledrive.html#topic+dribble">dribble</a></code>, which is how googledrive
represents Drive files
</p>
</li>
<li><p> an instance of <code>googlesheets4_spreadsheet</code>, which is what <code><a href="#topic+gs4_get">gs4_get()</a></code>
returns
</p>
</li></ul>

<p>Processed through <code><a href="#topic+as_sheets_id">as_sheets_id()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with S3 class <code>googlesheets4_spreadsheet</code>, for printing
purposes.
</p>


<h3>See Also</h3>

<p>Wraps the <code>spreadsheets.get</code> endpoint:
</p>

<ul>
<li> <p><a href="https://developers.google.com/sheets/api/reference/rest/v4/spreadsheets/get">https://developers.google.com/sheets/api/reference/rest/v4/spreadsheets/get</a>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
gs4_get(gs4_example("mini-gap"))

</code></pre>

<hr>
<h2 id='gs4_has_token'>Is there a token on hand?</h2><span id='topic+gs4_has_token'></span>

<h3>Description</h3>

<p>Reports whether googlesheets4 has stored a token, ready for use in downstream
requests.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gs4_has_token()
</code></pre>


<h3>Value</h3>

<p>Logical.
</p>


<h3>See Also</h3>

<p>Other low-level API functions: 
<code><a href="#topic+gs4_token">gs4_token</a>()</code>,
<code><a href="#topic+request_generate">request_generate</a>()</code>,
<code><a href="#topic+request_make">request_make</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>gs4_has_token()
</code></pre>

<hr>
<h2 id='gs4_oauth_app'>Get currently configured OAuth app (deprecated)</h2><span id='topic+gs4_oauth_app'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p>In light of the new <code><a href="gargle.html#topic+gargle_oauth_client_from_json">gargle::gargle_oauth_client()</a></code> constructor and class of
the same name, <code>gs4_oauth_app()</code> is being replaced by
<code><a href="#topic+gs4_oauth_client">gs4_oauth_client()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gs4_oauth_app()
</code></pre>

<hr>
<h2 id='gs4_random'>Generate a random Sheet name</h2><span id='topic+gs4_random'></span>

<h3>Description</h3>

<p>Generates a random name, suitable for a newly created Sheet, using
<code><a href="ids.html#topic+adjective_animal">ids::adjective_animal()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gs4_random(n = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gs4_random_+3A_n">n</code></td>
<td>
<p>Number of names to generate.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>gs4_random()
</code></pre>

<hr>
<h2 id='gs4_scopes'>Produce scopes specific to the Sheets API</h2><span id='topic+gs4_scopes'></span>

<h3>Description</h3>

<p>When called with no arguments, <code>gs4_scopes()</code> returns a named character
vector of scopes associated with the Sheets API. If <code>gs4_scopes(scopes =)</code> is
given, an abbreviated entry such as <code>"sheets.readonly"</code> is expanded to a full
scope (<code>"https://www.googleapis.com/auth/sheets.readonly"</code> in this case).
Unrecognized scopes are passed through unchanged.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gs4_scopes(scopes = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gs4_scopes_+3A_scopes">scopes</code></td>
<td>
<p>One or more API scopes. Each scope can be specified in full or,
for Sheets API-specific scopes, in an abbreviated form that is recognized by
<code><a href="#topic+gs4_scopes">gs4_scopes()</a></code>:
</p>

<ul>
<li><p> &quot;spreadsheets&quot; = &quot;https://www.googleapis.com/auth/spreadsheets&quot;
(the default)
</p>
</li>
<li><p> &quot;spreadsheets.readonly&quot; =
&quot;https://www.googleapis.com/auth/spreadsheets.readonly&quot;
</p>
</li>
<li><p> &quot;drive&quot; = &quot;https://www.googleapis.com/auth/drive&quot;
</p>
</li>
<li><p> &quot;drive.readonly&quot; = &quot;https://www.googleapis.com/auth/drive.readonly&quot;
</p>
</li>
<li><p> &quot;drive.file&quot; = &quot;https://www.googleapis.com/auth/drive.file&quot;
</p>
</li></ul>

<p>See
<a href="https://developers.google.com/identity/protocols/oauth2/scopes#sheets">https://developers.google.com/identity/protocols/oauth2/scopes#sheets</a> for
details on the permissions for each scope.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector of scopes.
</p>


<h3>See Also</h3>

<p><a href="https://developers.google.com/identity/protocols/oauth2/scopes#sheets">https://developers.google.com/identity/protocols/oauth2/scopes#sheets</a> for
details on the permissions for each scope.
</p>
<p>Other auth functions: 
<code><a href="#topic+gs4_auth_configure">gs4_auth_configure</a>()</code>,
<code><a href="#topic+gs4_auth">gs4_auth</a>()</code>,
<code><a href="#topic+gs4_deauth">gs4_deauth</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>gs4_scopes("spreadsheets")
gs4_scopes("spreadsheets.readonly")
gs4_scopes("drive")
gs4_scopes()
</code></pre>

<hr>
<h2 id='gs4_token'>Produce configured token</h2><span id='topic+gs4_token'></span>

<h3>Description</h3>

<p>For internal use or for those programming around the Sheets API.
Returns a token pre-processed with <code><a href="httr.html#topic+config">httr::config()</a></code>. Most users
do not need to handle tokens &quot;by hand&quot; or, even if they need some
control, <code><a href="#topic+gs4_auth">gs4_auth()</a></code> is what they need. If there is no current
token, <code><a href="#topic+gs4_auth">gs4_auth()</a></code> is called to either load from cache or
initiate OAuth2.0 flow.
If auth has been deactivated via <code><a href="#topic+gs4_deauth">gs4_deauth()</a></code>, <code>gs4_token()</code>
returns <code>NULL</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gs4_token()
</code></pre>


<h3>Value</h3>

<p>A <code>request</code> object (an S3 class provided by <a href="httr.html#topic+httr-package">httr</a>).
</p>


<h3>See Also</h3>

<p>Other low-level API functions: 
<code><a href="#topic+gs4_has_token">gs4_has_token</a>()</code>,
<code><a href="#topic+request_generate">request_generate</a>()</code>,
<code><a href="#topic+request_make">request_make</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
req &lt;- request_generate(
  "sheets.spreadsheets.get",
  list(spreadsheetId = "abc"),
  token = gs4_token()
)
req

</code></pre>

<hr>
<h2 id='gs4_user'>Get info on current user</h2><span id='topic+gs4_user'></span>

<h3>Description</h3>

<p>Reveals the email address of the user associated with the current token.
If no token has been loaded yet, this function does not initiate auth.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gs4_user()
</code></pre>


<h3>Value</h3>

<p>An email address or, if no token has been loaded, <code>NULL</code>.
</p>


<h3>See Also</h3>

<p><code><a href="gargle.html#topic+token-info">gargle::token_userinfo()</a></code>, <code><a href="gargle.html#topic+token-info">gargle::token_email()</a></code>,
<code><a href="gargle.html#topic+token-info">gargle::token_tokeninfo()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>gs4_user()
</code></pre>

<hr>
<h2 id='range_autofit'>Auto-fit columns or rows to the data</h2><span id='topic+range_autofit'></span>

<h3>Description</h3>

<p>Applies automatic resizing to either columns or rows of a (work)sheet. The
width or height of targeted columns or rows, respectively, is determined
from the current cell contents. This only affects the appearance of a sheet
in the browser and doesn't affect its values or dimensions in any way.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>range_autofit(ss, sheet = NULL, range = NULL, dimension = c("columns", "rows"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="range_autofit_+3A_ss">ss</code></td>
<td>
<p>Something that identifies a Google Sheet:
</p>

<ul>
<li><p> its file id as a string or <code><a href="googledrive.html#topic+drive_id">drive_id</a></code>
</p>
</li>
<li><p> a URL from which we can recover the id
</p>
</li>
<li><p> a one-row <code><a href="googledrive.html#topic+dribble">dribble</a></code>, which is how googledrive
represents Drive files
</p>
</li>
<li><p> an instance of <code>googlesheets4_spreadsheet</code>, which is what <code><a href="#topic+gs4_get">gs4_get()</a></code>
returns
</p>
</li></ul>

<p>Processed through <code><a href="#topic+as_sheets_id">as_sheets_id()</a></code>.</p>
</td></tr>
<tr><td><code id="range_autofit_+3A_sheet">sheet</code></td>
<td>
<p>Sheet to modify, in the sense of &quot;worksheet&quot; or &quot;tab&quot;. You can identify a sheet by name, with a string, or by position, with a number. Ignored if the sheet is specified via <code>range</code>. If neither argument specifies the sheet, defaults to the first visible sheet.</p>
</td></tr>
<tr><td><code id="range_autofit_+3A_range">range</code></td>
<td>
<p>Which columns or rows to resize. Optional. If you want to resize
all columns or all rows, use <code>dimension</code> instead. All the usual <code>range</code>
specifications are accepted, but the targeted range must specify only
columns (e.g. &quot;B:F&quot;) or only rows (e.g. &quot;2:7&quot;).</p>
</td></tr>
<tr><td><code id="range_autofit_+3A_dimension">dimension</code></td>
<td>
<p>Ignored if <code>range</code> is given. If consulted, <code>dimension</code> must
be either <code>"columns"</code> (the default) or <code>"rows"</code>. This is the simplest way
to request auto-resize for all columns or all rows.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The input <code>ss</code>, as an instance of <code><a href="#topic+sheets_id">sheets_id</a></code>
</p>


<h3>See Also</h3>

<p>Makes an <code>AutoResizeDimensionsRequest</code>:
</p>

<ul>
<li> <p><a href="https://developers.google.com/sheets/api/reference/rest/v4/spreadsheets/request#autoresizedimensionsrequest">https://developers.google.com/sheets/api/reference/rest/v4/spreadsheets/request#autoresizedimensionsrequest</a>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
dat &lt;- tibble::tibble(
  fruit = c("date", "lime", "pear", "plum")
)

ss &lt;- gs4_create("range-autofit-demo", sheets = dat)
ss

# open in the browser
gs4_browse(ss)

# shrink column A to fit the short fruit names
range_autofit(ss)
# in the browser, notice how the column width shrank

# send some longer fruit names
dat2 &lt;- tibble::tibble(
  fruit = c("cucumber", "honeydew")
)
ss %&gt;% sheet_append(dat2)
# in the browser, see that column A is now too narrow to show the data

range_autofit(ss)
# in the browser, see the column A reveals all the data now

# clean up
gs4_find("range-autofit-demo") %&gt;%
  googledrive::drive_trash()

</code></pre>

<hr>
<h2 id='range_delete'>Delete cells</h2><span id='topic+range_delete'></span>

<h3>Description</h3>

<p>Deletes a range of cells and shifts other cells into the deleted area. There
are several related tasks that are implemented by other functions:
</p>

<ul>
<li><p> To clear cells of their value and/or format, use <code><a href="#topic+range_clear">range_clear()</a></code>.
</p>
</li>
<li><p> To delete an entire (work)sheet, use <code><a href="#topic+sheet_delete">sheet_delete()</a></code>.
</p>
</li>
<li><p> To change the dimensions of a (work)sheet, use <code><a href="#topic+sheet_resize">sheet_resize()</a></code>.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>range_delete(ss, sheet = NULL, range, shift = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="range_delete_+3A_ss">ss</code></td>
<td>
<p>Something that identifies a Google Sheet:
</p>

<ul>
<li><p> its file id as a string or <code><a href="googledrive.html#topic+drive_id">drive_id</a></code>
</p>
</li>
<li><p> a URL from which we can recover the id
</p>
</li>
<li><p> a one-row <code><a href="googledrive.html#topic+dribble">dribble</a></code>, which is how googledrive
represents Drive files
</p>
</li>
<li><p> an instance of <code>googlesheets4_spreadsheet</code>, which is what <code><a href="#topic+gs4_get">gs4_get()</a></code>
returns
</p>
</li></ul>

<p>Processed through <code><a href="#topic+as_sheets_id">as_sheets_id()</a></code>.</p>
</td></tr>
<tr><td><code id="range_delete_+3A_sheet">sheet</code></td>
<td>
<p>Sheet to delete, in the sense of &quot;worksheet&quot; or &quot;tab&quot;. You can identify a sheet by name, with a string, or by position, with a number. Ignored if the sheet is specified via <code>range</code>. If neither argument specifies the sheet, defaults to the first visible sheet.</p>
</td></tr>
<tr><td><code id="range_delete_+3A_range">range</code></td>
<td>
<p>Cells to delete. There are a couple differences between <code>range</code>
here and how it works in other functions (e.g. <code><a href="#topic+range_read">range_read()</a></code>):
</p>

<ul>
<li> <p><code>range</code> must be specified.
</p>
</li>
<li> <p><code>range</code> must not be a named range.
</p>
</li>
<li> <p><code>range</code> must not be the name of a (work) sheet. Instead, use
<code><a href="#topic+sheet_delete">sheet_delete()</a></code> to delete an entire sheet.
Row-only and column-only ranges are especially relevant, such as &quot;2:6&quot; or
&quot;D&quot;. Remember you can also use the helpers in <code><a href="#topic+cell-specification">cell-specification</a></code>,
such as <code>cell_cols(4:6)</code>, or <code>cell_rows(5)</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="range_delete_+3A_shift">shift</code></td>
<td>
<p>Must be one of &quot;up&quot; or &quot;left&quot;, if specified. Required if <code>range</code>
is NOT a rows-only or column-only range (in which case, we can figure it
out for you). Determines whether the deleted area is filled by shifting
surrounding cells up or to the left.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The input <code>ss</code>, as an instance of <code><a href="#topic+sheets_id">sheets_id</a></code>
</p>


<h3>See Also</h3>

<p>Makes a <code>DeleteRangeRequest</code>:
</p>

<ul>
<li> <p><a href="https://developers.google.com/sheets/api/reference/rest/v4/spreadsheets/request#DeleteRangeRequest">https://developers.google.com/sheets/api/reference/rest/v4/spreadsheets/request#DeleteRangeRequest</a>
</p>
</li></ul>

<p>Other write functions: 
<code><a href="#topic+gs4_create">gs4_create</a>()</code>,
<code><a href="#topic+gs4_formula">gs4_formula</a>()</code>,
<code><a href="#topic+range_flood">range_flood</a>()</code>,
<code><a href="#topic+range_write">range_write</a>()</code>,
<code><a href="#topic+sheet_append">sheet_append</a>()</code>,
<code><a href="#topic+sheet_write">sheet_write</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# create a data frame to use as initial data
df &lt;- gs4_fodder(10)

# create Sheet
ss &lt;- gs4_create("range-delete-example", sheets = list(df))

# delete some rows
range_delete(ss, range = "2:4")

# delete a column
range_delete(ss, range = "C")

# delete a rectangle and specify how to shift remaining cells
range_delete(ss, range = "B3:F4", shift = "left")

# clean up
gs4_find("range-delete-example") %&gt;%
  googledrive::drive_trash()

</code></pre>

<hr>
<h2 id='range_flood'>Flood or clear a range of cells</h2><span id='topic+range_flood'></span><span id='topic+range_clear'></span>

<h3>Description</h3>

<p><code>range_flood()</code> &quot;floods&quot; a range of cells with the same content.
<code>range_clear()</code> is a wrapper that handles the common special case of
clearing the cell value. Both functions, by default, also clear the format,
but this can be specified via <code>reformat</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>range_flood(ss, sheet = NULL, range = NULL, cell = NULL, reformat = TRUE)

range_clear(ss, sheet = NULL, range = NULL, reformat = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="range_flood_+3A_ss">ss</code></td>
<td>
<p>Something that identifies a Google Sheet:
</p>

<ul>
<li><p> its file id as a string or <code><a href="googledrive.html#topic+drive_id">drive_id</a></code>
</p>
</li>
<li><p> a URL from which we can recover the id
</p>
</li>
<li><p> a one-row <code><a href="googledrive.html#topic+dribble">dribble</a></code>, which is how googledrive
represents Drive files
</p>
</li>
<li><p> an instance of <code>googlesheets4_spreadsheet</code>, which is what <code><a href="#topic+gs4_get">gs4_get()</a></code>
returns
</p>
</li></ul>

<p>Processed through <code><a href="#topic+as_sheets_id">as_sheets_id()</a></code>.</p>
</td></tr>
<tr><td><code id="range_flood_+3A_sheet">sheet</code></td>
<td>
<p>Sheet to write into, in the sense of &quot;worksheet&quot; or &quot;tab&quot;. You can identify a sheet by name, with a string, or by position, with a number.</p>
</td></tr>
<tr><td><code id="range_flood_+3A_range">range</code></td>
<td>
<p>A cell range to read from. If <code>NULL</code>, all non-empty cells are
read. Otherwise specify <code>range</code> as described in <a href="https://developers.google.com/sheets/api/guides/concepts#a1_notation">Sheets A1 notation</a>
or using the helpers documented in <a href="#topic+cell-specification">cell-specification</a>. Sheets uses
fairly standard spreadsheet range notation, although a bit different from
Excel. Examples of valid ranges: <code>"Sheet1!A1:B2"</code>, <code>"Sheet1!A:A"</code>,
<code>"Sheet1!1:2"</code>, <code>"Sheet1!A5:A"</code>, <code>"A1:B2"</code>, <code>"Sheet1"</code>. Interpreted
strictly, even if the range forces the inclusion of leading, trailing, or
embedded empty rows or columns. Takes precedence over <code>skip</code>, <code>n_max</code> and
<code>sheet</code>. Note <code>range</code> can be a named range, like <code>"sales_data"</code>, without
any cell reference.</p>
</td></tr>
<tr><td><code id="range_flood_+3A_cell">cell</code></td>
<td>
<p>The value to fill the cells in the <code>range</code> with. If unspecified,
the default of <code>NULL</code> results in clearing the existing value.</p>
</td></tr>
<tr><td><code id="range_flood_+3A_reformat">reformat</code></td>
<td>
<p>Logical, indicates whether to reformat the affected cells.
Currently googlesheets4 provides no real support for formatting, so
<code>reformat = TRUE</code> effectively means that edited cells become unformatted.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The input <code>ss</code>, as an instance of <code><a href="#topic+sheets_id">sheets_id</a></code>
</p>


<h3>See Also</h3>

<p>Makes a <code>RepeatCellRequest</code>:
</p>

<ul>
<li> <p><a href="https://developers.google.com/sheets/api/reference/rest/v4/spreadsheets/request#repeatcellrequest">https://developers.google.com/sheets/api/reference/rest/v4/spreadsheets/request#repeatcellrequest</a>
</p>
</li></ul>

<p>Other write functions: 
<code><a href="#topic+gs4_create">gs4_create</a>()</code>,
<code><a href="#topic+gs4_formula">gs4_formula</a>()</code>,
<code><a href="#topic+range_delete">range_delete</a>()</code>,
<code><a href="#topic+range_write">range_write</a>()</code>,
<code><a href="#topic+sheet_append">sheet_append</a>()</code>,
<code><a href="#topic+sheet_write">sheet_write</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# create a data frame to use as initial data
df &lt;- gs4_fodder(10)

# create Sheet
ss &lt;- gs4_create("range-flood-demo", sheets = list(df))

# default behavior (`cell = NULL`): clear value and format
range_flood(ss, range = "A1:B3")

# clear value but preserve format
range_flood(ss, range = "C1:D3", reformat = FALSE)

# send new value
range_flood(ss, range = "4:5", cell = ";-)")

# send formatting
# WARNING: use these unexported, internal functions at your own risk!
# This not (yet) officially supported, but it's possible.
blue_background &lt;- googlesheets4:::CellData(
  userEnteredFormat = googlesheets4:::new(
    "CellFormat",
    backgroundColor = googlesheets4:::new(
      "Color",
      red = 159 / 255, green = 183 / 255, blue = 196 / 255
    )
  )
)
range_flood(ss, range = "I:J", cell = blue_background)

# range_clear() is a shortcut where `cell = NULL` always
range_clear(ss, range = "9:9")
range_clear(ss, range = "10:10", reformat = FALSE)

# clean up
gs4_find("range-flood-demo") %&gt;%
  googledrive::drive_trash()

</code></pre>

<hr>
<h2 id='range_read'>Read a Sheet into a data frame</h2><span id='topic+range_read'></span><span id='topic+read_sheet'></span>

<h3>Description</h3>

<p>This is the main &quot;read&quot; function of the googlesheets4 package. It goes by two
names, because we want it to make sense in two contexts:
</p>

<ul>
<li> <p><code>read_sheet()</code> evokes other table-reading functions, like
<code>readr::read_csv()</code> and <code>readxl::read_excel()</code>. The <code>sheet</code> in this case
refers to a Google (spread)Sheet.
</p>
</li>
<li> <p><code>range_read()</code> is the right name according to the naming convention used
throughout the googlesheets4 package.
</p>
</li></ul>

<p><code>read_sheet()</code> and <code>range_read()</code> are synonyms and you can use either one.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>range_read(
  ss,
  sheet = NULL,
  range = NULL,
  col_names = TRUE,
  col_types = NULL,
  na = "",
  trim_ws = TRUE,
  skip = 0,
  n_max = Inf,
  guess_max = min(1000, n_max),
  .name_repair = "unique"
)

read_sheet(
  ss,
  sheet = NULL,
  range = NULL,
  col_names = TRUE,
  col_types = NULL,
  na = "",
  trim_ws = TRUE,
  skip = 0,
  n_max = Inf,
  guess_max = min(1000, n_max),
  .name_repair = "unique"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="range_read_+3A_ss">ss</code></td>
<td>
<p>Something that identifies a Google Sheet:
</p>

<ul>
<li><p> its file id as a string or <code><a href="googledrive.html#topic+drive_id">drive_id</a></code>
</p>
</li>
<li><p> a URL from which we can recover the id
</p>
</li>
<li><p> a one-row <code><a href="googledrive.html#topic+dribble">dribble</a></code>, which is how googledrive
represents Drive files
</p>
</li>
<li><p> an instance of <code>googlesheets4_spreadsheet</code>, which is what <code><a href="#topic+gs4_get">gs4_get()</a></code>
returns
</p>
</li></ul>

<p>Processed through <code><a href="#topic+as_sheets_id">as_sheets_id()</a></code>.</p>
</td></tr>
<tr><td><code id="range_read_+3A_sheet">sheet</code></td>
<td>
<p>Sheet to read, in the sense of &quot;worksheet&quot; or &quot;tab&quot;. You can identify a sheet by name, with a string, or by position, with a number. Ignored if the sheet is specified via <code>range</code>. If neither argument specifies the sheet, defaults to the first visible sheet.</p>
</td></tr>
<tr><td><code id="range_read_+3A_range">range</code></td>
<td>
<p>A cell range to read from. If <code>NULL</code>, all non-empty cells are
read. Otherwise specify <code>range</code> as described in <a href="https://developers.google.com/sheets/api/guides/concepts#a1_notation">Sheets A1 notation</a>
or using the helpers documented in <a href="#topic+cell-specification">cell-specification</a>. Sheets uses
fairly standard spreadsheet range notation, although a bit different from
Excel. Examples of valid ranges: <code>"Sheet1!A1:B2"</code>, <code>"Sheet1!A:A"</code>,
<code>"Sheet1!1:2"</code>, <code>"Sheet1!A5:A"</code>, <code>"A1:B2"</code>, <code>"Sheet1"</code>. Interpreted
strictly, even if the range forces the inclusion of leading, trailing, or
embedded empty rows or columns. Takes precedence over <code>skip</code>, <code>n_max</code> and
<code>sheet</code>. Note <code>range</code> can be a named range, like <code>"sales_data"</code>, without
any cell reference.</p>
</td></tr>
<tr><td><code id="range_read_+3A_col_names">col_names</code></td>
<td>
<p><code>TRUE</code> to use the first row as column names, <code>FALSE</code> to get
default names, or a character vector to provide column names directly. If
user provides <code>col_types</code>, <code>col_names</code> can have one entry per column or one
entry per unskipped column.</p>
</td></tr>
<tr><td><code id="range_read_+3A_col_types">col_types</code></td>
<td>
<p>Column types. Either <code>NULL</code> to guess all from the
spreadsheet or a string of readr-style shortcodes, with one character or
code per column. If exactly one <code>col_type</code> is specified, it is recycled.
See Column Specification for more.</p>
</td></tr>
<tr><td><code id="range_read_+3A_na">na</code></td>
<td>
<p>Character vector of strings to interpret as missing values. By
default, blank cells are treated as missing data.</p>
</td></tr>
<tr><td><code id="range_read_+3A_trim_ws">trim_ws</code></td>
<td>
<p>Logical. Should leading and trailing whitespace be trimmed
from cell contents?</p>
</td></tr>
<tr><td><code id="range_read_+3A_skip">skip</code></td>
<td>
<p>Minimum number of rows to skip before reading anything, be it
column names or data. Leading empty rows are automatically skipped, so this
is a lower bound. Ignored if <code>range</code> is given.</p>
</td></tr>
<tr><td><code id="range_read_+3A_n_max">n_max</code></td>
<td>
<p>Maximum number of data rows to parse into the returned tibble.
Trailing empty rows are automatically skipped, so this is an upper bound on
the number of rows in the result. Ignored if <code>range</code> is given. <code>n_max</code> is
imposed locally, after reading all non-empty cells, so, if speed is an
issue, it is better to use <code>range</code>.</p>
</td></tr>
<tr><td><code id="range_read_+3A_guess_max">guess_max</code></td>
<td>
<p>Maximum number of data rows to use for guessing column
types.</p>
</td></tr>
<tr><td><code id="range_read_+3A_.name_repair">.name_repair</code></td>
<td>
<p>Handling of column names. By default, googlesheets4
ensures column names are not empty and are unique. There is full support
for <code>.name_repair</code> as documented in <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <a href="tibble.html#topic+tibble-package">tibble</a>
</p>


<h3>Column Specification</h3>

<p>Column types must be specified in a single string of readr-style short
codes, e.g. &quot;cci?l&quot; means &quot;character, character, integer, guess, logical&quot;.
This is not where googlesheets4's col spec will end up, but it gets the
ball rolling in a way that is consistent with readr and doesn't reinvent
any wheels.
</p>
<p>Shortcodes for column types:
</p>

<ul>
<li> <p><code style="white-space: pre;">&#8288;_&#8288;</code> or <code>-</code>: Skip. Data in a skipped column is still requested from the
API (the high-level functions in this package are rectangle-oriented), but
is not parsed into the data frame output.
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;?&#8288;</code>: Guess. A type is guessed for each cell and then a consensus type is
selected for the column. If no atomic type is suitable for all cells, a
list-column is created, in which each cell is converted to an R object of
&quot;best&quot; type. If no column types are specified, i.e. <code>col_types = NULL</code>,
all types are guessed.
</p>
</li>
<li> <p><code>l</code>: Logical.
</p>
</li>
<li> <p><code>i</code>: Integer. This type is never guessed from the data, because Sheets
have no formal cell type for integers.
</p>
</li>
<li> <p><code>d</code> or <code>n</code>: Numeric, in the sense of &quot;double&quot;.
</p>
</li>
<li> <p><code>D</code>: Date. This type is never guessed from the data, because date cells
are just serial datetimes that bear a &quot;date&quot; format.
</p>
</li>
<li> <p><code>t</code>: Time of day. This type is never guessed from the data, because time
cells are just serial datetimes that bear a &quot;time&quot; format. <em>Not implemented
yet; returns POSIXct.</em>
</p>
</li>
<li> <p><code>T</code>: Datetime, specifically POSIXct.
</p>
</li>
<li> <p><code>c</code>: Character.
</p>
</li>
<li> <p><code>C</code>: Cell. This type is unique to googlesheets4. This returns raw cell
data, as an R list, which consists of everything sent by the Sheets API for
that cell. Has S3 type of <code>"CELL_SOMETHING"</code> and <code>"SHEETS_CELL"</code>. Mostly
useful internally, but exposed for those who want direct access to, e.g.,
formulas and formats.
</p>
</li>
<li> <p><code>L</code>: List, as in &quot;list-column&quot;. Each cell is a length-1 atomic vector of
its discovered type.
</p>
</li>
<li> <p><em>Still to come</em>: duration (code will be <code>:</code>) and factor (code will be
<code>f</code>).
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
ss &lt;- gs4_example("deaths")
read_sheet(ss, range = "A5:F15")
read_sheet(ss, range = "other!A5:F15", col_types = "ccilDD")
read_sheet(ss, range = "arts_data", col_types = "ccilDD")

read_sheet(gs4_example("mini-gap"))
read_sheet(
  gs4_example("mini-gap"),
  sheet = "Europe",
  range = "A:D",
  col_types = "ccid"
)

</code></pre>

<hr>
<h2 id='range_read_cells'>Read cells from a Sheet</h2><span id='topic+range_read_cells'></span>

<h3>Description</h3>

<p>This low-level function returns cell data in a tibble with one row per cell.
This tibble has integer variables <code>row</code> and <code>col</code> (referring to location
with the Google Sheet), an A1-style reference <code>loc</code>, and a <code>cell</code>
list-column. The flagship function <code><a href="#topic+read_sheet">read_sheet()</a></code>, a.k.a. <code><a href="#topic+range_read">range_read()</a></code>, is
what most users are looking for, rather than <code>range_read_cells()</code>.
<code><a href="#topic+read_sheet">read_sheet()</a></code> is basically <code>range_read_cells()</code> (this function), followed by
<code><a href="#topic+spread_sheet">spread_sheet()</a></code>, which looks after reshaping and column typing. But if you
really want raw cell data from the API, <code>range_read_cells()</code> is for you!
</p>


<h3>Usage</h3>

<pre><code class='language-R'>range_read_cells(
  ss,
  sheet = NULL,
  range = NULL,
  skip = 0,
  n_max = Inf,
  cell_data = c("default", "full"),
  discard_empty = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="range_read_cells_+3A_ss">ss</code></td>
<td>
<p>Something that identifies a Google Sheet:
</p>

<ul>
<li><p> its file id as a string or <code><a href="googledrive.html#topic+drive_id">drive_id</a></code>
</p>
</li>
<li><p> a URL from which we can recover the id
</p>
</li>
<li><p> a one-row <code><a href="googledrive.html#topic+dribble">dribble</a></code>, which is how googledrive
represents Drive files
</p>
</li>
<li><p> an instance of <code>googlesheets4_spreadsheet</code>, which is what <code><a href="#topic+gs4_get">gs4_get()</a></code>
returns
</p>
</li></ul>

<p>Processed through <code><a href="#topic+as_sheets_id">as_sheets_id()</a></code>.</p>
</td></tr>
<tr><td><code id="range_read_cells_+3A_sheet">sheet</code></td>
<td>
<p>Sheet to read, in the sense of &quot;worksheet&quot; or &quot;tab&quot;. You can identify a sheet by name, with a string, or by position, with a number. Ignored if the sheet is specified via <code>range</code>. If neither argument specifies the sheet, defaults to the first visible sheet.</p>
</td></tr>
<tr><td><code id="range_read_cells_+3A_range">range</code></td>
<td>
<p>A cell range to read from. If <code>NULL</code>, all non-empty cells are
read. Otherwise specify <code>range</code> as described in <a href="https://developers.google.com/sheets/api/guides/concepts#a1_notation">Sheets A1 notation</a>
or using the helpers documented in <a href="#topic+cell-specification">cell-specification</a>. Sheets uses
fairly standard spreadsheet range notation, although a bit different from
Excel. Examples of valid ranges: <code>"Sheet1!A1:B2"</code>, <code>"Sheet1!A:A"</code>,
<code>"Sheet1!1:2"</code>, <code>"Sheet1!A5:A"</code>, <code>"A1:B2"</code>, <code>"Sheet1"</code>. Interpreted
strictly, even if the range forces the inclusion of leading, trailing, or
embedded empty rows or columns. Takes precedence over <code>skip</code>, <code>n_max</code> and
<code>sheet</code>. Note <code>range</code> can be a named range, like <code>"sales_data"</code>, without
any cell reference.</p>
</td></tr>
<tr><td><code id="range_read_cells_+3A_skip">skip</code></td>
<td>
<p>Minimum number of rows to skip before reading anything, be it
column names or data. Leading empty rows are automatically skipped, so this
is a lower bound. Ignored if <code>range</code> is given.</p>
</td></tr>
<tr><td><code id="range_read_cells_+3A_n_max">n_max</code></td>
<td>
<p>Maximum number of data rows to parse into the returned tibble.
Trailing empty rows are automatically skipped, so this is an upper bound on
the number of rows in the result. Ignored if <code>range</code> is given. <code>n_max</code> is
imposed locally, after reading all non-empty cells, so, if speed is an
issue, it is better to use <code>range</code>.</p>
</td></tr>
<tr><td><code id="range_read_cells_+3A_cell_data">cell_data</code></td>
<td>
<p>How much detail to get for each cell. <code>"default"</code> retrieves
the fields actually used when googlesheets4 guesses or imposes cell and
column types. <code>"full"</code> retrieves all fields in the <a href="https://developers.google.com/sheets/api/reference/rest/v4/spreadsheets/cells#CellData"><code>CellData</code> schema</a>.
The main differences relate to cell formatting.</p>
</td></tr>
<tr><td><code id="range_read_cells_+3A_discard_empty">discard_empty</code></td>
<td>
<p>Whether to discard cells that have no data. Literally,
we check for an <code>effectiveValue</code>, which is one of the fields in the
<a href="https://developers.google.com/sheets/api/reference/rest/v4/spreadsheets/cells#CellData"><code>CellData</code> schema</a>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble with one row per cell in the <code>range</code>.
</p>


<h3>See Also</h3>

<p>Wraps the <code>spreadsheets.get</code> endpoint:
</p>

<ul>
<li> <p><a href="https://developers.google.com/sheets/api/reference/rest/v4/spreadsheets/get">https://developers.google.com/sheets/api/reference/rest/v4/spreadsheets/get</a>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
range_read_cells(gs4_example("deaths"), range = "arts_data")

# if you want detailed and exhaustive cell data, do this
range_read_cells(
  gs4_example("formulas-and-formats"),
  cell_data = "full",
  discard_empty = FALSE
)

</code></pre>

<hr>
<h2 id='range_speedread'>Read Sheet as CSV</h2><span id='topic+range_speedread'></span>

<h3>Description</h3>

<p>This function uses a quick-and-dirty method to read a Sheet that bypasses the
Sheets API and, instead, parses a CSV representation of the data. This can be
much faster than <code><a href="#topic+range_read">range_read()</a></code> &ndash; noticeably so for &quot;large&quot; spreadsheets.
There are real downsides, though, so we recommend this approach only when the
speed difference justifies it. Here are the limitations we must accept to get
faster reading:
</p>

<ul>
<li><p> Only formatted cell values are available, not underlying values or details
on the formats.
</p>
</li>
<li><p> We can't target a named range as the <code>range</code>.
</p>
</li>
<li><p> We have no access to the data type of a cell, i.e. we don't know that it's
logical, numeric, or datetime. That must be re-discovered based on the
CSV data (or specified by the user).
</p>
</li>
<li><p> Auth and error handling have to be handled a bit differently internally,
which may lead to behaviour that differs from other functions in
googlesheets4.
</p>
</li></ul>

<p>Note that the Sheets API is still used to retrieve metadata on the target
Sheet, in order to support range specification. <code>range_speedread()</code> also
sends an auth token with the request, unless a previous call to
<code><a href="#topic+gs4_deauth">gs4_deauth()</a></code> has put googlesheets4 into a de-authorized state.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>range_speedread(ss, sheet = NULL, range = NULL, skip = 0, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="range_speedread_+3A_ss">ss</code></td>
<td>
<p>Something that identifies a Google Sheet:
</p>

<ul>
<li><p> its file id as a string or <code><a href="googledrive.html#topic+drive_id">drive_id</a></code>
</p>
</li>
<li><p> a URL from which we can recover the id
</p>
</li>
<li><p> a one-row <code><a href="googledrive.html#topic+dribble">dribble</a></code>, which is how googledrive
represents Drive files
</p>
</li>
<li><p> an instance of <code>googlesheets4_spreadsheet</code>, which is what <code><a href="#topic+gs4_get">gs4_get()</a></code>
returns
</p>
</li></ul>

<p>Processed through <code><a href="#topic+as_sheets_id">as_sheets_id()</a></code>.</p>
</td></tr>
<tr><td><code id="range_speedread_+3A_sheet">sheet</code></td>
<td>
<p>Sheet to read, in the sense of &quot;worksheet&quot; or &quot;tab&quot;. You can identify a sheet by name, with a string, or by position, with a number. Ignored if the sheet is specified via <code>range</code>. If neither argument specifies the sheet, defaults to the first visible sheet.</p>
</td></tr>
<tr><td><code id="range_speedread_+3A_range">range</code></td>
<td>
<p>A cell range to read from. If <code>NULL</code>, all non-empty cells are
read. Otherwise specify <code>range</code> as described in <a href="https://developers.google.com/sheets/api/guides/concepts#a1_notation">Sheets A1 notation</a>
or using the helpers documented in <a href="#topic+cell-specification">cell-specification</a>. Sheets uses
fairly standard spreadsheet range notation, although a bit different from
Excel. Examples of valid ranges: <code>"Sheet1!A1:B2"</code>, <code>"Sheet1!A:A"</code>,
<code>"Sheet1!1:2"</code>, <code>"Sheet1!A5:A"</code>, <code>"A1:B2"</code>, <code>"Sheet1"</code>. Interpreted
strictly, even if the range forces the inclusion of leading, trailing, or
embedded empty rows or columns. Takes precedence over <code>skip</code>, <code>n_max</code> and
<code>sheet</code>. Note <code>range</code> can be a named range, like <code>"sales_data"</code>, without
any cell reference.</p>
</td></tr>
<tr><td><code id="range_speedread_+3A_skip">skip</code></td>
<td>
<p>Minimum number of rows to skip before reading anything, be it
column names or data. Leading empty rows are automatically skipped, so this
is a lower bound. Ignored if <code>range</code> is given.</p>
</td></tr>
<tr><td><code id="range_speedread_+3A_...">...</code></td>
<td>
<p>Passed along to the CSV parsing function (currently
<code>readr::read_csv()</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <a href="tibble.html#topic+tibble-package">tibble</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (require("readr")) {
  # since cell type is not available, use readr's col type specification
  range_speedread(
    gs4_example("deaths"),
    sheet = "other",
    range = "A5:F15",
    col_types = cols(
      Age = col_integer(),
      `Date of birth` = col_date("%m/%d/%Y"),
      `Date of death` = col_date("%m/%d/%Y")
    )
  )
}

# write a Sheet that, by default, is NOT world-readable
(ss &lt;- sheet_write(chickwts))

# demo that range_speedread() sends a token, which is why we can read this
range_speedread(ss)

# clean up
googledrive::drive_trash(ss)

</code></pre>

<hr>
<h2 id='range_write'>(Over)write new data into a range</h2><span id='topic+range_write'></span>

<h3>Description</h3>

<p>Writes a data frame into a range of cells. Main differences from
<code><a href="#topic+sheet_write">sheet_write()</a></code> (a.k.a. <code><a href="#topic+write_sheet">write_sheet()</a></code>):
</p>

<ul>
<li><p> Narrower scope. <code>range_write()</code> literally targets some cells, not a whole
(work)sheet.
</p>
</li>
<li><p> The edited rectangle is not explicitly styled as a table. Nothing special
is done re: formatting a header row or freezing rows.
</p>
</li>
<li><p> Column names can be suppressed. This means that, although <code>data</code> must
be a data frame (at least for now), <code>range_write()</code> can actually be used
to write arbitrary data.
</p>
</li>
<li><p> The target (spread)Sheet and (work)sheet must already exist. There is no
ability to create a Sheet or add a worksheet.
</p>
</li>
<li><p> The target sheet dimensions are not &quot;trimmed&quot; to shrink-wrap the <code>data</code>.
However, the sheet might gain rows and/or columns, in order to write
<code>data</code> to the user-specified <code>range</code>.
</p>
</li></ul>

<p>If you just want to add rows to an existing table, the function you probably
want is <code><a href="#topic+sheet_append">sheet_append()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>range_write(
  ss,
  data,
  sheet = NULL,
  range = NULL,
  col_names = TRUE,
  reformat = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="range_write_+3A_ss">ss</code></td>
<td>
<p>Something that identifies a Google Sheet:
</p>

<ul>
<li><p> its file id as a string or <code><a href="googledrive.html#topic+drive_id">drive_id</a></code>
</p>
</li>
<li><p> a URL from which we can recover the id
</p>
</li>
<li><p> a one-row <code><a href="googledrive.html#topic+dribble">dribble</a></code>, which is how googledrive
represents Drive files
</p>
</li>
<li><p> an instance of <code>googlesheets4_spreadsheet</code>, which is what <code><a href="#topic+gs4_get">gs4_get()</a></code>
returns
</p>
</li></ul>

<p>Processed through <code><a href="#topic+as_sheets_id">as_sheets_id()</a></code>.</p>
</td></tr>
<tr><td><code id="range_write_+3A_data">data</code></td>
<td>
<p>A data frame.</p>
</td></tr>
<tr><td><code id="range_write_+3A_sheet">sheet</code></td>
<td>
<p>Sheet to write into, in the sense of &quot;worksheet&quot; or &quot;tab&quot;. You can identify a sheet by name, with a string, or by position, with a number. Ignored if the sheet is specified via <code>range</code>. If neither argument specifies the sheet, defaults to the first visible sheet.</p>
</td></tr>
<tr><td><code id="range_write_+3A_range">range</code></td>
<td>
<p>Where to write. This <code>range</code> argument has important similarities
and differences to <code>range</code> elsewhere (e.g. <code><a href="#topic+range_read">range_read()</a></code>):
</p>

<ul>
<li><p> Similarities: Can be a cell range, using A1 notation (&quot;A1:D3&quot;) or using
the helpers in <code><a href="#topic+cell-specification">cell-specification</a></code>. Can combine sheet name and cell
range (&quot;Sheet1!A5:A&quot;) or refer to a sheet by name (<code>range = "Sheet1"</code>,
although <code>sheet = "Sheet1"</code> is preferred for clarity).
</p>
</li>
<li><p> Difference: Can NOT be a named range.
</p>
</li>
<li><p> Difference: <code>range</code> can be interpreted as the <em>start</em> of the target
rectangle (the upper left corner) or, more literally, as the actual
target rectangle. See the &quot;Range specification&quot; section for details.
</p>
</li></ul>
</td></tr>
<tr><td><code id="range_write_+3A_col_names">col_names</code></td>
<td>
<p>Logical, indicates whether to send the column names of
<code>data</code>.</p>
</td></tr>
<tr><td><code id="range_write_+3A_reformat">reformat</code></td>
<td>
<p>Logical, indicates whether to reformat the affected cells.
Currently googlesheets4 provides no real support for formatting, so
<code>reformat = TRUE</code> effectively means that edited cells become unformatted.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The input <code>ss</code>, as an instance of <code><a href="#topic+sheets_id">sheets_id</a></code>
</p>


<h3>Range specification</h3>

<p>The <code>range</code> argument of <code>range_write()</code> is special, because the Sheets API
can implement it in 2 different ways:
</p>

<ul>
<li><p> If <code>range</code> represents exactly 1 cell, like &quot;B3&quot;, it is taken as the <em>start</em>
(or upper left corner) of the targeted cell rectangle. The edited cells are
determined implicitly by the extent of the <code>data</code> we are writing. This
frees you from doing fiddly range computations based on the dimensions of
the <code>data</code>.
</p>
</li>
<li><p> If <code>range</code> describes a rectangle with multiple cells, it is interpreted
as the <em>actual</em> rectangle to edit. It is possible to describe a rectangle
that is unbounded on the right (e.g. &quot;B2:4&quot;), on the bottom (e.g. &quot;A4:C&quot;),
or on both the right and the bottom (e.g.
<code>cell_limits(c(2, 3), c(NA, NA))</code>. Note that <strong>all cells</strong> inside the
rectangle receive updated data and format. Important implication: if the
<code>data</code> object isn't big enough to fill the target rectangle, the cells that
don't receive new data are effectively cleared, i.e. the existing value
and format are deleted.
</p>
</li></ul>



<h3>See Also</h3>

<p>If sheet size needs to change, makes an <code>UpdateSheetPropertiesRequest</code>:
</p>

<ul>
<li> <p><a href="https://developers.google.com/sheets/api/reference/rest/v4/spreadsheets/request#UpdateSheetPropertiesRequest">https://developers.google.com/sheets/api/reference/rest/v4/spreadsheets/request#UpdateSheetPropertiesRequest</a>
</p>
</li></ul>

<p>The main data write is done via an <code>UpdateCellsRequest</code>:
</p>

<ul>
<li> <p><a href="https://developers.google.com/sheets/api/reference/rest/v4/spreadsheets/request#updatecellsrequest">https://developers.google.com/sheets/api/reference/rest/v4/spreadsheets/request#updatecellsrequest</a>
</p>
</li></ul>

<p>Other write functions: 
<code><a href="#topic+gs4_create">gs4_create</a>()</code>,
<code><a href="#topic+gs4_formula">gs4_formula</a>()</code>,
<code><a href="#topic+range_delete">range_delete</a>()</code>,
<code><a href="#topic+range_flood">range_flood</a>()</code>,
<code><a href="#topic+sheet_append">sheet_append</a>()</code>,
<code><a href="#topic+sheet_write">sheet_write</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# create a Sheet with some initial, empty (work)sheets
(ss &lt;- gs4_create("range-write-demo", sheets = c("alpha", "beta")))

df &lt;- data.frame(
  x = 1:3,
  y = letters[1:3]
)

#  write df somewhere other than the "upper left corner"
range_write(ss, data = df, range = "D6")

# view your magnificent creation in the browser
gs4_browse(ss)

# send data of disparate types to a 1-row rectangle
dat &lt;- tibble::tibble(
  string = "string",
  logical = TRUE,
  datetime = Sys.time()
)
range_write(ss, data = dat, sheet = "beta", col_names = FALSE)

# send data of disparate types to a 1-column rectangle
dat &lt;- tibble::tibble(
  x = list(Sys.time(), FALSE, "string")
)
range_write(ss, data = dat, range = "beta!C5", col_names = FALSE)

# clean up
gs4_find("range-write-demo") %&gt;%
  googledrive::drive_trash()

</code></pre>

<hr>
<h2 id='request_generate'>Generate a Google Sheets API request</h2><span id='topic+request_generate'></span>

<h3>Description</h3>

<p>Generate a request, using knowledge of the <a href="https://developers.google.com/sheets/api/">Sheets API</a> from its Discovery
Document (<code style="white-space: pre;">&#8288;https://www.googleapis.com/discovery/v1/apis/sheets/v4/rest&#8288;</code>). Use
<code><a href="#topic+request_make">request_make()</a></code> to execute the request. Most users should, instead, use
higher-level wrappers that facilitate common tasks, such as reading or
writing worksheets or cell ranges. The functions here are intended for
internal use and for programming around the Sheets API.
</p>
<p><code>request_generate()</code> lets you provide the bare minimum of input.
It takes a nickname for an endpoint and:
</p>

<ul>
<li><p> Uses the API spec to look up the <code>method</code>, <code>path</code>, and <code>base_url</code>.
</p>
</li>
<li><p> Checks <code>params</code> for validity and completeness with respect to the
endpoint. Uses <code>params</code> for URL endpoint substitution and separates
remaining parameters into those destined for the body versus the query.
</p>
</li>
<li><p> Adds an API key to the query if and only if <code>token = NULL</code>.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>request_generate(
  endpoint = character(),
  params = list(),
  key = NULL,
  token = gs4_token()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="request_generate_+3A_endpoint">endpoint</code></td>
<td>
<p>Character. Nickname for one of the selected Sheets API v4
endpoints built into googlesheets4. Learn more in <code><a href="#topic+gs4_endpoints">gs4_endpoints()</a></code>.</p>
</td></tr>
<tr><td><code id="request_generate_+3A_params">params</code></td>
<td>
<p>Named list. Parameters destined for endpoint URL substitution,
the query, or the body.</p>
</td></tr>
<tr><td><code id="request_generate_+3A_key">key</code></td>
<td>
<p>API key. Needed for requests that don't contain a token. The need
for an API key in the absence of a token is explained in Google's document
&quot;Credentials, access, security, and identity&quot;
(<code style="white-space: pre;">&#8288;https://support.google.com/googleapi/answer/6158857?hl=en&amp;ref_topic=7013279&#8288;</code>).
In order of precedence, these sources are consulted: the formal <code>key</code>
argument, a <code>key</code> parameter in <code>params</code>, a user-configured API key set up
with <code><a href="#topic+gs4_auth_configure">gs4_auth_configure()</a></code> and retrieved with <code><a href="#topic+gs4_api_key">gs4_api_key()</a></code>.</p>
</td></tr>
<tr><td><code id="request_generate_+3A_token">token</code></td>
<td>
<p>Set this to <code>NULL</code> to suppress the inclusion of a token. Note
that, if auth has been de-activated via <code><a href="#topic+gs4_deauth">gs4_deauth()</a></code>,
<code>gs4_token()</code> will actually return <code>NULL</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>list()</code><br /> Components are <code>method</code>, <code>url</code>, <code>body</code>, and <code>token</code>,
suitable as input for <code><a href="#topic+request_make">request_make()</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="gargle.html#topic+request_develop">gargle::request_develop()</a></code>, <code><a href="gargle.html#topic+request_develop">gargle::request_build()</a></code>,
<code><a href="gargle.html#topic+request_make">gargle::request_make()</a></code>
</p>
<p>Other low-level API functions: 
<code><a href="#topic+gs4_has_token">gs4_has_token</a>()</code>,
<code><a href="#topic+gs4_token">gs4_token</a>()</code>,
<code><a href="#topic+request_make">request_make</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>req &lt;- request_generate(
  "sheets.spreadsheets.get",
  list(spreadsheetId = gs4_example("deaths")),
  key = "PRETEND_I_AM_AN_API_KEY",
  token = NULL
)
req
</code></pre>

<hr>
<h2 id='request_make'>Make a Google Sheets API request</h2><span id='topic+request_make'></span>

<h3>Description</h3>

<p>Low-level function to execute a Sheets API request. Most users should,
instead, use higher-level wrappers that facilitate common tasks, such as
reading or writing worksheets or cell ranges. The functions here are intended
for internal use and for programming around the Sheets API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>request_make(x, ..., encode = "json")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="request_make_+3A_x">x</code></td>
<td>
<p>List. Holds the components for an HTTP request, presumably created
with <code><a href="#topic+request_generate">request_generate()</a></code> or <code><a href="gargle.html#topic+request_develop">gargle::request_build()</a></code>. Must contain a
<code>method</code> and <code>url</code>. If present, <code>body</code> and <code>token</code> are used.</p>
</td></tr>
<tr><td><code id="request_make_+3A_...">...</code></td>
<td>
<p>Optional arguments passed through to the HTTP method.</p>
</td></tr>
<tr><td><code id="request_make_+3A_encode">encode</code></td>
<td>
<p>If the body is a named list, how should it be encoded? This has
the same meaning as <code>encode</code> in all the <code><a href="httr.html#topic+VERB">httr::VERB()</a></code>s, such as
<code><a href="httr.html#topic+POST">httr::POST()</a></code>. Note, however, that we default to <code>encode = "json"</code>, which
is what you want most of the time when calling the Sheets API. The httr
default is <code>"multipart"</code>. Other acceptable values are <code>"form"</code> and <code>"raw"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>make_request()</code> is a very thin wrapper around <code><a href="gargle.html#topic+request_retry">gargle::request_retry()</a></code>,
only adding the googlesheets4 user agent. Typically the input has been
created with <code><a href="#topic+request_generate">request_generate()</a></code> or <code><a href="gargle.html#topic+request_develop">gargle::request_build()</a></code> and the output
is processed with <code>process_response()</code>.
</p>
<p><code><a href="gargle.html#topic+request_retry">gargle::request_retry()</a></code> retries requests that error with <code style="white-space: pre;">&#8288;429 RESOURCE_EXHAUSTED&#8288;</code>. Its basic scheme is exponential backoff, with one tweak
that is very specific to the Sheets API, which has documented <a href="https://developers.google.com/sheets/api/limits">usage limits</a>:
</p>
<p>&quot;a limit of 500 requests per 100 seconds per project and 100 requests per 100
seconds per user&quot;
</p>
<p>Note that the &quot;project&quot; here means everyone using googlesheets4 who hasn't
configured their own OAuth client. This is potentially a lot of users, all
acting independently.
</p>
<p>If you hit the &quot;100 requests per 100 seconds per <strong>user</strong>&quot; limit (which
really does mean YOU), the first wait time is a bit more than 100 seconds,
then we revert to exponential backoff.
</p>
<p>If you experience lots of retries, especially with 100 second delays, it
means your use of googlesheets4 is more than casual and <strong>it's time for you
to get your own OAuth client or use a service account token</strong>. This is explained
in the gargle vignette <code>vignette("get-api-credentials", package = "gargle")</code>.
</p>


<h3>Value</h3>

<p>Object of class <code>response</code> from <a href="httr.html#topic+httr">httr</a>.
</p>


<h3>See Also</h3>

<p>Other low-level API functions: 
<code><a href="#topic+gs4_has_token">gs4_has_token</a>()</code>,
<code><a href="#topic+gs4_token">gs4_token</a>()</code>,
<code><a href="#topic+request_generate">request_generate</a>()</code>
</p>

<hr>
<h2 id='sheet_add'>Add one or more (work)sheets</h2><span id='topic+sheet_add'></span>

<h3>Description</h3>

<p>Adds one or more (work)sheets to an existing (spread)Sheet. Note that sheet
names must be unique.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sheet_add(ss, sheet = NULL, ..., .before = NULL, .after = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sheet_add_+3A_ss">ss</code></td>
<td>
<p>Something that identifies a Google Sheet:
</p>

<ul>
<li><p> its file id as a string or <code><a href="googledrive.html#topic+drive_id">drive_id</a></code>
</p>
</li>
<li><p> a URL from which we can recover the id
</p>
</li>
<li><p> a one-row <code><a href="googledrive.html#topic+dribble">dribble</a></code>, which is how googledrive
represents Drive files
</p>
</li>
<li><p> an instance of <code>googlesheets4_spreadsheet</code>, which is what <code><a href="#topic+gs4_get">gs4_get()</a></code>
returns
</p>
</li></ul>

<p>Processed through <code><a href="#topic+as_sheets_id">as_sheets_id()</a></code>.</p>
</td></tr>
<tr><td><code id="sheet_add_+3A_sheet">sheet</code></td>
<td>
<p>One or more new sheet names. If unspecified, one new sheet is
added and Sheets autogenerates a name of the form &quot;SheetN&quot;.</p>
</td></tr>
<tr><td><code id="sheet_add_+3A_...">...</code></td>
<td>
<p>Optional parameters to specify additional properties, common to
all of the new sheet(s). Not relevant to most users. Specify fields of the
<a href="https://developers.google.com/sheets/api/reference/rest/v4/spreadsheets/sheets#SheetProperties"><code>SheetProperties</code> schema</a>
in <code>name = value</code> form.</p>
</td></tr>
<tr><td><code id="sheet_add_+3A_.before">.before</code>, <code id="sheet_add_+3A_.after">.after</code></td>
<td>
<p>Optional specification of where to put the new sheet(s). Specify, at most, one of <code>.before</code> and <code>.after</code>. Refer to an existing sheet by name (via a string) or by position (via a number). If unspecified, Sheets puts the new sheet(s) at the end.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The input <code>ss</code>, as an instance of <code><a href="#topic+sheets_id">sheets_id</a></code>
</p>


<h3>See Also</h3>

<p>Makes a batch of <code>AddSheetRequest</code>s (one per sheet):
</p>

<ul>
<li> <p><a href="https://developers.google.com/sheets/api/reference/rest/v4/spreadsheets/request#addsheetrequest">https://developers.google.com/sheets/api/reference/rest/v4/spreadsheets/request#addsheetrequest</a>
</p>
</li></ul>

<p>Other worksheet functions: 
<code><a href="#topic+sheet_append">sheet_append</a>()</code>,
<code><a href="#topic+sheet_copy">sheet_copy</a>()</code>,
<code><a href="#topic+sheet_delete">sheet_delete</a>()</code>,
<code><a href="#topic+sheet_properties">sheet_properties</a>()</code>,
<code><a href="#topic+sheet_relocate">sheet_relocate</a>()</code>,
<code><a href="#topic+sheet_rename">sheet_rename</a>()</code>,
<code><a href="#topic+sheet_resize">sheet_resize</a>()</code>,
<code><a href="#topic+sheet_write">sheet_write</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
ss &lt;- gs4_create("add-sheets-to-me")

# the only required argument is the target spreadsheet
ss %&gt;% sheet_add()

# but you CAN specify sheet name and/or position
ss %&gt;% sheet_add("apple", .after = 1)
ss %&gt;% sheet_add("banana", .after = "apple")

# add multiple sheets at once
ss %&gt;% sheet_add(c("coconut", "dragonfruit"))

# keeners can even specify additional sheet properties
ss %&gt;%
  sheet_add(
    sheet = "eggplant",
    .before = 1,
    gridProperties = list(
      rowCount = 3, columnCount = 6, frozenRowCount = 1
    )
  )

# get an overview of the sheets
sheet_properties(ss)

# clean up
gs4_find("add-sheets-to-me") %&gt;%
  googledrive::drive_trash()

</code></pre>

<hr>
<h2 id='sheet_append'>Append rows to a sheet</h2><span id='topic+sheet_append'></span>

<h3>Description</h3>

<p>Adds one or more new rows after the last row with data in a (work)sheet,
increasing the row dimension of the sheet if necessary.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sheet_append(ss, data, sheet = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sheet_append_+3A_ss">ss</code></td>
<td>
<p>Something that identifies a Google Sheet:
</p>

<ul>
<li><p> its file id as a string or <code><a href="googledrive.html#topic+drive_id">drive_id</a></code>
</p>
</li>
<li><p> a URL from which we can recover the id
</p>
</li>
<li><p> a one-row <code><a href="googledrive.html#topic+dribble">dribble</a></code>, which is how googledrive
represents Drive files
</p>
</li>
<li><p> an instance of <code>googlesheets4_spreadsheet</code>, which is what <code><a href="#topic+gs4_get">gs4_get()</a></code>
returns
</p>
</li></ul>

<p>Processed through <code><a href="#topic+as_sheets_id">as_sheets_id()</a></code>.</p>
</td></tr>
<tr><td><code id="sheet_append_+3A_data">data</code></td>
<td>
<p>A data frame.</p>
</td></tr>
<tr><td><code id="sheet_append_+3A_sheet">sheet</code></td>
<td>
<p>Sheet to append to, in the sense of &quot;worksheet&quot; or &quot;tab&quot;. You can identify a sheet by name, with a string, or by position, with a number.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The input <code>ss</code>, as an instance of <code><a href="#topic+sheets_id">sheets_id</a></code>
</p>


<h3>See Also</h3>

<p>Makes an <code>AppendCellsRequest</code>:
</p>

<ul>
<li> <p><a href="https://developers.google.com/sheets/api/reference/rest/v4/spreadsheets/request#AppendCellsRequest">https://developers.google.com/sheets/api/reference/rest/v4/spreadsheets/request#AppendCellsRequest</a>
</p>
</li></ul>

<p>Other write functions: 
<code><a href="#topic+gs4_create">gs4_create</a>()</code>,
<code><a href="#topic+gs4_formula">gs4_formula</a>()</code>,
<code><a href="#topic+range_delete">range_delete</a>()</code>,
<code><a href="#topic+range_flood">range_flood</a>()</code>,
<code><a href="#topic+range_write">range_write</a>()</code>,
<code><a href="#topic+sheet_write">sheet_write</a>()</code>
</p>
<p>Other worksheet functions: 
<code><a href="#topic+sheet_add">sheet_add</a>()</code>,
<code><a href="#topic+sheet_copy">sheet_copy</a>()</code>,
<code><a href="#topic+sheet_delete">sheet_delete</a>()</code>,
<code><a href="#topic+sheet_properties">sheet_properties</a>()</code>,
<code><a href="#topic+sheet_relocate">sheet_relocate</a>()</code>,
<code><a href="#topic+sheet_rename">sheet_rename</a>()</code>,
<code><a href="#topic+sheet_resize">sheet_resize</a>()</code>,
<code><a href="#topic+sheet_write">sheet_write</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# we will recreate the table of "other" deaths from this example Sheet
(deaths &lt;- gs4_example("deaths") %&gt;%
  range_read(range = "other_data", col_types = "????DD"))

# split the data into 3 pieces, which we will send separately
deaths_one &lt;- deaths[1:5, ]
deaths_two &lt;- deaths[6, ]
deaths_three &lt;- deaths[7:10, ]

# create a Sheet and send the first chunk of data
ss &lt;- gs4_create("sheet-append-demo", sheets = list(deaths = deaths_one))

# append a single row
ss %&gt;% sheet_append(deaths_two)

# append remaining rows
ss %&gt;% sheet_append(deaths_three)

# read and check against the original
deaths_replica &lt;- range_read(ss, col_types = "????DD")
identical(deaths, deaths_replica)

# clean up
gs4_find("sheet-append-demo") %&gt;%
  googledrive::drive_trash()

</code></pre>

<hr>
<h2 id='sheet_copy'>Copy a (work)sheet</h2><span id='topic+sheet_copy'></span>

<h3>Description</h3>

<p>Copies a (work)sheet, within its current (spread)Sheet or to another Sheet.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sheet_copy(
  from_ss,
  from_sheet = NULL,
  to_ss = from_ss,
  to_sheet = NULL,
  .before = NULL,
  .after = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sheet_copy_+3A_from_ss">from_ss</code></td>
<td>
<p>Something that identifies a Google Sheet:
</p>

<ul>
<li><p> its file id as a string or <code><a href="googledrive.html#topic+drive_id">drive_id</a></code>
</p>
</li>
<li><p> a URL from which we can recover the id
</p>
</li>
<li><p> a one-row <code><a href="googledrive.html#topic+dribble">dribble</a></code>, which is how googledrive
represents Drive files
</p>
</li>
<li><p> an instance of <code>googlesheets4_spreadsheet</code>, which is what <code><a href="#topic+gs4_get">gs4_get()</a></code>
returns
</p>
</li></ul>

<p>Processed through <code><a href="#topic+as_sheets_id">as_sheets_id()</a></code>.</p>
</td></tr>
<tr><td><code id="sheet_copy_+3A_from_sheet">from_sheet</code></td>
<td>
<p>Sheet to copy, in the sense of &quot;worksheet&quot; or &quot;tab&quot;. You can identify a sheet by name, with a string, or by position, with a number. Defaults to the first visible sheet.</p>
</td></tr>
<tr><td><code id="sheet_copy_+3A_to_ss">to_ss</code></td>
<td>
<p>The Sheet to copy <em>to</em>. Accepts all the same types of input as
<code>from_ss</code>, which is also what this defaults to, if unspecified.</p>
</td></tr>
<tr><td><code id="sheet_copy_+3A_to_sheet">to_sheet</code></td>
<td>
<p>Optional. Name of the new sheet, as a string. If you don't
specify this, Google generates a name, along the lines of &quot;Copy of blah&quot;.
Note that sheet names must be unique within a Sheet, so if the automatic
name would violate this, Google also de-duplicates it for you, meaning you
could conceivably end up with &quot;Copy of blah 2&quot;. If you have better ideas
about sheet names, specify <code>to_sheet</code>.</p>
</td></tr>
<tr><td><code id="sheet_copy_+3A_.before">.before</code>, <code id="sheet_copy_+3A_.after">.after</code></td>
<td>
<p>Optional specification of where to put the new sheet. Specify, at most, one of <code>.before</code> and <code>.after</code>. Refer to an existing sheet by name (via a string) or by position (via a number). If unspecified, Sheets puts the new sheet at the end.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The receiving Sheet, <code style="white-space: pre;">&#8288;to_ ss&#8288;</code>, as an instance of <code><a href="#topic+sheets_id">sheets_id</a></code>.
</p>


<h3>See Also</h3>

<p>If the copy happens within one Sheet, makes a <code>DuplicateSheetRequest</code>:
</p>

<ul>
<li> <p><a href="https://developers.google.com/sheets/api/reference/rest/v4/spreadsheets/request#duplicatesheetrequest">https://developers.google.com/sheets/api/reference/rest/v4/spreadsheets/request#duplicatesheetrequest</a>
</p>
</li></ul>

<p>If the copy is from one Sheet to another, wraps the
<code>spreadsheets.sheets/copyTo</code> endpoint:
</p>

<ul>
<li> <p><a href="https://developers.google.com/sheets/api/reference/rest/v4/spreadsheets.sheets/copyTo">https://developers.google.com/sheets/api/reference/rest/v4/spreadsheets.sheets/copyTo</a>
</p>
</li></ul>

<p>and possibly makes a subsequent <code>UpdateSheetPropertiesRequest</code>:
</p>

<ul>
<li> <p><a href="https://developers.google.com/sheets/api/reference/rest/v4/spreadsheets/request#UpdateSheetPropertiesRequest">https://developers.google.com/sheets/api/reference/rest/v4/spreadsheets/request#UpdateSheetPropertiesRequest</a>
</p>
</li></ul>

<p>Other worksheet functions: 
<code><a href="#topic+sheet_add">sheet_add</a>()</code>,
<code><a href="#topic+sheet_append">sheet_append</a>()</code>,
<code><a href="#topic+sheet_delete">sheet_delete</a>()</code>,
<code><a href="#topic+sheet_properties">sheet_properties</a>()</code>,
<code><a href="#topic+sheet_relocate">sheet_relocate</a>()</code>,
<code><a href="#topic+sheet_rename">sheet_rename</a>()</code>,
<code><a href="#topic+sheet_resize">sheet_resize</a>()</code>,
<code><a href="#topic+sheet_write">sheet_write</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
ss_aaa &lt;- gs4_create(
  "sheet-copy-demo-aaa",
  sheets = list(mtcars = head(mtcars), chickwts = head(chickwts))
)

# copy 'mtcars' sheet within existing Sheet, accept autogenerated name
ss_aaa %&gt;%
  sheet_copy()

# copy 'mtcars' sheet within existing Sheet
# specify new sheet's name and location
ss_aaa %&gt;%
  sheet_copy(to_sheet = "mtcars-the-sequel", .after = 1)

# make a second Sheet
ss_bbb &lt;- gs4_create("sheet-copy-demo-bbb")

# copy 'chickwts' sheet from first Sheet to second
# accept auto-generated name and default location
ss_aaa %&gt;%
  sheet_copy("chickwts", to_ss = ss_bbb)

# copy 'chickwts' sheet from first Sheet to second,
# WITH a specific name and into a specific location
ss_aaa %&gt;%
  sheet_copy(
    "chickwts",
    to_ss = ss_bbb, to_sheet = "chicks-two", .before = 1
  )

# clean up
gs4_find("sheet-copy-demo") %&gt;%
  googledrive::drive_trash()

</code></pre>

<hr>
<h2 id='sheet_delete'>Delete one or more (work)sheets</h2><span id='topic+sheet_delete'></span>

<h3>Description</h3>

<p>Deletes one or more (work)sheets from a (spread)Sheet.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sheet_delete(ss, sheet)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sheet_delete_+3A_ss">ss</code></td>
<td>
<p>Something that identifies a Google Sheet:
</p>

<ul>
<li><p> its file id as a string or <code><a href="googledrive.html#topic+drive_id">drive_id</a></code>
</p>
</li>
<li><p> a URL from which we can recover the id
</p>
</li>
<li><p> a one-row <code><a href="googledrive.html#topic+dribble">dribble</a></code>, which is how googledrive
represents Drive files
</p>
</li>
<li><p> an instance of <code>googlesheets4_spreadsheet</code>, which is what <code><a href="#topic+gs4_get">gs4_get()</a></code>
returns
</p>
</li></ul>

<p>Processed through <code><a href="#topic+as_sheets_id">as_sheets_id()</a></code>.</p>
</td></tr>
<tr><td><code id="sheet_delete_+3A_sheet">sheet</code></td>
<td>
<p>Sheet to delete, in the sense of &quot;worksheet&quot; or &quot;tab&quot;. You can identify a sheet by name, with a string, or by position, with a number. You can pass a vector to delete multiple sheets at once or even a list, if you need to mix names and positions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The input <code>ss</code>, as an instance of <code><a href="#topic+sheets_id">sheets_id</a></code>
</p>


<h3>See Also</h3>

<p>Makes an <code>DeleteSheetsRequest</code>:
</p>

<ul>
<li> <p><a href="https://developers.google.com/sheets/api/reference/rest/v4/spreadsheets/request#DeleteSheetRequest">https://developers.google.com/sheets/api/reference/rest/v4/spreadsheets/request#DeleteSheetRequest</a>
</p>
</li></ul>

<p>Other worksheet functions: 
<code><a href="#topic+sheet_add">sheet_add</a>()</code>,
<code><a href="#topic+sheet_append">sheet_append</a>()</code>,
<code><a href="#topic+sheet_copy">sheet_copy</a>()</code>,
<code><a href="#topic+sheet_properties">sheet_properties</a>()</code>,
<code><a href="#topic+sheet_relocate">sheet_relocate</a>()</code>,
<code><a href="#topic+sheet_rename">sheet_rename</a>()</code>,
<code><a href="#topic+sheet_resize">sheet_resize</a>()</code>,
<code><a href="#topic+sheet_write">sheet_write</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
ss &lt;- gs4_create("delete-sheets-from-me")
sheet_add(ss, c("alpha", "beta", "gamma", "delta"))

# get an overview of the sheets
sheet_properties(ss)

# delete sheets
sheet_delete(ss, 1)
sheet_delete(ss, "gamma")
sheet_delete(ss, list("alpha", 2))

# get an overview of the sheets
sheet_properties(ss)

# clean up
gs4_find("delete-sheets-from-me") %&gt;%
  googledrive::drive_trash()

</code></pre>

<hr>
<h2 id='sheet_properties'>Get data about (work)sheets</h2><span id='topic+sheet_properties'></span><span id='topic+sheet_names'></span>

<h3>Description</h3>

<p>Reveals full metadata or just the names for the (work)sheets inside a
(spread)Sheet.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sheet_properties(ss)

sheet_names(ss)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sheet_properties_+3A_ss">ss</code></td>
<td>
<p>Something that identifies a Google Sheet:
</p>

<ul>
<li><p> its file id as a string or <code><a href="googledrive.html#topic+drive_id">drive_id</a></code>
</p>
</li>
<li><p> a URL from which we can recover the id
</p>
</li>
<li><p> a one-row <code><a href="googledrive.html#topic+dribble">dribble</a></code>, which is how googledrive
represents Drive files
</p>
</li>
<li><p> an instance of <code>googlesheets4_spreadsheet</code>, which is what <code><a href="#topic+gs4_get">gs4_get()</a></code>
returns
</p>
</li></ul>

<p>Processed through <code><a href="#topic+as_sheets_id">as_sheets_id()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>


<ul>
<li> <p><code>sheet_properties()</code>: A tibble with one row per (work)sheet.
</p>
</li>
<li> <p><code>sheet_names()</code>: A character vector of (work)sheet names.
</p>
</li></ul>



<h3>See Also</h3>

<p>Other worksheet functions: 
<code><a href="#topic+sheet_add">sheet_add</a>()</code>,
<code><a href="#topic+sheet_append">sheet_append</a>()</code>,
<code><a href="#topic+sheet_copy">sheet_copy</a>()</code>,
<code><a href="#topic+sheet_delete">sheet_delete</a>()</code>,
<code><a href="#topic+sheet_relocate">sheet_relocate</a>()</code>,
<code><a href="#topic+sheet_rename">sheet_rename</a>()</code>,
<code><a href="#topic+sheet_resize">sheet_resize</a>()</code>,
<code><a href="#topic+sheet_write">sheet_write</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
ss &lt;- gs4_example("gapminder")
sheet_properties(ss)
sheet_names(ss)

</code></pre>

<hr>
<h2 id='sheet_relocate'>Relocate one or more (work)sheets</h2><span id='topic+sheet_relocate'></span>

<h3>Description</h3>

<p>Move (work)sheets around within a (spread)Sheet. The outcome is most
predictable for these common and simple use cases:
</p>

<ul>
<li><p> Reorder and move one or more sheets to the front.
</p>
</li>
<li><p> Move a single sheet to a specific (but arbitrary) location.
</p>
</li>
<li><p> Move multiple sheets to the back with <code>.after = 100</code> (<code>.after</code> can be
any number greater than or equal to the number of sheets).
</p>
</li></ul>

<p>If your relocation task is more complicated and you are puzzled by the
result, break it into a sequence of simpler calls to
<code>sheet_relocate()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sheet_relocate(ss, sheet, .before = if (is.null(.after)) 1, .after = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sheet_relocate_+3A_ss">ss</code></td>
<td>
<p>Something that identifies a Google Sheet:
</p>

<ul>
<li><p> its file id as a string or <code><a href="googledrive.html#topic+drive_id">drive_id</a></code>
</p>
</li>
<li><p> a URL from which we can recover the id
</p>
</li>
<li><p> a one-row <code><a href="googledrive.html#topic+dribble">dribble</a></code>, which is how googledrive
represents Drive files
</p>
</li>
<li><p> an instance of <code>googlesheets4_spreadsheet</code>, which is what <code><a href="#topic+gs4_get">gs4_get()</a></code>
returns
</p>
</li></ul>

<p>Processed through <code><a href="#topic+as_sheets_id">as_sheets_id()</a></code>.</p>
</td></tr>
<tr><td><code id="sheet_relocate_+3A_sheet">sheet</code></td>
<td>
<p>Sheet to relocate, in the sense of &quot;worksheet&quot; or &quot;tab&quot;. You can identify a sheet by name, with a string, or by position, with a number. You can pass a vector to move multiple sheets at once or even a list, if you need to mix names and positions.</p>
</td></tr>
<tr><td><code id="sheet_relocate_+3A_.before">.before</code>, <code id="sheet_relocate_+3A_.after">.after</code></td>
<td>
<p>Specification of where to locate the sheets(s)
identified by <code>sheet</code>. Exactly one of <code>.before</code> and <code>.after</code> must be
specified. Refer to an existing sheet by name (via a string) or by position
(via a number).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The input <code>ss</code>, as an instance of <code><a href="#topic+sheets_id">sheets_id</a></code>
</p>


<h3>See Also</h3>

<p>Constructs a batch of <code>UpdateSheetPropertiesRequest</code>s (one per sheet):
</p>

<ul>
<li> <p><a href="https://developers.google.com/sheets/api/reference/rest/v4/spreadsheets/request#UpdateSheetPropertiesRequest">https://developers.google.com/sheets/api/reference/rest/v4/spreadsheets/request#UpdateSheetPropertiesRequest</a>
</p>
</li></ul>

<p>Other worksheet functions: 
<code><a href="#topic+sheet_add">sheet_add</a>()</code>,
<code><a href="#topic+sheet_append">sheet_append</a>()</code>,
<code><a href="#topic+sheet_copy">sheet_copy</a>()</code>,
<code><a href="#topic+sheet_delete">sheet_delete</a>()</code>,
<code><a href="#topic+sheet_properties">sheet_properties</a>()</code>,
<code><a href="#topic+sheet_rename">sheet_rename</a>()</code>,
<code><a href="#topic+sheet_resize">sheet_resize</a>()</code>,
<code><a href="#topic+sheet_write">sheet_write</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
sheet_names &lt;- c("alfa", "bravo", "charlie", "delta", "echo", "foxtrot")
ss &lt;- gs4_create("sheet-relocate-demo", sheets = sheet_names)
sheet_names(ss)

# move one sheet, forwards then backwards
ss %&gt;%
  sheet_relocate("echo", .before = "bravo") %&gt;%
  sheet_names()
ss %&gt;%
  sheet_relocate("echo", .after = "delta") %&gt;%
  sheet_names()

# reorder and move multiple sheets to the front
ss %&gt;%
  sheet_relocate(list("foxtrot", 4)) %&gt;%
  sheet_names()

# put the sheets back in the original order
ss %&gt;%
  sheet_relocate(sheet_names) %&gt;%
  sheet_names()

# reorder and move multiple sheets to the back
ss %&gt;%
  sheet_relocate(c("bravo", "alfa", "echo"), .after = 10) %&gt;%
  sheet_names()

# clean up
gs4_find("sheet-relocate-demo") %&gt;%
  googledrive::drive_trash()

</code></pre>

<hr>
<h2 id='sheet_rename'>Rename a (work)sheet</h2><span id='topic+sheet_rename'></span>

<h3>Description</h3>

<p>Changes the name of a (work)sheet.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sheet_rename(ss, sheet = NULL, new_name)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sheet_rename_+3A_ss">ss</code></td>
<td>
<p>Something that identifies a Google Sheet:
</p>

<ul>
<li><p> its file id as a string or <code><a href="googledrive.html#topic+drive_id">drive_id</a></code>
</p>
</li>
<li><p> a URL from which we can recover the id
</p>
</li>
<li><p> a one-row <code><a href="googledrive.html#topic+dribble">dribble</a></code>, which is how googledrive
represents Drive files
</p>
</li>
<li><p> an instance of <code>googlesheets4_spreadsheet</code>, which is what <code><a href="#topic+gs4_get">gs4_get()</a></code>
returns
</p>
</li></ul>

<p>Processed through <code><a href="#topic+as_sheets_id">as_sheets_id()</a></code>.</p>
</td></tr>
<tr><td><code id="sheet_rename_+3A_sheet">sheet</code></td>
<td>
<p>Sheet to rename, in the sense of &quot;worksheet&quot; or &quot;tab&quot;. You can identify a sheet by name, with a string, or by position, with a number. Defaults to the first visible sheet.</p>
</td></tr>
<tr><td><code id="sheet_rename_+3A_new_name">new_name</code></td>
<td>
<p>New name of the sheet, as a string. This is required.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The input <code>ss</code>, as an instance of <code><a href="#topic+sheets_id">sheets_id</a></code>
</p>


<h3>See Also</h3>

<p>Makes an <code>UpdateSheetPropertiesRequest</code>:
</p>

<ul>
<li> <p><a href="https://developers.google.com/sheets/api/reference/rest/v4/spreadsheets/request#UpdateSheetPropertiesRequest">https://developers.google.com/sheets/api/reference/rest/v4/spreadsheets/request#UpdateSheetPropertiesRequest</a>
</p>
</li></ul>

<p>Other worksheet functions: 
<code><a href="#topic+sheet_add">sheet_add</a>()</code>,
<code><a href="#topic+sheet_append">sheet_append</a>()</code>,
<code><a href="#topic+sheet_copy">sheet_copy</a>()</code>,
<code><a href="#topic+sheet_delete">sheet_delete</a>()</code>,
<code><a href="#topic+sheet_properties">sheet_properties</a>()</code>,
<code><a href="#topic+sheet_relocate">sheet_relocate</a>()</code>,
<code><a href="#topic+sheet_resize">sheet_resize</a>()</code>,
<code><a href="#topic+sheet_write">sheet_write</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
ss &lt;- gs4_create(
  "sheet-rename-demo",
  sheets = list(cars = head(cars), chickwts = head(chickwts))
)
sheet_names(ss)

ss %&gt;%
  sheet_rename(1, new_name = "automobiles") %&gt;%
  sheet_rename("chickwts", new_name = "poultry")

# clean up
gs4_find("sheet-rename-demo") %&gt;%
  googledrive::drive_trash()

</code></pre>

<hr>
<h2 id='sheet_resize'>Change the size of a (work)sheet</h2><span id='topic+sheet_resize'></span>

<h3>Description</h3>

<p>Changes the number of rows and/or columns in a (work)sheet.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sheet_resize(ss, sheet = NULL, nrow = NULL, ncol = NULL, exact = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sheet_resize_+3A_ss">ss</code></td>
<td>
<p>Something that identifies a Google Sheet:
</p>

<ul>
<li><p> its file id as a string or <code><a href="googledrive.html#topic+drive_id">drive_id</a></code>
</p>
</li>
<li><p> a URL from which we can recover the id
</p>
</li>
<li><p> a one-row <code><a href="googledrive.html#topic+dribble">dribble</a></code>, which is how googledrive
represents Drive files
</p>
</li>
<li><p> an instance of <code>googlesheets4_spreadsheet</code>, which is what <code><a href="#topic+gs4_get">gs4_get()</a></code>
returns
</p>
</li></ul>

<p>Processed through <code><a href="#topic+as_sheets_id">as_sheets_id()</a></code>.</p>
</td></tr>
<tr><td><code id="sheet_resize_+3A_sheet">sheet</code></td>
<td>
<p>Sheet to resize, in the sense of &quot;worksheet&quot; or &quot;tab&quot;. You can identify a sheet by name, with a string, or by position, with a number.</p>
</td></tr>
<tr><td><code id="sheet_resize_+3A_nrow">nrow</code>, <code id="sheet_resize_+3A_ncol">ncol</code></td>
<td>
<p>Desired number of rows or columns, respectively. The default
of <code>NULL</code> means to leave unchanged.</p>
</td></tr>
<tr><td><code id="sheet_resize_+3A_exact">exact</code></td>
<td>
<p>Logical, indicating whether to impose <code>nrow</code> and <code>ncol</code> exactly
or to treat them as lower bounds. If <code>exact = FALSE</code>,
<code>sheet_resize()</code> can only add cells. If <code>exact = TRUE</code>, cells can be
deleted and their contents are lost.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The input <code>ss</code>, as an instance of <code><a href="#topic+sheets_id">sheets_id</a></code>
</p>


<h3>See Also</h3>

<p>Makes an <code>UpdateSheetPropertiesRequest</code>:
</p>

<ul>
<li> <p><a href="https://developers.google.com/sheets/api/reference/rest/v4/spreadsheets/request#UpdateSheetPropertiesRequest">https://developers.google.com/sheets/api/reference/rest/v4/spreadsheets/request#UpdateSheetPropertiesRequest</a>
</p>
</li></ul>

<p>Other worksheet functions: 
<code><a href="#topic+sheet_add">sheet_add</a>()</code>,
<code><a href="#topic+sheet_append">sheet_append</a>()</code>,
<code><a href="#topic+sheet_copy">sheet_copy</a>()</code>,
<code><a href="#topic+sheet_delete">sheet_delete</a>()</code>,
<code><a href="#topic+sheet_properties">sheet_properties</a>()</code>,
<code><a href="#topic+sheet_relocate">sheet_relocate</a>()</code>,
<code><a href="#topic+sheet_rename">sheet_rename</a>()</code>,
<code><a href="#topic+sheet_write">sheet_write</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# create a Sheet with the default initial worksheet
(ss &lt;- gs4_create("sheet-resize-demo"))

# see (work)sheet dims
sheet_properties(ss)

# no resize occurs
sheet_resize(ss, nrow = 2, ncol = 6)

# reduce sheet size
sheet_resize(ss, nrow = 5, ncol = 7, exact = TRUE)

# add rows
sheet_resize(ss, nrow = 7)

# add columns
sheet_resize(ss, ncol = 10)

# add rows and columns
sheet_resize(ss, nrow = 9, ncol = 12)

# re-inspect (work)sheet dims
sheet_properties(ss)

# clean up
gs4_find("sheet-resize-demo") %&gt;%
  googledrive::drive_trash()

</code></pre>

<hr>
<h2 id='sheet_write'>(Over)write new data into a Sheet</h2><span id='topic+sheet_write'></span><span id='topic+write_sheet'></span>

<h3>Description</h3>

<p>This is one of the main ways to write data with googlesheets4. This function
writes a data frame into a (work)sheet inside a (spread)Sheet. The target
sheet is styled as a table:
</p>

<ul>
<li><p> Special formatting is applied to the header row, which holds column
names.
</p>
</li>
<li><p> The first row (header row) is frozen.
</p>
</li>
<li><p> The sheet's dimensions are set to &quot;shrink wrap&quot; the <code>data</code>.
</p>
</li></ul>

<p>If no existing Sheet is specified via <code>ss</code>, this function delegates to
<code><a href="#topic+gs4_create">gs4_create()</a></code> and the new Sheet's name is randomly generated. If that's
undesirable, call <code><a href="#topic+gs4_create">gs4_create()</a></code> directly to get more control.
</p>
<p>If no <code>sheet</code> is specified or if <code>sheet</code> doesn't identify an existing sheet,
a new sheet is added to receive the <code>data</code>. If <code>sheet</code> specifies an existing
sheet, it is effectively overwritten! All pre-existing values, formats, and
dimensions are cleared and the targeted sheet gets new values and dimensions
from <code>data</code>.
</p>
<p>This function goes by two names, because we want it to make sense in two
contexts:
</p>

<ul>
<li> <p><code>write_sheet()</code> evokes other table-writing functions, like
<code>readr::write_csv()</code>. The <code>sheet</code> here technically refers to an individual
(work)sheet (but also sort of refers to the associated Google
(spread)Sheet).
</p>
</li>
<li> <p><code>sheet_write()</code> is the right name according to the naming convention used
throughout the googlesheets4 package.
</p>
</li></ul>

<p><code>write_sheet()</code> and <code>sheet_write()</code> are equivalent and you can use either one.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sheet_write(data, ss = NULL, sheet = NULL)

write_sheet(data, ss = NULL, sheet = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sheet_write_+3A_data">data</code></td>
<td>
<p>A data frame. If it has zero rows, we send one empty pseudo-row
of data, so that we can apply the usual table styling. This empty row goes
away (gets filled, actually) the first time you send more data with
<code><a href="#topic+sheet_append">sheet_append()</a></code>.</p>
</td></tr>
<tr><td><code id="sheet_write_+3A_ss">ss</code></td>
<td>
<p>Something that identifies a Google Sheet:
</p>

<ul>
<li><p> its file id as a string or <code><a href="googledrive.html#topic+drive_id">drive_id</a></code>
</p>
</li>
<li><p> a URL from which we can recover the id
</p>
</li>
<li><p> a one-row <code><a href="googledrive.html#topic+dribble">dribble</a></code>, which is how googledrive
represents Drive files
</p>
</li>
<li><p> an instance of <code>googlesheets4_spreadsheet</code>, which is what <code><a href="#topic+gs4_get">gs4_get()</a></code>
returns
</p>
</li></ul>

<p>Processed through <code><a href="#topic+as_sheets_id">as_sheets_id()</a></code>.</p>
</td></tr>
<tr><td><code id="sheet_write_+3A_sheet">sheet</code></td>
<td>
<p>Sheet to write into, in the sense of &quot;worksheet&quot; or &quot;tab&quot;. You can identify a sheet by name, with a string, or by position, with a number.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The input <code>ss</code>, as an instance of <code><a href="#topic+sheets_id">sheets_id</a></code>
</p>


<h3>See Also</h3>

<p>Other write functions: 
<code><a href="#topic+gs4_create">gs4_create</a>()</code>,
<code><a href="#topic+gs4_formula">gs4_formula</a>()</code>,
<code><a href="#topic+range_delete">range_delete</a>()</code>,
<code><a href="#topic+range_flood">range_flood</a>()</code>,
<code><a href="#topic+range_write">range_write</a>()</code>,
<code><a href="#topic+sheet_append">sheet_append</a>()</code>
</p>
<p>Other worksheet functions: 
<code><a href="#topic+sheet_add">sheet_add</a>()</code>,
<code><a href="#topic+sheet_append">sheet_append</a>()</code>,
<code><a href="#topic+sheet_copy">sheet_copy</a>()</code>,
<code><a href="#topic+sheet_delete">sheet_delete</a>()</code>,
<code><a href="#topic+sheet_properties">sheet_properties</a>()</code>,
<code><a href="#topic+sheet_relocate">sheet_relocate</a>()</code>,
<code><a href="#topic+sheet_rename">sheet_rename</a>()</code>,
<code><a href="#topic+sheet_resize">sheet_resize</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
df &lt;- data.frame(
  x = 1:3,
  y = letters[1:3]
)

# specify only a data frame, get a new Sheet, with a random name
ss &lt;- write_sheet(df)
read_sheet(ss)

# clean up
googledrive::drive_trash(ss)

# create a Sheet with some initial, placeholder data
ss &lt;- gs4_create(
  "sheet-write-demo",
  sheets = list(alpha = data.frame(x = 1), omega = data.frame(x = 1))
)

# write df into its own, new sheet
sheet_write(df, ss = ss)

# write mtcars into the sheet named "omega"
sheet_write(mtcars, ss = ss, sheet = "omega")

# get an overview of the sheets
sheet_properties(ss)

# view your magnificent creation in the browser
gs4_browse(ss)

# clean up
gs4_find("sheet-write-demo") %&gt;%
  googledrive::drive_trash()

</code></pre>

<hr>
<h2 id='sheets_id'><code>sheets_id</code> class</h2><span id='topic+sheets_id'></span><span id='topic+as_sheets_id'></span>

<h3>Description</h3>

<p><code>sheets_id</code> is an S3 class that marks a string as a Google Sheet's id, which
the Sheets API docs refer to as <code>spreadsheetId</code>.
</p>
<p>Any object of class <code>sheets_id</code> also has the <code><a href="googledrive.html#topic+drive_id">drive_id</a></code>
class, which is used by googledrive for the same purpose. This means you
can provide a <code>sheets_id</code> to googledrive functions, in order to do anything
with your Sheet that has nothing to do with it being a spreadsheet. Examples:
change the Sheet's name, parent folder, or permissions. Read more about using
<a href="#topic+googlesheets4">googlesheets4</a> and googledrive together in <code>vignette("drive-and-sheets")</code>.
Note that a <code>sheets_id</code> object is intended to hold <strong>just one</strong> id, while the
parent class <code>drive_id</code> can be used for multiple ids.
</p>
<p><code>as_sheets_id()</code> is a generic function that converts various inputs into an
instance of <code>sheets_id</code>. See more below.
</p>
<p>When you print a <code>sheets_id</code>, we attempt to reveal the Sheet's current
metadata, via <code><a href="#topic+gs4_get">gs4_get()</a></code>. This can fail for a variety of reasons (e.g. if
you're offline), but the input <code>sheets_id</code> is always revealed and returned,
invisibly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_sheets_id(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sheets_id_+3A_x">x</code></td>
<td>
<p>Something that contains a Google Sheet id: an id string, a
<code><a href="googledrive.html#topic+drive_id">drive_id</a></code>, a URL, a one-row
<code><a href="googledrive.html#topic+dribble">dribble</a></code>, or a <code>googlesheets4_spreadsheet</code>.</p>
</td></tr>
<tr><td><code id="sheets_id_+3A_...">...</code></td>
<td>
<p>Other arguments passed down to methods. (Not used.)</p>
</td></tr>
</table>


<h3><code>as_sheets_id()</code></h3>

<p>These inputs can be converted to a <code>sheets_id</code>:
</p>

<ul>
<li><p> Spreadsheet id, &quot;a string containing letters, numbers, and some special
characters&quot;, typically 44 characters long, in our experience. Example:
<code style="white-space: pre;">&#8288;1qpyC0XzvTcKT6EISywvqESX3A0MwQoFDE8p-Bll4hps&#8288;</code>.
</p>
</li>
<li><p> A URL, from which we can excavate a spreadsheet or file id. Example:
<code>"https://docs.google.com/spreadsheets/d/1BzfL0kZUz1TsI5zxJF1WNF01IxvC67FbOJUiiGMZ_mQ/edit#gid=1150108545"</code>.
</p>
</li>
<li><p> A one-row <code><a href="googledrive.html#topic+dribble">dribble</a></code>, a &quot;Drive tibble&quot; used by the
googledrive package. In general, a <code>dribble</code> can represent several
files, one row per file. Since googlesheets4 is not vectorized over
spreadsheets, we are only prepared to accept a one-row <code>dribble</code>.
</p>

<ul>
<li> <p><code><a href="googledrive.html#topic+drive_get">googledrive::drive_get(&quot;YOUR_SHEET_NAME&quot;)</a></code>
is a great way to look up a Sheet via its name.
</p>
</li>
<li> <p><code><a href="#topic+gs4_find">gs4_find(&quot;YOUR_SHEET_NAME&quot;)</a></code> is another good way
to get your hands on a Sheet.
</p>
</li></ul>

</li>
<li><p> Spreadsheet meta data, as returned by, e.g., <code><a href="#topic+gs4_get">gs4_get()</a></code>. Literally,
this is an object of class <code>googlesheets4_spreadsheet</code>.
</p>
</li></ul>



<h3>See Also</h3>

<p><a href="googledrive.html#topic+drive_id">googledrive::as_id</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
mini_gap_id &lt;- gs4_example("mini-gap")
class(mini_gap_id)
mini_gap_id

as_sheets_id("abc")

</code></pre>

<hr>
<h2 id='spread_sheet'>Spread a data frame of cells into spreadsheet shape</h2><span id='topic+spread_sheet'></span>

<h3>Description</h3>

<p>Reshapes a data frame of cells (presumably the output of
<code><a href="#topic+range_read_cells">range_read_cells()</a></code>) into another data frame, i.e., puts it back into the
shape of the source spreadsheet. This function exists primarily for internal
use and for testing. The flagship function <code><a href="#topic+range_read">range_read()</a></code>, a.k.a.
<code><a href="#topic+read_sheet">read_sheet()</a></code>, is what most users are looking for. It is basically
<code><a href="#topic+range_read_cells">range_read_cells()</a></code> + <code>spread_sheet()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spread_sheet(
  df,
  col_names = TRUE,
  col_types = NULL,
  na = "",
  trim_ws = TRUE,
  guess_max = min(1000, max(df$row)),
  .name_repair = "unique"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spread_sheet_+3A_df">df</code></td>
<td>
<p>A data frame with one row per (nonempty) cell, integer variables
<code>row</code> and <code>column</code> (probably referring to location within the spreadsheet),
and a list-column <code>cell</code> of <code>SHEET_CELL</code> objects.</p>
</td></tr>
<tr><td><code id="spread_sheet_+3A_col_names">col_names</code></td>
<td>
<p><code>TRUE</code> to use the first row as column names, <code>FALSE</code> to get
default names, or a character vector to provide column names directly. If
user provides <code>col_types</code>, <code>col_names</code> can have one entry per column or one
entry per unskipped column.</p>
</td></tr>
<tr><td><code id="spread_sheet_+3A_col_types">col_types</code></td>
<td>
<p>Column types. Either <code>NULL</code> to guess all from the
spreadsheet or a string of readr-style shortcodes, with one character or
code per column. If exactly one <code>col_type</code> is specified, it is recycled.
See Column Specification for more.</p>
</td></tr>
<tr><td><code id="spread_sheet_+3A_na">na</code></td>
<td>
<p>Character vector of strings to interpret as missing values. By
default, blank cells are treated as missing data.</p>
</td></tr>
<tr><td><code id="spread_sheet_+3A_trim_ws">trim_ws</code></td>
<td>
<p>Logical. Should leading and trailing whitespace be trimmed
from cell contents?</p>
</td></tr>
<tr><td><code id="spread_sheet_+3A_guess_max">guess_max</code></td>
<td>
<p>Maximum number of data rows to use for guessing column
types.</p>
</td></tr>
<tr><td><code id="spread_sheet_+3A_.name_repair">.name_repair</code></td>
<td>
<p>Handling of column names. By default, googlesheets4
ensures column names are not empty and are unique. There is full support
for <code>.name_repair</code> as documented in <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble in the shape of the original spreadsheet, but enforcing
user's wishes regarding column names, column types, <code>NA</code> strings, and
whitespace trimming.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
df &lt;- gs4_example("mini-gap") %&gt;%
  range_read_cells()
spread_sheet(df)

# ^^ gets same result as ...
read_sheet(gs4_example("mini-gap"))

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
