<!DOCTYPE html><html lang="en-US"><head><title>Help for package GPTreeO</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {GPTreeO}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#CreateWrappedGP'><p>Factory function called by GPNode to create the wrapper for a specified GP package</p></a></li>
<li><a href='#GPNode'><p>R6 Class for the nodes / leaves in the GPTree tree</p></a></li>
<li><a href='#GPTree'><p>Tree structure storing all nodes containing local GPs</p></a></li>
<li><a href='#WrappedDiceKrigingGP'><p>R6 class WrappedDiceKrigingGP</p></a></li>
<li><a href='#WrappedGP'><p>R6 class WrappedGP</p></a></li>
<li><a href='#WrappedmlegpGP'><p>R6 class WrappedmlegpGP</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Dividing Local Gaussian Processes for Online Learning Regression</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.1</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Timo Braun &lt;gptreeo.timo.braun@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>We implement and extend the Dividing Local Gaussian Process 
    algorithm by Lederer et al. (2020) &lt;<a href="https://doi.org/10.48550%2FarXiv.2006.09446">doi:10.48550/arXiv.2006.09446</a>&gt;. Its
    main use case is in online learning where it is used to train a network of
    local GPs (referred to as tree) by cleverly partitioning the input space. 
    In contrast to a single GP, 'GPTreeO' is able to deal with larger amounts of
    data. The package includes methods to create the tree and set its
    parameter, incorporating data points from a data stream as well as making
    joint predictions based on all relevant local GPs.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Imports:</td>
<td>R6, hash, DiceKriging, mlegp</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, spelling, testthat</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-10-16 15:06:08 UTC; traschpanda</td>
</tr>
<tr>
<td>Author:</td>
<td>Timo Braun <a href="https://orcid.org/0009-0001-0965-8285"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cre],
  Anders Kvellestad <a href="https://orcid.org/0000-0002-5267-7705"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Riccardo De Bin <a href="https://orcid.org/0000-0002-7441-6880"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-10-16 15:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='CreateWrappedGP'>Factory function called by GPNode to create the wrapper for a specified GP package</h2><span id='topic+CreateWrappedGP'></span>

<h3>Description</h3>

<p>Factory function called by GPNode to create the wrapper for a specified GP package
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CreateWrappedGP(
  wrapper,
  X,
  y,
  y_var,
  gp_control,
  init_covpars,
  retrain_buffer_length,
  add_buffer_in_prediction
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CreateWrappedGP_+3A_wrapper">wrapper</code></td>
<td>
<p>A string specifying what GP implementation is used</p>
</td></tr>
<tr><td><code id="CreateWrappedGP_+3A_x">X</code></td>
<td>
<p>Input data matrix with x_dim columns and at maximum Nbar rows. Is used to create the first iteration of the local GP.</p>
</td></tr>
<tr><td><code id="CreateWrappedGP_+3A_y">y</code></td>
<td>
<p>Value of target variable at input point x; has to be a one-dimensional matrix or a vector; any further columns will be ignored</p>
</td></tr>
<tr><td><code id="CreateWrappedGP_+3A_y_var">y_var</code></td>
<td>
<p>Variance of the target variable; has to be a one-dimensional matrix or vector</p>
</td></tr>
<tr><td><code id="CreateWrappedGP_+3A_gp_control">gp_control</code></td>
<td>
<p>A list of GP implementation-specific options, passed directly to the wrapped GP implementation</p>
</td></tr>
<tr><td><code id="CreateWrappedGP_+3A_init_covpars">init_covpars</code></td>
<td>
<p>Initial covariance parameters of the local GP</p>
</td></tr>
<tr><td><code id="CreateWrappedGP_+3A_retrain_buffer_length">retrain_buffer_length</code></td>
<td>
<p>Only retrain when the number of buffer points or collected points exceeds this value</p>
</td></tr>
<tr><td><code id="CreateWrappedGP_+3A_add_buffer_in_prediction">add_buffer_in_prediction</code></td>
<td>
<p>If TRUE, points in the data buffers are added to the GP before prediction. They are added into a temporarily created GP which contains the not yet included points. The GP in the node is not yet updated.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A detailed list of expected functions from GPTree and GPNode can be found in the comments of this file. Currently, GPs from the <code>DiceKriging</code> package (<a href="#topic+WrappedDiceKrigingGP">WrappedDiceKrigingGP</a>) and <code>mlegp</code> package (<a href="#topic+WrappedmlegpGP">WrappedmlegpGP</a>) are implemented. The user can create their own wrapper using <a href="#topic+WrappedGP">WrappedGP</a>.
</p>


<h3>Value</h3>

<p>The wrapper of the chosen GP package, containing the respective GP and information on the shared points and those stored in the buffer.
</p>

<hr>
<h2 id='GPNode'>R6 Class for the nodes / leaves in the GPTree tree</h2><span id='topic+GPNode'></span>

<h3>Description</h3>

<p>The nodes contain the local GP if they are leaves (at the end of a branch). Nodes that are just nodes contain information on how the input space was split. They are responsible for computing and updating the splitting probabilities. Also, the tree interacts with the local GPs through the nodes.
</p>
<p>Currently, GPs from the <code>DiceKriging</code> package (<a href="#topic+WrappedDiceKrigingGP">WrappedDiceKrigingGP</a>) and <code>mlegp</code> package (<a href="#topic+WrappedmlegpGP">WrappedmlegpGP</a>) are implemented. The user can create their own wrapper using <a href="#topic+WrappedGP">WrappedGP</a>.
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>key</code></dt><dd><p>A string like &quot;0110100&quot; to identify the node in the binary tree</p>
</dd>
<dt><code>x_dim</code></dt><dd><p>Dimensionality of input points. It is set once the first point is received through the <a href="#topic+GPTree">GPTree</a> method <code>update</code>. It needs to be specified if <code>min_ranges</code> should be different from default.</p>
</dd>
<dt><code>theta</code></dt><dd><p>Overlap ratio between two leafs in the split direction. The default value is 0.</p>
</dd>
<dt><code>split_direction_criterion</code></dt><dd><p>A string that indicates which spitting criterion to use. The options are:
</p>

<ul>
<li> <p><code>"max_spread"</code>: Split along the direction which has the largest data spread.
</p>
</li>
<li> <p><code>"min_lengthscale"</code>: split along the direction with the smallest length-scale hyperparameter from the local GP.
</p>
</li>
<li> <p><code>"max_spread_per_lengthscale"</code>: Split along the direction with the largest data spread relative to the corresponding GP length-scale hyperparameter.
</p>
</li>
<li> <p><code>"max_corr"</code>: Split along the direction where the input data is most strongly correlated with the target variable.
</p>
</li>
<li> <p><code>"principal_component"</code>: Split along the first principal component.
</p>
</li></ul>

<p>The default value is <code>"max_spread_per_lengthscale"</code>.</p>
</dd>
<dt><code>split_position_criterion</code></dt><dd><p>A string indicating how the split position along the split direction should be set. Possible values are (<code>"mean"</code> and <code>"median"</code>). The default is <code>"mean"</code>.</p>
</dd>
<dt><code>shape_decay</code></dt><dd><p>A string specifying how the probability function for a point to be assigned to the left leaf should fall off in the overlap region. The available options are a linear shape (<code>"linear"</code>), an exponential shape (<code>"exponential"</code>) or a Gaussian shape (<code>"gaussian"</code>). Another option is to select no overlap region. This can be achieved by selecting <code>"deterministic"</code> or to set <code>theta</code> to 0. The default is <code>"linear"</code>.</p>
</dd>
<dt><code>prob_min_theta</code></dt><dd><p>Minimum probability after which the overlap shape gets truncated (either towards 0 or 1). The default value is 0.01.</p>
</dd>
<dt><code>Nbar</code></dt><dd><p>Maximum number of data points for each GP in a leaf before it is split. The default value is 1000.</p>
</dd>
<dt><code>min_ranges</code></dt><dd><p>Smallest allowed input data spread (per dimension) before node splitting stops. It is set to its default <code>min_ranges = rep(0.0, x_dim)</code> once the first point is received through the <code>update</code> method. <code>x_dim</code> needs to be specified by the user if it should be different from the default.</p>
</dd>
<dt><code>is_leaf</code></dt><dd><p>If TRUE, this node a leaf, i.e the last node on its branch</p>
</dd>
<dt><code>wrapped_gp</code></dt><dd><p>An instance of the WrappedGP type</p>
</dd>
<dt><code>can_split</code></dt><dd><p>If TRUE for a given dimension, the leaf can be split along that dimension</p>
</dd>
<dt><code>rotation_matrix</code></dt><dd><p>A rotation matrix, used for transforming the data</p>
</dd>
<dt><code>shift</code></dt><dd><p>A shift, used for transforming the data</p>
</dd>
<dt><code>use_pc_transform</code></dt><dd><p>TRUE if principal components transformation is used for node splitting</p>
</dd>
<dt><code>x_spread</code></dt><dd><p>Vector of data spread for each dimension</p>
</dd>
<dt><code>split_index</code></dt><dd><p>Index for the split dimension</p>
</dd>
<dt><code>position_split</code></dt><dd><p>Position of the split along dimension split_index</p>
</dd>
<dt><code>width_overlap</code></dt><dd><p>Width of overlap region along dimension split_index</p>
</dd>
<dt><code>point_ids</code></dt><dd><p>IDs of the points assigned to this node</p>
</dd>
<dt><code>residuals</code></dt><dd><p>Vector of residuals</p>
</dd>
<dt><code>pred_errs</code></dt><dd><p>Vector of prediction uncertainties</p>
</dd>
<dt><code>error_scaler</code></dt><dd><p>Scaling factor for the prediction error to ensure desired coverage</p>
</dd>
<dt><code>use_n_residuals</code></dt><dd><p>Number of past residuals to use in calibrating the <code>error_scaler</code></p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-GPNode-new"><code>GPNode$new()</code></a>
</p>
</li>
<li> <p><a href="#method-GPNode-transform"><code>GPNode$transform()</code></a>
</p>
</li>
<li> <p><a href="#method-GPNode-update_prob_pars"><code>GPNode$update_prob_pars()</code></a>
</p>
</li>
<li> <p><a href="#method-GPNode-get_prob_child_1"><code>GPNode$get_prob_child_1()</code></a>
</p>
</li>
<li> <p><a href="#method-GPNode-register_residual"><code>GPNode$register_residual()</code></a>
</p>
</li>
<li> <p><a href="#method-GPNode-update_empirical_error_pars"><code>GPNode$update_empirical_error_pars()</code></a>
</p>
</li>
<li> <p><a href="#method-GPNode-delete_gp"><code>GPNode$delete_gp()</code></a>
</p>
</li>
<li> <p><a href="#method-GPNode-clone"><code>GPNode$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-GPNode-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a new node object
</p>


<h5>Usage</h5>

<div class="r"><pre>GPNode$new(
  key,
  x_dim,
  theta,
  split_direction_criterion,
  split_position_criterion,
  shape_decay,
  prob_min_theta,
  Nbar,
  wrapper,
  gp_control,
  retrain_buffer_length,
  add_buffer_in_prediction,
  min_ranges = NULL,
  is_leaf = TRUE
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>key</code></dt><dd><p>A string like &quot;0110100&quot; to identify the node in the binary tree</p>
</dd>
<dt><code>x_dim</code></dt><dd><p>Dimensionality of input points. It is set once the first point is received through the <a href="#topic+GPTree">GPTree</a> method <code>update</code>. It needs to be specified if <code>min_ranges</code> should be different from default.</p>
</dd>
<dt><code>theta</code></dt><dd><p>Overlap ratio between two leafs in the split direction. The default value is 0.</p>
</dd>
<dt><code>split_direction_criterion</code></dt><dd><p>A string that indicates which spitting criterion to use. The options are:
</p>

<ul>
<li> <p><code>"max_spread"</code>: Split along the direction which has the largest data spread.
</p>
</li>
<li> <p><code>"min_lengthscale"</code>: split along the direction with the smallest length-scale hyperparameter from the local GP.
</p>
</li>
<li> <p><code>"max_spread_per_lengthscale"</code>: Split along the direction with the largest data spread relative to the corresponding GP length-scale hyperparameter.
</p>
</li>
<li> <p><code>"max_corr"</code>: Split along the direction where the input data is most strongly correlated with the target variable.
</p>
</li>
<li> <p><code>"principal_component"</code>: Split along the first principal component.
</p>
</li></ul>

<p>The default value is <code>"max_spread_per_lengthscale"</code>.</p>
</dd>
<dt><code>split_position_criterion</code></dt><dd><p>A string indicating how the split position along the split direction should be set. Possible values are (<code>"mean"</code> and <code>"median"</code>). The default is <code>"mean"</code>.</p>
</dd>
<dt><code>shape_decay</code></dt><dd><p>A string specifying how the probability function for a point to be assigned to the left leaf should fall off in the overlap region. The available options are a linear shape (<code>"linear"</code>), an exponential shape (<code>"exponential"</code>) or a Gaussian shape (<code>"gaussian"</code>). Another option is to select no overlap region. This can be achieved by selecting <code>"deterministic"</code> or to set <code>theta</code> to 0. The default is <code>"linear"</code>.</p>
</dd>
<dt><code>prob_min_theta</code></dt><dd><p>Minimum probability after which the overlap shape gets truncated (either towards 0 or 1). The default value is 0.01.</p>
</dd>
<dt><code>Nbar</code></dt><dd><p>Maximum number of data points for each GP in a leaf before it is split. The default value is 1000.</p>
</dd>
<dt><code>wrapper</code></dt><dd><p>A string that indicates which GP implementation should be used. The current version includes wrappers for the packages <code>"DiceKriging"</code> and <code>"mlegp"</code>. The default setting is <code>"DiceKriging"</code>.</p>
</dd>
<dt><code>gp_control</code></dt><dd><p>A <code>list</code> of control parameter that is forwarded to the wrapper. Here, the covariance function is specified. <code>DiceKriging</code> allows for the following kernels, passed as string: <code>"gauss"</code>, <code>"matern5_2"</code>, <code>"matern3_2"</code>, <code>"exp"</code>, <code>"powexp"</code> where <code>"matern3_2"</code> is set as default.</p>
</dd>
<dt><code>retrain_buffer_length</code></dt><dd><p>Size of the retrain buffer. The buffer for a each node collects data points and holds them until the buffer length is reached. Then the GP in the node is updated with the data in the buffer. For a fixed <code>Nbar</code>, higher values for <code>retrain_buffer_length</code> lead to faster run time (less frequent retraining), but the trade-off is a temporary reduced prediction accuracy. We advise that the choice for <code>retrain_buffer_length</code> should depend on the chosen <code>Nbar</code>. By default <code>retrain_buffer_length</code> is set equal to <code>Nbar</code>.</p>
</dd>
<dt><code>add_buffer_in_prediction</code></dt><dd><p>If TRUE, points in the data buffers are added to the GP before prediction. They are added into a temporarily created GP which contains the not yet included points. The GP in the node is not yet updated. The default is <code>FALSE</code>.</p>
</dd>
<dt><code>min_ranges</code></dt><dd><p>Smallest allowed input data spread (per dimension) before node splitting stops. It is set to its default <code>min_ranges = rep(0.0, x_dim)</code> once the first point is received through the <a href="#topic+GPTree">GPTree</a> method <code>update</code>. <code>x_dim</code> needs to be specified by the user if it should be different from the default.</p>
</dd>
<dt><code>is_leaf</code></dt><dd><p>If TRUE, this node a leaf, i.e the last node on its branch.</p>
</dd>
<dt><code>n_points_train_limit</code></dt><dd><p>Number of points at which a GP is created in the leaf</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A new GPNode object. Contains the local GP in the field <code>wrapped_gp</code>, and information used for and related to splitting the node. If the node has been split, the local GP is removed.
</p>


<hr>
<a id="method-GPNode-transform"></a>



<h4>Method <code>transform()</code></h4>

<p>Method to transform input data through a shift and a rotation. IS EXPECTED TO NOT BE CALLED BY THE USER
</p>


<h5>Usage</h5>

<div class="r"><pre>GPNode$transform(X)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>X</code></dt><dd><p>Matrix with x points</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>The transformed X matrix
</p>


<hr>
<a id="method-GPNode-update_prob_pars"></a>



<h4>Method <code>update_prob_pars()</code></h4>

<p>Method to update the probability parameters (x_spread, can_split, split_index, position_split, width_overlap). IS EXPECTED TO NOT BE CALLED BY THE USER
</p>


<h5>Usage</h5>

<div class="r"><pre>GPNode$update_prob_pars()</pre></div>


<hr>
<a id="method-GPNode-get_prob_child_1"></a>



<h4>Method <code>get_prob_child_1()</code></h4>

<p>Method to compute the probability that a point x should go to child 1. IS EXPECTED TO NOT BE CALLED BY THE USER
</p>


<h5>Usage</h5>

<div class="r"><pre>GPNode$get_prob_child_1(x)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x</code></dt><dd><p>Single data point for which probability is computed; has to be a vector with length equal to x_dim</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>The probability that a point x should go to child 1
</p>


<hr>
<a id="method-GPNode-register_residual"></a>



<h4>Method <code>register_residual()</code></h4>

<p>Method to register prediction performance
</p>


<h5>Usage</h5>

<div class="r"><pre>GPNode$register_residual(x, y)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x</code></dt><dd><p>Most recent single input data point from the data stream; has to be a vector with length equal to x_dim</p>
</dd>
<dt><code>y</code></dt><dd><p>Target variable which has to be a one-dimensional matrix or a vector; any further columns will be ignored</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GPNode-update_empirical_error_pars"></a>



<h4>Method <code>update_empirical_error_pars()</code></h4>

<p>Method for updating the empirical error parameters
</p>


<h5>Usage</h5>

<div class="r"><pre>GPNode$update_empirical_error_pars()</pre></div>


<hr>
<a id="method-GPNode-delete_gp"></a>



<h4>Method <code>delete_gp()</code></h4>

<p>Method to delete the GP. IS EXPECTED TO NOT BE CALLED BY THE USER
</p>


<h5>Usage</h5>

<div class="r"><pre>GPNode$delete_gp()</pre></div>


<hr>
<a id="method-GPNode-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>GPNode$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p><code><a href="#topic+GPTree">GPTree()</a></code> for the main methods
</p>

<hr>
<h2 id='GPTree'>Tree structure storing all nodes containing local GPs</h2><span id='topic+GPTree'></span>

<h3>Description</h3>

<p>The base class which contains and where all parameters are set. Here, all information on how and when the splitting is carried out is stored.
<code>wrapper</code> and <code>gp_control</code> specify the Gaussian process (GP) implementation and its parameters. Moreover, minimum errors and calibration of the predictions are specified here, too.
</p>
<p><strong>Essential methods</strong>
</p>
<p>The following three methods are essential for the package. The remaining ones are mostly not expected to be called by the user.
</p>

<ul>
<li> <p><a href="#method-GPTree-new"><code>GPTree$new()</code></a>: Creates a new tree with specified parameters
</p>
</li>
<li> <p><a href="#method-GPTree-update"><code>GPTree$update()</code></a>: Adds the information from the input point to the tree and updates local GPs
</p>
</li>
<li> <p><a href="#method-GPTree-joint_prediction"><code>GPTree$joint_prediction()</code></a>: Computes the joint prediction for a given input point
</p>
</li></ul>



<h3>Brief package functionality overview</h3>

<p>The tree collects the information from all <a href="#topic+GPNode">GPNode</a>s which in turn contain the local GP. Currently, GPs from the <code>DiceKriging</code> package (<a href="#topic+WrappedDiceKrigingGP">WrappedDiceKrigingGP</a>) and <code>mlegp</code> package (<a href="#topic+WrappedmlegpGP">WrappedmlegpGP</a>) are implemented. The user can create their own wrapper using <a href="#topic+WrappedGP">WrappedGP</a>.
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>Nbar</code></dt><dd><p>Maximum number of data points for each GP in a leaf before it is split. The default value is 1000.</p>
</dd>
<dt><code>retrain_buffer_length</code></dt><dd><p>Size of the retrain buffer. The buffer for a each node collects data points and holds them until the buffer length is reached. Then the GP in the node is updated with the data in the buffer. For a fixed <code>Nbar</code>, higher values for <code>retrain_buffer_length</code> lead to faster run time (less frequent retraining), but the trade-off is a temporary reduced prediction accuracy. We advise that the choice for <code>retrain_buffer_length</code> should depend on the chosen <code>Nbar</code>. By default <code>retrain_buffer_length</code> is set equal to <code>Nbar</code>.</p>
</dd>
<dt><code>gradual_split</code></dt><dd><p>If TRUE, gradual splitting is used for splitting. The default value is TRUE.</p>
</dd>
<dt><code>theta</code></dt><dd><p>Overlap ratio between two leafs in the split direction. The default value is 0.</p>
</dd>
<dt><code>wrapper</code></dt><dd><p>A string that indicates which GP implementation should be used. The current version includes wrappers for the packages <code>"DiceKriging"</code> and <code>"mlegp"</code>. The default setting is <code>"DiceKriging"</code>.</p>
</dd>
<dt><code>gp_control</code></dt><dd><p>A <code>list</code> of control parameter that is forwarded to the wrapper. Here, the covariance function is specified. <code>DiceKriging</code> allows for the following kernels, passed as string: <code>"gauss"</code>, <code>"matern5_2"</code>, <code>"matern3_2"</code>, <code>"exp"</code>, <code>"powexp"</code> where <code>"matern3_2"</code> is set as default.</p>
</dd>
<dt><code>split_direction_criterion</code></dt><dd><p>A string that indicates which spitting criterion to use. The options are:
</p>

<ul>
<li> <p><code>"max_spread"</code>: Split along the direction which has the largest data spread.
</p>
</li>
<li> <p><code>"min_lengthscale"</code>: split along the direction with the smallest length-scale hyperparameter from the local GP.
</p>
</li>
<li> <p><code>"max_spread_per_lengthscale"</code>: Split along the direction with the largest data spread relative to the corresponding GP length-scale hyperparameter.
</p>
</li>
<li> <p><code>"max_corr"</code>: Split along the direction where the input data is most strongly correlated with the target variable.
</p>
</li>
<li> <p><code>"principal_component"</code>: Split along the first principal component.
</p>
</li></ul>

<p>The default value is <code>"max_spread_per_lengthscale"</code>.</p>
</dd>
<dt><code>split_position_criterion</code></dt><dd><p>A string indicating how the split position along the split direction should be set. Possible values are (<code>"median"</code> and <code>"mean"</code>). The default is <code>"median"</code>.</p>
</dd>
<dt><code>shape_decay</code></dt><dd><p>A string specifying how the probability function for a point to be assigned to the left leaf should fall off in the overlap region. The available options are a linear shape (<code>"linear"</code>), an exponential shape (<code>"exponential"</code>) or a Gaussian shape (<code>"gaussian"</code>). Another option is to select no overlap region. This can be achieved by selecting <code>"deterministic"</code> or to set <code>theta</code> to 0. The default is <code>"linear"</code>.</p>
</dd>
<dt><code>use_empirical_error</code></dt><dd><p>If TRUE, the uncertainty is calibrated using recent data points. The default value is TRUE.
</p>
<p>The most recent 25 observations are used to ensure that the prediction uncertainty yields approximately 68 % coverage. This coverage is only achieved if <code>theta = 0</code> (also together with <code>gradual_split = TRUE</code>) is used. Nevertheless, the coverage will be closer to 68 % than it would be without calibration. The prediction uncertainties at the beginning are conservative and become less conservative with increasing number of input points.</p>
</dd>
<dt><code>use_reference_gp</code></dt><dd><p>If TRUE, the covariance parameters determined for the GP in node 0 will be used for all subsequent GPs. The default is <code>FALSE</code>.</p>
</dd>
<dt><code>min_abs_y_err</code></dt><dd><p>Minimum absolute error assumed for y data. The default value is 0.</p>
</dd>
<dt><code>min_rel_y_err</code></dt><dd><p>Minimum relative error assumed for y data. The default value is <code>100 * .Machine$double.eps</code>.</p>
</dd>
<dt><code>min_abs_node_pred_err</code></dt><dd><p>Minimum absolute error on the prediction from a single node. The default value is 0.</p>
</dd>
<dt><code>min_rel_node_pred_err</code></dt><dd><p>Minimum relative error on the prediction from a single node. The default value is <code>100 * .Machine$double.eps</code>.</p>
</dd>
<dt><code>prob_min_theta</code></dt><dd><p>Minimum probability after which the overlap shape gets truncated (either towards 0 or 1). The default value is 0.01.</p>
</dd>
<dt><code>add_buffer_in_prediction</code></dt><dd><p>If TRUE, points in the data buffers are added to the GP before prediction. They are added into a temporarily created GP which contains the not yet included points. The GP in the node is not yet updated. The default is <code>FALSE</code>.</p>
</dd>
<dt><code>x_dim</code></dt><dd><p>Dimensionality of input points. It is set once the first point is received through the <a href="#method-GPTree-update"><code>update()</code></a> or <a href="#method-GPTree-joint_prediction"><code>joint_prediction()</code></a> method. It needs to be specified if <code>min_ranges</code> should be different from default.</p>
</dd>
<dt><code>min_ranges</code></dt><dd><p>Smallest allowed input data spread (per dimension) before node splitting stops. It is set to its default <code>min_ranges = rep(0.0, x_dim)</code> once the first point is received through the <a href="#method-GPTree-update"><code>update()</code></a> method. <code>x_dim</code> needs to be specified by the user if it should be different from the default.</p>
</dd>
<dt><code>max_cond_num</code></dt><dd><p>Add additional noise if the covariance matrix condition number exceeds this value. The default is <code>NULL</code>.</p>
</dd>
<dt><code>max_points</code></dt><dd><p>The maximum number of points the tree is allowed to store. The default value is <code>Inf</code>.
</p>
<p>End of the user-defined input fields.</p>
</dd>
<dt><code>nodes</code></dt><dd><p>A hash to hold the GP tree, using string keys to identify nodes and their position in the tree  (&quot;0&quot;, &quot;00&quot;, &quot;01&quot;, &quot;000&quot;, &quot;001&quot;, &quot;010&quot;, &quot;011&quot;, etc.)</p>
</dd>
<dt><code>leaf_keys</code></dt><dd><p>Stores the keys (&quot;0&quot;, &quot;00&quot;, &quot;01&quot;, &quot;000&quot;, &quot;001&quot;, &quot;010&quot;, &quot;011&quot;, etc.) for the leaves</p>
</dd>
<dt><code>n_points</code></dt><dd><p>Number of points in the tree</p>
</dd>
<dt><code>n_fed</code></dt><dd><p>Number of points fed to the tree</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-GPTree-new"><code>GPTree$new()</code></a>
</p>
</li>
<li> <p><a href="#method-GPTree-add_node"><code>GPTree$add_node()</code></a>
</p>
</li>
<li> <p><a href="#method-GPTree-get_marginal_point_prob"><code>GPTree$get_marginal_point_prob()</code></a>
</p>
</li>
<li> <p><a href="#method-GPTree-update"><code>GPTree$update()</code></a>
</p>
</li>
<li> <p><a href="#method-GPTree-get_data_split_table"><code>GPTree$get_data_split_table()</code></a>
</p>
</li>
<li> <p><a href="#method-GPTree-joint_prediction"><code>GPTree$joint_prediction()</code></a>
</p>
</li>
<li> <p><a href="#method-GPTree-clone"><code>GPTree$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-GPTree-new"></a>



<h4>Method <code>new()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>GPTree$new(
  Nbar = 1000,
  retrain_buffer_length = Nbar,
  gradual_split = TRUE,
  theta = 0,
  wrapper = "DiceKriging",
  gp_control = list(covtype = "matern3_2"),
  split_direction_criterion = "max_spread_per_lengthscale",
  split_position_criterion = "median",
  shape_decay = "linear",
  use_empirical_error = TRUE,
  use_reference_gp = FALSE,
  min_abs_y_err = 0,
  min_rel_y_err = 100 * .Machine$double.eps,
  min_abs_node_pred_err = 0,
  min_rel_node_pred_err = 100 * .Machine$double.eps,
  prob_min_theta = 0.01,
  add_buffer_in_prediction = FALSE,
  x_dim = 0,
  min_ranges = NULL,
  max_cond_num = NULL,
  max_points = Inf
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>Nbar</code></dt><dd><p>Maximum number of data points for each GP in a leaf before it is split. The default value is 1000.</p>
</dd>
<dt><code>retrain_buffer_length</code></dt><dd><p>Size of the retrain buffer. The buffer for a each node collects data points and holds them until the buffer length is reached. Then the GP in the node is updated with the data in the buffer. For a fixed <code>Nbar</code>, higher values for <code>retrain_buffer_length</code> lead to faster run time (less frequent retraining), but the trade-off is a temporary reduced prediction accuracy. We advise that the choice for <code>retrain_buffer_length</code> should depend on the chosen <code>Nbar</code>. By default <code>retrain_buffer_length</code> is set equal to <code>Nbar</code>.</p>
</dd>
<dt><code>gradual_split</code></dt><dd><p>If TRUE, gradual splitting is used for splitting. The default value is TRUE.</p>
</dd>
<dt><code>theta</code></dt><dd><p>Overlap ratio between two leafs in the split direction. The default value is 0.</p>
</dd>
<dt><code>wrapper</code></dt><dd><p>A string that indicates which GP implementation should be used. The current version includes wrappers for the packages <code>"DiceKriging"</code> and <code>"mlegp"</code>. The default setting is <code>"DiceKriging"</code>.</p>
</dd>
<dt><code>gp_control</code></dt><dd><p>A <code>list</code> of control parameter that is forwarded to the wrapper. Here, the covariance function is specified. <code>DiceKriging</code> allows for the following kernels, passed as string: <code>"gauss"</code>, <code>"matern5_2"</code>, <code>"matern3_2"</code>, <code>"exp"</code>, <code>"powexp"</code> where <code>"matern3_2"</code> is set as default.</p>
</dd>
<dt><code>split_direction_criterion</code></dt><dd><p>A string that indicates which spitting criterion to use. The options are:
</p>

<ul>
<li> <p><code>"max_spread"</code>: Split along the direction which has the largest data spread.
</p>
</li>
<li> <p><code>"min_lengthscale"</code>: split along the direction with the smallest length-scale hyperparameter from the local GP.
</p>
</li>
<li> <p><code>"max_spread_per_lengthscale"</code>: Split along the direction with the largest data spread relative to the corresponding GP length-scale hyperparameter.
</p>
</li>
<li> <p><code>"max_corr"</code>: Split along the direction where the input data is most strongly correlated with the target variable.
</p>
</li>
<li> <p><code>"principal_component"</code>: Split along the first principal component.
</p>
</li></ul>

<p>The default value is <code>"max_spread_per_lengthscale"</code>.</p>
</dd>
<dt><code>split_position_criterion</code></dt><dd><p>A string indicating how the split position along the split direction should be set. Possible values are (<code>"median"</code> and <code>"mean"</code>). The default is <code>"median"</code>.</p>
</dd>
<dt><code>shape_decay</code></dt><dd><p>A string specifying how the probability function for a point to be assigned to the left leaf should fall off in the overlap region. The available options are a linear shape (<code>"linear"</code>), an exponential shape (<code>"exponential"</code>) or a Gaussian shape (<code>"gaussian"</code>). Another option is to select no overlap region. This can be achieved by selecting <code>"deterministic"</code> or to set <code>theta</code> to 0. The default is <code>"linear"</code>.</p>
</dd>
<dt><code>use_empirical_error</code></dt><dd><p>If TRUE, the uncertainty is calibrated using recent data points. The default value is TRUE.
</p>
<p>The most recent 25 observations are used to ensure that the prediction uncertainty yields approximately 68 % coverage. This coverage is only achieved if <code>theta = 0</code> (also together with <code>gradual_split = TRUE</code>) is used. Nevertheless, the coverage will be closer to 68 % than it would be without calibration. The prediction uncertainties at the beginning are conservative and become less conservative with increasing number of input points.</p>
</dd>
<dt><code>use_reference_gp</code></dt><dd><p>If TRUE, the covariance parameters determined for the GP in node 0 will be used for all subsequent GPs. The default is <code>FALSE</code>.</p>
</dd>
<dt><code>min_abs_y_err</code></dt><dd><p>Minimum absolute error assumed for y data. The default value is 0.</p>
</dd>
<dt><code>min_rel_y_err</code></dt><dd><p>Minimum relative error assumed for y data. The default value is <code>100 * .Machine$double.eps</code>.</p>
</dd>
<dt><code>min_abs_node_pred_err</code></dt><dd><p>Minimum absolute error on the prediction from a single node. The default value is 0.</p>
</dd>
<dt><code>min_rel_node_pred_err</code></dt><dd><p>Minimum relative error on the prediction from a single node. The default value is <code>100 * .Machine$double.eps</code>.</p>
</dd>
<dt><code>prob_min_theta</code></dt><dd><p>Minimum probability after which the overlap shape gets truncated (either towards 0 or 1). The default value is 0.01.</p>
</dd>
<dt><code>add_buffer_in_prediction</code></dt><dd><p>If TRUE, points in the data buffers are added to the GP before prediction. They are added into a temporarily created GP which contains the not yet included points. The GP in the node is not yet updated. The default is <code>FALSE</code>.</p>
</dd>
<dt><code>x_dim</code></dt><dd><p>Dimensionality of input points. It is set once the first point is received through the <code>update</code> method. It needs to be specified if <code>min_ranges</code> should be different from default.</p>
</dd>
<dt><code>min_ranges</code></dt><dd><p>Smallest allowed input data spread (per dimension) before node splitting stops. It is set to its default <code>min_ranges = rep(0.0, x_dim)</code> once the first point is received through the <code>update</code> method. <code>x_dim</code> needs to be specified by the user if it should be different from the default.</p>
</dd>
<dt><code>max_cond_num</code></dt><dd><p>Add additional noise if the covariance matrix condition number exceeds this value. The default is <code>NULL</code>.</p>
</dd>
<dt><code>max_points</code></dt><dd><p>The maximum number of points the tree is allowed to store. The default value is <code>Inf</code>.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A new GPTree object. Tree-specific parameters are listed in this object. The field <code>nodes</code> contains a <a href="hash.html#topic+hash">hash</a> with all <a href="#topic+GPNode">GPNode</a>s and information related to nodes. The nodes in turn contain the local GPs. Nodes that have been split no longer contain a GP.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>set.seed(42)
## Use the 1d toy data set from Higdon (2002)
X &lt;- as.matrix(sample(seq(0, 10, length.out = 31)))
y &lt;- sin(2 * pi * X / 10) + 0.2 * sin(2 * pi * X / 2.5)
y_variance &lt;- rep(0.1**2, 31)

## Initialize a tree with Nbar = 15, retrain_buffer_length = 15, use_empirical_error = FALSE,
## and default parameters otherwise
gptree &lt;- GPTree$new(Nbar = 15, retrain_buffer_length = 15, use_empirical_error = FALSE)

## For the purpose of this example, we simulate the data stream through a simple for loop.
## In actual applications, the input stream comes from e.g. a differential evolutionary scanner.
## We follow the procedure in the associated paper, thus letting the tree make a prediction
## first before we update the tree with the point.
for (i in 1:nrow(X)) {
y_pred_with_err = gptree$joint_prediction(X[i,], return_std = TRUE)
## Update the tree with the true (X,y) pair
gptree$update(X[i,], y[i], y_variance[i])
}

## In the following, we go over different initializations of the tree
## 1. The same tree as before, but using the package mlegp:
## Note: since the default for gp_control is gp_control = list(covtype = "matern3_2"),
## we set gp_control to an empty list when using mlegp.
gptree &lt;- GPTree$new(Nbar = 15, retrain_buffer_length = 15, use_empirical_error = FALSE,
wrapper = "mlegp", gp_control = list())

## 2. Minimum working example:
gptree &lt;- GPTree$new()

## 3. Fully specified example corresponding to the default settings
## Here, we choose to specify x_dim and min_ranges so that they correspond to the default values.
## If we do not specifiy them here, they will be automatically specified once
## the update or predict method is called.
gptree &lt;- GPTree$new(Nbar = 1000, retrain_buffer_length = 1000,
gradual_split = TRUE, theta = 0, wrapper = "DiceKriging",
gp_control = list(covtype = "matern3_2"),
split_direction_criterion = "max_spread_per_lengthscale", split_position_criterion = "mean",
shape_decay = "linear", use_empirical_error = TRUE, 
use_reference_gp = FALSE, min_abs_y_err = 0, min_rel_y_err = 100 * .Machine$double.eps,
min_abs_node_pred_err = 0, min_rel_node_pred_err = 100 * .Machine$double.eps,
prob_min_theta = 0.01, add_buffer_in_prediction = FALSE, x_dim = ncol(X),
min_ranges = rep(0.0, ncol(X)), max_cond_num = NULL, max_points = Inf)
</pre>
</div>


<hr>
<a id="method-GPTree-add_node"></a>



<h4>Method <code>add_node()</code></h4>

<p>Add a new GPNode to the tree. IS EXPECTED TO NOT BE CALLED BY THE USER
</p>


<h5>Usage</h5>

<div class="r"><pre>GPTree$add_node(key)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>key</code></dt><dd><p>Key of the new leaf</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GPTree-get_marginal_point_prob"></a>



<h4>Method <code>get_marginal_point_prob()</code></h4>

<p>Marginal probability for point x to belong to node with given key. IS EXPECTED TO NOT BE CALLED BY THE USER
</p>


<h5>Usage</h5>

<div class="r"><pre>GPTree$get_marginal_point_prob(x, key)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x</code></dt><dd><p>Single input data point from the data stream; has to be a vector with length equal to x_dim</p>
</dd>
<dt><code>key</code></dt><dd><p>Key of the node</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>Returns the marginal probability for point x to belong to node with given key
</p>


<hr>
<a id="method-GPTree-update"></a>



<h4>Method <code>update()</code></h4>

<p>Assigns the given input point x with target variable y and associated variance y_var to a node and updates the tree accordingly
</p>


<h5>Usage</h5>

<div class="r"><pre>GPTree$update(x, y, y_var = 0, retrain_node = TRUE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x</code></dt><dd><p>Most recent single input data point from the data stream; has to be a vector with length equal to x_dim</p>
</dd>
<dt><code>y</code></dt><dd><p>Value of target variable at input point x; has to be a one-dimensional matrix or a vector; any further columns will be ignored</p>
</dd>
<dt><code>y_var</code></dt><dd><p>Variance of the target variable; has to be a one-dimensional matrix or vector</p>
</dd>
<dt><code>retrain_node</code></dt><dd><p>If TRUE, the GP node will be retrained after the point is added.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>The methods takes care of both updating an existing node and splitting the parent node into two child nodes. It ensures that the each child node has at least <code>n_points_train_limit</code> in each GP. Further handling of duplicate points is also done here.
</p>


<hr>
<a id="method-GPTree-get_data_split_table"></a>



<h4>Method <code>get_data_split_table()</code></h4>

<p>Generates a table used to distribute data points from a node to two child nodes
</p>


<h5>Usage</h5>

<div class="r"><pre>GPTree$get_data_split_table(current_node)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>current_node</code></dt><dd><p>The GPNode whose data should be distributed</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A matrix object
</p>


<hr>
<a id="method-GPTree-joint_prediction"></a>



<h4>Method <code>joint_prediction()</code></h4>

<p>Compute the joint prediction from all relevant leaves for an input point x
</p>


<h5>Usage</h5>

<div class="r"><pre>GPTree$joint_prediction(x, return_std = TRUE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x</code></dt><dd><p>Single data point for which the predicted joint mean (and standard deviation) is computed; has to be a vector with length equal to x_dim</p>
</dd>
<dt><code>return_std</code></dt><dd><p>If TRUE, the standard error of the prediction is returned</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>We follow Eqs. (5) and (6) in <a href="https://arxiv.org/abs/2006.09446">this paper</a>
</p>



<h5>Returns</h5>

<p>The prediction (and its standard error) for input point x from this tree
</p>


<hr>
<a id="method-GPTree-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>GPTree$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'>
## ------------------------------------------------
## Method `GPTree$new`
## ------------------------------------------------

set.seed(42)
## Use the 1d toy data set from Higdon (2002)
X &lt;- as.matrix(sample(seq(0, 10, length.out = 31)))
y &lt;- sin(2 * pi * X / 10) + 0.2 * sin(2 * pi * X / 2.5)
y_variance &lt;- rep(0.1**2, 31)

## Initialize a tree with Nbar = 15, retrain_buffer_length = 15, use_empirical_error = FALSE,
## and default parameters otherwise
gptree &lt;- GPTree$new(Nbar = 15, retrain_buffer_length = 15, use_empirical_error = FALSE)

## For the purpose of this example, we simulate the data stream through a simple for loop.
## In actual applications, the input stream comes from e.g. a differential evolutionary scanner.
## We follow the procedure in the associated paper, thus letting the tree make a prediction
## first before we update the tree with the point.
for (i in 1:nrow(X)) {
y_pred_with_err = gptree$joint_prediction(X[i,], return_std = TRUE)
## Update the tree with the true (X,y) pair
gptree$update(X[i,], y[i], y_variance[i])
}

## In the following, we go over different initializations of the tree
## 1. The same tree as before, but using the package mlegp:
## Note: since the default for gp_control is gp_control = list(covtype = "matern3_2"),
## we set gp_control to an empty list when using mlegp.
gptree &lt;- GPTree$new(Nbar = 15, retrain_buffer_length = 15, use_empirical_error = FALSE,
wrapper = "mlegp", gp_control = list())

## 2. Minimum working example:
gptree &lt;- GPTree$new()

## 3. Fully specified example corresponding to the default settings
## Here, we choose to specify x_dim and min_ranges so that they correspond to the default values.
## If we do not specifiy them here, they will be automatically specified once
## the update or predict method is called.
gptree &lt;- GPTree$new(Nbar = 1000, retrain_buffer_length = 1000,
gradual_split = TRUE, theta = 0, wrapper = "DiceKriging",
gp_control = list(covtype = "matern3_2"),
split_direction_criterion = "max_spread_per_lengthscale", split_position_criterion = "mean",
shape_decay = "linear", use_empirical_error = TRUE, 
use_reference_gp = FALSE, min_abs_y_err = 0, min_rel_y_err = 100 * .Machine$double.eps,
min_abs_node_pred_err = 0, min_rel_node_pred_err = 100 * .Machine$double.eps,
prob_min_theta = 0.01, add_buffer_in_prediction = FALSE, x_dim = ncol(X),
min_ranges = rep(0.0, ncol(X)), max_cond_num = NULL, max_points = Inf)
</code></pre>

<hr>
<h2 id='WrappedDiceKrigingGP'>R6 class WrappedDiceKrigingGP</h2><span id='topic+WrappedDiceKrigingGP'></span>

<h3>Description</h3>

<p>Contains the GP created by <a href="DiceKriging.html#topic+km">DiceKriging::km</a> from the <code>DiceKriging</code> package
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>gp</code></dt><dd><p>The DiceKriging GP object (<a href="DiceKriging.html#topic+km">DiceKriging::km</a> in the <code>DiceKriging</code> manual)</p>
</dd>
<dt><code>X_buffer</code></dt><dd><p>Buffer matrix to collect x points until first GP can be trained</p>
</dd>
<dt><code>y_buffer</code></dt><dd><p>Buffer vector to collect y points until first GP can be trained</p>
</dd>
<dt><code>y_var_buffer</code></dt><dd><p>Buffer vector to collect variance of y points until first GP can be trained</p>
</dd>
<dt><code>add_y_var</code></dt><dd><p>Small additional variance used to keep the covariance matrix condition number under control</p>
</dd>
<dt><code>n_points_train_limit</code></dt><dd><p>Number of points needed before we can create the GP</p>
</dd>
<dt><code>n_points</code></dt><dd><p>The number of collected points belonging to this GP</p>
</dd>
<dt><code>x_dim</code></dt><dd><p>Dimensionality of input points</p>
</dd>
<dt><code>gp_control</code></dt><dd><p>A list of GP implementation-specific options, passed directly to the wrapped GP implementation</p>
</dd>
<dt><code>init_covpars</code></dt><dd><p>The initial covariance parameters when training the DiceKriging GP object in self@gp</p>
</dd>
<dt><code>estimate_covpars</code></dt><dd><p>If TRUE, the parameters are estimated by the package. Otherwise, the parameters from init_covpars are taken</p>
</dd>
<dt><code>retrain_buffer_length</code></dt><dd><p>Only retrain after this many new points have been added to the buffer</p>
</dd>
<dt><code>retrain_buffer_counter</code></dt><dd><p>Counter for the number of new points added since last retraining</p>
</dd>
<dt><code>add_buffer_in_prediction</code></dt><dd><p>If TRUE, points in the data buffers are added to the GP before prediction. They are added into a temporarily created GP which contains the not yet included points. The GP in the node is not yet updated.</p>
</dd>
<dt><code>X_shared</code></dt><dd><p>Matrix with x points that this GP shares with the GP in the sibling node</p>
</dd>
<dt><code>y_shared</code></dt><dd><p>Vector of y points that this GP shares with the GP in the sibling node</p>
</dd>
<dt><code>y_var_shared</code></dt><dd><p>Vector of y_var points that this GP shares with the GP in the sibling node</p>
</dd>
<dt><code>n_shared_points</code></dt><dd><p>The number of own points shared with the GP in the sibling node</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-WrappedDiceKrigingGP-new"><code>WrappedDiceKrigingGP$new()</code></a>
</p>
</li>
<li> <p><a href="#method-WrappedDiceKrigingGP-update_init_covpars"><code>WrappedDiceKrigingGP$update_init_covpars()</code></a>
</p>
</li>
<li> <p><a href="#method-WrappedDiceKrigingGP-get_lengthscales"><code>WrappedDiceKrigingGP$get_lengthscales()</code></a>
</p>
</li>
<li> <p><a href="#method-WrappedDiceKrigingGP-get_X_data"><code>WrappedDiceKrigingGP$get_X_data()</code></a>
</p>
</li>
<li> <p><a href="#method-WrappedDiceKrigingGP-get_y_data"><code>WrappedDiceKrigingGP$get_y_data()</code></a>
</p>
</li>
<li> <p><a href="#method-WrappedDiceKrigingGP-get_y_var_data"><code>WrappedDiceKrigingGP$get_y_var_data()</code></a>
</p>
</li>
<li> <p><a href="#method-WrappedDiceKrigingGP-get_cov_mat"><code>WrappedDiceKrigingGP$get_cov_mat()</code></a>
</p>
</li>
<li> <p><a href="#method-WrappedDiceKrigingGP-update_add_y_var"><code>WrappedDiceKrigingGP$update_add_y_var()</code></a>
</p>
</li>
<li> <p><a href="#method-WrappedDiceKrigingGP-store_point"><code>WrappedDiceKrigingGP$store_point()</code></a>
</p>
</li>
<li> <p><a href="#method-WrappedDiceKrigingGP-delete_buffers"><code>WrappedDiceKrigingGP$delete_buffers()</code></a>
</p>
</li>
<li> <p><a href="#method-WrappedDiceKrigingGP-train"><code>WrappedDiceKrigingGP$train()</code></a>
</p>
</li>
<li> <p><a href="#method-WrappedDiceKrigingGP-predict"><code>WrappedDiceKrigingGP$predict()</code></a>
</p>
</li>
<li> <p><a href="#method-WrappedDiceKrigingGP-delete_gp"><code>WrappedDiceKrigingGP$delete_gp()</code></a>
</p>
</li>
<li> <p><a href="#method-WrappedDiceKrigingGP-create_DiceKriging_gp"><code>WrappedDiceKrigingGP$create_DiceKriging_gp()</code></a>
</p>
</li>
<li> <p><a href="#method-WrappedDiceKrigingGP-call_DiceKriging_predict"><code>WrappedDiceKrigingGP$call_DiceKriging_predict()</code></a>
</p>
</li>
<li> <p><a href="#method-WrappedDiceKrigingGP-clone"><code>WrappedDiceKrigingGP$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-WrappedDiceKrigingGP-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a new WrappedDiceKrigingGP object
</p>


<h5>Usage</h5>

<div class="r"><pre>WrappedDiceKrigingGP$new(
  X,
  y,
  y_var,
  gp_control,
  init_covpars,
  retrain_buffer_length,
  add_buffer_in_prediction,
  estimate_covpars = TRUE,
  X_shared = NULL,
  y_shared = NULL,
  y_var_shared = NULL
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>X</code></dt><dd><p>Input data matrix with x_dim columns and at maximum Nbar rows. Is used to create the first iteration of the local GP.</p>
</dd>
<dt><code>y</code></dt><dd><p>Value of target variable at input point x; has to be a one-dimensional matrix or a vector; any further columns will be ignored</p>
</dd>
<dt><code>y_var</code></dt><dd><p>Variance of the target variable; has to be a one-dimensional matrix or vector</p>
</dd>
<dt><code>gp_control</code></dt><dd><p>A list of GP implementation-specific options, passed directly to the wrapped GP implementation</p>
</dd>
<dt><code>init_covpars</code></dt><dd><p>Initial covariance parameters of the local GP</p>
</dd>
<dt><code>retrain_buffer_length</code></dt><dd><p>Only retrain when the number of buffer points or collected points exceeds this value</p>
</dd>
<dt><code>add_buffer_in_prediction</code></dt><dd><p>If TRUE, points in the data buffers are added to the GP before prediction. They are added into a temporarily created GP which contains the not yet included points. The GP in the node is not yet updated.</p>
</dd>
<dt><code>estimate_covpars</code></dt><dd><p>If TRUE, the parameters are estimated by the package. Otherwise, the parameters from init_covpars are taken</p>
</dd>
<dt><code>X_shared</code></dt><dd><p>Matrix with x points that this GP shares with the GP in the sibling node</p>
</dd>
<dt><code>y_shared</code></dt><dd><p>Vector of y points that this GP shares with the GP in the sibling node</p>
</dd>
<dt><code>y_var_shared</code></dt><dd><p>Vector of y_var points that this GP shares with the GP in the sibling node</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A new WrappedDiceKrigingGP object. Besides the local GP, information on the shared points and those stored in the buffer are collected. For more information on the GP, consult the method <a href="DiceKriging.html#topic+km">DiceKriging::km</a> in the <code>DiceKriging</code> package.
</p>


<hr>
<a id="method-WrappedDiceKrigingGP-update_init_covpars"></a>



<h4>Method <code>update_init_covpars()</code></h4>

<p>Stores the initial covariance parameters (length-scales, standard deviation and trend coefficients) of the GP in the field <code>init_covpars</code>
</p>


<h5>Usage</h5>

<div class="r"><pre>WrappedDiceKrigingGP$update_init_covpars()</pre></div>


<hr>
<a id="method-WrappedDiceKrigingGP-get_lengthscales"></a>



<h4>Method <code>get_lengthscales()</code></h4>

<p>Retrieves the length-scales of the kernel of the local GP
</p>


<h5>Usage</h5>

<div class="r"><pre>WrappedDiceKrigingGP$get_lengthscales()</pre></div>


<hr>
<a id="method-WrappedDiceKrigingGP-get_X_data"></a>



<h4>Method <code>get_X_data()</code></h4>

<p>Retrieves the design matrix X
</p>


<h5>Usage</h5>

<div class="r"><pre>WrappedDiceKrigingGP$get_X_data(include_shared = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>include_shared</code></dt><dd><p>If TRUE, shared points between this GP and its sibling GP are included</p>
</dd>
</dl>

</div>


<hr>
<a id="method-WrappedDiceKrigingGP-get_y_data"></a>



<h4>Method <code>get_y_data()</code></h4>

<p>Retrieves the response
</p>


<h5>Usage</h5>

<div class="r"><pre>WrappedDiceKrigingGP$get_y_data(include_shared = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>include_shared</code></dt><dd><p>If TRUE, shared points between this GP and its sibling GP are included</p>
</dd>
</dl>

</div>


<hr>
<a id="method-WrappedDiceKrigingGP-get_y_var_data"></a>



<h4>Method <code>get_y_var_data()</code></h4>

<p>Retrieves the individual variances from the response
</p>


<h5>Usage</h5>

<div class="r"><pre>WrappedDiceKrigingGP$get_y_var_data(include_shared = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>include_shared</code></dt><dd><p>If TRUE, shared points between this GP and its sibling GP are included</p>
</dd>
</dl>

</div>


<hr>
<a id="method-WrappedDiceKrigingGP-get_cov_mat"></a>



<h4>Method <code>get_cov_mat()</code></h4>

<p>Retrieves the covariance matrix
</p>


<h5>Usage</h5>

<div class="r"><pre>WrappedDiceKrigingGP$get_cov_mat()</pre></div>



<h5>Returns</h5>

<p>the covariance matrix
</p>


<hr>
<a id="method-WrappedDiceKrigingGP-update_add_y_var"></a>



<h4>Method <code>update_add_y_var()</code></h4>

<p>Method for updating add_y_var based on a bound for the covariance matrix condition number, based on <a href="https://arxiv.org/abs/1602.00853">this paper</a>, Section 5.4
</p>


<h5>Usage</h5>

<div class="r"><pre>WrappedDiceKrigingGP$update_add_y_var(max_cond_num)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>max_cond_num</code></dt><dd><p>Max allowed condition number</p>
</dd>
</dl>

</div>


<hr>
<a id="method-WrappedDiceKrigingGP-store_point"></a>



<h4>Method <code>store_point()</code></h4>

<p>Stores a new point into the respective buffer method
</p>


<h5>Usage</h5>

<div class="r"><pre>WrappedDiceKrigingGP$store_point(
  x,
  y,
  y_var,
  shared = FALSE,
  remove_shared = TRUE
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x</code></dt><dd><p>Single input data point from the data stream; has to be a vector or row matrix with length equal to x_dim</p>
</dd>
<dt><code>y</code></dt><dd><p>Value of target variable at input point x; has to be a one-dimensional matrix or a vector; any further columns will be ignored</p>
</dd>
<dt><code>y_var</code></dt><dd><p>Variance of the target variable; has to be a one-dimensional matrix or vector</p>
</dd>
<dt><code>shared</code></dt><dd><p>If TRUE, this point is shared between this GP and its sibling GP</p>
</dd>
<dt><code>remove_shared</code></dt><dd><p>If TRUE, the last of the shared points is removed</p>
</dd>
</dl>

</div>


<hr>
<a id="method-WrappedDiceKrigingGP-delete_buffers"></a>



<h4>Method <code>delete_buffers()</code></h4>

<p>Method for clearing the buffers
</p>


<h5>Usage</h5>

<div class="r"><pre>WrappedDiceKrigingGP$delete_buffers()</pre></div>


<hr>
<a id="method-WrappedDiceKrigingGP-train"></a>



<h4>Method <code>train()</code></h4>

<p>Method for (re)creating / (re)training the GP
</p>


<h5>Usage</h5>

<div class="r"><pre>WrappedDiceKrigingGP$train(do_buffer_check = TRUE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>do_buffer_check</code></dt><dd><p>If TRUE, only train the GP if the number of stored points is larger than retrain_buffer_length</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>TRUE if training was performed, otherwise FALSE
</p>


<hr>
<a id="method-WrappedDiceKrigingGP-predict"></a>



<h4>Method <code>predict()</code></h4>

<p>Method for prediction
</p>


<h5>Usage</h5>

<div class="r"><pre>WrappedDiceKrigingGP$predict(x, return_std = TRUE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x</code></dt><dd><p>Single data point for which the predicted mean (and standard deviation) is computed; has to be a vector or row matrix with length equal to x_dim</p>
</dd>
<dt><code>return_std</code></dt><dd><p>If TRUE, the standard error is returned in addition to the prediction</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>Prediction for input point x
</p>


<hr>
<a id="method-WrappedDiceKrigingGP-delete_gp"></a>



<h4>Method <code>delete_gp()</code></h4>

<p>Method to delete the GP object in self$gp
</p>


<h5>Usage</h5>

<div class="r"><pre>WrappedDiceKrigingGP$delete_gp()</pre></div>


<hr>
<a id="method-WrappedDiceKrigingGP-create_DiceKriging_gp"></a>



<h4>Method <code>create_DiceKriging_gp()</code></h4>

<p>Method for calling the 'km' function in DiceKriging to create a GP object, stored in self$gp
</p>


<h5>Usage</h5>

<div class="r"><pre>WrappedDiceKrigingGP$create_DiceKriging_gp(X, y, y_var)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>X</code></dt><dd><p>Input data matrix with x_dim columns and at maximum Nbar rows for the local GP.</p>
</dd>
<dt><code>y</code></dt><dd><p>Value of target variable at input point x; has to be a one-dimensional matrix or a vector; any further columns will be ignored</p>
</dd>
<dt><code>y_var</code></dt><dd><p>Variance of the target variable; has to be a one-dimensional matrix or vector</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>TRUE
</p>


<hr>
<a id="method-WrappedDiceKrigingGP-call_DiceKriging_predict"></a>



<h4>Method <code>call_DiceKriging_predict()</code></h4>

<p>Method for calling the 'predict' function in DiceKriging
</p>


<h5>Usage</h5>

<div class="r"><pre>WrappedDiceKrigingGP$call_DiceKriging_predict(x, use_gp = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x</code></dt><dd><p>Single data point for which the predicted mean (and standard deviation) is computed; has to be a vector with length equal to x_dim</p>
</dd>
<dt><code>use_gp</code></dt><dd><p>optional user-defined GP which is evaluated instead of the local GP</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>The predictions for x from the specified GP, by default the local GP
</p>


<hr>
<a id="method-WrappedDiceKrigingGP-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>WrappedDiceKrigingGP$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>



<hr>
<h2 id='WrappedGP'>R6 class WrappedGP</h2><span id='topic+WrappedGP'></span>

<h3>Description</h3>

<p>Contains the GP created by a user-defined GP package
</p>


<h3>Details</h3>

<p>This is effectively a dummy wrapper based on the wrapper for the mlegp package (see <a href="#topic+WrappedmlegpGP">WrappedmlegpGP</a>). It contains a basic implementation of the wrapper. The vignette offers a tutorial on how to change this wrapper for the new GP package.
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>gp</code></dt><dd><p>The mlegp GP object (<a href="mlegp.html#topic+mlegp">mlegp::mlegp</a> in the <code>mlegp</code> manual)</p>
</dd>
<dt><code>X_buffer</code></dt><dd><p>Buffer matrix to collect x points until first GP can be trained</p>
</dd>
<dt><code>y_buffer</code></dt><dd><p>Buffer vector to collect y points until first GP can be trained</p>
</dd>
<dt><code>y_var_buffer</code></dt><dd><p>Buffer vector to collect variance of y points until first GP can be trained</p>
</dd>
<dt><code>add_y_var</code></dt><dd><p>Small additional variance used to keep the covariance matrix condition number under control</p>
</dd>
<dt><code>n_points_train_limit</code></dt><dd><p>Number of points needed before we can create the GP</p>
</dd>
<dt><code>n_points</code></dt><dd><p>The number of collected points belonging to this GP</p>
</dd>
<dt><code>x_dim</code></dt><dd><p>Dimensionality of input points</p>
</dd>
<dt><code>gp_control</code></dt><dd><p>A list of GP implementation-specific options, passed directly to the wrapped GP implementation</p>
</dd>
<dt><code>init_covpars</code></dt><dd><p>The initial covariance parameters when training the mlegp GP object in self@gp</p>
</dd>
<dt><code>estimate_covpars</code></dt><dd><p>If TRUE, the parameters are estimated by the package. Otherwise, the parameters from init_covpars are taken</p>
</dd>
<dt><code>retrain_buffer_length</code></dt><dd><p>Only retrain after this many new points have been added to the buffer</p>
</dd>
<dt><code>retrain_buffer_counter</code></dt><dd><p>Counter for the number of new points added since last retraining</p>
</dd>
<dt><code>add_buffer_in_prediction</code></dt><dd><p>If TRUE, points in the data buffers are added to the GP before prediction. They are added into a temporarily created GP which contains the not yet included points. The GP in the node is not yet updated.</p>
</dd>
<dt><code>X_shared</code></dt><dd><p>Matrix with x points that this GP shares with the GP in the sibling node</p>
</dd>
<dt><code>y_shared</code></dt><dd><p>Vector of y points that this GP shares with the GP in the sibling node</p>
</dd>
<dt><code>y_var_shared</code></dt><dd><p>Vector of y_var points that this GP shares with the GP in the sibling node</p>
</dd>
<dt><code>n_shared_points</code></dt><dd><p>The number of own points shared with the GP in the sibling node</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-WrappedGP-new"><code>WrappedGP$new()</code></a>
</p>
</li>
<li> <p><a href="#method-WrappedGP-update_init_covpars"><code>WrappedGP$update_init_covpars()</code></a>
</p>
</li>
<li> <p><a href="#method-WrappedGP-get_lengthscales"><code>WrappedGP$get_lengthscales()</code></a>
</p>
</li>
<li> <p><a href="#method-WrappedGP-get_X_data"><code>WrappedGP$get_X_data()</code></a>
</p>
</li>
<li> <p><a href="#method-WrappedGP-get_y_data"><code>WrappedGP$get_y_data()</code></a>
</p>
</li>
<li> <p><a href="#method-WrappedGP-get_y_var_data"><code>WrappedGP$get_y_var_data()</code></a>
</p>
</li>
<li> <p><a href="#method-WrappedGP-get_cov_mat"><code>WrappedGP$get_cov_mat()</code></a>
</p>
</li>
<li> <p><a href="#method-WrappedGP-update_add_y_var"><code>WrappedGP$update_add_y_var()</code></a>
</p>
</li>
<li> <p><a href="#method-WrappedGP-store_point"><code>WrappedGP$store_point()</code></a>
</p>
</li>
<li> <p><a href="#method-WrappedGP-delete_buffers"><code>WrappedGP$delete_buffers()</code></a>
</p>
</li>
<li> <p><a href="#method-WrappedGP-delete_gp"><code>WrappedGP$delete_gp()</code></a>
</p>
</li>
<li> <p><a href="#method-WrappedGP-call_create_gp"><code>WrappedGP$call_create_gp()</code></a>
</p>
</li>
<li> <p><a href="#method-WrappedGP-call_predict"><code>WrappedGP$call_predict()</code></a>
</p>
</li>
<li> <p><a href="#method-WrappedGP-train"><code>WrappedGP$train()</code></a>
</p>
</li>
<li> <p><a href="#method-WrappedGP-predict"><code>WrappedGP$predict()</code></a>
</p>
</li>
<li> <p><a href="#method-WrappedGP-clone"><code>WrappedGP$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-WrappedGP-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a new WrappedmlegpGP object
</p>


<h5>Usage</h5>

<div class="r"><pre>WrappedGP$new(
  X,
  y,
  y_var,
  gp_control,
  init_covpars,
  retrain_buffer_length,
  add_buffer_in_prediction,
  estimate_covpars = TRUE,
  X_shared = NULL,
  y_shared = NULL,
  y_var_shared = NULL
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>X</code></dt><dd><p>Input data matrix with x_dim columns and at maximum Nbar rows. Is used to create the first iteration of the local GP.</p>
</dd>
<dt><code>y</code></dt><dd><p>Value of target variable at input point x; has to be a one-dimensional matrix or a vector; any further columns will be ignored</p>
</dd>
<dt><code>y_var</code></dt><dd><p>Variance of the target variable; has to be a one-dimensional matrix or vector</p>
</dd>
<dt><code>gp_control</code></dt><dd><p>A list of GP implementation-specific options, passed directly to the wrapped GP implementation</p>
</dd>
<dt><code>init_covpars</code></dt><dd><p>Initial covariance parameters of the local GP</p>
</dd>
<dt><code>retrain_buffer_length</code></dt><dd><p>Only retrain when the number of buffer points or collected points exceeds this value</p>
</dd>
<dt><code>add_buffer_in_prediction</code></dt><dd><p>If TRUE, points in the data buffers are added to the GP before prediction. They are added into a temporarily created GP which contains the not yet included points. The GP in the node is not yet updated.</p>
</dd>
<dt><code>estimate_covpars</code></dt><dd><p>If TRUE, the parameters are estimated by the package. Otherwise, the parameters from init_covpars are taken</p>
</dd>
<dt><code>X_shared</code></dt><dd><p>Matrix with x points that this GP shares with the GP in the sibling node</p>
</dd>
<dt><code>y_shared</code></dt><dd><p>Vector of y points that this GP shares with the GP in the sibling node</p>
</dd>
<dt><code>y_var_shared</code></dt><dd><p>Vector of y_var points that this GP shares with the GP in the sibling node</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A new WrappedGP object. Besides the local GP, information on the shared points and those stored in the buffer are collected. For more information on the GP, consult the respective met in the GP package.
</p>


<hr>
<a id="method-WrappedGP-update_init_covpars"></a>



<h4>Method <code>update_init_covpars()</code></h4>

<p>Stores the initial covariance parameters (length-scales, standard deviation and trend coefficients) of the GP in the field <code>init_covpars</code>
</p>


<h5>Usage</h5>

<div class="r"><pre>WrappedGP$update_init_covpars()</pre></div>


<hr>
<a id="method-WrappedGP-get_lengthscales"></a>



<h4>Method <code>get_lengthscales()</code></h4>

<p>Retrieves the length-scales of the kernel of the local GP
</p>


<h5>Usage</h5>

<div class="r"><pre>WrappedGP$get_lengthscales()</pre></div>


<hr>
<a id="method-WrappedGP-get_X_data"></a>



<h4>Method <code>get_X_data()</code></h4>

<p>Retrieves the design matrix X
</p>


<h5>Usage</h5>

<div class="r"><pre>WrappedGP$get_X_data(include_shared = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>include_shared</code></dt><dd><p>If TRUE, shared points between this GP and its sibling GP are included</p>
</dd>
</dl>

</div>


<hr>
<a id="method-WrappedGP-get_y_data"></a>



<h4>Method <code>get_y_data()</code></h4>

<p>Retrieves the response
</p>


<h5>Usage</h5>

<div class="r"><pre>WrappedGP$get_y_data(include_shared = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>include_shared</code></dt><dd><p>If TRUE, shared points between this GP and its sibling GP are included</p>
</dd>
</dl>

</div>


<hr>
<a id="method-WrappedGP-get_y_var_data"></a>



<h4>Method <code>get_y_var_data()</code></h4>

<p>Retrieves the individual variances from the response
</p>


<h5>Usage</h5>

<div class="r"><pre>WrappedGP$get_y_var_data(include_shared = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>include_shared</code></dt><dd><p>If TRUE, shared points between this GP and its sibling GP are included</p>
</dd>
</dl>

</div>


<hr>
<a id="method-WrappedGP-get_cov_mat"></a>



<h4>Method <code>get_cov_mat()</code></h4>

<p>Retrieves the covariance matrix
</p>


<h5>Usage</h5>

<div class="r"><pre>WrappedGP$get_cov_mat()</pre></div>



<h5>Returns</h5>

<p>the covariance matrix
</p>


<hr>
<a id="method-WrappedGP-update_add_y_var"></a>



<h4>Method <code>update_add_y_var()</code></h4>

<p>Method for updating add_y_var based on a bound for the covariance matrix condition number, based on <a href="https://arxiv.org/abs/1602.00853">this paper</a>, Section 5.4
</p>


<h5>Usage</h5>

<div class="r"><pre>WrappedGP$update_add_y_var(max_cond_num)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>max_cond_num</code></dt><dd><p>Max allowed condition number</p>
</dd>
</dl>

</div>


<hr>
<a id="method-WrappedGP-store_point"></a>



<h4>Method <code>store_point()</code></h4>

<p>Stores a new point into the respective buffer method
</p>


<h5>Usage</h5>

<div class="r"><pre>WrappedGP$store_point(x, y, y_var, shared = FALSE, remove_shared = TRUE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x</code></dt><dd><p>Single input data point from the data stream; has to be a vector or row matrix with length equal to x_dim</p>
</dd>
<dt><code>y</code></dt><dd><p>Value of target variable at input point x; has to be a one-dimensional matrix or a vector; any further columns will be ignored</p>
</dd>
<dt><code>y_var</code></dt><dd><p>Variance of the target variable; has to be a one-dimensional matrix or vector</p>
</dd>
<dt><code>shared</code></dt><dd><p>If TRUE, this point is shared between this GP and its sibling GP</p>
</dd>
<dt><code>remove_shared</code></dt><dd><p>If TRUE, the last of the shared points is removed</p>
</dd>
</dl>

</div>


<hr>
<a id="method-WrappedGP-delete_buffers"></a>



<h4>Method <code>delete_buffers()</code></h4>

<p>Method for clearing the buffers
</p>


<h5>Usage</h5>

<div class="r"><pre>WrappedGP$delete_buffers()</pre></div>


<hr>
<a id="method-WrappedGP-delete_gp"></a>



<h4>Method <code>delete_gp()</code></h4>

<p>Method to delete the GP object in self$gp
</p>


<h5>Usage</h5>

<div class="r"><pre>WrappedGP$delete_gp()</pre></div>


<hr>
<a id="method-WrappedGP-call_create_gp"></a>



<h4>Method <code>call_create_gp()</code></h4>

<p>Method for calling the 'mlegp' function in mlegp to create a GP object, stored in self$gp
</p>


<h5>Usage</h5>

<div class="r"><pre>WrappedGP$call_create_gp(X, y, y_var)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>X</code></dt><dd><p>Input data matrix with x_dim columns and at maximum Nbar rows for the local GP.</p>
</dd>
<dt><code>y</code></dt><dd><p>Value of target variable at input point x; has to be a one-dimensional matrix or a vector; any further columns will be ignored</p>
</dd>
<dt><code>y_var</code></dt><dd><p>Variance of the target variable; has to be a one-dimensional matrix or vector</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>TRUE
</p>


<hr>
<a id="method-WrappedGP-call_predict"></a>



<h4>Method <code>call_predict()</code></h4>

<p>Method for calling the 'predict' function in mlegp
</p>


<h5>Usage</h5>

<div class="r"><pre>WrappedGP$call_predict(x, use_gp = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x</code></dt><dd><p>Single data point for which the predicted mean (and standard deviation) is computed; has to be a vector with length equal to x_dim</p>
</dd>
<dt><code>use_gp</code></dt><dd><p>Optional user-defined GP which is evaluated instead of the local GP</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>The predictions for x from the specified GP, by default the local GP. The output needs to be a list with fields mean and sd for the prediction and prediction error, respectively.
</p>


<hr>
<a id="method-WrappedGP-train"></a>



<h4>Method <code>train()</code></h4>

<p>Method for (re)creating / (re)training the GP
</p>


<h5>Usage</h5>

<div class="r"><pre>WrappedGP$train(do_buffer_check = TRUE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>do_buffer_check</code></dt><dd><p>If TRUE, only train the GP if the number of stored points is larger than retrain_buffer_length</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>TRUE if training was performed, otherwise FALSE
</p>


<hr>
<a id="method-WrappedGP-predict"></a>



<h4>Method <code>predict()</code></h4>

<p>Method for prediction
</p>


<h5>Usage</h5>

<div class="r"><pre>WrappedGP$predict(x, return_std = TRUE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x</code></dt><dd><p>Single data point for which the predicted mean (and standard deviation) is computed; has to be a vector or row matrix with length equal to x_dim</p>
</dd>
<dt><code>return_std</code></dt><dd><p>If TRUE, the standard error is returned in addition to the prediction</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>Prediction for input point x
</p>


<hr>
<a id="method-WrappedGP-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>WrappedGP$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>



<hr>
<h2 id='WrappedmlegpGP'>R6 class WrappedmlegpGP</h2><span id='topic+WrappedmlegpGP'></span>

<h3>Description</h3>

<p>Contains the GP created by <a href="mlegp.html#topic+mlegp">mlegp::mlegp</a> from the <code>mlegp</code> package
</p>


<h3>Details</h3>

<p>This package is by default not able to include individual uncertainties for input points. For this reason, all fields related to <code>y_var</code> are not used when updating the GP. No covariance kernel can be specified either. This implementation also assumes a vector for <code>y</code> (and not a matrix with multiple columns). Moreover, since no parameters can be specified for the GP, we will only update the GP parameters due to internal dependencies, but not use <code>init_covpars</code>.
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>gp</code></dt><dd><p>The mlegp GP object (<a href="mlegp.html#topic+mlegp">mlegp::mlegp</a> in the <code>mlegp</code> manual)</p>
</dd>
<dt><code>X_buffer</code></dt><dd><p>Buffer matrix to collect x points until first GP can be trained</p>
</dd>
<dt><code>y_buffer</code></dt><dd><p>Buffer vector to collect y points until first GP can be trained</p>
</dd>
<dt><code>y_var_buffer</code></dt><dd><p>Buffer vector to collect variance of y points until first GP can be trained</p>
</dd>
<dt><code>add_y_var</code></dt><dd><p>Small additional variance used to keep the covariance matrix condition number under control</p>
</dd>
<dt><code>n_points_train_limit</code></dt><dd><p>Number of points needed before we can create the GP</p>
</dd>
<dt><code>n_points</code></dt><dd><p>The number of collected points belonging to this GP</p>
</dd>
<dt><code>x_dim</code></dt><dd><p>Dimensionality of input points</p>
</dd>
<dt><code>gp_control</code></dt><dd><p>A list of GP implementation-specific options, passed directly to the wrapped GP implementation</p>
</dd>
<dt><code>init_covpars</code></dt><dd><p>The initial covariance parameters when training the mlegp GP object in self@gp</p>
</dd>
<dt><code>estimate_covpars</code></dt><dd><p>If TRUE, the parameters are estimated by the package. Otherwise, the parameters from init_covpars are taken</p>
</dd>
<dt><code>retrain_buffer_length</code></dt><dd><p>Only retrain after this many new points have been added to the buffer</p>
</dd>
<dt><code>retrain_buffer_counter</code></dt><dd><p>Counter for the number of new points added since last retraining</p>
</dd>
<dt><code>add_buffer_in_prediction</code></dt><dd><p>If TRUE, points in the data buffers are added to the GP before prediction. They are added into a temporarily created GP which contains the not yet included points. The GP in the node is not yet updated.</p>
</dd>
<dt><code>X_shared</code></dt><dd><p>Matrix with x points that this GP shares with the GP in the sibling node</p>
</dd>
<dt><code>y_shared</code></dt><dd><p>Vector of y points that this GP shares with the GP in the sibling node</p>
</dd>
<dt><code>y_var_shared</code></dt><dd><p>Vector of y_var points that this GP shares with the GP in the sibling node</p>
</dd>
<dt><code>n_shared_points</code></dt><dd><p>The number of own points shared with the GP in the sibling node</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-WrappedmlegpGP-new"><code>WrappedmlegpGP$new()</code></a>
</p>
</li>
<li> <p><a href="#method-WrappedmlegpGP-update_init_covpars"><code>WrappedmlegpGP$update_init_covpars()</code></a>
</p>
</li>
<li> <p><a href="#method-WrappedmlegpGP-get_lengthscales"><code>WrappedmlegpGP$get_lengthscales()</code></a>
</p>
</li>
<li> <p><a href="#method-WrappedmlegpGP-get_X_data"><code>WrappedmlegpGP$get_X_data()</code></a>
</p>
</li>
<li> <p><a href="#method-WrappedmlegpGP-get_y_data"><code>WrappedmlegpGP$get_y_data()</code></a>
</p>
</li>
<li> <p><a href="#method-WrappedmlegpGP-get_y_var_data"><code>WrappedmlegpGP$get_y_var_data()</code></a>
</p>
</li>
<li> <p><a href="#method-WrappedmlegpGP-get_cov_mat"><code>WrappedmlegpGP$get_cov_mat()</code></a>
</p>
</li>
<li> <p><a href="#method-WrappedmlegpGP-update_add_y_var"><code>WrappedmlegpGP$update_add_y_var()</code></a>
</p>
</li>
<li> <p><a href="#method-WrappedmlegpGP-store_point"><code>WrappedmlegpGP$store_point()</code></a>
</p>
</li>
<li> <p><a href="#method-WrappedmlegpGP-delete_buffers"><code>WrappedmlegpGP$delete_buffers()</code></a>
</p>
</li>
<li> <p><a href="#method-WrappedmlegpGP-train"><code>WrappedmlegpGP$train()</code></a>
</p>
</li>
<li> <p><a href="#method-WrappedmlegpGP-predict"><code>WrappedmlegpGP$predict()</code></a>
</p>
</li>
<li> <p><a href="#method-WrappedmlegpGP-delete_gp"><code>WrappedmlegpGP$delete_gp()</code></a>
</p>
</li>
<li> <p><a href="#method-WrappedmlegpGP-create_mlegp_gp"><code>WrappedmlegpGP$create_mlegp_gp()</code></a>
</p>
</li>
<li> <p><a href="#method-WrappedmlegpGP-call_mlegp_predict"><code>WrappedmlegpGP$call_mlegp_predict()</code></a>
</p>
</li>
<li> <p><a href="#method-WrappedmlegpGP-clone"><code>WrappedmlegpGP$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-WrappedmlegpGP-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a new WrappedmlegpGP object
</p>


<h5>Usage</h5>

<div class="r"><pre>WrappedmlegpGP$new(
  X,
  y,
  y_var,
  gp_control,
  init_covpars,
  retrain_buffer_length,
  add_buffer_in_prediction,
  estimate_covpars = TRUE,
  X_shared = NULL,
  y_shared = NULL,
  y_var_shared = NULL
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>X</code></dt><dd><p>Input data matrix with x_dim columns and at maximum Nbar rows. Is used to create the first iteration of the local GP.</p>
</dd>
<dt><code>y</code></dt><dd><p>Value of target variable at input point x; has to be a one-dimensional matrix or a vector; any further columns will be ignored</p>
</dd>
<dt><code>y_var</code></dt><dd><p>Variance of the target variable; has to be a one-dimensional matrix or vector</p>
</dd>
<dt><code>gp_control</code></dt><dd><p>A list of GP implementation-specific options, passed directly to the wrapped GP implementation</p>
</dd>
<dt><code>init_covpars</code></dt><dd><p>Initial covariance parameters of the local GP</p>
</dd>
<dt><code>retrain_buffer_length</code></dt><dd><p>Only retrain when the number of buffer points or collected points exceeds this value</p>
</dd>
<dt><code>add_buffer_in_prediction</code></dt><dd><p>If TRUE, points in the data buffers are added to the GP before prediction. They are added into a temporarily created GP which contains the not yet included points. The GP in the node is not yet updated.</p>
</dd>
<dt><code>estimate_covpars</code></dt><dd><p>If TRUE, the parameters are estimated by the package. Otherwise, the parameters from init_covpars are taken</p>
</dd>
<dt><code>X_shared</code></dt><dd><p>Matrix with x points that this GP shares with the GP in the sibling node</p>
</dd>
<dt><code>y_shared</code></dt><dd><p>Vector of y points that this GP shares with the GP in the sibling node</p>
</dd>
<dt><code>y_var_shared</code></dt><dd><p>Vector of y_var points that this GP shares with the GP in the sibling node</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A new WrappedmlegpGP object. Besides the local GP, information on the shared points and those stored in the buffer are collected. For more information on the GP, consult the method <a href="mlegp.html#topic+mlegp">mlegp::mlegp</a> in the <code>mlegp</code> package.
</p>


<hr>
<a id="method-WrappedmlegpGP-update_init_covpars"></a>



<h4>Method <code>update_init_covpars()</code></h4>

<p>Stores the initial covariance parameters (length-scales, standard deviation and trend coefficients) of the GP in the field <code>init_covpars</code>
</p>


<h5>Usage</h5>

<div class="r"><pre>WrappedmlegpGP$update_init_covpars()</pre></div>


<hr>
<a id="method-WrappedmlegpGP-get_lengthscales"></a>



<h4>Method <code>get_lengthscales()</code></h4>

<p>Retrieves the length-scales of the kernel of the local GP
</p>


<h5>Usage</h5>

<div class="r"><pre>WrappedmlegpGP$get_lengthscales()</pre></div>


<hr>
<a id="method-WrappedmlegpGP-get_X_data"></a>



<h4>Method <code>get_X_data()</code></h4>

<p>Retrieves the design matrix X
</p>


<h5>Usage</h5>

<div class="r"><pre>WrappedmlegpGP$get_X_data(include_shared = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>include_shared</code></dt><dd><p>If TRUE, shared points between this GP and its sibling GP are included</p>
</dd>
</dl>

</div>


<hr>
<a id="method-WrappedmlegpGP-get_y_data"></a>



<h4>Method <code>get_y_data()</code></h4>

<p>Retrieves the response
</p>


<h5>Usage</h5>

<div class="r"><pre>WrappedmlegpGP$get_y_data(include_shared = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>include_shared</code></dt><dd><p>If TRUE, shared points between this GP and its sibling GP are included</p>
</dd>
</dl>

</div>


<hr>
<a id="method-WrappedmlegpGP-get_y_var_data"></a>



<h4>Method <code>get_y_var_data()</code></h4>

<p>Retrieves the individual variances from the response
</p>


<h5>Usage</h5>

<div class="r"><pre>WrappedmlegpGP$get_y_var_data(include_shared = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>include_shared</code></dt><dd><p>If TRUE, shared points between this GP and its sibling GP are included</p>
</dd>
</dl>

</div>


<hr>
<a id="method-WrappedmlegpGP-get_cov_mat"></a>



<h4>Method <code>get_cov_mat()</code></h4>

<p>Retrieves the covariance matrix
</p>


<h5>Usage</h5>

<div class="r"><pre>WrappedmlegpGP$get_cov_mat()</pre></div>



<h5>Returns</h5>

<p>the covariance matrix
</p>


<hr>
<a id="method-WrappedmlegpGP-update_add_y_var"></a>



<h4>Method <code>update_add_y_var()</code></h4>

<p>Method for updating add_y_var based on a bound for the covariance matrix condition number, based on <a href="https://arxiv.org/abs/1602.00853">this paper</a>, Section 5.4
</p>


<h5>Usage</h5>

<div class="r"><pre>WrappedmlegpGP$update_add_y_var(max_cond_num)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>max_cond_num</code></dt><dd><p>Max allowed condition number</p>
</dd>
</dl>

</div>


<hr>
<a id="method-WrappedmlegpGP-store_point"></a>



<h4>Method <code>store_point()</code></h4>

<p>Stores a new point into the respective buffer method
</p>


<h5>Usage</h5>

<div class="r"><pre>WrappedmlegpGP$store_point(x, y, y_var, shared = FALSE, remove_shared = TRUE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x</code></dt><dd><p>Single input data point from the data stream; has to be a vector or row matrix with length equal to x_dim</p>
</dd>
<dt><code>y</code></dt><dd><p>Value of target variable at input point x; has to be a one-dimensional matrix or a vector; any further columns will be ignored</p>
</dd>
<dt><code>y_var</code></dt><dd><p>Variance of the target variable; has to be a one-dimensional matrix or vector</p>
</dd>
<dt><code>shared</code></dt><dd><p>If TRUE, this point is shared between this GP and its sibling GP</p>
</dd>
<dt><code>remove_shared</code></dt><dd><p>If TRUE, the last of the shared points is removed</p>
</dd>
</dl>

</div>


<hr>
<a id="method-WrappedmlegpGP-delete_buffers"></a>



<h4>Method <code>delete_buffers()</code></h4>

<p>Method for clearing the buffers
</p>


<h5>Usage</h5>

<div class="r"><pre>WrappedmlegpGP$delete_buffers()</pre></div>


<hr>
<a id="method-WrappedmlegpGP-train"></a>



<h4>Method <code>train()</code></h4>

<p>Method for (re)creating / (re)training the GP
</p>


<h5>Usage</h5>

<div class="r"><pre>WrappedmlegpGP$train(do_buffer_check = TRUE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>do_buffer_check</code></dt><dd><p>If TRUE, only train the GP if the number of stored points is larger than retrain_buffer_length</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>TRUE if training was performed, otherwise FALSE
</p>


<hr>
<a id="method-WrappedmlegpGP-predict"></a>



<h4>Method <code>predict()</code></h4>

<p>Method for prediction
</p>


<h5>Usage</h5>

<div class="r"><pre>WrappedmlegpGP$predict(x, return_std = TRUE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x</code></dt><dd><p>Single data point for which the predicted mean (and standard deviation) is computed; has to be a vector or row matrix with length equal to x_dim</p>
</dd>
<dt><code>return_std</code></dt><dd><p>If TRUE, the standard error is returned in addition to the prediction</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>Prediction for input point x
</p>


<hr>
<a id="method-WrappedmlegpGP-delete_gp"></a>



<h4>Method <code>delete_gp()</code></h4>

<p>Method to delete the GP object in self$gp
</p>


<h5>Usage</h5>

<div class="r"><pre>WrappedmlegpGP$delete_gp()</pre></div>


<hr>
<a id="method-WrappedmlegpGP-create_mlegp_gp"></a>



<h4>Method <code>create_mlegp_gp()</code></h4>

<p>Method for calling the 'mlegp' function in mlegp to create a GP object, stored in self$gp
</p>


<h5>Usage</h5>

<div class="r"><pre>WrappedmlegpGP$create_mlegp_gp(X, y, y_var)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>X</code></dt><dd><p>Input data matrix with x_dim columns and at maximum Nbar rows for the local GP.</p>
</dd>
<dt><code>y</code></dt><dd><p>Value of target variable at input point x; has to be a one-dimensional matrix or a vector; any further columns will be ignored</p>
</dd>
<dt><code>y_var</code></dt><dd><p>Variance of the target variable; has to be a one-dimensional matrix or vector</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>TRUE
</p>


<hr>
<a id="method-WrappedmlegpGP-call_mlegp_predict"></a>



<h4>Method <code>call_mlegp_predict()</code></h4>

<p>Method for calling the 'predict' function in mlegp
</p>


<h5>Usage</h5>

<div class="r"><pre>WrappedmlegpGP$call_mlegp_predict(x, use_gp = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x</code></dt><dd><p>Single data point for which the predicted mean (and standard deviation) is computed; has to be a vector with length equal to x_dim</p>
</dd>
<dt><code>use_gp</code></dt><dd><p>Optional user-defined GP which is evaluated instead of the local GP</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>The predictions for x from the specified GP, by default the local GP. The output needs to be a list with fields mean and sd for the prediction and prediction error, respectively.
</p>


<hr>
<a id="method-WrappedmlegpGP-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>WrappedmlegpGP$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>



</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
